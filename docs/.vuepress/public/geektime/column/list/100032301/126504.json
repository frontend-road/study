{"id":126504,"title":"加餐 | JMQ的Broker是如何异步处理消息的？","content":"<p>你好，我是李玥。</p><p>我们的课程更新到进阶篇之后，通过评论区的留言，我看到有一些同学不太理解，为什么在进阶篇中要讲这些“看起来和消息队列关系不大的”内容呢？</p><p>在这里，我跟你分享一下这门课程的设计思路。我们这门课程的名称是“消息队列高手课”，我希望你在学习完这门课程之后，不仅仅只是成为一个使用消息队列的高手，而是<strong>设计和实现</strong>消息队列的高手。所以我们在设计课程的时候，分了基础篇、进阶篇和案例篇三部分。</p><p>基础篇中我们给大家讲解消息队列的原理和一些使用方法，重点是让大家学会使用消息队列。</p><p>你在进阶篇中，我们课程设计的重点是讲解实现消息队列必备的技术知识，通过分析源码讲解消息队列的实现原理。<strong>希望你通过进阶篇的学习能够掌握到设计、实现消息队列所必备的知识和技术，这些知识和技术也是设计所有高性能、高可靠的分布式系统都需要具备的。</strong></p><p>进阶篇的上半部分，我们每一节课一个专题，来讲解设计实现一个高性能消息队列，必备的技术和知识。这里面每节课中讲解的技术点，不仅可以用来设计消息队列，同学们在设计日常的应用系统中也一定会用得到。</p><p>前几天我在极客时间直播的时候也跟大家透露过，由我所在的京东基础架构团队开发的消息队列JMQ，它的综合性能要显著优于目前公认性能非常好的Kafka。虽然在开发JMQ的过程中有很多的创新，但是对于性能的优化这块，并没有什么全新的划时代的新技术，JMQ之所以能做到这样的极致性能，靠的就是合理地设计和正确地使用已有的这些通用的底层技术和优化技巧。我把这些技术和知识点加以提炼和总结，放在进阶篇的上半部分中。</p><!-- [[[read_end]]] --><p>进阶篇的下半部分，我们主要通过分析源码的方式，来学习优秀开源消息队列产品中的一些实现原理和它们的设计思想。</p><p>在最后的案例篇，我会和大家一起，利用进阶篇中学习的知识，一起来开发一个简单的RPC框架。为什么我们要开发一个RPC框架，而不是一个消息队列？这里面就是希望大家不只是机械的去学习，仅仅是我告诉这个问题怎么解决，你就只是学会了这个问题怎么解决，而是能做到真正理解原理，掌握知识和技术，并且能融会贯通，灵活地去使用。只有这样，你才是真的“学会了”。</p><p>有的同学在看了进阶篇中已更新的这几节课程之后，觉得只讲技术原理不过瘾，希望能看到这些技术是如何在消息队列中应用并落地的，看到具体的实现和代码，所以我以京东JMQ为例，将这些基础技术点在消息队列实现中的应用讲解一下。</p><h2>JMQ的Broker是如何异步处理消息的？</h2><p>对于消息队列的Broker，它最核心的两个流程就是接收生产者发来的消息，以及给消费者发送消息。后者的业务逻辑相对比较简单，影响消息队列性能的关键，就是消息生产的这个业务流程。在JMQ中，经过优化后的消息生产流程，实测它每秒钟可以处理超过100万次请求。</p><p>我们在之前的课程中首先讲了异步的设计思想，这里给你分享一下我在设计这个流程时，是如何来将异步的设计落地的。</p><p>消息生产的流程需要完成的功能是这样的：</p><p><img src=\"https://static001.geekbang.org/resource/image/a7/ba/a7589a7b4525e107f9b82de133bc43ba.jpg?wh=4124*2895\" alt=\"\"></p><ul>\n<li>首先，生产者发送一批消息给Broker的主节点；</li>\n<li>Broker收到消息之后，会对消息做一系列的解析、检查等处理；</li>\n<li>然后，把消息复制给所有的Broker从节点，并且需要把消息写入到磁盘中；</li>\n<li>主节点收到大多数从节点的复制成功确认后，给生产者回响应告知消息发送成功。</li>\n</ul><p>由于使用各种异步框架或多或少都会有一些性能损失，所以我在设计这个流程的时候，没有使用任何的异步框架，而是自行设计一组互相配合的处理线程来实现，但使用的异步设计思想和我们之前课程中所讲的是一样的。</p><p>对于这个流程，我们设计的线程模型是这样的：</p><p><img src=\"https://static001.geekbang.org/resource/image/c9/fc/c9bf75cafc246f4ace9d36831e95e1fc.png?wh=1157*580\" alt=\"\"></p><p>图中白色的细箭头是数据流，蓝色的箭头是控制流，白色的粗箭头代表远程调用。蓝白相间的方框代表的是处理的步骤，我在蓝色方框中标注了这个步骤是在什么线程中执行的。圆角矩形代表的是流程中需要使用的一些关键的数据结构。</p><p>这里我们设计了6组线程，将一个大的流程拆成了6个小流程。并且整个过程完全是异步化的。</p><p>流程的入口在图中的左上角，Broker在收到来自生产者的发消息请求后，会在一个Handler中处理这些请求，这和我们在普通的业务系统中，用Handler接收HTTP请求是一样的，执行Handler中业务逻辑使用的是Netty的IO线程。</p><p>收到请求后，我们在Handler中不做过多的处理，执行必要的检查后，将请求放到一个内存队列中，也就是图中的Requests Queue。请求被放入队列后，Handler的方法就结束了。可以看到，在Handler中只是把请求放到了队列中，没有太多的业务逻辑，这个执行过程是非常快的，所以即使是处理海量的请求，也不会过多的占用IO线程。</p><p>由于要保证消息的有序性，整个流程的大部分过程是不能并发的，只能单线程执行。所以，接下来我们使用一个线程WriteThread从请求队列中按照顺序来获取请求，依次进行解析请求等其他的处理逻辑，最后将消息序列化并写入存储。序列化后的消息会被写入到一个内存缓存中，就是图中的JournalCache，等待后续的处理。</p><p>执行到这里，一条一条的消息已经被转换成一个连续的字节流，每一条消息都在这个字节流中有一个全局唯一起止位置，也就是这条消息的Offset。后续的处理就不用关心字节流中的内容了，只要确保这个字节流能快速正确的被保存和复制就可以了。</p><p>这里面还有一个工作需要完成，就是给生产者回响应，但在这一步，消息既没有落盘，也没有完成复制，还不能给客户端返回响应，所以我们把待返回的响应按照顺序放到一个内存的链表Pending Callbacks中，并记录每个请求中的消息对应的Offset。</p><p>然后，我们有2个线程，FlushThread和ReplicationThread，这两个线程是并行执行的，分别负责批量异步进行刷盘和复制，刷盘和复制又分别是2个比较复杂的流程，我们暂时不展开讲。刷盘线程不停地将新写入Journal Cache的字节流写到磁盘上，完成一批数据的刷盘，它就会更新一个刷盘位置的内存变量，确保这个刷盘位置之前数据都已经安全的写入磁盘中。复制线程的逻辑也是类似的，同样维护了一个复制位置的内存变量。</p><p>最后，我们设计了一组专门用于发送响应的线程ReponseThreads，在刷盘位置或者复制位置更新后，去检查待返回的响应链表Pending Callbacks，根据QOS级别的设置（因为不同QOS基本对发送成功的定义不一样，有的设置需要消息写入磁盘才算成功，有的需要复制完成才算成功），将刷盘位置或者复制位置之前所有响应，以及已经超时的响应，利用这组线程ReponseThreads异步并行的发送给各个客户端。</p><p>这样就完成了消息生产这个流程。整个流程中，除了JournalCache的加载和卸载需要对文件加锁以外，没有用到其他的锁。每个小流程都不会等待其他流程的共享资源，也就不用互相等待资源（没有数据需要处理时等待上游流程提供数据的情况除外），并且只要有数据就能第一时间处理。</p><p>这个流程中，最核心的部分在于WriteThread执行处理的这个步骤，对每条消息进行处理的这些业务逻辑，都只能在WriteThread中单线程执行，虽然这里面干了很多的事儿，但是我们确保这些逻辑中，没有缓慢的磁盘和网络IO，也没有使用任何的锁来等待资源，全部都是内存操作，这样即使单线程可以非常快速地执行所有的业务逻辑。</p><p><strong>这个里面有很重要的几点优化：</strong></p><ul>\n<li>一是我们使用异步设计，把刷盘和复制这两部分比较慢的操作从这个流程中分离出去异步执行；</li>\n<li>第二是，我们使用了一个写缓存Journal Cache将一个写磁盘的操作，转换成了一个写内存的操作，来提升数据写入的性能，关于如何使用缓存，后面我会专门用一节课来讲；</li>\n<li>第三是，这个处理的全流程是近乎无锁的设计，避免了线程因为等待锁导致的阻塞；</li>\n<li>第四是，我们把回复响应这个需要等待资源的操作，也异步放到其他的线程中去执行。</li>\n</ul><p>你看，一个看起来很简单的接收请求写入数据并回响应的流程，需要涉及的技术包括：<strong>异步的设计、缓存设计、锁的正确使用、线程协调、序列化和内存管理</strong>，等等。你需要对这些技术都有深入的理解，并合理地使用，才能在确保逻辑正确、数据准确的前提下，做到极致的性能。这也是为什么我们在课程的进阶篇中，用这么多节课来逐一讲解这些“看起来和消息队列没什么关系”的知识点和技术。</p><p>我也希望同学们在学习这些知识点的时候，不仅仅只是记住了，能说出来，用于回答面试问题，还要能真正理解这些知识点和技术背后深刻的思想，并使用在日常的设计和开发过程中。</p><p>比如说，在面试的时候，很多同学都可以很轻松地讲JVM内存结构，也知道怎么用jstat、jmap、jstack这些工具来查看虚拟机的状态。但是，当我给出一个有内存溢出的问题程序和源代码，让他来分析原因并改正的时候，却很少有人能给出正确的答案。在我看来，对于JVM这些基础知识，这样的同学他以为自己已经掌握了，但是，无法领会技术背后的思想，做不到学以致用，那还只是别人知识，不是你的。</p><p>再比如，我下面要说的这个俩大爷的作业，你是真的花时间把代码写出来了，还只是在脑子想了想怎么做，就算完成了呢？</p><h2>俩大爷的思考题</h2><p>我们在进阶篇的开始，花了4节课的内容，来讲解如何实现高性能的异步网络通信，在《<a href=\"http://time.geekbang.org/column/article/119988\">13 | 传输协议：应用程序之间对话的语言</a>》中，我给大家留了一个思考题：写一个程序，让俩大爷在胡同口遇见10万次并记录下耗时。</p><p>有几个同学在留言区分享了自己的代码，每一个同学分享的代码我都仔细读过，有的作业实现了异步的网络通信，有的作业序列化和协议设计实现得很好，但很遗憾的是，没有一份作业能在序列化、协议设计和异步网络传输这几方面都做到我期望的水平。</p><p>在这个作业中，应用到了我们进阶篇中前四节课讲到的几个知识点：</p><ul>\n<li>使用异步设计的方法；</li>\n<li>异步网络IO；</li>\n<li>专用序列化、反序列化方法；</li>\n<li>设计良好的传输协议；</li>\n<li>双工通信。</li>\n</ul><p>这里面特别是双工通信的方法，大家都没能正确的实现。所以，这些作业的实际执行性能也没能达到一个应有的水平。</p><p>这里，我也给出一个作业的参考实现，我们用Go语言来实现这个作业：</p><p>我们用Go语言来实现这个作业：</p><pre><code>package main\n\nimport (\n\t&quot;encoding/binary&quot;\n\t&quot;fmt&quot;\n\t&quot;io&quot;\n\t&quot;net&quot;\n\t&quot;sync&quot;\n\t&quot;time&quot;\n)\n\nvar zRecvCount = uint32(0) // 张大爷听到了多少句话\nvar lRecvCount = uint32(0) // 李大爷听到了多少句话\nvar total = uint32(100000) // 总共需要遇见多少次\n\nvar z0 = &quot;吃了没，您吶?&quot;\nvar z3 = &quot;嗨！吃饱了溜溜弯儿。&quot;\nvar z5 = &quot;回头去给老太太请安！&quot;\nvar l1 = &quot;刚吃。&quot;\nvar l2 = &quot;您这，嘛去？&quot;\nvar l4 = &quot;有空家里坐坐啊。&quot;\n\nvar liWriteLock sync.Mutex    // 李大爷的写锁\nvar zhangWriteLock sync.Mutex // 张大爷的写锁\n\ntype RequestResponse struct {\n\tSerial  uint32 // 序号\n\tPayload string // 内容\n}\n\n// 序列化RequestResponse，并发送\n// 序列化后的结构如下：\n// \t长度\t4字节\n// \tSerial 4字节\n// \tPayLoad 变长\nfunc writeTo(r *RequestResponse, conn *net.TCPConn, lock *sync.Mutex) {\n\tlock.Lock()\n\tdefer lock.Unlock()\n\tpayloadBytes := []byte(r.Payload)\n\tserialBytes := make([]byte, 4)\n\tbinary.BigEndian.PutUint32(serialBytes, r.Serial)\n\tlength := uint32(len(payloadBytes) + len(serialBytes))\n\tlengthByte := make([]byte, 4)\n\tbinary.BigEndian.PutUint32(lengthByte, length)\n\n\tconn.Write(lengthByte)\n\tconn.Write(serialBytes)\n\tconn.Write(payloadBytes)\n\t// fmt.Println(&quot;发送: &quot; + r.Payload)\n}\n\n// 接收数据，反序列化成RequestResponse\nfunc readFrom(conn *net.TCPConn) (*RequestResponse, error) {\n\tret := &amp;RequestResponse{}\n\tbuf := make([]byte, 4)\n\tif _, err := io.ReadFull(conn, buf); err != nil {\n\t\treturn nil, fmt.Errorf(&quot;读长度故障：%s&quot;, err.Error())\n\t}\n\tlength := binary.BigEndian.Uint32(buf)\n\tif _, err := io.ReadFull(conn, buf); err != nil {\n\t\treturn nil, fmt.Errorf(&quot;读Serial故障：%s&quot;, err.Error())\n\t}\n\tret.Serial = binary.BigEndian.Uint32(buf)\n\tpayloadBytes := make([]byte, length-4)\n\tif _, err := io.ReadFull(conn, payloadBytes); err != nil {\n\t\treturn nil, fmt.Errorf(&quot;读Payload故障：%s&quot;, err.Error())\n\t}\n\tret.Payload = string(payloadBytes)\n\treturn ret, nil\n}\n\n// 张大爷的耳朵\nfunc zhangDaYeListen(conn *net.TCPConn, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\tfor zRecvCount &lt; total*3 {\n\t\tr, err := readFrom(conn)\n\t\tif err != nil {\n\t\t\tfmt.Println(err.Error())\n\t\t\tbreak\n\t\t}\n\t\t// fmt.Println(&quot;张大爷收到：&quot; + r.Payload)\n\t\tif r.Payload == l2 { // 如果收到：您这，嘛去？\n\t\t\tgo writeTo(&amp;RequestResponse{r.Serial, z3}, conn, &amp;zhangWriteLock) // 回复：嗨！吃饱了溜溜弯儿。\n\t\t} else if r.Payload == l4 { // 如果收到：有空家里坐坐啊。\n\t\t\tgo writeTo(&amp;RequestResponse{r.Serial, z5}, conn, &amp;zhangWriteLock) // 回复：回头去给老太太请安！\n\t\t} else if r.Payload == l1 { // 如果收到：刚吃。\n\t\t\t// 不用回复\n\t\t} else {\n\t\t\tfmt.Println(&quot;张大爷听不懂：&quot; + r.Payload)\n\t\t\tbreak\n\t\t}\n\t\tzRecvCount++\n\t}\n}\n\n// 张大爷的嘴\nfunc zhangDaYeSay(conn *net.TCPConn) {\n\tnextSerial := uint32(0)\n\tfor i := uint32(0); i &lt; total; i++ {\n\t\twriteTo(&amp;RequestResponse{nextSerial, z0}, conn, &amp;zhangWriteLock)\n\t\tnextSerial++\n\t}\n}\n\n// 李大爷的耳朵，实现是和张大爷类似的\nfunc liDaYeListen(conn *net.TCPConn, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\tfor lRecvCount &lt; total*3 {\n\t\tr, err := readFrom(conn)\n\t\tif err != nil {\n\t\t\tfmt.Println(err.Error())\n\t\t\tbreak\n\t\t}\n\t\t// fmt.Println(&quot;李大爷收到：&quot; + r.Payload)\n\t\tif r.Payload == z0 { // 如果收到：吃了没，您吶?\n\t\t\twriteTo(&amp;RequestResponse{r.Serial, l1}, conn, &amp;liWriteLock) // 回复：刚吃。\n\t\t} else if r.Payload == z3 {\n\t\t\t// do nothing\n\t\t} else if r.Payload == z5 {\n\t\t\t// do nothing\n\t\t} else {\n\t\t\tfmt.Println(&quot;李大爷听不懂：&quot; + r.Payload)\n\t\t\tbreak\n\t\t}\n\t\tlRecvCount++\n\t}\n}\n\n// 李大爷的嘴\nfunc liDaYeSay(conn *net.TCPConn) {\n\tnextSerial := uint32(0)\n\tfor i := uint32(0); i &lt; total; i++ {\n\t\twriteTo(&amp;RequestResponse{nextSerial, l2}, conn, &amp;liWriteLock)\n\t\tnextSerial++\n\t\twriteTo(&amp;RequestResponse{nextSerial, l4}, conn, &amp;liWriteLock)\n\t\tnextSerial++\n\t}\n}\n\nfunc startServer(wg *sync.WaitGroup) {\n\ttcpAddr, _ := net.ResolveTCPAddr(&quot;tcp&quot;, &quot;127.0.0.1:9999&quot;)\n\ttcpListener, _ := net.ListenTCP(&quot;tcp&quot;, tcpAddr)\n\tdefer tcpListener.Close()\n\tfmt.Println(&quot;张大爷在胡同口等着 ...&quot;)\n\tfor {\n\t\tconn, err := tcpListener.AcceptTCP()\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\tbreak\n\t\t}\n\n\t\tfmt.Println(&quot;碰见一个李大爷:&quot; + conn.RemoteAddr().String())\n\t\tgo zhangDaYeListen(conn, wg)\n\t\tgo zhangDaYeSay(conn)\n\t}\n\n}\n\nfunc startClient(wg *sync.WaitGroup) *net.TCPConn {\n\tvar tcpAddr *net.TCPAddr\n\ttcpAddr, _ = net.ResolveTCPAddr(&quot;tcp&quot;, &quot;127.0.0.1:9999&quot;)\n\tconn, _ := net.DialTCP(&quot;tcp&quot;, nil, tcpAddr)\n\tgo liDaYeListen(conn, wg)\n\tgo liDaYeSay(conn)\n\treturn conn\n}\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\tgo startServer(&amp;wg)\n\ttime.Sleep(time.Second)\n\tconn := startClient(&amp;wg)\n\tt1 := time.Now()\n\twg.Wait()\n\telapsed := time.Since(t1)\n\tconn.Close()\n\tfmt.Println(&quot;耗时: &quot;, elapsed)\n}\n</code></pre><p>在我的Mac执行10万次大约需要不到5秒钟：</p><pre><code>go run hutong.go\n张大爷在胡同口等着 ...\n碰见一个李大爷:127.0.0.1:50136\n耗时:  4.962786896s\n</code></pre><p>在这段程序里面，<strong>我没有对程序做任何特殊的性能优化，只是使用了我们之前四节课中讲到的，上面列出来的那些知识点，完成了一个基本的实现。</strong></p><p>在这段程序中，我们首先定义了RequestResponse这个结构体，代表请求或响应，它包括序号和内容两个字段。readFrom方法的功能是，接收数据，反序列化成RequestResponse。</p><p>协议的设计是这样的：首先用4个字节来标明这个请求的长度，然后用4个字节来保存序号，最后变长的部分就是大爷说的话。这里面用到了使用前置长度的方式来进行断句，这种断句的方式我在之前的课程中专门讲到过。</p><p>这里面我们使用了专有的序列化方法，原因我在之前的课程中重点讲过，专有的序列化方法具备最好的性能，序列化出来的字节数也更少，而我们这个作业比拼的就是性能，所以在这个作业中采用这种序列化方式是最合适的选择。</p><p>zhangDaYeListen和liDaYeListen这两个方法，它们的实现是差不多的，就是接收对方发出的请求，然后给出正确的响应。zhangDaYeSay和liDaYeSay这两个方法的实现也是差不多的，当俩大爷遇见后，就开始不停地说各自的请求，<strong>并不等待对方的响应</strong>，连续说10万次。</p><p>这4个方法，分别在4个不同的协程中并行运行，两收两发，实现了全双工的通信。在这个地方，不少同学还是摆脱不了“一问一答，再问再答”这种人类交流的自然方式对思维的影响，写出来的依然是单工通信的程序，单工通信的性能是远远不如双工通信的，所以，要想做到比较好的网络传输性能，双工通信的方式才是最佳的选择。</p><p>为了避免并发向同一个socket中写入造成数据混乱，我们给俩大爷分别定义了一个写锁，确保每个大爷同一时刻只能有一个协程在发送数据。后面的课程中，我们会专门来讲，如何正确地使用锁。</p><p>最后，我们给张大爷定义为服务端，李大爷定义为客户端，连接建立后，分别开启两个大爷的耳朵和嘴，来完成这10万次遇见。</p><h2>思考题</h2><p>在我给出这个俩大爷作业的实现中，我们可以计算一下，10万次遇见耗时约5秒，平均每秒可以遇见约2万次，<strong>考虑到数据量的大小，这里面仍然有非常大的优化空间。</strong></p><p>请你在充分理解这段代码之后，想一想，还有哪些地方是可以优化的，然后一定要动手把代码改出来，并运行，验证一下你的改进是否真的达到了效果。欢迎你在留言区提出你的改进意见。</p><p>感谢阅读，如果你觉得这篇文章对你有一些启发，也欢迎把它分享给你的朋友。</p><p></p>","comments":[{"had_liked":false,"id":127678,"user_name":"包明","can_delete":false,"product_type":"c1","uid":1086748,"ip_address":"","ucode":"67B9F661613532","user_header":"https://static001.geekbang.org/account/avatar/00/10/95/1c/3cefe42b.jpg","comment_is_top":false,"comment_ctime":1566778629,"is_pvip":false,"replies":[{"id":47515,"content":"你要明白一件事儿，客户端发来一条数据，直到服务端返回给客户端发送成功，这段时间内，数据是允许丢失的。\n\n数据丢失后，客户端收不到发送成功响应，自然会重试。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566868175,"ip_address":"","comment_id":127678,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"Requests Queue 内存级的 怎么做到不丢请求？","like_count":69},{"had_liked":false,"id":127222,"user_name":"青舟","can_delete":false,"product_type":"c1","uid":1192732,"ip_address":"","ucode":"2651482AC0DEC6","user_header":"https://static001.geekbang.org/account/avatar/00/12/33/1c/59a4e803.jpg","comment_is_top":false,"comment_ctime":1566614196,"is_pvip":false,"replies":[{"id":47079,"content":"👍👍👍","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566620279,"ip_address":"","comment_id":127222,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"https:&#47;&#47;github.com&#47;qingzhou413&#47;geektime-mq-rpc.git\n\n使用netty作为网络库，server和client的io线程数都是1，笔记本4核标压2.3G时间2.3秒。","like_count":27,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464384,"discussion_content":"👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566620279,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1905373,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/hxdXcxp1wOKuKhiaibDZdrW8yJ2lcGOtVrRdgHS3Ub3ObeYg0ukh5oOMicuWIUORzDVv2OVfdkfnicfZVvQvqtNMpw/132","nickname":"Geek_aecacf","note":"","ucode":"B2C4E8E049786A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570341,"discussion_content":"请教个问题：这个代码是使用了批量处理的方式，会比普通的快很多，但是使用双工模式是在哪里体现的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651737507,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1899599,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/fc/4f/0a452c94.jpg","nickname":"大毛","note":"","ucode":"93B18287F06706","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1905373,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/hxdXcxp1wOKuKhiaibDZdrW8yJ2lcGOtVrRdgHS3Ub3ObeYg0ukh5oOMicuWIUORzDVv2OVfdkfnicfZVvQvqtNMpw/132","nickname":"Geek_aecacf","note":"","ucode":"B2C4E8E049786A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630997,"discussion_content":"最直接的体现是，readFrom 和 writeTo 中没有保护 net.TCPConn 的锁（writeTo中有锁，但是是为了解决并发写的问题，而不是锁住对net.TCPConn的操作），也就是说，在调用 readFrom 的同时也可以调用 writeTo，这就是读的时候可以写，也就是双工。更具体的，就是在调用 conn.Write(lengthByte) 的时候也可以调用 io.ReadFull(conn, buf)。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699206082,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":570341,"ip_address":"北京","group_id":0},"score":630997,"extra":""}]}]},{"had_liked":false,"id":161690,"user_name":"ub8","can_delete":false,"product_type":"c1","uid":1481811,"ip_address":"","ucode":"0D937C3EAEB781","user_header":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","comment_is_top":false,"comment_ctime":1576297133,"is_pvip":false,"replies":[{"id":62381,"content":"一般简单常用的做法都是在处理request的线程中执行业务逻辑，然后把response返回。\n\n其实从网络层面来看，Request和Response只是客户端和服务端互相发送的两段数据，和服务端处理用什么线程完全没有关系。\n\nRequest和Response如何对应，这个取决于网络传输协议是怎么设计的。这个我们在课程中讲过。\n\n在服务端实现中，可以接受到Request之后，进行异步处理，异步处理完成之后，无论在什么线程中，只要能拿到处理结果构建出Response，通过网络发给客户端就可以了。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1576896514,"ip_address":"","comment_id":161690,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师，文中提到的 “我们把回复响应这个需要等待资源的操作，也异步放到其他的线程中去执行。”；这个是怎么实现的呢？ ResponseThread ,和 RequestThread 是如何对应上的？","like_count":14,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477817,"discussion_content":"一般简单常用的做法都是在处理request的线程中执行业务逻辑，然后把response返回。\n\n其实从网络层面来看，Request和Response只是客户端和服务端互相发送的两段数据，和服务端处理用什么线程完全没有关系。\n\nRequest和Response如何对应，这个取决于网络传输协议是怎么设计的。这个我们在课程中讲过。\n\n在服务端实现中，可以接受到Request之后，进行异步处理，异步处理完成之后，无论在什么线程中，只要能拿到处理结果构建出Response，通过网络发给客户端就可以了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576896514,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299756,"discussion_content":"同一个connection","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597807351,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1749015,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/b0/17/451cb87c.jpg","nickname":"加油！","note":"","ucode":"947E97762DB6EF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542257,"discussion_content":"都异步了怎么还同一个connection，这里老师例子是用go的协程处理的，两者没有什么关系，而Request和Response对应是通过传输协议对应上的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640692287,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":299756,"ip_address":"","group_id":0},"score":542257,"extra":""},{"author":{"id":1592279,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","nickname":"William Ning","note":"","ucode":"4DB8D05E69E5F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1749015,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/b0/17/451cb87c.jpg","nickname":"加油！","note":"","ucode":"947E97762DB6EF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554318,"discussion_content":"老师的回复：\n\n你的大部分理解都没问题，有一个小问题是，维持一个TCP连接并不一定需要占用一个线程。只有在这个连接上执行收发数据的时候，才需要占用线程。收到请求处理完，把请求交给其它线程处理后，当前线程就可以释放了。直到响应生成后，这段时间只维持TCP连接是不需要占用任何线程的。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1646316231,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":542257,"ip_address":"","group_id":0},"score":554318,"extra":""}]}]},{"had_liked":false,"id":127449,"user_name":"linqw","can_delete":false,"product_type":"c1","uid":1134138,"ip_address":"","ucode":"09DCFE98C54DD8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","comment_is_top":false,"comment_ctime":1566718840,"is_pvip":false,"replies":[{"id":47507,"content":"这个流程中处理的数据已经是被分配过的，单个队列的数据。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566867929,"ip_address":"","comment_id":127449,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师有个疑问，帮忙解答下哦，在上面的那个流程图中，WriteThread是单线程从请求队列中获取到消息然后把消息放到journal Cache，开启ReplicationThread、FlushThread进行处理，能否把WriteThread做成分配器了，mq只要保证topic下的队列有序就可以，同一个队列的消息由WriteThread分配给同一个线程进行处理，线程池的形式，线程池中的每个工作线程内部都有个集合保存消息，如果前面没有同一个队列的消息，分配给最空闲的线程进行执行，那这样的话，WriteThread只要分配消息，比如可以对发送过来的消息中要保存的队列属性值进行hash，然后根据hash值判断线程池中的所有线程的消息集合是否有相同队列的消息，有的话分配给同一个线程执行，没有的话最空闲的线程执行，mysql的binlog同步也是有几种这种策略，并发的同步sql，刚开始是基于库，同一个库的sql分配到一个线程执行同步，不同库进行并发，后来是基于redo log的组提交形式，能组提交的sql可以并发的同步，再后来是WRITESET，根据库名、表名、索引（主键和唯一索引）计算hash进行分发策略。","like_count":8,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464496,"discussion_content":"这个流程中处理的数据已经是被分配过的，单个队列的数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566867929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127282,"user_name":"吾皇万岁万岁万万岁","can_delete":false,"product_type":"c1","uid":1135155,"ip_address":"","ucode":"8FDD608729A002","user_header":"https://static001.geekbang.org/account/avatar/00/11/52/33/abf321b7.jpg","comment_is_top":false,"comment_ctime":1566633078,"is_pvip":false,"replies":[{"id":47162,"content":"不会丢，因为数据已经复制到了从节点上，leader宕机后，会重新选举出新的leader（也就是之前的某个follower），这个新leader上是有原leader上的全部数据的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566708652,"ip_address":"","comment_id":127282,"utype":1}],"discussion_count":6,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"请问老师，JMQ在follower节点响应后，就给生产者发送确认消息，此时如果leader节点故障，数据还在JournalCache里面，拿是不是可以认为这部分数据丢失？","like_count":8,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464496,"discussion_content":"这个流程中处理的数据已经是被分配过的，单个队列的数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566867929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155806,"user_name":"李冲","can_delete":false,"product_type":"c1","uid":1254530,"ip_address":"","ucode":"C8C12308B0FDDA","user_header":"https://static001.geekbang.org/account/avatar/00/13/24/82/b5808a60.jpg","comment_is_top":false,"comment_ctime":1574759465,"is_pvip":false,"replies":[{"id":60086,"content":"👍👍👍","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1574903308,"ip_address":"","comment_id":155806,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"借用老师的的go源码经过读，写，去掉锁3次演进，分别在金山云ECS（2核4G）上跑到3.1&#47;2.4&#47;1.4秒的样子。\n最终的文件：https:&#47;&#47;github.com&#47;lichongsw&#47;algorithm&#47;blob&#47;master&#47;duplex_communication_optimization_3_no_write_lock.go","like_count":7,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464412,"discussion_content":"不会丢，因为数据已经复制到了从节点上，leader宕机后，会重新选举出新的leader（也就是之前的某个follower），这个新leader上是有原leader上的全部数据的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566708652,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1115149,"avatar":"https://static001.geekbang.org/account/avatar/00/11/04/0d/3dc5683a.jpg","nickname":"柯察金","note":"","ucode":"F722BF8FCD2C47","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":637884,"discussion_content":"那在 jorunal cache 里面的数据不就丢失了嘛","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1709041039,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":464412,"ip_address":"美国","group_id":0},"score":637884,"extra":""}]},{"author":{"id":1002317,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4b/4d/0239bc19.jpg","nickname":"益军","note":"","ucode":"5629FA62A01F25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6578,"discussion_content":"这里有两个问题哈。1.这个领导者选举期间，客户端写入消息是失败还是重试到其他broker ？ 2.一般这个领导者选举时间需要多久，采用哪种协议实现的？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1566982978,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1009652,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","nickname":"钱","note":"","ucode":"2C92A243A463D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1002317,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4b/4d/0239bc19.jpg","nickname":"益军","note":"","ucode":"5629FA62A01F25","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":20407,"discussion_content":"好问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569311074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":6578,"ip_address":"","group_id":0},"score":20407,"extra":""},{"author":{"id":1802337,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/80/61/ae3bb67c.jpg","nickname":"毛毛虫大帝","note":"","ucode":"1EBB026121C060","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1002317,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4b/4d/0239bc19.jpg","nickname":"益军","note":"","ucode":"5629FA62A01F25","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":175000,"discussion_content":"客户端发往一台broker应该内部有一个最大重试次数，如果超过最大重试仍然失败，会根据之前客户端拉取的该主题分布的集群列表中其他可用broker继续发送，那么故障的broker内部该主题的存储会进行选举，这里并不是broker的选举而是类似存储上的分区或者队列的选举，新leader产生在之前该主题存储的其他broker上的副本上，由选举的term任期值和最大日志复制位置决定，该选举使用raft实现的，复制也是raft协议，选举成功的时间一般是1秒内，follower成为leader的超时时间一般是150ms~300ms之间。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581947975,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":6578,"ip_address":"","group_id":0},"score":175000,"extra":""}]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373131,"discussion_content":"我想了解下leader与follow之间同步数据 是基于半同步还是自己实现了一个复制状态机？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620627862,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143835,"user_name":"李心宇🦉","can_delete":false,"product_type":"c1","uid":1208306,"ip_address":"","ucode":"C381CA80170D5B","user_header":"https://static001.geekbang.org/account/avatar/00/12/6f/f2/1f77b0bd.jpg","comment_is_top":false,"comment_ctime":1571797838,"is_pvip":false,"replies":[{"id":55638,"content":"你的大部分理解都没问题，有一个小问题是，维持一个TCP连接并不一定需要占用一个线程。只有在这个连接上执行收发数据的时候，才需要占用线程。收到请求处理完，把请求交给其它线程处理后，当前线程就可以释放了。直到响应生成后，这段时间只维持TCP连接是不需要占用任何线程的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1571883695,"ip_address":"","comment_id":143835,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师好，我对JMQ的broker接收生产者请求并写入消息的流程有个疑问。\n在处理完数据落盘和多节点数据复制之后，要给生产者回复响应了，这时候broker如何能找到生产者呢？我理解是第一步生产者发送请求建立的TCP连接句柄没有释放，最后再通过这个连接句柄来write响应。这样的话，还是每个连接在得到响应之前不能释放需要占用一个线程啊。请问是怎么做到在第一步接收响应阶段只需要很少的线程的？是不是利用异步非阻塞，在线程里设置大量的协程来处理请求？","like_count":5,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475879,"discussion_content":"👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574903308,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1254530,"avatar":"https://static001.geekbang.org/account/avatar/00/13/24/82/b5808a60.jpg","nickname":"李冲","note":"","ucode":"C8C12308B0FDDA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79925,"discussion_content":"经过再一次批量写优化后，金山云ECS（2核4G）上跑到0.7秒左右。\nhttps://github.com/lichongsw/algorithm/blob/master/duplex_communication_optimization_4_use_write_buf.go","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576124046,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134918,"user_name":"Martin","can_delete":false,"product_type":"c1","uid":1464381,"ip_address":"","ucode":"8EAA93D6432C22","user_header":"https://static001.geekbang.org/account/avatar/00/16/58/3d/4ba98f04.jpg","comment_is_top":false,"comment_ctime":1568952577,"is_pvip":false,"replies":[{"id":51839,"content":"👍👍👍正确写出这个程序差不多就是这个耗时。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1569024325,"ip_address":"","comment_id":134918,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"https:&#47;&#47;github.com&#47;MartinDai&#47;mq-in-action&#47;blob&#47;master&#47;src&#47;main&#47;java&#47;com&#47;doodl6&#47;mq&#47;MeetInRpc.java\n\n基于netty4实现的，Macbook pro 2015款 13寸 测试差不多4.2秒左右，老师帮忙看看哪里还可以有优化空间吗","like_count":5,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467956,"discussion_content":"👍👍👍正确写出这个程序差不多就是这个耗时。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569024325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1577210,"avatar":"https://static001.geekbang.org/account/avatar/00/18/10/fa/d977627e.jpg","nickname":"刘大人","note":"","ucode":"F66AE613E80398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336798,"discussion_content":"同样的代码 我咋跑了 11s","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608704749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127929,"user_name":"南辕北辙","can_delete":false,"product_type":"c1","uid":1214502,"ip_address":"","ucode":"03EC406AE0D591","user_header":"https://static001.geekbang.org/account/avatar/00/12/88/26/b8c53cee.jpg","comment_is_top":false,"comment_ctime":1566811243,"is_pvip":false,"replies":[{"id":47525,"content":"恭喜你学到了😄","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566868614,"ip_address":"","comment_id":127929,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"把老师的代码看了n遍，再用java的原生nio实现了一遍，理解了老师的用心良苦。前二章序列化与网络协议那块的知识，对应代码对于struct的构造，四字节的总长度，四字节的序号，以及变长内容，然后二个大爷在接受到数据以后也是根据这个协议进行取数据。也就对应了序列化以及协议都是自定义的！！二个大爷都懂该怎么从二进制的数据中，提取出对话。","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467956,"discussion_content":"👍👍👍正确写出这个程序差不多就是这个耗时。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569024325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1577210,"avatar":"https://static001.geekbang.org/account/avatar/00/18/10/fa/d977627e.jpg","nickname":"刘大人","note":"","ucode":"F66AE613E80398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336798,"discussion_content":"同样的代码 我咋跑了 11s","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608704749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127781,"user_name":"刘天鹏","can_delete":false,"product_type":"c1","uid":1632015,"ip_address":"","ucode":"FB146250578911","user_header":"https://static001.geekbang.org/account/avatar/00/18/e7/0f/fa840c1b.jpg","comment_is_top":false,"comment_ctime":1566791888,"is_pvip":false,"replies":[{"id":47520,"content":"如果是多个线程并发向同一个socket中写数据，这个锁是必须加的。\n\n比如，A线程发送“123456”，B线程发送“abcd”，如果不加锁，对端收到的可能就成了“12abc345d6”，这种数据是对端是没法解析的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566868410,"ip_address":"","comment_id":127781,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师的writeTo函数没必要加锁吧，用一个局部缓冲把lengthByte serialBytes payloadBytes拼装好再一起发送应该就可以了\n我把我的大爷改成双工的，多线程的，可以打包发送的，现在大爷还只有一张嘴一个耳朵（一个socket连接）\n可能是没有逻辑处理的负担，多线程没啥改变\n打包发送有一定的改进，1次3条数据 14s\n现在100万次胡同碰面，8.66s(公司的i7)\n\nhttps:&#47;&#47;gist.github.com&#47;liutianpeng&#47;d9330f85d47525a8e32dcd24f5738e55","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464710,"discussion_content":"恭喜你学到了😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566868614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1740409,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/8e/79/f9d5dd3a.jpg","nickname":"吕超","note":"","ucode":"B36883984BE16B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369247,"discussion_content":"既然问答的内容是既定的，那直接用枚举传123456岂不美哉？连序列化都省了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618986945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1577210,"avatar":"https://static001.geekbang.org/account/avatar/00/18/10/fa/d977627e.jpg","nickname":"刘大人","note":"","ucode":"F66AE613E80398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336713,"discussion_content":"Java 代码 分享下？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608685595,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1214502,"avatar":"https://static001.geekbang.org/account/avatar/00/12/88/26/b8c53cee.jpg","nickname":"南辕北辙","note":"","ucode":"03EC406AE0D591","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6252,"discussion_content":"既然耳朵代码中对话字符串都是用来判断的，可否在传递过程中用一个数字版本号来代替对话内容，减少传递数据量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566811558,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127678,"user_name":"包明","can_delete":false,"product_type":"c1","uid":1086748,"ip_address":"","ucode":"67B9F661613532","user_header":"https://static001.geekbang.org/account/avatar/00/10/95/1c/3cefe42b.jpg","comment_is_top":false,"comment_ctime":1566778629,"is_pvip":false,"replies":[{"id":47515,"content":"你要明白一件事儿，客户端发来一条数据，直到服务端返回给客户端发送成功，这段时间内，数据是允许丢失的。\n\n数据丢失后，客户端收不到发送成功响应，自然会重试。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566868175,"ip_address":"","comment_id":127678,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"Requests Queue 内存级的 怎么做到不丢请求？","like_count":69,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464605,"discussion_content":"你要明白一件事儿，客户端发来一条数据，直到服务端返回给客户端发送成功，这段时间内，数据是允许丢失的。\n\n数据丢失后，客户端收不到发送成功响应，自然会重试。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1566868175,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373130,"discussion_content":"这种都是靠客户端自己实现状态机 比方说rocketmq的可靠消息一致性 或者就是实现retries特性","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1620627777,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2417723,"avatar":"https://static001.geekbang.org/account/avatar/00/24/e4/3b/f1b9d6bf.jpg","nickname":"蔡俊贤","note":"","ucode":"A856D094E3F4A3","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390496,"discussion_content":"在客户端发送消息后收到ACK前的这段时间内，这条消息的状态对客户端来说就是发送中，发送中的消息是允许丢失的，不管是因为网络原因没有到达broker，还是在broker的缓存中丢失，对于客户端来说，它可以在超时没有收到ACK后判断为消息发送失败，从而进入重发流程","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1629865241,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1110723,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f2/c3/f18e4507.jpg","nickname":"远鹏","note":"","ucode":"37B06413D88BEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":216661,"discussion_content":"内存级的东西本身是做不到不丢请求的，但可以通过其他手段进行消息的确认来进一步判断消息的完整性","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585474211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127222,"user_name":"青舟","can_delete":false,"product_type":"c1","uid":1192732,"ip_address":"","ucode":"2651482AC0DEC6","user_header":"https://static001.geekbang.org/account/avatar/00/12/33/1c/59a4e803.jpg","comment_is_top":false,"comment_ctime":1566614196,"is_pvip":false,"replies":[{"id":47079,"content":"👍👍👍","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566620279,"ip_address":"","comment_id":127222,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"https:&#47;&#47;github.com&#47;qingzhou413&#47;geektime-mq-rpc.git\n\n使用netty作为网络库，server和client的io线程数都是1，笔记本4核标压2.3G时间2.3秒。","like_count":27,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464605,"discussion_content":"你要明白一件事儿，客户端发来一条数据，直到服务端返回给客户端发送成功，这段时间内，数据是允许丢失的。\n\n数据丢失后，客户端收不到发送成功响应，自然会重试。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1566868175,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373130,"discussion_content":"这种都是靠客户端自己实现状态机 比方说rocketmq的可靠消息一致性 或者就是实现retries特性","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1620627777,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2417723,"avatar":"https://static001.geekbang.org/account/avatar/00/24/e4/3b/f1b9d6bf.jpg","nickname":"蔡俊贤","note":"","ucode":"A856D094E3F4A3","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390496,"discussion_content":"在客户端发送消息后收到ACK前的这段时间内，这条消息的状态对客户端来说就是发送中，发送中的消息是允许丢失的，不管是因为网络原因没有到达broker，还是在broker的缓存中丢失，对于客户端来说，它可以在超时没有收到ACK后判断为消息发送失败，从而进入重发流程","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1629865241,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1110723,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f2/c3/f18e4507.jpg","nickname":"远鹏","note":"","ucode":"37B06413D88BEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":216661,"discussion_content":"内存级的东西本身是做不到不丢请求的，但可以通过其他手段进行消息的确认来进一步判断消息的完整性","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585474211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161690,"user_name":"ub8","can_delete":false,"product_type":"c1","uid":1481811,"ip_address":"","ucode":"0D937C3EAEB781","user_header":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","comment_is_top":false,"comment_ctime":1576297133,"is_pvip":false,"replies":[{"id":62381,"content":"一般简单常用的做法都是在处理request的线程中执行业务逻辑，然后把response返回。\n\n其实从网络层面来看，Request和Response只是客户端和服务端互相发送的两段数据，和服务端处理用什么线程完全没有关系。\n\nRequest和Response如何对应，这个取决于网络传输协议是怎么设计的。这个我们在课程中讲过。\n\n在服务端实现中，可以接受到Request之后，进行异步处理，异步处理完成之后，无论在什么线程中，只要能拿到处理结果构建出Response，通过网络发给客户端就可以了。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1576896514,"ip_address":"","comment_id":161690,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师，文中提到的 “我们把回复响应这个需要等待资源的操作，也异步放到其他的线程中去执行。”；这个是怎么实现的呢？ ResponseThread ,和 RequestThread 是如何对应上的？","like_count":14,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464384,"discussion_content":"👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566620279,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1905373,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/hxdXcxp1wOKuKhiaibDZdrW8yJ2lcGOtVrRdgHS3Ub3ObeYg0ukh5oOMicuWIUORzDVv2OVfdkfnicfZVvQvqtNMpw/132","nickname":"Geek_aecacf","note":"","ucode":"B2C4E8E049786A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570341,"discussion_content":"请教个问题：这个代码是使用了批量处理的方式，会比普通的快很多，但是使用双工模式是在哪里体现的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651737507,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1899599,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/fc/4f/0a452c94.jpg","nickname":"大毛","note":"","ucode":"93B18287F06706","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1905373,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/hxdXcxp1wOKuKhiaibDZdrW8yJ2lcGOtVrRdgHS3Ub3ObeYg0ukh5oOMicuWIUORzDVv2OVfdkfnicfZVvQvqtNMpw/132","nickname":"Geek_aecacf","note":"","ucode":"B2C4E8E049786A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630997,"discussion_content":"最直接的体现是，readFrom 和 writeTo 中没有保护 net.TCPConn 的锁（writeTo中有锁，但是是为了解决并发写的问题，而不是锁住对net.TCPConn的操作），也就是说，在调用 readFrom 的同时也可以调用 writeTo，这就是读的时候可以写，也就是双工。更具体的，就是在调用 conn.Write(lengthByte) 的时候也可以调用 io.ReadFull(conn, buf)。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699206082,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":570341,"ip_address":"北京","group_id":0},"score":630997,"extra":""}]}]},{"had_liked":false,"id":127449,"user_name":"linqw","can_delete":false,"product_type":"c1","uid":1134138,"ip_address":"","ucode":"09DCFE98C54DD8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","comment_is_top":false,"comment_ctime":1566718840,"is_pvip":false,"replies":[{"id":47507,"content":"这个流程中处理的数据已经是被分配过的，单个队列的数据。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566867929,"ip_address":"","comment_id":127449,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师有个疑问，帮忙解答下哦，在上面的那个流程图中，WriteThread是单线程从请求队列中获取到消息然后把消息放到journal Cache，开启ReplicationThread、FlushThread进行处理，能否把WriteThread做成分配器了，mq只要保证topic下的队列有序就可以，同一个队列的消息由WriteThread分配给同一个线程进行处理，线程池的形式，线程池中的每个工作线程内部都有个集合保存消息，如果前面没有同一个队列的消息，分配给最空闲的线程进行执行，那这样的话，WriteThread只要分配消息，比如可以对发送过来的消息中要保存的队列属性值进行hash，然后根据hash值判断线程池中的所有线程的消息集合是否有相同队列的消息，有的话分配给同一个线程执行，没有的话最空闲的线程执行，mysql的binlog同步也是有几种这种策略，并发的同步sql，刚开始是基于库，同一个库的sql分配到一个线程执行同步，不同库进行并发，后来是基于redo log的组提交形式，能组提交的sql可以并发的同步，再后来是WRITESET，根据库名、表名、索引（主键和唯一索引）计算hash进行分发策略。","like_count":8,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477817,"discussion_content":"一般简单常用的做法都是在处理request的线程中执行业务逻辑，然后把response返回。\n\n其实从网络层面来看，Request和Response只是客户端和服务端互相发送的两段数据，和服务端处理用什么线程完全没有关系。\n\nRequest和Response如何对应，这个取决于网络传输协议是怎么设计的。这个我们在课程中讲过。\n\n在服务端实现中，可以接受到Request之后，进行异步处理，异步处理完成之后，无论在什么线程中，只要能拿到处理结果构建出Response，通过网络发给客户端就可以了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576896514,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299756,"discussion_content":"同一个connection","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597807351,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1749015,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/b0/17/451cb87c.jpg","nickname":"加油！","note":"","ucode":"947E97762DB6EF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542257,"discussion_content":"都异步了怎么还同一个connection，这里老师例子是用go的协程处理的，两者没有什么关系，而Request和Response对应是通过传输协议对应上的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640692287,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":299756,"ip_address":"","group_id":0},"score":542257,"extra":""},{"author":{"id":1592279,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","nickname":"William Ning","note":"","ucode":"4DB8D05E69E5F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1749015,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/b0/17/451cb87c.jpg","nickname":"加油！","note":"","ucode":"947E97762DB6EF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554318,"discussion_content":"老师的回复：\n\n你的大部分理解都没问题，有一个小问题是，维持一个TCP连接并不一定需要占用一个线程。只有在这个连接上执行收发数据的时候，才需要占用线程。收到请求处理完，把请求交给其它线程处理后，当前线程就可以释放了。直到响应生成后，这段时间只维持TCP连接是不需要占用任何线程的。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1646316231,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":542257,"ip_address":"","group_id":0},"score":554318,"extra":""}]}]},{"had_liked":false,"id":127282,"user_name":"吾皇万岁万岁万万岁","can_delete":false,"product_type":"c1","uid":1135155,"ip_address":"","ucode":"8FDD608729A002","user_header":"https://static001.geekbang.org/account/avatar/00/11/52/33/abf321b7.jpg","comment_is_top":false,"comment_ctime":1566633078,"is_pvip":false,"replies":[{"id":47162,"content":"不会丢，因为数据已经复制到了从节点上，leader宕机后，会重新选举出新的leader（也就是之前的某个follower），这个新leader上是有原leader上的全部数据的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566708652,"ip_address":"","comment_id":127282,"utype":1}],"discussion_count":6,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"请问老师，JMQ在follower节点响应后，就给生产者发送确认消息，此时如果leader节点故障，数据还在JournalCache里面，拿是不是可以认为这部分数据丢失？","like_count":8,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464412,"discussion_content":"不会丢，因为数据已经复制到了从节点上，leader宕机后，会重新选举出新的leader（也就是之前的某个follower），这个新leader上是有原leader上的全部数据的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566708652,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1115149,"avatar":"https://static001.geekbang.org/account/avatar/00/11/04/0d/3dc5683a.jpg","nickname":"柯察金","note":"","ucode":"F722BF8FCD2C47","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":637884,"discussion_content":"那在 jorunal cache 里面的数据不就丢失了嘛","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1709041039,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":464412,"ip_address":"美国","group_id":0},"score":637884,"extra":""}]},{"author":{"id":1002317,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4b/4d/0239bc19.jpg","nickname":"益军","note":"","ucode":"5629FA62A01F25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6578,"discussion_content":"这里有两个问题哈。1.这个领导者选举期间，客户端写入消息是失败还是重试到其他broker ？ 2.一般这个领导者选举时间需要多久，采用哪种协议实现的？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1566982978,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1009652,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","nickname":"钱","note":"","ucode":"2C92A243A463D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1002317,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4b/4d/0239bc19.jpg","nickname":"益军","note":"","ucode":"5629FA62A01F25","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":20407,"discussion_content":"好问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569311074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":6578,"ip_address":"","group_id":0},"score":20407,"extra":""},{"author":{"id":1802337,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/80/61/ae3bb67c.jpg","nickname":"毛毛虫大帝","note":"","ucode":"1EBB026121C060","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1002317,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4b/4d/0239bc19.jpg","nickname":"益军","note":"","ucode":"5629FA62A01F25","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":175000,"discussion_content":"客户端发往一台broker应该内部有一个最大重试次数，如果超过最大重试仍然失败，会根据之前客户端拉取的该主题分布的集群列表中其他可用broker继续发送，那么故障的broker内部该主题的存储会进行选举，这里并不是broker的选举而是类似存储上的分区或者队列的选举，新leader产生在之前该主题存储的其他broker上的副本上，由选举的term任期值和最大日志复制位置决定，该选举使用raft实现的，复制也是raft协议，选举成功的时间一般是1秒内，follower成为leader的超时时间一般是150ms~300ms之间。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581947975,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":6578,"ip_address":"","group_id":0},"score":175000,"extra":""}]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373131,"discussion_content":"我想了解下leader与follow之间同步数据 是基于半同步还是自己实现了一个复制状态机？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620627862,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155806,"user_name":"李冲","can_delete":false,"product_type":"c1","uid":1254530,"ip_address":"","ucode":"C8C12308B0FDDA","user_header":"https://static001.geekbang.org/account/avatar/00/13/24/82/b5808a60.jpg","comment_is_top":false,"comment_ctime":1574759465,"is_pvip":false,"replies":[{"id":60086,"content":"👍👍👍","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1574903308,"ip_address":"","comment_id":155806,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"借用老师的的go源码经过读，写，去掉锁3次演进，分别在金山云ECS（2核4G）上跑到3.1&#47;2.4&#47;1.4秒的样子。\n最终的文件：https:&#47;&#47;github.com&#47;lichongsw&#47;algorithm&#47;blob&#47;master&#47;duplex_communication_optimization_3_no_write_lock.go","like_count":7,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475879,"discussion_content":"👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574903308,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1254530,"avatar":"https://static001.geekbang.org/account/avatar/00/13/24/82/b5808a60.jpg","nickname":"李冲","note":"","ucode":"C8C12308B0FDDA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79925,"discussion_content":"经过再一次批量写优化后，金山云ECS（2核4G）上跑到0.7秒左右。\nhttps://github.com/lichongsw/algorithm/blob/master/duplex_communication_optimization_4_use_write_buf.go","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576124046,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143835,"user_name":"李心宇🦉","can_delete":false,"product_type":"c1","uid":1208306,"ip_address":"","ucode":"C381CA80170D5B","user_header":"https://static001.geekbang.org/account/avatar/00/12/6f/f2/1f77b0bd.jpg","comment_is_top":false,"comment_ctime":1571797838,"is_pvip":false,"replies":[{"id":55638,"content":"你的大部分理解都没问题，有一个小问题是，维持一个TCP连接并不一定需要占用一个线程。只有在这个连接上执行收发数据的时候，才需要占用线程。收到请求处理完，把请求交给其它线程处理后，当前线程就可以释放了。直到响应生成后，这段时间只维持TCP连接是不需要占用任何线程的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1571883695,"ip_address":"","comment_id":143835,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师好，我对JMQ的broker接收生产者请求并写入消息的流程有个疑问。\n在处理完数据落盘和多节点数据复制之后，要给生产者回复响应了，这时候broker如何能找到生产者呢？我理解是第一步生产者发送请求建立的TCP连接句柄没有释放，最后再通过这个连接句柄来write响应。这样的话，还是每个连接在得到响应之前不能释放需要占用一个线程啊。请问是怎么做到在第一步接收响应阶段只需要很少的线程的？是不是利用异步非阻塞，在线程里设置大量的协程来处理请求？","like_count":5,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471717,"discussion_content":"你的大部分理解都没问题，有一个小问题是，维持一个TCP连接并不一定需要占用一个线程。只有在这个连接上执行收发数据的时候，才需要占用线程。收到请求处理完，把请求交给其它线程处理后，当前线程就可以释放了。直到响应生成后，这段时间只维持TCP连接是不需要占用任何线程的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571883695,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1208306,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6f/f2/1f77b0bd.jpg","nickname":"李心宇🦉","note":"","ucode":"C381CA80170D5B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":39083,"discussion_content":"感谢老师的解答，现在理解了。想了一个demo，tcp accept之后，handler拿到conn对象之后，放入一个map里，然后就可以释放这个线程了。等相应的异步任务处理完之后，再到map里取conn对象发送相应。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1571889542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1749015,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/b0/17/451cb87c.jpg","nickname":"加油！","note":"","ucode":"947E97762DB6EF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1208306,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6f/f2/1f77b0bd.jpg","nickname":"李心宇🦉","note":"","ucode":"C381CA80170D5B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542264,"discussion_content":"这个过程应该是tcp自己维护的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640694709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":39083,"ip_address":"","group_id":0},"score":542264,"extra":""}]}]},{"had_liked":false,"id":134918,"user_name":"Martin","can_delete":false,"product_type":"c1","uid":1464381,"ip_address":"","ucode":"8EAA93D6432C22","user_header":"https://static001.geekbang.org/account/avatar/00/16/58/3d/4ba98f04.jpg","comment_is_top":false,"comment_ctime":1568952577,"is_pvip":false,"replies":[{"id":51839,"content":"👍👍👍正确写出这个程序差不多就是这个耗时。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1569024325,"ip_address":"","comment_id":134918,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"https:&#47;&#47;github.com&#47;MartinDai&#47;mq-in-action&#47;blob&#47;master&#47;src&#47;main&#47;java&#47;com&#47;doodl6&#47;mq&#47;MeetInRpc.java\n\n基于netty4实现的，Macbook pro 2015款 13寸 测试差不多4.2秒左右，老师帮忙看看哪里还可以有优化空间吗","like_count":5,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471717,"discussion_content":"你的大部分理解都没问题，有一个小问题是，维持一个TCP连接并不一定需要占用一个线程。只有在这个连接上执行收发数据的时候，才需要占用线程。收到请求处理完，把请求交给其它线程处理后，当前线程就可以释放了。直到响应生成后，这段时间只维持TCP连接是不需要占用任何线程的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571883695,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1208306,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6f/f2/1f77b0bd.jpg","nickname":"李心宇🦉","note":"","ucode":"C381CA80170D5B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":39083,"discussion_content":"感谢老师的解答，现在理解了。想了一个demo，tcp accept之后，handler拿到conn对象之后，放入一个map里，然后就可以释放这个线程了。等相应的异步任务处理完之后，再到map里取conn对象发送相应。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1571889542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1749015,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/b0/17/451cb87c.jpg","nickname":"加油！","note":"","ucode":"947E97762DB6EF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1208306,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6f/f2/1f77b0bd.jpg","nickname":"李心宇🦉","note":"","ucode":"C381CA80170D5B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542264,"discussion_content":"这个过程应该是tcp自己维护的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640694709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":39083,"ip_address":"","group_id":0},"score":542264,"extra":""}]}]},{"had_liked":false,"id":127929,"user_name":"南辕北辙","can_delete":false,"product_type":"c1","uid":1214502,"ip_address":"","ucode":"03EC406AE0D591","user_header":"https://static001.geekbang.org/account/avatar/00/12/88/26/b8c53cee.jpg","comment_is_top":false,"comment_ctime":1566811243,"is_pvip":false,"replies":[{"id":47525,"content":"恭喜你学到了😄","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566868614,"ip_address":"","comment_id":127929,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"把老师的代码看了n遍，再用java的原生nio实现了一遍，理解了老师的用心良苦。前二章序列化与网络协议那块的知识，对应代码对于struct的构造，四字节的总长度，四字节的序号，以及变长内容，然后二个大爷在接受到数据以后也是根据这个协议进行取数据。也就对应了序列化以及协议都是自定义的！！二个大爷都懂该怎么从二进制的数据中，提取出对话。","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464710,"discussion_content":"恭喜你学到了😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566868614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1740409,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/8e/79/f9d5dd3a.jpg","nickname":"吕超","note":"","ucode":"B36883984BE16B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369247,"discussion_content":"既然问答的内容是既定的，那直接用枚举传123456岂不美哉？连序列化都省了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618986945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1577210,"avatar":"https://static001.geekbang.org/account/avatar/00/18/10/fa/d977627e.jpg","nickname":"刘大人","note":"","ucode":"F66AE613E80398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336713,"discussion_content":"Java 代码 分享下？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608685595,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1214502,"avatar":"https://static001.geekbang.org/account/avatar/00/12/88/26/b8c53cee.jpg","nickname":"南辕北辙","note":"","ucode":"03EC406AE0D591","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6252,"discussion_content":"既然耳朵代码中对话字符串都是用来判断的，可否在传递过程中用一个数字版本号来代替对话内容，减少传递数据量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566811558,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127781,"user_name":"刘天鹏","can_delete":false,"product_type":"c1","uid":1632015,"ip_address":"","ucode":"FB146250578911","user_header":"https://static001.geekbang.org/account/avatar/00/18/e7/0f/fa840c1b.jpg","comment_is_top":false,"comment_ctime":1566791888,"is_pvip":false,"replies":[{"id":47520,"content":"如果是多个线程并发向同一个socket中写数据，这个锁是必须加的。\n\n比如，A线程发送“123456”，B线程发送“abcd”，如果不加锁，对端收到的可能就成了“12abc345d6”，这种数据是对端是没法解析的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566868410,"ip_address":"","comment_id":127781,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师的writeTo函数没必要加锁吧，用一个局部缓冲把lengthByte serialBytes payloadBytes拼装好再一起发送应该就可以了\n我把我的大爷改成双工的，多线程的，可以打包发送的，现在大爷还只有一张嘴一个耳朵（一个socket连接）\n可能是没有逻辑处理的负担，多线程没啥改变\n打包发送有一定的改进，1次3条数据 14s\n现在100万次胡同碰面，8.66s(公司的i7)\n\nhttps:&#47;&#47;gist.github.com&#47;liutianpeng&#47;d9330f85d47525a8e32dcd24f5738e55","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464655,"discussion_content":"如果是多个线程并发向同一个socket中写数据，这个锁是必须加的。\n\n比如，A线程发送“123456”，B线程发送“abcd”，如果不加锁，对端收到的可能就成了“12abc345d6”，这种数据是对端是没法解析的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566868410,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1632015,"avatar":"https://static001.geekbang.org/account/avatar/00/18/e7/0f/fa840c1b.jpg","nickname":"刘天鹏","note":"","ucode":"FB146250578911","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6358,"discussion_content":"哦 懂了，socket的send不是线程安全的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566868802,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":197585,"user_name":"nfx","can_delete":false,"product_type":"c1","uid":1693667,"ip_address":"","ucode":"88D3F3920C68BC","user_header":"https://static001.geekbang.org/account/avatar/00/19/d7/e3/e6cf6352.jpg","comment_is_top":false,"comment_ctime":1585386652,"is_pvip":false,"replies":[{"id":74817,"content":"这个地方理论上是不需要锁的，因为是Append Only的数据模型，也就是说数据在尾部追加写入，写入后不可改变，那读写就不会有冲突，所以不需要加锁。\n\n但实际上，因为内存是有限的，总是要发生换页操作，相当于把数据从内存中删除，这个地方还是需要用锁来控制的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1585532115,"ip_address":"","comment_id":197585,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"有个疑问,  request queue, journal cache都是生产者, 消费者模型的队列,  里面应该会有锁吧?  只是这种队列锁需要的资源很少. \n 不知道怎么理解对不对","like_count":2},{"had_liked":false,"id":134282,"user_name":"顶新","can_delete":false,"product_type":"c1","uid":1036566,"ip_address":"","ucode":"241D3CCCAE536B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d1/16/6347bbc0.jpg","comment_is_top":false,"comment_ctime":1568793058,"is_pvip":false,"replies":[{"id":51547,"content":"这个地方是不需要锁的，写入和移出Callback分别是在2个固定的线程中分别执行，这个链表写入的时候直接是尾部追加，执行Callback的时候在头部移出。并且，执行Callback的时候一定链表中有数据的时候，所以也不需要加锁担心移除越界。所以这个地方是不需要锁的","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1568855667,"ip_address":"","comment_id":134282,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"FlushThread 和 ReplicationThread线程对内存的链表 Pending Callbacks 中数据的更新，然后ResponseThread扫描链表Pending Callbacks，批量取出符合 QOS 规则的响应及超时的响应，然后并发返回给客户端。这块也存在对 Pending Callbacks 存在互斥锁吧？不知道理解的对不对，还请老师答疑 :)","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489552,"discussion_content":"这个地方理论上是不需要锁的，因为是Append Only的数据模型，也就是说数据在尾部追加写入，写入后不可改变，那读写就不会有冲突，所以不需要加锁。\n\n但实际上，因为内存是有限的，总是要发生换页操作，相当于把数据从内存中删除，这个地方还是需要用锁来控制的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585532115,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1749015,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/b0/17/451cb87c.jpg","nickname":"加油！","note":"","ucode":"947E97762DB6EF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542265,"discussion_content":"学到了，Append Only的数据模型","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640695097,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532661,"discussion_content":"简单解释一下 线程做完持久化或同步后，需要将内存数据删除，这个时候存在写覆盖问题 需要一层保护","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637662300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127545,"user_name":"ykkk88","can_delete":false,"product_type":"c1","uid":1068585,"ip_address":"","ucode":"A1BCFC2F0D1022","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/29/1be3dd40.jpg","comment_is_top":false,"comment_ctime":1566739307,"is_pvip":false,"replies":[{"id":47510,"content":"是的。\n\n一般的协议都是这种“请求-响应”的方式，不需要同步的请求之间有序。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566867996,"ip_address":"","comment_id":127545,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"如果要保证前一句话要对方确认回复后再发送下一句话 就不能用这种方式了吧？这样吞吐量就会很低了","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467690,"discussion_content":"这个地方是不需要锁的，写入和移出Callback分别是在2个固定的线程中分别执行，这个链表写入的时候直接是尾部追加，执行Callback的时候在头部移出。并且，执行Callback的时候一定链表中有数据的时候，所以也不需要加锁担心移除越界。所以这个地方是不需要锁的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568855667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127533,"user_name":"TWT_Marq","can_delete":false,"product_type":"c1","uid":1238077,"ip_address":"","ucode":"1E1E14C7281477","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/3d/5d51fda4.jpg","comment_is_top":false,"comment_ctime":1566736554,"is_pvip":false,"replies":[{"id":47508,"content":"是的","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566867942,"ip_address":"","comment_id":127533,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"JMQ中，接受请求的iothreads将请求丢给request queue，WriteThread从queue中取出来开始干活。这个queue是concurrentBlockingQueue吗？","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464544,"discussion_content":"是的。\n\n一般的协议都是这种“请求-响应”的方式，不需要同步的请求之间有序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566867996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127448,"user_name":"linqw","can_delete":false,"product_type":"c1","uid":1134138,"ip_address":"","ucode":"09DCFE98C54DD8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","comment_is_top":false,"comment_ctime":1566717576,"is_pvip":false,"replies":[{"id":47506,"content":"还是贴一下GitHub的链接把，也方便其他同学学习。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566867867,"ip_address":"","comment_id":127448,"utype":1}],"discussion_count":10,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"我用java实现了一版，老师帮忙看下哦，评论只能发2000字，其余在评论区补上\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.annotation.Nonnull;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.locks.ReentrantLock;\n\n&#47;**\n * @author linqw\n *&#47;\npublic class SocketExample {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(SocketExample.class);\n\n    private static final ReentrantLock LI_WRITE_REENTRANT_LOCK = new ReentrantLock();\n\n    private static final ReentrantLock ZHANG_WRITE_REENTRANT_LOCK = new ReentrantLock();\n\n    private static final int NCPU = Runtime.getRuntime().availableProcessors();\n\n    private final ThreadPoolExecutor serverThreadPoolExecutor = new ThreadPoolExecutor(NCPU, NCPU, 5, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(200000), new ThreadFactoryImpl(&quot;server-&quot;), new ThreadPoolExecutor.CallerRunsPolicy());\n\n    private final ThreadPoolExecutor clientThreadPoolExecutor = new ThreadPoolExecutor(NCPU, NCPU, 5, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(200000), new ThreadFactoryImpl(&quot;client-&quot;), new ThreadPoolExecutor.CallerRunsPolicy());\n\n    private volatile boolean started = false;\n\n    &#47;**\n     * 俩大爷已经遇见了多少次\n     *&#47;\n    private volatile AtomicInteger count = new AtomicInteger(0);\n\n    &#47;**\n     * 总共需要遇见多少次\n     *&#47;\n    private static final int TOTAL = 1;\n\n    private static final String Z0 = &quot; 吃了没，您吶?&quot;;\n\n    private static final String Z3 = &quot; 嗨！吃饱了溜溜弯儿。&quot;;\n    private static final String Z5 = &quot; 回头去给老太太请安！&quot;;\n    private static final String L1 = &quot; 刚吃。&quot;;\n    private static final String L2 = &quot; 您这，嘛去？&quot;;\n    private static final String L4 = &quot; 有空家里坐坐啊。&quot;;","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464495,"discussion_content":"还是贴一下GitHub的链接把，也方便其他同学学习。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566867867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134138,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","nickname":"linqw","note":"","ucode":"09DCFE98C54DD8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6132,"discussion_content":"class RequestResponse {\n        int serial;\n        String payLoad;\n\n        @Override\n        public String toString() {\n            return &#34;RequestResponse{&#34; +\n                    &#34;serial=&#34; + serial +\n                    &#34;, payLoad=&#39;&#34; + payLoad + &#39;\\&#39;&#39; +\n                    &#39;}&#39;;\n        }\n    }\n\n    private void writeTo(RequestResponse requestResponse, ReentrantLock reentrantLock, Socket socket) {\n        try {\n            OutputStream outputStream = socket.getOutputStream();\n            byte[] payloadBytes = requestResponse.payLoad.getBytes();\n            byte[] serialBytes = intToByte(requestResponse.serial);\n            int length = payloadBytes.length + serialBytes.length;\n            byte[] lengthBytes = intToByte(length);\n            reentrantLock.lock();\n            outputStream.write(lengthBytes);\n            outputStream.write(serialBytes);\n            outputStream.write(payloadBytes);\n            outputStream.flush();\n        } catch (IOException e) {\n            LOGGER.error(e.toString());\n        } finally {\n            reentrantLock.unlock();\n        }\n    }\n\n    ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1566719012,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1103652,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d7/24/bdc0e12b.jpg","nickname":"施华洛","note":"","ucode":"138B4A0E4EA76A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6224,"discussion_content":"来个git版本的啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566795049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1134138,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","nickname":"linqw","note":"","ucode":"09DCFE98C54DD8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1103652,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d7/24/bdc0e12b.jpg","nickname":"施华洛","note":"","ucode":"138B4A0E4EA76A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6279,"discussion_content":"我找个时间，用netty、 nio也实现下，统一放在GitHub上","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1566820342,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":6224,"ip_address":"","group_id":0},"score":6279,"extra":""}]},{"author":{"id":1134138,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","nickname":"linqw","note":"","ucode":"09DCFE98C54DD8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6138,"discussion_content":"  class ThreadFactoryImpl implements ThreadFactory {\n        private final AtomicLong threadIndex = new AtomicLong(0);\n        private final String threadNamePrefix;\n        private final boolean daemon;\n\n        ThreadFactoryImpl(final String threadNamePrefix) {\n            this(threadNamePrefix, false);\n        }\n\n        ThreadFactoryImpl(final String threadNamePrefix, boolean daemon) {\n            this.threadNamePrefix = threadNamePrefix;\n            this.daemon = daemon;\n        }\n\n        @Override\n        public Thread newThread(@Nonnull Runnable r) {\n            Thread thread = new Thread(r, threadNamePrefix + this.threadIndex.incrementAndGet());\n            thread.setDaemon(daemon);\n            return thread;\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        SocketExample socketExample = new SocketExample();\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                socketExample.startServer(9999);\n            }\n        }).start();\n        while (!socketExample.started) {\n            Thread.sleep(1);\n        }\n        long start = System.nanoTime();\n        socketExample.startClient(&#34;127.0.0.1&#34;, 9999);\n        long end = System.nanoTime();\n        System.out.println(TimeUnit.SECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    }\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566719271,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134138,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","nickname":"linqw","note":"","ucode":"09DCFE98C54DD8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6137,"discussion_content":" private void startClient(String host, int port) {\n        final CountDownLatch countDownLatch = new CountDownLatch(1);\n        // 与服务端建立连接\n        try (Socket socket = new Socket(host, port)) {\n            clientThreadPoolExecutor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    liDaYeListen(socket, countDownLatch);\n\n                }\n            });\n            clientThreadPoolExecutor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    liDaYeSay(socket);\n                }\n            });\n            countDownLatch.await();\n        } catch (IOException | InterruptedException e) {\n            LOGGER.error(e.toString());\n        }\n\n    }\n\n    private byte[] intToByte(int val) {\n        byte[] bytes = new byte[4];\n        bytes[0] = (byte) (val &amp; 0xff);\n        bytes[1] = (byte) ((val >> 8) &amp; 0xff);\n        bytes[2] = (byte) ((val >> 16) &amp; 0xff);\n        bytes[3] = (byte) ((val >> 24) &amp; 0xff);\n        return bytes;\n    }\n\n    private int byteToInt(byte[] bytes) {\n        int val = 0;\n        if (bytes == null || bytes.length < 4) {\n            return val;\n        }\n        val += bytes[0] &amp; 0xff;\n        val += (bytes[1] &amp; 0xff) << 8;\n        val += (bytes[2] &amp; 0xff) << 16;\n        val += (bytes[3] &amp; 0xff) << 24;\n        return val;\n    }\n\n  ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566719267,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134138,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","nickname":"linqw","note":"","ucode":"09DCFE98C54DD8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6136,"discussion_content":"    /**\n     * 李大爷的嘴\n     */\n    private void liDaYeSay(Socket socket) {\n        AtomicInteger nextSerial = new AtomicInteger(0);\n        for (int i = 0; i < TOTAL; i++) {\n            clientThreadPoolExecutor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    RequestResponse requestResponse = new RequestResponse();\n                    requestResponse.serial = nextSerial.getAndAdd(1);;\n                    requestResponse.payLoad = L2;\n                    writeTo(requestResponse, LI_WRITE_REENTRANT_LOCK, socket);\n                }\n            });\n            clientThreadPoolExecutor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    RequestResponse requestResponse = new RequestResponse();\n                    requestResponse.serial = nextSerial.getAndAdd(1);\n                    requestResponse.payLoad = L4;\n                    writeTo(requestResponse, LI_WRITE_REENTRANT_LOCK, socket);\n                }\n            });\n\n        }\n    }\n\n    private void startServer(int port) {\n        // 监听指定的端口\n\n        try (ServerSocket server = new ServerSocket(port)) {\n            started = true;\n            System.out.println(&#34; 张大爷在胡同口等着 ...&#34;);\n            Socket socket = server.accept();\n            System.out.println(&#34; 碰见一个李大爷:&#34; + socket.getRemoteSocketAddress().toString());\n            zhangDaYeSay(socket);\n            zhangDaYeListen(socket);\n        } catch (IOException e) {\n            LOGGER.error(e.toString());\n        }\n    }\n\n   ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566719247,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134138,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","nickname":"linqw","note":"","ucode":"09DCFE98C54DD8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6135,"discussion_content":"/**\n     * 李大爷的耳朵\n     */\n    private void liDaYeListen(Socket socket, CountDownLatch countDownLatch) {\n        while (count.get() <= TOTAL - 1) {\n            RequestResponse requestResponse = readFrom(socket);\n            if (requestResponse == null) {\n                continue;\n            }\n\n            clientThreadPoolExecutor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    // fmt.Println(&#34; 李大爷收到：&#34; + r.Payload)\n                    // 如果收到：吃了没，您吶?\n                    if (requestResponse.payLoad.equals(Z0)) {\n                        requestResponse.payLoad = L1;\n                        // 回复：刚吃。\n                        writeTo(requestResponse, LI_WRITE_REENTRANT_LOCK, socket);\n                    } else if (requestResponse.payLoad.equals(Z3)) {\n                        // do nothing\n                    } else if (requestResponse.payLoad.equals(Z5)) {\n                        //fmt.Println(&#34; 俩人说完走了 &#34;)\n                        count.incrementAndGet();\n                    } else {\n                        System.out.format(&#34; 李大爷听不懂：%s%n&#34; + requestResponse.payLoad);\n                    }\n                }\n            });\n\n        }\n        countDownLatch.countDown();\n    }\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566719210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134138,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","nickname":"linqw","note":"","ucode":"09DCFE98C54DD8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6134,"discussion_content":"  /**\n     * 张大爷的耳朵\n     */\n    private void zhangDaYeListen(Socket socket) {\n\n        while (count.get() <= TOTAL - 1) {\n            RequestResponse requestResponse = readFrom(socket);\n            if (requestResponse == null) {\n                continue;\n            }\n            serverThreadPoolExecutor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    // 如果收到：您这，嘛去？\n                    if (requestResponse.payLoad.equals(L2)) {\n                        requestResponse.payLoad = Z3;\n                        // 回复：嗨！吃饱了溜溜弯儿。\n                        writeTo(requestResponse, ZHANG_WRITE_REENTRANT_LOCK, socket);\n                        // 如果收到：有空家里坐坐啊。\n                    } else if (requestResponse.payLoad.equals(L4)) {\n                        requestResponse.payLoad = Z5;\n                        // 回复：回头去给老太太请安！\n                        writeTo(requestResponse, ZHANG_WRITE_REENTRANT_LOCK, socket);\n                        // 如果收到：刚吃。\n                    } else if (requestResponse.payLoad.equals(L1)) {\n                        // ignore不用回复\n                    } else {\n                        System.out.format(&#34; 张大爷听不懂：%s%n&#34; + requestResponse.payLoad);\n                    }\n                }\n            });\n        }\n\n\n    }\n\n    /**\n     * 张大爷的嘴\n     */\n    private void zhangDaYeSay(Socket socket) {\n        AtomicInteger nextSerial = new AtomicInteger(0);\n        for (int i = 0; i < TOTAL; i++) {\n            serverThreadPoolExecutor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    RequestResponse requestResponse = new RequestResponse();\n                    requestResponse.serial = nextSerial.getAndAdd(1);\n                    requestResponse.payLoad = Z0;\n                    writeTo(requestResponse, ZHANG_WRITE_REENTRANT_LOCK, socket);\n                }\n            });\n        }\n    }\n\n    ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566719138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134138,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","nickname":"linqw","note":"","ucode":"09DCFE98C54DD8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6133,"discussion_content":"private RequestResponse readFrom(Socket socket) {\n        RequestResponse requestResponse = new RequestResponse();\n        int length = 4;\n        int serialLength = 4;\n        byte[] payloadBytes;\n        byte[] serialBytes;\n        byte[] lengthBytes;\n        InputStream inputStream;\n        try {\n            inputStream = socket.getInputStream();\n\n            try {\n                lengthBytes = new byte[length];\n                inputStream.read(lengthBytes);\n                length = byteToInt(lengthBytes);\n                if (length <= serialLength) {\n                    return null;\n                }\n            } catch (IOException e) {\n                LOGGER.error(&#34; 读长度故障：{}&#34;, e.toString());\n            }\n            try {\n                serialBytes = new byte[4];\n                inputStream.read(serialBytes);\n                requestResponse.serial = byteToInt(serialBytes);\n            } catch (IOException e) {\n                LOGGER.error(&#34; 读Serial故障：{}&#34;, e.toString());\n            }\n            try {\n                payloadBytes = new byte[length - serialLength];\n                inputStream.read(payloadBytes);\n                requestResponse.payLoad = new String(payloadBytes);\n            } catch (IOException e) {\n                LOGGER.error(&#34; 读PayLoad故障：{}&#34;, e.toString());\n            }\n        } catch (IOException e) {\n            LOGGER.error(e.toString());\n        }\n        return requestResponse;\n\n    }\n\n  ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566719106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127344,"user_name":"豆沙包","can_delete":false,"product_type":"c1","uid":1223954,"ip_address":"","ucode":"7C62E546E6786A","user_header":"https://static001.geekbang.org/account/avatar/00/12/ad/12/d4d54dd2.jpg","comment_is_top":false,"comment_ctime":1566659587,"is_pvip":false,"replies":[{"id":47163,"content":"这个地方是因为，完成了所有会话之后，关闭socket连接的时候，没有先等待2个大爷读写socket的4个线程都结束导致的。\n\n虽然不影响结果，但还是可以改进一下，做到优雅的退出。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566708952,"ip_address":"","comment_id":127344,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"老师，我在运行你的老大爷代码的时候发现了一个问题，经常报读长度故障。我调试了一下，应该是因为张大爷阻塞在readfrom的时候，李大爷count++了。然后count大于total，client释放了tcp。这导致readfrom无法读出准确数据。我在返回读数据故障前判断了一下count和total的关系，如果count大于等于total正常返回，就没有再报过异常了。您看我分析的是否有问题呢","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464451,"discussion_content":"这个地方是因为，完成了所有会话之后，关闭socket连接的时候，没有先等待2个大爷读写socket的4个线程都结束导致的。\n\n虽然不影响结果，但还是可以改进一下，做到优雅的退出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566708952,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127215,"user_name":"solar","can_delete":false,"product_type":"c1","uid":1070335,"ip_address":"","ucode":"E6C7090478B027","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/ff/09a058f3.jpg","comment_is_top":false,"comment_ctime":1566612503,"is_pvip":false,"replies":[{"id":47078,"content":"这些想法，最好是落到代码上，通过真实的优化效果，来印证自己的想法。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566620267,"ip_address":"","comment_id":127215,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"一些分配内存地方也可以优化，可以预先分配一块复用，减少向内核申请分配内存次数.","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464451,"discussion_content":"这个地方是因为，完成了所有会话之后，关闭socket连接的时候，没有先等待2个大爷读写socket的4个线程都结束导致的。\n\n虽然不影响结果，但还是可以改进一下，做到优雅的退出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566708952,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127212,"user_name":"Geek_zbvt62","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/d28174a9.jpg","comment_is_top":false,"comment_ctime":1566612023,"is_pvip":false,"replies":[{"id":47080,"content":"1. 这里是不需要同步的，因为这个流它具备WAL的所有特性：尾部追加、写入后不变，这种WAL读写线程之间是不需要任何协调的。\n\n2. 这个是我们单独使用堆外内存设计的一个写缓存，目的就是避免频繁的GC。\n\n3. 优化的过程是一个循序渐进的过程，并没有哪一步是一下子提升了很多。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566620620,"ip_address":"","comment_id":127212,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"想简单请教一下JMQ\n1. writeThread与ReplicationThread&#47;FlushThread之间的同步也要基于无锁队列是吧？\n2. JournalCache就是简单的用户态内存，还是基于mmap？（从描述上看感觉就是用户态内存）。\n3. 老师能不能透露一下，在研发JMQ的过程中，解决了哪个瓶颈之后，吞吐量一下子提了很多呢？","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464379,"discussion_content":"这些想法，最好是落到代码上，通过真实的优化效果，来印证自己的想法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566620267,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1070335,"avatar":"https://static001.geekbang.org/account/avatar/00/10/54/ff/09a058f3.jpg","nickname":"solar","note":"","ucode":"E6C7090478B027","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6028,"discussion_content":"业务中曾用go实现过. 😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566620796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140558,"user_name":"Tesla","can_delete":false,"product_type":"c1","uid":1500742,"ip_address":"","ucode":"98629AFD9861EE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKUcSLVV6ia3dibe7qvTu8Vic1PVs2EibxoUdx930MC7j2Q9A6s4eibMDZlcicMFY0D0icd3RrDorMChu0zw/132","comment_is_top":false,"comment_ctime":1570985576,"is_pvip":false,"replies":[{"id":54348,"content":"不是这样的，以你这个例子来说，假设abcd这条消息前面再也没有其它消息的，它是最前的一条，abcd这条消息的offset就是0， abcdefgh这条消息的offset就是6.","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1571018586,"ip_address":"","comment_id":140558,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"老师好，请问一下WriteThread中将消息序列化并维护起止位置offset，这个offset是否就是头部信息中保存消息长度呢？比如04abcd08abcdefgh，通过04就可以知道abcd消息的起止位置，下一个读到的08则代表下一条消息的起止位置？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470440,"discussion_content":"不是这样的，以你这个例子来说，假设abcd这条消息前面再也没有其它消息的，它是最前的一条，abcd这条消息的offset就是0， abcdefgh这条消息的offset就是6.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571018586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1485489,"avatar":"https://static001.geekbang.org/account/avatar/00/16/aa/b1/c834aab5.jpg","nickname":"张小勋","note":"","ucode":"8C5E434EF53BF4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38137,"discussion_content":"08  04 应该指的是后面读取的长度吧offset 是指的读取的开始位置~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571734125,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135953,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1569313877,"is_pvip":false,"replies":[{"id":52146,"content":"是的，这里的“异步”是指，发响应给客户端并不是由复制或者刷盘线程来执行的，而是单独的一组线程。给每个客户端发响应这个操作是可以并行执行的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1569375374,"ip_address":"","comment_id":135953,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"老师好， ReponseThreads 这组线程，怎么实现异步并行的没太理解，她不是需要等待复制响应或者落盘后才发消息给客户端嘛？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470440,"discussion_content":"不是这样的，以你这个例子来说，假设abcd这条消息前面再也没有其它消息的，它是最前的一条，abcd这条消息的offset就是0， abcdefgh这条消息的offset就是6.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571018586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1485489,"avatar":"https://static001.geekbang.org/account/avatar/00/16/aa/b1/c834aab5.jpg","nickname":"张小勋","note":"","ucode":"8C5E434EF53BF4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38137,"discussion_content":"08  04 应该指的是后面读取的长度吧offset 是指的读取的开始位置~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571734125,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":197585,"user_name":"nfx","can_delete":false,"product_type":"c1","uid":1693667,"ip_address":"","ucode":"88D3F3920C68BC","user_header":"https://static001.geekbang.org/account/avatar/00/19/d7/e3/e6cf6352.jpg","comment_is_top":false,"comment_ctime":1585386652,"is_pvip":false,"replies":[{"id":74817,"content":"这个地方理论上是不需要锁的，因为是Append Only的数据模型，也就是说数据在尾部追加写入，写入后不可改变，那读写就不会有冲突，所以不需要加锁。\n\n但实际上，因为内存是有限的，总是要发生换页操作，相当于把数据从内存中删除，这个地方还是需要用锁来控制的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1585532115,"ip_address":"","comment_id":197585,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"有个疑问,  request queue, journal cache都是生产者, 消费者模型的队列,  里面应该会有锁吧?  只是这种队列锁需要的资源很少. \n 不知道怎么理解对不对","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489552,"discussion_content":"这个地方理论上是不需要锁的，因为是Append Only的数据模型，也就是说数据在尾部追加写入，写入后不可改变，那读写就不会有冲突，所以不需要加锁。\n\n但实际上，因为内存是有限的，总是要发生换页操作，相当于把数据从内存中删除，这个地方还是需要用锁来控制的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585532115,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1749015,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/b0/17/451cb87c.jpg","nickname":"加油！","note":"","ucode":"947E97762DB6EF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542265,"discussion_content":"学到了，Append Only的数据模型","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640695097,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532661,"discussion_content":"简单解释一下 线程做完持久化或同步后，需要将内存数据删除，这个时候存在写覆盖问题 需要一层保护","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637662300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134282,"user_name":"顶新","can_delete":false,"product_type":"c1","uid":1036566,"ip_address":"","ucode":"241D3CCCAE536B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d1/16/6347bbc0.jpg","comment_is_top":false,"comment_ctime":1568793058,"is_pvip":false,"replies":[{"id":51547,"content":"这个地方是不需要锁的，写入和移出Callback分别是在2个固定的线程中分别执行，这个链表写入的时候直接是尾部追加，执行Callback的时候在头部移出。并且，执行Callback的时候一定链表中有数据的时候，所以也不需要加锁担心移除越界。所以这个地方是不需要锁的","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1568855667,"ip_address":"","comment_id":134282,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"FlushThread 和 ReplicationThread线程对内存的链表 Pending Callbacks 中数据的更新，然后ResponseThread扫描链表Pending Callbacks，批量取出符合 QOS 规则的响应及超时的响应，然后并发返回给客户端。这块也存在对 Pending Callbacks 存在互斥锁吧？不知道理解的对不对，还请老师答疑 :)","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467690,"discussion_content":"这个地方是不需要锁的，写入和移出Callback分别是在2个固定的线程中分别执行，这个链表写入的时候直接是尾部追加，执行Callback的时候在头部移出。并且，执行Callback的时候一定链表中有数据的时候，所以也不需要加锁担心移除越界。所以这个地方是不需要锁的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568855667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127545,"user_name":"ykkk88","can_delete":false,"product_type":"c1","uid":1068585,"ip_address":"","ucode":"A1BCFC2F0D1022","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/29/1be3dd40.jpg","comment_is_top":false,"comment_ctime":1566739307,"is_pvip":false,"replies":[{"id":47510,"content":"是的。\n\n一般的协议都是这种“请求-响应”的方式，不需要同步的请求之间有序。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566867996,"ip_address":"","comment_id":127545,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"如果要保证前一句话要对方确认回复后再发送下一句话 就不能用这种方式了吧？这样吞吐量就会很低了","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464544,"discussion_content":"是的。\n\n一般的协议都是这种“请求-响应”的方式，不需要同步的请求之间有序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566867996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127533,"user_name":"TWT_Marq","can_delete":false,"product_type":"c1","uid":1238077,"ip_address":"","ucode":"1E1E14C7281477","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/3d/5d51fda4.jpg","comment_is_top":false,"comment_ctime":1566736554,"is_pvip":false,"replies":[{"id":47508,"content":"是的","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566867942,"ip_address":"","comment_id":127533,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"JMQ中，接受请求的iothreads将请求丢给request queue，WriteThread从queue中取出来开始干活。这个queue是concurrentBlockingQueue吗？","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464537,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566867942,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127448,"user_name":"linqw","can_delete":false,"product_type":"c1","uid":1134138,"ip_address":"","ucode":"09DCFE98C54DD8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","comment_is_top":false,"comment_ctime":1566717576,"is_pvip":false,"replies":[{"id":47506,"content":"还是贴一下GitHub的链接把，也方便其他同学学习。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566867867,"ip_address":"","comment_id":127448,"utype":1}],"discussion_count":10,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"我用java实现了一版，老师帮忙看下哦，评论只能发2000字，其余在评论区补上\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.annotation.Nonnull;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.locks.ReentrantLock;\n\n&#47;**\n * @author linqw\n *&#47;\npublic class SocketExample {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(SocketExample.class);\n\n    private static final ReentrantLock LI_WRITE_REENTRANT_LOCK = new ReentrantLock();\n\n    private static final ReentrantLock ZHANG_WRITE_REENTRANT_LOCK = new ReentrantLock();\n\n    private static final int NCPU = Runtime.getRuntime().availableProcessors();\n\n    private final ThreadPoolExecutor serverThreadPoolExecutor = new ThreadPoolExecutor(NCPU, NCPU, 5, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(200000), new ThreadFactoryImpl(&quot;server-&quot;), new ThreadPoolExecutor.CallerRunsPolicy());\n\n    private final ThreadPoolExecutor clientThreadPoolExecutor = new ThreadPoolExecutor(NCPU, NCPU, 5, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(200000), new ThreadFactoryImpl(&quot;client-&quot;), new ThreadPoolExecutor.CallerRunsPolicy());\n\n    private volatile boolean started = false;\n\n    &#47;**\n     * 俩大爷已经遇见了多少次\n     *&#47;\n    private volatile AtomicInteger count = new AtomicInteger(0);\n\n    &#47;**\n     * 总共需要遇见多少次\n     *&#47;\n    private static final int TOTAL = 1;\n\n    private static final String Z0 = &quot; 吃了没，您吶?&quot;;\n\n    private static final String Z3 = &quot; 嗨！吃饱了溜溜弯儿。&quot;;\n    private static final String Z5 = &quot; 回头去给老太太请安！&quot;;\n    private static final String L1 = &quot; 刚吃。&quot;;\n    private static final String L2 = &quot; 您这，嘛去？&quot;;\n    private static final String L4 = &quot; 有空家里坐坐啊。&quot;;","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464537,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566867942,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127344,"user_name":"豆沙包","can_delete":false,"product_type":"c1","uid":1223954,"ip_address":"","ucode":"7C62E546E6786A","user_header":"https://static001.geekbang.org/account/avatar/00/12/ad/12/d4d54dd2.jpg","comment_is_top":false,"comment_ctime":1566659587,"is_pvip":false,"replies":[{"id":47163,"content":"这个地方是因为，完成了所有会话之后，关闭socket连接的时候，没有先等待2个大爷读写socket的4个线程都结束导致的。\n\n虽然不影响结果，但还是可以改进一下，做到优雅的退出。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566708952,"ip_address":"","comment_id":127344,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"老师，我在运行你的老大爷代码的时候发现了一个问题，经常报读长度故障。我调试了一下，应该是因为张大爷阻塞在readfrom的时候，李大爷count++了。然后count大于total，client释放了tcp。这导致readfrom无法读出准确数据。我在返回读数据故障前判断了一下count和total的关系，如果count大于等于total正常返回，就没有再报过异常了。您看我分析的是否有问题呢","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464495,"discussion_content":"还是贴一下GitHub的链接把，也方便其他同学学习。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566867867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134138,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","nickname":"linqw","note":"","ucode":"09DCFE98C54DD8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6132,"discussion_content":"class RequestResponse {\n        int serial;\n        String payLoad;\n\n        @Override\n        public String toString() {\n            return &#34;RequestResponse{&#34; +\n                    &#34;serial=&#34; + serial +\n                    &#34;, payLoad=&#39;&#34; + payLoad + &#39;\\&#39;&#39; +\n                    &#39;}&#39;;\n        }\n    }\n\n    private void writeTo(RequestResponse requestResponse, ReentrantLock reentrantLock, Socket socket) {\n        try {\n            OutputStream outputStream = socket.getOutputStream();\n            byte[] payloadBytes = requestResponse.payLoad.getBytes();\n            byte[] serialBytes = intToByte(requestResponse.serial);\n            int length = payloadBytes.length + serialBytes.length;\n            byte[] lengthBytes = intToByte(length);\n            reentrantLock.lock();\n            outputStream.write(lengthBytes);\n            outputStream.write(serialBytes);\n            outputStream.write(payloadBytes);\n            outputStream.flush();\n        } catch (IOException e) {\n            LOGGER.error(e.toString());\n        } finally {\n            reentrantLock.unlock();\n        }\n    }\n\n    ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1566719012,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1103652,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d7/24/bdc0e12b.jpg","nickname":"施华洛","note":"","ucode":"138B4A0E4EA76A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6224,"discussion_content":"来个git版本的啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566795049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1134138,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","nickname":"linqw","note":"","ucode":"09DCFE98C54DD8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1103652,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d7/24/bdc0e12b.jpg","nickname":"施华洛","note":"","ucode":"138B4A0E4EA76A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6279,"discussion_content":"我找个时间，用netty、 nio也实现下，统一放在GitHub上","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1566820342,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":6224,"ip_address":"","group_id":0},"score":6279,"extra":""}]},{"author":{"id":1134138,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","nickname":"linqw","note":"","ucode":"09DCFE98C54DD8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6138,"discussion_content":"  class ThreadFactoryImpl implements ThreadFactory {\n        private final AtomicLong threadIndex = new AtomicLong(0);\n        private final String threadNamePrefix;\n        private final boolean daemon;\n\n        ThreadFactoryImpl(final String threadNamePrefix) {\n            this(threadNamePrefix, false);\n        }\n\n        ThreadFactoryImpl(final String threadNamePrefix, boolean daemon) {\n            this.threadNamePrefix = threadNamePrefix;\n            this.daemon = daemon;\n        }\n\n        @Override\n        public Thread newThread(@Nonnull Runnable r) {\n            Thread thread = new Thread(r, threadNamePrefix + this.threadIndex.incrementAndGet());\n            thread.setDaemon(daemon);\n            return thread;\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        SocketExample socketExample = new SocketExample();\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                socketExample.startServer(9999);\n            }\n        }).start();\n        while (!socketExample.started) {\n            Thread.sleep(1);\n        }\n        long start = System.nanoTime();\n        socketExample.startClient(&#34;127.0.0.1&#34;, 9999);\n        long end = System.nanoTime();\n        System.out.println(TimeUnit.SECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    }\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566719271,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134138,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","nickname":"linqw","note":"","ucode":"09DCFE98C54DD8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6137,"discussion_content":" private void startClient(String host, int port) {\n        final CountDownLatch countDownLatch = new CountDownLatch(1);\n        // 与服务端建立连接\n        try (Socket socket = new Socket(host, port)) {\n            clientThreadPoolExecutor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    liDaYeListen(socket, countDownLatch);\n\n                }\n            });\n            clientThreadPoolExecutor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    liDaYeSay(socket);\n                }\n            });\n            countDownLatch.await();\n        } catch (IOException | InterruptedException e) {\n            LOGGER.error(e.toString());\n        }\n\n    }\n\n    private byte[] intToByte(int val) {\n        byte[] bytes = new byte[4];\n        bytes[0] = (byte) (val &amp; 0xff);\n        bytes[1] = (byte) ((val >> 8) &amp; 0xff);\n        bytes[2] = (byte) ((val >> 16) &amp; 0xff);\n        bytes[3] = (byte) ((val >> 24) &amp; 0xff);\n        return bytes;\n    }\n\n    private int byteToInt(byte[] bytes) {\n        int val = 0;\n        if (bytes == null || bytes.length < 4) {\n            return val;\n        }\n        val += bytes[0] &amp; 0xff;\n        val += (bytes[1] &amp; 0xff) << 8;\n        val += (bytes[2] &amp; 0xff) << 16;\n        val += (bytes[3] &amp; 0xff) << 24;\n        return val;\n    }\n\n  ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566719267,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134138,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","nickname":"linqw","note":"","ucode":"09DCFE98C54DD8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6136,"discussion_content":"    /**\n     * 李大爷的嘴\n     */\n    private void liDaYeSay(Socket socket) {\n        AtomicInteger nextSerial = new AtomicInteger(0);\n        for (int i = 0; i < TOTAL; i++) {\n            clientThreadPoolExecutor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    RequestResponse requestResponse = new RequestResponse();\n                    requestResponse.serial = nextSerial.getAndAdd(1);;\n                    requestResponse.payLoad = L2;\n                    writeTo(requestResponse, LI_WRITE_REENTRANT_LOCK, socket);\n                }\n            });\n            clientThreadPoolExecutor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    RequestResponse requestResponse = new RequestResponse();\n                    requestResponse.serial = nextSerial.getAndAdd(1);\n                    requestResponse.payLoad = L4;\n                    writeTo(requestResponse, LI_WRITE_REENTRANT_LOCK, socket);\n                }\n            });\n\n        }\n    }\n\n    private void startServer(int port) {\n        // 监听指定的端口\n\n        try (ServerSocket server = new ServerSocket(port)) {\n            started = true;\n            System.out.println(&#34; 张大爷在胡同口等着 ...&#34;);\n            Socket socket = server.accept();\n            System.out.println(&#34; 碰见一个李大爷:&#34; + socket.getRemoteSocketAddress().toString());\n            zhangDaYeSay(socket);\n            zhangDaYeListen(socket);\n        } catch (IOException e) {\n            LOGGER.error(e.toString());\n        }\n    }\n\n   ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566719247,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134138,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","nickname":"linqw","note":"","ucode":"09DCFE98C54DD8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6135,"discussion_content":"/**\n     * 李大爷的耳朵\n     */\n    private void liDaYeListen(Socket socket, CountDownLatch countDownLatch) {\n        while (count.get() <= TOTAL - 1) {\n            RequestResponse requestResponse = readFrom(socket);\n            if (requestResponse == null) {\n                continue;\n            }\n\n            clientThreadPoolExecutor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    // fmt.Println(&#34; 李大爷收到：&#34; + r.Payload)\n                    // 如果收到：吃了没，您吶?\n                    if (requestResponse.payLoad.equals(Z0)) {\n                        requestResponse.payLoad = L1;\n                        // 回复：刚吃。\n                        writeTo(requestResponse, LI_WRITE_REENTRANT_LOCK, socket);\n                    } else if (requestResponse.payLoad.equals(Z3)) {\n                        // do nothing\n                    } else if (requestResponse.payLoad.equals(Z5)) {\n                        //fmt.Println(&#34; 俩人说完走了 &#34;)\n                        count.incrementAndGet();\n                    } else {\n                        System.out.format(&#34; 李大爷听不懂：%s%n&#34; + requestResponse.payLoad);\n                    }\n                }\n            });\n\n        }\n        countDownLatch.countDown();\n    }\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566719210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134138,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","nickname":"linqw","note":"","ucode":"09DCFE98C54DD8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6134,"discussion_content":"  /**\n     * 张大爷的耳朵\n     */\n    private void zhangDaYeListen(Socket socket) {\n\n        while (count.get() <= TOTAL - 1) {\n            RequestResponse requestResponse = readFrom(socket);\n            if (requestResponse == null) {\n                continue;\n            }\n            serverThreadPoolExecutor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    // 如果收到：您这，嘛去？\n                    if (requestResponse.payLoad.equals(L2)) {\n                        requestResponse.payLoad = Z3;\n                        // 回复：嗨！吃饱了溜溜弯儿。\n                        writeTo(requestResponse, ZHANG_WRITE_REENTRANT_LOCK, socket);\n                        // 如果收到：有空家里坐坐啊。\n                    } else if (requestResponse.payLoad.equals(L4)) {\n                        requestResponse.payLoad = Z5;\n                        // 回复：回头去给老太太请安！\n                        writeTo(requestResponse, ZHANG_WRITE_REENTRANT_LOCK, socket);\n                        // 如果收到：刚吃。\n                    } else if (requestResponse.payLoad.equals(L1)) {\n                        // ignore不用回复\n                    } else {\n                        System.out.format(&#34; 张大爷听不懂：%s%n&#34; + requestResponse.payLoad);\n                    }\n                }\n            });\n        }\n\n\n    }\n\n    /**\n     * 张大爷的嘴\n     */\n    private void zhangDaYeSay(Socket socket) {\n        AtomicInteger nextSerial = new AtomicInteger(0);\n        for (int i = 0; i < TOTAL; i++) {\n            serverThreadPoolExecutor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    RequestResponse requestResponse = new RequestResponse();\n                    requestResponse.serial = nextSerial.getAndAdd(1);\n                    requestResponse.payLoad = Z0;\n                    writeTo(requestResponse, ZHANG_WRITE_REENTRANT_LOCK, socket);\n                }\n            });\n        }\n    }\n\n    ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566719138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134138,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","nickname":"linqw","note":"","ucode":"09DCFE98C54DD8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6133,"discussion_content":"private RequestResponse readFrom(Socket socket) {\n        RequestResponse requestResponse = new RequestResponse();\n        int length = 4;\n        int serialLength = 4;\n        byte[] payloadBytes;\n        byte[] serialBytes;\n        byte[] lengthBytes;\n        InputStream inputStream;\n        try {\n            inputStream = socket.getInputStream();\n\n            try {\n                lengthBytes = new byte[length];\n                inputStream.read(lengthBytes);\n                length = byteToInt(lengthBytes);\n                if (length <= serialLength) {\n                    return null;\n                }\n            } catch (IOException e) {\n                LOGGER.error(&#34; 读长度故障：{}&#34;, e.toString());\n            }\n            try {\n                serialBytes = new byte[4];\n                inputStream.read(serialBytes);\n                requestResponse.serial = byteToInt(serialBytes);\n            } catch (IOException e) {\n                LOGGER.error(&#34; 读Serial故障：{}&#34;, e.toString());\n            }\n            try {\n                payloadBytes = new byte[length - serialLength];\n                inputStream.read(payloadBytes);\n                requestResponse.payLoad = new String(payloadBytes);\n            } catch (IOException e) {\n                LOGGER.error(&#34; 读PayLoad故障：{}&#34;, e.toString());\n            }\n        } catch (IOException e) {\n            LOGGER.error(e.toString());\n        }\n        return requestResponse;\n\n    }\n\n  ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566719106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127215,"user_name":"solar","can_delete":false,"product_type":"c1","uid":1070335,"ip_address":"","ucode":"E6C7090478B027","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/ff/09a058f3.jpg","comment_is_top":false,"comment_ctime":1566612503,"is_pvip":false,"replies":[{"id":47078,"content":"这些想法，最好是落到代码上，通过真实的优化效果，来印证自己的想法。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566620267,"ip_address":"","comment_id":127215,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"一些分配内存地方也可以优化，可以预先分配一块复用，减少向内核申请分配内存次数.","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464379,"discussion_content":"这些想法，最好是落到代码上，通过真实的优化效果，来印证自己的想法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566620267,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1070335,"avatar":"https://static001.geekbang.org/account/avatar/00/10/54/ff/09a058f3.jpg","nickname":"solar","note":"","ucode":"E6C7090478B027","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6028,"discussion_content":"业务中曾用go实现过. 😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566620796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127212,"user_name":"Geek_zbvt62","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/d28174a9.jpg","comment_is_top":false,"comment_ctime":1566612023,"is_pvip":false,"replies":[{"id":47080,"content":"1. 这里是不需要同步的，因为这个流它具备WAL的所有特性：尾部追加、写入后不变，这种WAL读写线程之间是不需要任何协调的。\n\n2. 这个是我们单独使用堆外内存设计的一个写缓存，目的就是避免频繁的GC。\n\n3. 优化的过程是一个循序渐进的过程，并没有哪一步是一下子提升了很多。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566620620,"ip_address":"","comment_id":127212,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"想简单请教一下JMQ\n1. writeThread与ReplicationThread&#47;FlushThread之间的同步也要基于无锁队列是吧？\n2. JournalCache就是简单的用户态内存，还是基于mmap？（从描述上看感觉就是用户态内存）。\n3. 老师能不能透露一下，在研发JMQ的过程中，解决了哪个瓶颈之后，吞吐量一下子提了很多呢？","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464378,"discussion_content":"1. 这里是不需要同步的，因为这个流它具备WAL的所有特性：尾部追加、写入后不变，这种WAL读写线程之间是不需要任何协调的。\n\n2. 这个是我们单独使用堆外内存设计的一个写缓存，目的就是避免频繁的GC。\n\n3. 优化的过程是一个循序渐进的过程，并没有哪一步是一下子提升了很多。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566620620,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140558,"user_name":"Tesla","can_delete":false,"product_type":"c1","uid":1500742,"ip_address":"","ucode":"98629AFD9861EE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKUcSLVV6ia3dibe7qvTu8Vic1PVs2EibxoUdx930MC7j2Q9A6s4eibMDZlcicMFY0D0icd3RrDorMChu0zw/132","comment_is_top":false,"comment_ctime":1570985576,"is_pvip":false,"replies":[{"id":54348,"content":"不是这样的，以你这个例子来说，假设abcd这条消息前面再也没有其它消息的，它是最前的一条，abcd这条消息的offset就是0， abcdefgh这条消息的offset就是6.","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1571018586,"ip_address":"","comment_id":140558,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"老师好，请问一下WriteThread中将消息序列化并维护起止位置offset，这个offset是否就是头部信息中保存消息长度呢？比如04abcd08abcdefgh，通过04就可以知道abcd消息的起止位置，下一个读到的08则代表下一条消息的起止位置？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464378,"discussion_content":"1. 这里是不需要同步的，因为这个流它具备WAL的所有特性：尾部追加、写入后不变，这种WAL读写线程之间是不需要任何协调的。\n\n2. 这个是我们单独使用堆外内存设计的一个写缓存，目的就是避免频繁的GC。\n\n3. 优化的过程是一个循序渐进的过程，并没有哪一步是一下子提升了很多。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566620620,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135953,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1569313877,"is_pvip":false,"replies":[{"id":52146,"content":"是的，这里的“异步”是指，发响应给客户端并不是由复制或者刷盘线程来执行的，而是单独的一组线程。给每个客户端发响应这个操作是可以并行执行的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1569375374,"ip_address":"","comment_id":135953,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"老师好， ReponseThreads 这组线程，怎么实现异步并行的没太理解，她不是需要等待复制响应或者落盘后才发消息给客户端嘛？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468399,"discussion_content":"是的，这里的“异步”是指，发响应给客户端并不是由复制或者刷盘线程来执行的，而是单独的一组线程。给每个客户端发响应这个操作是可以并行执行的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569375374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129609,"user_name":"大白先生","can_delete":false,"product_type":"c1","uid":1615335,"ip_address":"","ucode":"7EF709EF8FFE6B","user_header":"https://static001.geekbang.org/account/avatar/00/18/a5/e7/ed0a0131.jpg","comment_is_top":false,"comment_ctime":1567171879,"is_pvip":false,"replies":[{"id":48361,"content":"无论是用前置长度还是分隔符的方式断句，一个10K的消息，当接收方收到前8K的时候，它是肯定可以知道“这条消息我只收到了一部分”，这个时候它就什么都不做，等着把剩下的部分收全就行了。\n\n你在这里面有一个误区就是，每次读到一部分数据，不是说一定非要把这部分数据全都解析完，能解析出来整句的消息，拿去处理。剩下半句的扔在那儿不管，等着后半句来了再解析就行了。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567214143,"ip_address":"","comment_id":129609,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"老师，我基于之前半包粘包的问题还想问一个问题。之前您说如果按照咱们课上讲的自定义消息格式，不会出现这种情况。我想问，如果出现概念上的半包情况，也就是说，soket首发缓存去8k，我这边写入一条10k的消息，那么接收方按照咱们定义的格式解析，那不就是解析到了前8k的数据，那么按照数据钱的包长度解析的时候，数据的长度就不够，这样不会引起数据错误么","like_count":1},{"had_liked":false,"id":128607,"user_name":"大白先生","can_delete":false,"product_type":"c1","uid":1615335,"ip_address":"","ucode":"7EF709EF8FFE6B","user_header":"https://static001.geekbang.org/account/avatar/00/18/a5/e7/ed0a0131.jpg","comment_is_top":false,"comment_ctime":1566912873,"is_pvip":false,"replies":[{"id":47843,"content":"其实，并没有所谓的粘包或者半包问题，我在之前的课程中讲过，依靠数据流的自然分隔来断句是不靠谱的，TCP协议本身也没有支持或者保证，每次发出的的一批数据，对方一定也会“一次性”的收到起止位置相同的一批数据，实际上tcp连接通道他是一个双向流，流中的数据是没有什么天然的分割的，也根本不会保证什么“批”。所以，所谓的“粘包”或者“半包”都是伪概念，只要你在协议设计上，能够按照我们提供的方法进行断句，即使出现“粘包半包”，依然可以正确的传输数据。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566973276,"ip_address":"","comment_id":128607,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"老师，我在学习java实现tcp发送数据时，我有看到有讲解tcp粘包或者是半包的情况，我看的文章说是可能是因为一次写入的数据大于soket发送缓冲区。会导致接收方接受数据有问题。但是我写例子的时候没有发现这个问题，请问，怎么能弄出这两种情况？假如不用netty时，利用soket能如何处理这种问题。","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465565,"discussion_content":"无论是用前置长度还是分隔符的方式断句，一个10K的消息，当接收方收到前8K的时候，它是肯定可以知道“这条消息我只收到了一部分”，这个时候它就什么都不做，等着把剩下的部分收全就行了。\n\n你在这里面有一个误区就是，每次读到一部分数据，不是说一定非要把这部分数据全都解析完，能解析出来整句的消息，拿去处理。剩下半句的扔在那儿不管，等着后半句来了再解析就行了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567214143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181991,"user_name":"Geek_498c16","can_delete":false,"product_type":"c1","uid":1716617,"ip_address":"","ucode":"616913785EFF06","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL6ibvATzI5FKR6r71GU3CjdlPkZYYSBYBtNibIGENFZDnqajW7LOPKZXUPWSsjt8OiaxTZ0neT8LwQQ/132","comment_is_top":false,"comment_ctime":1582688776,"is_pvip":false,"replies":[{"id":70562,"content":"达到系统处理能力极限之后，消息就会堆积到这里，这样也客观上起了一个背压的效果。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1582766609,"ip_address":"","comment_id":181991,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"Requests Queue 不会存在 WriteThread处理慢导致队列塞满的情况吗? 看了下流程Requests Queue 的取是比放慢的.","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465020,"discussion_content":"其实，并没有所谓的粘包或者半包问题，我在之前的课程中讲过，依靠数据流的自然分隔来断句是不靠谱的，TCP协议本身也没有支持或者保证，每次发出的的一批数据，对方一定也会“一次性”的收到起止位置相同的一批数据，实际上tcp连接通道他是一个双向流，流中的数据是没有什么天然的分割的，也根本不会保证什么“批”。所以，所谓的“粘包”或者“半包”都是伪概念，只要你在协议设计上，能够按照我们提供的方法进行断句，即使出现“粘包半包”，依然可以正确的传输数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566973276,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1485489,"avatar":"https://static001.geekbang.org/account/avatar/00/16/aa/b1/c834aab5.jpg","nickname":"张小勋","note":"","ucode":"8C5E434EF53BF4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38140,"discussion_content":"TCP 不是分次发包的么  不存在粘包或者半包问题？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571734384,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136564,"user_name":"Six Days","can_delete":false,"product_type":"c1","uid":1322463,"ip_address":"","ucode":"8587F2EEFFFD11","user_header":"https://static001.geekbang.org/account/avatar/00/14/2d/df/4949b250.jpg","comment_is_top":false,"comment_ctime":1569472990,"is_pvip":false,"replies":[{"id":52404,"content":"后续我们会把所有代码都开源出来的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1569495979,"ip_address":"","comment_id":136564,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"老师，希望能给出一份java 版本的参考代码以供学习，谢谢你了","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468695,"discussion_content":"后续我们会把所有代码都开源出来的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569495979,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135070,"user_name":"mark","can_delete":false,"product_type":"c1","uid":1015720,"ip_address":"","ucode":"39EDFEA8010F9B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/a8/d103904b.jpg","comment_is_top":false,"comment_ctime":1568996358,"is_pvip":false,"replies":[{"id":51838,"content":"👍👍👍\n最好能说一下你优化了哪些地方。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1569024178,"ip_address":"","comment_id":135070,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"做了一点优化，到了 3s\n\nhttps:&#47;&#47;gist.github.com&#47;vipwzw&#47;382f68995e26a2696e4da8cc5039c595","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468695,"discussion_content":"后续我们会把所有代码都开源出来的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569495979,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132474,"user_name":"Luciano李鑫","can_delete":false,"product_type":"c1","uid":1329995,"ip_address":"","ucode":"5FBE5F86FD5B2C","user_header":"https://static001.geekbang.org/account/avatar/00/14/4b/4b/97926cba.jpg","comment_is_top":false,"comment_ctime":1568130705,"is_pvip":false,"replies":[{"id":50694,"content":"这种错误一般是连接中断了。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1568165215,"ip_address":"","comment_id":132474,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"读长度故障 read: connection reset by peer ,请问下这是为什么，macOS系统","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468030,"discussion_content":"👍👍👍\n最好能说一下你优化了哪些地方。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569024178,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015720,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/a8/d103904b.jpg","nickname":"mark","note":"","ucode":"39EDFEA8010F9B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":18133,"discussion_content":"1. 读写添加了bufio 2. 编码解码用了 sync.Pool 主要就是加了一些缓冲。其实还可以优化，比如做批量的发送之类的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569025392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132395,"user_name":"aroll","can_delete":false,"product_type":"c1","uid":1023524,"ip_address":"","ucode":"3A1A1267C88CC3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9e/24/0d6a7987.jpg","comment_is_top":false,"comment_ctime":1568108905,"is_pvip":false,"replies":[{"id":51008,"content":"我检查了一下这段代码，确实在并发的时候可能出现你说的问题，原因是，代码中俩大爷只用了一个count来计数，张大爷收到了所有的对话就结束了程序，但是李大爷可能还没收全消息。\n\n我已经修改了代码，你可以再参考一下。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1568431684,"ip_address":"","comment_id":132395,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"老师，你用go语言实现的代码，我把fmt.Println放开之后跑了一下，发现有消息丢失的现象，&quot; 嗨！吃饱了溜溜弯儿。&quot;（这一句总是少一次），&quot; 刚吃。&quot;（这一句时有时没有），我对go了解不多，没看出来咋回事","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466911,"discussion_content":"我检查了一下这段代码，确实在并发的时候可能出现你说的问题，原因是，代码中俩大爷只用了一个count来计数，张大爷收到了所有的对话就结束了程序，但是李大爷可能还没收全消息。\n\n我已经修改了代码，你可以再参考一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568431684,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127551,"user_name":"ykkk88","can_delete":false,"product_type":"c1","uid":1068585,"ip_address":"","ucode":"A1BCFC2F0D1022","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/29/1be3dd40.jpg","comment_is_top":false,"comment_ctime":1566739584,"is_pvip":false,"replies":[{"id":47511,"content":"不用等。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566868006,"ip_address":"","comment_id":127551,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"老师  重新看了下上面这个例子我的理解是异步方式发送消息吧，发送完不会等到消息回来再发第二个？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464545,"discussion_content":"不用等。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566868006,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1199968,"avatar":"https://static001.geekbang.org/account/avatar/00/12/4f/60/049a20e9.jpg","nickname":"吴宇晨","note":"","ucode":"F8F45B7067DF6D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6269,"discussion_content":"那只是在发送和接收消息时是异步的，因为有序号，客户端收到后可以按序号还原问答顺序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566817869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127388,"user_name":"coffee","can_delete":false,"product_type":"c1","uid":1391640,"ip_address":"","ucode":"DF831C481B7949","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/vK7WwQG23CI29w0iamcgetTicMdQ8NsJsQWSXIia3aSUbVE6dqfTiaVtqTdibJu31f7k2BkOSkQianxOUaqojEYP6ic3w/132","comment_is_top":false,"comment_ctime":1566693419,"is_pvip":false,"replies":[{"id":47164,"content":"👍👍👍","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566708993,"ip_address":"","comment_id":127388,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"老师，已将单工通讯改成了双工通讯，时间上确定有提高。10万次大概在3364-4873毫秒这个区间。\nhttps:&#47;&#47;github.com&#47;swgithub1006&#47;mqlearning\n协议上的确还有优化的空间，比如借鉴下protobuf的设计思想。","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464545,"discussion_content":"不用等。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566868006,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1199968,"avatar":"https://static001.geekbang.org/account/avatar/00/12/4f/60/049a20e9.jpg","nickname":"吴宇晨","note":"","ucode":"F8F45B7067DF6D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6269,"discussion_content":"那只是在发送和接收消息时是异步的，因为有序号，客户端收到后可以按序号还原问答顺序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566817869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127200,"user_name":"路人","can_delete":false,"product_type":"c1","uid":1084291,"ip_address":"","ucode":"55FF703DE772D7","user_header":"https://static001.geekbang.org/account/avatar/00/10/8b/83/d2afc837.jpg","comment_is_top":false,"comment_ctime":1566608795,"is_pvip":false,"replies":[{"id":47081,"content":"使用Keynote绘制的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566620709,"ip_address":"","comment_id":127200,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"老师的课讲的很好，基本上讲的都是一些消息相关的设计理念，站的角度也比较高，非常实用。请问下老师文中的图用的什么工具画的","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464470,"discussion_content":"👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566708993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129609,"user_name":"大白先生","can_delete":false,"product_type":"c1","uid":1615335,"ip_address":"","ucode":"7EF709EF8FFE6B","user_header":"https://static001.geekbang.org/account/avatar/00/18/a5/e7/ed0a0131.jpg","comment_is_top":false,"comment_ctime":1567171879,"is_pvip":false,"replies":[{"id":48361,"content":"无论是用前置长度还是分隔符的方式断句，一个10K的消息，当接收方收到前8K的时候，它是肯定可以知道“这条消息我只收到了一部分”，这个时候它就什么都不做，等着把剩下的部分收全就行了。\n\n你在这里面有一个误区就是，每次读到一部分数据，不是说一定非要把这部分数据全都解析完，能解析出来整句的消息，拿去处理。剩下半句的扔在那儿不管，等着后半句来了再解析就行了。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567214143,"ip_address":"","comment_id":129609,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"老师，我基于之前半包粘包的问题还想问一个问题。之前您说如果按照咱们课上讲的自定义消息格式，不会出现这种情况。我想问，如果出现概念上的半包情况，也就是说，soket首发缓存去8k，我这边写入一条10k的消息，那么接收方按照咱们定义的格式解析，那不就是解析到了前8k的数据，那么按照数据钱的包长度解析的时候，数据的长度就不够，这样不会引起数据错误么","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465565,"discussion_content":"无论是用前置长度还是分隔符的方式断句，一个10K的消息，当接收方收到前8K的时候，它是肯定可以知道“这条消息我只收到了一部分”，这个时候它就什么都不做，等着把剩下的部分收全就行了。\n\n你在这里面有一个误区就是，每次读到一部分数据，不是说一定非要把这部分数据全都解析完，能解析出来整句的消息，拿去处理。剩下半句的扔在那儿不管，等着后半句来了再解析就行了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567214143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128607,"user_name":"大白先生","can_delete":false,"product_type":"c1","uid":1615335,"ip_address":"","ucode":"7EF709EF8FFE6B","user_header":"https://static001.geekbang.org/account/avatar/00/18/a5/e7/ed0a0131.jpg","comment_is_top":false,"comment_ctime":1566912873,"is_pvip":false,"replies":[{"id":47843,"content":"其实，并没有所谓的粘包或者半包问题，我在之前的课程中讲过，依靠数据流的自然分隔来断句是不靠谱的，TCP协议本身也没有支持或者保证，每次发出的的一批数据，对方一定也会“一次性”的收到起止位置相同的一批数据，实际上tcp连接通道他是一个双向流，流中的数据是没有什么天然的分割的，也根本不会保证什么“批”。所以，所谓的“粘包”或者“半包”都是伪概念，只要你在协议设计上，能够按照我们提供的方法进行断句，即使出现“粘包半包”，依然可以正确的传输数据。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566973276,"ip_address":"","comment_id":128607,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"老师，我在学习java实现tcp发送数据时，我有看到有讲解tcp粘包或者是半包的情况，我看的文章说是可能是因为一次写入的数据大于soket发送缓冲区。会导致接收方接受数据有问题。但是我写例子的时候没有发现这个问题，请问，怎么能弄出这两种情况？假如不用netty时，利用soket能如何处理这种问题。","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465020,"discussion_content":"其实，并没有所谓的粘包或者半包问题，我在之前的课程中讲过，依靠数据流的自然分隔来断句是不靠谱的，TCP协议本身也没有支持或者保证，每次发出的的一批数据，对方一定也会“一次性”的收到起止位置相同的一批数据，实际上tcp连接通道他是一个双向流，流中的数据是没有什么天然的分割的，也根本不会保证什么“批”。所以，所谓的“粘包”或者“半包”都是伪概念，只要你在协议设计上，能够按照我们提供的方法进行断句，即使出现“粘包半包”，依然可以正确的传输数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566973276,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1485489,"avatar":"https://static001.geekbang.org/account/avatar/00/16/aa/b1/c834aab5.jpg","nickname":"张小勋","note":"","ucode":"8C5E434EF53BF4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38140,"discussion_content":"TCP 不是分次发包的么  不存在粘包或者半包问题？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571734384,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181991,"user_name":"Geek_498c16","can_delete":false,"product_type":"c1","uid":1716617,"ip_address":"","ucode":"616913785EFF06","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL6ibvATzI5FKR6r71GU3CjdlPkZYYSBYBtNibIGENFZDnqajW7LOPKZXUPWSsjt8OiaxTZ0neT8LwQQ/132","comment_is_top":false,"comment_ctime":1582688776,"is_pvip":false,"replies":[{"id":70562,"content":"达到系统处理能力极限之后，消息就会堆积到这里，这样也客观上起了一个背压的效果。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1582766609,"ip_address":"","comment_id":181991,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"Requests Queue 不会存在 WriteThread处理慢导致队列塞满的情况吗? 看了下流程Requests Queue 的取是比放慢的.","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485189,"discussion_content":"达到系统处理能力极限之后，消息就会堆积到这里，这样也客观上起了一个背压的效果。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582766609,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1716617,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL6ibvATzI5FKR6r71GU3CjdlPkZYYSBYBtNibIGENFZDnqajW7LOPKZXUPWSsjt8OiaxTZ0neT8LwQQ/132","nickname":"Geek_498c16","note":"","ucode":"616913785EFF06","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":187841,"discussion_content":"你这里的队列是有界的吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582772371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136564,"user_name":"Six Days","can_delete":false,"product_type":"c1","uid":1322463,"ip_address":"","ucode":"8587F2EEFFFD11","user_header":"https://static001.geekbang.org/account/avatar/00/14/2d/df/4949b250.jpg","comment_is_top":false,"comment_ctime":1569472990,"is_pvip":false,"replies":[{"id":52404,"content":"后续我们会把所有代码都开源出来的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1569495979,"ip_address":"","comment_id":136564,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"老师，希望能给出一份java 版本的参考代码以供学习，谢谢你了","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485189,"discussion_content":"达到系统处理能力极限之后，消息就会堆积到这里，这样也客观上起了一个背压的效果。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582766609,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1716617,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL6ibvATzI5FKR6r71GU3CjdlPkZYYSBYBtNibIGENFZDnqajW7LOPKZXUPWSsjt8OiaxTZ0neT8LwQQ/132","nickname":"Geek_498c16","note":"","ucode":"616913785EFF06","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":187841,"discussion_content":"你这里的队列是有界的吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582772371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135070,"user_name":"mark","can_delete":false,"product_type":"c1","uid":1015720,"ip_address":"","ucode":"39EDFEA8010F9B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/a8/d103904b.jpg","comment_is_top":false,"comment_ctime":1568996358,"is_pvip":false,"replies":[{"id":51838,"content":"👍👍👍\n最好能说一下你优化了哪些地方。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1569024178,"ip_address":"","comment_id":135070,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"做了一点优化，到了 3s\n\nhttps:&#47;&#47;gist.github.com&#47;vipwzw&#47;382f68995e26a2696e4da8cc5039c595","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468030,"discussion_content":"👍👍👍\n最好能说一下你优化了哪些地方。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569024178,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015720,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/a8/d103904b.jpg","nickname":"mark","note":"","ucode":"39EDFEA8010F9B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":18133,"discussion_content":"1. 读写添加了bufio 2. 编码解码用了 sync.Pool 主要就是加了一些缓冲。其实还可以优化，比如做批量的发送之类的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569025392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132474,"user_name":"Luciano李鑫","can_delete":false,"product_type":"c1","uid":1329995,"ip_address":"","ucode":"5FBE5F86FD5B2C","user_header":"https://static001.geekbang.org/account/avatar/00/14/4b/4b/97926cba.jpg","comment_is_top":false,"comment_ctime":1568130705,"is_pvip":false,"replies":[{"id":50694,"content":"这种错误一般是连接中断了。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1568165215,"ip_address":"","comment_id":132474,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"读长度故障 read: connection reset by peer ,请问下这是为什么，macOS系统","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466960,"discussion_content":"这种错误一般是连接中断了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568165215,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1329995,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4b/4b/97926cba.jpg","nickname":"Luciano李鑫","note":"","ucode":"5FBE5F86FD5B2C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":10080,"discussion_content":"我在Linux测试没问题 macOS上会报上面的错，一般什么情况会导致被动中断呢，客户端和服务端都在本地，偶尔还会报EOF","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568262074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132395,"user_name":"aroll","can_delete":false,"product_type":"c1","uid":1023524,"ip_address":"","ucode":"3A1A1267C88CC3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9e/24/0d6a7987.jpg","comment_is_top":false,"comment_ctime":1568108905,"is_pvip":false,"replies":[{"id":51008,"content":"我检查了一下这段代码，确实在并发的时候可能出现你说的问题，原因是，代码中俩大爷只用了一个count来计数，张大爷收到了所有的对话就结束了程序，但是李大爷可能还没收全消息。\n\n我已经修改了代码，你可以再参考一下。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1568431684,"ip_address":"","comment_id":132395,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"老师，你用go语言实现的代码，我把fmt.Println放开之后跑了一下，发现有消息丢失的现象，&quot; 嗨！吃饱了溜溜弯儿。&quot;（这一句总是少一次），&quot; 刚吃。&quot;（这一句时有时没有），我对go了解不多，没看出来咋回事","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466960,"discussion_content":"这种错误一般是连接中断了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568165215,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1329995,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4b/4b/97926cba.jpg","nickname":"Luciano李鑫","note":"","ucode":"5FBE5F86FD5B2C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":10080,"discussion_content":"我在Linux测试没问题 macOS上会报上面的错，一般什么情况会导致被动中断呢，客户端和服务端都在本地，偶尔还会报EOF","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568262074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127551,"user_name":"ykkk88","can_delete":false,"product_type":"c1","uid":1068585,"ip_address":"","ucode":"A1BCFC2F0D1022","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/29/1be3dd40.jpg","comment_is_top":false,"comment_ctime":1566739584,"is_pvip":false,"replies":[{"id":47511,"content":"不用等。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566868006,"ip_address":"","comment_id":127551,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"老师  重新看了下上面这个例子我的理解是异步方式发送消息吧，发送完不会等到消息回来再发第二个？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466911,"discussion_content":"我检查了一下这段代码，确实在并发的时候可能出现你说的问题，原因是，代码中俩大爷只用了一个count来计数，张大爷收到了所有的对话就结束了程序，但是李大爷可能还没收全消息。\n\n我已经修改了代码，你可以再参考一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568431684,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127388,"user_name":"coffee","can_delete":false,"product_type":"c1","uid":1391640,"ip_address":"","ucode":"DF831C481B7949","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/vK7WwQG23CI29w0iamcgetTicMdQ8NsJsQWSXIia3aSUbVE6dqfTiaVtqTdibJu31f7k2BkOSkQianxOUaqojEYP6ic3w/132","comment_is_top":false,"comment_ctime":1566693419,"is_pvip":false,"replies":[{"id":47164,"content":"👍👍👍","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566708993,"ip_address":"","comment_id":127388,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"老师，已将单工通讯改成了双工通讯，时间上确定有提高。10万次大概在3364-4873毫秒这个区间。\nhttps:&#47;&#47;github.com&#47;swgithub1006&#47;mqlearning\n协议上的确还有优化的空间，比如借鉴下protobuf的设计思想。","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464470,"discussion_content":"👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566708993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127200,"user_name":"路人","can_delete":false,"product_type":"c1","uid":1084291,"ip_address":"","ucode":"55FF703DE772D7","user_header":"https://static001.geekbang.org/account/avatar/00/10/8b/83/d2afc837.jpg","comment_is_top":false,"comment_ctime":1566608795,"is_pvip":false,"replies":[{"id":47081,"content":"使用Keynote绘制的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566620709,"ip_address":"","comment_id":127200,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"老师的课讲的很好，基本上讲的都是一些消息相关的设计理念，站的角度也比较高，非常实用。请问下老师文中的图用的什么工具画的","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464372,"discussion_content":"使用Keynote绘制的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566620709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128691,"user_name":"付永强","can_delete":false,"product_type":"c1","uid":1419544,"ip_address":"","ucode":"898998296EBD56","user_header":"https://static001.geekbang.org/account/avatar/00/15/a9/18/393a841d.jpg","comment_is_top":false,"comment_ctime":1566952077,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"这么看来JMQ基本上是把所有涉及io等待地方步骤进行异步设计。学到了！感谢分享！🤔","like_count":18},{"had_liked":false,"id":143344,"user_name":"谢清","can_delete":false,"product_type":"c1","uid":1069849,"ip_address":"","ucode":"31B2862A790CEB","user_header":"https://static001.geekbang.org/account/avatar/00/10/53/19/dec74631.jpg","comment_is_top":false,"comment_ctime":1571671174,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"刷了下评论，青舟写的最好，其次Martin\n青舟\nhttps:&#47;&#47;github.com&#47;qingzhou413&#47;geektime-mq-rpc.git\nMartin\nhttps:&#47;&#47;github.com&#47;MartinDai&#47;mq-in-action&#47;blob&#47;master&#47;src&#47;main&#47;java&#47;com&#47;doodl6&#47;mq&#47;MeetInRpc.java","like_count":12},{"had_liked":false,"id":127240,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1566618427,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"老师说得很好，想成为一个真成的高手，理解并实践这些基本原理，是必不可少的，不要只停留在知识的表面，要领会技术背后的思想，才能活学活用，实践肯定是少不了的，加油。","like_count":5},{"had_liked":false,"id":181068,"user_name":"凡","can_delete":false,"product_type":"c1","uid":1721168,"ip_address":"","ucode":"80C2A6452AB9EA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/43/50/abb4ca1e.jpg","comment_is_top":false,"comment_ctime":1582469319,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"借鉴了 MySql 的思想，跟新数据先写入 Buffer pool，然后定期将内存的数据刷到磁盘，这样减少了磁盘 IO 的操作频率，提高了性能","like_count":2},{"had_liked":false,"id":271466,"user_name":"自拍不开美颜","can_delete":false,"product_type":"c1","uid":1925935,"ip_address":"","ucode":"711CF52CF68434","user_header":"https://static001.geekbang.org/account/avatar/00/1d/63/2f/f7e5b8c4.jpg","comment_is_top":false,"comment_ctime":1609654813,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"一问一答，是半双工而不是单工。","like_count":1},{"had_liked":false,"id":128298,"user_name":"大魔王汪汪","can_delete":false,"product_type":"c1","uid":1010680,"ip_address":"","ucode":"4B205CB52FC95F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/f8/b4da7936.jpg","comment_is_top":false,"comment_ctime":1566869491,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"整个设计方案简单的看是几个消费生产模型的组合😍","like_count":1},{"had_liked":false,"id":127198,"user_name":"leslie","can_delete":false,"product_type":"c1","uid":1324255,"ip_address":"","ucode":"798E7C1CC98CC2","user_header":"https://static001.geekbang.org/account/avatar/00/14/34/df/64e3d533.jpg","comment_is_top":false,"comment_ctime":1566608008,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"\t今天老师重新梳理之后知道大致需要哪些知识了，借着之前老师的教诲做个总结：\n\t基础知识\n\t1.网络方面：消息队列所用的知识确实只是使用在应用层关于全双工这块知识，其它层次暂不涉及\n\t2.程序：我们只需要掌握常规的编程手法就行；至于我们去用何种语言实现不重要的，重要的是基于问题通过代码高效的解决就行\n\t3.操作系统：我们需要明白系统进程之间的调用，从而才能合理的去实现异步和并发\n\t课程的学习\n\t1.老师其实是最初在传授消息队列的由来、框架、不同消息队列的使用场景\n\t2.教授整个消息队列的生产者和消费者之间的关系和特性：让我们理解消息队列\n\t3.通过上述基础：后面的课程就是不断的通过真实现状理论+实际案例去操作动手；渔授予了，就要开始让我们捕鱼了，\n\t通过我们捕鱼的问题去修正我们的错误，提升我们捕鱼的能力。这是我学习到现在对于课程学习的感受。\n\t代码能力偏弱：不过后面会尽力去做；毕竟课程涉及的东西和知识，为了学习好课程一直在跟刘老师课并用刘老师的学习方式在补充学习中所不足；\n\t知识的课程是跟上了，代码的实践落下了；尽力去做尽力跟上老师的步伐吧，希望老师课程结课时能达到自己最初的学习目标。","like_count":1},{"had_liked":false,"id":393649,"user_name":"lion_fly","can_delete":false,"product_type":"c1","uid":1060242,"ip_address":"广东","ucode":"FCFD6B66C01B83","user_header":"https://static001.geekbang.org/account/avatar/00/10/2d/92/287f99db.jpg","comment_is_top":false,"comment_ctime":1724483195,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"所谓的双工，其实就是通信的两端都是server，而不是传统的C&#47;S的模式","like_count":0},{"had_liked":false,"id":370820,"user_name":"全麦小面包","can_delete":false,"product_type":"c1","uid":1086413,"ip_address":"上海","ucode":"823C65BF366097","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/cd/dbafc7d1.jpg","comment_is_top":false,"comment_ctime":1679303978,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"老师，我还有一个问题想请教，就是如何实现&quot;生产者和消费者之间的无锁沟通&quot;。如果文中的&quot;请求队列&quot;用BlockingQueue实现，那么它的&quot;添加\\获取&quot;操作，都是带锁的，无论需不需要获取锁相关的信号量，进行阻塞等待。例如offer方法直接返回true或false，但也是要先获取锁的。这是因为可能存在多个线程竞争&quot;写\\读&quot;，造成队列内部状态异常。然后我看了评论，老师说基于WAL，可以实现生产者和消费者之间的无锁沟通，能详细说说吗？","like_count":0},{"had_liked":false,"id":370816,"user_name":"全麦小面包","can_delete":false,"product_type":"c1","uid":1086413,"ip_address":"上海","ucode":"823C65BF366097","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/cd/dbafc7d1.jpg","comment_is_top":false,"comment_ctime":1679303239,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"老师，我想问下&quot;WriteThread&quot;单线程的意义。文中说，由于要保证消息的有序性，所以，使用单线程的WriteThread 从请求队列中按照顺序来获取请求。但将请求放入&quot;请求队列&quot;的线程不止一个吧(Netty 的 IO 线程)？所以即使WriteThread单线程，也不能保证全局的顺序，这样的话，单WriteThread线程，有特别的意义吗？","like_count":0},{"had_liked":false,"id":128691,"user_name":"付永强","can_delete":false,"product_type":"c1","uid":1419544,"ip_address":"","ucode":"898998296EBD56","user_header":"https://static001.geekbang.org/account/avatar/00/15/a9/18/393a841d.jpg","comment_is_top":false,"comment_ctime":1566952077,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"这么看来JMQ基本上是把所有涉及io等待地方步骤进行异步设计。学到了！感谢分享！🤔","like_count":18},{"had_liked":false,"id":143344,"user_name":"谢清","can_delete":false,"product_type":"c1","uid":1069849,"ip_address":"","ucode":"31B2862A790CEB","user_header":"https://static001.geekbang.org/account/avatar/00/10/53/19/dec74631.jpg","comment_is_top":false,"comment_ctime":1571671174,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"刷了下评论，青舟写的最好，其次Martin\n青舟\nhttps:&#47;&#47;github.com&#47;qingzhou413&#47;geektime-mq-rpc.git\nMartin\nhttps:&#47;&#47;github.com&#47;MartinDai&#47;mq-in-action&#47;blob&#47;master&#47;src&#47;main&#47;java&#47;com&#47;doodl6&#47;mq&#47;MeetInRpc.java","like_count":12},{"had_liked":false,"id":127240,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1566618427,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"老师说得很好，想成为一个真成的高手，理解并实践这些基本原理，是必不可少的，不要只停留在知识的表面，要领会技术背后的思想，才能活学活用，实践肯定是少不了的，加油。","like_count":5},{"had_liked":false,"id":181068,"user_name":"凡","can_delete":false,"product_type":"c1","uid":1721168,"ip_address":"","ucode":"80C2A6452AB9EA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/43/50/abb4ca1e.jpg","comment_is_top":false,"comment_ctime":1582469319,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"借鉴了 MySql 的思想，跟新数据先写入 Buffer pool，然后定期将内存的数据刷到磁盘，这样减少了磁盘 IO 的操作频率，提高了性能","like_count":2},{"had_liked":false,"id":271466,"user_name":"自拍不开美颜","can_delete":false,"product_type":"c1","uid":1925935,"ip_address":"","ucode":"711CF52CF68434","user_header":"https://static001.geekbang.org/account/avatar/00/1d/63/2f/f7e5b8c4.jpg","comment_is_top":false,"comment_ctime":1609654813,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"一问一答，是半双工而不是单工。","like_count":1},{"had_liked":false,"id":128298,"user_name":"大魔王汪汪","can_delete":false,"product_type":"c1","uid":1010680,"ip_address":"","ucode":"4B205CB52FC95F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/f8/b4da7936.jpg","comment_is_top":false,"comment_ctime":1566869491,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"整个设计方案简单的看是几个消费生产模型的组合😍","like_count":1},{"had_liked":false,"id":127198,"user_name":"leslie","can_delete":false,"product_type":"c1","uid":1324255,"ip_address":"","ucode":"798E7C1CC98CC2","user_header":"https://static001.geekbang.org/account/avatar/00/14/34/df/64e3d533.jpg","comment_is_top":false,"comment_ctime":1566608008,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"\t今天老师重新梳理之后知道大致需要哪些知识了，借着之前老师的教诲做个总结：\n\t基础知识\n\t1.网络方面：消息队列所用的知识确实只是使用在应用层关于全双工这块知识，其它层次暂不涉及\n\t2.程序：我们只需要掌握常规的编程手法就行；至于我们去用何种语言实现不重要的，重要的是基于问题通过代码高效的解决就行\n\t3.操作系统：我们需要明白系统进程之间的调用，从而才能合理的去实现异步和并发\n\t课程的学习\n\t1.老师其实是最初在传授消息队列的由来、框架、不同消息队列的使用场景\n\t2.教授整个消息队列的生产者和消费者之间的关系和特性：让我们理解消息队列\n\t3.通过上述基础：后面的课程就是不断的通过真实现状理论+实际案例去操作动手；渔授予了，就要开始让我们捕鱼了，\n\t通过我们捕鱼的问题去修正我们的错误，提升我们捕鱼的能力。这是我学习到现在对于课程学习的感受。\n\t代码能力偏弱：不过后面会尽力去做；毕竟课程涉及的东西和知识，为了学习好课程一直在跟刘老师课并用刘老师的学习方式在补充学习中所不足；\n\t知识的课程是跟上了，代码的实践落下了；尽力去做尽力跟上老师的步伐吧，希望老师课程结课时能达到自己最初的学习目标。","like_count":1},{"had_liked":false,"id":393649,"user_name":"lion_fly","can_delete":false,"product_type":"c1","uid":1060242,"ip_address":"广东","ucode":"FCFD6B66C01B83","user_header":"https://static001.geekbang.org/account/avatar/00/10/2d/92/287f99db.jpg","comment_is_top":false,"comment_ctime":1724483195,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"所谓的双工，其实就是通信的两端都是server，而不是传统的C&#47;S的模式","like_count":0},{"had_liked":false,"id":370820,"user_name":"全麦小面包","can_delete":false,"product_type":"c1","uid":1086413,"ip_address":"上海","ucode":"823C65BF366097","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/cd/dbafc7d1.jpg","comment_is_top":false,"comment_ctime":1679303978,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"老师，我还有一个问题想请教，就是如何实现&quot;生产者和消费者之间的无锁沟通&quot;。如果文中的&quot;请求队列&quot;用BlockingQueue实现，那么它的&quot;添加\\获取&quot;操作，都是带锁的，无论需不需要获取锁相关的信号量，进行阻塞等待。例如offer方法直接返回true或false，但也是要先获取锁的。这是因为可能存在多个线程竞争&quot;写\\读&quot;，造成队列内部状态异常。然后我看了评论，老师说基于WAL，可以实现生产者和消费者之间的无锁沟通，能详细说说吗？","like_count":0},{"had_liked":false,"id":370816,"user_name":"全麦小面包","can_delete":false,"product_type":"c1","uid":1086413,"ip_address":"上海","ucode":"823C65BF366097","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/cd/dbafc7d1.jpg","comment_is_top":false,"comment_ctime":1679303239,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"老师，我想问下&quot;WriteThread&quot;单线程的意义。文中说，由于要保证消息的有序性，所以，使用单线程的WriteThread 从请求队列中按照顺序来获取请求。但将请求放入&quot;请求队列&quot;的线程不止一个吧(Netty 的 IO 线程)？所以即使WriteThread单线程，也不能保证全局的顺序，这样的话，单WriteThread线程，有特别的意义吗？","like_count":0},{"had_liked":false,"id":348882,"user_name":"god","can_delete":false,"product_type":"c1","uid":1997758,"ip_address":"","ucode":"09CB6D17451CBC","user_header":"https://static001.geekbang.org/account/avatar/00/1e/7b/be/12735117.jpg","comment_is_top":false,"comment_ctime":1655508386,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"有没有Java需要实现的例子，谢谢","like_count":0},{"had_liked":false,"id":326942,"user_name":"李文博","can_delete":false,"product_type":"c1","uid":2845349,"ip_address":"","ucode":"C238A840DA60DE","user_header":"","comment_is_top":false,"comment_ctime":1639789439,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"刷盘和复制怎么保证数据一致性的，复制成功了，刷盘失败了。这时候刚好宕机了，那数据怎么保证一致性的","like_count":0},{"had_liked":false,"id":326192,"user_name":"锐锐","can_delete":false,"product_type":"c1","uid":2562434,"ip_address":"","ucode":"FCBA8CF5AB2325","user_header":"https://static001.geekbang.org/account/avatar/00/27/19/82/5acaca40.jpg","comment_is_top":false,"comment_ctime":1639408601,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"老师，有没有参考redis? 上一个课程学的redis感觉和jmq的差不多(｡･ω･｡)ﾉ♡","like_count":0},{"had_liked":false,"id":322956,"user_name":"凯文小猪","can_delete":false,"product_type":"c1","uid":1980201,"ip_address":"","ucode":"36D8AD0229547F","user_header":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","comment_is_top":false,"comment_ctime":1637669417,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"这里有个问题 一直没搞懂就是IOThread使用每请求每线程的方式 是如何保证队列内消息有序的？\n比方说同一个客户端发送两条消息&lt;queue1, msg1&gt;, &lt;queue1, msg2&gt; 对broker来说会使用两个线程来接收请求扔到request cache 这里没看出如何保证单队列下如何做到因果一致。\n\n以kafka来说，我们会将严格有序的消息扔到同一个分区里。想问一下JMQ是如何保证的","like_count":0},{"had_liked":false,"id":307490,"user_name":"SinKitwah","can_delete":false,"product_type":"c1","uid":1478242,"ip_address":"","ucode":"BC39A39E17C95E","user_header":"https://static001.geekbang.org/account/avatar/00/16/8e/62/435148c1.jpg","comment_is_top":false,"comment_ctime":1629120720,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"这似乎会存在从节点处理完并响应给主节点，但是这个主节点突然挂掉的情况。然后导致客户端重发…这不是重复发送了吗","like_count":0},{"had_liked":false,"id":296185,"user_name":"Geek_fjfjjf04","can_delete":false,"product_type":"c1","uid":1972839,"ip_address":"","ucode":"848DE73097F4D7","user_header":"","comment_is_top":false,"comment_ctime":1622797199,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"张大爷在胡同口等着 ...\n碰见一个李大爷:127.0.0.1:57913\n耗时:  9.482526528s\n使用上面的代码，我在mac上运行出来怎么9秒多","like_count":0},{"had_liked":false,"id":281601,"user_name":"Geek_1d0a96","can_delete":false,"product_type":"c1","uid":2293684,"ip_address":"","ucode":"C2B4D608DB6B12","user_header":"","comment_is_top":false,"comment_ctime":1614822756,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"jmq看起来像redis6.0","like_count":0},{"had_liked":false,"id":279096,"user_name":"Simple life","can_delete":false,"product_type":"c1","uid":1571460,"ip_address":"","ucode":"1902D7F72FB43F","user_header":"https://static001.geekbang.org/account/avatar/00/17/fa/84/f01d203a.jpg","comment_is_top":false,"comment_ctime":1613619676,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"生产者也可能因为网络原因导致没有收到成功响应导致重发消息，MQ可能要增加对消息ID的维护，判断是否存在","like_count":0},{"had_liked":false,"id":277970,"user_name":"Edward","can_delete":false,"product_type":"c1","uid":2249379,"ip_address":"","ucode":"D7485A8A89761C","user_header":"https://static001.geekbang.org/account/avatar/00/22/52/a3/28f6ade2.jpg","comment_is_top":false,"comment_ctime":1612686569,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"学以致用，受教","like_count":0},{"had_liked":false,"id":277898,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1612664529,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"刚看见还有对应的编程题,用Netty简单实现了一下,性能上可能还是有些差距\nhttps:&#47;&#47;github.com&#47;HeavenXin&#47;geektime_message_queue&#47;tree&#47;master&#47;src13&#47;talk","like_count":0},{"had_liked":false,"id":348882,"user_name":"god","can_delete":false,"product_type":"c1","uid":1997758,"ip_address":"","ucode":"09CB6D17451CBC","user_header":"https://static001.geekbang.org/account/avatar/00/1e/7b/be/12735117.jpg","comment_is_top":false,"comment_ctime":1655508386,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"有没有Java需要实现的例子，谢谢","like_count":0},{"had_liked":false,"id":326942,"user_name":"李文博","can_delete":false,"product_type":"c1","uid":2845349,"ip_address":"","ucode":"C238A840DA60DE","user_header":"","comment_is_top":false,"comment_ctime":1639789439,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"刷盘和复制怎么保证数据一致性的，复制成功了，刷盘失败了。这时候刚好宕机了，那数据怎么保证一致性的","like_count":0},{"had_liked":false,"id":326192,"user_name":"锐锐","can_delete":false,"product_type":"c1","uid":2562434,"ip_address":"","ucode":"FCBA8CF5AB2325","user_header":"https://static001.geekbang.org/account/avatar/00/27/19/82/5acaca40.jpg","comment_is_top":false,"comment_ctime":1639408601,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"老师，有没有参考redis? 上一个课程学的redis感觉和jmq的差不多(｡･ω･｡)ﾉ♡","like_count":0},{"had_liked":false,"id":322956,"user_name":"凯文小猪","can_delete":false,"product_type":"c1","uid":1980201,"ip_address":"","ucode":"36D8AD0229547F","user_header":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","comment_is_top":false,"comment_ctime":1637669417,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"这里有个问题 一直没搞懂就是IOThread使用每请求每线程的方式 是如何保证队列内消息有序的？\n比方说同一个客户端发送两条消息&lt;queue1, msg1&gt;, &lt;queue1, msg2&gt; 对broker来说会使用两个线程来接收请求扔到request cache 这里没看出如何保证单队列下如何做到因果一致。\n\n以kafka来说，我们会将严格有序的消息扔到同一个分区里。想问一下JMQ是如何保证的","like_count":0},{"had_liked":false,"id":307490,"user_name":"SinKitwah","can_delete":false,"product_type":"c1","uid":1478242,"ip_address":"","ucode":"BC39A39E17C95E","user_header":"https://static001.geekbang.org/account/avatar/00/16/8e/62/435148c1.jpg","comment_is_top":false,"comment_ctime":1629120720,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"这似乎会存在从节点处理完并响应给主节点，但是这个主节点突然挂掉的情况。然后导致客户端重发…这不是重复发送了吗","like_count":0},{"had_liked":false,"id":296185,"user_name":"Geek_fjfjjf04","can_delete":false,"product_type":"c1","uid":1972839,"ip_address":"","ucode":"848DE73097F4D7","user_header":"","comment_is_top":false,"comment_ctime":1622797199,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"张大爷在胡同口等着 ...\n碰见一个李大爷:127.0.0.1:57913\n耗时:  9.482526528s\n使用上面的代码，我在mac上运行出来怎么9秒多","like_count":0},{"had_liked":false,"id":281601,"user_name":"Geek_1d0a96","can_delete":false,"product_type":"c1","uid":2293684,"ip_address":"","ucode":"C2B4D608DB6B12","user_header":"","comment_is_top":false,"comment_ctime":1614822756,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"jmq看起来像redis6.0","like_count":0},{"had_liked":false,"id":279096,"user_name":"Simple life","can_delete":false,"product_type":"c1","uid":1571460,"ip_address":"","ucode":"1902D7F72FB43F","user_header":"https://static001.geekbang.org/account/avatar/00/17/fa/84/f01d203a.jpg","comment_is_top":false,"comment_ctime":1613619676,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"生产者也可能因为网络原因导致没有收到成功响应导致重发消息，MQ可能要增加对消息ID的维护，判断是否存在","like_count":0},{"had_liked":false,"id":277970,"user_name":"Edward","can_delete":false,"product_type":"c1","uid":2249379,"ip_address":"","ucode":"D7485A8A89761C","user_header":"https://static001.geekbang.org/account/avatar/00/22/52/a3/28f6ade2.jpg","comment_is_top":false,"comment_ctime":1612686569,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"学以致用，受教","like_count":0},{"had_liked":false,"id":277898,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1612664529,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"刚看见还有对应的编程题,用Netty简单实现了一下,性能上可能还是有些差距\nhttps:&#47;&#47;github.com&#47;HeavenXin&#47;geektime_message_queue&#47;tree&#47;master&#47;src13&#47;talk","like_count":0},{"had_liked":false,"id":239095,"user_name":"颇忒妥","can_delete":false,"product_type":"c1","uid":1026448,"ip_address":"","ucode":"AA86AD1049BC2E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a9/90/0c5ed3d9.jpg","comment_is_top":false,"comment_ctime":1596434369,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"耗时:  40.354851ms\n\nhttps:&#47;&#47;gist.github.com&#47;chanjarster&#47;a3b6957ad1f4117038722372cafbecb9","like_count":0},{"had_liked":false,"id":198967,"user_name":"远鹏","can_delete":false,"product_type":"c1","uid":1110723,"ip_address":"","ucode":"37B06413D88BEC","user_header":"https://static001.geekbang.org/account/avatar/00/10/f2/c3/f18e4507.jpg","comment_is_top":false,"comment_ctime":1585474603,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"讲的很对，很多知识点表面上和mq没有关系，实际上是对知识掌握程度不够","like_count":0},{"had_liked":false,"id":197016,"user_name":"凌空飞起的剪刀腿","can_delete":false,"product_type":"c1","uid":1243680,"ip_address":"","ucode":"16FBBF4A3B54C6","user_header":"https://static001.geekbang.org/account/avatar/00/12/fa/20/0f06b080.jpg","comment_is_top":false,"comment_ctime":1585349677,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"李老师您好，JMQ中request queue不需要加锁啊？","like_count":0},{"had_liked":false,"id":143930,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1571808795,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"理解老师的讲课思路，就因为老师这么讲我才购买这个专栏，非常值！","like_count":0},{"had_liked":false,"id":137809,"user_name":"丁丁历险记","can_delete":false,"product_type":"c1","uid":1661704,"ip_address":"","ucode":"A43829E454C067","user_header":"https://static001.geekbang.org/account/avatar/00/19/5b/08/b0b0db05.jpg","comment_is_top":false,"comment_ctime":1569859805,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"无用之用，方为大用。","like_count":0},{"had_liked":false,"id":134690,"user_name":"Geek_3cb8e5","can_delete":false,"product_type":"c1","uid":1599296,"ip_address":"","ucode":"E520F0D7051FDE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ4Mg9HAJ5auickN5l1JxxxVS0CdQVJX0QkqEQAib7VzHx0pES4V4Xu3XvBK0Nkib8j5GwibjO3v0hPJA/132","comment_is_top":false,"comment_ctime":1568895836,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"老师，您的课程安排非常的好， 我们需要学习轮子是如何造的。","like_count":0},{"had_liked":false,"id":134112,"user_name":"renwotao","can_delete":false,"product_type":"c1","uid":1042503,"ip_address":"","ucode":"8054CA7EC0C8AB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e8/47/3e4a03ac.jpg","comment_is_top":false,"comment_ctime":1568762853,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"序号设计很有帮助，","like_count":0},{"had_liked":false,"id":129612,"user_name":"oscarwin","can_delete":false,"product_type":"c1","uid":1131956,"ip_address":"","ucode":"492430BA342593","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/b4/ec66d499.jpg","comment_is_top":false,"comment_ctime":1567172776,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"如果使用阻塞IO来显示，似乎会出现死锁的情况:\n张大爷say线程：write阻塞\n张大爷listen线程：回复时，阻塞在lock上\n李大爷say线程：write阻塞\n李大爷listen线程：回复时，阻塞在lock上\n如此，就发生了死锁。","like_count":0},{"had_liked":false,"id":128034,"user_name":"夜空中最亮的星","can_delete":false,"product_type":"c1","uid":1267566,"ip_address":"","ucode":"ADC3E7B6789955","user_header":"https://static001.geekbang.org/account/avatar/00/13/57/6e/b6795c44.jpg","comment_is_top":false,"comment_ctime":1566823171,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"今天必须写一下","like_count":0},{"had_liked":false,"id":127216,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1566612687,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"太精彩了，JMQ的设计，我觉得完全就是将现实中的流水线作业再加上操作系统的特性","like_count":0},{"had_liked":false,"id":239095,"user_name":"颇忒妥","can_delete":false,"product_type":"c1","uid":1026448,"ip_address":"","ucode":"AA86AD1049BC2E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a9/90/0c5ed3d9.jpg","comment_is_top":false,"comment_ctime":1596434369,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"耗时:  40.354851ms\n\nhttps:&#47;&#47;gist.github.com&#47;chanjarster&#47;a3b6957ad1f4117038722372cafbecb9","like_count":0},{"had_liked":false,"id":198967,"user_name":"远鹏","can_delete":false,"product_type":"c1","uid":1110723,"ip_address":"","ucode":"37B06413D88BEC","user_header":"https://static001.geekbang.org/account/avatar/00/10/f2/c3/f18e4507.jpg","comment_is_top":false,"comment_ctime":1585474603,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"讲的很对，很多知识点表面上和mq没有关系，实际上是对知识掌握程度不够","like_count":0},{"had_liked":false,"id":197016,"user_name":"凌空飞起的剪刀腿","can_delete":false,"product_type":"c1","uid":1243680,"ip_address":"","ucode":"16FBBF4A3B54C6","user_header":"https://static001.geekbang.org/account/avatar/00/12/fa/20/0f06b080.jpg","comment_is_top":false,"comment_ctime":1585349677,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"李老师您好，JMQ中request queue不需要加锁啊？","like_count":0},{"had_liked":false,"id":143930,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1571808795,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"理解老师的讲课思路，就因为老师这么讲我才购买这个专栏，非常值！","like_count":0},{"had_liked":false,"id":137809,"user_name":"丁丁历险记","can_delete":false,"product_type":"c1","uid":1661704,"ip_address":"","ucode":"A43829E454C067","user_header":"https://static001.geekbang.org/account/avatar/00/19/5b/08/b0b0db05.jpg","comment_is_top":false,"comment_ctime":1569859805,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"无用之用，方为大用。","like_count":0},{"had_liked":false,"id":134690,"user_name":"Geek_3cb8e5","can_delete":false,"product_type":"c1","uid":1599296,"ip_address":"","ucode":"E520F0D7051FDE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ4Mg9HAJ5auickN5l1JxxxVS0CdQVJX0QkqEQAib7VzHx0pES4V4Xu3XvBK0Nkib8j5GwibjO3v0hPJA/132","comment_is_top":false,"comment_ctime":1568895836,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"老师，您的课程安排非常的好， 我们需要学习轮子是如何造的。","like_count":0},{"had_liked":false,"id":134112,"user_name":"renwotao","can_delete":false,"product_type":"c1","uid":1042503,"ip_address":"","ucode":"8054CA7EC0C8AB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e8/47/3e4a03ac.jpg","comment_is_top":false,"comment_ctime":1568762853,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"序号设计很有帮助，","like_count":0},{"had_liked":false,"id":129612,"user_name":"oscarwin","can_delete":false,"product_type":"c1","uid":1131956,"ip_address":"","ucode":"492430BA342593","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/b4/ec66d499.jpg","comment_is_top":false,"comment_ctime":1567172776,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"如果使用阻塞IO来显示，似乎会出现死锁的情况:\n张大爷say线程：write阻塞\n张大爷listen线程：回复时，阻塞在lock上\n李大爷say线程：write阻塞\n李大爷listen线程：回复时，阻塞在lock上\n如此，就发生了死锁。","like_count":0},{"had_liked":false,"id":128034,"user_name":"夜空中最亮的星","can_delete":false,"product_type":"c1","uid":1267566,"ip_address":"","ucode":"ADC3E7B6789955","user_header":"https://static001.geekbang.org/account/avatar/00/13/57/6e/b6795c44.jpg","comment_is_top":false,"comment_ctime":1566823171,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"今天必须写一下","like_count":0},{"had_liked":false,"id":127216,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1566612687,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"太精彩了，JMQ的设计，我觉得完全就是将现实中的流水线作业再加上操作系统的特性","like_count":0},{"had_liked":false,"id":127213,"user_name":"solar","can_delete":false,"product_type":"c1","uid":1070335,"ip_address":"","ucode":"E6C7090478B027","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/ff/09a058f3.jpg","comment_is_top":false,"comment_ctime":1566612091,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"还可以优化io buffer读写，如映射conn的buffer，减少内核态与用户态的内存拷贝.","like_count":0},{"had_liked":false,"id":127205,"user_name":"看不到de颜色","can_delete":false,"product_type":"c1","uid":1162714,"ip_address":"","ucode":"88348CCAE81931","user_header":"https://static001.geekbang.org/account/avatar/00/11/bd/da/3d76ea74.jpg","comment_is_top":false,"comment_ctime":1566611250,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"沙发~~看了本章内容深感惭愧。平日里更多的也只是对原理的了解，确实缺乏动手实践。这就去码张大爷和李大爷的爱恨情长。","like_count":0},{"had_liked":false,"id":127213,"user_name":"solar","can_delete":false,"product_type":"c1","uid":1070335,"ip_address":"","ucode":"E6C7090478B027","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/ff/09a058f3.jpg","comment_is_top":false,"comment_ctime":1566612091,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"还可以优化io buffer读写，如映射conn的buffer，减少内核态与用户态的内存拷贝.","like_count":0},{"had_liked":false,"id":127205,"user_name":"看不到de颜色","can_delete":false,"product_type":"c1","uid":1162714,"ip_address":"","ucode":"88348CCAE81931","user_header":"https://static001.geekbang.org/account/avatar/00/11/bd/da/3d76ea74.jpg","comment_is_top":false,"comment_ctime":1566611250,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"沙发~~看了本章内容深感惭愧。平日里更多的也只是对原理的了解，确实缺乏动手实践。这就去码张大爷和李大爷的爱恨情长。","like_count":0}]}