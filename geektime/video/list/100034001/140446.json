{"id":140446,"title":"44 | 实现自己的集合算法","content":"<p><strong>课件地址</strong></p><p><a href=\"https://gitee.com/geektime-geekbang/swift-course\">https://gitee.com/geektime-geekbang/swift-course</a></p>","comments":[{"had_liked":false,"id":162302,"user_name":"小千","can_delete":false,"product_type":"c3","uid":1286065,"ip_address":"","ucode":"8A1274AD7B87F0","user_header":"https://static001.geekbang.org/account/avatar/00/13/9f/b1/ae61b184.jpg","comment_is_top":false,"comment_ctime":1576496730,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100034001,"comment_content":"交作业\nfunc getSubsetsOfSet2&lt;T&gt;(set: Set&lt;T&gt;) -&gt; Array&lt;Set&lt;T&gt;&gt; {\n    let elements = Array(set)\n    return getSubsetsOfSet4(elements: elements, index: elements.count-1)\n}\nfunc getSubsetsOfSet4&lt;T&gt;(elements: Array&lt;T&gt;, index: Int) -&gt; Array&lt;Set&lt;T&gt;&gt; {\n    var subSets = Array&lt;Set&lt;T&gt;&gt;() &#47;&#47; 子集的数组\n    &#47;&#47; 先添加空集\n    subSets.append(Set([]))\n    &#47;&#47; 以下获取每位元素加入的非空子集\n    for element in elements{\n        for subSet in subSets{\n            var subSetWithCurrent = subSet\n            subSetWithCurrent.insert(element)\n            subSets.append(subSetWithCurrent)\n        }\n      print(&quot;当前元素为:\\(element),【选】,子集为:\\(subSets)&quot;)\n    }\n    print(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;所有子集为:\\(subSets)&quot;)\n    return subSets\n}\n\nlet set0:Set&lt;Int&gt; = [1,2,3]\ngetSubsetsOfSet2(set: set0)","like_count":1},{"had_liked":false,"id":347657,"user_name":"Sugar","can_delete":false,"product_type":"c3","uid":2436149,"ip_address":"","ucode":"BEFD1950841EA0","user_header":"https://static001.geekbang.org/account/avatar/00/25/2c/35/b0b62c5f.jpg","comment_is_top":false,"comment_ctime":1654260975,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100034001,"comment_content":"另外一种递归的思路，也是考虑Set内每一个元素要不要，将遍历Set的过程交给递归\nfunc getSubSet&lt;T&gt;(st: Set&lt;T&gt;) -&gt; Array&lt;Set&lt;T&gt;&gt; {\n    var ans = Array&lt;Set&lt;T&gt;&gt; ()\n    let ary = Array&lt;T&gt;(st)\n    var tmp = Array&lt;T&gt;()\n    findSubSet(ary: ary, ans: &amp;ans, tmp: &amp;tmp, idx: 0)\n    return ans;\n}\n\nfunc findSubSet&lt;T&gt; (ary: Array&lt;T&gt;, ans: inout Array&lt;Set&lt;T&gt;&gt;, tmp: inout Array&lt;T&gt;, idx: Int) {\n    if idx == ary.count {\n        ans.append(Set&lt;T&gt;(tmp))\n        return\n    }\n    &#47;&#47; 不要\n    findSubSet(ary: ary, ans: &amp;ans, tmp: &amp;tmp, idx: idx + 1)\n    \n    &#47;&#47; 要\n    tmp.append(ary[idx])\n    findSubSet(ary: ary, ans: &amp;ans, tmp: &amp;tmp, idx: idx + 1)\n    tmp.popLast()\n}","like_count":0},{"had_liked":false,"id":288765,"user_name":"皮特尔","can_delete":false,"product_type":"c3","uid":1017161,"ip_address":"","ucode":"313862C91DD325","user_header":"https://static001.geekbang.org/account/avatar/00/0f/85/49/585c69c4.jpg","comment_is_top":false,"comment_ctime":1618661271,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100034001,"comment_content":"最后的递归算法有这种操作：在遍历集合的同时改变集合。我记得有些语言是不允许这样操作的。\nSwift语言是如何保证这种操作不出问题的？过程中有隐式的对象copy吗？","like_count":0},{"had_liked":false,"id":221070,"user_name":"骈","can_delete":false,"product_type":"c3","uid":1923927,"ip_address":"","ucode":"2F76FA30770A83","user_header":"https://static001.geekbang.org/account/avatar/00/1d/5b/57/4a16a27f.jpg","comment_is_top":false,"comment_ctime":1590396831,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100034001,"comment_content":"&#47;&#47;1 方法一 位运算 每一个子集相当于 一个 count 位的 二进制数， 第n位 上 0代表不添加第n个元素。1 代表添加第n个元素\n        &#47;&#47;一共有 2 的 n 次方个子集\n        \n        let set4 : Set&lt;Int&gt; = [123,23,42,4234,5,4,7,568,796,23,456,46,6345,35,353,45]\n        let count = 1 &lt;&lt; set4.count &#47;&#47;总共的个数\n        let elements = Array(set4)\n        var subSets = Array&lt;Set&lt;Int&gt;&gt;()\n        for i in 0..&lt;count\n        {\n            var subSet = Set&lt;Int&gt;()\n            for j in 0..&lt;elements.count\n            {\n                \n                &#47;&#47; 获取数字 i 的 第j 位上 是否为 1  如果是1 则添加元素\n                if ((i &gt;&gt; j) &amp; 1)  == 1\n                {\n                    subSet.insert(elements[j])\n                }\n            }\n            subSets.append(subSet)\n        }\n        \n        print(subSets)","like_count":0},{"had_liked":false,"id":221069,"user_name":"骈","can_delete":false,"product_type":"c3","uid":1923927,"ip_address":"","ucode":"2F76FA30770A83","user_header":"https://static001.geekbang.org/account/avatar/00/1d/5b/57/4a16a27f.jpg","comment_is_top":false,"comment_ctime":1590396784,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100034001,"comment_content":"递归的 思路 文档上 应该是 2 的n次方 而不是 2n","like_count":0}]}