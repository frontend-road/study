{"id":740770,"title":"第 8 章 挂载与更新(1)","content":"<h1 id=\"nav_point_75\">第 8 章　挂载与更新</h1>\n<p>在第 7 章中，我们主要介绍了渲染器的基本概念和整体架构。本章，我们将讲解渲染器的核心功能：挂载与更新。</p>\n<h2 id=\"nav_point_76\">8.1　挂载子节点和元素的属性</h2>\n<p>第 7 章提到，当 <code>vnode.children</code> 的值是字符串类型时，会把它设置为元素的文本内容。一个元素除了具有文本子节点外，还可以包含其他元素子节点，并且子节点可以是很多个。为了描述元素的子节点，我们需要将 <code>vnode.children</code> 定义为数组：</p>\n<pre class=\"code-rows\"><code> const vnode = {\n   type: 'div',\n   children: [\n     {\n       type: 'p',\n       children: 'hello'\n     }\n   ]\n }\n</code></pre>\n<p>上面这段代码描述的是“一个 <code>div</code> 标签具有一个子节点，且子节点是 <code>p</code> 标签”。可以看到，<code>vnode.children</code> 是一个数组，它的每一个元素都是一个独立的虚拟节点对象。这样就形成了树型结构，即虚拟 DOM 树。</p>\n<p>为了完成子节点的渲染，我们需要修改 <code>mountElement</code> 函数，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function mountElement(vnode, container) {\n   const el = createElement(vnode.type)\n   if (typeof vnode.children === 'string') {\n     setElementText(el, vnode.children)\n   } else if (Array.isArray(vnode.children)) {\n     // 如果 children 是数组，则遍历每一个子节点，并调用 patch 函数挂载它们\n     vnode.children.forEach(child =&gt; {\n       patch(null, child, el)\n     })\n   }\n   insert(el, container)\n }\n</code></pre>\n<p>在上面这段代码中，我们增加了新的判断分支。使用 <code>Array.isArray</code> 函数判断 <code>vnode.children</code> 是否是数组，如果是数组，则循环遍历它，并调 <code>patch</code> 函数挂载数组中的虚拟节点。在挂载子节点时，需要注意以下两点。</p>\n<ul>\n<li>传递给 <code>patch</code> 函数的第一个参数是 <code>null</code>。因为是挂载阶段，没有旧 <code>vnode</code>，所以只需要传递 <code>null</code> 即可。这样，当 <code>patch</code> 函数执行时，就会递归地调用 <code>mountElement</code> 函数完成挂载。</li>\n<li>传递给 <code>patch</code> 函数的第三个参数是挂载点。由于我们正在挂载的子元素是 <code>div</code> 标签的子节点，所以需要把刚刚创建的 <code>div</code> 元素作为挂载点，这样才能保证这些子节点挂载到正确位置。</li>\n</ul>\n<p>完成了子节点的挂载后，我们再来看看如何用 <code>vnode</code> 描述一个标签的属性，以及如何渲染这些属性。我们知道，HTML 标签有很多属性，其中有些属性是通用的，例如 <code>id</code>、<code>class</code> 等，而有些属性是特定元素才有的，例如 <code>form</code> 元素的 <code>action</code> 属性。实际上，渲染一个元素的属性比想象中要复杂，不过我们仍然秉承一切从简的原则，先来看看最基本的属性处理。</p><!-- [[[read_end]]] -->\n<p>为了描述元素的属性，我们需要为虚拟 DOM 定义新的 <code>vnode.props</code> 字段，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> const vnode = {\n   type: 'div',\n   // 使用 props 描述一个元素的属性\n   props: {\n     id: 'foo'\n   },\n   children: [\n     {\n       type: 'p',\n       children: 'hello'\n     }\n   ]\n }\n</code></pre>\n<p><code>vnode.props</code> 是一个对象，它的键代表元素的属性名称，它的值代表对应属性的值。这样，我们就可以通过遍历 <code>props</code> 对象的方式，把这些属性渲染到对应的元素上，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function mountElement(vnode, container) {\n   const el = createElement(vnode.type)\n   // 省略 children 的处理\n<p>// 如果 vnode.props 存在才处理它<br />\nif (vnode.props) {<br />\n// 遍历 vnode.props<br />\nfor (const key in vnode.props) {<br />\n// 调用 setAttribute 将属性设置到元素上<br />\nel.setAttribute(key, vnode.props[key])<br />\n}<br />\n}</p>\n<p>insert(el, container)<br />\n}<br />\n</code></pre></p>\n<p>在这段代码中，我们首先检查了 <code>vnode.props</code> 字段是否存在，如果存在则遍历它，并调用 <code>setAttribute</code> 函数将属性设置到元素上。实际上，除了使用 <code>setAttribute</code> 函数为元素设置属性之外，还可以通过 DOM 对象直接设置：</p>\n<pre class=\"code-rows\"><code> function mountElement(vnode, container) {\n   const el = createElement(vnode.type)\n   // 省略 children 的处理\n<p>if (vnode.props) {<br />\nfor (const key in vnode.props) {<br />\n// 直接设置<br />\nel[key] = vnode.props[key]<br />\n}<br />\n}</p>\n<p>insert(el, container)<br />\n}<br />\n</code></pre></p>\n<p>在这段代码中，我们没有选择使用 <code>setAttribute</code> 函数，而是直接将属性设置在 DOM 对象上，即 <code>el[key] = vnode.props[key]</code>。实际上，无论是使用 <code>setAttribute</code> 函数，还是直接操作 DOM 对象，都存在缺陷。如前所述，为元素设置属性比想象中要复杂得多。不过，在讨论具体有哪些缺陷之前，我们有必要先搞清楚两个重要的概念：<strong><code>HTML Attributes</code></strong> 和 <strong><code>DOM Properties</code></strong>。</p>\n<h2 id=\"nav_point_77\">8.2　HTML Attributes 与 DOM Properties</h2>\n<p>理解 HTML Attributes 和 DOM Properties 之间的差异和关联非常重要，这能够帮助我们合理地设计虚拟节点的结构，更是正确地为元素设置属性的关键。</p>\n<p>我们从最基本的 HTML 说起。给出如下 HTML 代码：</p>\n<pre class=\"code-rows\"><code> &lt;input id=\"my-input\" type=\"text\" value=\"foo\" /&gt;\n</code></pre>\n<p>HTML Attributes 指的就是定义在 HTML 标签上的属性，这里指的就是 <code>id=\"my-input\"</code>、<code>type=\"text\"</code> 和 <code>value=\"foo\"</code>。当浏览器解析这段 HTML 代码后，会创建一个与之相符的 <code>DOM</code> 元素对象，我们可以通过 JavaScript 代码来读取该 DOM 对象：</p>\n<pre class=\"code-rows\"><code> const el = document.querySelector('#my-input')\n</code></pre>\n<p>这个 DOM 对象会包含很多<strong>属性</strong>（properties），如图 8-1 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00523.jpeg\" alt=\"\" width=\"55%\" style=\"width: 55%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 8-1　DOM 对象下的属性</strong></p>\n<p>这些属性就是所谓的 DOM Properties。很多 HTML Attributes 在 DOM 对象上有与之同名的 DOM Properties，例如 <code>id=\"my-input\"</code> 对应 <code>el.id</code>，<code>type=\"text\"</code> 对应 <code>el.type</code>，<code>value=\"foo\"</code> 对应 <code>el.value</code> 等。但 DOM Properties 与 HTML Attributes 的名字不总是一模一样的，例如：</p>\n<pre class=\"code-rows\"><code> &lt;div class=\"foo\"&gt;&lt;/div&gt;\n</code></pre>\n<p><code>class=\"foo\"</code> 对应的 DOM Properties 则是 <code>el.className</code>。另外，并不是所有 HTML Attributes 都有与之对应的 DOM Properties，例如：</p>\n<pre class=\"code-rows\"><code> &lt;div aria-valuenow=\"75\"&gt;&lt;/div&gt;\n</code></pre>\n<p><code>aria-*</code> 类的 HTML Attributes 就没有与之对应的 DOM Properties。</p>\n<p>类似地，也不是所有 DOM Properties 都有与之对应的 HTML Attributes，例如可以用 <code>el.textContent</code> 来设置元素的文本内容，但并没有与之对应的 HTML Attributes 来完成同样的工作。</p>\n<p>HTML Attributes 的值与 DOM Properties 的值之间是有关联的，例如下面的 HTML 片段：</p>\n<pre class=\"code-rows\"><code> &lt;div id=\"foo\"&gt;&lt;/div&gt;\n</code></pre>\n<p>这个片段描述了一个具有 <code>id</code> 属性的 <code>div</code> 标签。其中，<code>id=\"foo\"</code> 对应的 DOM Properties 是 <code>el.id</code>，并且值为字符串 <code>'foo'</code>。我们把这种 HTML Attributes 与 DOM Properties 具有相同名称（即 <code>id</code>）的属性看作直接映射。但并不是所有 HTML Attributes 与 DOM Properties 之间都是直接映射的关系，例如：</p>\n<pre class=\"code-rows\"><code> &lt;input value=\"foo\" /&gt;\n</code></pre>\n<p>这是一个具有 <code>value</code> 属性的 <code>input</code> 标签。如果用户没有修改文本框的内容，那么通过 <code>el.value</code> 读取对应的 DOM Properties 的值就是字符串 <code>'foo'</code>。而如果用户修改了文本框的值，那么 <code>el.value</code> 的值就是当前文本框的值。例如，用户将文本框的内容修改为 <code>'bar'</code>，那么：</p>\n<pre class=\"code-rows\"><code> console.log(el.value) // 'bar'\n</code></pre>\n<p>但如果运行下面的代码，会发生“奇怪”的现象：</p>\n<pre class=\"code-rows\"><code> console.log(el.getAttribute('value')) // 仍然是 'foo'\n console.log(el.value) // 'bar'\n</code></pre>\n<p>可以发现，用户对文本框内容的修改并不会影响 <code>el.getAttribute('value')</code> 的返回值，这个现象蕴含着 HTML Attributes 所代表的意义。实际上，HTML Attributes 的作用是设置与之对应的 DOM Properties 的初始值。一旦值改变，那么 DOM Properties 始终存储着当前值，而通过 <code>getAttribute</code> 函数得到的仍然是初始值。</p>\n<p>但我们仍然可以通过 <code>el.defaultValue</code> 来访问初始值，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> el.getAttribute('value') // 仍然是 'foo'\n el.value // 'bar'\n el.defaultValue // 'foo'\n</code></pre>\n<p>这说明一个 HTML Attributes 可能关联多个 DOM Properties。例如在上例中，<code>value=\"foo\"</code> 与 <code>el.value</code> 和 <code>el.defaultValue</code> 都有关联。</p>\n<p>虽然我们可以认为 HTML Attributes 是用来设置与之对应的 DOM Properties 的初始值的，但有些值是受限制的，就好像浏览器内部做了默认值校验。如果你通过 HTML Attributes 提供的默认值不合法，那么浏览器会使用内建的合法值作为对应 DOM Properties 的默认值，例如：</p>\n<pre class=\"code-rows\"><code> &lt;input type=\"foo\" /&gt;\n</code></pre>\n<p>我们知道，为 <code>&lt;input/&gt;</code> 标签的 <code>type</code> 属性指定字符串 <code>'foo'</code> 是不合法的，因此浏览器会矫正这个不合法的值。所以当我们尝试读取 <code>el.type</code> 时，得到的其实是矫正后的值，即字符串 <code>'text'</code>，而非字符串 <code>'foo'</code>：</p>\n<pre class=\"code-rows\"><code> console.log(el.type) // 'text'\n</code></pre>\n<p>从上述分析来看，HTML Attributes 与 DOM Properties 之间的关系很复杂，但其实我们只需要记住一个核心原则即可：<strong>HTML Attributes 的作用是设置与之对应的 DOM Properties 的初始值</strong>。</p>\n<h2 id=\"nav_point_78\">8.3　正确地设置元素属性</h2>\n<p>上一节我们详细讨论了 HTML Attributes 和 DOM Properties 相关的内容，因为 HTML Attributes 和 DOM Properties 会影响 DOM 属性的添加方式。对于普通的 HTML 文件来说，当浏览器解析 HTML 代码后，会自动分析 HTML Attributes 并设置合适的 DOM Properties。但用户编写在 Vue.js 的单文件组件中的模板不会被浏览器解析，这意味着，原本需要浏览器来完成的工作，现在需要框架来完成。</p>\n<p>我们以禁用的按钮为例，如下面的 HTML 代码所示：</p>\n<pre class=\"code-rows\"><code> &lt;button disabled&gt;Button&lt;/button&gt;\n</code></pre>\n<p>浏览器在解析这段 HTML 代码时，发现这个按钮存在一个叫作 <code>disabled</code> 的 HTML Attributes，于是浏览器会将该按钮设置为禁用状态，并将它的 <code>el.disabled</code> 这个 DOM Properties 的值设置为 <code>true</code>，这一切都是浏览器帮我们处理好的。但同样的代码如果出现在 Vue.js 的模板中，则情况会有所不同。首先，这个 HTML 模板会被编译成 <code>vnode</code>，它等价于：</p>\n<pre class=\"code-rows\"><code> const button = {\n   type: 'button',\n   props: {\n     disabled: ''\n   }\n }\n</code></pre>\n<p>注意，这里的 <code>props.disabled</code> 的值是空字符串，如果在渲染器中调用 <code>setAttribute</code> 函数设置属性，则相当于：</p>\n<pre class=\"code-rows\"><code> el.setAttribute('disabled', '')\n</code></pre>\n<p>这么做的确没问题，浏览器会将按钮禁用。但考虑如下模板：</p>\n<pre class=\"code-rows\"><code> &lt;button :disabled=\"false\"&gt;Button&lt;/button&gt;\n</code></pre>\n<p>它对应的 <code>vnode</code> 为：</p>\n<pre class=\"code-rows\"><code> const button = {\n   type: 'button',\n   props: {\n     disabled: false\n   }\n }\n</code></pre>\n<p>用户的本意是“不禁用”按钮，但如果渲染器仍然使用 <code>setAttribute</code> 函数设置属性值，则会产生意外的效果，即按钮被禁用了：</p>\n<pre class=\"code-rows\"><code> el.setAttribute('disabled', false)\n</code></pre>\n<p>在浏览器中运行上面这句代码，我们发现浏览器仍然将按钮禁用了。这是因为使用 <code>setAttribute</code> 函数设置的值总是会被字符串化，所以上面这句代码等价于：</p>\n<pre class=\"code-rows\"><code> el.setAttribute('disabled', 'false')\n</code></pre>\n<p>对于按钮来说，它的 <code>el.disabled</code> 属性值是布尔类型的，并且它不关心具体的 HTML Attributes 的值是什么，只要 <code>disabled</code> 属性存在，按钮就会被禁用。所以我们发现，渲染器不应该总是使用 <code>setAttribute</code> 函数将 <code>vnode.props</code> 对象中的属性设置到元素上。那么应该怎么办呢？一个很自然的思路是，我们可以优先设置 DOM Properties，例如：</p>\n<pre class=\"code-rows\"><code> el.disabled = false\n</code></pre>\n<p>这样是可以正确工作的，但又带来了新的问题。还是以上面给出的模板为例：</p>\n<pre class=\"code-rows\"><code> &lt;button disabled&gt;Button&lt;/button&gt;\n</code></pre>\n<p>这段模板对应的 <code>vnode</code> 是：</p>\n<pre class=\"code-rows\"><code> const button = {\n   type: 'button',\n   props: {\n     disabled: ''\n   }\n }\n</code></pre>\n<p>我们注意到，在模板经过编译后得到的 <code>vnode</code> 对象中，<code>props.disabled</code> 的值是一个空字符串。如果直接用它设置元素的 DOM Properties，那么相当于：</p>\n<pre class=\"code-rows\"><code> el.disabled = ''\n</code></pre>\n<p>由于 <code>el.disabled</code> 是布尔类型的值，所以当我们尝试将它设置为空字符串时，浏览器会将它的值矫正为布尔类型的值，即 <code>false</code>。所以上面这句代码的执行结果等价于：</p>\n<pre class=\"code-rows\"><code> el.disabled = false\n</code></pre>\n<p>这违背了用户的本意，因为用户希望禁用按钮，而 <code>el.disabled = false</code> 则是不禁用的意思。</p>\n<p>这么看来，无论是使用 <code>setAttribute</code> 函数，还是直接设置元素的 DOM Properties，都存在缺陷。要彻底解决这个问题，我们只能做特殊处理，即优先设置元素的 DOM Properties，但当值为空字符串时，要手动将值矫正为 <code>true</code>。只有这样，才能保证代码的行为符合预期。下面的 <code>mountElement</code> 函数给出了具体的实现：</p>\n<pre class=\"code-rows\"><code> function mountElement(vnode, container) {\n   const el = createElement(vnode.type)\n   // 省略 children 的处理\n<p>if (vnode.props) {<br />\nfor (const key in vnode.props) {<br />\n// 用 in 操作符判断 key 是否存在对应的 DOM Properties<br />\nif (key in el) {<br />\n// 获取该 DOM Properties 的类型<br />\nconst type = typeof el[key]<br />\nconst value = vnode.props[key]<br />\n// 如果是布尔类型，并且 value 是空字符串，则将值矫正为 true<br />\nif (type === ‘boolean’ &amp;&amp; value === ‘’) {<br />\nel[key] = true<br />\n} else {<br />\nel[key] = value<br />\n}<br />\n} else {<br />\n// 如果要设置的属性没有对应的 DOM Properties，则使用 setAttribute 函数设置属性<br />\nel.setAttribute(key, vnode.props[key])<br />\n}<br />\n}<br />\n}</p>\n<p>insert(el, container)<br />\n}<br />\n</code></pre></p>\n<p>如上面的代码所示，我们检查每一个 <code>vnode.props</code> 中的属性，看看是否存在对应的 DOM Properties，如果存在，则优先设置 DOM Properties。同时，我们对布尔类型的 DOM Properties 做了值的矫正，即当要设置的值为空字符串时，将其矫正为布尔值 <code>true</code>。当然，如果 <code>vnode.props</code> 中的属性不具有对应的 DOM Properties，则仍然使用 <code>setAttribute</code> 函数完成属性的设置。</p>\n<p>但上面给出的实现仍然存在问题，因为有一些 DOM Properties 是只读的，如以下代码所示：</p>\n<pre class=\"code-rows\"><code> &lt;form id=\"form1\"&gt;&lt;/form&gt;\n &lt;input form=\"form1\" /&gt;\n</code></pre>\n<p>在这段代码中，我们为 <code>&lt;input/&gt;</code> 标签设置了 <code>form</code> 属性（HTML Attributes）。它对应的 DOM Properties 是 <code>el.form</code>，但 <code>el.form</code> 是只读的，因此我们只能够通过 <code>setAttribute</code> 函数来设置它。这就需要我们修改现有的逻辑：</p>\n<pre class=\"code-rows\"><code> function shouldSetAsProps(el, key, value) {\n   // 特殊处理\n   if (key === 'form' &amp;&amp; el.tagName === 'INPUT') return false\n   // 兜底\n   return key in el\n }\n<p>function mountElement(vnode, container) {<br />\nconst el = createElement(vnode.type)<br />\n// 省略 children 的处理</p>\n<p>if (vnode.props) {<br />\nfor (const key in vnode.props) {<br />\nconst value = vnode.props[key]<br />\n// 使用 shouldSetAsProps 函数判断是否应该作为 DOM Properties 设置<br />\nif (shouldSetAsProps(el, key, value)) {<br />\nconst type = typeof el[key]<br />\nif (type === ‘boolean’ &amp;&amp; value === ‘’) {<br />\nel[key] = true<br />\n} else {<br />\nel[key] = value<br />\n}<br />\n} else {<br />\nel.setAttribute(key, value)<br />\n}<br />\n}<br />\n}</p>\n<p>insert(el, container)<br />\n}<br />\n</code></pre></p>\n<p>如上面的代码所示，为了代码的可读性，我们提取了一个 <code>shouldSetAsProps</code> 函数。该函数会返回一个布尔值，代表属性是否应该作为 DOM Properties 被设置。如果返回 <code>true</code>，则代表应该作为 DOM Properties 被设置，否则应该使用 <code>setAttribute</code> 函数来设置。在 <code>shouldSetAsProps</code> 函数内，我们对 <code>&lt;input form=\"xxx\" /&gt;</code> 进行特殊处理，即 <code>&lt;input/&gt;</code> 标签的 <code>form</code> 属性必须使用 <code>setAttribute</code> 函数来设置。实际上，不仅仅是 <code>&lt;input/&gt;</code> 标签，所有表单元素都具有 <code>form</code> 属性，它们都应该作为 HTML Attributes 被设置。</p>\n<p>当然，<code>&lt;input form=\"xxx\"/&gt;</code> 是一个特殊的例子，还有一些其他类似于这种需要特殊处理的情况。我们不会列举所有情况并一一讲解，因为掌握处理问题的思路更加重要。另外，我们也不可能把所有需要特殊处理的地方都记住，更何况有时我们根本不知道在什么情况下才需要特殊处理。所以，上述解决方案本质上是经验之谈。不要惧怕写出不完美的代码，只要在后续迭代过程中“见招拆招“，代码就会变得越来越完善，框架也会变得越来越健壮。</p>\n<p>最后，我们需要把属性的设置也变成与平台无关，因此需要把属性设置相关操作也提取到渲染器选项中，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> const renderer = createRenderer({\n   createElement(tag) {\n     return document.createElement(tag)\n   },\n   setElementText(el, text) {\n     el.textContent = text\n   },\n   insert(el, parent, anchor = null) {\n     parent.insertBefore(el, anchor)\n   },\n   // 将属性设置相关操作封装到 patchProps 函数中，并作为渲染器选项传递\n   patchProps(el, key, prevValue, nextValue) {\n     if (shouldSetAsProps(el, key, nextValue)) {\n       const type = typeof el[key]\n       if (type === 'boolean' &amp;&amp; nextValue === '') {\n         el[key] = true\n       } else {\n         el[key] = nextValue\n       }\n     } else {\n       el.setAttribute(key, nextValue)\n     }\n   }\n })\n</code></pre>\n<p>而在 <code>mountElement</code> 函数中，只需要调用 <code>patchProps</code> 函数，并为其传递相关参数即可：</p>\n<pre class=\"code-rows\"><code> function mountElement(vnode, container) {\n   const el = createElement(vnode.type)\n   if (typeof vnode.children === 'string') {\n     setElementText(el, vnode.children)\n   } else if (Array.isArray(vnode.children)) {\n     vnode.children.forEach(child =&gt; {\n       patch(null, child, el)\n     })\n   }\n<p>if (vnode.props) {<br />\nfor (const key in vnode.props) {<br />\n// 调用 patchProps 函数即可<br />\npatchProps(el, key, null, vnode.props[key])<br />\n}<br />\n}</p>\n<p>insert(el, container)<br />\n}<br />\n</code></pre></p>\n<p>这样，我们就把属性相关的渲染逻辑从渲染器的核心中抽离了出来。</p>\n<h2 id=\"nav_point_79\">8.4　<code>class</code> 的处理</h2>\n<p>在上一节中，我们讲解了如何正确地把 <code>vnode.props</code> 中定义的属性设置到 DOM 元素上。但在 Vue.js 中，仍然有一些属性需要特殊处理，比如 <code>class</code> 属性。为什么需要对 <code>class</code> 属性进行特殊处理呢？这是因为 Vue.js 对 <code>calss</code> 属性做了增强。在 Vue.js 中为元素设置类名有以下几种方式。</p>\n<p>方式一：指定 <code>class</code> 为一个字符串值。</p>\n<pre class=\"code-rows\"><code> &lt;p class=\"foo bar\"&gt;&lt;/p&gt;\n</code></pre>\n<p>这段模板对应的 <code>vnode</code> 是：</p>\n<pre class=\"code-rows\"><code> const vnode = {\n   type: 'p',\n   props: {\n     class: 'foo bar'\n   }\n }\n</code></pre>\n<p>方式二：指定 <code>class</code> 为一个对象值。</p>\n<pre class=\"code-rows\"><code> &lt;p :class=\"cls\"&gt;&lt;/p&gt;\n</code></pre>\n<p>假设对象 <code>cls</code> 的内容如下：</p>\n<pre class=\"code-rows\"><code> const cls = { foo: true, bar: false }\n</code></pre>\n<p>那么，这段模板对应的 <code>vnode</code> 是：</p>\n<pre class=\"code-rows\"><code> const vnode = {\n   type: 'p',\n   props: {\n     class: { foo: true, bar: false }\n   }\n }\n</code></pre>\n<p>方式三：<code>class</code> 是包含上述两种类型的数组。</p>\n<pre class=\"code-rows\"><code> &lt;p :class=\"arr\"&gt;&lt;/p&gt;\n</code></pre>\n<p>这个数组可以是字符串值与对象值的组合：</p>\n<pre class=\"code-rows\"><code> const arr = [\n   // 字符串\n   'foo bar',\n   // 对象\n   {\n     baz: true\n   }\n ]\n</code></pre>\n<p>那么，这段模板对应的 <code>vnode</code> 是：</p>\n<pre class=\"code-rows\"><code> const vnode = {\n   type: 'p',\n   props: {\n     class: [\n       'foo bar',\n       { baz: true }\n     ]\n   }\n }\n</code></pre>\n<p>可以看到，因为 <code>class</code> 的值可以是多种类型，所以我们必须在设置元素的 <code>class</code> 之前将值归一化为统一的字符串形式，再把该字符串作为元素的 <code>class</code> 值去设置。因此，我们需要封装 <code>normalizeClass</code> 函数，用它来将不同类型的 <code>class</code> 值正常化为字符串，例如：</p>\n<pre class=\"code-rows\"><code> const vnode = {\n   type: 'p',\n   props: {\n     // 使用 normalizeClass 函数对值进行序列化\n     class: normalizeClass([\n       'foo bar',\n       { baz: true }\n     ])\n   }\n }\n</code></pre>\n<p>最后的结果等价于：</p>\n<pre class=\"code-rows\"><code> const vnode = {\n   type: 'p',\n   props: {\n     // 序列化后的结果\n     class: 'foo bar baz'\n   }\n }\n</code></pre>\n<p>至于 <code>normalizeClass</code> 函数的实现，这里我们不会做详细讲解，因为它本质上就是一个数据结构转换的小算法，实现起来并不复杂。</p>\n<p>假设现在我们已经能够对 <code>class</code> 值进行正常化了。接下来，我们将讨论如何将正常化后的 <code>class</code> 值设置到元素上。其实，我们目前实现的渲染器已经能够完成 <code>class</code> 的渲染了。观察前文中函数的代码，由于 <code>class</code> 属性对应的 DOM Properties 是 <code>el.className</code>，所以表达式 <code>'class' in el</code> 的值将会是 <code>false</code>，因此，<code>patchProps</code> 函数会使用 <code>setAttribute</code> 函数来完成 <code>class</code> 的设置。但是我们知道，在浏览器中为一个元素设置 <code>class</code> 有三种方式，即使用 <code>setAttribute</code>、<code>el.className</code> 或 <code>el.classList</code>。那么哪一种方法的性能更好呢？图 8-2 对比了这三种方式为元素设置 1000 次 <code>class</code> 的性能。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00524.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 8-2　<code>el.className</code>、<code>setAttribute</code> 和 <code>el.classList</code> 的性能比较</strong></p>\n<p>可以看到，<code>el.className</code> 的性能最优。因此，我们需要调整 <code>patchProps</code> 函数的实现，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> const renderer = createRenderer({\n   // 省略其他选项\n<p>patchProps(el, key, prevValue, nextValue) {<br />\n// 对 class 进行特殊处理<br />\nif (key === ‘class’) {<br />\nel.className = nextValue || ‘’<br />\n} else if (shouldSetAsProps(el, key, nextValue)) {<br />\nconst type = typeof el[key]<br />\nif (type === ‘boolean’ &amp;&amp; nextValue === ‘’) {<br />\nel[key] = true<br />\n} else {<br />\nel[key] = nextValue<br />\n}<br />\n} else {<br />\nel.setAttribute(key, nextValue)<br />\n}<br />\n}<br />\n})<br />\n</code></pre></p>\n<p>从上面的代码中可以看到，我们对 <code>class</code> 进行了特殊处理，即使用 <code>el.className</code> 代替 <code>setAttribute</code> 函数。其实除了 <code>class</code> 属性之外，Vue.js 对 <code>style</code> 属性也做了增强，所以我们也需要对 <code>style</code> 做类似的处理。</p>\n<p>通过对 <code>class</code> 的处理，我们能够意识到，<code>vnode.props</code> 对象中定义的属性值的类型并不总是与 DOM 元素属性的数据结构保持一致，这取决于上层 API 的设计。Vue.js 允许对象类型的值作为 <code>class</code> 是为了方便开发者，在底层的实现上，必然需要对值进行正常化后再使用。另外，正常化值的过程是有代价的，如果需要进行大量的正常化操作，则会消耗更多性能。</p>\n<h2 id=\"nav_point_80\">8.5　卸载操作</h2>\n<p>前文主要讨论了挂载操作。接下来，我们将会讨论卸载操作。卸载操作发生在更新阶段，更新指的是，在初次挂载完成之后，后续渲染会触发更新，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> // 初次挂载\n renderer.render(vnode, document.querySelector('#app'))\n // 再次挂载新 vnode，将触发更新\n renderer.render(newVNode, document.querySelector('#app'))\n</code></pre>\n<p>更新的情况有几种，我们逐个来看。当后续调用 <code>render</code> 函数渲染空内容（即 <code>null</code>）时，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> // 初次挂载\n renderer.render(vnode, document.querySelector('#app'))\n // 新 vnode 为 null，意味着卸载之前渲染的内容\n renderer.render(null, document.querySelector('#app'))\n</code></pre>\n<p>首次挂载完成后，后续渲染时如果传递了 <code>null</code> 作为新 <code>vnode</code>，则意味着什么都不渲染，这时我们需要卸载之前渲染的内容。回顾前文实现的 <code>render</code> 函数，如下：</p>\n<pre class=\"code-rows\"><code> function render(vnode, container) {\n   if (vnode) {\n     patch(container._vnode, vnode, container)\n   } else {\n     if (container._vnode) {\n       // 卸载，清空容器\n       container.innerHTML = ''\n     }\n   }\n   container._vnode = vnode\n }\n</code></pre>\n<p>可以看到，当 <code>vnode</code> 为 <code>null</code>，并且容器元素的 <code>container._vnode</code> 属性存在时，我们直接通过 <code>innerHTML</code> 清空容器。但这么做是不严谨的，原因有三点。</p>\n<ul>\n<li>容器的内容可能是由某个或多个组件渲染的，当卸载操作发生时，应该正确地调用这些组件的 <code>beforeUnmount</code>、<code>unmounted</code> 等生命周期函数。</li>\n<li>即使内容不是由组件渲染的，有的元素存在自定义指令，我们应该在卸载操作发生时正确执行对应的指令钩子函数。</li>\n<li>使用 <code>innerHTML</code> 清空容器元素内容的另一个缺陷是，它不会移除绑定在 DOM 元素上的事件处理函数。</li>\n</ul>\n<p>正如上述三点原因，我们不能简单地使用 <code>innerHTML</code> 来完成卸载操作。正确的卸载方式是，根据 <code>vnode</code> 对象获取与其相关联的真实 DOM 元素，然后使用原生 DOM 操作方法将该 DOM 元素移除。为此，我们需要在 <code>vnode</code> 与真实 DOM 元素之间建立联系，修改 <code>mountElement</code> 函数，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function mountElement(vnode, container) {\n   // 让 vnode.el 引用真实 DOM 元素\n   const el = vnode.el = createElement(vnode.type)\n   if (typeof vnode.children === 'string') {\n     setElementText(el, vnode.children)\n   } else if (Array.isArray(vnode.children)) {\n     vnode.children.forEach(child =&gt; {\n       patch(null, child, el)\n     })\n   }\n<p>if (vnode.props) {<br />\nfor (const key in vnode.props) {<br />\npatchProps(el, key, null, vnode.props[key])<br />\n}<br />\n}</p>\n<p>insert(el, container)<br />\n}<br />\n</code></pre></p>\n<p>可以看到，当我们调用 <code>createElement</code> 函数创建真实 DOM 元素时，会把真实 DOM 元素赋值给 <code>vnode.el</code> 属性。这样，在 <code>vnode</code> 与真实 DOM 元素之间就建立了联系，我们可以通过 <code>vnode.el</code> 来获取该虚拟节点对应的真实 DOM 元素。有了这些，当卸载操作发生的时候，只需要根据虚拟节点对象 <code>vnode.el</code> 取得真实 DOM 元素，再将其从父元素中移除即可：</p>\n<pre class=\"code-rows\"><code> function render(vnode, container) {\n   if (vnode) {\n     patch(container._vnode, vnode, container)\n   } else {\n     if (container._vnode) {\n       // 根据 vnode 获取要卸载的真实 DOM 元素\n       const el = container._vnode.el\n       // 获取 el 的父元素\n       const parent = el.parentNode\n       // 调用 removeChild 移除元素\n       if (parent) parent.removeChild(el)\n     }\n   }\n   container._vnode = vnode\n }\n</code></pre>\n<p>如上面的代码所示，其中 <code>container._vnode</code> 代表旧 <code>vnode</code>，即要被卸载的 <code>vnode</code>。然后通过 <code>container._vnode.el</code> 取得真实 DOM 元素，并调用 <code>removeChild</code> 函数将其从父元素中移除即可。</p>\n<p>由于卸载操作是比较常见且基本的操作，所以我们应该将它封装到 <code>unmount</code> 函数中，以便后续代码可以复用它，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function unmount(vnode) {\n   const parent = vnode.el.parentNode\n   if (parent) {\n     parent.removeChild(vnode.el)\n   }\n }\n</code></pre>\n<p><code>unmount</code> 函数接收一个虚拟节点作为参数，并将该虚拟节点对应的真实 DOM 元素从父元素中移除。现在 <code>unmount</code> 函数的代码还非常简单，后续我们会慢慢充实它，让它变得更加完善。有了 <code>unmount</code> 函数后，就可以直接在 <code>render</code> 函数中调用它来完成卸载任务了：</p>\n<pre class=\"code-rows\"><code> function render(vnode, container) {\n   if (vnode) {\n     patch(container._vnode, vnode, container)\n   } else {\n     if (container._vnode) {\n       // 调用 unmount 函数卸载 vnode\n       unmount(container._vnode)\n     }\n   }\n   container._vnode = vnode\n }\n</code></pre>\n<p>最后，将卸载操作封装到 <code>unmount</code> 中，还能够带来两点额外的好处。</p>\n<ul>\n<li>在 <code>unmount</code> 函数内，我们有机会调用绑定在 DOM 元素上的指令钩子函数，例如 <code>beforeUnmount</code>、<code>unmounted</code> 等。</li>\n<li>当 <code>unmount</code> 函数执行时，我们有机会检测虚拟节点 <code>vnode</code> 的类型。如果该虚拟节点描述的是组件，则我们有机会调用组件相关的生命周期函数。</li>\n</ul>\n<h2 id=\"nav_point_81\">8.6　区分 <code>vnode</code> 的类型</h2>\n<p>在上一节中我们了解到，当后续调用 <code>render</code> 函数渲染空内容（即 <code>null</code>）时，会执行卸载操作。如果在后续渲染时，为 <code>render</code> 函数传递了新的 <code>vnode</code>，则不会进行卸载操作，而是会把新旧 <code>vnode</code> 都传递给 <code>patch</code> 函数进行打补丁操作。回顾前文实现的 <code>patch</code> 函数，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function patch(n1, n2, container) {\n   if (!n1) {\n     mountElement(n2, container)\n   } else {\n     // 更新\n   }\n }\n</code></pre>\n<p>其中，<code>patch</code> 函数的两个参数 <code>n1</code> 和 <code>n2</code> 分别代表旧 <code>vnode</code> 与新 <code>vnode</code>。如果旧 <code>vnode</code> 存在，则需要在新旧 <code>vnode</code> 之间打补丁。但在具体执行打补丁操作之前，我们需要保证新旧 <code>vnode</code> 所描述的内容相同。这是什么意思呢？举个例子，假设初次渲染的 <code>vnode</code> 是一个 <code>p</code> 元素：</p>\n<pre class=\"code-rows\"><code> const vnode = {\n   type: 'p'\n }\n renderer.render(vnode, document.querySelector('#app'))\n</code></pre>\n<p>后续又渲染了一个 <code>input</code> 元素：</p>\n<pre class=\"code-rows\"><code> const vnode = {\n   type: 'input'\n }\n renderer.render(vnode, document.querySelector('#app'))\n</code></pre>\n<p>这就会造成新旧 <code>vnode</code> 所描述的内容不同，即 <code>vnode.type</code> 属性的值不同。对于上例来说，<code>p</code> 元素和 <code>input</code> 元素之间不存在打补丁的意义，因为对于不同的元素来说，每个元素都有特有的属性，例如：</p>\n<pre class=\"code-rows\"><code> &lt;p id=\"foo\" /&gt;\n &lt;!-- type 属性是 input 标签特有的，p 标签则没有该属性 --&gt;\n &lt;input type=\"submit\" /&gt;\n</code></pre>\n<p>在这种情况下，正确的更新操作是，先将 <code>p</code> 元素卸载，再将 <code>input</code> 元素挂载到容器中。因此我们需要调整 <code>patch</code> 函数的代码：</p>\n<pre class=\"code-rows\"><code> function patch(n1, n2, container) {\n   // 如果 n1 存在，则对比 n1 和 n2 的类型\n   if (n1 &amp;&amp; n1.type !== n2.type) {\n     // 如果新旧 vnode 的类型不同，则直接将旧 vnode 卸载\n     unmount(n1)\n     n1 = null\n   }\n<p>if (!n1) {<br />\nmountElement(n2, container)<br />\n} else {<br />\n// 更新<br />\n}<br />\n}<br />\n</code></pre></p>\n<p>如上面的代码所示，在真正执行更新操作之前，我们优先检查新旧 <code>vnode</code> 所描述的内容是否相同，如果不同，则直接调用 <code>unmount</code> 函数将旧 <code>vnode</code> 卸载。这里需要注意的是，卸载完成后，我们应该将参数 <code>n1</code> 的值重置为 <code>null</code>，这样才能保证后续挂载操作正确执行。</p>\n<p>即使新旧 <code>vnode</code> 描述的内容相同，我们仍然需要进一步确认它们的类型是否相同。我们知道，一个 <code>vnode</code> 可以用来描述普通标签，也可以用来描述组件，还可以用来描述 <code>Fragment</code> 等。对于不同类型的 <code>vnode</code>，我们需要提供不同的挂载或打补丁的处理方式。所以，我们需要继续修改 <code>patch</code> 函数的代码以满足需求，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function patch(n1, n2, container) {\n   if (n1 &amp;&amp; n1.type !== n2.type) {\n     unmount(n1)\n     n1 = null\n   }\n   // 代码运行到这里，证明 n1 和 n2 所描述的内容相同\n   const { type } = n2\n   // 如果 n2.type 的值是字符串类型，则它描述的是普通标签元素\n   if (typeof type === 'string') {\n     if (!n1) {\n       mountElement(n2, container)\n     } else {\n       patchElement(n1, n2)\n     }\n   } else if (typeof type === 'object') {\n     // 如果 n2.type 的值的类型是对象，则它描述的是组件\n   } else if (type === 'xxx') {\n     // 处理其他类型的 vnode\n   }\n }\n</code></pre>\n<p>实际上，在前文的讲解中，我们一直假设 <code>vnode</code> 的类型是普通标签元素。但严谨的做法是根据 <code>vnode.type</code> 进一步确认它们的类型是什么，从而使用相应的处理函数进行处理。例如，如果 <code>vnode.type</code> 的值是字符串类型，则它描述的是普通标签元素，这时我们会调用 <code>mountElement</code> 或 <code>patchElement</code> 完成挂载和更新操作；如果 <code>vnode.type</code> 的值的类型是对象，则它描述的是组件，这时我们会调用与组件相关的挂载和更新方法。</p>\n","comments":[]}