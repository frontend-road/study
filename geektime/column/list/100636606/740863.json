{"id":740863,"title":"第 3 章 Spring Framework 中的 AOP","content":"\n<blockquote>\n<p><strong>本章内容</strong></p>\n<ul>\n<li>AOP 的概念</li>\n<li>Spring AOP 的实现原理</li>\n<li>基于注解的 AOP 配置方式</li>\n<li>基于 XML Schema 的 AOP 配置方式</li>\n</ul>\n</blockquote>\n<p>讲完了 IoC，我们再来聊聊 Spring Framework 中的另一个重要内容——面向切面编程，即 AOP。它是框架中众多功能的基础，例如声明式事务就是依靠 AOP 来实现的。此外，Spring 还为我们提供了简单的方式来使用 AOP，这有助于简化业务代码中一些共性功能的开发。本章我们会一起去了解 AOP 的基本概念，以及 AOP 在 Spring Framework 中的实现，并学习如何通过使用注解和 XML 文件的方式来配置 AOP 相关的功能。</p>\n<h2 id=\"nav_point_44\">3.1　Spring 中的 AOP</h2>\n<p>为了能更好地理解 AOP，本节会先带大家了解一下什么是 AOP，它能做什么，随后展开解释其中的一些核心概念，最后再剖析一下 Spring Framework 中 AOP 的实现原理。</p>\n<h3 id=\"nav_point_45\">3.1.1　AOP 的核心概念</h3>\n<p>AOP 是 Aspect Oriented Programming（面向切面编程）的首字母缩写，是一种编程范式，它的目的是通过分离横切关注点（cross-cutting concerns）来提升代码的模块化程度。AOP 的概念最早是由 Xerox PARC<span class=\"comment-number\">1</span> 提出的，我第一次接触到这个概念则是在 2004 年左右，当时我还在上大学，恰逢学院的一位博士生导师来给本科生上课，课程中他向我们介绍了 AOP，那时主要的 AOP 框架还是 AspectJ<span class=\"comment-number\">2</span>。</p><!-- [[[read_end]]] -->\n\n\n<p>AOP 中提到的<strong>关注点</strong>，其实就是一段<strong>特定的功能</strong>，有些关注点出现在多个模块中，就称为<strong>横切关注点</strong>。这么说可能有点抽象，举个例子，一个后台客服系统的每个模块都需要记录客服的操作日志，这就是一个能从业务逻辑中分离出来的横切关注点，完全不用交织在每个模块的代码中，可以作为一个单独的模块存在。</p>\n<p>整理一下，可以发现 AOP 解决了两个问题：第一是<strong>代码混乱</strong>，核心的业务逻辑代码还必须兼顾其他功能，这就导致不同功能的代码交织在一起，可读性很差；第二是<strong>代码分散</strong>，同一个功能的代码分散在多个模块中，不易维护。在引入 AOP 之后，一切就变得不一样了。</p>\n<p>虽然 AOP 同 OOP（Object-Oriented Programming，面向对象编程）一样，都是一种编程范式，但它并非站在 OOP 的对立面，而是对 OOP 的一个很好的补充。Spring Framework 就是一个例子，它很好地将两者融合在了一起。</p>\n<p>在 AOP 中有几个重要的概念，在开始实践前，我们先通过表 3-1 来了解一下这些概念。</p>\n<p><strong>表 3-1　AOP 中的几个重要概念</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>概念</p></th>\n<th><p>说明</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>切面（aspect）</p></td>\n<td><p>按关注点进行模块分解时，横切关注点就表示为一个切面</p></td>\n</tr>\n<tr>\n<td><p>连接点（join point）<span class=\"comment-number\">3</span></p></td>\n<td><p>程序执行的某一刻，在这个点上可以添加额外的动作</p></td>\n</tr>\n<tr>\n<td><p>通知（advice）</p></td>\n<td><p>切面在特定连接点上执行的动作</p></td>\n</tr>\n<tr>\n<td><p>切入点（pointcut）</p></td>\n<td><p>切入点是用来描述连接点的，它决定了当前代码与连接点是否匹配</p></td>\n</tr>\n</tbody>\n</table>\n\n<p>借助表 3-1，我们可以将这些概念串联起来：通过切入点来匹配程序中的特定连接点，在这些连接点上执行通知，这种通知可以是在连接点前后执行，也可以是将连接点包围起来。</p>\n<h3 id=\"nav_point_46\">3.1.2　Spring AOP 的实现原理</h3>\n<p>在 Spring Framework 中，虽然 Spring AOP 的使用方式发生过很大的变化，但其背后的核心技术却从未改变，那就是<strong>动态代理技术</strong>。代理模式是 GoF 提出的 23 种经典设计模式之一，我们可以为某个对象提供一个代理，控制对该对象的访问，代理可以在两个有调用关系的对象之间起到中介的作用——代理封装了目标对象，调用者调用了代理的方法，代理再去调用实际的目标对象，如图 3-1 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00758.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 3-1　代理模式示意图</strong></p>\n<p><strong>动态代理</strong>就是在运行时动态地为对象创建代理的技术。在 Spring 中，由 AOP 框架创建、用来实现切面的对象被称为 <strong>AOP 代理</strong>（AOP Proxy），一般采用 JDK 动态代理或者是 CGLIB<span class=\"comment-number\">4</span> 代理，两者在使用时的区别具体如表 3-2 所示。</p>\n\n<p><strong>表 3-2　JDK 动态代理与 CGLIB 代理的区别</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>&nbsp;</p></th>\n<th><p>必须要实现接口</p></th>\n<th><p>支持拦截 <code>public</code> 方法</p></th>\n<th><p>支持拦截 <code>protected</code> 方法</p></th>\n<th><p>拦截默认作用域方法 <span class=\"comment-number\">5</span></p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>JDK 动态代理</p></td>\n<td><p>是</p></td>\n<td><p>是</p></td>\n<td><p>否</p></td>\n<td><p>否</p></td>\n</tr>\n<tr>\n<td><p>CGLIB 代理</p></td>\n<td><p>否</p></td>\n<td><p>是</p></td>\n<td><p>是</p></td>\n<td><p>是</p></td>\n</tr>\n</tbody>\n</table>\n\n<p>虽然 CGLIB 支持拦截非 <code>public</code> 作用域的方法调用，但在不同对象之间交互时，建议还是以 <code>public</code> 方法调用为主。</p>\n<p>Spring 容器在为 Bean 注入依赖时，会自动将被依赖 Bean 的 AOP 代理注入进来，这就让我们感觉是在使用原始的 Bean，其实不然。</p>\n<p>被切面拦截的对象称为<strong>目标对象</strong>（target object）或<strong>通知对象</strong>（advised object），因为 Spring 用了动态代理，所以目标对象就是要被代理的对象。</p>\n<p>以 JDK 动态代理为例，假设我们希望在代码示例 3-1<span class=\"comment-number\">6</span> 的方法执行前后增加两句日志，可以采用下面这套代码，先实现调用 <code>Hello</code> 的主流程。</p>\n\n<blockquote>\n<p><strong>代码示例 3-1</strong>　要被动态代理的 Hello 接口及其实现片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>public interface Hello {\n    void say();\n}\n\npublic class SpringHello implements Hello {\n    @Override\n    public void say() {\n        System.out.println(\"Hello Spring!\");\n    }\n}</code></pre>\n<p>随后，我们可以像代码示例 3-2 那样设计一个 <code>InvocationHandler</code>，于是对代理对象的调用都会转为调用 <code>invoke</code> 方法，传入的参数中就包含了所调用的方法和实际的参数。</p>\n<blockquote>\n<p><strong>代码示例 3-2</strong>　在 <code>Hello.say()</code> 前后打印日志的 <code>InvocationHandler</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>public class LogHandler implements InvocationHandler {\n    private Hello source;\n\n    public LogHandler(Hello source) {\n        this.source = source;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(\"Ready to say something.\");\n        try {\n            return method.invoke(source, args);\n        } finally {\n            System.out.println(\"Already say something.\");\n        }\n    }\n}</code></pre>\n<p>最后，再通过 <code>Proxy.newProxyInstance()</code> 为 <code>Hello</code> 实现类的 Bean 实例创建使用 <code>LogHandler</code> 的代理，如代码示例 3-3 所示。</p>\n<blockquote>\n<p><strong>代码示例 3-3</strong>　创建 JDK 动态代理并调用方法</p>\n</blockquote>\n<pre class=\"code-rows\"><code>public class Application {\n    public static void main(String[] args) {\n        Hello original = new SpringHello();\n        Hello target = (Hello) Proxy.newProxyInstance(Hello.class.getClassLoader(),\n            original.getClass().getInterfaces(), new LogHandler(original));\n        target.say();\n    }\n}</code></pre>\n<p>这段代码的运行效果如下：</p>\n<pre class=\"code-rows\"><code>Ready to say something.\nHello Spring!\nAlready say something.</code></pre>\n<p>Spring AOP 的实现方式与我们的例子大同小异，相信通过这个例子大家已经能够对其背后的实现原理了解一二了。感兴趣的朋友可以阅读一下 <code>ProxyFactoryBean</code> 的源码，若是采用 JDK 动态代理，<code>AopProxyFactory</code> 会创建 <code>JdkDynamicAopProxy</code>；若是采用 CGLIB 代理，则是创建 <code>ObjenesisCglibAopProxy</code>，前者的逻辑就和我们的例子差不多。</p>\n<blockquote>\n<p><strong>茶歇时间：使用代理模式过程中的小坑</strong></p>\n<p>在上面的例子中，我们调用的是代理对象 <code>target</code> 上的方法，并不直接操作原始对象。在 Spring AOP 中，为了能用到被 AOP 增强过的方法，我们应该始终与代理对象交互。如果存在一个类的内部方法调用，这个调用的对象不是代理，而是其本身，则无法享受 AOP 增强的效果。</p>\n<p>比如，下面这个类中的 <code>foo()</code> 方法调用了 <code>bar()</code>，哪怕 Spring AOP 对 <code>bar()</code> 做了拦截，由于调用的不是代理对象，因而看不到任何效果，大家需要特别注意这种情况。</p>\n<pre class=\"code-rows\"><code>public class Hello {\n    public void foo() {\n        bar();\n    }\n\n    public void bar() {...}\n}</code></pre>\n</blockquote>\n<h2 id=\"nav_point_47\">3.2　基于 <code>@AspectJ</code> 的配置</h2>\n<p>回想我第一次接触 AOP 时，AspectJ 的使用体验并不理想。AspectJ 不仅需要编写单独的 Aspect 代码，还要通过 <code>ajc</code> 命令做编译。当然，尽管现在的 AspectJ 也有了长足进步，但 Spring AOP 中所有的东西都是 Java 类，对开发者来说用起来更为统一，体验更好。Spring Framework 同时支持 <code>@AspectJ</code> 注解和 XML Schema 两种方式来使用 AOP，虽然官方并没有明显的偏好，但个人认为注解的方式更贴近 Java 的风格，所以先来介绍一下基于注解的方式。</p>\n<p>首先，需要引入 <code>org.springframework:spring-aspects</code> 依赖，以便使用 AspectJ 相关的注解和功能。要开启 <code>@AspectJ</code> 支持，可以在 Java 配置类上增加 <code>@EnableAspectJAutoProxy</code> 注解，比如像下面这样：</p>\n<pre class=\"code-rows\"><code>@Configuration\n@EnableAspectJAutoProxy\npublic class Config {...}</code></pre>\n<p><code>@EnableAspectJAutoProxy</code> 有两个属性，<code>proxyTargetClass</code> 用于选择是否开启基于类的代理（是否使用 CGLIB 来做代理）；<code>exposeProxy</code> 用于选择是否将代理对象暴露到 <code>AopContext</code> 中，两者默认值都是 <code>false</code>。<span class=\"comment-number\">7</span></p>\n\n<p>我们也可以通过 XML Schema 的方式来实现相同的效果，如代码示例 3-4 所示，注意要正确地引入 <code>aop</code> 命名空间。</p>\n<blockquote>\n<p><strong>代码示例 3-4</strong>　通过 <code>&lt;aop:aspectj-autoproxy/&gt;</code> 开启 <code>@AspectJ</code> 支持</p>\n</blockquote>\n<pre class=\"code-rows\"><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:aop=\"http://www.springframework.org/schema/aop\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;\n\n    &lt;aop:aspectj-autoproxy/&gt;\n\n&lt;/beans&gt;</code></pre>\n<p>接下来，在完成配置后，我们就可以使用 <code>@Aspect</code> 注解来声明切面了，将这个注解加到类上即可：</p>\n<pre class=\"code-rows\"><code>@Aspect\npublic class MyAspect {...}</code></pre>\n<blockquote>\n<p><strong>注意</strong>　有两点内容需要重点说明。</p>\n<p>(1) 添加 <code>@Aspect</code> 注解只是告诉 Spring“这个类是切面”，但并没有把它声明为 Bean，因此需要我们手动进行配置，例如添加 <code>@Component</code> 注解，或者在 Java 配置类中进行声明。</p>\n<p>(2) Spring Framework 会对带有 <code>@Aspect</code> 注解的类做特殊对待，因为其本身就是一个切面，所以不会被别的切面自动拦截。</p>\n</blockquote>\n<p>在声明了切面后，我们就可以配置具体的切入点和通知了，本章的后面会对这些做具体的展开。</p>\n<h3 id=\"nav_point_48\">3.2.1　声明切入点</h3>\n<p>注解方式的切入点声明由两部分组成——<strong>切入点表达式</strong>和<strong>切入点方法签名</strong>。前者用来描述要匹配的连接点，后者可以用来引用切入点，方便切入点的复用，具体如代码示例 3-5 所示。</p>\n<blockquote>\n<p><strong>代码示例 3-5</strong>　一些简单的切入点声明</p>\n</blockquote>\n<pre class=\"code-rows\"><code>package learning.spring.helloworld;\n\npublic class HelloPointcut {\n    @Pointcut(\"target(learning.spring.helloworld.Hello)\")\n    public void helloType() {} // 目标对象是learning.spring.helloworld.Hello类型\n\n    @Pointcut(\"execution(public * say())\")\n    public void sayOperation() {} // 执行public的say()方法\n\n    @Pointcut(\"helloType() &amp;&amp; sayOperation()\") // 复用其他切入点\n    public void sayHello() {} // 执行Hello类型中public的say()方法\n}</code></pre>\n<p><code>@Pointcut</code> 注解中使用的就是 AspectJ 5 的表达式，其中一些常用的 PCD（pointcut designator，切入点标识符）如表 3-3 所示。</p>\n<p><strong>表 3-3　<code>@Pointcut</code> 中的一些常用 PCD</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>PCD</p></th>\n<th><p>说明</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>execution</code></p></td>\n<td><p>最常用的一个 PCD，用来匹配特定方法的执行</p></td>\n</tr>\n<tr>\n<td><p><code>within</code></p></td>\n<td><p>匹配特定范围内的类型，可以用通配符来匹配某个 Java 包内的所有类</p></td>\n</tr>\n<tr>\n<td><p><code>this</code></p></td>\n<td><p>Spring AOP 代理对象这个 Bean 本身要匹配某个给定的类型</p></td>\n</tr>\n<tr>\n<td><p><code>target</code></p></td>\n<td><p>目标对象要匹配某个给定的类型，比 <code>this</code> 更常用一些</p></td>\n</tr>\n<tr>\n<td><p><code>args</code></p></td>\n<td><p>传入的方法参数要匹配某个给定的类型，它也可以用于绑定请求参数</p></td>\n</tr>\n<tr>\n<td><p><code>bean</code></p></td>\n<td><p>Spring AOP 特有的一个 PCD，匹配 Bean 的 ID 或名称，可以用通配符</p></td>\n</tr>\n</tbody>\n</table>\n<p>因为 <code>execution</code> 用得非常多，下面详细描述一下它的表达式，<code>[]</code> 代表可选项，<code>&lt;&gt;</code> 代表必选项：</p>\n<pre class=\"code-rows\"><code>execution([修饰符] &lt;返回类型&gt; [全限定类名.]&lt;方法&gt;(&lt;参数&gt;) [异常])</code></pre>\n<p>其中，</p>\n<ul>\n<li>每个部分都可以使用 <code>*</code> 通配符</li>\n<li>类名中使用 <code>.*</code> 表示包中的所有类，<code>..*</code> 表示当前包与子包中的所有类</li>\n<li>参数主要分为以下几种情况：<ul>\n<li><code>()</code> 表示方法无参数</li>\n<li><code>(..)</code> 表示有任意个参数</li>\n<li><code>(*)</code> 表示有一个任意类型的参数</li>\n<li><code>(String)</code> 表示有一个 <code>String</code> 类型的参数</li>\n<li><code>(String,String)</code> 代表有两个 <code>String</code> 类型的参数</li>\n</ul>\n</li>\n</ul>\n<p>在 Java 中，为了方便标识，我们也经常使用注解，如果类上带了特定的注解，也可以用表 3-4 中的这些 PCD。</p>\n<p><strong>表 3-4　针对注解的常用 PCD</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>PCD</p></th>\n<th><p>说明</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>@target</code></p></td>\n<td><p>执行的目标对象带有特定类型注解</p></td>\n</tr>\n<tr>\n<td><p><code>@args</code></p></td>\n<td><p>传入的方法参数带有特定类型注解</p></td>\n</tr>\n<tr>\n<td><p><code>@annotation</code></p></td>\n<td><p>拦截的方法上带有特定类型注解</p></td>\n</tr>\n</tbody>\n</table>\n<p>切入点表达式支持与、或、非运算，运算符分别为 &amp;&amp;、||和 !，还可以进行灵活组合。</p>\n<p>最后，我们再提供一些示例：</p>\n<pre class=\"code-rows\"><code>// learning.spring.helloworld及其子包中所有类里的say方法\n// 该方法可以返回任意类型，第一个参数必须是String，后面可以跟任意参数\nexecution(* learning.spring.helloworld..*.say(String,..))\n\n// learning.spring.helloworld及其子包\nwithin(learning.spring.helloworld..*)\n\n// 方法的参数仅有一个String\nargs(java.lang.String)\n\n// 目标类型为Hello及其子类\ntarget(learning.spring.helloworld.Hello+)\n\n// 类上带有@AopNeeded注解\n@target(learning.spring.helloworld.AopNeeded)</code></pre>\n<blockquote>\n<p><strong>茶歇时间：Spring AOP 与 AspectJ 中 PCD 的不同之处</strong></p>\n<p>Spring AOP 中虽然使用了 AspectJ 5 的切入点表达式，也共用了不少 AspectJ 的 PCD，但其实两者还是有区别的。比如，Spring AOP 中仅支持有限的 PCD，AspectJ 中还有很多 PCD 是 Spring AOP 不支持的。</p>\n<p>由于 Spring AOP 的实现基于动态代理，因而只能匹配普通方法的执行，像静态初始化、静态方法、构造方法、属性赋值等操作都是拦截不到的。所以说相比 AspectJ 而言，Spring AOP 的功能弱很多，但在大部分场景下也基本够用。</p>\n<p>出于上述差异，在表 3-4 中我们并没有列出 <code>@within</code> 这个 PCD，因为在 Spring AOP 中，<code>@target</code> 与 <code>@within</code> 两者在使用上感受不到什么区别。前者要求运行时的目标对象带有注解，这个注解的 <code>@Retention</code> 是 <code>RetentionPolicy.RUNTIME</code>，即运行时的；后者要求被拦截的类上带有 <code>@Retention</code> 是 <code>RetentionPolicy.CLASS</code> 的注解。但 Spring AOP 只能拦截到非静态 <code>public</code> 方法的执行，两个 PCD 的效果一样，所以还是老老实实用 <code>@target</code> 吧。<span class=\"comment-number\">8</span></p>\n</blockquote>\n\n<h3 id=\"nav_point_49\">3.2.2　声明通知</h3>\n<p>Spring AOP 中有多种通知类型，可以帮助我们在方法的各个执行阶段进行拦截，例如，可以在方法执行前、返回后、抛出异常后添加特定的操作，也可以完全替代方法的实现，甚至为一个类添加原先没有的接口实现。</p>\n<ol>\n<li><p><strong>前置通知</strong></p>\n<p><code>@Before</code> 注解可以用来声明一个前置通知，注解中可以引用事先定义好的切入点，也可以直接传入一个切入点表达式，在被拦截到的方法开始执行前，会先执行通知中的代码：</p>\n<pre class=\"code-rows\"><code>@Aspect\npublic class BeforeAspect {\n    @Before(\"learning.spring.helloworld.HelloPointcut.sayHello()\")\n    public void before() {\n        System.out.println(\"Before Advice\");\n    }\n    // 同一个切面类里还可以有其他通知方法\n    // 这就是一个普通的Java类，没有太多限制\n}</code></pre>\n<p>前置通知的方法没有返回值，因为它在被拦截的方法前执行，就算有返回值也没地方使用，但是它可以对被拦截方法的参数进行加工，通过 <code>args</code> 这个 PCD 能明确参数，并将其绑定到前置通知方法的参数上。例如，要在 <code>sayHello(AtomicInteger)</code> 这个方法前对 <code>AtomicInteger</code> 类型的参数进行数值调整，就可以这样做：</p>\n<pre class=\"code-rows\"><code>@Before(\"learning.spring.helloworld.HelloPointcut.sayHello() &amp;&amp; args(count)\")\npublic void before(AtomicInteger count) {\n    // 操作count\n}</code></pre>\n<p>要是同时存在多个通知作用于同一处，可以让切面类实现 <code>Ordered</code> 接口，或者在上面添加 <code>@Order</code> 注解。指定的值越低，优先级则越高，在最终的代理对象执行时也会先执行优先级高的逻辑。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>后置通知</strong></p>\n<p>在方法执行后，可能正常返回，也可能抛出了异常。如果想要拦截正常返回的调用，可以使用</p>\n<p><code>@AfterReturing</code> 注解。例如像下面这样：</p>\n<pre class=\"code-rows\"><code>@AfterReturning(\"execution(public * say(..))\")\npublic void after() {}\n\n@AfterReturning(pointcut = \"execution(public * say(..))\", returning = \"words\")\npublic void printWords(String words) {\n    System.out.println(\"Say something: \" + words);\n}</code></pre>\n<p><code>printWords()</code> 方法的参数 <code>words</code> 就是被拦截方法的返回值，而且此处限定了该通知只拦截返回值是 <code>String</code> 类型的调用。需要提醒的是，<code>returning</code> 中给定的名字必须与方法的参数名保持一致。</p>\n<p>如果想要拦截抛出异常的调用，可以使用 <code>@AfterThrowing</code> 注解，这个注解的用法与 <code>@AfterReturing</code> 极为类似。例如：</p>\n<pre class=\"code-rows\"><code>@AfterThrowing(\"execution(public * say(..))\")\npublic void afterThrow() {}\n\n@AfterThrowing(pointcut = \"execution(public * say(..))\", throwing = \"exception\")\npublic void printException(Exception exception) {}</code></pre>\n<p>如果不关注执行是否成功，只是想在方法结束后做些动作，可以使用 <code>@After</code> 注解：</p>\n<pre class=\"code-rows\"><code>@After(\"execution(public * say(..))\")\npublic void afterAdvice() {}</code></pre>\n<p>添加了 <code>@After</code> 注解的方法必须要能够处理正常与异常这两种情况，但它又获取不到返回值或异常对象，所以一般只被用来做一些资源清理的工作。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>环绕通知</strong></p>\n<p>还有一种通知类型是环绕通知，它的功能比较强大，不仅可以在方法执行前后加入自己的逻辑，甚至可以完全替换方法本身的逻辑，或者替换调用参数。我们可以添加 @Around 注解来声明环绕通知，这个方法的签名需要特别注意，它的第一个参数必须是 ProceedingJoinPoint 类型的，方法的返回类型是被拦截方法的返回类型，或者直接用 Object 类型。</p>\n<p>例如，我们希望统计 <code>say()</code> 方法的执行时间，可以像代码示例 3-6 那样来声明环绕通知。</p>\n<blockquote>\n<p><strong>代码示例 3-6</strong>　统计方法耗时的环绕通知</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Aspect\npublic class TimerAspect {\n    @Around(\"execution(public * say(..))\")\n    public Object recordTime(ProceedingJoinPoint pjp) throws Throwable {\n        long start = System.currentTimeMillis();\n        try {\n            return pjp.proceed();\n        } finally {\n            long end = System.currentTimeMillis();\n            System.out.println(\"Total time: \" + (end - start) + \"ms\");\n        }\n    }\n}</code></pre>\n<p>其中的 <code>pjp.proceed()</code> 就是调用具体的连接点进行的处理，<code>proceed()</code> 方法也接受 <code>Ojbect[]</code> 参数，可以替代原先的参数。</p>\n<p>环绕通知虽然很强大，但在日常开发过程中，我们选择能满足需求的通知类型就好，如果 <code>@After</code> 够用，那就不用 <code>@Around</code> 了。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>引入通知</strong></p>\n<p>与前面介绍的几种相比，下面要介绍的最后一种 Spring AOP 通知不太常用。我们可以为 Bean 添加新的接口，并为新增的方法提供默认实现，这种操作被称为<strong>引入</strong>（Introduction）<span class=\"comment-number\">9</span>。在切面类里声明一个成员属性，该属性的类型就是要引入的类型，在上面添加 <code>@DeclareParents</code> 注解就可以声明引入，可以像下面这样为 <code>Hello</code> 及其子类实现 <code>GoodBye</code> 接口：</p>\n<pre class=\"code-rows\"><code>@Aspect\npublic class MyAspect {\n    @DeclareParents(value = \"learning.spring.helloworld.Hello+\", defaultImpl = DefaultGoodByeImpl.class)\n    private GoodBye goodBye;\n}</code></pre>\n<p>引入其实是针对类型进行的增强，<code>value</code> 中仅可填入要匹配的类型，可以使用 AspectJ 类型匹配模式。引入声明后，在 Spring 容器中取到的 Bean 就已经完成了增强，哪怕在前置通知中也是如此。</p>\n</li>\n</ol>\n\n<h3 id=\"nav_point_50\">3.2.3　基于 <code>@AspectJ</code> 的示例</h3>\n<p>为了便于大家能更好地掌握 Spring AOP 的用法，本节为大家准备了一个基于 <code>@AspectJ</code> 注解的 AOP 示例 <span class=\"comment-number\">10</span>，如代码示例 3-7 所示，假设这里我们有一个 <code>Hello</code> 接口及其对应实现 <code>SpringHello</code>。</p>\n\n<blockquote>\n<p><strong>代码示例 3-7</strong>　<code>Hello</code> 接口及其实现代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>public interface Hello {\n    // 为了方便演示改变参数内容，此处使用StringBuffer\n    String sayHello(StringBuffer words);\n}\n\n@Component\npublic class SpringHello implements Hello {\n    @Override\n    public String sayHello(StringBuffer words) {\n        return \"Hello! \" + words;\n    }\n}</code></pre>\n<p>第一个切面拦截 <code>Hello</code> 类型中的方法执行，我们在传入的 <code>StringBuffer</code> 中追加了一段文字，为了演示多个通知的执行顺序，还增加了 <code>@Order</code> 注解，如代码示例 3-8 所示。</p>\n<blockquote>\n<p><strong>代码示例 3-8</strong>　<code>HelloAspect</code> 切面代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Aspect\n@Component\n@Order(1)\npublic class HelloAspect {\n    @Before(\"target(learning.spring.helloworld.Hello) &amp;&amp; args(words)\")\n    public void addWords(StringBuffer words) {\n        words.append(\"Welcome to Spring! \");\n    }\n}</code></pre>\n<p>第二个切面 <code>SayAspect</code> 中有三部分内容（如代码示例 3-9 所示）：</p>\n<p>(1) 拦截所有 <code>say</code> 打头的方法，在 <code>StringBuffer</code> 参数中追加目前为止说过的话的计数 <span class=\"comment-number\">11</span>；</p>\n\n<p>(2) 为 <code>learning.spring.helloworld</code> 包内的类引入了一个 <code>GoodBye</code> 接口；</p>\n<p>(3) 通过环绕通知改变了 <code>sayHello()</code> 方法的执行结果，追加了对引入的 <code>GoodBye</code> 接口的调用。</p>\n<blockquote>\n<p><strong>代码示例 3-9</strong>　<code>SayAspect</code> 切面代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Aspect\n@Component\n@Order(2)\npublic class SayAspect {\n    @DeclareParents(value = \"learning.spring.helloworld.*\",\n                    defaultImpl = DefaultGoodBye.class)\n    private GoodBye bye;\n    private int counter = 0;\n\n    @Before(\"execution(* say*(..)) &amp;&amp; args(words)\")\n    public void countSentence(StringBuffer words) {\n        words.append(\"[\" + ++counter + \"]\\n\");\n    }\n\n    @Around(\"execution(* sayHello(..)) &amp;&amp; this(bye)\")\n    public String addSay(ProceedingJoinPoint pjp, GoodBye bye)\n        throws Throwable {\n        return pjp.proceed() + bye.sayBye();\n    }\n\n    public void reset() {\n        counter = 0;\n    }\n\n    public int getCounter() {\n        return counter;\n    }\n}</code></pre>\n<p>这个切面中所引入的 <code>GoodBye</code> 接口及其默认实现内容如代码示例 3-10 所示。</p>\n<blockquote>\n<p><strong>代码示例 3-10</strong>　<code>GoodBye</code> 接口及其实现的代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>public interface GoodBye {\n    String sayBye();\n}\n\npublic class DefaultGoodBye implements GoodBye {\n    @Override\n    public String sayBye() {\n        return \"Bye! \";\n    }\n}</code></pre>\n<p>为了验证这个示例的运行结果是否如我们预期的那样，可以编写一个执行类，直接去调用 <code>SpringHello</code> 的 <code>sayHello()</code> 方法。但在实际工作中，大家要写的代码远比例子中的复杂，而且很多时候需要进行各种测试来做验证——有了充分的单元测试，才能保障代码质量。因此，从本节开始，我们的示例中会加入测试用例来验证代码是否符合预期。接下来，就让我们来看看这两种方式的代码该如何编写。</p>\n<ol>\n<li><p><strong>直接运行代码</strong></p>\n<p>我们通过 <code>AnnotationConfigApplicationContext</code> 可以构建一个基于注解的 Spring 容器，再配合简单的 Java 配置类，这个代码就能运行了，如代码示例 3-11 所示。</p>\n<blockquote>\n<p><strong>代码示例 3-11</strong>　<code>Application</code> 类的代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Configuration\n@EnableAspectJAutoProxy\n@ComponentScan(\"learning.spring.helloworld\")\npublic class Application {\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext applicationContext =\n                new AnnotationConfigApplicationContext(Application.class);\n\n        Hello hello = applicationContext.getBean(\"springHello\", Hello.class);\n        System.out.println(hello.sayHello(new StringBuffer(\"My Friend. \")));\n        System.out.println(hello.sayHello(new StringBuffer(\"My Dear Friend. \")));\n    }\n}</code></pre>\n<p>上述代码的执行输出如下：</p>\n<pre class=\"code-rows\"><code>Hello! My Friend. Welcome to Spring! [1]\nBye!\nHello! My Dear Friend. Welcome to Spring! [2]\nBye!</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>单元测试</strong></p>\n<p>直接运行代码，然后通过肉眼查看输出内容来判断逻辑是否正确，这种方法虽然简单直观，但不具备在大规模项目中使用的条件——每次改动代码都要人肉测试，既不高效，又浪费人力资源。所以，能用代码来验证的事，我们就要把它们写成自动化测试。<span class=\"comment-number\">12</span></p>\n<p>Maven 工程默认将生产代码和测试代码分开了，生产代码在 <code>main</code> 目录中，而测试代码则写在 <code>test</code> 目录中。为了在项目中使用 JUnit 5 进行单元测试，pom.xml 文件需要引入 <code>spring-test</code> 和 <code>junit-jupiter</code> 依赖，就像下面这样：<span class=\"comment-number\">13</span></p>\n<pre class=\"code-rows\"><code>&lt;dependencies&gt;\n    &lt;!-- 省略其他内容 --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;\n        &lt;version&gt;5.3.15&lt;/version&gt;\n        &lt;scope&gt;test&lt;/scope&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;\n        &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;\n        &lt;version&gt;5.8.2&lt;/version&gt;\n        &lt;scope&gt;test&lt;/scope&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;</code></pre>\n<p>下面我们编写一个 <code>ApplicationTest</code> 类，通过其中的断言（assertion）来判断结果，如代码示例 3-12 所示。</p>\n<blockquote>\n<p><strong>代码示例 3-12</strong>　<code>ApplicationTest</code> 类的代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@ExtendWith(SpringExtension.class)\n@ContextConfiguration(classes = Application.class)\n// 这个@SpringJUnitConfig可以代替上述两行\n// @SpringJUnitConfig(Application.class)\npublic class ApplicationTest {\n    @Autowired\n    private Hello hello;\n    @Autowired\n    private SayAspect sayAspect;\n\n    @BeforeEach\n    public void setUp() {\n        // Spring容器是同一个，因此SayAspect也是同一个\n        // 重置计数器，方便进行断言判断\n        sayAspect.reset();\n    }\n\n    @Test\n    @DisplayName(\"springHello不为空\")\n    public void testNotEmpty() {\n        assertNotNull(hello);\n    }\n\n    @Test\n    @DisplayName(\"springHello是否为GoodBye类型\")\n    public void testIntroduction() {\n        assertTrue(hello instanceof GoodBye);\n    }\n\n    @Test\n    @DisplayName(\"通知是否均已执行\")\n    public void testAdvice() {\n        StringBuffer words = new StringBuffer(\"Test. \");\n        String sentence = hello.sayHello(words);\n        assertEquals(\"Test. Welcome to Spring! [1]\\n\", words.toString());\n        assertEquals(\"Hello! Test. Welcome to Spring! [1]\\nBye! \", sentence);\n    }\n\n    @Test\n    @DisplayName(\"说两句话，检查计数\")\n    public void testMultipleSpeaking() {\n        assertEquals(\"Hello! Test. Welcome to Spring! [1]\\nBye! \",\n                     hello.sayHello(new StringBuffer(\"Test. \")));\n        assertEquals(\"Hello! Test. Welcome to Spring! [2]\\nBye! \",\n                     hello.sayHello(new StringBuffer(\"Test. \")));\n    }\n}</code></pre>\n<p>在 IDEA 中执行测试后，可以看到如图 3-2 的测试结果。如果某项测试失败，那么对应测试就不会有绿色的对勾。大家可以通过点击选中某项测试，查看其具体执行情况。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00759.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 3-2　IDEA 中的测试结果</strong></p>\n<p>也可以在命令行中通过 Maven 来执行测试，由于 JUnit 5 对 Maven 及其插件的版本有要求，测试者最好安装 3.6.0 版本以上的 Maven，并在 pom.xml 中修改 maven-surefire-plugin 的版本，比如使用 2.22.0 以上的版本，像下面这样：</p>\n<pre class=\"code-rows\"><code>&lt;build&gt;\n    &lt;plugins&gt;\n        &lt;!-- 为了支持JUnit 5， 使用2.22.0的插件 --&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n            &lt;version&gt;2.22.0&lt;/version&gt;\n        &lt;/plugin&gt;\n    &lt;/plugins&gt;\n&lt;/build&gt;</code></pre>\n<p>随后在工程目录中执行 <code>mvn test</code> 命令，如果一切顺利，我们就可以在输出中看到类似如下的内容（如果有断言失败，也会在输出中有所提示）：</p>\n<pre class=\"code-rows\"><code>[INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.523 s - in learning.spring.\n    helloworld.ApplicationTest\n[INFO]\n[INFO] Results:\n[INFO]\n[INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0</code></pre>\n</li>\n</ol>\n\n\n<h2 id=\"nav_point_51\">3.3　基于 XML Schema 的配置</h2>\n<p>Spring Framework 除了支持以 <code>@AspectJ</code> 注解的方式来配置 AOP，还支持通过 <code>&lt;aop/&gt;</code> XML Schema 的方式。如果大家习惯使用 XML，也可以考虑采用这种方式。</p>\n<p>Spring AOP 相关的 XML 配置，都放在 <code>&lt;aop:config/&gt;</code> 中，比如要声明切面，就可以像代码示例 3-13 那样。切面类的内容和上一节介绍的类似，但无须添加注解。</p>\n<blockquote>\n<p><strong>代码示例 3-13</strong>　用 <code>&lt;aop:aspect/&gt;</code> 声明切面</p>\n</blockquote>\n<pre class=\"code-rows\"><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n        xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xmlns:aop=\"http://www.springframework.org/schema/aop\"\n        xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;\n\n    &lt;aop:config&gt;\n        &lt;aop:aspect id=\"helloAspect\" ref=\"aspectBean\"&gt;\n            &lt;!-- 其他内容省略 --&gt;\n        &lt;/aop:aspect&gt;\n    &lt;/aop:config&gt;\n\n    &lt;bean id=\"aspectBean\" class=\"...\" /&gt;\n&lt;/beans&gt;</code></pre>\n<h3 id=\"nav_point_52\">3.3.1　声明切入点</h3>\n<p>在 <code>&lt;aop:config/&gt;</code> 中，我们可以通过 <code>&lt;aop:pointcut/&gt;</code> 来配置切入点。它既可以配置在 <code>&lt;aop:config/&gt;</code> 中，也可以出现在 <code>&lt;aop:aspect/&gt;</code> 中。切入点的 <code>id</code> 可以方便复用，<code>expression</code> 中的切入点表达式就和 3.2.1 节中介绍的一致。例如像下面这样：</p>\n<pre class=\"code-rows\"><code>&lt;aop:config&gt;\n    &lt;aop:aspect id=\"helloAspect\" ref=\"aspectBean\"&gt;\n        &lt;aop:pointcut id=\"helloType\" expression=\"target(learning.spring.helloworld.Hello)\" /&gt;\n        &lt;!-- 其他内容省略 --&gt;\n    &lt;/aop:aspect&gt;\n&lt;/aop:config&gt;</code></pre>\n<p><code>&lt;aop:pointcut/&gt;</code> 的 <code>expression</code> 中既可以直接写表达式，也可以写带有 <code>@Pointcut</code> 注解的全限定方法。表达式同样支持运算，可以用 <code>&amp;&amp;</code>、<code>||</code> 和 <code>!</code>，或者 <code>and</code>、<code>or</code> 和 <code>not</code> 进行组合，考虑到 XML 中用前一种方式比较麻烦，这里建议大家还是尽量使用 <code>and</code>、<code>or</code> 和 <code>not</code>。需要注意一点，组合表达式中不能通过 <code>id</code> 来引用其他已经定义的切入点。</p>\n<h3 id=\"nav_point_53\">3.3.2　声明通知</h3>\n<p>在 XML 中的通知也和 <code>@AspectJ</code> 注解的类似，只不过换成了 <code>&lt;aop:before/&gt;</code>、<code>&lt;aop:after-returning/&gt;</code> 等 XML 而已。如果有多个通知要执行，可以让切面类实现 <code>Ordered</code> 接口或者添加 <code>@Order</code> 注解，<code>&lt;aop:aspect/&gt;</code> 中有一个 <code>order</code> 属性也可以配置切面的顺序。</p>\n<ol>\n<li><p><strong>前置通知</strong></p>\n<p><code>&lt;aop:before/&gt;</code> 可以用来声明前置通知，<code>method</code> 属性的值是切面的具体方法，其中包含了前置通知的代码逻辑；<code>pointcut</code> 属性的值是切入点表达式，也可以通过 <code>pointcut-ref</code> 属性来使用事先定义好的切入点。例如，代码示例 3-7 的前置通知，可以改写为如下 XML 格式：</p>\n<pre class=\"code-rows\"><code>&lt;aop:aspect id=\"beforeAspect\" ref=\"beforeAspectBean\"&gt;\n    &lt;aop:before pointcut=\"learning.spring.helloworld.HelloPointcut.sayHello()\" method=\"before\" /&gt;\n&lt;/aop:aspect&gt;</code></pre>\n<p>在 <code>pointcut</code> 中也可以使用绑定的方式向方法传递参数，比如用 <code>args()</code>、<code>this()</code> 或 <code>target()</code>。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>后置通知</strong></p>\n<p>与基于 <code>@AspectJ</code> 注解的方式一样，基于 XML Schema 的后置通知同样分为三类。</p>\n<ul>\n<li>正常返回：<code>&lt;aop:after-returning/&gt;</code>。</li>\n<li>抛出异常：<code>&lt;aop:after-throwing/&gt;</code>。</li>\n<li>无所谓正常返回还是抛出异常：<code>&lt;aop:after/&gt;</code>。</li>\n</ul>\n<p>三个标签中都有 <code>pointcut</code>、<code>pointcut-ref</code> 和 <code>method</code> 属性，其作用与 <code>&lt;aop:before/&gt;</code> 中介绍的一样。</p>\n<p><code>&lt;aop:after-returning/&gt;</code> 中还有一个 <code>returning</code> 属性，用来将方法的执行返回传递到通知方法中，属性值需要与方法的参数名一致。当然，我们也可以忽略这个属性，不关心返回值。3.2.2 节中的例子可以改写成下面这样：</p>\n<pre class=\"code-rows\"><code>&lt;aop:after-returning pointcut=\"execution(public * say(..))\"\n                       returning=\"words\"\n                       method=\"printWords\" /&gt;</code></pre>\n<p><code>&lt;aop:after-throwing/&gt;</code> 中也与注解一样，有一个 <code>throwing</code> 属性，用来向通知方法中传递抛出的异常。3.2.2 节中的例子同样可以改写成下面这样：</p>\n<pre class=\"code-rows\"><code>&lt;aop:after-throwing pointcut=\"execution(public * say(..))\"\n                      method=\"afterThrow\" /&gt;\n\n&lt;aop:after-throwing pointcut=\"execution(public * say(..))\"\n                      throwing=\"exception\"\n                      method=\"printException\" /&gt;</code></pre>\n<p><code>&lt;aop:after/&gt;</code> 则相对简单，没有额外的属性可以配置。上面的例子改写为 XML 后就像下面这样：</p>\n<pre class=\"code-rows\"><code>&lt;aop:after pointcut=\"execution(public * say(..))\" method=\"afterAdvice\" /&gt;</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>环绕通知</strong></p>\n<p>环绕通知的代码实现与使用 <code>@AspectJ</code> 注解时是一样的，只不过将注解换成了 <code>&lt;aop:around/&gt;</code> 的 XML，代码示例 3-8 的声明可以改写成如下 XML：</p>\n<pre class=\"code-rows\"><code>&lt;aop:around pointcut=\"execution(public * say(..))\" method=\"recordTime\" /&gt;</code></pre>\n<p>至于具体的方法定义，可以回顾一下 3.2.2 节中的相关内容和代码示例 3-8。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>引入通知</strong></p>\n<p>XML 中同样也可以声明引入，在 <code>&lt;aop:aspect/&gt;</code> 中通过 <code>&lt;aop:declare-parents/&gt;</code> 就可以实现和 <code>@DeclareParents</code> 注解一样的效果，<code>&lt;aop:declare-parents/&gt;</code> 里有三个属性。</p>\n<ul>\n<li><code>types-matching</code>：用来匹配类型，比如 <code>learning.spring.helloworld.*+</code>。</li>\n<li><code>implement-interface</code>：要引入的接口。</li>\n<li><code>default-impl</code>：接口的默认实现。</li>\n</ul>\n<p>3.2.2 节中的 <code>@DeclareParents</code> 示例可以改写成下面这样：</p>\n<pre class=\"code-rows\"><code>&lt;aop:aspect id=\"myAspect\" ref=\"myAspectBean\"&gt;\n    &lt;aop:declare-parents types-matching=\"learning.spring.helloworld.Hello+\"\n        implement-interface=\"learning.spring.helloworld.GoodBye\"\n        default-impl=\"learning.spring.helloworld.DefaultGoodByeImpl\"/&gt;\n    &lt;!-- 其他省略 --&gt;\n&lt;/aop:aspect&gt;</code></pre>\n</li>\n</ol>\n<h3 id=\"nav_point_54\">3.3.3　通知器</h3>\n<p>如果觉得 XML Schema 的配置方式比较繁琐，在 <code>&lt;aop:config/&gt;</code> 中又有 <code>&lt;aop:aspect/&gt;</code>，又有 <code>&lt;aop:pointcut/&gt;</code>，还有各种通知。为此，Spring Framework 为我们提供了一套通知器（advisor）的 XML 元素，通过 <code>&lt;aop:advisor/&gt;</code> 可以简单地配置出一个仅包含单个通知的切面，通知器中引用的 Bean 要实现如下的 AOP 通知接口。</p>\n<ul>\n<li><code>MethodInterceptor</code>：环绕通知。</li>\n<li><code>MethodBeforeAdvice</code>：前置通知。</li>\n<li><code>AfterReturningAdvice</code>：正常返回的后置通知。</li>\n<li><code>ThrowsAdvice</code>：抛出异常的后置通知。</li>\n</ul>\n<p>随后，可以像下面这样来定义通知器：</p>\n<pre class=\"code-rows\"><code>&lt;aop:config&gt;\n    &lt;aop:pointcut id=\"sayMethod\" expression=\"execution(public * say(..))\" /&gt;\n\n    &lt;aop:advisor pointcut-ref=\"sayMethod\" advice-ref=\"aroundAdvice\" /&gt;\n&lt;/aop:config&gt;\n\n&lt;bean id=\"aroundAdvice\" class=\"learning.spring.helloworld.SayMethodInterceptor\" /&gt;</code></pre>\n<h3 id=\"nav_point_55\">3.3.4　基于 XML Schema 的示例</h3>\n<p>与 3.2 节一样，本节也提供了一个示例帮助大家理解并掌握基于 XML Schema 的 AOP 使用方式。有了 3.2.3 节的基础，本节的例子可以基本照搬 3.2.3 节中的代码，去除所有 <code>@AspectJ</code> 相关的注解，同时将 Bean 配置方式从注解换成 XML。<span class=\"comment-number\">14</span></p>\n\n<p>在项目的 <code>resources</code> 目录中添加一个 applicationContext.xml，内容如代码示例 3-14 所示。可以看到 XML 文件可以完全取代注解来实现 AOP 相关的配置。</p>\n<blockquote>\n<p><strong>代码示例 3-14</strong>　完整的 <code>applicationContext.xml</code> 文件</p>\n</blockquote>\n<pre class=\"code-rows\"><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n        xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xmlns:aop=\"http://www.springframework.org/schema/aop\"\n        xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;\n\n    &lt;aop:config&gt;\n        &lt;aop:aspect ref=\"helloAspect\" order=\"1\"&gt;\n            &lt;aop:before pointcut=\"target(learning.spring.helloworld.Hello) and args(words)\"\n                        method=\"addWords\"/&gt;\n        &lt;/aop:aspect&gt;\n\n        &lt;aop:aspect ref=\"sayAspect\" order=\"2\"&gt;\n            &lt;aop:before pointcut=\"execution(* say*(..)) and args(words)\" method=\"countSentence\" /&gt;\n            &lt;aop:around pointcut=\"execution(* sayHello(..)) and this(bye)\" method=\"addSay\" /&gt;\n            &lt;aop:declare-parents types-matching=\"learning.spring.helloworld.*\"\n                implement-interface=\"learning.spring.helloworld.GoodBye\"\n                default-impl=\"learning.spring.helloworld.DefaultGoodBye\" /&gt;\n        &lt;/aop:aspect&gt;\n    &lt;/aop:config&gt;\n\n    &lt;bean id=\"springHello\" class=\"learning.spring.helloworld.SpringHello\" /&gt;\n    &lt;bean id=\"helloAspect\" class=\"learning.spring.helloworld.HelloAspect\" /&gt;\n    &lt;bean id=\"sayAspect\" class=\"learning.spring.helloworld.SayAspect\" /&gt;\n\n&lt;/beans&gt;</code></pre>\n<p>由于容器的配置使用了 XML 文件，所以在 <code>Application</code> 类中也要使用对应的类来加载容器配置，本次我们选择了 <code>ClassPathXmlApplicationContext</code>，具体的执行代码如代码示例 3-15 所示。运行后可以看到与 3.2.3 中一样的输出。</p>\n<blockquote>\n<p><strong>代码示例 3-15</strong>　<code>Application</code> 类的代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>public class Application {\n    public static void main(String[] args) {\n        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n\n        Hello hello = applicationContext.getBean(\"springHello\", Hello.class);\n        System.out.println(hello.sayHello(new StringBuffer(\"My Friend. \")));\n        System.out.println(hello.sayHello(new StringBuffer(\"My Dear Friend. \")));\n    }\n}</code></pre>\n<p>对于单元测试，我们需要做的改动也非常小，之前的 <code>@ContextConfiguration</code> 中给的是 Java 配置类，这次将其改为提供 CLASSPATH 中的 XML 配置文件，其余不动，具体如下所示：</p>\n<pre class=\"code-rows\"><code>@ExtendWith(SpringExtension.class)\n@ContextConfiguration(\"classpath:applicationContext.xml\")\npublic class ApplicationTest {\n    // 省略\n}</code></pre>\n<blockquote>\n<p><strong>茶歇时间：超简洁的 JUnit 单元测试入门</strong></p>\n<p>在这两节的例子中，我们都使用了 JUnit 5 来进行自动化测试。有了自动化测试的保障，我们就可以在每次修改代码后快速进行验证，这样既能保障质量，又能节省大量人力。因此，很有必要为系统编写测试代码，其中单元测试和集成测试缺一不可。</p>\n<p>通过代码示例 3-12 可以看到，带有 <code>@Test</code> 注解的方法会被视为测试方法，在测试方法中务必使用断言进行判断，而不要用输出日志的方式进行人工观察，否则测试代码的价值会大打折扣。<code>org.junit.jupiter.api.Assertions</code> 类中提供了大量的断言静态方法，比如：</p>\n<ul>\n<li>判断两者是否相等的 <code>assertEquals()</code> 和 <code>assertNotEquals()</code>；</li>\n<li>判断布尔值的 <code>assertTrue()</code> 和 <code>assertFalse()</code>；</li>\n<li>判断对象是否为空的 <code>assertNull()</code> 和 <code>assertNotNull()</code>。</li>\n</ul>\n<p>在每个测试方法执行前后，都可以执行一些初始化和清理的逻辑：添加了 <code>@BeforeEach</code> 和 <code>@AfterEach</code> 的方法会分别在测试方法执行前后被 JUnit 执行；如果要在所有测试方法执行前进行总的初始化，可以使用 <code>@BeforeAll</code> 注解，对应的还有所有测试方法执行后执行的 <code>@AfterAll</code>。</p>\n<p>JUnit 5 可以通过 <code>@ExtendWith</code> 注解来添加扩展，在我们的例子中，<code>@ExtendWith(SpringExtension.class)</code> 就添加了 Spring 的测试支持，<code>@ContextConfiguration</code> 注解指定了用来初始化 Spring 容器的配置类或配置文件。</p>\n<p>值得一提的是，JUnit 4 和 JUnit 5 在 API 层面存在不少差异，比如 <code>@Before</code> 和 <code>@After</code> 分别对应了 <code>@BeforeEach</code> 和 <code>@AfterEach</code>，<code>@RunWith</code> 对应了 <code>@ExtendWith</code>，两个版本的 <code>assertXxx()</code> 静态方法放在了不同的类里等。如果大家还在使用 JUnit 4，可以查阅官方文档了解具体的用法。鉴于 JUnit 5 在功能上更胜一筹，如果可以的话，建议大家还是使用 JUnit 5，在本书后面的章节也会有更多关于 Spring 的测试支持的例子。</p>\n</blockquote>\n<h2 id=\"nav_point_56\">3.4　小结</h2>\n<p>通过本章的学习，相信大家已经对 Spring AOP 有了一个基本的认识：了解了 AOP 的核心概念以及 Spring Framework 中 AOP 的实现原理；学习了 Spring Framework 提供的两种配置方式，大家可以根据实际情况选择使用基于 <code>@AspectJ</code> 注解的方式，或者基于 <code>&lt;aop/&gt;</code>XML Schema 的方式（无论哪种方式，其中对切面、切入点和通知的定义大同小异）。</p>\n<p>此外，本章的两个 <code>Hello</code> 示例，都提供了基于 JUnit 5 的自动化测试代码，演示了如何通过单元测试来验证代码的逻辑。希望大家在日常工作中能更多地使用这种测试方式，本书后续章节也会有更多这方面的内容。</p>\n<p>下一章，我们会从 Spring Framework 进入 Spring Boot 的领域，为大家介绍 Spring Boot 的几个核心功能。</p>\n\n<br style=\"page-break-after:always\" />","comments":[{"had_liked":false,"id":392354,"user_name":"Geek_091400","can_delete":false,"product_type":"c1","uid":3923875,"ip_address":"山东","ucode":"A9A30B8C4613FA","user_header":"","comment_is_top":false,"comment_ctime":1720673770,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636606,"comment_content":"作者对Spring Framework的AOP理解真深入呀","like_count":0}]}