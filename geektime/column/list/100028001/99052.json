{"id":99052,"title":"07 | 深入浅出HashMap的设计与优化","content":"<p>你好，我是刘超。</p><p>在上一讲中我提到过Collection接口，那么在Java容器类中，除了这个接口之外，还定义了一个很重要的Map接口，主要用来存储键值对数据。</p><p>HashMap作为我们日常使用最频繁的容器之一，相信你一定不陌生了。今天我们就从HashMap的底层实现讲起，深度了解下它的设计与优化。</p><h2>常用的数据结构</h2><p>我在05讲分享List集合类的时候，讲过ArrayList是基于数组的数据结构实现的，LinkedList是基于链表的数据结构实现的，而我今天要讲的HashMap是基于哈希表的数据结构实现的。我们不妨一起来温习下常用的数据结构，这样也有助于你更好地理解后面地内容。</p><p><strong>数组</strong>：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)，但在数组中间以及头部插入数据时，需要复制移动后面的元素。</p><p><strong>链表</strong>：一种在物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。</p><p>链表由一系列结点（链表中每一个元素）组成，结点可以在运行时动态生成。每个结点都包含“存储数据单元的数据域”和“存储下一个结点地址的指针域”这两个部分。</p><p>由于链表不用必须按顺序存储，所以链表在插入的时候可以达到O(1)的复杂度，但查找一个结点或者访问特定编号的结点需要O(n)的时间。</p><!-- [[[read_end]]] --><p><strong>哈希表</strong>：根据关键码值（Key value）直接进行访问的数据结构。通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做哈希函数，存放记录的数组就叫做哈希表。</p><p><strong>树</strong>：由n（n≥1）个有限结点组成的一个具有层次关系的集合，就像是一棵倒挂的树。</p><h2>HashMap的实现结构</h2><p>了解完数据结构后，我们再来看下HashMap的实现结构。作为最常用的Map类，它是基于哈希表实现的，继承了AbstractMap并且实现了Map接口。</p><p>哈希表将键的Hash值映射到内存地址，即根据键获取对应的值，并将其存储到内存地址。也就是说HashMap是根据键的Hash值来决定对应值的存储位置。通过这种索引方式，HashMap获取数据的速度会非常快。</p><p>例如，存储键值对（x，“aa”）时，哈希表会通过哈希函数f(x)得到\"aa\"的实现存储位置。</p><p>但也会有新的问题。如果再来一个(y，“bb”)，哈希函数f(y)的哈希值跟之前f(x)是一样的，这样两个对象的存储地址就冲突了，这种现象就被称为哈希冲突。<span class=\"orange\">那么哈希表是怎么解决的呢？方式有很多，比如，开放定址法、再哈希函数法和链地址法。</span></p><p>开放定址法很简单，当发生哈希冲突时，如果哈希表未被装满，说明在哈希表中必然还有空位置，那么可以把key存放到冲突位置后面的空位置上去。这种方法存在着很多缺点，例如，查找、扩容等，所以我不建议你作为解决哈希冲突的首选。</p><p>再哈希法顾名思义就是在同义词产生地址冲突时再计算另一个哈希函数地址，直到冲突不再发生，这种方法不易产生“聚集”，但却增加了计算时间。如果我们不考虑添加元素的时间成本，且对查询元素的要求极高，就可以考虑使用这种算法设计。</p><p>HashMap则是综合考虑了所有因素，采用链地址法解决哈希冲突问题。这种方法是采用了数组（哈希表）+ 链表的数据结构，当发生哈希冲突时，就用一个链表结构存储相同Hash值的数据。</p><h2>HashMap的重要属性</h2><p>从HashMap的源码中，我们可以发现，HashMap是由一个Node数组构成，每个Node包含了一个key-value键值对。</p><pre><code>  transient Node&lt;K,V&gt;[] table;\n</code></pre><p>Node类作为HashMap中的一个内部类，除了key、value两个属性外，还定义了一个next指针。当有哈希冲突时，HashMap会用之前数组当中相同哈希值对应存储的Node对象，通过指针指向新增的相同哈希值的Node对象的引用。</p><pre><code>static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {\n        final int hash;\n        final K key;\n        V value;\n        Node&lt;K,V&gt; next;\n\n        Node(int hash, K key, V value, Node&lt;K,V&gt; next) {\n            this.hash = hash;\n            this.key = key;\n            this.value = value;\n            this.next = next;\n        }\n}\n</code></pre><p>HashMap还有两个重要的属性：加载因子（loadFactor）和边界值（threshold）。在初始化HashMap时，就会涉及到这两个关键初始化参数。</p><pre><code>int threshold;\n\n    final float loadFactor;\n</code></pre><p>LoadFactor属性是用来间接设置Entry数组（哈希表）的内存空间大小，在初始HashMap不设置参数的情况下，默认LoadFactor值为0.75。<strong>为什么是0.75这个值呢？</strong></p><p>这是因为对于使用链表法的哈希表来说，查找一个元素的平均时间是O(1+n)，这里的n指的是遍历链表的长度，因此加载因子越大，对空间的利用就越充分，这就意味着链表的长度越长，查找效率也就越低。如果设置的加载因子太小，那么哈希表的数据将过于稀疏，对空间造成严重浪费。</p><p>那有没有什么办法来解决这个因链表过长而导致的查询时间复杂度高的问题呢？你可以先想想，我将在后面的内容中讲到。</p><p>Entry数组的Threshold是通过初始容量和LoadFactor计算所得，在初始HashMap不设置参数的情况下，默认边界值为12。如果我们在初始化时，设置的初始化容量较小，HashMap中Node的数量超过边界值，HashMap就会调用resize()方法重新分配table数组。这将会导致HashMap的数组复制，迁移到另一块内存中去，从而影响HashMap的效率。</p><h2>HashMap添加元素优化</h2><p>初始化完成后，HashMap就可以使用put()方法添加键值对了。从下面源码可以看出，当程序将一个key-value对添加到HashMap中，程序首先会根据该key的hashCode()返回值，再通过hash()方法计算出hash值，再通过putVal方法中的(n - 1) &amp; hash决定该Node的存储位置。</p><pre><code> public V put(K key, V value) {\n        return putVal(hash(key), key, value, false, true);\n    }\n</code></pre><pre><code> static final int hash(Object key) {\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n    }\n</code></pre><pre><code>  if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length;\n        //通过putVal方法中的(n - 1) &amp; hash决定该Node的存储位置\n        if ((p = tab[i = (n - 1) &amp; hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n\n</code></pre><p><span class=\"orange\">如果你不太清楚hash()以及(n-1)&amp;hash的算法，就请你看下面的详述。</span></p><p>我们先来了解下hash()方法中的算法。如果我们没有使用hash()方法计算hashCode，而是直接使用对象的hashCode值，会出现什么问题呢？</p><p>假设要添加两个对象a和b，如果数组长度是16，这时对象a和b通过公式(n - 1) &amp; hash运算，也就是(16-1)＆a.hashCode和(16-1)＆b.hashCode，15的二进制为0000000000000000000000000001111，假设对象 A 的 hashCode 为 1000010001110001000001111000000，对象 B 的 hashCode 为 0111011100111000101000010100000，你会发现上述与运算结果都是0。这样的哈希结果就太让人失望了，很明显不是一个好的哈希算法。</p><p>但如果我们将 hashCode 值右移 16 位（h &gt;&gt;&gt; 16代表无符号右移16位），也就是取 int 类型的一半，刚好可以将该二进制数对半切开，并且使用位异或运算（如果两个数对应的位置相反，则结果为1，反之为0），这样的话，就能避免上面的情况发生。这就是hash()方法的具体实现方式。<strong>简而言之，就是尽量打乱hashCode真正参与运算的低16位。</strong></p><p>我再来解释下(n - 1) &amp; hash是怎么设计的，这里的n代表哈希表的长度，哈希表习惯将长度设置为2的n次方，这样恰好可以保证(n - 1) &amp; hash的计算得到的索引值总是位于table数组的索引之内。例如：hash=15，n=16时，结果为15；hash=17，n=16时，结果为1。</p><p>在获得Node的存储位置后，如果判断Node不在哈希表中，就新增一个Node，并添加到哈希表中，整个流程我将用一张图来说明：</p><p><img src=\"https://static001.geekbang.org/resource/image/eb/d9/ebc8c027e556331dc327e18feb00c7d9.jpg?wh=1454*1380\" alt=\"\"></p><p><strong>从图中我们可以看出：</strong>在JDK1.8中，HashMap引入了红黑树数据结构来提升链表的查询效率。</p><p>这是因为链表的长度超过8后，红黑树的查询效率要比链表高，所以当链表超过8时，HashMap就会将链表转换为红黑树，这里值得注意的一点是，这时的新增由于存在左旋、右旋效率会降低。讲到这里，我前面我提到的“因链表过长而导致的查询时间复杂度高”的问题，也就迎刃而解了。</p><p>以下就是put的实现源码:</p><pre><code> final V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;\n        if ((tab = table) == null || (n = tab.length) == 0)\n//1、判断当table为null或者tab的长度为0时，即table尚未初始化，此时通过resize()方法得到初始化的table\n            n = (tab = resize()).length;\n        if ((p = tab[i = (n - 1) &amp; hash]) == null)\n//1.1、此处通过（n - 1） &amp; hash 计算出的值作为tab的下标i，并另p表示tab[i]，也就是该链表第一个节点的位置。并判断p是否为null\n            tab[i] = newNode(hash, key, value, null);\n//1.1.1、当p为null时，表明tab[i]上没有任何元素，那么接下来就new第一个Node节点，调用newNode方法返回新节点赋值给tab[i]\n        else {\n//2.1下面进入p不为null的情况，有三种情况：p为链表节点；p为红黑树节点；p是链表节点但长度为临界长度TREEIFY_THRESHOLD，再插入任何元素就要变成红黑树了。\n            Node&lt;K,V&gt; e; K k;\n            if (p.hash == hash &amp;&amp;\n                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))\n//2.1.1HashMap中判断key相同的条件是key的hash相同，并且符合equals方法。这里判断了p.key是否和插入的key相等，如果相等，则将p的引用赋给e\n\n                e = p;\n            else if (p instanceof TreeNode)\n//2.1.2现在开始了第一种情况，p是红黑树节点，那么肯定插入后仍然是红黑树节点，所以我们直接强制转型p后调用TreeNode.putTreeVal方法，返回的引用赋给e\n                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);\n            else {\n//2.1.3接下里就是p为链表节点的情形，也就是上述说的另外两类情况：插入后还是链表/插入后转红黑树。另外，上行转型代码也说明了TreeNode是Node的一个子类\n                for (int binCount = 0; ; ++binCount) {\n//我们需要一个计数器来计算当前链表的元素个数，并遍历链表，binCount就是这个计数器\n\n                    if ((e = p.next) == null) {\n                        p.next = newNode(hash, key, value, null);\n                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) \n// 插入成功后，要判断是否需要转换为红黑树，因为插入后链表长度加1，而binCount并不包含新节点，所以判断时要将临界阈值减1\n                            treeifyBin(tab, hash);\n//当新长度满足转换条件时，调用treeifyBin方法，将该链表转换为红黑树\n                        break;\n                    }\n                    if (e.hash == hash &amp;&amp;\n                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n                        break;\n                    p = e;\n                }\n            }\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;\n        if (++size &gt; threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    }\n\n</code></pre><h2>HashMap获取元素优化</h2><p>当HashMap中只存在数组，而数组中没有Node链表时，是HashMap查询数据性能最好的时候。一旦发生大量的哈希冲突，就会产生Node链表，这个时候每次查询元素都可能遍历Node链表，从而降低查询数据的性能。</p><p>特别是在链表长度过长的情况下，性能将明显降低，红黑树的使用很好地解决了这个问题，使得查询的平均复杂度降低到了O(log(n))，链表越长，使用黑红树替换后的查询效率提升就越明显。</p><p>我们在编码中也可以优化HashMap的性能，例如，重写key值的hashCode()方法，降低哈希冲突，从而减少链表的产生，高效利用哈希表，达到提高性能的效果。</p><h2>HashMap扩容优化</h2><p>HashMap也是数组类型的数据结构，所以一样存在扩容的情况。</p><p>在JDK1.7 中，HashMap整个扩容过程就是分别取出数组元素，一般该元素是最后一个放入链表中的元素，然后遍历以该元素为头的单向链表元素，依据每个被遍历元素的 hash 值计算其在新数组中的下标，然后进行交换。这样的扩容方式会将原来哈希冲突的单向链表尾部变成扩容后单向链表的头部。</p><p>而在 JDK 1.8 中，HashMap对扩容操作做了优化。由于扩容数组的长度是 2 倍关系，所以对于假设初始 tableSize = 4 要扩容到 8 来说就是 0100 到 1000 的变化（左移一位就是 2 倍），在扩容中只用判断原来的 hash 值和左移动的一位（newtable 的值）按位与操作是 0 或 1 就行，0 的话索引不变，1 的话索引变成原索引加上扩容前数组。</p><p>之所以能通过这种“与运算“来重新分配索引，是因为 hash 值本来就是随机的，而hash 按位与上 newTable 得到的 0（扩容前的索引位置）和 1（扩容前索引位置加上扩容前数组长度的数值索引处）就是随机的，所以扩容的过程就能把之前哈希冲突的元素再随机分布到不同的索引中去。</p><h2>总结</h2><p>HashMap通过哈希表数据结构的形式来存储键值对，这种设计的好处就是查询键值对的效率高。</p><p>我们在使用HashMap时，可以结合自己的场景来设置初始容量和加载因子两个参数。当查询操作较为频繁时，我们可以适当地减少加载因子；如果对内存利用率要求比较高，我可以适当的增加加载因子。</p><p><span class=\"orange\">我们还可以在预知存储数据量的情况下，提前设置初始容量（初始容量=预知数据量/加载因子）。</span>这样做的好处是可以减少resize()操作，提高HashMap的效率。</p><p>HashMap还使用了数组+链表这两种数据结构相结合的方式实现了链地址法，当有哈希值冲突时，就可以将冲突的键值对链成一个链表。</p><p>但这种方式又存在一个性能问题，如果链表过长，查询数据的时间复杂度就会增加。HashMap就在Java8中使用了红黑树来解决链表过长导致的查询性能下降问题。以下是HashMap的数据结构图：</p><p><img src=\"https://static001.geekbang.org/resource/image/c0/6f/c0a12608e37753c96f2358fe0f6ff86f.jpg?wh=1304*904\" alt=\"\"></p><h2>思考题</h2><p>实际应用中，我们设置初始容量，一般得是2的整数次幂。你知道原因吗？</p><p>期待在留言区看到你的答案。也欢迎你点击“请朋友读”，把今天的内容分享给身边的朋友，邀请他一起学习。</p><p></p>","comments":[{"had_liked":false,"id":100579,"user_name":"陆离","can_delete":false,"product_type":"c1","uid":1483932,"ip_address":"","ucode":"2C8C206CE36A81","user_header":"https://static001.geekbang.org/account/avatar/00/16/a4/9c/b32ed9e9.jpg","comment_is_top":false,"comment_ctime":1559598526,"is_pvip":false,"replies":[{"id":"36249","content":"回答正确，就是减少哈希冲突，均匀分布元素。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1559610503,"ip_address":"","comment_id":100579,"utype":1}],"discussion_count":6,"race_medal":0,"score":"482595935678","product_id":100028001,"comment_content":"2的幂次方减1后每一位都是1，让数组每一个位置都能添加到元素。<br>例如十进制8，对应二进制1000，减1是0111，这样在&amp;hash值使数组每个位置都是可以添加到元素的，如果有一个位置为0，那么无论hash值是多少那一位总是0，例如0101，&amp;hash后第二位总是0，也就是说数组中下标为2的位置总是空的。<br>如果初始化大小设置的不是2的幂次方，hashmap也会调整到比初始化值大且最近的一个2的幂作为capacity。<br>","like_count":113,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452608,"discussion_content":"回答正确，就是减少哈希冲突，均匀分布元素。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559610503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1260141,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3a/6d/910b2445.jpg","nickname":"Wheat","note":"","ucode":"7D99EA149B6DE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261876,"discussion_content":"不是数组下表为2的元素是空的，而是数组下标的2进制的第2位为1的就都用不了了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1589017650,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1539926,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIUBia0Aevb2CyMNPvuzTkVvlcoDpdFELFav5Bcic90wxehZibo0VglM7aRZLMo93Ful7v5TFlKfEYyg/132","nickname":"啊不多","note":"","ucode":"A38DE3C564B748","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":177819,"discussion_content":"还有一个在扩容的时候 也利用到了2的幂次方这个特性 ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582122178,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1391249,"avatar":"https://static001.geekbang.org/account/avatar/00/15/3a/91/d894a61f.jpg","nickname":"好久不见","note":"","ucode":"283FDB7580D398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295771,"discussion_content":"这样回答因果倒置了吧。这个2的幂次方应该是putVal中(n - 1) &amp; hash这个计算方式定的，进而取2的幂次方可以使数据均匀分布。但如果这里是hash % (n-1)，那n不为2的幂次方也没问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596338453,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2106663,"avatar":"https://static001.geekbang.org/account/avatar/00/20/25/27/0076d304.jpg","nickname":"帽子狗","note":"","ucode":"51596F366AF068","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1391249,"avatar":"https://static001.geekbang.org/account/avatar/00/15/3a/91/d894a61f.jpg","nickname":"好久不见","note":"","ucode":"283FDB7580D398","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329035,"discussion_content":"没有本末倒置，是因为2的幂取mod有这个特性：((2^n)-1)&amp;x == x%2^n...   为了快速hash选择位运算，如果改成其他的数，每次get都mod一次，效率大打折扣。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606300516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":295771,"ip_address":""},"score":329035,"extra":""},{"author":{"id":2166073,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/k3YD3y3BzGDSdrwRJyJY4BXsNJibfM4uzOdDVKIAlFApR2FZCLg2ibrZtJ4vuahA3LHLW9GKzH5CMGqCDhWjhZqg/132","nickname":"戒酒的李白","note":"","ucode":"744E1A22761647","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2106663,"avatar":"https://static001.geekbang.org/account/avatar/00/20/25/27/0076d304.jpg","nickname":"帽子狗","note":"","ucode":"51596F366AF068","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561895,"discussion_content":"是这样的，好久不见也没有说错。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649739949,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":329035,"ip_address":""},"score":561895,"extra":""}]}]},{"had_liked":false,"id":100589,"user_name":"giserway","can_delete":false,"product_type":"c1","uid":1067304,"ip_address":"","ucode":"139D579F323383","user_header":"https://static001.geekbang.org/account/avatar/00/10/49/28/4dcfa376.jpg","comment_is_top":false,"comment_ctime":1559602327,"is_pvip":true,"replies":[{"id":"36250","content":"回答非常到位","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1559610532,"ip_address":"","comment_id":100589,"utype":1}],"discussion_count":4,"race_medal":0,"score":"224897901719","product_id":100028001,"comment_content":"1）通过将 Key 的 hash 值与 length-1 进行 &amp; 运算，实现了当前 Key 的定位，2 的幂次方可以减少冲突（碰撞）的次数，提高 HashMap 查询效率；<br>2）如果 length 为 2 的次幂，则 length-1  转化为二进制必定是 11111…… 的形式，在于 h 的二进制与操作效率会非常的快，而且空间不浪费；如果 length 不是 2 的次幂，比如 length 为 15，则 length-1 为 14，对应的二进制为 1110，在于 h 与操作，最后一位都为 0，而 0001，0011，0101，1001，1011，0111，1101 这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！这样就会造成空间的浪费。","like_count":53,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452612,"discussion_content":"回答非常到位","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559610532,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1017377,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/86/21/4ef1a2d5.jpg","nickname":"非晚","note":"","ucode":"997B9A82DDDB8C","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349180,"discussion_content":"通透","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612951145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1186971,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/sBdBCczeAia0ZdJ0jqUC4bUv6lpRo2sleTib6M7Mia6d6JrdUfSHATpHWspqGeyibKgvKPcK0Q2pABw7VMaZNRK4CQ/132","nickname":"macco","note":"","ucode":"502B3CCF12A096","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318423,"discussion_content":"太赞了,上面的没看懂,你这解释就明白了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603728311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1214582,"avatar":"https://static001.geekbang.org/account/avatar/00/12/88/76/c69b7fe5.jpg","nickname":"youngitachi","note":"","ucode":"88717CA8B8ED64","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3309,"discussion_content":"赞一个，用实例说话，太具有说服力了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564392170,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140178,"user_name":"Sdylan","can_delete":false,"product_type":"c1","uid":1008503,"ip_address":"","ucode":"4589D0D0FA9275","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/77/423345ab.jpg","comment_is_top":false,"comment_ctime":1570844645,"is_pvip":false,"replies":[{"id":"54267","content":"加载因子过高，虽然提高了空间的利用率，但增加了查询时间的成本；加载因子过低，虽然减少查询时间的成本，但是空间利用率又很低了。所以0.75是一个折中的选择。<br>链表长度为8转为红黑树的原因是，官方根据泊松分布实验发现，假设hashmap长度length为16，假设放入12（0.75*16）个数据到hashmap中，链表中存放8个节点的概率仅为0.00000006，而链表中存放1~7节点的概率为：<br><br>0: 0.60653066<br><br>1: 0.30326533<br><br>2: 0.07581633<br><br>3: 0.01263606<br><br>4: 0.00157952<br><br>5: 0.00015795<br><br>6: 0.00001316<br><br>7: 0.00000094<br><br>从以上可知，实际上一个链表被放满8个节点的概率非常小，实际上链表转红黑树是非常耗性能的，而链表在8个节点以内的平均查询时间复杂度与黑红树相差无几，超过8个节点，黑红树的查询复杂度会好一些。所以，当链表的节点大于等于8个的时候，转为红黑树的性价比比较合适。<br>","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1570952803,"ip_address":"","comment_id":140178,"utype":1}],"discussion_count":4,"race_medal":0,"score":"156189667301","product_id":100028001,"comment_content":"装载因子0.75是怎么算出来了，是经验值还是什么？ 另外为什么链表长度8就要转红黑树呢","like_count":37,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470283,"discussion_content":"加载因子过高，虽然提高了空间的利用率，但增加了查询时间的成本；加载因子过低，虽然减少查询时间的成本，但是空间利用率又很低了。所以0.75是一个折中的选择。\n链表长度为8转为红黑树的原因是，官方根据泊松分布实验发现，假设hashmap长度length为16，假设放入12（0.75*16）个数据到hashmap中，链表中存放8个节点的概率仅为0.00000006，而链表中存放1~7节点的概率为：\n\n0: 0.60653066\n\n1: 0.30326533\n\n2: 0.07581633\n\n3: 0.01263606\n\n4: 0.00157952\n\n5: 0.00015795\n\n6: 0.00001316\n\n7: 0.00000094\n\n从以上可知，实际上一个链表被放满8个节点的概率非常小，实际上链表转红黑树是非常耗性能的，而链表在8个节点以内的平均查询时间复杂度与黑红树相差无几，超过8个节点，黑红树的查询复杂度会好一些。所以，当链表的节点大于等于8个的时候，转为红黑树的性价比比较合适。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570952803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1261959,"avatar":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","nickname":"Better me","note":"","ucode":"CADF08D357489A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386498,"discussion_content":"计算threshold的时候是通过size*0.75，可以考虑优化为size-（size>>2）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627615428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1397872,"avatar":"https://static001.geekbang.org/account/avatar/00/15/54/70/bc8f1824.jpg","nickname":"哈哈","note":"","ucode":"BA32EA6844F201","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372154,"discussion_content":"0.75怎么就是折中了呢，解释还是不够有说服力","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620214721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1133926,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4d/66/28742ad4.jpg","nickname":"水浴清风","note":"","ucode":"36EF5179E6F952","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327898,"discussion_content":"为什么可以用泊松分布来模拟插入的操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606013145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103170,"user_name":"嘉嘉☕","can_delete":false,"product_type":"c1","uid":1059771,"ip_address":"","ucode":"632A5CC4B53BB1","user_header":"https://static001.geekbang.org/account/avatar/00/10/2b/bb/5cf70df8.jpg","comment_is_top":false,"comment_ctime":1560389827,"is_pvip":false,"replies":[{"id":"37487","content":"加载因子是扩容的参考标准，如果加载因子越大，例如默认数组初始化大小为16，加载因子由0.75改成1.0，原来数组长度到了12就扩容，变成数组大小为16，也就是说被占满了，才会进行扩容，这也可能意味着已经发生了很多哈希冲突，这样导致某些数组中的链表长度增加，影响查询效率。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1560476887,"ip_address":"","comment_id":103170,"utype":1}],"discussion_count":3,"race_medal":0,"score":"126114441411","product_id":100028001,"comment_content":"加载因子那块儿，感觉有点跳跃，为什么加载因子越大，对空间利用越充分呢？","like_count":30,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453768,"discussion_content":"加载因子是扩容的参考标准，如果加载因子越大，例如默认数组初始化大小为16，加载因子由0.75改成1.0，原来数组长度到了12就扩容，变成数组大小为16，也就是说被占满了，才会进行扩容，这也可能意味着已经发生了很多哈希冲突，这样导致某些数组中的链表长度增加，影响查询效率。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560476887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1136420,"avatar":"https://static001.geekbang.org/account/avatar/00/11/57/24/2d942948.jpg","nickname":"Eaglet","note":"","ucode":"AC20EDC1204860","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3132,"discussion_content":"老师这段话，我读了五遍才理解其义。加载因子是扩容的参考标准（threshold =  capacity*loadfactor）默认数组初始大小为16，在加载因子为0.75（默认值）时，在数组长度（size）达到12就扩容，反之，如果把加载因子放大，到1，那么 threshold 就变成16，意味着，在数组长度达到16才会扩容，这时候也许已经产生很多哈希冲突了，导致某些链表过长，影响查询效率。这时候用时间换了空间！","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1564211065,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2664121,"avatar":"https://static001.geekbang.org/account/avatar/00/28/a6/b9/6bdaf8ce.jpg","nickname":"rich_li","note":"","ucode":"B82495DDC942DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":397762,"discussion_content":"加载因子越大，能装的东西就越多咯，但查询就会变慢，就是以时间换空间咯。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632667233,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":100676,"user_name":"大虫子","can_delete":false,"product_type":"c1","uid":1107044,"ip_address":"","ucode":"2B8C2F29F0AD40","user_header":"https://static001.geekbang.org/account/avatar/00/10/e4/64/6e458806.jpg","comment_is_top":false,"comment_ctime":1559614771,"is_pvip":false,"replies":[{"id":"36420","content":"你好，JDK1.7是考虑新增数据大多数是热点数据，所以考虑放在链表头位置，也就是数组中，这样可以提高查询效率，但这种方式会出现插入数据是逆序的。在JDK1.8开始hashmap链表在节点长度达到8之后会变成红黑树，这样一来在数组后节点长度不断增加时，遍历一次的次数就会少很多，相比头插法而言，尾插法操作额外的遍历消耗已经小很多了。<br><br>也有很多人说避免多线程情况下hashmap扩容时的死循环问题，我个人觉得避免死循环的关键不在尾插法的改变，而是扩容时，用了首尾两个指针来避免死循环。这个我会在后面的多线程中讲到hashmap扩容导致死循环的问题。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1559703416,"ip_address":"","comment_id":100676,"utype":1}],"discussion_count":4,"race_medal":0,"score":"126113666355","product_id":100028001,"comment_content":"老师您好，能解答下，为什么JDK1.8之前，链表元素增加采用的是头插法，1.8之后改成尾插法了。1.8之前采用头插法是基于什么设计思路呢？","like_count":30,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452632,"discussion_content":"你好，JDK1.7是考虑新增数据大多数是热点数据，所以考虑放在链表头位置，也就是数组中，这样可以提高查询效率，但这种方式会出现插入数据是逆序的。在JDK1.8开始hashmap链表在节点长度达到8之后会变成红黑树，这样一来在数组后节点长度不断增加时，遍历一次的次数就会少很多，相比头插法而言，尾插法操作额外的遍历消耗已经小很多了。\n\n也有很多人说避免多线程情况下hashmap扩容时的死循环问题，我个人觉得避免死循环的关键不在尾插法的改变，而是扩容时，用了首尾两个指针来避免死循环。这个我会在后面的多线程中讲到hashmap扩容导致死循环的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559703416,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1007753,"avatar":"","nickname":"suke","note":"","ucode":"C0287C31A4F45B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287667,"discussion_content":"老师，我在多线程部分没有看到对于hashmap扩容导致死循环问题的讲解","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1593505648,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1500391,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e4/e7/31944ee7.jpg","nickname":"千军万马万马@","note":"","ucode":"0BDAD22123435A","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":1007753,"avatar":"","nickname":"suke","note":"","ucode":"C0287C31A4F45B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287860,"discussion_content":"我也是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593570182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":287667,"ip_address":""},"score":287860,"extra":""}]},{"author":{"id":1024294,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","nickname":"null","note":"","ucode":"F9039EFED6B55D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368366,"discussion_content":"好像并没有回答为什么改用尾插。(避免死循环不在尾插的改变，所以感觉没回复题主的问题。)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618670529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":100997,"user_name":"孙志强","can_delete":false,"product_type":"c1","uid":1325997,"ip_address":"","ucode":"9C070F1E4EC6FF","user_header":"https://static001.geekbang.org/account/avatar/00/14/3b/ad/31193b83.jpg","comment_is_top":false,"comment_ctime":1559699184,"is_pvip":true,"replies":[{"id":"36485","content":"对的，有这样一个条件。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1559779893,"ip_address":"","comment_id":100997,"utype":1}],"discussion_count":1,"race_medal":0,"score":"87459045104","product_id":100028001,"comment_content":"以前看源码，我记得好像链表转换红黑树不光链表元素大于8个，好像还有一个表的大小大于64","like_count":21,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452770,"discussion_content":"对的，有这样一个条件。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559779893,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101017,"user_name":"小小征","can_delete":false,"product_type":"c1","uid":1358930,"ip_address":"","ucode":"335380EFE0FC61","user_header":"https://static001.geekbang.org/account/avatar/00/14/bc/52/52745d32.jpg","comment_is_top":false,"comment_ctime":1559701518,"is_pvip":false,"replies":[{"id":"36531","content":"以下是resize中判断是否位移的部分代码，我们可以看到元素的hash值与原数组容量运算，如果运算结果为0，保持原位，如果运算结果为1，则意向扩容的高位。<br><br>\t\tif ((e.hash &amp; oldCap) == 0) {<br>                             if (loTail == null)<br>                                 loHead = e;<br>                             else<br>                                 loTail.next = e;<br>                             loTail = e;<br>                         }<br>                         else {<br>                             if (hiTail == null)<br>                                 hiHead = e;<br>                             else<br>                                 hiTail.next = e;<br>                             hiTail = e;<br>                         }<br><br>假设链表中有4、8、12，他们的二进制位00000100、00001000、00001100，而原来数组容量为4，则是 00000100，以下与运算：<br><br>00000100 &amp; 00000100 = 0 保持原位<br>00001000 &amp; 00000100 = 1 移动到高位<br>00001100 &amp; 00000100 = 1 移动到高位","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1559786704,"ip_address":"","comment_id":101017,"utype":1}],"discussion_count":10,"race_medal":0,"score":"53099309070","product_id":100028001,"comment_content":"0 的话索引不变，1 的话索引变成原索引加上扩容前数组。  这句有点不理解 老师","like_count":12,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452780,"discussion_content":"以下是resize中判断是否位移的部分代码，我们可以看到元素的hash值与原数组容量运算，如果运算结果为0，保持原位，如果运算结果为1，则意向扩容的高位。\n\n\t\tif ((e.hash &amp;amp; oldCap) == 0) {\n                             if (loTail == null)\n                                 loHead = e;\n                             else\n                                 loTail.next = e;\n                             loTail = e;\n                         }\n                         else {\n                             if (hiTail == null)\n                                 hiHead = e;\n                             else\n                                 hiTail.next = e;\n                             hiTail = e;\n                         }\n\n假设链表中有4、8、12，他们的二进制位00000100、00001000、00001100，而原来数组容量为4，则是 00000100，以下与运算：\n\n00000100 &amp;amp; 00000100 = 0 保持原位\n00001000 &amp;amp; 00000100 = 1 移动到高位\n00001100 &amp;amp; 00000100 = 1 移动到高位","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559786704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1024294,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","nickname":"null","note":"","ucode":"F9039EFED6B55D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368383,"discussion_content":"00000100 &amp; 00000100 = 0 保持原位\n00001000 &amp; 00000100 = 1 移动到高位\n00001100 &amp; 00000100 = 1 移动到高位\n\n------\n\n很明显结论有问题，当数组大小由 4 扩充到 8。元素 8 的位置不变，元素 4 和元素 12 都要移动。\n源码if ((e.hash &amp; oldCap) == 0) 是等于0，else 分支是不等于0的逻辑。\n\n学习了这么多篇文章，不论是文章内容，还是回复各位同学的问题，老师有一些结论，多多少少都会有瑕疵，让人产生疑问。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1618672078,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1023750,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9f/06/287d77dd.jpg","nickname":"承香墨影","note":"","ucode":"4D6A4D6E1ED29F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24317,"discussion_content":"0 的话索引不变，1 的话索引变成原索引加上扩容前数组。\n------\n修改成 「0 的话索引不变，1 的话索引变成原索引加上扩容前数组的长度。」，应该就没有歧义了。\n因为每次是成倍的扩容，旧的数组是 16 索引是 8，新的数组就是 32，如果是 1 的话，需要将旧索引 8 加上扩容的尺寸 16，就得出了新的索引 24。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1570093638,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1442437,"avatar":"https://static001.geekbang.org/account/avatar/00/16/02/85/9a81a973.jpg","nickname":"ZHANG","note":"","ucode":"BAFD110AE33328","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":117197,"discussion_content":"老师，那这儿描述是不是不准确呢:“在扩容中只用判断原来的 hash 值和左移动的一位（newtable 的值）按位与操作是 0 或 1 就行，0 的话索引不变，1 的话索引变成原索引加上扩容前数组。”，应该是和旧数组的值按位与，不是新数组","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1578101555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1298722,"avatar":"https://static001.geekbang.org/account/avatar/00/13/d1/22/706c492e.jpg","nickname":"Algoric","note":"","ucode":"78D9850A88C254","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":112226,"discussion_content":"“而 hash 按位与上 newTable 得到的 0（扩容前的索引位置）和 1（扩容前索引位置加上扩容前数组长度的数值索引处”这里是不是有问题，应该是hash按位和原数组长度做与运算，不是newTable?","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577845631,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1462843,"avatar":"https://static001.geekbang.org/account/avatar/00/16/52/3b/f1501d79.jpg","nickname":"不工","note":"","ucode":"A8725E6D0E1765","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298965,"discussion_content":"4 &amp; 4 == 0？ 不是4吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597493374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1652750,"avatar":"https://static001.geekbang.org/account/avatar/00/19/38/0e/aa52eb1e.jpg","nickname":"💗妳在我安👣","note":"","ucode":"507FC3D843DB79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":159576,"discussion_content":"这个运算结果应该是  001吧\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580709134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1343671,"avatar":"","nickname":"Geek_bd613f","note":"","ucode":"69740C1D0FC15B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":36267,"discussion_content":"例子中与的第二个操作数应该是00001000，扩容后的长度，低位为0，屏蔽了之前索引的变化。1表示是新加入节点，0表示原来的索引？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571357601,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1138007,"avatar":"https://static001.geekbang.org/account/avatar/00/11/5d/57/82f1a3d4.jpg","nickname":"吾爱有三","note":"","ucode":"FC5B32E36CE249","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1674,"discussion_content":"这个与运算结果不应该是1，0，0 吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562808423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1014665,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/89/34f2cbcc.jpg","nickname":"杨宇","note":"","ucode":"EB74DF6E269F03","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1138007,"avatar":"https://static001.geekbang.org/account/avatar/00/11/5d/57/82f1a3d4.jpg","nickname":"吾爱有三","note":"","ucode":"FC5B32E36CE249","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6913,"discussion_content":"运算结果是：非零，零，非零","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1567171518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":1674,"ip_address":""},"score":6913,"extra":""}]}]},{"had_liked":false,"id":100877,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1559660895,"is_pvip":false,"replies":[{"id":"36399","content":"<br><br>面试的时候，问到时间复杂度，大部分是考察你对数据结构的了解程度。建议可以多复习下数据结构的知识。<br><br>hashmap的最优时间复杂度是O（1），而最坏时间复杂度是O(n)。<br><br>在没有产生hash冲突的情况下，查询和插入的时间复杂度是O(1)；<br><br>而产生hash冲突的情况下，如果是最终插入到链表，链表的插入时间复杂度为O(1)，而查询的时候，时间复杂度为O(n)；<br><br>在产生hash冲突的情况下，如果最终插入的是红黑树，插入和查询的平均时间复杂度是O（logn）。<br><br>而TreeMap是基于红黑树实现的，所以时间复杂度你也清楚了吧。<br><br>","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1559698427,"ip_address":"","comment_id":100877,"utype":1}],"discussion_count":2,"race_medal":0,"score":"44509333855","product_id":100028001,"comment_content":"老师好。hashmap的put和get的时间复杂度算多少啊?最好O(1)。最坏复杂度是O(log(n))平均是O(1)么?。。。treeMap的,treeMap，putO(n)，getO(1)?之前面试被问了，不晓得哪错了","like_count":11,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452713,"discussion_content":"\n\n面试的时候，问到时间复杂度，大部分是考察你对数据结构的了解程度。建议可以多复习下数据结构的知识。\n\nhashmap的最优时间复杂度是O（1），而最坏时间复杂度是O(n)。\n\n在没有产生hash冲突的情况下，查询和插入的时间复杂度是O(1)；\n\n而产生hash冲突的情况下，如果是最终插入到链表，链表的插入时间复杂度为O(1)，而查询的时候，时间复杂度为O(n)；\n\n在产生hash冲突的情况下，如果最终插入的是红黑树，插入和查询的平均时间复杂度是O（logn）。\n\n而TreeMap是基于红黑树实现的，所以时间复杂度你也清楚了吧。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559698427,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1210699,"avatar":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","nickname":"-W.LI-","note":"","ucode":"3556786538664F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8335,"discussion_content":"老师冲突的时候虽然队尾插入，可是先要判断是否相等还是O(n)吧?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567925071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101170,"user_name":"Chocolate","can_delete":false,"product_type":"c1","uid":1013822,"ip_address":"","ucode":"242CF0E3C10E97","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/3e/c39d86f1.jpg","comment_is_top":false,"comment_ctime":1559733611,"is_pvip":false,"replies":[{"id":"57888","content":"这种数据倾斜的可能性比较小","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1573557796,"ip_address":"","comment_id":101170,"utype":1}],"discussion_count":2,"race_medal":0,"score":"31624504683","product_id":100028001,"comment_content":"老师，您好，请教一个问题，为什么 HashMap 的容量等于数组长度？但是扩容的时候却是根据 Map 里的所有元素总数去扩容，这样会不会导致数组中的某一个 node 有很长的链表或红黑树，数组中的其他位置都没有元素？谢谢","like_count":8,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452833,"discussion_content":"这种数据倾斜的可能性比较小","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573557796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1124948,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2a/54/c9990105.jpg","nickname":"bro.","note":"","ucode":"D65283CD869804","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1650,"discussion_content":"不是，首先一个好的hash算法就是需要元素尽可能均匀分布，如果冲突过多，算法就要替换了！再次不是根据map里的总数扩容，只是根据设置初始值乘以加载因子跟map里的总数比较，假如初始默认值16*默认加载因子0.75=12如果此时map数据等于12我们就要开始扩容数组长度为32了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562765328,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101117,"user_name":"晓杰","can_delete":false,"product_type":"c1","uid":1441546,"ip_address":"","ucode":"1174C88EEBF8A6","user_header":"https://static001.geekbang.org/account/avatar/00/15/ff/0a/12faa44e.jpg","comment_is_top":false,"comment_ctime":1559720448,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23034556928","product_id":100028001,"comment_content":"初始容量2的n次方是偶数，在计算key的索引位置时，是通过(n-1)&amp;hash计算的，这样n-1得到的奇数，那么通过在进行与操作时，如果hash的第一位是0，那么(n-1)&amp;hash得到的是偶数，如果hash的第一位是1，那么(n-1)&amp;hash得到的是奇数，因此可以让数据分布更加均匀，减少hash冲突，相反如果n-1是偶数，那无论hash的第一位是偶数还是奇数，(n-1)&amp;hash得到的都是偶数，不利于数据的分布","like_count":5},{"had_liked":false,"id":100677,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1559614933,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18739484117","product_id":100028001,"comment_content":"一下子追到最新了。老师集合这块讲得是真不错。弱弱补个小点。空集合或空map返回不要new，走常量不可变集合或map。尽量减少对象的创建。毕竟创建和回收都是有开销的。","like_count":5},{"had_liked":false,"id":178819,"user_name":"M.c","can_delete":false,"product_type":"c1","uid":1332814,"ip_address":"","ucode":"57F662CF4B5986","user_header":"https://static001.geekbang.org/account/avatar/00/14/56/4e/60e50534.jpg","comment_is_top":false,"comment_ctime":1581835385,"is_pvip":false,"replies":[{"id":"70522","content":"是的，在源码中可以查到对于的代码，链表长度大于8而且整个map中的键值对大于等于MIN_TREEIFY_CAPACITY (64)时，才进行链表到红黑树的转换。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1582722109,"ip_address":"","comment_id":178819,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14466737273","product_id":100028001,"comment_content":"“这是因为链表的长度超过 8 后，红黑树的查询效率要比链表高，所以当链表超过 8 时，HashMap 就会将链表转换为红黑树”，此处转换为红黑树少了个条件吧？MIN_TREEIFY_CAPACITY要同时大于64","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483979,"discussion_content":"是的，在源码中可以查到对于的代码，链表长度大于8而且整个map中的键值对大于等于MIN_TREEIFY_CAPACITY (64)时，才进行链表到红黑树的转换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582722109,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126865,"user_name":"大俊stan","can_delete":false,"product_type":"c1","uid":1125370,"ip_address":"","ucode":"BD0CB5FC790DDB","user_header":"https://static001.geekbang.org/account/avatar/00/11/2b/fa/1cde88d4.jpg","comment_is_top":false,"comment_ctime":1566499541,"is_pvip":false,"replies":[{"id":"50386","content":"好的，收到建议","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1567945209,"ip_address":"","comment_id":126865,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14451401429","product_id":100028001,"comment_content":"作者如果把扩容的源码贴出来，可能更好理解是如何扩容，以及为什么多线程hashmap会产生闭环","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464210,"discussion_content":"好的，收到建议","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567945209,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":102100,"user_name":"bro.","can_delete":false,"product_type":"c1","uid":1124948,"ip_address":"","ucode":"D65283CD869804","user_header":"https://static001.geekbang.org/account/avatar/00/11/2a/54/c9990105.jpg","comment_is_top":false,"comment_ctime":1560136215,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14445038103","product_id":100028001,"comment_content":"编程中有遇到这种情况,当判断一个数n 是否为偶数使用n%2 == 0 ,计算机语言已经做了优化为 n&amp;(2-1) = n &amp; 1 == 0,对于二进制来说与操作只需要一个电路即可完成比取余速度快多了,相同的对于hash扩容,只需要判断前一位hash值是0还是1,如果是0保持数组位置不变,如果为1增加原来扩容前数组长度即可,而且由于hash值计算每一位都是平均分配0或者1,所以保持均匀分布","like_count":3},{"had_liked":false,"id":100681,"user_name":"WolvesLeader","can_delete":false,"product_type":"c1","uid":1103839,"ip_address":"","ucode":"33610E19CA2E96","user_header":"https://static001.geekbang.org/account/avatar/00/10/d7/df/fc0a6709.jpg","comment_is_top":false,"comment_ctime":1559615819,"is_pvip":false,"replies":[{"id":"36421","content":"你好，这个在后面多线程中会讲到，可以留意关注下。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1559703550,"ip_address":"","comment_id":100681,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14444517707","product_id":100028001,"comment_content":"hashmap在多线程情况下数据丢失，大师，能不能分析分析原因","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452633,"discussion_content":"你好，这个在后面多线程中会讲到，可以留意关注下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559703550,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":100601,"user_name":"陆劲","can_delete":false,"product_type":"c1","uid":1439466,"ip_address":"","ucode":"833B47688ED00C","user_header":"https://static001.geekbang.org/account/avatar/00/15/f6/ea/9b41ce10.jpg","comment_is_top":false,"comment_ctime":1559605151,"is_pvip":false,"replies":[{"id":"36247","content":"哈希表在面试中是出现较频繁的，不仅因为它在平时工作中用的比较多，还由于它优秀的设计和优化思想。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1559610188,"ip_address":"","comment_id":100601,"utype":1}],"discussion_count":1,"race_medal":1,"score":"14444507039","product_id":100028001,"comment_content":"要是早一天发这个就好了，昨天面试被问到哈希函数给问懵了。老师很棒！这几乎是我在极客跟的最紧的课。","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452613,"discussion_content":"哈希表在面试中是出现较频繁的，不仅因为它在平时工作中用的比较多，还由于它优秀的设计和优化思想。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559610188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":234542,"user_name":"小白","can_delete":false,"product_type":"c1","uid":2062471,"ip_address":"","ucode":"0DA92147F3B7EE","user_header":"","comment_is_top":false,"comment_ctime":1594716765,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10184651357","product_id":100028001,"comment_content":"老师你好，请教一个问题。HashMap 长度等于数组长度吗？ 那么它的链表下面存的那些还算吗？ 如果下标为1的位置下挂了 3个node ？ 那么它的数组长度还是16 吗？  还是 13 ？","like_count":2,"discussions":[{"author":{"id":1139413,"avatar":"https://static001.geekbang.org/account/avatar/00/11/62/d5/1f5c5ab6.jpg","nickname":"大大大熊myeh","note":"","ucode":"4832C2E7CEB151","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338540,"discussion_content":"当然是16，HashMap的长度是调用了size()方法，size()方法返回的HashMap#size属性，在每次put一个新键值对的时候，size属性都会+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609308673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108208,"user_name":"luzero","can_delete":false,"product_type":"c1","uid":1359123,"ip_address":"","ucode":"B1BACA0CE8163C","user_header":"https://static001.geekbang.org/account/avatar/00/14/bd/13/6424f528.jpg","comment_is_top":false,"comment_ctime":1561697629,"is_pvip":false,"replies":[{"id":"39350","content":"理解正确，赞","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561862377,"ip_address":"","comment_id":108208,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10151632221","product_id":100028001,"comment_content":"使用2的次幂是因为进行&amp;运算的时候，每次都能落到tables数组内，并且2的次幂进行&amp;运算和直接模运算（%）的值是一样的，也就是说（n-1）&amp;hash==hash%n，如果直接使用（%）模运算最终也会转换成二进制的去计算性能不如&amp;运算，还有就是&amp;计算分布均匀，减少哈希冲突，如果是2的次幂,假设n=16，（16-1）&amp;0==0、（16-1）&amp;1==1、16-1)&amp;2==2、........、（16-1)&amp;19==3、（16-1)&amp;20==4、（16-1)&amp;21==5、。如果不是2的次幂的话，假设是n=15，（15-1）&amp;1==0、（15-1）&amp;1==2、（15-1)&amp;3==2、......、（15-1)&amp;4==4、（15-1)&amp;5==4.    哈哈、不知道我回答的沾不沾边？望老师您点评一下哈","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455871,"discussion_content":"理解正确，赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561862377,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":100946,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1559694183,"is_pvip":false,"replies":[{"id":"36394","content":"HashMap的扩容是一次性完成的。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1559697578,"ip_address":"","comment_id":100946,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10149628775","product_id":100028001,"comment_content":"Hash字典发生扩容时，需要复制元素，请问这个过程是一次完成的吗？redis里的字典是准备了两个字典，一个原始字典，一个rehash字典，扩容后，不是一次完成数据迁移的，每次操作字典都考虑两个数组并复制数据，扩容完毕后交换两个数组指针<br>","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452750,"discussion_content":"HashMap的扩容是一次性完成的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559697578,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":100829,"user_name":"曾泽伟","can_delete":false,"product_type":"c1","uid":1106117,"ip_address":"","ucode":"E8C7C256BA4D84","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/c5/0a727162.jpg","comment_is_top":false,"comment_ctime":1559648718,"is_pvip":false,"replies":[{"id":"36413","content":"我们知道再hash也是放在数组上的，这样比放在链表或红黑树上来说，查询性能是会提升的，一个简单的hash计算的速度远远要比遍历链表或红黑树要快。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1559699133,"ip_address":"","comment_id":100829,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10149583310","product_id":100028001,"comment_content":"再哈希--如果我们不考虑添加元素的时间成本，且对查询元素的要求极高，就可以使用此法<br>我没太明白，为什么再哈希会提高查询？如果再哈希了，我第一次哈希的位置没查到，得再次哈希查找位置，如果还没有又要再哈希，循环往复，感觉查询性能并不高啊，老师能解释一下吗？","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452696,"discussion_content":"我们知道再hash也是放在数组上的，这样比放在链表或红黑树上来说，查询性能是会提升的，一个简单的hash计算的速度远远要比遍历链表或红黑树要快。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559699133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":100656,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":false,"comment_ctime":1559611534,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10149546126","product_id":100028001,"comment_content":"因为选择下标和扩容的时候都依赖和(n-1）按位与，2的幂次方满足n-1都是1的情况，因此必须选择2的幂次方，且如果使用时传入的参数不是2的幂次方，HashMap会自动转成大于传入参数的最小的2的幂次方来确保下标和扩容机制的正常运行","like_count":2},{"had_liked":false,"id":148066,"user_name":"suke","can_delete":false,"product_type":"c1","uid":1007753,"ip_address":"","ucode":"C0287C31A4F45B","user_header":"","comment_is_top":false,"comment_ctime":1572935695,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5867902991","product_id":100028001,"comment_content":"内容讲的很跳跃,factor和threshold怎么参与计算的也不说,这思路一点也不严谨啊,付费内容能不能有点耐心","like_count":1,"discussions":[{"author":{"id":1212902,"avatar":"https://static001.geekbang.org/account/avatar/00/12/81/e6/6cafed37.jpg","nickname":"旅途","note":"","ucode":"5022477E8E9441","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301052,"discussion_content":"？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598372880,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":111426,"user_name":"吾爱有三","can_delete":false,"product_type":"c1","uid":1138007,"ip_address":"","ucode":"FC5B32E36CE249","user_header":"https://static001.geekbang.org/account/avatar/00/11/5d/57/82f1a3d4.jpg","comment_is_top":false,"comment_ctime":1562556622,"is_pvip":false,"replies":[{"id":"40612","content":"因为存在线程安全性问题，例如put数据丢失，size()最终的数据不对等等。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562574356,"ip_address":"","comment_id":111426,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5857523918","product_id":100028001,"comment_content":"老师您好，1.8中hashmap解决了并发场景的死循环，那么为什么在高并发还是不建议使用hashmap？","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457350,"discussion_content":"因为存在线程安全性问题，例如put数据丢失，size()最终的数据不对等等。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562574356,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104777,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1560834158,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"5855801454","product_id":100028001,"comment_content":"static int indexFor(int h, int length) { <br>        return h &amp; (length-1);<br> }<br>我们知道对于HashMap的table而言，数据分布需要均匀（最好每项都只有一个元素，这样就可以直接找到），不能太紧也不能太松，太紧会导致查询速度慢，太松则浪费空间。计算hash值后，怎么才能保证table元素分布均与呢？我们会想到取模，但是由于取模的消耗较大，HashMap是这样处理的：调用indexFor方法。<br>HashMap源码中有一个indexFor方法，返回的是key的hashcode跟初始容量-1做与运算。<br><br>首先length为2的整数次幂的话，h&amp;(length-1)就相当于对length取模，这样便保证了散列的均匀，同时也提升了效率；<br><br>其次，length为2的整数次幂的话，为偶数。这样length-1为奇数，奇数的最后一位为1，这样便保证了h&amp;(length-1)的最后一位为0，也可能为1（这取决于h的值），即与后的结果可能为偶数也可能是奇数。这样便可以保证散列的均匀性，<br><br>而如果length为奇数的话，很明显length-1为偶数，它的最后一位是0，这样h&amp;(length-1)的最后一位肯定为0，即只能为偶数，这样任何hash值都只会被散列到数组的偶数下标位置上，这便浪费了近一半的空间。所以，length取2的整数次幂，是为了使不同hash值发生碰撞的概率较小，这样就能使元素在哈希表中均匀地散列。<br>--------------------- <br>作者：每天晒白牙 <br>来源：CSDN <br>原文：https:&#47;&#47;blog.csdn.net&#47;dam454450872&#47;article&#47;details&#47;80376661 <br>版权声明：本文为博主原创文章，转载请附上博文链接！","like_count":1},{"had_liked":false,"id":102959,"user_name":"Fever","can_delete":false,"product_type":"c1","uid":1263997,"ip_address":"","ucode":"2595F13BC3ECAB","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/7d/7b9fd831.jpg","comment_is_top":false,"comment_ctime":1560336117,"is_pvip":false,"replies":[{"id":"37664","content":"是的，描述不清楚，感谢提醒。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1560652872,"ip_address":"","comment_id":102959,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5855303413","product_id":100028001,"comment_content":"Hash冲突，那么可以把 key 存放到冲突位置的空位置上去，这里是不是写错了，应该是冲突位置后面的空位置吧？<br>","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453666,"discussion_content":"是的，描述不清楚，感谢提醒。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560652872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":102203,"user_name":"jimmy","can_delete":false,"product_type":"c1","uid":1043178,"ip_address":"","ucode":"566EE76C509026","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/8ibhsSDmHmichVKzxW6vN6Ln2sy8ibOcG8O8akwPDnia98cqLwO29qk4mUqNScwMSlVgOAlgUNw0YnbyosjIJGAibIg/132","comment_is_top":false,"comment_ctime":1560159814,"is_pvip":false,"replies":[{"id":"36872","content":"这是兼容链表查询和转红黑树两者性能一起考虑的，这个值经过不是绝对的最佳值，是基于大数据求得比较合适的阈值。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1560174333,"ip_address":"","comment_id":102203,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5855127110","product_id":100028001,"comment_content":"请问下为什么链表转换成红黑树的阈值是8？","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453293,"discussion_content":"这是兼容链表查询和转红黑树两者性能一起考虑的，这个值经过不是绝对的最佳值，是基于大数据求得比较合适的阈值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560174333,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101220,"user_name":"迎风劲草","can_delete":false,"product_type":"c1","uid":1511787,"ip_address":"","ucode":"66EDA6C0B12A44","user_header":"https://static001.geekbang.org/account/avatar/00/17/11/6b/8034959a.jpg","comment_is_top":false,"comment_ctime":1559743882,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"5854711178","product_id":100028001,"comment_content":"主要是为了减少hash冲突，hash &amp; (n-1)  n为2的n次幂，n-1换成比特位都是1","like_count":1},{"had_liked":false,"id":100855,"user_name":"强哥","can_delete":false,"product_type":"c1","uid":1206726,"ip_address":"","ucode":"3B8DC780FE4EF9","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/c6/513df085.jpg","comment_is_top":false,"comment_ctime":1559655750,"is_pvip":false,"replies":[{"id":"36382","content":"用与运算是提高了运算性能，而容量大小为2的幂次方是为了降低哈希冲突。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1559694617,"ip_address":"","comment_id":100855,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5854623046","product_id":100028001,"comment_content":"最主要的原因是位运算替代%取模操作，提高运算性能，说什么降低冲突的，是否比较过质数和偶数冲突概率呢？","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452708,"discussion_content":"用与运算是提高了运算性能，而容量大小为2的幂次方是为了降低哈希冲突。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559694617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":268365,"user_name":"Geek_964b0f","can_delete":false,"product_type":"c1","uid":2295031,"ip_address":"","ucode":"D6AEDAEF609020","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/sQV132p5s2Nicia1wJPiafJtMP5ic0kwpzntdkibInNScCeic0ZvDE7y90nCM7rGDaZ2DiaRlYjhoplOpJVGlbibkToAPg/132","comment_is_top":false,"comment_ctime":1608169324,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608169324","product_id":100028001,"comment_content":"hashMap中计算索引时使用（n-1)&amp;hash，当n为2的幂次方时，n-1的二进制数为*111的形式，能更好的减少哈希冲突，jdk8中有对初始容量设置为2的幂次方的操作，例如输入9，会将其转化为16","like_count":0},{"had_liked":false,"id":262202,"user_name":"Geek_a8b86d","can_delete":false,"product_type":"c1","uid":2295705,"ip_address":"","ucode":"EA320C749DB675","user_header":"","comment_is_top":false,"comment_ctime":1605663692,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1605663692","product_id":100028001,"comment_content":"例如：hash=15，n=16 时，结果为 15；hash=17，n=16 时，结果为 1。这个是怎么算的？","like_count":0,"discussions":[{"author":{"id":2664121,"avatar":"https://static001.geekbang.org/account/avatar/00/28/a6/b9/6bdaf8ce.jpg","nickname":"rich_li","note":"","ucode":"B82495DDC942DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":397764,"discussion_content":"额，&amp;运算中1&amp;1=1,1&amp;0=0,0&amp;0=0。 （n-1）&amp; hash = 1111 &amp; 1111 = 1111 = 15;\n第二个，1111 &amp; 10001 = 00001 = 1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632667624,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244075,"user_name":"旅途","can_delete":false,"product_type":"c1","uid":1212902,"ip_address":"","ucode":"5022477E8E9441","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/e6/6cafed37.jpg","comment_is_top":false,"comment_ctime":1598374182,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598374182","product_id":100028001,"comment_content":"老师 对于使用2的幂次方减一然后与hash进行与的位运算这个我懂了,但是好像没理解透彻,假如十进制8 二进制1000 对hash使用位或（|）操作,这样效果一样吗","like_count":0},{"had_liked":false,"id":232307,"user_name":"😚 46","can_delete":false,"product_type":"c1","uid":1433535,"ip_address":"","ucode":"EED0EBBBF80A43","user_header":"https://static001.geekbang.org/account/avatar/00/15/df/bf/96b50d1e.jpg","comment_is_top":false,"comment_ctime":1593951528,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593951528","product_id":100028001,"comment_content":"在 HashMap 初始化时，threshold = 初始容量，默认是16。<br>当插入第一个元素后，会进入 resize 方法，此时 threshold = 容量 * 加载因子。 ","like_count":0},{"had_liked":false,"id":225708,"user_name":"瑶老板的小弟","can_delete":false,"product_type":"c1","uid":1438863,"ip_address":"","ucode":"EA6CDB3165227F","user_header":"https://static001.geekbang.org/account/avatar/00/15/f4/8f/6b3d4370.jpg","comment_is_top":false,"comment_ctime":1591838034,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591838034","product_id":100028001,"comment_content":"1.8优化，扩容时候链表尾节点插入，避免环链。","like_count":0},{"had_liked":false,"id":213272,"user_name":"GaGi","can_delete":false,"product_type":"c1","uid":1099053,"ip_address":"","ucode":"CC8D22E1DD8CA2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c5/2d/1eebfc3c.jpg","comment_is_top":false,"comment_ctime":1588347904,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588347904","product_id":100028001,"comment_content":"老师你好，文中说jdk1.8的扩容优化：“在扩容中只用判断原来的 hash 值和左移动的一位（newtable 的值）按位与操作是 0 或 1 就行”，<br>查看了1.8的源码，发现是hash&amp;oldCap，也就是说跟原本的数组长度进行比较","like_count":0},{"had_liked":false,"id":201468,"user_name":"其实还OK","can_delete":false,"product_type":"c1","uid":1909860,"ip_address":"","ucode":"394B4B7ECFBDCC","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/aEvdVcM1ESQUrsiaYdwAqhqcOfhZ9dxtEetUwm4tfhHbhRUspIyvrFjibQkicUL3N03e5pmSGTfz2OzZ7ibZMn4k2Q/132","comment_is_top":false,"comment_ctime":1585791920,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585791920","product_id":100028001,"comment_content":"如果每个元素的hash值都是唯一，特别是低位的最大程度不同时，初始容量设置为2的n次幂可以保持与运算后结果与元素的hash值低位一样，就可以达到最大程度的错开元素的存储","like_count":0},{"had_liked":false,"id":200685,"user_name":"赵玉闯","can_delete":false,"product_type":"c1","uid":1926759,"ip_address":"","ucode":"82E85AC08206EA","user_header":"","comment_is_top":false,"comment_ctime":1585637932,"is_pvip":false,"replies":[{"id":"75242","content":"是的，arraylist的扩容方式则是直接重新申请一个新的空间，将原来的数组中的元素复制过去","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1585741437,"ip_address":"","comment_id":200685,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585637932","product_id":100028001,"comment_content":"老师，我想问一下，如果数组扩容，是不是应该是基于原来数组尾部继续申请连续的内存空间，也就是原来的二倍，那如果基于原来数组的尾部没有连续的这么大的空间了，怎么办。会去一个新的地方申请原来的二倍空间，然后把这些数据都挪过去吗？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490101,"discussion_content":"是的，arraylist的扩容方式则是直接重新申请一个新的空间，将原来的数组中的元素复制过去","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585741437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164923,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1577112432,"is_pvip":false,"replies":[{"id":"62976","content":"1、只是一个首尾数据调换的过程；<br>2、后面补上，评论里面字数有限，无法将完整源码贴上。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1577187301,"ip_address":"","comment_id":164923,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1577112432","product_id":100028001,"comment_content":"很棒<br><br>1.就是被hashmap中链表的 头部 和 尾部搞晕了，老师，是数组里的元素是链表头部还是尾部啊？<br><br>2.扩容方法，呜呜呜… 有点想老师也能贴一下扩容源码分析。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478951,"discussion_content":"1、只是一个首尾数据调换的过程；\n2、后面补上，评论里面字数有限，无法将完整源码贴上。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577187301,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151434,"user_name":"FelixFly","can_delete":false,"product_type":"c1","uid":1160461,"ip_address":"","ucode":"1D39A7C3D0E31F","user_header":"https://static001.geekbang.org/account/avatar/00/11/b5/0d/0e65dee6.jpg","comment_is_top":false,"comment_ctime":1573718995,"is_pvip":true,"replies":[{"id":"58543","content":"第一种，加载因子考虑的更多的是扩容","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1573983293,"ip_address":"","comment_id":151434,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573718995","product_id":100028001,"comment_content":"老师，实际应用中，我们设置初始容量，一般得是 2 的整数次幂，这个HashMap在初始化容量的时候会重新计算，会重新计算为2 的整数次幂<br>我们设置初始容量的要考虑加载因子，设置的初始容量是预知数据量 &#47; 加载因子，假如预知容量是20，算出来的结果是26.6，这样设置的初始容量应该为27，但是计算出来的容量是32（也就是2的5次幂），也就是说这时候的默认边界值为32*0.75=24<br>还有另一种方法是设置加载因子改为1.0，预售容量是20，设置初始容量为20，加载因子为1.0，这样计算出来的容量是32，也就是说默认边界值是32<br>这两种方法在实际应用中哪种比较好点","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474472,"discussion_content":"第一种，加载因子考虑的更多的是扩容","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573983293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150268,"user_name":"雷小鸿","can_delete":false,"product_type":"c1","uid":1368897,"ip_address":"","ucode":"424DC9A532FFD7","user_header":"https://static001.geekbang.org/account/avatar/00/14/e3/41/bd0e3a04.jpg","comment_is_top":false,"comment_ctime":1573487435,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1573487435","product_id":100028001,"comment_content":"2次幂就是hash%length和(n一1)&amp;hash相等。用&amp;运算效率高。不是2次幂不保证和取余相等。就不会均匀分配。","like_count":0},{"had_liked":false,"id":143262,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1571658251,"is_pvip":false,"replies":[{"id":"56523","content":"扩容需要迁移数据，消耗性能","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1572520635,"ip_address":"","comment_id":143262,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571658251","product_id":100028001,"comment_content":"”这种方法存在着很多缺点，例如，查找、扩容等，所以我不建议你作为解决哈希冲突的首选。”<br><br>老师能否讲讲为什么扩容时候有缺点？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471452,"discussion_content":"扩容需要迁移数据，消耗性能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572520635,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138986,"user_name":"aof","can_delete":false,"product_type":"c1","uid":1062864,"ip_address":"","ucode":"5815D63C4926BC","user_header":"https://static001.geekbang.org/account/avatar/00/10/37/d0/26975fba.jpg","comment_is_top":false,"comment_ctime":1570523310,"is_pvip":false,"replies":[{"id":"54271","content":"因为将加载因子调大，填满的元素越多，空间利用率越高，但冲突的机会加大了","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1570955851,"ip_address":"","comment_id":138986,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1570523310","product_id":100028001,"comment_content":"老师，这句&quot;因此加载因子越大，对空间的利用就越充分，这就意味着链表的长度越长”，为什么加载因子越大链表长度越长？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469726,"discussion_content":"因为将加载因子调大，填满的元素越多，空间利用率越高，但冲突的机会加大了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570955851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131694,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1567851542,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567851542","product_id":100028001,"comment_content":"课后思考及问题<br>假设初始容量设置为4，4是2的幂次方，<br>4(十进制)=100(二进制)，100-1=011，假设是四个字节的整型数字，一个字节八位4*8=32位，则在前面再补29个0。则不管计算的哈希值是什么和011相与后，000&#47;001&#47;010&#47;011(前面还有29个0)这四种情况都是可能存在的，所以他们的位置是都能被占用的，当然上，如果数据超过四个就必然会发生多个数字落到同一个位置的情况啦！这就是哈希冲突啦！<br><br>再假设初始容量为5，<br>5(十进制)=101(二进制)，101-1=100，同样假设是四个字节的整型数字，一个字节八位4*8=32位，则在前面再补29个0。则不管计算的哈希值是什么和100相与后，只能得到000&#47;100这两个位置(前面还有29个0)，其中这三个位置001&#47;010&#47;011，无论如何都是不会被占用的，五个位置即使超过两个就必然会发生哈希冲突，并且还有三个位置永远用不了。<br><br>很明显通过一正一反两个极其简单的例子，就能反应出，如果初始容量不是2的幂次方，则会造成更多的空间浪费和更高的冲突率。<br>当然，位运算的性能总是最佳的，这么操作性能也会很棒!<br>如果把初始容量从1到100都推演一下，估计效果会更好，印象更深刻。","like_count":1},{"had_liked":false,"id":123794,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1565762629,"is_pvip":false,"replies":[{"id":"71193","content":"不一定，这里只是一种算hash值的方式，与key的hashcode并不存在比较。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1583159566,"ip_address":"","comment_id":123794,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565762629","product_id":100028001,"comment_content":"老师，hashmap里判断两个对象相不相等先是比较hash函数，而hash函数是hashcode右移16位异或得到的，那么hash函数相同，hashcode一定相同么","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462815,"discussion_content":"不一定，这里只是一种算hash值的方式，与key的hashcode并不存在比较。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583159566,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122615,"user_name":"行则将至","can_delete":false,"product_type":"c1","uid":1542987,"ip_address":"","ucode":"DB972F2DF059C4","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","comment_is_top":false,"comment_ctime":1565439825,"is_pvip":false,"replies":[{"id":"51876","content":"纠正下按位“与”运算，这里应该是：<br>00000100 &amp; 00000100 = 非0 移动到高位<br>00001000 &amp; 00000100 = 0 保持原位<br>00001100 &amp; 00000100 = 非0 移动到高位","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1569057368,"ip_address":"","comment_id":122615,"utype":1}],"discussion_count":2,"race_medal":1,"score":"1565439825","product_id":100028001,"comment_content":"作者回复: 假设链表中有4、8、12，他们的二进制位00000100、00001000、00001100，而原来数组容量为4，则是 00000100，以下与运算：<br><br>00000100 &amp; 00000100 = 0 保持原位<br>00001000 &amp; 00000100 = 1 移动到高位<br>00001100 &amp; 00000100 = 1 移动到高位<br><br>老师，您这个例子的结果说错了吧？<br>结果应该是1   0   1  吧？<br>00000100这个也不代表1吧。换算成十进制是4啊。<br>这个问题，一直不理解，希望老师","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462332,"discussion_content":"纠正下按位“与”运算，这里应该是：\n00000100 &amp;amp; 00000100 = 非0 移动到高位\n00001000 &amp;amp; 00000100 = 0 保持原位\n00001100 &amp;amp; 00000100 = 非0 移动到高位","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569057368,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1014665,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/89/34f2cbcc.jpg","nickname":"杨宇","note":"","ucode":"EB74DF6E269F03","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6912,"discussion_content":"1其实不是1，在此应该视为“非0”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567171360,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121586,"user_name":"帽子丨影","can_delete":false,"product_type":"c1","uid":1225395,"ip_address":"","ucode":"2B34892A2DE83E","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/b3/798a4bb2.jpg","comment_is_top":false,"comment_ctime":1565162534,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565162534","product_id":100028001,"comment_content":"文中最后说到扩容是从新分配索引是使用hash值与newCap进行&amp;操作，但是看源码是和oldCap进行&amp;操作的，我觉得也应该是与oldCap进行比较：因为这一步主要是看hash值在oldCap那个1的位置是不是1，如果是1则表示在newCap上也是1(而在oldCap这个1被忽略了)，需要放在高位上","like_count":0},{"had_liked":false,"id":115610,"user_name":"Vincent","can_delete":false,"product_type":"c1","uid":1135159,"ip_address":"","ucode":"CD8B84A57A6A0C","user_header":"https://static001.geekbang.org/account/avatar/00/11/52/37/13b4c8aa.jpg","comment_is_top":false,"comment_ctime":1563674660,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563674660","product_id":100028001,"comment_content":"不管你初始容量是否设置为2的整数次幂，hashmap 通过tableSizeFor 方法转换成了2的整数次幂。至于为什么要2的整数次幂 是因为hash 函数计算hash值时候使用了(n - 1) &amp; hash, 如果n是2的整数次幂，那么n-1 就是所有二进制位都是1，可以保证所有函数都在数组table 的某一个索引位置。所以这个时候我们只要保证hash函数返回的hash值区分度大，就可以减少冲突的可能。","like_count":0},{"had_liked":false,"id":113619,"user_name":"克","can_delete":false,"product_type":"c1","uid":1069206,"ip_address":"","ucode":"6DDFBB05E0F4E9","user_header":"https://static001.geekbang.org/account/avatar/00/10/50/96/18612c89.jpg","comment_is_top":false,"comment_ctime":1563095569,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563095569","product_id":100028001,"comment_content":"总不能等到每个数组idx都有元素才扩容吧。那样鬼知道什么时候填满，按照元素总数初以加载因子就是为了减少链表长度。","like_count":0},{"had_liked":false,"id":108254,"user_name":"luzero","can_delete":false,"product_type":"c1","uid":1359123,"ip_address":"","ucode":"B1BACA0CE8163C","user_header":"https://static001.geekbang.org/account/avatar/00/14/bd/13/6424f528.jpg","comment_is_top":false,"comment_ctime":1561705827,"is_pvip":false,"replies":[{"id":"39351","content":"是重写","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561862475,"ip_address":"","comment_id":108254,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561705827","product_id":100028001,"comment_content":"老师请教一个问题，HashMap 获取元素优化这个章节中的 “例如，重新 key 值的 hashCode() 方法”，是重写？还是重新？ 哈哈哈、我有点搞蒙了哦<br>","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455886,"discussion_content":"是重写","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561862475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107933,"user_name":"Forwardジ","can_delete":false,"product_type":"c1","uid":1212684,"ip_address":"","ucode":"B3A0231E792C9A","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/0c/22cf60a9.jpg","comment_is_top":false,"comment_ctime":1561635774,"is_pvip":false,"replies":[{"id":"39345","content":"是指hashmap扩容吗？","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561861015,"ip_address":"","comment_id":107933,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561635774","product_id":100028001,"comment_content":"老师，hashmap的大小看文章里没讲解，这块怎么总结？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455752,"discussion_content":"是指hashmap扩容吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561861015,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107431,"user_name":"Rancood","can_delete":false,"product_type":"c1","uid":1204333,"ip_address":"","ucode":"052BDF2221F480","user_header":"https://static001.geekbang.org/account/avatar/00/12/60/6d/e2576fda.jpg","comment_is_top":false,"comment_ctime":1561535368,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561535368","product_id":100028001,"comment_content":"(n-1)&amp;hash得到的是在数组下标在map的数组的范围之内","like_count":0},{"had_liked":false,"id":105173,"user_name":"ZOU志伟","can_delete":false,"product_type":"c1","uid":1029179,"ip_address":"","ucode":"439779871CC992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b4/3b/a1f7e3a4.jpg","comment_is_top":false,"comment_ctime":1560933040,"is_pvip":false,"replies":[{"id":"51875","content":"纠正下按位“与”运算，这里应该是：<br>00000100 &amp; 00000100 = 非0 移动到高位<br>00001000 &amp; 00000100 = 0 保持原位<br>00001100 &amp; 00000100 = 非0 移动到高位","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1569057349,"ip_address":"","comment_id":105173,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560933040","product_id":100028001,"comment_content":"假设链表中有4、8、12，他们的二进制位00000100、00001000、00001100，而原来数组容量为4，则是 00000100，以下与运算：<br><br>00000100 &amp; 00000100 = 0 保持原位<br>00001000 &amp; 00000100 = 1 移动到高位<br>00001100 &amp; 00000100 = 1 移动到高位<br><br>这段不理解，为何&amp;运算是0或者1？","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454583,"discussion_content":"纠正下按位“与”运算，这里应该是：\n00000100 &amp;amp; 00000100 = 非0 移动到高位\n00001000 &amp;amp; 00000100 = 0 保持原位\n00001100 &amp;amp; 00000100 = 非0 移动到高位","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569057349,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105158,"user_name":"ZOU志伟","can_delete":false,"product_type":"c1","uid":1029179,"ip_address":"","ucode":"439779871CC992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b4/3b/a1f7e3a4.jpg","comment_is_top":false,"comment_ctime":1560931640,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560931640","product_id":100028001,"comment_content":"元素获取和扩容讲得有点模糊，建议加点图标说明","like_count":0},{"had_liked":false,"id":104938,"user_name":"汤小高","can_delete":false,"product_type":"c1","uid":1555565,"ip_address":"","ucode":"D4AB7766273D52","user_header":"https://static001.geekbang.org/account/avatar/00/17/bc/6d/f6f0a442.jpg","comment_is_top":false,"comment_ctime":1560874829,"is_pvip":false,"replies":[{"id":"38064","content":"假设链表中有4、8、12，他们的二进制位00000100、00001000、00001100，而原来数组容量为4，则是 00000100，以下与运算：<br><br>00000100 &amp; 00000100 = 非0 移动到高位<br>00001000 &amp; 00000100 = 0 保持原位<br>00001100 &amp; 00000100 = 非0 移动到高位","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1560909944,"ip_address":"","comment_id":104938,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560874829","product_id":100028001,"comment_content":"老师，有个疑问：<br>(e.hash &amp; oldCap)，它的两种结果，一个是0，另一个应该是oldCap，老师为什么说一种结果是0，一种结果是1呢？另一种结果不一定是1吧？比如hash为3，二进制是0011，oldCap为4，二进制为0100  它们相与的结果为0   ，但是比如hash为4，二进制为0100  oldCap为4，二进制为为0100，它们相与的结果不还是0100吗，十进制不是4吗，怎么会是0了","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454490,"discussion_content":"假设链表中有4、8、12，他们的二进制位00000100、00001000、00001100，而原来数组容量为4，则是 00000100，以下与运算：\n\n00000100 &amp;amp; 00000100 = 非0 移动到高位\n00001000 &amp;amp; 00000100 = 0 保持原位\n00001100 &amp;amp; 00000100 = 非0 移动到高位","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560909944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":102544,"user_name":"小辉辉","can_delete":false,"product_type":"c1","uid":1189661,"ip_address":"","ucode":"9FF25E25C85350","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/1d/1cb36854.jpg","comment_is_top":false,"comment_ctime":1560248508,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560248508","product_id":100028001,"comment_content":"HashMap源码看过几遍，跟着老师的思路来又学到了新东西","like_count":0},{"had_liked":false,"id":101624,"user_name":"你好旅行者","can_delete":false,"product_type":"c1","uid":1154101,"ip_address":"","ucode":"5C72A428DC28F3","user_header":"https://static001.geekbang.org/account/avatar/00/11/9c/35/9dc79371.jpg","comment_is_top":false,"comment_ctime":1559892519,"is_pvip":false,"replies":[{"id":"36865","content":"一个开源框架更多是考虑一个大环境下的优化场景，所以对于某些特殊场景，比如你说的这种低位全相等，高位不相等的情况，自己需要考虑如何去优化key值。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1560172285,"ip_address":"","comment_id":101624,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559892519","product_id":100028001,"comment_content":"对于老师提到的hash函数的目的是为了尽量打乱hashcode真正参与运算的低16位。我想问为什么只考虑了低16位，假设出现一种情况，hashcode的低位全部相等，高位不相等，那岂不是会大大加大哈希冲突吗？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453040,"discussion_content":"一个开源框架更多是考虑一个大环境下的优化场景，所以对于某些特殊场景，比如你说的这种低位全相等，高位不相等的情况，自己需要考虑如何去优化key值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560172285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101118,"user_name":"晓杰","can_delete":false,"product_type":"c1","uid":1441546,"ip_address":"","ucode":"1174C88EEBF8A6","user_header":"https://static001.geekbang.org/account/avatar/00/15/ff/0a/12faa44e.jpg","comment_is_top":false,"comment_ctime":1559720556,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559720556","product_id":100028001,"comment_content":"用与运算代替取模运算，可以提高运算的效率，而且当n是2的幂次方时：hash &amp; (n- 1) == hash % n","like_count":0},{"had_liked":false,"id":101021,"user_name":"郑晨Cc","can_delete":false,"product_type":"c1","uid":1324942,"ip_address":"","ucode":"57146E444D6329","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/8e/cf0b4575.jpg","comment_is_top":false,"comment_ctime":1559702227,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559702227","product_id":100028001,"comment_content":"思考题：因为计算机是二进制 数组大小设置为2的整数次幂有利于使用位运算代替取模求余，就像在人类的思维中很容易看出一个数字对10的正数次幂求余数一样。扩容中的位运算也是类似的道理","like_count":0},{"had_liked":false,"id":100960,"user_name":"强哥","can_delete":false,"product_type":"c1","uid":1206726,"ip_address":"","ucode":"3B8DC780FE4EF9","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/c6/513df085.jpg","comment_is_top":false,"comment_ctime":1559696094,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559696094","product_id":100028001,"comment_content":"我继续之前的问题，如果容量不是2的幂次方，那还能用位运算代替模运算吗？这个是否有人思考过呢？","like_count":0},{"had_liked":false,"id":100915,"user_name":"胖妞","can_delete":false,"product_type":"c1","uid":1543769,"ip_address":"","ucode":"AC82AF2B912575","user_header":"","comment_is_top":false,"comment_ctime":1559689504,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559689504","product_id":100028001,"comment_content":"平常基本会用就满足了，所以，一般不会设置map的初始值，底层算法有点复杂，尤其位运算，我都需要好好想想，才能明白干啥！从文中看，开始map创建就是一个node数组，只是，在计算存放node位置的时候，如果node位置计算出现冲突(一致)了，就将把冲突的后一个node转存到前一个node尾部，变成一个链表，当链表长度超过8后，这种链表又会重新转成树结构！？是吗？这里面的几次转变，产生的一些问题，也不是很明白！第一，hase算法，计算位置的时候，什么情况下会出现结果一致，第二，链表转换为树为啥定位为8和长度限制，第三，转换为树的时候，肯定会把以前的链表元素全部遍历后，重新创建数据结构，那么，这种重新创建数据结构的时间话费难道还比在后面继续追加来的快吗？算法小白一枚！尤其这种涉及位运算的！唉！看来要好好看一下基础了！","like_count":0},{"had_liked":false,"id":100702,"user_name":"程序员人生","can_delete":false,"product_type":"c1","uid":1113668,"ip_address":"","ucode":"C5C5073D89AAA2","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/44/3e3040ac.jpg","comment_is_top":false,"comment_ctime":1559620496,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559620496","product_id":100028001,"comment_content":"降低hash碰撞，增加空间利用率","like_count":0},{"had_liked":false,"id":100700,"user_name":"yes","can_delete":false,"product_type":"c1","uid":1386201,"ip_address":"","ucode":"612BF6884ED6CC","user_header":"https://static001.geekbang.org/account/avatar/00/15/26/d9/f7e96590.jpg","comment_is_top":false,"comment_ctime":1559618572,"is_pvip":false,"replies":[{"id":"36416","content":"是的，感谢提醒！~","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1559699586,"ip_address":"","comment_id":100700,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559618572","product_id":100028001,"comment_content":"1.8那个流程图中不转树的话，node是插入尾部吧不是头部","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452646,"discussion_content":"是的，感谢提醒！~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559699586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":100573,"user_name":"哲","can_delete":false,"product_type":"c1","uid":1110473,"ip_address":"","ucode":"5387E831DB789F","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/c9/adc1df03.jpg","comment_is_top":false,"comment_ctime":1559579599,"is_pvip":false,"replies":[{"id":"36257","content":"对的，具体是为了降低哈希冲突，均匀分布新增元素，提高查询性能。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1559611514,"ip_address":"","comment_id":100573,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559579599","product_id":100028001,"comment_content":"主要是为了方便位运算吧","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452606,"discussion_content":"对的，具体是为了降低哈希冲突，均匀分布新增元素，提高查询性能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559611514,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}