{"id":209138,"title":"08 | 可复用架构案例（一）：如何设计一个基础服务？","content":"<p>你好，我是王庆友。</p><p>在上一讲中，我提到过，在架构设计中，要实现业务上的复用，一个比较可行的做法是，把各个基础业务封装成共享服务，供上层所有应用调用。所以今天，我就来和你聊一聊，如何从头开始，落地这样一个典型的共享服务。</p><p>我们知道，落地一个微服务其实并不困难，但要实现一个能够高度复用的共享服务并不容易，在落地过程中，经常会有一系列的问题困扰着我们。</p><ul>\n<li>我们事先对服务的边界没有进行很好的划分，结果在落地的过程中，大家反复争论具体功能的归属。</li>\n<li>由于对业务的了解不够深入，我们要么设计不足，导致同一个服务有很多版本；要么服务过度设计，实现了一堆永远用不上的功能。</li>\n</ul><p><strong>对于落地一个共享服务来说，服务边界的划分和功能的抽象设计是核心。</strong>服务边界确定了这个服务应该“做什么”，抽象设计确定了这个服务应该“怎么做”。</p><p>接下来，我就以一个<strong>实际的订单服务例子</strong>，为你详细讲解一下要如何重点解决这两个问题。这样你可以通过具体的案例，去深入地理解如何落地共享服务，实现业务能力的复用。</p><h2>订单业务架构</h2><p>不同企业的订单业务是不一样的，所以这里我先介绍下这个订单的业务场景。</p><p>这是个O2O（Online To Offline，线上到线下）的交易业务，订单的来源有两个，一个是自有小程序或App过来的订单，还有一个是外卖平台过来的订单，然后这些线上的订单会同步到门店的收银系统进行接单和进一步处理。这里我放了一张订单的业务架构图，你可以到文稿中看下：</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/f6/f5/f60dec4aff0201e54f8a509046e0aef5.jpg?wh=1142*675\" alt=\"\"></p><p>在这里，订单服务是和4个应用直接打交道的：</p><ul>\n<li><strong>小程序服务端</strong>调用订单服务落地自有线上订单；</li>\n<li><strong>外卖同步程序</strong>接收三方外卖平台的订单，然后调用订单服务落地订单；</li>\n<li><strong> POS同步程序</strong>通过订单服务拉取订单，并推送给商户内部的收银系统；</li>\n<li>最后还有一个<strong>订单管理后台</strong>，通过订单服务查询和修改订单。</li>\n</ul><p>OK，接下来，我们就具体看下，如何从头开始落地这个订单服务。</p><h2>订单服务边界划分</h2><p>首先，我们要确定这个服务的边界，这是进行服务内部设计的前提。划分边界时，你需要对相关的业务场景有充分了解，并且在一定程度上，能够预测潜在的需求。在<a href=\"https://time.geekbang.org/column/article/207876\">上一讲</a>，我也和你分享了划分边界一些比较实用的原则和做法，你可以对照学习一下。</p><p>根据业务场景的分析，这个订单服务需要负责三个方面的功能。</p><h3>基本信息管理</h3><p>首先是订单基本信息管理，主要提供订单基础信息的增删改查功能，包括下单用户、下单商品、收货人、收货地址、收货时间、堂食或外卖、订单状态、取餐码等。</p><p>另外，你需要注意的是，这里有多个下单渠道，除了通用的订单信息，每个渠道还有特定的渠道相关信息，比如堂食的订单要有取餐码、外卖的订单要有收货人和收货地址等等，这个都需要在我们的数据模型里给出定义。</p><h3>订单优惠管理</h3><p>然后是订单优惠管理功能，这对应的是订单的小票信息，从最开始的商品金额，到最后需要用户实际支付的金额，中间会有一系列的折扣和减免，这些都是属于订单信息的一部分。这些信息我们需要展示给用户看，如果后续要进行订单成本的分摊，也需要用到它。</p><h3>订单生命周期管理</h3><p>最后是订单的生命周期管理功能，主要负责管理订单的状态变化。我们知道，从不同下单渠道过来的订单，它的状态变化过程是不一样的；不同行业的订单，它的状态变化过程也是不同的，所以<strong>订单服务的状态要做到通用</strong>，能够支持各种可能的状态定义和状态转换过程。这个也是订单服务设计的难点，我在后面会重点介绍。</p><p>好了，现在我们已经给出了订单服务的功能。<strong>为了更好地定义边界，在实践中，你还需要澄清哪些功能不属于服务</strong>，这样可以避免后续的很多争论。所以在这里，我会进一步给出订单服务不包括的功能，你在划分自己的服务边界时最好也能够明确给出。</p><p><strong>第一，作为基础服务，订单服务不主动调用其他服务。</strong></p><p>比如说，你想了解订单的用户详情、商品详情等等，这应该由上层应用通过调用相应的服务来实现，然后和订单信息组装在一起，而不是在订单服务内部直接调用其他服务，否则会导致基础服务之间相互依赖，职责模糊。</p><p>如果说这个信息整合的场景非常通用，我们可以创建一个在基础服务之上的聚合服务来实现，把订单信息、用户信息、商品信息整合在一起。</p><p><strong>第二，订单服务不负责和第三方系统的集成。</strong></p><p>在这里，订单需要在我们的订单服务和三方外卖平台，以及收银系统之间进行同步，这些同步功能都是针对第三方系统定制的，不具有通用性。而我们的订单服务作为基础服务，需要具备通用性，因此这些和外部系统对接的功能不会在订单服务的内部实现，而是由额外的同步程序实现。</p><blockquote>\n<p>小提示：这些同步程序可以主动调用订单服务，然后再和第三方对接，如果想实时获取订单信息的变化，同步程序可以订阅订单服务的消息通知，第一时间了解订单变化。</p>\n</blockquote><p><strong>第三，订单服务不提供优惠计算或成本分摊逻辑。</strong></p><p>订单服务不负责具体的优惠计算，只提供优惠结果的存储和查询，用于还原订单的费用组成。优惠的具体计算过程一般由专门的促销系统负责，成本的分摊一般由后续的财务系统负责。这个我们在上一讲中已经说过，这里就不详细解释了。</p><p><strong>最后，该服务不提供履单详情，不负责详细物流信息的存储。</strong></p><p>比如说，订单已经发送至上海、订单已经到达某某快递站等等这些信息，订单服务不负责提供这些详细信息，这些都是属于后续履单系统的职责。订单服务可以存储一些外部系统的单据号码，比如配送单号，这样能方便上层应用通过订单记录和配送系统进行关联，获取配送的详细信息。但订单服务只负责存储，不负责数据的进一步解释。</p><p>到这里，你可以看到，通过从正反两个方面说明订单服务的职责，我们就得到了一个边界很清晰、职责很聚焦的订单服务边界，所有人对它的职责认识是一致的，尽可能地避免了后续的争论。</p><h2>订单服务内部设计</h2><p>好，确定了这个<strong>订单服务要做什么</strong>之后，接下来，我们要解决的就是<strong>服务内部怎么做</strong>的问题了。</p><p>作为共享服务，我们要保证订单服务功能上的通用性，就需要同时对内部数据模型和外部接口进行良好的抽象设计。</p><h3>订单状态通用化</h3><p>对于数据模型来说，订单要存储哪些信息，已经比较明确了，具体你可以看下这个图。</p><p><img src=\"https://static001.geekbang.org/resource/image/a0/83/a0976cc0a2fee60922a9253809a57183.jpg?wh=1142*1047\" alt=\"\"></p><p>但对于如何管理订单的状态，情况就比较复杂了。</p><p>我们知道，如果针对一个具体的项目，无论它的订单状态有多么的复杂，我们都可以事先精确地定义出来。<strong>但不同的行业甚至不同的企业，他们对于订单状态管理都是不一样的，订单服务作为一个共享服务，它必须要满足不同项目的订单状态管理。</strong>所以对于如何解决这个问题，这里我有两个思路供你参考。</p><p><strong>一个是<span class=\"orange\">开放订单状态定义</span>。</strong></p><p>在这里，订单服务事先不限定订单有哪些状态，每个项目都可以自己定义有哪些订单状态。服务的调用方可以在接口里传递任意的状态值；订单服务只负责保存状态数据，不负责解释具体的状态，也不负责任何的规则校验，它允许订单从一个状态转换为其他任意的状态。</p><p>这样的设计，在理论上可以满足各种状态的定义，满足各种状态之间的变化，但这样做其实有很大的问题。在这里，订单状态是完全由外部负责管理的，上层应用的负担会很重，不但要负责定义有哪些状态，而且还要维护状态的转换规则，一不小心，订单可能从状态A非法地变成状态B，导致业务出问题。</p><p><strong>另外一个是<span class=\"orange\">应用和服务共同管理状态</span>。</strong></p><p>对于订单状态管理，应用和服务各自承担一部分职责，我们看下具体如何实现。</p><p>我们知道，无论订单的状态变化是如何的复杂，我们总是可以定义一个订单有哪些基本的状态，包括这些基本状态之间是如何变化的。比如，订单一开始都是用户下单后待支付，支付完成后变成一个有效的订单，然后由商家进行接单，制作完成后进行发货配送等等，订单最终的状态要么是完成，要么是取消。</p><p><strong>这些订单的基本状态，我们称之为“主状态”，它们由订单服务负责定义</strong>，包括这些主状态之间的转换规则，比如已完成的订单不能变为已取消的订单。主状态的数量是比较有限的，状态之间的变化关系也是比较明确的。</p><p>这个主状态，我们对大量现有的业务场景进行总结和抽象，是完全可以定义出来的。在这个订单服务例子里，我们定义了如下图所示的订单状态机，包括有哪些主状态，以及它们的转化关系。</p><p><img src=\"https://static001.geekbang.org/resource/image/0d/74/0d773b0d18e318b2b5260a0430c42c74.jpg?wh=1142*606\" alt=\"\"></p><p><strong>订单除了“主状态”，还有“子状态”。</strong></p><p>比如，一个订单处于配送中，实际情况可能是“仓库已发货”，“货已到配送站”，或者是“快递员正在送货中”等等，那么在这些情况中，订单的主状态都是“配送中”，它的子状态就是细化的这几种情况。<strong>子状态有哪些具体的取值，不同的项目是不一样的，这个就开放给各个应用来定义。</strong></p><p>所以，订单服务数据模型里有<strong>两个字段</strong>，其中的主状态由订单服务负责管理，包括主状态之间的变化规则；而子状态由上层应用来定义，管理子状态的变化规则，比如一个配送中的订单，它的子状态可以由“仓库已发货”，变为“快递员正在送货中”。</p><p>现在，我们就可以总结下这两种订单状态的设计思路。</p><p><strong>第一种方案，我们不对订单状态进行管理</strong>，而是把订单的状态作为一个简单的属性存储，只支持订单状态简单的增删改查功能。我们知道，订单状态是订单业务规则的核心体现，这样的订单服务是没有灵魂的，也失去了大部分业务复用的价值。</p><p><strong>第二种方案，应用和服务共同管理订单的状态</strong>，订单服务抓大放小，通过主状态管理把控住了订单的核心业务规则，同时把子状态开放给应用进行管理，为具体的业务场景提供了灵活性。通过主状态和子状态的结合，订单服务就满足了不同行业、不同企业的订单状态管理需求。</p><h3>订单服务接口定义</h3><p>说完了订单的状态管理，接下来，我们从调用方怎么使用服务的角度，来看下订单服务外部接口是如何设计的。</p><p>外部系统和服务的交互有<strong>两种方式</strong>，包括同步的服务接口调用和异步的消息通知。</p><p><strong>首先是<span class=\"orange\">同步的服务接口调用</span>。</strong></p><p>为了方便外部调用方，我们在服务接口命名时，一定要规范和统一，接口名字要能够望文生义，方便调用者快速找到所需要的接口。并且，我们还要提供接口具体的请求和响应样例帮助说明。</p><p>具体的接口设计规范，我就不具体展开了，每个公司都要有明确的规范要求，这里我就说下常见的查询接口是如何设计的。</p><p>一个订单有很多字段，每次调用方要查询的信息可能都不相同，不同字段之间的组合方式有很多，我们不可能一一支持。</p><p><strong>那么，我们怎么设计查询接口，来满足各种场景需求呢?</strong>一般来说，我们可以根据返回字段数量的不同，提供三个不同粒度的查询接口来满足多样化的需求。</p><p>第一个是<strong>粗粒度接口</strong>，只返回订单最基本的7-8个字段，比如订单编号、订单状态、订单金额、下单用户、下单时间等等；第二个是<strong>中粒度接口</strong>，返回订单比较常用的十几个字段；第三个是<strong>细粒度接口</strong>，返回订单的详细信息。</p><p>这样，不同的查询需求，就可以根据要返回信息的详细程度，来选择合适的接口，通过这种方式，我们兼顾了要定义的接口数量和查询的性能。</p><p><strong>其次是<span class=\"orange\">异步的消息通知</span>。</strong></p><p>订单服务除了提供同步的接口调用，还针对每次订单信息的变化，提供异步的消息通知，感兴趣的外部系统可以通过接收消息，第一时间感知订单的变化。</p><p><strong>按照消息详细程度的不同，订单消息可以分为“胖消息”和“瘦消息”。</strong></p><p>顾名思义，<strong>胖消息</strong>包含了尽可能多的字段，但<strong>传输效率低</strong>；<strong>瘦消息</strong>只包含最基本的字段，<strong>传输效率高</strong>。如果外部系统需要更多的信息，它们可以通过进一步调用订单服务的接口来获取。</p><p>在这个订单服务的例子里，如果是订单状态的变化，我们只需提供订单号、变化前后的状态即可，因此主要以瘦消息为主；如果是新订单的创建，由于订单的字段比较多，所以使用胖消息，避免外部系统进一步调用订单服务接口。你在实践中，可以根据实际情况，在消息的数据量和消费者处理消息的复杂度之间做平衡。</p><p>前面我们说了，订单服务不会主动调用外部系统的接口，这里的异步消息通知，就可以很好地保证外部系统及时感知订单的任何变化，同时避免订单服务和外部系统直接耦合。</p><h2>总结</h2><p>要想打造一个可高度复用的共享服务，你需要掌握最核心的两点：<strong>清晰的边界划分、内部的抽象设计。</strong></p><p>今天，我通过一个实际的订单服务例子，帮助你理解如何清晰地定义服务的边界，以及如何通过抽象设计保证服务的通用性。你在实践中，一定要深入分析业务场景，识别真正的挑战在哪里，避免设计的简单化或过度复杂化。</p><p>通过今天的讲解，相信你在前一篇理论内容的基础上，对如何打造一个共享服务有了更深入的体会，希望你在工作中能不断地去实践，真正掌握这些技能。</p><p><strong>最后，给你留一道思考题：</strong>在落地共享服务的时候，你碰到过哪些挑战，都是怎么解决的？</p><p>欢迎你在留言区与大家分享你的答案，如果你在学习和实践的过程中，有什么问题或者思考，也欢迎给我留言，我们一起讨论。感谢阅读，我们下期再见。</p>","comments":[{"had_liked":false,"id":185987,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":true,"comment_ctime":1583738353,"is_pvip":false,"replies":[{"id":"71872","content":"感觉你这个不仅仅是订单服务，而包含了订单之上打的oms系统，如果一开始各个基础业务划分的好，系统整体就很好调整，下一讲说的是现有系统的服务化改造，也许对你有用","user_name":"作者回复","user_name_real":"王庆友","uid":"1268522","ctime":1583745723,"ip_address":"","comment_id":185987,"utype":1}],"discussion_count":1,"race_medal":0,"score":"9.2233720556184003e+18","product_id":100046301,"comment_content":"1.碰巧也是做订单系统的。<br>2.目前接管的订单系统是一个开发了四五年的单体订单系统。<br>3.没有边界划分，以往的实现，基本就是开发将产品的业务逻辑翻译成代码。现象就是部分拆单策略非常复杂，所有本该外部系统承接的业务逻辑都由订单组完成。这就导致你想维护订单组，支付，营销，会员，商品你都要懂业务。（起步简单，可能这些现在的分组都是那么几个人来完成，但随着业务线的发展，各组的业务都膨胀了很多，已经不是个人短时间能够掌握的）。<br>4.代码耦合非常严重，一个商品组的表对象do，会在各个组的api包里面被依赖，相关的业务逻辑也严重依赖该do。牵一发动全身，常常因为一个字段的调整开很久的会议。<br>5.代码实现没任何扩展性和灵活性，大量逻辑判断依赖入参状态，导致从单体转多元输入后，一个方法动不动就上千行代码，大量根据数据元做逻辑跳转的代码。<br><br>6.职责模糊，功能复杂，代码耦合高，实现逻辑基本硬编码没有扩展的能力，没有任何单元测试。<br><br>7.现在需要该项目能灵活支撑多元业务的接入，基本就是单体往saas发展了。我能想到的方法都需要较大成本，因为最小的组成单元“策略”，本身的实现不具备可灵活复用的特性，必须重构其实现方式。但如此一来，成本太大。领导是接受不了的。","like_count":5,"discussions":[{"author":{"id":1268522,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5b/2a/83c3cb2d.jpg","nickname":"王庆友","note":"","ucode":"90D8743C4A6C79","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486569,"discussion_content":"感觉你这个不仅仅是订单服务，而包含了订单之上打的oms系统，如果一开始各个基础业务划分的好，系统整体就很好调整，下一讲说的是现有系统的服务化改造，也许对你有用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583745723,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185868,"user_name":"探索无止境","can_delete":false,"product_type":"c1","uid":1044178,"ip_address":"","ucode":"91D2A9907DFA79","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/d2/7024431c.jpg","comment_is_top":false,"comment_ctime":1583717139,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"44533390099","product_id":100046301,"comment_content":"可惜只有22讲，每一讲都有收获","like_count":9},{"had_liked":false,"id":186505,"user_name":"孙同学","can_delete":false,"product_type":"c1","uid":1676238,"ip_address":"","ucode":"C6C82400D15336","user_header":"https://static001.geekbang.org/account/avatar/00/19/93/ce/092acd6a.jpg","comment_is_top":false,"comment_ctime":1583853955,"is_pvip":false,"replies":[{"id":"72035","content":"上层应用负责调用优惠计算，然后把结果交给订单服务负责存储。","user_name":"作者回复","user_name_real":"王庆友","uid":"1268522","ctime":1583887808,"ip_address":"","comment_id":186505,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23058690435","product_id":100046301,"comment_content":"https:&#47;&#47;www.processon.com&#47;view&#47;link&#47;5e51378ce4b0c037b5f9d1e3 学习整理更新，有个疑问，基础服务不主动调用其他服务，那在优惠计算不是要调用其他服务，然后将结果存储在自己的数据模型中吗，还是说向外提供接口，用于输入优惠计算规则？","like_count":6,"discussions":[{"author":{"id":1268522,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5b/2a/83c3cb2d.jpg","nickname":"王庆友","note":"","ucode":"90D8743C4A6C79","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486782,"discussion_content":"上层应用负责调用优惠计算，然后把结果交给订单服务负责存储。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583887808,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1039768,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/dd/98/883c42b4.jpg","nickname":"LiuHu","note":"","ucode":"284E2025C554BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":250156,"discussion_content":"在上一讲中服务的“一致性”有提到，“促销服务负责促销规则的维护，以及对应的优惠计算功能；订单服务负责优惠结果数据落地，以及后续的查询功能”。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587995089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185930,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1583725759,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"18763594943","product_id":100046301,"comment_content":"可复用的两个点：清晰的边界划分和抽象的内部设计。<br><br>1、对于边界划分。在服务的设计之处，总是会现有一个头脑风暴、各方需求裹挟的发散过程，然后随着设计的进行，必需经过收敛，所以我觉得界定服务不做什么更有实践意义。同时，服务功能越单一，越利于复用。<br><br>2、对于内部抽象设计。<br><br>我听完本科，觉得抽象设计还是紧紧的围绕到目前为止的不变的核心：数据和规则（这里特制对外的服务）。<br><br>对于数据，不仅要保证需要的数据要覆盖全面（基础信息、组合信息、外部系统使用的信息——之前的可也讲过，服务是相互正交、互不调用的，但可以共享一定的数据），而且要考虑数据是动态的（比如订单状态的变化），变化就涉及到状态检验规则。这就又涉及到了数据的全面到底是什么含义？是胡子眉毛一把抓么？不是的，是应该抓主要矛盾（比如订单分为基本状态和子状态）<br><br><br>不主动调用外部，并不是说和外部没有信息交互。这时，使用消息队列进行消息通知自然是一个好的选择，使得内外部解耦。<br><br>进一步，订阅发布模式使得发布消息的实体和接受消息的实体解耦了，双方只需要面对消息本身即可。这是一个理解消息队列的高级的视角。","like_count":5,"discussions":[{"author":{"id":1010018,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/69/62/b874af21.jpg","nickname":"颛顼","note":"","ucode":"4A6139389C62EA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":250296,"discussion_content":"这里面数据的分类怎么理解?组合信息是指？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587999020,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1489957,"avatar":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","nickname":"tt","note":"","ucode":"7753B79AD5A9AC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1010018,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/69/62/b874af21.jpg","nickname":"颛顼","note":"","ucode":"4A6139389C62EA","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":250783,"discussion_content":"词用的不准确。组合信息指用基础信息加工、变换出来的信息。就是课里说的订单系统里保存的订单金额相关数据。订单总金额是基本信息的话，优惠金额即支付金额就是组合信息。\n\n不过最近看React，它的理念是只保存基本信息，可以用基本信息计算出来的组合信息或二次信息都不保存，而是用计算得出来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588039958,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":250296,"ip_address":""},"score":250783,"extra":""}]},{"author":{"id":1268522,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5b/2a/83c3cb2d.jpg","nickname":"王庆友","note":"","ucode":"90D8743C4A6C79","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":200953,"discussion_content":"我们的课代表来了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583746391,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185864,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1583716497,"is_pvip":false,"replies":[{"id":"71825","content":"你这种说的是url回调，这也是一种方式，在支付里用的比较多，收到第三方平台支付成功后，支付服务回调应用系统提供的URL完成通知。<br>这种方式比同步调用耦合性低，比消息通知耦合性高一些，并且调用不成功，要重试，服务要做的事情要更多一些。<br>如果针对不特定的接收者，消息通知更合适，解耦更彻底一些。","user_name":"作者回复","user_name_real":"王庆友","uid":"1268522","ctime":1583723430,"ip_address":"","comment_id":185864,"utype":1}],"discussion_count":3,"race_medal":0,"score":"18763585681","product_id":100046301,"comment_content":"老师好，订单服务在异步通知应用的时候使用的技术我觉得不一定非要mq吧，只要应用把自己的通知url告知订单服务，订单服务负责在信息变动时进行推送就可以了，这种更简单一些，不过可能可用性不是很高而已。","like_count":5,"discussions":[{"author":{"id":1268522,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5b/2a/83c3cb2d.jpg","nickname":"王庆友","note":"","ucode":"90D8743C4A6C79","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486533,"discussion_content":"你这种说的是url回调，这也是一种方式，在支付里用的比较多，收到第三方平台支付成功后，支付服务回调应用系统提供的URL完成通知。\n这种方式比同步调用耦合性低，比消息通知耦合性高一些，并且调用不成功，要重试，服务要做的事情要更多一些。\n如果针对不特定的接收者，消息通知更合适，解耦更彻底一些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583723430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757658,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/da/7faf18a0.jpg","nickname":"唐高为","note":"","ucode":"15655BE4928C9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":201346,"discussion_content":"如果只做回调的话，需要在代码里添加定时任务进行重试。其实可以将重试的逻辑独立出来，专门做一个回调服务。主应用向这个回调服务发异步消息就行了。再进一步，可以在回调服务里管理多个回调方。当然，在增加灵活性的同时也会增加复杂性。要根据业务阶段和人员情况来权衡。回调主要是应对外部系统通讯协议不确定的问题。如果是内部系统的一部通知，还是用消息队列比较成熟。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583770682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1489957,"avatar":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","nickname":"tt","note":"","ucode":"7753B79AD5A9AC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":200819,"discussion_content":"嗯，真的是啊，回掉也是一种异步调用方式。我觉得从架构的角度去看通讯方式，如果要做到两个系统互不调用，消息队列的发布订阅模式我觉得是最彻底的，因为双方只对消息本身负责，可以不知道对方的存在。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583726370,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188125,"user_name":"小洛","can_delete":false,"product_type":"c1","uid":1005062,"ip_address":"","ucode":"227EC21891012B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/56/06/ea49b29d.jpg","comment_is_top":false,"comment_ctime":1584323070,"is_pvip":false,"replies":[{"id":"72824","content":"1. 既然子状态是显式的,最好有明确字段保存。<br>2. 针对这种情况，可以考虑结账不是订单的结束态，而是结账后，过一定时间自动关单，变成真正的&quot;完成&quot;状态。","user_name":"作者回复","user_name_real":"王庆友","uid":"1268522","ctime":1584419869,"ip_address":"","comment_id":188125,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14469224958","product_id":100046301,"comment_content":"请教下老师<br>1、关于设计两个状态字段管理订单主状态和子状态，可以主状态是个单独字段，而子状态放在扩展字段吗？那么订单还承接按照子状态纬度的查询<br>2、关于订单主状态，基本状态是不可变的，比如支付，下单，结账（结束）但是我们公司的业务就是结账状态有个逆操作反结账，然后还可以不停地在原订单的基础上再加菜，这样的设计合理吗","like_count":4,"discussions":[{"author":{"id":1268522,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5b/2a/83c3cb2d.jpg","nickname":"王庆友","note":"","ucode":"90D8743C4A6C79","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487342,"discussion_content":"1. 既然子状态是显式的,最好有明确字段保存。\n2. 针对这种情况，可以考虑结账不是订单的结束态，而是结账后，过一定时间自动关单，变成真正的&amp;quot;完成&amp;quot;状态。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584419869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185993,"user_name":"中国合伙人","can_delete":false,"product_type":"c1","uid":1589319,"ip_address":"","ucode":"C8803C2EBD92BA","user_header":"https://static001.geekbang.org/account/avatar/00/18/40/47/b62d0a64.jpg","comment_is_top":false,"comment_ctime":1583739454,"is_pvip":true,"replies":[{"id":"71873","content":"如果扩展字段是通用的，订单服务会把这部分逻辑落进去，如果是某个项目专用，订单服务支持落数据就可以","user_name":"作者回复","user_name_real":"王庆友","uid":"1268522","ctime":1583745844,"ip_address":"","comment_id":185993,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10173674046","product_id":100046301,"comment_content":"我想问一下，订单模型不一样，我们经常通过扩展字段存储差异化数据。那在哪解析扩展字段？基础服务负责解析这些差异字段吗？这里要怎么设计不同业务类型订单查询？","like_count":3,"discussions":[{"author":{"id":1268522,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5b/2a/83c3cb2d.jpg","nickname":"王庆友","note":"","ucode":"90D8743C4A6C79","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486573,"discussion_content":"如果扩展字段是通用的，订单服务会把这部分逻辑落进去，如果是某个项目专用，订单服务支持落数据就可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583745844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":265059,"user_name":"如来神掌","can_delete":false,"product_type":"c1","uid":1033096,"ip_address":"","ucode":"45E20FF935BD2F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c3/88/d16816a8.jpg","comment_is_top":false,"comment_ctime":1606747699,"is_pvip":false,"replies":[{"id":"99628","content":"如何是服务化设计，A应用和B应用的数据落在不同数据库。","user_name":"作者回复","user_name_real":"王庆友","uid":"1268522","ctime":1611040703,"ip_address":"","comment_id":265059,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5901714995","product_id":100046301,"comment_content":"数据如何存储? 比如A应用产生的数据和B应用产生的数据，在数据库设计上如何设计和存储呢？","like_count":2,"discussions":[{"author":{"id":1268522,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5b/2a/83c3cb2d.jpg","nickname":"王庆友","note":"","ucode":"90D8743C4A6C79","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510786,"discussion_content":"如何是服务化设计，A应用和B应用的数据落在不同数据库。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611040703,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":304723,"user_name":"天空","can_delete":false,"product_type":"c1","uid":1038338,"ip_address":"","ucode":"96C04E8D3C32B7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d8/02/c749e2c7.jpg","comment_is_top":false,"comment_ctime":1627567529,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627567529","product_id":100046301,"comment_content":"这一讲精彩","like_count":0},{"had_liked":false,"id":253802,"user_name":"yudidi","can_delete":false,"product_type":"c1","uid":1202482,"ip_address":"","ucode":"70283DE39D86F5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ydFhHonicUQibGlAfsAYBibNOfSxpCG5cJNp9oRibTJm3TrxM7Hj4WPPCRE3vluZJb0TGQqpKCaBWLdmra5Su1KF5Q/132","comment_is_top":false,"comment_ctime":1602902299,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1602902299","product_id":100046301,"comment_content":"&quot;主状态和子状态&quot;这种设计，我们有些其他业务(非订单业务)也有用到, 使用过程中有2点感觉不舒服: <br>比如有主状态A(其下子状态a1,a2),主状态B(其下子状态b1,b2),<br>1.如果子状态从a2切换为b1, 还需要变更主状态A=&gt;B。<br>2.状态正向变化很ok,但是状态逆向变化是很麻烦的。比如从b2回到a2, 那么主状态也要从B恢复A。<br>如果业务的状态很多，又有逆向变化情况，那么大家一定会遇到这些问题，不知道大家有何高见。<br>这算是业务自身复杂度导致的吗?<br>","like_count":0,"discussions":[{"author":{"id":2235293,"avatar":"https://static001.geekbang.org/account/avatar/00/22/1b/9d/78cd27a9.jpg","nickname":"被雪吹过的夏天","note":"","ucode":"18ECB7DEB982C6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330367,"discussion_content":"朋友不需要纠结订单状态正向和逆向的变化，根据业务场景变化，很正常！ 在一定程序不用太在意主状态和子状态，主状态都可以支持逆向变化，为什么子状态就不可以呢？完全可以看成一个状态去处理。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1606580175,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225674,"user_name":"Sam_Deep_Thinking","can_delete":false,"product_type":"c1","uid":1001152,"ip_address":"","ucode":"8E4EF6F24B821B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/46/c0/bf880bda.jpg","comment_is_top":false,"comment_ctime":1591830467,"is_pvip":true,"replies":[{"id":"84625","content":"由上层的聚合服务提供，内部调用多个基础服务。","user_name":"作者回复","user_name_real":"王庆友","uid":"1268522","ctime":1592967186,"ip_address":"","comment_id":225674,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591830467","product_id":100046301,"comment_content":"请问一下，针对c端的下单接口，是由订单基础服务来提供还是由订单的聚合服务来提供？如果是基础服务来提供的话，那由于下单的时候，还是需要调用其他服务获取数据，进行订单数据落地，这就违反了文章中提到的原则，如果是聚合层来提供下单接口的话，那么基础服务落地订单数据时，聚合层就必须传递订单所需要的所有数据。","like_count":1,"discussions":[{"author":{"id":1268522,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5b/2a/83c3cb2d.jpg","nickname":"王庆友","note":"","ucode":"90D8743C4A6C79","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497941,"discussion_content":"由上层的聚合服务提供，内部调用多个基础服务。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592967186,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208547,"user_name":"密码123456","can_delete":false,"product_type":"c1","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1587379246,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587379246","product_id":100046301,"comment_content":"我觉得最难的就是，服务的划分和通用化设计。异步通知解耦和主动调用接口粒度划分会容易很多。","like_count":0},{"had_liked":false,"id":202005,"user_name":"蓦然回首","can_delete":false,"product_type":"c1","uid":1044233,"ip_address":"","ucode":"86056EE894FF70","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ef/09/904be048.jpg","comment_is_top":false,"comment_ctime":1585886626,"is_pvip":false,"replies":[{"id":"75524","content":"这个要看这些不同订单共性内容多不多，包括数据模型和业务逻辑，如果差异不大，整合在一起，如果差异很大，没必要强行整合在一起，理解起来困难。","user_name":"作者回复","user_name_real":"王庆友","uid":"1268522","ctime":1585899016,"ip_address":"","comment_id":202005,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585886626","product_id":100046301,"comment_content":"老师好，针对订单服务，如果要支持的业务模型不一样，比如商品、酒店、外卖，订单接口比如下单，是使用一个接口还是按业务分成多个接口比较好？底层存储是按业务分开存储，还是通过通过抽象和扩展放到一个库中好呢？","like_count":1,"discussions":[{"author":{"id":1268522,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5b/2a/83c3cb2d.jpg","nickname":"王庆友","note":"","ucode":"90D8743C4A6C79","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490479,"discussion_content":"这个要看这些不同订单共性内容多不多，包括数据模型和业务逻辑，如果差异不大，整合在一起，如果差异很大，没必要强行整合在一起，理解起来困难。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585899016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":197223,"user_name":"舞命小丢","can_delete":false,"product_type":"c1","uid":1195577,"ip_address":"","ucode":"799DB341F6B0CA","user_header":"https://static001.geekbang.org/account/avatar/00/12/3e/39/de5a3618.jpg","comment_is_top":false,"comment_ctime":1585364004,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585364004","product_id":100046301,"comment_content":"讲的挺好的","like_count":0},{"had_liked":false,"id":186737,"user_name":"AYOU","can_delete":false,"product_type":"c1","uid":1048845,"ip_address":"","ucode":"BEF18C1DB4B621","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/0d/75b3cb10.jpg","comment_is_top":false,"comment_ctime":1583915608,"is_pvip":false,"replies":[{"id":"72076","content":"是用户基本信息，订单系统一般只存用户id,多存信息就冗余了，简单的情况下，退货单也在订单服务里管理，比如餐饮外卖。复杂情况是有单独的退换货系统，比如电商","user_name":"作者回复","user_name_real":"王庆友","uid":"1268522","ctime":1583929156,"ip_address":"","comment_id":186737,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1583915608","product_id":100046301,"comment_content":"老师好：<br>  1.基本信息管理里面有用户信息，这个用户信息是用户系统的用户基本信息吗？上层系统下单组装用户信息时，订单系统只存用户id还是存一个用户的基本信息？<br>  2.一般退货的流程是在订单系统做吗？","like_count":1,"discussions":[{"author":{"id":1268522,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5b/2a/83c3cb2d.jpg","nickname":"王庆友","note":"","ucode":"90D8743C4A6C79","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486858,"discussion_content":"是用户基本信息，订单系统一般只存用户id,多存信息就冗余了，简单的情况下，退货单也在订单服务里管理，比如餐饮外卖。复杂情况是有单独的退换货系统，比如电商","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583929156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1048845,"avatar":"https://static001.geekbang.org/account/avatar/00/10/01/0d/75b3cb10.jpg","nickname":"AYOU","note":"","ucode":"BEF18C1DB4B621","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206732,"discussion_content":"老师，不同系统间的订单这些差异化的属性要怎么存呀，是加一个扩展表然后关联原来的订单表存多余的字段吗？还是说再扩展不同的app对应不同的订单系统，然后在这个扩展的订单系统基于基础订单系统来做扩展？ 谢老师！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584435235,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}