{"id":740848,"title":"第 9 章 面向对象编程(2)","content":"<h2 id=\"nav_point_153\">9.3　编程建议</h2>\n<h3 id=\"nav_point_154\">9.3.1　使用 <code>__init_subclass__</code> 替代元类</h3>\n<p>在前面介绍元类时，我提到强大的元类有许多替代工具，它们比元类更简单，可以涵盖元类的部分使用场景。<code>__init_subclass__</code> 方法就是其中一员。</p>\n<p><code>__init_subclass__</code> 是类的一个特殊钩子方法，它的主要功能是在类派生出子类时，触发额外的操作。假如某个类实现了这个钩子方法，那么当其他类继承该类时，钩子方法就会被触发。</p>\n<p>我用 8.2.2 节中的例子来演示如何使用 <code>__init_subclass__</code>。在那个例子中，我通过类装饰器实现了自动注册 <code>Validator</code> 子类的功能。其实，这个需求完全可以用 <code>__init_subclass__</code> 钩子方法来实现。</p>\n<p>在下面的代码里，我定义了一个有子类化钩子方法的 <code>Validator</code> 类：</p>\n<pre class=\"code-rows\"><code>class Validator:\n    \"\"\"校验器基类：统一注册所有校验器类，方便后续使用\"\"\"\n\n    _validators = {}\n\n    def __init_subclass__(cls, **kwargs):\n        print('{} registered, extra kwargs: {}'.format(cls.__name__, kwargs))\n        Validator._validators[cls.__name__] = cls</code></pre>\n<p>接下来，再定义一些继承了 <code>Validator</code> 的子类：</p>\n<pre class=\"code-rows\"><code>class StringValidator(Validator, foo='bar'): ➊\n    name = 'string'\n\nclass IntegerValidator(Validator):\n    name = 'int'\n\nprint(Validator._validators)</code></pre>\n<blockquote>\n<p>❶ 子类化时可以提供额外的参数</p>\n</blockquote>\n<p>执行结果如下：</p>\n<pre class=\"code-rows\"><code>StringValidator registered, extra kwargs: {'foo': 'bar'} ➊\nIntegerValidator registered, extra kwargs: {}\n{'StringValidator': &lt;class '__main__.StringValidator'&gt;, 'IntegerValidator': &lt;class '__main__.IntegerValidator'&gt;} ➋</code></pre>\n<blockquote>\n<p>❶ 父类的钩子方法被触发，完成子类注册并打印参数</p>\n<p>❷ 完成注册</p>\n</blockquote>\n<p>通过上面的例子，你会发现 <code>__init_subclass__</code> 非常适合在这种需要触达所有子类的场景中使用。而且同元类相比，钩子方法只要求使用者了解继承，不用掌握更高深的元类相关知识，门槛低了不少。它和类装饰器一样，都可以有效替代元类。</p>\n<h3 id=\"nav_point_155\">9.3.2　在分支中寻找多态的应用时机</h3>\n<p><strong>多态</strong>（polymorphism）是面向对象编程的基本概念之一。它表示同一个方法调用，在运行时会因为对象类型的不同，产生不同效果。比如 <code>animal.bark()</code> 这段代码，在 <code>animal</code> 是 <code>Cat</code> 类型时会发出“喵喵”叫，在 <code>animal</code> 是 <code>Dog</code> 类型时则发出“汪汪”叫。</p><!-- [[[read_end]]] -->\n<p>多态很好理解，当我们看到设计合理的多态代码时，很轻松就能明白代码的意图。但面向对象编程的新手有时会处在一种状态：理解多态，却不知道何时该创建多态。</p>\n<p>举个例子，下面的 <code>FancyLogger</code> 是一个记录日志的类：</p>\n<pre class=\"code-rows\"><code>class FancyLogger:\n    \"\"\"日志类：支持向文件、Redis、ES 等服务输出日志\"\"\"\n\n    _redis_max_length = 1024\n\n    def __init__(self, output_type=OutputType.FILE):\n        self.output_type = output_type\n        ...\n\n    def log(self, message):\n        \"\"\"打印日志\"\"\"\n        if self.output_type == OutputType.FILE:\n            ...\n        elif self.output_type == OutputType.REDIS:\n            ...\n        elif self.output_type == OutputType.ES:\n            ...\n        else:\n            raise TypeError('output type invalid')\n\n    def pre_process(self, message):\n        \"\"\"预处理日志\"\"\"\n        # Redis 对日志最大长度有限制，需要进行裁剪\n        if self.output_type == OutputType.REDIS:\n            return message[: self._redis_max_length]</code></pre>\n<p><code>FancyLogger</code> 类接收一个实例化参数：<code>output_type</code>，代表当前的日志输出类型。当输出类型不同时，<code>log()</code> 和 <code>pre_process()</code> 方法会做不同的事情。</p>\n<p>上面这段代码就是一个典型的应该使用多态的例子。</p>\n<p><code>FancyLogger</code> 类在日志输出类型不同时，需要有不同的行为。因此，我们完全可以为“输出日志”行为建模一个新的类型：<code>LogWriter</code>，然后把每个类型的不同逻辑封装到各自的 <code>Writer</code> 类中。</p>\n<p>对于现有的三种类型，我们可以创建下面的 <code>Writer</code> 类：</p>\n<pre class=\"code-rows\"><code>class FileWriter:\n    def write(self, message):\n        ...\n\n\nclass RedisWriter:\n    max_length = 1024\n\n    def write(self, message):\n        message = self._pre_process(message)\n        ...\n\n    def _pre_process(self, message):\n        # Redis 对日志最大长度有限制，需要进行裁剪\n        return message[: self.max_length]\n\n\nclass EsWriter: ➊\n    def write(self, message):\n        ...</code></pre>\n<blockquote>\n<p>❶ 注意：这些 <code>Writer</code> 类都没有继承任何基类，这是因为在 Python 中多态并不需要使用继承。如果你觉得这样不好，也可以选择创建一个 <code>LogWriter</code> 抽象基类</p>\n</blockquote>\n<p>基于这些不同的 <code>Writer</code> 类，<code>FancyLogger</code> 可以简化成下面这样：</p>\n<pre class=\"code-rows\"><code>class FancyLogger:\n    \"\"\"日志类：支持向文件、Redis、ES 等服务输出日志\"\"\"\n\n    def __init__(self, output_writer=None):\n        self._writer = output_writer or FileWriter()\n        ...\n\n    def log(self, message):\n        self._writer.write(message)</code></pre>\n<p>新代码利用多态特性，完全消除了原来的条件判断语句。另外你会发现，新代码的扩展性也远比旧代码好。</p>\n<p>假如你想增加一种新的输出类型。在旧代码中，你需要分别修改 <code>FancyLogger</code> 类的 <code>log()</code>、<code>pre_process()</code> 等多个方法，在里面增加新的类型判断逻辑。而在新代码中，你只要增加一个新的 <code>Writer</code> 类即可，多态会帮你搞定剩下的事情。</p>\n<p>当你深入思考多态时，会发现它是一种思维的杠杆，是一种“以少胜多”的过程。</p>\n<p>比起把所有的分支和可能性，一股脑儿地塞进程序员的脑子里，多态思想驱使我们更积极地寻找有效的抽象，以此隔离各个模块，让它们之间通过规范的接口来通信。模块因此变得更容易扩展，代码也变得更好理解了。</p>\n<h4>找到使用多态的时机</h4>\n<p>当你发现自己的代码出现以下特征时：</p>\n<ul>\n<li>有许多 <code>if</code>/<code>else</code> 判断，并且这些判断语句的条件都非常类似；</li>\n<li>有许多针对类型的 <code>isinstance()</code> 判断逻辑。</li>\n</ul>\n<p>你应该问自己一个问题：代码是不是缺少了某种抽象？如果增加这个抽象，这些分布在各处的条件分支，是不是可以用多态来表现？如果答案是肯定的，那就去找到那个抽象吧！</p>\n<h3 id=\"nav_point_156\">9.3.3　有序组织你的类方法</h3>\n<p>在编写类时，有一个常被忽略的细节：类方法的组织顺序。这个细节很小，并不影响代码的正确性，和程序的执行效率也没有任何关系。但如果你在写代码时忽视了它，就会让整个类变得十分难懂。</p>\n<p>举个例子，下面这个类的方法组织顺序就很糟糕：</p>\n<pre class=\"code-rows\"><code>class UserServiceClient:\n    \"\"\"请求用户服务的 Client 模块\"\"\"\n\n    def __init__(self, service_host, user_token): ...\n\n    def __str__(self):\n        return f'UserServiceClient: '\n\n    def get_user_profile(self, user_id):\n        \"\"\"获取用户资料\"\"\"\n\n    def request(self, params, headers, response_type):\n        \"\"\"发送请求\"\"\"\n\n    @staticmethod\n    def _parse_username(username):\n        \"\"\"解析用户名\"\"\"\n\n    def _filter_posts(self, posts):\n        \"\"\"过滤无效的用户文章\"\"\"\n\n    def get_user_posts(self, user_id):\n        \"\"\"获取用户所有文章\"\"\"\n\n    @classmethod\n    def initialize_from_request(self, request):\n        \"\"\"从当前请求初始化一个 UserServiceClient 对象\"\"\"</code></pre>\n<p>当从上而下阅读 <code>UserServiceClient</code> 类时，你的思维会不断地来回跳跃，很难搞明白它所提供的主要接口究竟是什么。</p>\n<p>在组织类方法时，我们应该关注使用者的诉求，把他们最想知道的内容放在前面，把他们不那么关心的内容放在后面。下面是一些关于组织方法顺序的建议。</p>\n<p>作为惯例，<code>__init__</code> 实例化方法应该总是放在类的最前面，<code>__new__</code> 方法同理。</p>\n<p>公有方法应该放在类的前面，因为它们是其他模块调用类的入口，是类的门面，也是所有人最关心的内容。以 <code>_</code> 开头的私有方法，大部分是类自身的实现细节，应该放在靠后的位置。</p>\n<p>至于类方法、静态方法和属性对象，你不必将它们区分对待，直接参考公有 / 私有的思路即可。比如，大部分类方法是公有的，所有它们通常会比较靠前。而静态方法常常是内部使用的私有方法，所以常放在靠后的位置。</p>\n<p>以 <code>__</code> 开头的魔法方法比较特殊，我通常会按照方法的重要程度来决定它们的位置。比如一个迭代器类的 <code>__iter__</code> 方法应该放在非常靠前的位置，因为它是构成类接口的重要方法。</p>\n<p>最后一点，当你从上往下阅读类时，所有方法的抽象级别应该是不断降低的，就好像阅读一篇新闻一样，第一段是新闻的概要，之后才会描述细节。</p>\n<p>基于上面这些原则，我重新组织了 <code>UserServiceClient</code> 类：</p>\n<pre class=\"code-rows\"><code>class UserServiceClient:\n    \"\"\"请求用户服务的 Client 模块\"\"\"\n\n    def __init__(self, service_host, user_token): ...\n\n    @classmethod\n    def initialize_from_request(self, request): ➊\n        \"\"\"从当前请求初始化一个 UserServiceClient 对象\"\"\"\n\n    def get_user_profile(self, user_id):\n        \"\"\"获取用户资料\"\"\"\n\n    def get_user_posts(self, user_id):\n        \"\"\"获取用户所有文章\"\"\"\n\n    def request(self, params, headers, response_type): ➋\n        \"\"\"发送请求\"\"\"\n\n    def _filter_posts(self, posts): ➌\n        \"\"\"过滤无效的用户文章\"\"\"\n\n    @staticmethod\n    def _parse_username(username):\n        \"\"\"解析用户名\"\"\"\n\n    def __str__(self): ➍\n        return f'UserServiceClient: '</code></pre>\n<blockquote>\n<p>❶ <code>initialize_from_request</code> 是类对外提供的 API，所以放在靠前的位置</p>\n<p>❷ <code>request</code> 方法比其他两个公开方法的抽象级别要低，所以放在它们后面</p>\n<p>❸ 私有方法靠后放置</p>\n<p>❹ <code>__str__</code> 魔法方法对于当前类来说不是很重要，可以放在靠后的位置</p>\n</blockquote>\n<p>如何组织类方法，其实是件很主观的事情，你完全可以不理会我说的这套原则，而使用自己的方式。但是，无论你选择哪种原则来组织类方法，请一定保证该原则应用到了所有类上，不然代码看上去会很不统一，非常奇怪。</p>\n<h3 id=\"nav_point_157\">9.3.4　函数搭配，干活不累</h3>\n<p>和那些严格的面向对象语言不同，在 Python 中，“面向对象”不必特别纯粹，你不必严格套用经典的 23 种设计模式，开口“抽象工厂”，闭口“命令模式”，只通过类来实现所有功能。在写代码时，如果你在原有的面向对象代码上，撒上一点儿函数作为调味品，就会发生奇妙的化学反应。</p>\n<p>比如在 8.1.5 节中，我们就试过用函数搭配装饰器类，来实现有参数装饰器。</p>\n<p>除此之外，用函数搭配面向对象代码还能实现许多其他功能。</p>\n<ol>\n<li><p><strong>用函数降低 API 使用成本</strong></p>\n<p>在 Python 社区中，有一个非常著名的第三方 HTTP 工具包：<code>requests</code>，它简单易用、功能强大，是开发者最爱的工具之一。<code>requests</code> 成功的原因有很多，但我认为其中最重要的一个，就是它提供了一套非常简洁易用的 API。</p>\n<p>使用 <code>requests</code> 请求某个网址，只要写两行代码即可：</p>\n<pre class=\"code-rows\"><code>import requests\n\nr = requests.get('https://example.com', auth=('user', 'pass'))</code></pre>\n<p>显而易见，这套让 <code>requests</code> 引以为傲的简洁 API 是基于函数来实现的。在 <code>requests</code> 包的 <code>__init__</code> 模块中，定义了许多常用的 API 函数，比如 <code>get()</code>、<code>post()</code>、<code>request()</code> 等。</p>\n<p>但重点在于，虽然这些 API 都是普通函数，但 <code>requests</code> 内部完全是基于面向对象思想编写的。拿 <code>requests.request()</code> 函数来说，它的内部实现其实是这样的：</p>\n<pre class=\"code-rows\"><code># 来自 requests.api 模块\nfrom request import sessions\n\ndef request(method, url, **kwargs):\n    with sessions.Session() as session: ➊\n        return session.request(method=method, url=url, **kwargs)</code></pre>\n<blockquote>\n<p>❶ 实例化一个 <code>Session</code> 上下文对象，完成请求</p>\n</blockquote>\n<p>假如 <code>requests</code> 包的作者删掉这个函数，让用户直接使用 <code>sessions.Session()</code> 对象，行不行？当然可以。但在使用者看来，显然调用函数比实例化 <code>Session()</code> 对象要讨喜得多。</p>\n<p>在 Python 中，像上面这种用函数搭配面向对象的代码非常多见，它有点儿像设计模式中的<strong>外观模式</strong>（facade pattern）。在该模式中，函数作为一种简化 API 的工具，封装了复杂的面向对象功能，大大降低了使用成本。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>实现“预绑定方法模式”</strong></p>\n<p>假设你在开发一个程序，它的所有配置项都保存在一个特定文件中。在项目启动时，程序需要从配置文件中读取所有配置项，然后将其加载进内存供其他模块使用。</p>\n<p>由于程序执行时只需要一个全局的配置对象，因此你觉得这个场景非常适合使用经典设计模式：<strong>单例模式</strong>（singleton pattern）。</p>\n<p>下面的代码就应用了单例模式的配置类 <code>AppConfig</code>：</p>\n<pre class=\"code-rows\"><code>class AppConfig:\n    \"\"\"程序配置类，使用单例模式\"\"\"\n\n    _instance = None\n\n    def __new__(cls):\n        if cls._instance is None:\n            inst = super().__new__(cls)\n            # 省略：从外部配置文件读取配置\n            ...\n            cls._instance = inst\n        return cls._instance\n\n    def get_database(self):\n        \"\"\"读取数据库配置\"\"\"\n        ...\n\n    def reload(self):\n        \"\"\"重新读取配置文件，刷新配置\"\"\"\n        ...</code></pre>\n<p>在 Python 中，实现单例模式的方式有很多，而上面这种最为常见，它通过重写类的 <code>__new__</code> 方法来接管实例创建行为。当 <code>__new__</code> 方法被重写后，类的每次实例化返回的不再是新实例，而是同一个已经初始化的旧实例 <code>cls._instance</code>：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; c1 = AppConfig()\n&gt;&gt;&gt; c2 = AppConfig()\n&gt;&gt;&gt; c1 is c2 ➊\nTrue</code></pre>\n<blockquote>\n<p>❶ 测试单例模式，调用 <code>AppConfig()</code> 总是会产生同一个对象</p>\n</blockquote>\n<p>基于上面的设计，如果其他人想读取数据库配置，代码需要这样写：</p>\n<pre class=\"code-rows\"><code>from project.config import AppConfig\n\ndb_conf = AppConfig().get_database()\n# 重新加载配置\nAppConfig().reload()</code></pre>\n<p>虽然在处理这种全局配置对象时，单例模式是一种行之有效的解决方案，但在 Python 中，其实有一种更简单的做法——预绑定方法模式。</p>\n<p><strong>预绑定方法模式</strong>（prebound method pattern）是一种将对象方法绑定为函数的模式。要实现该模式，第一步就是完全删掉 <code>AppConfig</code> 里的单例设计模式。因为在 Python 里，实现单例压根儿不用这么麻烦，我们有一个随手可得的单例对象——<strong>模块</strong>（module）。</p>\n<p>当你在 Python 中执行 <code>import</code> 语句导入模块时，无论 <code>import</code> 执行了多少次，每个被导入的模块在内存中只会存在一份（保存在 <code>sys.modules</code> 中）。因此，要实现单例模式，只需在模块里创建一个全局对象即可：</p>\n<pre class=\"code-rows\"><code>class AppConfig:\n    \"\"\"程序配置类，使用单例模式\"\"\"\n\n    def __init__(self): ➊\n        # 省略：从外部配置文件读取配置\n        ...\n\n_config = AppConfig() ➋</code></pre>\n<blockquote>\n<p>❶ 完全删掉单例模式的相关代码，只实现 <code>__init__</code> 方法</p>\n<p>❷ <code>_config</code> 就是我们的“单例 <code>AppConfig</code> 对象”，它以下划线开头命名，表明自己是一个私有全局变量，以免其他人直接操作</p>\n</blockquote>\n<p>下一步，为了给其他模块提供好用的 API，我们需要将单例对象 <code>_config</code> 的公有方法绑定到 <code>config</code> 模块上：</p>\n<pre class=\"code-rows\"><code># file: project/config.py\n_config = Config()\n\nget_database_conf = _config.get_database\nreload_config = _config.reload</code></pre>\n<p>之后，其他模块就可以像调用普通函数一样操作应用配置对象了：</p>\n<pre class=\"code-rows\"><code>from project.config import get_databse_conf\n\ndb_conf = get_databse_conf()\nreload_config()</code></pre>\n<p>通过“预绑定方法模式”，我们既避免了复杂的单例设计模式，又有了更易使用的函数 API，可谓一举两得。</p>\n</li>\n</ol>\n<h2 id=\"nav_point_158\">9.4　总结</h2>\n<p>在本章中，我们学习了许多与面向对象编程有关的知识。</p>\n<p>Python 是一门面向对象的编程语言，它为面向对象编程提供了非常全面的支持。但和其他编程语言相比，Python 中的面向对象有许多细微区别。比如，Python 并没有严格的私有成员，大多数时候，我们只要给变量加上下划线 <code>_</code> 前缀，意思意思就够了。</p>\n<p>和许多静态类型语言不同，在 Python 中，我们遵循“鸭子类型”编程风格，极少对变量进行严格的类型检查。“鸭子类型”是一种非常实用的编程风格，但也有缺乏标准、过于隐式的缺点。为了部分弥补这些缺点，我们可以用抽象类来实现更灵活的子类化检查。</p>\n<p>在创建类时，你除了可以定义普通方法外，还可以通过 <code>@classmethod</code>、<code>@property</code> 等装饰器定义许多特殊对象，这些对象在各自的适宜场景下可以发挥重要作用。</p>\n<p>在 Python 中，一个类可以同时继承多个基类，Mixin 模式正是依赖这种技术实现的。但多重继承非常复杂、容易搞砸，使用时请务必当心。</p>\n<p>本章讲述了一个和继承有关的案例故事。虽然继承是面向对象的基本特征之一，但它也很容易被误用。你应该学会判断何时该使用继承，何时该用组合代替继承。</p>\n<p>在下一章里，我们会通过一些实际案例，继续深入探索一些经典的面向对象设计原则。</p>\n<p>以下是本章要点知识总结。</p>\n<p>(1) 语言基础知识</p>\n<ul>\n<li>类与实例的数据，都保存在一个名为 <code>__dict__</code> 的字典属性中</li>\n<li>灵活利用 <code>__dict__</code> 属性，能帮你做到常规做法难以完成的一些事情</li>\n<li>使用 <code>@classmethod</code> 可以定义类方法，类方法常用作工厂方法</li>\n<li>使用 <code>@staticmethod</code> 可以定义静态方法，静态方法不依赖实例状态，是一种无状态方法</li>\n<li>使用 <code>@property</code> 可以定义动态属性对象，该属性对象的获取、设置和删除行为都支持自定义</li>\n</ul>\n<p>(2) 面向对象高级特性</p>\n<ul>\n<li>Python 使用 MRO 算法来确定多重继承时的方法优先级</li>\n<li><code>super()</code> 函数获取的并不是当前类的父类，而是当前 MRO 链条里的下一个类</li>\n<li>Mixin 是一种基于多重继承的有效编程模式，用好 Mixin 需要精心的设计</li>\n<li>元类的功能相当强大，但同时也相当复杂，除非开发一些框架类工具，否则你极少需要使用元类</li>\n<li>元类有许多更简单的替代品，比如类装饰器、子类化钩子方法等</li>\n<li>通过定义 <code>__init_subclass__</code> 钩子方法，你可以在某个类被继承时执行自定义逻辑</li>\n</ul>\n<p>(3) 鸭子类型与抽象类</p>\n<ul>\n<li>鸭鸭“鸭子类型”是 Python 语言最为鲜明的特点之一，在该风格下，一般不做任何严格的类型检查</li>\n<li>虽然“鸭子类型”非常实用，但是它有两个明显的缺点——缺乏标准和过于隐式</li>\n<li>抽象类提供了一种更灵活的子类化机制，我们可以通过定义抽象类来改变 <code>isinstance()</code> 的行为</li>\n<li>通过 <code>@abstractmethod</code> 装饰器，你可以要求抽象类的子类必须实现某个方法</li>\n</ul>\n<p>(4) 面向对象设计</p>\n<ul>\n<li>继承提供了相当强大的代码复用机制，但同时也带来了非常紧密的耦合关系</li>\n<li>错误使用继承容易导致代码失控</li>\n<li>对事物的行为而不是事物本身建模，更容易孵化出好的面向对象设计</li>\n<li>在创建继承关系时应当谨慎。用组合来替代继承有时是更好的做法</li>\n</ul>\n<p>(5) 函数与面向对象的配合</p>\n<ul>\n<li>Python 里的面向对象不必特别纯粹，假如用函数打一点儿配合，你可以设计出更好的代码</li>\n<li>可以像 <code>requests</code> 模块一样，用函数为自己的面向对象模块实现一些更易用的 API</li>\n<li>在 Python 中，我们极少会应用真正的“单例模式”，大多数情况下，一个简单的模块级全局对象就够了</li>\n<li>使用“预绑定方法模式”，你可以快速为普通实例包装出类似普通函数的 API</li>\n</ul>\n<p>(6) 代码编写细节</p>\n<ul>\n<li>Python 的成员私有协议并不严格，如果你想标示某个属性为私有，使用单下划线前缀就够了</li>\n<li>编写类时，类方法排序应该遵循某种特殊规则，把读者最关心的内容摆在最前面</li>\n<li>多态是面向对象编程里的基本概念，同时也是最强大的思维工具之一</li>\n<li>多态可能的介入时机：许多类似的条件分支判断、许多针对类型的 <code>isinstance()</code> 判断</li>\n</ul>\n\n<br style=\"page-break-after:always\" />","comments":[]}