{"id":75702,"title":"41 | 动态规划理论：一篇文章带你彻底搞懂最优子结构、无后效性和重复子问题","content":"<p>上一节，我通过两个非常经典的问题，向你展示了用动态规划解决问题的过程。现在你对动态规划应该有了一个初步的认识。</p><p>今天，我主要讲动态规划的一些理论知识。学完这节内容，可以帮你解决这样几个问题：什么样的问题可以用动态规划解决？解决动态规划问题的一般思考过程是什么样的？贪心、分治、回溯、动态规划这四种算法思想又有什么区别和联系？</p><p>理论的东西都比较抽象，不过你不用担心，我会结合具体的例子来讲解，争取让你这次就能真正理解这些知识点，也为后面的应用和实战做好准备。</p><h2>“一个模型三个特征”理论讲解</h2><p>什么样的问题适合用动态规划来解决呢？换句话说，动态规划能解决的问题有什么规律可循呢？实际上，动态规划作为一个非常成熟的算法思想，很多人对此已经做了非常全面的总结。我把这部分理论总结为“一个模型三个特征”。</p><p>首先，我们来看，什么是“<strong>一个模型</strong>”？它指的是动态规划适合解决的问题的模型。我把这个模型定义为“<strong>多阶段决策最优解模型</strong>”。下面我具体来给你讲讲。</p><p>我们一般是用动态规划来解决最优问题。而解决问题的过程，需要经历多个决策阶段。每个决策阶段都对应着一组状态。然后我们寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。</p><!-- [[[read_end]]] --><p>现在，我们再来看，什么是“<strong>三个特征</strong>”？它们分别是<strong>最优子结构</strong>、<strong>无后效性</strong>和<strong>重复子问题</strong>。这三个概念比较抽象，我来逐一详细解释一下。</p><h3>1.最优子结构</h3><p>最优子结构指的是，问题的最优解包含子问题的最优解。反过来说就是，我们可以通过子问题的最优解，推导出问题的最优解。如果我们把最优子结构，对应到我们前面定义的动态规划问题模型上，那我们也可以理解为，后面阶段的状态可以通过前面阶段的状态推导出来。</p><h3>2.无后效性</h3><p>无后效性有两层含义，第一层含义是，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。无后效性是一个非常“宽松”的要求。只要满足前面提到的动态规划问题模型，其实基本上都会满足无后效性。</p><h3>3.重复子问题</h3><p>这个概念比较好理解。前面一节，我已经多次提过。如果用一句话概括一下，那就是，不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。</p><h2>“一个模型三个特征”实例剖析</h2><p>“一个模型三个特征”这部分是理论知识，比较抽象，你看了之后可能还是有点懵，有种似懂非懂的感觉，没关系，这个很正常。接下来，我结合一个具体的动态规划问题，来给你详细解释。</p><p>假设我们有一个n乘以n的矩阵w[n][n]。矩阵存储的都是正整数。棋子起始位置在左上角，终止位置在右下角。我们将棋子从左上角移动到右下角。每次只能向右或者向下移动一位。从左上角到右下角，会有很多不同的路径可以走。我们把每条路径经过的数字加起来看作路径的长度。那从左上角移动到右下角的最短路径长度是多少呢？</p><p><img src=\"https://static001.geekbang.org/resource/image/65/9f/652dff86c5dcc6a0e2a0de9a814b079f.jpg?wh=1142*616\" alt=\"\"></p><p>我们先看看，这个问题是否符合“一个模型”？</p><p>从(0, 0)走到(n-1, n-1)，总共要走2*(n-1)步，也就对应着2*(n-1)个阶段。每个阶段都有向右走或者向下走两种决策，并且每个阶段都会对应一个状态集合。</p><p>我们把状态定义为min_dist(i, j)，其中i表示行，j表示列。min_dist表达式的值表示从(0, 0)到达(i, j)的最短路径长度。所以，这个问题是一个多阶段决策最优解问题，符合动态规划的模型。</p><p><img src=\"https://static001.geekbang.org/resource/image/b0/69/b0da245a38fafbfcc590782486b85269.jpg?wh=1888*878\" alt=\"\"></p><p>我们再来看，这个问题是否符合“三个特征”？</p><p>我们可以用回溯算法来解决这个问题。如果你自己写一下代码，画一下递归树，就会发现，递归树中有重复的节点。重复的节点表示，从左上角到节点对应的位置，有多种路线，这也能说明这个问题中存在重复子问题。</p><p><img src=\"https://static001.geekbang.org/resource/image/64/65/64403695861da87f41f7b2ec83d44365.jpg?wh=1142*490\" alt=\"\"></p><p>如果我们走到(i, j)这个位置，我们只能通过(i-1, j)，(i, j-1)这两个位置移动过来，也就是说，我们想要计算(i, j)位置对应的状态，只需要关心(i-1, j)，(i, j-1)两个位置对应的状态，并不关心棋子是通过什么样的路线到达这两个位置的。而且，我们仅仅允许往下和往右移动，不允许后退，所以，前面阶段的状态确定之后，不会被后面阶段的决策所改变，所以，这个问题符合“无后效性”这一特征。</p><p>刚刚定义状态的时候，我们把从起始位置(0, 0)到(i, j)的最小路径，记作min_dist(i, j)。因为我们只能往右或往下移动，所以，我们只有可能从(i, j-1)或者(i-1, j)两个位置到达(i, j)。也就是说，到达(i, j)的最短路径要么经过(i, j-1)，要么经过(i-1, j)，而且到达(i, j)的最短路径肯定包含到达这两个位置的最短路径之一。换句话说就是，min_dist(i, j)可以通过min_dist(i, j-1)和min_dist(i-1, j)两个状态推导出来。这就说明，这个问题符合“最优子结构”。</p><pre><code>min_dist(i, j) = w[i][j] + min(min_dist(i, j-1), min_dist(i-1, j))\n</code></pre><h2>两种动态规划解题思路总结</h2><p>刚刚我讲了，如何鉴别一个问题是否可以用动态规划来解决。现在，我再总结一下，动态规划解题的一般思路，让你面对动态规划问题的时候，能够有章可循，不至于束手无策。</p><p>我个人觉得，解决动态规划问题，一般有两种思路。我把它们分别叫作，状态转移表法和状态转移方程法。</p><h3>1.状态转移表法</h3><p>一般能用动态规划解决的问题，都可以使用回溯算法的暴力搜索解决。所以，当我们拿到问题的时候，我们可以先用简单的回溯算法解决，然后定义状态，每个状态表示一个节点，然后对应画出递归树。从递归树中，我们很容易可以看出来，是否存在重复子问题，以及重复子问题是如何产生的。以此来寻找规律，看是否能用动态规划解决。</p><p>找到重复子问题之后，接下来，我们有两种处理思路，第一种是直接用<strong>回溯加“备忘录”</strong>的方法，来避免重复子问题。从执行效率上来讲，这跟动态规划的解决思路没有差别。第二种是使用动态规划的解决方法，<strong>状态转移表法</strong>。第一种思路，我就不讲了，你可以看看上一节的两个例子。我们重点来看状态转移表法是如何工作的。</p><p>我们先画出一个状态表。状态表一般都是二维的，所以你可以把它想象成二维数组。其中，每个状态包含三个变量，行、列、数组值。我们根据决策的先后过程，从前往后，根据递推关系，分阶段填充状态表中的每个状态。最后，我们将这个递推填表的过程，翻译成代码，就是动态规划代码了。</p><p>尽管大部分状态表都是二维的，但是如果问题的状态比较复杂，需要很多变量来表示，那对应的状态表可能就是高维的，比如三维、四维。那这个时候，我们就不适合用状态转移表法来解决了。一方面是因为高维状态转移表不好画图表示，另一方面是因为人脑确实很不擅长思考高维的东西。</p><p>现在，我们来看一下，如何套用这个状态转移表法，来解决之前那个矩阵最短路径的问题？</p><p>从起点到终点，我们有很多种不同的走法。我们可以穷举所有走法，然后对比找出一个最短走法。不过如何才能无重复又不遗漏地穷举出所有走法呢？我们可以用回溯算法这个比较有规律的穷举算法。</p><p>回溯算法的代码实现如下所示。代码很短，而且我前面也分析过很多回溯算法的例题，这里我就不多做解释了，你自己来看看。</p><pre><code>private int minDist = Integer.MAX_VALUE; // 全局变量或者成员变量\n// 调用方式：minDistBacktracing(0, 0, 0, w, n);\npublic void minDistBT(int i, int j, int dist, int[][] w, int n) {\n  // 到达了n-1, n-1这个位置了，这里看着有点奇怪哈，你自己举个例子看下\n  if (i == n &amp;&amp; j == n) {\n    if (dist &lt; minDist) minDist = dist;\n    return;\n  }\n  if (i &lt; n) { // 往下走，更新i=i+1, j=j\n    minDistBT(i + 1, j, dist+w[i][j], w, n);\n  }\n  if (j &lt; n) { // 往右走，更新i=i, j=j+1\n    minDistBT(i, j+1, dist+w[i][j], w, n);\n  }\n}\n</code></pre><p>有了回溯代码之后，接下来，我们要画出递归树，以此来寻找重复子问题。在递归树中，一个状态（也就是一个节点）包含三个变量(i, j, dist)，其中i，j分别表示行和列，dist表示从起点到达(i, j)的路径长度。从图中，我们看出，尽管(i, j, dist)不存在重复的，但是(i, j)重复的有很多。对于(i, j)重复的节点，我们只需要选择dist最小的节点，继续递归求解，其他节点就可以舍弃了。</p><p><img src=\"https://static001.geekbang.org/resource/image/2c/e2/2c3ec820fa8f8cc7df838c0304b030e2.jpg?wh=1142*745\" alt=\"\"></p><p>既然存在重复子问题，我们就可以尝试看下，是否可以用动态规划来解决呢？</p><p>我们画出一个二维状态表，表中的行、列表示棋子所在的位置，表中的数值表示从起点到这个位置的最短路径。我们按照决策过程，通过不断状态递推演进，将状态表填好。为了方便代码实现，我们按行来进行依次填充。</p><p><img src=\"https://static001.geekbang.org/resource/image/b3/ca/b3f0de1c81533a0d24c43426eaf09aca.jpg?wh=1142*685\" alt=\"\"><img src=\"https://static001.geekbang.org/resource/image/05/7d/05a48baf7fb4d251bf5078840079107d.jpg?wh=1142*612\" alt=\"\"></p><p>弄懂了填表的过程，代码实现就简单多了。我们将上面的过程，翻译成代码，就是下面这个样子。结合着代码、图和文字描述，应该更容易理解我讲的内容。</p><pre><code>public int minDistDP(int[][] matrix, int n) {\n  int[][] states = new int[n][n];\n  int sum = 0;\n  for (int j = 0; j &lt; n; ++j) { // 初始化states的第一行数据\n    sum += matrix[0][j];\n    states[0][j] = sum;\n  }\n  sum = 0;\n  for (int i = 0; i &lt; n; ++i) { // 初始化states的第一列数据\n    sum += matrix[i][0];\n    states[i][0] = sum;\n  }\n  for (int i = 1; i &lt; n; ++i) {\n    for (int j = 1; j &lt; n; ++j) {\n      states[i][j] = \n            matrix[i][j] + Math.min(states[i][j-1], states[i-1][j]);\n    }\n  }\n  return states[n-1][n-1];\n}\n</code></pre><h3>2.状态转移方程法</h3><p>状态转移方程法有点类似递归的解题思路。我们需要分析，某个问题如何通过子问题来递归求解，也就是所谓的最优子结构。根据最优子结构，写出递归公式，也就是所谓的状态转移方程。有了状态转移方程，代码实现就非常简单了。一般情况下，我们有两种代码实现方法，一种是<strong>递归加“备忘录”</strong>，另一种是<strong>迭代递推</strong>。</p><p>我们还是拿刚才的例子来举例。最优子结构前面已经分析过了，你可以回过头去再看下。为了方便你查看，我把状态转移方程放到这里。</p><pre><code>min_dist(i, j) = w[i][j] + min(min_dist(i, j-1), min_dist(i-1, j))\n</code></pre><p>这里我强调一下，<strong>状态转移方程是解决动态规划的关键。</strong>如果我们能写出状态转移方程，那动态规划问题基本上就解决一大半了，而翻译成代码非常简单。但是很多动态规划问题的状态本身就不好定义，状态转移方程也就更不好想到。</p><p>下面我用递归加“备忘录”的方式，将状态转移方程翻译成来代码，你可以看看。对于另一种实现方式，跟状态转移表法的代码实现是一样的，只是思路不同。</p><pre><code>private int[][] matrix = \n         {{1，3，5，9}, {2，1，3，4}，{5，2，6，7}，{6，8，4，3}};\nprivate int n = 4;\nprivate int[][] mem = new int[4][4];\npublic int minDist(int i, int j) { // 调用minDist(n-1, n-1);\n  if (i == 0 &amp;&amp; j == 0) return matrix[0][0];\n  if (mem[i][j] &gt; 0) return mem[i][j];\n  int minLeft = Integer.MAX_VALUE;\n  if (j-1 &gt;= 0) {\n    minLeft = minDist(i, j-1);\n  }\n  int minUp = Integer.MAX_VALUE;\n  if (i-1 &gt;= 0) {\n    minUp = minDist(i-1, j);\n  }\n  \n  int currMinDist = matrix[i][j] + Math.min(minLeft, minUp);\n  mem[i][j] = currMinDist;\n  return currMinDist;\n}\n</code></pre><p>两种动态规划解题思路到这里就讲完了。我要强调一点，不是每个问题都同时适合这两种解题思路。有的问题可能用第一种思路更清晰，而有的问题可能用第二种思路更清晰，所以，你要结合具体的题目来看，到底选择用哪种解题思路。</p><h2>四种算法思想比较分析</h2><p>到今天为止，我们已经学习了四种算法思想，贪心、分治、回溯和动态规划。今天的内容主要讲些理论知识，我正好一块儿也分析一下这四种算法，看看它们之间有什么区别和联系。</p><p>如果我们将这四种算法思想分一下类，那贪心、回溯、动态规划可以归为一类，而分治单独可以作为一类，因为它跟其他三个都不大一样。为什么这么说呢？前三个算法解决问题的模型，都可以抽象成我们今天讲的那个多阶段决策最优解模型，而分治算法解决的问题尽管大部分也是最优解问题，但是，大部分都不能抽象成多阶段决策模型。</p><p>回溯算法是个“万金油”。基本上能用的动态规划、贪心解决的问题，我们都可以用回溯算法解决。回溯算法相当于穷举搜索。穷举所有的情况，然后对比得到最优解。不过，回溯算法的时间复杂度非常高，是指数级别的，只能用来解决小规模数据的问题。对于大规模数据的问题，用回溯算法解决的执行效率就很低了。</p><p>尽管动态规划比回溯算法高效，但是，并不是所有问题，都可以用动态规划来解决。能用动态规划解决的问题，需要满足三个特征，最优子结构、无后效性和重复子问题。在重复子问题这一点上，动态规划和分治算法的区分非常明显。分治算法要求分割成的子问题，不能有重复子问题，而动态规划正好相反，动态规划之所以高效，就是因为回溯算法实现中存在大量的重复子问题。</p><p>贪心算法实际上是动态规划算法的一种特殊情况。它解决问题起来更加高效，代码实现也更加简洁。不过，它可以解决的问题也更加有限。它能解决的问题需要满足三个条件，最优子结构、无后效性和贪心选择性（这里我们不怎么强调重复子问题）。</p><p>其中，最优子结构、无后效性跟动态规划中的无异。“贪心选择性”的意思是，通过局部最优的选择，能产生全局的最优选择。每一个阶段，我们都选择当前看起来最优的决策，所有阶段的决策完成之后，最终由这些局部最优解构成全局最优解。</p><h2>内容小结</h2><p>今天的内容到此就讲完了，我带你来复习一下。</p><p>我首先讲了什么样的问题适合用动态规划解决。这些问题可以总结概括为“一个模型三个特征”。其中，“一个模型”指的是，问题可以抽象成分阶段决策最优解模型。“三个特征”指的是最优子结构、无后效性和重复子问题。</p><p>然后，我讲了两种动态规划的解题思路。它们分别是状态转移表法和状态转移方程法。其中，状态转移表法解题思路大致可以概括为，<strong>回溯算法实现-定义状态-画递归树-找重复子问题-画状态转移表-根据递推关系填表-将填表过程翻译成代码</strong>。状态转移方程法的大致思路可以概括为，<strong>找最优子结构-写状态转移方程-将状态转移方程翻译成代码</strong>。</p><p>最后，我们对比了之前讲过的四种算法思想。贪心、回溯、动态规划可以解决的问题模型类似，都可以抽象成多阶段决策最优解模型。尽管分治算法也能解决最优问题，但是大部分问题的背景都不适合抽象成多阶段决策模型。</p><p>今天的内容比较偏理论，可能会不好理解。很多理论知识的学习，单纯的填鸭式讲给你听，实际上效果并不好。要想真的把这些理论知识理解透，化为己用，还是需要你自己多思考，多练习。等你做了足够多的题目之后，自然就能自己悟出一些东西，这样再回过头来看理论，就会非常容易看懂。</p><p>所以，在今天的内容中，如果有哪些地方你还不能理解，那也没关系，先放一放。下一节，我会运用今天讲到的理论，再解决几个动态规划的问题。等你学完下一节，可以再回过头来看下今天的理论知识，可能就会有一种顿悟的感觉。</p><h2>课后思考</h2><p>硬币找零问题，我们在贪心算法那一节中讲过一次。我们今天来看一个新的硬币找零问题。假设我们有几种不同币值的硬币v1，v2，……，vn（单位是元）。如果我们要支付w元，求最少需要多少个硬币。比如，我们有3种不同的硬币，1元、3元、5元，我们要支付9元，最少需要3个硬币（3个3元的硬币）。</p><p>欢迎留言和我分享，也欢迎点击“<span class=\"orange\">请朋友读</span>”，把今天的内容分享给你的好友，和他一起讨论、学习。</p>","neighbors":{"left":{"article_title":"40 | 初识动态规划：如何巧妙解决“双十一”购物时的凑单问题？","id":74788},"right":{"article_title":"42 | 动态规划实战：如何实现搜索引擎中的拼写纠错功能？","id":75794}},"comments":[{"had_liked":false,"id":56577,"user_name":"yaya","can_delete":false,"product_type":"c1","uid":1233856,"ip_address":"","ucode":"8C7FAC8F828BA4","user_header":"https://static001.geekbang.org/account/avatar/00/12/d3/c0/d38daa2d.jpg","comment_is_top":false,"comment_ctime":1546496417,"is_pvip":false,"replies":[{"id":"20486","content":"👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1546566437,"ip_address":"","comment_id":56577,"utype":1}],"discussion_count":27,"race_medal":0,"score":"1384525965729","product_id":100017301,"comment_content":"可以看做爬阶梯问题，分别可以走1.3.5步，怎么最少走到9步，动态转移方程为f(9)=1+min(f(8),f(6),f(4))","like_count":323,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435129,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546566437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1234975,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d8/1f/c07a7575.jpg","nickname":"酸奶酸不酸","note":"","ucode":"E260BF354F6C6B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":203553,"discussion_content":"这个1是硬币个数，不是面值","likes_number":18,"is_delete":false,"is_hidden":false,"ctime":1584055541,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1019588,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8e/c4/8d1150f3.jpg","nickname":"Richie","note":"","ucode":"12314EF0347693","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":143318,"discussion_content":"高手，一下子帮我理解了动态转移方程。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1579500745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1205485,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJUhJakYu4BI7eFnheKDdibDjZqz32ia2rhN0Jz5YoR1ZRlDrLcFNr4MJnPg3WiaxaocWotOANeqsBibw/132","nickname":"小白","note":"","ucode":"862EA133563634","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261040,"discussion_content":"优秀","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588932808,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2832351,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/37/df/d49eab02.jpg","nickname":"拉布拉多、谁都能摸","note":"","ucode":"F4E4FDDFA0CCF4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531710,"discussion_content":"看到你的这个具体的例子就瞬间懂了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637394702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1020726,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/93/36/abb7bfe3.jpg","nickname":"Hhpon","note":"","ucode":"12FE37D4B67631","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":403530,"discussion_content":"可是1，3，5这三个面值只是例子呀，如果我们不知道硬币具体的面值、个数的话我们应该怎么办呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634100088,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2756739,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/10/83/0facd0eb.jpg","nickname":"利威尔兵长","note":"","ucode":"FDE0BD5BFB1B4A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":395054,"discussion_content":"🐂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632208277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2440338,"avatar":"https://static001.geekbang.org/account/avatar/00/25/3c/92/81fa306d.jpg","nickname":"张Dave","note":"","ucode":"0E8B6FDEB7505B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372683,"discussion_content":"5+3+1=9，也是3个硬币，为啥不行？为啥是3个3元？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620434858,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2694205,"avatar":"https://static001.geekbang.org/account/avatar/00/29/1c/3d/76465ee4.jpg","nickname":"摘星","note":"","ucode":"55D8CAFC938F91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2440338,"avatar":"https://static001.geekbang.org/account/avatar/00/25/3c/92/81fa306d.jpg","nickname":"张Dave","note":"","ucode":"0E8B6FDEB7505B","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":543819,"discussion_content":"都可以啊，只是最少能凑成的数量是3个而已","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641307533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":372683,"ip_address":""},"score":543819,"extra":""}]},{"author":{"id":1438860,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f4/8c/0866b228.jpg","nickname":"子房","note":"","ucode":"CB05938C248BB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365442,"discussion_content":"厉害","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617801681,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1714081,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJu4p8ZheJ4KCLo6gI6VficSp1U4XCicfquprCavib6Xm0iaoXuwlLDgXxcosUSfiawfE1qFZhp9TG86Rg/132","nickname":"Geek_ttjjttjj","note":"","ucode":"6FE6FC8BBF0EBC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333706,"discussion_content":"为什么是走1，3，5，不是2 ,3, 4 或者 1，4，4等？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607600121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1625340,"avatar":"https://static001.geekbang.org/account/avatar/00/18/cc/fc/92646317.jpg","nickname":"骑着驴读着书的谢小夕","note":"","ucode":"56F0A469B630A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1714081,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJu4p8ZheJ4KCLo6gI6VficSp1U4XCicfquprCavib6Xm0iaoXuwlLDgXxcosUSfiawfE1qFZhp9TG86Rg/132","nickname":"Geek_ttjjttjj","note":"","ucode":"6FE6FC8BBF0EBC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349379,"discussion_content":"因为硬币的面值，只有这么几个。 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613141794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":333706,"ip_address":""},"score":349379,"extra":""}]},{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325689,"discussion_content":"老哥，这个牛叉。一针见血","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605407070,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1898292,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/jibauP3icEFic4w56L2ddVghL7h2gGKhFdW8lBfE9rpwwRgzUKkLFY9wb4w70AXz7retME96a6EBRTA0LvSLn0ib8A/132","nickname":"jack","note":"","ucode":"A2253AC8570C5E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311489,"discussion_content":"一针见血","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602373375,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1336634,"avatar":"https://static001.geekbang.org/account/avatar/00/14/65/3a/bc801fb2.jpg","nickname":"mqray","note":"","ucode":"15664507AD7033","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":279619,"discussion_content":"第一反应也是爬楼梯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591371275,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1358312,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b9/e8/0b3cf295.jpg","nickname":"HaiSky","note":"","ucode":"ECE7C263142432","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278134,"discussion_content":"这个厉害了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591153998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1640973,"avatar":"https://static001.geekbang.org/account/avatar/00/19/0a/0d/7bac5bcb.jpg","nickname":"maybe","note":"","ucode":"2C0D1D26853DB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":107767,"discussion_content":"有大佬出来解释下这个转移方程吗，有点看不懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577605226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":6,"child_discussions":[{"author":{"id":1645302,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1a/f6/19e67bea.jpg","nickname":"モブ","note":"","ucode":"01BE64E20DEF7C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1640973,"avatar":"https://static001.geekbang.org/account/avatar/00/19/0a/0d/7bac5bcb.jpg","nickname":"maybe","note":"","ucode":"2C0D1D26853DB3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":126980,"discussion_content":"就是在有了那三种f之后再走一步就到顶了，于是加了1","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1578556634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":107767,"ip_address":""},"score":126980,"extra":""},{"author":{"id":1472863,"avatar":"https://static001.geekbang.org/account/avatar/00/16/79/5f/8c9d0643.jpg","nickname":"晚空城旧心","note":"","ucode":"5C6D22728C9380","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1640973,"avatar":"https://static001.geekbang.org/account/avatar/00/19/0a/0d/7bac5bcb.jpg","nickname":"maybe","note":"","ucode":"2C0D1D26853DB3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":157100,"discussion_content":"f(n)= 1 + min(f(n - 1),f(n - 3),f(n - 5))","likes_number":25,"is_delete":false,"is_hidden":false,"ctime":1580441636,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":107767,"ip_address":""},"score":157100,"extra":""},{"author":{"id":1158349,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ac/cd/fda6374f.jpg","nickname":"Louis","note":"","ucode":"BC667839F17937","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645302,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1a/f6/19e67bea.jpg","nickname":"モブ","note":"","ucode":"01BE64E20DEF7C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":177182,"discussion_content":"更准确应该是再走一次吧？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1582083820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":126980,"ip_address":""},"score":177182,"extra":""}]},{"author":{"id":1361314,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c5/a2/5788e409.jpg","nickname":"三石","note":"","ucode":"32C04A2586E8D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":989,"discussion_content":"不用加1吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562224477,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1019302,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8d/a6/22c37c91.jpg","nickname":"楊_宵夜","note":"","ucode":"7BA0CADC5F23BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1361314,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c5/a2/5788e409.jpg","nickname":"三石","note":"","ucode":"32C04A2586E8D0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":147652,"discussion_content":"f(8) + 1(个1块钱硬币)\nf(6) + 1(个3块钱硬币)\nf(4) + 1(个5块钱硬币)","likes_number":22,"is_delete":false,"is_hidden":false,"ctime":1579664475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":989,"ip_address":""},"score":147652,"extra":""},{"author":{"id":1309592,"avatar":"https://static001.geekbang.org/account/avatar/00/13/fb/98/6f238b8e.jpg","nickname":"半个柚子","note":"","ucode":"CF5D1190D970A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1361314,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c5/a2/5788e409.jpg","nickname":"三石","note":"","ucode":"32C04A2586E8D0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":182415,"discussion_content":"不加1 怎么统计需要多少个钱币或者多少步呢","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1582423411,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":989,"ip_address":""},"score":182415,"extra":""},{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1309592,"avatar":"https://static001.geekbang.org/account/avatar/00/13/fb/98/6f238b8e.jpg","nickname":"半个柚子","note":"","ucode":"CF5D1190D970A9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":216427,"discussion_content":"老哥这个评论形象了，给赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585449490,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":182415,"ip_address":""},"score":216427,"extra":""}]}]},{"had_liked":false,"id":56582,"user_name":"郭霖","can_delete":false,"product_type":"c1","uid":1114433,"ip_address":"","ucode":"C2ADA402806514","user_header":"https://static001.geekbang.org/account/avatar/00/11/01/41/72237894.jpg","comment_is_top":false,"comment_ctime":1546499480,"is_pvip":false,"discussion_count":10,"race_medal":0,"score":"297899242904","product_id":100017301,"comment_content":"动态规划状态转移表解法：<br><br>public int minCoins(int money) {<br>  if (money == 1 || money == 3 || money == 5) return 1;<br>  boolean [][] state = new boolean[money][money + 1];<br>  if (money &gt;= 1) state[0][1] = true;<br>  if (money &gt;= 3) state[0][3] = true;<br>  if (money &gt;= 5) state[0][5] = true;<br>  for (int i = 1; i &lt; money; i++) {<br>    for (int j = 1; j &lt;= money; j++) {<br>      if (state[i - 1][j]) {<br>        if (j + 1 &lt;= money) state[i][j + 1] = true;<br>        if (j + 3 &lt;= money) state[i][j + 3] = true;<br>        if (j + 5 &lt;= money) state[i][j + 5] = true;<br>        if (state[i][money]) return i + 1;<br>      }<br>    }<br>  }<br>  return money;<br>}","like_count":70,"discussions":[{"author":{"id":1098637,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c3/8d/214ad614.jpg","nickname":"朱坤","note":"","ucode":"65224DA2456EAB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158165,"discussion_content":"本来想偷懒一下的，但看到郭霖老师的头像，就立马回到课后思考题，认真思考，然后动手做了一遍。。。感谢郭霖老师的激励。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1580558594,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2162521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/MaX06SRk19zM2lAaymYylpXD6LMtIPFlDyxZKgRhmZCjhNE4nIdDGBmh08razhebVCgAv54xialYBBIIwmleBew/132","nickname":"Geek_6d1382","note":"","ucode":"B61E65CFEB684F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":414428,"discussion_content":"看到郭老师了，苏州真香","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636733139,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1796438,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/zlWt0lPDicdib5BTUbuwA3wLLUuejtZ5icGu3DHMBPd6PicXOdhZ3zYFts8VkXjjyQuxzUJas2w5OTmx3icWKiaZM1Vg/132","nickname":"youyou.L","note":"","ucode":"B3DB0D0700EEAC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318907,"discussion_content":"空间降维的dp解法： \npublic int payDp(int cost){\n        int[] status = new int[cost + 1];\n        // 第一次特殊处理\n        for (int p : coins) {\n            ++status[p];\n        }\n        // 状态转移\n        for (int i = 1; i <= cost; ++i) {\n            for (int j = cost; j >= 0; --j) {\n                if (status[cost] != 0) {\n                    return status[cost];\n                }\n                if (status[j] == i) {\n                    for (int p : coins) {\n                        if (j + p <= cost) {\n                            status[j + p] = status[j] + 1;\n                        }\n                    }\n                }\n            }\n        }\n        // 凑不到cost元\n        return -1;\n    }","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603878563,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1267621,"avatar":"https://static001.geekbang.org/account/avatar/00/13/57/a5/4d8f6e7d.jpg","nickname":"咕小咚","note":"","ucode":"1B6AF9766AB081","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":135125,"discussion_content":"for循环应该是j<money吧？j<=money虽然也不会越界，但是没有意义","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579071053,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1487456,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLzSRrK59sydq3k5uTE9SzPYShHo3PqGh8GTk3be0pHjS7eGTdw27cUyI0M4UEiaicoV2PJpiajWGTtQ/132","nickname":"wxj","note":"","ucode":"B9BFE650BC4A39","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1534,"discussion_content":"为什么是return money;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562678372,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1054598,"avatar":"https://static001.geekbang.org/account/avatar/00/10/17/86/416f772e.jpg","nickname":"shelldon","note":"","ucode":"BF8FE102D6DD1B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1487456,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLzSRrK59sydq3k5uTE9SzPYShHo3PqGh8GTk3be0pHjS7eGTdw27cUyI0M4UEiaicoV2PJpiajWGTtQ/132","nickname":"wxj","note":"","ucode":"B9BFE650BC4A39","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":20838,"discussion_content":"最糟糕的情况是用 money 张 1 元硬币去支付 money 元","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1569384046,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":1534,"ip_address":""},"score":20838,"extra":""},{"author":{"id":1636167,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Y5U2ADUvruWhziaB4tSyiaADbmIcWX3kgEjKCOWkHYsjibdjzCEKooRoIxKZekymzzIGCW5MrLVicKd4c1EbFRZfkA/132","nickname":"Geek_3c2128","note":"","ucode":"7C079FC032285C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1054598,"avatar":"https://static001.geekbang.org/account/avatar/00/10/17/86/416f772e.jpg","nickname":"shelldon","note":"","ucode":"BF8FE102D6DD1B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":95717,"discussion_content":"按道理讲,只要代码没问题,最糟糕全部用1元去支付的情况已经包含在遍历中,不需要单独拎出来,所以return什么都是不会被执行到的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577026207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":20838,"ip_address":""},"score":95717,"extra":""},{"author":{"id":1054598,"avatar":"https://static001.geekbang.org/account/avatar/00/10/17/86/416f772e.jpg","nickname":"shelldon","note":"","ucode":"BF8FE102D6DD1B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1636167,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Y5U2ADUvruWhziaB4tSyiaADbmIcWX3kgEjKCOWkHYsjibdjzCEKooRoIxKZekymzzIGCW5MrLVicKd4c1EbFRZfkA/132","nickname":"Geek_3c2128","note":"","ucode":"7C079FC032285C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":96369,"discussion_content":"是，为了让编译器通过，不加最后一句的话会提示该函数没有返回值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577061790,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":95717,"ip_address":""},"score":96369,"extra":""}]}]},{"had_liked":false,"id":75754,"user_name":"攻玉","can_delete":false,"product_type":"c1","uid":1256489,"ip_address":"","ucode":"191BA2197377B8","user_header":"https://static001.geekbang.org/account/avatar/00/13/2c/29/2380837c.jpg","comment_is_top":false,"comment_ctime":1552464196,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"263545469252","product_id":100017301,"comment_content":"<br># 1. 回溯 :  太慢了<br>coin = 0<br>def minCoin(money):<br>    global coin<br>    if money == 1: return 1<br>    if money == 2: return 2<br>    if money == 3: return 1<br>    if money == 4: return 2<br>    if money == 5: return 1<br>#    if money &lt;= 0: return <br><br>    coin = 1 + min(minCoin(money-1) , minCoin(money-3) , minCoin(money-5))<br>    print(money , coin)<br>    return coin<br><br>print(minCoin(10))<br><br><br># 2.写备忘录, 记录重复的递归项:<br># 速度提升不知道几十万倍 ! 缺点就是有递归层数的限制 , 超过最大递归层数(几百?)会报错<br>import numpy as np<br>map = {} # 初始化一个 dict<br>coin = 0<br>def minCoin(money):<br>    global coin<br>    # 先查表 : <br>    if money in map:  # 如果在 map 的第一列里面 , 说明记录过. <br>        return map[money]   # 直接返回 minCoin <br>    if money == 1: return 1<br>    if money == 2: return 2<br>    if money == 3: return 1<br>    if money == 4: return 2<br>    if money == 5: return 1<br>#    if money &lt;= 0: return <br><br>    coin = 1 + min(minCoin(money-1) , minCoin(money-3) , minCoin(money-5))<br>    map[money] = coin  # 放入map<br><br>    return coin<br>    <br>print(minCoin(100))   <br>print(map)<br><br><br>&#39;&#39;&#39;<br><br>#  3.DP .<br>### 备忘录有了, 我们尝试根据递推公式 :<br>#  coin = 1 + min(minCoin(money-1) , minCoin(money-3) , minCoin(money-5))<br>### 书写状态转移方程 : <br><br>s = {}   # 设 s 为状态数组 : <br>s[1] ,s[2] ,s[3] ,s[4] ,s[5]  = 1,2,1,2,1 <br><br>def minCoinDP(money):<br>    for i in range(6,money+1):<br>        s[i] = 1+ min(s[i-1],s[i-3],s[i-5])<br><br>    return s[money]<br><br><br>print(minCoinDP(10000))<br>","like_count":61,"discussions":[{"author":{"id":2962599,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/34/a7/52c4ea60.jpg","nickname":"年少挽滑稽世无双","note":"","ucode":"793DCBDE25A07B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577638,"discussion_content":"666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656252275,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181055,"avatar":"https://static001.geekbang.org/account/avatar/00/12/05/7f/d35ab9a1.jpg","nickname":"z.l","note":"","ucode":"805CC5784D3F76","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534890,"discussion_content":"S[1]到S[5]直接定义不妥吧？如果硬币面试是动态的咋整？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638289313,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1014534,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eq6LGLtCCNoIf8S09fxcvk1OrTicPibZgX3kf8aaowY5nD8mTicH9SZZ8SlxgJvppqPThK1cEibrlA7bw/132","nickname":"秦汉2022","note":"","ucode":"C99D56B44F79C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333674,"discussion_content":"很清楚","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607590558,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1169063,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d6/a7/ac23f5a6.jpg","nickname":"better","note":"","ucode":"AF1DB566EBB8A5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":205067,"discussion_content":"强大👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584259533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":69573,"user_name":"algo","can_delete":false,"product_type":"c1","uid":1177817,"ip_address":"","ucode":"31E898AE80B47B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f8/d9/db957e30.jpg","comment_is_top":false,"comment_ctime":1550789939,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"151874645299","product_id":100017301,"comment_content":"回溯算法实现矩阵最短路径会有边界问题，下面是修改后的代码。<br>private static int MIN_DIS = Integer.MAX_VALUE;<br>public static void minDisByBT(int i, int j, int[][] w, int n, int distance) {<br>        distance += w[i][j];<br>        if (i == n - 1 &amp;&amp; j == n - 1) {<br>            if (distance &lt; MIN_DIS) MIN_DIS = distance;<br>            return;<br>        }<br>        if (i &lt; n - 1) {<br>            minDisByBT(i + 1, j, w, n, distance);<br>        }<br>        if (j &lt; n - 1) {<br>            minDisByBT(i, j + 1, w, n, distance);<br>        }<br>    }","like_count":35,"discussions":[{"author":{"id":1358312,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b9/e8/0b3cf295.jpg","nickname":"HaiSky","note":"","ucode":"ECE7C263142432","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278137,"discussion_content":"你把数组长度减一传进去","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591154047,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1971013,"avatar":"","nickname":"resolutexjh","note":"","ucode":"F0B3B223B98A92","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544061,"discussion_content":"万万没想到居然给了一份越界的代码，还想着是不是缺条件了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641391848,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1785041,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/3c/d1/c802e741.jpg","nickname":"庆华","note":"","ucode":"74F9E71D690985","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531380,"discussion_content":"我也在这debug半天，发现数组越界了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637297519,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1810050,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9e/82/61e5acf7.jpg","nickname":"MooNight","note":"","ucode":"B5B5876841E33E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":265716,"discussion_content":"我也一直在纳闷儿，会数组越界","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589430001,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57345,"user_name":"feifei","can_delete":false,"product_type":"c1","uid":1105431,"ip_address":"","ucode":"B1F8AE3AD82C51","user_header":"https://static001.geekbang.org/account/avatar/00/10/de/17/75e2b624.jpg","comment_is_top":false,"comment_ctime":1546757889,"is_pvip":false,"replies":[{"id":"20710","content":"👍 都有这个似懂非懂的过程的 多练习 慢慢就有感觉了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1546825363,"ip_address":"","comment_id":57345,"utype":1}],"discussion_count":3,"race_medal":0,"score":"134690744065","product_id":100017301,"comment_content":"经过一个星期的努力，这个动态规划终于有点感觉了，今天来做题，我也来试试解这个题目，在看了第一个童鞋的解法后，感觉这个写的太死了，再就是没有反推出哪些币的组合，我就自己来实现了下！<br>我也想说动态规划的解，真不容易啊，我按照老师提供的方法，先使用回塑写出了暴力搜索，然后再画出了递归树，找到状态组合，然后才来写这个动态规划，感觉好复杂，不过吧，这个使用状态转移方程，我感觉更难，比这个递归还难写。。。。。。，最主要是这个状态想不到，但这个动态规划代码写完了，我又感觉能写方程了，我想哭。。。。。。。<br><br><br>public int countMoneyMin(int[] moneyItems, int resultMemory) {<br><br>    if (null == moneyItems || moneyItems.length &lt; 1) {<br>      return -1;<br>    }<br><br>    if (resultMemory &lt; 1) {<br>      return -1;<br>    }<br><br>    &#47;&#47; 计算遍历的层数，此按最小金额来支付即为最大层数<br>    int levelNum = resultMemory &#47; moneyItems[0];<br>    int leng = moneyItems.length;<br><br>    int[][] status = new int[levelNum][resultMemory + 1];<br><br>    &#47;&#47; 初始化状态数组<br>    for (int i = 0; i &lt; levelNum; i++) {<br>      for (int j = 0; j &lt; resultMemory + 1; j++) {<br>        status[i][j] = -1;<br>      }<br>    }<br><br>    &#47;&#47; 将第一层的数数据填充<br>    for (int i = 0; i &lt; leng; i++) {<br>      status[0][moneyItems[i]] = moneyItems[i];<br>    }<br><br>    int minNum = -1;<br><br>    &#47;&#47; 计算推导状态<br>    for (int i = 1; i &lt; levelNum; i++) {<br>      &#47;&#47; 推导出当前状态<br>      for (int j = 0; j &lt; resultMemory; j++) {<br>        if (status[i - 1][j] != -1) {<br>          &#47;&#47; 遍历元素,进行累加<br>          for (int k = 0; k &lt; leng; k++) {<br>            if (j + moneyItems[k] &lt;= resultMemory) {<br>              status[i][j + moneyItems[k]] = moneyItems[k];<br>            }<br>          }<br>        }<br><br>        &#47;&#47; 找到最小的张数<br>        if (status[i][resultMemory] &gt;= 0) {<br>          minNum = i + 1;<br>          break;<br>        }<br>      }<br><br>      if (minNum &gt; 0) {<br>        break;<br>      }<br>    }<br><br>    int befValue = resultMemory;<br><br>    &#47;&#47; 进行反推出，币的组合<br>    for (int i = minNum - 1; i &gt;= 0; i--) {<br>      for (int j = resultMemory; j &gt;= 0; j--) {<br>        if (j == befValue) {<br>          System.out.println(&quot;当前的为:&quot; + status[i][j]);<br>          befValue = befValue - status[i][j];<br>          break;<br>        }<br>      }<br>    }<br><br>    return minNum;<br>  }","like_count":31,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435535,"discussion_content":"👍 都有这个似懂非懂的过程的 多练习 慢慢就有感觉了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546825363,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2474580,"avatar":"https://static001.geekbang.org/account/avatar/00/25/c2/54/77dac43b.jpg","nickname":"UltramanTiga","note":"","ucode":"245D8768E5CCDD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579934,"discussion_content":"我刚写的也是这样，就是填二维表，按部就班来的感觉，不过大家的都好简洁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657780661,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1237824,"avatar":"","nickname":"罗先森","note":"","ucode":"E1734A5ADD629C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324813,"discussion_content":"这种方法好像会超时","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605174206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":197700,"user_name":"邢世宝","can_delete":false,"product_type":"c1","uid":1113854,"ip_address":"","ucode":"7A58863FC89052","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/fe/12638c5b.jpg","comment_is_top":false,"comment_ctime":1585392709,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"91779705925","product_id":100017301,"comment_content":"课后习题用leetcode-322验证自己实现是否正确","like_count":21},{"had_liked":false,"id":56566,"user_name":"煦暖","can_delete":false,"product_type":"c1","uid":1245418,"ip_address":"","ucode":"96D0B236C4148A","user_header":"https://static001.geekbang.org/account/avatar/00/13/00/ea/6ad346c1.jpg","comment_is_top":false,"comment_ctime":1546493369,"is_pvip":false,"replies":[{"id":"21319","content":"嗯嗯 是的 笔误  抱歉","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1547262049,"ip_address":"","comment_id":56566,"utype":1}],"discussion_count":1,"race_medal":0,"score":"61676035513","product_id":100017301,"comment_content":"状态转移表法，二维状态表的图中，第一行下面的表达式：<br>文中“min(4+3, 8+3)”应该是“min(4+3, 9+3)”","like_count":14,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435120,"discussion_content":"嗯嗯 是的 笔误  抱歉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547262049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75413,"user_name":"攻玉","can_delete":false,"product_type":"c1","uid":1256489,"ip_address":"","ucode":"191BA2197377B8","user_header":"https://static001.geekbang.org/account/avatar/00/13/2c/29/2380837c.jpg","comment_is_top":false,"comment_ctime":1552393517,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"53092001069","product_id":100017301,"comment_content":"import numpy as np<br>老师 , 那个回溯法的代码好像不太对 , 我用 python 写了一个<br>import sys<br>minDist = sys.maxsize<br>n = 4  # 这是个 4*4 的矩阵 . <br>w = np.array([[0,3,5,9],[2,1,3,4],[5,2,6,7],[6,8,4,3]])<br># dist = np.zeros((4,4))  # 定义 dist(i, j) 为到达点 (i,j) 的路径长度<br># dist[i, j] = w[i,j] + min(dist[i-1, j] , dist[i, j-1])<br><br>def minDistBackTrace(i, j, dist, w, n):<br>    global minDist<br>    dist += w[i][j] <br>    if i==n -1 and j == n-1 :<br>        if dist &lt; minDist: minDist = dist<br>        return<br><br>    if i &lt; n-1: <br>        minDistBackTrace(i + 1, j, dist, w, n)<br>    if j &lt; n-1: <br>        minDistBackTrace(i , j + 1, dist, w, n)  \t<br><br>","like_count":12,"discussions":[{"author":{"id":1113854,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fe/fe/12638c5b.jpg","nickname":"邢世宝","note":"","ucode":"7A58863FC89052","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215752,"discussion_content":"老师的回溯算法确实跑不起来，有数组移除的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585378965,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1086793,"avatar":"https://static001.geekbang.org/account/avatar/00/10/95/49/8e821e97.jpg","nickname":"Mr.D","note":"","ucode":"2D3BD7AEB83130","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2448,"discussion_content":"已测1/2/3/4 size的矩阵","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563631418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1086793,"avatar":"https://static001.geekbang.org/account/avatar/00/10/95/49/8e821e97.jpg","nickname":"Mr.D","note":"","ucode":"2D3BD7AEB83130","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2447,"discussion_content":"你这份是对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563631377,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":58016,"user_name":"猫头鹰爱拿铁","can_delete":false,"product_type":"c1","uid":1105958,"ip_address":"","ucode":"24266B58968428","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/26/4942a09e.jpg","comment_is_top":false,"comment_ctime":1546961063,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"48791601319","product_id":100017301,"comment_content":"看了这一篇豁然开朗，上一篇的习题也会做了。感觉这些涉及多决策的习题基本上第一眼都能想到回溯法，但是用动态规划法就要好好想一想，关键还是老师说的动态转移方程式。我尝试用两种方法做了一遍，回溯法和动态规划法。<br><br>int minNum = Integer.MAX_VALUE;<br><br>\t&#47;**<br>\t * 使用回溯法获取给定金额最小的硬币数量，调用时num为0<br>\t * <br>\t * @param coinVal<br>\t *            硬币值数组<br>\t * @param total<br>\t *            指定的金额<br>\t * @param num<br>\t *            每个解法所得到的硬币数量<br>\t *&#47;<br>\tpublic void getLeastCoinNumByBackTracking(int[] coinVal, int total, int num) {<br>\t\tif (total == 0) {<br>\t\t\tif (num &lt; minNum)<br>\t\t\t\tminNum = num;<br>\t\t\treturn;<br>\t\t}<br>\t\tfor (int i = 0; i &lt; coinVal.length; i++) {<br>\t\t\tif (total - coinVal[i] &gt;= 0) {<br>\t\t\t\tgetLeastCoinNumByBackTracking(coinVal, total - coinVal[i],<br>\t\t\t\t\t\tnum + 1);<br>\t\t\t}<br>\t\t}<br>\t}<br><br>\t&#47;**<br>\t * 使用动态规划法获取给定金额下最小的硬币数量<br>\t * <br>\t * @param coinVal<br>\t *            硬币值数组<br>\t * @param total<br>\t *            给定金额<br>\t * @return 给定金额下最小的硬币数量<br>\t *&#47;<br>\tpublic int getLeastCoinNumByDP(int[] coinVal, int total) {<br>\t\t&#47;&#47; coinNum存放的是每个对应金额下最少硬币的最优解<br>\t\tint coinNum[] = new int[total + 1];<br>\t\tcoinNum[0] = 0;<br>\t\t&#47;&#47;初始化coinNum数组，硬币值数组对应的值的硬币数量都为1<br>\t\tfor (int i = 0; i &lt; coinVal.length; i++) {<br>\t\t\tcoinNum[coinVal[i]] = 1;<br>\t\t}<br>\t\t<br>\t\tfor (int i = 1; i &lt;= total; i++) {<br>\t\t\tif (coinNum[i] == 0) {<br>\t\t\t\tint minTemp = Integer.MAX_VALUE; &#47;&#47; 获取每个i对应的最小硬币数值<br>\t\t\t\tfor (int j = 0; j &lt; coinVal.length; j++) {<br>\t\t\t\t\tif (i - coinVal[j] &gt; 0) {<br>\t\t\t\t\t\tint v1 = coinNum[i - coinVal[j]] + 1;<br>\t\t\t\t\t\tif (v1 &lt; minTemp) {<br>\t\t\t\t\t\t\tminTemp = v1;<br>\t\t\t\t\t\t}<br>\t\t\t\t\t}<br>\t\t\t\t}<br>\t\t\t\tcoinNum[i] = minTemp;<br>\t\t\t}<br>\t\t}<br>\t\treturn coinNum[total];<br>\t}","like_count":11,"discussions":[{"author":{"id":2718869,"avatar":"https://static001.geekbang.org/account/avatar/00/29/7c/95/db224274.jpg","nickname":"Aurora.","note":"","ucode":"8A908805080E74","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548427,"discussion_content":"回溯法的代码可以进行优化，存储重复计算的子问题","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1643189469,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72923,"user_name":"菜菜","can_delete":false,"product_type":"c1","uid":1243536,"ip_address":"","ucode":"888AC33663B774","user_header":"https://static001.geekbang.org/account/avatar/00/12/f9/90/f90903e5.jpg","comment_is_top":false,"comment_ctime":1551755485,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31616526557","product_id":100017301,"comment_content":"老师，回溯法求矩阵最短路径的代码会出错，边界条件的问题","like_count":7},{"had_liked":false,"id":154843,"user_name":"乾坤瞬间","can_delete":false,"product_type":"c1","uid":1683130,"ip_address":"","ucode":"15BDCF29CBF8EB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","comment_is_top":false,"comment_ctime":1574578594,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"27344382370","product_id":100017301,"comment_content":"我捋一下思路用 状态转移表法<br>1，首先这个问题适合用多阶段决策最优模型，不过唯一与前面的例子不同的是，这里的阶段不是很容易找，其实问题的期望实质上是保证走尽量少的阶段达到累计值到达期望值(9)，而我们前面接触的都是固定的阶段，所以从这一点上对动态规划的阶段概念又有了新认识<br>2，状态的定义，定义一个status[i][w]二维数组，i代表第i阶段，w表示第i阶段的累积值，且w不大于9.其实我把每一层的状态值定义为上一层的所有状态与本层的任一组合(1，3，5)的和这样我们就可以避免重复子结构(3-&gt;5与5-&gt;3的第二阶段的状态值都是8)的计算<br><br><br>","like_count":7,"discussions":[{"author":{"id":1138792,"avatar":"https://static001.geekbang.org/account/avatar/00/11/60/68/540a9004.jpg","nickname":"戒修","note":"","ucode":"EAECD493E06B66","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288091,"discussion_content":"二维数组定义状态太浪费空间了，如果w很大。力扣上有类似的题目，我就用的二维数组。提示内存使用过大。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1593650506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1661456,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epYAmnyHBCVY7YicTF3IXa39mvVTuyum9yicPyFG5amXuo6R2QOTicX0iaXLicH8CTktC7XHruv81ichgkg/132","nickname":"Geek_b25f99","note":"","ucode":"6F7BEAB2C31528","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73833,"discussion_content":"说得对，确实与讲的例子有所不同，这道题加深了新的认识","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575599969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":67319,"user_name":"随风","can_delete":false,"product_type":"c1","uid":1250040,"ip_address":"","ucode":"2883C362D6C2B4","user_header":"https://static001.geekbang.org/account/avatar/00/13/12/f8/888a9b9d.jpg","comment_is_top":false,"comment_ctime":1550129246,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"23024965726","product_id":100017301,"comment_content":"<br>看了这么久，很少留言、很多思考题也只停留在想的层面，很少去实现。刚好有点时间，把动态规则这个思考题想了一下，顺便用Java实现出来。<br>思考题：如上面值{1,3,5}凑9块钱的最小张数、我们可以分成3个阶段。<br>第一阶段：用1块钱，那么1块钱可以有1、2、3...9张这几种可能。<br>第二阶段：在第一阶段的金额还有张数上增加3元的<br>第三阶段：在第二阶段总金额上载增加5元的。<br>状态转移方程:Sum(n) = Sum(n-1) + v * num ,v表示当前阶段的面值，num表示当前阶段的张数。<br>代码实现如下：<br>public class DynMoney {<br>\tprivate static int minNum = Integer.MAX_VALUE;<br>\t&#47;**<br>\t * Sum(n) = Sum(n-1) + v * num<br>\t * @param sum 凑的总额<br>\t * @param v  钱的面额<br>\t * @return<br>\t *&#47;<br>\tpublic static int minMoney(int sum,int v[]) {<br>\t\tnextStep(0, 0, 0, sum, v);<br>\t\treturn minNum;<br>\t}<br>\t&#47;**<br>\t * @param n    钱的张数.<br>\t * @param c    到那个阶段<br>\t * @param cv   凑的钱数<br>\t * @param sum  要凑的钱的总数<br>\t * @param v    面额<br>\t *&#47;<br>\tpublic static void nextStep(int n,int c, int cv,int sum,int v[]) {<br>\t\t&#47;&#47;金额凑够了<br>\t\tif (cv == sum) {<br>\t\t\tminNum = Math.min(minNum, n);<br>\t\t\treturn;<br>\t\t}<br>\t\t&#47;&#47;或者凑到最后阶段，没凑够总金额<br>\t\tif(c == v.length) {<br>\t\t\treturn;<br>\t\t}<br>\t\t&#47;&#47;每个阶段，钱的张数，张数应该小与等于 凑的金额&#47;面额<br>\t\tfor(int j=0; j &lt;= sum&#47;v[c]; j++) {<br>\t\t\tif(cv + v[c]*j &lt;= sum) {<br>\t\t\t\t&#47;&#47;当前阶段凑的不超额，下阶段继续凑<br>\t\t\t\tnextStep(n+j, c+1,cv + v[c]*j, sum,v);<br>\t\t\t}<br>\t\t}<br>\t}<br><br>\tpublic static void main(String arg[]) {<br>\t\tSystem.out.println(minMoney(8, new int[]{1,3,5}));<br>\t}<br>}","like_count":5,"discussions":[{"author":{"id":1108788,"avatar":"https://static001.geekbang.org/account/avatar/00/10/eb/34/cd310e69.jpg","nickname":"行走的","note":"","ucode":"04772A8A1FF2B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":37327,"discussion_content":"看了这么多留言，这个留言的讲解是最清晰易懂的！点赞，这个流言的讲解应该🔝啊！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571579661,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1290245,"avatar":"https://static001.geekbang.org/account/avatar/00/13/b0/05/48e3f940.jpg","nickname":"无心","note":"","ucode":"2AD84413DB4A72","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1108788,"avatar":"https://static001.geekbang.org/account/avatar/00/10/eb/34/cd310e69.jpg","nickname":"行走的","note":"","ucode":"04772A8A1FF2B4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":124817,"discussion_content":"这个是回溯吧，穷举了所有的可能，也没有进行子问题去重，应该不能算动态规划吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578451924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":37327,"ip_address":""},"score":124817,"extra":""}]}]},{"had_liked":false,"id":258011,"user_name":"星夜","can_delete":false,"product_type":"c1","uid":1128491,"ip_address":"","ucode":"3B46C09D994CEB","user_header":"https://static001.geekbang.org/account/avatar/00/11/38/2b/9db9406b.jpg","comment_is_top":false,"comment_ctime":1604242305,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18784111489","product_id":100017301,"comment_content":"思考题接着码：<br>2.动态规划版本<br>private int coinPlan2(int[] coinTypes, int money) {<br>    int[] dp = new int[money + 1];<br>    Arrays.fill(dp, -1);<br>    dp[0] = 0;<br><br>    &#47;&#47; 按照硬币面值排序<br>    Arrays.sort(coinTypes);<br>    &#47;&#47; 复杂度O(M * N), 递推公式: f(n) = f(n - max(coinTypes)) + 1<br>    for (int i = 1; i &lt;= money; i++) {<br>        &#47;&#47; 从小问题开始解决，避免重复计算<br>        for (int j = coinTypes.length - 1; j &gt;= 0; j--) {<br>            if (coinTypes[j] &lt;= i &amp;&amp; dp[i - coinTypes[j]] &gt;= 0) {<br>                dp[i] = dp[i - coinTypes[j]] + 1;<br>                break;<br>            }<br>        }<br>    }<br><br>    &#47;&#47; 最少需要多少枚硬币<br>    return dp[money];<br>}","like_count":5},{"had_liked":false,"id":219626,"user_name":"强劲九","can_delete":false,"product_type":"c1","uid":1235372,"ip_address":"","ucode":"62DB1860386A38","user_header":"https://static001.geekbang.org/account/avatar/00/12/d9/ac/26ada7b8.jpg","comment_is_top":false,"comment_ctime":1590053192,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18769922376","product_id":100017301,"comment_content":"关于动态规划的练习，可以去 LeetCode 上看 liweiwei 的题解。他的题解做得非常的详细和用心，并且会给出不同问题相关题目。跟着把出现的问题解决了，应该能够有很大的提升。","like_count":4},{"had_liked":false,"id":69367,"user_name":"阿崔cxr","can_delete":false,"product_type":"c1","uid":1177565,"ip_address":"","ucode":"26E2C7D96306A4","user_header":"https://static001.geekbang.org/account/avatar/00/11/f7/dd/c85f2065.jpg","comment_is_top":false,"comment_ctime":1550728004,"is_pvip":false,"replies":[{"id":"24819","content":"我擦，我研究下","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1550831714,"ip_address":"","comment_id":69367,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18730597188","product_id":100017301,"comment_content":"老师，我按照文章里面的代码敲了一遍，<br>状态转移表法的那个代码运行结果等于 等于19<br>状态转移方程法的那个代码运行结果等于 18 <br><br>不知道大家是不是这样的？？？？？？","like_count":4,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440083,"discussion_content":"我擦，我研究下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550831714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1128596,"avatar":"https://static001.geekbang.org/account/avatar/00/11/38/94/42f053a4.jpg","nickname":"hugooyu-gcst","note":"","ucode":"905EDA90790FAD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":153163,"discussion_content":"minleft和minup的初始值如果小于1，计算结果就是18了，会加不到w(0，0)的值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580033448,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":55648,"user_name":"blacknhole","can_delete":false,"product_type":"c1","uid":1098286,"ip_address":"","ucode":"271682FFE28F25","user_header":"https://static001.geekbang.org/account/avatar/00/10/c2/2e/c4a527d9.jpg","comment_is_top":false,"comment_ctime":1546252649,"is_pvip":false,"replies":[{"id":"20189","content":"已改 多谢指正","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1546394427,"ip_address":"","comment_id":55648,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18726121833","product_id":100017301,"comment_content":"状态转移方程法的代码实现有问题：<br>1，int minUp = Integer.MIN_VALUE;语句应赋值为Integer.MAX_VALUE。<br>2，返回前应将返回值赋值给mem[i][j]。","like_count":4,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434821,"discussion_content":"已改 多谢指正","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546394427,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":55488,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1546216223,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18726085407","product_id":100017301,"comment_content":"2018最后一次更新，我通读三遍跟上打卡了。本节理论归纳的很精简，适合动态规划求解的问题的特性：一个模型，三个特征。<br>一个模型：多阶段决策最优解<br>三个特征：最优子结构，无后效性，重复子问题。<br>","like_count":4},{"had_liked":false,"id":57009,"user_name":"Kudo","can_delete":false,"product_type":"c1","uid":1036948,"ip_address":"","ucode":"21965914B72AEB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d2/94/8bd217f1.jpg","comment_is_top":false,"comment_ctime":1546599213,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14431501101","product_id":100017301,"comment_content":"思考题解答<br>使用回溯法（python实现）：<br>import sys<br>min_count = sys.maxsize # 用于追踪最小值<br><br>def minCoinCount(i, values, amount, ca):<br>    &#39;&#39;&#39;<br>    i: 硬币数量<br>    values: 硬币面值数组<br>    amount: 要凑的总价值<br>    ca: current amount 当前价值<br>    &#39;&#39;&#39;<br>    global min_count<br>    if ca == amount or i == amount: # 总共amount步<br>        if ca == amount and i &lt; min_count:<br>            min_count = i<br>        return<br>        <br>    for v in values: # 依次考察每种币值<br>        if ca + v &lt;= amount: # 保证不超总值价<br>            minCoinCount(i+1, values, amount, ca+v)<br>            <br># 使用方法<br>values = [1,3,5]<br>minCoinCount(0, values, 9, 0)<br>print(min_count)","like_count":3},{"had_liked":false,"id":55484,"user_name":"想当上帝的司机","can_delete":false,"product_type":"c1","uid":1239378,"ip_address":"","ucode":"D8251388854911","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/52/f07e9001.jpg","comment_is_top":false,"comment_ctime":1546214047,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14431115935","product_id":100017301,"comment_content":"放假了还在更新 赞","like_count":3},{"had_liked":false,"id":197577,"user_name":"邢世宝","can_delete":false,"product_type":"c1","uid":1113854,"ip_address":"","ucode":"7A58863FC89052","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/fe/12638c5b.jpg","comment_is_top":false,"comment_ctime":1585386100,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10175320692","product_id":100017301,"comment_content":"老师给的回溯法跑不通<br><br>    &#47;**<br>     * 求(0, 0)到(n-1, n-1)的最小和<br>     *<br>     * @param matrix 二维数组<br>     * @param i 开始的行坐标<br>     * @param j 开始的列坐标<br>     * @param n 数组长度<br>     * @param length 到达(i, j)节点的路径<br>     *&#47;<br>    private void minLength(int[][] matrix, int i, int j, int n, int length) {<br>        length = length + matrix[i][j];<br>        if (j == n - 1 &amp;&amp; i == n - 1) {<br>            if (length &lt; minLength) {<br>                minLength = length;<br>            }<br>            return;<br>        }<br><br>        if (i &lt; n - 1) {<br>            minLength(matrix, i + 1, j, n, length);<br>        }<br>        if (j &lt; n - 1) {<br>            minLength(matrix, i, j + 1, n, length);<br>        }<br>    }","like_count":2},{"had_liked":false,"id":172452,"user_name":"注定非凡","can_delete":false,"product_type":"c1","uid":1113597,"ip_address":"","ucode":"80673056E131B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","comment_is_top":false,"comment_ctime":1579180155,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10169114747","product_id":100017301,"comment_content":"二：动态规划理论之最优子结构，无后效性和重复子问题<br>\t\t<br>1，“一个模型三个特征”理论讲解<br>\t\t什么样的问题适合用动态规划来解决？<br>（1）“一个模型”<br>\t\t它指的是动态规划适合解决的问题的模型，“多阶段决策最优解模型”。<br>\t\t一般是用动态规划来解决最优问题，而解决问题的过程，需要经历多个决策阶段。每个决策阶段都对应一组状态。然后我们寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。<br>（2）“三个特征”：<br>\t\t他们分别是最优子结构，无后效性和重复子问题<br>\t1，最优子结构：<br>\t最优子结构指的是，问题的最优解包含子问题的最优解。即反之讲，可以通过子问题的最优解，推导出问题的最优解。<br>\t若把最优子结构，对应到前面定义的动态规划问题模型上，也可以理解为后面阶段的状态可以通过前面阶段的状态推导出来。<br>\t2，无后效性：<br>\t无后效性有两层含义，第一层含义是，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步步推导出来的，第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响，无后效性是一个非常“宽松”的要求。只要满足前面提到的动态规划问题模型，基本上都会满足无后效性。<br>\t3，重复子问题<br>\t不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态<br><br>三 两种动态规划解题思路总结<br>\t解决动态规划问题，一般有两种思路，分别可叫作，状态转移表法和状态转移方程法<br>\t1，状态转移表法<br>一般能用动态规划解决的问题，都可以使用回溯算法的暴力搜索解决。所以，当拿到问题时，可以先用简单的回溯算法解决，然后定义状态，每个状态表示一个节点，然后对应画出递归树。<br>从递归树中，很容易可以看出是否存在重复子问题，以及重复子问题是如何产生的。以此来寻找规律，看是否能用动态规划解决。<br>找到重复子问题之后，有两种处理思路，第一种是直接用回溯加“备忘录”的方法，来避免重复子问题。从执行效率上来将，这和动态规划的解决思路没有差别，第二种是使用动态规划的解决方法，状态转移表法。<br>\t\t<br>状态转移表法，<br>先画出一个状态表，状态表一般都是二维的其中每个状态包含三个变量，行，列，数组值。我们根据决策的先后过程，从前往后，根据递推关系，分阶段填充状态表中的每个状态。最后，将这个递推填表的过程，翻译成代码，就是动态规划代码了。<br> <br>状态转移方程法：<br>状态转移方程有点类似递归的解题思路，需要分析，某个问题如何通过子问题来递归求解，也就是所谓的最优子结构。根据最优子结构，写出递归公式，也就是所谓的状态转移方程。有了状态转移方程，代码实现就非常简单了，一般情况下，有两种代码实现的方法，一种是递归加“备忘录”，另一种是迭代递推。<br><br>状态转移方程是解决动态规划的关键，如果能写出状态转移方程，那动态规划问题基本上就解决一大半了，但是很多动态规划问题的状态本身就不好定义，状态转移方程也就更不好想到。<br>四 4种算法思想比较分析<br>\t如果将贪心，分治，回溯和动态规划四种算法思想分类，那贪心，回溯，动态规划可归为一类，而分治单独可以作为一类，因为它跟其他是三个都不大一样。<br>\t因为前三个算法解决问题的模型，都可以抽象成多阶段决策最优解模型，而分治算法解决问题尽管大部分也还是最优解问题，但大部分都不能抽象成多阶段决策模型。<br>\t回溯算法，是个万金油。基本上能用动态规划，贪心解决的问题，都可以用回溯算法解决。回溯算法相当于穷举搜索。穷举所有的情况，然后对比得到最优解。不过，回溯算法的时间复杂度非常高，是指数级别的，只能用来解决小规模数据的问题。对于大规模的数据问题，用回溯算法解决的执行效率很低。<br>\t动态规划算法，尽管比较回溯算法高效，但是，并不是所有问题都可以用动态规划来解决。能用动态规划解决的问题，需要满足三个特征：最优子结构，无后效性和重复子问题。在重复子问题这一点上，动态规划和分治算法的区分非常明显，分治算法要求分割成子问题，不能有重复字问题，而动态规划正好相反，动态规划之所以高效，就是因为回溯算法实现中存在大量的重复子问题。<br>\t贪心算法：实际上是动态规划算法中一种比较特殊情况。他解决问题更加高效，代码实现也更加简洁。不过，他可以解决的问题也更加有限。他能解决的问题需要满足三个条件，最优子结构，无后效性和贪心选择性。<br>\t其中，最优子结构，无后效性跟动态规划中的无异。“贪心选择性”的意思是，通过局部最优的选择，能产生全局的最优选择。每个阶段，我们都选择当前看起来最优的决策，所以阶段的决策完成之后，最终由这些局部最优解构成全局最优解。<br><br>","like_count":2},{"had_liked":false,"id":152254,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1573954051,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10163888643","product_id":100017301,"comment_content":"老师给的回溯法例子中边界的确有些问题。下面贴上修改后的实现：<br>  &#47;**<br>   * call minDist(0, 0, a[0][0], a, a.length)<br>   * @param i    cur row index<br>   * @param j    cur column index<br>   * @param dist cur distance,start from a[0][0]<br>   * @param a    array<br>   * @param n    length of the input array<br>   *&#47;<br>  public static void minDistBt(int i, int j, int dist, int[][] a, int n) {<br>    System.out.printf(&quot;%2d %2d\\n&quot;, i, j);<br>    if (i == n - 1 &amp;&amp; j == n - 1) {<br>      if (dist &lt; minDist)<br>        minDist = dist;<br>      return;<br>    }<br><br>    if (i + 1 &lt; n)<br>      minDistBt(i + 1, j, dist + a[i + 1][j], a, n);<br><br>    if (j + 1 &lt; n)<br>      minDistBt(i, j + 1, dist + a[i][j + 1], a, n);<br><br>  }","like_count":2},{"had_liked":false,"id":55535,"user_name":"farFlight","can_delete":false,"product_type":"c1","uid":1245211,"ip_address":"","ucode":"B0872D3ECBEC38","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83epbRibsic15KXfGEN3SSjnLhXGyhK2Uyrj5ibBJsKAjicNqtafDaQOLH4xpSJRZD1vmibFPJER1ySmwP9A/132","comment_is_top":false,"comment_ctime":1546225281,"is_pvip":false,"replies":[{"id":"20197","content":"高级篇会讲到","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1546394782,"ip_address":"","comment_id":55535,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10136159873","product_id":100017301,"comment_content":"用动态规划的方法，初始化那些等于币值的价值，然后从1开始一步一步推到w元，f(k)代表k元时最少的硬币数量，状态方程是：<br>f(k) = min(f(k-vi)) + 1, i需要遍历所有的币种。<br><br>另外，请问老师之后会多讲一些回溯的技巧吗？回溯方法虽然本身复杂度比较高，但是可以用一些剪枝技巧branch and bound，这样实际运行时间也能很快，而且很多复杂的问题用回溯法思路会比较简单。","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434793,"discussion_content":"高级篇会讲到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546394782,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257714,"user_name":"星夜","can_delete":false,"product_type":"c1","uid":1128491,"ip_address":"","ucode":"3B46C09D994CEB","user_header":"https://static001.geekbang.org/account/avatar/00/11/38/2b/9db9406b.jpg","comment_is_top":false,"comment_ctime":1604074387,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5899041683","product_id":100017301,"comment_content":"思考题：<br>1.回溯版本<br>private List&lt;Integer&gt; coinPlan(int[] coinTypes, int money) {<br>    &#47;&#47; 硬币面值排序<br>    Arrays.sort(coinTypes);<br>    List&lt;Integer&gt; plans = new ArrayList&lt;&gt;();<br>    boolean planRes = coinPlanCore(coinTypes, money, plans);<br>    if (planRes) {<br>        return plans;<br>    }<br>    return null;<br>}<br><br>private boolean coinPlanCore(int[] coinTypes, int money, List&lt;Integer&gt; plans) {<br>    if (money == 0) {<br>        return true;<br>    }<br>    if (money &lt; coinTypes[0]) {<br>        &#47;&#47; 低于最低面值<br>        return false;<br>    }<br><br>    &#47;&#47; 指数级时间复杂度<br>    for (int i = coinTypes.length - 1; i &gt;= 0; i--) {<br>        if (money &gt;= coinTypes[i]) {<br>            plans.add(coinTypes[i]);<br><br>            money -= coinTypes[i];<br>            boolean planCore = coinPlanCore(coinTypes, money, plans);<br>            if (planCore) {<br>                return true;<br>            }<br>            money += coinTypes[i];<br><br>            plans.remove(plans.size() - 1);<br>        }<br>    }<br>    return false;<br>}<br><br>public static void main(String... args) {<br>    CoinMoney coinMoney = new CoinMoney();<br>    System.out.println(coinMoney.coinPlan(new int[]{1, 3, 5}, 9));<br>    System.out.println(coinMoney.coinPlan(new int[]{1, 2, 5, 8, 10, 50}, 399));<br>    System.out.println(coinMoney.coinPlan(new int[]{1, 2, 5, 8, 10, 50}, 376));<br>    System.out.println(coinMoney.coinPlan(new int[]{1, 2, 5, 8, 10, 50}, 1));<br>}","like_count":1,"discussions":[{"author":{"id":1128491,"avatar":"https://static001.geekbang.org/account/avatar/00/11/38/2b/9db9406b.jpg","nickname":"星夜","note":"","ucode":"3B46C09D994CEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320105,"discussion_content":"思考题接着码：\n2.动态规划版本\nprivate int coinPlan2(int[] coinTypes, int money) {\n    int[] dp = new int[money + 1];\n    Arrays.fill(dp, -1);\n    dp[0] = 0;\n\n    // 按照硬币面值排序\n    Arrays.sort(coinTypes);\n    // 复杂度O(M * N), 递推公式: f(n) = f(n - max(coinTypes)) + 1\n    for (int i = 1; i <= money; i++) {\n        // 从小问题开始解决，避免重复计算\n        for (int j = coinTypes.length - 1; j >= 0; j--) {\n            if (coinTypes[j] <= i &amp;&amp; dp[i - coinTypes[j]] >= 0) {\n                dp[i] = dp[i - coinTypes[j]] + 1;\n                break;\n            }\n        }\n    }\n\n    // 最少需要多少枚硬币\n    return dp[money];\n}","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1604242248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":237730,"user_name":"Javatar","can_delete":false,"product_type":"c1","uid":2032840,"ip_address":"","ucode":"E216645CDF632C","user_header":"https://static001.geekbang.org/account/avatar/00/1f/04/c8/3c7af100.jpg","comment_is_top":false,"comment_ctime":1595936990,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5890904286","product_id":100017301,"comment_content":"看了评论，基本上都是只输出个数，可能我想的比较多，写了一个对于任意零钱数组，打印所有找零组合的，欢迎交流：<br>int[] coins = new int[]{1, 3, 5, 7, 9};<br>Map&lt;Integer, List&lt;List&lt;Integer&gt;&gt;&gt; mem = new HashMap&lt;&gt;();<br>private List&lt;List&lt;Integer&gt;&gt; calMinCoins(int total) {<br>        if (mem.get(total) != null &amp;&amp; mem.get(total).size() &gt; 0) {<br>            return mem.get(total);<br>        }<br>        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();<br>        if (coinSet.contains(total)) {<br>            List&lt;Integer&gt; list = new ArrayList&lt;&gt;(1);<br>            list.add(total);<br>            result.add(list);<br>            mem.put(total, result);<br>            return result;<br>        }<br>        if (total &lt; coins[0]) {<br>            return Collections.emptyList();<br>        }<br>        int minCoins = Integer.MAX_VALUE;<br>        Map&lt;Integer, List&lt;List&lt;Integer&gt;&gt;&gt; minCoinsMap = new HashMap&lt;&gt;();<br>        &#47;&#47;根据状态转移方程，每种面额，剔除掉一个，计算剩余面额的最小张数，放到coinMap中<br>        for (int i = 0; i &lt; coins.length; i++) {<br>            List&lt;List&lt;Integer&gt;&gt; lists = calMinCoins(total - coins[i]);<br>            if (lists.size() &gt; 0) {<br>                if (lists.get(0).size() &lt; minCoins) {<br>                    minCoinsMap.clear();<br>                    minCoins = lists.get(0).size();<br>                    minCoinsMap.put(i, lists);<br>                } else if (lists.get(0).size() == minCoins) {<br>                    minCoinsMap.put(i, lists);<br>                }<br>            }<br>        }<br>        if (minCoinsMap.size() &gt;= 1) {<br>            Set&lt;List&lt;Integer&gt;&gt; copySet = new HashSet&lt;&gt;();<br>            minCoinsMap.forEach((minIndex, subCoins) -&gt; {<br>                for (List&lt;Integer&gt; list : subCoins) {<br>                    List&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(list);<br>                    arrayList.add(coins[minIndex]);<br>                    arrayList.sort(Integer::compareTo);<br>                    copySet.add(arrayList);<br>                }<br>            });<br>            List&lt;List&lt;Integer&gt;&gt; copyList = new ArrayList&lt;&gt;(copySet);<br>            mem.put(total, copyList);<br>            return copyList;<br>        }<br>        return new ArrayList&lt;&gt;();<br>    }","like_count":1},{"had_liked":false,"id":225676,"user_name":"颇忒妥","can_delete":false,"product_type":"c1","uid":1026448,"ip_address":"","ucode":"AA86AD1049BC2E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a9/90/0c5ed3d9.jpg","comment_is_top":false,"comment_ctime":1591832029,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5886799325","product_id":100017301,"comment_content":"新建booleanriyu数组 states[w+1]<br>找在states[1], states[3], states[5] 标记为true <br>然后开始循环，遍历states[]从后往前把<br>states[5+1], states[5+3], states[5+5]<br>states[3+1], states[3+3], states[3+5]<br>states[1+1], states[1+3], states[1+5]标记为true<br>如此反复，直到states[w]为true<br>循环次数+1就是解","like_count":1,"discussions":[{"author":{"id":1026448,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a9/90/0c5ed3d9.jpg","nickname":"颇忒妥","note":"","ucode":"AA86AD1049BC2E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281924,"discussion_content":"某一次循环里states下标都超过了w，那么就说明无解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591842009,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":209867,"user_name":"腾升","can_delete":false,"product_type":"c1","uid":1640504,"ip_address":"","ucode":"0F72CFFC78ED2D","user_header":"https://static001.geekbang.org/account/avatar/00/19/08/38/53f32090.jpg","comment_is_top":false,"comment_ctime":1587629166,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5882596462","product_id":100017301,"comment_content":"可以看作完全背包问题，例如：weight = {1, 3, 5}，w = 9，dp[0-w] 数组记录支付 i 元时需要的最小硬币数，并统计每次dp[w] 的最小非零值。<br><br>状态转换过程如下：<br>1 : 0, 1, 2, 3, 4, 5, 6, 7, 8, 9<br>3 : 0, 1, 2, 1, 2, 3, 2, 3, 4, 3<br>5 : 0, 1, 2, 1, 2, 1, 2, 3, 2, 3<br>动态转移方程：dp[ j + weight[ i ]] = min(dp[ j+weight[ i ]], dp[ j ] + 1);<br><br>代码如下：<br>\tpublic static int knapsack3(int[] weight, int n, int w) {<br>\t\tint[] dp = new int[w+1];<br>\t\tint min = Integer.MAX_VALUE;<br>\t\tif (weight[0] &lt;= w) <br>\t\t\tdp[weight[0]] = 1;<br><br>\t\tfor (int i = 0; i &lt; n; ++i) {<br>\t\t\tSystem.out.print(i + &quot;:&quot;);<br>\t\t\tfor (int j = 0; j &lt;= w; ++j) {<br>\t\t\t\tif (j == 0 || dp[j] != 0 &amp;&amp; j &lt;= w - weight[i]) {<br>\t\t\t\t\tif(dp[j+weight[i]] != 0)<br>\t\t\t\t\t\tdp[j+weight[i]] = Math.min(dp[j+weight[i]], dp[j] + 1);<br>\t\t\t\t\telse<br>\t\t\t\t\t\tdp[j+weight[i]] = dp[j] + 1;<br>\t\t\t\t}<br>\t\t\t\tif(j == w &amp;&amp; dp[w] != 0)<br>\t\t\t\t\tmin = Math.min(min, dp[w]);<br>\t\t\t\tSystem.out.print(dp[j] + &quot;, &quot;);<br>\t\t\t}<br>\t\t\tSystem.out.println();<br>\t\t}<br>\t\treturn min;<br>\t}","like_count":1},{"had_liked":false,"id":209293,"user_name":"Geek_4ee31f","can_delete":false,"product_type":"c1","uid":1902621,"ip_address":"","ucode":"E9791C219A88BD","user_header":"","comment_is_top":false,"comment_ctime":1587530819,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5882498115","product_id":100017301,"comment_content":"回溯的代码有边界越界的问题，不知道作者还有机会修改吗？要不然还是继续会有人被坑．","like_count":1},{"had_liked":false,"id":151449,"user_name":"am","can_delete":false,"product_type":"c1","uid":1327015,"ip_address":"","ucode":"CA48DB75D00F8E","user_header":"https://static001.geekbang.org/account/avatar/00/14/3f/a7/56c9ecbe.jpg","comment_is_top":false,"comment_ctime":1573722609,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5868689905","product_id":100017301,"comment_content":"Go语言实现找零钱（动态规划）版本：<br><br>&#47;&#47; value: 硬币币值, n: 硬币数量, w: 支付金额<br>func lfchange(value []int, n int, w int) int {<br>\tsort.Ints(value)<br>\t&#47;&#47; 最小币值<br>\tminV := value[0]<br>\t&#47;&#47; dp[i]表示支付金额为i需要多少个硬币<br>\tdp := make([]int, w+1)<br>\tfor _, v := range value { &#47;&#47; 初始化状态<br>\t\tif v &gt; w {<br>\t\t\tbreak<br>\t\t}<br>\t\tdp[v] = 1<br>\t}<br>\t&#47;&#47; 硬币数<br>\tvar count int<br>\tfor i := minV + 1; i &lt;= w; i++ { &#47;&#47; 动态规划方程转移<br>\t\tcount = 0<br>\t\tfor j := n - 1; j &gt;= 0; j-- {<br>\t\t\tif i%value[j] == 0 {<br>\t\t\t\tdp[i] = i &#47; value[j]<br>\t\t\t\tbreak<br>\t\t\t}<br>\t\t}<br>\t\tfor j := minV; j &lt; i; j++ {<br>\t\t\tif dp[j] != 0 &amp;&amp; dp[i-j] != 0 {<br>\t\t\t\tcount = dp[j] + dp[i-j]<br>\t\t\t\tif count &lt; dp[i] {<br>\t\t\t\t\tdp[i] = count<br>\t\t\t\t}<br>\t\t\t}<br>\t\t}<br>\t}<br>\treturn dp[w]<br>}","like_count":1},{"had_liked":false,"id":141037,"user_name":"嘉一","can_delete":false,"product_type":"c1","uid":1196864,"ip_address":"","ucode":"8D16BD0B75B019","user_header":"https://static001.geekbang.org/account/avatar/00/12/43/40/e7ef18de.jpg","comment_is_top":false,"comment_ctime":1571104723,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5866072019","product_id":100017301,"comment_content":"课后题答案（ts版本）：<br>class SortClazz {<br><br>            public static optionCell: number[] = [1, 3, 5];<br>            public static storeVal: { [key: number]: number } = {};<br><br>            public static getMinCount(targetVal: number): number {<br>                let optionCell = SortClazz.optionCell;<br>                if (optionCell.indexOf(targetVal) &gt;= 0) {<br>                    return 1;<br>                }<br>                if (SortClazz.storeVal[targetVal]) {<br>                    return SortClazz.storeVal[targetVal];<br>                }<br><br>                let minArr: number[] = [];<br>                for (let i = 0, leng = optionCell.length; i &lt; leng; ++i) {<br>                    let tempVal = targetVal - optionCell[i];<br>                    if (tempVal &gt; 0) {<br>                        minArr.push(SortClazz.getMinCount(tempVal));<br>                    }<br>                }<br>                let minVal: number = targetVal;<br>                while (minArr.length &gt; 0) {<br>                    minVal = Math.min(minVal, minArr.pop());<br>                }<br>                SortClazz.storeVal[targetVal] = ++minVal;<br>                return minVal;<br>            }<br><br>        }","like_count":1},{"had_liked":false,"id":128041,"user_name":"未来的胡先森","can_delete":false,"product_type":"c1","uid":1234682,"ip_address":"","ucode":"AFF193AC0E2E6C","user_header":"https://static001.geekbang.org/account/avatar/00/12/d6/fa/1f5bf642.jpg","comment_is_top":false,"comment_ctime":1566823962,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5861791258","product_id":100017301,"comment_content":"小争哥，我又仔细看了一遍代码，在 minDist 方法中<br>第一行if (i == 0 &amp;&amp; j == 0) return matrix[0][0]; &#47;&#47; 初始化第一行第一列 <br>int currMinDist = matrix[i][j] + Math.min(minLeft, minUp); &#47;&#47; 取最小值<br>这里实际上就是对 minLeft、minUp 确定了边界值，之前看代码把 Integer.MAX_VALUE 看成了 Integer.MIN_VALUE 自己实现的出现了错误赋值（自己是手巧代码，不是复制文章代码有所遗漏）<br>耽误小争哥你时间了，表示抱歉","like_count":1},{"had_liked":false,"id":123124,"user_name":"Bayes","can_delete":false,"product_type":"c1","uid":1539608,"ip_address":"","ucode":"2F83B2EFCE6B5D","user_header":"https://static001.geekbang.org/account/avatar/00/17/7e/18/c3ed4650.jpg","comment_is_top":false,"comment_ctime":1565611109,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5860578405","product_id":100017301,"comment_content":"思考题：<br>个人感觉使用转移方程的思路比转移表更加清晰。这里使用递归+备忘录讲一下我的思路：<br>凑够9元需要用最少的硬币：f(9)=min(5+f(4), 3+f(6), 1+f(8))，<br>f(4)=min(3+f(1), 1+f(3))，<br>f(6)=min(5+f(1), 3+f(3), 1+f(5))，<br>f(8)=min(5+f(3), 3+f(5), 1+f(7)),<br>f(7)=min(5+f(2), 3+f(4), 1+f(6)),<br>f(2)=1+f(1),<br><br>注：其中的f(1)、f(3)、f(5)可以看做是哨兵，结果都是1。","like_count":1},{"had_liked":false,"id":118445,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1564366275,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5859333571","product_id":100017301,"comment_content":"思考题的递归式子是f(w) = min(f(w-1), f(w-3),f(w-5)) + 1，可以递归解决。","like_count":1},{"had_liked":false,"id":89091,"user_name":"kkllor","can_delete":false,"product_type":"c1","uid":1117877,"ip_address":"","ucode":"B5995F82E93919","user_header":"https://static001.geekbang.org/account/avatar/00/11/0e/b5/137f25a9.jpg","comment_is_top":false,"comment_ctime":1556075399,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5851042695","product_id":100017301,"comment_content":"    public static void main(String[] args) {<br>        int[] money = {1, 3, 5};<br>        int[] mem = new int[10];&#47;&#47;下标表示当前的金额，值表示达到当前金额用的硬币数<br>        for (int i = 0; i &lt; 10; i++) {<br>            mem[i] = -1;<br>        }<br>        for (int i = 0; i &lt; money.length; i++) {&#47;&#47;初始值设置，即选择一个硬币的情况<br>            if (money[i] &lt;= 9) {<br>                mem[money[i]] = 1;<br>            }<br>        }<br><br>        for (int j = 1; j &lt;= 9; j++) {<br>            if (mem[j] &gt; 0)<br>                for (int m = 0; m &lt; money.length; m++) {<br>                    if (j + money[m] &lt;= 9) { &#47;&#47;金额不得超过9<br>                        if (mem[j + money[m]] == -1 || mem[j] + 1 &lt; mem[j + money[m]])&#47;&#47;关键判断：达到相同金额的情况，保留用硬币数目最小的<br>                            mem[j + money[m]] = mem[j] + 1;<br>                    }<br><br>                }<br>        }<br><br>        System.out.println(mem[9]);<br>    }","like_count":1},{"had_liked":false,"id":88271,"user_name":"小新村小学扛霸子","can_delete":false,"product_type":"c1","uid":1250309,"ip_address":"","ucode":"BECFAB70A68C9F","user_header":"https://static001.geekbang.org/account/avatar/00/13/14/05/5f46ffa6.jpg","comment_is_top":false,"comment_ctime":1555901622,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5850868918","product_id":100017301,"comment_content":"老师真是太厉害了！！！！！","like_count":1},{"had_liked":false,"id":80483,"user_name":"DthFish","can_delete":false,"product_type":"c1","uid":1247542,"ip_address":"","ucode":"EAA903F5423032","user_header":"https://static001.geekbang.org/account/avatar/00/13/09/36/e14a2041.jpg","comment_is_top":false,"comment_ctime":1553667077,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5848634373","product_id":100017301,"comment_content":"public class LeastCoin {<br><br>    public static void main(String[] args) {<br>        int[] coins = {1, 3, 5};<br>        System.out.println(leastCoin(coins, 3, 9));<br><br>    }<br><br>    public static int leastCoin(int[] coins, int num, int limit) {<br>        int[] states = new int[limit + 1];&#47;&#47; 要到达9，所以取状态在[0,9]之间<br><br>        for (int i = 0; i &lt;= limit; i++) {&#47;&#47; 初始化 -1 表示不能满足要求<br>            states[i] = -1;<br>        }<br>        states[0] = 0;<br><br>        for (int i = 1; i &lt;= limit; i++) {<br>            for (int j = 0; j &lt; num; j++) {<br>                if (i - coins[j] &gt;= 0 &amp;&amp; states[i - coins[j]] &gt;= 0) {&#47;&#47;角标不越界，并且前一个状态可达（比如：i = 9，4要可达才能加上5）<br>                    int count = states[i - coins[j]] + 1;&#47;&#47;前一个值需要的硬币数加 1<br>                    if (states[i] &lt; 0 || states[i] &gt; count) {&#47;&#47; states[i] = -1,或者之前记录的硬币数比现在的要多<br>                        states[i] = count;<br>                    }<br>                }<br>            }<br>        }<br><br>        return states[limit];<br>    }<br>}","like_count":1},{"had_liked":false,"id":70745,"user_name":"Zix","can_delete":false,"product_type":"c1","uid":1025719,"ip_address":"","ucode":"48BB6A7F1352CB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a6/b7/e0c9be64.jpg","comment_is_top":false,"comment_ctime":1551173357,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5846140653","product_id":100017301,"comment_content":"经测试，状态转移表法与状态转移方程法的代码均无误。<br>但是此问题最开始用的回溯法，会出现数组越界的问题，边界还需要再判断，请老师解答。","like_count":1},{"had_liked":false,"id":70733,"user_name":"Zix","can_delete":false,"product_type":"c1","uid":1025719,"ip_address":"","ucode":"48BB6A7F1352CB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a6/b7/e0c9be64.jpg","comment_is_top":false,"comment_ctime":1551171199,"is_pvip":false,"replies":[{"id":"25396","content":"嗯嗯 我再去看下","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551232389,"ip_address":"","comment_id":70733,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846138495","product_id":100017301,"comment_content":"老师，回溯的那种解法，代码有问题，会出现数组越界，边界的问题。","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440800,"discussion_content":"嗯嗯 我再去看下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551232389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57135,"user_name":"Kudo","can_delete":false,"product_type":"c1","uid":1036948,"ip_address":"","ucode":"21965914B72AEB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d2/94/8bd217f1.jpg","comment_is_top":false,"comment_ctime":1546657206,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5841624502","product_id":100017301,"comment_content":"思考题解答：<br>动态规划解法（python实现）<br>状态转移方程：min_count[i] = min(min_count[j] + 1) for any j &lt; i<br>import sys<br>def minCoinCount(values, amount):<br>    &#39;&#39;&#39;<br>    values: 硬币面值数组<br>    amount: 要凑的总价值<br>    &#39;&#39;&#39;<br>    min_count = [sys.maxsize] * (amount+1) # 初始化<br>    min_count[0] = 0 <br>    for i in range(1, amount+1): # [1, amount+1)左闭右开<br>        for j in range(i): # [0,i)左闭右开<br>            for v in values: # 依次考察每种币值<br>                if j + v == i and min_count[j] + 1 &lt; min_count[i]: # 能凑齐且最小<br>                    min_count[i] = min_count[j] + 1<br>    <br>    print(min_count[amount]) # 输出结果<br>    <br># 使用方法<br>values = [1,3,5]<br>minCoinCount(values, 9)","like_count":1},{"had_liked":false,"id":55469,"user_name":"程序员联盟","can_delete":false,"product_type":"c1","uid":1018781,"ip_address":"","ucode":"5BB1E4050BBFF2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8b/9d/30c79c4b.jpg","comment_is_top":false,"comment_ctime":1546189530,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5841156826","product_id":100017301,"comment_content":"动态规划的课太帅了。老师厉害","like_count":1},{"had_liked":false,"id":358889,"user_name":"秃头ing","can_delete":false,"product_type":"c1","uid":1677170,"ip_address":"云南","ucode":"20ECA26E896ACD","user_header":"https://static001.geekbang.org/account/avatar/00/19/97/72/8fa068ec.jpg","comment_is_top":false,"comment_ctime":1664971929,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664971929","product_id":100017301,"comment_content":"太强了<br>","like_count":0},{"had_liked":false,"id":357905,"user_name":"🎏往事随风🎏","can_delete":false,"product_type":"c1","uid":1227188,"ip_address":"辽宁","ucode":"D1A19195FCEAF0","user_header":"https://static001.geekbang.org/account/avatar/00/12/b9/b4/8b65959a.jpg","comment_is_top":false,"comment_ctime":1663743495,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663743495","product_id":100017301,"comment_content":"&#47;**<br> * 求最少需要的硬币，就是求moneyList硬币组合中，价值=w的最小长度的组合<br> * <br> * @param w 要支付w元<br> * @param moneyList 有的不同面值硬币<br> * @param value 每次支付的金额总和<br> * @param payList 每次支付的记录<br> *&#47;<br>fun compute(w: Int, moneyList: MutableList&lt;Int&gt;, value: Int, payList: MutableList&lt;Int&gt;) {<br>    if (value == w) {<br>        println(payList)<br>        return<br>    }<br>    for (i in 0 until moneyList.size) {<br>        val tempPayList = mutableListOf&lt;Int&gt;()<br>        tempPayList.addAll(payList)<br>        tempPayList.add(moneyList[i])<br>        val tempMoneyList = mutableListOf&lt;Int&gt;()<br>        tempMoneyList.addAll(moneyList.subList(i + 1, moneyList.size))<br>        val tempValue = value + moneyList[i]<br>        compute(w, tempMoneyList, tempValue, tempPayList)<br>    }<br>}","like_count":0},{"had_liked":false,"id":347179,"user_name":"H.H","can_delete":false,"product_type":"c1","uid":2668479,"ip_address":"","ucode":"3C0BB1E2A3EC51","user_header":"https://static001.geekbang.org/account/avatar/00/28/b7/bf/815f0ec6.jpg","comment_is_top":false,"comment_ctime":1653794913,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1653794913","product_id":100017301,"comment_content":"思考题：状态转移方程:f(w) = min( f(w-5),f(w-3), f(w-1) ) +1<br>代码实现：<br>def min_coins(w):<br>    coins_count = 0<br>    if w &lt; 0:<br>        return 1<br>    if w == 5 or w==3 or w==1:<br>        coins_count += 1<br>        return coins_count<br>    else:<br>        coins_count += (min(min_coins(w-5),min_coins(w-3),min_coins(w-1))+1)<br>    return coins_count<br><br>如果我说代码真的是我写的，但是我自己并不能特别理解，这正常吗？🤦🏻‍♀️","like_count":0},{"had_liked":false,"id":344948,"user_name":"苏成","can_delete":false,"product_type":"c1","uid":2668694,"ip_address":"","ucode":"80A8E7B243DD73","user_header":"https://static001.geekbang.org/account/avatar/00/28/b8/96/716ba431.jpg","comment_is_top":false,"comment_ctime":1651892048,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1651892048","product_id":100017301,"comment_content":"&#47;&#47; 回溯法和状态转移表法解决硬币找零<br>public class Change {<br><br>    static int min = Integer.MAX_VALUE;<br>    &#47;&#47; 使用回溯法<br>    public static void bT(int n, int[] money, int w, int all){<br>        if( w &gt;= all ){<br>            if( w == all )<br>                if( n &lt;= min )  min = n;<br>            return ;<br>        }<br><br>        for( int i = 0; i &lt; money.length; i++ )<br>            bT(n+1, money, w+money[i], all);<br>    }<br><br><br>    &#47;&#47; 使用动态规划（状态转移表法）进行求解<br>    public static int minCoins(int[] money, int all){<br>        &#47;&#47; 因为最小面值是1，所以我们最多可以有all张,填表之后从上往下遍历state[i][all];返回i+1<br>        boolean[][] state = new boolean[all][all+1];<br>        state[0][0] = true;<br><br>        &#47;&#47; 初始化第一行<br>        for( int i = 0; i &lt; money.length; i++ )<br>          if(money[i] &lt;= all)<br>              state[0][money[i]] = true;<br>        for( int i = 0; i &lt; money.length; i++ ){<br>            for( int x = 1; x &lt; all; x++ )              &#47;&#47; 行<br>                for(int j = all -money[i]; j &gt;= 0; j-- ){       &#47;&#47; 列<br>                    if( state[x-1][j] )<br>                        state[x][j+money[i]] = true;<br>            }<br>        }<br><br>        for( int i = 0; i &lt; all; i++ ){<br>            if( state[i][all] )<br>                return i+1;<br>        }<br><br>        return all;<br>    }<br><br><br>    public static void main(String[] args) {<br>&#47;&#47;        bT(0, new int[]{1,3,5}, 0, 9);<br>        int min = minCoins(new int[]{1,4,5}, 9);<br>        System.out.println(min);<br>    }<br>}<br>","like_count":0},{"had_liked":false,"id":344358,"user_name":"👿","can_delete":false,"product_type":"c1","uid":2614279,"ip_address":"","ucode":"AA3D367FE7834D","user_header":"https://static001.geekbang.org/account/avatar/00/27/e4/07/1cb174bf.jpg","comment_is_top":false,"comment_ctime":1651487363,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651487363","product_id":100017301,"comment_content":"Easy<br><br>func main() {<br>\tfmt.Println(minCoin(1))<br>\tfmt.Println(minCoin(8))<br>\tfmt.Println(minCoin(15))<br>\tfmt.Println(minCoin(20))<br>\tfmt.Println(minCoin(60))<br>}<br><br>func minCoin(money int) int {<br>\tif money &lt; 0 {<br>\t\treturn -1<br>\t}<br>\tif money &lt;= 5 {<br>\t\treturn []int{0, 1, 2, 1, 2, 1}[money]<br>\t}<br>\tdp := make([]int, money + 1)<br>\tdp[0], dp[1], dp[2], dp[3], dp[4], dp[5] = 0, 1, 2, 1, 2, 1<br>\tfor i := 6; i &lt;= money; i++ {<br>\t\tdp[i] = min(dp[i-5], dp[i-3], dp[i-1]) + 1<br>\t}<br>\treturn dp[money]<br>}<br><br>func min(i int, i2 int, i3 int) int {<br>\tmin := i<br>\tif min &gt; i2 {<br>\t\tmin = i2<br>\t}<br>\tif min &gt; i3 {<br>\t\tmin = i3<br>\t}<br>\treturn min<br>}","like_count":0},{"had_liked":false,"id":338529,"user_name":"Today","can_delete":false,"product_type":"c1","uid":1235000,"ip_address":"","ucode":"4FA397F0BD8C6E","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/38/41027bda.jpg","comment_is_top":false,"comment_ctime":1647560457,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647560457","product_id":100017301,"comment_content":"本节学习到了： 如何抽象出状态，如何确定最优子结构是写出动态规划的关键","like_count":0},{"had_liked":false,"id":330133,"user_name":"iPolaris","can_delete":false,"product_type":"c1","uid":1521172,"ip_address":"","ucode":"48ED4FCF00B84F","user_header":"https://static001.geekbang.org/account/avatar/00/17/36/14/ae0d3bf1.jpg","comment_is_top":false,"comment_ctime":1641809162,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641809162","product_id":100017301,"comment_content":"第一个回溯代码会有数组越界问题，需要1、每次进来都更新路径长度，2.、把边界条件改成n-1","like_count":0},{"had_liked":false,"id":309167,"user_name":"Tardis","can_delete":false,"product_type":"c1","uid":1056053,"ip_address":"","ucode":"945358C7420763","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/35/1c0e1a30.jpg","comment_is_top":false,"comment_ctime":1629965457,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629965457","product_id":100017301,"comment_content":"课后思考题：假设需要N个硬币数，需要支付的金额M=9。<br>方程是f(N, M) = 1 + min(f(N-1, M-1), f(N-1, M-3), f(N-1, M-5))","like_count":0},{"had_liked":false,"id":307109,"user_name":"叶致习","can_delete":false,"product_type":"c1","uid":1510429,"ip_address":"","ucode":"38E399769699D9","user_header":"https://static001.geekbang.org/account/avatar/00/17/0c/1d/f21977c8.jpg","comment_is_top":false,"comment_ctime":1628863895,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628863895","product_id":100017301,"comment_content":"回溯算法的代码会有数组越界的问题！！！下面是我修改后的 C++ 代码，对应了 leetcode64 问题的答案，但是会超出时间限制。<br><br>&#47;&#47; 这个回溯法会超出时间限制<br>class Solution {<br>private:<br>    int minDist = 10000;<br>    void minDistBT(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int i, int j, int dist, int m, int n) {<br>        if (i == 0 &amp;&amp; j == 0) dist = grid[0][0];<br>        if (i == m-1 &amp;&amp; j == n-1) {<br>            if (dist &lt; minDist) minDist = dist;<br>            return;<br>        }<br>        if (i &lt; m-1) {<br>            minDistBT(grid, i + 1, j, dist + grid[i+1][j], m, n);  &#47;&#47; 向右走<br>        }<br><br>        if (j &lt; n-1) {<br>            minDistBT(grid, i, j + 1, dist + grid[i][j+1], m, n);  &#47;&#47; 向下走<br>        }<br><br>    }<br><br>public:<br>    int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {<br>        int m = grid.size();<br>        int n = grid[0].size();<br>        int dist = 0;<br>        minDistBT(grid, 0, 0, dist, m, n);<br>        return minDist;<br>    }<br>};","like_count":0},{"had_liked":false,"id":301846,"user_name":"zj坚果","can_delete":false,"product_type":"c1","uid":1070601,"ip_address":"","ucode":"D6E787FF032D7B","user_header":"https://static001.geekbang.org/account/avatar/00/10/56/09/4a9d4a35.jpg","comment_is_top":false,"comment_ctime":1625908478,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625908478","product_id":100017301,"comment_content":"假设达到最优解的组合不止一种，怎么列出达到最优解的各种组合，比如背包容量10，物品重1和9等于10，物品重2和8也是时，我想打印出这些方案要如何设计，不能全部靠反推吧","like_count":0},{"had_liked":false,"id":300144,"user_name":"阿甘","can_delete":false,"product_type":"c1","uid":1057843,"ip_address":"","ucode":"BC93175B70E05D","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/33/bcf37f50.jpg","comment_is_top":false,"comment_ctime":1625020229,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1625020229","product_id":100017301,"comment_content":"感觉写成这样子更好懂一些：<br><br>```java<br>package life.arganzheng.study.letcode;<br><br>public class MinDist {<br><br>    Integer minDist = Integer.MAX_VALUE;<br><br>    public static void main(String[] args) {<br>        int[][] matrix = new int[][] {<br>            {1, 3, 5, 9}, {2, 1, 3, 4}, {5, 2, 6, 7}, {6, 8, 4, 3},<br>        };<br>        int minDist = new MinDist().minDist(matrix);<br>        System.out.println(minDist);<br>    }<br><br>    public int minDist(int[][] matrix) {<br>        visit(matrix, matrix.length, 0, 0, 0);<br>        return minDist;<br>    }<br><br>    private void visit(int[][] grid, int n, int i, int j, int curDist) {<br>        curDist += grid[i][j]; &#47;&#47; 计算当前的距离<br><br>        if (i == n - 1 &amp;&amp; j == n - 1) { &#47;&#47; 已经到达终点<br>            if (curDist &lt; minDist) {<br>                minDist = curDist;<br>                return;<br>            }<br>        }<br><br>        &#47;&#47; 未到达终点，继续遍历访问<br>        if (i &lt; n - 1) { &#47;&#47; 向下遍历<br>            visit(grid, n, i + 1, j, curDist);<br>        }<br><br>        if (j &lt; n - 1) { &#47;&#47; 向右遍历<br>            visit(grid, n, i, j + 1, curDist);<br>        }<br>    }<br>}<br>```","like_count":0},{"had_liked":false,"id":298109,"user_name":"海崖","can_delete":false,"product_type":"c1","uid":2552745,"ip_address":"","ucode":"9D42E0B0D30A56","user_header":"https://static001.geekbang.org/account/avatar/00/26/f3/a9/bb9d8450.jpg","comment_is_top":false,"comment_ctime":1623915392,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623915392","product_id":100017301,"comment_content":"叮~打卡","like_count":0},{"had_liked":false,"id":295096,"user_name":"周振","can_delete":false,"product_type":"c1","uid":1134208,"ip_address":"","ucode":"4F729F9C8FA7DE","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/80/faa89499.jpg","comment_is_top":false,"comment_ctime":1622225995,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622225995","product_id":100017301,"comment_content":"分治算法和其他三者解决的不是同一个层次的问题。<br>贪心算法是动态规划的特殊情况，会比较简单一些。回溯算法是暴力出奇迹，穷举所有情况计算最优解。<br>在选用算法解决问题时候，也是这几讲的关键，就是分析问题，看是否满足贪心、动态规划的条件。","like_count":0},{"had_liked":false,"id":294660,"user_name":"vv_test","can_delete":false,"product_type":"c1","uid":1685884,"ip_address":"","ucode":"1D164B2F034E2B","user_header":"https://static001.geekbang.org/account/avatar/00/19/b9/7c/afe6f1eb.jpg","comment_is_top":false,"comment_ctime":1622035963,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622035963","product_id":100017301,"comment_content":"首先我们可以先从递归树的角度来分析，使用f(n,m), n 为硬币的个数，m为当前所有的硬币加起来多少块钱。<br>那么当没有硬币的时候 f(0,0)，<br>1个硬币的时候，f(1,1) f(1,3) f(1,5) 有三个状态。<br>2上硬币的时候,f(1,1) 下的子树又有三个状态f(1,2) f(1,4), f(1,6),<br>f(1,3) 下的子树也是有三个状态 f(1,4) f(1,6), f(1,10),<br> 以此类推(不能评论图，当就看了)可以发现f(1,4) f(1,6) 就是重复子节点。<br>那么根据递归树状态转移表解法: 把每一层重复的状态（节点）合并，只记录不同的状态。<br>声明一个二维数据记录这个状态，state[m][m+1], 值为false，true.  true 表示，可以用这么多个币结算这么多钱。评论区有个哥们实现了代码，nice.<br>","like_count":0},{"had_liked":false,"id":293966,"user_name":"徐改","can_delete":false,"product_type":"c1","uid":1298380,"ip_address":"","ucode":"82276A584AC602","user_header":"https://static001.geekbang.org/account/avatar/00/13/cf/cc/8de5007b.jpg","comment_is_top":false,"comment_ctime":1621654304,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621654304","product_id":100017301,"comment_content":"我用Go写出了状态转移表方式的代码，感觉如果是要用状态转移表的方式来写，那么可以不用死磕状态转移方程了，因为我在写出代码前一直在想要如何用表达式表示当前阶段的解由上一个阶段的最优解来推导得出，我们只需要关心如何能够在避免重复子问题的前提下，将状态转移表依次填充结果就行了。<br>以下是代码：<br>var minCountOfCoin = -1<br>&#47;&#47; money表示要付的钱是多少<br>func minCoins(money int) {<br>\tif money == 1 || money == 3 || money == 5 {<br>\t\tminCountOfCoin = 1<br>\t}<br>\tstates := make([][]bool, money)<br>\tfor i := 0; i &lt; money; i++ {<br>\t\tstates[i] = make([]bool, money + 1)<br>\t}<br>        &#47;&#47; 初始化第一阶段<br>\tif money &gt; 5 {<br>\t\tstates[0][1] = true<br>\t\tstates[0][3] = true<br>\t\tstates[0][5] = true<br>\t} else if money &gt; 3 {<br>\t\tstates[0][1] = true<br>\t\tstates[0][3] = true<br>\t} else {<br>\t\tstates[0][1] = true<br>\t}<br>\tfor i := 1; i &lt; money; i++ {<br>\t\tfor j := 1; j &lt;= money; j++ {<br>\t\t\t&#47;&#47; 最快到达money的时候，就是所花费硬币个数最少的时候<br>\t\t\tif states[i - 1][money] {<br>\t\t\t\tminCountOfCoin = i<br>\t\t\t\treturn<br>\t\t\t}<br>\t\t\tif states[i - 1][j] {<br>\t\t\t\tif j + 1 &lt;= money &amp;&amp; !states[i][j + 1] {<br>\t\t\t\t\tstates[i][j + 1] = true<br>\t\t\t\t}<br>\t\t\t\tif j + 3 &lt;= money &amp;&amp; !states[i][j + 3]  {<br>\t\t\t\t\tstates[i][j + 3] = true<br>\t\t\t\t}<br>\t\t\t\tif j + 5 &lt;= money &amp;&amp; !states[i][j + 5] {<br>\t\t\t\t\tstates[i][j + 5] = true<br>\t\t\t\t}<br>\t\t\t}<br>\t\t}<br>\t}<br>}","like_count":0},{"had_liked":false,"id":288997,"user_name":"柯尊铖","can_delete":false,"product_type":"c1","uid":1851031,"ip_address":"","ucode":"8C3E35A76EED61","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ5GIMGQPRu31calIBicDXTNJQFCgTwgaiaQJniaw8jYrPxwpxNd0nAiapYgD6OK1LrSLuSerOuURG1sQ/132","comment_is_top":false,"comment_ctime":1618814654,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618814654","product_id":100017301,"comment_content":"和 leetcode 322 题比较像，粘一下我 322 的题解。<br>var coinChange = function(coins, amount) {<br>  &#47;&#47; dp[i] 就是凑成 i 至少需要多少个硬币<br>  const dp = new Array(amount + 1)<br>  dp[0] = 0<br>  for (let i = 1; i &lt;= amount; i++) {<br>    coins.forEach((coin) =&gt; {<br>      &#47;&#47; 扣掉一个硬币之后，剩下金额至少需要多少个硬币组成<br>      const pre = i - coin<br>      if (pre &gt;= 0 &amp;&amp; dp[pre] &gt;= 0) {<br>        dp[i] = Math.min(dp[i] || Number.MAX_SAFE_INTEGER, dp[pre] + 1)<br>      }<br>    })<br>    &#47;&#47; 没有符合的硬币可以凑成金额<br>    dp[i] = dp[i] || -1<br>  }<br>  return dp[amount]<br>};","like_count":0},{"had_liked":false,"id":286986,"user_name":"子房","can_delete":false,"product_type":"c1","uid":1438860,"ip_address":"","ucode":"CB05938C248BB3","user_header":"https://static001.geekbang.org/account/avatar/00/15/f4/8c/0866b228.jpg","comment_is_top":false,"comment_ctime":1617717023,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617717023","product_id":100017301,"comment_content":"课后作业代码，同 LeetCode 零钱兑换<br><br>    &#47;**<br>     * 零钱兑换<br>     * @param coins 面币种类<br>     * @param amount 总金额<br>     * @return int<br>     *&#47;<br>    public static int  coinChange(int[] coins, int amount) {<br>        if(amount &lt;= 0){<br>            return 0;<br>        }<br>        Arrays.sort(coins);<br>        if(coins[0] &gt; amount ){<br>            return -1;<br>        }<br>        int[] dp = new int[amount+1];<br>        Arrays.fill(dp, -1);<br>        &#47;&#47; 初始化<br>        for (int i = 0; i &lt; coins.length &amp;&amp; coins[i] &lt;= amount; i++){<br>            dp[coins[i]] = 1;<br>        }<br>        for (int i = coins[0]; i &lt;= amount; i++) {<br>            int j = 0;<br>            while (j &lt; coins.length &amp;&amp; coins[j] &lt;= i ){<br>                if(coins[j] == i) {<br>                    dp[i] = 1;<br>                    break;<br>                }<br>                if (dp[i - coins[j]] != -1) {<br>                    if (dp[i] == -1){<br>                        dp[i] = dp[i - coins[j]] + 1;<br>                    }else {<br>                        dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);<br>                    }<br>                }<br>                j++;<br>            }<br>        }<br><br>        return dp[amount];<br>    }","like_count":0},{"had_liked":false,"id":286835,"user_name":"子房","can_delete":false,"product_type":"c1","uid":1438860,"ip_address":"","ucode":"CB05938C248BB3","user_header":"https://static001.geekbang.org/account/avatar/00/15/f4/8c/0866b228.jpg","comment_is_top":false,"comment_ctime":1617624115,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617624115","product_id":100017301,"comment_content":"点赞，看了这么多算法，也会做点动态规划，让人豁然开朗。","like_count":0},{"had_liked":false,"id":286781,"user_name":"你好，阳光","can_delete":false,"product_type":"c1","uid":2145095,"ip_address":"","ucode":"1A2F487C57F7D9","user_header":"https://static001.geekbang.org/account/avatar/00/20/bb/47/b60ae3eb.jpg","comment_is_top":false,"comment_ctime":1617592811,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617592811","product_id":100017301,"comment_content":"关于动态规划解题思路，我自己在文稿中看得不是很清楚，经过自己的做题和思考，觉得解动态规划的核心是定义好状态并写出状态转移方程，至于具体实现上，可以使用自底向上的填写状态转移表法，也可以使用自顶向下的递归+备忘录法，个人更倾向使用前者，因为方便进行空间复杂度优化。下面以升级版的背包问题为例，将两种方法列出。<br>let maxVal = -1<br>let weight = [2,2,4,6,3] &#47;&#47; 物品重量<br>let value = [3,4,8,9,6]<br>let n = 5 &#47;&#47; 物品个数<br>let w = 9 &#47;&#47; 背包最大载重<br>let mem = new Array(n).fill(null)<br>for(let i=0; i&lt;n; ++i) {<br>  mem[i] = new Array(w+1).fill(-1) &#47;&#47; mem[i][j]表示用i+1个物品组成重量不超过j的组合所具有的最大价值<br>}<br>&#47;&#47; 状态转移方程为f(i, j) = max(f(i-1, j), f(i-1, j-weight[i])+value[i]), j&gt;=weight[i];f(i, j) = f(i-1, j), j&lt;weight[i]<br>function backpackDpRecur(i, j) { &#47;&#47; 调用backpackDpRecur(n-1, w)<br>  if(mem[i][j] != -1)<br>    return mem[i][j]<br>  if(i===0)<br>    maxVal =  j&gt;=weight[0] ? value[i] : 0<br>  else if(j===0)<br>    maxVal = 0<br>  else<br>    maxVal = j&lt;weight[i] ? backpackDpRecur(i-1,j) : Math.max(backpackDpRecur(i-1,j), backpackDpRecur(i-1,j-weight[i])+value[i])<br>  mem[i][j] = maxVal<br>  return maxVal<br>}<br>```<br>- 解法3：动态规划自底向上填表法<br>```js<br>let maxVal = -1<br>let weight = [2,2,4,6,3] &#47;&#47; 物品重量<br>let value = [3,4,8,9,6]<br>let n = 5 &#47;&#47; 物品个数<br>let w = 9 &#47;&#47; 背包最大载重<br>let state = new Array(n).fill(null)<br>for(let i=0; i&lt;n; ++i) {<br>  state[i] = new Array(w+1).fill(-1) &#47;&#47; state[i][j]表示用i+1个物品组成重量不超过j的组合所具有的最大价值<br>}<br>function backpackDP() {<br>  &#47;&#47; 初始化状态<br>  state[0][0] = 0<br>  &#47;&#47; if(weight[0] &lt; w)<br>  &#47;&#47;   state[0][weight[0]] = value[0]<br>  for(let j=weight[0]; j&lt;w; ++j)<br>    state[0][j] = value[0]<br>  for(let i=1; i&lt;n; ++i) {<br>    for(let j=0; j&lt;=w; ++j) {<br>      if(j &lt; weight[i])<br>        state[i][j] = state[i-1][j]<br>      else{<br>        state[i][j] = Math.max(state[i-1][j], state[i-1][j-weight[i]]+value[i])<br>      }<br>    }<br>  } <br>  for(let j=w; j&gt;=0; --j) {<br>    if(state[n-1][j] &gt; maxVal) {<br>      maxVal = state[n-1][j]<br>      return maxVal<br>    }<br>  }<br>}","like_count":0},{"had_liked":false,"id":283226,"user_name":"你好，阳光","can_delete":false,"product_type":"c1","uid":2145095,"ip_address":"","ucode":"1A2F487C57F7D9","user_header":"https://static001.geekbang.org/account/avatar/00/20/bb/47/b60ae3eb.jpg","comment_is_top":false,"comment_ctime":1615629255,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615629255","product_id":100017301,"comment_content":"思考题分析思路：找零9元所需最少硬币数很明显是求解最优解问题，而且找零的过程根据所使用的硬币分为多个阶段，所以是一个多阶段决策最优解模型。再来看是否满足动态规划的三个特征。设找零9元所需最少硬币数为f(9)，从前一个阶段到找零9元阶段有3种方法，使用1元，3元和5元硬币，容易写出状态转移方程为f(9)=min(f(8),f(6),f(4))+1，其实能写出状态转移方程就表明已经满足了动态规划的三个特征。下面只需要确定好初始状态就可以根据状态转移方程求解问题。<br>function minCoin(w) {<br>  let minCoins = [null,1,2,1,2,1]<br>  for(let i=6; i&lt;=w; i++) {<br>    minCoins.push(1+Math.min(minCoins[i-1], minCoins[i-3]&lt;minCoins[i-5]?minCoins[i-3]:minCoins[i-5]))<br>  }<br>  return minCoins[w]<br>}","like_count":0},{"had_liked":false,"id":281451,"user_name":"爬坡的蚂蚁","can_delete":false,"product_type":"c1","uid":1463578,"ip_address":"","ucode":"FBA950CDCE6723","user_header":"https://static001.geekbang.org/account/avatar/00/16/55/1a/c5f033a0.jpg","comment_is_top":false,"comment_ctime":1614753758,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614753758","product_id":100017301,"comment_content":"练习题（Swift）：<br>使用一个数组（A,下标为0~9），下标代表剩余的未支付的费用，存储的是使用的硬币币值的字符串。最小币值为1，那么最多支付9次，而且最多存在9种未支付的费用值（1~9），所以遍历9次。<br>首先对数组A预处理，9 - 1 = 8，所以在下标8的位置填上“1”（表示使用了币值为1的硬币），同理在下标9 - 3 = 6填上“3”，下标4填上“5”。这是对数组A遍历了第1遍。<br>然后继续对数组遍历第2遍，最多9遍。第1遍特殊，第2遍和后面的规律一样。<br>看看第2遍是怎么遍历数组的：此次遍历，只需要找到数组中有值的位置，角标代表剩余未支付的费用，存储的是已支付的硬币值字符串，遍历到下标4，然后分别取1、3、5去与下标4做减法代表再支付一部分费用，将得到的值（剩余未支付费用）当做新的下标，如4 - 1 = 3，然后在下标3处 存储下标4中的字符串（“5”）与此次使用的币值字符串（“1”）拼接后得到的字符串“51”，即A[3] = &quot;51&quot;。<br>在存储得到的字符串的过程中，可能存在将要存储的位置已有值的情况，这时需要对比两个值的字符串长度，取最短的那一个存储进去就可以，这里遵循的是使用最少硬币原则。当使用不同币种对比完成后，这一次遍历就结束了，然后可以进行第3次和第4次...。<br>遍历过程中一旦碰到剩余费用与某个币值相减得0，得出A[0]应该存储的字符串后，操作结束。到此，A[0]字符串长度即为最少硬币数，A[0]的值为使用的硬币组合。<br>    class func minimumCoins(to pay: Int, coins kinds: [Int]) -&gt; Int {<br>        &#47;&#47; 下标为使用过某些硬币后剩余的费用，存储的是使用过的硬币的数字字符串<br>        var coinNumbers = [String](repeating: &quot;&quot;, count: pay + 1)<br>        &#47;&#47; 第一次的数据先做处理，用总费用减去不同币种，到的角标出存储使用币值的字符串<br>        for value in kinds {<br>            if value &lt; pay {<br>                coinNumbers[pay - value] = String(value)<br>            }<br>        }<br>        for _ in 1..&lt;pay { &#47;&#47; 遍历1 ~ （pay - 1）遍<br>            for i in 0...pay {&#47;&#47; 探寻数组中的每一个值<br>                if coinNumbers[i] != &quot;&quot; {&#47;&#47; 非空字符串为有效值<br>                    for value in kinds {&#47;&#47; 与不同币种做减法<br>                        if value == i {&#47;&#47; 剩余费用等于此刻使用的硬币币值<br>                            coinNumbers[i - value] = coinNumbers[i] + String(value)<br>                            return coinNumbers[i - value].count&#47;&#47; 返回字符串长度即为使用的硬币数<br>                        }else if value &lt; i {&#47;&#47; 剩余费用得够减才算有效<br>                            let step = coinNumbers[i] + String(value)&#47;&#47; 剩余费用减去硬币值后，拼接新位置需要存储的字符串<br>                            let newStep = coinNumbers[i - value]&#47;&#47; 新位置原来的字符串<br>                            if newStep == &quot;&quot; || newStep.count &gt; step.count{&#47;&#47; 原来字符串为空直接存入新字符串,或者取新旧字符串中最短的一个存入对应位置<br>                                coinNumbers[i - value] = step<br>                            }<br>                        }<br>                    }<br>                }<br>            }<br>        }<br>        return pay<br>    }","like_count":0},{"had_liked":false,"id":278855,"user_name":"xxx","can_delete":false,"product_type":"c1","uid":1356978,"ip_address":"","ucode":"E78B1F15BC10F7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIcLjatV3GHdibZXCTIgL1X2A7jpByIeLH3Zyia8KXdT4JRcicmVSgq5ekRHCFCFenMqicsAwaWYibHkTw/132","comment_is_top":false,"comment_ctime":1613391866,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613391866","product_id":100017301,"comment_content":"【转】<br>贪心：一条路走到黑，就一次机会，只能哪边看着顺眼走哪边<br>回溯：一条路走到黑，无数次重来的机会，还怕我走不出来 (Snapshot View)<br>动态规划：拥有上帝视角，手握无数平行宇宙的历史存档， 同时发展出无数个未来 (Versioned Archive View)","like_count":0},{"had_liked":false,"id":278613,"user_name":"吃鱼","can_delete":false,"product_type":"c1","uid":1812912,"ip_address":"","ucode":"848835584F6099","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/b0/0c701ef3.jpg","comment_is_top":false,"comment_ctime":1613131214,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613131214","product_id":100017301,"comment_content":"突然想说卧槽！学完这一章，突然感觉leetcode上的算法题也不过如此","like_count":0},{"had_liked":false,"id":278611,"user_name":"Allan","can_delete":false,"product_type":"c1","uid":1310388,"ip_address":"","ucode":"8DA4DBECC2C45C","user_header":"https://static001.geekbang.org/account/avatar/00/13/fe/b4/295338e7.jpg","comment_is_top":false,"comment_ctime":1613129308,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613129308","product_id":100017301,"comment_content":"动态规划：一模型多阶段，三特征 对后无影响 产生子问题重复 最优子结构子问题最优了最后就最优了，两种思路：状态转换表矩阵方式 状态转换方程，通过花树图发现规律。<br>硬币问题：通过我们花树图发现其实答案不止一个比如9的这个：有 3 3 3 ，5 3 1 都可以。每一条线我们选择最优的状态转换方程 minCount  = 1 + min(f(v1),f(v2),f(v3).....)","like_count":0},{"had_liked":false,"id":275088,"user_name":"宋不肥","can_delete":false,"product_type":"c1","uid":1240126,"ip_address":"","ucode":"32B34AF579C91C","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/3e/885ec1d2.jpg","comment_is_top":false,"comment_ctime":1611302787,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611302787","product_id":100017301,"comment_content":"无后效性 其实就是当前的决定不受后面的影响，子问题的最优决策只与子问题自己相关，与原始问题无关，解决子问题时候不用考虑原始问题，就和递归只要考虑当前层状态和处理一样，所以DP的最原始形式其实是 ： 递归回溯（遍历所有可能） + 剪枝（提前去掉非最优结构的分支的下探遍历 + 记忆化缓存（节省重复的下探遍历）","like_count":0},{"had_liked":false,"id":272639,"user_name":"morse","can_delete":false,"product_type":"c1","uid":1001529,"ip_address":"","ucode":"E22E5FA291B9AA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/39/4e95e7b9.jpg","comment_is_top":false,"comment_ctime":1610182382,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610182382","product_id":100017301,"comment_content":"```go<br>func CoinChange(coins []int, amount int) int {<br>\tstatus := make([]int, amount+1)<br>\tstatus[0] = 0<br>\tfor i := 1; i &lt; amount; i++ {<br>\t\tstatus[i] = -1<br>\t}<br><br>\tfor a := 1; a &lt;= amount; a++ {<br>\t\tmin := math.MaxFloat64<br>\t\tfor _, c := range coins {<br>\t\t\tif a-c &lt; 0 {<br>\t\t\t\tcontinue<br>\t\t\t}<br>\t\t\tmin = math.Min(float64(status[a-c]+1), min)<br>\t\t}<br>\t\tstatus[a] = int(min)<br>\t}<br><br>\treturn status[amount]<br>}<br>```","like_count":0},{"had_liked":false,"id":268578,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1608262342,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608262342","product_id":100017301,"comment_content":" &#47;**<br>     * 动态规划状态表：<br>     *     1   2   3   4   5   6   7   8   9<br>     * 1   √   √   √<br>     * 2       √   √   √   √   √<br>     * 3           √   √   √   √   √   √   √<br>     * 4<br>     * 5<br>     * 6<br>     * 7<br>     * 8<br>     * 9<br>     * &lt;p&gt;<br>     * 行代表零钱加和。列代表第几次选择硬币。<br>     * 第一次选择，可以选择1,2,3 所以有三种状态。<br>     * 第二次，同样可以选择1,2,3 ，在前一次基础上推导有(1+1,1+2,1+3, 2+2,2+3,3+3)，即有 2,3,4,5,6  共六种加和状态。<br>     * 同理推导得到第三次选择后，有 3,4,5,6,7,8,9几种状态，并且已经出现了目标零钱9 。所以可以停止推导。返回结果3.<br>     *<br>     * @param change<br>     * @param moneys<br>     * @return<br>     *&#47;<br>    public static int dpCoin(int change, int[] moneys) {<br>        boolean[][] stats = new boolean[change + 1][change + 1];<br>        &#47;&#47;1.处理第一次选择<br>        for (int i = 0; i &lt; moneys.length; ++i) {<br>            stats[1][moneys[i]] = true;<br>            if (moneys[i] == change) {<br>                return 1;<br>            }<br>        }<br><br>        &#47;&#47;2.状态推导<br>        for (int i = 2; i &lt;= change; ++i) {<br>            &#47;&#47;从上一层的状态推导<br>            for (int s = 1; s &lt; change; ++s) {<br>                for (int j = 0; j &lt; moneys.length; ++j) {<br>                    if (stats[i - 1][s] &amp;&amp; (s + moneys[j]) &lt;= change) {<br>                        stats[i][s + moneys[j]] = true;<br>                        if ((s + moneys[j]) == change) {<br>                            return i;<br>                        }<br>                    }<br>                }<br>            }<br>        }<br><br>        return -1;<br>    }","like_count":0},{"had_liked":false,"id":268577,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1608262271,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608262271","product_id":100017301,"comment_content":"    &#47;**<br>     * 有若干面值的硬币v1,v2,..vn ,要找零w 。求需要的最小硬币个数。<br>     * 回溯解法：<br>     * &lt;p&gt;<br>     * 每次选择都有n种可能，穷举所有的组合，然后找到组合值为w,并且组合个数最小的即为所求。<br>     * <br>     *                                                  f(0,0)<br>     * <br>     * <br>     * f(1,1)                            f(1,2)                              f(1,3)<br>     * <br>     * <br>     * f(2,1)    f(2,2)      f(2,3)      f(2,3)    f(2,4)      f(2,5)        f(2,4)    f(2,5)      f(2,6)<br>     * <br>     * <br>     * ..........<br>     * &lt;p&gt;<br>     * 可以看到递归树中，有很多重复的，而重复的分支我们只需要选择一个继续查找即可。所以引入备忘录进行优化。<br>     *<br>     * @param n 当前已经选择的硬币个数<br>     * @param cur_change 当前已选硬币总和<br>     * @param change 要找的零钱<br>     * @param moneys 可选的硬币集合<br>     * @param stats  以选的硬币数和硬币总和 备忘录<br>     *&#47;<br>    static int nums = Integer.MAX_VALUE;<br><br>    public static void coin(int n, int cur_change, int change, int[] moneys, int[][] stats) {<br>        if (cur_change == change) {<br>            if (n &lt; nums) nums = n;<br>            return;<br>        }<br><br>        if (stats[n][cur_change] &gt; 0) return;<br>        for (int i = 0; i &lt; moneys.length; ++i) {<br>            if (cur_change + moneys[i] &lt;= change) {<br>                stats[n][cur_change] = cur_change;<br>                coin(n + 1, cur_change + moneys[i], change, moneys, stats);<br>            }<br>        }<br>    }","like_count":0},{"had_liked":false,"id":261665,"user_name":"🔥 如初之光","can_delete":false,"product_type":"c1","uid":2252211,"ip_address":"","ucode":"0FB2BA12D4B15A","user_header":"https://static001.geekbang.org/account/avatar/00/22/5d/b3/aa2c17f0.jpg","comment_is_top":false,"comment_ctime":1605487039,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605487039","product_id":100017301,"comment_content":"动态规划就难在怎么把方程搞出来🤪","like_count":0},{"had_liked":false,"id":261104,"user_name":"Greathouse","can_delete":false,"product_type":"c1","uid":1014625,"ip_address":"","ucode":"A0C95809AD38F4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7b/61/8c68474e.jpg","comment_is_top":false,"comment_ctime":1605197366,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605197366","product_id":100017301,"comment_content":"public static int minCoin(int money) {<br>\t\tint[] dp = new int[money+1];<br>\t\tint[] arr = {1,3,5};<br>\t\tdp[1] = 1;<br>\t\tdp[3] = 1;<br>\t\tdp[5] = 1;<br>\t\tfor(int i = 1; i &lt;= money; i++) {<br>\t\t\tint min = 1000;<br>\t\t\tfor(int j = 0; j &lt;3; j++) {<br>\t\t\t\tif(i-arr[j] &gt;=0) {<br>\t\t\t\t\tmin = Math.min(min,dp[i-arr[j]]+1);<br>\t\t\t\t}<br>\t\t\t}<br>\t\t\tdp[i] = min;<br>\t\t}<br>\t\treturn dp[money];<br>\t}","like_count":0},{"had_liked":false,"id":258208,"user_name":"我爱灌汤包จุ๊บ","can_delete":false,"product_type":"c1","uid":2217729,"ip_address":"","ucode":"A17A342095655B","user_header":"https://static001.geekbang.org/account/avatar/00/21/d7/01/bf452ade.jpg","comment_is_top":false,"comment_ctime":1604325827,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604325827","product_id":100017301,"comment_content":"请问一下leetcode秋叶收藏集的题目，它是用动态规划解决，不过我没能分析出它可以用动态规划的理由，还望指点","like_count":0},{"had_liked":false,"id":257196,"user_name":"youyou.L","can_delete":false,"product_type":"c1","uid":1796438,"ip_address":"","ucode":"B3DB0D0700EEAC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/zlWt0lPDicdib5BTUbuwA3wLLUuejtZ5icGu3DHMBPd6PicXOdhZ3zYFts8VkXjjyQuxzUJas2w5OTmx3icWKiaZM1Vg/132","comment_is_top":false,"comment_ctime":1603878471,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603878471","product_id":100017301,"comment_content":"思考题dp的降维解法：<br> public int payDp(int cost){<br>        int[] status = new int[cost + 1];<br>        &#47;&#47; 第一次特殊处理<br>        for (int p : coins) {<br>            ++status[p];<br>        }<br>        &#47;&#47; 状态转移<br>        for (int i = 1; i &lt;= cost; ++i) {<br>            for (int j = cost; j &gt;= 0; --j) {<br>                if (status[cost] != 0) {<br>                    return status[cost];<br>                }<br>                if (status[j] == i) {<br>                    for (int p : coins) {<br>                        if (j + p &lt;= cost) {<br>                            status[j + p] = status[j] + 1;<br>                        }<br>                    }<br>                }<br>            }<br>        }<br>        &#47;&#47; 凑不到cost元<br>        return -1;<br>    }","like_count":0},{"had_liked":false,"id":257150,"user_name":"鹤影","can_delete":false,"product_type":"c1","uid":1332662,"ip_address":"","ucode":"FFCED365B4691B","user_header":"https://static001.geekbang.org/account/avatar/00/14/55/b6/81901a59.jpg","comment_is_top":false,"comment_ctime":1603864832,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603864832","product_id":100017301,"comment_content":" public void minCoins() {<br>        int coins[] = new int[]{1, 2, 5, 10, 20, 50, 100};           &#47;&#47;硬币种类<br>        int money = 99;                              &#47;&#47;需要支付的金额<br><br>        int data[][] = new int[money + 1][coins.length + 1];    &#47;&#47;用来保存结果的数组，行表示各种硬币所需要的个数及总数，列表示当前金额<br>        int sumIndex = coins.length;                            &#47;&#47;每行的最后一个值，用来保存当前金额所需要的总的硬币数量<br><br>        data[0][0] = 0;     &#47;&#47;初始化数组，表示0元时，不放入硬币<br><br>        for (int i = 0; i &lt; money + 1; i++) {&#47;&#47;i表示当前的金额<br>            for (int j = 0; j &lt; coins.length; j++) {<br>                int nextMoney = i + coins[j];<br>                if (nextMoney &gt; money) continue;<br><br>                if (data[nextMoney][sumIndex] == 0) {  &#47;&#47;选择放入当前硬币<br>                    &#47;&#47;更新数据<br>                    for (int k = 0; k &lt; data[i].length; k++) {<br>                        data[nextMoney][k] = data[i][k];<br>                    }<br>                    data[nextMoney][sumIndex] = data[nextMoney][sumIndex] + 1;  &#47;&#47;更新总的硬币数量<br>                    data[nextMoney][j] = data[nextMoney][j] + 1;                &#47;&#47;更新 最新放入的硬币数量<br><br>                } else if (data[i][sumIndex] + 1 &gt; data[nextMoney][sumIndex]) {<br><br>                } else {  &#47;&#47;选择放入当前硬币<br>                    &#47;&#47;更新数据<br>                    for (int k = 0; k &lt; data[i].length; k++) {<br>                        data[nextMoney][k] = data[i][k];<br>                    }<br>                    data[nextMoney][sumIndex] = data[nextMoney][sumIndex] + 1;<br>                    data[nextMoney][j] = data[nextMoney][j] + 1;<br>                }<br>            }<br>        }<br><br>        String result = &quot;&quot;;<br>        for (int i = 0; i &lt; data[money].length - 1; i++) {<br>            if (data[money][i] &gt; 0) {<br>                if (TextUtils.isEmpty(result)) result = coins[i] + &quot; x &quot; + data[money][i];<br>                else result = result + &quot; + &quot; + coins[i] + &quot; x &quot; + data[money][i];<br>            }<br>        }<br>        result = result + &quot; = &quot; + money;<br>        Log.d(TAG, &quot;分别用到的硬币和硬币数量: &quot; + result);<br>        Log.d(TAG, &quot;所用到的硬币总数：&quot; + data[money][sumIndex]);<br>    }","like_count":0},{"had_liked":false,"id":255818,"user_name":"foreach","can_delete":false,"product_type":"c1","uid":1138849,"ip_address":"","ucode":"67453D351B09B2","user_header":"https://static001.geekbang.org/account/avatar/00/11/60/a1/fb665ad4.jpg","comment_is_top":false,"comment_ctime":1603438820,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603438820","product_id":100017301,"comment_content":"思考题：<br><br>\t\tpublic int minComByDP(int[] item, int money) {<br>\t\t\t<br>\t\t\t&#47;&#47;状态数组，记录1~money需要的最低硬币数<br>\t\t\tint[] min = new int[money+1];<br>\t\t\t<br>\t\t\t&#47;&#47;初始化为-1<br>\t\t\tfor(int i=0;i&lt;min.length;i++) {<br>\t\t\t\tmin[i] = -1;<br>\t\t\t}<br>\t\t\t<br>\t\t\t&#47;&#47;把1，3，5对应的状态设置为1<br>\t\t\tfor(int i : item) {<br>\t\t\t\tif(i &lt;= money) min[i] = 1;<br>\t\t\t}<br>\t\t\t<br>\t\t\tif(min[money] &gt; 0) return min[money];<br>\t\t\t<br>\t\t\t&#47;&#47;递推公式：min[n] = 1 + min[n-item[j]]<br>\t\t\tfor(int n = item[0]+1;n&lt;min.length;n++) {<br>\t\t\t\tif(min[n] &lt; 0) {<br>\t\t\t\t\tfor(int j = item.length - 1;j &gt;= 0;j--) {<br>\t\t\t\t\t\tif(n - item[j] &gt;= 0 &amp;&amp; min[n-item[j]] &gt; 0) {<br>\t\t\t\t\t\t\tmin[n] = 1 + min[n-item[j]];<br>\t\t\t\t\t\t\tbreak;<br>\t\t\t\t\t\t}<br>\t\t\t\t\t}<br>\t\t\t\t}<br>\t\t\t}<br>\t\t\t<br>\t\t\t<br>\t\t\treturn min[money];<br>\t\t}","like_count":0},{"had_liked":false,"id":245394,"user_name":"独佳记忆","can_delete":false,"product_type":"c1","uid":2136425,"ip_address":"","ucode":"26BB45AF467E27","user_header":"https://static001.geekbang.org/account/avatar/00/20/99/69/95fc7b88.jpg","comment_is_top":false,"comment_ctime":1598931273,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598931273","product_id":100017301,"comment_content":"动态规划，就是回溯法的基础上，画图，抽象出状态转移函数: f(w)=1+min(w-ci)<br>在解决问题时，都需要有一个数组能够存储每次决策后的状态。<br>本题w元，就需要建立数组 f[w+1], 初始化头： f[0]=0。<br><br>代码如下：<br><br>class Solution {<br>     public int coinChange(int[] coins, int w) {<br>        int[] f = new int[w + 1];<br>        &#47;&#47;初始化<br>        f[0] = 0;<br>        for (int i = 1; i &lt; w + 1; i++) {<br>            int min = Integer.MAX_VALUE;<br>            for (int c : coins) {<br>                &#47;&#47;公式： f(i) = 1+ min{f(i-c)} , 假设 有一个c为1，则边界 f(1)=1+f(0);<br>                &#47;&#47; 需要判断： f[i - c] 不能是那个默认的最大值，否则会有溢出： Integer.MAX_VALUE + 1 = Integer.MIN_VALUE !!<br>                if (c &lt;= i &amp;&amp; f[i - c] != Integer.MAX_VALUE&amp;&amp; f[i - c] != Integer.MAX_VALUE) {<br>                    int fiPre = 1 + f[i - c];<br>                    min = fiPre &lt; min ? fiPre : min;<br>                }<br>            }<br>            f[i] = min;<br>        }<br>        if(f[w] == Integer.MAX_VALUE){<br>            return -1;<br>        }<br>        return f[w];<br>    }<br>}","like_count":0},{"had_liked":false,"id":244550,"user_name":"Joe","can_delete":false,"product_type":"c1","uid":1111805,"ip_address":"","ucode":"F73CF74433168D","user_header":"https://static001.geekbang.org/account/avatar/00/10/f6/fd/2c619dde.jpg","comment_is_top":false,"comment_ctime":1598577412,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598577412","product_id":100017301,"comment_content":"* dp[i] 总金额为i时，最少找零的硬币量<br> * 动态转移方程式：dp[i] = min(dp[i - coin]) + 1;<br>public int coinChange(int[] coins, int amount) {<br>        if(amount &lt; 0) {<br>            return -1;<br>        }<br>        int[] dp = new int[amount + 1];   &#47;&#47; dp[i] 总金额为i时，最少找零的硬币量<br>        Arrays.fill(dp, -1);<br>        dp[0] = 0;<br>        for (int money = 1; money &lt;= amount; money++) {<br>            int count = Integer.MAX_VALUE;<br>            for (int coin : coins) {<br>                if(money - coin &gt;= 0 &amp;&amp; dp[money - coin] != -1) {<br>                    count = Math.min(count, dp[money - coin] + 1);<br>                }<br>            }<br>            if(count != Integer.MAX_VALUE) {<br>                dp[money] = count;<br>            }<br>        }<br>        return dp[amount];<br>    }","like_count":0},{"had_liked":false,"id":241214,"user_name":"随风","can_delete":false,"product_type":"c1","uid":1250040,"ip_address":"","ucode":"2883C362D6C2B4","user_header":"https://static001.geekbang.org/account/avatar/00/13/12/f8/888a9b9d.jpg","comment_is_top":false,"comment_ctime":1597217537,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597217537","product_id":100017301,"comment_content":"&#47;&#47;课后题、状态表法实现。力扣 322:  零钱兑换。<br>public int coinChange(int[] coins, int amount) {<br>        &#47;&#47;状态表，数组下表表示金额，数组内容存储使用的硬币数<br>        Integer status[] = new Integer[amount + 1];<br>        &#47;**初始化状态*&#47;<br>        status[0] = 0;<br>        for(int i = 1; i &lt; status.length; i++) {<br>            status[i] = Integer.MAX_VALUE;<br>        }<br>        &#47;&#47;有多少种面额硬币，都有多少个阶段<br>        for(int i = 0; i &lt; coins.length; i++) {<br>            &#47;&#47;根据面额，计算可达到的金额及使用的硬币数<br>            for (int j = 0; j &lt;= amount - coins[i]; j++) {<br>                if (status[j] != Integer.MAX_VALUE &amp;&amp; status[j+coins[i]] &gt; status[j] + 1) {<br>                    status[j+coins[i]] = status[j] + 1;<br>                }<br>            }<br>        }<br>        if (status[amount] &lt; Integer.MAX_VALUE){<br>            return status[amount];<br>        }<br>        return -1;<br>    }","like_count":0},{"had_liked":false,"id":237990,"user_name":"徐飞","can_delete":false,"product_type":"c1","uid":1070154,"ip_address":"","ucode":"C4A0B6D45338E1","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/4a/d8c7cacb.jpg","comment_is_top":false,"comment_ctime":1596023083,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596023083","product_id":100017301,"comment_content":"0-1背包问题适合用状态转移方程吗","like_count":0},{"had_liked":false,"id":233418,"user_name":"xk_","can_delete":false,"product_type":"c1","uid":1514305,"ip_address":"","ucode":"DFE1AC38EA78A7","user_header":"https://static001.geekbang.org/account/avatar/00/17/1b/41/dbb7d785.jpg","comment_is_top":false,"comment_ctime":1594310672,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594310672","product_id":100017301,"comment_content":"int dynamic(int[] coins, int amount) {<br>        boolean[] flagArr = new boolean[amount + 1];<br>        &#47;&#47;初始化i=0的时候<br>        for (int coin : coins) {<br>            if (coin  == amount) {<br>                return 1;<br>            }<br>            flagArr[coin] = true;<br>        }<br>        int i = 1;<br>        for (; i &lt; amount; i++) {<br>            for (int j = amount; j &gt;= 0; j--) {<br>                if (flagArr[j]) {<br>                    for (int coin : coins) {<br>                        if (coin + j == amount) {<br>                            return i + 1;<br>                        }<br>                        if (coin + j &lt; amount) {<br>                            flagArr[coin + j] = true;<br>                        }<br>                    }<br>                }<br>            }<br>        }<br>        return flagArr[amount + 1] ? -1 : i;<br>    }","like_count":0},{"had_liked":false,"id":229386,"user_name":"JY","can_delete":false,"product_type":"c1","uid":1645413,"ip_address":"","ucode":"54DF39E40C0F20","user_header":"https://wx.qlogo.cn/mmopen/vi_32/OWO43KiahibaWnZWkEzXfNQCAqAvVNia44HLxzaNbPKZxiaic3ameJ72dLros26ibxuCL1B5pl7MRlOVrqutNsTOXegQ/132","comment_is_top":false,"comment_ctime":1592982629,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592982629","product_id":100017301,"comment_content":"let coin = (target)=&gt;{<br>    if(target === 0)return 0;<br>    let status = Array(target + 1).fill(false);<br>    status[1] = 1;<br>    status[3] = 1;<br>    status[5] = 1;<br>    let  i = 1;<br>    while(true){<br>          for(let  j = 1; j &lt; target ; ++j){<br>                  if(status[j] &amp;&amp; status[j] === i){<br>                         status[j+1] = status[j + 1] &amp;&amp; status[j + 1] &lt; (1+i)? status[j + 1]: (1 + i);<br>                         status[j+3] = status[j + 3] &amp;&amp; status[j + 3] &lt; (1+i)? status[j + 3]: (1 + i);<br>                         status[j+5] = status[j + 5] &amp;&amp; status[j + 5] &lt; (1+i)? status[j + 5]: (1 + i);<br>                  }<br>                  if(status[target]){<br>                         return status[target];<br>                  }<br>           }<br>           i++;<br>    }<br>}","like_count":0},{"had_liked":false,"id":226613,"user_name":"TheStarBoys","can_delete":false,"product_type":"c1","uid":2009311,"ip_address":"","ucode":"9A6D70482F9212","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/SiciaNKibn60SjA50TsTEtO09DoRA57UozylHmKckZXkJmNiaShSC0BIP6TdZC6cAphuEzmuxMHWwvpYN8P7kKb8eA/132","comment_is_top":false,"comment_ctime":1592151876,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1592151876","product_id":100017301,"comment_content":"其实对于状态转移表法还可以更优化，目前是用了二维数组，能不能用一维数组来实现呢？由于递推 dp[i][j] 的状态，只需要知道dp[i-1][j] 和 dp[i][j-1]。把图中的二维数组的每一行独立开，当成一个一维数组，可以发现在计算 dp[i][j] 的时候，上一行的数据 dp[i-1][j] 还没有被覆盖，因此转换成一维数组是完全可以行的，以下是go代码实现：<br>&#47;&#47; n*n的网格board<br>func minDistance(board [][]int, n int) int {<br>\tstates := make([]int, n)<br>\tstates[0] = board[0][0]<br>\tfor i := 1; i &lt; n; i++ { &#47;&#47; 初始化第一行数据<br>\t\tstates[i] = states[i-1] + board[0][i]<br>\t}<br>\tfor i := 1; i &lt; n; i++ { &#47;&#47; 推导接下来的第 i 行数据<br>\t\tfor j := 0; j &lt; n; j++ {<br>\t\t\tleft := math.MaxInt64<br>\t\t\tif j - 1 &gt;= 0 {<br>\t\t\t\tleft = states[j-1]<br>\t\t\t}<br>\t\t\tup := states[j]<br>\t\t\t&#47;&#47; 递推方程<br>\t\t\tstates[j] = min(left, up) + board[i][j]<br>\t\t}<br>\t}<br>\treturn states[n-1]<br>}","like_count":0},{"had_liked":false,"id":225697,"user_name":"GaGi","can_delete":false,"product_type":"c1","uid":1099053,"ip_address":"","ucode":"CC8D22E1DD8CA2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c5/2d/1eebfc3c.jpg","comment_is_top":false,"comment_ctime":1591836492,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591836492","product_id":100017301,"comment_content":"文中的回溯算法计算路径漏了计算[0][0]这个路径才会导致答案是偏少，大伙记得加上","like_count":0},{"had_liked":false,"id":225261,"user_name":"Sean","can_delete":false,"product_type":"c1","uid":1490049,"ip_address":"","ucode":"9360D9FBB2F851","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJpJz0SORayxydkezyVfk4TvDcJjSahuMbvXPkCbvvjC4RLt6picrlp4rrxXm22TbRQrbC6ibl8zNSw/132","comment_is_top":false,"comment_ctime":1591698230,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1591698230","product_id":100017301,"comment_content":"用递归来一波：<br>public class Solution {<br>    @Test<br>    public void minCoinsTest() {<br>        Assert.assertEquals(3, minCoins(9));<br>        Assert.assertEquals(3, minCoins(11));<br>        Assert.assertEquals(4, minCoins(12));<br>    }<br><br>    public int minCoins(int amount) {<br>        if (amount &lt; 1) {<br>            throw new RuntimeException(&quot;amount should be large than 1&quot;);<br>        }<br>        for (int i = 1; i &lt; amount + 1; i++) {<br>            if (possible(amount, i)) {<br>                return i;<br>            }<br>        }<br>        throw new RuntimeException(&quot;this should not be happen&quot;);<br>    }<br><br>    &#47;**<br>     * 对于需要支付的金额，用coins个硬币是否可行<br>     *<br>     * @param needToPay<br>     * @param coins<br>     * @return<br>     *&#47;<br>    public boolean possible(int needToPay, int coins) {<br>        &#47;&#47;只有三种硬币 1 、3 和 5 元<br>        if (coins == 1) {<br>            return needToPay == 1 || needToPay == 3 || needToPay == 5;<br>        }<br>        if (coins * 5 &lt; needToPay) {<br>            return false;<br>        }<br>        return possible(needToPay - 5, coins - 1) ||<br>                possible(needToPay - 3, coins - 1) ||<br>                possible(needToPay - 1, coins - 1);<br>    }<br>}","like_count":0},{"had_liked":false,"id":223113,"user_name":"叮叮叮","can_delete":false,"product_type":"c1","uid":1914201,"ip_address":"","ucode":"956C42489F25DB","user_header":"https://static001.geekbang.org/account/avatar/00/1d/35/59/3a7219de.jpg","comment_is_top":false,"comment_ctime":1591003593,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591003593","product_id":100017301,"comment_content":"1、设f[x]表示支付x元至少需要的硬币数<br>2、转移方程为：f[9] = Min{ f[8]+1, f[6]+1, f[4]+1}; <br>3、初始状态：f[1]=1; f[3]=1; f[5]=1<br>4、循环计算f[]数组","like_count":0},{"had_liked":false,"id":221870,"user_name":"爱吃胡萝卜","can_delete":false,"product_type":"c1","uid":1459413,"ip_address":"","ucode":"35FCF84D1E04C5","user_header":"https://static001.geekbang.org/account/avatar/00/16/44/d5/ca522e83.jpg","comment_is_top":false,"comment_ctime":1590626177,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590626177","product_id":100017301,"comment_content":"贴一下我的 动态规划找零解法<br><br>```Swift<br>func dynamicZhaoLing(w: Int) -&gt; Int {<br>    var items = [Int](repeating: -1, count: w + 1)<br>    items[0] = 0<br>    let mianZhi = [1,3,5]<br>    <br>    while items[w] == -1 {<br>        for i in mianZhi {<br>            var j = w - i<br>           <br>            while j &gt;= 0 {<br>                if (items[j] != -1) {<br>                    if items[j + i] == -1 {<br>                       items[j + i] = items[j] + 1<br>                    } else {<br>                       items[j + i] = min(items[j] + 1, items[j + i])<br>                    }<br>                    <br>                }<br>                j -= 1<br>            }<br>        }<br>    }<br>    <br>    return items[w]<br>}<br>```","like_count":0},{"had_liked":false,"id":220625,"user_name":"懒猫","can_delete":false,"product_type":"c1","uid":1206544,"ip_address":"","ucode":"B4B567A11B491D","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/10/275ae749.jpg","comment_is_top":false,"comment_ctime":1590298285,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590298285","product_id":100017301,"comment_content":"钱币找零问题思路过程，首先思考下回溯算法，先以第一种面额去凑（按题目意思每一种额度的硬币【不限个数】），凑齐后看看当前使用的纸币数是否比最小的还要小，如果小且刚好能凑齐就更新最小纸币数，然后递归使用下一种额度，递归重复上述过程，直到所有面额的硬币用完<br><br>&#47;&#47; 回溯形式，golang实现<br>func findChangeDfs(m int, coins []int) int {<br>\tmin := math.MaxInt64<br>\tfindChangeBacktrack(m, coins, 0, 0, 0, &amp;min)<br>\treturn min<br>}<br><br>&#47;&#47; num：零钱的张数<br>&#47;&#47; 首先探寻回溯类型的算法，可以发现是以 f(当前金额,当前张数) 作为递归函数的核心使用参数<br>&#47;&#47; 以这两个变量画递归树，会出现重复节点<br>func findChangeBacktrack(m int, coins []int, k, curr, num int, min *int) {<br>\t&#47;&#47; 零钱找到了最后一种或已找到符合数量的零钱<br>\tif curr &gt;= m {<br>\t\tif curr == m &amp;&amp; num &lt; *min {<br>\t\t\t*min = num<br>\t\t}<br>\t\treturn<br>\t}<br>\tfor i := k; i &lt; len(coins); i++ {<br>\t\tif curr+coins[i] &lt;= m {<br>\t\t\t&#47;&#47; 不足时，先用当前面额的零钱凑齐<br>\t\t\t&#47;&#47; 当面额足够时，算算耗费的纸币数，比最小的纸币数要小时记录下来(前提是刚好凑齐额度)<br>\t\t\t&#47;&#47; 然后再递归用下一个<br>\t\t\tfindChangeBacktrack(m, coins, i, curr+coins[i], num+1, min)<br>\t\t}<br>\t}<br>}<br><br>因此在dp解法中，需要围绕 [当前金额，当前张数] 构造状态变量，可以用一个[]int整型数组，长度为金额+1<br>func findChangeDP(m int, coins []int) int {<br>\tdp := make([]int, m+1) &#47;&#47; 下标表示金额，值表示该金额对应最小找零纸币数<br>\t&#47;&#47; 状态转移填充<br>\tfor i := 1; i &lt;= m; i++ {<br>\t\tmin := math.MaxInt64<br>\t\t&#47;&#47; 只需寻找i-money中的金额的下标，因为i-money中金额在money中一定会出现<br>\t\t&#47;&#47; 那么dp[i]一定等于dp[i-money]+1，并且最小的也存在于这些里面<br>\t\tfor _, coin := range coins {<br>\t\t\tif i-coin &gt;= 0 &amp;&amp; dp[i-coin]+1 &lt; min {<br>\t\t\t\tmin = dp[i-coin] + 1<br>\t\t\t}<br>\t\t}<br>\t\tdp[i] = min<br>\t}<br><br>\tif dp[m] == math.MaxInt64 {<br>\t\treturn -1 &#47;&#47; 无解<br>\t}<br><br>\treturn dp[m]<br>}","like_count":0},{"had_liked":false,"id":219897,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1590115383,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1590115383","product_id":100017301,"comment_content":"动态规划从理论上似乎并不难理解，也许是因为老师讲的比较清楚。但是可能需要大量的练习，才能见神杀神，秒过 LeetCode。<br><br>学习了留言里面 @郭霖 老师的代码，然后仿写了 LeetCode 322 Coin Change，结果……<br><br>用状态转移表来解决动态规划问题，似乎在时间复杂度上并没有优势，空间复杂度上似乎也一般，但是相对比较容易理解。<br><br>然后去看了标准答案，分为自顶向下和从下往上两种动态规划的思路，虽然有差别，但最重要的应该还是找到状态转移方程。","like_count":0},{"had_liked":false,"id":218270,"user_name":"scott","can_delete":false,"product_type":"c1","uid":1276032,"ip_address":"","ucode":"A3C507695AAF9D","user_header":"https://static001.geekbang.org/account/avatar/00/13/78/80/d2547579.jpg","comment_is_top":false,"comment_ctime":1589768992,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589768992","product_id":100017301,"comment_content":"使用python 解<br>coins代表 硬币的种类 [1,3,5],w代表兑换的元数。<br>状态转移方程 dp[i] = min(dp[i-v0],dp[i-v2],.....,dp[i-vn])+1<br>```<br>def money(coins, w):<br>    dp = [0] * (w + 1)<br>    for i in range(1, w + 1):<br>       # 记录最小的兑换数量<br>        min_value = int(1e9)<br>        for coin in coins:<br>            if i-coin &gt;= 0:<br>                min_value = min(dp[i-coin], min_value)<br>        dp[i] = min_value + 1<br>    return dp[w]<br><br><br>if __name__ == &#39;__main__&#39;:<br>    coins = [1, 3, 5]<br>    w = 4<br>    print(money(coins, w))<br>```","like_count":0},{"had_liked":false,"id":217823,"user_name":"小阳","can_delete":false,"product_type":"c1","uid":1296135,"ip_address":"","ucode":"97A162992E6A81","user_header":"https://static001.geekbang.org/account/avatar/00/13/c7/07/5798c17e.jpg","comment_is_top":false,"comment_ctime":1589620995,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589620995","product_id":100017301,"comment_content":"思考题：<br>  状态转移方程： f(n) = min( 1+f(n-1), 1 + f(n-3), 1 + f(n-5) )<br><br>使用递归实现： <br>    int[ ] record = new int[n+1];<br>    public int  findMinCoins(int n) {<br>          if (record[n] &gt; 0 ) return record[n];<br>          if ( n == 1) return 1;<br>          if ( n == 3) return 1;<br>          if ( n == 5) return 1;<br>          if ( n &lt; 5 &amp;&amp; n != 3 &amp;&amp; n!= 1){<br>               record[n] = Integer.MAX_VALUE;<br>               return Integer.Max_VALUE;<br>          }<br>          int  cout1 = findMinCoins(n-1);<br>          int  cout3 = findMinCoins(n-3);<br>          int  cout5 = findMinCoins(n-5);<br>          int min = Math.min(cout1, Math.min(cout3,cout5));<br>          if ( min != Integer.MAX_VALUE ) {<br>                min = min + 1;<br>          }<br>          record[n] = min;<br>          return min;<br>    }","like_count":0},{"had_liked":false,"id":217781,"user_name":"默默","can_delete":false,"product_type":"c1","uid":1006635,"ip_address":"","ucode":"AF798B9D327F24","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/2b/8b771383.jpg","comment_is_top":false,"comment_ctime":1589612570,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589612570","product_id":100017301,"comment_content":"定义n个阶段，每个阶段支付1、3、5三种硬币，用一个一维数组记录每一阶段可能的状态，每个阶段判断是否有状态值9，如果没有继续往下一阶段走，在上一层状态的基础上记录这一层的状态，判断是否有状态值9，继续上述过程，直到找到状态值9","like_count":0},{"had_liked":false,"id":214089,"user_name":"lucasyu_xlwb","can_delete":false,"product_type":"c1","uid":1991852,"ip_address":"","ucode":"22754512495511","user_header":"https://static001.geekbang.org/account/avatar/00/1e/64/ac/7431e82e.jpg","comment_is_top":false,"comment_ctime":1588654590,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588654590","product_id":100017301,"comment_content":"还有就是，自顶向下，或者是自底向上，有时候都搞不清到底谁是顶或者谁是底","like_count":0},{"had_liked":false,"id":214088,"user_name":"lucasyu_xlwb","can_delete":false,"product_type":"c1","uid":1991852,"ip_address":"","ucode":"22754512495511","user_header":"https://static001.geekbang.org/account/avatar/00/1e/64/ac/7431e82e.jpg","comment_is_top":false,"comment_ctime":1588654476,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588654476","product_id":100017301,"comment_content":"接续上面问题，感觉不符合递归和动态规划的方式。若以上分解是递归，那么递推分解的过程不应当涉及具体问题的求解，具体求解应当由归的过程完成。若以上分解是DP, 那么应当最底层解决的问题比较简单啊，底层的计算不依赖高层的结果。有点乱","like_count":0},{"had_liked":false,"id":214085,"user_name":"lucasyu_xlwb","can_delete":false,"product_type":"c1","uid":1991852,"ip_address":"","ucode":"22754512495511","user_header":"https://static001.geekbang.org/account/avatar/00/1e/64/ac/7431e82e.jpg","comment_is_top":false,"comment_ctime":1588654017,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588654017","product_id":100017301,"comment_content":"请问老师，到底什么样的问题才算原问题的子问题，且可以递归解决的？如矩阵连乘A1*A2*A3*A4，第一次递推产生子问题 A12*A3*A4, A1*A23*A4, A1*A2*A34 , A12表示A1*A2的结果。 A12*A3*A4的子问题又有 A123*A4, A12*A34。感觉不像递归分解问题的方式。。","like_count":0},{"had_liked":false,"id":213963,"user_name":"王jojo","can_delete":false,"product_type":"c1","uid":1812840,"ip_address":"","ucode":"1ABE7FA2614F86","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/68/ec442a70.jpg","comment_is_top":false,"comment_ctime":1588600870,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588600870","product_id":100017301,"comment_content":"贪心算法比较像狗狗走迷宫，哪里有骨头就走哪里","like_count":0},{"had_liked":false,"id":213590,"user_name":"华仔","can_delete":false,"product_type":"c1","uid":1299543,"ip_address":"","ucode":"F794510431C343","user_header":"https://static001.geekbang.org/account/avatar/00/13/d4/57/b0a11ae5.jpg","comment_is_top":false,"comment_ctime":1588485148,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588485148","product_id":100017301,"comment_content":"动态规划算法从理论上来说，能解决的是寻找最优解这一类的问题。但是并不是所有最优解的问题都能通过这个来解决，一般能通过动态规划解决的问题有一模式三个点，模式就是可以分阶段分步骤逐步寻找最优解的模式，三个特征是有最优子结构，由最优子结构可以得出全局最优解，第二是有重复子结构可以合并，这是可以降低时间复杂度的核心原因，第三是没有后效行，前面的选择的结论不受后面的影响而改变。<br><br>实际上解决动态规划我们有两套思路，一个是正向的，通过回溯算出思路之后，得出一个正向步骤迭代的状态转移方程法。另一个是反向从结果倒推的状态转移公式。<br><br>","like_count":0},{"had_liked":false,"id":208099,"user_name":"喻茂","can_delete":false,"product_type":"c1","uid":1318661,"ip_address":"","ucode":"C8BD8086A17365","user_header":"https://static001.geekbang.org/account/avatar/00/14/1f/05/8a06692e.jpg","comment_is_top":false,"comment_ctime":1587275667,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587275667","product_id":100017301,"comment_content":"&lt;?php<br>$matrix = [<br>\t[1,3,5,9],<br>\t[2,1,3,4],<br>\t[5,2,6,7],<br>\t[6,8,4,3]<br>];<br>$mem = [];<br>$lujing = [];<br>$lujing[0][0] = &quot;&quot;;<br>$lujing[1][0] = &quot;下&quot;;<br>$lujing[2][0] = &quot;下下&quot;;<br>$lujing[3][0] = &quot;下下下&quot;;<br>$lujing[0][1] = &quot;右&quot;;<br>$lujing[0][2] = &quot;右右&quot;;<br>$lujing[0][3] = &quot;右右右&quot;;<br><br><br>&#47;&#47; 获取权重最短路径<br>function minDist($i,$j){ <br>\tglobal $matrix;<br>\tglobal $mem;<br>\tglobal $lujing;<br>\t<br>\tif ($i==0 &amp;&amp; $j==0) {<br>\t\treturn $matrix[0][0];<br>\t}<br>\t<br>\t&#47;&#47; 到达某一点最短路径，<br>\t&#47;&#47; 是到达它的上一点的最短路径或者是左边点的最短路径中的较小值加上到达当前点的距离值<br>\tif (isset($mem[$i][$j])) {<br>\t\treturn $mem[$i][$j];<br>\t}<br>\t<br>\t&#47;&#47; 如果它有左边值和上面值则<br>\tif (($j -1 &gt;= 0) &amp;&amp; ($i-1 &gt;= 0)) {<br>\t\t&#47;&#47; 左边值<br>\t\tif (isset($mem[$i][$j-1])) {<br>\t\t\t$minLeft = $mem[$i][$j-1];<br>\t\t} else {<br>\t\t\t$minLeft = minDist($i,$j-1);<br>\t\t}<br>\t\t<br>\t\t&#47;&#47; 上边值<br>\t\tif (isset($mem[$i-1][$j])) {<br>\t\t\t$minUp = $mem[$i-1][$j];<br>\t\t} else {<br>\t\t\t$minUp = minDist($i-1,$j);<br>\t\t}<br>\t\tif ($minLeft &lt;= $minUp) {<br>\t\t\t$currMinDist = $matrix[$i][$j] + $minLeft;<br>\t\t\t$lujing[$i][$j] = $lujing[$i][$j-1].&quot;右&quot;;<br>\t\t} else {<br>\t\t\t$currMinDist = $matrix[$i][$j] + $minUp;<br>\t\t\t$lujing[$i][$j] = $lujing[$i-1][$j].&quot;下&quot;;<br>\t\t}<br>\t\t$mem[$i][$j] = $currMinDist;<br>\t\treturn $currMinDist;<br>\t}elseif ($j -1 &gt;= 0) {<br>\t\tif (isset($mem[$i][$j-1])) {<br>\t\t\t$currMinDist = $matrix[$i][$j] + $mem[$i][$j-1];<br>\t\t} else {<br>\t\t\t$currMinDist = $matrix[$i][$j]+ minDist($i,$j-1);<br>\t\t}<br>\t\t$mem[$i][$j] = $currMinDist;<br>\t\t$lujing[$i][$j] = $lujing[$i][$j-1].&quot;右&quot;;<br>\t\treturn $currMinDist;<br>\t}elseif ($i -1 &gt;= 0) {<br>\t\tif (isset($mem[$i-1][$j])) {<br>\t\t\t$currMinDist = $matrix[$i][$j] + $mem[$i-1][$j];<br>\t\t} else {<br>\t\t\t$currMinDist = $matrix[$i][$j] + minDist($i-1,$j);<br>\t\t}<br>\t\t$mem[$i][$j] = $currMinDist;<br>\t\t$lujing[$i][$j] = $lujing[$i-1][$j].&quot;下&quot;;<br>\t\treturn $currMinDist;<br>\t}<br>}<br><br>echo minDist(3,3);<br>echo &quot;&lt;br&gt;&quot;;<br>echo $lujing[3][3];","like_count":0},{"had_liked":false,"id":205817,"user_name":"kkllor","can_delete":false,"product_type":"c1","uid":1117877,"ip_address":"","ucode":"B5995F82E93919","user_header":"https://static001.geekbang.org/account/avatar/00/11/0e/b5/137f25a9.jpg","comment_is_top":false,"comment_ctime":1586743169,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586743169","product_id":100017301,"comment_content":"  public static int[] coins = new int[]{3, 1, 5};<br>    public static int TARGET = 9;<br>    public static int state[] = new int[TARGET + 1];<br><br>    public static int f1() {<br>        &#47;&#47;状态数组初始化<br>        for (int i = 0; i &lt; state.length; i++) {<br>            state[i] = 0;<br>        }<br>        for (int i = 0; i &lt; coins.length; i++) {<br>            state[coins[i]] = 1;<br>        }<br>        for (int i = 1; i &lt; state.length; i++) {<br>            if (state[i] &gt; 0)<br>                continue;<br>            int minPre = Integer.MAX_VALUE;<br>            for (int j = 0; j &lt; coins.length; j++) {<br>                if (i - coins[j] &gt;= 0 &amp;&amp; state[i - coins[j]] &gt; 0) {<br>                    minPre = Math.min(minPre, state[i - coins[j]]);<br>                }<br>            }<br>            if (minPre != Integer.MAX_VALUE)<br>                state[i] = 1 + minPre;<br>        }<br><br>        return state[state.length - 1];<br>    }","like_count":0},{"had_liked":false,"id":203388,"user_name":"rookie","can_delete":false,"product_type":"c1","uid":1686457,"ip_address":"","ucode":"F6CCC3EEE2A96E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoeOax1CZKbFicWib6Eicl7WHVpFG269qQCes0wbiawJsqPs45B8sAgF7eGyjhJJkibXTjtApNicnmicPh1g/132","comment_is_top":false,"comment_ctime":1586182946,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586182946","product_id":100017301,"comment_content":"老师，我有个问题，在现在的棋类的算棋算法里面，基本上都是使用回溯算法实现的，甚至还使用一些比较高级高级的阿尔法贝塔剪枝算法来优化回溯算法，但是时间复杂度仍然很高。这种类型的回溯算法是不是无法用动态规划进行实现，如果一旦能用动态规划进行实现，那ai的算棋棋力将又会上升一个新境界。","like_count":0},{"had_liked":false,"id":200805,"user_name":"看不见的城市","can_delete":false,"product_type":"c1","uid":1905705,"ip_address":"","ucode":"A33F894543C90F","user_header":"https://static001.geekbang.org/account/avatar/00/1d/14/29/48ad4b9d.jpg","comment_is_top":false,"comment_ctime":1585653688,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585653688","product_id":100017301,"comment_content":"public int minStep(int w) {<br>        if (w == 1) return 1;<br>        if (w == 3) return 1;<br>        if (w == 5) return 1;<br>        if (w &lt;= 0) return Integer.MAX_VALUE;<br>        return 1 + Math.min(Math.min(minStep(w - 1), minStep(w - 3)), minStep(w - 5));<br>    }","like_count":0},{"had_liked":false,"id":180531,"user_name":"Céline","can_delete":false,"product_type":"c1","uid":1711849,"ip_address":"","ucode":"1C82C3169DF82C","user_header":"https://static001.geekbang.org/account/avatar/00/1a/1e/e9/98556d05.jpg","comment_is_top":false,"comment_ctime":1582309110,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582309110","product_id":100017301,"comment_content":"用python把backtrack，dp table还有recursion的方法都实现了一下：<br>def findMinCoins_backtrack(count, amount):<br>    global min_count<br>    if amount == total_amount:<br>        min_count = min(min_count, count)<br>        return<br>    if amount &gt; total_amount:<br>        return<br>    for coin in demonination:<br>        findMinCoins_backtrack(count+1, amount+coin)<br><br>-------<br>def findMinCoins_DPTable():<br>    # We need to initialize the first several values.<br>    # i.e. for total_count==9, the closest combination are: currnt_amount==8&#47;6&#47;4 + 1&#47;3&#47;5, count+1<br>    for i in range(1, total_amount+1): # One-based index<br>        for coin in demonination:<br>            if i - coin == 0:<br>                min_count_table[i] = 1 # It must be the minimum count of coins for this amount of money<br>                break<br>            if i &lt; coin: # amount of money &lt; demonination of coin, no need to keep comparing<br>                break<br>            min_count_table[i] = min(min_count_table[i], min_count_table[i-coin] + 1)<br>------<br>ef findMinCoins_recursion(amount):<br>    if amount in demonination:<br>        return 1<br>    if amount &lt; 0:<br>        return float(&#39;inf&#39;)<br>    return min([findMinCoins_recursion(amount-coin) for coin in demonination])+1<br><br>-----<br>","like_count":0},{"had_liked":false,"id":175466,"user_name":"neohope","can_delete":false,"product_type":"c1","uid":1043475,"ip_address":"","ucode":"C0268F6E7E2B6E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","comment_is_top":false,"comment_ctime":1580727312,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580727312","product_id":100017301,"comment_content":"\tprivate final int before6[] = {0,1,2,1,2,1};<br>\t<br>\tpublic int minCoins(int money) {<br>\t\tif(money&lt;6)return before6[money];<br>\t\t<br>\t\tint[] dp = new int[money + 1];<br>\t\tfor(int i=0;i&lt;6;i++)dp[i]=before6[i];<br>\t\t<br>\t\tfor (int i = 6; i &lt; money; i++) {<br>\t\t\tint c1 = dp[i-1]+1;<br>\t\t\tint c2 = dp[i-2]+1;<br>\t\t\tint c3 = dp[i-3]+1;<br>\t\t\tint min = c1&lt;=c2?c1:c2;<br>\t\t\tmin = min&lt;c3?min:c3;<br>\t\t\tdp[i]=min;<br>\t\t}<br>\t\t<br>\t\treturn dp[money];<br>\t}","like_count":0},{"had_liked":false,"id":175098,"user_name":"朱坤","can_delete":false,"product_type":"c1","uid":1098637,"ip_address":"","ucode":"65224DA2456EAB","user_header":"https://static001.geekbang.org/account/avatar/00/10/c3/8d/214ad614.jpg","comment_is_top":false,"comment_ctime":1580558101,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580558101","product_id":100017301,"comment_content":"使用状态转移表法, 转移表如下所示：<br>```<br>[0,0,0,0,0,0,0,0,0,1] &#47;&#47;初始状态：9元<br>[0,0,0,0,1,0,1,0,1,0] &#47;&#47;花一枚银币后可达：4元、6元，8元<br>[0,1,0,1,0,1,0,1,0,0] &#47;&#47; 再花一枚可达：1元，3，5，7元<br>[1,0,1,0,1,0,1,0,0,0] &#47;&#47; 再花一枚可达：0元、2元、4元、6元  <br>```<br>JS 实现代码：<br><br>function getRow(count) {<br>    const row = [];<br>    for(let i = 0; i&lt;count; i++) {<br>        row[i] = 0;<br>    }<br>    return row;<br>}<br><br>function findMinCount(coins, money) {<br>    const matrix = [];<br>    matrix[0] = getRow(money+1);<br>    matrix[0][money] = 1; &#47;&#47; 剩余钱数标志为1<br>    <br>    while(true) {<br>        const lastRow = matrix[matrix.length-1];<br>        const newRow = getRow(money + 1);<br>        for(let i = money; i&gt;=0 ; i--) {<br>            if (!lastRow[i]) { &#47;&#47; 经过上一次找零，没有此剩余钱数<br>                continue;<br>            }<br>            for (let j = 0; j &lt; coins.length;j++) {<br>                newRow[i - coins[j]] = 1; &#47;&#47; 找零后，剩余钱数，标志为1<br>            }<br>        }<br>        if (newRow[0]) { &#47;&#47; 剩余钱数已为0<br>            return matrix.length;<br>        }<br>        matrix.push(newRow);<br>    }<br>}<br><br>function main() {<br>    const coins = [1,3,5];<br>    const money = 9;<br>    console.log(findMinCount(coins, money));<br>}<br>main();<br><br><br>","like_count":0},{"had_liked":false,"id":175096,"user_name":"朱坤","can_delete":false,"product_type":"c1","uid":1098637,"ip_address":"","ucode":"65224DA2456EAB","user_header":"https://static001.geekbang.org/account/avatar/00/10/c3/8d/214ad614.jpg","comment_is_top":false,"comment_ctime":1580556626,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580556626","product_id":100017301,"comment_content":"使用状态转移表法：<br>```<br>[0,0,0,0,0,0,0,0,0,1] &#47;&#47;初始状态：9元<br>[0,0,0,0,1,0,1,0,1,0] &#47;&#47;花一枚银币后可达：4元、6元，8元<br>[0,1,0,1,0,1,0,1,0,0] &#47;&#47; 再花一枚可达：1元，3，5，7元<br>[1,0,1,0,1,0,1,0,0,0] &#47;&#47; 再花一枚可达：0元、2元、4元、6元<br>```","like_count":0},{"had_liked":false,"id":174624,"user_name":"不归橙","can_delete":false,"product_type":"c1","uid":1319969,"ip_address":"","ucode":"4F3D84E9395F61","user_header":"https://static001.geekbang.org/account/avatar/00/14/24/21/90b748a2.jpg","comment_is_top":false,"comment_ctime":1580300240,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1580300240","product_id":100017301,"comment_content":"硬币找零问题：<br>    public static int charge(int[] coinsValues, int w){<br>        Arrays.sort(coinsValues); &#47;&#47; 不同价值硬币按从小到大排序<br><br>        int[][] minCoins = new int[coinsValues.length + 1][w + 1];<br>        for (int i = 0; i &lt;= coinsValues.length; i++) {<br>            minCoins[i][0] = 0; &#47;&#47;  w为0，硬币为0初始化<br>        }<br>        for (int j = 0; j &lt;= w; j++) {<br>            minCoins[0][j] = Integer.MAX_VALUE; &#47;&#47; 硬币种类为0，无能为力<br>        }<br><br>        for (int j = 1; j &lt;= w; j++) {<br>            for(int i = 1; i &lt;= coinsValues.length; i++) {<br>                if (j &lt; coinsValues[i-1]) { &#47;&#47; 硬币价值大于w<br>                    minCoins[i][j] = minCoins[i - 1][j];<br>                    continue;<br>                }<br>                &#47;&#47; 取 采用额度为j的硬币后最少硬币数 和 不采用额度为j的硬币后最少硬币数 的最小值<br>                minCoins[i][j] = Math.min(minCoins[i - 1][j], minCoins[i][j - coinsValues[i-1]] + 1);<br>            }<br>        }<br>        for (int i = 1; i &lt;= coinsValues.length; i++) {<br>            for (int j = 1; j &lt;= w; j++) {<br>                System.out.print(minCoins[i][j] + &quot; &quot;);  &#47;&#47; 循环打印二维数组<br>            }<br>            System.out.println();<br>        }<br><br>        return minCoins[coinsValues.length][w];<br>    }","like_count":0},{"had_liked":false,"id":173628,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1579621842,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579621842","product_id":100017301,"comment_content":"用Python简单写了一个程序，程序代码如下：<br># 最少硬币数求解<br><br>&#39;&#39;&#39;<br>假设：<br>W:  金额<br>Vi: i类不同币种，i = 1,2,...n<br>coin：获取金额为W的最少硬币数的函数<br><br>则状态方程： coin(W) = min(coin(W - Vi) + 1)<br>&#39;&#39;&#39;<br><br>V = [1,3,5]<br><br># 结果初始化<br>init_result = {}<br>for C in V:<br>    init_result[C] = 0<br><br>def coin(W):<br>#BEGIN<br><br>    &#39;&#39;&#39;<br>    获取金额为W的最少硬币数<br>    :参数： W，金额<br>    :返回值: min_coins(最少硬币数), min_result(硬币的分解结果)<br>    &#39;&#39;&#39;<br>    global V<br>    global init_result<br>    min_coins = min_result = None<br><br>    # 对金额进行分解<br>    for C in V:<br>        next_W = W - C<br><br>        # 金额符合某个硬币的面额<br>        if next_W == 0:<br>            min_coins = 1<br>            min_result = init_result.copy()<br>            min_result[C] += 1<br>            break<br><br>        if next_W &lt; 0:<br>            continue<br><br>        curr_coins, temp_result = coin(next_W)<br><br>        if curr_coins is not None:<br>            curr_coins += 1<br><br>            if min_coins is None or curr_coins &lt; min_coins:<br>                min_coins = curr_coins<br>                min_result = temp_result<br>                min_result[C] += 1<br><br>    return min_coins, min_result<br>#END<br><br>def main():<br>#BEGIN<br><br>    w = int(input(&#39;请输入金额：&#39;))<br><br>    min_coins, min_result = coin(w)<br><br>    if min_coins is None:<br>        print(&#39;无解&#39;)<br>    else:<br>        print(&#39;-&#39;*10)<br>        print(&#39;至少需要：&#39;)<br>        for r in min_result:<br>            if min_result[r] &gt; 0 :<br>                print(&#39;面值为{}的硬币{}枚&#39;.format(str(r), str(min_result[r])))<br>#END<br><br>if __name__ == &#39;__main__&#39;:<br>    main()<br>","like_count":0},{"had_liked":false,"id":170958,"user_name":"拓","can_delete":false,"product_type":"c1","uid":1010957,"ip_address":"","ucode":"AC1940ECC25436","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6d/0d/e3fa096f.jpg","comment_is_top":false,"comment_ctime":1578799397,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578799397","product_id":100017301,"comment_content":"我怎么觉得，这个新新的硬币找零问题，和贪心算法那节讲的找零问题是同一个问题。没发现区别。。。","like_count":0},{"had_liked":false,"id":170549,"user_name":"SteveYang","can_delete":false,"product_type":"c1","uid":1754829,"ip_address":"","ucode":"C42BCA4F40A9EF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKCbnOvEatUN4ysE2cl6zJNoAJVXXuQVhicQ1jxh6Z2Towrmmc1I6PndaicuQQ0RyyJPyJQicv4tSib9Q/132","comment_is_top":false,"comment_ctime":1578630273,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578630273","product_id":100017301,"comment_content":"课后习题可以用动态规划的状态转移方程求解，minCoin(money) = 1 + min(minCoin(money-1) , minCoin(money-3) , minCoin(money-5))","like_count":0},{"had_liked":false,"id":168897,"user_name":"Sun Fei","can_delete":false,"product_type":"c1","uid":1032631,"ip_address":"","ucode":"092EC0992050BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c1/b7/57f153f6.jpg","comment_is_top":false,"comment_ctime":1578212396,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578212396","product_id":100017301,"comment_content":"最优路径，回溯算法是不是有问题？数组越界...","like_count":0},{"had_liked":false,"id":167711,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1577919813,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577919813","product_id":100017301,"comment_content":"多阶段决策最优解模型,<br>1.一个问题可以分解成多个递进的阶段<br>2.只有相邻的阶段存在转移关系<br>3.相邻阶段的转移有最全局优解解。<br>4.最优解可以用状态转移表法或者状态转移方程描述。","like_count":0},{"had_liked":false,"id":166238,"user_name":"子夜2104","can_delete":false,"product_type":"c1","uid":1070286,"ip_address":"","ucode":"C4FF54AEA6002F","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/ce/92029d2f.jpg","comment_is_top":false,"comment_ctime":1577421364,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577421364","product_id":100017301,"comment_content":"都一个回溯的代码有边界溢出的问题，修改后如下：<br><br><br>    &#47;&#47;调用方式  dp.dist(0, 0, matrix[0][0]);<br>    public void dist(int i, int j, int dist) {<br>        if (i == n-1 &amp;&amp; j == n-1) {<br>            if (dist &lt; minDist) minDist = dist;<br>            return;<br>        }<br><br>        if (i + 1 &lt; n)<br>            dist(i + 1, j, dist + matrix[i + 1][j]);<br><br>        if (j + 1 &lt; n)<br>            dist(i, j + 1, dist + matrix[i][j + 1]);<br>    }<br>","like_count":0},{"had_liked":false,"id":166188,"user_name":"子夜2104","can_delete":false,"product_type":"c1","uid":1070286,"ip_address":"","ucode":"C4FF54AEA6002F","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/ce/92029d2f.jpg","comment_is_top":false,"comment_ctime":1577413426,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577413426","product_id":100017301,"comment_content":"重复学习本节课，又有了一些疑惑，希望老师和同学们能够解答一下：<br><br>求解动态规划的解时：从上一步可能的到达的结果中选择最优的（最大值或者最小值），即最优子结构，那这算是局部求最优解吗？贪心算法就是由局部最优得到全局最优，但这有时候会不正确，为什么动态规划就能得到最优的解呢？","like_count":0},{"had_liked":false,"id":166123,"user_name":"梦想的优惠券","can_delete":false,"product_type":"c1","uid":1257418,"ip_address":"","ucode":"D3B44F6C618CA7","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/ca/cbce6e94.jpg","comment_is_top":false,"comment_ctime":1577407398,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1577407398","product_id":100017301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":164458,"user_name":"Leosocy","can_delete":false,"product_type":"c1","uid":1132542,"ip_address":"","ucode":"5E076D6B981F84","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/fe/f2ce12cd.jpg","comment_is_top":false,"comment_ctime":1576997497,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576997497","product_id":100017301,"comment_content":"def min_coins_count(coins, amount):<br>    dp = [float(&quot;inf&quot;)] * (amount + 1)<br>    dp[0] = 0<br>    for i in range(1, amount + 1):<br>        for coin in coins:<br>            if i - coin &gt;= 0:<br>                dp[i] = min(dp[i], dp[i - coin] + 1)<br>    return dp[amount]<br><br><br>if __name__ == &quot;__main__&quot;:<br>    print(min_coins_count([1, 5], 4))","like_count":0},{"had_liked":false,"id":164456,"user_name":"Leosocy","can_delete":false,"product_type":"c1","uid":1132542,"ip_address":"","ucode":"5E076D6B981F84","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/fe/f2ce12cd.jpg","comment_is_top":false,"comment_ctime":1576997428,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576997428","product_id":100017301,"comment_content":"状态转移方程为：min_count(amount) = min(min_amount(amount - coin) + 1 for coin in coins))<br><br>```python<br>def min_coins_count(coins, amount):<br>    dp = [float(&quot;inf&quot;)] * (amount + 1)    # 初始化都为正无穷<br>    dp[0] = 0 <br>    for i in range(1, amount + 1):<br>        for coin in coins:<br>            if i - coin &gt;= 0:<br>                dp[i] = min(dp[i], dp[i - coin] + 1)<br>    return dp[amount]<br><br><br>if __name__ == &quot;__main__&quot;:<br>    print(min_coins_count([1, 3, 5], 9))<br>```","like_count":0},{"had_liked":false,"id":163340,"user_name":"Yehui","can_delete":false,"product_type":"c1","uid":1734240,"ip_address":"","ucode":"FE1A5E96079F93","user_header":"https://static001.geekbang.org/account/avatar/00/1a/76/60/6b671d8b.jpg","comment_is_top":false,"comment_ctime":1576702093,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576702093","product_id":100017301,"comment_content":"想请问一下 backtracking + 备忘录 跟 状态转移方程法(top-bottom) 的区别。 感觉这两种的实现方法是一样的。","like_count":0},{"had_liked":false,"id":162641,"user_name":"icephobia","can_delete":false,"product_type":"c1","uid":1284212,"ip_address":"","ucode":"CD383B35994331","user_header":"https://static001.geekbang.org/account/avatar/00/13/98/74/6edfe4c1.jpg","comment_is_top":false,"comment_ctime":1576571394,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576571394","product_id":100017301,"comment_content":"递归树中每个节点是(i, j, dist)，dist是怎么计算出来的？","like_count":0},{"had_liked":false,"id":161240,"user_name":"马振","can_delete":false,"product_type":"c1","uid":1136329,"ip_address":"","ucode":"94234F533219C1","user_header":"https://static001.geekbang.org/account/avatar/00/11/56/c9/7b3cd3e0.jpg","comment_is_top":false,"comment_ctime":1576154388,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576154388","product_id":100017301,"comment_content":"1-0背包问题适合采用状态转移表，二维表最短路径问题适合状态转移方程，为什么？<br>因为二维路径问题中，到了某一点可能有多种方式，此时路径值也会有多个，因为此时到达方式不会影响后面的路径选择，此时就需要抛弃到达该点的非最佳方式，这就是状态转移方程的作用。<br>而1-0背包问题，到第n个物体时，并不知道此时最佳的方式，因为此时前面物体放入与否会决定后面物体的能否放入，此时并不能做出取舍；只能记录所有第n次的结果，之=这就是状态表的作用，依此退出第n+1次的重量。","like_count":0},{"had_liked":false,"id":159171,"user_name":"文刀山己几示羊","can_delete":false,"product_type":"c1","uid":1557626,"ip_address":"","ucode":"346C7392814405","user_header":"https://static001.geekbang.org/account/avatar/00/17/c4/7a/e584f82a.jpg","comment_is_top":false,"comment_ctime":1575552006,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575552006","product_id":100017301,"comment_content":"矩阵最小路径和的回溯写法：<br><br>private void backtrack(int[][] matrix, int cp, int i, int j, int n) {<br>    if (i == n - 1 &amp;&amp; j == n - 1) {<br>        &#47;&#47; 加上终点位置的值后再判断更新<br>        if (cp + matrix[i][j] &lt; shortestP) {<br>            shortestP = cp + matrix[i][j];<br>        }<br>        return;<br>    }<br>    if (j + 1 &lt; n) {<br>        &#47;&#47; 加上当前位置的值后，向右走<br>        backtrack(matrix, cp + matrix[i][j], i, j + 1, n);<br>    }<br>    if (i + 1 &lt; n) {<br>        &#47;&#47; 加上当前位置的值后，向下走<br>        backtrack(matrix, cp + matrix[i][j], i + 1, j, n);<br>    }<br>}","like_count":0},{"had_liked":false,"id":156153,"user_name":"teddytyy","can_delete":false,"product_type":"c1","uid":1268738,"ip_address":"","ucode":"E1569D81A4154E","user_header":"https://static001.geekbang.org/account/avatar/00/13/5c/02/e7af1750.jpg","comment_is_top":false,"comment_ctime":1574825686,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574825686","product_id":100017301,"comment_content":"课后：<br>int minChange(int coins[], int coinNum, int money) {<br>    int dp[w+1];<br>    for (int i = 1; i &lt; w+1; i++) {<br>        dp[i] = INTEGER_MAX;<br>    }<br>    dp[0] = 0;<br>    for (int i = 0; i &lt; w+1; i++) {<br>        for (int j = 0; j &lt; coinNum; i++) {<br>            if (i+coins[j] &lt;=w) dp[i+coins[j]] = min(dp[i]+1, dp[i+coins[j]]);<br>        }<br>    }<br>    if (dp[w] != INTEGER_MAX) return dp[w];<br>    else return -1;<br>}","like_count":0},{"had_liked":false,"id":152467,"user_name":"leowu","can_delete":false,"product_type":"c1","uid":1664736,"ip_address":"","ucode":"4FBA5015D0FFB5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELdKezshEZ7tvspWOvPN7A2HYTnfUInEjWtxcSMo1luN7cEHrU2ibTSdYfTcUMLGYSI87KfA8owibZw/132","comment_is_top":false,"comment_ctime":1574013032,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574013032","product_id":100017301,"comment_content":"课后思考题，使用动态转移方程：<br><br>&#47;**<br>     * dp[amount+1]: min number of coins<br>     * <br>     * answer: dp[amount]<br>     * <br>     * dp[0] = 0;<br>     * <br>     * dp[n] = min(1 + (...dp[n-(coin in coins[n])]))<br>     * @param coins<br>     * @param amount<br>     * @return<br>     *&#47;<br>    private static int coinChange4(int[] coins, int amount) {<br>        int[] dp = new int[amount+1];<br><br>        Arrays.fill(dp, Integer.MAX_VALUE);<br>        dp[0] = 0;<br><br>        for (int i=1; i&lt;dp.length; i++) {<br>            for (int j=0; j&lt;coins.length; j++) {<br>                if (coins[j] &lt;= i &amp;&amp; dp[i - coins[j]] != Integer.MAX_VALUE) {<br>                    dp[i] = Math.min(dp[i], 1 + dp[i - coins[j]]);<br>                }<br>            }<br>        }<br><br>        return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];<br>    }","like_count":0},{"had_liked":false,"id":146412,"user_name":"刘榴","can_delete":false,"product_type":"c1","uid":1063491,"ip_address":"","ucode":"08C51E3CE77889","user_header":"https://static001.geekbang.org/account/avatar/00/10/3a/43/6abf3b7d.jpg","comment_is_top":false,"comment_ctime":1572514945,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572514945","product_id":100017301,"comment_content":"int coins[4] = {1, 5, 10, 20};<br>void pay_coins(int coin_index, int paying, int&amp; counts) {<br>    if(paying == 0)<br>        return;<br><br>    counts += paying &#47; coins[coin_index];<br>    paying = paying % coins[coin_index];<br><br>    if(coin_index &gt; 0)<br>        coin_index --;<br>    pay_coins(coin_index, paying, counts);<br>}<br><br>int main(int argc, char** argv) {<br>    int paying = 97;<br>    int counts = 0;<br>    pay_coins(3, paying, counts);<br><br>    std::cout &lt;&lt; &quot;paying coins &quot; &lt;&lt; counts &lt;&lt; std::endl;<br><br>    return 0;<br>}","like_count":0},{"had_liked":false,"id":145412,"user_name":"疯","can_delete":false,"product_type":"c1","uid":1371660,"ip_address":"","ucode":"A4FA44A6F573A4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epgjuGZNgB6sSJmCIhyfMEbI1x1UbKdUuLudWucGLqib2b2Ob2CeO66x4pV9REHguxbCqgTwzSpWaQ/132","comment_is_top":false,"comment_ctime":1572268616,"is_pvip":false,"replies":[{"id":"56461","content":"再看下文章吧，文章里已经讲到了","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1572487508,"ip_address":"","comment_id":145412,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572268616","product_id":100017301,"comment_content":"为什么说存在重复子问题会更适合尝试动态规划来解决","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472384,"discussion_content":"再看下文章吧，文章里已经讲到了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572487508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142154,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1571301154,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571301154","product_id":100017301,"comment_content":"讲的都明白了，关键还是得多找点题目练习才能形成自己的套路","like_count":0},{"had_liked":false,"id":140246,"user_name":"彭锐","can_delete":false,"product_type":"c1","uid":1179669,"ip_address":"","ucode":"F2CB53DE42026D","user_header":"https://static001.geekbang.org/account/avatar/00/12/00/15/6e399ec7.jpg","comment_is_top":false,"comment_ctime":1570862166,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570862166","product_id":100017301,"comment_content":"三个特征里，最优子结构，让人迷惑。“问题的最优解包括子问题的最优解”，这个与动态规划无关，比如上一节的背包问题，下一个阶段的状态应该前一个阶段的状态共同计算获得。<br>我觉得就不应该有最优子结构这个条件。","like_count":0},{"had_liked":false,"id":136238,"user_name":"junjun","can_delete":false,"product_type":"c1","uid":1547322,"ip_address":"","ucode":"1F7EE146B9BE04","user_header":"https://static001.geekbang.org/account/avatar/00/17/9c/3a/bfd73920.jpg","comment_is_top":false,"comment_ctime":1569393725,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1569393725","product_id":100017301,"comment_content":"我记得有个知乎漫画动态规划讲的不错","like_count":0,"discussions":[{"author":{"id":1257580,"avatar":"https://static001.geekbang.org/account/avatar/00/13/30/6c/93b81bc7.jpg","nickname":"丫丫","note":"","ucode":"7E2B56ED35FBAB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":102538,"discussion_content":"求地址","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577352268,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135349,"user_name":"xuanyuan","can_delete":false,"product_type":"c1","uid":1113737,"ip_address":"","ucode":"1EC79B9372868F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2icbib62icXtibTkThtyRksbuJLoTLMts7zook2S30MiaBtbz0f5JskwYicwqXkhpYfvCpuYkcvPTibEaQ/132","comment_is_top":false,"comment_ctime":1569135230,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569135230","product_id":100017301,"comment_content":"这么好的课程，留言却这么少","like_count":0},{"had_liked":false,"id":133904,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1568694992,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1568694992","product_id":100017301,"comment_content":"文末思考题是leetcode 322;<br>尝试用回溯，好像挺复杂的没想明白 ，然后是化表发，得定义一个dp[n][w]的一个数组吧，那个n好像没什么用，把n去掉吧，就一个d[w]数组存储最优值，刚好有递推公式；都能说说自己的求解分析过程，思路吗？","like_count":0,"discussions":[{"author":{"id":1108788,"avatar":"https://static001.geekbang.org/account/avatar/00/10/eb/34/cd310e69.jpg","nickname":"行走的","note":"","ucode":"04772A8A1FF2B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":37337,"discussion_content":"赞同，留言里面大多解法一点求解分析过程都没有，太难理解了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571581224,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":125252,"user_name":"未来的胡先森","can_delete":false,"product_type":"c1","uid":1234682,"ip_address":"","ucode":"AFF193AC0E2E6C","user_header":"https://static001.geekbang.org/account/avatar/00/12/d6/fa/1f5bf642.jpg","comment_is_top":false,"comment_ctime":1566131741,"is_pvip":false,"replies":[{"id":"47251","content":"不好意思，才回复你，我上周回了趟老家。你说的没错，是有点问题。不过，你的两条回复我都看了，感觉初始化方式也不大对。我一会重新写下代码，更新上去。<br><br>修改回复：我又重新看了下代码，貌似没问题哈😂，你能给我一个你觉得有问题的测试用例吗?","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1566774891,"ip_address":"","comment_id":125252,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566131741","product_id":100017301,"comment_content":"小争哥，文章「状态转移方程法」中的代码，int minLeft = Integer.MAX_VALUE、int minUp = Integer.MAX_VALUE 是否存在问题。当计算到达（1,0）、(0,1) 两个点时，左右路径会变成初始的值，导致后续计算全部出错，是不是该初始化为 matrix[0] [0] 呢？<br><br>这是我照着你思路实现的代码：<br><br>```java<br>int[][] memo = null, matrix = null;<br>public int minDistance2(int[][] matrix){<br>    int len = matrix.length;<br>    this.matrix = matrix;<br>    &#47;&#47; 转移方程法<br>    memo = new int[len][len];<br>    return minDistanceCore(len - 1, len - 1);<br>}<br><br>private int minDistanceCore(int row,int col) {<br>    if (row == 0 &amp;&amp; col == 0) { &#47;&#47; (0,0) 直接返回值<br>        return matrix[0][0];<br>    }<br>    if (memo[row][col] != 0) { &#47;&#47; 若已计算则直接返回对应值<br>        return memo[row][col];<br>    }<br>    int distLeft = matrix[0][0], distUp = matrix[0][0];<br>    if (col &gt; 0) {<br>        distLeft = minDistanceCore(row, col - 1);<br>    }<br>    if (row &gt; 0) {<br>        distUp = minDistanceCore(row - 1, col);<br>    }<br>    int curDist = matrix[row][col] + Integer.min(distLeft, distUp);<br>    memo[row][col] = curDist; &#47;&#47; 记录当前距离<br>    return curDist;<br>}<br>```","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463497,"discussion_content":"不好意思，才回复你，我上周回了趟老家。你说的没错，是有点问题。不过，你的两条回复我都看了，感觉初始化方式也不大对。我一会重新写下代码，更新上去。\n\n修改回复：我又重新看了下代码，貌似没问题哈😂，你能给我一个你觉得有问题的测试用例吗?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566774891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123430,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1565674981,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1565674981","product_id":100017301,"comment_content":"第一次动手操作了下，动态规划的方法调用代码很简洁，但是递归调用到一定程度时就会有栈溢出，然后又用循环改写了一个版本。循环实现那里把所有支持的硬币放到了一个Set中，当然这部分代码稍作修改就可以支持任意多大小的兑换硬币。<br>static int minCoinNumByDP(int value, int[] mem) {<br>        if (value &lt;= 0) {<br>            return 0;<br>        }<br>        if (value == 1 || value == 3 || value == 5) {<br>            return 1;<br>        }<br>        if (value == 2 || value == 4) {<br>            return 2;<br>        }<br><br>        if (mem[value] &gt; 0) {<br>            return mem[value];<br>        }<br><br>        mem[value] = 1 + Math.min(Math.min(minCoinNumByDP(value - 1, mem), minCoinNumByDP(value - 3, mem)),<br>                minCoinNumByDP(value - 5, mem));<br>        return mem[value];<br>    }<br><br>    static int minCoinNumByDPWithoutRecursion(int value, int[] mem) {<br>        if (value &lt;= 0) {<br>            return 0;<br>        }<br>        mem[2] = 2; mem[4] = 2;<br>        for (int i = 0; i &lt;= value; i++) {<br>            if (coins.contains(i)) {<br>                mem[i] = 1;<br>            }<br>            if (mem[i] &gt; 0 || i == 0) {<br>                continue;<br>            }<br>            mem[i] = 1 + Math.min(Math.min(mem[i - 1], mem[i - 3]), mem[i - 5]);<br>        }<br>        return mem[value];<br>    }","like_count":0},{"had_liked":false,"id":115272,"user_name":"路漫漫","can_delete":false,"product_type":"c1","uid":1597156,"ip_address":"","ucode":"09565AADAFA337","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erObO6EFRxGTlldp4LDHG7ZJK8iarHYTydh8gj8ib60PQwCdtLP6EPTkmoFO7yaoXetDhwkFIeAMzfg/132","comment_is_top":false,"comment_ctime":1563522761,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563522761","product_id":100017301,"comment_content":"为什么第一张图的(0,0)是1 第2张又是0,第3张又是1","like_count":0},{"had_liked":false,"id":103916,"user_name":"糖","can_delete":false,"product_type":"c1","uid":1542834,"ip_address":"","ucode":"784DDA19104392","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJzP9yB6eIRRyVNe3iab0gXB6yOeaNRHGx6raTQz2grfE5N2LWl6uIj1mrSU7nxiaEzeSLp6xAkE3iaQ/132","comment_is_top":false,"comment_ctime":1560565306,"is_pvip":true,"replies":[{"id":"37644","content":"我讲解主要是从由来、本质来讲，不是特别target面试切题的。切题的话直接写状态转移方程就好了，不用理解的那么透彻！","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1560641065,"ip_address":"","comment_id":103916,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560565306","product_id":100017301,"comment_content":"大家做动态规划题目时会出现这种情况吗？在没看这些理论的知识时，不管什么最优子结构，重复子问题，也不管什么状态的时候，有些简单的问题自己还能解决，直到了解了这些知识，知道了什么是动态规划，了解了动态规划中状态转移的概念之后，我们往往在一个特别简单的问题上就去分析的很复杂以至于以前感觉很简单的问题现在都不会解了，感觉越做越不会了。。。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454055,"discussion_content":"我讲解主要是从由来、本质来讲，不是特别target面试切题的。切题的话直接写状态转移方程就好了，不用理解的那么透彻！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560641065,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97948,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1558850818,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558850818","product_id":100017301,"comment_content":"思考题：看做爬阶梯<br>coins_value_steps = {1:1,3:1,5:1}<br>def coin_dy(total_value):<br>    if coins_value_steps.get(total_value) != None:<br>        return coins_value_steps[total_value]<br>    if total_value - 1 &gt; 0 and total_value - 3 &gt; 0 and total_value - 5 &gt; 0:<br>        return 1 + min(coin_dy(total_value-1),coin_dy(total_value-3),coin_dy(total_value-5))<br>    elif total_value - 1 &gt; 0 and total_value - 3 &gt; 0:<br>        return 1 + min(coin_dy(total_value - 1), coin_dy(total_value - 3))<br>    elif total_value - 1 &gt; 0:<br>        return 1 + coin_dy(total_value - 1)<br>print(&quot;动态规划：最少需要%d个硬币&quot; % coin_dy(9))","like_count":0},{"had_liked":false,"id":94087,"user_name":"Peng","can_delete":false,"product_type":"c1","uid":1108103,"ip_address":"","ucode":"D15A78DD1AC18C","user_header":"https://static001.geekbang.org/account/avatar/00/10/e8/87/89561ed0.jpg","comment_is_top":false,"comment_ctime":1557717051,"is_pvip":false,"replies":[{"id":"33703","content":"是有点对不上哈。你可以独立的看。回溯代码只是为了解释重复子问题。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1557791782,"ip_address":"","comment_id":94087,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557717051","product_id":100017301,"comment_content":"状态转移表法的回溯代码中有注释：&#47;&#47; 调用方式：minDistBacktracing(0,0,0,w,n)<br>这样调用跟下面的递归树对不上吧，递归树的根节点是f(0,0,1）<br>能再明确一下吗","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449908,"discussion_content":"是有点对不上哈。你可以独立的看。回溯代码只是为了解释重复子问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557791782,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83662,"user_name":"hh","can_delete":false,"product_type":"c1","uid":1239635,"ip_address":"","ucode":"C0A90DDC22F92C","user_header":"https://static001.geekbang.org/account/avatar/00/12/ea/53/3d1beec3.jpg","comment_is_top":false,"comment_ctime":1554693174,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554693174","product_id":100017301,"comment_content":"代码运行起来好像是ok的，总感觉不像动态规则的样子。。。。？？？？<br><br>var v = [1,3,5];<br>var w = 11;<br>var num = [0,1];<br>function getNum(v, w) {<br>  for(var i =2; i&lt;=w; i++) {<br>    num[i] = getMin(i) + 1;<br>  }<br>  return num[w];<br>}<br>function getMin(i) {<br>  var min = num[i-v[0]];<br>  for(var j =0; j&lt;v.length; j++) {<br>    if(i - v[j] &gt;=0) {<br>      if(num[i-v[j]] &lt; min){<br>        min = num[i-v[j]];<br>      }<br>    }<br>  }<br>  return min;<br>}<br><br>getNum(v,w);","like_count":0},{"had_liked":false,"id":80498,"user_name":"心动","can_delete":false,"product_type":"c1","uid":1239268,"ip_address":"","ucode":"4024B7EC525BC1","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/e4/ea6b9015.jpg","comment_is_top":false,"comment_ctime":1553670549,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553670549","product_id":100017301,"comment_content":"private int[] mem = new int[1024];<br><br>\tpublic int solution(int n) {<br>\t\tif (n &lt;= 0) {<br>\t\t\treturn 2;<br>\t\t}<br>\t\tif (mem[n] &gt; 0) {<br>\t\t\treturn mem[n];<br>\t\t}<br>\t\tif (n == 1 || n == 3 || n == 5) {<br>\t\t\tmem[n] = 1;<br>\t\t\treturn 1;<br>\t\t}<br>\t\tint n1 = solution(n - 1) + 1;<br>\t\tint n2 = solution(n - 3) + 1;<br>\t\tint n3 = solution(n - 5) + 1;<br>\t\tint res = n1 &gt; n2 ? n2 : n1;<br>\t\tres = res &gt; n3 ? n3 : res;<br>\t\tmem[n] = res;<br>\t\treturn res;<br>\t}","like_count":0},{"had_liked":false,"id":77116,"user_name":"daniel","can_delete":false,"product_type":"c1","uid":1370456,"ip_address":"","ucode":"3516AF7F9A4DEA","user_header":"https://static001.geekbang.org/account/avatar/00/14/e9/58/397a4ab2.jpg","comment_is_top":false,"comment_ctime":1552838190,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552838190","product_id":100017301,"comment_content":"回溯写起来舒服，但是动态就不会多余计算<br>int value = Integer.Max<br> public void Jump(int i, int j,int value,int[][] matrix){<br><br>        if (i == 5) return;<br>        if (j == 5) return;<br>        if (i == 4&amp;&amp; j == 4) {if (value+matrix[i][j]&lt;minValue) minValue = value+matrix[i][j] ;return;}<br>        Jump(i+1,j,value+matrix[i][j],matrix);<br>        Jump(i,j+1,value+matrix[i][j],matrix);<br>    }","like_count":0},{"had_liked":false,"id":77062,"user_name":"猪猪男孩","can_delete":false,"product_type":"c1","uid":1461246,"ip_address":"","ucode":"E853E29182C6B5","user_header":"https://static001.geekbang.org/account/avatar/00/16/4b/fe/048ad222.jpg","comment_is_top":false,"comment_ctime":1552822341,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552822341","product_id":100017301,"comment_content":"def findMoney1(m,n):<br>    if m&lt;1:<br>        return 0<br><br>    for i in range(len(n)-1,-1,-1):<br>        if m == n[i]:return 1<br>    <br>    <br>    f = [[0 for _ in range(m+1)] for _ in range(m)]<br>    <br>    for i in range(len(n)):<br>        if n[i] &lt;= m:f[0][n[i]] = 1<br>        <br>    for i in range(1,m):<br>        for j in range(m):<br>            if f[i-1][j] &gt; 0:<br>                for k in range(len(n)):<br>                    if n[k]+j &lt;= m:<br>                        if f[i][j+n[k]]&gt;0:<br>                            f[i][j+n[k]] = min(f[i][j+n[k]],f[i-1][j]+1)<br>                        else:<br>                            f[i][j+n[k]] += f[i-1][j]+1<br>                f[i][j] = f[i-1][j]<br><br>    return f[m-1][m]","like_count":0},{"had_liked":false,"id":77023,"user_name":"少吃就会瘦","can_delete":false,"product_type":"c1","uid":1026004,"ip_address":"","ucode":"4773404D93A0CC","user_header":"","comment_is_top":false,"comment_ctime":1552809252,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1552809252","product_id":100017301,"comment_content":"public class Main {<br><br>\tpublic static void main(String[] args) {<br>        int [] a = new int [10];<br>        int [] value = {1,3,5};<br>        for(int i = 0;i&lt;value.length;i++)<br>      {<br>    \t      a[value[i]]=1;<br>      }<br>      for(int n = 1;n&lt;10;n++)<br>      {<br>    \t      if(a[n]==1)<br>    \t\t     continue;<br>    \t      a[n]=min(a,n-1, n-3,n-5)+1;<br>      }<br>      System.out.println(a[9]);<br>\t}\t<br>\tpublic static int min(int [] array,int a,int b,int c)<br>    {<br>\t\tint left,middle,right,min_num;<br>\t\tleft=a&lt;1?Integer.MAX_VALUE:array[a];<br>\t\tmiddle=b&lt;1?Integer.MAX_VALUE:array[b];<br>\t\tright=c&lt;1?Integer.MAX_VALUE:array[c];\t<br>\t\tmin_num = left&lt;middle?left:middle;<br>\t\tmin_num = min_num&lt;right?min_num:right;\t\t<br>\t\treturn min_num;\t  <br>      }<br><br>}<br>","like_count":0},{"had_liked":false,"id":73838,"user_name":"淤白","can_delete":false,"product_type":"c1","uid":1206503,"ip_address":"","ucode":"D1E65DC40DAF68","user_header":"https://static001.geekbang.org/account/avatar/00/12/68/e7/ee47d0e2.jpg","comment_is_top":false,"comment_ctime":1552013546,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552013546","product_id":100017301,"comment_content":"课后作业：<br>\tint[] bizhi = {1,3,5};<br>\tpublic int minNum(int totalMoney) {<br>\t\tint[] moneyNums = new int[totalMoney+1];<br>\t\tfor (int i = 0; i &lt; moneyNums.length; i++) {<br>\t\t\tfor (int j = 0; j &lt; bizhi.length; j++) {<br>\t\t\t\tif (i + bizhi[j] &gt; totalMoney) {<br>\t\t\t\t\tcontinue;<br>\t\t\t\t}<br>\t\t\t\tif (moneyNums[i+bizhi[j]] == 0) {<br>\t\t\t\t\tmoneyNums[i+bizhi[j]] = moneyNums[i] + 1;<br>\t\t\t\t} else {<br>\t\t\t\t\tmoneyNums[i+bizhi[j]] = Math.min(moneyNums[i+bizhi[j]], moneyNums[i]+1);<br>\t\t\t\t}<br>\t\t\t}<br>\t\t}<br>\t\tSystem.err.println(moneyNums[totalMoney]);<br>\t\treturn moneyNums[totalMoney];<br>\t}","like_count":0},{"had_liked":false,"id":64678,"user_name":"luo","can_delete":false,"product_type":"c1","uid":1148742,"ip_address":"","ucode":"00FBDC12101419","user_header":"https://static001.geekbang.org/account/avatar/00/11/87/46/2850b4a9.jpg","comment_is_top":false,"comment_ctime":1548856205,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548856205","product_id":100017301,"comment_content":"王老师 我发现最优子问题在动态规划中 属于可有可无的一个特征，因为0-1背包问题我就没有想到最优子问题体现在哪？就是求n个阶段完成之后背包的最大重量","like_count":0},{"had_liked":false,"id":64320,"user_name":".","can_delete":false,"product_type":"c1","uid":1194614,"ip_address":"","ucode":"2FBBAB303A4D5A","user_header":"https://static001.geekbang.org/account/avatar/00/12/3a/76/e9f18792.jpg","comment_is_top":false,"comment_ctime":1548744678,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548744678","product_id":100017301,"comment_content":"用回溯写的矩形最短距离有问题，最后个点的距离没有加上。","like_count":0},{"had_liked":false,"id":63074,"user_name":"哈哈","can_delete":false,"product_type":"c1","uid":1142044,"ip_address":"","ucode":"F4673CC2238BAE","user_header":"https://static001.geekbang.org/account/avatar/00/11/6d/1c/10d5c280.jpg","comment_is_top":false,"comment_ctime":1548244515,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548244515","product_id":100017301,"comment_content":"状态方程<br>public int getCoinCount(int[] a,int money){<br>        int min1=0;<br>        int min2=0;<br>        int min3=0;<br>        if(money-a[0]&gt;=0){<br>            min1=1+getCoinCount(a,money-a[0]);<br>        }<br>        if(money-a[1]&gt;=0){<br>            min2=1+getCoinCount(a,money-a[1]);<br>        }<br>        if(money-a[2]&gt;=0){<br>            min3=1+getCoinCount(a,money-a[2]);<br>        }<br>        if(min1!=0 &amp;&amp; min2!=0 &amp;&amp; min3!=0){<br>            int min = Math.min(min1, min2);<br>            min=Math.min(min,min3);<br>            return min;<br>        }else{<br>           if(min1==0){<br>               int min = Math.min(min2, min3);<br>               if(min==0){<br>                   return min2==0?min3:min2;<br>               }else{<br>                  return min;<br>               }<br>           }else if(min2==0){<br>               int min = Math.min(min1, min3);<br>               if(min==0){<br>                   return min1==0?min3:min1;<br>               }else{<br>                   return min;<br>               }<br><br>           }else{<br>               int min = Math.min(min2, min1);<br>               if(min==0){<br>                   return min2==0?min1:min2;<br>               }else{<br>                   return min;<br>               }<br><br>           }<br>        }<br>    }","like_count":0},{"had_liked":false,"id":62630,"user_name":"老王","can_delete":false,"product_type":"c1","uid":1236457,"ip_address":"","ucode":"79B81C8F6179CB","user_header":"https://static001.geekbang.org/account/avatar/00/12/dd/e9/c939283c.jpg","comment_is_top":false,"comment_ctime":1548122313,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548122313","product_id":100017301,"comment_content":"我理解动态规划就是多维递归","like_count":0},{"had_liked":false,"id":61522,"user_name":"cw","can_delete":false,"product_type":"c1","uid":1264296,"ip_address":"","ucode":"82A6B50462F9F9","user_header":"https://static001.geekbang.org/account/avatar/00/13/4a/a8/b7e36dd2.jpg","comment_is_top":false,"comment_ctime":1547713424,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547713424","product_id":100017301,"comment_content":"min（x)= min(min(x-1),min(x-2),min(x-3))+1","like_count":0},{"had_liked":false,"id":60963,"user_name":"alex","can_delete":false,"product_type":"c1","uid":1260350,"ip_address":"","ucode":"A8292811E0E753","user_header":"https://static001.geekbang.org/account/avatar/00/13/3b/3e/950f9db7.jpg","comment_is_top":false,"comment_ctime":1547599015,"is_pvip":false,"replies":[{"id":"23153","content":"貌似是的。不过我对隐式马尔科夫不了解：《","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1549179530,"ip_address":"","comment_id":60963,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1547599015","product_id":100017301,"comment_content":"我是一个游戏设计师，看完这篇文章突然发现跟隐式马科夫模型有非常相似的地方，隐式马科夫模型的每个子状态可以用动态规划实现吗？<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436683,"discussion_content":"貌似是的。不过我对隐式马尔科夫不了解：《","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549179530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":59196,"user_name":"Alexis何春光","can_delete":false,"product_type":"c1","uid":1181149,"ip_address":"","ucode":"614570FAE3B56A","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/dd/b201cf13.jpg","comment_is_top":false,"comment_ctime":1547326903,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547326903","product_id":100017301,"comment_content":"可以跑出来的代码：<br>public int minNeededCoins(int[] coins, int w) {<br>\t\tint[] dp = new int[w + 1];<br>\t\tfor(int i = 1 ;i &lt; dp.length; i++) {<br>\t\t\tdp[i] = Integer.MAX_VALUE;<br>\t\t}<br>\t\tfor (int i = 1; i &lt; w + 1; i++) {<br>\t\t\tfor (int j = 0; j &lt; coins.length; j++) {<br>\t\t\t\tif (coins[j] &lt;= i){<br>\t\t\t\t\tint last = dp[i - coins[j]];<br>\t\t\t\t\tif(last != Integer.MAX_VALUE &amp;&amp; last + 1 &lt; dp[i])<br>\t\t\t\t\tdp[i] = last + 1;<br>\t\t\t\t}<br>\t\t\t}<br>\t\t}<br>\t\treturn dp[w];\t<br>\t}","like_count":0},{"had_liked":false,"id":59018,"user_name":"Dylan","can_delete":false,"product_type":"c1","uid":1040236,"ip_address":"","ucode":"58064D0C9F9F5F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/df/6c/5af32271.jpg","comment_is_top":false,"comment_ctime":1547273463,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547273463","product_id":100017301,"comment_content":"count[i]=min(f(i-v1),f(i-v2).....f(i-vn)) + 1,i &lt;= w；初始条件count[0] = 0，count[i]表示当钱总额是i的时候最少的硬币数。","like_count":0},{"had_liked":false,"id":58800,"user_name":"。。。","can_delete":false,"product_type":"c1","uid":1267092,"ip_address":"","ucode":"F4D90A500B66D3","user_header":"https://static001.geekbang.org/account/avatar/00/13/55/94/cefb8a05.jpg","comment_is_top":false,"comment_ctime":1547195695,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547195695","product_id":100017301,"comment_content":"不知道这算动态规划吗。。也不知道写的对嘛-- 希望老师能看见 硬币的解答 <br>public void coinDynamic02(int[] coinItem, int resultMemory) {<br>        &#47;&#47; 层数为总金额<br>        int levelNum = resultMemory;<br>        &#47;&#47; 长度为货币数值<br>        int length = coinItem.length;<br>        int[][] status = new int[levelNum + 1][length];<br>        &#47;&#47; 初始化状态数组<br>        for (int i = 0; i &lt;= levelNum; i++) {<br>            for (int j = 0; j &lt; length; j++) {<br>                status[i][j] = -1;<br>            }<br>        }<br>        &#47;&#47; 计算推导状态<br>        for (int i = 1; i &lt;= levelNum; i++) {<br>            for (int j = 0; j &lt; coinItem.length; j++) {<br>                int coin = coinItem[j];  int result = i - coin;<br>                if (result &lt; 0) {&#47;&#47; 如果小于零,说明货币价值本身超过了 需要的总金额<br>                    continue;<br>                } else if (result == 0) {&#47;&#47; 如果刚好等于 0 说明该货币价值 == 需要的总金额<br>                    status[i][j] = 1; &#47;&#47; 需要一个货币<br>                } else {&#47;&#47; 总金额 - coin  去找 上一个的总金额 是否有货币数<br>                    int[] subStatus = status[result];<br>                    int min = -1; &#47;&#47; 最少的货币数<br>                    for (int t = subStatus.length - 1; t &gt;= 0; --t) { &#47;&#47; 找到可以凑成总金额的最少的硬币数量的下标<br>                        if (subStatus[t] &gt; 0) {<br>                            min = t; break;<br>                        }<br>                    }<br>     if (min == -1) {&#47;&#47; 没有找到 就直接返回<br>                        continue;<br>                    }<br>                    int num = status[result][min];<br>                    status[i][j] = num + 1;<br>                }<br>            }<br>        }<br> &#47;&#47; 找到最小的货币数量<br> int i;<br> for (i = length - 1; i &gt;= 0; --i) {<br> if (status[resultMemory][i] &gt; 0) {<br> break;<br>}<br> }<br> if (i == -1) {&#47;&#47; 没有找到<br>return;<br>}<br>int sum = resultMemory;&#47;&#47; 需要的硬币数量<br>int num = status[resultMemory][i];<br> System.out.println(&quot;需要&quot; + coinItem[i]);<br>for (int j = num - 1; j &gt;= 1; --j) {<br>int coin = coinItem[i];<br> sum = sum - coin;<br> int t;<br>for (t = length - 1; t &gt;= 0; --t) {<br>if (status[sum][t] &gt; 0) {<br>break;<br>}<br>}<br>System.out.println(&quot;需要&quot; + coinItem[t]);<br> i = t;<br>    }<br>    }<br>","like_count":0},{"had_liked":false,"id":57705,"user_name":"Geek_41d472","can_delete":false,"product_type":"c1","uid":1247965,"ip_address":"","ucode":"DEC2B6329460CF","user_header":"https://static001.geekbang.org/account/avatar/00/13/0a/dd/88fa7b52.jpg","comment_is_top":false,"comment_ctime":1546872304,"is_pvip":false,"replies":[{"id":"21850","content":"多练练 写起来很轻松的：）","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1547708829,"ip_address":"","comment_id":57705,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546872304","product_id":100017301,"comment_content":"牛逼，让我自己想，我肯定想不出动态规划的算法，哈哈，看老师写的代码但是毫无压力。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435713,"discussion_content":"多练练 写起来很轻松的：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547708829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57198,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1546680746,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546680746","product_id":100017301,"comment_content":"这个思考题是不是可以简单地对硬币金额排序<br>如果每个硬币只能用一次 那么优先选最大的 再选次大的 依次类推 直到满足金额<br>如果每个硬币可以用多次 那更简单了就一直用最大金额的硬币 重复n次 直到满足金额","like_count":0},{"had_liked":false,"id":56551,"user_name":"siegfried","can_delete":false,"product_type":"c1","uid":1007931,"ip_address":"","ucode":"31673819DD2605","user_header":"https://static001.geekbang.org/account/avatar/00/0f/61/3b/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1546486795,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546486795","product_id":100017301,"comment_content":"<br><br>func findCoin(x, count) {<br>\tif (x &gt; 0) {<br>\t\treturn minCount(<br>\t\t\tfindCoin(n-5, count + 1),<br>\t\t\tfindCoin(n-3, count + 1),<br>\t\t\tfindCoin(n-1, count + 1)<br>\t\t);<br>\t}<br>\t<br>\tif (x == 0) {<br>\t\treturn count<br>\t}<br><br>\tif (x &lt; 0) {<br>\t\treturn count - 1<br>\t}<br>\t<br>}<br><br>findCoin(9, 0)<br><br>随手写一点思路。 1， 3， 5，三种硬币。 因此 9元的结果可以来自  n(8) + 1, n(6) + 3, n(4) + 5.   n(x)为, x为多少元的时候的组合方法。 递归，n(8) n(6) n(4)","like_count":0},{"had_liked":false,"id":56430,"user_name":"敬艺","can_delete":false,"product_type":"c1","uid":1109680,"ip_address":"","ucode":"08B559B123A1BB","user_header":"https://static001.geekbang.org/account/avatar/00/10/ee/b0/fb5bad5c.jpg","comment_is_top":false,"comment_ctime":1546442079,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546442079","product_id":100017301,"comment_content":"“从 (0, 0) 走到 (n-1, n-1)，总共要走 2*(n-1) 步”，请问这个是如何计算得来的？","like_count":0},{"had_liked":false,"id":56421,"user_name":"Xianping","can_delete":false,"product_type":"c1","uid":1240709,"ip_address":"","ucode":"108EF4AFF699C9","user_header":"https://static001.geekbang.org/account/avatar/00/12/ee/85/59e39469.jpg","comment_is_top":false,"comment_ctime":1546441119,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546441119","product_id":100017301,"comment_content":"似懂非懂","like_count":0},{"had_liked":false,"id":56420,"user_name":"Xianping","can_delete":false,"product_type":"c1","uid":1240709,"ip_address":"","ucode":"108EF4AFF699C9","user_header":"https://static001.geekbang.org/account/avatar/00/12/ee/85/59e39469.jpg","comment_is_top":false,"comment_ctime":1546441076,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546441076","product_id":100017301,"comment_content":"越来越难","like_count":0},{"had_liked":false,"id":56419,"user_name":"Xianping","can_delete":false,"product_type":"c1","uid":1240709,"ip_address":"","ucode":"108EF4AFF699C9","user_header":"https://static001.geekbang.org/account/avatar/00/12/ee/85/59e39469.jpg","comment_is_top":false,"comment_ctime":1546441039,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546441039","product_id":100017301,"comment_content":"难度，成基数级别增长，一下子似懂非懂了，听着好像懂了，关了一想，又不懂了","like_count":0},{"had_liked":false,"id":55969,"user_name":"纯洁的憎恶","can_delete":false,"product_type":"c1","uid":1130512,"ip_address":"","ucode":"5E9757DE6F45DF","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/10/b6bf3c3c.jpg","comment_is_top":false,"comment_ctime":1546357249,"is_pvip":true,"replies":[{"id":"20168","content":"动态规划确实挺难的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1546393530,"ip_address":"","comment_id":55969,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546357249","product_id":100017301,"comment_content":"感觉难度一下子提升了好多","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434903,"discussion_content":"动态规划确实挺难的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546393530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":55950,"user_name":"ban","can_delete":false,"product_type":"c1","uid":1034204,"ip_address":"","ucode":"E523CE97E48266","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c7/dc/9408c8c2.jpg","comment_is_top":false,"comment_ctime":1546353479,"is_pvip":false,"replies":[{"id":"20174","content":"嗯嗯 我改下","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1546393743,"ip_address":"","comment_id":55950,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546353479","product_id":100017301,"comment_content":"二维状态表，是不是不对，第一行图中是1  4  8  18<br>不应该是1  4  9（4+5=9）  18 <br>？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434896,"discussion_content":"嗯嗯 我改下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546393743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":55699,"user_name":"蓝心","can_delete":false,"product_type":"c1","uid":1236484,"ip_address":"","ucode":"2230EB2DEB6DF6","user_header":"https://static001.geekbang.org/account/avatar/00/12/de/04/a597d056.jpg","comment_is_top":false,"comment_ctime":1546264733,"is_pvip":false,"replies":[{"id":"20244","content":"嗯嗯 我改下","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1546417866,"ip_address":"","comment_id":55699,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546264733","product_id":100017301,"comment_content":"动态规划思想：状态转移方程法（递归+“备忘录”）<br>代码的备忘录 初始化为了5x5的数组，不是应该是4x4？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434827,"discussion_content":"嗯嗯 我改下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546417866,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":55643,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1546251199,"is_pvip":false,"replies":[{"id":"20191","content":"有点贪心的意思。<br>肯定是最优解的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1546394472,"ip_address":"","comment_id":55643,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546251199","product_id":100017301,"comment_content":"老师，状态转移表中，求解当前最小值，是不是就是贪心算法的思想？<br><br>最优子结构算出的最终结果，并不一定是最优解吧？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434819,"discussion_content":"有点贪心的意思。\n肯定是最优解的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546394472,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":55490,"user_name":"失火的夏天","can_delete":false,"product_type":"c1","uid":1241770,"ip_address":"","ucode":"10C6E66EB2A65F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","comment_is_top":false,"comment_ctime":1546217462,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546217462","product_id":100017301,"comment_content":"思考题用一个数组记录到每一个元所需要的个数，动态规划方程a[i]=min(a[i+1]-v1，a[i+1]－v2....)+1。<br><br>老师说都不是所以问题都能用动态规划解决，那些不具有最有子结构的问题，如果使用动态规划，就利用不到动态规划的特征，无法提供时间效率，还反而让空间复杂度变高","like_count":0}]}