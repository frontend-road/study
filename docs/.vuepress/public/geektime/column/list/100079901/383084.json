{"id":383084,"title":"08｜复杂状态处理：如何保证状态一致性？","content":"<p>你好，我是王沛。今天我们聊聊 React 中的状态管理。</p><p>从这节课开始，我们就进入到了实战篇的训练。React Hooks 中其实有一些通用原则和常见设计模式，所以我设计了几个典型的业务场景，这样你就可以对这些原则和模式有一个具体的印象，之后在遇到类似场景时，也能从容应对。</p><p>今天我们先从状态一致性这个需求开始讲起。我在基础篇就反复提到过，React 中 UI 完全是通过状态驱动的。所以在任何时刻，整个应用程序的状态数据就完全决定了当前 UI 上的展现。毫不夸张地说，React 的开发其实就是复杂应用程序状态的管理和开发。因此，这就需要你去仔细思考，<strong>该怎么去用最优、最合理的方式，去管理你的应用程序的状态。</strong></p><p>所以今天这节课我会带你围绕状态一致性这个需求，介绍两个基本原则，它们能帮助我们避免很多复杂的状态管理逻辑，简化应用程序的开发。</p><h1>原则一：保证状态最小化</h1><p>新接触 React 的同学经常会有一个错误的习惯，就是把 State 当变量用，很容易把过多的数据放到 State 里，可以说这是对 State 的一种滥用。</p><p>那到底该怎么使用 State 呢？我们需要遵循一个原则，即：<strong>在保证 State 完整性的同时，也要保证它的最小化。</strong>什么意思呢？</p><p>就是说，某些数据如果能从已有的 State 中计算得到，那么我们就应该始终在用的时候去计算，而不要把计算的结果存到某个 State 中。这样的话，才能简化我们的状态处理逻辑。</p><!-- [[[read_end]]] --><p>举个例子。你要做一个功能，需要对一个列表的结果进行关键字搜索，我们假设是一个显示电影标题的列表，需要能够对标题进行搜索。最终的效果如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/80/10/80eb70a42a50b47a131f5af57130d210.png?wh=678*532\" alt=\"\"></p><p>可以看到，这个功能包括一个搜索框和一个电影标题的列表。那么，在考虑怎么实现这个功能的时候，应该从哪里着手呢？</p><p>按照 React 的状态驱动 UI 的思想，第一步就是<strong>要考虑整个功能有哪几个状态</strong>。直观上来说，页面可能包含三个状态：</p><ol>\n<li>电影列表的数据：可能来自某个 API 请求；</li>\n<li>用户输入的关键字：来自用户的输入；</li>\n<li>搜索的结果数据：来自原始数据结合关键字的过滤结果。</li>\n</ol><p>那么很多同学这时候就会在组件中去定义这三个状态，一般的实现代码如下：</p><pre><code>function FilterList({ data }) {\n  // 设置关键字的 State\n  const [searchKey, setSearchKey] = useState('');\n  // 设置最终要展示的数据状态，并用原始数据作为初始值\n  const [filtered, setFiltered] = useState(data);\n\n  // 处理用户的搜索关键字\n  const handleSearch = useCallback(evt =&gt; {\n    setSearchKey(evt.target.value);\n    setFiltered(data.filter(item =&gt; {\n      return item.title.includes(evt.target.value)));\n    }));\n  }, [filtered])\n  return (\n    &lt;div&gt;\n      &lt;input value={searchKey} onChange={handleSearch} /&gt;\n      {/* 根据 filtered 数据渲染 UI */}\n    &lt;/div&gt;\n  );\n}\n</code></pre><p>看上去没有太大问题，整段代码也能正常工作。但是如果仔细思考，你会发现其中隐藏的一致性的问题：展示的结果数据完全由原始数据和关键字决定，而现在却作为一个独立的状态去维护了。这意味着你始终要在原始数据、关键字和结果数据之间保证一致性。</p><p>在代码中，我们已经做了一部分维护一致性的工作，那就是当关键字变化时，我们会同时更新关键字和最终结果这两个状态，从而让这两个状态始终保持一致。</p><p>不过还有部分一致性的工作没有被考虑到，那就是如果原始数据 data 属性变化了，最终的结果却没有使用新的数据。</p><p>这个时候你可能就又会问了：我在处理关键字变化的同时，再处理一下 data 属性变化的场景，这样不就可以保证三个状态的一致性了吗？比如再加上下面这段代码。</p><pre><code>function FilterList({ data }) {\n  // ...\n  // 在 data 变化的时候，也重新生成最终数据\n  useEffect(() =&gt; {\n    setFiltered(data =&gt; {...})\n  }, [data, searchKey])\n  // ...\n}\n</code></pre><p>现在，我们终于能够保证三个状态的一致性了，整个搜索列表也能正常工作了！但是我们在获得一些成就感的同时，是不是也有一些小小的抱怨：这状态管理确实还挺复杂的，需要写这么多的逻辑来保证一致性，从而让功能正常工作。</p><p>那么，我想说的是，这种复杂性其实完全不需要。因为复杂性的根源就在于没有遵循状态最小化的原则，而是设计了一个多余的状态：<strong>过滤后的结果数据</strong>。由于这个结果数据实际上完全由原始数据和过滤关键字决定，那么我们在需要的时候每次重新计算得出就可以了。</p><p>那时候你可能又有疑问了，如果每次都计算，不是会有性能问题吗？其实在第4讲我已经提到，React 提供的 useMemo 这个 Hook 正是为了解决这个问题，可以缓存计算的结果。所以实现的代码可以修改如下：</p><pre><code>import React, { useState, useMemo } from &quot;react&quot;;\n\nfunction FilterList({ data }) {\n  const [searchKey, setSearchKey] = useState(&quot;&quot;);\n  \n  // 每当 searchKey 或者 data 变化的时候，重新计算最终结果\n  const filtered = useMemo(() =&gt; {\n    return data.filter((item) =&gt;\n      item.title.toLowerCase().includes(searchKey.toLowerCase())\n    );\n  }, [searchKey, data]);\n\n  return (\n    &lt;div className=&quot;08-filter-list&quot;&gt;\n      &lt;h2&gt;Movies&lt;/h2&gt;\n      &lt;input\n        value={searchKey}\n        placeholder=&quot;Search...&quot;\n        onChange={(evt) =&gt; setSearchKey(evt.target.value)}\n      /&gt;\n      &lt;ul style={{ marginTop: 20 }}&gt;\n        {filtered.map((item) =&gt; (\n          &lt;li key={item.id}&gt;{item.title}&lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre><p>可以看到，除了通过属性传递进来的 data 状态，我们只定义了一个 searchKey 这个状态。然后通过计算的方式，就可以得到最终需要展现的结果。这样，状态的一致性就得到了天然的保证。你看，通过使用状态最小化的原则，管理就变得非常简单了。</p><p>虽然这是一个比较简单的例子，但是在实际开发的过程中，很多复杂场景之所以变得复杂，如果抽丝剥茧来看，你会发现它们都有<strong>定义多余状态现象</strong>的影子，而问题的根源就在于<strong>它们没有遵循状态最小化的原则</strong>。</p><p>所以我们在定义一个新的状态之前，都要再三拷问自己：<strong>这个状态是必须的吗？是否能通过计算得到呢？</strong>在得到肯定的回答后，我们再去定义新的状态，就能避免大部分多余的状态定义问题了，也就能在简化状态管理的同时，保证状态的一致性。</p><h1>原则二：避免中间状态，确保唯一数据源</h1><p>上面的例子其实定义的多余状态比较明显，但在有的场景下，特别是原始状态数据来自某个外部数据源，而非 state 或者 props 的时候，冗余状态就没那么明显。这时候你就需要准确定位状态的数据源究竟是什么，并且在开发中确保它始终是唯一的数据源，以此避免定义中间状态。</p><p>还是拿刚才讲的可搜索电影列表的例子来说，我们需要在用户体验上做一个改进，要让搜索的结果做到可分享。这个功能就类似 Baidu 这样的搜索引擎，通过一个链接就能分享搜索结果。比如说，你通过“<a href=\"http://www.baidu.com/s?wd=%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4\">http://www.baidu.com/s?wd=极客时间</a>”就可以看到极客时间的搜索结果。</p><p>想象一下，如果搜索引擎没有这个功能，那使用起来会有多么不方便。每次要分享一个搜索结果，都必须告诉别人关键字是什么，让他/她自己打开 Baidu 去搜索。所以将关键字放到 URL 中也是实际开发中经常遇到的一个需求。</p><p>那么要实现这个功能，我们就需要让 URL 中包含搜索关键字的信息，这样任何人用这个 URL ，就都能看到和我一样的搜索关键字和结果了。</p><p>在考虑这个功能实现，尤其是基于已有功能做改进的时候，通常来说，直观的思路都是：首先把 URL 上的参数数据保存在一个 State 中，当URL 变化时，就去改变这个 State。然后在组件中再根据这个 State 来实现搜索的业务逻辑。</p><p>按照这个思路来改进电影列表的话，我们就可以用类似下面的代码来实现：</p><pre><code>// getQuery 函数用户获取 URL 的查询字符串\nimport getQuery from './getQuery';\n// history 工具可以用于改变浏览器地址\nimport history from './history';\n\nfunction SearchBox({ data }) {\n  // 定义关键字这个状态，用 URL 上的查询参数作为初始值\n  const [searchKey, setSearchKey] = useState(getQuery('key'));\n  // 处理用户输入的关键字\n  const handleSearchChange = useCallback(evt =&gt; {\n    const key = evt.target.value;\n    // 设置当前的查询关键状态\n    setSearchKey(key);\n    // 改变 URL 的查询参数\n    history.push(`/movie-list?key=${key}`);\n  })\n  // ....\n  return (\n    &lt;div className=&quot;08-search-box&quot;&gt;\n      &lt;input\n        value={searchKey}\n        placeholder=&quot;Search...&quot;\n        onChange={handleSearchChange}\n      /&gt;\n      {/* 其它渲染逻辑*/}\n    &lt;/div&gt;\n  );\n}\n</code></pre><p>可以看到，组件的核心逻辑基本没变，只是做了两个小的变化：</p><ol>\n<li>把 URL 上的查询参数作为关键字的默认值；</li>\n<li>当用户输入搜索关键字时，我们不但更新了内部 State，同时还改变了 URL 的查询参数。</li>\n</ol><p>通过这两个小的变化，我们就实现了搜索结果的可分享。看上去似乎没有什么问题：保证了关键字状态，还有 URL 参数的一致性。但是正如我刚才强调的，一旦涉及到主动保持一致性的逻辑，我们就要考虑状态是否真的有必要。</p><p>所以我们再仔细思考下，就会发现上面的逻辑是有漏洞的。因为从 URL 参数到内部 State 的同步只有组件第一次渲染才会发生，而后面的同步则是由输入框的 onChange 事件保证的，那么一致性就很容易被破坏。</p><p>也就是说，如果 URL 不是由用户在组件内搜索栏去改变的，而是其它地方，比如说组件外的某个按钮去触发改变的，那么组件由于已经渲染过了，其实内部的 searchKey 这个 State 是不会被更新的，一致性就会被破坏。</p><p>要解决这个问题，一个比较容易想到的思路就是<strong>我们要有更加完善的机制，让在 URL 不管因为什么原因而发生变化的时候，都能同步查询参数到 searchKey 这个 State</strong>。但是如果沿着这个思路，那么状态管理就会一下子变得非常复杂。因为我们需要维护三个状态的一致性。</p><p>其实，从根源上来说，产生这个复杂度的问题在于我们定义了 searchKey 这样一个多余的中间状态，而且这个 searchKey 状态来源于两个数据源：一是用户输入；二是 URL 上的参数。这就导致逻辑非常复杂。</p><p>那么如果我们遵循唯一数据源这个原则，把 URL 上的查询关键字作为唯一数据源，逻辑就会变得简单了：只需要在用户输入查询关键字时，直接去改变 URL 上的查询字符串就行。这个转变可以用下面的图做一个对比，你会更直观地理解：</p><p><img src=\"https://static001.geekbang.org/resource/image/9f/de/9f534fa5235d0a45cafec91cbfa9e4de.png?wh=1462*572\" alt=\"\"></p><p>通过对比可以看到，左边引入了一个多余的 State 作为关键字这个状态，而为了保证一致性，就需要很多复杂的同步逻辑，比如说以下几点：</p><ul>\n<li>URL 变化时，同步查询关键字到 State；</li>\n<li>State 变化时，同步查询关键字到输入框；</li>\n<li>用户在输入框输入的时候，同步关键字到 URL 和 State。</li>\n</ul><p>但是，在去掉多余的 State 后，我们就只需要在输入框和 URL 的查询参数之间做一个同步。那么实现的代码可以简化如下：</p><pre><code>import React, { useCallback, useMemo } from &quot;react&quot;;\nimport { useSearchParam } from &quot;react-use&quot;;\n\nfunction SearchBox({ data }) {\n  // 使用 useSearchParam 这个 Hook 用于监听查询参数变化\n  const searchKey = useSearchParam(&quot;key&quot;) || &quot;&quot;;\n  const filtered = useMemo(() =&gt; {\n    return data.filter((item) =&gt;\n      item.title.toLowerCase().includes(searchKey.toLowerCase())\n    );\n  }, [searchKey, data]);\n\n  const handleSearch = useCallback((evt) =&gt; {\n    // 当用户输入时，直接改变 URL\n    window.history.pushState(\n      {},\n      &quot;&quot;,\n      `${window.location.pathname}?key=${evt.target.value}`\n    );\n  }, []);\n  return (\n    &lt;div className=&quot;08-filter-list&quot;&gt;\n      &lt;h2&gt;Movies (Search key from URL)&lt;/h2&gt;\n      &lt;input\n        value={searchKey}\n        placeholder=&quot;Search...&quot;\n        onChange={handleSearch}\n      /&gt;\n      &lt;ul style={{ marginTop: 20 }}&gt;\n        {filtered.map((item) =&gt; (\n          &lt;li key={item.id}&gt;{item.title}&lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre><p>可以看到，当用户输入参数的时候，我们是直接改变当前的 URL，而不是去改变一个内部的状态。所以当 URL 变化的时候，我们使用了 useSearchParam 这样一个第三方的 Hook 去绑定查询参数，并将其显示在输入框内，从而实现了输入框内容和查询关键字这个状态的同步。</p><p>从本质上来说，这个例子展示了确保状态唯一数据源的重要性。我们是直接将 URL 作为唯一的数据来源，那么状态的读取和修改都是对 URL 直接进行操作，而不是通过一个中间的状态。这样就简化了状态的管理，保证了状态的一致性。</p><h1>实战演练：创建自定义受控组件</h1><p>在前面两个例子中，你看到了状态管理的两个很重要的原则，一个是确保状态最小化，另一个则是找到正确的状态来源，并直接使用这个来源，避免中间状态。那么接下来我再通过一个日常开发中非常常见的例子，来帮助你理解和掌握这两个原则的实际应用。</p><p>这个例子就是创建一个受控表单组件。比如，一个用于输入价格的表单组件，需要用户既能输入价格的数量，还能选择货币的种类，最终的效果类似下面这个图：</p><p><img src=\"https://static001.geekbang.org/resource/image/02/53/02e4012e1fb549eyyaa8ccb433344753.png?wh=480*92\" alt=\"\"></p><p>首先我要解释下什么是受控组件。在 React 中，对表单组件的处理可以分为两种，受控组件和非受控组件：</p><ol>\n<li>受控组件：组件的展示完全由传入的属性决定。比如说，如果一个输入框中的值完全由传入的 value 属性决定，而不是由用户输入决定，那么就是受控组件，写法是：&lt; input value={value} onChange={handleChange} /&gt;。这也是为什么只给 &lt; input/&gt; 传了一个 value 值但是没有传 onChange 事件，那么键盘怎么输入都没有反应。</li>\n<li>非受控组件：表单组件可以有自己的内部状态，而且它的展示值是不受控的。比如 input 在非受控状态下的写法是：&lt; input onChange={handleChange}/&gt;。也就是说，父组件不会把 value 直接传递给 input 组件。</li>\n</ol><p>在日常开发中，大部分的表单元素其实都是受控组件，我们会通过外部的状态完全控制当前组件的行为。</p><p>那么对于这个例子，价格输入框作为一个受控组件，它需要定义两个属性：value 和 onChange。这样它就和一个普通的表单元素具有相同用法了。其中 value 的值是一个对象，同时包含数值和货币两个属性，比如：</p><pre><code>{\n  amount: 0,\n  currency: 'rmb',\n}\n</code></pre><p>那现在我们就来看如何实现这个受控组件。在这里我就不再演示错误的写法是什么样的了，而是直接给你看正确的实现方式。</p><p>在实际项目中，我经常看到很多同学会把这个简单的功能做得逻辑非常复杂，甚至还不断出现 Bug，总不能保证 UI 和数据的一致性。这其实都是因为没有仔细思考状态的准确来源是什么，以及是否定义了多余的状态。</p><p>我们先直接来看正确的实现：</p><pre><code>import React, { useState, useCallback } from &quot;react&quot;;\n\nfunction PriceInput({\n  // 定义默认的 value 的数据结构\n  value = { amount: 0, currency: &quot;rmb&quot; },\n  // 默认不处理 onChange 事件\n  onChange = () =&gt; {}\n}) {\n  // 定义一个事件处理函数统一处理 amount 或者 currency 变化的场景\n  const handleChange = useCallback(\n    (deltaValue) =&gt; {\n      // 直接修改外部的 value 值，而不是定义内部 state\n      onChange({\n        ...value,\n        ...deltaValue\n      });\n    },\n    [value, onChange]\n  );\n  return (\n    &lt;div className=&quot;exp-02-price-input&quot;&gt;\n      {/* 输入价格的数量 */}\n      &lt;input\n        value={value.amount}\n        onChange={(evt) =&gt; handleChange({ amount: evt.target.value })}\n      /&gt;\n      {/* 选择货币种类*/}\n      &lt;select\n        value={value.currency}\n        onChange={(evt) =&gt; handleChange({ currency: evt.target.value })}\n      &gt;\n        &lt;option value=&quot;rmb&quot;&gt;RMB&lt;/option&gt;\n        &lt;option value=&quot;dollar&quot;&gt;Dollar&lt;/option&gt;\n      &lt;/select&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre><p>可以看到，这个自定义组件包含了 input 和 select 两个基础组件，分别用来输入价格数量和选择货币。在它们发生变化的时候，直接去触发 onChange 事件让父组件去修改 value 值；同样的，它们自己显示的值，则完全来自于传递进来的 value 属性。所以这其中的思考逻辑在于：</p><ol>\n<li>避免多余的状态：我们不需要在 PriceInput 这个自定义组件内部，去定义状态用于保存的 amount 或者 currency。</li>\n<li>找到准确的唯一数据源：这里内部两个基础组件的值，其准确且唯一的来源就是 value 属性，而不是其它的任何中间状态。</li>\n</ol><p>因此，通过这样的做法，整个自定义的组件逻辑就变得非常简单，甚至不需要任何内部的状态，就实现了这样一个非常常见的需求。</p><p>而在我看到的实际项目代码中，发现很多同学都习惯于用多余的内部状态去分别保存 amount 和 currency，然后再和外部传进来的 value 属性进行同步，以此来保证一致性，这就造成了状态逻辑的复杂。所以我们在做类似功能的时候，一定要避免这种不合理的做法，尽量用最简洁的逻辑去实现需要的功能。</p><h1>小结</h1><p>好了，这节课的内容就是这些，我简单小结一下。你可以把 React 的开发看作是复杂状态的管理和维护。那么为了保证状态的一致性，我们就一定要简化状态处理的逻辑。其中有两个重要的原则需要遵循：</p><ul>\n<li>一个是状态最小化原则，也就是说要避免冗余的状态；</li>\n<li>另一个则是唯一数据源原则，避免中间状态。</li>\n</ul><p>所以，在任何时候想要定义新状态的时候，都要问自己一下：这个状态有必要吗？是否能通过计算得到？是否只是一个中间状态？只有每次都仔细思考了，才能找到需要定义的最本质的状态。然后围绕这个最本质的状态去思考某个功能具体的实现，从而让 React 的开发更加简洁和高效。</p><p>这节课所有的示例代码，你可以通过 codesandbox 查看：<a href=\"https://codesandbox.io/s/react-hooks-course-20vzg?file=/src/08/PriceInput.js:0-802\">https://codesandbox.io/s/react-hooks-course-20vzg</a>.</p><h1>思考题</h1><p>在第二个在URL 中包含查询关键字的例子中，我们用到了 userSearchParams 这样一个第三方的 Hook，用于绑定 URL 上的查询字符串参数。如果让你实现这个 Hook，你会怎么做呢？</p><p>欢迎在评论区写下你的思考和想法，我会和你交流讨论。如果今天的实战演练让你有所收获，也欢迎把课程分享给你的同事、朋友，我们共同进步！</p>","neighbors":{"left":{"article_title":"07｜全局状态管理：如何在函数组件中使用 Redux？","id":382459},"right":{"article_title":"答疑解惑01｜如何转换应用React Hooks 的思路？","id":384252}},"comments":[{"had_liked":false,"id":339836,"user_name":"Geek_e6b8eb","can_delete":false,"product_type":"c1","uid":2955055,"ip_address":"","ucode":"C675EB2AACE319","user_header":"","comment_is_top":true,"comment_ctime":1648432182,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"9.2233720385032008e+18","product_id":100079901,"comment_content":"真的后悔没有早一点看到这个课程，之前我就维护了很多中间代码，最后弄得一个组件超级复杂。 &#47;(ㄒoㄒ)&#47;~~","like_count":0},{"had_liked":false,"id":297055,"user_name":"Isaac","can_delete":false,"product_type":"c1","uid":1110607,"ip_address":"","ucode":"038C349AB508AB","user_header":"https://static001.geekbang.org/account/avatar/00/10/f2/4f/59bd4141.jpg","comment_is_top":false,"comment_ctime":1623292079,"is_pvip":false,"replies":[{"id":"107973","content":"赞~ history API 是比较特别的，只能用 patch 的方法来监听 url 变化。","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1623470272,"ip_address":"","comment_id":297055,"utype":1}],"discussion_count":5,"race_medal":0,"score":"48867932335","product_id":100079901,"comment_content":"思考题回答：<br>由于 hisgory.pushState 不会触发页面重新渲染，也不会导致组件更新，所以，默认的 userSearchParams 只会获取第一次的 URL 上的查询字符串。因此，为了解决这个问题，可以通过监听 pushstate、replaceState 等事件，对状态进行同步。<br><br>其实去阅读 react-us 的源码实现，也是采用了这种办法。<br>https:&#47;&#47;github.com&#47;streamich&#47;react-use&#47;blob&#47;90e72a5340460816e2159b2c461254661b00e1d3&#47;src&#47;useSearchParam.ts#L8","like_count":12,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521699,"discussion_content":"赞~ history API 是比较特别的，只能用 patch 的方法来监听 url 变化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623470272,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1110607,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f2/4f/59bd4141.jpg","nickname":"Isaac","note":"","ucode":"038C349AB508AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378727,"discussion_content":"这里补充一下，其实浏览器默认不支持监听 pushState 的，所以需要我们对 history 对象做一层劫持。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1623374545,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2936579,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLJgN2pOV8RpojoWiaF4zfv963IiaSsNtby4FQB4NZgKEdbHJNpuV3m47ezpr2Be0UnibPnx1P3a4hgg/132","nickname":"Geek_73e833","note":"","ucode":"4132C0B36A016D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1110607,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f2/4f/59bd4141.jpg","nickname":"Isaac","note":"","ucode":"038C349AB508AB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579114,"discussion_content":"大佬解释一下，在哪里做的劫持","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657179080,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":378727,"ip_address":""},"score":579114,"extra":""}]},{"author":{"id":2936579,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLJgN2pOV8RpojoWiaF4zfv963IiaSsNtby4FQB4NZgKEdbHJNpuV3m47ezpr2Be0UnibPnx1P3a4hgg/132","nickname":"Geek_73e833","note":"","ucode":"4132C0B36A016D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579120,"discussion_content":"奥，明白了，react-use 源码在这里，劫持在这里\nconst patchHistoryMethod = (method) =&gt; {\n  const history = window.history;\n  const original = history[method];\n\n  history[method] = function (state) {\n    const result = original.apply(this, arguments);\n    const event = new Event(method.toLowerCase());\n\n    (event as any).state = state;\n\n    window.dispatchEvent(event);\n\n    return result;\n  };\n};\n\nif (isBrowser) {\n  patchHistoryMethod(&#39;pushState&#39;);\n  patchHistoryMethod(&#39;replaceState&#39;);\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657180929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2936579,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLJgN2pOV8RpojoWiaF4zfv963IiaSsNtby4FQB4NZgKEdbHJNpuV3m47ezpr2Be0UnibPnx1P3a4hgg/132","nickname":"Geek_73e833","note":"","ucode":"4132C0B36A016D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579113,"discussion_content":"自己用addEventListener监听popstate，pushstate， replacestate，这三个都没有用，看react-use也是这三个，“patch的方法” 是啥意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657179018,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":297126,"user_name":"Jerryz","can_delete":false,"product_type":"c1","uid":1232276,"ip_address":"","ucode":"9DAEEAAE70FA00","user_header":"https://static001.geekbang.org/account/avatar/00/12/cd/94/0d44361e.jpg","comment_is_top":false,"comment_ctime":1623320044,"is_pvip":false,"replies":[{"id":"107950","content":"👍","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1623388876,"ip_address":"","comment_id":297126,"utype":1}],"discussion_count":3,"race_medal":0,"score":"35983058412","product_id":100079901,"comment_content":"默认 history.pushState 和 history.replaceState 都没有对应的监听事件。react-use patch 了history 对象。","like_count":8,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521729,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623388876,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1089037,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9e/0d/743ba4ef.jpg","nickname":"GENTAR RAY","note":"","ucode":"4ABA3939EA184F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393569,"discussion_content":"应该是我只 import 了 useSearchParams 而相关的 patch 在 useLocation 里，最后 npm run build 的时候是 production 模式的 webpack，直接 tree-shaking 给抖掉了，而开发环境没有 tree-shaking， 发现不了问题。。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1631498214,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1089037,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9e/0d/743ba4ef.jpg","nickname":"GENTAR RAY","note":"","ucode":"4ABA3939EA184F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393461,"discussion_content":"最近用 useSearchParams 遇到了一个问题，用 create-react-app 创建出来的项目打包之后发现 useSearchParams 不能正常工作，原因是 react-use 源码里有这样一段代码(https://github.com/streamich/react-use/blob/master/src/useLocation.ts#L20)\n具体原因还没弄清楚，但是 root cause 就在这了，仅供参考 。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631441386,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":303053,"user_name":"Geek_0330fe","can_delete":false,"product_type":"c1","uid":2377130,"ip_address":"","ucode":"3324AF1AD2DC8C","user_header":"","comment_is_top":false,"comment_ctime":1626557577,"is_pvip":false,"replies":[{"id":"109867","content":"第三方库的目的正是简化你的应用逻辑。其内部如何实现都不会影响你的应用的复杂度，也无需关系它内部如何实现。","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1626854464,"ip_address":"","comment_id":303053,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18806426761","product_id":100079901,"comment_content":"react-use 的 useSearchParams 中也使用了一个 state 去维护了一个状态，这是不是说明复杂度不会消失，只会转移呢？我们只是把我们本来要维护的那个状态交给第三方库去维护了。","like_count":4,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523536,"discussion_content":"第三方库的目的正是简化你的应用逻辑。其内部如何实现都不会影响你的应用的复杂度，也无需关系它内部如何实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626854464,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":297009,"user_name":"Geeker","can_delete":false,"product_type":"c1","uid":1032345,"ip_address":"","ucode":"9937127DE96D78","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c0/99/259a412f.jpg","comment_is_top":false,"comment_ctime":1623281190,"is_pvip":true,"replies":[{"id":"107952","content":"可以说，直接降低了代码复杂度~","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1623388930,"ip_address":"","comment_id":297009,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18803150374","product_id":100079901,"comment_content":"状态最小化原则直接影响了代码的复杂度","like_count":4,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521680,"discussion_content":"可以说，直接降低了代码复杂度~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623388930,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":297048,"user_name":"Isaac","can_delete":false,"product_type":"c1","uid":1110607,"ip_address":"","ucode":"038C349AB508AB","user_header":"https://static001.geekbang.org/account/avatar/00/10/f2/4f/59bd4141.jpg","comment_is_top":false,"comment_ctime":1623291029,"is_pvip":false,"replies":[{"id":"107974","content":"是的，跨组件的数据共享就需要 Redux 这样的全局状态管理机制了。","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1623470309,"ip_address":"","comment_id":297048,"utype":1}],"discussion_count":7,"race_medal":0,"score":"14508192917","product_id":100079901,"comment_content":"老师，文章中的列表筛选的例子，虽然使用 useMemo 可以缓存，但是如果多个组件实例用到，岂不是还是会出现多次计算？","like_count":3,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521694,"discussion_content":"是的，跨组件的数据共享就需要 Redux 这样的全局状态管理机制了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623470309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1110607,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f2/4f/59bd4141.jpg","nickname":"Isaac","note":"","ucode":"038C349AB508AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378899,"discussion_content":"嗯嗯 明白 ，谢谢同学和老师的回复交流 😁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623498031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1168127,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d2/ff/99d2e7f5.jpg","nickname":"|G. XIAO|","note":"","ucode":"75DA0B3047A2F0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378657,"discussion_content":"如果多个组件实例用到，是不是可以把列表筛选的这个方法，抽象成一个  Hooks，然后多个组件实例引用即可","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623325376,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1110607,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f2/4f/59bd4141.jpg","nickname":"Isaac","note":"","ucode":"038C349AB508AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1168127,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d2/ff/99d2e7f5.jpg","nickname":"|G. XIAO|","note":"","ucode":"75DA0B3047A2F0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378726,"discussion_content":"这个已经是一个 hook 了呀，抽象成一个 Hooks ，意思是单独写到一个文件里吗？如果是这样的话，本质没啥区别，每个组件去使用的时候会都执行一遍。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623374372,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":378657,"ip_address":""},"score":378726,"extra":""},{"author":{"id":1168127,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d2/ff/99d2e7f5.jpg","nickname":"|G. XIAO|","note":"","ucode":"75DA0B3047A2F0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1110607,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f2/4f/59bd4141.jpg","nickname":"Isaac","note":"","ucode":"038C349AB508AB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378730,"discussion_content":"1.嗯嗯，我是这里理解的，在抽取一个 Hooks 问题不大，这样也能保证数据源的唯一性\n2.使用 useMemo，依赖没有变化，使用缓存的数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623375895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":378726,"ip_address":""},"score":378730,"extra":""},{"author":{"id":1110607,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f2/4f/59bd4141.jpg","nickname":"Isaac","note":"","ucode":"038C349AB508AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1168127,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d2/ff/99d2e7f5.jpg","nickname":"|G. XIAO|","note":"","ucode":"75DA0B3047A2F0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378843,"discussion_content":"我这里主要纠结的地方在于，假设我有A、B 两个组件，都调用了这个 Hook ，那么 A、B 两个组件都会执行一遍过滤 list 的操作，即使你用了 useMemo。\n所以，我理解的是，如果有多个组件需要使用的 filterList（过滤后的 list），那么是否将 filterList 直接存储到 redux 中更好？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623462379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":378730,"ip_address":""},"score":378843,"extra":""}]}]},{"had_liked":false,"id":297362,"user_name":"寇云","can_delete":false,"product_type":"c1","uid":1001332,"ip_address":"","ucode":"87181F16F83543","user_header":"https://static001.geekbang.org/account/avatar/00/0f/47/74/5e292ded.jpg","comment_is_top":false,"comment_ctime":1623483885,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10213418477","product_id":100079901,"comment_content":"老师第一个例子中，数据的请求放到当前组件中好还是由外部传入好？","like_count":2},{"had_liked":false,"id":297156,"user_name":"守望","can_delete":false,"product_type":"c1","uid":1560187,"ip_address":"","ucode":"09FD14D30F26CB","user_header":"https://static001.geekbang.org/account/avatar/00/17/ce/7b/f9b418d8.jpg","comment_is_top":false,"comment_ctime":1623332485,"is_pvip":false,"replies":[{"id":"107948","content":"虽然看上去有点像，但不太一样哦~","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1623388694,"ip_address":"","comment_id":297156,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10213267077","product_id":100079901,"comment_content":"这是不是和单向数据流差不多呀！！！<br>数据流向总是一条线，不要开新分支","like_count":2,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521737,"discussion_content":"虽然看上去有点像，但不太一样哦~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623388694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":297153,"user_name":"傻子来了快跑丶","can_delete":false,"product_type":"c1","uid":1282777,"ip_address":"","ucode":"662624121A1DFA","user_header":"https://static001.geekbang.org/account/avatar/00/13/92/d9/84c1de45.jpg","comment_is_top":false,"comment_ctime":1623330771,"is_pvip":false,"replies":[{"id":"107949","content":"数据处理为什么要在父组件呢？","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1623388838,"ip_address":"","comment_id":297153,"utype":1}],"discussion_count":4,"race_medal":0,"score":"10213265363","product_id":100079901,"comment_content":"&#47;&#47; 每当 searchKey 或者 data 变化的时候，重新计算最终结果<br>老师这个地方有问题吧，一般我们是通过关键字去拿接口的data数据，你这个demo data数据并不是通过keyword获取过来的，而是直接传入的一个data，是有问题的，应该通过状态提升，也就是<br>const filtered = useMemo(() =&gt; { return data.filter((item) =&gt; item.title.toLowerCase().includes(searchKey.toLowerCase()) ); }, [searchKey, data]);<br>这段代码应该在父组件中，拿到data数据之后再传进去","like_count":2,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521736,"discussion_content":"数据处理为什么要在父组件呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623388838,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1374957,"avatar":"https://static001.geekbang.org/account/avatar/00/14/fa/ed/0742b854.jpg","nickname":"Jun Ma","note":"","ucode":"0C5E2AB51E6A83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584467,"discussion_content":"我觉得他们在说两个东西。 \n一个是已知数据源，通过前端来做过滤；\n一个是拿到关键字，直接去后端请求；\n不知道我理解对没有。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660838145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2177627,"avatar":"https://static001.geekbang.org/account/avatar/00/21/3a/5b/e59f76a6.jpg","nickname":"婧子酱.","note":"","ucode":"B47F87EFA8F8F5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378702,"discussion_content":"这里貌似只是个样例吧 data来源既父组件props传入 也可以在当前组件获取到放到state里面","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623346171,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1282777,"avatar":"https://static001.geekbang.org/account/avatar/00/13/92/d9/84c1de45.jpg","nickname":"傻子来了快跑丶","note":"","ucode":"662624121A1DFA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2177627,"avatar":"https://static001.geekbang.org/account/avatar/00/21/3a/5b/e59f76a6.jpg","nickname":"婧子酱.","note":"","ucode":"B47F87EFA8F8F5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378728,"discussion_content":"是呢，最优的方式就是老师最后给出的那个例子，状态提升","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623375847,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":378702,"ip_address":""},"score":378728,"extra":""}]}]},{"had_liked":false,"id":348902,"user_name":"鲁滨逊","can_delete":false,"product_type":"c1","uid":1387826,"ip_address":"","ucode":"AD58F1115DF311","user_header":"https://static001.geekbang.org/account/avatar/00/15/2d/32/43595745.jpg","comment_is_top":false,"comment_ctime":1655529163,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655529163","product_id":100079901,"comment_content":"1. &#47;&#47; getQuery 函数用户获取 URL 的查询字符串  应该是  用于获取 URL 的查询字符串。<br>2. 受控组件的例子中， handleChange 的代码写在父组件中是不是更好 ？","like_count":0},{"had_liked":false,"id":328459,"user_name":"Light 胖虎","can_delete":false,"product_type":"c1","uid":2876591,"ip_address":"","ucode":"D5FCFE14172D31","user_header":"https://static001.geekbang.org/account/avatar/00/2b/e4/af/f8cf4bc2.jpg","comment_is_top":false,"comment_ctime":1640743729,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640743729","product_id":100079901,"comment_content":"const handleSearchChange = useCallback(evt =&gt; { const key = evt.target.value; &#47;&#47; 设置当前的查询关键状态 setSearchKey(key); &#47;&#47; 改变 URL 的查询参数 history.push(`&#47;movie-list?key=${key}`); })<br>这个方法放在了input的onChange事件上面，会不会只要输入值有变化页面就跳转出去了呢","like_count":0},{"had_liked":false,"id":321570,"user_name":"阿阳","can_delete":false,"product_type":"c1","uid":1165817,"ip_address":"","ucode":"20A35FB86B1C5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/c9/f9/39492855.jpg","comment_is_top":false,"comment_ctime":1636949529,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636949529","product_id":100079901,"comment_content":"对于这节课的内容，我最近一年多的项目实践，有深刻的体会。上一次迭代，因为定义了很多中间状态和冗余状态，也没有仔细思考哪些数据是必须的数据，哪些是非必须的数据，导致状态之间的同步非常复杂，而且非常容易出错。当时陷入了泥潭，无法自拔。这次重构项目，虽然用的是vue3重构的项目，但是react的开发思想，以及这节课讲授的经验，我重新在新的迭代开发中，去尝试使用，去思考逻辑背后的数据，一下子感觉到豁然开朗了，而且越做感觉越顺畅。<br>感谢老师！","like_count":0},{"had_liked":false,"id":317067,"user_name":"陈极客","can_delete":false,"product_type":"c1","uid":1393500,"ip_address":"","ucode":"F01811019654CE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI7ZuleMUiarkal8u7r2jiajt1kiaicCiaWxHlmOicI4NLcqWQC9iar9y46oXv0W2oNQanUUwwPJQdFzZVfQ/132","comment_is_top":false,"comment_ctime":1634655547,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634655547","product_id":100079901,"comment_content":"实战例子非常生动！学习到了","like_count":0},{"had_liked":false,"id":312220,"user_name":"李克勤","can_delete":false,"product_type":"c1","uid":2660079,"ip_address":"","ucode":"78917017E984FB","user_header":"","comment_is_top":false,"comment_ctime":1631689986,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631689986","product_id":100079901,"comment_content":"使用userSearchParams维护searchkey,并暴露给SearchBox吧","like_count":0},{"had_liked":false,"id":311997,"user_name":"张洪永","can_delete":false,"product_type":"c1","uid":2717457,"ip_address":"","ucode":"F144992D9CAD5C","user_header":"","comment_is_top":false,"comment_ctime":1631587164,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631587164","product_id":100079901,"comment_content":"const handleSearch = useCallback(evt =&gt; { setSearchKey(evt.target.value); setFiltered(data.filter(item =&gt; { return item.title.includes(evt.target.value))); })); }, [filtered])<br>filtered 没有被改变，handleSearch可以被认为没有改变，这里是否会有问题呢","like_count":0},{"had_liked":false,"id":311376,"user_name":"文小文","can_delete":false,"product_type":"c1","uid":2689886,"ip_address":"","ucode":"65C20A6A8D0459","user_header":"https://static001.geekbang.org/account/avatar/00/29/0b/5e/08c8465c.jpg","comment_is_top":false,"comment_ctime":1631193389,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631193389","product_id":100079901,"comment_content":"老师讲得太好了，浅显易懂！ 感谢老师的辛勤付出","like_count":0},{"had_liked":false,"id":301785,"user_name":"浩明啦","can_delete":false,"product_type":"c1","uid":1377422,"ip_address":"","ucode":"120ED8FC45B992","user_header":"https://static001.geekbang.org/account/avatar/00/15/04/8e/e75ecc5e.jpg","comment_is_top":false,"comment_ctime":1625881771,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1625881771","product_id":100079901,"comment_content":"老师想请教一下如果一个组件内部有多个 useState 的状态 譬如<br><br>第一种<br>const [list,setList] = useState([])<br>const [loading,setLoading] = useState(false)<br>const [error,setError] = useState(false)<br><br><br>第二种<br>const [state,setState] = useState({<br>    list:[],<br>    loading:false,<br>    error:false<br>})<br><br>以上哪两种会更加推荐呢？<br><br>在一些场景下<br><br>比如我在某个方法中执行了一些方法<br><br>使用第一种<br><br>useCallback(()=&gt;{<br>    setLoading(true)  <br>    fetch(&#39;http:xxx&#39;).then((res)=&gt;{<br>        setList(res)<br>        setLoading(false) <br>    }).catch(()=&gt;{<br>        setError(true) <br>    })<br>})<br><br><br>使用第二种<br>useCallback(()=&gt;{<br>    setState({...state,loading:true})  <br>    fetch(&#39;http:xxx&#39;).then((res)=&gt;{<br>        setState({...state,loading:false,list:res})  <br>    }).catch(()=&gt;{<br>        setState({...state,error:true})  <br>    })<br>})<br><br>可以看到第一种方法在  fetch(&#39;http:xxx&#39;) 完之后有两步操作，以为函数要运行两遍，如果采用第二种函数只需要执行一遍，是不是第二种的组织方式更好呢？","like_count":0,"discussions":[{"author":{"id":2003923,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/93/d3/97497cbe.jpg","nickname":"OriX","note":"","ucode":"EEC1CF06115CD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387656,"discussion_content":"多state且state互相影响的时候,可以使用useReducer 来代替,会更好些哦","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1628324798,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":299352,"user_name":"Juntíng","can_delete":false,"product_type":"c1","uid":1039290,"ip_address":"","ucode":"F6A3B528D6F3FD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/db/ba/304a9a4a.jpg","comment_is_top":false,"comment_ctime":1624591005,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1624591005","product_id":100079901,"comment_content":"SearchBox 本质上还是维护了一个 searchKey 的状态，只是通过提取让 useSearchParam 这个 hook 去维护了，SearchBox 组件不需要去关注了。","like_count":0,"discussions":[{"author":{"id":2377130,"avatar":"","nickname":"Geek_0330fe","note":"","ucode":"3324AF1AD2DC8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384390,"discussion_content":"正是我看到文章后想说的，状态实际上不是消失只会转移。但是按照老师修改后的思路，确实数据流更清晰了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626558100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1200447,"avatar":"https://static001.geekbang.org/account/avatar/00/12/51/3f/41c68054.jpg","nickname":"我要的飞翔","note":"","ucode":"41C51DBC8372BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381454,"discussion_content":"确实是，但是useSearchParam这个hook的state也只是通过监听url来改变，所以还是确保了唯一数据源，这个思路没错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625062214,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}