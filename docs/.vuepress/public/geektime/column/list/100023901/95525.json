{"id":95525,"title":"34 | Worker Thread模式：如何避免重复创建线程？","content":"<p>在<a href=\"https://time.geekbang.org/column/article/95098\">上一篇文章</a>中，我们介绍了一种最简单的分工模式——Thread-Per-Message模式，对应到现实世界，其实就是委托代办。这种分工模式如果用Java Thread实现，频繁地创建、销毁线程非常影响性能，同时无限制地创建线程还可能导致OOM，所以在Java领域使用场景就受限了。</p><p>要想有效避免线程的频繁创建、销毁以及OOM问题，就不得不提今天我们要细聊的，也是Java领域使用最多的Worker Thread模式。</p><h2>Worker Thread模式及其实现</h2><p>Worker Thread模式可以类比现实世界里车间的工作模式：车间里的工人，有活儿了，大家一起干，没活儿了就聊聊天等着。你可以参考下面的示意图来理解，Worker Thread模式中<strong>Worker Thread对应到现实世界里，其实指的就是车间里的工人</strong>。不过这里需要注意的是，车间里的工人数量往往是确定的。</p><p><img src=\"https://static001.geekbang.org/resource/image/9d/c3/9d0082376427a97644ad7219af6922c3.png?wh=1142*511\" alt=\"\"></p><center><span class=\"reference\">车间工作示意图</span></center><p>那在编程领域该如何模拟车间的这种工作模式呢？或者说如何去实现Worker Thread模式呢？通过上面的图，你很容易就能想到用阻塞队列做任务池，然后创建固定数量的线程消费阻塞队列中的任务。其实你仔细想会发现，这个方案就是Java语言提供的线程池。</p><!-- [[[read_end]]] --><p>线程池有很多优点，例如能够避免重复创建、销毁线程，同时能够限制创建线程的上限等等。学习完上一篇文章后你已经知道，用Java的Thread实现Thread-Per-Message模式难以应对高并发场景，原因就在于频繁创建、销毁Java线程的成本有点高，而且无限制地创建线程还可能导致应用OOM。线程池，则恰好能解决这些问题。</p><p>那我们还是以echo程序为例，看看如何用线程池来实现。</p><p>下面的示例代码是用线程池实现的echo服务端，相比于Thread-Per-Message模式的实现，改动非常少，仅仅是创建了一个最多线程数为500的线程池es，然后通过es.execute()方法将请求处理的任务提交给线程池处理。</p><pre><code>ExecutorService es = Executors\n  .newFixedThreadPool(500);\nfinal ServerSocketChannel ssc = \n  ServerSocketChannel.open().bind(\n    new InetSocketAddress(8080));\n//处理请求    \ntry {\n  while (true) {\n    // 接收请求\n    SocketChannel sc = ssc.accept();\n    // 将请求处理任务提交给线程池\n    es.execute(()-&gt;{\n      try {\n        // 读Socket\n        ByteBuffer rb = ByteBuffer\n          .allocateDirect(1024);\n        sc.read(rb);\n        //模拟处理请求\n        Thread.sleep(2000);\n        // 写Socket\n        ByteBuffer wb = \n          (ByteBuffer)rb.flip();\n        sc.write(wb);\n        // 关闭Socket\n        sc.close();\n      }catch(Exception e){\n        throw new UncheckedIOException(e);\n      }\n    });\n  }\n} finally {\n  ssc.close();\n  es.shutdown();\n}   \n</code></pre><h2>正确地创建线程池</h2><p>Java的线程池既能够避免无限制地<strong>创建线程</strong>导致OOM，也能避免无限制地<strong>接收任务</strong>导致OOM。只不过后者经常容易被我们忽略，例如在上面的实现中，就被我们忽略了。所以强烈建议你<strong>用创建有界的队列来接收任务</strong>。</p><p>当请求量大于有界队列的容量时，就需要合理地拒绝请求。如何合理地拒绝呢？这需要你结合具体的业务场景来制定，即便线程池默认的拒绝策略能够满足你的需求，也同样建议你<strong>在创建线程池时，清晰地指明拒绝策略</strong>。</p><p>同时，为了便于调试和诊断问题，我也强烈建议你<strong>在实际工作中给线程赋予一个业务相关的名字</strong>。</p><p>综合以上这三点建议，echo程序中创建线程可以使用下面的示例代码。</p><pre><code>ExecutorService es = new ThreadPoolExecutor(\n  50, 500,\n  60L, TimeUnit.SECONDS,\n  //注意要创建有界队列\n  new LinkedBlockingQueue&lt;Runnable&gt;(2000),\n  //建议根据业务需求实现ThreadFactory\n  r-&gt;{\n    return new Thread(r, &quot;echo-&quot;+ r.hashCode());\n  },\n  //建议根据业务需求实现RejectedExecutionHandler\n  new ThreadPoolExecutor.CallerRunsPolicy());\n</code></pre><h2>避免线程死锁</h2><p>使用线程池过程中，还要注意一种<strong>线程死锁</strong>的场景。如果提交到相同线程池的任务不是相互独立的，而是有依赖关系的，那么就有可能导致线程死锁。实际工作中，我就亲历过这种线程死锁的场景。具体现象是<strong>应用每运行一段时间偶尔就会处于无响应的状态，监控数据看上去一切都正常，但是实际上已经不能正常工作了</strong>。</p><p>这个出问题的应用，相关的逻辑精简之后，如下图所示，该应用将一个大型的计算任务分成两个阶段，第一个阶段的任务会等待第二阶段的子任务完成。在这个应用里，每一个阶段都使用了线程池，而且两个阶段使用的还是同一个线程池。</p><p><img src=\"https://static001.geekbang.org/resource/image/f8/b8/f807b0935133b315870d2d7db5477db8.png?wh=1142*496\" alt=\"\"></p><center><span class=\"reference\">应用业务逻辑示意图</span></center><p>我们可以用下面的示例代码来模拟该应用，如果你执行下面的这段代码，会发现它永远执行不到最后一行。执行过程中没有任何异常，但是应用已经停止响应了。</p><pre><code>//L1、L2阶段共用的线程池\nExecutorService es = Executors.\n  newFixedThreadPool(2);\n//L1阶段的闭锁    \nCountDownLatch l1=new CountDownLatch(2);\nfor (int i=0; i&lt;2; i++){\n  System.out.println(&quot;L1&quot;);\n  //执行L1阶段任务\n  es.execute(()-&gt;{\n    //L2阶段的闭锁 \n    CountDownLatch l2=new CountDownLatch(2);\n    //执行L2阶段子任务\n    for (int j=0; j&lt;2; j++){\n      es.execute(()-&gt;{\n        System.out.println(&quot;L2&quot;);\n        l2.countDown();\n      });\n    }\n    //等待L2阶段任务执行完\n    l2.await();\n    l1.countDown();\n  });\n}\n//等着L1阶段任务执行完\nl1.await();\nSystem.out.println(&quot;end&quot;);\n</code></pre><p>当应用出现类似问题时，首选的诊断方法是查看线程栈。下图是上面示例代码停止响应后的线程栈，你会发现线程池中的两个线程全部都阻塞在 <code>l2.await();</code> 这行代码上了，也就是说，线程池里所有的线程都在等待L2阶段的任务执行完，那L2阶段的子任务什么时候能够执行完呢？永远都没那一天了，为什么呢？因为线程池里的线程都阻塞了，没有空闲的线程执行L2阶段的任务了。</p><p><img src=\"https://static001.geekbang.org/resource/image/43/83/43c663eedd5b0b75b6c3022e26eb1583.png?wh=792*612\" alt=\"\"></p><p>原因找到了，那如何解决就简单了，最简单粗暴的办法就是将线程池的最大线程数调大，如果能够确定任务的数量不是非常多的话，这个办法也是可行的，否则这个办法就行不通了。其实<strong>这种问题通用的解决方案是为不同的任务创建不同的线程池</strong>。对于上面的这个应用，L1阶段的任务和L2阶段的任务如果各自都有自己的线程池，就不会出现这种问题了。</p><p>最后再次强调一下：<strong>提交到相同线程池中的任务一定是相互独立的，否则就一定要慎重</strong>。</p><h2>总结</h2><p>我们曾经说过，解决并发编程里的分工问题，最好的办法是和现实世界做对比。对比现实世界构建编程领域的模型，能够让模型更容易理解。上一篇我们介绍的Thread-Per-Message模式，类似于现实世界里的委托他人办理，而今天介绍的Worker Thread模式则类似于车间里工人的工作模式。如果你在设计阶段，发现对业务模型建模之后，模型非常类似于车间的工作模式，那基本上就能确定可以在实现阶段采用Worker Thread模式来实现。</p><p>Worker Thread模式和Thread-Per-Message模式的区别有哪些呢？从现实世界的角度看，你委托代办人做事，往往是和代办人直接沟通的；对应到编程领域，其实现也是主线程直接创建了一个子线程，主子线程之间是可以直接通信的。而车间工人的工作方式则是完全围绕任务展开的，一个具体的任务被哪个工人执行，预先是无法知道的；对应到编程领域，则是主线程提交任务到线程池，但主线程并不关心任务被哪个线程执行。</p><p>Worker Thread模式能避免线程频繁创建、销毁的问题，而且能够限制线程的最大数量。Java语言里可以直接使用线程池来实现Worker Thread模式，线程池是一个非常基础和优秀的工具类，甚至有些大厂的编码规范都不允许用new Thread()来创建线程的，必须使用线程池。</p><p>不过使用线程池还是需要格外谨慎的，除了今天重点讲到的如何正确创建线程池、如何避免线程死锁问题，还需要注意前面我们曾经提到的ThreadLocal内存泄露问题。同时对于提交到线程池的任务，还要做好异常处理，避免异常的任务从眼前溜走，从业务的角度看，有时没有发现异常的任务后果往往都很严重。</p><h2>课后思考</h2><p>小灰同学写了如下的代码，本义是异步地打印字符串“QQ”，请问他的实现是否有问题呢？</p><pre><code>ExecutorService pool = Executors\n  .newSingleThreadExecutor();\npool.submit(() -&gt; {\n  try {\n    String qq=pool.submit(()-&gt;&quot;QQ&quot;).get();\n    System.out.println(qq);\n  } catch (Exception e) {\n  }\n});\n</code></pre><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p><p></p>","comments":[{"had_liked":false,"id":95004,"user_name":"vector","can_delete":false,"product_type":"c1","uid":1107266,"ip_address":"","ucode":"F42E76E8966BBE","user_header":"https://static001.geekbang.org/account/avatar/00/10/e5/42/fbe890c0.jpg","comment_is_top":false,"comment_ctime":1557936808,"is_pvip":false,"replies":[{"id":"34033","content":"比喻很形象👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558004985,"ip_address":"","comment_id":95004,"utype":1}],"discussion_count":1,"race_medal":0,"score":"409579829928","product_id":100023901,"comment_content":"工厂里只有一个工人，他的工作就是同步的等待工厂里其他人给他提供东西，然而并没有其他人，他将等到天荒地老，海枯石烂~","like_count":95,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450295,"discussion_content":"比喻很形象👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558004985,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97210,"user_name":"曾轼麟","can_delete":false,"product_type":"c1","uid":1451391,"ip_address":"","ucode":"D418371AC11270","user_header":"https://static001.geekbang.org/account/avatar/00/16/25/7f/473d5a77.jpg","comment_is_top":false,"comment_ctime":1558611583,"is_pvip":false,"replies":[{"id":"34743","content":"👍👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558615958,"ip_address":"","comment_id":97210,"utype":1}],"discussion_count":2,"race_medal":0,"score":"272141551231","product_id":100023901,"comment_content":"EagerThreadPool 老师这个线程池可以避免死锁的情况，死锁的时候会自动撑大","like_count":63,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451179,"discussion_content":"👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558615958,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1101760,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cf/c0/8e4c1135.jpg","nickname":"ddup","note":"","ucode":"D8EC573DA46A10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584856,"discussion_content":"不对吧 EagerThreadPool 是考虑优先创建线程执行任务，达到最大线程数再把任务放进队列。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661161754,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97939,"user_name":"linqw","can_delete":false,"product_type":"c1","uid":1134138,"ip_address":"","ucode":"09DCFE98C54DD8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","comment_is_top":false,"comment_ctime":1558846933,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"96048127445","product_id":100023901,"comment_content":"newSingleThreadExecutor线程池只有单个线程，先将外部线程提交给线程池，外部线程等待内部线程执行完成，但由于线程池只有单线程，导致内部线程一直没有执行的机会，相当于内部线程需要线程池的资源，外部线程需要内部线程的结果，导致死锁。","like_count":22,"discussions":[{"author":{"id":2139604,"avatar":"","nickname":"成电帅才","note":"","ucode":"DDE757138F41D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363001,"discussion_content":"死锁首先得有锁吧，这里连锁都没有，怎么能叫死锁呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617089984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2139604,"avatar":"","nickname":"成电帅才","note":"","ucode":"DDE757138F41D2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370967,"discussion_content":"前几章死锁的定义：一组互相竞争资源的线程因互相等待，导致“永久”阻塞的现象","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1619598315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":363001,"ip_address":""},"score":370967,"extra":""}]}]},{"had_liked":false,"id":95679,"user_name":"zero","can_delete":false,"product_type":"c1","uid":1299615,"ip_address":"","ucode":"528DD5C8399AEC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKlwpFM3tkeG15YqyJTYWkfqkdmro9POq6SicYm57TaEFDOUZCXjoe0Z0Iz6UibGQqic3icJRsHdFzibtw/132","comment_is_top":false,"comment_ctime":1558141099,"is_pvip":true,"replies":[{"id":"34255","content":"不是递归，但会死锁","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558168430,"ip_address":"","comment_id":95679,"utype":1}],"discussion_count":1,"race_medal":0,"score":"61687683243","product_id":100023901,"comment_content":"感觉这程序会调用栈内存溢出，这段代码相当于无限的递归调用啊。不知道理解的对不对，请老师指点。","like_count":14,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450557,"discussion_content":"不是递归，但会死锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558168430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95566,"user_name":"木刻","can_delete":false,"product_type":"c1","uid":1157430,"ip_address":"","ucode":"0A3226FEE3983B","user_header":"https://static001.geekbang.org/account/avatar/00/11/a9/36/972f7abf.jpg","comment_is_top":false,"comment_ctime":1558084294,"is_pvip":false,"replies":[{"id":"34257","content":"好累😂","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558169014,"ip_address":"","comment_id":95566,"utype":1}],"discussion_count":1,"race_medal":0,"score":"40212789958","product_id":100023901,"comment_content":"希望老师能开一栏专门讲一讲Linux下多线程并发情况下程序性能的排查和调优。谢谢老师","like_count":9,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450519,"discussion_content":"好累😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558169014,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338627,"user_name":"Geek_42f729","can_delete":false,"product_type":"c1","uid":1600341,"ip_address":"","ucode":"76CFFF9DEDDF96","user_header":"https://static001.geekbang.org/account/avatar/00/18/6b/55/2b0f219b.jpg","comment_is_top":false,"comment_ctime":1647607295,"is_pvip":false,"replies":[{"id":"123920","content":"分析很到位","user_name":"作者回复","user_name_real":"编辑","uid":"1269969","ctime":1647911967,"ip_address":"","comment_id":338627,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27417411071","product_id":100023901,"comment_content":"看了一遍评论，有一部分同学回答了课后思考的结论，但是没有描述产生该结论的原因，我来描述一下吧，有不对的地方还请老师、同学们指出；<br><br>结论是：小灰写的代码会被一直阻塞；<br><br>原因是：<br><br>1. 通过Executors.newSingleThreadExecutor()创建的线程池默认是1个核心线程 + 无界工作队列；<br><br>2. 第一次submit时，会把池中唯一的一个核心线程给占用；<br><br>3. 第二次submit时，由于没有空闲的线程，并且工作队列也没满，所以线程池会把提交的任务添加到工作队列，然后等待空闲线程来执行该任务；<br><br>4. 在第二次submit时使用了.get()方法，这里会一直等到线程返回执行结果；<br><br>5. 由于两次submit是嵌套执行的，并且此时线程池中也没有空闲线程，所以第二次submit的任务永远不会被执行，.get()方法会就被永远阻塞，从而导致第一次submit的线程也被永远阻塞。","like_count":7,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557627,"discussion_content":"分析很到位","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647911967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95490,"user_name":"佑儿","can_delete":false,"product_type":"c1","uid":1226196,"ip_address":"","ucode":"0629888E7A5E16","user_header":"https://static001.geekbang.org/account/avatar/00/12/b5/d4/3bd5b77b.jpg","comment_is_top":false,"comment_ctime":1558063526,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"27327867302","product_id":100023901,"comment_content":"原始的workerThread模式包含三种角色：工人、传送带、产品，<br>传送带中维护一个productionsQueue以及最大的产品数量（为了防止产品无限积压）,<br>在传送带初始化时，创建了若干个worker（线程），worker不断从传送带取产品进行加工，<br>当传送带中无产品时，worker线程被挂起等待唤醒，当有新的产品加入到传送带中时，挂起的worker会被唤醒，取产品加工。<br>当上游线程Thread往传送带中加入产品时，如果productionsQueue到达最大产品数量时，Thread会被挂起。<br>当有worker线程取出产品后，会唤醒阻塞的线程Thread(当然这里也有可能唤醒worker)<br>线程池只是workerThread的一种实现，那么线程池中创建的Thread就是工人，线程池本身就是传送带，产品就是提交到线程池中的Runnable，<br>而在线程池中的阻塞队列就相当于productionsQueue，请问老师，我这样理解是否正确？<br><br> ","like_count":6,"discussions":[{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370968,"discussion_content":"工人是线程池重的线程、传送带是任务队列、产品是任务","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619598532,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95304,"user_name":"ack","can_delete":false,"product_type":"c1","uid":1440912,"ip_address":"","ucode":"69CA1233EEA8E2","user_header":"https://static001.geekbang.org/account/avatar/00/15/fc/90/c9df0459.jpg","comment_is_top":false,"comment_ctime":1558014165,"is_pvip":false,"replies":[{"id":"34152","content":"我觉得是死锁，活锁有释放再获取的过程","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558091520,"ip_address":"","comment_id":95304,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27327817941","product_id":100023901,"comment_content":"老师，请教个问题，线程死锁那个代码，是活锁吗，思考题我也认为是活锁","like_count":6,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450408,"discussion_content":"我觉得是死锁，活锁有释放再获取的过程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558091520,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148840,"user_name":"Mr_杨","can_delete":false,"product_type":"c1","uid":1008065,"ip_address":"","ucode":"AD31C2320DF6A2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/61/c1/9ad88d67.jpg","comment_is_top":false,"comment_ctime":1573093773,"is_pvip":false,"replies":[{"id":"57430","content":"无解，必须控制线程数量。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1573216494,"ip_address":"","comment_id":148840,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10163028365","product_id":100023901,"comment_content":"老师请教个问题，如果不同业务用不同线程池，保证不了线程数量，会带来并发线程过大，如何控制频繁上下文切换的问题","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473632,"discussion_content":"无解，必须控制线程数量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573216494,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":301299,"user_name":"王成","can_delete":false,"product_type":"c1","uid":1441460,"ip_address":"","ucode":"29765BBCD3B8B2","user_header":"https://static001.geekbang.org/account/avatar/00/15/fe/b4/6902ac00.jpg","comment_is_top":false,"comment_ctime":1625624569,"is_pvip":false,"replies":[{"id":"112071","content":"设置超时绝对是最佳实践，否则必然出事","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1630132298,"ip_address":"","comment_id":301299,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5920591865","product_id":100023901,"comment_content":"最近工作中遇到一个关于线程池的问题，莫名其妙的线程就不在执行<br>问题的原因是<br>每个线程都会去请求一次http，但是时间长了会出现阻塞现象（http工具类写的有点问题）<br>最终解决方案，除了优化工具类，还给每一个线程设置了超时时间","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522962,"discussion_content":"设置超时绝对是最佳实践，否则必然出事","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630132298,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284597,"user_name":"张申傲","can_delete":false,"product_type":"c1","uid":1182372,"ip_address":"","ucode":"22D46BC529BA8A","user_header":"https://static001.geekbang.org/account/avatar/00/12/0a/a4/828a431f.jpg","comment_is_top":false,"comment_ctime":1616380356,"is_pvip":true,"replies":[{"id":"103329","content":"一般人解决问题都是以现实世界模型为主的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1616499544,"ip_address":"","comment_id":284597,"utype":1}],"discussion_count":1,"race_medal":2,"score":"5911347652","product_id":100023901,"comment_content":"越来越发现，软件领域中的很多问题，都可以向现实世界寻求答案。","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517401,"discussion_content":"一般人解决问题都是以现实世界模型为主的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616499544,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159469,"user_name":"大大大熊myeh","can_delete":false,"product_type":"c1","uid":1139413,"ip_address":"","ucode":"4832C2E7CEB151","user_header":"https://static001.geekbang.org/account/avatar/00/11/62/d5/1f5c5ab6.jpg","comment_is_top":false,"comment_ctime":1575631043,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5870598339","product_id":100023901,"comment_content":"首先它是一个单线程的线程池，第一次submit的任务是获取“给pool线程池设置的第二个submit任务的返回值”，然后输出。然而因为是单线程池，永远也等不到第二个线程任务返回QQ。第一个线程任务依赖于第二个任务，导致死锁。呼应本章主题：线程池分工。","like_count":1},{"had_liked":false,"id":95685,"user_name":"扬～","can_delete":false,"product_type":"c1","uid":1208163,"ip_address":"","ucode":"6FA7D8FE188341","user_header":"https://static001.geekbang.org/account/avatar/00/12/6f/63/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1558143030,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5853110326","product_id":100023901,"comment_content":"可以出个线程池异常处理的方案吗","like_count":1},{"had_liked":false,"id":95335,"user_name":"佑儿","can_delete":false,"product_type":"c1","uid":1226196,"ip_address":"","ucode":"0629888E7A5E16","user_header":"https://static001.geekbang.org/account/avatar/00/12/b5/d4/3bd5b77b.jpg","comment_is_top":false,"comment_ctime":1558021126,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5852988422","product_id":100023901,"comment_content":"有问题，singlepool中只有一个线程池，future.get方法阻塞当前线程，导致打印qq的线程没有机会执行，会根据丢弃策略进行不同的操作。","like_count":1},{"had_liked":false,"id":95155,"user_name":"晓杰","can_delete":false,"product_type":"c1","uid":1441546,"ip_address":"","ucode":"1174C88EEBF8A6","user_header":"https://static001.geekbang.org/account/avatar/00/15/ff/0a/12faa44e.jpg","comment_is_top":false,"comment_ctime":1557975482,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5852942778","product_id":100023901,"comment_content":"线程池里面的最大线程数只有一个，无法做到异步","like_count":1},{"had_liked":false,"id":350374,"user_name":"码小呆","can_delete":false,"product_type":"c1","uid":2055809,"ip_address":"","ucode":"44532D6ABF9340","user_header":"https://static001.geekbang.org/account/avatar/00/1f/5e/81/82709d6e.jpg","comment_is_top":false,"comment_ctime":1656857314,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1656857314","product_id":100023901,"comment_content":"这段代码,感觉是对应了书中的 : 如果提交到相同线程池的任务不是相互独立的，而是有依赖关系的，那么就有可能导致线程死锁 这一段话.","like_count":0},{"had_liked":false,"id":289128,"user_name":"xzy","can_delete":false,"product_type":"c1","uid":1002095,"ip_address":"","ucode":"1A44368083A19E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/6f/e36b3908.jpg","comment_is_top":false,"comment_ctime":1618884019,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618884019","product_id":100023901,"comment_content":"这跟上面讲的死锁例子一样呀","like_count":0},{"had_liked":false,"id":284255,"user_name":"俺能学个啥","can_delete":false,"product_type":"c1","uid":1026742,"ip_address":"","ucode":"30740C5B58774C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/aa/b6/46a5bbf3.jpg","comment_is_top":false,"comment_ctime":1616142184,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616142184","product_id":100023901,"comment_content":"单线程池提交任务里面依然提交任务，这会导致里面的任务会放进阻塞队列，而只有一个线程会导致无法返回结果，外面的也会阻塞，里面的也会阻塞，就卡在那里。。","like_count":0},{"had_liked":false,"id":275932,"user_name":"喃寻","can_delete":false,"product_type":"c1","uid":1565085,"ip_address":"","ucode":"E31B3660726671","user_header":"https://static001.geekbang.org/account/avatar/00/17/e1/9d/3ec0adec.jpg","comment_is_top":false,"comment_ctime":1611719591,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1611719591","product_id":100023901,"comment_content":"这里会死锁，原因是submit方法是需要等待返回值的，而这里是单线程，所以里面的submit没有可以执行的线程，导致一直等待","like_count":0},{"had_liked":false,"id":268911,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1608431140,"is_pvip":false,"replies":[{"id":"97553","content":"������������","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1608465100,"ip_address":"","comment_id":268911,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1608431140","product_id":100023901,"comment_content":"本篇就是一个主题，java创建线程池，并特别注意<br>1、生产中拒绝使用Executors提供的初始化线程池的方法（因为使用无解队列）<br>2、生产环境应根据业务自定义拒绝策略","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512077,"discussion_content":"������������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608465100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1250907,"avatar":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","nickname":"Monday","note":"","ucode":"77B9BACC783598","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336058,"discussion_content":"老师，最近的留言好几个都是乱码？只有我看到乱码吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608465165,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239926,"user_name":"Arthur","can_delete":false,"product_type":"c1","uid":1222441,"ip_address":"","ucode":"FF96EEDEBF7E3C","user_header":"https://static001.geekbang.org/account/avatar/00/12/a7/29/977c3280.jpg","comment_is_top":false,"comment_ctime":1596695369,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596695369","product_id":100023901,"comment_content":"Executors .newSingleThreadExecutor() 创建的线程池只有一个线程，在实现上只有一个线程处理，跟异步的概念有差别，更恐怖是在线程池里有重复使用线程池执行任务，任务之间出现依赖，这样任务永远不会打印了。","like_count":0},{"had_liked":false,"id":234659,"user_name":"FH","can_delete":false,"product_type":"c1","uid":1179224,"ip_address":"","ucode":"E47F6765CF1EEE","user_header":"https://static001.geekbang.org/account/avatar/00/11/fe/58/2cddaca4.jpg","comment_is_top":false,"comment_ctime":1594743387,"is_pvip":false,"replies":[{"id":"87044","content":"不合理， 示例代码只是代码前段，说明用法而已。写完整的类，有很多缩进，代码很难在手机上很排版","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1595161015,"ip_address":"","comment_id":234659,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1594743387","product_id":100023901,"comment_content":"老师有个问题请教一下，线程池不应该是项目启动时加载或者懒加载模式吗，但是看示例代码都是调用业务代码时才去创建ExecutorService，这样合理吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501451,"discussion_content":"不合理， 示例代码只是代码前段，说明用法而已。写完整的类，有很多缩进，代码很难在手机上很排版","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595161015,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212007,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1588045497,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588045497","product_id":100023901,"comment_content":"单线程池线程池直接阻塞在get处，而再等待的任务永远在阻塞队列中放着。一个等结果，一个等线程。凉凉～","like_count":0},{"had_liked":false,"id":207463,"user_name":"听雨","can_delete":false,"product_type":"c1","uid":1254493,"ip_address":"","ucode":"252754F9FCFF0C","user_header":"https://static001.geekbang.org/account/avatar/00/13/24/5d/65e61dcb.jpg","comment_is_top":false,"comment_ctime":1587089397,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587089397","product_id":100023901,"comment_content":"老师，java的ThreadPoolExecutor里为什么把runState和WorkerCount两个字段包装到ctl一个变量里，分开两个它不香吗，还省得每次位运算才能获取到具体的runState和WorkerCount了","like_count":0},{"had_liked":false,"id":195759,"user_name":"Mr.wang","can_delete":false,"product_type":"c1","uid":1224805,"ip_address":"","ucode":"86F341A5316BBC","user_header":"https://static001.geekbang.org/account/avatar/00/12/b0/65/90387745.jpg","comment_is_top":false,"comment_ctime":1585215018,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1585215018","product_id":100023901,"comment_content":"创建一个单线程线程池，再运行任务的时候，主任务先获取线程，进入到任务里面后，也使用线程中的线程，但这里是单线程线程池，子任务获取不到线程，解决方案是加大线程池的线程数量。","like_count":0},{"had_liked":false,"id":182013,"user_name":"电光火石","can_delete":false,"product_type":"c1","uid":1013160,"ip_address":"","ucode":"3AD33BB4AA940F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/a8/dfe4cade.jpg","comment_is_top":false,"comment_ctime":1582692190,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582692190","product_id":100023901,"comment_content":"有个问题是关于forkjoinpool的死锁问题，假设我现在创建了4个线程的forkjoinpool，当我做任务拆分的，可能需要拆分8次，我理解A拆成2个子任务的时候，A也是一直在等待的，那这样会不会造成没有线程可用而形成死锁？还是说forkjoinpool 有很好的机制，A线程等待的时候，可以把线程空出来进行调度？谢谢了！","like_count":0},{"had_liked":false,"id":137739,"user_name":"Sharry","can_delete":false,"product_type":"c1","uid":1239293,"ip_address":"","ucode":"045DDB864659F6","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/fd/035f4c94.jpg","comment_is_top":false,"comment_ctime":1569833944,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569833944","product_id":100023901,"comment_content":"这个 WorkerThread 任务分配模式与生产者消费者很像啊<br>","like_count":0},{"had_liked":false,"id":137737,"user_name":"Sharry","can_delete":false,"product_type":"c1","uid":1239293,"ip_address":"","ucode":"045DDB864659F6","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/fd/035f4c94.jpg","comment_is_top":false,"comment_ctime":1569833753,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569833753","product_id":100023901,"comment_content":"只有一个线程, 会阻塞在 get 方法上, 直到永久","like_count":0},{"had_liked":false,"id":137418,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1569736620,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1569736620","product_id":100023901,"comment_content":"执行代码后查看线程栈会发现pool-1-thread-1一直处于waiting状态，因为外层的pool.submit等待内层pool.submit，内层又在等待外层submit的释放，简直是相互伤害到地老天荒啊。解决方案有两种：<br>1、最简单就是把线程个数从1个改到2个，然后代码运行就会成功打印出来QQ<br>2、真正要解决的还是需要针对有依赖关系的代码分配不同的线程池，只有真正无关的逻辑才能共用一个线程池。<br>第一次发现原来线程池之中还有deadlock的问题存在，其实说白了，线程池只是解决了频繁线程创建和销毁的代价问题，关于并发所带来的的问题，它是一点力都没出的，甚至某些时候还带来了一些问题(比如threadlocal)。","like_count":0},{"had_liked":false,"id":96618,"user_name":"好牙","can_delete":false,"product_type":"c1","uid":1117320,"ip_address":"","ucode":"F36A824C1AB19A","user_header":"","comment_is_top":false,"comment_ctime":1558480464,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558480464","product_id":100023901,"comment_content":"外部线程会由于内部线程submit.get而阻塞，占有single线程池的唯一worker资源，从而导致内部线程永远无法执行，形成活锁。解法可以拆分为两个线程池。","like_count":0},{"had_liked":false,"id":95284,"user_name":"峰","can_delete":false,"product_type":"c1","uid":1056019,"ip_address":"","ucode":"C53CB64E8E7D19","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg","comment_is_top":false,"comment_ctime":1558007235,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1558007235","product_id":100023901,"comment_content":"线程池只有一个线程，在任务执行的时候不能有再多的线程去处理提交的任务。","like_count":0},{"had_liked":false,"id":95113,"user_name":"周治慧","can_delete":false,"product_type":"c1","uid":1335293,"ip_address":"","ucode":"7D56C4E66BEE17","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKR3ibELhjgVicCNShZCBwvaDxibnzibggG4wUzVkS2mkDxUBZyIs87nDEdJ7PiahJBVoZcuhQ84RxAziag/132","comment_is_top":false,"comment_ctime":1557969892,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557969892","product_id":100023901,"comment_content":"两个线程共用一个线程池，当线程池中只有一个线程时，第二个线程是拿那不到线程的","like_count":0},{"had_liked":false,"id":95108,"user_name":"孙志强","can_delete":false,"product_type":"c1","uid":1325997,"ip_address":"","ucode":"9C070F1E4EC6FF","user_header":"https://static001.geekbang.org/account/avatar/00/14/3b/ad/31193b83.jpg","comment_is_top":false,"comment_ctime":1557969550,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1557969550","product_id":100023901,"comment_content":"死锁","like_count":0},{"had_liked":false,"id":95075,"user_name":"密码123456","can_delete":false,"product_type":"c1","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1557966244,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557966244","product_id":100023901,"comment_content":"跟今天的例子好像。一个线程池，却提交2个任务，其中一个线程等待另外一个线程","like_count":0},{"had_liked":false,"id":95074,"user_name":"智超","can_delete":false,"product_type":"c1","uid":1109769,"ip_address":"","ucode":"1C28A46FDD7FA2","user_header":"https://static001.geekbang.org/account/avatar/00/10/ef/09/209cb7ff.jpg","comment_is_top":false,"comment_ctime":1557966244,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557966244","product_id":100023901,"comment_content":"线程池只有一个线程就悲剧了","like_count":0},{"had_liked":false,"id":95060,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1557965323,"is_pvip":false,"replies":[{"id":"34153","content":"最多的情况是重启的时候","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558091625,"ip_address":"","comment_id":95060,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557965323","product_id":100023901,"comment_content":"老师，有个疑问，想问下线程池该什么时候销毁?","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450315,"discussion_content":"最多的情况是重启的时候","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558091625,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95055,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1557964700,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557964700","product_id":100023901,"comment_content":"A任务等待B任务返回QQ字符串，但是线程池只有一个线程，B任务没有多余的线程执行，导致线程池瘫痪","like_count":0},{"had_liked":false,"id":95012,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1557938313,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557938313","product_id":100023901,"comment_content":"为什么思考提会有两次submit方法，猜这里应该就是问题了。打卡！","like_count":0}]}