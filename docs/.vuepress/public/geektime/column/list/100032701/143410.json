{"id":143410,"title":"25 | 使用阻塞I/O和进程模型：最传统的方式","content":"<p>你好，我是盛延敏，这里是网络编程实战第25讲，欢迎回来。</p><p>上一讲中，我们讲到了C10K问题，并引入了解决C10K问题的各种解法。其中，最简单也是最有效的一种解决方法就是为每个连接创建一个独立的进程去服务。那么，到底如何为每个连接客户创建一个进程来服务呢？在这其中，又需要特别注意什么呢？今天我们就围绕这部分内容展开，期望经过今天的学习，你对父子进程、僵尸进程、使用进程处理连接等有一个比较直观的理解。</p><h2>父进程和子进程</h2><p>我们知道，进程是程序执行的最小单位，一个进程有完整的地址空间、程序计数器等，如果想创建一个新的进程，使用函数fork就可以。</p><pre><code>pid_t fork(void)\n返回：在子进程中为0，在父进程中为子进程ID，若出错则为-1\n</code></pre><p>如果你是第一次使用这个函数，你会觉得难以理解的地方在于，虽然我们的程序调用fork一次，它却在父、子进程里各返回一次。在调用该函数的进程（即为父进程）中返回的是新派生的进程ID号，在子进程中返回的值为0。想要知道当前执行的进程到底是父进程，还是子进程，只能通过返回值来进行判断。</p><p>fork函数实现的时候，实际上会把当前父进程的所有相关值都克隆一份，包括地址空间、打开的文件描述符、程序计数器等，就连执行代码也会拷贝一份，新派生的进程的表现行为和父进程近乎一样，就好像是派生进程调用过fork函数一样。为了区别两个不同的进程，实现者可以通过改变fork函数的栈空间值来判断，对应到程序中就是返回值的不同。</p><!-- [[[read_end]]] --><p>这样就形成了编程范式：</p><pre><code>if(fork() == 0){\n  do_child_process(); //子进程执行代码\n}else{\n  do_parent_process();  //父进程执行代码\n}\n</code></pre><p>当一个子进程退出时，系统内核还保留了该进程的若干信息，比如退出状态。这样的进程如果不回收，就会变成僵尸进程。在Linux下，这样的“僵尸”进程会被挂到进程号为1的init进程上。所以，由父进程派生出来的子进程，也必须由父进程负责回收，否则子进程就会变成僵尸进程。僵尸进程会占用不必要的内存空间，如果量多到了一定数量级，就会耗尽我们的系统资源。</p><p>有两种方式可以在子进程退出后回收资源，分别是调用wait和waitpid函数。</p><pre><code>pid_t wait(int *statloc);\npid_t waitpid(pid_t pid, int *statloc, int options);\n</code></pre><p>函数wait和waitpid都可以返回两个值，一个是函数返回值，表示已终止子进程的进程ID号，另一个则是通过statloc指针返回子进程终止的实际状态。这个状态可能的值为正常终止、被信号杀死、作业控制停止等。</p><p>如果没有已终止的子进程，而是有一个或多个子进程在正常运行，那么wait将阻塞，直到第一个子进程终止。</p><p>waitpid可以认为是wait函数的升级版，它的参数更多，提供的控制权也更多。pid参数允许我们指定任意想等待终止的进程ID，值-1表示等待第一个终止的子进程。options参数给了我们更多的控制选项。</p><p>处理子进程退出的方式一般是注册一个信号处理函数，捕捉信号SIGCHLD信号，然后再在信号处理函数里调用waitpid函数来完成子进程资源的回收。SIGCHLD是子进程退出或者中断时由内核向父进程发出的信号，默认这个信号是忽略的。所以，如果想在子进程退出时能回收它，需要像下面一样，注册一个SIGCHLD函数。</p><pre><code>signal(SIGCHLD, sigchld_handler);　　\n</code></pre><h2>阻塞I/O的进程模型</h2><p>为了说明使用阻塞I/O和进程模型，我们假设有两个客户端，服务器初始监听在套接字lisnted_fd上。当第一个客户端发起连接请求，连接建立后产生出连接套接字，此时，父进程派生出一个子进程，在子进程中，使用连接套接字和客户端通信，因此子进程不需要关心监听套接字，只需要关心连接套接字；父进程则相反，将客户服务交给子进程来处理，因此父进程不需要关心连接套接字，只需要关心监听套接字。</p><p>这张图描述了从连接请求到连接建立，父进程派生子进程为客户服务。</p><p><img src=\"https://static001.geekbang.org/resource/image/6c/a3/6cf70cf7f651273b38aac61cb61a88a3.png?wh=1398*598\" alt=\"\"><br>\n假设父进程之后又接收了新的连接请求，从accept调用返回新的已连接套接字，父进程又派生出另一个子进程，这个子进程用第二个已连接套接字为客户端服务。</p><p>这张图同样描述了这个过程。</p><p><img src=\"https://static001.geekbang.org/resource/image/4f/08/4fb66c841fbca96f8b27c13c61a29608.png?wh=1366*718\" alt=\"\"><br>\n现在，服务器端的父进程继续监听在套接字上，等待新的客户连接到来；两个子进程分别使用两个不同的连接套接字为两个客户服务。</p><h2>程序讲解</h2><p>我们将前面的内容串联起来，就是下面完整的一个基于进程模型的服务器端程序。</p><pre><code>#include &quot;lib/common.h&quot;\n\n#define MAX_LINE 4096\n\nchar rot13_char(char c) {\n    if ((c &gt;= 'a' &amp;&amp; c &lt;= 'm') || (c &gt;= 'A' &amp;&amp; c &lt;= 'M'))\n        return c + 13;\n    else if ((c &gt;= 'n' &amp;&amp; c &lt;= 'z') || (c &gt;= 'N' &amp;&amp; c &lt;= 'Z'))\n        return c - 13;\n    else\n        return c;\n}\n\nvoid child_run(int fd) {\n    char outbuf[MAX_LINE + 1];\n    size_t outbuf_used = 0;\n    ssize_t result;\n\n    while (1) {\n        char ch;\n        result = recv(fd, &amp;ch, 1, 0);\n        if (result == 0) {\n            break;\n        } else if (result == -1) {\n            perror(&quot;read&quot;);\n            break;\n        }\n\n        if (outbuf_used &lt; sizeof(outbuf)) {\n            outbuf[outbuf_used++] = rot13_char(ch);\n        }\n\n        if (ch == '\\n') {\n            send(fd, outbuf, outbuf_used, 0);\n            outbuf_used = 0;\n            continue;\n        }\n    }\n}\n\nvoid sigchld_handler(int sig) {\n    while (waitpid(-1, 0, WNOHANG) &gt; 0);\n    return;\n}\n\nint main(int c, char **v) {\n    int listener_fd = tcp_server_listen(SERV_PORT);\n    signal(SIGCHLD, sigchld_handler);\n    while (1) {\n        struct sockaddr_storage ss;\n        socklen_t slen = sizeof(ss);\n        int fd = accept(listener_fd, (struct sockaddr *) &amp;ss, &amp;slen);\n        if (fd &lt; 0) {\n            error(1, errno, &quot;accept failed&quot;);\n            exit(1);\n        }\n\n        if (fork() == 0) {\n            close(listener_fd);\n            child_run(fd);\n            exit(0);\n        } else {\n            close(fd);\n        }\n    }\n\n    return 0;\n}\n</code></pre><p>程序的48行注册了一个信号处理函数，用来回收子进程资源。函数sigchld_handler，在一个循环体内调用了waitpid函数，以便回收所有已终止的子进程。这里选项WNOHANG用来告诉内核，即使还有未终止的子进程也不要阻塞在waitpid上。注意这里不可以使用wait，因为wait函数在有未终止子进程的情况下，没有办法不阻塞。</p><p>程序的58-62行，通过判断fork的返回值为0，进入子进程处理逻辑。按照前面的讲述，子进程不需要关心监听套接字，故而在这里关闭掉监听套接字listen_fd，之后调用child_run函数使用已连接套接字fd来进行数据读写。第63行，进入的是父进程处理逻辑，父进程不需要关心连接套接字，所以在这里关闭连接套接字。</p><p>还记得<a href=\"https://time.geekbang.org/column/article/126126\">第11讲</a>中讲到的close函数吗？我们知道，从父进程派生出的子进程，同时也会复制一份描述字，也就是说，连接套接字和监听套接字的引用计数都会被加1，而调用close函数则会对引用计数进行减1操作，这样在套接字引用计数到0时，才可以将套接字资源回收。所以，这里的close函数非常重要，缺少了它们，就会引起服务器端资源的泄露。</p><p>child_run函数中，通过一个while循环来不断和客户端进行交互，依次读出字符之后，进行了简单的转码，如果读到回车符，则将转码之后的结果通过连接套接字发送出去。这样的回显方式，显得比较有“交互感”。</p><h2>实验</h2><p>我们启动该服务器，监听在对应的端口43211上。</p><pre><code>./fork01\n</code></pre><p>再启动两个telnet客户端，连接到43211端口，每次通过标准输入和服务器端传输一些数据，我们看到，服务器和客户端的交互正常。</p><pre><code>$telnet 127.0.0.1 43211\nTrying 127.0.0.1...\nConnected to localhost.\nEscape character is '^]'.\nafasfa\nnsnfsn\n]\ntelnet&gt; quit\nConnection closed.\n</code></pre><pre><code>$telnet 127.0.0.1 43211\nTrying 127.0.0.1...\nConnected to localhost.\nEscape character is '^]'.\nagasgasg\nntnftnft\n]\ntelnet&gt; quit\nConnection closed.\n</code></pre><p>客户端退出，服务器端也在正常工作，此时如果再通过telnet建立新的连接，客户端和服务器端的数据传输也会正常进行。</p><p>至此，我们构建了一个完整的服务器端程序，可以并发处理多个不同的客户连接，互不干扰。</p><h2>总结</h2><p>使用阻塞I/O和进程模型，为每一个连接创建一个独立的子进程来进行服务，是一个非常简单有效的实现方式，这种方式可能很难满足高性能程序的需求，但好处在于实现简单。在实现这样的程序时，我们需要注意两点：</p><ul>\n<li>要注意对套接字的关闭梳理；</li>\n<li>要注意对子进程进行回收，避免产生不必要的僵尸进程。</li>\n</ul><h2>思考题</h2><p>给你出两道思考题：</p><p>第一道，你可以查查资料，看看有没有比较著名的程序是使用这样的模式来构建的？</p><p>第二道，程序中处理SIGCHLD信号时，使用了一个循环来回收处理终止的子进程，为什么要这么做呢？如果不使用循环会有什么后果？</p><p>欢迎你在评论区写下你的思考，我会和你一起交流，也欢迎把这篇文章分享给你的朋友或者同事，一起交流一下。</p>","neighbors":{"left":{"article_title":"24 | C10K问题：高并发模型设计","id":143388},"right":{"article_title":"26 | 使用阻塞I/O和线程模型：换一种轻量的方式","id":145464}},"comments":[{"had_liked":false,"id":139706,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1570709098,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"156189531754","product_id":100032701,"comment_content":"读书少的人只能直接回答第二问 第一问回答不了哈哈哈<br>是因为如果有多个子进程同时结束的话内核只会产生一次SIGCHLD信号至少信号处理函数只会唤醒一次,如果不循环就无法取得所有已终止的子进程数据","like_count":37},{"had_liked":false,"id":149351,"user_name":"rong","can_delete":false,"product_type":"c1","uid":1128740,"ip_address":"","ucode":"637A27C532D817","user_header":"https://static001.geekbang.org/account/avatar/00/11/39/24/ab14f6cf.jpg","comment_is_top":false,"comment_ctime":1573199744,"is_pvip":false,"replies":[{"id":"57497","content":"在Linux里面，线程其实就是轻量级进程(light-weighted process)，它们都使用同样的task_struct结构，无论用户进程(process), 用户线程(thread)，就只是在task_struct的填法不一样而已。<br><br>所以，从内核角度来说，确实是线程(task_struct)是最小的，但是从用户角度来说，确实是进程是最小执行的单元，因为不可能没有进程，凭空产生出线程来。<br><br>线程和进程都有各自的PC计数器，实际上，无论是这里的fork，还是后面讲到的线程pthread_create，最终到内核中都是调用do_fork来产生task_struct结构的。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1573285197,"ip_address":"","comment_id":149351,"utype":1}],"discussion_count":3,"race_medal":0,"score":"74587643776","product_id":100032701,"comment_content":"文章开头部分，应该是线程是程序执行的最小单位吧。进程是cpu分配资源的最小单位。还有，每个线程有一个程序计数器，不是每个进程。","like_count":17,"discussions":[{"author":{"id":1316758,"avatar":"https://static001.geekbang.org/account/avatar/00/14/17/96/846fc11b.jpg","nickname":"Richard","note":"","ucode":"893F958B9DD161","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":204228,"discussion_content":"进程是资源分配的单位，线程是CPU调度的单位","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1584147593,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473827,"discussion_content":"在Linux里面，线程其实就是轻量级进程(light-weighted process)，它们都使用同样的task_struct结构，无论用户进程(process), 用户线程(thread)，就只是在task_struct的填法不一样而已。\n\n所以，从内核角度来说，确实是线程(task_struct)是最小的，但是从用户角度来说，确实是进程是最小执行的单元，因为不可能没有进程，凭空产生出线程来。\n\n线程和进程都有各自的PC计数器，实际上，无论是这里的fork，还是后面讲到的线程pthread_create，最终到内核中都是调用do_fork来产生task_struct结构的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573285197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2184325,"avatar":"https://static001.geekbang.org/account/avatar/00/21/54/85/ab5148ce.jpg","nickname":"duckman","note":"","ucode":"0184C26C4B6C1B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334894,"discussion_content":"太本本主义了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608021311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139879,"user_name":"Kepler","can_delete":false,"product_type":"c1","uid":1214303,"ip_address":"","ucode":"0C9CA3DB8B3CF0","user_header":"https://static001.geekbang.org/account/avatar/00/12/87/5f/6bf8b74a.jpg","comment_is_top":false,"comment_ctime":1570759776,"is_pvip":true,"replies":[{"id":"55070","content":"我知道有apache服务器，其他的大家可以补充。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1571450948,"ip_address":"","comment_id":139879,"utype":1}],"discussion_count":3,"race_medal":0,"score":"48815400032","product_id":100032701,"comment_content":"这种古老的多进程方式来处理io应该是apache服务器了吧，新型的redis, nginx都是事件驱动epoll来实现的；<br>采用while循环是为了回收所有已退出子进程的状态。<br>","like_count":11,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470154,"discussion_content":"我知道有apache服务器，其他的大家可以补充。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571450948,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2184325,"avatar":"https://static001.geekbang.org/account/avatar/00/21/54/85/ab5148ce.jpg","nickname":"duckman","note":"","ucode":"0184C26C4B6C1B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338056,"discussion_content":"很久之前的apache + cgi的形式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609162684,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1252980,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1e/74/636ea0f3.jpg","nickname":"你好","note":"","ucode":"0B5E024BA58560","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":258048,"discussion_content":"nginx 也使用了多个进程，因为一个进程挂掉后不会影响其他进程执行，但是线程挂掉后整个进程就崩了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588642667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138273,"user_name":"刘丹","can_delete":false,"product_type":"c1","uid":1081922,"ip_address":"","ucode":"66594D1C957E15","user_header":"https://static001.geekbang.org/account/avatar/00/10/82/42/8b04d489.jpg","comment_is_top":false,"comment_ctime":1570147699,"is_pvip":false,"replies":[{"id":"54296","content":"是我疏忽了，不过系统内核确实可以回收，最好还是自己close一下。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1570970181,"ip_address":"","comment_id":138273,"utype":1}],"discussion_count":1,"race_medal":0,"score":"48814787955","product_id":100032701,"comment_content":"请问主进程结束的时候没有关闭listener_fd，子进程结束的时候没有关闭fd，是让操作系统在关闭进程时自动回收资源吗？","like_count":11,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469462,"discussion_content":"是我疏忽了，不过系统内核确实可以回收，最好还是自己close一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570970181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159431,"user_name":"Geek_sky","can_delete":false,"product_type":"c1","uid":1619199,"ip_address":"","ucode":"7F85BEB76F34A9","user_header":"https://static001.geekbang.org/account/avatar/00/18/b4/ff/125e0787.jpg","comment_is_top":false,"comment_ctime":1575621983,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"44525294943","product_id":100032701,"comment_content":"一个发出而没有被接收的信号叫做待处理信号（pending signal）。在任何时刻，一种类型至多只会有一个待处理信号。如果一个进程有一个类型为k的待处理信号，那么任何接下来发送到这个进程的类型为k的信号都不会排队等待；它们只是被简单地丢弃。一个进程可以有选择性地阻塞接收某种信号。当一种信号被阻塞时，它仍可以被发送，但是产生的待处理信号不会被接收，直到进程取消对这种信号的阻塞。<br>一个待处理信号最多只能被接收一次。内核为每个进程在pending位向量中维护着待处理信号的集合，而在blocked位向量中维护着被阻塞的信号集合。只要传送了一个类型为k的信号，内核就会设置pending中的第k位，而只要接收了一个类型为k的信号，内核就会清除pending中的第k位。——深入理解计算机系统","like_count":10},{"had_liked":false,"id":139712,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1570710203,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18750579387","product_id":100032701,"comment_content":"上面说错了 信号会产生多次 信号处理函数只会调用一次","like_count":5},{"had_liked":false,"id":138927,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1570509413,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14455411301","product_id":100032701,"comment_content":"1. 按老师说的去搜了一下，也看到评论区其他同学的留言，发现redis的bgsave使用了fork创建子进程来保存数据。<br><br>2.  不使用while循环 在子进程退出时，会错过在子进程的资源回收叭","like_count":3},{"had_liked":false,"id":154881,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1574586788,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10164521380","product_id":100032701,"comment_content":"我理解的进程和线程<br>进程：OS的最小执行单位<br>线程：OS的最小调度单位<br>线程又称轻量级进程，他们的本质都是一段代码指令，被放到内存中等待执行，不过区别在于，进程间完全是隔离的互不影响，但是一个进程内的线程间是共享内存空间的，当然线程也有自己私有的一下资源，比如栈空间和PC寄存器等。<br><br>阻塞IO+多进程的实现已知有apache服务器","like_count":2},{"had_liked":false,"id":239127,"user_name":"Simple life","can_delete":false,"product_type":"c1","uid":1571460,"ip_address":"","ucode":"1902D7F72FB43F","user_header":"https://static001.geekbang.org/account/avatar/00/17/fa/84/f01d203a.jpg","comment_is_top":false,"comment_ctime":1596442325,"is_pvip":false,"replies":[{"id":"89388","content":"利用了cpu多核的能力。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1597636307,"ip_address":"","comment_id":239127,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5891409621","product_id":100032701,"comment_content":"这种阻塞进程模型与单进程accept+处理有什么区别？仅仅为了环境隔离?效率上并没有带来提升，还增加了上下文切换的操作，感觉有点得不偿失","like_count":1,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502991,"discussion_content":"利用了cpu多核的能力。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597636307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138850,"user_name":"Hale","can_delete":false,"product_type":"c1","uid":1129731,"ip_address":"","ucode":"1925955343FE94","user_header":"https://static001.geekbang.org/account/avatar/00/11/3d/03/b2d9a084.jpg","comment_is_top":false,"comment_ctime":1570492629,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"5865459925","product_id":100032701,"comment_content":"Nginx采用了进城池的模式来处理连接。使用循环是为了回收所有的子进程资源，一直到退出，否则接收完一个就直接退出了。","like_count":1,"discussions":[{"author":{"id":1306092,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ61zTDmLk7IhLJn6seBPOwsVaKIWUWaxk5YmsdYBZUOYMQCsyl9iaQVSg9U5qJVLLOCFUoLUuYnRA/132","nickname":"fjpcode","note":"","ucode":"C32C5E3ECB9A90","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72933,"discussion_content":"别误导呀，nginx不是采用基于事件的epoll模型来处理网络IO的吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575543865,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138350,"user_name":"张立华","can_delete":false,"product_type":"c1","uid":1231713,"ip_address":"","ucode":"173B938DD9478A","user_header":"https://static001.geekbang.org/account/avatar/00/12/cb/61/b62d8a3b.jpg","comment_is_top":false,"comment_ctime":1570176109,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5865143405","product_id":100032701,"comment_content":"避免僵尸进程，两种方法：1 忽略SIGCHLD， 2 调用wait或waitpid<br><br>应该说 忽略SIGCHLD，最省事吧","like_count":1,"discussions":[{"author":{"id":2123892,"avatar":"https://static001.geekbang.org/account/avatar/00/20/68/74/aea478ba.jpg","nickname":"我是管小亮","note":"","ucode":"A1C624CF9E1CA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299522,"discussion_content":"如何消除僵尸进程\n\n- 外部消灭：kill发送SIGTERM或者SIGKILL信号消灭产生僵尸进程的进程，它产生的僵死进程就变成了孤儿进程，这些孤儿进程会被init进程接管，init 进程会 wait()这些孤儿进程，释放它们占用的系统进程表中的资源。\n\n- 内部解决：子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。// fork 两次，原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597721689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1306092,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ61zTDmLk7IhLJn6seBPOwsVaKIWUWaxk5YmsdYBZUOYMQCsyl9iaQVSg9U5qJVLLOCFUoLUuYnRA/132","nickname":"fjpcode","note":"","ucode":"C32C5E3ECB9A90","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72941,"discussion_content":"在不使用wait/waitpid的情况下，直接忽略SIGCHLD，终止进程的资源谁来回收？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575544171,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344677,"user_name":"菜鸡","can_delete":false,"product_type":"c1","uid":1683117,"ip_address":"","ucode":"A3102C3ECCA332","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLmWgscKlnjXiaBugNJ2ozMmZibAEKichZv7OfGwQX9voDicVy2qnKtlm5kWQAKZ414vFohR8FV5N9ZhA/132","comment_is_top":false,"comment_ctime":1651720602,"is_pvip":false,"replies":[{"id":"126191","content":"你可以不放过这个问题，仔细研究一下，评论区等你......","user_name":"作者回复","user_name_real":"编辑","uid":"1618647","ctime":1652614459,"ip_address":"","comment_id":344677,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1651720602","product_id":100032701,"comment_content":"这个代码我运行了一下，当有一个客户端关闭时，服务端会出现accept failed: Interrupted system call (4)，然后其它客户端就无法再进行交互了，直到被强制关闭","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572132,"discussion_content":"你可以不放过这个问题，仔细研究一下，评论区等你......","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652614459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311263,"user_name":"Geek_842f07","can_delete":false,"product_type":"c1","uid":2698987,"ip_address":"","ucode":"ED772AF755FE7E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/WP4Ge8ABcINFkccKaNYKibicFnI0JAoojBBAUGrichNeRAgzm5RGbHG7GqYrFX3ELEzenuEbicQHJy2HZ72RxSOuMA/132","comment_is_top":false,"comment_ctime":1631149117,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631149117","product_id":100032701,"comment_content":"如果在信号处理程序执行期间有其他两个SIGCHID信号来到，则信号处理程序只会再执行一次，少处理了一次","like_count":0},{"had_liked":false,"id":246340,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1599285778,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599285778","product_id":100032701,"comment_content":"第一题，redis和nginx底层都是基于epoll实现的。当然了，像nodejs 也是livevent实现的，底层也是epoll。<br>第二题，使用循环的目的是，第一次父进程创建的子进程。后面子进程还会创建子进程。需要回收全部子进程。<br>","like_count":0},{"had_liked":false,"id":187497,"user_name":"Richard","can_delete":false,"product_type":"c1","uid":1316758,"ip_address":"","ucode":"893F958B9DD161","user_header":"https://static001.geekbang.org/account/avatar/00/14/17/96/846fc11b.jpg","comment_is_top":false,"comment_ctime":1584147503,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584147503","product_id":100032701,"comment_content":"1. oracle的专用模式就是这样实现的，一个listener进程进行监听，来一个session就创建一个前台进程，每个进程有自己的pga。<br>2. 很多人都已经回答了，当有多个子进程退出时，需要考虑处理多个信号的情况。<br>3. 这是unp书里的一个例子，建议大家仔细阅读一下","like_count":0},{"had_liked":false,"id":181396,"user_name":"supermouse","can_delete":false,"product_type":"c1","uid":1321860,"ip_address":"","ucode":"88072D5F881827","user_header":"https://static001.geekbang.org/account/avatar/00/14/2b/84/07f0c0d6.jpg","comment_is_top":false,"comment_ctime":1582534853,"is_pvip":false,"replies":[{"id":"71038","content":"因为我需要对字符串进行解析，这里只是为了判断一下回车符的出现，你完全可以改为先读字节流再解析。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1583052863,"ip_address":"","comment_id":181396,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1582534853","product_id":100032701,"comment_content":"请问老师，文稿中的代码child_run函数里面的recv是一次只接收一个字符吗？为什么不一次接收一个字符串呢？","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484989,"discussion_content":"因为我需要对字符串进行解析，这里只是为了判断一下回车符的出现，你完全可以改为先读字节流再解析。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583052863,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138401,"user_name":"锦","can_delete":false,"product_type":"c1","uid":1468298,"ip_address":"","ucode":"CB0EB4B68C468B","user_header":"https://static001.geekbang.org/account/avatar/00/16/67/8a/babd74dc.jpg","comment_is_top":false,"comment_ctime":1570197907,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1570197907","product_id":100032701,"comment_content":"我知道的使用多进程模型有Nginx,Redis，不过Redis是用Reactor事件驱动模型来实现的","like_count":0,"discussions":[{"author":{"id":1306092,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ61zTDmLk7IhLJn6seBPOwsVaKIWUWaxk5YmsdYBZUOYMQCsyl9iaQVSg9U5qJVLLOCFUoLUuYnRA/132","nickname":"fjpcode","note":"","ucode":"C32C5E3ECB9A90","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72938,"discussion_content":"nginx的多进程，只是为了充分利用CPU多核特性，和老师说的一条连接对应一个处理进程不是一回事吧。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575544071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1074310,"avatar":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","nickname":"多襄丸","note":"","ucode":"1AA1497C5A293C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":25269,"discussion_content":"redis 是使用 父子进程 + 阻塞式IO 的模型吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570494638,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1184919,"avatar":"https://static001.geekbang.org/account/avatar/00/12/14/97/8a3aa317.jpg","nickname":"疾风知劲草","note":"","ucode":"B6E73CA240AA29","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1074310,"avatar":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","nickname":"多襄丸","note":"","ucode":"1AA1497C5A293C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55692,"discussion_content":"不是，redis是单线程程序加多路复用做数据存取，bgsave才会fork一个子进程来做备份","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574389534,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":25269,"ip_address":""},"score":55692,"extra":""}]}]},{"had_liked":false,"id":138338,"user_name":"搞怪者😘 😒 😏 👿","can_delete":false,"product_type":"c1","uid":1300678,"ip_address":"","ucode":"40DFF5D3E3B24C","user_header":"https://static001.geekbang.org/account/avatar/00/13/d8/c6/2b2a58cf.jpg","comment_is_top":false,"comment_ctime":1570171032,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1570171032","product_id":100032701,"comment_content":"Nginx和php–fpm就是这样的架构。<br><br>一个wait不足够阻止僵尸进程，如果n个子进程同时停止，那么会同时发出n个SIGCHILD信号给父进程，但是信号处理函数执行一次，因为信号一般是不排队的，多个SIGCHILD只会发送一次给父进程。所以需要用循环waitpid处理，获取所有终止子进程状态。","like_count":0,"discussions":[{"author":{"id":1101405,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ce/5d/5297717a.jpg","nickname":"初见","note":"","ucode":"06D7952CED37D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":59768,"discussion_content":"nginx 是 子进程 epoll_wait 接收事件后处理请求，父进程不负责 epoll_wait\nphp-fpm 是 子进程 appect 接收连接后处理请求，父进程不负责accept\n\n本文讲的是，父进程 accept 接受链接，将连接转交给子进程，子进程处理请求","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574693821,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1300678,"avatar":"https://static001.geekbang.org/account/avatar/00/13/d8/c6/2b2a58cf.jpg","nickname":"搞怪者😘 😒 😏 👿","note":"","ucode":"40DFF5D3E3B24C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1101405,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ce/5d/5297717a.jpg","nickname":"初见","note":"","ucode":"06D7952CED37D3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62016,"discussion_content":"是的，父进程在这里只是做管理😂😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574813645,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":59768,"ip_address":""},"score":62016,"extra":""}]},{"author":{"id":1101405,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ce/5d/5297717a.jpg","nickname":"初见","note":"","ucode":"06D7952CED37D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":59745,"discussion_content":"很遗憾，nginx 和 php-fpm 都不是这种架构","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574693610,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}