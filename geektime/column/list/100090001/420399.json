{"id":420399,"title":"06 | Shuffle管理：为什么Shuffle是性能瓶颈？","content":"<p>你好，我是吴磊。</p><p>在上一讲，我们拜访了斯巴克国际建筑集团总公司，结识了Spark调度系统的三巨头：DAGScheduler、TaskScheduler和SchedulerBackend。相信你已经感受到，调度系统组件众多且运作流程精密而又复杂。</p><p>任务调度的首要环节，是DAGScheduler以Shuffle为边界，把计算图DAG切割为多个执行阶段Stages。显然，<strong>Shuffle是这个环节的关键</strong>。那么，我们不禁要问：“Shuffle是什么？为什么任务执行需要Shuffle操作？Shuffle是怎样一个过程？”</p><p>今天这一讲，我们转而去“拜访”斯巴克国际建筑集团的分公司，用“工地搬砖的任务”来理解Shuffle及其工作原理。由于Shuffle的计算几乎需要消耗所有类型的硬件资源，比如CPU、内存、磁盘与网络，在绝大多数的Spark作业中，Shuffle往往是作业执行性能的瓶颈，因此，我们必须要掌握Shuffle的工作原理，从而为Shuffle环节的优化打下坚实基础。</p><h2>什么是Shuffle</h2><p>我们先不急着给Shuffle下正式的定义，为了帮你迅速地理解Shuffle的含义，从而达到事半功倍的效果，我们不妨先去拜访斯巴克集团的分公司，去看看“工地搬砖”是怎么一回事。</p><!-- [[[read_end]]] --><p>斯巴克集团的各家分公司分别驻扎在不同的建筑工地，每家分公司的人员配置和基础设施都大同小异：在人员方面，各家分公司都有建筑工人若干、以及负责管理这些工人的工头。在基础设施方面，每家分公司都有临时搭建、方便存取建材的临时仓库，这些仓库配备各式各样的建筑原材料，比如混凝土砖头、普通砖头、草坪砖头等等。</p><p>咱们参观、考察斯巴克建筑集团的目的，毕竟还是学习Spark，因此我们得把分公司的人与物和Spark的相关概念对应上，这样才能方便你快速理解Spark的诸多组件与核心原理。</p><p>分公司的人与物和Spark的相关概念是这样对应的：</p><p><img src=\"https://static001.geekbang.org/resource/image/aa/80/aab67642c34a4a959f4cde9dd750b280.jpg?wh=1920x919\" alt=\"图片\" title=\"集团分公司与Spark相关概念对应关系\"></p><p>基于图中不同概念的对应关系，接下来，我们来看“工地搬砖”的任务。斯巴克建筑集团的3家分公司，分别接到3个不同的建筑任务。第一家分公司的建筑项目是摩天大厦，第二家分公司被要求在工地上建造一座“萌宠乐园”，而第三家分公司收到的任务是打造露天公园。为了叙述方便，我们把三家分公司分别称作分公司1、分公司2和分公司3。</p><p>显然，不同建筑项目对于建材的选型要求是有区别的，摩天大厦的建造需要刚性强度更高的混凝土砖头，同理，露天公园的建设需要透水性好的草坪砖头，而萌宠乐园使用普通砖头即可。</p><p>可是，不同类型的砖头，分别散落在3家公司的临时仓库中。为了实现资源的高效利用，每个分公司的施工工人们，都需要从另外两家把项目特需的砖头搬运过来。对于这个过程，我们把它叫作“搬砖任务”。</p><p><img src=\"https://static001.geekbang.org/resource/image/4d/80/4d93f366247018896373c1d846fb4780.jpg?wh=1920x1403\" alt=\"图片\" title=\"工地搬砖的任务\"></p><p>有了“工地搬砖”的直观对比，我们现在就可以直接给Shuffle下一个正式的定义了。</p><p>Shuffle的本意是扑克的“洗牌”，在分布式计算场景中，它被引申为<strong>集群范围内跨节点、跨进程的数据分发</strong>。在工地搬砖的任务中，如果我们把不同类型的砖头看作是分布式数据集，那么不同类型的砖头在各个分公司之间搬运的过程，与分布式计算中的Shuffle可以说是异曲同工。</p><p>要完成工地搬砖的任务，每位工人都需要长途跋涉到另外两家分公司，然后从人家的临时仓库把所需的砖头搬运回来。分公司之间相隔甚远，仅靠工人们一块砖一块砖地搬运，显然不现实。因此，为了提升搬砖效率，每位工人还需要借助货运卡车来帮忙。不难发现，工地搬砖的任务需要消耗大量的人力物力，可以说是劳师动众。</p><p>Shuffle的过程也是类似，分布式数据集在集群内的分发，会引入大量的<strong>磁盘I/O</strong>与<strong>网络I/O</strong>。在DAG的计算链条中，Shuffle环节的执行性能是最差的。你可能会问：“既然Shuffle的性能这么差，为什么在计算的过程中非要引入Shuffle操作呢？免去Shuffle环节不行吗？”</p><p>其实，计算过程之所以需要Shuffle，往往是由计算逻辑、或者说业务逻辑决定的。</p><p>比如，对于搬砖任务来说，不同的建筑项目就是需要不同的建材，只有这样才能满足不同的施工要求。再比如，在Word Count的例子中，我们的“业务逻辑”是对单词做统计计数，那么对单词“Spark”来说，在做“加和”之前，我们就是得把原本分散在不同Executors中的“Spark”，拉取到某一个Executor，才能完成统计计数的操作。</p><p>结合过往的工作经验，我们发现在绝大多数的业务场景中，Shuffle操作都是必需的、无法避免的。既然我们躲不掉Shuffle，那么接下来，我们就一起去探索，看看Shuffle到底是怎样的一个计算过程。</p><h2>Shuffle工作原理</h2><p>为了方便你理解，我们还是用Word Count的例子来做说明。在这个示例中，引入Shuffle操作的是reduceByKey算子，也就是下面这行代码（完整代码请回顾<a href=\"https://time.geekbang.org/column/article/415209\">第1讲</a>）。</p><pre><code class=\"language-scala\">// 按照单词做分组计数\nval wordCounts: RDD[(String, Int)] = kvRDD.reduceByKey((x, y) =&gt; x + y)&nbsp;\n</code></pre><p>我们先来直观地回顾一下这一步的计算过程，然后再去分析其中涉及的Shuffle操作：</p><p><img src=\"https://static001.geekbang.org/resource/image/31/4d/3199582354a56f9e64bdf7b8a516b04d.jpg?wh=1920x1256\" alt=\"图片\" title=\"reduceByKey计算过程示意图\"></p><p>如上图所示，以Shuffle为边界，reduceByKey的计算被切割为两个执行阶段。约定俗成地，我们把Shuffle之前的Stage叫作<strong>Map阶段</strong>，而把Shuffle之后的Stage称作<strong>Reduce阶段</strong>。在<strong>Map阶段</strong>，每个Executors先把自己负责的数据分区做初步聚合（又叫Map端聚合、局部聚合）；在<strong>Shuffle环节</strong>，不同的单词被分发到不同节点的Executors中；最后的<strong>Reduce阶段</strong>，Executors以单词为Key做第二次聚合（又叫全局聚合），从而完成统计计数的任务。</p><p>不难发现，Map阶段与Reduce阶段的计算过程相对清晰明了，二者都是利用reduce运算完成局部聚合与全局聚合。在reduceByKey的计算过程中，Shuffle才是关键。</p><p>仔细观察上图你就会发现，与其说Shuffle是跨节点、跨进程的数据分发，不如说Shuffle是Map阶段与Reduce阶段之间的数据交换。那么问题来了，两个执行阶段之间，是如何实现数据交换的呢？</p><h3>Shuffle中间文件</h3><p>如果用一句来概括的话，那就是，<strong>Map阶段与Reduce阶段，通过生产与消费Shuffle中间文件的方式，来完成集群范围内的数据交换</strong>。换句话说，Map阶段生产Shuffle中间文件，Reduce阶段消费Shuffle中间文件，二者以中间文件为媒介，完成数据交换。</p><p>那么接下来的问题是，什么是<strong>Shuffle中间文件</strong>，它是怎么产生的，又是如何被消费的？</p><p>我把它的产生和消费过程总结在下图中了：</p><p><img src=\"https://static001.geekbang.org/resource/image/95/80/95479766b8acebdedd5c8a0f8bda0680.jpg?wh=1920x862\" alt=\"图片\" title=\"Shuffle中间文件示意图\"></p><p>在上一讲介绍调度系统的时候，我们说过DAGScheduler会为每一个Stage创建任务集合TaskSet，而每一个TaskSet都包含多个分布式任务（Task）。在Map执行阶段，每个Task（以下简称Map Task）都会<strong>生成包含data文件与index文件的Shuffle中间文件</strong>，如上图所示。也就是说，Shuffle文件的生成，<strong>是以Map Task为粒度的</strong>，Map阶段有多少个Map Task，就会生成多少份Shuffle中间文件。</p><p>再者，Shuffle中间文件是统称、泛指，它包含两类实体文件，一个是记录（Key，Value）键值对的data文件，另一个是记录键值对所属Reduce Task的index文件。换句话说，index文件标记了data文件中的哪些记录，应该由下游Reduce阶段中的哪些Task（简称Reduce Task）消费。在上图中，为了方便示意，我们把首字母是S、i、c的单词分别交给下游的3个Reduce Task去消费，显然，这里的数据交换规则是单词首字母。</p><p>在Spark中，Shuffle环节实际的数据交换规则要比这复杂得多。<strong>数据交换规则又叫分区规则</strong>，因为它定义了<strong>分布式数据集在Reduce阶段如何划分数据分区</strong>。假设Reduce阶段有N个Task，这N个Task对应着N个数据分区，那么在Map阶段，每条记录应该分发到哪个Reduce Task，是由下面的公式来决定的。</p><pre><code class=\"language-plain\">P = Hash(Record Key) % N\n</code></pre><p>对于任意一条数据记录，Spark先按照既定的哈希算法，计算记录主键的哈希值，然后把哈希值对N取模，计算得到的结果数字，就是这条记录在Reduce阶段的数据分区编号P。换句话说，这条记录在Shuffle的过程中，应该被分发到Reduce阶段的P号分区。</p><p>熟悉了分区规则与中间文件之后，接下来，我们再来说一说中间文件是怎么产生的。</p><h3>Shuffle Write</h3><p>我们刚刚说过，Shuffle中间文件，是以Map Task为粒度生成的，我们不妨使用下图中的Map Task以及与之对应的数据分区为例，来讲解中间文件的生成过程。数据分区的数据内容如图中绿色方框所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/92/ab/92781f6ff67224812d7aee1b7d6a63ab.jpg?wh=1920x618\" alt=\"图片\" title=\"Shuffle Write执行过程\"></p><p>在生成中间文件的过程中，Spark会借助一种类似于Map的数据结构，来计算、缓存并排序数据分区中的数据记录。这种Map结构的Key是（Reduce Task Partition ID，Record Key），而Value是原数据记录中的数据值，如图中的“内存数据结构”所示。</p><p>对于数据分区中的数据记录，Spark会根据我们前面提到的公式1逐条计算记录所属的目标分区ID，然后把主键（Reduce Task Partition ID，Record Key）和记录的数据值插入到Map数据结构中。当Map结构被灌满之后，Spark根据主键对Map中的数据记录做排序，然后把所有内容溢出到磁盘中的临时文件，如图中的步骤1所示。</p><p>随着Map结构被清空，Spark可以继续读取分区内容并继续向Map结构中插入数据，直到Map结构再次被灌满而再次溢出，如图中的步骤2所示。就这样，如此往复，直到数据分区中所有的数据记录都被处理完毕。</p><p>到此为止，磁盘上存有若干个溢出的临时文件，而内存的Map结构中留有部分数据，Spark使用归并排序算法对所有临时文件和Map结构剩余数据做合并，分别生成data文件、和与之对应的index文件，如图中步骤4所示。Shuffle阶段生成中间文件的过程，又叫Shuffle Write。</p><p>总结下来，Shuffle中间文件的生成过程，分为如下几个步骤：</p><p>1.对于数据分区中的数据记录，逐一计算其目标分区，然后填充内存数据结构；<br>\n2.当数据结构填满后，如果分区中还有未处理的数据记录，就对结构中的数据记录按（目标分区 ID，Key）排序，将所有数据溢出到临时文件，同时清空数据结构；<br>\n3.重复前 2 个步骤，直到分区中所有的数据记录都被处理为止；<br>\n4.对所有临时文件和内存数据结构中剩余的数据记录做归并排序，生成数据文件和索引文件。</p><p>到目前为止，我们熟悉了Spark在Map阶段生产Shuffle中间文件的过程，那么，在Reduce阶段，不同的Tasks又是如何基于这些中间文件，来定位属于自己的那部分数据，从而完成数据拉取呢？</p><h3>Shuffle Read</h3><p>首先，我们需要注意的是，对于每一个Map Task生成的中间文件，其中的目标分区数量是由Reduce阶段的<strong>任务数量</strong>（又叫<strong>并行度</strong>）决定的。在下面的示意图中，Reduce阶段的并行度是3，因此，Map Task的中间文件会包含3个目标分区的数据，而<strong>index文件，恰恰是用来标记目标分区所属数据记录的起始索引。</strong></p><p><img src=\"https://static001.geekbang.org/resource/image/22/d9/2283d917c3ab2262bbd91f35e0ce0dd9.jpg?wh=1920x828\" alt=\"图片\" title=\"Shuffle中间文件示意图\"></p><p>对于所有Map Task生成的中间文件，Reduce Task需要通过网络从不同节点的硬盘中下载并拉取属于自己的数据内容。不同的Reduce Task正是根据index文件中的起始索引来确定哪些数据内容是“属于自己的”。Reduce阶段不同于Reduce Task拉取数据的过程，往往也被叫做<strong>Shuffle Read</strong>。</p><p>好啦，到此为止，我们依次解答了本讲最初提到的几个问题：“什么是Shuffle？为什么需要Shuffle，以及Shuffle是如何工作的”。Shuffle是衔接不同执行阶段的关键环节，Shuffle的执行性能往往是Spark作业端到端执行效率的关键，因此，掌握Shuffle，是我们入门Spark的必经之路。希望今天的讲解，能帮你更好地认识Shuffle。</p><h2>重点回顾</h2><p>今天的内容比较多，我们一起来做个总结。</p><p>首先，我们给Shuffle下了一个明确的定义，在分布式计算场景中，<strong>Shuffle指的是集群范围内跨节点、跨进程的数据分发</strong>。</p><p>我们在最开始提到，Shuffle的计算会消耗所有类型的硬件资源。具体来说，Shuffle中的哈希与排序操作会大量消耗CPU，而Shuffle Write生成中间文件的过程，会消耗宝贵的内存资源与磁盘I/O，最后，Shuffle Read阶段的数据拉取会引入大量的网络I/O。不难发现，<strong>Shuffle是资源密集型计算</strong>，因此理解Shuffle对开发者来说至关重要。</p><p>紧接着，我们介绍了Shuffle中间文件。Shuffle中间文件是统称，它包含两类文件，一个是记录（Key，Value）键值对的data文件，另一个是记录键值对所属Reduce Task的index文件。计算图DAG中的Map阶段与Reduce阶段，正是通过中间文件来完成数据的交换。</p><p>接下来，我们详细讲解了Shuffle Write过程中生成中间文件的详细过程，归纳起来，这个过程分为4个步骤：</p><p>1.对于数据分区中的数据记录，逐一计算其目标分区，然后填充内存数据结构；<br>\n2.当数据结构填满后，如果分区中还有未处理的数据记录，就对结构中的数据记录按（目标分区 ID，Key）排序，将所有数据溢出到临时文件，同时清空数据结构；<br>\n3.重复前 2 个步骤，直到分区中所有的数据记录都被处理为止；<br>\n4.对所有临时文件和内存数据结构中剩余的数据记录做归并排序，生成数据文件和索引文件。</p><p>最后，在Reduce阶段，Reduce Task通过index文件来“定位”属于自己的数据内容，并通过网络从不同节点的data文件中下载属于自己的数据记录。</p><h2>每课一练</h2><p>这一讲就到这里了，我在这给你留个思考题：</p><p>在Shuffle的计算过程中，中间文件存储在参数spark.local.dir设置的文件目录中，这个参数的默认值是/tmp，你觉得这个参数该如何设置才更合理呢？</p><p>欢迎你在评论区分享你的答案，我在评论区等你。如果这一讲对你有所帮助，你也可以分享给自己的朋友，我们下一讲见。</p>","comments":[{"had_liked":false,"id":313109,"user_name":"Geek_2dfa9a","can_delete":false,"product_type":"c1","uid":1435535,"ip_address":"","ucode":"B5FE7971F5E773","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epGTSTvn7r4ibk1PuaUrSvvLdviaLcne50jbvvfiaxKkM5SLibeP6jibA2bCCQBqETibvIvcsOhAZlwS8kQ/132","comment_is_top":true,"comment_ctime":1632281609,"is_pvip":false,"replies":[{"id":"113471","content":"完美，满分💯！置顶🔝<br><br>老弟功底十分扎实～👍👍👍","user_name":"作者回复","user_name_real":"吴磊","uid":"1043100","ctime":1632358182,"ip_address":"","comment_id":313109,"utype":1}],"discussion_count":7,"race_medal":0,"score":"9.2233721587460997e+18","product_id":100090001,"comment_content":"官网配置文档 https:&#47;&#47;spark.apache.org&#47;docs&#47;3.1.2&#47;configuration.html<br>Directory to use for &quot;scratch&quot; space in Spark, including map output files and RDDs that get stored on disk. This should be on a fast, local disk in your system. It can also be a comma-separated list of multiple directories on different disks.<br>Note: This will be overridden by SPARK_LOCAL_DIRS (Standalone), MESOS_SANDBOX (Mesos) or LOCAL_DIRS (YARN) environment variables set by the cluster manager.<br>临时目录，用来存map output文件（shuffle产生）和save RDD到磁盘的时候会用到。应该配置成快速的本地磁盘。支持‘,’分隔的多个目录。<br>注意：这个配置会被SPARK_LOCAL_DIRS（Standalone部署），MESOS_SANDBOX（Mesos），LOCAL_DIRS (YARN)替换。<br>既然shuffle会带来很高的开销，除了优化driver程序也可以考虑优化系统配置。<br>首先&#47;tmp是会被系统清理的（取决于不同linux分发版的清理策略），如果作业运行时&#47;tmp中的文件被清除了，那就要重新shuffle或<br>重新缓存RDD（这块没有仔细研究，简单猜测下缓存失效策略是重新缓存），因此，不适合将配置spark.local.dir设置为默认的&#47;tmp<br>其次，部署文档有提该配置项支持多个目录，那可以考虑配置多块硬盘（或者SSD），再把挂载不同硬盘的目录配置到spark.local.dir，<br>这样可以显著提升shuffle和RDD缓存的性能。请大家指教。","like_count":28,"discussions":[{"author":{"id":1043100,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/9c/230061e7.jpg","nickname":"吴磊","note":"","ucode":"136DC8CF1B10DC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527236,"discussion_content":"完美，满分💯！置顶🔝\n\n老弟功底十分扎实～👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632358182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1385403,"avatar":"https://static001.geekbang.org/account/avatar/00/15/23/bb/a1a61f7c.jpg","nickname":"GAC·DU","note":"","ucode":"7847FBE1C13740","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":395369,"discussion_content":"用逗号分开可以实现挂载到多个硬盘的目录下，这样是不是就可以避免硬盘故障和提高shuffle write的并行度了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632294351,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1435535,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epGTSTvn7r4ibk1PuaUrSvvLdviaLcne50jbvvfiaxKkM5SLibeP6jibA2bCCQBqETibvIvcsOhAZlwS8kQ/132","nickname":"Geek_2dfa9a","note":"","ucode":"B5FE7971F5E773","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1385403,"avatar":"https://static001.geekbang.org/account/avatar/00/15/23/bb/a1a61f7c.jpg","nickname":"GAC·DU","note":"","ucode":"7847FBE1C13740","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":395438,"discussion_content":"\n我觉得是这样，主要目标是为了提升shuffle的io效率，容错的话并不是那么重要，因为这些临时文件在job运行完成后会清理的，生命周期是job级别的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1632305832,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":395369,"ip_address":""},"score":395438,"extra":""},{"author":{"id":1385403,"avatar":"https://static001.geekbang.org/account/avatar/00/15/23/bb/a1a61f7c.jpg","nickname":"GAC·DU","note":"","ucode":"7847FBE1C13740","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1435535,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epGTSTvn7r4ibk1PuaUrSvvLdviaLcne50jbvvfiaxKkM5SLibeP6jibA2bCCQBqETibvIvcsOhAZlwS8kQ/132","nickname":"Geek_2dfa9a","note":"","ucode":"B5FE7971F5E773","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":395643,"discussion_content":"可以深入讨论一下，如果把shuffle write数据落盘操作和Kafka数据落盘操作横向对比一下，会不会有异曲同工之妙，同样是数据先写入内存，然后批量落盘，kafka会提供offset文件，shuffle会提供index文件，如果把shuffle替换成kafka是什么效果？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632321018,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":395438,"ip_address":""},"score":395643,"extra":""},{"author":{"id":1435535,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epGTSTvn7r4ibk1PuaUrSvvLdviaLcne50jbvvfiaxKkM5SLibeP6jibA2bCCQBqETibvIvcsOhAZlwS8kQ/132","nickname":"Geek_2dfa9a","note":"","ucode":"B5FE7971F5E773","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1385403,"avatar":"https://static001.geekbang.org/account/avatar/00/15/23/bb/a1a61f7c.jpg","nickname":"GAC·DU","note":"","ucode":"7847FBE1C13740","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":395753,"discussion_content":"没问题，我找个时间仔细看下源码再回复你","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1632327001,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":395643,"ip_address":""},"score":395753,"extra":""}]}]},{"had_liked":false,"id":313333,"user_name":"qinsi","can_delete":false,"product_type":"c1","uid":1667175,"ip_address":"","ucode":"090D9C4068FF12","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","comment_is_top":false,"comment_ctime":1632380972,"is_pvip":true,"replies":[{"id":"113519","content":"好问题～<br><br>第一个问题实际上，就是数据倾斜，data skew，倾斜会导致你说的，闲的闲死、忙的忙死，忙的那个拖累作业整体性能。两种思路，一个是用spark3.0的AQE，join自动倾斜处理。另一个是手工加盐。这两种方法，其实在《性能篇》都有详细的介绍。稍后我把那边比较核心的讲解，给你贴过来。这会在地铁上，不好操作。<br><br>第二个，其实是两个层面的事情。一个是调度系统，说的是代码调度，调度到数据所在的地方。而shuffle呢，数据移动是刚需，是计算逻辑需要。换句话说，这个时候，代码动不动，数据都要动。这个其实已经超出调度系统范畴，纯粹是计算逻辑需要。两个层面的问题哈～","user_name":"作者回复","user_name_real":"吴磊","uid":"1043100","ctime":1632447114,"ip_address":"","comment_id":313333,"utype":1}],"discussion_count":2,"race_medal":0,"score":"44582053932","product_id":100090001,"comment_content":"看到哈希那边有个问题，就是遇到不均匀的数据会怎么样？比如对这篇论文执行word count：https:&#47;&#47;isotropic.org&#47;papers&#47;chicken.pdf<br><br>原本可能指望所有工人一起搬砖，结果发现只有一个工人在搬砖？<br><br>另外前几讲说过大数据的精髓在于数据不动代码动，但这讲说还是无法避免shuffle搬运数据，这个要怎么理解？","like_count":10,"discussions":[{"author":{"id":1043100,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/9c/230061e7.jpg","nickname":"吴磊","note":"","ucode":"136DC8CF1B10DC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527317,"discussion_content":"好问题～\n\n第一个问题实际上，就是数据倾斜，data skew，倾斜会导致你说的，闲的闲死、忙的忙死，忙的那个拖累作业整体性能。两种思路，一个是用spark3.0的AQE，join自动倾斜处理。另一个是手工加盐。这两种方法，其实在《性能篇》都有详细的介绍。稍后我把那边比较核心的讲解，给你贴过来。这会在地铁上，不好操作。\n\n第二个，其实是两个层面的事情。一个是调度系统，说的是代码调度，调度到数据所在的地方。而shuffle呢，数据移动是刚需，是计算逻辑需要。换句话说，这个时候，代码动不动，数据都要动。这个其实已经超出调度系统范畴，纯粹是计算逻辑需要。两个层面的问题哈～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632447114,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1722878,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/49/fe/48846a6d.jpg","nickname":"Ebdaoli","note":"","ucode":"E45C113C1AFD12","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1043100,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/9c/230061e7.jpg","nickname":"吴磊","note":"","ucode":"136DC8CF1B10DC","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":579212,"discussion_content":"我想请问下，关于移动计算和移动数据的问题，数据本地化的优先级是来源于数据存放的节点和计算节点的一致性，而计算节点有限的计算资源不能保证必然的本地化，那么在其他节点启动的计算任务就需要从数据存放节点来拉取数据。上述这部分的操作是影响了计算本地化和计算非本地化的时间差异，那么在数据经过shuffle算子之后，reduce的执行节点对shuffle溢出文件的拉取过程，这部分应该是拉取新生成的文件，这部分过程是否会涉及到计算本地化？比如我在本地写出map端文件，在本地继续执行reduce过程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657250360,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":527317,"ip_address":""},"score":579212,"extra":""}]}]},{"had_liked":false,"id":315123,"user_name":"Unknown element","can_delete":false,"product_type":"c1","uid":2028277,"ip_address":"","ucode":"34A129800D0238","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f2/f5/b82f410d.jpg","comment_is_top":false,"comment_ctime":1633694771,"is_pvip":false,"replies":[{"id":"114422","content":"好问题~ 是的， 就像你分析的那样，如果map task计算阶段，发现没有某些reduce task的数据，那么index文件中的索引，就会一直顺延~ 思考的很深入，赞👍~","user_name":"作者回复","user_name_real":"吴磊","uid":"1043100","ctime":1633965230,"ip_address":"","comment_id":315123,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23108531251","product_id":100090001,"comment_content":"老师您在shuffle read部分说“不同的 Reduce Task 正是根据 index 文件中的起始索引来确定哪些数据内容是属于自己的”，这一步具体是怎么实现的呢？以文中的index文件举例，文中的index文件是0,3,7，那么不同的reduce task是各自有一个编号，然后按编号大小顺序确定自己应该拉取哪一部分数据吗？比如编号为0的reduce task拉取index文件的第一个索引到第二个索引之间的数据，也就是index为0,1,2的数据；编号为1的reduce task拉取index文件的第二个索引到第三个索引之间的数据，也就是index为3,4,5,6的数据；编号为2的reduce task拉取index文件的第三个索引到最后的数据，也就是index为7,8,9的数据？这样的话如果map task计算出来没有数据应该被发到第二个reduce task那index文件是0,3,3吗？","like_count":5,"discussions":[{"author":{"id":1043100,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/9c/230061e7.jpg","nickname":"吴磊","note":"","ucode":"136DC8CF1B10DC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527874,"discussion_content":"好问题~ 是的， 就像你分析的那样，如果map task计算阶段，发现没有某些reduce task的数据，那么index文件中的索引，就会一直顺延~ 思考的很深入，赞👍~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633965230,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314262,"user_name":"Unknown element","can_delete":false,"product_type":"c1","uid":2028277,"ip_address":"","ucode":"34A129800D0238","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f2/f5/b82f410d.jpg","comment_is_top":false,"comment_ctime":1632919717,"is_pvip":false,"replies":[{"id":"113942","content":"好问题~<br><br>先说第一个，这个就是index文件的作用，它记录的就是隶属于不同Reduce task的数据索引，Reduce task基于这些索引来判断，哪些数据属于他。举例来说，Reduce task 3，那么data文件中，index从3到4之间的数据，就是属于这个Reduce task 3的。<br><br>第二个，好问题。这个其实是“静态思维”惹的祸。要知道，不管是Map task，还是Reduce task，消耗的计算资源，都是同一个集群、同样节点上同样的一批Executors。<br><br>Reduce tasks对于Map tasks是有依赖的，同一批Executors，执行完Map tasks之后，数据落盘到了spark.local.dir配置的目录。接下来，还是这同一批Executors，启动Reduce tasks，跨网络去不同节点上拉取属于自己的数据。<br><br>因此，Executors一直没闲着，不存在资源浪费的问题。要动态地看待Map &amp; Reduce过程，他们在时间线上，是有前后关系的。而所有任务，消耗的都是同一批硬件资源~<br><br>","user_name":"作者回复","user_name_real":"吴磊","uid":"1043100","ctime":1633167934,"ip_address":"","comment_id":314262,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18812788901","product_id":100090001,"comment_content":"老师您好  我有两个问题想问下：<br>1. 对于所有 Map Task 生成的中间文件，Reduce Task 需要通过网络从不同节点的硬盘中下载并拉取属于自己的数据内容  那不同的reduce task是怎么知道哪些内容是属于自己的呢？比如对于文中的例子，reduce阶段的3个任务怎么知道自己应该拉取中间文件的哪些记录？<br>2. 对于评论区AIK的问题，您说shuffle过程不是数据交换，而是数据流转，那意思是在map阶段 所有将要执行reduce task的节点都是空闲的吗（等待map task生成shuffle中间文件）？那他们是不是在这个stage的整个计算过程中都是空闲的？这样的话岂不是没有发挥出集群的最大算力？","like_count":4,"discussions":[{"author":{"id":2028277,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f2/f5/b82f410d.jpg","nickname":"Unknown element","note":"","ucode":"34A129800D0238","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400326,"discussion_content":"谢谢老师第二问题我懂了，但是第一个还是不太明白，就比如说文章中的那个例子，index文件是0，3，7，表示一个reduce task要拿index为0、1、2的数据，另一个reduce task要拿index为3、4、5、6的数据，剩下那个reduce task要拿index为7、8、9的数据，但是reduce task好像没有标号啊，他们怎么知道哪些数据是属于自己的呢","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1633234281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1043100,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/9c/230061e7.jpg","nickname":"吴磊","note":"","ucode":"136DC8CF1B10DC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527623,"discussion_content":"好问题~\n\n先说第一个，这个就是index文件的作用，它记录的就是隶属于不同Reduce task的数据索引，Reduce task基于这些索引来判断，哪些数据属于他。举例来说，Reduce task 3，那么data文件中，index从3到4之间的数据，就是属于这个Reduce task 3的。\n\n第二个，好问题。这个其实是“静态思维”惹的祸。要知道，不管是Map task，还是Reduce task，消耗的计算资源，都是同一个集群、同样节点上同样的一批Executors。\n\nReduce tasks对于Map tasks是有依赖的，同一批Executors，执行完Map tasks之后，数据落盘到了spark.local.dir配置的目录。接下来，还是这同一批Executors，启动Reduce tasks，跨网络去不同节点上拉取属于自己的数据。\n\n因此，Executors一直没闲着，不存在资源浪费的问题。要动态地看待Map &amp;amp; Reduce过程，他们在时间线上，是有前后关系的。而所有任务，消耗的都是同一批硬件资源~\n\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1633167934,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":337251,"user_name":"钟强","can_delete":false,"product_type":"c1","uid":2446756,"ip_address":"","ucode":"C4227385241E70","user_header":"https://static001.geekbang.org/account/avatar/00/25/55/a4/a06abd2d.jpg","comment_is_top":false,"comment_ctime":1646718740,"is_pvip":false,"replies":[{"id":"123312","content":"shuffle与executors数量无关哈，即便是一个executors，像groupByKey、join、reduceByKey这些操作，照样会引入shuffle，只不过shuffle都在同一个executors发生，省去了网络I&#47;O的开销，但是磁盘开销还是会有","user_name":"作者回复","user_name_real":"编辑","uid":"1043100","ctime":1646833878,"ip_address":"","comment_id":337251,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10236653332","product_id":100090001,"comment_content":"如果集群中只有一个executor, 但是executor上面有多个map task, 这样的环境是不是不需要shuffle?","like_count":2,"discussions":[{"author":{"id":1043100,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/9c/230061e7.jpg","nickname":"吴磊","note":"","ucode":"136DC8CF1B10DC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555284,"discussion_content":"shuffle与executors数量无关哈，即便是一个executors，像groupByKey、join、reduceByKey这些操作，照样会引入shuffle，只不过shuffle都在同一个executors发生，省去了网络I/O的开销，但是磁盘开销还是会有","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646833878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336984,"user_name":"Ebdaoli","can_delete":false,"product_type":"c1","uid":1722878,"ip_address":"","ucode":"E45C113C1AFD12","user_header":"https://static001.geekbang.org/account/avatar/00/1a/49/fe/48846a6d.jpg","comment_is_top":false,"comment_ctime":1646535243,"is_pvip":false,"replies":[{"id":"123311","content":"一个个来看哈<br>1）Map task，其并行度由其Stage中的首个RDD决定，如果Map task是读取HDFS，那么并行度就是分布式文件block数量；<br>2）是的，中间文件的合并，可以理解为归并排序；另外，对于Join策略，Spark通常默认选取SMJ，因此Sort有利于后期做数据关联","user_name":"作者回复","user_name_real":"编辑","uid":"1043100","ctime":1646833789,"ip_address":"","comment_id":336984,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10236469835","product_id":100090001,"comment_content":"磊哥，关于 spark shuffle write 阶段有个问题不太理解，①：Maptask的 任务数的并行度由什么来决定的？根据文件大小来切分划分的吗？ ②：为什么最终数据需要进行 sort？合并的方式选择的是 归并排序？","like_count":2,"discussions":[{"author":{"id":1043100,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/9c/230061e7.jpg","nickname":"吴磊","note":"","ucode":"136DC8CF1B10DC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555283,"discussion_content":"一个个来看哈\n1）Map task，其并行度由其Stage中的首个RDD决定，如果Map task是读取HDFS，那么并行度就是分布式文件block数量；\n2）是的，中间文件的合并，可以理解为归并排序；另外，对于Join策略，Spark通常默认选取SMJ，因此Sort有利于后期做数据关联","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646833789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324852,"user_name":"猫太太","can_delete":false,"product_type":"c1","uid":1537617,"ip_address":"","ucode":"7A1D1CAA3AF260","user_header":"https://static001.geekbang.org/account/avatar/00/17/76/51/96291466.jpg","comment_is_top":false,"comment_ctime":1638688055,"is_pvip":false,"replies":[{"id":"118144","content":"老弟说的是对的~ Reduce Task拉取数据的过程就是Shuffle Read。<br><br>这里的写法有问题，我回头让编辑帮忙改下，这里应该是最后的总结部分，改得比较仓促，出typo了，感谢老弟提醒~","user_name":"作者回复","user_name_real":"编辑","uid":"1043100","ctime":1639060873,"ip_address":"","comment_id":324852,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10228622647","product_id":100090001,"comment_content":"您好，讲的很清楚，看完都有点想去去自己看源码了。这句有点不太理解，可以解释一下么：“Reduce 阶段不同于 Reduce Task 拉取数据的过程，往往也被叫做 Shuffle Read。” 请问shuffle read属于reduce阶段么？reduce task拉取数据的过程不包括在reduce阶段么？reduce task拉取数据的过程不是shuffle read么？reduce阶段有什么事情发生呢？谢谢～","like_count":2,"discussions":[{"author":{"id":1043100,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/9c/230061e7.jpg","nickname":"吴磊","note":"","ucode":"136DC8CF1B10DC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537445,"discussion_content":"老弟说的是对的~ Reduce Task拉取数据的过程就是Shuffle Read。\n\n这里的写法有问题，我回头让编辑帮忙改下，这里应该是最后的总结部分，改得比较仓促，出typo了，感谢老弟提醒~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639060873,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313101,"user_name":"Neo-dqy","can_delete":false,"product_type":"c1","uid":1924786,"ip_address":"","ucode":"9BF300EB1DDD00","user_header":"https://static001.geekbang.org/account/avatar/00/1d/5e/b2/aceb3e41.jpg","comment_is_top":false,"comment_ctime":1632280220,"is_pvip":false,"replies":[{"id":"113474","content":"好问题～<br><br>1. 这里是按照（目标分区id，词频）来排序的。也就是按照两列排序。<br><br>2.下一讲就会提到，groupByKey、reduceByKey、aggregateByKey、combineByKey、sortByKey，都会引入Shuffle。<br><br>3. 可以关注后面要讲的broadcast join～ ","user_name":"作者回复","user_name_real":"吴磊","uid":"1043100","ctime":1632358917,"ip_address":"","comment_id":313101,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10222214812","product_id":100090001,"comment_content":"老师好，学完这节课我主要有三个问题：<br>1. Shuffle Write 过程中，对所有临时文件和内存数据结构中剩余的数据记录做归并排序，这里是按照目标分区的ID进行排序，还是按照value（词频）进行排序的啊？<br>2. 除了reduce类型的算子会触发shuffle操作，还有什么别的算子能触发呢？<br>3. 既然shuffle操作是不可避免的，那我们又要怎么优化这个操作呢？","like_count":2,"discussions":[{"author":{"id":1043100,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/9c/230061e7.jpg","nickname":"吴磊","note":"","ucode":"136DC8CF1B10DC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527230,"discussion_content":"好问题～\n\n1. 这里是按照（目标分区id，词频）来排序的。也就是按照两列排序。\n\n2.下一讲就会提到，groupByKey、reduceByKey、aggregateByKey、combineByKey、sortByKey，都会引入Shuffle。\n\n3. 可以关注后面要讲的broadcast join～ ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632358917,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2108294,"avatar":"https://static001.geekbang.org/account/avatar/00/20/2b/86/318e6ff3.jpg","nickname":"井先生","note":"","ucode":"87FD735FA7BFC3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":397600,"discussion_content":"1. 这里是按照（目标分区id，词频）来排序的。也就是按照两列排序。\n=》我怎么理解是按照（目标分区id，key）来排序的?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632650166,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1043100,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/9c/230061e7.jpg","nickname":"吴磊","note":"","ucode":"136DC8CF1B10DC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":2108294,"avatar":"https://static001.geekbang.org/account/avatar/00/20/2b/86/318e6ff3.jpg","nickname":"井先生","note":"","ucode":"87FD735FA7BFC3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":399148,"discussion_content":"前面有个kv交换，交换之后，词频就是key","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1632911412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":397600,"ip_address":""},"score":399148,"extra":""}]}]},{"had_liked":false,"id":344662,"user_name":"星潼","can_delete":false,"product_type":"c1","uid":1008546,"ip_address":"","ucode":"D7C30CD2BEC78D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/a2/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1651715506,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5946682802","product_id":100090001,"comment_content":"感谢老师的精彩讲解，我有一个问题请教老师^_^。<br>听了老师的讲解，我发现Spark也是将Shuffle过程的中间结果保存在磁盘，感觉这个流程跟MapReduce的Shuffle过程很类似。<br>MapReduce性能差的一个原因就是Map Task将中间结果数据写在磁盘，之前听说Spark性能好的原因是由于内存计算，可既然Spark的shuffle过程也是将中间结果写到磁盘，那为什么spark的性能就会比MR高出很多呢？请老师指教，感谢。","like_count":1,"discussions":[{"author":{"id":1526892,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4c/6c/11fb0f1d.jpg","nickname":"布兰特","note":"","ucode":"EE3316C188EC3C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574144,"discussion_content":"spark在中间结果溢写磁盘之前，会尽可量的利用内存，直到TaskManager没有可分配的内存，才会将中间结果溢写。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1653870745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332512,"user_name":"阿狸弟弟的包子店","can_delete":false,"product_type":"c1","uid":2861352,"ip_address":"","ucode":"0CCF598B029075","user_header":"","comment_is_top":false,"comment_ctime":1643284122,"is_pvip":false,"replies":[{"id":"121496","content":"之前有hash shuffle manager和Tungsten shuffle manager，不过现在都统一到sort shuffle manager里面了。hash很早就deprecate掉了，对于文件的消耗太大了；Tungsten shuffle manager，基本运行机制与sort shuffle manager一致，主要是在计算过程中，尽可能地利用了Tungsten的数据结构和内存寻址方式。在计算流程上，Tungsten based shuffle和sort based shuffle是一样的~","user_name":"作者回复","user_name_real":"编辑","uid":"1043100","ctime":1643355605,"ip_address":"","comment_id":332512,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5938251418","product_id":100090001,"comment_content":"Shuffle算法感觉需要补一补，看评论有hash得，还有sort-base的，还有其他的吗？","like_count":1,"discussions":[{"author":{"id":1043100,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/9c/230061e7.jpg","nickname":"吴磊","note":"","ucode":"136DC8CF1B10DC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548748,"discussion_content":"之前有hash shuffle manager和Tungsten shuffle manager，不过现在都统一到sort shuffle manager里面了。hash很早就deprecate掉了，对于文件的消耗太大了；Tungsten shuffle manager，基本运行机制与sort shuffle manager一致，主要是在计算过程中，尽可能地利用了Tungsten的数据结构和内存寻址方式。在计算流程上，Tungsten based shuffle和sort based shuffle是一样的~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643355605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330871,"user_name":"A","can_delete":false,"product_type":"c1","uid":2709345,"ip_address":"","ucode":"3A60C9F3985A38","user_header":"https://static001.geekbang.org/account/avatar/00/29/57/61/369a609c.jpg","comment_is_top":false,"comment_ctime":1642237618,"is_pvip":false,"replies":[{"id":"121199","content":"Quote<br>“运行stage0的executor产生的数据称作建材，结束后driver继续提交stage1，运行stage1的executor全集群得去拉去各自所需的建材，可以这样理解嘛老师？”<br>是的，理解是对的~ 完全正确<br><br>对于每个map task来说，data、index都存储在本机磁盘，具体目录由spark.local.dir配置项来确定。哪些文件，存储在哪里，尺寸大小，这些meta data，都会由存储系统当中的BlockManager来记录，每个Executors都有自己的BlockManager。各个Executors的BlockManager会向Driver的BlockManagerMaster定期汇报这些meta data。reduce task在尝试拉取data、index文件时，需要通过Executors的BlockManager去拿到这些元信息，然后完成数据拉取。如果Executors的BlockManager没有这些元信息，BlockManager回去找Driver端的BlockManagerMaster，从而拿到全局元信息~","user_name":"作者回复","user_name_real":"编辑","uid":"1043100","ctime":1642778533,"ip_address":"","comment_id":330871,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5937204914","product_id":100090001,"comment_content":"因rdd得依赖属性shuffle划分了两个stage0和1<br>运行stage0的executor产生的数据称作建材，结束后driver继续提交stage1，运行stage1的executor全集群得去拉去各自所需的建材，可以这样理解嘛老师？<br>那stage0产生的临时data、index是记录在哪里？如何返回给driver的呢？以及stage1提交时是如何获取的呢？<br>目前想到的是重新封装但是又说不过去<br>还望老师给条路，自己再去研究一下！<br>感谢老师！","like_count":1,"discussions":[{"author":{"id":1043100,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/9c/230061e7.jpg","nickname":"吴磊","note":"","ucode":"136DC8CF1B10DC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547640,"discussion_content":"Quote\n“运行stage0的executor产生的数据称作建材，结束后driver继续提交stage1，运行stage1的executor全集群得去拉去各自所需的建材，可以这样理解嘛老师？”\n是的，理解是对的~ 完全正确\n\n对于每个map task来说，data、index都存储在本机磁盘，具体目录由spark.local.dir配置项来确定。哪些文件，存储在哪里，尺寸大小，这些meta data，都会由存储系统当中的BlockManager来记录，每个Executors都有自己的BlockManager。各个Executors的BlockManager会向Driver的BlockManagerMaster定期汇报这些meta data。reduce task在尝试拉取data、index文件时，需要通过Executors的BlockManager去拿到这些元信息，然后完成数据拉取。如果Executors的BlockManager没有这些元信息，BlockManager回去找Driver端的BlockManagerMaster，从而拿到全局元信息~","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1642778534,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2709345,"avatar":"https://static001.geekbang.org/account/avatar/00/29/57/61/369a609c.jpg","nickname":"A","note":"","ucode":"3A60C9F3985A38","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1043100,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/9c/230061e7.jpg","nickname":"吴磊","note":"","ucode":"136DC8CF1B10DC","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":547642,"discussion_content":"老师，也就是说driver端把rdd各种转化流程转换为任务分发给executor以后，executor开始执行任务的时候还是有可能会去主动向driver端索要自己所需的数据（executor的blockmanager没有的话）\n那我明白了老师，看来我陷入了思维误区，感谢老师的解答，我去源码里找找这些信息。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642778852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":547640,"ip_address":""},"score":547642,"extra":""}]}]},{"had_liked":false,"id":323786,"user_name":"实数","can_delete":false,"product_type":"c1","uid":2637725,"ip_address":"","ucode":"697BEAFCE929D2","user_header":"https://static001.geekbang.org/account/avatar/00/28/3f/9d/c59c12ad.jpg","comment_is_top":false,"comment_ctime":1638162863,"is_pvip":false,"replies":[{"id":"117606","content":"Hash-based shuffle已经deprecate了哈，现在默认的都是Sort-based shuffle。Shuffle的目的不是排序，单纯的Shuffle，做不到全局有序。Sort-based只是shuffle的一种实现方式~<br><br>Sort-based实现方式至少有两个收益：<br>1）为后续可能的Sort Merge Join奠定基础<br>2）为后续可能的全局排序，奠定基础","user_name":"作者回复","user_name_real":"编辑","uid":"1043100","ctime":1638284833,"ip_address":"","comment_id":323786,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5933130159","product_id":100090001,"comment_content":"这个讲的是hashshuffle是吗，那么第二代的sortshuffle相比较如何呢。是不是两代的shuffle都不能保证全局有序啊","like_count":1,"discussions":[{"author":{"id":1043100,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/9c/230061e7.jpg","nickname":"吴磊","note":"","ucode":"136DC8CF1B10DC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534844,"discussion_content":"Hash-based shuffle已经deprecate了哈，现在默认的都是Sort-based shuffle。Shuffle的目的不是排序，单纯的Shuffle，做不到全局有序。Sort-based只是shuffle的一种实现方式~\n\nSort-based实现方式至少有两个收益：\n1）为后续可能的Sort Merge Join奠定基础\n2）为后续可能的全局排序，奠定基础","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638284833,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321018,"user_name":"啊秋秋秋秋","can_delete":false,"product_type":"c1","uid":2479108,"ip_address":"","ucode":"695F4B9B4AFE8F","user_header":"https://static001.geekbang.org/account/avatar/00/25/d4/04/49dfb810.jpg","comment_is_top":false,"comment_ctime":1636621494,"is_pvip":false,"replies":[{"id":"116595","content":"老弟不妨换种思路、或是换个视角，来看待Shuffle的过程。Shuffle字面意思，是数据分发，但是在我看来，是Map阶段和Reduce阶段的数据交换。<br><br>我们其实说过，上一个Shuffle的Reduce阶段，其实是下一个Shuffle的Map阶段。Reduce阶段在Shuffle边界去拉取Map阶段的输出数据，本质上，和整个Spark作业从源头读取数据源，并没有本质上的区别。<br><br>Spark从分布式文件系统读数据，也会有网络开销；这个和Reduce阶段去读Map阶段输出的中间文件，本质上是一个过程。因此，与其说是pull模式，倒不如说就是数据源的跨网络访问（读取）而已。<br><br>所以说，Shuffle的过程中，只有所谓的“Pull”模式（数据的跨节点访问），没有常规意义的Push模式，因为Push模式不成立。","user_name":"作者回复","user_name_real":"吴磊","uid":"1043100","ctime":1636645924,"ip_address":"","comment_id":321018,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5931588790","product_id":100090001,"comment_content":"老师您好！请问为什么是reducer从mapper那里拉取数据，而不是mapper把数据push到reducer端呢？我自己的理解是，如果是mapper push的话，传递数据这部分工作主要在mapper端，比如需要存储各个reducer的地址，会给mapper增加workload？但是感觉两种方式都可以，不太清楚为什么MR Spark这种分布式计算模型里都是采用reducer pull，请指点一下！谢谢！！","like_count":1,"discussions":[{"author":{"id":1043100,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/9c/230061e7.jpg","nickname":"吴磊","note":"","ucode":"136DC8CF1B10DC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530187,"discussion_content":"老弟不妨换种思路、或是换个视角，来看待Shuffle的过程。Shuffle字面意思，是数据分发，但是在我看来，是Map阶段和Reduce阶段的数据交换。\n\n我们其实说过，上一个Shuffle的Reduce阶段，其实是下一个Shuffle的Map阶段。Reduce阶段在Shuffle边界去拉取Map阶段的输出数据，本质上，和整个Spark作业从源头读取数据源，并没有本质上的区别。\n\nSpark从分布式文件系统读数据，也会有网络开销；这个和Reduce阶段去读Map阶段输出的中间文件，本质上是一个过程。因此，与其说是pull模式，倒不如说就是数据源的跨网络访问（读取）而已。\n\n所以说，Shuffle的过程中，只有所谓的“Pull”模式（数据的跨节点访问），没有常规意义的Push模式，因为Push模式不成立。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636645924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313124,"user_name":"GAC·DU","can_delete":false,"product_type":"c1","uid":1385403,"ip_address":"","ucode":"7847FBE1C13740","user_header":"https://static001.geekbang.org/account/avatar/00/15/23/bb/a1a61f7c.jpg","comment_is_top":false,"comment_ctime":1632287672,"is_pvip":true,"replies":[{"id":"113473","content":"好问题～<br><br>先说第二个，你说的对，你的说法更加准确，确实不是交换，而是传递&#47;流转。从生产消费的角度来看，map阶段是生产者，reduce阶段是消费者。<br><br>再说第一个，其实很简单，就是当前索引和下一个索引之间的范围。reduce task从自己的起始索引，读到下一个task的起始索引，就确定了自己的数据范围～","user_name":"作者回复","user_name_real":"吴磊","uid":"1043100","ctime":1632358487,"ip_address":"","comment_id":313124,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5927254968","product_id":100090001,"comment_content":"中间存储文件，我理解它是一个不用永久存储的临时文件，理论上放到任何位置都可以。但是如果在生成文件这个临界点Executor宕机，存放在&#47;tmp目录下的文件就会丢失，如果存放在正常的目录下就会避免这种问题。还有shuffle write如果是顺序写，选SSD或者HDD硬盘也没什么区别。<br><br>有两个问题想请教老师<br><br>第一，您说Reduce Task 通过 index 文件来“定位”属于自己的数据内容和index 文件，是用来标记目标分区所属数据记录的起始索引。那么Reduce Task如何知道从起始索引读取多少个数据为止，是Reduce Task内部还有算法吗？<br><br>第二，您说Map 阶段与 Reduce 阶段，通过生产与消费 Shuffle 中间文件的方式，来完成集群范围内的数据交换，我对此处的交换不是很理解，交换不应该是相互的吗，我理解的交换是双方拿出自己的交给对方，比如我在篮子里放一个苹果，您在篮子里放一个梨，我拿到了梨而您拿到了苹果。但是Map和Reduce两者之间Reduce更像是白拿。这里的数据交换能不能理解成数据传递或者数据流转？","like_count":1,"discussions":[{"author":{"id":1043100,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/9c/230061e7.jpg","nickname":"吴磊","note":"","ucode":"136DC8CF1B10DC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527240,"discussion_content":"好问题～\n\n先说第二个，你说的对，你的说法更加准确，确实不是交换，而是传递/流转。从生产消费的角度来看，map阶段是生产者，reduce阶段是消费者。\n\n再说第一个，其实很简单，就是当前索引和下一个索引之间的范围。reduce task从自己的起始索引，读到下一个task的起始索引，就确定了自己的数据范围～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632358487,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2861352,"avatar":"","nickname":"阿狸弟弟的包子店","note":"","ucode":"0CCF598B029075","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548631,"discussion_content":"思考的很深入","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643283770,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360388,"user_name":"小李","can_delete":false,"product_type":"c1","uid":1903790,"ip_address":"四川","ucode":"30BD251EE1B1E2","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/iaQgtbE98VGIVIyribdo6dgLOnaNoe7ZdUuPr60ibsduibscrzQCTzdW2AfL9nxwe8YlSK75gOnK3YbAJKTaFPxibdg/132","comment_is_top":false,"comment_ctime":1666532655,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1666532655","product_id":100090001,"comment_content":"老师，在业务场景中，shuffle write阶段是怎么知道shuffle read阶段的分区数的？","like_count":0},{"had_liked":false,"id":354161,"user_name":"唐方刚","can_delete":false,"product_type":"c1","uid":3046392,"ip_address":"广东","ucode":"93DA58C3DCCF1B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/ugib9sF9icd9dhibQoAA025hibbD5zgZTiaddLoeEH457hrkBBhtQK6qknTWt270rHCtBZqeqsbibtHghgjdkPx3DyIw/132","comment_is_top":false,"comment_ctime":1660135199,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660135199","product_id":100090001,"comment_content":"怎么感觉和hadoop mr的过程一样的","like_count":0},{"had_liked":false,"id":345864,"user_name":"Geek_b2839b","can_delete":false,"product_type":"c1","uid":2876299,"ip_address":"","ucode":"6D8ABA989AB724","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIw0Nnvrrt9fV1wHVfBlPzrZmxNCRTbWPfNEbCEMtuoj6gw0LlMbbS3gtRLgLMfCoAV3TXsk5giavw/132","comment_is_top":false,"comment_ctime":1652662561,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652662561","product_id":100090001,"comment_content":"4. 对所有临时文件和内存数据结构中剩余的数据记录做归并排序，生成数据文件和索引文件。<br>-----------------------<br>老师，如果临时文件和内存数据文件非常大，无法单节点加载进入内存里，那怎么去归并排序呢","like_count":0},{"had_liked":false,"id":336641,"user_name":"Tianchen","can_delete":false,"product_type":"c1","uid":2880924,"ip_address":"","ucode":"44FDD3D5510149","user_header":"https://static001.geekbang.org/account/avatar/00/2b/f5/9c/4bdff9f2.jpg","comment_is_top":false,"comment_ctime":1646271606,"is_pvip":false,"replies":[{"id":"123248","content":"Partition ID~","user_name":"作者回复","user_name_real":"编辑","uid":"1043100","ctime":1646725113,"ip_address":"","comment_id":336641,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1646271606","product_id":100090001,"comment_content":"老师好，想问下公式1的哈希值P，在后续流程中是对应的Map 结构中Reduce Task Partition ID（P0,P1 ,P2）还是index（0,3,7）","like_count":0,"discussions":[{"author":{"id":1043100,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/9c/230061e7.jpg","nickname":"吴磊","note":"","ucode":"136DC8CF1B10DC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555035,"discussion_content":"Partition ID~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646725114,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":334597,"user_name":"小西门","can_delete":false,"product_type":"c1","uid":1366326,"ip_address":"","ucode":"96EB1026635BD5","user_header":"https://static001.geekbang.org/account/avatar/00/14/d9/36/05eda19f.jpg","comment_is_top":false,"comment_ctime":1645012634,"is_pvip":false,"replies":[{"id":"122823","content":"并不是哈~ 老弟还是需要再消化下Shuffle的整个计算过程，所有reduce task都需要去所有机器上去拉取shuffle中间文件，这个不由Driver来决定；再者，reduce阶段partitioner是确定的，不存在task&#47;partition ID不一致的情况","user_name":"作者回复","user_name_real":"编辑","uid":"1043100","ctime":1645889516,"ip_address":"","comment_id":334597,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1645012634","product_id":100090001,"comment_content":"老师好，我的问题是：<br>如果计算记录所属那个Reduce Task的算法是一致的话，会不会出现某些exectors中只有单个(k,v)，但是通过算法计算出来的reduce task partition ID是另外一个executor？这样就产生了不必要的网络IO。<br><br>我个人猜想是，会不会计算reduce task partition ID是在各map task做完之后，通知到driver，dirver获得了全局信息后，再通知到reduce task不用去shuffle read只有单个(k,v)的executor的shuffle中间文件。","like_count":0,"discussions":[{"author":{"id":1043100,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/9c/230061e7.jpg","nickname":"吴磊","note":"","ucode":"136DC8CF1B10DC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553462,"discussion_content":"并不是哈~ 老弟还是需要再消化下Shuffle的整个计算过程，所有reduce task都需要去所有机器上去拉取shuffle中间文件，这个不由Driver来决定；再者，reduce阶段partitioner是确定的，不存在task/partition ID不一致的情况","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645889516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333376,"user_name":"艾利特-G","can_delete":false,"product_type":"c1","uid":1195204,"ip_address":"","ucode":"8C4DA0ABE77CDC","user_header":"https://static001.geekbang.org/account/avatar/00/12/3c/c4/4ee2968a.jpg","comment_is_top":false,"comment_ctime":1644314370,"is_pvip":false,"replies":[{"id":"122396","content":"第一段里说的&quot;N&quot;和第二段里说的任务并行度，确实是同一个事物，但他们不是Executors的Core数。简单理解，并行度就是数据分片的数量，想象一下，一个数据集，总共1TB，假设每个数据分片200MB，那么总共有1TB&#47;200GB这么多个数据分片，这个数字显然和Executors的Core没有对应关系的~","user_name":"作者回复","user_name_real":"编辑","uid":"1043100","ctime":1645369620,"ip_address":"","comment_id":333376,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1644314370","product_id":100090001,"comment_content":"&gt; 假设 Reduce 阶段有 N 个 Task，这 N 个 Task 对应着 N 个数据分区，那么在 Map 阶段，每条记录应该分发到哪个 Reduce Task，是由下面的公式来决定的。<br>&gt; ...<br>&gt; 首先，我们需要注意的是，对于每一个 Map Task 生成的中间文件，其中的目标分区数量是由 Reduce 阶段的任务数量（又叫并行度）决定的。<br><br>所以我是不是可以这么理解: 第一段里说的&quot;N&quot;和第二段里说的任务并行度是同一个事物，也就是Executor的core数？","like_count":0,"discussions":[{"author":{"id":1043100,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/9c/230061e7.jpg","nickname":"吴磊","note":"","ucode":"136DC8CF1B10DC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552255,"discussion_content":"第一段里说的&#34;N&#34;和第二段里说的任务并行度，确实是同一个事物，但他们不是Executors的Core数。简单理解，并行度就是数据分片的数量，想象一下，一个数据集，总共1TB，假设每个数据分片200MB，那么总共有1TB/200GB这么多个数据分片，这个数字显然和Executors的Core没有对应关系的~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645369620,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322907,"user_name":"Geek_a3a122","can_delete":false,"product_type":"c1","uid":2850979,"ip_address":"","ucode":"E8447CC8267B1D","user_header":"","comment_is_top":false,"comment_ctime":1637654462,"is_pvip":false,"replies":[{"id":"117416","content":"老弟说的是对的~ Reduce Task拉取数据的过程就是Shuffle Read。<br><br>这里的写法有问题，我回头让编辑帮忙改下，这里应该是最后的总结部分，改得比较仓促，出typo了，感谢老弟提醒~","user_name":"作者回复","user_name_real":"编辑","uid":"1043100","ctime":1637987322,"ip_address":"","comment_id":322907,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1637654462","product_id":100090001,"comment_content":"`Reduce 阶段不同于 Reduce Task 拉取数据的过程，往往也被叫做 Shuffle Read。`<br>这句话没太理解，Reduce Task拉取数据的过程不就是Shuffle Read吗，为什么叫Reduce阶段不同于Reduce Task拉取数据的过程呢？","like_count":0,"discussions":[{"author":{"id":1043100,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/9c/230061e7.jpg","nickname":"吴磊","note":"","ucode":"136DC8CF1B10DC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":533829,"discussion_content":"老弟说的是对的~ Reduce Task拉取数据的过程就是Shuffle Read。\n\n这里的写法有问题，我回头让编辑帮忙改下，这里应该是最后的总结部分，改得比较仓促，出typo了，感谢老弟提醒~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637987322,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1537617,"avatar":"https://static001.geekbang.org/account/avatar/00/17/76/51/96291466.jpg","nickname":"猫太太","note":"","ucode":"7A1D1CAA3AF260","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536103,"discussion_content":"同问了 发现老师在前面的评论已经解答了 谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638689642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321087,"user_name":"Andy","can_delete":false,"product_type":"c1","uid":1119133,"ip_address":"","ucode":"4BCA899B8E4E85","user_header":"https://static001.geekbang.org/account/avatar/00/11/13/9d/0ff43179.jpg","comment_is_top":false,"comment_ctime":1636673264,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636673264","product_id":100090001,"comment_content":"我在当前项目中，安装了spark2.3.3 手动设置了 SPARK_LOCAL_DIRS 目录。因为我运行程序时没指定cluster模式，默认是master local ，程序会把所有数据（1T数据）拉到提交任务的机器，把tmp写爆了，程序就死了。提交任务时显示指定了 client 或 cluster模式就解决了这个写爆本地磁盘问题（数据都是各各datanode上运行了）。平时程序如果不报没有硬盘空间，我根本不关注spark.local.dir参数。","like_count":0},{"had_liked":false,"id":314566,"user_name":"LJK","can_delete":false,"product_type":"c1","uid":1199213,"ip_address":"","ucode":"12B2441099FF1D","user_header":"https://static001.geekbang.org/account/avatar/00/12/4c/6d/c20f2d5a.jpg","comment_is_top":false,"comment_ctime":1633230363,"is_pvip":false,"replies":[{"id":"114051","content":"先说coalesce(shuffle=false)，这个没有网络I&#47;O的，coalesce只是在同一个Executor内部（同一个JVM进程）对多个分区做合并，所以肯定没有网络I&#47;O的~<br><br>再说cartesian，比较特殊，它是两个RDD之间的操作，两个RDD元素之间，需要做笛卡尔积。具体的实现上，Spark保持一个RDD“待在原地、保持不动”，而去全量广播另一个RDD，这样即可轻松完成两个RDD的笛卡尔积。所以在这个操作里，前一个RDD没有网络I&#47;O，但是后面一个会有~","user_name":"作者回复","user_name_real":"吴磊","uid":"1043100","ctime":1633610804,"ip_address":"","comment_id":314566,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1633230363","product_id":100090001,"comment_content":"老师的课真的是很好，非常感谢！对于Shuffle有个疑问，之前看到过对于几种特殊情况窄依赖的操作，譬如coalesce(shuffle=false)和cartesian，虽然child rdd依赖多个parent rdd，但是是不会生成新的stage的，不明白这几个操作会不会产生网络IO。毕竟如果下一个task需要合并多个分区的话，如果这些分区不在同一物理节点，那么如何进行合并呢？还是说由于懒加载其实是不进行合并的？","like_count":0,"discussions":[{"author":{"id":1043100,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/9c/230061e7.jpg","nickname":"吴磊","note":"","ucode":"136DC8CF1B10DC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527721,"discussion_content":"先说coalesce(shuffle=false)，这个没有网络I/O的，coalesce只是在同一个Executor内部（同一个JVM进程）对多个分区做合并，所以肯定没有网络I/O的~\n\n再说cartesian，比较特殊，它是两个RDD之间的操作，两个RDD元素之间，需要做笛卡尔积。具体的实现上，Spark保持一个RDD“待在原地、保持不动”，而去全量广播另一个RDD，这样即可轻松完成两个RDD的笛卡尔积。所以在这个操作里，前一个RDD没有网络I/O，但是后面一个会有~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633610804,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313966,"user_name":"钱鹏 Allen","can_delete":false,"product_type":"c1","uid":2518863,"ip_address":"","ucode":"7E95E82C0717DA","user_header":"https://static001.geekbang.org/account/avatar/00/26/6f/4f/3cf1e9c4.jpg","comment_is_top":false,"comment_ctime":1632760493,"is_pvip":true,"replies":[{"id":"113780","content":"这句不对哈：“transform和action之间有shuffle”<br><br>两者之间一定不存在shuffle，shuffle都是transformation算子引入的。具体哪些算子会引入shuffle，可以等看完算子（三）之后做个简单汇总～","user_name":"作者回复","user_name_real":"吴磊","uid":"1043100","ctime":1632878204,"ip_address":"","comment_id":313966,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1632760493","product_id":100090001,"comment_content":"tmp缓存文件可以临时生成<br>shuflle阶段：溢出临时文件和合并merge中间文件<br>transform和action算子之间需要shuffle，之前自己只了解宽窄依赖，现在对shuffle的运行机制更深一部了解。","like_count":0,"discussions":[{"author":{"id":1043100,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/9c/230061e7.jpg","nickname":"吴磊","note":"","ucode":"136DC8CF1B10DC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527530,"discussion_content":"这句不对哈：“transform和action之间有shuffle”\n\n两者之间一定不存在shuffle，shuffle都是transformation算子引入的。具体哪些算子会引入shuffle，可以等看完算子（三）之后做个简单汇总～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632878204,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2518863,"avatar":"https://static001.geekbang.org/account/avatar/00/26/6f/4f/3cf1e9c4.jpg","nickname":"钱鹏 Allen","note":"","ucode":"7E95E82C0717DA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":398978,"discussion_content":"谢谢磊哥的指点，拿好小板凳，研读算子（三）~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632882557,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313826,"user_name":"神经蛙","can_delete":false,"product_type":"c1","uid":2223109,"ip_address":"","ucode":"09DC65B6E2EDD8","user_header":"https://static001.geekbang.org/account/avatar/00/21/ec/05/ce889d6c.jpg","comment_is_top":false,"comment_ctime":1632702262,"is_pvip":false,"replies":[{"id":"113766","content":"以前（计算模式、效率上）区别比较大，现在其实差别不大了。当然，实现上还是有些细微的差别。你说的对，就一轮mapreduce的话，两者效率上差不多的","user_name":"作者回复","user_name_real":"吴磊","uid":"1043100","ctime":1632831566,"ip_address":"","comment_id":313826,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1632702262","product_id":100090001,"comment_content":"大佬，看完觉得spark的shuffle跟mapreduce的shuffle像是一样的，两者有区别吗？两者主要区别是什么？<br>另外，如果一个MR job只有一个阶段的map和reduce而没有级联，处理效率应该和spark差不多吧？","like_count":0,"discussions":[{"author":{"id":1043100,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/9c/230061e7.jpg","nickname":"吴磊","note":"","ucode":"136DC8CF1B10DC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527484,"discussion_content":"以前（计算模式、效率上）区别比较大，现在其实差别不大了。当然，实现上还是有些细微的差别。你说的对，就一轮mapreduce的话，两者效率上差不多的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632831566,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3046392,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/ugib9sF9icd9dhibQoAA025hibbD5zgZTiaddLoeEH457hrkBBhtQK6qknTWt270rHCtBZqeqsbibtHghgjdkPx3DyIw/132","nickname":"唐方刚","note":"","ucode":"93DA58C3DCCF1B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585594,"discussion_content":"是啊，我也同感，都是先内存（环形缓冲），不够了就spill到磁盘，最后再merge，好像没什么区别","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661695122,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}