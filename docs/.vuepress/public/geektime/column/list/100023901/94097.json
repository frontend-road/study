{"id":94097,"title":"31 | Guarded Suspension模式：等待唤醒机制的规范实现","content":"<p>前不久，同事小灰工作中遇到一个问题，他开发了一个Web项目：Web版的文件浏览器，通过它用户可以在浏览器里查看服务器上的目录和文件。这个项目依赖运维部门提供的文件浏览服务，而这个文件浏览服务只支持消息队列（MQ）方式接入。消息队列在互联网大厂中用的非常多，主要用作流量削峰和系统解耦。在这种接入方式中，发送消息和消费结果这两个操作之间是异步的，你可以参考下面的示意图来理解。</p><p><img src=\"https://static001.geekbang.org/resource/image/d1/21/d1ad5ce1df66d85698308c41e4e93a21.png?wh=1142*393\" alt=\"\"></p><center><span class=\"reference\">消息队列（MQ）示意图</span></center><p>在小灰的这个Web项目中，用户通过浏览器发过来一个请求，会被转换成一个异步消息发送给MQ，等MQ返回结果后，再将这个结果返回至浏览器。小灰同学的问题是：给MQ发送消息的线程是处理Web请求的线程T1，但消费MQ结果的线程并不是线程T1，那线程T1如何等待MQ的返回结果呢？为了便于你理解这个场景，我将其代码化了，示例代码如下。</p><pre><code>class Message{\n  String id;\n  String content;\n}\n//该方法可以发送消息\nvoid send(Message msg){\n  //省略相关代码\n}\n//MQ消息返回后会调用该方法\n//该方法的执行线程不同于\n//发送消息的线程\nvoid onMessage(Message msg){\n  //省略相关代码\n}\n//处理浏览器发来的请求\nRespond handleWebReq(){\n  //创建一消息\n  Message msg1 = new \n    Message(&quot;1&quot;,&quot;{...}&quot;);\n  //发送消息\n  send(msg1);\n  //如何等待MQ返回的消息呢？\n  String result = ...;\n}\n</code></pre><p>看到这里，相信你一定有点似曾相识的感觉，这不就是前面我们在<a href=\"https://time.geekbang.org/column/article/88487\">《15 | Lock和Condition（下）：Dubbo如何用管程实现异步转同步？》</a>中曾介绍过的异步转同步问题吗？仔细分析，的确是这样，不过在那一篇文章中我们只是介绍了最终方案，让你知其然，但是并没有介绍这个方案是如何设计出来的，今天咱们再仔细聊聊这个问题，让你知其所以然，遇到类似问题也能自己设计出方案来。</p><!-- [[[read_end]]] --><h2>Guarded Suspension模式</h2><p>上面小灰遇到的问题，在现实世界里比比皆是，只是我们一不小心就忽略了。比如，项目组团建要外出聚餐，我们提前预订了一个包间，然后兴冲冲地奔过去，到那儿后大堂经理看了一眼包间，发现服务员正在收拾，就会告诉我们：“您预订的包间服务员正在收拾，请您稍等片刻。”过了一会，大堂经理发现包间已经收拾完了，于是马上带我们去包间就餐。</p><p>我们等待包间收拾完的这个过程和小灰遇到的等待MQ返回消息本质上是一样的，都是<strong>等待一个条件满足</strong>：就餐需要等待包间收拾完，小灰的程序里要等待MQ返回消息。</p><p>那我们来看看现实世界里是如何解决这类问题的呢？现实世界里大堂经理这个角色很重要，我们是否等待，完全是由他来协调的。通过类比，相信你也一定有思路了：我们的程序里，也需要这样一个大堂经理。的确是这样，那程序世界里的大堂经理该如何设计呢？其实设计方案前人早就搞定了，而且还将其总结成了一个设计模式：<strong>Guarded Suspension</strong>。所谓Guarded Suspension，直译过来就是“保护性地暂停”。那下面我们就来看看，Guarded Suspension模式是如何模拟大堂经理进行保护性地暂停的。</p><p>下图就是Guarded Suspension模式的结构图，非常简单，一个对象GuardedObject，内部有一个成员变量——受保护的对象，以及两个成员方法——<code>get(Predicate&lt;T&gt; p)</code>和<code>onChanged(T obj)</code>方法。其中，对象GuardedObject就是我们前面提到的大堂经理，受保护对象就是餐厅里面的包间；受保护对象的get()方法对应的是我们的就餐，就餐的前提条件是包间已经收拾好了，参数p就是用来描述这个前提条件的；受保护对象的onChanged()方法对应的是服务员把包间收拾好了，通过onChanged()方法可以fire一个事件，而这个事件往往能改变前提条件p的计算结果。下图中，左侧的绿色线程就是需要就餐的顾客，而右侧的蓝色线程就是收拾包间的服务员。</p><p><img src=\"https://static001.geekbang.org/resource/image/63/dc/630f3eda98a0e6a436953153c68464dc.png?wh=1142*503\" alt=\"\"></p><center><span class=\"reference\">Guarded Suspension模式结构图</span></center><p>GuardedObject的内部实现非常简单，是管程的一个经典用法，你可以参考下面的示例代码，核心是：get()方法通过条件变量的await()方法实现等待，onChanged()方法通过条件变量的signalAll()方法实现唤醒功能。逻辑还是很简单的，所以这里就不再详细介绍了。</p><pre><code>class GuardedObject&lt;T&gt;{\n  //受保护的对象\n  T obj;\n  final Lock lock = \n    new ReentrantLock();\n  final Condition done =\n    lock.newCondition();\n  final int timeout=1;\n  //获取受保护对象  \n  T get(Predicate&lt;T&gt; p) {\n    lock.lock();\n    try {\n      //MESA管程推荐写法\n      while(!p.test(obj)){\n        done.await(timeout, \n          TimeUnit.SECONDS);\n      }\n    }catch(InterruptedException e){\n      throw new RuntimeException(e);\n    }finally{\n      lock.unlock();\n    }\n    //返回非空的受保护对象\n    return obj;\n  }\n  //事件通知方法\n  void onChanged(T obj) {\n    lock.lock();\n    try {\n      this.obj = obj;\n      done.signalAll();\n    } finally {\n      lock.unlock();\n    }\n  }\n}\n</code></pre><h2>扩展Guarded Suspension模式</h2><p>上面我们介绍了Guarded Suspension模式及其实现，这个模式能够模拟现实世界里大堂经理的角色，那现在我们再来看看这个“大堂经理”能否解决小灰同学遇到的问题。</p><p>Guarded Suspension模式里GuardedObject有两个核心方法，一个是get()方法，一个是onChanged()方法。很显然，在处理Web请求的方法handleWebReq()中，可以调用GuardedObject的get()方法来实现等待；在MQ消息的消费方法onMessage()中，可以调用GuardedObject的onChanged()方法来实现唤醒。</p><pre><code>//处理浏览器发来的请求\nRespond handleWebReq(){\n  //创建一消息\n  Message msg1 = new \n    Message(&quot;1&quot;,&quot;{...}&quot;);\n  //发送消息\n  send(msg1);\n  //利用GuardedObject实现等待\n  GuardedObject&lt;Message&gt; go\n    =new GuardObjec&lt;&gt;();\n  Message r = go.get(\n    t-&gt;t != null);\n}\nvoid onMessage(Message msg){\n  //如何找到匹配的go？\n  GuardedObject&lt;Message&gt; go=???\n  go.onChanged(msg);\n}\n</code></pre><p>但是在实现的时候会遇到一个问题，handleWebReq()里面创建了GuardedObject对象的实例go，并调用其get()方等待结果，那在onMessage()方法中，如何才能够找到匹配的GuardedObject对象呢？这个过程类似服务员告诉大堂经理某某包间已经收拾好了，大堂经理如何根据包间找到就餐的人。现实世界里，大堂经理的头脑中，有包间和就餐人之间的关系图，所以服务员说完之后大堂经理立刻就能把就餐人找出来。</p><p>我们可以参考大堂经理识别就餐人的办法，来扩展一下Guarded Suspension模式，从而使它能够很方便地解决小灰同学的问题。在小灰的程序中，每个发送到MQ的消息，都有一个唯一性的属性id，所以我们可以维护一个MQ消息id和GuardedObject对象实例的关系，这个关系可以类比大堂经理大脑里维护的包间和就餐人的关系。</p><p>有了这个关系，我们来看看具体如何实现。下面的示例代码是扩展Guarded Suspension模式的实现，扩展后的GuardedObject内部维护了一个Map，其Key是MQ消息id，而Value是GuardedObject对象实例，同时增加了静态方法create()和fireEvent()；create()方法用来创建一个GuardedObject对象实例，并根据key值将其加入到Map中，而fireEvent()方法则是模拟的大堂经理根据包间找就餐人的逻辑。</p><pre><code>class GuardedObject&lt;T&gt;{\n  //受保护的对象\n  T obj;\n  final Lock lock = \n    new ReentrantLock();\n  final Condition done =\n    lock.newCondition();\n  final int timeout=2;\n  //保存所有GuardedObject\n  final static Map&lt;Object, GuardedObject&gt; \n  gos=new ConcurrentHashMap&lt;&gt;();\n  //静态方法创建GuardedObject\n  static &lt;K&gt; GuardedObject \n      create(K key){\n    GuardedObject go=new GuardedObject();\n    gos.put(key, go);\n    return go;\n  }\n  static &lt;K, T&gt; void \n      fireEvent(K key, T obj){\n    GuardedObject go=gos.remove(key);\n    if (go != null){\n      go.onChanged(obj);\n    }\n  }\n  //获取受保护对象  \n  T get(Predicate&lt;T&gt; p) {\n    lock.lock();\n    try {\n      //MESA管程推荐写法\n      while(!p.test(obj)){\n        done.await(timeout, \n          TimeUnit.SECONDS);\n      }\n    }catch(InterruptedException e){\n      throw new RuntimeException(e);\n    }finally{\n      lock.unlock();\n    }\n    //返回非空的受保护对象\n    return obj;\n  }\n  //事件通知方法\n  void onChanged(T obj) {\n    lock.lock();\n    try {\n      this.obj = obj;\n      done.signalAll();\n    } finally {\n      lock.unlock();\n    }\n  }\n}\n</code></pre><p>这样利用扩展后的GuardedObject来解决小灰同学的问题就很简单了，具体代码如下所示。</p><pre><code>//处理浏览器发来的请求\nRespond handleWebReq(){\n  int id=序号生成器.get();\n  //创建一消息\n  Message msg1 = new \n    Message(id,&quot;{...}&quot;);\n  //创建GuardedObject实例\n  GuardedObject&lt;Message&gt; go=\n    GuardedObject.create(id);  \n  //发送消息\n  send(msg1);\n  //等待MQ消息\n  Message r = go.get(\n    t-&gt;t != null);  \n}\nvoid onMessage(Message msg){\n  //唤醒等待的线程\n  GuardedObject.fireEvent(\n    msg.id, msg);\n}\n</code></pre><h2>总结</h2><p>Guarded Suspension模式本质上是一种等待唤醒机制的实现，只不过Guarded Suspension模式将其规范化了。规范化的好处是你无需重头思考如何实现，也无需担心实现程序的可理解性问题，同时也能避免一不小心写出个Bug来。但Guarded Suspension模式在解决实际问题的时候，往往还是需要扩展的，扩展的方式有很多，本篇文章就直接对GuardedObject的功能进行了增强，Dubbo中DefaultFuture这个类也是采用的这种方式，你可以对比着来看，相信对DefaultFuture的实现原理会理解得更透彻。当然，你也可以创建新的类来实现对Guarded Suspension模式的扩展。</p><p>Guarded Suspension模式也常被称作Guarded Wait模式、Spin Lock模式（因为使用了while循环去等待），这些名字都很形象，不过它还有一个更形象的非官方名字：多线程版本的if。单线程场景中，if语句是不需要等待的，因为在只有一个线程的条件下，如果这个线程被阻塞，那就没有其他活动线程了，这意味着if判断条件的结果也不会发生变化了。但是多线程场景中，等待就变得有意义了，这种场景下，if判断条件的结果是可能发生变化的。所以，用“多线程版本的if”来理解这个模式会更简单。</p><h2>课后思考</h2><p>有同学觉得用done.await()还要加锁，太啰嗦，还不如直接使用sleep()方法，下面是他的实现，你觉得他的写法正确吗？</p><pre><code>//获取受保护对象  \nT get(Predicate&lt;T&gt; p) {\n  try {\n    while(!p.test(obj)){\n      TimeUnit.SECONDS\n        .sleep(timeout);\n    }\n  }catch(InterruptedException e){\n    throw new RuntimeException(e);\n  }\n  //返回非空的受保护对象\n  return obj;\n}\n//事件通知方法\nvoid onChanged(T obj) {\n  this.obj = obj;\n}\n</code></pre><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p><p></p>","comments":[{"had_liked":false,"id":92883,"user_name":"青莲","can_delete":false,"product_type":"c1","uid":1181787,"ip_address":"","ucode":"6BA5D5D47DE38E","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/5b/2a342424.jpg","comment_is_top":false,"comment_ctime":1557361840,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"362334614704","product_id":100023901,"comment_content":"sleep 无法被唤醒，只能时间到后自己恢复运行，当真正的条件满足了，时间未到，接着睡眠，无性能可言","like_count":85},{"had_liked":false,"id":92949,"user_name":"一道阳光","can_delete":false,"product_type":"c1","uid":1239557,"ip_address":"","ucode":"F35207CCCEC6E2","user_header":"https://static001.geekbang.org/account/avatar/00/12/ea/05/c0d8014d.jpg","comment_is_top":false,"comment_ctime":1557367293,"is_pvip":false,"replies":[{"id":"33212","content":"👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1557412342,"ip_address":"","comment_id":92949,"utype":1}],"discussion_count":9,"race_medal":0,"score":"259255405053","product_id":100023901,"comment_content":"当从消息队列接收消息失败时，while循环会一直执行下去，永远不会结束，回占用大量资源。","like_count":59,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449435,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557412342,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1512642,"avatar":"https://static001.geekbang.org/account/avatar/00/17/14/c2/46ebe3a0.jpg","nickname":"侧耳倾听","note":"","ucode":"5BF2A2440B54F0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":243436,"discussion_content":"wait和sleep不都是一直循环下去吗？wait让出锁，sleep没加锁也不会占锁，他俩有啥区别？问题在于写这行代码，在消息队列不返回会死循环，跟用不用sleep有关系吗？线程一直得不到释放，对象不能被回收，随着时间的迁移，线程越来越多，一个问题是栈溢出，另一个问题是系统无法访问，第三个问题cpu使用率升高","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1587540614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1045090,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f2/62/f873cd8f.jpg","nickname":"tongmin_tsai","note":"","ucode":"D9423E770D5846","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1512642,"avatar":"https://static001.geekbang.org/account/avatar/00/17/14/c2/46ebe3a0.jpg","nickname":"侧耳倾听","note":"","ucode":"5BF2A2440B54F0","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":299752,"discussion_content":"我也有同样的疑问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597806975,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":243436,"ip_address":""},"score":299752,"extra":""},{"author":{"id":1441895,"avatar":"https://static001.geekbang.org/account/avatar/00/16/00/67/e24dd940.jpg","nickname":"那月真美","note":"","ucode":"CEF1AF65C6064E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1512642,"avatar":"https://static001.geekbang.org/account/avatar/00/17/14/c2/46ebe3a0.jpg","nickname":"侧耳倾听","note":"","ucode":"5BF2A2440B54F0","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":302502,"discussion_content":"wait是不会消耗线程资源的，sleep会","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598936526,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":243436,"ip_address":""},"score":302502,"extra":""}]},{"author":{"id":1174199,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ea/b7/1a18a39d.jpg","nickname":"5-刘新波(Arvin)","note":"","ucode":"DBD135D2587A93","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220200,"discussion_content":"可以在等待设置计数，避免死循环","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1585840300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1128491,"avatar":"https://static001.geekbang.org/account/avatar/00/11/38/2b/9db9406b.jpg","nickname":"星夜","note":"","ucode":"3B46C09D994CEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342546,"discussion_content":"sleep会占用线程而wait不会占用线程，他们两个都不会消耗CPU","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1610710875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2070984,"avatar":"","nickname":"dominiczhu","note":"","ucode":"9C87F77CCE06C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386140,"discussion_content":"那使用wait就不会出现这种情况么，假如任务失败了，管程实现方案不也会一直挂着么。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627439396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1241064,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ef/e8/076a6f59.jpg","nickname":"张翀","note":"","ucode":"835A01424FDD5E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":115950,"discussion_content":"什么意思，请教","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578047743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1335293,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKR3ibELhjgVicCNShZCBwvaDxibnzibggG4wUzVkS2mkDxUBZyIs87nDEdJ7PiahJBVoZcuhQ84RxAziag/132","nickname":"周治慧","note":"","ucode":"7D56C4E66BEE17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1241064,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ef/e8/076a6f59.jpg","nickname":"张翀","note":"","ucode":"835A01424FDD5E","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":162869,"discussion_content":"onMessage方法一直不会被调用(即接收消息失败),此时while循环的条件一直不满足","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581029817,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":115950,"ip_address":""},"score":162869,"extra":""}]}]},{"had_liked":false,"id":93854,"user_name":"Felix Envy","can_delete":false,"product_type":"c1","uid":1200085,"ip_address":"","ucode":"24E0F2165AD108","user_header":"https://static001.geekbang.org/account/avatar/00/12/4f/d5/e23dc965.jpg","comment_is_top":false,"comment_ctime":1557637710,"is_pvip":false,"replies":[{"id":"33668","content":"👍 需要，等待超时后要把他移除。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1557757453,"ip_address":"","comment_id":93854,"utype":1}],"discussion_count":2,"race_medal":0,"score":"194831166030","product_id":100023901,"comment_content":"老师，感觉如果有方法调用了GuardedObect.create方法但是没有任何其他线程调用fireEvent方法会造成内存泄漏啊，这种情况需要考虑吗？","like_count":45,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449797,"discussion_content":"👍 需要，等待超时后要把他移除。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557757453,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1172759,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e5/17/084dc246.jpg","nickname":"NLand","note":"","ucode":"07F7AE58EC68C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":556923,"discussion_content":"那移除以后是否也得跳出while循环了，毕竟guardobject对象都没了？而且这个移除判断条件是否是：obj==null&amp;&amp;已超时 ？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647573225,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":449797,"ip_address":""},"score":556923,"extra":""}]}]},{"had_liked":false,"id":95805,"user_name":"zhangwei","can_delete":false,"product_type":"c1","uid":1246639,"ip_address":"","ucode":"B71CBA5311846F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIvrwfqAuRkaK8Pl2apHKFZxd5mjnFhROMNcg5qXUT4AxE2ZTTia5Hg6pmFM1vozq3vZiagJoaJ4Pyg/132","comment_is_top":false,"comment_ctime":1558182141,"is_pvip":false,"replies":[{"id":"34272","content":"我了解有人是这么做的：把回执消息放到redis的list中，按照ip重新分组之后从redis中再次消费。<br>也可以按照ip建立不同的topic。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558185138,"ip_address":"","comment_id":95805,"utype":1}],"discussion_count":14,"race_medal":0,"score":"169061906685","product_id":100023901,"comment_content":"老师，我有个疑问，希望帮忙解答。如果Web应用是集群的，A节点处理HTTP请求后发了MQ，B节点的onMessage消费了回执消息，那么A节点怎么把结果响应给客户端呢？疑问好久了，希望老师给个思路，谢谢！","like_count":40,"discussions":[{"author":{"id":1335293,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKR3ibELhjgVicCNShZCBwvaDxibnzibggG4wUzVkS2mkDxUBZyIs87nDEdJ7PiahJBVoZcuhQ84RxAziag/132","nickname":"周治慧","note":"","ucode":"7D56C4E66BEE17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":162891,"discussion_content":"他说的意思是,AB两个节点是集群,A接收到客户端请求后,发送消息到mq,消费者消费消息,集群中接收到回复消息的为节点B不是集群中发送消息的节点A;相当于内存维护在A中不在B中,此时就需要A和B的内存数据共享比如redis或者mq","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1581035393,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1810156,"avatar":"","nickname":"poordickey","note":"","ucode":"2A436EC813AF97","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1335293,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKR3ibELhjgVicCNShZCBwvaDxibnzibggG4wUzVkS2mkDxUBZyIs87nDEdJ7PiahJBVoZcuhQ84RxAziag/132","nickname":"周治慧","note":"","ucode":"7D56C4E66BEE17","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339166,"discussion_content":"redis内存方案咋解决  看不懂了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609533394,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":162891,"ip_address":""},"score":339166,"extra":""},{"author":{"id":1261360,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3f/30/23f6b413.jpg","nickname":"五十九秒","note":"","ucode":"1F34F62193CFF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1810156,"avatar":"","nickname":"poordickey","note":"","ucode":"2A436EC813AF97","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368809,"discussion_content":"使用redis消息处理完成后，根据机器ip把相应的机器的消息放到这个ip下，每台机器消费时从redis中取属于自己的消息，或者不同的机器建立不同的topic。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618837443,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":339166,"ip_address":""},"score":368809,"extra":""},{"author":{"id":1367043,"avatar":"https://static001.geekbang.org/account/avatar/00/14/dc/03/ad9574b3.jpg","nickname":"习兮习兮","note":"","ucode":"E616E924188CBA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1810156,"avatar":"","nickname":"poordickey","note":"","ucode":"2A436EC813AF97","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380487,"discussion_content":"就是通过双向MQ, 或者集群共享缓存的方法, 通过一定的染色确定接收和响应backend为同一节点; ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624525229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":339166,"ip_address":""},"score":380487,"extra":""}]},{"author":{"id":1400703,"avatar":"https://static001.geekbang.org/account/avatar/00/15/5f/7f/3d005d61.jpg","nickname":"Tyrone","note":"","ucode":"DA6F289438A750","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219689,"discussion_content":"这就是本地缓存与分布式缓存的不同场景使用呗。你单机用本地缓存就满足了，集群环境下你就用分布式缓存呗比如redis...这就好比登录。难道说你在A节点登录了，在B节点上再重新登录一次？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1585795800,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450604,"discussion_content":"我了解有人是这么做的：把回执消息放到redis的list中，按照ip重新分组之后从redis中再次消费。\n也可以按照ip建立不同的topic。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1558185138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1246639,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIvrwfqAuRkaK8Pl2apHKFZxd5mjnFhROMNcg5qXUT4AxE2ZTTia5Hg6pmFM1vozq3vZiagJoaJ4Pyg/132","nickname":"zhangwei","note":"","ucode":"B71CBA5311846F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311837,"discussion_content":"最近用rocketmq可以解决这个问题，消费模式选择BRODCASTING，ConsumerGroup的每个节点都可以消费。副作用是只有一个消费节点有效，其他节点都空跑了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602499544,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1810156,"avatar":"","nickname":"poordickey","note":"","ucode":"2A436EC813AF97","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1246639,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIvrwfqAuRkaK8Pl2apHKFZxd5mjnFhROMNcg5qXUT4AxE2ZTTia5Hg6pmFM1vozq3vZiagJoaJ4Pyg/132","nickname":"zhangwei","note":"","ucode":"B71CBA5311846F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339164,"discussion_content":"我看懂了你的方法   但作者的方法没看懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609533156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":311837,"ip_address":""},"score":339164,"extra":""}]},{"author":{"id":1400703,"avatar":"https://static001.geekbang.org/account/avatar/00/15/5f/7f/3d005d61.jpg","nickname":"Tyrone","note":"","ucode":"DA6F289438A750","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219695,"discussion_content":"感觉只要实现一个像nginx的定向转发的就行。或者直接就是广播，所有节点都能收的到。但是给每个节点取个名，只有某个节点发的。就只能某个节点消费。感觉就可以了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585796276,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1810156,"avatar":"","nickname":"poordickey","note":"","ucode":"2A436EC813AF97","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1400703,"avatar":"https://static001.geekbang.org/account/avatar/00/15/5f/7f/3d005d61.jpg","nickname":"Tyrone","note":"","ucode":"DA6F289438A750","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339165,"discussion_content":"msg里把host信息加上  广播模式很快就能过滤掉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609533288,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":219695,"ip_address":""},"score":339165,"extra":""}]},{"author":{"id":1528931,"avatar":"https://static001.geekbang.org/account/avatar/00/17/54/63/3a3f7d4c.jpg","nickname":"Giraffe","note":"","ucode":"2F272FFD6CD0CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553107,"discussion_content":"为什么要用MQ，同步调用用RPC不好吗，MQ更适合异步的场景","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645714689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2143675,"avatar":"","nickname":"Geek_9101a0","note":"","ucode":"55DED90E052AB2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302054,"discussion_content":"这不是集群吧，顶多是个负载均衡","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598774497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1234281,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d5/69/d1f2f7c8.jpg","nickname":"罗洪州 IT","note":"","ucode":"3688313E7D010A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2298,"discussion_content":"A节点请求MQ应该不会响应到B节点，用什么做的集群？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563441608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93272,"user_name":"Mr.Brooks","can_delete":false,"product_type":"c1","uid":1118650,"ip_address":"","ucode":"D47A6B0236A79F","user_header":"https://static001.geekbang.org/account/avatar/00/11/11/ba/2175bc50.jpg","comment_is_top":false,"comment_ctime":1557449026,"is_pvip":true,"replies":[{"id":"33677","content":"👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1557758075,"ip_address":"","comment_id":93272,"utype":1}],"discussion_count":2,"race_medal":0,"score":"108931631426","product_id":100023901,"comment_content":"没有锁也无法保证内存可见性吧","like_count":25,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449554,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557758075,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1199213,"avatar":"https://static001.geekbang.org/account/avatar/00/12/4c/6d/c20f2d5a.jpg","nickname":"LJK","note":"","ucode":"12B2441099FF1D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332425,"discussion_content":"这里用的是可重入锁，用普通锁会有什么问题吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607207709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97812,"user_name":"linqw","can_delete":false,"product_type":"c1","uid":1134138,"ip_address":"","ucode":"09DCFE98C54DD8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","comment_is_top":false,"comment_ctime":1558782810,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"65983292250","product_id":100023901,"comment_content":"总结：Guarded Suspension模式，要解决的是，发送消息的线程和消费消息结果的线程不是同一个，但是消息结果又需要由发送的线程进行处理，为此需要为每个消息创建出类似大堂经理，生活中一般是只有一个大堂经理，但是在编程世界里需要为每个分配一个大堂经理，大堂经理主要做的事情就是发送线程发送完消息时，将其阻塞，提供消息结果的回调接口，通知阻塞的发送线程消费消息结果。<br>课后习题：1、使用sleep如果消息结果已经返回，还需等到sleep超时，才能继续执行2、使用加锁的await方法可以保证可见性，如果使用sleep的话，需要给obj加上volatile3、感觉在sent（message）成功后才阻塞，不然有可能mq接收消息失败，while循环会一直执行下去，sent失败，直接响应提示给前端。<br>","like_count":15},{"had_liked":false,"id":201173,"user_name":"朵朵集团总裁","can_delete":false,"product_type":"c1","uid":1338806,"ip_address":"","ucode":"871ACA41655401","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Dh6hib6KsQDsucBZztpyAp6hEhb4j2aJrLdsYnH1Ll6D0yaTuYPpYj1vmwWN97lfxsH6V8CZp8nCXdIejffslVg/132","comment_is_top":false,"comment_ctime":1585727902,"is_pvip":false,"replies":[{"id":"75458","content":"总裁您说的对👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1585872995,"ip_address":"","comment_id":201173,"utype":1}],"discussion_count":1,"race_medal":0,"score":"44535400862","product_id":100023901,"comment_content":"如果mq服务挂了无法消费，会引起web请求服务很多线程出于等待状态，是不是应该whlie循环加上超时。","like_count":10,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490258,"discussion_content":"总裁您说的对👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585872995,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93289,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1557450242,"is_pvip":false,"replies":[{"id":"33509","content":"这个回调函数和mq的回调函数从服务接入方的角度看是一样的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1557644086,"ip_address":"","comment_id":93289,"utype":1}],"discussion_count":1,"race_medal":0,"score":"40212155906","product_id":100023901,"comment_content":"接入微信支付支付宝支付里边，也需要提供一个回调函数，onChange()就是一个回调函数吧，不过微信支付宝支付是异步回调，是不是也可以改成这种？微信支付宝里边的其它第三方支付是不是就是这种模式，因为支付成功之后跳转到它们自己的页面，而不是微信支付宝官方的支付成功界面","like_count":9,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449565,"discussion_content":"这个回调函数和mq的回调函数从服务接入方的角度看是一样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557644086,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92941,"user_name":"君哥聊技术","can_delete":false,"product_type":"c1","uid":1325816,"ip_address":"","ucode":"2C9A22BCE4C79E","user_header":"https://static001.geekbang.org/account/avatar/00/14/3a/f8/c1a939e7.jpg","comment_is_top":false,"comment_ctime":1557365932,"is_pvip":false,"replies":[{"id":"33208","content":"await和notify获取锁才能调用，所以不能去掉锁","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1557411839,"ip_address":"","comment_id":92941,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31622137004","product_id":100023901,"comment_content":"如果以文中的最后一段示例代码来看，每一个请求生成一个id，对应一个GuardedObject，并没有线程安全问题。我觉得可以去掉锁。<br>但是加sleep的话，没有办法唤醒，只能等到超时。","like_count":7,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449432,"discussion_content":"await和notify获取锁才能调用，所以不能去掉锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557411839,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92863,"user_name":"zero","can_delete":false,"product_type":"c1","uid":1299615,"ip_address":"","ucode":"528DD5C8399AEC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKlwpFM3tkeG15YqyJTYWkfqkdmro9POq6SicYm57TaEFDOUZCXjoe0Z0Iz6UibGQqic3icJRsHdFzibtw/132","comment_is_top":false,"comment_ctime":1557358832,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"31622129904","product_id":100023901,"comment_content":"wait会释放占有的资源，sleep不会释放","like_count":7},{"had_liked":false,"id":131442,"user_name":"庄墨寒","can_delete":false,"product_type":"c1","uid":1063970,"ip_address":"","ucode":"BBD9EFA891BF06","user_header":"https://static001.geekbang.org/account/avatar/00/10/3c/22/9024c062.jpg","comment_is_top":false,"comment_ctime":1567753638,"is_pvip":false,"replies":[{"id":"49891","content":"这是个真实的例子，集群中有两台机器，a-&gt;b有一个参数topic，b-&gt;a的时候根据传入的topic参数来确定写入哪个topic的，两台机器的topic参数不同，所以发送和接收是能对应上的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1567780919,"ip_address":"","comment_id":131442,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23042590118","product_id":100023901,"comment_content":"老师, 我觉得您只是举个例子吧. 真实的生成环境, A和B肯定都是一个集群; A 给 B发一个消息. B处理完后再给A发一个消息,  在A 集群中发送和接收消息的大概率两台不同的机器. 解决这个问题两种办法: 1. web 请求长轮询; 2. A集群有分布式的缓存, A的某台机器处理消息后把结果写到缓存, 处理web请求的机器有专门的线程去轮询. ","like_count":5,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466455,"discussion_content":"这是个真实的例子，集群中有两台机器，a-&amp;gt;b有一个参数topic，b-&amp;gt;a的时候根据传入的topic参数来确定写入哪个topic的，两台机器的topic参数不同，所以发送和接收是能对应上的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567780919,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176936,"user_name":"Chuan","can_delete":false,"product_type":"c1","uid":1438352,"ip_address":"","ucode":"FACEC5DAC36A7A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI4akcIyIOXB2OqibTe7FF90hwsBicxkjdicUNTMorGeIictdr3OoMxhc20yznmZWwAvQVThKPFWgOyMw/132","comment_is_top":false,"comment_ctime":1581231479,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18761100663","product_id":100023901,"comment_content":"这里有一个区别就是每次都创建了一个GuardedObject，相当于创建了多个大堂经理，这里和现实中有点不一样。目的是，如果使用一个GuardedObject，在singalAll时，可能会导致线程2的回执结果被线程1消费，即锁冲突。所以这里每次都创建不同的GuardedObject，其内部的锁也不同，在唤醒的时候就不会出错了。","like_count":4,"discussions":[{"author":{"id":1418179,"avatar":"https://static001.geekbang.org/account/avatar/00/15/a3/c3/91aa0e32.jpg","nickname":"迁","note":"","ucode":"ECB1DC885B25D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383016,"discussion_content":"   // 这个是大堂经理  他是  static的 只有一个\n    final static Map<Object, GuardedObject> gos=new ConcurrentHashMap<>();","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625823709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137293,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1569678630,"is_pvip":true,"replies":[{"id":"52753","content":"wait是管程里的操作，sleep就是一个系统api，他们其实没关系，所以sleep不会释放管程的锁，他们没关系","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1569683230,"ip_address":"","comment_id":137293,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18749547814","product_id":100023901,"comment_content":"问题的原因主要是sleep没办法提供等待-唤醒机制，也就是说极端情况下可能会一直处于睡眠状态。<br>老师，有个问题，为什么sleep不能被唤醒啊？网上查了下答案，好像是说wait会持有一个对象锁(JVM)提供的，然后在执行notify操作的时候，JVM会释放这个对象锁，并选择一个等待的线程执行。而sleep并没有释放这个锁，所以没办法唤醒？感觉有点道理，但是不知道对不对，望老师不吝赐教","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469022,"discussion_content":"wait是管程里的操作，sleep就是一个系统api，他们其实没关系，所以sleep不会释放管程的锁，他们没关系","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569683230,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1818343,"avatar":"","nickname":"刘同青","note":"","ucode":"84B62DF8BC61FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281626,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591780123,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136046,"user_name":"飞翔","can_delete":false,"product_type":"c1","uid":1068571,"ip_address":"","ucode":"65AF6AF292DAD6","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/1b/f4b786b9.jpg","comment_is_top":false,"comment_ctime":1569335391,"is_pvip":true,"replies":[{"id":"52559","content":"是的👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1569582219,"ip_address":"","comment_id":136046,"utype":1}],"discussion_count":3,"race_medal":0,"score":"18749204575","product_id":100023901,"comment_content":"老师 future.get 就是guarded suspension 的应用吧","like_count":5,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468431,"discussion_content":"是的👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569582219,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134574,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4f/ee/bd08cfab.jpg","nickname":"一魄","note":"","ucode":"71541125D4AA5A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392516,"discussion_content":"没少看源码啊兄台","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1631025547,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1818343,"avatar":"","nickname":"刘同青","note":"","ucode":"84B62DF8BC61FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281625,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591780109,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128009,"user_name":"Ab","can_delete":false,"product_type":"c1","uid":1039466,"ip_address":"","ucode":"8E9261782F025D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/dc/6a/b5478b65.jpg","comment_is_top":false,"comment_ctime":1566820210,"is_pvip":false,"replies":[{"id":"48643","content":"每个请求都会创建一个GuardedObject，get和onChanged不是在一个线程里执行的，也不在一个对象里","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1567428554,"ip_address":"","comment_id":128009,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18746689394","product_id":100023901,"comment_content":"老师， 有一个地方不太理解，扩展 Guarded Suspension 模式 这一节第一个例子，get和onChange方法应该是在同一个GuardedObject上调用的吧，为啥还有维护一个Map来存储msgId和GuardedObject之间的关系呢？","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464751,"discussion_content":"每个请求都会创建一个GuardedObject，get和onChanged不是在一个线程里执行的，也不在一个对象里","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567428554,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018240,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/89/80/3666ced3.jpg","nickname":"黄浩特","note":"","ucode":"C3A4BBF4FB8519","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":35357,"discussion_content":"调用 onChange 方法的线程必须通过 fireEvent 方法调用 onChanged。这里onChanged 应该可以是私有的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571272715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146008,"user_name":"ipofss","can_delete":false,"product_type":"c1","uid":1018620,"ip_address":"","ucode":"DE3061C9259F9E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/fc/d1dd57dd.jpg","comment_is_top":false,"comment_ctime":1572417918,"is_pvip":false,"replies":[{"id":"56355","content":"wait会释放锁，建议重看第一部分管程相关的内容","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1572428748,"ip_address":"","comment_id":146008,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14457319806","product_id":100023901,"comment_content":"老师，这节听了个大概，不是非常懂。其中有一点没理解，get方法加锁后，while判断一直都为true，也就一直不会释放锁，那onChanged方法进去之后，获取不到锁，双方不久互相死等下去了么，我应该还是哪里没想明白","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472667,"discussion_content":"wait会释放锁，建议重看第一部分管程相关的内容","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572428748,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":269984,"user_name":"Geek_110f21","can_delete":false,"product_type":"c1","uid":2355391,"ip_address":"","ucode":"67495EAEAF5D61","user_header":"","comment_is_top":false,"comment_ctime":1608867360,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10198801952","product_id":100023901,"comment_content":"sleep两个问题，一个是实效性不及等待唤醒，第二是obj变量要加volatile保证可见性","like_count":3},{"had_liked":false,"id":230007,"user_name":"zapup","can_delete":false,"product_type":"c1","uid":1397351,"ip_address":"","ucode":"388D6BB5D7B137","user_header":"https://static001.geekbang.org/account/avatar/00/15/52/67/fcba0967.jpg","comment_is_top":false,"comment_ctime":1593240617,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10183175209","product_id":100023901,"comment_content":"go 像是 msg 的专属私人经理。<br>1. 拿着 id（预约的房号） 来，由大堂总部 GuardedObject 派一位私人经理 go 专门负责（static create()），并记录在册（gos）；<br>2. 如果你提前问你的私人经理「好了吗」（go.get()），他会先 hold 住你，并等待总部喊话；<br>3. 后勤部打扫好卫生之后，不会直接与某个私人经理（go）说，而是直接告诉大堂总部哪间房（id）已经好了（static fireEvent(id)）；<br>4. 大堂总部在小册子（gos）中找到负责此房间（id）的私人经理（go），并通知他「房间好了」（go.onChanged(obj)）；<br>5. 私人经理把被 hold 住的你唤醒（signAll）","like_count":2},{"had_liked":false,"id":100313,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1559526789,"is_pvip":false,"replies":[{"id":"36128","content":"只要唤醒的时候能找到正确的线程就可以，不知道你的方法是不是能做到","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1559541121,"ip_address":"","comment_id":100313,"utype":1}],"discussion_count":4,"race_medal":0,"score":"10149461381","product_id":100023901,"comment_content":"老师，您好！<br>我想到了一个场景：​线程 t1 提交了消息 m1，线程 t2 提交了消息 m2，此时都在 get() 方法处等待结果返回。m2 先被处理完，this.obj 对应的是消息 m2 的结果，调用 fireEvent() 唤醒 t1 和 t2，t1 竞争到锁资源，消费了 m2 的结果 this.obj。<br><br>如果存在这种场景，再维护一个 ConcurrentHashMap，key 是 msg.id，value 是对应的 obj，是否就能解决结果这问题？<br><br>谢谢老师！","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452496,"discussion_content":"只要唤醒的时候能找到正确的线程就可以，不知道你的方法是不是能做到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559541121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1095445,"avatar":"https://static001.geekbang.org/account/avatar/00/10/b7/15/6a2b6b83.jpg","nickname":"董宗磊","note":"","ucode":"D7005A328BC2EE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3006,"discussion_content":"我理解m1、m2会对应两个不同的GuardedObject对象的，每个对象内部都是单独的Lock，fireEvent方法只会唤醒各自的线程","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1564107507,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1335293,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKR3ibELhjgVicCNShZCBwvaDxibnzibggG4wUzVkS2mkDxUBZyIs87nDEdJ7PiahJBVoZcuhQ84RxAziag/132","nickname":"周治慧","note":"","ucode":"7D56C4E66BEE17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":162893,"discussion_content":"两个不同的GuardedObject对象维护的是不同的lock和condition,不存在锁的冲突问题","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581035670,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1896587,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/f0/8b/e307f616.jpg","nickname":"沐浴露🧴","note":"","ucode":"CFAFDE6450BC2F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263234,"discussion_content":"只有static 修饰的成员变量 new出来的对象才会共享","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589190954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92965,"user_name":"晓杰","can_delete":false,"product_type":"c1","uid":1441546,"ip_address":"","ucode":"1174C88EEBF8A6","user_header":"https://static001.geekbang.org/account/avatar/00/15/ff/0a/12faa44e.jpg","comment_is_top":false,"comment_ctime":1557369461,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10147304053","product_id":100023901,"comment_content":"用sleep的话只能等睡眠时间到了之后再返回while循环条件去判断，但是wait相当于和singal组成等待唤醒的机制，这样满足条件的概率更大一些，性能也更好","like_count":2},{"had_liked":false,"id":268403,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1608177871,"is_pvip":false,"replies":[{"id":"97469","content":"学以致用啊������������","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1608249578,"ip_address":"","comment_id":268403,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5903145167","product_id":100023901,"comment_content":"guarded suspension模式解决了我工作中的一个问题<br>client同步掉我的服务a，服务a处理并需要等待一个定时任务的执行结果，","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511935,"discussion_content":"学以致用啊������������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608249578,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155799,"user_name":"石头🍊","can_delete":false,"product_type":"c1","uid":1550500,"ip_address":"","ucode":"D68673430450B8","user_header":"https://static001.geekbang.org/account/avatar/00/17/a8/a4/ea898a39.jpg","comment_is_top":false,"comment_ctime":1574758363,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869725659","product_id":100023901,"comment_content":"使用LockSupport配合map是不是也可以实现","like_count":1},{"had_liked":false,"id":155011,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1574617092,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5869584388","product_id":100023901,"comment_content":"sleep 不是释放锁","like_count":1,"discussions":[{"author":{"id":1644104,"avatar":"https://static001.geekbang.org/account/avatar/00/19/16/48/09493874.jpg","nickname":"茶没喝完","note":"","ucode":"D72D88C42A1258","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271851,"discussion_content":"sleep不改变锁状态：sleep之前获取了锁，不会释放锁；之前没有获取锁，也不会获取锁。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590205045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":149374,"user_name":"Joker","can_delete":false,"product_type":"c1","uid":1156592,"ip_address":"","ucode":"126AF848001A1E","user_header":"https://static001.geekbang.org/account/avatar/00/11/a5/f0/8648c464.jpg","comment_is_top":false,"comment_ctime":1573203914,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5868171210","product_id":100023901,"comment_content":"如果按照代码上面来看，这还是一个客户对应一个大堂经理了呗。。每次还要换新的大堂经理的感觉。","like_count":1},{"had_liked":false,"id":110536,"user_name":"杨鹏程baci","can_delete":false,"product_type":"c1","uid":1205949,"ip_address":"","ucode":"3D22F6B74340A8","user_header":"https://static001.geekbang.org/account/avatar/00/12/66/bd/bd5d503e.jpg","comment_is_top":false,"comment_ctime":1562291311,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5857258607","product_id":100023901,"comment_content":"老师好，Message r = get(t-&gt;t != null); 这个地方里面的t是什么参数啊，有点看的不是很懂，然后在get方法里面!p.test(obj)里面是判断了啥，就这里有点看的不是很明白，谢谢！","like_count":1,"discussions":[{"author":{"id":1583588,"avatar":"https://static001.geekbang.org/account/avatar/00/18/29/e4/ade74d94.jpg","nickname":"hejun","note":"","ucode":"DCF01B4159178F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217499,"discussion_content":"Predicate是一个接口，里面只有一个抽象方法test。“t->t != null”就是重写这个抽象方法。“!p.test(obj)”表明test的入参 t=obj，判断了 obj != null。 ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585565680,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1644104,"avatar":"https://static001.geekbang.org/account/avatar/00/19/16/48/09493874.jpg","nickname":"茶没喝完","note":"","ucode":"D72D88C42A1258","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271852,"discussion_content":"java8的FunctionInterface","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590205153,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1061748,"avatar":"https://static001.geekbang.org/account/avatar/00/10/33/74/d9d143fa.jpg","nickname":"silentyears","note":"","ucode":"6E137BFEB874CA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":123293,"discussion_content":"test 就是 t ！= null","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578399300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104504,"user_name":"王盛武","can_delete":false,"product_type":"c1","uid":1182516,"ip_address":"","ucode":"DE7EF246D3DCE8","user_header":"https://static001.geekbang.org/account/avatar/00/12/0b/34/f41d73a4.jpg","comment_is_top":false,"comment_ctime":1560768862,"is_pvip":false,"replies":[{"id":"38347","content":"最佳实践不一定是最优方案，但是能防止出错","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1561161196,"ip_address":"","comment_id":104504,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5855736158","product_id":100023901,"comment_content":"王老师，请问这里lock是实例私有对象，为什么不用 lock.signal？  感觉文案里的代码不需要signalall函数，因为这个lock是每次都new出来的，线程等待队列里永远只有一个线程，所以signalall意义不大","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454298,"discussion_content":"最佳实践不一定是最优方案，但是能防止出错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561161196,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1450758,"avatar":"https://static001.geekbang.org/account/avatar/00/16/23/06/47bb92bc.jpg","nickname":"Tyrion","note":"","ucode":"3F8C57F7F60DBE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2168,"discussion_content":"我觉得西滋滋说的对！虽然老师说的是最优实践，但是也得看场景吧。如果能够确定每次都是new的新对象，那用singal也是很好（而且假如singal比singalAll性能更好的话，那是不是效果更好呢）。当然老师说的问题也是对的，写成最优实践，主要是为了防止异常发生吧，比如本来应该是每次new一个对象的，结果某个地方没有new，而重复用了之前new的对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563326656,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96852,"user_name":"Rancood","can_delete":false,"product_type":"c1","uid":1204333,"ip_address":"","ucode":"052BDF2221F480","user_header":"https://static001.geekbang.org/account/avatar/00/12/60/6d/e2576fda.jpg","comment_is_top":false,"comment_ctime":1558521327,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5853488623","product_id":100023901,"comment_content":"这个模式了解了，但是实例中业务有点懵，handleWebReq方法最终拿到的是自己发送出去的message消息；是不是应该在onMessage方法唤醒等待线程之前进行业务处理，生成新的Message消息newMsg，然后把newMsg传到fireEvent里面，这样拿到的是反馈的结果。请老师指点一下","like_count":1,"discussions":[{"author":{"id":1018240,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/89/80/3666ced3.jpg","nickname":"黄浩特","note":"","ucode":"C3A4BBF4FB8519","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":35341,"discussion_content":"实际业务分为客户端和服务端，老师的代码是客户端的. 客户端发送消息后等待唤醒，服务端接收消息进行业务处理，将结果发送回客户端，客户端接收到结果消息，调用fireEvent 唤醒对应的等待线程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571272069,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94706,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1557883948,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5852851244","product_id":100023901,"comment_content":"额 我看有个同学说 可见性也无法保证。<br><br>锁是保证可见性的嘛？ 我记得锁是保证原子性的哇， 可见性不是volatile变量来保证的嘛？ ","like_count":1},{"had_liked":false,"id":93667,"user_name":"cricket1981","can_delete":false,"product_type":"c1","uid":1001715,"ip_address":"","ucode":"758262F5958DA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/f3/f1034ffd.jpg","comment_is_top":false,"comment_ctime":1557554981,"is_pvip":false,"replies":[{"id":"33500","content":"思路不同，不过结果是一样的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1557642626,"ip_address":"","comment_id":93667,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5852522277","product_id":100023901,"comment_content":"项目中我使用了Map&lt;key, CountdownLatch&gt;来处理异步转同步调用，异步等待时通过countdownLatch.await(timeout)设置超时时长，请问老师这跟你讲的lock nitifyAll管程方法是否类似？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449722,"discussion_content":"思路不同，不过结果是一样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557642626,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1670763,"avatar":"https://static001.geekbang.org/account/avatar/00/19/7e/6b/36fc4516.jpg","nickname":"FIRE","note":"","ucode":"85861D990FB3AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326716,"discussion_content":"高,核心就是线程的wait/notify","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605666722,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93147,"user_name":"橘子","can_delete":false,"product_type":"c1","uid":1368522,"ip_address":"","ucode":"EDF6145878F897","user_header":"https://static001.geekbang.org/account/avatar/00/14/e1/ca/d8b0835f.jpg","comment_is_top":false,"comment_ctime":1557407918,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5852375214","product_id":100023901,"comment_content":"这让我想到了之前很火的sleep排序算法，哈哈","like_count":1},{"had_liked":false,"id":92935,"user_name":"锦","can_delete":false,"product_type":"c1","uid":1468298,"ip_address":"","ucode":"CB0EB4B68C468B","user_header":"https://static001.geekbang.org/account/avatar/00/16/67/8a/babd74dc.jpg","comment_is_top":false,"comment_ctime":1557365446,"is_pvip":false,"replies":[{"id":"53899","content":"我喜欢自己找座😂","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1570709612,"ip_address":"","comment_id":92935,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5852332742","product_id":100023901,"comment_content":"<br><br>老师，问个细节问题：就餐人与餐桌的关系不是在大堂经理脑中吗？怎么写在就餐人的内部呢？是因为GuardedObject的类本身充当的大堂经理角色，类实例充当就餐人角色吗？<br>如果是这样的话，那大堂经理是唯一的吗？<br><br>回答问题：改成sleep不加锁就变成线程不安全的忙等待模式，应该不符合需求。","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449430,"discussion_content":"我喜欢自己找座😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570709612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":353026,"user_name":"键盘上的魔术","can_delete":false,"product_type":"c1","uid":2697700,"ip_address":"北京","ucode":"A731D721FB8D3A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/LFJZ4x47rvShGhsePLIxc8EzdlBxAmVAIjJ2FQZ4NEpo8E4JCZQEOb2NIfOuiaQLL6Otkt7W3Rmu6Tv3AkgYdRA/132","comment_is_top":false,"comment_ctime":1659081476,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1659081476","product_id":100023901,"comment_content":"锁+wait+notify是管程模型范式。 sleep没有这种用法。其实单从页面角度说， 如果用 sleep的话到底睡多少秒合适呢？  就知道用sleep不合理了","like_count":0},{"had_liked":false,"id":346196,"user_name":"学习学个屁","can_delete":false,"product_type":"c1","uid":1049017,"ip_address":"","ucode":"DF2D61E6FB2FCE","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","comment_is_top":false,"comment_ctime":1652886078,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652886078","product_id":100023901,"comment_content":"sleep 不能被唤醒，而且也占用资源。","like_count":0},{"had_liked":false,"id":343971,"user_name":"佐佐真君","can_delete":false,"product_type":"c1","uid":2761438,"ip_address":"","ucode":"CE6E1A08C30DB1","user_header":"https://static001.geekbang.org/account/avatar/00/2a/22/de/1351551d.jpg","comment_is_top":false,"comment_ctime":1651150026,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1651150026","product_id":100023901,"comment_content":"老师，我觉得这节课您举得例子不太合适。<br>一般来说服务调用方、MQ和服务提供方是分布在不同的进程里的。<br>而您的实现是针对一个进程里的不同线程来说的。<br>","like_count":0},{"had_liked":false,"id":329942,"user_name":"我 我 我","can_delete":false,"product_type":"c1","uid":1180597,"ip_address":"","ucode":"DB9BC7110A7B3F","user_header":"https://static001.geekbang.org/account/avatar/00/12/03/b5/cf6a5f97.jpg","comment_is_top":false,"comment_ctime":1641665149,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641665149","product_id":100023901,"comment_content":"这儿使用锁， 是因为消息是异步的， 存在资源竞争的问题。","like_count":0},{"had_liked":false,"id":324253,"user_name":"大明猩","can_delete":false,"product_type":"c1","uid":1494622,"ip_address":"","ucode":"61D330B42AE3C4","user_header":"https://static001.geekbang.org/account/avatar/00/16/ce/5e/b103d538.jpg","comment_is_top":false,"comment_ctime":1638349287,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1638349287","product_id":100023901,"comment_content":"看了好几遍，我咋没感觉到这个模式的牛逼之处呢，大致思想是浏览器请求都发过来，然后哪儿个请求得到结果就给他返回<br>","like_count":0},{"had_liked":false,"id":266148,"user_name":"LJK","can_delete":false,"product_type":"c1","uid":1199213,"ip_address":"","ucode":"12B2441099FF1D","user_header":"https://static001.geekbang.org/account/avatar/00/12/4c/6d/c20f2d5a.jpg","comment_is_top":false,"comment_ctime":1607207641,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607207641","product_id":100023901,"comment_content":"有个问题，get和onChange方法中为什么要用RLock? 用普通的Lock可以吗？","like_count":0},{"had_liked":false,"id":260666,"user_name":"xzy","can_delete":false,"product_type":"c1","uid":1002095,"ip_address":"","ucode":"1A44368083A19E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/6f/e36b3908.jpg","comment_is_top":false,"comment_ctime":1605080597,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605080597","product_id":100023901,"comment_content":"类比，加代码讲解，老师这种讲法，很赞！","like_count":0},{"had_liked":false,"id":233865,"user_name":"delete is create","can_delete":false,"product_type":"c1","uid":1147979,"ip_address":"","ucode":"A8C751219A7746","user_header":"https://static001.geekbang.org/account/avatar/00/11/84/4b/e4738ba8.jpg","comment_is_top":false,"comment_ctime":1594482675,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1594482675","product_id":100023901,"comment_content":"单机可以的  但是集群下这种模式就失效了 <br> ","like_count":0,"discussions":[{"author":{"id":2697700,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/LFJZ4x47rvShGhsePLIxc8EzdlBxAmVAIjJ2FQZ4NEpo8E4JCZQEOb2NIfOuiaQLL6Otkt7W3Rmu6Tv3AkgYdRA/132","nickname":"键盘上的魔术","note":"","ucode":"A731D721FB8D3A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581940,"discussion_content":"集群把内存map改成redis就好了，思想是一样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659079057,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":195625,"user_name":"Mr.wang","can_delete":false,"product_type":"c1","uid":1224805,"ip_address":"","ucode":"86F341A5316BBC","user_header":"https://static001.geekbang.org/account/avatar/00/12/b0/65/90387745.jpg","comment_is_top":false,"comment_ctime":1585206399,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1585206399","product_id":100023901,"comment_content":"不行，使用sleep不会释放线程，相当于占用线程等待，会造成内存溢出。","like_count":0},{"had_liked":false,"id":193612,"user_name":"james","can_delete":false,"product_type":"c1","uid":1049208,"ip_address":"","ucode":"5701899403917C","user_header":"https://static001.geekbang.org/account/avatar/00/10/02/78/23c56bce.jpg","comment_is_top":false,"comment_ctime":1584933469,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584933469","product_id":100023901,"comment_content":"请问老师, 我的理解是否正确: <br>一共 3 个角色<br>应用A内请求处理类<br>RocketMQ<br>应用A内异步处理请求的消费者<br><br><br>应用A内请求处理类<br>1. 接收web请求<br>2. 发mq消息<br><br>RocketMQ<br>1. 接收消息<br><br><br>应用A内异步处理请求的消费者<br>1. 从RocketMQ拉取消息<br>2. 处理消息<br>3. 进行通知<br><br><br>应用A内请求处理类<br>1. 接到通知<br>2. 响应客户端 - 整个结束","like_count":0},{"had_liked":false,"id":188184,"user_name":"Evan","can_delete":false,"product_type":"c1","uid":1344281,"ip_address":"","ucode":"B877ABD0CF4661","user_header":"https://static001.geekbang.org/account/avatar/00/14/83/19/0a3fe8c1.jpg","comment_is_top":false,"comment_ctime":1584327305,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1584327305","product_id":100023901,"comment_content":"不加锁，没办法保证代码原子性、可见性。存在竞态条件的问题","like_count":0},{"had_liked":false,"id":183389,"user_name":"旅途","can_delete":false,"product_type":"c1","uid":1212902,"ip_address":"","ucode":"5022477E8E9441","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/e6/6cafed37.jpg","comment_is_top":false,"comment_ctime":1583032167,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583032167","product_id":100023901,"comment_content":"这段代码 由于使用的是同一个锁对象 是串行的 所以是不是可以把 锁和条件对象 也使用成每个消息一份 进行优化?","like_count":0},{"had_liked":false,"id":173235,"user_name":"书中迷梦","can_delete":false,"product_type":"c1","uid":1103010,"ip_address":"","ucode":"1C6B697F41698F","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/a2/fa41c8a8.jpg","comment_is_top":false,"comment_ctime":1579483186,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579483186","product_id":100023901,"comment_content":"老师这个示例列举的不太严谨，在单机情况是，文中说的没问题，但是到了分布式系统里面，就会导致，有的通知了但是该节点并没有阻塞队列","like_count":0},{"had_liked":false,"id":168274,"user_name":"Cv","can_delete":false,"product_type":"c1","uid":1062797,"ip_address":"","ucode":"C77CE172B5AA28","user_header":"","comment_is_top":false,"comment_ctime":1578040553,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578040553","product_id":100023901,"comment_content":"等待线程和回执线程是两个线程, 可见性可以通过添加volatile解决, 但是不加锁会有线程安全问题: p.test(obj)执行过程中obj被改变了可能会有未知问题.<br>","like_count":0},{"had_liked":false,"id":165212,"user_name":"anotherJJz","can_delete":false,"product_type":"c1","uid":1547742,"ip_address":"","ucode":"260F4B125D20FB","user_header":"https://static001.geekbang.org/account/avatar/00/17/9d/de/90c1ddf4.jpg","comment_is_top":false,"comment_ctime":1577180110,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577180110","product_id":100023901,"comment_content":"想请问一下，通常本地的onMessage方法，怎么暴露给外部的服务调用？","like_count":0},{"had_liked":false,"id":161002,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1576076312,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576076312","product_id":100023901,"comment_content":"Java服务接收请求，处理，响应是不是也是一个异步变同步的过程。<br><br>多线程处理，对于客户端而言是同步的。","like_count":0},{"had_liked":false,"id":148631,"user_name":"考休","can_delete":false,"product_type":"c1","uid":1053955,"ip_address":"","ucode":"968DFC00D6D0CF","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/03/c0fe1dbf.jpg","comment_is_top":false,"comment_ctime":1573041396,"is_pvip":false,"replies":[{"id":"57431","content":"除了这个办法好像没别的办法了😂","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1573217058,"ip_address":"","comment_id":148631,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1573041396","product_id":100023901,"comment_content":"请问老师，真正消息队列的请求中，如果是需要有消息处理返回值的情况，就是采用这种模式实现的吗，例如RabbitMQ","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473559,"discussion_content":"除了这个办法好像没别的办法了😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573217058,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1818343,"avatar":"","nickname":"刘同青","note":"","ucode":"84B62DF8BC61FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281627,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591780131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137457,"user_name":"Sharry","can_delete":false,"product_type":"c1","uid":1239293,"ip_address":"","ucode":"045DDB864659F6","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/fd/035f4c94.jpg","comment_is_top":false,"comment_ctime":1569745685,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569745685","product_id":100023901,"comment_content":"看了这篇文章之后才发现, 在使用管程解决并发编程的协作问题时, Guarded Suspension 模型几乎无处不在, 它太常用了, 没想到它居然已经抽象成一种编程模式. ","like_count":0},{"had_liked":false,"id":126701,"user_name":"文","can_delete":false,"product_type":"c1","uid":1090847,"ip_address":"","ucode":"E2DBA62248052E","user_header":"https://static001.geekbang.org/account/avatar/00/10/a5/1f/d2f6a1f7.jpg","comment_is_top":false,"comment_ctime":1566453417,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"1566453417","product_id":100023901,"comment_content":"while 可不可以换成 if？","like_count":0,"discussions":[{"author":{"id":2697700,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/LFJZ4x47rvShGhsePLIxc8EzdlBxAmVAIjJ2FQZ4NEpo8E4JCZQEOb2NIfOuiaQLL6Otkt7W3Rmu6Tv3AkgYdRA/132","nickname":"键盘上的魔术","note":"","ucode":"A731D721FB8D3A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581941,"discussion_content":"进入wait()然后被notify()后，需要再判断一次当前是否条件满足了。 if的话就不会再判断了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659079363,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1670763,"avatar":"https://static001.geekbang.org/account/avatar/00/19/7e/6b/36fc4516.jpg","nickname":"FIRE","note":"","ucode":"85861D990FB3AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326713,"discussion_content":"不行,大概是不能循环了吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605666424,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57586,"discussion_content":"不行，别傻了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574617176,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1039466,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/dc/6a/b5478b65.jpg","nickname":"Ab","note":"","ucode":"8E9261782F025D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6278,"discussion_content":"不可以，这个是范式，前面章节将了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566820341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117535,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1564069250,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564069250","product_id":100023901,"comment_content":"老师，线程t1需要阻塞等待消息对列返回结果么","like_count":0},{"had_liked":false,"id":105750,"user_name":"xuery","can_delete":false,"product_type":"c1","uid":1027584,"ip_address":"","ucode":"F461B61BE06131","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/00/025f37e7.jpg","comment_is_top":false,"comment_ctime":1561080744,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1561080744","product_id":100023901,"comment_content":"不对，总结有以下几点：<br>1.程序正常运行，即使while不满意条件了，sleep还是会继续等待那么多时间<br>2.没有锁就无法保证obj对象的可见性<br>3.如果消费失败，则会一直sleep","like_count":0},{"had_liked":false,"id":97463,"user_name":"cricket1981","can_delete":false,"product_type":"c1","uid":1001715,"ip_address":"","ucode":"758262F5958DA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/f3/f1034ffd.jpg","comment_is_top":false,"comment_ctime":1558676156,"is_pvip":false,"replies":[{"id":"34879","content":"websocket可以吗，没了解到你说的难点在哪里","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558699719,"ip_address":"","comment_id":97463,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1558676156","product_id":100023901,"comment_content":"想问一下分布式环境下，异步转同步的方法有哪些？例如，数据服务部署多个instance，客户在Web UI上点击外部数据源试用，后端通过一个数据服务instance请求外部数据源，外部数据源会异步回调结果(LB地址)返回，怎么样将结果显示在请求数据服务的Web UI上? 客户试用的过程是同步的，但请求外部数据源操作流程是异步的。谢谢！","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451286,"discussion_content":"websocket可以吗，没了解到你说的难点在哪里","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558699719,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96101,"user_name":"andy","can_delete":false,"product_type":"c1","uid":1063321,"ip_address":"","ucode":"F03BE5E20B471C","user_header":"https://static001.geekbang.org/account/avatar/00/10/39/99/42929758.jpg","comment_is_top":false,"comment_ctime":1558331217,"is_pvip":false,"replies":[{"id":"34432","content":"前者","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558357971,"ip_address":"","comment_id":96101,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1558331217","product_id":100023901,"comment_content":"我有个疑惑就是，这里所说的MQ可以是RabittMQ或者是其他类型的MQ吗？还是说这个MQ其实就JAVA中的一个数据结构？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450720,"discussion_content":"前者","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558357971,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95879,"user_name":"三木禾","can_delete":false,"product_type":"c1","uid":1109458,"ip_address":"","ucode":"39C37228236860","user_header":"https://static001.geekbang.org/account/avatar/00/10/ed/d2/e3ae7ddd.jpg","comment_is_top":false,"comment_ctime":1558240174,"is_pvip":false,"replies":[{"id":"34354","content":"onmessage调用 onchange,他们是两个类里的方法","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558313729,"ip_address":"","comment_id":95879,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1558240174","product_id":100023901,"comment_content":"老师，您这代码能不能写的完整一点啊，前面有个onMessage ,后面有个onChange","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450626,"discussion_content":"onmessage调用 onchange,他们是两个类里的方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558313729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94786,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1557897802,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557897802","product_id":100023901,"comment_content":"await(timeout);  本来是去等待队列里面呆timeout长的时间，如果到timeout之前没有被signal就出队;如果被signal了就是机制的正常运行。最终都return obj;<br><br>sleep(timeout);  守护条件不成立就sleep timeout, 还不成立再sleep timeout, … 如果在发生死锁或者onchange失败的情况下， get()方法会因为状态改变的失败而一直 判断 sleep下去 …… <br>老师我这里添加了死锁，不知道说的对不对啊，恳请老师回复。<br><br>还有，为什么我没办法用这种独到的眼力去套用一些框架代码的相似处啊? 是知道的太少了嘛？ ","like_count":0},{"had_liked":false,"id":94488,"user_name":"Geek_ebda96","can_delete":false,"product_type":"c1","uid":1134862,"ip_address":"","ucode":"02912E6D95A5A6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoRiaKX0ulEibbbwM4xhjyMeza0Pyp7KO1mqvfJceiaM6ZNtGpXJibI6P2qHGwBP9GKwOt9LgHicHflBXw/132","comment_is_top":false,"comment_ctime":1557823468,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557823468","product_id":100023901,"comment_content":"sleep方法，sleep期间，不会释放对象的锁，线程T1执行get，获取的lock在sleep期间他的锁不会释放，如果t2线程去执行onchanged方法，这时候获取不到lock的锁的，会导致程序死锁，<br>await方法，线程T1执行get,在等待期间，他会释放掉锁，这时t2执行onchanged，可以获取到lock然后给obj赋值，get1就可以获取到最新的obj<br><br>对于reentrantlock，执行lock后，如果不释放unlock，执行了await，其他线程还是可以获取到lock","like_count":0},{"had_liked":false,"id":94476,"user_name":"佑儿","can_delete":false,"product_type":"c1","uid":1226196,"ip_address":"","ucode":"0629888E7A5E16","user_header":"https://static001.geekbang.org/account/avatar/00/12/b5/d4/3bd5b77b.jpg","comment_is_top":false,"comment_ctime":1557821131,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557821131","product_id":100023901,"comment_content":"学习心得：每一种设计模式都适应某种场景，个人认为Guarded Suspension模式的根本在于get数据的时候一定能够获取，如果获取不到就等待，保护性暂停也就是这个意思，阻塞队列大部分都是这种模式。","like_count":0},{"had_liked":false,"id":94350,"user_name":"Kaleidoscoper","can_delete":false,"product_type":"c1","uid":1031741,"ip_address":"","ucode":"E705716641B08F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/be/3d/b782c7a5.jpg","comment_is_top":false,"comment_ctime":1557794428,"is_pvip":false,"replies":[{"id":"33939","content":"线程安全的容器能避免你说的这种情况<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1557930666,"ip_address":"","comment_id":94350,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557794428","product_id":100023901,"comment_content":"想问下老师，Create和fireEvent方法不加锁可以么，像Create方法不加锁指令重排优化，先返回object再加进map里会不会有问题","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450032,"discussion_content":"线程安全的容器能避免你说的这种情况\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557930666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93252,"user_name":"曾轼麟","can_delete":false,"product_type":"c1","uid":1451391,"ip_address":"","ucode":"D418371AC11270","user_header":"https://static001.geekbang.org/account/avatar/00/16/25/7f/473d5a77.jpg","comment_is_top":false,"comment_ctime":1557448076,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557448076","product_id":100023901,"comment_content":"sleep会无法唤醒导致超时，但是可以使用时间轮HashTimeWheel的方式去设置每一次请求的超时时间","like_count":0},{"had_liked":false,"id":93171,"user_name":"君哥聊技术","can_delete":false,"product_type":"c1","uid":1325816,"ip_address":"","ucode":"2C9A22BCE4C79E","user_header":"https://static001.geekbang.org/account/avatar/00/14/3a/f8/c1a939e7.jpg","comment_is_top":false,"comment_ctime":1557413516,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557413516","product_id":100023901,"comment_content":"老师，再问一下，如果不用锁，也不用await，notify，就用sleep，跟最后一段代码一样。<br>在test方法中加obj检验，除了sleep唤醒问题外，会有什么其他问题呢？","like_count":0},{"had_liked":false,"id":93149,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1557408149,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557408149","product_id":100023901,"comment_content":"打卡！","like_count":0},{"had_liked":false,"id":92916,"user_name":"晓杰","can_delete":false,"product_type":"c1","uid":1441546,"ip_address":"","ucode":"1174C88EEBF8A6","user_header":"https://static001.geekbang.org/account/avatar/00/15/ff/0a/12faa44e.jpg","comment_is_top":false,"comment_ctime":1557364637,"is_pvip":false,"replies":[{"id":"33211","content":"生产消息和消费消息不是一个线程，所以获取不到<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1557411956,"ip_address":"","comment_id":92916,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557364637","product_id":100023901,"comment_content":"请问老师MQ不是可以点对点吗，那服务提供方不可以指定消费某条消息吗，这样线程T是不是也可以获得MQ返回的结果","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449424,"discussion_content":"生产消息和消费消息不是一个线程，所以获取不到\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557411956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92899,"user_name":"kyle","can_delete":false,"product_type":"c1","uid":1179158,"ip_address":"","ucode":"DB05C0F7D2C472","user_header":"https://static001.geekbang.org/account/avatar/00/11/fe/16/0f096793.jpg","comment_is_top":false,"comment_ctime":1557363120,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557363120","product_id":100023901,"comment_content":"Java8的无法的补补！😰","like_count":0},{"had_liked":false,"id":92889,"user_name":"往事随风，顺其自然","can_delete":false,"product_type":"c1","uid":1235692,"ip_address":"","ucode":"F266EC6B143E38","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/ec/779c1a78.jpg","comment_is_top":false,"comment_ctime":1557362181,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557362181","product_id":100023901,"comment_content":"等待不确定时哪个线程成功，等待时间固定，不精确","like_count":0}]}