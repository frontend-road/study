{"id":740874,"title":"第 8 章 数据访问进阶(2)","content":"<h2 id=\"nav_point_128\">8.3　Spring 的缓存抽象</h2>\n<p>我们一般是按照图 8-3 的步骤来使用缓存数据的：第一次进入代码段，判断缓存中是否有需要的数据，如果存在就用缓存里的，如果不存在就从数据库或其他地方读取数据并放入缓存，这样下次就能从缓存获取数据了。当然，这里还要考虑缓存内容过期、超过缓存上限时内容淘汰、数据写入缓存时是否加锁等问题。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00769.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 8-3　一般的缓存操作流程</strong></p>\n<p>我们将这个过程抽象一下，缓存的常见操作无非就是判断是否存在、读取、写入和淘汰，真希望有一套框架能自动缓存特定方法的返回值，这样就不用我们再自己写代码了。Spring Framework 恰好就提供了这么一层缓存抽象。</p>\n<h3 id=\"nav_point_129\">8.3.1　基于注解的方法缓存</h3>\n<p>Spring Framework 3.1 引入了一套缓存抽象，它通过注解或者 XML 的方式配置到方法上，每次执行方法就会在缓存里做一次检查，看看是否已经用当前参数调用过这个方法了，如果调用过并且有结果在缓存里了，就不再执行实际的方法调用，而是直接返回缓存值；如果没调用过，就进行调用，并缓存结果。这样一来，就可以自动避免反复执行一些开销很大的方法了。</p>\n<blockquote>\n<p><strong>请注意</strong>　这里有两点需要着重说明一下：</p>\n<ul>\n<li>这套缓存抽象背后是通过 AOP 来实现的，即在实际对象外面包了一层代理，由代理来完成缓存操作，所以必须访问代理后的对象；</li>\n<li>只有那些<strong>可幂等操作</strong>的方法才适用于这套抽象，因为必须要保证相同的参数拥有一样的返回值。</li>\n</ul>\n</blockquote>\n<p>从 Spring Framework 4.1 版本开始，这套缓存抽象还提供了对 JSR-107 注解的支持。在本节中，我们就着重讨论基于注解的方法缓存。</p><!-- [[[read_end]]] -->\n<ol>\n<li><p><strong>常用注解介绍</strong></p>\n<p>表 8-9 中列举了在 Spring 的缓存抽象中提供的注解，以及它们与 JSR-107 注解的对应关系。</p>\n<p><strong>表 8-9　Spring 的缓存抽象中提供的注解</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>Spring 注解</th><th>JSR-107 对应注解</th><th>说明</th></tr><tr><td><code>@Cacheable</code></td><td><code>@CacheResult</code></td><td>从缓存中获取对应的缓存值，没有的话就执行方法并缓存，然后返回，其中 <code>sync</code> 如果为 <code>true</code>，在调用方法时会锁住缓存，相同的参数只有一个线程会计算，其他线程等待结果</td></tr><tr><td><code>@CachePut</code></td><td><code>@CachePut</code></td><td>直接用方法返回更新缓存，不做判断</td></tr><tr><td><code>@CacheEvict</code></td><td><code>@CacheRemove</code> / <code>@CacheRemoveAll</code></td><td>清除缓存，其中的 <code>allEntries</code> 如果设置为 <code>true</code>，则清除指定缓存</td></tr><tr><td><code>@Caching</code></td><td>无</td><td>可以用来组合多个缓存抽象的注解，比如两个 <code>@CacheEvict</code></td></tr><tr><td><code>@CacheConfig</code></td><td><code>@CacheDefaults</code></td><td>添加在类上，为这个类里的缓存抽象注解提供公共配置，例如统一的 <code>cacheNames</code> 和 <code>cacheManager</code></td></tr></table>\n\n<p>这些注解中有很多一样的属性（除了 <code>@Caching</code>），具体如下。</p>\n<ul>\n<li><strong><code>cacheNames</code></strong>，用来设置操作的缓存列表，例如 <code>cacheNames=\"menu\"</code>。</li>\n<li><strong><code>key</code></strong>，计算缓存键名的 SpEL 表达式，如果不设置，默认值是 <code>\"\"</code>，即所有参数都参与计算，共同决定键名。通过 <code>{#root.args[0]}</code> 来引用方法的第 1 个参数，此处也可以替换为参数名，例如 <code>#foo</code>；<code>#result</code> 可以访问方法的返回对象，如果注解有 <code>beforeInvocation</code> 属性，配置为 <code>true</code> 时 <code>#result</code> 不可用；<code>#root.methodName</code> 和 <code>#root.targetClass</code> 可以访问方法名和目标类的类名，相应地，<code>#root.method</code> 和 <code>#root.target</code> 则访问对应的对象；<code>#root.caches</code> 可以获得要操作的缓存列表。</li>\n<li><strong><code>keyGenerator</code></strong>，自定义的 <code>KeyGenerator</code> Bean 名称，用来生成缓存键名，与 <code>key</code> 属性互斥。</li>\n<li><strong><code>cacheManager</code></strong>，缓存管理器的 Bean 名称，负责管理实际的缓存。</li>\n<li><strong><code>cacheResolver</code></strong>，缓存解析器的 Bean 名称，与 <code>cacheManager</code> 属性互斥。</li>\n<li><strong><code>condition</code></strong>，操作缓存的条件，也是用 SpEL 表达式来计算的。</li>\n</ul>\n<p>前面说过，<code>key</code> 和 <code>keyGenerator</code> 是用来计算缓存键名的，默认情况下，<code>SimpleKeyGenerator</code> 会根据参数来生成键名，策略如下。</p>\n<ul>\n<li>如果没有参数，直接返回 <code>SimpleKey.EMPTY</code>。</li>\n<li>如果只有一个参数，且参数不为 <code>null</code>，也不是数组类型，直接返回这个参数。</li>\n<li>如果是其他情况，返回包含所有参数的 <code>SimpleKey</code> 实例。</li>\n</ul>\n<p><code>condition</code> 用来计算操作条件，它可以是这样的：</p>\n<pre class=\"code-rows\"><code>@Cacheable(cacheNames=\"menu\", condition=\"#name.length() &lt; 16\")\npublic MenuItem findByName(String name) {...}</code></pre>\n<p>还有一个 <code>unless</code> 参数，并不是所有注解都有，它是用来投否决票的。<code>unless</code> 仅在方法执行后有效，可以拿到执行结果 <code>#result</code>。当 <code>unless</code> 的表达式计算为 <code>true</code> 时则不放入缓存。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>如何激活缓存抽象</strong></p>\n<p>了解了上面的这些注解后，又该怎么激活 Spring Framework 对它们的支持呢？激活的方法与事务类似，可以在配置类上增加 <code>@EnableCaching</code> 注解，例如下面这样：</p>\n<pre class=\"code-rows\"><code>@Configuration\n@EnableCaching\npublic class Config {}</code></pre>\n<p>也可以在 XML 配置文件中使用 <code>&lt;cache:annotation-driven/&gt;</code> 标签，例如：</p>\n<pre class=\"code-rows\"><code>&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n        xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xmlns:cache=\"http://www.springframework.org/schema/cache\"\n        xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/cache\n        https://www.springframework.org/schema/cache/spring-cache.xsd\"&gt;\n\n    &lt;cache:annotation-driven/&gt;\n&lt;/beans&gt;</code></pre>\n<p>前文提到的各种注解都可以在 <code>&lt;cache/&gt;</code> 中找到对应的配置方法，此处就不展开了，我们还是以注解的用法为主。</p>\n<p>现在，回到二进制奶茶店的例子中，8.2 节的需求描述中已经说明了菜单是长时间的，属于读多写少的内容，因此非常适合做缓存。我们可以将整个菜单缓存起来，减少对数据库的操作。<span class=\"comment-number\">17</span> 先添加一个菜单服务类 <code>MenuService</code>，用它来封装 <code>Repository</code> 的操作，同时在其方法上添加相应的注解，如代码示例 8-13 所示。其实，<strong>一般都推荐将业务逻辑封装到 <code>Service</code> 中</strong>，一个服务在具体实现过程中可能会涉及多个不同表的操作，所以我们将事务也添加在 <code>Service</code> 上。</p>\n<blockquote>\n<p><strong>代码示例 8-13</strong>　<code>MenuService</code> 及 <code>MenuRepository</code> 的代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Service\n@CacheConfig(cacheNames = \"menu\")\npublic class MenuService {\n    @Autowired\n    private MenuRepository menuRepository;\n\n    @Cacheable\n    public List&lt;MenuItem&gt; getAllMenu() {\n        return menuRepository.findAll();\n    }\n\n    @Cacheable(key = \"#root.methodName + '-' + #name + '-' + #size\")\n    public Optional&lt;MenuItem&gt; getByNameAndSize(String name, Size size) {\n        return menuRepository.findByNameAndSize(name, size);\n    }\n}\n\n// MenuRepository稍做调整，增加了一个方法\npublic interface MenuRepository extends JpaRepository&lt;MenuItem, Long&gt;{\n    Optional&lt;MenuItem&gt; findByNameAndSize(String name, Size size);\n}</code></pre>\n<p>上面这段代码中，类上添加的 <code>@CacheConfig</code> 注解配置了公共的 <code>cacheNames</code>，因此就不用再在两个方法上做配置了；<code>getByNameAndSize()</code> 上的 <code>@Cacheable</code> 注解中配置了 <code>key</code> 属性，此处将方法名、<code>name</code> 参数与 <code>size</code> 参数用“<code>-</code>”拼接在一起作为缓存的键名。</p>\n<p>有了菜单服务，接下来需要初始化一下我们的缓存，做个“预热”，代码示例 8-14 就起到了这个作用。先调用 <code>getAllMenu()</code> 缓存完整的菜单列表，再调用 <code>getByNameAndSize()</code> 缓存单个菜单项。一般情况下在有了完整数据后，可以通过简单处理来获得里面的内容，这里出于演示的目的又加了些其他方法，在实践中可以酌情考虑合理使用缓存。</p>\n<blockquote>\n<p><strong>代码示例 8-14</strong>　用于“预热”缓存的 <code>MenuCacheRunner</code> 代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Component\n@Order(1)\n@Slf4j\npublic class MenuCacheRunner implements ApplicationRunner {\n    @Autowired\n    private MenuService menuService;\n\n    @Override\n    public void run(ApplicationArguments args) throws Exception {\n        log.info(\"从数据库加载菜单列表，后续应该就在缓存里了\");\n        List&lt;MenuItem&gt; list = menuService.getAllMenu();\n        log.info(\"共取得{}个条目。\", list.size());\n        menuService.getByNameAndSize(\"Java咖啡\", Size.MEDIUM).ifPresent(m -&gt; log.info(\"加载中杯Java咖啡，放入缓存，ID={}\", m.getId()));\n    }\n}</code></pre>\n<p>缓存“预热”后，再遇到调用对应方法的情况，只要缓存未失效，就不会执行真正的调用，而是直接返回缓存的值。调整后的 <code>MenuPrinterRunner</code> 会使用 <code>MenuService</code> 来获取菜单信息，加载到 data.sql 中预先插入的两条数据后，再重新通过 <code>getByNameAndSize()</code> 来做遍历，这时因为在 <code>MenuCacheRunner</code> 中缓存过“中杯 Java 咖啡”，它会直接从缓存中获取，而大杯咖啡则还需要访问数据库，如代码示例 8-15 所示。</p>\n<blockquote>\n<p><strong>代码示例 8-15</strong>　经过调整的 <code>MenuPrinterRunner</code> 代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Component\n@Order(2)\n@Slf4j\npublic class MenuPrinterRunner implements ApplicationRunner {\n    @Autowired\n    private MenuService menuService;\n\n    @Override\n    public void run(ApplicationArguments args) throws Exception {\n        log.info(\"再次加载菜单列表，应该不会访问数据库\");\n        List&lt;MenuItem&gt; list = menuService.getAllMenu();\n        log.info(\"共有{}个饮品可选。\", list.size());\n        list.forEach(i -&gt; log.info(\"重新查询菜单项({})：{}\", i.getId(),\n            menuService.getByNameAndSize(i.getName(), i.getSize())));\n    }\n}</code></pre>\n<p>由于开启了 Hibernate 的 SQL 打印功能，在运行程序时，通过观察日志中的 SQL 执行情况，就可以很方便地判断是否命中缓存。</p>\n</li>\n</ol>\n\n<h3 id=\"nav_point_130\">8.3.2　替换不同的缓存实现</h3>\n<p>在上一节的例子中，我们使用了 Spring Framework 提供的默认缓存，它的背后是 Java 的 <code>ConcurrentHashMap</code>。其实 Spring 的缓存抽象能够支持多种不同的后端缓存实现，它有一层 <code>CacheManager</code> 抽象，在其中维护了多个 <code>Cache</code>，我们要缓存的内容就是保存在 <code>Cache</code> 里的，而之前注解的 <code>cacheNames</code> 中指定的就是这里的 <code>Cache</code>。</p>\n<p>只需选择不同的 <code>CacheManager</code> 实现类，就能替换具体使用的缓存。表 8-9 列出了 Spring Framework 中内置的几个 <code>CacheManager</code> 实现。</p>\n<p><strong>表 8-10　内置的 <code>CacheManager</code> 实现</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>实现类</p></th>\n<th><p>底层实现</p></th>\n<th><p>说明</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>ConcurrentMapCacheManager</code></p></td>\n<td><p><code>ConcurrentHashMap</code></p></td>\n<td><p>建议仅用于测试目的</p></td>\n</tr>\n<tr>\n<td><p><code>NoOpCacheManager</code></p></td>\n<td><p>无</p></td>\n<td><p>不做任何缓存操作，可以视为关闭缓存</p></td>\n</tr>\n<tr>\n<td><p><code>CompositeCacheManager</code></p></td>\n<td><p>无</p></td>\n<td><p>用于组合多个不同的 <code>CacheManager</code>，会在其中遍历要找的缓存</p></td>\n</tr>\n<tr>\n<td><p><code>EhCacheCacheManager</code></p></td>\n<td><p>EhCache</p></td>\n<td><p>适用于 EhCache</p></td>\n</tr>\n<tr>\n<td><p><code>CaffeineCacheManager</code></p></td>\n<td><p>Caffeine</p></td>\n<td><p>适用于 Caffeine</p></td>\n</tr>\n<tr>\n<td><p><code>JCacheCacheManager</code></p></td>\n<td><p>JCache</p></td>\n<td><p>适用于遵循 JSR-107 规范的缓存</p></td>\n</tr>\n</tbody>\n</table>\n<p>spring-context 这个 Jar 包中只有几个简单的实现，像 EhCache、Caffeine 和 JCache 这样的支持都在 spring-context-support 里。我们可以手动引入后者，但在 Spring Boot 的帮助下，缓存抽象的引入也变得和其他各种能力一样，有对应的起步依赖：</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<p>而 Spring Boot 的自动配置支持的缓存类型就更多了，除了表 8-10 中提到的，还有下面的几种：</p>\n<ul>\n<li>Redis</li>\n<li>Couchbase</li>\n<li>Hazelcast</li>\n<li>Infinispan</li>\n</ul>\n<p><code>CacheProperties</code> 提供了一些基本的配置，在配置文件中使用的前缀是 <code>spring.cache</code>，例如 <code>spring.cache.type=redis</code> 可以指定缓存的类型，<code>spring.cache.cache-names=foo,bar</code> 可以限定只用 <code>foo</code> 和 <code>bar</code> 这两个缓存名称，不能动态创建其他的缓存。</p>\n<ol>\n<li><p><strong>替换为 Caffeine</strong></p>\n<p>要将默认的 <code>ConcurrentMapCacheManager</code> 替换为 <code>CaffeineCacheManager</code>，首先需要在 pom.xml 中引入 Caffeine 的依赖，具体的版本交给 Spring Boot 来管理（当然，也可以由我们自己指定）：</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.github.ben-manes.caffeine&lt;/groupId&gt;\n    &lt;artifactId&gt;caffeine&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<p>Spring Boot 的自动配置 <code>CaffeineCacheConfiguration</code> 会在下面的条件下生效，创建一个 <code>CaffeineCacheManager</code>：</p>\n<pre class=\"code-rows\"><code>@Configuration(proxyBeanMethods = false)\n@ConditionalOnClass({ Caffeine.class, CaffeineCacheManager.class })\n@ConditionalOnMissingBean(CacheManager.class)\n@Conditional({ CacheCondition.class })\nclass CaffeineCacheConfiguration {}</code></pre>\n<p>在配置文件中可以像这样来设置缓存，具体的 <code>spec</code> 内容可以参考 <code>CaffeineSpec</code> 类：</p>\n<pre class=\"code-rows\"><code>spring.cache.caffeine.spec=initialCapacity=10,maximumSize=50,expireAfterAccess=60s</code></pre>\n<p>8.3.1 节中的例子，只需做如上的调整，就能直接使用 Caffeine 运行起来，在代码层面实现零改动。<span class=\"comment-number\">18</span> 我们也可以写一个代码示例 8-16 这样的测试用例，看看是否真的自动使用了 Caffeine 做了缓存。由于我们的测试在运行前会先运行 <code>MenuCacheRunner</code>，所以我们只需要在单元测试里做些简单的判断就行了，比如是不是用了 <code>CaffeineCacheManager</code>，缓存里有没有之前存进去的内容等。</p>\n<blockquote>\n<p><strong>代码示例 8-16</strong>　针对 Caffine 的 <code>MenuCacheRunnerTest</code> 测试类</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootTest\nclass MenuCacheRunnerTest {\n    @Autowired\n    private CacheManager cacheManager;\n\n    @Test\n    void testCache() {\n        Cache cache = cacheManager.getCache(\"menu\");\n        assertTrue(cacheManager instanceof CaffeineCacheManager);\n        assertTrue(cache instanceof CaffeineCache);\n        assertNotNull(cache.get(\"getByNameAndSize-Java咖啡-MEDIUM\"));\n    }\n}</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>替换为 Redis</strong></p>\n<p>如果要将缓存抽象的底层缓存实现更换为 Redis，方法和之前类似：引入 Spring Data Redis 的依赖，随后 Spring Boot 的自动配置类 <code>RedisCacheConfiguration</code> 会根据条件生效，在上下文中注册一个 <code>RedisCacheManager</code> Bean。</p>\n<p><code>CacheProperties</code> 中针对 Redis 有一些配置，可以参考 <code>CacheProperties.Redis</code> 这个内部类，具体如表 8-11 所示。</p>\n<p><strong>表 8-11　<code>spring.cache.redis</code> 配置</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>配置项</th><th>默认值</th><th>说明</th></tr><tr><td><code>spring.cache.redis.time-to-live</code></td><td>不过期</td><td>过期时间</td></tr><tr><td><code>spring.cache.redis.cache-null-values</code></td><td><code>true</code></td><td>是否可以缓存空值</td></tr><tr><td><code>spring.cache.redis.key-prefix</code></td><td>无前缀</td><td>缓存中键的前缀</td></tr><tr><td><code>spring.cache.redis.use-key-prefix</code></td><td><code>true</code></td><td>写入缓存时是否添加键的前缀</td></tr></table>\n\n<p>与前面使用 Caffeine 时一样，先修改 pom.xml，将 Caffeine 的依赖换掉 <span class=\"comment-number\">19</span>：</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<p>我们可以像 8.2 节那样对 Redis 的操作进行设置，调整序列化方式，这里的演示就不做过多的调整了。除了 <code>spring.cache.redis.time-to-live=60s</code> 以外，其他配置先全部使用默认值，连接监听在 <code>localhost:6379</code> 上的 Redis。在运行程序后，可以访问 Redis 缓存，查看数据，看到的结果会与下面的输出类似：</p>\n<pre class=\"code-rows\"><code># redis-cli\n127.0.0.1:6379&gt; keys *\n1) \"menu:name:Java\\xe5\\x92\\x96\\xe5\\x95\\xa1\"\n2) \"menu::getByNameAndSize-Java\\xe5\\x92\\x96\\xe5\\x95\\xa1-MEDIUM\"\n3) \"menu::SimpleKey []\"\n4) \"menu::getByNameAndSize-Java\\xe5\\x92\\x96\\xe5\\x95\\xa1-LARGE\"\n5) \"menu:1:idx\"\n6) \"menu:2:idx\"\n7) \"menu\"\n127.0.0.1:6379&gt; type \"menu::getByNameAndSize-Java\\xe5\\x92\\x96\\xe5\\x95\\xa1-MEDIUM\"\nstring\n127.0.0.1:6379&gt;</code></pre>\n<p>这里的序列化方式其实都是在 <code>RedisCacheConfiguration</code> 中配置的，其中的 <code>keySerializationPair</code> 和 <code>valueSerializationPair</code> 默认是用 <code>RedisSerializer.string()</code> 和 <code>RedisSerializer.java()</code> 来构造的。要对它们进行调整有两种方式，具体如下所示（如果是要调整序列化方式，建议用第一种）：</p>\n<p>(1) 在上下文中配置一个我们自己的 <code>RedisCacheConfiguration</code> Bean，在里面完成自定义；</p>\n<p>(2) 在上下文中配置一个我们自己的 <code>RedisCacheManagerBuilderCustomizer</code> 实现，对 <code>RedisCacheManager</code> 进行调整。</p>\n<p>代码示例 8-16 的测试类也要稍做调整，<code>Cache</code> 应该判断是否为 <code>RedisCache</code> 的实例，具体如代码示例 8-17 所示。</p>\n<blockquote>\n<p><strong>代码示例 8-17</strong>　针对 Redis 改写的 <code>MenuCacheRunnerTest</code> 测试类</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootTest\nclass MenuCacheRunnerTest {\n    @Autowired\n    private CacheManager cacheManager;\n\n    @Test\n    void testCache() {\n        Cache cache = cacheManager.getCache(\"menu\");\n        assertTrue(cacheManager instanceof RedisCacheManager);\n        assertTrue(cache instanceof RedisCache);\n        assertNotNull(cache.get(\"getByNameAndSize-Java咖啡-MEDIUM\"));\n    }\n}</code></pre>\n</li>\n</ol>\n\n\n<h2 id=\"nav_point_131\">8.4　小结</h2>\n<p>在这一章里，我们更多地还是在聊一些与数据操作实战相关的话题，例如，在实际生产环境中，数据库连接池除了管理连接，还应该搭配哪些功能——可能是其内置的功能，也可能是与其他组件结合，像密码加密就是个必备的能力。除了关系型数据库，我们还会在工程中大量地使用非关系型数据库，Redis 就是其中比较常用的。你应该体会到了，在 Spring Boot 和 Spring Data Redis 的帮助下，Redis 的使用既轻松又惬意。最后我们还聊了聊 Spring Framework 提供的缓存抽象，它在一定程度上简化了方法返回值缓存的复杂性，在工作中十分好用。</p>\n<p>本章我们聊完了数据库相关的话题，下一章将要开启一个新篇章 —— 怎么实现 Web 相关的需求。</p>\n<blockquote>\n<p style=\"text-align: center\"><strong>二进制奶茶店项目开发小结</strong></p>\n<p>到这一章为止，Spring 中的数据操作部分就结束了，阶段性地小结一下二进制奶茶店目前的情况。在第 5 章小结的基础上，目前 BinaryTea 工程在技术层面又实现了如下功能：</p>\n<ul>\n<li><strong>菜单、订单等对象建模</strong>，结合 JPA 注解与 Lombok 注解，Model 层的对象可以直接通过 ORM 框架与数据库中的表建立映射关系；</li>\n<li><strong>常规关系型数据库操作</strong>，Spring Data 的 <code>Repository</code> 可以方便地实现最基本的增删改查操作，定义接口即能实现扩展；</li>\n<li><strong>菜单数据缓存</strong>，通过 Spring 的缓存抽象，能够透明地更换底层的缓存实现。</li>\n</ul>\n<p>在项目进展过程中，我们还交替演示了 JDBC、Hibernate 及 MyBatis 的基本使用方法；在演示 Spring Data Redis 时，也切换了 Lettuce 和 Jedis 客户端；介绍缓存抽象时，将基于 <code>ConcurrentHashMap</code> 的缓存替换为了 Caffeine 和 Redis。在 Spring 家族各种组件的帮助下，这种切换几乎是无缝的，对业务代码的改动微乎其微。</p>\n</blockquote>\n\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"第 8 章 数据访问进阶(1)","id":740873},"right":{"article_title":"第三部分 使用 Spring 开发 Web 应用","id":740875}},"comments":[]}