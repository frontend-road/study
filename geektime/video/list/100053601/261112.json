{"id":261112,"title":"23 | 如何解决微服务的分布式事务问题？（下）","content":"<p><strong>课件和Demo地址</strong><br>\n<a href=\"https://gitee.com/geektime-geekbang/geektime-distributed\">https://gitee.com/geektime-geekbang/geektime-distributed</a></p>","comments":[{"had_liked":false,"id":238162,"user_name":"原军","can_delete":false,"product_type":"c3","uid":1016202,"ip_address":"","ucode":"003C988716FBCC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/81/8a/0b065758.jpg","comment_is_top":false,"comment_ctime":1596083453,"is_pvip":false,"replies":[{"id":88124,"content":"微服务架构中，要么同步调用，要么异步调用，具体要看业务或者技术场景。\n\n同步调用一般用RPC或者REST框架，异步调用一般通过MQ。\n\n","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1596208507,"ip_address":"","comment_id":238162,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100053601,"comment_content":"老师在微服务架构中，服务直接能相互调用吗，如果可以的话，通过什么方式调用的","like_count":4,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502662,"discussion_content":"微服务架构中，要么同步调用，要么异步调用，具体要看业务或者技术场景。\n\n同步调用一般用RPC或者REST框架，异步调用一般通过MQ。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596208507,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":289265,"user_name":"不记年","can_delete":false,"product_type":"c3","uid":1045945,"ip_address":"","ucode":"287E40C68356DC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/b9/888fe350.jpg","comment_is_top":false,"comment_ctime":1618961992,"is_pvip":false,"replies":[{"id":105440,"content":"P分区容忍性是即成事实，意思是说在微服务场景下，或者说在数据库被拆分的场景下，系统一定是分区的(Partitioned)，也就不再是只有一个独立的不分区的数据库。","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1619965744,"ip_address":"","comment_id":289265,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100053601,"comment_content":"为什么分区容错性是既成事实呢","like_count":0,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518867,"discussion_content":"P分区容忍性是即成事实，意思是说在微服务场景下，或者说在数据库被拆分的场景下，系统一定是分区的(Partitioned)，也就不再是只有一个独立的不分区的数据库。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619965744,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":278880,"user_name":"butterfly","can_delete":false,"product_type":"c3","uid":1392924,"ip_address":"","ucode":"1B724973303FB0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/rRCSdTPyqWcW6U8DO9xL55ictNPlbQ38VAcaBNgibqaAhcH7mn1W9ddxIJLlMiaA5sngBicMX02w2HP5pAWpBAJsag/132","comment_is_top":false,"comment_ctime":1613418084,"is_pvip":false,"replies":[{"id":101503,"content":"saga可以认为是一种更通用的服务编排&#47;协调模式，偏向解决长流程性事务。而rocket mq的事务消息是实现事务性可靠消息的一种技术。saga模式也可以基于rocket mq的可靠消息来实现。\n\nsaga模式一般要求底层消息的可靠交付，但是它的编排逻辑(例如状态机)可以设计为能够自动处理底层消息交付不可靠的情况(通过重试或者回滚等机制)。","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1613746482,"ip_address":"","comment_id":278880,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100053601,"comment_content":"saga模式和rocket mq的事务消息有什么区别？\nsaga模式需要协调者保证消息可靠的投递到mq的吗？","like_count":0,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515541,"discussion_content":"saga可以认为是一种更通用的服务编排/协调模式，偏向解决长流程性事务。而rocket mq的事务消息是实现事务性可靠消息的一种技术。saga模式也可以基于rocket mq的可靠消息来实现。\n\nsaga模式一般要求底层消息的可靠交付，但是它的编排逻辑(例如状态机)可以设计为能够自动处理底层消息交付不可靠的情况(通过重试或者回滚等机制)。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613746482,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":243816,"user_name":"Vincent_","can_delete":false,"product_type":"c3","uid":1313831,"ip_address":"","ucode":"0904F7CE04E788","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ibbEWWUTH7964UOnwpBPC8Lhb1TS4s7XMEXTPKHPUBlj58GVkdRQRqa6EydIRL2I1uJDzeichLj86gJfTpzcgcCA/132","comment_is_top":false,"comment_ctime":1598281739,"is_pvip":false,"replies":[{"id":90084,"content":"回答你的一些问题：\n\n1. 在启动下单扣库存事务之前，可以先校验一下是否有库存，如果没有直接返回没有，如果有再启动分布式事务。\n\n2. 有同步异步两种主要做法，国内大多用同步事务方案，也就是说事务协调器的主流程是同步的，比方说可以基于阿里seata框架的AT模式(或者TCC)模式来实现。国外有不少采用异步方案的，比方说基于uber cadence来实现，虽然是异步实现，但是调用方客户端也是可以封装成同步的，具体可以参考uber cadence的java客户端实现(底层应该使用polling轮询机制实现)。关于seata和cadence，本课程后面都有介绍。","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1598702031,"ip_address":"","comment_id":243816,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100053601,"comment_content":"这节课里提到的购物场景，订单service保证了订单-db的事务一致性，库存service保证了库存-db的事务一致性，但是实际大厂商城，我下一个单如果没有库存下单时直接就会提示我库存不足，而不让我的订单落库，这是要怎么实现？引入mq主要就是分隔开各个服务的细粒度，但是业务场景下，多服务协调，异步的话用户没法实时获得感知，同步的话，多个服务用rpc又会让处理时间变长。想请问老师，这种场景大厂一般是怎么解决的？异步的话，是如何在用户点击下单时，多个服务异步mq，用户一个下单request还能拿到这么多异步的最后结果的？","like_count":0,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504402,"discussion_content":"回答你的一些问题：\n\n1. 在启动下单扣库存事务之前，可以先校验一下是否有库存，如果没有直接返回没有，如果有再启动分布式事务。\n\n2. 有同步异步两种主要做法，国内大多用同步事务方案，也就是说事务协调器的主流程是同步的，比方说可以基于阿里seata框架的AT模式(或者TCC)模式来实现。国外有不少采用异步方案的，比方说基于uber cadence来实现，虽然是异步实现，但是调用方客户端也是可以封装成同步的，具体可以参考uber cadence的java客户端实现(底层应该使用polling轮询机制实现)。关于seata和cadence，本课程后面都有介绍。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598702031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241653,"user_name":"Elective9095","can_delete":false,"product_type":"c3","uid":1595002,"ip_address":"","ucode":"2AC2F9B0A6D823","user_header":"https://static001.geekbang.org/account/avatar/00/18/56/7a/382538dc.jpg","comment_is_top":false,"comment_ctime":1597382236,"is_pvip":false,"replies":[{"id":89245,"content":"saga模式长短事务都支持，长事务更适合。\n\n分布式事务的做法，都是把原来人工做的变成让机器自动做，就像以前银行没有计算机，都靠手工补偿。","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1597416053,"ip_address":"","comment_id":241653,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100053601,"comment_content":"saga模型，中间步骤失败会对前面已完成的步骤进行补偿。如果一个业务流程比较长，还能这样搞吗？我感觉saga模型就是需要人工补偿的步骤改成了自动补偿。","like_count":0,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503803,"discussion_content":"saga模式长短事务都支持，长事务更适合。\n\n分布式事务的做法，都是把原来人工做的变成让机器自动做，就像以前银行没有计算机，都靠手工补偿。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597416053,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":251928,"user_name":"OlafOO","can_delete":false,"product_type":"c3","uid":1019254,"ip_address":"","ucode":"105F8B194ED37B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/76/994a9929.jpg","comment_is_top":false,"comment_ctime":1601981409,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100053601,"comment_content":"购物事务过程中，全局事务还未完成，但是订单已经可见了，用户此时取消订单，会对购物事务进行干扰，导致数据不一致的问题，可以使用语义锁，对未完成的订单不允许操作。","like_count":2},{"had_liked":false,"id":369462,"user_name":"曹操的曹🐈","can_delete":false,"product_type":"c3","uid":1343595,"ip_address":"广东","ucode":"B3FBB479BE98EC","user_header":"https://static001.geekbang.org/account/avatar/00/14/80/6b/4d795196.jpg","comment_is_top":false,"comment_ctime":1677565485,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100053601,"comment_content":"老师，协同模式下在回滚的过程中其中一跳超时重试多次或者不可达是否都会破坏事务的一致性，这种应该如何避免？","like_count":0},{"had_liked":false,"id":362127,"user_name":"北极的大企鹅","can_delete":false,"product_type":"c3","uid":1045577,"ip_address":"上海","ucode":"8935346D08E109","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f4/49/2b938b4f.jpg","comment_is_top":false,"comment_ctime":1668175366,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100053601,"comment_content":"来了","like_count":0}]}