{"id":92849,"title":"27 | 并发工具类模块热点问题答疑","content":"<p>前面我们用13篇文章的内容介绍了Java SDK提供的并发工具类，这些工具类都是久经考验的，所以学好用好它们对于解决并发问题非常重要。我们在介绍这些工具类的时候，重点介绍了这些工具类的产生背景、应用场景以及实现原理，目的就是让你在面对并发问题的时候，有思路，有办法。只有思路、办法有了，才谈得上开始动手解决问题。</p><p>当然了，只有思路和办法还不足以把问题解决，最终还是要动手实践的，我觉得在实践中有两方面的问题需要重点关注：<strong>细节问题与最佳实践</strong>。千里之堤毁于蚁穴，细节虽然不能保证成功，但是可以导致失败，所以我们一直都强调要关注细节。而最佳实践是前人的经验总结，可以帮助我们不要阴沟里翻船，所以没有十足的理由，一定要遵守。</p><p>为了让你学完即学即用，我在每篇文章的最后都给你留了道思考题。这13篇文章的13个思考题，基本上都是相关工具类在使用中需要特别注意的一些细节问题，工作中容易碰到且费神费力，所以咱们今天就来一一分析。</p><h2>1. while(true) 总不让人省心</h2><p><a href=\"https://time.geekbang.org/column/article/87779\">《14 | Lock&amp;Condition（上）：隐藏在并发包中的管程》</a>的思考题，本意是通过破坏不可抢占条件来避免死锁问题，但是它的实现中有一个致命的问题，那就是： while(true) 没有break条件，从而导致了死循环。除此之外，这个实现虽然不存在死锁问题，但还是存在活锁问题的，解决活锁问题很简单，只需要随机等待一小段时间就可以了。</p><!-- [[[read_end]]] --><p>修复后的代码如下所示，我仅仅修改了两个地方，一处是转账成功之后break，另一处是在while循环体结束前增加了<code>Thread.sleep(随机时间)</code>。</p><pre><code>class Account {\n  private int balance;\n  private final Lock lock\n          = new ReentrantLock();\n  // 转账\n  void transfer(Account tar, int amt){\n    while (true) {\n      if(this.lock.tryLock()) {\n        try {\n          if (tar.lock.tryLock()) {\n            try {\n              this.balance -= amt;\n              tar.balance += amt;\n              //新增：退出循环\n              break;\n            } finally {\n              tar.lock.unlock();\n            }\n          }//if\n        } finally {\n          this.lock.unlock();\n        }\n      }//if\n      //新增：sleep一个随机时间避免活锁\n      Thread.sleep(随机时间);\n    }//while\n  }//transfer\n}\n</code></pre><p>这个思考题里面的while(true)问题还是比较容易看出来的，<strong>但不是所有的while(true)问题都这么显而易见的</strong>，很多都隐藏得比较深。</p><p>例如，<a href=\"https://time.geekbang.org/column/article/90515\">《21 | 原子类：无锁工具类的典范》</a>的思考题本质上也是一个while(true)，不过它隐藏得就比较深了。看上去 <code>while(!rf.compareAndSet(or, nr))</code> 是有终止条件的，而且跑单线程测试一直都没有问题。实际上却存在严重的并发问题，问题就出在对or的赋值在while循环之外，这样每次循环or的值都不会发生变化，所以一旦有一次循环rf.compareAndSet(or, nr)的值等于false，那之后无论循环多少次，都会等于false。也就是说在特定场景下，变成了while(true)问题。既然找到了原因，修改就很简单了，只要把对or的赋值移到while循环之内就可以了，修改后的代码如下所示：</p><pre><code>public class SafeWM {\n  class WMRange{\n    final int upper;\n    final int lower;\n    WMRange(int upper,int lower){\n    //省略构造函数实现\n    }\n  }\n  final AtomicReference&lt;WMRange&gt;\n    rf = new AtomicReference&lt;&gt;(\n      new WMRange(0,0)\n    );\n  // 设置库存上限\n  void setUpper(int v){\n    WMRange nr;\n    WMRange or;\n    //原代码在这里\n    //WMRange or=rf.get();\n    do{\n      //移动到此处\n      //每个回合都需要重新获取旧值\n      or = rf.get();\n      // 检查参数合法性\n      if(v &lt; or.lower){\n        throw new IllegalArgumentException();\n      }\n      nr = new\n        WMRange(v, or.lower);\n    }while(!rf.compareAndSet(or, nr));\n  }\n}\n</code></pre><h2>2. signalAll() 总让人省心</h2><p><a href=\"https://time.geekbang.org/column/article/88487\">《15 | Lock&amp;Condition（下）：Dubbo如何用管程实现异步转同步？》</a>的思考题是关于signal()和signalAll()的，Dubbo最近已经把signal()改成signalAll()了，我觉得用signal()也不能说错，但的确是<strong>用signalAll()会更安全</strong>。我个人也倾向于使用signalAll()，因为我们写程序，不是做数学题，而是在搞工程，工程中会有很多不稳定的因素，更有很多你预料不到的情况发生，所以不要让你的代码铤而走险，尽量使用更稳妥的方案和设计。Dubbo修改后的相关代码如下所示：</p><pre><code>// RPC结果返回时调用该方法   \nprivate void doReceived(Response res) {\n  lock.lock();\n  try {\n    response = res;\n    done.signalAll();\n  } finally {\n    lock.unlock();\n  }\n}\n</code></pre><h2>3. Semaphore需要锁中锁</h2><p><a href=\"https://time.geekbang.org/column/article/88499\">《16 | Semaphore：如何快速实现一个限流器？》</a>的思考题是对象池的例子中Vector能否换成ArrayList，答案是不可以的。Semaphore可以允许多个线程访问一个临界区，那就意味着可能存在多个线程同时访问ArrayList，而ArrayList不是线程安全的，所以对象池的例子中是不能够将Vector换成ArrayList的。<strong>Semaphore允许多个线程访问一个临界区，这也是一把双刃剑</strong>，当多个线程进入临界区时，如果需要访问共享变量就会存在并发问题，所以必须<strong>加锁</strong>，也就是说Semaphore需要锁中锁。</p><h2>4. 锁的申请和释放要成对出现</h2><p><a href=\"https://time.geekbang.org/column/article/89456\">《18 | StampedLock：有没有比读写锁更快的锁？》</a>思考题的Bug出在没有正确地释放锁。锁的申请和释放要成对出现，对此我们有一个最佳实践，就是使用<strong>try{}finally{}</strong>，但是try{}finally{}并不能解决所有锁的释放问题。比如示例代码中，锁的升级会生成新的stamp ，而finally中释放锁用的是锁升级前的stamp，本质上这也属于锁的申请和释放没有成对出现，只是它隐藏得有点深。解决这个问题倒也很简单，只需要对stamp 重新赋值就可以了，修复后的代码如下所示：</p><pre><code>private double x, y;\nfinal StampedLock sl = new StampedLock();\n// 存在问题的方法\nvoid moveIfAtOrigin(double newX, double newY){\n long stamp = sl.readLock();\n try {\n  while(x == 0.0 &amp;&amp; y == 0.0){\n    long ws = sl.tryConvertToWriteLock(stamp);\n    if (ws != 0L) {\n      //问题出在没有对stamp重新赋值\n      //新增下面一行\n      stamp = ws;\n      x = newX;\n      y = newY;\n      break;\n    } else {\n      sl.unlockRead(stamp);\n      stamp = sl.writeLock();\n    }\n  }\n } finally {\n  //此处unlock的是stamp\n  sl.unlock(stamp);\n}\n</code></pre><h2>5. 回调总要关心执行线程是谁</h2><p><a href=\"https://time.geekbang.org/column/article/89461\">《19 | CountDownLatch和CyclicBarrier：如何让多线程步调一致？》</a>的思考题是：CyclicBarrier的回调函数使用了一个固定大小为1的线程池，是否合理？我觉得是合理的，可以从以下两个方面来分析。</p><p>第一个是线程池大小是1，只有1个线程，主要原因是check()方法的耗时比getPOrders()和getDOrders()都要短，所以没必要用多个线程，同时单线程能保证访问的数据不存在并发问题。</p><p>第二个是使用了线程池，如果不使用，直接在回调函数里调用check()方法是否可以呢？绝对不可以。为什么呢？这个要分析一下回调函数和唤醒等待线程之间的关系。下面是CyclicBarrier相关的源码，通过源码你会发现CyclicBarrier是同步调用回调函数之后才唤醒等待的线程，如果我们在回调函数里直接调用check()方法，那就意味着在执行check()的时候，是不能同时执行getPOrders()和getDOrders()的，这样就起不到提升性能的作用。</p><pre><code>try {\n  //barrierCommand是回调函数\n  final Runnable command = barrierCommand;\n  //调用回调函数\n  if (command != null)\n\tcommand.run();\n  ranAction = true;\n  //唤醒等待的线程\n  nextGeneration();\n  return 0;\n} finally {\n  if (!ranAction)\n\tbreakBarrier();\n}\n</code></pre><p>所以，当遇到回调函数的时候，你应该本能地问自己：执行回调函数的线程是哪一个？这个在多线程场景下非常重要。因为不同线程ThreadLocal里的数据是不同的，有些框架比如Spring就用ThreadLocal来管理事务，如果不清楚回调函数用的是哪个线程，很可能会导致错误的事务管理，并最终导致数据不一致。</p><p>CyclicBarrier的回调函数究竟是哪个线程执行的呢？如果你分析源码，你会发现执行回调函数的线程是将CyclicBarrier内部计数器减到 0 的那个线程。所以我们前面讲执行check()的时候，是不能同时执行getPOrders()和getDOrders()，因为执行这两个方法的线程一个在等待，一个正在忙着执行check()。</p><p>再次强调一下：<strong>当看到回调函数的时候，一定问一问执行回调函数的线程是谁</strong>。</p><h2>6. 共享线程池：有福同享就要有难同当</h2><p><a href=\"https://time.geekbang.org/column/article/91569\">《24 | CompletableFuture：异步编程没那么难》</a>的思考题是下列代码是否有问题。很多同学都发现这段代码的问题了，例如没有异常处理、逻辑不严谨等等，不过我更想让你关注的是：findRuleByJdbc()这个方法隐藏着一个阻塞式I/O，这意味着会阻塞调用线程。默认情况下所有的CompletableFuture共享一个ForkJoinPool，当有阻塞式I/O时，可能导致所有的ForkJoinPool线程都阻塞，进而影响整个系统的性能。</p><pre><code>//采购订单\nPurchersOrder po;\nCompletableFuture&lt;Boolean&gt; cf = \n  CompletableFuture.supplyAsync(()-&gt;{\n    //在数据库中查询规则\n    return findRuleByJdbc();\n  }).thenApply(r -&gt; {\n    //规则校验\n    return check(po, r);\n});\nBoolean isOk = cf.join();\n</code></pre><p>利用共享，往往能让我们快速实现功能，所谓是有福同享，但是代价就是有难要同当。在强调高可用的今天，大多数人更倾向于使用隔离的方案。</p><h2>7. 线上问题定位的利器：线程栈dump</h2><p><a href=\"https://time.geekbang.org/column/article/88909\">《17 | ReadWriteLock：如何快速实现一个完备的缓存？》</a>和<a href=\"https://time.geekbang.org/column/article/90201\">《20 | 并发容器：都有哪些“坑”需要我们填？》</a>的思考题，本质上都是定位线上并发问题，方案很简单，就是通过查看线程栈来定位问题。重点是查看线程状态，分析线程进入该状态的原因是否合理，你可以参考<a href=\"https://time.geekbang.org/column/article/86366\">《09 | Java线程（上）：Java线程的生命周期》</a>来加深理解。</p><p>为了便于分析定位线程问题，你需要给线程赋予一个有意义的名字，对于线程池可以通过自定义ThreadFactory来给线程池中的线程赋予有意义的名字，也可以在执行run()方法时通过<code>Thread.currentThread().setName();</code>来给线程赋予一个更贴近业务的名字。</p><h2>总结</h2><p>Java并发工具类到今天为止，就告一段落了，由于篇幅原因，不能每个工具类都详细介绍。Java并发工具类内容繁杂，熟练使用是需要一个过程的，而且需要多加实践。希望你学完这个模块之后，遇到并发问题时最起码能知道用哪些工具可以解决。至于工具使用的细节和最佳实践，我总结的也只是我认为重要的。由于每个人的思维方式和编码习惯不同，也许我认为不重要的，恰恰是你的短板，所以这部分内容更多地还是需要你去实践，在实践中养成良好的编码习惯，不断纠正错误的思维方式。</p><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p><p></p>","comments":[{"had_liked":false,"id":90741,"user_name":"Sunqc","can_delete":false,"product_type":"c1","uid":1473717,"ip_address":"","ucode":"2C54659635403F","user_header":"https://static001.geekbang.org/account/avatar/00/16/7c/b5/4a7a2bd4.jpg","comment_is_top":false,"comment_ctime":1556622722,"is_pvip":false,"replies":[{"id":"34459","content":"感谢感谢😃","user_name":"作者回复","comment_id":90741,"uid":"1269969","ip_address":"","utype":1,"ctime":1558362745,"user_name_real":"王宝令"}],"discussion_count":4,"race_medal":0,"score":"310794268034","product_id":100023901,"comment_content":"听老师讲课是一种享受，很舒服，从文字叙述就感觉很和蔼可亲，不像有的老师，虽然技术也很牛，但是话里话外透漏着自己多牛多牛的感觉","like_count":72,"discussions":[{"author":{"id":1897671,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/f4/c7/037235c9.jpg","nickname":"kimoti","note":"","ucode":"0A78077408C2B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269908,"discussion_content":"同感,其实高人都是很谦虚的","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1589960937,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1277081,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7c/99/4dac6ce6.jpg","nickname":"lakeslove","note":"","ucode":"65E14D29D3C981","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1897671,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/f4/c7/037235c9.jpg","nickname":"kimoti","note":"","ucode":"0A78077408C2B1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319193,"discussion_content":"某些高人真心不谦虚，课程泛泛而谈，问点细节问题还不搭理","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603961041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":269908,"ip_address":""},"score":319193,"extra":""}]},{"author":{"id":2342014,"avatar":"https://static001.geekbang.org/account/avatar/00/23/bc/7e/c1422d90.jpg","nickname":"打工人的精神领袖","note":"","ucode":"8EC3864768368D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537372,"discussion_content":"你说的是不是马士兵?","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1639044291,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448634,"discussion_content":"感谢感谢😃","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1558362745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144575,"user_name":"ipofss","can_delete":false,"product_type":"c1","uid":1018620,"ip_address":"","ucode":"DE3061C9259F9E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/fc/d1dd57dd.jpg","comment_is_top":false,"comment_ctime":1571972366,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"57406547214","product_id":100023901,"comment_content":"这一章的内容，我觉得等把整个专栏学完之后，还有必要再仔细回顾一遍，然后再加上其他的文章，自己动手写一下demo，才能记住的多一些，毕竟平时工作中用到多线程的地方不多","like_count":14,"discussions":[{"author":{"id":1441830,"avatar":"https://static001.geekbang.org/account/avatar/00/16/00/26/a80010f0.jpg","nickname":"JL","note":"","ucode":"07BD8069AE2CBD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310177,"discussion_content":"用得不多 但是面试时候问到特别多🤣","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1601664611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1513825,"avatar":"https://static001.geekbang.org/account/avatar/00/17/19/61/119cbde2.jpg","nickname":"Dolly","note":"","ucode":"CC74978F393055","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1441830,"avatar":"https://static001.geekbang.org/account/avatar/00/16/00/26/a80010f0.jpg","nickname":"JL","note":"","ucode":"07BD8069AE2CBD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361298,"discussion_content":"扎心了，平时crud糊页面，面试多线程高并发","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1616639853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":310177,"ip_address":""},"score":361298,"extra":""}]},{"author":{"id":1812970,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a9/ea/5bfce6c5.jpg","nickname":"mgs2002","note":"","ucode":"F5931108BD509B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":279856,"discussion_content":"确实呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591435707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136964,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1569567571,"is_pvip":true,"replies":[{"id":"52707","content":"👍","user_name":"作者回复","comment_id":136964,"uid":"1269969","ip_address":"","utype":1,"ctime":1569667474,"user_name_real":"王宝令"}],"discussion_count":2,"race_medal":0,"score":"31634338643","product_id":100023901,"comment_content":"关于线程协作那里为什么使用单线程线程池，特意回头重新看了下代码，终于明白了老师的做法，因为回调函数也会占据一个执行线程，如果不使用额外的线程，那么就会存在部分串行，就达不到完全分工并行，以提升吞吐的效果了","like_count":7,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468883,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569667474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1053955,"avatar":"https://static001.geekbang.org/account/avatar/00/10/15/03/c0fe1dbf.jpg","nickname":"考休","note":"","ucode":"968DFC00D6D0CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":45449,"discussion_content":"我也是又回去看了一遍才明白，利用线程池执行check()方法，本质上还是为了保证check的异步调用，进而提升系统的性能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573039605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90568,"user_name":"邱","can_delete":false,"product_type":"c1","uid":1443771,"ip_address":"","ucode":"6235D4CDA8B8C3","user_header":"https://static001.geekbang.org/account/avatar/00/16/07/bb/97ba4ccd.jpg","comment_is_top":false,"comment_ctime":1556582591,"is_pvip":false,"replies":[{"id":"32444","content":"这个还是要看实际场景，主要是考虑数据库事务，还有线程池是不是隔离的","user_name":"作者回复","comment_id":90568,"uid":"1269969","ip_address":"","utype":1,"ctime":1556590269,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"31621353663","product_id":100023901,"comment_content":"王老师你好，我想问您一个问题:在实际的项目中使用线程池并行执行任务的时候，是不是和数据库的交互都不要放在线程池当中","like_count":7,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448572,"discussion_content":"这个还是要看实际场景，主要是考虑数据库事务，还有线程池是不是隔离的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556590269,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90709,"user_name":"遇见阳光","can_delete":false,"product_type":"c1","uid":1203576,"ip_address":"","ucode":"378E5D37B3CD0E","user_header":"https://static001.geekbang.org/account/avatar/00/12/5d/78/f011d586.jpg","comment_is_top":false,"comment_ctime":1556614294,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"27326418070","product_id":100023901,"comment_content":"老师，我有一个疑问，如果说每个不同的业务都需要不同的线程池去处理，那这样线程池不是越来越多，这种应该如何解决","like_count":7,"discussions":[{"author":{"id":1174199,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ea/b7/1a18a39d.jpg","nickname":"5-刘新波(Arvin)","note":"","ucode":"DBD135D2587A93","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206188,"discussion_content":"需要控制各个线程池中线程的数量，线程池起了隔离和并发的作用，只有在最关键的地方用，比如“慢速”，“分发”等场景。大概就是这个意思","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584370797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369099,"discussion_content":"对操作系统来说都一样，虽然你自己有不同的池子","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618928773,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180569,"user_name":"美美","can_delete":false,"product_type":"c1","uid":1148422,"ip_address":"","ucode":"44CC95C45AF345","user_header":"https://static001.geekbang.org/account/avatar/00/11/86/06/72b01bb7.jpg","comment_is_top":false,"comment_ctime":1582339283,"is_pvip":false,"replies":[{"id":"70315","content":"有时候明明知道方法返回值不会为空，依然会判断一下，这个只是最佳实践而已","user_name":"作者回复","comment_id":180569,"uid":"1269969","ip_address":"","utype":1,"ctime":1582553889,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"18762208467","product_id":100023901,"comment_content":"2. signalAll() 总让人省心<br>如果非常明确的知道 只有一个线程在阻塞等待，明确的唤醒一个线程，这样不更好吗？","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484716,"discussion_content":"有时候明明知道方法返回值不会为空，依然会判断一下，这个只是最佳实践而已","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582553889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90553,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1556554304,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18736423488","product_id":100023901,"comment_content":"打卡，虽然没有深入了解每个工具类，但确实了解更多了。","like_count":5},{"had_liked":false,"id":219176,"user_name":"kimoti","can_delete":false,"product_type":"c1","uid":1897671,"ip_address":"","ucode":"0A78077408C2B1","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f4/c7/037235c9.jpg","comment_is_top":false,"comment_ctime":1589961387,"is_pvip":false,"replies":[{"id":"93196","content":"共享一个线程池，只要有一个阻塞方法，最终所有线程都会阻塞","user_name":"作者回复","comment_id":219176,"uid":"1269969","ip_address":"","utype":1,"ctime":1603458015,"user_name_real":"王宝令"}],"discussion_count":4,"race_medal":0,"score":"14474863275","product_id":100023901,"comment_content":"想请教老师一个问题，为什么当一个线程遇到阻塞式IO的时候，其他线程都会阻塞呢？<br>其他线程并没有遇到阻塞式IO呀。","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495703,"discussion_content":"共享一个线程池，只要有一个阻塞方法，最终所有线程都会阻塞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603458015,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1756574,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/icHLBNHJGoTGGF6vSDCgQg13cXvVgwyicAHu5icZtwJ9diaibj493mkCEXJ1bKc6Lqquaf4FnCzoxeGa5QIj77ZeCew/132","nickname":"Geek_c387a8","note":"","ucode":"643C6E82310DAB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":570760,"discussion_content":"这个问题我也有点疑问，目前看到只调用一次，意思是不是，如果是循环不停的调用或者很多地方使用CompletableFuture，最终线程池里所有线程都堵在那个阻塞方法里？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651904036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":495703,"ip_address":""},"score":570760,"extra":""}]},{"author":{"id":2179875,"avatar":"https://static001.geekbang.org/account/avatar/00/21/43/23/d98fb8f7.jpg","nickname":"Niverkk","note":"","ucode":"F9220C10107E44","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378455,"discussion_content":"并发，一次阻塞一个，最后不就全阻塞住了吗。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1623230227,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1219139,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9a/43/d6291e76.jpg","nickname":"Q宝的宝","note":"","ucode":"55C575755A4905","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367433,"discussion_content":"为啥会导致每个线程都阻塞呢，还是没明白","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618362676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91397,"user_name":"郑晨Cc","can_delete":false,"product_type":"c1","uid":1324942,"ip_address":"","ucode":"57146E444D6329","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/8e/cf0b4575.jpg","comment_is_top":false,"comment_ctime":1557025240,"is_pvip":false,"replies":[{"id":"34444","content":"finally都会执行","user_name":"作者回复","comment_id":91397,"uid":"1269969","ip_address":"","utype":1,"ctime":1558359361,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"14441927128","product_id":100023901,"comment_content":"老师 第一个while(true)的例子 怎么在释放锁之前就 break退出循环了？难道break不该在释放锁之后吗？","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448905,"discussion_content":"finally都会执行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558359361,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90793,"user_name":"ban","can_delete":false,"product_type":"c1","uid":1034204,"ip_address":"","ucode":"E523CE97E48266","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c7/dc/9408c8c2.jpg","comment_is_top":false,"comment_ctime":1556646014,"is_pvip":false,"replies":[{"id":"32574","content":"执行 check() 的时候，是不能同时执行 getPOrders() 和 getDOrders()，因为执行这两个方法的线程一个在等待，一个正在忙着执行 check()。","user_name":"作者回复","comment_id":90793,"uid":"1269969","ip_address":"","utype":1,"ctime":1556700295,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"10146580606","product_id":100023901,"comment_content":"老师，你好。<br>第五题的问题里面：通过源码你会发现 CyclicBarrier 是同步调用回调函数之后才唤醒等待的线程，如果我们在回调函数里直接调用 check() 方法，那就意味着在执行 check() 的时候，是不能同时执行 getPOrders() 和 getDOrders() 的。<br><br>意思是说如果回调函数直接执行chekc()方法，会让check()和（getPOrders() 和 getDOrders() ）变成串行的情况吗！","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448656,"discussion_content":"执行 check() 的时候，是不能同时执行 getPOrders() 和 getDOrders()，因为执行这两个方法的线程一个在等待，一个正在忙着执行 check()。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556700295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":318020,"user_name":"李剑","can_delete":false,"product_type":"c1","uid":2062321,"ip_address":"","ucode":"F37908267733AE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiaPl8VlycfEgPmuGacSAAdf08Ect7rfAtRzW2jiaslsPSicIDwibG8yObgcI0ooTLDl0zH4M17ziazjg/132","comment_is_top":false,"comment_ctime":1635125327,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5930092623","product_id":100023901,"comment_content":"并发工具应该都涉及到aqs吧 但这一块没看讲到","like_count":1},{"had_liked":false,"id":214669,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1588778570,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5883745866","product_id":100023901,"comment_content":"这章就是工具啊，只能理解每个工具的场景，才能熟练的应用，而具体的细节反倒不是非常重要了","like_count":1},{"had_liked":false,"id":354235,"user_name":"高志强","can_delete":false,"product_type":"c1","uid":1276563,"ip_address":"辽宁","ucode":"68737002043752","user_header":"https://static001.geekbang.org/account/avatar/00/13/7a/93/c9302518.jpg","comment_is_top":false,"comment_ctime":1660206709,"is_pvip":false,"replies":[{"id":"129095","content":"ppt","user_name":"作者回复","comment_id":354235,"uid":"1269969","ip_address":"辽宁","utype":1,"ctime":1660884254,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1660206709","product_id":100023901,"comment_content":"老师，我想问一下您文章中的流程图，使用什么工具画的呢","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584503,"discussion_content":"ppt","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660884255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":350029,"user_name":"码小呆","can_delete":false,"product_type":"c1","uid":2055809,"ip_address":"","ucode":"44532D6ABF9340","user_header":"https://static001.geekbang.org/account/avatar/00/1f/5e/81/82709d6e.jpg","comment_is_top":false,"comment_ctime":1656512658,"is_pvip":true,"replies":[{"id":"127520","content":"这个专栏可以叫&lt;java并发编程注&gt;，看这个专栏有助于看懂好多并发编程的书籍","user_name":"作者回复","comment_id":350029,"uid":"1269969","ip_address":"","utype":1,"ctime":1657004267,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1656512658","product_id":100023901,"comment_content":"看老师的课程,结合java并发编程实战结合,学习起来更加好呢~~","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578769,"discussion_content":"这个专栏可以叫&lt;java并发编程注&gt;，看这个专栏有助于看懂好多并发编程的书籍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657004267,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":269379,"user_name":"张洋","can_delete":false,"product_type":"c1","uid":1182914,"ip_address":"","ucode":"549BE5DEEF8417","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/c2/bad34a50.jpg","comment_is_top":false,"comment_ctime":1608628368,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1608628368","product_id":100023901,"comment_content":"之前还对CyclicBarrier 那篇使用一个新的线程池有疑问，通过今天的解答，茅塞顿开，是自己之前的理解片面了。","like_count":0},{"had_liked":false,"id":208765,"user_name":"InfoQ_e077cb303519","can_delete":false,"product_type":"c1","uid":1390669,"ip_address":"","ucode":"2CCA309DB2EF46","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLAK6F4BFT5ewhJEeZrjmRx5HxP8tvnNpJcpLlotHiadp0s6aL3d7LfMHEuQP6tibu80wUy8micVu4oQ/132","comment_is_top":false,"comment_ctime":1587434346,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587434346","product_id":100023901,"comment_content":"老师，在一个项目中线程池共享怎么实现比较好","like_count":0},{"had_liked":false,"id":186722,"user_name":"bbbi","can_delete":false,"product_type":"c1","uid":1682175,"ip_address":"","ucode":"9A539AEF791428","user_header":"https://static001.geekbang.org/account/avatar/00/19/aa/ff/e2c331e0.jpg","comment_is_top":false,"comment_ctime":1583911750,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583911750","product_id":100023901,"comment_content":"工具类确实有点多，而且都是实践性很强的，这一遍看仅仅是走马观花而已","like_count":0},{"had_liked":false,"id":117435,"user_name":"秋天","can_delete":false,"product_type":"c1","uid":1057056,"ip_address":"","ucode":"A7E1D953EF7E17","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/20/1299e137.jpg","comment_is_top":false,"comment_ctime":1564046788,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1564046788","product_id":100023901,"comment_content":"并发编程还需要多踩坑，最近就因为这个导致系统出现异常，而导致线系统cpu占满","like_count":0},{"had_liked":false,"id":112851,"user_name":"杨春鹏","can_delete":false,"product_type":"c1","uid":1172056,"ip_address":"","ucode":"518F38232F97B5","user_header":"https://static001.geekbang.org/account/avatar/00/11/e2/58/8c8897c8.jpg","comment_is_top":false,"comment_ctime":1562831420,"is_pvip":false,"replies":[{"id":"41242","content":"很像两阶段提交的场景，你可以试一试","user_name":"作者回复","comment_id":112851,"uid":"1269969","ip_address":"","utype":1,"ctime":1562940846,"user_name_real":"王宝令"}],"discussion_count":2,"race_medal":0,"score":"1562831420","product_id":100023901,"comment_content":"您好。我现在的业务需求：<br>只要有一个子线程失败，那么主线程以及其他子线程的事务也要进行回滚？<br>那怎么实现比较好一些。谢谢","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457929,"discussion_content":"很像两阶段提交的场景，你可以试一试","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562940846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018240,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/89/80/3666ced3.jpg","nickname":"黄浩特","note":"","ucode":"C3A4BBF4FB8519","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":34125,"discussion_content":"我觉得可以子线程不负责数据修改全部传回主线程进行修改, 主线程监督所有子线程的异常","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571160753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93961,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1557676363,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1557676363","product_id":100023901,"comment_content":"天呐，我一直以为执行check()的是 fixedPool中的的那唯一一个线程!","like_count":0,"discussions":[{"author":{"id":1063422,"avatar":"https://static001.geekbang.org/account/avatar/00/10/39/fe/99465085.jpg","nickname":"Adrian","note":"","ucode":"C11789EA4AFC69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4460,"discussion_content":"是fixedPool中的那个线程执行的，只不过是执行回调函数的线程唤起线程池将任务做掉了，丢给线程池做掉之后，当前线程就可以继续执行并发的getOrders这些操作了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1565437016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90886,"user_name":"捞鱼的搬砖奇","can_delete":false,"product_type":"c1","uid":1021539,"ip_address":"","ucode":"2FD194C4DA26E5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/96/63/7eb32c9b.jpg","comment_is_top":false,"comment_ctime":1556711261,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556711261","product_id":100023901,"comment_content":"老师能不能在上面提到的原文出错的代码边写上正确的做，并用注释说明","like_count":0},{"had_liked":false,"id":90601,"user_name":"苏志辉","can_delete":false,"product_type":"c1","uid":1068927,"ip_address":"","ucode":"39B25CE21C04EE","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/7f/5dc11380.jpg","comment_is_top":false,"comment_ctime":1556586644,"is_pvip":false,"replies":[{"id":"32446","content":"如果check就一个线程执行，应该不会","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556590584,"ip_address":"","comment_id":90601,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556586644","product_id":100023901,"comment_content":"第五个问题，我觉得应该先同步取完前两个节点再异步调用check逻辑，否则极端情况，取到的两个节点不是匹配的","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448589,"discussion_content":"如果check就一个线程执行，应该不会","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556590584,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}