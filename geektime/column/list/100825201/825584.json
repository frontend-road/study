{"id":825584,"title":"19｜商业意义（下）：如何利用端侧重排提升转化率","content":"<p>你好，我是柳博文。</p><p>这节课我们继续学习如何利用端侧重排提升转化率。上节课我们已经学习了传统算法里的代表——皮尔逊相关系数和Apriori算法。</p><p>今天，我们还会学习一些机器学习和深度学习里的典型算法。最后我还会为你演示如何在端侧把算法跑起来，最终实现转化率的提升。<br>\n好，话不多说，我们直接开始吧。</p><h2>机器学习算法代表</h2><p>在机器学习这个方向上，我们选择了kmeans和决策树算法。</p><h3>kmeans算法</h3><p>首先是kmeans算法，其原理是将用户分成不同的簇，每个簇表示一组具有相似点击行为的用户，之后就可以根据这些簇推荐定制化UI界面。</p><p>为了实现这个算法，针对需要处理的数据结构，我们可以使用用户属性和点击位置及卡片类型作为特征。然后应用K-Means聚类，将用户分为若干簇，根据聚类结果，向每个簇的用户展示不同的UI结构。</p><p>我们仍然使用NodeJS来实现，代码如下：</p><pre><code class=\"language-javascript\">const fs = require('fs');\nconst kmeans = require('node-kmeans');\n\n// 读取 JSON 文件中的数据\nconst data = JSON.parse(fs.readFileSync('../data/oneonewithcardtype.json', 'utf-8'));\n\n// 定义卡片类型区域\nconst regions = {\n&nbsp; bar: [0, 100],\n&nbsp; seckill: [150, 350],\n&nbsp; item_1: [370, 470],\n&nbsp; banner: [490, 590],\n&nbsp; item_2: [610, 710],\n&nbsp; item_3: [830, 930],\n&nbsp; item_4: [950, 1050],\n&nbsp; item_5: [1070, 1170],\n&nbsp; item_6: [1190, 1290],\n&nbsp; item_7: [1310, 1410],\n&nbsp; item_8: [1430, 1530],\n&nbsp; item_9: [1550, 1650],\n&nbsp; item_10: [1670, 1770],\n&nbsp; item_11: [1790, 1890],\n&nbsp; item_12: [1910, 2010],\n&nbsp; item_13: [2030, 2130],\n&nbsp; item_14: [2150, 2250],\n&nbsp; item_15: [2270, 2370],\n&nbsp; item_16: [2390, 2490],\n&nbsp; item_17: [2510, 2610],\n&nbsp; item_18: [2630, 2730],\n&nbsp; item_19: [2750, 2850],\n&nbsp; item_20: [2870, 2970],\n&nbsp; item_21: [2990, 3090],\n&nbsp; item_22: [3110, 3210],\n&nbsp; item_23: [3230, 3330],\n&nbsp; item_24: [3350, 3450],\n&nbsp; item_25: [3470, 3570],\n&nbsp; item_26: [3590, 3690],\n&nbsp; item_27: [3710, 3810],\n&nbsp; item_28: [3830, 3930],\n&nbsp; item_29: [3950, 4050],\n&nbsp; item_30: [4070, 4170],\n&nbsp; item_31: [4190, 4290],\n&nbsp; item_32: [4310, 4410],\n&nbsp; item_33: [4430, 4530],\n&nbsp; item_34: [4550, 4650],\n&nbsp; item_35: [4670, 4770],\n&nbsp; item_36: [4790, 4890],\n&nbsp; item_37: [5010, 5110],\n&nbsp; item_38: [5230, 5330],\n};\n\n// 将卡片类型映射到数值\nconst cardTypeToNumber = (cardType) =&gt; {\n&nbsp; return Object.keys(regions).indexOf(cardType);\n};\n\n// 将性别和年龄映射到数值\nconst genderToNumber = (gender) =&gt; (gender === 'male' ? 0 : 1);\n\nconst ageToNumber = (age) =&gt; {\n&nbsp; if (age &gt;= 18 &amp;&amp; age &lt;= 25) return 0;\n&nbsp; if (age &gt;= 26 &amp;&amp; age &lt;= 35) return 1;\n&nbsp; if (age &gt;= 36 &amp;&amp; age &lt;= 45) return 2;\n&nbsp; if (age &gt;= 46 &amp;&amp; age &lt;= 55) return 3;\n&nbsp; return 4; // 超过范围的年龄\n};\n\n// 转换数据格式以便进行聚类\nconst vectors = data.map((entry) =&gt; [\n&nbsp; genderToNumber(entry.gender),\n&nbsp; ageToNumber(entry.age),\n&nbsp; cardTypeToNumber(entry.clickCardType),\n]);\n\n// 设置聚类的数量\nconst numClusters = 3; // 可以调整聚类数量\n\n// 执行 K-means 聚类\nkmeans.clusterize(vectors, { k: numClusters }, (err, res) =&gt; {\n&nbsp; if (err) {\n&nbsp; &nbsp; console.error('K-means 聚类出错:', err);\n&nbsp; } else {\n&nbsp; &nbsp; console.log('K-means 聚类结果:');\n&nbsp; &nbsp; \n&nbsp; &nbsp; res.forEach((cluster, index) =&gt; {\n&nbsp; &nbsp; &nbsp; const userIds = cluster.clusterInd.map(pointIndex =&gt; data[pointIndex].userId);\n&nbsp; &nbsp; &nbsp; const uniqueUserIds = [...new Set(userIds)]; // 去重用户ID数组\n&nbsp; &nbsp; &nbsp; \n&nbsp; &nbsp; &nbsp; console.log(`\\n聚类 ${index + 1}：`);\n&nbsp; &nbsp; &nbsp; console.log(`质心：`, cluster.centroid);\n&nbsp; &nbsp; &nbsp; console.log(`用户ID数组：`, uniqueUserIds);\n&nbsp; &nbsp; });\n&nbsp; }\n});\n</code></pre><!-- [[[read_end]]] --><p>分别作用于数据A和数据B，算法输出是后面这样。</p><p><img src=\"https://static001.geekbang.org/resource/image/f1/08/f1fc36757b13199a6ee5d1908e73df08.jpg?wh=1542x861\" alt=\"\"></p><p>那么，我们可以对以上结果做一个分析：</p><p>首先是质心（质心是每个数据簇的中心点，它代表了该簇中所有数据点的“平均位置”）的三个维度，代表了用户点击行为特征。虽然第一个和第二个维度的差异较小，但在第三个维度上，用户群体的行为特征显著不同，反映了用户在特定条件下的点击行为变化。</p><p>然后是用户分布对比，聚类3的用户覆盖最广泛，其次是聚类2，聚类1的用户相对较少。其中，聚类2的质心值较高，可能表明该聚类用户的行为模式与其他群体不同。</p><p>根据以上结果分析，用户行为模式显示了UI交互中的显著差异。聚类2的用户表现出较强的目的性，他们进入页面后会迅速寻找所需商品。因此，这类用户适合提供个性化推荐，帮助他们快速找到心仪商品并下单。</p><p>而聚类1和3的用户目的性较弱，可能只是随意浏览，但也希望购买一些商品。对于这类用户，操作流程过于复杂就会导致用户流失。所以对于聚类1、3的用户，需要我们化简他们的操作流程，并根据群体特征动态调整UI布局。</p><h3>决策树算法</h3><p>接下来是决策树算法，决策树可以帮助我们识别用户属性（如性别、年龄）如何影响点击行为，从而为每种用户属性组合推荐最佳UI。</p><p>在实现决策树算法的过程中，我们将用户的属性和点击行为作为输入特征训练决策树模型，最后使用这个模型来用户的点击行为，使用决策树模型结果为不同用户定制推荐的UI卡片。</p><p>我们继续使用NodeJS来实现这样的决策树算法，代码如下：</p><pre><code class=\"language-javascript\">const DecisionTree = require('decision-tree');\nconst fs = require('fs');\n\n// 读取 JSON 文件中的数据\nconst rawData = fs.readFileSync('../data/oneonewithcardtype.json', 'utf-8');\nconst data = JSON.parse(rawData);\n\n// 准备训练数据\nconst trainingData = data.map(({ gender, age, clickCardType }) =&gt; ({\n&nbsp; gender: gender === 'male' ? 0 : 1, &nbsp;// 将性别转换为数值\n&nbsp; age,\n&nbsp; clickCardType\n}));\n\n// 过滤无效的标签并确保标签是有效的类\nconst validTrainingData = trainingData.filter(item =&gt; \n&nbsp; item.clickCardType !== undefined &amp;&amp; \n&nbsp; item.clickCardType !== null &amp;&amp;\n&nbsp; item.clickCardType !== '' // 检查空字符串\n);\n\nif (validTrainingData.length === 0) {\n&nbsp; throw new Error('No valid training data available.');\n}\n\n// 特征和标签\nconst features = ['gender', 'age'];\nconst labels = validTrainingData.map(item =&gt; item.clickCardType);\n\n// 创建并训练决策树\nconst decisionTree = new DecisionTree(validTrainingData, 'clickCardType', features);\n\n// 预测\nconst predictedLabel = decisionTree.predict({ gender: 0, age: 25 }); // 预测25岁男性用户的点击行为\nconsole.log('Predicted label:', predictedLabel);\n</code></pre><p>使用决策树算法对数据A和数据B都进行一次处理，同样对25岁男性进行预测。数据A的预测结果是 item_1，数据B的结果是item_23。也就是说这样的性别和年龄的组合下，用户在一排一的UI结构下偏好第一个商品，而在一排二这样的UI结构下，用户偏爱第23个商品。</p><p>这样一来，我们就可以根据进来的用户进行预测，将用户偏好的卡片放在显而易见的地方，也可以将用户偏好的卡片放在非第一屏的地方来激活长尾效应。</p><h2>深度学习算法代表</h2><p>最后是深度学习算法代表，这也是我们这节实践课重点要关注和学习的算法模型类型，这里我们选择LSTM（RNN）神经网络和卷积神经网络模型（CNN）算法。</p><p>这里大概梳理一下RNN和CNN的区别。</p><p>RNN 用于处理序列数据（如时间序列和文本），通过循环连接记忆之前的输入，适用于有时间依赖的数据。但它容易遇到梯度消失或爆炸的问题。</p><p>而CNN 擅长处理图像数据，通过卷积操作提取局部特征，对数据的空间结构敏感，适合图像分类、目标检测等任务。CNN 使用卷积核提取局部特征，计算复杂度主要与空间维度有关，易于并行计算。</p><p>选择 RNN 还是 CNN 取决于数据类型，也就是说处理时间序列数据适合用 RNN，处理图像数据适合 CNN。</p><p>对于RNN来说，LSTM，这是一种特殊的 RNN模型，擅长处理时间序列数据。哪怕你的数据并非典型的时间序列，但 LSTM 仍然能捕捉到用户行为的序列模式，尤其是在用户交互行为具有一定的时序或顺序依赖时效果会更好。</p><p>这里使用NodeJS结合synaptic来实现，代码如下:</p><pre><code class=\"language-javascript\">const fs = require('fs');\nconst synaptic = require('synaptic');\n\n\n// 读取 JSON 文件中的数据\nconst rawData = fs.readFileSync('../data/onetwowithcardtype.json', 'utf-8');\nconst data = JSON.parse(rawData);\n\n// 将数据转换为适合网络的输入格式\nconst processedData = data.map(item =&gt; ({\n&nbsp; &nbsp; gender: item.gender === 'male' ? 0 : 1,\n&nbsp; &nbsp; age: item.age,\n&nbsp; &nbsp; clickTime: new Date(item.clickTime).getTime(),\n&nbsp; &nbsp; clickPositionX: item.clickPosition.x,\n&nbsp; &nbsp; clickPositionY: item.clickPosition.y,\n&nbsp; &nbsp; clickCardType: item.clickCardType\n}));\n\n// 提取输入特征\nconst inputFeatures = processedData.map(item =&gt; [\n&nbsp; &nbsp; item.gender, \n&nbsp; &nbsp; item.age, \n&nbsp; &nbsp; item.clickTime, \n&nbsp; &nbsp; item.clickPositionX, \n&nbsp; &nbsp; item.clickPositionY\n]);\n\n// 提取标签 (clickCardType) 并将其转化为数值（假设有三个类型）\nconst cardTypes = Array.from(new Set(processedData.map(item =&gt; item.clickCardType)));\nconst labelMap = cardTypes.reduce((map, type, index) =&gt; (map[type] = index, map), {});\nconst labels = processedData.map(item =&gt; labelMap[item.clickCardType]);\n\n// 为神经网络准备训练数据\nconst trainingData = inputFeatures.map((input, index) =&gt; ({\n&nbsp; &nbsp; input: input,\n&nbsp; &nbsp; output: Array(cardTypes.length).fill(0).map((v, i) =&gt; i === labels[index] ? 1 : 0)\n}));\n\n// 创建并训练神经网络\nconst { Layer, Network } = synaptic;\nconst inputLayer = new Layer(5);\nconst hiddenLayer = new Layer(10);\nconst outputLayer = new Layer(cardTypes.length);\n\ninputLayer.project(hiddenLayer);\nhiddenLayer.project(outputLayer);\n\nconst net = new Network({\n&nbsp; &nbsp; input: inputLayer,\n&nbsp; &nbsp; hidden: [hiddenLayer],\n&nbsp; &nbsp; output: outputLayer\n})\n\nconst trainer = new synaptic.Trainer(net);\ntrainer.train(trainingData, {\n&nbsp; &nbsp; rate: 0.1,\n&nbsp; &nbsp; iterations: 100,\n&nbsp; &nbsp; error: 0.01,\n&nbsp; &nbsp; shuffle: true,\n&nbsp; &nbsp; log: 10\n});\n\n// 保存模型\nconst modelJSON = net.toJSON();\nfs.writeFileSync('./model.json', JSON.stringify(modelJSON));\n\nconsole.log('Model trained and saved successfully.');\n\n// 使用模型进行预测\nconst newUserData = [\n&nbsp; &nbsp; 0, // gender: male\n&nbsp; &nbsp; 25, // age\n&nbsp; &nbsp; new Date().getTime(), // current time\n&nbsp; &nbsp; 150, // clickPositionX\n&nbsp; &nbsp; 300 &nbsp;// clickPositionY\n];\n\n// 预测结果\nconst output = net.activate(newUserData);\nconst predictedIndex = output.indexOf(Math.max(...output));\nconst predictedLabel = cardTypes[predictedIndex];\nconsole.log('Predicted ClickCardType:', predictedLabel);  // Predicted ClickCardType: item_2\n</code></pre><p>在这个过程中，通过多次迭代训练，最终将训练完成的模型文件保存在文件中，这样我们就可以使用权重文件在进行预测了。最直观的使用方法就是预测用户喜欢点击的卡片的类型，然后将对应卡片放在整个页面醒目的地方，一次提升点击以及后续的数据转化。</p><p>那么，同样对于卷积神经网络，CNN 通常用于图像数据，但在特征数量较多的情况下，也能用来提取特征并做分类。特别是当你对点击数据进行高维度编码时，CNN 可以帮助识别局部特征模式。所以我们不妨用它来做一次测试，或许会有惊喜。</p><p>使用NodeJS加上synaptic实现一个CNN并完成训练和预测的代码如下：</p><pre><code class=\"language-javascript\">const synaptic = require('synaptic');\nconst fs = require('fs');\n\n// 读取 JSON 文件中的数据\nconst rawData = fs.readFileSync('../data/oneonewithcardtype.json', 'utf-8');\nconst data = JSON.parse(rawData);\n\n// 卡片类型映射\nconst cardTypes = [\n&nbsp; 'bar', 'seckill', 'item_1', 'banner', 'item_2', 'item_3', 'item_4', 'item_5',\n&nbsp; 'item_6', 'item_7', 'item_8', 'item_9', 'item_10', 'item_11', 'item_12', 'item_13',\n&nbsp; 'item_14', 'item_15', 'item_16', 'item_17', 'item_18', 'item_19', 'item_20', 'item_21',\n&nbsp; 'item_22', 'item_23', 'item_24', 'item_25', 'item_26', 'item_27', 'item_28', 'item_29',\n&nbsp; 'item_30', 'item_31', 'item_32', 'item_33', 'item_34', 'item_35', 'item_36', 'item_37',\n&nbsp; 'item_38'\n];\n\n// 数据预处理\nconst preprocessData = (data) =&gt; {\n&nbsp; return data.map(item =&gt; ({\n&nbsp; &nbsp; inputs: [item.age, item.gender === 'male' ? 0 : 1], // 示例中使用简单特征\n&nbsp; &nbsp; output: cardTypes.map(type =&gt; type === item.clickCardType ? 1 : 0) // 独热编码\n&nbsp; }));\n};\n\nconst processedData = preprocessData(data);\n\n// 定义一个简单的神经网络模型\nconst { Layer, Network } = synaptic;\n\n// 创建网络层\nconst inputLayer = new Layer(2); // 输入层：特征数\nconst hiddenLayer = new Layer(5); // 隐藏层的神经元数量\nconst outputLayer = new Layer(cardTypes.length); // 输出层：预测类别数量\n\n// 连接网络层\ninputLayer.project(hiddenLayer);\nhiddenLayer.project(outputLayer);\n\n// 创建网络\nconst network = new Network({\n&nbsp; input: inputLayer,\n&nbsp; hidden: [hiddenLayer],\n&nbsp; output: outputLayer\n});\n\n// 训练网络\nconst trainer = new synaptic.Trainer(network);\ntrainer.train(processedData, {\n&nbsp; rate: 0.01,\n&nbsp; iterations: 2000,\n&nbsp; error: 0.005\n});\n\n// 预测\nconst predict = (inputData) =&gt; {\n&nbsp; const output = network.activate(inputData);\n&nbsp; return cardTypes[output.indexOf(Math.max(...output))]; // 返回预测类别\n};\n\n// 示例预测\nconst prediction = predict([48, 0]); // 48岁男性的输入特征\nconsole.log('Prediction:', prediction);\n</code></pre><p>卷积神经网络模型的训练完成后，就能够使用模型来进行预测了，这里我们可以采取和RNN一样的思路逻辑来完成UI结构的优化。</p><h2>让算法跑在端侧</h2><p>有了训练好算法模型，以及根据算法预测制定的策略之后，想要完成端侧重排就很容易了。基于现代前端框架的客户端渲染（CSR）方式，可以选择在客户端处使用JavaScript动态调整UI结构，这也是为什么我们需要使用JavaScript版本的库来进行训练，这样可以直接快速地集成到页面代码中。</p><h2>总结</h2><p>让我们来做一个总结吧！这节课，我们继续尝试用将不同类型的算法作用在处理好的数据上，并对其算法处理结果进行分析。</p><p>其中，机器学习方向上，选择了 kmeans和决策树算法。在深度学习的方向上，我们分别尝试了RNN和CNN这两类具有代表性的算法模型。</p><p>K-means算法可以将用户根据其点击行为的相似性划分为不同的簇，每个簇代表了一类具有相似行为模式的用户。通过这些簇，我们可以为每个用户群体推荐个性化的UI界面。另一方面，决策树算法可以帮助我们分析用户的属性（如性别、年龄等）对点击行为的影响，从而为不同的用户属性组合提供最优的UI推荐。</p><p>接下来是RNN和CNN模型。我们之前提到的计算机视觉（CV）应用中使用了CNN，而RNN则是我们首次接触的模型。RNN特别适合处理序列数据（例如时间序列和文本），它通过循环连接保留之前输入的信息，因此能有效处理时间依赖性的数据。无论是RNN还是CNN，都是通过多轮迭代训练来优化模型，训练完成后再用模型进行预测。</p><p>最后，根据模型预测结果，我们可以通过CSR的方式，在客户端使用JavaScript来动态调控UI结构，以此来实现端侧重排。</p><h2>思考题</h2><p>为什么不能将UI的重排放在服务器端？</p><p>欢迎你在留言区和我交流讨论，如果这节课对你有启发，也推荐你把它分享给更多朋友。</p>","comments":[{"had_liked":false,"id":395752,"user_name":"很好玩","can_delete":false,"product_type":"c1","uid":1095703,"ip_address":"上海","ucode":"CA860B797EC3DE","user_header":"https://static001.geekbang.org/account/avatar/00/10/b8/17/3a54a2b6.jpg","comment_is_top":false,"comment_ctime":1731931115,"is_pvip":false,"replies":[{"id":143724,"content":"你好，同学\n\n是的，如果在客户端进行模型的推理，不仅实时而且安全，但是可能引出另外一个需要解决的问题，客户端的算力是有局限的，是可以深度思考一下这个问题如何解决~","user_name":"作者回复","user_name_real":"编辑","uid":3971025,"ctime":1732068787,"ip_address":"浙江","comment_id":395752,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100825201,"comment_content":"客户端可以更实时的拿到用户数据","like_count":0,"discussions":[{"author":{"id":3971025,"avatar":"https://static001.geekbang.org/account/avatar/00/3c/97/d1/52acf459.jpg","nickname":"柳博文","note":"","ucode":"1E60D52922548C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":654170,"discussion_content":"你好，同学\n\n是的，如果在客户端进行模型的推理，不仅实时而且安全，但是可能引出另外一个需要解决的问题，客户端的算力是有局限的，是可以深度思考一下这个问题如何解决~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1732068788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]}]}