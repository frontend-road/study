{"id":198614,"title":"45 | 工厂模式（下）：如何设计实现一个Dependency Injection框架？","content":"<p>在上一节课我们讲到，当创建对象是一个“大工程”的时候，我们一般会选择使用工厂模式，来封装对象复杂的创建过程，将对象的创建和使用分离，让代码更加清晰。那何为“大工程”呢？上一节课中我们讲了两种情况，一种是创建过程涉及复杂的if-else分支判断，另一种是对象创建需要组装多个其他类对象或者需要复杂的初始化过程。</p><p>今天，我们再来讲一个创建对象的“大工程”，依赖注入框架，或者叫依赖注入容器（Dependency Injection Container），简称DI容器。在今天的讲解中，我会带你一块搞清楚这样几个问题：DI容器跟我们讲的工厂模式又有何区别和联系？DI容器的核心功能有哪些，以及如何实现一个简单的DI容器？</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>工厂模式和DI容器有何区别？</h2><p>实际上，DI容器底层最基本的设计思路就是基于工厂模式的。DI容器相当于一个大的工厂类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。正是因为它持有一堆对象，所以这个框架才被称为“容器”。</p><p>DI容器相对于我们上节课讲的工厂模式的例子来说，它处理的是更大的对象创建工程。上节课讲的工厂模式中，一个工厂类只负责某个类对象或者某一组相关类对象（继承自同一抽象类或者接口的子类）的创建，而DI容器负责的是整个应用中所有类对象的创建。</p><!-- [[[read_end]]] --><p>除此之外，DI容器负责的事情要比单纯的工厂模式要多。比如，它还包括配置的解析、对象生命周期的管理。接下来，我们就详细讲讲，一个简单的DI容器应该包含哪些核心功能。</p><h2>DI容器的核心功能有哪些？</h2><p>总结一下，一个简单的DI容器的核心功能一般有三个：配置解析、对象创建和对象生命周期管理。</p><p><strong>首先，我们来看配置解析。</strong></p><p>在上节课讲的工厂模式中，工厂类要创建哪个类对象是事先确定好的，并且是写死在工厂类代码中的。作为一个通用的框架来说，框架代码跟应用代码应该是高度解耦的，DI容器事先并不知道应用会创建哪些对象，不可能把某个应用要创建的对象写死在框架代码中。所以，我们需要通过一种形式，让应用告知DI容器要创建哪些对象。这种形式就是我们要讲的配置。</p><p>我们将需要由DI容器来创建的类对象和创建类对象的必要信息（使用哪个构造函数以及对应的构造函数参数都是什么等等），放到配置文件中。容器读取配置文件，根据配置文件提供的信息来创建对象。</p><p>下面是一个典型的Spring容器的配置文件。Spring容器读取这个配置文件，解析出要创建的两个对象：rateLimiter和redisCounter，并且得到两者的依赖关系：rateLimiter依赖redisCounter。</p><pre><code>public class RateLimiter {\n  private RedisCounter redisCounter;\n  public RateLimiter(RedisCounter redisCounter) {\n    this.redisCounter = redisCounter;\n  }\n  public void test() {\n    System.out.println(&quot;Hello World!&quot;);\n  }\n  //...\n}\n\npublic class RedisCounter {\n  private String ipAddress;\n  private int port;\n  public RedisCounter(String ipAddress, int port) {\n    this.ipAddress = ipAddress;\n    this.port = port;\n  }\n  //...\n}\n\n配置文件beans.xml：\n&lt;beans&gt;\n   &lt;bean id=&quot;rateLimiter&quot; class=&quot;com.xzg.RateLimiter&quot;&gt;\n      &lt;constructor-arg ref=&quot;redisCounter&quot;/&gt;\n   &lt;/bean&gt;\n \n   &lt;bean id=&quot;redisCounter&quot; class=&quot;com.xzg.redisCounter&quot;&gt;\n     &lt;constructor-arg type=&quot;String&quot; value=&quot;127.0.0.1&quot;&gt;\n     &lt;constructor-arg type=&quot;int&quot; value=1234&gt;\n   &lt;/bean&gt;\n&lt;/beans&gt;\n</code></pre><p><strong>其次，我们再来看对象创建。</strong></p><p>在DI容器中，如果我们给每个类都对应创建一个工厂类，那项目中类的个数会成倍增加，这会增加代码的维护成本。要解决这个问题并不难。我们只需要将所有类对象的创建都放到一个工厂类中完成就可以了，比如BeansFactory。</p><p>你可能会说，如果要创建的类对象非常多，BeansFactory中的代码会不会线性膨胀（代码量跟创建对象的个数成正比）呢？实际上并不会。待会讲到DI容器的具体实现的时候，我们会讲“反射”这种机制，它能在程序运行的过程中，动态地加载类、创建对象，不需要事先在代码中写死要创建哪些对象。所以，不管是创建一个对象还是十个对象，BeansFactory工厂类代码都是一样的。</p><p><strong>最后，我们来看对象的生命周期管理。</strong></p><p>上一节课我们讲到，简单工厂模式有两种实现方式，一种是每次都返回新创建的对象，另一种是每次都返回同一个事先创建好的对象，也就是所谓的单例对象。在Spring框架中，我们可以通过配置scope属性，来区分这两种不同类型的对象。scope=prototype表示返回新创建的对象，scope=singleton表示返回单例对象。</p><p>除此之外，我们还可以配置对象是否支持懒加载。如果lazy-init=true，对象在真正被使用到的时候（比如：BeansFactory.getBean(“userService”)）才被被创建；如果lazy-init=false，对象在应用启动的时候就事先创建好。</p><p>不仅如此，我们还可以配置对象的init-method和destroy-method方法，比如init-method=loadProperties()，destroy-method=updateConfigFile()。DI容器在创建好对象之后，会主动调用init-method属性指定的方法来初始化对象。在对象被最终销毁之前，DI容器会主动调用destroy-method属性指定的方法来做一些清理工作，比如释放数据库连接池、关闭文件。</p><h2>如何实现一个简单的DI容器？</h2><p>实际上，用Java语言来实现一个简单的DI容器，核心逻辑只需要包括这样两个部分：配置文件解析、根据配置文件通过“反射”语法来创建对象。</p><h3>1.最小原型设计</h3><p>因为我们主要是讲解设计模式，所以，在今天的讲解中，我们只实现一个DI容器的最小原型。像Spring框架这样的DI容器，它支持的配置格式非常灵活和复杂。为了简化代码实现，重点讲解原理，在最小原型中，我们只支持下面配置文件中涉及的配置语法。</p><pre><code>配置文件beans.xml\n&lt;beans&gt;\n   &lt;bean id=&quot;rateLimiter&quot; class=&quot;com.xzg.RateLimiter&quot;&gt;\n      &lt;constructor-arg ref=&quot;redisCounter&quot;/&gt;\n   &lt;/bean&gt;\n \n   &lt;bean id=&quot;redisCounter&quot; class=&quot;com.xzg.redisCounter&quot; scope=&quot;singleton&quot; lazy-init=&quot;true&quot;&gt;\n     &lt;constructor-arg type=&quot;String&quot; value=&quot;127.0.0.1&quot;&gt;\n     &lt;constructor-arg type=&quot;int&quot; value=1234&gt;\n   &lt;/bean&gt;\n&lt;/bean\n</code></pre><p>最小原型的使用方式跟Spring框架非常类似，示例代码如下所示：</p><pre><code>public class Demo {\n  public static void main(String[] args) {\n    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\n            &quot;beans.xml&quot;);\n    RateLimiter rateLimiter = (RateLimiter) applicationContext.getBean(&quot;rateLimiter&quot;);\n    rateLimiter.test();\n    //...\n  }\n}\n</code></pre><h3>2.提供执行入口</h3><p>前面我们讲到，面向对象设计的最后一步是：组装类并提供执行入口。在这里，执行入口就是一组暴露给外部使用的接口和类。</p><p>通过刚刚的最小原型使用示例代码，我们可以看出，执行入口主要包含两部分：ApplicationContext和ClassPathXmlApplicationContext。其中，ApplicationContext是接口，ClassPathXmlApplicationContext是接口的实现类。两个类具体实现如下所示：</p><pre><code>public interface ApplicationContext {\n  Object getBean(String beanId);\n}\n\npublic class ClassPathXmlApplicationContext implements ApplicationContext {\n  private BeansFactory beansFactory;\n  private BeanConfigParser beanConfigParser;\n\n  public ClassPathXmlApplicationContext(String configLocation) {\n    this.beansFactory = new BeansFactory();\n    this.beanConfigParser = new XmlBeanConfigParser();\n    loadBeanDefinitions(configLocation);\n  }\n\n  private void loadBeanDefinitions(String configLocation) {\n    InputStream in = null;\n    try {\n      in = this.getClass().getResourceAsStream(&quot;/&quot; + configLocation);\n      if (in == null) {\n        throw new RuntimeException(&quot;Can not find config file: &quot; + configLocation);\n      }\n      List&lt;BeanDefinition&gt; beanDefinitions = beanConfigParser.parse(in);\n      beansFactory.addBeanDefinitions(beanDefinitions);\n    } finally {\n      if (in != null) {\n        try {\n          in.close();\n        } catch (IOException e) {\n          // TODO: log error\n        }\n      }\n    }\n  }\n\n  @Override\n  public Object getBean(String beanId) {\n    return beansFactory.getBean(beanId);\n  }\n}\n</code></pre><p>从上面的代码中，我们可以看出，ClassPathXmlApplicationContext负责组装BeansFactory和BeanConfigParser两个类，串联执行流程：从classpath中加载XML格式的配置文件，通过BeanConfigParser解析为统一的BeanDefinition格式，然后，BeansFactory根据BeanDefinition来创建对象。</p><h3>3.配置文件解析</h3><p>配置文件解析主要包含BeanConfigParser接口和XmlBeanConfigParser实现类，负责将配置文件解析为BeanDefinition结构，以便BeansFactory根据这个结构来创建对象。</p><p>配置文件的解析比较繁琐，不涉及我们专栏要讲的理论知识，不是我们讲解的重点，所以这里我只给出两个类的大致设计思路，并未给出具体的实现代码。如果感兴趣的话，你可以自行补充完整。具体的代码框架如下所示：</p><pre><code>public interface BeanConfigParser {\n  List&lt;BeanDefinition&gt; parse(InputStream inputStream);\n  List&lt;BeanDefinition&gt; parse(String configContent);\n}\n\npublic class XmlBeanConfigParser implements BeanConfigParser {\n\n  @Override\n  public List&lt;BeanDefinition&gt; parse(InputStream inputStream) {\n    String content = null;\n    // TODO:...\n    return parse(content);\n  }\n\n  @Override\n  public List&lt;BeanDefinition&gt; parse(String configContent) {\n    List&lt;BeanDefinition&gt; beanDefinitions = new ArrayList&lt;&gt;();\n    // TODO:...\n    return beanDefinitions;\n  }\n\n}\n\npublic class BeanDefinition {\n  private String id;\n  private String className;\n  private List&lt;ConstructorArg&gt; constructorArgs = new ArrayList&lt;&gt;();\n  private Scope scope = Scope.SINGLETON;\n  private boolean lazyInit = false;\n  // 省略必要的getter/setter/constructors\n \n  public boolean isSingleton() {\n    return scope.equals(Scope.SINGLETON);\n  }\n\n\n  public static enum Scope {\n    SINGLETON,\n    PROTOTYPE\n  }\n  \n  public static class ConstructorArg {\n    private boolean isRef;\n    private Class type;\n    private Object arg;\n    // 省略必要的getter/setter/constructors\n  }\n}\n</code></pre><h3>4.核心工厂类设计</h3><p>最后，我们来看，BeansFactory是如何设计和实现的。这也是我们这个DI容器最核心的一个类了。它负责根据从配置文件解析得到的BeanDefinition来创建对象。</p><p>如果对象的scope属性是singleton，那对象创建之后会缓存在singletonObjects这样一个map中，下次再请求此对象的时候，直接从map中取出返回，不需要重新创建。如果对象的scope属性是prototype，那每次请求对象，BeansFactory都会创建一个新的对象返回。</p><p>实际上，BeansFactory创建对象用到的主要技术点就是Java中的反射语法：一种动态加载类和创建对象的机制。我们知道，JVM在启动的时候会根据代码自动地加载类、创建对象。至于都要加载哪些类、创建哪些对象，这些都是在代码中写死的，或者说提前写好的。但是，如果某个对象的创建并不是写死在代码中，而是放到配置文件中，我们需要在程序运行期间，动态地根据配置文件来加载类、创建对象，那这部分工作就没法让JVM帮我们自动完成了，我们需要利用Java提供的反射语法自己去编写代码。</p><p>搞清楚了反射的原理，BeansFactory的代码就不难看懂了。具体代码实现如下所示：</p><pre><code>public class BeansFactory {\n  private ConcurrentHashMap&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;();\n  private ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefinitions = new ConcurrentHashMap&lt;&gt;();\n\n  public void addBeanDefinitions(List&lt;BeanDefinition&gt; beanDefinitionList) {\n    for (BeanDefinition beanDefinition : beanDefinitionList) {\n      this.beanDefinitions.putIfAbsent(beanDefinition.getId(), beanDefinition);\n    }\n\n    for (BeanDefinition beanDefinition : beanDefinitionList) {\n      if (beanDefinition.isLazyInit() == false &amp;&amp; beanDefinition.isSingleton()) {\n        createBean(beanDefinition);\n      }\n    }\n  }\n\n  public Object getBean(String beanId) {\n    BeanDefinition beanDefinition = beanDefinitions.get(beanId);\n    if (beanDefinition == null) {\n      throw new NoSuchBeanDefinitionException(&quot;Bean is not defined: &quot; + beanId);\n    }\n    return createBean(beanDefinition);\n  }\n\n  @VisibleForTesting\n  protected Object createBean(BeanDefinition beanDefinition) {\n    if (beanDefinition.isSingleton() &amp;&amp; singletonObjects.contains(beanDefinition.getId())) {\n      return singletonObjects.get(beanDefinition.getId());\n    }\n\n    Object bean = null;\n    try {\n      Class beanClass = Class.forName(beanDefinition.getClassName());\n      List&lt;BeanDefinition.ConstructorArg&gt; args = beanDefinition.getConstructorArgs();\n      if (args.isEmpty()) {\n        bean = beanClass.newInstance();\n      } else {\n        Class[] argClasses = new Class[args.size()];\n        Object[] argObjects = new Object[args.size()];\n        for (int i = 0; i &lt; args.size(); ++i) {\n          BeanDefinition.ConstructorArg arg = args.get(i);\n          if (!arg.getIsRef()) {\n            argClasses[i] = arg.getType();\n            argObjects[i] = arg.getArg();\n          } else {\n            BeanDefinition refBeanDefinition = beanDefinitions.get(arg.getArg());\n            if (refBeanDefinition == null) {\n              throw new NoSuchBeanDefinitionException(&quot;Bean is not defined: &quot; + arg.getArg());\n            }\n            argClasses[i] = Class.forName(refBeanDefinition.getClassName());\n            argObjects[i] = createBean(refBeanDefinition);\n          }\n        }\n        bean = beanClass.getConstructor(argClasses).newInstance(argObjects);\n      }\n    } catch (ClassNotFoundException | IllegalAccessException\n            | InstantiationException | NoSuchMethodException | InvocationTargetException e) {\n      throw new BeanCreationFailureException(&quot;&quot;, e);\n    }\n\n    if (bean != null &amp;&amp; beanDefinition.isSingleton()) {\n      singletonObjects.putIfAbsent(beanDefinition.getId(), bean);\n      return singletonObjects.get(beanDefinition.getId());\n    }\n    return bean;\n  }\n}\n</code></pre><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们来一块总结回顾一下，你需要重点掌握的内容。</p><p>DI容器在一些软件开发中已经成为了标配，比如Spring IOC、Google Guice。但是，大部分人可能只是把它当作一个黑盒子来使用，并未真正去了解它的底层是如何实现的。当然，如果只是做一些简单的小项目，简单会用就足够了，但是，如果我们面对的是非常复杂的系统，当系统出现问题的时候，对底层原理的掌握程度，决定了我们排查问题的能力，直接影响到我们排查问题的效率。</p><p>今天，我们讲解了一个简单的DI容器的实现原理，其核心逻辑主要包括：配置文件解析，以及根据配置文件通过“反射”语法来创建对象。其中，创建对象的过程就应用到了我们在学的工厂模式。对象创建、组装、管理完全有DI容器来负责，跟具体业务代码解耦，让程序员聚焦在业务代码的开发上。</p><h2>课堂讨论</h2><p>BeansFactory类中的createBean()函数是一个递归函数。当构造函数的参数是ref类型时，会递归地创建ref属性指向的对象。如果我们在配置文件中错误地配置了对象之间的依赖关系，导致存在循环依赖，那BeansFactory的createBean()函数是否会出现堆栈溢出？又该如何解决这个问题呢？</p><p>你可以可以在留言区说一说，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>","neighbors":{"left":{"article_title":"44 | 工厂模式（上）：我为什么说没事不要随便用工厂模式创建对象？","id":197254},"right":{"article_title":"46 | 建造者模式：详解构造函数、set方法、建造者模式三种对象创建方式","id":199674}},"comments":[{"had_liked":false,"id":179514,"user_name":"沈康","can_delete":false,"product_type":"c1","uid":1611025,"ip_address":"","ucode":"02AFA50738AB8E","user_header":"https://static001.geekbang.org/account/avatar/00/18/95/11/eb431e52.jpg","comment_is_top":false,"comment_ctime":1582018878,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"654417047870","product_id":100039001,"comment_content":"默默的掏出了《spring源码深度解析》回顾一番<br> 1、构造器循环依赖<br>构造器注入的循环依赖是无法解决的，只能抛出bean创建异常使容器无法启动<br>如何判断是循环依赖？<br>把正在创建的bean放入到一个(正在创建的map)中，如果依赖创建bean在此map中存在，则抛出异常。<br>2、setter方法循环依赖<br>①单例情况可以解决循环依赖，方法是提前暴露一个返回该单例的工厂方法，让依赖对象可以引用到<br>②多例不能解决循环依赖，因为多例不需要缓存","like_count":153,"discussions":[{"author":{"id":1796908,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/6b/2c/b27eefc5.jpg","nickname":"Abcd","note":"","ucode":"274C7487FDDC21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284628,"discussion_content":"你说的很对，c++编译器初期就是将c++代码翻译成c语言，然后调用c编译器","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592571733,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181074,"user_name":"undefined","can_delete":false,"product_type":"c1","uid":1587803,"ip_address":"","ucode":"867405CA5A9FB7","user_header":"https://static001.geekbang.org/account/avatar/00/18/3a/5b/ce1724ca.jpg","comment_is_top":false,"comment_ctime":1582470758,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"242100639334","product_id":100039001,"comment_content":"把本文的示例补全成了可执行代码：<br>https:&#47;&#47;github.com&#47;plusmancn&#47;learn-java&#47;tree&#47;master&#47;src&#47;main&#47;java&#47;Exercise&#47;di<br>顺便纠正一个笔误：<br>BeansFactory 下 createBean 方法中：singletonObjects.contains 应为 singletonObjects. containsKey","like_count":57,"discussions":[{"author":{"id":1097836,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","nickname":"随心而至","note":"","ucode":"31866865255101","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352963,"discussion_content":"跑了下，确实是可以的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614928537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1397298,"avatar":"https://static001.geekbang.org/account/avatar/00/15/52/32/bb570f48.jpg","nickname":"向往的生活","note":"","ucode":"0E8DB45357820F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288138,"discussion_content":"强","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593658903,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179629,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1582041624,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"156200864280","product_id":100039001,"comment_content":"20200218再次复习：<br>1. 研究了Spring容器中处理循环依赖的知识点：（1）只能处理单例的、setter注入的循环依赖，其他的注入模式无法处理；（2）依赖缓存处理循环依赖，关键思想是，将正在创建中的对象提前暴露一个单例工厂，让其他实例可以引用到<br>2. 网上一篇比较好的文章：https:&#47;&#47;juejin.im&#47;post&#47;5d0d8f64f265da1b7b3193ac","like_count":36,"discussions":[{"author":{"id":1438860,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f4/8c/0866b228.jpg","nickname":"子房","note":"","ucode":"CB05938C248BB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341550,"discussion_content":"不一样的 ， @Lazy 只是决定你的初始化行为，无法解决循环依赖的问题","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1610449924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1293907,"avatar":"https://static001.geekbang.org/account/avatar/00/13/be/53/eda4b622.jpg","nickname":"Smile @ Life","note":"","ucode":"320EDAD5A8BE56","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295062,"discussion_content":"没人用@Lazy 注解来处理单例循环依赖吗 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596077286,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217362,"user_name":"简单猫","can_delete":false,"product_type":"c1","uid":1866485,"ip_address":"","ucode":"EA027D4C344E25","user_header":"https://static001.geekbang.org/account/avatar/00/1c/7a/f5/54a5084b.jpg","comment_is_top":false,"comment_ctime":1589469791,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"130438488671","product_id":100039001,"comment_content":"不要被这些所谓的专业化名词吓到了 什么三级缓存。a依赖b，b依赖c，c依赖a,d依赖a，b，c什么的，你要解决的核心是不要重复创建。那么你就要把已经创建的对象存起来(map，hashmaps什么的) ，然后再次创建的时候先去缓存map中读取，没有才创建。 创建对象流程：1先反射创建类对象  2然后配置类里面的属性 方法(依赖就在这)。<br>至于你要怎么利用设计模式解耦 分3级缓存 分别存储完全实例化的对象  未设置属性方法类对象  还是对象工厂  那就看如何好用咯","like_count":31,"discussions":[{"author":{"id":1030842,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ba/ba/83de3488.jpg","nickname":"Carter","note":"","ucode":"1FD476D8F2BE27","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367397,"discussion_content":"问题是，创建a必须先有b，创建b又得先有a","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1618336671,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1613665,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9f/61/c46b42f4.jpg","nickname":"talkyoung","note":"","ucode":"8D231FA9004B64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1030842,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ba/ba/83de3488.jpg","nickname":"Carter","note":"","ucode":"1FD476D8F2BE27","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553941,"discussion_content":"楼主没看明白，别理他","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646138642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":367397,"ip_address":""},"score":553941,"extra":""}]}]},{"had_liked":false,"id":178284,"user_name":"此鱼不得水","can_delete":false,"product_type":"c1","uid":1257453,"ip_address":"","ucode":"95268E823FB4D2","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/ed/a87bb8fa.jpg","comment_is_top":false,"comment_ctime":1581650132,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"91775963348","product_id":100039001,"comment_content":"Spring解决循环依赖的办法是多级缓存。","like_count":21},{"had_liked":false,"id":210270,"user_name":"zhengyu.nie","can_delete":false,"product_type":"c1","uid":1541669,"ip_address":"","ucode":"FFE0377D323E46","user_header":"https://static001.geekbang.org/account/avatar/00/17/86/25/25ded6c3.jpg","comment_is_top":false,"comment_ctime":1587710908,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"57422285756","product_id":100039001,"comment_content":"基本就是Spring源码大体原型了，委托的BeanFactory在Spring源码里是DefaultListableBeanFactory。循环依赖解决是三级缓存，提前暴露还没有初始化结束的bean。检测是Map存一下过程，aba这样顺序判断，有重复（a出现两次）就是环了。<br><br>三级缓存源码对应<br>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton<br><br>&#47;**<br>\t * Return the (raw) singleton object registered under the given name.<br>\t * &lt;p&gt;Checks already instantiated singletons and also allows for an early<br>\t * reference to a currently created singleton (resolving a circular reference).<br>\t * @param beanName the name of the bean to look for<br>\t * @param allowEarlyReference whether early references should be created or not<br>\t * @return the registered singleton object, or {@code null} if none found<br>\t *&#47;<br>\t@Nullable<br>\tprotected Object getSingleton(String beanName, boolean allowEarlyReference) {<br>\t\tObject singletonObject = this.singletonObjects.get(beanName);<br>\t\tif (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {<br>\t\t\tsynchronized (this.singletonObjects) {<br>\t\t\t\tsingletonObject = this.earlySingletonObjects.get(beanName);<br>\t\t\t\tif (singletonObject == null &amp;&amp; allowEarlyReference) {<br>\t\t\t\t\tObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);<br>\t\t\t\t\tif (singletonFactory != null) {<br>\t\t\t\t\t\tsingletonObject = singletonFactory.getObject();<br>\t\t\t\t\t\tthis.earlySingletonObjects.put(beanName, singletonObject);<br>\t\t\t\t\t\tthis.singletonFactories.remove(beanName);<br>\t\t\t\t\t}<br>\t\t\t\t}<br>\t\t\t}<br>\t\t}<br>\t\treturn singletonObject;<br>\t}<br><br><br>\t&#47;** Cache of singleton objects: bean name to bean instance. *&#47;<br>\tprivate final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256);<br><br>\t&#47;** Cache of singleton factories: bean name to ObjectFactory. *&#47;<br>\tprivate final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;&gt;(16);<br><br>\t&#47;** Cache of early singleton objects: bean name to bean instance. *&#47;<br>\tprivate final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;&gt;(16);<br>","like_count":14},{"had_liked":false,"id":227044,"user_name":"王先森","can_delete":false,"product_type":"c1","uid":1022267,"ip_address":"","ucode":"1AF1A395107479","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/3b/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1592271789,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"40246977453","product_id":100039001,"comment_content":"php开发者默默的去瞅laravel的DI容器","like_count":10},{"had_liked":false,"id":178306,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1581657078,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"40236362742","product_id":100039001,"comment_content":"思考题:<br>①构造器初始化方式，无法解决循环依赖<br>②set注入方式初始化，有两种:<br>第一种，创建的是单例对象，可以解决。<br>第二种，创建的是原型对象，由于di容器不缓存对象导致无法提前暴露一个创建中的对象，依赖对象就会getbean时创建一个新对象，接着又进去循环依赖创建新对象…依然解决不了。","like_count":9},{"had_liked":false,"id":178322,"user_name":"勤劳的明酱","can_delete":false,"product_type":"c1","uid":1259140,"ip_address":"","ucode":"05EBE89B80371B","user_header":"https://static001.geekbang.org/account/avatar/00/13/36/84/788f0c60.jpg","comment_is_top":false,"comment_ctime":1581661385,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"31646432457","product_id":100039001,"comment_content":"思考题：<br> 构造器注入不好解决<br> setter注入：根据BenDefinition创建的bean可以是未完成的bean，就是说bean里面的属性可以是没有填充过的，这个时候bean依然能创建成功，之后属性，postConstruct、InitializingBean、init-method完成之后才能算是一个完整的bean，所以即使出现循环依赖也能解决。","like_count":7},{"had_liked":false,"id":178316,"user_name":"好吃不贵","can_delete":false,"product_type":"c1","uid":1316993,"ip_address":"","ucode":"6576E2BECE4F7C","user_header":"https://static001.geekbang.org/account/avatar/00/14/18/81/83b6ade2.jpg","comment_is_top":false,"comment_ctime":1581660385,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"31646431457","product_id":100039001,"comment_content":"createBean先用Topology sort看是否有环，然后再按序创建？","like_count":8,"discussions":[{"author":{"id":1904717,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/10/4d/3f4ae286.jpg","nickname":"Dimon Ho","note":"","ucode":"5B090E7FF6FC05","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374187,"discussion_content":"老师说的是如果这个常量只有这一个类中有使用，就在这个类中定义就好了，没必要放在Constants类中，如果这个常量在项目中多个地方使用，肯定还是要在Constants中定义的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621055097,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":178227,"user_name":"Geek_3b1096","can_delete":false,"product_type":"c1","uid":1549364,"ip_address":"","ucode":"A6BD92B79B3632","user_header":"","comment_is_top":false,"comment_ctime":1581624559,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"31646395631","product_id":100039001,"comment_content":"终于解答了我对于DI的疑惑","like_count":7,"discussions":[{"author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384238,"discussion_content":"同感","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626435296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181522,"user_name":"DullBird","can_delete":false,"product_type":"c1","uid":1110494,"ip_address":"","ucode":"80E2FD5F9687CB","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/de/3ebcbb3f.jpg","comment_is_top":false,"comment_ctime":1582554402,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"27352358178","product_id":100039001,"comment_content":"1. 我理解spring 解决A和B对象的循环引用是这样的流程是这样的，假设先加载A，丢一个A的引用到一个引用map&lt;id, ref&gt;，发现A有一个filed 引用B，就初始化B，丢一个B的引用到Map，初始化发现需要一个A，就从map里面找，找到了一个A，就把A的引用丢给B的属性，然后B加载结束了，A继续加载，拿到map里面的B，加载完成。","like_count":6,"discussions":[{"author":{"id":1313115,"avatar":"https://static001.geekbang.org/account/avatar/00/14/09/5b/e9ee3b41.jpg","nickname":"音为","note":"","ucode":"D78E4CBCE6BF45","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299915,"discussion_content":"逻辑错误，把a丢给b的时候a还没创建完成","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597853895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1313115,"avatar":"https://static001.geekbang.org/account/avatar/00/14/09/5b/e9ee3b41.jpg","nickname":"音为","note":"","ucode":"D78E4CBCE6BF45","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312267,"discussion_content":"如果是set方法依赖a就创建完成了，所以分构造器循环依赖和set方法循环依赖","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1602646022,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":299915,"ip_address":""},"score":312267,"extra":""},{"author":{"id":2874237,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/db/7d/a3510ae3.jpg","nickname":"凯林","note":"","ucode":"20A1024A7ECE17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544479,"discussion_content":"应该说提前暴露引用吧，并没有初始化完成","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641537018,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":312267,"ip_address":""},"score":544479,"extra":""}]}]},{"had_liked":false,"id":178463,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1581694280,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"23056530760","product_id":100039001,"comment_content":"关于思考题，对象的依赖关系应该是一个有向无环图（DAG），我倾向于在解析配置文件的时候检测是否存在环，不过这样在大型项目中可能性能不会太好。回头研究下Spring咋做的。","like_count":6},{"had_liked":false,"id":261995,"user_name":"郑大钱","can_delete":false,"product_type":"c1","uid":1503067,"ip_address":"","ucode":"114CF48056880E","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/5b/ff28088f.jpg","comment_is_top":false,"comment_ctime":1605601941,"is_pvip":false,"replies":[{"id":"96127","content":"说的好","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606701207,"ip_address":"","comment_id":261995,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18785471125","product_id":100039001,"comment_content":"“初级工程师在维护代码，高级工程师在设计代码，资深工程师在重构代码”<br>依赖注入框架好牛逼呀！当手把手教我设计一个框架之后，才破除了我对框架的权威和迷信。<br>自己最开始做业务也是在原有框架上面修修补补，回过头来看，发现自己非常能忍，即使原有的框架很难用，自己也能坚持用下去。<br>转念一想，那不是能忍，那是懒。懒得去理解框架的原理，懒得让它更易用。<br>像豌豆公主一样保持自己的敏感，是持续改进的动力。","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509684,"discussion_content":"说的好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606701207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":202523,"user_name":"xk_","can_delete":false,"product_type":"c1","uid":1514305,"ip_address":"","ucode":"DFE1AC38EA78A7","user_header":"https://static001.geekbang.org/account/avatar/00/17/1b/41/dbb7d785.jpg","comment_is_top":false,"comment_ctime":1586001628,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"18765870812","product_id":100039001,"comment_content":"回答一下课后题：<br>首先，我们不用spring创建对象去思考一下：<br>1.构造函数是不可能存在循环依赖的，因为作为参数依赖的对象必须提前存在，参数的创建也需要参数，所以不存在。<br>2.setter注入，A依赖B，B依赖A，只要最后形成闭环，就不会报错。<br>3. setter注入，创建A需要B，创建B需要新的A，创建新的A需要新的B…如此循环下去就会栈溢出了。<br><br>spring也正好是这样实现的。<br>对于第二点，spring是用三级缓存来实现的。","like_count":4},{"had_liked":false,"id":178917,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1581855208,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"18761724392","product_id":100039001,"comment_content":"循环依赖的意思是A依赖于B，B依赖于A（Bean A → Bean B → Bean A）出现循环依赖，首先应该考虑设计出了问题，应该重新划分类的职责。如果是老的项目，则可以按照其他小伙伴给出的解决方式。最好的解决方案还是看官方文档：链接在这里https:&#47;&#47;docs.spring.io&#47;spring&#47;docs&#47;current&#47;spring-framework-reference&#47;core.html#beans<br>Circular dependencies<br>If you use predominantly constructor injection, it is possible to create an unresolvable circular dependency scenario.<br><br>For example: Class A requires an instance of class B through constructor injection, and class B requires an instance of class A through constructor injection. If you configure beans for classes A and B to be injected into each other, the Spring IoC container detects this circular reference at runtime, and throws a BeanCurrentlyInCreationException.<br><br>One possible solution is to edit the source code of some classes to be configured by setters rather than constructors. Alternatively, avoid constructor injection and use setter injection only. In other words, although it is not recommended, you can configure circular dependencies with setter injection.<br><br>Unlike the typical case (with no circular dependencies), a circular dependency between bean A and bean B forces one of the beans to be injected into the other prior to being fully initialized itself (a classic chicken-and-egg scenario).","like_count":4},{"had_liked":false,"id":197853,"user_name":"change","can_delete":false,"product_type":"c1","uid":1110876,"ip_address":"","ucode":"D78B4B3752B6FE","user_header":"https://static001.geekbang.org/account/avatar/00/10/f3/5c/8704e784.jpg","comment_is_top":false,"comment_ctime":1585400850,"is_pvip":true,"discussion_count":1,"race_medal":5,"score":"10175335442","product_id":100039001,"comment_content":"工厂模式与DI容器<br>1、DI容器相当于一个大的工厂类,负责在程序启动,根据配置参数将所需要的对象都创建好,当程序需要时,直接从容器中获取某类对象;<br>2、工厂类只负责创建某一个或某一组类对象,而DI容器是创建整个应用所有需要的类对象<br>DI容器的基本功能<br>1、读取配置文件:配置文件中包含要创建的类对象及创建类对象的必要信息(使用那个构造函数及构造函数的参数列表);<br>2、创建对象:利用反射机制,动态加载类、创建对象;<br>3、对象生命周期管理:每次获取都返回新创建的对象(prototype)和每次获取都返回同一个事先创建好的对象(singleton,即单例对象),在单例对象中,还区分是否在程序启动时创建还是需要时创建(init-lazy);<br>DI容器接口设计<br>1、BeanConfigParser:解析配置文件<br>2、BeanFactory:根据解析配置的结果来创建对象;<br>1、ApplicationContext:DI容器内的上帝类(组装BeanFactory和ConfigParser),也是对外的接口;","like_count":3,"discussions":[{"author":{"id":1148142,"avatar":"https://static001.geekbang.org/account/avatar/00/11/84/ee/3a364ccd.jpg","nickname":"滇西之王","note":"","ucode":"B1EBFFAE3AECEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553140,"discussion_content":"公用的还是得提出来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645752073,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181016,"user_name":"yu","can_delete":false,"product_type":"c1","uid":1138645,"ip_address":"","ucode":"56856DCC0C8387","user_header":"https://static001.geekbang.org/account/avatar/00/11/5f/d5/2fec2911.jpg","comment_is_top":false,"comment_ctime":1582460194,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10172394786","product_id":100039001,"comment_content":"学习spring的时候老师讲过，当时就是背了一下，知道有这么回事儿，这回算是知道了来龙去脉","like_count":2},{"had_liked":false,"id":346751,"user_name":"Geek_d1f952","can_delete":false,"product_type":"c1","uid":2906259,"ip_address":"","ucode":"179570630107A0","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/bFOAzic4EYicm2U3mdHKl67uceibPpgM7QBC8nAGdMCC6PCiamolNIfw9rstzGCEBNiaIWkianFG28VZzOggcehkMic5A/132","comment_is_top":false,"comment_ctime":1653399487,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5948366783","product_id":100039001,"comment_content":"看着有点懵 这一讲对其他语言的同学不是很友好啊","like_count":2},{"had_liked":false,"id":344673,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1651719588,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"5946686884","product_id":100039001,"comment_content":"这里例子，过于限制语言了。对 java 用户友好，对其他用户似乎意义不大。","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503369,"discussion_content":"并不是都不能加的，必要的时候也可以加getter、setter的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597453600,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":340408,"user_name":"谢小路","can_delete":false,"product_type":"c1","uid":1035064,"ip_address":"","ucode":"C9FE2EB10DC105","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cb/38/4c9cfdf4.jpg","comment_is_top":false,"comment_ctime":1648802106,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5943769402","product_id":100039001,"comment_content":"羡慕这些学 Java 的，看的清清楚楚，你问问没接触 Java 看的累不？","like_count":1},{"had_liked":false,"id":215467,"user_name":"Pluto","can_delete":false,"product_type":"c1","uid":1038251,"ip_address":"","ucode":"E292AFAD428135","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d7/ab/15c9b94e.jpg","comment_is_top":false,"comment_ctime":1588996526,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"5883963822","product_id":100039001,"comment_content":"看了留言有些感慨，@Autowired 是什么注入方式？这种方式的循环依赖 Spring 可以自动解决吗？如果可以，哪种场景下可以解决？如果不行，哪种场景下不能解决？真的踩过坑的人才懂","like_count":1,"discussions":[{"author":{"id":1074897,"avatar":"https://static001.geekbang.org/account/avatar/00/10/66/d1/8664c464.jpg","nickname":"flyCoder","note":"","ucode":"82FB7B60775978","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":315933,"discussion_content":"大佬，不详细解释下？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603337885,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":189350,"user_name":"空白昵称","can_delete":false,"product_type":"c1","uid":1433815,"ip_address":"","ucode":"91F50CA25102AB","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/d7/744bd8c3.jpg","comment_is_top":false,"comment_ctime":1584504181,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5879471477","product_id":100039001,"comment_content":"作为一个swifter，我竟然也看懂了这里的demo实例代码。阅读java的能力果然在逐步提高。<br>关于练习部分，如果单例在创建时发生了环依赖，这时一定是错误的、此时就要检查配置了。如果是非单例参数依赖，个人感觉这里依赖关系设计应该趋向于树的形状，而非设计成有向图。如果发现依赖关系是图的形状，应该考虑调整整体实现代码架构了。不知道我理解对不对。<br>希望各位大神多多指点🙏","like_count":1},{"had_liked":false,"id":178768,"user_name":"FIGNT","can_delete":false,"product_type":"c1","uid":1540988,"ip_address":"","ucode":"D9DB185AE9E67C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKZ16iaIia0029oI1Qh5NicibpbTiaBAaCOPYXoLplKHr6uQ2rSVxPZanBvpMcL2NuhwKQYCFnaHP5tedQ/132","comment_is_top":false,"comment_ctime":1581820506,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5876787802","product_id":100039001,"comment_content":"这个争哥的数据结构与算法之美的递归有答案。对象依赖个数可以限制个大小，递归时如果超过该深度就报错。可能有更好的方式，期待老师的答案","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493263,"discussion_content":"后面会讲到的 你往后看看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588042140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":178341,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1018370,"ip_address":"","ucode":"7A488CC6FE15E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","comment_is_top":false,"comment_ctime":1581665193,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5876632489","product_id":100039001,"comment_content":"什么场景下使用工厂模式判断依据为：当创建对象是一个“大工程”时，一般使用工厂模式来实现，将对象的复杂逻辑封装起来，实现对象的创建和使用分离，使得代码结构更加清晰，类的职责更加单一，也体现了依赖反转原则。“大工程”的判断依据有两个：创建过程涉及复杂的if-else逻辑判断和对象创建需要组装多个其他类对象或者需要复杂的初始化过程。<br>Spring的IOC容器就是一个典型的工厂，当我们需要Bean时，只要正确的配置了对象创建需要的规则，他们通过IOC容器提供的接口就可以获取对象，实现了控制反转。<br>对于课堂讨论：会出现堆栈溢出StackOverflowError异常。","like_count":1},{"had_liked":false,"id":178257,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1581644425,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5876611721","product_id":100039001,"comment_content":"思考题：<br>1、如果循环依赖的类都是SINGLETON，不会出现堆栈溢出<br>2、如果循环依赖的类都是PROTOTYPE，本章的代码来看，的确会出现堆栈溢出；解决办法，可以做递归的深度控制。","like_count":1},{"had_liked":false,"id":352370,"user_name":"小学生的大铁锤","can_delete":false,"product_type":"c1","uid":1793606,"ip_address":"","ucode":"347B17A73FE7A6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/90DWsNicbNLJqRBLXWgM0t7AomqD4UpNnGFtkw4CorUg27tfuPfDiaImEMQkesCzzmFNicCPwHtYFjQ16Alf2fxjQ/132","comment_is_top":false,"comment_ctime":1658589368,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658589368","product_id":100039001,"comment_content":"通过spring IOC容器讲解了工厂方法模式的应用，明白了通过工厂方法模式隔离变化，隔离复杂的基本处理流程和效果。","like_count":0},{"had_liked":false,"id":340283,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1648718944,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648718944","product_id":100039001,"comment_content":"不是很明白  private List&lt;ConstructorArg&gt; constructorArgs = new ArrayList&lt;&gt;(); 这里为啥是获取的所有构造器参数？而不是所有构造器。","like_count":0},{"had_liked":false,"id":322582,"user_name":"风云","can_delete":false,"product_type":"c1","uid":1240650,"ip_address":"","ucode":"08A9E045664843","user_header":"","comment_is_top":false,"comment_ctime":1637487755,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637487755","product_id":100039001,"comment_content":"干货满满","like_count":0},{"had_liked":false,"id":322416,"user_name":"陆一鸣猜不动","can_delete":false,"product_type":"c1","uid":2831163,"ip_address":"","ucode":"68E89A037F9A0C","user_header":"https://static001.geekbang.org/account/avatar/00/2b/33/3b/0b25b622.jpg","comment_is_top":false,"comment_ctime":1637377410,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637377410","product_id":100039001,"comment_content":"感觉写好代码最重要的还是精准拆解功能的能力","like_count":0},{"had_liked":false,"id":320332,"user_name":"charmsongo","can_delete":false,"product_type":"c1","uid":1609051,"ip_address":"","ucode":"4FBEE716E93A1A","user_header":"https://static001.geekbang.org/account/avatar/00/18/8d/5b/383a49e4.jpg","comment_is_top":false,"comment_ctime":1636257842,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636257842","product_id":100039001,"comment_content":"总结<br>1、工厂模式和 DI 容器有何区别？<br>\t一个工厂类只负责某个类对象或者某一组相关类对象（继承自同一抽象类或者接口的子类）的创建，而 DI 容器负责的是整个应用中所有类对象的创建。<br>2、DI 容器的核心功能有哪些？<br>\t一个简单的 DI 容器的核心功能一般有三个：配置解析、对象创建和对象生命周期管理。<br>3、如何实现一个简单的 DI 容器？<br>\t核心逻辑只需要包括这样两个部分：配置文件解析、根据配置文件通过“反射”语法来创建对象。<br>\tBeansFactory 创建对象用到的主要技术点就是 Java 中的反射语法：一种动态加载类和创建对象的机制。","like_count":0},{"had_liked":false,"id":307656,"user_name":"Geek_b7eb88","can_delete":false,"product_type":"c1","uid":1573715,"ip_address":"","ucode":"0EB46381D9B1CB","user_header":"","comment_is_top":false,"comment_ctime":1629191091,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629191091","product_id":100039001,"comment_content":"这篇文章有点类似于iOS中，Runtime的类和对象。帮助我们知道类底层整体结构，方法调用等。","like_count":0},{"had_liked":false,"id":303728,"user_name":"Derek","can_delete":false,"product_type":"c1","uid":1572759,"ip_address":"","ucode":"AA6959B3E80019","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/SGkm1DWZU7d1FepiczXZvLahCWP5Px4aNdDRUJGBIy2IWuUSGaNRn8zdWMyr0wNEjx0zAPyac6h5ya1VFDbibicDQ/132","comment_is_top":false,"comment_ctime":1626946097,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626946097","product_id":100039001,"comment_content":"本人写的简化版的spring框架，有兴趣的小伙伴互相学习下，GitHub搜mini-spring","like_count":0},{"had_liked":false,"id":303727,"user_name":"Derek","can_delete":false,"product_type":"c1","uid":1572759,"ip_address":"","ucode":"AA6959B3E80019","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/SGkm1DWZU7d1FepiczXZvLahCWP5Px4aNdDRUJGBIy2IWuUSGaNRn8zdWMyr0wNEjx0zAPyac6h5ya1VFDbibicDQ/132","comment_is_top":false,"comment_ctime":1626945848,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1626945848","product_id":100039001,"comment_content":"本人写的简化版的spring框架，有兴趣的互相沟通学习下，地址：","like_count":0,"discussions":[{"author":{"id":1283461,"avatar":"https://static001.geekbang.org/account/avatar/00/13/95/85/15cd21c2.jpg","nickname":"杨锋","note":"","ucode":"85A7828A538FB0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284969,"discussion_content":"vue.js不是个框架吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592702542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":299470,"user_name":"Ivan.Qi","can_delete":false,"product_type":"c1","uid":1099170,"ip_address":"","ucode":"36F46A4D1F0EAA","user_header":"https://static001.geekbang.org/account/avatar/00/10/c5/a2/4ece341b.jpg","comment_is_top":false,"comment_ctime":1624646816,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624646816","product_id":100039001,"comment_content":"PHP依赖注入容器<br>https:&#47;&#47;github.com&#47;wuYin&#47;blog&#47;blob&#47;master&#47;php&#47;laravel-ioc-design-pattern-and-service-container.md","like_count":0},{"had_liked":false,"id":299229,"user_name":"孟庆祥","can_delete":false,"product_type":"c1","uid":1454705,"ip_address":"","ucode":"BA5CE528587DAD","user_header":"https://static001.geekbang.org/account/avatar/00/16/32/71/a4fbd9f3.jpg","comment_is_top":false,"comment_ctime":1624519646,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624519646","product_id":100039001,"comment_content":"public void addBeanDefinitions(List beanDefinitionList) { for (BeanDefinition beanDefinition : beanDefinitionList) { this.beanDefinitions.putIfAbsent(beanDefinition.getId(), beanDefinition); } for (BeanDefinition beanDefinition : beanDefinitionList) { if (beanDefinition.isLazyInit() == false &amp;&amp; beanDefinition.isSingleton()) { createBean(beanDefinition); } } }<br><br>这2个for循环是不是可以合成一个for循环","like_count":0},{"had_liked":false,"id":286621,"user_name":"人生若只如初见","can_delete":false,"product_type":"c1","uid":1254828,"ip_address":"","ucode":"6D9E2D10550210","user_header":"https://static001.geekbang.org/account/avatar/00/13/25/ac/44f8cc92.jpg","comment_is_top":false,"comment_ctime":1617433174,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617433174","product_id":100039001,"comment_content":"工厂模式示例：DI容器。<br>DI容器核心：配置文件解析、根据解析的类信息反射生成对象、管理对象生命周期。","like_count":0},{"had_liked":false,"id":285918,"user_name":"渊จุ๊บ","can_delete":false,"product_type":"c1","uid":1530295,"ip_address":"","ucode":"E3A2C1E89EB576","user_header":"https://static001.geekbang.org/account/avatar/00/17/59/b7/9db9c657.jpg","comment_is_top":false,"comment_ctime":1617074247,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617074247","product_id":100039001,"comment_content":"思考题：<br>我觉得可以用《数据结构与算法之美》里讲到的拓扑图来解决环依赖的问题。<br>我在https:&#47;&#47;github.com&#47;ClessLi&#47;bifrost项目里pkg&#47;resolv&#47;V2&#47;nginx&#47;loop_preventer.LoopPreventer里就用到这个机制，解决了nginx配置文件include子配置文件环加载","like_count":0},{"had_liked":false,"id":280848,"user_name":"御风","can_delete":false,"product_type":"c1","uid":1812807,"ip_address":"","ucode":"51C8212BE06364","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/47/ded5da90.jpg","comment_is_top":false,"comment_ctime":1614421663,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614421663","product_id":100039001,"comment_content":"把本文的示例补全了，发布在个人公众号上：<br>https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;b4fjeE1YTCYj95_VwVUAuA","like_count":0},{"had_liked":false,"id":267019,"user_name":"淤白","can_delete":false,"product_type":"c1","uid":1206503,"ip_address":"","ucode":"D1E65DC40DAF68","user_header":"https://static001.geekbang.org/account/avatar/00/12/68/e7/ee47d0e2.jpg","comment_is_top":false,"comment_ctime":1607571533,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607571533","product_id":100039001,"comment_content":"打卡：用Java实现了文中的案例。（配置解析逻辑后面自己抽时间再完善）","like_count":0},{"had_liked":false,"id":253601,"user_name":"RedDevil","can_delete":false,"product_type":"c1","uid":1131128,"ip_address":"","ucode":"F8F5DC209BB3B9","user_header":"https://static001.geekbang.org/account/avatar/00/11/42/78/7ba89c75.jpg","comment_is_top":false,"comment_ctime":1602810106,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602810106","product_id":100039001,"comment_content":"太棒了，从理论高度看spring","like_count":0},{"had_liked":false,"id":250856,"user_name":"大叶子","can_delete":false,"product_type":"c1","uid":1135900,"ip_address":"","ucode":"31CCDE9E88C023","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/1c/c76abe73.jpg","comment_is_top":false,"comment_ctime":1601262273,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601262273","product_id":100039001,"comment_content":"再次看 又有不一样的收获，仿佛只能是这样，理所应当，反射真的是一把‘利剑’","like_count":0},{"had_liked":false,"id":250092,"user_name":"王大喵","can_delete":false,"product_type":"c1","uid":1109528,"ip_address":"","ucode":"C14AAE3ED964DE","user_header":"https://static001.geekbang.org/account/avatar/00/10/ee/18/65e89d9c.jpg","comment_is_top":false,"comment_ctime":1600931388,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600931388","product_id":100039001,"comment_content":"在框架设计时，完全可以使用DI来通过配置控制组件的创建、组装和管理，对于框架来讲，一般是一些服务治理相关的组件，因为是框架，应该可以避免通过反射进行获取配置。<br>现况，公司框架每个基础组件会有一个类似的工厂类。","like_count":0},{"had_liked":false,"id":242345,"user_name":"","can_delete":false,"product_type":"c1","uid":2095026,"ip_address":"","ucode":"79DB151C0BFC63","user_header":"https://static001.geekbang.org/account/avatar/00/1f/f7/b2/b9d2d7d8.jpg","comment_is_top":false,"comment_ctime":1597676828,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597676828","product_id":100039001,"comment_content":"spring解决循环依赖为什么要用三级缓存呢，个人觉得2级就够了，第三级的用处没有想明白","like_count":0},{"had_liked":false,"id":240094,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1596761111,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596761111","product_id":100039001,"comment_content":"1 用一个map存储解析过的类名，当解析一个新类名时到map里查一下，如果已存在，直接报错返回<br>2 设置最深递归深度，例如64。超过该深度也报错返回，这样做是为了避免栈溢出","like_count":0},{"had_liked":false,"id":238700,"user_name":"冬渐暖","can_delete":false,"product_type":"c1","uid":1586800,"ip_address":"","ucode":"907E41AAE9A36C","user_header":"https://static001.geekbang.org/account/avatar/00/18/36/70/00122b24.jpg","comment_is_top":false,"comment_ctime":1596264842,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596264842","product_id":100039001,"comment_content":"ioc容器包含：读取解析配置文件。即 怎么创建对象（如控制对象的生命周期、获取源），用谁去创建(创建对象的工厂)","like_count":0},{"had_liked":false,"id":232086,"user_name":"少年锦时","can_delete":false,"product_type":"c1","uid":1313379,"ip_address":"","ucode":"70E2CFF88A0ACB","user_header":"https://static001.geekbang.org/account/avatar/00/14/0a/63/165b0d40.jpg","comment_is_top":false,"comment_ctime":1593852541,"is_pvip":false,"replies":[{"id":"85668","content":"也可以~","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1593909599,"ip_address":"","comment_id":232086,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1593852541","product_id":100039001,"comment_content":"beanDefinition.isLazyInit() == false  为什么不直接写成!beanDefinition.isLazyInit() 呢","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479660,"discussion_content":"后面有讲到的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577666020,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":227187,"user_name":"愤怒的虾干","can_delete":false,"product_type":"c1","uid":1266043,"ip_address":"","ucode":"CEBD1B2BE7BCEE","user_header":"https://static001.geekbang.org/account/avatar/00/13/51/7b/191a2112.jpg","comment_is_top":false,"comment_ctime":1592308897,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592308897","product_id":100039001,"comment_content":"使用栈代替递归创建，做到创建过程在当前类可控；使用集合记录正在创建的对象链，如果当前依赖存在与集合中，说明存在循环依赖。","like_count":0},{"had_liked":false,"id":226900,"user_name":"Leon Wong","can_delete":false,"product_type":"c1","uid":1073650,"ip_address":"","ucode":"B49B327367CF9E","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/f2/ca989d6f.jpg","comment_is_top":false,"comment_ctime":1592225661,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592225661","product_id":100039001,"comment_content":"循环依赖其实也很好解决，如果两个类出现了循环依赖，要么说明依赖不合理，要么说明你需要一个更高层的bean去囊括这两个bean，从而解决循环依赖","like_count":0},{"had_liked":false,"id":212732,"user_name":"Cutler","can_delete":false,"product_type":"c1","uid":1228136,"ip_address":"","ucode":"2EDECFE039845B","user_header":"https://static001.geekbang.org/account/avatar/00/12/bd/68/3fd6428d.jpg","comment_is_top":false,"comment_ctime":1588204825,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588204825","product_id":100039001,"comment_content":"可以限制递归调用的层级，比如超过100级就抛出异常，因为即使没有出现循环依赖，依赖关系超过100层也是不可接受的。","like_count":0},{"had_liked":false,"id":208406,"user_name":"Edward Lee","can_delete":false,"product_type":"c1","uid":1228518,"ip_address":"","ucode":"156223F1D7E94A","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/e6/7808520d.jpg","comment_is_top":false,"comment_ctime":1587351800,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587351800","product_id":100039001,"comment_content":"存在依赖关系的类创建，应属于无环图的一类，因此可以通过拓扑排序，确定类的创建顺序及检测是否存在环，如果存在环则说明配置错误，需抛出异常处理。","like_count":0},{"had_liked":false,"id":203247,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1586160399,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1586160399","product_id":100039001,"comment_content":"简单的东西复杂化了，每个人都有自己的理解。能够把简单的东西复杂化，也不是一件容易的事。","like_count":0},{"had_liked":false,"id":203241,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1586159812,"is_pvip":false,"discussion_count":2,"race_medal":1,"score":"1586159812","product_id":100039001,"comment_content":"在讲解原来的时候，能不能少用一些java的例子的，可以多用一下抽象的理论。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479450,"discussion_content":"这种情况就要脱邪恶也没办法 后面实战篇会讲到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577666588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":201368,"user_name":"@%初%@","can_delete":false,"product_type":"c1","uid":1053509,"ip_address":"","ucode":"2B8A6134675ED7","user_header":"https://static001.geekbang.org/account/avatar/00/10/13/45/16c60da2.jpg","comment_is_top":false,"comment_ctime":1585756694,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585756694","product_id":100039001,"comment_content":"setter注入<br>解决循环依赖，spring的做法如下，创建一个obejctFactory，提供懒加载的bean提前暴露，初始化工作，交给后面的beanPostProcessor去搞定。","like_count":0},{"had_liked":false,"id":189212,"user_name":"不学不行啊","can_delete":false,"product_type":"c1","uid":1335474,"ip_address":"","ucode":"69368165141C2D","user_header":"https://static001.geekbang.org/account/avatar/00/14/60/b2/ccebcb71.jpg","comment_is_top":false,"comment_ctime":1584488745,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584488745","product_id":100039001,"comment_content":"666","like_count":0},{"had_liked":false,"id":187758,"user_name":"刘伟龙","can_delete":false,"product_type":"c1","uid":1110912,"ip_address":"","ucode":"D009378493E753","user_header":"https://static001.geekbang.org/account/avatar/00/10/f3/80/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1584232055,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584232055","product_id":100039001,"comment_content":"createBean中catch抛出一个自定义异常，方法没抛异常，好像代码有问题","like_count":0},{"had_liked":false,"id":186228,"user_name":"睁眼看世界","can_delete":false,"product_type":"c1","uid":1206388,"ip_address":"","ucode":"F94CF34BC5B2AC","user_header":"https://static001.geekbang.org/account/avatar/00/12/68/74/461b202d.jpg","comment_is_top":false,"comment_ctime":1583805143,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583805143","product_id":100039001,"comment_content":"老师讲解的通俗易懂，一下子帮我解惑了spring-ioc的源码阅读，点赞；spring是由一个机制解决循环依赖问题的，创建bean的时候，分几个阶段。","like_count":0},{"had_liked":false,"id":185970,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1583734272,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583734272","product_id":100039001,"comment_content":"对于这个问题,我在看了评论区的留言后,并且复习了之前的Spring相关笔记,得出的答案是Spring中,如果循环是发生在构造函数中,那么无解,会直接抛出运行时异常,<br>而是通过setter方法设置进去的,如果允许了循环依赖,则可以在A设置参数之前,先暴露一个工厂方法,放在一个存储工厂类的Map中,然后B在生产的时候,能直接获取到这个工厂类,进行相关的生产,当然,这样解决循环依赖还是必须设置为单例,而且即使这样,使用过程中,还是会出现无限循环,导致栈溢出","like_count":0},{"had_liked":false,"id":185787,"user_name":"否极泰来","can_delete":false,"product_type":"c1","uid":1439355,"ip_address":"","ucode":"C249173266251A","user_header":"https://static001.geekbang.org/account/avatar/00/15/f6/7b/b6abcbbe.jpg","comment_is_top":false,"comment_ctime":1583678791,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583678791","product_id":100039001,"comment_content":"BeansFactory 类中的 createBean() 函数是一个递归函数。当构造函数的参数是 ref 类型时，会递归地创建 ref 属性指向的对象。如果我们在配置文件中错误地配置了对象之间的依赖关系，导致存在循环依赖，那 BeansFactory 的 createBean() 函数是否会出现堆栈溢出？又该如何解决这个问题呢？<br>如果循环依赖没有处理肯定会无限制创建对象导致溢出的<br>开发中是无法保证避免出现循环依赖，虽然类之间可能出现互相引用是设计不合理导致的（还可能是版本迭代），加上开发中每个人想法都不一样，还有可能是历史遗留问题<br>我之前就遇到过，我是-通过懒加载解决的","like_count":0},{"had_liked":false,"id":184629,"user_name":"二师兄","can_delete":false,"product_type":"c1","uid":1027034,"ip_address":"","ucode":"679D497472F5D2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ab/da/ab32124c.jpg","comment_is_top":false,"comment_ctime":1583374330,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583374330","product_id":100039001,"comment_content":"不是很熟悉JAVA，想知道：为什么引用要递归调用创建，记得JAVA对象都是引用吧？能和C++进行类比吗？","like_count":0},{"had_liked":false,"id":183249,"user_name":"jaryoung","can_delete":false,"product_type":"c1","uid":1077406,"ip_address":"","ucode":"6E72D107DB7E51","user_header":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","comment_is_top":false,"comment_ctime":1582982224,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1582982224","product_id":100039001,"comment_content":"说起来这个问题，为啥spring推荐使用构造器注入？通过构造器注入，能够很好发现循环依赖的问题所在。出现一个set和属性注入的，竟然大部分情况都不会出现循环依赖的问题，但是有时候启动的时候会偶尔发生循环依赖导致启动失败的情况。<br>说回正题，如果找出循环依赖，这个问题可以转化成如何判断是否有环吧？如果是的话，其实不是就特别好判断了呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479319,"discussion_content":"并没有说jdk是面向过程的啊 我是说jdk中也存在面向过程的设计","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577668528,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180920,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1582443147,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582443147","product_id":100039001,"comment_content":"设计模式_45:<br># 作业<br>1. 会导致堆栈溢出<br>2. 想到的办法是检测有向无环图，但真实的项目中一定会有循环依赖，如何解决这个问题，看了一下*Spring*中是通过*setter*依赖的方法来解决的，使用了3级缓存。<br><br># 感想<br>程序的一个作用就是高效解决重复的劳动，现在我搞出一个DI框架，用代码解决了一个重复的劳动：那就是写模板代码。","like_count":0},{"had_liked":false,"id":180406,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1582275158,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582275158","product_id":100039001,"comment_content":"课堂讨论Answer:    <br>可以尝试在解析时校验循环依赖. 即ApplicationContext实现类中的loadBeanDefinitions()方法中校验.<br>","like_count":0},{"had_liked":false,"id":178976,"user_name":"安静的boy","can_delete":false,"product_type":"c1","uid":1196475,"ip_address":"","ucode":"F5F44B75228A85","user_header":"https://static001.geekbang.org/account/avatar/00/12/41/bb/21ce60d2.jpg","comment_is_top":false,"comment_ctime":1581866267,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581866267","product_id":100039001,"comment_content":"看了这边文章突然对Spring的IOC有了一个清晰认识。","like_count":0},{"had_liked":false,"id":178906,"user_name":"平风造雨","can_delete":false,"product_type":"c1","uid":1014349,"ip_address":"","ucode":"F9EE4704F31E22","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/4d/b0228a1a.jpg","comment_is_top":false,"comment_ctime":1581851519,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1581851519","product_id":100039001,"comment_content":"createBean对refBean的依赖是不是可以理解成强依赖和弱依赖，如果是弱依赖的话，即使出现循环依赖，也可以继续执行被依赖bean的创建，等后续再检查这些不完整的Bean，走初始化逻辑。如果是强依赖，是不是只能抛异常出来？","like_count":0},{"had_liked":false,"id":178838,"user_name":"cricket1981","can_delete":false,"product_type":"c1","uid":1001715,"ip_address":"","ucode":"758262F5958DA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/f3/f1034ffd.jpg","comment_is_top":false,"comment_ctime":1581838938,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581838938","product_id":100039001,"comment_content":"不错，授教了！在老师的基础上改进了下，将bean配置属性class换成了index，通过反射获取到合适的构造函数","like_count":0},{"had_liked":false,"id":178663,"user_name":"桂城老托尼","can_delete":false,"product_type":"c1","uid":1306032,"ip_address":"","ucode":"139E4B8EE88B79","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJcxSpNMqwqyicMvdOSr9ic0p1ABiauHnv7g7YQVSJuoHPoQbYDu3YzdpgmSAk2KricUBQ5yibWBWIq75w/132","comment_is_top":false,"comment_ctime":1581775846,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581775846","product_id":100039001,"comment_content":"感谢分享，尝试回答下课堂讨论<br>1. scope = singleton 情况下是不会的，递归方法里如果存在了bean 则会直接返回。 如果是prototype 则需要每次调用都new出一个对象来，可能存在风险，spring 是怎么规避这个问题的，需要研究下代码。<br>2. ref 文中的实现目测没有检查 ref 的类型是否和对象的属性类型是否一致。","like_count":0},{"had_liked":false,"id":178631,"user_name":"chanllenge","can_delete":false,"product_type":"c1","uid":1213699,"ip_address":"","ucode":"148FC08C90BC58","user_header":"https://static001.geekbang.org/account/avatar/00/12/85/03/1a7d3dd6.jpg","comment_is_top":false,"comment_ctime":1581763028,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581763028","product_id":100039001,"comment_content":"这部分代码可以试着自己实现一遍，然后再看spring源码，应该就很好懂了，争哥讲的好","like_count":0},{"had_liked":false,"id":178562,"user_name":"程序员小跃","can_delete":false,"product_type":"c1","uid":1015483,"ip_address":"","ucode":"25BB96E0791A60","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","comment_is_top":false,"comment_ctime":1581744602,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1581744602","product_id":100039001,"comment_content":"意外之喜，还能在这里学到Spring相关的知识。状态越来越好，2020越来越好","like_count":0},{"had_liked":false,"id":178545,"user_name":"Ken张云忠","can_delete":false,"product_type":"c1","uid":1134288,"ip_address":"","ucode":"D0BAC9FC17DE2B","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","comment_is_top":false,"comment_ctime":1581738445,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581738445","product_id":100039001,"comment_content":"如果我们在配置文件中错误地配置了对象之间的依赖关系，导致存在循环依赖，那 BeansFactory 的 createBean() 函数是否会出现堆栈溢出？又该如何解决这个问题呢？<br>会出现堆栈溢出.<br>分析:配置了循环依赖后,原型模式和单例模式都会有因为无法将对象构建出来而一直递归调用的问题,最终导致堆栈溢出.<br>至于解决方式还需要向学友多多学习,构造器方式初始化应是无法解决的;<br>set注入方式中单例模式可以解决,但是原型模式还是会出现循环依赖创建实例的问题,这里也没法做循环依赖检测;<br>有的提出控制递归的深度和多级缓存,还没理解怎么处理.","like_count":0},{"had_liked":false,"id":178456,"user_name":"唐朝农民","can_delete":false,"product_type":"c1","uid":1133947,"ip_address":"","ucode":"6F8F43C6652225","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIaOAxRlZjFkGfRBn420LuAcyWkMrpq5iafGdqthX5icJPjql0ibZOAdafaqbfvw4ZpVzDmsaYglVXDw/132","comment_is_top":false,"comment_ctime":1581692669,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581692669","product_id":100039001,"comment_content":"不好意思我搞错了，这里在递归函数里处理了","like_count":0},{"had_liked":false,"id":178455,"user_name":"唐朝农民","can_delete":false,"product_type":"c1","uid":1133947,"ip_address":"","ucode":"6F8F43C6652225","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIaOAxRlZjFkGfRBn420LuAcyWkMrpq5iafGdqthX5icJPjql0ibZOAdafaqbfvw4ZpVzDmsaYglVXDw/132","comment_is_top":false,"comment_ctime":1581692484,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581692484","product_id":100039001,"comment_content":"BeansFactory中的46-51行那里 所有的ref 都是prototype的，是不是也应该判断其是否singleton的，如果是的话应该直接从singleObjects中获取呢","like_count":0},{"had_liked":false,"id":178426,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1581687803,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581687803","product_id":100039001,"comment_content":"原来 DI 容器是一个超级工厂","like_count":0},{"had_liked":false,"id":178388,"user_name":"webmin","can_delete":false,"product_type":"c1","uid":1047014,"ip_address":"","ucode":"98B0CA882454E8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/e6/47742988.jpg","comment_is_top":false,"comment_ctime":1581676489,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1581676489","product_id":100039001,"comment_content":"理论上如果没有进行循环依赖检测，就进行创建会出现堆栈溢出。<br>解决方法：在对象创建之前，先根据配置信息，把自己的id以及其ref所指向的引用，递归的找出来放入Hash表，检查是否发生碰撞。","like_count":0},{"had_liked":false,"id":178376,"user_name":"Geek_849ad3","can_delete":false,"product_type":"c1","uid":1817489,"ip_address":"","ucode":"E20321EF9BA86F","user_header":"","comment_is_top":false,"comment_ctime":1581672894,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581672894","product_id":100039001,"comment_content":"讲得很不错","like_count":0},{"had_liked":false,"id":178353,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1581667500,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1581667500","product_id":100039001,"comment_content":"写的真好，情人节的日子看这篇文章，别有一番滋味，","like_count":0},{"had_liked":false,"id":178294,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1581652776,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1581652776","product_id":100039001,"comment_content":"思考题：会出现栈溢出，比如 A--&gt;B--&gt;A, 创建Bean时，因为没有重复创建检测，会出现死循环，导致栈溢出，可以在添加一个正在创建bean的对象池，放入正在创建的对象，然后每次创建的时候，检查对象是否在池子中，如果在池子中，就说明存在循环依赖，直接抛出异常，让用户解决循环依赖的问题。","like_count":0},{"had_liked":false,"id":178256,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1581644339,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581644339","product_id":100039001,"comment_content":"小争哥这个DI框架已经有Spring IOC的雏形了🤘","like_count":0},{"had_liked":false,"id":178241,"user_name":"明翼","can_delete":false,"product_type":"c1","uid":1068361,"ip_address":"","ucode":"E77F86BEB3D5C1","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/49/28e73b9c.jpg","comment_is_top":false,"comment_ctime":1581640898,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581640898","product_id":100039001,"comment_content":"关于递归的判断我的理解是否可以保存一个list，里面保存依赖的class名，如果加入了依赖已经存在了，说明存在递归，则抛出异常","like_count":0}]}