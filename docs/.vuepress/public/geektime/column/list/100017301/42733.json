{"id":42733,"title":"16 | 二分查找（下）：如何快速定位IP对应的省份地址？","content":"<p>通过IP地址来查找IP归属地的功能，不知道你有没有用过？没用过也没关系，你现在可以打开百度，在搜索框里随便输一个IP地址，就会看到它的归属地。</p><p><img src=\"https://static001.geekbang.org/resource/image/c4/0a/c497770eca94fdf3baf4f813bafcb20a.jpg?wh=1520*676\" alt=\"\"></p><p>这个功能并不复杂，它是通过维护一个很大的IP地址库来实现的。地址库中包括IP地址范围和归属地的对应关系。</p><p>当我们想要查询202.102.133.13这个IP地址的归属地时，我们就在地址库中搜索，发现这个IP地址落在[202.102.133.0, 202.102.133.255]这个地址范围内，那我们就可以将这个IP地址范围对应的归属地“山东东营市”显示给用户了。</p><pre><code>[202.102.133.0, 202.102.133.255]  山东东营市 \n[202.102.135.0, 202.102.136.255]  山东烟台 \n[202.102.156.34, 202.102.157.255] 山东青岛 \n[202.102.48.0, 202.102.48.255] 江苏宿迁 \n[202.102.49.15, 202.102.51.251] 江苏泰州 \n[202.102.56.0, 202.102.56.255] 江苏连云港\n</code></pre><p>现在我的问题是，在庞大的地址库中逐一比对IP地址所在的区间，是非常耗时的。<strong><span class=\"orange\">假设我们有12万条这样的IP区间与归属地的对应关系，如何快速定位出一个IP地址的归属地呢？</span></strong></p><p>是不是觉得比较难？不要紧，等学完今天的内容，你就会发现这个问题其实很简单。</p><p>上一节我讲了二分查找的原理，并且介绍了最简单的一种二分查找的代码实现。今天我们来讲几种二分查找的变形问题。</p><p>不知道你有没有听过这样一个说法：“十个二分九个错”。二分查找虽然原理极其简单，但是想要写出没有Bug的二分查找并不容易。</p><p>唐纳德·克努特（Donald E.Knuth）在《计算机程序设计艺术》的第3卷《排序和查找》中说到：“尽管第一个二分查找算法于1946年出现，然而第一个完全正确的二分查找算法实现直到1962年才出现。”</p><!-- [[[read_end]]] --><p>你可能会说，我们上一节学的二分查找的代码实现并不难写啊。那是因为上一节讲的只是二分查找中最简单的一种情况，在不存在重复元素的有序数组中，查找值等于给定值的元素。最简单的二分查找写起来确实不难，但是，二分查找的变形问题就没那么好写了。</p><p>二分查找的变形问题很多，我只选择几个典型的来讲解，其他的你可以借助我今天讲的思路自己来分析。</p><p><img src=\"https://static001.geekbang.org/resource/image/42/36/4221d02a2e88e9053085920f13f9ce36.jpg?wh=1142*783\" alt=\"\"></p><p>需要特别说明一点，为了简化讲解，今天的内容，我都以数据是从小到大排列为前提，如果你要处理的数据是从大到小排列的，解决思路也是一样的。同时，我希望你最好先自己动手试着写一下这4个变形问题，然后再看我的讲述，这样你就会对我说的“二分查找比较难写”有更加深的体会了。</p><h2>变体一：查找第一个值等于给定值的元素</h2><p>上一节中的二分查找是最简单的一种，即有序数据集合中不存在重复的数据，我们在其中查找值等于某个给定值的数据。如果我们将这个问题稍微修改下，有序数据集合中存在重复的数据，我们希望找到第一个值等于给定值的数据，这样之前的二分查找代码还能继续工作吗？</p><p>比如下面这样一个有序数组，其中，a[5]，a[6]，a[7]的值都等于8，是重复的数据。我们希望查找第一个等于8的数据，也就是下标是5的元素。</p><p><img src=\"https://static001.geekbang.org/resource/image/50/f8/503c572dd0f9d734b55f1bd12765c4f8.jpg?wh=1142*284\" alt=\"\"></p><p>如果我们用上一节课讲的二分查找的代码实现，首先拿8与区间的中间值a[4]比较，8比6大，于是在下标5到9之间继续查找。下标5和9的中间位置是下标7，a[7]正好等于8，所以代码就返回了。</p><p>尽管a[7]也等于8，但它并不是我们想要找的第一个等于8的元素，因为第一个值等于8的元素是数组下标为5的元素。我们上一节讲的二分查找代码就无法处理这种情况了。所以，针对这个变形问题，我们可以稍微改造一下上一节的代码。</p><p>100个人写二分查找就会有100种写法。网上有很多关于变形二分查找的实现方法，有很多写得非常简洁，比如下面这个写法。但是，尽管简洁，理解起来却非常烧脑，也很容易写错。</p><pre><code>public int bsearch(int[] a, int n, int value) {\n  int low = 0;\n  int high = n - 1;\n  while (low &lt;= high) {\n    int mid = low + ((high - low) &gt;&gt; 1);\n    if (a[mid] &gt;= value) {\n      high = mid - 1;\n    } else {\n      low = mid + 1;\n    }\n  }\n\n  if (low &lt; n &amp;&amp; a[low]==value) return low;\n  else return -1;\n}\n</code></pre><p>看完这个实现之后，你是不是觉得很不好理解？如果你只是死记硬背这个写法，我敢保证，过不了几天，你就会全都忘光，再让你写，90%的可能会写错。所以，我换了一种实现方法，你看看是不是更容易理解呢？</p><pre><code>public int bsearch(int[] a, int n, int value) {\n  int low = 0;\n  int high = n - 1;\n  while (low &lt;= high) {\n    int mid =  low + ((high - low) &gt;&gt; 1);\n    if (a[mid] &gt; value) {\n      high = mid - 1;\n    } else if (a[mid] &lt; value) {\n      low = mid + 1;\n    } else {\n      if ((mid == 0) || (a[mid - 1] != value)) return mid;\n      else high = mid - 1;\n    }\n  }\n  return -1;\n}\n</code></pre><p>我来稍微解释一下这段代码。a[mid]跟要查找的value的大小关系有三种情况：大于、小于、等于。对于a[mid]&gt;value的情况，我们需要更新high= mid-1；对于a[mid]&lt;value的情况，我们需要更新low=mid+1。这两点都很好理解。那当a[mid]=value的时候应该如何处理呢？</p><p>如果我们查找的是任意一个值等于给定值的元素，当a[mid]等于要查找的值时，a[mid]就是我们要找的元素。但是，如果我们求解的是第一个值等于给定值的元素，当a[mid]等于要查找的值时，我们就需要确认一下这个a[mid]是不是第一个值等于给定值的元素。</p><p>我们重点看第11行代码。如果mid等于0，那这个元素已经是数组的第一个元素，那它肯定是我们要找的；如果mid不等于0，但a[mid]的前一个元素a[mid-1]不等于value，那也说明a[mid]就是我们要找的第一个值等于给定值的元素。</p><p>如果经过检查之后发现a[mid]前面的一个元素a[mid-1]也等于value，那说明此时的a[mid]肯定不是我们要查找的第一个值等于给定值的元素。那我们就更新high=mid-1，因为要找的元素肯定出现在[low, mid-1]之间。</p><p>对比上面的两段代码，是不是下面那种更好理解？实际上，<strong>很多人都觉得变形的二分查找很难写，主要原因是太追求第一种那样完美、简洁的写法</strong>。而对于我们做工程开发的人来说，代码易读懂、没Bug，其实更重要，所以我觉得第二种写法更好。</p><h2>变体二：查找最后一个值等于给定值的元素</h2><p>前面的问题是查找第一个值等于给定值的元素，我现在把问题稍微改一下，查找最后一个值等于给定值的元素，又该如何做呢？</p><p>如果你掌握了前面的写法，那这个问题你应该很轻松就能解决。你可以先试着实现一下，然后跟我写的对比一下。</p><pre><code>public int bsearch(int[] a, int n, int value) {\n  int low = 0;\n  int high = n - 1;\n  while (low &lt;= high) {\n    int mid =  low + ((high - low) &gt;&gt; 1);\n    if (a[mid] &gt; value) {\n      high = mid - 1;\n    } else if (a[mid] &lt; value) {\n      low = mid + 1;\n    } else {\n      if ((mid == n - 1) || (a[mid + 1] != value)) return mid;\n      else low = mid + 1;\n    }\n  }\n  return -1;\n}\n</code></pre><p>我们还是重点看第11行代码。如果a[mid]这个元素已经是数组中的最后一个元素了，那它肯定是我们要找的；如果a[mid]的后一个元素a[mid+1]不等于value，那也说明a[mid]就是我们要找的最后一个值等于给定值的元素。</p><p>如果我们经过检查之后，发现a[mid]后面的一个元素a[mid+1]也等于value，那说明当前的这个a[mid]并不是最后一个值等于给定值的元素。我们就更新low=mid+1，因为要找的元素肯定出现在[mid+1, high]之间。</p><h2>变体三：查找第一个大于等于给定值的元素</h2><p>现在我们再来看另外一类变形问题。在有序数组中，查找第一个大于等于给定值的元素。比如，数组中存储的这样一个序列：3，4，6，7，10。如果查找第一个大于等于5的元素，那就是6。</p><p>实际上，实现的思路跟前面的那两种变形问题的实现思路类似，代码写起来甚至更简洁。</p><pre><code>public int bsearch(int[] a, int n, int value) {\n  int low = 0;\n  int high = n - 1;\n  while (low &lt;= high) {\n    int mid =  low + ((high - low) &gt;&gt; 1);\n    if (a[mid] &gt;= value) {\n      if ((mid == 0) || (a[mid - 1] &lt; value)) return mid;\n      else high = mid - 1;\n    } else {\n      low = mid + 1;\n    }\n  }\n  return -1;\n}\n</code></pre><p>如果a[mid]小于要查找的值value，那要查找的值肯定在[mid+1, high]之间，所以，我们更新low=mid+1。</p><p>对于a[mid]大于等于给定值value的情况，我们要先看下这个a[mid]是不是我们要找的第一个值大于等于给定值的元素。如果a[mid]前面已经没有元素，或者前面一个元素小于要查找的值value，那a[mid]就是我们要找的元素。这段逻辑对应的代码是第7行。</p><p>如果a[mid-1]也大于等于要查找的值value，那说明要查找的元素在[low, mid-1]之间，所以，我们将high更新为mid-1。</p><h2>变体四：查找最后一个小于等于给定值的元素</h2><p>现在，我们来看最后一种二分查找的变形问题，查找最后一个小于等于给定值的元素。比如，数组中存储了这样一组数据：3，5，6，8，9，10。最后一个小于等于7的元素就是6。是不是有点类似上面那一种？实际上，实现思路也是一样的。</p><p>有了前面的基础，你完全可以自己写出来了，所以我就不详细分析了。我把代码贴出来，你可以写完之后对比一下。</p><pre><code>public int bsearch7(int[] a, int n, int value) {\n  int low = 0;\n  int high = n - 1;\n  while (low &lt;= high) {\n    int mid =  low + ((high - low) &gt;&gt; 1);\n    if (a[mid] &gt; value) {\n      high = mid - 1;\n    } else {\n      if ((mid == n - 1) || (a[mid + 1] &gt; value)) return mid;\n      else low = mid + 1;\n    }\n  }\n  return -1;\n}\n</code></pre><h2>解答开篇</h2><p>好了，现在我们回头来看开篇的问题：如何快速定位出一个IP地址的归属地？</p><p>现在这个问题应该很简单了。如果IP区间与归属地的对应关系不经常更新，我们可以先预处理这12万条数据，让其按照起始IP从小到大排序。如何来排序呢？我们知道，IP地址可以转化为32位的整型数。所以，我们可以将起始地址，按照对应的整型值的大小关系，从小到大进行排序。</p><p>然后，这个问题就可以转化为我刚讲的第四种变形问题“在有序数组中，查找最后一个小于等于某个给定值的元素”了。</p><p>当我们要查询某个IP归属地时，我们可以先通过二分查找，找到最后一个起始IP小于等于这个IP的IP区间，然后，检查这个IP是否在这个IP区间内，如果在，我们就取出对应的归属地显示；如果不在，就返回未查找到。</p><h2>内容小结</h2><p>上一节我说过，凡是用二分查找能解决的，绝大部分我们更倾向于用散列表或者二叉查找树。即便是二分查找在内存使用上更节省，但是毕竟内存如此紧缺的情况并不多。那二分查找真的没什么用处了吗？</p><p>实际上，上一节讲的求“值等于给定值”的二分查找确实不怎么会被用到，二分查找更适合用在“近似”查找问题，在这类问题上，二分查找的优势更加明显。比如今天讲的这几种变体问题，用其他数据结构，比如散列表、二叉树，就比较难实现了。</p><p>变体的二分查找算法写起来非常烧脑，很容易因为细节处理不好而产生Bug，这些容易出错的细节有：<strong>终止条件、区间上下界更新方法、返回值选择</strong>。所以今天的内容你最好能用自己实现一遍，对锻炼编码能力、逻辑思维、写出Bug free代码，会很有帮助。</p><h2>课后思考</h2><p>我们今天讲的都是非常规的二分查找问题，今天的思考题也是一个非常规的二分查找问题。如果有序数组是一个循环有序数组，比如4，5，6，1，2，3。针对这种情况，如何实现一个求“值等于给定值”的二分查找算法呢？</p><p>欢迎留言和我分享，我会第一时间给你反馈。</p>","neighbors":{"left":{"article_title":"15 | 二分查找（上）：如何用最省内存的方式实现快速查找功能？","id":42520},"right":{"article_title":"17 | 跳表：为什么Redis一定要用跳表来实现有序集合？","id":42896}},"comments":[{"had_liked":false,"id":35470,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":true,"comment_ctime":1540608546,"is_pvip":false,"discussion_count":41,"race_medal":0,"score":"9.2233746325555999e+18","product_id":100017301,"comment_content":"有三种方法查找循环有序数组<br> <br> 一、<br> 1. 找到分界下标，分成两个有序数组<br> 2. 判断目标值在哪个有序数据范围内，做二分查找<br> <br> 二、<br> 1. 找到最大值的下标 x;<br> 2. 所有元素下标 +x 偏移，超过数组范围值的取模;<br> 3. 利用偏移后的下标做二分查找；<br> 4. 如果找到目标下标，再作 -x 偏移，就是目标值实际下标。<br> <br> 两种情况最高时耗都在查找分界点上，所以时间复杂度是 O(N）。<br> <br> 复杂度有点高，能否优化呢？<br> <br> 三、<br>我们发现循环数组存在一个性质：以数组中间点为分区，会将数组分成一个有序数组和一个循环有序数组。<br> <br> 如果首元素小于 mid，说明前半部分是有序的，后半部分是循环有序数组；<br> 如果首元素大于 mid，说明后半部分是有序的，前半部分是循环有序的数组；<br> 如果目标元素在有序数组范围中，使用二分查找；<br> 如果目标元素在循环有序数组中，设定数组边界后，使用以上方法继续查找。<br> <br> 时间复杂度为 O(logN)。","like_count":605,"discussions":[{"author":{"id":1019069,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8c/bd/4895b166.jpg","nickname":"Chelizi","note":"","ucode":"B90CFDB5F7B900","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":259597,"discussion_content":"// Java 实现\n/**\n     * 用二分法查找值等于给定值的索引\n     * <p>\n     * 循环数组特性：以数组中间点为分区，会将数组分成一个有序数组和一个循环有序数组\n     * <p>\n     * 二分搜索法的关键在于获得了中间数后，判断下面要搜索左半段还是右半段，如果中间的数小于最右边的数，则右半段是有序的，若中间数大于最右边数，则左半段是有序的，我们只要在有序的半段里用首尾两个数组来判断目标值是否在这一区域内，这样就可以确定保留哪半边了\n     * <p>\n     * 时间复杂度为 O(logN)\n     *\n     * @param arr   循环有序数组，例如 [4，5，6，1，2，3]\n     * @param value\n     * @return\n     */\n    public int bsearchInCycleSortedArray(int[] arr, int value) {\n        int low = 0;\n        int high = arr.length - 1;\n\n        while (low <= high) {\n            int mid = low + ((high - low) >> 1);\n            if (arr[mid] == value) return mid;\n            // 如果中间元素小于尾元素，说明后半部分是有序的，前半部分是循环有序数组\n            if (arr[mid] < arr[high]) {\n                // 如果目标元素在有序数组范围中，使用二分查找\n                if (arr[mid] < value &amp;&amp; arr[high] >= value) low = mid + 1;\n                else high = mid - 1;\n            } else { // 如果中间元素大于尾元素，说明前半部分是有序的，后半部分是循环有序数组\n                if (arr[low] <= value &amp;&amp; arr[mid] > value) high = mid - 1;\n                else low = mid + 1;\n            }\n        }\n        return -1;\n    }","likes_number":12,"is_delete":false,"is_hidden":false,"ctime":1588781949,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2278126,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/7bq9uVY5BUF6M5beOUJ2CsZbuyPuoZIjBdxBkc57WF7ibBmSEkpffWFqSz6wjhSNW9vUuf3GK10xHW2QF5iaBD4Q/132","nickname":"Geek_125fab","note":"","ucode":"3855B652AECF03","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1019069,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8c/bd/4895b166.jpg","nickname":"Chelizi","note":"","ucode":"B90CFDB5F7B900","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346223,"discussion_content":"if (arr[mid] < arr[high])不能代表后半部分有序吧?比如：1,2,3,4,0,5,6,7","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611889337,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":259597,"ip_address":""},"score":346223,"extra":""},{"author":{"id":2028954,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f5/9a/63dc81a2.jpg","nickname":"Geek1185","note":"","ucode":"47BEE492EF4C1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2278126,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/7bq9uVY5BUF6M5beOUJ2CsZbuyPuoZIjBdxBkc57WF7ibBmSEkpffWFqSz6wjhSNW9vUuf3GK10xHW2QF5iaBD4Q/132","nickname":"Geek_125fab","note":"","ucode":"3855B652AECF03","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568739,"discussion_content":"你这不是循环有序数组","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1651216567,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":346223,"ip_address":""},"score":568739,"extra":""}]},{"author":{"id":1098987,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/eb/2285a345.jpg","nickname":"花晨少年","note":"","ucode":"6AA3537A6BA10E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":140026,"discussion_content":"前两个算法，既然是o(n)时间复杂度，那就没必要了，直接扫描整个数组就是两","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1579342382,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1246531,"avatar":"https://static001.geekbang.org/account/avatar/00/13/05/43/baac3bbb.jpg","nickname":"EyesOnMe","note":"","ucode":"981482EA89DC02","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1098987,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/eb/2285a345.jpg","nickname":"花晨少年","note":"","ucode":"6AA3537A6BA10E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573401,"discussion_content":"我也刚想说，搁这脑筋急转弯呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653389617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":140026,"ip_address":""},"score":573401,"extra":""}]},{"author":{"id":1008809,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/64/a9/27d63f2e.jpg","nickname":"佳楠","note":"","ucode":"A1698AE91992AA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46385,"discussion_content":"/**\n * 在 O(logN) 时间内，从循环有序数组里查找元素\n * 二分之后，总有一半是有序数组\n */\npublic static int searchInLoopSortedArray(int[] nums, int target) {\n    if(nums.length == 0) return -1;\n\n    int low = 0;\n    int high = nums.length - 1;\n\n    while (low <= high) {\n        int mid = low + ((high - low) >> 1);\n        if(nums[mid] == target) return mid;\n\n        if(nums[low] <= nums[mid]) {\n            if(nums[mid] > target  &amp;&amp; nums[low] <= target) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        } else if(nums[low] > nums[mid]) {\n            if(nums[mid] < target &amp;&amp; nums[high] >= target) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n\n    return  -1;\n}","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1573143019,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2292598,"avatar":"https://static001.geekbang.org/account/avatar/00/22/fb/76/71877cfc.jpg","nickname":"Geek_cec571","note":"","ucode":"19727B27AD904F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369677,"discussion_content":"/**\n     有三种方法查找循环有序数组\n\n     一、\n     1. 找到分界下标，分成两个有序数组 o(n)\n     2. 判断目标值在哪个有序数据范围内，做二分查找  O(logn)\n\n     二、\n     1. 找到最大值的下标 x; o(n)\n     2. 所有元素下标 +x 偏移，超过数组范围值的取模; o(n)\n     3. 利用偏移后的下标做二分查找； O(logn)\n     4. 如果找到目标下标，再作 -x 偏移，就是目标值实际下标。  o(1)\n\n\n     三、\n     我们发现循环数组存在一个性质：以数组中间点为分区，会将数组分成一个有序数组和一个循环有序数组。\n\n     如果首元素小于 mid，说明前半部分是有序的，后半部分是循环有序数组；\n     如果首元素大于 mid，说明后半部分是有序的，前半部分是循环有序的数组；\n     如果目标元素在有序数组范围中，使用二分查找；\n     如果目标元素在循环有序数组中，设定数组边界后，使用以上方法继续查找。\n\n     时间复杂度为 O(logN)。\n\n     此实现为三，每次淘汰一半元素，感觉最为优雅\n     */\n    private int bSearchLoopBSearch(int[] a, int low, int high, int value) {\n        while (low <= high) {\n            int mid = low + ((high - low) >> 1);\n            //判断在顺序递增部分还是在循环数组部分\n            if(a[mid] == value){\n                return mid;\n            }\n            if(a[low] <= a[mid]){\n                //循环段在右侧\n                if(a[low] <= value &amp;&amp; value < a[mid]){\n                    high = mid -1;\n                }else{\n                    low = mid + 1;\n                }\n            }else {\n                //循环段在左侧，\n                if(a[mid] < value &amp;&amp; value <= a[high]){\n                    low = mid + 1;\n                }else {\n                    high = mid -1;\n                }\n\n            }\n        }\n        return -1;\n    }","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1619115318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1476862,"avatar":"https://static001.geekbang.org/account/avatar/00/16/88/fe/c18a85fe.jpg","nickname":"随风","note":"","ucode":"037CE3554D8AB9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302990,"discussion_content":"python实现：\n def search(self, nums: List[int], target: int) -> int:\n        low = 0\n        high = len(nums) - 1\n        while low <= high:\n            mid = low + ((high - low) >> 1)\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < nums[low]:\n                # mid之后是有序的\n                if target >= nums[mid] and target <= nums[high]:\n                    low = mid\n                else:\n                    high = mid - 1\n            else:\n                # mid之前是有序的\n                if target >= nums[low] and target <= nums[mid]:\n                    high = mid\n                else:\n                    low = mid + 1\n        return -1\n","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1599105183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1528163,"avatar":"https://static001.geekbang.org/account/avatar/00/17/51/63/9da9ae1f.jpg","nickname":"Lib","note":"","ucode":"7A2BEC8100F2F6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":255490,"discussion_content":"python 实现第三种方式：\n\n        if not nums:  # empty array\n            return -1\n\n        l = 0\n        h = len(nums) - 1\n        while l <= h:\n            m = l + ((h - l) >> 1)\n            if nums[m] == target:  # find the target\n                return m\n            if nums[l] <= nums[m]:  # the first half is ordered\n                if nums[l] <= target < nums[m]:  # the target is in the first half\n                    h = m - 1\n                else:\n                    l = m + 1\n            else:  # the second half is ordered\n                if nums[m+1] <= target <= nums[h]:  # the target is in the second half\n                    l = m + 1\n                else:\n                    h = m - 1\n        return -1","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1588404911,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1448786,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/z4hFFGreQKeXzVG5eiaFuuWcMd6pibDdQwdNT5S29Eg92WjGgKBY8LRhvrGNqJwHsysWHMW4emiaEAKWKs4OoibPicQ/132","nickname":"strive","note":"","ucode":"0CC5A1B6490155","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214474,"discussion_content":"为什么是加最大值下标x偏移啊？不应该是加（n-1-x）偏移后才是有序的么？怎么理解啊？求帮助","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1585195932,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1599768,"avatar":"https://static001.geekbang.org/account/avatar/00/18/69/18/ca8a5c22.jpg","nickname":"收","note":"","ucode":"EC3338DB7AEF34","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1448786,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/z4hFFGreQKeXzVG5eiaFuuWcMd6pibDdQwdNT5S29Eg92WjGgKBY8LRhvrGNqJwHsysWHMW4emiaEAKWKs4OoibPicQ/132","nickname":"strive","note":"","ucode":"0CC5A1B6490155","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":239948,"discussion_content":"我也没理解上去","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587311170,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":214474,"ip_address":""},"score":239948,"extra":""},{"author":{"id":1589055,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKKKdCyib4iblXC6JIH7HWDfIFVweTb7SgEOuRjquic3GiaiaGInFSiaU8w2y2bjvZjgiaA3IEQuyibXTaeHQ/132","nickname":"10xiaohu","note":"","ucode":"CAB39DBB93E608","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1448786,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/z4hFFGreQKeXzVG5eiaFuuWcMd6pibDdQwdNT5S29Eg92WjGgKBY8LRhvrGNqJwHsysWHMW4emiaEAKWKs4OoibPicQ/132","nickname":"strive","note":"","ucode":"0CC5A1B6490155","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282081,"discussion_content":"作者应该是写错了，相信你自己👍👍","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591881838,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":214474,"ip_address":""},"score":282081,"extra":""},{"author":{"id":1358312,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b9/e8/0b3cf295.jpg","nickname":"HaiSky","note":"","ucode":"ECE7C263142432","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1599768,"avatar":"https://static001.geekbang.org/account/avatar/00/18/69/18/ca8a5c22.jpg","nickname":"收","note":"","ucode":"EC3338DB7AEF34","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294537,"discussion_content":"加X意思就是从最小的那个数开始计算（回归正常从小到大顺序查找）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595920662,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":239948,"ip_address":""},"score":294537,"extra":""}]},{"author":{"id":1563854,"avatar":"https://static001.geekbang.org/account/avatar/00/17/dc/ce/03fdeb60.jpg","nickname":"白色纯度","note":"","ucode":"7ABC830EE468A1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3963,"discussion_content":"可以用二分法找最大值下标，剑指offer有详解。复杂度是ｌｏｇN，不过代码要多写点了。给楼主个赞！","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1565007891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1257189,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2e/e5/ba06244e.jpg","nickname":"Johnny🐳","note":"","ucode":"A574E233832D2A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2667,"discussion_content":"还有一个前提是要判断数组是递增还是递减吧","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1563850202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2037714,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/17/d2/68cdbd75.jpg","nickname":"海狮","note":"","ucode":"18FDDF5841F282","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291807,"discussion_content":"分区分治，一个对比的是目标值，一个对比的是首元素，复杂度都是log(n)，所以合起来也是log(n)，妙啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594958610,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1049022,"avatar":"https://static001.geekbang.org/account/avatar/00/10/01/be/be358cab.jpg","nickname":"Kennedy","note":"","ucode":"C50627007E5ED0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288359,"discussion_content":"如果循环数组是{4 5 6 1 2 3 7 8 9 1 2 3},查找9，min 的值是7。如果按照三的操作方式，就找不到吧。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1593737665,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1035759,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cd/ef/0e779fff.jpg","nickname":"火耳","note":"","ucode":"589DC5598D8F2C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1049022,"avatar":"https://static001.geekbang.org/account/avatar/00/10/01/be/be358cab.jpg","nickname":"Kennedy","note":"","ucode":"C50627007E5ED0","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":291001,"discussion_content":"这个似乎不是循环有序数组","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1594657707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":288359,"ip_address":""},"score":291001,"extra":""},{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1049022,"avatar":"https://static001.geekbang.org/account/avatar/00/10/01/be/be358cab.jpg","nickname":"Kennedy","note":"","ucode":"C50627007E5ED0","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":317288,"discussion_content":"这不是有序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603529060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":288359,"ip_address":""},"score":317288,"extra":""},{"author":{"id":1939316,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/97/74/a933d664.jpg","nickname":"莜戏","note":"","ucode":"C3488A2BB44359","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1035759,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cd/ef/0e779fff.jpg","nickname":"火耳","note":"","ucode":"589DC5598D8F2C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351147,"discussion_content":"自信点，把似乎去掉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614166015,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":291001,"ip_address":""},"score":351147,"extra":""}]},{"author":{"id":1811611,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a4/9b/0967f397.jpg","nickname":"风，大风","note":"","ucode":"1A0F4D461BBC77","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263053,"discussion_content":"第三种感觉跟二分查找比较契合，用java实现了一下\npublic int loopFirstEqualSqrt(int[] data, int value){\n        int start = 0;\n        int end = data.length - 1;\n        int mid = -1;\n        while (start <= end){\n            mid = start + ((end - start)>>1);\n            if (data[0] > data[mid]){\n                if (data[mid] <= value &amp;&amp; data[data.length - 1] >= value){\n                    start = mid;\n                    break;\n                }\n                end = mid -1;\n            }else{\n                if (data[0] <= value &amp;&amp; data[mid] >= value){\n                    end = mid;\n                    break;\n                }\n                start = mid + 1;\n            }\n        }\n        while (start <= end){\n            mid = start + ((end - start)>>1);\n            if (data[mid] < value)\n                start = mid + 1;\n            else if(data[mid] > value)\n                end = mid - 1;\n            else {\n                if(mid==0||data[mid-1]!=value)return mid;\n                end = mid -1;\n            }\n        }\n        return -1;\n    }","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589167300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1172090,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e2/7a/38a27e47.jpg","nickname":"蓦然回首","note":"","ucode":"B17658DCFE6402","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333920,"discussion_content":"这样更复杂了，还是第一种更简洁，时间复杂度可能更低，下面的操作先不说是否正确，至少更复杂，更多要判断的地方!","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607673418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1172090,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e2/7a/38a27e47.jpg","nickname":"蓦然回首","note":"","ucode":"B17658DCFE6402","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333919,"discussion_content":"不过作者这里有个很重要的问题没有考虑进去：下标反向偏移有可能是负值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607673355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1172090,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e2/7a/38a27e47.jpg","nickname":"蓦然回首","note":"","ucode":"B17658DCFE6402","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333918,"discussion_content":"应该是作者写错了，不然转换不成正常的数组","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607673305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1172090,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e2/7a/38a27e47.jpg","nickname":"蓦然回首","note":"","ucode":"B17658DCFE6402","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333917,"discussion_content":"楼主没有理解错，上面的意思就是通过偏移，将下标转换成一个正常数组的下标来处理，找到middle后，再通过反向偏移，找到实际的下标值，从而得到真正的数组元素","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607673271,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2206029,"avatar":"https://static001.geekbang.org/account/avatar/00/21/a9/4d/c64803ea.jpg","nickname":"ZJUZZ","note":"","ucode":"E1E3446BC85592","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320897,"discussion_content":"第三种方法，如果是首元素等于mid呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604499966,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1939316,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/97/74/a933d664.jpg","nickname":"莜戏","note":"","ucode":"C3488A2BB44359","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2206029,"avatar":"https://static001.geekbang.org/account/avatar/00/21/a9/4d/c64803ea.jpg","nickname":"ZJUZZ","note":"","ucode":"E1E3446BC85592","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351146,"discussion_content":"一两个元素还分啥区，直接比较它不好嘛","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614165941,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":320897,"ip_address":""},"score":351146,"extra":""}]},{"author":{"id":1667491,"avatar":"https://static001.geekbang.org/account/avatar/00/19/71/a3/b881f08c.jpg","nickname":"L响","note":"","ucode":"012AE7EE725911","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300366,"discussion_content":"找分区点也可以使用二分法，从而时间复杂度是logN，那么前两种方法的时间复杂度可以达到logN，没错吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598065558,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1986914,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/51/62/770c1f72.jpg","nickname":"ym","note":"","ucode":"4C2DBB83731ACA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263737,"discussion_content":"数组中点不一定是分界点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589245119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1189727,"avatar":"https://static001.geekbang.org/account/avatar/00/12/27/5f/f9573d8b.jpg","nickname":"Geek_3a5591","note":"","ucode":"1E47569D818F95","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1986914,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/51/62/770c1f72.jpg","nickname":"ym","note":"","ucode":"4C2DBB83731ACA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269249,"discussion_content":"我想这句话应该是这样-【以数组中间点为分界点进行分区，会将数组分成一个有序数组和一个循环有序数组】","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589886491,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":263737,"ip_address":""},"score":269249,"extra":""},{"author":{"id":1457272,"avatar":"https://static001.geekbang.org/account/avatar/00/16/3c/78/9f052793.jpg","nickname":"LeeWong","note":"","ucode":"14A39710472221","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1189727,"avatar":"https://static001.geekbang.org/account/avatar/00/12/27/5f/f9573d8b.jpg","nickname":"Geek_3a5591","note":"","ucode":"1E47569D818F95","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288118,"discussion_content":"没听懂 中间点也不见得吧 循环有序 那个循环中的数据个数不一定一样吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593654735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":269249,"ip_address":""},"score":288118,"extra":""},{"author":{"id":1397631,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKVUskibDnhMt5MCIJ8227HWkeg2wEEyewps8GuWhWaY5fy7Ya56bu2ktMlxdla3K29Wqia9efCkWaQ/132","nickname":"衬衫的价格是19美元","note":"","ucode":"655F925451F772","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1986914,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/51/62/770c1f72.jpg","nickname":"ym","note":"","ucode":"4C2DBB83731ACA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310576,"discussion_content":"方法三的精髓是用一个中间点一定可以将一个循环有序数组分割成有序的部分和循环有序的部分","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601910252,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":263737,"ip_address":""},"score":310576,"extra":""}]},{"author":{"id":1537033,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJu6UPy60jo9osWZs00xZ54eHcxHjUTg5s8p6M7l2sUFQcibk9PVFxDIplD9ENFYfx4B5Ljicnmu0VQ/132","nickname":"Geek_python","note":"","ucode":"0F4AB46B923765","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":198061,"discussion_content":"找最大值下标，也是一个变体二分查找问题。判断num[mid-1] ＞num[mid] ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583468001,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008809,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/64/a9/27d63f2e.jpg","nickname":"佳楠","note":"","ucode":"A1698AE91992AA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46328,"discussion_content":"Leetcode 33 加了一个条件：\nYou may assume no duplicate exists in the array.\n所有有了这个条件， logN 的算法才生效","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573140603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1204050,"avatar":"https://static001.geekbang.org/account/avatar/00/12/5f/52/87c76776.jpg","nickname":"BboySticker","note":"","ucode":"44D0A9582BD21A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1008809,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/64/a9/27d63f2e.jpg","nickname":"佳楠","note":"","ucode":"A1698AE91992AA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50143,"discussion_content":"Leetcode 81. Search in Rotated Sorted Array II\n你说的是这题的情况，可以看下解答","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573680802,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":46328,"ip_address":""},"score":50143,"extra":""}]},{"author":{"id":1008809,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/64/a9/27d63f2e.jpg","nickname":"佳楠","note":"","ucode":"A1698AE91992AA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46308,"discussion_content":"面对这种数据场景，如何判断呢\nint nums = [1, 7, 0, 1, ,1, 1, 1]\nnums[mid=3] = 1\n\n由于 a[0] = a[mid]，a[6] = a[mid]，无法判断哪个部分是有序数组。\n是否这种情境下，需要进入递归。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573139707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1547322,"avatar":"https://static001.geekbang.org/account/avatar/00/17/9c/3a/bfd73920.jpg","nickname":"junjun","note":"","ucode":"1F7EE146B9BE04","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":18866,"discussion_content":"用二分查找找到最小的，然后因为是有序的，下一步就可以找到对应的值是否是查找的值了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569116409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1125988,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2e/64/df1a587b.jpg","nickname":"idioticbear","note":"","ucode":"E0ED5F497440F0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3396,"discussion_content":"牛批","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564455989,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1578981,"avatar":"https://static001.geekbang.org/account/avatar/00/18/17/e5/19c28271.jpg","nickname":"WonderSky","note":"","ucode":"7947B1370EB1E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2372,"discussion_content":"大赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563524421,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2055898,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/5e/da/9064df96.jpg","nickname":".","note":"","ucode":"77609EE91386C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1578981,"avatar":"https://static001.geekbang.org/account/avatar/00/18/17/e5/19c28271.jpg","nickname":"WonderSky","note":"","ucode":"7947B1370EB1E2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293417,"discussion_content":"    旋转数组分为两段有序数组，且其中一部分的最大值不大于另一部分的最小值。\n    首先我们初步确定要查找的值所在的区间是左半段还是右半段，在更新区间时同时判断区间中点属于哪半段，结合两者更新区间端点。\n    若出现区间落在一个半段中，则问题退化为一般的二分查找问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595523803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2372,"ip_address":""},"score":293417,"extra":""}]}]},{"had_liked":false,"id":36203,"user_name":"zixuan","can_delete":false,"product_type":"c1","uid":1131300,"ip_address":"","ucode":"C72920DD05B074","user_header":"https://static001.geekbang.org/account/avatar/00/11/43/24/3f9f7c70.jpg","comment_is_top":false,"comment_ctime":1540975852,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"1002268355820","product_id":100017301,"comment_content":"思考题对应leetcode 33题，大家可以去练习","like_count":234,"discussions":[{"author":{"id":1268788,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/D9iciayk2kC7VxrsiauxngbMhcicm6CZiaXBa4JNbVdRqQ5HIpoqPzRptbttMdaGnTaUqZsEyW4kyZA2cyiaZCwZrWGA/132","nickname":"Jim","note":"","ucode":"E3E8F9A527D6DB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":167955,"discussion_content":"最好自己实现一版，你会发现官方的题解水平太次了","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1581525182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2538092,"avatar":"","nickname":"懒猫","note":"","ucode":"094F30C802C0F6","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1268788,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/D9iciayk2kC7VxrsiauxngbMhcicm6CZiaXBa4JNbVdRqQ5HIpoqPzRptbttMdaGnTaUqZsEyW4kyZA2cyiaZCwZrWGA/132","nickname":"Jim","note":"","ucode":"E3E8F9A527D6DB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543543,"discussion_content":"我觉得官方解挺巧妙的，请问大佬对这题有什么高见","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641199869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":167955,"ip_address":""},"score":543543,"extra":""}]},{"author":{"id":1238836,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e7/34/2640b1e4.jpg","nickname":"Leon","note":"","ucode":"AF26BB602B8705","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24006,"discussion_content":"&#34;循环有序数组&#34;很难理解成&#34;旋转数组&#34;。\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1569978956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1592279,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","nickname":"William Ning","note":"","ucode":"4DB8D05E69E5F3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387683,"discussion_content":"https://leetcode-cn.com/problems/search-in-rotated-sorted-array/","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628344662,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35516,"user_name":"舍得","can_delete":false,"product_type":"c1","uid":1147685,"ip_address":"","ucode":"2146A08D2D79B6","user_header":"https://static001.geekbang.org/account/avatar/00/11/83/25/10dac87c.jpg","comment_is_top":false,"comment_ctime":1540634697,"is_pvip":false,"replies":[{"id":"12742","content":"谢谢指正 我稍后改下","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540812253,"ip_address":"","comment_id":35516,"utype":1}],"discussion_count":7,"race_medal":0,"score":"293598410825","product_id":100017301,"comment_content":"第一段代码有漏洞，且不说int能不能表示数组的下标问题，毕竟这个数组能越界说明相当庞大了；<br>主要问题在于，如果我给定的数大于任何一个数组元素，low就会等于n，n是数组越界后的第一个元素，如果它刚好是要查找的值呢？？","like_count":68,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427561,"discussion_content":"谢谢指正 我稍后改下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540812253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1242358,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f4/f6/3ec43eb7.jpg","nickname":"逝水流","note":"","ucode":"F815BF2C4DC321","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384195,"discussion_content":"感觉这个问题已经修复了，这个应该是指if (low < n &amp;&amp; a[low]==value) return low; 这里如果没有low<n，直接判断a[low]==value的情况，如果是c语言，并不会报数组越界错误，而是根据越界值n对应的地址查找数据，如果这个时候这个地址存储的数据正好也是value这个值，那么就会出现a[low]==value。但是这时的数据，并不是我们期望的数组内的数据。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1626420980,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2613627,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/IXd7rNYSNfgk3CpDRsqic1I0NIamEY0NPEQnibRagn5scPNVkHQ3V0sAnq8O9jgaUxnIibvsjOn3zVjCphC00tJ6w/132","nickname":"周扬","note":"","ucode":"3DE5210624C38E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382283,"discussion_content":"问题作者已经在修复了哈，就是结尾的那句low小于n就是，大家不要方","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1625495668,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2440496,"avatar":"https://static001.geekbang.org/account/avatar/00/25/3d/30/9e5e5d4d.jpg","nickname":"巴菲特不非","note":"","ucode":"9E2B911ED5BF08","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352775,"discussion_content":"？？？？？？是作者改了吗，不知道你说哪里出错了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614846580,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181206,"avatar":"https://static001.geekbang.org/account/avatar/00/12/06/16/e85c1fa8.jpg","nickname":"滴答丶滴","note":"","ucode":"2093C2948B4327","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303262,"discussion_content":"是这段代码吗？if (low < n &amp;&amp; a[low]==value) return low;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599204594,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1716747,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/1pMbwZrAl5gVy4FictX9HiaDicYOjRI2E6flxrXLhLTcneF74TowWK6rJW6oKs9iakPl0dqHsWjav0TjK6vyEZTlJA/132","nickname":"柳长青","note":"","ucode":"3EA2B7BD5DBCAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288578,"discussion_content":"确实不太理解，第一段代码是指？第一次出现的那段代码吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593792620,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1481811,"avatar":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","nickname":"ub8","note":"","ucode":"0D937C3EAEB781","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77983,"discussion_content":"没明白，求大神解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575963194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72882,"user_name":"王艳红","can_delete":false,"product_type":"c1","uid":1347994,"ip_address":"","ucode":"7012E919104FB9","user_header":"https://static001.geekbang.org/account/avatar/00/14/91/9a/b3de9b72.jpg","comment_is_top":false,"comment_ctime":1551750198,"is_pvip":false,"replies":[{"id":"26406","content":"下面的写法有可能会导致溢出，比如low很大，high也很大，之和就溢出了。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551752796,"ip_address":"","comment_id":72882,"utype":1}],"discussion_count":14,"race_medal":0,"score":"246364886070","product_id":100017301,"comment_content":"王老师，有一个疑惑不太明白<br>int mid = low + ((high - low)&gt;&gt;1) <br>这句，为什么要用这种写法呢？我看之前的简单的额二分查找是<br>int mid = (low + high)&#47;2 <br><br>","like_count":57,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441807,"discussion_content":"下面的写法有可能会导致溢出，比如low很大，high也很大，之和就溢出了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551752796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2052521,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/51/a9/741b5ad9.jpg","nickname":"FD","note":"","ucode":"ED396BD322489E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294084,"discussion_content":"感觉没好好看前面的内容","likes_number":13,"is_delete":false,"is_hidden":false,"ctime":1595776927,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1268797,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5c/3d/e8325811.jpg","nickname":"对白","note":"","ucode":"3183E5ADBC794B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294958,"discussion_content":"防止整型溢出","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596037112,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1178016,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f9/a0/2240fb2c.jpg","nickname":"capo","note":"","ucode":"6FD72DA5DBC220","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":252243,"discussion_content":"老师，我看之前简单二分查找求中间值 low + (high - low) >> 1 是不需要括号吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588145364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1446784,"avatar":"","nickname":"Geek_3ba85e","note":"","ucode":"106586BF969A80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1178016,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f9/a0/2240fb2c.jpg","nickname":"capo","note":"","ucode":"6FD72DA5DBC220","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":252620,"discussion_content":">> 的优先级非常低，不加括号会先执行+法！","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1588172461,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":252243,"ip_address":""},"score":252620,"extra":""},{"author":{"id":1637933,"avatar":"https://static001.geekbang.org/account/avatar/00/18/fe/2d/e23fc6ee.jpg","nickname":"深水蓝","note":"","ucode":"3E3B195DE54DE1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1178016,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f9/a0/2240fb2c.jpg","nickname":"capo","note":"","ucode":"6FD72DA5DBC220","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573477,"discussion_content":"研究算法的时候，没必要纠结具体的语句是否精炼。先不谈优先级的问题，加上括号是一种没有错误而且更明确的做法。这样加上括号就可以帮助更多人清晰地读懂算法的意思。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653458165,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":252243,"ip_address":""},"score":573477,"extra":""}]},{"author":{"id":1220552,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9f/c8/0318c83e.jpg","nickname":"Geek_b617bf","note":"","ucode":"9BAFC3B184B1D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":25236,"discussion_content":"当low=1 high=2 的时候  两种写法貌似不相等??","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570460400,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1164531,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c4/f3/92f654f1.jpg","nickname":"Bug? Feature!","note":"","ucode":"F8FA8A0094FBA0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1220552,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9f/c8/0318c83e.jpg","nickname":"Geek_b617bf","note":"","ucode":"9BAFC3B184B1D2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38632,"discussion_content":"相等啊，都是1，我估计你不怎么懂求余运算。。。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1571811375,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":25236,"ip_address":""},"score":38632,"extra":""},{"author":{"id":2189412,"avatar":"https://static001.geekbang.org/account/avatar/00/21/68/64/7f6f0dfd.jpg","nickname":"凌风","note":"","ucode":"7069D4BD8C8DCB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1220552,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9f/c8/0318c83e.jpg","nickname":"Geek_b617bf","note":"","ucode":"9BAFC3B184B1D2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308433,"discussion_content":"你注意前面的接收类型是int","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600951068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":25236,"ip_address":""},"score":308433,"extra":""}]},{"author":{"id":1556463,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/R5MwOVibGFTHJJt0d9AhfRBojQGVB4TvWYwuft5aGkOMmMAKh9Pj32icB8bnEOKFD3VAAXXibHVUTAzL5MrwE4ibibw/132","nickname":"Geek_c11531","note":"","ucode":"D9AFC931DF8B42","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5548,"discussion_content":"懂了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566351401,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":2133309,"avatar":"https://static001.geekbang.org/account/avatar/00/20/8d/3d/91b1afd3.jpg","nickname":"小北","note":"","ucode":"8FE84905F0E073","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1556463,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/R5MwOVibGFTHJJt0d9AhfRBojQGVB4TvWYwuft5aGkOMmMAKh9Pj32icB8bnEOKFD3VAAXXibHVUTAzL5MrwE4ibibw/132","nickname":"Geek_c11531","note":"","ucode":"D9AFC931DF8B42","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303237,"discussion_content":"老哥 能解释一下吗 我还是不太懂为什么这样取\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599198462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":5548,"ip_address":""},"score":303237,"extra":""},{"author":{"id":1052863,"avatar":"https://static001.geekbang.org/account/avatar/00/10/10/bf/a3a3c6d0.jpg","nickname":"胜杰","note":"","ucode":"401806B1660784","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2133309,"avatar":"https://static001.geekbang.org/account/avatar/00/20/8d/3d/91b1afd3.jpg","nickname":"小北","note":"","ucode":"8FE84905F0E073","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309385,"discussion_content":"看前面那篇文章，老师在里头有讲解的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601277354,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":303237,"ip_address":""},"score":309385,"extra":""},{"author":{"id":1242358,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f4/f6/3ec43eb7.jpg","nickname":"逝水流","note":"","ucode":"F815BF2C4DC321","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1052863,"avatar":"https://static001.geekbang.org/account/avatar/00/10/10/bf/a3a3c6d0.jpg","nickname":"胜杰","note":"","ucode":"401806B1660784","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384198,"discussion_content":"举个简单的例子，如果low>1，high=int最大值-1，相加就溢出了。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626421286,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":309385,"ip_address":""},"score":384198,"extra":""}]}]},{"had_liked":false,"id":52845,"user_name":"毅仔","can_delete":false,"product_type":"c1","uid":1242369,"ip_address":"","ucode":"31ECF2CC9CAD73","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/01/720b8b9b.jpg","comment_is_top":false,"comment_ctime":1545538822,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"242063707398","product_id":100017301,"comment_content":"第一次见到逻辑这么清晰的二分查找代码，已经被老师俘获了，太优雅了","like_count":57},{"had_liked":false,"id":120676,"user_name":"Geek_86533a","can_delete":false,"product_type":"c1","uid":1610333,"ip_address":"","ucode":"6961C429E8953A","user_header":"","comment_is_top":false,"comment_ctime":1564972161,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"212018369665","product_id":100017301,"comment_content":"茅塞顿开，刷leetcode的时候，看大神们写的二分查找，找一个数字出现的左右边界，始终无法理解，现在才明白自己陷入了追求代码简洁的误区。感谢老师渡我出苦海！","like_count":50,"discussions":[{"author":{"id":2016408,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/c4/98/9c7a1a23.jpg","nickname":"罗杰.菲の樂","note":"","ucode":"63590706846EEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553291,"discussion_content":"我也觉得是这样的，这个代码可读性非常好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645817792,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217669,"user_name":"John","can_delete":false,"product_type":"c1","uid":1020861,"ip_address":"","ucode":"E4ADF8488953FB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/93/bd/f3977ebb.jpg","comment_is_top":false,"comment_ctime":1589570290,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"139028523762","product_id":100017301,"comment_content":"我来给初学者解释一下IP地址的事吧. 为什么说IP地址可以转化为32位的整数呢? 首先我们看IP地址都是张这样的: &quot;XXX.XXX.XXX.XXX&quot; 一共4段,每段3位(因为你从来没有见过4位的一段的吧). 我们知道2的10次方是1024(程序员记得10月24号这个节日吧), 所有很容易掐指一算得到2^9=512 =&gt; 2^8=256. 其实xxx的上限是255, 这是IP地址的规定(反正你也没见过3xx或者4xx的地址吧)!!! 也就是说对于[0, 256)=[0, 255] 这个区间对应的2进制是8位. 刚才说了是4段, 那么就是4*8=32位的2进制喽. 当然了, 我们这段只是论证了对应的2进制是32位而已, 你对这道题的操作倒也不必一定要转化为2进制, 其实也可以干脆把小数点直接抽掉+补上前面的0, 得到一个很大的十进制数字. 这样的后果第一保持顺序的稳定性(其实也没有重复的), 第二很容易从十进制大数转回IP地址. 比如这样 &quot;255.128.16.8 =&gt; 255128016008&quot;, 最后搜索结束之后再转回去 &quot;255128016008=&gt;255128016008&quot;就可以啦!","like_count":32,"discussions":[{"author":{"id":1377447,"avatar":"https://static001.geekbang.org/account/avatar/00/15/04/a7/ea22485a.jpg","nickname":"海洋","note":"","ucode":"5CC1E17E5C455D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373715,"discussion_content":"感谢科普，最后一句“最后搜索结束之后再转回去 &#34;255128016008=>255128016008&#34;就可以啦!”，应该改为“最后搜索结束之后再转回去 &#34;255128016008=>255.128.16.8&#34;就可以啦!”","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1620832660,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2552582,"avatar":"https://static001.geekbang.org/account/avatar/00/26/f3/06/dc848b1b.jpg","nickname":"遗忘的沙漠胡杨","note":"","ucode":"68AF10964537A8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552460,"discussion_content":"感谢解惑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645486474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35550,"user_name":"Victor","can_delete":false,"product_type":"c1","uid":1003903,"ip_address":"","ucode":"801413B2B5C7B5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/51/7f/c74e3543.jpg","comment_is_top":false,"comment_ctime":1540651094,"is_pvip":false,"replies":[{"id":"12682","content":"数据库可以 单性能会受限","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540740458,"ip_address":"","comment_id":35550,"utype":1}],"discussion_count":9,"race_medal":0,"score":"130389669974","product_id":100017301,"comment_content":"今天的IP地址归属地问题，从工程实现的角度考虑，我更偏向于直接使用关系型数据库实现。<br>也就是将12w条归属地与IP区间的开始、结束存入数据库中。<br>数据库表ip_table有如下字段：area_name | start_ip | end_ip ，start_ip及end_ip 均建立索引<br>SQL语句：<br>select area_name from ip_table where input_ip &gt;= start_ip and input_ip &lt;= end_ip;<br>学习算法的课程常常和自己工程开发的实际结合在一起，感觉两者是相互促进理解的过程。","like_count":30,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427572,"discussion_content":"数据库可以 单性能会受限","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540740458,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1219496,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9b/a8/6a391c66.jpg","nickname":"Leon📷","note":"","ucode":"B9BBD1EFAAE5A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1186,"discussion_content":"数据库mysql是B+树，查询性能是nlogn，没有二分法logn来的快","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1562374090,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1219496,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9b/a8/6a391c66.jpg","nickname":"Leon📷","note":"","ucode":"B9BBD1EFAAE5A2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305922,"discussion_content":"—— ——！innodb 特性，极热索引，会自适应为hash索引。。I-HASH","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600131324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":1186,"ip_address":""},"score":305922,"extra":""},{"author":{"id":1324122,"avatar":"https://static001.geekbang.org/account/avatar/00/14/34/5a/723311cd.jpg","nickname":"句子","note":"","ucode":"C0C20F466DF9D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1219496,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9b/a8/6a391c66.jpg","nickname":"Leon📷","note":"","ucode":"B9BBD1EFAAE5A2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378522,"discussion_content":"B+树查询是nlogn，不是logn吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623254657,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":1186,"ip_address":""},"score":378522,"extra":""}]},{"author":{"id":1324122,"avatar":"https://static001.geekbang.org/account/avatar/00/14/34/5a/723311cd.jpg","nickname":"句子","note":"","ucode":"C0C20F466DF9D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378523,"discussion_content":"为啥是nlogn，就算是数组，查询性能都是O(n)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623254767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645430,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiauonyMORA2s43W7mogGDH4WYjW0gBJtYmUa9icTB6aMPGqibicEKlLoQmLKLWEctwHzthbTZkKR20w/132","nickname":"Spring4J","note":"","ucode":"06F056085A2564","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337718,"discussion_content":"我觉得还行，第二个字段可以用到索引下推。其实，索引还可以再加一个name字段，避免回表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609057404,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1988075,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJX4ZU53F8hBHicctluqK6Ef3U0ib40bq1vFyAvqV0wu3GaPuWbj967OdMT7k0gl3OMxsfopvbk9veQ/132","nickname":"Geek_dd8b2b","note":"","ucode":"CBEF7C39075A96","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287737,"discussion_content":"再说一句吧，因为查询只有start_ip和end_ip，这两个都是大于等于或者小于等于这种查询，mysql在处理这种不确定性的索引时候，只会使用一个不确定的。所以如果你的ip正好位于整个地址范围的中间，基本上是在12万/2 这么多数据里遍历查询。然后在用where里的比如end_ip作为条件进行过滤。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593524601,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1988075,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJX4ZU53F8hBHicctluqK6Ef3U0ib40bq1vFyAvqV0wu3GaPuWbj967OdMT7k0gl3OMxsfopvbk9veQ/132","nickname":"Geek_dd8b2b","note":"","ucode":"CBEF7C39075A96","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287736,"discussion_content":" 另外建立的覆盖索引只有一个有用，比如建立覆盖索引start_ip，end_ip，area。因为mysql在处理这种大于等于的索引时候，只有第一个模糊查询会使用索引，后面都没法用。所以你的索引效果可能很低。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593524010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1527721,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4f/a9/0279cee8.jpg","nickname":"星星在线","note":"","ucode":"C2EE7A8CB54E20","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285331,"discussion_content":"你这个要求太严格了，基本上就是要求作者举的例子，必须是用当前算法处理起来最优才行。如果有另外一种方式更优，这例子就不能举了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592808742,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35395,"user_name":"charon","can_delete":false,"product_type":"c1","uid":1189460,"ip_address":"","ucode":"E20B2EB92C30C2","user_header":"https://static001.geekbang.org/account/avatar/00/12/26/54/9fb6a10d.jpg","comment_is_top":false,"comment_ctime":1540539169,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"78849950497","product_id":100017301,"comment_content":"用JavaScript实现的最基本的思考题：<br>array是传入的数组，value是要查找的值<br>思路是通过对比low,high的值来判断value所在的区间，不用多循环一遍找偏移量了~<br>    function search(array,value){<br>        let low = 0;<br>        let high = array.length - 1;<br>        <br>        while(low &lt;= high){<br>            let mid = low + ((high - low) &gt;&gt; 1);<br>            if(value == array[low]) return low;<br>            if(value == array[high]) return high;<br>            if(value == array[mid]) return mid;<br><br>            if(value &gt; array[mid] &amp;&amp; value &gt; array[high] &amp;&amp; array[mid] &lt; array[low]){<br>                high = mid - 1;<br>            }else if(value &lt; array[mid] &amp;&amp; value &lt; array[low] &amp;&amp; array[mid] &lt; array[low]){<br>                high = mid - 1;<br>            }else if(value &lt; array[mid] &amp;&amp; value &gt; array[low]){<br>                high = mid - 1;<br>            }else{<br>                low = mid + 1;<br>            }<br>        }<br><br>        return -1<br>    }","like_count":18,"discussions":[{"author":{"id":1446784,"avatar":"","nickname":"Geek_3ba85e","note":"","ucode":"106586BF969A80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":252629,"discussion_content":"哎呀我去， 我就把头尾判断的没写，然后到两个指针相邻的时候总是过不去...真是恍然大悟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588172664,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":202630,"user_name":"松鼠鱼","can_delete":false,"product_type":"c1","uid":1815185,"ip_address":"","ucode":"C0E87CCF71DB44","user_header":"","comment_is_top":false,"comment_ctime":1586018576,"is_pvip":true,"discussion_count":5,"race_medal":0,"score":"74600462608","product_id":100017301,"comment_content":"尝试了一下LeetCode的33题，试提供一个Java版本的解法。从提交反馈来看还是不错的：<br>Runtime: 0 ms, faster than 100.00% of Java online submissions for Search in Rotated Sorted Array.<br><br>    public int solution(int[] nums, int target) {<br>        int s = 0;<br>        int e = nums.length - 1;<br>        while (e &gt;= s){<br>            int mid = s + (e-s)&#47;2;<br>            if (nums[mid] == target) return mid;<br>            if (nums[mid] &lt; nums[e]) {<br>                if (target &lt; nums[mid] || target &gt; nums[e]) {<br>                    e = mid - 1;<br>                } else s = mid + 1;<br>            } else {<br>                if (target &lt; nums[s] || target &gt; nums[mid]) {<br>                    s = mid + 1;<br>                } else e = mid - 1;<br>            }<br>        }<br>        return -1;<br>    }","like_count":17,"discussions":[{"author":{"id":2874311,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/db/c7/a2c8b513.jpg","nickname":"王洋","note":"","ucode":"6AADEAE8561218","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581859,"discussion_content":"厉害","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659024396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"陕西"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2703237,"avatar":"","nickname":"sean","note":"","ucode":"B517C6A09A4F07","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488625,"discussion_content":"把循环数组分成2部分来处理，每次循环找到存在存在目标的对应区间","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637056840,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1793563,"avatar":"","nickname":"InfoQ_095d09facfde","note":"","ucode":"9A2488E5AD9C25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368472,"discussion_content":"如果是判断有序的一边，判断逻辑会更容易理解一些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618725820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1890452,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJiartmgOY37cyzpYRicGBy7ZSnzZzmozxqaXE7Xm1aA3ubicDhMOIsfgibicFicvKA0NJ61YdicgXTdHpOw/132","nickname":"hxloongs","note":"","ucode":"8CFAF37C0DB1F0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347819,"discussion_content":"看了好一会儿，太妙了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612333349,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1234695,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d7/07/a2a671dc.jpg","nickname":"Terminal","note":"","ucode":"54685A7D900A3A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344045,"discussion_content":"思考了一会理解了你的思路，厉害～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611247302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36635,"user_name":"姜威","can_delete":false,"product_type":"c1","uid":1244051,"ip_address":"","ucode":"C58EB9A5AD634D","user_header":"https://static001.geekbang.org/account/avatar/00/12/fb/93/f19a5364.jpg","comment_is_top":false,"comment_ctime":1541210711,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"61670752855","product_id":100017301,"comment_content":"总结：二分查找（下）<br>一、四种常见的二分查找变形问题<br>1.查找第一个值等于给定值的元素<br>2.查找最后一个值等于给定值的元素<br>3.查找第一个大于等于给定值的元素<br>4.查找最后一个小于等于给定值的元素<br>二、适用性分析<br>1.凡事能用二分查找解决的，绝大部分我们更倾向于用散列表或者二叉查找树，即便二分查找在内存上更节省，但是毕竟内存如此紧缺的情况并不多。<br>2.求“值等于给定值”的二分查找确实不怎么用到，二分查找更适合用在”近似“查找问题上。比如上面讲几种变体。<br>三、思考<br>1.如何快速定位出一个IP地址的归属地？<br>[202.102.133.0, 202.102.133.255]  山东东营市 <br>[202.102.135.0, 202.102.136.255]  山东烟台 <br>[202.102.156.34, 202.102.157.255] 山东青岛 <br>[202.102.48.0, 202.102.48.255] 江苏宿迁 <br>[202.102.49.15, 202.102.51.251] 江苏泰州 <br>[202.102.56.0, 202.102.56.255] 江苏连云港<br>假设我们有 12 万条这样的 IP 区间与归属地的对应关系，如何快速定位出一个IP地址的归属地呢？<br>2.如果有一个有序循环数组，比如4，5，6，1，2，3。针对这种情况，如何实现一个求“值等于给定值”的二分查找算法？","like_count":14,"discussions":[{"author":{"id":1158349,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ac/cd/fda6374f.jpg","nickname":"Louis","note":"","ucode":"BC667839F17937","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":39774,"discussion_content":"不懂你每次复制老师讲的内容有什么意义。。一点自己的观点没有","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1571983673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1134861,"avatar":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","nickname":"James","note":"","ucode":"48B0F2A334D1C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1158349,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ac/cd/fda6374f.jpg","nickname":"Louis","note":"","ucode":"BC667839F17937","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":64215,"discussion_content":"重点是思考题都没自己做..","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574942303,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":39774,"ip_address":""},"score":64215,"extra":""},{"author":{"id":1613665,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9f/61/c46b42f4.jpg","nickname":"talkyoung","note":"","ucode":"8D231FA9004B64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1158349,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ac/cd/fda6374f.jpg","nickname":"Louis","note":"","ucode":"BC667839F17937","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545391,"discussion_content":"有利于根据大纲回顾","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641947612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":39774,"ip_address":""},"score":545391,"extra":""}]},{"author":{"id":1354687,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ab/bf/db863c7e.jpg","nickname":"Bella","note":"","ucode":"0255EFFA9E228B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":80006,"discussion_content":"哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576136830,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":70186,"user_name":"朱坤","can_delete":false,"product_type":"c1","uid":1098637,"ip_address":"","ucode":"65224DA2456EAB","user_header":"https://static001.geekbang.org/account/avatar/00/10/c3/8d/214ad614.jpg","comment_is_top":false,"comment_ctime":1551025456,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"57385600304","product_id":100017301,"comment_content":"置顶的同学的思路一，即先找分界再判断在哪个数组，再二分，其实是可以做到O(Log N)的，找分界的点的规则就是找到首个小于a[0]的元素，思路用老师4个转换问题的解法就可以。按评论做了下leetcode33题，感觉会比较老师给的思考题描述清晰。。因为老师说的找问题，没有明确有几组循环数组。。","like_count":13,"discussions":[{"author":{"id":1317999,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1c/6f/3ea2a599.jpg","nickname":"嘉木","note":"","ucode":"AF4877693782C0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380300,"discussion_content":"“找分界的点的规则就是找到首个小于a[0]的元素，思路用老师4个转换问题的解法就可以”\n—— 第4个转换问题是基于非循环数组求解，你说的这个还是在循环数组中求解吧，不一样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624430458,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1652836,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epKJlW7sqts2ZbPuhMbseTAdvHWnrc4ficAeSZyKibkvn6qyxflPrkKKU3mH6XCNmYvDg11tB6y0pxg/132","nickname":"pc","note":"","ucode":"1AD538B9A900B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":235165,"discussion_content":"找分界点就已经O(n)了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587025352,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1600770,"avatar":"https://static001.geekbang.org/account/avatar/00/18/6d/02/0a8b9471.jpg","nickname":"摆渡人","note":"","ucode":"0679ED7112E654","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1652836,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epKJlW7sqts2ZbPuhMbseTAdvHWnrc4ficAeSZyKibkvn6qyxflPrkKKU3mH6XCNmYvDg11tB6y0pxg/132","nickname":"pc","note":"","ucode":"1AD538B9A900B6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":262487,"discussion_content":"找分界点也可以二分","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589104739,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":235165,"ip_address":""},"score":262487,"extra":""}]}]},{"had_liked":false,"id":47517,"user_name":"菜鸡程序员","can_delete":false,"product_type":"c1","uid":1308074,"ip_address":"","ucode":"F1DFEC2343FE25","user_header":"https://static001.geekbang.org/account/avatar/00/13/f5/aa/5d520017.jpg","comment_is_top":false,"comment_ctime":1544149508,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35903887876","product_id":100017301,"comment_content":"<br>1.如果不知道分界点，找寻分界点没有意义，不如直接遍历。<br>2.如果知道分界点，查看在哪一边，然后二分法，或者偏移量计算,二分法<br><br>老师,我今天这种可以吗:<br>&#47;**<br>\t * 功能描述:查找第一个大于等于给定值的元素<br>\t *<br>\t * @param null<br>\t * @return<br>\t * @author xiongfan<br>\t * @date 2018&#47;12&#47;7 9:43:00<br>\t *&#47;<br>\tpublic static int getFirstGreaterValue(int[] array,int value) {<br>\t\tint low = 0;<br>\t\tint high = array.length - 1;<br><br>\t\twhile (low &lt;= high) {<br>\t\t\tint mid = low + (high - low) &gt;&gt; 1;<br>\t\t\tif (array[mid] &lt; value) {<br>\t\t\t\tlow = mid + 1;<br>\t\t\t} else if (array[mid] &gt; value) {<br>\t\t\t\thigh = mid - 1;<br>\t\t\t} else {<br><br>\t\t\t\tif (mid == 0 || array[mid - 1] &lt; array[mid]) {<br>\t\t\t\t\treturn mid;<br>\t\t\t\t}<br>\t\t\t\thigh = mid - 1;<br><br>\t\t\t}<br>\t\t}<br><br>\t\treturn low&gt;array.length-1?-1:low;<br>\t}<br><br>\t&#47;**<br>\t * 功能描述:查找最后一个小于等于给定值的元素<br>\t *<br>\t * @param null<br>\t * @return<br>\t * @author xiongfan<br>\t * @date 2018&#47;12&#47;7 10:03:00<br>\t *&#47;<br>\tpublic static int getLastLessValue(int[] array,int value) {<br>\t\tint low = 0;<br>\t\tint high = array.length - 1;<br><br>\t\twhile (low &lt;= high) {<br>\t\t\tint mid = low + (high - low) &gt;&gt; 1;<br>\t\t\tif (array[mid] &gt; value) {<br>\t\t\t\thigh = mid - 1;<br>\t\t\t} else if (array[mid] &lt; value) {<br>\t\t\t\tlow = mid + 1;<br>\t\t\t} else {<br>\t\t\t\tif (mid &gt; array.length-1 || array[mid] &lt; array[mid + 1]) {<br>\t\t\t\t\treturn mid;<br>\t\t\t\t}<br>\t\t\t\tlow = mid + 1;<br>\t\t\t}<br>\t\t}<br><br>\t\treturn high&lt;0?-1:high;<br>\t}<br>","like_count":8},{"had_liked":false,"id":35468,"user_name":"勤劳的小胖子-libo","can_delete":false,"product_type":"c1","uid":1158344,"ip_address":"","ucode":"5BB20CD5A56568","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/c8/4b1c0d40.jpg","comment_is_top":false,"comment_ctime":1540607456,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"35900345824","product_id":100017301,"comment_content":"1. 先二分遍历找到分隔点index，特征是&lt;pre, &gt;=next;<br>2. 把数组分成二个部分，[0,index-1], [index,length-1];<br>3. 分别使用二分查找，找到给定的值。<br>时间复杂度为2*log(n). 不确定有什么更好的办法。<br>","like_count":8,"discussions":[{"author":{"id":2100090,"avatar":"https://static001.geekbang.org/account/avatar/00/20/0b/7a/9ce7dc7d.jpg","nickname":"东瓜酱","note":"","ucode":"B1FEADF98DE292","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301750,"discussion_content":"我的思路跟你一样\n1.先利用二分查找法，找到数组的分割点，也就是数组中最小数的下标\n2.再把数组分成两个部分，分别利用二分查找找到所需的值\n时间复杂度就是logn，这已经是很好的方法了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598624332,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1295609,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJRFRX8kNzNet7FibNvtavbVpAwK09AhIhrib9k762qWtH6mre8ickP7hM5mgZC4ytr8NnmIfmAhxMSQ/132","nickname":"老大不小","note":"","ucode":"35BCDD3CB13467","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581499,"discussion_content":"4，5，6，1，2，3  没明白&lt;pre, &gt;=next;，比如index是1，前面是6，后面是2，都大于index.如果index是6，也是大于前后两位的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658818178,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":48158,"user_name":"疾风狂草","can_delete":false,"product_type":"c1","uid":1283489,"ip_address":"","ucode":"05F899725048BC","user_header":"","comment_is_top":false,"comment_ctime":1544372422,"is_pvip":false,"replies":[{"id":"17167","content":"哈希表是精准查找","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1544406897,"ip_address":"","comment_id":48158,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31609143494","product_id":100017301,"comment_content":"老师，你说二分查找更适合用在“近似”查找问题，在这类问题上，二分查找的优势更加明显。这种问题链式哈希表不是更擅长吗？","like_count":7,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":432057,"discussion_content":"哈希表是精准查找","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544406897,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64861,"user_name":"牛顿的苹果啦","can_delete":false,"product_type":"c1","uid":1036606,"ip_address":"","ucode":"B31657FA24CB03","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d1/3e/d790c6d3.jpg","comment_is_top":false,"comment_ctime":1548927679,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23023764159","product_id":100017301,"comment_content":"思考题：<br>可以考虑将数组分为N个有序数组，分别进行二分查找。<br>代码实现：<br> public  int circleBinarySearch(int[] a, int value){<br>        int low = 0, high=0;<br>        for(int i=0;i&lt;a.length-1;i++){<br>            &#47;&#47;找到有序数组的下标<br>            if(a[i]&lt;a[i+1]){<br>                high=i+1;<br>            }else{<br>                &#47;&#47;有序数组到顶，二分查找<br>                int i1 = binarySearch(low, high, a, value);<br>                if(-1 != i1){<br>                    return i1;<br>                }else{<br>                    low = high+1;<br>                }<br>            }<br>            &#47;&#47;high已经到最后一个位置<br>            if(a.length-1 == high){<br>                return binarySearch(low, high, a, value);<br>            }<br>        }<br>        return -1;<br>    }<br><br>    private int binarySearch(int low, int high, int[] a, int value){<br>        for(;low&lt;=high;){<br>            int middle = low+((high-low)&gt;&gt;1);<br>            if(a[middle] == value){<br>                return middle;<br>            }<br>            if(a[middle] &gt; value){<br>                high = middle -1;<br>            }else{<br>                low = middle +1;<br>            }<br>        }<br>        return -1;<br>    }","like_count":5},{"had_liked":false,"id":36173,"user_name":"狼的诱惑","can_delete":false,"product_type":"c1","uid":1257043,"ip_address":"","ucode":"AE89DFC5963C42","user_header":"https://static001.geekbang.org/account/avatar/00/13/2e/53/bf62683f.jpg","comment_is_top":false,"comment_ctime":1540962922,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"23015799402","product_id":100017301,"comment_content":"@老师，请老师或其他高人回复指教<br>&#47;**<br>     * 例如： 4 5 6 1 2 3<br>     * 循环数组的二分查找  总体时间复杂度O(n)<br>     *&#47;<br>    public static int forEqualsThan(int[] arr, int num) {<br>        if (arr[0] == num) {<br>            return 0;<br>        }<br>        int length = arr.length;<br>        int low = 0;<br>        int high = length - 1;<br>        &#47;&#47;找到循环节点<br>        for (int i = 0; i &lt; length; i++) {<br>            if (i == length - 1) {<br>                if (arr[i] &gt; arr[0]) {<br>                    low = i;<br>                    high = 0;<br>                    break;<br>                }<br>            } else {<br>                if (arr[i] &gt; arr[i + 1]) {<br>                    low = i;<br>                    high = low + 1;<br>                    break;<br>                }<br>            }<br>        }<br>        &#47;&#47;判断第一个节点的大小位置，确定low和high的值，转变为正常有序的二分查找<br>        if (arr[0] &lt; num) {<br>            high = low;<br>            low = 0;<br>        }<br>        if (arr[0] &gt; num) {<br>            low = high;<br>            high = length - 1;<br>        }<br>        while (low &lt;= high) {<br>            int index = low + ((high - low) &gt;&gt; 1);<br>            if (arr[index] &gt; num) {<br>                high = index - 1;<br>            }<br>            if (arr[index] &lt; num) {<br>                low = index + 1;<br>            }<br>            if (arr[index] == num) {<br>                return index;<br>            }<br>        }<br>        return -1;<br>    }","like_count":5,"discussions":[{"author":{"id":1618072,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b0/98/26de1ee8.jpg","nickname":"CHuAN","note":"","ucode":"9C4E798C42A1B7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6041,"discussion_content":"。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566636268,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1246664,"avatar":"https://static001.geekbang.org/account/avatar/00/13/05/c8/2f849dfb.jpg","nickname":"山顶的洞","note":"","ucode":"D3E9E928A3FA62","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4440,"discussion_content":"可以的，志哥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565419238,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1257043,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2e/53/bf62683f.jpg","nickname":"狼的诱惑","note":"","ucode":"AE89DFC5963C42","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1246664,"avatar":"https://static001.geekbang.org/account/avatar/00/13/05/c8/2f849dfb.jpg","nickname":"山顶的洞","note":"","ucode":"D3E9E928A3FA62","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4650,"discussion_content":"可以的，华兄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565619432,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4440,"ip_address":""},"score":4650,"extra":""},{"author":{"id":1225231,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b2/0f/fff4d7c3.jpg","nickname":"TSY","note":"","ucode":"9A6E39EBC7EAE2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1257043,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2e/53/bf62683f.jpg","nickname":"狼的诱惑","note":"","ucode":"AE89DFC5963C42","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214123,"discussion_content":"商业互吹\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585147448,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4650,"ip_address":""},"score":214123,"extra":""}]}]},{"had_liked":false,"id":98579,"user_name":"低调人生","can_delete":false,"product_type":"c1","uid":1210242,"ip_address":"","ucode":"02BF84F26D6079","user_header":"https://static001.geekbang.org/account/avatar/00/12/77/82/985138e7.jpg","comment_is_top":false,"comment_ctime":1559034318,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"18738903502","product_id":100017301,"comment_content":"我觉得查找第一个符合给定的值得那两种写法 第一种更好理解  没看懂作者的写法","like_count":4,"discussions":[{"author":{"id":1031734,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/be/36/abb7bfe3.jpg","nickname":"xenoblade3","note":"","ucode":"620DD0491EEFF3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3298,"discussion_content":"这有点杠了吧，第一种写法将第一个等于给定值的获取方法融入进low = mid +1分支，这并不容易理解，而王争给出的思路是正向思维，是很直接的思路。","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1564382207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1652836,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epKJlW7sqts2ZbPuhMbseTAdvHWnrc4ficAeSZyKibkvn6qyxflPrkKKU3mH6XCNmYvDg11tB6y0pxg/132","nickname":"pc","note":"","ucode":"1AD538B9A900B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":235168,"discussion_content":"不是垃圾就是会吹牛的垃圾","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587025506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645430,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiauonyMORA2s43W7mogGDH4WYjW0gBJtYmUa9icTB6aMPGqibicEKlLoQmLKLWEctwHzthbTZkKR20w/132","nickname":"Spring4J","note":"","ucode":"06F056085A2564","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":75690,"discussion_content":"那麻烦给出第一种思维的其他变种的代码？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575768332,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":39678,"user_name":"晓杉","can_delete":false,"product_type":"c1","uid":1209336,"ip_address":"","ucode":"19E634BB61A165","user_header":"https://static001.geekbang.org/account/avatar/00/12/73/f8/dbd2fa50.jpg","comment_is_top":false,"comment_ctime":1542334829,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"18722204013","product_id":100017301,"comment_content":"老师，我有一个疑问。<br>使用二分查找的前提是有序数组。<br>对于本节IP地址问题，我们先进行排序再进行查找，我理解应该时间复杂度是排序平均O(nLogn)再加上二分查找O(logn)<br>比单纯的顺序遍历O(n)要慢许多了。<br>是不是实际中，这种无序情况直接使用了顺序遍历查找呢？","like_count":4,"discussions":[{"author":{"id":1606288,"avatar":"https://static001.geekbang.org/account/avatar/00/18/82/90/295449c4.jpg","nickname":"半生瓜。","note":"","ucode":"6D4CC445230D19","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6297,"discussion_content":"排序后你可以保存排序结果啊，下一次再找就不用排序啦","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1566827583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1397631,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKVUskibDnhMt5MCIJ8227HWkeg2wEEyewps8GuWhWaY5fy7Ya56bu2ktMlxdla3K29Wqia9efCkWaQ/132","nickname":"衬衫的价格是19美元","note":"","ucode":"655F925451F772","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310578,"discussion_content":"ip的排序只需要排一次，因为ip对应的地址基本不会变动，一旦排序完成后，后面就可以当成常量来使用了，一次排序无数次查找，平均到每次查找上，排序的时间就可以忽略","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1601910774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1318394,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1d/fa/b81c89c3.jpg","nickname":"isobelar","note":"","ucode":"58CE4061984B43","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":248646,"discussion_content":"为什么不用基数排序，时间复杂度只有O(32n) < O(nlogn).","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587884126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1473900,"avatar":"https://static001.geekbang.org/account/avatar/00/16/7d/6c/e7163342.jpg","nickname":"邓海涵","note":"","ucode":"DCCA91C3B4CBAE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":71246,"discussion_content":"我觉得区间是排好序的。重点是取一个ip怎么匹配区间的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575388442,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1473900,"avatar":"https://static001.geekbang.org/account/avatar/00/16/7d/6c/e7163342.jpg","nickname":"邓海涵","note":"","ucode":"DCCA91C3B4CBAE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":226857,"discussion_content":"对呀，我也在想找到IP后怎么去匹配区间进而确定地点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586443698,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":71246,"ip_address":""},"score":226857,"extra":""}]}]},{"had_liked":false,"id":35278,"user_name":"刘忽悠","can_delete":false,"product_type":"c1","uid":1252173,"ip_address":"","ucode":"095DE3A8D3F450","user_header":"https://static001.geekbang.org/account/avatar/00/13/1b/4d/2cc44d9a.jpg","comment_is_top":false,"comment_ctime":1540489518,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"18720358702","product_id":100017301,"comment_content":"第一段代码的想法确实妙，乍眼一看还以为这段代码有问题","like_count":4},{"had_liked":false,"id":152853,"user_name":"Vilochen.","can_delete":false,"product_type":"c1","uid":1101556,"ip_address":"","ucode":"19D9BF8534B480","user_header":"https://static001.geekbang.org/account/avatar/00/10/ce/f4/5bfc786a.jpg","comment_is_top":false,"comment_ctime":1574089558,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14458991446","product_id":100017301,"comment_content":"文中的二分查找四道题实现：<br>1.<br>public static int searchFirst(int[] array, int num) {<br>        int l = 0;<br>        int h = array.length - 1;<br>        while (l &lt; h) {<br>            int mid = (l + h) &gt;&gt;&gt; 1;<br>            if (array[mid] &lt; num) {<br>                l = mid + 1;<br>            } else {<br>                h = mid;<br>            }<br>        }<br>        if (array[l] == num) {<br>            return l;<br>        }<br>        return -1;<br>    }<br><br> 2.   public static int searchFirstLarge(int[] array, int num) {<br>        int l = 0;<br>        int h = array.length - 1;<br>        while (l &lt; h) {<br>            int mid = (l + h) &gt;&gt;&gt; 1;<br>            if (array[mid] &lt; num) {<br>                l = mid + 1;<br>            } else {<br>                h = mid;<br>            }<br>        }<br>        if (array[l] &gt;= num) {<br>            return l;<br>        }<br>        return -1;<br>    }<br><br>  3.  public static int searchLast(int[] array, int num) {<br>        int l = 0;<br>        int h = array.length - 1;<br>        while (l &lt; h) {<br>            int mid = (l + h + 1) &gt;&gt;&gt; 1;<br>            if (array[mid] &gt; num) {<br>                h = mid - 1;<br>            } else {<br>                l = mid;<br>            }<br>        }<br>        if (array[l] == num) {<br>            return l;<br>        }<br>        return -1;<br>    }<br><br> 4.   public static int searchLastSmall(int[] array, int num) {<br>        int l = 0;<br>        int h = array.length - 1;<br>        while (l &lt; h) {<br>            int mid = (l + h + 1) &gt;&gt;&gt; 1;<br>            if (array[mid] &gt; num) {<br>                h = mid - 1;<br>            } else {<br>                l = mid;<br>            }<br>        }<br>        if (array[l] &lt;= num) {<br>            return l;<br>        }<br>        return -1;<br>    }","like_count":3},{"had_liked":false,"id":149532,"user_name":"felix","can_delete":false,"product_type":"c1","uid":1685680,"ip_address":"","ucode":"C10686E5C9F7BD","user_header":"https://static001.geekbang.org/account/avatar/00/19/b8/b0/20056da3.jpg","comment_is_top":false,"comment_ctime":1573268143,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14458170031","product_id":100017301,"comment_content":"想到一种思路，依旧对半查找，但是现在两边会出现一个有序数组和循环数组，如果选择的数在有序数组内，正常的二分查找就OK，如果不是，继续对半，同上。次数和二分查找一致，所以依旧是logN，就是判断比较多点。","like_count":3},{"had_liked":false,"id":120835,"user_name":"helloworld2018","can_delete":false,"product_type":"c1","uid":1210386,"ip_address":"","ucode":"2AE40C0DF5A9F7","user_header":"https://static001.geekbang.org/account/avatar/00/12/78/12/7df38a54.jpg","comment_is_top":false,"comment_ctime":1565004033,"is_pvip":false,"replies":[{"id":"44732","content":"low = 0  high=1，mid=0，low+1之后就相等了","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1565219456,"ip_address":"","comment_id":120835,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14449905921","product_id":100017301,"comment_content":"老师你好，二分法查找在什么情况下low==high","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461501,"discussion_content":"low = 0  high=1，mid=0，low+1之后就相等了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565219456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":51144,"user_name":"QFann","can_delete":false,"product_type":"c1","uid":1258674,"ip_address":"","ucode":"910DD5C907E347","user_header":"https://static001.geekbang.org/account/avatar/00/13/34/b2/1e593de7.jpg","comment_is_top":false,"comment_ctime":1545120730,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14430022618","product_id":100017301,"comment_content":"public int search(int[] nums, int target) {<br>        if(nums.length ==0) return -1;<br>        if(nums.length ==1){<br>            if(nums[0] == target) return 0;<br>            else return -1;<br>        }<br>        int low = 0;<br>        int high = nums.length - 1;<br>        int index = subIndex(nums,low,high);<br>        if(index != -1){<br>            int val = binarySearch(nums,low,index,target);<br>            if (val != -1) return val;<br>            return binarySearch(nums,index+1,high,target);<br>        }<br>        return binarySearch(nums,low,high,target);<br>    }<br>    <br>    public static int subIndex(int [] nums,int low,int high){<br>        while (low &lt;= high){<br>            int mid = low + ((high - low )&gt;&gt; 1);<br>            if(nums.length &lt; 1) return -1;<br>            if(nums[mid] &gt; nums[mid+1]) return mid;<br>            else if( nums[mid] &lt; nums[low] ) high = mid ;<br>            else if (nums[mid] &gt; nums[high]) low = mid ;<br>            else return -1;    <br>        }<br>        return -1;<br>    }<br>    <br>    public static int binarySearch(int[] nums,int low,int high,int target){<br>        while (low &lt;= high){<br>            int mid = low + ((high - low)&gt;&gt;1);<br>            if(nums[mid] == target) return mid;<br>            else if (nums[mid] &lt; target) low = mid + 1;<br>            else high = mid -1;   <br>        }<br>        return -1;<br>    }","like_count":3},{"had_liked":false,"id":35279,"user_name":"komo0104","can_delete":false,"product_type":"c1","uid":1084059,"ip_address":"","ucode":"90C40C69F7CC93","user_header":"https://static001.geekbang.org/account/avatar/00/10/8a/9b/feb182d3.jpg","comment_is_top":false,"comment_ctime":1540491025,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14425392913","product_id":100017301,"comment_content":"给原来的index加上偏移量。<br>比如原来的二分查找代码从0开始到n-1结束，现在为x到x - 1 (即n-1+x-n)。<br>x为开始循环处的索引，例子里为3 （1所在索引）。需要扫描一遍数组找到x，复杂度O(n)。其余和普通二分查找一样，需要多判断index not out of bound。如果索引超过n了要减n。<br>总的复杂度还是O(n)","like_count":3},{"had_liked":false,"id":267301,"user_name":"蓦然回首","can_delete":false,"product_type":"c1","uid":1172090,"ip_address":"","ucode":"B17658DCFE6402","user_header":"https://static001.geekbang.org/account/avatar/00/11/e2/7a/38a27e47.jpg","comment_is_top":false,"comment_ctime":1607674694,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"10197609286","product_id":100017301,"comment_content":"现在这个问题应该很简单了。如果 IP 区间与归属地的对应关系不经常更新，我们可以先预处理这 12 万条数据，让其按照起始 IP 从小到大排序。如何来排序呢？我们知道，IP 地址可以转化为 32 位的整型数。所以，我们可以将起始地址，按照对应的整型值的大小关系，从小到大进行排序。<br>这里所谓的起始地址是点分十进制表示法当中最后一个字节为0的IP吗(如192.168.166.0这种)<br><br>老师，查找IP归属地的问题，文章中给出的解决方法还是有些疑惑，为什么是查找最后一个小于等于指定IP的IP区间，而且二分查找一般不是直接定位某个具体的值吗？这种定位区间，怎么用二分查找？不知道我的理解是否有问题？我的理解是，既然我们知道具体要查找的IP,直接查找这个IP不行吗？文章当中也说预先处理这12万条数据，我的理解是否是已经全部放进一个数组了？<br>不知道上述理解是否有问题？","like_count":2,"discussions":[{"author":{"id":2662690,"avatar":"https://static001.geekbang.org/account/avatar/00/28/a1/22/c21f8c42.jpg","nickname":"歌者","note":"","ucode":"AC27207D8273AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559256,"discussion_content":"直接查找的复杂度为o(n)，二分查找为logn，数据规模越大，时间复杂度的影响越大，所以还是二分查找的效率高一些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648657981,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2662690,"avatar":"https://static001.geekbang.org/account/avatar/00/28/a1/22/c21f8c42.jpg","nickname":"歌者","note":"","ucode":"AC27207D8273AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559254,"discussion_content":"Ip区间开始值经过从小到大排序以后，每个位置的ip值既相当于一个区间的开始，也相当于上个区间的结束。算一个ip值落在哪个区间，那肯定需要这个ip值大于所在区间的开始值，因为经过排序了，所以有很多开始值都可能小于这个ip值，那么他到底落在哪个区间呢，那肯定是选离他最近的那个且小于他的那个区间开始值，所以此处就是选择最后一个小于他的ip区间开始值（这个值前面的所有值都小于待查ip，只有最后一个小的才满足要求）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648657862,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160757,"user_name":"SteveYang","can_delete":false,"product_type":"c1","uid":1754829,"ip_address":"","ucode":"C42BCA4F40A9EF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKCbnOvEatUN4ysE2cl6zJNoAJVXXuQVhicQ1jxh6Z2Towrmmc1I6PndaicuQQ0RyyJPyJQicv4tSib9Q/132","comment_is_top":false,"comment_ctime":1576029612,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10165964204","product_id":100017301,"comment_content":"查找循环有序数组：使用二分法根据首元素和中间元素的大小关系将数组分为有序数组和循环数组，如果目标在有序数组使用二分查找，如果在循环数组，则继续二分为有序数组和循环数组。","like_count":2},{"had_liked":false,"id":141527,"user_name":"小喵喵","can_delete":false,"product_type":"c1","uid":1062444,"ip_address":"","ucode":"FDBBB2A59DB8B6","user_header":"https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg","comment_is_top":false,"comment_ctime":1571187863,"is_pvip":false,"replies":[{"id":"54909","content":"找到区间开始就够了，因为区间是不重叠的。你自己举个例子看看。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1571360827,"ip_address":"","comment_id":141527,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10161122455","product_id":100017301,"comment_content":"通过ip找归属地时，是二分查找最后一个ip小于等于给定值的ip，这只是开始区间，请问老师那结束区间如何找呢？","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470786,"discussion_content":"找到区间开始就够了，因为区间是不重叠的。你自己举个例子看看。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571360827,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141517,"user_name":"小喵喵","can_delete":false,"product_type":"c1","uid":1062444,"ip_address":"","ucode":"FDBBB2A59DB8B6","user_header":"https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg","comment_is_top":false,"comment_ctime":1571187386,"is_pvip":false,"replies":[{"id":"54910","content":"你这行代码来自何处呀","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1571360862,"ip_address":"","comment_id":141517,"utype":1}],"discussion_count":4,"race_medal":0,"score":"10161121978","product_id":100017301,"comment_content":"为什么mid == n - 1，不是mid==high来判断更好吗？","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470782,"discussion_content":"你这行代码来自何处呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571360862,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1164531,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c4/f3/92f654f1.jpg","nickname":"Bug? Feature!","note":"","ucode":"F8FA8A0094FBA0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38633,"discussion_content":"high一直在变动啊，n-1是固定的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571811570,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1062444,"avatar":"https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg","nickname":"小喵喵","note":"","ucode":"FDBBB2A59DB8B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":36600,"discussion_content":"二分查找的变体啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571397134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1686840,"avatar":"https://static001.geekbang.org/account/avatar/00/19/bd/38/6d436088.jpg","nickname":"Lance","note":"","ucode":"CCE52F86EEBBED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1062444,"avatar":"https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg","nickname":"小喵喵","note":"","ucode":"FDBBB2A59DB8B6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38631,"discussion_content":"high不是整个数组的边界呀，判断的目的是想知道mid是不是到达数组的末尾，如果是就不用继续查找了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571811327,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":36600,"ip_address":""},"score":38631,"extra":""}]}]},{"had_liked":false,"id":101187,"user_name":"William","can_delete":false,"product_type":"c1","uid":1346215,"ip_address":"","ucode":"55F5D9DEE485B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","comment_is_top":false,"comment_ctime":1559736375,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"10149670967","product_id":100017301,"comment_content":"变体一：查找第一个值等于给定值的元素<br><br>刚开始没理解这个: a[mid] 的前一个元素 a[mid-1] 不等于 value , <br>那也说明 a[mid] 就是我们要找的第一个值等于给定值的元素, <br><br>举例说明:  1  4  4  4  6  7  9    [ 从0 -6]<br>low = 0 ; hight  = 6  <br>找 第一个元素4 ,  ( low+(hight-low))&#47;2  mid = 3  a[mid]= 4 , 元素匹配,此时看前一个元素a[ mid-1] = a[2] = 4 ,说明前面也有4这个元素, 所以继续进行二分查找.<br><br>如果 a[mid-1] !=4 ,那么此时mid 为所求.<br>此处需要注意 ,这个是有序的数据, 所以a[mid] 以前的元素一定 小于等于a[mid]","like_count":2,"discussions":[{"author":{"id":1268797,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5c/3d/e8325811.jpg","nickname":"对白","note":"","ucode":"3183E5ADBC794B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294966,"discussion_content":"很棒！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596038563,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35870,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1540826357,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10130760949","product_id":100017301,"comment_content":"二分的四种变种写法。个人觉得都是分三种情况进行讨论，再多注意判断边界值，三种情况为：<br>a[mid]&lt;value<br>a[mid]=value<br>a[mid]&gt;value； <br>思考题：自己思考了一小段时间没有好的思路，就各学友的留言，亲自实现了Smallfly的方法三，感觉比较好！谢谢！","like_count":2},{"had_liked":false,"id":35401,"user_name":"铁皮","can_delete":false,"product_type":"c1","uid":1013200,"ip_address":"","ucode":"E20FB02D9ABD20","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/d0/0053c9ba.jpg","comment_is_top":false,"comment_ctime":1540541134,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10130475726","product_id":100017301,"comment_content":"我发现第一段代码(简洁版)好像有bug。<br>测试数组int[] nums = new int[] {1, 3, 3, 3, 3, 6, 7, 9, 12, 14, 18};<br>执行bsearch(nums, nums.length, 20);<br>出现java.lang.ArrayIndexOutOfBoundsException: 11<br>但是执行bsearch(nums, nums.length - 1, 20);就没有问题。<br><br>但是第二段代码就是你提倡的写法，执行bsearch(nums, nums.length, 20);  就没有问题。<br>但是执行bsearch(nums, nums.length - 1, 18); 返回&quot;-1&quot;。就不正确了。<br><br>可能还需要大量的测试 <br>","like_count":2},{"had_liked":false,"id":35359,"user_name":"淤白","can_delete":false,"product_type":"c1","uid":1206503,"ip_address":"","ucode":"D1E65DC40DAF68","user_header":"https://static001.geekbang.org/account/avatar/00/12/68/e7/ee47d0e2.jpg","comment_is_top":false,"comment_ctime":1540524183,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10130458775","product_id":100017301,"comment_content":"1. 通过二分法算出偏移量；<br>2. 通过偏移量使 [0, n-1] 和现在有序数组的下标关联起来；<br>3. 通过二分法算出结果；<br>4. 对结果进行偏移处理拿到最终位置。","like_count":2},{"had_liked":false,"id":286046,"user_name":"阳.","can_delete":false,"product_type":"c1","uid":1112650,"ip_address":"","ucode":"3D48CEA896FAE1","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/4a/8b4372a8.jpg","comment_is_top":false,"comment_ctime":1617118587,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5912085883","product_id":100017301,"comment_content":"其实老师你的写法和网上那种写法的区别是：当已经找到一个数时，你对于下一次是否需要二分做了前置判断，不需要直接返回；而网上那种写法不做是否需要继续二分的判断，直接二分。如果要查找元素确实只存在一个，他的那种写法将会多做几次无用的二分，最后又将low指针移动到了元素所在的位置，而你的写法则不会做多余的二分，虽然时间复杂度都是O(logn)，但当考虑复杂度的系数、常量的时候你的算法更优。","like_count":1},{"had_liked":false,"id":260509,"user_name":"于途","can_delete":false,"product_type":"c1","uid":1669343,"ip_address":"","ucode":"70300C6CCCEAF1","user_header":"https://static001.geekbang.org/account/avatar/00/19/78/df/424bdc4a.jpg","comment_is_top":false,"comment_ctime":1605051137,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"5900018433","product_id":100017301,"comment_content":"二分查找更适合用于查找“近似”问题：<br>1.查找第一个等于给定值的元素；<br>2.查找最后一个等于给定值的元素；<br>3.查找第一个大于等于给定值的元素；<br>4.查找最后一个小于等于给定值的元素","like_count":1},{"had_liked":false,"id":177912,"user_name":"Jim","can_delete":false,"product_type":"c1","uid":1268788,"ip_address":"","ucode":"E3E8F9A527D6DB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/D9iciayk2kC7VxrsiauxngbMhcicm6CZiaXBa4JNbVdRqQ5HIpoqPzRptbttMdaGnTaUqZsEyW4kyZA2cyiaZCwZrWGA/132","comment_is_top":false,"comment_ctime":1581527108,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5876494404","product_id":100017301,"comment_content":"leet code 153. 寻找旋转排序数组中的最小值 跟变体类似，可以练习一下","like_count":1},{"had_liked":false,"id":130004,"user_name":"咸鱼抵渴","can_delete":false,"product_type":"c1","uid":1024289,"ip_address":"","ucode":"0DFE42C62EB243","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a1/21/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1567350015,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5862317311","product_id":100017301,"comment_content":"def find_rotate_index(lst):<br>    &quot;&quot;&quot;<br>    假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>    例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2]<br>    找出0所在的位置<br>    假设lst无重复数据 <br>    &quot;&quot;&quot;<br>    low = 0<br>    high = len(lst) -1<br>    if len(lst)==1:<br>        return lst[0]<br>    else:<br>        while low &lt;= high:<br>            mid = (low + high) &#47;&#47; 2<br>            # 因为lst无重复数据，且是两段有序组合，所以如果紧挨的两个元素，前一个大于后一个说明是要找的旋转点<br>            if lst[mid] &gt; lst[mid + 1]:<br>                return (mid + 1, lst[mid+1])<br>            # 因为是有序数组的翻转，所以反转点之后的数据都是要小于前面的数据<br>            # 如果lst[mid] &lt; lst[low] 说明mid 在 反转点的右侧，high = mid -1<br>            # 如果lst[mid] &gt; lst[low] 说明mid 在反转点左侧， low =mid+1<br>            else:<br>                if lst[mid] &lt; lst[low]:<br>                    high = mid - 1<br>                else:<br>                    low = mid + 1<br>    return -1","like_count":1},{"had_liked":false,"id":88901,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1556023572,"is_pvip":true,"replies":[{"id":"31847","content":"👍 麻烦编辑改下 多谢","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1556062054,"ip_address":"","comment_id":88901,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5850990868","product_id":100017301,"comment_content":"Donald E.Knuth 叫 高德纳。高德纳”这个中文名字是1977年他访问中国之前所取的，命名者是储枫（姚期智的夫人，计算机科学家）。他的妻子叫高精兰（Jill）。 这个名字不应该音译的。<br>","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447937,"discussion_content":"👍 麻烦编辑改下 多谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556062054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":52582,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1545445036,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5840412332","product_id":100017301,"comment_content":"今天再看这个篇文章的时候，突然想到思考题 把给定的数组 copy一份排个序 再二分^_^ 不知可不可行","like_count":1},{"had_liked":false,"id":42648,"user_name":"Laughing_Lz","can_delete":false,"product_type":"c1","uid":1251342,"ip_address":"","ucode":"7A7445E96F2978","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/0e/39307052.jpg","comment_is_top":false,"comment_ctime":1542988933,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5837956229","product_id":100017301,"comment_content":"\t&#47;**<br>\t * 循环数组中使用二分查找获取value所在位置<br>\t * <br>\t * @param arr   arr<br>\t * @param value value<br>\t * @return<br>\t *&#47;<br>\tpublic static int loopBinarySearch(int[] arr, int value) {<br>\t\tif (arr.length == 1) {<br>\t\t\tif (arr[0] == value) {<br>\t\t\t\treturn 0;<br>\t\t\t} else {<br>\t\t\t\treturn -1;<br>\t\t\t}<br>\t\t}<br>\t\tint low = 0, high = arr.length, middle = 0;<br>\t\t&#47;&#47; 首先获取首末位置<br>\t\tfor (int i = 0; i &lt; arr.length - 1; i++) {<br>\t\t\tif (arr[i] &gt; arr[i + 1]) {<br>\t\t\t\thigh = i;<br>\t\t\t\tlow = i + 1;<br>\t\t\t}<br>\t\t}<br>\t\tif (arr[arr.length - 1] &gt; arr[0]) {<br>\t\t\tlow = 0;<br>\t\t\thigh = arr.length - 1;<br>\t\t}<br>\t\t&#47;&#47; 经过和arr[0]判断后筛选出可能包含value的子数组<br>\t\tif (arr[0] == value) {<br>\t\t\treturn 0;<br>\t\t} else if (arr[0] &lt; value) {<br>\t\t\tlow = 1;<br>\t\t} else if (arr[0] &gt; value) {<br>\t\t\thigh = arr.length - 1;<br>\t\t}<br>\t\t&#47;&#47; 使用简单二分查找获取value位置<br>\t\twhile (low &lt;= high) {<br>\t\t\tmiddle = low + ((high - low) &gt;&gt; 1);<br>\t\t\tif (arr[middle] &gt; value) {<br>\t\t\t\thigh = middle - 1;<br>\t\t\t} else if (arr[middle] &lt; value) {<br>\t\t\t\tlow = middle + 1;<br>\t\t\t} else {<br>\t\t\t\treturn middle;<br>\t\t\t}<br>\t\t}<br>\t\treturn -1;<br>\t}","like_count":1},{"had_liked":false,"id":35660,"user_name":"Jeson","can_delete":false,"product_type":"c1","uid":1258168,"ip_address":"","ucode":"A75A8BF2EBD9CD","user_header":"https://static001.geekbang.org/account/avatar/00/13/32/b8/6a80fb00.jpg","comment_is_top":false,"comment_ctime":1540733289,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5835700585","product_id":100017301,"comment_content":"#查找第一个值等于给定值的元素<br>def bsearchFirst(nums, val):<br>    low, high = 0, len(nums) - 1<br>    while low &lt;= high:<br>        mid = low + ((high - low) &gt;&gt; 1)<br>        if nums[mid] &gt;= val:<br>            high = mid - 1<br>        else:<br>            low = mid + 1<br>    if nums[low] == val:<br>        return low<br>    else:<br>        return None<br><br>#查找最后一个值等于给定值的元素<br>def bsearchLast(nums, val):<br>    low, high = 0, len(nums) - 1<br>    while low &lt;= high:<br>        mid = low + ((high - low) &gt;&gt; 1)<br>        if nums[mid] &lt;= val:<br>            low = mid + 1<br>        else:<br>            high = mid - 1<br>    if nums[high] == val:<br>        return high<br>    else:<br>        return None<br><br>#查找第一个大于等于给定值的元素<br>def bsearchFirstLargerEqual(nums, val):<br>    low, high = 0, len(nums) - 1<br>    while low &lt;= high:<br>        mid = low + ((high - low) &gt;&gt; 1)<br>        if nums[mid] &gt;= val:<br>            high = mid - 1<br>        else:<br>            low = mid + 1<br>    if nums[low] &gt;= val:<br>        return low<br>    else:<br>        return None<br><br>#查找最后一个小于等于给定值的元素<br>def bSearchLastsmallerEqual(nums, val):<br>    low, high = 0, len(nums) - 1<br>    while low &lt;= high:<br>        mid = low + ((high - low) &gt;&gt; 1)<br>        if nums[mid] &lt;= val:<br>            low = mid + 1<br>        else:<br>            high = mid - 1<br>    if nums[high] &lt;= val:<br>        return high<br>    else:<br>        return None<br><br>#循环数组的二分查找<br>def bSearchRecycle(nums, val):<br>    n, offset = len(nums), 3<br>    low, high = 0, n - 1  <br>    while low &lt;= high:<br>        mid = low + ((high - low) &gt;&gt; 1)<br>        midIdx = (mid + offset) % n<br>        if nums[midIdx] == val:<br>            return midIdx<br>        elif nums[midIdx] &lt; val:<br>            low = mid + 1<br>        else:<br>            high = mid - 1<br>    return None<br><br>if __name__ == &#39;__main__&#39;:<br>    nums = [0, 0, 2, 2, 3, 3]<br>    val = 1<br>    print(bSearchLastsmallerEqual(nums, val))<br><br>    nums = [4, 5, 6, 1, 2, 3]<br>    val = 3<br>    print(bSearchRecycle(nums, val))","like_count":1},{"had_liked":false,"id":35523,"user_name":"锐雨","can_delete":false,"product_type":"c1","uid":1123139,"ip_address":"","ucode":"1B332E35C6A16D","user_header":"https://static001.geekbang.org/account/avatar/00/11/23/43/0fa84f5c.jpg","comment_is_top":false,"comment_ctime":1540636094,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5835603390","product_id":100017301,"comment_content":"关于循环有序数组的问题，假设array无重复元素的话，我们可以先二分法将array分成两个递增数组，再分别采用二分法。有不妥之处忘赐教哦, java：<br><br>\tpublic static int search(int x, int[] array) {<br>\t\tif (null == array || array.length == 0) {<br>\t\t\treturn -1;<br>\t\t}<br>\t\t&#47;** Step1. 先找到循环队列新一轮从小变大的起始位置*&#47;<br>\t\tint low = 1;<br>\t\tint high = array.length - 1;<br>\t\tint mid;<br>\t\tint firstVal = array[0];<br>\t\t&#47;*到firstVal之后第一个&lt;firstVal的position *&#47;<br>\t\tint dividePos = -1;<br>\t\twhile(low &lt;= high) {<br>\t\t\tmid = low + ((high - low)&gt;&gt;1);<br>\t\t\tif (array[mid] &gt; firstVal) {<br>\t\t\t\tlow = mid + 1;<br>\t\t\t} else {<br>\t\t\t\tif (mid == 1 || array[mid - 1] &gt; firstVal) {<br>\t\t\t\t\tdividePos = mid;<br>\t\t\t\t\tbreak;<br>\t\t\t\t} else {<br>\t\t\t\t\thigh = mid -1;<br>\t\t\t\t}<br>\t\t\t}<br>\t\t}<br>\t\t&#47;** Step2. 对dividePos两边分别进行二分搜索 *&#47;<br>\t\tint targetPos = -1;<br>\t\tif (dividePos &gt;= 1) {<br>\t\t\ttargetPos = bSearch(x, array, 0, dividePos - 1);<br>\t\t\tif (-1 != targetPos) {<br>\t\t\t\treturn targetPos;<br>\t\t\t} else {<br>\t\t\t\ttargetPos = bSearch(x, array, dividePos, array.length - 1);<br>\t\t\t};<br>\t\t} else {<br>\t\t\ttargetPos = bSearch(x, array, 0, array.length - 1);<br>\t\t}<br>\t\treturn targetPos;<br>\t}<br>\t<br>\t&#47;** 普通的二分搜索 *&#47;<br>\tpublic static int bSearch(int x, int[] array, int low, int high) {<br>\t\tif (null == array || array.length == 0 || low &lt; 0 || high &gt;= array.length) {<br>\t\t\treturn -1;<br>\t\t}<br>\t\tint mid;<br>\t\twhile(low &lt;= high) {<br>\t\t\tmid = low + ((high - low)&gt;&gt;1);<br>\t\t\tif (array[mid] &gt; x) {<br>\t\t\t\thigh = mid - 1;<br>\t\t\t} else if (array[mid] &lt; x) {<br>\t\t\t\tlow = mid + 1;<br>\t\t\t} else {<br>\t\t\t\treturn mid;<br>\t\t\t}<br>\t\t}<br>\t\treturn -1;<br>\t}","like_count":1},{"had_liked":false,"id":35462,"user_name":"小喵喵","can_delete":false,"product_type":"c1","uid":1062444,"ip_address":"","ucode":"FDBBB2A59DB8B6","user_header":"https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg","comment_is_top":false,"comment_ctime":1540604058,"is_pvip":false,"replies":[{"id":"12644","content":"c++有的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540690848,"ip_address":"","comment_id":35462,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5835571354","product_id":100017301,"comment_content":"二分查找的变体问题，在java sdk、net framework中有实现吗？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427543,"discussion_content":"c++有的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540690848,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35325,"user_name":"蒋礼锐","can_delete":false,"product_type":"c1","uid":1248897,"ip_address":"","ucode":"25E042066A1427","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/gM1ibHKPkrs5DSIp4aIuQ9jnYtNicc2tdG244PbaSvKw5jO9DWrhWghcVM1Y5Iq2QSpzLBUeWZQLhARst51z35mA/132","comment_is_top":false,"comment_ctime":1540517691,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5835484987","product_id":100017301,"comment_content":"留言有个地方写错了，不应该在n&#47;i二分时，应该是A(j-i)到A(j)。还请老师指点这样的思路是否正确","like_count":1},{"had_liked":false,"id":35324,"user_name":"tszzsk","can_delete":false,"product_type":"c1","uid":1233805,"ip_address":"","ucode":"7AA2D8B0390F78","user_header":"https://static001.geekbang.org/account/avatar/00/12/d3/8d/5df4ca11.jpg","comment_is_top":false,"comment_ctime":1540517566,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5835484862","product_id":100017301,"comment_content":"第二段代码：if ((mid == 0) || (a[mid - 1] != value)) 可否改为 if ((mid == low) || (a[mid - 1] != value)) ？以及下面变体?","like_count":1},{"had_liked":false,"id":35291,"user_name":"He110","can_delete":false,"product_type":"c1","uid":1037211,"ip_address":"","ucode":"163D7E5DD0A9C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d3/9b/ea5fc0df.jpg","comment_is_top":false,"comment_ctime":1540512184,"is_pvip":false,"replies":[{"id":"12568","content":"有大量重复数据时 就慢了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540515817,"ip_address":"","comment_id":35291,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5835479480","product_id":100017301,"comment_content":"觉得在查找到值之后，使用 while(arr[mid-1) == value) mid--，这种可能好些，就是二分转遍历，如果数据量大而重复的数据量的个数不多的话，这种可能更有优势，如果是十个数据里面七八个需要查找的数据这种就肯定是二分了，但是这种的话，直接遍历可能也不慢","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427505,"discussion_content":"有大量重复数据时 就慢了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540515817,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358535,"user_name":"111","can_delete":false,"product_type":"c1","uid":3109487,"ip_address":"北京","ucode":"D6E8E83A118A3E","user_header":"https://static001.geekbang.org/account/avatar/00/2f/72/6f/44c10658.jpg","comment_is_top":false,"comment_ctime":1664416643,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664416643","product_id":100017301,"comment_content":"二分变种<br>通过细分==target时的不同情况来处理，让代码变得简单易懂。这很重要<br>思考题，通过取余将循环数组拉直进行运算。这样比较符合常识<br>func search(nums []int, target int) int {<br>\toffset := 0<br>\tfor i := 1; i &lt; len(nums); i++ {<br>\t\tif nums[i-1] &gt; nums[i] {<br>\t\t\toffset = i<br>\t\t\tbreak<br>\t\t}<br>\t}<br>\tleft := 0<br>\tright := len(nums) - 1<br>\tfor left &lt;= right {<br>\t\tmid := left + (right-left)&gt;&gt;1<br>\t\ttmp := (mid + offset) % (len(nums))<br>\t\tif nums[tmp] &gt; target {<br>\t\t\tright = mid - 1<br>\t\t} else if nums[tmp] &lt; target {<br>\t\t\tleft = mid + 1<br>\t\t} else {<br>\t\t\tleft = tmp<br>\t\t\tbreak<br>\t\t}<br>\t}<br>\tif left &lt; len(nums) &amp;&amp; nums[left] == target {<br>        return left<br>\t} else {<br>        return -1<br>\t}<br>}","like_count":0},{"had_liked":false,"id":347960,"user_name":"MClink","can_delete":false,"product_type":"c1","uid":1435733,"ip_address":"","ucode":"F479190923355C","user_header":"https://static001.geekbang.org/account/avatar/00/15/e8/55/92f82281.jpg","comment_is_top":false,"comment_ctime":1654608857,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1654608857","product_id":100017301,"comment_content":"这些变体题，一开始我想的做法是，想用二分法找到值，先不管是不是要的，找到之后，因为是有序的，所以再基于所在的值坐标往左走或者往右走来判断，也可以解决问题。","like_count":0},{"had_liked":false,"id":346278,"user_name":"吴迪","can_delete":false,"product_type":"c1","uid":1209066,"ip_address":"","ucode":"8E649B27F10ABE","user_header":"https://static001.geekbang.org/account/avatar/00/12/72/ea/eae1c093.jpg","comment_is_top":false,"comment_ctime":1652972375,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1652972375","product_id":100017301,"comment_content":"golang 写的 思考题<br>func search3(a []int, value int) int {<br>\tn := len(a)<br>\tleft, right := 0, n-1<br>\tfor left &lt;= right {<br>\t\tmid := left + ((right - left) &gt;&gt; 1)<br>\t\tif a[mid] == value {<br>\t\t\treturn mid<br>\t\t}<br>\t\tif a[left] &gt; a[mid] {<br>\t\t\tif a[mid] &lt; value &amp;&amp; a[right] &gt;= value {<br>\t\t\t\tleft = mid + 1<br>\t\t\t} else {<br>\t\t\t\tright = mid - 1<br>\t\t\t}<br>\t\t} else {<br>\t\t\tif a[left] &lt;= value &amp;&amp; a[mid] &gt; value {<br>\t\t\t\tright = mid - 1<br>\t\t\t} else {<br>\t\t\t\tleft = mid + 1<br>\t\t\t}<br>\t\t}<br>\t}<br>\treturn -1<br>}","like_count":0},{"had_liked":false,"id":344582,"user_name":"hu","can_delete":false,"product_type":"c1","uid":1110492,"ip_address":"","ucode":"57A074D5904907","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/dc/05df7333.jpg","comment_is_top":false,"comment_ctime":1651655932,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651655932","product_id":100017301,"comment_content":"漂亮。","like_count":0},{"had_liked":false,"id":339101,"user_name":"嗯","can_delete":false,"product_type":"c1","uid":1273045,"ip_address":"","ucode":"4C53226F9113BF","user_header":"https://static001.geekbang.org/account/avatar/00/13/6c/d5/2597f6dd.jpg","comment_is_top":false,"comment_ctime":1647917608,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647917608","product_id":100017301,"comment_content":"试了一下思考题：<br>var search = function(nums, target) {<br>        let arr = nums.map((num, index) =&gt; ({<br>          value: num,<br>          index<br>        }))<br>        arr = arr.sort((a, b) =&gt; a.value - b.value)<br>        <br>        let low = 0;<br>        let high = nums.length - 1<br><br>        while(low &lt;= high) {<br>          let mid = low + ((high - low) &gt;&gt; 1)<br>          if (arr[mid].value &lt; target) {<br>            low = mid + 1<br>          } else if (arr[mid].value &gt; target) {<br>            high = mid -1<br>          } else {<br>            return arr[mid].index<br>          }<br>        }<br>        return -1<br>      };","like_count":0},{"had_liked":false,"id":337356,"user_name":"小帅","can_delete":false,"product_type":"c1","uid":2186026,"ip_address":"","ucode":"5DE78DC9EFCA49","user_header":"https://static001.geekbang.org/account/avatar/00/21/5b/2a/3c5bedc9.jpg","comment_is_top":false,"comment_ctime":1646789019,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646789019","product_id":100017301,"comment_content":"自己用c实现了一下，一四变体可以用mid=low+(high-low)&gt;&gt;1   .二四变体不能用，只能用mid=low+(high-low)  &#47;2   .","like_count":0},{"had_liked":false,"id":336915,"user_name":"Today","can_delete":false,"product_type":"c1","uid":1235000,"ip_address":"","ucode":"4FA397F0BD8C6E","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/38/41027bda.jpg","comment_is_top":false,"comment_ctime":1646466209,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646466209","product_id":100017301,"comment_content":"内容小结：<br><br>1. 二分查找在有序数组中找数据时，有一些变形题：<br><br>    ① 查找第一个或最后一个等于给定值的元素<br><br>    ② 查找第一个大于等于给定值的元素<br><br>    ③ 查找最后一个小于等于给定值的元素<br><br>2. 凡是可以使用二分查找解决的，大部分更倾向于使用散列表或者二叉查找树来解决，但是遇到 “近似” 查找而不是 “给定值” 查找时，二分查找的优势更大。<br><br>启发：<br><br>​\t在查找等于目标值第一个数时，low 越界的复杂处理直接被一个 if-else 提前简化边界判断，就很好理解！<br><br>思考题：<br><br>​\t循环数组本质上是由两个有序数组组合而成的，先使用基本的二分查找模板，比较的时候进行边界处理（当目标值 和 mid 值在同一个有序数组，转成基本问题，否则舍弃掉mid所在的一边， 继续二分）<br><br>","like_count":0},{"had_liked":false,"id":334864,"user_name":"尹月胜","can_delete":false,"product_type":"c1","uid":1127322,"ip_address":"","ucode":"24C1F14229C2EC","user_header":"https://static001.geekbang.org/account/avatar/00/11/33/9a/ef8c4644.jpg","comment_is_top":false,"comment_ctime":1645159739,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645159739","product_id":100017301,"comment_content":"这一节，评论很多哈","like_count":0},{"had_liked":false,"id":331907,"user_name":"sorrowfulliu","can_delete":false,"product_type":"c1","uid":2007754,"ip_address":"","ucode":"2F079251A889D4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/hnOgOD1tZvFzxTV0o7icHMxq0rchefUEe7HHia6OGBpdnnd67ooam4GCQNlJic6rhpryjedfEznV29YH2lAfyQNZQ/132","comment_is_top":false,"comment_ctime":1642862100,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642862100","product_id":100017301,"comment_content":"int search(vector&lt;int&gt; &amp;nums, int target) {<br>\tif (nums.empty()) return -1;<br>\tint len = nums.size();<br>\tint lo = 0, hi = len - 1;<br>\twhile (lo &lt; hi) {<br>\t\tint mi = lo + (hi - lo) &#47; 2;<br>\t\tif (nums[lo] &lt;= nums[mi]) { &#47;&#47;左半部分有序<br>\t\t\tif (target &lt;= nums[mi] &amp;&amp; nums[lo] &lt;= target) hi = mi;<br>\t\t\telse lo = mi + 1;<br>\t\t} else { &#47;&#47;右半部分有序<br>\t\t\tif (target &gt; nums[mi] &amp;&amp; nums[hi] &gt;= target) lo = mi + 1;<br>\t\t\telse hi = mi;<br>\t\t}<br>\t}<br>\treturn nums[lo] == target ? lo : -1;<br>}","like_count":0},{"had_liked":false,"id":331603,"user_name":"觉浅","can_delete":false,"product_type":"c1","uid":2893824,"ip_address":"","ucode":"32979A2CCB855A","user_header":"https://static001.geekbang.org/account/avatar/00/2c/28/00/2f783ebf.jpg","comment_is_top":false,"comment_ctime":1642668862,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642668862","product_id":100017301,"comment_content":"变体三和变体四的代码怎么看起来放反了？还是我没有看懂需要再看看😪","like_count":0},{"had_liked":false,"id":331429,"user_name":"胡家琪","can_delete":false,"product_type":"c1","uid":2551070,"ip_address":"","ucode":"FD2CEA0B6E5C13","user_header":"https://static001.geekbang.org/account/avatar/00/26/ed/1e/9e148e4f.jpg","comment_is_top":false,"comment_ctime":1642583469,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642583469","product_id":100017301,"comment_content":"老师你的课后思考的问题引出几个问题，什么是循环有序数组，如何界定一个数组有序与无序呢。我是刚开始接触到循环有序数组的概念，没有一个具体的认知，做题起来很艰难，希望老师能给我解答解答","like_count":0},{"had_liked":false,"id":328349,"user_name":"行知","can_delete":false,"product_type":"c1","uid":1694227,"ip_address":"","ucode":"90FA8A23BAEFC5","user_header":"https://static001.geekbang.org/account/avatar/00/19/da/13/2fddf167.jpg","comment_is_top":false,"comment_ctime":1640680491,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640680491","product_id":100017301,"comment_content":"思考题：<br><br>func search(nums []int, target int) int {<br>    if len(nums) &lt; 1 || (len(nums) == 1 &amp;&amp; nums[0] != target) {<br>\t\treturn -1<br>\t} else if nums[0] == target {<br>\t\treturn 0<br>\t}<br>\tl, r := 0, len(nums)-1<br>\tfor l &lt;= r {<br>\t\tmid := l + (r-l)&gt;&gt;1<br>\t\tif nums[mid] == target {<br>\t\t\treturn mid<br>\t\t} else if nums[mid] &gt;= nums[l] { &#47;&#47; 说明l~mid 这段为有序数组, 且e在l~mid区间<br>\t\t\tif nums[l] &lt;= target &amp;&amp; target &lt; nums[mid] {<br>\t\t\t\tr = mid - 1<br>\t\t\t} else {<br>\t\t\t\tl = mid + 1<br>\t\t\t}<br>\t\t} else if nums[mid] &lt;= nums[r] { &#47;&#47; 说明mid ~ r 这段为有序数组,<br>\t\t\tif nums[mid] &lt; target &amp;&amp; target &lt;= nums[r] {<br>\t\t\t\tl = mid + 1<br>\t\t\t} else {<br>\t\t\t\tr = mid - 1<br>\t\t\t}<br>\t\t}<br>\t}<br>\treturn -1<br>}","like_count":0},{"had_liked":false,"id":327546,"user_name":"Alancere","can_delete":false,"product_type":"c1","uid":2170382,"ip_address":"","ucode":"245BBF1B9A869F","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/ohDdvzhycYXfEbIYPw66MnohjO9suMGmQzSKMR00wfialHbhjVqia3BvJcD3JXThicpD1T2rFMBcgNT2CmyRnqPqw/132","comment_is_top":false,"comment_ctime":1640165638,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640165638","product_id":100017301,"comment_content":"go 语言实现： 利用循环有序数组性质。<br>\tif len(s) == 0 {<br>\t\treturn -1<br>\t}<br>\tlow := 0<br>\thigh := len(s) - 1<br>\tfor low &lt;= high {<br>\t\tmid := low + ((high - low) &gt;&gt; 1)<br>\t\tif s[mid] == value {<br>\t\t\treturn mid<br>\t\t} else if value &gt; s[mid] {<br>\t\t\tif s[low] &gt; value {<br>\t\t\t\thigh = mid + 1<br>\t\t\t} else {<br>\t\t\t\tlow = mid + 1<br>\t\t\t}<br>\t\t} else if value &lt; s[mid] {<br>\t\t\tif s[low] &gt; value {<br>\t\t\t\tlow = mid + 1<br>\t\t\t} else {<br>\t\t\t\thigh = mid - 1<br>\t\t\t}<br>\t\t}<br>\t}<br>\treturn -1","like_count":0},{"had_liked":false,"id":327418,"user_name":"weirdw","can_delete":false,"product_type":"c1","uid":2597645,"ip_address":"","ucode":"CC97D762CF383A","user_header":"https://static001.geekbang.org/account/avatar/00/27/a3/0d/b3a40f90.jpg","comment_is_top":false,"comment_ctime":1640130865,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640130865","product_id":100017301,"comment_content":"逻辑清晰的代码比简洁的代码看着舒服多了👍","like_count":0},{"had_liked":false,"id":322170,"user_name":"xjt","can_delete":false,"product_type":"c1","uid":1979799,"ip_address":"","ucode":"EDAA528E720917","user_header":"https://static001.geekbang.org/account/avatar/00/1e/35/97/83f634cc.jpg","comment_is_top":false,"comment_ctime":1637219250,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1637219250","product_id":100017301,"comment_content":"总结规则<br>&#47;**<br> * 变异二分查找<br> * 1、判断目标数据是在左分支还是右分支<br> *<br> * 2、目标数据在右分支。（关键词，“最后一个”等）<br> * 2.1、左侧判断直接更新high。<br> * 2.2、右侧先判断命中条件（包括判断最右位置length-1），命中返回middle，否则更新low。<br> *<br> * 3、目标数据在左分支。（关键词，“第一个”等）<br> * 3.1、右侧判断直接更新low。<br> * 3.2、左侧先判断命中条件（包括判断最左位置0），命中返回middle，否则更新high。<br> * *&#47;","like_count":0},{"had_liked":false,"id":318355,"user_name":"Geek_32f283","can_delete":false,"product_type":"c1","uid":2809582,"ip_address":"","ucode":"933E651AB54D50","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/YMYG4Tsr7vXWPics5eXpHUHicI4dibspRFgZP2WrEQdDdODVNETegPapXRSnJbcKuOsryrW0NGmCKwJXGVo8ZJTQA/132","comment_is_top":false,"comment_ctime":1635255123,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635255123","product_id":100017301,"comment_content":"思考题<br>Leetcode 33 搜索旋转排序数组<br>func search(nums []int, target int) int {<br>    &#47;&#47; 先查找最小数的位置 始终与最右边的数比较 来修改自己的查找范围<br>    var findindex func(left, right int)int<br>    findindex = func(left, right int)int{<br>        mid := 0<br>        for left &lt;= right{<br>            mid = left+(right-left) &gt;&gt; 1<br>            if nums[mid] &gt; nums[right]{<br>                left = mid + 1<br>            }else if nums[mid] &lt; nums[right]{<br>                right = mid<br>            }else{<br>                break<br>            }<br>        }<br>        return mid<br>    }<br>    index := findindex(0, len(nums)-1)<br>    &#47;&#47; 二分查找两个区间<br>    var binarysearch func(left int, right int)int<br>    binarysearch = func(left, right int)int{<br>        for left &lt;= right{<br>            mid := left + (right-left)&gt;&gt;1<br>            if(nums[mid] == target){<br>                return mid<br>            }else if nums[mid] &gt; target{<br>                right = mid -1<br>            }else{<br>                left = mid + 1<br>            }<br>        }<br>        return -1<br>    }<br>    ans := -1<br>    if binarysearch(0, index) != -1{<br>        ans =  binarysearch(0, index)<br>    }else if binarysearch(index, len(nums)-1) != -1{<br>        ans = binarysearch(index, len(nums)-1)<br>    }<br>    return ans<br><br>}","like_count":0},{"had_liked":false,"id":317346,"user_name":"Shinran.","can_delete":false,"product_type":"c1","uid":1240937,"ip_address":"","ucode":"E28AF157D1A93E","user_header":"https://static001.geekbang.org/account/avatar/00/12/ef/69/25ea2d67.jpg","comment_is_top":false,"comment_ctime":1634746569,"is_pvip":false,"discussion_count":0,"race_medal":2,"score":"1634746569","product_id":100017301,"comment_content":"开篇IP定位问题，请问为什么是查找最后一个呢","like_count":0},{"had_liked":false,"id":314630,"user_name":"鄙鼠⊙﹏⊙","can_delete":false,"product_type":"c1","uid":1722121,"ip_address":"","ucode":"2814CB1D7CF0EF","user_header":"https://static001.geekbang.org/account/avatar/00/1a/47/09/d8702640.jpg","comment_is_top":false,"comment_ctime":1633266761,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633266761","product_id":100017301,"comment_content":"    &#47;**<br>     * 旋转排序数组 (循环有序数组解法)<br>     * low:数组开始下标   high:数组结束下标  mid:二分查找的中间下标<br>     * 变种后的数组存在两种 例:原数组a 3, 4, 6, 7, 8, 10, 11, 12, 13, 19, 28, 29, 49 变种后的数组有如下两种<br>     * 第一种 a1: 6, 7, 8, 10, 11, 12, 13, 19, 28, 29, 49, 3, 4  此时a[low] &lt; a[mid] 例子中 a[0]&lt;a[6], 1&lt;13 此时前半部分是有序的<br>     * 第二种 a2: 28, 29, 49, 3, 4, 6, 7, 8, 10, 11, 12, 13, 19  此时a[low] &gt; a[mid] 例子种 a[0]&gt;a[6], 28&gt;7 此时后半部分是有序的<br>     * 故在二分查找时候也分为两种情况<br>     * 1.nums[start] &lt;= nums[mid]<br>     * 2.nums[start] &gt; nums[mid]<br>     * &lt;p&gt;<br>     * 其余的和最简单的二分查找一样<br>     * 时间复杂度O(logn)<br>     * @param a      原数组<br>     * @param target 查找的目标值<br>     * @return<br>     *&#47;<br>    public int binarySearch2(int[] a, int target) {<br>        if (a.length == 0 || a == null) {<br>            return -1;<br>        }<br>        int low = 0;<br>        int high = a.length - 1;<br>        int mid;<br><br>        while (low &lt;= high) {<br>            mid = low + ((high - low) &gt;&gt; 1);<br>            if (a[mid] == target) {<br>                return mid;<br>            }<br><br>            &#47;** 为什么 a[low] &lt;= a[mid] 而不是 a[low] &lt; a[mid]？ 因为当最后剩下两个数的时候, 有可能a[low] = a[mid], 若没有&lt;= 则永远无法找到<br>             *  例子: 当在a1查找28这个target值时候, 通过二分查找最后匹配剩下19,28这两个数, 此时mid和low的下标相同, 此时a[low] = a[mid], 这个时候只有判<br>             *  断条件a[low] &lt;= a[mid]才能进入匹配<br>             *&#47;<br>            if (a[low] &lt;= a[mid]) {<br>                if (target &gt;= a[low] &amp;&amp; target &lt; a[mid]) {<br>                    high = mid - 1;<br>                } else {<br>                    low = mid + 1;<br>                }<br>            } else {<br>                if (target &gt; a[mid] &amp;&amp; target &lt;= a[high]) {<br>                    low = mid + 1;<br>                } else {<br>                    high = mid - 1;<br>                }<br>            }<br>        }<br>        return -1;<br>    }","like_count":0},{"had_liked":false,"id":313695,"user_name":"沈畅","can_delete":false,"product_type":"c1","uid":1077953,"ip_address":"","ucode":"7404E41356B36B","user_header":"https://static001.geekbang.org/account/avatar/00/10/72/c1/59509397.jpg","comment_is_top":false,"comment_ctime":1632622050,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1632622050","product_id":100017301,"comment_content":"如果数据量在100-200是不是怎么查找效率都差不多啊？对于这种小数据量的查找有没有什么好办法呢？","like_count":0},{"had_liked":false,"id":313653,"user_name":"Wei鸿","can_delete":false,"product_type":"c1","uid":2750312,"ip_address":"","ucode":"8015E5D852436C","user_header":"https://static001.geekbang.org/account/avatar/00/29/f7/68/e3b1553a.jpg","comment_is_top":false,"comment_ctime":1632581752,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632581752","product_id":100017301,"comment_content":"所以究竟是循环有序数组 还是旋转有序数组呢？ 还是两者是一样的？","like_count":0},{"had_liked":false,"id":309096,"user_name":"while (1)等;","can_delete":false,"product_type":"c1","uid":1061991,"ip_address":"","ucode":"BAEC7258D65B69","user_header":"https://static001.geekbang.org/account/avatar/00/10/34/67/06a7f9be.jpg","comment_is_top":false,"comment_ctime":1629943202,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1629943202","product_id":100017301,"comment_content":"这个IP查找是不是也可以用“在有序数组中，查找第一个大于等于某个给定值的元素”，查找区间右侧的ip第一个大于等于给定的ip","like_count":0},{"had_liked":false,"id":309093,"user_name":"三思伍","can_delete":false,"product_type":"c1","uid":2739730,"ip_address":"","ucode":"9E01445F60E374","user_header":"https://static001.geekbang.org/account/avatar/00/29/ce/12/24c33b47.jpg","comment_is_top":false,"comment_ctime":1629942211,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629942211","product_id":100017301,"comment_content":"请问，查找第一个&#47;最后一个等于（或大于等于、小于等于）给定值的时候。<br>比如前两个代码块，第11行关键代码处。边界条件不应该是mid==low或mid==high吗？如果是第一次循环即找到，则mid==low==0，或mid==high==n-1也成立；如果是在区间更新到中间区块时，已说明两端外侧元素不满足条件，此时low和high都是中间某值，则此时mid不可能到达原数组边界呀，此时的边界应该是low和high吧。<br>如有错误之处，还请老师指出。","like_count":0},{"had_liked":false,"id":306671,"user_name":"苦久了","can_delete":false,"product_type":"c1","uid":2682173,"ip_address":"","ucode":"E039164B148955","user_header":"https://static001.geekbang.org/account/avatar/00/28/ed/3d/95457f63.jpg","comment_is_top":false,"comment_ctime":1628664999,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628664999","product_id":100017301,"comment_content":"我在else那里面做了一些处理，在数据量比较大的情况下，我觉得效率会更高一些；然后数组越界的情况，我也考虑到了<br><br>template&lt;typename T&gt;<br>int BinSearch_1(T a[], int n, T val)  &#47;&#47; 变体一：查找第一个值等于给定值的元素<br>{   <br>    int mid(0), low(0), high(n-1);<br>    while (low &lt;= high)<br>    {<br>        mid = low + ((high - low) &gt;&gt; 1);<br>        if (val &gt; a[mid] ){<br>            low = mid + 1;<br>        }<br>        else if ( val &lt; a[mid] ){<br>            high = mid -1;<br>        }<br>        else &#47;&#47; a[mid] = val, 这时候看找到的val，是不是唯一数，如果不是唯一的，那么找到连续的几个val中，最左边那个<br>        {   <br>            if( ( mid == 0) ||( a[mid-1]&lt; val ) )<br>                return mid;<br>            else&#47;&#47; 数据按照从小到大排序，val值有多个的话，肯定是连续的，只要挨个向左找到第一个值为val的就行，比如3 3 3 5 7 8 ，val=3<br>                {   &#47;&#47;情况1：碰到第一个小于val 的数，退出while，返回mid+1<br>                    &#47;&#47;情况2：向左遍历过程中，while循环未退出，碰到数组边界，那么直接返回mid&#47;0<br>                    while ( a[--mid] == val ){<br>                        if (mid == 0) &#47;&#47; 这里加一个if语句，是为了防止数组越界的问题，可能出现a[-1] == val的情况<br>                            return mid;<br>                    }<br>                    &#47;&#47; mid向左移动，发现一个小于val 的数，那么它右边的那个数就是数组中的第一个val<br>                    return mid + 1;                  <br>                }<br>        }   <br>    }<br>    return -1;<br>}","like_count":0},{"had_liked":false,"id":306095,"user_name":"William Ning","can_delete":false,"product_type":"c1","uid":1592279,"ip_address":"","ucode":"4DB8D05E69E5F3","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","comment_is_top":false,"comment_ctime":1628345713,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1628345713","product_id":100017301,"comment_content":"课后题<br>PHP Code<br><br>&lt;?php<br>class Solution {<br><br>    &#47;**<br>     * @param Integer[] $nums<br>     * @param Integer $target<br>     * @return Integer<br>     *&#47;<br>    function search($nums, $target) {<br>        $count = count($nums);<br>        if ($count == 0) {<br>            return -1;<br>        }<br>        if ($count == 1) {<br>            return $nums[0] == $target ? 0 : -1;<br>        }<br>        $row = $this-&gt;getRow($nums, 0, $count - 1);<br>        # 等于零代表数组是一个正序数组<br>        if ($row == 0) {<br>            return $this-&gt;findIndex($nums, 0, $count-1, $target);<br>        } elseif ($nums[0] &gt; $target) { # 如果第一个值大于目标值 代表目标值在旋转值后面<br>            return $this-&gt;findIndex($nums, $row, $count-1, $target);<br>        } else { # 从0开始查找<br>            return $this-&gt;findIndex($nums, 0, $row, $target);<br>        }<br>    }<br><br>    # 查找旋转值下标<br>    function getRow($nums, $l, $r){<br>        if ($nums[$l] &lt; $nums[$r]) {<br>            return 0;<br>        }<br>        while ($l&lt;=$r) {<br>            $mid = floor(($l+$r) &#47; 2);<br>            if ($nums[$mid] &gt; $nums[$mid +1]) {<br>                return $mid + 1;<br>            } else {<br>                if ($nums[$mid] &lt; $nums[$l]) {<br>                    $r = $mid - 1;<br>                } else{<br>                    $l = $mid + 1;<br>                }<br>            }<br>        }<br>    }<br>    # 查找目标值<br>    function findIndex($nums, $l, $r, $t) {<br>        while ($l&lt;=$r) {<br>            $mid = $l + ( ($r - $l) &gt;&gt; 1 );<br>            if ($nums[$mid] == $t) {<br>                return $mid;<br>            }<br>            if ($nums[$mid] &gt; $t) {<br>                $r = $mid - 1;<br>            } elseif ($nums[$mid] &lt; $t) {<br>                $l = $mid + 1;<br>            }<br>        }<br>        return -1;<br>    }<br>}","like_count":0},{"had_liked":false,"id":305592,"user_name":"1979104101ng","can_delete":false,"product_type":"c1","uid":2138770,"ip_address":"","ucode":"95204E6CBA81D6","user_header":"https://static001.geekbang.org/account/avatar/00/20/a2/92/6bbcb80b.jpg","comment_is_top":false,"comment_ctime":1628063219,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628063219","product_id":100017301,"comment_content":"用 JS 写了课例，新手风格<br>function bsearch(arr, val, low, high, flag) {<br>\t&#47;&#47; &lt;flag&gt; 0 表示找第一个 1 表示找最后一个<br>\t&#47;&#47; 2 表示找第一个大于等于的元素 3 表示找最后一个小于等于的元素<br>\tlet mid = low + ((high - low) &gt;&gt; 1);<br>\tif (arr[mid] == val) {<br>\t\tif (flag == 0) {<br>\t\t\tif (mid == 0 || arr[mid - 1] != val) {<br>\t\t\t\treturn arr[mid]<br>\t\t\t} else {<br>\t\t\t\treturn bsearch(arr, val, low, mid - 1, flag);<br>\t\t\t}<br>\t\t} else if (flag == 1) {<br>\t\t\tif (mid == high || arr[mid + 1] != val) {<br>\t\t\t\treturn arr[mid];<br>\t\t\t} else {<br>\t\t\t\treturn bsearch(arr, val, mid + 1, high, flag);<br>\t\t\t}<br>\t\t} else if (flag == 2) {<br>\t\t\tif (mid == 0 || arr[mid - 1] &lt; val) {<br>\t\t\t\treturn arr[mid];<br>\t\t\t} else {<br>\t\t\t\treturn bsearch(arr, val, low, mid - 1, flag);<br>\t\t\t}<br>\t\t} else if (flag == 3) {<br>\t\t\tif (mid == high || arr[mid + 1] &gt; val) {<br>\t\t\t\treturn arr[mid];<br>\t\t\t} else {<br>\t\t\t\treturn bsearch(arr, val, mid + 1, high, flag);<br>\t\t\t}<br>\t\t}<br>\t} else if (mid == 0 || mid == high) {<br>\t\treturn -1;<br>\t} else if (arr[mid] &lt; val) {<br>\t\treturn bsearch(arr, val, mid + 1, high, flag);<br>\t} else if (arr[mid] &gt; val) {<br>\t\treturn bsearch(arr, val, low, mid - 1, flag);<br>\t}<br>}","like_count":0},{"had_liked":false,"id":304497,"user_name":"Geek_842f07","can_delete":false,"product_type":"c1","uid":2698987,"ip_address":"","ucode":"ED772AF755FE7E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/WP4Ge8ABcINFkccKaNYKibicFnI0JAoojBBAUGrichNeRAgzm5RGbHG7GqYrFX3ELEzenuEbicQHJy2HZ72RxSOuMA/132","comment_is_top":false,"comment_ctime":1627455594,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627455594","product_id":100017301,"comment_content":"现在这个问题应该很简单了。如果 IP 区间与归属地的对应关系不经常更新，我们可以先预处理这 12 万条数据，让其按照起始 IP 从小到大排序。如何来排序呢？我们知道，IP 地址可以转化为 32 位的整型数。所以，我们可以将起始地址，按照对应的整型值的大小关系，从小到大进行排序。<br>请问这里是不是用到之前学习的计数排序？","like_count":0},{"had_liked":false,"id":304026,"user_name":"杨可","can_delete":false,"product_type":"c1","uid":2042428,"ip_address":"","ucode":"4D50A4E5C20EDC","user_header":"","comment_is_top":false,"comment_ctime":1627195607,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627195607","product_id":100017301,"comment_content":"课后习题的swift版本解法<br>https:&#47;&#47;note.youdao.com&#47;s&#47;RMQLc25j","like_count":0},{"had_liked":false,"id":303364,"user_name":"Tomie","can_delete":false,"product_type":"c1","uid":2370779,"ip_address":"","ucode":"3531EBA88C1EAB","user_header":"","comment_is_top":false,"comment_ctime":1626753277,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626753277","product_id":100017301,"comment_content":"  # 查找第一个大于val的数字 按照这么走 有问题，帮忙科普下，错在哪里<br>def binary_search(val, l):<br>    print(&#39;要查找的数字为%s&#39; % val)<br>    stat = 0<br>    end = len(l) - 1<br>    while stat &lt;= end:<br>        mid = stat + ((end - stat) &gt;&gt; 1)<br>        if l[mid] &gt;= val:<br>            if mid == 0 or l[mid - 1] &lt; val:<br>                print(&quot;第一大于%s 的数为%s&quot; % (val, l[mid]))<br>                return mid<br>            else:<br>                end = mid - 1<br>        else:<br>            stat = mid + 1<br>    return -1<br><br>a = [1, 2, 3, 4, 5, 6]<br>binary_search(3, a)<br>运行结果<br>要查找的数字为3<br>第一大于3 的数为3","like_count":0},{"had_liked":false,"id":302904,"user_name":"JC","can_delete":false,"product_type":"c1","uid":2466389,"ip_address":"","ucode":"0FB3C53427DF98","user_header":"https://static001.geekbang.org/account/avatar/00/25/a2/55/ec6b990a.jpg","comment_is_top":false,"comment_ctime":1626428661,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626428661","product_id":100017301,"comment_content":"二分查找中 mid 公式由来以及溢出解答：<br><br>int mid = (low + high)&#47;2<br>只是<br>int mid = low + ((high - low)&gt;&gt;1)<br>的化简<br>但是化简后发现，有可能当 (low+high)&#47;2 的时候 会超过 mid 类型的最大值 （即溢出）<br>这也是前辈们踩的坑，后人需特别注意！！！<br><br>至于  int mid = low + ((high - low)&gt;&gt;1) 公式怎么来的，你数组画画就明白了。<br>那为什么   ((high - low)&gt;&gt;1) 这里要用 () 括起来，完全和语言运算优先级挂钩。","like_count":0},{"had_liked":false,"id":302880,"user_name":"庆庆","can_delete":false,"product_type":"c1","uid":2259843,"ip_address":"","ucode":"77BE2DCEF15450","user_header":"https://static001.geekbang.org/account/avatar/00/22/7b/83/cbfeddae.jpg","comment_is_top":false,"comment_ctime":1626421166,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626421166","product_id":100017301,"comment_content":"class Solution {<br>public:<br>    int search(vector&lt;int&gt;&amp; nums, int target) {<br>        int low = 0;<br>        int high = nums.size() - 1;<br><br>        while(low &lt;= high)<br>        {<br>            int mid = low + ((high - low) &gt;&gt; 1);<br><br>            if(nums[mid] == target)<br>            {<br>                return mid;<br>            }<br><br>            &#47;&#47; 左半边有序<br>            if(nums[low] &lt;= nums[mid])<br>            {<br>                if(nums[low] &lt;= target &amp;&amp; target &lt; nums[mid])<br>                {<br>                    high = mid - 1;<br>                }<br>                else<br>                {<br>                    low = mid + 1;<br>                }<br>            }<br>            else &#47;&#47; 右半边有序<br>            {<br>                if(nums[mid] &lt; target &amp;&amp; target &lt;= nums[high])<br>                {<br>                    low = mid + 1;<br>                }<br>                else<br>                {<br>                    high = mid - 1;<br>                }<br>            }<br>        }<br><br>        return -1;<br>    }<br>};","like_count":0},{"had_liked":false,"id":298144,"user_name":"Shonn","can_delete":false,"product_type":"c1","uid":1590542,"ip_address":"","ucode":"393C2004D5A881","user_header":"https://static001.geekbang.org/account/avatar/00/18/45/0e/0901b3c3.jpg","comment_is_top":false,"comment_ctime":1623922846,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623922846","product_id":100017301,"comment_content":"留言已经说的很仔细了，我就把时间复杂度为O(logn)的方法实现一下：<br>    public int cycleBinarySearch(int[] a, int value) {<br>        int l = 0, r = a.length - 1;<br>        int mid;<br><br>        while (l &lt;= r) {<br>            mid = l + ((r - l) &gt;&gt; 1);<br><br>            if (a[mid] == value) {<br>                return mid;<br>            } else if (a[mid] &gt; a[l]) {<br>                &#47;&#47;左侧是有序数组<br>                if (a[mid] &gt; value &amp;&amp; a[l] &lt;= value) {<br>                    r = mid - 1;<br>                } else {<br>                    l = mid + 1;<br>                }<br>            } else {<br>                &#47;&#47;右侧是有序数组<br>                if (a[mid] &lt; value &amp;&amp; a[r] &gt;= value) {<br>                    l = mid + 1;<br>                } else {<br>                    r = mid - 1;<br>                }<br>            }<br>        }<br><br>        return -1;<br>    }","like_count":0},{"had_liked":false,"id":291085,"user_name":"双木公子","can_delete":false,"product_type":"c1","uid":1116567,"ip_address":"","ucode":"751885864D3AB7","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/97/4314e2d8.jpg","comment_is_top":false,"comment_ctime":1620013282,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620013282","product_id":100017301,"comment_content":"https:&#47;&#47;blog.csdn.net&#47;BruceLee1314&#47;article&#47;details&#47;116371574?spm=1001.2014.3001.5501,前一课和这一课所有相关算法实现和思路整理，谢谢老师，老师辛苦了","like_count":0},{"had_liked":false,"id":289852,"user_name":"佳俊","can_delete":false,"product_type":"c1","uid":1385803,"ip_address":"","ucode":"A54445937EEF21","user_header":"https://static001.geekbang.org/account/avatar/00/15/25/4b/4cbd001e.jpg","comment_is_top":false,"comment_ctime":1619231357,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619231357","product_id":100017301,"comment_content":"变体四代码有问题，不有考虑有相等元素的情况：<br>def bsearch(array, value):<br>    low = 0<br>    high = len(array) - 1<br>    while low &lt;= high:<br>        mid = low + ((high - low) &gt;&gt; 1)<br>        if array[mid] &gt; value:<br>            if mid == 0 or array[mid - 1] &lt;= value:<br>                return mid<br>            else:<br>                high = mid - 1<br>        elif array[mid] &lt;= value:<br>            low = mid + 1<br>    return len(array)","like_count":0},{"had_liked":false,"id":288464,"user_name":"幻影","can_delete":false,"product_type":"c1","uid":1740208,"ip_address":"","ucode":"E98DDC420A6E00","user_header":"https://static001.geekbang.org/account/avatar/00/1a/8d/b0/520f65d4.jpg","comment_is_top":false,"comment_ctime":1618479083,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618479083","product_id":100017301,"comment_content":"再刷感觉作者文章写的真好，首先有个最基础的入门，然后结合实际应用讲解了变形，给出的代码逻辑清楚，可读性很高，很容易理解；虽然没写过java，但是java代码不难懂，很直观。讲清楚了，并且实现了，而且实现很好理解，好评。比炫技晦涩的高一筹。","like_count":0},{"had_liked":false,"id":288191,"user_name":"coco","can_delete":false,"product_type":"c1","uid":1052821,"ip_address":"","ucode":"7BC3AB84E8434E","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/95/17a9a042.jpg","comment_is_top":false,"comment_ctime":1618356788,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618356788","product_id":100017301,"comment_content":"这次多掌握一个小技巧，位移，以前也知道就是不怎么用","like_count":0},{"had_liked":false,"id":288190,"user_name":"coco","can_delete":false,"product_type":"c1","uid":1052821,"ip_address":"","ucode":"7BC3AB84E8434E","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/95/17a9a042.jpg","comment_is_top":false,"comment_ctime":1618356736,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618356736","product_id":100017301,"comment_content":"犹豫水平低，也反复看过几次，感觉过段时间再看时又会重新分析，可能这就是掌握的一个过程吧","like_count":0},{"had_liked":false,"id":288154,"user_name":"Geek_Jack","can_delete":false,"product_type":"c1","uid":1773219,"ip_address":"","ucode":"15C4141411D2CC","user_header":"https://static001.geekbang.org/account/avatar/00/1b/0e/a3/62e97644.jpg","comment_is_top":false,"comment_ctime":1618324366,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618324366","product_id":100017301,"comment_content":"经过自己验证变体3与4的代码返回值有误，边界问题没有处理好，我纠正写了下<br> static int bSearchFirstBiger(int[] a, int low, int high, int val) {<br>    while (low &lt;= high) {<br>      int mid = low + ((high - low) &gt;&gt; 1);<br>      if (a[mid] &gt; val) {<br>        high = mid - 1;<br>      } else {<br>        if ((mid != a.length - 1) &amp;&amp; (a[mid + 1] &gt; val)) return mid + 1;<br>        else low = mid + 1;<br>      }<br>    }<br>    return -1;<br>  }<br><br>static int bSearchLastSmall(int[] a, int low, int high, int val) {<br>    while (low &lt;= high) {<br>      int mid = low + ((high - low) &gt;&gt; 1);<br>      if (a[mid] &lt; val) {<br>        low = mid + 1;<br>      } else {<br>        if (mid != 0 &amp;&amp; a[mid - 1] &lt; val) return mid - 1;<br>        high = mid - 1;<br>      }<br>    }<br>    return -1;<br>  }<br>","like_count":0},{"had_liked":false,"id":287153,"user_name":"帝江","can_delete":false,"product_type":"c1","uid":1590610,"ip_address":"","ucode":"93CBA4E4D05DA5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/B9vSOjMc2a86kYA8R5yDkVdFiaj2JeBZ1PuI9oUKhbnvuZwuibdUam6FTcGzDaiaFdk2GWJveUGhfCVpv4KaOdicoQ/132","comment_is_top":false,"comment_ctime":1617797668,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617797668","product_id":100017301,"comment_content":"利用分治思想.先把数组看成一个整体.先查找数组.再在数组中查找值","like_count":0},{"had_liked":false,"id":286217,"user_name":"Geek_71d8b8","can_delete":false,"product_type":"c1","uid":2237812,"ip_address":"","ucode":"C767E902AE874B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/gGOGcSH4AcC6iaeVcibEsuKdkRMPWia5G1OQY9Bm5n9pR7HFWEmtWeK9S3RhibDf8ePibx7RsCRl2Ng6MOPL0ry9vHA/132","comment_is_top":false,"comment_ctime":1617196504,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617196504","product_id":100017301,"comment_content":"leetcode第33题，java代码解法，二分+递归<br>    class Solution {<br><br>        public int search(int[] nums, int target) {<br>            return search(nums, target, 0, nums.length - 1);<br>        }<br><br>        &#47;**<br>         * 将数组分成两半<br>         * 若左边部分是递增的<br>         *      若目标在左边，则执行二分查找<br>         *      若目标在右边，则递归执行本函数<br>         * 若右边部分是递增的<br>         *      若目标在右边，则执行二分查找<br>         *      若目标在左边，则递归执行本函数<br>         *&#47;<br>        private int search(int[] a, int target, int left, int right) {<br>            if (left &gt; right){<br>                return -1;<br>            }<br>            if (left == right){<br>                return a[left] == target ? left : -1;<br>            }<br>            int mid;<br>            mid = left + ((right - left) &gt;&gt; 1);<br>            if (a[left] &lt; a[mid]) {<br>                if (a[left] &lt;= target &amp;&amp; target &lt;= a[mid]) {<br>                    return biSearch(a, target, left, mid);<br>                } else {<br>                    return search(a, target, mid + 1, right);<br>                }<br>            } else {<br>                if (a[mid + 1] &lt;= target &amp;&amp; target &lt;= a[right]) {<br>                    return biSearch(a, target, mid + 1, right);<br>                } else {<br>                    return search(a, target, left, mid);<br>                }<br>            }<br><br>        }<br><br>        private int biSearch(int[] a, int target, int l, int r) {<br>            int left = l, right = r, mid;<br>            while (left &lt;= right) {<br>                mid = left + ((right - left) &gt;&gt; 1);<br>                if (a[mid] == target) {<br>                    return mid;<br>                } else if (target &lt; a[mid]) {<br>                    right = mid - 1;<br>                } else {<br>                    left = mid + 1;<br>                }<br>            }<br>            return -1;<br>        }<br>    }","like_count":0},{"had_liked":false,"id":286197,"user_name":"陈尘辰","can_delete":false,"product_type":"c1","uid":2050761,"ip_address":"","ucode":"7F002F1CD70FB2","user_header":"https://static001.geekbang.org/account/avatar/00/1f/4a/c9/573a1b0a.jpg","comment_is_top":false,"comment_ctime":1617184606,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617184606","product_id":100017301,"comment_content":"public static int bsearchFirst(int[] arr, int target) {<br>        int left = 0;<br>        int right = arr.length - 1;<br>        int res = -1;<br>        while (left &lt;= right) {<br>            int mid = left + (right - left) &#47; 2;<br>            if (arr[mid] == target) {<br>                right = mid - 1;<br>                res = mid;<br>            } else if (arr[mid] &lt; target) {<br>                left = mid + 1;<br>            } else {<br>                right = mid - 1;<br>            }<br>        }<br>        return res;<br>    }<br><br>    public static int bsearchLast(int[] arr, int target) {<br>        int left = 0;<br>        int right = arr.length - 1;<br>        int res = -1;<br>        while (left &lt;= right) {<br>            int mid = left + (right - left) &#47; 2;<br>            if (arr[mid] == target) {<br>                left = mid + 1;<br>                res = mid;<br>            } else if (arr[mid] &lt; target) {<br>                left = mid + 1;<br>            } else {<br>                right = mid - 1;<br>            }<br>        }<br>        return res;<br>    }<br><br>    public static int bsearchFirstEqOrLarger(int[] arr, int target) {<br>        int left = 0;<br>        int right = arr.length - 1;<br>        int res = -1;<br>        while (left &lt; right) {<br>            int mid = left + (right - left) &#47; 2;<br>            if (arr[mid] &gt;= target) {<br>                right = mid;<br>                res = mid;<br>            }else{<br>                left = mid + 1;<br>            }<br>        }<br>        return res;<br>    }<br><br>    public static int bsearchLastEqOrLarger(int[] arr, int target) {<br>        int left = 0;<br>        int right = arr.length - 1;<br>        int res = -1;<br>        while (left &lt; right) {<br>            int mid = left + (right - left) &#47; 2;<br>            if (arr[mid] &gt; target) {<br>                right = mid - 1;<br>            } else if (arr[mid] &lt; target) {<br>                left = mid + 1;<br>            } else {<br>                left = mid;<br>                res = mid;<br>            }<br>        }<br>        return res;<br>    }","like_count":0},{"had_liked":false,"id":285978,"user_name":"Geek_a25096","can_delete":false,"product_type":"c1","uid":2046800,"ip_address":"","ucode":"E3400CCB95EB32","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erJ33eSC72BTHlwIPBdSFNFuXgX4FDibW0AuFuHqyXndpAqUZN7RDYAP4QTZHdG55q8weWYt3BkrrQ/132","comment_is_top":false,"comment_ctime":1617091436,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617091436","product_id":100017301,"comment_content":"二刷真的讲的太好了","like_count":0},{"had_liked":false,"id":285955,"user_name":"Boom clap!!!","can_delete":false,"product_type":"c1","uid":2443427,"ip_address":"","ucode":"E9AF8ECB963239","user_header":"https://static001.geekbang.org/account/avatar/00/25/48/a3/2df11999.jpg","comment_is_top":false,"comment_ctime":1617086564,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1617086564","product_id":100017301,"comment_content":"老师，第一个变形<br>第7行if low &lt; len(nums) and nums[low] == target: 为啥在python里这样写？不理解","like_count":0},{"had_liked":false,"id":285782,"user_name":"6到飞起","can_delete":false,"product_type":"c1","uid":2187496,"ip_address":"","ucode":"348140777ED22A","user_header":"","comment_is_top":false,"comment_ctime":1617010889,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617010889","product_id":100017301,"comment_content":"&#47;&#47;查找元素第一个出现的位置<br>public int search(int[] arr,int val){<br>        int length = arr.length;<br>        int low = 0;<br>        int high = length-1;<br><br>        int index = -1;<br>        while (low &lt;= high) {<br>            int mid = (low+high)&#47;2;<br>            if (arr[mid]==val) {<br>                index = mid; <br>                high = mid - 1;&#47;&#47;继续向下查找<br>                continue;<br>&#47;&#47;                return mid;<br>            }<br>            if (arr[mid]&gt;val) {<br>                high = mid-1;<br>            }else {<br>                low = mid + 1;<br>            }<br>        }<br>        return index;<br>    }","like_count":0},{"had_liked":false,"id":284351,"user_name":"Miroticwillbeforever","can_delete":false,"product_type":"c1","uid":2488913,"ip_address":"","ucode":"1DDD8AECD93EA8","user_header":"https://static001.geekbang.org/account/avatar/00/25/fa/51/5da91010.jpg","comment_is_top":false,"comment_ctime":1616208294,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616208294","product_id":100017301,"comment_content":"追求代码的可读性。老师这个确实容易理解并且好记！！！","like_count":0},{"had_liked":false,"id":280721,"user_name":"罗耀龙@坐忘","can_delete":false,"product_type":"c1","uid":1917663,"ip_address":"","ucode":"3CEA258DE7F3C7","user_header":"https://static001.geekbang.org/account/avatar/00/1d/42/df/a034455d.jpg","comment_is_top":false,"comment_ctime":1614327107,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1614327107","product_id":100017301,"comment_content":"茶艺师学编程<br><br>我建议这节课改名为“有效代码之美”，有谁反对的?","like_count":0},{"had_liked":false,"id":276472,"user_name":"柯尊铖","can_delete":false,"product_type":"c1","uid":1851031,"ip_address":"","ucode":"8C3E35A76EED61","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ5GIMGQPRu31calIBicDXTNJQFCgTwgaiaQJniaw8jYrPxwpxNd0nAiapYgD6OK1LrSLuSerOuURG1sQ/132","comment_is_top":false,"comment_ctime":1611948516,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611948516","product_id":100017301,"comment_content":"最后的题目自己写了一个二分的实现，leetcode 已通过<br>var search = function(nums, target) {<br>  let lo = 0<br>  let hi = nums.length - 1<br>  <br>  while (lo &lt;= hi) {<br>    &#47;&#47; mid 和其中一个端点相等的时候，可能会有多种情况，其实相等就说明找到了<br>    &#47;&#47; 也避免下面复杂的边界<br>    const m = Math.floor((lo + hi) &#47; 2)<br>    const mid = nums[m]<br>    if (nums[lo] === target) return lo<br>    if (nums[hi] === target) return hi<br>    if (mid === target) return m<br>    &#47;&#47; mid 可能落在左边，可能落在右边<br>    if (mid &gt; nums[lo] &amp;&amp; mid &gt; nums[hi]) {<br>      &#47;&#47; 落在左边，一定比最右边的点大<br>      &#47;&#47; target 有两种情况，1. 比 mid 小 比 lo 大 2. 比 mid大或者比 hi 小<br>      &#47;&#47; 分别对应 mid 的左边、右边<br>      if (target &lt; mid &amp;&amp; target &gt; nums[lo]) {<br>        &#47;&#47; 在 mid 左边<br>        hi = m - 1<br>      } else if (target &gt; mid || target &lt; nums[hi]) {<br>        lo = m + 1<br>      } else {<br>        &#47;&#47; 不在范围内<br>        return -1<br>      }<br>    } else if (mid &lt; nums[lo] &amp;&amp; mid &lt; nums[hi]) {<br>      &#47;&#47; 落在右边，一定比最左边的<br>      &#47;&#47; target 有两种情况 1. 比 mid 大 比 hi 小 2. 比 mid 小或者比 lo 大 3. 不存在<br>      if (target &gt; mid &amp;&amp; target &lt; nums[hi]) {<br>        lo = m + 1<br>      } else if (target &lt; mid || target &gt; nums[lo]) {<br>        hi = m - 1<br>      } else {<br>        return -1<br>      }<br>    } else {<br>      &#47;&#47; 这里 mid 一定是在一个有序的序列里<br>      if (target &gt; mid) {<br>        lo = m + 1<br>      } else {<br>        hi = m - 1<br>      }<br>    }<br>  }<br>  return -1<br>  &#47;&#47; return nums.indexOf(target)<br>};","like_count":0},{"had_liked":false,"id":276184,"user_name":"吕兵","can_delete":false,"product_type":"c1","uid":1102348,"ip_address":"","ucode":"1425DBB1DE6D56","user_header":"https://static001.geekbang.org/account/avatar/00/10/d2/0c/4d53274b.jpg","comment_is_top":false,"comment_ctime":1611824590,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611824590","product_id":100017301,"comment_content":"class Solution:<br>    def search(self, nums: List[int], target: int) -&gt; int:<br>      \tif not nums:<br>            return -1<br>        low = 0<br>        high = len(nums) - 1<br>        while(low &lt;= high):<br>            mid = low + ((high-low)&gt;&gt;1)<br>            if nums[mid] == target:<br>                return mid<br>            if nums[mid] &lt; nums[high]:<br>                if nums[mid] &lt; target &lt;= nums[high]:<br>                    low = mid + 1<br>                else:<br>                    high = mid - 1<br>            else:<br>                if nums[low] &lt;= target &lt; nums[mid]:<br>                    high = mid - 1<br>                else:<br>                    low = mid + 1<br><br>        return -1","like_count":0},{"had_liked":false,"id":274146,"user_name":"李伟","can_delete":false,"product_type":"c1","uid":1239462,"ip_address":"","ucode":"F0EF60EB250B20","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/a6/69907ec1.jpg","comment_is_top":false,"comment_ctime":1610872612,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1610872612","product_id":100017301,"comment_content":"public int search(int[] nums, int target) {<br>        int n = nums.length;<br>        if (n == 0) {<br>            return -1;<br>        }<br>        if (n == 1) {<br>            return nums[0] == target ? 0 : -1;<br>        }<br>        int low = 0, high = n - 1;<br>        while (low &lt;= high) {<br>            int mid = low + (high - low) &#47; 2;<br>            if (nums[mid] == target) {<br>                return mid;<br>            }<br>            if (nums[0] &lt;= nums[mid]) {<br>                if (nums[0] &lt;= target &amp;&amp; target &lt; nums[mid]) {<br>                    high = mid - 1;<br>                } else {<br>                    low = mid + 1;<br>                }<br>            } else {<br>                if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n - 1]) {<br>                    low = mid + 1;<br>                } else {<br>                    high = mid - 1;<br>                }<br>            }<br>        }<br>        return -1;<br>    }","like_count":0},{"had_liked":false,"id":274105,"user_name":"Andrew.Fang","can_delete":false,"product_type":"c1","uid":2359194,"ip_address":"","ucode":"1D754BBFC223F4","user_header":"https://static001.geekbang.org/account/avatar/00/23/ff/9a/f7d84a69.jpg","comment_is_top":false,"comment_ctime":1610855251,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610855251","product_id":100017301,"comment_content":"IP地址问题，可以把上述字符串拆成三个数组，分别为 起始、结尾、归属地 这样就方便进行查找，校验是否在区间，和进而找到归属地了。<br>可以在起始地址中找到最后一个小于等于给定地址的索引 i，判断结尾地址数组 i位置的值是否大于给定地址，否则说明不在有效地址区间。符合，则归属地数组的 I位置就是答案。<br>还可以在结尾ip数组中找第一个大于等于给定ip的位置，再在起始ip数组中校验目标地址是否大于起始地址。。。<br>至于点分十进制转换为为二进制，先字符串拆分，转整形，右移&lt;&lt; 24 16 8 0 结果相加。","like_count":0},{"had_liked":false,"id":273262,"user_name":"Geek_a5b8de","can_delete":false,"product_type":"c1","uid":2368692,"ip_address":"","ucode":"18E89494E7DFA4","user_header":"","comment_is_top":false,"comment_ctime":1610517213,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610517213","product_id":100017301,"comment_content":"争哥我看一些算法讲解的都有一些动图展示，可以的话是否能够加上一些动图，那样子理解起来比单看静图推理来的快一点","like_count":0},{"had_liked":false,"id":270415,"user_name":"Allan","can_delete":false,"product_type":"c1","uid":1310388,"ip_address":"","ucode":"8DA4DBECC2C45C","user_header":"https://static001.geekbang.org/account/avatar/00/13/fe/b4/295338e7.jpg","comment_is_top":false,"comment_ctime":1609122123,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609122123","product_id":100017301,"comment_content":"1、如果每段都是等长的，那么可以按照长度取最后一个小于等于指定值的范围，再从这个段中二分找到指定值。","like_count":0},{"had_liked":false,"id":268812,"user_name":"ohooblueblue","can_delete":false,"product_type":"c1","uid":2108395,"ip_address":"","ucode":"1D9F32B95AB71E","user_header":"https://static001.geekbang.org/account/avatar/00/20/2b/eb/d4d1bfb1.jpg","comment_is_top":false,"comment_ctime":1608359059,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608359059","product_id":100017301,"comment_content":"变体二：查找最后一个值等于给定值的元素的代码是有问题的，假设数组长度为2，且2个元素相等，就会出现死循环，如数组为[6, 6]","like_count":0},{"had_liked":false,"id":268501,"user_name":"徐志超-Klaus","can_delete":false,"product_type":"c1","uid":2343086,"ip_address":"","ucode":"CF26B39965F2A2","user_header":"https://static001.geekbang.org/account/avatar/00/23/c0/ae/e5e62510.jpg","comment_is_top":false,"comment_ctime":1608218869,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608218869","product_id":100017301,"comment_content":"关键是找分界点，设循环数组a[n]，找最后一个大于等于a[n-1]的数的下标，或者找最前一个小于等于a[0]的数的下标","like_count":0},{"had_liked":false,"id":268168,"user_name":"king","can_delete":false,"product_type":"c1","uid":2273754,"ip_address":"","ucode":"1E5BD0E2A789C3","user_header":"https://static001.geekbang.org/account/avatar/00/22/b1/da/5602cb4b.jpg","comment_is_top":false,"comment_ctime":1608087641,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608087641","product_id":100017301,"comment_content":"嘿嘿，第一个代码假若这个Value值不在数组中怎么办呢","like_count":0},{"had_liked":false,"id":262495,"user_name":"JonasGao","can_delete":false,"product_type":"c1","uid":1245935,"ip_address":"","ucode":"2AB1155863DE2C","user_header":"https://static001.geekbang.org/account/avatar/00/13/02/ef/17a2f2ed.jpg","comment_is_top":false,"comment_ctime":1605750777,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605750777","product_id":100017301,"comment_content":"看了前边几节课到这里。发现无论排序还是查找，数组的长度n都是以参数传递进来的。以Java为例，为什么不是直接访问Array.length呢？","like_count":0},{"had_liked":false,"id":262349,"user_name":"webioix","can_delete":false,"product_type":"c1","uid":1052168,"ip_address":"","ucode":"156C9AD566E7B3","user_header":"https://static001.geekbang.org/account/avatar/00/10/0e/08/543ee1d6.jpg","comment_is_top":false,"comment_ctime":1605697064,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605697064","product_id":100017301,"comment_content":"遇到一个面试题， 是求某值的最小和最大下标。 当时没给出答案， 后来我写了个：<br><br><br>```ruby<br><br>def find_binary(arr, target)<br>  s = arr.find_index {|e| e == target } # bsearch_index 似乎有问题， 需要手写一个<br>  if s.nil?<br>    return [-1, -1]<br>  end<br><br>  k = s<br>  e = s<br>  if k &gt;= 1 &amp;&amp; arr[k-1] == target<br>    m = find_binary(arr[0...k], target)<br>    s = m.first<br>  end<br><br>  if k &lt; arr.size - 1 &amp;&amp; arr[k + 1] == target<br>    m = find_binary(arr[(k + 1)..-1], target)<br>    e = k + m.last + 1<br>  end<br><br>  [s, e]<br>end<br><br>```<br>","like_count":0},{"had_liked":false,"id":261021,"user_name":"白小白","can_delete":false,"product_type":"c1","uid":2230018,"ip_address":"","ucode":"50A6EA980EF143","user_header":"","comment_is_top":false,"comment_ctime":1605174292,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605174292","product_id":100017301,"comment_content":"感觉思考题就是IP地址定位的变种啊，假设循环有序数组中没有重复元素，那么可以先获取到每个子数组的起始元素，把这个起始元素排列后，然后用老师将的第四个变种，获取起始下标，最后在这个子数组用二分法查找给定值就可以了吧","like_count":0},{"had_liked":false,"id":257559,"user_name":"Fy","can_delete":false,"product_type":"c1","uid":2213304,"ip_address":"","ucode":"4F4C0617A79083","user_header":"https://static001.geekbang.org/account/avatar/00/21/c5/b8/481d8a64.jpg","comment_is_top":false,"comment_ctime":1604027500,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604027500","product_id":100017301,"comment_content":"思考题 先找到分界点 即最小值的坐标<br>1。确定目标是在哪一块单调区间<br>2。 去那块单调区间使用二分查找","like_count":0},{"had_liked":false,"id":257322,"user_name":"杨","can_delete":false,"product_type":"c1","uid":1971269,"ip_address":"","ucode":"7EFEFE285975C6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/oltLEqTrmHm2aJP99BK6tHu5h7hp4aj08wR5Wt6H31iadFduDAVvjYKmhQ2nvGbLV3lkVdiat2GRasgWXoJeTibUg/132","comment_is_top":false,"comment_ctime":1603937453,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603937453","product_id":100017301,"comment_content":"循环有序数组 先找到最小值所在位置<br>a:=[]int{4,5,6,7,8,1,2,3}<br>\tl:=len(a)<br>\tj:=0<br>\tfor i:=0;i&lt;l;i++{<br>\t    if a[l-i-1]&gt;a[i]{<br>\t    \tj=i<br>\t    \tbreak<br>\t\t}else if a[l-i-1]==a[i]{<br>\t\t\tif a[i]&gt;a[i+1]{<br>\t\t\t\tj=i+1<br>\t\t\t}else{<br>\t\t\t\tj=i<br>\t\t\t}<br>\t\t\tbreak<br>\t\t}<br>\t}<br>所有j就是最小值位置  第一次二分法使用第一个值或者最后一个值就行比较，后面进行常规的二分法就行","like_count":0},{"had_liked":false,"id":251329,"user_name":"schwarzeni","can_delete":false,"product_type":"c1","uid":1112540,"ip_address":"","ucode":"C1969191F334BD","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/dc/0a1eeb4c.jpg","comment_is_top":false,"comment_ctime":1601468392,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601468392","product_id":100017301,"comment_content":"课后思考题，当初 LeetCode 上写这题的时候提交失败了四次，这次一次成功了，哈哈哈。不过话说这个评论区要是能 Markdown 就好了，代码就能高亮了<br><br>```go<br>func search(nums []int, target int) int {<br>    l, r := 0, len(nums)-1<br>    var binarySearch func() int<br>    var commonSearch func() int<br><br>    commonSearch = func() int {<br>        if l &gt; r {<br>            return -1<br>        }<br>        mid := l + (r-l)&#47;2<br>        if nums[mid] == target {<br>            return mid<br>        }<br>        if nums[l] &gt; nums[mid] {<br>            if nums[mid] &lt; target &amp;&amp; nums[r] &gt;= target {<br>                l = mid + 1<br>                return binarySearch()<br>            } else {<br>                r = mid - 1<br>                return commonSearch()<br>            }<br>        } else {<br>            if nums[mid] &gt; target &amp;&amp; nums[l] &lt;= target {<br>                r = mid - 1<br>                return binarySearch()<br>            } else {<br>                l = mid + 1<br>                return commonSearch()<br>            }<br>        }<br>    }<br>    binarySearch = func() int {<br>        if l &gt; r {<br>            return -1<br>        }<br>        mid := l + (r-l)&#47;2<br>        if nums[mid] == target {<br>            return mid<br>        }<br>        if nums[mid] &gt; target {<br>            r = mid - 1<br>            return binarySearch()<br>        } else {<br>            l = mid + 1<br>            return binarySearch()<br>        }<br>    }<br>    if len(nums) == 0 {<br>        return -1<br>    }<br>    if nums[l] &lt; nums[r] {<br>        return binarySearch()<br>    } else {<br>        return commonSearch()<br>    }<br>}<br>```","like_count":0},{"had_liked":false,"id":248127,"user_name":"jack","can_delete":false,"product_type":"c1","uid":1898292,"ip_address":"","ucode":"A2253AC8570C5E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/jibauP3icEFic4w56L2ddVghL7h2gGKhFdW8lBfE9rpwwRgzUKkLFY9wb4w70AXz7retME96a6EBRTA0LvSLn0ib8A/132","comment_is_top":false,"comment_ctime":1600040539,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1600040539","product_id":100017301,"comment_content":"对于思考题中之所以能够使用O(logn)的算法实现在循环数组中查找到给定值在于缩小了查找的范围。","like_count":0},{"had_liked":false,"id":247899,"user_name":"天敌","can_delete":false,"product_type":"c1","uid":1059944,"ip_address":"","ucode":"CD29A622197197","user_header":"https://static001.geekbang.org/account/avatar/00/10/2c/68/c299bc71.jpg","comment_is_top":false,"comment_ctime":1599908392,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599908392","product_id":100017301,"comment_content":"每次找target所在的区间<br>    public int search(int[] nums, int target) {<br>        int low = 0, high = nums.length - 1;<br>        while (low &lt;= high) {<br>            int mid = low + ((high - low) &gt;&gt; 1);<br>            if (nums[mid] == target) {<br>                return mid;<br>            } else if (nums[mid] &gt;= nums[low]) {<br>                &#47;&#47; p1,mid 有序<br>                if (target &gt;= nums[low] &amp;&amp; target &lt; nums[mid]) {<br>                    high = mid - 1;<br>                } else {<br>                    low = mid + 1;<br>                }<br>            } else {<br>                &#47;&#47; mid,p2 有序<br>                if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[high]) {<br>                    low = mid + 1;<br>                } else {<br>                    high = mid - 1;<br>                }<br>            }<br>        }<br><br>        return -1;<br>    }","like_count":0},{"had_liked":false,"id":247279,"user_name":"没事撸代码","can_delete":false,"product_type":"c1","uid":1418275,"ip_address":"","ucode":"E7C9F8B36EF55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ia2p5TE3N9AjcTcZK2ibgVYSTlUcklTCkWBibqRrGy9Yp5DtdmJOIyTO4ZP4LE5a3y3B2rURM81t8s7o2QMibj8LuQ/132","comment_is_top":false,"comment_ctime":1599645458,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1599645458","product_id":100017301,"comment_content":"第一个变形题的代码，只是刚好解决了给定的那个数组吧，如果数组里三个8没有连续，解不了呀","like_count":0,"discussions":[{"author":{"id":2226012,"avatar":"https://static001.geekbang.org/account/avatar/00/21/f7/5c/0623f121.jpg","nickname":"不会写代码","note":"","ucode":"130B5E6C91D7B8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319483,"discussion_content":"有序数组才能用二分查找，既然有序，一样的值肯定是连续的呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604037496,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":246195,"user_name":"王世林","can_delete":false,"product_type":"c1","uid":1076155,"ip_address":"","ucode":"2BB56D0FD71417","user_header":"https://static001.geekbang.org/account/avatar/00/10/6b/bb/10aaf123.jpg","comment_is_top":false,"comment_ctime":1599205720,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599205720","product_id":100017301,"comment_content":"查找最后一个元素<br><br><br>public static void main(String[] args) {<br>    int[] a = {1, 2, 4, 9, 9, 9, 17, 20, 20, 23, 40, 50};<br><br>    System.out.println(findLastValue(a, 20));<br>}<br><br>private static int findLastValue(int[] a, int value) {<br>    int low = 0;<br>    int high = a.length - 1;<br>    int mid;<br>    while (low &lt;= high) {<br>        mid = low + ((high - low) &gt;&gt; 1);<br>        if (a[mid] &lt; value) {<br>            low = mid + 1;<br>        } else if (a[mid] &gt; value) {<br>            high = mid - 1;<br>        } else {<br>            if ((mid == high) || (a[mid+1] != value)) {<br>                return mid;<br>            } else {<br>                low = mid + 1;<br>            }<br>        }<br>    }<br>    return -1;<br>}","like_count":0},{"had_liked":false,"id":245907,"user_name":"随风","can_delete":false,"product_type":"c1","uid":1476862,"ip_address":"","ucode":"037CE3554D8AB9","user_header":"https://static001.geekbang.org/account/avatar/00/16/88/fe/c18a85fe.jpg","comment_is_top":false,"comment_ctime":1599105103,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599105103","product_id":100017301,"comment_content":"还是二分查找，每次把数组分成有序和无序两部分，如果在有序部分则二分查找，如果在无序部分则重复开始，代码如下：<br> def search(self, nums: List[int], target: int) -&gt; int:<br>        low = 0<br>        high = len(nums) - 1<br>        while low &lt;= high:<br>            mid = low + ((high - low) &gt;&gt; 1)<br>            if nums[mid] == target:<br>                return mid<br>            elif nums[mid] &lt; nums[low]:<br>                # mid之后是有序的<br>                if target &gt;= nums[mid] and target &lt;= nums[high]:<br>                    low = mid<br>                else:<br>                    high = mid - 1<br>            else:<br>                # mid之前是有序的<br>                if target &gt;= nums[low] and target &lt;= nums[mid]:<br>                    high = mid<br>                else:<br>                    low = mid + 1<br>        return -1<br>","like_count":0},{"had_liked":false,"id":245221,"user_name":"一溢孤行","can_delete":false,"product_type":"c1","uid":1800923,"ip_address":"","ucode":"27DDEB08081BBD","user_header":"https://static001.geekbang.org/account/avatar/00/1b/7a/db/5c51a72e.jpg","comment_is_top":false,"comment_ctime":1598868002,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598868002","product_id":100017301,"comment_content":"<br>public int bsearch(int[] a, int n, int value) {<br>  int low = 0;<br>  int high = n - 1;<br>  while (low &lt;= high) {<br>    int mid =  low + ((high - low) &gt;&gt; 1);<br>    if (a[mid] &gt;= value) {<br>      if ((mid == 0) || (a[mid - 1] &lt;= value)) return mid + 1;<br>      else high = mid - 1;<br>    } else {<br>      low = mid + 1;<br>    }<br>  }<br>  return -1;<br>}<br>对变体三的代码做了一些修改，当给定值在数组中有多个时，也可以正常返回第一个大于给定值的元素的下标；另外，如果给定值在数组中的话，老师的代码也是需要修改的，即应该返回mid + 1。当然，我修改的代码只适用于给定值在数组中的情况，如果要将两者结合起来的话，还得另说……","like_count":0},{"had_liked":false,"id":244826,"user_name":"我是不是有点","can_delete":false,"product_type":"c1","uid":2144785,"ip_address":"","ucode":"562118E1C8B680","user_header":"https://static001.geekbang.org/account/avatar/00/20/ba/11/389cb512.jpg","comment_is_top":false,"comment_ctime":1598692097,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598692097","product_id":100017301,"comment_content":"对于各种情况，我做了一个总结，用C++写的。https:&#47;&#47;leetcode-cn.com&#47;problems&#47;binary-search&#47;solution&#47;di-gui-vsfei-di-gui-by-dahaiyidi&#47;","like_count":0},{"had_liked":false,"id":244807,"user_name":"庄坤","can_delete":false,"product_type":"c1","uid":1610407,"ip_address":"","ucode":"5E1C3E234BB793","user_header":"https://static001.geekbang.org/account/avatar/00/18/92/a7/b16dfff3.jpg","comment_is_top":false,"comment_ctime":1598685981,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598685981","product_id":100017301,"comment_content":"开篇的问题我想到的解法是还是使用最简单的二分查找<br>1、我们把每个ip区间的endIP存为一个数组，把startIP存为另一个数据<br>2、对第一个数组进行二分查找，如果比中间点小，把中间点对应的starIP拿来比较<br>3、如果比startIP大，说明找到了，如果比startIP小，则继续查找","like_count":0},{"had_liked":false,"id":244521,"user_name":"l c","can_delete":false,"product_type":"c1","uid":1245596,"ip_address":"","ucode":"7D43CC471595EC","user_header":"https://static001.geekbang.org/account/avatar/00/13/01/9c/1a750bc7.jpg","comment_is_top":false,"comment_ctime":1598556915,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598556915","product_id":100017301,"comment_content":"思路其实不难，首先在二分法的过程中确立几种情况：<br>1. mid == target，此时return<br>2. start &lt;= mid， 此时我们应该知道start --&gt; mid 是有序的，针对此情况又有以下情况<br>2.1 mid &lt; target，可推不等式：start &lt; mid &lt; target，则target必不能在start --&gt; mid的有序区间内，设start == mid + 1，继续搜索另一区间<br>2.2 mid &gt;target, 此时我们要继续观察start：<br>2.2.1 start &lt;= target，则我们知target如果存在，必须存在于start --&gt; mid的有序区间内，因此设end = mid - 1<br>2.2.2 start &gt; target，则我们知target &lt; start &lt; mid，必存在于另一区间，因此设start = mid + 1<br><br>对于mid --&gt; end是有序区间的情况也可以用以上逻辑推导。<br><br>总的来说，就是首先：<br>1. 通过比较mid和start&#47;end确立有序区间<br>2. 如果可以证明target必存在于有序区间，则继续搜索有序区间<br>3. 否则，搜索另一区间<br>","like_count":0},{"had_liked":false,"id":244504,"user_name":"JerryZhu","can_delete":false,"product_type":"c1","uid":1591223,"ip_address":"","ucode":"76850CD45786C1","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","comment_is_top":false,"comment_ctime":1598541423,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598541423","product_id":100017301,"comment_content":"课后思考循环数组二分查找思路<br>    public static int biRotateSearch(int[] nums, int target) {<br>        int low = 0 , n = nums.length, high = n - 1;<br>        while (low &lt;= high) {<br>            int mid = low + ((high - low) &gt;&gt; 1);<br>            if (nums[mid] == target) {<br>                return mid;<br>            }<br>            &#47;&#47; 因为是循环有序， 我们假定mid所存储的值大于或者等于low存储的值<br>            if (nums[mid] &gt;= nums[low]) {<br>                &#47;&#47; 确定好了区间， 把给定值带入， 然后正常二分查找求值<br>                &#47;&#47; 如果给定值正好在区间内，那么就在 low 到 mid - 1中继续二分查找<br>                if (target &gt;= nums[low] &amp;&amp; target &lt; nums[mid]) {<br>                    high = mid -1;<br>                } else {<br>                    &#47;&#47; 否则在 mid + 1 到 high 中二分查找<br>                    low = mid + 1;<br>                }<br>            } else {<br>                &#47;&#47; 否者 就在剩下的区间内找<br>                &#47;&#47; 如果 给定值 在 mid 到 high区间内<br>                if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[high]) {<br>                    &#47;&#47; 将 low 重新设置为 mid + 1 然后继续while循环<br>                    low = mid + 1;<br>                } else {<br>                   &#47;&#47; 如果不在区间内， 那么就只能往low 到 mid -1 区间中继续查找<br>                    high = mid - 1;<br>                }<br>            }<br><br>        }<br>        return -1;<br>    }<br>}","like_count":0},{"had_liked":false,"id":244494,"user_name":"JerryZhu","can_delete":false,"product_type":"c1","uid":1591223,"ip_address":"","ucode":"76850CD45786C1","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","comment_is_top":false,"comment_ctime":1598537189,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598537189","product_id":100017301,"comment_content":"&#47;**<br>*  查找第一个比给定值大的数据下标的递归实现<br>**&#47;<br><br>public static int binarySearch(int[] a, int n, int value) {<br>        return binaryIn(a, 0, n - 1, value);<br>    }<br><br><br>    private static int binaryIn(int[] a, int low, int high, int value) {<br>        if (low &gt; high) {<br>            return -1;<br>        }<br><br>        int mid = low + ((high - low) &gt;&gt; 1);<br><br>        &#47;&#47; 由于要查找第一个大于给定值的下面，那么凡事下标取值小于或者等于给定值的统统忽略重新递归<br>        &#47;&#47; 区间缩小到 mid + 1 到high<br>        if (a[mid] &lt;= value) {<br>            return binaryIn(a, mid + 1, high, value);<br>        }<br>        &#47;&#47; a[mid] &gt; value<br>        &#47;&#47; 找到 下标值大于给定值， 如果此时mid 已经是最低的下标了 那么直接返回就好<br>        &#47;&#47; 或者 mid - 1 的值 小于 或者 等于给定值， 那么认为此时的下标所存储的值已经是第一个大于给定值了<br>        if (mid == low || a[mid - 1] &lt;= value) {<br>            return mid;<br>        }<br>        &#47;&#47; 如果mid - 1的值 仍然大于给定值， 那么证明前面还有比给定值大的<br>        &#47;&#47; 当前获取的下标做存储的值，并不是第一个比给定值大的<br>        &#47;&#47; 我们就缩小范围继续递归， 这时候区间就是 low  到 mid -1<br>        return binaryIn(a, low, mid - 1, value);<br>    }","like_count":0},{"had_liked":false,"id":244488,"user_name":"JerryZhu","can_delete":false,"product_type":"c1","uid":1591223,"ip_address":"","ucode":"76850CD45786C1","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","comment_is_top":false,"comment_ctime":1598535691,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598535691","product_id":100017301,"comment_content":"public static int binarySearch(int[] a, int n, int value) {<br>        return binaryIn(a, 0, n - 1, value);<br>    }<br><br><br>    private static int binaryIn(int[] a, int low, int high, int value) {<br>        if (low &gt; high) {<br>            return -1;<br>        }<br><br>        int mid = low + ((high - low) &gt;&gt; 1);<br><br>        if (a[mid] &lt; value) {<br>            return binaryIn(a, mid + 1, high, value);<br>        } else if (a[mid] &gt; value) {<br>            return binaryIn(a, low, mid - 1, value);<br>        }<br>        &#47;&#47; 如果mid已经是第一个元素， 或者找到 mid前一个元素 已经不是给定的value值了，那么就返回mid<br>        if ((mid == 0) || (a[mid - 1] != value)) {<br>            return mid;<br>        } else {<br>            &#47;&#47; mid -1 仍然是给定值 ，那么继续把mid -1带入递归继续查找， 看看下个区间中是否还有给定值， 直到没有就返回<br>            return binaryIn(a, low, mid - 1, value);<br>        }<br>    }","like_count":0},{"had_liked":false,"id":244202,"user_name":"Njord","can_delete":false,"product_type":"c1","uid":2123809,"ip_address":"","ucode":"ECA9373719136E","user_header":"https://static001.geekbang.org/account/avatar/00/20/68/21/2d2c3867.jpg","comment_is_top":false,"comment_ctime":1598427793,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598427793","product_id":100017301,"comment_content":"public int binarySearchRing(int[] data, int low, int high, int value) {<br>        int mid;<br>        if (low &gt;= high) {<br>            return -1;<br>        }<br>        mid = low + ((high - low) &gt;&gt; 1);<br>        if (data[mid] == value) {<br>            return mid;<br>        }<br>        &#47;&#47;左侧为无序区<br>        if (data[0] &gt; data[mid]) {<br>            &#47;&#47;value的范围再右侧有序区中<br>            if (data[mid + 1] &lt;= value &amp;&amp; value &lt;= data[high]) {<br>                &#47;&#47;右侧常规二分查找<br>                return binarySearch(data, mid + 1, data.length - 1, value);<br>            } else {<br>                return binarySearchRing(data, 0, mid - 1, value);<br>            }<br>        } else {<br>            &#47;&#47;左侧为有序区<br>            if (data[low] &lt;= value &amp;&amp; value &lt;= data[mid - 1]) {<br>                &#47;&#47;value范围在左侧有序区中<br>                return binarySearch(data, low, mid - 1, value);<br>            } else {<br>                return binarySearchRing(data, mid + 1, high, value);<br>            }<br>        }<br>    }<br>其中binarySearch()为常规二分查找","like_count":0},{"had_liked":false,"id":244049,"user_name":"CHN-Lee-玉米","can_delete":false,"product_type":"c1","uid":2068721,"ip_address":"","ucode":"0A53080F38F229","user_header":"https://static001.geekbang.org/account/avatar/00/1f/90/f1/7f2b5e16.jpg","comment_is_top":false,"comment_ctime":1598367440,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598367440","product_id":100017301,"comment_content":"循环有序数组二分查找：<br><br>def bsearch(rlist, n, value):<br>    low = 0<br>    high = n - 1<br>    while low &lt;= high:<br>        mid = low + ((high - low) &gt;&gt; 1)<br>        if rlist[mid] == value:  # 找到就直接返回<br>            return mid<br>        if rlist[low] &lt;= rlist[mid]:  # 左区间有序<br>            if value &gt; rlist[mid] or value &lt; rlist[low]:  # 在有序区间外<br>                low = mid + 1<br>            else:<br>                high = mid - 1<br>        else:  # 右区间有序<br>            if value &lt; rlist[mid] or value &gt; rlist[high]:  # 在有序区间外<br>                high = mid - 1<br>            else:<br>                low = mid + 1<br>    return -1<br><br><br>if __name__ == &#39;__main__&#39;:<br>    rlist = [4, 5, 6, 7, 8, 9, 0, 1, 2, 3]  # 循环数组<br>    n = len(rlist)  # 数组大小<br>    for i in rlist:<br>        print(bsearch(rlist, n, i))<br>","like_count":0},{"had_liked":false,"id":243455,"user_name":"leezhiy","can_delete":false,"product_type":"c1","uid":1492044,"ip_address":"","ucode":"BEA6C949C3711A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/HY7jNvicCU0oiaX4WIeO0TPdVS6iazukbtWw88XbhpGzmibALnj1mY4CHAga7OLUPhdQCl0mHoR4yTm1RMGhVOo62A/132","comment_is_top":false,"comment_ctime":1598119492,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598119492","product_id":100017301,"comment_content":"变体三和四感觉有问题啊。。。。查找的值如果本身就在数组里，a[mid + 1] &gt; value 就会返回当前查找值的下标","like_count":0},{"had_liked":false,"id":243268,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1598007153,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598007153","product_id":100017301,"comment_content":"每次二分后，有半边是有序的，如果落在有序的半边，则退化为二分查找。否则继续上面的判断","like_count":0},{"had_liked":false,"id":240740,"user_name":"Eternal","can_delete":false,"product_type":"c1","uid":1188023,"ip_address":"","ucode":"EA6FE7CC98F740","user_header":"https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg","comment_is_top":false,"comment_ctime":1597049563,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597049563","product_id":100017301,"comment_content":"变种一：<br>如果 mid 不等于 0，但 a[mid]的前一个元素 a[mid-1]不等于 value，那也说明 a[mid]就是我们要找的第一个值等于给定值的元素，因为序列是按照从小到大排序的，因此肯定满足此推断，刚开始一直没想明白为啥这样","like_count":0},{"had_liked":false,"id":239125,"user_name":",","can_delete":false,"product_type":"c1","uid":1439568,"ip_address":"","ucode":"191431A878D7B6","user_header":"https://static001.geekbang.org/account/avatar/00/15/f7/50/cbfe1bc0.jpg","comment_is_top":false,"comment_ctime":1596441564,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596441564","product_id":100017301,"comment_content":"妙啊！","like_count":0},{"had_liked":false,"id":238063,"user_name":"对白","can_delete":false,"product_type":"c1","uid":1268797,"ip_address":"","ucode":"3183E5ADBC794B","user_header":"https://static001.geekbang.org/account/avatar/00/13/5c/3d/e8325811.jpg","comment_is_top":false,"comment_ctime":1596042049,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596042049","product_id":100017301,"comment_content":"我用python实现了二分查找及其四种变体并实测通过，感兴趣的小伙伴可参考一下链接：https:&#47;&#47;github.com&#47;lijinze9456yy000&#47;algorithm_practice","like_count":0},{"had_liked":false,"id":235558,"user_name":"Merry","can_delete":false,"product_type":"c1","uid":1024036,"ip_address":"","ucode":"E2A114E10814BA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a0/24/68c679c8.jpg","comment_is_top":false,"comment_ctime":1595085457,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595085457","product_id":100017301,"comment_content":"1.找到数组循环右移的位数<br>2.以此点为中点将数组划分成两个区域<br>3.在这两个区域中分别用二分查找","like_count":0},{"had_liked":false,"id":233337,"user_name":"永远不要低估一颗冠军的心","can_delete":false,"product_type":"c1","uid":1339230,"ip_address":"","ucode":"FF0DD7382CD3CA","user_header":"https://static001.geekbang.org/account/avatar/00/14/6f/5e/3f7e9ccd.jpg","comment_is_top":false,"comment_ctime":1594291002,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594291002","product_id":100017301,"comment_content":"对以上这个解决方案不明白，为什么要找第一个小于等于的区间呢，<br><br>和上一节课的二分查找有什么区别呢，既然你已经排序了，为什么不能用上节课那样的二分查找法","like_count":0},{"had_liked":false,"id":232143,"user_name":"NullPointerException","can_delete":false,"product_type":"c1","uid":1671084,"ip_address":"","ucode":"2352749F1E167C","user_header":"https://static001.geekbang.org/account/avatar/00/19/7f/ac/a295744c.jpg","comment_is_top":false,"comment_ctime":1593870906,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593870906","product_id":100017301,"comment_content":"非常优雅的写法！","like_count":0},{"had_liked":false,"id":231336,"user_name":"随风","can_delete":false,"product_type":"c1","uid":1250040,"ip_address":"","ucode":"2883C362D6C2B4","user_header":"https://static001.geekbang.org/account/avatar/00/13/12/f8/888a9b9d.jpg","comment_is_top":false,"comment_ctime":1593654056,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593654056","product_id":100017301,"comment_content":"思考题：看了下力扣答案，再实现了一下，思路还是二分查找：取中间节点，可以分成一个有序分区，一个循环有序分区。我们可以判断目标值是否在有序分区里面，是则在有序分区查找，否则在循环有序的那个分区查找。<br><br>    public static int search(int[] nums, int target) {<br>        int l = 0,r = nums.length -1,mid;<br>        while (l &lt;= r) {<br>            mid = l + (r - l) &#47; 2;<br>            if (nums[mid] == target) {<br>                return mid;<br>            }<br>            &#47;&#47;左边有序<br>            if (nums[mid] &gt;= nums[l]) {<br>                if(target &lt; nums[mid] &amp;&amp; target &gt;= nums[l]) {<br>                    &#47;&#47;在左边 有序分区里面<br>                    r = mid - 1;<br>                }else {<br>                    l = mid + 1;<br>                }<br>            }else {<br>                &#47;&#47;右边有序<br>                if(target &gt; nums[mid] &amp;&amp; target &lt;= nums[r]) {<br>                    &#47;&#47;在右边 有序分区里面<br>                    l = mid + 1;<br>                }else {<br>                    r = mid - 1;<br>                }<br>            }<br>        }<br>        return -1;<br>    }","like_count":0},{"had_liked":false,"id":231262,"user_name":"沈康","can_delete":false,"product_type":"c1","uid":1611025,"ip_address":"","ucode":"02AFA50738AB8E","user_header":"https://static001.geekbang.org/account/avatar/00/18/95/11/eb431e52.jpg","comment_is_top":false,"comment_ctime":1593618062,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593618062","product_id":100017301,"comment_content":"回过头看，什么查ip啊，这不就是分布式中的一致性hash算哪台机器吗","like_count":0},{"had_liked":false,"id":230926,"user_name":"Geek_dd8b2b","can_delete":false,"product_type":"c1","uid":1988075,"ip_address":"","ucode":"CBEF7C39075A96","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJX4ZU53F8hBHicctluqK6Ef3U0ib40bq1vFyAvqV0wu3GaPuWbj967OdMT7k0gl3OMxsfopvbk9veQ/132","comment_is_top":false,"comment_ctime":1593524856,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593524856","product_id":100017301,"comment_content":"二分查找主要在于目标值比较，然后确定区间，继续二分搜索","like_count":0},{"had_liked":false,"id":230894,"user_name":"Javatar","can_delete":false,"product_type":"c1","uid":2032840,"ip_address":"","ucode":"E216645CDF632C","user_header":"https://static001.geekbang.org/account/avatar/00/1f/04/c8/3c7af100.jpg","comment_is_top":false,"comment_ctime":1593516810,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593516810","product_id":100017301,"comment_content":"先没往下看，自己撸了一遍，写的是递归的实现，欢迎交流：<br>1.查找第一个<br> public static int findFirst(int[] a, int val, int start, int end) {<br><br>        if (start &gt; end) {<br>            return -1;<br>        }<br>        if (end == start) {<br>            if (a[start] == val) {<br>                return start;<br>            }<br>        }<br>        int mid = (start + end) &#47; 2;<br>        if (a[mid] == val) {<br>            int index = findFirst(a, val, start, mid - 1);<br>            if (index == -1) {<br>                return mid;<br>            } else {<br>                return index;<br>            }<br>        } else if (a[mid] &gt; val) {<br>            return findFirst(a, val, start, mid - 1);<br>        } else {<br>            return findFirst(a, val, mid + 1, end);<br>        }<br>    }<br>查找第一个大于等于的：<br>public static int findFirstGreaterThanOrEqualsThan(int[] a, int val, int start, int end) {<br><br>        if (start &gt; end) {<br>            return -1;<br>        }<br>        if (end == start) {<br>            if (a[start] &gt;= val) {<br>                return start;<br>            }<br>        }<br>        int mid = (start + end) &#47; 2;<br>        if (a[mid] &lt; val) {<br>            return findFirstGreaterThanOrEqualsThan(a, val, mid + 1, end);<br>        } else {<br>            int index = findFirstGreaterThanOrEqualsThan(a, val, start, mid - 1);<br>            if (index == -1) {<br>                return mid;<br>            } else {<br>                return index;<br>            }<br>        }<br>    }<br>另外两道就不贴了，因为思路类似。","like_count":0},{"had_liked":false,"id":230568,"user_name":"SuperH~","can_delete":false,"product_type":"c1","uid":1103802,"ip_address":"","ucode":"21929491561C7A","user_header":"https://static001.geekbang.org/account/avatar/00/10/d7/ba/d657d286.jpg","comment_is_top":false,"comment_ctime":1593421122,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593421122","product_id":100017301,"comment_content":"循环有序数组：找到中间的分隔节点，分隔为2部分有序数组，判断数字在哪一个数组范围内，再对数组进行2分发查找","like_count":0},{"had_liked":false,"id":230048,"user_name":"极客学子","can_delete":false,"product_type":"c1","uid":1149510,"ip_address":"","ucode":"40051597564EB7","user_header":"https://static001.geekbang.org/account/avatar/00/11/8a/46/71747b18.jpg","comment_is_top":false,"comment_ctime":1593247457,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593247457","product_id":100017301,"comment_content":"取最后一个值然后二分查找第一个小于这个值的坐标，即找出两个分区的临界点，然后再通过判断可确定要查找的值落在那个分区，再在相应的分区做二分查找即可。","like_count":0},{"had_liked":false,"id":229834,"user_name":"Swift_yong","can_delete":false,"product_type":"c1","uid":1260782,"ip_address":"","ucode":"19AE116EB7BCF0","user_header":"https://static001.geekbang.org/account/avatar/00/13/3c/ee/18f48590.jpg","comment_is_top":false,"comment_ctime":1593158846,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593158846","product_id":100017301,"comment_content":"思考题实现：<br>int binarySearch2(int a[], int n, int target) {<br>    <br>    int low = 0, low1 = 0, high = 0, high1 = 0;<br>    for (int i = 1; i &lt; n; i++) {<br>        if (a[i - 1] &gt; a[i]) {<br>            low = 0;<br>            high = i - 1;<br>            low1 = i;<br>            high1 = n - 1;<br>            break;<br>        }<br>    }<br>    <br>    while (low &lt;= high) {<br>        int mid = low + ((high - low) &gt;&gt; 1);<br>        if (a[mid] == target) {<br>            if (low == 0 || a[mid - 1] != target) {<br>                return mid;<br>            } else {<br>                high = mid - 1;<br>            }<br>        } else if (a[mid] &gt; target) {<br>            high = mid - 1;<br>        } else {<br>            low = mid + 1;<br>        }<br>    }<br>    <br>    while (low1 &lt;= high1) {<br>        int mid1 = low1 + ((high1 - low1) &gt;&gt; 1);<br>        if (a[mid1] == target) {<br>            if (low1 == 0 || a[mid1 - 1] != target) {<br>                return mid1;<br>            } else {<br>                high1 = mid1 - 1;<br>            }<br>        } else if (a[mid1] &gt; target) {<br>            high1 = mid1 - 1;<br>        } else {<br>            low1 = mid1 + 1;<br>        }<br>    }<br>    return -1;<br>}","like_count":0},{"had_liked":false,"id":229461,"user_name":"beyond","can_delete":false,"product_type":"c1","uid":1962858,"ip_address":"","ucode":"89185FC5C39067","user_header":"https://static001.geekbang.org/account/avatar/00/1d/f3/6a/66b6472b.jpg","comment_is_top":false,"comment_ctime":1593003782,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593003782","product_id":100017301,"comment_content":"变体1代码11行,mid==0表示数组第一个元素,不应该是mid==low吗","like_count":0},{"had_liked":false,"id":227647,"user_name":"worthto","can_delete":false,"product_type":"c1","uid":1387712,"ip_address":"","ucode":"41D7ABBBD2E7FF","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/N6yjnrLnMW4XVSkBr3f0N3F962l35b5j0kib9VSlAqqbf6iaoCPicL1WnJ9KjgT4egQ7A2G0Zx3OayaK4yuoZrUVA/132","comment_is_top":false,"comment_ctime":1592448624,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592448624","product_id":100017301,"comment_content":"再次总结一下，二分查找第一个元素和最后一个元素与一般的二分查找的区别。一句话，就是递归的出口发生了变化，查找第一个，要求的是当前的元素值为给定值，并且左边的元素不是给定值，如果不满足，则要从当前的左边接着进行递归二分查找。查找最后一个元素，也是同理。","like_count":0},{"had_liked":false,"id":227341,"user_name":"worthto","can_delete":false,"product_type":"c1","uid":1387712,"ip_address":"","ucode":"41D7ABBBD2E7FF","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/N6yjnrLnMW4XVSkBr3f0N3F962l35b5j0kib9VSlAqqbf6iaoCPicL1WnJ9KjgT4egQ7A2G0Zx3OayaK4yuoZrUVA/132","comment_is_top":false,"comment_ctime":1592360113,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592360113","product_id":100017301,"comment_content":"查找第一个给定值，自己写的，跟老师思路竟然是一样的，欣慰。<br><br>    public int searchFirstOpt(int[] array, int item) {<br>        int start = 0;<br>        int end = array.length - 1;<br>        while (start &lt;= end) {<br>            int mid = (end + start) &#47; 2;<br>            if (item == array[mid]) {<br>                if (mid - 1 &gt;= 0 &amp;&amp; item != array[mid - 1]) {<br>                    return mid;<br>                }<br>                end = mid - 1;<br>            } else if(item &lt; array[mid]) {<br>                end = mid - 1;<br>            } else {<br>                start = mid + 1;<br>            }<br>        }<br>        return -1;<br>    }","like_count":0},{"had_liked":false,"id":227334,"user_name":"worthto","can_delete":false,"product_type":"c1","uid":1387712,"ip_address":"","ucode":"41D7ABBBD2E7FF","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/N6yjnrLnMW4XVSkBr3f0N3F962l35b5j0kib9VSlAqqbf6iaoCPicL1WnJ9KjgT4egQ7A2G0Zx3OayaK4yuoZrUVA/132","comment_is_top":false,"comment_ctime":1592359197,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592359197","product_id":100017301,"comment_content":"二分查找第一个item<br>public int searchFirst(int[] array, int item) {<br>        int start = 0;<br>        int end = array.length - 1;<br>        while (start &lt;= end) {<br>            int mid = (end + start) &#47; 2;<br>            if (item == array[mid]) {<br>                int i = mid;<br>                while (i &gt;= 0 &amp;&amp; array[i] == array[mid]) {<br>                    i--;<br>                }<br>                return i + 1;<br><br>            } else if(item &lt; array[mid]) {<br>                end = mid - 1;<br>            } else {<br>                start = mid + 1;<br>            }<br>        }<br>        return -1;<br>    }","like_count":0},{"had_liked":false,"id":226165,"user_name":",","can_delete":false,"product_type":"c1","uid":1439568,"ip_address":"","ucode":"191431A878D7B6","user_header":"https://static001.geekbang.org/account/avatar/00/15/f7/50/cbfe1bc0.jpg","comment_is_top":false,"comment_ctime":1591969407,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591969407","product_id":100017301,"comment_content":"最近面试某大厂的时候，正好问到判断IP所属区间的问题，奥利给！","like_count":0},{"had_liked":false,"id":226075,"user_name":"饭","can_delete":false,"product_type":"c1","uid":1610573,"ip_address":"","ucode":"B3F1702D4DE604","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJKj3GbvevFibxwJibTqm16NaE8MXibwDUlnt5tt73KF9WS2uypha2m1Myxic6Q47Zaj2DZOwia3AgicO7Q/132","comment_is_top":false,"comment_ctime":1591946762,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591946762","product_id":100017301,"comment_content":"思考题，我觉得关键在于将循环数组元素坐标的索引转换成顺序数组，转换函数如下<br>&#47;&#47;&#47; &lt;summary&gt;<br>        &#47;&#47;&#47; 循环顺序表索引转换函数<br>        &#47;&#47;&#47; &lt;&#47;summary&gt;<br>        &#47;&#47;&#47; &lt;param name=&quot;head&quot;&gt;头索引&lt;&#47;param&gt;<br>        &#47;&#47;&#47; &lt;param name=&quot;end&quot;&gt;尾索引&lt;&#47;param&gt;<br>        &#47;&#47;&#47; &lt;param name=&quot;index&quot;&gt;&lt;&#47;param&gt;<br>        &#47;&#47;&#47; &lt;returns&gt;&lt;&#47;returns&gt;<br>        int ConvertToLoopIndex(int head, int end, int index)<br>        {<br>            if (head == 0)<br>                return index;<br>            if (index &lt; head)<br>                return index + head;<br>            else<br>                return index - head;<br>        }<br>然后按正常算法求解","like_count":0},{"had_liked":false,"id":225921,"user_name":"Geek_d40030","can_delete":false,"product_type":"c1","uid":2029525,"ip_address":"","ucode":"91A94D7C8F3F71","user_header":"","comment_is_top":false,"comment_ctime":1591890155,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1591890155","product_id":100017301,"comment_content":"采用二分法查找中间点，再分别对前后两个数组进行二分查找。","like_count":0},{"had_liked":false,"id":223825,"user_name":"渊จุ๊บ","can_delete":false,"product_type":"c1","uid":1530295,"ip_address":"","ucode":"E3A2C1E89EB576","user_header":"https://static001.geekbang.org/account/avatar/00/17/59/b7/9db9c657.jpg","comment_is_top":false,"comment_ctime":1591191899,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591191899","product_id":100017301,"comment_content":"写得有点丑<br>var (<br>\tn  = 0<br>\ts  = []int{1, 3, 4, 5, 6, 8, 8, 8, 11, 18}<br>\ts1 = []int{1, 3, 4, 5, 6, 8, 8, 8}<br>\ts2 = []int{8, 8, 8, 11, 18}<br>\ts3 = []int{5, 6, 7, 8, 9, 10, 11, 1, 2, 3, 4}<br>)<br><br>func TestBSearchLoopSlice(t *testing.T) {<br>    t.Log(loopSliceBSearch(s3, 11))<br>    t.Log(n)<br>}<br><br>func loopSliceBSearch(ints []int, val int) (int, int) {<br>\tm := len(ints)<br>\treturn loopSliceBSearchInternally(ints, 0, m-1, val)<br>}<br><br>func loopSliceBSearchInternally(ints []int, low, high, val int) (int, int) {<br>\tfmt.Println(low, high)<br>\tn++<br>\tif low &gt; high {<br>\t\treturn -1, -1<br>\t}<br><br>\tmid := low + ((high - low) &gt;&gt; 1)<br><br>\tif ints[mid] == val {<br>\t\treturn mid, ints[mid]<br>\t}<br><br>\tif ints[low] &lt; ints[high] {<br>\t\treturn bSearchFirstEqualInternally(ints, low, high, val)<br>\t}<br><br>\tif ints[mid] &gt; val {<br>\t\tif ints[mid] &gt; ints[high] {<br>\t\t\tif ints[high] &gt;= val {<br>\t\t\t\treturn loopSliceBSearchInternally(ints, mid+1, high, val)<br>\t\t\t}<br>\t\t\treturn loopSliceBSearchInternally(ints, low, mid-1, val)<br>\t\t} else {<br>\t\t\treturn loopSliceBSearchInternally(ints, low+1, mid-1, val)<br>\t\t}<br>\t} else {<br>\t\tif ints[mid] &gt; ints[high] {<br>\t\t\treturn loopSliceBSearchInternally(ints, mid+1, high-1, val)<br>\t\t} else {<br>\t\t\tif ints[low] &lt;= val {<br>\t\t\t\treturn loopSliceBSearchInternally(ints, low, mid-1, val)<br>\t\t\t}<br>\t\t\treturn loopSliceBSearchInternally(ints, mid+1, high, val)<br>\t\t}<br>\t}<br>}<br><br>func bSearchFirstEqualInternally(ints []int, low int, high int, val int) (int, int) {<br>\tn++<br>\tif low &gt; high {<br>\t\treturn -1, -1<br>\t}<br><br>\tif ints[low] == val {<br>\t\treturn low, ints[low]<br>\t}<br><br>\tmid := low + ((high - low) &gt;&gt; 1)<br>\tif ints[mid] &gt;= val {<br>\t\treturn bSearchFirstEqualInternally(ints, low, mid-1, val)<br>\t} else {<br>\t\treturn bSearchFirstEqualInternally(ints, mid+1, high, val)<br>\t}<br><br>}","like_count":0},{"had_liked":false,"id":222018,"user_name":"TheStarBoys","can_delete":false,"product_type":"c1","uid":2009311,"ip_address":"","ucode":"9A6D70482F9212","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/SiciaNKibn60SjA50TsTEtO09DoRA57UozylHmKckZXkJmNiaShSC0BIP6TdZC6cAphuEzmuxMHWwvpYN8P7kKb8eA/132","comment_is_top":false,"comment_ctime":1590657084,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1590657084","product_id":100017301,"comment_content":"func search(nums []int, target int) int {<br>    if len(nums) == 0 {<br>        return -1<br>    }<br>    left, right := 0, len(nums) - 1<br>    last := nums[right] &#47;&#47; 保存数组最后一个元素<br>    for left &lt;= right {<br>        mid := left + ((right - left) &gt;&gt; 1)<br>        tmp := nums[mid]<br>        if tmp == target {<br>            return mid<br>        } else if tmp &gt; last &amp;&amp; target &gt; last &amp;&amp; target &lt; tmp ||<br>        tmp &lt;= last &amp;&amp; !(target &lt;= last &amp;&amp; target &gt; tmp){<br>            &#47;&#47; 如果 mid 在左区间 并且 t 在 mid 左侧<br>            &#47;&#47; 如果 mid 在右区间 并且 t 不在 mid 右侧 --&gt; 即确保 t 在 mid 左侧<br>            right = mid - 1<br>        } else {<br>            left = mid + 1<br>        }<br>    }<br>    <br>    return -1<br>}","like_count":0},{"had_liked":false,"id":218200,"user_name":"Geek_Akara","can_delete":false,"product_type":"c1","uid":1991279,"ip_address":"","ucode":"E86A5A9EEC8BFF","user_header":"https://static001.geekbang.org/account/avatar/00/1e/62/6f/06d476f7.jpg","comment_is_top":false,"comment_ctime":1589746097,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589746097","product_id":100017301,"comment_content":"if ((mid == 0) || (a[mid - 1] &lt; value)) return mid;<br>如果mid = 0，那么mid-1 = -1， a[-1]是不是会溢出啊？<br>还是说Java判断完前面就会忽略后面的条件？","like_count":0},{"had_liked":false,"id":216841,"user_name":"ym","can_delete":false,"product_type":"c1","uid":1986914,"ip_address":"","ucode":"4C2DBB83731ACA","user_header":"https://static001.geekbang.org/account/avatar/00/1e/51/62/770c1f72.jpg","comment_is_top":false,"comment_ctime":1589353745,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589353745","product_id":100017301,"comment_content":"思考题：<br>关键在于确定数组的有序部分，再进行二分查找。循环有序数组取左右一半，总会有一半是有序的。比如，数组a为[4，5，6，７，８，1，2，3]。<br>１．先取一半，左半部分[4,5,6,7]有序，右半部分[8,1,2,3]乱序。<br>２．判断哪一部分有序。比较a[0]和a[mid]的大小即可知道哪一部分有序。<br> 3.   判断给定值target再哪部分中。比较target和有序区间的首尾值即可知道target是否在有序区间，从而可迭代二分区间的left和right<br>４．循环迭代","like_count":0},{"had_liked":false,"id":216634,"user_name":"海晏","can_delete":false,"product_type":"c1","uid":1915554,"ip_address":"","ucode":"38E998D2036115","user_header":"https://static001.geekbang.org/account/avatar/00/1d/3a/a2/d9f736c6.jpg","comment_is_top":false,"comment_ctime":1589299062,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589299062","product_id":100017301,"comment_content":"作业：python实现<br>#在一个没有重复数据的循环有序数组中进行二分查找,如[4,5,6,1,2,3]<br>def bsearch_f(arr, first, last, value):   <br>    if first &lt;= last:<br>        middle = first + ((last - first)&gt;&gt;1)<br>        if arr[first] == value: return first<br>        elif arr[last] == value: return last<br>        #value在区间的左序列<br>        elif arr[first] &lt; value and arr[last] &lt; value:<br>            if arr[middle] &lt; value:<br>                a = bsearch_f(arr, first+1, middle-1, value)<br>                b = bsearch_f(arr, middle+1, last-1, value)<br>                if a: return a<br>                else: return b<br>            elif arr[middle] &gt; value:<br>                return bsearch_f(arr, first+1, middle-1, value)<br>            else:<br>                return middle<br>        #value在区间的右序列<br>        elif arr[first] &gt; value and arr[last] &gt; value:<br>            if arr[middle] &lt; value:<br>                return bsearch_f(arr, middle+1, last-1, value)<br>            elif arr[middle] &gt; value:<br>                c = bsearch_f(arr, first+1, middle-1, value)<br>                d = bsearch_f(arr, middle+1, last-1, value)<br>              value  if c: return c<br>                else: return d<br>            else:<br>                return middle<br>        #区间是有序的<br>        elif arr[first] &lt; value and arr[last] &gt; value:<br>            if arr[middle] &lt; value:<br>                return bsearch_f(arr, middle+1, last-1, value)<br>            elif arr[middle] &gt; value:<br>                return bsearch_f(arr, first+1, middle-1, value)<br>            else:<br>                return middle<br>        #在区间之外<br>        else:<br>            return None<br>","like_count":0},{"had_liked":false,"id":215684,"user_name":"ztztzt8888","can_delete":false,"product_type":"c1","uid":1568577,"ip_address":"","ucode":"65C70DA6BF72A0","user_header":"https://static001.geekbang.org/account/avatar/00/17/ef/41/7dac7e0d.jpg","comment_is_top":false,"comment_ctime":1589078033,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589078033","product_id":100017301,"comment_content":"循环有序数组二分<br>```<br>public static int binaryRotatedSearch(int[] arr, int target) {<br>   if (arr == null) {<br>       return Integer.MIN_VALUE;<br>   }<br>   int st = 0;<br>   int end = arr.length - 1;<br>   while (st &lt;= end) {<br>       int mid = (st + end) &#47; 2;<br>       if (arr[mid] == target) {<br>           return mid;<br>       }<br>     &#47;&#47; at least one part must be sorted<br>       if (arr[st] &lt;= arr[mid]) { &#47;&#47; left part is sorted<br>           if (arr[st] &lt; target &amp;&amp; target &lt;= arr[mid]) {<br>               end = mid - 1;<br>           } else {<br>               st = mid + 1;<br>           }<br>       } else { &#47;&#47; right part is sorted<br>           if (arr[mid] &lt; target &amp;&amp; target &lt;= arr[end]) {<br>               st = mid + 1;<br>           } else {<br>               end = mid - 1;<br>           }<br>       }<br>   }<br>   return Integer.MIN_VALUE;<br>}<br>```","like_count":0},{"had_liked":false,"id":214888,"user_name":"壮壮.java","can_delete":false,"product_type":"c1","uid":1844270,"ip_address":"","ucode":"755C8C8A823B70","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJrZb9pm07aiciaNalQ0gRgMub2In4RQHYSd7VI2gvsTQMC1wSsYfcxxCYCeBmrs6Vic7GRf9jtNRqyA/132","comment_is_top":false,"comment_ctime":1588842260,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588842260","product_id":100017301,"comment_content":"3 4 种场景 应该考虑查询的元素不在数组的场景","like_count":0},{"had_liked":false,"id":214690,"user_name":"Chelizi","can_delete":false,"product_type":"c1","uid":1019069,"ip_address":"","ucode":"B90CFDB5F7B900","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/bd/4895b166.jpg","comment_is_top":false,"comment_ctime":1588782490,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588782490","product_id":100017301,"comment_content":"&#47;&#47; 文中四道题 Java 简洁版<br>&#47;&#47; 查找第一个值等于给定值的元素<br>    public int bsearchFirst(int[] arr, int value) {<br>        int low = 0;<br>        int high = arr.length - 1;<br>        while (low &lt;= high) {<br>            int mid = low + ((high - low) &gt;&gt; 1);<br>            if (arr[mid] &lt; value) {<br>                low = mid + 1;<br>            } else {<br>                high = mid - 1;<br>            }<br>        }<br><br>        &#47;&#47; low &lt; arr.length 可以保证当 arr 中所有元素均小于 value 时，arr[low] 不越界<br>        if (low &lt; arr.length &amp;&amp; arr[low] == value) return low;<br>        else return -1;<br>    }<br><br>    &#47;&#47; 查找最后有一个值等于给定值的元素<br>    public int bsearchLast(int[] arr, int value) {<br>        int low = 0;<br>        int high = arr.length - 1;<br>        while (low &lt;= high) {<br>            int mid = low + ((high - low) &gt;&gt; 1);<br>            if (arr[mid] &gt; value) {<br>                high = mid - 1;<br>            } else {<br>                low = mid + 1;<br>            }<br>        }<br><br>        &#47;&#47; high &gt;= 0 可以保证当 arr 中所有元素均大于 value 时，arr[high] 不越界<br>        if (high &gt;= 0 &amp;&amp; arr[high] == value) return high;<br>        else return -1;<br>    }<br><br>    &#47;&#47; 查找第一个大于等于给定值的元素<br>    public int bsearchFirstget(int[] arr, int value) {<br>        int low = 0;<br>        int high = arr.length - 1;<br>        while (low &lt;= high) {<br>            int mid = low + ((high - low) &gt;&gt; 1);<br>            if (arr[mid] &lt; value) {<br>                low = mid + 1;<br>            } else {<br>                high = high - 1;<br>            }<br>        }<br>        if (low &lt; arr.length - 1 &amp;&amp; arr[low] &gt;= value) return low;<br>        else return -1;<br>    }<br><br>    &#47;&#47;  查找最后一个小于等于给定值的元素<br>    public int bsearchLastlet(int[] arr, int value) {<br>        int low = 0;<br>        int high = arr.length - 1;<br>        while (low &lt;= high) {<br>            int mid = low + ((high - low) &gt;&gt; 1);<br>            if (arr[mid] &gt; value) {<br>                high = mid - 1;<br>            } else {<br>                low = mid + 1;<br>            }<br>        }<br>        if (high &gt;= 0 &amp;&amp; arr[high] &lt;= value) return high;<br>        else return -1;<br>    }<br>","like_count":0},{"had_liked":false,"id":212170,"user_name":"hailowell","can_delete":false,"product_type":"c1","uid":1195572,"ip_address":"","ucode":"557DCAB01710AB","user_header":"","comment_is_top":false,"comment_ctime":1588070134,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588070134","product_id":100017301,"comment_content":"关于IP的查找，如果我来实现 我会建立一棵前缀树  只保存前三段地址，在树中保存对应的现实地址。平均查找应该比二分更快且更新方便","like_count":0},{"had_liked":false,"id":211394,"user_name":"拉普达","can_delete":false,"product_type":"c1","uid":1930686,"ip_address":"","ucode":"0E524C0D99B2A0","user_header":"https://static001.geekbang.org/account/avatar/00/1d/75/be/6f3ab95e.jpg","comment_is_top":false,"comment_ctime":1587957144,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587957144","product_id":100017301,"comment_content":"设数组最小数位置为k，则对下表做（i+n-k）mod n操作即可。","like_count":0},{"had_liked":false,"id":211197,"user_name":"russellyue","can_delete":false,"product_type":"c1","uid":1541894,"ip_address":"","ucode":"0758ACF772F9C1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epIMwPE6FwsicZ6bjhu7ZpWLnoib8G76sA1XL8y5W8GxqfQEjBub6g57E60mzjWzrA6icMRw1QT5CpyA/132","comment_is_top":false,"comment_ctime":1587912650,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1587912650","product_id":100017301,"comment_content":"总结：二分查找比较多的应用是它的变体，而不是简单的在所有不想等的有序列中寻找一个指。它的变体一般有这些：变体一：查找第一个值等于给定值的元素。当mid 等于value时，仅当mid == 0 或者 array[mid-1] 不等于该值，mid才是要找的值, 否则就让high=mid-1。变体二：查找最后一个值等于给定值的元素。当array[mid]等于value时，仅当mid == n-1 或者 array[mid+1] 不等于该值，mid才是要找的值，否则就让low = mid+1。变体三：查找第一个大于等于给定值的元素。当array[mid]大于等于value时，仅当mid==0 或者 array[mid-1] &lt; value时，mid才是要找的值，否则就让 high = mid -1。变体四：查找最后一个小于等于给定值的元素。当array[mid]小于等于value时，仅当 mid == n-1 或者 array[mid+1] &gt; value时，mid才是要的值，否则就让 low = mid +1。","like_count":0},{"had_liked":false,"id":211000,"user_name":"Allan","can_delete":false,"product_type":"c1","uid":1310388,"ip_address":"","ucode":"8DA4DBECC2C45C","user_header":"https://static001.geekbang.org/account/avatar/00/13/fe/b4/295338e7.jpg","comment_is_top":false,"comment_ctime":1587879811,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587879811","product_id":100017301,"comment_content":"60天攻克算法打卡行动第14天<br><br>学习内容 : 二分查找（下）：如何快速定位IP对应的省份地址？<br><br>掌握这4个二分查找变形问题的解题思路，自己动手练习如何写出变体的二分查找算法，高效解决“近似”查找问题。<br><br>1.变体一：查找第一个值等于给定值的元素<br>关键就是如果找到了这个元素，并且查看mid-1 是不是也是这个值，如果是那么更新high。<br>2.变体二：查找最后一个值等于给定值的元素<br>如果查找的 mid+1 还是这个元素，那么就更新 low = mid + 1<br>3.变体三：查找第一个大于等于给定值的元素<br>更新high = mid -1<br>4.变体四：查找最后一个小于等于给定值的元素<br>同理，跟变体三类似的问题，如果后面还有比它小的，那么就更新low = mid +1<br><br><br>所有的变体基本都是更新low ，hight 的问题，最后问题用low更新，第一问题基本都是hight更新。<br>思考题：可以把每个循环有序数组分隔出来，对应每个数组。然后在每个数组中去二分查找给定的值。","like_count":0},{"had_liked":false,"id":210039,"user_name":"鱼丸粗面","can_delete":false,"product_type":"c1","uid":1785016,"ip_address":"","ucode":"B2F3F75B0D1422","user_header":"https://static001.geekbang.org/account/avatar/00/1b/3c/b8/9489387c.jpg","comment_is_top":false,"comment_ctime":1587655932,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587655932","product_id":100017301,"comment_content":"分两步，时间复杂度是O(logn)<br>一、找到循环分割点<br>二、数组偏移后再做二分法<br><br>&#47;**<br>     * 如果有序数组是一个循环有序数组,比如 4,5,6,1,2,3。针对这种情况,如何实现一个求“值等于给定值”的二分查找算法呢？<br>     * 先找到循环分割点如 1 的位置是 4<br>     *&#47;<br>    public static int circlePoint(int[] arr) {<br>        int l = 1, h = arr.length, m = 0;<br>        while (l &lt; h) {<br>            m = l + ((h - l) &gt;&gt; 1);<br>            if (arr[m] &gt;= arr[l - 1]) {<br>                l = m + 1;<br>            } else {<br>                if (arr[m - 1] &gt;= arr[l - 1]) {<br>                    return m;<br>                }<br>                h = m;<br>            }<br>        }<br>        return h &gt; 0 ? 0 : -1;<br>    }<br><br>    &#47;**<br>     * 将下标平移 p 个点，再做二分法查找<br>     *&#47;<br>    public static int circleArrEq(int[] arr, int v) {<br>        int p = circlePoint(arr);<br>        if (p == -1) return -1;<br><br>        int l = p, h = arr.length + p, m, len = arr.length;<br>        while (l &lt; h) {<br>            m = l + ((h - l) &gt;&gt; 1);<br>            if (arr[m % len] &gt; v) {<br>                h = m;<br>            } else if (arr[m % len] &lt; v) {<br>                l = m + 1;<br>            } else {<br>                return m % len;<br>            }<br>        }<br>        return -1;<br>    }","like_count":0},{"had_liked":false,"id":208273,"user_name":"收","can_delete":false,"product_type":"c1","uid":1599768,"ip_address":"","ucode":"EC3338DB7AEF34","user_header":"https://static001.geekbang.org/account/avatar/00/18/69/18/ca8a5c22.jpg","comment_is_top":false,"comment_ctime":1587311573,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587311573","product_id":100017301,"comment_content":"基于最朴素的思想去查找，在这个循环有序组里含有规则：<br>如果 data[mid]&lt; x &amp;&amp; x &gt; data[high], 则x在前半段，此时应该移动high，否则移动low；<br>如果 data[mid]&gt; x &amp;&amp; x &lt; data[low], 则x在后半段，此时应该移动low，否则移动high；  <br>func search(data []int, x int) int {<br>\tif dataLen := len(data); dataLen == 0 {<br>\t\treturn -1<br>\t} else if dataLen == 1 {<br>\t\tif data[0] == x {<br>\t\t\treturn 0<br>\t\t} else {<br>\t\t\treturn -1<br>\t\t}<br>\t}<br><br>\tlow, high, mid := 0, len(data)-1, 0<br>\tfor low &lt;= high {<br>\t\tmid = low + (high-low)&gt;&gt;1<br>\t\tif data[mid] == x {<br>\t\t\treturn mid<br>\t\t} else if data[mid] &lt; x {<br>\t\t\tif x &lt;= data[high] {<br>\t\t\t\tlow = mid + 1<br>\t\t\t} else {<br>\t\t\t\thigh = mid - 1<br>\t\t\t}<br>\t\t} else {<br>\t\t\tif x &gt;= data[low] {<br>\t\t\t\thigh = mid - 1<br>\t\t\t} else {<br>\t\t\t\tlow = mid + 1<br>\t\t\t}<br>\t\t}<br>\t}<br><br>\treturn -1<br>}","like_count":0},{"had_liked":false,"id":206820,"user_name":"喵了个咪的汪","can_delete":false,"product_type":"c1","uid":1338163,"ip_address":"","ucode":"8D6BDF3B681147","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKTDI00ykOfZ1UFxHGZ1Yhknb2BIqrwZgjFD6ykDlN3KUEMN4YgKa8N9TVib8vrtQ2Uk0tFCGAwNsw/132","comment_is_top":false,"comment_ctime":1586940989,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586940989","product_id":100017301,"comment_content":"Go语言实现，在LeetCode提交了三次，用没有通过的测试用例在本地慢慢调试，终于通过了。我的方法是，如果不能一次性写出来的话，可能通过调试的方法理清思路，然后加上画图思考，慢慢的就进步了。<br><br>func Find(nums []int, target int) int{<br>\tif nums == nil || len(nums) == 0{<br>\t\treturn  -1<br>\t}<br><br>\tstart, end := 0,0 &#47;&#47;新的临时数组的起始索引<br><br>\tif nums[0] == target {<br>\t\treturn 0<br>\t}<br><br>\tif nums[len(nums)-1] == target{<br>\t\treturn len(nums)-1<br>\t}<br><br>\tfor i := 0;i&lt;len(nums);i++ {<br>\t\tif nums[i] &lt; target{<br>\t\t\tstart = i<br>\t\t}else if nums[i] == target{<br>\t\t\treturn i<br>\t\t}else{<br>\t\t\tend = i<br>\t\t}<br>\t}<br><br>\tfor start &lt;= end {<br>\t\tmid := start + ((end-start) &gt;&gt; 1)<br>\t\tif nums[mid] == target{<br>\t\t\treturn  mid<br>\t\t}else if nums[mid] &gt; target{<br>\t\t\tend = mid -1<br>\t\t} else{<br>\t\t\tstart = mid +1<br>\t\t}<br>\t}<br><br>\treturn -1<br>}","like_count":0},{"had_liked":false,"id":204498,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1586408937,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1586408937","product_id":100017301,"comment_content":"关于思考题：循环有序问题转换为单向有序问题，再使用二分查找解决。","like_count":0},{"had_liked":false,"id":203703,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1586256151,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586256151","product_id":100017301,"comment_content":" 没有看老师解法，每次for循环都在确定范围，止到最后一次出现high=low<br>对于，第四个变形，我采用下中位的方式即 mid = (high + low) &#47; 2 + 1，请看以下代码<br>&#47;**<br>\t * 查找第一个大于等于value的值<br>\t * [1, 4, 5, 7, 20, 44, 44, 55, 230]<br>\t * @param a<br>\t * @param value<br>\t * @return<br>\t *&#47;<br>\tpublic static int findFirstGtEqualNum(int [] a, int value) {<br><br>\t\tint low = 0;<br>\t\tint high = a.length-1;<br>\t\tfor (;;) {<br>\t\t\tif (high &lt; low) {<br>\t\t\t\tbreak;<br>\t\t\t}<br>\t\t\tif (high == low &amp;&amp; a[low] == value) {<br>\t\t\t\treturn low;<br>\t\t\t}<br>\t\t\tint mid = (high + low) &#47; 2;<br>\t\t\tif (a[mid] &gt;= value) {<br>\t\t\t\thigh = mid;<br>\t\t\t} else {<br>\t\t\t\tlow = mid + 1;<br>\t\t\t}<br>\t\t}<br>\t\treturn -1;<br>\t}<br><br>\t&#47;**<br>\t * 查找最后一个小于等于value的值<br>\t * [1, 4, 5, 7, 20, 44, 44, 55, 230]<br>\t * @param a<br>\t * @param value<br>\t * @return<br>\t *&#47;<br>\tpublic static int findEndLtEqualNum(int [] a, int value) {<br><br>\t\tint low = 0;<br>\t\tint high = a.length-1;<br>\t\tfor (;;) {<br>\t\t\tif (high &lt; low) {<br>\t\t\t\tbreak;<br>\t\t\t}<br>\t\t\tif (high == low &amp;&amp; a[low] == value) {<br>\t\t\t\treturn low;<br>\t\t\t}<br>\t\t\tint mid = (high + low) &#47; 2 + 1; &#47;&#47;采用下中位 防止当剩下两个数字的时候出现死循环<br><br>\t\t\tif (a[mid] &gt; value) {<br>\t\t\t\thigh = mid - 1;<br>\t\t\t}<br>\t\t\telse {<br>\t\t\t\tlow = mid; &#47;&#47;限定范围,当a[mid] &lt;= value时，这个目标值肯定mid或者mid之后<br>\t\t\t}<br>\t\t}<br>\t\treturn -1;<br>\t}<br>}","like_count":0},{"had_liked":false,"id":202137,"user_name":"喻茂","can_delete":false,"product_type":"c1","uid":1318661,"ip_address":"","ucode":"C8BD8086A17365","user_header":"https://static001.geekbang.org/account/avatar/00/14/1f/05/8a06692e.jpg","comment_is_top":false,"comment_ctime":1585908154,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585908154","product_id":100017301,"comment_content":"&lt;?php<br>&#47;&#47; 查找第一个值等于给定值的元素<br>function bsearch($arr,$value) {<br>\t$low = 0;<br>\t$high = count($arr) - 1;<br>\twhile ($low &lt;= $high) {<br>\t\t$mid = intval($low+($high-$low)&#47;2);<br>\t\tif ($arr[$mid] &gt; $value) {<br>\t\t\t$high = $mid -1;<br>\t\t} elseif ($arr[$mid] &lt; $value) {<br>\t\t\t$low = $mid + 1;<br>\t\t} else {<br>\t\t\tif (($mid==0) || ($arr[$mid-1] != $value)) {<br>\t\t\t\treturn $mid;<br>\t\t\t} else {<br>\t\t\t\t$high = $mid - 1;<br>\t\t\t}<br>\t\t}<br>\t}<br>\treturn -1;<br>}<br><br>$arr = [1,3,4,5,6,8,8,8,11,18];<br><br>echo bsearch($arr,8);<br>echo &quot;&lt;br&gt;&quot;;<br>&#47;&#47; 查找第一个大于等于给定值的元素<br>function bsearch2($arr,$value) {<br>\t$low = 0;<br>\t$high = count($arr) - 1;<br>\twhile ($low &lt;= $high) {<br>\t\t$mid = intval($low+($high-$low)&#47;2);<br>\t\tif ($arr[$mid] &gt;= $value) {<br>\t\t\tif (($mid==0) || ($arr[$mid-1] &lt; $value)) {<br>\t\t\t\treturn $mid;<br>\t\t\t} else {<br>\t\t\t\t$high = $mid - 1;<br>\t\t\t}<br>\t\t} else {<br>\t\t\t$low = $mid + 1;<br>\t\t}<br>\t}<br>\treturn -1;<br>}<br>echo bsearch2($arr,7);<br>","like_count":0},{"had_liked":false,"id":200793,"user_name":"蜗牛","can_delete":false,"product_type":"c1","uid":1086220,"ip_address":"","ucode":"01CC18F12E556D","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/0c/0a6a0d5e.jpg","comment_is_top":false,"comment_ctime":1585651865,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585651865","product_id":100017301,"comment_content":"n&#47;2+n&#47;4，顺逆时针都行","like_count":0},{"had_liked":false,"id":198434,"user_name":"张红升","can_delete":false,"product_type":"c1","uid":1045568,"ip_address":"","ucode":"EB85C4E2BBBC0C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f4/40/36f794fc.jpg","comment_is_top":false,"comment_ctime":1585451226,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585451226","product_id":100017301,"comment_content":"关于思考题自己的一个实现<br>  public static int search(int[] nums, int target) {<br> if (nums == null || nums.length &lt; 1) {<br>            return -1;<br>        }<br>        &#47;**<br>         * 解题思路：<br>         * 1、取数组的中间下标mid，然后把数组一分为二数组A:nums[0,mid],数组B:nums[mid=1,n-1]，被分的数组一个为有序数组，一个为旋转有序<br>         * 2、判断有序数组【如果数组的末位大于首位则说明数组是有序的】，在有序数组中根据二分查找法查找目标值，如果目标值在有序数组中则返回对应下标。<br>         * 3、如果目标值不在已分的有序数组中，则把剩下的旋转有序数组再按照步骤1、2进行重复<br>         * 4、注意退出的条件：分割后的数组元素个数&lt;1<br>         *&#47;<br><br>        int low = 0;<br>        int high = nums.length-1;<br><br>        while (low &lt;= high) {<br>            int midIndex = low + (high - low) &#47; 2;<br>            int middleValue = nums[midIndex];<br><br>            if(middleValue==target){<br>                return midIndex;<br>            }<br><br>            &#47;&#47;首先找出有序数组 ，假设sortLow和sortHigh分别为有序数组的首尾下标<br>            int sortLow ,sortHigh,noSortLow,noSortHigh;<br>            &#47;&#47;注意临界条件nums[low] = nums[midIndex]的情况，既数组中只有一个元素的场景<br>            if (nums[low] &lt;= nums[midIndex]) {<br>                sortLow = low;<br>                sortHigh=midIndex;<br><br>                noSortLow = midIndex+1;<br>                noSortHigh = high;<br>            }else {<br>                sortLow = midIndex;<br>                sortHigh=high;<br><br>                noSortLow = low;<br>                noSortHigh = midIndex-1;<br>            }<br>            &#47;&#47;判断目标值是否在有序数组内，如果是则使用二次查找法查找<br>            if (nums[sortLow] &lt;= target &amp;&amp; target &lt;= nums[sortHigh]) {<br>                if (middleValue &gt; target) {<br>                    high = midIndex - 1;<br>                } else {<br>                    low = midIndex + 1;<br>                }<br>            }else{<br>                &#47;&#47;如果目标值没有在有序数组的区间内则继续在剩下的旋转数组中查找，<br>                low = noSortLow;<br>                high= noSortHigh;<br><br>            }<br>        }<br>        return -1;<br>    }","like_count":0},{"had_liked":false,"id":191900,"user_name":"凉人。","can_delete":false,"product_type":"c1","uid":1659177,"ip_address":"","ucode":"4DB16004A62015","user_header":"https://static001.geekbang.org/account/avatar/00/19/51/29/24739c58.jpg","comment_is_top":false,"comment_ctime":1584802849,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584802849","product_id":100017301,"comment_content":"循环有序数组，采用二分 始终在无序中找有序","like_count":0},{"had_liked":false,"id":191873,"user_name":"看不见的城市","can_delete":false,"product_type":"c1","uid":1905705,"ip_address":"","ucode":"A33F894543C90F","user_header":"https://static001.geekbang.org/account/avatar/00/1d/14/29/48ad4b9d.jpg","comment_is_top":false,"comment_ctime":1584801879,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584801879","product_id":100017301,"comment_content":"java 实现：找到最小值的 minIndex, 关键在mid 要取余数<br>&#47;&#47; 循环数组：求值等于给定值的第一个位置<br>    public static int b8(int[] a, int n, int value) {<br>        int minIndex = 0;<br>        for (int i = 0; i &lt; n; i++)<br>            if (a[i] &lt; a[minIndex])<br>                minIndex = i;<br>        int low = minIndex;<br>        int high = minIndex + n - 1;<br>        while (low &lt;= high) {<br>            int mid = low + ((high - low) &gt;&gt; 1);<br>            if (a[mid % n] &gt;= value)<br>                high = mid - 1;<br>            else<br>                low = mid + 1;<br>        }<br><br>        if (low == minIndex || a[low % n] == value) return low % n;<br>        return -1;<br>    }","like_count":0},{"had_liked":false,"id":186318,"user_name":"恋雪","can_delete":false,"product_type":"c1","uid":1185590,"ip_address":"","ucode":"B0D8870130A314","user_header":"https://static001.geekbang.org/account/avatar/00/12/17/36/ece951b4.jpg","comment_is_top":false,"comment_ctime":1583824958,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1583824958","product_id":100017301,"comment_content":"变体4有bug，如数组[1,3,3,4,5,7,7,9]，找比7小的最后一个元素下标","like_count":0,"discussions":[{"author":{"id":1483495,"avatar":"","nickname":"Dispy","note":"","ucode":"1BF7870B32AB15","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":259761,"discussion_content":"变4是查找最后一个小于等于给定值的元素。我用你的数据测试了，结果是6，没有问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588815439,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185548,"user_name":"万万","can_delete":false,"product_type":"c1","uid":1178812,"ip_address":"","ucode":"7ECB1DD9E9A3A7","user_header":"https://static001.geekbang.org/account/avatar/00/11/fc/bc/06d42ecc.jpg","comment_is_top":false,"comment_ctime":1583628805,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583628805","product_id":100017301,"comment_content":"int[] arr = {1,1,2,3,4,5,6,6,8,8,8,14,18}老师的变体三和变体四代码可能有点小问题，分别没考虑到没查到的情况，比如变体三传参0，遍历四传19，代码分别返回下标0和12，实际应该返回-1","like_count":0},{"had_liked":false,"id":185527,"user_name":"kaisheng","can_delete":false,"product_type":"c1","uid":1504956,"ip_address":"","ucode":"FD9EFEBEB7BFDB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/mkcNxKyJibOd8bsLpQRJ9Yjsew5yTBm2GTXUSkvwbwibMqPPMV9GbmXPzFIRC9iaX2s7HxvSryTLhGnrSogYqB7NQ/132","comment_is_top":false,"comment_ctime":1583600003,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583600003","product_id":100017301,"comment_content":"分析：<br>要求，O(log n) 肯定是用二分查找，分析题目可以知道，打乱后的数组有两种情况，<br>情况1是这样的(nums[mid]&gt;nums[left])，表示midnum在大数组这边<br><br>其中,nums[4]&gt;nums[3]&gt;nums[2]&gt;nums[1]<br>比较mid和target值，根据不同的情况改变下标。<br>具体的比较是这样的想法，不难理解：<br>1.nums[mid]&lt;target,则所求的index应该在mid到4指向的位置之间，则left = mid+1;<br>2.num[mid]&gt;target，则所求的index应该在箭头1和箭头2指向的位置之间，或者在left到mid之间,如何分辨呢，<br>判断target和nums[left]值即可,具体而言：<br>       1&gt;   target比nums[left]小, 则target在箭头1和箭头2之间，即 left = mid + 1;<br>       2&gt;  target比nums[left]大,则 target在3到mid之间, right = mid -1;<br>3.num[mid]=target,return mid;<br> <br>情况2是这样的，nums[mid]&gt;=nums[left] 表示midnum在小数组这边，和情况一几乎一样，向上面一样分析就好<br><br>比较mid和target值，根据不同的情况改变下标。<br>具体的比较是这样的想法，不难理解：<br>1.nums[mid]&gt;target,则所求的index应该在1到mid指向的位置之间，则right= mid-1;<br>2.num[mid]&lt;target，则所求的index应该在箭头3和箭头4指向的位置之间，或者在mid到right之间,如何分辨呢，<br>判断target和nums[right]值即可,具体而言：<br>       1&gt;   target比nums[right]小, 则target在mid和right之间，即 left = mid + 1;<br>       2&gt;  target比nums[right]大,则 target在箭头3和箭头4指向的位置之间, right = mid -1;<br>3.num[mid]=target,return mid;<br><br><br> <br>接下来贴出来java实现代码：<br><br><br><br><br>1<br><br>public int search(int[] nums, int target) {<br><br><br>2<br><br>if (nums.length==1 &amp;&amp; nums[0]==target) return 0;<br><br><br>3<br><br>int left = 0;<br><br><br>4<br><br>int right = nums.length-1;<br><br><br>5<br><br>int mid = 0;<br><br><br>6<br><br>while (left&lt;right){<br><br><br>7<br><br>mid = (left+right)&#47;2;<br><br><br>8<br><br>if (nums[left]==target) return left;<br><br><br>9<br><br>if (nums[right]==target) return right;<br><br><br>10<br><br>if (nums[mid]==target) return mid;<br><br><br>11<br><br>if (nums[mid] &gt; nums[left]){ &#47;&#47;第一种情况<br><br><br>12<br><br>if (target&gt;nums[mid]) {<br><br><br>13<br><br>left = mid+1;<br><br><br>14<br><br>}else {<br><br><br>15<br><br>if (target&gt;nums[left]) {<br><br><br>16<br><br>right = mid-1;<br><br><br>17<br><br>}else {<br><br><br>18<br><br>left = mid+1;<br><br><br>19<br><br>}<br><br><br>20<br><br>}<br><br><br>21<br><br>}else { &#47;&#47;第二种情况<br><br><br>22<br><br>if (target&gt;nums[mid]){<br><br><br>23<br><br>if (target&lt;nums[right]) {<br><br><br>24<br><br>left = mid + 1;<br><br><br>25<br><br>}else {<br><br><br>26<br><br>right = mid -1;<br><br><br>27<br><br>}<br><br><br>28<br><br>}else {<br><br><br>29<br><br>right = mid -1;<br><br><br>30<br><br>}<br><br><br>31<br><br>}<br><br><br>32<br><br><br><br><br>33<br><br>}<br><br><br>34<br><br>return -1;<br><br><br>35<br><br>}","like_count":0},{"had_liked":false,"id":185258,"user_name":"shelldon","can_delete":false,"product_type":"c1","uid":1054598,"ip_address":"","ucode":"BF8FE102D6DD1B","user_header":"https://static001.geekbang.org/account/avatar/00/10/17/86/416f772e.jpg","comment_is_top":false,"comment_ctime":1583547789,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583547789","product_id":100017301,"comment_content":"***Talk is cheap. Show me the code.***<br>```cpp<br>&#47;&#47; 首先找到循环数组做了多少位移<br>&#47;&#47; 类比非循环有序数组的二分查找<br>&#47;&#47; 计算 virtual_low, virtual_high, virtual_mid，就像有两个完全一样的数组拼接在一起<br>&#47;&#47; 比较的时候要映射回实际位置 real_mid<br><br>class Solution {<br>public:<br>    int search(vector&lt;int&gt;&amp; nums, int target) {<br>        int size = nums.size();<br>        if (size == 0) return -1;<br>        if (size == 1) return (target == nums[0] ? 0 : -1); <br>        int offset = 0;<br><br>        &#47;&#47; 如果 offset &gt; 0 则用二分查找计算 offset<br>        if (nums.front() &gt; nums.back()) {<br>            int low = 0;<br>            int high = size - 1;<br>            while (low &lt;= high) {<br>                int mid = low + ((high - low) &gt;&gt; 1);<br>                if (nums[mid] &gt; nums[mid+1]) {<br>                    offset = mid + 1;<br>                    break;<br>                } else {<br>                    if (nums[mid] &lt; nums[low]) {<br>                        high = mid - 1;<br>                    } else {<br>                        low = mid + 1;<br>                    }<br>                }<br>            }<br>        }<br><br>        int virtual_low = offset;<br>        int virtual_high = (offset + size - 1);<br><br>        while (virtual_low &lt;= virtual_high) {<br>            int virtual_mid = virtual_low + ((virtual_high - virtual_low) &gt;&gt; 1);<br>            int real_mid = virtual_mid % size;<br>            if (target == nums[real_mid]) {<br>                return real_mid;<br>            } else if (target &lt; nums[real_mid]) {<br>                virtual_high = virtual_mid - 1;<br>            } else {<br>                virtual_low = virtual_mid + 1;<br>            }<br>        }<br>        return -1;<br>    }<br>};<br>```","like_count":0},{"had_liked":false,"id":185202,"user_name":"shelldon","can_delete":false,"product_type":"c1","uid":1054598,"ip_address":"","ucode":"BF8FE102D6DD1B","user_header":"https://static001.geekbang.org/account/avatar/00/10/17/86/416f772e.jpg","comment_is_top":false,"comment_ctime":1583512946,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583512946","product_id":100017301,"comment_content":"二分查找（上）和二分查找（下）总共举了五种情况的查找问题，二分查找代码编写注意事项总结如下：<br>1、循环退出条件<br>2、mid 的计算<br>3、low 和 high 的更新<br>4、返回值选择","like_count":0},{"had_liked":false,"id":183928,"user_name":"小肥羊","can_delete":false,"product_type":"c1","uid":1081582,"ip_address":"","ucode":"9F44BAA1A59FAD","user_header":"https://static001.geekbang.org/account/avatar/00/10/80/ee/bbee3ec1.jpg","comment_is_top":false,"comment_ctime":1583163222,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583163222","product_id":100017301,"comment_content":"思考题：一直都是二分查找，所以时间复杂度一直是O(logn)<br>int search(int[] a, int value){<br>        int low =0,high = a.length-1;<br>        while(low&lt;high){&#47;&#47; 使用二分法找到rotate数组中最小值的index<br>            int mid=(low+high)&#47;2;<br>            if(a[mid]&gt;a[high]) low=mid+1;<br>            else high=mid;<br>        }<br>        int rot = low; &#47;&#47; low和high相等的时候，就是最小值的index<br>        low = 0; high = a.length-1;<br>        while(low&lt;=high){<br>            int mid=(low+high)&#47;2;<br>            int realmid=(mid+rot)%a.length;&#47;&#47; 通过最小值index转化为有序数组二分查找值<br>            if(a[realmid]==value)return realmid;<br>            if(a[realmid]&lt;value)low=mid+1;<br>            else high = mid-1;<br>        }<br>        return -1;<br>    }","like_count":0},{"had_liked":false,"id":183825,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1583141513,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583141513","product_id":100017301,"comment_content":"  public static int binarySearch5(int[] i, int n, int value) {<br>        int low = 0;<br>        int high = n - 1;<br>        System.out.println(&quot;排序前：&quot; + Arrays.toString(i));<br>        Arrays.sort(i);<br>        System.out.println(&quot;排序后：&quot; + Arrays.toString(i));<br>        while (low &lt;= high) {<br>            int mid = low + ((high - low) &gt;&gt; 1);<br>            if (i[mid] == value) {<br>                return mid;<br>            } else if (i[mid] &gt; value) {<br>                high = mid - 1;<br>            } else {<br>                low = mid + 1;<br>            }<br>        }<br>        return -1;<br>    }","like_count":0},{"had_liked":false,"id":183775,"user_name":"孙思强","can_delete":false,"product_type":"c1","uid":1813790,"ip_address":"","ucode":"6E3F01DDFC1310","user_header":"https://static001.geekbang.org/account/avatar/00/1b/ad/1e/aeb8d6f3.jpg","comment_is_top":false,"comment_ctime":1583132586,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583132586","product_id":100017301,"comment_content":"循环遍历数组去除中间的转折点，然后他变为切成两个有序数组进行二分查找","like_count":0},{"had_liked":false,"id":181626,"user_name":"stephenhe","can_delete":false,"product_type":"c1","uid":1188718,"ip_address":"","ucode":"D37B7942BF9C9C","user_header":"https://static001.geekbang.org/account/avatar/00/12/23/6e/be0f3b57.jpg","comment_is_top":false,"comment_ctime":1582599617,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1582599617","product_id":100017301,"comment_content":"1循环有序数组与有序数组建立一个映射关系；<br>查找数组最小元素的位置为k，O(n)<br>2建立与简单二分查找算法对应的取值映射<br>item[i] = item[(i + k + n) mod n]<br>3按照二分算法查询即可，结果返回(i + k + n) mod n<br><br>请指教","like_count":0},{"had_liked":false,"id":181625,"user_name":"stephenhe","can_delete":false,"product_type":"c1","uid":1188718,"ip_address":"","ucode":"D37B7942BF9C9C","user_header":"https://static001.geekbang.org/account/avatar/00/12/23/6e/be0f3b57.jpg","comment_is_top":false,"comment_ctime":1582599240,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1582599240","product_id":100017301,"comment_content":"循环有序数组：","like_count":0},{"had_liked":false,"id":178495,"user_name":"Geek_5ed595","can_delete":false,"product_type":"c1","uid":1599346,"ip_address":"","ucode":"821454637335F8","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/7BnNphSkVlmswEmuv0laclvyDGIsMsrZOqPXJxvrazs4PLbrnM6jNxPVj0SGrJBv6HBfBWEVYicLOGWoXYv58aw/132","comment_is_top":false,"comment_ctime":1581711623,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581711623","product_id":100017301,"comment_content":"变体一，第十一行代码mid==0是为了防止后面的mid-1数组越界","like_count":0},{"had_liked":false,"id":177902,"user_name":"Jim","can_delete":false,"product_type":"c1","uid":1268788,"ip_address":"","ucode":"E3E8F9A527D6DB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/D9iciayk2kC7VxrsiauxngbMhcicm6CZiaXBa4JNbVdRqQ5HIpoqPzRptbttMdaGnTaUqZsEyW4kyZA2cyiaZCwZrWGA/132","comment_is_top":false,"comment_ctime":1581525246,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581525246","product_id":100017301,"comment_content":"课后思考对应leetcode 33题<br><br>public class Solution {<br>    public int Search(int[] nums, int target) {<br>        if(nums.Length == 0)<br>            return -1;<br><br>        if(target &lt; nums[0] &amp;&amp; target &gt; nums[nums.Length - 1])<br>        {<br>            return -1;<br>        }<br><br>        var low = 0;<br>        var high = nums.Length - 1;<br><br>        if(nums[low] == target)<br>        {<br>            return low;<br>        }<br>        else if(nums[high] == target)<br>        {<br>            return high;<br>        }<br><br>        while(low &lt;= high)<br>        {<br>            var mid = low +(high - low)&#47;2;<br>            <br>            if(nums[mid] == target)<br>            {<br>                return mid;<br>            }<br>            else if(nums[mid] &gt; nums[nums.Length - 1] &amp;&amp; target &lt; nums[nums.Length - 1])<br>            {<br>                low = mid + 1;<br>            }<br>            else if(nums[mid] &lt; nums[0] &amp;&amp; target &gt; nums[0])<br>            {<br>                high = mid - 1;<br>            }<br>            else if(nums[mid] &gt; target)<br>            {<br>                high = mid - 1;<br>            }<br>            else if(nums[mid] &lt; target)<br>            {<br>                low = mid + 1;<br>            }<br>        }<br><br>        return -1;<br>    }<br>}","like_count":0},{"had_liked":false,"id":177744,"user_name":"笨笨","can_delete":false,"product_type":"c1","uid":1005351,"ip_address":"","ucode":"6DA6DCAF6A7DCB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/27/805786be.jpg","comment_is_top":false,"comment_ctime":1581488507,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1581488507","product_id":100017301,"comment_content":"&#47;&#47; 思路描述：对比普通最基本的bsearch多了【当前数组是否是循环数组】这个变量因子，如果当前是循环数组则在基本的bsearch遍历完成且没有找到之后，并不结束，而是递归再查找反方向的另一半。而有前提条件数组中没有重复元素，所以判断是否是循环数组只需要判断当前分区数组的开始元素是否大于尾部元素即可。<br>&#47;&#47; 算法限制前提条件：数组中不存在重复元素<br>function loopBsearch(arr, s, e, t) {<br>  if (s &gt; e) return &#39;没找到&#39;; &#47;&#47; 针对递归的【终止条件】<br>  <br>  &#47;&#47; 基本二分查找所使用的变量定义<br>  let low = s;<br>  let high = e;<br>  let mid;<br><br>  &#47;&#47; 因为下面while中都会修改low和high，所以这里需要提前定义这里两个变量，而没有在while之后就近定义。<br>  const needLoop = arr[low] &gt; arr[high];  &#47;&#47; 判断当前是否是循环数组，如果是，则本次需要递归。<br>  const startPart = low + ((high - low) &gt;&gt; 1);  &#47;&#47; 如果需要递归，则递归的数组的分区标识。<br> <br> &#47;&#47; while循环体不变，还是基本的二分查找循环体<br>  while(low &lt;= high) {<br>    mid = low + ((high - low) &gt;&gt; 1);<br>    if (arr[mid] === t) {<br>      return mid;<br>    } else if(arr[mid] &gt; t) {<br>      high = mid-1;<br>    } else if(arr[mid] &lt; t) {<br>      low = mid+1;<br>    }<br>  }<br><br>  &#47;&#47; 如果是循环数组，则递归查找反方向<br>  if (needLoop) {<br>    if (arr[startPart] &gt; t) {<br>      return loopBsearch(arr, startPart+1, e, t);<br>    } else if (arr[startPart] &lt; t) {<br>      return loopBsearch(arr, s, startPart-1, t);<br>    } else {<br>       throw new Error(&#39;应该在上面找到的&#39;);<br>    }<br>  }<br><br>  return &#39;没找到&#39;;<br>}<br>&#47;&#47; 测试用例  <br>var arr = [5, 6, 7, 8, 1, 2, 3, 4];<br>console.log(loopBsearch(arr, 0, arr.length-1, 2)) &#47;&#47; output: 5<br>arr = [5, 6, 7, 8, 9, 1, 2];<br>console.log(loopBsearch(arr, 0, arr.length-1, 2)) &#47;&#47; output:  6<br>arr = [5, 6, 1, 2, 3, 4]; <br>console.log(loopBsearch(arr, 0, arr.length-1, 6)) &#47;&#47; output: 1<br>复杂度简要分析：最坏情况，因为数据的位置比较衰，一直需要递归，即共需要(log2 n)次基本二分查找，但每次规模减半，而一次二分的时间复杂度为O(log2 n)，则其求和为：O(log2 n + log2 n&#47;2 + log2 n&#47;4 + log2 n&#47;8 + ...) ","like_count":0},{"had_liked":false,"id":175445,"user_name":"Elliot","can_delete":false,"product_type":"c1","uid":1030070,"ip_address":"","ucode":"CC58A6FD2F338C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b7/b6/17103195.jpg","comment_is_top":false,"comment_ctime":1580721475,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580721475","product_id":100017301,"comment_content":"如果 a[mid]的后一个元素 a[mid+1]不等于 value，那也说明 a[mid]就是我们要找的最后一个值等于给定值的元素。 不太理解这个意思","like_count":0},{"had_liked":false,"id":172026,"user_name":"梦中那月儿照我心扉。","can_delete":false,"product_type":"c1","uid":1688261,"ip_address":"","ucode":"0C1A4EFA84A6A1","user_header":"https://static001.geekbang.org/account/avatar/00/19/c2/c5/d693e984.jpg","comment_is_top":false,"comment_ctime":1579073494,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579073494","product_id":100017301,"comment_content":"如果 mid 不等于 0，但 a[mid] 的前一个元素 a[mid-1] 不等于 value，那也说明 a[mid] 就是我们要找的第一个值等于给定值的元素。这句话，有点问题吧，为啥它的前一个元素不等于value就是要找的值？","like_count":0},{"had_liked":false,"id":167969,"user_name":"-","can_delete":false,"product_type":"c1","uid":1326977,"ip_address":"","ucode":"B915F53BC7F2A1","user_header":"https://static001.geekbang.org/account/avatar/00/14/3f/81/08b938b1.jpg","comment_is_top":false,"comment_ctime":1577970207,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577970207","product_id":100017301,"comment_content":"变体三：查找第一个大于等于给定值的元素, 这样写行不行?<br>   int (int a[], int n, int v) {<br>        int low = 0;<br>        int high = n - 1;<br>        while (low &lt; high) {<br>            int mid = low + ((high - low) &gt;&gt; 1);<br>            if (a[mid] &gt;= v) {<br>                high = mid;<br>            } else {<br>                low = mid + 1;<br>            }<br>        }<br>        if (low &lt; n &amp;&amp; a[low] &gt;= v) {<br>            return low;<br>        }<br>        return -1;<br>    }","like_count":0},{"had_liked":false,"id":166093,"user_name":"wxhxhw","can_delete":false,"product_type":"c1","uid":1613246,"ip_address":"","ucode":"870A28FDA30539","user_header":"https://static001.geekbang.org/account/avatar/00/18/9d/be/3eef22a8.jpg","comment_is_top":false,"comment_ctime":1577397104,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577397104","product_id":100017301,"comment_content":"前一阵有个面试就考到课后思考题了，可惜那时还没学到这！","like_count":0},{"had_liked":false,"id":165226,"user_name":"菜头","can_delete":false,"product_type":"c1","uid":1456964,"ip_address":"","ucode":"C5E95519F9EA21","user_header":"https://static001.geekbang.org/account/avatar/00/16/3b/44/dd534c9b.jpg","comment_is_top":false,"comment_ctime":1577183328,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577183328","product_id":100017301,"comment_content":"是否也可以转化为，在有序数组中查找第一个大于等于某个给定值的元素","like_count":0},{"had_liked":false,"id":163091,"user_name":"Umasou","can_delete":false,"product_type":"c1","uid":1187112,"ip_address":"","ucode":"3CA8678A0251C7","user_header":"https://static001.geekbang.org/account/avatar/00/12/1d/28/a1f5a37d.jpg","comment_is_top":false,"comment_ctime":1576655292,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576655292","product_id":100017301,"comment_content":"private int rSearch(int[] data,int k){<br>        int low = 0,mid;<br>        int high = data.length -1;<br>        while (low &lt;= high){<br>            mid = low + ((high - low) &gt;&gt; 1);<br>            if (data[mid] == k){<br>                return mid;<br>            }else if (data[mid] &lt; k &amp;&amp; data[high] &lt; k){<br>                high = mid - 1;<br>            }else if (data[low] &lt; k &amp;&amp; data[mid] &lt; k){<br>                low = mid + 1;<br>            }<br><br>        }<br>        return -1;<br>    }<br><br>","like_count":0},{"had_liked":false,"id":160632,"user_name":"CveniEs💤","can_delete":false,"product_type":"c1","uid":1247498,"ip_address":"","ucode":"762AFBDB490526","user_header":"https://static001.geekbang.org/account/avatar/00/13/09/0a/c674117a.jpg","comment_is_top":false,"comment_ctime":1575990009,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575990009","product_id":100017301,"comment_content":"针对变体3我有一点不解, 如果我要查找的数是6, 那么mid就是2, 直接return mid, 那么这样的结果就不对了啊, 麻烦老师解答一下","like_count":0},{"had_liked":false,"id":160596,"user_name":"毛启圣","can_delete":false,"product_type":"c1","uid":1330056,"ip_address":"","ucode":"233DA95ED28C11","user_header":"https://static001.geekbang.org/account/avatar/00/14/4b/88/272b4562.jpg","comment_is_top":false,"comment_ctime":1575982208,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575982208","product_id":100017301,"comment_content":"上面数组为a,写一个取虚拟数组 第n个元素的方法 F(n) = a[(n+3)%6]","like_count":0},{"had_liked":false,"id":160460,"user_name":"Jialin","can_delete":false,"product_type":"c1","uid":1112955,"ip_address":"","ucode":"12583269732A75","user_header":"https://static001.geekbang.org/account/avatar/00/10/fb/7b/2d4b38fb.jpg","comment_is_top":false,"comment_ctime":1575954158,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575954158","product_id":100017301,"comment_content":"leetcode33 81都可以做做","like_count":0},{"had_liked":false,"id":160041,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1575859892,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575859892","product_id":100017301,"comment_content":"二分查找代码的关键在于务必将区间减少为一半减一，这可以通过不满足条件来做到，或者满足条件而不满足顺序（例如不是第一个或者最后一个），这两种情况都能把区间减半，并把当前元素排除。否则，当前元素就满足条件返回。当区间为空时，查找失败。这样从反面思考，反而更容易把代码写对。","like_count":0},{"had_liked":false,"id":159783,"user_name":"梦想的优惠券","can_delete":false,"product_type":"c1","uid":1257418,"ip_address":"","ucode":"D3B44F6C618CA7","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/ca/cbce6e94.jpg","comment_is_top":false,"comment_ctime":1575788024,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1575788024","product_id":100017301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":159739,"user_name":"港","can_delete":false,"product_type":"c1","uid":1122464,"ip_address":"","ucode":"35931FC6198180","user_header":"https://static001.geekbang.org/account/avatar/00/11/20/a0/1fca96c0.jpg","comment_is_top":false,"comment_ctime":1575772131,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575772131","product_id":100017301,"comment_content":"可以首先通过二分查找找到循环起始索引，然后就可以通过二分查找找给定值时间复杂度为O(logn)","like_count":0},{"had_liked":false,"id":159708,"user_name":"阿冰777","can_delete":false,"product_type":"c1","uid":1373893,"ip_address":"","ucode":"F365EB44F971F3","user_header":"https://static001.geekbang.org/account/avatar/00/14/f6/c5/6329ddcc.jpg","comment_is_top":false,"comment_ctime":1575733044,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1575733044","product_id":100017301,"comment_content":"先遍历一遍，找到转折点spot，然后判断target是否大于start，如果是，则二分查找(start，spot) ,如果不是，则二分查找(spot+1, end).还可以优化一下，如果数值大于spot，或者小于spot+1说明找不到. ","like_count":0},{"had_liked":false,"id":159081,"user_name":"black","can_delete":false,"product_type":"c1","uid":1681512,"ip_address":"","ucode":"9B5E0909926674","user_header":"https://static001.geekbang.org/account/avatar/00/19/a8/68/70392fdd.jpg","comment_is_top":false,"comment_ctime":1575534839,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575534839","product_id":100017301,"comment_content":"get","like_count":0},{"had_liked":false,"id":157807,"user_name":"Sudouble","can_delete":false,"product_type":"c1","uid":1365574,"ip_address":"","ucode":"B369B09DAF8D20","user_header":"https://static001.geekbang.org/account/avatar/00/14/d6/46/5eb5261b.jpg","comment_is_top":false,"comment_ctime":1575262470,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1575262470","product_id":100017301,"comment_content":"使用二分的变体找到分界点，判断给定值在哪个范围，再继续使用二分","like_count":0},{"had_liked":false,"id":157805,"user_name":"梨子苹果","can_delete":false,"product_type":"c1","uid":1716067,"ip_address":"","ucode":"3666813FEE31D3","user_header":"https://static001.geekbang.org/account/avatar/00/1a/2f/63/7a048d46.jpg","comment_is_top":false,"comment_ctime":1575262157,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575262157","product_id":100017301,"comment_content":"最简单的方法就是每一步都判断在递增还是递减区间，直到找到确定的区间就停止判断所属增减区间，后续就是常规的二分查找。","like_count":0},{"had_liked":false,"id":156513,"user_name":"梨子苹果","can_delete":false,"product_type":"c1","uid":1716067,"ip_address":"","ucode":"3666813FEE31D3","user_header":"https://static001.geekbang.org/account/avatar/00/1a/2f/63/7a048d46.jpg","comment_is_top":false,"comment_ctime":1574904365,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574904365","product_id":100017301,"comment_content":"<br>public int bsearch(int[] a, int n, int value) {<br>  int low = 0;<br>  int high = n - 1;<br>  while (low &lt;= high) {<br>    int mid = low + ((high - low) &gt;&gt; 1);<br>    if (a[mid] &gt;= value) {<br>      high = mid - 1;<br>    } else {<br>      low = mid + 1;<br>    }<br>  }<br><br>  if (low &lt; n &amp;&amp; a[low]==value) return low;<br>  else return -1;<br>}<br><br>代码有问题吧","like_count":0},{"had_liked":false,"id":156190,"user_name":"梨子苹果","can_delete":false,"product_type":"c1","uid":1716067,"ip_address":"","ucode":"3666813FEE31D3","user_header":"https://static001.geekbang.org/account/avatar/00/1a/2f/63/7a048d46.jpg","comment_is_top":false,"comment_ctime":1574830742,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574830742","product_id":100017301,"comment_content":"先写一下第一个大于a的数，如果中间数比a大，判断前一位是否比a小如果是在左分区继续找，否则返回这个数或者之后的一个数，一次类推；另一方面如果中间数比a小，判断后一位是否是大于a则在右分区查找，任何不满足上下限的就退出返回找不到。","like_count":0},{"had_liked":false,"id":154562,"user_name":"素素","can_delete":false,"product_type":"c1","uid":1697601,"ip_address":"","ucode":"428BEAF187EE5E","user_header":"https://static001.geekbang.org/account/avatar/00/19/e7/41/6784860f.jpg","comment_is_top":false,"comment_ctime":1574480267,"is_pvip":true,"replies":[{"id":"60058","content":"是的，右移一位就相当于除以2","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1574858730,"ip_address":"","comment_id":154562,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1574480267","product_id":100017301,"comment_content":"老师，有个地方看不懂，int mid = low + ((high - low) &gt;&gt; 1)，&gt;&gt; 是代表右移的吗，怎么就计算出中间值了呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475508,"discussion_content":"是的，右移一位就相当于除以2","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574858730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1194094,"avatar":"https://static001.geekbang.org/account/avatar/00/12/38/6e/94d5d86f.jpg","nickname":"小仲子","note":"","ucode":"651A149AABACC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57366,"discussion_content":"  右移一位在二进制中代表除以2","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574601326,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154458,"user_name":"何雷","can_delete":false,"product_type":"c1","uid":1737805,"ip_address":"","ucode":"FA9BCE7DD9C8C4","user_header":"https://static001.geekbang.org/account/avatar/00/1a/84/4d/84371716.jpg","comment_is_top":false,"comment_ctime":1574434589,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574434589","product_id":100017301,"comment_content":"老师是对的，我想错了","like_count":0},{"had_liked":false,"id":154456,"user_name":"何雷","can_delete":false,"product_type":"c1","uid":1737805,"ip_address":"","ucode":"FA9BCE7DD9C8C4","user_header":"https://static001.geekbang.org/account/avatar/00/1a/84/4d/84371716.jpg","comment_is_top":false,"comment_ctime":1574434519,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574434519","product_id":100017301,"comment_content":"第一个变体中，第11行代码有问题吧，应该是mid==0 ‖  a[mid-1]==value","like_count":0},{"had_liked":false,"id":153438,"user_name":"Sun Fei","can_delete":false,"product_type":"c1","uid":1032631,"ip_address":"","ucode":"092EC0992050BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c1/b7/57f153f6.jpg","comment_is_top":false,"comment_ctime":1574235847,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574235847","product_id":100017301,"comment_content":"打卡。","like_count":0},{"had_liked":false,"id":152983,"user_name":"SapereAude","can_delete":false,"product_type":"c1","uid":1717549,"ip_address":"","ucode":"C5D61C535B7B10","user_header":"https://static001.geekbang.org/account/avatar/00/1a/35/2d/a2bde67e.jpg","comment_is_top":false,"comment_ctime":1574133688,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574133688","product_id":100017301,"comment_content":"上节课最后的表述是二分查找优于二叉树等；<br>这里最后怎么用了更倾向于用二叉树？<br>","like_count":0},{"had_liked":false,"id":152822,"user_name":"Geek_949cc1","can_delete":false,"product_type":"c1","uid":1690476,"ip_address":"","ucode":"F8ACDBF2FA8CC2","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKFRiaFrpOTVBuKicMficasBFuF2VY7EnUnLeFcvIn0R5OiaQsOcpJHNM5TusoPHMjIvSfia46c0EWH9mQ/132","comment_is_top":false,"comment_ctime":1574083630,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574083630","product_id":100017301,"comment_content":"谈谈自己对写这个变体的二分查找的理解：<br>1：首先来说老师写的这个代码相比于开始给出的那个简洁的代码是要好理解一点。我们只需要通过二分查找找到我们value的位置，然后根据条件，如果是第一个出现的，就对mid进行-1，最后一个出现的就对mid+1，再判断就可以找到了。<br>2：而对于另一种写法，我认为其实和简单的二分查找是一样的，只是在我们找到等于我们value值的这个位置，需要根据要求进行相应的mid-1 or mid+1。这样的操作总可以让我们找到第一次出现value的前一个位置和最后一次出现的后一个位置。到了这种情况我们就需要通过判断a[mid] &lt;value or a[mid] &gt;value的这个条件来对low or high进行更新，从而达到第一次出现或者最后一次出现的位置。<br>写的好啰嗦呀，不知道对不对","like_count":0},{"had_liked":false,"id":151761,"user_name":",","can_delete":false,"product_type":"c1","uid":1439568,"ip_address":"","ucode":"191431A878D7B6","user_header":"https://static001.geekbang.org/account/avatar/00/15/f7/50/cbfe1bc0.jpg","comment_is_top":false,"comment_ctime":1573786482,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573786482","product_id":100017301,"comment_content":"talk is cheap, show me code<br>```c++<br> int search(vector&lt;int&gt;&amp; nums, int target) {<br>        int n = nums.size();<br>        int low = 0, high = n - 1, mid=0;<br>        int target_idx = -1;<br>        while (low &lt;= high)<br>        {<br>            <br>            mid = low + ((high - low) &gt;&gt; 1);<br>            if(nums[mid] == target)<br>            {<br>                target_idx = mid;<br>                break;<br>            }<br>            if(nums[low] &lt;= nums[mid])<br>            {<br>                if(target &gt;= nums[low] &amp;&amp; target &lt; nums[mid])<br>                    high = mid - 1;<br>                else<br>                    low = mid + 1;<br>            }<br>            else<br>            {<br>                if(target &gt; nums[mid] &amp;&amp; target &lt;= nums[high])<br>                    low = mid + 1;<br>                else<br>                    high = mid - 1;<br>            }<br>        }<br>        return target_idx;<br>    }<br>```","like_count":0},{"had_liked":false,"id":150660,"user_name":"Mr.Fu","can_delete":false,"product_type":"c1","uid":1613254,"ip_address":"","ucode":"F1E4304C5CDE52","user_header":"https://static001.geekbang.org/account/avatar/00/18/9d/c6/a72db706.jpg","comment_is_top":false,"comment_ctime":1573576288,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573576288","product_id":100017301,"comment_content":"一.What-什么是二分查找<br>二分查找针对的是一个有序的数据集合<br>查找思想有点类似分治思想，每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半<br>直到找到要查找的元素，或者区间被缩小为 0<br>二.局限性<br>二分查找依赖的是顺序表结构，简单点说就是数组。二分查找算法需要按照下标随机访问元素，数组按照下标随机访问数据的时间复杂度是 O(1)，而链表随机访问的时间复杂度是 O(n)。所以如果数据使用链表存储，二分查找的时间复杂就会变得很高<br>二分查找针对的是有序数据<br>二分查找只能用在插入、删除操作不频繁的静态数据中，即一次排序多次查找的场景中<br>数据量太小不适合二分查找；不过如果数据之间的比较操作非常耗时，不管数据量大小都推荐使用二分查找(数组中存储的都是长度超过 300 的字符串，如此长的两个字符串之间比对大小会非常耗时，需要尽可能地减少比较次数)<br>数据量太大也不适合二分查找。二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空间连续。假如有 1GB 大小的数据，如果希望用数组来存储那就需要 1GB 的连续内存空间；注意“连续，也就是说即便有 2GB 的内存空间剩余，但是如果这剩余的 2GB 内存空间都是零散的，没有连续的 1GB 大小的内存空间，那照样无法申请一个 1GB 大小的数组。<br>三.优点<br>比散列表或者二叉树省内存<br>查找速度快<br>O(logn)有时候比O(n)快，log以2为底42亿的对数约等于32(2^32≈42亿)，所以O(log以2为底42亿的对数)比O(1000)小<br>四.复杂度分析<br>时间复杂度分析<br>①假设数据大小是 n，每次查找后数据都会缩小为原来的一半，也就是会除以 2；最坏情况下直到查找区间被缩小为空才停止，可以得到以下等比数列。<br><br>②其中 n&#47;(2^k)=1 时，k 的值就是总共缩小的次数。而每一次缩小操作只涉及两个数据的大小比较，所以经过了 k 次区间缩小操作，时间复杂度就是 O(k)。<br>③通过n&#47;(2^k)=1可以求得 k=log2n，所以时间复杂度就是 O(logn)。<br>空间复杂度分析：原地,O(1)<br><br>五.简单代码实现：递归和循环都可实现<br>循环实现简单的二分查找-有序数组中不存在重复元素<br><br><br>①易错点1：循环退出条件，是 low&lt;=high，而不是 low<br>②易错点2：mid = low+(high-low)&#47;2，而不是mid = (low+high)&#47;2，防止越界<br>③易错点3：low 和 high 的更新，low=mid+1，high=mid-1；如果直接写成 low=mid 或者 high=mid，可能会发生死循环。比如，当 high=3，low=3 时，如果 a[3] 不等于 value，就会导致一直循环不退出<br><br>递归实现简单的二分查找-有序数组中不存在重复元素<br><br><br><br>六.复杂变形问题<br>0.易错点：终止条件、区间上下界更新方法、返回值选择<br>查找第一个值等于给定值的元素，有序数据集合中存在重复的数据<br><br><br><br>查找最后一个值等于给定值的元素<br><br><br>查找第一个大于等于给定值的元素<br><br><br>查找最后一个小于等于给定值的元素<br><br><br><br>N.例子<br>假设有 1000 万个整数数据，每个数据占 8 个字节，如何设计数据结构和算法，快速判断某个整数是否出现在这 1000 万数据中，内存空间最多不要超过 100MB？只能将所有数据一次加载到内存（内存占用差不多是 80MB），用二分查找结果；散列表或者二叉树，都会需要比较多的额外的内存空间，100MB不够<br>假设我们有 12 万条 IP 区间与归属地的对应关系，如何快速定位出一个 IP 地址的归属地呢？<br>①如果 IP 区间与归属地的对应关系不经常更新，可以先预处理这 12 万条数据，让其按照起始 IP 从小到大排序。根据IP 地址可以转化为 32 位的整型数，所以可以将起始地址按照对应的整型值的大小关系，从小到大进行排序。<br>②然后这个问题就可以转化为“在有序数组中，查找最后一个小于等于某个给定值的元素”了。当要查询某个 IP 归属地时，可以先通过二分查找，找到最后一个起始 IP 小于等于这个 IP 的 IP 区间，然后检查这个 IP 是否在这个 IP 区间内，如果在就取出对应的归属地显示；如果不在就返回未查找到","like_count":0},{"had_liked":false,"id":143953,"user_name":"小旭贼优秀","can_delete":false,"product_type":"c1","uid":1673976,"ip_address":"","ucode":"8755845FF87CE5","user_header":"https://static001.geekbang.org/account/avatar/00/19/8a/f8/617e8f79.jpg","comment_is_top":false,"comment_ctime":1571813507,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571813507","product_id":100017301,"comment_content":"public static int bsearch(int[] arr, int value) {<br>\t\tif (arr == null) {<br>\t\t\treturn -1;<br>\t\t}<br><br>\t\tint low = 0, high = arr.length - 1;<br>\t\twhile (low &lt;= high) {<br>\t\t\tint mid = low + ((high - low) &gt;&gt; 1);<br><br>\t\t\tif (arr[mid] == value) {<br>\t\t\t\treturn mid;<br>\t\t\t} else if (arr[low] == value) {<br>\t\t\t\treturn low;<br>\t\t\t} else if (arr[high] == value) {<br>\t\t\t\treturn high;<br>\t\t\t} else if ((arr[low] &gt; value &amp;&amp; value &gt; arr[high] &amp;&amp; value &gt; arr[mid]) || <br>(value &lt; arr[mid] &amp;&amp; value &gt; arr[low])) {<br>\t\t\t\thigh = mid - 1;<br>\t\t\t} else {<br>\t\t\t\tlow = mid + 1;<br>\t\t\t}<br>\t\t}<br><br>\t\treturn -1;<br>\t}","like_count":0},{"had_liked":false,"id":142851,"user_name":"norton&#47;Dark","can_delete":false,"product_type":"c1","uid":1103637,"ip_address":"","ucode":"55C0B5636138BD","user_header":"https://static001.geekbang.org/account/avatar/00/10/d7/15/63258662.jpg","comment_is_top":false,"comment_ctime":1571561138,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571561138","product_id":100017301,"comment_content":"我的思路是：二分法的前提要求是顺序，所以要把循环数组拆解为两个独立的有序数组。然后再进行二分法查询。<br>拆分后，可以标识出两个数组的上下边界index，对两个数组进行二分查找时，二分法的函数实现可以复用。<br>这样代码的编写会更易理解。","like_count":0},{"had_liked":false,"id":140851,"user_name":"xuanyuan","can_delete":false,"product_type":"c1","uid":1113737,"ip_address":"","ucode":"1EC79B9372868F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2icbib62icXtibTkThtyRksbuJLoTLMts7zook2S30MiaBtbz0f5JskwYicwqXkhpYfvCpuYkcvPTibEaQ/132","comment_is_top":false,"comment_ctime":1571059899,"is_pvip":false,"replies":[{"id":"54517","content":"如果所有的元素都是相同的呢？效率就低了。不过我没太看懂你说的while循环是啥意思，你可以具体讲讲。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1571093828,"ip_address":"","comment_id":140851,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571059899","product_id":100017301,"comment_content":"第一个等于和最后一个等于，用简单二分法查找到之后，while循环不是更好理解吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470592,"discussion_content":"如果所有的元素都是相同的呢？效率就低了。不过我没太看懂你说的while循环是啥意思，你可以具体讲讲。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571093828,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138819,"user_name":"Geek_b617bf","can_delete":false,"product_type":"c1","uid":1220552,"ip_address":"","ucode":"9BAFC3B184B1D2","user_header":"https://static001.geekbang.org/account/avatar/00/12/9f/c8/0318c83e.jpg","comment_is_top":false,"comment_ctime":1570460148,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570460148","product_id":100017301,"comment_content":" public static int binarySearch2(int[] arr, int key) {<br>    &#47;&#47;先调用普通的二分查找法<br>        int index = binarySearch1(arr, key);<br>        if (index == -1) {<br>            return -1;<br>        } else {<br>            for (int i = index; i &gt;= 0; i--) {<br>                if (arr[i] != arr[index]) {<br>                    &#47;&#47;找到第一个不同的元素<br>                    return ++i;<br>                }<br>            }<br>            return 0;<br>        }<br>    }<br><br>感觉这样更好理解,哈哈","like_count":0},{"had_liked":false,"id":137311,"user_name":"JustDoDT","can_delete":false,"product_type":"c1","uid":1127175,"ip_address":"","ucode":"6AF0B80F00EAEF","user_header":"https://static001.geekbang.org/account/avatar/00/11/33/07/8f351609.jpg","comment_is_top":false,"comment_ctime":1569685848,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569685848","product_id":100017301,"comment_content":"来俩个迷惑人的问题：<br>查找第一个小于等于给定值的元素<br>查找最后一个大于等于给定值的元素","like_count":0},{"had_liked":false,"id":133235,"user_name":"onee","can_delete":false,"product_type":"c1","uid":1613204,"ip_address":"","ucode":"48C0A8938548C3","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIO6eRuuA6V34kREveXkNaebicNzy3oUvEM3t48ehMRJIuCnYNe9B54VuAndjo1cZZ5ykHDHL8ZlhA/132","comment_is_top":false,"comment_ctime":1568456391,"is_pvip":false,"replies":[{"id":"51219","content":"小争哥原创：）","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1568588364,"ip_address":"","comment_id":133235,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568456391","product_id":100017301,"comment_content":"这写法实在太妙了，妈妈再也不用担心二分查找不会写了","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467312,"discussion_content":"小争哥原创：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568588364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129937,"user_name":"Momentum","can_delete":false,"product_type":"c1","uid":1398396,"ip_address":"","ucode":"9822B01061FE79","user_header":"https://static001.geekbang.org/account/avatar/00/15/56/7c/a30223c1.jpg","comment_is_top":false,"comment_ctime":1567329821,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567329821","product_id":100017301,"comment_content":"我写了高赞的解决方法3，利用循环队列中间位置分治的情况，来实现logn时间复杂度。<br>只能说，这道理知易行难，遍历测试便知，在遇到重复数字被切成两份时，很容易出bug。<br>（也许是我太弱？）","like_count":0},{"had_liked":false,"id":128452,"user_name":"半生瓜。","can_delete":false,"product_type":"c1","uid":1606288,"ip_address":"","ucode":"6D4CC445230D19","user_header":"https://static001.geekbang.org/account/avatar/00/18/82/90/295449c4.jpg","comment_is_top":false,"comment_ctime":1566882183,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566882183","product_id":100017301,"comment_content":"借用Smallfly的第三种思想实现了一个。时间复杂度是2*O(logn)。<br>&#47;**<br> * 假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br> * ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。<br> * 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。<br> * 你可以假设数组中不存在重复的元素。<br> * 你的算法时间复杂度必须是 O(log n) 级别。<br> * 示例 1:<br> * 输入: nums = [4,5,6,7,0,1,2], target = 0<br> * 输出: 4<br> * @author HILL<br> * @version V1.0<br> * @date 2019&#47;8&#47;27<br> **&#47;<br>public class Solution {<br><br><br>    public int search(int[] nums, int target) {<br><br>        int low = 0;<br>        int high = nums.length-1;<br>        while (low&lt;=high){<br>            int mid = low+( (high-low) &gt;&gt;1 );<br>            if ( nums[mid] == target ) {<br>                return mid;<br>            }<br>            &#47;&#47;中点将数组分为一个有序数组、一个循环有序数组<br>            if(nums[mid] &gt;= nums[0] ){<br>                &#47;&#47;mid的前半段是有序数组，判断target是否在此范围内<br>                if (nums[mid] &gt; target &amp;&amp; nums[low] &lt;= target) {<br>                    &#47;&#47;调用二分正常查询<br>                    return binSearch(nums, target, low, mid-1);<br>                }else{<br>                    low = mid+1;<br>                }<br>            }else {<br>                &#47;&#47;mid的前半段是循环有序数组<br>               &#47;&#47;后半段是有序数组，判断target是否在此范围内<br>                if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[high]) {<br>                    &#47;&#47;调用二分正常查询<br>                    return binSearch(nums, target, mid+1, high);<br>                }else{<br>                    high = mid-1;<br>                }<br>            }<br>        }<br><br>        return -1;<br>    }<br><br><br>    private int binSearch(int[] nums, int target, int low, int high) {<br>        while (low&lt;=high){<br>            int mid = low+( (high-low) &gt;&gt;1 );<br>            if (nums[mid]&gt;target){<br>                high = mid-1;<br>            }else if (nums[mid]&lt;target){<br>                low = mid+1;<br>            }else{<br>                return mid;<br>            }<br>        }<br>        return -1;<br>    }<br><br><br>}","like_count":0},{"had_liked":false,"id":125953,"user_name":"走马","can_delete":false,"product_type":"c1","uid":1251016,"ip_address":"","ucode":"EEFE8F7590FFA4","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/c8/980776fc.jpg","comment_is_top":false,"comment_ctime":1566281893,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566281893","product_id":100017301,"comment_content":"&#47;&#47; 查找最后一个值等于给定值的元素<br>public static int Search_2(int[] sc,int aim)<br>{<br>    int low=0;<br>    int high=sc.length-1;<br>    int mid=0;<br>    while (low&lt;=high)<br>    {<br>        mid=low+((high-low)&gt;&gt;1);<br>        if(sc[mid]&gt;aim)<br>        {<br>            high=mid-1;<br>        }<br>        else<br>            low=mid+1;<br>    }<br>    if(high&gt;-1 &amp;&amp; sc[high]==aim)<br>        return high;<br>    else<br>        return -1;<br>}<br>--------------------------------------------------------------------------<br>&#47;&#47;查找第一个大于等于给定值的元素<br>public static int Search_3(int[] sc,int aim)<br>{<br>    int low=0;<br>    int high=sc.length-1;<br>    int mid=0;<br>    while (low&lt;=high)<br>    {<br>        mid=low+((high-low)&gt;&gt;1);<br>        if(sc[mid]&gt;=aim)<br>        {<br>            high=mid-1;<br>        }<br>        else<br>        {<br>            low=mid+1;<br>        }<br>    }<br>    if(low&lt;sc.length &amp;&amp; sc[low]&gt;=aim)<br>        return low;<br>    return -1;<br>}<br>-----------------------------------------------------------------------------<br>&#47;&#47; 查找最后一个小于等于给定值的元素<br>public static int Search_4(int[] sc,int aim)<br>{<br>    int low=0;<br>    int high=sc.length-1;<br>    int mid;<br>    while (low&lt;=high)<br>    {<br>        mid=low+((high-low)&gt;&gt;1);<br>        if(sc[mid]&lt;=aim)<br>        {<br>            low=mid+1;<br>        }<br>        else<br>        {<br>            high=mid-1;<br>        }<br>    }<br>    if(high&gt;0 &amp;&amp; sc[high]&lt;=aim)<br>        return high;<br>    return -1;<br>}","like_count":0},{"had_liked":false,"id":122858,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1565557393,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565557393","product_id":100017301,"comment_content":"遍历一下，确定初始的 left 和 right！<br>循环条件是 left != right<br>int mid = (left + (left + right) &#47; 2) % num.length<br>if num[mid] == value  return mid<br>if num[mid] &gt; value <br>       if mid == 0 <br>              right = num.length - 1;<br>       else <br>              right = mid - 1;<br>if num[mid] &lt; value <br>        if mid == n - 1 <br>              left = 0<br>        else<br>           left = mid + 1<br>不知道思路对不～～～","like_count":0},{"had_liked":false,"id":115485,"user_name":"Geek_33c134","can_delete":false,"product_type":"c1","uid":1596647,"ip_address":"","ucode":"C5BBA83AABD2AC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Ir1EdhB29109UhH7SGnVLEfEcKcGPDViaTpbS7BYXngqFghThYc093oFCTwsTLjVR7nHPokXJIPm7rbmPAU7TdQ/132","comment_is_top":false,"comment_ctime":1563601131,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563601131","product_id":100017301,"comment_content":"我第一个认为学的最好的算法就是二分算法，到了现在我最烦的就是二分算法。","like_count":0},{"had_liked":false,"id":115297,"user_name":"星期八","can_delete":false,"product_type":"c1","uid":1185504,"ip_address":"","ucode":"34A37F73A48E7F","user_header":"https://static001.geekbang.org/account/avatar/00/12/16/e0/7abad3cc.jpg","comment_is_top":false,"comment_ctime":1563526635,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1563526635","product_id":100017301,"comment_content":"课后思考题：请各位指导<br> int searchIndex(int[] a,int start,int end,int value){<br>        int middler = start + ((end - start)&gt;&gt;1);<br>        if(a[middler] != value) {<br>            if (a[middler] &gt; value &amp;&amp; a[0] &gt; value &amp;&amp; a[end] &gt;= value) {<br>                start = middler + 1;<br>            }<br>            if (a[middler] &gt; value &amp;&amp; a[0] &lt;= value &amp;&amp; a[end] &lt; value) {<br>                end = middler - 1;<br>            }<br>        }else{<br>            return middler;<br>        }<br>        while(start &lt;= end){<br>            middler = start + ((end - start)&gt;&gt;1);<br>            if(a[middler] &gt; value) {end = middler - 1;}<br>            else if(a[middler] &lt; value){ start  = middler + 1;}<br>            else return middler;<br>            }<br>        return -1;<br>    }","like_count":0,"discussions":[{"author":{"id":1122074,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1f/1a/54a00fdb.jpg","nickname":"artshell","note":"","ucode":"A74C45DA8FC550","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":111060,"discussion_content":"当查找的元素不在数组中，抛数组越界异常","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577776611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":113333,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1562974226,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562974226","product_id":100017301,"comment_content":"二叉查找的心法<br>结束条件 闭合区间为空<br>中间的值如果满足条件则返回，<br>不满足条件，跳过该值将区间分半","like_count":0},{"had_liked":false,"id":107140,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1561466596,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561466596","product_id":100017301,"comment_content":"二分查找除了在精确查找的应用场景下，还应用在近似查找的应用场景下。","like_count":0},{"had_liked":false,"id":105232,"user_name":"ppking","can_delete":false,"product_type":"c1","uid":1381730,"ip_address":"","ucode":"0C95B838F7E2FB","user_header":"","comment_is_top":false,"comment_ctime":1560942659,"is_pvip":false,"replies":[{"id":"38121","content":"不，代码没问题的，你再仔细看下","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1560988617,"ip_address":"","comment_id":105232,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560942659","product_id":100017301,"comment_content":"变体三里面如果要查找的值就是数组里面已经存在的元素，那么在这种情况下，得到的值就是这个本身的位置了，应该不合适吧？如果考虑还存在重复元素，是不是在if(mid == 0 || (a[mid-1] &lt; value)) 这个程序段里return之前加上\tfor(;(a[mid] &lt;= value) &amp;&amp; mid &lt; n;mid++){}会可以呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454600,"discussion_content":"不，代码没问题的，你再仔细看下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560988617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104808,"user_name":"🐬🐬🐬","can_delete":false,"product_type":"c1","uid":1155214,"ip_address":"","ucode":"6585F8B8ADC43E","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/8e/919dee01.jpg","comment_is_top":false,"comment_ctime":1560844333,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560844333","product_id":100017301,"comment_content":"思考题：<br>首先找到数组的临界值，分成两部分分别求元素的下标（因为有可能两部分都包含）并返回数组，都未找到则返回空数组。<br>适用倒序升序任意组合的数组<br>const search = (arr, value) =&gt; {<br>    let n = arr.length<br>    let low = 0<br>    let high = n - 1<br>    let indexArr = []<br>    <br>    while (low &lt;= high) {<br>        let mid = low + ((high - low) &gt;&gt; 1)<br>        if (arr[mid - 1] &lt; arr[mid] &amp;&amp; arr[mid + 1] &lt; arr[mid]||arr[mid - 1] &gt; arr[mid] &amp;&amp; arr[mid + 1] &gt; arr[mid]) { &#47;&#47;找出中间分界值<br>            let x = findEqual(arr, low, mid, value)<br>            if (x !== -1) {<br>                indexArr.push(x)<br>            }<br>            let y = findEqual(arr,mid+1,high,value)<br>            if (y !== -1) {<br>                indexArr.push(y)<br>            }<br>            return indexArr<br><br>        } else if (arr[mid - 1] &lt; arr[mid] &amp;&amp; arr[mid + 1] &gt; arr[mid]) {<br>            low = mid + 1<br>        } else if (arr[mid - 1] &gt; arr[mid] &amp;&amp; arr[mid + 1] &lt; arr[mid]) {<br>            high = mid - 1<br>        }<br>    }<br>}<br>const findEqual = (arr,low,high, value) =&gt; {<br>    while(low&lt;=high) {<br>        let mid = low + ((high - low) &gt;&gt; 1)<br>        if (mid == 0 || arr[mid - 1] &lt;= arr[mid]) { &#47;&#47; mid在递增区间<br>            if (arr[mid] &lt; value) {<br>                low = mid + 1<br>            } else if (arr[mid] &gt; value) {<br>                high = mid -1<br>            } else {<br>                return mid<br>            }<br>        } else if (mid == high || arr[mid - 1] &gt;= arr[mid]){  &#47;&#47; mid在递减区间<br>            if (arr[mid] &lt; value) {<br>                high = mid - 1<br>            } else if (arr[mid] &gt; value) {<br>                low = mid + 1<br>            } else {<br>                return mid<br>            }<br>        }<br>    }<br>    return -1<br>}","like_count":0},{"had_liked":false,"id":103205,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1560396534,"is_pvip":false,"replies":[{"id":"37585","content":"没太看懂你说的意思呢","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1560563037,"ip_address":"","comment_id":103205,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560396534","product_id":100017301,"comment_content":"在变体三种，处理不了大于右边界的情况吧，如果算法是找到第一个插入的位置，是不是要return low 而不是return -1 ，","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453786,"discussion_content":"没太看懂你说的意思呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560563037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":102843,"user_name":"佚名","can_delete":false,"product_type":"c1","uid":1356077,"ip_address":"","ucode":"A4E35B21AC3C31","user_header":"https://static001.geekbang.org/account/avatar/00/14/b1/2d/661132f3.jpg","comment_is_top":false,"comment_ctime":1560312457,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1560312457","product_id":100017301,"comment_content":"用smallfly的思路一实现的O(logN)的解法，java代码如下，已在lettcode33题AC，代码字数超了2000字，只放第一步找下标将数组拆分成两个有序数组，第二步判断在哪个数组内并二分查找比较简单。<br>     &#47;**<br>     * 获得数组最大值下标<br>     * @param a 数组<br>     * @return 最大值下标<br>     *&#47;<br>    public static int findMax(int[] a) {<br>        &#47;&#47;数组为空直接返回-1<br>        if (a.length == 0) {<br>            return -1;<br>        }<br>        int low = 0;<br>        int high = a.length - 1;<br>        &#47;&#47;当a.length == 1，最大值下标即为0<br>        if (high == 0) {<br>            return 0;<br>        }<br>        &#47;&#47;当a.length == 2，最大值下标为low或high<br>        if (high == 1) {<br>            if (a[low] &lt; a[high]) return high;<br>            else return low;<br>        }<br>        &#47;&#47;因为数组是循环有序数组，只有当数组升序时，如{1,2,3}，a[high]才会大于a[low]，最大值即为最后一个元素<br>        if (a[high] &gt; a[low]) {<br>            return high;<br>        }<br>        &#47;&#47;当a.length &gt;= 3时，使用二分查找数组最大值下标<br>        while (low &lt;= high) {<br>            int mid = low + ((high - low) &gt;&gt; 1);<br>            &#47;&#47;此情况出现于当区间缩小至low == 0，high == 1还没找到最大值时，则最大值即为第一个元素，如{5,1,2,3,4}<br>            if (mid == 0) return mid;<br>            if (a[mid] &gt; a[mid - 1] &amp;&amp; a[mid] &gt; a[mid + 1]) {<br>                &#47;&#47;如果此元素既大于它左边的元素，又大于它右边的元素，则它为最大值，如{4,5,6,7,0,1,2}<br>                return mid;<br>            } else if (a[mid] &lt; a[mid - 1] &amp;&amp; a[mid] &lt; a[mid + 1]) {<br>                &#47;&#47;如果此元素既小于它左边的元素，又小于它右边的元素，则它为最小值，如{5,6,7,0,1,2,4}<br>                &#47;&#47;根据循环有序数组的特性，最大值即在它左边<br>                return mid - 1;<br>            } else if (a[mid] &gt; a[mid - 1] &amp;&amp; a[mid] &lt; a[mid + 1] &amp;&amp; a[mid] &gt; a[low]) {<br>                &#47;&#47;如果此元素大于它左边的元素，小于它右边的元素，且大于区间第一个元素，则最大值在它右边，如{1,2,4,5,6,7,0}<br>                low = mid + 1;<br>            } else if (a[mid] &gt; a[mid - 1] &amp;&amp; a[mid] &lt; a[mid + 1] &amp;&amp; a[mid] &lt; a[low]) {<br>                &#47;&#47;如果此元素大于它左边的元素，小于它右边的元素，且小于区间第一个元素，则最大值在它左边，如{6,7,0,1,2,4,5}<br>                high = mid - 1;<br>            } else if (a[mid] &lt; a[mid - 1] &amp;&amp; a[mid] &gt; a[mid + 1]) {<br>                &#47;&#47;如果此元素小于它左边的元素，大于它右边的元素，只有数组是降序的才会出现这个情况，最大值即为第一个元素，如{3,2,1}<br>                return 0;<br>            }<br>        }<br>        return -1;<br>    }<br>","like_count":0},{"had_liked":false,"id":102256,"user_name":"wxj","can_delete":false,"product_type":"c1","uid":1487456,"ip_address":"","ucode":"B9BFE650BC4A39","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLzSRrK59sydq3k5uTE9SzPYShHo3PqGh8GTk3be0pHjS7eGTdw27cUyI0M4UEiaicoV2PJpiajWGTtQ/132","comment_is_top":false,"comment_ctime":1560171085,"is_pvip":false,"replies":[{"id":"36902","content":"专栏中没有看到这句话呀","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1560210067,"ip_address":"","comment_id":102256,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1560171085","product_id":100017301,"comment_content":"我们发现循环数组存在一个性质：以数组中间点为分区，会将数组分成一个有序数组和一个循环有序数组。 请问这个要怎么理解呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453318,"discussion_content":"专栏中没有看到这句话呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560210067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1028698,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b2/5a/574f5bb0.jpg","nickname":"Lukia","note":"","ucode":"C19472337BCCC6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4346,"discussion_content":"置顶帖里有解释","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565326614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":102025,"user_name":"苦行僧","can_delete":false,"product_type":"c1","uid":1055334,"ip_address":"","ucode":"726024A9A9CF44","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/66/2d9db9ed.jpg","comment_is_top":false,"comment_ctime":1560122859,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560122859","product_id":100017301,"comment_content":"多写几次二分查找的变体问题","like_count":0},{"had_liked":false,"id":101195,"user_name":"William","can_delete":false,"product_type":"c1","uid":1346215,"ip_address":"","ucode":"55F5D9DEE485B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","comment_is_top":false,"comment_ctime":1559738070,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1559738070","product_id":100017301,"comment_content":"变体三：查找第一个大于等于给定值的元素<br>public static  int bsearch3(int[] a, int n, int value) {<br>        int low = 0;<br>        int high = n - 1;<br>        while (low &lt;= high) {<br>            int mid = low + ((high - low) &gt;&gt; 1);<br>            if (a[mid] &gt;= value) {<br>                if(a[mid-1] &lt; value){<br>                    return mid ;<br>                }else{<br>                    high = mid - 1;<br>                }<br>            } else {<br>                low = mid + 1;<br>            }<br>        }<br>        return -1;<br><br><br>    }","like_count":0},{"had_liked":false,"id":101193,"user_name":"William","can_delete":false,"product_type":"c1","uid":1346215,"ip_address":"","ucode":"55F5D9DEE485B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","comment_is_top":false,"comment_ctime":1559737357,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1559737357","product_id":100017301,"comment_content":"变体二：查找最后一个值等于给定值的元素<br>  还是看这种的比较好理解..<br>```<br>public static  int bsearch2(int[] a, int n, int value) {<br>        int low = 0;<br>        int high = n - 1;<br>        while (low &lt;= high) {<br>            int mid = low + ((high - low) &gt;&gt; 1);<br>            if (a[mid] &gt; value) {<br>                high = mid - 1;<br>            } else {<br>                low = mid + 1;<br>            }<br>        }<br><br>        if(low &lt; n &amp;&amp; a[high]==value){<br>            return high;<br>        }else{<br>            return -1;<br>        }<br>    }<br>```<br><br>","like_count":0},{"had_liked":false,"id":101188,"user_name":"William","can_delete":false,"product_type":"c1","uid":1346215,"ip_address":"","ucode":"55F5D9DEE485B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","comment_is_top":false,"comment_ctime":1559736455,"is_pvip":true,"discussion_count":6,"race_medal":0,"score":"1559736455","product_id":100017301,"comment_content":"mid = low +(hight -low ) &#47; 2 <br>等同于.<br>mid = low +(hight -low ) &gt;&gt; 1<br>位运算<br><br><br>","like_count":0,"discussions":[{"author":{"id":1206751,"avatar":"https://static001.geekbang.org/account/avatar/00/12/69/df/2dca1305.jpg","nickname":"Healtheon","note":"","ucode":"B564B1FC4456E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":21276,"discussion_content":"不等同于，位移你没加括号。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569461882,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1346215,"avatar":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","nickname":"William","note":"","ucode":"55F5D9DEE485B1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1206751,"avatar":"https://static001.geekbang.org/account/avatar/00/12/69/df/2dca1305.jpg","nickname":"Healtheon","note":"","ucode":"B564B1FC4456E8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":31959,"discussion_content":"哪里？ ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570972695,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":21276,"ip_address":""},"score":31959,"extra":""},{"author":{"id":1206751,"avatar":"https://static001.geekbang.org/account/avatar/00/12/69/df/2dca1305.jpg","nickname":"Healtheon","note":"","ucode":"B564B1FC4456E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1346215,"avatar":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","nickname":"William","note":"","ucode":"55F5D9DEE485B1","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":31968,"discussion_content":"(hight -low ) >> 1这个整体得加括号啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570974246,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":31959,"ip_address":""},"score":31968,"extra":""},{"author":{"id":1346215,"avatar":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","nickname":"William","note":"","ucode":"55F5D9DEE485B1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1206751,"avatar":"https://static001.geekbang.org/account/avatar/00/12/69/df/2dca1305.jpg","nickname":"Healtheon","note":"","ucode":"B564B1FC4456E8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":33159,"discussion_content":"我写的有的呀、那不是有么？ ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571103597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":31968,"ip_address":""},"score":33159,"extra":""}]}]},{"had_liked":false,"id":99793,"user_name":"Geek_bbe9ea","can_delete":false,"product_type":"c1","uid":1336413,"ip_address":"","ucode":"4A0DA7C81D233C","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/5d/c8e2663b.jpg","comment_is_top":false,"comment_ctime":1559302422,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559302422","product_id":100017301,"comment_content":"func search(nums []int, target int) int {<br>    <br>    left := 0<br>\tright := len(nums) - 1<br><br>\treturn bSearch(nums, target, left, right)<br>}<br><br>func bSearch(nums []int, target int, low int, high int) int {<br>\tif high &lt; low {<br>\t\treturn -1<br>\t}<br>\tmid := rotateIdx(nums, low, high)<br>\tif mid &lt; 0 {<br>\t\treturn -1<br>\t}<br>\tif target == nums[mid] {<br>\t\treturn mid<br>\t} else {<br>\t\tif target &gt; nums[mid] {<br>\t\t\treturn -1<br>\t\t} else {<br>\t\t\tif high &gt; mid &amp;&amp; target &lt; nums[mid + 1] {<br>\t\t\t\treturn -1<br>\t\t\t} else {<br>\t\t\t\tif nums[low] &gt; target {<br>\t\t\t\t\treturn dsearch(nums, target, mid + 1, high)<br>\t\t\t\t}<br>\t\t\t\treturn dsearch(nums, target, low, mid - 1)<br>\t\t\t}<br>\t\t}<br>\t}<br>}<br><br>func rotateIdx(nums []int, low int, high int) int {<br>\tmid := low + ((high - low) &gt;&gt; 1)<br><br>\tif high &lt; low {<br>\t\treturn -1<br>\t}<br><br>\tif mid &lt; high {<br>\t\tif nums[mid] &gt; nums[mid + 1] {<br>\t\t\treturn mid<br>\t\t}<br>\t} else {<br>\t\treturn mid<br>\t}<br><br>\tif nums[low] &gt; nums[mid] {<br>\t\thigh = mid - 1<br>\t\treturn rotateIdx(nums, low, high)<br>\t} else {<br>\t\tlow = mid + 1<br>\t\treturn rotateIdx(nums, low, high)<br>\t}<br><br>\tlow = mid + 1<br>\treturn rotateIdx(nums, low, high)<br><br>\treturn mid<br>}<br><br>func dsearch(nums []int, target int, low int, high int) int {<br>\tif low &gt; high {<br>\t\treturn -1<br>\t}<br>\t<br>\tmid := low + ((high - low) &gt;&gt; 1)<br><br>\tif target == nums[mid]{<br>\t\t return mid<br>\t} else if target &gt; nums[mid] {<br>\t\tlow = mid + 1<br>\t\treturn dsearch(nums, target, low, high)<br>\t} else {<br>\t\thigh = mid - 1<br>\t\treturn dsearch(nums, target, low, high)<br>\t}<br>\t<br>}","like_count":0},{"had_liked":false,"id":98555,"user_name":"覃钰栋","can_delete":false,"product_type":"c1","uid":1251835,"ip_address":"","ucode":"19080C463658EF","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/oiboHpgukqib2ASXeU0H7W1ibgRMqyrNE5KaWicicPEDy0ia8YdoneZAtvW0EFIiaqZJp2OS4dnweOgXaJ5EjJicicEqic5A/132","comment_is_top":false,"comment_ctime":1559027500,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559027500","product_id":100017301,"comment_content":"  思考题<br> public static int search(int[] array, int target) {<br>        int low = 0;<br>        int high = array.length - 1;<br>        while (low &lt;= high) {<br>            int mid = low + ((high - low) &gt;&gt; 1);<br>            if (array[mid] == target) {<br>                return mid;<br>            }<br><br>            &#47;&#47;情况一、如果首元素小于 mid，说明前半部分是有序的，后半部分是循环有序数组<br>            if (array[low] &lt;= array[mid]) {<br>                if (target &lt; array[mid] &amp;&amp; target &gt;= array[low]) {<br>                    high = mid - 1;<br>                } else {<br>                    low = mid + 1;<br>                }<br>            }<br><br>            &#47;&#47;情况二、如果尾元素大于 mid，说明后半部分是有序的，前半部分是循环有序的数组；<br>            if (array[high] &gt;= array[mid]) {<br>                if (target &gt; array[mid] &amp;&amp; target &lt;= array[high]) {<br>                    low = mid + 1;<br>                } else {<br>                    high = mid - 1;<br>                }<br>            }<br>        }<br>        return -1;<br>    }","like_count":0},{"had_liked":false,"id":98245,"user_name":"极客miao","can_delete":false,"product_type":"c1","uid":1251060,"ip_address":"","ucode":"45AC3AC78B6216","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/f4/ca2a0ca1.jpg","comment_is_top":false,"comment_ctime":1558941318,"is_pvip":false,"replies":[{"id":"35205","content":"😁","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1559006215,"ip_address":"","comment_id":98245,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1558941318","product_id":100017301,"comment_content":"google 工程师为啥要用百度？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451612,"discussion_content":"😁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559006215,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94568,"user_name":"Mr丶JDR","can_delete":false,"product_type":"c1","uid":1194429,"ip_address":"","ucode":"0377C1D0EDABBF","user_header":"https://static001.geekbang.org/account/avatar/00/12/39/bd/344cff8c.jpg","comment_is_top":false,"comment_ctime":1557843028,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557843028","product_id":100017301,"comment_content":"哈哈，我和老师的思路是差不多的，但写法有点不一样；但王老师的更好！！！<br>&#47;**<br>     * 查找第一个值等于给定值的元素<br>     *<br>     * @param arr   数据源<br>     * @param value 需查找的值<br>     * @return 下标<br>     *&#47;<br>    public static int findByFirstValue(int[] arr, int value) {<br>        &#47;&#47; 校验元素个数<br>        int len = arr.length;<br>        if (len &lt; 1) {<br>            return -1;<br>        }<br><br>        &#47;&#47; 为了避免 while (arr[--mid] == midValue) 此段逻辑出现下标越界的问题先验证下标为0的元素是否相等<br>        if (arr[0] == value) {<br>            return 0;<br>        }<br><br>        &#47;&#47; 二分查找头部下标<br>        int head = 0;<br>        &#47;&#47; 二分查找尾部下标<br>        int tail = len - 1;<br><br>        while (head &lt;= tail) {<br>            int mid = head + ((tail - head) &gt;&gt; 1);<br>            int midValue = arr[mid];<br>            if (midValue == value) {<br>                &#47;&#47; 看前一个值是否与自己相等，直到不相等后，返回下一个下标的值<br>                while (arr[--mid] == midValue) {<br>                }<br>                return ++mid;<br>            } else if (midValue &gt; value) {<br>                tail = mid - 1;<br>            } else {<br>                head = mid + 1;<br>            }<br>        }<br><br>        return -1;<br>    }","like_count":0},{"had_liked":false,"id":93915,"user_name":"saber","can_delete":false,"product_type":"c1","uid":1193468,"ip_address":"","ucode":"D02F8D129DB41C","user_header":"https://static001.geekbang.org/account/avatar/00/12/35/fc/6d3e0035.jpg","comment_is_top":false,"comment_ctime":1557664538,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557664538","product_id":100017301,"comment_content":"思考题：将有序数组分成两部分。然后判断目标值在哪个有序数组范围内。然后在指定区间内进行二分搜索。<br>下面实现过程中。查找分界点用二分方法，复杂度 O(log(n))。之后选择某个有序区间二分搜索，复杂度为 O(log(n))。因此总复杂度仍然是 O(log(n))。<br>实现代码如下（经过 leetcode 33 ，网上检验正确了。实际运行速度达到了 c++ 排行第一名）<br>（可以到我的 github 上查看本专栏其他部分的笔记和带有详细注释的代码：<br>https:&#47;&#47;github.com&#47;saber&#47;algorithm）<br><br><br><br>&#47;&#47;! \\note<br>&#47;&#47;!     1）仅仅针对数据是升序，且是 int 类型<br>&#47;&#47;!     2）函数内部所说的分界点 pivot 表示最大值。<br>&#47;&#47;! \\complexity O(logn) = O(查找分界点) + O(正式查找目标值)，两部分都是 log(n)<br>int SearchRotatedSortedArray(vector&lt;int&gt;&amp; nums, int target) {<br>    if (nums.size() &lt; 1)<br>        return -1;<br><br>    &#47;&#47; 快速检验头尾元素<br>    if (nums[0] == target)<br>        return 0;<br>    else if (nums[nums.size()-1] == target)<br>        return nums.size() - 1;<br>    if (nums.size() &lt;= 2)<br>        return -1;<br><br>    &#47;&#47; 1 先找 pivot 点（此时对应最大值）<br>    &#47;&#47; 下面实现方法，对于整个数组是有序时，是不能找到分界点的，此时 pivot 仍然保留原来的值 -1<br>    int pivot = -1;<br>    int low = 0;<br>    int high = nums.size() - 1;<br>    while (low &lt;= high) {<br>        int middle = low + (high - low)&#47;2;<br>        if ((middle+1) &lt; int(nums.size()) and nums[middle] &gt; nums[middle+1]) {<br>            pivot = middle;<br>            break;<br>        } else if (nums[low] &lt;= nums[middle]) {<br>            low  = middle + 1;<br>        } else {<br>            high = middle - 1;<br>        }<br>    }<br>    cout &lt;&lt; &quot;pivot: &quot; &lt;&lt; pivot &lt;&lt; endl;<br><br>    &#47;&#47; 退出上面的循环有两种情况：<br>    &#47;&#47;  1）数组本身整体就是循环的，那么无法找到 pivot ，此时 pivot = -1<br>    &#47;&#47;  2）数组是循环有序的，那么可以找到最大值点，分界点即为 pivot 值<br><br>    &#47;&#47; 2 从两边有序（升序）数组中选择一个区间，按照二分方式进行查找<br>    &#47;&#47; 1）选定二分区间<br>    if (pivot &lt; 0) { &#47;&#47; 整个数组是有序的，在整个区间进行二分<br>        low  = 0;<br>        high = nums.size() - 1;<br>    } else if (nums[0] &gt; target) { &#47;&#47; 目标值在右区间<br>        low  = pivot + 1;<br>        high = nums.size() - 1;<br>    } else { &#47;&#47; 目标值在左区间<br>        low  = 0;<br>        high = pivot;<br>    }<br><br>    &#47;&#47; 2）进行二分查找<br>    while (low &lt;= high) {<br>        int middle = low + (high - low)&#47;2;<br>        if (nums[middle] == target) {<br>            return middle;<br>        } else if (nums[middle] &lt; target) {<br>            low = middle + 1;<br>        } else {<br>            high = middle - 1;<br>        }<br>    }<br>    return -1;<br>}","like_count":0},{"had_liked":false,"id":92623,"user_name":"犇","can_delete":false,"product_type":"c1","uid":1241705,"ip_address":"","ucode":"CCA66C9BF3EBAB","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/69/a925db7a.jpg","comment_is_top":false,"comment_ctime":1557307077,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557307077","product_id":100017301,"comment_content":"这个IP地址很棒，我的家乡😄","like_count":0},{"had_liked":false,"id":92319,"user_name":"猪猪男孩","can_delete":false,"product_type":"c1","uid":1461246,"ip_address":"","ucode":"E853E29182C6B5","user_header":"https://static001.geekbang.org/account/avatar/00/16/4b/fe/048ad222.jpg","comment_is_top":false,"comment_ctime":1557231564,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557231564","product_id":100017301,"comment_content":"时间复杂度O(logN)<br>class Solution:<br>    def search(self, nums, target: int) -&gt; int:<br>        if not nums:<br>            return -1<br>        i = 0<br>        j = len(nums)-1<br>        a = nums<br>        mid = i<br>        # 找到最小值的分界点<br>        while a[i] &gt;= a[j]:<br>            if j-i == 1:<br>                mid = j<br>                break<br>            mid = (i+j) &gt;&gt; 1<br>            if a[i] == a[mid] and a[j] == a[mid]:<br>                for k in range(i,j):<br>                    if a[k] &lt; a[mid]:<br>                        mid = k<br>                break<br>           <br>            elif a[mid] &gt;= a[i]:#i - mid 递增<br>                i = mid<br>            elif a[mid] &lt;= a[j]:#mid - j 递增<br>                j = mid<br>        # 锁定分区<br>        i = 0<br>        j = len(nums)-1<br>        if mid == 0:<br>            pass<br>        elif mid == j:<br>            if target == nums[-1]:<br>                return j<br>            else:<br>                j = mid-1<br>        elif target &gt;= a[mid] and target &lt;= a[j]:<br>            i = mid<br>        elif target &gt;= a[0] and target &lt;= a[mid-1]:<br>            j = mid-1<br>        <br>        while i &lt;= j:<br>            m = (i+j)&gt;&gt;1<br>            if a[m] == target:<br>                return m<br>            elif a[m] &gt; target:<br>                j = m-1<br>            elif a[m] &lt; target:<br>                i = m+1<br>        <br>        return -1","like_count":0},{"had_liked":false,"id":91285,"user_name":"星文友","can_delete":false,"product_type":"c1","uid":1068162,"ip_address":"","ucode":"EE438B9C1C7B61","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK9RytLsauRVYGjupDIaibibAK5iaicEicONrMFc0O3icAGf5mD1buxoQ2ePPn9YurFhRbuf3AR1qJDy0GQ/132","comment_is_top":false,"comment_ctime":1556964246,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556964246","product_id":100017301,"comment_content":"思路是找到开头的地方，然后调整开始和结束的位置，其余跟普通二分查找没有区别<br>class Solution {<br>    public int search(int[] nums, int target) {<br>        if (nums == null || nums.length == 0) {<br>            return -1;<br>        }<br>        int startIndex = 0;<br>        int temp = nums[0];<br>        int arrayLength = nums.length;<br>        for (int i = 0; i &lt; arrayLength; i++) {<br>            if (temp &gt; nums[i]) {<br>                temp = nums[i];<br>                startIndex = i;<br>            }<br>        }<br><br>        int endIndex = startIndex + arrayLength - 1;<br>        while (startIndex &lt;= endIndex) {<br>            int mid = startIndex + ((endIndex - startIndex) &gt;&gt; 1);<br>            int currentIndex = mid % arrayLength;<br>            if (nums[currentIndex] &lt; target) {<br>                startIndex = startIndex + 1;<br>            }else if(nums[currentIndex] &gt; target){<br>                endIndex = endIndex -1;<br>            }else {<br>                return currentIndex;<br>            }<br>        }<br>        return -1;<br>    }<br>}","like_count":0},{"had_liked":false,"id":90370,"user_name":"天，很蓝 ～","can_delete":false,"product_type":"c1","uid":1339242,"ip_address":"","ucode":"081D57F7CECC37","user_header":"https://static001.geekbang.org/account/avatar/00/14/6f/6a/b0d7987b.jpg","comment_is_top":false,"comment_ctime":1556501114,"is_pvip":false,"replies":[{"id":"32371","content":"非变体的二分查找怎么实现的呢？","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1556502659,"ip_address":"","comment_id":90370,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556501114","product_id":100017301,"comment_content":"查找ip的时候，文中说先使用变体的二分查找到一个值，然后再遍历后边的查找。感觉这个直接使用非变体的二分查找不是也可以吗？还是我哪里没理解到，望老师或同学指点一下","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448496,"discussion_content":"非变体的二分查找怎么实现的呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556502659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90200,"user_name":"李杰","can_delete":false,"product_type":"c1","uid":1019166,"ip_address":"","ucode":"8FCEBB886EA90B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/1e/fa135b14.jpg","comment_is_top":false,"comment_ctime":1556446020,"is_pvip":false,"replies":[{"id":"32375","content":"202.102.156.0这个是怎么来的呢？应该是202.102.156.34吧","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1556503163,"ip_address":"","comment_id":90200,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556446020","product_id":100017301,"comment_content":"老师您好，查找IP这个题目有个具体细节想了解下就是：比如 [202.102.156.34 202.102.156.255]那转化32位整数是不是只取 202.102.156.0 转，这样就不需要排序这个区间的所有值，最后拿到了最后一个小于等于的值再在这个区间里比对，是这样么？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448420,"discussion_content":"202.102.156.0这个是怎么来的呢？应该是202.102.156.34吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556503163,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90122,"user_name":"tuyu","can_delete":false,"product_type":"c1","uid":1448863,"ip_address":"","ucode":"B235325B541408","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/BIRpwViaN51yynIeFonD7QRlwDCVtKibrG956NTxzEqibOZZVjhMMgibOPmd3VicfYxpknZsic1oJq8KicZvXkmmiajuQg/132","comment_is_top":false,"comment_ctime":1556420018,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556420018","product_id":100017301,"comment_content":"不断反复看前面16节,终于能写思考题了;<br>分4种情况:<br># 用二分法查找一个循环数组<br>def b_search_cycle(a: List, value: int, low: int=0, high: int=0) -&gt; int:<br>    # 数组a是一个循环列表<br>    len_a = len(a)<br>    if len_a &lt;= 0:<br>        return -1<br><br>    while low &lt;= high:<br>        mid = low + (high - low) &#47;&#47; 2<br>        print(&quot;low {} high {} Mid {}&quot;.format(low, high, mid))<br>        if a[mid] == value:<br>            return mid<br>        elif a[low] &lt;= a[mid] &lt;= a[high]:<br>            if a[mid] &gt; value:<br>                high = mid - 1<br>            else:<br>                low = mid + 1<br>        elif a[high] &gt;= a[mid] and a[low] &gt;= a[mid]:<br>            if a[mid] &gt; value:<br>                return -1<br>            else:<br>                low1 = low<br>                high1 = mid - 1<br>                low2 = mid + 1<br>                high2 = high<br>                ret1 = b_search_cycle(a=a, value=value, low=low1, high=high1)<br>                ret2 = b_search_cycle(a=a, value=value, low=low2, high=high2)<br>                if ret1 != -1:<br>                    return ret1<br>                elif ret2 != -1:<br>                    return ret2<br>                else:<br>                    return -1<br>        elif a[high] &lt;= a[mid] and a[mid] &gt;= a[low]:<br>            if a[mid] &gt; value:<br>                low1 = low<br>                high1 = mid - 1<br>                low2 = mid + 1<br>                high2 = high<br>                ret1 = b_search_cycle(a=a, value=value, low=low1, high=high1)<br>                ret2 = b_search_cycle(a=a, value=value, low=low2, high=high2)<br>                if ret1 != -1:<br>                    return ret1<br>                elif ret2 != -1:<br>                    return ret2<br>                else:<br>                    return -1<br>            else:<br>                return -1<br>        else:<br>            return -1<br>    return -1<br>","like_count":0},{"had_liked":false,"id":87887,"user_name":"小邓","can_delete":false,"product_type":"c1","uid":1474505,"ip_address":"","ucode":"1E903D5622D39F","user_header":"https://static001.geekbang.org/account/avatar/00/16/7f/c9/40c609ee.jpg","comment_is_top":false,"comment_ctime":1555743195,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555743195","product_id":100017301,"comment_content":"循环数组问题通过Smallfly给的思路，我写了C#代码，链接在这：https:&#47;&#47;github.com&#47;CaigerDeng&#47;-DataStructure-BeautyOfAlgorithm-Homework&#47;blob&#47;master&#47;Main&#47;Main&#47;Chapter15.cs","like_count":0},{"had_liked":false,"id":86920,"user_name":"LCY","can_delete":false,"product_type":"c1","uid":1443345,"ip_address":"","ucode":"68BC650DC072CA","user_header":"https://static001.geekbang.org/account/avatar/00/16/06/11/7d14e384.jpg","comment_is_top":false,"comment_ctime":1555477935,"is_pvip":false,"replies":[{"id":"31496","content":"你现在说的是比较复杂的那种写法对吧，不建议去研究它啊，你就按照我给出的简单写法来就好了呢","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1555640159,"ip_address":"","comment_id":86920,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555477935","product_id":100017301,"comment_content":"临界情况：mid为要找的元素，当执行6，7行代码后high指向mid－1位置，由于数组内元素是有序的，mid下标以前的元素都小于mid中的元素，后面的二分查找会将low向右移动，<br>当移动到mid位置时，即为临界情况，此时low ＝ mid，high为mid－1。low指向的元素即是要找的第一个元素。<br><br>当mid指向的不是一个元素时，high为一直向左移动，直到移动到临界情况。<br><br>如果数组中不存在要找的元素时分为三种情况：<br>1.所有的元素都大于要找的元素，最终的结果为：high = -1,low = 0<br>2.所有的元素都小于要找的元素，最终的结果为：high ＝ n-1,low = n<br>3.数组中不存在要找的元素，最终的结果为：high = low - 1,下标为low的元素大于要找的元素。<br><br>老师对于第一种写法的理解你帮忙分析下有没有问题。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447245,"discussion_content":"你现在说的是比较复杂的那种写法对吧，不建议去研究它啊，你就按照我给出的简单写法来就好了呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555640159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83799,"user_name":"gico","can_delete":false,"product_type":"c1","uid":1167345,"ip_address":"","ucode":"AE40E8717A4F60","user_header":"https://static001.geekbang.org/account/avatar/00/11/cf/f1/057899c7.jpg","comment_is_top":false,"comment_ctime":1554717238,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554717238","product_id":100017301,"comment_content":"1.每次二分判断左右哪个是有序空间 <br>2.target是否在有序空间<br>3.循环直至条件结束<br>      <br><br>``` <br>public int search(int[] nums, int target) {<br>        int length = nums.length;<br>        int left = 0;<br>        int right = length-1;<br>        while(left&lt;=right){<br>            int mid = left+((right-left)&gt;&gt;1);<br>            if(nums[mid]==target){<br>                return mid;<br>            }<br>            if(nums[mid]&lt;nums[right]){<br>              &#47;&#47;右边有序 <br>                if(nums[mid]&lt;target&amp;&amp;nums[right]&gt;=target){<br>                    &#47;&#47;判断target是不是在有序空间中 在即进行二分<br>                    left = mid+1;<br>                    continue;<br>                }<br>               &#47;&#47;不在 即在左边边无序空间 再来执行循环<br>                right = mid-1;<br>            }else{<br>               &#47;&#47;中间值大于最右的值 左边有序<br>                if(nums[left]&lt;=target&amp;&amp;nums[mid]&gt;target){<br>                    &#47;&#47;判断target是不是在有序空间中 在即进行二分<br>                    right=mid-1;<br>                    continue;<br>                }<br>               &#47;&#47;不在 即在右边无序空间 再来执行循环<br>                left = mid+1;<br>            }<br>        }<br>        return -1;<br>    }<br>```","like_count":0},{"had_liked":false,"id":83689,"user_name":"立冬","can_delete":false,"product_type":"c1","uid":1467313,"ip_address":"","ucode":"287FA88D933FD5","user_header":"https://static001.geekbang.org/account/avatar/00/16/63/b1/a6103703.jpg","comment_is_top":false,"comment_ctime":1554701433,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554701433","product_id":100017301,"comment_content":"先比较在循环的边界确定low 和hight","like_count":0},{"had_liked":false,"id":83315,"user_name":"盘尼西林","can_delete":false,"product_type":"c1","uid":1197347,"ip_address":"","ucode":"B59569FC25144F","user_header":"https://static001.geekbang.org/account/avatar/00/12/45/23/28311447.jpg","comment_is_top":false,"comment_ctime":1554531278,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554531278","product_id":100017301,"comment_content":"分界点的所有前面的数 都大于分界点之后的所有数据，通过比较 v 与 arr[0], arr[len-1] 的大小重新选择 begin， 和 end","like_count":0},{"had_liked":false,"id":78076,"user_name":"柯西不等式","can_delete":false,"product_type":"c1","uid":1271425,"ip_address":"","ucode":"D6933CCABF6C5C","user_header":"https://static001.geekbang.org/account/avatar/00/13/66/81/8ff2006b.jpg","comment_is_top":false,"comment_ctime":1553067430,"is_pvip":false,"replies":[{"id":"28478","content":"给我个反例吧","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1553072364,"ip_address":"","comment_id":78076,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553067430","product_id":100017301,"comment_content":"变体1总的第二种实现，如果a[mid-2]==value呢？只判断a[mid]-1好像有点问题吧","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443959,"discussion_content":"给我个反例吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553072364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78036,"user_name":"等待戈多","can_delete":false,"product_type":"c1","uid":1445564,"ip_address":"","ucode":"80092A3352F9AA","user_header":"https://static001.geekbang.org/account/avatar/00/16/0e/bc/97606317.jpg","comment_is_top":false,"comment_ctime":1553059939,"is_pvip":false,"replies":[{"id":"28522","content":"你自己找个测试用例，debug一下看下，应该没错的。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1553133982,"ip_address":"","comment_id":78036,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553059939","product_id":100017301,"comment_content":" 老师，我感觉后面那两个代码有问题。我今天复习，自己敲了一遍，看到了老师那里<br>   if((mid==array.length-1)||array[mid+1]&gt;=key)    if判断那里，第二个判断条件 少了个等号","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443943,"discussion_content":"你自己找个测试用例，debug一下看下，应该没错的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553133982,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77065,"user_name":"乐凡","can_delete":false,"product_type":"c1","uid":1239260,"ip_address":"","ucode":"918C9997EB6537","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/dc/32e78f02.jpg","comment_is_top":false,"comment_ctime":1552823792,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552823792","product_id":100017301,"comment_content":"对于思考题，该数组可能有多个有序数组，可能有多个数组中的值等于给定值，我的实现思路是，对每一个有序数组都进行一次二分查找，查到的话就把该值对应的下标放到List数组中，结束后返回list，list中包含了所有等于给定值的下标。下面是实现，public static List&lt;Integer&gt; bSearch5(int[] a,int n,int value){<br>        List&lt;Integer&gt; resultList = new ArrayList&lt;&gt;();<br>        int low = 0;<br>        int high = fingHigh(a,low ,n );<br><br>        while (high &lt;= n - 1){<br>            int index = high;<br>            while (low &lt;= high){<br>                int middle = low + ((high - low) &gt;&gt; 1);<br>                if(a[middle] &gt; value){<br>                    high = middle - 1;<br>                }else if(a[middle] &lt; value){<br>                    low = middle + 1;<br>                }else{<br>                    resultList.add(middle);<br>                    break;<br>                }<br>            }<br>            if(high == n - 1)break;<br>            low = index + 1;<br>            high = fingHigh(a, low, n);<br>        }<br>        return resultList;<br><br>    }<br>    public static int fingHigh(int[] a,int low,int n){<br>        for (int i = low; i &lt; n - 1; i++) {<br>            if(a[i] &gt; a[i + 1]){<br>                return i;<br>            }<br>        }<br>        return n - 1;<br>    }","like_count":0},{"had_liked":false,"id":76322,"user_name":"康斯坦丁","can_delete":false,"product_type":"c1","uid":1368096,"ip_address":"","ucode":"C130E800E8D5C9","user_header":"https://static001.geekbang.org/account/avatar/00/14/e0/20/003190c1.jpg","comment_is_top":false,"comment_ctime":1552572594,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552572594","product_id":100017301,"comment_content":"每次判断mid 大于指定值，时判断start是否小于指定值，如果不是小于，表示在右边区域.<br>mid 小于指定值时，同理.<br>else if (list.get(mid).compareTo(target) &gt; 0) {<br>                if(mode.equals(Mode.CYCLE) &amp;&amp; list.get(start).compareTo(target) &gt;0){<br>                        start = mid + 1;<br>                }else {<br>                    end = mid - 1;<br>                }<br>            }else {<br>                if(mode.equals(Mode.CYCLE) &amp;&amp; list.get(end).compareTo(target) &lt;0){<br>                    end = mid - 1;<br>                }else {<br>                    start = mid + 1;<br>                }<br>            }","like_count":0},{"had_liked":false,"id":73677,"user_name":"好人","can_delete":false,"product_type":"c1","uid":1439552,"ip_address":"","ucode":"8BA995A57F7E1A","user_header":"https://static001.geekbang.org/account/avatar/00/15/f7/40/cba812dc.jpg","comment_is_top":false,"comment_ctime":1551956238,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551956238","product_id":100017301,"comment_content":"为什么你们会去用加偏移量，这样还不是先要去遍历一遍，不如直接for循环查找。","like_count":0},{"had_liked":false,"id":72730,"user_name":"duang_duang","can_delete":false,"product_type":"c1","uid":1392130,"ip_address":"","ucode":"77AE4ADD4BF3F3","user_header":"https://static001.geekbang.org/account/avatar/00/15/3e/02/45e25bab.jpg","comment_is_top":false,"comment_ctime":1551706721,"is_pvip":false,"replies":[{"id":"26805","content":"写起来更容易出bug的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551925907,"ip_address":"","comment_id":72730,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551706721","product_id":100017301,"comment_content":"请教一个问题，关于第一第二两个变种，在循环中查找到第一个与值相等的值时，直接返回当前下标，然后break；若是第一变种则从当前下标向low进行遍历，取出不再相等的上一个值的下标；第二种则向high遍历。这样的话在大多数场景中是否效率更高呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441714,"discussion_content":"写起来更容易出bug的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551925907,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72336,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1551589922,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551589922","product_id":100017301,"comment_content":"思考题找到分界点是解决问题的关键","like_count":0},{"had_liked":false,"id":71186,"user_name":"操盘手爱德华","can_delete":false,"product_type":"c1","uid":1366402,"ip_address":"","ucode":"CAAF3E6DC9D5FD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIFicK7Bn88Lqte7rURlw3Lf53oAu1jhiciaVlKLib48dlIAOAF03L7tjQcx1ia5AJI26S7HIxwx780Qzw/132","comment_is_top":false,"comment_ctime":1551279162,"is_pvip":false,"replies":[{"id":"25514","content":"不会的，你可以举个反例给我。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551318333,"ip_address":"","comment_id":71186,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551279162","product_id":100017301,"comment_content":"if (a[mid] &gt;= value) {<br>      high = mid - 1; &#47;&#47;要是a[mid]正好是大于等于value的第一个数，不就完美错过了么。<br>}","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441034,"discussion_content":"不会的，你可以举个反例给我。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551318333,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71180,"user_name":"操盘手爱德华","can_delete":false,"product_type":"c1","uid":1366402,"ip_address":"","ucode":"CAAF3E6DC9D5FD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIFicK7Bn88Lqte7rURlw3Lf53oAu1jhiciaVlKLib48dlIAOAF03L7tjQcx1ia5AJI26S7HIxwx780Qzw/132","comment_is_top":false,"comment_ctime":1551278593,"is_pvip":false,"replies":[{"id":"25515","content":"举个引起bug的反例给我吧","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551318367,"ip_address":"","comment_id":71180,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551278593","product_id":100017301,"comment_content":"那个烧脑的第一种写法明显有bug。实现的有问题。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441030,"discussion_content":"举个引起bug的反例给我吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551318367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":68893,"user_name":"黑白尤文","can_delete":false,"product_type":"c1","uid":1152644,"ip_address":"","ucode":"95B9F73AA0F20D","user_header":"https://static001.geekbang.org/account/avatar/00/11/96/84/d4ba322f.jpg","comment_is_top":false,"comment_ctime":1550626427,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550626427","product_id":100017301,"comment_content":"这题用字典树来实现，应该会更简单一点","like_count":0},{"had_liked":false,"id":66613,"user_name":"可妮","can_delete":false,"product_type":"c1","uid":1007885,"ip_address":"","ucode":"6F08A7F700EABE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKibr46Zzwgtl6TQweY6ibtjNyn5t6C4QLjq3EnvRJI73WwjBYoscmicYIRMTcb5Ef67usdlcVlQ8yjQ/132","comment_is_top":false,"comment_ctime":1549967003,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549967003","product_id":100017301,"comment_content":" 1.定义三个指针low, mid, high, 如果首元素小于 mid，说明前半部分[low,...,mid]是有序的；<br> 证明下这种情况：假设数组旋转后的组成为array=[A1，B1]，A1和B1分别递增<br> 可能存在三种情况：<br>[low,...., mid] 区间中只包含A1 的元素，此时这个区间是递增有序的<br>[low,...., mid] 区间中只包含B1 的元素， 此时也是递增有序的<br>[low,...., mid] 区间中包含一部分A1 和一部分B1，此时不可能出现array[low] &lt; array[mid], 因为A1 中的元素一定大于B1中的元素。<br>所以当array[low] &lt; array[mid] array[low,....,mid]一定是有序的<br>","like_count":0},{"had_liked":false,"id":65866,"user_name":"景页","can_delete":false,"product_type":"c1","uid":1188798,"ip_address":"","ucode":"DC9C2AD52A9E4A","user_header":"https://static001.geekbang.org/account/avatar/00/12/23/be/9a083ea1.jpg","comment_is_top":false,"comment_ctime":1549707610,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549707610","product_id":100017301,"comment_content":"置顶的Smallfly回答中第三种方法中“首元素大于mid”改为“首元素大于等于mid”，在有重复元素的情况下，例如“345612333”。","like_count":0},{"had_liked":false,"id":65698,"user_name":"吴昊","can_delete":false,"product_type":"c1","uid":1248635,"ip_address":"","ucode":"CB4F6A46930873","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/7b/e574577a.jpg","comment_is_top":false,"comment_ctime":1549594848,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549594848","product_id":100017301,"comment_content":"简洁烧脑的算法有一个好处，既能实现查找第一个等于value的元素，也能实现查找第一个大于等于value的元素。因为while循环终止时，high指向第一个小于value的元素，而low=high+1,所以low指向的元素必定大于或者等于value。","like_count":0},{"had_liked":false,"id":64407,"user_name":"极客","can_delete":false,"product_type":"c1","uid":1247176,"ip_address":"","ucode":"4906AB51EDFF3A","user_header":"https://static001.geekbang.org/account/avatar/00/13/07/c8/d4f39f8d.jpg","comment_is_top":false,"comment_ctime":1548770492,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548770492","product_id":100017301,"comment_content":"自己实现了下，您的代码很优雅，思路清晰","like_count":0},{"had_liked":false,"id":63823,"user_name":"1024","can_delete":false,"product_type":"c1","uid":1086407,"ip_address":"","ucode":"DCC31F6EC54F43","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/c7/86352ccc.jpg","comment_is_top":false,"comment_ctime":1548518759,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548518759","product_id":100017301,"comment_content":"思考题思路：<br>通过本节学的二分查找变形问题的解决思路，将思考题转化为简单情况的二分查找的问题，然后再进行二分查找，找到目标值下标(前提：循环有序数组，每一个有序部分没有重复元素）<br><br>例如，<br>数组：4，5，6，1，2，3<br>要查找的值为2<br>1.找到第一个小于2的下标start=3<br>2.找到最后一个大于2的下标end=5<br>3.start和end之间一定为有序的数组，然后再进行二分查找<br>时间复杂度O(3n)","like_count":0},{"had_liked":false,"id":63806,"user_name":"燃点丶","can_delete":false,"product_type":"c1","uid":1106277,"ip_address":"","ucode":"01E91FB4287535","user_header":"https://static001.geekbang.org/account/avatar/00/10/e1/65/0dd1abf7.jpg","comment_is_top":false,"comment_ctime":1548513103,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548513103","product_id":100017301,"comment_content":"老师帮我看下最后的思考题 <br>public int search(int[] nums, int target) {<br>        if (nums.length==0) return -1;<br>        int left=0;<br>        int right=nums.length-1;<br>        int middle=0;<br>        while (left&lt;=right){<br>            middle=(left+right)&gt;&gt;1;<br>            if (nums[middle]==target) return middle;<br>            if (nums[middle]&gt;nums[right]){<br>                left=middle+1;<br>            }<br>            if (nums[middle]&lt;nums[right]){<br>                right=middle-1;<br>            }<br>        }<br>        return -1;<br>    }<br>","like_count":0},{"had_liked":false,"id":60823,"user_name":"泉","can_delete":false,"product_type":"c1","uid":1099760,"ip_address":"","ucode":"914709BE802A8D","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/f0/aa2e0749.jpg","comment_is_top":false,"comment_ctime":1547558353,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1547558353","product_id":100017301,"comment_content":"二人应用场景:查找第一个等于给定值，查找最后一个等于给定值，查找大于等于给定值，查找小于等于给定值。","like_count":0},{"had_liked":false,"id":60524,"user_name":"LQS  KF","can_delete":false,"product_type":"c1","uid":1364737,"ip_address":"","ucode":"3C0A07A8220094","user_header":"https://static001.geekbang.org/account/avatar/00/14/d3/01/716d45b6.jpg","comment_is_top":false,"comment_ctime":1547485240,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547485240","product_id":100017301,"comment_content":"思考题java代码实现，github地址:https:&#47;&#47;github.com&#47;zzhujing&#47;java-algo<br>欢迎大家star，有以前所有的java实现<br><br>    &#47;&#47;从循环数组中查找对应value的索引位置<br>    private static int getIndexFromCycleArray(int[] source, int low, int height, int value) {<br>        while (low &lt;= height) {<br>            int mid = low + (height - low) &#47; 2;<br>            if (source[mid] &gt; source[low]) {<br>                if (source[mid] &gt; value &amp;&amp; source[low] &lt; value) {<br>                    &#47;&#47;二分查找<br>                    return binarySearchFirst1(source, low, mid, value);<br>                } else if (source[mid] &lt; value || source[low] &gt; value) {<br>                    low = mid + 1;<br>                } else {<br>                    return source[mid] == value ? mid : low;<br>                }<br>            } else {<br>                if (source[mid] &lt; value &amp;&amp; value &lt; source[height]) {<br>                    &#47;&#47;二分查找<br>                    return binarySearchFirst1(source, mid, height, value);<br>                } else if (source[mid] &gt; value || value &gt; source[height]) {<br>                    height = mid - 1;<br>                } else {<br>                    return source[mid] == value ? mid : height;<br>                }<br>            }<br>        }<br>        return -1;<br>    }","like_count":0},{"had_liked":false,"id":58982,"user_name":"不做键盘侠","can_delete":false,"product_type":"c1","uid":1154451,"ip_address":"","ucode":"30C123DCB9696C","user_header":"https://static001.geekbang.org/account/avatar/00/11/9d/93/945393c1.jpg","comment_is_top":false,"comment_ctime":1547264758,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547264758","product_id":100017301,"comment_content":"老师，问两个问题。1、网上有很多用左闭右开区间写法，用左闭右开似乎更有优势？<br>2、这种mid-1或者mid+1的写法有可能越界吧?如何处理这一问题呢？","like_count":0},{"had_liked":false,"id":57887,"user_name":"Yeir","can_delete":false,"product_type":"c1","uid":1072999,"ip_address":"","ucode":"3A325B919C66B9","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/67/8552dab9.jpg","comment_is_top":false,"comment_ctime":1546935596,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546935596","product_id":100017301,"comment_content":"思考题的算法golang实现. 对应letcode33题<br>func search(nums []int, target int) int {<br>    low := 0<br>\thigh := len(nums) - 1<br>\tindex := -1<br>\tfor low &lt;= high {<br>\t\t&#47;&#47;fmt.Println(nums[low : high+1])<br>\t\t&#47;&#47;先计算二分查找的中间数<br>\t\tmedian := low + (high-low)&#47;2<br>\t\tif nums[median] == target {<br>\t\t\tindex = median<br>\t\t\tbreak<br>\t\t}<br><br>\t\t&#47;&#47; 当median左边区间第一个元素low小于median, 假设左边区间存在一个大于median的数, 那么数组即存在[小小..大..小(median)..]这样的结构, 此时不可能是循环数组了.<br>\t\t&#47;&#47; 因此当low小于median时, 说明median左边的元素都小于median<br>\t\t&#47;&#47;<br>\t\t&#47;&#47; 当low等于median时, 则说明数组只剩下2个元素了.[大, 小] 或者 [小, 大].<br>\t\tif nums[low] &lt;= nums[median] {<br>\t\t\t&#47;&#47; 这里注意, 虽然median左边的元素都比median小, 但是不一定都比target小. 比如 4567012,寻找2时,456都比7小,但是却比2大. 因此需要确保target比median小的同时比low大<br>\t\t\tif nums[low] &lt;= target &amp;&amp; target &lt;= nums[median] {<br>\t\t\t\thigh = median - 1<br>\t\t\t} else {<br>\t\t\t\tlow = median + 1<br>\t\t\t}<br>\t\t} else { &#47;&#47; 同理, 当low大于median时, 假设右边区间存在一个小于median的数, 则数组存在[大..小(median)..小小..]这样的结构, 此时也不可能是循环数组了. 因此当low大于median时, 说明右边区间的元素都大于median<br><br>\t\t\t&#47;&#47; 这里同样需要注意, 虽然右边区间的元素比median大, 但是不一定都比target大. 比如6701234,寻找7时, 234都比1大, 但是却比7小. 因此需要确保target比median大的同时比high小<br>\t\t\tif nums[median] &lt;= target &amp;&amp; target &lt;= nums[high] {<br>\t\t\t\tlow = median + 1<br>\t\t\t} else {<br>\t\t\t\thigh = median - 1<br>\t\t\t}<br>\t\t}<br>\t}<br><br>\treturn index<br>}","like_count":0},{"had_liked":false,"id":55077,"user_name":"CathyLin","can_delete":false,"product_type":"c1","uid":1240546,"ip_address":"","ucode":"F7CDFF5E1A235F","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/e2/0e1c6c5a.jpg","comment_is_top":false,"comment_ctime":1546032886,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546032886","product_id":100017301,"comment_content":"思考题：求循环有序数组的“值等于给定值”的二分查找算法。<br>首先，先找出分界线，也就是说比如一个数组是递增然后递减的，那么就找出它们之间的分界线下标。然后令 left 等于分界线右边的下标，right 为分界线左边的下标。然后就可以求 mid 了。<br>但是求 mid 有以下几种情况：<br>1）left &lt;= right，那么 mid 直接等于 (left + right) &#47;2 就可以了。<br>2) left &gt; right，那么 mid 等于 (left + n + right) &#47;2 <br><br>然后更新 left 和 right 和循环链表差不多。<br>left = (mid+1) % n，right = (mid + 1) % n","like_count":0},{"had_liked":false,"id":54315,"user_name":"哈哈哈","can_delete":false,"product_type":"c1","uid":1252658,"ip_address":"","ucode":"D2DE2E3B42B56A","user_header":"https://static001.geekbang.org/account/avatar/00/13/1d/32/5bc92086.jpg","comment_is_top":false,"comment_ctime":1545826860,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545826860","product_id":100017301,"comment_content":"低分查找首个指定元素的下标if ((mid == 0) || (a[mid - 1] != value)) return mid;<br>这个条件应该也可以换为if ((mid == low) || (a[mid - 1] != value)) return mid;<br>","like_count":0},{"had_liked":false,"id":54253,"user_name":"Kane_Zhang","can_delete":false,"product_type":"c1","uid":1255430,"ip_address":"","ucode":"633396597246C5","user_header":"https://static001.geekbang.org/account/avatar/00/13/28/06/62ca6fa4.jpg","comment_is_top":false,"comment_ctime":1545815745,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1545815745","product_id":100017301,"comment_content":"python:<br>class Solution:<br>    def binary_search(self, nums, low, high, target):<br>        while low &lt;= high:<br>            mid = low + ((high - low) &gt;&gt; 1)<br>            if target &gt; nums[mid]:<br>                low = mid + 1<br>            elif target &lt; nums[mid]:<br>                high = mid - 1<br>            else:<br>                return mid<br><br>        return -1<br><br>    def search(self, nums, target):<br>        &quot;&quot;&quot;<br>        :type nums: List[int]<br>        :type target: int<br>        :rtype: int<br>        &quot;&quot;&quot;<br>        if not nums:<br>            return -1<br><br>        low, high = 0, len(nums) - 1<br>        while low &lt;= high:<br>            mid = low + ((high - low) &gt;&gt; 1)<br>            if nums[low] &lt;= nums[mid]:<br>                index = self.binary_search(nums, low, mid, target)<br>                if index != -1:<br>                    return index<br>                else:<br>                    low = mid + 1<br>            else:<br>                index = self.binary_search(nums, mid, high, target)<br>                if index != -1:<br>                    return index<br>                else:<br>                    high = mid - 1<br><br>        return -1","like_count":0},{"had_liked":false,"id":51873,"user_name":"左胜利","can_delete":false,"product_type":"c1","uid":1327195,"ip_address":"","ucode":"E17B4F4285170D","user_header":"https://static001.geekbang.org/account/avatar/00/14/40/5b/3fe51d4a.jpg","comment_is_top":false,"comment_ctime":1545272595,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545272595","product_id":100017301,"comment_content":"对于思考题：<br>1、首先使用二分查找获取第一个小于等于数组最后一个元素的元素的位置<br>2、对两部分有序数组分别使用二分查找<br>","like_count":0},{"had_liked":false,"id":51114,"user_name":"aguan(^･ｪ･^)","can_delete":false,"product_type":"c1","uid":1107177,"ip_address":"","ucode":"04833EF2D18E1A","user_header":"https://static001.geekbang.org/account/avatar/00/10/e4/e9/0dd3829f.jpg","comment_is_top":false,"comment_ctime":1545116614,"is_pvip":false,"replies":[{"id":"18560","content":"👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545185185,"ip_address":"","comment_id":51114,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545116614","product_id":100017301,"comment_content":"思考题，在leetcode上练习验证通过了，本着实现算法的思想，写了一大段复杂的代码<br> public static int binaryCycleSearch(int[] nums,int target) {<br>        &#47;&#47;二分法将数组分成两部分，要区分出哪部分是有序的<br>        &#47;&#47;当nums[mid] &gt; nums[mid-1] 时，前半部分有序<br>        &#47;&#47;当nums[mid] &lt; nums[mid + 1]时，后半部分有序<br>        int low = 0;<br>        int high = nums.length - 1;<br>        while (high&gt;=low) {<br><br>            int mid = low + ((high-low) &gt;&gt; 1);<br>            if(nums[mid] == target) {<br>                return mid;<br>            }<br>            if(high == low) {<br>                return -1;<br>            }<br>            if(mid == 0) {<br>                low = low = mid + 1;<br>                continue;<br>            } else if(mid == high) {<br>                high = mid -1;<br>                continue;<br>            }<br>            if(nums[mid] &gt;=nums[low]) {<br>                &#47;&#47;target落在前半部分有序队列中<br>                if(nums[mid] &gt; target &amp;&amp; (nums[mid-1] &gt;= target &amp;&amp; nums[low] &lt;= target)) {<br>                    high = mid - 1;<br>                }<br>                &#47;&#47;target未落在有序队列中（后半部分）<br>                else {<br>                    low = mid + 1;<br>                }<br>            } else if(nums[mid] &lt; nums[high] ){<br>                &#47;&#47;target落在后半部分有序队列中<br>                if(nums[mid] &lt; target &amp;&amp; (nums[high] &gt;=target &amp;&amp; nums[mid+1] &lt;= target)) {<br>                    low = mid + 1;<br>                } else {<br>                    high = mid - 1;<br>                }<br>            }<br><br>        }<br><br>        return -1;<br><br>    }","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433293,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545185185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50932,"user_name":"cw","can_delete":false,"product_type":"c1","uid":1264296,"ip_address":"","ucode":"82A6B50462F9F9","user_header":"https://static001.geekbang.org/account/avatar/00/13/4a/a8/b7e36dd2.jpg","comment_is_top":false,"comment_ctime":1545089579,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545089579","product_id":100017301,"comment_content":"循环有序数组的话，可以先找到循环点 a(n)&gt;a(n+1)","like_count":0},{"had_liked":false,"id":50069,"user_name":"匆匆","can_delete":false,"product_type":"c1","uid":1333414,"ip_address":"","ucode":"4DB39C6CD5743B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/H8NxrljQXliccaT5fjdXJQYS3ou3Z9ykAuKw6EgicicEA9L4jQLz3h85P0odgDSaK0cA9oTyUKibbiagdNvnHuuV5mQ/132","comment_is_top":false,"comment_ctime":1544858826,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544858826","product_id":100017301,"comment_content":"十个二分九个错。<br><br>最简单的二分查找很好写，但是一般用到的都是二分查找的变体，所以写正确的二分查找并不容易。本节给了四种二分查找的变体（查找第一个（最后一个）值等于给定值的元素；查找第一个（最后一个）大于给定值的元素）；","like_count":0},{"had_liked":false,"id":49878,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1544783893,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544783893","product_id":100017301,"comment_content":"变体3与变体4的代码如下：<br>&#47;**<br>     * 查找第一个大于等于给定值的元素<br>     *<br>     * @param arr    目标数组<br>     * @param target 查找的数字<br>     * @return<br>     *&#47;<br>    public static int search(int[] arr, int target) {<br>        int low = 0;<br>        int high = arr.length - 1;<br>        while (low &lt;= high) {<br>            int mid = low + (high - low) &#47; 2;<br>            if (arr[mid] &gt;= target) {<br>                &#47;&#47;new int[]{3, 4, 6, 7, 10, 11, 12}<br>                &#47;&#47;如果当前mid的前一个元素还大于所查找的值，那么查找的区间就在low~mid-1之间<br>                if ((mid != 0) &amp;&amp; (arr[mid - 1] &gt;= target)) {<br>                    high = mid - 1;<br>                } else {<br>                    return mid;<br>                }<br><br>            } else if (arr[mid] &lt; target) {<br>                low = mid + 1;<br>            }<br>        }<br>        return -1;<br>    }<br><br>  &#47;**<br>     * 变体四：查找最后一个小于等于给定值的元素<br>     *<br>     * @param arr    目标数组<br>     * @param target 查找的数字<br>     * @return<br>     *&#47;<br>    public static int search(int[] arr, int target) {<br>        int low = 0;<br>        int high = arr.length - 1;<br>        while (low &lt;= high) {<br>            int mid = low + (high - low) &#47; 2;<br>            if (arr[mid] &gt; target) {<br>                high = mid - 1;<br>            } else if (arr[mid] &lt;= target) {<br>                &#47;&#47;new int[]{3，5，6，8，9，10} 查找7<br>                &#47;&#47;如果mid的后一个元素还比查找的元素小，那么查找的范围在mid+1~high<br>                if ((mid != 0) &amp;&amp; (arr[mid + 1] &lt;= target)) {<br>                    low = mid + 1;<br>                } else {<br>                    return mid;<br>                }<br>            }<br>        }<br>        return -1;<br>    }<br>","like_count":0},{"had_liked":false,"id":49866,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1544782005,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544782005","product_id":100017301,"comment_content":"变体2的思路跟变体1的思路一样，只是把低位换成mid+1，很好理解 <br>&#47;**<br>     * 查找最后一个值等于给定值的元素<br>     *<br>     * @param arr<br>     * @param target<br>     * @return<br>     *&#47;<br>    public static int simpleSearch(int[] arr, int target) {<br>        int low = 0;<br>        int high = arr.length - 1;<br>        while (low &lt;= high) {<br>            int mid = low + (high - low) &#47; 2;<br>            if (arr[mid] &gt; target) {<br>                high = mid - 1;<br>            } else if (arr[mid] &lt; target) {<br>                low = mid + 1;<br>            } else {<br>                &#47;&#47;当mid不等于0，并且发现mid前面一个元素居然等于你要查找的元素，那么你要查找的第一个元素肯定出现在[low...mid-1]之间<br>                &#47;&#47;new int[]{1, 3, 4, 5, 6, 8, 8, 8, 8, 18}<br>                &#47;&#47;以上面数组为例子，要查找的元素是8，第一次我们查到了mid=7也等于8。<br>                &#47;&#47;这时候我们发现7不等于0，并且，索引8的元素居然也等于8。所以此时的mid=7不是我们要的索引位置<br>                &#47;&#47;所以要查找的元素在7~9之间的索引<br>                if ((mid != 0) &amp;&amp; arr[mid + 1] == target) {<br>                    low = mid + 1;<br>                } else {<br>                    return mid;<br>                }<br>            }<br>        }<br>        return -1;<br>    }","like_count":0},{"had_liked":false,"id":49857,"user_name":"luo","can_delete":false,"product_type":"c1","uid":1148742,"ip_address":"","ucode":"00FBDC12101419","user_header":"https://static001.geekbang.org/account/avatar/00/11/87/46/2850b4a9.jpg","comment_is_top":false,"comment_ctime":1544780396,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544780396","product_id":100017301,"comment_content":"   &#47;**<br>     * 在一个循环有序数组中用二分查找法找到对应的相等的值<br>     * @param a  数组<br>     * @param  lowInd 分界点<br>     * @param sv 寻找的值<br>     *  比如 4,5,6,1,2,3 分界点在<br>     *   一种是统一思想  low&lt;=hight 变更为 (low+cap-lowInd)%cap&lt;=(hight+cap-lowInd)%cap 用补偿的方式这样高阶还是高阶 低阶还是低阶<br>     *   mid = ((hight+cap - low)%cap&gt;&gt;1) + low; 这里先求高低数据的相差几个 再加上低阶的索引 求出中间值<br>     *   low = (mid+1)%cap; 防止低阶溢出<br>     *   hight = (mid+cap - 1)%cap; 防止高阶溢出<br>     *&#47;<br>    public int searchCircleArray(int[] a,int lowInd,int sv){<br>         if(a.length&lt;1){<br>            return -1;<br>        }<br>        int low = lowInd;<br>        int hight = lowInd -1;<br>        int cap = a.length;<br>        int mid = 0;<br>        while ((low+cap-lowInd)%cap&lt;=(hight+cap-lowInd)%cap){<br>            mid = ((hight+cap - low)%cap&gt;&gt;1) + low;<br>            if(a[mid]==sv){<br>                return mid;<br>            }else if(a[mid]&lt;sv){<br>                low = (mid+1)%cap;<br>            }else{<br>                hight = (mid+cap - 1)%cap;<br>            }<br>        }<br>        return -1;<br>    }<br><br>想了好久发现以后不能这么干，效率太低，老师同学帮忙瞅瞅是不是存在问题的","like_count":0},{"had_liked":false,"id":49816,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1544775452,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544775452","product_id":100017301,"comment_content":"老师，我把变体1的代码改了，并且使用了递归实现，你看下，这样感觉更好理解<br> &#47;**<br>     * 简单版本<br>     *<br>     * @param arr<br>     * @param target<br>     * @return<br>     *&#47;<br>    public static int simpleSearch(int[] arr, int target) {<br>        int low = 0;<br>        int high = arr.length - 1;<br>        while (low &lt;= high) {<br>            int mid = low + (high - low) &#47; 2;<br>            if (arr[mid] &gt; target) {<br>                high = mid - 1;<br>            } else if (arr[mid] &lt; target) {<br>                low = mid + 1;<br>            } else {<br>                &#47;&#47;当mid不等于0，并且发现mid前面一个元素居然等于你要查找的元素，那么你要查找的第一个元素肯定出现在[low...mid-1]之间<br>                &#47;&#47;new int[]{1, 3, 4, 5, 6, 8, 8, 8, 11, 18}<br>                &#47;&#47;以上面数组为例子，要查找的元素是8，第一次我们查到了mid=7也等于8。<br>                &#47;&#47;这时候我们发现7不等于0，并且，索引6的元素居然也等于8。所以此时的mid=7不是我们要的索引位置<br>                &#47;&#47;所以要查找的元素在5~6之间的索引<br>                if ((mid != 0) &amp;&amp; arr[mid - 1] == target) {<br>                    high = mid - 1;<br>                } else {<br>                    return mid;<br>                }<br>            }<br>        }<br>        return -1;<br>    }<br><br>    public static int recursionSearch(int[] arr, int l, int r, int x) {<br>        if (l &gt; r) {return -1;}<br>        int mid = l + (r - l) &#47; 2;<br>        if (arr[mid] &gt; x) {<br>            r = mid - 1;<br>            return recursionSearch(arr, l, r, x);<br>        } else if (arr[mid] &lt; x) {<br>            l = mid + 1;<br>            return recursionSearch(arr, l, r, x);<br>        } else {<br>            if ((mid != 0) &amp;&amp; (arr[mid - 1] == x)) {<br>                r = mid - 1;<br>                return recursionSearch(arr, l, r, x);<br>            } else {<br>                return mid;<br>            }<br>        }<br>    }","like_count":0},{"had_liked":false,"id":48902,"user_name":"Ace","can_delete":false,"product_type":"c1","uid":1010490,"ip_address":"","ucode":"D3B779A0E8264E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/3a/38de3fc4.jpg","comment_is_top":false,"comment_ctime":1544577163,"is_pvip":false,"replies":[{"id":"17734","content":"就是求high和low的中间值 不会比high大的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1544666748,"ip_address":"","comment_id":48902,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1544577163","product_id":100017301,"comment_content":"int mid = low + ((high - low) &gt;&gt; 1);<br>老师，请问这一行怎么理解，mid通过这样一算不是比最大值(high)还大了么","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":432410,"discussion_content":"就是求high和low的中间值 不会比high大的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544666748,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1810576,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","nickname":"M","note":"","ucode":"06F26E1D62E9C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":193245,"discussion_content":"(20+80)/2=50;\n20+((80-20)/2)=50","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583140379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":48715,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1544520928,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544520928","product_id":100017301,"comment_content":"二分查找的变形问题，出现了重复的数据，之前是不会有重复数据这种情况<br>主要是多了一个终止条件的判定：第一个问题解决了，觉得后面的问题都解决了<br><br>1、查找第一个值等于给定值的元素，找到这个值，的边上的元素<br>2、查找最后一个等于给定值的元素，找到这个值，<br>3、查找第一个大于等于给定值的元素<br>4、查找最后一个小于等于给定值的元素<br><br>一般能用散列表和二叉树解决的就用这两种方式，而不是二分查找，即便前两个更耗内存<br>二分查找跟适合与近似查找<br>写二分查找的容易出错的细节，终止条件，区间上下界更新方法，返回值选择<br><br>思考题：思考题又不会了，要吗就直接将数组先还原成有序数组，即找到分割点在进行下一步操作","like_count":0},{"had_liked":false,"id":48636,"user_name":"Geek_41dcba","can_delete":false,"product_type":"c1","uid":1089626,"ip_address":"","ucode":"22F9180FBD74F5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/wjK0unDiaUMZYGsl43dovmLWZS6WvDzpespydKfOQHDU55QPZQZvfKKYk4ZaITibGc3wwC3vqTTudWficcPhEia0Xw/132","comment_is_top":false,"comment_ctime":1544502887,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1544502887","product_id":100017301,"comment_content":"对于思考题中对有序但循环的数组进行二分定位<br><br>&#47;&#47;如果是一个循环数组，实现的一个思路可以是先定位到这个循环的开始点和结束点，然后再进行二分查找<br>&#47;&#47;如何定位开始点<br>&#47;&#47;可以是顺序比较，时间复杂度为O(n)----最终时间复杂度为O(n+logn)<br>&#47;&#47;可以基于二分查找的思路，找到最小值，也就是循环的开始点----最终时间复杂度为O(logn + logn)<br><br>根据查找最小值的方式将二分查找变形为查找最接近目标值的处理。假设循环数组是递增的方式<br>1. 首先设定最接近的目标值为n&#47;2的值，将这个接近的值称为近值。最左边为左边值，最后边为右边值<br>2.判断目标值所在的区域<br>      比较近值与目标值<br>           如果目标值小于近值<br>                  如果进值的左边小于近值就将近值的左边目标查找区域<br>                  否则处理直接结算，结果为未找到<br>           如果目标值大于近值且大于右边值就将近值的左边目标查找区域<br>           其他情况以近值的右边作为目标查找区域<br>      将新定位的区间替换老的查询区间<br>3.循环处理第二步，循环条件为(左边值索引 + 1 != 右边值索引)<br>       直到找到近值等于目标值，目标找到，处理结束<br>       &#47;&#47;目标区间大小为最小区间个数2(左边值索引 + 1 != 右边值索引)，且里面都没有找到目标值，没有找到，处理结束<br>时间复杂度为O(logn)<br><br>老师你看这个是否可行，或者是否遗漏了某些情况！！<br>    <br>","like_count":0},{"had_liked":false,"id":45718,"user_name":"lttzzlll","can_delete":false,"product_type":"c1","uid":1105387,"ip_address":"","ucode":"FA160F7C02ABAA","user_header":"https://static001.geekbang.org/account/avatar/00/10/dd/eb/80f9d212.jpg","comment_is_top":false,"comment_ctime":1543758535,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543758535","product_id":100017301,"comment_content":"针对课后问题，例如 4，5，6，1，2，3。<br><br>首先要找到 这个数组的 分界点称为 pivot， 比如 上述数组中的 6 的下表 2 或者 1 的下表 3， 都可以。<br><br>然后 针对 要查找的值 value，与 arr[low], arr[pivot - 1] arr[pivot], arr[high] 等比较后，<br>就能把区间缩小到 (low, pivot-1) 或者 (pivot, high)，所以 pivot是对原数组的一个划分，<br>将原问题 bsearch(arr, low, high, value) 分解为 bsearch(arr, low, pivot-1, value) , bsearch(arr, pivot, high, value).<br>时间复杂度不变。<br><br><br><br>1. 找到循环数组的最小位置<br>```python<br>def bsearch(arr):<br>    low, high = 0, len(arr) - 1<br>    while low &lt; high:<br>        mid = (low + high) &gt;&gt; 1<br>        if arr[low] &lt; arr[high]:<br>            break<br>        elif arr[mid] &gt; arr[high]:<br>            low = mid + 1<br>        else:<br>            high = mid<br>    return low<br>```<br><br><br>2. 循环数组的二分查找法<br>```python<br><br># 二分查找<br>def binarysearch(arr, low, high, value):<br>    while low &lt;= high:<br>        mid = (low + high) &gt;&gt; 1<br>        if arr[mid] &gt; value:<br>            high = mid - 1<br>        elif arr[mid] &lt; value:<br>            low = mid + 1<br>        else:<br>            return mid<br>    return -1<br><br># 查找循环数组中的指定值<br>def cyclesearch(arr, value):<br>    size = len(arr)<br>    pivot = bsearch(arr)<br>    if value &lt; arr[pivot]: return -1<br>    if value &gt; arr[(pivot - 1 + size) % size]: return -1<br>    if pivot &gt; 0 and value &gt;= arr[0]:<br>        return binarysearch(arr, 0, pivot - 1, value)<br>    else:<br>        return binarysearch(arr, pivot, size - 1, value)<br><br>```<br><br><br><br>","like_count":0},{"had_liked":false,"id":43473,"user_name":"origin","can_delete":false,"product_type":"c1","uid":1086653,"ip_address":"","ucode":"BEE45728683452","user_header":"https://static001.geekbang.org/account/avatar/00/10/94/bd/3b61c1c1.jpg","comment_is_top":false,"comment_ctime":1543230915,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543230915","product_id":100017301,"comment_content":"二分查找变体:<br>二分查找插入，旋转数组二分查找，查找第一个匹配数字","like_count":0},{"had_liked":false,"id":40829,"user_name":"明月几时有","can_delete":false,"product_type":"c1","uid":1140095,"ip_address":"","ucode":"09BD91B61ECBE1","user_header":"https://static001.geekbang.org/account/avatar/00/11/65/7f/5f759b5c.jpg","comment_is_top":false,"comment_ctime":1542679959,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542679959","product_id":100017301,"comment_content":"老师的方法确实很好理解，但我还是想请教下第一种的方法怎么理解的。是循环折半查找，逼近给定值，最后再比较是否与给定值相等吗？这样会不会效率不高，感觉做了些无用的操作。","like_count":0},{"had_liked":false,"id":38655,"user_name":"Z.","can_delete":false,"product_type":"c1","uid":1132616,"ip_address":"","ucode":"6BD310C42228FC","user_header":"https://static001.geekbang.org/account/avatar/00/11/48/48/5848524c.jpg","comment_is_top":false,"comment_ctime":1542097078,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542097078","product_id":100017301,"comment_content":"老师，我有遇到一种情况，例如一个投票的功能，已知作品的id 和获得的票数，要获取该作品的排名！我的做法是先获取排名的列表（每个元素包含作品id 和票数），然后用二分法查找到和该作品票数相同的位置，然后比较作品id ，如果没有命中，就先沿着当前向前比较，向前比较没有找到（比较到票数不相等的位置），就向后比较，直到找到！功能可以实现！就是想请教下，有没有更好的方法","like_count":0},{"had_liked":false,"id":37612,"user_name":"kakasi","can_delete":false,"product_type":"c1","uid":1237297,"ip_address":"","ucode":"64F357E6A08CA5","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/31/eb103bdc.jpg","comment_is_top":false,"comment_ctime":1541651381,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541651381","product_id":100017301,"comment_content":"二分查找应用场景: 适用于近似查找，如第一个≥给定值的元素，第一个≤给定值的元素，都是二分查找的变体。而一般情况下查找某个给定值，二叉查找树和散列表更适合。","like_count":0},{"had_liked":false,"id":36718,"user_name":"qinggeouye","can_delete":false,"product_type":"c1","uid":1251536,"ip_address":"","ucode":"5B53EEDD7BEC9C","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/d0/49b06424.jpg","comment_is_top":false,"comment_ctime":1541261201,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541261201","product_id":100017301,"comment_content":"关于开篇问题，顺着解题思路：<br>问题也可以转变为“在有序数组中，查找第一个大于等于某个给定值的元素”。<br>当要查询某个 IP 归属地时，可以先通过二分查找，找到第一个结束 IP 大于等于这个 IP 的 IP 区间；<br>然后检查这个 IP 是否在这个区间内；如果在，就取出对应的归属地显示；如果不在，就返回未查找到。<br>","like_count":0},{"had_liked":false,"id":36636,"user_name":"姜威","can_delete":false,"product_type":"c1","uid":1244051,"ip_address":"","ucode":"C58EB9A5AD634D","user_header":"https://static001.geekbang.org/account/avatar/00/12/fb/93/f19a5364.jpg","comment_is_top":false,"comment_ctime":1541210733,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541210733","product_id":100017301,"comment_content":"四、二分查找变形问题的代码实现<br>前提假设：以数据是从小到大排列为前提来实现<br>1.查找第一个值等于给定值的元素，比如在数组a[10]={1,3,4,5,6,8,8,8,11,18}<br>public int bSear1(int[] a, int val){<br>\tint start = 0;<br>\tint end = a.length - 1;<br>\tint mid = -1;<br>\twhile(start &lt;= end){<br>\t\tmid = start + (end - start) &#47; 2;<br>\t\tif (a[mid] &gt; val) {<br>\t\t\tend = mid - 1;<br>\t\t} else if (a[mid] &lt; val) {<br>\t\t\tstart = mid + 1;<br>\t\t} else {<br>\t\t\tif(mid == 0 || a[mid-1] &lt; val)\tbreak;<br>\t\t\telse end = mid - 1;<br>\t\t}<br>\t}<br>\treturn mid;<br>}<br>2.查找最后一个值等于给定值的元素，比如在数组a[10]={1,3,4,5,6,8,8,8,11,18}<br>public int bSear2(int[] a, int val){<br>\tint start = 0;<br>\tint end = a.length - 1;<br>\tint mid = -1;<br>\twhile(start &lt;= end){<br>\t\tmid = start + (end - start) &#47; 2;<br>\t\tif (a[mid] &gt; val) {<br>\t\t\tend = mid - 1;<br>\t\t} else if (a[mid] &lt; val) {<br>\t\t\tstart = mid + 1;<br>\t\t} else {<br>\t\t\tif(mid == 0 || a[mid-1] &lt; val) break;<br>\t\t\telse end = mid - 1;<br>\t\t}<br>\t}<br>\treturn mid;<br>}<br>3.查找第一个大于等于给定值的元素，比如在数组a[10]={1,3,4,5,6,8,8,8,11,18}<br>public int bSear3(int[] a, int val){<br>\tint start = 0;<br>\tint end = a.length - 1;<br>\tint mid = -1;<br>\twhile(start &lt;= end){<br>\t\tmid = start + (end - start) &#47; 2;<br>\t\tif(a[mid] &gt; val){<br>\t\t\tif(start == end) break;<br>\t\t\tend = mid - 1;<br>\t\t} else if (a[mid] &lt; val) {<br>\t\t\tstart = start + 1;<br>\t\t\tif(mid == a.length-1) return -1;<br>\t\t} else {<br>\t\t\tif(mid == 0 || a[mid-1] &lt; val)break;<br>   else  end = mid - 1;<br>\t\t}<br>\t}<br>\treturn mid;<br>}<br>4.查找最后一个小于等于给定值的元素，比如在数组a[10]={1,3,4,5,6,8,8,8,11,18}<br>public int bSear4(int[] a, int val){<br>\tint start = 0;<br>\tint end = a.length - 1;<br>\tint mid = -1;<br>\twhile(start &lt;= end){<br>\t\tmid = start + (end - start) &#47; 2;<br>\t\tif(a[mid] &gt; val){<br>\t\t\tend = mid - 1;<br>\t\t\tif(mid == 0) return -1;<br>\t\t} else if (a[mid] &lt; val) {<br>\t\t\tif(start == end) {<br>\t\t\t\tbreak;<br>\t\t\t}<br>\t\t\tstart = mid + 1;<br>\t\t} else {<br>\t\t\tif(mid == a.length-1 || a[mid+1] &gt; val) break;<br>\t\t\telse start = mid + 1;<br>\t\t}<br>\t}<br>\treturn mid;<br>}","like_count":0},{"had_liked":false,"id":35996,"user_name":"张洋","can_delete":false,"product_type":"c1","uid":1182914,"ip_address":"","ucode":"549BE5DEEF8417","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/c2/bad34a50.jpg","comment_is_top":false,"comment_ctime":1540885781,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1540885781","product_id":100017301,"comment_content":"课后思考题<br>可以先通过二分查找找出来循环数组的最小值和索引。通过最小值的索引把数组分为两个区间<br>然后每次查找的时候当前值比较 最小值和最大索引值的关系。<br>不在这个区间就去上一个区间去二分查找。","like_count":0},{"had_liked":false,"id":35952,"user_name":"知易","can_delete":false,"product_type":"c1","uid":1246882,"ip_address":"","ucode":"BD3E3F0F0A40EF","user_header":"https://static001.geekbang.org/account/avatar/00/13/06/a2/350c4af0.jpg","comment_is_top":false,"comment_ctime":1540870673,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540870673","product_id":100017301,"comment_content":"课后思考，二分确定循环不重复数组定值<br>public int erfenCircleArray(int[] a, int v) {<br>\t\tint low=0, high=a.length - 1;<br>\t\twhile(low &lt;= high) {<br>\t\t\tint mid = low + ((high - low)&gt;&gt;1);<br>\t\t\tif(a[mid] &gt; a[0]) {<br>\t\t\t\tif(v &gt; a[mid] || v &lt; a[low]) {<br>\t\t\t\t\tlow = mid + 1;<br>\t\t\t\t} else if(a[mid] == v) {<br>\t\t\t\t\treturn mid;<br>\t\t\t\t} else {<br>\t\t\t\t\thigh = mid - 1;<br>\t\t\t\t}<br>\t\t\t} else {<br>\t\t\t\tif(v &lt; a[mid] || v &gt; a[high]) {<br>\t\t\t\t\thigh = mid - 1;<br>\t\t\t\t} else if(a[mid] == v) {<br>\t\t\t\t\treturn mid;<br>\t\t\t\t} else {<br>\t\t\t\t\tlow = mid + 1;<br>\t\t\t\t}<br>\t\t\t}<br>\t\t}<br>\t\treturn -1;<br>\t}","like_count":0},{"had_liked":false,"id":35730,"user_name":"Infinite_gao","can_delete":false,"product_type":"c1","uid":1235607,"ip_address":"","ucode":"9FBFEDED8790A8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLsexaVCEecIhpPsOqHJkZFEnyTfOZ1Ot3lmSMfyIVkR5SerJibatj6mIHackokoIO4ELiaObhQ60rw/132","comment_is_top":false,"comment_ctime":1540777365,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540777365","product_id":100017301,"comment_content":"关于变种的3和4，在3的基础上稍加改造，第一个&gt;=给定值的前一个元素的位置就是最后一个&lt;给定值的位置","like_count":0},{"had_liked":false,"id":35724,"user_name":"拉欧","can_delete":false,"product_type":"c1","uid":1206605,"ip_address":"","ucode":"40996A8093A95F","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/4d/81c44f45.jpg","comment_is_top":false,"comment_ctime":1540776455,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540776455","product_id":100017301,"comment_content":"这道题之前做过，主要难点在于区分有序区间，其他和常规2分相同","like_count":0},{"had_liked":false,"id":35607,"user_name":"新手","can_delete":false,"product_type":"c1","uid":1238298,"ip_address":"","ucode":"A691F17A9CE49A","user_header":"https://static001.geekbang.org/account/avatar/00/12/e5/1a/788885ae.jpg","comment_is_top":false,"comment_ctime":1540703661,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540703661","product_id":100017301,"comment_content":"Rust实现的在循环有序无重复数组中查找值：<br><br>&#47;&#47;&#47; Binary search the element which equals to value in a sorted cycled slice<br>&#47;&#47;&#47;<br>&#47;&#47;&#47; # Arguments<br>&#47;&#47;&#47; * `a` - A sorted cycled slice that hold unique values<br>&#47;&#47;&#47; * `v` - The value to be searched<br>&#47;&#47;&#47;<br>&#47;&#47;&#47; # Return<br>&#47;&#47;&#47; Index of the value<br>&#47;&#47;&#47;<br>&#47;&#47;&#47; # Examples<br>&#47;&#47;&#47;<br>&#47;&#47;&#47; ```<br>&#47;&#47;&#47; extern crate binary_search;<br>&#47;&#47;&#47; use binary_search::binary_search_cycled;<br>&#47;&#47;&#47;<br>&#47;&#47;&#47; let a = vec![5, 6, 7, 8, 9, 1, 2, 3, 4];<br>&#47;&#47;&#47; assert_eq!(binary_search_cycled(&amp;a, 9), Some(4));<br>&#47;&#47;&#47; assert_eq!(binary_search_cycled(&amp;a, 10), None);<br>&#47;&#47;&#47; ```<br>pub fn binary_search_cycled&lt;T: PartialOrd&gt;(a: &amp;[T], v: T) -&gt; Option&lt;usize&gt; {<br>    let mut low = 0i32;<br>    let mut high = a.len() as i32 - 1;<br><br>    while low &lt;= high {<br>        &#47;&#47; prevent overflow<br>        let mid = low + ((high - low) &gt;&gt; 1);<br>        let mid_val = &amp;a[mid as usize];<br><br>        if *mid_val == v {<br>            return Some(mid as usize);<br>        } else if a[low as usize] &lt;= *mid_val {<br>            &#47;&#47; left side is ordered, right side is ordered or cycled<br>            if *mid_val &gt; v &amp;&amp; a[low as usize] &lt;= v {<br>                high = mid - 1;<br>            } else {<br>                low = mid + 1;<br>            }<br>        } else {<br>            &#47;&#47; left side is ordered or cycled, right side is ordered<br>            if *mid_val &lt; v &amp;&amp; a[high as usize] &gt;= v {<br>                low = mid + 1;<br>            } else {<br>                high = mid - 1;<br>            }<br>        }<br>    }<br><br>    None<br>}","like_count":0},{"had_liked":false,"id":35538,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1540645645,"is_pvip":false,"replies":[{"id":"12684","content":"哈哈 👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540740504,"ip_address":"","comment_id":35538,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540645645","product_id":100017301,"comment_content":"我提一个无关算法问题的问题：<br>Donald E.Kunth有一个正式的中文名，叫：高德纳。顺便提一句：他的夫人也有一个中文名，叫：高精兰(Jill)","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427568,"discussion_content":"哈哈 👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540740504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35536,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1540645222,"is_pvip":false,"replies":[{"id":"12685","content":"你这个还是循环有序的吗","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540740540,"ip_address":"","comment_id":35536,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540645222","product_id":100017301,"comment_content":"对今天的题目有点疑问：<br><br>「有序数组是个循环有序数组」，给得例子是这样[4,5,6,1,2,3]，一定是前面环中的数总大于后面环的数吗？有可能是这样吗：[4,5,6,1,2,3,9,10,11,18,17,16,6,7,8]","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427567,"discussion_content":"你这个还是循环有序的吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540740540,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35532,"user_name":"liangjf","can_delete":false,"product_type":"c1","uid":1058812,"ip_address":"","ucode":"681A6CCF098F55","user_header":"https://static001.geekbang.org/account/avatar/00/10/27/fc/b8d83d56.jpg","comment_is_top":false,"comment_ctime":1540643528,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540643528","product_id":100017301,"comment_content":"一开始，对于查找第一个等于查找值的下标这个问题的第二个简例，对于十一行代码，一直理解不了。想到某个情况是，mid是目标查找值多少钱，mid-1非目标查找值，mid-2是目标查找值，那11行代码是错误的啊。<br>后来马上想起，这是二分查找算法，上面假设<br>是不成立的，因为二分查找面对的数据是有序的。","like_count":0},{"had_liked":false,"id":35480,"user_name":"YellowMax","can_delete":false,"product_type":"c1","uid":1234383,"ip_address":"","ucode":"E937467C3850EA","user_header":"https://static001.geekbang.org/account/avatar/00/12/d5/cf/f60a7fcd.jpg","comment_is_top":false,"comment_ctime":1540617934,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540617934","product_id":100017301,"comment_content":"思考题思路：两次二分查找<br>1.很容易判断循环数组是递增还是递减的（第一个值与第二个值比较或者第一个与最后一个值比较），这一步时间复杂度认为是是 O(1);<br>2.第一次二分（假设是递增的），那就找到第一个小于给定值（下标为0的数）的数，该操作不需要跟查找给定值一样刻意区分到底该往右还是往左（比下标为0大就往右，小就往左），记录下标，这一步时间复杂度是 O(logn);<br>3.第二次二分将第二部找到的下标记为 low，把该值加上数组长度减一作为 high，用唤醒缓冲区加取模的方式二分查找给定的值，这一步的时间复杂度是 O(logn);<br><br>合计 O(1)+2O(logn)，用遍历的方式找循环点个人感觉不太可行，既然是遍历，为什么不直接遍历给定值呢？虽说循环点比整个数组长度小，但是这是概率性事件，我认为它的概率跟要找的值恰好在循环体后一半的概率差不多，所以先遍历循环点再二分不如直接遍历查找给定值。","like_count":0},{"had_liked":false,"id":35404,"user_name":"猫头鹰爱拿铁","can_delete":false,"product_type":"c1","uid":1105958,"ip_address":"","ucode":"24266B58968428","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/26/4942a09e.jpg","comment_is_top":false,"comment_ctime":1540543043,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1540543043","product_id":100017301,"comment_content":"刚动手把今天说的全写了一遍，变形真的好容易写错啊，特别是放在一快写。 我感觉掌握了普通的二分针对变形的二分要点就是找first的就是要尽可能的降低高位指针，然后关注index有没有比0小，找last就是尽可能的增大低位指针，然后关注index有没有高位越界。<br>题目的解法是这样先遍历一遍数组，找到边界index，然后在0和index以及index+1到array.length-1这里分别进行二分查找。如果第一个找到了就不找第二个了。<br>return (key=find(0,index,value))==-1?find(index+1,array.length-1,value):key;","like_count":0},{"had_liked":false,"id":35387,"user_name":"charon","can_delete":false,"product_type":"c1","uid":1189460,"ip_address":"","ucode":"E20B2EB92C30C2","user_header":"https://static001.geekbang.org/account/avatar/00/12/26/54/9fb6a10d.jpg","comment_is_top":false,"comment_ctime":1540534559,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540534559","product_id":100017301,"comment_content":"思考题：<br>我觉得不用找数组的偏移量，通过和low,heig,mid三个值的对比，也是可以确定要找的数值所以的区间的~","like_count":0},{"had_liked":false,"id":35385,"user_name":"Kudo","can_delete":false,"product_type":"c1","uid":1036948,"ip_address":"","ucode":"21965914B72AEB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d2/94/8bd217f1.jpg","comment_is_top":false,"comment_ctime":1540533823,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540533823","product_id":100017301,"comment_content":"Python实现：<br># 1. 查找第一个值等于给定值的元素<br>def bsearch(a, value):<br>    low, high = 0, len(a)-1<br>    while low &lt;= high:<br>        mid = low + (high - low) &#47;&#47; 2<br>        if a[mid] &lt; value:<br>            low = mid + 1<br>        elif a[mid] &gt; value:<br>            high = mid - 1<br>        elif a[mid] == value:<br>            if mid == 0 or a[mid-1] != value:<br>                return mid<br>            else:<br>                high = mid - 1     <br>    return -1<br><br># 2.查找第一个值大于等于给定值的元素<br>def bsearch(a, value):<br>    low, high = 0, len(a)-1<br>    while low &lt;= high:<br>        mid = low + (high - low) &#47;&#47; 2<br>        if a[mid] &lt; value:<br>            low = mid + 1<br>        if a[mid] &gt;= value:<br>            if mid == 0 or a[mid-1] &lt; value:<br>                return mid<br>            else:<br>                high = mid - 1     <br>    return -1","like_count":0},{"had_liked":false,"id":35367,"user_name":"ALAN","can_delete":false,"product_type":"c1","uid":1240164,"ip_address":"","ucode":"70E3B1C730E63F","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/64/7403c694.jpg","comment_is_top":false,"comment_ctime":1540525096,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540525096","product_id":100017301,"comment_content":"1.将循环数组划分成两个区间，第一个区间的数值都大于等于第二个区间，第一个区间的下标都小于第二个区间；首先比较数组中第一个位置的值a[0]和要查找的值val，若相等则直接return;若val大于a[0],则val位于第一区间，若val小于a[0],则val位于第二区间；<br>2.确定第一和第二区间分界线位置x。可知分界线位置x满足,a[x]&gt;a[x+1] 条件；通过如下方法查找位置x<br>int low=0,high=n-1;<br>while(low&lt;=high){<br>  int mid=low+(high-low)&gt;&gt;1;<br> if(a[mid]&gt;a[mid+1]) {<br>   x=mid;<br>   return x;<br>  }<br>else if(a[mid]&gt;a[low]){<br>    low=mid+1;<br> }<br>else{<br>  high=mid-1;<br>}<br>}<br>3.利用所确定的区间和x，在此区间内应用二分查找法计算&quot;值等于给定值&quot;。所确定区间为[0,x] 或[x+1,n-1]","like_count":0},{"had_liked":false,"id":35356,"user_name":"Sharry","can_delete":false,"product_type":"c1","uid":1239293,"ip_address":"","ucode":"045DDB864659F6","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/fd/035f4c94.jpg","comment_is_top":false,"comment_ctime":1540524105,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540524105","product_id":100017301,"comment_content":"思考题<br>int cycleArraySearch(int *arr, int len, int val) {<br>\t&#47;&#47; 计算循环周期<br>\tint cycle = len - 1;<br>\tfor (int i = 0; i &lt; len - 1; i++) {<br>\t\tif (arr[i] &gt; arr[i + 1]) {<br>\t\t\tcycle = i + 1;<br>\t\t\tbreak;<br>\t\t}<br>\t}<br>\t&#47;&#47; 确定元素位于的区间<br>\tint low = 0, high = low + cycle -1;<br>\twhile (high &lt;= len - 1) {<br>\t\t&#47;&#47; 找到区间后, 进行二分查找<br>\t\tif (arr[low] &lt;= val &amp;&amp; arr[high] &gt;= val) {<br>\t\t\treturn binarySearch(arr, low, high, val);<br>\t\t}<br>\t\tlow += cycle;<br>\t\thigh += cycle;<br>\t}<br>\treturn -1;<br>}<br>1. 计算循环周期<br>2. 确定元素位于的区间<br>3. 确定了区间后, 进行二分查找<br> 时间复杂度为: O(n)","like_count":0},{"had_liked":false,"id":35351,"user_name":"🐱您的好友William🐱","can_delete":false,"product_type":"c1","uid":1215456,"ip_address":"","ucode":"427786DB178965","user_header":"https://static001.geekbang.org/account/avatar/00/12/8b/e0/9a79ddac.jpg","comment_is_top":false,"comment_ctime":1540522991,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540522991","product_id":100017301,"comment_content":"不行不行，我之前想法有问题，既然已经遍历连接点了那么连接点之前的那段其实就已经查找过了，所以如果遍历到连接点没有找到就在后面用二分。这样做会保证算法复杂度比O（n）小，但区别不大。","like_count":0},{"had_liked":false,"id":35346,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1540522240,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540522240","product_id":100017301,"comment_content":"关于思考题 竟然是循环数组 可以把他看作一个环，我们取出最小的那个作为环的起点和终点 可以通过起始坐标点求得中点坐标即可求出最小的那个点，用两个指针指向一个从中点往前走，一个指针从中点往后走,然后再根据要求值的大小选择挪动指针，即可得出一个区间<br>伪代码:<br>假设通过数组起点和终点坐标 p 向左的指针为pl 向右的指针为pr  要查找的值val<br>如果pr &gt; val &amp;&amp; val &lt; pl 则pl -= 1 pr+=1<br>else if pr &gt; val || pr &lt; val则说明不存了<br>所以整个算法复杂度为O(logn)<br>通过这种方法 把环分成两部分 满足条件部分和不满足条件部分","like_count":0},{"had_liked":false,"id":35345,"user_name":"🐱您的好友William🐱","can_delete":false,"product_type":"c1","uid":1215456,"ip_address":"","ucode":"427786DB178965","user_header":"https://static001.geekbang.org/account/avatar/00/12/8b/e0/9a79ddac.jpg","comment_is_top":false,"comment_ctime":1540522049,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540522049","product_id":100017301,"comment_content":"思考题，是循环有序，那么我们先找到循环连接点的位置，遍历算法复杂度为O（n）。找到位置后我们就可以设置low=0，如果a[low]小于要查找的数就在连接点前面找，如果a[low]大于要查找的数就在连接点后面查找，复杂度是O（logn）。","like_count":0},{"had_liked":false,"id":35323,"user_name":"蒋礼锐","can_delete":false,"product_type":"c1","uid":1248897,"ip_address":"","ucode":"25E042066A1427","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/gM1ibHKPkrs5DSIp4aIuQ9jnYtNicc2tdG244PbaSvKw5jO9DWrhWghcVM1Y5Iq2QSpzLBUeWZQLhARst51z35mA/132","comment_is_top":false,"comment_ctime":1540517394,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540517394","product_id":100017301,"comment_content":"因为数组循环有序的特殊数组，所以首先要找到是多少为一循环，先假设每个循环之间是从小到大排列，每个循环内从大到小排列的数组为A,需要查找的数为value<br><br>从零遍历，step为1，如果A[i]&lt;A[i+1]，那么循环就是每i个一循环<br><br>在n&#47;i中使用二分查找，中间点一定是为i的倍数，终止条件为A[j*i]&gt;value, 则value值一定在j到j+i之间，因为还是有序，再用一次二分即可找到。<br><br>时间复杂度:<br>第一次遍历找循环，(不知道有没有可以优化的方法)，复杂度为O(N)，假设循环为c<br>第二次二分，log(n&#47;c)，n&#47;c是因为不会查找除了整数位以外的<br>第三次log(c)<br>所以整体的时间复杂度应该是o(N)<br><br>空间复杂度为1，没有开辟新数组","like_count":0},{"had_liked":false,"id":35311,"user_name":"一周","can_delete":false,"product_type":"c1","uid":1241320,"ip_address":"","ucode":"13A58E85B5232A","user_header":"https://static001.geekbang.org/account/avatar/00/12/f0/e8/e72b3cf5.jpg","comment_is_top":false,"comment_ctime":1540515819,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540515819","product_id":100017301,"comment_content":"思考题  首先便利一下找到最大值节点mid，然后，用第一个数值a[0]，最后一个数值a[n-1]和需要找的数值进行比较，确定是在哪个区域，然后在对应区域进行二分查找","like_count":0}]}