{"id":508706,"title":"35 | 发现和识别内存问题：内存调试实践","content":"<p>你好，我是吴咏炜。</p><p>作为内存相关话题的最后一讲，今天我们来聊一聊内存调试的问题。</p><h2>场景</h2><p>首先，目前已经存在一些工具，可以让你在自己不写任何代码的情况下，帮助你来进行内存调试。用好你所在平台的现有工具，已经可以帮你解决很多内存相关问题（在<a href=\"https://time.geekbang.org/column/article/187980\">第 21 讲</a>中我已经介绍了一些）。</p><p>不过，前面提到的工具，主要帮你解决的问题是内存泄漏，部分可以帮你解决内存踩踏问题。它们不能帮你解决内存相关的所有问题，比如：</p><ul>\n<li>内存检测工具可能需要使用自己的特殊内存分配器，因此不能和你的特殊内存分配器协作（不使用标准的 <code>malloc</code>/<code>free</code>）</li>\n<li>某些内存调试工具对性能影响太大，无法在实际场景中测试</li>\n<li>你需要检查程序各个模块的分别内存占用情况</li>\n<li>你需要检查程序各个线程的分别内存占用情况</li>\n<li>……</li>\n</ul><p>总的来说，现成的工具提供了一定的功能，如果它直接能满足你的需求，那当然最好。但如果你有超出它能力的需求，那自己写点代码来帮助调试，也不是一件非常困难的事情——尤其在我们了解了这么多关于内存的底层细节之后。</p><h2>内存调试原理</h2><p>内存调试的基本原理，就是在内存分配的时候记录跟分配相关的一些基本信息，然后，在后面的某个时间点，可以通过检查记录下来的信息来检查跟之前分配的匹配情况，如：</p><!-- [[[read_end]]] --><ul>\n<li>在（测试）程序退出时检查是否有未释放的内存，即有没有产生内存泄漏</li>\n<li>在释放内存时检查内存是不是确实是之前分配的</li>\n<li>根据记录的信息来对内存的使用进行分门别类的统计</li>\n</ul><p>根据不同的使用场景，我们需要在分配内存时记录不同的信息，比如：</p><ul>\n<li>需要检查有没有内存泄漏，我们可以只记录总的内存分配和释放次数</li>\n<li>需要检查内存泄漏的数量和位置，我们需要在每个内存块里额外记录分配内存的大小，及调用内存分配的代码的位置（文件、行号之类）；但这样记录下来的位置不一定是真正有问题的代码的位置</li>\n<li>需要检查实际造成内存泄漏的代码的位置，我们最好能够记录内存分配时的完整调用栈（而非分配内存的调用发生的位置）；注意这通常是一个平台相关的解决方案</li>\n<li>作为一种简单、跨平台的替换方案，我们可以在内存分配时记录一个“上下文”，这样在有内存泄漏时可以缩小错误范围，知道在什么上下文里发生了问题</li>\n<li>这个“上下文”里可以包含模块、线程之类的信息，随后我们就可以针对模块或线程来进行统计</li>\n<li>我们可以在分配内存时往里安插一个特殊的标识，并在释放时检查并清除这个标识，用来识别是不是释放了不该释放的内存，或者发生了重复释放</li>\n</ul><p>根据你的实际场景和需要，可能性也是无穷无尽的。</p><p>下面，我们就来根据“上下文”的思想，来实现一个小小的内存调试工具。基于同样的思想，你也可以对它进行扩充，来满足你的特殊需求。</p><h2>“上下文”内存调试工具</h2><h3>预备知识</h3><p>这个内存调试工具说难不难，但它用到了很多我们之前学过的知识。我在下面再列举一下，万一忘记了的话，建议你复习一下再往下看：</p><ul>\n<li>RAII（<a href=\"https://time.geekbang.org/column/article/169225\">第 1 讲</a>）：我们使用 RAII 来自动产生和销毁一个上下文</li>\n<li><code>deque</code> 和 <code>stack</code>（<a href=\"https://time.geekbang.org/column/article/173167\">第 4 讲</a>）：用来存放当前线程的所有上下文</li>\n<li><code>operator new</code> 和 <code>operator delete</code> 的不同形态及其替换（<a href=\"https://time.geekbang.org/column/article/489409\">第 31 讲</a>）：我们需要使用布置版本，指定对齐，并截获内存分配和释放操作</li>\n<li>分配器（<a href=\"https://time.geekbang.org/column/article/491227\">第 32 讲</a>）：我们最后会需要使用一个特殊的分配器来处理一个小细节</li>\n</ul><h3>上下文</h3><p>我已经说了好多遍上下文这个词。从代码的角度，它到底是什么呢？</p><p>它是什么，由你来决定。</p><p>从内存调试的角度，可能有用的上下文定义有：</p><ul>\n<li>文件名加行号</li>\n<li>文件名加函数名</li>\n<li>函数名加行号</li>\n<li>等等</li>\n</ul><p>每个人可能有不同的偏好。我目前使用了文件名加函数名这种方式，把上下文定义成：</p><pre><code class=\"language-cpp\">struct context {\n  const char* file;\n  const char* func;\n};\n</code></pre><p>要生成上下文，可以利用标准宏或编译器提供的特殊宏。下面的写法适用于任何编译器：</p><pre><code class=\"language-cpp\">context{__FILE__, __func__}\n</code></pre><p>如果你使用 GCC 的话，你应该会想用 <code>__PRETTY_FUNCTION__</code> 来代替 <code>__func__</code> <span class=\"orange\">[1]</span>。而如果你使用 MSVC 的话，<code>__FUNCSIG__</code> 可能会是个更好的选择 <span class=\"orange\">[2]</span>。</p><h3>上下文的产生和销毁</h3><p>我们使用一个类栈的数据结构来存放所有的上下文，并使用后进先出的方式来加入或抛弃上下文。代码非常直白，如下所示：</p><pre><code class=\"language-cpp\">thread_local stack&lt;context&gt;\n  context_stack;\n\nconst context default_ctx{\n  \"&lt;UNKNOWN&gt;\", \"&lt;UNKNOWN&gt;\"};\n\nconst context&amp;\nget_current_context()\n{\n  if (context_stack.empty()) {\n    return default_ctx;\n  }\n  return context_stack.top();\n}\n\nvoid restore_context()\n{\n  context_stack.pop();\n}\n\nvoid save_context(\n  const context&amp; ctx)\n{\n  context_stack.push(ctx);\n}\n</code></pre><p>但如果要求你次次小心地手工调用 <code>restore_context</code> 和 <code>save_context</code> 的话，那也太麻烦、太容易出错了。这时，我们可以写一个小小的 RAII 类，来自动化对这两个函数的调用：</p><pre><code class=\"language-cpp\">class checkpoint {\npublic:\n  explicit checkpoint(\n    const context&amp; ctx)\n  {\n    save_context(ctx);\n  }\n  ~checkpoint()\n  {\n    restore_context();\n  }\n};\n</code></pre><p>再加上一个宏会更方便一点：</p><pre><code class=\"language-cpp\">#define MEMORY_CHECKPOINT()        \\\n  checkpoint func_checkpoint{      \\\n    context{__FILE__, __func__}}\n</code></pre><p>然后，你就只需要在自己的函数里加上一行代码，就可以跟踪函数内部的内存使用了：</p><pre><code class=\"language-cpp\">void SomeFunc()\n{\n  MEMORY_CHECKPOINT();\n  // 函数里的其他操作\n}\n</code></pre><h3>记录上下文</h3><p>之前的代码只是让我们可以产生在某一特定场景下的上下文。我们要利用这些上下文进行内存调试，就需要把上下文记录下来。我们需要定义一堆额外的布置分配和释放函数。简单起见，我们在这些函数里，简单转发内存分配和释放请求到新的函数：</p><pre><code class=\"language-cpp\">void* operator new(\n  size_t size, const context&amp; ctx)\n{\n  void* ptr = alloc_mem(size, ctx);\n  if (ptr) {\n    return ptr;\n  } else {\n    throw bad_alloc();\n  }\n}\nvoid* operator new[](\n  size_t size, const context&amp; ctx)\n{\n  // 同上，略\n}\nvoid* operator new(\n  size_t size,\n  align_val_t align_val,\n  const context&amp; ctx)\n{\n  void* ptr = alloc_mem(\n    size, ctx, size_t(align_val));\n  if (ptr) {\n    return ptr;\n  } else {\n    throw bad_alloc();\n  }\n}\nvoid* operator new[](\n  size_t size,\n  align_val_t align_val,\n  const context&amp; ctx)\n{\n  // 同上，略\n}\n\nvoid operator delete(\n  void* ptr,\n  const context&amp;) noexcept\n{\n  free_mem(ptr);\n}\nvoid operator delete[](\n  void* ptr,\n  const context&amp;) noexcept\n{\n  free_mem(ptr);\n}\nvoid operator delete(\n  void* ptr, align_val_t align_val,\n  const context&amp;) noexcept\n{\n  free_mem(ptr, size_t(align_val));\n}\nvoid operator delete[](\n  void* ptr, align_val_t align_val,\n  const context&amp;) noexcept\n{\n  free_mem(ptr, size_t(align_val));\n}\n</code></pre><p>标准的分配和释放函数也类似地只是转发而已，但我们这时就会需要用上前面产生的上下文。代码重复比较多，我就只列举最典型的两个函数了：</p><pre><code class=\"language-cpp\">void* operator new(size_t size)\n{\n  return operator new(\n    size, get_current_context());\n}\n\nvoid operator delete(\n  void* ptr) noexcept\n{\n  free_mem(ptr);\n}\n</code></pre><p>下面，我们需要把重点放到 <code>alloc_mem</code> 和 <code>free_mem</code> 两个函数上。我们先写出这两个函数的原型：</p><pre><code class=\"language-cpp\">void* alloc_mem(\n  size_t size, const context&amp; ctx,\n  size_t alignment =\n    __STDCPP_DEFAULT_NEW_ALIGNMENT__);\n\nvoid free_mem(\n  void* usr_ptr,\n  size_t alignment =\n    __STDCPP_DEFAULT_NEW_ALIGNMENT__);\n</code></pre><p><code>alloc_mem</code> 接受大小、上下文和对齐值（默认为系统的默认对齐值 <code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>），进行内存分配，并把上下文记录下来。显然，下面的问题就是：</p><ul>\n<li>我们需要记录多少额外信息？</li>\n<li>我们需要把信息记录到哪里？</li>\n</ul><p>鉴于在释放内存时，通用的接口<strong>只能</strong>拿到一个指针，我们需要通过这个指针找到我们原先记录的信息，因此，我们得出结论，只能把额外的信息记录到分配给用户的内存前面。也就是说，我们需要在分配内存时多分配一点空间，在开头存上我们需要的额外信息，然后把额外信息后的内容返回给用户。这样，在用户释放内存的时候，我们才能简单地找到我们记录的额外信息。</p><p>我们需要额外存储的信息也不能只是上下文。关键地：</p><ul>\n<li>我们需要记录用户申请的内存大小，并用指针把所有的内存块串起来，以便在需要时报告内存泄漏的数量和大小。</li>\n<li>我们需要记录额外信息的大小，因为在不同的对齐值下，额外信息的指针和返回给用户的指针之间的差值会不相同。</li>\n<li>我们需要魔术数来辅助校验内存的有效性，帮助检测释放非法内存和重复释放。</li>\n</ul><p>因此，我们把额外信息的结构体定义如下：</p><pre><code class=\"language-cpp\">struct alloc_list_base {\n  alloc_list_base* next;\n  alloc_list_base* prev;\n};\n\nstruct alloc_list_t\n  : alloc_list_base {\n  size_t size;\n  context ctx;\n  uint32_t head_size;\n  uint32_t magic;\n};\n\nalloc_list_base alloc_list = {\n  &amp;alloc_list, // head (next)\n  &amp;alloc_list, // tail (prev)\n};\n</code></pre><p>从 <code>alloc_list_t</code> 分出一个 <code>alloc_list_base</code> 子类的目的是方便我们统一对链表头尾的操作，不需要特殊处理。<code>alloc_list</code> 的 <code>next</code> 成员指向链表头，<code>prev</code> 成员指向链表尾；把 <code>alloc_list</code> 也算进去，整个链表构成一个环形。</p><p><code>alloc_list_t</code> 内容有效时我们会在 <code>magic</code> 中填入一个特殊数值，这里我们随便取一个：</p><pre><code class=\"language-cpp\">constexpr uint32_t CMT_MAGIC =\n  0x4D'58'54'43; // \"CTXM\";\n</code></pre><p>在实现 <code>alloc_mem</code> 之前，我们先把对齐函数的实现写出来：</p><pre><code class=\"language-cpp\">constexpr uint32_t\nalign(size_t alignment, size_t s)\n{\n  return static_cast&lt;uint32_t&gt;(\n    (s + alignment - 1) &amp;\n    ~(alignment - 1));\n}\n</code></pre><p>我们这里把一个大小 <code>s</code> 调整为 <code>alignment</code> 的整数倍。这里 <code>alignment</code> 必须是 2 的整数次幂，否则这个算法不对。一种可能更容易理解、但也更低效的计算方法是 <code>(s + alignment - 1) / alignment * alignment</code>。</p><p>这样，我们终于可以写出 <code>alloc_mem</code> 的定义了：</p><pre><code class=\"language-cpp\">size_t current_mem_alloc = 0;\n\nvoid* alloc_mem(\n  size_t size, const context&amp; ctx,\n  size_t alignment =\n    __STDCPP_DEFAULT_NEW_ALIGNMENT__)\n{\n  uint32_t aligned_list_node_size =\n    align(alignment,\n          sizeof(alloc_list_t));\n  size_t s =\n    size + aligned_list_node_size;\n  auto ptr =\n    static_cast&lt;alloc_list_t*&gt;(\n      aligned_alloc(\n        alignment,\n        align(alignment, s)));\n  if (ptr == nullptr) {\n    return nullptr;\n  }\n  auto usr_ptr =\n    reinterpret_cast&lt;byte*&gt;(ptr) +\n    aligned_list_node_size;\n  ptr-&gt;ctx = ctx;\n  ptr-&gt;size = size;\n  ptr-&gt;head_size =\n    aligned_list_node_size;\n  ptr-&gt;magic = MAGIC;\n  ptr-&gt;prev = alloc_list.prev;\n  ptr-&gt;next = &amp;alloc_list;\n  alloc_list.prev-&gt;next = ptr;\n  alloc_list.prev = ptr;\n  current_mem_alloc += size;\n  return usr_ptr;\n}\n</code></pre><p>简单解释一下：</p><ul>\n<li>我们用一个全局变量 <code>current_mem_alloc</code> 跟踪当前已经分配的内存总量。</li>\n<li>把额外存储信息的大小和用户请求的内存大小都调为 <code>alignment</code> 的整数倍，并使用两者之和作为大小参数来调用 C++17 的 <code>aligned_alloc</code>，进行内存分配；注意 <code>aligned_alloc</code> 要求分配内存大小必须为对齐值的整数倍。</li>\n<li>如果分配内存失败，我们只能返回空指针。</li>\n<li>否则，我们在链表结点里填入内容，插入到链表尾部，增加  <code>current_mem_alloc</code> 值，并返回链表结点后的部分给用户。</li>\n</ul><h3>释放检查</h3><p>释放内存就是一个相反的操作，我们拿到一个用户提供的指针和对齐值，倒推出链表结点的地址，检查其中内容来验证地址的有效性，最后把链表结点从链表中摘除，并释放内存。</p><p>倒推链表结点地址的代码如下（简化版）：</p><pre><code class=\"language-cpp\">alloc_list_t*\nconvert_user_ptr(void* usr_ptr,\n                 size_t alignment)\n{\n  auto offset =\n    static_cast&lt;byte*&gt;(usr_ptr) -\n    static_cast&lt;byte*&gt;(nullptr);\n  auto byte_ptr =\n    static_cast&lt;byte*&gt;(usr_ptr);\n\n  if (offset % alignment != 0) {\n    return nullptr;\n  }\n  auto ptr =\n    reinterpret_cast&lt;alloc_list_t*&gt;(\n      byte_ptr -\n      align(alignment,\n            sizeof(alloc_list_t)));\n  if (ptr-&gt;magic != MAGIC) {\n    return nullptr;\n  }\n\n  return ptr;\n}\n</code></pre><p>我们首先把用户指针 <code>usr_ptr</code> 转换成整数值 <code>offset</code>，然后检查其是否对齐。不对齐的话，这个指针肯定是错误的，这个函数就直接返回空指针了。否则，我们就把用户指针减去链表结点的对齐大小，并转换为正确的类型。保险起见，我们还需要检查魔术数是否正确，不正确同样用空指针表示失败。魔术数正确的话，那我们才算得到了正确的结果。</p><p>检查逻辑基本就在上面了。<code>free_mem</code> 函数则相当简单：</p><pre><code class=\"language-cpp\">void free_mem(\n  void* usr_ptr,\n  size_t alignment =\n    __STDCPP_DEFAULT_NEW_ALIGNMENT__)\n{\n  if (usr_ptr == nullptr) {\n    return;\n  }\n\n  auto ptr = convert_user_ptr(\n    usr_ptr, alignment);\n  if (ptr == nullptr) {\n    puts(\"Invalid pointer or \"\n         \"double-free\");\n    abort();\n  }\n  current_mem_alloc -= ptr-&gt;size;\n  ptr-&gt;magic = 0;\n  ptr-&gt;prev-&gt;next = ptr-&gt;next;\n  ptr-&gt;next-&gt;prev = ptr-&gt;prev;\n  free(ptr);\n}\n</code></pre><p>对于空指针，我们按 C++ 标准不需要做任何事情，立即返回即可。如果倒推链表结点地址失败的话，我们会输出一行错误信息，并终止程序执行——内存错误是一个很严重的问题，通常继续执行程序已经没有意义，还是早点失败上调试器检查比较好。一切成功的话，我们就在 <code>current_mem_alloc</code> 里减去释放内存的大小，清除魔术数（这样才能防止重复释放），从链表中摘除当前结点，最后释放内存。</p><h3>退出检查</h3><p>我们在链表结点里存储了上下文信息，这就让我们后续可以做很多调试工作了。一种典型的应用是在程序退出时进行内存泄漏检查。我们可以使用一个全局 RAII 对象来控制调用 <code>check_leaks</code>，这可以保证泄漏检查会发生在 <code>main</code> 全部执行完成之后（课后思考里有更复杂的方法）：</p><pre><code class=\"language-cpp\">class invoke_check_leak_t {\npublic:\n  ~invoke_check_leak_t()\n  {\n    check_leaks();\n  }\n} invoke_check_leak;\n</code></pre><p>而 <code>check_leaks</code> 所需要做的事情，也就只是遍历内存块的链表而已：</p><pre><code class=\"language-cpp\">int check_leaks()\n{\n  int leak_cnt = 0;\n  auto ptr =\n    static_cast&lt;alloc_list_t*&gt;(\n      alloc_list.next);\n\n  while (ptr != &amp;alloc_list) {\n    if (ptr-&gt;magic != MAGIC) {\n      printf(\"error: heap data \"\n             \"corrupt near %p\\n\",\n             &amp;ptr-&gt;magic);\n      abort();\n    }\n\n    auto usr_ptr =\n      reinterpret_cast&lt;const byte*&gt;(\n        ptr) +\n      ptr-&gt;head_size;\n    printf(\"Leaked object at %p \"\n           \"(size %zu, \",\n           usr_ptr, ptr-&gt;size);\n    print_context(ptr-&gt;ctx);\n    printf(\")\\n\");\n\n    ptr =\n      static_cast&lt;alloc_list_t*&gt;(\n        ptr-&gt;next);\n    ++leak_cnt;\n  }\n  if (leak_cnt) {\n    printf(\"*** %d leaks found\\n\",\n           leak_cnt);\n  }\n\n  return leak_cnt;\n}\n</code></pre><p>我们从链表头（<code>alloc_list.next</code>）开始遍历链表，对每个结点首先检查魔术数是否正确，然后根据 <code>head_size</code> 算出用户内存所在的位置，并和上下文一起打印出来，然后泄漏计数加一。待链表遍历完成之后（遍历指针重新指向 <code>alloc_list</code>），我们打印泄漏内存块的数量，并将其返回。</p><p>对于下面这样一个简单的 <code>main</code> 函数：</p><pre><code class=\"language-cpp\">int main()\n{\n  auto ptr1 = new char[10];\n  MEMORY_CHECKPOINT();\n  auto ptr2 = new char[20];\n}\n</code></pre><p>这是一种可能的运行结果：</p><blockquote>\n<p><code>Leaked object at 0x57930e30 (size 10, context: &lt;UNKNOWN&gt;/&lt;UNKNOWN&gt;)</code><br>\n<code>Leaked object at 0x57930e70 (size 20, context: test.cpp/main)</code><br>\n<code>*** 2 leaks found</code></p>\n</blockquote><h3>一个小细节</h3><p>有一个小细节我们这里讨论一下：<code>context_stack</code> 也需要使用内存，按目前的实现，它的内存占用会计入到“当前”上下文里去，这可能会是一个不必要、且半随机的干扰。为此，我们给它准备一个独立的分配器，使得它占用的内存不被上下文所记录。它的实现如下所示：</p><pre><code class=\"language-cpp\">template &lt;typename T&gt;\nstruct malloc_allocator {\n  typedef T value_type;\n  typedef std::true_type\n    is_always_equal;\n  typedef std::true_type\n    propagate_on_container_move_assignment;\n\n  malloc_allocator() = default;\n  template &lt;typename U&gt;\n  malloc_allocator(\n    const malloc_allocator&lt;U&gt;&amp;)\n  {}\n\n  template &lt;typename U&gt;\n  struct rebind {\n    typedef malloc_allocator&lt;U&gt;\n      other;\n  };\n\n  T* allocate(size_t n)\n  {\n    return static_cast&lt;T*&gt;(\n      malloc(n * sizeof(T)));\n  }\n  void deallocate(T* p, size_t)\n  {\n    free(p);\n  }\n};\n</code></pre><p>除了一些常规的固定代码，这个分配器的主要功能体现在它的 <code>allocate</code> 和 <code>deallocate</code> 的实现上，里面直接调用了 <code>malloc</code> 和 <code>free</code>，而不是 <code>operator new</code> 和 <code>operator delete</code>，也非常简单。</p><p>然后，我们只需要让我们的 <code>context_stack</code> 使用这个分配器即可。</p><pre><code class=\"language-cpp\">thread_local stack&lt;\n  context,\n  deque&lt;context,\n        malloc_allocator&lt;context&gt;&gt;&gt;\n  context_stack;\n</code></pre><p>注意 <code>stack</code> 只是一个容器适配器，分配器参数需要写到它的底层容器 <code>deque</code> 里去才行。</p><h2>内容小结</h2><p>本讲我们综合运用迄今为止学到的多种知识，描述了一个使用栈式上下文对内存使用进行调试的工具。目前这个工具只是简单地记录上下文信息，并在检查内存泄漏时输出未释放的内存块的上下文信息。你可以根据自己的需要对其进行扩展，来满足特定的调试目的。</p><h2>课后思考</h2><p>Nvwa 项目提供了一个根据本讲思路实现的完整的内存调试器，请参考其中的 memory_trace.* 和 aligned_memory.* 文件 <span class=\"orange\">[3]</span>。它比本讲的介绍更加复杂一些，对跨平台和实际使用场景考虑更多，如：</p><ul>\n<li>多线程加锁保护，并通过自定义的 <code>fast_mutex</code> 来规避 MSVC 中的 <code>std::mutex</code> 的重入问题</li>\n<li>不直接调用标准的 <code>aligned_alloc</code> 和 <code>free</code> 来分配和释放内存，解决对齐分配的跨平台性问题</li>\n<li>对 <code>new[]</code> 和 <code>delete</code> 的不匹配使用有较好的检测</li>\n<li>使用 RAII 计数对象来尽可能延迟对 <code>check_leaks</code> 的调用</li>\n<li>更多的错误检测和输出</li>\n<li>……</li>\n</ul><p>请自行分析这一实际实现中增加的复杂性。如有任何问题，欢迎留言和我进行讨论。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] GNU, GCC Manual, section “Function Names as Strings”. <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Function-Names.html\">https://gcc.gnu.org/onlinedocs/gcc/Function-Names.html</a></span></p><p><span class=\"reference\">[2] Microsoft, “Predefined macros”. <a href=\"https://docs.microsoft.com/en-us/cpp/preprocessor/predefined-macros?view=msvc-170\">https://docs.microsoft.com/en-us/cpp/preprocessor/predefined-macros?view=msvc-170</a></span></p><p><span class=\"reference\">[3] 吴咏炜, nvwa. <a href=\"https://github.com/adah1972/nvwa/\">https://github.com/adah1972/nvwa/</a></span></p>","comments":[{"had_liked":false,"id":386652,"user_name":"转遍世界","can_delete":false,"product_type":"c1","uid":2006194,"ip_address":"江苏","ucode":"0783BFDDE87029","user_header":"https://static001.geekbang.org/account/avatar/00/1e/9c/b2/1a9beeb1.jpg","comment_is_top":false,"comment_ctime":1705290781,"is_pvip":false,"replies":[{"id":141018,"content":"这类问题没什么代码检测的好办法。只能使用外部工具，如 Address Sanitizer 和 Clang-Tidy。目前主要还是靠前者这样的运行期工具。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1705750998,"ip_address":"上海","comment_id":386652,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"你好吴老师，您这个内存调试实践代码主要是针对内存泄漏和重复释放的问题。但工作中基本用的是智能指针，这些问题出现的可能性不大。工作中主要的内存问题是野指针问题，比如数组越界访问，迭代器失效后访问非法内存，主要还是访问非法内存问题居多，请问如果想检查这类内存错误可以用代码去检测吗？还怎么去实现？","like_count":1},{"had_liked":false,"id":346834,"user_name":"H X","can_delete":false,"product_type":"c1","uid":1982957,"ip_address":"","ucode":"B73939E7C6A8B9","user_header":"https://static001.geekbang.org/account/avatar/00/1e/41/ed/31db8bce.jpg","comment_is_top":false,"comment_ctime":1653467324,"is_pvip":false,"replies":[{"id":126527,"content":"Valgrind 使用 GPL v2 发布，显然你可以自己去修改它的源代码。\n\nstill unreachable 我怀疑是真正的泄漏而不是内存碎片。你可以换用其他的内存检测工具试一下。C++ 理论上现在应该不容易产生内存泄漏了，如果你不用有所有权的裸指针的话——确实很少再有理由用了。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1653628967,"ip_address":"","comment_id":346834,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"请问 1 .valgrind的内存检测工具 memcheck 和massif 这两个，能否根据我自己的项目 对其源码进行修改。最小影响的 检测我的项目中内存泄漏问题。2、cpp中没有jvm的GC。我用valgrind memcheck查出很多 still reachable。我理解这是内存碎片（vector和string频繁增删数据导致的）针对still reachable 有好的办法解决吗？多谢老师","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636182,"discussion_content":"这类问题没什么代码检测的好办法。只能使用外部工具，如 Address Sanitizer 和 Clang-Tidy。目前主要还是靠前者这样的运行期工具。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705750999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":380334,"user_name":"Geek_595be5","can_delete":false,"product_type":"c1","uid":3242942,"ip_address":"新加坡","ucode":"5C29AC709897C0","user_header":"https://static001.geekbang.org/account/avatar/00/31/7b/be/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1693388991,"is_pvip":false,"replies":[{"id":138522,"content":"在目前我的用法下，拿到引用立即调用另一个函数（而不是保存下来），是没有问题了。这里主要关注性能，而不是防误用。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1693463528,"ip_address":"上海","comment_id":380334,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"请问上面示例中get_current_context函数返回的是引用会不会不安全，毕竟因stack实现不同，可以通过pop、push对之前的引用造成内容擦写","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573752,"discussion_content":"Valgrind 使用 GPL v2 发布，显然你可以自己去修改它的源代码。\n\nstill unreachable 我怀疑是真正的泄漏而不是内存碎片。你可以换用其他的内存检测工具试一下。C++ 理论上现在应该不容易产生内存泄漏了，如果你不用有所有权的裸指针的话——确实很少再有理由用了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653628967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371650,"user_name":"tony","can_delete":false,"product_type":"c1","uid":1131361,"ip_address":"安徽","ucode":"1160371C7F473E","user_header":"https://static001.geekbang.org/account/avatar/00/11/43/61/eeefa369.jpg","comment_is_top":false,"comment_ctime":1680147658,"is_pvip":false,"replies":[{"id":135696,"content":"我没看懂你的问题。分配的内存大小是强制对齐的，也跟“后续内存地址中的内容”是不是0完全没有关系……","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1680525788,"ip_address":"广东","comment_id":371650,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"convert_use_ptr中计算usr_ptr的长度是否在任何情况下都没有问题？比如分配的内存大小正好是对齐的且后续内存地址中的内容也不为0。谢谢老师。\n“auto offset =\n    static_cast&lt;byte*&gt;(usr_ptr) -\n    static_cast&lt;byte*&gt;(nullptr);”","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":626876,"discussion_content":"在目前我的用法下，拿到引用立即调用另一个函数（而不是保存下来），是没有问题了。这里主要关注性能，而不是防误用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1693463528,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368533,"user_name":"awmthink","can_delete":false,"product_type":"c1","uid":1331202,"ip_address":"广东","ucode":"742915BBCE7111","user_header":"https://static001.geekbang.org/account/avatar/00/14/50/02/cce1cf67.jpg","comment_is_top":false,"comment_ctime":1676429776,"is_pvip":false,"replies":[{"id":134217,"content":"不同翻译单元里的全局&#47;静态对象的析构顺序没有保证。文中的技巧可以保证析构发生在所有包含了这个头文件的源文件里的全局&#47;静态对象的析构之后。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1676438114,"ip_address":"广东","comment_id":368533,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"吴老师，请问：memory_trace里 “使用 RAII 计数对象来尽可能延迟对 check_leaks 的调用” 怎么理解呢？我看代码时，是把check_leaks调用放在了一个static对象的析构里，和全局对象invoke_check_leak相比，行为有什么不同吗？（防止有其他编译模块定义的全局对象生命周期比invoke_check_leak更长吗？）","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612131,"discussion_content":"我没看懂你的问题。分配的内存大小是强制对齐的，也跟“后续内存地址中的内容”是不是0完全没有关系……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680525788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347035,"user_name":"ericaaa","can_delete":false,"product_type":"c1","uid":3005568,"ip_address":"","ucode":"5E1AA008081DBC","user_header":"","comment_is_top":false,"comment_ctime":1653635746,"is_pvip":false,"replies":[{"id":126577,"content":"free 的参数类型是 void*，非强类型。它不管你内存是怎么使用的：只要你给 free 的是 malloc 得到的指针并之前没有释放过，操作就应该成功——把整个 malloc 分配的内存块释放掉。","user_name":"作者回复","user_name_real":"作者","uid":1645639,"ctime":1653783365,"ip_address":"","comment_id":347035,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师您好，我对free_mem最后一行free(ptr)有一些不大理解。这里的ptr类型是alloc_list_t*，这样是否只释放了head所占的memory而没有释放user object所占的memory呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":604799,"discussion_content":"不同翻译单元里的全局/静态对象的析构顺序没有保证。文中的技巧可以保证析构发生在所有包含了这个头文件的源文件里的全局/静态对象的析构之后。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676438114,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386652,"user_name":"转遍世界","can_delete":false,"product_type":"c1","uid":2006194,"ip_address":"江苏","ucode":"0783BFDDE87029","user_header":"https://static001.geekbang.org/account/avatar/00/1e/9c/b2/1a9beeb1.jpg","comment_is_top":false,"comment_ctime":1705290781,"is_pvip":false,"replies":[{"id":141018,"content":"这类问题没什么代码检测的好办法。只能使用外部工具，如 Address Sanitizer 和 Clang-Tidy。目前主要还是靠前者这样的运行期工具。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1705750998,"ip_address":"上海","comment_id":386652,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"你好吴老师，您这个内存调试实践代码主要是针对内存泄漏和重复释放的问题。但工作中基本用的是智能指针，这些问题出现的可能性不大。工作中主要的内存问题是野指针问题，比如数组越界访问，迭代器失效后访问非法内存，主要还是访问非法内存问题居多，请问如果想检查这类内存错误可以用代码去检测吗？还怎么去实现？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636182,"discussion_content":"这类问题没什么代码检测的好办法。只能使用外部工具，如 Address Sanitizer 和 Clang-Tidy。目前主要还是靠前者这样的运行期工具。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705750999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346834,"user_name":"H X","can_delete":false,"product_type":"c1","uid":1982957,"ip_address":"","ucode":"B73939E7C6A8B9","user_header":"https://static001.geekbang.org/account/avatar/00/1e/41/ed/31db8bce.jpg","comment_is_top":false,"comment_ctime":1653467324,"is_pvip":false,"replies":[{"id":126527,"content":"Valgrind 使用 GPL v2 发布，显然你可以自己去修改它的源代码。\n\nstill unreachable 我怀疑是真正的泄漏而不是内存碎片。你可以换用其他的内存检测工具试一下。C++ 理论上现在应该不容易产生内存泄漏了，如果你不用有所有权的裸指针的话——确实很少再有理由用了。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1653628967,"ip_address":"","comment_id":346834,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"请问 1 .valgrind的内存检测工具 memcheck 和massif 这两个，能否根据我自己的项目 对其源码进行修改。最小影响的 检测我的项目中内存泄漏问题。2、cpp中没有jvm的GC。我用valgrind memcheck查出很多 still reachable。我理解这是内存碎片（vector和string频繁增删数据导致的）针对still reachable 有好的办法解决吗？多谢老师","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573752,"discussion_content":"Valgrind 使用 GPL v2 发布，显然你可以自己去修改它的源代码。\n\nstill unreachable 我怀疑是真正的泄漏而不是内存碎片。你可以换用其他的内存检测工具试一下。C++ 理论上现在应该不容易产生内存泄漏了，如果你不用有所有权的裸指针的话——确实很少再有理由用了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653628967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":380334,"user_name":"Geek_595be5","can_delete":false,"product_type":"c1","uid":3242942,"ip_address":"新加坡","ucode":"5C29AC709897C0","user_header":"https://static001.geekbang.org/account/avatar/00/31/7b/be/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1693388991,"is_pvip":false,"replies":[{"id":138522,"content":"在目前我的用法下，拿到引用立即调用另一个函数（而不是保存下来），是没有问题了。这里主要关注性能，而不是防误用。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1693463528,"ip_address":"上海","comment_id":380334,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"请问上面示例中get_current_context函数返回的是引用会不会不安全，毕竟因stack实现不同，可以通过pop、push对之前的引用造成内容擦写","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":626876,"discussion_content":"在目前我的用法下，拿到引用立即调用另一个函数（而不是保存下来），是没有问题了。这里主要关注性能，而不是防误用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1693463528,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371650,"user_name":"tony","can_delete":false,"product_type":"c1","uid":1131361,"ip_address":"安徽","ucode":"1160371C7F473E","user_header":"https://static001.geekbang.org/account/avatar/00/11/43/61/eeefa369.jpg","comment_is_top":false,"comment_ctime":1680147658,"is_pvip":false,"replies":[{"id":135696,"content":"我没看懂你的问题。分配的内存大小是强制对齐的，也跟“后续内存地址中的内容”是不是0完全没有关系……","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1680525788,"ip_address":"广东","comment_id":371650,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"convert_use_ptr中计算usr_ptr的长度是否在任何情况下都没有问题？比如分配的内存大小正好是对齐的且后续内存地址中的内容也不为0。谢谢老师。\n“auto offset =\n    static_cast&lt;byte*&gt;(usr_ptr) -\n    static_cast&lt;byte*&gt;(nullptr);”","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612131,"discussion_content":"我没看懂你的问题。分配的内存大小是强制对齐的，也跟“后续内存地址中的内容”是不是0完全没有关系……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680525788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368533,"user_name":"awmthink","can_delete":false,"product_type":"c1","uid":1331202,"ip_address":"广东","ucode":"742915BBCE7111","user_header":"https://static001.geekbang.org/account/avatar/00/14/50/02/cce1cf67.jpg","comment_is_top":false,"comment_ctime":1676429776,"is_pvip":false,"replies":[{"id":134217,"content":"不同翻译单元里的全局&#47;静态对象的析构顺序没有保证。文中的技巧可以保证析构发生在所有包含了这个头文件的源文件里的全局&#47;静态对象的析构之后。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1676438114,"ip_address":"广东","comment_id":368533,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"吴老师，请问：memory_trace里 “使用 RAII 计数对象来尽可能延迟对 check_leaks 的调用” 怎么理解呢？我看代码时，是把check_leaks调用放在了一个static对象的析构里，和全局对象invoke_check_leak相比，行为有什么不同吗？（防止有其他编译模块定义的全局对象生命周期比invoke_check_leak更长吗？）","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":604799,"discussion_content":"不同翻译单元里的全局/静态对象的析构顺序没有保证。文中的技巧可以保证析构发生在所有包含了这个头文件的源文件里的全局/静态对象的析构之后。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676438114,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347035,"user_name":"ericaaa","can_delete":false,"product_type":"c1","uid":3005568,"ip_address":"","ucode":"5E1AA008081DBC","user_header":"","comment_is_top":false,"comment_ctime":1653635746,"is_pvip":false,"replies":[{"id":126577,"content":"free 的参数类型是 void*，非强类型。它不管你内存是怎么使用的：只要你给 free 的是 malloc 得到的指针并之前没有释放过，操作就应该成功——把整个 malloc 分配的内存块释放掉。","user_name":"作者回复","user_name_real":"作者","uid":1645639,"ctime":1653783365,"ip_address":"","comment_id":347035,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师您好，我对free_mem最后一行free(ptr)有一些不大理解。这里的ptr类型是alloc_list_t*，这样是否只释放了head所占的memory而没有释放user object所占的memory呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573984,"discussion_content":"free 的参数类型是 void*，非强类型。它不管你内存是怎么使用的：只要你给 free 的是 malloc 得到的指针并之前没有释放过，操作就应该成功——把整个 malloc 分配的内存块释放掉。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653783366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}