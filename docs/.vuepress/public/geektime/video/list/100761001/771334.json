{"id":771334,"title":"07｜类的声明与使用","content":"","comments":[{"had_liked":false,"id":396084,"user_name":"醉聆风语","can_delete":false,"product_type":"c3","uid":1059117,"ip_address":"北京","ucode":"2A287325F83373","user_header":"https://static001.geekbang.org/account/avatar/00/10/29/2d/83a29c82.jpg","comment_is_top":false,"comment_ctime":1733024088,"is_pvip":false,"replies":[{"id":143818,"content":"版本问题？我这里是报错的。\n```\n属性 &quot;#a&quot; 在类 &quot;A&quot; 外部不可访问，因为它具有专用标识符。\n```\nTS 5.6.3\nVSCode 1.95.3","user_name":"作者回复","user_name_real":"编辑","uid":1521669,"ctime":1733250279,"ip_address":"江苏","comment_id":396084,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100761001,"comment_content":"class A{\n    #a = 1;\n}\nvar a = new A;\na.#a=2;\nconsole.log(a.#a)；\n控制台为什么不报错","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":654691,"discussion_content":"版本问题？我这里是报错的。\n```\n属性 &#34;#a&#34; 在类 &#34;A&#34; 外部不可访问，因为它具有专用标识符。\n```\nTS 5.6.3\nVSCode 1.95.3","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1733250279,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":1,"child_discussions":[{"author":{"id":1059117,"avatar":"https://static001.geekbang.org/account/avatar/00/10/29/2d/83a29c82.jpg","nickname":"醉聆风语","note":"","ucode":"2A287325F83373","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":654699,"discussion_content":"在最新的Chrome浏览器控制台直接复制粘贴执行没有报错呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1733275948,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":654691,"ip_address":"北京","group_id":0},"score":654699,"extra":""}]}]},{"had_liked":false,"id":390620,"user_name":"Jack Q","can_delete":false,"product_type":"c3","uid":1160078,"ip_address":"广东","ucode":"A7DBC311884FFA","user_header":"https://static001.geekbang.org/account/avatar/00/11/b3/8e/1c564eb2.jpg","comment_is_top":false,"comment_ctime":1715780132,"is_pvip":false,"replies":[{"id":142081,"content":"首先，你的第2个猜想是对的。\n\n接下来，先说说“为什么要有XXX.d.ts”。这是TypeScript在使用tsc编译一份用户A.ts文件时，可以使用的“（类型库或模块XXX的）类型声明文件”。——注意，这里存在一个“隐藏限制”，即XXX.d.ts的出现，意味着TypeScript要有能力在“不参考XXX.ts任何代码”的前提下，完成对A.ts的编译。\n\n那么回到你的第2个猜想，如果有一个实例x，要检查它是不是兼容可以赋给class A的类型。在比如x.b时，就需要考虑一个问题：x需要有&#39;b&#39;这个成员，但不需要考虑&#39;a&#39;的类型，因为A.b在.d.ts中声明为“私有的（private）”——这意味着：1、在.js中它应该存在于一个对象实例上，以便可以访问；2、但又不需要考虑它的类型，因为它不会被外部存取；3、它可能在“@ts-ignore”的模式下被访问，但没有类型限制。\n\n主要是缘于上述的第3条，所以.d.ts中“需要声明&#39;b&#39;属性是存在的，但又不需要声明出类型”。\n\n至于第1个问题，其实也与我们上面的说明有关。\n\n如果没有Class A的源代码定义（就是在.js代码中如果显式地访问了哪些#x私有字段），那么想检查实例x是不是可以兼容Class A，“最简单和经济”的方法就是指明x是否存在一个#private私有槽。如果没有，显然x不能赋给一个“需要访问私有成员的Class A”。\n\n当然，即使x有#private私有槽，也不一定真的就是Class A的实例，因为这里还显然包括了Class A的所有子类，以及其它任何类的、实现了interface A的那些类或对象。——它们可能包含了#private私有槽（有私有成员）而并不兼容Class A。但是在这一点上，如果TypeScript要提供绝对安全的类型检查，就必须track全部类型和子类型的私有字段和类型，这对TypeScript来说就“太不经济”了。\n\n所以上面才说这是“最简单和经济”的方法：只检查“有否私有槽”，而不是检查每一个私有成员。\n\n最后，某种程度上来说，它也约束了运行.js或编译.ts所需要的版本，因为如果一个接口&#47;类的.d.ts中有#private这个声明，那么就意味着对应的js&#47;ts环境，以及提供这个.d.ts模块的库都必须支持到ES2022。——一个低版本的模块（中的类）显然不可能实现这个接口。","user_name":"作者回复","user_name_real":"编辑","uid":1521669,"ctime":1715828868,"ip_address":"江苏","comment_id":390620,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100761001,"comment_content":"declare class A {\n    #private;\n    a: boolean;\n    private b;\n    readonly d?: string;\n    constructor();\n    foo(): void;\n    as1(other: A): boolean;\n    as2(other: A): boolean;\n}\n疑问: \n1  .d.ts 这里为什么会将 #开头的内容合并为 #private ? \n2  private b 为什么会 没有 number这个具体的类型定义，类比 readonly d 是有 string 的具体定义的\n(个人猜想，因为 外部 是无法访问 私有属性的，所以不需要 提供私有属性的具体类型)","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645155,"discussion_content":"首先，你的第2个猜想是对的。\n\n接下来，先说说“为什么要有XXX.d.ts”。这是TypeScript在使用tsc编译一份用户A.ts文件时，可以使用的“（类型库或模块XXX的）类型声明文件”。——注意，这里存在一个“隐藏限制”，即XXX.d.ts的出现，意味着TypeScript要有能力在“不参考XXX.ts任何代码”的前提下，完成对A.ts的编译。\n\n那么回到你的第2个猜想，如果有一个实例x，要检查它是不是兼容可以赋给class A的类型。在比如x.b时，就需要考虑一个问题：x需要有&#39;b&#39;这个成员，但不需要考虑&#39;a&#39;的类型，因为A.b在.d.ts中声明为“私有的（private）”——这意味着：1、在.js中它应该存在于一个对象实例上，以便可以访问；2、但又不需要考虑它的类型，因为它不会被外部存取；3、它可能在“@ts-ignore”的模式下被访问，但没有类型限制。\n\n主要是缘于上述的第3条，所以.d.ts中“需要声明&#39;b&#39;属性是存在的，但又不需要声明出类型”。\n\n至于第1个问题，其实也与我们上面的说明有关。\n\n如果没有Class A的源代码定义（就是在.js代码中如果显式地访问了哪些#x私有字段），那么想检查实例x是不是可以兼容Class A，“最简单和经济”的方法就是指明x是否存在一个#private私有槽。如果没有，显然x不能赋给一个“需要访问私有成员的Class A”。\n\n当然，即使x有#private私有槽，也不一定真的就是Class A的实例，因为这里还显然包括了Class A的所有子类，以及其它任何类的、实现了interface A的那些类或对象。——它们可能包含了#private私有槽（有私有成员）而并不兼容Class A。但是在这一点上，如果TypeScript要提供绝对安全的类型检查，就必须track全部类型和子类型的私有字段和类型，这对TypeScript来说就“太不经济”了。\n\n所以上面才说这是“最简单和经济”的方法：只检查“有否私有槽”，而不是检查每一个私有成员。\n\n最后，某种程度上来说，它也约束了运行.js或编译.ts所需要的版本，因为如果一个接口/类的.d.ts中有#private这个声明，那么就意味着对应的js/ts环境，以及提供这个.d.ts模块的库都必须支持到ES2022。——一个低版本的模块（中的类）显然不可能实现这个接口。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1715828868,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645158,"discussion_content":"还有一点可以补充的。\n\n在 @see https://github.com/microsoft/TypeScript/issues/38050 中对这个问题有一个近似官方的回复：“让带有 #p 私有字段的类在输出到 .d.ts 文件时保留其名义类型行为（retain their nominal typing behavior when emitted to a .d.ts file）”。名义类型和结构类型的相关概念，在第03讲的课件里面是明确地提供了的（所以，呵呵，同学们要记得下载课件跟学啊）。“保留名义类型行为”在这里的意思基本上是说，让Class A在它的类型描述中保留——“我的类型信息中含有私有字段，并且这会影响到我和我的显式派生的子类型”——这样一条信息。\n\n这“几乎”强制要求class A只能与通过extends A显式派生的子类型兼容（即所谓的名义类型兼容），而无法与“使用相同声明的结构类型”兼容。（NOTE：这很重要，请详细从课件中了解两种兼容的区别）。\n\n最后，如果你仔细思考，那么你会发现 @see https://stackoverflow.com/a/64827614 中关于这个问题的讨论/答案是不正确的。^^.","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1715830259,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645159,"discussion_content":"再有，“本课程的课件”在 @see https://github.com/aimingoo/jike2 这个仓库里。极客时间没有给出一个“重要的、明显的、官方的”位置来列出这个地址，真心对学员不友好……不友好度 +10 😡","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1715830410,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1160078,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b3/8e/1c564eb2.jpg","nickname":"Jack Q","note":"","ucode":"A7DBC311884FFA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":645161,"discussion_content":"确实没看到这个课件o(╥﹏╥)o","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1715831843,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":645159,"ip_address":"广东","group_id":0},"score":645161,"extra":""}]}]},{"had_liked":false,"id":390296,"user_name":"WGH丶","can_delete":false,"product_type":"c3","uid":1922568,"ip_address":"陕西","ucode":"02E43256770C62","user_header":"https://static001.geekbang.org/account/avatar/00/1d/56/08/bd75f114.jpg","comment_is_top":false,"comment_ctime":1715035105,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100761001,"comment_content":"private修饰构造方法，结合工厂方法，也可以很容易实现单例：\n\nclass MyClass {\n    private static instance: MyClass | undefined\n\n    private constructor() {\n    }\n\n    static create() {\n        if (MyClass.instance === undefined) {\n            MyClass.instance = new MyClass;\n        }\n\n        return MyClass.instance;\n    }\n}\n\nconst o = MyClass.create();","like_count":3},{"had_liked":false,"id":390619,"user_name":"Jack Q","can_delete":false,"product_type":"c3","uid":1160078,"ip_address":"广东","ucode":"A7DBC311884FFA","user_header":"https://static001.geekbang.org/account/avatar/00/11/b3/8e/1c564eb2.jpg","comment_is_top":false,"comment_ctime":1715779812,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100761001,"comment_content":"class A {\n    a = true\n    &#47;&#47; private 属性 不会被转译为 #\n    &#47;&#47; 原因 https:&#47;&#47;github.com&#47;microsoft&#47;TypeScript&#47;issues&#47;31670\n    private b:number = 1;\n    &#47;&#47; tsconfig 中 target 低于 2022 #会被编译为 WeakMaps 的实现\n    #c:number = 2;\n    &#47;&#47; readonly 属性 不会通过添加 defineProperty 设置 writable 的方式 控制可写属性 来实现 readonly\n    &#47;&#47; 原因 同 private\n    readonly d?: string;\n    &#47;&#47; 所有的#开头的属性在生成的 .d.ts 文件汇总 都会被合并成 #private\n    #e: string[] = []\n    constructor() {\n        &#47;&#47; 在typescript 中对于 optional 的 readonly 属性 只能在 构造函数中 初始化赋值\n        this.d = &#39;4&#39;;\n    }\n    foo() {\n        &#47;&#47; 非构造函数中不能对 readonly 属性赋值\n        this.d = &#39;2&#39;;\n    }\n    public as1(other: A) {\n        return other.b === this.b;\n    }\n    &#47;&#47; # 实现 private 的特性\n    public as2(other: A) {\n        return other.#c === this.#c;\n    }\n}\nconst a = new A;\nconsole.log(a.a)\n&#47;&#47; 因为 b 是 private 修饰的属性,所以在 js 代码中是可以访问的\n&#47;&#47; 但是 private 修饰的属性的 错误提示 与 # 这个前缀定义 (#是一种语法标记) 不同\n&#47;&#47; Property &#39;b&#39; is private and only accessible within class &#39;A&#39;\nconsole.log(a.b)\n&#47;&#47; Property &#39;#c&#39; is not accessible outside class &#39;A&#39; because it has a private identifier.\nconsole.log(a.#c)\n&#47;&#47; 只能在 chrome 的 devtool 中运行, devtool 对JavaScript 语法进行了放宽\n&#47;&#47; https:&#47;&#47;developer.mozilla.org&#47;en-US&#47;docs&#47;Web&#47;JavaScript&#47;Reference&#47;Classes&#47;Private_properties 中 说明了原因\n&#47;&#47; 其他的运行环境下都会报错 \n&#47;&#47; Private field &#39;#e&#39; must be declared in an enclosing class\nconsole.log(a.#e)\n&#47;&#47; readonly 会被编译为 可访问 属性\nconsole.log(a.d)","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645156,"discussion_content":"Oh~~ 这是另一个问题的示例代码。（呵呵，就另行回复了）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1715829294,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}