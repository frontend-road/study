{"id":740843,"title":"第 6 章 循环与可迭代对象","content":"\n<p>“循环”是一个非常有趣的概念。在生活中，循环代表无休止地重复某件事，比如一直播放同一首歌就叫“单曲循环”。当某件事重复太多次以后，人们就很容易感到乏味，所以哪怕再好听的旷世名曲，也没人愿意连续听上一百遍。</p>\n<p>虽然人会对循环感到乏味，计算机却丝毫没有这个问题。程序员的主要任务之一，就是利用循环的概念，用极少的指令驱使计算机不知疲倦地完成繁重的计算任务。</p>\n<p>试想一下，假如不使用循环，从一个包含一万个数字的列表里找到数字 42 的位置，会是一件多么令人抓狂的任务。但正因为有了循环，我们可以用一个简单的 <code>for</code> 来搞定这类事情——无论列表里的数字是一万个还是十万个。</p>\n<p>在 Python 中，我们可以用两种方式编写循环：<code>for</code> 和 <code>while</code>。<code>for</code> 是我们最常用到的循环关键字，它的语法是 <code>for &lt;item&gt; in &lt;iterable&gt;</code>，需要配合一个可迭代对象 <code>iterable</code> 使用：</p>\n<pre class=\"code-rows\"><code># 循环打印列表里所有字符串的长度\nnames = ['foo', 'bar', 'foobar']\n\nfor name in names:\n    print(len(name))</code></pre>\n<p>Python 里的 <code>while</code> 循环和其他编程语言没什么区别。它的语法是 <code>while &lt;expression&gt;</code>，其中 <code>expression</code> 表达式是循环的成立条件，值为假时就中断循环。如果把上面的 <code>for</code> 循环翻译成 <code>while</code>，代码会变长不少：</p>\n<pre class=\"code-rows\"><code>i = 0\nwhile i &lt; len(names):\n    print(len(names[i]))\n    i += 1</code></pre>\n<p>对比这两段代码，我们可以观察到：对于一些常见的循环任务，使用 <code>for</code> 比 <code>while</code> 要方便得多。因此在日常编码中，<code>for</code> 的出场频率也远比 <code>while</code> 要高得多。</p>\n<p>如你所见，Python 的循环语法并不复杂，但这并不代表我们可以很轻松地写出好的循环。要把循环代码写得漂亮，有时关键不在循环结构自身，而在于另一个用来配合循环的主角：可迭代对象。</p><!-- [[[read_end]]] -->\n<p>在本章中，我会分享在 Python 里编写循环的一些经验和技巧，帮助你掌握如何利用可迭代对象写出更优雅的循环。</p>\n<h2 id=\"nav_point_103\">6.1　基础知识</h2>\n<h3 id=\"nav_point_104\">6.1.1　迭代器与可迭代对象</h3>\n<p>我们知道，在编写 <code>for</code> 循环时，不是所有对象都可以用作循环主体——只有那些<strong>可迭代</strong>（iterable）对象才行。说到可迭代对象，你最先想到的肯定是那些内置类型，比如字符串、生成器以及第 3 章介绍的所有容器类型，等等。</p>\n<p>除了这些内置类型外，你其实还可以轻松定义其他可迭代类型。但在此之前，我们需要先搞清楚 Python 里的“迭代”究竟是怎么一回事。这就需要引入两个重要的内置函数：<code>iter()</code> 和 <code>next()</code>。</p>\n<ol>\n<li><p><strong><code>iter()</code> 与 <code>next()</code> 内置函数</strong></p>\n<p>还记得内置函数 <code>bool()</code> 吗？我在第 4 章中介绍过，使用 <code>bool()</code> 可以获取某个对象的布尔真假值：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; bool('foo')\nTrue</code></pre>\n<p>而 <code>iter()</code> 函数和 <code>bool()</code> 很像，调用 <code>iter()</code> 会尝试返回一个迭代器对象。拿常见的内置可迭代类型举例：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; iter([1, 2, 3]) ➊\n&lt;list_iterator object at 0x101a82d90&gt;\n\n&gt;&gt;&gt; iter('foo') ➋\n&lt;str_iterator object at 0x101a99ed0&gt;\n\n&gt;&gt;&gt; iter(1) ➌\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: 'int' object is not iterable</code></pre>\n<blockquote>\n<p>❶ 列表类型的迭代器对象——<code>list_iterator</code></p>\n<p>❷ 字符串类型的迭代器对象——<code>str_iterator</code></p>\n<p>❸ 对不可迭代的类型执行 <code>iter()</code> 会抛出 <code>TypeError</code> 异常</p>\n</blockquote>\n<p>什么是<strong>迭代器</strong>（iterator）？顾名思义，这是一种帮助你迭代其他对象的对象。迭代器最鲜明的特征是：不断对它执行 <code>next()</code> 函数会返回下一次迭代结果。</p>\n<p>拿列表举例：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; l = ['foo', 'bar']\n\n# 首先通过 iter 函数拿到列表 l 的迭代器对象\n&gt;&gt;&gt; iter_l = iter(l)\n&gt;&gt;&gt; iter_l\n&lt;list_iterator object at 0x101a8c6d0&gt;\n\n# 然后对迭代器调用 next() 不断获取列表的下一个值\n&gt;&gt;&gt; next(iter_l)\n'foo'\n&gt;&gt;&gt; next(iter_l)\n'bar'</code></pre>\n<p>当迭代器没有更多值可以返回时，便会抛出 <code>StopIteration</code> 异常：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; next(iter_l)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nStopIteration</code></pre>\n<p>除了可以使用 <code>next()</code> 拿到迭代结果以外，迭代器还有一个重要的特点，那就是当你对迭代器执行 <code>iter()</code> 函数，尝试获取迭代器的迭代器对象时，返回的结果一定是迭代器本身：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; iter_l\n&lt;list_iterator object at 0x101a82d90&gt;\n&gt;&gt;&gt; iter(iter_l) is iter_l\nTrue</code></pre>\n<p>了解完上述概念后，其实你就已经了解了 <code>for</code> 循环的工作原理。当你使用 <code>for</code> 循环遍历某个可迭代对象时，其实是先调用了 <code>iter()</code> 拿到它的迭代器，然后不断地用 <code>next()</code> 从迭代器中获取值。</p>\n<p>也就是说，下面这段 <code>for</code> 循环代码：</p>\n<pre class=\"code-rows\"><code>names = ['foo', 'bar', 'foobar']\n\nfor name in names:\n    print(name)</code></pre>\n<p>其实可以翻译成下面这样：</p>\n<pre class=\"code-rows\"><code>iterator = iter(names)\nwhile True:\n    try:\n        name = next(iterator)\n        print(name)\n    except StopIteration:\n        break</code></pre>\n<p>搞清楚迭代的原理后，接下来我们尝试创建自己的迭代器。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>自定义迭代器</strong></p>\n<p>要自定义一个迭代器类型，关键在于实现下面这两个魔法方法。</p>\n<ul>\n<li><code>__iter__</code>：调用 <code>iter()</code> 时触发，迭代器对象总是返回自身。</li>\n<li><code>__next__</code>：调用 <code>next()</code> 时触发，通过 <code>return</code> 来返回结果，没有更多内容就抛出 <code>StopIteration</code> 异常，<strong>会在迭代过程中多次触发</strong>。</li>\n</ul>\n<p>举一个具体的例子。假如我想编写一个和 <code>range()</code> 类似的迭代器对象 <code>Range7</code>，它可以返回某个范围内所有可被 7 整除或包含 7 的整数。</p>\n<p>下面是 <code>Range7</code> 类的代码：</p>\n<pre class=\"code-rows\"><code>class Range7:\n    \"\"\"生成某个范围内可被 7 整除或包含 7 的整数\n\n    :param start: 开始数字\n    :param end: 结束数字\n    \"\"\"\n\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n        # 使用 current 保存当前所处的位置\n        self.current = start\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        while True:\n       # 当已经到达边界时，抛出异常终止迭代\n       if self.current &gt;= self.end:\n           raise StopIteration\n\n       if self.num_is_valid(self.current):\n           ret = self.current\n           self.current += 1\n           return ret\n       self.current += 1\n\n    def num_is_valid(self, num):\n        \"\"\"判断数字是否满足要求\"\"\"\n        if num == 0:\n            return False\n        return num % 7 == 0 or '7' in str(num)</code></pre>\n<p>我们可以通过 <code>for</code> 循环来验证这个迭代器的执行效果：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; r = Range7(0, 20)\n&gt;&gt;&gt; for num in r:\n...     print(num)\n...\n7\n14\n17</code></pre>\n<p>遍历 <code>Range7</code> 对象时，它确实会不断返回符合要求的数字。</p>\n<p>不过，虽然上面的代码满足需求，但在进一步使用时，我们会发现现在的 <code>Range7</code> 对象有一个问题，那就是每个新 <code>Range7</code> 对象只能被完整遍历一次，假如做二次遍历，就会拿不到任何结果：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; r = Range7(0, 20)\n&gt;&gt;&gt; tuple(r)\n(7, 14, 17)\n&gt;&gt;&gt; tuple(r) ➊</code></pre>\n<blockquote>\n<p>❶ 第二次用 <code>tuple()</code> 转换成元组，只能得到一个空元组</p>\n</blockquote>\n<p>这个问题并非 <code>Range7</code> 所独有，它其实是所有迭代器的“通病”。</p>\n<p>如果你回过头仔细读一遍 <code>Range7</code> 的代码，肯定可以发现它在二次遍历时不返回结果的原因。</p>\n<p>在之前的代码里，每个 <code>Range7</code> 对象都只有唯一的 <code>current</code> 属性，当程序第一次遍历完迭代器后，<code>current</code> 就会不断增长为边界值 <code>self.end</code>。之后，除非手动重置 <code>current</code> 的值，否则二次遍历自然就不会再拿到任何结果。</p>\n<p>那到底要如何调整代码，才能让 <code>Range7</code> 对象可以被重复使用呢？这需要先从“迭代器”和“可迭代对象”的区别说起。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>区分迭代器与可迭代对象</strong></p>\n<p>迭代器与可迭代对象这两个词虽然看上去很像，但它们的含义大不相同。</p>\n<p>迭代器是可迭代对象的一种。它最常出现的场景是在迭代其他对象时，作为一种介质或工具对象存在——就像调用 <code>iter([])</code> 时返回的 <code>list_iterator</code>。每个迭代器都对应一次完整的迭代过程，因此它自身必须保存与当前迭代相关的状态——迭代位置（就像 <code>Range7</code> 里面的 <code>current</code> 属性）。</p>\n<p>一个合法的迭代器，必须同时实现 <code>__iter__</code> 和 <code>__next__</code> 两个魔法方法。</p>\n<p>相比之下，可迭代对象的定义则宽泛许多。判断一个对象 <code>obj</code> 是否可迭代的唯一标准，就是调用 <code>iter(obj)</code>，然后看结果是不是一个迭代器 <span class=\"comment-number\">1</span>。因此，可迭代对象只需要实现 <code>__iter__</code> 方法，不一定得实现 <code>__next__</code> 方法。</p>\n<p>所以，如果想让 <code>Range7</code> 对象在每次迭代时都返回完整结果，我们必须把现在的代码拆成两部分：可迭代类型 <code>Range7</code> 和迭代器类型 <code>Range7Iterator</code>。代码如下所示：</p>\n<pre class=\"code-rows\"><code>class Range7:\n    \"\"\"生成某个范围内可被 7 整除或包含 7 的数字\"\"\"\n\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n\n    def __iter__(self):\n        # 返回一个新的迭代器对象\n        return Range7Iterator(self)\n　\n　\nclass Range7Iterator:\n    def __init__(self, range_obj):\n        self.range_obj = range_obj\n        self.current = range_obj.start\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        while True:\n            if self.current &gt;= self.range_obj.end:\n                raise StopIteration\n\n            if self.num_is_valid(self.current):\n                ret = self.current\n                self.current += 1\n                return ret\n            self.current += 1\n\n    def num_is_valid(self, num):\n        if num == 0:\n            return False\n        return num % 7 == 0 or '7' in str(num)</code></pre>\n<p>在新代码中，每次遍历 <code>Range7</code> 对象时，都会创建出一个全新的迭代器对象 <code>Range7Iterator</code>，之前的问题因此可以得到圆满解决：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; r = Range7(0, 20)\n\n&gt;&gt;&gt; tuple(r)\n(7, 14, 17)\n\n&gt;&gt;&gt; tuple(r) ➊\n(7, 14, 17)</code></pre>\n<blockquote>\n<p>❶ <code>Range7</code> 类型现在可以被重复迭代了</p>\n</blockquote>\n<p>最后，总结一下迭代器与可迭代对象的区别：</p>\n<ul>\n<li>可迭代对象不一定是迭代器，但迭代器一定是可迭代对象；</li>\n<li>对可迭代对象使用 <code>iter()</code> 会返回迭代器，迭代器则会返回其自身；</li>\n<li>每个迭代器的被迭代过程是一次性的，可迭代对象则不一定；</li>\n<li>可迭代对象只需要实现 <code>__iter__</code> 方法，而迭代器要额外实现 <code>__next__</code> 方法。</li>\n</ul>\n<blockquote>\n<p><strong>可迭代对象与 <code>__getitem__</code></strong></p>\n<p>除了 <code>__iter__</code> 和 <code>__next__</code> 方法外，还有一个魔法方法也和可迭代对象密切相关：<code>__getitem__</code>。</p>\n<p>如果一个类型没有定义 <code>__iter__</code>，但是定义了 <code>__getitem__</code> 方法，那么 Python 也会认为它是可迭代的。在遍历它时，解释器会不断使用数字索引值(0, 1, 2, …)来调用<code>__getitem__</code> 方法获得返回值，直到抛出 <code>IndexError</code> 为止。</p>\n<p>但 <code>__getitem__</code> 可遍历的这个特点不属于目前主流的迭代器协议，更多是对旧版本的一种兼容行为，所以本章不做过多阐述。</p>\n</blockquote>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>生成器是迭代器</strong></p>\n<p>在第 3 章中我简单介绍过生成器对象。我们知道，生成器是一种“懒惰的”可迭代对象，使用它来替代传统列表可以节约内存，提升执行效率。</p>\n<p>但除此之外，生成器还是一种简化的迭代器实现，使用它可以大大降低实现传统迭代器的编码成本。因此在平时，我们基本不需要通过 <code>__iter__</code> 和 <code>__next__</code> 来实现迭代器，只要写上几个 <code>yield</code> 就行。</p>\n<p>如果利用生成器，上面的 <code>Range7Iterator</code> 可以改写成一个只有 5 行代码的函数：</p>\n<pre class=\"code-rows\"><code>def range_7_gen(start, end):\n    \"\"\"生成器版本的 Range7Iterator\"\"\"\n    num = start\n    while num &lt; end:\n        if num != 0 and (num % 7 == 0 or '7' in str(num)):\n            yield num\n        num += 1</code></pre>\n<p>我们可以用 <code>iter()</code> 和 <code>next()</code> 函数来验证“生成器就是迭代器”这个事实：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; nums = range_7_gen(0, 20)\n\n# 使用 iter() 函数测试\n&gt;&gt;&gt; iter(nums)\n&lt;generator object range_7_gen at 0x10404b2e0&gt;\n&gt;&gt;&gt; iter(nums) is nums\nTrue\n\n# 使用 next() 不断获取下一个值\n&gt;&gt;&gt; next(nums)\n7\n&gt;&gt;&gt; next(nums)\n14</code></pre>\n<p><strong>生成器</strong>（generator）利用其简单的语法，大大降低了迭代器的使用门槛，是优化循环代码时最得力的帮手。</p>\n</li>\n</ol>\n\n<h3 id=\"nav_point_105\">6.1.2　修饰可迭代对象优化循环</h3>\n<p>对于学过其他编程语言的人来说，假如需要在遍历一个列表的同时，获取当前索引位置，他很可能会写出这样的代码：</p>\n<pre class=\"code-rows\"><code>index = 0\nfor name in names:\n    print(index, name)\n    index += 1</code></pre>\n<p>上面的循环虽然没错，但并不是最佳做法。一个拥有两年 Python 开发经验的人会说，这段代码应该这么写：</p>\n<pre class=\"code-rows\"><code>for i, name in enumerate(names):\n    print(i, name)</code></pre>\n<p><code>enumerate()</code> 是 Python 的一个内置函数，它接收一个可迭代对象作为参数，返回一个不断生成 <code>( 当前下标 , 当前元素 )</code> 的新可迭代对象。对于这个场景，使用它再适合不过了。</p>\n<p>虽然 <code>enumerate()</code> 函数很简单，但它其实代表了一种循环代码优化思路：通过修饰可迭代对象来优化循环。</p>\n<h4>使用生成器函数修饰可迭代对象</h4>\n<p>什么是“修饰可迭代对象”？用一段简单的代码来说明：</p>\n<pre class=\"code-rows\"><code>def sum_even_only(numbers):\n    \"\"\"对 numbers 里面所有的偶数求和\"\"\"\n    result = 0\n    for num in numbers:\n        if num % 2 == 0:\n            result += num\n    return result</code></pre>\n<p>在这段代码的循环体内，我写了一条 <code>if</code> 语句来剔除所有奇数。但是，假如借鉴 <code>enumerate()</code> 函数的思路，我们其实可以把这个“奇数剔除逻辑”提炼成一个生成器函数，从而简化循环内部代码。</p>\n<p>下面就是我们需要的生成器函数 <code>even_only()</code>，它专门负责偶数过滤工作：</p>\n<pre class=\"code-rows\"><code>def even_only(numbers):\n    for num in numbers:\n        if num % 2 == 0:\n            yield num</code></pre>\n<p>之后在 <code>sum_even_only_v2()</code> 里，只要先用 <code>even_only()</code> 函数修饰 <code>numbers</code> 变量，循环内的“偶数过滤”逻辑就可以完全去掉，只需简单求和即可：</p>\n<pre class=\"code-rows\"><code>def sum_even_only_v2(numbers):\n    \"\"\"对 numbers 里面所有的偶数求和\"\"\"\n    result = 0\n    for num in even_only(numbers):\n        result += num\n    return result</code></pre>\n<p>总结一下，“修饰可迭代对象”是指用生成器（或普通的迭代器）在循环外部包装原本的循环主体，完成一些原本必须在循环内部执行的工作——比如过滤特定成员、提供额外结果等，以此简化循环代码。</p>\n<p>除了自定义修饰函数外，你还可以直接使用标准库模块 <code>itertools</code> 里的许多现成工具。</p>\n<h3 id=\"nav_point_106\">6.1.3　使用 <code>itertools</code> 模块优化循环</h3>\n<p><code>itertools</code> 是一个和迭代器有关的标准库模块，其中包含许多用来处理可迭代对象的工具函数。在该模块的官方文档里，你可以找到每个函数的详细介绍与说明。</p>\n<p>在本节中，我会对 <code>itertools</code> 里的部分函数做简单介绍，但侧重点会和官方文档稍有不同。我会通过一些常见的代码场景，来详细解释 <code>itertools</code> 是如何改善循环代码的。</p>\n<ol>\n<li><p><strong>使用 <code>product()</code> 扁平化多层嵌套循环</strong></p>\n<p>虽然我们都知道：“扁平优于嵌套”，但有时针对某类需求，似乎得写一些多层嵌套循环才行。下面这个函数就是一个例子：</p>\n<pre class=\"code-rows\"><code>def find_twelve(num_list1, num_list2, num_list3):\n    \"\"\"从 3 个数字列表中，寻找是否存在和为 12 的 3 个数\"\"\"\n    for num1 in num_list1:\n        for num2 in num_list2:\n            for num3 in num_list3:\n                if num1 + num2 + num3 == 12:\n                    return num1, num2, num3</code></pre>\n<p>对于这种嵌套遍历多个对象的多层循环代码，我们可以使用 <code>product()</code> 函数来优化它。<code>product()</code> 接收多个可迭代对象作为参数，然后根据它们的笛卡儿积不断生成结果：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; from itertools import product\n&gt;&gt;&gt; list(product([1, 2], [3, 4]))\n[(1, 3), (1, 4), (2, 3), (2, 4)]</code></pre>\n<p>用 <code>product()</code> 优化函数里的嵌套循环：</p>\n<pre class=\"code-rows\"><code>from itertools import product\n　\n　\ndef find_twelve_v2(num_list1, num_list2, num_list3):\n    for num1, num2, num3 in product(num_list1, num_list2, num_list3):\n        if num1 + num2 + num3 == 12:\n            return num1, num2, num3</code></pre>\n<p>相比之前，新函数只用了一层 <code>for</code> 循环就完成了任务，代码变得更精练了。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>使用 <code>islice()</code> 实现循环内隔行处理</strong></p>\n<p>假如有一份数据文件，里面包含某论坛的许多帖子标题，内容格式如下所示：</p>\n<pre>\npython-guide: Python best practices guidebook, written for humans.\n&#45;--\nPython 2 Death Clock\n&#45;--\nRun any Python Script with an Alexa Voice Command\n&#45;--\n&lt;... ...&gt;\n</pre>\n\n<p>我现在需要解析这个文件，拿到文件里的所有标题。</p>\n<p>可能是为了格式美观，这份文件里的每两个标题之间，都有一个“<code>---</code>”分隔符。它给我的解析工作带来了一点儿小麻烦——在遍历过程中，我必须跳过这些无意义的符号。</p>\n<p>利用 <code>enumerate()</code> 内置函数，我可以直接在循环内加一段基于当前序号的 <code>if</code> 判断来做到这一点：</p>\n<pre class=\"code-rows\"><code>def parse_titles(filename):\n    \"\"\"从隔行数据文件中读取 Reddit 主题名称\n    \"\"\"\n    with open(filename, 'r') as fp:\n        for i, line in enumerate(fp):\n            # 跳过无意义的 --- 分隔符\n            if i % 2 == 0:\n                yield line.strip()</code></pre>\n<p>但是，对于这类在循环内隔行处理的需求来说，如果使用 <code>itertools</code> 里的 <code>islice()</code> 函数修饰被循环对象，整段循环代码可以变得更简单、更直接。</p>\n<p><code>islice(seq, start, end, step)</code> 函数和数组切片操作（<code>list[start:stop:step]</code>）接收的参数几乎完全一致。如果需要在循环内部实现隔行处理，只要设置第三个参数 <code>step</code>（递进步长）的值为 <code>2</code> 即可：</p>\n<pre class=\"code-rows\"><code>from itertools import islice\n\ndef parse_titles_v2(filename):\n    with open(filename, 'r') as fp:\n        # 设置 step=2，跳过无意义的 --- 分隔符\n        for line in islice(fp, 0, None, 2):\n            yield line.strip()</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>使用 <code>takewhile()</code> 替代 <code>break</code> 语句</strong></p>\n<p>有时，我们需要在每次开始执行循环体代码时，决定是否需要提前结束循环，比如：</p>\n<pre class=\"code-rows\"><code>for user in users:\n    # 当第一个不合格的用户出现后，不再进行后面的处理\n    if not is_qualified(user):\n        break\n\n    # 进行处理……</code></pre>\n<p>对于这类代码，我们可以使用 <code>takewhile()</code> 函数来进行简化。</p>\n<p><code>takewhile(predicate, iterable)</code> 会在迭代第二个参数 <code>iterable</code> 的过程中，不断使用当前值作为参数调用 <code>predicate()</code> 函数，并对返回结果进行真值测试，如果为 <code>True</code>，则返回当前值并继续迭代，否则立即中断本次迭代。</p>\n<p>使用 <code>takewhile()</code> 后代码会变成这样：</p>\n<pre class=\"code-rows\"><code>from itertools import takewhile\n\nfor user in takewhile(is_qualified, users):\n    # 进行处理……</code></pre>\n<p>除了上面这三个函数以外，<code>itertools</code> 还有其他一些有意思的工具函数，它们都可以搭配循环使用，比如用 <code>chain()</code> 函数可以扁平化双层嵌套循环、用 <code>zip_longest()</code> 函数可以同时遍历多个对象，等等。</p>\n<p>篇幅所限，此处不再一一介绍 <code>itertools</code> 的其他函数，读者如有兴趣可自行查阅官方文档。</p>\n</li>\n</ol>\n<h3 id=\"nav_point_107\">6.1.4　循环语句的 <code>else</code> 关键字</h3>\n<p>在 Python 语言的所有关键字里，<code>else</code> 也许是最奇特（或者说最“臭名昭著”）的一个。条件分支语句用 <code>else</code> 来表示“否则执行某件事”，异常捕获语句用 <code>else</code> 表示“没有异常就做某件事”。而在 <code>for</code> 和 <code>while</code> 循环结构里，人们同样也可以使用 <code>else</code> 关键字。</p>\n<p>举个例子，下面的 <code>process_tasks()</code> 函数里有个批量处理任务的 <code>for</code> 循环：</p>\n<pre class=\"code-rows\"><code>def process_tasks(tasks):\n    \"\"\"批量处理任务，如果遇到状态不为 pending 的任务，则中止本次处理\"\"\"\n    non_pending_found = False\n    for task in tasks:\n        if not task.is_pending():\n            non_pending_found = True\n            break\n        process(task)\n\n    if non_pending_found:\n        notify_admin('Found non-pending task, processing aborted.')\n    else:\n        notify_admin('All tasks was processed.')</code></pre>\n<p>函数会在执行结束时通知管理员。为了在不同情况（有或没有“<code>pending</code>”状态的任务）下发送不同通知，函数在循环开始前定义了一个标记变量 <code>non_pending_found</code>。</p>\n<p>假如利用循环语句的 <code>else</code> 分支，这份代码可缩减成下面这样：</p>\n<pre class=\"code-rows\"><code>def process_tasks(tasks):\n    \"\"\"批量处理任务，如果遇到状态不为 pending 的任务，则中止本次处理\"\"\"\n    for task in tasks:\n        if not task.is_pending():\n            notify_admin('Found non-pending task, processing aborted.')\n            break\n        process(task)\n    else:\n        notify_admin('All tasks was processed.')</code></pre>\n<p><code>for</code> 循环（和 <code>while</code> 循环）后的 <code>else</code> 关键字，代表如果循环正常结束（没有碰到任何 <code>break</code>），便执行该分支内的语句。因此，老式的“循环 + 标记变量”代码，就可以利用该特性简写为“循环 + <code>else</code> 分支”。看上去挺好，对吧？</p>\n<p>但不知你是否记得，在介绍异常语句的 <code>else</code> 分支时我说过，那里的 <code>else</code> 关键字很不直观、很难理解。而现在循环语句里的 <code>else</code> 与之相比，更是有过之而无不及。</p>\n<p>假如一个 Python 初学者读到上面的第二段代码，基本不可能猜到代码里的 <code>else</code> 分支到底是什么意思，而这正是糟糕的关键字的“功劳”。如果 Python 当初使用 <code>nobreak</code> 或 <code>then</code> 来替代 <code>else</code>，相信这个语言特性会比现在好理解得多。</p>\n<p>正因为如此，一些 Python 学习资料会建议大家避免使用循环里的 <code>else</code> 分支。理由很简单：因为和 <code>for...else</code> 所带来的高昂理解成本相比，它所提供的那点儿方便根本微不足道。但与此同时，也有更多资料把循环的 <code>else</code> 分支当成一种地道的 Python 写法，大力推荐他人使用。</p>\n<p>所以，到底该不该用 <code>for...else</code>？我其实很难给出一个权威建议。但能告诉你的是，和 <code>try...else</code> 比起来，我使用 <code>for...else</code> 的次数要少得多。</p>\n<p>举例来说，假如前面的 <code>process_tasks()</code> 函数在真实项目中出现，我极有可能会用“拆分子函数”的技巧来重构它。通过把循环结构拆分为一个独立函数，我可以完全避免“使用标记变量还是 <code>else</code> 分支”的艰难抉择：</p>\n<pre class=\"code-rows\"><code>def process_tasks(tasks):\n    \"\"\"批量处理任务并将结果通知管理员\"\"\"\n    if _process_tasks(tasks):\n        notify_admin('All tasks was processed.')\n    else:\n        notify_admin('Found non-pending task, processing aborted.')\n\n\ndef _process_tasks(tasks):\n    \"\"\"批量处理任务，如果遇到状态不为 pending 的任务，则中止本次处理\n\n    :return: 是否完全处理所有任务\n    :rtype: bool\n    \"\"\"\n    for task in tasks:\n        if not task.is_pending():\n            return False\n        process(task)\n    return True</code></pre>\n<h2 id=\"nav_point_108\">6.2　案例故事</h2>\n<p>在工作中，文件对象是我们最常接触到的可迭代类型之一。用 <code>for</code> 循环遍历一个文件对象，便可逐行读取它的内容。但这种方式在碰到大文件时，可能会出现一些奇怪的效率问题。在下面的故事中，小 R 就遇到了这个问题。</p>\n<h3 id=\"nav_point_109\">数字统计任务</h3>\n<p>小 R 是一位 Python 初学者，在学习了如何用 Python 读取文件后，他想要做一个小练习：计算某个文件中数字字符（0～9）的数量。</p>\n<p>参考了文件操作的相关文档后，他很快写出了如代码清单 6-1 所示的代码。</p>\n<blockquote>\n<p><strong>代码清单 6-1</strong>　标准的文件读取方式</p>\n</blockquote>\n<pre class=\"code-rows\"><code>def count_digits(fname):\n    \"\"\"计算文件里包含多少个数字字符\"\"\"\n    count = 0\n    with open(fname) as file:\n        for line in file:\n            for s in line:\n                if s.isdigit():\n                    count += 1\n    return count</code></pre>\n<p>小 R 的笔记本电脑中有一个测试用的小文件 small_file.txt，里面包含了一行行的随机字符串：</p>\n<pre class=\"code-rows\"><code>feiowe9322nasd9233rl\naoeijfiowejf8322kaf9a</code></pre>\n<p>把这个文件传入函数后，程序轻松计算出了数字字符的数量：</p>\n<pre class=\"code-rows\"><code>print(count_digits('small_file.txt'))\n# 输出结果: 13</code></pre>\n<p>不过奇怪的是，虽然 <code>count_digits()</code> 函数可以很快完成对 small_file.txt 的统计，但当小 R 把它用于另一个 5 GB 大的文件 big_file.txt 时，却发现程序花费了一分多钟才给出结果，并且整个执行过程耗光了笔记本电脑的全部 4G 内存。</p>\n<p>big_file.txt 的内容和 small_file.txt 没什么不同，也都是一些随机字符串而已。但在 big_file.txt 里，所有文本都放在了同一行：</p>\n<p><strong>大文件 big_file.txt</strong></p>\n<pre class=\"code-rows\"><code>df2if283rkwefh... &lt;剩余 5 GB 大小&gt; ...</code></pre>\n<p>为什么同一份代码用于大文件时，效率就会变低这么多呢？原因就藏在小 R 读取文件的方法里。</p>\n<ol>\n<li><p><strong>读取文件的标准做法</strong></p>\n<p>小 R 在代码里所使用的文件读取方式，可谓 Python 里的“标准做法”：首先用 <code>with open (fine_name)</code> 上下文管理器语法获得一个文件对象，然后用 <code>for</code> 循环迭代它，<strong>逐行</strong>获取文件里的内容。</p>\n<p>为什么这种文件读取方式会成为标准？这是因为它有两个好处：</p>\n<p>(1) <code>with</code> 上下文管理器会自动关闭文件描述符；</p>\n<p>(2) 在迭代文件对象时，内容是一行一行返回的，不会占用太多内存。</p>\n<p>不过这套标准做法虽好，但不是没有缺点。假如被读取的文件里根本就没有任何换行符，那么上面列的第 (2) 个好处就不再成立。缺少换行符以后，程序遍历文件对象时就不知道该何时中断，最终只能一次性生成一个巨大的字符串对象，白白消耗大量时间和内存。</p>\n<p>这就是 <code>count_digits()</code> 函数在处理 big_file.txt 时变得异常缓慢的原因。</p>\n<p>要解决这个问题，我们需要把这种读取文件的“标准做法”暂时放到一边。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>使用 <code>while</code> 循环加 <code>read()</code> 方法分块读取</strong></p>\n<p>除了直接遍历文件对象来逐行读取文件内容外，我们还可以调用更底层的 <code>file.read()</code> 方法。</p>\n<p>与直接用循环迭代文件对象不同，每次调用 <code>file.read(chunk_size)</code>,会马上读取从当前游标位置往后 <code>chunk_size</code> 大小的文件内容，不必等待任何换行符出现。</p>\n<p>有了 <code>file.read()</code> 方法的帮助，小 R 的函数可以改写代码清单 6-2。</p>\n<blockquote>\n<p><strong>代码清单 6-2</strong>　使用 <code>file.read()</code> 读取文件</p>\n</blockquote>\n<pre class=\"code-rows\"><code>def count_digits_v2(fname):\n    \"\"\"计算文件里包含多少个数字字符，每次读取 8 KB\"\"\"\n    count = 0\n    block_size = 1024 * 8\n    with open(fname) as file:\n        while True:\n            chunk = file.read(block_size)\n            # 当文件没有更多内容时，read 调用将会返回空字符串 ''\n            if not chunk:\n                break\n            for s in chunk:\n                if s.isdigit():\n                    count += 1\n    return count</code></pre>\n<p>在新函数中，我们使用了一个 <code>while</code> 循环来读取文件内容，每次最多读 8 KB，程序不再需要在内存中拼接长达数吉字节的字符串，内存占用会大幅降低。</p>\n<p>不过，新代码虽然解决了大文件读取时的性能问题，循环内的逻辑却变得更零碎了。如果使用 <code>iter()</code> 函数，我们可以进一步简化代码。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong><code>iter()</code> 的另一个用法</strong></p>\n<p>在 6.1.1 节中，我介绍过 <code>iter()</code> 是一个用来获取迭代器的内置函数，但除此之外，它其实还有另一个鲜为人知的用法。</p>\n<p>当我们以 <code>iter(callable, sentinel)</code> 的方式调用 <code>iter()</code> 函数时，会拿到一个特殊的迭代器对象。用循环遍历这个迭代器，会不断返回调用 <code>callable()</code> 的结果，假如结果等于 <code>sentinel</code>，迭代过程中止。</p>\n<p>利用这个特点，我们可以把上面的 <code>while</code> 重新改为 <code>for</code>，让循环内部变得更简单，如代码清单 6-3 所示。</p>\n<blockquote>\n<p><strong>代码清单 6-3</strong>　巧用 <code>iter()</code> 读取文件</p>\n</blockquote>\n<pre class=\"code-rows\"><code>from functools import partial\n\ndef count_digits_v3(fname):\n    count = 0\n    block_size = 1024 * 8\n    with open(fname) as fp:\n        # 使用 functools.partial 构造一个新的无须参数的函数\n        _read = partial(fp.read, block_size) ➊\n\n        # 利用 iter() 构造一个不断调用 _read 的迭代器\n        for chunk in iter(_read, ''):\n            for s in chunk:\n                if s.isdigit():\n                    count += 1\n    return count</code></pre>\n<blockquote>\n<p>❶ 你可以在 7.1.3 节找到 <code>partial</code> 工具函数的相关介绍</p>\n</blockquote>\n<p>完成改造后，我们再来看看新函数的性能如何。</p>\n<p>小 R 的旧程序需要 4 GB 内存，耗时超过一分钟，才能勉强完成 big_file.txt 的统计工作。而新代码只需要 7 MB 内存和 12 秒就能完成同样的事情——效率提升了近 4 倍，内存占用更是不到原来的 1%。</p>\n<p>解决了原有代码的性能问题后，小 R 很快又遇到了一个新问题。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>按职责拆解循环体代码</strong></p>\n<p>在 <code>count_digits_v3()</code> 函数里，小 R 实现了统计文件里所有数字的功能。现在，他又有了一个新任务：统计文件里面所有偶数字符 (0, 2, 4, 6, 8) 出现的次数。</p>\n<p>在实现新需求时，小 R 会发现一个让人心烦的问题：他无法复用已有的“按块读取大文件”的功能，只能把那片包含 <code>partial()</code>、<code>iter()</code> 的循环代码依样画葫芦照抄一遍。</p>\n<p>这是因为旧代码的循环内部存在两个独立的逻辑：“数据生成”（从文件里不断获取数字字符）与“数据消费”（统计个数）。这两个独立逻辑被放在了同一个循环体内，耦合在了一起。</p>\n<p>为了提升代码的可复用性，我们需要帮小 R 解耦。</p>\n<p>要解耦循环体，生成器（或迭代器）是首选。在这个案例中，我们可以定义一个新的生成器函数：<code>read_file_digits()</code>，由它来负责所有与“数据生成”相关的逻辑，如代码清单 6-4、代码清单 6-5、代码清单 6-6 所示。</p>\n<blockquote>\n<p><strong>代码清单 6-4</strong>　读取数字内容的生成器函数</p>\n</blockquote>\n<pre class=\"code-rows\"><code>def read_file_digits(fp, block_size=1024 * 8):\n    \"\"\"生成器函数：分块读取文件内容，返回其中的数字字符\"\"\"\n    _read = partial(fp.read, block_size)\n    for chunk in iter(_read, ''):\n        for s in chunk:\n            if s.isdigit():\n                yield s</code></pre>\n<p>这样 <code>count_digits_v4()</code> 里的主循环就只需要负责计数即可，代码如下所示。</p>\n<blockquote>\n<p><strong>代码清单 6-5</strong>　复用读取函数后的统计函数</p>\n</blockquote>\n<pre class=\"code-rows\"><code>def count_digits_v4(fname):\n    count = 0\n    with open(fname) as file:\n        for _ in read_file_digits(file):\n            count += 1\n    return count</code></pre>\n<p>当小 R 接到新任务，需要统计偶数时，可以直接复用 <code>read_file_digits()</code> 函数，代码如下所示。</p>\n<blockquote>\n<p><strong>代码清单 6-6</strong>　复用读取函数后的统计偶数函数</p>\n</blockquote>\n<pre class=\"code-rows\"><code>from collections import defaultdict\n\ndef count_even_groups(fname):\n    \"\"\"分别统计文件里每个偶数字符出现的次数\"\"\"\n    counter = defaultdict(int)\n    with open(fname) as file:\n        for num in read_file_digits(file):\n            if int(num) % 2 == 0:\n                counter[int(num)] += 1\n    return counter</code></pre>\n<p>实现新需求变得轻而易举。</p>\n<p>小 R 的故事告诉了我们一个道理。在编写循环时，我们需要时常问自己：循环体内的代码是不是过长、过于复杂了？如果答案是肯定的，那就试着把代码按职责分类，抽象成独立的生成器（或迭代器）吧。这样不光能让代码变得更整洁，可复用性也会极大提升。</p>\n</li>\n</ol>\n<h2 id=\"nav_point_110\">6.3　编程建议</h2>\n<h3 id=\"nav_point_111\">6.3.1　中断嵌套循环的正确方式</h3>\n<p>在 Python 里，当我们想要中断某个循环时，可以使用 <code>break</code> 语句。但有时，当程序需要马上从一个多层嵌套循环里中断时，一个 <code>break</code> 就会显得有点儿不够用。</p>\n<p>以下面这段代码为例：</p>\n<pre class=\"code-rows\"><code>def print_first_word(fp, prefix):\n    \"\"\"找到文件里第一个以指定前缀开头的单词并打印出来\n\n    :param fp: 可读文件对象\n    :param prefix: 需要寻找的单词前缀\n    \"\"\"\n    first_word = None\n    for line in fp:\n        for word in line.split():\n            if word.startswith(prefix):\n                first_word = word\n                # 注意：此处的 break 只能跳出最内层循环\n                break\n        # 一定要在外层加一个额外的 break 语句来判断是否结束循环\n        if first_word:\n            break\n\n    if first_word:\n        print(f'Found the first word startswith \"\": \"\"')\n    else:\n        print(f'Word starts with \"\" was not found.')</code></pre>\n<p><code>print_first_word()</code> 函数负责找到并打印某个文件里以特定前缀 <code>prefix</code> 开头的第一个单词，它的执行效果如下：</p>\n<pre class=\"code-rows\"><code># 找到匹配结果时\n$ python labeled_break.py --prefix=\"re\"\nFound the first word startswith \"re\": \"rename\"\n\n# 没找到匹结果配时\n$ python labeled_break.py --prefix=\"yy\"\nWord starts with \"yy\" was not found.</code></pre>\n<p>在上面的代码里，为了让程序在找到第一个单词时中断查找，我写了两个 <code>break</code>——内层循环一个，外层循环一个。这其实是不得已而为之，因为 Python 语言不支持“带标签的 <code>break</code>”语句 <span class=\"comment-number\">2</span>，无法用一个 <code>break</code> 跳出多层循环。</p>\n\n<p>但这样写其实并不好，这许许多多的 <code>break</code> 会让代码逻辑变得更难理解，也更容易出现 bug。</p>\n<p>如果想快速从嵌套循环里跳出，其实有个更好的做法，那就是把循环代码拆分为一个新函数，然后直接使用 <code>return</code>。</p>\n<p>比如，在下面这段代码里，我们可以把 <code>print_first_word()</code> 里的“寻找单词”部分拆分为一个独立函数：</p>\n<pre class=\"code-rows\"><code>def find_first_word(fp, prefix):\n    \"\"\"找到文件里第一个以指定前缀开头的单词并打印出来\n\n    :param fp: 可读文件对象\n    :param prefix: 需要寻找的单词前缀\n    \"\"\"\n    for line in fp:\n        for word in line.split():\n            if word.startswith(prefix):\n                return word\n    return None\n\ndef print_first_word(fp, prefix):\n    first_word = find_first_word(fp, prefix)\n    if first_word:\n        print(f'Found the first word startswith \"\": \"\"')\n    else:\n        print(f'Word starts with \"\" was not found.')</code></pre>\n<p>这样修改后，嵌套循环里的中断逻辑就变得更容易理解了。</p>\n<h3 id=\"nav_point_112\">6.3.2　巧用 <code>next()</code> 函数</h3>\n<p>我在 6.1.1 节中提到，内置函数 <code>next()</code> 是构成迭代器协议的关键函数。但在日常编码时，我们很少会直接用到 <code>next()</code>。这是因为在大部分场景下，循环语句可以满足普通迭代需求，不需要我们手动调用 <code>next()</code>。</p>\n<p>但 <code>next()</code> 函数其实很有趣。如果配合恰当的迭代器，<code>next()</code> 经常可以用很少的代码完成意想不到的功能。</p>\n<p>举个例子，假如有一个字典 <code>d</code>，你要怎么拿到它的第一个 <code>key</code> 呢？</p>\n<p>直接调用 <code>d.keys()[0]</code> 是不行的，因为字典键不是普通的容器对象，不支持切片操作：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; d = {'foo': 1, 'bar': 2}\n&gt;&gt;&gt; d.keys()[0]\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: 'dict_keys' object is not subscriptable</code></pre>\n<p>为了获取第一个 <code>key</code>，你必须把 <code>d.keys()</code> 先转换为普通列表才行：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; list(d.keys())[0]\n'foo'</code></pre>\n<p>但这么做有一个很大的缺点，那就是假如字典内容很多，<code>list()</code> 操作需要在内存中构建一个大列表，内存占用大，执行效率也比较低。</p>\n<p>假如使用 <code>next()</code>，你可以更简单地完成任务：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; next(iter(d.keys()))\n'foo'</code></pre>\n<p>只要先用 <code>iter()</code> 获取一个 <code>d.keys()</code> 的迭代器，再对它调用 <code>next()</code> 就能马上拿到第一个元素。这样做不需要遍历字典的所有 <code>key</code>，自然比先转换列表的方法效率更高。</p>\n<p>除此之外，在生成器对象上执行 <code>next()</code> 还能高效地完成一些元素查找类工作。</p>\n<p>假设有一个装了非常多整数的列表对象 <code>numbers</code>，我需要找到里面第一个可以被 7 整除的数字。除了编写传统的“<code>for</code> 循环配合 <code>break</code>”式代码，你也可以直接用 <code>next()</code> 配合生成器表达式来完成任务：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; numbers = [3, 6, 8, 2, 21, 30, 42]\n&gt;&gt;&gt; print(next(i for i in numbers if i % 7 == 0))\n21</code></pre>\n<h3 id=\"nav_point_113\">6.3.3　当心已被耗尽的迭代器</h3>\n<p>截至目前，我们已经见识了使用生成器的许多好处，比如相比列表更省内存、可以用来解耦循环体代码，等等。但任何事物都有其两面性，生成器或者说它的父类型迭代器，并非完美无缺，它们最大的陷阱之一是：会被耗尽。</p>\n<p>以下面这段代码为例：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; numbers = [1, 2, 3]\n\n# 使用生成器表达式创建一个新的生成器对象\n# 此时想象中的 numbers 内容为：2, 4, 6\n&gt;&gt;&gt; numbers = (i * 2 for i in numbers)</code></pre>\n<p>假如你连着对 <code>numbers</code> 做两次成员判断，程序会返回截然不同的结果：</p>\n<pre class=\"code-rows\"><code># 第一次 in 判断会触发生成器遍历，找到 4 后返回 True\n&gt;&gt;&gt; 4 in numbers\nTrue\n\n# 做第二次 in 判断时，生成器已被部分遍历过，无法再找到 4，因此返回意料外的结果 False\n&gt;&gt;&gt; 4 in numbers\nFalse</code></pre>\n<p>这种由生成器的“耗尽”特性所导致的 bug，隐蔽性非常强，当它出现在一些复杂项目中时，尤其难定位。比如 Instagram 团队就曾在 PyCon 2017 上分享过一个他们遇到的类似问题 <span class=\"comment-number\">3</span>。</p>\n\n<p>因此在平时，你需要将生成器（迭代器）的“可被一次性耗尽”特点铭记于心，避免写出由它所导致的 bug。假如要重复使用一个生成器，可以调用 <code>list()</code> 函数将它转成列表后再使用。</p>\n<blockquote>\n<p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100007/image00371.jpeg\" alt=\"\" width=\"5%\" style=\"width: 5%\" inline-img=\"true\" />　除了生成器函数、生成器表达式以外，人们还常常忽略内置的 <code>map()</code>、<code>filter()</code> 函数也会返回一个一次性的迭代器对象。在使用这些函数时，也请务必当心。</p>\n</blockquote>\n<h2 id=\"nav_point_114\">6.4　总结</h2>\n<p>本章我们学习了编写循环的相关知识。在 Python 里编写循环，关键不仅仅在于循环语法本身，更和可迭代类型息息相关。</p>\n<p>Python 里的对象迭代过程，有两个重要的参与者：<code>iter()</code> 与 <code>next()</code> 内置函数，它们分别对应两个重要的魔法方法：<code>__iter__</code> 和 <code>__next__</code> 。通过定义这两个魔法方法，我们可以快速创建自己的迭代器对象。</p>\n<p>要写出好的循环，要记住一个关键点——不要让循环体内的代码过于复杂。你可以把不同职责的代码作为独立的生成器函数拆分出去，这样能大大提升代码的可复用性。</p>\n<p>以下是本章要点知识总结。</p>\n<p>(1) 迭代与迭代器原理</p>\n<ul>\n<li>使用 <code>iter()</code> 函数会尝试获取一个迭代器对象</li>\n<li>使用 <code>next()</code> 函数会获取迭代器的下一个内容</li>\n<li>可以将 <code>for</code> 循环简单地理解为 <code>while</code> 循环 + 不断调用 <code>next()</code></li>\n<li>自定义迭代器需要实现 <code>__iter__</code> 和 <code>__next__</code> 两个魔法方法</li>\n<li>生成器对象是迭代器的一种</li>\n<li><code>iter(callable, sentinel)</code> 可以基于可调用对象构造一个迭代器</li>\n</ul>\n<p>(2) 迭代器与可迭代对象</p>\n<ul>\n<li>迭代器和可迭代对象是不同的概念</li>\n<li>可迭代对象不一定是迭代器，但迭代器一定是可迭代对象</li>\n<li>对可迭代对象使用 <code>iter()</code> 会返回迭代器，迭代器则会返回它自身</li>\n<li>每个迭代器的被迭代过程是一次性的，可迭代对象则不一定</li>\n<li>可迭代对象只需要实现 <code>__iter__</code> 方法，而迭代器要额外实现 <code>__next__</code> 方法</li>\n</ul>\n<p>(3) 代码可维护性技巧</p>\n<ul>\n<li>通过定义生成器函数来修饰可迭代对象，可以优化循环内部代码</li>\n<li><code>itertools</code> 模块里有许多函数可以用来修饰可迭代对象</li>\n<li>生成器函数可以用来解耦循环代码，提升可复用性</li>\n<li>不要使用多个 <code>break</code>，拆分为函数然后直接 <code>return</code> 更好</li>\n<li>使用 <code>next()</code> 函数有时可以完成一些意想不到的功能</li>\n</ul>\n<p>(4) 文件操作知识</p>\n<ul>\n<li>使用标准做法读取文件内容，在处理没有换行符的大文件时会很慢</li>\n<li>调用 <code>file.read()</code> 方法可以解决读取大文件的性能问题</li>\n</ul>\n\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"第 5 章 异常与错误处理","id":740842},"right":{"article_title":"第 7 章 函数(1)","id":740844}},"comments":[]}