{"id":312568,"title":"40 | Redis的下一步：基于NVM内存的实践","content":"<p>你好，我是蒋德钧。</p><p>今天这节课是咱们课程的最后一节课了，我们来聊聊Redis的下一步发展。</p><p>这几年呢，新型非易失存储（Non-Volatile Memory，NVM）器件发展得非常快。NVM器件具有容量大、性能快、能持久化保存数据的特性，这些刚好就是Redis追求的目标。同时，NVM器件像DRAM一样，可以让软件以字节粒度进行寻址访问，所以，在实际应用中，NVM可以作为内存来使用，我们称为NVM内存。</p><p>你肯定会想到，Redis作为内存键值数据库，如果能和NVM内存结合起来使用，就可以充分享受到这些特性。我认为，Redis发展的下一步，就可以基于NVM内存来实现大容量实例，或者是实现快速持久化数据和恢复。这节课，我就带你了解下这个新趋势。</p><p>接下来，我们先来学习下NVM内存的特性，以及软件使用NVM内存的两种模式。在不同的使用模式下，软件能用到的NVM特性是不一样的，所以，掌握这部分知识，可以帮助我们更好地根据业务需求选择适合的模式。</p><h2>NVM内存的特性与使用模式</h2><p>Redis是基于DRAM内存的键值数据库，而跟传统的DRAM内存相比，NVM有三个显著的特点。</p><p>首先，<strong>NVM内存最大的优势是可以直接持久化保存数据</strong>。也就是说，数据保存在NVM内存上后，即使发生了宕机或是掉电，数据仍然存在NVM内存上。但如果数据是保存在DRAM上，那么，掉电后数据就会丢失。</p><!-- [[[read_end]]] --><p>其次，<strong>NVM内存的访问速度接近DRAM的速度</strong>。我实际测试过NVM内存的访问速度，结果显示，它的读延迟大约是200~300ns，而写延迟大约是100ns。在读写带宽方面，单根NVM内存条的写带宽大约是1~2GB/s，而读带宽约是5~6GB/s。当软件系统把数据保存在NVM内存上时，系统仍然可以快速地存取数据。</p><p>最后，<strong>NVM内存的容量很大</strong>。这是因为，NVM器件的密度大，单个NVM的存储单元可以保存更多数据。例如，单根NVM内存条就能达到128GB的容量，最大可以达到512GB，而单根DRAM内存条通常是16GB或32GB。所以，我们可以很轻松地用NVM内存构建TB级别的内存。</p><p>总结来说，NVM内存的特点可以用三句话概括：</p><ul>\n<li>能持久化保存数据；</li>\n<li>读写速度和DRAM接近；</li>\n<li>容量大。</li>\n</ul><p>现在，业界已经有了实际的NVM内存产品，就是Intel在2019年4月份时推出的Optane AEP内存条（简称AEP内存）。我们在应用AEP内存时，需要注意的是，AEP内存给软件提供了两种使用模式，分别对应着使用了NVM的容量大和持久化保存数据两个特性，我们来学习下这两种模式。</p><p>第一种是Memory模式。</p><p>这种模式是把NVM内存作为大容量内存来使用的，也就是说，只使用NVM容量大和性能高的特性，没有启用数据持久化的功能。</p><p>例如，我们可以在一台服务器上安装6根NVM内存条，每根512GB，这样我们就可以在单台服务器上获得3TB的内存容量了。</p><p>在Memory模式下，服务器上仍然需要配置DRAM内存，但是，DRAM内存是被CPU用作AEP内存的缓存，DRAM的空间对应用软件不可见。换句话说，<strong>软件系统能使用到的内存空间，就是AEP内存条的空间容量</strong>。</p><p>第二种是App Direct模式。</p><p>这种模式启用了NVM持久化数据的功能。在这种模式下，应用软件把数据写到AEP内存上时，数据就直接持久化保存下来了。所以，使用了App Direct模式的AEP内存，也叫做持久化内存（Persistent Memory，PM）。</p><p>现在呢，我们知道了AEP内存的两种使用模式，那Redis是怎么用的呢？我来给你具体解释一下。</p><h2>基于NVM内存的Redis实践</h2><p>当AEP内存使用Memory模式时，应用软件就可以利用它的大容量特性来保存大量数据，Redis也就可以给上层业务应用提供大容量的实例了。而且，在Memory模式下，Redis可以像在DRAM内存上运行一样，直接在AEP内存上运行，不用修改代码。</p><p>不过，有个地方需要注意下：在Memory模式下，AEP内存的访问延迟会比DRAM高一点。我刚刚提到过，NVM的读延迟大约是200~300ns，而写延迟大约是100ns。所以，在Memory模式下运行Redis实例，实例读性能会有所降低，我们就需要在保存大量数据和读性能较慢两者之间做个取舍。</p><p>那么，当我们使用App Direct模式，把AEP内存用作PM时，Redis又该如何利用PM快速持久化数据的特性呢？这就和Redis的数据可靠性保证需求和现有机制有关了，我们来具体分析下。</p><p>为了保证数据可靠性，Redis设计了RDB和AOF两种机制，把数据持久化保存到硬盘上。</p><p>但是，无论是RDB还是AOF，都需要把数据或命令操作以文件的形式写到硬盘上。对于RDB来说，虽然Redis实例可以通过子进程生成RDB文件，但是，实例主线程fork子进程时，仍然会阻塞主线程。而且，RDB文件的生成需要经过文件系统，文件本身会有一定的操作开销。</p><p>对于AOF日志来说，虽然Redis提供了always、everysec和no三个选项，其中，always选项以fsync的方式落盘保存数据，虽然保证了数据的可靠性，但是面临性能损失的风险。everysec选项避免了每个操作都要实时落盘，改为后台每秒定期落盘。在这种情况下，Redis的写性能得到了改善，但是，应用会面临秒级数据丢失的风险。</p><p>此外，当我们使用RDB文件或AOF文件对Redis进行恢复时，需要把RDB文件加载到内存中，或者是回放AOF中的日志操作。这个恢复过程的效率受到RDB文件大小和AOF文件中的日志操作多少的影响。</p><p>所以，在前面的课程里，我也经常提醒你，不要让单个Redis实例过大，否则会导致RDB文件过大。在主从集群应用中，过大的RDB文件就会导致低效的主从同步。</p><p>我们先简单小结下现在Redis在涉及持久化操作时的问题：</p><ul>\n<li>RDB文件创建时的fork操作会阻塞主线程；</li>\n<li>AOF文件记录日志时，需要在数据可靠性和写性能之间取得平衡；</li>\n<li>使用RDB或AOF恢复数据时，恢复效率受RDB和AOF大小的限制。</li>\n</ul><p>但是，如果我们使用持久化内存，就可以充分利用PM快速持久化的特点，来避免RDB和AOF的操作。因为PM支持内存访问，而Redis的操作都是内存操作，那么，我们就可以把Redis直接运行在PM上。同时，数据本身就可以在PM上持久化保存了，我们就不再需要额外的RDB或AOF日志机制来保证数据可靠性了。</p><p>那么，当使用PM来支持Redis的持久化操作时，我们具体该如何实现呢？</p><p>我先介绍下PM的使用方法。</p><p>当服务器中部署了PM后，我们可以在操作系统的/dev目录下看到一个PM设备，如下所示：</p><pre><code> /dev/pmem0\n</code></pre><p>然后，我们需要使用ext4-dax文件系统来格式化这个设备：</p><pre><code> mkfs.ext4 /dev/pmem0\n</code></pre><p>接着，我们把这个格式化好的设备，挂载到服务器上的一个目录下：</p><pre><code>mount -o dax /dev/pmem0  /mnt/pmem0\n</code></pre><p>此时，我们就可以在这个目录下创建文件了。创建好了以后，再把这些文件通过内存映射（mmap）的方式映射到Redis的进程空间。这样一来，我们就可以把Redis接收到的数据直接保存到映射的内存空间上了，而这块内存空间是由PM提供的。所以，数据写入这块空间时，就可以直接被持久化保存了。</p><p>而且，如果要修改或删除数据，PM本身也支持以字节粒度进行数据访问，所以，Redis可以直接在PM上修改或删除数据。</p><p>如果发生了实例故障，Redis宕机了，因为数据本身已经持久化保存在PM上了，所以我们可以直接使用PM上的数据进行实例恢复，而不用再像现在的Redis那样，通过加载RDB文件或是重放AOF日志操作来恢复了，可以实现快速的故障恢复。</p><p>当然，因为PM的读写速度比DRAM慢，所以，<strong>如果使用PM来运行Redis，需要评估下PM提供的访问延迟和访问带宽，是否能满足业务层的需求</strong>。</p><p>我给你举个例子，带你看下如何评估PM带宽对Redis业务的支撑。</p><p>假设业务层需要支持1百万QPS，平均每个请求的大小是2KB，那么，就需要机器能支持2GB/s的带宽（1百万请求操作每秒 * 2KB每请求 = 2GB/s）。如果这些请求正好是写操作的话，那么，单根PM的写带宽可能不太够用了。</p><p>这个时候，我们就可以在一台服务器上使用多根PM内存条，来支撑高带宽的需求。当然，我们也可以使用切片集群，把数据分散保存到多个实例，分担访问压力。</p><p>好了，到这里，我们就掌握了用PM将Redis数据直接持久化保存在内存上的方法。现在，我们既可以在单个实例上使用大容量的PM保存更多的业务数据了，同时，也可以在实例故障后，直接使用PM上保存的数据进行故障恢复。</p><h2>小结</h2><p>这节课我向你介绍了NVM的三大特点：性能高、容量大、数据可以持久化保存。软件系统可以像访问传统DRAM内存一样，访问NVM内存。目前，Intel已经推出了NVM内存产品Optane AEP。</p><p>这款NVM内存产品给软件提供了两种使用模式，分别是Memory模式和App Direct模式。在Memory模式时，Redis可以利用NVM容量大的特点，实现大容量实例，保存更多数据。在使用App Direct模式时，Redis可以直接在持久化内存上进行数据读写，在这种情况下，Redis不用再使用RDB或AOF文件了，数据在机器掉电后也不会丢失。而且，实例可以直接使用持久化内存上的数据进行恢复，恢复速度特别快。</p><p>NVM内存是近年来存储设备领域中一个非常大的变化，它既能持久化保存数据，还能像内存一样快速访问，这必然会给当前基于DRAM和硬盘的系统软件优化带来新的机遇。现在，很多互联网大厂已经开始使用NVM内存了，希望你能够关注这个重要趋势，为未来的发展做好准备。</p><h2>每课一问</h2><p>按照惯例，我给你提个小问题，你觉得有了持久化内存后，还需要Redis主从集群吗?</p><p>欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得今天的内容对你有所帮助，也欢迎你分享给你的朋友或同事。</p>","comments":[{"had_liked":false,"id":263731,"user_name":"Kaito","can_delete":false,"product_type":"c1","uid":1020042,"ip_address":"","ucode":"79775FA35A95F2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","comment_is_top":false,"comment_ctime":1606234253,"is_pvip":true,"discussion_count":5,"race_medal":0,"score":"431102963853","product_id":100056701,"comment_content":"有了持久化内存，是否还需要 Redis 主从集群？<br><br>肯定还是需要主从集群的。持久化内存只能解决存储容量和数据恢复问题，关注点在于单个实例。<br><br>而 Redis 主从集群，既可以提升集群的访问性能，还能提高集群的可靠性。<br><br>例如部署多个从节点，采用读写分离的方式，可以分担单个实例的请求压力，提升集群的访问性能。而且当主节点故障时，可以提升从节点为新的主节点，降低故障对应用的影响。<br><br>两者属于不同维度的东西，互不影响。","like_count":101,"discussions":[{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338797,"discussion_content":"业界好像很少利用redis的主从，无论是单从还是树状从，大部分都是写主读主。个人认为从的存在 最大的价值在于提升可靠性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609383883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1879262,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/ac/de/68f35320.jpg","nickname":"小来子","note":"","ucode":"4EDAF31E43B211","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350341,"discussion_content":"啊。？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613816467,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":338797,"ip_address":""},"score":350341,"extra":""},{"author":{"id":2277195,"avatar":"https://static001.geekbang.org/account/avatar/00/22/bf/4b/2acf59c1.jpg","nickname":"我","note":"","ucode":"49C9AFFB997A3F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378474,"discussion_content":"读写分离有gap期，管饭也不推荐使用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623239613,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":338797,"ip_address":""},"score":378474,"extra":""}]},{"author":{"id":1300285,"avatar":"https://static001.geekbang.org/account/avatar/00/13/d7/3d/a076faf1.jpg","nickname":"蜗牛","note":"","ucode":"A99C9C890F95E4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331466,"discussion_content":"你好课代表，有这么一道题“100万并发4G数据，10万并发400G数据，如何设计Redis存储方式？”，这个要从哪个方面来考虑呢？并发量？数据量？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606879159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1336951,"avatar":"https://static001.geekbang.org/account/avatar/00/14/66/77/194ba21d.jpg","nickname":"lzh","note":"","ucode":"C3D83DF4230109","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1300285,"avatar":"https://static001.geekbang.org/account/avatar/00/13/d7/3d/a076faf1.jpg","nickname":"蜗牛","note":"","ucode":"A99C9C890F95E4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362311,"discussion_content":"个人理解，后者数据量大并发小，可以考虑分片集群，前者并发大数据量小，可以考虑主从集群，还要一些削峰限流策略。如果是面试场景的话，先回答一个基础版，然后看面试官想往哪方面拓展，没有标准的答案的，只有解决问题的思路","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1616916637,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":331466,"ip_address":""},"score":362311,"extra":""}]}]},{"had_liked":false,"id":265997,"user_name":"Mr.Brooks","can_delete":false,"product_type":"c1","uid":1118650,"ip_address":"","ucode":"D47A6B0236A79F","user_header":"https://static001.geekbang.org/account/avatar/00/11/11/ba/2175bc50.jpg","comment_is_top":false,"comment_ctime":1607096263,"is_pvip":true,"replies":[{"id":"97671","content":"这是个好问题。<br><br>增加从节点时，需要把全库数据拷贝到从节点上。我自己现在考虑的有两种方法：一种还是用写前日志，日志拷贝到从节点进行回放，但是这会带来双写的问题。另一种是，主节点在NVM上做快照，但是不写文件，从节点上直接从主节点的NVM上通过远程内存拷贝来实现复制，这个需要基于RDMA来做。","user_name":"作者回复","comment_id":265997,"uid":"1609687","ip_address":"","utype":1,"ctime":1608601333,"user_name_real":"蒋德钧"}],"discussion_count":2,"race_medal":0,"score":"108981278663","product_id":100056701,"comment_content":"使用NVM，没有了RDB，主从复制对于新添加的机器，是怎么实现的呢","like_count":26,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511118,"discussion_content":"这是个好问题。\n\n增加从节点时，需要把全库数据拷贝到从节点上。我自己现在考虑的有两种方法：一种还是用写前日志，日志拷贝到从节点进行回放，但是这会带来双写的问题。另一种是，主节点在NVM上做快照，但是不写文件，从节点上直接从主节点的NVM上通过远程内存拷贝来实现复制，这个需要基于RDMA来做。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608601333,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1022411,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/99/cb/8964faab.jpg","nickname":"-只是小小配角_","note":"","ucode":"EFC1CD54A23F39","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349519,"discussion_content":"redis一直以来都支持 disk less 的主从复制","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1613287520,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":264356,"user_name":"u","can_delete":false,"product_type":"c1","uid":1140276,"ip_address":"","ucode":"88FA7BA089807C","user_header":"https://static001.geekbang.org/account/avatar/00/11/66/34/0508d9e4.jpg","comment_is_top":false,"comment_ctime":1606445891,"is_pvip":false,"replies":[{"id":"98011","content":"这个问题很好。目前，应用程序是把本来要保存到磁盘上的数据保存到持久化内存上了，但是应用程序运行时的堆和栈还是在DRAM上，进程重启这些运行时信息就丢了。<br><br>所以，如果想把应用程序本身的运行时状态，例如堆栈等，也保存到持久化内存上，这个需要对操作系统的内核做修改。目前还没有成熟的方案。","user_name":"作者回复","comment_id":264356,"uid":"1609687","ip_address":"","utype":1,"ctime":1609078392,"user_name_real":"蒋德钧"}],"discussion_count":1,"race_medal":0,"score":"74620889923","product_id":100056701,"comment_content":"老师，比较好奇应用程序是如何基于持久化内存来恢复自身的状态的，还是说应用程序本身也作为持久化的一部分，在重启后就存在于内存中？","like_count":17,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510537,"discussion_content":"这个问题很好。目前，应用程序是把本来要保存到磁盘上的数据保存到持久化内存上了，但是应用程序运行时的堆和栈还是在DRAM上，进程重启这些运行时信息就丢了。\n\n所以，如果想把应用程序本身的运行时状态，例如堆栈等，也保存到持久化内存上，这个需要对操作系统的内核做修改。目前还没有成熟的方案。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609078392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":273646,"user_name":"好好学习","can_delete":false,"product_type":"c1","uid":1762191,"ip_address":"","ucode":"9D44D9530D9A1D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/e3/8f/77b5a753.jpg","comment_is_top":false,"comment_ctime":1610645269,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"61740187413","product_id":100056701,"comment_content":"终于学完了。 我真棒！","like_count":14,"discussions":[{"author":{"id":1102245,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d1/a5/2bbedc3b.jpg","nickname":"over","note":"","ucode":"FE272AC19842D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387520,"discussion_content":"奖励一下\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628228355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263808,"user_name":"Lemon","can_delete":false,"product_type":"c1","uid":2136414,"ip_address":"","ucode":"E52BB361B69825","user_header":"https://static001.geekbang.org/account/avatar/00/20/99/5e/33481a74.jpg","comment_is_top":false,"comment_ctime":1606270984,"is_pvip":false,"replies":[{"id":"97921","content":"回答的很好。<br><br>而且对NVM使用的思考非常赞。NVM的读写延迟（几百ns级别）还是要低于SSD的（几十到几百us级别），所以使用NVM替换SSD是可以解决Pika操作慢的问题。<br><br>不过，NVM的每GB成本还是要高于SSD的，这个在实际应用中要考虑。","user_name":"作者回复","comment_id":263808,"uid":"1609687","ip_address":"","utype":1,"ctime":1608994086,"user_name_real":"蒋德钧"}],"discussion_count":2,"race_medal":0,"score":"35966009352","product_id":100056701,"comment_content":"肯定还是需要的，两者是互补的。<br><br>NVM 给了数据存储方面的新方案，但目前用作 PM 的读写速度比 DRAM 慢，不使用主从集群仍会有明显的访问瓶颈。【过大的实例在主从同步时会有影响（缓存、带宽）】<br><br>而集群是为了高可用，分散了数据的访问和存储，便于拓展与维护。对于单实例而言，即便单实例恢复的再快，挂了对业务仍会有影响。<br><br>感觉 NVM 内存用作 PM 有点像第 28 将的 Pika，如果把 SSD 换为 NVM ，岂不是都再内存中操作？是否可以解决 Pika 操作慢的缺点？","like_count":8,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510315,"discussion_content":"回答的很好。\n\n而且对NVM使用的思考非常赞。NVM的读写延迟（几百ns级别）还是要低于SSD的（几十到几百us级别），所以使用NVM替换SSD是可以解决Pika操作慢的问题。\n\n不过，NVM的每GB成本还是要高于SSD的，这个在实际应用中要考虑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608994086,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338800,"discussion_content":"我觉得pika 最大的问题是多线程操作导致了锁的存在。无论如何细化，只要存在极热的key的读写，那么性能就会急剧下降。。。这点与 memcache 没啥区别。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1609384027,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":276522,"user_name":"宙斯","can_delete":false,"product_type":"c1","uid":2041396,"ip_address":"","ucode":"80DF36BAD298AD","user_header":"https://static001.geekbang.org/account/avatar/00/1f/26/34/891dd45b.jpg","comment_is_top":false,"comment_ctime":1611985637,"is_pvip":true,"replies":[{"id":"100448","content":"对主从集群的作用理解到位。","user_name":"作者回复","comment_id":276522,"uid":"1609687","ip_address":"","utype":1,"ctime":1612142687,"user_name_real":"蒋德钧"}],"discussion_count":1,"race_medal":0,"score":"31676756709","product_id":100056701,"comment_content":"需要。主从集群 1读写分离，降低实例压力 2数据冗余，防止介质损坏数据丢失","like_count":7,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514736,"discussion_content":"对主从集群的作用理解到位。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612142687,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":265905,"user_name":"李梦嘉","can_delete":false,"product_type":"c1","uid":1141909,"ip_address":"","ucode":"4F9F29F9E96A55","user_header":"https://static001.geekbang.org/account/avatar/00/11/6c/95/bb237f51.jpg","comment_is_top":false,"comment_ctime":1607065557,"is_pvip":false,"replies":[{"id":"97911","content":"Intel有在推基于AEP的Redis，可以看下<br>https:&#47;&#47;www.intel.com&#47;content&#47;dam&#47;www&#47;public&#47;us&#47;en&#47;documents&#47;solution-briefs&#47;redis-enterprise-brief.pdf<br><br>另外，github上有基于PMem的Redis实现，是基于Redis 4.0实现，有些旧了，不过可以作为一个参考。<br>https:&#47;&#47;github.com&#47;pmem&#47;pmem-redis<br><br>另外，阿里云上的Tair有基于AEP做扩展，参考<br>https:&#47;&#47;developer.aliyun.com&#47;article&#47;776609<br>","user_name":"作者回复","comment_id":265905,"uid":"1609687","ip_address":"","utype":1,"ctime":1608977752,"user_name_real":"蒋德钧"}],"discussion_count":1,"race_medal":0,"score":"31671836629","product_id":100056701,"comment_content":"老师，请问有AEP方案redis的最佳实践么，最近在调研这方面","like_count":7,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511087,"discussion_content":"Intel有在推基于AEP的Redis，可以看下\nhttps://www.intel.com/content/dam/www/public/us/en/documents/solution-briefs/redis-enterprise-brief.pdf\n\n另外，github上有基于PMem的Redis实现，是基于Redis 4.0实现，有些旧了，不过可以作为一个参考。\nhttps://github.com/pmem/pmem-redis\n\n另外，阿里云上的Tair有基于AEP做扩展，参考\nhttps://developer.aliyun.com/article/776609\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608977752,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263832,"user_name":"yyl","can_delete":false,"product_type":"c1","uid":1170843,"ip_address":"","ucode":"1741DACDFCA9AF","user_header":"https://static001.geekbang.org/account/avatar/00/11/dd/9b/0bc44a78.jpg","comment_is_top":false,"comment_ctime":1606276128,"is_pvip":false,"replies":[{"id":"97920","content":"对主从集群作用的理解很到位 :)","user_name":"作者回复","comment_id":263832,"uid":"1609687","ip_address":"","utype":1,"ctime":1608993733,"user_name_real":"蒋德钧"}],"discussion_count":1,"race_medal":0,"score":"18786145312","product_id":100056701,"comment_content":"问题：有了持久化内存，是否还需要 Redis 主从集群？<br>解答：需要，主从集群解决的单点故障问题，而且还能起到一定的负载分担。而NVM解决的是数据丢失","like_count":4,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510326,"discussion_content":"对主从集群作用的理解很到位 :)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608993733,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263781,"user_name":"写点啥呢","can_delete":false,"product_type":"c1","uid":1065272,"ip_address":"","ucode":"C19032CF1C41BA","user_header":"https://static001.geekbang.org/account/avatar/00/10/41/38/4f89095b.jpg","comment_is_top":false,"comment_ctime":1606266869,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18786136053","product_id":100056701,"comment_content":"请问蒋老师，Redis将PM用作内存模式的话，是否需要修改Redis代码。我理解内存模式是对程序透明的，虽然PM可以把数据持久化保存，但是如果Redis进程把它看做内存，如果希望进程启动能够自动回复，就会涉及到进程内存空间的恢复，OS里是没有这个功能的，是不是应该需要Redis来做个事情，才可以直接从PM保存的上一次数据中作为新进程的内存空间，而不再需要通过RDB或者AOF来做数据持久化？","like_count":4},{"had_liked":false,"id":280513,"user_name":"neohope","can_delete":false,"product_type":"c1","uid":1043475,"ip_address":"","ucode":"C0268F6E7E2B6E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","comment_is_top":false,"comment_ctime":1614238783,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5909206079","product_id":100056701,"comment_content":"老师好，关于mmap映射的问题，没看明白，有几点不清楚，还望帮忙解答：<br>1、将redis内存空间，用mmap映射到PM的ext系统文件后，保持的就是内存信息吧？那进程信息、线程信息、寄存器状态什么的，需要额外保持吗？<br>2、redis挂掉后，重新启动要如何做呢？<br>3、操作系统重启动后，再启动redis时，还能用这个持久化后的文件吗？要如何做呢？<br>4、用集群的时候，节点间复制要如何做呢？<br>感谢！","like_count":2},{"had_liked":false,"id":269241,"user_name":"Mr.蜜","can_delete":false,"product_type":"c1","uid":1035257,"ip_address":"","ucode":"C911B81198B3F5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cb/f9/75d08ccf.jpg","comment_is_top":false,"comment_ctime":1608565279,"is_pvip":false,"replies":[{"id":"97735","content":"大流量情况下，单个实例的压力太大，从节点是可以用来分担读压力的。","user_name":"作者回复","comment_id":269241,"uid":"1609687","ip_address":"","utype":1,"ctime":1608683946,"user_name_real":"蒋德钧"}],"discussion_count":2,"race_medal":0,"score":"5903532575","product_id":100056701,"comment_content":"由于PM的读写速度存在差异，使用读写分离的主从集群，还是有必要，这样可以分担单实例的处理压力，提升redis整体的性能，所以使用主从集群还是非常有必要的。","like_count":1,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512204,"discussion_content":"大流量情况下，单个实例的压力太大，从节点是可以用来分担读压力的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608683946,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338799,"discussion_content":"大流量的读写均衡情况下，写主读主，极少写主读从，一旦主从延迟就会产生非预期数据。。代价过大","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1609384018,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":265633,"user_name":"范闲","can_delete":false,"product_type":"c1","uid":1073125,"ip_address":"","ucode":"F21FD7DF6BA53C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","comment_is_top":false,"comment_ctime":1606965206,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5901932502","product_id":100056701,"comment_content":"主从集群仍旧需要。<br>单机失踪了持久化内存只能解决单机的存储容量和数据恢复问题。<br>主从集群可以提高访问速度，提高可靠性，做到HA。","like_count":1},{"had_liked":false,"id":263836,"user_name":"大土豆","can_delete":false,"product_type":"c1","uid":1121636,"ip_address":"","ucode":"67445DC3EC9DB0","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/64/52a5863b.jpg","comment_is_top":false,"comment_ctime":1606277200,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5901244496","product_id":100056701,"comment_content":"老师问下一个redis集群的问题，现在最多人用的3主3从的redis cluster方案，3个主节点同时也是哨兵实例吧？你怎么看这种集群部署方案","like_count":1},{"had_liked":false,"id":356997,"user_name":"NULL","can_delete":false,"product_type":"c1","uid":1191550,"ip_address":"山东","ucode":"2A323DD05352BC","user_header":"https://static001.geekbang.org/account/avatar/00/12/2e/7e/ebc28e10.jpg","comment_is_top":false,"comment_ctime":1662813432,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662813432","product_id":100056701,"comment_content":"关于dram, nvm, ssd的区别, 可以看下Intel Optane AEP的介绍, 在1:18秒处 https:&#47;&#47;www.intel.cn&#47;content&#47;www&#47;cn&#47;zh&#47;architecture-and-technology&#47;optane-dc-persistent-memory.html","like_count":0},{"had_liked":false,"id":334966,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1645208208,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1645208208","product_id":100056701,"comment_content":"gpu 内存可以加速redis性能吗？","like_count":0},{"had_liked":false,"id":334167,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1644799071,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1644799071","product_id":100056701,"comment_content":"nvm后还要记内存日志更好，一些操作执行到中间步骤的时候失败了，重启之后要有办法回滚。","like_count":0},{"had_liked":false,"id":333936,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1644598045,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1644598045","product_id":100056701,"comment_content":"解决主从一致性的问题，redis就可以当个分布式db了","like_count":0},{"had_liked":false,"id":315910,"user_name":"彭文达","can_delete":false,"product_type":"c1","uid":1801058,"ip_address":"","ucode":"8DCC27EC5AF263","user_header":"https://static001.geekbang.org/account/avatar/00/1b/7b/62/ec94cee4.jpg","comment_is_top":false,"comment_ctime":1634043149,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634043149","product_id":100056701,"comment_content":"完结撒花","like_count":0},{"had_liked":false,"id":315234,"user_name":"花儿少年","can_delete":false,"product_type":"c1","uid":1318540,"ip_address":"","ucode":"CFE4F64243673B","user_header":"https://static001.geekbang.org/account/avatar/00/14/1e/8c/450fe5cb.jpg","comment_is_top":false,"comment_ctime":1633761620,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633761620","product_id":100056701,"comment_content":"NVM 也是有些缺陷的，也可能会导致数据不一致。例如，在redis的新增一个数据节点，那么会有两步操作，1、分配内存，写入数据；2、将此内存地址的指针指向redis管理；而这两步我们知道在很多情况下都可能是乱序执行的，如果第二步先执行，此时机器crash了，redis就指向了一个无效地址。","like_count":0},{"had_liked":false,"id":311104,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1631072418,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631072418","product_id":100056701,"comment_content":"单机版的Redis必然存在着实例服务器宕机的问题,那么Redis主从集群必然有存在的需求<br>不过有了NVM,使用K8S直接管理也是可以的,毕竟绑定了固定的volume,也可以保证持久化和自动重启","like_count":0},{"had_liked":false,"id":296595,"user_name":"BertGeek","can_delete":false,"product_type":"c1","uid":1452799,"ip_address":"","ucode":"8E1D72C9F9778C","user_header":"https://static001.geekbang.org/account/avatar/00/16/2a/ff/a9d72102.jpg","comment_is_top":false,"comment_ctime":1623057003,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623057003","product_id":100056701,"comment_content":"从高可用角度考虑，主从集群还是非常必要，<br>NVM只是解决读写性能，可持久存储，只要是硬件也需要考虑坏的可能。<br>Redis数据需要备份，还是要做足工作的","like_count":0},{"had_liked":false,"id":286836,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1617626568,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1617626568","product_id":100056701,"comment_content":"有一点好奇，NVM 内存在 Memory 模式下，为什么还需要 DRAM 来做缓存？<br><br>使用 App Direct 模式，将 Redis 运行在持久化内存（Persistent Memory, PM）上，不需要额外的 RDB 或者 AOF，那岂不是要快的飞起？<br><br>有一个疑问，Redis 原本的优势建立在内存访问速度上，如果有了 NVM 内存，那么其他的数据库或者 KV 数据库也会变得比较快，Redis 的优势可能就没那么大。<br><br>对于课后题，有了持久化内存，应该还是需要 Redis 主从集群的，一方面可以读写分离，分散支撑高性能读写需求；另外一方面，主从集群也可以提高系统的可靠性。<br><br>有同学在留言里提到了 Pika，这个确实可以在 NVM 上。","like_count":0},{"had_liked":false,"id":267769,"user_name":"文古","can_delete":false,"product_type":"c1","uid":1313934,"ip_address":"","ucode":"9A3991AA033EB4","user_header":"https://static001.geekbang.org/account/avatar/00/14/0c/8e/8a39ee55.jpg","comment_is_top":false,"comment_ctime":1607919579,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1607919579","product_id":100056701,"comment_content":"老师您好，redis多路利用模式epoll创建fd的时候为什么只创建1024个，难道为了跟select兼容吗？这不是降低epoll的效率","like_count":0},{"had_liked":false,"id":264918,"user_name":"dfuru","can_delete":false,"product_type":"c1","uid":2110772,"ip_address":"","ucode":"0222FADA093D95","user_header":"","comment_is_top":false,"comment_ctime":1606706927,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606706927","product_id":100056701,"comment_content":"主从集群功能：<br>1. 保证数据的可靠性；<br>2. 保障业务的可用性。及时用了PM后，当发生宕机，仍然需要主从切换，保证业务可用。","like_count":0},{"had_liked":false,"id":263766,"user_name":" 尿布","can_delete":false,"product_type":"c1","uid":1476323,"ip_address":"","ucode":"D1C8BDA7540962","user_header":"https://static001.geekbang.org/account/avatar/00/16/86/e3/a31f6869.jpg","comment_is_top":false,"comment_ctime":1606264605,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1606264605","product_id":100056701,"comment_content":"pika","like_count":0,"discussions":[{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339604,"discussion_content":"pika不一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609745851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263733,"user_name":"林林要加油鸭","can_delete":false,"product_type":"c1","uid":2309104,"ip_address":"","ucode":"E71956CBD3BD4D","user_header":"https://static001.geekbang.org/account/avatar/00/23/3b/f0/0dd9ca93.jpg","comment_is_top":false,"comment_ctime":1606234497,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1606234497","product_id":100056701,"comment_content":"沙发！","like_count":0}]}