{"id":14270,"title":"18 | 即时编译器的中间表达形式","content":"<p>在上一章中，我利用了程序控制流图以及伪代码，来展示即时编译器中基于profile的优化。不过，这并非实际的优化过程。</p><h2>1. 中间表达形式（IR）</h2><p>在编译原理课程中，我们通常将编译器分为前端和后端。其中，前端会对所输入的程序进行词法分析、语法分析、语义分析，然后生成中间表达形式，也就是IR（Intermediate Representation ）。后端会对IR进行优化，然后生成目标代码。</p><p>如果不考虑解释执行的话，从Java源代码到最终的机器码实际上经过了两轮编译：Java编译器将Java源代码编译成Java字节码，而即时编译器则将Java字节码编译成机器码。</p><p>对于即时编译器来说，所输入的Java字节码剥离了很多高级的Java语法，而且其采用的基于栈的计算模型非常容易建模。因此，即时编译器并不需要重新进行词法分析、语法分析以及语义分析，而是直接将Java字节码作为一种IR。</p><p>不过，Java字节码本身并不适合直接作为可供优化的IR。这是因为现代编译器一般采用静态单赋值（Static Single Assignment，SSA）IR。这种IR的特点是每个变量只能被赋值一次，而且只有当变量被赋值之后才能使用。</p><pre><code>y = 1;\ny = 2;\nx = y;\n\n</code></pre><!-- [[[read_end]]] --><p>举个例子（<a href=\"https://en.wikipedia.org/wiki/Static_single_assignment_form\">来源</a>），上面这段代码所对应的SSA形式伪代码是下面这段：</p><pre><code>y1 = 1;\ny2 = 2;\nx1 = y2;\n</code></pre><p>在源代码中，我们可以轻易地发现第一个对y的赋值是冗余的，但是编译器不能。传统的编译器需要借助数据流分析（具体的优化叫<a href=\"https://en.wikipedia.org/wiki/Reaching_definition\">reaching definition</a>），从后至前依次确认哪些变量的值被覆盖（kill）掉。</p><p>不过，如果借助了SSA IR，编译器则可以通过查找赋值了但是没有使用的变量，来识别冗余赋值。</p><p>除此之外，SSA IR对其他优化方式也有很大的帮助，例如常量折叠（constant folding）、常量传播（constant propagation）、强度削减（strength reduction）以及死代码删除（dead code elimination）等。</p><pre><code>示例：\nx1=4*1024经过常量折叠后变为x1=4096\nx1=4; y1=x1经过常量传播后变为x1=4; y1=4\ny1=x1*3经过强度削减后变为y1=(x1&lt;&lt;1)+x1\nif(2&gt;1){y1=1;}else{y2=1;}经过死代码删除后变为y1=1\n</code></pre><p>部分同学可能会手动进行上述优化，以期望能够达到更高的运行效率。实际上，对于这些简单的优化，编译器会代为执行，以便程序员专注于代码的可读性。</p><p>SSA IR会带来一个问题，那便是不同执行路径可能会对同一变量设置不同的值。例如下面这段代码if语句的两个分支中，变量y分别被赋值为0或1，并且在接下来的代码中读取y的值。此时，根据不同的执行路径，所读取到的值也很有可能不同。</p><pre><code>x = ..;\nif (x &gt; 0) {\n  y = 0;\n} else {\n  y = 1;\n}\nx = y;\n</code></pre><p>为了解决这个问题，我们需要引入一个Phi函数的概念，能够根据不同的执行路径选择不同的值。于是，上面这段代码便可以转换为下面这段SSA伪代码。这里的Phi函数将根据前面两个分支分别选择y1、y2的值，并赋值给y3。</p><pre><code>x1 = ..;\nif (x1 &gt; 0) {\n  y1 = 0;\n} else {\n  y2 = 1;\n}\ny3 = Phi(y1, y2);\nx2 = y3;\n</code></pre><p>总之，即时编译器会将Java字节码转换成SSA IR。更确切的说，是一张包含控制流和数据流的IR图，每个字节码对应其中的若干个节点（注意，有些字节码并没有对应的IR节点）。然后，即时编译器在IR图上面进行优化。</p><p>我们可以将每一种优化看成一个独立的图算法，它接收一个IR图，并输出经过转换后的IR图。整个编译器优化过程便是一个个优化串联起来的。</p><h2>2. Sea-of-nodes</h2><p>HotSpot里的C2采用的是一种名为Sea-of-Nodes的SSA IR。它的最大特点，便是去除了变量的概念，直接采用变量所指向的值，来进行运算。</p><p>在上面这段SSA伪代码中，我们使用了多个变量名x1、x2、y1和y2。这在Sea-of-Nodes将不复存在。</p><p>取而代之的则是对应的值，比如说Phi(y1, y2)变成Phi(0, 1)，后者本身也是一个值，被其他IR节点所依赖。正因如此，常量传播在Sea-of-Nodes中变成了一个no-op。</p><p>Graal的IR同样也是Sea-of-Nodes类型的，并且可以认为是C2 IR的精简版本。由于Graal的IR系统更加容易理解，而且工具支持相对来说也比较全、比较新，所以下面我将围绕着Graal的IR系统来讲解。</p><p><span class=\"reference\">尽管IR系统不同，C2和Graal所实现的优化大同小异。对于那小部分不同的地方，它们也在不停地相互“借鉴”。所以你无须担心不通用的问题。</span></p><p>为了方便你理解今天的内容，我将利用IR可视化工具<a href=\"http://ssw.jku.at/General/Staff/TW/igv.html\">Ideal Graph Visualizer</a>（IGV），来展示具体的IR图。（这里Ideal是C2中IR的名字。）</p><pre><code>public static int foo(int count) {\n  int sum = 0;\n  for (int i = 0; i &lt; count; i++) {\n    sum += i;\n  }\n  return sum;\n}\n</code></pre><p>上面这段代码所对应的IR图如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/2d/fe/2d107fd56885909797a4ada966f2bdfe.png?wh=1132*1306\" alt=\"\"></p><p><strong>IR图</strong></p><p>这里面，0号Start节点是方法入口，21号Return节点是方法出口。红色加粗线条为控制流，蓝色线条为数据流，而其他颜色的线条则是特殊的控制流或数据流。被控制流边所连接的是固定节点，其他的皆属于浮动节点。若干个顺序执行的节点将被包含在同一个基本块之中，如图中的B0、B1等。</p><p><img src=\"https://static001.geekbang.org/resource/image/0b/8b/0be8e6fccbeedb821bd23bbef899f78b.png?wh=340*626\" alt=\"\"></p><p><strong>基本块直接的控制流关系</strong></p><p>基本块是仅有一个入口和一个出口的指令序列（IR节点序列）。一个基本块的出口可以和若干个基本块的入口相连接，反之亦然。</p><p>在我们的例子中，B0和B2的出口与B1的入口连接，代表在执行完B0或B2后可以跳转至B1，并继续执行B1中的内容。而B1的出口则与B2和B3的入口连接。</p><p>可以看到，上面的IR图已经没有sum或者i这样的变量名了，取而代之的是一个个的值，例如源程序中的i&lt;count被转换为10号&lt;节点，其接收两个值，分别为代表i的8号Phi节点，以及代表输入第0个参数的1号P(0)节点。</p><p>关于8号Phi节点，前面讲过，它将根据不同的执行路径选择不同的值。如果是从5号End节点进入的，则选择常量0；如果是从20号LoopEnd节点跳转进入的，则选择19号+节点。</p><p>你可以自己分析一下代表sum的7号Phi节点，根据不同的执行路径都选择了哪些值。</p><p>浮动节点的位置并不固定。在编译过程中，编译器需要（多次）计算浮动节点具体的排布位置。这个过程我们称之为节点调度（node scheduling）。</p><p>节点调度是根据节点之间的依赖关系来进行的。举个例子，在前面的IR图中，10号&lt;节点是16号if节点用来判断是否跳转的条件，因此它需要排布在16号if节点（注意这是一个固定节点）之前。同时它又依赖于8号Phi节点的值以及1号P(0)节点的值，因此它需要排布在这两个节点之后。</p><p>需要注意的是，C2没有固定节点这一概念，所有的IR节点都是浮动节点。它将根据各个基本块头尾之间的控制依赖，以及数据依赖和内存依赖，来进行节点调度。</p><p>这里的内存依赖是什么一个概念呢？假设一段程序往内存中存储了一个值，而后又读取同一内存，那么显然程序希望读取到的是所存储的值。即时编译器不能任意调度对同一内存地址的读写，因为它们之间存在依赖关系。</p><p>C2的做法便是将这种时序上的先后记录为内存依赖，并让节点调度算法在进行调度时考虑这些内存依赖关系。Graal则将内存读写转换成固定节点。由于固定节点存在先后关系，因此无须额外记录内存依赖。</p><h2>3. Global Value Numbering</h2><p>下面介绍一种因Sea-of-Nodes而变得非常容易的优化技术 —— Global Value Numbering（GVN）。</p><p>GVN是一种发现并消除等价计算的优化技术。举例来说，如果一段程序中出现了多次操作数相同的乘法，那么即时编译器可以将这些乘法并为一个，从而降低输出机器码的大小。如果这些乘法出现在同一执行路径上，那么GVN还将省下冗余的乘法操作。</p><p>在Sea-of-Nodes中，由于只存在值的概念，因此GVN算法将非常简单：如果一个浮动节点本身不存在内存副作用（由于GVN可能影响节点调度，如果有内存副作用的话，那么将引发一些源代码中不可能出现的情况） ，那么即时编译器只需判断该浮动节点是否与已存在的浮动节点的类型相同，所输入的IR节点是否一致，便可以将这两个浮动节点归并成一个。</p><pre><code>public static int foo(int a, int b) {\n    int sum = a * b;\n    if (a &gt; 0) {\n        sum += a * b;\n    }\n    if (b &gt; 0) {\n        sum += a * b;\n    }\n    return sum;\n}\n</code></pre><p>我们来看一个实际的案例。在上面这段代码中，如果a和b都大于0，那么我们需要做三次乘法。通过GVN之后，我们只会在B0中做一次乘法，并且在接下来的代码中直接使用乘法的结果，也就是4号*节点所代表的值。</p><p><img src=\"https://static001.geekbang.org/resource/image/f9/e1/f965693c5b1912f28065349b171832e1.png?wh=1092*1430\" alt=\"\"></p><p>我们可以将GVN理解为在IR图上的公共子表达式消除（Common Subexpression Elimination，CSE）。</p><p>这两者的区别在于，GVN直接比较值的相同与否，而CSE则是借助词法分析器来判断两个表达式相同与否。因此，在不少情况下，CSE还需借助常量传播来达到消除的效果。</p><h2>总结与实践</h2><p>今天我介绍了即时编译器的内部构造。</p><p>即时编译器将所输入的Java字节码转换成SSA IR，以便更好地进行优化。</p><p>具体来说，C2和Graal采用的是一种名为Sea-of-Nodes的IR，其特点用IR节点来代表程序中的值，并且将源程序中基于变量的计算转换为基于值的计算。</p><p>此外，我还介绍了C2和Graal的IR的可视化工具IGV，以及基于IR的优化GVN。</p><p>今天的实践环节，你可以尝试使用IGV来查看上一篇实践环节中的代码的具体编译过程。</p><p>你可以通过<a href=\"https://github.com/oracle/graal/releases/tag/idealgraphvisualizer-543\">该页面</a>下载当前版本的IGV。解压后，可运行脚本位于bin/idealgraphvisualizer中。IGV启动完成后，你可以通过下述指令将IR图打印至IGV中。（需附带Graal编译器的Java 10或以上版本。）</p><pre><code>// java -XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler -XX:CompileCommand='dontinline,CompilationTest::hash' -Dgraal.Dump=:3 -Dgraal.MethodFilter='CompilationTest.hash' -Dgraal.OptDeoptimizationGrouping=false CompilationTest\npublic class CompilationTest {\n  public static int hash(Object input) {\n    if (input instanceof Exception) {\n      return System.identityHashCode(input);\n    } else {\n      return input.hashCode();\n    }\n  }\n  public static void main(String[] args) throws InterruptedException {\n    for (int i = 0; i &lt; 500000; i++) {\n      hash(i);\n    }\n    Thread.sleep(2000);\n  }\n}\n</code></pre>","neighbors":{"left":{"article_title":"17 | 即时编译（下）","id":14070},"right":{"article_title":"19 |  Java字节码（基础篇）","id":14794}},"comments":[{"had_liked":false,"id":152919,"user_name":"夜行观星","can_delete":false,"product_type":"c1","uid":1010389,"ip_address":"","ucode":"C880CB39033929","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6a/d5/73c75eb3.jpg","comment_is_top":false,"comment_ctime":1574124595,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"65998634035","product_id":100010301,"comment_content":"看懂这篇文章，已经是一年之后，时间真快","like_count":15,"discussions":[{"author":{"id":1357311,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b5/ff/d1f205b0.jpg","nickname":"L","note":"","ucode":"5B847B2378854E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293567,"discussion_content":"这篇课代表没来    你来做个总结呗","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1595583105,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1010389,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/6a/d5/73c75eb3.jpg","nickname":"夜行观星","note":"","ucode":"C880CB39033929","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1357311,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b5/ff/d1f205b0.jpg","nickname":"L","note":"","ucode":"5B847B2378854E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335532,"discussion_content":"又过去一年了，哈哈，老师已经讲的很好了，没啥好总结的，我就补充些相关的基础知识吧。\n1、这篇主要讲中间表达形式，其实就是编译中常说的中间代码，了解完常见的几种中间代码表示：逆波兰表示、三地址码、四地址码后，来回头看文章中SSA-IR就好接受了。\n2、中间表达能够带来什么？其中之一的好处就是中间代码独立于目标机器，现代编译器通常会进行机器无关的程序性能优化。而关于中间代码优化部分，绕不过就是控制流分析（主要是找到程序中循环结构）与数据流分析（编译器掌握程序中变量定义和引用的情况，比如：活跃变量分析等），但在此之前需要把中间代码拆成一个个基本块，构建流图（对应文章中IR图，变成图了，许多图相关的算法就可以派上用场了），这些一般的要求都是了解过程即可。ps：算法部分的要求，高级编译设计一般属于科班高年级课程\n3、有了基本块、控制流分析、数据流分析积累下来的数据结构（还有之前积累词法分析、语法分析的符号表等），就可以做相应的优化，比如：公共子表达式删除、复制传播、代码外提等。\n上面仅仅是个人所了解部分，有错误之处，望谅解。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1608215024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":293567,"ip_address":""},"score":335532,"extra":""}]},{"author":{"id":1008404,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","nickname":"Jerry银银","note":"","ucode":"80DA1172A2360A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":101291,"discussion_content":"一年以后的我，这篇文章依然看不太懂","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577286181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008404,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","nickname":"Jerry银银","note":"","ucode":"80DA1172A2360A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":101284,"discussion_content":"你这一年进步太大了……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577286103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1245468,"avatar":"https://static001.geekbang.org/account/avatar/00/13/01/1c/d638d46e.jpg","nickname":"宋世通","note":"","ucode":"C7AA3F0E6930F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1008404,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","nickname":"Jerry银银","note":"","ucode":"80DA1172A2360A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390479,"discussion_content":"看大佬意思要把编译原理学一学","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629857869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":101284,"ip_address":""},"score":390479,"extra":""},{"author":{"id":3017215,"avatar":"https://static001.geekbang.org/account/avatar/00/2e/09/ff/cedb2a8d.jpg","nickname":"南方。","note":"","ucode":"DE799EC5D5F891","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1245468,"avatar":"https://static001.geekbang.org/account/avatar/00/13/01/1c/d638d46e.jpg","nickname":"宋世通","note":"","ucode":"C7AA3F0E6930F3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579106,"discussion_content":"看完编译原理再来看这篇 你会发现真的通透很多！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657176352,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":390479,"ip_address":""},"score":579106,"extra":""}]}]},{"had_liked":false,"id":48109,"user_name":"搬砖的孟达","can_delete":false,"product_type":"c1","uid":1201067,"ip_address":"","ucode":"8F280479C2C83D","user_header":"https://static001.geekbang.org/account/avatar/00/12/53/ab/20f1f4e8.jpg","comment_is_top":false,"comment_ctime":1544357993,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"53083965545","product_id":100010301,"comment_content":"看不太懂。哈哈哈...可能基础还不到这个水平吧，多看多思考吧。","like_count":12},{"had_liked":false,"id":175968,"user_name":"the geek","can_delete":false,"product_type":"c1","uid":1506723,"ip_address":"","ucode":"71DECBC814A539","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLz3icr3mGs5ib8FbSPQZ2ic3ib90mHkd1btQrmGacZjJxfYXrerIdaTxglKyCicFzLcEAb6deC2cWjE5Q/132","comment_is_top":false,"comment_ctime":1580895378,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27350699154","product_id":100010301,"comment_content":"这篇文章最好还是看懂，后面的方法内联章节会经常出现IR图，我一开始也是看了个大概，看了方法内联后，回来静下心一看，还是比较简单的<br>主要就是将方法的执行流程转换为IR图。<br>IR图中一些符号解释(以下是个人简单理解，仅供参考):<br>1. 常量值:C(0)、C(1)。就是常量值1、2  (类型是i32)<br>2. 参数值P(0)、P(1)。就是方法参数0和方法参数1=&gt;上面int a,int b<br>3.Phi(IR节点1,IR节点2,内存类型)。(i32可能是说int 32位 ，方便分配内存吧?个人猜测老师指正)","like_count":7},{"had_liked":false,"id":22473,"user_name":"ext4","can_delete":false,"product_type":"c1","uid":1180826,"ip_address":"","ucode":"FC881AECAC1974","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/9a/f2c0a206.jpg","comment_is_top":false,"comment_ctime":1535693517,"is_pvip":false,"replies":[{"id":"8203","content":"首先这些dependency都是为了scheduling服务的，也就是把图序列化为指令序列，图节点中的相互依赖会让它们拥有先后关系。<br><br>个人理解哈，原本的IO dependency就是IO顺序，Cliff Click大神的论文中说的是没有内存映射的IO访问。现在C2应该用来泛指非内存访问的JVM状态。<br><br>Graal里这种额外的依赖关系都是用控制流先后顺序来表达的。","user_name":"作者回复","comment_id":22473,"uid":"1176688","ip_address":"","utype":1,"ctime":1535966896,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"27305497293","product_id":100010301,"comment_content":"除了你上面提到的内存依赖，我看到C2的ideal graph里面还有一种依赖叫做I&#47;O dependency，这个在Graal的graph里似乎也没有了。可以解释一下C2的这个I&#47;O dependency是做什么的，以及Graal是如何替代这种依赖的表示的么？","like_count":6,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423135,"discussion_content":"首先这些dependency都是为了scheduling服务的，也就是把图序列化为指令序列，图节点中的相互依赖会让它们拥有先后关系。\n\n个人理解哈，原本的IO dependency就是IO顺序，Cliff Click大神的论文中说的是没有内存映射的IO访问。现在C2应该用来泛指非内存访问的JVM状态。\n\nGraal里这种额外的依赖关系都是用控制流先后顺序来表达的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535966896,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130233,"user_name":"neohope","can_delete":false,"product_type":"c1","uid":1043475,"ip_address":"","ucode":"C0268F6E7E2B6E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","comment_is_top":false,"comment_ctime":1567409769,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"18747278953","product_id":100010301,"comment_content":"想问一下老师，idealgraphvisualizer中，有没有办法看到全局的IR图？开启后，好像有很多次优化，每次都只能看到一部分哦。<br><br>此外：<br>1、官网下载的idealgraphvisualizer是2011年版本，没法用，要用直接在github上下载的版本<br>2、idealgraphvisualizer当前版本，好像只支持JDK1.8？<br>3、从graal官网下载的版本只有JDK1.8，下载了也没有用。直接下载Oracle JDK11就可以了<br>4、最后例子的Demo，JDK11参数要调整一下：<br>java -XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler -XX:CompileCommand=dontinline,&quot;CompilationTest.hash()&quot; -Dgraal.Dump=:3 -Dgraal.OptDeoptimizationGrouping=false CompilationTest<br>5、前面两个例子，需要用Debug版本的JDK。最后一个不需要。<br>","like_count":4,"discussions":[{"author":{"id":1043475,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","nickname":"neohope","note":"","ucode":"C0268F6E7E2B6E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7616,"discussion_content":"此外，在windows下的小伙伴可以从这里下载openjdk的debug版本：https://github.com/ojdkbuild/ojdkbuild/releases。linux下的小伙伴，其实自己编译就好了，也花不了太多时间。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567587466,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1184898,"avatar":"https://static001.geekbang.org/account/avatar/00/12/14/82/4a2f4da0.jpg","nickname":"ﺭ并踢了你一下ﺭ冯浩","note":"","ucode":"E09FC33F684E49","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326098,"discussion_content":"你好，我想问一下为什么\nd:\\java11\\bin\\java -XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler -XX:CompileCommand=dontinline,&#34;CompilationTest.hash&#34; -Dgraal.Dump=:3 -Dgraal.MethodFilter=&#34;CompilationTest.hash&#34; -Dgraal.OptDeoptimizationGrouping=false -Dgraal.LogFile=log.log CompilationTest\n这个可以打印出来bgv的文件  ---代码是实践题\n\n\nd:\\java11\\bin\\java -XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler -XX:CompileCommand=dontinline,&#34;Demo.foo&#34; -Dgraal.Dump=:3 -Dgraal.MethodFilter=&#34;Demo.foo&#34; -Dgraal.OptDeoptimizationGrouping=false -Dgraal.LogFile=log.log1 Demo\n这个打印不出来呢\n这是文件\npublic class Demo{\n\n    public static void main(String[] args) {\n        foo(5);\n    }\n\n    public static int foo(int count){\n        int sum = 0;\n        for(int i = 0; i < count; i++){\n            sum += i;\n        }\n        return sum;\n    }\n\n    \n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605520855,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1184898,"avatar":"https://static001.geekbang.org/account/avatar/00/12/14/82/4a2f4da0.jpg","nickname":"ﺭ并踢了你一下ﺭ冯浩","note":"","ucode":"E09FC33F684E49","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360929,"discussion_content":"直接去GraalVM官网下载就可以了，上文老师贴的网址工具都很老了。我下的是V20的版本，提供JDK8/11，不过要研究Graal的话，本机还是要装JDK11,的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616558410,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":326098,"ip_address":""},"score":360929,"extra":""}]}]},{"had_liked":false,"id":22736,"user_name":"Shine","can_delete":false,"product_type":"c1","uid":1022568,"ip_address":"","ucode":"C8C617B87C63C7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9a/68/92caeed6.jpg","comment_is_top":false,"comment_ctime":1535944633,"is_pvip":false,"replies":[{"id":"8210","content":"先说一下，这个是Graal的IR。<br><br>基本块的划分规则是根据其定义来的，即最长的，顺序执行的节点集。<br><br>start begin end是为了标注基本块的起始和结尾，便于优化，没有其他实际意义。<br><br>merge节点可以看成控制流交汇的节点，在Graal里就是用来挂phi节点的。最后有两个return而没有merge，实际上是另外一个优化code duplicati，将原本的merge优化掉，生成两条独立程序路径。在这两条路径中，b的值是唯一的，而不是一个phi方法。","user_name":"作者回复","comment_id":22736,"uid":"1176688","ip_address":"","utype":1,"ctime":1535968438,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"18715813817","product_id":100010301,"comment_content":"IR图有点看不懂。基本块是根据什么原则划分的？ 有些块有start,begin, end等等，有些块却没有？ 为什么GVN代码中，都是判断a,b是否大于0，图中B3来了一个Merge节点?","like_count":4,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423246,"discussion_content":"先说一下，这个是Graal的IR。\n\n基本块的划分规则是根据其定义来的，即最长的，顺序执行的节点集。\n\nstart begin end是为了标注基本块的起始和结尾，便于优化，没有其他实际意义。\n\nmerge节点可以看成控制流交汇的节点，在Graal里就是用来挂phi节点的。最后有两个return而没有merge，实际上是另外一个优化code duplicati，将原本的merge优化掉，生成两条独立程序路径。在这两条路径中，b的值是唯一的，而不是一个phi方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535968438,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172690,"user_name":"Ken张云忠","can_delete":false,"product_type":"c1","uid":1134288,"ip_address":"","ucode":"D0BAC9FC17DE2B","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","comment_is_top":false,"comment_ctime":1579251967,"is_pvip":false,"replies":[{"id":"67008","content":"那个比较老，你可以去下载GraalVM，里面有附带igv的。OpenJDK 7编译是比较难，很多奇奇怪怪的依赖问题，8之后就好多了","user_name":"作者回复","comment_id":172690,"uid":"1176688","ip_address":"","utype":1,"ctime":1579258715,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"14464153855","product_id":100010301,"comment_content":"郑老师,本节中第一张IR图和下面的Control Flow图是使用http:&#47;&#47;ssw.jku.at&#47;General&#47;Staff&#47;TW&#47;igv.html的IdealGraphVisualizer查看的吧.<br>这个工具使用jdk7启动起来后,但是在执行时必须要使用debug版的jdk7才能执行参数-XX:PrintIdealGraphLevel=2 -XX:PrintIdealGraphFile=ideal.xml,一直困扰在获取不到debug版的jdk7,下载openjdk7自己编译过程中遇到了太多问题,尤其是build-debug&#47;hotspot中太多代码编译不过去的问题.<br>老师是怎么样一步步得到debug版的jdk7的?","like_count":3,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481819,"discussion_content":"那个比较老，你可以去下载GraalVM，里面有附带igv的。OpenJDK 7编译是比较难，很多奇奇怪怪的依赖问题，8之后就好多了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579258715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130618,"user_name":"鱼肚","can_delete":false,"product_type":"c1","uid":1127630,"ip_address":"","ucode":"ECE205AB351CE2","user_header":"https://static001.geekbang.org/account/avatar/00/11/34/ce/b27f79e2.jpg","comment_is_top":false,"comment_ctime":1567495406,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14452397294","product_id":100010301,"comment_content":"原本里的 IGV 用不了，用这个 https:&#47;&#47;github.com&#47;oracle&#47;graal&#47;releases&#47;tag&#47;idealgraphvisualizer-543","like_count":3},{"had_liked":false,"id":178831,"user_name":"Ken张云忠","can_delete":false,"product_type":"c1","uid":1134288,"ip_address":"","ucode":"D0BAC9FC17DE2B","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","comment_is_top":false,"comment_ctime":1581837428,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5876804724","product_id":100010301,"comment_content":"用debug版jdk8的导出的ideal.xml只能在jdk7旧版的IGV中打开，打开后与老师的IR图差异很大，完全看不出老师所讲的内容。<br>后来想使用jdk11的graal来查看，按照实践中指令方式来运行，指令并没有把IR图打印至IGV中，不知道怎么来查看IR图了？<br>public class Practice {<br>  public static void main(String[] args){<br>    foo(5);<br>  }<br>  public static int foo(int count) {<br>    int sum = 0;<br>    for (int i = 0; i &lt; count; i++) {<br>      sum += i;<br>    }<br>    return sum;<br>  }<br>}<br>java -XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler -XX:CompileCommand=&#39;dontinline,Practice::hash&#39; -Dgraal.Dump=:3 -Dgraal.MethodFilter=&#39;Practice.hash&#39; -Dgraal.OptDeoptimizationGrouping=false Practice","like_count":1},{"had_liked":false,"id":96268,"user_name":"草戊","can_delete":false,"product_type":"c1","uid":1044202,"ip_address":"","ucode":"F1B0CB0A4FA762","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/ea/c8136dfd.jpg","comment_is_top":false,"comment_ctime":1558370361,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5853337657","product_id":100010301,"comment_content":"有好多编译原理的东西","like_count":1},{"had_liked":false,"id":309334,"user_name":"dominiczhu","can_delete":false,"product_type":"c1","uid":2070984,"ip_address":"","ucode":"9C87F77CCE06C8","user_header":"","comment_is_top":false,"comment_ctime":1630052059,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630052059","product_id":100010301,"comment_content":"pass了，ir图那块解释得实在看不懂，各个节点是什么，每个节点是怎样导致执行顺序流转的，都没有。","like_count":0},{"had_liked":false,"id":274517,"user_name":"八九","can_delete":false,"product_type":"c1","uid":1191617,"ip_address":"","ucode":"B996A884BFA474","user_header":"https://static001.geekbang.org/account/avatar/00/12/2e/c1/0fcd29ab.jpg","comment_is_top":false,"comment_ctime":1611044697,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611044697","product_id":100010301,"comment_content":"看了好几遍，边看边整理思路，看懂个大概。这是我边看边画的知识点：<br>java源代码---java编译器---&gt;java字节码---即时编译器---&gt;机器码<br>编译器：前端：IR（词法分析、语法分析、语义分析---&gt;生成中间表达形式）<br>             后端：IR优化---&gt;生成目标代码<br>即时编译器直接将java字节码作为一种IR，即时编译器将java字节码转为SSA IR(IR图)<br>静态单赋值IR(SSA IR)：每个变量只能被赋值一次，而且只有当变量被赋值之后才能使用<br>SSA IR存在的问题：不同执行路径会对同一个变量设置不同的值<br>        解决方法：Phi函数-能够根据不同的执行路径选择不同的值<br><br>1.C2采用Sea-of-Nodes的SSA IR，去除变量的概念，直接采用变量所指向的值进行运算。<br>  如：Phi(y1,y2) ---&gt; Phi(1,0)<br>C2没有固定节点的概念，所有的IR节点都是浮动节点。将根据各个基本块头尾之间的控制依赖，以及数据依赖和内存依赖，来进行节点调度。<br>节点调度：在编译过程中，编译器需要（多次）计算浮动节点具体的排布位置。这个过程称为节点调度。<br>内存依赖：假设一段程序往内存中存储了一个值，而后又读取同一内存，那么显然程序希望读取到的是所存储的值。<br>即时编译器不能任意调度对同一内存地址的读写，因为它们之间存在依赖关系。<br>C2的做法便是将这种时序上的先后记录为内存依赖，并让节点调度算法在进行调度时考虑这些内存依赖关系。\t\t  <br><br>2.Graal的IR也是Sea-of-Nodes类型，可理解为是C2 IR的精简版本<br>Graal将内存读写转换成固定节点。由于固定节点存在先后关系，因此无需额外记录内存依赖。<br><br><br>IR的可视化工具 IGV：被控制流边所连接的是固定节点，其他的皆属于浮动节点。<br>IR图是竖着看，然后遇到if分支就会有两个流程（满足与不满足），hpi函数里面用了节点上的编号，我理解是这样。<br><br>GVN是一种发现并消除等价计算的优化技术。例如如果一段程序中出现多次相同的乘法，那么即时编译器可以将这些乘法合并为一个。<br>在 Sea-of-Nodes 中，由于只存在值的概念，因此 GVN 算法将非常简单：<br>如果一个浮动节点本身不存在内存副作用（由于 GVN 可能影响节点调度，如果有内存副作用的话，那么将引发一些源代码中不可能出现的情况） ，<br>那么即时编译器只需判断该浮动节点是否与已存在的浮动节点的类型相同，所输入的 IR 节点是否一致，便可以将这两个浮动节点归并成一个。<br><br>有个问题：内存副作用是什么意思？有点不理解，麻烦帮我解答一下。<br>","like_count":1},{"had_liked":false,"id":253301,"user_name":"丁小明","can_delete":false,"product_type":"c1","uid":1207622,"ip_address":"","ucode":"CC23857B8D75D5","user_header":"https://static001.geekbang.org/account/avatar/00/12/6d/46/e16291f8.jpg","comment_is_top":false,"comment_ctime":1602678764,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602678764","product_id":100010301,"comment_content":"结合了第三版的java虚拟机，终于懂了！","like_count":0},{"had_liked":false,"id":221717,"user_name":"leaf","can_delete":false,"product_type":"c1","uid":1060139,"ip_address":"","ucode":"B2CFF00AFA7494","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKdzXiawss5gGiax48CJGAJpha4pJksPia7J7HsiatYwjBA9w1bkrDicXfQz1SthaG3w1KJ2ibOxpia5wfbQ/132","comment_is_top":false,"comment_ctime":1590573326,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590573326","product_id":100010301,"comment_content":"总结与实践中的例子，用源码中的命令在igv中没有看到任何东西啊！请问老师我漏了什么设置吗","like_count":0},{"had_liked":false,"id":175444,"user_name":"hasWhere","can_delete":false,"product_type":"c1","uid":1093541,"ip_address":"","ucode":"2C2B2988107489","user_header":"https://static001.geekbang.org/account/avatar/00/10/af/a5/afa1d7d7.jpg","comment_is_top":false,"comment_ctime":1580721449,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580721449","product_id":100010301,"comment_content":"先mark下，看的迷糊","like_count":0},{"had_liked":false,"id":165708,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1577285950,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577285950","product_id":100010301,"comment_content":"学虚拟机到今天，才慢慢明白，为什么R大在博客里提到很大一部分是学习编译原理的知识。<br><br>郑博，好想，你你能写篇文章，如何才能做到【稍微精通】虚拟机？","like_count":0},{"had_liked":false,"id":126776,"user_name":"樱小路依然","can_delete":false,"product_type":"c1","uid":1269957,"ip_address":"","ucode":"DBA9FF68015FE5","user_header":"https://static001.geekbang.org/account/avatar/00/13/60/c5/69286d58.jpg","comment_is_top":false,"comment_ctime":1566470969,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566470969","product_id":100010301,"comment_content":"呃，感觉有点不懂、<br>1.老师先说前端编译器将Java代码优化为IR<br>2.Java编译器将源代码编译为Java字节码<br>3.即时编译器将Java字节码当做一种IR<br>4.Java字节码并不适合作为可供优化的IR，因为其为 SSA IR，采用静态单赋值的方式<br><br>然而，后面老师又说：总之，即时编译器会将Java字节码转化为SSA IR。<br><br>请问到底是 Java编译器将Java源代码编译、转化为 SSA IR<br>还是即时编译器将Java字节码转换为SSA IR？","like_count":0},{"had_liked":false,"id":126757,"user_name":"Jthan","can_delete":false,"product_type":"c1","uid":1112381,"ip_address":"","ucode":"E771101B231566","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/3d/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1566465319,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566465319","product_id":100010301,"comment_content":"好靠前","like_count":0},{"had_liked":false,"id":34601,"user_name":"likun","can_delete":false,"product_type":"c1","uid":1030816,"ip_address":"","ucode":"9145ED059CCC6D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/a0/f03d20cd.jpg","comment_is_top":false,"comment_ctime":1540216056,"is_pvip":false,"replies":[{"id":"12763","content":"导出Graal IR不用debug版本的JDK","user_name":"作者回复","comment_id":34601,"uid":"1176688","ip_address":"","utype":1,"ctime":1540822245,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"1540216056","product_id":100010301,"comment_content":"你好 我这边找不到bebug版本的jdk10，好像无法查看ir图","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427267,"discussion_content":"导出Graal IR不用debug版本的JDK","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540822245,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}