{"id":737743,"title":"08｜解析参数：通过引入Cookie和Session避免反复登录","content":"<p>你好，我是郭屹。今天我们继续手写MiniTomcat。</p><p>上一节课我们完成了对Request、Response的Header信息解析，并且采用Facade模式封装了我们希望暴露给外界的方法体，避免被业务程序员直接调用实现类的内部方法。</p><p>在实际的请求结构中，除了消息头部的参数之外，请求的URI后缀往往会带上请求参数，例如 <code>/app1/servlet1?username=Tommy&amp;docid=TS0001</code>，路径和参数之间用“?”分隔，参数与参数之间使用“&amp;”隔开，这是我们这节课需要解析的部分。</p><p>除此之外，Header中可能还会包含用户信息，使用Cookie存储，但用户信息使用明文传递也不大好，而且Cookie是存储在客户端的，为了优化这个问题，Servlet规范规定了Session的用途，这节课我们也会解析并设置Cookie和Session。</p><p>下面我们一起动手来实现。</p><h2>项目结构</h2><p>这节课我们新增Session类，并对其进行封装而定义SessionFacade类。同时会增加TestServlet类，以便更好地测试。pom.xml依赖并未发生任何变化。项目结构如下：</p><pre><code class=\"language-plain\">MiniTomcat\n├─ src\n│  ├─ main\n│  │  ├─ java\n│  │  │  ├─ server\n│  │  │  │  ├─ DefaultHeaders.java\n│  │  │  │  ├─ HttpConnector.java\n│  │  │  │  ├─ HttpHeader.java\n│  │  │  │  ├─ HttpProcessor.java\n│  │  │  │  ├─ HttpRequest.java\n│  │  │  │  ├─ HttpRequestFacade.java\n│  │  │  │  ├─ HttpRequestLine.java\n│  │  │  │  ├─ HttpResponse.java\n│  │  │  │  ├─ HttpResponseFacade.java\n│  │  │  │  ├─ HttpServer.java\n│  │  │  │  ├─ Request.java\n│  │  │  │  ├─ Response.java\n│  │  │  │  ├─ ServletProcessor.java\n│  │  │  │  ├─ Session.java\n│  │  │  │  ├─ SessionFacade.java\n│  │  │  │  ├─ SocketInputStream.java\n│  │  │  │  ├─ StatisResourceProcessor.java\n│  │  ├─ resources\n│  ├─ test\n│  │  ├─ java\n│  │  │  ├─ test\n│  │  │  │  ├─ HelloServlet.java\n│  │  │  │  ├─ TestServlet.java\n│  │  ├─ resources\n├─ webroot\n│  ├─ test\n│  │  ├─ HelloServlet.class\n│  │  ├─ TestServlet.class\n│  ├─ hello.txt\n├─ pom.xml\n</code></pre><!-- [[[read_end]]] --><h2>URI请求参数的解析</h2><p>前面我们做到了解析Request Line一行，包括请求方法、URI与请求协议。但在实际请求中，URI后面经常会增加请求参数。比如：</p><pre><code class=\"language-plain\">GET /app1/servlet1?username=Tommy&amp;docid=TS0001 HTTP/1.1\n</code></pre><p>在这种情况下，以问号分隔的URI，前一部分是我们常说的请求地址，而后面则是请求的具体参数，接下来我们要把这部分的参数解析出来。</p><p>此前，在HttpRequest类的parse()方法中，我们已经用this.sis.readRequestLine(requestLine)这一行代码，获取到了Request Line。但我们把整个地址都当作了URI，因此有了下面这种写法。</p><pre><code class=\"language-java\">this.uri = new String(requestLine.uri,0,requestLine.uriEnd);\n</code></pre><p>但现在我们需要截取一部分，将地址与参数分离，所以改写一下，新增parseRequestLine方法。</p><pre><code class=\"language-java\">public void parse(Socket socket) {\n    try {\n        parseConnection(socket);\n        this.sis.readRequestLine(requestLine);\n        parseRequestLine();\n        parseHeaders();\n    } catch (IOException e) {\n        e.printStackTrace();\n    } catch (ServletException e) {\n        e.printStackTrace();\n    }\n}\nprivate void parseRequestLine() {\n\t\tint question = requestLine.indexOf(\"?\");\n\t&nbsp; &nbsp; if (question &gt;= 0) {\n\t&nbsp; &nbsp; &nbsp; &nbsp; queryString=new String(requestLine.uri, question + 1, requestLine.uriEnd - question - 1);\n\t&nbsp; &nbsp; &nbsp; &nbsp; uri = new String(requestLine.uri, 0, question);\n\t&nbsp; &nbsp; } else {\n\t&nbsp; &nbsp; &nbsp; &nbsp; queryString = null;\n\t&nbsp; &nbsp; &nbsp; &nbsp; uri = new String(requestLine.uri, 0, requestLine.uriEnd);\n\t&nbsp; &nbsp; }\n    }\n}\n</code></pre><p>parseRequestLine方法比较简单，主要是判断路径里是否有问号，通过问号分隔，取出地址和参数。</p><p>上述考虑的主要是GET请求的处理，而POST请求则一般把请求参数放入请求体之中。我们来看一个POST请求的示例。</p><pre><code class=\"language-plain\">POST /test HTTP/1.1\nHost: www.test.com\nUser-Agent: Mozilla/5.0(Windows; U; Windows NT 5.1; en-US; rv:1.7.6)Gecko/20050225 Firefox/1.0.1\nContent-Type:application/x-www-form-urlencoded\nContent-Length: 40\nConnection: Keep-Alive\n\nname=Professional%20Ajax&amp;publisher=Wiley\n</code></pre><p>我们可以看到，这种情况与GET请求类似，只是参数在请求体内，而且对URL做了encode编码，在这将一个空格转换成了%20。</p><p>接下来我们在HttpRequest类里定义数据结构用来存储参数信息。</p><pre><code class=\"language-java\">protected Map&lt;String, String[]&gt; parameters = new ConcurrentHashMap&lt;&gt;();\n</code></pre><p>注意其中的value是字符串数组，因为部分参数存在多个值与之对应，例如options、checkbox等。</p><p>目前我们处理POST方法比较简单，只考虑文本类型。其实可以支持文本、二进制、压缩包，都是通过Content-Type指定。常见的有application/json、application/xml等。</p><p>还有POST可以混合，也就是multipart/form-data多部分，有的是文本，有的是二进制，比如图片之类的。我们现在也先暂时放到一边。</p><p>首先我们改造SocketInputStream，由继承InputStream改为继承ServletInputStream。你可以看一下完整代码。</p><pre><code class=\"language-java\">package server;\nimport javax.servlet.ReadListener;\nimport javax.servlet.ServletInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\npublic class SocketInputStream extends ServletInputStream {\n    private static final byte CR = (byte) '\\r';\n    private static final byte LF = (byte) '\\n';\n    private static final byte SP = (byte) ' ';\n    private static final byte HT = (byte) '\\t';\n    private static final byte COLON = (byte) ':';\n    private static final int LC_OFFSET = 'A' - 'a';\n    protected byte buf[];\n    protected int count;\n    protected int pos;\n    protected InputStream is;\n    public SocketInputStream(InputStream is, int bufferSize) {\n        this.is = is;\n        buf = new byte[bufferSize];\n    }\n    //按照格式解析请求行\n    public void readRequestLine(HttpRequestLine requestLine)\n        throws IOException {\n        int chr = 0;\n        do {\n            try {\n                chr = read();\n            } catch (IOException e) {\n            }\n        } while ((chr == CR) || (chr == LF));\n        pos--;\n        int maxRead = requestLine.method.length;\n        int readStart = pos;\n        int readCount = 0;\n        boolean space = false;\n        //这里先获取请求的method\n        while (!space) {\n            if (pos &gt;= count) {\n                int val = read();\n                if (val == -1) {\n                    throw new IOException(\"requestStream.readline.error\");\n                }\n                pos = 0;\n                readStart = 0;\n            }\n            if (buf[pos] == SP) {\n                space = true;\n            }\n            requestLine.method[readCount] = (char) buf[pos];\n            readCount++;\n            pos++;\n        }\n        requestLine.uriEnd = readCount - 1;\n        maxRead = requestLine.uri.length;\n        readStart = pos;\n        readCount = 0;\n        space = false;\n        boolean eol = false;\n        //再获取请求的uri\n        while (!space) {\n            if (pos &gt;= count) {\n                int val = read();\n                if (val == -1)\n                    throw new IOException(\"requestStream.readline.error\");\n                pos = 0;\n                readStart = 0;\n            }\n            if (buf[pos] == SP) {\n                space = true;\n            }\n            requestLine.uri[readCount] = (char) buf[pos];\n            readCount++;\n            pos++;\n        }\n        requestLine.uriEnd = readCount - 1;\n        maxRead = requestLine.protocol.length;\n        readStart = pos;\n        readCount = 0;\n        //最后获取请求的协议\n        while (!eol) {\n            if (pos &gt;= count) {\n                int val = read();\n                if (val == -1)\n                    throw new IOException(\"requestStream.readline.error\");\n                pos = 0;\n                readStart = 0;\n            }\n            if (buf[pos] == CR) {\n                // Skip CR.\n            } else if (buf[pos] == LF) {\n                eol = true;\n            } else {\n                requestLine.protocol[readCount] = (char) buf[pos];\n                readCount++;\n            }\n            pos++;\n        }\n        requestLine.protocolEnd = readCount;\n    }\n    //读头信息，格式是header name:value\n    public void readHeader(HttpHeader header)\n        throws IOException {\n        int chr = read();\n        if ((chr == CR) || (chr == LF)) { // Skipping CR\n            if (chr == CR)\n                read(); // Skipping LF\n            header.nameEnd = 0;\n            header.valueEnd = 0;\n            return;\n        } else {\n            pos--;\n        }\n        // 读取header名\n        int maxRead = header.name.length;\n        int readStart = pos;\n        int readCount = 0;\n        boolean colon = false;\n        //以:分隔，前面的字符认为是header name\n        while (!colon) {\n            // 我们处于内部缓冲区的末尾\n            if (pos &gt;= count) {\n                int val = read();\n                if (val == -1) {\n                    throw new IOException(\"requestStream.readline.error\");\n                }\n                pos = 0;\n                readStart = 0;\n            }\n            if (buf[pos] == COLON) {\n                colon = true;\n            }\n            char val = (char) buf[pos];\n            if ((val &gt;= 'A') &amp;&amp; (val &lt;= 'Z')) {\n                val = (char) (val - LC_OFFSET);\n            }\n            header.name[readCount] = val;\n            readCount++;\n            pos++;\n        }\n        header.nameEnd = readCount - 1;\n        // 读取 header 值（可以多行）\n        maxRead = header.value.length;\n        readStart = pos;\n        readCount = 0;\n        int crPos = -2;\n        boolean eol = false;\n        boolean validLine = true;\n        //处理行，因为一个header的值有可能多行(一行的前面是空格或者制表符)，需要连续处理\n        while (validLine) {\n            boolean space = true;\n            // Skipping spaces\n            // Note : 只有前面的空格被跳过\n            while (space) {\n                // We're at the end of the internal buffer\n                if (pos &gt;= count) {\n                    // Copying part (or all) of the internal buffer to the line\n                    // buffer\n                    int val = read();\n                    if (val == -1)\n                        throw new IOException(\"requestStream.readline.error\");\n                    pos = 0;\n                    readStart = 0;\n                }\n                if ((buf[pos] == SP) || (buf[pos] == HT)) {\n                    pos++;\n                } else {\n                    space = false;\n                }\n            }\n            //一直处理到行结束\n            while (!eol) {\n                // We're at the end of the internal buffer\n                if (pos &gt;= count) {\n                    // Copying part (or all) of the internal buffer to the line\n                    // buffer\n                    int val = read();\n                    if (val == -1)\n                        throw new IOException(\"requestStream.readline.error\");\n                    pos = 0;\n                    readStart = 0;\n                }\n                //回车换行表示行结束\n                if (buf[pos] == CR) {\n                } else if (buf[pos] == LF) {\n                    eol = true;\n                } else {\n                    int ch = buf[pos] &amp; 0xff;\n                    header.value[readCount] = (char) ch;\n                    readCount++;\n                }\n                pos++;\n            }\n            //再往前读一个字符，如果是空格或制表符号则继续，多行处理的情况\n            int nextChr = read();\n            if ((nextChr != SP) &amp;&amp; (nextChr != HT)) {\n                pos--;\n                validLine = false;\n            } else {\n                eol = false;\n                header.value[readCount] = ' ';\n                readCount++;\n            }\n        }\n        header.valueEnd = readCount;\n    }\n    @Override\n    public int read() throws IOException {\n        if (pos &gt;= count) {\n            fill();\n            if (pos &gt;= count) {\n                return -1;\n            }\n        }\n        return buf[pos++] &amp; 0xff;\n    }\n    public int available() throws IOException {\n        return (count - pos) + is.available();\n    }\n    public void close() throws IOException {\n        if (is == null) {\n            return;\n        }\n        is.close();\n        is = null;\n        buf = null;\n    }\n    protected void fill() throws IOException {\n        pos = 0;\n        count = 0;\n        int nRead = is.read(buf, 0, buf.length);\n        if (nRead &gt; 0) {\n            count = nRead;\n        }\n    }\n    @Override\n    public boolean isFinished() {\n        return false;\n    }\n    @Override\n    public boolean isReady() {\n        return false;\n    }\n    @Override\n    public void setReadListener(ReadListener readListener) {\n    }\n}\n</code></pre><p>随后在HttpRequest的parseParameters方法内，我们就可以通过getInputStream()方法读取请求体内容。</p><pre><code class=\"language-java\">protected void parseParameters() {\n    //设置字符集\n    String encoding = getCharacterEncoding();\n    if (encoding == null) {\n        encoding = \"ISO-8859-1\";\n    }\n    //获取查询串\n    String qString = getQueryString();\n    if (qString != null) {\n        byte[] bytes = new byte[qString.length()];\n        try {\n            bytes=qString.getBytes(encoding);\n            parseParameters(this.parameters, bytes, encoding);\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();;\n        }\n    }\n    //获取 content Type\n    String contentType = getContentType();\n    if (contentType == null)\n        contentType = \"\";\n    int semicolon = contentType.indexOf(';');\n    if (semicolon &gt;= 0) {\n        contentType = contentType.substring(0, semicolon).trim();\n    }\n    else {\n        contentType = contentType.trim();\n    }\n    //对POST方法，从body中解析参数\n    if (\"POST\".equals(getMethod()) &amp;&amp; (getContentLength() &gt; 0)\n            &amp;&amp; \"application/x-www-form-urlencoded\".equals(contentType)) {\n        try {\n            int max = getContentLength();\n            int len = 0;\n            byte buf[] = new byte[getContentLength()];\n            ServletInputStream is = getInputStream();\n            while (len &lt; max) {\n                int next = is.read(buf, len, max - len);\n                if (next &lt; 0) {\n                    break;\n                }\n                len += next;\n            }\n            is.close();\n            if (len &lt; max) {\n                throw new RuntimeException(\"Content length mismatch\");\n            }\n            parseParameters(this.parameters, buf, encoding);\n        }\n        catch (UnsupportedEncodingException ue) {\n        }\n        catch (IOException e) {\n            throw new RuntimeException(\"Content read fail\");\n        }\n    }\n}\n\n//十六进制字符到数字的转换\nprivate byte convertHexDigit(byte b) {\n    if ((b &gt;= '0') &amp;&amp; (b &lt;= '9')) return (byte)(b - '0');\n    if ((b &gt;= 'a') &amp;&amp; (b &lt;= 'f')) return (byte)(b - 'a' + 10);\n    if ((b &gt;= 'A') &amp;&amp; (b &lt;= 'F')) return (byte)(b - 'A' + 10);\n    return 0;\n}\npublic void parseParameters(Map&lt;String,String[]&gt; map, byte[] data, String encoding)\n        throws UnsupportedEncodingException {\n    if (parsed)\n        return;\n    if (data != null &amp;&amp; data.length &gt; 0) {\n        int    pos = 0;\n        int    ix = 0;\n        int    ox = 0;\n        String key = null;\n        String value = null;\n        //解析参数串，处理特殊字符\n        while (ix &lt; data.length) {\n            byte c = data[ix++];\n            switch ((char) c) {\n                case '&amp;':   //两个参数之间的分隔符，遇到这个字符保存已经解析的key和value\n                    value = new String(data, 0, ox, encoding);\n                    if (key != null) {\n                        putMapEntry(map,key, value);\n                        key = null;\n                    }\n                    ox = 0;\n                    break;\n                case '=': //参数的key/value的分隔符\n                    key = new String(data, 0, ox, encoding);\n                    ox = 0;\n                    break;\n                case '+': //特殊字符，空格\n                    data[ox++] = (byte)' ';\n                    break;\n                case '%': //处理%NN表示的ASCII字符\n                    data[ox++] = (byte)((convertHexDigit(data[ix++]) &lt;&lt; 4)\n                            + convertHexDigit(data[ix++]));\n                    break;\n                default:\n                    data[ox++] = c;\n            }\n        }\n        //最后一个参数没有&amp;结尾\n        //The last value does not end in '&amp;'.  So save it now.\n        if (key != null) {\n            value = new String(data, 0, ox, encoding);\n            putMapEntry(map,key, value);\n        }\n    }\n    parsed = true;\n}\n//给key设置新值，多值用数组来存储\nprivate static void putMapEntry( Map&lt;String,String[]&gt; map, String name, String value) {\n    String[] newValues = null;\n    String[] oldValues = (String[]) map.get(name);\n    if (oldValues == null) {\n        newValues = new String[1];\n        newValues[0] = value;\n    } else {\n        newValues = new String[oldValues.length + 1];\n        System.arraycopy(oldValues, 0, newValues, 0, oldValues.length);\n        newValues[oldValues.length] = value;\n    }\n    map.put(name, newValues);\n}\n</code></pre><p>我们通过getInputStream方法，一次性将字节流读入到buf[]里，统一通过 <code>parseParameters(Map&lt;String,String[]&gt; map, byte[] data, String encoding)</code> 重载方法进行处理。在这个方法中主要进行参数解析：依次读取byte，在这个过程中判断 “&amp;”“=”“+”等特殊字符。而且对于“%20”这样经过encode的字符要特殊处理，我们要用十六进制还原它的字符。</p><p>你可以看一下解析代码。</p><pre><code class=\"language-java\">&nbsp; &nbsp; private byte convertHexDigit(byte b) {\n&nbsp; &nbsp; &nbsp; &nbsp; if ((b &gt;= '0') &amp;&amp; (b &lt;= '9')) return (byte)(b - '0');\n&nbsp; &nbsp; &nbsp; &nbsp; if ((b &gt;= 'a') &amp;&amp; (b &lt;= 'f')) return (byte)(b - 'a' + 10);\n&nbsp; &nbsp; &nbsp; &nbsp; if ((b &gt;= 'A') &amp;&amp; (b &lt;= 'F')) return (byte)(b - 'A' + 10);\n&nbsp; &nbsp; &nbsp; &nbsp; return 0;\n&nbsp; &nbsp; }\n</code></pre><p>先拿到“2”这个字符，变成数字2，再拿到“0”这个字符，变成数字0，随后进行计算：2*16+0=32，再按照ascii变成字符，也就是空格。</p><pre><code class=\"language-java\">(byte)((convertHexDigit(data[ix++]) &lt;&lt; 4) + convertHexDigit(data[ix++]));\n</code></pre><p>最后我们完善HttpRequest类中与parameter相关的方法。</p><pre><code class=\"language-java\">\tpublic String getParameter(String name) {\n\t&nbsp; &nbsp; parseParameters();\n\t&nbsp; &nbsp; String values[] = (String[]) parameters.get(name);\n\t&nbsp; &nbsp; if (values != null)\n\t&nbsp; &nbsp; &nbsp; return (values[0]);\n\t&nbsp; &nbsp; else\n\t&nbsp; &nbsp; &nbsp; return (null);\t}\n\n\tpublic Map&lt;String, String[]&gt; getParameterMap() {\n\t&nbsp; &nbsp; parseParameters();\n\t&nbsp; &nbsp; return (this.parameters);\n\t}\n\n\tpublic Enumeration&lt;String&gt; getParameterNames() {\n\t&nbsp; &nbsp; parseParameters();\n\t&nbsp; &nbsp; return (Collections.enumeration(parameters.keySet()));\n\t}\n\n\tpublic String[] getParameterValues(String name) {\n\t&nbsp; &nbsp; parseParameters();\n\t&nbsp; &nbsp; String values[] = (String[]) parameters.get(name);\n\t&nbsp; &nbsp; if (values != null)\n\t&nbsp; &nbsp; &nbsp; return (values);\n\t&nbsp; &nbsp; else\n\t&nbsp; &nbsp; &nbsp; return null;\n\t}\n</code></pre><p>这里我们初步完成了HttpRequest类里对请求参数parameter的解析，所有的处理都是在获取到具体参数的时候，才调用parseParameters()方法，把时序放到这里，是为了性能考虑。</p><h2>引入Cookie和Session</h2><p>在处理完参数解析之后，我们接下来考虑解析Cookie，Cookie也是放在Header里的，固定格式是 <code>Cookie: userName=xxxx;password=pwd;</code>，因此我们再次解析Header的时候，如果发现Header的名称是Cookie，就进一步解析Cookie。因为Cookie的数据结构需要遵从javax.servlet.http.Cookie规定，而request里可以包含多个Cookie，所以我们会用数组来存储。</p><p>在解析Cookie后我们再看一下Session，其实这两部分的改造可以放在一起，所以我们后续一并讨论。</p><p>HTTP协议本身是无状态的，但是在网站登录后我们又不希望一跳转页面就需要重新输入账号密码登录，在这种情况下就需要记住第一次登录状态，而Servlet规范就规定了使用Session记住用户状态，定义接口为javax.servlet.http.HttpSession。</p><p>Session由服务器创建，存在SessionID，依靠URL或者是Cookie传送，把名称定义成jsessionid。今后浏览器与服务器之间的数据交换都带上这个jsessionid. 然后程序可以根据jsessionid拿到这个Session，把一些状态数据存储在Session里。</p><p>一个Session其实可以简单地看成一个Map结构，然后由我们的Server为每个客户端创建一个Session。</p><p>首先我们先定义Session类与SessionFacade类，用来处理Server中的逻辑。</p><p>Session.java类定义如下：</p><pre><code class=\"language-java\">package server;\npublic class Session implements HttpSession{\n    private String sessionid;\n    private long creationTime;\n    private boolean valid;\n    private Map&lt;String,Object&gt; attributes = new ConcurrentHashMap&lt;&gt;();\n    @Override\n    public long getCreationTime() {\n        return this.creationTime;\n    }\n    @Override\n    public String getId() {\n        return this.sessionid;\n    }\n    @Override\n    public long getLastAccessedTime() {\n        return 0;\n    }\n    @Override\n    public ServletContext getServletContext() {\n        return null;\n    }\n    @Override\n    public void setMaxInactiveInterval(int interval) {\n    }\n    @Override\n    public int getMaxInactiveInterval() {\n        return 0;\n    }\n    @Override\n    public HttpSessionContext getSessionContext() {\n        return null;\n    }\n    @Override\n    public Object getAttribute(String name) {\n        return this.attributes.get(name);\n    }\n    @Override\n    public Object getValue(String name) {\n        return this.attributes.get(name);\n    }\n    @Override\n    public Enumeration&lt;String&gt; getAttributeNames() {\n        return Collections.enumeration(this.attributes.keySet());\n    }\n    @Override\n    public String[] getValueNames() {\n        return null;\n    }\n    @Override\n    public void setAttribute(String name, Object value) {\n        this.attributes.put(name, value);\n    }\n    @Override\n    public void putValue(String name, Object value) {\n        this.attributes.put(name, value);\n    }\n    @Override\n    public void removeAttribute(String name) {\n        this.attributes.remove(name);\n    }\n    @Override\n    public void removeValue(String name) {\n    }\n    @Override\n    public void invalidate() {\n        this.valid = false;\n    }\n    @Override\n    public boolean isNew() {\n        return false;\n    }\n    public void setValid(boolean b) {\n        this.valid = b;\n    }\n    public void setCreationTime(long currentTimeMillis) {\n        this.creationTime = currentTimeMillis;\n    }\n    public void setId(String sessionId) {\n        this.sessionid = sessionId;\n    }\n}\n</code></pre><p>SessionFacade.java类定义如下：</p><pre><code class=\"language-java\">package server;\npublic class SessionFacade implements HttpSession{\n    private HttpSession session;\n    public SessionFacade(HttpSession session) {\n        this.session = session;\n    }\n    @Override\n    public long getCreationTime() {\n        return session.getCreationTime();\n    }\n    @Override\n    public String getId() {\n        return session.getId();\n    }\n    @Override\n    public long getLastAccessedTime() {\n        return session.getLastAccessedTime();\n    }\n    @Override\n    public ServletContext getServletContext() {\n        return session.getServletContext();\n    }\n    @Override\n    public void setMaxInactiveInterval(int interval) {\n        session.setMaxInactiveInterval(interval);\n    }\n    @Override\n    public int getMaxInactiveInterval() {\n        return session.getMaxInactiveInterval();\n    }\n    @Override\n    public HttpSessionContext getSessionContext() {\n        return session.getSessionContext();\n    }\n    @Override\n    public Object getAttribute(String name) {\n        return session.getAttribute(name);\n    }\n    @Override\n    public Object getValue(String name) {\n        return session.getValue(name);\n    }\n    @Override\n    public Enumeration&lt;String&gt; getAttributeNames() {\n        return session.getAttributeNames();\n    }\n    @Override\n    public String[] getValueNames() {\n        return session.getValueNames();\n    }\n    @Override\n    public void setAttribute(String name, Object value) {\n        session.setAttribute(name, value);\n    }\n    @Override\n    public void putValue(String name, Object value) {\n        session.putValue(name, value);\n    }\n    @Override\n    public void removeAttribute(String name) {\n        session.removeAttribute(name);\n    }\n    @Override\n    public void removeValue(String name) {\n        session.removeValue(name);\n    }\n    @Override\n    public void invalidate() {\n        session.invalidate();\n    }\n    @Override\n    public boolean isNew() {\n        return session.isNew();\n    }\n}\n</code></pre><p>通过上面的定义实现可以看出，Session类主要是作为javax.servlet.http.HttpSession接口的实现类，而SessionFacade类则封装了希望对外暴露的接口，隐藏我们内部的实现。</p><p>我们需要明确，创建Session的是Server，也就是Servlet容器，比如Tomcat或者MiniTomcat。而客户端Client对Servlet的处理流程里只是使用Session存储的数据。程序员通过 <code>HttpServletRequest#getSession()</code> 获取返回的HttpSession。</p><p>Servlet容器根据收到的HTTP请求创建Session，也可以在客户端程序调用getSession方法的时候创建。上述过程完毕之后，Response返回参数内会回写Sessionid，这是通过在响应头中设置set-cookie参数实现的。</p><p>整个Session创建获取的情况是这样的：</p><ol>\n<li>\n<p>对一个全新的客户端发送HTTP请求到Server：Server发现这是一个全新的请求，为它创建Session，分配Sessionid，并在Response的返回头中设置Set-Cookie。生成的Session可能存放了某些身份认证识别的内容。</p>\n</li>\n<li>\n<p>客户端再次请求，这次在请求头Cookie内带上回传的Sessionid：Server发现第二次请求带有Sessionid，根据id匹配到Session，并取出之前存放在Session里的内容。</p>\n</li>\n</ol><p>我们要明确一个事实，虽然我们一直将Cookie与Session放在一起来讲，甚至有可能将二者混为一谈，但Session不一定要依赖Cookie（某些时候存在设置不接受Cookie的情况），也可以通过URL中参数带的jsessionid来做到，比如 <code>/test/TestServlet;jsessionid=5AC6268DD8D4D5D1FDF5D41E9F2FD960?curAlbumID=9</code>。浏览器是在URL之后加上 <code>;jsessionid=</code> 这个固定搭配来传递Session，不是普通的参数格式。</p><p>接下来我们看看怎么处理。首先是接收请求时在HttpRequest类中解析Session。提取parseRequestLine公共方法，你可以看一下HttpRequest类完整定义，接口实现类我只列出有调整的。</p><pre><code class=\"language-java\">package server;\n\npublic class HttpRequest implements HttpServletRequest {\n    private InputStream input;\n    private SocketInputStream sis;\n    private String uri;\n    private String queryString;\n    InetAddress address;\n    int port;\n    private boolean parsed = false;\n    protected HashMap&lt;String, String&gt; headers = new HashMap&lt;&gt;();\n    protected Map&lt;String, String[]&gt; parameters = new ConcurrentHashMap&lt;&gt;();\n    HttpRequestLine requestLine = new HttpRequestLine();\n    Cookie[] cookies;\n    HttpSession session;\n    String sessionid;\n    SessionFacade sessionFacade;\n    public HttpRequest(InputStream input) {\n        this.input = input;\n        this.sis = new SocketInputStream(this.input, 2048);\n    }\n    //解析请求行和头header\n    public void parse(Socket socket) {\n        try {\n            parseConnection(socket);\n            this.sis.readRequestLine(requestLine);\n            parseRequestLine();\n            parseHeaders();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (ServletException e) {\n            e.printStackTrace();\n        }\n    }\n    //处理请求行\n    private void parseRequestLine() {\n        //以问号判断是否带有参数串\n        int question = requestLine.indexOf(\"?\");\n        if (question &gt;= 0) {\n            queryString = new String(requestLine.uri, question + 1, requestLine.uriEnd - question - 1);\n            uri = new String(requestLine.uri, 0, question);\n            //处理参数串中带有jsessionid的情况\n            int semicolon = uri.indexOf(DefaultHeaders.JSESSIONID_NAME);\n            if (semicolon &gt;= 0) {\n                sessionid = uri.substring(semicolon+DefaultHeaders.JSESSIONID_NAME.length());\n                uri = uri.substring(0, semicolon);\n            }\n        } else {\n            queryString = null;\n            uri = new String(requestLine.uri, 0, requestLine.uriEnd);\n            int semicolon = uri.indexOf(DefaultHeaders.JSESSIONID_NAME);\n            if (semicolon &gt;= 0) {\n                sessionid = uri.substring(semicolon+DefaultHeaders.JSESSIONID_NAME.length());\n                uri = uri.substring(0, semicolon);\n            }\n        }\n    }\n    private void parseConnection(Socket socket) {\n        address = socket.getInetAddress();\n        port = socket.getPort();\n    }\n    //解析所有header信息\n    private void parseHeaders() throws IOException, ServletException {\n        while (true) {\n            HttpHeader header = new HttpHeader();\n            sis.readHeader(header);\n            if (header.nameEnd == 0) {\n                if (header.valueEnd == 0) {\n                    return;\n                } else {\n                    throw new ServletException(\"httpProcessor.parseHeaders.colon\");\n                }\n            }\n            String name = new String(header.name,0,header.nameEnd);\n            String value = new String(header.value, 0, header.valueEnd);\n            // 设置相应的头信息\n            if (name.equals(DefaultHeaders.ACCEPT_LANGUAGE_NAME)) {\n                headers.put(name, value);\n            } else if (name.equals(DefaultHeaders.CONTENT_LENGTH_NAME)) {\n                headers.put(name, value);\n            } else if (name.equals(DefaultHeaders.CONTENT_TYPE_NAME)) {\n                headers.put(name, value);\n            } else if (name.equals(DefaultHeaders.HOST_NAME)) {\n                headers.put(name, value);\n            } else if (name.equals(DefaultHeaders.CONNECTION_NAME)) {\n                headers.put(name, value);\n            } else if (name.equals(DefaultHeaders.TRANSFER_ENCODING_NAME)) {\n                headers.put(name, value);\n            } else if (name.equals(DefaultHeaders.COOKIE_NAME)) {\n                headers.put(name, value);\n                //处理cookie和session\n                Cookie[] cookiearr = parseCookieHeader(value);\n                this.cookies = cookiearr;\n                for (int i = 0; i &lt; cookies.length; i++) {\n                    if (cookies[i].getName().equals(\"jsessionid\")) {\n                        this.sessionid = cookies[i].getValue();\n                    }\n                }\n            }\n            else {\n                headers.put(name, value);\n            }\n        }\n    }\n    //解析Cookie头，格式为: key1=value1;key2=value2\n    public  Cookie[] parseCookieHeader(String header) {\n        if ((header == null) || (header.length() &lt; 1) )\n            return (new Cookie[0]);\n        ArrayList&lt;Cookie&gt; cookieal = new ArrayList&lt;&gt;();\n        while (header.length() &gt; 0) {\n            int semicolon = header.indexOf(';');\n            if (semicolon &lt; 0)\n                semicolon = header.length();\n            if (semicolon == 0)\n                break;\n            String token = header.substring(0, semicolon);\n            if (semicolon &lt; header.length())\n                header = header.substring(semicolon + 1);\n            else\n                header = \"\";\n            try {\n                int equals = token.indexOf('=');\n                if (equals &gt; 0) {\n                    String name = token.substring(0, equals).trim();\n                    String value = token.substring(equals+1).trim();\n                    cookieal.add(new Cookie(name, value));\n                }\n            } catch (Throwable e) {\n            }\n        }\n        return ((Cookie[]) cookieal.toArray (new Cookie [cookieal.size()]));\n    }\n    \n    @Override\n    public Cookie[] getCookies() {\n        return this.cookies;\n    }\n    \n    @Override\n    public HttpSession getSession() {\n        return this.sessionFacade;\n    }\n    //如果有存在的session，直接返回，如果没有，创建一个新的session\n    public HttpSession getSession(boolean create) {\n        if (sessionFacade != null)\n            return sessionFacade;\n        if (sessionid != null) {\n            session = HttpConnector.sessions.get(sessionid);\n            if (session != null) {\n                sessionFacade = new SessionFacade(session);\n                return sessionFacade;\n            } else {\n                session = HttpConnector.createSession();\n                sessionFacade = new SessionFacade(session);\n                return sessionFacade;\n            }\n        } else {\n            session = HttpConnector.createSession();\n            sessionFacade = new SessionFacade(session);\n            sessionid = session.getId();\n            return sessionFacade;\n        }\n    }\n    public String getSessionId() {\n        return this.sessionid;\n    }\n}\n</code></pre><p>上述代码中，我们着重关注parseRequestLine与parseCookieHeader方法的实现，主要是解析URL里包含jsessionid的部分，以及从Cookie中获取jsessionid。</p><p>但这个时候我们只是获取到了id，并没有获取Session，按照程序执行的顺序，如果在URL的查询字符串与Cookie中都存在jsessonid，那么我们会优先获取Cookie里对应的这个值。</p><p>由于我们一个Server需要对应多个Client，所以在Server内我们考虑采用Map结构存储Session，其中Key为Sessionid，Value为Session认证信息。因为HttpConnector类是全局的，所以现在我们先把这个Map存放在HttpConnector类里。同时将createSession方法以及generateSesionId方法也都放在HttpConnector中。你可以看一下相关代码。</p><pre><code class=\"language-java\">package server;\npublic class HttpConnector implements Runnable {\n    int minProcessors = 3;\n    int maxProcessors = 10;\n    int curProcessors = 0;\n    Deque&lt;HttpProcessor&gt; processors = new ArrayDeque&lt;&gt;();\n    //sessions map存放session\n    public static Map&lt;String, HttpSession&gt; sessions = new ConcurrentHashMap&lt;&gt;();\n    //创建新的session\n    public static Session createSession() {\n        Session session = new Session();\n        session.setValid(true);\n        session.setCreationTime(System.currentTimeMillis());\n        String sessionId = generateSessionId();\n        session.setId(sessionId);\n        sessions.put(sessionId, session);\n        return (session);\n    }\n    //以随机方式生成byte数组,形成sessionid\n    protected static synchronized String generateSessionId() {\n        Random random = new Random();\n        long seed = System.currentTimeMillis();\n        random.setSeed(seed);\n        byte bytes[] = new byte[16];\n        random.nextBytes(bytes);\n        StringBuffer result = new StringBuffer();\n        for (int i = 0; i &lt; bytes.length; i++) {\n            byte b1 = (byte) ((bytes[i] &amp; 0xf0) &gt;&gt; 4);\n            byte b2 = (byte) (bytes[i] &amp; 0x0f);\n            if (b1 &lt; 10)\n                result.append((char) ('0' + b1));\n            else\n                result.append((char) ('A' + (b1 - 10)));\n            if (b2 &lt; 10)\n                result.append((char) ('0' + b2));\n            else\n                result.append((char) ('A' + (b2 - 10)));\n        }\n        return (result.toString());\n    }\n}\n</code></pre><p>将Session的生成和管理全部放在Connector内还是有点儿臃肿，后面我们会进一步分解功能，通过Container和Manager来管理Session，现在暂且不深入讨论。</p><p>因为HttpConnector会在接受Socket之后，为Processor分配Socket，所以我们先在HttpProcessor类中进行Session处理。</p><p>添加代码：</p><pre><code class=\"language-java\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // create Request object and parse\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HttpRequest request = new HttpRequest(input);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; request.parse(socket);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //handle session\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (request.getSessionId()==null || request.getSessionId().equals(\"\")) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;   request.getSession(true);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n\n            // create Response object\n            HttpResponse response = new HttpResponse(output);\n            response.setRequest(request);\n</code></pre><p>代码里注释为“handle session”的代码就是我们添加的，判断是否存在Sessionid，不存在则调用getSession方法，这个方法内会判断有没有Session，如果没有就创建。目前还存在一个问题，当Request请求每次都是新创建的，那么Session一定是空的，所以在getSession方法内我们会进一步判断在URL中是否存在jsessionid，如果解析后的结果中有jsessionid，我们会用这个jsessionid从HttpConnector类的全局Map里查找相应的Session。</p><h2>测试</h2><p>这节课我们在src/test/java/test目录下引入新的TestServlet进行测试。</p><pre><code class=\"language-java\">package test;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\nimport java.io.IOException;\npublic class TestServlet extends HttpServlet{\n    private static final long serialVersionUID = 1L;\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException {\n        System.out.println(\"Enter doGet()\");\n        System.out.println(\"parameter name : \"+request.getParameter(\"name\"));\n        HttpSession session = request.getSession(true);\n        String user = (String) session.getAttribute(\"user\");\n        System.out.println(\"get user from session : \" + user);\n        if (user == null || user.equals(\"\")) {\n            session.setAttribute(\"user\", \"yale\");\n        }\n        response.setCharacterEncoding(\"UTF-8\");\n        String doc = \"&lt;!DOCTYPE html&gt; \\n\" +\n                \"&lt;html&gt;\\n\" +\n                \"&lt;head&gt;&lt;meta charset=\\\"utf-8\\\"&gt;&lt;title&gt;Test&lt;/title&gt;&lt;/head&gt;\\n\"+\n                \"&lt;body bgcolor=\\\"#f0f0f0\\\"&gt;\\n\" +\n                \"&lt;h1 align=\\\"center\\\"&gt;\" + \"Test 你好\" + \"&lt;/h1&gt;\\n\";\n        System.out.println(doc);\n        response.getWriter().println(doc);\n    }\n    public void doPost(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException {\n        System.out.println(\"Enter doGet()\");\n        System.out.println(\"parameter name : \"+request.getParameter(\"name\"));\n        response.setCharacterEncoding(\"UTF-8\");\n        String doc = \"&lt;!DOCTYPE html&gt; \\n\" +\n                \"&lt;html&gt;\\n\" +\n                \"&lt;head&gt;&lt;meta charset=\\\"utf-8\\\"&gt;&lt;title&gt;Test&lt;/title&gt;&lt;/head&gt;\\n\"+\n                \"&lt;body bgcolor=\\\"#f0f0f0\\\"&gt;\\n\" +\n                \"&lt;h1 align=\\\"center\\\"&gt;\" + \"Test 你好\" + \"&lt;/h1&gt;\\n\";\n        System.out.println(doc);\n        response.getWriter().println(doc);\n    }\n}\n</code></pre><p>启动程序，调用发送请求的时候，程序会依据GET或者POST请求，分别调用doGet和doPost方法。Servlet程序中直接使用下面这段代码获取Session。</p><pre><code class=\"language-java\">public void doGet(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException {\n    HttpSession session = request.getSession(true);\n}\n</code></pre><p>如果用户知道内部的实现，可以将这个Session强行转换，这样会暴露出很多内部使用的方法，因此在这里我们也会用SessionFacade包装一下，request参数内传入的就是SessionFacade的对象。</p><h2>小结</h2><p>这节课我们做到了对URI的参数解析，适配常规GET请求，另外一件事则是引入Cookie和Session的解析与处理，支持存储数据，避免多次反复登录。但目前还有个遗留问题，为了多次往返的时候带上jsessionid，我们需要在Response返回参数中回写，让客户端程序也能获取到，应该怎么处理呢？如果你有兴趣的话，可以继续往后看，我们后续会继续改造。</p><p>本节课完整代码参见：<a href=\"https://gitee.com/yaleguo1/minit-learning-demo/tree/geek_chapter08\">https://gitee.com/yaleguo1/minit-learning-demo/tree/geek_chapter08</a></p><h2>思考题</h2><p>学完了这节课的内容，我们做一个练习：自己手工写一个完整的请求串，要求包含cookie和session，并且某一个头的值是多行的。</p><p>欢迎你把你写的请求串分享到评论区，也欢迎你把这节课的内容分享给其他朋友，我们下节课再见！</p>","comments":[{"had_liked":false,"id":385927,"user_name":"ctt","can_delete":false,"product_type":"c1","uid":1126661,"ip_address":"广东","ucode":"FA87B9E86FD308","user_header":"https://static001.geekbang.org/account/avatar/00/11/31/05/9028e9ac.jpg","comment_is_top":false,"comment_ctime":1703671884,"is_pvip":false,"replies":[{"id":140709,"content":"你这个很好！特别是一个key有多行值。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1704027273,"ip_address":"湖南","comment_id":385927,"utype":1}],"discussion_count":1,"race_medal":1,"score":2,"product_id":100636401,"comment_content":"GET &#47;path&#47;to&#47;resource HTTP&#47;1.1\nHost: www.example.com\nUser-Agent: Mozilla&#47;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#47;537.36\n             (KHTML, like Gecko) Chrome&#47;58.0.3029.110 Safari&#47;537.36\nAccept: text&#47;html,application&#47;xhtml+xml,application&#47;xml;q=0.9,image&#47;webp,*&#47;*;q=0.8\nAccept-Language: en-US,en;q=0.5\nAccept-Encoding: gzip, deflate, br\nCookie: sessionid=abc123; username=ctt\nConnection: keep-alive\n","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634826,"discussion_content":"你这个很好！特别是一个key有多行值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704027273,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖南","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385855,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1703515481,"is_pvip":false,"replies":[{"id":140646,"content":"感谢Peter指正问题。\nQ1：Cookie和session不是成对的，两者没有必然关联，只是我们用Cookie记录sessionid，也可以在uri中带上jsessionid。\nQ2：set-cookie可以重复，后面的会覆盖前面的。\nQ3：这个import是有问题，感谢感谢。我原本的代码中没有这个，但是助手从我的Github上搬到Gitee的时候，他先在本地环境中保存了一下代码，被他的IDE自带的coretto jdk自动加上了。我们很快改正，感谢感谢。你自己删除这一行就行。","user_name":"作者回复","user_name_real":"作者","uid":1864890,"ctime":1703667814,"ip_address":"湖南","comment_id":385855,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"请教老师几个问题：\nQ1：Cookie和Session是成对出现的吗？\n有Cookie就一定有Session，对吗？反过来，有Session也一定有Cookie，对吗？\nQ2：Session的Set-Cookie字段可以出现多次吗？\n我让chatGPT3.5给出一个包含Cookie的Http响应，给出的例子是：\nHTTP&#47;1.1 200 OK\nDate: Tue, 15 Nov 2022 08:12:31 GMT\nServer: Apache&#47;2.4.38 (Unix)\nSet-Cookie: sessionid=abc123; Expires=Wed, 16 Nov 2022 08:12:31 GMT; Path=&#47;\nSet-Cookie: username=johndoe; Expires=Wed, 16 Nov 2022 08:12:31 GMT; Path=&#47;\nContent-Type: text&#47;html; charset=utf-8\nContent-Length: 1234\n\n其中，Set-Cookie出现了两次。\n我问gpt为什么出现两次，gpt回答“常抱歉，我犯了一个错误。在HTTP响应中，Set-Cookie首部字段只能出现一次”，但给出的修正后的例子还是包含两个。\n请问：Http Response的Set-Cookie字段可以出现多次吗？\n\n\nQ3:本课代码，messaging包不存在\nHttpRequest.java文件中有如下导包语句：\nimport com.sun.xml.internal.messaging.saaj.packaging.mime.internet.InternetHeaders;\n编译报错：\nError:(3, 67) java: 程序包com.sun.xml.internal.messaging.saaj.packaging.mime.internet不存在\n前面几课的代码，Idea中修改java版本后都能正常运行，第8课的代码却有这个编译错误，为什么？","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634569,"discussion_content":"感谢Peter指正问题。\nQ1：Cookie和session不是成对的，两者没有必然关联，只是我们用Cookie记录sessionid，也可以在uri中带上jsessionid。\nQ2：set-cookie可以重复，后面的会覆盖前面的。\nQ3：这个import是有问题，感谢感谢。我原本的代码中没有这个，但是助手从我的Github上搬到Gitee的时候，他先在本地环境中保存了一下代码，被他的IDE自带的coretto jdk自动加上了。我们很快改正，感谢感谢。你自己删除这一行就行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1703667814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖南","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385841,"user_name":"HH🐷🐠","can_delete":false,"product_type":"c1","uid":1133678,"ip_address":"广东","ucode":"C50172BDA604D5","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/6e/5435e214.jpg","comment_is_top":false,"comment_ctime":1703492920,"is_pvip":false,"replies":[{"id":140648,"content":"正确的。不过你的头中没有一个头的值包含多行的情况，http协议是允许多行的。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1703668470,"ip_address":"湖南","comment_id":385841,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"1、手工写一个请求串\nPOST &#47;servlet&#47;test.TestServlet HTTP&#47;1.1\nHost: localhost:8080\nContent-Type: application&#47;x-www-form-urlencoded\nCookie: jsessionid=43C65BC81B4B4DE4623CD48A13E7FF84; userId=123\nContent-Length: 9\n\nname=haha\n\n2、回传 jsessionid 到客户端其实文中也有提到了， 通过 cookie  或 URL 重写进行进行回传。","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634571,"discussion_content":"正确的。不过你的头中没有一个头的值包含多行的情况，http协议是允许多行的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1703668470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖南","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":1,"child_discussions":[{"author":{"id":1133678,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4c/6e/5435e214.jpg","nickname":"HH🐷🐠","note":"","ucode":"C50172BDA604D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":634575,"discussion_content":"好的， 我继续研究一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1703669882,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":634571,"ip_address":"广东","group_id":0},"score":634575,"extra":""}]}]},{"had_liked":false,"id":390898,"user_name":"偶来人间，风度翩翩","can_delete":false,"product_type":"c1","uid":1768374,"ip_address":"江苏","ucode":"DDABD0E3EB7104","user_header":"https://static001.geekbang.org/account/avatar/00/1a/fb/b6/728e2d02.jpg","comment_is_top":false,"comment_ctime":1716646811,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"代码示例中，对于SocketInputStream类，\n第53行代码【requestLine.uriEnd =  readCount - 1; 】是不正确的，\n应该是【requestLine.methodEnd = readCount - 1;】。   ","like_count":0}]}