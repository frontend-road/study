{"id":471688,"title":"06 | 牛刀小试：如何搭建优惠券计算服务和用户服务？","content":"<p>你好，我是姚秋辰。</p><p>上一节课我们搭建了coupon-template-serv模块，实现了优惠券模板的创建和批量查询等功能，相信你已经对如何使用Spring Boot搭建应用驾轻就熟了。今天我们就来搭建优惠券平台项目的另外两个模块，coupon-calculation-serv（优惠计算服务）和coupon-customer-serv（用户服务），组建一个完整的实战项目应用（middleware模块将在Spring Cloud环节进行搭建）。</p><p>通过今天的课程，你可以巩固并加深Spring Boot的实操能力，为接下来Spring Cloud微服务化改造打好前置知识的基础，在这节课里我也会分享一些关于设计模式和数据冗余的经验之谈。</p><p>另外，这节课的源码都可以在<a href=\"https://gitee.com/banxian-yao/geekbang-coupon-center\">Gitee代码库</a>中找到。你可不要只读爽文不动手敲代码，我建议你把代码下载到本地，对照着源码动手练习一遍，才能学为己用。</p><p>闲话少叙，我们根据优惠券项目的依赖关系，先从上游服务coupon-calculation-serv开始动手搭建吧。</p><h2>搭建coupon-calculation-serv</h2><p>coupon-calculation-serv提供了用于计算订单的优惠信息的接口，它是一个典型的“计算密集型”服务。所谓计算密集型服务一般具备下面的两个特征：</p><!-- [[[read_end]]] --><ol>\n<li><strong>不吃网络IO和磁盘空间</strong>；</li>\n<li><strong>运行期主要占用CPU、内存等计算资源</strong>。</li>\n</ol><p>在做大型应用架构的时候，我们通常会把计算密集型服务与IO/存储密集型服务分割开来，这样做的一个主要原因是提高资源利用率。</p><p>比如说，我们有一个计算密集型的微服务A和一个IO密集型微服务B，大促峰值流量到来的时候，如果微服务A面临的压力比较大，我可以专门调配高性能CPU和内存等“计算类”的资源去定向扩容A集群；如果微服务B压力吃紧了，我可以定向调拨云上的存储资源分配给B集群，这样就实现了一种“按需分配”。</p><p>假如微服务A和微服务B合二为一变成了一个服务，那么在分配资源的时候就无法做到定向调拨，全链路压测环节也难以精准定位各项性能指标，这难免出现资源浪费的情况。这也是为什么，我要把优惠计算这个服务单独拿出来的原因。</p><p>现在，我们开始着手搭建coupon-calculation-serv下的子模块。和coupon-template-serv结构类似，coupon-calculation-serv下面也分了若干个子模块，包括API层和业务逻辑层。API层定义了公共的POJO类，业务逻辑层主要实现优惠价格计算业务。因为calculation服务并不需要访问数据库，所以没有DAO模块。</p><p>根据子模块间的依赖关系，我们就先从coupon-calculation-api这个接口层子模块开始搭建吧。</p><h3>搭建coupon-calculation-api</h3><p>如果coupon-calculation-serv需要计算订单的优惠价格，那就得知道当前订单用了什么优惠券。封装了优惠券信息的Java类CouponInfo位于coupon-template-api包下，因此我们需要把coupon-template-api的依赖项加入到coupon-calculation-api中。</p><pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;${project.groupId}&lt;/groupId&gt;\n    &lt;artifactId&gt;coupon-template-api&lt;/artifactId&gt;\n    &lt;version&gt;${project.version}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre><p>添加好了依赖项之后，接下来我们定义用于封装订单信息的ShoppingCart类。</p><pre><code>@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class ShoppingCart {\n    // 订单的商品列表 - \n    @NotEmpty\n    private List&lt;Product&gt; products;\n     \n    // 封装了优惠券信息，目前计算服务只支持单张优惠券\n    // 为了考虑到以后多券的扩展性，所以定义成了List\n    private Long couponId;   \n    private List&lt;CouponInfo&gt; couponInfos;\n\n    // 订单的最终价格\n    private long cost;\n    // 用户ID\n    @NotNull\n    private Long userId;\n}\n</code></pre><p>在上面的源码中，我们看到ShoppingCart订单类中使用了Product对象，来封装当前订单的商品列表。在Product类中包含了商品的单价、商品数量，以及当前商品的门店ID。</p><pre><code>@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Product {\n    // 商品的价格\n    private long price;\n    // 商品在购物车里的数量\n    private Integer count;\n    // 商品销售的门店\n    private Long shopId;\n}\n</code></pre><p>在电商领域中，商品的数量通常不能以Integer整数来表示，这是因为只有标品才能以整数计件。对于像蔬菜、肉类等非标品来说，它们的计件单位并不是“个”。所以在实际项目中，尤其是零售行业的业务系统里，计件单位要允许小数位的存在。而我们的实战项目为了简化业务，就假定所有商品都是“标品”了。</p><p>在下单的时候，你可能有多张优惠券可供选择，你需要通过“<strong>价格试算</strong>”来模拟计算每张优惠券可以扣减的金额，进而选择最优惠的券来使用。SimulationOrder和SimulationResponse分别代表了“价格试算”的订单类，以及返回的计算结果Response。我们来看一下这两个类的源码。</p><pre><code>// 优惠券价格试算\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class SimulationOrder {\n\n    @NotEmpty\n    private List&lt;Product&gt; products;\n\n    @NotEmpty\n    private List&lt;Long&gt; couponIDs;\n\n    private List&lt;CouponInfo&gt; couponInfos;\n\n    @NotNull\n    private Long userId;\n}\n\n// 订单试算结果，可以看出哪个优惠券的优惠力度最大\n@Data\n@NoArgsConstructor\npublic class SimulationResponse {\n    // 最省钱的coupon\n    private Long bestCouponId;\n    // 每一个coupon对应的order价格\n    private Map&lt;Long, Long&gt; couponToOrderPrice = Maps.newHashMap();\n}\n</code></pre><p>到这里，coupon-calculation-api模块就搭建好了。因为calculation服务不需要访问数据库，所以我们就不用搭建dao模块了，直接来实现coupon-calculation-impl业务层的代码逻辑。</p><h3>搭建coupon-calculation-impl</h3><p>首先，我们在coupon-calculation-impl的pom.xml文件中添加下面的三个依赖项。</p><pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;${project.groupId}&lt;/groupId&gt;\n    &lt;artifactId&gt;coupon-template-api&lt;/artifactId&gt;\n    &lt;version&gt;${project.version}&lt;/version&gt;\n&lt;/dependency&gt;\n\n&lt;dependency&gt;\n    &lt;groupId&gt;${project.groupId}&lt;/groupId&gt;\n    &lt;artifactId&gt;coupon-calculation-api&lt;/artifactId&gt;\n    &lt;version&gt;${project.version}&lt;/version&gt;\n&lt;/dependency&gt;\n\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre><p>从coupon-template-api和coupon-calculation-api两个依赖项中，你可以拿到订单优惠计算过程用到的POJO对象。接下来，我们可以动手实现优惠计算逻辑了。</p><p>在搭建优惠计算业务逻辑的过程中，我运用了模板设计模式来封装计算逻辑。模板模式是一种基于抽象类的设计模式，它的思想很简单，就是<strong>将共性的算法骨架部分上升到抽象层，将个性部分延迟到子类中去实现</strong>。</p><p>优惠券类型有很多种，比如满减券、打折券、随机立减等等，这些券的计算流程（共性部分）是相同的，但具体的计算规则（个性部分）是不同的。我将共性的部分抽象成了AbstractRuleTemplate抽象类，将各个券的差异性计算方式做成了抽象类的子类。</p><p>让我们看一下计算逻辑的类结构图。</p><p><img src=\"https://static001.geekbang.org/resource/image/8b/a7/8b3bef22448b63a5db17f4a62902aaa7.jpg?wh=2000x1323\" alt=\"\"></p><p>在这张图里，顶层接口RuleTemplate定义了calculate方法，抽象模板类AbstractRuleTemplate将通用的模板计算逻辑在calculate方法中实现，同时它还定义了一个抽象方法calculateNewPrice作为子类的扩展点。各个具体的优惠计算类通过继承AbstractRuleTemplate，并实现calculateNewPrice来编写自己的优惠计算方式。</p><p>我们先来看一下AbstractRuleTemplate抽象类的代码，走读calculate模板方法中的计算逻辑实现。</p><pre><code>public ShoppingCart calculate(ShoppingCart order) {\n    // 获取订单总价\n    Long orderTotalAmount = getTotalPrice(order.getProducts());\n    // 获取以shopId为维度的总价统计\n    Map&lt;Long, Long&gt; sumAmount = getTotalPriceGroupByShop(order.getProducts());\n    CouponTemplateInfo template = order.getCouponInfos().get(0).getTemplate();\n    // 最低消费限制\n    Long threshold = template.getRule().getDiscount().getThreshold();\n    // 优惠金额或者打折比例\n    Long quota = template.getRule().getDiscount().getQuota();\n    // 如果优惠券未指定shopId，则shopTotalAmount=orderTotalAmount\n    // 如果指定了shopId，则shopTotalAmount=对应门店下商品总价\n    Long shopId = template.getShopId();\n    Long shopTotalAmount = (shopId == null) ? orderTotalAmount : sumAmount.get(shopId);\n    \n    // 如果不符合优惠券使用标准, 则直接按原价走，不使用优惠券\n    if (shopTotalAmount == null || shopTotalAmount &lt; threshold) {\n        log.debug(&quot;Totals of amount not meet&quot;);\n        order.setCost(orderTotalAmount);\n        order.setCouponInfos(Collections.emptyList());\n        return order;\n    }\n    // 子类中实现calculateNewPrice计算新的价格\n    Long newCost = calculateNewPrice(orderTotalAmount, shopTotalAmount, quota);\n    if (newCost &lt; minCost()) {\n        newCost = minCost();\n    }\n    order.setCost(newCost);\n    log.debug(&quot;original price={}, new price={}&quot;, orderTotalAmount, newCost);\n    return order;\n}\n</code></pre><p>在上面的源码中，我们看到大部分计算逻辑都在抽象类中做了实现，子类只要实现calculateNewPrice方法完成属于自己的订单价格计算就好。我们以满减规则类为例来看一下它的实现。</p><pre><code>@Slf4j\n@Component\npublic class MoneyOffTemplate extends AbstractRuleTemplate implements RuleTemplate {\n    @Override\n    protected Long calculateNewPrice(Long totalAmount, Long shopAmount, Long quota) {\n        // benefitAmount是扣减的价格\n        // 如果当前门店的商品总价&lt;quota，那么最多只能扣减shopAmount的钱数\n        Long benefitAmount = shopAmount &lt; quota ? shopAmount : quota;\n        return totalAmount - benefitAmount;\n    }    \n}\n</code></pre><p>在上面的源码中，我们看到子类业务的逻辑非常简单清爽。通过模板设计模式，我在抽象类中封装了共性逻辑，在子类中扩展了可变逻辑，每个子类只用关注自己的特定实现即可，使得代码逻辑变得更加清晰，大大降低了代码冗余。</p><p>随着业务发展，你的优惠券模板类型可能会进一步增加，比如赠品券、随机立减券等等，如果当前的抽象类无法满足新的需求，你可以通过建立多级抽象类的方式进一步增加抽象层次，不断将共性不变的部分抽取为抽象层。</p><p>创建完优惠计算逻辑，我们接下来看一下Service层的代码实现逻辑。Service层的calculateOrderPrice代码非常简单，通过CouponTemplateFactory工厂类获取到具体的计算规则，然后调用calculate计算订单价格就好了。simulate方法实现了订单价格试算，帮助用户在下单之前了解每个优惠券可以扣减的金额，从而选出最省钱的那个券。</p><pre><code>@Slf4j\n@Service\npublic class CouponCalculationServiceImpl implements CouponCalculationService {\n    \n    // 优惠券结算\n    // 这里通过Factory类决定使用哪个底层Rule，底层规则对上层透明\n    @Override\n    public ShoppingCart calculateOrderPrice(@RequestBody ShoppingCart cart) {\n        log.info(&quot;calculate order price: {}&quot;, JSON.toJSONString(cart));\n        RuleTemplate ruleTemplate = couponTemplateFactory.getTemplate(cart);\n        return ruleTemplate.calculate(cart);\n    }\n    \n    // 试计算每个优惠券在使用后订单的价格\n    // 页面上给用户提示最省钱的优惠券\n    @Override\n    public SimulationResponse simulate(@RequestBody SimulationOrder order) {\n        SimulationResponse response = new SimulationResponse();\n        Long minOrderPrice = Long.MIN_VALUE;\n        // 计算每一个优惠券的订单价格\n        for (CouponInfo coupon : order.getCouponInfos()) {\n            ShoppingCart cart = new ShoppingCart();\n            cart.setProducts(order.getProducts());\n            cart.setCouponInfos(Lists.newArrayList(coupon));\n            cart = couponProcessorFactory.getTemplate(cart).calculate(cart);\n            Long couponId = coupon.getId();\n            Long orderPrice = cart.getCost();\n            // 设置当前优惠券对应的订单价格\n            response.getCouponToOrderPrice().put(couponId, orderPrice);\n            // 比较订单价格，设置当前最优优惠券的ID\n            if (minOrderPrice &gt; orderPrice) {\n                response.setBestCouponId(coupon.getId());\n                minOrderPrice = orderPrice;\n            }\n        }\n        return response;\n    }\n    // 其它方法未列出，请至源码仓库查看完整代码 \n}\n</code></pre><p>在上面的源码中，我们看到，优惠券结算方法不用关心订单上使用的优惠券是满减券还是打折券，因为工厂方法会将子类转为顶层接口RuleTemplate返回。在写代码的过程中，我们也要有这样一种意识，就是<strong>尽可能对上层业务屏蔽其底层业务复杂度</strong>，底层具体业务逻辑的修改对上层是无感知的，这其实也是<strong>开闭原则</strong>的思想。</p><p>完成Service层后，我们接下来新建一个CouponCalculationController类，对外暴露2个POST接口，第一个接口完成订单优惠价格计算，第二个接口完成优惠券价格试算。</p><pre><code>@Slf4j\n@RestController\n@RequestMapping(&quot;calculator&quot;)\npublic class CouponCalculationController {\n    @Autowired\n    private CouponCalculationService couponCalculationService;\n    \n    // 优惠券结算\n    @PostMapping(&quot;/checkout&quot;)\n    @ResponseBody\n    public ShoppingCart calculateOrderPrice(@RequestBody ShoppingCart settlement) {\n        log.info(&quot;do calculation: {}&quot;, JSON.toJSONString(settlement));\n        return couponCalculationService.calculateOrderPrice(settlement);\n    }\n    \n    // 优惠券列表挨个试算\n    // 给客户提示每个可用券的优惠额度，帮助挑选\n    @PostMapping(&quot;/simulate&quot;)\n    @ResponseBody\n    public SimulationResponse simulate(@RequestBody SimulationOrder order) {\n        log.info(&quot;do simulation: {}&quot;, JSON.toJSONString(order));\n        return couponCalculationService.simulateOrder(order);\n    }\n    \n    // 其它方法未列出，请至源码仓库查看完整代码 \n}\n</code></pre><p>好了，现在你已经完成了所有业务逻辑的源码。最后一步画龙点睛，你还需要为coupon-calculation-impl应用创建一个Application启动类并添加application.yml配置项。因为它并不需要访问数据库，所以你不需要在配置文件或者启动类注解上添加spring-data的相关内容。</p><p>到这里，我们就完成了优惠计算服务的搭建工作，你可以到我的<a href=\"https://gitee.com/banxian-yao/geekbang-coupon-center/tree/master/0-Spring%20Boot%E6%80%A5%E9%80%9F%E8%90%BD%E5%9C%B0%E9%83%A8%E5%88%86/coupon-calculation-serv\">代码仓库</a>中查看完整的coupon-calculation-serv源码实现。</p><p>下面，我们去搭建优惠券项目的最后一个服务：coupon-customer-serv。</p><h2>搭建coupon-customer-serv</h2><p>coupon-customer-serv是一个服务于用户的子模块，它的结构和coupon-template-serv一样，包含了API层、DAO层和业务逻辑层。它实现了用户领券、用户优惠券查找和订单结算功能。</p><p>为了简化业务逻辑，我在源码里省略了“用户注册”等业务功能，使用userId来表示一个已注册的用户。</p><p>按照惯例，我们先从API层开始搭建，搭建coupon-customer-api的过程非常简单。</p><h3>搭建coupon-customer-api</h3><p>首先，我们需要把coupon-template-api和coupon-calculation-api这两个服务的依赖项添加到coupon-customer-api的pom依赖中，这样一来customer服务就可以引用到这两个服务的Request和Response对象了。</p><p>接下来，我们在API子模块中创建一个RequestCoupon类，作为用户领取优惠券的请求参数，通过传入用户ID和优惠券模板ID，用户可以领取一张由指定模板打造的优惠券。另一个类是SearchCoupon，用来封装优惠券查询的请求参数。</p><pre><code>@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class RequestCoupon {\n    // 用户领券\n    @NotNull\n    private Long userId;\n\n    // 券模板ID\n    @NotNull\n    private Long couponTemplateId;\n\n}\n\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class SearchCoupon {\n    @NotNull\n    private Long userId;\n    private Long shopId;\n    private Integer couponStatus;\n}\n</code></pre><p>到这里，coupon-customer-api就搭建完了。接下里我们去搭建coupon-customer-dao层，从数据层实现用户优惠券的增删改查。</p><h3>搭建coupon-customer-dao</h3><p>我在DAO子模块中创建了一个Coupon数据库实体对象用于保存用户领到的优惠券，并按照spring-data-jpa规范创建了一个CouponDAO接口用来提供CRUD操作。</p><p>我们先来看一下Coupon实体对象的内容。</p><pre><code>// 使用了lomkob注解自动生成建造者代码和getter、setter\n@Builder\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\n@Entity\n@EntityListeners(AuditingEntityListener.class)\n@Table(name = &quot;coupon&quot;)\npublic class Coupon {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = &quot;id&quot;, nullable = false)\n    private Long id;\n\n    // 对应的模板ID - 不使用one to one映射\n    @Column(name = &quot;template_id&quot;, nullable = false)\n    private Long templateId;\n\n    // 拥有这张优惠券的用户的ID\n    @Column(name = &quot;user_id&quot;, nullable = false)\n    private Long userId;\n\n    // 冗余一个shop id方便查找\n    @Column(name = &quot;shop_id&quot;)\n    private Long shopId;\n\n    // 自动生成时间戳\n    @CreatedDate\n    @Column(name = &quot;created_time&quot;, nullable = false)\n    private Date createdTime;\n\n    // CouponStatusConverter实现了AttributeConverter接口\n    // 将数据库value转化为CouponStatus类\n    @Column(name = &quot;status&quot;, nullable = false)\n    @Convert(converter = CouponStatusConverter.class)\n    private CouponStatus status;\n\n    @Transient\n    private CouponTemplateInfo templateInfo;\n}\n</code></pre><p>在上面的源码中，我在class级别使用了Lombok注解自动生成代码，如果你对Lomkob比较感兴趣，可以从<a href=\"https://projectlombok.org\">Lomkob官网</a>上获取更多的使用方法。</p><p>从这段代码引申一下，我想和你分享一个关于“<strong>数据冗余</strong>”的小知识点。我们看到Coupon实体对象中冗余保存了一个Shop ID，之所以说它是冗余字段，是因为Shop ID可以从CouponTemplate表中获取，顺着Coupon对象的templateID字段可以关联到CouponTemplate表，进而获取到ShopID对象。</p><p>那我们为什么需要在Coupon表中再保存一次shop ID呢？如果严格遵循数据库的范式，那确实不应该保存一个冗余的shop ID字段，但我们也不要忘了，所谓范式和规则就是留给后人打破的。</p><p>数据库的标准范式是上一个时代的产物，以那个时代的眼光来看，“存储”是一项很宝贵的资源，在做程序设计的时候应该尽可能节省磁盘空间、内存空间，反倒“性能”和“高并发”并不是需要担心的事情。</p><p>当我们用现在的眼光来审视程序设计，你会发现“存储资源”已经不再是制约生产力的瓶颈，<strong>为了应对高并发的场景，你必须尽可能提高系统的吞吐量和性能</strong>。</p><p>因此，你经常可以看到一二线大厂的高并发系统大量使用了“数据冗余”和“数据异构”方案。这是一个“<strong>以空间换时间</strong>”的路子，通过将一份数据冗余或异构到多处，提升业务的查询和处理效率。</p><p>了解了数据冗余的扩展知识后，我们来看下DAO层的接口类的内容：</p><pre><code>public interface CouponDao extends JpaRepository&lt;Coupon, Long&gt; {\n    // 根据用户ID和Template ID，统计用户从当前优惠券模板中领了多少张券\n    long countByUserIdAndTemplateId(Long userId, Long templateId);\n}\n</code></pre><p>在上面的源码中，我们只创建了一个接口用于count计算，至于其他增删改查功能则统一由父类JpaRepository一手包办了。spring-data-jpa沿袭了spring框架的简约风，大道至简解放双手，整个Spring框架从诞生至今，也一直都在朝着不断简化的方向发展。</p><p>到这里，coupon-customer-dao层的代码就写完了，接下来我们去搞定最后一个子模块coupon-customer-impl业务逻辑层。</p><h3>搭建coupon-customer-impl</h3><p>既然coupon-customer-impl需要调用template和calculation两个服务，在没有进入微服务化改造之前，我们只能先暂时委屈一下template和calculation，将它俩作为customer服务的一部分，做成一个三合一的单体应用。等你学到微服务课程的时候，这个单体应用会被拆分成独立的微服务模块。</p><p>首先，你需要将template、calculation的依赖项添加到coupon-customer-impl的配置文件中，注意这里我们添加的可不是API接口层的依赖，而是Impl接口实现层的依赖。</p><pre><code>    &lt;dependency&gt;\n        &lt;groupId&gt;${project.groupId}&lt;/groupId&gt;\n        &lt;artifactId&gt;coupon-customer-dao&lt;/artifactId&gt;\n        &lt;version&gt;${project.version}&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;${project.groupId}&lt;/groupId&gt;\n        &lt;artifactId&gt;coupon-calculation-impl&lt;/artifactId&gt;\n        &lt;version&gt;${project.version}&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;${project.groupId}&lt;/groupId&gt;\n        &lt;artifactId&gt;coupon-template-impl&lt;/artifactId&gt;\n        &lt;version&gt;${project.version}&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n</code></pre><p>添加完依赖项之后，我们就可以去动手实现业务逻辑层了。</p><p>CouponCustomerService是业务逻辑层的接口抽象，我添加了几个方法，用来实现用户领券、查询优惠券、下单核销优惠券、优惠券试算等功能。</p><pre><code>// 用户对接服务\npublic interface CouponCustomerService {\n    // 领券接口\n    Coupon requestCoupon(RequestCoupon request);\n    // 核销优惠券\n    ShoppingCart placeOrder( info);\n    // 优惠券金额试算\n    SimulationResponse simulateOrderPrice(SimulationOrder order);\n    // 用户删除优惠券\n    void deleteCoupon(Long userId, Long couponId);\n    // 查询用户优惠券\n    List&lt;CouponInfo&gt; findCoupon(SearchCoupon request);\n    // xxx其它方法请参考源码\n}\n</code></pre><p>这里，我以placeOrder方法为例，带你走读一下它的源码。如果你对其它方法的源码感兴趣，可以到<a href=\"https://gitee.com/banxian-yao/geekbang-coupon-center\">Gitee源码库</a>中找到Spring Boot急速落地篇的CouponCustomerServiceImpl类，查看源代码。</p><p>placeOrder方法实现了用户下单+优惠券核销的功能，我们来看一下它的实现逻辑。</p><pre><code>@Override\n@Transactional\npublic ShppingCart placeOrder(ShppingCart order) {\n    // 购物车为空，丢出异常\n    if (CollectionUtils.isEmpty(order.getProducts())) {\n        log.error(&quot;invalid check out request, order={}&quot;, order);\n        throw new IllegalArgumentException(&quot;cart is empty&quot;);\n    }\n\n    Coupon coupon = null;\n    if (order.getCouponId() != null) {\n        // 如果有优惠券就把它查出来，看是不是属于当前用户并且可用\n        Coupon example = Coupon.builder().userId(order.getUserId())\n                .id(order.getCouponId())\n                .status(CouponStatus.AVAILABLE)\n                .build();\n        coupon = couponDao.findAll(Example.of(example)).stream()\n                .findFirst()\n                // 如果当前用户查不到可用优惠券，就抛出错误\n                .orElseThrow(() -&gt; new RuntimeException(&quot;Coupon not found&quot;));        \n        // 优惠券有了，再把它的券模板信息查出\n        // 券模板里的Discount规则会在稍后用于订单价格计算\n        CouponInfo couponInfo = CouponConverter.convertToCoupon(coupon);\n        couponInfo.setTemplate(templateService.loadTemplateInfo(coupon.getTemplateId()));\n        order.setCouponInfos(Lists.newArrayList(couponInfo));\n    }\n\n    // 调用calculation服务使用优惠后的订单价格\n    ShppingCart checkoutInfo = calculationService.calculateOrderPrice(order);\n\n    if (coupon != null) {\n        // 如果优惠券没有被结算掉，而用户传递了优惠券，报错提示该订单满足不了优惠条件\n        if (CollectionUtils.isEmpty(checkoutInfo.getCouponInfos())) {\n            log.error(&quot;cannot apply coupon to order, couponId={}&quot;, coupon.getId());\n            throw new IllegalArgumentException(&quot;coupon is not applicable to this order&quot;);\n        }\n        log.info(&quot;update coupon status to used, couponId={}&quot;, coupon.getId());\n        coupon.setStatus(CouponStatus.USED);\n        couponDao.save(coupon);\n    }\n    return checkoutInfo;\n}\n</code></pre><p>在上面的源码中，我们看到Coupon对象的构造使用了Builder链式编程的风格，这是得益于在Coupon类上面声明的Lombok的Builder注解，只用一个Builder注解就能享受链式构造的体验。</p><p>搞定了业务逻辑层后，接下来轮到Controller部分了，我在CouponCustomerController中对外暴露了几个服务，这些服务调用CouponCustomerServiceImpl中的方法实现各自的业务逻辑。</p><pre><code>@Slf4j\n@RestController\n@RequestMapping(&quot;coupon-customer&quot;)\npublic class CouponCustomerController {\n    @Autowired\n    private CouponCustomerService customerService;\n  \n    // ....省略部分方法，完整方法列表请参考源码    \n\n    // 用户模拟计算每个优惠券的优惠价格\n    @PostMapping(&quot;simulateOrder&quot;)\n    public SimulationResponse simulate(@Valid @RequestBody SimulationOrder order) {\n        return customerService.simulateOrderPrice(order);\n    }\n    \n    // 用户删除优惠券 - 非物理删除\n    @DeleteMapping(&quot;deleteCoupon&quot;)\n    public void deleteCoupon(@RequestParam(&quot;userId&quot;) Long userId,\n                         @RequestParam(&quot;couponId&quot;) Long couponId) {\n        customerService.deleteCoupon(userId, couponId);\n    }\n    \n    // 下单核销优惠券\n    @PostMapping(&quot;checkout&quot;)\n    public ShppingCart checkout(@Valid @RequestBody ShppingCart info) {\n        return customerService.placeOrder(info);\n    }\n}\n</code></pre><p>以上，就是所有的业务逻辑代码部分了。接下来你只需要完成启动类和配置文件，就可以启动项目做测试了。我先来带你看一下启动类的部分：</p><pre><code>@SpringBootApplication\n@EnableJpaAuditing\n@ComponentScan(basePackages = {&quot;com.geekbang&quot;})\n@EnableTransactionManagement\n//用于扫描Dao @Repository\n@EnableJpaRepositories(basePackages = {&quot;com.geekbang&quot;})\n//用于扫描JPA实体类 @Entity，默认扫本包当下路径\n@EntityScan(basePackages = {&quot;com.geekbang&quot;})\npublic class Application {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n</code></pre><p>在上面的源码中，我们看到很多注解上都注明了com.geekbang作为包路径。之所以这么做，是因为Spring Boot的潜规则是将当前启动类类所在package作为扫包路径。</p><p>如果你的Application在com.geekbang.customer下，而你在项目中又需要加载来自com.geekbang.template下的类资源，就必须额外声明扫包路径，否则只有在com.geekbang.customer和其子路径之下的资源才会被加载。</p><p>关于配置项的部分，你可以直接把coupon-template-impl的配置文件application.yml照搬过来，不过，<strong>要记得把里面配置的spring.application.name改成coupon-customer-serv</strong>。</p><p>好，到这里，我们优惠券平台项目的Spring Boot版本就搭建完成了。现在，coupon-customer-serv已经成了一个三合一的单体应用，你只要在本地启动这一个应用，就可以调用customer、template和calculation三个服务的功能。</p><h2>总结</h2><p>现在，我们来回顾一下这两节Spring Boot实战课的重点内容。通过这两节课，我带你搭建了完整的Spring Boot版优惠券平台的三个子模块。为了让项目结构更加清晰，我用<strong>分层设计</strong>的思想将每个模块拆分成API层、DAO层和业务层。在搭建过程中，我们使用spring-data-jpa搞定了数据层，短短几行代码就能实现复杂的CRUD操作；使用spring-web搭建了Controller层，对外暴露了RESTFul风格的接口。</p><p>我们学习技术也分为外功修为和内功修行，讲究的是内外兼修。技术框架总会不断推陈出新，学会怎么使用一门技术，这修习的是外功。你掌握了一个功能强大的新框架，外功招式自然凌厉几分。但是能决定你武力值的上限有多高，还要靠你在工作学习中不断提高内功修为。</p><p>外功见效快而内功需要长期磨炼，就像我这节课分享的设计模式一样，设计模式就是典型的内功心法，学会一两种设计模式不会让你的技术水平产生突飞猛进的提高，但是当你逐渐融会贯通把各种设计模式活学活用到代码中，境界层次就变得不一样了。</p><p>从下一节课开始，我们将进入Spring Cloud基础篇的学习，通过基础篇的学习，你将熟练使用Nacos、Loadbalancer和OpenFeign组件来搭建基于微服务架构的跨服务调用。</p><h2>思考题</h2><p>如果我们分别把coupon-customer-serv、coupon-template-serv和coupon-calculation-serv分别部署在集群A、B和C上，你能想到几种方式，使得这几个应用可以在集群环境中互相发起调用呢？</p><p>我给你一个小提示，在思考这个问题的时候，你要想到一点，服务有可能会发生上下线而且集群也可能会扩容，要尽可能让调用请求发到正常工作的机器上，提高请求成功率。欢迎你在留言区分享你的想法和收获，我在留言区等你。</p><p>好啦，这节课就结束啦。也欢迎你把这节课分享给更多对Spring Cloud感兴趣的朋友。我是姚秋辰，我们下节课再见！</p>","comments":[{"had_liked":false,"id":328178,"user_name":"gallifrey","can_delete":false,"product_type":"c1","uid":1366631,"ip_address":"","ucode":"A4E5E0E7E2DEF9","user_header":"https://static001.geekbang.org/account/avatar/00/14/da/67/73a0c754.jpg","comment_is_top":true,"comment_ctime":1640590375,"is_pvip":false,"replies":[{"id":"119499","content":"还真是，我这数学就是体育老师都教不出来！想当年做营销中心的时候就搞出了个全店5折的bug。同学你算数一定是正经老师教的，思路清晰理解到位。<br><br>话说极客的评论置顶功能怎么玩，编辑大大，帮我把这条置顶。要让童鞋们看看，小学数学基础对以后写代码的指导意义有多大。一个程序员的一生，就是和bug抗争的一生，没有搞过几个P0 bug就像没挂过科一样，这个人生是不完整的。<br><br>我作为程序员的人生特别的完整。看了这个评论的同学们，你想自己家孩子也搞几个P0被3.25年终奖泡汤吗？不你不想，那就从我做起，赶紧的给娃的私教奥数补习班报起来","user_name":"作者回复","comment_id":328178,"uid":"2819998","ip_address":"","utype":1,"ctime":1640611804,"user_name_real":"作者"}],"discussion_count":4,"race_medal":0,"score":"9.2233720728550994e+18","product_id":100101301,"comment_content":"@Override<br>    protected Long calculateNewPrice(Long totalAmount, Long shopAmount, Long quota) {<br>        &#47;&#47; 计算使用优惠券之后的价格<br>        Long newPrice = convertToDecimal(shopAmount * (quota.doubleValue()&#47;100));<br>        log.debug(&quot;original price={}, new price={}&quot;, totalAmount, newPrice);<br>        return newPrice;<br>    }<br>作者看一下这个DiscountTemplate类的实现逻辑有问题，newPrice只是该商户的折扣完的价格，总价是totalAmount - shopAmount + newPrice ；<br>不知理解是否正确","like_count":8,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541946,"discussion_content":"还真是，我这数学就是体育老师都教不出来！想当年做营销中心的时候就搞出了个全店5折的bug。同学你算数一定是正经老师教的，思路清晰理解到位。\n\n话说极客的评论置顶功能怎么玩，编辑大大，帮我把这条置顶。要让童鞋们看看，小学数学基础对以后写代码的指导意义有多大。一个程序员的一生，就是和bug抗争的一生，没有搞过几个P0 bug就像没挂过科一样，这个人生是不完整的。\n\n我作为程序员的人生特别的完整。看了这个评论的同学们，你想自己家孩子也搞几个P0被3.25年终奖泡汤吗？不你不想，那就从我做起，赶紧的给娃的私教奥数补习班报起来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640611804,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":1366631,"avatar":"https://static001.geekbang.org/account/avatar/00/14/da/67/73a0c754.jpg","nickname":"gallifrey","note":"","ucode":"A4E5E0E7E2DEF9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":542015,"discussion_content":"这种类似bug我也干过，格外小心哈哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640619606,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":541946,"ip_address":""},"score":542015,"extra":""},{"author":{"id":1130726,"avatar":"https://static001.geekbang.org/account/avatar/00/11/40/e6/2cd0f52b.jpg","nickname":"Mr.x","note":"","ucode":"FDA144380DB9AE","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":543931,"discussion_content":"试图化解尴尬，哈哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641353651,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":541946,"ip_address":""},"score":543931,"extra":""}]},{"author":{"id":1076768,"avatar":"https://static001.geekbang.org/account/avatar/00/10/6e/20/a0740b7d.jpg","nickname":"刘智敏","note":"","ucode":"83D3DE25192DD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550384,"discussion_content":"我感觉这里的日志打印的逻辑是原始总价和新的总价，原始总价是totalAmount，新的总价是楼主说的这个totalAmount - shopAmount + newPrice","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1644503212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327863,"user_name":"Layne","can_delete":false,"product_type":"c1","uid":1479934,"ip_address":"","ucode":"1FEAACD900AB39","user_header":"https://static001.geekbang.org/account/avatar/00/16/94/fe/5fbf1bdc.jpg","comment_is_top":false,"comment_ctime":1640333237,"is_pvip":true,"replies":[{"id":"119400","content":"非常不错，使用nginx、keepalive做vip是挺常用的方案，省钱又简单","user_name":"作者回复","comment_id":327863,"uid":"2819998","ip_address":"","utype":1,"ctime":1640360449,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"40295038901","product_id":100101301,"comment_content":"回答下思考题：<br>1.利用注册中心的方式；<br>2.利用API网关的方式；<br>3.利用类似nginx这种做VIP的负载均衡方式。","like_count":9,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541432,"discussion_content":"非常不错，使用nginx、keepalive做vip是挺常用的方案，省钱又简单","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640360449,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328271,"user_name":"Geek_a6bab1","can_delete":false,"product_type":"c1","uid":2876451,"ip_address":"","ucode":"BDFC5B79B18471","user_header":"","comment_is_top":false,"comment_ctime":1640651674,"is_pvip":false,"replies":[{"id":"119562","content":"在业务里将join用户表的操作替换成通过后台api调用，获取用户服务信息。不过用户是基础数据，查询量比较巨大，实践里最好做一层数据异构，比如上一些主搜服务挡在DB前面。我打一个比方，就像做商品中心，如果商品表以前都是join获取商品数据，现在微服务化之后就把商品数据异构到了opensearch（根据自己公司技术栈选择主搜中间件选型），然后让业务方接入open search，对时效性要求很高的服务才通过对外暴露api做表查询","user_name":"作者回复","comment_id":328271,"uid":"2819998","ip_address":"","utype":1,"ctime":1640672716,"user_name_real":"编辑"}],"discussion_count":2,"race_medal":0,"score":"31705422746","product_id":100101301,"comment_content":"老师您好，请教一个问题。我现在有一个比较久的springboot项目，需要升级到cloud项目，每个服务对应了一个数据库。现在碰到的问题是，把用户表拆出来以后，再别的服务就不能通过join去关联用户信息了。对于该问题一般在分布式项目中是怎么处理的？","like_count":8,"discussions":[{"author":{"id":1401420,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLTFKH3aA1FV6lhNnX7sQO3kNjKD7vLangkmLThBUA2gx0eB7yiaP3ibR3z9cIJ9brZSaqwodIRulHA/132","nickname":"卡普","note":"","ucode":"2B37A4466BC077","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570394,"discussion_content":"可以先把对应的库放在同一个RDS中，这样仍然可以通过库名+表名的形式join，让业务先跑起来，然逐步替代","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1651754574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542146,"discussion_content":"在业务里将join用户表的操作替换成通过后台api调用，获取用户服务信息。不过用户是基础数据，查询量比较巨大，实践里最好做一层数据异构，比如上一些主搜服务挡在DB前面。我打一个比方，就像做商品中心，如果商品表以前都是join获取商品数据，现在微服务化之后就把商品数据异构到了opensearch（根据自己公司技术栈选择主搜中间件选型），然后让业务方接入open search，对时效性要求很高的服务才通过对外暴露api做表查询","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1640672716,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327810,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1640313322,"is_pvip":true,"replies":[{"id":"119403","content":"orm可以理解为一个“理念”或者“口号”，在关系型DB和对象之间构建一层映射。jpa是一种“ORM规范”，它没有实现ORM，只是定义了一组持久化API的规范，我在项目中用的spring官方推荐的spring-data-jpa（底层hibernate实现）才是jpa规范的具体实现，像openjpa、toplink这些都是jpa的实现。mybatis你可以理解为半自动或者手动挡的ORM框架，它本身并不是jpa的实现，你可以了解一下mybatis-plus，比mybatis好用一些。<br><br>","user_name":"作者回复","comment_id":327810,"uid":"2819998","ip_address":"","utype":1,"ctime":1640362418,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"23115149802","product_id":100101301,"comment_content":"请教两个问题：问题1：jpa本身不是具体的ORM框架，而是对ORM框架的一个封装，对吗？问题2：jpa只能用hibernate吗？能用mybatis吗？","like_count":5,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541439,"discussion_content":"orm可以理解为一个“理念”或者“口号”，在关系型DB和对象之间构建一层映射。jpa是一种“ORM规范”，它没有实现ORM，只是定义了一组持久化API的规范，我在项目中用的spring官方推荐的spring-data-jpa（底层hibernate实现）才是jpa规范的具体实现，像openjpa、toplink这些都是jpa的实现。mybatis你可以理解为半自动或者手动挡的ORM框架，它本身并不是jpa的实现，你可以了解一下mybatis-plus，比mybatis好用一些。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640362418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":337671,"user_name":"找工作","can_delete":false,"product_type":"c1","uid":1756876,"ip_address":"","ucode":"DFD2FFACAEDC12","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ce/cc/ec5895b0.jpg","comment_is_top":false,"comment_ctime":1646964840,"is_pvip":false,"replies":[{"id":"123397","content":"设计模式最大的用处，就是在面试环节哇咔咔！<br><br>要是评选最滥竽充数的设计模式，我推选facade","user_name":"作者回复","comment_id":337671,"uid":"2819998","ip_address":"","utype":1,"ctime":1646994908,"user_name_real":"编辑"}],"discussion_count":2,"race_medal":0,"score":"18826834024","product_id":100101301,"comment_content":"姚老师在讲主线的时候穿插了很多干货，以前看了很多次设计模式，但是就连最简单的工厂模式是啥都没记住。姚老师一句：工厂方法会将子类转为顶层接口返回。直接道出了核心！","like_count":4,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555623,"discussion_content":"设计模式最大的用处，就是在面试环节哇咔咔！\n\n要是评选最滥竽充数的设计模式，我推选facade","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646994908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2927904,"avatar":"","nickname":"Geek9382","note":"","ucode":"638288F553332F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557850,"discussion_content":"我选择模板模式。。噗。。最简单的 juc里边AQS嘛。。而且面试官喜欢聊 AQS要聊的东西可多啦。。不过最关键的还是学习人家的设计与玩法。。多看优秀且自己熟悉项目的源码。。比如jdk  比如tomcat  对吧。。这里边有值得学习  正常开发也一直在用。。看会了他们咋玩的。。自己开发的时候 别上来一顿怼。。而是仔细思考 能不能用已有的知识套路 套路一下？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647999994,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329652,"user_name":"杨逸林","can_delete":false,"product_type":"c1","uid":1167233,"ip_address":"","ucode":"4BF3CF3E2F1AC7","user_header":"https://static001.geekbang.org/account/avatar/00/11/cf/81/96f656ef.jpg","comment_is_top":false,"comment_ctime":1641457292,"is_pvip":false,"replies":[{"id":"120088","content":"后面我们会转成使用openfeign来发起远程调用，feign组件有一个同样的功能课程里会讲到","user_name":"作者回复","comment_id":329652,"uid":"2819998","ip_address":"","utype":1,"ctime":1641486499,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"14526359180","product_id":100101301,"comment_content":"老师怎么不用 Spring MVC 自带的记录请求体打印的内容来打印 @RequestBody 修饰的内容呢？这样一个个写 log.info JSON.toJSONString不累吗。<br><br>```java<br>    @Bean<br>    public CommonsRequestLoggingFilter logFilter() {<br>        CommonsRequestLoggingFilter filter<br>                = new CommonsRequestLoggingFilter();<br>        filter.setIncludeQueryString(true);<br>        filter.setIncludePayload(true);<br>        filter.setMaxPayloadLength(10000);<br>        filter.setIncludeHeaders(false);<br>        filter.setAfterMessagePrefix(&quot;REQUEST DATA : &quot;);<br>        return filter;<br>    }<br>```<br>application.yml<br>```yml<br>logging:<br>  level:<br>    org:<br>      springframework:<br>        web:<br>          filter:<br>            # 打开请求体的日志<br>            CommonsRequestLoggingFilter: debug<br>```<br>或者在 logback 里面配置也是一样的。<br>这样就能看到请求体里面的内容了，它最终会转成 CacheXXWrapper，从已缓存的内容里面读。","like_count":3,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544380,"discussion_content":"后面我们会转成使用openfeign来发起远程调用，feign组件有一个同样的功能课程里会讲到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641486499,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328779,"user_name":"martin","can_delete":false,"product_type":"c1","uid":1031930,"ip_address":"","ucode":"F2CA8F9976AC43","user_header":"https://static001.geekbang.org/account/avatar/00/0f/be/fa/2c5cb1e6.jpg","comment_is_top":false,"comment_ctime":1640878316,"is_pvip":false,"replies":[{"id":"119803","content":"啊哈，我抄作业的时候顺带拿过来了，同学很细心，这段可以去掉","user_name":"作者回复","comment_id":328779,"uid":"2819998","ip_address":"","utype":1,"ctime":1640928209,"user_name_real":"编辑"}],"discussion_count":2,"race_medal":0,"score":"14525780204","product_id":100101301,"comment_content":"老师，请教一个问题，AbstractRuleTemplate 已经实现了 RuleTemplate  接口，为什么 MoneyOffTemplate  还要重复写 implements RuleTemplate 呢？<br>public abstract class AbstractRuleTemplate implements RuleTemplate {}<br><br>public class MoneyOffTemplate extends AbstractRuleTemplate implements RuleTemplate {}","like_count":3,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542995,"discussion_content":"啊哈，我抄作业的时候顺带拿过来了，同学很细心，这段可以去掉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640928209,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1493907,"avatar":"https://static001.geekbang.org/account/avatar/00/16/cb/93/4adea49a.jpg","nickname":"努力努力再努力","note":"","ucode":"0C6EEA28FCE8C7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":545324,"discussion_content":"老师，我看spring源码里有很多接口也是这么做的，又继承然后又实现，请问这是有什么考量的吗，就像老师拷贝过来一样，那个伙计写这个的时候为啥会考虑又继承又实现咧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641906878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":542995,"ip_address":""},"score":545324,"extra":""}]}]},{"had_liked":false,"id":328288,"user_name":"请叫我和尚","can_delete":false,"product_type":"c1","uid":1703256,"ip_address":"","ucode":"33A8A1CDA103F9","user_header":"https://static001.geekbang.org/account/avatar/00/19/fd/58/1af629c7.jpg","comment_is_top":false,"comment_ctime":1640654468,"is_pvip":false,"replies":[{"id":"119568","content":"一年半已经是中忍级别了，实体类啥的就直接copy过来吧，么的问题的","user_name":"作者回复","comment_id":328288,"uid":"2819998","ip_address":"","utype":1,"ctime":1640673099,"user_name_real":"编辑"}],"discussion_count":2,"race_medal":0,"score":"14525556356","product_id":100101301,"comment_content":"有一个问题，目前已经 1 年半的 Java 业务开发经验，看源码的时候，需要跟着动手写吗？还是看源码梳理业务逻辑不用跟着动手写。<br>如果要跟着动手写，那是不是主要写业务逻辑处理部分，实体类这些就没有必要去重复写了，直接 cv？","like_count":3,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542153,"discussion_content":"一年半已经是中忍级别了，实体类啥的就直接copy过来吧，么的问题的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640673099,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1703256,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fd/58/1af629c7.jpg","nickname":"请叫我和尚","note":"","ucode":"33A8A1CDA103F9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":542221,"discussion_content":"那业务逻辑处理部分的代码呢，是重新写一遍还是按照你的代码看一遍你的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640685132,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":542153,"ip_address":""},"score":542221,"extra":""}]}]},{"had_liked":false,"id":327769,"user_name":"ᯤ⁵ᴳ","can_delete":false,"product_type":"c1","uid":1621494,"ip_address":"","ucode":"BA8F60B05D1389","user_header":"https://static001.geekbang.org/account/avatar/00/18/bd/f6/558bb119.jpg","comment_is_top":false,"comment_ctime":1640281344,"is_pvip":false,"replies":[{"id":"119402","content":"需要在本地先把数据库表创建好，把jdbc url和db用户名密码等配置好之后才能运行。改成H2先本地启动玩一玩是不错的方法","user_name":"作者回复","comment_id":327769,"uid":"2819998","ip_address":"","utype":1,"ctime":1640361489,"user_name_real":"编辑"}],"discussion_count":4,"race_medal":0,"score":"14525183232","product_id":100101301,"comment_content":"gitee上面的代码并不能直接run起来，建议先把数据库改成h2 然后放入建表语句等 直接跑起来再对照着看会好一点","like_count":3,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541438,"discussion_content":"需要在本地先把数据库表创建好，把jdbc url和db用户名密码等配置好之后才能运行。改成H2先本地启动玩一玩是不错的方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640361490,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1434423,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e3/37/c132802f.jpg","nickname":"WESTWALL","note":"","ucode":"295A030F9D3BF4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542697,"discussion_content":"我一开始也想用H2，后来发现customer和template都要连数据库，虽然后面会改，但现在确实是两个服务要查同一个表。又一想后面还Seata……果断放弃，还是docker-compose香","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640828682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1107209,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e5/09/ddabec76.jpg","nickname":"李峰","note":"","ucode":"3DA3574DB432A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541358,"discussion_content":"用docker 构建一个mysql容器，两个命令的事情","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640339765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1400170,"avatar":"https://static001.geekbang.org/account/avatar/00/15/5d/6a/83f7eb7f.jpg","nickname":"PueC","note":"","ucode":"6CE6B22DA69416","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541284,"discussion_content":"我倒是觉得MySQL安装挺好的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640317741,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330757,"user_name":"大明猩","can_delete":false,"product_type":"c1","uid":1494622,"ip_address":"","ucode":"61D330B42AE3C4","user_header":"https://static001.geekbang.org/account/avatar/00/16/ce/5e/b103d538.jpg","comment_is_top":false,"comment_ctime":1642148117,"is_pvip":true,"replies":[{"id":"120928","content":"这个托是专业的！","user_name":"作者回复","comment_id":330757,"uid":"2819998","ip_address":"","utype":1,"ctime":1642425959,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"10232082709","product_id":100101301,"comment_content":"看了老师写的代码，感觉自己这几年白学了，写不出来这么好的代码啊！","like_count":2,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546795,"discussion_content":"这个托是专业的！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642425959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327839,"user_name":"kimoti","can_delete":false,"product_type":"c1","uid":1897671,"ip_address":"","ucode":"0A78077408C2B1","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f4/c7/037235c9.jpg","comment_is_top":false,"comment_ctime":1640322294,"is_pvip":false,"replies":[{"id":"119409","content":"每到面试的时候，内功心法都会大幅提升","user_name":"作者回复","comment_id":327839,"uid":"2819998","ip_address":"","utype":1,"ctime":1640363391,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"10230256886","product_id":100101301,"comment_content":"修炼外功就是写业务逻辑代码,修炼内功就是算法,计算机底层原理,操作系统……","like_count":2,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541446,"discussion_content":"每到面试的时候，内功心法都会大幅提升","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640363391,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327773,"user_name":"时光@1","can_delete":false,"product_type":"c1","uid":1585019,"ip_address":"","ucode":"0358732C5E80AE","user_header":"https://static001.geekbang.org/account/avatar/00/18/2f/7b/3f506234.jpg","comment_is_top":false,"comment_ctime":1640296477,"is_pvip":false,"replies":[{"id":"119405","content":"就像一条河流一样，用户调用开始的地方是起始点，在最上游，然后逐渐流到了下游的底层服务。或者可以这么理解，你的服务所调用的服务，对于你的服务本身来说就是下游服务","user_name":"作者回复","comment_id":327773,"uid":"2819998","ip_address":"","utype":1,"ctime":1640362562,"user_name_real":"编辑"}],"discussion_count":2,"race_medal":0,"score":"10230231069","product_id":100101301,"comment_content":"老师 请问下 怎么样算是上游服务？","like_count":2,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541441,"discussion_content":"就像一条河流一样，用户调用开始的地方是起始点，在最上游，然后逐渐流到了下游的底层服务。或者可以这么理解，你的服务所调用的服务，对于你的服务本身来说就是下游服务","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1640362562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1585019,"avatar":"https://static001.geekbang.org/account/avatar/00/18/2f/7b/3f506234.jpg","nickname":"时光@1","note":"","ucode":"0358732C5E80AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541479,"discussion_content":"知道了 谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640400812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":340195,"user_name":"honmio","can_delete":false,"product_type":"c1","uid":1318805,"ip_address":"","ucode":"18C384AEAB3934","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJkOBhbBYIlfyhcLOOM569km83TAtRnckgRib4nwribISMh22ciaCnX7AoFMofNyYiaaTQwH26nichnJAw/132","comment_is_top":false,"comment_ctime":1648650844,"is_pvip":true,"replies":[{"id":"125170","content":"1. 同学说的没错，06讲的时候还没有涉及到微服务，所以这里的思考题是引出接下来要介绍的微服务部分，网关+注册中心+LB的合集<br>2. 不同团队负责的微服务代码提交到不同的git repo中（课程中为了方便下载放到了同一个包），使用maven管理微服务之间的依赖，一般只引用对向服务的api三方包，也就是一些pojo接口和类，不引入具体实现类","user_name":"作者回复","comment_id":340195,"uid":"2819998","ip_address":"","utype":1,"ctime":1650416090,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"5943618140","product_id":100101301,"comment_content":"老师好，对于思考题有两个疑问请教一下：<br><br>1、感觉上述几位朋友说的几种方式，难道不应该是配合在一起才会达到效果么？以注册中心为底，各集群的网关分别向注册中心提交各集群网关地址；当某集群向注册中心发起调用时，在目标集群内部，可以通过nginx或ka做负载方案达到目的。单纯的网关、注册中心、负载貌似都是解决方案的一部分<br><br>2、对maven不是很熟悉，像代码中这样的构建方式（多个项目包含在一起，根据maven构建父子模块），如果拆分到三个集群中，那么项目的互相引用，是需要将各项目做maven私服，然后根据maven包的三元素来做引用么？还是有更巧妙的方法<br><br>谢谢老师🙏","like_count":1,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":565158,"discussion_content":"1. 同学说的没错，06讲的时候还没有涉及到微服务，所以这里的思考题是引出接下来要介绍的微服务部分，网关+注册中心+LB的合集\n2. 不同团队负责的微服务代码提交到不同的git repo中（课程中为了方便下载放到了同一个包），使用maven管理微服务之间的依赖，一般只引用对向服务的api三方包，也就是一些pojo接口和类，不引入具体实现类","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650416090,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328597,"user_name":"塔矢亮的小螃蟹","can_delete":false,"product_type":"c1","uid":1170561,"ip_address":"","ucode":"5AEE1B64589D8D","user_header":"https://static001.geekbang.org/account/avatar/00/11/dc/81/76aceead.jpg","comment_is_top":false,"comment_ctime":1640783972,"is_pvip":false,"replies":[{"id":"119686","content":"确实是这样的，可以设想一下你在一个大的事业部，每个不同的模块都是不同的团队和独立的repo，你依赖的服务如果有更新，需要它们重新打包来做发布的。<br><br>比如像淘系这类用HSF框架的团队（和dubbo差不太多的一个rpc），是通过把公共类和接口单独打包出来供上下游业务来调用，那么如果业务更新迭代的过程中，你的接口层如果新加了method或者类加了属性，提供这个接口的团队需要build一个新的三方包并发版，让其他团队去引用。<br><br>当然了，还有一种方式可以不用build，但并不是很推荐，那就是用git的submodule功能，指定依赖项目的github url和branch，把依赖方作为当前项目的一个submodule引入进来。可以网上搜一下git submodule用法","user_name":"作者回复","comment_id":328597,"uid":"2819998","ip_address":"","utype":1,"ctime":1640787132,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"5935751268","product_id":100101301,"comment_content":"Hello 老师，我现在正在敲这块业务代码，不是在一个工程下分子模块，而是每一个大模块都是一个单独的工程，但是这样子就遇到了问题，比如说A工程需要引用到B工程的一个class<br><br>目前尝试的方法是把B工程通过.&#47;gradlew build打包成jar 包再添加到A工程的依赖中，但是这样子的话，尝试import class 不生效，判断可能是因为两个工程的包名是一致的吧，而且这样子的话一旦B有了更新，还得重新打包，感觉很不方便。<br>请问下老师有没有什么好的方法呢，","like_count":1,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542571,"discussion_content":"确实是这样的，可以设想一下你在一个大的事业部，每个不同的模块都是不同的团队和独立的repo，你依赖的服务如果有更新，需要它们重新打包来做发布的。\n\n比如像淘系这类用HSF框架的团队（和dubbo差不太多的一个rpc），是通过把公共类和接口单独打包出来供上下游业务来调用，那么如果业务更新迭代的过程中，你的接口层如果新加了method或者类加了属性，提供这个接口的团队需要build一个新的三方包并发版，让其他团队去引用。\n\n当然了，还有一种方式可以不用build，但并不是很推荐，那就是用git的submodule功能，指定依赖项目的github url和branch，把依赖方作为当前项目的一个submodule引入进来。可以网上搜一下git submodule用法","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1640787132,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328066,"user_name":"Geek_83494d","can_delete":false,"product_type":"c1","uid":2597299,"ip_address":"","ucode":"7D6822403BD745","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eouGPYeQWpN0mkruymokBib2SOsgv0RTJ60JiaCDxFic09X7VYgHRPBStHHNssvPkqm9Szskd3I6JEmQ/132","comment_is_top":false,"comment_ctime":1640511641,"is_pvip":false,"replies":[{"id":"119452","content":"比如非标品类的生鲜，计量单位是公斤，订单和小票上的数量单位就成小数了。对于生鲜类的库存管理来说，还有损耗计提，一斤牛肉在首次计量和最终卖出之间重量是不一样的（比如水分流失），后台商品中心统计损耗的时候也需要小数。","user_name":"作者回复","comment_id":328066,"uid":"2819998","ip_address":"","utype":1,"ctime":1640524735,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"5935478937","product_id":100101301,"comment_content":"所以在实际项目中，尤其是零售行业的业务系统里，计件单位要允许小数位的存在。  麻烦老师展开说一说。","like_count":1,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541709,"discussion_content":"比如非标品类的生鲜，计量单位是公斤，订单和小票上的数量单位就成小数了。对于生鲜类的库存管理来说，还有损耗计提，一斤牛肉在首次计量和最终卖出之间重量是不一样的（比如水分流失），后台商品中心统计损耗的时候也需要小数。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1640524735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327908,"user_name":"暮雨yl晨曦","can_delete":false,"product_type":"c1","uid":1052785,"ip_address":"","ucode":"18E5D3A93E67FF","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/71/d6c2e3a0.jpg","comment_is_top":false,"comment_ctime":1640355606,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5935322902","product_id":100101301,"comment_content":"思考题我能想到的方式也和Layne同学一样。<br>想不出有比这3个更好的方式。<br>在老师的代码中发现了一些问题。<br>1.CouponCalculationService和它的实现类里的@RequestBody应该是可以去掉的。这个service类是放在controller package下的，是特地这么处理的吗？我的习惯一直都是controller和service是同一层级的package。另外，我的习惯是先有interface再有impl。也就是service package下都是interface，把ServiceImpl放到service.impl下。老师的代码里是service下放的是ServiceImpl，interface放在service.inf下。<br>2.CouponCalculationController下的两个restful接口，应该少了@Valid注解。<br>3.AntiPauTemplate，应该是拼错了。。是Pua。。。<br>4.可以看出来老师已经工作非常非常多年了。用的还是比较老的guava的方式，其实现在可以不用了。比如Lists.newArrayList()，现在我们习惯用Collections.emptyList(); <br>coupons.stream().forEach(e -&gt; e.setTemplateInfo(templateMap.get(e.getTemplateId())));<br>直接：coupons.forEach(e -&gt; e.setTemplateInfo(templateMap.get(e.getTemplateId())));这样就可以了。<br>5.老师的注释喜欢用&#47;&#47;，我还是喜欢用java doc的风格，就是&#47;* *&#47;这种。不然idea一直提示也很难受。<br>6.从代码细节上来看，我们所在的组写的代码在细节上比老师更优雅一些。这样我就放心了，多对比一下，看看自己哪里做的好哪里做的不好。老师的整体思路是很清晰的，多向老师学习。目前看起来我细节上处理还ok，但是对整个技术架构以及中间件没有非常深入了解，之后需要多花时间在这上面。<br>7.我们这个课程看起来应该是以实战为主，原理性的东西会少一些。希望老师也能多提一些重要的原理性的点，以及面试经常被问到的知识点。<br>8.顺带提一下，在有个章节，按照老师的方法安装rabbit mq，装完之后启动不起来，提示找不到命令。后来自己查了一下解决了。我猜测是系统版本引起的，我习惯把mac os升级到最新版。<br>","like_count":1,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541555,"discussion_content":"包名定义只要遵循各个公司的规范就好，impl和intf都是比较常用的规范，不过controller和service还是尽量分开在不同的package。还有一种方式是直接去掉controller层，对外暴露service，底层逻辑封装在manager里，也是比较常用的。\n\nPUA和PAU一直傻傻分不清楚，曾经被PUA太狠了，可能潜意识里太想躲开这个词儿了。\n\nLists.newArrayList和empltyList分使用场景，如果直接返回的对象一定不会被修改，推荐后者因为创建的是immutable对象，如果初始化list后需要加塞对象那么用前者。我属于个人习惯一般都用前者，也是防御型编程的一个习惯，因为如果这个类被当前服务内部的其他方法调用的话，调用方可以直接在返回对象中添加值，不会报出exception\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640442962,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1052785,"avatar":"https://static001.geekbang.org/account/avatar/00/10/10/71/d6c2e3a0.jpg","nickname":"暮雨yl晨曦","note":"","ucode":"18E5D3A93E67FF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":541602,"discussion_content":"谢谢老师。又学到了。果然还是要多交流。只要能学到新的知识就很开心。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1640482760,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":541555,"ip_address":""},"score":541602,"extra":""}]}]},{"had_liked":false,"id":327772,"user_name":"BOB","can_delete":false,"product_type":"c1","uid":2017580,"ip_address":"","ucode":"E86596709EAB1E","user_header":"https://static001.geekbang.org/account/avatar/00/1e/c9/2c/9ed40921.jpg","comment_is_top":false,"comment_ctime":1640287988,"is_pvip":false,"replies":[{"id":"119404","content":"同学你已经把我后面课程的内容总结好了","user_name":"作者回复","comment_id":327772,"uid":"2819998","ip_address":"","utype":1,"ctime":1640362452,"user_name_real":"编辑"}],"discussion_count":3,"race_medal":0,"score":"5935255284","product_id":100101301,"comment_content":"服务启动后向注册中心注册服务地址(ip:port)，其他服务调用前从注册中心获取最新的服务列表。注册中心维护各个服务的心跳，超时就把对应的服务地址移除，并将下线信息通知到其他订阅了这个服务的服务。服务间的调用失败时会换一个地址重试。","like_count":1,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541440,"discussion_content":"同学你已经把我后面课程的内容总结好了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640362452,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2017580,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/c9/2c/9ed40921.jpg","nickname":"BOB","note":"","ucode":"E86596709EAB1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":541454,"discussion_content":"嘿嘿，道理大家都懂，但是缺少实践经验。工作中也都是基础架构团队的服务框架拿来即用，很少有机会能直接接触到。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640374116,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":541440,"ip_address":""},"score":541454,"extra":""}]},{"author":{"id":2927904,"avatar":"","nickname":"Geek9382","note":"","ucode":"638288F553332F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557887,"discussion_content":"少了一部分。。除了各个节点定时任务向注册中心注册服务地址以外，还需要服务注册中心【或者其他类似检查中心】来嗅探或者类似机制。试想，因为心跳的定时任务与tomcat【或者说容器】并不是一个线程池，假设业务或者依赖组件bug导致tomcat的线程池全部堵塞，表现为服务僵死无响应，但是心跳继续发送。。这个情况，剔除不了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648018026,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":356375,"user_name":"摊牌","can_delete":false,"product_type":"c1","uid":1453182,"ip_address":"上海","ucode":"F142596BFE4594","user_header":"https://static001.geekbang.org/account/avatar/00/16/2c/7e/f1efd18b.jpg","comment_is_top":false,"comment_ctime":1662215197,"is_pvip":true,"replies":[{"id":"130683","content":"因为每个优惠券可能会有不同的计算方式，这个calculateNewPrice是变化的部分，抽象类中的calculate方法是固定的模板逻辑","user_name":"作者回复","comment_id":356375,"uid":"2819998","ip_address":"上海","utype":1,"ctime":1665410644,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1662215197","product_id":100101301,"comment_content":"老师，我有个疑惑，在抽象类AbstractRuleTemplate中calculateNewPrice方法不是可以按照下面实现吗，相当于计算出优惠券的优惠价格，为啥要在子类实现呢？<br><br>public Long calculateNewPrice(ShoppingCart order){<br>        ShoppingCart shoppingCart = calculate(ShoppingCart order);<br>        return order.getCost() - shoppingCart.getCost();<br>    };","like_count":0,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589955,"discussion_content":"因为每个优惠券可能会有不同的计算方式，这个calculateNewPrice是变化的部分，抽象类中的calculate方法是固定的模板逻辑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665410644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":355433,"user_name":"qwi","can_delete":false,"product_type":"c1","uid":2881048,"ip_address":"上海","ucode":"A11C36EE18CA6F","user_header":"https://static001.geekbang.org/account/avatar/00/2b/f6/18/97db3985.jpg","comment_is_top":false,"comment_ctime":1661377785,"is_pvip":false,"replies":[{"id":"130678","content":"是的，演示的程序逻辑比较简单，没有跨店之类的场景","user_name":"作者回复","comment_id":355433,"uid":"2819998","ip_address":"上海","utype":1,"ctime":1665410165,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1661377785","product_id":100101301,"comment_content":"老师，是不是这个计算优惠卷是以门店维度计算，不能在同一个订单中有多个门店的商品？当前只是一个门店的维度","like_count":0,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589950,"discussion_content":"是的，演示的程序逻辑比较简单，没有跨店之类的场景","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665410165,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":355432,"user_name":"qwi","can_delete":false,"product_type":"c1","uid":2881048,"ip_address":"上海","ucode":"A11C36EE18CA6F","user_header":"https://static001.geekbang.org/account/avatar/00/2b/f6/18/97db3985.jpg","comment_is_top":false,"comment_ctime":1661376336,"is_pvip":false,"replies":[{"id":"130692","content":"外层有个for循环，这里的orderPrice就是每次循环一个优惠价计算出的价格，然后和历史最低比较","user_name":"作者回复","comment_id":355432,"uid":"2819998","ip_address":"上海","utype":1,"ctime":1665411823,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1661376336","product_id":100101301,"comment_content":"老师你好<br>&#47;&#47; 比较订单价格，设置当前最优优惠券的ID<br>            &#47;&#47; todo long的最大值&gt;订单金额，就能判断出最优惠的优惠券ID？<br>            &#47;&#47; 是否应该先得到用户所有可用优惠卷的试算算金额以后，然后进行比较？<br>            if (minOrderPrice &gt; orderPrice) {<br>                response.setBestCouponId(coupon.getId());<br>                minOrderPrice = orderPrice;<br>            }<br>老师帮忙解答","like_count":0,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589967,"discussion_content":"外层有个for循环，这里的orderPrice就是每次循环一个优惠价计算出的价格，然后和历史最低比较","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665411823,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":354006,"user_name":"一刀流小依","can_delete":false,"product_type":"c1","uid":1506940,"ip_address":"上海","ucode":"91FED4C0037470","user_header":"https://static001.geekbang.org/account/avatar/00/16/fe/7c/33e55038.jpg","comment_is_top":false,"comment_ctime":1660010359,"is_pvip":false,"replies":[{"id":"130675","content":"同学考虑的很周到，课程里的案例多是出于教学目的，所以没有严格按照领域领域模型来划分。但template和calculate两个模型区分开来还是很必要的，以淘系ump举例，计算服务的链路调用量可以达到top5，但是模板服务相对非常低频，而且每增加一个新的计算类型，也是需要像你这里提到的对计算规则进行语义描述。所以当年在开发的时候，经常由于营销玩法太有花头，ump组人手不够所以让各个业务团队共建开发新的优惠模板。<br><br>在这个case里的拆分更多的是剥离低频高频场景，即原本一个领域模型内的业务，从内部做更细粒度的拆分。所以这个三方包（即公共模型）其实可以放在template和calculate以外的一个三方包中","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1665409481,"ip_address":"上海","comment_id":354006,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1660010359","product_id":100101301,"comment_content":"请教下老师，关于服务拆分的问题。<br>我理解老师提到的，关于计算密集和IO密集型服务的拆分的逻辑。但是这里会造成代码逻辑上有些有悖直觉。<br><br>template服务给出了discount的定义（CouponType等），但是discount如何计算和使用却在另一个calculation服务当中，而不是由template提供计算的规则。<br>这样的话，如果template服务哪天想新增一个discount种类了，对calculation服务来说是不直观的。<br>例如某天我想增加“开n次根券”、“对总价取log券”，这时候template服务中Discount这个api定义完全没有变化（也是一个Long quota就能描述），只是CouponType增加了两种类型。<br>那实际开发中，是一般需要依靠人员跨组沟通吗？还是一般这种程度的服务拆分，其实多个服务还是由同一个小团队开发维护的？<br><br>感觉从代码划分的角度出发的话，CouponType和api里的Discount可能应该由calculation服务定义。<br>这样计算侧就会更原生地了解如何把计算规则是配到CounponType里，template服务只是保存了一份Discount的DTO在数据库里，不关心这个DTO的实际含义。<br>但是这样优惠出现template依赖calculation这样也有悖直觉的情况（只依赖bean定义，不依赖服务）。","like_count":0,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589944,"discussion_content":"同学考虑的很周到，课程里的案例多是出于教学目的，所以没有严格按照领域领域模型来划分。但template和calculate两个模型区分开来还是很必要的，以淘系ump举例，计算服务的链路调用量可以达到top5，但是模板服务相对非常低频，而且每增加一个新的计算类型，也是需要像你这里提到的对计算规则进行语义描述。所以当年在开发的时候，经常由于营销玩法太有花头，ump组人手不够所以让各个业务团队共建开发新的优惠模板。\n\n在这个case里的拆分更多的是剥离低频高频场景，即原本一个领域模型内的业务，从内部做更细粒度的拆分。所以这个三方包（即公共模型）其实可以放在template和calculate以外的一个三方包中","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665409481,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":352421,"user_name":"迈向架构师","can_delete":false,"product_type":"c1","uid":1637228,"ip_address":"上海","ucode":"2476594CF76001","user_header":"https://static001.geekbang.org/account/avatar/00/18/fb/6c/12fdc372.jpg","comment_is_top":false,"comment_ctime":1658655132,"is_pvip":true,"replies":[{"id":"128728","content":"多谢同学火眼金睛。<br><br>原地呼叫小编，改一个错字","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1659942089,"ip_address":"上海","comment_id":352421,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1658655132","product_id":100101301,"comment_content":"typo：接下【里】我们去搭建 coupon-customer-dao 层，从数据层实现用户优惠券的增删改查。   ","like_count":0,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583183,"discussion_content":"多谢同学火眼金睛。\n\n原地呼叫小编，改一个错字","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659942089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346194,"user_name":"beatdrug","can_delete":false,"product_type":"c1","uid":1043410,"ip_address":"","ucode":"6291179E6E5C5B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/4VCgcBbU51SiasW8tpjYwdqBGe2RNIy6neuI7AEjCQ6t9qqXw6tXpZ2bDCoxJhWqQJv2LlFmemVYJCrLze2Aa7g/132","comment_is_top":false,"comment_ctime":1652885050,"is_pvip":false,"replies":[{"id":"126725","content":"其实是个人习惯啦，dao层和service层分离算是个“潜规则”，就像飞纸飞机前要哈一口气一样，虽然不一定飞得远，但这是比较有“仪式感”的“潜规则”","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1654237003,"ip_address":"","comment_id":346194,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1652885050","product_id":100101301,"comment_content":"老师，业务层和dao层分模块是基于什么考虑？是方便对dao层用其他方式实现吗？","like_count":0,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574660,"discussion_content":"其实是个人习惯啦，dao层和service层分离算是个“潜规则”，就像飞纸飞机前要哈一口气一样，虽然不一定飞得远，但这是比较有“仪式感”的“潜规则”","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1654237003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330397,"user_name":"努力努力再努力","can_delete":false,"product_type":"c1","uid":1493907,"ip_address":"","ucode":"0C6EEA28FCE8C7","user_header":"https://static001.geekbang.org/account/avatar/00/16/cb/93/4adea49a.jpg","comment_is_top":false,"comment_ctime":1641966400,"is_pvip":true,"replies":[{"id":"120454","content":"没错，这两个可以单独启动，是为了方便大家搭建好之后验证效果。那个customer服务是三合一应用，包含了template和calculation两个服务的代码。<br><br>后面我们会改造成三个完全独立的应用","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1642006238,"ip_address":"","comment_id":330397,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1641966400","product_id":100101301,"comment_content":"老师，这个springboot 里是不是两个单体应用了，计算服务和用户服务都是可以单独启动的，","like_count":0,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545641,"discussion_content":"没错，这两个可以单独启动，是为了方便大家搭建好之后验证效果。那个customer服务是三合一应用，包含了template和calculation两个服务的代码。\n\n后面我们会改造成三个完全独立的应用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642006238,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329711,"user_name":"Rorchachl","can_delete":false,"product_type":"c1","uid":1895320,"ip_address":"","ucode":"7AABFF65A0033C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/KiaBJsepm9fHHicfPxiahhR3RqRaR4QH6YFibIHV5o5VspTIXmH72iaiaotb4cRpWtRvLC7mnh5KH1KlSNLGWlI7wUicQ/132","comment_is_top":false,"comment_ctime":1641486505,"is_pvip":false,"replies":[{"id":"120171","content":"1.对的，是用户最终领取到的优惠券<br>2.购物车的couponId是看用户下单的时候选择使用哪个优惠券<br>3.异构其实也是一种冗余，但通常不用来代指同数据库里的“数据冗余”。举一个异构的例子，比如说你有一个MySQL的CuponTemplate表，它保存的是结构化数据，你可以把MySQL的信息异构到OpenSearch或者其他非结构化的主搜存储方案里，应对高并发的访问。","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1641645088,"ip_address":"","comment_id":329711,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1641486505","product_id":100101301,"comment_content":"开发顺序<br>1.了解业务 知道要做的功能<br>2.建立模型 api层<br>3.构建dao层<br>4.构建serve层 controller<br>老师你好 有几个问题 <br>1.Coupon 这个表可以理解为用户优惠券关联表？用来存放不同用户领取的不同优惠券<br>2.那购物车对象中有CouponId是基于什么考虑？<br>3.数据冗余是一个数据存多份？那数据异构是？","like_count":0,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544697,"discussion_content":"1.对的，是用户最终领取到的优惠券\n2.购物车的couponId是看用户下单的时候选择使用哪个优惠券\n3.异构其实也是一种冗余，但通常不用来代指同数据库里的“数据冗余”。举一个异构的例子，比如说你有一个MySQL的CuponTemplate表，它保存的是结构化数据，你可以把MySQL的信息异构到OpenSearch或者其他非结构化的主搜存储方案里，应对高并发的访问。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641645089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1076768,"avatar":"https://static001.geekbang.org/account/avatar/00/10/6e/20/a0740b7d.jpg","nickname":"刘智敏","note":"","ucode":"83D3DE25192DD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550389,"discussion_content":"缓存应该也算异构了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644504363,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328610,"user_name":"卟卟熊","can_delete":false,"product_type":"c1","uid":1006030,"ip_address":"","ucode":"017B762191BC65","user_header":"https://static001.geekbang.org/account/avatar/00/0f/59/ce/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1640789091,"is_pvip":false,"replies":[{"id":"119775","content":"如果参考淘系的话那就是一个大的用户中台对接各个事业部，其实各个领域对用户域的CRUD没什么区别，只是各领域内部的自玩法不同，那不同的部分就放在自己各个领域里面实现就好了，不用延伸到基础用户服务。<br><br>当然也有另一种服务治理的方式，比如在用户域和各种业务域之间构建一个防腐层，或者orchestration layer，对不同域的特殊场景做一些model上面的拼装，底层用户领域还是提供基础服务，由中间横叉的这一层做一些整合和拼装结果集的工作。<br>","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1640861151,"ip_address":"","comment_id":328610,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1640789091","product_id":100101301,"comment_content":"老师请教一个问题，我理解的是你把优惠卷划分成了一个大领域，一个领域下划分了围绕优惠卷的字服务，如果说用户中心，订单中心是否也可以划分成不同的领域呢，然而领域划分好了，在项目结构上是否应该是与现在的我优惠卷服务一样，单独起项目结构，那如果优惠卷领域与订单领域都用到了用户中心的领域，那是不是在用户中心需要起两个子服务为优惠卷领域和订单领域提供接口服务啊？感谢老师回答，这里有点混乱。","like_count":0,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542850,"discussion_content":"如果参考淘系的话那就是一个大的用户中台对接各个事业部，其实各个领域对用户域的CRUD没什么区别，只是各领域内部的自玩法不同，那不同的部分就放在自己各个领域里面实现就好了，不用延伸到基础用户服务。\n\n当然也有另一种服务治理的方式，比如在用户域和各种业务域之间构建一个防腐层，或者orchestration layer，对不同域的特殊场景做一些model上面的拼装，底层用户领域还是提供基础服务，由中间横叉的这一层做一些整合和拼装结果集的工作。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640861151,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}