{"id":161114,"title":"05 | 理论二：封装、抽象、继承、多态分别可以解决哪些编程问题？","content":"<p>上一节课，我简单介绍了面向对象的一些基本概念和知识点，比如，什么是面向对象编程，什么是面向对象编程语言等等。其中，我们还提到，理解面向对象编程及面向对象编程语言的关键就是理解其四大特性：封装、抽象、继承、多态。不过，对于这四大特性，光知道它们的定义是不够的，我们还要知道每个特性存在的意义和目的，以及它们能解决哪些编程问题。所以，今天我就花一节课的时间，针对每种特性，结合实际的代码，带你将这些问题搞清楚。</p><p>这里我要强调一下，对于这四大特性，尽管大部分面向对象编程语言都提供了相应的语法机制来支持，但不同的编程语言实现这四大特性的语法机制可能会有所不同。所以，今天，我们在讲解四大特性的时候，并不与具体某种编程语言的特定语法相挂钩，同时，也希望你不要局限在你自己熟悉的编程语言的语法思维框架里。</p><h2>封装（Encapsulation）</h2><p>首先，我们来看封装特性。封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据。这句话怎么理解呢？我们通过一个简单的例子来解释一下。</p><p>下面这段代码是金融系统中一个简化版的虚拟钱包的代码实现。在金融系统中，我们会给每个用户创建一个虚拟钱包，用来记录用户在我们的系统中的虚拟货币量。对于虚拟钱包的业务背景，这里你只需要简单了解一下即可。在面向对象的实战篇中，我们会有单独两节课，利用OOP的设计思想来详细介绍虚拟钱包的设计实现。</p><!-- [[[read_end]]] --><pre><code>public class Wallet {\n  private String id;\n  private long createTime;\n  private BigDecimal balance;\n  private long balanceLastModifiedTime;\n  // ...省略其他属性...\n\n  public Wallet() {\n     this.id = IdGenerator.getInstance().generate();\n     this.createTime = System.currentTimeMillis();\n     this.balance = BigDecimal.ZERO;\n     this.balanceLastModifiedTime = System.currentTimeMillis();\n  }\n\n  // 注意：下面对get方法做了代码折叠，是为了减少代码所占文章的篇幅\n  public String getId() { return this.id; }\n  public long getCreateTime() { return this.createTime; }\n  public BigDecimal getBalance() { return this.balance; }\n  public long getBalanceLastModifiedTime() { return this.balanceLastModifiedTime;  }\n\n  public void increaseBalance(BigDecimal increasedAmount) {\n    if (increasedAmount.compareTo(BigDecimal.ZERO) &lt; 0) {\n      throw new InvalidAmountException(&quot;...&quot;);\n    }\n    this.balance.add(increasedAmount);\n    this.balanceLastModifiedTime = System.currentTimeMillis();\n  }\n\n  public void decreaseBalance(BigDecimal decreasedAmount) {\n    if (decreasedAmount.compareTo(BigDecimal.ZERO) &lt; 0) {\n      throw new InvalidAmountException(&quot;...&quot;);\n    }\n    if (decreasedAmount.compareTo(this.balance) &gt; 0) {\n      throw new InsufficientAmountException(&quot;...&quot;);\n    }\n    this.balance.subtract(decreasedAmount);\n    this.balanceLastModifiedTime = System.currentTimeMillis();\n  }\n}\n</code></pre><p>从代码中，我们可以发现，Wallet类主要有四个属性（也可以叫作成员变量），也就是我们前面定义中提到的信息或者数据。其中，id表示钱包的唯一编号，createTime表示钱包创建的时间，balance表示钱包中的余额，balanceLastModifiedTime表示上次钱包余额变更的时间。</p><p>我们参照封装特性，对钱包的这四个属性的访问方式进行了限制。调用者只允许通过下面这六个方法来访问或者修改钱包里的数据。</p><ul>\n<li>String getId()</li>\n<li>long getCreateTime()</li>\n<li>BigDecimal getBalance()</li>\n<li>long getBalanceLastModifiedTime()</li>\n<li>void increaseBalance(BigDecimal increasedAmount)</li>\n<li>void decreaseBalance(BigDecimal decreasedAmount)</li>\n</ul><p>之所以这样设计，是因为从业务的角度来说，id、createTime在创建钱包的时候就确定好了，之后不应该再被改动，所以，我们并没有在Wallet类中，暴露id、createTime这两个属性的任何修改方法，比如set方法。而且，这两个属性的初始化设置，对于Wallet类的调用者来说，也应该是透明的，所以，我们在Wallet类的构造函数内部将其初始化设置好，而不是通过构造函数的参数来外部赋值。</p><p>对于钱包余额balance这个属性，从业务的角度来说，只能增或者减，不会被重新设置。所以，我们在Wallet类中，只暴露了increaseBalance()和decreaseBalance()方法，并没有暴露set方法。对于balanceLastModifiedTime这个属性，它完全是跟balance这个属性的修改操作绑定在一起的。只有在balance修改的时候，这个属性才会被修改。所以，我们把balanceLastModifiedTime这个属性的修改操作完全封装在了increaseBalance()和decreaseBalance()两个方法中，不对外暴露任何修改这个属性的方法和业务细节。这样也可以保证balance和balanceLastModifiedTime两个数据的一致性。</p><p>对于封装这个特性，我们需要编程语言本身提供一定的语法机制来支持。这个语法机制就是<strong>访问权限控制。</strong>例子中的private、public等关键字就是Java语言中的访问权限控制语法。private关键字修饰的属性只能类本身访问，可以保护其不被类之外的代码直接访问。如果Java语言没有提供访问权限控制语法，所有的属性默认都是public的，那任意外部代码都可以通过类似wallet.id=123;这样的方式直接访问、修改属性，也就没办法达到隐藏信息和保护数据的目的了，也就无法支持封装特性了。</p><p><strong>封装特性的定义讲完了，我们再来看一下，封装的意义是什么？它能解决什么编程问题？</strong></p><p>如果我们对类中属性的访问不做限制，那任何代码都可以访问、修改类中的属性，虽然这样看起来更加灵活，但从另一方面来说，过度灵活也意味着不可控，属性可以随意被以各种奇葩的方式修改，而且修改逻辑可能散落在代码中的各个角落，势必影响代码的可读性、可维护性。比如某个同事在不了解业务逻辑的情况下，在某段代码中“偷偷地”重设了wallet中的balanceLastModifiedTime属性，这就会导致balance和balanceLastModifiedTime两个数据不一致。</p><p>除此之外，类仅仅通过有限的方法暴露必要的操作，也能提高类的易用性。如果我们把类属性都暴露给类的调用者，调用者想要正确地操作这些属性，就势必要对业务细节有足够的了解。而这对于调用者来说也是一种负担。相反，如果我们将属性封装起来，暴露少许的几个必要的方法给调用者使用，调用者就不需要了解太多背后的业务细节，用错的概率就减少很多。这就好比，如果一个冰箱有很多按钮，你就要研究很长时间，还不一定能操作正确。相反，如果只有几个必要的按钮，比如开、停、调节温度，你一眼就能知道该如何来操作，而且操作出错的概率也会降低很多。</p><h2>抽象（Abstraction）</h2><p>讲完了封装特性，我们再来看抽象特性。 封装主要讲的是如何隐藏信息、保护数据，而抽象讲的是如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。</p><p>在面向对象编程中，我们常借助编程语言提供的接口类（比如Java中的interface关键字语法）或者抽象类（比如Java中的abstract关键字语法）这两种语法机制，来实现抽象这一特性。</p><p>这里我稍微说明一下，在专栏中，我们把编程语言提供的接口语法叫作“接口类”而不是“接口”。之所以这么做，是因为“接口”这个词太泛化，可以指好多概念，比如API接口等，所以，我们用“接口类”特指编程语言提供的接口语法。</p><p>对于抽象这个特性，我举一个例子来进一步解释一下。</p><pre><code>public interface IPictureStorage {\n  void savePicture(Picture picture);\n  Image getPicture(String pictureId);\n  void deletePicture(String pictureId);\n  void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo);\n}\n\npublic class PictureStorage implements IPictureStorage {\n  // ...省略其他属性...\n  @Override\n  public void savePicture(Picture picture) { ... }\n  @Override\n  public Image getPicture(String pictureId) { ... }\n  @Override\n  public void deletePicture(String pictureId) { ... }\n  @Override\n  public void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo) { ... }\n}\n</code></pre><p>在上面的这段代码中，我们利用Java中的interface接口语法来实现抽象特性。调用者在使用图片存储功能的时候，只需要了解IPictureStorage这个接口类暴露了哪些方法就可以了，不需要去查看PictureStorage类里的具体实现逻辑。</p><p>实际上，抽象这个特性是非常容易实现的，并不需要非得依靠接口类或者抽象类这些特殊语法机制来支持。换句话说，并不是说一定要为实现类（PictureStorage）抽象出接口类（IPictureStorage），才叫作抽象。即便不编写IPictureStorage接口类，单纯的PictureStorage类本身就满足抽象特性。</p><p>之所以这么说，那是因为，类的方法是通过编程语言中的“函数”这一语法机制来实现的。通过函数包裹具体的实现逻辑，这本身就是一种抽象。调用者在使用函数的时候，并不需要去研究函数内部的实现逻辑，只需要通过函数的命名、注释或者文档，了解其提供了什么功能，就可以直接使用了。比如，我们在使用C语言的malloc()函数的时候，并不需要了解它的底层代码是怎么实现的。</p><p>除此之外，在上一节课中，我们还提到，抽象有时候会被排除在面向对象的四大特性之外，当时我卖了一个关子，现在我就来解释一下为什么。</p><p>抽象这个概念是一个非常通用的设计思想，并不单单用在面向对象编程中，也可以用来指导架构设计等。而且这个特性也并不需要编程语言提供特殊的语法机制来支持，只需要提供“函数”这一非常基础的语法机制，就可以实现抽象特性、所以，它没有很强的“特异性”，有时候并不被看作面向对象编程的特性之一。</p><p><strong>抽象特性的定义讲完了，我们再来看一下，抽象的意义是什么？它能解决什么编程问题？</strong></p><p>实际上，如果上升一个思考层面的话，抽象及其前面讲到的封装都是人类处理复杂性的有效手段。在面对复杂系统的时候，人脑能承受的信息复杂程度是有限的，所以我们必须忽略掉一些非关键性的实现细节。而抽象作为一种只关注功能点不关注实现的设计思路，正好帮我们的大脑过滤掉许多非必要的信息。</p><p>除此之外，抽象作为一个非常宽泛的设计思想，在代码设计中，起到非常重要的指导作用。很多设计原则都体现了抽象这种设计思想，比如基于接口而非实现编程、开闭原则（对扩展开放、对修改关闭）、代码解耦（降低代码的耦合性）等。我们在讲到后面的内容的时候，会具体来解释。</p><p>换一个角度来考虑，我们在定义（或者叫命名）类的方法的时候，也要有抽象思维，不要在方法定义中，暴露太多的实现细节，以保证在某个时间点需要改变方法的实现逻辑的时候，不用去修改其定义。举个简单例子，比如getAliyunPictureUrl()就不是一个具有抽象思维的命名，因为某一天如果我们不再把图片存储在阿里云上，而是存储在私有云上，那这个命名也要随之被修改。相反，如果我们定义一个比较抽象的函数，比如叫作getPictureUrl()，那即便内部存储方式修改了，我们也不需要修改命名。</p><h2>继承（Inheritance）</h2><p>学习完了封装和抽象两个特性，我们再来看继承特性。如果你熟悉的是类似Java、C++这样的面向对象的编程语言，那你对继承这一特性，应该不陌生了。继承是用来表示类之间的is-a关系，比如猫是一种哺乳动物。从继承关系上来讲，继承可以分为两种模式，单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类，比如猫既是哺乳动物，又是爬行动物。</p><p>为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持，比如Java使用extends关键字来实现继承，C++使用冒号（class B : public A），Python使用parentheses ()，Ruby使用&lt;。不过，有些编程语言只支持单继承，不支持多重继承，比如Java、PHP、C#、Ruby等，而有些编程语言既支持单重继承，也支持多重继承，比如C++、Python、Perl等。</p><p>为什么有些语言支持多重继承，有些语言不支持呢？这个问题留给你自己去研究，你可以针对你熟悉的编程语言，在留言区写一写具体的原因。</p><p><strong>继承特性的定义讲完了，我们再来看，继承存在的意义是什么？它能解决什么编程问题？</strong></p><p>继承最大的一个好处就是代码复用。假如两个类有一些相同的属性和方法，我们就可以将这些相同的部分，抽取到父类中，让两个子类继承父类。这样，两个子类就可以重用父类中的代码，避免代码重复写多遍。不过，这一点也并不是继承所独有的，我们也可以通过其他方式来解决这个代码复用的问题，比如利用组合关系而不是继承关系。</p><p>如果我们再上升一个思维层面，去思考继承这一特性，可以这么理解：我们代码中有一个猫类，有一个哺乳动物类。猫属于哺乳动物，从人类认知的角度上来说，是一种is-a关系。我们通过继承来关联两个类，反应真实世界中的这种关系，非常符合人类的认知，而且，从设计的角度来说，也有一种结构美感。</p><p>继承的概念很好理解，也很容易使用。不过，过度使用继承，继承层次过深过复杂，就会导致代码可读性、可维护性变差。为了了解一个类的功能，我们不仅需要查看这个类的代码，还需要按照继承关系一层一层地往上查看“父类、父类的父类……”的代码。还有，子类和父类高度耦合，修改父类的代码，会直接影响到子类。</p><p>所以，继承这个特性也是一个非常有争议的特性。很多人觉得继承是一种反模式。我们应该尽量少用，甚至不用。关于这个问题，在后面讲到“多用组合少用继承”这种设计思想的时候，我会非常详细地再讲解，这里暂时就不展开讲解了。</p><h2>多态（Polymorphism）</h2><p>学习完了封装、抽象、继承之后，我们再来看面向对象编程的最后一个特性，多态。多态是指，子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。对于多态这种特性，纯文字解释不好理解，我们还是看一个具体的例子。</p><pre><code>public class DynamicArray {\n  private static final int DEFAULT_CAPACITY = 10;\n  protected int size = 0;\n  protected int capacity = DEFAULT_CAPACITY;\n  protected Integer[] elements = new Integer[DEFAULT_CAPACITY];\n  \n  public int size() { return this.size; }\n  public Integer get(int index) { return elements[index];}\n  //...省略n多方法...\n  \n  public void add(Integer e) {\n    ensureCapacity();\n    elements[size++] = e;\n  }\n  \n  protected void ensureCapacity() {\n    //...如果数组满了就扩容...代码省略...\n  }\n}\n\npublic class SortedDynamicArray extends DynamicArray {\n  @Override\n  public void add(Integer e) {\n    ensureCapacity();\n    int i;\n    for (i = size-1; i&gt;=0; --i) { //保证数组中的数据有序\n      if (elements[i] &gt; e) {\n        elements[i+1] = elements[i];\n      } else {\n        break;\n      }\n    }\n    elements[i+1] = e;\n    ++size;\n  }\n}\n\npublic class Example {\n  public static void test(DynamicArray dynamicArray) {\n    dynamicArray.add(5);\n    dynamicArray.add(1);\n    dynamicArray.add(3);\n    for (int i = 0; i &lt; dynamicArray.size(); ++i) {\n      System.out.println(dynamicArray.get(i));\n    }\n  }\n  \n  public static void main(String args[]) {\n    DynamicArray dynamicArray = new SortedDynamicArray();\n    test(dynamicArray); // 打印结果：1、3、5\n  }\n}\n</code></pre><p>多态这种特性也需要编程语言提供特殊的语法机制来实现。在上面的例子中，我们用到了三个语法机制来实现多态。</p><ul>\n<li>第一个语法机制是编程语言要支持父类对象可以引用子类对象，也就是可以将SortedDynamicArray传递给DynamicArray。</li>\n<li>第二个语法机制是编程语言要支持继承，也就是SortedDynamicArray继承了DynamicArray，才能将SortedDyamicArray传递给DynamicArray。</li>\n<li>第三个语法机制是编程语言要支持子类可以重写（override）父类中的方法，也就是SortedDyamicArray重写了DynamicArray中的add()方法。</li>\n</ul><p>通过这三种语法机制配合在一起，我们就实现了在test()方法中，子类SortedDyamicArray替换父类DynamicArray，执行子类SortedDyamicArray的add()方法，也就是实现了多态特性。</p><p>对于多态特性的实现方式，除了利用“继承加方法重写”这种实现方式之外，我们还有其他两种比较常见的的实现方式，一个是利用接口类语法，另一个是利用duck-typing语法。不过，并不是每种编程语言都支持接口类或者duck-typing这两种语法机制，比如C++就不支持接口类语法，而duck-typing只有一些动态语言才支持，比如Python、JavaScript等。</p><p><strong>接下来，我们先来看如何利用接口类来实现多态特性。</strong>我们还是先来看一段代码。</p><pre><code>public interface Iterator {\n  boolean hasNext();\n  String next();\n  String remove();\n}\n\npublic class Array implements Iterator {\n  private String[] data;\n  \n  public boolean hasNext() { ... }\n  public String next() { ... }\n  public String remove() { ... }\n  //...省略其他方法...\n}\n\npublic class LinkedList implements Iterator {\n  private LinkedListNode head;\n  \n  public boolean hasNext() { ... }\n  public String next() { ... }\n  public String remove() { ... }\n  //...省略其他方法... \n}\n\npublic class Demo {\n  private static void print(Iterator iterator) {\n    while (iterator.hasNext()) {\n      System.out.println(iterator.next());\n    }\n  }\n  \n  public static void main(String[] args) {\n    Iterator arrayIterator = new Array();\n    print(arrayIterator);\n    \n    Iterator linkedListIterator = new LinkedList();\n    print(linkedListIterator);\n  }\n}\n</code></pre><p>在这段代码中，Iterator是一个接口类，定义了一个可以遍历集合数据的迭代器。Array和LinkedList都实现了接口类Iterator。我们通过传递不同类型的实现类（Array、LinkedList）到print(Iterator iterator)函数中，支持动态的调用不同的next()、hasNext()实现。</p><p>具体点讲就是，当我们往print(Iterator iterator)函数传递Array类型的对象的时候，print(Iterator iterator)函数就会调用Array的next()、hasNext()的实现逻辑；当我们往print(Iterator iterator)函数传递LinkedList类型的对象的时候，print(Iterator iterator)函数就会调用LinkedList的next()、hasNext()的实现逻辑。</p><p><strong>刚刚讲的是用接口类来实现多态特性。现在，我们再来看下，如何用duck-typing来实现多态特性。</strong>我们还是先来看一段代码。这是一段Python代码。</p><pre><code>class Logger:\n    def record(self):\n        print(“I write a log into file.”)\n        \nclass DB:\n    def record(self):\n        print(“I insert data into db. ”)\n        \ndef test(recorder):\n    recorder.record()\n\ndef demo():\n    logger = Logger()\n    db = DB()\n    test(logger)\n    test(db)\n</code></pre><p>从这段代码中，我们发现，duck-typing实现多态的方式非常灵活。Logger和DB两个类没有任何关系，既不是继承关系，也不是接口和实现的关系，但是只要它们都有定义了record()方法，就可以被传递到test()方法中，在实际运行的时候，执行对应的record()方法。</p><p>也就是说，只要两个类具有相同的方法，就可以实现多态，并不要求两个类之间有任何关系，这就是所谓的duck-typing，是一些动态语言所特有的语法机制。而像Java这样的静态语言，通过继承实现多态特性，必须要求两个类之间有继承关系，通过接口实现多态特性，类必须实现对应的接口。</p><p><strong>多态特性讲完了，我们再来看，多态特性存在的意义是什么？它能解决什么编程问题？</strong></p><p>多态特性能提高代码的可扩展性和复用性。为什么这么说呢？我们回过头去看讲解多态特性的时候，举的第二个代码实例（Iterator的例子）。</p><p>在那个例子中，我们利用多态的特性，仅用一个print()函数就可以实现遍历打印不同类型（Array、LinkedList）集合的数据。当再增加一种要遍历打印的类型的时候，比如HashMap，我们只需让HashMap实现Iterator接口，重新实现自己的hasNext()、next()等方法就可以了，完全不需要改动print()函数的代码。所以说，多态提高了代码的可扩展性。</p><p>如果我们不使用多态特性，我们就无法将不同的集合类型（Array、LinkedList）传递给相同的函数（print(Iterator iterator)函数）。我们需要针对每种要遍历打印的集合，分别实现不同的print()函数，比如针对Array，我们要实现print(Array array)函数，针对LinkedList，我们要实现print(LinkedList linkedList)函数。而利用多态特性，我们只需要实现一个print()函数的打印逻辑，就能应对各种集合数据的打印操作，这显然提高了代码的复用性。</p><p>除此之外，多态也是很多设计模式、设计原则、编程技巧的代码实现基础，比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的if-else语句等等。关于这点，在学习后面的章节中，你慢慢会有更深的体会。</p><h2>重点回顾</h2><p>今天的内容就讲完了，我们来一起总结回顾一下，你需要重点掌握的几个知识点。</p><p><strong>1.关于封装特性</strong></p><p>封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。它需要编程语言提供权限访问控制语法来支持，例如Java中的private、protected、public关键字。封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。</p><p><strong>2.关于抽象特性</strong></p><p>封装主要讲如何隐藏信息、保护数据，那抽象就是讲如何隐藏方法的具体实现，让使用者只需要关心方法提供了哪些功能，不需要知道这些功能是如何实现的。抽象可以通过接口类或者抽象类来实现，但也并不需要特殊的语法机制来支持。抽象存在的意义，一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。</p><p><strong>3.关于继承特性</strong></p><p>继承是用来表示类之间的is-a关系，分为两种模式：单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类。为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持。继承主要是用来解决代码复用的问题。</p><p><strong>4.关于多态特性</strong></p><p>多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类、duck-typing。多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。</p><h2>课堂讨论</h2><p>今天我们要讨论的话题有如下两个。</p><ol>\n<li>你熟悉的编程语言是否支持多重继承？如果不支持，请说一下为什么不支持。如果支持，请说一下它是如何避免多重继承的副作用的。</li>\n<li>你熟悉的编程语言对于四大特性是否都有现成的语法支持？对于支持的特性，是通过什么语法机制实现的？对于不支持的特性，又是基于什么原因做的取舍？</li>\n</ol><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>","neighbors":{"left":{"article_title":"04 | 理论一：当谈论面向对象的时候，我们到底在谈论什么？","id":161575},"right":{"article_title":"06 | 理论三：面向对象相比面向过程有哪些优势？面向过程真的过时了吗？","id":161587}},"comments":[{"had_liked":false,"id":151303,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1573697652,"is_pvip":false,"discussion_count":36,"race_medal":0,"score":"5400347588724","product_id":100039001,"comment_content":"争哥对面向对象的总结完美符合 What&#47;How&#47;Why 模型，我按照模型作下梳理。<br><br>## 封装<br>What：隐藏信息，保护数据访问。<br>How：暴露有限接口和属性，需要编程语言提供访问控制的语法。<br>Why：提高代码可维护性；降低接口复杂度，提高类的易用性。<br><br>##抽象<br>What: 隐藏具体实现，使用者只需关心功能，无需关心实现。<br>How: 通过接口类或者抽象类实现，特殊语法机制非必须。<br>Why: 提高代码的扩展性、维护性；降低复杂度，减少细节负担。<br><br>##继承<br>What: 表示 is-a 关系，分为单继承和多继承。<br>How: 需要编程语言提供特殊语法机制。例如 Java 的 “extends”，C++ 的 “:” 。<br>Why: 解决代码复用问题。<br><br>##多态<br>What: 子类替换父类，在运行时调用子类的实现。<br>How: 需要编程语言提供特殊的语法机制。比如继承、接口类、duck-typing。<br>Why: 提高代码扩展性和复用性。<br><br>3W 模型的关键在于 Why，没有 Why，其它两个就没有存在的意义。从四大特性可以看出，面向对象的终极目的只有一个：可维护性。易扩展、易复用，降低复杂度等等都属于可维护性的实现方式。<br>","like_count":1258,"discussions":[{"author":{"id":1220713,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a0/69/e42348a8.jpg","nickname":"李奇锋","note":"","ucode":"1A0A359D0530C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":355842,"discussion_content":"我倒是觉得降低复杂度才是关键目的，其他性质都是为其服务。\n\n只要代码不复杂，你就能理解它的逻辑，自然而然就能够维护好。\n\n以复用性为例，只要代码能复用，就意味着你需要记忆的内容/概念就减少，复杂度自然就低。\n\n以可扩展性为例，好的扩展自然不应该增加过多的复杂度。如果扩展功能需要添加过多的复杂度，那么就证明这个系统本身的可扩展性不佳。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1615479412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1264707,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4c/43/150c70c2.jpg","nickname":"陈松Plus","note":"","ucode":"0074BDECFA3D1D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363056,"discussion_content":"每个专栏总有课代表","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1617105267,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005574,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/58/06/6a9c089b.jpg","nickname":"Lee大树","note":"","ucode":"3C2012F6D21698","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325068,"discussion_content":"赞","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1605231174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1283461,"avatar":"https://static001.geekbang.org/account/avatar/00/13/95/85/15cd21c2.jpg","nickname":"杨锋","note":"","ucode":"85A7828A538FB0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284848,"discussion_content":"你就是那个科代表","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1592659765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1272047,"avatar":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","nickname":"Magic","note":"","ucode":"FD9CEDAA419EB0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308067,"discussion_content":"3why还有个高大上的名字-黄金圈法则","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600837049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1921287,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/51/07/b5a945b6.jpg","nickname":"Nick","note":"","ucode":"64BBE005890845","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":209255,"discussion_content":"总结的非常棒，关键是Why","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584623690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1203255,"avatar":"https://static001.geekbang.org/account/avatar/00/12/5c/37/de2649c3.jpg","nickname":"麦田守望者","note":"","ucode":"F4F0CCB787A420","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576824,"discussion_content":"高手","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655799818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2870321,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLE9hv64CEabxt76tQQcWDicx0sucpAApFvYoM8eXBViaJgz06EjcfJjiamSFWY9aAuxjILaPoiaa0lNw/132","nickname":"Soil","note":"","ucode":"3B353BC858B5AE","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557447,"discussion_content":"总结的很不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647825198,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2550743,"avatar":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","nickname":"if...else...","note":"","ucode":"D0565908C99695","race_medal":4,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376948,"discussion_content":"总结的很好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622435427,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2242904,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIHxTg3tYriaCXiccCf7xUl9QHibAhCMBKQ2oCicvgcuHCo4ULSguISXeHzxM9a8fFD7icfy3OgXibvUNxw/132","nickname":"Geek_9dbc25","note":"","ucode":"6CB31893173165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368843,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618843210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1098624,"avatar":"","nickname":"dream7519","note":"","ucode":"55E229FA55E15C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339468,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609682056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2400676,"avatar":"https://static001.geekbang.org/account/avatar/00/24/a1/a4/4def335a.jpg","nickname":"刘玉琪","note":"","ucode":"9CAFC96E725F12","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339186,"discussion_content":"棒，我抄个作业。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609557198,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2347137,"avatar":"https://static001.geekbang.org/account/avatar/00/23/d0/81/d5c8e46e.jpg","nickname":"snake","note":"","ucode":"47BFFE4D048156","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330878,"discussion_content":"已经收藏，总结的很好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606725819,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2347137,"avatar":"https://static001.geekbang.org/account/avatar/00/23/d0/81/d5c8e46e.jpg","nickname":"snake","note":"","ucode":"47BFFE4D048156","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330875,"discussion_content":"人才","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606724996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2323679,"avatar":"https://static001.geekbang.org/account/avatar/00/23/74/df/6c4c970c.jpg","nickname":"刘胜","note":"","ucode":"2ED796A94E1C8B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327557,"discussion_content":"课代表。总结真的很赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605861088,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1509295,"avatar":"https://static001.geekbang.org/account/avatar/00/17/07/af/d6215ca0.jpg","nickname":"智昊","note":"","ucode":"3F263C553B34F1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308105,"discussion_content":"课代表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600846920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1792214,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoiaP1gptuBzj3AXMpY8yLTIkpuarouOVzLde4636UJ7zAgnOEZibiaAIRVAicFaO64ftH45YOn1pD3VA/132","nickname":"Geek_35cfdd","note":"","ucode":"AD9615ABB4CA25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301179,"discussion_content":"关于封装是降低接口的复杂度么？我咋么感觉是降低使用者的复杂度。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598433777,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1272047,"avatar":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","nickname":"Magic","note":"","ucode":"FD9CEDAA419EB0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1792214,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoiaP1gptuBzj3AXMpY8yLTIkpuarouOVzLde4636UJ7zAgnOEZibiaAIRVAicFaO64ftH45YOn1pD3VA/132","nickname":"Geek_35cfdd","note":"","ucode":"AD9615ABB4CA25","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308068,"discussion_content":"应该是控制代码的复杂度","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600837070,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301179,"ip_address":""},"score":308068,"extra":""}]},{"author":{"id":1731082,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/6a/0a/45562844.jpg","nickname":"小玉家的猫","note":"","ucode":"ACA36922F22B69","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297820,"discussion_content":"封装，抽象，继承，多态为了代码可维护性！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597067412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1118111,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","nickname":"见南山","note":"","ucode":"6A8BB82B7573CA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285190,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592757308,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1398824,"avatar":"https://static001.geekbang.org/account/avatar/00/15/58/28/c86340ca.jpg","nickname":"达文西","note":"","ucode":"01C1063F23D634","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263990,"discussion_content":"666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589276902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1582951,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqrSGol9ss3nzh6Hqj2BYxBTlYbhSe72Og6Vx5CSb5iboibL9xZdWdYOpZzmN2ibj9EpboNDdRBSXSZw/132","nickname":"张张先生","note":"","ucode":"91B0E84B47AF05","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":246869,"discussion_content":"总结的好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587783367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1311947,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/xysT7OH4SrD4sv944ndDv5tnJOk5na37Gxd5owGWsE7ON7AVW0ibnYGNRoZd0ibLWhFVXLLjOB5QFxwjo0EGIkoQ/132","nickname":"雨下不停","note":"","ucode":"0893B9C249E48A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":229763,"discussion_content":"说得好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586688883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1104310,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d9/b6/4c498c17.jpg","nickname":"1620","note":"","ucode":"C9222A5CE4723C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":224687,"discussion_content":"留爪👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586323237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1096261,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ba/45/6722444c.jpg","nickname":"D","note":"","ucode":"248B90F19469A8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":216559,"discussion_content":"赞啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585464038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1622209,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c0/c1/414d5d1b.jpg","nickname":"_yh葱","note":"","ucode":"FA899711E91113","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":190258,"discussion_content":"总结的真好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582910572,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1037667,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d5/63/c4e2e579.jpg","nickname":"醉流年","note":"","ucode":"B8788E1B335322","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":181279,"discussion_content":"真的很赞👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582353784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1073216,"avatar":"https://static001.geekbang.org/account/avatar/00/10/60/40/d7e2e5b9.jpg","nickname":"宋江超","note":"","ucode":"565622DD8E36DF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":180540,"discussion_content":"黄金思维圈在面向对象的案例👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582296552,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1400962,"avatar":"https://static001.geekbang.org/account/avatar/00/15/60/82/9a43504b.jpg","nickname":"[耶]友超","note":"","ucode":"890572F77C3670","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":108030,"discussion_content":"大佬，收下我的👍👍👍👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577622195,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1310798,"avatar":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","nickname":"吴小智","note":"","ucode":"C7C9F58B5C9F7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84561,"discussion_content":"强了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576501113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1156383,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/OokHAy1fSOhBwwbbzud7seB5MEk4JezcGCS4Tzia7iaLOibCKgrj6PCN2b17bVAb224ygdLgjWVMnZsH18ibNoSTVA/132","nickname":"澜奏","note":"","ucode":"8682168E18B068","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":61018,"discussion_content":"这个总结真棒棒👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574769784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1199982,"avatar":"https://static001.geekbang.org/account/avatar/00/12/4f/6e/c8862883.jpg","nickname":"水雕歌","note":"","ucode":"280FAE14574299","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":58430,"discussion_content":"总结的很好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574675351,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1698258,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIx7FdRzUuQf4Fopr7DOXEHZyCFfH4GQViaqo7bymf1qaANcOvuEhHyTNwOOUFW7psxEeSQ5k9uXWw/132","nickname":"阿顺","note":"","ucode":"36F2AD6F980B11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55737,"discussion_content":"tql","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574393081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1429627,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJN64OCUT0Jp0h2Wiau9Os0o1WbwUeoq2QL0U2vZpib8ozPxo0XDiaPM9xcKfbkoBL24ztEHelxPIMVg/132","nickname":"Kevin","note":"","ucode":"9DFFD6E3960CF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53102,"discussion_content":"人均大师水平","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574132754,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1443365,"avatar":"https://static001.geekbang.org/account/avatar/00/16/06/25/5461385f.jpg","nickname":"学无止境0033","note":"","ucode":"6332DA0B9FF989","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52394,"discussion_content":"很赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574047011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015483,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","nickname":"程序员小跃","note":"","ucode":"25BB96E0791A60","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51541,"discussion_content":"总结的很赞，我要把这个收藏起来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573894918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150713,"user_name":"№修罗★幻影","can_delete":false,"product_type":"c1","uid":1010302,"ip_address":"","ucode":"FF89FB2C584833","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6a/7e/a6af4c00.jpg","comment_is_top":false,"comment_ctime":1573604430,"is_pvip":false,"discussion_count":24,"race_medal":0,"score":"2118992481358","product_id":100039001,"comment_content":"Java 不支持多重继承的原因<br>多重继承有副作用：钻石问题(菱形继承)。<br>假设类 B 和类 C 继承自类 A，且都重写了类 A 中的同一个方法，而类 D 同时继承了类 B 和类 C，那么此时类 D 会继承 B、C 的方法，那对于 B、C 重写的 A 中的方法，类 D 会继承哪一个呢？这里就会产生歧义。<br>考虑到这种二义性问题，Java 不支持多重继承。但是 Java 支持多接口实现，因为接口中的方法，是抽象的（从JDK1.8之后，接口中允许给出一些默认方法的实现，这里不考虑这个），就算一个类实现了多个接口，且这些接口中存在某个同名方法，但是我们在实现接口的时候，这个同名方法需要由我们这个实现类自己来实现，所以并不会出现二义性的问题。","like_count":493,"discussions":[{"author":{"id":1555182,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/ee/2a08e563.jpg","nickname":"MF","note":"","ucode":"1EF5C43CAD373A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56403,"discussion_content":"多继承接口类如果某个接口有默认方法，也需要重写默认方法，所以也不会造成二义性。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1574478189,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":98188,"discussion_content":"多个接口中方法就算返回值，参数，方法名一样，编译器只会让你实现一个，所以不会有歧义的问题","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1577149233,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2683430,"avatar":"https://static001.geekbang.org/account/avatar/00/28/f2/26/a8ac6b42.jpg","nickname":"听风有信","note":"","ucode":"2CCB467114FF5C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575196,"discussion_content":"返回值不一样的时候呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654662204,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":98188,"ip_address":""},"score":575196,"extra":""}]},{"author":{"id":1463023,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLbchZfeEnshPuUwEsQkn1XbWxjs3rRUpSRUxjW4q7rOcrPvXld0IxEZ1jlpEJdklFeEVERJoOfibg/132","nickname":"qf年间","note":"","ucode":"AA08AC984637EE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342180,"discussion_content":"有一种方法可以extends 超类 implements 接口","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1610607872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1676247,"avatar":"https://static001.geekbang.org/account/avatar/00/19/93/d7/93c8f92a.jpg","nickname":"斜杠ing...","note":"","ucode":"C4AE866AC8B9AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50800,"discussion_content":"学习到了，谢谢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573776213,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1244288,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fc/80/21d67b9b.jpg","nickname":"二狗","note":"","ucode":"91C38887F4F07B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49551,"discussion_content":"多继承同名方法重写不就好了  不客观","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573612472,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1010302,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/6a/7e/a6af4c00.jpg","nickname":"№修罗★幻影","note":"","ucode":"FF89FB2C584833","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1244288,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fc/80/21d67b9b.jpg","nickname":"二狗","note":"","ucode":"91C38887F4F07B","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":50021,"discussion_content":"如果不是声明为抽象方法，子类没有强制要求必须重写父类同名方法吧，那如果D没有对同名方法进行重写，那执行过程就会有问题了吧？当然你说的没错，子类重写了就OK(JDK8开始允许接口方法有默认实现，所以一旦出现这种钻石问题，编译器会强制实现类重写default 方法来消除二义性)","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1573656888,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":49551,"ip_address":""},"score":50021,"extra":""}]},{"author":{"id":2821728,"avatar":"","nickname":"600988292","note":"","ucode":"24BAE2B7A7B1E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558449,"discussion_content":"🐮","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648302999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1287406,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a4/ee/b960a322.jpg","nickname":"mihello","note":"","ucode":"4B1E7B7A141606","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553205,"discussion_content":"Python通过c3算法解决菱形问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645766161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1194060,"avatar":"https://static001.geekbang.org/account/avatar/00/12/38/4c/5426e2e0.jpg","nickname":"CJJ","note":"","ucode":"7E02A6A8547559","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347575,"discussion_content":"学到了谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612260241,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1152044,"avatar":"https://static001.geekbang.org/account/avatar/00/11/94/2c/19b0d10e.jpg","nickname":"鸵鸟","note":"","ucode":"D05C161DA4EF33","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297906,"discussion_content":"Java 8 的接口方法可以有默认的实现，这算不算多继承呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597109495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1010302,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/6a/7e/a6af4c00.jpg","nickname":"№修罗★幻影","note":"","ucode":"FF89FB2C584833","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1152044,"avatar":"https://static001.geekbang.org/account/avatar/00/11/94/2c/19b0d10e.jpg","nickname":"鸵鸟","note":"","ucode":"D05C161DA4EF33","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299707,"discussion_content":"多继承接口类如果某个接口有默认方法，编译器会要求你重写默认方法，所以也不会造成二义性","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1597793689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":297906,"ip_address":""},"score":299707,"extra":""},{"author":{"id":1030242,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/62/60937bbd.jpg","nickname":"逗你玩😄","note":"","ucode":"2E6309586B0363","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1152044,"avatar":"https://static001.geekbang.org/account/avatar/00/11/94/2c/19b0d10e.jpg","nickname":"鸵鸟","note":"","ucode":"D05C161DA4EF33","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":401437,"discussion_content":"不算，如果有实现类则用实现类的方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633669104,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":297906,"ip_address":""},"score":401437,"extra":""}]},{"author":{"id":1068193,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4c/a1/40b75a55.jpg","nickname":"LeoBing","note":"","ucode":"3964DA5DBFBE46","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295852,"discussion_content":"多接口情况下，同名方法实现一个就可以了吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596367289,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2092069,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKq0oQVibKcmYEy6MJ6GnLoXFMpicjLKT2AjO2h95UwZBcibAzkXibQrxhcpwN4JBIuEJ90UdiayI8kYjQ/132","nickname":"Geek_54624e","note":"","ucode":"A031A889D3C3FF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295333,"discussion_content":"高手啊，那一般支持多继承的语言是如何解决钻石问题的呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596166650,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1631921,"avatar":"","nickname":"jarryLee","note":"","ucode":"1392ED306DA5F2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2092069,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKq0oQVibKcmYEy6MJ6GnLoXFMpicjLKT2AjO2h95UwZBcibAzkXibQrxhcpwN4JBIuEJ90UdiayI8kYjQ/132","nickname":"Geek_54624e","note":"","ucode":"A031A889D3C3FF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341517,"discussion_content":"c++中是通过虚继承","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610444007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":295333,"ip_address":""},"score":341517,"extra":""}]},{"author":{"id":1394822,"avatar":"https://static001.geekbang.org/account/avatar/00/15/48/86/54c68afe.jpg","nickname":"铁男神sama","note":"","ucode":"0A3E3E61D36EDE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":63857,"discussion_content":"谢感谢分享","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574916925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134861,"avatar":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","nickname":"James","note":"","ucode":"48B0F2A334D1C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53439,"discussion_content":"学习了🐶🐶🐶","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574168861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1036972,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d2/ac/aeb9f156.jpg","nickname":"吖蒲","note":"","ucode":"397C5DA20D5693","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52398,"discussion_content":"学习了，谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574047273,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1210699,"avatar":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","nickname":"-W.LI-","note":"","ucode":"3556786538664F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50035,"discussion_content":"多继承感觉类加载都不好搞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573657905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1034977,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ca/e1/d8537537.jpg","nickname":"梁😜","note":"","ucode":"078473C50B802B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49784,"discussion_content":"学习了！ 还想问一下 C++ 是如何处理菱形继承的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573636699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1010302,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/6a/7e/a6af4c00.jpg","nickname":"№修罗★幻影","note":"","ucode":"FF89FB2C584833","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1034977,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ca/e1/d8537537.jpg","nickname":"梁😜","note":"","ucode":"078473C50B802B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50012,"discussion_content":"C++不是很了解，好像可以用虚继承的方式来规避？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573656513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":49784,"ip_address":""},"score":50012,"extra":""}]},{"author":{"id":1731625,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/6c/29/38ddc1ce.jpg","nickname":"雨季不再来","note":"","ucode":"74DBBB8E525067","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49550,"discussion_content":"学习了！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573612365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1346215,"avatar":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","nickname":"William","note":"","ucode":"55F5D9DEE485B1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49516,"discussion_content":"学习了，谢谢.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573608010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151160,"user_name":"拉格朗日的忧桑","can_delete":false,"product_type":"c1","uid":1312991,"ip_address":"","ucode":"5FCB2C6616E113","user_header":"https://static001.geekbang.org/account/avatar/00/14/08/df/4e5c2b29.jpg","comment_is_top":false,"comment_ctime":1573659334,"is_pvip":false,"replies":[{"id":"58189","content":"😄 多谢认可","user_name":"作者回复","comment_id":151160,"uid":"1190123","ip_address":"","utype":1,"ctime":1573690566,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"542739538630","product_id":100039001,"comment_content":"这是迄今讲面向对象特性最深刻的，没有之一","like_count":126,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474387,"discussion_content":"😄 多谢认可","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573690566,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1337016,"avatar":"https://static001.geekbang.org/account/avatar/00/14/66/b8/ece79234.jpg","nickname":"王智","note":"","ucode":"37D2AD591C1AEC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535091,"discussion_content":"我觉得也很好。读完豁然开朗，如饮美酒！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638349826,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150959,"user_name":"小学一年级","can_delete":false,"product_type":"c1","uid":1217230,"ip_address":"","ucode":"59B9805D7C2D92","user_header":"https://static001.geekbang.org/account/avatar/00/12/92/ce/9d24cb2c.jpg","comment_is_top":false,"comment_ctime":1573635038,"is_pvip":false,"discussion_count":22,"race_medal":0,"score":"362350887902","product_id":100039001,"comment_content":"我理解的四大特性<br>封装：加装备（添加盔甲）<br>继承：师傅掌对掌传输武功（毫无保留）<br>抽象：从道到术，柳叶能伤人<br>多态：奥特曼变身。","like_count":84,"discussions":[{"author":{"id":1575571,"avatar":"https://static001.geekbang.org/account/avatar/00/18/0a/93/a189ec16.jpg","nickname":"Eric","note":"","ucode":"7EB511C384BD7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60868,"discussion_content":"谁说的继承是毫无保留？","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1574761113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1217230,"avatar":"https://static001.geekbang.org/account/avatar/00/12/92/ce/9d24cb2c.jpg","nickname":"小学一年级","note":"","ucode":"59B9805D7C2D92","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1575571,"avatar":"https://static001.geekbang.org/account/avatar/00/18/0a/93/a189ec16.jpg","nickname":"Eric","note":"","ucode":"7EB511C384BD7B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":61239,"discussion_content":"是的，私有属性不能被继承","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574776109,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":60868,"ip_address":""},"score":61239,"extra":""},{"author":{"id":2015438,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/c0/ce/eb1b4ae1.jpg","nickname":"可圈可丶","note":"","ucode":"EB527E176EDE91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1217230,"avatar":"https://static001.geekbang.org/account/avatar/00/12/92/ce/9d24cb2c.jpg","nickname":"小学一年级","note":"","ucode":"59B9805D7C2D92","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287573,"discussion_content":"错，继承就是毫无保留。子类的确不能访问父类的private属性和方法，但是Oracle官方文档明确说明了，子类会继承父类的一切，包括private属性和方法，只是不能不能访问","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1593484241,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":61239,"ip_address":""},"score":287573,"extra":""},{"author":{"id":1076100,"avatar":"https://static001.geekbang.org/account/avatar/00/10/6b/84/d1e6eac9.jpg","nickname":"sun","note":"","ucode":"0358B9288D4018","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1217230,"avatar":"https://static001.geekbang.org/account/avatar/00/12/92/ce/9d24cb2c.jpg","nickname":"小学一年级","note":"","ucode":"59B9805D7C2D92","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294811,"discussion_content":"继承其实是继承所有,只不过被约束了, 子类在初始化的时候,会为父类的私有变量分配内存空间","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1596007271,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":61239,"ip_address":""},"score":294811,"extra":""}]},{"author":{"id":1625651,"avatar":"https://static001.geekbang.org/account/avatar/00/18/ce/33/09498236.jpg","nickname":"Geek_1b6022","note":"","ucode":"EBDDEF36DE58DF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51424,"discussion_content":"兄弟，考不考虑写小说？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1573869887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2646147,"avatar":"","nickname":"Geek_814a71","note":"","ucode":"95FCEB5F80F72F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377196,"discussion_content":"奥特曼变身有点东西啊，让我想到了迪迦的红色，迪迦的蓝色形态","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1622544678,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1337340,"avatar":"https://static001.geekbang.org/account/avatar/00/14/67/fc/e4ee44b7.jpg","nickname":"B","note":"","ucode":"542EE1046B116B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":110920,"discussion_content":"由道到术？是不是反了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577765894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1156383,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/OokHAy1fSOhBwwbbzud7seB5MEk4JezcGCS4Tzia7iaLOibCKgrj6PCN2b17bVAb224ygdLgjWVMnZsH18ibNoSTVA/132","nickname":"澜奏","note":"","ucode":"8682168E18B068","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":61020,"discussion_content":"兄弟，你这个有点萌萌哒了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574769804,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1314724,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0f/a4/0b49469f.jpg","nickname":"木子00","note":"","ucode":"8F78CA722EB29B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52512,"discussion_content":"理解独到！ ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574058248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2791307,"avatar":"","nickname":"Geek6444","note":"","ucode":"D06CCF0EC1CAC4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400315,"discussion_content":"高人往往能把复杂的事情用平常人都能听懂的方式说出来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633231871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2402804,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/ia09eNhQrdiarpkkjquBc4WMADuEqSJEBgjiaOM9Cdsp5jORM36k3GO1cGJWkGgkCB1qPwpibXK8gNibiaOrMibtYQYVg/132","nickname":"Geek_427070","note":"","ucode":"8BBD98625AF249","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360976,"discussion_content":"你在说啥？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616572042,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2026729,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/hh0DgEGDicER5svooZUPEFUNiaQibbFYVCSZeUcUlIawBiaOKwA0nqnWbmc23cPdevtEODTibqpQ5yUsG57s3jWl0nQ/132","nickname":"Geek_51f16a","note":"","ucode":"44FDD7C940207E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":356436,"discussion_content":"比比瞎","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615599327,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1240321,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ed/01/997432f3.jpg","nickname":"喜笑延开","note":"","ucode":"DBF645D2129460","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347144,"discussion_content":"NB","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612163908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1026832,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ab/10/b812ff3e.jpg","nickname":"Hesher","note":"","ucode":"99AB8B1704CB7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297885,"discussion_content":"什么鬼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597101780,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134517,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4f/b5/e0bb3efe.jpg","nickname":"晗晗","note":"","ucode":"93C812E7E5AA75","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287870,"discussion_content":"哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593574490,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1488356,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b5/e4/e6faf686.jpg","nickname":"握了个大蚂蚱","note":"","ucode":"AD34AD4FA37371","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284100,"discussion_content":"泥在说什么飞机","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592445228,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1958147,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/e1/03/f937e673.jpg","nickname":"🍀","note":"","ucode":"60E0AC2A55B63B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":268481,"discussion_content":"快把他抬走","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589788855,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1298790,"avatar":"https://static001.geekbang.org/account/avatar/00/13/d1/66/db125960.jpg","nickname":"urbane","note":"","ucode":"F2BA3E97327003","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55074,"discussion_content":"瞎比比","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574337639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1028961,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b3/61/e08899fe.jpg","nickname":"Jimmy","note":"","ucode":"A3DEB98CDD03B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53942,"discussion_content":"不要瞎理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574239110,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1122963,"avatar":"https://static001.geekbang.org/account/avatar/00/11/22/93/d02d1d3d.jpg","nickname":"树树树树树华","note":"","ucode":"0A24FF3AE00A4C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53486,"discussion_content":"天呐，我看一眼就感觉懂了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574171893,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1027189,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ac/75/002720a4.jpg","nickname":"mylikey","note":"","ucode":"8558D33CBEA3C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53407,"discussion_content":"大佬们，为啥多态是奥特曼变身？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574166272,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1346309,"avatar":"https://static001.geekbang.org/account/avatar/00/14/8b/05/3315b855.jpg","nickname":"Neuject","note":"","ucode":"4DCFF6CDC4186E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1027189,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ac/75/002720a4.jpg","nickname":"mylikey","note":"","ucode":"8558D33CBEA3C1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":91134,"discussion_content":"一个“变身”的执行，可以根据本质变身成不同的奥特曼。奥特曼就是接口，各种迪加奥特曼啊雷欧奥特曼啊啥的都是继承了这个接口的类，执行相同的内容可以产生多种状态，即多态性","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576812182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53407,"ip_address":""},"score":91134,"extra":""}]}]},{"had_liked":false,"id":151249,"user_name":"猫切切切切切","can_delete":false,"product_type":"c1","uid":1075033,"ip_address":"","ucode":"F350BA1B7FFDC4","user_header":"https://static001.geekbang.org/account/avatar/00/10/67/59/017b5726.jpg","comment_is_top":false,"comment_ctime":1573691584,"is_pvip":true,"discussion_count":9,"race_medal":0,"score":"319401271488","product_id":100039001,"comment_content":"封装隐藏属性<br>抽象隐藏方法<br>继承支持复用<br>多态支持扩展","like_count":74,"discussions":[{"author":{"id":1242602,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f5/ea/5f046856.jpg","nickname":"Dale","note":"","ucode":"AD19A33FE5EEDF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387112,"discussion_content":"感觉“封装隐藏属性，抽象隐藏方法”不太合理，感觉“封装控制访问，抽象隐藏实现”可能更贴切","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1627992128,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1150022,"avatar":"https://static001.geekbang.org/account/avatar/00/11/8c/46/dbf8eb8a.jpg","nickname":"kelly","note":"","ucode":"B1DFA3D7340869","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278207,"discussion_content":"瞎理解别误人子弟，封装难道不能隐藏方法？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591161510,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1075033,"avatar":"https://static001.geekbang.org/account/avatar/00/10/67/59/017b5726.jpg","nickname":"猫切切切切切","note":"","ucode":"F350BA1B7FFDC4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1150022,"avatar":"https://static001.geekbang.org/account/avatar/00/11/8c/46/dbf8eb8a.jpg","nickname":"kelly","note":"","ucode":"B1DFA3D7340869","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":280239,"discussion_content":"只是提出个人看法接收批评，并不打算接收子弟","likes_number":16,"is_delete":false,"is_hidden":false,"ctime":1591516839,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":278207,"ip_address":""},"score":280239,"extra":""}]},{"author":{"id":2929950,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/8udden1kRL4giajiaeIWZFQExRq3w9QLEicx3UUf3col1JiaxKLWM5oy4ch1yqH8XjVGL4iaLRKYHPe2WJyy1WP1ELg/132","nickname":"Geek_2a844d","note":"","ucode":"99F34F8A700308","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554373,"discussion_content":"不错😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646359640,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1623117,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c4/4d/85014aab.jpg","nickname":"一叉树","note":"","ucode":"BFC984403ACD1F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338649,"discussion_content":"非常精辟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609330871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2153943,"avatar":"https://static001.geekbang.org/account/avatar/00/20/dd/d7/885e4ce3.jpg","nickname":"Am0xil","note":"","ucode":"CE2A04F9FF9FE6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336714,"discussion_content":"表示赞同，以我粗浅的理解，封装本身就是为了保护类中的重要属性在程序中不被随意修改，而必须要通过定义的set方法。实在看不懂评论区的有些人，筷子本身就是用来吃饭的，他非要问，筷子为啥不能用来夹其他东西","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608685621,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1958147,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/e1/03/f937e673.jpg","nickname":"🍀","note":"","ucode":"60E0AC2A55B63B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":268485,"discussion_content":"好的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589789109,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181647,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/cf/b0d6fe74.jpg","nickname":"L.","note":"","ucode":"46A2F679C094E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":229624,"discussion_content":"精辟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586675159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1007385,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5f/19/70d74403.jpg","nickname":"王志祥","note":"","ucode":"F3D2CBDA07E143","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1181647,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/cf/b0d6fe74.jpg","nickname":"L.","note":"","ucode":"46A2F679C094E8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":231767,"discussion_content":"同意楼上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586828536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":229624,"ip_address":""},"score":231767,"extra":""}]}]},{"had_liked":false,"id":151518,"user_name":"丁丁历险记","can_delete":false,"product_type":"c1","uid":1661704,"ip_address":"","ucode":"A43829E454C067","user_header":"https://static001.geekbang.org/account/avatar/00/19/5b/08/b0b0db05.jpg","comment_is_top":false,"comment_ctime":1573734752,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"242091903328","product_id":100039001,"comment_content":"好久没复杂这些基础知识了，借今天写笔记的时间过足瘾。我就菜鸟一个，也深知言多必失，肯定有瞎扯的地方，还请指正，我好迭代。<br>1 封装 <br>常见编程语言通过 public protected privite  来支持<br>封装的意义 。<br>关掉直接操作数据的口子，让数据的修改更贴合真实业务。<br>例如：创建时间，就没有修改数据的场景。<br>钱包的钱数，只能通过增加，减少接口进行调整，不开放直接设置金额的接口（口子一开，对账就是个麻烦事）<br>另一个意义，调用类，没有必要知道太多的实施类的具体实现细节。让操作更为简单。<br>个人思考：<br>封装就是让代码遵守开闭原则的重要手段。<br>当调用类，关注过多实施类的继节时，一个需求的变化，可能引发多个依赖模块都发生了级联的改动，而一但调用类过度的知道了太多了实施类的细节（然后各种调用类代码再一散落），这时程序也相应地变得出各种毛病出来，既然这样，把实现的方法封装起来多好，让调用端少操点心。<br>Law of Demeter 有个别名，就叫最少知道原则，争哥说的第二个意义，感觉就是在描述遵守迪米特法则的好处.<br>再乱想一下， 人体，不就是最好的的封装么， 给你物料的入口（吃），出口（拉），还给你调节增强的接口（训练） 有多少人，并不知道其内部细节，不照样过着精彩的一生。 还有，调用类，总想知道更多被调用类的信息，以期更精准的控制，这种代码风格，就是完美主义病，而完美主义的并发症就是拖延症，以及极高的复杂度造成项目越写越混乱。<br>2 抽像。<br>抽像讲的是如何隐藏信息，而抽像讲的是隐藏方法的具体实现，让调用者只关心方法提供了哪些功能即可。<br>通常借 interface 和 abstract class 来实现 抽像这一特性。当implement 某接口时，只要知道接口干了啥，即可，无需要关心实施类的细节实现。<br>抽你的意义，能解决啥问题。<br>1 处理复杂性的有效手段。人脑承受信息有限，抽像做为不关注实现细节的套路，正好管用。<br>2抽像指导了很多的oo原则 ， 凡时对实现进行封装抽离的，都可以叫抽像，例如malloc()<br>3 定义类时，要有抽像思维，不要在方法中，暴露太多细节。（建议一层抽象层，让功能分解得更细，让意图和实现分享）<br>个人理解<br>（抽象处理的复杂度是人月神话里描述 的本质复杂度（Essential Complexity）， 也是尊重人脑的认知学的 ，大脑的特性是很烂的（ 抽像的工具包记重点，归纳特性，忽视细节），（推荐阅读google 整理术）<br>再瞎想一下，抽像是将很多的知道点给封装起来了(encoding 成为一个模型) ， 归纳法便是抽象的重要实现套路，也是支撑及发展文明的利器。 抽像在开发中的意义 ，是让具体的实施类，在合适的场所下编写 （最好满足sru）,然后通过合理的ood ,去调用或运行时create 具体的子类对象，去实现。 拜抽象所赐，一种各有分工，又能有序协同的场景就出来了<br>其三，个人套路包，我沟通时，当和建议相同方向时，就往抽像了说，当想有差异时，就很细节说。 （套路是双韧剑，就看你如何用了），我个人发现很多营销大的套路，抽像来看和传销是一至的，有些技术大牛的工作套路，和某著名贪官一模一样。（例如，把话说明白了再干，明确职责）<br>笔记下（下）<br>3继承<br>继续用来表示类之间是 is -a 关系。<br>猫是动物，于是就拥有的动物的自带属性行为。（移动速度，移动距离） 进一步的，动物属生物（于是） 有了生命的共有属性，年龄<br>有些语言单继续，有些多继承。<br>意义 和解决问题。<br>1 符合认知美感 。<br>2 减少重复coding .<br>问题: 重要隐患，父子类，大量方便藕合。<br>个人理解。<br>继续和不停的复杂粘贴代码是两个极度，复制代码虽散但各管各的，继续父一改，子跟着改，而复制代码这事，是问题是，实现一个细节后，其它的相联代码，都要不停的改。而继随相反，一改全刷了，除非你子类完全重写了，而一些不成熟的开发，前期的父类往往考虑不周，后期一折腾，悲剧从此开场。<br>再者 复制粘贴代码，两段代码关联太轻，基本上就是要一处一处的改，而复制这事，就关联得太重了。 一但重了，就往往产生大量的不必要的负担。 我学设计模式最开心的就是，基于原则，而不是基于规则，不同场景就用不同的套路。<br>基于职责太重这事，我是很反感用多重继续的。 需要啥，再组合一个类多好。 多关联一个类，死不了人的。 搞出菱形继随这种蛋疼的东西，又要不停的去关注细节，活着会很累的<br>4 多态。(个人觉得oo 中最有趣的一块)<br>多态指子类替代父类。<br>三种语法机制。（父可以）<br>实现多态，除继续外，还有利用接口类语法， duck-typing<br>个人理解：理解不深。有感觉描述不出来，就觉得，继续把事搞死了，多态就要死的东西搞活。 于是支持这种把事搞活的套路出来。","like_count":56,"discussions":[{"author":{"id":1201818,"avatar":"https://static001.geekbang.org/account/avatar/00/12/56/9a/4fd3ff1f.jpg","nickname":"hello world","note":"","ucode":"3A2CDCEAF51992","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72548,"discussion_content":"作者很赞，掌握了道和术，不仅仅学习技术，则将日常的感悟加以结合，学习本质，融会贯通","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1575503846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1267558,"avatar":"https://static001.geekbang.org/account/avatar/00/13/57/66/4a747704.jpg","nickname":"不忘初心","note":"","ucode":"FF0E30038CC71A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54747,"discussion_content":"很形象","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574312409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2058510,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/djjK4h3FfPGyllqd7Oc5TpCoJEU6TOcuiarLtAPGrROocibML1OgtUIgtxQDDsia3qqLfZkpCcDykl3l8WHNxzCag/132","nickname":"Geek_63aa00","note":"","ucode":"4AF5D3318F4468","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324047,"discussion_content":"有具体经验的理解更透彻，人码合一","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605044151,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1014534,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eq6LGLtCCNoIf8S09fxcvk1OrTicPibZgX3kf8aaowY5nD8mTicH9SZZ8SlxgJvppqPThK1cEibrlA7bw/132","nickname":"秦汉2022","note":"","ucode":"C99D56B44F79C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299958,"discussion_content":"谦虚了~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597888779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1283461,"avatar":"https://static001.geekbang.org/account/avatar/00/13/95/85/15cd21c2.jpg","nickname":"杨锋","note":"","ucode":"85A7828A538FB0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284855,"discussion_content":"羡慕","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592661991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152122,"user_name":"初心","can_delete":false,"product_type":"c1","uid":1104576,"ip_address":"","ucode":"C090A1723E3474","user_header":"https://static001.geekbang.org/account/avatar/00/10/da/c0/9fc31f2d.jpg","comment_is_top":false,"comment_ctime":1573885282,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"156192707938","product_id":100039001,"comment_content":"多态一句话，现在调用将来","like_count":36,"discussions":[{"author":{"id":1504671,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f5/9f/1509d389.jpg","nickname":"栾~龟虽寿！","note":"","ucode":"219B38C08979FE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":273055,"discussion_content":"继承就是无能的孩子找老爸去搞定事情，多态就是好儿子，自己撸起袖子加油干。","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1590402778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2431554,"avatar":"https://static001.geekbang.org/account/avatar/00/25/1a/42/85f36058.jpg","nickname":"orz","note":"","ucode":"7BA8D282A16DF3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1504671,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f5/9f/1509d389.jpg","nickname":"栾~龟虽寿！","note":"","ucode":"219B38C08979FE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546363,"discussion_content":"这个比喻棒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642305693,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":273055,"ip_address":""},"score":546363,"extra":""}]},{"author":{"id":1149143,"avatar":"https://static001.geekbang.org/account/avatar/00/11/88/d7/43cf7b60.jpg","nickname":"Cc°°","note":"","ucode":"6C88E8D2C4622D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577181,"discussion_content":"确定的是接口，不确定的是实现。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1655957135,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2028953,"avatar":"","nickname":"Geek3340","note":"","ucode":"C64D302CD53513","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333337,"discussion_content":"我晕了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607503698,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150979,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1573638061,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"117537755053","product_id":100039001,"comment_content":"猫不是爬行动物，:).","like_count":27,"discussions":[{"author":{"id":1298594,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/G2hKWVwthOFMChTia10NqpDn1ib6ibibtIHsEN8lbdApwrenOqmicAWBkCTb9zFeuPSXFrKpruwJqEhfZHk99scYS1Q/132","nickname":"李晟","note":"","ucode":"5E3F8A1CD8CC67","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":221845,"discussion_content":"华生你发现了盲点 :)","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586070726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1750549,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/b6/15/e2cfd10d.jpg","nickname":"ImYours°","note":"","ucode":"51F653129034C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350470,"discussion_content":"确实","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613888721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1104818,"avatar":"https://static001.geekbang.org/account/avatar/00/10/db/b2/29b4f22b.jpg","nickname":"JasonZ","note":"","ucode":"992193AE44C39C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294370,"discussion_content":"你说的对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595861581,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150833,"user_name":"划时代","can_delete":false,"product_type":"c1","uid":1061454,"ip_address":"","ucode":"9554CE2F83B77F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/2o1Izf2YyJSnnI0ErZ51pYRlnrmibqUTaia3tCU1PjMxuwyXSKOLUYiac2TQ5pd5gNGvS81fVqKWGvDsZLTM8zhWg/132","comment_is_top":false,"comment_ctime":1573615036,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"104652830140","product_id":100039001,"comment_content":"话题一：<br>C++语言的多重继承，存在三层继承关系时，采用virtual继承方式，形成菱形继承。标准库中的iostream类就存在多重继承关系，见图http:&#47;&#47;www.cplusplus.com&#47;img&#47;iostream.gif。<br>话题二：<br>C++语言的多态实现方式比较丰富，除了类中的virtual函数实现运行期多态以外。还支持编译期多态（模板元编程），不仅能够动态改变对象执行的函数，还能动态改变对象的定义类型。<br>","like_count":24},{"had_liked":false,"id":150808,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1573612521,"is_pvip":false,"discussion_count":1,"race_medal":1,"score":"100357860329","product_id":100039001,"comment_content":"专栏中有个思考题是 java 为何不支持类多继承？却支持接口的多继承？<br>而有些语言如python是支持多继承的？<br>首先java类支持多继承的话，两个父类有同名方法，在子类中调用的时候就不知道调用哪个了，出现决议(钻石问题或菱形问题)问题<br>而接口支持多继承因为接口定义的方法不能有方法体，所以不会出现决议问题。<br>而从jdk1.8开始，接口可以有默认方法(方法要用default标识)，必须要有方法体，这样在接口多继承上不也会有决议问题吗？其实你去试下就知道了，java发现这种情况，会通过让你强制在子接口中重写这个默认方法，这样就不会有决议问题了<br><br>python支持多继承因为它通过MRO解决的，pythoner应该懂，我是不太懂，感兴趣的可以去研究","like_count":23,"discussions":[{"author":{"id":1327497,"avatar":"https://static001.geekbang.org/account/avatar/00/14/41/89/77d3e613.jpg","nickname":"bookchan","note":"","ucode":"6C40EEAC767E25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":221369,"discussion_content":"mro是method resolution order，主要解决通过顺序查找约定规则，解决了同名方法的二义性问题。\n本地优先级：指声明时父类的顺序，比如C(A,B)，如果访问C类对象属性时，应该根据声明顺序，优先查找A类，然后再查找B类。\n单调性：如果在C的解析顺序中，A排在B的前面，那么在C的所有子类里，也必须满足这个顺序。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1586006191,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150791,"user_name":"小白","can_delete":false,"product_type":"c1","uid":1004755,"ip_address":"","ucode":"9BB9A170023CD8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/d3/46fd4aa3.jpg","comment_is_top":false,"comment_ctime":1573610810,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"96062891322","product_id":100039001,"comment_content":"go语言的“隐藏式接口”算是多态中duck-typing的实现方式吧","like_count":22,"discussions":[{"author":{"id":1004841,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/55/29/4fa6e9fb.jpg","nickname":"安静的雨","note":"","ucode":"6371DE858C4D3A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50708,"discussion_content":"不算吧 更像是隐式实现接口类","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1573745708,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1254656,"avatar":"https://static001.geekbang.org/account/avatar/00/13/25/00/3afbab43.jpg","nickname":"88591","note":"","ucode":"04CE3E46455185","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":185191,"discussion_content":"duck-typing 才是多态实现的根本","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1582601666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2806043,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLBFkSq1oiaEMRjtyyv4ZpCI0OuaSsqs04ODm0OkZF6QhsAh3SvqhxibS2n7PLAVZE3QRSn5Hic0DyXg/132","nickname":"ddh","note":"","ucode":"8E852375365F16","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541889,"discussion_content":"是隐式实现接口类","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1640595280,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1000008,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/48/030b108e.jpg","nickname":"Sophie","note":"","ucode":"BB4F4A32EF9B6D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52666,"discussion_content":"go 就是组合实现","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574077327,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1644194,"avatar":"https://static001.geekbang.org/account/avatar/00/19/16/a2/789d296e.jpg","nickname":"金旭","note":"","ucode":"2FE7B4B8CE4A07","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556426,"discussion_content":"golang中有个interface类型算是“接口类”，一个类需要实现接口类中定义的全部方法，那么该类的实例就可以赋值给接口类变量，接口类变量会调用相应类中的接口实现。好处是：有了类似动态类型语言ducktyping的书写简洁性（避免了声明），又可以实现编译期间的静态检查-满足了安全性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647354908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1644194,"avatar":"https://static001.geekbang.org/account/avatar/00/19/16/a2/789d296e.jpg","nickname":"金旭","note":"","ucode":"2FE7B4B8CE4A07","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556425,"discussion_content":"是隐式实现接口类","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647354646,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1298139,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ce/db/bb1821b3.jpg","nickname":"王      慈","note":"","ucode":"EACC3D086674D8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":155118,"discussion_content":"理解不算. Go还是强类型语言的...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580215980,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1295268,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/ibcRNslcyp7dwIR3TIwvloCibMd7Ew2TB3MU0wISFXEolyuHRtfIriagm6PMX5zQHicmc78BrBcxA6vQ5qnTPCev9A/132","nickname":"jiangjing","note":"","ucode":"D45001E5FB4D6F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":85376,"discussion_content":"好问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576543359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150868,"user_name":"weiguozhihui","can_delete":false,"product_type":"c1","uid":1052132,"ip_address":"","ucode":"D59087307CFC91","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/CibnyMEyuo4aKCjEzq3t8CRLbiatiaNCmSsTGlhdHaMseBibB2CK2Dyu4TSa7AVREseibicWUnSicp78kWP2gb66u7ajw/132","comment_is_top":false,"comment_ctime":1573618470,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"78883029798","product_id":100039001,"comment_content":"c 语言通过结构体来实现封装，只是c 的结构体没有关键字来控制结构体内部成员的访问权限问题，属于一种比较粗的封装。另外C中通过void*+结构体+函数指针也是可以实现多太的。Linux内核代码好多都是用了面向对象编程思想。C++中引入public protected private 关键字来进行访问控制权管理。C++中没有Java中的interface 关键字来描述接口类，但也是可以通过虚函数基类来进行的Java中的接口类的。C++是直接支持多继承的，但这个特性也被好多人诟病。","like_count":18,"discussions":[{"author":{"id":1193874,"avatar":"https://static001.geekbang.org/account/avatar/00/12/37/92/961ba560.jpg","nickname":"授人以🐟，不如授人以渔","note":"","ucode":"BD53829E924B66","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50294,"discussion_content":"C 结构体的封装，和没封装一样。没有访问权限的支持，在哪里都可以直接修改。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573700143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1514660,"avatar":"https://static001.geekbang.org/account/avatar/00/17/1c/a4/202dde43.jpg","nickname":"猴精鸭","note":"","ucode":"7513DC4138E031","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1193874,"avatar":"https://static001.geekbang.org/account/avatar/00/12/37/92/961ba560.jpg","nickname":"授人以🐟，不如授人以渔","note":"","ucode":"BD53829E924B66","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":347804,"discussion_content":"c头文件只声明结构体，结构体的定义放到源文件中就是封装了，对外只提供头文件，调用者不知道结构体里有什么，只能通过函数进行使用","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1612327335,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":50294,"ip_address":""},"score":347804,"extra":""}]},{"author":{"id":1444483,"avatar":"https://static001.geekbang.org/account/avatar/00/16/0a/83/f916f903.jpg","nickname":"风","note":"","ucode":"E1CE0825AAF805","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300961,"discussion_content":"C的结构体，不叫封装，它“只装不封”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598343555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151636,"user_name":"zcdll","can_delete":false,"product_type":"c1","uid":1004086,"ip_address":"","ucode":"F1F20EB17D8789","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/36/18f5d218.jpg","comment_is_top":false,"comment_ctime":1573773309,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"70293250045","product_id":100039001,"comment_content":"1. 你熟悉的编程语言是否支持多重继承？如果不支持，请说一下为什么不支持。如果支持，请说一下它是如何避免多重继承的副作用的。<br>    1. JavaScript 不支持多继承，多继承理论上都存在“菱形问题”，也就是说如果 class D 继承了 class B 和 class C，class B 和 class C 都继承了 class A，class A 中有一个方法  add，B 和 C 都重写了 add 方法，当 D 去调用 add 方法时 就会出问题，不知道调用哪个方法了。<br>    2. 理论上是可以通过 Mixin 的方式来实现多继承。<br>    3. 通过一些 合并 算法来“部分”解决“菱形问题”<br>    4. 参考 JavaScript中的“多继承” [https:&#47;&#47;juejin.im&#47;entry&#47;5ac46b6c5188255570063b71](https:&#47;&#47;juejin.im&#47;entry&#47;5ac46b6c5188255570063b71)<br>2. 你熟悉的编程语言对于四大特性是否都有现成的语法支持？对于支持的特性，是通过什么语法机制实现的？对于不支持的特性，又是基于什么原因做的取舍？<br>    1. JavaScript 支持封装，抽象，继承，多态<br>    2. 封装 ES6的话，通过 public protected private 等关键字来实现，ES5 的话通过 “函数作用域”，this，原型链来实现，ES6 的 class 本质上也是 function 的语法糖。<br>    3. 抽象 可以通过 this指针 和 原型链 的形式来实现<br>    4. 继承 通过 原型链 来实现，或者说基于封装的特性来实现<br>    5. 多态 通过原型链 的方式，子类覆写父类的方法来实现","like_count":16,"discussions":[{"author":{"id":1319369,"avatar":"https://static001.geekbang.org/account/avatar/00/14/21/c9/2b1e5326.jpg","nickname":"俞俊001","note":"","ucode":"B6D3F5448D4138","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":129579,"discussion_content":"第五点有点疑问。JavaScript 天然通过duck type支持多态。你的说法是强行用Java这种基于类的多态来描述JavaScript。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578715469,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151545,"user_name":"大胖子","can_delete":false,"product_type":"c1","uid":1302384,"ip_address":"","ucode":"075A4936880074","user_header":"https://static001.geekbang.org/account/avatar/00/13/df/70/f3b8b8a2.jpg","comment_is_top":false,"comment_ctime":1573738554,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"65998247994","product_id":100039001,"comment_content":"这篇文章讲的真他娘的好啊","like_count":15,"discussions":[{"author":{"id":1750549,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/b6/15/e2cfd10d.jpg","nickname":"ImYours°","note":"","ucode":"51F653129034C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388071,"discussion_content":"嘿，你他娘的还真是个人才","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628580660,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1576240,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLlibCGekRp9bxJ3dGfOWghhNVdF771ejzwqKnicKFBpmGuutwNGF3HGZz7KEEz2mdvPckibReRsVtDw/132","nickname":"Geek_e6159b","note":"","ucode":"0684569F9B114D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301404,"discussion_content":"琦玉，大兄弟。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598516336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018696,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/48/e2279b0e.jpg","nickname":"绵阳米粉儿真好吃","note":"","ucode":"F82499FD76B5EF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":253481,"discussion_content":"看到这条评论莫名想笑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588237956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150673,"user_name":"秋惊蛰","can_delete":false,"product_type":"c1","uid":1620344,"ip_address":"","ucode":"3D9A6D5CA9C79F","user_header":"https://static001.geekbang.org/account/avatar/00/18/b9/78/a5804dae.jpg","comment_is_top":false,"comment_ctime":1573580667,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"65998090107","product_id":100039001,"comment_content":"试着说一下Python吧<br>- 抽象：抽象是编程语言的共有特点，甚至是计算机科学的特点，从变量，函数，类，模块，包等概念都是不同层次的抽象。抽象和把大象装进冰箱分三步是一个道理，它给出了思路，指明了方向，省略了细节。我们用层层抽象来应对计算机系统的复杂性。Python主要的抽象工具是函数和类，模块和包也算吧，毕竟也是隐藏了细节。<br>- 封装：Python不支持严格意义上的封装，没有private, protected等访问修饰符，这样做是为了保证动态语言最大的灵活性，同时Python里很多理念都是约定大于定义的，私有的属性需要大家守约，不要去随意访问，这也是Python被吐槽的地方吧，大型项目约束力不够。<br>- 继承：Python支持多重继承，主要是因为它没有类似于Java的“接口类”的语法吧，用多重继承可以定义一些纯功能性的类，减少类的层级。<br>- 多态：Python的多态就是鸭子类型了，鸭子类型的背后是所谓“协议”，协议是非正式的接口，是一种特性，表现为一个或多个相关的方法，比如迭代器协议，序列协议。实现了迭代器协议就和Java中实现了Iterator接口一样。","like_count":15,"discussions":[{"author":{"id":2222614,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/1fXYkS0UlZUQQtzUpG2TZzVhVZHarfpWT5wjO7iajw959zysQks1vLFM2uQsKnYG3uQAhzenH9LP86goiciaCDNibQ/132","nickname":"Xingyi_Xie","note":"","ucode":"D1849DB8BFB1B2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":406414,"discussion_content":"手动点赞~~当然，Python中也可以通过“继承加方法重写”实现多态，虽然没有override关键词。直接在子类中定义，与父类中同名的方法，就实现了“子类替换父类”的多态。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634746915,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150817,"user_name":"Bug? Feature!","can_delete":false,"product_type":"c1","uid":1164531,"ip_address":"","ucode":"F8FA8A0094FBA0","user_header":"https://static001.geekbang.org/account/avatar/00/11/c4/f3/92f654f1.jpg","comment_is_top":false,"comment_ctime":1573613277,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"40228318941","product_id":100039001,"comment_content":"我们使用Java已经很长时间了，我们有多少次因为缺少多重继承而面临困难呢？<br>我个人的经验是一次都没有。因为多重继承很少有机会被用到，所以更安全的做法是去掉它而保持简单性。<br>就算是碰到需要多重继承的情景，我们也可以找到替代方法。<br>我的观点是，去掉对多重继承的支持不是Java的缺陷，对开发者来说是件好事。","like_count":9,"discussions":[{"author":{"id":1292206,"avatar":"https://static001.geekbang.org/account/avatar/00/13/b7/ae/a25fcb73.jpg","nickname":"colin","note":"","ucode":"7A8849B8AE33E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50264,"discussion_content":"是因为java没有多继承，所以java基本不做多继承相关的事。前后因果不能反","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1573697859,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1079425,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/81/f6229358.jpg","nickname":"fresh meat","note":"","ucode":"6AC5A69F80ECE7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49970,"discussion_content":"同意","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573653691,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150696,"user_name":"路遥","can_delete":false,"product_type":"c1","uid":1135025,"ip_address":"","ucode":"2BB52B8CA82829","user_header":"https://static001.geekbang.org/account/avatar/00/11/51/b1/4eab324e.jpg","comment_is_top":false,"comment_ctime":1573603117,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"40228308781","product_id":100039001,"comment_content":"多继承会带来菱形继承的问题。例如一个类的两个父类，都继承了同一个祖父类，两个父类都 override 了祖父类的方法，这时候孙子类就不知道如何调用了。<br><br>Java 8 的 interface 可以有方法默认实现，这应该可以算是曲线救国的多继承吧。","like_count":9,"discussions":[{"author":{"id":1471657,"avatar":"https://static001.geekbang.org/account/avatar/00/16/74/a9/5eb3ebc6.jpg","nickname":"唐龙","note":"","ucode":"87A10AE04F2037","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580892,"discussion_content":"在C++中。\n类A有一个纯虚函数func，BC两个子类分别有自己的实现，并且BC共同派生出一个孙子类D。\n在D类中可以通过B::func()或C::func()显式指明要调用哪一个父类的实现。\n你说的这个问题不算啥大问题，但是还需要注意其他细节，B或C从A继承过来时需要有一个采用虚继承的方式，但是两者都采用虚继承也不行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658395314,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236365,"user_name":"微末凡尘","can_delete":false,"product_type":"c1","uid":1099525,"ip_address":"","ucode":"25EDFD0914D0F4","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/05/19c5c255.jpg","comment_is_top":false,"comment_ctime":1595400244,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35955138612","product_id":100039001,"comment_content":"争哥对面向对象的总结完美符合 What&#47;How&#47;Why 模型，我按照模型作下梳理。<br><br>## 封装<br>What：隐藏信息，保护数据访问。<br>How：暴露有限接口和属性，需要编程语言提供访问控制的语法。<br>Why：提高代码可维护性；降低接口复杂度，提高类的易用性。<br><br>##抽象<br>What: 隐藏具体实现，使用者只需关心功能，无需关心实现。<br>How: 通过接口类或者抽象类实现，特殊语法机制非必须。<br>Why: 提高代码的扩展性、维护性；降低复杂度，减少细节负担。<br><br>##继承<br>What: 表示 is-a 关系，分为单继承和多继承。<br>How: 需要编程语言提供特殊语法机制。例如 Java 的 “extends”，C++ 的 “:” 。<br>Why: 解决代码复用问题。<br><br>##多态<br>What: 子类替换父类，在运行时调用子类的实现。<br>How: 需要编程语言提供特殊的语法机制。比如继承、接口类、duck-typing。<br>Why: 提高代码扩展性和复用性。<br><br>3W 模型的关键在于 Why，没有 Why，其它两个就没有存在的意义。从四大特性可以看出，面向对象的终极目的只有一个：可维护性。易扩展、易复用，降低复杂度等等都属于可维护性的实现方式。","like_count":8},{"had_liked":false,"id":151055,"user_name":"晨风破晓","can_delete":false,"product_type":"c1","uid":1321464,"ip_address":"","ucode":"F2BC46428A97B5","user_header":"https://static001.geekbang.org/account/avatar/00/14/29/f8/561c5be1.jpg","comment_is_top":false,"comment_ctime":1573647967,"is_pvip":false,"discussion_count":9,"race_medal":0,"score":"35933386335","product_id":100039001,"comment_content":"PHP不支持多继承，具体为什么还没了解过，四大特性都是有现有语法支持的；看完这堂课，貌似对多态还不是很理解","like_count":8,"discussions":[{"author":{"id":2297573,"avatar":"https://static001.geekbang.org/account/avatar/00/23/0e/e5/b7b42a13.jpg","nickname":"一天两天","note":"","ucode":"DB9D4C42F033DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325066,"discussion_content":"PHP没有多继承，使用trait组合，或者implements继承多个接口来实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605230895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1359669,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/35/0e3a92a7.jpg","nickname":"晴天了","note":"","ucode":"5310E02F8DF1F0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":313885,"discussion_content":"多态: 一种事物多种状态 .  每个实现类都依赖接口抽象 . 客户端类同样依赖抽象 . ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603102252,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1131091,"avatar":"https://static001.geekbang.org/account/avatar/00/11/42/53/d2ef5b62.jpg","nickname":"Lin","note":"","ucode":"C6C115A77CA1FD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":135727,"discussion_content":"不知道理解是否准确，比如说PHP内依赖注入时，参数类型可以是接口类，而非实际实现类，是多态的实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579099812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1514953,"avatar":"https://static001.geekbang.org/account/avatar/00/17/1d/c9/c22f4e4b.jpg","nickname":"杜美洁","note":"","ucode":"78354D0430C9DF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":114631,"discussion_content":"php貌似没有支持多态的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577975475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1625837,"avatar":"https://static001.geekbang.org/account/avatar/00/18/ce/ed/5abd527e.jpg","nickname":"骄之","note":"","ucode":"C1B72B963E370C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51747,"discussion_content":"PHP 通过 Trait 来解决多继承的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573920078,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1000008,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/48/030b108e.jpg","nickname":"Sophie","note":"","ucode":"BB4F4A32EF9B6D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1625837,"avatar":"https://static001.geekbang.org/account/avatar/00/18/ce/ed/5abd527e.jpg","nickname":"骄之","note":"","ucode":"C1B72B963E370C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52670,"discussion_content":"trait 是通过组合是解决的多继承问题","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574077378,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":51747,"ip_address":""},"score":52670,"extra":""},{"author":{"id":1211359,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7b/df/876dd9cc.jpg","nickname":"kings","note":"","ucode":"D478306EBF582E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1000008,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/48/030b108e.jpg","nickname":"Sophie","note":"","ucode":"BB4F4A32EF9B6D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55271,"discussion_content":"用PHP5得伤不起","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574348384,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":52670,"ip_address":""},"score":55271,"extra":""}]},{"author":{"id":1571892,"avatar":"https://static001.geekbang.org/account/avatar/00/17/fc/34/ec2f140f.jpg","nickname":"🌟","note":"","ucode":"B548DB42023BD8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50810,"discussion_content":"同感","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573776818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1737984,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIdCoCuWIfSdicDQY13qhGVUs4tgXt3iaqhUibjFQX2iaHTM8qA53hatv209EfqeK1pNknmrHajibP9Lkw/132","nickname":"Sherrygauss","note":"","ucode":"23BF8818AFA1E4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50248,"discussion_content":"我也是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573696555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":210206,"user_name":"Roc","can_delete":false,"product_type":"c1","uid":1802610,"ip_address":"","ucode":"0D71BD87E3DD54","user_header":"https://static001.geekbang.org/account/avatar/00/1b/81/72/e6dbf6f3.jpg","comment_is_top":false,"comment_ctime":1587697475,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27357501251","product_id":100039001,"comment_content":"python是支持多继承的，对于多继承的二义性问题，有一套MRO(Method Resolution Order)机制来解决，简单说就是排序。目前是采用C3算法，对继承关系建树后，使用拓扑排序得到序列；在python2.2之前也有用DFS去获取继承序列，但DFS会出现继承不到子类对于父类的重写，而后更新为C3算法，解决了本地优先级及单调性的问题。<br>详见贴：<br>https:&#47;&#47;blog.csdn.net&#47;qq_38923792&#47;article&#47;details&#47;94414944<br>https:&#47;&#47;www.mscto.com&#47;python&#47;183897.html<br>https:&#47;&#47;blog.csdn.net&#47;qwertyupoiuytr&#47;article&#47;details&#47;56439134","like_count":6},{"had_liked":false,"id":152457,"user_name":"昨日火冷啊","can_delete":false,"product_type":"c1","uid":1215103,"ip_address":"","ucode":"126A583CCF9E91","user_header":"https://static001.geekbang.org/account/avatar/00/12/8a/7f/fcb659b7.jpg","comment_is_top":false,"comment_ctime":1574005725,"is_pvip":false,"replies":[{"id":"60034","content":"从你的描述来看，有点类似的。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1574855183,"ip_address":"","comment_id":152457,"utype":1}],"discussion_count":3,"race_medal":0,"score":"27343809501","product_id":100039001,"comment_content":"老师好，<br>请问c++的template算不算 duck-typing？ 比如定义一个模版，A&lt;T&gt;，用到函数T.Load()。然后有类B 和C都有成员函数Load（）。 那么都可以通过使用A&lt;B&gt;  和A&lt;C&gt; 来使用模版，而B，C之间不需要继承关系。 ","like_count":6,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474823,"discussion_content":"从你的描述来看，有点类似的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574855183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2875594,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/e0/ca/adfaa551.jpg","nickname":"孙新","note":"","ucode":"A80038A479B943","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579702,"discussion_content":"c++的模板让c++变成了另外一门语言","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657621963,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2054357,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/58/d5/6688e2a0.jpg","nickname":"hey","note":"","ucode":"ECD6D0EC04E50B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400754,"discussion_content":"别这样，C++的template和Java的interface类似，B和C类似于继承了相同父类的子类，它们之间也自然没有继承关系。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633412918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152246,"user_name":"码农Kevin亮","can_delete":false,"product_type":"c1","uid":1116630,"ip_address":"","ucode":"D34562461CA0A1","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/d6/5f366427.jpg","comment_is_top":false,"comment_ctime":1573950435,"is_pvip":false,"replies":[{"id":"58604","content":"是的 有人把它叫做静态多态","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1574040275,"ip_address":"","comment_id":152246,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27343754211","product_id":100039001,"comment_content":"请问老师，有些教科书上会把重载也理解为多态，老师怎么理解呢","like_count":6,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474764,"discussion_content":"是的 有人把它叫做静态多态","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574040275,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151367,"user_name":"铿然","can_delete":false,"product_type":"c1","uid":1162461,"ip_address":"","ucode":"D529242EC2E2EA","user_header":"https://static001.geekbang.org/account/avatar/00/11/bc/dd/c9413f59.jpg","comment_is_top":false,"comment_ctime":1573707401,"is_pvip":true,"discussion_count":7,"race_medal":0,"score":"27343511177","product_id":100039001,"comment_content":"感觉抽象并不是为了信息隐藏，抽象是为了把共性的东西抽象出来，如麻雀，燕子的行为可以抽象为鸟的行为，这是抽象，这篇描述的抽象个人觉得不那么准确。","like_count":6,"discussions":[{"author":{"id":1802610,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/81/72/e6dbf6f3.jpg","nickname":"Roc","note":"","ucode":"0D71BD87E3DD54","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":252271,"discussion_content":"我的理解是没必要把抽象狭义化和实体化；抽象体现在多个方面：在函数中，抽象意味着隐藏实现细节；在类的构建中，抽象意味着抽取个体的共性，定义泛指的通用的类。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1588146683,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1162461,"avatar":"https://static001.geekbang.org/account/avatar/00/11/bc/dd/c9413f59.jpg","nickname":"铿然","note":"","ucode":"D529242EC2E2EA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1802610,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/81/72/e6dbf6f3.jpg","nickname":"Roc","note":"","ucode":"0D71BD87E3DD54","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":256279,"discussion_content":"不错，确实可以这么说，好比设计模型，有L0视图，L1视图，越底层越抽象，这些并不是因为共性抽象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588468125,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":252271,"ip_address":""},"score":256279,"extra":""}]},{"author":{"id":1024294,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","nickname":"null","note":"","ucode":"F9039EFED6B55D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":109156,"discussion_content":"我之前也是这么理解的，学习后有点模糊。\n现在是这么理解的：主要是抽象共性行为，顺便隐藏了方法实现，减少其他细节信息干扰。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1577670793,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1209336,"avatar":"https://static001.geekbang.org/account/avatar/00/12/73/f8/dbd2fa50.jpg","nickname":"晓杉","note":"","ucode":"19E634BB61A165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":129486,"discussion_content":"抽象就是为了隐藏细节，你提供SDK给别人开发，你不想把实现细节打包进去，抽象就起到了重要作用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578707750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1679661,"avatar":"https://static001.geekbang.org/account/avatar/00/19/a1/2d/599e9051.jpg","nickname":"CycleGAN","note":"","ucode":"9FD04813911A02","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52245,"discussion_content":"我也觉得","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574007883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1206751,"avatar":"https://static001.geekbang.org/account/avatar/00/12/69/df/2dca1305.jpg","nickname":"Healtheon","note":"","ucode":"B564B1FC4456E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50827,"discussion_content":"你的感觉是错的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573778445,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1205294,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/2e/e70a317a.jpg","nickname":"学好习，做好人","note":"","ucode":"C991643DB458E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50575,"discussion_content":"感觉模板模式是对抽象或者说Java中的抽象类运用最好的例子","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573735408,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151768,"user_name":"风流倜傥怪蜀黍","can_delete":false,"product_type":"c1","uid":1241140,"ip_address":"","ucode":"ADBA7EBDC9C7E2","user_header":"https://static001.geekbang.org/account/avatar/00/12/f0/34/d572802b.jpg","comment_is_top":false,"comment_ctime":1573788123,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23048624603","product_id":100039001,"comment_content":"偏门语言 OC 前来报道!!!<br>OC 不支持多继承,原因无非就是菱形继承导致的二异性.<br>OC 中的协议根老师讲的接口类是一个概念,只有方法声明(swift 可添加默认实现),可以实现伪多继承.<br>这里要说一下 OC 的消息转发机制,源自 smallTalk,赋予了 OC 语言的动态性,是整个 OC 语言的一大亮点,消息转发简单的理解成我虽然无法响应这个函数,但是我可以在运行时的时候指定其它类去响应,利用这个可以实现动态的实现多继承和多态特性","like_count":5},{"had_liked":false,"id":152949,"user_name":"ldd","can_delete":false,"product_type":"c1","uid":1208157,"ip_address":"","ucode":"E8344FAFFE5CF3","user_header":"https://static001.geekbang.org/account/avatar/00/12/6f/5d/f0a19f09.jpg","comment_is_top":false,"comment_ctime":1574128535,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18753997719","product_id":100039001,"comment_content":"话题1：<br>Objective-C不支持多继承，OC的方法调用是基于消息机制，是基于方法名调用的，而且是发生在运行时而非编译时，很难解决多个基类可能导致的二义性问题。<br>话题2：<br>封装：@private、@protected、@public 表作用域的关键字，而且还可以用.h、.m机制实现。<br>抽象：protocol 协议来实现。<br>继承：简单的 Child : Parent 来实现，内部其实用 isa 指针来实现的。<br>多态：继承、protocol 都可以实现<br><br>番外：OC也可以实现多继承，可以用消息转发机制去实现。但本人觉得多继承好像确实不是很实用，之前看 c++ 文档也不建议多用，很想听听争哥对多继承的态度☺️","like_count":4},{"had_liked":false,"id":151845,"user_name":"月坛小雨","can_delete":false,"product_type":"c1","uid":1209475,"ip_address":"","ucode":"AB7C38A85692E6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJVhMyzoAPOLPI5wxsxSydHZeqNdz1SLRnPPQ0STmWwXIbkhaLHw4t2AXsTJwicgEibcRAMZEgibAKgg/132","comment_is_top":false,"comment_ctime":1573799627,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18753668811","product_id":100039001,"comment_content":"python支持多重继承，带来钻石继承问题主要是两点：一是父类方法的调用顺序，二是父类方法会被执行多次。对问题一，python使用了C3算法，在避免同一类被调用多次的前提下，使用广度优先和从左到右的原则寻找需要属性和方法，使用funcitonname.__mro__可以查看调用顺序。对问题二，python在子类重写方法时，使用super().methodname()语句，super本质上是一个类，内部记录着MRO信息，也是用C3算法保证一个类只会被搜寻一次。","like_count":4},{"had_liked":false,"id":150755,"user_name":"安静","can_delete":false,"product_type":"c1","uid":1212758,"ip_address":"","ucode":"ABF1824D24BA2F","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/56/311be282.jpg","comment_is_top":false,"comment_ctime":1573607175,"is_pvip":false,"replies":[{"id":"59140","content":"我个人觉得duck typing过于灵活了","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1574333795,"ip_address":"","comment_id":150755,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18753476359","product_id":100039001,"comment_content":"duck-typing 实现多态的方式确实灵活，这个维护成功也会比较高吗？","like_count":4,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474262,"discussion_content":"我个人觉得duck typing过于灵活了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574333795,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150693,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1573602558,"is_pvip":true,"replies":[{"id":"59169","content":"理论上讲这是一种hack的方法 不推荐使用","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1574385114,"ip_address":"","comment_id":150693,"utype":1}],"discussion_count":3,"race_medal":0,"score":"18753471742","product_id":100039001,"comment_content":"老师，我还有一个问题：<br>Java中支持反射机制。利用反射机制，我们可以访问类的私有变量和私有方法。请问这是否有违“封装”的初衷呢？哪些场合我们要必须使用“反射”访问私有变量或者私有方法呢？","like_count":4,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474244,"discussion_content":"理论上讲这是一种hack的方法 不推荐使用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574385114,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1362631,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","nickname":"黄林晴","note":"","ucode":"B15C38AECDA88F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49465,"discussion_content":"我觉得一般业务不会可以使用反射，毕竟代码是自己控制的，当我们要改变源码中的逻辑，源码没有提供访问方法的时候可以考虑用反射，或者自己去编写框架的时候，不过因为反射性能损耗，运行时注解代替反射使用的更多","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1573604145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1362631,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","nickname":"黄林晴","note":"","ucode":"B15C38AECDA88F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49504,"discussion_content":"Awesome explanation! It is very inspiring! Reflection mechnism is very useful, it can be used in serialization, ioc and so on. Thanks!","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573606293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":49465,"ip_address":""},"score":49504,"extra":""}]}]},{"had_liked":false,"id":164536,"user_name":"请叫我和尚","can_delete":false,"product_type":"c1","uid":1703256,"ip_address":"","ucode":"33A8A1CDA103F9","user_header":"https://static001.geekbang.org/account/avatar/00/19/fd/58/1af629c7.jpg","comment_is_top":false,"comment_ctime":1577022916,"is_pvip":false,"replies":[{"id":"65140","content":"是的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1577949734,"ip_address":"","comment_id":164536,"utype":1}],"discussion_count":1,"race_medal":1,"score":"14461924804","product_id":100039001,"comment_content":"多态是否又分为编译时多态和运行时多态？","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478805,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577949734,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":286175,"user_name":"大毛","can_delete":false,"product_type":"c1","uid":1899599,"ip_address":"","ucode":"93B18287F06706","user_header":"https://static001.geekbang.org/account/avatar/00/1c/fc/4f/0a452c94.jpg","comment_is_top":false,"comment_ctime":1617178886,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10207113478","product_id":100039001,"comment_content":"举个例子：<br>- 封装：一个人有五脏六腑，你可以获得相关的信息，但是你不可以修改他们<br>- 抽象：人可以跑、学习、娱乐，你只需要提供这些行为的方法，而不需要告诉调用者人是怎么跑的<br>- 继承：男人女人都是人，他们可以继承“人”这个类<br>- 多态：不管是什么人，他们都可以完成“学习”这个动作，只不过不同的人的学习方式可能不同","like_count":2},{"had_liked":false,"id":273468,"user_name":"qf年间","can_delete":false,"product_type":"c1","uid":1463023,"ip_address":"","ucode":"AA08AC984637EE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLbchZfeEnshPuUwEsQkn1XbWxjs3rRUpSRUxjW4q7rOcrPvXld0IxEZ1jlpEJdklFeEVERJoOfibg/132","comment_is_top":false,"comment_ctime":1610607235,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10200541827","product_id":100039001,"comment_content":"dynamicArray的例子实际上说的是一个“向上转型”的问题","like_count":2},{"had_liked":false,"id":244502,"user_name":"ThinkingQuest","can_delete":false,"product_type":"c1","uid":1118560,"ip_address":"","ucode":"597D0C00DAEFE4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/0SDRac7XoordnKYgDLhz5wxAOtE6xqcsSywsywEtKQAR7xicBZQ6ceYftfZjl4Ivq3a5dzvRhYkn2GcUWiaQK7ZQ/132","comment_is_top":false,"comment_ctime":1598540991,"is_pvip":false,"replies":[{"id":"90144","content":"������，谢谢姐","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1598835649,"ip_address":"","comment_id":244502,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10188475583","product_id":100039001,"comment_content":"口语中的“爬行动物”指的是：动物界 脊索动物门 脊椎动物亚门 爬行纲。<br>猫属于： 动物界 脊索动物门 脊椎动物亚门 哺乳纲 食肉目 猫科 猫属<br><br>所以，猫不是“爬行动物”。<br><br>你要说猫属于“会爬行的动物”，那也对。 <br>","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504607,"discussion_content":"������，谢谢姐","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598835649,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244436,"user_name":"Jasper","can_delete":false,"product_type":"c1","uid":1144132,"ip_address":"","ucode":"7AEF50986C7D8C","user_header":"https://static001.geekbang.org/account/avatar/00/11/75/44/ee170215.jpg","comment_is_top":false,"comment_ctime":1598516373,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10188450965","product_id":100039001,"comment_content":"记忆多态三个特性有个很好的口诀：<br>一要有继承；<br>二要有重写；<br>三是父类引用指向子类对象。<br>想当年大学时代听马士兵老师的视频课程，对这个口诀可谓是记忆犹新呀^_^","like_count":2},{"had_liked":false,"id":201806,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":false,"comment_ctime":1585839435,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10175774027","product_id":100039001,"comment_content":"JDK7以后，有了invokedynamic，其实在字节码层面也是可以实现duck-typing效果的","like_count":2},{"had_liked":false,"id":170760,"user_name":"晓杉","can_delete":false,"product_type":"c1","uid":1209336,"ip_address":"","ucode":"19E634BB61A165","user_header":"https://static001.geekbang.org/account/avatar/00/12/73/f8/dbd2fa50.jpg","comment_is_top":false,"comment_ctime":1578707435,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10168642027","product_id":100039001,"comment_content":"java不支持多继承，但支持多实现，可以一定程度上弥补多继承。","like_count":2},{"had_liked":false,"id":153923,"user_name":"小妖","can_delete":false,"product_type":"c1","uid":1730626,"ip_address":"","ucode":"49C01DBFADF101","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJvm1JYIDcS74s4cEYxA1PXMqjortVXEjUKyGQcPvibNJ4EAuksIa6uoHgr6G1yRqAM2KtP3yicKgTA/132","comment_is_top":false,"comment_ctime":1574330821,"is_pvip":false,"replies":[{"id":"59156","content":"你举的例子不还是子类传递给父类吗","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1574377744,"ip_address":"","comment_id":153923,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10164265413","product_id":100039001,"comment_content":"我觉得文中对多肽的定义有问题，多肽不仅是只子类替换父类（父类对象引用子类对象），也包括父类（代理类）可以在某些时候代替子类作为参数传递（继承的方式实现参数代理），更直观的表现是实现类替换接口（接口引用接口的实现比如 : LIst&lt;String&gt; list=new ArrayList&lt;&gt;();）,这听起来有点像是抽象，实际上抽象的很多情况下是依赖多肽的，比如，方法接口接口作为参数，而不必接收具体的类这体现了抽象，但更体现了多肽…………求交流","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475324,"discussion_content":"你举的例子不还是子类传递给父类吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574377744,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153094,"user_name":"wanghai","can_delete":false,"product_type":"c1","uid":1450052,"ip_address":"","ucode":"44B7355C2BDBB2","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erToic2lDbQhozlh2Ey72ia4svuXZ4FmJERWMvATna98XEwxhqnHPVfzsdNsibicIK4ZpSReNrp7N7V9g/132","comment_is_top":false,"comment_ctime":1574156086,"is_pvip":false,"replies":[{"id":"59172","content":"后面章节会讲到 别急","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1574385771,"ip_address":"","comment_id":153094,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10164090678","product_id":100039001,"comment_content":"我最近在做一个功能，而且我也是有一些迷茫<br>我用到了继承，在父类定义了很多方法，然后我有很多子类，每个子类自己来实现一些需要重写的方法.<br>我也想到了组合，但是组合好像无法重写方法，导致变的更麻烦，希望大神帮我解惑～～","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475041,"discussion_content":"后面章节会讲到 别急","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574385771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152350,"user_name":"王振华 程序员","can_delete":false,"product_type":"c1","uid":1131957,"ip_address":"","ucode":"31BB337642B882","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/b5/c3cfb198.jpg","comment_is_top":false,"comment_ctime":1573980796,"is_pvip":false,"replies":[{"id":"58603","content":"透明的意思不就是不知道细节吗","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1574040109,"ip_address":"","comment_id":152350,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10163915388","product_id":100039001,"comment_content":"请问：封装部分，“而且，这两个属性的初始化设置，对于 Wallet 类的调用者来说，也应该是透明的”，这句话我不理解。id、createTime这两个属性的初始化设置，对于Wallet类的调用者来说，为什么是透明的？调用者应该不知道Wallet类内部的实现细节才对呀？","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474788,"discussion_content":"透明的意思不就是不知道细节吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574040109,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1131957,"avatar":"https://static001.geekbang.org/account/avatar/00/11/45/b5/c3cfb198.jpg","nickname":"王振华 程序员","note":"","ucode":"31BB337642B882","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":59713,"discussion_content":"还是我看书太少了，原来对外透明的意思是：外部调用者可以顺利的得到自己想要的任何功能，完全意识不到内部细节的存在，是看不到或者说也不需要看到内部的细节。\n我却望文生义地以为透明的意思是既然是透明的，那就什么都能看清楚了，哈哈。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574693187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151873,"user_name":"William Ning","can_delete":false,"product_type":"c1","uid":1592279,"ip_address":"","ucode":"4DB8D05E69E5F3","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","comment_is_top":false,"comment_ctime":1573803547,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10163738139","product_id":100039001,"comment_content":"PHP独特的语法混合了C、Java、Perl以及 PHP自创的语法, 不支持多继承的原因应与Java同, 实现多继承的方式有: 接口&#47;trait&#47;__call() ","like_count":2},{"had_liked":false,"id":151568,"user_name":"逍遥思","can_delete":false,"product_type":"c1","uid":1015512,"ip_address":"","ucode":"340F05C786730F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/d8/92a98fb6.jpg","comment_is_top":false,"comment_ctime":1573741310,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10163675902","product_id":100039001,"comment_content":"Swift 不支持多重继承，原因应该和其他不支持多重继承的原因一样，为了避免多重继承额外引入的复杂度。<br><br>Swift 支持封装、抽象、继承、多态：对封装的语法支持是通过 fileprivate 关键字隐藏不暴露的变量和方法；对抽象的支持是通过 protocol 关键字；对继承的支持是 class A: ClassB，对多态的支持是子类重写父类的方法。","like_count":2,"discussions":[{"author":{"id":1215892,"avatar":"https://static001.geekbang.org/account/avatar/00/12/8d/94/150dfe78.jpg","nickname":"GGL","note":"","ucode":"AED10B8248D1E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50890,"discussion_content":"Swift的多态用到了类似C++的虚函数表机制来实现的，OC是通过运行时机制isa指针。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573783155,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151487,"user_name":"学好习，做好人","can_delete":false,"product_type":"c1","uid":1205294,"ip_address":"","ucode":"C991643DB458E2","user_header":"https://static001.geekbang.org/account/avatar/00/12/64/2e/e70a317a.jpg","comment_is_top":false,"comment_ctime":1573729925,"is_pvip":false,"replies":[{"id":"58363","content":"也可以，不过看起来就有点过度设计的意思了，多了一个类，维护成本也提高了。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1573789197,"ip_address":"","comment_id":151487,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10163664517","product_id":100039001,"comment_content":"钱包那个例子，个人感觉应该把钱包余额的加减操作独立出来，比如WalletAction，并且WalletAction作为wallet的成员变量会不会更好一些，因为id,createTime,modifyTime可以算作钱包的一些固有属性，但是余额增加更偏重一些动态的计算行为，用组合的方式会不会更好些呢？","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474494,"discussion_content":"也可以，不过看起来就有点过度设计的意思了，多了一个类，维护成本也提高了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573789197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151127,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1573655930,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10163590522","product_id":100039001,"comment_content":"1、你熟悉的编程语言是否支持多重继承？如果不支持，请说一下为什么不支持。如果支持，请说一下它是如何避免多重继承的副作用的？<br>   java不支持多重继承。<br>  原因：多重继承中若不同父类存在相同方法签名时，子类调用此方法时会不知道调用哪个父类的方法的问题。<br>   如何避免：个人觉得可以根据所继承父类的先后顺序来确定优先级","like_count":2},{"had_liked":false,"id":150990,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1573639040,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10163573632","product_id":100039001,"comment_content":"Java对于封装，抽象，继承，多态支持够用了。封装和抽象解决的是信息隐藏的问题，也就是说不同位置需要看到的信息不同。封装是以类为边界，两边需要的信息量不对等。抽象是以调用者和实现者的角度来区分，两者需要的信息量差异也很大。继承和多态是抽象思想的延续，当类被分为接口和实现的时候，所有针对接口实现的操作，也同样使用于实现类。当一个接口有多个实现类，而针对接口实现的操作适用于所有满足这个接口的实现类，这样就让针对接口的代码得到复用。","like_count":2,"discussions":[{"author":{"id":1238051,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/23/ac13d916.jpg","nickname":"圆哥哥呐丶","note":"","ucode":"8E56E3E68A3836","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50473,"discussion_content":"继承和多态是抽象思想的延续，这句话 牛批了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573724841,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150935,"user_name":"小辉辉","can_delete":false,"product_type":"c1","uid":1189661,"ip_address":"","ucode":"9FF25E25C85350","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/1d/1cb36854.jpg","comment_is_top":false,"comment_ctime":1573631668,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"10163566260","product_id":100039001,"comment_content":"go语言中也有duck-typing","like_count":2,"discussions":[{"author":{"id":1272047,"avatar":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","nickname":"Magic","note":"","ucode":"FD9CEDAA419EB0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50263,"discussion_content":"go的interface算是一种duck-typing","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573697635,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1189661,"avatar":"https://static001.geekbang.org/account/avatar/00/12/27/1d/1cb36854.jpg","nickname":"小辉辉","note":"","ucode":"9FF25E25C85350","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1272047,"avatar":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","nickname":"Magic","note":"","ucode":"FD9CEDAA419EB0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50272,"discussion_content":"学的时候有个疑惑，如果实现太多的interface，又没有明确表明是哪些interface，找的时候估计会很崩溃。也有可能是go提倡的类少写方法，多用组合的原因吧😂😂😂","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573698213,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":50263,"ip_address":""},"score":50272,"extra":""},{"author":{"id":1211359,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7b/df/876dd9cc.jpg","nickname":"kings","note":"","ucode":"D478306EBF582E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1189661,"avatar":"https://static001.geekbang.org/account/avatar/00/12/27/1d/1cb36854.jpg","nickname":"小辉辉","note":"","ucode":"9FF25E25C85350","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55311,"discussion_content":"看源码疑似奔溃\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574349332,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":50272,"ip_address":""},"score":55311,"extra":""}]}]},{"had_liked":false,"id":150782,"user_name":"编程界的小学生","can_delete":false,"product_type":"c1","uid":1593289,"ip_address":"","ucode":"4A5BE9A5E877FA","user_header":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","comment_is_top":false,"comment_ctime":1573609911,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"10163544503","product_id":100039001,"comment_content":"JAVA前来报到，不支持多继承是因为考虑到钻石问题，比如A继承B和C，B和C继承了D，那么A类中覆盖的D方法是B重写的还是C重写的呢？导致混乱。<br>有个问题就是: 某种意义上讲，JAVA是不是隐式支持多继承的？因为每个类都默认继承了Object类，都用有Object的toString等方法。","like_count":2,"discussions":[{"author":{"id":1205294,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/2e/e70a317a.jpg","nickname":"学好习，做好人","note":"","ucode":"C991643DB458E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50552,"discussion_content":"个人理解，在Java里面，Object应该是所有类的基类，如果一个类没有显示的定义继承关系，那么就会默认继承Object,比如class A{}   ,但是显示的定义了继承关系，此时的继承关系应该是单向链表是的，比如class B extends A{} ,那么继承关系应该是 B->A->Object","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1573733750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1593289,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","nickname":"编程界的小学生","note":"","ucode":"4A5BE9A5E877FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1205294,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/2e/e70a317a.jpg","nickname":"学好习，做好人","note":"","ucode":"C991643DB458E2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50555,"discussion_content":"你这个解释很有道理，学习了。👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573734003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":50552,"ip_address":""},"score":50555,"extra":""},{"author":{"id":1623626,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c6/4a/3bd896fc.jpg","nickname":"Heiky","note":"","ucode":"03AA79E1BC4AE4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1205294,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/2e/e70a317a.jpg","nickname":"学好习，做好人","note":"","ucode":"C991643DB458E2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52513,"discussion_content":"这个解释是正确的，实际就是这样，赞一个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574058617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":50552,"ip_address":""},"score":52513,"extra":""}]},{"author":{"id":1167825,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d1/d1/62f74aa7.jpg","nickname":"自在飞","note":"","ucode":"A2712148DA06E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51044,"discussion_content":"单继承是在类声明时只能继承一个父类，而多继承是在类声明定义同时可以继承多个父类.从类定义角度来看：我觉得单继承和多继承的关键区别就是在于 在类定义时是否可以同时继承多个父类。从类继承线路来看：单继承形成的是一个单链表，而多继承则不是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573803499,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1730626,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJvm1JYIDcS74s4cEYxA1PXMqjortVXEjUKyGQcPvibNJ4EAuksIa6uoHgr6G1yRqAM2KtP3yicKgTA/132","nickname":"小妖","note":"","ucode":"49C01DBFADF101","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50903,"discussion_content":" 个人观点，所有的类都继承Object确实能算是隐式多继承，为什么不会出现菱形问题？因为Object是java提供的，在方法实现上会有一定的实现逻辑来处理这个问题\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573784634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1593289,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","nickname":"编程界的小学生","note":"","ucode":"4A5BE9A5E877FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1730626,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJvm1JYIDcS74s4cEYxA1PXMqjortVXEjUKyGQcPvibNJ4EAuksIa6uoHgr6G1yRqAM2KtP3yicKgTA/132","nickname":"小妖","note":"","ucode":"49C01DBFADF101","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50940,"discussion_content":"看第二条评论，第二条是对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573790118,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":50903,"ip_address":""},"score":50940,"extra":""}]},{"author":{"id":1327343,"avatar":"https://static001.geekbang.org/account/avatar/00/14/40/ef/52bbadb9.jpg","nickname":"那就这样吧","note":"","ucode":"A1315C5EAF2917","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49817,"discussion_content":"每个类都继承Object，其他类有继承关系，这也只是链式继承吧，其实也就是单继承了，不会存在菱形问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573640990,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1593289,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","nickname":"编程界的小学生","note":"","ucode":"4A5BE9A5E877FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1327343,"avatar":"https://static001.geekbang.org/account/avatar/00/14/40/ef/52bbadb9.jpg","nickname":"那就这样吧","note":"","ucode":"A1315C5EAF2917","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49837,"discussion_content":"菱形问题确实不会存在，只是在想JAVA这样是不是也是多继承，只是隐式而已。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573643000,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":49817,"ip_address":""},"score":49837,"extra":""}]}]},{"had_liked":false,"id":150774,"user_name":"一周思进","can_delete":false,"product_type":"c1","uid":1032125,"ip_address":"","ucode":"00BE5402479B16","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bf/bd/0c40979f.jpg","comment_is_top":false,"comment_ctime":1573609251,"is_pvip":false,"replies":[{"id":"58367","content":"学一下java呗，也不难，周末有加餐文章，你可以跟着学下。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1573789669,"ip_address":"","comment_id":150774,"utype":1}],"discussion_count":2,"race_medal":3,"score":"10163543843","product_id":100039001,"comment_content":"搞C语言的咋整🤣","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474265,"discussion_content":"学一下java呗，也不难，周末有加餐文章，你可以跟着学下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573789669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1193874,"avatar":"https://static001.geekbang.org/account/avatar/00/12/37/92/961ba560.jpg","nickname":"授人以🐟，不如授人以渔","note":"","ucode":"BD53829E924B66","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50304,"discussion_content":"就我所知，使用 C 语言也可以实现类似 C++ 面向对象的代码结构。就比如 C 中的结构体，是 C++ 中的类。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573702007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150744,"user_name":"小先生","can_delete":false,"product_type":"c1","uid":1055214,"ip_address":"","ucode":"E5F2052E0323C0","user_header":"https://static001.geekbang.org/account/avatar/00/10/19/ee/e395a35e.jpg","comment_is_top":false,"comment_ctime":1573606519,"is_pvip":false,"replies":[{"id":"58368","content":"可能是我的个人习惯问题，我喜欢把URL在代码命名中写成Url。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1573789730,"ip_address":"","comment_id":150744,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10163541111","product_id":100039001,"comment_content":"王老师，讨论一个代码规范的方面。 getPictureUrl() 写成  getPictureURL() 会不会更好一些？","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474257,"discussion_content":"可能是我的个人习惯问题，我喜欢把URL在代码命名中写成Url。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573789730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1120238,"avatar":"https://static001.geekbang.org/account/avatar/00/11/17/ee/b123e7bc.jpg","nickname":"大胃王","note":"","ucode":"17072DCDB4C7FC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51890,"discussion_content":"URI包含URL","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573963839,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150739,"user_name":"醉比","can_delete":false,"product_type":"c1","uid":1248399,"ip_address":"","ucode":"79E65F62BE7809","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/8f/4ebd303a.jpg","comment_is_top":false,"comment_ctime":1573606097,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10163540689","product_id":100039001,"comment_content":"java不支持多继承，大致了解两个原因：1.如果继承打得多个父类有相同的成员变量，子类在引用的时候就无法区分。2.若果继承的多个父类有相通的方法，而子类又没有重新实现该方法，那么在使用该方法时就无法确定该去使用哪个方法。欢迎指正与补充～","like_count":2,"discussions":[{"author":{"id":2046331,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIfQFSpQJNKeqTicbpr3Rjo4VYdjE85QMWicMkoTCrGljg6GZcTjXFib1hSt8X9QuUfEuhMQCrdP15Aw/132","nickname":"crabxyj","note":"","ucode":"C5E2A8676B90C5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331585,"discussion_content":"现在你可以在接口里面添加default实现默认方法，从而实现多继承，只不过多继承后必须需要在子类实现，有冲突的接口","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606905927,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150692,"user_name":"allean","can_delete":false,"product_type":"c1","uid":1051470,"ip_address":"","ucode":"A0D2DB4F219EAA","user_header":"https://static001.geekbang.org/account/avatar/00/10/0b/4e/fd946cb2.jpg","comment_is_top":false,"comment_ctime":1573602503,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10163537095","product_id":100039001,"comment_content":"打卡","like_count":2},{"had_liked":false,"id":150676,"user_name":"LJK","can_delete":false,"product_type":"c1","uid":1199213,"ip_address":"","ucode":"12B2441099FF1D","user_header":"https://static001.geekbang.org/account/avatar/00/12/4c/6d/c20f2d5a.jpg","comment_is_top":false,"comment_ctime":1573593604,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10163528196","product_id":100039001,"comment_content":"一些自己查的内容：<br><br>对于Python的封装特性，用双下滑线标注的private变量其实内部只是重命名了一下而已，即<br><br>class A():<br>    def __init__(self):<br>        self.__private = &quot;Private&quot;<br><br>其中的__private在A的实例上可以通过&quot;_A__private&quot;来访问，这么看来的话Python的封装其实还是相对比较宽松的，不知道为什么这么设计。<br><br>对于多态，Python接口类是通过abc抽象类来实现的。<br><br>如有不对还请指正，多谢大家","like_count":2,"discussions":[{"author":{"id":1248280,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0c/18/bacf4b7a.jpg","nickname":"daniel李","note":"","ucode":"573840F0C6573E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49719,"discussion_content":"其实ruby也是相同情况，封装机制都是比较宽松。觉得很多动态语言都这样，其中一个好处是灵活性。很多框架都是通过这种灵活性来做的。\n\n所以这种较宽松的封装机制得靠程序员自律。听过一种说法，同层次的程序员，动态类语言比静态语言很容易写出烂代码。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573624111,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1123103,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/1f/6452b2e8.jpg","nickname":"刘清斌","note":"","ucode":"775B053AF87B53","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49576,"discussion_content":"Python这样设计，我感觉主要考虑约定大于配置的原则，大家遵循这样原则，双下滑线属于私有变量，不应该被直接调用。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573614717,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150650,"user_name":"Bug? Feature!","can_delete":false,"product_type":"c1","uid":1164531,"ip_address":"","ucode":"F8FA8A0094FBA0","user_header":"https://static001.geekbang.org/account/avatar/00/11/c4/f3/92f654f1.jpg","comment_is_top":false,"comment_ctime":1573574524,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10163509116","product_id":100039001,"comment_content":"沙发","like_count":2},{"had_liked":false,"id":325280,"user_name":"曾佳皓","can_delete":false,"product_type":"c1","uid":1909810,"ip_address":"","ucode":"2BDC9CDBD8A60F","user_header":"","comment_is_top":false,"comment_ctime":1638889323,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5933856619","product_id":100039001,"comment_content":"c++支持多继承，因为存在虚继承，可以避免钻石继承","like_count":1},{"had_liked":false,"id":300812,"user_name":"嗯。","can_delete":false,"product_type":"c1","uid":1563245,"ip_address":"","ucode":"30FC6EF9A01070","user_header":"https://static001.geekbang.org/account/avatar/00/17/da/6d/7c8fdb14.jpg","comment_is_top":false,"comment_ctime":1625394466,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5920361762","product_id":100039001,"comment_content":"1.Java只支持单继承。因为假设子类C继承了A、B两个父类，而A、B同时存在call()方法，当子类调用call()方法时，会产生冲突<br>2.Java完全支持这四种特性，如文章所说：<br>封装：通过private、public、protected访问权限修饰符<br>继承：extends关键字<br>多态：继承+重写，接口类<br>抽象：interface、abstract","like_count":1},{"had_liked":false,"id":285873,"user_name":"李叶","can_delete":false,"product_type":"c1","uid":1470449,"ip_address":"","ucode":"41B33FA8526E48","user_header":"https://static001.geekbang.org/account/avatar/00/16/6f/f1/35f9f16f.jpg","comment_is_top":false,"comment_ctime":1617062589,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5912029885","product_id":100039001,"comment_content":"封装：数据保护隐藏，通过访问权限控制，暴露必要方法；抽象：通过接口实现，只提供功能，不暴露细节，解决复用问题；继承：表示is-a关系，复用；多态：父类可以是子类的应用，解决扩展复用问题。","like_count":1},{"had_liked":false,"id":268450,"user_name":"Gabriel","can_delete":false,"product_type":"c1","uid":1437358,"ip_address":"","ucode":"714772A93E93DC","user_header":"https://static001.geekbang.org/account/avatar/00/15/ee/ae/855b7e6e.jpg","comment_is_top":false,"comment_ctime":1608201582,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5903168878","product_id":100039001,"comment_content":"PHP:<br>1：php 不支持多继承，用关键字 extends 来继承一个类。<br>2：php支持重写。子类修改父类的方法。<br>3：接口<br>     a：接口，可以指定某个类必须实现哪里方法，但不需要定义这些方法的具体内容<br>     b：接口使用过 Interface 关键字来定义的，就像定义一个标准的类一样，但其中定义所有的方法都是空的。<br>     c：接口中定义的所有方法都是必须公有， 这是接口特性。<br>     d：要实现一个接口，使用implements操作符，类中必须实现接口中定义的所有方法，否则会报一个致命错误。<br>抽象类：任何一个类，如果它里面至少有一个方法被声明为抽象的，那么这个类就必须是抽象类。定义的抽象类不能被实例化。被定义为抽象的方法只是声明了其调用方式（参数），不能定义具体功能实现。继承一个抽象类的时候，子类必须定义父类中所有的抽象方法。这些方法的访问控制必须和父类中的一样（或者更宽松）<br>","like_count":1},{"had_liked":false,"id":260095,"user_name":"大魔王嗷呜","can_delete":false,"product_type":"c1","uid":1888220,"ip_address":"","ucode":"D6F0EA8E4A608B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/fRVxJWw4SfXbfIHHdVzrQsicfPSF1Ektv3dYaSNTlKo4xq62f1457see877ET6on206ls0dkemujob6ZK9ZAUIQ/132","comment_is_top":false,"comment_ctime":1604923170,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5899890466","product_id":100039001,"comment_content":"没有人用golang嘛，来总结下golang对面向对象的支持：<br>1. 封装：<br>变量，函数根据大小写字母判定是否可以被外部包调用<br>2. 继承<br>木有继承，用组合代替继承（组合匿名结构体，可直接在外部调用该结构体的方法，使用它的成员变量<br>3. 多态<br>用interface实现（只要实现了interface，就可以被用在适用于该接口的任何地方<br>4. 抽象 <br>无处不在","like_count":1},{"had_liked":false,"id":254630,"user_name":"Kingram","can_delete":false,"product_type":"c1","uid":2247700,"ip_address":"","ucode":"212E403E81F2FC","user_header":"https://static001.geekbang.org/account/avatar/00/22/4c/14/8fa39544.jpg","comment_is_top":false,"comment_ctime":1603160305,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5898127601","product_id":100039001,"comment_content":"1.Go语言支持多继承,为了防止多个父类的函数相同导致调用错误,可以使用子类对象.父类名.函数名的方式调用.<br>2.Go语言实现四大特性的机制如下:<br>1)封装:结构体内首字母大写字段可以对外暴露,包内首字母大写的函数和字段都可以对外暴露,小写则隐藏<br>2)继承:结构体内写父类名实现继承父类,实现接口的函数则继承接口<br>3)抽象:interface语法支持<br>4)多态:interface语法支持","like_count":1},{"had_liked":false,"id":248965,"user_name":"曙光","can_delete":false,"product_type":"c1","uid":1476450,"ip_address":"","ucode":"04D65BF7F19845","user_header":"https://static001.geekbang.org/account/avatar/00/16/87/62/f99b5b05.jpg","comment_is_top":false,"comment_ctime":1600392524,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5895359820","product_id":100039001,"comment_content":"思考题：<br>1 使用Java，没有多重继承，如果支持多重继承，那a1继承A1,b1，b1继承 A1，问a1和b1是兄弟关系还是父子关系（两层就乱了）。单继承就是避免这种层次不清的方法。<br>2  java有现成的语法支持四大特性。<br>封装：public, private, protect关键字,  <br>抽象：抽象类，抽象方法，编写函数<br>继承：继承类 extend ，实现接口 implements<br>多态：支持继承；父类引用指向子类对象；可重写（override）父类方法；","like_count":1},{"had_liked":false,"id":246776,"user_name":"WilliamVector","can_delete":false,"product_type":"c1","uid":1898112,"ip_address":"","ucode":"E0D3C3D4FCB7C9","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f6/80/85ec2c2a.jpg","comment_is_top":false,"comment_ctime":1599475639,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5894442935","product_id":100039001,"comment_content":"1、关于封装特性：封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。它需要编程语言提供权限访问控制语法来支持，例如 Java 中的 private、protected、public 关键字。封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。<br>2、关于抽象特性：封装主要讲如何隐藏信息、保护数据，那抽象就是讲如何隐藏方法的具体实现，让使用者只需要关心方法提供了哪些功能，不需要知道这些功能是如何实现的。抽象可以通过接口类或者抽象类来实现，但也并不需要特殊的语法机制来支持。抽象存在的意义，一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。<br>3、继承是用来表示类之间的 is-a 关系，分为两种模式：单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类。为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持。继承主要是用来解决代码复用的问题。<br>4、关于多态特性：多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类、duck-typing。多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。<br>【思考】<br>1、Java不支持多重继承，因为当两个父类中有同名方法时，会不知道调用哪一个。C++支持多继承，同名方法，C++可以通过::指定具体的类来避免歧义。<br>2、Java中的封装通过类的public、private、protected权限控制实现，抽象通过interface来实现，继承通过extends、implements来实现，多态通过interface和implements实现。C++中的封装通过类的public、private、protected权限控制实现，抽象通过包含虚函数(virtual)实现，继承通过:实现，多态通过继承和类型转换实现。","like_count":1},{"had_liked":false,"id":216951,"user_name":"刘同青","can_delete":false,"product_type":"c1","uid":1818343,"ip_address":"","ucode":"84B62DF8BC61FB","user_header":"","comment_is_top":false,"comment_ctime":1589375107,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5884342403","product_id":100039001,"comment_content":"<br><br><br><br>课后题：<br><br>你熟悉的编程语言是否支持多重继承？如果不支持，请说一下为什么不支持。如果支持，请说一下它是如何避免多重继承的副作用的。<br><br>java不支持多继承。为了防止菱形继承的副作用，假设支持多继承，B类和C类继承了A类，并重写方法 fun1()，那么如果D类同时继承了B类和C类，那么调用D类对象的方法fun1()时，是执行B类中的方法还是C类的方法呢？<br><br>C++支持多继承，可以在调用方法时指定父类以避免二义性，但是这种方式会降低方法的易用性。<br><br>学习笔记：抽象封装继承多态可以解决什么问题<br><br>1、封装<br><br>解释：信息隐藏或者数据访问保护，类通过暴露有限的访问接口，授权外部通过这些合理的接口对类进行访问。需要编程语言提供访问权限控制的语法，比如java提供private protected public<br><br>作用：相比可以对类的属性随意进行set来说，对类进行封装的优点是：<br><br>（1）易读。外部仅能通过有限的接口访问，而且一般还有明确的含义。<br><br>（2）易用。使用者不需要对所有属性都关注，而且要小心的set,，封装后可以大胆的调用。<br><br>（3）安全。如果随意修改，可能造成数据不一致。<br><br>2、抽象<br><br>解释：隐藏方法实现细节，调用者只需要关注方法有什么功能，不需要了解方法的实现。常常通过编程语言的接口类和抽象类来实现抽象，比如java中的interface接口类和abstract抽象类。实际上单纯的一个函数也是抽象，因为调用函数时不需要关注函数体，而只需要根据函数的注释了解其功能，然后就可以使用了。<br><br>作用：通过抽象可以屏蔽实现细节，使问题聚焦，是处理复杂问题的有效手段<br><br>注意：在定义类、接口或者命令函数的时候也要有抽象思维，名字不要暴露太多的实现细节，以提高名称的稳定性，以保证在未来改变方法实现逻辑的时候，名字不用变。<br><br><br><br>3、继承<br><br>解释：表示类之间 is a 的关系，java为了避免菱形问题所以仅仅支持单继承。<br><br>作用：代码复用。<br><br>注意点：继承层次过深，会导致代码的可读性可维护性变差，为了 了解一个子类的功能，不仅需要查看这个类，还需要按照继承关系一层一层的向上查看；子类和父类高度耦合，修改父类的代码会直接影响到子类。<br><br><br><br>4、多态<br><br>解释：父类变量可以指向子类对象，后者说接口变量可以指向实现类对象，通过继承+方法重写和接口+方法实现来实现多态。<br><br>作用：提高代码的扩展性和复用性。<br><br>（1）因为父类或者接口类一般都是比较抽象的，越抽象越远离具体实现的类或接口越稳定，所以客户端使用父类或者接口变量进行开发，而不去关注易变的具体子类或者接口实现类，这样在需要替换子类或者实现类的时候，不需要大动干戈的修改原有代码，这就是扩展性。<br><br>（2）如果一个方法的参数是抽象的父类或接口，那可以传入任意的子类对象或者接口实现类，让这个方法的复用性更好。<br><br>课后题","like_count":1},{"had_liked":false,"id":203509,"user_name":"Geek_032104","can_delete":false,"product_type":"c1","uid":1298282,"ip_address":"","ucode":"25542A2348F99F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/G61OS6hibNG7iakUmXeKmcY5VtFWnPpywzjOcUCm3t0HsibCibm3jzLNbdvjKQ8G8WSIkicBiaqoCsvHibn3M7wV4YbrA/132","comment_is_top":false,"comment_ctime":1586223651,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5881190947","product_id":100039001,"comment_content":"抽象不只是隐藏方法细节。决定一个类里边应该具备哪些属性和方法，这也是抽象。","like_count":1},{"had_liked":false,"id":190274,"user_name":"Nick","can_delete":false,"product_type":"c1","uid":1921287,"ip_address":"","ucode":"64BBE005890845","user_header":"https://static001.geekbang.org/account/avatar/00/1d/51/07/b5a945b6.jpg","comment_is_top":false,"comment_ctime":1584625478,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879592774","product_id":100039001,"comment_content":"重新回顾了面向对象的4大特性，争哥讲的很透彻，值得反复阅读和理解，对于刚入职场的同学，面试的时候也很有帮助。","like_count":1},{"had_liked":false,"id":177530,"user_name":"nightn","can_delete":false,"product_type":"c1","uid":1026818,"ip_address":"","ucode":"39FC4FF0281637","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ab/02/8688abed.jpg","comment_is_top":false,"comment_ctime":1581411250,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5876378546","product_id":100039001,"comment_content":"结合本节内容谈谈 C++ 对四大特性的支持。<br>（1）C++ 对封装的支持。通过访问控制符（public, protected, private）实现了对 class 成员的封装。与 Java 不同的是，C++ 还允许对继承进行访问控制，支持 public 继承、protected 继承和 private 继承，从而将封装的场景从单一类扩展到整个继承体系。<br>（2）C++ 对抽象的支持。函数是最基本的抽象，此外，C++ 虽然不支持 interface，但一个只含纯虚函数的 class 就相当于 Java 中的一个接口类，利用它可以将一组公共操作抽象出来，由各个子类去完善实现细节。<br>（3）C++ 对继承的支持。C++ 支持多重继承，但如果不是非常必要，一般不推荐使用。多重继承的一个副作用是在菱形继承中，最底下的子类的实例会存放重复数据成员，造成存储空间浪费和二义性问题，C++ 使用了虚基类避免了这个问题。<br>（4）C++ 对多态的支持。通过虚函数机制实现多态，子类可以重写父类虚函数。该语法特性是由虚表虚指针实现的。","like_count":1},{"had_liked":false,"id":160928,"user_name":"万历十五年","can_delete":false,"product_type":"c1","uid":1122150,"ip_address":"","ucode":"3D8CF5DF847AE8","user_header":"https://static001.geekbang.org/account/avatar/00/11/1f/66/59e0647a.jpg","comment_is_top":false,"comment_ctime":1576062540,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5871029836","product_id":100039001,"comment_content":"“抽象”这一词并不是编程语言特有的，实际上我们在日常生活中每时每刻都在使用。<br>“抽象”就是对事物或事件的一个命名，是一种信息封装单元，它使人们传递信息更加方便，提高了沟通效率。<br>同时“抽象”也是有力度之分的，比如：<br>getUrl(), <br>getPicureUrl(),<br>getAliyunPictureUrl()<br>结合不同的业务场景，“抽象”力度的强弱就有了不同的适用范围。<br><br>","like_count":1},{"had_liked":false,"id":155939,"user_name":"被讨厌的勇气","can_delete":false,"product_type":"c1","uid":1547913,"ip_address":"","ucode":"AE3B3CA27D91A2","user_header":"https://static001.geekbang.org/account/avatar/00/17/9e/89/6e9c05d6.jpg","comment_is_top":false,"comment_ctime":1574780511,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869747807","product_id":100039001,"comment_content":"C++支持多重继承，C语言的设计宗旨有一条是相信程序员，而C++兼容C，也相信程序员，C++中虚继承来解决菱形继承问题。<br><br>C++提供访问权限控制来支持封装特性；C++中可以定义抽象类；支持单继承、多重继承；C++中，指向基类的指针或引用可以其派生类，且支持方法重写。<br><br>##坚持打卡##<br><br>封装（信息隐藏、数据保护），定义：类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或数据。语法机制：访问权限控制。作用：可维护性、易用性（降低心智负担）。示例，虚拟钱包。<br><br>抽象，平时所提到的抽象是指与具体事物关联比较少，如人名是一种抽象，从另一角度看，抽象可以隐藏具体实现。语法支持：抽象类、接口类、函数、命名（具有通用性，与具体事物关联少）。意义：可维护性、。示例，图片云存储。<br><br>继承，子类可以复用父类中的属性和方法，表示is-a关系。语法支持：C++中：，Java中extends。意义，代码复用。<br><br>多态，子类可以替换掉父类。语法支持：父类可以引用子类、继承、方法重写；接口类；动态语言中Duck Typing。意义：可扩展性、可复用性。示例，Array、Iterator。<br><br>争哥讲的清晰明了。","like_count":1},{"had_liked":false,"id":154385,"user_name":"zeta","can_delete":false,"product_type":"c1","uid":1255260,"ip_address":"","ucode":"AF84A72375827C","user_header":"https://static001.geekbang.org/account/avatar/00/13/27/5c/ee2a876f.jpg","comment_is_top":false,"comment_ctime":1574420398,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869387694","product_id":100039001,"comment_content":"\t第一，个人理解其实多重继承不存在技术问题（C++能实现且正常使用其他的肯定也可以实现且正常使用）。但是像JAVA这种标榜自己是纯面向对象语言的语言来说，多重继承是否实现is a的语义呢？拿一个C++中举的多重继承例子来说，吸血鬼分别继承自蝙蝠和人，那么吸血鬼is a蝙蝠么？吸血鬼is a人么？所以其实两个都不是，这就是设计上的语义问题。这里缺失了除了is a的另一个概念，behaves like，也就是多重继承的真义实际上是behaves like，也就是接口的意义。A vampire behaves like humans and bats. 而这是接口能多重的原因，一个类可以具有多重行为，但是不能是多种东西。<br>\t第二，最近学了Rust，结合说一下<br>\t\t封装：Rust有公共和私有方法<br>\t\t抽象：Rust 有基于Struct, Enum, Traits（类似抽象类和接口的结合体，可以多重继承，可以有抽象方法）的抽象，比较多样。<br>\t\t继承：Rust没有继承特性，只有实现Traits，提倡用组合代替继承<br>\t\t多态：Rust官方教程就提到过，Rust不支持多态，所以Rust不是一个严格意义上的面向对象语言。但其实Rust有迂回的办法达成这个，类似duck-typing。","like_count":1},{"had_liked":false,"id":153388,"user_name":"前端西瓜哥","can_delete":false,"product_type":"c1","uid":1248576,"ip_address":"","ucode":"150130C34CD1C1","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/40/f70e5653.jpg","comment_is_top":false,"comment_ctime":1574228747,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869196043","product_id":100039001,"comment_content":"1. javaScript。不支持多重继承。我觉得可能是因为语言定位原因：浏览器的简单脚本。所以js在设计时，语法要尽量简单，选择了单继承。另外 js 的继承还是简单的原型链继承。<br><br>2. javaScript。（1）封装，没有现成支持，不支持私有属性。js 要实现封装，目前方案也很多：命名约定、WeakMap、Symbol、闭包、Proxy、使用ts、# 声明（提案）（2）抽象，支持。（3）继承，支持原型链继承（4）多态，可以用继承，也可以用鸭子类型，某种意义上的面向方法编程，因为js是弱类型语言。","like_count":1},{"had_liked":false,"id":151953,"user_name":"王加武","can_delete":false,"product_type":"c1","uid":1665471,"ip_address":"","ucode":"DDCFE578C6C428","user_header":"https://static001.geekbang.org/account/avatar/00/19/69/bf/50a824a4.jpg","comment_is_top":false,"comment_ctime":1573820782,"is_pvip":false,"replies":[{"id":"60032","content":"是不一样的。我的意思是如果java语言中没有访问控制权限的语法，就是没有private、public、protected、default。。。这是一个假设...","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1574854275,"ip_address":"","comment_id":151953,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5868788078","product_id":100039001,"comment_content":"我学习的是JAVA<br>JAVA是不支持多继承的，<br>JAVA实现了封装，继承，多态，抽象等四大特性，是真正意义上的面向对象编程语言<br>我有一点疑惑，就您说的访问权限控制符那里，您说的“如果 Java 语言没有提供访问权限控制语法，所有的属性默认都是 public 的”，这恐怕是不对的吧，我在其他的教程上看到的是default,我也试了一下，确实是default.<br>因为default和public的权限是不一样的。<br>public:所有的类都可以访问<br>default:只有本身的类,子类，还有这个类所在的包中的所有的类可以访问<br>这两个的权限是不一样的！<br>这是我的疑惑，还请老师解释一下！","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474666,"discussion_content":"是不一样的。我的意思是如果java语言中没有访问控制权限的语法，就是没有private、public、protected、default。。。这是一个假设...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574854275,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151749,"user_name":"赵宇浩","can_delete":false,"product_type":"c1","uid":1102850,"ip_address":"","ucode":"571C1B03858F67","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/02/ad82f59a.jpg","comment_is_top":false,"comment_ctime":1573784744,"is_pvip":false,"replies":[{"id":"58345","content":"感觉还是一种数据驱动或者db驱动的设计思维方式。实际上，对于一些复杂业务逻辑的开发，db中数据的读和存只是很小的一部分。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1573786156,"ip_address":"","comment_id":151749,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5868752040","product_id":100039001,"comment_content":"最近在探索DDD的时候有个问题，当涉及db或api时该怎么设计。<br>比如你上面提到的账户调增，理论上有个人的账户都会有个新的对象，但假如调增要调用api，那这个api需要这个账户类持有么？那每次创建对象还要set进去？感觉不是很舒服。。","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474600,"discussion_content":"感觉还是一种数据驱动或者db驱动的设计思维方式。实际上，对于一些复杂业务逻辑的开发，db中数据的读和存只是很小的一部分。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573786156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151573,"user_name":"筱乐乐哦","can_delete":false,"product_type":"c1","uid":1307611,"ip_address":"","ucode":"AE92539F0419C3","user_header":"https://static001.geekbang.org/account/avatar/00/13/f3/db/5b7a8fd8.jpg","comment_is_top":false,"comment_ctime":1573741883,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5868709179","product_id":100039001,"comment_content":"哈哈，老师写的很好，多态那，我又去复习了下下jvm的加过程，感觉又进一步理解了，老师赶紧更新吧，饥渴难耐啊","like_count":1},{"had_liked":false,"id":151166,"user_name":"村长","can_delete":false,"product_type":"c1","uid":1218960,"ip_address":"","ucode":"AB8B2B79387D11","user_header":"https://static001.geekbang.org/account/avatar/00/12/99/90/ca2a8632.jpg","comment_is_top":false,"comment_ctime":1573659989,"is_pvip":false,"replies":[{"id":"58188","content":"😄 马上会讲到 如何用抽象类模拟接口","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1573690531,"ip_address":"","comment_id":151166,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5868627285","product_id":100039001,"comment_content":"cpp的虚基类都不加实现不就是接口么","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474389,"discussion_content":"😄 马上会讲到 如何用抽象类模拟接口","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573690531,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150987,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1015754,"ip_address":"","ucode":"00DF2FEC58D2E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","comment_is_top":false,"comment_ctime":1573638604,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5868605900","product_id":100039001,"comment_content":"这节课程虽然对于有编程经验的人来说很容易理解，但是读完后能感受到老师清晰的解读思路，赞！","like_count":1},{"had_liked":false,"id":150813,"user_name":"小喵喵","can_delete":false,"product_type":"c1","uid":1062444,"ip_address":"","ucode":"FDBBB2A59DB8B6","user_header":"https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg","comment_is_top":false,"comment_ctime":1573612999,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5868580295","product_id":100039001,"comment_content":"我们常常听到这样一句话：面向接口编程，而不是实现编码。我举例一下，原谅我拿阿猫阿狗举例<br> interface Animal<br>    {<br>        void Eat();<br>    }<br>    public class Dog : Animal<br>    {<br>        public void Eat()<br>        {<br>            &#47;&#47;print dog eat bone.<br>        }<br>    }<br>    public class Cat : Animal<br>    {<br>        public void Eat()<br>        {<br>            &#47;&#47;cat eat fish<br>        }<br>    }<br>    public class DemoTest<br>    {<br>        public  void Test()<br>        {<br>            &#47;&#47;接口来调用<br>            Animal dog = new Dog();<br>            dog.Eat();<br>            Animal cat = new Cat();<br>            cat.Eat();<br>            &#47;&#47;class来调用<br>            Dog dog = new Dog();<br>            dog.Eat();<br>            Cat cat = new Cat();<br>            cat.Eat();<br>        }<br>    }<br>我还是没有完全理解，觉得面向接口编程反而增加了更多的代码（比如单独定义interface Animal）。上端程序使用的时候也需要知道具体的Animal(比如 Animal dog = new Dog())。也是实例化一个Dog然后赋值给Animal的。为什么不觉得直接来使用Dog dog = new Dog()。这样还可以去掉Interface Animal了。","like_count":1,"discussions":[{"author":{"id":1220617,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a0/09/4af6ff52.jpg","nickname":"Six","note":"","ucode":"E297BB638B2BD9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214559,"discussion_content":"兄弟，这样做是有好处的，方便扩展和复用(这个复用就是定义一个接受Animal参数的方法或者类)，好好理解下作者多态中举的例子","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585208131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1087243,"avatar":"https://static001.geekbang.org/account/avatar/00/10/97/0b/a943bcb3.jpg","nickname":"zhou","note":"","ucode":"E1CE8575B3F106","race_medal":3,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52894,"discussion_content":"你想想Spring的依赖注入，你根本不用考虑接口怎么实现的，你调用只用使用接口调用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574090806,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150804,"user_name":"xavier","can_delete":false,"product_type":"c1","uid":1243128,"ip_address":"","ucode":"2F7918EA37ED9F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f7/f8/3c0a6854.jpg","comment_is_top":false,"comment_ctime":1573611914,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5868579210","product_id":100039001,"comment_content":"封装这里的解释，让我联想到 less is more 这句话。<br>less是对使用者而言。像封装一样，仅提供关键的方法给使用者。<br>more是对设计者而言。为了实现封装特性，封装内部会做大量处理。","like_count":1},{"had_liked":false,"id":150749,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1573606883,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5868574179","product_id":100039001,"comment_content":"设计模式05：<br>- Java不支持多继承，弊端之一的菱形问题就不赘述了，我认为多继承带来的另外一个问题就是复杂性的增加，我们在写程序之前，常常会按照**接口-&gt;抽象类-&gt;实现类-&gt;拓展实现类**这样的模式，这样设计出来的一组类是与某一个“业务”强相关的，如果可以多继承，以上流程就可以在任一环节继承其他一组类，这样的设计会造成更高的复杂性与耦合性，之后理解与维护的成本会更高。","like_count":1},{"had_liked":false,"id":360797,"user_name":"ipofss","can_delete":false,"product_type":"c1","uid":1018620,"ip_address":"上海","ucode":"DE3061C9259F9E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/fc/d1dd57dd.jpg","comment_is_top":false,"comment_ctime":1666858965,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1666858965","product_id":100039001,"comment_content":"面向对象的4大特性的深度解读，以后再面试时也不至于干巴巴的回答了，并且对于自己日常开发也加深了理解","like_count":0},{"had_liked":false,"id":360180,"user_name":"Geek_98ea8d","can_delete":false,"product_type":"c1","uid":3205000,"ip_address":"北京","ucode":"A535420E63F385","user_header":"","comment_is_top":false,"comment_ctime":1666256383,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1666256383","product_id":100039001,"comment_content":"太强了","like_count":0},{"had_liked":false,"id":359482,"user_name":"Will Zhang","can_delete":false,"product_type":"c1","uid":3197012,"ip_address":"上海","ucode":"294B06E7EFEB18","user_header":"https://static001.geekbang.org/account/avatar/00/30/c8/54/8d27cb56.jpg","comment_is_top":false,"comment_ctime":1665566790,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665566790","product_id":100039001,"comment_content":"python<br>封装：没有硬性要求，而是一种约定<br>没用_标记的一般都是公开属性和公开方法<br>前面有_的属性和方法被认为是受保护的，可以直接修改<br>前面有__的属性和方法也被认为是受保护的，不能直接修改，但是可以通过一些手段修改<br>前面和后面都有__的方法是内部方法，一般不让用<br>继承：支持多继承，使用MRO列表解决菱形问题<br>python通过C3算法生成一个MRO列表，如果当期类的名称空间没有该属性时会去依次查找MRO列表的下一个元素的名称空间，通过该方法实现继承的代码复用。<br>多态：<br>python为什么支持不继承相同父类的多态（python叫鸭子类型）<br>python是动态语言，一切皆对象，python不管一个变量到底是什么类型，因为它可以是任何类型，当程序运行到这一步的时候就看一下它有没有这个方法或属性，有就调用，没有就报错，就这么拽。","like_count":0},{"had_liked":false,"id":357614,"user_name":"陈威洋","can_delete":false,"product_type":"c1","uid":2264679,"ip_address":"广东","ucode":"DCF84B4D3A7354","user_header":"https://static001.geekbang.org/account/avatar/00/22/8e/67/afb412fb.jpg","comment_is_top":false,"comment_ctime":1663487168,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663487168","product_id":100039001,"comment_content":"那么为什么Java不支持 多继承？<br>这就是“多继承的钻石问题”。<br>类 B 和类 C 继承自类 A，且都重写了类 A 中的同一个方法，而类 D 同时继承了类 B 和类 C，那么此时类 D 会继承 B、C 的方法，那对于 B、C 重写的 A 中的方法，类 D 会继承哪一个呢？这就是 多继承 会导致这种有歧义的情况存在。","like_count":0},{"had_liked":false,"id":355931,"user_name":"Stay_Gold","can_delete":false,"product_type":"c1","uid":1119904,"ip_address":"北京","ucode":"ACB8DCD2EF8F95","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJRCtuJkpyy2NTTABPFibg2k9tZscOOKx9wu80a85d5HspCorO9Nibj7Z7q9v1icPTVm5ia52r0RCzEaA/132","comment_is_top":false,"comment_ctime":1661856736,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661856736","product_id":100039001,"comment_content":"先总结一下今天学到的知识<br>1.封装：封装是对实现细节的隐藏，可以是提高代码的安全性和易用性。<br>2.抽象：抽象是对对象特征的提取，在不同的层次有不同的抽象。抽象和封装的区别是抽象是提取共性，封装是隐藏细节。<br>3.继承：继承是is...a关系，即是什么东西是什么的关系，可以提高代码的可复用性。<br>4.多态：多态是父类能直接指向子类的引用地址，可以提高代码的可扩展性和复用性。<br>问题<br>一.你熟悉的编程语言是否支持多重继承？如果不支持，请说一下为什么不支持。如果支持，请说一下它是如何避免多重继承的副作用的。<br>我个人比较熟悉的是c#和java，都是不支持对类的多重继承的，只支持接口的多重继承。我想不支持的原因，还是觉得多重继承，不管是调用方法还是实现多态特性的时候都容易产生歧义，不知道具体去执行那个实例或者方法。或者说需要很多额外的工作去保证避免这些场景。<br><br>二.你熟悉的编程语言对于四大特性是否都有现成的语法支持？对于支持的特性，是通过什么语法机制实现的？对于不支持的特性，又是基于什么原因做的取舍？<br>熟悉的后端语言：c# java,都支持面向对象的四大特性，实现的机制如下<br>封装：通过访问权限的控制来实现的。<br>抽象：抽象可以说通过接口或者抽象类来实现，也可以说语言本身其实都是有抽象特性的。<br>继承：继承的实现原理应该还是通过继承关键字把两者的引用地址关联起来了<br>多态：多态是继承+重写+父类能指向子类的引用<br>","like_count":0},{"had_liked":false,"id":351741,"user_name":"R","can_delete":false,"product_type":"c1","uid":2172520,"ip_address":"","ucode":"3721FC8C8DE174","user_header":"https://static001.geekbang.org/account/avatar/00/21/26/68/b86dc4df.jpg","comment_is_top":false,"comment_ctime":1658143014,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1658143014","product_id":100039001,"comment_content":"本节的案例都实现了一遍，源码如下：<br>https:&#47;&#47;gitee.com&#47;RingoTangs&#47;java-review&#47;tree&#47;master&#47;design-pattern&#47;part01&#47;src&#47;main&#47;java&#47;com&#47;nssc&#47;design","like_count":0},{"had_liked":false,"id":350950,"user_name":"SICUN","can_delete":false,"product_type":"c1","uid":1254261,"ip_address":"","ucode":"22A384904EB9E9","user_header":"https://static001.geekbang.org/account/avatar/00/13/23/75/2b599841.jpg","comment_is_top":false,"comment_ctime":1657385366,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657385366","product_id":100039001,"comment_content":"1. php不支持多继承，如果多继承时子类调用多个父类都有方法时会产生模凌两可的状况，感觉多继承收益和需要处理的付出不是很划算，可通过实现多个接口或者trait实现类似多继承的效果<br>2.php支持四大特性：<br>封装：public protected private<br>抽象：interface，abstract<br>继承：extend<br>多态：继承，方法覆盖，父类子类可互相调用，后期静态绑定","like_count":0},{"had_liked":false,"id":349508,"user_name":"三生","can_delete":false,"product_type":"c1","uid":1606669,"ip_address":"","ucode":"1DE1A2693A5E33","user_header":"https://static001.geekbang.org/account/avatar/00/18/84/0d/4e289b94.jpg","comment_is_top":false,"comment_ctime":1656031249,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1656031249","product_id":100039001,"comment_content":"python没有接口，而是采用多继承和抽象类来代替接口，多继承也是一种代码复用的方式","like_count":0},{"had_liked":false,"id":345725,"user_name":"姚钫","can_delete":false,"product_type":"c1","uid":1498146,"ip_address":"","ucode":"ECB8B0627A4F9B","user_header":"https://static001.geekbang.org/account/avatar/00/16/dc/22/41a390ae.jpg","comment_is_top":false,"comment_ctime":1652526216,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652526216","product_id":100039001,"comment_content":"220513 day04 四大特性<br>1.存在的意义和目的,解决了哪里编程问题<br>what&#47;how&#47;why<br>封装是对数据提供必要的操作接口，屏蔽可能能出现的异常，保证安全<br>继承解决代码复用<br>多态是对未来代码依旧可用<br>抽象是对场景业务及很多场景以及现实世界的抽象<br>q:你熟悉的编程语言是否支持多重继承？如果不支持，请说一下为什么不支持。如果支持，请说一下它是如何避免多重继承的副作用的。<br>a:不支持,因为如果继承的两个类都是非抽象的类并且方法也是非抽象的,子类调用父类方法的时候不知道用谁的, C++好像支持,需要强制重写两个父类共有的方法<br>q:你熟悉的编程语言对于四大特性是否都有现成的语法支持？对于支持的特性，是通过什么语法机制实现的？对于不支持的特性，又是基于什么原因做的取舍？<br>a:我熟悉的是Java,这四大特性都有,语法机制:封装是通过关键字private protect和public,抽象是abstract,继承和实现是extends和implements,多态是利用继承或实现来实现父类引用指向子类对象","like_count":0},{"had_liked":false,"id":342153,"user_name":"myfff","can_delete":false,"product_type":"c1","uid":1223008,"ip_address":"","ucode":"71C5ACC21816F2","user_header":"https://static001.geekbang.org/account/avatar/00/12/a9/60/efaa1dee.jpg","comment_is_top":false,"comment_ctime":1650073260,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650073260","product_id":100039001,"comment_content":"对于 抽象 的运用，在有些文章中要求每个对象的行为描述尽量准确，也就是对象的方案命名尽量准确。而有时候我们认为适当的抽象能让方法有更强的通用和适应性(比如接口的覆盖场景变广后)。 不知道作者怎么看待这个问题","like_count":0},{"had_liked":false,"id":339776,"user_name":"八声甘州","can_delete":false,"product_type":"c1","uid":2019483,"ip_address":"","ucode":"BCE59119BEABBE","user_header":"https://static001.geekbang.org/account/avatar/00/1e/d0/9b/101cbd95.jpg","comment_is_top":false,"comment_ctime":1648375268,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1648375268","product_id":100039001,"comment_content":"go:<br>封装：变量名或方法名、函数名 首字母大写包内可见，反之不可见<br>抽象：接口（interface）类型<br>继承：结构体组合<br>多态：接口、ducktyping","like_count":0},{"had_liked":false,"id":338214,"user_name":"金旭","can_delete":false,"product_type":"c1","uid":1644194,"ip_address":"","ucode":"2FE7B4B8CE4A07","user_header":"https://static001.geekbang.org/account/avatar/00/19/16/a2/789d296e.jpg","comment_is_top":false,"comment_ctime":1647355009,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647355009","product_id":100039001,"comment_content":"golang这里应该属于课程中说的：接口类实现吧。<br>interface类型算是“接口类”，一个类需要实现接口类中定义的全部方法，那么该类的实例就可以赋值给接口类变量，接口类变量会调用相应类中的接口实现。<br>好处是：有了类似动态类型语言ducktyping的书写简洁性（避免了声明），又可以实现编译期间的静态检查-满足了安全性","like_count":0},{"had_liked":false,"id":331028,"user_name":"百炼钢","can_delete":false,"product_type":"c1","uid":1590695,"ip_address":"","ucode":"71A20C3C0B2978","user_header":"https://static001.geekbang.org/account/avatar/00/18/45/a7/da9b2d2b.jpg","comment_is_top":false,"comment_ctime":1642385355,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642385355","product_id":100039001,"comment_content":"新语言都没再提供复杂的封装（private, protected, default, public）了，比如 dart 就用 _ 前缀表示私有；钱包数据要保存到数据库，下次取出时还是要赋值，不给 id 赋值方法也不合理，当然在这篇讲解封装的文中是合适的；现在的语言更强调不可变：用 final , const 来修饰类属性，赋值之后就不再变化了。kotlin中创建的类都是默认final的，除非声明时提供 open 前缀，否则没法被继承。最近有学习dart和kotlin，有此感想……","like_count":0},{"had_liked":false,"id":324255,"user_name":"王智","can_delete":false,"product_type":"c1","uid":1337016,"ip_address":"","ucode":"37D2AD591C1AEC","user_header":"https://static001.geekbang.org/account/avatar/00/14/66/b8/ece79234.jpg","comment_is_top":false,"comment_ctime":1638349667,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1638349667","product_id":100039001,"comment_content":"第一题：<br>* java。不显式支持，但是可以通过内部类变相支持。 <br>* 不知道。大概是符合“单继承、多实现”吧。<br>第二题：<br>* java。都有。<br>* 封装：函数、访问控制修饰符实现；继承：extends关键字；多态：重写。","like_count":0},{"had_liked":false,"id":321672,"user_name":"Z宇锤锤","can_delete":false,"product_type":"c1","uid":2188142,"ip_address":"","ucode":"7DB36E986A7A51","user_header":"https://static001.geekbang.org/account/avatar/00/21/63/6e/6b971571.jpg","comment_is_top":false,"comment_ctime":1636987556,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1636987556","product_id":100039001,"comment_content":"面向对象四大块：抽象继承和多态，还有一个封装。<br>抽象：关注方法<br>继承：is a结构优美<br>多态：方法复用<br>封装：隔离外部环境","like_count":0},{"had_liked":false,"id":321278,"user_name":"探雪","can_delete":false,"product_type":"c1","uid":2833619,"ip_address":"","ucode":"2332650D9C8D54","user_header":"https://static001.geekbang.org/account/avatar/00/2b/3c/d3/fab9d588.jpg","comment_is_top":false,"comment_ctime":1636733645,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636733645","product_id":100039001,"comment_content":"自古评论出人才","like_count":0},{"had_liked":false,"id":318908,"user_name":"Geek_c46527","can_delete":false,"product_type":"c1","uid":2800355,"ip_address":"","ucode":"3C6008B6BC999F","user_header":"","comment_is_top":false,"comment_ctime":1635478542,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635478542","product_id":100039001,"comment_content":"封装：隐藏信息，保护数据，提供给定的统一方式去访问数据<br>抽象：隐藏方法的具体实现，提供调用者方法能解决什么问题<br>继承：is-a的一种关系，单继承和多继承，多继承会产生选择继承相同方法的选择问题，继承可以代码复用<br>多态：父类引用指向子类对象的操作，提高代码的扩展性，继承+方法重写或接口类实现","like_count":0},{"had_liked":false,"id":315729,"user_name":"刘博","can_delete":false,"product_type":"c1","uid":1992973,"ip_address":"","ucode":"F00AA3B3200BBE","user_header":"https://static001.geekbang.org/account/avatar/00/1e/69/0d/0a2fd71e.jpg","comment_is_top":false,"comment_ctime":1633955280,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633955280","product_id":100039001,"comment_content":"个人理解：封装是访问权限控制，定义类的时候通过暴露一些必要的修改函数，获取数据函数，保证类的稳定性以及易用性。继承提高代码复用，尽量少的去定义一些具有相同功能的类，但是多层继承会带来的问题就是继承关系薄弱，可能继承类与父类的相关度很低。抽象：增加类的扩展性。在不改动类定义的情况下丰富类的功能，进一步提升类的稳定性，健壮性。多态：通过實現接口，子类替换父类，通过不同的调用實現不同的功能，丰富类的功能。","like_count":0},{"had_liked":false,"id":315112,"user_name":"Geek_1","can_delete":false,"product_type":"c1","uid":2704407,"ip_address":"","ucode":"59300A73996D20","user_header":"https://static001.geekbang.org/account/avatar/00/29/44/17/e4fdcaad.jpg","comment_is_top":false,"comment_ctime":1633691266,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633691266","product_id":100039001,"comment_content":"JAVA是不支持多重继承的，定义了接口类来避免多重继承的副作用。<br>JAVA支持面向对象的四大特性。通过语言自身的特性来实现的，比如private pritected等关键字，和一些其他的语法","like_count":0},{"had_liked":false,"id":312948,"user_name":"阿昕","can_delete":false,"product_type":"c1","uid":1012906,"ip_address":"","ucode":"F3AD093B68E074","user_header":"https://static001.geekbang.org/account/avatar/00/0f/74/aa/178a6797.jpg","comment_is_top":false,"comment_ctime":1632135657,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1632135657","product_id":100039001,"comment_content":"Java支持多重继承，主要是为了维持语法上的简洁","like_count":0},{"had_liked":false,"id":312445,"user_name":"黄乔鑫","can_delete":false,"product_type":"c1","uid":1863174,"ip_address":"","ucode":"CBD0A8E5E99427","user_header":"https://static001.geekbang.org/account/avatar/00/1c/6e/06/bb43e716.jpg","comment_is_top":false,"comment_ctime":1631804134,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631804134","product_id":100039001,"comment_content":"四大特性<br>\t封装(Encapsulation)<br>\t\t通过暴露有限的访问接口，授权外部通过类的方式访问内部数据或者数据（通过修饰符private、protected、public控制）<br>\t\t保护数据不被随意修改、提高可维护性<br>\t\t提高类的易用性<br>\t抽象<br>\t\t关心方法提供什么功能，不关注实现方式（通过interface、abstract class实现）<br>\t\t提高代码可扩展性、维护性，修改实现不需要改变定义，减少改动范围<br>\t\t解决复杂系统，有效过滤不必要的关注信息<br>\t继承<br>\t\t表达类之间is-a的关系，比如Dog is a Animal，分为单继承、多继承<br>\t\t解决代码复用的问题<br>\t多态<br>\t\t指子类可以替代父类<br>\t\t继承、接口、duck-typing<br>\t\t提高代码的扩展性和复用性<br>","like_count":0},{"had_liked":false,"id":310628,"user_name":"张宗伟","can_delete":false,"product_type":"c1","uid":1374181,"ip_address":"","ucode":"1447A20C7A8982","user_header":"https://static001.geekbang.org/account/avatar/00/14/f7/e5/ec543f3b.jpg","comment_is_top":false,"comment_ctime":1630810762,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630810762","product_id":100039001,"comment_content":"就我熟悉的 js 来说：<br>1. 没有多继承。<br>2. 见代码：<br>&#47;&#47; 封装<br>function Encapsulation(name, age) {<br>  this.name = name;<br>  this.age = age;<br>  let address = &quot;xinyang&quot;;<br><br>  this.getAddress = function () {<br>    return address;<br>  };<br><br>  this.setAddress = function (addr) {<br>    address = addr;<br>  };<br><br>  this.write = function () {<br>    console.log(&quot;Encapsulation write.&quot;);<br>  };<br>}<br><br>&#47;&#47; 抽象<br>function abstraction(name) {<br>  console.log(&quot;Hello, Welcome &quot;, name, &quot;!&quot;);<br>}<br><br>&#47;&#47; 继承<br>&#47;&#47; 通过构造函数和原型链实现继承<br>function Inheritance(name, age) {<br>  Encapsulation.call(this, name, age);<br>  this.say = function () {<br>    console.log(this.name, &quot;is&quot;, this.age, &quot;in&quot;, this.getAddress());<br>  };<br>  this.write = function () {<br>    console.log(&quot;Inheritance write.&quot;);<br>  };<br>}<br>function Proxy() {}<br>Proxy.prototype = Encapsulation.prototype;<br>Inheritance.prototype = new Proxy();<br>Inheritance.prototype.constructor = Inheritance;<br><br>&#47;&#47; 多态<br>function polymorphism(obj) {<br>  obj.write();<br>}<br><br>&#47;&#47; test<br>const Encap1 = new Encapsulation(&quot;zzw&quot;, 27);<br>console.log(Encap1.getAddress());<br>Encap1.setAddress(&quot;henan&quot;);<br>console.log(Encap1.getAddress());<br><br>console.log(abstraction(&quot;zzw&quot;));<br><br>const Inher1 = new Inheritance(&quot;zzw&quot;, 26);<br>console.log(Inher1.say());<br><br>polymorphism(Encap1);<br>polymorphism(Inher1);","like_count":0},{"had_liked":false,"id":309039,"user_name":"贱贱的梦想","can_delete":false,"product_type":"c1","uid":1068326,"ip_address":"","ucode":"A3F7AF23D193AF","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/26/44095eba.jpg","comment_is_top":false,"comment_ctime":1629902674,"is_pvip":true,"discussion_count":0,"race_medal":4,"score":"1629902674","product_id":100039001,"comment_content":"总结的非常好，赞","like_count":0},{"had_liked":false,"id":308473,"user_name":"Geek_acfddd","can_delete":false,"product_type":"c1","uid":2734516,"ip_address":"","ucode":"455CF12A7CA6B8","user_header":"http://thirdwx.qlogo.cn/mmopen/uqaRIfRCAhIkBiaVBBgkKiaJmYC9JdeUQ7Y4XKyrPeLtNXgTHiaa3E3cibwTE8u2NjOwP9QF3icnlnVqnhCFEUz2ueYPrsCxKLKqy/132","comment_is_top":false,"comment_ctime":1629636668,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629636668","product_id":100039001,"comment_content":"有的人认为泛型语法也是一种多态，是连接时多态。<br>我认为也对，因为泛型实现了同一段代码调用多种不同类型的实例，提高代码复用性，这正是多态所要求的。<br>请问老师对泛型是否属于多态，以及泛型在设计原则中的应用有什么看法呢？","like_count":0},{"had_liked":false,"id":307123,"user_name":"小王在努力","can_delete":false,"product_type":"c1","uid":2733574,"ip_address":"","ucode":"A324EF87198905","user_header":"https://static001.geekbang.org/account/avatar/00/29/b6/06/cd1eaa49.jpg","comment_is_top":false,"comment_ctime":1628875662,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628875662","product_id":100039001,"comment_content":"打卡，收获很多，工作快一年了，看着一堆又一堆的代码难受啊。冲冲冲！！！","like_count":0},{"had_liked":false,"id":306548,"user_name":"Geek_842f07","can_delete":false,"product_type":"c1","uid":2698987,"ip_address":"","ucode":"ED772AF755FE7E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/WP4Ge8ABcINFkccKaNYKibicFnI0JAoojBBAUGrichNeRAgzm5RGbHG7GqYrFX3ELEzenuEbicQHJy2HZ72RxSOuMA/132","comment_is_top":false,"comment_ctime":1628604626,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628604626","product_id":100039001,"comment_content":"1.你熟悉的编程语言是否支持多重继承？如果不支持，请说一下为什么不支持。如果支持，请说一下它是如何避免多重继承的副作用的。<br>答：我熟悉的是C++，支持多重继承，多重继承的缺点是变得复杂，并且会出现二义性的问题，c++使用类名覆盖，同名覆盖来解决这个问题，但这也增加了编程的复杂性。<br>2.你熟悉的编程语言对于四大特性是否都有现成的语法支持？对于支持的特性，是通过什么语法机制实现的？对于不支持的特性，又是基于什么原因做的取舍？<br>答：在c++中，封装通过public, private, protected关键字来支持；抽象方面，C++可以定义抽象类，但并没有接口的直接语法支持；在继承方面，使用：语法支持，继承方式可以是公有继承或者私有继承；在多态方面可以通过抽象类来实现多态","like_count":0},{"had_liked":false,"id":304876,"user_name":"肖军","can_delete":false,"product_type":"c1","uid":2660080,"ip_address":"","ucode":"AC06B71DC7D8F0","user_header":"","comment_is_top":false,"comment_ctime":1627653682,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627653682","product_id":100039001,"comment_content":"mark","like_count":0},{"had_liked":false,"id":298442,"user_name":"Bumblebee","can_delete":false,"product_type":"c1","uid":2051293,"ip_address":"","ucode":"B879C8A511D08D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","comment_is_top":false,"comment_ctime":1624109484,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1624109484","product_id":100039001,"comment_content":"可以认为抽象也是封装的一种体现","like_count":0},{"had_liked":false,"id":298108,"user_name":"Geek_16c7da","can_delete":false,"product_type":"c1","uid":2661287,"ip_address":"","ucode":"5AC77B1062BF27","user_header":"","comment_is_top":false,"comment_ctime":1623915249,"is_pvip":false,"replies":[{"id":"108186","content":"你好，专栏是图文+音频哦，没有视频。","user_name":"编辑回复","user_name_real":"赵宇新","uid":"1501385","ctime":1623919851,"ip_address":"","comment_id":298108,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1623915249","product_id":100039001,"comment_content":"小白，这个里面的课程都是语音，没有视频吗","like_count":0,"discussions":[{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522018,"discussion_content":"你好，专栏是图文+音频哦，没有视频。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623919851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":288985,"user_name":"lobby","can_delete":false,"product_type":"c1","uid":1181960,"ip_address":"","ucode":"8D81722BE36AD4","user_header":"https://static001.geekbang.org/account/avatar/00/12/09/08/f3547e77.jpg","comment_is_top":false,"comment_ctime":1618809413,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618809413","product_id":100039001,"comment_content":"golang的多态好像也是duck- typing的形式，感觉现代一点的语言都是以此形式，不知好处或优势在哪里","like_count":0},{"had_liked":false,"id":284561,"user_name":"森林里的胖老虎","can_delete":false,"product_type":"c1","uid":2530946,"ip_address":"","ucode":"C93BA8F2885601","user_header":"https://static001.geekbang.org/account/avatar/00/26/9e/82/7758ab1c.jpg","comment_is_top":false,"comment_ctime":1616338470,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616338470","product_id":100039001,"comment_content":"java为啥不支持多重继承，因为如果多个父类，拥有同名的函数或者字段，那么子类在使用的时候，该去使用哪个，java支持多个接口的实现，首先实现和继承不一样，继承会把父类的所有的信息获取过来，实现只会获取自己想要的抽象方法，如果存在多个接口存在相同的抽象方法名，也没有关系，因为在接口中这些方法只是抽象方法，不具备任何逻辑","like_count":0},{"had_liked":false,"id":273822,"user_name":"刘立嘉","can_delete":false,"product_type":"c1","uid":2414637,"ip_address":"","ucode":"1241140EBE7FE3","user_header":"https://static001.geekbang.org/account/avatar/00/24/d8/2d/6ec3760c.jpg","comment_is_top":false,"comment_ctime":1610688376,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610688376","product_id":100039001,"comment_content":"封装、继承、多态，面向对象三要素，再加上抽象，四要素，构成面向对象的灵魂，深入融汇贯通，运用自如，超越编程技术，成为美学。","like_count":0},{"had_liked":false,"id":268456,"user_name":"焱","can_delete":false,"product_type":"c1","uid":1113301,"ip_address":"","ucode":"677BF1BE4B94D5","user_header":"https://static001.geekbang.org/account/avatar/00/10/fc/d5/1cf5fd56.jpg","comment_is_top":false,"comment_ctime":1608205093,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608205093","product_id":100039001,"comment_content":"java是单继承的吧，通过限定返回的数据类型大小来避免多爱民继承？<br>java实现四大特性的语法是extends和implements来实现的","like_count":0},{"had_liked":false,"id":268401,"user_name":"Geek_dd2917","can_delete":false,"product_type":"c1","uid":2294905,"ip_address":"","ucode":"CD347EA01D874A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/CTpxkU8vxyr7hhGT8yVZxgn1G75sjibFbTHibFAtMA3t2PfhTbZlUyXiaC4yblOGaeVy51lkLASGrzcwMDW0gAlcA/132","comment_is_top":false,"comment_ctime":1608177579,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608177579","product_id":100039001,"comment_content":"有一个点一直想不太明白，多态的问题不能在原类中扩展出不同实现方案的方法出来吗，具体什么场景使用什么方法，对原实现方法也不会去修改，请明白的童鞋指教。。。","like_count":0},{"had_liked":false,"id":262863,"user_name":"一位不愿透露姓名的码农","can_delete":false,"product_type":"c1","uid":1064047,"ip_address":"","ucode":"82A4281E8D8E62","user_header":"https://static001.geekbang.org/account/avatar/00/10/3c/6f/c4a0a38b.jpg","comment_is_top":false,"comment_ctime":1605862133,"is_pvip":false,"replies":[{"id":"96117","content":"嗯呢 ������","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606700907,"ip_address":"","comment_id":262863,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605862133","product_id":100039001,"comment_content":"duck-typing:两个类实现同一个方法，即可实现多态。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510006,"discussion_content":"嗯呢 ������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700907,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261020,"user_name":"Zachariah","can_delete":false,"product_type":"c1","uid":2229665,"ip_address":"","ucode":"B0AED2A3B91369","user_header":"https://static001.geekbang.org/account/avatar/00/22/05/a1/2c631e12.jpg","comment_is_top":false,"comment_ctime":1605174255,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605174255","product_id":100039001,"comment_content":"先举一个多重继承的例子，我们定义一个动物（类）既是狗（父类1）也是猫（父类2），两个父类都有“叫”这个方法。那么当我们调用“叫”这个方法时，它就不知道是狗叫还是猫叫了，这就是多重继承的冲突。 而java对此的解决方法是，一个物体的本质只能有一个。一个动物只能是狗或只能是猫，如果你想创造一个会玩毛线球会玩激光（被激光玩？）的狗，那么只需要创造一个描述这类行为的接口（就叫玩耍吧），然后在自己的类里面实现“玩耍”接口，具体实现这些玩的行为，最终你同样会得到一个既像狗又像猫的动物。如果你想让这个动物叫起来像猫而不是狗，那么使用覆写（override）机制，子类里重新定义“叫”这个行为即可。但是无论如何，这样得到的类是绝对不会有多重继承的冲突的。<br><br> 作者：Charlie W 链接：https:&#47;&#47;www.zhihu.com&#47;question&#47;24317891&#47;answer&#47;65289659 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","like_count":0},{"had_liked":false,"id":254345,"user_name":"晴天了","can_delete":false,"product_type":"c1","uid":1359669,"ip_address":"","ucode":"5310E02F8DF1F0","user_header":"https://static001.geekbang.org/account/avatar/00/14/bf/35/0e3a92a7.jpg","comment_is_top":false,"comment_ctime":1603102908,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603102908","product_id":100039001,"comment_content":"老师有个疑问.   多态 : (子类可以替换父类) 是否可以理解为子类依赖父类的抽象. ","like_count":0},{"had_liked":false,"id":252097,"user_name":"Mr_scx","can_delete":false,"product_type":"c1","uid":1239546,"ip_address":"","ucode":"28B5CE68A5A339","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKWiaZb7a2JAcIVlXYuZ3iaPfSF6vBbg3yUps6LKpsZarftyXufMHYKJmMKzH3bIpVkDAVNXE9q0oOw/132","comment_is_top":false,"comment_ctime":1602124367,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602124367","product_id":100039001,"comment_content":"&quot;如果 Java 语言没有提供访问权限控制语法，所有的属性默认都是 public 的&quot;，老师，关于这句话，我记得 Java中缺省修饰符和带 public修饰符的权限还不一样的呀","like_count":0},{"had_liked":false,"id":251421,"user_name":"呆瓜","can_delete":false,"product_type":"c1","uid":1655940,"ip_address":"","ucode":"C98C7B224D0640","user_header":"https://static001.geekbang.org/account/avatar/00/19/44/84/4da14994.jpg","comment_is_top":false,"comment_ctime":1601541394,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601541394","product_id":100039001,"comment_content":"c++首先引入的多重继承带来了诸如菱形继承一类的问题，而后为了解决这个问题又不得不引入了虚继承这种概念。然而在实际的应用中人们发现继承更多的只被用在两种场合：扩充&#47;改善基类，以及实现多态。对于前者，单继承足以；而对于后者，则真正需要的其实是纯抽象类，即只包含纯虚函数的基类。而对于这一种基类，由于其目的和普通的实例类已经有所不同，因此在java中将其改称为interface，即接口加以明确区分。因此，java或者c#所谓的不支持多重继承，只是不支持对实例类的多重继承——因为这种继承所带来的一点点代码上的缩减远比不上其引入的麻烦，但是对于用于实现多态的多重继承，即implement interface依然是很好的支持了的。<br><br><br>","like_count":0},{"had_liked":false,"id":250128,"user_name":"Zly","can_delete":false,"product_type":"c1","uid":1529196,"ip_address":"","ucode":"834C3FE84F2939","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/6c/896df6b6.jpg","comment_is_top":false,"comment_ctime":1600943485,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600943485","product_id":100039001,"comment_content":"c#不支持多重继承，需要的话把多出来类的定义成接口，是可以有多个接口的","like_count":0},{"had_liked":false,"id":247595,"user_name":"apollo_steve","can_delete":false,"product_type":"c1","uid":1708286,"ip_address":"","ucode":"754053D5957A94","user_header":"https://static001.geekbang.org/account/avatar/00/1a/10/fe/a46a5a06.jpg","comment_is_top":false,"comment_ctime":1599751057,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599751057","product_id":100039001,"comment_content":"C++支持多重继承；存在一个问题是a-&gt;b, a-&gt;c, b,c-&gt;d，这种情况下d会有两份a,采用虚继承可避免该问题；<br><br>支持封装 private public protected关键字<br>支持抽象 .h定义，.cpp实现，但没有接口类<br>支持继承 class A: public B;<br>支持多态：继承机制和虚拟函数表方法，并且父类指针可以只想子类对象","like_count":0},{"had_liked":false,"id":246429,"user_name":"张鉴","can_delete":false,"product_type":"c1","uid":1250837,"ip_address":"","ucode":"694D37E8D0BF4C","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/15/2dcd8e00.jpg","comment_is_top":false,"comment_ctime":1599322890,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599322890","product_id":100039001,"comment_content":"写的不对还请大家指正<br>golang <br>1.封装 <br>    通过struct和字段大小写实现<br>2.继承 <br>   不支持继承，通过组合的方式实现<br>3.抽象<br>   通过duck-typing隐式实现接口<br>4. 多态<br>   duck-typing","like_count":0},{"had_liked":false,"id":245717,"user_name":"宇天飞","can_delete":false,"product_type":"c1","uid":1126444,"ip_address":"","ucode":"3FB37D1E2DAA61","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/2c/06375913.jpg","comment_is_top":false,"comment_ctime":1599034482,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1599034482","product_id":100039001,"comment_content":"问题1：<br>1、不支持。java。<br><br>问题2：<br>1、有的。<br>抽象：函数、接口、类、包<br>封装：访问控制<br>继承：extends<br>多态：","like_count":0},{"had_liked":false,"id":245142,"user_name":"lin yu","can_delete":false,"product_type":"c1","uid":1126028,"ip_address":"","ucode":"3F2E0AF47750FE","user_header":"https://static001.geekbang.org/account/avatar/00/11/2e/8c/75936ae2.jpg","comment_is_top":false,"comment_ctime":1598844891,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598844891","product_id":100039001,"comment_content":"没有人发现多态demo的SortedDynamicArray类中 add方法要加super.add(e);么 还是我idea有问题。","like_count":0},{"had_liked":false,"id":240813,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1597073018,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597073018","product_id":100039001,"comment_content":"1 c++支持多重继承。多重继承存在的主要问题是菱形继承问题，c++通过虚继承的方式解决，但付出的代价是时间和空间上性能的损耗，空间上需要在类对象为虚基类安插多余的指针。时间上，需要经过多重指针解析访问虚基类数据<br>2 c++支持封装，继承，抽象，多态的特性","like_count":0},{"had_liked":false,"id":240083,"user_name":"Ilearning99","can_delete":false,"product_type":"c1","uid":1989119,"ip_address":"","ucode":"7901836A2C47EF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/qOdqzmC507sibL6sichNSDaVmyoMKibEIqHWpic4CftgOQnoA3QKeRPwic9j1Ha8MLtzzqzfSRavR9GWMju09SMADUg/132","comment_is_top":false,"comment_ctime":1596759315,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596759315","product_id":100039001,"comment_content":"多重继承会存在歧义，java和c#都不支持多重继承，<br>java和c#对于四大特性都有支持，但是python不支持封装和","like_count":0},{"had_liked":false,"id":239356,"user_name":"双飞燕","can_delete":false,"product_type":"c1","uid":1727988,"ip_address":"","ucode":"D19A7ECD7EE630","user_header":"https://static001.geekbang.org/account/avatar/00/1a/5d/f4/fcf32e20.jpg","comment_is_top":false,"comment_ctime":1596509643,"is_pvip":false,"replies":[{"id":"89274","content":"不需要，重载是在一个类中多个重名函数","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1597454573,"ip_address":"","comment_id":239356,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1596509643","product_id":100039001,"comment_content":"老师，我看到有些文章把多态分为重写和重载，对于重载，需要有父子关系的依赖吗？有点疑惑","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503079,"discussion_content":"不需要，重载是在一个类中多个重名函数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597454573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239123,"user_name":"Happy—sea","can_delete":false,"product_type":"c1","uid":1624484,"ip_address":"","ucode":"4EAD3636164392","user_header":"https://static001.geekbang.org/account/avatar/00/18/c9/a4/66b606ad.jpg","comment_is_top":false,"comment_ctime":1596441252,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596441252","product_id":100039001,"comment_content":"多重继承的问题之前没有思考过，以前读书的时候只是记住了java面向对象的四大准则。现在想想java多继承会引发一些无法处理的问题。老师讲封装，抽象，继承，多态与实际的语法支持搭配讲解，以前是糊里糊涂的，现在清晰了很多。","like_count":0},{"had_liked":false,"id":238419,"user_name":"尾舟","can_delete":false,"product_type":"c1","uid":1002661,"ip_address":"","ucode":"6E3C3308B64F85","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4c/a5/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1596163471,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596163471","product_id":100039001,"comment_content":"对于语言来说重要的是表达力，所以为了实现duck type这种表达能力有的语言选择了多重继承一般是比较老的语言，对cpp来说多重继承就应该是一个基类和多个纯虚基类，后创建的语言发现这样实现容易用错，但同时要保留这种能力才有了java 的 interface之类的实现","like_count":0},{"had_liked":false,"id":238141,"user_name":"站在岸上的鱼","can_delete":false,"product_type":"c1","uid":2093578,"ip_address":"","ucode":"96C3D7B1772541","user_header":"https://static001.geekbang.org/account/avatar/00/1f/f2/0a/e10d198f.jpg","comment_is_top":false,"comment_ctime":1596079456,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596079456","product_id":100039001,"comment_content":"c#， java这些都是支持多重继承的，而为了避免类的多继承副作用，c#，java这些编程语言采用单类多接口的方法来支持多重继承。<br><br>c# 封装：通过访问控制修饰符；抽象：虚类，接口来实现；继承：类的单继承，接口的多继承；多态：父类和父接口可以引用子类的对象，子类可以重写父类或接口中的方法实现，类的继承。抽象类，虚方法，方法重写，方法重载","like_count":0},{"had_liked":false,"id":237689,"user_name":"何超","can_delete":false,"product_type":"c1","uid":1522691,"ip_address":"","ucode":"02C19C1A070315","user_header":"https://static001.geekbang.org/account/avatar/00/17/3c/03/ce032c4d.jpg","comment_is_top":false,"comment_ctime":1595926878,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595926878","product_id":100039001,"comment_content":"一直没理解多态，今天终于明白了。其实不止子类可以替代父类，这就限定继承了。例如调用接口，也可以存在多态。","like_count":0},{"had_liked":false,"id":234943,"user_name":"西电","can_delete":false,"product_type":"c1","uid":2063037,"ip_address":"","ucode":"95BD4CE9D93018","user_header":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","comment_is_top":false,"comment_ctime":1594839543,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594839543","product_id":100039001,"comment_content":"多继承方法重名时候的二意性问题","like_count":0},{"had_liked":false,"id":234752,"user_name":"歪歪在学习","can_delete":false,"product_type":"c1","uid":1618198,"ip_address":"","ucode":"889032C02D2D26","user_header":"https://static001.geekbang.org/account/avatar/00/18/b1/16/ba221660.jpg","comment_is_top":false,"comment_ctime":1594787365,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594787365","product_id":100039001,"comment_content":"java不支持多继承的原因是因为菱形问题。get","like_count":0},{"had_liked":false,"id":232140,"user_name":"sorationalist","can_delete":false,"product_type":"c1","uid":2012902,"ip_address":"","ucode":"4E2B3B3234E1C5","user_header":"https://static001.geekbang.org/account/avatar/00/1e/b6/e6/b2be4536.jpg","comment_is_top":false,"comment_ctime":1593870001,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593870001","product_id":100039001,"comment_content":"总结：1. 继承关系，公共功能可以实现代码的复用，然后重写父类方法来实现特殊业务的处理，场景，类之间必须是is-a关系，继承特性代码层次嵌套过深，难以维护。<br>2. 多态，继承或者接口以来实现，只要保证拥有相同的方法，不需要强制具有is-a关系。","like_count":0},{"had_liked":false,"id":228631,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1592757899,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592757899","product_id":100039001,"comment_content":"封装：保护数据，提供少量的属性和方法，易用，易维护。java中采用public，pritected default private四个关键词来控制类方法字段得访问权限。<br><br>抽象：隐藏方法的细节，使用者只需要关注方法的去参和结果即可。java中有接口和抽象类。<br><br>继承：方法复用。extends<br><br>多态：代码的扩展性。继承+接口或抽象类","like_count":0},{"had_liked":false,"id":228066,"user_name":"qiuyuan","can_delete":false,"product_type":"c1","uid":1745853,"ip_address":"","ucode":"B283F9281A9FC8","user_header":"https://static001.geekbang.org/account/avatar/00/1a/a3/bd/b28098c5.jpg","comment_is_top":false,"comment_ctime":1592547606,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592547606","product_id":100039001,"comment_content":"封装:<br>    我钱包里的钱我可以拿出来给你，你也可以拿给我我装进去，但你不能直接动我的钱包<br>抽象:<br>    存在又不存在的就是抽象的<br>继承:<br>    继承的本质是能力的复用<br>多态:<br>    不用说那么多，你就说你是不是xxx，是就行","like_count":0},{"had_liked":false,"id":226487,"user_name":"Chris Zou","can_delete":false,"product_type":"c1","uid":1897148,"ip_address":"","ucode":"B6DFC71C1DD8B7","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f2/bc/ffc7ad67.jpg","comment_is_top":false,"comment_ctime":1592120150,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592120150","product_id":100039001,"comment_content":"一：<br>C++语言支持多重继承，避免二义性副作用<br>1. 加类名限定符，指定具体类；<br>2. 子类同名覆盖，内部实现指定一个具体的类；<br>3. 虚基类，多重继承自有共同虚基类的类；<br>[参考博客](https:&#47;&#47;blog.csdn.net&#47;yang2011079080010&#47;article&#47;details&#47;51407144)<br><br>二：<br>封装：private、protected、public关键字<br>抽象：纯虚函数表示一个抽象接口，子类实现；<br>继承：&quot;:&quot;符号<br>多态：<br>静态多态：函数重载和泛型编程，发生在编译时期<br>动态多态：一种接口，多个虚函数实现，发生在运行期间。指针或者引用的父类对象，通过调用父类对象（指针类型或者引用类型）的虚函数来动态调用实际对象的虚函数方法。底层实现是每个类维系一个虚函数地址表，实际的类对象分配一个虚表指针来指向是父类还是子类的虚表，从而实现多态。<br>","like_count":0},{"had_liked":false,"id":220039,"user_name":"朝小树","can_delete":false,"product_type":"c1","uid":1323875,"ip_address":"","ucode":"18DC282DEF16C8","user_header":"https://static001.geekbang.org/account/avatar/00/14/33/63/2d48822a.jpg","comment_is_top":false,"comment_ctime":1590140032,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590140032","product_id":100039001,"comment_content":"多态：父类声明，子类实现，调用同名方法时，调用的是子类重写的方法。","like_count":0},{"had_liked":false,"id":219732,"user_name":"Geek_East","can_delete":false,"product_type":"c1","uid":1589947,"ip_address":"","ucode":"A1A7CBF9B8FB2D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXKSvfaeicog2Ficx4W3pNeA1KRLOS7iaFy2uoxCDoYpGkGnP6KPGecKia6Dr3MtCkNGpHxAzmTMd0LA/132","comment_is_top":false,"comment_ctime":1590071687,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1590071687","product_id":100039001,"comment_content":"核心目的: 无限拓展<br>- 最小化重复代码        (继承:  子类、抽象类、泛型)  -&gt; 拓展效率<br>- 最小化副作用           (封装)                                -&gt; 拓展前提<br>- 最大化传参类型      （多态：子类、接口类)           -&gt; 水平拓展<br>- 向上构建                 (抽象)                                -&gt; 垂直拓展<br>","like_count":0},{"had_liked":false,"id":219633,"user_name":"黄学尧","can_delete":false,"product_type":"c1","uid":1879994,"ip_address":"","ucode":"433DAF4232E784","user_header":"https://static001.geekbang.org/account/avatar/00/1c/af/ba/9be637d5.jpg","comment_is_top":false,"comment_ctime":1590053634,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590053634","product_id":100039001,"comment_content":"我的关注点比较奇特。。<br>猫是哺乳动物，不是爬行动物，哺乳动物和爬行动物是互斥的。","like_count":0},{"had_liked":false,"id":219183,"user_name":"超乎所以","can_delete":false,"product_type":"c1","uid":1705767,"ip_address":"","ucode":"AA1B387BCB5971","user_header":"https://static001.geekbang.org/account/avatar/00/1a/07/27/0e3b4e69.jpg","comment_is_top":false,"comment_ctime":1589962993,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589962993","product_id":100039001,"comment_content":"java 语言不支持多重继承。多重继承有菱形继承问题。类A有方法add(*),类B,类C都继承自类A,重写方法add(),类D继承自B,C，此时D调用add()方法时，调用的是哪个add()方法呢？","like_count":0},{"had_liked":false,"id":216924,"user_name":"方舟勇士","can_delete":false,"product_type":"c1","uid":1218162,"ip_address":"","ucode":"53D3D844B08B92","user_header":"https://static001.geekbang.org/account/avatar/00/12/96/72/a517bf25.jpg","comment_is_top":false,"comment_ctime":1589370064,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1589370064","product_id":100039001,"comment_content":"Grady Booch：抽象和封装是互补的概念：抽象关注的是对象可以观察到的行为，而封装关注这种行为的实现。封装通常是通过信息隐藏来实现的（不只是数据隐藏）。信息隐藏是将那些不涉及对象本质特征的秘密都隐藏起来的过程。通常，对象的结构是隐藏的，其方法的实现也是隐藏的。","like_count":0},{"had_liked":false,"id":216571,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1589286837,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589286837","product_id":100039001,"comment_content":"golang中的数据访问保护<br>package main<br>import &quot;fmt&quot;<br>type Foo struct {<br>  name string<br>}<br>&#47;&#47; Set方法<br>func (f *Foo) SetName(name string) {<br>  &#47;&#47; do  ....<br>  f.name = name<br>}<br>&#47;&#47; Get方法，只要把首字母大写。<br>func (f Foo) Name() string {<br>   &#47;&#47; do<br>    return f.name<br>}<br>func main() {<br>   p := Foo{}<br>   p.SetName(&quot;Abc&quot;)<br>   name := p.Name()<br>   fmt.Println(name)<br>}<br>HTTP Read时RequestJOSN反序列化为实体RequestXxx，HTTP Write时序列化ResponseXxx —&gt; ResponseJSON。这2个对象的属性必须包外可见。BO可以用数据访问保护","like_count":0},{"had_liked":false,"id":216569,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1589285757,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589285757","product_id":100039001,"comment_content":"封装：数据访问保护。<br>需要保护的属性声明为private xxx，通过getXxx(),setXxx()方法对属性进行中取值和赋值，方法内部可以对私有属性进行逻辑封装，保证数据不被恶意修改。好多通过工具生成空的get set方法，或者直接通过@Data注解完成get set方法，是对封装特性的破坏。","like_count":0},{"had_liked":false,"id":216526,"user_name":"师哥","can_delete":false,"product_type":"c1","uid":1333376,"ip_address":"","ucode":"A86CD1661D370F","user_header":"https://static001.geekbang.org/account/avatar/00/14/58/80/c9e232b6.jpg","comment_is_top":false,"comment_ctime":1589276939,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589276939","product_id":100039001,"comment_content":"封装  继承   抽象  多态  在大学学习的时候觉得自己知道了理解了，但是这么多年过去了感觉还是不能彻底理解。现在就彻底要整明白。<br>","like_count":0},{"had_liked":false,"id":215876,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1589123613,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589123613","product_id":100039001,"comment_content":"抽象就是先写作什么的代码，不写怎么做，抽象类和接口都是只管做什么，不管怎么做的代码。<br>对需求进行拆分(聚焦问题)、提纯(丢弃无关)、简化(不考虑如何实现建表，只考虑包含什么功能)。所以说通过接口很容易完成抽象工作，其次是抽象类需要写属性和部分函数逻辑。通过调用接口可以很容易把底层代码写完，然后再写接口实现，降低问题复杂度。接口就是方法的集合，没有实现，所以接口就是抽象。<br>在需求中抽象出类、基类、接口(func集合)。抽象时并没有考虑子类如何替换父类、底层调用高层(使用者)，不同的调用者可以实现多态。其实就是解决复杂问题的思维方法，只考虑做什么，不考虑怎么做。","like_count":0},{"had_liked":false,"id":215490,"user_name":"Zeng Shine","can_delete":false,"product_type":"c1","uid":1245334,"ip_address":"","ucode":"15D2618C92D662","user_header":"https://static001.geekbang.org/account/avatar/00/13/00/96/6df95326.jpg","comment_is_top":false,"comment_ctime":1589000431,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589000431","product_id":100039001,"comment_content":"想说一下自己对封装和抽象的理解。封装是一个动词，可以接不同的宾语。面向对象的封装特性是动词作名词用，完整的动宾结构应该是封装数据访问。抽象是指隐藏具体实现过程，暴露结果，这里的隐藏具体实现也算是封装，完整的动宾结构是封装实现。","like_count":0},{"had_liked":false,"id":215232,"user_name":"小马","can_delete":false,"product_type":"c1","uid":1490686,"ip_address":"","ucode":"92B7ECD23BDCB5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoXW5rycAcrNTwgOvib8poPXO0zvIekIPzBZJfsnciaLPIw9Q1t3rsXeH6DR24QndpYQibvibhR1tKHPw/132","comment_is_top":false,"comment_ctime":1588934292,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588934292","product_id":100039001,"comment_content":"看完文章，结合自己的理解，有以下的看法。<br>对于抽象，认为是一种编程思想，以JAVA为例，充分利用接口进行行为抽象，利用抽象类实现公有行为，子类实现具体细节。<br>对于封装应该是对数据项和行为两者的控制，我们只暴露最少的行为，对于具体细节实现进行封装，这样在外部使用时更加的简单易用，内部扩展封闭。<br>对于继承应该是对父类的重用，同时新增其他行为。多态则离不开继承，但是对于继承这里应该多考虑对抽象方法的多态实现或者是接口的多态实现，保证父类实现的重用性。","like_count":0},{"had_liked":false,"id":213491,"user_name":"注定非凡","can_delete":false,"product_type":"c1","uid":1113597,"ip_address":"","ucode":"80673056E131B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","comment_is_top":false,"comment_ctime":1588432254,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1588432254","product_id":100039001,"comment_content":"what<br>封装，抽象，继承，多态是一种思想理论，<br>封装：信息隐藏，数据访问保护<br>抽象：提取共同点，找到共同本质<br>继承：特征传递，能力沿用<br>多态：父类可以调用多个子类的能力<br>why<br>实现简洁，准确的语义，平衡机器执行效率和人类的理解能力  《信息论》<br>how<br>封装：依赖于编程语言提供特殊的控制权限语法<br>抽象：归纳共同特性，脱去个性化的特征<br>继承：依赖编程语言的语法实现<br>多态：配合继承共同服用","like_count":0},{"had_liked":false,"id":213242,"user_name":"妙子爸","can_delete":false,"product_type":"c1","uid":1433842,"ip_address":"","ucode":"988C1A7B9548F7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/hsxzhpId4k4uGK5CG534oLEIibqluVwOqgGqxFibILZDSia38gYOHflJDE1zfDVRGRIRq8sxdrAzWnvDP0eVDRMyQ/132","comment_is_top":false,"comment_ctime":1588339621,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588339621","product_id":100039001,"comment_content":"java没有多继承，原因可能是避免菱形集成的问题，子类不知道用哪个父类的成员变量，要重写很多不必要的方法。","like_count":0},{"had_liked":false,"id":212766,"user_name":"不靠谱的琴谱","can_delete":false,"product_type":"c1","uid":1243964,"ip_address":"","ucode":"D388EDFD6E5F8C","user_header":"https://static001.geekbang.org/account/avatar/00/12/fb/3c/e92d40f6.jpg","comment_is_top":false,"comment_ctime":1588208387,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588208387","product_id":100039001,"comment_content":"lua也是支持duck-typing的，这种用法写起来很快乐。","like_count":0},{"had_liked":false,"id":212014,"user_name":"Giacomo","can_delete":false,"product_type":"c1","uid":1478055,"ip_address":"","ucode":"BE5B1E68BCDBB3","user_header":"https://static001.geekbang.org/account/avatar/00/16/8d/a7/2176bbc5.jpg","comment_is_top":false,"comment_ctime":1588046474,"is_pvip":false,"replies":[{"id":"78923","content":"kitty也可以是一个子类呀 不一定是实例","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1588129770,"ip_address":"","comment_id":212014,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1588046474","product_id":100039001,"comment_content":"不知道是不是大家都这么写的，但我觉得is-a应该是例与类的关系，而不是继承吧。<br><br>比如 kitty is a cat. 表达的是kitty是一只cat，而不是说Kitty是猫的一个品种。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493410,"discussion_content":"kitty也可以是一个子类呀 不一定是实例","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588129770,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1478055,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8d/a7/2176bbc5.jpg","nickname":"Giacomo","note":"","ucode":"BE5B1E68BCDBB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271811,"discussion_content":"不是啊，我这里的kitty是一只猫的名字。\n而且，如果说想表达子类的关系我们会说，\na Kitty is a Cat\n或者\nKitty is Cat","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590197567,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":210596,"user_name":"张张先生","can_delete":false,"product_type":"c1","uid":1582951,"ip_address":"","ucode":"91B0E84B47AF05","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqrSGol9ss3nzh6Hqj2BYxBTlYbhSe72Og6Vx5CSb5iboibL9xZdWdYOpZzmN2ibj9EpboNDdRBSXSZw/132","comment_is_top":false,"comment_ctime":1587793987,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587793987","product_id":100039001,"comment_content":"课后作业：<br>工作中最常用的语言是JAVA，并不支持多继承，JAVA的定位就是简单的编程语言，舍弃了指针、多继承等特性，多继承主要的问题是菱形继承问题，也就是B和C继承了A，B和C均对A中的方法a()重写，如果这个时候D继承B和C且对方法a()不重写，那么这个时候D中的方法a()是来自于哪里","like_count":0},{"had_liked":false,"id":208902,"user_name":"李靖峰","can_delete":false,"product_type":"c1","uid":1139247,"ip_address":"","ucode":"AA4DE3E91A1FFA","user_header":"https://static001.geekbang.org/account/avatar/00/11/62/2f/6fe8ee9e.jpg","comment_is_top":false,"comment_ctime":1587461678,"is_pvip":false,"replies":[{"id":"78925","content":"嗯嗯 你说的没错 有些资料会区分 静态和动态 静态是重载","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1588129957,"ip_address":"","comment_id":208902,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1587461678","product_id":100039001,"comment_content":"老师，关于多态的部分细分的话还有静态多态和动态多态，前者用泛型实现","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492667,"discussion_content":"嗯嗯 你说的没错 有些资料会区分 静态和动态 静态是重载","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588129957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208101,"user_name":"Geek__93441785f6a2","can_delete":false,"product_type":"c1","uid":1450033,"ip_address":"","ucode":"03F5A9C37FF728","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLOCkhE6EF8dpnug21uHof7bu6YnM2gwEMDtdTtCPmRibKx4CUiass25UfMSwib8zJ7lwv8beYYXjLCA/132","comment_is_top":false,"comment_ctime":1587277324,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587277324","product_id":100039001,"comment_content":"这是我看过所有讲封装，抽象，继承，多态的文章中，讲的最清楚，最易懂的一篇，通过实例去分析每种特性的用法与用途","like_count":0},{"had_liked":false,"id":206056,"user_name":"盘尼西林","can_delete":false,"product_type":"c1","uid":1197347,"ip_address":"","ucode":"B59569FC25144F","user_header":"https://static001.geekbang.org/account/avatar/00/12/45/23/28311447.jpg","comment_is_top":false,"comment_ctime":1586781919,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586781919","product_id":100039001,"comment_content":"四大原则:<br>    封装: 对外界屏蔽内部的细节，保护成员<br>    抽象: 如果不能很好的封装那么一定是抽象的不够,需要往上继续抽象<br>    继承: 倾向于使用组合的形式，继承会有太多的依赖关系<br>    多态: 程序的拓展性和复用性，至少整体的代码&amp;&amp;逻辑结构是不会变的","like_count":0},{"had_liked":false,"id":202341,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1585971465,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1585971465","product_id":100039001,"comment_content":"抽象的作用：作者这里的所说的似乎是对基本概念的抽象，尽可能的把概念向上抽出，与实际编码中的抽象似乎并不是同一个东西。abstract和interface的实现机制，具体解决了什么问题呢？为什么会有抽象类这样的机制呢？这里并没有说清楚。比如，子类继承了抽象类，可以根据抽象类中定义的方法自己实现一套自己的逻辑。只是方法名与父类相同而已。凡是继承了这个抽象类的子类都拥有相关的方法，那这样的话，抽象基类就是一个统一方法或者接口的类。即这样可以提高代码的可维护性。","like_count":0},{"had_liked":false,"id":200602,"user_name":"Ray","can_delete":false,"product_type":"c1","uid":1604089,"ip_address":"","ucode":"3A66800D8E35D6","user_header":"https://static001.geekbang.org/account/avatar/00/18/79/f9/3cd59b29.jpg","comment_is_top":false,"comment_ctime":1585623358,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585623358","product_id":100039001,"comment_content":"个人观点：封装和抽象可以结合在一起使用，类似公共方法可能是这两大特性直观的表现<br>python支持多继承，但继承太多同样会有菱形继承的问题，super的存在可以解决一些但觉得比较混乱(应该是个人问题，有经验的大佬可以沟通一下)<br>从入行以来面向对象编程的特性一直没有特别清晰的认知，这算是再次刷新对概念的理解<br>加油啊，打好基础才能走的更远","like_count":0},{"had_liked":false,"id":200433,"user_name":"赵毅","can_delete":false,"product_type":"c1","uid":1905585,"ip_address":"","ucode":"28F6820F1987F6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIgDicRj9LAvWVyuibTbRnZDFeC6uWI8zfWU1gLM6yPoNklUaiar4TKxEyRHFibjIth3iahRNLcNvewjug/132","comment_is_top":false,"comment_ctime":1585583164,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585583164","product_id":100039001,"comment_content":"本章个人总结：<br>1、注意当前类属性是不是可以set？谁可以set<br>2、当前类、方法、属性谁可以有访问权shi限<br>3、命名不要暴露太多细节，特别是public函数，如果有一天内容改了，命名是否也要改<br>4、利用组合，不用继承<br>c#为什么不支持多重继承：<br>我觉得可以实现但其实编程语言开发者是为了减少复杂性，面向接口编程而不是面向对象编程<br>多重继承可以利用多个接口来实现","like_count":0},{"had_liked":false,"id":197769,"user_name":"屴","can_delete":false,"product_type":"c1","uid":1406688,"ip_address":"","ucode":"512BDF75C5BEDA","user_header":"https://static001.geekbang.org/account/avatar/00/15/76/e0/95be78a9.jpg","comment_is_top":false,"comment_ctime":1585397639,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585397639","product_id":100039001,"comment_content":"封装如何保证对象的线程安全？","like_count":0},{"had_liked":false,"id":197739,"user_name":"面向百度编程","can_delete":false,"product_type":"c1","uid":1732780,"ip_address":"","ucode":"8FE04A019D71D1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","comment_is_top":false,"comment_ctime":1585396211,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585396211","product_id":100039001,"comment_content":"java不支持多继承，支持多实现，首先我想说一下java的多太的前提就是继承，如果子类要运行父类的方法，如果子类没有重写的化，那么子类将会往父类寻找方法，如果说有两个父类都实现了同一个方法，那么到底该调用哪个方法呢，很显然做不到精准，需要决策，但是支持多实现，因为其父类都没有具体实现方法，根本不需要决策，而是将来需要的时候进行动态决策，而在java8中突然引入了默认实现，我认为其一是为了 新特性的向下兼容，同时默认实现如果子类调用两个父类都有的方法的化，同样会冲突，不知道到底调用那个，只时候，可以通过 组合来实现控制具体调用哪个类的方法，类似于适配器，代理，模式","like_count":0},{"had_liked":false,"id":197729,"user_name":"面向百度编程","can_delete":false,"product_type":"c1","uid":1732780,"ip_address":"","ucode":"8FE04A019D71D1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","comment_is_top":false,"comment_ctime":1585395531,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585395531","product_id":100039001,"comment_content":"关于java不支持多继承问题，之前在深入理解java虚拟机看到过，父类的索引（除了object外）只有一个，而父类的索引对应着这个类的全限定类名。父类索引是由常量池的常量项结构表总成的，类似于数据库中的数据表，u2字段表示，父类索引","like_count":0},{"had_liked":false,"id":197630,"user_name":"这得从我捡到一个鼠标垫开始说起","can_delete":false,"product_type":"c1","uid":1272321,"ip_address":"","ucode":"2FF4347B4E7A9B","user_header":"https://static001.geekbang.org/account/avatar/00/13/6a/01/d9cb531d.jpg","comment_is_top":false,"comment_ctime":1585388775,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585388775","product_id":100039001,"comment_content":"1 java 不支持，个人认为多重继承会让代码的可读性变差，继承关系变得复杂<br>2 java在语法层面全都支持","like_count":0},{"had_liked":false,"id":197155,"user_name":"桂冠远航","can_delete":false,"product_type":"c1","uid":1155463,"ip_address":"","ucode":"5959E1A1DAA05D","user_header":"https://static001.geekbang.org/account/avatar/00/11/a1/87/259ab5a3.jpg","comment_is_top":false,"comment_ctime":1585360819,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585360819","product_id":100039001,"comment_content":"博大精深，常看常新。","like_count":0},{"had_liked":false,"id":196695,"user_name":"木白","can_delete":false,"product_type":"c1","uid":1194009,"ip_address":"","ucode":"BEC459430B293C","user_header":"https://static001.geekbang.org/account/avatar/00/12/38/19/c8d72c61.jpg","comment_is_top":false,"comment_ctime":1585303291,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585303291","product_id":100039001,"comment_content":"猫并不是爬行动物吧，哈哈，非杠，只是读到了就说一下","like_count":0},{"had_liked":false,"id":194639,"user_name":"Cutler","can_delete":false,"product_type":"c1","uid":1228136,"ip_address":"","ucode":"2EDECFE039845B","user_header":"https://static001.geekbang.org/account/avatar/00/12/bd/68/3fd6428d.jpg","comment_is_top":false,"comment_ctime":1585094628,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585094628","product_id":100039001,"comment_content":"熟悉的语言java c# go都不支持多重继承，其中go只支持组合，个人认为多重继承如果多个父类有相同的字段或方法会冲突，从而带来不确定性，不知道是不是这个原因。","like_count":0},{"had_liked":false,"id":193827,"user_name":"墨鱼","can_delete":false,"product_type":"c1","uid":1022720,"ip_address":"","ucode":"8FB5E4DCB8A024","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/00/654be3f7.jpg","comment_is_top":false,"comment_ctime":1584971112,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584971112","product_id":100039001,"comment_content":"1.js 不支持多重继承，具体原因这个文章讲的不错 https:&#47;&#47;juejin.im&#47;entry&#47;5ac46b6c5188255570063b71<br><br><br>2.js四大特性都可以实现<br>封装是：仅仅暴露有限的接口，达到数据访问保护的功能。可以在函数里面声明变量，然后外面的是获取不到，也就改写不了。但是需要的话也可以 return 出去。<br><br>抽象：只关注功能点，而不关注具体的实现方法。比如我写一个函数，功能是把一个数组里面符合特定条件的数组筛选出来。我使用这个函数，不需要关心具体的过滤过程。我只需要结果。<br><br>继承: 就是子类继承父类的属性。单继承是子类只继承父类的属性。多继承是一个子类继承了多个父类的属性。<br><br><br>多态：子类可以替换父类的方法，在代码执行时，调用不同的子类方法。有利于代码的维护和扩展。JS 是无状态的语言，天生支持多态。通过原型或者类的方式实现<br><br><br>","like_count":0},{"had_liked":false,"id":193362,"user_name":"默片。","can_delete":false,"product_type":"c1","uid":1473606,"ip_address":"","ucode":"1D6D6456901E1E","user_header":"https://static001.geekbang.org/account/avatar/00/16/7c/46/019a6b9b.jpg","comment_is_top":false,"comment_ctime":1584890979,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584890979","product_id":100039001,"comment_content":"关于duck-typing，在cpp中其实用template也能实现，并且可以在编译期检查其正确性。","like_count":0},{"had_liked":false,"id":191389,"user_name":"不学不行啊","can_delete":false,"product_type":"c1","uid":1335474,"ip_address":"","ucode":"69368165141C2D","user_header":"https://static001.geekbang.org/account/avatar/00/14/60/b2/ccebcb71.jpg","comment_is_top":false,"comment_ctime":1584769512,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584769512","product_id":100039001,"comment_content":"继承是用来表示类之间的 is-a 关系，分为两种模式：单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类。为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持。继承主要是用来解决代码复用的问题","like_count":0},{"had_liked":false,"id":191388,"user_name":"不学不行啊","can_delete":false,"product_type":"c1","uid":1335474,"ip_address":"","ucode":"69368165141C2D","user_header":"https://static001.geekbang.org/account/avatar/00/14/60/b2/ccebcb71.jpg","comment_is_top":false,"comment_ctime":1584769503,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584769503","product_id":100039001,"comment_content":"多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类、duck-typing。多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。","like_count":0},{"had_liked":false,"id":191387,"user_name":"不学不行啊","can_delete":false,"product_type":"c1","uid":1335474,"ip_address":"","ucode":"69368165141C2D","user_header":"https://static001.geekbang.org/account/avatar/00/14/60/b2/ccebcb71.jpg","comment_is_top":false,"comment_ctime":1584769494,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584769494","product_id":100039001,"comment_content":"封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。它需要编程语言提供权限访问控制语法来支持，例如 Java 中的 private、protected、public 关键字。封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。","like_count":0},{"had_liked":false,"id":191384,"user_name":"不学不行啊","can_delete":false,"product_type":"c1","uid":1335474,"ip_address":"","ucode":"69368165141C2D","user_header":"https://static001.geekbang.org/account/avatar/00/14/60/b2/ccebcb71.jpg","comment_is_top":false,"comment_ctime":1584769172,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584769172","product_id":100039001,"comment_content":"     封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。","like_count":0},{"had_liked":false,"id":189843,"user_name":"索旭东","can_delete":false,"product_type":"c1","uid":1139039,"ip_address":"","ucode":"BFD07BCD8C8CAE","user_header":"https://static001.geekbang.org/account/avatar/00/11/61/5f/b279daaf.jpg","comment_is_top":false,"comment_ctime":1584576618,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584576618","product_id":100039001,"comment_content":"上节课刚说抽象可能不是面向对象特有的，老师就这节课解惑了","like_count":0},{"had_liked":false,"id":186364,"user_name":"Conny","can_delete":false,"product_type":"c1","uid":1869997,"ip_address":"","ucode":"18E6CEAEE5E038","user_header":"https://static001.geekbang.org/account/avatar/00/1c/88/ad/0bb5a9a5.jpg","comment_is_top":false,"comment_ctime":1583830226,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583830226","product_id":100039001,"comment_content":"在学习这个之前已经懂前三种特性，但一直对多态特性有点模糊，所以学习后我想着重谈一下自己对多态特性的理解：<br>什么是多态？<br>个人理解，多态就是支持一个类的方法重写，重点在重写，从而实现代码的扩展和复用。<br>怎么实现多态？<br>利用继承、接口类、duck-typing类来实现。<br>继承类？<br>子类继承父类，并在内部重新改写某个父类的方法。调用的是子类的方法。<br>duck-typing类？<br>不同类只要拥有相同的方法（名字），就可以在某个包含这个方法的函数中，调用这些类的方法。由于不同类的方法有些不同，这就实现了多态。<br>接口类？<br>接口类似于搭建了（不专业地讲）一个中间的桥梁、（中二地讲）一个目录样式的激活器。可以在同一个函数中使用包含这个接口的不同类，从而实现调用其方法的目的。个人理解，接口类有点像在duck-typing类的基础上，给不同类加上了某种联系。","like_count":0},{"had_liked":false,"id":186026,"user_name":"冲鸭","can_delete":false,"product_type":"c1","uid":1115945,"ip_address":"","ucode":"0EF69B02188A73","user_header":"https://static001.geekbang.org/account/avatar/00/11/07/29/e5537b9e.jpg","comment_is_top":false,"comment_ctime":1583743958,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583743958","product_id":100039001,"comment_content":"java默认访问权限不是public吧","like_count":0},{"had_liked":false,"id":184806,"user_name":"hiwangqi","can_delete":false,"product_type":"c1","uid":1670440,"ip_address":"","ucode":"E5FAC94609A08F","user_header":"https://static001.geekbang.org/account/avatar/00/19/7d/28/0368cf29.jpg","comment_is_top":false,"comment_ctime":1583410087,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583410087","product_id":100039001,"comment_content":"讲的很好学习了","like_count":0},{"had_liked":false,"id":183689,"user_name":"peiyi","can_delete":false,"product_type":"c1","uid":1272214,"ip_address":"","ucode":"4834AC379A21AB","user_header":"https://static001.geekbang.org/account/avatar/00/13/69/96/f7d2d30e.jpg","comment_is_top":false,"comment_ctime":1583117066,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583117066","product_id":100039001,"comment_content":"C++支持多重继承，通过virtual关键字避免多重继承的问题。<br>封装：通过public&#47;protected&#47;private关键字实现。<br>抽象：通过函数封装&#47;纯接口类（只包含virtual修饰的函数）实现。<br>继承：通过冒号（：）实现，也可以用限定关键字修饰<br>多态：分为静态多态和动态多态。<br>静态多态：<br>1）函数模版&#47;类模板：通过给出不同类型参数；<br>2）函数重载&#47;运算符重载：改变参数等；<br>3）强制多态：一般是运算过程中运算类型强制转换，如double-》int；<br>动态多态：通过继承和虚函数实现。","like_count":0},{"had_liked":false,"id":183678,"user_name":"彭汤宇","can_delete":false,"product_type":"c1","uid":1160325,"ip_address":"","ucode":"72BDD100CB373A","user_header":"https://static001.geekbang.org/account/avatar/00/11/b4/85/e21fc61b.jpg","comment_is_top":false,"comment_ctime":1583115556,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583115556","product_id":100039001,"comment_content":"如果 Java 语言没有提供访问权限控制语法，所有的属性默认都是 public 的，那任意外部代码都可以通过类似 wallet.id=123。Java默认的不是default吗？","like_count":0},{"had_liked":false,"id":180565,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1582337585,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582337585","product_id":100039001,"comment_content":"封装：易用<br>抽象：易维护<br>继承：易复用<br>多态：易扩展","like_count":0},{"had_liked":false,"id":179601,"user_name":"未来小娃","can_delete":false,"product_type":"c1","uid":1047329,"ip_address":"","ucode":"477D166EBB6B70","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/21/d017438c.jpg","comment_is_top":false,"comment_ctime":1582037408,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1582037408","product_id":100039001,"comment_content":"封装隐藏了属性的访问，抽象隐藏了方法的实现，继承实现代码的复用，多态让类更易扩展。继承的使用会有个误区，继承能够表示现实is-a的关系，但是是否is-a的关系一定得用继承才能实现呢？我觉得未必，同一个类不用的实例罢了，其次大家都说公共的属性和方法放在父类，使用的时候往往过了头。意思就是不管属性或方法是否与父类有关 ，都往父类塞，别说你没这样做过，我自己也曾经犯过这样的错，那么这样会有什么问题呢？父类越来越臃肿，父类变成了工具类，那么你父类可真够累的。经常提醒自己是否可以放在公共类，或者是否与父类真的强相关。再说多态，不对比不知道，多态其实继承的延伸，运行时会调用子类重载过的方法，这样的好处是可以无限扩展子类，只需要实例化的时候指定子类的类型就好了，确实可以节省代码唉。再讨论下多继承，多继承首先与多态违背，一个既是A又是B的实例运行态到底选择谁。","like_count":0},{"had_liked":false,"id":179407,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1581998245,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581998245","product_id":100039001,"comment_content":"对于问题一,我比较熟悉Java,是不支持多重继承的,毕竟有一个经典的钻石问题,在多重继承的时候,可能因为继承的多个父类都具有相同的属性,从而导致子类无法指定使用哪个父类的方法,从而出现了歧义<br>2.Java本身是支持四大特性,如上面所说,封装通过类,继承通过extends,多态通过子类转换为父类调用,抽象通过接口类和抽象类实现了","like_count":0},{"had_liked":false,"id":178269,"user_name":"秀丽","can_delete":false,"product_type":"c1","uid":1402332,"ip_address":"","ucode":"9872272B8056F5","user_header":"https://static001.geekbang.org/account/avatar/00/15/65/dc/0737102d.jpg","comment_is_top":false,"comment_ctime":1581647468,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581647468","product_id":100039001,"comment_content":"封装：提高安全性<br>抽象：方法等的封装<br>继承：提高复用性<br>多态：提高扩展性","like_count":0},{"had_liked":false,"id":177887,"user_name":"Edward Lee","can_delete":false,"product_type":"c1","uid":1228518,"ip_address":"","ucode":"156223F1D7E94A","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/e6/7808520d.jpg","comment_is_top":false,"comment_ctime":1581521810,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581521810","product_id":100039001,"comment_content":"为了方便记忆封装，抽象，继承，多态，个人总结为<br><br>封装 - function<br>抽象 - implements<br>继承 - extends<br>多态 - @Override","like_count":0},{"had_liked":false,"id":177618,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1581435358,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1581435358","product_id":100039001,"comment_content":"Java不支持多重继承，主要是为了避免钻石继承这种问题，Java提供了接口这种机制，用来实现某个类对多重继续这种特性的需求。在Java里，继承表示is-a这种关系，利用接口表示某个对象具有哪些行为能力。","like_count":0},{"had_liked":false,"id":176500,"user_name":"Geek_bb89c3","can_delete":false,"product_type":"c1","uid":1331828,"ip_address":"","ucode":"0F97B5B0F2DDD6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/IZKGetBZDuMEa2VwwtesTELvLORIyV749ItgfAqNPv30n4zEv71wuGNr1aNVIVltG0icvH53DHDuqPuzNpiauWAg/132","comment_is_top":false,"comment_ctime":1581072787,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581072787","product_id":100039001,"comment_content":"面向对象四大特性：封装，抽象，继承，多态。<br>封装：数据隐藏，和访问控制。需要语言提供数据访问权限，private，public，protected。这样做的优点一方面让系统变得更安全，只会让状态按照指定方式进行修改，而不会无法控制的修改，提高了可维护性。<br>抽象：分离功能和实现，让使用者简单的了解功能而忽略细节。这是一个通用特性，并不是oo特有的。抽象主要控制了系统的复杂度，系统易于维护，扩展和理解。<br>继承：在关系中的is-a关系。需要语言提供继承语法。主要解决代码复用的问题。继承分为单继承和多继承。过度继承的后果代码难以阅读和父类修改后会影响到子类。<br>多态：用父类引用指向子类对象的过程。需要语言提供抽象类语法。这样能提升系统的可扩展性，和复用性。使用一个父类，传入各种子类。<br>","like_count":0},{"had_liked":false,"id":175132,"user_name":"三尺寒冰","can_delete":false,"product_type":"c1","uid":1027586,"ip_address":"","ucode":"B10C7C9F955DF5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/02/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1580567524,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580567524","product_id":100039001,"comment_content":"java、php、javascript都不支持多重继承。<br>多重继承，就不能唯一确定父类了，调用父类方法可能报错。","like_count":0},{"had_liked":false,"id":174306,"user_name":"felix","can_delete":false,"product_type":"c1","uid":1086157,"ip_address":"","ucode":"DF514D0BB9B508","user_header":"https://static001.geekbang.org/account/avatar/00/10/92/cd/d39e568c.jpg","comment_is_top":false,"comment_ctime":1580132252,"is_pvip":false,"replies":[{"id":"67753","content":"生物没学好，你就当它会爬所以叫爬行动物吧😂","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1580174485,"ip_address":"","comment_id":174306,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1580132252","product_id":100039001,"comment_content":"“比如猫既是哺乳动物，又是爬行动物。”老师恐怕对爬行动物有什么误解吧？！😂","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482362,"discussion_content":"生物没学好，你就当它会爬所以叫爬行动物吧😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580174485,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1086157,"avatar":"https://static001.geekbang.org/account/avatar/00/10/92/cd/d39e568c.jpg","nickname":"felix","note":"","ucode":"DF514D0BB9B508","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":154728,"discussion_content":"got it","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580178062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174070,"user_name":"巨龙的力量啊","can_delete":false,"product_type":"c1","uid":1684858,"ip_address":"","ucode":"8FC6978929E48F","user_header":"https://static001.geekbang.org/account/avatar/00/19/b5/7a/a126c48f.jpg","comment_is_top":false,"comment_ctime":1579944042,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579944042","product_id":100039001,"comment_content":"前端前来打卡，真的学到东西啦","like_count":0},{"had_liked":false,"id":172960,"user_name":"linker","can_delete":false,"product_type":"c1","uid":1803259,"ip_address":"","ucode":"6C5799F2FC2C82","user_header":"https://static001.geekbang.org/account/avatar/00/1b/83/fb/621adceb.jpg","comment_is_top":false,"comment_ctime":1579395648,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579395648","product_id":100039001,"comment_content":"1:c需要不支持多继承，也不支持继承，我觉得它可以把结构体签到嵌入结构体来模拟继承，不知道对不对。<br>2:c需要不支持面向对象的四大特性语法，个人感觉是因为c需要早起发明的，当时软件设计没有这么复杂，没有考虑这些高级特性；另外由于c语言是为了写操作系统等底层接近硬件的软件发明的，所以对语言的性能有要求，而加上面向对象的特性可能会增加编译器的复杂性并且编译出来的二进制效率不高。","like_count":0},{"had_liked":false,"id":172593,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1579229243,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579229243","product_id":100039001,"comment_content":"封装：隐藏内部，暴露细节。<br>抽象：隐藏具体，关注功能。<br>继承：is-a关系。<br>多态：父类的变量指向子类的对象，执行的是子类重写的方法。","like_count":0},{"had_liked":false,"id":172132,"user_name":"双枪伽利略","can_delete":false,"product_type":"c1","uid":1267664,"ip_address":"","ucode":"14EAE02D543FE3","user_header":"https://static001.geekbang.org/account/avatar/00/13/57/d0/e2118a3b.jpg","comment_is_top":false,"comment_ctime":1579094424,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579094424","product_id":100039001,"comment_content":"python, 避免多重继承的副作用的方法：不用","like_count":0},{"had_liked":false,"id":172118,"user_name":"拉欧","can_delete":false,"product_type":"c1","uid":1206605,"ip_address":"","ucode":"40996A8093A95F","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/4d/81c44f45.jpg","comment_is_top":false,"comment_ctime":1579093002,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579093002","product_id":100039001,"comment_content":"老师讲的非常透彻，基本是面试的标准答案","like_count":0},{"had_liked":false,"id":172022,"user_name":"茶没喝完","can_delete":false,"product_type":"c1","uid":1644104,"ip_address":"","ucode":"D72D88C42A1258","user_header":"https://static001.geekbang.org/account/avatar/00/19/16/48/09493874.jpg","comment_is_top":false,"comment_ctime":1579072980,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579072980","product_id":100039001,"comment_content":"老师我太爱您了，解开了我多年学java的迷惑。感谢！！！！","like_count":0},{"had_liked":false,"id":169193,"user_name":"varotene","can_delete":false,"product_type":"c1","uid":1004441,"ip_address":"","ucode":"B37E9B6D35090C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/53/99/56f148bc.jpg","comment_is_top":false,"comment_ctime":1578289638,"is_pvip":false,"replies":[{"id":"65743","content":"看少哪一两个了，实际上，少抽象、少继承都没太大问题","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1578379707,"ip_address":"","comment_id":169193,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578289638","product_id":100039001,"comment_content":"如果没有这四大特性，或者四大特性中少一两个，感觉还能实现面向对象编程想要达到的目的？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480452,"discussion_content":"看少哪一两个了，实际上，少抽象、少继承都没太大问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578379707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166688,"user_name":"程序员大天地","can_delete":false,"product_type":"c1","uid":1249001,"ip_address":"","ucode":"7A21F15FEE2D5B","user_header":"https://static001.geekbang.org/account/avatar/00/13/0e/e9/98b6ea61.jpg","comment_is_top":false,"comment_ctime":1577543567,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577543567","product_id":100039001,"comment_content":"2、GO语言支持封装，用结构体支持的；也支持抽象，使用接口类interface实现；支持多态，是接口类语法实现。","like_count":0},{"had_liked":false,"id":166686,"user_name":"程序员大天地","can_delete":false,"product_type":"c1","uid":1249001,"ip_address":"","ucode":"7A21F15FEE2D5B","user_header":"https://static001.geekbang.org/account/avatar/00/13/0e/e9/98b6ea61.jpg","comment_is_top":false,"comment_ctime":1577543436,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577543436","product_id":100039001,"comment_content":"1、Go语言不支持继承，估计是考虑到继承过多代码不易阅读。GO语言虽然不支持继承，但是支持组合。","like_count":0},{"had_liked":false,"id":166625,"user_name":"王岩","can_delete":false,"product_type":"c1","uid":1022558,"ip_address":"","ucode":"434F1A28A7B54C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9a/5e/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1577523426,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577523426","product_id":100039001,"comment_content":"1. Java 语言不支持多继承，支持多实现。主要因为调用的不确定性，多实现不会发生调用不确定性问题；<br>public abstract class Animal1 {<br>    <br>    void eat(){<br>        System.out.println(&quot;Animal1 eat&quot;);<br>    }<br>}<br>public class Animal2 {<br><br>    void eat(){<br>        System.out.println(&quot;Animal2 eat&quot;);<br>    }<br>}<br>public class Dog extends Animal1,Animal2 {<br><br>    @Override<br>    void eat(){<br>        &#47;&#47; 调用不确定性：执行Animal1的eat方法还是执行Animal2的eat方法？<br>        super.eat();<br>    }<br>}<br>由于接口中的方法没有实现，实现类的重写方法会同时覆盖多个接口中的方法。另外一点，继承本身存在的一个问题就是会使类的体系变得复杂，如果多继承的话，会让这个问题更加严重<br>2.封装还有一个好处：写这个类的人可以任意修改类中 private 修饰的代码，而不用担心会对调用者产生的影响，也算是提高了代码维护性吧<br>以上是个人理解，不知对不对，希望大家指点","like_count":0},{"had_liked":false,"id":166535,"user_name":"北风一叶","can_delete":false,"product_type":"c1","uid":1087302,"ip_address":"","ucode":"30310E66341D2A","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/46/fe1f21d8.jpg","comment_is_top":false,"comment_ctime":1577488139,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577488139","product_id":100039001,"comment_content":"1. 封装：隐藏非必要的函数、接口，暴露必要的函数、接口供外部访问，可以有效的进行信息隐藏和数据访问保护<br>2. 抽象：讲述如何隐藏方法的具体实现，让使用者只需要关注方法的具体功能<br>3. 继承：分类单继承和多继承，类间为is-a的关系使子类出现的地方可以被替换为父类<br>4. 多态：实现面对接口编程的非常重要的特性<br>几个特性完美结合，最终实现可扩展性、可复用等特性","like_count":0},{"had_liked":false,"id":165916,"user_name":"阿U","can_delete":false,"product_type":"c1","uid":1171359,"ip_address":"","ucode":"161A8E74E0D612","user_header":"https://static001.geekbang.org/account/avatar/00/11/df/9f/6e3e1b77.jpg","comment_is_top":false,"comment_ctime":1577344972,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1577344972","product_id":100039001,"comment_content":"搞不懂评论都在说多继承，文章明明说多重继承，这不是一个概念吧。多重继承是指a继承b，b继承c，相当于c是a父类的父类，所以JAVA是支持多重继承的。但不支持多继承 会造成大家说的那种问题。","like_count":0,"discussions":[{"author":{"id":1577580,"avatar":"https://static001.geekbang.org/account/avatar/00/18/12/6c/61a598e9.jpg","nickname":"苏暮沉觞","note":"","ucode":"532B816D4EF47B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":126792,"discussion_content":"多重继承跟多继承是一个概念，具体可以查看wiki百科：https://zh.wikipedia.org/wiki/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578538952,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165780,"user_name":"喵喵喵","can_delete":false,"product_type":"c1","uid":1211713,"ip_address":"","ucode":"E3AD8BF42E19DF","user_header":"https://static001.geekbang.org/account/avatar/00/12/7d/41/3c5b770b.jpg","comment_is_top":false,"comment_ctime":1577321994,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577321994","product_id":100039001,"comment_content":"打卡～","like_count":0},{"had_liked":false,"id":165375,"user_name":"我叫郭小黑","can_delete":false,"product_type":"c1","uid":1463441,"ip_address":"","ucode":"C238592EB5EDBC","user_header":"https://static001.geekbang.org/account/avatar/00/16/54/91/0d4647d9.jpg","comment_is_top":false,"comment_ctime":1577231693,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577231693","product_id":100039001,"comment_content":"第一个问题，使用java语言，不支持多继承，因为在多继承的时候，如果两个父类存在同样的方法，那么继承类不知道要继承具体哪一个方法，而同样子类在重新父类方法时，并不知道要重写哪个父类的方法。<br>第二个问题，java支持四大特性。<br>  对于封装使用了访问权限的关键字来控制。<br>  对于抽象可以采用类抽象和接口抽象，当然对于类的方法也是一种抽象。<br>  java可以使用extends关键字实现单继承。<br>  由于继承，父类可以引用子类对象，重写等特性，可以实现多态。","like_count":0},{"had_liked":false,"id":164737,"user_name":"黄政","can_delete":false,"product_type":"c1","uid":1345630,"ip_address":"","ucode":"9076A1BF7BB051","user_header":"https://static001.geekbang.org/account/avatar/00/14/88/5e/cc916a2b.jpg","comment_is_top":false,"comment_ctime":1577084397,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1577084397","product_id":100039001,"comment_content":"1.C++，当前支持多重继承。可以通过虚继承，来解决多重继承中，引用基类接口产生二义性的问题<br>2.C++对当前四大特性，均支持<br>1）封装：class类<br>2）抽象：函数接口即可做到<br>3）继承：C++当前支持继承特性<br>4）多态：基类函数定义成virual函数，子类中实现对应功能","like_count":0},{"had_liked":false,"id":164131,"user_name":"dingdongfm","can_delete":false,"product_type":"c1","uid":1564213,"ip_address":"","ucode":"7D17D2BC392A66","user_header":"","comment_is_top":false,"comment_ctime":1576892941,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576892941","product_id":100039001,"comment_content":"学习了，非常清晰的讲解","like_count":0},{"had_liked":false,"id":163867,"user_name":"Neuject","can_delete":false,"product_type":"c1","uid":1346309,"ip_address":"","ucode":"4DCFF6CDC4186E","user_header":"https://static001.geekbang.org/account/avatar/00/14/8b/05/3315b855.jpg","comment_is_top":false,"comment_ctime":1576814387,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576814387","product_id":100039001,"comment_content":"1. C#不支持类的多继承，避免多继承情况下继承的多个类具有相同内容时本身无法确定调用哪一个，因为多继承的话这些是平级的，也就是“菱形问题”。感觉多继承的这些需求都可以用继承多个接口完成，也可以类继承多个层级。<br><br>2. C#对于封装、抽象、继承、多态，这四个都有现成的语法支持。<br>封装：五种访问权限控制——public、protected、internal、protected internal、private<br>抽象：使用abstract关键字<br>继承：类和接口的继承都是使用“:”来实现，可以继承单个类和多个接口<br>多态：三种实现方式中①继承+方法重写、②接口类语法都可以实现，③duck-typing这种不行，感觉这种是在太灵活了，万物皆可多态实现了<br><br>PS：老师讲的真的太棒了，思路条理结构清晰，作为技术人员表达能力还这么强，真是我辈学习楷模啊","like_count":0},{"had_liked":false,"id":161207,"user_name":"BeanNan","can_delete":false,"product_type":"c1","uid":1088253,"ip_address":"","ucode":"FCF21A73BBE707","user_header":"https://static001.geekbang.org/account/avatar/00/10/9a/fd/30c425f9.jpg","comment_is_top":false,"comment_ctime":1576147559,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576147559","product_id":100039001,"comment_content":"Java不支持多继承的原因在于，继承多个类，维护起这些类中各个state很麻烦，所以只允许单继承，但是可以多实现接口，接口里面只有对应的action, 不涉及状态的维护","like_count":0},{"had_liked":false,"id":161144,"user_name":"从未走远","can_delete":false,"product_type":"c1","uid":1032967,"ip_address":"","ucode":"C5D379BF4A0271","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c3/07/8e1b6592.jpg","comment_is_top":false,"comment_ctime":1576131791,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576131791","product_id":100039001,"comment_content":"“如果 Java 语言没有提供访问权限控制语法，所有的属性默认都是 public 的”              关于Java的访问修饰符，应该是四种private，不写，protected，public把，默认用的是“不写“这种级别吧？","like_count":0},{"had_liked":false,"id":161130,"user_name":"rammelzzz","can_delete":false,"product_type":"c1","uid":1606275,"ip_address":"","ucode":"3BA634B5F6F74B","user_header":"https://static001.geekbang.org/account/avatar/00/18/82/83/8f168e4e.jpg","comment_is_top":false,"comment_ctime":1576125493,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576125493","product_id":100039001,"comment_content":"封装不仅体现在类的设计上。当需要给外部服务提供接口时，接口封装越好，外部对所提供服务的认知就会越简单越容易理解。反之则需要理解你的复杂业务逻辑，比如我给你传这个参数是什么含义类似的问题","like_count":0},{"had_liked":false,"id":160473,"user_name":"levi","can_delete":false,"product_type":"c1","uid":1259800,"ip_address":"","ucode":"C616B6172778F7","user_header":"https://static001.geekbang.org/account/avatar/00/13/39/18/2d739edc.jpg","comment_is_top":false,"comment_ctime":1575958422,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575958422","product_id":100039001,"comment_content":"争哥,请教一个问题,总感觉策略模式和多态很像,多态是策略模式的一种实现方式吗<br>","like_count":0},{"had_liked":false,"id":159785,"user_name":"爱水人家","can_delete":false,"product_type":"c1","uid":1730305,"ip_address":"","ucode":"0C94C6ACBC9CEB","user_header":"https://static001.geekbang.org/account/avatar/00/1a/67/01/44626cb9.jpg","comment_is_top":false,"comment_ctime":1575788471,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575788471","product_id":100039001,"comment_content":"我是C++使用者。众所周知，C++是支持多重继承的，为了避免多重继承带来的虚函数重写问题，C++定义了虚继承这种语法。","like_count":0},{"had_liked":false,"id":158393,"user_name":"疯狂的五花肉","can_delete":false,"product_type":"c1","uid":1642465,"ip_address":"","ucode":"B3CE22B3245EB3","user_header":"https://static001.geekbang.org/account/avatar/00/19/0f/e1/26632e59.jpg","comment_is_top":false,"comment_ctime":1575363366,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575363366","product_id":100039001,"comment_content":"你熟悉的编程语言是否支持多重继承？如果不支持，请说一下为什么不支持。如果支持，请说一下它是如何避免多重继承的副作用的。<br>答：Java与c++为例，Java都不支持多继承，c++支持多继承，多继承时，可能存在二义性，结构混乱。<br>java:可以使用接口类来实现多重继承的问题，接口没有具体实现，就可以去除二义性；<br>c++:使用虚基类解决这个副作用（例如有基类B，从B派生出C和D，然后类F又同时继承了C和D，现在类F的一个对象里面包含了两个基类B的对象，如果F访问自己的从基类B那里继承过来的的数据成员或者函数成员那么编译器就不知道你指的到底是从C那里继承过来的B对象呢还是从D那里继承过来的B对象。于是虚基类诞生了，将C和D的继承方式改为虚继承，那么F访问自己从B那里继承过来的成员就不会有二义性问题了，也就是将F对象里的B对象统一为一个，只有一个基类B对象）<br><br>你熟悉的编程语言对于四大特性是否都有现成的语法支持？对于支持的特性，是通过什么语法机制实现的？对于不支持的特性，又是基于什么原因做的取舍？<br>答：有现成的语法支持<br>封装（public，private等关键字）<br>多态（子类重写父类方法）<br>继承（extends关键字）<br>抽象（interface，abstract关键字）","like_count":0},{"had_liked":false,"id":158189,"user_name":"花花大脸猫","can_delete":false,"product_type":"c1","uid":1117318,"ip_address":"","ucode":"8ABDB3F7F4FB0F","user_header":"https://static001.geekbang.org/account/avatar/00/11/0c/86/8e52afb8.jpg","comment_is_top":false,"comment_ctime":1575344520,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1575344520","product_id":100039001,"comment_content":"1，java不支持，多继承的话如果父类有同名方法，子类无法决策调用哪个具体实现，如果是子类实现多个接口的话，同名接口方法只会在子类实现一次，没有上述父类多继承无法决策调用哪个具体实现的问题。<br>2.如老师所述，java目前都支持。","like_count":0},{"had_liked":false,"id":157166,"user_name":"疯狂土豆","can_delete":false,"product_type":"c1","uid":1273966,"ip_address":"","ucode":"16ADC351B57151","user_header":"https://static001.geekbang.org/account/avatar/00/13/70/6e/27f43b70.jpg","comment_is_top":false,"comment_ctime":1575052348,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575052348","product_id":100039001,"comment_content":"争哥，我是java的，一直有一个疑问反射是不是跳过了像private的限制，可以随意访问和设置属性的值了，那私有属性的设置也就没有意义了，是不是有点矛盾？","like_count":0},{"had_liked":false,"id":156716,"user_name":"冰ྂ镇ྂ可ྂ乐ྂ","can_delete":false,"product_type":"c1","uid":1455996,"ip_address":"","ucode":"A19F24BA1178FB","user_header":"https://static001.geekbang.org/account/avatar/00/16/37/7c/b6bc6024.jpg","comment_is_top":false,"comment_ctime":1574941455,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574941455","product_id":100039001,"comment_content":"python支持多重继承，对于方法解析顺序（MRO）的搜索，在经典类和新式类中是不同的：","like_count":0},{"had_liked":false,"id":156689,"user_name":"奇小易","can_delete":false,"product_type":"c1","uid":1171151,"ip_address":"","ucode":"E06B4DFB5352BB","user_header":"https://static001.geekbang.org/account/avatar/00/11/de/cf/ef2e0501.jpg","comment_is_top":false,"comment_ctime":1574935790,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574935790","product_id":100039001,"comment_content":"Q: 你熟悉的编程语言是否支持多重继承？如果不支持，请说一下为什么不支持。如果支持，请说一下它是如何避免多重继承的副作用的。<br>A: Python支持多重继承，使用MRO（Method Resolution Order）算法解决多继承的二义性问题，现在的实现是C3算法。多继承情况下，查询方法的顺序是从下至上，从左至右。先从最近的父类这一层开始查找，从左往右查，找不到以同样的方式向更上层的父类进行查找，以此类推，找到第一个执行，找不到抛未找到错误。<br>参考资料：https:&#47;&#47;www.python.org&#47;download&#47;releases&#47;2.3&#47;mro&#47;<br><br>Q: 你熟悉的编程语言对于四大特性是否都有现成的语法支持？对于支持的特性，是通过什么语法机制实现的？对于不支持的特性，又是基于什么原因做的取舍？<br>A: <br>Python<br>封装：使用变量命名的规范来隐藏数据（语法本身不支持，应该是作为动态语言，要做这样的限制很难？其实不是很懂这个原因）<br>继承：直接现有的继承语法<br>抽象：函数<br>多态：duck-typing<br>Python没有Java中的抽象类、接口类这种特定语法支持，但可以通过普通类来实现此功能，只需要在父类中实现一个抛出&quot;未实现&quot;异常的方法即可。","like_count":0},{"had_liked":false,"id":156183,"user_name":"mirapm","can_delete":false,"product_type":"c1","uid":1477646,"ip_address":"","ucode":"56478F8E0BE9D1","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/0e/a8b2a5bb.jpg","comment_is_top":false,"comment_ctime":1574829775,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574829775","product_id":100039001,"comment_content":"duck typing跟C++的模板很相似呀","like_count":0},{"had_liked":false,"id":155969,"user_name":"王麒","can_delete":false,"product_type":"c1","uid":1265260,"ip_address":"","ucode":"330017C5A911B6","user_header":"https://static001.geekbang.org/account/avatar/00/13/4e/6c/71020c59.jpg","comment_is_top":false,"comment_ctime":1574785791,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574785791","product_id":100039001,"comment_content":"Go的接口是隐式实现的，某种程度上来说，利用他的接口实现的多态也可以理解为一种duck-typing吧？","like_count":0},{"had_liked":false,"id":155714,"user_name":"Pioneer4","can_delete":false,"product_type":"c1","uid":1742839,"ip_address":"","ucode":"EE095D397D9BB4","user_header":"https://static001.geekbang.org/account/avatar/00/1a/97/f7/8afbb146.jpg","comment_is_top":false,"comment_ctime":1574741718,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574741718","product_id":100039001,"comment_content":"1. 你熟悉的编程语言是否支持多重继承？如果不支持，请说一下为什么不支持。如果支持，请说一下它是如何避免多重继承的副作用的。<br>我熟悉的C语言不支持继承，由于是面向过程的语言，更注重底层实现，缺少面向对象语言的封装、继承、多态机制。熟悉的java支持单继承，由于其语法机制决定了它的使用。如果java虽然不能实现多继承，但可以通过接口，组合等方式达到同样的效果。<br><br>2、你熟悉的编程语言对于四大特性是否都有现成的语法支持？对于支持的特性，是通过什么语法机制实现的？对于不支持的特性，又是基于什么原因做的取舍？<br>java支持四大特性。封装方面基于public、protect、default、private权限控制关键字实现；抽象通过abstract class、method和 interface实现；继承主要为单继承多实现，利用extends、implements机制。多态通过父类引用指向子类、接口指向子类、子类重写父类方法等实现。","like_count":0},{"had_liked":false,"id":155621,"user_name":"greg","can_delete":false,"product_type":"c1","uid":1189197,"ip_address":"","ucode":"BEE952C7ED2C84","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/0o2FEeJiav8lK9Y49JUOBretDypyHic2FL9dSZYnweBPZ5ibm3vgfm3q7kgXmQEOGOLJFgPEcMweVFj5QTrt4Vb4g/132","comment_is_top":false,"comment_ctime":1574729526,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574729526","product_id":100039001,"comment_content":"是什么，怎么用，可以用来解决什么问题。 整片文章思路很清晰，赞。","like_count":0},{"had_liked":false,"id":155102,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1574646201,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574646201","product_id":100039001,"comment_content":"字码结合 赞","like_count":0},{"had_liked":false,"id":155046,"user_name":"张鼎松","can_delete":false,"product_type":"c1","uid":1063160,"ip_address":"","ucode":"061F86EA9AA93D","user_header":"https://static001.geekbang.org/account/avatar/00/10/38/f8/b7ae7c6d.jpg","comment_is_top":false,"comment_ctime":1574640941,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574640941","product_id":100039001,"comment_content":"问题:为了可以赋值给Itorator, Array和LinkedList独有的方法或者属性一定要是private吗？","like_count":0},{"had_liked":false,"id":154964,"user_name":"ray","can_delete":false,"product_type":"c1","uid":1717235,"ip_address":"","ucode":"10962C711CBC11","user_header":"","comment_is_top":false,"comment_ctime":1574605743,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574605743","product_id":100039001,"comment_content":"老师好，请问老师在什么应用情境下会使用protected设定成员变量、成员方法的权限，什么时候会使用private设定成员变量、成员方法的权限？通常开始设计类的时候，不会那么清楚知道哪些应该定为protected，哪些应该定为private，因此想听听老师的想法。<br><br>谢谢老师","like_count":0},{"had_liked":false,"id":154885,"user_name":"东流","can_delete":false,"product_type":"c1","uid":1738147,"ip_address":"","ucode":"2715BC6E87BD83","user_header":"https://static001.geekbang.org/account/avatar/00/1a/85/a3/7e078442.jpg","comment_is_top":false,"comment_ctime":1574588337,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574588337","product_id":100039001,"comment_content":"java,类集成不支持多继承，因为避免菱形问题。但类可以实现多个接口，变现实现了多继承的部分功能<br>四大特性都有，<br>封装:通过关键private,protected,default,public实现<br>抽象:接口和抽象类<br>继承:extends,implement<br>多态:override注解","like_count":0},{"had_liked":false,"id":154824,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1274787,"ip_address":"","ucode":"C233DF1D224EC1","user_header":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","comment_is_top":false,"comment_ctime":1574575202,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574575202","product_id":100039001,"comment_content":"我熟悉的语言是Java和Objective-C以及swift。<br>Java不支持单继承是因为若一个类A同时继承两个类B和C，B和C中都有同样的方法,A的实例对象调用这个相同的方法时，无法知道调用的是哪一个父类的方法。<br>Objective-C以及swift也不支持多继承，二者采用的都是通过协议，类似Java的接口，以达到多重继承的效果。<br><br>大学的时候只学了一门C++，支持多重继承，当继承的父类中都有相同的父类时，多重继承的时候会出现二义性，通过如下方式避免：<br>1、类名限定：调用时指名调用的是哪个类的函数<br>2、同名覆盖：子类中声明一个同名函数，该函数根据需要内部调用某个父类的这个同名函数<br>3、虚基类：定义虚基类，直接或间接继承虚基类的所有派生类","like_count":0},{"had_liked":false,"id":154665,"user_name":"秋雨飘落","can_delete":false,"product_type":"c1","uid":1124916,"ip_address":"","ucode":"EC795F8DEC00EB","user_header":"https://static001.geekbang.org/account/avatar/00/11/2a/34/78656be9.jpg","comment_is_top":false,"comment_ctime":1574504377,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574504377","product_id":100039001,"comment_content":"四大特性 多态理解不清楚","like_count":0},{"had_liked":false,"id":154043,"user_name":"遗忘的童话","can_delete":false,"product_type":"c1","uid":1252850,"ip_address":"","ucode":"E11D9E8A11A82C","user_header":"https://static001.geekbang.org/account/avatar/00/13/1d/f2/81918ad5.jpg","comment_is_top":false,"comment_ctime":1574353251,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574353251","product_id":100039001,"comment_content":"我就不总结，我只想说一句话，钱花的真值啊！","like_count":0},{"had_liked":false,"id":153920,"user_name":"真是艹0","can_delete":false,"product_type":"c1","uid":1234043,"ip_address":"","ucode":"0A082CE0D79C6E","user_header":"https://static001.geekbang.org/account/avatar/00/12/d4/7b/74e59208.jpg","comment_is_top":false,"comment_ctime":1574330261,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574330261","product_id":100039001,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":153887,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1025030,"ip_address":"","ucode":"62A89FD460827A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a4/06/cf6b6d0f.jpg","comment_is_top":false,"comment_ctime":1574325785,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574325785","product_id":100039001,"comment_content":"我熟悉的就是Java，争哥都已经总结好了：<br>- 封装，使用访问权限控制 public、protected、default、private<br>- 抽象，使用接口类和抽象类<br>- 继承，使用 extends 实现单继承<br>- 多态，借助继承和抽象类都能实现多态","like_count":0},{"had_liked":false,"id":153833,"user_name":"肖臧","can_delete":false,"product_type":"c1","uid":1047733,"ip_address":"","ucode":"4FAC9FF54DD6A0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fc/b5/ac717737.jpg","comment_is_top":false,"comment_ctime":1574315191,"is_pvip":false,"replies":[{"id":"59136","content":"本身代码就省略了很多东西 主要是为了讲原理","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1574331642,"ip_address":"","comment_id":153833,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1574315191","product_id":100039001,"comment_content":"封装的虚拟钱包类，没考虑多线程场景吧，增减操作都不是线程安全的","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475291,"discussion_content":"本身代码就省略了很多东西 主要是为了讲原理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574331642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1047733,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fc/b5/ac717737.jpg","nickname":"肖臧","note":"","ucode":"4FAC9FF54DD6A0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55006,"discussion_content":"的确是要忽略很多细节，才能突出您想表达的封装，就怕有人拿来主义，无脑拿过去用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574331793,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153339,"user_name":"昵称不重要","can_delete":false,"product_type":"c1","uid":1156872,"ip_address":"","ucode":"50F0E9DC56AE3B","user_header":"https://static001.geekbang.org/account/avatar/00/11/a7/08/802cc83f.jpg","comment_is_top":false,"comment_ctime":1574219967,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574219967","product_id":100039001,"comment_content":"目前没用过多继承，经过争哥讲解对于四大特性理解更清晰了","like_count":0},{"had_liked":false,"id":153069,"user_name":"千年孤独","can_delete":false,"product_type":"c1","uid":1037215,"ip_address":"","ucode":"282CA1A68E8774","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d3/9f/36ea3be4.jpg","comment_is_top":false,"comment_ctime":1574152679,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574152679","product_id":100039001,"comment_content":"用Golang实现的多态代码：<br>package main<br><br>import &quot;fmt&quot;<br><br>type Animal interface {<br>\tGetName() string<br>}<br><br>type Cat struct{<br>\tName string<br>}<br><br>func (a *Cat) GetName() string{<br>\tfmt.Println(&quot;Cat&quot;)<br>\treturn a.Name<br>}<br><br>func Exec(animal Animal) string{<br>\tfmt.Println(&quot;Animal&quot;)<br>\treturn animal.GetName()<br>}<br><br>type Dog struct {<br>\tName string<br>}<br><br>func (a *Dog) GetName() string{<br>\tfmt.Println(&quot;Dog&quot;)<br>\treturn a.Name<br>}<br><br>func main() {<br>\tvar  dog Animal = &amp;Dog{Name:&quot;this is a dog&quot;}<br>\tvar cat Animal = &amp;Cat{Name:&quot;this is a cat&quot;}<br>\tfmt.Println(Exec(dog))<br>\tfmt.Println(Exec(cat))<br>}","like_count":0},{"had_liked":false,"id":152979,"user_name":"Kevin","can_delete":false,"product_type":"c1","uid":1429627,"ip_address":"","ucode":"9DFFD6E3960CF7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJN64OCUT0Jp0h2Wiau9Os0o1WbwUeoq2QL0U2vZpib8ozPxo0XDiaPM9xcKfbkoBL24ztEHelxPIMVg/132","comment_is_top":false,"comment_ctime":1574133033,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574133033","product_id":100039001,"comment_content":"方法本身也是抽象，读者只需要从方法名，参数，返回值来整体理解方法作用，忽略掉方法实现 。<br>很优秀的理解。","like_count":0},{"had_liked":false,"id":152936,"user_name":"超级小帅兔","can_delete":false,"product_type":"c1","uid":1190963,"ip_address":"","ucode":"3D9FAC98D82637","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtxPelZRoA8WOx5ESmW4CIj9icf1XHNsDqyCaBudmVzSX2pSiacEn7IlLRic8ePegiaRwBet7nwKQkicg/132","comment_is_top":false,"comment_ctime":1574126370,"is_pvip":true,"replies":[{"id":"58732","content":"😂 好像不是...","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1574128431,"ip_address":"","comment_id":152936,"utype":1}],"discussion_count":2,"race_medal":2,"score":"1574126370","product_id":100039001,"comment_content":"王峥老师，感谢优质文章。只有一个小问题，猫是爬行动物吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474995,"discussion_content":"😂 好像不是...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574128431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1190963,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtxPelZRoA8WOx5ESmW4CIj9icf1XHNsDqyCaBudmVzSX2pSiacEn7IlLRic8ePegiaRwBet7nwKQkicg/132","nickname":"超级小帅兔","note":"","ucode":"3D9FAC98D82637","race_medal":2,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53062,"discussion_content":":)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574128506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152838,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1574086452,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574086452","product_id":100039001,"comment_content":"第一次认识到暴露方法就是抽象的一种","like_count":0},{"had_liked":false,"id":152817,"user_name":"wyf2317","can_delete":false,"product_type":"c1","uid":1236837,"ip_address":"","ucode":"7F3E61A6188B39","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ub4icibeRLzff8Nf6ORsolib9KHtmeu3d4cCCAFd3Xgah3v78WfDYQB7WKq9iaIPXPwHBxw7mkBP9wYxDGMT9m1Rbw/132","comment_is_top":false,"comment_ctime":1574083228,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574083228","product_id":100039001,"comment_content":"1. 多重继承容易遇到钻石继承的问题","like_count":0},{"had_liked":false,"id":152792,"user_name":"兢","can_delete":false,"product_type":"c1","uid":1070683,"ip_address":"","ucode":"878EAA03E02C1C","user_header":"","comment_is_top":false,"comment_ctime":1574080678,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574080678","product_id":100039001,"comment_content":"“如果 Java 语言没有提供访问权限控制语法，所有的属性默认都是 public 的” 。貌似不是public，是包内的访问权限","like_count":0},{"had_liked":false,"id":152742,"user_name":"任先森","can_delete":false,"product_type":"c1","uid":1337482,"ip_address":"","ucode":"A3EE0FD8231F8D","user_header":"https://static001.geekbang.org/account/avatar/00/14/68/8a/620aa4ea.jpg","comment_is_top":false,"comment_ctime":1574073546,"is_pvip":false,"replies":[{"id":"60035","content":"1. bean中不要写特别四的逻辑，这个怎么理解呢？<br>2. 如果有需求的话，可以添加set方法和get修改时间的方法","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1574855292,"ip_address":"","comment_id":152742,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574073546","product_id":100039001,"comment_content":"王老师，我有一点没能理解。就是刚开始写的虚拟钱包类(Walet),是不是封装的有点过了呢，我看阿里巴巴开发规范，不要在bean里写特别的死的逻辑，否则排查问题不好排查，<br>还有一个就是没理解，不写set的话从数据库里查怎么放到bean里呢，还有一个是页面应该也会显示最后修改时间，没有get，怎么取出最后修改时间呢","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474922,"discussion_content":"1. bean中不要写特别四的逻辑，这个怎么理解呢？\n2. 如果有需求的话，可以添加set方法和get修改时间的方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574855292,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152727,"user_name":"志振爱咋滴咋滴","can_delete":false,"product_type":"c1","uid":1237624,"ip_address":"","ucode":"E7A5049920C101","user_header":"https://static001.geekbang.org/account/avatar/00/12/e2/78/9241b7b2.jpg","comment_is_top":false,"comment_ctime":1574070530,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574070530","product_id":100039001,"comment_content":"1.目前使用java语言，并不支持多重继承，主要就是避免在多重继承中，如果出现方法重载的时候，子类无法确定自己到底该直接实现何者重载的方法。<br>2.java目前就是比较支持这四个特性的。<br>封装：该要的要不该要的不要<br>继承：能剩就剩，但是要避免出现歧义<br>多态：大家都能用才是真好用<br>抽象：不该知道的就别知道的好","like_count":0},{"had_liked":false,"id":152660,"user_name":"Heiky","can_delete":false,"product_type":"c1","uid":1623626,"ip_address":"","ucode":"03AA79E1BC4AE4","user_header":"https://static001.geekbang.org/account/avatar/00/18/c6/4a/3bd896fc.jpg","comment_is_top":false,"comment_ctime":1574058485,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574058485","product_id":100039001,"comment_content":"Java不支持多继承的原因，就是会出现钻石问题，二义性的问题，想必有很多小伙伴都知道。另外我想说一点，多态的定义，父类引用指向子类对象，这样是不是更好理解，引用指向子类对象，调用的方法也会是子类重写之后的方法。","like_count":0},{"had_liked":false,"id":152658,"user_name":"冲","can_delete":false,"product_type":"c1","uid":1149914,"ip_address":"","ucode":"4191C8A4DF3840","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIk46cor5XVFTPZbPOnb7pViabgy450pobo46hRHFQz5nR5ocYRKIzC8vShic36vwa553H4Vj50x5wA/132","comment_is_top":false,"comment_ctime":1574058227,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574058227","product_id":100039001,"comment_content":"C#不支持类多继承，但是支持多接口继承","like_count":0},{"had_liked":false,"id":152650,"user_name":"钢！","can_delete":false,"product_type":"c1","uid":1246834,"ip_address":"","ucode":"22155C1F87AC72","user_header":"https://static001.geekbang.org/account/avatar/00/13/06/72/d5b570e1.jpg","comment_is_top":false,"comment_ctime":1574056685,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574056685","product_id":100039001,"comment_content":"谈谈我对四大特性的理解<br>封装：对外：保证了类使用的简便，隐藏了复杂的实现，<br>          对内：保证了对象属性即对象内存操作的规范性，可将变化限制在有限范围，做到了可控。","like_count":0},{"had_liked":false,"id":152435,"user_name":"Fun","can_delete":false,"product_type":"c1","uid":1145502,"ip_address":"","ucode":"5D89BA4C678785","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJdUGdEj3R25CrYqibPibYibibRicqUfyL4aTTPbMagyywjKMhXGZE37RTe7lEdvC4DibvtYpzg8zXvt9HQ/132","comment_is_top":false,"comment_ctime":1574000623,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574000623","product_id":100039001,"comment_content":"# day 9<br>继续学习OOP的四大特性的概念。<br>封装：数据访问保护。可以提高代码易用性；<br>抽象：屏蔽函数功能实现细节。可以提高代码可复用性；<br>继承：表现is-a的一种关系，只有OOPL才有提供语法支持。可以提高代码复用性，扩展性；<br>多态：子类代替父类，同样只有OOPL才有提供语法机制。可以提高代码复用性，扩展性，是很多设计模式，设计原则，编码技巧的基础。","like_count":0},{"had_liked":false,"id":152354,"user_name":"王振华 程序员","can_delete":false,"product_type":"c1","uid":1131957,"ip_address":"","ucode":"31BB337642B882","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/b5/c3cfb198.jpg","comment_is_top":false,"comment_ctime":1573980978,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573980978","product_id":100039001,"comment_content":"Ruby不支持多重继承，因为会很混乱。但如果除了父类中的属性、方法，子类还想复用其他的属性、方法，在Ruby中还提供了 mixin的方式，来从module中引入。module和类相似，只是不能定义实例。可以理解为只有方法，没有数据。","like_count":0},{"had_liked":false,"id":152301,"user_name":"大胃王","can_delete":false,"product_type":"c1","uid":1120238,"ip_address":"","ucode":"17072DCDB4C7FC","user_header":"https://static001.geekbang.org/account/avatar/00/11/17/ee/b123e7bc.jpg","comment_is_top":false,"comment_ctime":1573964593,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1573964593","product_id":100039001,"comment_content":"回顾计算机语言发展历史：二进制-&gt;汇编-&gt;面向过程-&gt;面向对象-&gt;？<br><br>可以发现，计算机语言的发展历史本质上是为了解决：软件开发速度无法满足软件发展需要的矛盾，所以个人认为计算机语言会朝着越来越简单的方向发展。事后诸葛的角度来看，继承特性是过度设计了，抽象类也没有必要存在。","like_count":0,"discussions":[{"author":{"id":1429627,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJN64OCUT0Jp0h2Wiau9Os0o1WbwUeoq2QL0U2vZpib8ozPxo0XDiaPM9xcKfbkoBL24ztEHelxPIMVg/132","nickname":"Kevin","note":"","ucode":"9DFFD6E3960CF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53105,"discussion_content":"面向自然语言","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574132907,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152258,"user_name":"条","can_delete":false,"product_type":"c1","uid":1203836,"ip_address":"","ucode":"6F8679175256E3","user_header":"https://static001.geekbang.org/account/avatar/00/12/5e/7c/94af3f5e.jpg","comment_is_top":false,"comment_ctime":1573954367,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573954367","product_id":100039001,"comment_content":"1.编程语言：java，只支持单继承，如果对多继承支持，会有二义性的问题。<br>2.java对四大特性的支持：<br>(1)封装：访问权限控制。<br>(2)抽象：interface和abstract(非必须语法支持)，需要提供函数这个基础特性。<br>(3)继承：extends关键字。<br>(4)多态：1)父类可以引用子类的对象。<br>              2)继承父类(extends)或实现接口(implements)。<br>              3)子类可以重写父类方法。<br><br>","like_count":0},{"had_liked":false,"id":152247,"user_name":"码农Kevin亮","can_delete":false,"product_type":"c1","uid":1116630,"ip_address":"","ucode":"D34562461CA0A1","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/d6/5f366427.jpg","comment_is_top":false,"comment_ctime":1573950668,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573950668","product_id":100039001,"comment_content":"用了这么久js，一直没明白什么是duck-typing，老师这么一说就秒懂了","like_count":0},{"had_liked":false,"id":152207,"user_name":"林夕","can_delete":false,"product_type":"c1","uid":1494249,"ip_address":"","ucode":"89ADA39FC10BBD","user_header":"https://static001.geekbang.org/account/avatar/00/16/cc/e9/19497393.jpg","comment_is_top":false,"comment_ctime":1573914858,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573914858","product_id":100039001,"comment_content":"动态数组排序那个循环过后的那个语句觉得有点怪怪的，循环里已经是把大的是放在最后一个位置了，循环过后又把e放到最后一个位置了。。。","like_count":0},{"had_liked":false,"id":152074,"user_name":"个人练习生niki👍","can_delete":false,"product_type":"c1","uid":1191678,"ip_address":"","ucode":"48E5D6DE94BBBB","user_header":"https://static001.geekbang.org/account/avatar/00/12/2e/fe/5541689b.jpg","comment_is_top":false,"comment_ctime":1573870823,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573870823","product_id":100039001,"comment_content":"Java中语法不支持多继承，通过内部类的方式对多继承妥协。","like_count":0},{"had_liked":false,"id":152064,"user_name":"cc","can_delete":false,"product_type":"c1","uid":1592092,"ip_address":"","ucode":"FF41E5D87BAD76","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/1c/5eb03a91.jpg","comment_is_top":false,"comment_ctime":1573868332,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573868332","product_id":100039001,"comment_content":"C++是支持多重继承的。虚继承。<br>也支持四大特性。","like_count":0},{"had_liked":false,"id":152010,"user_name":"Devin-Yang","can_delete":false,"product_type":"c1","uid":1120500,"ip_address":"","ucode":"68B9395BA71272","user_header":"https://static001.geekbang.org/account/avatar/00/11/18/f4/eb253192.jpg","comment_is_top":false,"comment_ctime":1573832795,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573832795","product_id":100039001,"comment_content":"java语言出于安全考虑只允许继承单一父类，同时也提供了实现多个接口和使用内部类的方式间接来实现多重继承","like_count":0},{"had_liked":false,"id":151976,"user_name":"Holmes","can_delete":false,"product_type":"c1","uid":1078589,"ip_address":"","ucode":"28DD6247AC3908","user_header":"https://static001.geekbang.org/account/avatar/00/10/75/3d/0d6cf519.jpg","comment_is_top":false,"comment_ctime":1573826266,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573826266","product_id":100039001,"comment_content":"Objective-C 不支持多重继承，原因不晓得","like_count":0},{"had_liked":false,"id":151842,"user_name":"wl","can_delete":false,"product_type":"c1","uid":1392730,"ip_address":"","ucode":"45062AA2460F1F","user_header":"https://static001.geekbang.org/account/avatar/00/15/40/5a/e65e8c40.jpg","comment_is_top":false,"comment_ctime":1573799407,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573799407","product_id":100039001,"comment_content":"1、你熟悉的编程语言是否支持多重继承？如果不支持，请说一下为什么不支持。如果支持，请说一下它是如何避免多重继承的副作用的。<br><br>JavaScript 可以通过 b extends a; c extends b; 的方式实现看起来是多重继承的继承。其实是JS 的语法糖，通过原型链的方式实现的，所以会按 c、b、a 的顺序查找属性和方法，不会发生冲突。<br><br>2、你熟悉的编程语言对于四大特性是否都有现成的语法支持？对于支持的特性，是通过什么语法机制实现的？对于不支持的特性，又是基于什么原因做的取舍？<br><br>封装：可以通过把属性和方法封装在函数内部去实现。<br>抽象：JS 没有接口类的概念，不过可以通过 TS 实现。<br>继承：可以通过 JS 的语法糖 extends Class ，并且在子类内部重写父类方法实现。<br>多态：项目中没有使用过多态的概念，但是按照老师讲的，JS 应该也是可以实现多态的，只要两个类有相同的行为，就可以通过 duck-typing 来实现多态。<br><br>也不知道理解的对不对，请老师指正，谢谢！","like_count":0},{"had_liked":false,"id":151789,"user_name":"DullBird","can_delete":false,"product_type":"c1","uid":1110494,"ip_address":"","ucode":"80E2FD5F9687CB","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/de/3ebcbb3f.jpg","comment_is_top":false,"comment_ctime":1573792575,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573792575","product_id":100039001,"comment_content":"1.我使用java，java语言不支持多继承。<br>不支持的原因想到一个是: 如果A实现一个方法叫void say(),B也实现一个方法void say()<br>那么C继承A，B的时候，调用C.say(),不知道是调用的A的say()还是B的say()<br>2.对于4大特性，java 都是支持的。<br>封装:通过访问修饰符<br>抽象:方法的命名，接口类，抽象类<br>继承:通过抽象类和接口类<br>多态:通过子类复写方法 + 继承实现","like_count":0},{"had_liked":false,"id":151766,"user_name":"Chaos浩","can_delete":false,"product_type":"c1","uid":1675943,"ip_address":"","ucode":"4FFAE6EEAA460B","user_header":"https://static001.geekbang.org/account/avatar/00/19/92/a7/00fefed5.jpg","comment_is_top":false,"comment_ctime":1573787380,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573787380","product_id":100039001,"comment_content":"比大学课本里讲的通俗易懂多了","like_count":0},{"had_liked":false,"id":151652,"user_name":"自来也","can_delete":false,"product_type":"c1","uid":1681814,"ip_address":"","ucode":"94CF8E5FF6DEC2","user_header":"https://static001.geekbang.org/account/avatar/00/19/a9/96/6d517a06.jpg","comment_is_top":false,"comment_ctime":1573775987,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573775987","product_id":100039001,"comment_content":"我认为Java设计非常好，拿猫来说，我认为封装应该从一开始的抽象类生命体开始，然后慢慢往下分支，抽象是描述的某一类事物，然而猫是爬着走，应该属于interface，这是他的一种行为，假设有一天猫进化了，还会飞，那我就在搞个会飞的接口，行为一直存在，当这类物体失去了这个特征不代表这个特征从此就消失了，例如人在生病他实现了感冒的接口，身体好了，就把接口移除，但是感冒仍然存在。","like_count":0},{"had_liked":false,"id":151593,"user_name":"jony","can_delete":false,"product_type":"c1","uid":1048286,"ip_address":"","ucode":"80765A6B9ABA0D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fe/de/2019f370.jpg","comment_is_top":false,"comment_ctime":1573746644,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573746644","product_id":100039001,"comment_content":"Java多重继承确实会有歧义问题，所以舍弃了多重继承，c++可以在调用具体方法时通过添加域操作符来避免歧义，对于菱形继承通过使用vitual虚继承避免歧义，具体参考https:&#47;&#47;blog.csdn.net&#47;u014489596&#47;article&#47;details&#47;38488927","like_count":0},{"had_liked":false,"id":151575,"user_name":"段启超","can_delete":false,"product_type":"c1","uid":1258209,"ip_address":"","ucode":"164CF3018071B2","user_header":"https://static001.geekbang.org/account/avatar/00/13/32/e1/c9aacb37.jpg","comment_is_top":false,"comment_ctime":1573741906,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573741906","product_id":100039001,"comment_content":"java报道:<br>JAVA 不支持多继承，因为java中的继承体现的是一种子类和父类的关系，如果两个父类有相同的方法，子类覆写父类的方法到底重写哪一个，不能确定。另一方面，我觉得JAVA的这种设计和更符合现实世界的继承关系，一个儿子不可能有多个亲爹。接口语法机制也让JAVA拥有灵活扩展的能力。<br>JAVA支持这四个特征。<br>抽象：JAVA可以通过抽象类和接口机制完成抽象，正如争哥说的，还有一种层次之美。<br>封装：JAVA中的public,private,protected，加强package，构造了完整的权限控制体系，实现对不同场景下的封装。<br>继承：extends,implements 实现对父类和接口的继承，实现。提现is-a,和can-do的设计原则，也是实现多态的途径。<br>多态:多态以继承和实现为基础,由JVM在运行期实现对对应子类方法的调用。这种机制为JAVA提供了扩展性。","like_count":0},{"had_liked":false,"id":151556,"user_name":"L🚲🐱","can_delete":false,"product_type":"c1","uid":1577856,"ip_address":"","ucode":"08A012739614DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","comment_is_top":false,"comment_ctime":1573739788,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573739788","product_id":100039001,"comment_content":"one. java 不支持多继承, 因为会产生歧义, 虽然 java 不支持多继承, 但是支持多实现, 可以实现多个接口, <br>two. 都支持 抽象用 abstract  继承 extend 多态 @Override 封装 访问控制符","like_count":0},{"had_liked":false,"id":151526,"user_name":"Geek_Spring","can_delete":false,"product_type":"c1","uid":1292572,"ip_address":"","ucode":"3F44EE152CB357","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erRavHNiaicxIIq5Pal1iadE4axG6ibbib6llpHBslhiahWDQ6tdE1IcWicFogfvuyfGoiayC51knA09UtQvQ/132","comment_is_top":false,"comment_ctime":1573736574,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573736574","product_id":100039001,"comment_content":"学习java的时候都知道不支持多继承，为啥呢，也是最近才知道具体原因，就是那个钻石问题，如果A同时继承B和C，而B和C同时有一个D方法，A如何决定该继承那一个呢？但是对于多继承这个字眼，在java中又是支持的，接口可以多继承，接口全都是抽象方法继承谁都无所谓，所以接口可以继承多个接口。类不能支持多继承就是为了避免这个歧异问题","like_count":0},{"had_liked":false,"id":151435,"user_name":"liy","can_delete":false,"product_type":"c1","uid":1322151,"ip_address":"","ucode":"ACE2C473DBA19F","user_header":"https://static001.geekbang.org/account/avatar/00/14/2c/a7/7f702c49.jpg","comment_is_top":false,"comment_ctime":1573719003,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1573719003","product_id":100039001,"comment_content":"好强，无法回答思考题，有点丢脸。。","like_count":0},{"had_liked":false,"id":151431,"user_name":"光光","can_delete":false,"product_type":"c1","uid":1242876,"ip_address":"","ucode":"A0F1D0134C935F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f6/fc/171c4976.jpg","comment_is_top":false,"comment_ctime":1573718275,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573718275","product_id":100039001,"comment_content":"对于多重继承和单重继承这就就拿C++和java来说吧。从两个语言的被发明的时间C++是80年代被发明然后陆续加入饿了面向对象的特性，至于C++采用多重继承多从实际面向对象的角度出发，就像老师再文中举得栗子（可能更符合人们思考问题的逻辑吧）；而java作为一个真真意义上的面向对象语言，从C++中学习吸收了不少，继承方面，选择了单继承，但允许接口多继承，这样很好的解决了DOD的问题，通过接口类来完成多重继承的功能，后来的C#也采用这种方法。","like_count":0},{"had_liked":false,"id":151427,"user_name":"曾经瘦过","can_delete":false,"product_type":"c1","uid":1240106,"ip_address":"","ucode":"57C32575A1C1FD","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/2a/b11d5ad8.jpg","comment_is_top":false,"comment_ctime":1573717708,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573717708","product_id":100039001,"comment_content":"java  不支持多继承 (接口有点多继承的意思)","like_count":0},{"had_liked":false,"id":151423,"user_name":"天野明","can_delete":false,"product_type":"c1","uid":1229765,"ip_address":"","ucode":"4522BA0AE29958","user_header":"https://static001.geekbang.org/account/avatar/00/12/c3/c5/61abf810.jpg","comment_is_top":false,"comment_ctime":1573716766,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573716766","product_id":100039001,"comment_content":"自从学go语言知道了duck-typing模式后，真心觉得c++的多态好鸡肋。。","like_count":0},{"had_liked":false,"id":151401,"user_name":"нáпの゛","can_delete":false,"product_type":"c1","uid":1130666,"ip_address":"","ucode":"834FA877EFBAF7","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/aa/49bbb007.jpg","comment_is_top":false,"comment_ctime":1573713489,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573713489","product_id":100039001,"comment_content":"四个特性被捋的明明白白。之前都没细思过单继承和多继承的区别，查了C++是通过基类名限定来避免二义性，不知道是否正确。<br>四个特性C++是现成语法支持的，通过什么机制实现触碰到知识盲点了，希望老师后面课里能讲到。","like_count":0},{"had_liked":false,"id":151398,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1573713286,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573713286","product_id":100039001,"comment_content":"你熟悉的编程语言对于四大特性是否都有现成的语法支持？对于支持的特性，是通过什么语法机制实现的？对于不支持的特性，又是基于什么原因做的取舍？<br>Java<br>封装： 访问权限的控制。（但是其反射，其实时破坏了这种机制）<br>继承： extends<br>抽象：接口，个人理解抽象类也是接口的另一种形式。<br>多态：个人理解 这个体现比较明显的地方就是 泛型。","like_count":0},{"had_liked":false,"id":151395,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1573713123,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573713123","product_id":100039001,"comment_content":"理解：<br>1，封装：屏蔽内部细节，使得外部调用时只需要关注public属性和方法。<br>2，抽象：体现为抽象类或者接口类。用于规范其实现类。假设，定义了抽象类“会叫的动物”，都有 叫 这个方法，这时候，如果有类继承了这个抽象类，但是没有 叫 这个方法那么就是不合理的。这个例子在多态会再用到。<br>3，继承：继承分为两种，一种是为了提取公共方法。另一种则是为了多态。<br>4，多态：“子类可以替换父类”，另一点“接口的多个实现也可以互相替换”。抽象时的例子：创建了一个List&lt;会叫的动物&gt; 这时候，有需求。需要十个会叫的动物，调用的地方，往List里添加了8个鹦鹉对象（鹦鹉实现了会叫的动物接口），但是鹦鹉不够了，然后又往里面添加了2个 青蛙（同样实现了会叫的动物接口），然后到了调用这个List的地方。遍历它们，然后调用它们的 叫 方法即可。具体是什么东西在叫，调用方并不需要关心。更不需要关心如何（内部实现） 叫，也就体现了封装。","like_count":0},{"had_liked":false,"id":151387,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1573711969,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1573711969","product_id":100039001,"comment_content":"第一次对封装、抽象、继承和多态有了点总结的想法，封装的出发角度是数据(访问控制)，抽象的出发角度是操作(方法和函数)，继承的出发角度是代码复用，而多态更多的是代码扩展。按我的理解，一份代码的实现从抽象(数据)，到具体实现(如何操作数据)，也就是编码(继承和多态)，这可能就是面向对象四大特性总结的过程吧。最后，个人超级不喜欢多继承，因为太容易乱了，更倾向于实现多个接口来实现多重复用，虽然现实世界中存在对象的多重复用，但多个复用对象之间应该有个主次之分，或者更精确地说在不同角度下看是这样的。那么单继承+接口基本就足够了，多继承带来的维护成本大多数情况下比优势更小。这和标准的UML适合写论文而不适合沟通是一个道理。","like_count":0},{"had_liked":false,"id":151373,"user_name":"铿然","can_delete":false,"product_type":"c1","uid":1162461,"ip_address":"","ucode":"D529242EC2E2EA","user_header":"https://static001.geekbang.org/account/avatar/00/11/bc/dd/c9413f59.jpg","comment_is_top":false,"comment_ctime":1573707939,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1573707939","product_id":100039001,"comment_content":"补充，面向接口编程不等同于抽象，面向接口编程为了接口稳定，可以🈶不同实现，抽象是为了把共性的部分抽离出来使用。","like_count":0},{"had_liked":false,"id":151351,"user_name":"沐夜星光","can_delete":false,"product_type":"c1","uid":1447220,"ip_address":"","ucode":"22F699E237B179","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLia2EwyyEVs3tWRnMlqaAG7R7HvlW4vGvxthKsicgsCEeXO1qL7mMy6GAzgdkSKcH3c70Qa2hY3JLw/132","comment_is_top":false,"comment_ctime":1573704332,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573704332","product_id":100039001,"comment_content":"封装中提到的increaseBalance和decreaseBalance，提醒了我封装不仅提供对隐私数据的保护，同时也通过方法实现了对操作权限的控制。按照我平时的开发习惯，为了图省事，可能只会定义一个setBalance。","like_count":0},{"had_liked":false,"id":151348,"user_name":"Leo","can_delete":false,"product_type":"c1","uid":1383148,"ip_address":"","ucode":"24401B70B6B40A","user_header":"https://static001.geekbang.org/account/avatar/00/15/1a/ec/4d272448.jpg","comment_is_top":false,"comment_ctime":1573703547,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573703547","product_id":100039001,"comment_content":"打卡,js基于原型,原型链实现继承功能","like_count":0},{"had_liked":false,"id":151324,"user_name":"anynew","can_delete":false,"product_type":"c1","uid":1235807,"ip_address":"","ucode":"F8308342828D4B","user_header":"https://static001.geekbang.org/account/avatar/00/12/db/5f/1ec96fb4.jpg","comment_is_top":false,"comment_ctime":1573699142,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573699142","product_id":100039001,"comment_content":"为什么Java不支持而c++支持","like_count":0},{"had_liked":false,"id":151311,"user_name":"bearlu","can_delete":false,"product_type":"c1","uid":1030862,"ip_address":"","ucode":"14F260C8B24E27","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/ce/fd45714f.jpg","comment_is_top":false,"comment_ctime":1573698168,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1573698168","product_id":100039001,"comment_content":"C++是多重继承，但是设计类的时候尽量使用单继承<br>C++通过private,protected,public进行封装特性<br>通过定义abstract关键字进行抽象<br>通过：进行继承<br>通过virtual和继承进行多态的实现","like_count":0},{"had_liked":false,"id":151304,"user_name":"colin","can_delete":false,"product_type":"c1","uid":1292206,"ip_address":"","ucode":"7A8849B8AE33E0","user_header":"https://static001.geekbang.org/account/avatar/00/13/b7/ae/a25fcb73.jpg","comment_is_top":false,"comment_ctime":1573697941,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573697941","product_id":100039001,"comment_content":"大量多继承场景，现在基本就只有c++能完成了","like_count":0},{"had_liked":false,"id":151298,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1573697425,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573697425","product_id":100039001,"comment_content":"c++：<br>1 支持多重继承。在多重继承情况下，子类转换为第一个父类不需要做额外的移位运算。但对于非第一个父类，需要进行偏移运算。另外，引入虚函数后，子类将同时包含多个虚表指针。至于多重继承的副作用，不是特别清楚，还望高人指点<br>2 c++完全支持面向对象的4种特性。<br>封装：支持public，protected，private三种权限级别<br>抽象：支持虚基类，即包含纯虚函数<br>继承：支持单继承，多继承，虚继承<br>多态：虚函数机制","like_count":0},{"had_liked":false,"id":151296,"user_name":"努力努力再努力m","can_delete":false,"product_type":"c1","uid":1644369,"ip_address":"","ucode":"9DD9E9C2988FFC","user_header":"https://static001.geekbang.org/account/avatar/00/19/17/51/3e13dc0c.jpg","comment_is_top":false,"comment_ctime":1573697313,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573697313","product_id":100039001,"comment_content":"看了这一讲后，才发现以前学的时候，只是简单的了解怎么用，并不懂它们的意义，又回头把java的这几个特性看了一遍，受益匪浅。","like_count":0},{"had_liked":false,"id":151285,"user_name":"饭粒","can_delete":false,"product_type":"c1","uid":1153455,"ip_address":"","ucode":"4C3220B0D43997","user_header":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","comment_is_top":false,"comment_ctime":1573695158,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573695158","product_id":100039001,"comment_content":"文章很棒。以前只是知道是什么，没去想这些特性的意义和解决的问题。","like_count":0},{"had_liked":false,"id":151276,"user_name":"Milittle","can_delete":false,"product_type":"c1","uid":1045455,"ip_address":"","ucode":"80E566639A8ABB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f3/cf/851dab01.jpg","comment_is_top":false,"comment_ctime":1573693601,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1573693601","product_id":100039001,"comment_content":"好多我都是看得懂 以前也有认知  说明我还是不错 能深入到这个层面  感谢争哥的专栏 让我学到很多 就是我还没达到可以汇总知识的地步 我还需要努力 同时交大研 向优秀的争哥继续学习~","like_count":0},{"had_liked":false,"id":151273,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1573693527,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1573693527","product_id":100039001,"comment_content":"C++支持多继承，但是会有菱形继承的问题，需要代码检查排除，封装，抽象，继承，多态都支持，通过类，虚函数，重载，重写来实现这四种特性","like_count":0},{"had_liked":false,"id":151270,"user_name":"Tom.G","can_delete":false,"product_type":"c1","uid":1206034,"ip_address":"","ucode":"7929B45C1A51F8","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/12/5c6eb568.jpg","comment_is_top":false,"comment_ctime":1573693315,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573693315","product_id":100039001,"comment_content":"1.看了其他同学的评论才知道，多继承会导致菱形问题<br>2.C#语言<br>2.1封装：public private sealed internal protected<br>2.2抽象：abstract interface<br>2.3继承：冒号<br>2.4多态：子类替换父类","like_count":0},{"had_liked":false,"id":151194,"user_name":"will","can_delete":false,"product_type":"c1","uid":1156207,"ip_address":"","ucode":"7A7DBE3E0EEAEB","user_header":"https://static001.geekbang.org/account/avatar/00/11/a4/6f/672a27d4.jpg","comment_is_top":false,"comment_ctime":1573664004,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573664004","product_id":100039001,"comment_content":"使用的java和kotlin，java不支持多继承，原因是会带来菱形问题，所谓的菱形问题会导致代码会产生歧义，导致不知道到底是继承了谁的方法，因此不支持多继承，可以有多个实现。<br>但是如果实现多个类中有同名的方法还是会产生歧义的问题，最好是避开此问题。<br>不知道理解的对不对","like_count":0},{"had_liked":false,"id":151167,"user_name":"Y024","can_delete":false,"product_type":"c1","uid":1018056,"ip_address":"","ucode":"397126D2E17997","user_header":"https://static001.geekbang.org/account/avatar/00/0f/88/c8/ae476935.jpg","comment_is_top":false,"comment_ctime":1573660025,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1573660025","product_id":100039001,"comment_content":"Day009 05<br>抽象是个神技，在遇到问题时不要只想着如何解决一个具体的问题，要在具体问题答案的基础上，提炼更普遍的方法，即把答案从具体问题中抽离出来，抽象成有效的策略，指导解决未来的类似问题。","like_count":0},{"had_liked":false,"id":151157,"user_name":"L🚲🐱","can_delete":false,"product_type":"c1","uid":1577856,"ip_address":"","ucode":"08A012739614DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","comment_is_top":false,"comment_ctime":1573658963,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573658963","product_id":100039001,"comment_content":"看完今天的文章后，发现我以前写的封装和一坨屎一样，希望学完这个专栏，代码水平有进步💪","like_count":0},{"had_liked":false,"id":151123,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1573655552,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573655552","product_id":100039001,"comment_content":"<br>以下内容基于Java语言<br>1.Java表面不支持多重继承（一个衍生类只能extends一个基类，但可以implements多个接口类）但实际上我认为是支持多重继承的，这一点在多态性上有所体现。<br><br>2.对于封装性，Java提供了语言层面的访问控制（private，protected，default，public）。<br>对于抽象性，Java提供了实例方法（instance method）与抽象方法（abstract method）以支持抽象性。<br>对于继承性，Java提供了extends关键字，藉此衍生类可以继承自基类。<br>对于多态性，Java支持向上转型及向下转型的方式实现灵活的动态绑定。","like_count":0},{"had_liked":false,"id":151106,"user_name":"大豆腐","can_delete":false,"product_type":"c1","uid":1244050,"ip_address":"","ucode":"1E8D4F938F9AEA","user_header":"https://static001.geekbang.org/account/avatar/00/12/fb/92/e3b0e597.jpg","comment_is_top":false,"comment_ctime":1573654187,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573654187","product_id":100039001,"comment_content":"看了一下专栏的加餐部分目录，非常期待。现在的我处于一种非常尴尬的地带，觉得自己的代码写的烂，但是不知道如何优化，工作中遇到的很多问题也不能得心应手。再加上最近入职一家新公司，项目是从别的公司买来的，已经运行了7年，里面的业务，同事也只是略知一二，搞得写一个接口都非常吃力，得花很长时间梳理相关的业务逻辑。","like_count":0},{"had_liked":false,"id":151102,"user_name":"佳民","can_delete":false,"product_type":"c1","uid":1000433,"ip_address":"","ucode":"A5626BAEC96945","user_header":"https://static001.geekbang.org/account/avatar/00/0f/43/f1/3c69eb09.jpg","comment_is_top":false,"comment_ctime":1573653922,"is_pvip":false,"replies":[{"id":"60033","content":"抽象从非常广义的角度来说，可以按照你的理解方式理解。不过，也可以按照我文章中写的面向对象的角度来理解。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1574854711,"ip_address":"","comment_id":151102,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573653922","product_id":100039001,"comment_content":"老师，我学习的面向对象特性中也是没有抽象，我理解的封装是数据保护和实现隐藏，也就是文中的封装和抽象；而我理解的抽象是指设计能力，比如对像泛化（设计父类）、类接口设计等等，这样的理解有偏差么？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474364,"discussion_content":"抽象从非常广义的角度来说，可以按照你的理解方式理解。不过，也可以按照我文章中写的面向对象的角度来理解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574854711,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151100,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1573653521,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1573653521","product_id":100039001,"comment_content":"面向对象的四大特性：<br>封装：数据隐藏，数据保护，对一些属性的操作进行限制<br>抽象：隐藏具体的实现细节，让使用者更加关注于怎么是调用，不需要关心内部的具体实现<br>继承：用来表示 is-a的关系，很好的代码得到复用，分为单继承和多继承<br>多态：子类可以替换父类具体的实现方式，提高代码扩展性","like_count":0},{"had_liked":false,"id":151098,"user_name":"xuanyuan","can_delete":false,"product_type":"c1","uid":1113737,"ip_address":"","ucode":"1EC79B9372868F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2icbib62icXtibTkThtyRksbuJLoTLMts7zook2S30MiaBtbz0f5JskwYicwqXkhpYfvCpuYkcvPTibEaQ/132","comment_is_top":false,"comment_ctime":1573653431,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573653431","product_id":100039001,"comment_content":"1、2的原因都可以归结为语言设计者对语言设计的理念不同<br>另外感觉抽象是另外一个层次的概念，这里描述的抽象可以用封装和多态来承载。或者说封装、继承、多态的最终目的都是抽象。","like_count":0},{"had_liked":false,"id":151091,"user_name":"柳树","can_delete":false,"product_type":"c1","uid":1025223,"ip_address":"","ucode":"F03249D4534BCB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a4/c7/d1ee69c6.jpg","comment_is_top":false,"comment_ctime":1573652612,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573652612","product_id":100039001,"comment_content":"面向对象这几个特性，「封装」和「抽象」感受至深。<br><br>作为一个业务后端，经常要向前端提供接口，前端通过你给的url来操作、查询数据，如何把接口名称、交互行为设计的抽象，又不晦涩难懂，让前端看了知道可以干啥，却又不需要暴露内部细节，把一个模块暴露出去的行为，可以让前端自己玩转起来，是业务后端的一项艺术。<br><br>而如果是中台后端，也同理，只是你提供接口的对象，也许变成了业务后端。","like_count":0},{"had_liked":false,"id":151089,"user_name":"美美","can_delete":false,"product_type":"c1","uid":1148422,"ip_address":"","ucode":"44CC95C45AF345","user_header":"https://static001.geekbang.org/account/avatar/00/11/86/06/72b01bb7.jpg","comment_is_top":false,"comment_ctime":1573652455,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573652455","product_id":100039001,"comment_content":"关于多继承的问题，我是这样理解的，假如支持多继承，两个父类的方法完全一样，那子类继承的是哪一个呢？这样会导致子类行为的不确定性，增加了语言的复杂性","like_count":0},{"had_liked":false,"id":151086,"user_name":"Warn","can_delete":false,"product_type":"c1","uid":1465310,"ip_address":"","ucode":"F2F7FCDB0940D0","user_header":"https://static001.geekbang.org/account/avatar/00/16/5b/de/152f1c2c.jpg","comment_is_top":false,"comment_ctime":1573652060,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573652060","product_id":100039001,"comment_content":"学习，有没有同学分享一下JavaScript，期待","like_count":0},{"had_liked":false,"id":151081,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1573651327,"is_pvip":true,"replies":[{"id":"58366","content":"可以自己上网搜下哈","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1573789566,"ip_address":"","comment_id":151081,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1573651327","product_id":100039001,"comment_content":"duck-typing是个什么概念？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474358,"discussion_content":"可以自己上网搜下哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573789566,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151073,"user_name":"Joanfen","can_delete":false,"product_type":"c1","uid":1004260,"ip_address":"","ucode":"4CF1B92337B625","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/e4/50600574.jpg","comment_is_top":false,"comment_ctime":1573650712,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573650712","product_id":100039001,"comment_content":"阅读者的短句听得有点累，一句话要分成 ABC&#47;DE&#47;FG这样的方式读，英文也是这样读，听那段代码传递的时候听得整个人都懵了","like_count":0},{"had_liked":false,"id":151058,"user_name":"连边","can_delete":false,"product_type":"c1","uid":1391748,"ip_address":"","ucode":"54B5DA38449728","user_header":"https://static001.geekbang.org/account/avatar/00/15/3c/84/608f679b.jpg","comment_is_top":false,"comment_ctime":1573648337,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573648337","product_id":100039001,"comment_content":"看着封装的那一段，我想起了我今天写的php接口，都是直接sql直接干的。","like_count":0},{"had_liked":false,"id":151036,"user_name":"越过大西洋","can_delete":false,"product_type":"c1","uid":1254936,"ip_address":"","ucode":"21FBC3BBCC23B4","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/18/ed6911b7.jpg","comment_is_top":false,"comment_ctime":1573646049,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573646049","product_id":100039001,"comment_content":"PHP 不支持多重继承, 因为多重继承增加了代码的复杂性与含糊性, 存在钻石问题","like_count":0},{"had_liked":false,"id":151032,"user_name":"夜空中最亮的星","can_delete":false,"product_type":"c1","uid":1267566,"ip_address":"","ucode":"ADC3E7B6789955","user_header":"https://static001.geekbang.org/account/avatar/00/13/57/6e/b6795c44.jpg","comment_is_top":false,"comment_ctime":1573645516,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573645516","product_id":100039001,"comment_content":"老师讲的很透彻","like_count":0},{"had_liked":false,"id":151003,"user_name":"Hector","can_delete":false,"product_type":"c1","uid":1496889,"ip_address":"","ucode":"110CAF87ADDC01","user_header":"https://static001.geekbang.org/account/avatar/00/16/d7/39/6698b6a9.jpg","comment_is_top":false,"comment_ctime":1573641353,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573641353","product_id":100039001,"comment_content":"甘若醴泉，代码进阶过程真的像指路明灯","like_count":0},{"had_liked":false,"id":150985,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1573638510,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573638510","product_id":100039001,"comment_content":"Java 不支持多重基础。继承本来就是一个很有争议的用法，多重基础副作用更大，容易造成多个副本的情况，所以Java放弃对多重基础的支持。","like_count":0},{"had_liked":false,"id":150984,"user_name":"冬冬呛","can_delete":false,"product_type":"c1","uid":1247583,"ip_address":"","ucode":"E0EFE04631E1EE","user_header":"https://static001.geekbang.org/account/avatar/00/13/09/5f/64d805c5.jpg","comment_is_top":false,"comment_ctime":1573638445,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573638445","product_id":100039001,"comment_content":"1. java 和 Python 都不支持多重继承的特性，主要还是一种 trade-off ，但分别还是通过接口和 mixin的方式实现了多重继承的功能，带来的复杂性降低了<br>2. Python <br>    1. 封装：通过语法的函数实现<br>    2. 继承：语法提供了支持<br>    3. 多态：语法提供的 duck-typing 实现","like_count":0},{"had_liked":false,"id":150969,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1573636560,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573636560","product_id":100039001,"comment_content":"对于被子类重写的（Override）的方法，javac会在子类的字节码文件中会生成一个桥接方法（留意字节码文件中出现的ACC_BRIDGE, ACC_SYNTHETIC标记的方法）。<br>具体解释请参考https:&#47;&#47;time.geekbang.org&#47;column&#47;article&#47;41800","like_count":0},{"had_liked":false,"id":150945,"user_name":"冬渐暖","can_delete":false,"product_type":"c1","uid":1586800,"ip_address":"","ucode":"907E41AAE9A36C","user_header":"https://static001.geekbang.org/account/avatar/00/18/36/70/00122b24.jpg","comment_is_top":false,"comment_ctime":1573633168,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1573633168","product_id":100039001,"comment_content":"为什么Java中不支持多重继承？<br>为什么Java不支持多重继承, 可以考虑以下两点:<br>1)第一个原因是围绕钻石形继承问题产生的歧义，<br>超父类、父类、子类如果有同一个方法，系统都不知道用哪个。<br>考虑一个类 A 有 foo() 方法, 然后 B 和 C 派生自 A, 并且有自己的 foo() 实现，现在 D 类使用多个继承派生自 B 和C，如果我们只引用 foo(), 编译器将无法决定它应该调用哪个 foo()。这也称为 Diamond 问题，因为这个继承方案的结构类似于菱形，见下图:<br><br>即使我们删除钻石的顶部 A 类并允许多重继承，我们也将看到这个问题含糊性的一面。如果你把这个理由告诉面试官，他会问为什么 C++ 可以支持多重继承而 Java不行。嗯，在这种情况下，我会试着向他解释我下面给出的第二个原因，它不是因为技术难度, 而是更多的可维护和更清晰的设计是驱动因素, 虽然这只能由 Java 言语设计师确认，我们只是推测。维基百科链接有一些很好的解释，说明在使用多重继承时，由于钻石问题，不同的语言地址问题是如何产生的。<br>2)对我来说第二个也是更有说服力的理由是，多重继承确实使设计复杂化并在转换、构造函数链接等过程中产生问题。假设你需要多重继承的情况并不多，简单起见，明智的决定是省略它。此外，Java 可以通过使用接口支持单继承来避免这种歧义。由于接口只有方法声明而且没有提供任何实现，因此只有一个特定方法的实现，因此不会有任何歧义。<br><br>Java不支持多继承其实主要就是在规范了代码实现的同时，也产生了一些局限性， 影响着程序设计结构。<br><br>当然，上面的是我之前在某个地方看到然后抄下来当笔记的 。<br>说实话，看这讲的时候，但凡有点java基础的，都会感觉看的很轻松的，尤其是这个钱包例子  哈哈<br><br>关于接口，没工作之前认为就是写个service什么的就可以，结果工作之后发现是controller。。。。<br>个人认为就是大点的代理模式。拿你说的图片存储来说吧，个人是把这些地址写到配置文件&#47;数据库字典表里。<br>","like_count":0,"discussions":[{"author":{"id":1016594,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/83/12/4ba82798.jpg","nickname":"我是智障","note":"","ucode":"ED9D959423E024","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49949,"discussion_content":"全是 copy 的吧，评论发表之前自己过一下子好嘛，图在哪里啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573652751,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1586800,"avatar":"https://static001.geekbang.org/account/avatar/00/18/36/70/00122b24.jpg","nickname":"冬渐暖","note":"","ucode":"907E41AAE9A36C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1016594,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/83/12/4ba82798.jpg","nickname":"我是智障","note":"","ucode":"ED9D959423E024","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50327,"discussion_content":"😭疏忽了 本来还准备去掉那些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573706299,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":49949,"ip_address":""},"score":50327,"extra":""}]}]},{"had_liked":false,"id":150938,"user_name":"qqq","can_delete":false,"product_type":"c1","uid":1006786,"ip_address":"","ucode":"91B0ACF8CBE7BD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/c2/8ffd2ad0.jpg","comment_is_top":false,"comment_ctime":1573631866,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1573631866","product_id":100039001,"comment_content":"# 面向对象四大特点<br><br>## 封装（Encapsulation）<br><br>### 解释：信息隐藏或者数据访问保护<br><br>### 实现方式：访问权限控制<br><br>### 解决问题：提高易用性、可维护性<br><br>## 抽象（Abstracttion）<br><br>### 解释：隐藏方法的具体实现<br><br>### 实现方式：接口类、抽象类、函数语法机制<br><br>### 解决问题：不必关心实现细节<br><br>### 类方法命名，不用关心实现逻辑：getAliyunPictureUrl =&gt; getPictureUrl<br><br>## 继承（Inheritance）<br><br>### 解释：代码复用、避免重复，符合认知<br><br>### 分类：单继承、多继承<br><br>### 问题：继承层次过多，可读性、可维护性变差。多用组合少用继承<br><br>## 多态（Polymorphism）<br><br>### 解释：子类替换父类<br><br>### 实现方式：<br><br>- 继承 + 方法重写<br>- 接口类<br>- duck-typeing: 定义同一个方法<br><br>### 解决问题：可扩展性、复用性<br><br>","like_count":0},{"had_liked":false,"id":150903,"user_name":"啦啦啦","can_delete":false,"product_type":"c1","uid":1131687,"ip_address":"","ucode":"6B12EC90A62525","user_header":"https://static001.geekbang.org/account/avatar/00/11/44/a7/171c1e86.jpg","comment_is_top":false,"comment_ctime":1573624895,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573624895","product_id":100039001,"comment_content":"interface testInter{<br>      function testEcho();<br>}<br><br>class test1{<br><br>      function testEcho(){<br>\t\t  <br>\t\t  return &#39;test1&#39;;<br>\t  }<br>}<br><br><br>class test2{<br>\t  function testEcho(){<br>\t\t  return &#39;test2&#39;;<br>\t  }<br>\t<br>}<br><br><br>class demo{<br>\tprivate function printTest($object){<br>\t\tvar_dump($object-&gt;testEcho());<br>\t}<br>\t<br>\tpublic function demoEcho(){<br>\t\t$test1 = new test1();<br>\t\t$this-&gt;printTest($test1);<br>\t\t<br>\t\t$test2 = new test2();<br>\t\t$this-&gt;printTest($test2);<br>\t\t<br>\t}\t<br>}<br><br>$demo = new demo();<br>$demo-&gt;demoEcho();<br><br>照着老师写的例子写了个php的阉割版的利用接口类实现的多态，哈哈哈","like_count":0},{"had_liked":false,"id":150902,"user_name":"不与三季人说","can_delete":false,"product_type":"c1","uid":1693164,"ip_address":"","ucode":"A3F03832309FDD","user_header":"https://static001.geekbang.org/account/avatar/00/19/d5/ec/3d6e7ea7.jpg","comment_is_top":false,"comment_ctime":1573624684,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573624684","product_id":100039001,"comment_content":"这几节课偏基础一些，都是很基本的概念，不过听老师说一遍还是又加深了一遍印象，java只能单继承，但是可以多实现，设计者这所以这样肯定是考虑了得失，避免一些问题，像二义性虽然会存在，但是多继承的语言也是可以通过其他的方式进行解决，所以单继承和多继承都有各自的取舍，不能说哪个好哪个不好，语言本身都是艺术，都是美。","like_count":0},{"had_liked":false,"id":150896,"user_name":"刘大明","can_delete":false,"product_type":"c1","uid":1035081,"ip_address":"","ucode":"83C063FBD9BF2B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cb/49/0b9ffc8e.jpg","comment_is_top":false,"comment_ctime":1573623543,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1573623543","product_id":100039001,"comment_content":"以前没有考虑过多继承会有菱形问题。这次受教了。","like_count":0,"discussions":[{"author":{"id":1045455,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f3/cf/851dab01.jpg","nickname":"Milittle","note":"","ucode":"80E566639A8ABB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50222,"discussion_content":"很经典的问题  加油 共勉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573693634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150887,"user_name":"WIZ","can_delete":false,"product_type":"c1","uid":1260348,"ip_address":"","ucode":"313AF84674475C","user_header":"https://static001.geekbang.org/account/avatar/00/13/3b/3c/2947127c.jpg","comment_is_top":false,"comment_ctime":1573621452,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573621452","product_id":100039001,"comment_content":"打卡<br>1。c#是不支持多继承的，因为多继承会让代码变得混乱，微软认为其优势抵不上其增加的复杂性，故舍弃<br>2。c#是有现成的语法机制支持4大特性的，在c#中一般说是三大，不包括抽象，封装除了手动实现，还可以直接用属性访问器来控制，继承，允许继承多个接口，但只能继承一个类，也是用:来标识；既然支持继承，那么相应的也支持多态，重写即是多态的一种体现，注意是重写而不是重载。简单点说，多态就是能够调用什么方法由变量类型决定，到底执行哪个方法由实际指向的对象决定。","like_count":0},{"had_liked":false,"id":150885,"user_name":"旺旺","can_delete":false,"product_type":"c1","uid":1159196,"ip_address":"","ucode":"FE2CF90F446BFB","user_header":"https://static001.geekbang.org/account/avatar/00/11/b0/1c/2e30eeb8.jpg","comment_is_top":false,"comment_ctime":1573620953,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573620953","product_id":100039001,"comment_content":"多重继续比较复杂，而且实际上人们在看到多重继承的时候也自己会被绕晕，不利于人们理解。<br>所以还是像Java那样，利用多个接口来实现比较清晰容易理解。","like_count":0},{"had_liked":false,"id":150862,"user_name":"靠人品去赢","can_delete":false,"product_type":"c1","uid":1301286,"ip_address":"","ucode":"7A20F9EBE847E1","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/26/54f2c164.jpg","comment_is_top":false,"comment_ctime":1573617740,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573617740","product_id":100039001,"comment_content":"这个封装结合业务讲得很好，钱包向外透露信息的控制，很有说服力。<br>关于多态，我看到很多书把接口的实现也算在多态里，到底算不算，其实可不可以看成特殊的继承。<br>还有就是子类代替父类，一些模式像工厂模式有自己的实现，很给力。","like_count":0},{"had_liked":false,"id":150846,"user_name":"do it","can_delete":false,"product_type":"c1","uid":1309911,"ip_address":"","ucode":"E0753912E8F2AF","user_header":"https://static001.geekbang.org/account/avatar/00/13/fc/d7/b102034a.jpg","comment_is_top":false,"comment_ctime":1573616343,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573616343","product_id":100039001,"comment_content":"C++支持多重继承，也带来了菱形继承问题，一般解决办法就是采用虚继承了","like_count":0},{"had_liked":false,"id":150844,"user_name":"丿淡忘","can_delete":false,"product_type":"c1","uid":1139645,"ip_address":"","ucode":"604AE01961A026","user_header":"https://static001.geekbang.org/account/avatar/00/11/63/bd/80f587ad.jpg","comment_is_top":false,"comment_ctime":1573616307,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1573616307","product_id":100039001,"comment_content":"用的c++，c++ 属于相信程序员的语言，认为程序员可以去做正确的事，支持多继承，对于钻石继承的问题，一般是采用虚继承的方式来解决，子类继承的两个父类，有同一个祖父类，使用虚继承后，子类只会创建一次两个父类具有的相同祖父类内容，从而解决钻石继承的问题，但一般情况还是别搞钻石继承","like_count":0},{"had_liked":false,"id":150843,"user_name":"shniu","can_delete":false,"product_type":"c1","uid":1019555,"ip_address":"","ucode":"E64CD8BED96D8D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/a3/d7e5fe8a.jpg","comment_is_top":false,"comment_ctime":1573616025,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573616025","product_id":100039001,"comment_content":"1. 用过Java，Java支持单继承、支持实现多个接口；多重继承带来很多副作用，比如二义性（菱形继承，用Python的时候有体会）、类型转换只能在运行时确定而不是编译阶段等，解决这些问题的麻烦大于他带来的好处；比如golang就没有直观的继承概念，而是使用duck-typing的机制。可以读一下这个 - <br> https:&#47;&#47;www.zhihu.com&#47;question&#47;31377101&#47;answer&#47;403757577。Python 支持多重继承，可以考虑使用Mixin机制来避免副作用，优先考虑通过多重继承来组合多个Mixin的功能，而不是设计多层次的复杂的继承关系；此外，python中出现二义性的解决方式是MRO算法，基本就是按照继承顺序来找真实要调用的方法。<br>2. Java是支持的，就不做分析了。Golang 显示的支持抽象、多态、封装，继承没有显示支持，go是一种Prototype-base的语言，对于抽象，go提供了函数、interface type、 struct type等；对于多态，go采用interface-type，然后使用 duck-typing来实现多态；对于封装，在 struct type 中可以声明成员变量和方法，小写字母开头的变量和方法是内部私有，外部无法访问，大写字母开头的变量和方法可以外部直接访问。","like_count":0},{"had_liked":false,"id":150841,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1573615816,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573615816","product_id":100039001,"comment_content":"第一遍 没理解到抽象和多态的区别 抽象主要是针对方法来说  多态则是针对类来说 如果该类实现了接口类或者抽象类的方法 并且继承自接口类和抽象类 那么就可以通过多态加上函数调用实现抽象 这也是为啥子 抽象 在很多地方没有被加入面向对象的特性的原因吧！所以很多时候都说面向对象的三大特性 封装 继承 多态","like_count":0},{"had_liked":false,"id":150834,"user_name":"pines","can_delete":false,"product_type":"c1","uid":1200708,"ip_address":"","ucode":"7B925605B36B4E","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/44/de7f2b98.jpg","comment_is_top":false,"comment_ctime":1573615063,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573615063","product_id":100039001,"comment_content":"Go语言中没有继承，只有组合，C++倒是支持多继承，不过会有菱形继承的问题，解决方案，就是加virtual关键字，虚继承","like_count":0},{"had_liked":false,"id":150831,"user_name":"柳志焕","can_delete":false,"product_type":"c1","uid":1235940,"ip_address":"","ucode":"42375930DC2AA0","user_header":"https://static001.geekbang.org/account/avatar/00/12/db/e4/a1b45d79.jpg","comment_is_top":false,"comment_ctime":1573614742,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573614742","product_id":100039001,"comment_content":"Java 不支持多继承，主要原因是多继承会让语言本身变得非常复杂（如同 C++），效率也会降低。事实上，接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性。","like_count":0},{"had_liked":false,"id":150829,"user_name":"Eden Ma","can_delete":false,"product_type":"c1","uid":1457408,"ip_address":"","ucode":"755312F0D154F9","user_header":"https://static001.geekbang.org/account/avatar/00/16/3d/00/7daa7403.jpg","comment_is_top":false,"comment_ctime":1573614121,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573614121","product_id":100039001,"comment_content":"OC 1、不支持多重继承，因为菱形继承问题。<br>2、支持四大特性，简单列举一些，封装可以通过类扩展和@private来控制属性访问权限，可以用协议作为抽象基类，多态系统类很多地方都有用到比如类簇NSNumber。","like_count":0},{"had_liked":false,"id":150826,"user_name":"塔兹米","can_delete":false,"product_type":"c1","uid":1425252,"ip_address":"","ucode":"1A58C81EF9B0A4","user_header":"https://static001.geekbang.org/account/avatar/00/15/bf/64/c9a0e913.jpg","comment_is_top":false,"comment_ctime":1573613982,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573613982","product_id":100039001,"comment_content":"打卡。<br>Java为什么不支持多继承。<br><br>1.因为子类继承了2个父类，父类都继承与一个祖父类的话，那就不能分辨他们重写的方法了。<br>2.关键字 super 代表父类对象，多个父类的话，那就不晓得到底代表谁了。","like_count":0},{"had_liked":false,"id":150814,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1573613015,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573613015","product_id":100039001,"comment_content":"不支持多继承的原因在于 如果层次过多 会导致类里面的成员或者方法很多 多则乱","like_count":0},{"had_liked":false,"id":150810,"user_name":"Gavin🦅","can_delete":false,"product_type":"c1","uid":1459226,"ip_address":"","ucode":"3E7F0211FB1EC5","user_header":"https://static001.geekbang.org/account/avatar/00/16/44/1a/792a9a89.jpg","comment_is_top":false,"comment_ctime":1573612722,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573612722","product_id":100039001,"comment_content":"在我看来关于OC的代理 Swift的协议都是基于多态特性的, 这种想法对么?","like_count":0},{"had_liked":false,"id":150805,"user_name":"Lifelong Learning","can_delete":false,"product_type":"c1","uid":1173517,"ip_address":"","ucode":"3E39BED3E13FB4","user_header":"https://static001.geekbang.org/account/avatar/00/11/e8/0d/fcd95db8.jpg","comment_is_top":false,"comment_ctime":1573612066,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573612066","product_id":100039001,"comment_content":"总结:<br>面对对象编程的四大特性---封装,抽象,继承,多态<br>1.封装<br>就是将一些属性,方法等包裹在一个类中,通过语言本身提供的机制对封装的内容进行不同作用域的访问,这样其实类似让使用者知道那些是可以访问,而让设计者可以不断的去迭代和更改那些私有的属性和方法.<br>2.抽象<br>语言中的基本功能---函数,其实就是提供了这个功能,java中通过interface class接口类和abstract class抽象类就是通过函数来实现的,使用者只要知道这个函数是做什么的,而不需要关心具体的实现细节(就是所谓的方法体)<br>3.继承<br>继承分为单继承和多继承两类,像java,php等就是单继承,而c++,python等就是多继承,多继承只要的弊病在子类继承多个父类后在访问相同的属性或者方法时就是不知道访问那个父类继承的属性和方法了,而继承在实际运用中也会产生多层继承,这样其实也造成程序的可读性和高耦合,父类中属性或者方法更改后会影响其他子类,所以建议不要使用多层继承<br>4.多态<br>所谓的多态就是一种行为有多种状态,既多种的表现形式,在java中主要有三种实现多态的方法---1.overload重载和override覆盖;2.利用interface接口类进行方法的override覆盖,每个实现接口的类都可以对方法进行具体的实现(java1.8以后接口类中可以有默认的方法实现,但是在实现接口的类也可以对其进行覆盖,这样也就避免了接口多继承带来的指向不明确的问题);3.通过抽象类进行方法的覆盖,在抽象类中的抽象的方法(用public abstract修饰的方法)必须在在子类中进行实现(除非子类也是抽象类),这样同样实现的多态","like_count":0},{"had_liked":false,"id":150798,"user_name":"青青子衿","can_delete":false,"product_type":"c1","uid":1438102,"ip_address":"","ucode":"4A388A3BA70C29","user_header":"https://static001.geekbang.org/account/avatar/00/15/f1/96/9571fa3d.jpg","comment_is_top":false,"comment_ctime":1573611124,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573611124","product_id":100039001,"comment_content":"讲得非常到位","like_count":0},{"had_liked":false,"id":150797,"user_name":"肥而不腻","can_delete":false,"product_type":"c1","uid":1435246,"ip_address":"","ucode":"3E6786A82A6DD6","user_header":"https://static001.geekbang.org/account/avatar/00/15/e6/6e/062da5e4.jpg","comment_is_top":false,"comment_ctime":1573611038,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573611038","product_id":100039001,"comment_content":"已学习今日份文档和评论！","like_count":0},{"had_liked":false,"id":150792,"user_name":"稳","can_delete":false,"product_type":"c1","uid":1284626,"ip_address":"","ucode":"BF5723E63E4115","user_header":"https://static001.geekbang.org/account/avatar/00/13/9a/12/06863960.jpg","comment_is_top":false,"comment_ctime":1573610833,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573610833","product_id":100039001,"comment_content":"凑凑热闹写写Python<br>1、支持多重继承。对于菱形继承问题，通过深度优先和广度优先来确定；<br>2、对于封装不支持，猜测是为了语法的简洁；抽象是通过ABC抽象类；继承和多态老师文章讲过，就不多说了","like_count":0},{"had_liked":false,"id":150790,"user_name":"yz","can_delete":false,"product_type":"c1","uid":1256001,"ip_address":"","ucode":"D646E3BDD795A2","user_header":"https://static001.geekbang.org/account/avatar/00/13/2a/41/6116db1b.jpg","comment_is_top":false,"comment_ctime":1573610750,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1573610750","product_id":100039001,"comment_content":"C#是支持多重继承的吧。","like_count":0,"discussions":[{"author":{"id":1011793,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/70/51/f1825adb.jpg","nickname":"Lugyedo","note":"","ucode":"EB5E456B638E70","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49801,"discussion_content":"和Java一样不支持多重继承","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573638959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150787,"user_name":"moqifei","can_delete":false,"product_type":"c1","uid":1358410,"ip_address":"","ucode":"E0A6C858B78A3A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLGovXf8jNP5ZqHsDKLwajjicbFwpX9on1xiaJDR4CgWaWP2KcfOdneasBfKFo3dO3dwQyGG6WjK40w/132","comment_is_top":false,"comment_ctime":1573610319,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573610319","product_id":100039001,"comment_content":"爬行类( Reptilia)由石炭纪末期的古代两栖类进化而来，心脏有两心房一心室，心室有不完全隔膜，体温不恒定，是真正适应陆栖生活的变温脊椎动物，并由此产生出恒温的鸟类和哺乳类。爬行类不仅在成体结构上进一步适应陆地生活，其繁殖也脱离了水的束缚，与鸟类、哺乳类共称为羊膜动物(amniota)。","like_count":0},{"had_liked":false,"id":150785,"user_name":"熊斌","can_delete":false,"product_type":"c1","uid":1026280,"ip_address":"","ucode":"24D0C32F397113","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a8/e8/bc84c47d.jpg","comment_is_top":false,"comment_ctime":1573610012,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1573610012","product_id":100039001,"comment_content":"我用的时Java语言，不支持通过extends关键字进行多重继承。留言区已经有同学解释了原因。<br><br>我有个疑问，Java语言的内部类是否是解决多重继承的一种方案？","like_count":0,"discussions":[{"author":{"id":1231549,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ca/bd/a51ae4b2.jpg","nickname":"吃饭饭","note":"","ucode":"95CFA07CDA2957","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49759,"discussion_content":"这个貌似在 Java 编程思想中提到过，是可以这么理解的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573631492,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150783,"user_name":"coder王","can_delete":false,"product_type":"c1","uid":1121990,"ip_address":"","ucode":"21465DC3850BCB","user_header":"https://static001.geekbang.org/account/avatar/00/11/1e/c6/6f817e6e.jpg","comment_is_top":false,"comment_ctime":1573609917,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573609917","product_id":100039001,"comment_content":"对于Java来说，虽然不支持多继承，但是可以通过组合方式来实现多继承的功能，主要是复用代码，文章都提到了😁","like_count":0},{"had_liked":false,"id":150781,"user_name":"KaitoShy","can_delete":false,"product_type":"c1","uid":1038415,"ip_address":"","ucode":"E2E2E9BD3F5048","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d8/4f/65abc6f0.jpg","comment_is_top":false,"comment_ctime":1573609899,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573609899","product_id":100039001,"comment_content":"1.  php 不支持多继承，可能是和C实现的机制有关，猜想的原因可能和棱形继承有关,有待研究一下php的源码；实现的方式是interface方式或者 trait<br>2. php 有现有语法支持。<br>像python，php 这种C-Like语言，由于 C 语言是在现有的语法层面是没有支持的，或者在设计C语言的时候OOP是不怎么流行。C 实现 OOP 的方式是用type struct。","like_count":0},{"had_liked":false,"id":150769,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1573608647,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573608647","product_id":100039001,"comment_content":"地铁打卡","like_count":0},{"had_liked":false,"id":150768,"user_name":"William","can_delete":false,"product_type":"c1","uid":1346215,"ip_address":"","ucode":"55F5D9DEE485B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","comment_is_top":false,"comment_ctime":1573608579,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1573608579","product_id":100039001,"comment_content":"面向对象特性： 封装、继承 、多态、抽象.<br><br>封装：封装属性，减少暴露不必要的属性，增加零散属性的管理.<br>继承： is-a关系，属于子类是具有父类的特征. <br>            子类可以调用父类的属性<br>多态：子类可以重写父类的方法. <br>           同一个类内部可以重载方法. <br>抽象：提取公共的方法，子类或者实现类重写. 各自按照自己的特性实现逻辑处理.","like_count":0},{"had_liked":false,"id":150760,"user_name":"小畅","can_delete":false,"product_type":"c1","uid":1322880,"ip_address":"","ucode":"D031CC07CD564E","user_header":"","comment_is_top":false,"comment_ctime":1573607679,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573607679","product_id":100039001,"comment_content":"看到留言，php估计考虑到易用性吧，不支持多继承，没有那么复杂，多继承会导致棱形问题，父类的属性和函数有二义性","like_count":0},{"had_liked":false,"id":150759,"user_name":"风行者","can_delete":false,"product_type":"c1","uid":1541934,"ip_address":"","ucode":"F058640CF77A35","user_header":"https://static001.geekbang.org/account/avatar/00/17/87/2e/ea54c240.jpg","comment_is_top":false,"comment_ctime":1573607514,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573607514","product_id":100039001,"comment_content":"1)封装，隐藏属性与方法，如操作系统仅公开系统调用，让被调用方的学习成本更低，另外也让维护者从代码角度了解更多的类的设计意图，如有哪些对象属性是创建时候初始化的，有哪些是外界行为产生的。<br>2）继承，父子代码复用，让整个代码结构更加清晰，但是太多层的继承跳转也让代码很难读。java的继承（extends)只能支持继承一个类，继承多个类会导致子类无法明确导致该引用哪个父类（拥有相同的方法签名和属性）的属性或方法","like_count":0},{"had_liked":false,"id":150753,"user_name":"啦啦啦","can_delete":false,"product_type":"c1","uid":1131687,"ip_address":"","ucode":"6B12EC90A62525","user_header":"https://static001.geekbang.org/account/avatar/00/11/44/a7/171c1e86.jpg","comment_is_top":false,"comment_ctime":1573607075,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573607075","product_id":100039001,"comment_content":"php不支持多继承，个人感觉就是因为多继承会带来的副作用多吧","like_count":0},{"had_liked":false,"id":150750,"user_name":"Geek_4e58c9","can_delete":false,"product_type":"c1","uid":1541413,"ip_address":"","ucode":"C1507B6BCCF4F0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/FpudwHOvLaFheC6EiboZsfEQGtvEWykGNTCC3AUM7L9sReWZ7TVicJ73uV1sZ3jbRibYj2NasLHAkLmn7p8FkW2Cg/132","comment_is_top":false,"comment_ctime":1573606902,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573606902","product_id":100039001,"comment_content":"不推荐继承的原因：父类的修改会影响到自己类的功能","like_count":0},{"had_liked":false,"id":150748,"user_name":"啦啦啦","can_delete":false,"product_type":"c1","uid":1131687,"ip_address":"","ucode":"6B12EC90A62525","user_header":"https://static001.geekbang.org/account/avatar/00/11/44/a7/171c1e86.jpg","comment_is_top":false,"comment_ctime":1573606865,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573606865","product_id":100039001,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":150740,"user_name":"yuerling","can_delete":false,"product_type":"c1","uid":1235297,"ip_address":"","ucode":"C9A20A4A9B7FA4","user_header":"https://static001.geekbang.org/account/avatar/00/12/d9/61/f7a59630.jpg","comment_is_top":false,"comment_ctime":1573606283,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573606283","product_id":100039001,"comment_content":"老师，当策略模式，策略过多膨胀时有什么好的方法可以优雅的解决嘛","like_count":0},{"had_liked":false,"id":150735,"user_name":"青青木","can_delete":false,"product_type":"c1","uid":1049870,"ip_address":"","ucode":"2732BA6FBC149D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJKILshrJiasJADt0FTdA9x9rJbSeM3t7BUgUxKqBpsZK4Uukg9qwmbOCmLia89VaqsPcKyauGBLRFw/132","comment_is_top":false,"comment_ctime":1573605904,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573605904","product_id":100039001,"comment_content":"Java接口我理解是一种行为约定，当一个类实现一个接口时就有了这个接口定义的行为，一个类是可以有多个行为的因此Java允许多接口继承，但是从单一接口原则考虑 类还是继承少量必要接口，不要搞成大杂烩。","like_count":0},{"had_liked":false,"id":150734,"user_name":"刘润森","can_delete":false,"product_type":"c1","uid":1236556,"ip_address":"","ucode":"84101C670A6747","user_header":"https://static001.geekbang.org/account/avatar/00/12/de/4c/a51ece16.jpg","comment_is_top":false,"comment_ctime":1573605791,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573605791","product_id":100039001,"comment_content":"python动态语言，没有访问的限制，也没有接口的定义，继承也可以多继承。","like_count":0},{"had_liked":false,"id":150731,"user_name":"轨迹","can_delete":false,"product_type":"c1","uid":1026737,"ip_address":"","ucode":"B212E2582B38CE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/aa/b1/52d2871f.jpg","comment_is_top":false,"comment_ctime":1573605475,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573605475","product_id":100039001,"comment_content":"我觉得封装还有其他优点，例如:组织代码。如，表示一个人的类，就有身高，体重，住址，爱好等等信息，封装成一个类，比直接定义零散的变量要好","like_count":0},{"had_liked":false,"id":150723,"user_name":"koo","can_delete":false,"product_type":"c1","uid":1149276,"ip_address":"","ucode":"D612E52B5D90BB","user_header":"https://static001.geekbang.org/account/avatar/00/11/89/5c/89f7bc6b.jpg","comment_is_top":false,"comment_ctime":1573604870,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1573604870","product_id":100039001,"comment_content":"地铁上学习专栏，干货已学习，代码今天抽时间实现揣摩揣摩。<br>OC既支持多继承，也支持多态。但也正是因为支持多继承导致自己在开发使用中基础类与各个子类之间各自特性随着迭代越来越臃肿。这边方面技能很薄弱有待提升，希望通过专栏能得到改善。👻👻👻","like_count":0,"discussions":[{"author":{"id":1456188,"avatar":"https://static001.geekbang.org/account/avatar/00/16/38/3c/77738aa4.jpg","nickname":"毫无根据的沉溺于美妙的幻想","note":"","ucode":"CE318147D99E3D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49543,"discussion_content":"OC 是Objective-C? 那它不支持多继承啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573611748,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150720,"user_name":"泰伦卢","can_delete":false,"product_type":"c1","uid":1141994,"ip_address":"","ucode":"FEA6B43C8D4FF9","user_header":"https://static001.geekbang.org/account/avatar/00/11/6c/ea/e03fec22.jpg","comment_is_top":false,"comment_ctime":1573604725,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1573604725","product_id":100039001,"comment_content":"C++支持多重继承，尽管支持，但感觉这个东西也算是个鸡肋，可以通过一层一层继承来实现相同的目的，反而导致可读性下降，个人学渣拙见","like_count":0},{"had_liked":false,"id":150715,"user_name":"陈迎春","can_delete":false,"product_type":"c1","uid":1443663,"ip_address":"","ucode":"2870BA6D6E5B1E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIang00R9vkklnkFCLhzRysNfocr0sLnCdoZwOT3UkulAPefk5BDvd0PfIeQSODSQg1DjKWUmJOaA/132","comment_is_top":false,"comment_ctime":1573604521,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573604521","product_id":100039001,"comment_content":"C++支持多重继承，但感觉最好还是不要使用多重继承，可读性会变差一些","like_count":0},{"had_liked":false,"id":150710,"user_name":"Fly55","can_delete":false,"product_type":"c1","uid":1251563,"ip_address":"","ucode":"FFA9D5C6EDD6F4","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/eb/fd0b4a1f.jpg","comment_is_top":false,"comment_ctime":1573604264,"is_pvip":false,"discussion_count":1,"race_medal":1,"score":"1573604264","product_id":100039001,"comment_content":"java不支持<br>1.若子类继承的父类中拥有相同的成员变量，子类在引用该变量时将无法判别使用哪个父类的成员变量。<br>2.若一个子类继承的多个父类拥有相同方法，同时子类并未覆盖该方法，那么调用该方法时将无法确定调用哪个父类的方法。","like_count":0,"discussions":[{"author":{"id":1239557,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ea/05/c0d8014d.jpg","nickname":"一道阳光","note":"","ucode":"F35207CCCEC6E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49498,"discussion_content":"对，我也想到了这点，但是为啥有些需要可以实现多重继承呢？百思不得其解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573606124,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150708,"user_name":"Cy23","can_delete":false,"product_type":"c1","uid":1591293,"ip_address":"","ucode":"8DC561C5151758","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/fd/895f0c27.jpg","comment_is_top":false,"comment_ctime":1573604172,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1573604172","product_id":100039001,"comment_content":"打卡，说实话，一直是隐约理解了，又隐约分不清。好尴尬啊，多少年了还是这样，我都怀疑人生了","like_count":0,"discussions":[{"author":{"id":1153978,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9b/ba/333b59e5.jpg","nickname":"Linuxer","note":"","ucode":"272D9D8089C3D6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49961,"discussion_content":"不是你是这样，我也如此","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573653478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150699,"user_name":"Miracle","can_delete":false,"product_type":"c1","uid":1373357,"ip_address":"","ucode":"C98378B19CDF1E","user_header":"https://static001.geekbang.org/account/avatar/00/14/f4/ad/33d67855.jpg","comment_is_top":false,"comment_ctime":1573603162,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1573603162","product_id":100039001,"comment_content":"go语言虽然没有继承概念，但是内嵌结构体其实也实现了继承的特性，内嵌多个结构体也可以看成多继承，这时候就会出现一个问题，如果潜入的多个结构体出现相同的字段，就会造成子结构体不清楚到底是继承谁的字段，所以就需要确保嵌入的结构体中不存在重名字段","like_count":0,"discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49493,"discussion_content":"Go只有接口，哈哈哈！进一步简化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573605791,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150690,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1573602312,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1573602312","product_id":100039001,"comment_content":"Java不支持多继承（multiple inheritance）。在多继承中，一个子类可以有多个父类，子类继承所有父类的公共属性和方法，例如C extends A, C extends B。<br><br>其他语言，如C++支持多继承。但在实际应用中，即使是有经验的C++工程师，也不建议使用多继承（特殊情况除外）。<br><br>Java为什么不使用多继承呢？<br>这是综合考虑语言复杂性和性能的折衷结果。<br><br>第一，复杂性。<br>因为这会使语言变的复杂（像C++）。例如 C 继承A和B，当A和B中都有一个方法f，当C调用方法f或者override方法f时，是指A的还是B的f？<br><br>Java使用接口实现多继承。像在Java的Arrays.sort()中，类如果想实现排序效果，就必须实现Comparable接口中的compareTo方法。但这也有缺点：接口只能有完全抽象的方法。问题是：使用某个接口时要实现所有抽象方法。那如果我不想实现接口中的所有方法呢？在Java中时做不到的。<br><br>第二，复杂性。<br>多继承运行中会实时查找继承的方法，编程语言实现这个机制时，不好编程语言的底层实现会影响语言的性能。<br><br>总结：Java中使用Interface实现多继承。一个类可以有一个父类，但可以实现多个接口。不同接口中的同名方法，使用接口名+点+方法名指代。<br>","like_count":0},{"had_liked":false,"id":150678,"user_name":"Aliliin","can_delete":false,"product_type":"c1","uid":1025239,"ip_address":"","ucode":"61F9A09BB6650F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a4/d7/5d2bfaa7.jpg","comment_is_top":false,"comment_ctime":1573599831,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573599831","product_id":100039001,"comment_content":"Php 不支持多重继承，至于为什么还真没思考过这个问题。","like_count":0},{"had_liked":false,"id":150674,"user_name":"redj","can_delete":false,"product_type":"c1","uid":1251309,"ip_address":"","ucode":"9BD7A1E0FEA881","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/ed/f79dd0f6.jpg","comment_is_top":false,"comment_ctime":1573582595,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573582595","product_id":100039001,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":150654,"user_name":"玄兴梦影","can_delete":false,"product_type":"c1","uid":1364855,"ip_address":"","ucode":"D9EDBBC61317E9","user_header":"https://static001.geekbang.org/account/avatar/00/14/d3/77/fb38ccf1.jpg","comment_is_top":false,"comment_ctime":1573575373,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573575373","product_id":100039001,"comment_content":"学习","like_count":0},{"had_liked":false,"id":151303,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1573697652,"is_pvip":false,"discussion_count":36,"race_medal":0,"score":"5400347588724","product_id":100039001,"comment_content":"争哥对面向对象的总结完美符合 What&#47;How&#47;Why 模型，我按照模型作下梳理。<br><br>## 封装<br>What：隐藏信息，保护数据访问。<br>How：暴露有限接口和属性，需要编程语言提供访问控制的语法。<br>Why：提高代码可维护性；降低接口复杂度，提高类的易用性。<br><br>##抽象<br>What: 隐藏具体实现，使用者只需关心功能，无需关心实现。<br>How: 通过接口类或者抽象类实现，特殊语法机制非必须。<br>Why: 提高代码的扩展性、维护性；降低复杂度，减少细节负担。<br><br>##继承<br>What: 表示 is-a 关系，分为单继承和多继承。<br>How: 需要编程语言提供特殊语法机制。例如 Java 的 “extends”，C++ 的 “:” 。<br>Why: 解决代码复用问题。<br><br>##多态<br>What: 子类替换父类，在运行时调用子类的实现。<br>How: 需要编程语言提供特殊的语法机制。比如继承、接口类、duck-typing。<br>Why: 提高代码扩展性和复用性。<br><br>3W 模型的关键在于 Why，没有 Why，其它两个就没有存在的意义。从四大特性可以看出，面向对象的终极目的只有一个：可维护性。易扩展、易复用，降低复杂度等等都属于可维护性的实现方式。<br>","like_count":1258,"discussions":[{"author":{"id":2558083,"avatar":"","nickname":"Geek_d131e9","note":"","ucode":"AB158FF9703F7F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367822,"discussion_content":"我也很想知道...老哥 你现在会了吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618476093,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150713,"user_name":"№修罗★幻影","can_delete":false,"product_type":"c1","uid":1010302,"ip_address":"","ucode":"FF89FB2C584833","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6a/7e/a6af4c00.jpg","comment_is_top":false,"comment_ctime":1573604430,"is_pvip":false,"discussion_count":24,"race_medal":0,"score":"2118992481358","product_id":100039001,"comment_content":"Java 不支持多重继承的原因<br>多重继承有副作用：钻石问题(菱形继承)。<br>假设类 B 和类 C 继承自类 A，且都重写了类 A 中的同一个方法，而类 D 同时继承了类 B 和类 C，那么此时类 D 会继承 B、C 的方法，那对于 B、C 重写的 A 中的方法，类 D 会继承哪一个呢？这里就会产生歧义。<br>考虑到这种二义性问题，Java 不支持多重继承。但是 Java 支持多接口实现，因为接口中的方法，是抽象的（从JDK1.8之后，接口中允许给出一些默认方法的实现，这里不考虑这个），就算一个类实现了多个接口，且这些接口中存在某个同名方法，但是我们在实现接口的时候，这个同名方法需要由我们这个实现类自己来实现，所以并不会出现二义性的问题。","like_count":493,"discussions":[{"author":{"id":1555182,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/ee/2a08e563.jpg","nickname":"MF","note":"","ucode":"1EF5C43CAD373A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56403,"discussion_content":"多继承接口类如果某个接口有默认方法，也需要重写默认方法，所以也不会造成二义性。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1574478189,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":98188,"discussion_content":"多个接口中方法就算返回值，参数，方法名一样，编译器只会让你实现一个，所以不会有歧义的问题","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1577149233,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2683430,"avatar":"https://static001.geekbang.org/account/avatar/00/28/f2/26/a8ac6b42.jpg","nickname":"听风有信","note":"","ucode":"2CCB467114FF5C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575196,"discussion_content":"返回值不一样的时候呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654662204,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":98188,"ip_address":""},"score":575196,"extra":""}]},{"author":{"id":1463023,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLbchZfeEnshPuUwEsQkn1XbWxjs3rRUpSRUxjW4q7rOcrPvXld0IxEZ1jlpEJdklFeEVERJoOfibg/132","nickname":"qf年间","note":"","ucode":"AA08AC984637EE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342180,"discussion_content":"有一种方法可以extends 超类 implements 接口","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1610607872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1676247,"avatar":"https://static001.geekbang.org/account/avatar/00/19/93/d7/93c8f92a.jpg","nickname":"斜杠ing...","note":"","ucode":"C4AE866AC8B9AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50800,"discussion_content":"学习到了，谢谢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573776213,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1244288,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fc/80/21d67b9b.jpg","nickname":"二狗","note":"","ucode":"91C38887F4F07B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49551,"discussion_content":"多继承同名方法重写不就好了  不客观","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573612472,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1010302,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/6a/7e/a6af4c00.jpg","nickname":"№修罗★幻影","note":"","ucode":"FF89FB2C584833","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1244288,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fc/80/21d67b9b.jpg","nickname":"二狗","note":"","ucode":"91C38887F4F07B","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":50021,"discussion_content":"如果不是声明为抽象方法，子类没有强制要求必须重写父类同名方法吧，那如果D没有对同名方法进行重写，那执行过程就会有问题了吧？当然你说的没错，子类重写了就OK(JDK8开始允许接口方法有默认实现，所以一旦出现这种钻石问题，编译器会强制实现类重写default 方法来消除二义性)","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1573656888,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":49551,"ip_address":""},"score":50021,"extra":""}]},{"author":{"id":2821728,"avatar":"","nickname":"600988292","note":"","ucode":"24BAE2B7A7B1E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558449,"discussion_content":"🐮","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648302999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1287406,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a4/ee/b960a322.jpg","nickname":"mihello","note":"","ucode":"4B1E7B7A141606","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553205,"discussion_content":"Python通过c3算法解决菱形问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645766161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1194060,"avatar":"https://static001.geekbang.org/account/avatar/00/12/38/4c/5426e2e0.jpg","nickname":"CJJ","note":"","ucode":"7E02A6A8547559","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347575,"discussion_content":"学到了谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612260241,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1152044,"avatar":"https://static001.geekbang.org/account/avatar/00/11/94/2c/19b0d10e.jpg","nickname":"鸵鸟","note":"","ucode":"D05C161DA4EF33","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297906,"discussion_content":"Java 8 的接口方法可以有默认的实现，这算不算多继承呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597109495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1010302,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/6a/7e/a6af4c00.jpg","nickname":"№修罗★幻影","note":"","ucode":"FF89FB2C584833","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1152044,"avatar":"https://static001.geekbang.org/account/avatar/00/11/94/2c/19b0d10e.jpg","nickname":"鸵鸟","note":"","ucode":"D05C161DA4EF33","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299707,"discussion_content":"多继承接口类如果某个接口有默认方法，编译器会要求你重写默认方法，所以也不会造成二义性","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1597793689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":297906,"ip_address":""},"score":299707,"extra":""},{"author":{"id":1030242,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/62/60937bbd.jpg","nickname":"逗你玩😄","note":"","ucode":"2E6309586B0363","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1152044,"avatar":"https://static001.geekbang.org/account/avatar/00/11/94/2c/19b0d10e.jpg","nickname":"鸵鸟","note":"","ucode":"D05C161DA4EF33","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":401437,"discussion_content":"不算，如果有实现类则用实现类的方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633669104,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":297906,"ip_address":""},"score":401437,"extra":""}]},{"author":{"id":1068193,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4c/a1/40b75a55.jpg","nickname":"LeoBing","note":"","ucode":"3964DA5DBFBE46","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295852,"discussion_content":"多接口情况下，同名方法实现一个就可以了吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596367289,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2092069,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKq0oQVibKcmYEy6MJ6GnLoXFMpicjLKT2AjO2h95UwZBcibAzkXibQrxhcpwN4JBIuEJ90UdiayI8kYjQ/132","nickname":"Geek_54624e","note":"","ucode":"A031A889D3C3FF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295333,"discussion_content":"高手啊，那一般支持多继承的语言是如何解决钻石问题的呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596166650,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1631921,"avatar":"","nickname":"jarryLee","note":"","ucode":"1392ED306DA5F2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2092069,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKq0oQVibKcmYEy6MJ6GnLoXFMpicjLKT2AjO2h95UwZBcibAzkXibQrxhcpwN4JBIuEJ90UdiayI8kYjQ/132","nickname":"Geek_54624e","note":"","ucode":"A031A889D3C3FF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341517,"discussion_content":"c++中是通过虚继承","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610444007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":295333,"ip_address":""},"score":341517,"extra":""}]},{"author":{"id":1394822,"avatar":"https://static001.geekbang.org/account/avatar/00/15/48/86/54c68afe.jpg","nickname":"铁男神sama","note":"","ucode":"0A3E3E61D36EDE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":63857,"discussion_content":"谢感谢分享","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574916925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134861,"avatar":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","nickname":"James","note":"","ucode":"48B0F2A334D1C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53439,"discussion_content":"学习了🐶🐶🐶","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574168861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1036972,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d2/ac/aeb9f156.jpg","nickname":"吖蒲","note":"","ucode":"397C5DA20D5693","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52398,"discussion_content":"学习了，谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574047273,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1210699,"avatar":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","nickname":"-W.LI-","note":"","ucode":"3556786538664F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50035,"discussion_content":"多继承感觉类加载都不好搞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573657905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1034977,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ca/e1/d8537537.jpg","nickname":"梁😜","note":"","ucode":"078473C50B802B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49784,"discussion_content":"学习了！ 还想问一下 C++ 是如何处理菱形继承的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573636699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1010302,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/6a/7e/a6af4c00.jpg","nickname":"№修罗★幻影","note":"","ucode":"FF89FB2C584833","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1034977,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ca/e1/d8537537.jpg","nickname":"梁😜","note":"","ucode":"078473C50B802B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50012,"discussion_content":"C++不是很了解，好像可以用虚继承的方式来规避？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573656513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":49784,"ip_address":""},"score":50012,"extra":""}]},{"author":{"id":1731625,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/6c/29/38ddc1ce.jpg","nickname":"雨季不再来","note":"","ucode":"74DBBB8E525067","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49550,"discussion_content":"学习了！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573612365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1346215,"avatar":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","nickname":"William","note":"","ucode":"55F5D9DEE485B1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49516,"discussion_content":"学习了，谢谢.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573608010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151160,"user_name":"拉格朗日的忧桑","can_delete":false,"product_type":"c1","uid":1312991,"ip_address":"","ucode":"5FCB2C6616E113","user_header":"https://static001.geekbang.org/account/avatar/00/14/08/df/4e5c2b29.jpg","comment_is_top":false,"comment_ctime":1573659334,"is_pvip":false,"replies":[{"id":"58189","content":"😄 多谢认可","user_name":"作者回复","comment_id":151160,"uid":"1190123","ip_address":"","utype":1,"ctime":1573690566,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"542739538630","product_id":100039001,"comment_content":"这是迄今讲面向对象特性最深刻的，没有之一","like_count":126,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474387,"discussion_content":"😄 多谢认可","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573690566,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1337016,"avatar":"https://static001.geekbang.org/account/avatar/00/14/66/b8/ece79234.jpg","nickname":"王智","note":"","ucode":"37D2AD591C1AEC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535091,"discussion_content":"我觉得也很好。读完豁然开朗，如饮美酒！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638349826,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150959,"user_name":"小学一年级","can_delete":false,"product_type":"c1","uid":1217230,"ip_address":"","ucode":"59B9805D7C2D92","user_header":"https://static001.geekbang.org/account/avatar/00/12/92/ce/9d24cb2c.jpg","comment_is_top":false,"comment_ctime":1573635038,"is_pvip":false,"discussion_count":22,"race_medal":0,"score":"362350887902","product_id":100039001,"comment_content":"我理解的四大特性<br>封装：加装备（添加盔甲）<br>继承：师傅掌对掌传输武功（毫无保留）<br>抽象：从道到术，柳叶能伤人<br>多态：奥特曼变身。","like_count":84},{"had_liked":false,"id":151249,"user_name":"猫切切切切切","can_delete":false,"product_type":"c1","uid":1075033,"ip_address":"","ucode":"F350BA1B7FFDC4","user_header":"https://static001.geekbang.org/account/avatar/00/10/67/59/017b5726.jpg","comment_is_top":false,"comment_ctime":1573691584,"is_pvip":true,"discussion_count":9,"race_medal":0,"score":"319401271488","product_id":100039001,"comment_content":"封装隐藏属性<br>抽象隐藏方法<br>继承支持复用<br>多态支持扩展","like_count":74,"discussions":[{"author":{"id":1258251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/33/0b/fd18c8ab.jpg","nickname":"大胖子呀、","note":"","ucode":"4BADF8096254BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":202339,"discussion_content":"争哥这个置顶操作就很骚了，hiahiahia","likes_number":13,"is_delete":false,"is_hidden":false,"ctime":1583898736,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1208393,"avatar":"https://static001.geekbang.org/account/avatar/00/12/70/49/d7690979.jpg","nickname":"tommyCmd","note":"","ucode":"4ADBB1FA44668D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260037,"discussion_content":"感觉终于单例模式知识点终于不用死记硬背了","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1588842579,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2277251,"avatar":"https://static001.geekbang.org/account/avatar/00/22/bf/83/c83be5a3.jpg","nickname":"eHackyd","note":"","ucode":"E6E7994FBDF0A5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568657,"discussion_content":"舔狗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1651194680,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2083243,"avatar":"","nickname":"Geek_9e4d78","note":"","ucode":"F4FFBC06B1ABA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294283,"discussion_content":"双重检查锁那里有个bug，单例引用应该用volatile修饰，否则在并发时，某个请求会去到一个没有实例化完的对象","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595848943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1497221,"avatar":"https://static001.geekbang.org/account/avatar/00/16/d8/85/f31e8841.jpg","nickname":"大魔王or","note":"","ucode":"2E3DFD4E90FF6B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2083243,"avatar":"","nickname":"Geek_9e4d78","note":"","ucode":"F4FFBC06B1ABA3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298947,"discussion_content":"老师讲了，高版本的JVM内部解决了这个问题，仔细看括号里的内容","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1597486927,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":294283,"ip_address":""},"score":298947,"extra":""},{"author":{"id":1955317,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/d5/f5/2ee8cf75.jpg","nickname":"王同学","note":"","ucode":"EAFCC3D47F6FFB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1497221,"avatar":"https://static001.geekbang.org/account/avatar/00/16/d8/85/f31e8841.jpg","nickname":"大魔王or","note":"","ucode":"2E3DFD4E90FF6B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324158,"discussion_content":"怎么解决的，有官方的依据吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605062735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":298947,"ip_address":""},"score":324158,"extra":""},{"author":{"id":2071327,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/9b/1f/9f3379d3.jpg","nickname":"Geek_7f21d2","note":"","ucode":"12204FDAD951BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1955317,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/d5/f5/2ee8cf75.jpg","nickname":"王同学","note":"","ucode":"EAFCC3D47F6FFB","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":325565,"discussion_content":"老师不是说了 new对象的时候保证初始化三步是原子性的就解决了 要考证的话下个源码自己撸","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605349983,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":324158,"ip_address":""},"score":325565,"extra":""}]},{"author":{"id":1173753,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo435IStLENgDxYPDykxxE9CP6Tye3xPQ584UeNqW21pU62ic6vibrGpNjKVbhulVehVG5IGvicSTaZg/132","nickname":"alex","note":"","ucode":"C7572007957F1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":208878,"discussion_content":"没有之一","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584586583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1138766,"avatar":"https://static001.geekbang.org/account/avatar/00/11/60/4e/1c654d86.jpg","nickname":"Omooo","note":"","ucode":"FFADFDC72EC847","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300239,"discussion_content":"真实！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597997397,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1097416,"avatar":"https://static001.geekbang.org/account/avatar/00/10/be/c8/7c5f324f.jpg","nickname":"港岛妹夫","note":"","ucode":"9F6AAA29B60D8F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294176,"discussion_content":"确实是, 而且几分钟看完, 解决了之前所有的困惑.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595819142,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1586908,"avatar":"https://static001.geekbang.org/account/avatar/00/18/36/dc/97369381.jpg","nickname":"张钟强","note":"","ucode":"EE0D5CAEDBBAC8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":226081,"discussion_content":"这操作，太骚了。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586419573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151518,"user_name":"丁丁历险记","can_delete":false,"product_type":"c1","uid":1661704,"ip_address":"","ucode":"A43829E454C067","user_header":"https://static001.geekbang.org/account/avatar/00/19/5b/08/b0b0db05.jpg","comment_is_top":false,"comment_ctime":1573734752,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"242091903328","product_id":100039001,"comment_content":"好久没复杂这些基础知识了，借今天写笔记的时间过足瘾。我就菜鸟一个，也深知言多必失，肯定有瞎扯的地方，还请指正，我好迭代。<br>1 封装 <br>常见编程语言通过 public protected privite  来支持<br>封装的意义 。<br>关掉直接操作数据的口子，让数据的修改更贴合真实业务。<br>例如：创建时间，就没有修改数据的场景。<br>钱包的钱数，只能通过增加，减少接口进行调整，不开放直接设置金额的接口（口子一开，对账就是个麻烦事）<br>另一个意义，调用类，没有必要知道太多的实施类的具体实现细节。让操作更为简单。<br>个人思考：<br>封装就是让代码遵守开闭原则的重要手段。<br>当调用类，关注过多实施类的继节时，一个需求的变化，可能引发多个依赖模块都发生了级联的改动，而一但调用类过度的知道了太多了实施类的细节（然后各种调用类代码再一散落），这时程序也相应地变得出各种毛病出来，既然这样，把实现的方法封装起来多好，让调用端少操点心。<br>Law of Demeter 有个别名，就叫最少知道原则，争哥说的第二个意义，感觉就是在描述遵守迪米特法则的好处.<br>再乱想一下， 人体，不就是最好的的封装么， 给你物料的入口（吃），出口（拉），还给你调节增强的接口（训练） 有多少人，并不知道其内部细节，不照样过着精彩的一生。 还有，调用类，总想知道更多被调用类的信息，以期更精准的控制，这种代码风格，就是完美主义病，而完美主义的并发症就是拖延症，以及极高的复杂度造成项目越写越混乱。<br>2 抽像。<br>抽像讲的是如何隐藏信息，而抽像讲的是隐藏方法的具体实现，让调用者只关心方法提供了哪些功能即可。<br>通常借 interface 和 abstract class 来实现 抽像这一特性。当implement 某接口时，只要知道接口干了啥，即可，无需要关心实施类的细节实现。<br>抽你的意义，能解决啥问题。<br>1 处理复杂性的有效手段。人脑承受信息有限，抽像做为不关注实现细节的套路，正好管用。<br>2抽像指导了很多的oo原则 ， 凡时对实现进行封装抽离的，都可以叫抽像，例如malloc()<br>3 定义类时，要有抽像思维，不要在方法中，暴露太多细节。（建议一层抽象层，让功能分解得更细，让意图和实现分享）<br>个人理解<br>（抽象处理的复杂度是人月神话里描述 的本质复杂度（Essential Complexity）， 也是尊重人脑的认知学的 ，大脑的特性是很烂的（ 抽像的工具包记重点，归纳特性，忽视细节），（推荐阅读google 整理术）<br>再瞎想一下，抽像是将很多的知道点给封装起来了(encoding 成为一个模型) ， 归纳法便是抽象的重要实现套路，也是支撑及发展文明的利器。 抽像在开发中的意义 ，是让具体的实施类，在合适的场所下编写 （最好满足sru）,然后通过合理的ood ,去调用或运行时create 具体的子类对象，去实现。 拜抽象所赐，一种各有分工，又能有序协同的场景就出来了<br>其三，个人套路包，我沟通时，当和建议相同方向时，就往抽像了说，当想有差异时，就很细节说。 （套路是双韧剑，就看你如何用了），我个人发现很多营销大的套路，抽像来看和传销是一至的，有些技术大牛的工作套路，和某著名贪官一模一样。（例如，把话说明白了再干，明确职责）<br>笔记下（下）<br>3继承<br>继续用来表示类之间是 is -a 关系。<br>猫是动物，于是就拥有的动物的自带属性行为。（移动速度，移动距离） 进一步的，动物属生物（于是） 有了生命的共有属性，年龄<br>有些语言单继续，有些多继承。<br>意义 和解决问题。<br>1 符合认知美感 。<br>2 减少重复coding .<br>问题: 重要隐患，父子类，大量方便藕合。<br>个人理解。<br>继续和不停的复杂粘贴代码是两个极度，复制代码虽散但各管各的，继续父一改，子跟着改，而复制代码这事，是问题是，实现一个细节后，其它的相联代码，都要不停的改。而继随相反，一改全刷了，除非你子类完全重写了，而一些不成熟的开发，前期的父类往往考虑不周，后期一折腾，悲剧从此开场。<br>再者 复制粘贴代码，两段代码关联太轻，基本上就是要一处一处的改，而复制这事，就关联得太重了。 一但重了，就往往产生大量的不必要的负担。 我学设计模式最开心的就是，基于原则，而不是基于规则，不同场景就用不同的套路。<br>基于职责太重这事，我是很反感用多重继续的。 需要啥，再组合一个类多好。 多关联一个类，死不了人的。 搞出菱形继随这种蛋疼的东西，又要不停的去关注细节，活着会很累的<br>4 多态。(个人觉得oo 中最有趣的一块)<br>多态指子类替代父类。<br>三种语法机制。（父可以）<br>实现多态，除继续外，还有利用接口类语法， duck-typing<br>个人理解：理解不深。有感觉描述不出来，就觉得，继续把事搞死了，多态就要死的东西搞活。 于是支持这种把事搞活的套路出来。","like_count":56,"discussions":[{"author":{"id":1201818,"avatar":"https://static001.geekbang.org/account/avatar/00/12/56/9a/4fd3ff1f.jpg","nickname":"hello world","note":"","ucode":"3A2CDCEAF51992","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72548,"discussion_content":"作者很赞，掌握了道和术，不仅仅学习技术，则将日常的感悟加以结合，学习本质，融会贯通","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1575503846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1267558,"avatar":"https://static001.geekbang.org/account/avatar/00/13/57/66/4a747704.jpg","nickname":"不忘初心","note":"","ucode":"FF0E30038CC71A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54747,"discussion_content":"很形象","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574312409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2058510,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/djjK4h3FfPGyllqd7Oc5TpCoJEU6TOcuiarLtAPGrROocibML1OgtUIgtxQDDsia3qqLfZkpCcDykl3l8WHNxzCag/132","nickname":"Geek_63aa00","note":"","ucode":"4AF5D3318F4468","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324047,"discussion_content":"有具体经验的理解更透彻，人码合一","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605044151,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1014534,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eq6LGLtCCNoIf8S09fxcvk1OrTicPibZgX3kf8aaowY5nD8mTicH9SZZ8SlxgJvppqPThK1cEibrlA7bw/132","nickname":"秦汉2022","note":"","ucode":"C99D56B44F79C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299958,"discussion_content":"谦虚了~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597888779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1283461,"avatar":"https://static001.geekbang.org/account/avatar/00/13/95/85/15cd21c2.jpg","nickname":"杨锋","note":"","ucode":"85A7828A538FB0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284855,"discussion_content":"羡慕","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592661991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152122,"user_name":"初心","can_delete":false,"product_type":"c1","uid":1104576,"ip_address":"","ucode":"C090A1723E3474","user_header":"https://static001.geekbang.org/account/avatar/00/10/da/c0/9fc31f2d.jpg","comment_is_top":false,"comment_ctime":1573885282,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"156192707938","product_id":100039001,"comment_content":"多态一句话，现在调用将来","like_count":36,"discussions":[{"author":{"id":1504671,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f5/9f/1509d389.jpg","nickname":"栾~龟虽寿！","note":"","ucode":"219B38C08979FE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":273055,"discussion_content":"继承就是无能的孩子找老爸去搞定事情，多态就是好儿子，自己撸起袖子加油干。","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1590402778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2431554,"avatar":"https://static001.geekbang.org/account/avatar/00/25/1a/42/85f36058.jpg","nickname":"orz","note":"","ucode":"7BA8D282A16DF3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1504671,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f5/9f/1509d389.jpg","nickname":"栾~龟虽寿！","note":"","ucode":"219B38C08979FE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546363,"discussion_content":"这个比喻棒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642305693,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":273055,"ip_address":""},"score":546363,"extra":""}]},{"author":{"id":1149143,"avatar":"https://static001.geekbang.org/account/avatar/00/11/88/d7/43cf7b60.jpg","nickname":"Cc°°","note":"","ucode":"6C88E8D2C4622D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577181,"discussion_content":"确定的是接口，不确定的是实现。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1655957135,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2028953,"avatar":"","nickname":"Geek3340","note":"","ucode":"C64D302CD53513","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333337,"discussion_content":"我晕了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607503698,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150979,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1573638061,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"117537755053","product_id":100039001,"comment_content":"猫不是爬行动物，:).","like_count":27,"discussions":[{"author":{"id":1298594,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/G2hKWVwthOFMChTia10NqpDn1ib6ibibtIHsEN8lbdApwrenOqmicAWBkCTb9zFeuPSXFrKpruwJqEhfZHk99scYS1Q/132","nickname":"李晟","note":"","ucode":"5E3F8A1CD8CC67","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":221845,"discussion_content":"华生你发现了盲点 :)","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586070726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1750549,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/b6/15/e2cfd10d.jpg","nickname":"ImYours°","note":"","ucode":"51F653129034C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350470,"discussion_content":"确实","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613888721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1104818,"avatar":"https://static001.geekbang.org/account/avatar/00/10/db/b2/29b4f22b.jpg","nickname":"JasonZ","note":"","ucode":"992193AE44C39C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294370,"discussion_content":"你说的对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595861581,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150833,"user_name":"划时代","can_delete":false,"product_type":"c1","uid":1061454,"ip_address":"","ucode":"9554CE2F83B77F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/2o1Izf2YyJSnnI0ErZ51pYRlnrmibqUTaia3tCU1PjMxuwyXSKOLUYiac2TQ5pd5gNGvS81fVqKWGvDsZLTM8zhWg/132","comment_is_top":false,"comment_ctime":1573615036,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"104652830140","product_id":100039001,"comment_content":"话题一：<br>C++语言的多重继承，存在三层继承关系时，采用virtual继承方式，形成菱形继承。标准库中的iostream类就存在多重继承关系，见图http:&#47;&#47;www.cplusplus.com&#47;img&#47;iostream.gif。<br>话题二：<br>C++语言的多态实现方式比较丰富，除了类中的virtual函数实现运行期多态以外。还支持编译期多态（模板元编程），不仅能够动态改变对象执行的函数，还能动态改变对象的定义类型。<br>","like_count":24},{"had_liked":false,"id":150808,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1573612521,"is_pvip":false,"discussion_count":1,"race_medal":1,"score":"100357860329","product_id":100039001,"comment_content":"专栏中有个思考题是 java 为何不支持类多继承？却支持接口的多继承？<br>而有些语言如python是支持多继承的？<br>首先java类支持多继承的话，两个父类有同名方法，在子类中调用的时候就不知道调用哪个了，出现决议(钻石问题或菱形问题)问题<br>而接口支持多继承因为接口定义的方法不能有方法体，所以不会出现决议问题。<br>而从jdk1.8开始，接口可以有默认方法(方法要用default标识)，必须要有方法体，这样在接口多继承上不也会有决议问题吗？其实你去试下就知道了，java发现这种情况，会通过让你强制在子接口中重写这个默认方法，这样就不会有决议问题了<br><br>python支持多继承因为它通过MRO解决的，pythoner应该懂，我是不太懂，感兴趣的可以去研究","like_count":23,"discussions":[{"author":{"id":1327497,"avatar":"https://static001.geekbang.org/account/avatar/00/14/41/89/77d3e613.jpg","nickname":"bookchan","note":"","ucode":"6C40EEAC767E25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":221369,"discussion_content":"mro是method resolution order，主要解决通过顺序查找约定规则，解决了同名方法的二义性问题。\n本地优先级：指声明时父类的顺序，比如C(A,B)，如果访问C类对象属性时，应该根据声明顺序，优先查找A类，然后再查找B类。\n单调性：如果在C的解析顺序中，A排在B的前面，那么在C的所有子类里，也必须满足这个顺序。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1586006191,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150791,"user_name":"小白","can_delete":false,"product_type":"c1","uid":1004755,"ip_address":"","ucode":"9BB9A170023CD8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/d3/46fd4aa3.jpg","comment_is_top":false,"comment_ctime":1573610810,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"96062891322","product_id":100039001,"comment_content":"go语言的“隐藏式接口”算是多态中duck-typing的实现方式吧","like_count":22,"discussions":[{"author":{"id":1004841,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/55/29/4fa6e9fb.jpg","nickname":"安静的雨","note":"","ucode":"6371DE858C4D3A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50708,"discussion_content":"不算吧 更像是隐式实现接口类","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1573745708,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1254656,"avatar":"https://static001.geekbang.org/account/avatar/00/13/25/00/3afbab43.jpg","nickname":"88591","note":"","ucode":"04CE3E46455185","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":185191,"discussion_content":"duck-typing 才是多态实现的根本","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1582601666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2806043,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLBFkSq1oiaEMRjtyyv4ZpCI0OuaSsqs04ODm0OkZF6QhsAh3SvqhxibS2n7PLAVZE3QRSn5Hic0DyXg/132","nickname":"ddh","note":"","ucode":"8E852375365F16","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541889,"discussion_content":"是隐式实现接口类","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1640595280,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1000008,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/48/030b108e.jpg","nickname":"Sophie","note":"","ucode":"BB4F4A32EF9B6D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52666,"discussion_content":"go 就是组合实现","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574077327,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1644194,"avatar":"https://static001.geekbang.org/account/avatar/00/19/16/a2/789d296e.jpg","nickname":"金旭","note":"","ucode":"2FE7B4B8CE4A07","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556426,"discussion_content":"golang中有个interface类型算是“接口类”，一个类需要实现接口类中定义的全部方法，那么该类的实例就可以赋值给接口类变量，接口类变量会调用相应类中的接口实现。好处是：有了类似动态类型语言ducktyping的书写简洁性（避免了声明），又可以实现编译期间的静态检查-满足了安全性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647354908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1644194,"avatar":"https://static001.geekbang.org/account/avatar/00/19/16/a2/789d296e.jpg","nickname":"金旭","note":"","ucode":"2FE7B4B8CE4A07","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556425,"discussion_content":"是隐式实现接口类","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647354646,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1298139,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ce/db/bb1821b3.jpg","nickname":"王      慈","note":"","ucode":"EACC3D086674D8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":155118,"discussion_content":"理解不算. Go还是强类型语言的...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580215980,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1295268,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/ibcRNslcyp7dwIR3TIwvloCibMd7Ew2TB3MU0wISFXEolyuHRtfIriagm6PMX5zQHicmc78BrBcxA6vQ5qnTPCev9A/132","nickname":"jiangjing","note":"","ucode":"D45001E5FB4D6F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":85376,"discussion_content":"好问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576543359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150868,"user_name":"weiguozhihui","can_delete":false,"product_type":"c1","uid":1052132,"ip_address":"","ucode":"D59087307CFC91","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/CibnyMEyuo4aKCjEzq3t8CRLbiatiaNCmSsTGlhdHaMseBibB2CK2Dyu4TSa7AVREseibicWUnSicp78kWP2gb66u7ajw/132","comment_is_top":false,"comment_ctime":1573618470,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"78883029798","product_id":100039001,"comment_content":"c 语言通过结构体来实现封装，只是c 的结构体没有关键字来控制结构体内部成员的访问权限问题，属于一种比较粗的封装。另外C中通过void*+结构体+函数指针也是可以实现多太的。Linux内核代码好多都是用了面向对象编程思想。C++中引入public protected private 关键字来进行访问控制权管理。C++中没有Java中的interface 关键字来描述接口类，但也是可以通过虚函数基类来进行的Java中的接口类的。C++是直接支持多继承的，但这个特性也被好多人诟病。","like_count":18,"discussions":[{"author":{"id":1242819,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f6/c3/926f2da9.jpg","nickname":"Paradise丶朽木","note":"","ucode":"4E4B8DCC216FAA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":196939,"discussion_content":"Using localRef, we are reducing the access of volatile variable to just one for positive usecase. If we do not use localRef, then we would have to access volatile variable twice - once for checking null and then at method return time. \nAccessing volatile memory is quite an expensive affair because it involves reaching out to main memory.\n参考链接：https://www.javacodemonk.com/threadsafe-singleton-design-pattern-java-806ad7e6","likes_number":123,"is_delete":false,"is_hidden":false,"ctime":1583386956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":14,"child_discussions":[{"author":{"id":1231549,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ca/bd/a51ae4b2.jpg","nickname":"吃饭饭","note":"","ucode":"95CFA07CDA2957","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1242819,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f6/c3/926f2da9.jpg","nickname":"Paradise丶朽木","note":"","ucode":"4E4B8DCC216FAA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295368,"discussion_content":"厉害啊，解决了一个困惑","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596176749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":196939,"ip_address":""},"score":295368,"extra":""},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1242819,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f6/c3/926f2da9.jpg","nickname":"Paradise丶朽木","note":"","ucode":"4E4B8DCC216FAA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296273,"discussion_content":"厉害了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596501166,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":196939,"ip_address":""},"score":296273,"extra":""},{"author":{"id":1131128,"avatar":"https://static001.geekbang.org/account/avatar/00/11/42/78/7ba89c75.jpg","nickname":"RedDevil","note":"","ucode":"F8F5DC209BB3B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1242819,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f6/c3/926f2da9.jpg","nickname":"Paradise丶朽木","note":"","ucode":"4E4B8DCC216FAA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312551,"discussion_content":"大神","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602731987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":196939,"ip_address":""},"score":312551,"extra":""}]},{"author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":161343,"discussion_content":"不是局部变量来接受静态变量，而是你这个静态变量有了 volatile 关键字，需要从主存同步，修改又要同步到主存，消耗了io，而局部变量和主存无关，只要最后一次同步到主存上去就好了","likes_number":56,"is_delete":false,"is_hidden":false,"ctime":1580891305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":163147,"discussion_content":"volatile 修饰不走寄存器内存，每次操作都是直接访问的内存，性能较差。","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1581053088,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":161343,"ip_address":""},"score":163147,"extra":""},{"author":{"id":1134288,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","nickname":"Ken张云忠","note":"","ucode":"D0BAC9FC17DE2B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":164144,"discussion_content":"虽然jvm是基于栈结构实现的,但是最终也是会经过转换调用到寄存器的.","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1581156366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":163147,"ip_address":""},"score":164144,"extra":""}]},{"author":{"id":1020390,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/91/e6/03582dee.jpg","nickname":"牧名","note":"","ucode":"193F0F33E1AB47","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":178981,"discussion_content":"因为volatile修饰的静态变量访问比较慢，如果不用局部变量则getInstance需要多次访问instance变量，使用局部变量可以有一定的性能提升。","likes_number":50,"is_delete":false,"is_hidden":false,"ctime":1582205564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1644104,"avatar":"https://static001.geekbang.org/account/avatar/00/19/16/48/09493874.jpg","nickname":"茶没喝完","note":"","ucode":"D72D88C42A1258","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020390,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/91/e6/03582dee.jpg","nickname":"牧名","note":"","ucode":"193F0F33E1AB47","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":241980,"discussion_content":"厉害","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587453695,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":178981,"ip_address":""},"score":241980,"extra":""},{"author":{"id":1138766,"avatar":"https://static001.geekbang.org/account/avatar/00/11/60/4e/1c654d86.jpg","nickname":"Omooo","note":"","ucode":"FFADFDC72EC847","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020390,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/91/e6/03582dee.jpg","nickname":"牧名","note":"","ucode":"193F0F33E1AB47","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300241,"discussion_content":"牛批","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597997758,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":178981,"ip_address":""},"score":300241,"extra":""},{"author":{"id":1691669,"avatar":"https://static001.geekbang.org/account/avatar/00/19/d0/15/5851180d.jpg","nickname":"一个无趣的俗人","note":"","ucode":"25435088B10CA2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020390,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/91/e6/03582dee.jpg","nickname":"牧名","note":"","ucode":"193F0F33E1AB47","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377272,"discussion_content":"牛逼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622566473,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":178981,"ip_address":""},"score":377272,"extra":""}]},{"author":{"id":1099216,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c5/d0/cf6bbe55.jpg","nickname":"CALL ME","note":"","ucode":"2A5BE26EAC9716","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301352,"discussion_content":"最后应该return temp吧","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1598499041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1143536,"avatar":"https://static001.geekbang.org/account/avatar/00/11/72/f0/abb7bfe3.jpg","nickname":"Mcnulty","note":"","ucode":"3DD71D84B58A16","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1099216,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c5/d0/cf6bbe55.jpg","nickname":"CALL ME","note":"","ucode":"2A5BE26EAC9716","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304295,"discussion_content":"对的，最后应该是return temp。这样在instance!=null时，传统双检锁会访问2次主存；现在利用局部变量只需要访问1次主存，性能更好。","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1599540490,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301352,"ip_address":""},"score":304295,"extra":""},{"author":{"id":2283490,"avatar":"https://static001.geekbang.org/account/avatar/00/22/d7/e2/5e5cc8f3.jpg","nickname":"Molyt","note":"","ucode":"9CCF7A18B2C547","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1099216,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c5/d0/cf6bbe55.jpg","nickname":"CALL ME","note":"","ucode":"2A5BE26EAC9716","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":405487,"discussion_content":"如果第一次为空，就走if里面的temp赋值后，再赋值给instance，第二次进来instance不为空，return instance应该没错吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634570325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301352,"ip_address":""},"score":405487,"extra":""}]},{"author":{"id":1134288,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","nickname":"Ken张云忠","note":"","ucode":"D0BAC9FC17DE2B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":163946,"discussion_content":"这是双重检测方式的优化写法，volatile带有读写屏障指令，可以有效防止指令重排序，确保数据最终可以刷入主存中。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1581130288,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2225926,"avatar":"","nickname":"Geek_eaff30","note":"","ucode":"751D26C18D13C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":356834,"discussion_content":"刚看到前面说的双重检测一直有个疑惑，先判断为null，然后再加锁，这时候如果是在高并发的情况下，是不是会有可能出现new了两个不同的实例，我觉得层主你发的这个就可以避免这种问题，在锁里面再去判断一次instance是否初始化","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1615687670,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1325816,"avatar":"https://static001.geekbang.org/account/avatar/00/14/3a/f8/c1a939e7.jpg","nickname":"君哥聊技术","note":"","ucode":"2C9A22BCE4C79E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":163166,"discussion_content":"\n争哥说的是不是类似这种的  \nAtomicReference<Singleton> INSTANCE = new AtomicReference<Singleton>()\npublic static Singleton getInstance() {\n        for (;;) {\n            Singleton singleton = INSTANCE.get();\n            if (null != singleton) {\n                return singleton;\n            }\n\n            singleton = new Singleton();\n            if (INSTANCE.compareAndSet(null, singleton)) {\n                return singleton;\n            }\n        }","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1581056730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1073027,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5f/83/bb728e53.jpg","nickname":"Douglas","note":"","ucode":"CFDE3D76B9DAE6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1325816,"avatar":"https://static001.geekbang.org/account/avatar/00/14/3a/f8/c1a939e7.jpg","nickname":"君哥聊技术","note":"","ucode":"2C9A22BCE4C79E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213825,"discussion_content":"这个方式会有多个实例被创建，比如第一次请求全都进来就直接new 了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1585125533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":163166,"ip_address":""},"score":213825,"extra":""},{"author":{"id":1644104,"avatar":"https://static001.geekbang.org/account/avatar/00/19/16/48/09493874.jpg","nickname":"茶没喝完","note":"","ucode":"D72D88C42A1258","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1073027,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5f/83/bb728e53.jpg","nickname":"Douglas","note":"","ucode":"CFDE3D76B9DAE6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":405997,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634690077,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":213825,"ip_address":""},"score":405997,"extra":""}]},{"author":{"id":1097836,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","nickname":"随心而至","note":"","ucode":"31866865255101","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350173,"discussion_content":"记住加volatile等同于从主存里面获取值，不是CPU寄存器。可以看看https://www.jianshu.com/p/aa6a9a7035a9","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1613733154,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2436755,"avatar":"https://static001.geekbang.org/account/avatar/00/25/2e/93/81e3e4ca.jpg","nickname":"ฅSlekฅ","note":"","ucode":"B732C672B3D301","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1097836,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","nickname":"随心而至","note":"","ucode":"31866865255101","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":409347,"discussion_content":"补充一下：多个线程在多核CPU上跑，每个CPU都包含自己独有的缓存（解决读写效率的问题）。volatile的目的就是让CPU缓存中的数据&#34;强行&#34;刷新到内存中，从而保证各个线程都能够看到数据的变化(即保证&#34;可见性&#34;)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635422846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":350173,"ip_address":""},"score":409347,"extra":""}]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296276,"discussion_content":"应该不是多次访问主存，每次都会赋值给临时变量的时候都要访问主存，应该是保证temp=new Singleton();再怎么重排序也不存在线程安全问题","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596501857,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2683430,"avatar":"https://static001.geekbang.org/account/avatar/00/28/f2/26/a8ac6b42.jpg","nickname":"听风有信","note":"","ucode":"2CCB467114FF5C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554998,"discussion_content":"为啥不会","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646714119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":296276,"ip_address":""},"score":554998,"extra":""}]},{"author":{"id":1924882,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/aXnFBB3XD3lwB3jf1A0PQqT66aJy4yycbRupJI3ia2CUFMuLsvYthM41TDopIIjL8kz7k2xE5vrAtQggQ6Jt8Zw/132","nickname":"付磊","note":"","ucode":"719BD0B72FF2AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583681,"discussion_content":"哦哦，我理解了，热评第一分享的链接中说的是对的，他所谓的不临时变量需要两次访问主存，指的是实例已经初始化好的情况。如果是未初始化，那么不用临时变量需要访问三次主存(两次判断一次返回)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660288803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1924882,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/aXnFBB3XD3lwB3jf1A0PQqT66aJy4yycbRupJI3ia2CUFMuLsvYthM41TDopIIjL8kz7k2xE5vrAtQggQ6Jt8Zw/132","nickname":"付磊","note":"","ucode":"719BD0B72FF2AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583677,"discussion_content":"用临时变量应该是可以减少访问主存数据的问题，但是我个人感觉上面说的包括第一热评分享的链接是不是都有问题,如果不用临时变量,两个判空+返回总共三次访问主存,如果用临时变量，那么判空不会访问主存，但是有两次赋值操作，不过返回的是临时变量，因此这里只需要访问2次主存，比不用临时变量要少一次才对。 不知道我说的对不对，反正上面好几个人说的都有冲突，大家伙颇有人云亦云的感觉,如果我理解有误欢迎大家指出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660288252,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2986618,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/92/7a/0c2317ab.jpg","nickname":"江湖骗子","note":"","ucode":"5BE77FD50E35AC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576412,"discussion_content":"AbstractQueuedSynchronizer中并没有使用单例模式吧?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655531941,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1261052,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3d/fc/f81d7847.jpg","nickname":"BATMAN","note":"","ucode":"414137A1074E62","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":355373,"discussion_content":"为什么使用volatile修饰变量，可以看下JMM内存模型这本书，JMM是在硬件架构上抽象出来的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615425557,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1515149,"avatar":"https://static001.geekbang.org/account/avatar/00/17/1e/8d/5b242931.jpg","nickname":"Fish","note":"","ucode":"C20719F8B0F7C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295469,"discussion_content":"在同步代码块內临时变量好像没减少对静态变量的读写次数 ，不明白好处在哪？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596201117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151636,"user_name":"zcdll","can_delete":false,"product_type":"c1","uid":1004086,"ip_address":"","ucode":"F1F20EB17D8789","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/36/18f5d218.jpg","comment_is_top":false,"comment_ctime":1573773309,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"70293250045","product_id":100039001,"comment_content":"1. 你熟悉的编程语言是否支持多重继承？如果不支持，请说一下为什么不支持。如果支持，请说一下它是如何避免多重继承的副作用的。<br>    1. JavaScript 不支持多继承，多继承理论上都存在“菱形问题”，也就是说如果 class D 继承了 class B 和 class C，class B 和 class C 都继承了 class A，class A 中有一个方法  add，B 和 C 都重写了 add 方法，当 D 去调用 add 方法时 就会出问题，不知道调用哪个方法了。<br>    2. 理论上是可以通过 Mixin 的方式来实现多继承。<br>    3. 通过一些 合并 算法来“部分”解决“菱形问题”<br>    4. 参考 JavaScript中的“多继承” [https:&#47;&#47;juejin.im&#47;entry&#47;5ac46b6c5188255570063b71](https:&#47;&#47;juejin.im&#47;entry&#47;5ac46b6c5188255570063b71)<br>2. 你熟悉的编程语言对于四大特性是否都有现成的语法支持？对于支持的特性，是通过什么语法机制实现的？对于不支持的特性，又是基于什么原因做的取舍？<br>    1. JavaScript 支持封装，抽象，继承，多态<br>    2. 封装 ES6的话，通过 public protected private 等关键字来实现，ES5 的话通过 “函数作用域”，this，原型链来实现，ES6 的 class 本质上也是 function 的语法糖。<br>    3. 抽象 可以通过 this指针 和 原型链 的形式来实现<br>    4. 继承 通过 原型链 来实现，或者说基于封装的特性来实现<br>    5. 多态 通过原型链 的方式，子类覆写父类的方法来实现","like_count":16,"discussions":[{"author":{"id":1115702,"avatar":"https://static001.geekbang.org/account/avatar/00/11/06/36/d288bcc7.jpg","nickname":"张诚","note":"","ucode":"F623703194769B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591058,"discussion_content":"分场景去看待问题，这个思考过程我需要学习","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666254270,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"湖北"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151545,"user_name":"大胖子","can_delete":false,"product_type":"c1","uid":1302384,"ip_address":"","ucode":"075A4936880074","user_header":"https://static001.geekbang.org/account/avatar/00/13/df/70/f3b8b8a2.jpg","comment_is_top":false,"comment_ctime":1573738554,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"65998247994","product_id":100039001,"comment_content":"这篇文章讲的真他娘的好啊","like_count":15,"discussions":[{"author":{"id":1958147,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/e1/03/f937e673.jpg","nickname":"🍀","note":"","ucode":"60E0AC2A55B63B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":226629,"discussion_content":"在读取日志写入位置之前要实现互斥","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586437822,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1958147,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/e1/03/f937e673.jpg","nickname":"🍀","note":"","ucode":"60E0AC2A55B63B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309282,"discussion_content":"多个Logger共享同一个Filewritter为什么能保证日志不会被覆盖呢，多个线程同时进入Logger中去写日志会出现被覆盖，你的意思是用静态私有filewritter对象作为synchronized锁吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601253158,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":226629,"ip_address":""},"score":309282,"extra":""},{"author":{"id":1167825,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d1/d1/62f74aa7.jpg","nickname":"自在飞","note":"","ucode":"A2712148DA06E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336384,"discussion_content":"这是从“多个logger对象公用一个FileWriter对象”来考虑的，而且FileWriter.write()在写数据时，其内部实现上已经通过synchronized加了锁做了同步操作","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1608561048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":309282,"ip_address":""},"score":336384,"extra":""}]}]},{"had_liked":false,"id":150673,"user_name":"秋惊蛰","can_delete":false,"product_type":"c1","uid":1620344,"ip_address":"","ucode":"3D9A6D5CA9C79F","user_header":"https://static001.geekbang.org/account/avatar/00/18/b9/78/a5804dae.jpg","comment_is_top":false,"comment_ctime":1573580667,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"65998090107","product_id":100039001,"comment_content":"试着说一下Python吧<br>- 抽象：抽象是编程语言的共有特点，甚至是计算机科学的特点，从变量，函数，类，模块，包等概念都是不同层次的抽象。抽象和把大象装进冰箱分三步是一个道理，它给出了思路，指明了方向，省略了细节。我们用层层抽象来应对计算机系统的复杂性。Python主要的抽象工具是函数和类，模块和包也算吧，毕竟也是隐藏了细节。<br>- 封装：Python不支持严格意义上的封装，没有private, protected等访问修饰符，这样做是为了保证动态语言最大的灵活性，同时Python里很多理念都是约定大于定义的，私有的属性需要大家守约，不要去随意访问，这也是Python被吐槽的地方吧，大型项目约束力不够。<br>- 继承：Python支持多重继承，主要是因为它没有类似于Java的“接口类”的语法吧，用多重继承可以定义一些纯功能性的类，减少类的层级。<br>- 多态：Python的多态就是鸭子类型了，鸭子类型的背后是所谓“协议”，协议是非正式的接口，是一种特性，表现为一个或多个相关的方法，比如迭代器协议，序列协议。实现了迭代器协议就和Java中实现了Iterator接口一样。","like_count":15,"discussions":[{"author":{"id":2222614,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/1fXYkS0UlZUQQtzUpG2TZzVhVZHarfpWT5wjO7iajw959zysQks1vLFM2uQsKnYG3uQAhzenH9LP86goiciaCDNibQ/132","nickname":"Xingyi_Xie","note":"","ucode":"D1849DB8BFB1B2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":406414,"discussion_content":"手动点赞~~当然，Python中也可以通过“继承加方法重写”实现多态，虽然没有override关键词。直接在子类中定义，与父类中同名的方法，就实现了“子类替换父类”的多态。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634746915,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150817,"user_name":"Bug? Feature!","can_delete":false,"product_type":"c1","uid":1164531,"ip_address":"","ucode":"F8FA8A0094FBA0","user_header":"https://static001.geekbang.org/account/avatar/00/11/c4/f3/92f654f1.jpg","comment_is_top":false,"comment_ctime":1573613277,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"40228318941","product_id":100039001,"comment_content":"我们使用Java已经很长时间了，我们有多少次因为缺少多重继承而面临困难呢？<br>我个人的经验是一次都没有。因为多重继承很少有机会被用到，所以更安全的做法是去掉它而保持简单性。<br>就算是碰到需要多重继承的情景，我们也可以找到替代方法。<br>我的观点是，去掉对多重继承的支持不是Java的缺陷，对开发者来说是件好事。","like_count":9,"discussions":[{"author":{"id":1292206,"avatar":"https://static001.geekbang.org/account/avatar/00/13/b7/ae/a25fcb73.jpg","nickname":"colin","note":"","ucode":"7A8849B8AE33E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50264,"discussion_content":"是因为java没有多继承，所以java基本不做多继承相关的事。前后因果不能反","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1573697859,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1079425,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/81/f6229358.jpg","nickname":"fresh meat","note":"","ucode":"6AC5A69F80ECE7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49970,"discussion_content":"同意","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573653691,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150696,"user_name":"路遥","can_delete":false,"product_type":"c1","uid":1135025,"ip_address":"","ucode":"2BB52B8CA82829","user_header":"https://static001.geekbang.org/account/avatar/00/11/51/b1/4eab324e.jpg","comment_is_top":false,"comment_ctime":1573603117,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"40228308781","product_id":100039001,"comment_content":"多继承会带来菱形继承的问题。例如一个类的两个父类，都继承了同一个祖父类，两个父类都 override 了祖父类的方法，这时候孙子类就不知道如何调用了。<br><br>Java 8 的 interface 可以有方法默认实现，这应该可以算是曲线救国的多继承吧。","like_count":9,"discussions":[{"author":{"id":1471657,"avatar":"https://static001.geekbang.org/account/avatar/00/16/74/a9/5eb3ebc6.jpg","nickname":"唐龙","note":"","ucode":"87A10AE04F2037","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580892,"discussion_content":"在C++中。\n类A有一个纯虚函数func，BC两个子类分别有自己的实现，并且BC共同派生出一个孙子类D。\n在D类中可以通过B::func()或C::func()显式指明要调用哪一个父类的实现。\n你说的这个问题不算啥大问题，但是还需要注意其他细节，B或C从A继承过来时需要有一个采用虚继承的方式，但是两者都采用虚继承也不行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658395314,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236365,"user_name":"微末凡尘","can_delete":false,"product_type":"c1","uid":1099525,"ip_address":"","ucode":"25EDFD0914D0F4","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/05/19c5c255.jpg","comment_is_top":false,"comment_ctime":1595400244,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35955138612","product_id":100039001,"comment_content":"争哥对面向对象的总结完美符合 What&#47;How&#47;Why 模型，我按照模型作下梳理。<br><br>## 封装<br>What：隐藏信息，保护数据访问。<br>How：暴露有限接口和属性，需要编程语言提供访问控制的语法。<br>Why：提高代码可维护性；降低接口复杂度，提高类的易用性。<br><br>##抽象<br>What: 隐藏具体实现，使用者只需关心功能，无需关心实现。<br>How: 通过接口类或者抽象类实现，特殊语法机制非必须。<br>Why: 提高代码的扩展性、维护性；降低复杂度，减少细节负担。<br><br>##继承<br>What: 表示 is-a 关系，分为单继承和多继承。<br>How: 需要编程语言提供特殊语法机制。例如 Java 的 “extends”，C++ 的 “:” 。<br>Why: 解决代码复用问题。<br><br>##多态<br>What: 子类替换父类，在运行时调用子类的实现。<br>How: 需要编程语言提供特殊的语法机制。比如继承、接口类、duck-typing。<br>Why: 提高代码扩展性和复用性。<br><br>3W 模型的关键在于 Why，没有 Why，其它两个就没有存在的意义。从四大特性可以看出，面向对象的终极目的只有一个：可维护性。易扩展、易复用，降低复杂度等等都属于可维护性的实现方式。","like_count":8},{"had_liked":false,"id":151055,"user_name":"晨风破晓","can_delete":false,"product_type":"c1","uid":1321464,"ip_address":"","ucode":"F2BC46428A97B5","user_header":"https://static001.geekbang.org/account/avatar/00/14/29/f8/561c5be1.jpg","comment_is_top":false,"comment_ctime":1573647967,"is_pvip":false,"discussion_count":9,"race_medal":0,"score":"35933386335","product_id":100039001,"comment_content":"PHP不支持多继承，具体为什么还没了解过，四大特性都是有现有语法支持的；看完这堂课，貌似对多态还不是很理解","like_count":8,"discussions":[{"author":{"id":2297573,"avatar":"https://static001.geekbang.org/account/avatar/00/23/0e/e5/b7b42a13.jpg","nickname":"一天两天","note":"","ucode":"DB9D4C42F033DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325066,"discussion_content":"PHP没有多继承，使用trait组合，或者implements继承多个接口来实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605230895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1359669,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/35/0e3a92a7.jpg","nickname":"晴天了","note":"","ucode":"5310E02F8DF1F0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":313885,"discussion_content":"多态: 一种事物多种状态 .  每个实现类都依赖接口抽象 . 客户端类同样依赖抽象 . ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603102252,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1131091,"avatar":"https://static001.geekbang.org/account/avatar/00/11/42/53/d2ef5b62.jpg","nickname":"Lin","note":"","ucode":"C6C115A77CA1FD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":135727,"discussion_content":"不知道理解是否准确，比如说PHP内依赖注入时，参数类型可以是接口类，而非实际实现类，是多态的实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579099812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1514953,"avatar":"https://static001.geekbang.org/account/avatar/00/17/1d/c9/c22f4e4b.jpg","nickname":"杜美洁","note":"","ucode":"78354D0430C9DF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":114631,"discussion_content":"php貌似没有支持多态的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577975475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1625837,"avatar":"https://static001.geekbang.org/account/avatar/00/18/ce/ed/5abd527e.jpg","nickname":"骄之","note":"","ucode":"C1B72B963E370C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51747,"discussion_content":"PHP 通过 Trait 来解决多继承的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573920078,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1000008,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/48/030b108e.jpg","nickname":"Sophie","note":"","ucode":"BB4F4A32EF9B6D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1625837,"avatar":"https://static001.geekbang.org/account/avatar/00/18/ce/ed/5abd527e.jpg","nickname":"骄之","note":"","ucode":"C1B72B963E370C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52670,"discussion_content":"trait 是通过组合是解决的多继承问题","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574077378,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":51747,"ip_address":""},"score":52670,"extra":""},{"author":{"id":1211359,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7b/df/876dd9cc.jpg","nickname":"kings","note":"","ucode":"D478306EBF582E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1000008,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/48/030b108e.jpg","nickname":"Sophie","note":"","ucode":"BB4F4A32EF9B6D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55271,"discussion_content":"用PHP5得伤不起","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574348384,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":52670,"ip_address":""},"score":55271,"extra":""}]},{"author":{"id":1571892,"avatar":"https://static001.geekbang.org/account/avatar/00/17/fc/34/ec2f140f.jpg","nickname":"🌟","note":"","ucode":"B548DB42023BD8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50810,"discussion_content":"同感","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573776818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1737984,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIdCoCuWIfSdicDQY13qhGVUs4tgXt3iaqhUibjFQX2iaHTM8qA53hatv209EfqeK1pNknmrHajibP9Lkw/132","nickname":"Sherrygauss","note":"","ucode":"23BF8818AFA1E4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50248,"discussion_content":"我也是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573696555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":210206,"user_name":"Roc","can_delete":false,"product_type":"c1","uid":1802610,"ip_address":"","ucode":"0D71BD87E3DD54","user_header":"https://static001.geekbang.org/account/avatar/00/1b/81/72/e6dbf6f3.jpg","comment_is_top":false,"comment_ctime":1587697475,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27357501251","product_id":100039001,"comment_content":"python是支持多继承的，对于多继承的二义性问题，有一套MRO(Method Resolution Order)机制来解决，简单说就是排序。目前是采用C3算法，对继承关系建树后，使用拓扑排序得到序列；在python2.2之前也有用DFS去获取继承序列，但DFS会出现继承不到子类对于父类的重写，而后更新为C3算法，解决了本地优先级及单调性的问题。<br>详见贴：<br>https:&#47;&#47;blog.csdn.net&#47;qq_38923792&#47;article&#47;details&#47;94414944<br>https:&#47;&#47;www.mscto.com&#47;python&#47;183897.html<br>https:&#47;&#47;blog.csdn.net&#47;qwertyupoiuytr&#47;article&#47;details&#47;56439134","like_count":6,"discussions":[{"author":{"id":1113744,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fe/90/19ef108d.jpg","nickname":"techwro","note":"","ucode":"7AF2B319F0AE1B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301505,"discussion_content":"要做到争哥说的“把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序”这一点，搜了一圈只有这个说法靠谱：\nIn short, we emit a trailing barrier in three cases: ... 3. A field write was detected, and -XX:+UnlockExperimentalVMOptions -XX:+AlwaysSafeConstructors was requested.\n而AlwaysSafeConstructors这个vm-option是jdk9才有的experimental选项。\nref: \nhttps://shipilev.net/blog/2014/safe-public-construction/ \nhttps://chriswhocodes.com/vm-options-explorer.html","likes_number":18,"is_delete":false,"is_hidden":false,"ctime":1598541777,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1263009,"avatar":"https://static001.geekbang.org/account/avatar/00/13/45/a1/d97c3e23.jpg","nickname":"莺歌蕾西","note":"","ucode":"445AE78CF5C86B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311718,"discussion_content":"这个地方讲错了吧，这种写法存在的问题是，因为指令重排序，先给变量赋值了对象的地址，但是对象本身还没有创建，被其他线程使用，导致空指针","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1602471720,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2071327,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/9b/1f/9f3379d3.jpg","nickname":"Geek_7f21d2","note":"","ucode":"12204FDAD951BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1263009,"avatar":"https://static001.geekbang.org/account/avatar/00/13/45/a1/d97c3e23.jpg","nickname":"莺歌蕾西","note":"","ucode":"445AE78CF5C86B","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":325567,"discussion_content":"要认真听讲啊兄弟","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1605350057,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":311718,"ip_address":""},"score":325567,"extra":""}]},{"author":{"id":1606474,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eotQ0pwrCZctLQ8IfRphIwqVSUISxncqlG4XbvSGvicMYYrRLEzSLHGc6IMKCziaDjJgQ444n9EqnoA/132","nickname":"ilovepeace","note":"","ucode":"F6E8F0429A7987","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":165878,"discussion_content":"同求","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1581339008,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1785016,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/3c/b8/9489387c.jpg","nickname":"鱼丸粗面","note":"","ucode":"B2F3F75B0D1422","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360824,"discussion_content":"synchronized内部本身就可以防止指令重排序了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1616545885,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1181401,"avatar":"https://static001.geekbang.org/account/avatar/00/12/06/d9/a3b1466c.jpg","nickname":"青春那些事","note":"","ucode":"DF515BFD8F0A30","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1785016,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/3c/b8/9489387c.jpg","nickname":"鱼丸粗面","note":"","ucode":"B2F3F75B0D1422","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547667,"discussion_content":"扯吧 sync本身有volitile的语意是针对sync块和其他代码块之间 而不是sync块内部","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1642808461,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":360824,"ip_address":""},"score":547667,"extra":""},{"author":{"id":1222119,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a5/e7/815acbf7.jpg","nickname":"warm_day","note":"","ucode":"3CD078E809497C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1785016,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/3c/b8/9489387c.jpg","nickname":"鱼丸粗面","note":"","ucode":"B2F3F75B0D1422","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579984,"discussion_content":"sync是为了保证原子性呦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657788029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":360824,"ip_address":""},"score":579984,"extra":""}]},{"author":{"id":1809802,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/8a/a2d34896.jpg","nickname":"一元(wx:abley1874)","note":"","ucode":"5E7A33642FC767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291112,"discussion_content":"得道答案了吗？各位","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594710172,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1101718,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cf/96/251c0cee.jpg","nickname":"xindoo","note":"","ucode":"AEAF3208E644BC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1809802,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/8a/a2d34896.jpg","nickname":"一元(wx:abley1874)","note":"","ucode":"5E7A33642FC767","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291162,"discussion_content":"没有","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594720948,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":291112,"ip_address":""},"score":291162,"extra":""}]},{"author":{"id":1160644,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b5/c4/9148b40d.jpg","nickname":"SunshineBoy","note":"","ucode":"FC54CD1815CCBA","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217955,"discussion_content":"加了synchronized，使高并发环境变为单线程环境，单线程环境不用考虑指令重排序。单线程环境本来就是线程安全的。指令重不重排序已经不重要了 。即符合happen-before原则","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585588321,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":6,"child_discussions":[{"author":{"id":1101718,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cf/96/251c0cee.jpg","nickname":"xindoo","note":"","ucode":"AEAF3208E644BC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1160644,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b5/c4/9148b40d.jpg","nickname":"SunshineBoy","note":"","ucode":"FC54CD1815CCBA","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":218182,"discussion_content":"你没有理解真正的问题，synchronized代码块确实可以保证只有单线程进入，这个线程里不用关注关注重排序也没问题。但如果这个线程给instance变量赋了值，其它线程就可以拿到instance并使用了，指令重排序可能导致instance没有初始化完就被别的线程用了，这才是volatile要解决的问题。 ","likes_number":13,"is_delete":false,"is_hidden":false,"ctime":1585628699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":217955,"ip_address":""},"score":218182,"extra":""},{"author":{"id":2122539,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","nickname":"阿骨打","note":"","ucode":"35EADA5550162A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1160644,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b5/c4/9148b40d.jpg","nickname":"SunshineBoy","note":"","ucode":"FC54CD1815CCBA","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":300298,"discussion_content":"new一个对象的时候分为3步，1、开辟空间 2、赋值 3、将地址赋给外部的引用，其中 2 3会重排序  所以才用了 volatile，然后才会用到你的happens-before原则","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598014522,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":217955,"ip_address":""},"score":300298,"extra":""},{"author":{"id":2122539,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","nickname":"阿骨打","note":"","ucode":"35EADA5550162A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1160644,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b5/c4/9148b40d.jpg","nickname":"SunshineBoy","note":"","ucode":"FC54CD1815CCBA","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":300299,"discussion_content":"并发编程的艺术 这本书有提到，当然它是阿里的工程师 根据 并发编程实战 这本书总结的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598014569,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":217955,"ip_address":""},"score":300299,"extra":""}]},{"author":{"id":1113737,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2icbib62icXtibTkThtyRksbuJLoTLMts7zook2S30MiaBtbz0f5JskwYicwqXkhpYfvCpuYkcvPTibEaQ/132","nickname":"xuanyuan","note":"","ucode":"1EC79B9372868F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":189030,"discussion_content":"应该是老师说错了，1.5之前用volatile也有问题，1.5之后用volatile好了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582849232,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1101718,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cf/96/251c0cee.jpg","nickname":"xindoo","note":"","ucode":"AEAF3208E644BC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1113737,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2icbib62icXtibTkThtyRksbuJLoTLMts7zook2S30MiaBtbz0f5JskwYicwqXkhpYfvCpuYkcvPTibEaQ/132","nickname":"xuanyuan","note":"","ucode":"1EC79B9372868F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":189298,"discussion_content":"1.5之前volatile没有禁止指令重排序的功能，是会有问题，我觉得老师应该知道这点。老师在文中说的是new方法逻辑的变更导致不再需要volatile了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582866082,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":189030,"ip_address":""},"score":189298,"extra":""},{"author":{"id":1160644,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b5/c4/9148b40d.jpg","nickname":"SunshineBoy","note":"","ucode":"FC54CD1815CCBA","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":1113737,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2icbib62icXtibTkThtyRksbuJLoTLMts7zook2S30MiaBtbz0f5JskwYicwqXkhpYfvCpuYkcvPTibEaQ/132","nickname":"xuanyuan","note":"","ucode":"1EC79B9372868F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217958,"discussion_content":"加了synchronized，使高并发环境变为单线程环境，单线程环境不用考虑指令重排序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585588429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":189030,"ip_address":""},"score":217958,"extra":""},{"author":{"id":1329127,"avatar":"https://static001.geekbang.org/account/avatar/00/14/47/e7/f5128436.jpg","nickname":"Androider","note":"","ucode":"20E4B04A960556","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1101718,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cf/96/251c0cee.jpg","nickname":"xindoo","note":"","ucode":"AEAF3208E644BC","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":340711,"discussion_content":"「new方法逻辑的变更」是怎么个变更法？ 可以详细说一下吗  谢谢啦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610101900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":189298,"ip_address":""},"score":340711,"extra":""}]},{"author":{"id":2683430,"avatar":"https://static001.geekbang.org/account/avatar/00/28/f2/26/a8ac6b42.jpg","nickname":"听风有信","note":"","ucode":"2CCB467114FF5C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387427,"discussion_content":"应该还是需要的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628162391,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1261052,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3d/fc/f81d7847.jpg","nickname":"BATMAN","note":"","ucode":"414137A1074E62","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":355380,"discussion_content":"DDL创建单例好像还是某个大厂的面试题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615425678,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2358638,"avatar":"https://static001.geekbang.org/account/avatar/00/23/fd/6e/1913dbb6.jpg","nickname":"Amber","note":"","ucode":"650FE5C46CCD1C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335817,"discussion_content":"双检查锁实现单例本身就是错的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608344225,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1591223,"avatar":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","nickname":"JerryZhu","note":"","ucode":"76850CD45786C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307931,"discussion_content":"同求一个， 据我所知， 创建对象还是要拆开啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600787316,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2179830,"avatar":"","nickname":"Geek_f00f74","note":"","ucode":"7A0E89CB0AF499","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305517,"discussion_content":"同求","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599980851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1366632,"avatar":"https://static001.geekbang.org/account/avatar/00/14/da/68/11ab05f3.jpg","nickname":"百钰","note":"","ucode":"D8C53679C24B61","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297380,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596893410,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1461320,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/vE94VZiawHoIxqWbPZOGDnl34vXEhhYTRWxiaUaRB1GbaOOQ6tjWib3icYQf9iaQvVJswUkY2wg2PR4FmrzIzmqTibHA/132","nickname":"秦歌","note":"","ucode":"0C6A3861BF6AFE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294763,"discussion_content":"大佬们找到答案了没","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595991398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1243331,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f8/c3/1d557354.jpg","nickname":"o my love","note":"","ucode":"307601ACAC5DCC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289962,"discussion_content":"这个问题解决了吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594283532,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1101718,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cf/96/251c0cee.jpg","nickname":"xindoo","note":"","ucode":"AEAF3208E644BC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1243331,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f8/c3/1d557354.jpg","nickname":"o my love","note":"","ucode":"307601ACAC5DCC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290342,"discussion_content":"没有","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594437194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":289962,"ip_address":""},"score":290342,"extra":""}]},{"author":{"id":1498641,"avatar":"https://static001.geekbang.org/account/avatar/00/16/de/11/72f96304.jpg","nickname":"M.O(∩_∩)O","note":"","ucode":"B245C2BA20DDA8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":241657,"discussion_content":"同求","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587432518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1337453,"avatar":"https://static001.geekbang.org/account/avatar/00/14/68/6d/cfbb7218.jpg","nickname":"ggqi","note":"","ucode":"DC1CFE87E3217D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":222796,"discussion_content":"http://www.imooc.com/article/276841","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586175315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1101718,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cf/96/251c0cee.jpg","nickname":"xindoo","note":"","ucode":"AEAF3208E644BC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1337453,"avatar":"https://static001.geekbang.org/account/avatar/00/14/68/6d/cfbb7218.jpg","nickname":"ggqi","note":"","ucode":"DC1CFE87E3217D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":229848,"discussion_content":"这篇文章之前我也搜索到过，文章作者只是发现了这个现象，但具体原理他也不知道。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586695181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":222796,"ip_address":""},"score":229848,"extra":""}]},{"author":{"id":1044178,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ee/d2/7024431c.jpg","nickname":"探索无止境","note":"","ucode":"91D2A9907DFA79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214582,"discussion_content":"同求","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585211217,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1189752,"avatar":"https://static001.geekbang.org/account/avatar/00/12/27/78/c474624b.jpg","nickname":"陈序员","note":"","ucode":"ECA6175A97AF3B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":184406,"discussion_content":"同求","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582554548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1251721,"avatar":"https://static001.geekbang.org/account/avatar/00/13/19/89/20488013.jpg","nickname":"hanazawakana","note":"","ucode":"E0F6FACBFE7D15","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":166780,"discussion_content":"因为volatile在jdk1.5开始通过happens-before增强了有序性，happens-before底层基于内存屏障，禁止了排序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581427650,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1101718,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cf/96/251c0cee.jpg","nickname":"xindoo","note":"","ucode":"AEAF3208E644BC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1251721,"avatar":"https://static001.geekbang.org/account/avatar/00/13/19/89/20488013.jpg","nickname":"hanazawakana","note":"","ucode":"E0F6FACBFE7D15","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":167312,"discussion_content":"感谢，但好像依旧没有解答我的问题，我的问题是为什么不再需要volatile？ 还是说你的意思是new增强的有序性？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581476821,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":166780,"ip_address":""},"score":167312,"extra":""},{"author":{"id":1177602,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f8/02/a02d127d.jpg","nickname":"Treasure","note":"","ucode":"4211ECEB347C3D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1251721,"avatar":"https://static001.geekbang.org/account/avatar/00/13/19/89/20488013.jpg","nickname":"hanazawakana","note":"","ucode":"E0F6FACBFE7D15","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":168258,"discussion_content":"同问，为啥不再需要啊，happen-before，也是需要加上volatile才有用啊。为啥争哥说不用加？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581565967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":166780,"ip_address":""},"score":168258,"extra":""},{"author":{"id":1403980,"avatar":"https://static001.geekbang.org/account/avatar/00/15/6c/4c/be735cc5.jpg","nickname":"自己争取","note":"","ucode":"90821BF6E6B85E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1101718,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cf/96/251c0cee.jpg","nickname":"xindoo","note":"","ucode":"AEAF3208E644BC","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":229605,"discussion_content":"文字里扣号说 new 和初始化 原子性了吧。应该是jvm 实现了吧，个人理解","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586672439,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":167312,"ip_address":""},"score":229605,"extra":""}]}]},{"had_liked":false,"id":152457,"user_name":"昨日火冷啊","can_delete":false,"product_type":"c1","uid":1215103,"ip_address":"","ucode":"126A583CCF9E91","user_header":"https://static001.geekbang.org/account/avatar/00/12/8a/7f/fcb659b7.jpg","comment_is_top":false,"comment_ctime":1574005725,"is_pvip":false,"replies":[{"id":"60034","content":"从你的描述来看，有点类似的。","user_name":"作者回复","comment_id":152457,"uid":"1190123","ip_address":"","utype":1,"ctime":1574855183,"user_name_real":"王争"}],"discussion_count":3,"race_medal":0,"score":"27343809501","product_id":100039001,"comment_content":"老师好，<br>请问c++的template算不算 duck-typing？ 比如定义一个模版，A&lt;T&gt;，用到函数T.Load()。然后有类B 和C都有成员函数Load（）。 那么都可以通过使用A&lt;B&gt;  和A&lt;C&gt; 来使用模版，而B，C之间不需要继承关系。 ","like_count":6,"discussions":[{"author":{"id":1417381,"avatar":"https://static001.geekbang.org/account/avatar/00/15/a0/a5/b0072646.jpg","nickname":"Ffffff","note":"","ucode":"25C40FE3A8B4BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296665,"discussion_content":"纠正一点：AccessibilityManager用的应该是饿汉模式","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1596618730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309284,"discussion_content":"多个线程可以同时使用同一个静态FileWriter对象也会出现日志写入覆盖吧，是静态FileWriter对象作为sychnorized锁？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601253484,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1138766,"avatar":"https://static001.geekbang.org/account/avatar/00/11/60/4e/1c654d86.jpg","nickname":"Omooo","note":"","ucode":"FFADFDC72EC847","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300242,"discussion_content":"一开口就知道，老 Android 怪了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597998020,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296278,"discussion_content":"哈哈，我都在考虑消息队列了，这个简单","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596502017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152246,"user_name":"码农Kevin亮","can_delete":false,"product_type":"c1","uid":1116630,"ip_address":"","ucode":"D34562461CA0A1","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/d6/5f366427.jpg","comment_is_top":false,"comment_ctime":1573950435,"is_pvip":false,"replies":[{"id":"58604","content":"是的 有人把它叫做静态多态","user_name":"作者回复","comment_id":152246,"uid":"1190123","ip_address":"","utype":1,"ctime":1574040275,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"27343754211","product_id":100039001,"comment_content":"请问老师，有些教科书上会把重载也理解为多态，老师怎么理解呢","like_count":6,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474764,"discussion_content":"是的 有人把它叫做静态多态","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574040275,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151367,"user_name":"铿然","can_delete":false,"product_type":"c1","uid":1162461,"ip_address":"","ucode":"D529242EC2E2EA","user_header":"https://static001.geekbang.org/account/avatar/00/11/bc/dd/c9413f59.jpg","comment_is_top":false,"comment_ctime":1573707401,"is_pvip":true,"discussion_count":7,"race_medal":0,"score":"27343511177","product_id":100039001,"comment_content":"感觉抽象并不是为了信息隐藏，抽象是为了把共性的东西抽象出来，如麻雀，燕子的行为可以抽象为鸟的行为，这是抽象，这篇描述的抽象个人觉得不那么准确。","like_count":6,"discussions":[{"author":{"id":1357311,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b5/ff/d1f205b0.jpg","nickname":"L","note":"","ucode":"5B847B2378854E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296155,"discussion_content":"同求解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596462019,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151768,"user_name":"风流倜傥怪蜀黍","can_delete":false,"product_type":"c1","uid":1241140,"ip_address":"","ucode":"ADBA7EBDC9C7E2","user_header":"https://static001.geekbang.org/account/avatar/00/12/f0/34/d572802b.jpg","comment_is_top":false,"comment_ctime":1573788123,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23048624603","product_id":100039001,"comment_content":"偏门语言 OC 前来报道!!!<br>OC 不支持多继承,原因无非就是菱形继承导致的二异性.<br>OC 中的协议根老师讲的接口类是一个概念,只有方法声明(swift 可添加默认实现),可以实现伪多继承.<br>这里要说一下 OC 的消息转发机制,源自 smallTalk,赋予了 OC 语言的动态性,是整个 OC 语言的一大亮点,消息转发简单的理解成我虽然无法响应这个函数,但是我可以在运行时的时候指定其它类去响应,利用这个可以实现动态的实现多继承和多态特性","like_count":5},{"had_liked":false,"id":152949,"user_name":"ldd","can_delete":false,"product_type":"c1","uid":1208157,"ip_address":"","ucode":"E8344FAFFE5CF3","user_header":"https://static001.geekbang.org/account/avatar/00/12/6f/5d/f0a19f09.jpg","comment_is_top":false,"comment_ctime":1574128535,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18753997719","product_id":100039001,"comment_content":"话题1：<br>Objective-C不支持多继承，OC的方法调用是基于消息机制，是基于方法名调用的，而且是发生在运行时而非编译时，很难解决多个基类可能导致的二义性问题。<br>话题2：<br>封装：@private、@protected、@public 表作用域的关键字，而且还可以用.h、.m机制实现。<br>抽象：protocol 协议来实现。<br>继承：简单的 Child : Parent 来实现，内部其实用 isa 指针来实现的。<br>多态：继承、protocol 都可以实现<br><br>番外：OC也可以实现多继承，可以用消息转发机制去实现。但本人觉得多继承好像确实不是很实用，之前看 c++ 文档也不建议多用，很想听听争哥对多继承的态度☺️","like_count":4},{"had_liked":false,"id":151845,"user_name":"月坛小雨","can_delete":false,"product_type":"c1","uid":1209475,"ip_address":"","ucode":"AB7C38A85692E6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJVhMyzoAPOLPI5wxsxSydHZeqNdz1SLRnPPQ0STmWwXIbkhaLHw4t2AXsTJwicgEibcRAMZEgibAKgg/132","comment_is_top":false,"comment_ctime":1573799627,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18753668811","product_id":100039001,"comment_content":"python支持多重继承，带来钻石继承问题主要是两点：一是父类方法的调用顺序，二是父类方法会被执行多次。对问题一，python使用了C3算法，在避免同一类被调用多次的前提下，使用广度优先和从左到右的原则寻找需要属性和方法，使用funcitonname.__mro__可以查看调用顺序。对问题二，python在子类重写方法时，使用super().methodname()语句，super本质上是一个类，内部记录着MRO信息，也是用C3算法保证一个类只会被搜寻一次。","like_count":4},{"had_liked":false,"id":150755,"user_name":"安静","can_delete":false,"product_type":"c1","uid":1212758,"ip_address":"","ucode":"ABF1824D24BA2F","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/56/311be282.jpg","comment_is_top":false,"comment_ctime":1573607175,"is_pvip":false,"replies":[{"id":"59140","content":"我个人觉得duck typing过于灵活了","user_name":"作者回复","comment_id":150755,"uid":"1190123","ip_address":"","utype":1,"ctime":1574333795,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"18753476359","product_id":100039001,"comment_content":"duck-typing 实现多态的方式确实灵活，这个维护成功也会比较高吗？","like_count":4,"discussions":[{"author":{"id":1718303,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKDfO7wKibzpw4YsoqLRCHUKxX4rYRUh7m7RCdOwzWVaN9QLlhcU5ho3w2Qcpib1O69YPj65ib07xQBQ/132","nickname":"努力呼吸","note":"","ucode":"52941DD7A01BBA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215054,"discussion_content":"对，我也想知道出处","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585277725,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1113660,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","nickname":"Miaozhe","note":"","ucode":"62872E8C138B67","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1718303,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKDfO7wKibzpw4YsoqLRCHUKxX4rYRUh7m7RCdOwzWVaN9QLlhcU5ho3w2Qcpib1O69YPj65ib07xQBQ/132","nickname":"努力呼吸","note":"","ucode":"52941DD7A01BBA","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":224314,"discussion_content":"我认为此处加Volitile是为了使缓存写入主存，是其它线程的缓存失效。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586275878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":215054,"ip_address":""},"score":224314,"extra":""},{"author":{"id":1809802,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/8a/a2d34896.jpg","nickname":"一元(wx:abley1874)","note":"","ucode":"5E7A33642FC767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1113660,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","nickname":"Miaozhe","note":"","ucode":"62872E8C138B67","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291114,"discussion_content":"答非所问吧。你说的这是volatile的可见性特性，而且这儿使用的是互斥锁，根本不需要可见性，只是volatile会禁止指令重排。我们想知道的是，到底jvm是否已经将 new对象的操作优化为了原子操作，是否不用考虑指令重排问题","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1594710443,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":224314,"ip_address":""},"score":291114,"extra":""},{"author":{"id":1261052,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3d/fc/f81d7847.jpg","nickname":"BATMAN","note":"","ucode":"414137A1074E62","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1113660,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","nickname":"Miaozhe","note":"","ucode":"62872E8C138B67","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":355382,"discussion_content":"是为了禁止指令冲排序，new 一个对象并不是一个原子性操作（不知道高版本的jvm是不是），大概分为：分配内存地址，赋默认值，赋值，返回内存地址，冲排序会把返回内存地址提前，导致对象的某些属性还是默认值，而对象不是null","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1615425917,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":224314,"ip_address":""},"score":355382,"extra":""}]}]},{"had_liked":false,"id":150693,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1573602558,"is_pvip":true,"replies":[{"id":"59169","content":"理论上讲这是一种hack的方法 不推荐使用","user_name":"作者回复","comment_id":150693,"uid":"1190123","ip_address":"","utype":1,"ctime":1574385114,"user_name_real":"王争"}],"discussion_count":3,"race_medal":0,"score":"18753471742","product_id":100039001,"comment_content":"老师，我还有一个问题：<br>Java中支持反射机制。利用反射机制，我们可以访问类的私有变量和私有方法。请问这是否有违“封装”的初衷呢？哪些场合我们要必须使用“反射”访问私有变量或者私有方法呢？","like_count":4,"discussions":[{"author":{"id":1866485,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/7a/f5/54a5084b.jpg","nickname":"简单猫","note":"","ucode":"EA027D4C344E25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":265239,"discussion_content":"饿汉 大饼先挂你脖子上，想吃就吃。\n懒汉 饿了说一声(要用的时候) 再给你饼 省的饼挂身上浪费力气(资源)","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1589380855,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490719,"discussion_content":"着急吃-》饿汉式\n不着急吃-》懒汉式","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597454733,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1324863,"avatar":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","nickname":"KK","note":"","ucode":"FFC31A3FE3A285","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299904,"discussion_content":"got it","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597850905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164536,"user_name":"请叫我和尚","can_delete":false,"product_type":"c1","uid":1703256,"ip_address":"","ucode":"33A8A1CDA103F9","user_header":"https://static001.geekbang.org/account/avatar/00/19/fd/58/1af629c7.jpg","comment_is_top":false,"comment_ctime":1577022916,"is_pvip":false,"replies":[{"id":"65140","content":"是的","user_name":"作者回复","comment_id":164536,"uid":"1190123","ip_address":"","utype":1,"ctime":1577949734,"user_name_real":"王争"}],"discussion_count":1,"race_medal":1,"score":"14461924804","product_id":100039001,"comment_content":"多态是否又分为编译时多态和运行时多态？","like_count":3,"discussions":[{"author":{"id":1236024,"avatar":"","nickname":"我睡觉不磨牙","note":"","ucode":"16DFDE5C649160","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":200657,"discussion_content":"多数情况下可能只需要一个EventBus实例，框架为避免只需要一个EventBus的开发者因为误操作 创建多个实例，所以采用单例提供一个默认的。用单例模式只是为了提供这一个默认的实例，并不代表EventBus类在系统中只能有一个实例。  只是个人理解","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583711110,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1212750,"avatar":"https://static001.geekbang.org/account/avatar/00/12/81/4e/d71092f4.jpg","nickname":"夏目","note":"","ucode":"67C075A01CF4D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":243540,"discussion_content":"我咋没看到双重锁检测😳","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587548243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1362631,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","nickname":"黄林晴","note":"","ucode":"B15C38AECDA88F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1212750,"avatar":"https://static001.geekbang.org/account/avatar/00/12/81/4e/d71092f4.jpg","nickname":"夏目","note":"","ucode":"67C075A01CF4D2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":243566,"discussion_content":"源码中的getDefault方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587549706,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":243540,"ip_address":""},"score":243566,"extra":""},{"author":{"id":1212750,"avatar":"https://static001.geekbang.org/account/avatar/00/12/81/4e/d71092f4.jpg","nickname":"夏目","note":"","ucode":"67C075A01CF4D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1362631,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","nickname":"黄林晴","note":"","ucode":"B15C38AECDA88F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":244550,"discussion_content":"com.google.common.eventbus这个包下面的EventBus类吗，没看到这个方法，我是guava 23.0","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587611714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":243566,"ip_address":""},"score":244550,"extra":""},{"author":{"id":1362631,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","nickname":"黄林晴","note":"","ucode":"B15C38AECDA88F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1212750,"avatar":"https://static001.geekbang.org/account/avatar/00/12/81/4e/d71092f4.jpg","nickname":"夏目","note":"","ucode":"67C075A01CF4D2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":244698,"discussion_content":"我说的eventbus是android中使用的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587622403,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":244550,"ip_address":""},"score":244698,"extra":""}]},{"author":{"id":1359893,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c0/15/be72b945.jpg","nickname":"端点星好运","note":"","ucode":"AA48B23A1C4317","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":161198,"discussion_content":"多例？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580875499,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1362631,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","nickname":"黄林晴","note":"","ucode":"B15C38AECDA88F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1359893,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c0/15/be72b945.jpg","nickname":"端点星好运","note":"","ucode":"AA48B23A1C4317","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":161229,"discussion_content":"源码写的是单例","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580878815,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":161198,"ip_address":""},"score":161229,"extra":""}]}]},{"had_liked":false,"id":286175,"user_name":"大毛","can_delete":false,"product_type":"c1","uid":1899599,"ip_address":"","ucode":"93B18287F06706","user_header":"https://static001.geekbang.org/account/avatar/00/1c/fc/4f/0a452c94.jpg","comment_is_top":false,"comment_ctime":1617178886,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10207113478","product_id":100039001,"comment_content":"举个例子：<br>- 封装：一个人有五脏六腑，你可以获得相关的信息，但是你不可以修改他们<br>- 抽象：人可以跑、学习、娱乐，你只需要提供这些行为的方法，而不需要告诉调用者人是怎么跑的<br>- 继承：男人女人都是人，他们可以继承“人”这个类<br>- 多态：不管是什么人，他们都可以完成“学习”这个动作，只不过不同的人的学习方式可能不同","like_count":2},{"had_liked":false,"id":273468,"user_name":"qf年间","can_delete":false,"product_type":"c1","uid":1463023,"ip_address":"","ucode":"AA08AC984637EE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLbchZfeEnshPuUwEsQkn1XbWxjs3rRUpSRUxjW4q7rOcrPvXld0IxEZ1jlpEJdklFeEVERJoOfibg/132","comment_is_top":false,"comment_ctime":1610607235,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10200541827","product_id":100039001,"comment_content":"dynamicArray的例子实际上说的是一个“向上转型”的问题","like_count":2},{"had_liked":false,"id":244502,"user_name":"ThinkingQuest","can_delete":false,"product_type":"c1","uid":1118560,"ip_address":"","ucode":"597D0C00DAEFE4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/0SDRac7XoordnKYgDLhz5wxAOtE6xqcsSywsywEtKQAR7xicBZQ6ceYftfZjl4Ivq3a5dzvRhYkn2GcUWiaQK7ZQ/132","comment_is_top":false,"comment_ctime":1598540991,"is_pvip":false,"replies":[{"id":"90144","content":"������，谢谢姐","user_name":"作者回复","comment_id":244502,"uid":"1190123","ip_address":"","utype":1,"ctime":1598835649,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"10188475583","product_id":100039001,"comment_content":"口语中的“爬行动物”指的是：动物界 脊索动物门 脊椎动物亚门 爬行纲。<br>猫属于： 动物界 脊索动物门 脊椎动物亚门 哺乳纲 食肉目 猫科 猫属<br><br>所以，猫不是“爬行动物”。<br><br>你要说猫属于“会爬行的动物”，那也对。 <br>","like_count":2,"discussions":[{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282201,"discussion_content":"这么好的老铁称之为程序破坏者，哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591922028,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244436,"user_name":"Jasper","can_delete":false,"product_type":"c1","uid":1144132,"ip_address":"","ucode":"7AEF50986C7D8C","user_header":"https://static001.geekbang.org/account/avatar/00/11/75/44/ee170215.jpg","comment_is_top":false,"comment_ctime":1598516373,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10188450965","product_id":100039001,"comment_content":"记忆多态三个特性有个很好的口诀：<br>一要有继承；<br>二要有重写；<br>三是父类引用指向子类对象。<br>想当年大学时代听马士兵老师的视频课程，对这个口诀可谓是记忆犹新呀^_^","like_count":2},{"had_liked":false,"id":201806,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":false,"comment_ctime":1585839435,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10175774027","product_id":100039001,"comment_content":"JDK7以后，有了invokedynamic，其实在字节码层面也是可以实现duck-typing效果的","like_count":2},{"had_liked":false,"id":170760,"user_name":"晓杉","can_delete":false,"product_type":"c1","uid":1209336,"ip_address":"","ucode":"19E634BB61A165","user_header":"https://static001.geekbang.org/account/avatar/00/12/73/f8/dbd2fa50.jpg","comment_is_top":false,"comment_ctime":1578707435,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10168642027","product_id":100039001,"comment_content":"java不支持多继承，但支持多实现，可以一定程度上弥补多继承。","like_count":2},{"had_liked":false,"id":153923,"user_name":"小妖","can_delete":false,"product_type":"c1","uid":1730626,"ip_address":"","ucode":"49C01DBFADF101","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJvm1JYIDcS74s4cEYxA1PXMqjortVXEjUKyGQcPvibNJ4EAuksIa6uoHgr6G1yRqAM2KtP3yicKgTA/132","comment_is_top":false,"comment_ctime":1574330821,"is_pvip":false,"replies":[{"id":"59156","content":"你举的例子不还是子类传递给父类吗","user_name":"作者回复","comment_id":153923,"uid":"1190123","ip_address":"","utype":1,"ctime":1574377744,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"10164265413","product_id":100039001,"comment_content":"我觉得文中对多肽的定义有问题，多肽不仅是只子类替换父类（父类对象引用子类对象），也包括父类（代理类）可以在某些时候代替子类作为参数传递（继承的方式实现参数代理），更直观的表现是实现类替换接口（接口引用接口的实现比如 : LIst&lt;String&gt; list=new ArrayList&lt;&gt;();）,这听起来有点像是抽象，实际上抽象的很多情况下是依赖多肽的，比如，方法接口接口作为参数，而不必接收具体的类这体现了抽象，但更体现了多肽…………求交流","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475324,"discussion_content":"你举的例子不还是子类传递给父类吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574377744,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153094,"user_name":"wanghai","can_delete":false,"product_type":"c1","uid":1450052,"ip_address":"","ucode":"44B7355C2BDBB2","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erToic2lDbQhozlh2Ey72ia4svuXZ4FmJERWMvATna98XEwxhqnHPVfzsdNsibicIK4ZpSReNrp7N7V9g/132","comment_is_top":false,"comment_ctime":1574156086,"is_pvip":false,"replies":[{"id":"59172","content":"后面章节会讲到 别急","user_name":"作者回复","comment_id":153094,"uid":"1190123","ip_address":"","utype":1,"ctime":1574385771,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"10164090678","product_id":100039001,"comment_content":"我最近在做一个功能，而且我也是有一些迷茫<br>我用到了继承，在父类定义了很多方法，然后我有很多子类，每个子类自己来实现一些需要重写的方法.<br>我也想到了组合，但是组合好像无法重写方法，导致变的更麻烦，希望大神帮我解惑～～","like_count":2,"discussions":[{"author":{"id":1016905,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/49/47d48fd0.jpg","nickname":"观弈道人","note":"","ucode":"F3BB619A33C605","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":194761,"discussion_content":"没见过多台机器共享一个日志文件的，不是找事情嘛","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1583242151,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1606474,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eotQ0pwrCZctLQ8IfRphIwqVSUISxncqlG4XbvSGvicMYYrRLEzSLHGc6IMKCziaDjJgQ444n9EqnoA/132","nickname":"ilovepeace","note":"","ucode":"F6E8F0429A7987","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":165914,"discussion_content":"刚看完单例下篇，如果你的日志文件在一个公共目录，可以利用集群单例方式处理。但是我觉得通常做法一般还是集群中各个实例维护自己的日志，然后统一收集查看即可。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1581341133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1241576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f1/e8/d2e88567.jpg","nickname":"ssrsdzry","note":"","ucode":"89BCFA6A1997E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1606474,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eotQ0pwrCZctLQ8IfRphIwqVSUISxncqlG4XbvSGvicMYYrRLEzSLHGc6IMKCziaDjJgQ444n9EqnoA/132","nickname":"ilovepeace","note":"","ucode":"F6E8F0429A7987","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":200621,"discussion_content":"+1，我见过的方式是每台机器生成自己的日志文件，文件名包含service名称+机器名称+日期。最后所有机器的日志会被发送到一台存放历史日志的机器上。存放一个月或者其他时间之后会被删除。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1583691282,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":165914,"ip_address":""},"score":200621,"extra":""}]},{"author":{"id":2122580,"avatar":"","nickname":"Geek_ddf6a8","note":"","ucode":"873A8920AF06B2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301093,"discussion_content":"加类锁、单例方式都会覆盖同一个文件，而分布式锁如果多实例共用可以做到不会。docker如果采用k8s等编排，有多实例但没挂载目录情况下，各实例的目录空间是独立的，不会覆盖  如果多实例的日志文件挂载到同一个宿主机的相同目录下，是会被覆盖的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598405726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1606474,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eotQ0pwrCZctLQ8IfRphIwqVSUISxncqlG4XbvSGvicMYYrRLEzSLHGc6IMKCziaDjJgQ444n9EqnoA/132","nickname":"ilovepeace","note":"","ucode":"F6E8F0429A7987","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":165877,"discussion_content":"如果类似docker的实例，实际上相当于多台机器，写的日志应该在不同的实例目录下了吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581338983,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1525958,"avatar":"","nickname":"一只雪狼","note":"","ucode":"5E986C16C6B1AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1606474,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eotQ0pwrCZctLQ8IfRphIwqVSUISxncqlG4XbvSGvicMYYrRLEzSLHGc6IMKCziaDjJgQ444n9EqnoA/132","nickname":"ilovepeace","note":"","ucode":"F6E8F0429A7987","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":236023,"discussion_content":"如果docker挂了hostpath进去，用了同一个路径同一个文件名字也会覆盖的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587052179,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":165877,"ip_address":""},"score":236023,"extra":""}]}]},{"had_liked":false,"id":152350,"user_name":"王振华 程序员","can_delete":false,"product_type":"c1","uid":1131957,"ip_address":"","ucode":"31BB337642B882","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/b5/c3cfb198.jpg","comment_is_top":false,"comment_ctime":1573980796,"is_pvip":false,"replies":[{"id":"58603","content":"透明的意思不就是不知道细节吗","user_name":"作者回复","comment_id":152350,"uid":"1190123","ip_address":"","utype":1,"ctime":1574040109,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"10163915388","product_id":100039001,"comment_content":"请问：封装部分，“而且，这两个属性的初始化设置，对于 Wallet 类的调用者来说，也应该是透明的”，这句话我不理解。id、createTime这两个属性的初始化设置，对于Wallet类的调用者来说，为什么是透明的？调用者应该不知道Wallet类内部的实现细节才对呀？","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497882,"discussion_content":"静态变量没法替代单例啊。单例是类本身不允许多个实例。但是静态变量，我可以定义多个啊，这个怎么解决呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592526562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151873,"user_name":"William Ning","can_delete":false,"product_type":"c1","uid":1592279,"ip_address":"","ucode":"4DB8D05E69E5F3","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","comment_is_top":false,"comment_ctime":1573803547,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10163738139","product_id":100039001,"comment_content":"PHP独特的语法混合了C、Java、Perl以及 PHP自创的语法, 不支持多继承的原因应与Java同, 实现多继承的方式有: 接口&#47;trait&#47;__call() ","like_count":2},{"had_liked":false,"id":151568,"user_name":"逍遥思","can_delete":false,"product_type":"c1","uid":1015512,"ip_address":"","ucode":"340F05C786730F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/d8/92a98fb6.jpg","comment_is_top":false,"comment_ctime":1573741310,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10163675902","product_id":100039001,"comment_content":"Swift 不支持多重继承，原因应该和其他不支持多重继承的原因一样，为了避免多重继承额外引入的复杂度。<br><br>Swift 支持封装、抽象、继承、多态：对封装的语法支持是通过 fileprivate 关键字隐藏不暴露的变量和方法；对抽象的支持是通过 protocol 关键字；对继承的支持是 class A: ClassB，对多态的支持是子类重写父类的方法。","like_count":2,"discussions":[{"author":{"id":2678074,"avatar":"https://static001.geekbang.org/account/avatar/00/28/dd/3a/92726fb6.jpg","nickname":"Geek_f0f0bc","note":"","ucode":"A754BEC95E2BC6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390337,"discussion_content":"空间换时间 ，大家基本都能接受 ，而且 说实在话内存也不会耗费很多 ，并且大部分场景最后单例类都会用到，最后都是要为其分配内存的，所以更倾向于饿汉模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629788875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151487,"user_name":"学好习，做好人","can_delete":false,"product_type":"c1","uid":1205294,"ip_address":"","ucode":"C991643DB458E2","user_header":"https://static001.geekbang.org/account/avatar/00/12/64/2e/e70a317a.jpg","comment_is_top":false,"comment_ctime":1573729925,"is_pvip":false,"replies":[{"id":"58363","content":"也可以，不过看起来就有点过度设计的意思了，多了一个类，维护成本也提高了。","user_name":"作者回复","comment_id":151487,"uid":"1190123","ip_address":"","utype":1,"ctime":1573789197,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"10163664517","product_id":100039001,"comment_content":"钱包那个例子，个人感觉应该把钱包余额的加减操作独立出来，比如WalletAction，并且WalletAction作为wallet的成员变量会不会更好一些，因为id,createTime,modifyTime可以算作钱包的一些固有属性，但是余额增加更偏重一些动态的计算行为，用组合的方式会不会更好些呢？","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474494,"discussion_content":"也可以，不过看起来就有点过度设计的意思了，多了一个类，维护成本也提高了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573789197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151127,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1573655930,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10163590522","product_id":100039001,"comment_content":"1、你熟悉的编程语言是否支持多重继承？如果不支持，请说一下为什么不支持。如果支持，请说一下它是如何避免多重继承的副作用的？<br>   java不支持多重继承。<br>  原因：多重继承中若不同父类存在相同方法签名时，子类调用此方法时会不知道调用哪个父类的方法的问题。<br>   如何避免：个人觉得可以根据所继承父类的先后顺序来确定优先级","like_count":2},{"had_liked":false,"id":150990,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1573639040,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10163573632","product_id":100039001,"comment_content":"Java对于封装，抽象，继承，多态支持够用了。封装和抽象解决的是信息隐藏的问题，也就是说不同位置需要看到的信息不同。封装是以类为边界，两边需要的信息量不对等。抽象是以调用者和实现者的角度来区分，两者需要的信息量差异也很大。继承和多态是抽象思想的延续，当类被分为接口和实现的时候，所有针对接口实现的操作，也同样使用于实现类。当一个接口有多个实现类，而针对接口实现的操作适用于所有满足这个接口的实现类，这样就让针对接口的代码得到复用。","like_count":2,"discussions":[{"author":{"id":1238051,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/23/ac13d916.jpg","nickname":"圆哥哥呐丶","note":"","ucode":"8E56E3E68A3836","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50473,"discussion_content":"继承和多态是抽象思想的延续，这句话 牛批了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573724841,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150935,"user_name":"小辉辉","can_delete":false,"product_type":"c1","uid":1189661,"ip_address":"","ucode":"9FF25E25C85350","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/1d/1cb36854.jpg","comment_is_top":false,"comment_ctime":1573631668,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"10163566260","product_id":100039001,"comment_content":"go语言中也有duck-typing","like_count":2,"discussions":[{"author":{"id":1272047,"avatar":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","nickname":"Magic","note":"","ucode":"FD9CEDAA419EB0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50263,"discussion_content":"go的interface算是一种duck-typing","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573697635,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1189661,"avatar":"https://static001.geekbang.org/account/avatar/00/12/27/1d/1cb36854.jpg","nickname":"小辉辉","note":"","ucode":"9FF25E25C85350","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1272047,"avatar":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","nickname":"Magic","note":"","ucode":"FD9CEDAA419EB0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50272,"discussion_content":"学的时候有个疑惑，如果实现太多的interface，又没有明确表明是哪些interface，找的时候估计会很崩溃。也有可能是go提倡的类少写方法，多用组合的原因吧😂😂😂","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573698213,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":50263,"ip_address":""},"score":50272,"extra":""},{"author":{"id":1211359,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7b/df/876dd9cc.jpg","nickname":"kings","note":"","ucode":"D478306EBF582E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1189661,"avatar":"https://static001.geekbang.org/account/avatar/00/12/27/1d/1cb36854.jpg","nickname":"小辉辉","note":"","ucode":"9FF25E25C85350","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55311,"discussion_content":"看源码疑似奔溃\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574349332,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":50272,"ip_address":""},"score":55311,"extra":""}]}]},{"had_liked":false,"id":150782,"user_name":"编程界的小学生","can_delete":false,"product_type":"c1","uid":1593289,"ip_address":"","ucode":"4A5BE9A5E877FA","user_header":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","comment_is_top":false,"comment_ctime":1573609911,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"10163544503","product_id":100039001,"comment_content":"JAVA前来报到，不支持多继承是因为考虑到钻石问题，比如A继承B和C，B和C继承了D，那么A类中覆盖的D方法是B重写的还是C重写的呢？导致混乱。<br>有个问题就是: 某种意义上讲，JAVA是不是隐式支持多继承的？因为每个类都默认继承了Object类，都用有Object的toString等方法。","like_count":2,"discussions":[{"author":{"id":1205294,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/2e/e70a317a.jpg","nickname":"学好习，做好人","note":"","ucode":"C991643DB458E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50552,"discussion_content":"个人理解，在Java里面，Object应该是所有类的基类，如果一个类没有显示的定义继承关系，那么就会默认继承Object,比如class A{}   ,但是显示的定义了继承关系，此时的继承关系应该是单向链表是的，比如class B extends A{} ,那么继承关系应该是 B->A->Object","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1573733750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1593289,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","nickname":"编程界的小学生","note":"","ucode":"4A5BE9A5E877FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1205294,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/2e/e70a317a.jpg","nickname":"学好习，做好人","note":"","ucode":"C991643DB458E2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50555,"discussion_content":"你这个解释很有道理，学习了。👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573734003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":50552,"ip_address":""},"score":50555,"extra":""},{"author":{"id":1623626,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c6/4a/3bd896fc.jpg","nickname":"Heiky","note":"","ucode":"03AA79E1BC4AE4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1205294,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/2e/e70a317a.jpg","nickname":"学好习，做好人","note":"","ucode":"C991643DB458E2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52513,"discussion_content":"这个解释是正确的，实际就是这样，赞一个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574058617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":50552,"ip_address":""},"score":52513,"extra":""}]},{"author":{"id":1167825,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d1/d1/62f74aa7.jpg","nickname":"自在飞","note":"","ucode":"A2712148DA06E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51044,"discussion_content":"单继承是在类声明时只能继承一个父类，而多继承是在类声明定义同时可以继承多个父类.从类定义角度来看：我觉得单继承和多继承的关键区别就是在于 在类定义时是否可以同时继承多个父类。从类继承线路来看：单继承形成的是一个单链表，而多继承则不是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573803499,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1730626,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJvm1JYIDcS74s4cEYxA1PXMqjortVXEjUKyGQcPvibNJ4EAuksIa6uoHgr6G1yRqAM2KtP3yicKgTA/132","nickname":"小妖","note":"","ucode":"49C01DBFADF101","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50903,"discussion_content":" 个人观点，所有的类都继承Object确实能算是隐式多继承，为什么不会出现菱形问题？因为Object是java提供的，在方法实现上会有一定的实现逻辑来处理这个问题\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573784634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1593289,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","nickname":"编程界的小学生","note":"","ucode":"4A5BE9A5E877FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1730626,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJvm1JYIDcS74s4cEYxA1PXMqjortVXEjUKyGQcPvibNJ4EAuksIa6uoHgr6G1yRqAM2KtP3yicKgTA/132","nickname":"小妖","note":"","ucode":"49C01DBFADF101","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50940,"discussion_content":"看第二条评论，第二条是对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573790118,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":50903,"ip_address":""},"score":50940,"extra":""}]},{"author":{"id":1327343,"avatar":"https://static001.geekbang.org/account/avatar/00/14/40/ef/52bbadb9.jpg","nickname":"那就这样吧","note":"","ucode":"A1315C5EAF2917","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49817,"discussion_content":"每个类都继承Object，其他类有继承关系，这也只是链式继承吧，其实也就是单继承了，不会存在菱形问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573640990,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1593289,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","nickname":"编程界的小学生","note":"","ucode":"4A5BE9A5E877FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1327343,"avatar":"https://static001.geekbang.org/account/avatar/00/14/40/ef/52bbadb9.jpg","nickname":"那就这样吧","note":"","ucode":"A1315C5EAF2917","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49837,"discussion_content":"菱形问题确实不会存在，只是在想JAVA这样是不是也是多继承，只是隐式而已。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573643000,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":49817,"ip_address":""},"score":49837,"extra":""}]}]},{"had_liked":false,"id":150774,"user_name":"一周思进","can_delete":false,"product_type":"c1","uid":1032125,"ip_address":"","ucode":"00BE5402479B16","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bf/bd/0c40979f.jpg","comment_is_top":false,"comment_ctime":1573609251,"is_pvip":false,"replies":[{"id":"58367","content":"学一下java呗，也不难，周末有加餐文章，你可以跟着学下。","user_name":"作者回复","comment_id":150774,"uid":"1190123","ip_address":"","utype":1,"ctime":1573789669,"user_name_real":"王争"}],"discussion_count":2,"race_medal":3,"score":"10163543843","product_id":100039001,"comment_content":"搞C语言的咋整🤣","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474265,"discussion_content":"学一下java呗，也不难，周末有加餐文章，你可以跟着学下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573789669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1193874,"avatar":"https://static001.geekbang.org/account/avatar/00/12/37/92/961ba560.jpg","nickname":"授人以🐟，不如授人以渔","note":"","ucode":"BD53829E924B66","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50304,"discussion_content":"就我所知，使用 C 语言也可以实现类似 C++ 面向对象的代码结构。就比如 C 中的结构体，是 C++ 中的类。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573702007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150744,"user_name":"小先生","can_delete":false,"product_type":"c1","uid":1055214,"ip_address":"","ucode":"E5F2052E0323C0","user_header":"https://static001.geekbang.org/account/avatar/00/10/19/ee/e395a35e.jpg","comment_is_top":false,"comment_ctime":1573606519,"is_pvip":false,"replies":[{"id":"58368","content":"可能是我的个人习惯问题，我喜欢把URL在代码命名中写成Url。","user_name":"作者回复","comment_id":150744,"uid":"1190123","ip_address":"","utype":1,"ctime":1573789730,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"10163541111","product_id":100039001,"comment_content":"王老师，讨论一个代码规范的方面。 getPictureUrl() 写成  getPictureURL() 会不会更好一些？","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474257,"discussion_content":"可能是我的个人习惯问题，我喜欢把URL在代码命名中写成Url。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573789730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1120238,"avatar":"https://static001.geekbang.org/account/avatar/00/11/17/ee/b123e7bc.jpg","nickname":"大胃王","note":"","ucode":"17072DCDB4C7FC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51890,"discussion_content":"URI包含URL","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573963839,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150739,"user_name":"醉比","can_delete":false,"product_type":"c1","uid":1248399,"ip_address":"","ucode":"79E65F62BE7809","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/8f/4ebd303a.jpg","comment_is_top":false,"comment_ctime":1573606097,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10163540689","product_id":100039001,"comment_content":"java不支持多继承，大致了解两个原因：1.如果继承打得多个父类有相同的成员变量，子类在引用的时候就无法区分。2.若果继承的多个父类有相通的方法，而子类又没有重新实现该方法，那么在使用该方法时就无法确定该去使用哪个方法。欢迎指正与补充～","like_count":2,"discussions":[{"author":{"id":2046331,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIfQFSpQJNKeqTicbpr3Rjo4VYdjE85QMWicMkoTCrGljg6GZcTjXFib1hSt8X9QuUfEuhMQCrdP15Aw/132","nickname":"crabxyj","note":"","ucode":"C5E2A8676B90C5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331585,"discussion_content":"现在你可以在接口里面添加default实现默认方法，从而实现多继承，只不过多继承后必须需要在子类实现，有冲突的接口","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606905927,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150692,"user_name":"allean","can_delete":false,"product_type":"c1","uid":1051470,"ip_address":"","ucode":"A0D2DB4F219EAA","user_header":"https://static001.geekbang.org/account/avatar/00/10/0b/4e/fd946cb2.jpg","comment_is_top":false,"comment_ctime":1573602503,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10163537095","product_id":100039001,"comment_content":"打卡","like_count":2},{"had_liked":false,"id":150676,"user_name":"LJK","can_delete":false,"product_type":"c1","uid":1199213,"ip_address":"","ucode":"12B2441099FF1D","user_header":"https://static001.geekbang.org/account/avatar/00/12/4c/6d/c20f2d5a.jpg","comment_is_top":false,"comment_ctime":1573593604,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10163528196","product_id":100039001,"comment_content":"一些自己查的内容：<br><br>对于Python的封装特性，用双下滑线标注的private变量其实内部只是重命名了一下而已，即<br><br>class A():<br>    def __init__(self):<br>        self.__private = &quot;Private&quot;<br><br>其中的__private在A的实例上可以通过&quot;_A__private&quot;来访问，这么看来的话Python的封装其实还是相对比较宽松的，不知道为什么这么设计。<br><br>对于多态，Python接口类是通过abc抽象类来实现的。<br><br>如有不对还请指正，多谢大家","like_count":2,"discussions":[{"author":{"id":1248280,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0c/18/bacf4b7a.jpg","nickname":"daniel李","note":"","ucode":"573840F0C6573E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49719,"discussion_content":"其实ruby也是相同情况，封装机制都是比较宽松。觉得很多动态语言都这样，其中一个好处是灵活性。很多框架都是通过这种灵活性来做的。\n\n所以这种较宽松的封装机制得靠程序员自律。听过一种说法，同层次的程序员，动态类语言比静态语言很容易写出烂代码。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573624111,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1123103,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/1f/6452b2e8.jpg","nickname":"刘清斌","note":"","ucode":"775B053AF87B53","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49576,"discussion_content":"Python这样设计，我感觉主要考虑约定大于配置的原则，大家遵循这样原则，双下滑线属于私有变量，不应该被直接调用。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573614717,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150650,"user_name":"Bug? Feature!","can_delete":false,"product_type":"c1","uid":1164531,"ip_address":"","ucode":"F8FA8A0094FBA0","user_header":"https://static001.geekbang.org/account/avatar/00/11/c4/f3/92f654f1.jpg","comment_is_top":false,"comment_ctime":1573574524,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10163509116","product_id":100039001,"comment_content":"沙发","like_count":2},{"had_liked":false,"id":325280,"user_name":"曾佳皓","can_delete":false,"product_type":"c1","uid":1909810,"ip_address":"","ucode":"2BDC9CDBD8A60F","user_header":"","comment_is_top":false,"comment_ctime":1638889323,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5933856619","product_id":100039001,"comment_content":"c++支持多继承，因为存在虚继承，可以避免钻石继承","like_count":1},{"had_liked":false,"id":300812,"user_name":"嗯。","can_delete":false,"product_type":"c1","uid":1563245,"ip_address":"","ucode":"30FC6EF9A01070","user_header":"https://static001.geekbang.org/account/avatar/00/17/da/6d/7c8fdb14.jpg","comment_is_top":false,"comment_ctime":1625394466,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5920361762","product_id":100039001,"comment_content":"1.Java只支持单继承。因为假设子类C继承了A、B两个父类，而A、B同时存在call()方法，当子类调用call()方法时，会产生冲突<br>2.Java完全支持这四种特性，如文章所说：<br>封装：通过private、public、protected访问权限修饰符<br>继承：extends关键字<br>多态：继承+重写，接口类<br>抽象：interface、abstract","like_count":1},{"had_liked":false,"id":285873,"user_name":"李叶","can_delete":false,"product_type":"c1","uid":1470449,"ip_address":"","ucode":"41B33FA8526E48","user_header":"https://static001.geekbang.org/account/avatar/00/16/6f/f1/35f9f16f.jpg","comment_is_top":false,"comment_ctime":1617062589,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5912029885","product_id":100039001,"comment_content":"封装：数据保护隐藏，通过访问权限控制，暴露必要方法；抽象：通过接口实现，只提供功能，不暴露细节，解决复用问题；继承：表示is-a关系，复用；多态：父类可以是子类的应用，解决扩展复用问题。","like_count":1},{"had_liked":false,"id":268450,"user_name":"Gabriel","can_delete":false,"product_type":"c1","uid":1437358,"ip_address":"","ucode":"714772A93E93DC","user_header":"https://static001.geekbang.org/account/avatar/00/15/ee/ae/855b7e6e.jpg","comment_is_top":false,"comment_ctime":1608201582,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5903168878","product_id":100039001,"comment_content":"PHP:<br>1：php 不支持多继承，用关键字 extends 来继承一个类。<br>2：php支持重写。子类修改父类的方法。<br>3：接口<br>     a：接口，可以指定某个类必须实现哪里方法，但不需要定义这些方法的具体内容<br>     b：接口使用过 Interface 关键字来定义的，就像定义一个标准的类一样，但其中定义所有的方法都是空的。<br>     c：接口中定义的所有方法都是必须公有， 这是接口特性。<br>     d：要实现一个接口，使用implements操作符，类中必须实现接口中定义的所有方法，否则会报一个致命错误。<br>抽象类：任何一个类，如果它里面至少有一个方法被声明为抽象的，那么这个类就必须是抽象类。定义的抽象类不能被实例化。被定义为抽象的方法只是声明了其调用方式（参数），不能定义具体功能实现。继承一个抽象类的时候，子类必须定义父类中所有的抽象方法。这些方法的访问控制必须和父类中的一样（或者更宽松）<br>","like_count":1},{"had_liked":false,"id":260095,"user_name":"大魔王嗷呜","can_delete":false,"product_type":"c1","uid":1888220,"ip_address":"","ucode":"D6F0EA8E4A608B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/fRVxJWw4SfXbfIHHdVzrQsicfPSF1Ektv3dYaSNTlKo4xq62f1457see877ET6on206ls0dkemujob6ZK9ZAUIQ/132","comment_is_top":false,"comment_ctime":1604923170,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5899890466","product_id":100039001,"comment_content":"没有人用golang嘛，来总结下golang对面向对象的支持：<br>1. 封装：<br>变量，函数根据大小写字母判定是否可以被外部包调用<br>2. 继承<br>木有继承，用组合代替继承（组合匿名结构体，可直接在外部调用该结构体的方法，使用它的成员变量<br>3. 多态<br>用interface实现（只要实现了interface，就可以被用在适用于该接口的任何地方<br>4. 抽象 <br>无处不在","like_count":1},{"had_liked":false,"id":254630,"user_name":"Kingram","can_delete":false,"product_type":"c1","uid":2247700,"ip_address":"","ucode":"212E403E81F2FC","user_header":"https://static001.geekbang.org/account/avatar/00/22/4c/14/8fa39544.jpg","comment_is_top":false,"comment_ctime":1603160305,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5898127601","product_id":100039001,"comment_content":"1.Go语言支持多继承,为了防止多个父类的函数相同导致调用错误,可以使用子类对象.父类名.函数名的方式调用.<br>2.Go语言实现四大特性的机制如下:<br>1)封装:结构体内首字母大写字段可以对外暴露,包内首字母大写的函数和字段都可以对外暴露,小写则隐藏<br>2)继承:结构体内写父类名实现继承父类,实现接口的函数则继承接口<br>3)抽象:interface语法支持<br>4)多态:interface语法支持","like_count":1},{"had_liked":false,"id":248965,"user_name":"曙光","can_delete":false,"product_type":"c1","uid":1476450,"ip_address":"","ucode":"04D65BF7F19845","user_header":"https://static001.geekbang.org/account/avatar/00/16/87/62/f99b5b05.jpg","comment_is_top":false,"comment_ctime":1600392524,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5895359820","product_id":100039001,"comment_content":"思考题：<br>1 使用Java，没有多重继承，如果支持多重继承，那a1继承A1,b1，b1继承 A1，问a1和b1是兄弟关系还是父子关系（两层就乱了）。单继承就是避免这种层次不清的方法。<br>2  java有现成的语法支持四大特性。<br>封装：public, private, protect关键字,  <br>抽象：抽象类，抽象方法，编写函数<br>继承：继承类 extend ，实现接口 implements<br>多态：支持继承；父类引用指向子类对象；可重写（override）父类方法；","like_count":1},{"had_liked":false,"id":246776,"user_name":"WilliamVector","can_delete":false,"product_type":"c1","uid":1898112,"ip_address":"","ucode":"E0D3C3D4FCB7C9","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f6/80/85ec2c2a.jpg","comment_is_top":false,"comment_ctime":1599475639,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5894442935","product_id":100039001,"comment_content":"1、关于封装特性：封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。它需要编程语言提供权限访问控制语法来支持，例如 Java 中的 private、protected、public 关键字。封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。<br>2、关于抽象特性：封装主要讲如何隐藏信息、保护数据，那抽象就是讲如何隐藏方法的具体实现，让使用者只需要关心方法提供了哪些功能，不需要知道这些功能是如何实现的。抽象可以通过接口类或者抽象类来实现，但也并不需要特殊的语法机制来支持。抽象存在的意义，一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。<br>3、继承是用来表示类之间的 is-a 关系，分为两种模式：单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类。为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持。继承主要是用来解决代码复用的问题。<br>4、关于多态特性：多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类、duck-typing。多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。<br>【思考】<br>1、Java不支持多重继承，因为当两个父类中有同名方法时，会不知道调用哪一个。C++支持多继承，同名方法，C++可以通过::指定具体的类来避免歧义。<br>2、Java中的封装通过类的public、private、protected权限控制实现，抽象通过interface来实现，继承通过extends、implements来实现，多态通过interface和implements实现。C++中的封装通过类的public、private、protected权限控制实现，抽象通过包含虚函数(virtual)实现，继承通过:实现，多态通过继承和类型转换实现。","like_count":1},{"had_liked":false,"id":216951,"user_name":"刘同青","can_delete":false,"product_type":"c1","uid":1818343,"ip_address":"","ucode":"84B62DF8BC61FB","user_header":"","comment_is_top":false,"comment_ctime":1589375107,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5884342403","product_id":100039001,"comment_content":"<br><br><br><br>课后题：<br><br>你熟悉的编程语言是否支持多重继承？如果不支持，请说一下为什么不支持。如果支持，请说一下它是如何避免多重继承的副作用的。<br><br>java不支持多继承。为了防止菱形继承的副作用，假设支持多继承，B类和C类继承了A类，并重写方法 fun1()，那么如果D类同时继承了B类和C类，那么调用D类对象的方法fun1()时，是执行B类中的方法还是C类的方法呢？<br><br>C++支持多继承，可以在调用方法时指定父类以避免二义性，但是这种方式会降低方法的易用性。<br><br>学习笔记：抽象封装继承多态可以解决什么问题<br><br>1、封装<br><br>解释：信息隐藏或者数据访问保护，类通过暴露有限的访问接口，授权外部通过这些合理的接口对类进行访问。需要编程语言提供访问权限控制的语法，比如java提供private protected public<br><br>作用：相比可以对类的属性随意进行set来说，对类进行封装的优点是：<br><br>（1）易读。外部仅能通过有限的接口访问，而且一般还有明确的含义。<br><br>（2）易用。使用者不需要对所有属性都关注，而且要小心的set,，封装后可以大胆的调用。<br><br>（3）安全。如果随意修改，可能造成数据不一致。<br><br>2、抽象<br><br>解释：隐藏方法实现细节，调用者只需要关注方法有什么功能，不需要了解方法的实现。常常通过编程语言的接口类和抽象类来实现抽象，比如java中的interface接口类和abstract抽象类。实际上单纯的一个函数也是抽象，因为调用函数时不需要关注函数体，而只需要根据函数的注释了解其功能，然后就可以使用了。<br><br>作用：通过抽象可以屏蔽实现细节，使问题聚焦，是处理复杂问题的有效手段<br><br>注意：在定义类、接口或者命令函数的时候也要有抽象思维，名字不要暴露太多的实现细节，以提高名称的稳定性，以保证在未来改变方法实现逻辑的时候，名字不用变。<br><br><br><br>3、继承<br><br>解释：表示类之间 is a 的关系，java为了避免菱形问题所以仅仅支持单继承。<br><br>作用：代码复用。<br><br>注意点：继承层次过深，会导致代码的可读性可维护性变差，为了 了解一个子类的功能，不仅需要查看这个类，还需要按照继承关系一层一层的向上查看；子类和父类高度耦合，修改父类的代码会直接影响到子类。<br><br><br><br>4、多态<br><br>解释：父类变量可以指向子类对象，后者说接口变量可以指向实现类对象，通过继承+方法重写和接口+方法实现来实现多态。<br><br>作用：提高代码的扩展性和复用性。<br><br>（1）因为父类或者接口类一般都是比较抽象的，越抽象越远离具体实现的类或接口越稳定，所以客户端使用父类或者接口变量进行开发，而不去关注易变的具体子类或者接口实现类，这样在需要替换子类或者实现类的时候，不需要大动干戈的修改原有代码，这就是扩展性。<br><br>（2）如果一个方法的参数是抽象的父类或接口，那可以传入任意的子类对象或者接口实现类，让这个方法的复用性更好。<br><br>课后题","like_count":1,"discussions":[{"author":{"id":1459006,"avatar":"https://static001.geekbang.org/account/avatar/00/16/43/3e/960d12cb.jpg","nickname":"DY","note":"","ucode":"55536A524A99B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290949,"discussion_content":"那么多需要打印日志的类， 你需要new 多少个文件啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594647468,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203509,"user_name":"Geek_032104","can_delete":false,"product_type":"c1","uid":1298282,"ip_address":"","ucode":"25542A2348F99F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/G61OS6hibNG7iakUmXeKmcY5VtFWnPpywzjOcUCm3t0HsibCibm3jzLNbdvjKQ8G8WSIkicBiaqoCsvHibn3M7wV4YbrA/132","comment_is_top":false,"comment_ctime":1586223651,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5881190947","product_id":100039001,"comment_content":"抽象不只是隐藏方法细节。决定一个类里边应该具备哪些属性和方法，这也是抽象。","like_count":1},{"had_liked":false,"id":190274,"user_name":"Nick","can_delete":false,"product_type":"c1","uid":1921287,"ip_address":"","ucode":"64BBE005890845","user_header":"https://static001.geekbang.org/account/avatar/00/1d/51/07/b5a945b6.jpg","comment_is_top":false,"comment_ctime":1584625478,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879592774","product_id":100039001,"comment_content":"重新回顾了面向对象的4大特性，争哥讲的很透彻，值得反复阅读和理解，对于刚入职场的同学，面试的时候也很有帮助。","like_count":1},{"had_liked":false,"id":177530,"user_name":"nightn","can_delete":false,"product_type":"c1","uid":1026818,"ip_address":"","ucode":"39FC4FF0281637","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ab/02/8688abed.jpg","comment_is_top":false,"comment_ctime":1581411250,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5876378546","product_id":100039001,"comment_content":"结合本节内容谈谈 C++ 对四大特性的支持。<br>（1）C++ 对封装的支持。通过访问控制符（public, protected, private）实现了对 class 成员的封装。与 Java 不同的是，C++ 还允许对继承进行访问控制，支持 public 继承、protected 继承和 private 继承，从而将封装的场景从单一类扩展到整个继承体系。<br>（2）C++ 对抽象的支持。函数是最基本的抽象，此外，C++ 虽然不支持 interface，但一个只含纯虚函数的 class 就相当于 Java 中的一个接口类，利用它可以将一组公共操作抽象出来，由各个子类去完善实现细节。<br>（3）C++ 对继承的支持。C++ 支持多重继承，但如果不是非常必要，一般不推荐使用。多重继承的一个副作用是在菱形继承中，最底下的子类的实例会存放重复数据成员，造成存储空间浪费和二义性问题，C++ 使用了虚基类避免了这个问题。<br>（4）C++ 对多态的支持。通过虚函数机制实现多态，子类可以重写父类虚函数。该语法特性是由虚表虚指针实现的。","like_count":1},{"had_liked":false,"id":160928,"user_name":"万历十五年","can_delete":false,"product_type":"c1","uid":1122150,"ip_address":"","ucode":"3D8CF5DF847AE8","user_header":"https://static001.geekbang.org/account/avatar/00/11/1f/66/59e0647a.jpg","comment_is_top":false,"comment_ctime":1576062540,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5871029836","product_id":100039001,"comment_content":"“抽象”这一词并不是编程语言特有的，实际上我们在日常生活中每时每刻都在使用。<br>“抽象”就是对事物或事件的一个命名，是一种信息封装单元，它使人们传递信息更加方便，提高了沟通效率。<br>同时“抽象”也是有力度之分的，比如：<br>getUrl(), <br>getPicureUrl(),<br>getAliyunPictureUrl()<br>结合不同的业务场景，“抽象”力度的强弱就有了不同的适用范围。<br><br>","like_count":1},{"had_liked":false,"id":155939,"user_name":"被讨厌的勇气","can_delete":false,"product_type":"c1","uid":1547913,"ip_address":"","ucode":"AE3B3CA27D91A2","user_header":"https://static001.geekbang.org/account/avatar/00/17/9e/89/6e9c05d6.jpg","comment_is_top":false,"comment_ctime":1574780511,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869747807","product_id":100039001,"comment_content":"C++支持多重继承，C语言的设计宗旨有一条是相信程序员，而C++兼容C，也相信程序员，C++中虚继承来解决菱形继承问题。<br><br>C++提供访问权限控制来支持封装特性；C++中可以定义抽象类；支持单继承、多重继承；C++中，指向基类的指针或引用可以其派生类，且支持方法重写。<br><br>##坚持打卡##<br><br>封装（信息隐藏、数据保护），定义：类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或数据。语法机制：访问权限控制。作用：可维护性、易用性（降低心智负担）。示例，虚拟钱包。<br><br>抽象，平时所提到的抽象是指与具体事物关联比较少，如人名是一种抽象，从另一角度看，抽象可以隐藏具体实现。语法支持：抽象类、接口类、函数、命名（具有通用性，与具体事物关联少）。意义：可维护性、。示例，图片云存储。<br><br>继承，子类可以复用父类中的属性和方法，表示is-a关系。语法支持：C++中：，Java中extends。意义，代码复用。<br><br>多态，子类可以替换掉父类。语法支持：父类可以引用子类、继承、方法重写；接口类；动态语言中Duck Typing。意义：可扩展性、可复用性。示例，Array、Iterator。<br><br>争哥讲的清晰明了。","like_count":1},{"had_liked":false,"id":154385,"user_name":"zeta","can_delete":false,"product_type":"c1","uid":1255260,"ip_address":"","ucode":"AF84A72375827C","user_header":"https://static001.geekbang.org/account/avatar/00/13/27/5c/ee2a876f.jpg","comment_is_top":false,"comment_ctime":1574420398,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869387694","product_id":100039001,"comment_content":"\t第一，个人理解其实多重继承不存在技术问题（C++能实现且正常使用其他的肯定也可以实现且正常使用）。但是像JAVA这种标榜自己是纯面向对象语言的语言来说，多重继承是否实现is a的语义呢？拿一个C++中举的多重继承例子来说，吸血鬼分别继承自蝙蝠和人，那么吸血鬼is a蝙蝠么？吸血鬼is a人么？所以其实两个都不是，这就是设计上的语义问题。这里缺失了除了is a的另一个概念，behaves like，也就是多重继承的真义实际上是behaves like，也就是接口的意义。A vampire behaves like humans and bats. 而这是接口能多重的原因，一个类可以具有多重行为，但是不能是多种东西。<br>\t第二，最近学了Rust，结合说一下<br>\t\t封装：Rust有公共和私有方法<br>\t\t抽象：Rust 有基于Struct, Enum, Traits（类似抽象类和接口的结合体，可以多重继承，可以有抽象方法）的抽象，比较多样。<br>\t\t继承：Rust没有继承特性，只有实现Traits，提倡用组合代替继承<br>\t\t多态：Rust官方教程就提到过，Rust不支持多态，所以Rust不是一个严格意义上的面向对象语言。但其实Rust有迂回的办法达成这个，类似duck-typing。","like_count":1},{"had_liked":false,"id":153388,"user_name":"前端西瓜哥","can_delete":false,"product_type":"c1","uid":1248576,"ip_address":"","ucode":"150130C34CD1C1","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/40/f70e5653.jpg","comment_is_top":false,"comment_ctime":1574228747,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869196043","product_id":100039001,"comment_content":"1. javaScript。不支持多重继承。我觉得可能是因为语言定位原因：浏览器的简单脚本。所以js在设计时，语法要尽量简单，选择了单继承。另外 js 的继承还是简单的原型链继承。<br><br>2. javaScript。（1）封装，没有现成支持，不支持私有属性。js 要实现封装，目前方案也很多：命名约定、WeakMap、Symbol、闭包、Proxy、使用ts、# 声明（提案）（2）抽象，支持。（3）继承，支持原型链继承（4）多态，可以用继承，也可以用鸭子类型，某种意义上的面向方法编程，因为js是弱类型语言。","like_count":1},{"had_liked":false,"id":151953,"user_name":"王加武","can_delete":false,"product_type":"c1","uid":1665471,"ip_address":"","ucode":"DDCFE578C6C428","user_header":"https://static001.geekbang.org/account/avatar/00/19/69/bf/50a824a4.jpg","comment_is_top":false,"comment_ctime":1573820782,"is_pvip":false,"replies":[{"id":"60032","content":"是不一样的。我的意思是如果java语言中没有访问控制权限的语法，就是没有private、public、protected、default。。。这是一个假设...","user_name":"作者回复","comment_id":151953,"uid":"1190123","ip_address":"","utype":1,"ctime":1574854275,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"5868788078","product_id":100039001,"comment_content":"我学习的是JAVA<br>JAVA是不支持多继承的，<br>JAVA实现了封装，继承，多态，抽象等四大特性，是真正意义上的面向对象编程语言<br>我有一点疑惑，就您说的访问权限控制符那里，您说的“如果 Java 语言没有提供访问权限控制语法，所有的属性默认都是 public 的”，这恐怕是不对的吧，我在其他的教程上看到的是default,我也试了一下，确实是default.<br>因为default和public的权限是不一样的。<br>public:所有的类都可以访问<br>default:只有本身的类,子类，还有这个类所在的包中的所有的类可以访问<br>这两个的权限是不一样的！<br>这是我的疑惑，还请老师解释一下！","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474666,"discussion_content":"是不一样的。我的意思是如果java语言中没有访问控制权限的语法，就是没有private、public、protected、default。。。这是一个假设...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574854275,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151749,"user_name":"赵宇浩","can_delete":false,"product_type":"c1","uid":1102850,"ip_address":"","ucode":"571C1B03858F67","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/02/ad82f59a.jpg","comment_is_top":false,"comment_ctime":1573784744,"is_pvip":false,"replies":[{"id":"58345","content":"感觉还是一种数据驱动或者db驱动的设计思维方式。实际上，对于一些复杂业务逻辑的开发，db中数据的读和存只是很小的一部分。","user_name":"作者回复","comment_id":151749,"uid":"1190123","ip_address":"","utype":1,"ctime":1573786156,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"5868752040","product_id":100039001,"comment_content":"最近在探索DDD的时候有个问题，当涉及db或api时该怎么设计。<br>比如你上面提到的账户调增，理论上有个人的账户都会有个新的对象，但假如调增要调用api，那这个api需要这个账户类持有么？那每次创建对象还要set进去？感觉不是很舒服。。","like_count":1},{"had_liked":false,"id":151573,"user_name":"筱乐乐哦","can_delete":false,"product_type":"c1","uid":1307611,"ip_address":"","ucode":"AE92539F0419C3","user_header":"https://static001.geekbang.org/account/avatar/00/13/f3/db/5b7a8fd8.jpg","comment_is_top":false,"comment_ctime":1573741883,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5868709179","product_id":100039001,"comment_content":"哈哈，老师写的很好，多态那，我又去复习了下下jvm的加过程，感觉又进一步理解了，老师赶紧更新吧，饥渴难耐啊","like_count":1},{"had_liked":false,"id":151166,"user_name":"村长","can_delete":false,"product_type":"c1","uid":1218960,"ip_address":"","ucode":"AB8B2B79387D11","user_header":"https://static001.geekbang.org/account/avatar/00/12/99/90/ca2a8632.jpg","comment_is_top":false,"comment_ctime":1573659989,"is_pvip":false,"replies":[{"id":"58188","content":"😄 马上会讲到 如何用抽象类模拟接口","user_name":"作者回复","comment_id":151166,"uid":"1190123","ip_address":"","utype":1,"ctime":1573690531,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"5868627285","product_id":100039001,"comment_content":"cpp的虚基类都不加实现不就是接口么","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493965,"discussion_content":"不是重点,你自己研究研究吧😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594602856,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150987,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1015754,"ip_address":"","ucode":"00DF2FEC58D2E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","comment_is_top":false,"comment_ctime":1573638604,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5868605900","product_id":100039001,"comment_content":"这节课程虽然对于有编程经验的人来说很容易理解，但是读完后能感受到老师清晰的解读思路，赞！","like_count":1},{"had_liked":false,"id":150813,"user_name":"小喵喵","can_delete":false,"product_type":"c1","uid":1062444,"ip_address":"","ucode":"FDBBB2A59DB8B6","user_header":"https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg","comment_is_top":false,"comment_ctime":1573612999,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5868580295","product_id":100039001,"comment_content":"我们常常听到这样一句话：面向接口编程，而不是实现编码。我举例一下，原谅我拿阿猫阿狗举例<br> interface Animal<br>    {<br>        void Eat();<br>    }<br>    public class Dog : Animal<br>    {<br>        public void Eat()<br>        {<br>            &#47;&#47;print dog eat bone.<br>        }<br>    }<br>    public class Cat : Animal<br>    {<br>        public void Eat()<br>        {<br>            &#47;&#47;cat eat fish<br>        }<br>    }<br>    public class DemoTest<br>    {<br>        public  void Test()<br>        {<br>            &#47;&#47;接口来调用<br>            Animal dog = new Dog();<br>            dog.Eat();<br>            Animal cat = new Cat();<br>            cat.Eat();<br>            &#47;&#47;class来调用<br>            Dog dog = new Dog();<br>            dog.Eat();<br>            Cat cat = new Cat();<br>            cat.Eat();<br>        }<br>    }<br>我还是没有完全理解，觉得面向接口编程反而增加了更多的代码（比如单独定义interface Animal）。上端程序使用的时候也需要知道具体的Animal(比如 Animal dog = new Dog())。也是实例化一个Dog然后赋值给Animal的。为什么不觉得直接来使用Dog dog = new Dog()。这样还可以去掉Interface Animal了。","like_count":1,"discussions":[{"author":{"id":1691669,"avatar":"https://static001.geekbang.org/account/avatar/00/19/d0/15/5851180d.jpg","nickname":"一个无趣的俗人","note":"","ucode":"25435088B10CA2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377273,"discussion_content":"虽然可行，但不够简单。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622566697,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1147453,"avatar":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","nickname":"忆水寒","note":"","ucode":"E3F86BD8AA8903","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1691669,"avatar":"https://static001.geekbang.org/account/avatar/00/19/d0/15/5851180d.jpg","nickname":"一个无趣的俗人","note":"","ucode":"25435088B10CA2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377907,"discussion_content":"嗯，方法很多","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622958192,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":377273,"ip_address":""},"score":377907,"extra":""}]}]},{"had_liked":false,"id":150804,"user_name":"xavier","can_delete":false,"product_type":"c1","uid":1243128,"ip_address":"","ucode":"2F7918EA37ED9F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f7/f8/3c0a6854.jpg","comment_is_top":false,"comment_ctime":1573611914,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5868579210","product_id":100039001,"comment_content":"封装这里的解释，让我联想到 less is more 这句话。<br>less是对使用者而言。像封装一样，仅提供关键的方法给使用者。<br>more是对设计者而言。为了实现封装特性，封装内部会做大量处理。","like_count":1},{"had_liked":false,"id":150749,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1573606883,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5868574179","product_id":100039001,"comment_content":"设计模式05：<br>- Java不支持多继承，弊端之一的菱形问题就不赘述了，我认为多继承带来的另外一个问题就是复杂性的增加，我们在写程序之前，常常会按照**接口-&gt;抽象类-&gt;实现类-&gt;拓展实现类**这样的模式，这样设计出来的一组类是与某一个“业务”强相关的，如果可以多继承，以上流程就可以在任一环节继承其他一组类，这样的设计会造成更高的复杂性与耦合性，之后理解与维护的成本会更高。","like_count":1},{"had_liked":false,"id":360797,"user_name":"ipofss","can_delete":false,"product_type":"c1","uid":1018620,"ip_address":"上海","ucode":"DE3061C9259F9E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/fc/d1dd57dd.jpg","comment_is_top":false,"comment_ctime":1666858965,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1666858965","product_id":100039001,"comment_content":"面向对象的4大特性的深度解读，以后再面试时也不至于干巴巴的回答了，并且对于自己日常开发也加深了理解","like_count":0},{"had_liked":false,"id":360180,"user_name":"Geek_98ea8d","can_delete":false,"product_type":"c1","uid":3205000,"ip_address":"北京","ucode":"A535420E63F385","user_header":"","comment_is_top":false,"comment_ctime":1666256383,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1666256383","product_id":100039001,"comment_content":"太强了","like_count":0},{"had_liked":false,"id":359482,"user_name":"Will Zhang","can_delete":false,"product_type":"c1","uid":3197012,"ip_address":"上海","ucode":"294B06E7EFEB18","user_header":"https://static001.geekbang.org/account/avatar/00/30/c8/54/8d27cb56.jpg","comment_is_top":false,"comment_ctime":1665566790,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665566790","product_id":100039001,"comment_content":"python<br>封装：没有硬性要求，而是一种约定<br>没用_标记的一般都是公开属性和公开方法<br>前面有_的属性和方法被认为是受保护的，可以直接修改<br>前面有__的属性和方法也被认为是受保护的，不能直接修改，但是可以通过一些手段修改<br>前面和后面都有__的方法是内部方法，一般不让用<br>继承：支持多继承，使用MRO列表解决菱形问题<br>python通过C3算法生成一个MRO列表，如果当期类的名称空间没有该属性时会去依次查找MRO列表的下一个元素的名称空间，通过该方法实现继承的代码复用。<br>多态：<br>python为什么支持不继承相同父类的多态（python叫鸭子类型）<br>python是动态语言，一切皆对象，python不管一个变量到底是什么类型，因为它可以是任何类型，当程序运行到这一步的时候就看一下它有没有这个方法或属性，有就调用，没有就报错，就这么拽。","like_count":0},{"had_liked":false,"id":357614,"user_name":"陈威洋","can_delete":false,"product_type":"c1","uid":2264679,"ip_address":"广东","ucode":"DCF84B4D3A7354","user_header":"https://static001.geekbang.org/account/avatar/00/22/8e/67/afb412fb.jpg","comment_is_top":false,"comment_ctime":1663487168,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663487168","product_id":100039001,"comment_content":"那么为什么Java不支持 多继承？<br>这就是“多继承的钻石问题”。<br>类 B 和类 C 继承自类 A，且都重写了类 A 中的同一个方法，而类 D 同时继承了类 B 和类 C，那么此时类 D 会继承 B、C 的方法，那对于 B、C 重写的 A 中的方法，类 D 会继承哪一个呢？这就是 多继承 会导致这种有歧义的情况存在。","like_count":0},{"had_liked":false,"id":355931,"user_name":"Stay_Gold","can_delete":false,"product_type":"c1","uid":1119904,"ip_address":"北京","ucode":"ACB8DCD2EF8F95","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJRCtuJkpyy2NTTABPFibg2k9tZscOOKx9wu80a85d5HspCorO9Nibj7Z7q9v1icPTVm5ia52r0RCzEaA/132","comment_is_top":false,"comment_ctime":1661856736,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661856736","product_id":100039001,"comment_content":"先总结一下今天学到的知识<br>1.封装：封装是对实现细节的隐藏，可以是提高代码的安全性和易用性。<br>2.抽象：抽象是对对象特征的提取，在不同的层次有不同的抽象。抽象和封装的区别是抽象是提取共性，封装是隐藏细节。<br>3.继承：继承是is...a关系，即是什么东西是什么的关系，可以提高代码的可复用性。<br>4.多态：多态是父类能直接指向子类的引用地址，可以提高代码的可扩展性和复用性。<br>问题<br>一.你熟悉的编程语言是否支持多重继承？如果不支持，请说一下为什么不支持。如果支持，请说一下它是如何避免多重继承的副作用的。<br>我个人比较熟悉的是c#和java，都是不支持对类的多重继承的，只支持接口的多重继承。我想不支持的原因，还是觉得多重继承，不管是调用方法还是实现多态特性的时候都容易产生歧义，不知道具体去执行那个实例或者方法。或者说需要很多额外的工作去保证避免这些场景。<br><br>二.你熟悉的编程语言对于四大特性是否都有现成的语法支持？对于支持的特性，是通过什么语法机制实现的？对于不支持的特性，又是基于什么原因做的取舍？<br>熟悉的后端语言：c# java,都支持面向对象的四大特性，实现的机制如下<br>封装：通过访问权限的控制来实现的。<br>抽象：抽象可以说通过接口或者抽象类来实现，也可以说语言本身其实都是有抽象特性的。<br>继承：继承的实现原理应该还是通过继承关键字把两者的引用地址关联起来了<br>多态：多态是继承+重写+父类能指向子类的引用<br>","like_count":0,"discussions":[{"author":{"id":1388018,"avatar":"https://static001.geekbang.org/account/avatar/00/15/2d/f2/07b94d3c.jpg","nickname":"养成好习惯","note":"","ucode":"7919C9592E2B2C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568952,"discussion_content":"php属于静态方式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651280071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351741,"user_name":"R","can_delete":false,"product_type":"c1","uid":2172520,"ip_address":"","ucode":"3721FC8C8DE174","user_header":"https://static001.geekbang.org/account/avatar/00/21/26/68/b86dc4df.jpg","comment_is_top":false,"comment_ctime":1658143014,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1658143014","product_id":100039001,"comment_content":"本节的案例都实现了一遍，源码如下：<br>https:&#47;&#47;gitee.com&#47;RingoTangs&#47;java-review&#47;tree&#47;master&#47;design-pattern&#47;part01&#47;src&#47;main&#47;java&#47;com&#47;nssc&#47;design","like_count":0},{"had_liked":false,"id":350950,"user_name":"SICUN","can_delete":false,"product_type":"c1","uid":1254261,"ip_address":"","ucode":"22A384904EB9E9","user_header":"https://static001.geekbang.org/account/avatar/00/13/23/75/2b599841.jpg","comment_is_top":false,"comment_ctime":1657385366,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657385366","product_id":100039001,"comment_content":"1. php不支持多继承，如果多继承时子类调用多个父类都有方法时会产生模凌两可的状况，感觉多继承收益和需要处理的付出不是很划算，可通过实现多个接口或者trait实现类似多继承的效果<br>2.php支持四大特性：<br>封装：public protected private<br>抽象：interface，abstract<br>继承：extend<br>多态：继承，方法覆盖，父类子类可互相调用，后期静态绑定","like_count":0},{"had_liked":false,"id":349508,"user_name":"三生","can_delete":false,"product_type":"c1","uid":1606669,"ip_address":"","ucode":"1DE1A2693A5E33","user_header":"https://static001.geekbang.org/account/avatar/00/18/84/0d/4e289b94.jpg","comment_is_top":false,"comment_ctime":1656031249,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1656031249","product_id":100039001,"comment_content":"python没有接口，而是采用多继承和抽象类来代替接口，多继承也是一种代码复用的方式","like_count":0},{"had_liked":false,"id":345725,"user_name":"姚钫","can_delete":false,"product_type":"c1","uid":1498146,"ip_address":"","ucode":"ECB8B0627A4F9B","user_header":"https://static001.geekbang.org/account/avatar/00/16/dc/22/41a390ae.jpg","comment_is_top":false,"comment_ctime":1652526216,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652526216","product_id":100039001,"comment_content":"220513 day04 四大特性<br>1.存在的意义和目的,解决了哪里编程问题<br>what&#47;how&#47;why<br>封装是对数据提供必要的操作接口，屏蔽可能能出现的异常，保证安全<br>继承解决代码复用<br>多态是对未来代码依旧可用<br>抽象是对场景业务及很多场景以及现实世界的抽象<br>q:你熟悉的编程语言是否支持多重继承？如果不支持，请说一下为什么不支持。如果支持，请说一下它是如何避免多重继承的副作用的。<br>a:不支持,因为如果继承的两个类都是非抽象的类并且方法也是非抽象的,子类调用父类方法的时候不知道用谁的, C++好像支持,需要强制重写两个父类共有的方法<br>q:你熟悉的编程语言对于四大特性是否都有现成的语法支持？对于支持的特性，是通过什么语法机制实现的？对于不支持的特性，又是基于什么原因做的取舍？<br>a:我熟悉的是Java,这四大特性都有,语法机制:封装是通过关键字private protect和public,抽象是abstract,继承和实现是extends和implements,多态是利用继承或实现来实现父类引用指向子类对象","like_count":0},{"had_liked":false,"id":342153,"user_name":"myfff","can_delete":false,"product_type":"c1","uid":1223008,"ip_address":"","ucode":"71C5ACC21816F2","user_header":"https://static001.geekbang.org/account/avatar/00/12/a9/60/efaa1dee.jpg","comment_is_top":false,"comment_ctime":1650073260,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650073260","product_id":100039001,"comment_content":"对于 抽象 的运用，在有些文章中要求每个对象的行为描述尽量准确，也就是对象的方案命名尽量准确。而有时候我们认为适当的抽象能让方法有更强的通用和适应性(比如接口的覆盖场景变广后)。 不知道作者怎么看待这个问题","like_count":0},{"had_liked":false,"id":339776,"user_name":"八声甘州","can_delete":false,"product_type":"c1","uid":2019483,"ip_address":"","ucode":"BCE59119BEABBE","user_header":"https://static001.geekbang.org/account/avatar/00/1e/d0/9b/101cbd95.jpg","comment_is_top":false,"comment_ctime":1648375268,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1648375268","product_id":100039001,"comment_content":"go:<br>封装：变量名或方法名、函数名 首字母大写包内可见，反之不可见<br>抽象：接口（interface）类型<br>继承：结构体组合<br>多态：接口、ducktyping","like_count":0},{"had_liked":false,"id":338214,"user_name":"金旭","can_delete":false,"product_type":"c1","uid":1644194,"ip_address":"","ucode":"2FE7B4B8CE4A07","user_header":"https://static001.geekbang.org/account/avatar/00/19/16/a2/789d296e.jpg","comment_is_top":false,"comment_ctime":1647355009,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647355009","product_id":100039001,"comment_content":"golang这里应该属于课程中说的：接口类实现吧。<br>interface类型算是“接口类”，一个类需要实现接口类中定义的全部方法，那么该类的实例就可以赋值给接口类变量，接口类变量会调用相应类中的接口实现。<br>好处是：有了类似动态类型语言ducktyping的书写简洁性（避免了声明），又可以实现编译期间的静态检查-满足了安全性","like_count":0},{"had_liked":false,"id":331028,"user_name":"百炼钢","can_delete":false,"product_type":"c1","uid":1590695,"ip_address":"","ucode":"71A20C3C0B2978","user_header":"https://static001.geekbang.org/account/avatar/00/18/45/a7/da9b2d2b.jpg","comment_is_top":false,"comment_ctime":1642385355,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642385355","product_id":100039001,"comment_content":"新语言都没再提供复杂的封装（private, protected, default, public）了，比如 dart 就用 _ 前缀表示私有；钱包数据要保存到数据库，下次取出时还是要赋值，不给 id 赋值方法也不合理，当然在这篇讲解封装的文中是合适的；现在的语言更强调不可变：用 final , const 来修饰类属性，赋值之后就不再变化了。kotlin中创建的类都是默认final的，除非声明时提供 open 前缀，否则没法被继承。最近有学习dart和kotlin，有此感想……","like_count":0},{"had_liked":false,"id":324255,"user_name":"王智","can_delete":false,"product_type":"c1","uid":1337016,"ip_address":"","ucode":"37D2AD591C1AEC","user_header":"https://static001.geekbang.org/account/avatar/00/14/66/b8/ece79234.jpg","comment_is_top":false,"comment_ctime":1638349667,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1638349667","product_id":100039001,"comment_content":"第一题：<br>* java。不显式支持，但是可以通过内部类变相支持。 <br>* 不知道。大概是符合“单继承、多实现”吧。<br>第二题：<br>* java。都有。<br>* 封装：函数、访问控制修饰符实现；继承：extends关键字；多态：重写。","like_count":0},{"had_liked":false,"id":321672,"user_name":"Z宇锤锤","can_delete":false,"product_type":"c1","uid":2188142,"ip_address":"","ucode":"7DB36E986A7A51","user_header":"https://static001.geekbang.org/account/avatar/00/21/63/6e/6b971571.jpg","comment_is_top":false,"comment_ctime":1636987556,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1636987556","product_id":100039001,"comment_content":"面向对象四大块：抽象继承和多态，还有一个封装。<br>抽象：关注方法<br>继承：is a结构优美<br>多态：方法复用<br>封装：隔离外部环境","like_count":0},{"had_liked":false,"id":321278,"user_name":"探雪","can_delete":false,"product_type":"c1","uid":2833619,"ip_address":"","ucode":"2332650D9C8D54","user_header":"https://static001.geekbang.org/account/avatar/00/2b/3c/d3/fab9d588.jpg","comment_is_top":false,"comment_ctime":1636733645,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636733645","product_id":100039001,"comment_content":"自古评论出人才","like_count":0},{"had_liked":false,"id":318908,"user_name":"Geek_c46527","can_delete":false,"product_type":"c1","uid":2800355,"ip_address":"","ucode":"3C6008B6BC999F","user_header":"","comment_is_top":false,"comment_ctime":1635478542,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635478542","product_id":100039001,"comment_content":"封装：隐藏信息，保护数据，提供给定的统一方式去访问数据<br>抽象：隐藏方法的具体实现，提供调用者方法能解决什么问题<br>继承：is-a的一种关系，单继承和多继承，多继承会产生选择继承相同方法的选择问题，继承可以代码复用<br>多态：父类引用指向子类对象的操作，提高代码的扩展性，继承+方法重写或接口类实现","like_count":0},{"had_liked":false,"id":315729,"user_name":"刘博","can_delete":false,"product_type":"c1","uid":1992973,"ip_address":"","ucode":"F00AA3B3200BBE","user_header":"https://static001.geekbang.org/account/avatar/00/1e/69/0d/0a2fd71e.jpg","comment_is_top":false,"comment_ctime":1633955280,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633955280","product_id":100039001,"comment_content":"个人理解：封装是访问权限控制，定义类的时候通过暴露一些必要的修改函数，获取数据函数，保证类的稳定性以及易用性。继承提高代码复用，尽量少的去定义一些具有相同功能的类，但是多层继承会带来的问题就是继承关系薄弱，可能继承类与父类的相关度很低。抽象：增加类的扩展性。在不改动类定义的情况下丰富类的功能，进一步提升类的稳定性，健壮性。多态：通过實現接口，子类替换父类，通过不同的调用實現不同的功能，丰富类的功能。","like_count":0},{"had_liked":false,"id":315112,"user_name":"Geek_1","can_delete":false,"product_type":"c1","uid":2704407,"ip_address":"","ucode":"59300A73996D20","user_header":"https://static001.geekbang.org/account/avatar/00/29/44/17/e4fdcaad.jpg","comment_is_top":false,"comment_ctime":1633691266,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633691266","product_id":100039001,"comment_content":"JAVA是不支持多重继承的，定义了接口类来避免多重继承的副作用。<br>JAVA支持面向对象的四大特性。通过语言自身的特性来实现的，比如private pritected等关键字，和一些其他的语法","like_count":0},{"had_liked":false,"id":312948,"user_name":"阿昕","can_delete":false,"product_type":"c1","uid":1012906,"ip_address":"","ucode":"F3AD093B68E074","user_header":"https://static001.geekbang.org/account/avatar/00/0f/74/aa/178a6797.jpg","comment_is_top":false,"comment_ctime":1632135657,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1632135657","product_id":100039001,"comment_content":"Java支持多重继承，主要是为了维持语法上的简洁","like_count":0},{"had_liked":false,"id":312445,"user_name":"黄乔鑫","can_delete":false,"product_type":"c1","uid":1863174,"ip_address":"","ucode":"CBD0A8E5E99427","user_header":"https://static001.geekbang.org/account/avatar/00/1c/6e/06/bb43e716.jpg","comment_is_top":false,"comment_ctime":1631804134,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631804134","product_id":100039001,"comment_content":"四大特性<br>\t封装(Encapsulation)<br>\t\t通过暴露有限的访问接口，授权外部通过类的方式访问内部数据或者数据（通过修饰符private、protected、public控制）<br>\t\t保护数据不被随意修改、提高可维护性<br>\t\t提高类的易用性<br>\t抽象<br>\t\t关心方法提供什么功能，不关注实现方式（通过interface、abstract class实现）<br>\t\t提高代码可扩展性、维护性，修改实现不需要改变定义，减少改动范围<br>\t\t解决复杂系统，有效过滤不必要的关注信息<br>\t继承<br>\t\t表达类之间is-a的关系，比如Dog is a Animal，分为单继承、多继承<br>\t\t解决代码复用的问题<br>\t多态<br>\t\t指子类可以替代父类<br>\t\t继承、接口、duck-typing<br>\t\t提高代码的扩展性和复用性<br>","like_count":0},{"had_liked":false,"id":310628,"user_name":"张宗伟","can_delete":false,"product_type":"c1","uid":1374181,"ip_address":"","ucode":"1447A20C7A8982","user_header":"https://static001.geekbang.org/account/avatar/00/14/f7/e5/ec543f3b.jpg","comment_is_top":false,"comment_ctime":1630810762,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630810762","product_id":100039001,"comment_content":"就我熟悉的 js 来说：<br>1. 没有多继承。<br>2. 见代码：<br>&#47;&#47; 封装<br>function Encapsulation(name, age) {<br>  this.name = name;<br>  this.age = age;<br>  let address = &quot;xinyang&quot;;<br><br>  this.getAddress = function () {<br>    return address;<br>  };<br><br>  this.setAddress = function (addr) {<br>    address = addr;<br>  };<br><br>  this.write = function () {<br>    console.log(&quot;Encapsulation write.&quot;);<br>  };<br>}<br><br>&#47;&#47; 抽象<br>function abstraction(name) {<br>  console.log(&quot;Hello, Welcome &quot;, name, &quot;!&quot;);<br>}<br><br>&#47;&#47; 继承<br>&#47;&#47; 通过构造函数和原型链实现继承<br>function Inheritance(name, age) {<br>  Encapsulation.call(this, name, age);<br>  this.say = function () {<br>    console.log(this.name, &quot;is&quot;, this.age, &quot;in&quot;, this.getAddress());<br>  };<br>  this.write = function () {<br>    console.log(&quot;Inheritance write.&quot;);<br>  };<br>}<br>function Proxy() {}<br>Proxy.prototype = Encapsulation.prototype;<br>Inheritance.prototype = new Proxy();<br>Inheritance.prototype.constructor = Inheritance;<br><br>&#47;&#47; 多态<br>function polymorphism(obj) {<br>  obj.write();<br>}<br><br>&#47;&#47; test<br>const Encap1 = new Encapsulation(&quot;zzw&quot;, 27);<br>console.log(Encap1.getAddress());<br>Encap1.setAddress(&quot;henan&quot;);<br>console.log(Encap1.getAddress());<br><br>console.log(abstraction(&quot;zzw&quot;));<br><br>const Inher1 = new Inheritance(&quot;zzw&quot;, 26);<br>console.log(Inher1.say());<br><br>polymorphism(Encap1);<br>polymorphism(Inher1);","like_count":0},{"had_liked":false,"id":309039,"user_name":"贱贱的梦想","can_delete":false,"product_type":"c1","uid":1068326,"ip_address":"","ucode":"A3F7AF23D193AF","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/26/44095eba.jpg","comment_is_top":false,"comment_ctime":1629902674,"is_pvip":true,"discussion_count":0,"race_medal":4,"score":"1629902674","product_id":100039001,"comment_content":"总结的非常好，赞","like_count":0},{"had_liked":false,"id":308473,"user_name":"Geek_acfddd","can_delete":false,"product_type":"c1","uid":2734516,"ip_address":"","ucode":"455CF12A7CA6B8","user_header":"http://thirdwx.qlogo.cn/mmopen/uqaRIfRCAhIkBiaVBBgkKiaJmYC9JdeUQ7Y4XKyrPeLtNXgTHiaa3E3cibwTE8u2NjOwP9QF3icnlnVqnhCFEUz2ueYPrsCxKLKqy/132","comment_is_top":false,"comment_ctime":1629636668,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629636668","product_id":100039001,"comment_content":"有的人认为泛型语法也是一种多态，是连接时多态。<br>我认为也对，因为泛型实现了同一段代码调用多种不同类型的实例，提高代码复用性，这正是多态所要求的。<br>请问老师对泛型是否属于多态，以及泛型在设计原则中的应用有什么看法呢？","like_count":0},{"had_liked":false,"id":307123,"user_name":"小王在努力","can_delete":false,"product_type":"c1","uid":2733574,"ip_address":"","ucode":"A324EF87198905","user_header":"https://static001.geekbang.org/account/avatar/00/29/b6/06/cd1eaa49.jpg","comment_is_top":false,"comment_ctime":1628875662,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628875662","product_id":100039001,"comment_content":"打卡，收获很多，工作快一年了，看着一堆又一堆的代码难受啊。冲冲冲！！！","like_count":0},{"had_liked":false,"id":306548,"user_name":"Geek_842f07","can_delete":false,"product_type":"c1","uid":2698987,"ip_address":"","ucode":"ED772AF755FE7E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/WP4Ge8ABcINFkccKaNYKibicFnI0JAoojBBAUGrichNeRAgzm5RGbHG7GqYrFX3ELEzenuEbicQHJy2HZ72RxSOuMA/132","comment_is_top":false,"comment_ctime":1628604626,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628604626","product_id":100039001,"comment_content":"1.你熟悉的编程语言是否支持多重继承？如果不支持，请说一下为什么不支持。如果支持，请说一下它是如何避免多重继承的副作用的。<br>答：我熟悉的是C++，支持多重继承，多重继承的缺点是变得复杂，并且会出现二义性的问题，c++使用类名覆盖，同名覆盖来解决这个问题，但这也增加了编程的复杂性。<br>2.你熟悉的编程语言对于四大特性是否都有现成的语法支持？对于支持的特性，是通过什么语法机制实现的？对于不支持的特性，又是基于什么原因做的取舍？<br>答：在c++中，封装通过public, private, protected关键字来支持；抽象方面，C++可以定义抽象类，但并没有接口的直接语法支持；在继承方面，使用：语法支持，继承方式可以是公有继承或者私有继承；在多态方面可以通过抽象类来实现多态","like_count":0},{"had_liked":false,"id":304876,"user_name":"肖军","can_delete":false,"product_type":"c1","uid":2660080,"ip_address":"","ucode":"AC06B71DC7D8F0","user_header":"","comment_is_top":false,"comment_ctime":1627653682,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627653682","product_id":100039001,"comment_content":"mark","like_count":0},{"had_liked":false,"id":298442,"user_name":"Bumblebee","can_delete":false,"product_type":"c1","uid":2051293,"ip_address":"","ucode":"B879C8A511D08D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","comment_is_top":false,"comment_ctime":1624109484,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1624109484","product_id":100039001,"comment_content":"可以认为抽象也是封装的一种体现","like_count":0},{"had_liked":false,"id":298108,"user_name":"Geek_16c7da","can_delete":false,"product_type":"c1","uid":2661287,"ip_address":"","ucode":"5AC77B1062BF27","user_header":"","comment_is_top":false,"comment_ctime":1623915249,"is_pvip":false,"replies":[{"id":"108186","content":"你好，专栏是图文+音频哦，没有视频。","user_name":"编辑回复","comment_id":298108,"uid":"1501385","ip_address":"","utype":2,"ctime":1623919851,"user_name_real":"赵宇新"}],"discussion_count":1,"race_medal":0,"score":"1623915249","product_id":100039001,"comment_content":"小白，这个里面的课程都是语音，没有视频吗","like_count":0},{"had_liked":false,"id":288985,"user_name":"lobby","can_delete":false,"product_type":"c1","uid":1181960,"ip_address":"","ucode":"8D81722BE36AD4","user_header":"https://static001.geekbang.org/account/avatar/00/12/09/08/f3547e77.jpg","comment_is_top":false,"comment_ctime":1618809413,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618809413","product_id":100039001,"comment_content":"golang的多态好像也是duck- typing的形式，感觉现代一点的语言都是以此形式，不知好处或优势在哪里","like_count":0},{"had_liked":false,"id":284561,"user_name":"森林里的胖老虎","can_delete":false,"product_type":"c1","uid":2530946,"ip_address":"","ucode":"C93BA8F2885601","user_header":"https://static001.geekbang.org/account/avatar/00/26/9e/82/7758ab1c.jpg","comment_is_top":false,"comment_ctime":1616338470,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616338470","product_id":100039001,"comment_content":"java为啥不支持多重继承，因为如果多个父类，拥有同名的函数或者字段，那么子类在使用的时候，该去使用哪个，java支持多个接口的实现，首先实现和继承不一样，继承会把父类的所有的信息获取过来，实现只会获取自己想要的抽象方法，如果存在多个接口存在相同的抽象方法名，也没有关系，因为在接口中这些方法只是抽象方法，不具备任何逻辑","like_count":0},{"had_liked":false,"id":273822,"user_name":"刘立嘉","can_delete":false,"product_type":"c1","uid":2414637,"ip_address":"","ucode":"1241140EBE7FE3","user_header":"https://static001.geekbang.org/account/avatar/00/24/d8/2d/6ec3760c.jpg","comment_is_top":false,"comment_ctime":1610688376,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610688376","product_id":100039001,"comment_content":"封装、继承、多态，面向对象三要素，再加上抽象，四要素，构成面向对象的灵魂，深入融汇贯通，运用自如，超越编程技术，成为美学。","like_count":0},{"had_liked":false,"id":268456,"user_name":"焱","can_delete":false,"product_type":"c1","uid":1113301,"ip_address":"","ucode":"677BF1BE4B94D5","user_header":"https://static001.geekbang.org/account/avatar/00/10/fc/d5/1cf5fd56.jpg","comment_is_top":false,"comment_ctime":1608205093,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608205093","product_id":100039001,"comment_content":"java是单继承的吧，通过限定返回的数据类型大小来避免多爱民继承？<br>java实现四大特性的语法是extends和implements来实现的","like_count":0},{"had_liked":false,"id":268401,"user_name":"Geek_dd2917","can_delete":false,"product_type":"c1","uid":2294905,"ip_address":"","ucode":"CD347EA01D874A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/CTpxkU8vxyr7hhGT8yVZxgn1G75sjibFbTHibFAtMA3t2PfhTbZlUyXiaC4yblOGaeVy51lkLASGrzcwMDW0gAlcA/132","comment_is_top":false,"comment_ctime":1608177579,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608177579","product_id":100039001,"comment_content":"有一个点一直想不太明白，多态的问题不能在原类中扩展出不同实现方案的方法出来吗，具体什么场景使用什么方法，对原实现方法也不会去修改，请明白的童鞋指教。。。","like_count":0},{"had_liked":false,"id":262863,"user_name":"一位不愿透露姓名的码农","can_delete":false,"product_type":"c1","uid":1064047,"ip_address":"","ucode":"82A4281E8D8E62","user_header":"https://static001.geekbang.org/account/avatar/00/10/3c/6f/c4a0a38b.jpg","comment_is_top":false,"comment_ctime":1605862133,"is_pvip":false,"replies":[{"id":"96117","content":"嗯呢 ������","user_name":"作者回复","comment_id":262863,"uid":"1190123","ip_address":"","utype":1,"ctime":1606700907,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"1605862133","product_id":100039001,"comment_content":"duck-typing:两个类实现同一个方法，即可实现多态。","like_count":0,"discussions":[{"author":{"id":1951501,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/c7/0d/0dab398b.jpg","nickname":"好名字","note":"","ucode":"E2BFD96F912A67","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311141,"discussion_content":"第一后半句不全对，id自增器也是有状态的，但是应用场景就需要这种共用有状态的对象，这种场景不需要考虑线程安全。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602234912,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261020,"user_name":"Zachariah","can_delete":false,"product_type":"c1","uid":2229665,"ip_address":"","ucode":"B0AED2A3B91369","user_header":"https://static001.geekbang.org/account/avatar/00/22/05/a1/2c631e12.jpg","comment_is_top":false,"comment_ctime":1605174255,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605174255","product_id":100039001,"comment_content":"先举一个多重继承的例子，我们定义一个动物（类）既是狗（父类1）也是猫（父类2），两个父类都有“叫”这个方法。那么当我们调用“叫”这个方法时，它就不知道是狗叫还是猫叫了，这就是多重继承的冲突。 而java对此的解决方法是，一个物体的本质只能有一个。一个动物只能是狗或只能是猫，如果你想创造一个会玩毛线球会玩激光（被激光玩？）的狗，那么只需要创造一个描述这类行为的接口（就叫玩耍吧），然后在自己的类里面实现“玩耍”接口，具体实现这些玩的行为，最终你同样会得到一个既像狗又像猫的动物。如果你想让这个动物叫起来像猫而不是狗，那么使用覆写（override）机制，子类里重新定义“叫”这个行为即可。但是无论如何，这样得到的类是绝对不会有多重继承的冲突的。<br><br> 作者：Charlie W 链接：https:&#47;&#47;www.zhihu.com&#47;question&#47;24317891&#47;answer&#47;65289659 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","like_count":0},{"had_liked":false,"id":254345,"user_name":"晴天了","can_delete":false,"product_type":"c1","uid":1359669,"ip_address":"","ucode":"5310E02F8DF1F0","user_header":"https://static001.geekbang.org/account/avatar/00/14/bf/35/0e3a92a7.jpg","comment_is_top":false,"comment_ctime":1603102908,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603102908","product_id":100039001,"comment_content":"老师有个疑问.   多态 : (子类可以替换父类) 是否可以理解为子类依赖父类的抽象. ","like_count":0},{"had_liked":false,"id":252097,"user_name":"Mr_scx","can_delete":false,"product_type":"c1","uid":1239546,"ip_address":"","ucode":"28B5CE68A5A339","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKWiaZb7a2JAcIVlXYuZ3iaPfSF6vBbg3yUps6LKpsZarftyXufMHYKJmMKzH3bIpVkDAVNXE9q0oOw/132","comment_is_top":false,"comment_ctime":1602124367,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602124367","product_id":100039001,"comment_content":"&quot;如果 Java 语言没有提供访问权限控制语法，所有的属性默认都是 public 的&quot;，老师，关于这句话，我记得 Java中缺省修饰符和带 public修饰符的权限还不一样的呀","like_count":0},{"had_liked":false,"id":251421,"user_name":"呆瓜","can_delete":false,"product_type":"c1","uid":1655940,"ip_address":"","ucode":"C98C7B224D0640","user_header":"https://static001.geekbang.org/account/avatar/00/19/44/84/4da14994.jpg","comment_is_top":false,"comment_ctime":1601541394,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601541394","product_id":100039001,"comment_content":"c++首先引入的多重继承带来了诸如菱形继承一类的问题，而后为了解决这个问题又不得不引入了虚继承这种概念。然而在实际的应用中人们发现继承更多的只被用在两种场合：扩充&#47;改善基类，以及实现多态。对于前者，单继承足以；而对于后者，则真正需要的其实是纯抽象类，即只包含纯虚函数的基类。而对于这一种基类，由于其目的和普通的实例类已经有所不同，因此在java中将其改称为interface，即接口加以明确区分。因此，java或者c#所谓的不支持多重继承，只是不支持对实例类的多重继承——因为这种继承所带来的一点点代码上的缩减远比不上其引入的麻烦，但是对于用于实现多态的多重继承，即implement interface依然是很好的支持了的。<br><br><br>","like_count":0},{"had_liked":false,"id":250128,"user_name":"Zly","can_delete":false,"product_type":"c1","uid":1529196,"ip_address":"","ucode":"834C3FE84F2939","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/6c/896df6b6.jpg","comment_is_top":false,"comment_ctime":1600943485,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600943485","product_id":100039001,"comment_content":"c#不支持多重继承，需要的话把多出来类的定义成接口，是可以有多个接口的","like_count":0},{"had_liked":false,"id":247595,"user_name":"apollo_steve","can_delete":false,"product_type":"c1","uid":1708286,"ip_address":"","ucode":"754053D5957A94","user_header":"https://static001.geekbang.org/account/avatar/00/1a/10/fe/a46a5a06.jpg","comment_is_top":false,"comment_ctime":1599751057,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599751057","product_id":100039001,"comment_content":"C++支持多重继承；存在一个问题是a-&gt;b, a-&gt;c, b,c-&gt;d，这种情况下d会有两份a,采用虚继承可避免该问题；<br><br>支持封装 private public protected关键字<br>支持抽象 .h定义，.cpp实现，但没有接口类<br>支持继承 class A: public B;<br>支持多态：继承机制和虚拟函数表方法，并且父类指针可以只想子类对象","like_count":0},{"had_liked":false,"id":246429,"user_name":"张鉴","can_delete":false,"product_type":"c1","uid":1250837,"ip_address":"","ucode":"694D37E8D0BF4C","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/15/2dcd8e00.jpg","comment_is_top":false,"comment_ctime":1599322890,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599322890","product_id":100039001,"comment_content":"写的不对还请大家指正<br>golang <br>1.封装 <br>    通过struct和字段大小写实现<br>2.继承 <br>   不支持继承，通过组合的方式实现<br>3.抽象<br>   通过duck-typing隐式实现接口<br>4. 多态<br>   duck-typing","like_count":0},{"had_liked":false,"id":245717,"user_name":"宇天飞","can_delete":false,"product_type":"c1","uid":1126444,"ip_address":"","ucode":"3FB37D1E2DAA61","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/2c/06375913.jpg","comment_is_top":false,"comment_ctime":1599034482,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1599034482","product_id":100039001,"comment_content":"问题1：<br>1、不支持。java。<br><br>问题2：<br>1、有的。<br>抽象：函数、接口、类、包<br>封装：访问控制<br>继承：extends<br>多态：","like_count":0},{"had_liked":false,"id":245142,"user_name":"lin yu","can_delete":false,"product_type":"c1","uid":1126028,"ip_address":"","ucode":"3F2E0AF47750FE","user_header":"https://static001.geekbang.org/account/avatar/00/11/2e/8c/75936ae2.jpg","comment_is_top":false,"comment_ctime":1598844891,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598844891","product_id":100039001,"comment_content":"没有人发现多态demo的SortedDynamicArray类中 add方法要加super.add(e);么 还是我idea有问题。","like_count":0},{"had_liked":false,"id":240813,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1597073018,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597073018","product_id":100039001,"comment_content":"1 c++支持多重继承。多重继承存在的主要问题是菱形继承问题，c++通过虚继承的方式解决，但付出的代价是时间和空间上性能的损耗，空间上需要在类对象为虚基类安插多余的指针。时间上，需要经过多重指针解析访问虚基类数据<br>2 c++支持封装，继承，抽象，多态的特性","like_count":0,"discussions":[{"author":{"id":1115790,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erYC10qj8SliaHlueoKNiaWNQtPYSTLxJ2iafWSuUkXLJ75EXVbGWwibC4GExuaoEDqW3icIqMr2RcsE6Q/132","nickname":"pat","note":"","ucode":"C89570BF45F8E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":161178,"discussion_content":"那得生成多少文件啊\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580874239,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1115790,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erYC10qj8SliaHlueoKNiaWNQtPYSTLxJ2iafWSuUkXLJ75EXVbGWwibC4GExuaoEDqW3icIqMr2RcsE6Q/132","nickname":"pat","note":"","ucode":"C89570BF45F8E2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":161238,"discussion_content":"一般会使用线程池，数量可控","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580879647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":161178,"ip_address":""},"score":161238,"extra":""},{"author":{"id":1541669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/86/25/25ded6c3.jpg","nickname":"zhengyu.nie","note":"","ucode":"FFE0377D323E46","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212651,"discussion_content":"完全不可行，线程池隔离是最基本的，而且tomcat日志排查就可以直接gg了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584985914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":161238,"ip_address":""},"score":212651,"extra":""}]}]},{"had_liked":false,"id":240083,"user_name":"Ilearning99","can_delete":false,"product_type":"c1","uid":1989119,"ip_address":"","ucode":"7901836A2C47EF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/qOdqzmC507sibL6sichNSDaVmyoMKibEIqHWpic4CftgOQnoA3QKeRPwic9j1Ha8MLtzzqzfSRavR9GWMju09SMADUg/132","comment_is_top":false,"comment_ctime":1596759315,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596759315","product_id":100039001,"comment_content":"多重继承会存在歧义，java和c#都不支持多重继承，<br>java和c#对于四大特性都有支持，但是python不支持封装和","like_count":0},{"had_liked":false,"id":239356,"user_name":"双飞燕","can_delete":false,"product_type":"c1","uid":1727988,"ip_address":"","ucode":"D19A7ECD7EE630","user_header":"https://static001.geekbang.org/account/avatar/00/1a/5d/f4/fcf32e20.jpg","comment_is_top":false,"comment_ctime":1596509643,"is_pvip":false,"replies":[{"id":"89274","content":"不需要，重载是在一个类中多个重名函数","user_name":"作者回复","comment_id":239356,"uid":"1190123","ip_address":"","utype":1,"ctime":1597454573,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"1596509643","product_id":100039001,"comment_content":"老师，我看到有些文章把多态分为重写和重载，对于重载，需要有父子关系的依赖吗？有点疑惑","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503079,"discussion_content":"不需要，重载是在一个类中多个重名函数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597454573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239123,"user_name":"Happy—sea","can_delete":false,"product_type":"c1","uid":1624484,"ip_address":"","ucode":"4EAD3636164392","user_header":"https://static001.geekbang.org/account/avatar/00/18/c9/a4/66b606ad.jpg","comment_is_top":false,"comment_ctime":1596441252,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596441252","product_id":100039001,"comment_content":"多重继承的问题之前没有思考过，以前读书的时候只是记住了java面向对象的四大准则。现在想想java多继承会引发一些无法处理的问题。老师讲封装，抽象，继承，多态与实际的语法支持搭配讲解，以前是糊里糊涂的，现在清晰了很多。","like_count":0},{"had_liked":false,"id":238419,"user_name":"尾舟","can_delete":false,"product_type":"c1","uid":1002661,"ip_address":"","ucode":"6E3C3308B64F85","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4c/a5/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1596163471,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596163471","product_id":100039001,"comment_content":"对于语言来说重要的是表达力，所以为了实现duck type这种表达能力有的语言选择了多重继承一般是比较老的语言，对cpp来说多重继承就应该是一个基类和多个纯虚基类，后创建的语言发现这样实现容易用错，但同时要保留这种能力才有了java 的 interface之类的实现","like_count":0},{"had_liked":false,"id":238141,"user_name":"站在岸上的鱼","can_delete":false,"product_type":"c1","uid":2093578,"ip_address":"","ucode":"96C3D7B1772541","user_header":"https://static001.geekbang.org/account/avatar/00/1f/f2/0a/e10d198f.jpg","comment_is_top":false,"comment_ctime":1596079456,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596079456","product_id":100039001,"comment_content":"c#， java这些都是支持多重继承的，而为了避免类的多继承副作用，c#，java这些编程语言采用单类多接口的方法来支持多重继承。<br><br>c# 封装：通过访问控制修饰符；抽象：虚类，接口来实现；继承：类的单继承，接口的多继承；多态：父类和父接口可以引用子类的对象，子类可以重写父类或接口中的方法实现，类的继承。抽象类，虚方法，方法重写，方法重载","like_count":0},{"had_liked":false,"id":237689,"user_name":"何超","can_delete":false,"product_type":"c1","uid":1522691,"ip_address":"","ucode":"02C19C1A070315","user_header":"https://static001.geekbang.org/account/avatar/00/17/3c/03/ce032c4d.jpg","comment_is_top":false,"comment_ctime":1595926878,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595926878","product_id":100039001,"comment_content":"一直没理解多态，今天终于明白了。其实不止子类可以替代父类，这就限定继承了。例如调用接口，也可以存在多态。","like_count":0},{"had_liked":false,"id":234943,"user_name":"西电","can_delete":false,"product_type":"c1","uid":2063037,"ip_address":"","ucode":"95BD4CE9D93018","user_header":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","comment_is_top":false,"comment_ctime":1594839543,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594839543","product_id":100039001,"comment_content":"多继承方法重名时候的二意性问题","like_count":0},{"had_liked":false,"id":234752,"user_name":"歪歪在学习","can_delete":false,"product_type":"c1","uid":1618198,"ip_address":"","ucode":"889032C02D2D26","user_header":"https://static001.geekbang.org/account/avatar/00/18/b1/16/ba221660.jpg","comment_is_top":false,"comment_ctime":1594787365,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594787365","product_id":100039001,"comment_content":"java不支持多继承的原因是因为菱形问题。get","like_count":0},{"had_liked":false,"id":232140,"user_name":"sorationalist","can_delete":false,"product_type":"c1","uid":2012902,"ip_address":"","ucode":"4E2B3B3234E1C5","user_header":"https://static001.geekbang.org/account/avatar/00/1e/b6/e6/b2be4536.jpg","comment_is_top":false,"comment_ctime":1593870001,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593870001","product_id":100039001,"comment_content":"总结：1. 继承关系，公共功能可以实现代码的复用，然后重写父类方法来实现特殊业务的处理，场景，类之间必须是is-a关系，继承特性代码层次嵌套过深，难以维护。<br>2. 多态，继承或者接口以来实现，只要保证拥有相同的方法，不需要强制具有is-a关系。","like_count":0},{"had_liked":false,"id":228631,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1592757899,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592757899","product_id":100039001,"comment_content":"封装：保护数据，提供少量的属性和方法，易用，易维护。java中采用public，pritected default private四个关键词来控制类方法字段得访问权限。<br><br>抽象：隐藏方法的细节，使用者只需要关注方法的去参和结果即可。java中有接口和抽象类。<br><br>继承：方法复用。extends<br><br>多态：代码的扩展性。继承+接口或抽象类","like_count":0},{"had_liked":false,"id":228066,"user_name":"qiuyuan","can_delete":false,"product_type":"c1","uid":1745853,"ip_address":"","ucode":"B283F9281A9FC8","user_header":"https://static001.geekbang.org/account/avatar/00/1a/a3/bd/b28098c5.jpg","comment_is_top":false,"comment_ctime":1592547606,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592547606","product_id":100039001,"comment_content":"封装:<br>    我钱包里的钱我可以拿出来给你，你也可以拿给我我装进去，但你不能直接动我的钱包<br>抽象:<br>    存在又不存在的就是抽象的<br>继承:<br>    继承的本质是能力的复用<br>多态:<br>    不用说那么多，你就说你是不是xxx，是就行","like_count":0},{"had_liked":false,"id":226487,"user_name":"Chris Zou","can_delete":false,"product_type":"c1","uid":1897148,"ip_address":"","ucode":"B6DFC71C1DD8B7","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f2/bc/ffc7ad67.jpg","comment_is_top":false,"comment_ctime":1592120150,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592120150","product_id":100039001,"comment_content":"一：<br>C++语言支持多重继承，避免二义性副作用<br>1. 加类名限定符，指定具体类；<br>2. 子类同名覆盖，内部实现指定一个具体的类；<br>3. 虚基类，多重继承自有共同虚基类的类；<br>[参考博客](https:&#47;&#47;blog.csdn.net&#47;yang2011079080010&#47;article&#47;details&#47;51407144)<br><br>二：<br>封装：private、protected、public关键字<br>抽象：纯虚函数表示一个抽象接口，子类实现；<br>继承：&quot;:&quot;符号<br>多态：<br>静态多态：函数重载和泛型编程，发生在编译时期<br>动态多态：一种接口，多个虚函数实现，发生在运行期间。指针或者引用的父类对象，通过调用父类对象（指针类型或者引用类型）的虚函数来动态调用实际对象的虚函数方法。底层实现是每个类维系一个虚函数地址表，实际的类对象分配一个虚表指针来指向是父类还是子类的虚表，从而实现多态。<br>","like_count":0},{"had_liked":false,"id":220039,"user_name":"朝小树","can_delete":false,"product_type":"c1","uid":1323875,"ip_address":"","ucode":"18DC282DEF16C8","user_header":"https://static001.geekbang.org/account/avatar/00/14/33/63/2d48822a.jpg","comment_is_top":false,"comment_ctime":1590140032,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590140032","product_id":100039001,"comment_content":"多态：父类声明，子类实现，调用同名方法时，调用的是子类重写的方法。","like_count":0},{"had_liked":false,"id":219732,"user_name":"Geek_East","can_delete":false,"product_type":"c1","uid":1589947,"ip_address":"","ucode":"A1A7CBF9B8FB2D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXKSvfaeicog2Ficx4W3pNeA1KRLOS7iaFy2uoxCDoYpGkGnP6KPGecKia6Dr3MtCkNGpHxAzmTMd0LA/132","comment_is_top":false,"comment_ctime":1590071687,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1590071687","product_id":100039001,"comment_content":"核心目的: 无限拓展<br>- 最小化重复代码        (继承:  子类、抽象类、泛型)  -&gt; 拓展效率<br>- 最小化副作用           (封装)                                -&gt; 拓展前提<br>- 最大化传参类型      （多态：子类、接口类)           -&gt; 水平拓展<br>- 向上构建                 (抽象)                                -&gt; 垂直拓展<br>","like_count":0},{"had_liked":false,"id":219633,"user_name":"黄学尧","can_delete":false,"product_type":"c1","uid":1879994,"ip_address":"","ucode":"433DAF4232E784","user_header":"https://static001.geekbang.org/account/avatar/00/1c/af/ba/9be637d5.jpg","comment_is_top":false,"comment_ctime":1590053634,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590053634","product_id":100039001,"comment_content":"我的关注点比较奇特。。<br>猫是哺乳动物，不是爬行动物，哺乳动物和爬行动物是互斥的。","like_count":0},{"had_liked":false,"id":219183,"user_name":"超乎所以","can_delete":false,"product_type":"c1","uid":1705767,"ip_address":"","ucode":"AA1B387BCB5971","user_header":"https://static001.geekbang.org/account/avatar/00/1a/07/27/0e3b4e69.jpg","comment_is_top":false,"comment_ctime":1589962993,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589962993","product_id":100039001,"comment_content":"java 语言不支持多重继承。多重继承有菱形继承问题。类A有方法add(*),类B,类C都继承自类A,重写方法add(),类D继承自B,C，此时D调用add()方法时，调用的是哪个add()方法呢？","like_count":0},{"had_liked":false,"id":216924,"user_name":"方舟勇士","can_delete":false,"product_type":"c1","uid":1218162,"ip_address":"","ucode":"53D3D844B08B92","user_header":"https://static001.geekbang.org/account/avatar/00/12/96/72/a517bf25.jpg","comment_is_top":false,"comment_ctime":1589370064,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1589370064","product_id":100039001,"comment_content":"Grady Booch：抽象和封装是互补的概念：抽象关注的是对象可以观察到的行为，而封装关注这种行为的实现。封装通常是通过信息隐藏来实现的（不只是数据隐藏）。信息隐藏是将那些不涉及对象本质特征的秘密都隐藏起来的过程。通常，对象的结构是隐藏的，其方法的实现也是隐藏的。","like_count":0},{"had_liked":false,"id":216571,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1589286837,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589286837","product_id":100039001,"comment_content":"golang中的数据访问保护<br>package main<br>import &quot;fmt&quot;<br>type Foo struct {<br>  name string<br>}<br>&#47;&#47; Set方法<br>func (f *Foo) SetName(name string) {<br>  &#47;&#47; do  ....<br>  f.name = name<br>}<br>&#47;&#47; Get方法，只要把首字母大写。<br>func (f Foo) Name() string {<br>   &#47;&#47; do<br>    return f.name<br>}<br>func main() {<br>   p := Foo{}<br>   p.SetName(&quot;Abc&quot;)<br>   name := p.Name()<br>   fmt.Println(name)<br>}<br>HTTP Read时RequestJOSN反序列化为实体RequestXxx，HTTP Write时序列化ResponseXxx —&gt; ResponseJSON。这2个对象的属性必须包外可见。BO可以用数据访问保护","like_count":0},{"had_liked":false,"id":216569,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1589285757,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589285757","product_id":100039001,"comment_content":"封装：数据访问保护。<br>需要保护的属性声明为private xxx，通过getXxx(),setXxx()方法对属性进行中取值和赋值，方法内部可以对私有属性进行逻辑封装，保证数据不被恶意修改。好多通过工具生成空的get set方法，或者直接通过@Data注解完成get set方法，是对封装特性的破坏。","like_count":0},{"had_liked":false,"id":216526,"user_name":"师哥","can_delete":false,"product_type":"c1","uid":1333376,"ip_address":"","ucode":"A86CD1661D370F","user_header":"https://static001.geekbang.org/account/avatar/00/14/58/80/c9e232b6.jpg","comment_is_top":false,"comment_ctime":1589276939,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589276939","product_id":100039001,"comment_content":"封装  继承   抽象  多态  在大学学习的时候觉得自己知道了理解了，但是这么多年过去了感觉还是不能彻底理解。现在就彻底要整明白。<br>","like_count":0},{"had_liked":false,"id":215876,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1589123613,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589123613","product_id":100039001,"comment_content":"抽象就是先写作什么的代码，不写怎么做，抽象类和接口都是只管做什么，不管怎么做的代码。<br>对需求进行拆分(聚焦问题)、提纯(丢弃无关)、简化(不考虑如何实现建表，只考虑包含什么功能)。所以说通过接口很容易完成抽象工作，其次是抽象类需要写属性和部分函数逻辑。通过调用接口可以很容易把底层代码写完，然后再写接口实现，降低问题复杂度。接口就是方法的集合，没有实现，所以接口就是抽象。<br>在需求中抽象出类、基类、接口(func集合)。抽象时并没有考虑子类如何替换父类、底层调用高层(使用者)，不同的调用者可以实现多态。其实就是解决复杂问题的思维方法，只考虑做什么，不考虑怎么做。","like_count":0},{"had_liked":false,"id":215490,"user_name":"Zeng Shine","can_delete":false,"product_type":"c1","uid":1245334,"ip_address":"","ucode":"15D2618C92D662","user_header":"https://static001.geekbang.org/account/avatar/00/13/00/96/6df95326.jpg","comment_is_top":false,"comment_ctime":1589000431,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589000431","product_id":100039001,"comment_content":"想说一下自己对封装和抽象的理解。封装是一个动词，可以接不同的宾语。面向对象的封装特性是动词作名词用，完整的动宾结构应该是封装数据访问。抽象是指隐藏具体实现过程，暴露结果，这里的隐藏具体实现也算是封装，完整的动宾结构是封装实现。","like_count":0},{"had_liked":false,"id":215232,"user_name":"小马","can_delete":false,"product_type":"c1","uid":1490686,"ip_address":"","ucode":"92B7ECD23BDCB5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoXW5rycAcrNTwgOvib8poPXO0zvIekIPzBZJfsnciaLPIw9Q1t3rsXeH6DR24QndpYQibvibhR1tKHPw/132","comment_is_top":false,"comment_ctime":1588934292,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588934292","product_id":100039001,"comment_content":"看完文章，结合自己的理解，有以下的看法。<br>对于抽象，认为是一种编程思想，以JAVA为例，充分利用接口进行行为抽象，利用抽象类实现公有行为，子类实现具体细节。<br>对于封装应该是对数据项和行为两者的控制，我们只暴露最少的行为，对于具体细节实现进行封装，这样在外部使用时更加的简单易用，内部扩展封闭。<br>对于继承应该是对父类的重用，同时新增其他行为。多态则离不开继承，但是对于继承这里应该多考虑对抽象方法的多态实现或者是接口的多态实现，保证父类实现的重用性。","like_count":0},{"had_liked":false,"id":213491,"user_name":"注定非凡","can_delete":false,"product_type":"c1","uid":1113597,"ip_address":"","ucode":"80673056E131B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","comment_is_top":false,"comment_ctime":1588432254,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1588432254","product_id":100039001,"comment_content":"what<br>封装，抽象，继承，多态是一种思想理论，<br>封装：信息隐藏，数据访问保护<br>抽象：提取共同点，找到共同本质<br>继承：特征传递，能力沿用<br>多态：父类可以调用多个子类的能力<br>why<br>实现简洁，准确的语义，平衡机器执行效率和人类的理解能力  《信息论》<br>how<br>封装：依赖于编程语言提供特殊的控制权限语法<br>抽象：归纳共同特性，脱去个性化的特征<br>继承：依赖编程语言的语法实现<br>多态：配合继承共同服用","like_count":0},{"had_liked":false,"id":213242,"user_name":"妙子爸","can_delete":false,"product_type":"c1","uid":1433842,"ip_address":"","ucode":"988C1A7B9548F7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/hsxzhpId4k4uGK5CG534oLEIibqluVwOqgGqxFibILZDSia38gYOHflJDE1zfDVRGRIRq8sxdrAzWnvDP0eVDRMyQ/132","comment_is_top":false,"comment_ctime":1588339621,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588339621","product_id":100039001,"comment_content":"java没有多继承，原因可能是避免菱形集成的问题，子类不知道用哪个父类的成员变量，要重写很多不必要的方法。","like_count":0},{"had_liked":false,"id":212766,"user_name":"不靠谱的琴谱","can_delete":false,"product_type":"c1","uid":1243964,"ip_address":"","ucode":"D388EDFD6E5F8C","user_header":"https://static001.geekbang.org/account/avatar/00/12/fb/3c/e92d40f6.jpg","comment_is_top":false,"comment_ctime":1588208387,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588208387","product_id":100039001,"comment_content":"lua也是支持duck-typing的，这种用法写起来很快乐。","like_count":0},{"had_liked":false,"id":212014,"user_name":"Giacomo","can_delete":false,"product_type":"c1","uid":1478055,"ip_address":"","ucode":"BE5B1E68BCDBB3","user_header":"https://static001.geekbang.org/account/avatar/00/16/8d/a7/2176bbc5.jpg","comment_is_top":false,"comment_ctime":1588046474,"is_pvip":false,"replies":[{"id":"78923","content":"kitty也可以是一个子类呀 不一定是实例","user_name":"作者回复","comment_id":212014,"uid":"1190123","ip_address":"","utype":1,"ctime":1588129770,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"1588046474","product_id":100039001,"comment_content":"不知道是不是大家都这么写的，但我觉得is-a应该是例与类的关系，而不是继承吧。<br><br>比如 kitty is a cat. 表达的是kitty是一只cat，而不是说Kitty是猫的一个品种。","like_count":0,"discussions":[{"author":{"id":1455958,"avatar":"https://static001.geekbang.org/account/avatar/00/16/37/56/11068390.jpg","nickname":"倡印","note":"","ucode":"4F53AA5D017D89","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352004,"discussion_content":"unity开发者+1","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1614564542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":210596,"user_name":"张张先生","can_delete":false,"product_type":"c1","uid":1582951,"ip_address":"","ucode":"91B0E84B47AF05","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqrSGol9ss3nzh6Hqj2BYxBTlYbhSe72Og6Vx5CSb5iboibL9xZdWdYOpZzmN2ibj9EpboNDdRBSXSZw/132","comment_is_top":false,"comment_ctime":1587793987,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587793987","product_id":100039001,"comment_content":"课后作业：<br>工作中最常用的语言是JAVA，并不支持多继承，JAVA的定位就是简单的编程语言，舍弃了指针、多继承等特性，多继承主要的问题是菱形继承问题，也就是B和C继承了A，B和C均对A中的方法a()重写，如果这个时候D继承B和C且对方法a()不重写，那么这个时候D中的方法a()是来自于哪里","like_count":0},{"had_liked":false,"id":208902,"user_name":"李靖峰","can_delete":false,"product_type":"c1","uid":1139247,"ip_address":"","ucode":"AA4DE3E91A1FFA","user_header":"https://static001.geekbang.org/account/avatar/00/11/62/2f/6fe8ee9e.jpg","comment_is_top":false,"comment_ctime":1587461678,"is_pvip":false,"replies":[{"id":"78925","content":"嗯嗯 你说的没错 有些资料会区分 静态和动态 静态是重载","user_name":"作者回复","comment_id":208902,"uid":"1190123","ip_address":"","utype":1,"ctime":1588129957,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"1587461678","product_id":100039001,"comment_content":"老师，关于多态的部分细分的话还有静态多态和动态多态，前者用泛型实现","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500160,"discussion_content":"我建议你去看下极客的并发专栏😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594388254,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1809802,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/8a/a2d34896.jpg","nickname":"一元(wx:abley1874)","note":"","ucode":"5E7A33642FC767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291116,"discussion_content":"有一点要十分明确，工作内存将数据回写到主内存中，是Java层面的操作，而指令重排是cpu等底层的硬件操作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594710813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208101,"user_name":"Geek__93441785f6a2","can_delete":false,"product_type":"c1","uid":1450033,"ip_address":"","ucode":"03F5A9C37FF728","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLOCkhE6EF8dpnug21uHof7bu6YnM2gwEMDtdTtCPmRibKx4CUiass25UfMSwib8zJ7lwv8beYYXjLCA/132","comment_is_top":false,"comment_ctime":1587277324,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587277324","product_id":100039001,"comment_content":"这是我看过所有讲封装，抽象，继承，多态的文章中，讲的最清楚，最易懂的一篇，通过实例去分析每种特性的用法与用途","like_count":0},{"had_liked":false,"id":206056,"user_name":"盘尼西林","can_delete":false,"product_type":"c1","uid":1197347,"ip_address":"","ucode":"B59569FC25144F","user_header":"https://static001.geekbang.org/account/avatar/00/12/45/23/28311447.jpg","comment_is_top":false,"comment_ctime":1586781919,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586781919","product_id":100039001,"comment_content":"四大原则:<br>    封装: 对外界屏蔽内部的细节，保护成员<br>    抽象: 如果不能很好的封装那么一定是抽象的不够,需要往上继续抽象<br>    继承: 倾向于使用组合的形式，继承会有太多的依赖关系<br>    多态: 程序的拓展性和复用性，至少整体的代码&amp;&amp;逻辑结构是不会变的","like_count":0},{"had_liked":false,"id":202341,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1585971465,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1585971465","product_id":100039001,"comment_content":"抽象的作用：作者这里的所说的似乎是对基本概念的抽象，尽可能的把概念向上抽出，与实际编码中的抽象似乎并不是同一个东西。abstract和interface的实现机制，具体解决了什么问题呢？为什么会有抽象类这样的机制呢？这里并没有说清楚。比如，子类继承了抽象类，可以根据抽象类中定义的方法自己实现一套自己的逻辑。只是方法名与父类相同而已。凡是继承了这个抽象类的子类都拥有相关的方法，那这样的话，抽象基类就是一个统一方法或者接口的类。即这样可以提高代码的可维护性。","like_count":0},{"had_liked":false,"id":200602,"user_name":"Ray","can_delete":false,"product_type":"c1","uid":1604089,"ip_address":"","ucode":"3A66800D8E35D6","user_header":"https://static001.geekbang.org/account/avatar/00/18/79/f9/3cd59b29.jpg","comment_is_top":false,"comment_ctime":1585623358,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585623358","product_id":100039001,"comment_content":"个人观点：封装和抽象可以结合在一起使用，类似公共方法可能是这两大特性直观的表现<br>python支持多继承，但继承太多同样会有菱形继承的问题，super的存在可以解决一些但觉得比较混乱(应该是个人问题，有经验的大佬可以沟通一下)<br>从入行以来面向对象编程的特性一直没有特别清晰的认知，这算是再次刷新对概念的理解<br>加油啊，打好基础才能走的更远","like_count":0},{"had_liked":false,"id":200433,"user_name":"赵毅","can_delete":false,"product_type":"c1","uid":1905585,"ip_address":"","ucode":"28F6820F1987F6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIgDicRj9LAvWVyuibTbRnZDFeC6uWI8zfWU1gLM6yPoNklUaiar4TKxEyRHFibjIth3iahRNLcNvewjug/132","comment_is_top":false,"comment_ctime":1585583164,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585583164","product_id":100039001,"comment_content":"本章个人总结：<br>1、注意当前类属性是不是可以set？谁可以set<br>2、当前类、方法、属性谁可以有访问权shi限<br>3、命名不要暴露太多细节，特别是public函数，如果有一天内容改了，命名是否也要改<br>4、利用组合，不用继承<br>c#为什么不支持多重继承：<br>我觉得可以实现但其实编程语言开发者是为了减少复杂性，面向接口编程而不是面向对象编程<br>多重继承可以利用多个接口来实现","like_count":0},{"had_liked":false,"id":197769,"user_name":"屴","can_delete":false,"product_type":"c1","uid":1406688,"ip_address":"","ucode":"512BDF75C5BEDA","user_header":"https://static001.geekbang.org/account/avatar/00/15/76/e0/95be78a9.jpg","comment_is_top":false,"comment_ctime":1585397639,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585397639","product_id":100039001,"comment_content":"封装如何保证对象的线程安全？","like_count":0},{"had_liked":false,"id":197739,"user_name":"面向百度编程","can_delete":false,"product_type":"c1","uid":1732780,"ip_address":"","ucode":"8FE04A019D71D1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","comment_is_top":false,"comment_ctime":1585396211,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585396211","product_id":100039001,"comment_content":"java不支持多继承，支持多实现，首先我想说一下java的多太的前提就是继承，如果子类要运行父类的方法，如果子类没有重写的化，那么子类将会往父类寻找方法，如果说有两个父类都实现了同一个方法，那么到底该调用哪个方法呢，很显然做不到精准，需要决策，但是支持多实现，因为其父类都没有具体实现方法，根本不需要决策，而是将来需要的时候进行动态决策，而在java8中突然引入了默认实现，我认为其一是为了 新特性的向下兼容，同时默认实现如果子类调用两个父类都有的方法的化，同样会冲突，不知道到底调用那个，只时候，可以通过 组合来实现控制具体调用哪个类的方法，类似于适配器，代理，模式","like_count":0},{"had_liked":false,"id":197729,"user_name":"面向百度编程","can_delete":false,"product_type":"c1","uid":1732780,"ip_address":"","ucode":"8FE04A019D71D1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","comment_is_top":false,"comment_ctime":1585395531,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585395531","product_id":100039001,"comment_content":"关于java不支持多继承问题，之前在深入理解java虚拟机看到过，父类的索引（除了object外）只有一个，而父类的索引对应着这个类的全限定类名。父类索引是由常量池的常量项结构表总成的，类似于数据库中的数据表，u2字段表示，父类索引","like_count":0},{"had_liked":false,"id":197630,"user_name":"这得从我捡到一个鼠标垫开始说起","can_delete":false,"product_type":"c1","uid":1272321,"ip_address":"","ucode":"2FF4347B4E7A9B","user_header":"https://static001.geekbang.org/account/avatar/00/13/6a/01/d9cb531d.jpg","comment_is_top":false,"comment_ctime":1585388775,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585388775","product_id":100039001,"comment_content":"1 java 不支持，个人认为多重继承会让代码的可读性变差，继承关系变得复杂<br>2 java在语法层面全都支持","like_count":0},{"had_liked":false,"id":197155,"user_name":"桂冠远航","can_delete":false,"product_type":"c1","uid":1155463,"ip_address":"","ucode":"5959E1A1DAA05D","user_header":"https://static001.geekbang.org/account/avatar/00/11/a1/87/259ab5a3.jpg","comment_is_top":false,"comment_ctime":1585360819,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585360819","product_id":100039001,"comment_content":"博大精深，常看常新。","like_count":0},{"had_liked":false,"id":196695,"user_name":"木白","can_delete":false,"product_type":"c1","uid":1194009,"ip_address":"","ucode":"BEC459430B293C","user_header":"https://static001.geekbang.org/account/avatar/00/12/38/19/c8d72c61.jpg","comment_is_top":false,"comment_ctime":1585303291,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585303291","product_id":100039001,"comment_content":"猫并不是爬行动物吧，哈哈，非杠，只是读到了就说一下","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495573,"discussion_content":"好像jdk5之后就解决了，我有点记不清了😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594388592,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1809802,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/8a/a2d34896.jpg","nickname":"一元(wx:abley1874)","note":"","ucode":"5E7A33642FC767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291117,"discussion_content":"糟了，估计争哥搞错了，jdk1.5后才实现了volatile禁止指令重排特性","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1594710969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1613052,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9c/fc/0aa200b5.jpg","nickname":"Java课代表","note":"","ucode":"F17E4A1807FB12","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1809802,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/8a/a2d34896.jpg","nickname":"一元(wx:abley1874)","note":"","ucode":"5E7A33642FC767","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292480,"discussion_content":"有可能记错了，我也是为了这个问题深挖留言区","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595240695,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":291117,"ip_address":""},"score":292480,"extra":""},{"author":{"id":1113744,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fe/90/19ef108d.jpg","nickname":"techwro","note":"","ucode":"7AF2B319F0AE1B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1809802,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/8a/a2d34896.jpg","nickname":"一元(wx:abley1874)","note":"","ucode":"5E7A33642FC767","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301494,"discussion_content":"我怀疑是的，之前问了争哥也没回我","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598540508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":291117,"ip_address":""},"score":301494,"extra":""}]},{"author":{"id":1112183,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f8/77/a6d34ca5.jpg","nickname":"jackie","note":"","ucode":"01A4B7839CFABD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300922,"discussion_content":"挖了评论区，在找是jdk哪个版本解决这个问题~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598320131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1113744,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fe/90/19ef108d.jpg","nickname":"techwro","note":"","ucode":"7AF2B319F0AE1B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1112183,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f8/77/a6d34ca5.jpg","nickname":"jackie","note":"","ucode":"01A4B7839CFABD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301493,"discussion_content":"老哥搞清楚了吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598540461,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":300922,"ip_address":""},"score":301493,"extra":""},{"author":{"id":1112183,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f8/77/a6d34ca5.jpg","nickname":"jackie","note":"","ucode":"01A4B7839CFABD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1113744,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fe/90/19ef108d.jpg","nickname":"techwro","note":"","ucode":"7AF2B319F0AE1B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310350,"discussion_content":"应该是记错了，jdk1.5后才实现了volatile禁止指令重排特性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601792032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301493,"ip_address":""},"score":310350,"extra":""}]}]},{"had_liked":false,"id":194639,"user_name":"Cutler","can_delete":false,"product_type":"c1","uid":1228136,"ip_address":"","ucode":"2EDECFE039845B","user_header":"https://static001.geekbang.org/account/avatar/00/12/bd/68/3fd6428d.jpg","comment_is_top":false,"comment_ctime":1585094628,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585094628","product_id":100039001,"comment_content":"熟悉的语言java c# go都不支持多重继承，其中go只支持组合，个人认为多重继承如果多个父类有相同的字段或方法会冲突，从而带来不确定性，不知道是不是这个原因。","like_count":0},{"had_liked":false,"id":193827,"user_name":"墨鱼","can_delete":false,"product_type":"c1","uid":1022720,"ip_address":"","ucode":"8FB5E4DCB8A024","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/00/654be3f7.jpg","comment_is_top":false,"comment_ctime":1584971112,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584971112","product_id":100039001,"comment_content":"1.js 不支持多重继承，具体原因这个文章讲的不错 https:&#47;&#47;juejin.im&#47;entry&#47;5ac46b6c5188255570063b71<br><br><br>2.js四大特性都可以实现<br>封装是：仅仅暴露有限的接口，达到数据访问保护的功能。可以在函数里面声明变量，然后外面的是获取不到，也就改写不了。但是需要的话也可以 return 出去。<br><br>抽象：只关注功能点，而不关注具体的实现方法。比如我写一个函数，功能是把一个数组里面符合特定条件的数组筛选出来。我使用这个函数，不需要关心具体的过滤过程。我只需要结果。<br><br>继承: 就是子类继承父类的属性。单继承是子类只继承父类的属性。多继承是一个子类继承了多个父类的属性。<br><br><br>多态：子类可以替换父类的方法，在代码执行时，调用不同的子类方法。有利于代码的维护和扩展。JS 是无状态的语言，天生支持多态。通过原型或者类的方式实现<br><br><br>","like_count":0},{"had_liked":false,"id":193362,"user_name":"默片。","can_delete":false,"product_type":"c1","uid":1473606,"ip_address":"","ucode":"1D6D6456901E1E","user_header":"https://static001.geekbang.org/account/avatar/00/16/7c/46/019a6b9b.jpg","comment_is_top":false,"comment_ctime":1584890979,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584890979","product_id":100039001,"comment_content":"关于duck-typing，在cpp中其实用template也能实现，并且可以在编译期检查其正确性。","like_count":0},{"had_liked":false,"id":191389,"user_name":"不学不行啊","can_delete":false,"product_type":"c1","uid":1335474,"ip_address":"","ucode":"69368165141C2D","user_header":"https://static001.geekbang.org/account/avatar/00/14/60/b2/ccebcb71.jpg","comment_is_top":false,"comment_ctime":1584769512,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584769512","product_id":100039001,"comment_content":"继承是用来表示类之间的 is-a 关系，分为两种模式：单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类。为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持。继承主要是用来解决代码复用的问题","like_count":0},{"had_liked":false,"id":191388,"user_name":"不学不行啊","can_delete":false,"product_type":"c1","uid":1335474,"ip_address":"","ucode":"69368165141C2D","user_header":"https://static001.geekbang.org/account/avatar/00/14/60/b2/ccebcb71.jpg","comment_is_top":false,"comment_ctime":1584769503,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584769503","product_id":100039001,"comment_content":"多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类、duck-typing。多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。","like_count":0},{"had_liked":false,"id":191387,"user_name":"不学不行啊","can_delete":false,"product_type":"c1","uid":1335474,"ip_address":"","ucode":"69368165141C2D","user_header":"https://static001.geekbang.org/account/avatar/00/14/60/b2/ccebcb71.jpg","comment_is_top":false,"comment_ctime":1584769494,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584769494","product_id":100039001,"comment_content":"封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。它需要编程语言提供权限访问控制语法来支持，例如 Java 中的 private、protected、public 关键字。封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。","like_count":0},{"had_liked":false,"id":191384,"user_name":"不学不行啊","can_delete":false,"product_type":"c1","uid":1335474,"ip_address":"","ucode":"69368165141C2D","user_header":"https://static001.geekbang.org/account/avatar/00/14/60/b2/ccebcb71.jpg","comment_is_top":false,"comment_ctime":1584769172,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584769172","product_id":100039001,"comment_content":"     封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。","like_count":0},{"had_liked":false,"id":189843,"user_name":"索旭东","can_delete":false,"product_type":"c1","uid":1139039,"ip_address":"","ucode":"BFD07BCD8C8CAE","user_header":"https://static001.geekbang.org/account/avatar/00/11/61/5f/b279daaf.jpg","comment_is_top":false,"comment_ctime":1584576618,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584576618","product_id":100039001,"comment_content":"上节课刚说抽象可能不是面向对象特有的，老师就这节课解惑了","like_count":0},{"had_liked":false,"id":186364,"user_name":"Conny","can_delete":false,"product_type":"c1","uid":1869997,"ip_address":"","ucode":"18E6CEAEE5E038","user_header":"https://static001.geekbang.org/account/avatar/00/1c/88/ad/0bb5a9a5.jpg","comment_is_top":false,"comment_ctime":1583830226,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583830226","product_id":100039001,"comment_content":"在学习这个之前已经懂前三种特性，但一直对多态特性有点模糊，所以学习后我想着重谈一下自己对多态特性的理解：<br>什么是多态？<br>个人理解，多态就是支持一个类的方法重写，重点在重写，从而实现代码的扩展和复用。<br>怎么实现多态？<br>利用继承、接口类、duck-typing类来实现。<br>继承类？<br>子类继承父类，并在内部重新改写某个父类的方法。调用的是子类的方法。<br>duck-typing类？<br>不同类只要拥有相同的方法（名字），就可以在某个包含这个方法的函数中，调用这些类的方法。由于不同类的方法有些不同，这就实现了多态。<br>接口类？<br>接口类似于搭建了（不专业地讲）一个中间的桥梁、（中二地讲）一个目录样式的激活器。可以在同一个函数中使用包含这个接口的不同类，从而实现调用其方法的目的。个人理解，接口类有点像在duck-typing类的基础上，给不同类加上了某种联系。","like_count":0},{"had_liked":false,"id":186026,"user_name":"冲鸭","can_delete":false,"product_type":"c1","uid":1115945,"ip_address":"","ucode":"0EF69B02188A73","user_header":"https://static001.geekbang.org/account/avatar/00/11/07/29/e5537b9e.jpg","comment_is_top":false,"comment_ctime":1583743958,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583743958","product_id":100039001,"comment_content":"java默认访问权限不是public吧","like_count":0},{"had_liked":false,"id":184806,"user_name":"hiwangqi","can_delete":false,"product_type":"c1","uid":1670440,"ip_address":"","ucode":"E5FAC94609A08F","user_header":"https://static001.geekbang.org/account/avatar/00/19/7d/28/0368cf29.jpg","comment_is_top":false,"comment_ctime":1583410087,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583410087","product_id":100039001,"comment_content":"讲的很好学习了","like_count":0},{"had_liked":false,"id":183689,"user_name":"peiyi","can_delete":false,"product_type":"c1","uid":1272214,"ip_address":"","ucode":"4834AC379A21AB","user_header":"https://static001.geekbang.org/account/avatar/00/13/69/96/f7d2d30e.jpg","comment_is_top":false,"comment_ctime":1583117066,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583117066","product_id":100039001,"comment_content":"C++支持多重继承，通过virtual关键字避免多重继承的问题。<br>封装：通过public&#47;protected&#47;private关键字实现。<br>抽象：通过函数封装&#47;纯接口类（只包含virtual修饰的函数）实现。<br>继承：通过冒号（：）实现，也可以用限定关键字修饰<br>多态：分为静态多态和动态多态。<br>静态多态：<br>1）函数模版&#47;类模板：通过给出不同类型参数；<br>2）函数重载&#47;运算符重载：改变参数等；<br>3）强制多态：一般是运算过程中运算类型强制转换，如double-》int；<br>动态多态：通过继承和虚函数实现。","like_count":0},{"had_liked":false,"id":183678,"user_name":"彭汤宇","can_delete":false,"product_type":"c1","uid":1160325,"ip_address":"","ucode":"72BDD100CB373A","user_header":"https://static001.geekbang.org/account/avatar/00/11/b4/85/e21fc61b.jpg","comment_is_top":false,"comment_ctime":1583115556,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583115556","product_id":100039001,"comment_content":"如果 Java 语言没有提供访问权限控制语法，所有的属性默认都是 public 的，那任意外部代码都可以通过类似 wallet.id=123。Java默认的不是default吗？","like_count":0},{"had_liked":false,"id":180565,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1582337585,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582337585","product_id":100039001,"comment_content":"封装：易用<br>抽象：易维护<br>继承：易复用<br>多态：易扩展","like_count":0},{"had_liked":false,"id":179601,"user_name":"未来小娃","can_delete":false,"product_type":"c1","uid":1047329,"ip_address":"","ucode":"477D166EBB6B70","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/21/d017438c.jpg","comment_is_top":false,"comment_ctime":1582037408,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1582037408","product_id":100039001,"comment_content":"封装隐藏了属性的访问，抽象隐藏了方法的实现，继承实现代码的复用，多态让类更易扩展。继承的使用会有个误区，继承能够表示现实is-a的关系，但是是否is-a的关系一定得用继承才能实现呢？我觉得未必，同一个类不用的实例罢了，其次大家都说公共的属性和方法放在父类，使用的时候往往过了头。意思就是不管属性或方法是否与父类有关 ，都往父类塞，别说你没这样做过，我自己也曾经犯过这样的错，那么这样会有什么问题呢？父类越来越臃肿，父类变成了工具类，那么你父类可真够累的。经常提醒自己是否可以放在公共类，或者是否与父类真的强相关。再说多态，不对比不知道，多态其实继承的延伸，运行时会调用子类重载过的方法，这样的好处是可以无限扩展子类，只需要实例化的时候指定子类的类型就好了，确实可以节省代码唉。再讨论下多继承，多继承首先与多态违背，一个既是A又是B的实例运行态到底选择谁。","like_count":0},{"had_liked":false,"id":179407,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1581998245,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581998245","product_id":100039001,"comment_content":"对于问题一,我比较熟悉Java,是不支持多重继承的,毕竟有一个经典的钻石问题,在多重继承的时候,可能因为继承的多个父类都具有相同的属性,从而导致子类无法指定使用哪个父类的方法,从而出现了歧义<br>2.Java本身是支持四大特性,如上面所说,封装通过类,继承通过extends,多态通过子类转换为父类调用,抽象通过接口类和抽象类实现了","like_count":0},{"had_liked":false,"id":178269,"user_name":"秀丽","can_delete":false,"product_type":"c1","uid":1402332,"ip_address":"","ucode":"9872272B8056F5","user_header":"https://static001.geekbang.org/account/avatar/00/15/65/dc/0737102d.jpg","comment_is_top":false,"comment_ctime":1581647468,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581647468","product_id":100039001,"comment_content":"封装：提高安全性<br>抽象：方法等的封装<br>继承：提高复用性<br>多态：提高扩展性","like_count":0},{"had_liked":false,"id":177887,"user_name":"Edward Lee","can_delete":false,"product_type":"c1","uid":1228518,"ip_address":"","ucode":"156223F1D7E94A","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/e6/7808520d.jpg","comment_is_top":false,"comment_ctime":1581521810,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581521810","product_id":100039001,"comment_content":"为了方便记忆封装，抽象，继承，多态，个人总结为<br><br>封装 - function<br>抽象 - implements<br>继承 - extends<br>多态 - @Override","like_count":0},{"had_liked":false,"id":177618,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1581435358,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1581435358","product_id":100039001,"comment_content":"Java不支持多重继承，主要是为了避免钻石继承这种问题，Java提供了接口这种机制，用来实现某个类对多重继续这种特性的需求。在Java里，继承表示is-a这种关系，利用接口表示某个对象具有哪些行为能力。","like_count":0},{"had_liked":false,"id":176500,"user_name":"Geek_bb89c3","can_delete":false,"product_type":"c1","uid":1331828,"ip_address":"","ucode":"0F97B5B0F2DDD6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/IZKGetBZDuMEa2VwwtesTELvLORIyV749ItgfAqNPv30n4zEv71wuGNr1aNVIVltG0icvH53DHDuqPuzNpiauWAg/132","comment_is_top":false,"comment_ctime":1581072787,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581072787","product_id":100039001,"comment_content":"面向对象四大特性：封装，抽象，继承，多态。<br>封装：数据隐藏，和访问控制。需要语言提供数据访问权限，private，public，protected。这样做的优点一方面让系统变得更安全，只会让状态按照指定方式进行修改，而不会无法控制的修改，提高了可维护性。<br>抽象：分离功能和实现，让使用者简单的了解功能而忽略细节。这是一个通用特性，并不是oo特有的。抽象主要控制了系统的复杂度，系统易于维护，扩展和理解。<br>继承：在关系中的is-a关系。需要语言提供继承语法。主要解决代码复用的问题。继承分为单继承和多继承。过度继承的后果代码难以阅读和父类修改后会影响到子类。<br>多态：用父类引用指向子类对象的过程。需要语言提供抽象类语法。这样能提升系统的可扩展性，和复用性。使用一个父类，传入各种子类。<br>","like_count":0},{"had_liked":false,"id":175132,"user_name":"三尺寒冰","can_delete":false,"product_type":"c1","uid":1027586,"ip_address":"","ucode":"B10C7C9F955DF5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/02/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1580567524,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580567524","product_id":100039001,"comment_content":"java、php、javascript都不支持多重继承。<br>多重继承，就不能唯一确定父类了，调用父类方法可能报错。","like_count":0},{"had_liked":false,"id":174306,"user_name":"felix","can_delete":false,"product_type":"c1","uid":1086157,"ip_address":"","ucode":"DF514D0BB9B508","user_header":"https://static001.geekbang.org/account/avatar/00/10/92/cd/d39e568c.jpg","comment_is_top":false,"comment_ctime":1580132252,"is_pvip":false,"replies":[{"id":"67753","content":"生物没学好，你就当它会爬所以叫爬行动物吧😂","user_name":"作者回复","comment_id":174306,"uid":"1190123","ip_address":"","utype":1,"ctime":1580174485,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"1580132252","product_id":100039001,"comment_content":"“比如猫既是哺乳动物，又是爬行动物。”老师恐怕对爬行动物有什么误解吧？！😂","like_count":0,"discussions":[{"author":{"id":1211223,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","nickname":"QQ怪","note":"","ucode":"1A39B8433D9208","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206850,"discussion_content":"老哥，能分享下demo测试代码吗。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584449895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1439355,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f6/7b/b6abcbbe.jpg","nickname":"否极泰来","note":"","ucode":"C249173266251A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1211223,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","nickname":"QQ怪","note":"","ucode":"1A39B8433D9208","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":257343,"discussion_content":"百度一下吧，网上很多这种代码的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588560633,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":206850,"ip_address":""},"score":257343,"extra":""}]}]},{"had_liked":false,"id":174070,"user_name":"巨龙的力量啊","can_delete":false,"product_type":"c1","uid":1684858,"ip_address":"","ucode":"8FC6978929E48F","user_header":"https://static001.geekbang.org/account/avatar/00/19/b5/7a/a126c48f.jpg","comment_is_top":false,"comment_ctime":1579944042,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579944042","product_id":100039001,"comment_content":"前端前来打卡，真的学到东西啦","like_count":0},{"had_liked":false,"id":172960,"user_name":"linker","can_delete":false,"product_type":"c1","uid":1803259,"ip_address":"","ucode":"6C5799F2FC2C82","user_header":"https://static001.geekbang.org/account/avatar/00/1b/83/fb/621adceb.jpg","comment_is_top":false,"comment_ctime":1579395648,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579395648","product_id":100039001,"comment_content":"1:c需要不支持多继承，也不支持继承，我觉得它可以把结构体签到嵌入结构体来模拟继承，不知道对不对。<br>2:c需要不支持面向对象的四大特性语法，个人感觉是因为c需要早起发明的，当时软件设计没有这么复杂，没有考虑这些高级特性；另外由于c语言是为了写操作系统等底层接近硬件的软件发明的，所以对语言的性能有要求，而加上面向对象的特性可能会增加编译器的复杂性并且编译出来的二进制效率不高。","like_count":0},{"had_liked":false,"id":172593,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1579229243,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579229243","product_id":100039001,"comment_content":"封装：隐藏内部，暴露细节。<br>抽象：隐藏具体，关注功能。<br>继承：is-a关系。<br>多态：父类的变量指向子类的对象，执行的是子类重写的方法。","like_count":0},{"had_liked":false,"id":172132,"user_name":"双枪伽利略","can_delete":false,"product_type":"c1","uid":1267664,"ip_address":"","ucode":"14EAE02D543FE3","user_header":"https://static001.geekbang.org/account/avatar/00/13/57/d0/e2118a3b.jpg","comment_is_top":false,"comment_ctime":1579094424,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579094424","product_id":100039001,"comment_content":"python, 避免多重继承的副作用的方法：不用","like_count":0},{"had_liked":false,"id":172118,"user_name":"拉欧","can_delete":false,"product_type":"c1","uid":1206605,"ip_address":"","ucode":"40996A8093A95F","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/4d/81c44f45.jpg","comment_is_top":false,"comment_ctime":1579093002,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579093002","product_id":100039001,"comment_content":"老师讲的非常透彻，基本是面试的标准答案","like_count":0},{"had_liked":false,"id":172022,"user_name":"茶没喝完","can_delete":false,"product_type":"c1","uid":1644104,"ip_address":"","ucode":"D72D88C42A1258","user_header":"https://static001.geekbang.org/account/avatar/00/19/16/48/09493874.jpg","comment_is_top":false,"comment_ctime":1579072980,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579072980","product_id":100039001,"comment_content":"老师我太爱您了，解开了我多年学java的迷惑。感谢！！！！","like_count":0},{"had_liked":false,"id":169193,"user_name":"varotene","can_delete":false,"product_type":"c1","uid":1004441,"ip_address":"","ucode":"B37E9B6D35090C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/53/99/56f148bc.jpg","comment_is_top":false,"comment_ctime":1578289638,"is_pvip":false,"replies":[{"id":"65743","content":"看少哪一两个了，实际上，少抽象、少继承都没太大问题","user_name":"作者回复","comment_id":169193,"uid":"1190123","ip_address":"","utype":1,"ctime":1578379707,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"1578289638","product_id":100039001,"comment_content":"如果没有这四大特性，或者四大特性中少一两个，感觉还能实现面向对象编程想要达到的目的？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480452,"discussion_content":"看少哪一两个了，实际上，少抽象、少继承都没太大问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578379707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166688,"user_name":"程序员大天地","can_delete":false,"product_type":"c1","uid":1249001,"ip_address":"","ucode":"7A21F15FEE2D5B","user_header":"https://static001.geekbang.org/account/avatar/00/13/0e/e9/98b6ea61.jpg","comment_is_top":false,"comment_ctime":1577543567,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577543567","product_id":100039001,"comment_content":"2、GO语言支持封装，用结构体支持的；也支持抽象，使用接口类interface实现；支持多态，是接口类语法实现。","like_count":0},{"had_liked":false,"id":166686,"user_name":"程序员大天地","can_delete":false,"product_type":"c1","uid":1249001,"ip_address":"","ucode":"7A21F15FEE2D5B","user_header":"https://static001.geekbang.org/account/avatar/00/13/0e/e9/98b6ea61.jpg","comment_is_top":false,"comment_ctime":1577543436,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577543436","product_id":100039001,"comment_content":"1、Go语言不支持继承，估计是考虑到继承过多代码不易阅读。GO语言虽然不支持继承，但是支持组合。","like_count":0},{"had_liked":false,"id":166625,"user_name":"王岩","can_delete":false,"product_type":"c1","uid":1022558,"ip_address":"","ucode":"434F1A28A7B54C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9a/5e/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1577523426,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577523426","product_id":100039001,"comment_content":"1. Java 语言不支持多继承，支持多实现。主要因为调用的不确定性，多实现不会发生调用不确定性问题；<br>public abstract class Animal1 {<br>    <br>    void eat(){<br>        System.out.println(&quot;Animal1 eat&quot;);<br>    }<br>}<br>public class Animal2 {<br><br>    void eat(){<br>        System.out.println(&quot;Animal2 eat&quot;);<br>    }<br>}<br>public class Dog extends Animal1,Animal2 {<br><br>    @Override<br>    void eat(){<br>        &#47;&#47; 调用不确定性：执行Animal1的eat方法还是执行Animal2的eat方法？<br>        super.eat();<br>    }<br>}<br>由于接口中的方法没有实现，实现类的重写方法会同时覆盖多个接口中的方法。另外一点，继承本身存在的一个问题就是会使类的体系变得复杂，如果多继承的话，会让这个问题更加严重<br>2.封装还有一个好处：写这个类的人可以任意修改类中 private 修饰的代码，而不用担心会对调用者产生的影响，也算是提高了代码维护性吧<br>以上是个人理解，不知对不对，希望大家指点","like_count":0},{"had_liked":false,"id":166535,"user_name":"北风一叶","can_delete":false,"product_type":"c1","uid":1087302,"ip_address":"","ucode":"30310E66341D2A","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/46/fe1f21d8.jpg","comment_is_top":false,"comment_ctime":1577488139,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577488139","product_id":100039001,"comment_content":"1. 封装：隐藏非必要的函数、接口，暴露必要的函数、接口供外部访问，可以有效的进行信息隐藏和数据访问保护<br>2. 抽象：讲述如何隐藏方法的具体实现，让使用者只需要关注方法的具体功能<br>3. 继承：分类单继承和多继承，类间为is-a的关系使子类出现的地方可以被替换为父类<br>4. 多态：实现面对接口编程的非常重要的特性<br>几个特性完美结合，最终实现可扩展性、可复用等特性","like_count":0},{"had_liked":false,"id":165916,"user_name":"阿U","can_delete":false,"product_type":"c1","uid":1171359,"ip_address":"","ucode":"161A8E74E0D612","user_header":"https://static001.geekbang.org/account/avatar/00/11/df/9f/6e3e1b77.jpg","comment_is_top":false,"comment_ctime":1577344972,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1577344972","product_id":100039001,"comment_content":"搞不懂评论都在说多继承，文章明明说多重继承，这不是一个概念吧。多重继承是指a继承b，b继承c，相当于c是a父类的父类，所以JAVA是支持多重继承的。但不支持多继承 会造成大家说的那种问题。","like_count":0,"discussions":[{"author":{"id":1577580,"avatar":"https://static001.geekbang.org/account/avatar/00/18/12/6c/61a598e9.jpg","nickname":"苏暮沉觞","note":"","ucode":"532B816D4EF47B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":126792,"discussion_content":"多重继承跟多继承是一个概念，具体可以查看wiki百科：https://zh.wikipedia.org/wiki/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578538952,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165780,"user_name":"喵喵喵","can_delete":false,"product_type":"c1","uid":1211713,"ip_address":"","ucode":"E3AD8BF42E19DF","user_header":"https://static001.geekbang.org/account/avatar/00/12/7d/41/3c5b770b.jpg","comment_is_top":false,"comment_ctime":1577321994,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577321994","product_id":100039001,"comment_content":"打卡～","like_count":0},{"had_liked":false,"id":165375,"user_name":"我叫郭小黑","can_delete":false,"product_type":"c1","uid":1463441,"ip_address":"","ucode":"C238592EB5EDBC","user_header":"https://static001.geekbang.org/account/avatar/00/16/54/91/0d4647d9.jpg","comment_is_top":false,"comment_ctime":1577231693,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577231693","product_id":100039001,"comment_content":"第一个问题，使用java语言，不支持多继承，因为在多继承的时候，如果两个父类存在同样的方法，那么继承类不知道要继承具体哪一个方法，而同样子类在重新父类方法时，并不知道要重写哪个父类的方法。<br>第二个问题，java支持四大特性。<br>  对于封装使用了访问权限的关键字来控制。<br>  对于抽象可以采用类抽象和接口抽象，当然对于类的方法也是一种抽象。<br>  java可以使用extends关键字实现单继承。<br>  由于继承，父类可以引用子类对象，重写等特性，可以实现多态。","like_count":0},{"had_liked":false,"id":164737,"user_name":"黄政","can_delete":false,"product_type":"c1","uid":1345630,"ip_address":"","ucode":"9076A1BF7BB051","user_header":"https://static001.geekbang.org/account/avatar/00/14/88/5e/cc916a2b.jpg","comment_is_top":false,"comment_ctime":1577084397,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1577084397","product_id":100039001,"comment_content":"1.C++，当前支持多重继承。可以通过虚继承，来解决多重继承中，引用基类接口产生二义性的问题<br>2.C++对当前四大特性，均支持<br>1）封装：class类<br>2）抽象：函数接口即可做到<br>3）继承：C++当前支持继承特性<br>4）多态：基类函数定义成virual函数，子类中实现对应功能","like_count":0},{"had_liked":false,"id":164131,"user_name":"dingdongfm","can_delete":false,"product_type":"c1","uid":1564213,"ip_address":"","ucode":"7D17D2BC392A66","user_header":"","comment_is_top":false,"comment_ctime":1576892941,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576892941","product_id":100039001,"comment_content":"学习了，非常清晰的讲解","like_count":0},{"had_liked":false,"id":163867,"user_name":"Neuject","can_delete":false,"product_type":"c1","uid":1346309,"ip_address":"","ucode":"4DCFF6CDC4186E","user_header":"https://static001.geekbang.org/account/avatar/00/14/8b/05/3315b855.jpg","comment_is_top":false,"comment_ctime":1576814387,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576814387","product_id":100039001,"comment_content":"1. C#不支持类的多继承，避免多继承情况下继承的多个类具有相同内容时本身无法确定调用哪一个，因为多继承的话这些是平级的，也就是“菱形问题”。感觉多继承的这些需求都可以用继承多个接口完成，也可以类继承多个层级。<br><br>2. C#对于封装、抽象、继承、多态，这四个都有现成的语法支持。<br>封装：五种访问权限控制——public、protected、internal、protected internal、private<br>抽象：使用abstract关键字<br>继承：类和接口的继承都是使用“:”来实现，可以继承单个类和多个接口<br>多态：三种实现方式中①继承+方法重写、②接口类语法都可以实现，③duck-typing这种不行，感觉这种是在太灵活了，万物皆可多态实现了<br><br>PS：老师讲的真的太棒了，思路条理结构清晰，作为技术人员表达能力还这么强，真是我辈学习楷模啊","like_count":0},{"had_liked":false,"id":161207,"user_name":"BeanNan","can_delete":false,"product_type":"c1","uid":1088253,"ip_address":"","ucode":"FCF21A73BBE707","user_header":"https://static001.geekbang.org/account/avatar/00/10/9a/fd/30c425f9.jpg","comment_is_top":false,"comment_ctime":1576147559,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576147559","product_id":100039001,"comment_content":"Java不支持多继承的原因在于，继承多个类，维护起这些类中各个state很麻烦，所以只允许单继承，但是可以多实现接口，接口里面只有对应的action, 不涉及状态的维护","like_count":0},{"had_liked":false,"id":161144,"user_name":"从未走远","can_delete":false,"product_type":"c1","uid":1032967,"ip_address":"","ucode":"C5D379BF4A0271","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c3/07/8e1b6592.jpg","comment_is_top":false,"comment_ctime":1576131791,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576131791","product_id":100039001,"comment_content":"“如果 Java 语言没有提供访问权限控制语法，所有的属性默认都是 public 的”              关于Java的访问修饰符，应该是四种private，不写，protected，public把，默认用的是“不写“这种级别吧？","like_count":0},{"had_liked":false,"id":161130,"user_name":"rammelzzz","can_delete":false,"product_type":"c1","uid":1606275,"ip_address":"","ucode":"3BA634B5F6F74B","user_header":"https://static001.geekbang.org/account/avatar/00/18/82/83/8f168e4e.jpg","comment_is_top":false,"comment_ctime":1576125493,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576125493","product_id":100039001,"comment_content":"封装不仅体现在类的设计上。当需要给外部服务提供接口时，接口封装越好，外部对所提供服务的认知就会越简单越容易理解。反之则需要理解你的复杂业务逻辑，比如我给你传这个参数是什么含义类似的问题","like_count":0},{"had_liked":false,"id":160473,"user_name":"levi","can_delete":false,"product_type":"c1","uid":1259800,"ip_address":"","ucode":"C616B6172778F7","user_header":"https://static001.geekbang.org/account/avatar/00/13/39/18/2d739edc.jpg","comment_is_top":false,"comment_ctime":1575958422,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575958422","product_id":100039001,"comment_content":"争哥,请教一个问题,总感觉策略模式和多态很像,多态是策略模式的一种实现方式吗<br>","like_count":0},{"had_liked":false,"id":159785,"user_name":"爱水人家","can_delete":false,"product_type":"c1","uid":1730305,"ip_address":"","ucode":"0C94C6ACBC9CEB","user_header":"https://static001.geekbang.org/account/avatar/00/1a/67/01/44626cb9.jpg","comment_is_top":false,"comment_ctime":1575788471,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575788471","product_id":100039001,"comment_content":"我是C++使用者。众所周知，C++是支持多重继承的，为了避免多重继承带来的虚函数重写问题，C++定义了虚继承这种语法。","like_count":0},{"had_liked":false,"id":158393,"user_name":"疯狂的五花肉","can_delete":false,"product_type":"c1","uid":1642465,"ip_address":"","ucode":"B3CE22B3245EB3","user_header":"https://static001.geekbang.org/account/avatar/00/19/0f/e1/26632e59.jpg","comment_is_top":false,"comment_ctime":1575363366,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575363366","product_id":100039001,"comment_content":"你熟悉的编程语言是否支持多重继承？如果不支持，请说一下为什么不支持。如果支持，请说一下它是如何避免多重继承的副作用的。<br>答：Java与c++为例，Java都不支持多继承，c++支持多继承，多继承时，可能存在二义性，结构混乱。<br>java:可以使用接口类来实现多重继承的问题，接口没有具体实现，就可以去除二义性；<br>c++:使用虚基类解决这个副作用（例如有基类B，从B派生出C和D，然后类F又同时继承了C和D，现在类F的一个对象里面包含了两个基类B的对象，如果F访问自己的从基类B那里继承过来的的数据成员或者函数成员那么编译器就不知道你指的到底是从C那里继承过来的B对象呢还是从D那里继承过来的B对象。于是虚基类诞生了，将C和D的继承方式改为虚继承，那么F访问自己从B那里继承过来的成员就不会有二义性问题了，也就是将F对象里的B对象统一为一个，只有一个基类B对象）<br><br>你熟悉的编程语言对于四大特性是否都有现成的语法支持？对于支持的特性，是通过什么语法机制实现的？对于不支持的特性，又是基于什么原因做的取舍？<br>答：有现成的语法支持<br>封装（public，private等关键字）<br>多态（子类重写父类方法）<br>继承（extends关键字）<br>抽象（interface，abstract关键字）","like_count":0},{"had_liked":false,"id":158189,"user_name":"花花大脸猫","can_delete":false,"product_type":"c1","uid":1117318,"ip_address":"","ucode":"8ABDB3F7F4FB0F","user_header":"https://static001.geekbang.org/account/avatar/00/11/0c/86/8e52afb8.jpg","comment_is_top":false,"comment_ctime":1575344520,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1575344520","product_id":100039001,"comment_content":"1，java不支持，多继承的话如果父类有同名方法，子类无法决策调用哪个具体实现，如果是子类实现多个接口的话，同名接口方法只会在子类实现一次，没有上述父类多继承无法决策调用哪个具体实现的问题。<br>2.如老师所述，java目前都支持。","like_count":0},{"had_liked":false,"id":157166,"user_name":"疯狂土豆","can_delete":false,"product_type":"c1","uid":1273966,"ip_address":"","ucode":"16ADC351B57151","user_header":"https://static001.geekbang.org/account/avatar/00/13/70/6e/27f43b70.jpg","comment_is_top":false,"comment_ctime":1575052348,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575052348","product_id":100039001,"comment_content":"争哥，我是java的，一直有一个疑问反射是不是跳过了像private的限制，可以随意访问和设置属性的值了，那私有属性的设置也就没有意义了，是不是有点矛盾？","like_count":0},{"had_liked":false,"id":156716,"user_name":"冰ྂ镇ྂ可ྂ乐ྂ","can_delete":false,"product_type":"c1","uid":1455996,"ip_address":"","ucode":"A19F24BA1178FB","user_header":"https://static001.geekbang.org/account/avatar/00/16/37/7c/b6bc6024.jpg","comment_is_top":false,"comment_ctime":1574941455,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574941455","product_id":100039001,"comment_content":"python支持多重继承，对于方法解析顺序（MRO）的搜索，在经典类和新式类中是不同的：","like_count":0},{"had_liked":false,"id":156689,"user_name":"奇小易","can_delete":false,"product_type":"c1","uid":1171151,"ip_address":"","ucode":"E06B4DFB5352BB","user_header":"https://static001.geekbang.org/account/avatar/00/11/de/cf/ef2e0501.jpg","comment_is_top":false,"comment_ctime":1574935790,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574935790","product_id":100039001,"comment_content":"Q: 你熟悉的编程语言是否支持多重继承？如果不支持，请说一下为什么不支持。如果支持，请说一下它是如何避免多重继承的副作用的。<br>A: Python支持多重继承，使用MRO（Method Resolution Order）算法解决多继承的二义性问题，现在的实现是C3算法。多继承情况下，查询方法的顺序是从下至上，从左至右。先从最近的父类这一层开始查找，从左往右查，找不到以同样的方式向更上层的父类进行查找，以此类推，找到第一个执行，找不到抛未找到错误。<br>参考资料：https:&#47;&#47;www.python.org&#47;download&#47;releases&#47;2.3&#47;mro&#47;<br><br>Q: 你熟悉的编程语言对于四大特性是否都有现成的语法支持？对于支持的特性，是通过什么语法机制实现的？对于不支持的特性，又是基于什么原因做的取舍？<br>A: <br>Python<br>封装：使用变量命名的规范来隐藏数据（语法本身不支持，应该是作为动态语言，要做这样的限制很难？其实不是很懂这个原因）<br>继承：直接现有的继承语法<br>抽象：函数<br>多态：duck-typing<br>Python没有Java中的抽象类、接口类这种特定语法支持，但可以通过普通类来实现此功能，只需要在父类中实现一个抛出&quot;未实现&quot;异常的方法即可。","like_count":0},{"had_liked":false,"id":156183,"user_name":"mirapm","can_delete":false,"product_type":"c1","uid":1477646,"ip_address":"","ucode":"56478F8E0BE9D1","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/0e/a8b2a5bb.jpg","comment_is_top":false,"comment_ctime":1574829775,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574829775","product_id":100039001,"comment_content":"duck typing跟C++的模板很相似呀","like_count":0},{"had_liked":false,"id":155969,"user_name":"王麒","can_delete":false,"product_type":"c1","uid":1265260,"ip_address":"","ucode":"330017C5A911B6","user_header":"https://static001.geekbang.org/account/avatar/00/13/4e/6c/71020c59.jpg","comment_is_top":false,"comment_ctime":1574785791,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574785791","product_id":100039001,"comment_content":"Go的接口是隐式实现的，某种程度上来说，利用他的接口实现的多态也可以理解为一种duck-typing吧？","like_count":0},{"had_liked":false,"id":155714,"user_name":"Pioneer4","can_delete":false,"product_type":"c1","uid":1742839,"ip_address":"","ucode":"EE095D397D9BB4","user_header":"https://static001.geekbang.org/account/avatar/00/1a/97/f7/8afbb146.jpg","comment_is_top":false,"comment_ctime":1574741718,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574741718","product_id":100039001,"comment_content":"1. 你熟悉的编程语言是否支持多重继承？如果不支持，请说一下为什么不支持。如果支持，请说一下它是如何避免多重继承的副作用的。<br>我熟悉的C语言不支持继承，由于是面向过程的语言，更注重底层实现，缺少面向对象语言的封装、继承、多态机制。熟悉的java支持单继承，由于其语法机制决定了它的使用。如果java虽然不能实现多继承，但可以通过接口，组合等方式达到同样的效果。<br><br>2、你熟悉的编程语言对于四大特性是否都有现成的语法支持？对于支持的特性，是通过什么语法机制实现的？对于不支持的特性，又是基于什么原因做的取舍？<br>java支持四大特性。封装方面基于public、protect、default、private权限控制关键字实现；抽象通过abstract class、method和 interface实现；继承主要为单继承多实现，利用extends、implements机制。多态通过父类引用指向子类、接口指向子类、子类重写父类方法等实现。","like_count":0},{"had_liked":false,"id":155621,"user_name":"greg","can_delete":false,"product_type":"c1","uid":1189197,"ip_address":"","ucode":"BEE952C7ED2C84","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/0o2FEeJiav8lK9Y49JUOBretDypyHic2FL9dSZYnweBPZ5ibm3vgfm3q7kgXmQEOGOLJFgPEcMweVFj5QTrt4Vb4g/132","comment_is_top":false,"comment_ctime":1574729526,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574729526","product_id":100039001,"comment_content":"是什么，怎么用，可以用来解决什么问题。 整片文章思路很清晰，赞。","like_count":0},{"had_liked":false,"id":155102,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1574646201,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574646201","product_id":100039001,"comment_content":"字码结合 赞","like_count":0},{"had_liked":false,"id":155046,"user_name":"张鼎松","can_delete":false,"product_type":"c1","uid":1063160,"ip_address":"","ucode":"061F86EA9AA93D","user_header":"https://static001.geekbang.org/account/avatar/00/10/38/f8/b7ae7c6d.jpg","comment_is_top":false,"comment_ctime":1574640941,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574640941","product_id":100039001,"comment_content":"问题:为了可以赋值给Itorator, Array和LinkedList独有的方法或者属性一定要是private吗？","like_count":0},{"had_liked":false,"id":154964,"user_name":"ray","can_delete":false,"product_type":"c1","uid":1717235,"ip_address":"","ucode":"10962C711CBC11","user_header":"","comment_is_top":false,"comment_ctime":1574605743,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574605743","product_id":100039001,"comment_content":"老师好，请问老师在什么应用情境下会使用protected设定成员变量、成员方法的权限，什么时候会使用private设定成员变量、成员方法的权限？通常开始设计类的时候，不会那么清楚知道哪些应该定为protected，哪些应该定为private，因此想听听老师的想法。<br><br>谢谢老师","like_count":0},{"had_liked":false,"id":154885,"user_name":"东流","can_delete":false,"product_type":"c1","uid":1738147,"ip_address":"","ucode":"2715BC6E87BD83","user_header":"https://static001.geekbang.org/account/avatar/00/1a/85/a3/7e078442.jpg","comment_is_top":false,"comment_ctime":1574588337,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574588337","product_id":100039001,"comment_content":"java,类集成不支持多继承，因为避免菱形问题。但类可以实现多个接口，变现实现了多继承的部分功能<br>四大特性都有，<br>封装:通过关键private,protected,default,public实现<br>抽象:接口和抽象类<br>继承:extends,implement<br>多态:override注解","like_count":0},{"had_liked":false,"id":154824,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1274787,"ip_address":"","ucode":"C233DF1D224EC1","user_header":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","comment_is_top":false,"comment_ctime":1574575202,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574575202","product_id":100039001,"comment_content":"我熟悉的语言是Java和Objective-C以及swift。<br>Java不支持单继承是因为若一个类A同时继承两个类B和C，B和C中都有同样的方法,A的实例对象调用这个相同的方法时，无法知道调用的是哪一个父类的方法。<br>Objective-C以及swift也不支持多继承，二者采用的都是通过协议，类似Java的接口，以达到多重继承的效果。<br><br>大学的时候只学了一门C++，支持多重继承，当继承的父类中都有相同的父类时，多重继承的时候会出现二义性，通过如下方式避免：<br>1、类名限定：调用时指名调用的是哪个类的函数<br>2、同名覆盖：子类中声明一个同名函数，该函数根据需要内部调用某个父类的这个同名函数<br>3、虚基类：定义虚基类，直接或间接继承虚基类的所有派生类","like_count":0},{"had_liked":false,"id":154665,"user_name":"秋雨飘落","can_delete":false,"product_type":"c1","uid":1124916,"ip_address":"","ucode":"EC795F8DEC00EB","user_header":"https://static001.geekbang.org/account/avatar/00/11/2a/34/78656be9.jpg","comment_is_top":false,"comment_ctime":1574504377,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574504377","product_id":100039001,"comment_content":"四大特性 多态理解不清楚","like_count":0},{"had_liked":false,"id":154043,"user_name":"遗忘的童话","can_delete":false,"product_type":"c1","uid":1252850,"ip_address":"","ucode":"E11D9E8A11A82C","user_header":"https://static001.geekbang.org/account/avatar/00/13/1d/f2/81918ad5.jpg","comment_is_top":false,"comment_ctime":1574353251,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574353251","product_id":100039001,"comment_content":"我就不总结，我只想说一句话，钱花的真值啊！","like_count":0,"discussions":[{"author":{"id":1249781,"avatar":"https://static001.geekbang.org/account/avatar/00/13/11/f5/039f003d.jpg","nickname":"宁锟","note":"","ucode":"815FC9A9EBB109","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":177130,"discussion_content":"一个new操作分为3个子操作，1.分配内存空间，获得一个指向该空间的引用objRef 2.调用构造器初始化objRef引用指向的实例 3 将objRef引用赋值给实例变量Instance \nJIT编译器会将子操作3相应的指令重排到子操作2相应的指令前，这就导致其他线程看到instance实例变量的时候，虽然不为null，但并未初始化","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1582080215,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1101718,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cf/96/251c0cee.jpg","nickname":"xindoo","note":"","ucode":"AEAF3208E644BC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1249781,"avatar":"https://static001.geekbang.org/account/avatar/00/13/11/f5/039f003d.jpg","nickname":"宁锟","note":"","ucode":"815FC9A9EBB109","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":177564,"discussion_content":"按争哥的意思，高版本的jdk不会将2 3重排，但是我目前没找到相关资料","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582114702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":177130,"ip_address":""},"score":177564,"extra":""},{"author":{"id":1314724,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0f/a4/0b49469f.jpg","nickname":"木子00","note":"","ucode":"8F78CA722EB29B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1101718,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cf/96/251c0cee.jpg","nickname":"xindoo","note":"","ucode":"AEAF3208E644BC","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":278252,"discussion_content":"想知道是JDK 哪个版本\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591164933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":177564,"ip_address":""},"score":278252,"extra":""}]},{"author":{"id":1249781,"avatar":"https://static001.geekbang.org/account/avatar/00/13/11/f5/039f003d.jpg","nickname":"宁锟","note":"","ucode":"815FC9A9EBB109","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":177140,"discussion_content":"加锁已经能够保证可见性，不存在重复实例化的情况","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1582080767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1101718,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cf/96/251c0cee.jpg","nickname":"xindoo","note":"","ucode":"AEAF3208E644BC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1249781,"avatar":"https://static001.geekbang.org/account/avatar/00/13/11/f5/039f003d.jpg","nickname":"宁锟","note":"","ucode":"815FC9A9EBB109","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":177484,"discussion_content":"忘记这茬了，理解了，那按争哥的意思，确实不需要加volatile","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582110880,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":177140,"ip_address":""},"score":177484,"extra":""}]},{"author":{"id":2415448,"avatar":"https://static001.geekbang.org/account/avatar/00/24/db/58/a7a0a85b.jpg","nickname":"二饼","note":"","ucode":"48120565D135F7","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574957,"discussion_content":"这里使用的是synchronized（同步锁），不能放置指令重排（volatile），但是可以保证可见性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654496134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1020390,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/91/e6/03582dee.jpg","nickname":"牧名","note":"","ucode":"193F0F33E1AB47","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":178968,"discussion_content":"锁能保证可见性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582205286,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153920,"user_name":"真是艹0","can_delete":false,"product_type":"c1","uid":1234043,"ip_address":"","ucode":"0A082CE0D79C6E","user_header":"https://static001.geekbang.org/account/avatar/00/12/d4/7b/74e59208.jpg","comment_is_top":false,"comment_ctime":1574330261,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574330261","product_id":100039001,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":153887,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1025030,"ip_address":"","ucode":"62A89FD460827A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a4/06/cf6b6d0f.jpg","comment_is_top":false,"comment_ctime":1574325785,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574325785","product_id":100039001,"comment_content":"我熟悉的就是Java，争哥都已经总结好了：<br>- 封装，使用访问权限控制 public、protected、default、private<br>- 抽象，使用接口类和抽象类<br>- 继承，使用 extends 实现单继承<br>- 多态，借助继承和抽象类都能实现多态","like_count":0},{"had_liked":false,"id":153833,"user_name":"肖臧","can_delete":false,"product_type":"c1","uid":1047733,"ip_address":"","ucode":"4FAC9FF54DD6A0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fc/b5/ac717737.jpg","comment_is_top":false,"comment_ctime":1574315191,"is_pvip":false,"replies":[{"id":"59136","content":"本身代码就省略了很多东西 主要是为了讲原理","user_name":"作者回复","comment_id":153833,"uid":"1190123","ip_address":"","utype":1,"ctime":1574331642,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"1574315191","product_id":100039001,"comment_content":"封装的虚拟钱包类，没考虑多线程场景吧，增减操作都不是线程安全的","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475291,"discussion_content":"本身代码就省略了很多东西 主要是为了讲原理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574331642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1047733,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fc/b5/ac717737.jpg","nickname":"肖臧","note":"","ucode":"4FAC9FF54DD6A0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55006,"discussion_content":"的确是要忽略很多细节，才能突出您想表达的封装，就怕有人拿来主义，无脑拿过去用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574331793,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153339,"user_name":"昵称不重要","can_delete":false,"product_type":"c1","uid":1156872,"ip_address":"","ucode":"50F0E9DC56AE3B","user_header":"https://static001.geekbang.org/account/avatar/00/11/a7/08/802cc83f.jpg","comment_is_top":false,"comment_ctime":1574219967,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574219967","product_id":100039001,"comment_content":"目前没用过多继承，经过争哥讲解对于四大特性理解更清晰了","like_count":0},{"had_liked":false,"id":153069,"user_name":"千年孤独","can_delete":false,"product_type":"c1","uid":1037215,"ip_address":"","ucode":"282CA1A68E8774","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d3/9f/36ea3be4.jpg","comment_is_top":false,"comment_ctime":1574152679,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574152679","product_id":100039001,"comment_content":"用Golang实现的多态代码：<br>package main<br><br>import &quot;fmt&quot;<br><br>type Animal interface {<br>\tGetName() string<br>}<br><br>type Cat struct{<br>\tName string<br>}<br><br>func (a *Cat) GetName() string{<br>\tfmt.Println(&quot;Cat&quot;)<br>\treturn a.Name<br>}<br><br>func Exec(animal Animal) string{<br>\tfmt.Println(&quot;Animal&quot;)<br>\treturn animal.GetName()<br>}<br><br>type Dog struct {<br>\tName string<br>}<br><br>func (a *Dog) GetName() string{<br>\tfmt.Println(&quot;Dog&quot;)<br>\treturn a.Name<br>}<br><br>func main() {<br>\tvar  dog Animal = &amp;Dog{Name:&quot;this is a dog&quot;}<br>\tvar cat Animal = &amp;Cat{Name:&quot;this is a cat&quot;}<br>\tfmt.Println(Exec(dog))<br>\tfmt.Println(Exec(cat))<br>}","like_count":0},{"had_liked":false,"id":152979,"user_name":"Kevin","can_delete":false,"product_type":"c1","uid":1429627,"ip_address":"","ucode":"9DFFD6E3960CF7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJN64OCUT0Jp0h2Wiau9Os0o1WbwUeoq2QL0U2vZpib8ozPxo0XDiaPM9xcKfbkoBL24ztEHelxPIMVg/132","comment_is_top":false,"comment_ctime":1574133033,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574133033","product_id":100039001,"comment_content":"方法本身也是抽象，读者只需要从方法名，参数，返回值来整体理解方法作用，忽略掉方法实现 。<br>很优秀的理解。","like_count":0},{"had_liked":false,"id":152936,"user_name":"超级小帅兔","can_delete":false,"product_type":"c1","uid":1190963,"ip_address":"","ucode":"3D9FAC98D82637","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtxPelZRoA8WOx5ESmW4CIj9icf1XHNsDqyCaBudmVzSX2pSiacEn7IlLRic8ePegiaRwBet7nwKQkicg/132","comment_is_top":false,"comment_ctime":1574126370,"is_pvip":true,"replies":[{"id":"58732","content":"😂 好像不是...","user_name":"作者回复","comment_id":152936,"uid":"1190123","ip_address":"","utype":1,"ctime":1574128431,"user_name_real":"王争"}],"discussion_count":2,"race_medal":2,"score":"1574126370","product_id":100039001,"comment_content":"王峥老师，感谢优质文章。只有一个小问题，猫是爬行动物吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474995,"discussion_content":"😂 好像不是...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574128431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1190963,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtxPelZRoA8WOx5ESmW4CIj9icf1XHNsDqyCaBudmVzSX2pSiacEn7IlLRic8ePegiaRwBet7nwKQkicg/132","nickname":"超级小帅兔","note":"","ucode":"3D9FAC98D82637","race_medal":2,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53062,"discussion_content":":)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574128506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152838,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1574086452,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574086452","product_id":100039001,"comment_content":"第一次认识到暴露方法就是抽象的一种","like_count":0},{"had_liked":false,"id":152817,"user_name":"wyf2317","can_delete":false,"product_type":"c1","uid":1236837,"ip_address":"","ucode":"7F3E61A6188B39","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ub4icibeRLzff8Nf6ORsolib9KHtmeu3d4cCCAFd3Xgah3v78WfDYQB7WKq9iaIPXPwHBxw7mkBP9wYxDGMT9m1Rbw/132","comment_is_top":false,"comment_ctime":1574083228,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574083228","product_id":100039001,"comment_content":"1. 多重继承容易遇到钻石继承的问题","like_count":0},{"had_liked":false,"id":152792,"user_name":"兢","can_delete":false,"product_type":"c1","uid":1070683,"ip_address":"","ucode":"878EAA03E02C1C","user_header":"","comment_is_top":false,"comment_ctime":1574080678,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574080678","product_id":100039001,"comment_content":"“如果 Java 语言没有提供访问权限控制语法，所有的属性默认都是 public 的” 。貌似不是public，是包内的访问权限","like_count":0},{"had_liked":false,"id":152742,"user_name":"任先森","can_delete":false,"product_type":"c1","uid":1337482,"ip_address":"","ucode":"A3EE0FD8231F8D","user_header":"https://static001.geekbang.org/account/avatar/00/14/68/8a/620aa4ea.jpg","comment_is_top":false,"comment_ctime":1574073546,"is_pvip":false,"replies":[{"id":"60035","content":"1. bean中不要写特别四的逻辑，这个怎么理解呢？<br>2. 如果有需求的话，可以添加set方法和get修改时间的方法","user_name":"作者回复","comment_id":152742,"uid":"1190123","ip_address":"","utype":1,"ctime":1574855292,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"1574073546","product_id":100039001,"comment_content":"王老师，我有一点没能理解。就是刚开始写的虚拟钱包类(Walet),是不是封装的有点过了呢，我看阿里巴巴开发规范，不要在bean里写特别的死的逻辑，否则排查问题不好排查，<br>还有一个就是没理解，不写set的话从数据库里查怎么放到bean里呢，还有一个是页面应该也会显示最后修改时间，没有get，怎么取出最后修改时间呢","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474922,"discussion_content":"1. bean中不要写特别四的逻辑，这个怎么理解呢？\n2. 如果有需求的话，可以添加set方法和get修改时间的方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574855292,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152727,"user_name":"志振爱咋滴咋滴","can_delete":false,"product_type":"c1","uid":1237624,"ip_address":"","ucode":"E7A5049920C101","user_header":"https://static001.geekbang.org/account/avatar/00/12/e2/78/9241b7b2.jpg","comment_is_top":false,"comment_ctime":1574070530,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574070530","product_id":100039001,"comment_content":"1.目前使用java语言，并不支持多重继承，主要就是避免在多重继承中，如果出现方法重载的时候，子类无法确定自己到底该直接实现何者重载的方法。<br>2.java目前就是比较支持这四个特性的。<br>封装：该要的要不该要的不要<br>继承：能剩就剩，但是要避免出现歧义<br>多态：大家都能用才是真好用<br>抽象：不该知道的就别知道的好","like_count":0},{"had_liked":false,"id":152660,"user_name":"Heiky","can_delete":false,"product_type":"c1","uid":1623626,"ip_address":"","ucode":"03AA79E1BC4AE4","user_header":"https://static001.geekbang.org/account/avatar/00/18/c6/4a/3bd896fc.jpg","comment_is_top":false,"comment_ctime":1574058485,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574058485","product_id":100039001,"comment_content":"Java不支持多继承的原因，就是会出现钻石问题，二义性的问题，想必有很多小伙伴都知道。另外我想说一点，多态的定义，父类引用指向子类对象，这样是不是更好理解，引用指向子类对象，调用的方法也会是子类重写之后的方法。","like_count":0},{"had_liked":false,"id":152658,"user_name":"冲","can_delete":false,"product_type":"c1","uid":1149914,"ip_address":"","ucode":"4191C8A4DF3840","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIk46cor5XVFTPZbPOnb7pViabgy450pobo46hRHFQz5nR5ocYRKIzC8vShic36vwa553H4Vj50x5wA/132","comment_is_top":false,"comment_ctime":1574058227,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574058227","product_id":100039001,"comment_content":"C#不支持类多继承，但是支持多接口继承","like_count":0},{"had_liked":false,"id":152650,"user_name":"钢！","can_delete":false,"product_type":"c1","uid":1246834,"ip_address":"","ucode":"22155C1F87AC72","user_header":"https://static001.geekbang.org/account/avatar/00/13/06/72/d5b570e1.jpg","comment_is_top":false,"comment_ctime":1574056685,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574056685","product_id":100039001,"comment_content":"谈谈我对四大特性的理解<br>封装：对外：保证了类使用的简便，隐藏了复杂的实现，<br>          对内：保证了对象属性即对象内存操作的规范性，可将变化限制在有限范围，做到了可控。","like_count":0},{"had_liked":false,"id":152435,"user_name":"Fun","can_delete":false,"product_type":"c1","uid":1145502,"ip_address":"","ucode":"5D89BA4C678785","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJdUGdEj3R25CrYqibPibYibibRicqUfyL4aTTPbMagyywjKMhXGZE37RTe7lEdvC4DibvtYpzg8zXvt9HQ/132","comment_is_top":false,"comment_ctime":1574000623,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574000623","product_id":100039001,"comment_content":"# day 9<br>继续学习OOP的四大特性的概念。<br>封装：数据访问保护。可以提高代码易用性；<br>抽象：屏蔽函数功能实现细节。可以提高代码可复用性；<br>继承：表现is-a的一种关系，只有OOPL才有提供语法支持。可以提高代码复用性，扩展性；<br>多态：子类代替父类，同样只有OOPL才有提供语法机制。可以提高代码复用性，扩展性，是很多设计模式，设计原则，编码技巧的基础。","like_count":0},{"had_liked":false,"id":152354,"user_name":"王振华 程序员","can_delete":false,"product_type":"c1","uid":1131957,"ip_address":"","ucode":"31BB337642B882","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/b5/c3cfb198.jpg","comment_is_top":false,"comment_ctime":1573980978,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573980978","product_id":100039001,"comment_content":"Ruby不支持多重继承，因为会很混乱。但如果除了父类中的属性、方法，子类还想复用其他的属性、方法，在Ruby中还提供了 mixin的方式，来从module中引入。module和类相似，只是不能定义实例。可以理解为只有方法，没有数据。","like_count":0},{"had_liked":false,"id":152301,"user_name":"大胃王","can_delete":false,"product_type":"c1","uid":1120238,"ip_address":"","ucode":"17072DCDB4C7FC","user_header":"https://static001.geekbang.org/account/avatar/00/11/17/ee/b123e7bc.jpg","comment_is_top":false,"comment_ctime":1573964593,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1573964593","product_id":100039001,"comment_content":"回顾计算机语言发展历史：二进制-&gt;汇编-&gt;面向过程-&gt;面向对象-&gt;？<br><br>可以发现，计算机语言的发展历史本质上是为了解决：软件开发速度无法满足软件发展需要的矛盾，所以个人认为计算机语言会朝着越来越简单的方向发展。事后诸葛的角度来看，继承特性是过度设计了，抽象类也没有必要存在。","like_count":0,"discussions":[{"author":{"id":1429627,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJN64OCUT0Jp0h2Wiau9Os0o1WbwUeoq2QL0U2vZpib8ozPxo0XDiaPM9xcKfbkoBL24ztEHelxPIMVg/132","nickname":"Kevin","note":"","ucode":"9DFFD6E3960CF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53105,"discussion_content":"面向自然语言","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574132907,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152258,"user_name":"条","can_delete":false,"product_type":"c1","uid":1203836,"ip_address":"","ucode":"6F8679175256E3","user_header":"https://static001.geekbang.org/account/avatar/00/12/5e/7c/94af3f5e.jpg","comment_is_top":false,"comment_ctime":1573954367,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573954367","product_id":100039001,"comment_content":"1.编程语言：java，只支持单继承，如果对多继承支持，会有二义性的问题。<br>2.java对四大特性的支持：<br>(1)封装：访问权限控制。<br>(2)抽象：interface和abstract(非必须语法支持)，需要提供函数这个基础特性。<br>(3)继承：extends关键字。<br>(4)多态：1)父类可以引用子类的对象。<br>              2)继承父类(extends)或实现接口(implements)。<br>              3)子类可以重写父类方法。<br><br>","like_count":0},{"had_liked":false,"id":152247,"user_name":"码农Kevin亮","can_delete":false,"product_type":"c1","uid":1116630,"ip_address":"","ucode":"D34562461CA0A1","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/d6/5f366427.jpg","comment_is_top":false,"comment_ctime":1573950668,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573950668","product_id":100039001,"comment_content":"用了这么久js，一直没明白什么是duck-typing，老师这么一说就秒懂了","like_count":0},{"had_liked":false,"id":152207,"user_name":"林夕","can_delete":false,"product_type":"c1","uid":1494249,"ip_address":"","ucode":"89ADA39FC10BBD","user_header":"https://static001.geekbang.org/account/avatar/00/16/cc/e9/19497393.jpg","comment_is_top":false,"comment_ctime":1573914858,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573914858","product_id":100039001,"comment_content":"动态数组排序那个循环过后的那个语句觉得有点怪怪的，循环里已经是把大的是放在最后一个位置了，循环过后又把e放到最后一个位置了。。。","like_count":0},{"had_liked":false,"id":152074,"user_name":"个人练习生niki👍","can_delete":false,"product_type":"c1","uid":1191678,"ip_address":"","ucode":"48E5D6DE94BBBB","user_header":"https://static001.geekbang.org/account/avatar/00/12/2e/fe/5541689b.jpg","comment_is_top":false,"comment_ctime":1573870823,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573870823","product_id":100039001,"comment_content":"Java中语法不支持多继承，通过内部类的方式对多继承妥协。","like_count":0},{"had_liked":false,"id":152064,"user_name":"cc","can_delete":false,"product_type":"c1","uid":1592092,"ip_address":"","ucode":"FF41E5D87BAD76","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/1c/5eb03a91.jpg","comment_is_top":false,"comment_ctime":1573868332,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573868332","product_id":100039001,"comment_content":"C++是支持多重继承的。虚继承。<br>也支持四大特性。","like_count":0},{"had_liked":false,"id":152010,"user_name":"Devin-Yang","can_delete":false,"product_type":"c1","uid":1120500,"ip_address":"","ucode":"68B9395BA71272","user_header":"https://static001.geekbang.org/account/avatar/00/11/18/f4/eb253192.jpg","comment_is_top":false,"comment_ctime":1573832795,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573832795","product_id":100039001,"comment_content":"java语言出于安全考虑只允许继承单一父类，同时也提供了实现多个接口和使用内部类的方式间接来实现多重继承","like_count":0},{"had_liked":false,"id":151976,"user_name":"Holmes","can_delete":false,"product_type":"c1","uid":1078589,"ip_address":"","ucode":"28DD6247AC3908","user_header":"https://static001.geekbang.org/account/avatar/00/10/75/3d/0d6cf519.jpg","comment_is_top":false,"comment_ctime":1573826266,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573826266","product_id":100039001,"comment_content":"Objective-C 不支持多重继承，原因不晓得","like_count":0},{"had_liked":false,"id":151842,"user_name":"wl","can_delete":false,"product_type":"c1","uid":1392730,"ip_address":"","ucode":"45062AA2460F1F","user_header":"https://static001.geekbang.org/account/avatar/00/15/40/5a/e65e8c40.jpg","comment_is_top":false,"comment_ctime":1573799407,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573799407","product_id":100039001,"comment_content":"1、你熟悉的编程语言是否支持多重继承？如果不支持，请说一下为什么不支持。如果支持，请说一下它是如何避免多重继承的副作用的。<br><br>JavaScript 可以通过 b extends a; c extends b; 的方式实现看起来是多重继承的继承。其实是JS 的语法糖，通过原型链的方式实现的，所以会按 c、b、a 的顺序查找属性和方法，不会发生冲突。<br><br>2、你熟悉的编程语言对于四大特性是否都有现成的语法支持？对于支持的特性，是通过什么语法机制实现的？对于不支持的特性，又是基于什么原因做的取舍？<br><br>封装：可以通过把属性和方法封装在函数内部去实现。<br>抽象：JS 没有接口类的概念，不过可以通过 TS 实现。<br>继承：可以通过 JS 的语法糖 extends Class ，并且在子类内部重写父类方法实现。<br>多态：项目中没有使用过多态的概念，但是按照老师讲的，JS 应该也是可以实现多态的，只要两个类有相同的行为，就可以通过 duck-typing 来实现多态。<br><br>也不知道理解的对不对，请老师指正，谢谢！","like_count":0},{"had_liked":false,"id":151789,"user_name":"DullBird","can_delete":false,"product_type":"c1","uid":1110494,"ip_address":"","ucode":"80E2FD5F9687CB","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/de/3ebcbb3f.jpg","comment_is_top":false,"comment_ctime":1573792575,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573792575","product_id":100039001,"comment_content":"1.我使用java，java语言不支持多继承。<br>不支持的原因想到一个是: 如果A实现一个方法叫void say(),B也实现一个方法void say()<br>那么C继承A，B的时候，调用C.say(),不知道是调用的A的say()还是B的say()<br>2.对于4大特性，java 都是支持的。<br>封装:通过访问修饰符<br>抽象:方法的命名，接口类，抽象类<br>继承:通过抽象类和接口类<br>多态:通过子类复写方法 + 继承实现","like_count":0},{"had_liked":false,"id":151766,"user_name":"Chaos浩","can_delete":false,"product_type":"c1","uid":1675943,"ip_address":"","ucode":"4FFAE6EEAA460B","user_header":"https://static001.geekbang.org/account/avatar/00/19/92/a7/00fefed5.jpg","comment_is_top":false,"comment_ctime":1573787380,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573787380","product_id":100039001,"comment_content":"比大学课本里讲的通俗易懂多了","like_count":0},{"had_liked":false,"id":151652,"user_name":"自来也","can_delete":false,"product_type":"c1","uid":1681814,"ip_address":"","ucode":"94CF8E5FF6DEC2","user_header":"https://static001.geekbang.org/account/avatar/00/19/a9/96/6d517a06.jpg","comment_is_top":false,"comment_ctime":1573775987,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573775987","product_id":100039001,"comment_content":"我认为Java设计非常好，拿猫来说，我认为封装应该从一开始的抽象类生命体开始，然后慢慢往下分支，抽象是描述的某一类事物，然而猫是爬着走，应该属于interface，这是他的一种行为，假设有一天猫进化了，还会飞，那我就在搞个会飞的接口，行为一直存在，当这类物体失去了这个特征不代表这个特征从此就消失了，例如人在生病他实现了感冒的接口，身体好了，就把接口移除，但是感冒仍然存在。","like_count":0},{"had_liked":false,"id":151593,"user_name":"jony","can_delete":false,"product_type":"c1","uid":1048286,"ip_address":"","ucode":"80765A6B9ABA0D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fe/de/2019f370.jpg","comment_is_top":false,"comment_ctime":1573746644,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573746644","product_id":100039001,"comment_content":"Java多重继承确实会有歧义问题，所以舍弃了多重继承，c++可以在调用具体方法时通过添加域操作符来避免歧义，对于菱形继承通过使用vitual虚继承避免歧义，具体参考https:&#47;&#47;blog.csdn.net&#47;u014489596&#47;article&#47;details&#47;38488927","like_count":0},{"had_liked":false,"id":151575,"user_name":"段启超","can_delete":false,"product_type":"c1","uid":1258209,"ip_address":"","ucode":"164CF3018071B2","user_header":"https://static001.geekbang.org/account/avatar/00/13/32/e1/c9aacb37.jpg","comment_is_top":false,"comment_ctime":1573741906,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573741906","product_id":100039001,"comment_content":"java报道:<br>JAVA 不支持多继承，因为java中的继承体现的是一种子类和父类的关系，如果两个父类有相同的方法，子类覆写父类的方法到底重写哪一个，不能确定。另一方面，我觉得JAVA的这种设计和更符合现实世界的继承关系，一个儿子不可能有多个亲爹。接口语法机制也让JAVA拥有灵活扩展的能力。<br>JAVA支持这四个特征。<br>抽象：JAVA可以通过抽象类和接口机制完成抽象，正如争哥说的，还有一种层次之美。<br>封装：JAVA中的public,private,protected，加强package，构造了完整的权限控制体系，实现对不同场景下的封装。<br>继承：extends,implements 实现对父类和接口的继承，实现。提现is-a,和can-do的设计原则，也是实现多态的途径。<br>多态:多态以继承和实现为基础,由JVM在运行期实现对对应子类方法的调用。这种机制为JAVA提供了扩展性。","like_count":0},{"had_liked":false,"id":151556,"user_name":"L🚲🐱","can_delete":false,"product_type":"c1","uid":1577856,"ip_address":"","ucode":"08A012739614DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","comment_is_top":false,"comment_ctime":1573739788,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573739788","product_id":100039001,"comment_content":"one. java 不支持多继承, 因为会产生歧义, 虽然 java 不支持多继承, 但是支持多实现, 可以实现多个接口, <br>two. 都支持 抽象用 abstract  继承 extend 多态 @Override 封装 访问控制符","like_count":0},{"had_liked":false,"id":151526,"user_name":"Geek_Spring","can_delete":false,"product_type":"c1","uid":1292572,"ip_address":"","ucode":"3F44EE152CB357","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erRavHNiaicxIIq5Pal1iadE4axG6ibbib6llpHBslhiahWDQ6tdE1IcWicFogfvuyfGoiayC51knA09UtQvQ/132","comment_is_top":false,"comment_ctime":1573736574,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573736574","product_id":100039001,"comment_content":"学习java的时候都知道不支持多继承，为啥呢，也是最近才知道具体原因，就是那个钻石问题，如果A同时继承B和C，而B和C同时有一个D方法，A如何决定该继承那一个呢？但是对于多继承这个字眼，在java中又是支持的，接口可以多继承，接口全都是抽象方法继承谁都无所谓，所以接口可以继承多个接口。类不能支持多继承就是为了避免这个歧异问题","like_count":0},{"had_liked":false,"id":151435,"user_name":"liy","can_delete":false,"product_type":"c1","uid":1322151,"ip_address":"","ucode":"ACE2C473DBA19F","user_header":"https://static001.geekbang.org/account/avatar/00/14/2c/a7/7f702c49.jpg","comment_is_top":false,"comment_ctime":1573719003,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1573719003","product_id":100039001,"comment_content":"好强，无法回答思考题，有点丢脸。。","like_count":0},{"had_liked":false,"id":151431,"user_name":"光光","can_delete":false,"product_type":"c1","uid":1242876,"ip_address":"","ucode":"A0F1D0134C935F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f6/fc/171c4976.jpg","comment_is_top":false,"comment_ctime":1573718275,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573718275","product_id":100039001,"comment_content":"对于多重继承和单重继承这就就拿C++和java来说吧。从两个语言的被发明的时间C++是80年代被发明然后陆续加入饿了面向对象的特性，至于C++采用多重继承多从实际面向对象的角度出发，就像老师再文中举得栗子（可能更符合人们思考问题的逻辑吧）；而java作为一个真真意义上的面向对象语言，从C++中学习吸收了不少，继承方面，选择了单继承，但允许接口多继承，这样很好的解决了DOD的问题，通过接口类来完成多重继承的功能，后来的C#也采用这种方法。","like_count":0},{"had_liked":false,"id":151427,"user_name":"曾经瘦过","can_delete":false,"product_type":"c1","uid":1240106,"ip_address":"","ucode":"57C32575A1C1FD","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/2a/b11d5ad8.jpg","comment_is_top":false,"comment_ctime":1573717708,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573717708","product_id":100039001,"comment_content":"java  不支持多继承 (接口有点多继承的意思)","like_count":0},{"had_liked":false,"id":151423,"user_name":"天野明","can_delete":false,"product_type":"c1","uid":1229765,"ip_address":"","ucode":"4522BA0AE29958","user_header":"https://static001.geekbang.org/account/avatar/00/12/c3/c5/61abf810.jpg","comment_is_top":false,"comment_ctime":1573716766,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573716766","product_id":100039001,"comment_content":"自从学go语言知道了duck-typing模式后，真心觉得c++的多态好鸡肋。。","like_count":0},{"had_liked":false,"id":151401,"user_name":"нáпの゛","can_delete":false,"product_type":"c1","uid":1130666,"ip_address":"","ucode":"834FA877EFBAF7","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/aa/49bbb007.jpg","comment_is_top":false,"comment_ctime":1573713489,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573713489","product_id":100039001,"comment_content":"四个特性被捋的明明白白。之前都没细思过单继承和多继承的区别，查了C++是通过基类名限定来避免二义性，不知道是否正确。<br>四个特性C++是现成语法支持的，通过什么机制实现触碰到知识盲点了，希望老师后面课里能讲到。","like_count":0},{"had_liked":false,"id":151398,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1573713286,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573713286","product_id":100039001,"comment_content":"你熟悉的编程语言对于四大特性是否都有现成的语法支持？对于支持的特性，是通过什么语法机制实现的？对于不支持的特性，又是基于什么原因做的取舍？<br>Java<br>封装： 访问权限的控制。（但是其反射，其实时破坏了这种机制）<br>继承： extends<br>抽象：接口，个人理解抽象类也是接口的另一种形式。<br>多态：个人理解 这个体现比较明显的地方就是 泛型。","like_count":0},{"had_liked":false,"id":151395,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1573713123,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573713123","product_id":100039001,"comment_content":"理解：<br>1，封装：屏蔽内部细节，使得外部调用时只需要关注public属性和方法。<br>2，抽象：体现为抽象类或者接口类。用于规范其实现类。假设，定义了抽象类“会叫的动物”，都有 叫 这个方法，这时候，如果有类继承了这个抽象类，但是没有 叫 这个方法那么就是不合理的。这个例子在多态会再用到。<br>3，继承：继承分为两种，一种是为了提取公共方法。另一种则是为了多态。<br>4，多态：“子类可以替换父类”，另一点“接口的多个实现也可以互相替换”。抽象时的例子：创建了一个List&lt;会叫的动物&gt; 这时候，有需求。需要十个会叫的动物，调用的地方，往List里添加了8个鹦鹉对象（鹦鹉实现了会叫的动物接口），但是鹦鹉不够了，然后又往里面添加了2个 青蛙（同样实现了会叫的动物接口），然后到了调用这个List的地方。遍历它们，然后调用它们的 叫 方法即可。具体是什么东西在叫，调用方并不需要关心。更不需要关心如何（内部实现） 叫，也就体现了封装。","like_count":0},{"had_liked":false,"id":151387,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1573711969,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1573711969","product_id":100039001,"comment_content":"第一次对封装、抽象、继承和多态有了点总结的想法，封装的出发角度是数据(访问控制)，抽象的出发角度是操作(方法和函数)，继承的出发角度是代码复用，而多态更多的是代码扩展。按我的理解，一份代码的实现从抽象(数据)，到具体实现(如何操作数据)，也就是编码(继承和多态)，这可能就是面向对象四大特性总结的过程吧。最后，个人超级不喜欢多继承，因为太容易乱了，更倾向于实现多个接口来实现多重复用，虽然现实世界中存在对象的多重复用，但多个复用对象之间应该有个主次之分，或者更精确地说在不同角度下看是这样的。那么单继承+接口基本就足够了，多继承带来的维护成本大多数情况下比优势更小。这和标准的UML适合写论文而不适合沟通是一个道理。","like_count":0},{"had_liked":false,"id":151373,"user_name":"铿然","can_delete":false,"product_type":"c1","uid":1162461,"ip_address":"","ucode":"D529242EC2E2EA","user_header":"https://static001.geekbang.org/account/avatar/00/11/bc/dd/c9413f59.jpg","comment_is_top":false,"comment_ctime":1573707939,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1573707939","product_id":100039001,"comment_content":"补充，面向接口编程不等同于抽象，面向接口编程为了接口稳定，可以🈶不同实现，抽象是为了把共性的部分抽离出来使用。","like_count":0},{"had_liked":false,"id":151351,"user_name":"沐夜星光","can_delete":false,"product_type":"c1","uid":1447220,"ip_address":"","ucode":"22F699E237B179","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLia2EwyyEVs3tWRnMlqaAG7R7HvlW4vGvxthKsicgsCEeXO1qL7mMy6GAzgdkSKcH3c70Qa2hY3JLw/132","comment_is_top":false,"comment_ctime":1573704332,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573704332","product_id":100039001,"comment_content":"封装中提到的increaseBalance和decreaseBalance，提醒了我封装不仅提供对隐私数据的保护，同时也通过方法实现了对操作权限的控制。按照我平时的开发习惯，为了图省事，可能只会定义一个setBalance。","like_count":0},{"had_liked":false,"id":151348,"user_name":"Leo","can_delete":false,"product_type":"c1","uid":1383148,"ip_address":"","ucode":"24401B70B6B40A","user_header":"https://static001.geekbang.org/account/avatar/00/15/1a/ec/4d272448.jpg","comment_is_top":false,"comment_ctime":1573703547,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573703547","product_id":100039001,"comment_content":"打卡,js基于原型,原型链实现继承功能","like_count":0},{"had_liked":false,"id":151324,"user_name":"anynew","can_delete":false,"product_type":"c1","uid":1235807,"ip_address":"","ucode":"F8308342828D4B","user_header":"https://static001.geekbang.org/account/avatar/00/12/db/5f/1ec96fb4.jpg","comment_is_top":false,"comment_ctime":1573699142,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573699142","product_id":100039001,"comment_content":"为什么Java不支持而c++支持","like_count":0},{"had_liked":false,"id":151311,"user_name":"bearlu","can_delete":false,"product_type":"c1","uid":1030862,"ip_address":"","ucode":"14F260C8B24E27","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/ce/fd45714f.jpg","comment_is_top":false,"comment_ctime":1573698168,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1573698168","product_id":100039001,"comment_content":"C++是多重继承，但是设计类的时候尽量使用单继承<br>C++通过private,protected,public进行封装特性<br>通过定义abstract关键字进行抽象<br>通过：进行继承<br>通过virtual和继承进行多态的实现","like_count":0},{"had_liked":false,"id":151304,"user_name":"colin","can_delete":false,"product_type":"c1","uid":1292206,"ip_address":"","ucode":"7A8849B8AE33E0","user_header":"https://static001.geekbang.org/account/avatar/00/13/b7/ae/a25fcb73.jpg","comment_is_top":false,"comment_ctime":1573697941,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573697941","product_id":100039001,"comment_content":"大量多继承场景，现在基本就只有c++能完成了","like_count":0},{"had_liked":false,"id":151298,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1573697425,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573697425","product_id":100039001,"comment_content":"c++：<br>1 支持多重继承。在多重继承情况下，子类转换为第一个父类不需要做额外的移位运算。但对于非第一个父类，需要进行偏移运算。另外，引入虚函数后，子类将同时包含多个虚表指针。至于多重继承的副作用，不是特别清楚，还望高人指点<br>2 c++完全支持面向对象的4种特性。<br>封装：支持public，protected，private三种权限级别<br>抽象：支持虚基类，即包含纯虚函数<br>继承：支持单继承，多继承，虚继承<br>多态：虚函数机制","like_count":0},{"had_liked":false,"id":151296,"user_name":"努力努力再努力m","can_delete":false,"product_type":"c1","uid":1644369,"ip_address":"","ucode":"9DD9E9C2988FFC","user_header":"https://static001.geekbang.org/account/avatar/00/19/17/51/3e13dc0c.jpg","comment_is_top":false,"comment_ctime":1573697313,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573697313","product_id":100039001,"comment_content":"看了这一讲后，才发现以前学的时候，只是简单的了解怎么用，并不懂它们的意义，又回头把java的这几个特性看了一遍，受益匪浅。","like_count":0},{"had_liked":false,"id":151285,"user_name":"饭粒","can_delete":false,"product_type":"c1","uid":1153455,"ip_address":"","ucode":"4C3220B0D43997","user_header":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","comment_is_top":false,"comment_ctime":1573695158,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573695158","product_id":100039001,"comment_content":"文章很棒。以前只是知道是什么，没去想这些特性的意义和解决的问题。","like_count":0},{"had_liked":false,"id":151276,"user_name":"Milittle","can_delete":false,"product_type":"c1","uid":1045455,"ip_address":"","ucode":"80E566639A8ABB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f3/cf/851dab01.jpg","comment_is_top":false,"comment_ctime":1573693601,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1573693601","product_id":100039001,"comment_content":"好多我都是看得懂 以前也有认知  说明我还是不错 能深入到这个层面  感谢争哥的专栏 让我学到很多 就是我还没达到可以汇总知识的地步 我还需要努力 同时交大研 向优秀的争哥继续学习~","like_count":0},{"had_liked":false,"id":151273,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1573693527,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1573693527","product_id":100039001,"comment_content":"C++支持多继承，但是会有菱形继承的问题，需要代码检查排除，封装，抽象，继承，多态都支持，通过类，虚函数，重载，重写来实现这四种特性","like_count":0},{"had_liked":false,"id":151270,"user_name":"Tom.G","can_delete":false,"product_type":"c1","uid":1206034,"ip_address":"","ucode":"7929B45C1A51F8","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/12/5c6eb568.jpg","comment_is_top":false,"comment_ctime":1573693315,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573693315","product_id":100039001,"comment_content":"1.看了其他同学的评论才知道，多继承会导致菱形问题<br>2.C#语言<br>2.1封装：public private sealed internal protected<br>2.2抽象：abstract interface<br>2.3继承：冒号<br>2.4多态：子类替换父类","like_count":0},{"had_liked":false,"id":151194,"user_name":"will","can_delete":false,"product_type":"c1","uid":1156207,"ip_address":"","ucode":"7A7DBE3E0EEAEB","user_header":"https://static001.geekbang.org/account/avatar/00/11/a4/6f/672a27d4.jpg","comment_is_top":false,"comment_ctime":1573664004,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573664004","product_id":100039001,"comment_content":"使用的java和kotlin，java不支持多继承，原因是会带来菱形问题，所谓的菱形问题会导致代码会产生歧义，导致不知道到底是继承了谁的方法，因此不支持多继承，可以有多个实现。<br>但是如果实现多个类中有同名的方法还是会产生歧义的问题，最好是避开此问题。<br>不知道理解的对不对","like_count":0},{"had_liked":false,"id":151167,"user_name":"Y024","can_delete":false,"product_type":"c1","uid":1018056,"ip_address":"","ucode":"397126D2E17997","user_header":"https://static001.geekbang.org/account/avatar/00/0f/88/c8/ae476935.jpg","comment_is_top":false,"comment_ctime":1573660025,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1573660025","product_id":100039001,"comment_content":"Day009 05<br>抽象是个神技，在遇到问题时不要只想着如何解决一个具体的问题，要在具体问题答案的基础上，提炼更普遍的方法，即把答案从具体问题中抽离出来，抽象成有效的策略，指导解决未来的类似问题。","like_count":0},{"had_liked":false,"id":151157,"user_name":"L🚲🐱","can_delete":false,"product_type":"c1","uid":1577856,"ip_address":"","ucode":"08A012739614DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","comment_is_top":false,"comment_ctime":1573658963,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573658963","product_id":100039001,"comment_content":"看完今天的文章后，发现我以前写的封装和一坨屎一样，希望学完这个专栏，代码水平有进步💪","like_count":0},{"had_liked":false,"id":151123,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1573655552,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573655552","product_id":100039001,"comment_content":"<br>以下内容基于Java语言<br>1.Java表面不支持多重继承（一个衍生类只能extends一个基类，但可以implements多个接口类）但实际上我认为是支持多重继承的，这一点在多态性上有所体现。<br><br>2.对于封装性，Java提供了语言层面的访问控制（private，protected，default，public）。<br>对于抽象性，Java提供了实例方法（instance method）与抽象方法（abstract method）以支持抽象性。<br>对于继承性，Java提供了extends关键字，藉此衍生类可以继承自基类。<br>对于多态性，Java支持向上转型及向下转型的方式实现灵活的动态绑定。","like_count":0},{"had_liked":false,"id":151106,"user_name":"大豆腐","can_delete":false,"product_type":"c1","uid":1244050,"ip_address":"","ucode":"1E8D4F938F9AEA","user_header":"https://static001.geekbang.org/account/avatar/00/12/fb/92/e3b0e597.jpg","comment_is_top":false,"comment_ctime":1573654187,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573654187","product_id":100039001,"comment_content":"看了一下专栏的加餐部分目录，非常期待。现在的我处于一种非常尴尬的地带，觉得自己的代码写的烂，但是不知道如何优化，工作中遇到的很多问题也不能得心应手。再加上最近入职一家新公司，项目是从别的公司买来的，已经运行了7年，里面的业务，同事也只是略知一二，搞得写一个接口都非常吃力，得花很长时间梳理相关的业务逻辑。","like_count":0},{"had_liked":false,"id":151102,"user_name":"佳民","can_delete":false,"product_type":"c1","uid":1000433,"ip_address":"","ucode":"A5626BAEC96945","user_header":"https://static001.geekbang.org/account/avatar/00/0f/43/f1/3c69eb09.jpg","comment_is_top":false,"comment_ctime":1573653922,"is_pvip":false,"replies":[{"id":"60033","content":"抽象从非常广义的角度来说，可以按照你的理解方式理解。不过，也可以按照我文章中写的面向对象的角度来理解。","user_name":"作者回复","comment_id":151102,"uid":"1190123","ip_address":"","utype":1,"ctime":1574854711,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"1573653922","product_id":100039001,"comment_content":"老师，我学习的面向对象特性中也是没有抽象，我理解的封装是数据保护和实现隐藏，也就是文中的封装和抽象；而我理解的抽象是指设计能力，比如对像泛化（设计父类）、类接口设计等等，这样的理解有偏差么？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474364,"discussion_content":"抽象从非常广义的角度来说，可以按照你的理解方式理解。不过，也可以按照我文章中写的面向对象的角度来理解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574854711,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151100,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1573653521,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1573653521","product_id":100039001,"comment_content":"面向对象的四大特性：<br>封装：数据隐藏，数据保护，对一些属性的操作进行限制<br>抽象：隐藏具体的实现细节，让使用者更加关注于怎么是调用，不需要关心内部的具体实现<br>继承：用来表示 is-a的关系，很好的代码得到复用，分为单继承和多继承<br>多态：子类可以替换父类具体的实现方式，提高代码扩展性","like_count":0},{"had_liked":false,"id":151098,"user_name":"xuanyuan","can_delete":false,"product_type":"c1","uid":1113737,"ip_address":"","ucode":"1EC79B9372868F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2icbib62icXtibTkThtyRksbuJLoTLMts7zook2S30MiaBtbz0f5JskwYicwqXkhpYfvCpuYkcvPTibEaQ/132","comment_is_top":false,"comment_ctime":1573653431,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573653431","product_id":100039001,"comment_content":"1、2的原因都可以归结为语言设计者对语言设计的理念不同<br>另外感觉抽象是另外一个层次的概念，这里描述的抽象可以用封装和多态来承载。或者说封装、继承、多态的最终目的都是抽象。","like_count":0},{"had_liked":false,"id":151091,"user_name":"柳树","can_delete":false,"product_type":"c1","uid":1025223,"ip_address":"","ucode":"F03249D4534BCB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a4/c7/d1ee69c6.jpg","comment_is_top":false,"comment_ctime":1573652612,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573652612","product_id":100039001,"comment_content":"面向对象这几个特性，「封装」和「抽象」感受至深。<br><br>作为一个业务后端，经常要向前端提供接口，前端通过你给的url来操作、查询数据，如何把接口名称、交互行为设计的抽象，又不晦涩难懂，让前端看了知道可以干啥，却又不需要暴露内部细节，把一个模块暴露出去的行为，可以让前端自己玩转起来，是业务后端的一项艺术。<br><br>而如果是中台后端，也同理，只是你提供接口的对象，也许变成了业务后端。","like_count":0},{"had_liked":false,"id":151089,"user_name":"美美","can_delete":false,"product_type":"c1","uid":1148422,"ip_address":"","ucode":"44CC95C45AF345","user_header":"https://static001.geekbang.org/account/avatar/00/11/86/06/72b01bb7.jpg","comment_is_top":false,"comment_ctime":1573652455,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573652455","product_id":100039001,"comment_content":"关于多继承的问题，我是这样理解的，假如支持多继承，两个父类的方法完全一样，那子类继承的是哪一个呢？这样会导致子类行为的不确定性，增加了语言的复杂性","like_count":0},{"had_liked":false,"id":151086,"user_name":"Warn","can_delete":false,"product_type":"c1","uid":1465310,"ip_address":"","ucode":"F2F7FCDB0940D0","user_header":"https://static001.geekbang.org/account/avatar/00/16/5b/de/152f1c2c.jpg","comment_is_top":false,"comment_ctime":1573652060,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573652060","product_id":100039001,"comment_content":"学习，有没有同学分享一下JavaScript，期待","like_count":0},{"had_liked":false,"id":151081,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1573651327,"is_pvip":true,"replies":[{"id":"58366","content":"可以自己上网搜下哈","user_name":"作者回复","comment_id":151081,"uid":"1190123","ip_address":"","utype":1,"ctime":1573789566,"user_name_real":"王争"}],"discussion_count":1,"race_medal":1,"score":"1573651327","product_id":100039001,"comment_content":"duck-typing是个什么概念？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474358,"discussion_content":"可以自己上网搜下哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573789566,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151073,"user_name":"Joanfen","can_delete":false,"product_type":"c1","uid":1004260,"ip_address":"","ucode":"4CF1B92337B625","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/e4/50600574.jpg","comment_is_top":false,"comment_ctime":1573650712,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573650712","product_id":100039001,"comment_content":"阅读者的短句听得有点累，一句话要分成 ABC&#47;DE&#47;FG这样的方式读，英文也是这样读，听那段代码传递的时候听得整个人都懵了","like_count":0},{"had_liked":false,"id":151058,"user_name":"连边","can_delete":false,"product_type":"c1","uid":1391748,"ip_address":"","ucode":"54B5DA38449728","user_header":"https://static001.geekbang.org/account/avatar/00/15/3c/84/608f679b.jpg","comment_is_top":false,"comment_ctime":1573648337,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573648337","product_id":100039001,"comment_content":"看着封装的那一段，我想起了我今天写的php接口，都是直接sql直接干的。","like_count":0},{"had_liked":false,"id":151036,"user_name":"越过大西洋","can_delete":false,"product_type":"c1","uid":1254936,"ip_address":"","ucode":"21FBC3BBCC23B4","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/18/ed6911b7.jpg","comment_is_top":false,"comment_ctime":1573646049,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573646049","product_id":100039001,"comment_content":"PHP 不支持多重继承, 因为多重继承增加了代码的复杂性与含糊性, 存在钻石问题","like_count":0},{"had_liked":false,"id":151032,"user_name":"夜空中最亮的星","can_delete":false,"product_type":"c1","uid":1267566,"ip_address":"","ucode":"ADC3E7B6789955","user_header":"https://static001.geekbang.org/account/avatar/00/13/57/6e/b6795c44.jpg","comment_is_top":false,"comment_ctime":1573645516,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573645516","product_id":100039001,"comment_content":"老师讲的很透彻","like_count":0},{"had_liked":false,"id":151003,"user_name":"Hector","can_delete":false,"product_type":"c1","uid":1496889,"ip_address":"","ucode":"110CAF87ADDC01","user_header":"https://static001.geekbang.org/account/avatar/00/16/d7/39/6698b6a9.jpg","comment_is_top":false,"comment_ctime":1573641353,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573641353","product_id":100039001,"comment_content":"甘若醴泉，代码进阶过程真的像指路明灯","like_count":0},{"had_liked":false,"id":150985,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1573638510,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573638510","product_id":100039001,"comment_content":"Java 不支持多重基础。继承本来就是一个很有争议的用法，多重基础副作用更大，容易造成多个副本的情况，所以Java放弃对多重基础的支持。","like_count":0},{"had_liked":false,"id":150984,"user_name":"冬冬呛","can_delete":false,"product_type":"c1","uid":1247583,"ip_address":"","ucode":"E0EFE04631E1EE","user_header":"https://static001.geekbang.org/account/avatar/00/13/09/5f/64d805c5.jpg","comment_is_top":false,"comment_ctime":1573638445,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573638445","product_id":100039001,"comment_content":"1. java 和 Python 都不支持多重继承的特性，主要还是一种 trade-off ，但分别还是通过接口和 mixin的方式实现了多重继承的功能，带来的复杂性降低了<br>2. Python <br>    1. 封装：通过语法的函数实现<br>    2. 继承：语法提供了支持<br>    3. 多态：语法提供的 duck-typing 实现","like_count":0},{"had_liked":false,"id":150969,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1573636560,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573636560","product_id":100039001,"comment_content":"对于被子类重写的（Override）的方法，javac会在子类的字节码文件中会生成一个桥接方法（留意字节码文件中出现的ACC_BRIDGE, ACC_SYNTHETIC标记的方法）。<br>具体解释请参考https:&#47;&#47;time.geekbang.org&#47;column&#47;article&#47;41800","like_count":0},{"had_liked":false,"id":150945,"user_name":"冬渐暖","can_delete":false,"product_type":"c1","uid":1586800,"ip_address":"","ucode":"907E41AAE9A36C","user_header":"https://static001.geekbang.org/account/avatar/00/18/36/70/00122b24.jpg","comment_is_top":false,"comment_ctime":1573633168,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1573633168","product_id":100039001,"comment_content":"为什么Java中不支持多重继承？<br>为什么Java不支持多重继承, 可以考虑以下两点:<br>1)第一个原因是围绕钻石形继承问题产生的歧义，<br>超父类、父类、子类如果有同一个方法，系统都不知道用哪个。<br>考虑一个类 A 有 foo() 方法, 然后 B 和 C 派生自 A, 并且有自己的 foo() 实现，现在 D 类使用多个继承派生自 B 和C，如果我们只引用 foo(), 编译器将无法决定它应该调用哪个 foo()。这也称为 Diamond 问题，因为这个继承方案的结构类似于菱形，见下图:<br><br>即使我们删除钻石的顶部 A 类并允许多重继承，我们也将看到这个问题含糊性的一面。如果你把这个理由告诉面试官，他会问为什么 C++ 可以支持多重继承而 Java不行。嗯，在这种情况下，我会试着向他解释我下面给出的第二个原因，它不是因为技术难度, 而是更多的可维护和更清晰的设计是驱动因素, 虽然这只能由 Java 言语设计师确认，我们只是推测。维基百科链接有一些很好的解释，说明在使用多重继承时，由于钻石问题，不同的语言地址问题是如何产生的。<br>2)对我来说第二个也是更有说服力的理由是，多重继承确实使设计复杂化并在转换、构造函数链接等过程中产生问题。假设你需要多重继承的情况并不多，简单起见，明智的决定是省略它。此外，Java 可以通过使用接口支持单继承来避免这种歧义。由于接口只有方法声明而且没有提供任何实现，因此只有一个特定方法的实现，因此不会有任何歧义。<br><br>Java不支持多继承其实主要就是在规范了代码实现的同时，也产生了一些局限性， 影响着程序设计结构。<br><br>当然，上面的是我之前在某个地方看到然后抄下来当笔记的 。<br>说实话，看这讲的时候，但凡有点java基础的，都会感觉看的很轻松的，尤其是这个钱包例子  哈哈<br><br>关于接口，没工作之前认为就是写个service什么的就可以，结果工作之后发现是controller。。。。<br>个人认为就是大点的代理模式。拿你说的图片存储来说吧，个人是把这些地址写到配置文件&#47;数据库字典表里。<br>","like_count":0,"discussions":[{"author":{"id":1016594,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/83/12/4ba82798.jpg","nickname":"我是智障","note":"","ucode":"ED9D959423E024","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49949,"discussion_content":"全是 copy 的吧，评论发表之前自己过一下子好嘛，图在哪里啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573652751,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1586800,"avatar":"https://static001.geekbang.org/account/avatar/00/18/36/70/00122b24.jpg","nickname":"冬渐暖","note":"","ucode":"907E41AAE9A36C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1016594,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/83/12/4ba82798.jpg","nickname":"我是智障","note":"","ucode":"ED9D959423E024","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50327,"discussion_content":"😭疏忽了 本来还准备去掉那些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573706299,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":49949,"ip_address":""},"score":50327,"extra":""}]}]},{"had_liked":false,"id":150938,"user_name":"qqq","can_delete":false,"product_type":"c1","uid":1006786,"ip_address":"","ucode":"91B0ACF8CBE7BD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/c2/8ffd2ad0.jpg","comment_is_top":false,"comment_ctime":1573631866,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1573631866","product_id":100039001,"comment_content":"# 面向对象四大特点<br><br>## 封装（Encapsulation）<br><br>### 解释：信息隐藏或者数据访问保护<br><br>### 实现方式：访问权限控制<br><br>### 解决问题：提高易用性、可维护性<br><br>## 抽象（Abstracttion）<br><br>### 解释：隐藏方法的具体实现<br><br>### 实现方式：接口类、抽象类、函数语法机制<br><br>### 解决问题：不必关心实现细节<br><br>### 类方法命名，不用关心实现逻辑：getAliyunPictureUrl =&gt; getPictureUrl<br><br>## 继承（Inheritance）<br><br>### 解释：代码复用、避免重复，符合认知<br><br>### 分类：单继承、多继承<br><br>### 问题：继承层次过多，可读性、可维护性变差。多用组合少用继承<br><br>## 多态（Polymorphism）<br><br>### 解释：子类替换父类<br><br>### 实现方式：<br><br>- 继承 + 方法重写<br>- 接口类<br>- duck-typeing: 定义同一个方法<br><br>### 解决问题：可扩展性、复用性<br><br>","like_count":0},{"had_liked":false,"id":150903,"user_name":"啦啦啦","can_delete":false,"product_type":"c1","uid":1131687,"ip_address":"","ucode":"6B12EC90A62525","user_header":"https://static001.geekbang.org/account/avatar/00/11/44/a7/171c1e86.jpg","comment_is_top":false,"comment_ctime":1573624895,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573624895","product_id":100039001,"comment_content":"interface testInter{<br>      function testEcho();<br>}<br><br>class test1{<br><br>      function testEcho(){<br>\t\t  <br>\t\t  return &#39;test1&#39;;<br>\t  }<br>}<br><br><br>class test2{<br>\t  function testEcho(){<br>\t\t  return &#39;test2&#39;;<br>\t  }<br>\t<br>}<br><br><br>class demo{<br>\tprivate function printTest($object){<br>\t\tvar_dump($object-&gt;testEcho());<br>\t}<br>\t<br>\tpublic function demoEcho(){<br>\t\t$test1 = new test1();<br>\t\t$this-&gt;printTest($test1);<br>\t\t<br>\t\t$test2 = new test2();<br>\t\t$this-&gt;printTest($test2);<br>\t\t<br>\t}\t<br>}<br><br>$demo = new demo();<br>$demo-&gt;demoEcho();<br><br>照着老师写的例子写了个php的阉割版的利用接口类实现的多态，哈哈哈","like_count":0},{"had_liked":false,"id":150902,"user_name":"不与三季人说","can_delete":false,"product_type":"c1","uid":1693164,"ip_address":"","ucode":"A3F03832309FDD","user_header":"https://static001.geekbang.org/account/avatar/00/19/d5/ec/3d6e7ea7.jpg","comment_is_top":false,"comment_ctime":1573624684,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573624684","product_id":100039001,"comment_content":"这几节课偏基础一些，都是很基本的概念，不过听老师说一遍还是又加深了一遍印象，java只能单继承，但是可以多实现，设计者这所以这样肯定是考虑了得失，避免一些问题，像二义性虽然会存在，但是多继承的语言也是可以通过其他的方式进行解决，所以单继承和多继承都有各自的取舍，不能说哪个好哪个不好，语言本身都是艺术，都是美。","like_count":0},{"had_liked":false,"id":150896,"user_name":"刘大明","can_delete":false,"product_type":"c1","uid":1035081,"ip_address":"","ucode":"83C063FBD9BF2B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cb/49/0b9ffc8e.jpg","comment_is_top":false,"comment_ctime":1573623543,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1573623543","product_id":100039001,"comment_content":"以前没有考虑过多继承会有菱形问题。这次受教了。","like_count":0,"discussions":[{"author":{"id":1045455,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f3/cf/851dab01.jpg","nickname":"Milittle","note":"","ucode":"80E566639A8ABB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50222,"discussion_content":"很经典的问题  加油 共勉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573693634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150887,"user_name":"WIZ","can_delete":false,"product_type":"c1","uid":1260348,"ip_address":"","ucode":"313AF84674475C","user_header":"https://static001.geekbang.org/account/avatar/00/13/3b/3c/2947127c.jpg","comment_is_top":false,"comment_ctime":1573621452,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573621452","product_id":100039001,"comment_content":"打卡<br>1。c#是不支持多继承的，因为多继承会让代码变得混乱，微软认为其优势抵不上其增加的复杂性，故舍弃<br>2。c#是有现成的语法机制支持4大特性的，在c#中一般说是三大，不包括抽象，封装除了手动实现，还可以直接用属性访问器来控制，继承，允许继承多个接口，但只能继承一个类，也是用:来标识；既然支持继承，那么相应的也支持多态，重写即是多态的一种体现，注意是重写而不是重载。简单点说，多态就是能够调用什么方法由变量类型决定，到底执行哪个方法由实际指向的对象决定。","like_count":0},{"had_liked":false,"id":150885,"user_name":"旺旺","can_delete":false,"product_type":"c1","uid":1159196,"ip_address":"","ucode":"FE2CF90F446BFB","user_header":"https://static001.geekbang.org/account/avatar/00/11/b0/1c/2e30eeb8.jpg","comment_is_top":false,"comment_ctime":1573620953,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573620953","product_id":100039001,"comment_content":"多重继续比较复杂，而且实际上人们在看到多重继承的时候也自己会被绕晕，不利于人们理解。<br>所以还是像Java那样，利用多个接口来实现比较清晰容易理解。","like_count":0},{"had_liked":false,"id":150862,"user_name":"靠人品去赢","can_delete":false,"product_type":"c1","uid":1301286,"ip_address":"","ucode":"7A20F9EBE847E1","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/26/54f2c164.jpg","comment_is_top":false,"comment_ctime":1573617740,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573617740","product_id":100039001,"comment_content":"这个封装结合业务讲得很好，钱包向外透露信息的控制，很有说服力。<br>关于多态，我看到很多书把接口的实现也算在多态里，到底算不算，其实可不可以看成特殊的继承。<br>还有就是子类代替父类，一些模式像工厂模式有自己的实现，很给力。","like_count":0},{"had_liked":false,"id":150846,"user_name":"do it","can_delete":false,"product_type":"c1","uid":1309911,"ip_address":"","ucode":"E0753912E8F2AF","user_header":"https://static001.geekbang.org/account/avatar/00/13/fc/d7/b102034a.jpg","comment_is_top":false,"comment_ctime":1573616343,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573616343","product_id":100039001,"comment_content":"C++支持多重继承，也带来了菱形继承问题，一般解决办法就是采用虚继承了","like_count":0},{"had_liked":false,"id":150844,"user_name":"丿淡忘","can_delete":false,"product_type":"c1","uid":1139645,"ip_address":"","ucode":"604AE01961A026","user_header":"https://static001.geekbang.org/account/avatar/00/11/63/bd/80f587ad.jpg","comment_is_top":false,"comment_ctime":1573616307,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1573616307","product_id":100039001,"comment_content":"用的c++，c++ 属于相信程序员的语言，认为程序员可以去做正确的事，支持多继承，对于钻石继承的问题，一般是采用虚继承的方式来解决，子类继承的两个父类，有同一个祖父类，使用虚继承后，子类只会创建一次两个父类具有的相同祖父类内容，从而解决钻石继承的问题，但一般情况还是别搞钻石继承","like_count":0},{"had_liked":false,"id":150843,"user_name":"shniu","can_delete":false,"product_type":"c1","uid":1019555,"ip_address":"","ucode":"E64CD8BED96D8D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/a3/d7e5fe8a.jpg","comment_is_top":false,"comment_ctime":1573616025,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573616025","product_id":100039001,"comment_content":"1. 用过Java，Java支持单继承、支持实现多个接口；多重继承带来很多副作用，比如二义性（菱形继承，用Python的时候有体会）、类型转换只能在运行时确定而不是编译阶段等，解决这些问题的麻烦大于他带来的好处；比如golang就没有直观的继承概念，而是使用duck-typing的机制。可以读一下这个 - <br> https:&#47;&#47;www.zhihu.com&#47;question&#47;31377101&#47;answer&#47;403757577。Python 支持多重继承，可以考虑使用Mixin机制来避免副作用，优先考虑通过多重继承来组合多个Mixin的功能，而不是设计多层次的复杂的继承关系；此外，python中出现二义性的解决方式是MRO算法，基本就是按照继承顺序来找真实要调用的方法。<br>2. Java是支持的，就不做分析了。Golang 显示的支持抽象、多态、封装，继承没有显示支持，go是一种Prototype-base的语言，对于抽象，go提供了函数、interface type、 struct type等；对于多态，go采用interface-type，然后使用 duck-typing来实现多态；对于封装，在 struct type 中可以声明成员变量和方法，小写字母开头的变量和方法是内部私有，外部无法访问，大写字母开头的变量和方法可以外部直接访问。","like_count":0},{"had_liked":false,"id":150841,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1573615816,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573615816","product_id":100039001,"comment_content":"第一遍 没理解到抽象和多态的区别 抽象主要是针对方法来说  多态则是针对类来说 如果该类实现了接口类或者抽象类的方法 并且继承自接口类和抽象类 那么就可以通过多态加上函数调用实现抽象 这也是为啥子 抽象 在很多地方没有被加入面向对象的特性的原因吧！所以很多时候都说面向对象的三大特性 封装 继承 多态","like_count":0},{"had_liked":false,"id":150834,"user_name":"pines","can_delete":false,"product_type":"c1","uid":1200708,"ip_address":"","ucode":"7B925605B36B4E","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/44/de7f2b98.jpg","comment_is_top":false,"comment_ctime":1573615063,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573615063","product_id":100039001,"comment_content":"Go语言中没有继承，只有组合，C++倒是支持多继承，不过会有菱形继承的问题，解决方案，就是加virtual关键字，虚继承","like_count":0},{"had_liked":false,"id":150831,"user_name":"柳志焕","can_delete":false,"product_type":"c1","uid":1235940,"ip_address":"","ucode":"42375930DC2AA0","user_header":"https://static001.geekbang.org/account/avatar/00/12/db/e4/a1b45d79.jpg","comment_is_top":false,"comment_ctime":1573614742,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573614742","product_id":100039001,"comment_content":"Java 不支持多继承，主要原因是多继承会让语言本身变得非常复杂（如同 C++），效率也会降低。事实上，接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性。","like_count":0},{"had_liked":false,"id":150829,"user_name":"Eden Ma","can_delete":false,"product_type":"c1","uid":1457408,"ip_address":"","ucode":"755312F0D154F9","user_header":"https://static001.geekbang.org/account/avatar/00/16/3d/00/7daa7403.jpg","comment_is_top":false,"comment_ctime":1573614121,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573614121","product_id":100039001,"comment_content":"OC 1、不支持多重继承，因为菱形继承问题。<br>2、支持四大特性，简单列举一些，封装可以通过类扩展和@private来控制属性访问权限，可以用协议作为抽象基类，多态系统类很多地方都有用到比如类簇NSNumber。","like_count":0},{"had_liked":false,"id":150826,"user_name":"塔兹米","can_delete":false,"product_type":"c1","uid":1425252,"ip_address":"","ucode":"1A58C81EF9B0A4","user_header":"https://static001.geekbang.org/account/avatar/00/15/bf/64/c9a0e913.jpg","comment_is_top":false,"comment_ctime":1573613982,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573613982","product_id":100039001,"comment_content":"打卡。<br>Java为什么不支持多继承。<br><br>1.因为子类继承了2个父类，父类都继承与一个祖父类的话，那就不能分辨他们重写的方法了。<br>2.关键字 super 代表父类对象，多个父类的话，那就不晓得到底代表谁了。","like_count":0},{"had_liked":false,"id":150814,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1573613015,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573613015","product_id":100039001,"comment_content":"不支持多继承的原因在于 如果层次过多 会导致类里面的成员或者方法很多 多则乱","like_count":0},{"had_liked":false,"id":150810,"user_name":"Gavin🦅","can_delete":false,"product_type":"c1","uid":1459226,"ip_address":"","ucode":"3E7F0211FB1EC5","user_header":"https://static001.geekbang.org/account/avatar/00/16/44/1a/792a9a89.jpg","comment_is_top":false,"comment_ctime":1573612722,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573612722","product_id":100039001,"comment_content":"在我看来关于OC的代理 Swift的协议都是基于多态特性的, 这种想法对么?","like_count":0},{"had_liked":false,"id":150805,"user_name":"Lifelong Learning","can_delete":false,"product_type":"c1","uid":1173517,"ip_address":"","ucode":"3E39BED3E13FB4","user_header":"https://static001.geekbang.org/account/avatar/00/11/e8/0d/fcd95db8.jpg","comment_is_top":false,"comment_ctime":1573612066,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573612066","product_id":100039001,"comment_content":"总结:<br>面对对象编程的四大特性---封装,抽象,继承,多态<br>1.封装<br>就是将一些属性,方法等包裹在一个类中,通过语言本身提供的机制对封装的内容进行不同作用域的访问,这样其实类似让使用者知道那些是可以访问,而让设计者可以不断的去迭代和更改那些私有的属性和方法.<br>2.抽象<br>语言中的基本功能---函数,其实就是提供了这个功能,java中通过interface class接口类和abstract class抽象类就是通过函数来实现的,使用者只要知道这个函数是做什么的,而不需要关心具体的实现细节(就是所谓的方法体)<br>3.继承<br>继承分为单继承和多继承两类,像java,php等就是单继承,而c++,python等就是多继承,多继承只要的弊病在子类继承多个父类后在访问相同的属性或者方法时就是不知道访问那个父类继承的属性和方法了,而继承在实际运用中也会产生多层继承,这样其实也造成程序的可读性和高耦合,父类中属性或者方法更改后会影响其他子类,所以建议不要使用多层继承<br>4.多态<br>所谓的多态就是一种行为有多种状态,既多种的表现形式,在java中主要有三种实现多态的方法---1.overload重载和override覆盖;2.利用interface接口类进行方法的override覆盖,每个实现接口的类都可以对方法进行具体的实现(java1.8以后接口类中可以有默认的方法实现,但是在实现接口的类也可以对其进行覆盖,这样也就避免了接口多继承带来的指向不明确的问题);3.通过抽象类进行方法的覆盖,在抽象类中的抽象的方法(用public abstract修饰的方法)必须在在子类中进行实现(除非子类也是抽象类),这样同样实现的多态","like_count":0},{"had_liked":false,"id":150798,"user_name":"青青子衿","can_delete":false,"product_type":"c1","uid":1438102,"ip_address":"","ucode":"4A388A3BA70C29","user_header":"https://static001.geekbang.org/account/avatar/00/15/f1/96/9571fa3d.jpg","comment_is_top":false,"comment_ctime":1573611124,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573611124","product_id":100039001,"comment_content":"讲得非常到位","like_count":0},{"had_liked":false,"id":150797,"user_name":"肥而不腻","can_delete":false,"product_type":"c1","uid":1435246,"ip_address":"","ucode":"3E6786A82A6DD6","user_header":"https://static001.geekbang.org/account/avatar/00/15/e6/6e/062da5e4.jpg","comment_is_top":false,"comment_ctime":1573611038,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573611038","product_id":100039001,"comment_content":"已学习今日份文档和评论！","like_count":0},{"had_liked":false,"id":150792,"user_name":"稳","can_delete":false,"product_type":"c1","uid":1284626,"ip_address":"","ucode":"BF5723E63E4115","user_header":"https://static001.geekbang.org/account/avatar/00/13/9a/12/06863960.jpg","comment_is_top":false,"comment_ctime":1573610833,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573610833","product_id":100039001,"comment_content":"凑凑热闹写写Python<br>1、支持多重继承。对于菱形继承问题，通过深度优先和广度优先来确定；<br>2、对于封装不支持，猜测是为了语法的简洁；抽象是通过ABC抽象类；继承和多态老师文章讲过，就不多说了","like_count":0},{"had_liked":false,"id":150790,"user_name":"yz","can_delete":false,"product_type":"c1","uid":1256001,"ip_address":"","ucode":"D646E3BDD795A2","user_header":"https://static001.geekbang.org/account/avatar/00/13/2a/41/6116db1b.jpg","comment_is_top":false,"comment_ctime":1573610750,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1573610750","product_id":100039001,"comment_content":"C#是支持多重继承的吧。","like_count":0,"discussions":[{"author":{"id":1011793,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/70/51/f1825adb.jpg","nickname":"Lugyedo","note":"","ucode":"EB5E456B638E70","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49801,"discussion_content":"和Java一样不支持多重继承","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573638959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150787,"user_name":"moqifei","can_delete":false,"product_type":"c1","uid":1358410,"ip_address":"","ucode":"E0A6C858B78A3A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLGovXf8jNP5ZqHsDKLwajjicbFwpX9on1xiaJDR4CgWaWP2KcfOdneasBfKFo3dO3dwQyGG6WjK40w/132","comment_is_top":false,"comment_ctime":1573610319,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573610319","product_id":100039001,"comment_content":"爬行类( Reptilia)由石炭纪末期的古代两栖类进化而来，心脏有两心房一心室，心室有不完全隔膜，体温不恒定，是真正适应陆栖生活的变温脊椎动物，并由此产生出恒温的鸟类和哺乳类。爬行类不仅在成体结构上进一步适应陆地生活，其繁殖也脱离了水的束缚，与鸟类、哺乳类共称为羊膜动物(amniota)。","like_count":0},{"had_liked":false,"id":150785,"user_name":"熊斌","can_delete":false,"product_type":"c1","uid":1026280,"ip_address":"","ucode":"24D0C32F397113","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a8/e8/bc84c47d.jpg","comment_is_top":false,"comment_ctime":1573610012,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1573610012","product_id":100039001,"comment_content":"我用的时Java语言，不支持通过extends关键字进行多重继承。留言区已经有同学解释了原因。<br><br>我有个疑问，Java语言的内部类是否是解决多重继承的一种方案？","like_count":0},{"had_liked":false,"id":150783,"user_name":"coder王","can_delete":false,"product_type":"c1","uid":1121990,"ip_address":"","ucode":"21465DC3850BCB","user_header":"https://static001.geekbang.org/account/avatar/00/11/1e/c6/6f817e6e.jpg","comment_is_top":false,"comment_ctime":1573609917,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573609917","product_id":100039001,"comment_content":"对于Java来说，虽然不支持多继承，但是可以通过组合方式来实现多继承的功能，主要是复用代码，文章都提到了😁","like_count":0},{"had_liked":false,"id":150781,"user_name":"KaitoShy","can_delete":false,"product_type":"c1","uid":1038415,"ip_address":"","ucode":"E2E2E9BD3F5048","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d8/4f/65abc6f0.jpg","comment_is_top":false,"comment_ctime":1573609899,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573609899","product_id":100039001,"comment_content":"1.  php 不支持多继承，可能是和C实现的机制有关，猜想的原因可能和棱形继承有关,有待研究一下php的源码；实现的方式是interface方式或者 trait<br>2. php 有现有语法支持。<br>像python，php 这种C-Like语言，由于 C 语言是在现有的语法层面是没有支持的，或者在设计C语言的时候OOP是不怎么流行。C 实现 OOP 的方式是用type struct。","like_count":0,"discussions":[{"author":{"id":1047733,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fc/b5/ac717737.jpg","nickname":"肖臧","note":"","ucode":"4FAC9FF54DD6A0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":230961,"discussion_content":"单例本来就推荐用无参构造函数，要更新成员变量的值，写个update函数嘛","likes_number":38,"is_delete":false,"is_hidden":false,"ctime":1586782977,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":2015438,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/c0/ce/eb1b4ae1.jpg","nickname":"可圈可丶","note":"","ucode":"EB527E176EDE91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1047733,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fc/b5/ac717737.jpg","nickname":"肖臧","note":"","ucode":"4FAC9FF54DD6A0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312845,"discussion_content":"正解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602831813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":230961,"ip_address":""},"score":312845,"extra":""},{"author":{"id":1438860,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f4/8c/0866b228.jpg","nickname":"子房","note":"","ucode":"CB05938C248BB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1047733,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fc/b5/ac717737.jpg","nickname":"肖臧","note":"","ucode":"4FAC9FF54DD6A0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340964,"discussion_content":"正确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610246255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":230961,"ip_address":""},"score":340964,"extra":""},{"author":{"id":2475056,"avatar":"https://static001.geekbang.org/account/avatar/00/25/c4/30/711b03e5.jpg","nickname":"Geek_Candice","note":"","ucode":"0F2CBCF624F905","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1047733,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fc/b5/ac717737.jpg","nickname":"肖臧","note":"","ucode":"4FAC9FF54DD6A0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388366,"discussion_content":"正","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628732240,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":230961,"ip_address":""},"score":388366,"extra":""}]},{"author":{"id":1019588,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8e/c4/8d1150f3.jpg","nickname":"Richie","note":"","ucode":"12314EF0347693","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":200062,"discussion_content":"第2个问题中，按照这种写法，就不是单例了，存在多次相同参数的调用，返回不同对象实例的情况。","likes_number":29,"is_delete":false,"is_hidden":false,"ctime":1583653651,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1019588,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8e/c4/8d1150f3.jpg","nickname":"Richie","note":"","ucode":"12314EF0347693","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591560,"discussion_content":"多次参数相同，代码中已经做了判断，返回的是同一个对象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666663265,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":200062,"ip_address":"北京"},"score":591560,"extra":""},{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1019588,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8e/c4/8d1150f3.jpg","nickname":"Richie","note":"","ucode":"12314EF0347693","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591561,"discussion_content":"但是代码没有做到多线程安全性. 需要通过double-check方式来做判断","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666663485,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":200062,"ip_address":"北京"},"score":591561,"extra":""}]},{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":165415,"discussion_content":"我觉得应该抛异常。因为重新new就不是单例了，更新参数，多线程会出现异常也不行。 作为一个单例，它要保证唯一和全局共享两个特性，所以不建议重复构建和更新值。","likes_number":22,"is_delete":false,"is_hidden":false,"ctime":1581292853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1094597,"avatar":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","nickname":"Liam","note":"","ucode":"1D15D3B64F2606","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":175813,"discussion_content":"1 单例可以依赖注入，mock类即可\n2 第一次初始化之后，不允许重复初始化，应该抛出异常","likes_number":21,"is_delete":false,"is_hidden":false,"ctime":1581996201,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1257453,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2f/ed/a87bb8fa.jpg","nickname":"此鱼不得水","note":"","ucode":"95268E823FB4D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":163055,"discussion_content":"既然是单例，就不应该重新创建一个吧，如果已经存在了instance成员变量的值不一样的话，应该直接抛错吧。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1581045078,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1132337,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","nickname":"小晏子","note":"","ucode":"3AAA6FB5ACB6AE","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":1257453,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2f/ed/a87bb8fa.jpg","nickname":"此鱼不得水","note":"","ucode":"95268E823FB4D2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":163074,"discussion_content":"如果直接抛错就跟这种方案的设计初衷违背了，因为它需要根据不同的参数生成不同的instance，如果抛错，那就不需要传递参数进来了。其实这种用法就比较奇怪，我的理解就是设计者希望对应不同的参数有不同的instance，但是对于同样的一组参数，instance是相同的，这是我的理解。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1581046512,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":163055,"ip_address":""},"score":163074,"extra":""},{"author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1132337,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","nickname":"小晏子","note":"","ucode":"3AAA6FB5ACB6AE","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":163150,"discussion_content":"但是这样还是解决不了ABA问题，先来个A参数，新生成了一个对象，然后来了B，对象被重新创建，这时候A又来了，这第一个A的参数就和第三个A的参数是两个对象了。也没有达到单例的效果。\n\n如每次只更新不重新创建，就会存在我用着用着，对象参数就被改了。也是很头疼(´;︵;`)","likes_number":12,"is_delete":false,"is_hidden":false,"ctime":1581054168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":163074,"ip_address":""},"score":163150,"extra":""},{"author":{"id":1132337,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","nickname":"小晏子","note":"","ucode":"3AAA6FB5ACB6AE","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":163194,"discussion_content":"你说的是，所以这种用法我从没见过，也是看这个课程才知道的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581059144,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":163150,"ip_address":""},"score":163194,"extra":""}]},{"author":{"id":1052859,"avatar":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","nickname":"Demon.Lee","note":"","ucode":"7F0E5493A8E345","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302699,"discussion_content":"第2道题，我怎么感觉老师的目的是为了给后面的工厂模式进行铺垫呢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599011637,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316993,"avatar":"https://static001.geekbang.org/account/avatar/00/14/18/81/83b6ade2.jpg","nickname":"好吃不贵","note":"","ucode":"6576E2BECE4F7C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":163145,"discussion_content":"是不是可以写个函数，update下paramA和paramB就好，不用再new Singleton了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581053035,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1132337,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","nickname":"小晏子","note":"","ucode":"3AAA6FB5ACB6AE","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":1316993,"avatar":"https://static001.geekbang.org/account/avatar/00/14/18/81/83b6ade2.jpg","nickname":"好吃不贵","note":"","ucode":"6576E2BECE4F7C","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":163195,"discussion_content":"嗯 是的，我这个写法确实不如直接更新好，好像改不了了，呵呵","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581059192,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":163145,"ip_address":""},"score":163195,"extra":""},{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1316993,"avatar":"https://static001.geekbang.org/account/avatar/00/14/18/81/83b6ade2.jpg","nickname":"好吃不贵","note":"","ucode":"6576E2BECE4F7C","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":591562,"discussion_content":"这个会在不知不觉中修改了其他人的代码逻辑吧。因为单例的本质是全局只存在一个对象，其他人的代码逻辑也有可能使用不同的参数对应的单例对象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666663590,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":163145,"ip_address":"北京"},"score":591562,"extra":""}]},{"author":{"id":1732780,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","nickname":"面向百度编程","note":"","ucode":"8FE04A019D71D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":236098,"discussion_content":"直接判断instance不为null不就可以了么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587053529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150769,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1573608647,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573608647","product_id":100039001,"comment_content":"地铁打卡","like_count":0},{"had_liked":false,"id":150768,"user_name":"William","can_delete":false,"product_type":"c1","uid":1346215,"ip_address":"","ucode":"55F5D9DEE485B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","comment_is_top":false,"comment_ctime":1573608579,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1573608579","product_id":100039001,"comment_content":"面向对象特性： 封装、继承 、多态、抽象.<br><br>封装：封装属性，减少暴露不必要的属性，增加零散属性的管理.<br>继承： is-a关系，属于子类是具有父类的特征. <br>            子类可以调用父类的属性<br>多态：子类可以重写父类的方法. <br>           同一个类内部可以重载方法. <br>抽象：提取公共的方法，子类或者实现类重写. 各自按照自己的特性实现逻辑处理.","like_count":0},{"had_liked":false,"id":150760,"user_name":"小畅","can_delete":false,"product_type":"c1","uid":1322880,"ip_address":"","ucode":"D031CC07CD564E","user_header":"","comment_is_top":false,"comment_ctime":1573607679,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573607679","product_id":100039001,"comment_content":"看到留言，php估计考虑到易用性吧，不支持多继承，没有那么复杂，多继承会导致棱形问题，父类的属性和函数有二义性","like_count":0},{"had_liked":false,"id":150759,"user_name":"风行者","can_delete":false,"product_type":"c1","uid":1541934,"ip_address":"","ucode":"F058640CF77A35","user_header":"https://static001.geekbang.org/account/avatar/00/17/87/2e/ea54c240.jpg","comment_is_top":false,"comment_ctime":1573607514,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573607514","product_id":100039001,"comment_content":"1)封装，隐藏属性与方法，如操作系统仅公开系统调用，让被调用方的学习成本更低，另外也让维护者从代码角度了解更多的类的设计意图，如有哪些对象属性是创建时候初始化的，有哪些是外界行为产生的。<br>2）继承，父子代码复用，让整个代码结构更加清晰，但是太多层的继承跳转也让代码很难读。java的继承（extends)只能支持继承一个类，继承多个类会导致子类无法明确导致该引用哪个父类（拥有相同的方法签名和属性）的属性或方法","like_count":0},{"had_liked":false,"id":150753,"user_name":"啦啦啦","can_delete":false,"product_type":"c1","uid":1131687,"ip_address":"","ucode":"6B12EC90A62525","user_header":"https://static001.geekbang.org/account/avatar/00/11/44/a7/171c1e86.jpg","comment_is_top":false,"comment_ctime":1573607075,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573607075","product_id":100039001,"comment_content":"php不支持多继承，个人感觉就是因为多继承会带来的副作用多吧","like_count":0},{"had_liked":false,"id":150750,"user_name":"Geek_4e58c9","can_delete":false,"product_type":"c1","uid":1541413,"ip_address":"","ucode":"C1507B6BCCF4F0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/FpudwHOvLaFheC6EiboZsfEQGtvEWykGNTCC3AUM7L9sReWZ7TVicJ73uV1sZ3jbRibYj2NasLHAkLmn7p8FkW2Cg/132","comment_is_top":false,"comment_ctime":1573606902,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573606902","product_id":100039001,"comment_content":"不推荐继承的原因：父类的修改会影响到自己类的功能","like_count":0},{"had_liked":false,"id":150748,"user_name":"啦啦啦","can_delete":false,"product_type":"c1","uid":1131687,"ip_address":"","ucode":"6B12EC90A62525","user_header":"https://static001.geekbang.org/account/avatar/00/11/44/a7/171c1e86.jpg","comment_is_top":false,"comment_ctime":1573606865,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573606865","product_id":100039001,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":150740,"user_name":"yuerling","can_delete":false,"product_type":"c1","uid":1235297,"ip_address":"","ucode":"C9A20A4A9B7FA4","user_header":"https://static001.geekbang.org/account/avatar/00/12/d9/61/f7a59630.jpg","comment_is_top":false,"comment_ctime":1573606283,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573606283","product_id":100039001,"comment_content":"老师，当策略模式，策略过多膨胀时有什么好的方法可以优雅的解决嘛","like_count":0},{"had_liked":false,"id":150735,"user_name":"青青木","can_delete":false,"product_type":"c1","uid":1049870,"ip_address":"","ucode":"2732BA6FBC149D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJKILshrJiasJADt0FTdA9x9rJbSeM3t7BUgUxKqBpsZK4Uukg9qwmbOCmLia89VaqsPcKyauGBLRFw/132","comment_is_top":false,"comment_ctime":1573605904,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573605904","product_id":100039001,"comment_content":"Java接口我理解是一种行为约定，当一个类实现一个接口时就有了这个接口定义的行为，一个类是可以有多个行为的因此Java允许多接口继承，但是从单一接口原则考虑 类还是继承少量必要接口，不要搞成大杂烩。","like_count":0},{"had_liked":false,"id":150734,"user_name":"刘润森","can_delete":false,"product_type":"c1","uid":1236556,"ip_address":"","ucode":"84101C670A6747","user_header":"https://static001.geekbang.org/account/avatar/00/12/de/4c/a51ece16.jpg","comment_is_top":false,"comment_ctime":1573605791,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573605791","product_id":100039001,"comment_content":"python动态语言，没有访问的限制，也没有接口的定义，继承也可以多继承。","like_count":0},{"had_liked":false,"id":150731,"user_name":"轨迹","can_delete":false,"product_type":"c1","uid":1026737,"ip_address":"","ucode":"B212E2582B38CE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/aa/b1/52d2871f.jpg","comment_is_top":false,"comment_ctime":1573605475,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573605475","product_id":100039001,"comment_content":"我觉得封装还有其他优点，例如:组织代码。如，表示一个人的类，就有身高，体重，住址，爱好等等信息，封装成一个类，比直接定义零散的变量要好","like_count":0},{"had_liked":false,"id":150723,"user_name":"koo","can_delete":false,"product_type":"c1","uid":1149276,"ip_address":"","ucode":"D612E52B5D90BB","user_header":"https://static001.geekbang.org/account/avatar/00/11/89/5c/89f7bc6b.jpg","comment_is_top":false,"comment_ctime":1573604870,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1573604870","product_id":100039001,"comment_content":"地铁上学习专栏，干货已学习，代码今天抽时间实现揣摩揣摩。<br>OC既支持多继承，也支持多态。但也正是因为支持多继承导致自己在开发使用中基础类与各个子类之间各自特性随着迭代越来越臃肿。这边方面技能很薄弱有待提升，希望通过专栏能得到改善。👻👻👻","like_count":0,"discussions":[{"author":{"id":1387712,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N6yjnrLnMW4XVSkBr3f0N3F962l35b5j0kib9VSlAqqbf6iaoCPicL1WnJ9KjgT4egQ7A2G0Zx3OayaK4yuoZrUVA/132","nickname":"worthto","note":"","ucode":"41D7ABBBD2E7FF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261030,"discussion_content":"个人觉得mock代码放入到正常的代码示例中，是不可取的，侵入性太强。现有的代码中有太多的单例，可以考虑重写现有的单例对象的newStance方法，然后再依赖注入一个单例对象的生成器InstanceBuilder类，把创建的方法放到这个类中。这样的话，就把创建这个单例对象的逻辑解耦了，单例只负责单例对象的管理。职责也单一。","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1588931903,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1611025,"avatar":"https://static001.geekbang.org/account/avatar/00/18/95/11/eb431e52.jpg","nickname":"沈康","note":"","ucode":"02AFA50738AB8E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":165097,"discussion_content":"第一种方法不好呀，感觉1楼的好点","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1581254603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1019588,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8e/c4/8d1150f3.jpg","nickname":"Richie","note":"","ucode":"12314EF0347693","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":200069,"discussion_content":"第一问的回答中，我觉得思路不错，但是代码写法有点问题。要Mock的应该是CacheManager实例，而不是User实例；而且，getInstance()方法本是无参数的，这样写就不兼容了，语义上也不对，方法返回的应该是CacheManager对象而不是User对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583654117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150720,"user_name":"泰伦卢","can_delete":false,"product_type":"c1","uid":1141994,"ip_address":"","ucode":"FEA6B43C8D4FF9","user_header":"https://static001.geekbang.org/account/avatar/00/11/6c/ea/e03fec22.jpg","comment_is_top":false,"comment_ctime":1573604725,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1573604725","product_id":100039001,"comment_content":"C++支持多重继承，尽管支持，但感觉这个东西也算是个鸡肋，可以通过一层一层继承来实现相同的目的，反而导致可读性下降，个人学渣拙见","like_count":0},{"had_liked":false,"id":150715,"user_name":"陈迎春","can_delete":false,"product_type":"c1","uid":1443663,"ip_address":"","ucode":"2870BA6D6E5B1E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIang00R9vkklnkFCLhzRysNfocr0sLnCdoZwOT3UkulAPefk5BDvd0PfIeQSODSQg1DjKWUmJOaA/132","comment_is_top":false,"comment_ctime":1573604521,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573604521","product_id":100039001,"comment_content":"C++支持多重继承，但感觉最好还是不要使用多重继承，可读性会变差一些","like_count":0},{"had_liked":false,"id":150710,"user_name":"Fly55","can_delete":false,"product_type":"c1","uid":1251563,"ip_address":"","ucode":"FFA9D5C6EDD6F4","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/eb/fd0b4a1f.jpg","comment_is_top":false,"comment_ctime":1573604264,"is_pvip":false,"discussion_count":1,"race_medal":1,"score":"1573604264","product_id":100039001,"comment_content":"java不支持<br>1.若子类继承的父类中拥有相同的成员变量，子类在引用该变量时将无法判别使用哪个父类的成员变量。<br>2.若一个子类继承的多个父类拥有相同方法，同时子类并未覆盖该方法，那么调用该方法时将无法确定调用哪个父类的方法。","like_count":0,"discussions":[{"author":{"id":1394822,"avatar":"https://static001.geekbang.org/account/avatar/00/15/48/86/54c68afe.jpg","nickname":"铁男神sama","note":"","ucode":"0A3E3E61D36EDE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308996,"discussion_content":"逻辑鬼才","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601166144,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296314,"discussion_content":"Spring这种容器技术不是严格意义上的单例模式，是单例的替代品了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596508101,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1958147,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/e1/03/f937e673.jpg","nickname":"🍀","note":"","ucode":"60E0AC2A55B63B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":226619,"discussion_content":"此接口非彼接口","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586437420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150708,"user_name":"Cy23","can_delete":false,"product_type":"c1","uid":1591293,"ip_address":"","ucode":"8DC561C5151758","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/fd/895f0c27.jpg","comment_is_top":false,"comment_ctime":1573604172,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1573604172","product_id":100039001,"comment_content":"打卡，说实话，一直是隐约理解了，又隐约分不清。好尴尬啊，多少年了还是这样，我都怀疑人生了","like_count":0,"discussions":[{"author":{"id":2085090,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/d0/e2/1d00c079.jpg","nickname":"写代码的","note":"","ucode":"F58186409A3D65","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296621,"discussion_content":"不同的参数，本就应该返回不同的对象，把它设计成单例就有问题。抛出异常没从根本上解决问题，如果抛出异常，获取单例的所有地方都得捕获这个异常，问题来了，捕获之后程序该怎么处理？举个例子，假设有一个gui程序，想通过单例获取全局的画笔，getinstance传入了画笔的属性，一旦获取不到就抛出异常，然后程序捕获了异常，接下来该怎么处理呢？直接不画了？正确的做法是，画笔不应该设计为单例，并且让画笔提供接受画笔属性的构造函数。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596604894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150699,"user_name":"Miracle","can_delete":false,"product_type":"c1","uid":1373357,"ip_address":"","ucode":"C98378B19CDF1E","user_header":"https://static001.geekbang.org/account/avatar/00/14/f4/ad/33d67855.jpg","comment_is_top":false,"comment_ctime":1573603162,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1573603162","product_id":100039001,"comment_content":"go语言虽然没有继承概念，但是内嵌结构体其实也实现了继承的特性，内嵌多个结构体也可以看成多继承，这时候就会出现一个问题，如果潜入的多个结构体出现相同的字段，就会造成子结构体不清楚到底是继承谁的字段，所以就需要确保嵌入的结构体中不存在重名字段","like_count":0,"discussions":[{"author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":163152,"discussion_content":"第二个如果你在更新完之后，别的线程进来把你参数改了，你就崩盘了。。。。。真的不如判断和当前不一样就重新创建","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1581054463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1227840,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/40/2279cfb5.jpg","nickname":"大力水手Jerry","note":"","ucode":"E4A6C71E275DB5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":321297,"discussion_content":"在init中使用同步原语，确保对该实例的修改是串行的。在创建时判断一致性也需要使用同步原语，但粒度更大。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604560882,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":163152,"ip_address":""},"score":321297,"extra":""}]}]},{"had_liked":false,"id":150690,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1573602312,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1573602312","product_id":100039001,"comment_content":"Java不支持多继承（multiple inheritance）。在多继承中，一个子类可以有多个父类，子类继承所有父类的公共属性和方法，例如C extends A, C extends B。<br><br>其他语言，如C++支持多继承。但在实际应用中，即使是有经验的C++工程师，也不建议使用多继承（特殊情况除外）。<br><br>Java为什么不使用多继承呢？<br>这是综合考虑语言复杂性和性能的折衷结果。<br><br>第一，复杂性。<br>因为这会使语言变的复杂（像C++）。例如 C 继承A和B，当A和B中都有一个方法f，当C调用方法f或者override方法f时，是指A的还是B的f？<br><br>Java使用接口实现多继承。像在Java的Arrays.sort()中，类如果想实现排序效果，就必须实现Comparable接口中的compareTo方法。但这也有缺点：接口只能有完全抽象的方法。问题是：使用某个接口时要实现所有抽象方法。那如果我不想实现接口中的所有方法呢？在Java中时做不到的。<br><br>第二，复杂性。<br>多继承运行中会实时查找继承的方法，编程语言实现这个机制时，不好编程语言的底层实现会影响语言的性能。<br><br>总结：Java中使用Interface实现多继承。一个类可以有一个父类，但可以实现多个接口。不同接口中的同名方法，使用接口名+点+方法名指代。<br>","like_count":0},{"had_liked":false,"id":150678,"user_name":"Aliliin","can_delete":false,"product_type":"c1","uid":1025239,"ip_address":"","ucode":"61F9A09BB6650F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a4/d7/5d2bfaa7.jpg","comment_is_top":false,"comment_ctime":1573599831,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573599831","product_id":100039001,"comment_content":"Php 不支持多重继承，至于为什么还真没思考过这个问题。","like_count":0},{"had_liked":false,"id":150674,"user_name":"redj","can_delete":false,"product_type":"c1","uid":1251309,"ip_address":"","ucode":"9BD7A1E0FEA881","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/ed/f79dd0f6.jpg","comment_is_top":false,"comment_ctime":1573582595,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573582595","product_id":100039001,"comment_content":"打卡","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495150,"discussion_content":"根据业务来估算的，有些业务本身就很慢，就判定为慢sql","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589524621,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150654,"user_name":"玄兴梦影","can_delete":false,"product_type":"c1","uid":1364855,"ip_address":"","ucode":"D9EDBBC61317E9","user_header":"https://static001.geekbang.org/account/avatar/00/14/d3/77/fb38ccf1.jpg","comment_is_top":false,"comment_ctime":1573575373,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573575373","product_id":100039001,"comment_content":"学习","like_count":0}]}