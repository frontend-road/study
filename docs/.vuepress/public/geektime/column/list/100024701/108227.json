{"id":108227,"title":"48 | 接收网络包（下）：如何搞明白合作伙伴让我们做什么？","content":"<p>上一节，我们解析了网络包接收的上半部分，从硬件网卡到IP层。这一节，我们接着来解析TCP层和Socket层都做了哪些事情。</p><h2>网络协议栈的TCP层</h2><p>从tcp_v4_rcv函数开始，我们的处理逻辑就从IP层到了TCP层。</p><pre><code>int tcp_v4_rcv(struct sk_buff *skb)\n{\n\tstruct net *net = dev_net(skb-&gt;dev);\n\tconst struct iphdr *iph;\n\tconst struct tcphdr *th;\n\tbool refcounted;\n\tstruct sock *sk;\n\tint ret;\n......\n\tth = (const struct tcphdr *)skb-&gt;data;\n\tiph = ip_hdr(skb);\n......\n\tTCP_SKB_CB(skb)-&gt;seq = ntohl(th-&gt;seq);\n\tTCP_SKB_CB(skb)-&gt;end_seq = (TCP_SKB_CB(skb)-&gt;seq + th-&gt;syn + th-&gt;fin + skb-&gt;len - th-&gt;doff * 4);\n\tTCP_SKB_CB(skb)-&gt;ack_seq = ntohl(th-&gt;ack_seq);\n\tTCP_SKB_CB(skb)-&gt;tcp_flags = tcp_flag_byte(th);\n\tTCP_SKB_CB(skb)-&gt;tcp_tw_isn = 0;\n\tTCP_SKB_CB(skb)-&gt;ip_dsfield = ipv4_get_dsfield(iph);\n\tTCP_SKB_CB(skb)-&gt;sacked\t = 0;\n\nlookup:\n\tsk = __inet_lookup_skb(&amp;tcp_hashinfo, skb, __tcp_hdrlen(th), th-&gt;source, th-&gt;dest, &amp;refcounted);\n\nprocess:\n\tif (sk-&gt;sk_state == TCP_TIME_WAIT)\n\t\tgoto do_time_wait;\n\n\tif (sk-&gt;sk_state == TCP_NEW_SYN_RECV) {\n......\n\t}\n......\n\tth = (const struct tcphdr *)skb-&gt;data;\n\tiph = ip_hdr(skb);\n\n\tskb-&gt;dev = NULL;\n\n\tif (sk-&gt;sk_state == TCP_LISTEN) {\n\t\tret = tcp_v4_do_rcv(sk, skb);\n\t\tgoto put_and_return;\n\t}\n......\n\tif (!sock_owned_by_user(sk)) {\n\t\tif (!tcp_prequeue(sk, skb))\n\t\t\tret = tcp_v4_do_rcv(sk, skb);\n\t} else if (tcp_add_backlog(sk, skb)) {\n\t\tgoto discard_and_relse;\n\t}\n......\n}\n</code></pre><p>在tcp_v4_rcv中，得到TCP的头之后，我们可以开始处理TCP层的事情。因为TCP层是分状态的，状态被维护在数据结构struct sock里面，因而我们要根据IP地址以及TCP头里面的内容，在tcp_hashinfo中找到这个包对应的struct sock，从而得到这个包对应的连接的状态。</p><p>接下来，我们就根据不同的状态做不同的处理，例如，上面代码中的TCP_LISTEN、TCP_NEW_SYN_RECV状态属于连接建立过程中。这个我们在讲三次握手的时候讲过了。再如，TCP_TIME_WAIT状态是连接结束的时候的状态，这个我们暂时可以不用看。</p><p>接下来，我们来分析最主流的网络包的接收过程，这里面涉及三个队列：</p><ul>\n<li>backlog队列</li>\n<li>prequeue队列</li>\n<li>sk_receive_queue队列</li>\n</ul><p>为什么接收网络包的过程，需要在这三个队列里面倒腾过来、倒腾过去呢？这是因为，同样一个网络包要在三个主体之间交接。</p><!-- [[[read_end]]] --><p>第一个主体是<strong>软中断的处理过程</strong>。如果你没忘记的话，我们在执行tcp_v4_rcv函数的时候，依然处于软中断的处理逻辑里，所以必然会占用这个软中断。</p><p>第二个主体就是<strong>用户态进程</strong>。如果用户态触发系统调用read读取网络包，也要从队列里面找。</p><p>第三个主体就是<strong>内核协议栈</strong>。哪怕用户进程没有调用read，读取网络包，当网络包来的时候，也得有一个地方收着呀。</p><p>这时候，我们就能够了解上面代码中sock_owned_by_user的意思了，其实就是说，当前这个sock是不是正有一个用户态进程等着读数据呢，如果没有，内核协议栈也调用tcp_add_backlog，暂存在backlog队列中，并且抓紧离开软中断的处理过程。</p><p>如果有一个用户态进程等待读取数据呢？我们先调用tcp_prequeue，也即赶紧放入prequeue队列，并且离开软中断的处理过程。在这个函数里面，我们会看到对于sysctl_tcp_low_latency的判断，也即是不是要低时延地处理网络包。</p><p>如果把sysctl_tcp_low_latency设置为0，那就要放在prequeue队列中暂存，这样不用等待网络包处理完毕，就可以离开软中断的处理过程，但是会造成比较长的时延。如果把sysctl_tcp_low_latency设置为1，我们还是调用tcp_v4_do_rcv。</p><pre><code>int tcp_v4_do_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct sock *rsk;\n\n\tif (sk-&gt;sk_state == TCP_ESTABLISHED) { /* Fast path */\n\t\tstruct dst_entry *dst = sk-&gt;sk_rx_dst;\n......\n\t\ttcp_rcv_established(sk, skb, tcp_hdr(skb), skb-&gt;len);\n\t\treturn 0;\n\t}\n......\n\tif (tcp_rcv_state_process(sk, skb)) {\n......\n\t}\n\treturn 0;\n......\n}\n</code></pre><p>在tcp_v4_do_rcv中，分两种情况，一种情况是连接已经建立，处于TCP_ESTABLISHED状态，调用tcp_rcv_established。另一种情况，就是其他的状态，调用tcp_rcv_state_process。</p><pre><code>int tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tstruct request_sock *req;\n\tint queued = 0;\n\tbool acceptable;\n\n\tswitch (sk-&gt;sk_state) {\n\tcase TCP_CLOSE:\n......\n\tcase TCP_LISTEN:\n......\n\tcase TCP_SYN_SENT:\n......\n\t}\n......\n\tswitch (sk-&gt;sk_state) {\n\tcase TCP_SYN_RECV:\n......\n\tcase TCP_FIN_WAIT1: \n......\n\tcase TCP_CLOSING:\n......\n\tcase TCP_LAST_ACK:\n......\n    }\n\n\t/* step 7: process the segment text */\n\tswitch (sk-&gt;sk_state) {\n\tcase TCP_CLOSE_WAIT:\n\tcase TCP_CLOSING:\n\tcase TCP_LAST_ACK:\n......\n\tcase TCP_FIN_WAIT1:\n\tcase TCP_FIN_WAIT2:\n......\n\tcase TCP_ESTABLISHED:\n......\n\t}\n}\n</code></pre><p>在tcp_rcv_state_process中，如果我们对着TCP的状态图进行比对，能看到，对于TCP所有状态的处理，其中和连接建立相关的状态，咱们已经分析过，所以我们重点关注连接状态下的工作模式。</p><p><img src=\"https://static001.geekbang.org/resource/image/38/c6/385ff4a348dfd2f64feb0d7ba81e2bc6.png?wh=1423*1963\" alt=\"\"></p><p>在连接状态下，我们会调用tcp_rcv_established。在这个函数里面，我们会调用tcp_data_queue，将其放入sk_receive_queue队列进行处理。</p><pre><code>static void tcp_data_queue(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tbool fragstolen = false;\n......\n\tif (TCP_SKB_CB(skb)-&gt;seq == tp-&gt;rcv_nxt) {\n\t\tif (tcp_receive_window(tp) == 0)\n\t\t\tgoto out_of_window;\n\n\t\t/* Ok. In sequence. In window. */\n\t\tif (tp-&gt;ucopy.task == current &amp;&amp;\n\t\t    tp-&gt;copied_seq == tp-&gt;rcv_nxt &amp;&amp; tp-&gt;ucopy.len &amp;&amp;\n\t\t    sock_owned_by_user(sk) &amp;&amp; !tp-&gt;urg_data) {\n\t\t\tint chunk = min_t(unsigned int, skb-&gt;len,\n\t\t\t\t\t  tp-&gt;ucopy.len);\n\n\t\t\t__set_current_state(TASK_RUNNING);\n\n\t\t\tif (!skb_copy_datagram_msg(skb, 0, tp-&gt;ucopy.msg, chunk)) {\n\t\t\t\ttp-&gt;ucopy.len -= chunk;\n\t\t\t\ttp-&gt;copied_seq += chunk;\n\t\t\t\teaten = (chunk == skb-&gt;len);\n\t\t\t\ttcp_rcv_space_adjust(sk);\n\t\t\t}\n\t\t}\n\n\t\tif (eaten &lt;= 0) {\nqueue_and_out:\n......\n\t\t\teaten = tcp_queue_rcv(sk, skb, 0, &amp;fragstolen);\n\t\t}\n\t\ttcp_rcv_nxt_update(tp, TCP_SKB_CB(skb)-&gt;end_seq);\n......\n\t\tif (!RB_EMPTY_ROOT(&amp;tp-&gt;out_of_order_queue)) {\n\t\t\ttcp_ofo_queue(sk);\n......\n\t\t}\n......\n\t\treturn;\n\t}\n\n\tif (!after(TCP_SKB_CB(skb)-&gt;end_seq, tp-&gt;rcv_nxt)) {\n\t\t/* A retransmit, 2nd most common case.  Force an immediate ack. */\n\t\ttcp_dsack_set(sk, TCP_SKB_CB(skb)-&gt;seq, TCP_SKB_CB(skb)-&gt;end_seq);\n\nout_of_window:\n\t\ttcp_enter_quickack_mode(sk);\n\t\tinet_csk_schedule_ack(sk);\ndrop:\n\t\ttcp_drop(sk, skb);\n\t\treturn;\n\t}\n\n\t/* Out of window. F.e. zero window probe. */\n\tif (!before(TCP_SKB_CB(skb)-&gt;seq, tp-&gt;rcv_nxt + tcp_receive_window(tp)))\n\t\tgoto out_of_window;\n\n\ttcp_enter_quickack_mode(sk);\n\n\tif (before(TCP_SKB_CB(skb)-&gt;seq, tp-&gt;rcv_nxt)) {\n\t\t/* Partial packet, seq &lt; rcv_next &lt; end_seq */\n\t\ttcp_dsack_set(sk, TCP_SKB_CB(skb)-&gt;seq, tp-&gt;rcv_nxt);\n\t\t/* If window is closed, drop tail of packet. But after\n\t\t * remembering D-SACK for its head made in previous line.\n\t\t */\n\t\tif (!tcp_receive_window(tp))\n\t\t\tgoto out_of_window;\n\t\tgoto queue_and_out;\n\t}\n\n\ttcp_data_queue_ofo(sk, skb);\n}\n</code></pre><p>在tcp_data_queue中，对于收到的网络包，我们要分情况进行处理。</p><p>第一种情况，seq == tp-&gt;rcv_nxt，说明来的网络包正是我服务端期望的下一个网络包。这个时候我们判断sock_owned_by_user，也即用户进程也是正在等待读取，这种情况下，就直接skb_copy_datagram_msg，将网络包拷贝给用户进程就可以了。</p><p>如果用户进程没有正在等待读取，或者因为内存原因没有能够拷贝成功，tcp_queue_rcv里面还是将网络包放入sk_receive_queue队列。</p><p>接下来，tcp_rcv_nxt_update将tp-&gt;rcv_nxt设置为end_seq，也即当前的网络包接收成功后，更新下一个期待的网络包。</p><p>这个时候，我们还会判断一下另一个队列，out_of_order_queue，也看看乱序队列的情况，看看乱序队列里面的包，会不会因为这个新的网络包的到来，也能放入到sk_receive_queue队列中。</p><p>例如，客户端发送的网络包序号为5、6、7、8、9。在5还没有到达的时候，服务端的rcv_nxt应该是5，也即期望下一个网络包是5。但是由于中间网络通路的问题，5、6还没到达服务端，7、8已经到达了服务端了，这就出现了乱序。</p><p>乱序的包不能进入sk_receive_queue队列。因为一旦进入到这个队列，意味着可以发送给用户进程。然而，按照TCP的定义，用户进程应该是按顺序收到包的，没有排好序，就不能给用户进程。所以，7、8不能进入sk_receive_queue队列，只能暂时放在out_of_order_queue乱序队列中。</p><p>当5、6到达的时候，5、6先进入sk_receive_queue队列。这个时候我们再来看out_of_order_queue乱序队列中的7、8，发现能够接上。于是，7、8也能进入sk_receive_queue队列了。tcp_ofo_queue函数就是做这个事情的。</p><p>至此第一种情况处理完毕。</p><p>第二种情况，end_seq不大于rcv_nxt，也即服务端期望网络包5。但是，来了一个网络包3，怎样才会出现这种情况呢？肯定是服务端早就收到了网络包3，但是ACK没有到达客户端，中途丢了，那客户端就认为网络包3没有发送成功，于是又发送了一遍，这种情况下，要赶紧给客户端再发送一次ACK，表示早就收到了。</p><p>第三种情况，seq不小于rcv_nxt + tcp_receive_window。这说明客户端发送得太猛了。本来seq肯定应该在接收窗口里面的，这样服务端才来得及处理，结果现在超出了接收窗口，说明客户端一下子把服务端给塞满了。</p><p>这种情况下，服务端不能再接收数据包了，只能发送ACK了，在ACK中会将接收窗口为0的情况告知客户端，客户端就知道不能再发送了。这个时候双方只能交互窗口探测数据包，直到服务端因为用户进程把数据读走了，空出接收窗口，才能在ACK里面再次告诉客户端，又有窗口了，又能发送数据包了。</p><p>第四种情况，seq小于rcv_nxt，但是end_seq大于rcv_nxt，这说明从seq到rcv_nxt这部分网络包原来的ACK客户端没有收到，所以重新发送了一次，从rcv_nxt到end_seq时新发送的，可以放入sk_receive_queue队列。</p><p>当前四种情况都排除掉了，说明网络包一定是一个乱序包了。这里有点儿难理解，我们还是用上面那个乱序的例子仔细分析一下rcv_nxt=5。</p><p>我们假设tcp_receive_window也是5，也即超过10服务端就接收不了了。当前来的这个网络包既不在rcv_nxt之前（不是3这种），也不在rcv_nxt + tcp_receive_window之后（不是11这种），说明这正在我们期望的接收窗口里面，但是又不是rcv_nxt（不是我们马上期望的网络包5），这正是上面的例子中网络包7、8的情况。</p><p>对于网络包7、8，我们只好调用tcp_data_queue_ofo进入out_of_order_queue乱序队列，但是没有关系，当网络包5、6到来的时候，我们会走第一种情况，把7、8拿出来放到sk_receive_queue队列中。</p><p>至此，网络协议栈的处理过程就结束了。</p><h2>Socket层</h2><p>当接收的网络包进入各种队列之后，接下来我们就要等待用户进程去读取它们了。</p><p>读取一个socket，就像读取一个文件一样，读取socket的文件描述符，通过read系统调用。</p><p>read系统调用对于一个文件描述符的操作，大致过程都是类似的，在文件系统那一节，我们已经详细解析过。最终它会调用到用来表示一个打开文件的结构stuct file指向的file_operations操作。</p><p>对于socket来讲，它的file_operations定义如下：</p><pre><code>static const struct file_operations socket_file_ops = {\n\t.owner =\tTHIS_MODULE,\n\t.llseek =\tno_llseek,\n\t.read_iter =\tsock_read_iter,\n\t.write_iter =\tsock_write_iter,\n\t.poll =\t\tsock_poll,\n\t.unlocked_ioctl = sock_ioctl,\n\t.mmap =\t\tsock_mmap,\n\t.release =\tsock_close,\n\t.fasync =\tsock_fasync,\n\t.sendpage =\tsock_sendpage,\n\t.splice_write = generic_splice_sendpage,\n\t.splice_read =\tsock_splice_read,\n};\n</code></pre><p>按照文件系统的读取流程，调用的是sock_read_iter。</p><pre><code>static ssize_t sock_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct file *file = iocb-&gt;ki_filp;\n\tstruct socket *sock = file-&gt;private_data;\n\tstruct msghdr msg = {.msg_iter = *to,\n\t\t\t     .msg_iocb = iocb};\n\tssize_t res;\n\n\tif (file-&gt;f_flags &amp; O_NONBLOCK)\n\t\tmsg.msg_flags = MSG_DONTWAIT;\n......\n\tres = sock_recvmsg(sock, &amp;msg, msg.msg_flags);\n\t*to = msg.msg_iter;\n\treturn res;\n}\n</code></pre><p>在sock_read_iter中，通过VFS中的struct file，将创建好的socket结构拿出来，然后调用sock_recvmsg，sock_recvmsg会调用sock_recvmsg_nosec。</p><pre><code>static inline int sock_recvmsg_nosec(struct socket *sock, struct msghdr *msg, int flags)\n{\n\treturn sock-&gt;ops-&gt;recvmsg(sock, msg, msg_data_left(msg), flags);\n}\n</code></pre><p>这里调用了socket的ops的recvmsg，这个我们遇到好几次了。根据inet_stream_ops的定义，这里调用的是inet_recvmsg。</p><pre><code>int inet_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,\n\t\t int flags)\n{\n\tstruct sock *sk = sock-&gt;sk;\n\tint addr_len = 0;\n\tint err;\n......\n\terr = sk-&gt;sk_prot-&gt;recvmsg(sk, msg, size, flags &amp; MSG_DONTWAIT,\n\t\t\t\t   flags &amp; ~MSG_DONTWAIT, &amp;addr_len);\n......\n}\n</code></pre><p>这里面，从socket结构，我们可以得到更底层的sock结构，然后调用sk_prot的recvmsg方法。这个同样遇到好几次了，根据tcp_prot的定义，调用的是tcp_recvmsg。</p><pre><code>int tcp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int nonblock,\n\t\tint flags, int *addr_len)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint copied = 0;\n\tu32 peek_seq;\n\tu32 *seq;\n\tunsigned long used;\n\tint err;\n\tint target;\t\t/* Read at least this many bytes */\n\tlong timeo;\n\tstruct task_struct *user_recv = NULL;\n\tstruct sk_buff *skb, *last;\n.....\n\tdo {\n\t\tu32 offset;\n......\n\t\t/* Next get a buffer. */\n\t\tlast = skb_peek_tail(&amp;sk-&gt;sk_receive_queue);\n\t\tskb_queue_walk(&amp;sk-&gt;sk_receive_queue, skb) {\n\t\t\tlast = skb;\n\t\t\toffset = *seq - TCP_SKB_CB(skb)-&gt;seq;\n\t\t\tif (offset &lt; skb-&gt;len)\n\t\t\t\tgoto found_ok_skb;\n......\n\t\t}\n......\n\t\tif (!sysctl_tcp_low_latency &amp;&amp; tp-&gt;ucopy.task == user_recv) {\n\t\t\t/* Install new reader */\n\t\t\tif (!user_recv &amp;&amp; !(flags &amp; (MSG_TRUNC | MSG_PEEK))) {\n\t\t\t\tuser_recv = current;\n\t\t\t\ttp-&gt;ucopy.task = user_recv;\n\t\t\t\ttp-&gt;ucopy.msg = msg;\n\t\t\t}\n\n\t\t\ttp-&gt;ucopy.len = len;\n\t\t\t/* Look: we have the following (pseudo)queues:\n\t\t\t *\n\t\t\t * 1. packets in flight\n\t\t\t * 2. backlog\n\t\t\t * 3. prequeue\n\t\t\t * 4. receive_queue\n\t\t\t *\n\t\t\t * Each queue can be processed only if the next ones\n\t\t\t * are empty. \n\t\t\t */\n\t\t\tif (!skb_queue_empty(&amp;tp-&gt;ucopy.prequeue))\n\t\t\t\tgoto do_prequeue;\n\t\t}\n\n\t\tif (copied &gt;= target) {\n\t\t\t/* Do not sleep, just process backlog. */\n\t\t\trelease_sock(sk);\n\t\t\tlock_sock(sk);\n\t\t} else {\n\t\t\tsk_wait_data(sk, &amp;timeo, last);\n\t\t}\n\n\t\tif (user_recv) {\n\t\t\tint chunk;\n\t\t\tchunk = len - tp-&gt;ucopy.len;\n\t\t\tif (chunk != 0) {\n\t\t\t\tlen -= chunk;\n\t\t\t\tcopied += chunk;\n\t\t\t}\n\n\t\t\tif (tp-&gt;rcv_nxt == tp-&gt;copied_seq &amp;&amp;\n\t\t\t    !skb_queue_empty(&amp;tp-&gt;ucopy.prequeue)) {\ndo_prequeue:\n\t\t\t\ttcp_prequeue_process(sk);\n\n\t\t\t\tchunk = len - tp-&gt;ucopy.len;\n\t\t\t\tif (chunk != 0) {\n\t\t\t\t\tlen -= chunk;\n\t\t\t\t\tcopied += chunk;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcontinue;\n\tfound_ok_skb:\n\t\t/* Ok so how much can we use? */\n\t\tused = skb-&gt;len - offset;\n\t\tif (len &lt; used)\n\t\t\tused = len;\n\n\t\tif (!(flags &amp; MSG_TRUNC)) {\n\t\t\terr = skb_copy_datagram_msg(skb, offset, msg, used);\n......\n\t\t}\n\n\t\t*seq += used;\n\t\tcopied += used;\n\t\tlen -= used;\n\n\t\ttcp_rcv_space_adjust(sk);\n......\n\t} while (len &gt; 0);\n......\n}\n</code></pre><p>tcp_recvmsg这个函数比较长，里面逻辑也很复杂，好在里面有一段注释概括了这里面的逻辑。注释里面提到了三个队列，receive_queue队列、prequeue队列和backlog队列。这里面，我们需要把前一个队列处理完毕，才处理后一个队列。</p><p>tcp_recvmsg的整个逻辑也是这样执行的：这里面有一个while循环，不断地读取网络包。</p><p>这里，我们会先处理sk_receive_queue队列。如果找到了网络包，就跳到found_ok_skb这里。这里会调用skb_copy_datagram_msg，将网络包拷贝到用户进程中，然后直接进入下一层循环。</p><p>直到sk_receive_queue队列处理完毕，我们才到了sysctl_tcp_low_latency判断。如果不需要低时延，则会有prequeue队列。于是，我们能就跳到do_prequeue这里，调用tcp_prequeue_process进行处理。</p><p>如果sysctl_tcp_low_latency设置为1，也即没有prequeue队列，或者prequeue队列为空，则需要处理backlog队列，在release_sock函数中处理。</p><p>release_sock会调用__release_sock，这里面会依次处理队列中的网络包。</p><pre><code>void release_sock(struct sock *sk)\n{\n......\n\tif (sk-&gt;sk_backlog.tail)\n\t\t__release_sock(sk);\n......\n}\n\nstatic void __release_sock(struct sock *sk)\n\t__releases(&amp;sk-&gt;sk_lock.slock)\n\t__acquires(&amp;sk-&gt;sk_lock.slock)\n{\n\tstruct sk_buff *skb, *next;\n\n\twhile ((skb = sk-&gt;sk_backlog.head) != NULL) {\n\t\tsk-&gt;sk_backlog.head = sk-&gt;sk_backlog.tail = NULL;\n\t\tdo {\n\t\t\tnext = skb-&gt;next;\n\t\t\tprefetch(next);\n\t\t\tskb-&gt;next = NULL;\n\t\t\tsk_backlog_rcv(sk, skb);\n\t\t\tcond_resched();\n\t\t\tskb = next;\n\t\t} while (skb != NULL);\n\t}\n......\n}\n</code></pre><p>最后，哪里都没有网络包，我们只好调用sk_wait_data，继续等待在哪里，等待网络包的到来。</p><p>至此，网络包的接收过程到此结束。</p><h2>总结时刻</h2><p>这一节我们讲完了接收网络包，我们来从头串一下，整个过程可以分成以下几个层次。</p><ul>\n<li>硬件网卡接收到网络包之后，通过DMA技术，将网络包放入Ring Buffer；</li>\n<li>硬件网卡通过中断通知CPU新的网络包的到来；</li>\n<li>网卡驱动程序会注册中断处理函数ixgb_intr；</li>\n<li>中断处理函数处理完需要暂时屏蔽中断的核心流程之后，通过软中断NET_RX_SOFTIRQ触发接下来的处理过程；</li>\n<li>NET_RX_SOFTIRQ软中断处理函数net_rx_action，net_rx_action会调用napi_poll，进而调用ixgb_clean_rx_irq，从Ring Buffer中读取数据到内核struct sk_buff；</li>\n<li>调用netif_receive_skb进入内核网络协议栈，进行一些关于VLAN的二层逻辑处理后，调用ip_rcv进入三层IP层；</li>\n<li>在IP层，会处理iptables规则，然后调用ip_local_deliver交给更上层TCP层；</li>\n<li>在TCP层调用tcp_v4_rcv，这里面有三个队列需要处理，如果当前的Socket不是正在被读；取，则放入backlog队列，如果正在被读取，不需要很实时的话，则放入prequeue队列，其他情况调用tcp_v4_do_rcv；</li>\n<li>在tcp_v4_do_rcv中，如果是处于TCP_ESTABLISHED状态，调用tcp_rcv_established，其他的状态，调用tcp_rcv_state_process；</li>\n<li>在tcp_rcv_established中，调用tcp_data_queue，如果序列号能够接的上，则放入sk_receive_queue队列；如果序列号接不上，则暂时放入out_of_order_queue队列，等序列号能够接上的时候，再放入sk_receive_queue队列。</li>\n</ul><p>至此内核接收网络包的过程到此结束，接下来就是用户态读取网络包的过程，这个过程分成几个层次。</p><ul>\n<li>VFS层：read系统调用找到struct file，根据里面的file_operations的定义，调用sock_read_iter函数。sock_read_iter函数调用sock_recvmsg函数。</li>\n<li>Socket层：从struct file里面的private_data得到struct socket，根据里面ops的定义，调用inet_recvmsg函数。</li>\n<li>Sock层：从struct socket里面的sk得到struct sock，根据里面sk_prot的定义，调用tcp_recvmsg函数。</li>\n<li>TCP层：tcp_recvmsg函数会依次读取receive_queue队列、prequeue队列和backlog队列。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/20/52/20df32a842495d0f629ca5da53e47152.png?wh=3865*5080\" alt=\"\"></p><h2>课堂练习</h2><p>对于TCP协议、三次握手、发送和接收的连接维护、拥塞控制、滑动窗口，我们都解析过了。唯独四次挥手我们没有解析，对应的代码你应该知道在什么地方了，你可以自己试着解析一下四次挥手的过程。</p><p>欢迎留言和我分享你的疑惑和见解 ，也欢迎可以收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习和进步。</p><p><img src=\"https://static001.geekbang.org/resource/image/8c/37/8c0a95fa07a8b9a1abfd394479bdd637.jpg?wh=1110*659\" alt=\"\"></p>","neighbors":{"left":{"article_title":"47 | 接收网络包（上）：如何搞明白合作伙伴让我们做什么？","id":107485},"right":{"article_title":"49 | 虚拟机：如何成立子公司，让公司变集团？","id":108964}},"comments":[{"had_liked":false,"id":241921,"user_name":"Geek_ty","can_delete":false,"product_type":"c1","uid":1587280,"ip_address":"","ucode":"F8178B6B09D628","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epZhOmpZpicOzalVU7kibd59dMJc25N9cfGu9icBAIUPzYNYDedtzlYHZBiazaYiadgqvlotrjM4CA6KOQ/132","comment_is_top":false,"comment_ctime":1597501206,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"44547174166","product_id":100024701,"comment_content":"这里说一下，在17年后的Linux版本中已经取消了prequeue以及相关的操作，如果阅读较新的Linux内核的同学们请不要误解。现在只剩2个队列了。","like_count":10,"discussions":[{"author":{"id":1902002,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/05/b2/93b64021.jpg","nickname":"Geek_jikuo","note":"","ucode":"D4AF9E736701B8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389749,"discussion_content":"个人理解：\nsyns queue ,accept queue是tcp存储连接状态的队列，根据连接状态os会分配一些系统资源，cpu，内存；\n\nbacklog, sk_receive_queue, out_order_queue是存储网络包的队列\n\n在队列中拿到网络包之后再去更新 tcp连接状态的队列","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629421853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1243680,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fa/20/0f06b080.jpg","nickname":"凌空飞起的剪刀腿","note":"","ucode":"16FBBF4A3B54C6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365594,"discussion_content":"现在只有两个队列了吗？syns queue(半连接队列）；accept queue（全连接队列）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617847321,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1068620,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4e/4c/ce09ff52.jpg","nickname":"Lance","note":"","ucode":"5FE55DAFE74013","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1243680,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fa/20/0f06b080.jpg","nickname":"凌空飞起的剪刀腿","note":"","ucode":"16FBBF4A3B54C6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548565,"discussion_content":"syns queue(半连接队列）和 accept queue（全连接队列）是与listening socket相关的队列。队列用于管理连接，不涉及到连接之后的网络包的处理。\n\n而Geek_ty所说的被取消的prequeue是属于accpet socket队列，里面存放的是网络包。与accpet socket相关的队列还有 sk_receive_queue队列、out_of_order_queue队列以及 backlog队列","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1643265305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":365594,"ip_address":""},"score":548565,"extra":""}]}]},{"had_liked":false,"id":114513,"user_name":"免费的人","can_delete":false,"product_type":"c1","uid":1032106,"ip_address":"","ucode":"2B12D8ED63C564","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bf/aa/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1563328021,"is_pvip":false,"replies":[{"id":"46598","content":"讲不了了，要不这个专栏就太长了。在网络协议里面大致讲了一下epoll的内核实现，但是分析的不细","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1566363906,"ip_address":"","comment_id":114513,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23038164501","product_id":100024701,"comment_content":"老师有计划讲epoll的实现吗？","like_count":5,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458697,"discussion_content":"讲不了了，要不这个专栏就太长了。在网络协议里面大致讲了一下epoll的内核实现，但是分析的不细","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566363906,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114540,"user_name":"免费的人","can_delete":false,"product_type":"c1","uid":1032106,"ip_address":"","ucode":"2B12D8ED63C564","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bf/aa/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1563331152,"is_pvip":false,"replies":[{"id":"46597","content":"4.13里面是tcp_low_latency - BOOLEAN<br>        If set, the TCP stack makes decisions that prefer lower<br>        latency as opposed to higher throughput.  By default, this<br>        option is not set meaning that higher throughput is preferred.<br>        An example of an application where this default should be<br>        changed would be a Beowulf compute cluster.<br>        Default: 0<br><br>5.0里面就是<br><br>cp_low_latency - BOOLEAN<br>\tThis is a legacy option, it has no effect anymore.","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1566363861,"ip_address":"","comment_id":114540,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18743200336","product_id":100024701,"comment_content":"从kernel doc里发现这个说明：<br>tcp_low_latency - BOOLEAN<br>\tThis is a legacy option, it has no effect anymore.<br><br>这个选项没用了？","like_count":4,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458714,"discussion_content":"4.13里面是tcp_low_latency - BOOLEAN\n        If set, the TCP stack makes decisions that prefer lower\n        latency as opposed to higher throughput.  By default, this\n        option is not set meaning that higher throughput is preferred.\n        An example of an application where this default should be\n        changed would be a Beowulf compute cluster.\n        Default: 0\n\n5.0里面就是\n\ncp_low_latency - BOOLEAN\n\tThis is a legacy option, it has no effect anymore.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566363861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114604,"user_name":"D","can_delete":false,"product_type":"c1","uid":1027596,"ip_address":"","ucode":"5BB4D16FE39BFF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/0c/f39f847a.jpg","comment_is_top":false,"comment_ctime":1563348469,"is_pvip":false,"replies":[{"id":"46573","content":"红黑树，可以先判断一把再拿","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1566359064,"ip_address":"","comment_id":114604,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14448250357","product_id":100024701,"comment_content":"这个 out_of_order_queue 是怎么实现的， 假如5，6已结到了，下个期待7，8，但是从队头拿出的是9，10，怎么办，重新入队吗，这样效率有点低吧，老师能讲讲吗","like_count":3,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458744,"discussion_content":"红黑树，可以先判断一把再拿","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566359064,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308268,"user_name":"Geek_jikuo","can_delete":false,"product_type":"c1","uid":1902002,"ip_address":"","ucode":"D4AF9E736701B8","user_header":"https://static001.geekbang.org/account/avatar/00/1d/05/b2/93b64021.jpg","comment_is_top":false,"comment_ctime":1629502470,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10219437062","product_id":100024701,"comment_content":"问题：三层上送四层的时候，数据包是怎样知道自己属于哪个sock的？<br>答：tcp_v4_rcv()  -&gt; __inet_lookup_skb<br>根据数据包的ip+端口从tcp_hashinfo中找到，会有两个hash表：listening_hash和establish_hash哈希表<br>(注：参考文中一条笔记)","like_count":2},{"had_liked":false,"id":205438,"user_name":"深海极光","can_delete":false,"product_type":"c1","uid":1096111,"ip_address":"","ucode":"331024F7E99C64","user_header":"https://static001.geekbang.org/account/avatar/00/10/b9/af/f59b4c7c.jpg","comment_is_top":false,"comment_ctime":1586617253,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10176551845","product_id":100024701,"comment_content":"请问下老师，是linux协议栈通过tcp解析完成，放入到receive queue或者backlog queue 再去唤醒用户进程来读的吗，我们一般都是epoll读，而epoll是根据事件变化的，也是在fd的等待队列上睡眠，就是这一步是怎么关联的","like_count":2},{"had_liked":false,"id":167417,"user_name":"小马","can_delete":false,"product_type":"c1","uid":1040654,"ip_address":"","ucode":"0F7E0225A7E043","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e1/0e/dde741d7.jpg","comment_is_top":false,"comment_ctime":1577788185,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10167722777","product_id":100024701,"comment_content":"大佬你用的linux 内核是哪个版本，以及用什么工具查看源码的？我用的是 source insight","like_count":2},{"had_liked":false,"id":147126,"user_name":"caryr","can_delete":false,"product_type":"c1","uid":1480634,"ip_address":"","ucode":"9710A1F38F5133","user_header":"https://static001.geekbang.org/account/avatar/00/16/97/ba/b5b56c25.jpg","comment_is_top":false,"comment_ctime":1572812316,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10162746908","product_id":100024701,"comment_content":"老师您好，有个困惑： <br>if (!sock_owned_by_user(sk)) {    if (!tcp_prequeue(sk, skb))      ret = tcp_v4_do_rcv(sk, skb);  } <br>else if (tcp_add_backlog(sk, skb)) {    goto discard_and_relse;  }<br>这代码不是 sock属于我的时候执行add_backlog吗？<br>可为什么文中又说：（大意：sock不属于任何用户，则调用add_backlog 。是我哪里理解偏差了吗？）<br>这时候，我们就能够了解上面代码中 sock_owned_by_user 的意思了，其实就是说，当前这个 sock 是不是正有一个用户态进程等着读数据呢，如果没有，内核协议栈也调用 tcp_add_backlog，暂存在 backlog 队列中，并且抓紧离开软中断的处理过程。","like_count":2},{"had_liked":false,"id":124692,"user_name":"取名字好麻烦","can_delete":false,"product_type":"c1","uid":1226508,"ip_address":"","ucode":"EB5EE98C231551","user_header":"","comment_is_top":false,"comment_ctime":1565945593,"is_pvip":false,"replies":[{"id":"46265","content":"赞，加油","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1566280471,"ip_address":"","comment_id":124692,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10155880185","product_id":100024701,"comment_content":"大概也就看了五六七八遍","like_count":2,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463281,"discussion_content":"赞，加油","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566280471,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205547,"user_name":"深海极光","can_delete":false,"product_type":"c1","uid":1096111,"ip_address":"","ucode":"331024F7E99C64","user_header":"https://static001.geekbang.org/account/avatar/00/10/b9/af/f59b4c7c.jpg","comment_is_top":false,"comment_ctime":1586669811,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5881637107","product_id":100024701,"comment_content":"看了好多遍，并结合其他的资料，有个疑问就是放入backlog queue的条件，老师是说没有用户进程在等待读数据，综合其它的资料是说socket的锁是否正在被其它使用，如果是就放入backlog queue,因为不能让软中断等，如果能拿到就放入rece queue 感觉这样是更合理，请老师解答","like_count":1,"discussions":[{"author":{"id":1096111,"avatar":"https://static001.geekbang.org/account/avatar/00/10/b9/af/f59b4c7c.jpg","nickname":"深海极光","note":"","ucode":"331024F7E99C64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":239295,"discussion_content":"老师这个专辑的问题还解答吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587291443,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":171099,"user_name":"林先森","can_delete":false,"product_type":"c1","uid":1130951,"ip_address":"","ucode":"A25699D1A768B4","user_header":"https://static001.geekbang.org/account/avatar/00/11/41/c7/3aead12b.jpg","comment_is_top":false,"comment_ctime":1578844558,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5873811854","product_id":100024701,"comment_content":"老师，请教一个问题，在网络包接收过程中，在哪一个环节确认后才会向对端发送ack包啊？是等应用程序读取之后吗？","like_count":1,"discussions":[{"author":{"id":1508990,"avatar":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","nickname":"西门吹牛","note":"","ucode":"E5D3624DDE1E83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379655,"discussion_content":"不需要应用层读取后，在从网卡读到内核缓冲区中，就可以返回ack","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624039091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129639,"user_name":"wjh_all_in","can_delete":false,"product_type":"c1","uid":1501209,"ip_address":"","ucode":"0480A53AD46C97","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIC2Ww3swYiaMalnpA1f87xgzV8Hs1Y27M2CbNQqgR27Il72hibXn5FvhU7mbr3XKsxYDZdjY4GMDbg/132","comment_is_top":false,"comment_ctime":1567178544,"is_pvip":false,"replies":[{"id":"48703","content":"要的，如果判断接不上，就回退到默认流程","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567480324,"ip_address":"","comment_id":129639,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5862145840","product_id":100024701,"comment_content":"老师，prequeue 队列和 backlog 队列需要做乱序的保证吗？如果没有，怎么保证可靠性?","like_count":1,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465579,"discussion_content":"要的，如果判断接不上，就回退到默认流程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567480324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1609871,"avatar":"https://static001.geekbang.org/account/avatar/00/18/90/8f/9c691a5f.jpg","nickname":"奔跑的码仔","note":"","ucode":"AB3B02B07B8B8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38047,"discussion_content":"经过分析prequeue和backlog的最终都是调用的tcp_v4_do_rcv，该函数，最终处理tcp的乱序、重传、滑动窗口等等问题，然后将数据最终放入sk_receive_queue队列里。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571716805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1609871,"avatar":"https://static001.geekbang.org/account/avatar/00/18/90/8f/9c691a5f.jpg","nickname":"奔跑的码仔","note":"","ucode":"AB3B02B07B8B8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38045,"discussion_content":"老师，那是不是，可以这么理解，只有确认没有问题（经过整理以后顺序完全没有问题的数据）的数据才会放入sk_receive_queue队列中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571716546,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114602,"user_name":"没心没肺","can_delete":false,"product_type":"c1","uid":1258867,"ip_address":"","ucode":"121FD3AEBA3BEA","user_header":"https://static001.geekbang.org/account/avatar/00/13/35/73/46d6dadc.jpg","comment_is_top":false,"comment_ctime":1563348406,"is_pvip":false,"replies":[{"id":"46574","content":"终于....","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1566359075,"ip_address":"","comment_id":114602,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5858315702","product_id":100024701,"comment_content":"终于快结束了🙄","like_count":1,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458742,"discussion_content":"终于....","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566359075,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":354205,"user_name":"西门吹牛","can_delete":false,"product_type":"c1","uid":1508990,"ip_address":"北京","ucode":"E5D3624DDE1E83","user_header":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","comment_is_top":false,"comment_ctime":1660184178,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660184178","product_id":100024701,"comment_content":"为什么mmap 不可用在网络IO 中避免用户态和内核态数据复制的开销，而文件IO可以","like_count":0},{"had_liked":false,"id":296017,"user_name":"八戒","can_delete":false,"product_type":"c1","uid":1576512,"ip_address":"","ucode":"3F262A99492A65","user_header":"https://static001.geekbang.org/account/avatar/00/18/0e/40/49a71ed8.jpg","comment_is_top":false,"comment_ctime":1622706402,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622706402","product_id":100024701,"comment_content":"发现先看总结再看文章，更易理解……","like_count":0},{"had_liked":false,"id":253303,"user_name":"stackWarn","can_delete":false,"product_type":"c1","uid":1002005,"ip_address":"","ucode":"89672E452DEBA5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/15/106eaaa8.jpg","comment_is_top":false,"comment_ctime":1602680084,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602680084","product_id":100024701,"comment_content":"作为一个运维，这4篇要好好研读 对照内核看几遍了。 加油1刷","like_count":0},{"had_liked":false,"id":227927,"user_name":"韩俊臣","can_delete":false,"product_type":"c1","uid":1475340,"ip_address":"","ucode":"D6A15C025570D5","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/0c/b9e39db4.jpg","comment_is_top":false,"comment_ctime":1592527883,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592527883","product_id":100024701,"comment_content":"发现，得先对着图概览一遍，然后去看调用链，才能勉强看懂","like_count":0},{"had_liked":false,"id":191358,"user_name":"衡子","can_delete":false,"product_type":"c1","uid":1109433,"ip_address":"","ucode":"0AED79FC9D14BB","user_header":"https://static001.geekbang.org/account/avatar/00/10/ed/b9/825b2411.jpg","comment_is_top":false,"comment_ctime":1584765452,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584765452","product_id":100024701,"comment_content":"还是有很多细节需要慢慢吃透，例如：client发送一般断掉呢？队列里面的已接收的包会丢弃么？socket应该有类似心跳或者说状态维护的机制，是在超时关闭连接的时候去清理数据么？","like_count":0},{"had_liked":false,"id":158461,"user_name":"yew","can_delete":false,"product_type":"c1","uid":1202278,"ip_address":"","ucode":"A26F808BB6C59F","user_header":"https://static001.geekbang.org/account/avatar/00/12/58/66/7afd8da5.jpg","comment_is_top":false,"comment_ctime":1575377559,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1575377559","product_id":100024701,"comment_content":"整个接收过程 那几步发生内存拷贝","like_count":0,"discussions":[{"author":{"id":1443017,"avatar":"https://static001.geekbang.org/account/avatar/00/16/04/c9/ef585c96.jpg","nickname":"碌舰虾","note":"","ucode":"B947C229E767D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":564689,"discussion_content":"1、DMA\n2、软中断处理\n3、系统调用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650296202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134610,"user_name":"ZYecho","can_delete":false,"product_type":"c1","uid":1356589,"ip_address":"","ucode":"9D156DD30C581E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLh73kPzAKhz7YxUribqF6QKFiahhVAbwpgVLSRicA68c6ZFA7vUBJY1ves3LVvibrypROyI7awv47eSA/132","comment_is_top":false,"comment_ctime":1568878075,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1568878075","product_id":100024701,"comment_content":"为什么放入prequeue队列就会导致一个大的时延？ 是因为如果不放入的话，就可以直接在软中断中处理了么？","like_count":0,"discussions":[{"author":{"id":1609871,"avatar":"https://static001.geekbang.org/account/avatar/00/18/90/8f/9c691a5f.jpg","nickname":"奔跑的码仔","note":"","ucode":"AB3B02B07B8B8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38048,"discussion_content":"如果不放入prequeue中的话，会直接调用tcp_v4_do_rcv将sk_receive_queue队列中，用户进程读取时首先读取的就是该队列中的数据，所以处理时延较低吧。若放入prequeue队列中，等用户读取数据时，prequeue中的数据包最终还得需要通过tcp_v4_do_rcv的处理，即，延时处理了。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1571716997,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1002005,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4a/15/106eaaa8.jpg","nickname":"stackWarn","note":"","ucode":"89672E452DEBA5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312414,"discussion_content":"加了一个queue 处理就有延时了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602679999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114588,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1563345860,"is_pvip":false,"replies":[{"id":"46575","content":"谢谢","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1566359082,"ip_address":"","comment_id":114588,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563345860","product_id":100024701,"comment_content":"老师写得好！","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458736,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566359082,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}