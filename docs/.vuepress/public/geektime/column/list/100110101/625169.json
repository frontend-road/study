{"id":625169,"title":"32｜Fabric：新渲染器的演进之路","content":"<p>你好，我是蒋宏伟。</p><p>对核心渲染流程的持续迭代和优化，是 React Native 能够广受欢迎的重要原因之一。</p><p>Fabric 是 React Native 新架构渲染器的名字。今天，这一讲我不仅要给你介绍 Fabric 渲染器的核心技术原理，更想让你通过渲染器的演变升级过程，了解该过程中 React Native 技术团队每次大升级背后的思考过程。希望这些优秀框架背后的升级思考，以及对技术极致追求的精神，能够给你带去启发。</p><p>为了便于你理解 Fabric 新渲染器是如何演变而来的，我会先和你介绍一个假想的简化版渲染器，接着再带你回顾 React Native 老架构渲染器的工作原理，最后再告诉你 Fabric 新架构渲染器是如何设计的。</p><h2>简版渲染器</h2><p>时至今日，在 React Native 开源之初的宏大愿景依旧打动着我：将现代 Web 技术引入移动端（Bringing modern web techniques to mobile）。</p><p>Web 开发历史悠久，沉淀了诸多优秀实践和基础设施。随着 React Web 框架的出现，将现代 Web 中积累的开发理念，以及语言、框架、规范和生态等引入移动端，统一各端基础设施，必然能够整体降低移动端学习和开发成本。这是该理念如此打动我的原因。</p><!-- [[[read_end]]] --><p><strong>但难点是，如何将 Web 和移动端打通？</strong></p><p>打通的关键是语言间的相互调用，也就是常说的语言间的通信。将 Web 技术引入移动端的关键是，打通 JavaScript 与 OC/Java 的通信，使得 JavaScript 可以调用 iOS/Android 操作系统暴露出来的 API。</p><p>我以 Hello World iOS 应用为例，给你简单介绍一下通信原理。</p><p>先看 iOS 端的原生渲染。你可以通过 Objective-C 语言调用 iOS 操作系统暴露的 API，将 Hello World 文字显示在手机屏幕上。示例代码如下：</p><pre><code class=\"language-plain\">// 创建一个 iOS 标签视图\nUILabel *label = [[UILabel alloc]init];\n\n// 将该标签的文案设置为 \"Hello World\"\nlabel.text = @\"Hello World\";\n\n// 将标签视图添加到主视图中/屏幕上\n[self.view addSubview: label];\n</code></pre><p>在 iOS 程序中，你可以通过 UILabel 控件初始化一个标签视图，并通过对 <code>lable.text = \"Hello Wolrd\"</code> 赋值设置其文案，最后通过 <code>addSubview</code> 将其添加到主视图中，也就是将其显示到 iOS 手机屏幕上。<strong>以上这些 API 都是操作系统提供给 iOS 应用的“渲染能力”。</strong></p><p>那如何将这些渲染能力暴露给 JavaScript 呢？我们在 JavaScript 引擎中提到过，开发者可以借助 JavaScript 引擎的能力，实现 JavaScript 和 C++ 函数的相互调用。而 C++ 和 Objective-C 是同一类语言，它们之间本来就可以直接调用。因此，这就实现了 JavaScript 和 Objective-C 之间的相互调用。</p><pre><code class=\"language-plain\">// oc\njsContext[@\"setText\"] = ^(string???? str) {\n    label.text = str;\n};\n\n// javascript\nsetText('Hello World')\n</code></pre><p>例如，你可以将 <code>label.text = str</code> 装成一个 <code>setText</code> 函数，并将该函数挂在 JavaScript 引擎创建的 JSContext 上下文对象上。然后，在 JavaScript 代码中通过调用 <code>setText('Hello World')</code> 给标签视图赋值。</p><p>除了设置文本外，你还可以将创建视图、设置颜色/布局、添加到主视图等方法都进行封装。进一步地，任何的原生控件，都可以如上所示的一个个地封装宿主函数，并提供给 JavaScript 调用。这就是一个简版渲染器，有了它，你就实现了用 JavaScript 写原生应用的效果。</p><h2>老架构渲染器</h2><p>当然，上述的简版渲染器过于简单。在一个跨端渲染器中，还需要考虑组件化、声明式等开发者体验的因素，也要考虑统一 iOS/Android 布局的实现，以及如何通过多线程来提升渲染性能等多方面因素。</p><p><strong>老渲染器最重要的职责之一，是将你在 JavaScript 侧声明的组件转换为 iOS/Android 侧的 API 命令。</strong></p><p>如果不使用 React Native 提供的老渲染器，开发者虽然能够通过类似“简版渲染器”的方式直接调用原生 API，但这种方式显然开发效率太低。渲染器帮你把这个过程给自动化了，它可以让你用组件化的、声明式的方式描述页面，并在底层将你写的组件转化为对应原生 API。</p><p>以 Hello World 项目为例：</p><pre><code class=\"language-plain\">const App = () =&gt; &lt;Text&gt;Hello World&lt;/Text&gt;;\n\nAppRegistry.registerComponent(appName, () =&gt; App);\n</code></pre><p>当你在声明一个包含 <code>&lt;Text&gt;Hello World&lt;/Text&gt;</code> 的 App 组件，并将该 App 组件传给 <code>registerComponent</code> 方法之后，通过渲染器，它会将声明式的代码转换为原生命令。</p><p>以上 Hello World 应用中会包括一个用于布局的 View 视图和显示文本的视图。在 iOS 端，会生成一个 <code>UIView</code> 用于布局，并会创建 <code>NSAttributedString</code> 用于显示文本。在 Objective-C 中调用相关以上创建视图的 API 后，操作系统就会将 Hello World 文字显示在屏幕上了。</p><p><strong>老渲染器另一个重要的职责是实现 Flex 布局。</strong></p><p>开源第一版的 Flex 布局是直接用原生代码实现的，后来该功能独立了出来，作为了一个 C++ 第三方库 Yoga 被 React Native 引入。</p><p>当你想让 Hello World 文字居中，你可能会这么做：</p><pre><code class=\"language-plain\">&lt;View style={{flex: 1, justifyContent: 'center', alignItems: 'center'}}&gt;\n   &lt;Text&gt;Hello World&lt;/Text&gt;\n&lt;/View&gt;\n</code></pre><p>给 Hello World 文字外包一层 View 组件，并在 View 组件 style 属性设置 justifyContent、alignItems 为居中。渲染器会将 style 属性设置，转化为包裹 Hello World 视图容器的 x/y 轴坐标，使其实现屏幕居中。</p><p><strong>老渲染器还有一个职责是，尽可能地提升渲染性能。</strong></p><p>在简版渲染器中，我们并没有单独开一个线程来执行 JavaScript 代码，因此我们的 JavaScript 代码和 UI 操作都是在主线程进行的。在主线程增加了 JavaScript 代码的执行后，整个渲染流程耗时就会增加。而且，由于 JavaScript 执行和 UI 操作是同步的，一旦 JavaScript 执行过慢，会拖慢整个渲染流程，这就大大增加了卡顿的几率。</p><p>为此，React Native 在第一版的时候，就将其设置成了双线程异步消息通信的架构。后来 React Native 团队又为 Yoga 布局引擎，并又新增了一个线程，专门用于处理布局。</p><p>整体而言，相对于单线程同步调用的架构，多线程的异步消息通信的架构，它能大幅地减少卡顿的可能性。一方面，因为，渲染任务被分解到了三个线程中，JavaScript 线程、布局线程和 UI 线程，所以 UI 线程的任务量会减少，UI 线程的渲染卡顿的几率也会减少。另一方面，采用异步通信而不是同步通信后，JavaScript 线程任务的执行不会阻塞 UI 线程。</p><p><img src=\"https://static001.geekbang.org/resource/image/1c/86/1c0f9095b98d92fbed1ebf8c92d92f86.jpg?wh=767x224\" alt=\"图片\"></p><p>基于此，在 2015 年 3 月，开源第一版 React Native 渲染器，在 iOS 端实现了将 “Web 技术引入移动端”的目标。</p><h2>Fabric 新渲染器</h2><p>Fabric 新渲染器是基于老渲染器的重构升级，而重构升级过程中不变的是核心责任，是组件化/声明式、Flex布局和多线程模型。升级的是开发者体验，以及性能提升带来的用户体验。</p><p>因此，整体上看，Fabric 渲染器完成的主要任务还是将你声明的组件转换为最终原生 API 的调用。</p><p>Fabric 渲染器的转换过程主要涉及到 3 棵树：</p><ul>\n<li>Element Tree</li>\n<li>Fiber Tree</li>\n<li>Shadow Tree</li>\n</ul><h3>Element Tree</h3><p><strong>Element Tree 是在 JavaScript 侧，由 React 通过开发者书写的 JSX 创建而成的，它由若干个 Element 组成。</strong></p><p>一般而言，根节点 <code>&lt;App/&gt;</code> 就是一个 Element，同时它也是棵 Element Tree。一个 Element 就是一个普通的对象，该对象描述的是组件的实例或宿主视图的实例。</p><p>以 Hello World 应用为例：</p><pre><code class=\"language-plain\">const App = () =&gt; {\n  return (\n    &lt;View style={{opacity: 0.99, flex:1, justifyContent: 'center', alignItems: 'center'}}&gt;\n      &lt;Text style={{opacity: 0.88}}&gt;Hello World&lt;/Text&gt;\n    &lt;/View&gt;\n  );\n};\n\n// Element Tree\n&lt;App/&gt;\n</code></pre><p>整个应用的根节点是 <code>&lt;App/&gt;</code> ，<code>&lt;App/&gt;</code> 子节点是 <code>&lt;View/&gt;</code> ，<code>&lt;View/&gt;</code> 的子节点是<code>&lt;Text/&gt;</code>，它们共同构成了一棵 Element Tree。</p><p>一棵 Element Tree 的每个节点都是一个 Element。React Element 有两种类型，一种是通过函数或类自定义的合成组件生成的，另一种是宿主组件生成的。其中，宿主组件指的框架通过 JavaScript 引擎暴露给 JavaScript 的原生组件。</p><p><code>&lt;App/&gt;</code> 根节点是自定义函数创建的，所以它是合成组件生成的节点。<code>&lt;App/&gt;</code> 根节点打印出来如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/01/58/01411a46aff60d50a3f92760106c3858.jpg?wh=1017x603\" alt=\"图片\"></p><p>它是一个由 type、props、concurrentRoot 等属性组成的对象。其中，type 属性是一个 function () 函数，函数名 name 是 App。</p><p>而 <code>&lt;Text/&gt;</code> 节点是由框架暴露组件生成的节点，<code>&lt;Text/&gt;</code> 元素打印出来如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/0y/9f/0yy4d60fd6436c8874bd969412a92f9f.jpg?wh=1018x578\" alt=\"图片\"></p><p>从上图可知，一个 Element 也是一个普通的对象。该对象的 type 属性值为字符串 <code>RCTText</code>，style 属性值由设置透明属性 <code>opacity: 0.99</code> 和设置居中布局的属性组成，子节点 children 属性值为 <code>Hello World</code>。</p><p>从 Hello World 应用中的 <code>&lt;App&gt;</code> <code>&lt;Text&gt;</code> 节点的构成，我们可以看出，一个 Element 常见的属性包括 type 、props、concurrentRoot、style、children 等属性。</p><ul>\n<li>type：type 代表该 Element 的类型。如果 type 的值是 RCTText、RCTView 之类的字符串，那么该 Element 对应着一个宿主视图。如果 type 的值是函数或类，那么该 Element 是由合成组件生成的，并且没有对应的宿主视图。</li>\n<li>props：Element 初始化传入的属性，其中又包括当前根节点 concurrentRoot、样式 style、子节点 children，或者例如 Text 组件的 ellipsizeMode 文本省略属性等等。</li>\n</ul><p>在 React 层， Element Tree 会被映射为 Fiber Tree。</p><h3>Fiber Tree</h3><p><strong>Fiber Tree 是由若干个 Fiber 节点组成的，如果某个 Fiber 节点是通过用于描述宿主视图的 Element 生成的，那么该 Fiber 会对应一个同样的宿主视图。</strong></p><p>Fiber 是 React 16 之后引入的新能力，它使得 React 每次可渲染的颗粒度更小了，由 React 16 之前的一次 render 所有节点，变为了一次 render 时可分批次对节点进行操作。因此，从渲染角度，我们还可以将 Fiber 节点看做每次 render 的最小的渲染单位，让它能 Fabric 渲染器更快更智能。</p><p>在 React 内部，Fiber 节点是由 createFiberFromElement 函数创建的。从名字上可以看出，Fiber 节点是由 Element 节点生成的。进一步地，Fiber Tree 也可以看做 Element Tree 的映射。</p><p>同样，Fiber 节点也分两种，一种是由合成组件生成的 Element 所映射的 Fiber 节点，它没有对应的宿主组件的实例；一种是由宿主组件生成 Element 所映射的 Fiber 节点，它拥有对应的宿主组件实例。</p><p>还是以 Hello World 应用为例。你可以将 App 组件所创建的 Fiber 节点，打印出来如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/85/09/854e4e39ecd271cbb78078bd63397e09.jpg?wh=1013x717\" alt=\"图片\"></p><p>可以看到，App Fiber 节点是一个对象。该对象也有类型 type、子节点 child、属性 *props 等对象属性，这些对象属性在 Element 上也有。例如，App 组件所创建的 Element、Fiber 的 type 都是一个名为 App 的函数。当然，Fiber 节点上的属性是比 Element 多，比如 Fiber 节点拥有兄弟节点 sibling、父节点 return、状态节点 stateNode 等属性。</p><p>状态节点 stateNode 是一个较为特殊的属性，它关联了渲染器在 C++ 层生成的 Shadow 节点。App Fiber 节点的 stateNode 为 null，代表的就是合成组件所对应的 Fiber 节点是没有关联 Shadow 节点的，也就没有对应的宿主视图了。</p><p>同时，我也将 Hello World 应用中通过 Text 组件所创建的 Fiber 节点，打印了出来，如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/b0/d1/b0b17ef1e46dff127cc4428f117356d1.jpg?wh=1018x600\" alt=\"图片\"></p><p>Text Fiber 节点和 App Fiber 节点属性都是一样的，都有类型 type、子节点 child、兄弟节点 sibling、父节点 return、状态节点 stateNode 等对象属性。</p><p>不同的是 Text Fiber 节点的 type 是 RCTText，是字符串类型。而 App Fiber 的 type ，正如我们在前面看到的，是个函数。另外，Text Fiber 节点的 stateNode 是有值的，其中 node 属性值显示是一个 CallbackObject 类型，而前面我们提到 App Fiber 的 stateNode 的值是 null。</p><p>该 CallbackObject 类型的值代表的是一个在 C++ 层的 Shadow 节点，而在 JavaScript 层打印不出来这个 Shadow 节点，所以它没有具体的内容和原型链。</p><h3>Shadow Tree</h3><p><strong>Shadow Tree 是在 C++ 层创建的树，它由若干个 Shadow 节点组成。这些 Shadow 节点是在创建对应的拥有 stateNode 值的 Fiber 节点时，同步创建的。</strong></p><p>以 Hello Word 中的 <code>&lt;Text&gt;</code> 元素为例：</p><pre><code class=\"language-plain\">&lt;Text style={{opacity: 0.88}}&gt;Hello World&lt;/Text&gt;\n</code></pre><p>在 Xcode 中，它对应的 Shadow 节点打印出来如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/e6/09/e659b4a2575054f18cd0d544c160bf09.jpg?wh=1016x876\" alt=\"图片\"></p><p><code>&lt;Text&gt;</code> 元素对应的 Shadow 节点是个原生对象，该对象上挂载了属性 props、子节点 children、布局 layoutMetrics 等对象属性。</p><p>其中，Shadow 的 props 的透明度 <code>opacity: 0.88</code> 来自于 JSX 中的 <code>style={{opacity: 0.88}}</code> 的设置；子节点 children 的 <code>text=\"Hello World\"</code> 来自于 JSX 标签括起来的内容 Hello World。而 x/y 轴坐标以及 width/height 视图大小是根据其自身 style 布局属性，以及父节点和其他节点 style 布局属性计算出来的。</p><p>也就是说，Shadow Tree 不仅继承了由 JSX 所创建 Element Tree 的相关属性、父子节点关系，还新增了该视图如何在屏幕上进行布局的具体值。</p><p>最后，在 Fabric 渲染器的 C++ 层，通过 Diff 算法对比更新前后的两棵 Shadow Tree，计算出更新视图的操作指令（这些操作指令类似于简版渲染器中提到的 <code>setText('Hello World')</code> ），完成最终的渲染。这就是，Fabric 渲染器实现将 JSX 渲染成原生视图的整体流程。</p><p><img src=\"https://static001.geekbang.org/resource/image/39/5c/391707a966c082dd361c483d3d5abc5c.jpg?wh=2038x798\" alt=\"\"></p><p>更多的细节，可以参考我翻译的官方文档<a href=\"https://reactnative.cn/architecture/render-pipeline\">《Fabric 渲染流水线》</a> 。</p><h2>总结</h2><p>从老渲染到 Fabric 新渲染器，虽然代码几乎完全重写，但它坚守的初衷始终没有变过，而且 Fabric 新渲染器更好地完成了“将 Web 技术带到移动端”的使命。</p><p>Fabric 渲染器使用的是 React 16 以上版本，通过 Fiber 的能力，降低了大批量渲染卡顿的可能性。通信方式由异步消息升级为了同步调用，这也减少了通讯的性能损耗。多线程模型支持了 6 种不同优先级的渲染模式，由此可针对不同场景采用不同的渲染方案，这也进一步减少了卡顿的几率。</p><p>因此，我们可以说 Fabric 新渲染器就是对老渲染器在开发体验和渲染性能上的演化升级。</p><h2>思考题</h2><p>社区一些开源库更新一段时间后就逐渐停止了维护，而 React Native 持续迭代和优化了 8 年之久，你认为是什么因素导致了它有如此强的生命力？</p><p>欢迎在留言区分享你的看法、交流学习心得或者提出问题，如果觉得有收获，也期待你把今天的内容分享给更多的朋友！</p>","neighbors":{"left":{"article_title":"31｜多线程：RN底层是如何保障交互体验的？","id":620175},"right":{"article_title":"33｜AI前沿：ChatGPT资料精选集","id":656559}},"comments":[{"had_liked":false,"id":368010,"user_name":"Aaaaaaaaaaayou","can_delete":false,"product_type":"c1","uid":1073601,"ip_address":"广东","ucode":"67BA315B87587D","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/c1/93031a2a.jpg","comment_is_top":false,"comment_ctime":1675818732,"is_pvip":false,"replies":null,"discussion_count":2,"race_medal":0,"score":2,"product_id":100110101,"comment_content":"为什么 Fiber Tree diff 完后还要再Diff Shadow Tree?","like_count":2,"discussions":[{"author":{"id":1088541,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/1d/f0f10198.jpg","nickname":"蒋宏伟","note":"","ucode":"02226CABD5ECE7","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":603218,"discussion_content":"因为，在浏览器层，JS 可以直接操作 DOM，就只需一次 Diff；在 RN 中，JS 不能直接操作 Native 控件，只能再 Diff Shadow Tree 去操作 Native 控件。 在 Native 源码中也有 Diff 相关代码。\n","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1676017255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1915533,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/3a/8d/f5e7a20d.jpg","nickname":"何以解忧","note":"","ucode":"4DFE2BDBAF4919","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":605907,"discussion_content":"这个问题，我也有些疑问。1，js diff的结果直接翻译成 native 的更新指令不是更好么？ 2， dom 元素的布局渲染底层调用的是C++ 的代码实现，和 jsi 的通过调用c++ 代码操作native 视图，似乎形式上是一致的。期待老师的解惑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676878878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":373679,"user_name":"Geek_1de763","can_delete":false,"product_type":"c1","uid":3617278,"ip_address":"广东","ucode":"F148E5451990D8","user_header":"","comment_is_top":false,"comment_ctime":1683008296,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100110101,"comment_content":"所以新架构应用6讲没了？\n","like_count":1},{"had_liked":false,"id":374810,"user_name":"听说昵称太长了躲在树后面会被别人看见的","can_delete":false,"product_type":"c1","uid":3616258,"ip_address":"福建","ucode":"EFFEE43631C3B4","user_header":"https://static001.geekbang.org/account/avatar/00/37/2e/02/7f151e08.jpg","comment_is_top":false,"comment_ctime":1684460976,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100110101,"comment_content":"老师你好，有个新架构的问题想请教下，TurboModule 和 Fabric 怎么向 JS 端发送消息？我把公司应用升级到 0.71.8 并开启新构架后折腾了三天最终无奈退回到老架构了，TextInput 不可用、触摸事件也乱了，这些都通过 ref 操作和自定义封装触摸组件解决，但是最困惑我的问题是 TurboModule 和 Fabric 怎么发送消息给 RN 端？官方文档翻遍了没看到相关介绍，还有原生代码在新构架只能解耦出来做成单独的 NPM 包吗，我们大量老构架的原生组件都是直接在 Android&#47;IOS 工程下写的，没办法解耦出来成单独 NPM 包。","like_count":0,"discussions":[{"author":{"id":1088541,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/1d/f0f10198.jpg","nickname":"蒋宏伟","note":"","ucode":"02226CABD5ECE7","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":619712,"discussion_content":"官方有文档啊：https://reactnative.dev/docs/the-new-architecture/pillars-turbomodules","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1685447409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":374349,"user_name":"jing","can_delete":false,"product_type":"c1","uid":1329347,"ip_address":"广东","ucode":"1FCCB5F0886E94","user_header":"https://static001.geekbang.org/account/avatar/00/14/48/c3/04de5d84.jpg","comment_is_top":false,"comment_ctime":1683973654,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100110101,"comment_content":"+催更","like_count":0},{"had_liked":false,"id":374348,"user_name":"jing","can_delete":false,"product_type":"c1","uid":1329347,"ip_address":"广东","ucode":"1FCCB5F0886E94","user_header":"https://static001.geekbang.org/account/avatar/00/14/48/c3/04de5d84.jpg","comment_is_top":false,"comment_ctime":1683973646,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100110101,"comment_content":"催更","like_count":0},{"had_liked":false,"id":374154,"user_name":"大大小小","can_delete":false,"product_type":"c1","uid":2178133,"ip_address":"广东","ucode":"8A21DC629A24F5","user_header":"https://static001.geekbang.org/account/avatar/00/21/3c/55/74844d08.jpg","comment_is_top":false,"comment_ctime":1683645933,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100110101,"comment_content":"怎么不更新了？","like_count":0},{"had_liked":false,"id":369332,"user_name":"Geek_781ef0","can_delete":false,"product_type":"c1","uid":3050858,"ip_address":"广东","ucode":"7878C36BA1B08E","user_header":"","comment_is_top":false,"comment_ctime":1677415462,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100110101,"comment_content":"老师，还剩3讲，剩下的题目会是什么？催更！","like_count":0}]}