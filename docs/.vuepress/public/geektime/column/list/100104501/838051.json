{"id":838051,"title":"27 | 难点解析：如何调试eBPF程序","content":"<p>你好，我是倪朋飞。</p><p>在上一讲中，我带你深入探讨了 eBPF 程序参数格式和返回格式的设计。从 Linux 内核 eBPF 源码出发，我们重点分析了 <code>BPF_PROG_TYPE</code> 宏定义，并详细讨论了不同类型 eBPF 程序的参数格式和返回格式。为了便于理解和快速参考，我还以表格形式对常用的 eBPF 程序类型进行了全面汇总。通过这节课程，相信你在开发新的 eBPF 程序时能够更加得心应手地选择合适的程序类型，并正确处理其参数和返回值。</p><p>除了不容易找到 eBPF 程序的参数格式及返回格式之外，开发 eBPF 程序的另一个难点是如何调试 eBPF 程序。由于 eBPF 程序运行在内核虚拟机中，传统的调试工具如 GDB、Valgrind 和 strace 等都无法直接使用。这就导致开发者在完成 eBPF 程序开发后，往往很难有效地排查和解决代码中的潜在问题。在我们课程的留言区，我也收到很多类似的留言。</p><p>今天，我就带你一起来深入探讨这个问题，并为你介绍一些高效的调试方法和技巧。通过这些方法，希望能够帮助你更好地应对 eBPF 程序开发中的挑战，提高代码质量和开发效率。</p><h2>日志</h2><p>首先，我们来看一个最简单、最常用的方法，也就是打印调试日志。在我们课程之前的案例中，其实已经大量使用了这种方法。</p><!-- [[[read_end]]] --><p>我想你也应该已经在不同的 eBPF 程序中使用过 <code>bpf_trace_printk()</code> 或者 <code>bpf_printk()</code> 等方式来打印日志，不过我想再次提醒你注意它们在使用时的限制。</p><h3>bpf_trace_printk</h3><p>先看第一个 <code>bpf_trace_printk()</code>。</p><p><code>bpf_trace_printk()</code> 是一个 eBPF 辅助函数，最多只支持 3 个参数，并且在使用时需要传入格式化字符串的长度。比如下面就是一个简单的示例：</p><pre><code class=\"language-plain\">static const char fmt[] = \"some int: %d\";\nbpf_trace_printk(fmt, sizeof(fmt), 123);\n</code></pre><p>可以看到，<code>bpf_trace_printk()</code> 使用起来还是比较麻烦的。</p><h3>bpf_printk</h3><p>接下来，再来看它的简化版本 <code>bpf_printk()</code>。</p><p><code>bpf_printk()</code> 是 Libbpf 引入的一个宏，用来简化 eBPF 程序打印调试日志的过程。为了方便开发者使用，它在内部封装了 <code>bpf_trace_printk()</code> 和 <code>bpf_trace_vprintk()</code> 这两个函数：</p><ul>\n<li>\n<p>当参数数量小于或等于 3 的时候，还是继续调用 <code>bpf_trace_printk()</code> 来打印日志。</p>\n</li>\n<li>\n<p>而当参数数量大于 3 的时候，则调用 <code>bpf_trace_vprintk()</code> 来打印日志，这样最多可以支持 12 个参数，当然限制是需要 v5.16 或者更新的内核。</p>\n</li>\n</ul><p>简化之后，<code>bpf_printk()</code> 的使用就很方便了，不再需要传入格式化字符串的长度，比如下面就是一个简单的示例：</p><pre><code class=\"language-plain\">bpf_printk(\"Process[%d]: %s\\n\", pid, filename);\n</code></pre><h3>如何查看日志</h3><p>进行到这里，日志已经打印了，那么又该如何查看日志呢？</p><p>其实，无论是哪种方法，你都可以到 <code>/sys/kernel/debug/tracing/trace</code> 或 <code>/sys/kernel/debug/tracing/trace_pipe</code> 找到打印的日志。注意，<code>trace</code> 记录的是静态快照，而 <code>trace_pipe</code> 则是动态的输出。</p><p>至于具体的日志格式，我已经在第 3 讲 <a href=\"https://time.geekbang.org/column/article/481090\">初窥门径：开发并运行你的第一个 eBPF 程序</a> 中详细讲过。如果你已经忘记了，可以回去再复习一下。</p><p>虽然日志是最常用的调试方法，但由于其对性能有比较大的影响，通常在生产环境中并不建议打印过多的日志。那么，还有没有其他的方法来确保 eBPF 程序的行为是我们期望的结果呢？</p><p>接下来，我们再来看看另外一种测试 eBPF 程序的方法，即单元测试。</p><h2>单元测试</h2><p>对于程序开发来说，单元测试是必不可少的一部分，是确保程序的行为跟我们的预期一致的重要手段，eBPF 程序的开发自然也不例外。良好的单元测试不仅能够提前发现问题，还能为后续的重构提供质量保障。</p><p>不过，eBPF 程序毕竟运行在内核态，并不能像常规编程那样直接通过接口模拟进行测试。那么，该如何对 eBPF 程序进行单元测试呢？</p><p>Linux 内核开发者自然也考虑到了这个问题，所以为此专门增加了一个 <code>BPF_PROG_TEST_RUN</code> 的系统调用，后来又简化为 <code>BPF_PROG_RUN</code>（这两个系统调用可以直接互替，这一讲中我们使用简化的 <code>BPF_PROG_RUN</code>）。</p><p><code>BPF_PROG_RUN</code> 命令允许你将 eBPF 程序加载到内核后多次运行，并基于你提供的输入记录输出，这样就可以方便地进行单元测试或基准测试。同其他 eBPF 命令一样，Libbpf 对它也进行了封装，也就是 <code>bpf_prog_test_run_opts()</code> 库函数，它的定义如下所示：</p><pre><code class=\"language-cpp\">LIBBPF_API int bpf_prog_test_run_opts(int prog_fd,\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;struct bpf_test_run_opts *opts);\n</code></pre><p>这其中，<code>prog_fd</code> 是 eBPF 程序加载后的文件描述符，而 <code>struct bpf_test_run_opts</code> 则是用来传入单元测试的参数，包括输入数据、上下文信息、重复执行次数、批处理大小等，其定义如下所示。为了方便你理解，我已经加上了详细的注释。</p><pre><code class=\"language-cpp\">struct bpf_test_run_opts {\n &nbsp; &nbsp; // 结构体的大小，用于前向 / 后向兼容性\n &nbsp; &nbsp;size_t sz;\n​\n &nbsp; &nbsp;// 输入数据的指针，可选\n &nbsp; &nbsp;const void *data_in;\n &nbsp; &nbsp;// 输入数据的大小\n &nbsp; &nbsp;__u32 data_size_in;\n​\n &nbsp; &nbsp;// 输出数据的指针，可选\n &nbsp; &nbsp;void *data_out;\n &nbsp; &nbsp;// 输出数据的大小\n &nbsp; &nbsp;// 输入时：data_out 的最大长度\n &nbsp; &nbsp;// 输出时：data_out 的实际长度\n &nbsp; &nbsp;__u32 data_size_out;\n​\n &nbsp; &nbsp;// 输入上下文的指针，可选\n &nbsp; &nbsp;const void *ctx_in;\n &nbsp; &nbsp;// 输入上下文的大小\n &nbsp; &nbsp;__u32 ctx_size_in;\n &nbsp; &nbsp;// 输出上下文的指针，可选\n &nbsp; &nbsp;void *ctx_out;\n &nbsp; &nbsp;// 输出上下文的大小\n &nbsp; &nbsp;// 输入时：ctx_out 的最大长度\n &nbsp; &nbsp;// 输出时：ctx_out 的实际长度\n &nbsp; &nbsp;__u32 ctx_size_out;\n​\n &nbsp; &nbsp;// eBPF 程序的返回值（作为输出）\n &nbsp; &nbsp;__u32 retval;\n​\n &nbsp; &nbsp;// 重复执行次数（用于基准测试）\n &nbsp; &nbsp;int repeat;\n​\n &nbsp; &nbsp;// 平均每次执行的耗时（单位纳秒，作为输出）\n &nbsp; &nbsp;__u32 duration;\n​\n &nbsp; &nbsp;// 标志位\n &nbsp; &nbsp;__u32 flags;\n​\n &nbsp; &nbsp;// 指定运行 BPF 程序的 CPU\n &nbsp; &nbsp;__u32 cpu;\n​\n &nbsp; &nbsp;// 批处理大小\n &nbsp; &nbsp;__u32 batch_size;\n};\n</code></pre><p>接下来，让我用一个简单的示例带你一起看看如何使用 <code>bpf_prog_test_run_opts()</code> 来做单元测试。</p><h3>eBPF 程序</h3><p>要做单元测试，首先当然还是需要有一个待测试的 eBPF 程序，以下就是这个 eBPF 程序的核心代码（完整的代码请参考 <a href=\"https://github.com/feiskyer/ebpf-apps/blob/main/bpf-apps/xdp_drop_test.bpf.c\">GitHub</a>）：</p><pre><code class=\"language-cpp\">SEC(\"xdp\")\nint xdp_prog_drop(struct xdp_md *ctx)\n{\n &nbsp;void *data = (void *)(long)ctx-&gt;data;\n &nbsp;void *data_end = (void *)(long)ctx-&gt;data_end;\n &nbsp;int pkt_sz = data_end - data;\n​\n &nbsp;bpf_printk(\"packet size: %d\", pkt_sz);\n​\n &nbsp;struct ethhdr *eth = data;\n &nbsp;struct iphdr *iph = data + sizeof(struct ethhdr);\n &nbsp;if (data + sizeof(struct ethhdr) + sizeof(struct iphdr) &gt; data_end)\n  {\n &nbsp; &nbsp;return XDP_PASS;\n  }\n​\n &nbsp;if (iph-&gt;protocol == IPPROTO_ICMP)\n  {\n &nbsp; return XDP_DROP;\n  }\n​\n &nbsp;return XDP_PASS;\n}\n</code></pre><p>从这段代码你可以看出，它的功能就是丢弃所有的 ICMP 包，而正常放过其他类型的网络包。</p><h3>单元测试程序</h3><p>eBPF 程序开发完成后，接下来我们就可以开始开发单元测试程序了。和常规的 eBPF 程序类似，我们还需要首先编译 eBPF 程序为字节码，然后再调用 &nbsp;<code>bpftool gen skeleton</code>&nbsp; 为 eBPF 字节码生成脚手架头文件，最后再到测试文件中引用脚手架头文件加载并测试 eBPF 程序。</p><p>忽略异常处理和工具函数后，测试程序的核心代码如下所示（完整的代码请参考 <a href=\"https://github.com/feiskyer/ebpf-apps/blob/main/bpf-apps/xdp_drop_test.c\">GitHub</a>）：</p><pre><code class=\"language-cpp\">​int main(int argc, char **argv)\n{\n &nbsp;/* 1. 构造 ICMP 和 TCP 包 */\n &nbsp;char *icmp_packet = get_icmp();\n &nbsp;char *tcp_packet = get_tcp();\n​\n &nbsp;/* 2. 构造 ICMP 测试参数 */\n &nbsp;struct bpf_test_run_opts opts = {\n &nbsp;  .sz = sizeof(struct bpf_test_run_opts),\n &nbsp;  .data_in = icmp_packet,\n &nbsp;  .data_size_in = ICMP_SIZE,\n  };\n​\n &nbsp;/* 3. 加载 XDP 程序 */\n &nbsp;struct xdp_drop_test_bpf *obj = xdp_drop_test_bpf__open_and_load();\n &nbsp;if (!obj) {\n &nbsp; &nbsp;fprintf(stderr, \"failed to open and/or load BPF object\\n\");\n &nbsp; &nbsp;free(icmp_packet);\n &nbsp; &nbsp;free(tcp_packet);\n &nbsp; &nbsp;return 1;\n  }\n​\n &nbsp;/* 4. 执行 ICMP 测试 */\n &nbsp;int prog_id = bpf_program__fd(obj-&gt;progs.xdp_prog_drop);\n &nbsp;int err = bpf_prog_test_run_opts(prog_id, &amp;opts);\n &nbsp;if (err != 0) {\n &nbsp; &nbsp;fprintf(stderr,\n &nbsp; &nbsp; &nbsp;\"[FAIL] failed to run bpf_prog_test_run_opts() for ICMP: %d\\n\",\n &nbsp; &nbsp; &nbsp;err);\n &nbsp; &nbsp;goto cleanup;\n  }\n &nbsp;if (opts.retval == XDP_DROP) {\n &nbsp; &nbsp;fprintf(stdout, \"[PASS] ICMP packets dropped\\n\");\n  } else {\n &nbsp; &nbsp;fprintf(stdout, \"[FAIL] ICMP packets not dropped\\n\");\n  }\n​\n &nbsp;/* 5. 构造 TCP 测试参数并执行 TCP 测试 */\n &nbsp;struct bpf_test_run_opts tcp_opts = {\n &nbsp;  .sz = sizeof(struct bpf_test_run_opts),\n &nbsp;  .data_in = tcp_packet,\n &nbsp;  .data_size_in = TCP_SIZE,\n  };\n &nbsp;err = bpf_prog_test_run_opts(prog_id, &amp;tcp_opts);\n &nbsp;if (err != 0) {\n &nbsp; &nbsp;fprintf(stderr,\n &nbsp; &nbsp; &nbsp;\"[FAIL] failed to run bpf_prog_test_run_opts() for TCP: %d\\n\",\n &nbsp; &nbsp; &nbsp;err);\n &nbsp; &nbsp;goto cleanup;\n  }\n &nbsp;if (tcp_opts.retval == XDP_PASS) {\n &nbsp; &nbsp;fprintf(stdout, \"[PASS] TCP packets passed\\n\");\n  } else {\n &nbsp; &nbsp;fprintf(stdout, \"[FAIL] TCP packets not passed\\n\");\n  }\n​\n &nbsp;// cleanup\n  ...\n}\n</code></pre><p>从这段代码中你可以看出，测试 eBPF 程序主要分为三步。</p><ul>\n<li>第一步，构造输入数据：eBPF 程序所需要的数据和上下文信息需要在测试之前构造好，这里我们构造了一个 ICMP 包和一个 TCP 包。</li>\n<li>第二步，加载 eBPF 程序：eBPF 程序加载之后不再需要挂载到网卡上，而是在运行测试时通过构造数据自动触发其执行。</li>\n<li>第三，开始测试：设置 <code>bpf_test_run_opts</code> 参数之后运行 <code>bpf_prog_test_run_opts()</code> 开始测试，最后再验证运行结果是否跟期望值相同。</li>\n</ul><p>测试程序编译之后，你就可以开始运行测试了。注意测试时需要使用 sudo 或者 root 用户运行，如果一切正常，你将看到如下的输出：</p><pre><code class=\"language-shell\"># sudo ./xdp_drop_test\n[PASS] ICMP packets dropped\n[PASS] TCP packets passed\n</code></pre><p>对于大型应用程序，你还可以基于 <code>BPF_PROG_RUN</code> 构建专用的测试框架，进一步简化新功能的测试过程，从而确保测试的全面性和准确性。</p><p>一个典型的例子是 Cilium 项目。Cilium 团队基于 <code>BPF_PROG_RUN</code> 开发了一套独特的测试框架，专门针对其 eBPF 程序进行优化。通过定制化的测试框架， Cilium 能够更加高效地验证其复杂的网络和安全功能。如果你想深入了解 Cilium 的测试框架及其实现细节，可以参考它的 <a href=\"https://docs.cilium.io/en/stable/contributing/testing/bpf/\">官方测试文档</a>。</p><h2>小结</h2><p>今天，我带你一起探讨了 eBPF 程序的调试方法。eBPF 程序运行在内核虚拟机中，无法直接使用传统的调试工具，从而导致 eBPF 程序的调试成为一大难题。</p><p>在今天的课程中，我和你分享了两种有效调试 eBPF 程序的方法，即日志记录和单元测试。这两种方法虽然简单，却能在 eBPF 开发过程中发挥重要作用，帮助你有效调试和解决开发测试过程中的各种问题。</p><p>第一种，日志是最简单、最有效的调试方法，也是应用最广泛的一种方法。然而，由于日志记录对系统性能有较大影响，故而在生产环境中应当谨慎使用。</p><p>第二种，单元测试也是程序开发过程中必不可少的一环，良好的单元测试不仅能够帮你提前发现问题，还能为后续的新变更提供质量保障。借助 Libbpf 提供的</p><p><code>bpf_prog_test_run_opts()</code> 库函数，通过 <code>BPF_PROG_RUN</code> 方法对 eBPF 程序进行单元测试，操作起来也很方便。</p><p>你可能也注意到了，使用 <code>BPF_PROG_RUN</code> 这种方法来做测试时，实际上还是需要加载 eBPF 程序到内核里，所以它的测试过程还是依赖于测试所在系统的内核。</p><p>这样一来，想要测试不同版本内核的兼容性时，就需要我们为这些内核创建相应的测试环境。比如，你可以使用 QEMU 或者云平台为不同版本的内核创建响应的虚拟机，然后在这些虚拟机中测试不同内核的兼容性。</p><p>除了这些方法之外，对于 XDP、TC 和 cGroup 类型的 eBPF 程序，你还可以使用 fentry/fexit 来跟踪它们的执行过程。相比 kprobe，fentry/fexit 不仅性能优越，而且还能跟踪 eBPF 程序本身，而不是仅限于内核函数。</p><h3>思考与讨论</h3><p>最后，我想邀请你也来聊一聊你的 eBPF 程序开发经历，特别是调试过程中遇到的挑战及解决方法。你是否使用过今天课程中提到的调试方法呢？有什么宝贵经验可以与同学们交流吗？</p><p>期待你在留言区和我讨论，也欢迎把这节课分享给你的同事、朋友。让我们一起在实战中演练，在交流中进步。</p>","neighbors":{"left":{"article_title":"06 | 事件触发：各类eBPF程序的触发机制及其应用场景","id":483364},"right":[]},"comments":[]}