{"id":127900,"title":"12 | 连接无效：使用Keep-Alive还是应用心跳来检测？","content":"<p>你好，我是盛延敏，这里是网络编程实战第12讲，欢迎回来。</p><p>上一篇文章中，我们讲到了如何使用close和shutdown来完成连接的关闭，在大多数情况下，我们会优选shutdown来完成对连接一个方向的关闭，待对端处理完之后，再完成另外一个方向的关闭。</p><p>在很多情况下，连接的一端需要一直感知连接的状态，如果连接无效了，应用程序可能需要报错，或者重新发起连接等。</p><p>在这一篇文章中，我将带你体验一下对连接状态的检测，并提供检测连接状态的最佳实践。</p><h2>从一个例子开始</h2><p>让我们用一个例子开始今天的话题。</p><p>我之前做过一个基于NATS消息系统的项目，多个消息的提供者 （pub）和订阅者（sub）都连到NATS消息系统，通过这个系统来完成消息的投递和订阅处理。</p><p>突然有一天，线上报了一个故障，一个流程不能正常处理。经排查，发现消息正确地投递到了NATS服务端，但是消息订阅者没有收到该消息，也没能做出处理，导致流程没能进行下去。</p><p>通过观察消息订阅者后发现，消息订阅者到NATS服务端的连接虽然显示是“正常”的，但实际上，这个连接已经是无效的了。为什么呢？这是因为NATS服务器崩溃过，NATS服务器和消息订阅者之间的连接中断FIN包，由于异常情况，没能够正常到达消息订阅者，这样造成的结果就是消息订阅者一直维护着一个“过时的”连接，不会收到NATS服务器发送来的消息。</p><!-- [[[read_end]]] --><p>这个故障的根本原因在于，作为NATS服务器的客户端，消息订阅者没有及时对连接的有效性进行检测，这样就造成了问题。</p><p>保持对连接有效性的检测，是我们在实战中必须要注意的一个点。</p><h2>TCP Keep-Alive选项</h2><p>很多刚接触TCP编程的人会惊讶地发现，在没有数据读写的“静默”的连接上，是没有办法发现TCP连接是有效还是无效的。比如客户端突然崩溃，服务器端可能在几天内都维护着一个无用的 TCP连接。前面提到的例子就是这样的一个场景。</p><p>那么有没有办法开启类似的“轮询”机制，让TCP告诉我们，连接是不是“活着”的呢？</p><p>这就是TCP保持活跃机制所要解决的问题。实际上，TCP有一个保持活跃的机制叫做Keep-Alive。</p><p>这个机制的原理是这样的：</p><p>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的TCP连接已经死亡，系统内核将错误信息通知给上层应用程序。</p><p>上述的可定义变量，分别被称为保活时间、保活时间间隔和保活探测次数。在Linux系统中，这些变量分别对应sysctl变量<code>net.ipv4.tcp_keepalive_time</code>、<code>net.ipv4.tcp_keepalive_intvl</code>、 <code>net.ipv4.tcp_keepalve_probes</code>，默认设置是7200秒（2小时）、75秒和9次探测。</p><p>如果开启了TCP保活，需要考虑以下几种情况：</p><p>第一种，对端程序是正常工作的。当TCP保活的探测报文发送给对端, 对端会正常响应，这样TCP保活时间会被重置，等待下一个TCP保活时间的到来。</p><p>第二种，对端程序崩溃并重启。当TCP保活的探测报文发送给对端后，对端是可以响应的，但由于没有该连接的有效信息，会产生一个RST报文，这样很快就会发现TCP连接已经被重置。</p><p>第三种，是对端程序崩溃，或对端由于其他原因导致报文不可达。当TCP保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，TCP会报告该TCP连接已经死亡。</p><p>TCP保活机制默认是关闭的，当我们选择打开时，可以分别在连接的两个方向上开启，也可以单独在一个方向上开启。如果开启服务器端到客户端的检测，就可以在客户端非正常断连的情况下清除在服务器端保留的“脏数据”；而开启客户端到服务器端的检测，就可以在服务器无响应的情况下，重新发起连接。</p><p>为什么TCP不提供一个频率很好的保活机制呢？我的理解是早期的网络带宽非常有限，如果提供一个频率很高的保活机制，对有限的带宽是一个比较严重的浪费。</p><h2>应用层探活</h2><p>如果使用TCP自身的keep-Alive机制，在Linux系统中，最少需要经过2小时11分15秒才可以发现一个“死亡”连接。这个时间是怎么计算出来的呢？其实是通过2小时，加上75秒乘以9的总和。实际上，对很多对时延要求敏感的系统中，这个时间间隔是不可接受的。</p><p>所以，必须在应用程序这一层来寻找更好的解决方案。</p><p>我们可以通过在应用程序中模拟TCP Keep-Alive机制，来完成在应用层的连接探活。</p><p>我们可以设计一个PING-PONG的机制，需要保活的一方，比如客户端，在保活时间达到后，发起对连接的PING操作，如果服务器端对PING操作有回应，则重新设置保活时间，否则对探测次数进行计数，如果最终探测次数达到了保活探测次数预先设置的值之后，则认为连接已经无效。</p><p>这里有两个比较关键的点：</p><p>第一个是需要使用定时器，这可以通过使用I/O复用自身的机制来实现；第二个是需要设计一个PING-PONG的协议。</p><p>下面我们尝试来完成这样的一个设计。</p><h3>消息格式设计</h3><p>我们的程序是客户端来发起保活，为此定义了一个消息对象。你可以看到这个消息对象，这个消息对象是一个结构体，前4个字节标识了消息类型，为了简单，这里设计了<code>MSG_PING</code>、<code>MSG_PONG</code>、<code>MSG_TYPE 1</code>和<code>MSG_TYPE 2</code>四种消息类型。</p><pre><code>typedef struct {\n    u_int32_t type;\n    char data[1024];\n} messageObject;\n\n#define MSG_PING          1\n#define MSG_PONG          2\n#define MSG_TYPE1        11\n#define MSG_TYPE2        21\n</code></pre><h3>客户端程序设计</h3><p>客户端完全模拟TCP Keep-Alive的机制，在保活时间达到后，探活次数增加1，同时向服务器端发送PING格式的消息，此后以预设的保活时间间隔，不断地向服务器端发送PING格式的消息。如果能收到服务器端的应答，则结束保活，将保活时间置为0。</p><p>这里我们使用select I/O复用函数自带的定时器，select函数将在后面详细介绍。</p><pre><code>#include &quot;lib/common.h&quot;\n#include &quot;message_objecte.h&quot;\n\n#define    MAXLINE     4096\n#define    KEEP_ALIVE_TIME  10\n#define    KEEP_ALIVE_INTERVAL  3\n#define    KEEP_ALIVE_PROBETIMES  3\n\n\nint main(int argc, char **argv) {\n    if (argc != 2) {\n        error(1, 0, &quot;usage: tcpclient &lt;IPaddress&gt;&quot;);\n    }\n\n    int socket_fd;\n    socket_fd = socket(AF_INET, SOCK_STREAM, 0);\n\n    struct sockaddr_in server_addr;\n    bzero(&amp;server_addr, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(SERV_PORT);\n    inet_pton(AF_INET, argv[1], &amp;server_addr.sin_addr);\n\n    socklen_t server_len = sizeof(server_addr);\n    int connect_rt = connect(socket_fd, (struct sockaddr *) &amp;server_addr, server_len);\n    if (connect_rt &lt; 0) {\n        error(1, errno, &quot;connect failed &quot;);\n    }\n\n    char recv_line[MAXLINE + 1];\n    int n;\n\n    fd_set readmask;\n    fd_set allreads;\n\n    struct timeval tv;\n    int heartbeats = 0;\n\n    tv.tv_sec = KEEP_ALIVE_TIME;\n    tv.tv_usec = 0;\n\n    messageObject messageObject;\n\n    FD_ZERO(&amp;allreads);\n    FD_SET(socket_fd, &amp;allreads);\n    for (;;) {\n        readmask = allreads;\n        int rc = select(socket_fd + 1, &amp;readmask, NULL, NULL, &amp;tv);\n        if (rc &lt; 0) {\n            error(1, errno, &quot;select failed&quot;);\n        }\n        if (rc == 0) {\n            if (++heartbeats &gt; KEEP_ALIVE_PROBETIMES) {\n                error(1, 0, &quot;connection dead\\n&quot;);\n            }\n            printf(&quot;sending heartbeat #%d\\n&quot;, heartbeats);\n            messageObject.type = htonl(MSG_PING);\n            rc = send(socket_fd, (char *) &amp;messageObject, sizeof(messageObject), 0);\n            if (rc &lt; 0) {\n                error(1, errno, &quot;send failure&quot;);\n            }\n            tv.tv_sec = KEEP_ALIVE_INTERVAL;\n            continue;\n        }\n        if (FD_ISSET(socket_fd, &amp;readmask)) {\n            n = read(socket_fd, recv_line, MAXLINE);\n            if (n &lt; 0) {\n                error(1, errno, &quot;read error&quot;);\n            } else if (n == 0) {\n                error(1, 0, &quot;server terminated \\n&quot;);\n            }\n            printf(&quot;received heartbeat, make heartbeats to 0 \\n&quot;);\n            heartbeats = 0;\n            tv.tv_sec = KEEP_ALIVE_TIME;\n        }\n    }\n}\n</code></pre><p>这个程序主要分成三大部分：</p><p>第一部分为套接字的创建和连接建立：</p><ul>\n<li>15-16行，创建了TCP套接字；</li>\n<li>18-22行，创建了IPv4目标地址，其实就是服务器端地址，注意这里使用的是传入参数作为服务器地址；</li>\n<li>24-28行，向服务器端发起连接。</li>\n</ul><p>第二部分为select定时器准备：</p><ul>\n<li>39-40行，设置了超时时间为KEEP_ALIVE_TIME，这相当于保活时间；</li>\n<li>44-45行，初始化select函数的套接字。</li>\n</ul><p>最重要的为第三部分，这一部分需要处理心跳报文：</p><ul>\n<li>48行调用select函数，感知I/O事件。这里的I/O事件，除了套接字上的读操作之外，还有在39-40行设置的超时事件。当KEEP_ALIVE_TIME这段时间到达之后，select函数会返回0，于是进入53-63行的处理；</li>\n<li>在53-63行，客户端已经在KEEP_ALIVE_TIME这段时间内没有收到任何对当前连接的反馈，于是发起PING消息，尝试问服务器端：“喂，你还活着吗？”这里我们通过传送一个类型为MSG_PING的消息对象来完成PING操作，之后我们会看到服务器端程序如何响应这个PING操作；</li>\n<li>第65-74行是客户端在接收到服务器端程序之后的处理。为了简单，这里就没有再进行报文格式的转换和分析。在实际的工作中，这里其实是需要对报文进行解析后处理的，只有是PONG类型的回应，我们才认为是PING探活的结果。这里认为既然收到服务器端的报文，那么连接就是正常的，所以会对探活计数器和探活时间都置零，等待下一次探活时间的来临。</li>\n</ul><h3>服务器端程序设计</h3><p>服务器端的程序接受一个参数，这个参数设置的比较大，可以模拟连接没有响应的情况。服务器端程序在接收到客户端发送来的各种消息后，进行处理，其中如果发现是PING类型的消息，在休眠一段时间后回复一个PONG消息，告诉客户端：“嗯，我还活着。”当然，如果这个休眠时间很长的话，那么客户端就无法快速知道服务器端是否存活，这是我们模拟连接无响应的一个手段而已，实际情况下，应该是系统崩溃，或者网络异常。</p><pre><code>#include &quot;lib/common.h&quot;\n#include &quot;message_objecte.h&quot;\n\nstatic int count;\n\nint main(int argc, char **argv) {\n    if (argc != 2) {\n        error(1, 0, &quot;usage: tcpsever &lt;sleepingtime&gt;&quot;);\n    }\n\n    int sleepingTime = atoi(argv[1]);\n\n    int listenfd;\n    listenfd = socket(AF_INET, SOCK_STREAM, 0);\n\n    struct sockaddr_in server_addr;\n    bzero(&amp;server_addr, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    server_addr.sin_port = htons(SERV_PORT);\n\n    int rt1 = bind(listenfd, (struct sockaddr *) &amp;server_addr, sizeof(server_addr));\n    if (rt1 &lt; 0) {\n        error(1, errno, &quot;bind failed &quot;);\n    }\n\n    int rt2 = listen(listenfd, LISTENQ);\n    if (rt2 &lt; 0) {\n        error(1, errno, &quot;listen failed &quot;);\n    }\n\n    int connfd;\n    struct sockaddr_in client_addr;\n    socklen_t client_len = sizeof(client_addr);\n\n    if ((connfd = accept(listenfd, (struct sockaddr *) &amp;client_addr, &amp;client_len)) &lt; 0) {\n        error(1, errno, &quot;bind failed &quot;);\n    }\n\n    messageObject message;\n    count = 0;\n\n    for (;;) {\n        int n = read(connfd, (char *) &amp;message, sizeof(messageObject));\n        if (n &lt; 0) {\n            error(1, errno, &quot;error read&quot;);\n        } else if (n == 0) {\n            error(1, 0, &quot;client closed \\n&quot;);\n        }\n\n        printf(&quot;received %d bytes\\n&quot;, n);\n        count++;\n\n        switch (ntohl(message.type)) {\n            case MSG_TYPE1 :\n                printf(&quot;process  MSG_TYPE1 \\n&quot;);\n                break;\n\n            case MSG_TYPE2 :\n                printf(&quot;process  MSG_TYPE2 \\n&quot;);\n                break;\n\n            case MSG_PING: {\n                messageObject pong_message;\n                pong_message.type = MSG_PONG;\n                sleep(sleepingTime);\n                ssize_t rc = send(connfd, (char *) &amp;pong_message, sizeof(pong_message), 0);\n                if (rc &lt; 0)\n                    error(1, errno, &quot;send failure&quot;);\n                break;\n            }\n\n            default :\n                error(1, 0, &quot;unknown message type (%d)\\n&quot;, ntohl(message.type));\n        }\n\n    }\n\n}\n</code></pre><p>服务器端程序主要分为两个部分。</p><p>第一部分为监听过程的建立，包括7-38行； 第13-14行先创建一个本地TCP监听套接字；16-20行绑定该套接字到本地端口和ANY地址上；第27-38行分别调用listen和accept完成被动套接字转换和监听。</p><p>第二部分为43行到77行，从建立的连接套接字上读取数据，解析报文，根据消息类型进行不同的处理。</p><ul>\n<li>55-57行为处理MSG_TYPE1的消息；</li>\n<li>59-61行为处理MSG_TYPE2的消息；</li>\n<li>重点是64-72行处理MSG_PING类型的消息。通过休眠来模拟响应是否及时，然后调用send函数发送一个PONG报文，向客户端表示“还活着”的意思；</li>\n<li>74行为异常处理，因为消息格式不认识，所以程序出错退出。</li>\n</ul><h2>实验</h2><p>基于上面的程序设计，让我们分别做两个不同的实验：</p><p>第一次实验，服务器端休眠时间为60秒。</p><p>我们看到，客户端在发送了三次心跳检测报文PING报文后，判断出连接无效，直接退出了。之所以造成这样的结果，是因为在这段时间内没有接收到来自服务器端的任何PONG报文。当然，实际工作的程序，可能需要不一样的处理，比如重新发起连接。</p><pre><code>$./pingclient 127.0.0.1\nsending heartbeat #1\nsending heartbeat #2\nsending heartbeat #3\nconnection dead\n</code></pre><pre><code>$./pingserver 60\nreceived 1028 bytes\nreceived 1028 bytes\n</code></pre><p>第二次实验，我们让服务器端休眠时间为5秒。</p><p>我们看到，由于这一次服务器端在心跳检测过程中，及时地进行了响应，客户端一直都会认为连接是正常的。</p><pre><code>$./pingclient 127.0.0.1\nsending heartbeat #1\nsending heartbeat #2\nreceived heartbeat, make heartbeats to 0\nreceived heartbeat, make heartbeats to 0\nsending heartbeat #1\nsending heartbeat #2\nreceived heartbeat, make heartbeats to 0\nreceived heartbeat, make heartbeats to 0\n</code></pre><pre><code>$./pingserver 5\nreceived 1028 bytes\nreceived 1028 bytes\nreceived 1028 bytes\nreceived 1028 bytes\n</code></pre><h2>总结</h2><p>通过今天的文章，我们能看到虽然TCP没有提供系统的保活能力，让应用程序可以方便地感知连接的存活，但是，我们可以在应用程序里灵活地建立这种机制。一般来说，这种机制的建立依赖于系统定时器，以及恰当的应用层报文协议。比如，使用心跳包就是这样一种保持Keep Alive的机制。</p><h2>思考题</h2><p>和往常一样，我留两道思考题：</p><p>你可以看到今天的内容主要是针对TCP的探活，那么你觉得这样的方法是否同样适用于UDP呢？</p><p>第二道题是，有人说额外的探活报文占用了有限的带宽，对此你是怎么想的呢？而且，为什么需要多次探活才能决定一个TCP连接是否已经死亡呢？</p><p>欢迎你在评论区写下你的思考，我会和你一起交流。也欢迎把这篇文章分享给你的朋友或者同事，与他们一起讨论一下这两个问题吧。</p>","comments":[{"had_liked":false,"id":128858,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":true,"comment_ctime":1566977647,"is_pvip":false,"replies":[{"id":"47913","content":"2是一个很好的例子。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1567004470,"ip_address":"","comment_id":128858,"utype":1}],"discussion_count":5,"race_medal":0,"score":"9.2233721071411999e+18","product_id":100032701,"comment_content":"思考题<br>1. udp不需要连接 所以没有必要心跳包<br>2. 我觉得还是很有必要判定存活 像以前网吧打游戏 朋友的电脑突然蓝屏死机 朋友的角色还残留于游戏中,所以服务器为了判定他是否真的存活还是需要一个心跳包 隔了一段时间过后把朋友角色踢下线","like_count":17,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465138,"discussion_content":"2是一个很好的例子。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567004470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2184325,"avatar":"https://static001.geekbang.org/account/avatar/00/21/54/85/ab5148ce.jpg","nickname":"duckman","note":"","ucode":"0184C26C4B6C1B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332635,"discussion_content":"总结：心跳包是用来查看当前连接的状态的，而不是网络状态，UDP非面向连接，也就并不存在用心跳包探测连接的问题了。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1607272781,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2184325,"avatar":"https://static001.geekbang.org/account/avatar/00/21/54/85/ab5148ce.jpg","nickname":"duckman","note":"","ucode":"0184C26C4B6C1B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336805,"discussion_content":"实际上多次探活并不能确定一个连接当前是否已经死亡了。但是可以制定这样的策略，根据这个策略，n次探活失败便标记为失败。\n\n类似于：“我观察不到你，就当做你不存在”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608706432,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2075086,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/a9/ce/23f2e185.jpg","nickname":"Running man","note":"","ucode":"F3357D6696A5C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325744,"discussion_content":"有时候会使用UDP模拟tcp实现相对可靠的连接，需要考虑保活心跳机制，也算一种非常规应用方式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605420951,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111870,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK2Az5uTh9ZGVA7yQCj1BXtXuicPRkvJicA97AoN9xX3bnPcUYglTMXJeZeoVbPQeJA7ICvQhR3KQ0w/132","nickname":"日不落帝国","note":"","ucode":"6A11ABBD8AC438","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":25600,"discussion_content":"学习学习","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570541887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128822,"user_name":"fjpcode","can_delete":false,"product_type":"c1","uid":1306092,"ip_address":"","ucode":"C32C5E3ECB9A90","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ61zTDmLk7IhLJn6seBPOwsVaKIWUWaxk5YmsdYBZUOYMQCsyl9iaQVSg9U5qJVLLOCFUoLUuYnRA/132","comment_is_top":false,"comment_ctime":1566967883,"is_pvip":false,"replies":[{"id":"47915","content":"👍","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1567004511,"ip_address":"","comment_id":128822,"utype":1}],"discussion_count":2,"race_medal":0,"score":"177660627019","product_id":100032701,"comment_content":"1.UDP里面各方并不会维护一个socket上下文状态是无连接的，如果为了连接而保活是不必要的，如果为了探测对端是否正常工作而做ping-pong也是可行的。<br>2.额外的探活报文是会占用一些带宽资源，可根据实际业务场景，适当增加保活时间，降低探活频率，简化ping-pong协议。 <br>3.多次探活是为了防止误伤，避免ping包在网络中丢失掉了，而误认为对端死亡。","like_count":41,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465119,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567004511,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1009652,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","nickname":"钱","note":"","ucode":"2C92A243A463D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56532,"discussion_content":"回答的好，我也觉得是这样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574495393,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207628,"user_name":"扩散性百万咸面包","can_delete":false,"product_type":"c1","uid":1905171,"ip_address":"","ucode":"6D703D51553B42","user_header":"https://static001.geekbang.org/account/avatar/00/1d/12/13/e103a6e3.jpg","comment_is_top":false,"comment_ctime":1587122890,"is_pvip":false,"replies":[{"id":"77716","content":"HTTP的 keep-alive是为了使http变成长连接，在此前的http 1.0中，每次http的请求-响应之后，tcp连接就会被释放掉，这显然是非常浪费的，于是通过加入keep-alive，使得http连接不会被立即释放。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1587303973,"ip_address":"","comment_id":207628,"utype":1}],"discussion_count":1,"race_medal":0,"score":"61716665034","product_id":100032701,"comment_content":"想到HTTP Header也能设置Connection: Keep-Alive，也是应用层协议，是不是底层实现也类似于定时器+Ping Pong的思路？","like_count":14,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492187,"discussion_content":"HTTP的 keep-alive是为了使http变成长连接，在此前的http 1.0中，每次http的请求-响应之后，tcp连接就会被释放掉，这显然是非常浪费的，于是通过加入keep-alive，使得http连接不会被立即释放。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587303973,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162494,"user_name":"云师兄","can_delete":false,"product_type":"c1","uid":1010459,"ip_address":"","ucode":"4475AF1598FBFD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/1b/4b397b80.jpg","comment_is_top":false,"comment_ctime":1576545850,"is_pvip":false,"replies":[{"id":"63912","content":"当然有。服务器端要探活client来保证自己不会维护无效连接，客户端来探活保持自己是不是可以持续申请资源。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1577604607,"ip_address":"","comment_id":162494,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35936284218","product_id":100032701,"comment_content":"文章中提到保活有两个方向，实际应用中，会有两个方向同时探测的场景吗","like_count":8,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478067,"discussion_content":"当然有。服务器端要探活client来保证自己不会维护无效连接，客户端来探活保持自己是不是可以持续申请资源。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577604607,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163994,"user_name":"满怀","can_delete":false,"product_type":"c1","uid":1483113,"ip_address":"","ucode":"EFAC662A37D684","user_header":"https://static001.geekbang.org/account/avatar/00/16/a1/69/0ddda908.jpg","comment_is_top":false,"comment_ctime":1576842046,"is_pvip":false,"replies":[{"id":"63900","content":"是的，大部分的应用程序开发者都会选择自己在应用层处理连接有效性的检测。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1577604074,"ip_address":"","comment_id":163994,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27346645822","product_id":100032701,"comment_content":"老师 我想问一下 看您在回复当中有说 虽然TCP本身的keep-alive机制可以设置保活时间，保活探测时间间隔以及探测次数，但是应用层会无法感知，那么这种情况下会怎么处理呢 就是文中所给出的三种情况吗","like_count":6,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478608,"discussion_content":"是的，大部分的应用程序开发者都会选择自己在应用层处理连接有效性的检测。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577604074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131377,"user_name":"徐凯","can_delete":false,"product_type":"c1","uid":1244991,"ip_address":"","ucode":"12F82BA3649CD5","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/3f/bbb8a88c.jpg","comment_is_top":false,"comment_ctime":1567733875,"is_pvip":false,"replies":[{"id":"50812","content":"首先，客户端应用程序崩溃是可以有FIN包的，如果有的话，read阻塞就可以返回了；其次，如果真的是客户端机器跪了，那么是没有FIN包发出的，这个时候，我们只好一直在那里傻等。<br><br>且慢，还有别的辙，那就是不要用阻塞I&#47;O，不要在哪里傻傻等待。使用I&#47;O复用就可以办到的，往后看就会明白了。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1568194771,"ip_address":"","comment_id":131377,"utype":1}],"discussion_count":3,"race_medal":0,"score":"23042570355","product_id":100032701,"comment_content":"老师  同步连接可以实现心跳包么 如果不能的话  那同步连接如果因为客户端崩溃 没有通过四次挥手结束连接  服务端还堵塞在接收数据  那么这样如何判断对方已经离开呢","like_count":5,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466422,"discussion_content":"首先，客户端应用程序崩溃是可以有FIN包的，如果有的话，read阻塞就可以返回了；其次，如果真的是客户端机器跪了，那么是没有FIN包发出的，这个时候，我们只好一直在那里傻等。\n\n且慢，还有别的辙，那就是不要用阻塞I/O，不要在哪里傻傻等待。使用I/O复用就可以办到的，往后看就会明白了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568194771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1244991,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ff/3f/bbb8a88c.jpg","nickname":"徐凯","note":"","ucode":"12F82BA3649CD5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":9632,"discussion_content":"所以说这个FIN包是不一定有的  服务端不能依赖于等待这个FIN包是么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568197889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1220130,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9e/22/b820e079.jpg","nickname":"拖鞋汉","note":"","ucode":"4A258AD458A623","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1244991,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ff/3f/bbb8a88c.jpg","nickname":"徐凯","note":"","ucode":"12F82BA3649CD5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":224578,"discussion_content":"除非是kernel崩溃，要不然FIN包一定有。kernel崩溃了，可以通过心跳或者多路复用的timeout机制来避免傻等。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1586316506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":9632,"ip_address":""},"score":224578,"extra":""}]}]},{"had_liked":false,"id":218485,"user_name":"rongyefeng","can_delete":false,"product_type":"c1","uid":1959482,"ip_address":"","ucode":"9A15D947E9D645","user_header":"https://static001.geekbang.org/account/avatar/00/1d/e6/3a/382cf024.jpg","comment_is_top":false,"comment_ctime":1589807918,"is_pvip":false,"replies":[{"id":"80985","content":"Bingo。确实是我忘记了:)","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1589977789,"ip_address":"","comment_id":218485,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14474709806","product_id":100032701,"comment_content":"服务器端恢复心跳包这段   <br>case MSG_PING:   <br>{  <br>    messageObject pong_message;     <br>    pong_message.type = MSG_PONG;  <br>    sleep(sleepingTime);      <br>     ssize_t rc = send(connfd, (char *) &amp;pong_message, sizeof(pong_message), 0);     <br>老师，这个type是int类型，应该将其转为网络序才对吧？ pong_message.type = htonl(MSG_PONG);     <br>而且你的客户端程序也是有转换的，是不是服务器端这里忘记了？","like_count":3,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495478,"discussion_content":"Bingo。确实是我忘记了:)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589977789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162486,"user_name":"HunterYuan","can_delete":false,"product_type":"c1","uid":1015256,"ip_address":"","ucode":"F8900C33D29AA7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/d8/d7c77764.jpg","comment_is_top":false,"comment_ctime":1576545173,"is_pvip":false,"replies":[{"id":"63913","content":"学习了。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1577604632,"ip_address":"","comment_id":162486,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14461447061","product_id":100032701,"comment_content":"对于协议栈中的TCP的keep-alive是可以手动配置的，全局配置通过修改net.ipv4下的等参数；局部配置可以通过setsockopt修改socket选项。在工作中遇到过一个oracle,windows服务器的保活时间大于，我们设备状态连接表的保活时间，导致，一段时间后重连，导致服务器报错问题。当时最最快的处理办法是，修改window默认的保活时间小于状态连接失效时间。","like_count":3,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478064,"discussion_content":"学习了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577604632,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129024,"user_name":"石将从","can_delete":false,"product_type":"c1","uid":1375617,"ip_address":"","ucode":"12F43E643D1D58","user_header":"https://static001.geekbang.org/account/avatar/00/14/fd/81/1864f266.jpg","comment_is_top":false,"comment_ctime":1567010041,"is_pvip":false,"replies":[{"id":"48204","content":"这是因为，嗯，跟select实现有关，我再后面讲select时详细剖析，现在先记住吧。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1567131818,"ip_address":"","comment_id":129024,"utype":1}],"discussion_count":4,"race_medal":0,"score":"14451911929","product_id":100032701,"comment_content":"为啥这句套接字要加1呢？int rc = select(socket_fd + 1, &amp;readmask, NULL, NULL, &amp;tv);","like_count":3,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465228,"discussion_content":"这是因为，嗯，跟select实现有关，我再后面讲select时详细剖析，现在先记住吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567131818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1622329,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c1/39/11904266.jpg","nickname":"Steiner","note":"","ucode":"232C1C75207A1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":10143,"discussion_content":"标准输入也是一个文件句柄，它的描述符是0，所以这个轮询范围要加1","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568267081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2184325,"avatar":"https://static001.geekbang.org/account/avatar/00/21/54/85/ab5148ce.jpg","nickname":"duckman","note":"","ucode":"0184C26C4B6C1B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332620,"discussion_content":"https://linux.die.net/man/2/select\n\n\nint select(int nfds, fd_set *readfds, fd_set *writefds,\n           fd_set *exceptfds, struct timeval *timeout);&#39;\n\n\nnfds is the highest-numbered file descriptor in any of the three sets, plus 1.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607269654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1260026,"avatar":"https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg","nickname":"安排","note":"","ucode":"F78CFA9624CAEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6767,"discussion_content":"select工作机制决定的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567090598,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":231381,"user_name":"郑祖煌","can_delete":false,"product_type":"c1","uid":1469608,"ip_address":"","ucode":"49A0D2E3279826","user_header":"https://static001.geekbang.org/account/avatar/00/16/6c/a8/1922a0f5.jpg","comment_is_top":false,"comment_ctime":1593660492,"is_pvip":false,"replies":[{"id":"85730","content":"没有服务器到客户端的反向连接检测么？M+10秒有点狠啊。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1593954512,"ip_address":"","comment_id":231381,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5888627788","product_id":100032701,"comment_content":"这个是客户端探活服务器是否还存活，还可以用服务器来探活客户端是否还存活。我原先也有接触过这个心跳，不过实现的机制比较简单，就是客户端连上服务器了，客户端要每个M秒向服务器发包，服务器如果在M+10秒内没收到这个心跳包就判定客户端已经死亡。就会在应用层方面判定客户端已经失去连接。","like_count":1,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500278,"discussion_content":"没有服务器到客户端的反向连接检测么？M+10秒有点狠啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593954512,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190110,"user_name":"刘士涛","can_delete":false,"product_type":"c1","uid":1192218,"ip_address":"","ucode":"6D83F766D189E5","user_header":"https://static001.geekbang.org/account/avatar/00/12/31/1a/fd82b2d5.jpg","comment_is_top":false,"comment_ctime":1584603574,"is_pvip":false,"replies":[{"id":"73535","content":"应用层设置ping-pang的操作，如果在一段时间内没有应用层心跳报文，认为tcp已经断开。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1584863601,"ip_address":"","comment_id":190110,"utype":1}],"discussion_count":4,"race_medal":0,"score":"5879570870","product_id":100032701,"comment_content":"请问老师一个tcp长连接，网络发生故障， client和server都还没有断开这个连接， 这时候client调用send发送数据是个什么行为？我理解send进缓冲区是一直成功的， 但是由于网络不通， 数据不会发出去。这时候如果想要发现这个tcp断开就只能client应用层设置一个超时， 超时后调用shutdown， 有其他的方式可以感知到这个tcp断开么","like_count":1,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487889,"discussion_content":"应用层设置ping-pang的操作，如果在一段时间内没有应用层心跳报文，认为tcp已经断开。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584863601,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2403622,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ad/26/d46f4394.jpg","nickname":"Owen","note":"","ucode":"FDE0D574B8ED5A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549947,"discussion_content":"马士兵","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644308424,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1993133,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/69/ad/0ba9f9f0.jpg","nickname":"ging_96","note":"","ucode":"F8936FC04BBFFC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290528,"discussion_content":"如果没有心跳检测，并且网络一直异常。其实对客户端和服务端是完全发现不了的吧。假如数据一直是单向传递，并且不需要对端回复。比如只能从服务端到客户端，当有数据需要发送，服务端找到对应的socket，然后写入发送缓冲区，被送到网络中。客户端永远也收不到，服务端还以为自己发送成功了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594524441,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2224386,"avatar":"https://static001.geekbang.org/account/avatar/00/21/f1/02/96082034.jpg","nickname":"Guchen","note":"","ucode":"9BD34F616F167A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1993133,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/69/ad/0ba9f9f0.jpg","nickname":"ging_96","note":"","ucode":"F8936FC04BBFFC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":316112,"discussion_content":"TCP应该不会那么蠢，如果网络一直异常，服务端发送到网络上的数据包迟迟到达不了客户端，也就无法接收到ACK，超时重传应该有上限吧，如果某个包重传了很多次还是得不到确认，应该就会默认链路不通吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603361118,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":290528,"ip_address":""},"score":316112,"extra":""}]}]},{"had_liked":false,"id":168981,"user_name":"Geek_d6f50f","can_delete":false,"product_type":"c1","uid":1793213,"ip_address":"","ucode":"4AA490453CF4FB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/wwM75BhyU43UYOJ6fZCZgY6pfNPGHHRlooPLQEtDGUNic4aLRHWmBRTpIiblBAFheUVm9Sw8HWAChcFsnVM2sd5Q/132","comment_is_top":false,"comment_ctime":1578232147,"is_pvip":true,"replies":[{"id":"68086","content":"是这样的，<br><br>当客户端10秒钟select超时时间到达，第一次进入heartbeat，发送报文给服务器端，同时客户端把下一次select超时时间设置为3秒(KEEP_ALIVE_INTERVAL)；<br><br>由于服务器端是5秒之后才回复，3秒之后，第二次heartbeat时间到，客户端发送第二个heartbeat。<br><br>5秒之后，第一次的heartbeat回复到，客户端把超时时间又重新设置为10秒。<br><br>再过5秒之后，第二次的heartbeat回复到，客户端把超时时间再次设置为10秒。<br><br>如此反复。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1580632415,"ip_address":"","comment_id":168981,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5873199443","product_id":100032701,"comment_content":"老师，第二次运行程序，客户端的定时器设定为每10秒钟进行一次select返回0，此时进行探测包发送。而服务器端延迟5秒进行应答，为什么客户端每次都能发送两个包后才清零？不应该是只进行一个包的发送，服务器端延迟5秒就给出应答，然后清零吗？","like_count":1,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480393,"discussion_content":"是这样的，\n\n当客户端10秒钟select超时时间到达，第一次进入heartbeat，发送报文给服务器端，同时客户端把下一次select超时时间设置为3秒(KEEP_ALIVE_INTERVAL)；\n\n由于服务器端是5秒之后才回复，3秒之后，第二次heartbeat时间到，客户端发送第二个heartbeat。\n\n5秒之后，第一次的heartbeat回复到，客户端把超时时间又重新设置为10秒。\n\n再过5秒之后，第二次的heartbeat回复到，客户端把超时时间再次设置为10秒。\n\n如此反复。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580632415,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138365,"user_name":"衬衫的价格是19美元","can_delete":false,"product_type":"c1","uid":1397631,"ip_address":"","ucode":"655F925451F772","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKVUskibDnhMt5MCIJ8227HWkeg2wEEyewps8GuWhWaY5fy7Ya56bu2ktMlxdla3K29Wqia9efCkWaQ/132","comment_is_top":false,"comment_ctime":1570179336,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5865146632","product_id":100032701,"comment_content":"tcp探活的目的之一是判断该连接是否还需要，以此决定是维持还是释放该连接资源。udp无连接，也不占用服务器或者客户端的资源，因此业务无需探活","like_count":1},{"had_liked":false,"id":129225,"user_name":"徐凯","can_delete":false,"product_type":"c1","uid":1244991,"ip_address":"","ucode":"12F82BA3649CD5","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/3f/bbb8a88c.jpg","comment_is_top":false,"comment_ctime":1567065847,"is_pvip":false,"replies":[{"id":"48197","content":"探活包的多次发送，还是为了减少误判的概率，你说的是一种情况，但我觉得多此探活肯定会拉长对一个&quot;无效&quot;连接的判断时间的。这个是一个tradeoff，所以大多数程序都把这个作为选项让使用者自己配置。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1567131047,"ip_address":"","comment_id":129225,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5862033143","product_id":100032701,"comment_content":"我看到大家对于第二个问题的答案都提到了为了避免探活包丢包 所以要发多个探活包。但是我觉得只要发了探活包对方就一定能收到，就算丢了 发送端也会重传。而大家说的发送多个探活包的原因 是因为重传需要等到计时器超时才传，而如果网络堵塞的话可能会出现频繁丢包 那么服务端可能需要很久才能知道对方已经离开 发多个探活包的话 就减少了这个等待的时间 这样理解对么","like_count":1,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465344,"discussion_content":"探活包的多次发送，还是为了减少误判的概率，你说的是一种情况，但我觉得多此探活肯定会拉长对一个&amp;quot;无效&amp;quot;连接的判断时间的。这个是一个tradeoff，所以大多数程序都把这个作为选项让使用者自己配置。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567131047,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1993133,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/69/ad/0ba9f9f0.jpg","nickname":"ging_96","note":"","ucode":"F8936FC04BBFFC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291124,"discussion_content":"在tcp ip层面，如果发送一个心跳包，经过tcp的可靠协议，一定能传递到对方或者Tcp超时，但是等待tcp报超时太慢，所以在应用层面上加了自己的超时判断，用于 “快速” 检测。这个解释针对的是为什么需要应用层实现超时，而不是靠Tcp发送心跳包超时；\n但是应用层判断，可能存在误判，如果网络延迟较大，或者对端正在忙于处理其他事务，那么这个心跳回复包最后是会回复的，但是会超时（超过我们的设置时间）；所以需要多此发送心跳包，一旦至少一个回复了，就表明其实对端是活着的。 所以这种机制是在tcp层面超时和误判之间寻求一个平衡，既可以快速发现问题，又不至于误判。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594712667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128694,"user_name":"LDxy","can_delete":false,"product_type":"c1","uid":1188710,"ip_address":"","ucode":"956432CE7B7761","user_header":"https://static001.geekbang.org/account/avatar/00/12/23/66/413c0bb5.jpg","comment_is_top":false,"comment_ctime":1566952479,"is_pvip":false,"replies":[{"id":"47917","content":"可以设置的，但是有时候应用层需要感知处理这样的异常","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1567004786,"ip_address":"","comment_id":128694,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5861919775","product_id":100032701,"comment_content":"TCP本身的keep-alive的时间是可以自己设置的吗？如果是可以自己设置的，为何还需要自己实现这个机制？","like_count":1,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465060,"discussion_content":"可以设置的，但是有时候应用层需要感知处理这样的异常","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567004786,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":357655,"user_name":"张贺龙","can_delete":false,"product_type":"c1","uid":1862219,"ip_address":"上海","ucode":"209B08E3E7075A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKSjC36vSdPiaibQqrVicXYk7pvia1JKpY8aib9DBNMBHIPVxPE19wP9MTm63akRp6uYBjFibEk6XytrgNg/132","comment_is_top":false,"comment_ctime":1663544645,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663544645","product_id":100032701,"comment_content":"保活是应用层的动作可以用于udp，在数据中心集群中多个主机的通讯也有使用udp通讯的场景，保活的作用还是相当大的；保活会占用额外带宽，但由于只在无业务消息时传送，因此不会影响正常业务信息的传送；多次确认是为了避免偶然网络抖动造成的消息传送超时","like_count":0},{"had_liked":false,"id":321035,"user_name":"Mandone","can_delete":false,"product_type":"c1","uid":1116017,"ip_address":"","ucode":"FE236389CEF200","user_header":"https://static001.geekbang.org/account/avatar/00/11/07/71/d3049207.jpg","comment_is_top":false,"comment_ctime":1636626546,"is_pvip":true,"replies":[{"id":"116707","content":"http的keep-alive不是我这里的心跳。<br>我这里的意思是指，通过在客户端-服务器之间发送定期的报文，用来检查连接的有效性。不一定是客户端发给服务器，服务器端也可以发送给客户端。在很多程序里都叫做&quot;ping-pang&quot;报文。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1636874978,"ip_address":"","comment_id":321035,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1636626546","product_id":100032701,"comment_content":"老师你在留言里面回复，很多实际的场景都是自己在应用层加心跳，这个是指http的keep-alive么？如果是在java开发的应用，这个心跳是指客户端定时向服务端发起请求么？可不可以结合一下java应用举一个例子","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530194,"discussion_content":"http的keep-alive不是我这里的心跳。\n我这里的意思是指，通过在客户端-服务器之间发送定期的报文，用来检查连接的有效性。不一定是客户端发给服务器，服务器端也可以发送给客户端。在很多程序里都叫做&amp;quot;ping-pang&amp;quot;报文。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636874978,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":293459,"user_name":"凌空飞起的剪刀腿","can_delete":false,"product_type":"c1","uid":1243680,"ip_address":"","ucode":"16FBBF4A3B54C6","user_header":"https://static001.geekbang.org/account/avatar/00/12/fa/20/0f06b080.jpg","comment_is_top":false,"comment_ctime":1621394271,"is_pvip":false,"replies":[{"id":"106718","content":"只能说，很多实际的场景都是自己在应用层加心跳来解的。没有好不好，是大家总结出来的行之有效的方法。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1621778779,"ip_address":"","comment_id":293459,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1621394271","product_id":100032701,"comment_content":"老师我想问一下， 连接无效：使用Keep-Alive还是应用心跳来检测？<br>是不是应该使用应用心跳来检测，比使用Keep-Alive更好啊？<br>","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520220,"discussion_content":"只能说，很多实际的场景都是自己在应用层加心跳来解的。没有好不好，是大家总结出来的行之有效的方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621778779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240867,"user_name":"守望","can_delete":false,"product_type":"c1","uid":1437287,"ip_address":"","ucode":"8EAF6C1921B08D","user_header":"https://static001.geekbang.org/account/avatar/00/15/ee/67/03c95ec2.jpg","comment_is_top":false,"comment_ctime":1597106676,"is_pvip":false,"replies":[{"id":"89397","content":"你说的这种情况，连接是需要重建建立的，心跳检测如果觉得慢，可以通过设置不同的处理逻辑来加速，比如一旦发现连接异常，就立即启动一个补偿机制，短时间内进行重连。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1597640813,"ip_address":"","comment_id":240867,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1597106676","product_id":100032701,"comment_content":"老师您好，有个问题想请教一下，假设服务端重启了，起来后还是绑定同样的ip和端口，而客户端仍然发送，如何最大程度的避免客户端发送数据丢失呢？这种心跳检测貌似发现过慢。","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503581,"discussion_content":"你说的这种情况，连接是需要重建建立的，心跳检测如果觉得慢，可以通过设置不同的处理逻辑来加速，比如一旦发现连接异常，就立即启动一个补偿机制，短时间内进行重连。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597640813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1437287,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ee/67/03c95ec2.jpg","nickname":"守望","note":"","ucode":"8EAF6C1921B08D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299310,"discussion_content":"感谢作者回复，确实，靠心跳太慢，而所谓的重发机制，应该基于有应答的，出于效率考虑，没有做应用层的自问自答，所以一旦连接异常，其实不太好判断之前发送的消息到底到达了没有。最后再次感谢作者的回复。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597652266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230270,"user_name":"饭","can_delete":false,"product_type":"c1","uid":1610573,"ip_address":"","ucode":"B3F1702D4DE604","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJKj3GbvevFibxwJibTqm16NaE8MXibwDUlnt5tt73KF9WS2uypha2m1Myxic6Q47Zaj2DZOwia3AgicO7Q/132","comment_is_top":false,"comment_ctime":1593331893,"is_pvip":false,"replies":[{"id":"85719","content":"你的结论是来自端口号的限制么？如果是这样的话，我觉得是一个错误的结论。后面章节讲到的C10K&#47;C10M问题，就是在研究单机上的连接达到10K、10M的技术。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1593953283,"ip_address":"","comment_id":230270,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1593331893","product_id":100032701,"comment_content":"老师，一台服务器同时在线的tcp&#47;ip连接数，理论上是不是最多只有65535个?","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499822,"discussion_content":"你的结论是来自端口号的限制么？如果是这样的话，我觉得是一个错误的结论。后面章节讲到的C10K/C10M问题，就是在研究单机上的连接达到10K、10M的技术。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593953283,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1610573,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJKj3GbvevFibxwJibTqm16NaE8MXibwDUlnt5tt73KF9WS2uypha2m1Myxic6Q47Zaj2DZOwia3AgicO7Q/132","nickname":"饭","note":"","ucode":"B3F1702D4DE604","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288996,"discussion_content":"是的，我看端口号码最大是65535，一个端口对应一个连接，所以这么认为，后面章节还没开始看。谢谢老师。另外我是做.net开发的，现在基于.net实现课堂中的案例，很多细节参数没法翻译了，类库封装得太好了。刷下一遍时，我想学点C++，然后来实现课堂C语言案例，不知道里面的细节设置，c++是不是都包含了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593954429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1336951,"avatar":"https://static001.geekbang.org/account/avatar/00/14/66/77/194ba21d.jpg","nickname":"lzh","note":"","ucode":"C3D83DF4230109","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1610573,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJKj3GbvevFibxwJibTqm16NaE8MXibwDUlnt5tt73KF9WS2uypha2m1Myxic6Q47Zaj2DZOwia3AgicO7Q/132","nickname":"饭","note":"","ucode":"B3F1702D4DE604","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381217,"discussion_content":"是你的头啊，nginx分分钟上十万并发连接。自己主动连别人需要占用端口，这时候受端口数量限制，别人主动连自己，没有端口限制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624956383,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":288996,"ip_address":""},"score":381217,"extra":""}]}]},{"had_liked":false,"id":227065,"user_name":"郑祖煌","can_delete":false,"product_type":"c1","uid":1469608,"ip_address":"","ucode":"49A0D2E3279826","user_header":"https://static001.geekbang.org/account/avatar/00/16/6c/a8/1922a0f5.jpg","comment_is_top":false,"comment_ctime":1592274037,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592274037","product_id":100032701,"comment_content":"1. udp不需要连接，所以没有为了判断连接是否可行而用数据包探活的必要。不过也可以同样通过这个方式去判断对端是否正常的存在着。<br>2. 觉得是很有必要的。 如果不判断是否存在，则有可能要耗费额外的资源去维护一个已经消亡的链接，同时还会让本来正常的运行逻辑运行的不正常。多次探活是为了避免关闭重启或者当前对端正在执行其他代码没办法及时回复的情况。","like_count":0},{"had_liked":false,"id":205699,"user_name":"一凡","can_delete":false,"product_type":"c1","uid":1897395,"ip_address":"","ucode":"5E9BE33452AF3B","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f3/b3/0ba7a760.jpg","comment_is_top":false,"comment_ctime":1586704319,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586704319","product_id":100032701,"comment_content":"1、UDP面向无连接 不需要心跳检测<br>2、占带宽是正常啦，消耗资源可接受，多次探活是排除丢包导致的问题（电脑Ping的时候都是发几个包证明连接）","like_count":0},{"had_liked":false,"id":204007,"user_name":"拖鞋汉","can_delete":false,"product_type":"c1","uid":1220130,"ip_address":"","ucode":"4A258AD458A623","user_header":"https://static001.geekbang.org/account/avatar/00/12/9e/22/b820e079.jpg","comment_is_top":false,"comment_ctime":1586318193,"is_pvip":false,"replies":[{"id":"76795","content":"如果是服务端探活，我可能就不会使用select来完成计时器了，这里的客户端例子只是一个参考实现。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1586680444,"ip_address":"","comment_id":204007,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1586318193","product_id":100032701,"comment_content":"select监听socket_fd，那么如果服务端探活呢，一个socket_fd上可能有多个connection_fd，这里面只要有一个触发了事件，select返回的值不就大于0了吗，心跳逻辑不就无法触发了？还是说心跳针对的是socket_fd，而不是connection_fd?","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491038,"discussion_content":"如果是服务端探活，我可能就不会使用select来完成计时器了，这里的客户端例子只是一个参考实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586680444,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167911,"user_name":"A.Windy","can_delete":false,"product_type":"c1","uid":1128146,"ip_address":"","ucode":"254868B270F26D","user_header":"https://static001.geekbang.org/account/avatar/00/11/36/d2/32d3545a.jpg","comment_is_top":false,"comment_ctime":1577961418,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1577961418","product_id":100032701,"comment_content":"看到后面就知道了， 嘿嘿 https:&#47;&#47;github.com&#47;froghui&#47;yolanda","like_count":0},{"had_liked":false,"id":167909,"user_name":"A.Windy","can_delete":false,"product_type":"c1","uid":1128146,"ip_address":"","ucode":"254868B270F26D","user_header":"https://static001.geekbang.org/account/avatar/00/11/36/d2/32d3545a.jpg","comment_is_top":false,"comment_ctime":1577961167,"is_pvip":true,"replies":[{"id":"65476","content":"应该搞定了吧","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1578213167,"ip_address":"","comment_id":167909,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1577961167","product_id":100032701,"comment_content":"程序编译不过， 说lib&#47;common.h 找不到， 怎么搞啊","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480052,"discussion_content":"应该搞定了吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578213167,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1128146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/36/d2/32d3545a.jpg","nickname":"A.Windy","note":"","ucode":"254868B270F26D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":119145,"discussion_content":"搞定了https://github.com/froghui/yolanda","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578218180,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157520,"user_name":"bbbi","can_delete":false,"product_type":"c1","uid":1682175,"ip_address":"","ucode":"9A539AEF791428","user_header":"https://static001.geekbang.org/account/avatar/00/19/aa/ff/e2c331e0.jpg","comment_is_top":false,"comment_ctime":1575184883,"is_pvip":false,"replies":[{"id":"60391","content":"基本是这样。而且应用层处理的时候，还有各种异常处理，便于暴露和发现问题，如果是使用tcp协议的keepalive，不是很容易处理这些细节。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1575189597,"ip_address":"","comment_id":157520,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1575184883","product_id":100032701,"comment_content":"我的理解是这样的：<br>TCP协议并没有提供一个保活的措施，如果出现TCP已经连接后，两端异常崩溃或者是编码问题没有及时的关闭连接(比如客户端发送--&gt;服务端收到消息返回数据--&gt;客户端收到后直接退出，没有调用close)，那么服务器会一直维护着这个通道，造成资源浪费。所以加入keepalive，系统提供一个计时器，在约定的时间下发送检测包。但是这个计时器检测时间默认是2小时开始检测时间太长，所以我们可以在应用层，手动发送检测包","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476454,"discussion_content":"基本是这样。而且应用层处理的时候，还有各种异常处理，便于暴露和发现问题，如果是使用tcp协议的keepalive，不是很容易处理这些细节。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575189597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1682175,"avatar":"https://static001.geekbang.org/account/avatar/00/19/aa/ff/e2c331e0.jpg","nickname":"bbbi","note":"","ucode":"9A539AEF791428","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":68056,"discussion_content":"老师，如果是这样的话，那tcp没有长链接，跟短链接之分了吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575198692,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154629,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1574496082,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574496082","product_id":100032701,"comment_content":"探测TCP连接是否有效，KEEP-ALIVE可以实现，不过时间太长啦！所以，通常会在应用层，自己仿照KEEP-ALIVE的原理弄一个自己更加可以灵活可控的。","like_count":0},{"had_liked":false,"id":144854,"user_name":"zhanyd","can_delete":false,"product_type":"c1","uid":1073845,"ip_address":"","ucode":"4C994EE512A3C4","user_header":"https://static001.geekbang.org/account/avatar/00/10/62/b5/4159fa05.jpg","comment_is_top":false,"comment_ctime":1572076203,"is_pvip":false,"replies":[{"id":"55888","content":"哪里没看懂？","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1572099174,"ip_address":"","comment_id":144854,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572076203","product_id":100032701,"comment_content":"这程序，没看懂。。。","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472138,"discussion_content":"哪里没看懂？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572099174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139114,"user_name":"15652790052","can_delete":false,"product_type":"c1","uid":1274615,"ip_address":"","ucode":"8A15D673C16A8F","user_header":"","comment_is_top":false,"comment_ctime":1570547969,"is_pvip":false,"replies":[{"id":"54317","content":"这种情况下确实不会傻等。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1570972969,"ip_address":"","comment_id":139114,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1570547969","product_id":100032701,"comment_content":"请教一个问题: 客户端如果奔溃了-&gt;进程退出了-&gt;内核会收到关于此进程的所有资源,包括socket文件-&gt;意味这个socket的两个方向都关闭了,怎么会感知不到而傻等呢","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469797,"discussion_content":"这种情况下确实不会傻等。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570972969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137220,"user_name":"陈诚","can_delete":false,"product_type":"c1","uid":1338751,"ip_address":"","ucode":"138DD00D245FEE","user_header":"https://static001.geekbang.org/account/avatar/00/14/6d/7f/e1c189c7.jpg","comment_is_top":false,"comment_ctime":1569658537,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1569658537","product_id":100032701,"comment_content":"如果能收到服务器端的应答，则结束保活，将保活时间置为 0。<br><br>---&gt;<br>如果能收到服务器端的应答，则结束保活，将保活时间置为KEEP_ALIVE_TIME，即恢复初值","like_count":0,"discussions":[{"author":{"id":1851730,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/ooYDTtTQHL9CZQmonDOQSC4Af9S4uqicXzUicOqEJqSOtHyOZ81PTpxcTqK5ibNHsaNWJIuHiaVcxB8gIo9RNXsshA/132","nickname":"小叶","note":"","ucode":"EFD624AD6B2686","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387959,"discussion_content":"我也是这么认为，原文是不是错了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628509174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136303,"user_name":"有点意思","can_delete":false,"product_type":"c1","uid":1399454,"ip_address":"","ucode":"67F55604E8A548","user_header":"https://static001.geekbang.org/account/avatar/00/15/5a/9e/8f2ccc1d.jpg","comment_is_top":false,"comment_ctime":1569405561,"is_pvip":true,"replies":[{"id":"52207","content":"每秒一次会不会太快了？","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1569408068,"ip_address":"","comment_id":136303,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1569405561","product_id":100032701,"comment_content":"老师 你好<br>现在做的项目中要用到心跳，具体是这样的<br>服务端一个 客户端多个<br>每个客户端会持续的往服务端发送从网卡抓取的流量，如果某段时间网卡没有流量就不发 但是连接还需要维持 之前用的keepalive 现在想换成应用层心跳<br>想到的方案如下:<br>客户端开启线程1来发送抓到的流量 并且每间隔1秒就发送一次心跳给服务端 服务端收到心跳会回复一下<br>同时开启另外一个线程2启用select和recv来接收心跳响应 如果在 3秒内没接受到心跳 那么就判断连接断开<br><br>老师你觉得这种方案可以么 有什么缺点么","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468556,"discussion_content":"每秒一次会不会太快了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569408068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1306092,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ61zTDmLk7IhLJn6seBPOwsVaKIWUWaxk5YmsdYBZUOYMQCsyl9iaQVSg9U5qJVLLOCFUoLUuYnRA/132","nickname":"fjpcode","note":"","ucode":"C32C5E3ECB9A90","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":66547,"discussion_content":"我觉得没必要高两个线程吧，既然用到了select, 可以利用select的timeout机制来做心跳保活，只需要记录一下上一次发送心跳的时间就可以了，例如select超时时间设置成500ms。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575083729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1399454,"avatar":"https://static001.geekbang.org/account/avatar/00/15/5a/9e/8f2ccc1d.jpg","nickname":"有点意思","note":"","ucode":"67F55604E8A548","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":21127,"discussion_content":"如果将间隔时间改大一点比如3秒 那select的时候我就将超时时间设成9秒\n超时时间是间隔时间的3倍 类似于你的实例代码里面通过发送三次来判断连接还在不在\n你看这样可以么\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569422857,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132647,"user_name":"冷雨","can_delete":false,"product_type":"c1","uid":1082022,"ip_address":"","ucode":"2ED2978575862F","user_header":"https://static001.geekbang.org/account/avatar/00/10/82/a6/01ee14d5.jpg","comment_is_top":false,"comment_ctime":1568184702,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568184702","product_id":100032701,"comment_content":"第一题:udp可以使用同样的方式<br>第二题:确实占用带宽，但一方面ping-pong报文大小比较小，带宽占用有限，另一方面及时确认连接是否可用比带宽的损耗要重要的多。为什么要多次才能确认呢，因为网络抖动可能导致ping消息没有收到或者pong消息没有返回，如果一次就关闭，很容易导致误杀，而且socket建立的成本也比较高，多次确认对应用程序来说也是可以接受的。","like_count":0},{"had_liked":false,"id":132447,"user_name":"Rancood","can_delete":false,"product_type":"c1","uid":1204333,"ip_address":"","ucode":"052BDF2221F480","user_header":"https://static001.geekbang.org/account/avatar/00/12/60/6d/e2576fda.jpg","comment_is_top":false,"comment_ctime":1568124164,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568124164","product_id":100032701,"comment_content":"UDP本身就是无连接的，不需要探活；现在带宽可以忽略不计了，有时候可能因为网络原因报文不可达，所以需要多试几次","like_count":0},{"had_liked":false,"id":131975,"user_name":"另一半棉花糖","can_delete":false,"product_type":"c1","uid":1593363,"ip_address":"","ucode":"C11266794FBA5B","user_header":"https://static001.geekbang.org/account/avatar/00/18/50/13/104d9501.jpg","comment_is_top":false,"comment_ctime":1567997551,"is_pvip":false,"replies":[{"id":"50783","content":"这个是你工作中碰到过的，还是你自己构想出来的案例？<br><br>本质上，你问的问题是网络有延迟，导致检测时间也有延迟，我觉得这个是完全正常的，因为我们的程序是&quot;企图&quot;发现对端是否down掉了，是一个后知后觉型的，肯定是需要时间判断的。一般我们可以通过设置这个N的值来进行调整。比如N=3，三个包不回就认为down掉了。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1568189435,"ip_address":"","comment_id":131975,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567997551","product_id":100032701,"comment_content":"在对端计算能力紧张、或者网络延迟比较大的时候，仍然会对每一个ping包都做回复，但是本端可能在发了第KEEP_ALIVE_PROBETIMES-1个包之后才收到对端针对第一个ping做的回复。这样虽然本端就会认为这个连接是有效的，但会在接下来接收到好几个pong包；如果这一批的某一个pong包的到来时间正好落在本端第二次由于select超时而进行链路探测的时间段内的话，则可能产生“对端实际已经down了，但是本端过很久才能检测到（可能要达到N个select超时时间）”的问题。这个问题该怎么解决？要给ping和pong加序列号以用于匹配么？","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466706,"discussion_content":"这个是你工作中碰到过的，还是你自己构想出来的案例？\n\n本质上，你问的问题是网络有延迟，导致检测时间也有延迟，我觉得这个是完全正常的，因为我们的程序是&amp;quot;企图&amp;quot;发现对端是否down掉了，是一个后知后觉型的，肯定是需要时间判断的。一般我们可以通过设置这个N的值来进行调整。比如N=3，三个包不回就认为down掉了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568189435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131928,"user_name":"Smirk","can_delete":false,"product_type":"c1","uid":1230263,"ip_address":"","ucode":"F677072767F0A4","user_header":"https://static001.geekbang.org/account/avatar/00/12/c5/b7/87e7e865.jpg","comment_is_top":false,"comment_ctime":1567984208,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1567984208","product_id":100032701,"comment_content":"占带宽那个问题忙时不用探活包，正常通讯本身可以判是不是活，闲时探活包数据量比正常通讯包小很多。","like_count":0},{"had_liked":false,"id":131278,"user_name":"wyf2317","can_delete":false,"product_type":"c1","uid":1236837,"ip_address":"","ucode":"7F3E61A6188B39","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ub4icibeRLzff8Nf6ORsolib9KHtmeu3d4cCCAFd3Xgah3v78WfDYQB7WKq9iaIPXPwHBxw7mkBP9wYxDGMT9m1Rbw/132","comment_is_top":false,"comment_ctime":1567689121,"is_pvip":true,"replies":[{"id":"50821","content":"哈哈，9102年。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1568195219,"ip_address":"","comment_id":131278,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567689121","product_id":100032701,"comment_content":"1 udp不需要<br>2 9102年了，这点带宽不成问题。反倒是保持连接带来的一系列资源消耗才是重点。增加心跳检查可以快速确认客户端是否存活或者客户端快速重连。减少资源消耗，提升用户体验。","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466367,"discussion_content":"哈哈，9102年。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568195219,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130073,"user_name":"苦行僧","can_delete":false,"product_type":"c1","uid":1055334,"ip_address":"","ucode":"726024A9A9CF44","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/66/2d9db9ed.jpg","comment_is_top":false,"comment_ctime":1567383660,"is_pvip":false,"replies":[{"id":"50840","content":"好吧，我应该加上你说的&quot;点题&quot;的。我在总结里加了一点。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1568196415,"ip_address":"","comment_id":130073,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567383660","product_id":100032701,"comment_content":"使用心跳包不就是为了保持keep alive吗？文章内容到最后也没有点题？","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465788,"discussion_content":"好吧，我应该加上你说的&amp;quot;点题&amp;quot;的。我在总结里加了一点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568196415,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129826,"user_name":"沉淀的梦想","can_delete":false,"product_type":"c1","uid":1177315,"ip_address":"","ucode":"BCB7C26F9D214B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f6/e3/e4bcd69e.jpg","comment_is_top":false,"comment_ctime":1567277930,"is_pvip":false,"replies":[{"id":"50842","content":"我应该还把heatbeats置为0了。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1568196684,"ip_address":"","comment_id":129826,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1567277930","product_id":100032701,"comment_content":"老师在pingclient的实现中，为什么只要该一下结构体的字段值就能重置探活时间了？<br><br>        if (FD_ISSET(socket_fd, &amp;readmask)) {<br>            &#47;&#47;......<br>            &#47;&#47; 重置探活时间<br>            tv.tv_sec = KEEP_ALIVE_TIME;<br>        }","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465668,"discussion_content":"我应该还把heatbeats置为0了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568196684,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1593363,"avatar":"https://static001.geekbang.org/account/avatar/00/18/50/13/104d9501.jpg","nickname":"另一半棉花糖","note":"","ucode":"C11266794FBA5B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8406,"discussion_content":"看一下select调用的最后一个参数的意义吧。。代码里，改完这个时间之后，就又进select了，用tv作为最后一个参数的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567997789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128864,"user_name":"张立华","can_delete":false,"product_type":"c1","uid":1231713,"ip_address":"","ucode":"173B938DD9478A","user_header":"https://static001.geekbang.org/account/avatar/00/12/cb/61/b62d8a3b.jpg","comment_is_top":false,"comment_ctime":1566978142,"is_pvip":false,"replies":[{"id":"47911","content":"很老的一个版本，大概在2014-1015年的java-nats client版本吧。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1567004399,"ip_address":"","comment_id":128864,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566978142","product_id":100032701,"comment_content":"请问下作者，你提到的nats客户端的问题，是nats客户端的那个版本的bug","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465142,"discussion_content":"很老的一个版本，大概在2014-1015年的java-nats client版本吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567004399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128860,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1566977840,"is_pvip":false,"replies":[{"id":"47912","content":"那是一个过时的连接，显然应该被服务器端检测到，并摘掉这个过时的占用系统资源的连接。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1567004447,"ip_address":"","comment_id":128860,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566977840","product_id":100032701,"comment_content":"其实我也在想比如客户端崩溃重启过后 然后重新建立连接 创建socket 那之前那个连接是怎么处理的？因为之前那个服务器那个连接发往的还是我 所以就想知道这个时候是怎么处理的","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465140,"discussion_content":"那是一个过时的连接，显然应该被服务器端检测到，并摘掉这个过时的占用系统资源的连接。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567004447,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128818,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1566967307,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566967307","product_id":100032701,"comment_content":"1.udp本来无连接，不需要探活<br>2.多次探活的原因可能会发生探活丢包","like_count":0},{"had_liked":false,"id":128789,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1566963258,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566963258","product_id":100032701,"comment_content":"思考题:<br>1.适用也不适用，具体看应用场景，UDP本身无连接，根本没有必要保活，如果是基于UDP做一些其它协议如HTTP&#47;3，就是在UDP层做的探活。<br>2.探活报文很小，但如果每台机器，每个应用，每个连接都大量存在探活，那整个网络环境就都是探活报文了，带宽确实会被大量占用。为什么要多次探活，因为探活报文也可能发生丢包。","like_count":0},{"had_liked":false,"id":128742,"user_name":"锦","can_delete":false,"product_type":"c1","uid":1468298,"ip_address":"","ucode":"CB0EB4B68C468B","user_header":"https://static001.geekbang.org/account/avatar/00/16/67/8a/babd74dc.jpg","comment_is_top":false,"comment_ctime":1566955775,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566955775","product_id":100032701,"comment_content":"1,我觉得同样适合udp协议，虽然udp是无连接的，但是为了更好的利用网络资源，还是需要探活机制<br>2,探活机制设置合理的情况下对带宽影响不大，资源消耗不多，到作用很大，性价比很高<br>需要多次探活是为了double check，可能有些回包还没找到回家的路，也有可能对端正在故障恢复，需要一些时间。","like_count":0},{"had_liked":false,"id":128705,"user_name":"webmin","can_delete":false,"product_type":"c1","uid":1047014,"ip_address":"","ucode":"98B0CA882454E8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/e6/47742988.jpg","comment_is_top":false,"comment_ctime":1566953076,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1566953076","product_id":100032701,"comment_content":"长连接的情况下，最好要做双向探测。<br>UDP也适用，UPD下的探测可以知道是否网络发生故障。<br>单次看比较小，连接数的量级很大的话，加起来探测占用的带宽就会很大。<br>一次通信在网络中有可能要经过多个设备，其中有设备可能出现瞬时故障，也可能会多条通路，其中一条路有问题。","like_count":0},{"had_liked":false,"id":128689,"user_name":"杨领well","can_delete":false,"product_type":"c1","uid":1145650,"ip_address":"","ucode":"3974A03855168C","user_header":"https://static001.geekbang.org/account/avatar/00/11/7b/32/60089a62.jpg","comment_is_top":false,"comment_ctime":1566951325,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566951325","product_id":100032701,"comment_content":"能多次探测，说明对端极有可能还存在，只是因为各种原因导致没收到回复的包。因为如果对端不存在了，应该会收到 RST，导致链接关闭。","like_count":0},{"had_liked":false,"id":128684,"user_name":"xindoo","can_delete":false,"product_type":"c1","uid":1101718,"ip_address":"","ucode":"AEAF3208E644BC","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/96/251c0cee.jpg","comment_is_top":false,"comment_ctime":1566950520,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"1566950520","product_id":100032701,"comment_content":"第一个问题，我觉得不适合udp，udp本身是无连接的，所以就没必要探活来保持连接。 <br>第二个问题，以现今网络传输数据量看，探活报文只会占所有传输数据量极小部分，甚至可以忽略不计，所以占有限贷款一说就是伪命题。 至于需要多次探活，还是为了避免因为网络丢包的问题导致的误判。","like_count":0,"discussions":[{"author":{"id":1081922,"avatar":"https://static001.geekbang.org/account/avatar/00/10/82/42/8b04d489.jpg","nickname":"刘丹","note":"","ucode":"66594D1C957E15","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6515,"discussion_content":"UDP应用也应该在业务上做探活，如果长时间没通信，就无法判断对端状态","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566954721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1236766,"avatar":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","nickname":"传说中的成大大","note":"","ucode":"103543D6E706BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1081922,"avatar":"https://static001.geekbang.org/account/avatar/00/10/82/42/8b04d489.jpg","nickname":"刘丹","note":"","ucode":"66594D1C957E15","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6740,"discussion_content":"dup本来就不关心状态啊 想发就发也不关心你收不收得到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567078510,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":6515,"ip_address":""},"score":6740,"extra":""}]}]}]}