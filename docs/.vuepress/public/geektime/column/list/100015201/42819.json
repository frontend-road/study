{"id":42819,"title":"29 | PV、PVC体系是不是多此一举？从本地持久化卷谈起","content":"<p>你好，我是张磊。今天我和你分享的主题是：PV、PVC体系是不是多此一举？从本地持久化卷谈起。</p><p>在上一篇文章中，我为你详细讲解了PV、PVC持久化存储体系在Kubernetes项目中的设计和实现原理。而在文章最后的思考题中，我为你留下了这样一个讨论话题：像PV、PVC这样的用法，是不是有“过度设计”的嫌疑？</p><p>比如，我们公司的运维人员可以像往常一样维护一套NFS或者Ceph服务器，根本不必学习Kubernetes。而开发人员，则完全可以靠“复制粘贴”的方式，在Pod的YAML文件里填上Volumes字段，而不需要去使用PV和PVC。</p><p>实际上，如果只是为了职责划分，PV、PVC体系确实不见得比直接在Pod里声明Volumes字段有什么优势。</p><p>不过，你有没有想过这样一个问题，如果<a href=\"https://kubernetes.io/docs/concepts/storage/persistent-volumes/#types-of-persistent-volumes\">Kubernetes内置的20种持久化数据卷实现</a>，都没办法满足你的容器存储需求时，该怎么办？</p><p>这个情况乍一听起来有点不可思议。但实际上，凡是鼓捣过开源项目的读者应该都有所体会，“不能用”“不好用”“需要定制开发”，这才是落地开源基础设施项目的三大常态。</p><p>而在持久化存储领域，用户呼声最高的定制化需求，莫过于支持“本地”持久化存储了。</p><!-- [[[read_end]]] --><p>也就是说，用户希望Kubernetes能够直接使用宿主机上的本地磁盘目录，而不依赖于远程存储服务，来提供“持久化”的容器Volume。</p><p>这样做的好处很明显，由于这个Volume直接使用的是本地磁盘，尤其是SSD盘，它的读写性能相比于大多数远程存储来说，要好得多。这个需求对本地物理服务器部署的私有Kubernetes集群来说，非常常见。</p><p>所以，Kubernetes在v1.10之后，就逐渐依靠PV、PVC体系实现了这个特性。这个特性的名字叫作：Local Persistent Volume。</p><p>不过，首先需要明确的是，<strong>Local Persistent Volume并不适用于所有应用</strong>。事实上，它的适用范围非常固定，比如：高优先级的系统应用，需要在多个不同节点上存储数据，并且对I/O较为敏感。典型的应用包括：分布式数据存储比如MongoDB、Cassandra等，分布式文件系统比如GlusterFS、Ceph等，以及需要在本地磁盘上进行大量数据缓存的分布式应用。</p><p>其次，相比于正常的PV，一旦这些节点宕机且不能恢复时，Local Persistent Volume的数据就可能丢失。这就要求<strong>使用Local Persistent Volume的应用必须具备数据备份和恢复的能力</strong>，允许你把这些数据定时备份在其他位置。</p><p>接下来，我就为你深入讲解一下这个特性。</p><p>不难想象，<span class=\"orange\">Local Persistent Volume的设计，主要面临两个难点。</span></p><p><strong>第一个难点在于</strong>：如何把本地磁盘抽象成PV。</p><p>可能你会说，Local Persistent Volume，不就等同于hostPath加NodeAffinity吗？</p><p>比如，一个Pod可以声明使用类型为Local的PV，而这个PV其实就是一个hostPath类型的Volume。如果这个hostPath对应的目录，已经在节点A上被事先创建好了。那么，我只需要再给这个Pod加上一个nodeAffinity=nodeA，不就可以使用这个Volume了吗？</p><p>事实上，<strong>你绝不应该把一个宿主机上的目录当作PV使用</strong>。这是因为，这种本地目录的存储行为完全不可控，它所在的磁盘随时都可能被应用写满，甚至造成整个宿主机宕机。而且，不同的本地目录之间也缺乏哪怕最基础的I/O隔离机制。</p><p>所以，一个Local Persistent Volume对应的存储介质，一定是一块额外挂载在宿主机的磁盘或者块设备（“额外”的意思是，它不应该是宿主机根目录所使用的主硬盘）。这个原则，我们可以称为“<strong>一个PV一块盘</strong>”。</p><p><strong>第二个难点在于</strong>：调度器如何保证Pod始终能被正确地调度到它所请求的Local Persistent Volume所在的节点上呢？</p><p>造成这个问题的原因在于，对于常规的PV来说，Kubernetes都是先调度Pod到某个节点上，然后，再通过“两阶段处理”来“持久化”这台机器上的Volume目录，进而完成Volume目录与容器的绑定挂载。</p><p>可是，对于Local PV来说，节点上可供使用的磁盘（或者块设备），必须是运维人员提前准备好的。它们在不同节点上的挂载情况可以完全不同，甚至有的节点可以没这种磁盘。</p><p>所以，这时候，调度器就必须能够知道所有节点与Local Persistent Volume对应的磁盘的关联关系，然后根据这个信息来调度Pod。</p><p>这个原则，我们可以称为“<strong>在调度的时候考虑Volume分布</strong>”。在Kubernetes的调度器里，有一个叫作VolumeBindingChecker的过滤条件专门负责这个事情。在Kubernetes v1.11中，这个过滤条件已经默认开启了。</p><p>基于上述讲述，<span class=\"orange\">在开始使用Local Persistent Volume之前，你首先需要在集群里配置好磁盘或者块设备。</span>在公有云上，这个操作等同于给虚拟机额外挂载一个磁盘，比如GCE的Local SSD类型的磁盘就是一个典型例子。</p><p>而在我们部署的私有环境中，你有两种办法来完成这个步骤。</p><ul>\n<li>第一种，当然就是给你的宿主机挂载并格式化一个可用的本地磁盘，这也是最常规的操作；</li>\n<li>第二种，对于实验环境，你其实可以在宿主机上挂载几个RAM Disk（内存盘）来模拟本地磁盘。</li>\n</ul><p>接下来，我会使用第二种方法，在我们之前部署的Kubernetes集群上进行实践。</p><p><strong>首先</strong>，在名叫node-1的宿主机上创建一个挂载点，比如/mnt/disks；<strong>然后</strong>，用几个RAM Disk来模拟本地磁盘，如下所示：</p><pre><code># 在node-1上执行\n$ mkdir /mnt/disks\n$ for vol in vol1 vol2 vol3; do\n    mkdir /mnt/disks/$vol\n    mount -t tmpfs $vol /mnt/disks/$vol\ndone\n</code></pre><p>需要注意的是，如果你希望其他节点也能支持Local Persistent Volume的话，那就需要为它们也执行上述操作，并且确保这些磁盘的名字（vol1、vol2等）都不重复。</p><p><span class=\"orange\">接下来，我们就可以为这些本地磁盘定义对应的PV了</span>，如下所示：</p><pre><code>apiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: example-pv\nspec:\n  capacity:\n    storage: 5Gi\n  volumeMode: Filesystem\n  accessModes:\n  - ReadWriteOnce\n  persistentVolumeReclaimPolicy: Delete\n  storageClassName: local-storage\n  local:\n    path: /mnt/disks/vol1\n  nodeAffinity:\n    required:\n      nodeSelectorTerms:\n      - matchExpressions:\n        - key: kubernetes.io/hostname\n          operator: In\n          values:\n          - node-1\n</code></pre><p>可以看到，这个PV的定义里：local字段，指定了它是一个Local Persistent Volume；而path字段，指定的正是这个PV对应的本地磁盘的路径，即：/mnt/disks/vol1。</p><p>当然了，这也就意味着如果Pod要想使用这个PV，那它就必须运行在node-1上。所以，在这个PV的定义里，需要有一个nodeAffinity字段指定node-1这个节点的名字。这样，调度器在调度Pod的时候，就能够知道一个PV与节点的对应关系，从而做出正确的选择。<strong>这正是Kubernetes实现“在调度的时候就考虑Volume分布”的主要方法。</strong></p><p><strong>接下来</strong>，我们就可以使用kubect create来创建这个PV，如下所示：</p><pre><code>$ kubectl create -f local-pv.yaml \npersistentvolume/example-pv created\n\n$ kubectl get pv\nNAME         CAPACITY   ACCESS MODES   RECLAIM POLICY  STATUS      CLAIM             STORAGECLASS    REASON    AGE\nexample-pv   5Gi        RWO            Delete           Available                     local-storage             16s\n</code></pre><p>可以看到，这个PV创建后，进入了Available（可用）状态。</p><p>而正如我在上一篇文章里所建议的那样，使用PV和PVC的最佳实践，是你要创建一个StorageClass来描述这个PV，如下所示：</p><pre><code>kind: StorageClass\napiVersion: storage.k8s.io/v1\nmetadata:\n  name: local-storage\nprovisioner: kubernetes.io/no-provisioner\nvolumeBindingMode: WaitForFirstConsumer\n</code></pre><p>这个StorageClass的名字，叫作local-storage。需要注意的是，在它的provisioner字段，我们指定的是no-provisioner。这是因为Local Persistent Volume目前尚不支持Dynamic Provisioning，所以它没办法在用户创建PVC的时候，就自动创建出对应的PV。也就是说，我们前面创建PV的操作，是不可以省略的。</p><p>与此同时，这个StorageClass还定义了一个volumeBindingMode=WaitForFirstConsumer的属性。它是Local Persistent Volume里一个非常重要的特性，即：<strong>延迟绑定</strong>。</p><p>我们知道，当你提交了PV和PVC的YAML文件之后，Kubernetes就会根据它们俩的属性，以及它们指定的StorageClass来进行绑定。只有绑定成功后，Pod才能通过声明这个PVC来使用对应的PV。</p><p>可是，如果你使用的是Local Persistent Volume的话，就会发现，这个流程根本行不通。</p><p>比如，现在你有一个Pod，它声明使用的PVC叫作pvc-1。并且，我们规定，这个Pod只能运行在node-2上。</p><p>而在Kubernetes集群中，有两个属性（比如：大小、读写权限）相同的Local类型的PV。</p><p>其中，第一个PV的名字叫作pv-1，它对应的磁盘所在的节点是node-1。而第二个PV的名字叫作pv-2，它对应的磁盘所在的节点是node-2。</p><p>假设现在，Kubernetes的Volume控制循环里，首先检查到了pvc-1和pv-1的属性是匹配的，于是就将它们俩绑定在一起。</p><p>然后，你用kubectl create创建了这个Pod。</p><p>这时候，问题就出现了。</p><p>调度器看到，这个Pod所声明的pvc-1已经绑定了pv-1，而pv-1所在的节点是node-1，根据“调度器必须在调度的时候考虑Volume分布”的原则，这个Pod自然会被调度到node-1上。</p><p>可是，我们前面已经规定过，这个Pod根本不允许运行在node-1上。所以。最后的结果就是，这个Pod的调度必然会失败。</p><p><strong>这就是为什么，在使用Local Persistent Volume的时候，我们必须想办法推迟这个“绑定”操作。</strong></p><p>那么，具体推迟到什么时候呢？</p><p><strong>答案是：推迟到调度的时候。</strong></p><p>所以说，StorageClass里的volumeBindingMode=WaitForFirstConsumer的含义，就是告诉Kubernetes里的Volume控制循环（“红娘”）：虽然你已经发现这个StorageClass关联的PVC与PV可以绑定在一起，但请不要现在就执行绑定操作（即：设置PVC的VolumeName字段）。</p><p>而要等到第一个声明使用该PVC的Pod出现在调度器之后，调度器再综合考虑所有的调度规则，当然也包括每个PV所在的节点位置，来统一决定，这个Pod声明的PVC，到底应该跟哪个PV进行绑定。</p><p>这样，在上面的例子里，由于这个Pod不允许运行在pv-1所在的节点node-1，所以它的PVC最后会跟pv-2绑定，并且Pod也会被调度到node-2上。</p><p>所以，通过这个延迟绑定机制，原本实时发生的PVC和PV的绑定过程，就被延迟到了Pod第一次调度的时候在调度器中进行，从而保证了这个<strong>绑定结果不会影响Pod的正常调度</strong>。</p><p>当然，在具体实现中，调度器实际上维护了一个与Volume Controller类似的控制循环，专门负责为那些声明了“延迟绑定”的PV和PVC进行绑定工作。</p><p>通过这样的设计，这个额外的绑定操作，并不会拖慢调度器的性能。而当一个Pod的PVC尚未完成绑定时，调度器也不会等待，而是会直接把这个Pod重新放回到待调度队列，等到下一个调度周期再做处理。</p><p>在明白了这个机制之后，我们就可以创建StorageClass了，如下所示：</p><pre><code>$ kubectl create -f local-sc.yaml \nstorageclass.storage.k8s.io/local-storage created\n</code></pre><p><span class=\"orange\">接下来，我们只需要定义一个非常普通的PVC，就可以让Pod使用到上面定义好的Local Persistent Volume了</span>，如下所示：</p><pre><code>kind: PersistentVolumeClaim\napiVersion: v1\nmetadata:\n  name: example-local-claim\nspec:\n  accessModes:\n  - ReadWriteOnce\n  resources:\n    requests:\n      storage: 5Gi\n  storageClassName: local-storage\n</code></pre><p>可以看到，这个PVC没有任何特别的地方。唯一需要注意的是，它声明的storageClassName是local-storage。所以，将来Kubernetes的Volume Controller看到这个PVC的时候，不会为它进行绑定操作。</p><p>现在，我们来创建这个PVC：</p><pre><code>$ kubectl create -f local-pvc.yaml \npersistentvolumeclaim/example-local-claim created\n\n$ kubectl get pvc\nNAME                  STATUS    VOLUME    CAPACITY   ACCESS MODES   STORAGECLASS    AGE\nexample-local-claim   Pending                                       local-storage   7s\n</code></pre><p>可以看到，尽管这个时候，Kubernetes里已经存在了一个可以与PVC匹配的PV，但这个PVC依然处于Pending状态，也就是等待绑定的状态。</p><p><span class=\"orange\">然后，我们编写一个Pod来声明使用这个PVC</span>，如下所示：</p><pre><code>kind: Pod\napiVersion: v1\nmetadata:\n  name: example-pv-pod\nspec:\n  volumes:\n    - name: example-pv-storage\n      persistentVolumeClaim:\n       claimName: example-local-claim\n  containers:\n    - name: example-pv-container\n      image: nginx\n      ports:\n        - containerPort: 80\n          name: &quot;http-server&quot;\n      volumeMounts:\n        - mountPath: &quot;/usr/share/nginx/html&quot;\n          name: example-pv-storage\n</code></pre><p>这个Pod没有任何特别的地方，你只需要注意，它的volumes字段声明要使用前面定义的、名叫example-local-claim的PVC即可。</p><p>而我们一旦使用kubectl create创建这个Pod，就会发现，我们前面定义的PVC，会立刻变成Bound状态，与前面定义的PV绑定在了一起，如下所示：</p><pre><code>$ kubectl create -f local-pod.yaml \npod/example-pv-pod created\n\n$ kubectl get pvc\nNAME                  STATUS    VOLUME       CAPACITY   ACCESS MODES   STORAGECLASS    AGE\nexample-local-claim   Bound     example-pv   5Gi        RWO            local-storage   6h\n</code></pre><p>也就是说，在我们创建的Pod进入调度器之后，“绑定”操作才开始进行。</p><p>这时候，我们可以尝试在这个Pod的Volume目录里，创建一个测试文件，比如：</p><pre><code>$ kubectl exec -it example-pv-pod -- /bin/sh\n# cd /usr/share/nginx/html\n# touch test.txt\n</code></pre><p>然后，登录到node-1这台机器上，查看一下它的 /mnt/disks/vol1目录下的内容，你就可以看到刚刚创建的这个文件：</p><pre><code># 在node-1上\n$ ls /mnt/disks/vol1\ntest.txt\n</code></pre><p>而如果你重新创建这个Pod的话，就会发现，我们之前创建的测试文件，依然被保存在这个持久化Volume当中：</p><pre><code>$ kubectl delete -f local-pod.yaml \n\n$ kubectl create -f local-pod.yaml \n\n$ kubectl exec -it example-pv-pod -- /bin/sh\n# ls /usr/share/nginx/html\n# touch test.txt\n</code></pre><p>这就说明，像Kubernetes这样构建出来的、基于本地存储的Volume，完全可以提供容器持久化存储的功能。所以，像StatefulSet这样的有状态编排工具，也完全可以通过声明Local类型的PV和PVC，来管理应用的存储状态。</p><p><strong>需要注意的是，我们上面手动创建PV的方式，即Static的PV管理方式，在删除PV时需要按如下流程执行操作：</strong></p><ol>\n<li>\n<p>删除使用这个PV的Pod；</p>\n</li>\n<li>\n<p>从宿主机移除本地磁盘（比如，umount它）；</p>\n</li>\n<li>\n<p>删除PVC；</p>\n</li>\n<li>\n<p>删除PV。</p>\n</li>\n</ol><p>如果不按照这个流程的话，这个PV的删除就会失败。</p><p>当然，由于上面这些创建PV和删除PV的操作比较繁琐，Kubernetes其实提供了一个Static Provisioner来帮助你管理这些PV。</p><p>比如，我们现在的所有磁盘，都挂载在宿主机的/mnt/disks目录下。</p><p>那么，当Static Provisioner启动后，它就会通过DaemonSet，自动检查每个宿主机的/mnt/disks目录。然后，调用Kubernetes API，为这些目录下面的每一个挂载，创建一个对应的PV对象出来。这些自动创建的PV，如下所示：</p><pre><code>$ kubectl get pv\nNAME                CAPACITY    ACCESSMODES   RECLAIMPOLICY   STATUS      CLAIM     STORAGECLASS    REASON    AGE\nlocal-pv-ce05be60   1024220Ki   RWO           Delete          Available             local-storage             26s\n\n$ kubectl describe pv local-pv-ce05be60 \nName:  local-pv-ce05be60\n...\nStorageClass: local-storage\nStatus:  Available\nClaim:  \nReclaim Policy: Delete\nAccess Modes: RWO\nCapacity: 1024220Ki\nNodeAffinity:\n  Required Terms:\n      Term 0:  kubernetes.io/hostname in [node-1]\nMessage: \nSource:\n    Type: LocalVolume (a persistent volume backed by local storage on a node)\n    Path: /mnt/disks/vol1\n</code></pre><p>这个PV里的各种定义，比如StorageClass的名字、本地磁盘挂载点的位置，都可以通过provisioner的<a href=\"https://github.com/kubernetes-incubator/external-storage/tree/master/local-volume/helm\">配置文件指定</a>。当然，provisioner也会负责前面提到的PV的删除工作。</p><p>而这个provisioner本身，其实也是一个我们前面提到过的<a href=\"https://github.com/kubernetes-incubator/external-storage/tree/master/local-volume\">External Provisioner</a>，它的部署方法，在<a href=\"https://github.com/kubernetes-incubator/external-storage/tree/master/local-volume#option-1-using-the-local-volume-static-provisioner\">对应的文档里</a>有详细描述。这部分内容，就留给你课后自行探索了。</p><h2>总结</h2><p>在今天这篇文章中，我为你详细介绍了Kubernetes里Local Persistent Volume的实现方式。</p><p>可以看到，正是通过PV和PVC，以及StorageClass这套存储体系，这个后来新添加的持久化存储方案，对Kubernetes已有用户的影响，几乎可以忽略不计。作为用户，你的Pod的YAML和PVC的YAML，并没有任何特殊的改变，这个特性所有的实现只会影响到PV的处理，也就是由运维人员负责的那部分工作。</p><p>而这，正是这套存储体系带来的“解耦”的好处。</p><p>其实，Kubernetes很多看起来比较“繁琐”的设计（比如“声明式API”，以及我今天讲解的“PV、PVC体系”）的主要目的，都是希望为开发者提供更多的“可扩展性”，给使用者带来更多的“稳定性”和“安全感”。这两个能力的高低，是衡量开源基础设施项目水平的重要标准。</p><h2>思考题</h2><p>正是由于需要使用“延迟绑定”这个特性，Local Persistent Volume目前还不能支持Dynamic Provisioning。你是否能说出，为什么“延迟绑定”会跟Dynamic Provisioning有冲突呢？</p><p>感谢你的收听，欢迎你给我留言，也欢迎分享给更多的朋友一起阅读。</p><p></p>","neighbors":{"left":{"article_title":"28 | PV、PVC、StorageClass，这些到底在说啥？","id":42698},"right":{"article_title":"30 | 编写自己的存储插件：FlexVolume与CSI","id":44245}},"comments":[{"had_liked":false,"id":35754,"user_name":"realc","can_delete":false,"product_type":"c1","uid":1199581,"ip_address":"","ucode":"289947A88A5803","user_header":"https://static001.geekbang.org/account/avatar/00/12/4d/dd/3b594e8d.jpg","comment_is_top":false,"comment_ctime":1540782810,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"293598558938","product_id":100015201,"comment_content":"知其然，知其所以然。很多教程教材，就跟上学时学校直接灌给我们一样，要让我们去硬啃。不如老师这课程，一个知识点，一个功能的来龙去脉、前世今生都给讲的清清楚楚的。","like_count":69},{"had_liked":false,"id":35777,"user_name":"虎虎❤️","can_delete":false,"product_type":"c1","uid":1086535,"ip_address":"","ucode":"157F261E80291A","user_header":"https://static001.geekbang.org/account/avatar/00/10/94/47/75875257.jpg","comment_is_top":false,"comment_ctime":1540793940,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"250648897108","product_id":100015201,"comment_content":"思考题，我的理解：<br>因为当一个pvc创建之后，kubernetes因为dynamic provisioning机制会调用pvc指定的storageclass里的provisioner自动使用local disk的信息去创建pv。而且pv一旦创建，nodeaffinity参数就指定了固定的node。而此时，provisioner并没有pod调度的相关信息。<br>延迟绑定发生的时机是pod已经进入调度器。此时对应的pv已经创建，绑定了node。并可能与pod的调度信息发生冲突。<br>如果dynamic provisioning机制能够推迟到pod 调度的阶段，同时考虑pod调度条件和node硬件信息，这样才能实现dynamic provisioning。实现上可以参考延迟绑定，来一个延迟 provision。另外实现一个controller在pod调度阶段创建pv。<br><br>","like_count":59,"discussions":[{"author":{"id":1350159,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9a/0f/da7ed75a.jpg","nickname":"芒果少侠","note":"","ucode":"98D0BBB52BB80F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":197115,"discussion_content":"对的。\ndynamic provision机制会使得声明pvc(kubectl apply -f mypvc.yaml)的时候，storage class自动创建符合条件（大小等等）的local pv。但分配到哪个节点无法确定。\n在local pv创建完后，就会固定好所在的node了。 但此时还没有所需要的pod的调度信息。如果之后在pod中指定pvc，原先创建的pv不在pod需要的节点上，那么该dynamic provision就没有意义了。除非再创建一个在所在节点的local pv。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1583407800,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1248326,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0c/46/dfe32cf4.jpg","nickname":"多选参数","note":"","ucode":"B2294D80AB075F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379150,"discussion_content":"简单说起来，就是 dynamic provisioning 在创建出 local pv 的时候就需要将绑定关系指定","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1623728904,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2721775,"avatar":"","nickname":"姜弛北","note":"","ucode":"548B23D4082FE2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587012,"discussion_content":"Pod也指定NodeAffinity属性，调度到同一台Node上，能否解决这个问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662684969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":62951,"user_name":"xfan","can_delete":false,"product_type":"c1","uid":1315147,"ip_address":"","ucode":"48ED8D498D7F56","user_header":"https://static001.geekbang.org/account/avatar/00/14/11/4b/fa64f061.jpg","comment_is_top":false,"comment_ctime":1548212438,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"57382787286","product_id":100015201,"comment_content":"思考题：<br>因为dynamic provision机制不知道pod需要在哪个node下运行，而提前就创建好了，，","like_count":14},{"had_liked":false,"id":216527,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1589277257,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27359081033","product_id":100015201,"comment_content":"Dynamic Provisioning 提供的是自动创建PV的机制，会根据PVC来创建PV并绑定，而我们的延迟绑定是需要在调度的时候综合考虑所有的调度条件来进行PVC和PV的绑定并调度Pod到PV所在的节点，二者有冲突","like_count":6},{"had_liked":false,"id":152170,"user_name":"拉欧","can_delete":false,"product_type":"c1","uid":1206605,"ip_address":"","ucode":"40996A8093A95F","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/4d/81c44f45.jpg","comment_is_top":false,"comment_ctime":1573896792,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18753765976","product_id":100015201,"comment_content":"Dynamic Provisioning 是通过pvc 创建指定规格的pv, 而Local Persistent Volume 是先创建pv, 在创建pvc, 然后在pod创建的时候绑定pv和pvc；从语义上讲，Dynamic Provisioning 就不太可能支持延迟这种效果","like_count":4},{"had_liked":false,"id":150845,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1573616342,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18753485526","product_id":100015201,"comment_content":"因为Dynamic Provisioning会自动创建PV，也就是说，在PVC创建后就根据StorageClass去自动创建PV并绑定了，而“延迟绑定”发生在调度Pod时，此时PVC已经创建了。因此二者是矛盾的~~","like_count":4},{"had_liked":false,"id":76167,"user_name":"大星星","can_delete":false,"product_type":"c1","uid":1082286,"ip_address":"","ucode":"4EAC1D22AE420C","user_header":"https://static001.geekbang.org/account/avatar/00/10/83/ae/c082bb25.jpg","comment_is_top":false,"comment_ctime":1552541163,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14437443051","product_id":100015201,"comment_content":"手动删除pv的步骤中，1234步骤，为什么不是1342呢","like_count":3,"discussions":[{"author":{"id":1807117,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM6GcSnUMzR0H9haiaAxssjibGLQMLAsPKonh50g9W2Iz38LcZNGH39HPaANLtovXTp1YvsINIZoH6F0iaSGuxJMXZS/132","nickname":"Geek_10d981","note":"","ucode":"AF4E774D17F7B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":254005,"discussion_content":"这个1234删除步骤很正常，HDS,EMC等SAN存储的删除步骤都是类似的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588267213,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":233533,"user_name":"海。","can_delete":false,"product_type":"c1","uid":1222981,"ip_address":"","ucode":"D8E300A6D58EDB","user_header":"https://static001.geekbang.org/account/avatar/00/12/a9/45/fc03d0cf.jpg","comment_is_top":false,"comment_ctime":1594348993,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"10184283585","product_id":100015201,"comment_content":"如果不是Local Persistent Volume， 而使用云块存储 aws ebs ， “延迟绑定”和 Dynamic Provisioning 可以不冲突吧？ 我看https:&#47;&#47;github.com&#47;kubernetes-sigs&#47;aws-ebs-csi-driver&#47;blob&#47;master&#47;examples&#47;kubernetes&#47;dynamic-provisioning&#47;specs&#47;storageclass.yaml 的volumeBindingMode也是 WaitForFirstConsumer","like_count":2,"discussions":[{"author":{"id":1645662,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/5e/46c4c6d8.jpg","nickname":"郑文","note":"","ucode":"A44F77600AD067","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":397083,"discussion_content":"Local pv 才需要延迟绑定，无法动态生成pv；ebs看起来是个远程存储，不需要延迟绑定，支持动态生成pv。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632558827,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1199969,"avatar":"https://static001.geekbang.org/account/avatar/00/12/4f/61/00083e41.jpg","nickname":"小白","note":"","ucode":"7ACE14C0C4AE61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645662,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/5e/46c4c6d8.jpg","nickname":"郑文","note":"","ucode":"A44F77600AD067","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547212,"discussion_content":"跨可用区时需要","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642583152,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":397083,"ip_address":""},"score":547212,"extra":""}]},{"author":{"id":2449777,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLDUJyeq54fiaXAgF62tNeocO3lHsKT4mygEcNoZLnibg6ONKicMgCgUHSfgW8hrMUXlwpNSzR8MHZwg/132","nickname":"types","note":"","ucode":"8B50927EF1804F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374645,"discussion_content":"具体参考https://kubernetes.io/docs/concepts/storage/storage-classes/\nAWS EBS是支持dynamic Provision","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621301233,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":48090,"user_name":"johnson.skiii","can_delete":false,"product_type":"c1","uid":1316924,"ip_address":"","ucode":"F1B6E71B54046C","user_header":"https://static001.geekbang.org/account/avatar/00/14/18/3c/b5a00c1a.jpg","comment_is_top":false,"comment_ctime":1544347797,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"5839315093","product_id":100015201,"comment_content":"liuchjlu<br>请教一个问题，当使用Local Persistent Volume的时候，pv中声明的local path如果所在节点没有这个目录会不会自动创建？<br><br><br>我的理解是：pv无论是使用NAS或者其他的存储，还是local persistent volume，都是infra的童鞋帮忙先规划好的存储区域。那么你在写这个pv的时候，要确保这块存储可用，比如目录存在。","like_count":1,"discussions":[{"author":{"id":1033169,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c3/d1/bdf895bf.jpg","nickname":"penng","note":"","ucode":"6087CFCB0AC434","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586026,"discussion_content":"有个参数值，设置如果没有，自动创建目录","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661938590,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"重庆"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015973,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/80/a5/abb7bfe3.jpg","nickname":"要没时间了","note":"","ucode":"6578732FB4C5B0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":567368,"discussion_content":"不用static provisioner那就必须要手动创建，使用static provisioner，在它的配置文件里面可以根据storageClass来指定指定相应volume的local path和mount path的具体数值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650896495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36691,"user_name":"liuchjlu","can_delete":false,"product_type":"c1","uid":1272986,"ip_address":"","ucode":"F8DC235B6F1D73","user_header":"https://static001.geekbang.org/account/avatar/00/13/6c/9a/8e16409b.jpg","comment_is_top":false,"comment_ctime":1541241645,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5836208941","product_id":100015201,"comment_content":"请教一个问题，当使用Local Persistent Volume的时候，pv中声明的local path如果所在节点没有这个目录会不会自动创建？","like_count":1,"discussions":[{"author":{"id":1610260,"avatar":"https://static001.geekbang.org/account/avatar/00/18/92/14/6ca50b3b.jpg","nickname":"大G来了呦","note":"","ucode":"97711D9CCA73B0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302796,"discussion_content":"不会","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599033171,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35970,"user_name":"silver","can_delete":false,"product_type":"c1","uid":1186740,"ip_address":"","ucode":"908E3C8560D6E1","user_header":"https://static001.geekbang.org/account/avatar/00/12/1b/b4/a6db1c1e.jpg","comment_is_top":false,"comment_ctime":1540876870,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5835844166","product_id":100015201,"comment_content":"&#39;一个 PV 一块盘&#39;能再解释下么，如果直接写宿主机上的本地磁盘目录只要把每个container所消耗的硬盘空间都加个cap就能防止磁盘被写满吧？","like_count":1,"discussions":[{"author":{"id":1645662,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/5e/46c4c6d8.jpg","nickname":"郑文","note":"","ucode":"A44F77600AD067","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":397085,"discussion_content":"不只是磁盘空间的问题。跟cpu一样，磁盘也有负载问题。如果一个应用大量读写磁盘，可能导致宿主机磁盘满负荷而响应慢或者无法响应。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632559008,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358415,"user_name":"Geek_a852c8","can_delete":false,"product_type":"c1","uid":2206508,"ip_address":"广东","ucode":"D925A9D71A76BA","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/O6qftWBakkjQHrAhF5tia21GKkQxibJaPy2nWUKc9eiaouaqb67Hj60RRKgjgHhzPmaxaHkLszcNYrDSkj21lPylQ/132","comment_is_top":false,"comment_ctime":1664280451,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664280451","product_id":100015201,"comment_content":"[root@VM-20-5-centos test1]# kubectl get pv <br>NAME         CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                         STORAGECLASS    REASON   AGE<br>example-pv   1Gi        RWO            Delete           Failed   default&#47;example-local-claim   local-storage            81s<br><br>绑定了pvc后的pv。如果删除了pvc后。状态变成failed.那怎么才能让他变回Available呢？","like_count":0},{"had_liked":false,"id":354357,"user_name":"阿喵","can_delete":false,"product_type":"c1","uid":1262233,"ip_address":"上海","ucode":"5E84C870ADF1D5","user_header":"https://static001.geekbang.org/account/avatar/00/13/42/99/7d9b1fd5.jpg","comment_is_top":false,"comment_ctime":1660296831,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660296831","product_id":100015201,"comment_content":"思考题：<br>假设现在有node1和node2两个节点，且pod因为某些原因只能运行在node2节点上，而dynamic provisioning在pvc创建之后就自动创建pv与其绑定，此时并不会考虑pod的调度情况，假设这个pv被创建在node1节点上，那么pod必然调度失败","like_count":0},{"had_liked":false,"id":345634,"user_name":"阿伦","can_delete":false,"product_type":"c1","uid":1097240,"ip_address":"","ucode":"EEB5FAA3E65C91","user_header":"https://static001.geekbang.org/account/avatar/00/10/be/18/ecac08dc.jpg","comment_is_top":false,"comment_ctime":1652447010,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652447010","product_id":100015201,"comment_content":"有一点疑惑，重启的pod，是如何保证自己一定启动在之前关联的PV机器上的，上面的例子说pod只能运行在2节点上，那如果没有这个限制，被部署在了1机器上，然后写了数据之后，pod重启，运行到2机器上了，那1机器上的PV有数据持久化又有什么意义呢？","like_count":0},{"had_liked":false,"id":343538,"user_name":"要没时间了","can_delete":false,"product_type":"c1","uid":1015973,"ip_address":"","ucode":"6578732FB4C5B0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/80/a5/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1650897004,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650897004","product_id":100015201,"comment_content":"Dynamic Provisioning 这个机制，关键是在于，如果它最终的结果是仅有一个合法的PV以及底层的持久化目录， 这就反向影响了Pod Schduling的决定，相当于可被调度的候选节点只有一个了。<br><br>要不然，就在多个，甚至集群全部节点都创建好相应的local PV。这样可以一定程度，或者彻底消除调度失败的可能。<br><br>否则，就只能在volume创建的时候想办法，在scheduler里面实现相应的通过调用CSI 的API创建volume的逻辑。<br><br>后者所谓的“动态创建”的方式，虽然可能，但是是不适合放在 scheduler里面的。scheduler按照责任划分来说，不应该再对资源进行修改了，以为她本身就是一个根据现有资源情况做调度决定的组件。<br><br>通过上面的考虑，如果资源充足，那就在集群出划分出一个专门可以使用local volume的节点池，在上面每一个节点都创建相应的PV。否则，感觉是没办法解决这个冲突的","like_count":0},{"had_liked":false,"id":341451,"user_name":"loser","can_delete":false,"product_type":"c1","uid":1259571,"ip_address":"","ucode":"94C8EB5761CE7A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/T7sFX0O4Tdwic8RUolZVe4hNPDiaiaxsfGD4qCBsmac8Iqcibe23Y3jEOQyTic7hsYn46ETeC56jhJ4nFOdOsEZxchw/132","comment_is_top":false,"comment_ctime":1649635726,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649635726","product_id":100015201,"comment_content":"只有几个G那种怎么挂载一个单盘呢？","like_count":0},{"had_liked":false,"id":341304,"user_name":"勤奋的辣牛肉","can_delete":false,"product_type":"c1","uid":1676412,"ip_address":"","ucode":"D48CC31A8D44FC","user_header":"https://static001.geekbang.org/account/avatar/00/19/94/7c/70bf584f.jpg","comment_is_top":false,"comment_ctime":1649511794,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649511794","product_id":100015201,"comment_content":"Static Provisioner  和 local-volume-provisioner  是一个东西么?","like_count":0},{"had_liked":false,"id":336740,"user_name":"Lccc","can_delete":false,"product_type":"c1","uid":2436867,"ip_address":"","ucode":"87727E4F36FA38","user_header":"https://static001.geekbang.org/account/avatar/00/25/2f/03/0be37ebd.jpg","comment_is_top":false,"comment_ctime":1646328352,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1646328352","product_id":100015201,"comment_content":"如果PVC支持扩展nodeAffinity字段, 是不是就可以解决延迟绑定了, StorageClass在读取到新增PVC后, 直接创建指定node的PV并进行Bound","like_count":0,"discussions":[{"author":{"id":2139471,"avatar":"https://static001.geekbang.org/account/avatar/00/20/a5/4f/772dd0f3.jpg","nickname":"zlel","note":"","ucode":"D98D44B933D6D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582578,"discussion_content":"PVC如果也有nodeAffinity字段的话，会和Pod的nodeAffinity字段产生冲突。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659514482,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"日本"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":316979,"user_name":"恰同学少年。","can_delete":false,"product_type":"c1","uid":1928162,"ip_address":"","ucode":"4D4BC29421A245","user_header":"https://static001.geekbang.org/account/avatar/00/1d/6b/e2/f02e45df.jpg","comment_is_top":false,"comment_ctime":1634631446,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634631446","product_id":100015201,"comment_content":"&quot;需要注意的是，我们上面手动创建 PV 的方式，即 Static 的 PV 管理方式，在删除 PV 时需要按如下流程执行操作：删除使用这个 PV 的 Pod；从宿主机移除本地磁盘（比如，umount 它）；删除 PVC；删除 PV。&quot;<br><br><br>请问这里为什么不按这个顺序就会失败？我在k8s环境实践了以下两种方式也可以删除成功。<br>方案一：只不过这里可能的问题是在删除pv pvc的窗口期pod读写会有异常？<br>- 删除PV<br>- 删除PVC<br>- 删除Pod<br><br>方案二：<br>- 删除PVC<br>- 删除Pod<br>- 删除PV","like_count":0},{"had_liked":false,"id":303606,"user_name":"wx","can_delete":false,"product_type":"c1","uid":1117803,"ip_address":"","ucode":"7AA8F0FEFD1128","user_header":"https://static001.geekbang.org/account/avatar/00/11/0e/6b/9ee9f422.jpg","comment_is_top":false,"comment_ctime":1626871979,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626871979","product_id":100015201,"comment_content":"思考题: <br>1. Static Provisioning 的pv 是提前创建好的，调度器在调度pod时，一方面可以考虑nodeAffinity等调度需求，另一方面也能通过已有pv信息知道 pv的空间够不够。所以pv绑定pvc 可以放在Pod调度后进行。<br>2. Dynamic Provisioning，最大的问题: 无法提前知道节点 空间够不够。<br>情况一: 如果让Pod先调度到节点上之后，再通过 storageClass 创建pv绑定pvc，很有可能 节点本地磁盘空间 都不够了。<br>情况二: 如果先让 storageClass 创建pv绑定pvc，再调度Pod，pvc所在的节点信息 和 Pod 需要的节点信息 产生冲突。<br><br>求老师给 正确解答","like_count":0},{"had_liked":false,"id":301935,"user_name":"SmartsYoung","can_delete":false,"product_type":"c1","uid":1843402,"ip_address":"","ucode":"7277B790D470DE","user_header":"https://static001.geekbang.org/account/avatar/00/1c/20/ca/2b0f69bc.jpg","comment_is_top":false,"comment_ctime":1625983615,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1625983615","product_id":100015201,"comment_content":"请问这个错误是什么原因呢？<br>Warning  FailedScheduling  62s (x2 over 64s)  default-scheduler  0&#47;1 nodes are available: 1 node(s) didn&#39;t match Pod&#39;s node affinity&#47;selector.<br>","like_count":0},{"had_liked":false,"id":296261,"user_name":"Geek_5baa01","can_delete":false,"product_type":"c1","uid":2470693,"ip_address":"","ucode":"EE194170C4B30E","user_header":"","comment_is_top":false,"comment_ctime":1622866444,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622866444","product_id":100015201,"comment_content":"目前的的控制器已经支持自动扫描目录创建 PV，延迟绑定还是一样，这是pod 调度规则限制，在使用 statefulset 时 k8s 会根据你使用的 stroage class 去找的已经具备 local pv 的node运行，那么其实也有一些dynamic 的特性了","like_count":0},{"had_liked":false,"id":283035,"user_name":"lumence","can_delete":false,"product_type":"c1","uid":1144080,"ip_address":"","ucode":"00BA0ECFA6F002","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJtl3p4gcguAZy580SyoQAic79Z7QAvTcibnicV9K8x2Yzbxa8BlknwhquzTPPklaWPDDbrECQG3uurg/132","comment_is_top":false,"comment_ctime":1615528508,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615528508","product_id":100015201,"comment_content":"# 有人说，文章中的例子跑不起来，可能是因为在主节点上创建了，本地卷的原因。<br># 一下示例 亲测有效<br><br>apiVersion: v1<br># PV 类型<br>kind: PersistentVolume<br>metadata:<br>  # PV 的名字<br>  name: example-pv<br>spec:<br>  capacity:<br>    # 分配 1G 空间<br>    storage: 1Gi<br>  # 允许直接挂载到容器的某个目录下<br>  volumeMode: Filesystem<br>  # 读写模式 = 只能被单个节点以读写的方式映射<br>  accessModes:<br>  - ReadWriteOnce<br>  # 磁盘空间回收策略 = 删除 PV 时删除里面的数据<br>  persistentVolumeReclaimPolicy: Delete<br>  # 指定存储类名字<br>  storageClassName: local-storage<br>  # 指定卷路径，就是宿主机上要被挂载的目录<br>  local:<br>    path: &#47;mnt&#47;disks&#47;vol1<br>  # 因为上面读写模式设置成只能一个节点访问<br>  # 所以这里要选择，哪个节点可以访问<br>  nodeAffinity:<br>    required:<br>      nodeSelectorTerms:<br>      - matchExpressions:<br>        - key: kubernetes.io&#47;hostname<br>          operator: In<br>          # 主机名，这里选择了master节点，所以创建 Pod 需要设置容忍度<br>          values:<br>            - kubernetes-master<br><br>---<br><br>kind: StorageClass<br>apiVersion: storage.k8s.io&#47;v1<br>metadata:<br>  name: local-storage<br># no-provisioner 表示，必须手动创建 PV 实例，K8s 不支持自动创建<br>provisioner: kubernetes.io&#47;no-provisioner<br># 延迟绑定。延迟到调度 Pod 的时候再决定 PV 和 PVC的 绑定关系<br>volumeBindingMode: WaitForFirstConsumer<br><br>---<br><br>kind: PersistentVolumeClaim<br>apiVersion: v1<br>metadata:<br>  name: example-local-claim<br>spec:<br>  accessModes:<br>  - ReadWriteOnce<br>  resources:<br>    requests:<br>      storage: 1Gi<br>  storageClassName: local-storage<br><br>---<br><br>kind: Pod<br>apiVersion: v1<br>metadata:<br>  name: example-pv-pod<br><br>spec:<br>  # 使用 nodeSelector 选择主节点<br>  nodeSelector:<br>    &quot;kubernetes.io&#47;hostname&quot;: kubernetes-master<br>  volumes:<br>    - name: example-pv-storage<br>      persistentVolumeClaim:<br>       claimName: example-local-claim<br>  containers:<br>    - name: example-pv-container<br>      image: busybox<br>      command: [&quot;sh&quot;, &quot;-c&quot;]<br>      args:<br>      # 每隔 500 秒追加一行内容到 &#47;data&#47;log&#47;x.log<br>      - while true; do<br>          echo &quot;x&quot; &gt;&gt; &#47;data&#47;log&#47;x.log;<br>          sleep 500;<br>        done;<br>      # 将 PV 挂载到当前容器的 &#47;data&#47;log 目录<br>      volumeMounts:<br>        - mountPath: &quot;&#47;data&#47;log&quot;<br>          name: example-pv-storage<br>  # 容忍在主节点上运行此 Pod<br>  tolerations:<br>        - key: node-role.kubernetes.io&#47;master<br>          effect: NoSchedule<br>","like_count":0},{"had_liked":false,"id":282860,"user_name":"Ben","can_delete":false,"product_type":"c1","uid":1252353,"ip_address":"","ucode":"70351D4FAE47F7","user_header":"https://static001.geekbang.org/account/avatar/00/13/1c/01/5aaaf5b6.jpg","comment_is_top":false,"comment_ctime":1615442582,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615442582","product_id":100015201,"comment_content":"思考题<br>Dynamic Provisioning不会考虑pv所在node, 而Local Persistent Volume跟node绑定在一起","like_count":0},{"had_liked":false,"id":277633,"user_name":"惘 闻","can_delete":false,"product_type":"c1","uid":1181650,"ip_address":"","ucode":"C5909F034BF072","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","comment_is_top":false,"comment_ctime":1612497901,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612497901","product_id":100015201,"comment_content":"我总觉得PV才像是PVC的父类,给PVC提供了一些通用的&quot;属性&quot;去继承使用.一个PV下继承了好多个PVC共享&quot;父类&quot;的&quot;属性&quot;.且各自不同的&quot;实现&quot;-&gt;申请空间的大小等.","like_count":0},{"had_liked":false,"id":245712,"user_name":"大G来了呦","can_delete":false,"product_type":"c1","uid":1610260,"ip_address":"","ucode":"97711D9CCA73B0","user_header":"https://static001.geekbang.org/account/avatar/00/18/92/14/6ca50b3b.jpg","comment_is_top":false,"comment_ctime":1599033292,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1599033292","product_id":100015201,"comment_content":"发现一个问题：在pvc设置requests的大小为 1Gi，不过在使用的时候发现容量依然是整个pv的大小，请问这个原因又是什么呢，是否和accessModes模式有关呢？<br>[root@node1 pv]# kubectl get pv<br>NAME         CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                         STORAGECLASS    REASON   AGE<br>example-pv   6Gi        RWO            Delete           Bound    default&#47;example-local-claim   local-storage            31m<br>[root@node1 pv]# kubectl get pvc<br>NAME                  STATUS   VOLUME       CAPACITY   ACCESS MODES   STORAGECLASS    AGE<br>example-local-claim   Bound    example-pv   6Gi        RWO            local-storage   31m","like_count":0,"discussions":[{"author":{"id":1218209,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/a1/74aff40d.jpg","nickname":"此方为名","note":"","ucode":"6E33CCD9061329","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376758,"discussion_content":"调度器选的，因为你的request是1G，而你pv里面只有一个6G的符合要求，他就把这个pv绑定到pvc","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1622318833,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235497,"user_name":"水哥","can_delete":false,"product_type":"c1","uid":1285614,"ip_address":"","ucode":"9706E7F188A082","user_header":"https://static001.geekbang.org/account/avatar/00/13/9d/ee/2d02a9c0.jpg","comment_is_top":false,"comment_ctime":1595062686,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1595062686","product_id":100015201,"comment_content":"这个local volume使用广泛，目前公司使用的k8s集群，底层分布式存储的设计，就使用了此功能","like_count":0,"discussions":[{"author":{"id":1207457,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6c/a1/80d83f0a.jpg","nickname":"Ellison","note":"","ucode":"A2FB94D4F6A332","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345919,"discussion_content":"我们使用的是动态的local pv， lvm","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611815450,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222248,"user_name":"小松松","can_delete":false,"product_type":"c1","uid":1298152,"ip_address":"","ucode":"B9B5FFE7CAA548","user_header":"https://static001.geekbang.org/account/avatar/00/13/ce/e8/12cb8e99.jpg","comment_is_top":false,"comment_ctime":1590725313,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1590725313","product_id":100015201,"comment_content":"我有一个问题想了解一下  pod使用pv后不断地向里面写数据  如果超出pv的容量该怎么办呢？","like_count":0},{"had_liked":false,"id":112431,"user_name":"小猪","can_delete":false,"product_type":"c1","uid":1201662,"ip_address":"","ucode":"EAD6A4876CEF3B","user_header":"https://static001.geekbang.org/account/avatar/00/12/55/fe/ab541300.jpg","comment_is_top":false,"comment_ctime":1562731543,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1562731543","product_id":100015201,"comment_content":"pod挂载ceph rbd的存储pvc，当pod所在节点主机出故障宕机后，pod被自动调度到其他节点，但是原pod处于terminated状态，无法彻底删除，导致pvc没释放，新的pod无法使用这个pvc，进而新pod不能启动！这种情况如何解决？","like_count":0,"discussions":[{"author":{"id":2028725,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/3icaaUibVCz5gYiaj5gZ4wV85rJFibYicCUL7ibUS5TDpkvXiakRbDxgAjJSLAYFGRFcfBKdvbP1lLbzwG1z9D9PCNjtQ/132","nickname":"Geek_75ec47","note":"","ucode":"78046B622999AA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309311,"discussion_content":"可以试试手动umount吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601256451,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":88808,"user_name":"寻","can_delete":false,"product_type":"c1","uid":1167430,"ip_address":"","ucode":"473B2CC14158A7","user_header":"https://static001.geekbang.org/account/avatar/00/11/d0/46/7f9af8de.jpg","comment_is_top":false,"comment_ctime":1556006409,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556006409","product_id":100015201,"comment_content":"请教一下，动态创建的存储卷如何扩容？","like_count":0},{"had_liked":false,"id":78705,"user_name":"gl328518397","can_delete":false,"product_type":"c1","uid":1293354,"ip_address":"","ucode":"05AF4661EF0AAF","user_header":"https://static001.geekbang.org/account/avatar/00/13/bc/2a/00a3d488.jpg","comment_is_top":false,"comment_ctime":1553221174,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553221174","product_id":100015201,"comment_content":"听你的课就跟听王立群讲史记一样。逻辑性强，每次听懂一点就感觉很爽。","like_count":0},{"had_liked":false,"id":71438,"user_name":"单朋荣","can_delete":false,"product_type":"c1","uid":1272662,"ip_address":"","ucode":"8AD121BEDD9675","user_header":"https://static001.geekbang.org/account/avatar/00/13/6b/56/37a4cea7.jpg","comment_is_top":false,"comment_ctime":1551342885,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551342885","product_id":100015201,"comment_content":"张老师可以的，思考题的答案就在本章的“第二个男难点在于：”里面，不用自己总结，差点想破脑袋~","like_count":0},{"had_liked":false,"id":71428,"user_name":"单朋荣","can_delete":false,"product_type":"c1","uid":1272662,"ip_address":"","ucode":"8AD121BEDD9675","user_header":"https://static001.geekbang.org/account/avatar/00/13/6b/56/37a4cea7.jpg","comment_is_top":false,"comment_ctime":1551340702,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551340702","product_id":100015201,"comment_content":"延迟绑定之所以会和Dynamic Provisioning冲突？顾名思义，是因为后者不存在延迟的情况，即在PV、PVC匹配后，查看状态STATUS字段不是Pending（等待调度后在绑定的状态），而直接处于Bound状态。由于local Persistent Volume调度延迟的机制，所以两者有冲突。若理解有偏差，请张老师批评指正。","like_count":0},{"had_liked":false,"id":54925,"user_name":"lpf32","can_delete":false,"product_type":"c1","uid":1039717,"ip_address":"","ucode":"E1B127FDFF74BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/dd/65/3b4a2930.jpg","comment_is_top":false,"comment_ctime":1545982385,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545982385","product_id":100015201,"comment_content":"动态模式下，pvc请求才会创建pv，从直觉上两者应该是绑定关系。但是local需要延迟绑定，会产生冲突。可以把pv的实际产生也推迟到调度阶段。","like_count":0},{"had_liked":false,"id":44372,"user_name":"愤怒的大鸟","can_delete":false,"product_type":"c1","uid":1312522,"ip_address":"","ucode":"31CC4608390F7A","user_header":"https://static001.geekbang.org/account/avatar/00/14/07/0a/7b80c171.jpg","comment_is_top":false,"comment_ctime":1543416021,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1543416021","product_id":100015201,"comment_content":"老师你好，当多个一个服务多个副本同时运行时，应用日志同时输出到同一个PVC，我是用NFS做的，这样多个副本都会将日志输出到同一个目录下的同一个文件中，如果是两个副本统一瞬间都有日志输出，怎么办，会锁住不让另一个写日志吗？","like_count":0,"discussions":[{"author":{"id":1102245,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d1/a5/2bbedc3b.jpg","nickname":"over","note":"","ucode":"FE272AC19842D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348018,"discussion_content":"写操作会堵塞","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1612404733,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37904,"user_name":"Irving","can_delete":false,"product_type":"c1","uid":1218814,"ip_address":"","ucode":"8489A106BE6203","user_header":"https://static001.geekbang.org/account/avatar/00/12/98/fe/953e5192.jpg","comment_is_top":false,"comment_ctime":1541782952,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1541782952","product_id":100015201,"comment_content":"按照文章测试了下，指定了单个节点，报如下错误什么原因呢？<br>apiVersion: apps&#47;v1<br>kind: Deployment<br>metadata:<br>  name: nginx-deployment<br>  labels:<br>    app: nginx<br>spec:<br>  replicas: 1<br>  selector:<br>    matchLabels:<br>      app: nginx<br>  template:<br>    metadata:<br>      labels:<br>        app: nginx<br>    spec:<br>      #nodeSelector:<br>       #zone: node-1<br>      nodeName: kubernetes-node-1 #指定调度节点为 kubernetes-node-1<br>      containers:<br>      - name: nginx-pv-container<br>        image: nginx:1.10.3<br>        imagePullPolicy: IfNotPresent<br>        ports:<br>         - containerPort: 80<br>        volumeMounts:<br>            - name: example-pv-storage<br>              mountPath: &quot;&#47;usr&#47;share&#47;nginx&#47;html&quot;<br>      volumes:<br>      - name: example-pv-storage<br>        persistentVolumeClaim:<br>          claimName: example-local-claim<br><br>Unable to mount volumes for pod &quot;nginx-deployment-77489d8d4c-4bl22_default(5c22d166-e440-11e8-90ea-0050569f4a19)&quot;: timeout expired waiting for volumes to attach or mount for pod &quot;default&quot;&#47;&quot;nginx-deployment-77489d8d4c-4bl22&quot;. list of unmounted volumes=[example-pv-storage]. list of unattached volumes=[example-pv-storage default-token-7c4cf]","like_count":0,"discussions":[{"author":{"id":1144080,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJtl3p4gcguAZy580SyoQAic79Z7QAvTcibnicV9K8x2Yzbxa8BlknwhquzTPPklaWPDDbrECQG3uurg/132","nickname":"lumence","note":"","ucode":"00BA0ECFA6F002","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":356084,"discussion_content":"哈哈。可能是在主节点上面创建的PV，但是，你的 Pod，不能运行在 主节点上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615528285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1596843,"avatar":"https://static001.geekbang.org/account/avatar/00/18/5d/ab/97016efc.jpg","nickname":"ガオガオ","note":"","ucode":"0532F7ECAB3E5F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40439,"discussion_content":"我也同样碰到了，卡在这了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572191206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37604,"user_name":"vx:jiancheng_goon","can_delete":false,"product_type":"c1","uid":1218615,"ip_address":"","ucode":"FD34901B061825","user_header":"https://static001.geekbang.org/account/avatar/00/12/98/37/7f575aec.jpg","comment_is_top":false,"comment_ctime":1541649957,"is_pvip":false,"replies":[{"id":"13580","content":"这是你volume没弄好吧……","user_name":"作者回复","user_name_real":"Geek_6ef93d","uid":"1218095","ctime":1541719623,"ip_address":"","comment_id":37604,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1541649957","product_id":100015201,"comment_content":"如果是容器化的kubelet要如何解决本地PV的问题，因为发现kubelet写的数据，都写在了容器里了，而没有在宿主机上。","like_count":0,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428421,"discussion_content":"这是你volume没弄好吧……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541719623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36027,"user_name":"看不穿","can_delete":false,"product_type":"c1","uid":1259769,"ip_address":"","ucode":"8D35C36C7A35F0","user_header":"https://static001.geekbang.org/account/avatar/00/13/38/f9/2b4755b5.jpg","comment_is_top":false,"comment_ctime":1540898091,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1540898091","product_id":100015201,"comment_content":"老师，问两个问题，关于开发人员用镜像发版的问题:<br>1，之后即使改一个文件，也要重新制作镜像文件？<br>2，镜像文件相对来说size比较大，上传会很耗时吧？<br>有没有解决办法？","like_count":0,"discussions":[{"author":{"id":2384157,"avatar":"https://static001.geekbang.org/account/avatar/00/24/61/1d/07e4d68e.jpg","nickname":"挖土豆","note":"","ucode":"BB1939900AC8A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349791,"discussion_content":"分层上传把，就是作者讲过的rootfs","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613546846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1102245,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d1/a5/2bbedc3b.jpg","nickname":"over","note":"","ucode":"FE272AC19842D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348017,"discussion_content":"2，只会上传更新的那部分","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612404615,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35830,"user_name":"shaobo","can_delete":false,"product_type":"c1","uid":1087931,"ip_address":"","ucode":"E47B99769A9EAF","user_header":"https://static001.geekbang.org/account/avatar/00/10/99/bb/90d97247.jpg","comment_is_top":false,"comment_ctime":1540818234,"is_pvip":false,"replies":[{"id":"12798","content":"可以，但是没有持久战性","user_name":"作者回复","user_name_real":"Geek_6ef93d","uid":"1218095","ctime":1540875478,"ip_address":"","comment_id":35830,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1540818234","product_id":100015201,"comment_content":"k8S部署kfk，es可以用local persistent  volume吗","like_count":0,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427681,"discussion_content":"可以，但是没有持久战性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540875478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645662,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/5e/46c4c6d8.jpg","nickname":"郑文","note":"","ucode":"A44F77600AD067","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":397088,"discussion_content":"就是持久性。文章提到过，需要应用自己考虑数据的备份和恢复","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632559707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1102245,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d1/a5/2bbedc3b.jpg","nickname":"over","note":"","ucode":"FE272AC19842D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348016,"discussion_content":"什么是持久战性？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612404530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}