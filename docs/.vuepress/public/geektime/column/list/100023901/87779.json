{"id":87779,"title":"14 | Lock和Condition（上）：隐藏在并发包中的管程","content":"<p>Java SDK并发包内容很丰富，包罗万象，但是我觉得最核心的还是其对管程的实现。因为理论上利用管程，你几乎可以实现并发包里所有的工具类。在前面<a href=\"https://time.geekbang.org/column/article/86089\">《08 | 管程：并发编程的万能钥匙》</a>中我们提到过在并发编程领域，有两大核心问题：一个是<strong>互斥</strong>，即同一时刻只允许一个线程访问共享资源；另一个是<strong>同步</strong>，即线程之间如何通信、协作。这两大问题，管程都是能够解决的。<strong>Java SDK并发包通过Lock和Condition两个接口来实现管程，其中Lock用于解决互斥问题，Condition用于解决同步问题</strong>。</p><p>今天我们重点介绍Lock的使用，在介绍Lock的使用之前，有个问题需要你首先思考一下：Java语言本身提供的synchronized也是管程的一种实现，既然Java从语言层面已经实现了管程了，那为什么还要在SDK里提供另外一种实现呢？难道Java标准委员会还能同意“重复造轮子”的方案？很显然它们之间是有巨大区别的。那区别在哪里呢？如果能深入理解这个问题，对你用好Lock帮助很大。下面我们就一起来剖析一下这个问题。</p><h2>再造管程的理由</h2><p>你也许曾经听到过很多这方面的传说，例如在Java的1.5版本中，synchronized性能不如SDK里面的Lock，但1.6版本之后，synchronized做了很多优化，将性能追了上来，所以1.6之后的版本又有人推荐使用synchronized了。那性能是否可以成为“重复造轮子”的理由呢？显然不能。因为性能问题优化一下就可以了，完全没必要“重复造轮子”。</p><!-- [[[read_end]]] --><p>到这里，关于这个问题，你是否能够想出一条理由来呢？如果你细心的话，也许能想到一点。那就是我们前面在介绍<a href=\"https://time.geekbang.org/column/article/85001\">死锁问题</a>的时候，提出了一个<strong>破坏不可抢占条件</strong>方案，但是这个方案synchronized没有办法解决。原因是synchronized申请资源的时候，如果申请不到，线程直接进入阻塞状态了，而线程进入阻塞状态，啥都干不了，也释放不了线程已经占有的资源。但我们希望的是：</p><blockquote>\n<p>对于“不可抢占”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。</p>\n</blockquote><p>如果我们重新设计一把互斥锁去解决这个问题，那该怎么设计呢？我觉得有三种方案。</p><ol>\n<li><strong>能够响应中断</strong>。synchronized的问题是，持有锁A后，如果尝试获取锁B失败，那么线程就进入阻塞状态，一旦发生死锁，就没有任何机会来唤醒阻塞的线程。但如果阻塞状态的线程能够响应中断信号，也就是说当我们给阻塞的线程发送中断信号的时候，能够唤醒它，那它就有机会释放曾经持有的锁A。这样就破坏了不可抢占条件了。</li>\n<li><strong>支持超时</strong>。如果线程在一段时间之内没有获取到锁，不是进入阻塞状态，而是返回一个错误，那这个线程也有机会释放曾经持有的锁。这样也能破坏不可抢占条件。</li>\n<li><strong>非阻塞地获取锁</strong>。如果尝试获取锁失败，并不进入阻塞状态，而是直接返回，那这个线程也有机会释放曾经持有的锁。这样也能破坏不可抢占条件。</li>\n</ol><p>这三种方案可以全面弥补synchronized的问题。到这里相信你应该也能理解了，这三个方案就是“重复造轮子”的主要原因，体现在API上，就是Lock接口的三个方法。详情如下：</p><pre><code>// 支持中断的API\nvoid lockInterruptibly() \n  throws InterruptedException;\n// 支持超时的API\nboolean tryLock(long time, TimeUnit unit) \n  throws InterruptedException;\n// 支持非阻塞获取锁的API\nboolean tryLock();\n</code></pre><h2>如何保证可见性</h2><p>Java SDK里面Lock的使用，有一个经典的范例，就是<code>try{}finally{}</code>，需要重点关注的是在finally里面释放锁。这个范例无需多解释，你看一下下面的代码就明白了。但是有一点需要解释一下，那就是可见性是怎么保证的。你已经知道Java里多线程的可见性是通过Happens-Before规则保证的，而synchronized之所以能够保证可见性，也是因为有一条synchronized相关的规则：synchronized的解锁 Happens-Before 于后续对这个锁的加锁。那Java SDK里面Lock靠什么保证可见性呢？例如在下面的代码中，线程T1对value进行了+=1操作，那后续的线程T2能够看到value的正确结果吗？</p><pre><code>class X {\n  private final Lock rtl =\n  new ReentrantLock();\n  int value;\n  public void addOne() {\n    // 获取锁\n    rtl.lock();  \n    try {\n      value+=1;\n    } finally {\n      // 保证锁能释放\n      rtl.unlock();\n    }\n  }\n}\n</code></pre><p>答案必须是肯定的。<strong>Java SDK里面锁</strong>的实现非常复杂，这里我就不展开细说了，但是原理还是需要简单介绍一下：它是<strong>利用了volatile相关的Happens-Before规则</strong>。Java SDK里面的ReentrantLock，内部持有一个volatile 的成员变量state，获取锁的时候，会读写state的值；解锁的时候，也会读写state的值（简化后的代码如下面所示）。也就是说，在执行value+=1之前，程序先读写了一次volatile变量state，在执行value+=1之后，又读写了一次volatile变量state。根据相关的Happens-Before规则：</p><ol>\n<li><strong>顺序性规则</strong>：对于线程T1，value+=1 Happens-Before 释放锁的操作unlock()；</li>\n<li><strong>volatile变量规则</strong>：由于state = 1会先读取state，所以线程T1的unlock()操作Happens-Before线程T2的lock()操作；</li>\n<li><strong>传递性规则</strong>：线程 T1的value+=1  Happens-Before 线程 T2 的 lock() 操作。</li>\n</ol><pre><code>class SampleLock {\n  volatile int state;\n  // 加锁\n  lock() {\n    // 省略代码无数\n    state = 1;\n  }\n  // 解锁\n  unlock() {\n    // 省略代码无数\n    state = 0;\n  }\n}\n</code></pre><p>所以说，后续线程T2能够看到value的正确结果。如果你觉得理解起来还有点困难，建议你重温一下前面我们讲过的<a href=\"https://time.geekbang.org/column/article/84017\">《02 | Java内存模型：看Java如何解决可见性和有序性问题》</a>里面的相关内容。</p><h2>什么是可重入锁</h2><p>如果你细心观察，会发现我们创建的锁的具体类名是ReentrantLock，这个翻译过来叫<strong>可重入锁</strong>，这个概念前面我们一直没有介绍过。<strong>所谓可重入锁，顾名思义，指的是线程可以重复获取同一把锁</strong>。例如下面代码中，当线程T1执行到 ① 处时，已经获取到了锁 rtl ，当在 ① 处调用 get()方法时，会在 ② 再次对锁 rtl 执行加锁操作。此时，如果锁 rtl 是可重入的，那么线程T1可以再次加锁成功；如果锁 rtl 是不可重入的，那么线程T1此时会被阻塞。</p><p>除了可重入锁，可能你还听说过可重入函数，可重入函数怎么理解呢？指的是线程可以重复调用？显然不是，所谓<strong>可重入函数，指的是多个线程可以同时调用该函数</strong>，每个线程都能得到正确结果；同时在一个线程内支持线程切换，无论被切换多少次，结果都是正确的。多线程可以同时执行，还支持线程切换，这意味着什么呢？线程安全啊。所以，可重入函数是线程安全的。</p><pre><code>class X {\n  private final Lock rtl =\n  new ReentrantLock();\n  int value;\n  public int get() {\n    // 获取锁\n    rtl.lock();         ②\n    try {\n      return value;\n    } finally {\n      // 保证锁能释放\n      rtl.unlock();\n    }\n  }\n  public void addOne() {\n    // 获取锁\n    rtl.lock();  \n    try {\n      value = 1 + get(); ①\n    } finally {\n      // 保证锁能释放\n      rtl.unlock();\n    }\n  }\n}\n</code></pre><h2>公平锁与非公平锁</h2><p>在使用ReentrantLock的时候，你会发现ReentrantLock这个类有两个构造函数，一个是无参构造函数，一个是传入fair参数的构造函数。fair参数代表的是锁的公平策略，如果传入true就表示需要构造一个公平锁，反之则表示要构造一个非公平锁。</p><pre><code>//无参构造函数：默认非公平锁\npublic ReentrantLock() {\n    sync = new NonfairSync();\n}\n//根据公平策略参数创建锁\npublic ReentrantLock(boolean fair){\n    sync = fair ? new FairSync() \n                : new NonfairSync();\n}\n</code></pre><p>在前面<a href=\"https://time.geekbang.org/column/article/86089\">《08 | 管程：并发编程的万能钥匙》</a>中，我们介绍过入口等待队列，锁都对应着一个等待队列，如果一个线程没有获得锁，就会进入等待队列，当有线程释放锁的时候，就需要从等待队列中唤醒一个等待的线程。如果是公平锁，唤醒的策略就是谁等待的时间长，就唤醒谁，很公平；如果是非公平锁，则不提供这个公平保证，有可能等待时间短的线程反而先被唤醒。</p><h2>用锁的最佳实践</h2><p>你已经知道，用锁虽然能解决很多并发问题，但是风险也是挺高的。可能会导致死锁，也可能影响性能。这方面有是否有相关的最佳实践呢？有，还很多。但是我觉得最值得推荐的是并发大师Doug Lea《Java并发编程：设计原则与模式》一书中，推荐的三个用锁的最佳实践，它们分别是：</p><blockquote>\n<ol>\n<li>永远只在更新对象的成员变量时加锁</li>\n<li>永远只在访问可变的成员变量时加锁</li>\n<li>永远不在调用其他对象的方法时加锁</li>\n</ol>\n</blockquote><p>这三条规则，前两条估计你一定会认同，最后一条你可能会觉得过于严苛。但是我还是倾向于你去遵守，因为调用其他对象的方法，实在是太不安全了，也许“其他”方法里面有线程sleep()的调用，也可能会有奇慢无比的I/O操作，这些都会严重影响性能。更可怕的是，“其他”类的方法可能也会加锁，然后双重加锁就可能导致死锁。</p><p><strong>并发问题，本来就难以诊断，所以你一定要让你的代码尽量安全，尽量简单，哪怕有一点可能会出问题，都要努力避免。</strong></p><h2>总结</h2><p>Java SDK 并发包里的Lock接口里面的每个方法，你可以感受到，都是经过深思熟虑的。除了支持类似synchronized隐式加锁的lock()方法外，还支持超时、非阻塞、可中断的方式获取锁，这三种方式为我们编写更加安全、健壮的并发程序提供了很大的便利。希望你以后在使用锁的时候，一定要仔细斟酌。</p><p>除了并发大师Doug Lea推荐的三个最佳实践外，你也可以参考一些诸如：减少锁的持有时间、减小锁的粒度等业界广为人知的规则，其实本质上它们都是相通的，不过是在该加锁的地方加锁而已。你可以自己体会，自己总结，最终总结出自己的一套最佳实践来。</p><h2>课后思考</h2><p>你已经知道 tryLock() 支持非阻塞方式获取锁，下面这段关于转账的程序就使用到了 tryLock()，你来看看，它是否存在死锁问题呢？</p><pre><code>class Account {\n  private int balance;\n  private final Lock lock\n          = new ReentrantLock();\n  // 转账\n  void transfer(Account tar, int amt){\n    while (true) {\n      if(this.lock.tryLock()) {\n        try {\n          if (tar.lock.tryLock()) {\n            try {\n              this.balance -= amt;\n              tar.balance += amt;\n            } finally {\n              tar.lock.unlock();\n            }\n          }//if\n        } finally {\n          this.lock.unlock();\n        }\n      }//if\n    }//while\n  }//transfer\n}\n</code></pre><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p><p></p>","comments":[{"had_liked":false,"id":81386,"user_name":"　","can_delete":false,"product_type":"c1","uid":1267107,"ip_address":"","ucode":"246CD8612E84EA","user_header":"https://static001.geekbang.org/account/avatar/00/13/55/a3/88cbb981.jpg","comment_is_top":false,"comment_ctime":1553885879,"is_pvip":true,"replies":[{"id":"29567","content":"👍","user_name":"作者回复","comment_id":81386,"uid":"1269969","ip_address":"","utype":1,"ctime":1553991901,"user_name_real":"王宝令"}],"discussion_count":7,"race_medal":0,"score":"474000288439","product_id":100023901,"comment_content":"我觉得:不会出现死锁，但会出现活锁","like_count":111,"discussions":[{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363120,"discussion_content":"活锁就是指线程一直处于运行（RUNNABLE）状态，但却是在做无用功，而这个线程本身要完成的任务却一直无法进展。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1617113814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1346215,"avatar":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","nickname":"William","note":"","ucode":"55F5D9DEE485B1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300166,"discussion_content":"互相谦让，导致同一时刻重新进入相同获取对方锁状态.","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1597974386,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445175,"discussion_content":"👍","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1553991901,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2410092,"avatar":"https://static001.geekbang.org/account/avatar/00/24/c6/6c/a400175a.jpg","nickname":"FARO_Z","note":"","ucode":"B33BCC36C2A74E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570948,"discussion_content":"这个活锁有可能消解吗？比如说在第一轮循环中，T1，T2线程因为取不到对方持有的锁，而释放自己的锁，开启第二轮循环，但是第二轮循环中，T1线程率先获取两个锁，完成任务。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652003324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1475385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/83/39/f9623363.jpg","nickname":"竹马彦四郎的好朋友影法師","note":"","ucode":"A9555AEFF90CDF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349340,"discussion_content":"真皮😜 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613103737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1400962,"avatar":"https://static001.geekbang.org/account/avatar/00/15/60/82/9a43504b.jpg","nickname":"[耶]友超","note":"","ucode":"890572F77C3670","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3586,"discussion_content":"为啥呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564621897,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1115302,"avatar":"https://static001.geekbang.org/account/avatar/00/11/04/a6/18c4f73c.jpg","nickname":"Airsaid","note":"","ucode":"5B90BC0044F376","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1400962,"avatar":"https://static001.geekbang.org/account/avatar/00/15/60/82/9a43504b.jpg","nickname":"[耶]友超","note":"","ucode":"890572F77C3670","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":197076,"discussion_content":"没有引入随机性，导致线程在释放锁后马上又重新去获取，而此时另外的线程可能也正在这样做，互相又都获取不到锁。","likes_number":21,"is_delete":false,"is_hidden":false,"ctime":1583404057,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3586,"ip_address":""},"score":197076,"extra":""}]}]},{"had_liked":false,"id":81489,"user_name":"小华","can_delete":false,"product_type":"c1","uid":1402795,"ip_address":"","ucode":"902E7ED95D73BA","user_header":"https://static001.geekbang.org/account/avatar/00/15/67/ab/facff632.jpg","comment_is_top":false,"comment_ctime":1553925077,"is_pvip":false,"replies":[{"id":"29558","content":"👍<br>","user_name":"作者回复","comment_id":81489,"uid":"1269969","ip_address":"","utype":1,"ctime":1553989017,"user_name_real":"王宝令"}],"discussion_count":5,"race_medal":0,"score":"383806014421","product_id":100023901,"comment_content":"有可能活锁，A，B两账户相互转账，各自持有自己lock的锁，都一直在尝试获取对方的锁，形成了活锁","like_count":90,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445227,"discussion_content":"👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553989017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1189580,"avatar":"https://static001.geekbang.org/account/avatar/00/12/26/cc/719aec6d.jpg","nickname":"24","note":"","ucode":"F09DF49B6254E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361244,"discussion_content":"虽然结论说的是活锁，但是描述的意思是死锁啊，持有自己的锁，都在等待对方持有的资源。重点应该是非阻塞吧。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1616632776,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2527545,"avatar":"https://static001.geekbang.org/account/avatar/00/26/91/39/acba72ca.jpg","nickname":"JohnCoding","note":"","ucode":"23FF4A45AA2F27","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1189580,"avatar":"https://static001.geekbang.org/account/avatar/00/12/26/cc/719aec6d.jpg","nickname":"24","note":"","ucode":"F09DF49B6254E8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390271,"discussion_content":"我觉得你说得对，是一个非阻塞的死锁这样理解比较好","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1629735274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":361244,"ip_address":""},"score":390271,"extra":""}]},{"author":{"id":1252848,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1d/f0/59702429.jpg","nickname":"idea","note":"","ucode":"621921030982C0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293071,"discussion_content":"一开始看这代码看不出啥问题，被这么一说给点明白了，学习了+1","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1595426470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111870,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK2Az5uTh9ZGVA7yQCj1BXtXuicPRkvJicA97AoN9xX3bnPcUYglTMXJeZeoVbPQeJA7ICvQhR3KQ0w/132","nickname":"日不落帝国","note":"","ucode":"6A11ABBD8AC438","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6189,"discussion_content":"学习学习了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566774370,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81536,"user_name":"xiyi","can_delete":false,"product_type":"c1","uid":1447833,"ip_address":"","ucode":"E368673D610D91","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIBarfQrgZjEW8uUgvQckubEIFwNCJL93OygIgx3fCkObgRzSdo2baVWRd1C8mV6VDGKuoBFic4ZZA/132","comment_is_top":false,"comment_ctime":1553938169,"is_pvip":false,"replies":[{"id":"29556","content":"👍👍👍<br>","user_name":"作者回复","comment_id":81536,"uid":"1269969","ip_address":"","utype":1,"ctime":1553988962,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"302201648889","product_id":100023901,"comment_content":"存在活锁。这个例子可以稍微改下，成功转账后应该跳出循环。加个随机重试时间避免活锁","like_count":70,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445243,"discussion_content":"👍👍👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553988962,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81409,"user_name":"bing","can_delete":false,"product_type":"c1","uid":1067589,"ip_address":"","ucode":"6ADAA36B2B732C","user_header":"https://static001.geekbang.org/account/avatar/00/10/4a/45/04a13bf9.jpg","comment_is_top":false,"comment_ctime":1553906443,"is_pvip":false,"replies":[{"id":"29576","content":"是的，高手👍👍👍<br>","user_name":"作者回复","comment_id":81409,"uid":"1269969","ip_address":"","utype":1,"ctime":1553999207,"user_name_real":"王宝令"}],"discussion_count":5,"race_medal":0,"score":"285021747979","product_id":100023901,"comment_content":"文中说的公平锁和非公平锁，是不按照排队的顺序被唤醒，我记得非公平锁的场景应该是线程释放锁之后，如果来了一个线程获取锁，他不必去排队直接获取到，应该不会入队吧。获取不到才进吧","like_count":66,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445185,"discussion_content":"是的，高手👍👍👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553999207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1481811,"avatar":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","nickname":"ub8","note":"","ucode":"0D937C3EAEB781","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391372,"discussion_content":"误人子弟","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1630420862,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2046055,"avatar":"","nickname":"杜总","note":"","ucode":"C6600875A265E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286499,"discussion_content":"没获取到锁的线程会放到aqs队列尾部，等到头节点的线程执行完毕，会通知头节点的下一个节点出队列执行，这个状态是等待不是阻塞，运行肯定是runnable的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593186385,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1813207,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/aa/d7/a417ad5b.jpg","nickname":"CharAt","note":"","ucode":"D7D44B48FC4E79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":175472,"discussion_content":"想问一下 之前的排队的线程堵塞 是如何被唤醒的 就是锁池里面没有抢到对象锁的线程，当进去的对象被wait()以后 释放掉对象锁后  那锁池里面的线程是直接从blocked 变成runnable吗？  ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581955348,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2308075,"avatar":"","nickname":"Geek_89e362","note":"","ucode":"E596C2CFE1CFAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1813207,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/aa/d7/a417ad5b.jpg","nickname":"CharAt","note":"","ucode":"D7D44B48FC4E79","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326838,"discussion_content":"是WAITING状态，AQS队列的头结点在释放锁时，会唤醒其后续处于WAITING的节点，","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605686291,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":175472,"ip_address":""},"score":326838,"extra":""}]}]},{"had_liked":false,"id":118329,"user_name":"江湖夜雨","can_delete":false,"product_type":"c1","uid":1282575,"ip_address":"","ucode":"C64913C7000899","user_header":"https://static001.geekbang.org/account/avatar/00/13/92/0f/cff30522.jpg","comment_is_top":false,"comment_ctime":1564323530,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"267852295882","product_id":100023901,"comment_content":"终于理解最后一道题出现活锁问题了，两个线程同事执行，线程A获取了u1.trylock，线程B获取了u2.trylock，线程A尝试获取u2.trylock，不能成功，线程A结束，同时线程B尝试获取u1.trylock，不能成功，线程B结束，又开始新的一轮，这样一直循环下去！","like_count":62,"discussions":[{"author":{"id":1387088,"avatar":"","nickname":"再次遇见你","note":"","ucode":"09FC74C305F870","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552827,"discussion_content":"我的理解跟你一致","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1645605372,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2963434,"avatar":"","nickname":"Geek_94fa0e","note":"","ucode":"15BC7D4E130E80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560871,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649475611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2867465,"avatar":"","nickname":"Geek_73484e","note":"","ucode":"BFBF8878F186C0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553859,"discussion_content":"会导致饥饿","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646120136,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2410092,"avatar":"https://static001.geekbang.org/account/avatar/00/24/c6/6c/a400175a.jpg","nickname":"FARO_Z","note":"","ucode":"B33BCC36C2A74E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2867465,"avatar":"","nickname":"Geek_73484e","note":"","ucode":"BFBF8878F186C0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580121,"discussion_content":"不是饥饿","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657880305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":553859,"ip_address":""},"score":580121,"extra":""}]},{"author":{"id":1552958,"avatar":"https://static001.geekbang.org/account/avatar/00/17/b2/3e/13c2b1c9.jpg","nickname":"Geek_600c87","note":"","ucode":"795A81C36CE3AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551441,"discussion_content":"感，突","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645017426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2403622,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ad/26/d46f4394.jpg","nickname":"Owen","note":"","ucode":"FDE0D574B8ED5A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348452,"discussion_content":"感分 突顿","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612580576,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1107484,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e6/1c/9d3744ee.jpg","nickname":"小李讲源码","note":"","ucode":"2573037D7C82C8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289364,"discussion_content":"感谢分享，突然顿悟。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594081896,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81561,"user_name":"J.M.Liu","can_delete":false,"product_type":"c1","uid":1200037,"ip_address":"","ucode":"B2CB84B8E923A6","user_header":"https://static001.geekbang.org/account/avatar/00/12/4f/a5/71358d7b.jpg","comment_is_top":false,"comment_ctime":1553945954,"is_pvip":false,"replies":[{"id":"29562","content":"👍👍👍<br>","user_name":"作者回复","comment_id":81561,"uid":"1269969","ip_address":"","utype":1,"ctime":1553990408,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"130402964834","product_id":100023901,"comment_content":"1.这个是个死循环啊，有锁没群，都出不来。<br>2.如果抛开死循环，也会造成活锁，状态不稳定。当然这个也看场景，假如冲突窗口很小，又在单机多核的话，活锁的可能性还是很小的，可以接受","like_count":30,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445253,"discussion_content":"👍👍👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553990408,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":110375,"user_name":"森呢","can_delete":false,"product_type":"c1","uid":1239193,"ip_address":"","ucode":"B3D07ACF710B11","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/99/0ea71e63.jpg","comment_is_top":false,"comment_ctime":1562245194,"is_pvip":false,"replies":[{"id":"40165","content":"感谢补充😄state必须是volatile变量，否则是不会有unlock&gt;lock的，我比你更紧张😂","user_name":"作者回复","comment_id":110375,"uid":"1269969","ip_address":"","utype":1,"ctime":1562289747,"user_name_real":"王宝令"}],"discussion_count":4,"race_medal":0,"score":"104641460298","product_id":100023901,"comment_content":"老师，你好，这是我第二遍研读你的课程了，每一遍都收获很大。第一次写留言有点紧张。<br>你上面写的jdk利用内存模型的三条规则来保证可见性，是正确的。但我觉得好像描述的理由好像不充分，我不知道我理解的对不对，请老师解答一下<br>我的理解应该是 ：1）释放锁成功后，写state的值 （unlock&gt;state-=1） 顺序性<br>2）获取锁前，读state值（state&gt;lock）顺序性<br>3）传递性  unlock&gt;lock<br><br>下面是jdk的源码<br>final boolean nonfairTryAcquire(int acquires) {<br>    final Thread current = Thread.currentThread();&#47;&#47;获取当前线程实例<br>    int c = getState();&#47;&#47;获取state变量的值,即当前锁被重入的次数<br>    if (c == 0) {   &#47;&#47;state为0,说明当前锁未被任何线程持有<br>        if (compareAndSetState(0, acquires)) { &#47;&#47;以cas方式获取锁<br>            setExclusiveOwnerThread(current);  &#47;&#47;将当前线程标记为持有锁的线程<br>            return true;&#47;&#47;获取锁成功,非重入<br>        }<br>    }<br>    else if (current == getExclusiveOwnerThread()) { &#47;&#47;当前线程就是持有锁的线程,说明该锁被重入了<br>        int nextc = c + acquires;&#47;&#47;计算state变量要更新的值<br>        if (nextc &lt; 0) &#47;&#47; overflow<br>            throw new Error(&quot;Maximum lock count exceeded&quot;);<br>        setState(nextc);&#47;&#47;非同步方式更新state值<br>        return true;  &#47;&#47;获取锁成功,重入<br>    }<br>    return false;     &#47;&#47;走到这里说明尝试获取锁失败<br>}<br><br>","like_count":24,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456845,"discussion_content":"感谢补充😄state必须是volatile变量，否则是不会有unlock&amp;gt;lock的，我比你更紧张😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562289747,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1239193,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e8/99/0ea71e63.jpg","nickname":"森呢","note":"","ucode":"B3D07ACF710B11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1083,"discussion_content":"老师说的对，漏了，应该是：\n1）释放锁成功后，写state的值 （unlock>state-=1） 顺序性\n2）获取锁前，读state值（state>lock）顺序性\n3）写volatile的state>读volatile state的值\n4）传递性 unlock>lock","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1562313856,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2445017,"avatar":"https://static001.geekbang.org/account/avatar/00/25/4e/d9/a559e58c.jpg","nickname":"郭橙輝-","note":"","ucode":"2B61A22448E5DD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411030,"discussion_content":"666啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635835083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1477324,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8a/cc/da9adc82.jpg","nickname":"小太阳","note":"","ucode":"3B1C90425E485D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294593,"discussion_content":"看了你的留言我终于弄懂了unlock>lock的原因了！多谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595937324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83487,"user_name":"linqw","can_delete":false,"product_type":"c1","uid":1134138,"ip_address":"","ucode":"09DCFE98C54DD8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","comment_is_top":false,"comment_ctime":1554622719,"is_pvip":false,"replies":[{"id":"30170","content":"点个大大的赞！不过还可以再优化一下，如果阻塞在tar.lock.tryLock上一段时间，this.lock是不能释放的。","user_name":"作者回复","comment_id":83487,"uid":"1269969","ip_address":"","utype":1,"ctime":1554633518,"user_name_real":"王宝令"}],"discussion_count":15,"race_medal":0,"score":"104633837823","product_id":100023901,"comment_content":"class Account {<br>  private int balance;<br>  private final Lock lock<br>          = new ReentrantLock();<br>  &#47;&#47; 转账<br>  void transfer(Account tar, int amt){<br>\tboolean flag = true;<br>    while (flag) {<br>      if(this.lock.tryLock(随机数，NANOSECONDS)) {<br>        try {<br>          if (tar.lock.tryLock(随机数，NANOSECONDS)) {<br>            try {<br>              this.balance -= amt;<br>              tar.balance += amt;<br>\t      flag = false;<br>            } finally {<br>              tar.lock.unlock();<br>            }<br>          }&#47;&#47;if<br>        } finally {<br>          this.lock.unlock();<br>        }<br>      }&#47;&#47;if<br>    }&#47;&#47;while<br>  }&#47;&#47;transfer<br>}<br>感觉可以这样操作","like_count":24,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446044,"discussion_content":"点个大大的赞！不过还可以再优化一下，如果阻塞在tar.lock.tryLock上一段时间，this.lock是不能释放的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554633518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1004342,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/36/2c449c71.jpg","nickname":"叶玉林","note":"","ucode":"C72E88613DB992","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53096,"discussion_content":"this.lock 不需要随机时间，tar.lock.需要随机时间 我理解的是这样，我持有不到对方的锁，不立即返回而是等待一会","likes_number":12,"is_delete":false,"is_hidden":false,"ctime":1574132050,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1004342,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/36/2c449c71.jpg","nickname":"叶玉林","note":"","ucode":"C72E88613DB992","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293442,"discussion_content":"应该是外层加随机时间","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595549334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53096,"ip_address":""},"score":293442,"extra":""},{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1004342,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/36/2c449c71.jpg","nickname":"叶玉林","note":"","ucode":"C72E88613DB992","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363146,"discussion_content":"是的，如果是外层随机时间的话，两个线程同时执行A转B，B转A，获取到各自的this，同时获取tar的时候由于都没有释放锁就会结束继续下一轮，一直跑但是不能完成转账还是存在活锁问题。\ntryLock方法描述 {@code true} if the lock was free and was acquired by the current thread, or the lock was already held by the current thread; and {@code false} if the waiting time elapsed before the lock could be acquired","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1617116316,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53096,"ip_address":""},"score":363146,"extra":""},{"author":{"id":1662987,"avatar":"https://static001.geekbang.org/account/avatar/00/19/60/0b/d7dddf19.jpg","nickname":"皮皮","note":"","ucode":"8C986AA546B44E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570023,"discussion_content":"外层加随机时间没用啊，线程执行到这里就可以拿到锁，后面还是有活锁问题","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1651639208,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":293442,"ip_address":""},"score":570023,"extra":""}]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293441,"discussion_content":"老师的意思应该是如果阻塞在内层，内层锁拿不到等一段时间，此时外层锁是没释放的，这段时间可能形成死锁；破解活锁一个随机时间就够了","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1595549242,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1533266,"avatar":"https://static001.geekbang.org/account/avatar/00/17/65/52/07c09c7f.jpg","nickname":"josancpp","note":"","ucode":"0CDC39B3E716A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275125,"discussion_content":"this.lock还是要释放的。\n如果A转账B，B转账A，两个锁都拿个各自的this锁，如果不释放锁，会出现死锁","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1590667491,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293443,"discussion_content":"外层加随机时间，内层不加","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595549359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1580185,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/99/5e1a2118.jpg","nickname":"mylife","note":"","ucode":"D802160BFB29FC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591224,"discussion_content":"个人理解：只需要1个地方加随机数就可以了。在条件不成立的情况下，尽量让锁的持有时间最少，如果是在内层随机超时时间的话，这个时候上层的锁是没释放的，如果双方都进入到内层的时候，这个过程中存在死锁的过程直到超时时间破坏；如果在外层加随机的话，内层没获取就立刻都释放，只需要外层随机不一样，再次进来后就会成功","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666410163,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1068432,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4d/90/25b6f544.jpg","nickname":"马文龙","note":"","ucode":"679B0F0AB402C7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351308,"discussion_content":"大家讨论了一番后，是不是不管里外，只要有一层加随机时间就够了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614237867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1068432,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4d/90/25b6f544.jpg","nickname":"马文龙","note":"","ucode":"679B0F0AB402C7","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":380463,"discussion_content":"是的，只需要错开一个人的时间，就降低了活锁的概率","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624517319,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":351308,"ip_address":""},"score":380463,"extra":""}]},{"author":{"id":1181650,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","nickname":"惘 闻","note":"","ucode":"C5909F034BF072","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294148,"discussion_content":"只需要内层不加等待时间就好了吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595810411,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1156592,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a5/f0/8648c464.jpg","nickname":"Joker","note":"","ucode":"126AF848001A1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":43380,"discussion_content":"是说第二个不用用随机时间 trylock的意思吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572871173,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1156592,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a5/f0/8648c464.jpg","nickname":"Joker","note":"","ucode":"126AF848001A1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":43377,"discussion_content":"大佬，请教一下啊，这个老师说的this.lock不能释放，这个要咋个优化？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572870977,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177681,"user_name":"CDz","can_delete":false,"product_type":"c1","uid":1114779,"ip_address":"","ucode":"A23BEE1C4A5922","user_header":"https://static001.geekbang.org/account/avatar/00/11/02/9b/b1a3c60d.jpg","comment_is_top":false,"comment_ctime":1581473039,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"96070753551","product_id":100023901,"comment_content":"什么是活锁？<br>结果和活锁一样，不同的是，活锁没有堵塞，顾名思义，一直在运行，但是没有执行有效代码。<br><br>这里为什么会出现活锁？<br>可能导致活锁 ，并不一定会活锁。<br>原因：双方同时为对方转账时，同时进入第一个锁，但是发现获取不到第二个锁，于是释放，进行下一次循环。<br>下一次循环同样的结果，这就是出现了活锁。<br><br>解决办法：<br>引入随机时间","like_count":23,"discussions":[{"author":{"id":2997759,"avatar":"","nickname":"Geek_85f669","note":"","ucode":"62E5C58B9CEDF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571532,"discussion_content":"+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652259102,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1652099,"avatar":"https://static001.geekbang.org/account/avatar/00/19/35/83/f2d7beac.jpg","nickname":"粉红猪","note":"","ucode":"355C1B87D3D0DE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560435,"discussion_content":"还有我，我是废物(ಥ﹏ಥ)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649328770,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1900550,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqpYdydSevQVgL0xkj7REG9efRYeesEKnMlzSLVzcMxstvib1jD40BFqhXcJaiaX2AOeO69bf2SUx8Q/132","nickname":"是愛不是爱","note":"","ucode":"7577081245E620","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291372,"discussion_content":"看到你这里我才顿悟，我是不是没救了o(╥﹏╥)o","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594795402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1428043,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ca/4b/c1ace3aa.jpg","nickname":"蚝不鱿鱼","note":"","ucode":"5DB98E406F1D3E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1900550,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqpYdydSevQVgL0xkj7REG9efRYeesEKnMlzSLVzcMxstvib1jD40BFqhXcJaiaX2AOeO69bf2SUx8Q/132","nickname":"是愛不是爱","note":"","ucode":"7577081245E620","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306652,"discussion_content":"没救的不止你一个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600340974,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":291372,"ip_address":""},"score":306652,"extra":""}]}]},{"had_liked":false,"id":81500,"user_name":"海鸿","can_delete":false,"product_type":"c1","uid":1104275,"ip_address":"","ucode":"7074EF94EA70AD","user_header":"https://static001.geekbang.org/account/avatar/00/10/d9/93/098e5ef5.jpg","comment_is_top":false,"comment_ctime":1553928474,"is_pvip":false,"replies":[{"id":"29543","content":"对","user_name":"作者回复","comment_id":81500,"uid":"1269969","ip_address":"","utype":1,"ctime":1553950370,"user_name_real":"王宝令"}],"discussion_count":4,"race_medal":0,"score":"74568372506","product_id":100023901,"comment_content":"突然有个问题：<br>cpu层面的原子性是单条cpu指令。<br>java层面的互斥（管程）保证了原子性。<br>这两个原子性意义应该不一样吧？<br>我的理解是cpu的原子性是不受线程调度影响，指令要不执行了，要么没执行。而java层面的原子性是在锁的机制下保证只有一个线程执行，其余等待，此时cpu还是可以进行线程调度，使运行中的那个线程让出cpu时间，当然了该线程还是掌握锁。<br>我这样理解对吧？","like_count":17,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445230,"discussion_content":"对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553950370,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181650,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","nickname":"惘 闻","note":"","ucode":"C5909F034BF072","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294430,"discussion_content":"你理解的是正确的，可是这样的话，为什么加了锁老师还说有可见性问题呢？加了锁之后，保证原子性，变量的值已经刷新到内存中了啊。其他可访问这个变量的线程也就对这个变量可见了啊。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595893036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1855112,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIYj6Zv3ibicLebxo7lsPMEwpBynHkYp8pLc3FcltUfmOBSRxpmicEwIAgP9OvSKnGGdaxwsZ7yiciaSsQ/132","nickname":"冯磊","note":"","ucode":"4FFB8B984269FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1181650,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","nickname":"惘 闻","note":"","ucode":"C5909F034BF072","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383188,"discussion_content":"原子性和可见性是两个现象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625974683,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":294430,"ip_address":""},"score":383188,"extra":""}]},{"author":{"id":1323652,"avatar":"","nickname":"sibyl","note":"","ucode":"0D142011860D69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289639,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594170503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81520,"user_name":"姜戈","can_delete":false,"product_type":"c1","uid":1058972,"ip_address":"","ucode":"45C4BE93C8E4CC","user_header":"https://static001.geekbang.org/account/avatar/00/10/28/9c/73e76b19.jpg","comment_is_top":false,"comment_ctime":1553933932,"is_pvip":false,"replies":[{"id":"29563","content":"用condition会更复杂<br>","user_name":"作者回复","comment_id":81520,"uid":"1269969","ip_address":"","utype":1,"ctime":1553990530,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"61683476076","product_id":100023901,"comment_content":"我也觉得是存在活锁，而非死锁。存在这种可能性：互相持有各自的锁，发现需要的对方的锁都被对方持有，就会释放当前持有的锁，导致大家都在不停持锁，释放锁，但事情还没做。当然还是会存在转账成功的情景，不过效率低下。我觉得此时需要引入Condition，协调两者同步处理转账！","like_count":14,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445239,"discussion_content":"用condition会更复杂\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553990530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81384,"user_name":"Q宝的宝","can_delete":false,"product_type":"c1","uid":1219139,"ip_address":"","ucode":"55C575755A4905","user_header":"https://static001.geekbang.org/account/avatar/00/12/9a/43/d6291e76.jpg","comment_is_top":false,"comment_ctime":1553881047,"is_pvip":false,"replies":[{"id":"29485","content":"火眼金睛👍👍👍👍，这就改过来<br>","user_name":"作者回复","comment_id":81384,"uid":"1269969","ip_address":"","utype":1,"ctime":1553904418,"user_name_real":"王宝令"}],"discussion_count":3,"race_medal":0,"score":"61683423191","product_id":100023901,"comment_content":"老师，本文在讲述如何保证可见性时，分析示例--“线程 T1 对 value 进行了 +=1 操作后，后续的线程 T2 能否看到 value 的正确结果？“时，提到三条Happen-Before规则，这里在解释第2条和第3条规则时，似乎说反了，正确的应该是，根据volatile变量规则，线程T1的unlock()操作Happen-Before于线程T2的lock()操作，所以，根据传递性规则，线程 T1 的 value+=1操作Happen-Before于线程T2的lock()操作。请老师指正。","like_count":14,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445174,"discussion_content":"火眼金睛👍👍👍👍，这就改过来\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553904418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1654600,"avatar":"","nickname":"xanxus","note":"","ucode":"FFF1EFD2ABCBAA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312142,"discussion_content":"happend-before中的锁的规则跟并发包里面的没有关系吧，当然并发包里面的同样满足这个条件，但是用这个太推理的话，感觉有点因果倒置的感觉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602594960,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3003,"discussion_content":"老师是不是再故意考验我们自己理解程度～😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564107129,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81380,"user_name":"羊三","can_delete":false,"product_type":"c1","uid":1103221,"ip_address":"","ucode":"59F03ED302A734","user_header":"https://static001.geekbang.org/account/avatar/00/10/d5/75/75dab2b3.jpg","comment_is_top":false,"comment_ctime":1553879246,"is_pvip":false,"replies":[{"id":"29569","content":"是的<br>","user_name":"作者回复","comment_id":81380,"uid":"1269969","ip_address":"","utype":1,"ctime":1553992002,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"44503552206","product_id":100023901,"comment_content":"用非阻塞的方式去获取锁，破坏了第五章所说的产生死锁的四个条件之一的“不可抢占”。所以不会产生死锁。<br><br>用锁的最佳实践，第三个“永远不在调用其他对象的方法时加锁”，我理解其实是在工程规范上避免可能出现的锁相关问题。","like_count":10,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445171,"discussion_content":"是的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553992002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81504,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1553929349,"is_pvip":false,"replies":[{"id":"29565","content":"👍<br>","user_name":"作者回复","comment_id":81504,"uid":"1269969","ip_address":"","utype":1,"ctime":1553991646,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"35913667717","product_id":100023901,"comment_content":"1 不会出现死锁，因为不存在阻塞的情况<br>2 线程较多的情况会导致部分线程始终无法获取到锁，导致活锁","like_count":9,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445232,"discussion_content":"👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553991646,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136248,"user_name":"张鑫","can_delete":false,"product_type":"c1","uid":1166695,"ip_address":"","ucode":"3CE5B1077184B2","user_header":"https://static001.geekbang.org/account/avatar/00/11/cd/67/23fab87a.jpg","comment_is_top":false,"comment_ctime":1569395701,"is_pvip":true,"replies":[{"id":"52395","content":"👍","user_name":"作者回复","comment_id":136248,"uid":"1269969","ip_address":"","utype":1,"ctime":1569495102,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"31634166773","product_id":100023901,"comment_content":"公平锁和非公平锁，公平锁唤醒策略就是谁等待时间长，就唤醒谁。非公平锁，有可能等待时间短。<br>对于公平锁和非公平锁我有不同的理解。<br><br>个人理解：公平锁是直接先进入AQS同步队列，抢占锁。非公平锁，是先抢占锁，若没有抢到则进入AQS同步队列，等待唤醒。<br><br>非公平锁代码：<br>\tfinal void lock() {<br>            if (compareAndSetState(0, 1))<br>                setExclusiveOwnerThread(Thread.currentThread());<br>            else<br>                acquire(1);<br>        }<br>公平锁：<br>\t final void lock() {<br>            acquire(1);<br>        }<br><br>acquire(1)是当前线程抢占锁，若没有抢到则加入到同步队列中。公平锁和非公平锁逻辑一致。","like_count":7,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468525,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569495102,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81454,"user_name":"朱小豪","can_delete":false,"product_type":"c1","uid":1311234,"ip_address":"","ucode":"9177EF1DDFF346","user_header":"https://static001.geekbang.org/account/avatar/00/14/02/02/1080b30c.jpg","comment_is_top":false,"comment_ctime":1553917351,"is_pvip":false,"replies":[{"id":"29561","content":"加了break，也会有活锁问题，不加的话我觉得也是活锁，因为锁都会释放<br>","user_name":"作者回复","comment_id":81454,"uid":"1269969","ip_address":"","utype":1,"ctime":1553989455,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"31618688423","product_id":100023901,"comment_content":"应该是少了个break跳出循环，然后这个例子是会产生死锁的，因为满足了死锁产生的条件。","like_count":7,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445205,"discussion_content":"加了break，也会有活锁问题，不加的话我觉得也是活锁，因为锁都会释放\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553989455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126171,"user_name":"zyz","can_delete":false,"product_type":"c1","uid":1019339,"ip_address":"","ucode":"0092F8C0FFA375","user_header":"","comment_is_top":false,"comment_ctime":1566345602,"is_pvip":false,"replies":[{"id":"46577","content":"是管程的实现","user_name":"作者回复","comment_id":126171,"uid":"1269969","ip_address":"","utype":1,"ctime":1566359269,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"27336149378","product_id":100023901,"comment_content":"老师，lock是用aqs实现的，aqs是用了volatile＋cas操作系统原子操作保证线程安全的，这个也是管程吗？","like_count":6,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463863,"discussion_content":"是管程的实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566359269,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114509,"user_name":"小予","can_delete":false,"product_type":"c1","uid":1442580,"ip_address":"","ucode":"3F5EAEE1746074","user_header":"https://static001.geekbang.org/account/avatar/00/16/03/14/e9ca2d09.jpg","comment_is_top":false,"comment_ctime":1563327143,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18743196327","product_id":100023901,"comment_content":"1、转账成功跳出循环，避免死循环<br>2、锁自己账户时，加一个随机等待时间，避免活锁<br>3、锁目标账户时，锁不到则直接解锁<br>class Account {<br>\tprivate int balance;<br>\tprivate final Lock lock = new ReentrantLock();<br>    &#47;&#47; 转账<br>    void transfer(Account tar, int amt){<br>\t\twhile (true) {<br>\t\t    if(this.lock.tryLock(随机数，NANOSECONDS)) {<br>\t\t\t\ttry {<br>\t\t\t\t\tif (tar.lock.tryLock()) {<br>\t\t\t\t\t\ttry {<br>\t\t\t\t\t\t\tthis.balance -= amt;<br>\t\t\t\t\t\t\ttar.balance += amt;<br>\t\t\t\t\t\t\t&#47;&#47; 转账成功结束循环<br>\t\t\t\t\t\t\tbreak;<br>\t\t\t\t\t\t} finally {<br>\t\t\t\t\t\t\ttar.lock.unlock();<br>\t\t\t\t\t\t}<br>\t\t\t\t\t}&#47;&#47;if<br>\t\t\t\t} finally {<br>\t\t\t\t\tthis.lock.unlock();<br>\t\t\t\t}<br>\t\t\t}&#47;&#47;if<br>\t\t}&#47;&#47;while<br>    }&#47;&#47;transfer<br>}","like_count":4,"discussions":[{"author":{"id":1621470,"avatar":"https://static001.geekbang.org/account/avatar/00/18/bd/de/e0c994b3.jpg","nickname":"坐地铁的程序员","note":"","ucode":"A04A239D173E2A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5248,"discussion_content":"我觉得你这样的优化，同样存在活锁的可能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566114503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94880,"user_name":"tdytaylor","can_delete":false,"product_type":"c1","uid":1181214,"ip_address":"","ucode":"5B4919FDFE91A6","user_header":"https://static001.geekbang.org/account/avatar/00/12/06/1e/51ad425f.jpg","comment_is_top":false,"comment_ctime":1557914801,"is_pvip":false,"replies":[{"id":"33934","content":"想想对面相遇的两个人互相谦让的例子看看","user_name":"作者回复","comment_id":94880,"uid":"1269969","ip_address":"","utype":1,"ctime":1557929657,"user_name_real":"王宝令"}],"discussion_count":3,"race_medal":0,"score":"18737783985","product_id":100023901,"comment_content":"老师，关于这个问题，我思考之后觉得不会出现死锁，但是没看出为什么会出现活锁","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450243,"discussion_content":"想想对面相遇的两个人互相谦让的例子看看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557929657,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1228393,"avatar":"https://static001.geekbang.org/account/avatar/00/12/be/69/5404e5a3.jpg","nickname":"momo","note":"","ucode":"3B2CB1EC9BC601","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361744,"discussion_content":"cpu片效率有那么差吗 AtryLock 进入下次循环前 B不会有一瞬间发现的机会？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616742905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1428043,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ca/4b/c1ace3aa.jpg","nickname":"蚝不鱿鱼","note":"","ucode":"5DB98E406F1D3E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306653,"discussion_content":"公交车只剩一个位子，两个人一直不停互相让座，然后那个位置就一直空着了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600341075,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81446,"user_name":"朱小豪","can_delete":false,"product_type":"c1","uid":1311234,"ip_address":"","ucode":"9177EF1DDFF346","user_header":"https://static001.geekbang.org/account/avatar/00/14/02/02/1080b30c.jpg","comment_is_top":false,"comment_ctime":1553915626,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18733784810","product_id":100023901,"comment_content":"本文最后的例子，不明白为什么要用while true而且没有跳出循环，这不是死循环吗","like_count":4},{"had_liked":false,"id":210313,"user_name":"nodlee","can_delete":false,"product_type":"c1","uid":1155871,"ip_address":"","ucode":"C1D36A5A72A0D1","user_header":"https://static001.geekbang.org/account/avatar/00/11/a3/1f/c94facb8.jpg","comment_is_top":false,"comment_ctime":1587718811,"is_pvip":false,"replies":[{"id":"78692","content":"没问题","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1588032652,"ip_address":"","comment_id":210313,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14472620699","product_id":100023901,"comment_content":"T1                    T2<br>lock(1)               lock(1)<br>  \tgetState              getState<br>value += 1;           value += 1;<br>unlock(1);            unlock(1); <br>\tgetState              getState<br>\tsetState              setState<br>T1 和 T2 的操作序列可以简化为上面的内容，我的理解：T1 unlock 最后会写 state, 而 T2 的 lock 首先读 state, 根据 volatile 写优先于读的原则，所以 T1 的 unlock() 操作 Happens-Before T2 的 lock() 操作； 不知道这样理解有没有问题？","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493002,"discussion_content":"没问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588032652,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131417,"user_name":"兔2🐰🍃","can_delete":false,"product_type":"c1","uid":1096984,"ip_address":"","ucode":"1FEDA044BB6CBD","user_header":"https://static001.geekbang.org/account/avatar/00/10/bd/18/2af6bf4b.jpg","comment_is_top":false,"comment_ctime":1567744006,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14452645894","product_id":100023901,"comment_content":"volatile 变量规则：【unlock()对state的写操作 happens-before其他线程lock() 对 state的读操作，】所以线程 T1 的 unlock() 操作 Happens-Before 线程 T2 的 lock() 操作； <br>这样会不会更容易理解些？","like_count":3},{"had_liked":false,"id":83035,"user_name":"易儿易","can_delete":false,"product_type":"c1","uid":1242864,"ip_address":"","ucode":"B15D1031CA841E","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqLcWH3mSPmhjrs1aGL4b3TqI7xDqWWibM4nYFrRlp0z7FNSWaJz0mqovrgIA7ibmrPt8zRScSfRaqQ/132","comment_is_top":false,"comment_ctime":1554378674,"is_pvip":false,"replies":[{"id":"30070","content":"是的，都被唤醒。理论上是同时进入入口等待队列，等待时间是相同的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554479267,"ip_address":"","comment_id":83035,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14439280562","product_id":100023901,"comment_content":"老师，notifyAll()在面对公平锁和非公平锁的时候，是不是效果就一样了？所有等待队列中的线程全部被唤醒，统统到入口等待队列中排队？这些被唤醒的线程不用根据等待时间排队再放入入口等待队列中了吧？","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445827,"discussion_content":"是的，都被唤醒。理论上是同时进入入口等待队列，等待时间是相同的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554479267,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81800,"user_name":"右耳听海","can_delete":false,"product_type":"c1","uid":1022011,"ip_address":"","ucode":"E0B9F1083F4F98","user_header":"https://static001.geekbang.org/account/avatar/00/0f/98/3b/5af90c80.jpg","comment_is_top":false,"comment_ctime":1554037987,"is_pvip":false,"replies":[{"id":"29663","content":"=1之前有一段代码会查看状态是否为0，显然不能三七二十一直接设置<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554078886,"ip_address":"","comment_id":81800,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14438939875","product_id":100023901,"comment_content":"请问state=1先读取是怎么得出来的，还有lock和unlock的方法对state都是写操作，怎么用到valiate规则的，valiate规则不是读取操作先与写操作吗，这个地方两个都是写操作","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445352,"discussion_content":"=1之前有一段代码会查看状态是否为0，显然不能三七二十一直接设置\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554078886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135601,"user_name":"Wangxi","can_delete":false,"product_type":"c1","uid":1211790,"ip_address":"","ucode":"C25A9A14179930","user_header":"https://static001.geekbang.org/account/avatar/00/12/7d/8e/bb16d414.jpg","comment_is_top":false,"comment_ctime":1569226141,"is_pvip":true,"replies":[{"id":"53610","content":"最终都会调用操作系统提供的API，线程都会被挂起，所以从这个角度看都是重量级的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1570580819,"ip_address":"","comment_id":135601,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10159160733","product_id":100023901,"comment_content":"请问老师一个问题。AQS实现的锁，阻塞唤醒线程使用的是park&#47;unpark方法。synchronized关键字实现的锁，在底层也是park&#47;unpark。这两种锁底层实现可以认为是一致的吗。如果是一致的。那么lock接口也是重量级锁了。","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468262,"discussion_content":"最终都会调用操作系统提供的API，线程都会被挂起，所以从这个角度看都是重量级的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570580819,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127325,"user_name":"xinglichea","can_delete":false,"product_type":"c1","uid":1176447,"ip_address":"","ucode":"986DA07BF3CA89","user_header":"https://static001.geekbang.org/account/avatar/00/11/f3/7f/2dd9409b.jpg","comment_is_top":false,"comment_ctime":1566655059,"is_pvip":false,"replies":[{"id":"47167","content":"不是所有情况都能代替，重新想想并发下i++","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1566712027,"ip_address":"","comment_id":127325,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10156589651","product_id":100023901,"comment_content":"2.永远只在访问可变的成员变量时加锁<br><br>老师，请问下，访问可变的成员变量时加锁方案，能否用volatile变量替代？如果可以，在并发能力上有什么区别？","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464442,"discussion_content":"不是所有情况都能代替，重新想想并发下i++","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566712027,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127120,"user_name":"静水流深","can_delete":false,"product_type":"c1","uid":1339724,"ip_address":"","ucode":"644F05EFBD2E7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/4c/2cefec07.jpg","comment_is_top":false,"comment_ctime":1566559525,"is_pvip":false,"replies":[{"id":"47077","content":"这个建议我觉得非常好😃","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1566617555,"ip_address":"","comment_id":127120,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10156494117","product_id":100023901,"comment_content":"以前学并发编程时候很吃力，就是坚持学完了本章后，我有种豁然开朗的感觉！谢谢老师！这个专栏，强烈建议涨价！！","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464328,"discussion_content":"这个建议我觉得非常好😃","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566617555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1860513,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/63/a1/e281d530.jpg","nickname":"王晨旭","note":"","ucode":"AB7364E1809126","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":205895,"discussion_content":"你可以多买几章送人 以显示你土豪的身份","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584355015,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1987202,"avatar":"","nickname":"Geek_783cc7","note":"","ucode":"C43F76B1978FA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325736,"discussion_content":"你是魔鬼吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605418451,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87834,"user_name":"锦","can_delete":false,"product_type":"c1","uid":1468298,"ip_address":"","ucode":"CB0EB4B68C468B","user_header":"https://static001.geekbang.org/account/avatar/00/16/67/8a/babd74dc.jpg","comment_is_top":false,"comment_ctime":1555726655,"is_pvip":false,"replies":[{"id":"31617","content":"SDK的段位和JVM差距还是挺大的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555746881,"ip_address":"","comment_id":87834,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10145661247","product_id":100023901,"comment_content":"文中提到JAVA SDK 里面Lock也是JAVA对管程的另一种实现，那么想必也是符合管程的工作原理，即内部封装共享变量和条件变量等待队列和操作方法。那么其可见性为什么不能通过管程中锁的happens-before规则来保证呢？","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447618,"discussion_content":"SDK的段位和JVM差距还是挺大的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555746881,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81702,"user_name":"拒绝","can_delete":false,"product_type":"c1","uid":1335155,"ip_address":"","ucode":"CB0264C4D3FE17","user_header":"https://static001.geekbang.org/account/avatar/00/14/5f/73/bb3dc468.jpg","comment_is_top":false,"comment_ctime":1554012627,"is_pvip":false,"replies":[{"id":"29624","content":"加个随机线程睡眠时间就可以了","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554030865,"ip_address":"","comment_id":81702,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10143947219","product_id":100023901,"comment_content":"老师您好：<br>   那在解决这个活锁问题时，是在获取其他对象锁前面（tar.lock.tryLock()）加个随机线程睡眠时间？还是《java编程：设计原则与模式》中的第三条，永远不在调用其他对象时加锁；去掉（tar.lock.tryLock()） 这个锁来解决活锁呢？","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445306,"discussion_content":"加个随机线程睡眠时间就可以了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554030865,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346483,"user_name":"Bumblebee","can_delete":false,"product_type":"c1","uid":2051293,"ip_address":"","ucode":"B879C8A511D08D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","comment_is_top":false,"comment_ctime":1653192601,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5948159897","product_id":100023901,"comment_content":"今日总结，总结的不对的希望老师同学们多多指正。<br><br><br>一、Java本身有了synchronized为什么还有提供Lock实现？<br><br>①  首先回顾一下发生死锁的四个必要条件；<br>      1）线程对资源的访问是互斥的；<br>      2）占有且等待（线程在获取某个资源失败时，不会主动释放，自己已经持有的资源）；<br>      3）不可中断（线程无法响应其他线程的中断）；<br>      4）循环等待（线程互相等待）；<br>②  要破坏死锁任意破坏死锁四个必要条件中的一个即可；<br>③  因此jdk的Lock实现提供了下面几个方法来解决死锁问题；<br>    1）支持中断的API；<br>          void lockInterruptibly() throws  InterruptedException;（持有synchronized隐式锁线程被阻塞后无法响应中断，而持有Lock锁的线程在阻塞状态下是能够响应中断的，这样被阻塞的线程才有机会释放自己持有的锁）；<br><br>    2）支持超时的API；<br>          boolean tryLock(long time, TimeUnit unit)   throws InterruptedException（在指定时间内没有获取到锁，线程不是进入阻塞状态而是返回一个错误，这样线程就可以释放自己已经持有的资源，破坏了死锁中不可抢占这个条件）；<br><br>    3）支持非阻塞获取锁的API；<br>           boolean tryLock()（如果尝试获取锁失败线程不进入阻塞状态，而是直接返回，这样线程也有机会释放自己持有的资源，破了死锁中不可抢占这个条件）；<br><br>二   、ReentrantLock，是如何保证可见性的？<br> ①  ReentrantLock，内部持有一个被volatile修饰的成员变量；<br> ②   利用了 volatile 相关的 Happens-Before 规则，能保存可见性；<br><br>三、用锁的最佳实践？<br>①  永远只在更新对象成员变量的时候加锁；<br>②  永远只在访问可变成员变量时加锁；<br>③  永远不要在调用其他对象方法时加锁；<br><br><br>","like_count":1},{"had_liked":false,"id":319344,"user_name":"Geek_7a9e2c","can_delete":false,"product_type":"c1","uid":1265132,"ip_address":"","ucode":"00DC77B9C85EE3","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er78PmxPDq4a3vNuvvX10fiaBC4FZ7XXuOX1nMjhCIqiaHWfpjfd5CDoVVB0GRGveChNmkSmuy7smxQ/132","comment_is_top":false,"comment_ctime":1635753904,"is_pvip":false,"replies":[{"id":"116131","content":"非公平锁不管有没有等待的，先去获取锁，能获取就用，相当于插队；公平锁是先去排队。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1636264640,"ip_address":"","comment_id":319344,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5930721200","product_id":100023901,"comment_content":"关于非公平锁的解释与其他的资料有点出入，其他资料讲非公平锁的场景是当锁释放后，如果刚好有个线程在尝试获取锁，则直接给这个线程，而不用在队列里唤醒一个线程，因为唤醒一个线程需要的时间比较多，而你举例的场景是唤醒的可能不是从队列头部唤醒，而是随机从队列里拿出来一个线程","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529600,"discussion_content":"非公平锁不管有没有等待的，先去获取锁，能获取就用，相当于插队；公平锁是先去排队。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636264640,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":277489,"user_name":"Owen","can_delete":false,"product_type":"c1","uid":2403622,"ip_address":"","ucode":"FDE0D574B8ED5A","user_header":"https://static001.geekbang.org/account/avatar/00/24/ad/26/d46f4394.jpg","comment_is_top":false,"comment_ctime":1612429568,"is_pvip":false,"replies":[{"id":"100816","content":"Lock是SDK利用volatile规则实现的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1612599628,"ip_address":"","comment_id":277489,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5907396864","product_id":100023901,"comment_content":"“解锁 Happens-Before 于后续对这个锁的加锁”，这个原则是只针对synchronized，与Lock无关吗？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515068,"discussion_content":"Lock是SDK利用volatile规则实现的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612599628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262286,"user_name":"尼古拉斯","can_delete":false,"product_type":"c1","uid":2026074,"ip_address":"","ucode":"82EE35B505C09A","user_header":"","comment_is_top":false,"comment_ctime":1605684521,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5900651817","product_id":100023901,"comment_content":"while (true) 没有结束条件，虽然不是重点","like_count":1},{"had_liked":false,"id":237363,"user_name":"惘 闻","can_delete":false,"product_type":"c1","uid":1181650,"ip_address":"","ucode":"C5909F034BF072","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","comment_is_top":false,"comment_ctime":1595809902,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5890777198","product_id":100023901,"comment_content":"老师，看到可见性那里我有个疑惑。锁可以保证变量操作的原子性。而变量的一条增加操作，指的是，1.先从内存获取值到缓存中。2.修改值。3.将修改后的值从缓存写入到内存中。既然已经在内存中了，怎么还会有可见性问题呢。不是很理解这里。","like_count":1,"discussions":[{"author":{"id":1181650,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","nickname":"惘 闻","note":"","ucode":"C5909F034BF072","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294765,"discussion_content":"我终于懂了。在讲原子性的时候说的写入内存说的是对于这条线程而言，写入自己的工作内存。这里并不包涵写入主内存中。而volatile和happen-before 选择是保证将工作内存中的变量值写入到主内存中的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595991611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":191234,"user_name":"雷刚","can_delete":false,"product_type":"c1","uid":1655725,"ip_address":"","ucode":"115FE2BE1AAB61","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/pTD8nS0SsORKiaRD3wB0NK9Bpd0wFnPWtYLPfBRBhvZ68iaJErMlM2NNSeEibwQfY7GReILSIYZXfT9o8iaicibcyw3g/132","comment_is_top":false,"comment_ctime":1584756971,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879724267","product_id":100023901,"comment_content":"看了一下评论区的留言，再仔细看了一下代码，确实不会产生死锁，却可能会产生活锁。不过生产中，我宁愿加一把大锁也不会这么写代码，不然太难读了，可能一些框架的底层会这么写。","like_count":1},{"had_liked":false,"id":129854,"user_name":"Geek_8a997f","can_delete":false,"product_type":"c1","uid":1508407,"ip_address":"","ucode":"60B2CD8695F36B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK0NwSicic81RbxQPraALLtK44KOSahvRlvic8B5yD0RX43xKaMDGMibJZnhBe0BY0IibWFpErzXPuyZNg/132","comment_is_top":false,"comment_ctime":1567306057,"is_pvip":true,"replies":[{"id":"48441","content":"是的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1567311773,"ip_address":"","comment_id":129854,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5862273353","product_id":100023901,"comment_content":"老师，有个疑惑请教一下，您的文章中提到，synchronized不能响应中断，是指线程被中断，需要自己读取中断标志并自行处理终止，这种的不算响应中断么？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465680,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567311773,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119663,"user_name":"Fortune","can_delete":false,"product_type":"c1","uid":1508654,"ip_address":"","ucode":"6B9465AC996523","user_header":"https://static001.geekbang.org/account/avatar/00/17/05/2e/5a6b6b6e.jpg","comment_is_top":false,"comment_ctime":1564648449,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5859615745","product_id":100023901,"comment_content":"唉，到实践部分就懵逼了，前面理论还没消化，实践部分理解不是很透，不适合没有用过或者没有对并发包API理解的人，我太难了。。。。","like_count":1},{"had_liked":false,"id":111010,"user_name":"倚梦流","can_delete":false,"product_type":"c1","uid":1435045,"ip_address":"","ucode":"7CB442D629534B","user_header":"https://static001.geekbang.org/account/avatar/00/15/e5/a5/fae40ac3.jpg","comment_is_top":false,"comment_ctime":1562420484,"is_pvip":false,"replies":[{"id":"40426","content":"👍加个随机等待就更好了","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1562494141,"ip_address":"","comment_id":111010,"utype":1}],"discussion_count":4,"race_medal":0,"score":"5857387780","product_id":100023901,"comment_content":"会出现活锁和死循环，老师你好，这是我的优化后的代码，运用了之前学过的知识，优先获取id值比较小的资源，请老师指点是否有不足之处，谢谢！<br>    void transfer6(Account tar,int amt){<br>        boolean isOver=false;<br>        Account left=this;<br>        Account right=tar;<br>        if(left.id&gt;right.id){<br>            left=tar;<br>            right=this;<br>        }<br>        Thread th=Thread.currentThread();<br>        while (!th.isInterrupted() &amp;&amp; !isOver){<br>            if(left.lock.tryLock()){<br>                try{<br>                    if(right.lock.tryLock()){<br>                        try{<br>                            System.out.println(&quot;账号：&quot;+this.id+&quot;开始转账啦！,转出金额：&quot;+amt);<br>                            if(this.balance&gt;=amt){<br>                                this.balance-=amt;<br>                                tar.balance+=amt;<br>                                System.out.println(&quot;转账成功！&quot;);<br>                            }else{<br>                                System.out.println(&quot;转账失败，余额不足！&quot;);<br>                            }<br>                            isOver=true;<br>                            System.out.println(&quot;转入账号:&quot;+this.id+&quot; 余额：&quot;+this.balance);<br>                            System.out.println(&quot;转出账号:&quot;+tar.id+&quot; 余额：&quot;+tar.balance);<br>                            System.out.println(&quot;转账结束！&quot;);<br>                        }finally {<br>                            right.lock.unlock();<br>                        }<br>                    }<br>                }finally {<br>                    left.lock.unlock();<br>                }<br>            }<br>        }<br>    }","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457174,"discussion_content":"👍加个随机等待就更好了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562494141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1196266,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ5ricEp2SDpA2d2iaw6TOVaPfmeicDicP34bamibX1JbHEkJl8wDQOK3ia4vic9WacKjFia9wibeG3nwOIiafA/132","nickname":"hunter","note":"","ucode":"EFBF6071BFCE10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546189,"discussion_content":"都在外层加随机 还是针对一把锁加随机？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642214013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1004192,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/52/a0/d308434e.jpg","nickname":"StarKing","note":"","ucode":"EB825CFA70AC1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24023,"discussion_content":"1.顺序解决了锁方向。\n2.最好加随机锁时间解决碰撞问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569983537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1448974,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/0e/42b357cd.jpg","nickname":"Xiky","note":"","ucode":"C9E8D8C7024CA6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2280,"discussion_content":"感觉是不是不需要随机等待了，加锁的顺序已经让id的排序保证了？请老师指正","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563436244,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85143,"user_name":"尹圣","can_delete":false,"product_type":"c1","uid":1163547,"ip_address":"","ucode":"C276A01B4910F3","user_header":"https://static001.geekbang.org/account/avatar/00/11/c1/1b/e08d42f8.jpg","comment_is_top":false,"comment_ctime":1554988465,"is_pvip":false,"replies":[{"id":"30522","content":"不知道你说的不安全是指哪里，state 你只是写了，没有读，而且account++也不是互斥的操作。<br>java并发包里用volatile保证可见性，还用aqs实现了互斥。保证线程安全不是这么简单的。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554989771,"ip_address":"","comment_id":85143,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5849955761","product_id":100023901,"comment_content":"public class Main {<br><br>    static volatile int state = 0;<br><br>    public static long account = 0;<br><br>    public static void main(String[] args) throws InterruptedException {<br><br>        for (int i = 0; i &lt; 100000; i++) {<br>            new Thread(() -&gt; {<br>                new Main().addAccount();<br>            }).start();<br>        }<br><br>        Thread.sleep(6000);<br>        System.out.println(account);<br>    }<br><br>    private void addAccount() {<br>        &#47;&#47;  线程不安全<br>        state = 1;   &#47;&#47;----1<br>        account++;   &#47;&#47;----2<br>        state = 0;   &#47;&#47;----3<br>    }<br>}<br><br>老师，有个疑问，如果按照volatile的Happens-Before这里的程序也应该是线程安全的，但实际上不是线程安全的，问题出在哪呢？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446572,"discussion_content":"不知道你说的不安全是指哪里，state 你只是写了，没有读，而且account++也不是互斥的操作。\njava并发包里用volatile保证可见性，还用aqs实现了互斥。保证线程安全不是这么简单的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554989771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81886,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1554078917,"is_pvip":false,"replies":[{"id":"29664","content":"用可重入锁可以实现，还有些无锁的算法也可以","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554079435,"ip_address":"","comment_id":81886,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5849046213","product_id":100023901,"comment_content":"可重入函数的线程安全是不是由函数内部的可重入锁保证的呢？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445380,"discussion_content":"用可重入锁可以实现，还有些无锁的算法也可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554079435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81622,"user_name":"alias cd=rm -rf","can_delete":false,"product_type":"c1","uid":1318325,"ip_address":"","ucode":"E7B27D76305B75","user_header":"https://static001.geekbang.org/account/avatar/00/14/1d/b5/971261fd.jpg","comment_is_top":false,"comment_ctime":1553966702,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5848933998","product_id":100023901,"comment_content":"不会死锁因为，打破了不释放的原则。","like_count":1},{"had_liked":false,"id":345811,"user_name":"学习学个屁","can_delete":false,"product_type":"c1","uid":1049017,"ip_address":"","ucode":"DF2D61E6FB2FCE","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","comment_is_top":false,"comment_ctime":1652607712,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652607712","product_id":100023901,"comment_content":"非公平锁不是按照谁等待的时间长去唤醒的吧。是按照顺序唤醒的。","like_count":0},{"had_liked":false,"id":345810,"user_name":"学习学个屁","can_delete":false,"product_type":"c1","uid":1049017,"ip_address":"","ucode":"DF2D61E6FB2FCE","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","comment_is_top":false,"comment_ctime":1652607663,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652607663","product_id":100023901,"comment_content":"不会引起死锁，但会一直死循环，也就是会产生活锁。<br>2次锁，2个lock对象都不一样，都会lock unlock，外面一直死循环，一直如此，不停的加锁，释放锁。","like_count":0},{"had_liked":false,"id":339169,"user_name":"🎓Dream-seeker","can_delete":false,"product_type":"c1","uid":2100403,"ip_address":"","ucode":"3C8477DE9DD766","user_header":"https://static001.geekbang.org/account/avatar/00/20/0c/b3/7e13920b.jpg","comment_is_top":false,"comment_ctime":1647954182,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647954182","product_id":100023901,"comment_content":"重点是这个if条件，两条线程都知道对方的锁被占用了，就去释放锁，结果是谁也拿不到锁一直循环往复 这属于活锁","like_count":0},{"had_liked":false,"id":330838,"user_name":"hunter","can_delete":false,"product_type":"c1","uid":1196266,"ip_address":"","ucode":"EFBF6071BFCE10","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ5ricEp2SDpA2d2iaw6TOVaPfmeicDicP34bamibX1JbHEkJl8wDQOK3ia4vic9WacKjFia9wibeG3nwOIiafA/132","comment_is_top":false,"comment_ctime":1642213329,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642213329","product_id":100023901,"comment_content":"入口等待队列和阻塞队列是什么关系","like_count":0},{"had_liked":false,"id":328776,"user_name":"hello","can_delete":false,"product_type":"c1","uid":1649057,"ip_address":"","ucode":"4F42DAA5DB5C38","user_header":"https://static001.geekbang.org/account/avatar/00/19/29/a1/41607383.jpg","comment_is_top":false,"comment_ctime":1640876263,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1640876263","product_id":100023901,"comment_content":"我在想一个问题，synchronized 和Lock 是不是都不能破坏“占有且等待” 和“循环等待”，它们只能用一次性申请资源和排序来解决死锁的问题。","like_count":0},{"had_liked":false,"id":315191,"user_name":"官宝儿","can_delete":false,"product_type":"c1","uid":2110827,"ip_address":"","ucode":"03B4312475A984","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI5eicXFWltiaF9ibsEh2nNC80OYoHibhhE0X1hPHZ5KuAtY4Yxp5dQ4LsciaDxUHFBPlJM7kgQwkspzsQ/132","comment_is_top":false,"comment_ctime":1633746501,"is_pvip":false,"replies":[{"id":"114499","content":"感觉这个是死循环","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1634123202,"ip_address":"","comment_id":315191,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1633746501","product_id":100023901,"comment_content":"俩个锁被俩个线程无限的各执一把导致俩个线程永远拿不到俩把锁，这种情况算死锁吗","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527897,"discussion_content":"感觉这个是死循环","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634123202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308027,"user_name":"Geek_059c01","can_delete":false,"product_type":"c1","uid":2617415,"ip_address":"","ucode":"DE2D22FD0270BA","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJvgMafguPrOkiagvnPDkNzakYkoauIKI43bBlmenhrjLOiaNF4ic0gHUHv5AYz2qGX4MxEGt8HPJHuw/132","comment_is_top":false,"comment_ctime":1629361961,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629361961","product_id":100023901,"comment_content":"会出现死锁，老师可不可以贴出标准的不出现死锁的使用Lock方案？","like_count":0},{"had_liked":false,"id":292860,"user_name":"gsz","can_delete":false,"product_type":"c1","uid":1147531,"ip_address":"","ucode":"8FD1B41E884B18","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/8b/5340fb27.jpg","comment_is_top":false,"comment_ctime":1621041331,"is_pvip":false,"replies":[{"id":"106777","content":"非公平锁性能好，但是个别线程等待时间有可能会很长。如果对实时性有要求，就需要用公平锁，公平锁+限流基本上就能保证处理的稳定性","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1621900876,"ip_address":"","comment_id":292860,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1621041331","product_id":100023901,"comment_content":"老师 什么情况下比较适合用公平锁，什么情况下比较适合用非公平锁","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519987,"discussion_content":"非公平锁性能好，但是个别线程等待时间有可能会很长。如果对实时性有要求，就需要用公平锁，公平锁+限流基本上就能保证处理的稳定性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621900876,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":289823,"user_name":"一路向北","can_delete":false,"product_type":"c1","uid":1370932,"ip_address":"","ucode":"B688B1C748D019","user_header":"https://static001.geekbang.org/account/avatar/00/14/eb/34/9756d116.jpg","comment_is_top":false,"comment_ctime":1619190159,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619190159","product_id":100023901,"comment_content":"代码执行内容：启动线程A：完成a给c转账，启动线程B完成b给c转账，线程A持有lockA,线程B持有lockB,AB线程抢夺lockC,谁抢到谁执行，死循环运行，不会终止<br><br><br>","like_count":0},{"had_liked":false,"id":288135,"user_name":"张滔","can_delete":false,"product_type":"c1","uid":1322636,"ip_address":"","ucode":"87ABAFF0E861E0","user_header":"https://static001.geekbang.org/account/avatar/00/14/2e/8c/b261e15a.jpg","comment_is_top":false,"comment_ctime":1618315863,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618315863","product_id":100023901,"comment_content":"volatile 变量规则：由于 state = 1 会先读取 state，所以线程 T1 的 unlock() 操作 Happens-Before 线程 T2 的 lock() 操作。这条规则没明白，不是说对一个 volatile 变量的写操作， Happens-Before 于后续对这个 volatile 变量的读操作吗？","like_count":0},{"had_liked":false,"id":285164,"user_name":"Laughing","can_delete":false,"product_type":"c1","uid":1002134,"ip_address":"","ucode":"F68F1E000CA800","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/96/99466a06.jpg","comment_is_top":false,"comment_ctime":1616651943,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616651943","product_id":100023901,"comment_content":"如果A、B两个账户互相转账的情况下，A、B两个账户都在尝试拿到对方账户的锁。可以考虑使用本节中提到的三个方案设计一把互斥锁，来解决这个问题。","like_count":0},{"had_liked":false,"id":284653,"user_name":"威先森","can_delete":false,"product_type":"c1","uid":1687656,"ip_address":"","ucode":"5F445C6832274B","user_header":"https://static001.geekbang.org/account/avatar/00/19/c0/68/314e8306.jpg","comment_is_top":false,"comment_ctime":1616403604,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616403604","product_id":100023901,"comment_content":"1. 顺序性规则：对于线程 T1，value+=1 Happens-Before 释放锁的操作 unlock()；<br>2. volatile 变量规则：由于 state = 1 会先读取 state，所以线程 T1 的 unlock() 操作 Happens-Before 线程 T2 的 lock() 操作；<br>3. 传递性规则：线程 T1 的 value+=1 Happens-Before 线程 T2 的 lock() 操作。<br>这个第二条写的稍微难理解了一点，有点像管程中锁的规则+volatile 变量规则的结合了","like_count":0},{"had_liked":false,"id":283838,"user_name":"黑山老妖","can_delete":false,"product_type":"c1","uid":1115958,"ip_address":"","ucode":"A1659F99C5BE1E","user_header":"https://static001.geekbang.org/account/avatar/00/11/07/36/d677e741.jpg","comment_is_top":false,"comment_ctime":1615951598,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615951598","product_id":100023901,"comment_content":"结果和活锁一样，不同的是，活锁没有堵塞，顾名思义，一直在运行，但是没有执行有效代码。<br>","like_count":0},{"had_liked":false,"id":283444,"user_name":"马以","can_delete":false,"product_type":"c1","uid":1344431,"ip_address":"","ucode":"3FEA06CA14DE28","user_header":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","comment_is_top":false,"comment_ctime":1615784977,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615784977","product_id":100023901,"comment_content":"两个账户互相为对方转账的时候会活锁！","like_count":0},{"had_liked":false,"id":281577,"user_name":"廖梓楷","can_delete":false,"product_type":"c1","uid":1433574,"ip_address":"","ucode":"5EB427453F8D22","user_header":"https://static001.geekbang.org/account/avatar/00/15/df/e6/d7638e29.jpg","comment_is_top":false,"comment_ctime":1614817025,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614817025","product_id":100023901,"comment_content":"如果账户A转账给账户B,账户B同时转账给账户A,则可能存在活锁。解决方案：tryLock加个随机等待时间，则能从概率上降低这种情况的发生","like_count":0},{"had_liked":false,"id":266249,"user_name":"Geek_e56b38","can_delete":false,"product_type":"c1","uid":2229257,"ip_address":"","ucode":"40625CF22A974C","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erRCf8vWbWibaiaKibNyTC3BMLWDIPK7xUlEy2oVBykrcSIjS5PP4xTDDZRYBicMfK44ia7uWV5cxugVHg/132","comment_is_top":false,"comment_ctime":1607255577,"is_pvip":false,"replies":[{"id":"96738","content":"������������","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1607297976,"ip_address":"","comment_id":266249,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1607255577","product_id":100023901,"comment_content":"我觉得特性里应该还可以加一条，Lock可以很好的支持生产者消费者模型，可以绑定多个条件阻塞队列，但是synchronized就很难做到这一点。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511189,"discussion_content":"������������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607297976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262567,"user_name":"茶没喝完","can_delete":false,"product_type":"c1","uid":1644104,"ip_address":"","ucode":"D72D88C42A1258","user_header":"https://static001.geekbang.org/account/avatar/00/19/16/48/09493874.jpg","comment_is_top":false,"comment_ctime":1605770621,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605770621","product_id":100023901,"comment_content":"不会死锁，获取不到第二把锁，会主动释放第一把已经获取到到锁，可能会出现活跃。","like_count":0},{"had_liked":false,"id":255466,"user_name":"halo","can_delete":false,"product_type":"c1","uid":1138057,"ip_address":"","ucode":"782892605CC855","user_header":"https://static001.geekbang.org/account/avatar/00/11/5d/89/93b837d6.jpg","comment_is_top":false,"comment_ctime":1603352004,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1603352004","product_id":100023901,"comment_content":"我在书上看过对  同步互斥  的描述，同步是目的，互斥是手段。同步是 同一时刻只有一个线程访问共享资源。   跟本节课中解释的有差异，各位看官觉得那种说法对？","like_count":0,"discussions":[{"author":{"id":1274495,"avatar":"https://static001.geekbang.org/account/avatar/00/13/72/7f/5da093c5.jpg","nickname":"水目沾","note":"","ucode":"FDD1D15C277D58","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364371,"discussion_content":"你这理解有点狭隘，同步是指两个线程之间的协同：任何互斥手段 如synchronized 、lock等都是为了相互协同，而不是为了互斥而互斥。你把同步换成协同，就好理解了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617459214,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":255413,"user_name":"李孟","can_delete":false,"product_type":"c1","uid":1006768,"ip_address":"","ucode":"AD2349CB12F130","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/b0/77e5f8c8.jpg","comment_is_top":false,"comment_ctime":1603338355,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1603338355","product_id":100023901,"comment_content":"@Data<br>public class Account {<br>   private int balance;<br>   private final Lock lock = new ReentrantLock();<br><br>    public Account(int balance) {<br>        this.balance = balance;<br>    }<br><br>    public void transfer(Account tar, int amt) throws InterruptedException {<br>        boolean flag = true;<br>        Random random = new Random();<br>        while (flag){<br>           if(this.lock.tryLock(random.nextInt(1000)+1, TimeUnit.MILLISECONDS)) {<br>               try {<br>               if (tar.lock.tryLock())<br>               {<br>                   try {<br>                       this.balance -= amt;<br>                       tar.balance += amt;<br>                       flag = false;<br>                   }<br>                   finally {<br>                       tar.lock.unlock();<br>                   }<br>               }&#47;&#47;if<br>               } finally {<br>                   this.lock.unlock();<br>               }<br>           }<br>       }<br>   }<br><br>    public static void main(String[] args) throws InterruptedException {<br><br>        for (int i = 0; i &lt; 10000; i++) {<br>            Account a = new Account(200);<br>            Account b = new Account(200);<br>            Account c = new Account(200);<br><br>            Thread t1 = new Thread(()-&gt;{<br>                try {<br>                    a.transfer(b,100);<br>                } catch (InterruptedException e) {<br>                    e.printStackTrace();<br>                }<br>            });<br><br><br><br>            Thread t2 = new Thread(()-&gt;{<br>                try {<br>                    b.transfer(c,100);<br>                } catch (InterruptedException e) {<br>                    e.printStackTrace();<br>                }<br>            });<br>            t1.start();<br>            t2.start();<br><br><br>            t2.join();<br><br>            System.out.println(a.getBalance());<br>            System.out.println(b.getBalance());<br>            System.out.println(c.getBalance());<br>            System.out.println(&quot;---------------&quot;);<br><br>        }<br><br>    }<br><br>}<br>","like_count":0},{"had_liked":false,"id":253092,"user_name":"xanxus","can_delete":false,"product_type":"c1","uid":1654600,"ip_address":"","ucode":"FFF1EFD2ABCBAA","user_header":"","comment_is_top":false,"comment_ctime":1602594802,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602594802","product_id":100023901,"comment_content":"由于 state = 1 会先读取 state，所以线程 T1 的 unlock() 操作 Happens-Before 线程 T2 的 lock() 操作；  happen-before 中的lock和unlock 是针对synchronize的锁吧，跟JUC中的没有关系吧","like_count":0},{"had_liked":false,"id":245575,"user_name":"罗樱罂","can_delete":false,"product_type":"c1","uid":2045997,"ip_address":"","ucode":"9072E79E625ED1","user_header":"https://static001.geekbang.org/account/avatar/00/1f/38/2d/f3c6493e.jpg","comment_is_top":false,"comment_ctime":1598986590,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598986590","product_id":100023901,"comment_content":"老师，我想问一下aqs的各种队列知识点在哪一章有介绍？（对不起跳着看的。。感觉找了许久。。。","like_count":0},{"had_liked":false,"id":243987,"user_name":"fightingD","can_delete":false,"product_type":"c1","uid":1443637,"ip_address":"","ucode":"AD2876CED5D5AC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKwViav94kcF50CxA0Jw7icicxociaVzut97iacy3b2ciacFqXuFWdiakVq304YcI8pt4HT5A1Yvp8EkYCpw/132","comment_is_top":false,"comment_ctime":1598345949,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598345949","product_id":100023901,"comment_content":"不会死锁，获取不到锁的时候返回false,会释放自己持有的锁。","like_count":0},{"had_liked":false,"id":243981,"user_name":"fightingD","can_delete":false,"product_type":"c1","uid":1443637,"ip_address":"","ucode":"AD2876CED5D5AC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKwViav94kcF50CxA0Jw7icicxociaVzut97iacy3b2ciacFqXuFWdiakVq304YcI8pt4HT5A1Yvp8EkYCpw/132","comment_is_top":false,"comment_ctime":1598344822,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598344822","product_id":100023901,"comment_content":"没有死锁的问题了，但是可能会有活锁的问题，最好使用tryLock(long time, TimeUnit unit) 方法，并给time 设置一个随机数。","like_count":0},{"had_liked":false,"id":238125,"user_name":"惘 闻","can_delete":false,"product_type":"c1","uid":1181650,"ip_address":"","ucode":"C5909F034BF072","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","comment_is_top":false,"comment_ctime":1596074749,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596074749","product_id":100023901,"comment_content":"感觉这个可重入锁没有什么意义啊","like_count":0},{"had_liked":false,"id":237822,"user_name":"惘 闻","can_delete":false,"product_type":"c1","uid":1181650,"ip_address":"","ucode":"C5909F034BF072","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","comment_is_top":false,"comment_ctime":1595983337,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"1595983337","product_id":100023901,"comment_content":"如果创建的是公平锁，这个锁创建的condition的条件等待队列是公平的吗？","like_count":0,"discussions":[{"author":{"id":1274495,"avatar":"https://static001.geekbang.org/account/avatar/00/13/72/7f/5da093c5.jpg","nickname":"水目沾","note":"","ucode":"FDD1D15C277D58","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364372,"discussion_content":"条件队列与同步队列你分得清不？公不公平是针对同步队列来说的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617459316,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1181650,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","nickname":"惘 闻","note":"","ucode":"C5909F034BF072","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1274495,"avatar":"https://static001.geekbang.org/account/avatar/00/13/72/7f/5da093c5.jpg","nickname":"水目沾","note":"","ucode":"FDD1D15C277D58","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364747,"discussion_content":"能详细讲一下吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617591496,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":364372,"ip_address":""},"score":364747,"extra":""},{"author":{"id":1274495,"avatar":"https://static001.geekbang.org/account/avatar/00/13/72/7f/5da093c5.jpg","nickname":"水目沾","note":"","ucode":"FDD1D15C277D58","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1181650,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","nickname":"惘 闻","note":"","ucode":"C5909F034BF072","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364795,"discussion_content":"条件等待队列都是公平的呀，被阻塞的都放到条件队列后面","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617609108,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":364747,"ip_address":""},"score":364795,"extra":""},{"author":{"id":1181650,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","nickname":"惘 闻","note":"","ucode":"C5909F034BF072","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1274495,"avatar":"https://static001.geekbang.org/account/avatar/00/13/72/7f/5da093c5.jpg","nickname":"水目沾","note":"","ucode":"FDD1D15C277D58","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365189,"discussion_content":"知道了，多谢。Lock的本质是AQS，AQS自己维护的队列是当前等待资源的队列，AQS会在资源被释放后，依次唤醒队列中从前到后的所有节点，使他们对应的线程恢复执行，直到队列为空。而Condition自己也维护了一个队列，该队列的作用是维护一个等待signal信号的队列。但是，两个队列的作用不同的，事实上，每个线程也仅仅会同时存在以上两个队列中的一个。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617722253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":364795,"ip_address":""},"score":365189,"extra":""}]}]},{"had_liked":false,"id":235865,"user_name":"non","can_delete":false,"product_type":"c1","uid":1306912,"ip_address":"","ucode":"F765CC7DDDC7F4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJoOia8n2xdlII9AEfK3Zh3k3wlh6HTemyxZ4Z5DicxYITk8YgYEGM8K1xOt2Puic9xoGCQev7JOZ7bA/132","comment_is_top":false,"comment_ctime":1595229425,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595229425","product_id":100023901,"comment_content":"因为题中的trylock不会占有锁后等待，破坏了占有等待的条件因此不会出现死锁，但可能会出现两个账户同时获取到自己的lock之后获取不到对方账户的lock而产生活锁","like_count":0},{"had_liked":false,"id":235347,"user_name":"第一装甲集群司令克莱斯特","can_delete":false,"product_type":"c1","uid":1265707,"ip_address":"","ucode":"4E8FBB23AD860B","user_header":"https://static001.geekbang.org/account/avatar/00/13/50/2b/2344cdaa.jpg","comment_is_top":false,"comment_ctime":1594979120,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594979120","product_id":100023901,"comment_content":"可重入锁，又叫递归锁。说白了，就是线程获取锁，执行外层函数，外层函数内调用其他函数，这时候，线程不会阻塞，可以直接进入内层函数，不阻塞，递归重入。","like_count":0},{"had_liked":false,"id":224516,"user_name":"Just","can_delete":false,"product_type":"c1","uid":2022626,"ip_address":"","ucode":"35FA6917DE1D04","user_header":"https://static001.geekbang.org/account/avatar/00/1e/dc/e2/a3abd320.jpg","comment_is_top":false,"comment_ctime":1591427011,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591427011","product_id":100023901,"comment_content":"持有的锁会自动释放所以不存在死锁，但是如果同时获取锁，同时释放锁就存在活锁，可以加个随机时间来避免","like_count":0},{"had_liked":false,"id":222010,"user_name":"发哥","can_delete":false,"product_type":"c1","uid":1281495,"ip_address":"","ucode":"E2BA6621422D08","user_header":"https://static001.geekbang.org/account/avatar/00/13/8d/d7/eeceb2d5.jpg","comment_is_top":false,"comment_ctime":1590655475,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590655475","product_id":100023901,"comment_content":"老师好，我有个问题，如果阻塞在tar.lock.tryLock上一段时间，应该是不能释放tar.lock吧？","like_count":0},{"had_liked":false,"id":217367,"user_name":"UniqueDirt","can_delete":false,"product_type":"c1","uid":2001375,"ip_address":"","ucode":"1E5555EE495733","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJkDobVTaXD0oWouJBHQQSvnicJnzfZ7cSKmZeV20svZ7uWKGkibnL8xXiaOPRPYP7IibVIWPaCBDhjMw/132","comment_is_top":false,"comment_ctime":1589470569,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589470569","product_id":100023901,"comment_content":"会存在活锁  但T1进入finally释放锁的同时T2有可能刚好获取到T1释放的锁  所以转账操作有几率成功的","like_count":0},{"had_liked":false,"id":216877,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1589360470,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589360470","product_id":100023901,"comment_content":"老师，关于可重入锁有个疑问，既然synchronized也是可以重复获取同一把锁的，是我理解的有问题么？请老师指教<br><br>public class ReentrantLockDemo {<br><br><br>    private static int v = 0;<br><br>    @Test<br>    public void test() {<br>        addOne();<br>        try {<br>            Thread.sleep(1000);<br>        } catch (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br>        System.out.println(&quot;v的值为：&quot; + this.v);<br>    }<br><br>    private synchronized void addOne() {<br>        this.v = get() + 1;<br>    }<br><br>    private synchronized int get() {<br>        return v;<br>    }<br><br><br>}<br><br>执行结果也是1，我用多个线程调addOne()方法也没有阻塞，结果也是正确的","like_count":0},{"had_liked":false,"id":212560,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1588149056,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588149056","product_id":100023901,"comment_content":"老师，对思考题有个疑问，这是个转账业务，用sy解决并发时就没有用while (true)  ，为什么用lock解决并发时要用while (true) 呢？这个例子可以把while (true) 去掉么？","like_count":0},{"had_liked":false,"id":210794,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1587826016,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587826016","product_id":100023901,"comment_content":"线程ab同时执行，同时获取对方的锁，又同时获取不到，又同时释放，如此往返，形成死锁","like_count":0},{"had_liked":false,"id":208320,"user_name":"刘耳总","can_delete":false,"product_type":"c1","uid":1271724,"ip_address":"","ucode":"6D157E6E960075","user_header":"https://static001.geekbang.org/account/avatar/00/13/67/ac/af895343.jpg","comment_is_top":false,"comment_ctime":1587339808,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587339808","product_id":100023901,"comment_content":"可重入锁指的是在一个线程中可以多次获取同一把锁，比如：<br>一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法，而无需重新获得锁；<br><br>可重入锁是针对同一线程啊，差点懵逼了","like_count":0},{"had_liked":false,"id":192523,"user_name":"雷刚","can_delete":false,"product_type":"c1","uid":1655725,"ip_address":"","ucode":"115FE2BE1AAB61","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/pTD8nS0SsORKiaRD3wB0NK9Bpd0wFnPWtYLPfBRBhvZ68iaJErMlM2NNSeEibwQfY7GReILSIYZXfT9o8iaicibcyw3g/132","comment_is_top":false,"comment_ctime":1584857100,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584857100","product_id":100023901,"comment_content":"关于 synchronized 锁升级，我还是有点疑问。synchronized 可以从无锁 -&gt; 偏向锁 -&gt; 轻量级锁  -&gt; 重量级锁，但锁只能升级不能降级。现在我们开发一般都使用 Spring IoC，基本上都是单例，这样系统运行时间长后，可能 synchronized 锁大部分都会升级成重量级锁，感觉 synchronized 锁升级好像在这种场景不是太实用。不知道会不会有这种问题？","like_count":0},{"had_liked":false,"id":191869,"user_name":"zhangchao","can_delete":false,"product_type":"c1","uid":1508339,"ip_address":"","ucode":"E665D153A85DE0","user_header":"https://static001.geekbang.org/account/avatar/00/17/03/f3/0bd094ad.jpg","comment_is_top":false,"comment_ctime":1584801623,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584801623","product_id":100023901,"comment_content":"看来要学习下AQS了","like_count":0},{"had_liked":false,"id":191850,"user_name":"zhangchao","can_delete":false,"product_type":"c1","uid":1508339,"ip_address":"","ucode":"E665D153A85DE0","user_header":"https://static001.geekbang.org/account/avatar/00/17/03/f3/0bd094ad.jpg","comment_is_top":false,"comment_ctime":1584800068,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584800068","product_id":100023901,"comment_content":"思考题可能出现活锁","like_count":0},{"had_liked":false,"id":184792,"user_name":"Airsaid","can_delete":false,"product_type":"c1","uid":1115302,"ip_address":"","ucode":"5B90BC0044F376","user_header":"https://static001.geekbang.org/account/avatar/00/11/04/a6/18c4f73c.jpg","comment_is_top":false,"comment_ctime":1583404530,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583404530","product_id":100023901,"comment_content":"写了一段代码验证了下 ReentrantLock 的可见性，发现在 lock() 和 unlock() 外操作共享变量果然会导致变量不准确（刚开始没加动态的判断，发现依然一致，于是猜测可能是优化导致，加上动态的判断后重新尝试，发现在内在外的结果果然不一样）：<br><br>class ReentrantLockExample {<br>  private val lock = ReentrantLock()<br>  private var value = 0<br>  private var unsafeValue = 0<br><br>  fun get(): IntArray {<br>    lock.lock()<br>    try {<br>      return intArrayOf(value, unsafeValue)<br>    } finally {<br>      lock.unlock()<br>    }<br>  }<br><br>  fun addOne() {<br>    lock.lock()<br>    try {<br>      value++<br>    } finally {<br>      lock.unlock()<br>    }<br>    &#47;&#47; 增加永远为 true 的动态判断，避免编译器优化<br>    if (System.currentTimeMillis() &gt; Random.nextInt(100))<br>      unsafeValue++<br>  }<br>}<br><br>fun main() {<br>  val threadPool = Executors.newFixedThreadPool(10)<br>  val latch = CountDownLatch(1)<br><br>  val example = ReentrantLockExample()<br><br>  &#47;&#47; 开启多个线程同时对数据写入，然后执行完毕后看最终效果<br>  repeat(10000) {<br>    threadPool.submit {<br>      latch.await()<br>      example.addOne()<br>      println(&quot;${Thread.currentThread().name}-value: ${Arrays.toString(example.get())}&quot;)<br>    }<br>  }<br><br>  latch.countDown()<br>  threadPool.shutdown()<br>}","like_count":0},{"had_liked":false,"id":182267,"user_name":"Asha","can_delete":false,"product_type":"c1","uid":1796527,"ip_address":"","ucode":"69F227707A9EDD","user_header":"https://static001.geekbang.org/account/avatar/00/1b/69/af/ceb4450c.jpg","comment_is_top":false,"comment_ctime":1582753260,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1582753260","product_id":100023901,"comment_content":"老师 你好 我想问下破坏不可抢占锁是为了使得之前已经获得的锁释放，我不明白为什么 synchronize不能解决 我理解之前讲的wait操作就是把之前获取的资源给释放了，麻烦老师指正我理解哪里错了","like_count":0,"discussions":[{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380530,"discussion_content":"原因是 synchronized 申请资源的时候，如果申请不到，线程直接进入阻塞状态了，而线程进入阻塞状态，啥都干不了，也释放不了线程已经占有的资源","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624546553,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175802,"user_name":"旅途","can_delete":false,"product_type":"c1","uid":1212902,"ip_address":"","ucode":"5022477E8E9441","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/e6/6cafed37.jpg","comment_is_top":false,"comment_ctime":1580829016,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580829016","product_id":100023901,"comment_content":"思考题还真是活锁 如果把tryLock()改为lock()就变为活锁了","like_count":0},{"had_liked":false,"id":158086,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1575330629,"is_pvip":false,"replies":[{"id":"65379","content":"jdk里没有的就去jvm里看看，我已经看不动了😂","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1578133794,"ip_address":"","comment_id":158086,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1575330629","product_id":100023901,"comment_content":"老师，unsafe类是个什么呢？看着老师说的很简单，感觉还是有点懵逼，于是就看了lock里到底是个什么。里面最终看到就是一个unsafe.<br> return unsafe.compareAndSwapObject(this, headOffset, null, update);","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476625,"discussion_content":"jdk里没有的就去jvm里看看，我已经看不动了😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578133794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1274495,"avatar":"https://static001.geekbang.org/account/avatar/00/13/72/7f/5da093c5.jpg","nickname":"水目沾","note":"","ucode":"FDD1D15C277D58","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364379,"discussion_content":"unsafe 是个本地方法类，都是用 C++ 实现的直接与操作系统打交道的一些方法，可以理解成对地城方法的一些封装，不用关心里面。知道每个方法的作用接口，比如你举得例子：unsafe.compareAndSwapObject 就是 CAS 啊，因为 CAS 最终是要通过操作系统去实现的，还有很多类似的事情JAVA 语言层面又做不到，所以需要 unsafe。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617460303,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1212902,"avatar":"https://static001.geekbang.org/account/avatar/00/12/81/e6/6cafed37.jpg","nickname":"旅途","note":"","ucode":"5022477E8E9441","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":160795,"discussion_content":"看这个方法是使用的cas","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580828053,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147435,"user_name":"Joker","can_delete":false,"product_type":"c1","uid":1156592,"ip_address":"","ucode":"126AF848001A1E","user_header":"https://static001.geekbang.org/account/avatar/00/11/a5/f0/8648c464.jpg","comment_is_top":false,"comment_ctime":1572863779,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572863779","product_id":100023901,"comment_content":"是 AbstractQueuedSynchronizer 这个里面的 state 这个成员属性吧","like_count":0},{"had_liked":false,"id":144560,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1571968647,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571968647","product_id":100023901,"comment_content":"我知道了上一章的这个总结：<br>在 Java 语言里面，Happens-Before 的语义本质上是一种可见性，A Happens-Before B 意味着 A 事件对 B 事件来说是可见的，无论 A 事件和 B 事件是否发生在同一个线程里。<br><br>例如 A 事件发生在线程 1 上，B 事件发生在线程 2 上，Happens-Before 规则保证线程 2 上也能看到 A 事件的发生。<br><br>我感觉这种规则估计是在编译环境的优化。。。","like_count":0},{"had_liked":false,"id":144556,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1571968379,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571968379","product_id":100023901,"comment_content":"请教老师和其他同学一个问题：<br><br>- **顺序性规则**：对于线程 T1，value+=1 Happens-Before 释放锁的操作 unlock()；<br>- **volatile 变量规则**：由于 state = 1 会先读取 state，所以线程 T1 的 unlock() 操作 Happens-Before 线程 T2 的 lock() 操作；<br>- **传递性规则**：线程 T1 的 value+=1  Happens-Before 线程 T2 的 lock() 操作。<br><br>顺序性规则是在线程内部的，是不是可以这样理解：<br><br>a = 5；&#47;&#47; 普通<br><br>b = 5; &#47;&#47; volatile 修饰<br><br>一旦修改了 volatile 变量 b 的话，那么他前面的修改的结果（a = 5）也会刷新到主存中？？？<br><br>顺序性只是线程内部的，而传递性跨越了两个线程，感觉不对吧，是我哪里理解错了吗？？","like_count":0},{"had_liked":false,"id":141392,"user_name":"陌臣","can_delete":false,"product_type":"c1","uid":1643898,"ip_address":"","ucode":"EC1B2DA7483F11","user_header":"https://static001.geekbang.org/account/avatar/00/19/15/7a/db9879e1.jpg","comment_is_top":false,"comment_ctime":1571147385,"is_pvip":false,"replies":[{"id":"54749","content":"看13章","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1571227673,"ip_address":"","comment_id":141392,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571147385","product_id":100023901,"comment_content":"有个小问题不解，老师在介绍可重入锁例子时用final修饰，private final Lock rtl = = new ReentrantLock(); 是为了保证变量rtl不会被修改吗？如果是，为什么呢？如果不是，是有其他意义吗？求解答","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470743,"discussion_content":"看13章","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571227673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140910,"user_name":"245864982","can_delete":false,"product_type":"c1","uid":1238485,"ip_address":"","ucode":"AC47075A95B759","user_header":"https://static001.geekbang.org/account/avatar/00/12/e5/d5/680402fd.jpg","comment_is_top":false,"comment_ctime":1571075138,"is_pvip":false,"replies":[{"id":"54611","content":"如果a(),b()都是同步方法，c()也是同步方法且内部需要调用a,b，这时候就需要可重入锁。理论上有非公平锁一直不被唤醒的可能。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1571142748,"ip_address":"","comment_id":140910,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1571075138","product_id":100023901,"comment_content":"老师，对于可重入锁，不理解这样设计有什么用途的。两个方法用两把锁不就可以了吗？为什么要设计成可重入的。还有公平锁是等待时间长的先进唤醒谁，那么非公平锁呢？是随机吗？非公平锁会导致有的线程一直不被唤醒吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470620,"discussion_content":"如果a(),b()都是同步方法，c()也是同步方法且内部需要调用a,b，这时候就需要可重入锁。理论上有非公平锁一直不被唤醒的可能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571142748,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1274495,"avatar":"https://static001.geekbang.org/account/avatar/00/13/72/7f/5da093c5.jpg","nickname":"水目沾","note":"","ucode":"FDD1D15C277D58","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364384,"discussion_content":"对于你第一个问题，我觉得重入这个词有点糊弄人了，。我给你举个例子，你一下就明白了：\nprivate void synchronized recursion(int n) {\n  n--;\n  recursion(n);\n};\n这个递归方法，你来说说如果 synchronized 不支持重入，这方法还能执行吗？\n所谓的重入是为了防止自己和自己争抢锁。\n\n第二个问题：在讨论公平与非公平的时候，你把目光放在了队列上（很多人都这样），其实公不公平很好理解的理解的，我举个例子，你要去食堂打饭，很多人在排队。\n公平锁：你看到有队伍，直接站在队列后面。按顺序依次给你们打饭，这不就很公平吗？\n非公平锁：你直接冲上去插到第一排让阿姨给你打饭，阿姨也给你打，这就是不公平了啊。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617461039,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134947,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1568960630,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1568960630","product_id":100023901,"comment_content":"不会产生死锁，但是会有活锁，代码里有个奇怪的问题，转账执行成功直接退出循环就可以结束了。<br>Java AQS的state和等待队列之前看过，现在才知道原来是管程的思想，受教了。","like_count":0},{"had_liked":false,"id":133567,"user_name":"Wangxi","can_delete":false,"product_type":"c1","uid":1211790,"ip_address":"","ucode":"C25A9A14179930","user_header":"https://static001.geekbang.org/account/avatar/00/12/7d/8e/bb16d414.jpg","comment_is_top":false,"comment_ctime":1568609650,"is_pvip":true,"replies":[{"id":"51312","content":"并发编程的艺术里讲的很好，感兴趣的可以去看看，这个专栏主要还是入门和使用","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1568633242,"ip_address":"","comment_id":133567,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1568609650","product_id":100023901,"comment_content":"建议老师加上aqs的讲解，juc包的基础，理解了这个，对juc理解会更深","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467429,"discussion_content":"并发编程的艺术里讲的很好，感兴趣的可以去看看，这个专栏主要还是入门和使用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568633242,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1108159,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e8/bf/39042a46.jpg","nickname":"牙医","note":"","ucode":"27791DFF11EF45","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":242281,"discussion_content":"CAS+park/unpark?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587474014,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126773,"user_name":"冉野","can_delete":false,"product_type":"c1","uid":1137353,"ip_address":"","ucode":"2CAEA424996876","user_header":"https://static001.geekbang.org/account/avatar/00/11/5a/c9/933ee0a8.jpg","comment_is_top":false,"comment_ctime":1566470514,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566470514","product_id":100023901,"comment_content":"如果换成synchronized来锁住对象，出现的就是死锁了吧，如果是这样的话，老师 我有个地方不太明白，是因为tryLock支持尝试获取锁而非一直阻塞而不会导致死锁吗？<br>","like_count":0},{"had_liked":false,"id":126614,"user_name":"逆流的鱼","can_delete":false,"product_type":"c1","uid":1258399,"ip_address":"","ucode":"AA3DDE44A83C40","user_header":"https://static001.geekbang.org/account/avatar/00/13/33/9f/8dbd9558.jpg","comment_is_top":false,"comment_ctime":1566436425,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566436425","product_id":100023901,"comment_content":"回顾死锁条件：<br>1.资源互斥2.占用且等待3.不可抢占4.循环等待<br>个人认为，能响应中断属于3，支持超时和非阻塞的获取锁属于2","like_count":0},{"had_liked":false,"id":126361,"user_name":"日拱一兵","can_delete":false,"product_type":"c1","uid":1437158,"ip_address":"","ucode":"D6386E5CD7C061","user_header":"https://static001.geekbang.org/account/avatar/00/15/ed/e6/75a32708.jpg","comment_is_top":false,"comment_ctime":1566371630,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566371630","product_id":100023901,"comment_content":"A,B 两个账户互转不会有问题吗？","like_count":0},{"had_liked":false,"id":126341,"user_name":"文","can_delete":false,"product_type":"c1","uid":1090847,"ip_address":"","ucode":"E2DBA62248052E","user_header":"https://static001.geekbang.org/account/avatar/00/10/a5/1f/d2f6a1f7.jpg","comment_is_top":false,"comment_ctime":1566367891,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566367891","product_id":100023901,"comment_content":"老师我记得lock里面结点加入队列后会调用LockSupport.park，非可中断加锁里的代码","like_count":0},{"had_liked":false,"id":117177,"user_name":"赵小洛","can_delete":false,"product_type":"c1","uid":1592232,"ip_address":"","ucode":"A326C12B1A1ABA","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/a8/14b8a860.jpg","comment_is_top":false,"comment_ctime":1563982315,"is_pvip":false,"replies":[{"id":"42967","content":"类似错峰出行","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1564027594,"ip_address":"","comment_id":117177,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563982315","product_id":100023901,"comment_content":"老师 为什么加上随机等待就能解决活锁的情况。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459848,"discussion_content":"类似错峰出行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564027594,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":116932,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1563941102,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563941102","product_id":100023901,"comment_content":"---总结---<br>1. Lock出现的一个原因：避免死锁，破坏不可抢占条件，其支持中断响应、超时设置、非阻塞地获取锁<br>2. Lock对于可见性的保证：通过加锁和解锁时设置voliate的state变量，利用Happens-before原则<br>3. Lock支持的属性：可重入锁、公平锁与非公平锁、读写锁<br>4. 锁的最佳实践：只在访问或更新当前对象的成员变量时加锁","like_count":0},{"had_liked":false,"id":113946,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1563192029,"is_pvip":false,"replies":[{"id":"41577","content":"需要自己根据实际场景实现，最后的例子认真体会一下吧","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1563235236,"ip_address":"","comment_id":113946,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563192029","product_id":100023901,"comment_content":"老师我想问下lock获取不到锁主动释放资源在哪里体现呢，是底层已经写好了么","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458449,"discussion_content":"需要自己根据实际场景实现，最后的例子认真体会一下吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563235236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":113472,"user_name":"齐","can_delete":false,"product_type":"c1","uid":1486566,"ip_address":"","ucode":"378B273955095D","user_header":"https://static001.geekbang.org/account/avatar/00/16/ae/e6/58f30bb3.jpg","comment_is_top":false,"comment_ctime":1563024998,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1563024998","product_id":100023901,"comment_content":"可能会出现死循环去获取锁，即活锁问题","like_count":0},{"had_liked":false,"id":108542,"user_name":"ken","can_delete":false,"product_type":"c1","uid":1206552,"ip_address":"","ucode":"436DB0F6909E67","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep5kj3SLkkQQEVzETBHokoOKYdOtlOGXd8Qk8LXv8QNDhbiazHMCj057eicKtFmFk07UnzLian81jrGA/132","comment_is_top":false,"comment_ctime":1561797103,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561797103","product_id":100023901,"comment_content":"前面老师讲过处于waiting blocked状态的线程，如果被别的线程调用其interrupt方法，就会在被调用线程触发中断异常，那持有synchronized的锁被阻塞的线程也会收到，不就满足了条件一，可以被中断即有机会释放持有的锁资源了吗？","like_count":0},{"had_liked":false,"id":104898,"user_name":"小小逗比","can_delete":false,"product_type":"c1","uid":1327840,"ip_address":"","ucode":"883DA37098FD6D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/1JqTt1GcfIzsRFejCKibrHXejcFvhp86mo2lOnqpWEXCgxibnXiaibKOYNoItR58Uyn3q0hDsCFjr3BAX0r60vgydQ/132","comment_is_top":false,"comment_ctime":1560866230,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560866230","product_id":100023901,"comment_content":"this.lock 和 tar.lock 是两个锁, 线程获取this锁后,继续获取tar锁,执行操作,然后释放tar锁 ,再释放this锁,当前循环的代码执行结束, 继续下一次循环, 因为两个锁都已经释放,所以会无限循环下去","like_count":0},{"had_liked":false,"id":104663,"user_name":"晴天听夜曲","can_delete":false,"product_type":"c1","uid":1245813,"ip_address":"","ucode":"D0099EC299A18C","user_header":"https://static001.geekbang.org/account/avatar/00/13/02/75/96a111c1.jpg","comment_is_top":false,"comment_ctime":1560816278,"is_pvip":false,"replies":[{"id":"38256","content":"可以参与一些开源的项目","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1561076985,"ip_address":"","comment_id":104663,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560816278","product_id":100023901,"comment_content":"老师，光看理论我觉得印象不是很深刻？需要配合一些练习题什么的么？有什么好的推荐。。目前公司几乎不怎么写多线程场景的代码。。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454365,"discussion_content":"可以参与一些开源的项目","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561076985,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":100244,"user_name":"JGOS","can_delete":false,"product_type":"c1","uid":1237592,"ip_address":"","ucode":"46A905A169408F","user_header":"https://static001.geekbang.org/account/avatar/00/12/e2/58/2468a5e9.jpg","comment_is_top":false,"comment_ctime":1559497530,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559497530","product_id":100023901,"comment_content":"老师 如果线程t2 , 不加锁直接读value,是不是会读到旧数据?","like_count":0},{"had_liked":false,"id":99359,"user_name":"假装自己不胖","can_delete":false,"product_type":"c1","uid":1412994,"ip_address":"","ucode":"308F1BAA96CDA5","user_header":"https://static001.geekbang.org/account/avatar/00/15/8f/82/374f43a1.jpg","comment_is_top":false,"comment_ctime":1559199298,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559199298","product_id":100023901,"comment_content":"  if(this.lock.tryLock()) {<br>                try {<br>                    this.balance -= amt;<br>                    if (tar.lock.tryLock()) {<br>                        try {<br>                            tar.balance += amt;<br>                        } finally {<br>                            tar.lock.unlock();<br>                        }<br>                    }&#47;&#47;if<br>                } finally {<br>                    this.lock.unlock();<br>                }<br>            }&#47;&#47;if<br><br><br>要是这样呢","like_count":0},{"had_liked":false,"id":95852,"user_name":"Hour","can_delete":false,"product_type":"c1","uid":1448748,"ip_address":"","ucode":"AA1045ACABC0BB","user_header":"https://static001.geekbang.org/account/avatar/00/16/1b/2c/6b3c0911.jpg","comment_is_top":false,"comment_ctime":1558231190,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1558231190","product_id":100023901,"comment_content":"老师好，对于可重入锁有个疑问，执行addOne 函数时得到可重入锁后直接可进入get 函数，可在get函数finally中又把锁给释放掉了，那再回到addOne 函数中时还会持有锁吗？为什么？","like_count":0,"discussions":[{"author":{"id":1439904,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f8/a0/0512ab62.jpg","nickname":"大川","note":"","ucode":"23D37AE82F8767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":744,"discussion_content":"https://www.cnblogs.com/dj3839/p/6580765.html 这里面有个例子  你看看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562033127,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93900,"user_name":"苍茫大地","can_delete":false,"product_type":"c1","uid":1010515,"ip_address":"","ucode":"7EA9DF22931ABB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/53/a102d6a5.jpg","comment_is_top":false,"comment_ctime":1557656880,"is_pvip":false,"replies":[{"id":"34435","content":"我感觉不一定吧","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558358319,"ip_address":"","comment_id":93900,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557656880","product_id":100023901,"comment_content":"在获取第一把锁时设置超时时间，成功获取到第一把锁后，循环获取第二把锁，没有超时时间，这样是不是性能最好？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449821,"discussion_content":"我感觉不一定吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558358319,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92816,"user_name":"Barry","can_delete":false,"product_type":"c1","uid":1191473,"ip_address":"","ucode":"454C22BB075D56","user_header":"https://static001.geekbang.org/account/avatar/00/12/2e/31/1fd134eb.jpg","comment_is_top":false,"comment_ctime":1557330054,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557330054","product_id":100023901,"comment_content":"可重入锁的使用场景具体有哪些？","like_count":0},{"had_liked":false,"id":87903,"user_name":"Cancer","can_delete":false,"product_type":"c1","uid":1128051,"ip_address":"","ucode":"DF44879B27760C","user_header":"https://static001.geekbang.org/account/avatar/00/11/36/73/3a652c41.jpg","comment_is_top":false,"comment_ctime":1555747647,"is_pvip":false,"replies":[{"id":"31711","content":"sleep放回合结束前会更好，没必要每次都sleep<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555894357,"ip_address":"","comment_id":87903,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555747647","product_id":100023901,"comment_content":"\t&#47;&#47; 转账<br>\tvoid transfer(Account tar, int amt) {<br>\t\tboolean success = false;<br>\t\tThread th = Thread.currentThread();<br>\t\twhile (!th.isInterrupted() &amp;&amp; !success) {<br>\t\t\tif (this.lock.tryLock()) {&#47;&#47;①<br>\t\t\t\ttry {<br>\t\t\t\t\ttry {<br>\t\t\t\t\t\tThread.sleep(new Random().nextInt(10));&#47;&#47;随机睡眠，打个时间差，解决活锁<br>\t\t\t\t\t} catch (InterruptedException e) {<br>\t\t\t\t\t\tThread.currentThread().interrupt();<br>\t\t\t\t\t}<br>\t\t\t\t\tif (tar.lock.tryLock()) {&#47;&#47;②<br>\t\t\t\t\t\ttry {<br>\t\t\t\t\t\t\tthis.balance -= amt;<br>\t\t\t\t\t\t\ttar.balance += amt;<br>\t\t\t\t\t\t\tsuccess = true;<br>\t\t\t\t\t\t} finally {<br>\t\t\t\t\t\t\ttar.lock.unlock();<br>\t\t\t\t\t\t}<br>\t\t\t\t\t}<br>\t\t\t\t} finally {<br>\t\t\t\t\tthis.lock.unlock();<br>\t\t\t\t}<br>\t\t\t}<br>\t\t}<br>\t}<br>老师，是不是，这样就可以解决活锁问题了呢？刚刚看到这一节，麻烦老师有空回复下，谢谢","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447640,"discussion_content":"sleep放回合结束前会更好，没必要每次都sleep\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555894357,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84749,"user_name":"speedy9","can_delete":false,"product_type":"c1","uid":1196256,"ip_address":"","ucode":"558A338D54626E","user_header":"https://static001.geekbang.org/account/avatar/00/12/40/e0/2f1816a8.jpg","comment_is_top":false,"comment_ctime":1554902159,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554902159","product_id":100023901,"comment_content":"关于思考题，java的访问作用域修饰符，都是修饰在类上，不在实例上，因此可以互相访问private成员。","like_count":0},{"had_liked":false,"id":83598,"user_name":"Sunqc","can_delete":false,"product_type":"c1","uid":1473717,"ip_address":"","ucode":"2C54659635403F","user_header":"https://static001.geekbang.org/account/avatar/00/16/7c/b5/4a7a2bd4.jpg","comment_is_top":false,"comment_ctime":1554682775,"is_pvip":false,"replies":[{"id":"30263","content":"有可能","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554702679,"ip_address":"","comment_id":83598,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554682775","product_id":100023901,"comment_content":"老师，是不是可能不断获取多锁，又有可能发生转账成功","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446088,"discussion_content":"有可能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554702679,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82740,"user_name":"果然如此","can_delete":false,"product_type":"c1","uid":1210003,"ip_address":"","ucode":"C7543BD0A67505","user_header":"https://static001.geekbang.org/account/avatar/00/12/76/93/c78a132a.jpg","comment_is_top":false,"comment_ctime":1554292827,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554292827","product_id":100023901,"comment_content":"活锁还是比死锁容易解决，加个随机等待时间或客户端手动重试！","like_count":0},{"had_liked":false,"id":82596,"user_name":"aguan(^･ｪ･^)","can_delete":false,"product_type":"c1","uid":1107177,"ip_address":"","ucode":"04833EF2D18E1A","user_header":"https://static001.geekbang.org/account/avatar/00/10/e4/e9/0dd3829f.jpg","comment_is_top":false,"comment_ctime":1554256111,"is_pvip":false,"replies":[{"id":"29896","content":"先读也没关系，重要的是写完后，其他线程能看到<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554293214,"ip_address":"","comment_id":82596,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554256111","product_id":100023901,"comment_content":"老师，对于可见性的例子有个疑问<br>为啥T1的unlock就先于T2的lock呢？state=0不是也要先读吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445654,"discussion_content":"先读也没关系，重要的是写完后，其他线程能看到\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554293214,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81833,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1554046376,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1554046376","product_id":100023901,"comment_content":"tar.lock tar.balence  Acount的这两个属性不是private的吗？还是我理解有误啊","like_count":0},{"had_liked":false,"id":81644,"user_name":"老杨同志","can_delete":false,"product_type":"c1","uid":1246199,"ip_address":"","ucode":"3F334F0CFD3DE6","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/f7/3a493bec.jpg","comment_is_top":false,"comment_ctime":1553995499,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553995499","product_id":100023901,"comment_content":"看了其它他人的留言，确认会发生活锁。改进方案1）对两个账户排序，按顺序加锁。2）拿到第一把锁，拿第二把锁失败，根据两个账户的比较结果选择性释放还是持有","like_count":0},{"had_liked":false,"id":81582,"user_name":"senekis","can_delete":false,"product_type":"c1","uid":1446025,"ip_address":"","ucode":"CD88681F0278FD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erTlRJ6skf7iawAeqNfIT1PPgjD7swUdRIRkX1iczjj97GNrxnsnn3QuOhkVbCLgFYAm7sMZficNTSbA/132","comment_is_top":false,"comment_ctime":1553952948,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1553952948","product_id":100023901,"comment_content":"谢谢老师推荐《Java并发编程: 设计原则与模式》这本书啊，上网查了一下，已经绝版了，怪不得以前上亚马逊搜索时都没有搜到过，要不是老师推荐，就要错过大神写的这部经典了！","like_count":0},{"had_liked":false,"id":81558,"user_name":"董尚斌","can_delete":false,"product_type":"c1","uid":1195545,"ip_address":"","ucode":"9582217F65C1C7","user_header":"https://static001.geekbang.org/account/avatar/00/12/3e/19/873abe8a.jpg","comment_is_top":false,"comment_ctime":1553945072,"is_pvip":false,"replies":[{"id":"29574","content":"不会死锁但是有活锁<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553998757,"ip_address":"","comment_id":81558,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553945072","product_id":100023901,"comment_content":"不会产生死锁，因为是重入锁，所以第二次也能获取得到，最里面的释放了锁，导致锁释放了。<br>---等等<br>如果这样的话，那么最外层的锁岂不是有线程安全的问题，理论上，但是理论上，这个问题相当于，我本地锁了，调用另外一个方法，结果他和我获取的是同一个锁。<br>写法没错。<br>我还是认为不会死锁。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445252,"discussion_content":"不会死锁但是有活锁\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553998757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81535,"user_name":"一道阳光","can_delete":false,"product_type":"c1","uid":1239557,"ip_address":"","ucode":"F35207CCCEC6E2","user_header":"https://static001.geekbang.org/account/avatar/00/12/ea/05/c0d8014d.jpg","comment_is_top":false,"comment_ctime":1553938122,"is_pvip":false,"replies":[{"id":"29575","content":"会<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553998836,"ip_address":"","comment_id":81535,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553938122","product_id":100023901,"comment_content":"老师，有个疑问，例子中两个if语句之间加上某些操作，如果线程获取第二把锁失败，释放曾经获取的锁，然后再次重新获取第一把锁之后，第二把锁之前，这些操作会重复执行一遍吧。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445242,"discussion_content":"会\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553998836,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81506,"user_name":"花蛋壳","can_delete":false,"product_type":"c1","uid":1111006,"ip_address":"","ucode":"917BB219120BD2","user_header":"https://static001.geekbang.org/account/avatar/00/10/f3/de/c6509355.jpg","comment_is_top":false,"comment_ctime":1553930195,"is_pvip":false,"replies":[{"id":"29557","content":"👍<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553988993,"ip_address":"","comment_id":81506,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553930195","product_id":100023901,"comment_content":"trylock是非阻塞的，尝试获取锁失败会立即返回，所以不应该会出现死锁问题","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445233,"discussion_content":"👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553988993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81487,"user_name":"程序员人生","can_delete":false,"product_type":"c1","uid":1113668,"ip_address":"","ucode":"C5C5073D89AAA2","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/44/3e3040ac.jpg","comment_is_top":false,"comment_ctime":1553923968,"is_pvip":false,"replies":[{"id":"29559","content":"还有下","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553989040,"ip_address":"","comment_id":81487,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553923968","product_id":100023901,"comment_content":"Condition 呢？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445226,"discussion_content":"还有下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553989040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81473,"user_name":"ykkk88","can_delete":false,"product_type":"c1","uid":1068585,"ip_address":"","ucode":"A1BCFC2F0D1022","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/29/1be3dd40.jpg","comment_is_top":false,"comment_ctime":1553921090,"is_pvip":false,"replies":[{"id":"29566","content":"我这种可能<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553991678,"ip_address":"","comment_id":81473,"utype":1}],"discussion_count":1,"race_medal":2,"score":"1553921090","product_id":100023901,"comment_content":"老师 reemtrantlock如果是非公平锁的话 会不会造成饿死 比如readwritereentrantlock","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445216,"discussion_content":"我这种可能\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553991678,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81443,"user_name":"姜小白","can_delete":false,"product_type":"c1","uid":1449131,"ip_address":"","ucode":"83B2D2A9FA295D","user_header":"https://static001.geekbang.org/account/avatar/00/16/1c/ab/23816951.jpg","comment_is_top":false,"comment_ctime":1553914609,"is_pvip":false,"replies":[{"id":"29544","content":"trylock是非阻塞的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553950418,"ip_address":"","comment_id":81443,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553914609","product_id":100023901,"comment_content":"我觉得trylock方法应该用那个加超时时间的，不然会一直自旋下去。活锁了","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445199,"discussion_content":"trylock是非阻塞的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553950418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81423,"user_name":"阿冲","can_delete":false,"product_type":"c1","uid":1062514,"ip_address":"","ucode":"06BF66D9009659","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKg7RjNMzSrIwUnjYstbdicVv5MawrQLTHc6rdpwm0Q04b7icj7eAb0F8zSxe8gmM99QBvTECK5KvrQ/132","comment_is_top":false,"comment_ctime":1553911338,"is_pvip":false,"replies":[{"id":"29560","content":"👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553989097,"ip_address":"","comment_id":81423,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553911338","product_id":100023901,"comment_content":"有可能一直陷入死循环","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445192,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553989097,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81405,"user_name":"GeekAmI","can_delete":false,"product_type":"c1","uid":1005030,"ip_address":"","ucode":"232C0B6DFB9F56","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/e6/87197b10.jpg","comment_is_top":false,"comment_ctime":1553905142,"is_pvip":false,"replies":[{"id":"29665","content":"这里拿不到别人锁会释放自己的锁<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554079732,"ip_address":"","comment_id":81405,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553905142","product_id":100023901,"comment_content":"互相转账时，有可能产生死锁。可重入锁指的是对同一把锁的加锁操作，转账这个显然是2把不同的锁。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445183,"discussion_content":"这里拿不到别人锁会释放自己的锁\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554079732,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81403,"user_name":"Tony Du","can_delete":false,"product_type":"c1","uid":1001661,"ip_address":"","ucode":"F5FCC400E615EA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/bd/6c7d4230.jpg","comment_is_top":false,"comment_ctime":1553904375,"is_pvip":false,"replies":[{"id":"29666","content":"我也觉得不会有死锁<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554079760,"ip_address":"","comment_id":81403,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553904375","product_id":100023901,"comment_content":"我觉得不会死锁，T1获取tar锁和T2获取this锁有可能同时执行，但是互相tryLock都失败，进入循环，下一次再重新拿锁，随着线程的执行，总有机会两个线程错开执行到拿锁那句，所以不会死锁。请老师指正！","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445182,"discussion_content":"我也觉得不会有死锁\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554079760,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81402,"user_name":"一道阳光","can_delete":false,"product_type":"c1","uid":1239557,"ip_address":"","ucode":"F35207CCCEC6E2","user_header":"https://static001.geekbang.org/account/avatar/00/12/ea/05/c0d8014d.jpg","comment_is_top":false,"comment_ctime":1553904350,"is_pvip":false,"replies":[{"id":"29568","content":"👍👍👍改过来了<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553991953,"ip_address":"","comment_id":81402,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553904350","product_id":100023901,"comment_content":"死锁不会出现，多核CPU下会出现活锁，两个线程互相去试图获取，都没有成功，就返回。<br>另外老师讲lock规则的可见性时，应该是线程T1的lock操作会happens-before于线程T2的lock操作。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445181,"discussion_content":"👍👍👍改过来了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553991953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}