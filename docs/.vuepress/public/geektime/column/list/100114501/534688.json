{"id":534688,"title":"16｜视频：初级篇实操总结","content":"<p>你好，我是Chrono。</p><p>学完了前面的7节文字+音频的课程之后，今天又是一节视频课程，对“初级篇”里Kubernetes知识做一个回顾与总结，同样还是注重实际操作的演示，而不会讲解理论知识。</p><p>首先我们会启动本机环境里的minikube，登录虚拟节点看看apiserver、etcd、scheduler等组件，然后使用命令行工具kubectl操作Kubernetes，创建Pod、Job、CronJob、ConfigMap、Secret等API对象。</p><p>接下来我们视频上见。</p><hr><h3>一. minikube环境</h3><p><video poster=\"https://static001.geekbang.org/resource/image/f9/82/f9dc1572049e052dbf7a6b7d60b39482.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/22d0d4d8-182403ae05f-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/d51c4ba4c0f6480a853aa0260ac96255/fd7f460dc9d14904998adf7b1f6fceb0-df367729a5aa180933814f46cd6ca103-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><p>视频操作要点：</p><p>我们从minikube环境开始，安装的过程就不演示了，我假设你已经按照<a href=\"https://time.geekbang.org/column/article/529780\">第9讲</a>里的步骤成功下载了minikube和kubectl的二进制文件。</p><p>先看一下minikube的版本号：</p><pre><code class=\"language-plain\">minikube version\n</code></pre><p>显示的是当前的最新版本1.25.2，再看一下它的状态：</p><pre><code class=\"language-plain\">minikube status\n</code></pre><p>可以看到Kubernetes的组件都没有启动，集群处于停止状态。</p><p>现在让我们用 <code>minikube start</code> 启动minikube集群：</p><pre><code class=\"language-plain\">minikube start --kubernetes-version=v1.23.3\n</code></pre><p>稍等一小会，看看它提示里的表情符号，一个本地的微型Kubernetes集群就创建好了。从提示信息里可以看到，这个Kubernetes集群的版本是v1.23.3，运行在Docker 20.10.12上。</p><!-- [[[read_end]]] --><p>现在我们再看一下minikube的状态：</p><pre><code class=\"language-plain\">minikube status\n</code></pre><p>可以看到Kubernetes的核心组件kubelet、apiserver都是运行状态了。</p><p>命令 <code>minikube node list</code> 可以查看这个微型集群的节点列表：</p><pre><code class=\"language-plain\">minikube node list\n</code></pre><p>默认情况下，minikube只会创建一个节点，这里显示它的IP地址是“192.168.49.2”。</p><p>我们可以使用命令 <code>minikube ssh</code> 直接登录到这个节点，是虚拟机里的一个虚拟机，在里面可以执行任意的Linux操作：</p><pre><code class=\"language-bash\">uname -a  #显示是Ubuntu操作系统\ndocker version #这个节点里也跑了一个docker，但其实是复用了宿主机的docker\ndocker ps    #能够看到节点里以容器形式运行的Kubernetes进程，比如pause、scheduler等等\nexit\n</code></pre><p>看完了minikube集群的状态，让我们用kubectl来操作Kubernetes，首先是看版本号：</p><pre><code class=\"language-plain\">kubectl version\n</code></pre><p>显示版本是1.23.3。用 <code>kubectl get pod</code> 看看当前集群里运行的运行应用，会发现是空的。</p><p>让我们用 <code>run</code> 命令运行一个Nginx Pod：</p><pre><code class=\"language-plain\">kubectl run ngx --image=nginx:alpine\n</code></pre><p>这个时候我们再查看Pod， <code>kubectl get pod</code> 就会看到有一个Pod运行了。</p><p>这个Nginx pod属于default名字空间，而apiserver等核心组件是在kube-system名字空间，你可以用 <code>-n</code> 参数查看在kube-system里运行的Pod：</p><pre><code class=\"language-plain\">kubectl get pod -n kube-system\n</code></pre><p>可以看到apiserver、etcd、scheduler、controller manager、coredns、kube-proxy等组件都是以Pod的形式在这里运行。</p><h3>二. 用kubectl操作API对象</h3><p><video poster=\"https://static001.geekbang.org/resource/image/54/36/54b52afb862a759b3ab4a39849f83e36.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/f620f7b-181b8be45bb-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/5ecce2893a7b475fab32e3a23006a487/231855bd53144b16b576cebea6e18207-dfe9193d7796080a7458c2209015a6ec-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><p>视频操作要点：</p><p>下面我们把注意力集中在kubectl操作Kubernetes API对象上。</p><p>先来查看当前Kubernetes版本支持的所有api对象，命令是 <code>kubectl api-resources</code>：</p><pre><code class=\"language-plain\">kubectl api-resources\n</code></pre><p>它的输出信息很多，你可以看到Pod的简写是po、api version是v1、CronJob的简写是cj、api version是batch/v1，这些信息在我们编写YAML描述文件的时候非常有用。</p><p>再来看另一个常用的命令 <code>kubectl explain</code>，它能够给出api对象字段的详细信息，比如查看Pod：</p><pre><code class=\"language-plain\">kubectl explain pod\nkubectl explain pod.metadata\nkubectl explain pod.spec\nkubectl explain pod.spec.containers\n</code></pre><p>有了这个随手可得的文档，我们在编写YAML文件的时候就不会不知所措了。</p><p>创建YAML样板要用到两个特殊参数“--dry-run=client”和“-o yaml”，我把它定义成一个环境变量：</p><pre><code class=\"language-plain\">export out=\"--dry-run=client -o yaml\"\n</code></pre><p>然后我们再创建一个Pod的YAML：</p><pre><code class=\"language-plain\">kubectl run ngx --image=nginx:alpine $out &gt; pod.yml\n</code></pre><p>用vi编辑这个文件，删除不需要的字段，一个YAML描述文件形式的API对象就创建好了。</p><h3>三. Pod对象</h3><p><video poster=\"https://static001.geekbang.org/resource/image/c5/11/c5f98ac2230ca607f779a6596cd5b011.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/4cb608fe-181b8be430b-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/e735dc9e459b41a0909da5159e215913/68ed2a70a377430ebdb6837d09b9cb26-f205ce729b35fa8d25ef857e7012159a-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><p>视频操作要点：</p><p>我们来看一个已经编辑好的Nginx pod对象，里面定义了名字是ngx-pod，有两个标签env和owner，spec里的containers定义了Pod里只有一个容器，镜像是nginx:alpine，对外的端口是80。</p><p>现在就可以使用命令 <code>kubectl apply</code> 创建这个Pod，再用 <code>kubectl get pod</code> 来查看状态：</p><pre><code class=\"language-plain\">kubectl apply -f ngx-pod.yml\nkubectl get pod\n</code></pre><p>命令 <code>kubectl logs</code> 会输出Nginx的运行日志：</p><pre><code class=\"language-plain\">kubectl logs ngx-pod\n</code></pre><p>我们还可以用 <code>kubectl exec</code> 进入Pod里的容器，注意要有 <code>--</code>：</p><pre><code class=\"language-plain\">kubectl exec -it ngx-pod -- sh\nnginx -v\nuname -a\nexit\n</code></pre><p>最后我们用 <code>kubectl delete</code> 删除这个Pod：</p><pre><code class=\"language-plain\">kubectl delete -f ngx-pod.yml\n</code></pre><h3>四. 离线业务对象Job、CronJob</h3><p><video poster=\"https://static001.geekbang.org/resource/image/86/40/86834deaa8f1259ca65da6cdc5867340.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/1d3d2044-181b8be3fe0-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/d17275ca36d54b2d873b8343e1a86622/0954d47bb02d492d9023512a5cddab89-9ea5ba81a6f03f1503c458c01849978c-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><p>视频操作要点：</p><p>看完了Pod的基本操作之后，我们来看离线业务的对象Job和CronJob。</p><p>首先要用 <code>kubectl create</code> 创建一个Job样板文件：</p><pre><code class=\"language-plain\">kubectl create job echo-job --image=busybox $out\n</code></pre><p>把它保存编辑之后，我们就得到了一个Job对象，用vi看一下。这个Job非常简单，执行echo命令，输出hello world。注意它的restartPolicy是OnFailure，表示失败后要原地重启容器。</p><p>现在来创建Job对象，用的命令还是 <code>kubectl apply</code>：</p><pre><code class=\"language-plain\">kubectl apply -f job.yml\n</code></pre><p>创建之后用 <code>kubectl get job</code>、<code>kubectl get pod</code> 来分别查看Job和Pod的状态，使用命令 <code>kubectl logs</code> 来获取Pod的运行结果：</p><pre><code class=\"language-plain\">kubectl get job\nkubectl get pod\nkubectl logs echo-job-l52l7\n</code></pre><p>CronJob同样也可以自动生成样板文件：</p><pre><code class=\"language-plain\">kubectl create cj echo-cj --image=busybox --schedule=\"\" $out\nvi cronjob.yml\n</code></pre><p>CronJob对象里要注意的是，它使用jobTemplate又定义了一个Job，然后在字段schedule里使用cron语法定义了定时运行的规则，这里就是每分钟运行一次。</p><p>CronJob的用法和Job几乎是一样的，用 <code>apply</code> 命令创建后就可以用get来查看作业的运行状态：</p><pre><code class=\"language-plain\">kubectl apply -f cronjob.yml\nkubectl get cj\nkubectl get pod\n</code></pre><p>最后让我们用 <code>delete</code> 命令删除这两个API对象：</p><pre><code class=\"language-plain\">kubectl delete -f job.yml\nkubectl delete -f cronjob.yml\n</code></pre><h3>五. 配置信息对象ConfigMap和Secret</h3><p><video poster=\"https://static001.geekbang.org/resource/image/90/30/9015b2f688128be127419a9f1575f330.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/5d50af62-182403adbf9-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/0125c506fb01492db04ac984a89c54a8/6851bc79d22644b28c38a9f4e387ca54-b2612598497ab5a2b4602c985bb2fe7a-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><p>视频操作要点：</p><p>下面我来演示Kubernetes里的配置信息对象ConfigMap和secret。</p><p>还是老办法，先用 <code>kubectl create</code> 创建ConfigMap的样板文件，不过要命令后面多加一个参数 <code>--from-literal</code> ，从字面值生成一些数据：</p><pre><code class=\"language-plain\">kubectl create cm info --from-literal=k=v $out\n</code></pre><p>Secret也是同样的创建方式，注意命令形式与ConfigMap略有不同，要用generic表示一般的机密信息：</p><pre><code class=\"language-plain\">kubectl create secret generic user --from-literal=name=root $out\n</code></pre><p>我们来看看已经编辑好的YAML文件:</p><pre><code class=\"language-plain\">vi cm.yml\n</code></pre><p>这里定义了4个配置项，注意ConfigMap要求必须是字符串，所以最好用引号引起来，避免解释成数字导致错误。</p><pre><code class=\"language-plain\">vi secret.yml\n</code></pre><p>Secret里定义了3个配置项，由于做了base64编码，不能直接看到原值，不过我们可以在命令行里用工具base64 -d解码，比如看用户名：</p><pre><code class=\"language-plain\">echo cm9vdA== | base64 -d\n</code></pre><p>现在让我们创建这两个对象：</p><pre><code class=\"language-plain\">kubectl apply&nbsp;-f cm.yml\nkubectl apply  -f secret.yml\n</code></pre><p>然后查看这些对象的状态：</p><pre><code class=\"language-plain\">kubectl get cm\nkubectl describe cm info\n</code></pre><p>ConfigMap是明文显示：</p><pre><code class=\"language-plain\">kubectl get secret\nkubectl describe secret user\n</code></pre><p>而Secret的类型是Opaque，不透明的，不能直接看到。</p><p>接下来我们把这些配置信息以存储卷的形式注入Pod，需要在Pod里加入“<strong>volumes</strong>”和“<strong>volumeMounts</strong>”字段：</p><pre><code class=\"language-plain\">vi vol-pod.yml\n</code></pre><p>在这份YAML里，我为ConfigMap和Secret定义了两个volume，分别是cm-vol和sec-vol，然后在volumeMounts里把它们挂载到了tmp目录。</p><p>用 <code>kubectl apply</code> 命令创建之后，我们还是用 <code>kubectl exec</code> 进入Pod，看看配置信息被加载成了什么形式：</p><pre><code class=\"language-bash\">kubectl apply -f vol-pod.yml\nkubectl get pod\nkubectl exec -it vol-pod -- sh\n\ncd /tmp\nls              #加载成两个目录\ncd cm-items/\ncat greeting\ncd ..\ncd sec-items/\ncat pwd        #已经被base64解码\n</code></pre><h3>六. 在Kubernetes里搭建WordPress</h3><p><video poster=\"https://static001.geekbang.org/resource/image/fc/a7/fc2ba132b807e8f4a5412c148b9545a7.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/2c632123-181b8be36f6-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/16a4e076eb6d4597bd087f1f1432aa28/0bee8924d19d4b4fb5009bbf37d370d8-1b4720df19676267e3d7bc65e8decfce-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><p>视频操作要点：</p><p>最后我们在Kubernetes里搭建WordPress，这些YAML文件都已经准备好了，只需要逐个用 <code>apply</code> 命令创建就可以。</p><p>首先是MariaDB数据库：</p><pre><code class=\"language-plain\">kubectl apply -f mariadb-pod.yml\nkubectl get pod -o wide\n</code></pre><p>需要看它的IP地址，这里是172.17.0.？，然后我们修改WordPress YAML，环境变量host改成MariaDB的地址，然后再创建WordPress Pod：</p><pre><code class=\"language-plain\">kubectl apply -f wp-pod.yml\nkubectl get pod -o wide\n</code></pre><p>现在这两个Pod都已经正常运行了，我们需要把WordPress的端口暴露出来，用的是 <code>kubectl port-forward</code> 命令：</p><pre><code class=\"language-plain\">kubectl port-forward wp-pod 8080:80 &amp;\n</code></pre><p>然后我们用Docker运行Nginx容器，代理这个端口：</p><pre><code class=\"language-plain\">./wp_proxy.sh\ndocker ps\n</code></pre><p>现在我们打开Mac上的Safari浏览器，输入虚拟机的IP地址“<a href=\"http://192.168.10.208\">http://192.168.10.208</a>”，就可以看到WordPress的安装界面了。</p><h3>课下作业</h3><p>今天是动手操作课，记得让自己实际上手操作一遍，毕竟看一遍和写一遍学习效果完全不同哦。</p><p>欢迎分享自己的学习体验和疑问，在留言区参与讨论。我们下节课见。</p>","neighbors":{"left":{"article_title":"15｜实战演练：玩转Kubernetes（1）","id":534644},"right":{"article_title":"17｜更真实的云原生：实际搭建多节点的Kubernetes集群","id":534762}},"comments":[]}