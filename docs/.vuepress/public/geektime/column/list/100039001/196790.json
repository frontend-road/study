{"id":196790,"title":"43 | 单例模式（下）：如何设计实现一个集群环境下的分布式单例模式？","content":"<p>上两节课中，我们针对单例模式，讲解了单例的应用场景、几种常见的代码实现和存在的问题，并粗略给出了替换单例模式的方法，比如工厂模式、IOC容器。今天，我们再进一步扩展延伸一下，一块讨论一下下面这几个问题：</p><ul>\n<li>如何理解单例模式中的唯一性？</li>\n<li>如何实现线程唯一的单例？</li>\n<li>如何实现集群环境下的单例？</li>\n<li>如何实现一个多例模式？</li>\n</ul><p>今天的内容稍微有点“烧脑”，希望你在看的过程中多思考一下。话不多说，让我们正式开始今天的学习吧！</p><h2>如何理解单例模式中的唯一性？</h2><p>首先，我们重新看一下单例的定义：“一个类只允许创建唯一一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。”</p><p>定义中提到，“一个类只允许创建唯一一个对象”。那对象的唯一性的作用范围是什么呢？是指线程内只允许创建一个对象，还是指进程内只允许创建一个对象？答案是后者，也就是说，单例模式创建的对象是进程唯一的。这里有点不好理解，我来详细地解释一下。</p><p>我们编写的代码，通过编译、链接，组织在一起，就构成了一个操作系统可以执行的文件，也就是我们平时所说的“可执行文件”（比如Windows下的exe文件）。可执行文件实际上就是代码被翻译成操作系统可理解的一组指令，你完全可以简单地理解为就是代码本身。</p><!-- [[[read_end]]] --><p>当我们使用命令行或者双击运行这个可执行文件的时候，操作系统会启动一个进程，将这个执行文件从磁盘加载到自己的进程地址空间（可以理解操作系统为进程分配的内存存储区，用来存储代码和数据）。接着，进程就一条一条地执行可执行文件中包含的代码。比如，当进程读到代码中的User user = new User();这条语句的时候，它就在自己的地址空间中创建一个user临时变量和一个User对象。</p><p>进程之间是不共享地址空间的，如果我们在一个进程中创建另外一个进程（比如，代码中有一个fork()语句，进程执行到这条语句的时候会创建一个新的进程），操作系统会给新进程分配新的地址空间，并且将老进程地址空间的所有内容，重新拷贝一份到新进程的地址空间中，这些内容包括代码、数据（比如user临时变量、User对象）。</p><p>所以，单例类在老进程中存在且只能存在一个对象，在新进程中也会存在且只能存在一个对象。而且，这两个对象并不是同一个对象，这也就说，单例类中对象的唯一性的作用范围是进程内的，在进程间是不唯一的。</p><h2>如何实现线程唯一的单例？</h2><p>刚刚我们讲了单例类对象是进程唯一的，一个进程只能有一个单例对象。那如何实现一个线程唯一的单例呢？</p><p>我们先来看一下，什么是线程唯一的单例，以及“线程唯一”和“进程唯一”的区别。</p><p>“进程唯一”指的是进程内唯一，进程间不唯一。类比一下，“线程唯一”指的是线程内唯一，线程间可以不唯一。实际上，“进程唯一”还代表了线程内、线程间都唯一，这也是“进程唯一”和“线程唯一”的区别之处。这段话听起来有点像绕口令，我举个例子来解释一下。</p><p>假设IdGenerator是一个线程唯一的单例类。在线程A内，我们可以创建一个单例对象a。因为线程内唯一，在线程A内就不能再创建新的IdGenerator对象了，而线程间可以不唯一，所以，在另外一个线程B内，我们还可以重新创建一个新的单例对象b。</p><p>尽管概念理解起来比较复杂，但线程唯一单例的代码实现很简单，如下所示。在代码中，我们通过一个HashMap来存储对象，其中key是线程ID，value是对象。这样我们就可以做到，不同的线程对应不同的对象，同一个线程只能对应一个对象。实际上，Java语言本身提供了ThreadLocal工具类，可以更加轻松地实现线程唯一单例。不过，ThreadLocal底层实现原理也是基于下面代码中所示的HashMap。</p><pre><code>public class IdGenerator {\n  private AtomicLong id = new AtomicLong(0);\n\n  private static final ConcurrentHashMap&lt;Long, IdGenerator&gt; instances\n          = new ConcurrentHashMap&lt;&gt;();\n\n  private IdGenerator() {}\n\n  public static IdGenerator getInstance() {\n    Long currentThreadId = Thread.currentThread().getId();\n    instances.putIfAbsent(currentThreadId, new IdGenerator());\n    return instances.get(currentThreadId);\n  }\n\n  public long getId() {\n    return id.incrementAndGet();\n  }\n}\n</code></pre><h2>如何实现集群环境下的单例？</h2><p>刚刚我们讲了“进程唯一”的单例和“线程唯一”的单例，现在，我们再来看下，“集群唯一”的单例。</p><p>首先，我们还是先来解释一下，什么是“集群唯一”的单例。</p><p>我们还是将它跟“进程唯一”“线程唯一”做个对比。“进程唯一”指的是进程内唯一、进程间不唯一。“线程唯一”指的是线程内唯一、线程间不唯一。集群相当于多个进程构成的一个集合，“集群唯一”就相当于是进程内唯一、进程间也唯一。也就是说，不同的进程间共享同一个对象，不能创建同一个类的多个对象。</p><p>我们知道，经典的单例模式是进程内唯一的，那如何实现一个进程间也唯一的单例呢？如果严格按照不同的进程间共享同一个对象来实现，那集群唯一的单例实现起来就有点难度了。</p><p>具体来说，我们需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。</p><p>为了保证任何时刻，在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，还需要显式地将对象从内存中删除，并且释放对对象的加锁。</p><p>按照这个思路，我用伪代码实现了一下这个过程，具体如下所示：</p><pre><code>public class IdGenerator {\n  private AtomicLong id = new AtomicLong(0);\n  private static IdGenerator instance;\n  private static SharedObjectStorage storage = FileSharedObjectStorage(/*入参省略，比如文件地址*/);\n  private static DistributedLock lock = new DistributedLock();\n  \n  private IdGenerator() {}\n\n  public synchronized static IdGenerator getInstance() \n    if (instance == null) {\n      lock.lock();\n      instance = storage.load(IdGenerator.class);\n    }\n    return instance;\n  }\n  \n  public synchroinzed void freeInstance() {\n    storage.save(this, IdGeneator.class);\n    instance = null; //释放对象\n    lock.unlock();\n  }\n  \n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n\n// IdGenerator使用举例\nIdGenerator idGeneator = IdGenerator.getInstance();\nlong id = idGenerator.getId();\nidGenerator.freeInstance();\n</code></pre><h2>如何实现一个多例模式？</h2><p>跟单例模式概念相对应的还有一个多例模式。那如何实现一个多例模式呢？</p><p>“单例”指的是，一个类只能创建一个对象。对应地，“多例”指的就是，一个类可以创建多个对象，但是个数是有限制的，比如只能创建3个对象。如果用代码来简单示例一下的话，就是下面这个样子：</p><pre><code>public class BackendServer {\n  private long serverNo;\n  private String serverAddress;\n\n  private static final int SERVER_COUNT = 3;\n  private static final Map&lt;Long, BackendServer&gt; serverInstances = new HashMap&lt;&gt;();\n\n  static {\n    serverInstances.put(1L, new BackendServer(1L, &quot;192.134.22.138:8080&quot;));\n    serverInstances.put(2L, new BackendServer(2L, &quot;192.134.22.139:8080&quot;));\n    serverInstances.put(3L, new BackendServer(3L, &quot;192.134.22.140:8080&quot;));\n  }\n\n  private BackendServer(long serverNo, String serverAddress) {\n    this.serverNo = serverNo;\n    this.serverAddress = serverAddress;\n  }\n\n  public BackendServer getInstance(long serverNo) {\n    return serverInstances.get(serverNo);\n  }\n\n  public BackendServer getRandomInstance() {\n    Random r = new Random();\n    int no = r.nextInt(SERVER_COUNT)+1;\n    return serverInstances.get(no);\n  }\n}\n</code></pre><p>实际上，对于多例模式，还有一种理解方式：同一类型的只能创建一个对象，不同类型的可以创建多个对象。这里的“类型”如何理解呢？</p><p>我们还是通过一个例子来解释一下，具体代码如下所示。在代码中，logger name就是刚刚说的“类型”，同一个logger name获取到的对象实例是相同的，不同的logger name获取到的对象实例是不同的。</p><pre><code>public class Logger {\n  private static final ConcurrentHashMap&lt;String, Logger&gt; instances\n          = new ConcurrentHashMap&lt;&gt;();\n\n  private Logger() {}\n\n  public static Logger getInstance(String loggerName) {\n    instances.putIfAbsent(loggerName, new Logger());\n    return instances.get(loggerName);\n  }\n\n  public void log() {\n    //...\n  }\n}\n\n//l1==l2, l1!=l3\nLogger l1 = Logger.getInstance(&quot;User.class&quot;);\nLogger l2 = Logger.getInstance(&quot;User.class&quot;);\nLogger l3 = Logger.getInstance(&quot;Order.class&quot;);\n</code></pre><p>这种多例模式的理解方式有点类似工厂模式。它跟工厂模式的不同之处是，多例模式创建的对象都是同一个类的对象，而工厂模式创建的是不同子类的对象，关于这一点，下一节课中就会讲到。实际上，它还有点类似享元模式，两者的区别等到我们讲到享元模式的时候再来分析。除此之外，实际上，枚举类型也相当于多例模式，一个类型只能对应一个对象，一个类可以创建多个对象。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们来一块总结回顾一下，你需要掌握的重点内容。</p><p>今天的内容比较偏理论，在实际的项目开发中，没有太多的应用。讲解的目的，主要还是拓展你的思路，锻炼你的逻辑思维能力，加深你对单例的认识。</p><p><strong>1.如何理解单例模式的唯一性？</strong></p><p>单例类中对象的唯一性的作用范围是“进程唯一”的。“进程唯一”指的是进程内唯一，进程间不唯一；“线程唯一”指的是线程内唯一，线程间可以不唯一。实际上，“进程唯一”就意味着线程内、线程间都唯一，这也是“进程唯一”和“线程唯一”的区别之处。“集群唯一”指的是进程内唯一、进程间也唯一。</p><p><strong>2.如何实现线程唯一的单例？</strong></p><p>我们通过一个HashMap来存储对象，其中key是线程ID，value是对象。这样我们就可以做到，不同的线程对应不同的对象，同一个线程只能对应一个对象。实际上，Java语言本身提供了ThreadLocal并发工具类，可以更加轻松地实现线程唯一单例。</p><p><strong>3.如何实现集群环境下的单例？</strong></p><p>我们需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。为了保证任何时刻在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，需要显式地将对象从内存中删除，并且释放对对象的加锁。</p><p><strong>4.如何实现一个多例模式？</strong></p><p>“单例”指的是一个类只能创建一个对象。对应地，“多例”指的就是一个类可以创建多个对象，但是个数是有限制的，比如只能创建3个对象。多例的实现也比较简单，通过一个Map来存储对象类型和对象之间的对应关系，来控制对象的个数。</p><h2>课堂讨论</h2><p>在文章中，我们讲到单例唯一性的作用范围是进程，实际上，对于Java语言来说，单例类对象的唯一性的作用范围并非进程，而是类加载器（Class Loader），你能自己研究并解释一下为什么吗？</p><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>","neighbors":{"left":{"article_title":"42 | 单例模式（中）：我为什么不推荐使用单例模式？又有何替代方案？","id":194068},"right":{"article_title":"44 | 工厂模式（上）：我为什么说没事不要随便用工厂模式创建对象？","id":197254}},"comments":[{"had_liked":false,"id":177167,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1581307629,"is_pvip":false,"discussion_count":20,"race_medal":1,"score":"1204172150509","product_id":100039001,"comment_content":"要回答这个课后问题，要理解classloader和JDK8中使用的双亲委派模型。<br>classloader有两个作用：1. 用于将class文件加载到JVM中；2. 确认每个类应该由哪个类加载器加载，并且也用于判断JVM运行时的两个类是否相等。<br>双亲委派模型的原理是当一个类加载器接收到类加载请求时，首先会请求其父类加载器加载，每一层都是如此，当父类加载器无法找到这个类时（根据类的全限定名称），子类加载器才会尝试自己去加载。<br>所以双亲委派模型解决了类重复加载的问题， 比如可以试想没有双亲委派模型时，如果用户自己写了一个全限定名为java.lang.Object的类，并用自己的类加载器去加载，同时BootstrapClassLoader加载了rt.jar包中的JDK本身的java.lang.Object，这样内存中就存在两份Object类了，此时就会出现很多问题，例如根据全限定名无法定位到具体的类。有了双亲委派模型后，所有的类加载操作都会优先委派给父类加载器，这样一来，即使用户自定义了一个java.lang.Object，但由于BootstrapClassLoader已经检测到自己加载了这个类，用户自定义的类加载器就不会再重复加载了。所以，双亲委派模型能够保证类在内存中的唯一性。<br>联系到课后的问题，所以用户定义了单例类，这样JDK使用双亲委派模型加载一次之后就不会重复加载了，保证了单例类的进程内的唯一性，也可以认为是classloader内的唯一性。当然，如果没有双亲委派模型，那么多个classloader就会有多个实例，无法保证唯一性。 ","like_count":280,"discussions":[{"author":{"id":1423544,"avatar":"https://static001.geekbang.org/account/avatar/00/15/b8/b8/070de9c1.jpg","nickname":"子适","note":"","ucode":"57802D756E4828","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56513,"discussion_content":"它只关心程序飞的高不高，不关心程序猿飞的累不累。🐂🍺","likes_number":28,"is_delete":false,"is_hidden":false,"ctime":1574492242,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1518308,"avatar":"https://static001.geekbang.org/account/avatar/00/17/2a/e4/714ffd01.jpg","nickname":"Kelly.W","note":"","ucode":"6EFB58A24355C4","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":315959,"discussion_content":"它只关心程序飞的高不高，不关心程序猿飞的累不累。太喜欢这句话了","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1603339918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1262680,"avatar":"https://static001.geekbang.org/account/avatar/00/13/44/58/a901cfce.jpg","nickname":"LiYou","note":"","ucode":"F10DD1205CCDD1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296826,"discussion_content":"对于所有编程语言最终目的是两种：提高硬件的运行效率和提高程序员的开发效率。然而这两种很难兼得。\n(๑˃̵ᴗ˂̵)👍(๑˃̵ᴗ˂̵)👍(๑˃̵ᴗ˂̵)👍","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1596677186,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1063308,"avatar":"https://static001.geekbang.org/account/avatar/00/10/39/8c/089525aa.jpg","nickname":"小乙哥","note":"","ucode":"C77E79BEA0C325","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55565,"discussion_content":"硬件成本与编程语言发展，这个思考角度新颖","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1574384382,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1956678,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/db/46/19fd3b93.jpg","nickname":"YYQ","note":"","ucode":"19C7D3B9D21DB0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292625,"discussion_content":"cpu中指令全是o（1），没有比这个高的","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1595290397,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474730,"discussion_content":"👍","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574129736,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383755,"discussion_content":"好家伙 这就是 买正版课的理由; 首先从硬件本质上谈起,人终究要驯服这个计算机,方式就有很多,面向过程开发 面向对象开发,不妨一 一试试,用Java来做,Java的面向对象开发,很上手,开发效率高,但是人的开发效率高了,一段时间内机器的效率不高,机器就是用来提高效率的,这个Java不妥;那就试试c,虽然c普通人开发效率慢,但是机器高,随着时间推移,机器带来的收益更大,因此还得看未来场景;","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1626232762,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1308783,"avatar":"https://static001.geekbang.org/account/avatar/00/13/f8/6f/080973cf.jpg","nickname":"Edward","note":"","ucode":"10FAADF92D05F4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342548,"discussion_content":"彩！","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1610711479,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2463396,"avatar":"","nickname":"Geek_d78bd5","note":"","ucode":"CEFEF90DC9A84C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391371,"discussion_content":"可以，透彻，我只想到c语言贴近硬件，易于开发。同时计算机的底层和普通的业务开发不太。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1630420659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1958147,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/e1/03/f937e673.jpg","nickname":"🍀","note":"","ucode":"60E0AC2A55B63B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":268499,"discussion_content":"我也看了那一篇简书","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589791564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1691500,"avatar":"https://static001.geekbang.org/account/avatar/00/19/cf/6c/87faa554.jpg","nickname":"MoeRookie","note":"","ucode":"E860D73EE91F00","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1958147,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/e1/03/f937e673.jpg","nickname":"🍀","note":"","ucode":"60E0AC2A55B63B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331188,"discussion_content":"请问那篇简书文章的地址是?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606801543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":268499,"ip_address":""},"score":331188,"extra":""}]},{"author":{"id":1253109,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1e/f5/fba1adfd.jpg","nickname":"斑斓","note":"","ucode":"57AE303DD189E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212556,"discussion_content":"硬件的发展总是制约着软件的发展","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584977068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2051293,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","nickname":"Bumblebee","note":"","ucode":"B879C8A511D08D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584471,"discussion_content":"🚩","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660866722,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2715388,"avatar":"","nickname":"Geek8535","note":"","ucode":"D1919541632C95","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532864,"discussion_content":"厉害了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637722089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2664142,"avatar":"","nickname":"QL","note":"","ucode":"B2EA2101793B56","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530583,"discussion_content":"优秀极了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637109156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1120156,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ercic1LB9N9P1kArjS1f3hOo641elcwFGHWrxeYF4yZjfwiaydLwVeM4ZJEmVkib66GtJoE0cr6Dviauw/132","nickname":"小北","note":"","ucode":"A428FC9B771108","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":407614,"discussion_content":"说的太好了，直击本质！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635072669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1992973,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/69/0d/0a2fd71e.jpg","nickname":"刘博","note":"","ucode":"F00AA3B3200BBE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":402859,"discussion_content":"醍醐灌顶","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633958130,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1210268,"avatar":"https://static001.geekbang.org/account/avatar/00/12/77/9c/ce85b2d3.jpg","nickname":"汽水枪","note":"","ucode":"50C340ADC3C40A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":398438,"discussion_content":"我想的是：因为历史原因和人多的原因。。哭泣。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632793498,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1162242,"avatar":"https://static001.geekbang.org/account/avatar/00/11/bc/02/3f7a7197.jpg","nickname":"跨江大桥","note":"","ucode":"4629B23F1BB9F0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1210268,"avatar":"https://static001.geekbang.org/account/avatar/00/12/77/9c/ce85b2d3.jpg","nickname":"汽水枪","note":"","ucode":"50C340ADC3C40A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":414933,"discussion_content":"内卷。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636940437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":398438,"ip_address":""},"score":414933,"extra":""}]},{"author":{"id":1622696,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c2/a8/f3f8f5d2.jpg","nickname":"一格状语","note":"","ucode":"EBA9ED5F97416D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394604,"discussion_content":"说的太好了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631953644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1122533,"avatar":"https://static001.geekbang.org/account/avatar/00/11/20/e5/f66d6144.jpg","nickname":"九先生","note":"","ucode":"A63A333299D485","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385801,"discussion_content":"醍醐灌顶啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627281615,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2309338,"avatar":"","nickname":"Geek_syh","note":"","ucode":"0177F10845CE87","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382050,"discussion_content":"讲的太通透了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625388063,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2550743,"avatar":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","nickname":"if...else...","note":"","ucode":"D0565908C99695","race_medal":4,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376972,"discussion_content":"大神","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622444003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1999235,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/81/83/f93b1e62.jpg","nickname":"peaceForce","note":"","ucode":"98A318930DDC9A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374559,"discussion_content":"妙哉妙哉！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621244662,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1234963,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d8/13/082013bc.jpg","nickname":"昵称C","note":"","ucode":"1BB2D537942DC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374161,"discussion_content":"评论区有大神","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621046020,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1691447,"avatar":"https://static001.geekbang.org/account/avatar/00/19/cf/37/6ed137b9.jpg","nickname":"Dunk","note":"","ucode":"A8F5AB98382719","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367104,"discussion_content":"彩","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618272305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1210386,"avatar":"https://static001.geekbang.org/account/avatar/00/12/78/12/7df38a54.jpg","nickname":"helloworld2018","note":"","ucode":"2AE40C0DF5A9F7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364316,"discussion_content":"膜拜","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617440884,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1240321,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ed/01/997432f3.jpg","nickname":"喜笑延开","note":"","ucode":"DBF645D2129460","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347156,"discussion_content":"lihai","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612166275,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1971360,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/14/a0/4c315270.jpg","nickname":"刘颜","note":"","ucode":"FD3B9C7338B74C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332894,"discussion_content":"彩","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607387996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1717342,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/34/5e/089ac156.jpg","nickname":"冯佳兴","note":"","ucode":"41D308E99EF9FF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331871,"discussion_content":"漂亮","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606998341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1156557,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a5/cd/3aff5d57.jpg","nickname":"Alery","note":"","ucode":"08F3F49181E67B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329086,"discussion_content":"精彩\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606309145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1541014,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/96/73ff13a0.jpg","nickname":"天亮前说晚安","note":"","ucode":"1D82EE562A7C71","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304553,"discussion_content":"那为啥不搞个转换软件呢，用面向对象高级语言写代码然后编译成字节码文件使用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599613382,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":6,"child_discussions":[{"author":{"id":1014665,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/89/34f2cbcc.jpg","nickname":"杨宇","note":"","ucode":"EB74DF6E269F03","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1541014,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/96/73ff13a0.jpg","nickname":"天亮前说晚安","note":"","ucode":"1D82EE562A7C71","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335031,"discussion_content":"Java不就是这么做的吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608077422,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":304553,"ip_address":""},"score":335031,"extra":""},{"author":{"id":1541014,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/96/73ff13a0.jpg","nickname":"天亮前说晚安","note":"","ucode":"1D82EE562A7C71","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1014665,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/89/34f2cbcc.jpg","nickname":"杨宇","note":"","ucode":"EB74DF6E269F03","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":338432,"discussion_content":"我指的是编译阶段就直接生成指令集文件。不是加载运行，最后还要虚拟机转","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609290741,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":335031,"ip_address":""},"score":338432,"extra":""},{"author":{"id":1116001,"avatar":"https://static001.geekbang.org/account/avatar/00/11/07/61/8adbd0ae.jpg","nickname":"李凯旋","note":"","ucode":"FC267DD00F620D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1541014,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/96/73ff13a0.jpg","nickname":"天亮前说晚安","note":"","ucode":"1D82EE562A7C71","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343010,"discussion_content":"关键要跨平台","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610901803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":338432,"ip_address":""},"score":343010,"extra":""}]},{"author":{"id":1455958,"avatar":"https://static001.geekbang.org/account/avatar/00/16/37/56/11068390.jpg","nickname":"倡印","note":"","ucode":"4F53AA5D017D89","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292585,"discussion_content":"大佬就是大佬","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595257718,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1283461,"avatar":"https://static001.geekbang.org/account/avatar/00/13/95/85/15cd21c2.jpg","nickname":"杨锋","note":"","ucode":"85A7828A538FB0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284936,"discussion_content":"厉害啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592673527,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1314724,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0f/a4/0b49469f.jpg","nickname":"木子00","note":"","ucode":"8F78CA722EB29B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":276018,"discussion_content":"讲的太厉害了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590801750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1736148,"avatar":"","nickname":"Geek_jerry","note":"","ucode":"684923936D7849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":267952,"discussion_content":"个人认为面向对象语言就是在面向过程的语言上的基础上升级得来的。目的就是为了方面大家从人的视角不是从机器的视角设计开发项目","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589716760,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1104310,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d9/b6/4c498c17.jpg","nickname":"1620","note":"","ucode":"C9222A5CE4723C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":224700,"discussion_content":"赞\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586324330,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1225224,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","nickname":"尔冬橙","note":"","ucode":"0B013A49BC18DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217963,"discussion_content":"写的真好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585590303,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1734795,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/78/8b/421cb2c4.jpg","nickname":"成活","note":"","ucode":"F8840EE4DC3969","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":205874,"discussion_content":"手动点赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584352659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1235764,"avatar":"https://static001.geekbang.org/account/avatar/00/12/db/34/6b8cee97.jpg","nickname":"瘦风","note":"","ucode":"24CC2F8786D884","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":160555,"discussion_content":"赶紧拿出小本本记录下来📝","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580815944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1625618,"avatar":"https://static001.geekbang.org/account/avatar/00/18/ce/12/1488e361.jpg","nickname":"小明","note":"","ucode":"5A0357E9849226","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":102168,"discussion_content":"学习了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577327857,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1608879,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8c/af/debec40c.jpg","nickname":"长夏江村","note":"","ucode":"79921B6F7760B2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62173,"discussion_content":"理解深刻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574820889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177104,"user_name":"下雨天","can_delete":false,"product_type":"c1","uid":1008315,"ip_address":"","ucode":"816B3792ECC50A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/62/bb/323a3133.jpg","comment_is_top":false,"comment_ctime":1581286639,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"216329651439","product_id":100039001,"comment_content":"课堂讨论<br>     Java中，两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。<br>     单例类对象的唯一性前提也必须保证该类被同一个类加载器加载！","like_count":50,"discussions":[{"author":{"id":1448863,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/BIRpwViaN51yynIeFonD7QRlwDCVtKibrG956NTxzEqibOZZVjhMMgibOPmd3VicfYxpknZsic1oJq8KicZvXkmmiajuQg/132","nickname":"tuyu","note":"","ucode":"B235325B541408","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50772,"discussion_content":"加一","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573762989,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1131687,"avatar":"https://static001.geekbang.org/account/avatar/00/11/44/a7/171c1e86.jpg","nickname":"啦啦啦","note":"","ucode":"6B12EC90A62525","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50759,"discussion_content":"哈哈，老弟还没睡呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573749184,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204869,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":false,"comment_ctime":1586485035,"is_pvip":true,"discussion_count":7,"race_medal":0,"score":"121845569323","product_id":100039001,"comment_content":"JDK8中是双亲委派制，其实是单亲，parent只有一个，只不过国内翻译的时候翻译成双亲而已，应用类加载器（application class loader）的parent是扩展类加载器（extension class loader），扩展类加载器的parent是启动类加载器（bootstrap class loader）。启动类加载器是由 C++ 实现的，没有对应的 Java 对象，因此在 Java 中只能用 null 来指代。而且这里的类加载器并不是继承的关系，而是组合的的关系。<br><br>JDK 9 为了模块化的支持，对双亲委派模式做了一些改动：扩展类加载器被平台类加载器（Platform ClassLoader）取代。平台类加载器和应用程序类加载器都不再继承自 java.net.URLClassLoader，而是继承于 jdk.internal.loader.BuiltinClassLoader。<br><br>https:&#47;&#47;docs.oracle.com&#47;javase&#47;9&#47;migrate&#47;toc.htm#JSMIG-GUID-A868D0B9-026F-4D46-B979-901834343F9E","like_count":28,"discussions":[{"author":{"id":1750549,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/b6/15/e2cfd10d.jpg","nickname":"ImYours°","note":"","ucode":"51F653129034C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388078,"discussion_content":"大佬，你这个实现有没有博客或者源码？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628582586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2463502,"avatar":"https://static001.geekbang.org/account/avatar/00/25/97/0e/d79c9a2a.jpg","nickname":"风清扬","note":"","ucode":"0C252B0910677F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":357072,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615730878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179054,"user_name":"，","can_delete":false,"product_type":"c1","uid":1701867,"ip_address":"","ucode":"A5543C8DFEB198","user_header":"https://static001.geekbang.org/account/avatar/00/19/f7/eb/e7127bb8.jpg","comment_is_top":false,"comment_ctime":1581904759,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"83186283383","product_id":100039001,"comment_content":"深入理解JAVA虚拟机第三版 总结:<br>大前提:每一个类加载器,都有一个独立的类名称空间(通俗的解释:两个类只有在同一个类加载器加载的前提下,才能比较它们是否&quot;相等&quot;)<br><br>启动类加载器:加载JAVA_HOME\\lib目录下的类库<br>↑<br>扩展类加载器:加载JAVA_HOME\\lib\\ext目录下的类库,是java SE 扩展功能, jdk9 被模块化的天然扩展能力所取代<br>↑<br>应用程序加载器:加载用户的应用程序<br>↑<br>用户自定义的加载器:供用户扩展使用,加载用户想要的内容<br><br>  这个类加载器的层次关系被称为类的&quot;双亲委派模型&quot;<br><br>双亲委派模型工作流程:<br> 如果一个类加载器收到了加载请求,那么他会把这个请求委派给父类去完成,每一层都是如此,所以他最后会被委派到启动类加载器中,只有父类反馈自己无法完成这个加载请求时,子类才会尝试自己去加载<br>类不会重复的原因:<br> 比如一个类,java.lang.Object,存放在JAVA_HOME&#47;lib&#47;rt.jar中,无论哪个类加载器想要加载他,最终都会被委派给启动类加载器去加载<br>反之,如果没有双亲委派机制,用户自己编写一个java.lang.Object类,那么如果他被其他类加载器加载,内存中就会出现两个ava.lang.Object类","like_count":19,"discussions":[{"author":{"id":1283461,"avatar":"https://static001.geekbang.org/account/avatar/00/13/95/85/15cd21c2.jpg","nickname":"杨锋","note":"","ucode":"85A7828A538FB0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284938,"discussion_content":"为毛你的图像会动","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592674020,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180756,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1582381699,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"70301858435","product_id":100039001,"comment_content":"设计模式_43:<br># 作业<br>Java的类加载有一个双亲委托的机制(递归地让父加载器在cache中寻找，如果都找不到才会让当前加载器去加载)，这个机制保证了有诸多好处，与今天的内容相关的就是：不管类名是否相同，不同加载器，加载的一定是不同的类。<br>1. 如果两个加载器是父子关系，那么只会被加载一次。<br>2. 如果两个加载器无父子关系，即使加载类名相同的类也会按照不同的类处理。<br><br>综上，Java的单例对象对象是类加载器唯一的。<br><br><br># 感想<br><br>今天的内容，有一个感想: 程序员的头脑中，要能够想象程序运行的过程中，内存中发生了什么，我们要对底层多一些研究，否则真的不知其所以然。","like_count":16},{"had_liked":false,"id":177238,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1581330286,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"40236035950","product_id":100039001,"comment_content":"老师讲的多例模式应该就是享元模式，常量池、数据库连接池经常使用。","like_count":9,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474569,"discussion_content":"你指出的这点很好。关于封装，有两种理解，一种是狭义的面向对象特性：封装是一种信息隐藏，需要把数据和方法放到一起，而c语言实现的代码，数据和方法是分离的。封装的另一种广义的理解，可以包含你指的封装函数。抽象实际上我们前面章节中也讲到过，比较没有特异性，有的时候不看做面向对象的特性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573785954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1039204,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","nickname":"中年男子","note":"","ucode":"027C86B3370150","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51085,"discussion_content":"那个例子里，老师说只用到了类和对象， 没有用到面向对象的四大特性，是因为这个例子只是用到了类来组织代码的方式，将数据和方法绑定到了一起。并没有权限访问控制， 比如暴露方法来修改User类的三个成员：name、age、gender。 所以说的没有用到的&#34;封装&#34;是比较狭义的“封装”，当然封装成类也是封装，只是广义上的封装。  以上，我是这么理解的。欢迎交流。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1573809254,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1117268,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0c/54/b829b6cc.jpg","nickname":"未未的未来","note":"","ucode":"7E271691F5BF65","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1039204,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","nickname":"中年男子","note":"","ucode":"027C86B3370150","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":51119,"discussion_content":"是的，有些概念没有明显的边界，不是非黑即白，提高开发效率就好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573813161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":51085,"ip_address":""},"score":51119,"extra":""}]},{"author":{"id":1368038,"avatar":"https://static001.geekbang.org/account/avatar/00/14/df/e6/bd1b3c0b.jpg","nickname":"Jesse","note":"","ucode":"727CA882B84DA0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50879,"discussion_content":"如果从贴近底层和性能上考虑为什么不用汇编语言呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573781601,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1117268,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0c/54/b829b6cc.jpg","nickname":"未未的未来","note":"","ucode":"7E271691F5BF65","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1368038,"avatar":"https://static001.geekbang.org/account/avatar/00/14/df/e6/bd1b3c0b.jpg","nickname":"Jesse","note":"","ucode":"727CA882B84DA0","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":50961,"discussion_content":"我只是一种猜测吧，另外，C语言是比汇编语言高级一些的语言，在开发效率上也许是一方面的考虑吧。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573793188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":50879,"ip_address":""},"score":50961,"extra":""},{"author":{"id":1039204,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","nickname":"中年男子","note":"","ucode":"027C86B3370150","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1368038,"avatar":"https://static001.geekbang.org/account/avatar/00/14/df/e6/bd1b3c0b.jpg","nickname":"Jesse","note":"","ucode":"727CA882B84DA0","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":51087,"discussion_content":"汇编离人“太远”，C语言比较折中？ ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573809351,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":50879,"ip_address":""},"score":51087,"extra":""},{"author":{"id":1368038,"avatar":"https://static001.geekbang.org/account/avatar/00/14/df/e6/bd1b3c0b.jpg","nickname":"Jesse","note":"","ucode":"727CA882B84DA0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1039204,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","nickname":"中年男子","note":"","ucode":"027C86B3370150","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":51144,"discussion_content":"感觉是，汇编对于人来阅读有难度，c就易于人阅读了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573816732,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":51087,"ip_address":""},"score":51144,"extra":""}]},{"author":{"id":1368038,"avatar":"https://static001.geekbang.org/account/avatar/00/14/df/e6/bd1b3c0b.jpg","nickname":"Jesse","note":"","ucode":"727CA882B84DA0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50876,"discussion_content":"使用c语言编写的例子，你说的封装了函数，并不是指面向对象语言中的封装，面向对象的封装是抽象出数据和方法，封装到一个类中。你说的封装的函数，只是实现这个函数所需要的步骤的集合。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573781487,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1117268,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0c/54/b829b6cc.jpg","nickname":"未未的未来","note":"","ucode":"7E271691F5BF65","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1368038,"avatar":"https://static001.geekbang.org/account/avatar/00/14/df/e6/bd1b3c0b.jpg","nickname":"Jesse","note":"","ucode":"727CA882B84DA0","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":50960,"discussion_content":"我可能没说清楚，是C++实现的那个例子，属性和函数都已经在类里了，就是有些不太明白为什么这不是一种封装。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1573793085,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":50876,"ip_address":""},"score":50960,"extra":""}]}]},{"had_liked":false,"id":177115,"user_name":"Ken张云忠","can_delete":false,"product_type":"c1","uid":1134288,"ip_address":"","ucode":"D0BAC9FC17DE2B","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","comment_is_top":false,"comment_ctime":1581293428,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"31646064500","product_id":100039001,"comment_content":"实际上，对于 Java 语言来说，单例类对象的唯一性的作用范围并非进程，而是类加载器（Class Loader），你能自己研究并解释一下为什么吗？<br>因为Jvm中类加载时采用的是双亲委派模式，对于类的唯一性的确定是通过类全名和类加载器实例一起来实现的，jdk8可以支持多个Java应用共享jre下的很多类实例就是通过扩展类加载器实现的，所以这里所说单例类实例唯一性的作用范围是类加载器指的就是即使类全名相同的类文件也必须要保证被同个类应用类加载器加载。","like_count":7,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474683,"discussion_content":"会不会有歧义呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574129769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2463502,"avatar":"https://static001.geekbang.org/account/avatar/00/25/97/0e/d79c9a2a.jpg","nickname":"风清扬","note":"","ucode":"0C252B0910677F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":357073,"discussion_content":"会有歧义，确实是。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615730942,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1898112,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/f6/80/85ec2c2a.jpg","nickname":"WilliamVector","note":"","ucode":"E0D3C3D4FCB7C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304263,"discussion_content":"特定用途的字符串转换，最好不要覆盖为toString。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599531423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":178739,"user_name":"桂城老托尼","can_delete":false,"product_type":"c1","uid":1306032,"ip_address":"","ucode":"139E4B8EE88B79","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJcxSpNMqwqyicMvdOSr9ic0p1ABiauHnv7g7YQVSJuoHPoQbYDu3YzdpgmSAk2KricUBQ5yibWBWIq75w/132","comment_is_top":false,"comment_ctime":1581811987,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"27351615763","product_id":100039001,"comment_content":"感谢分享<br>1，线程唯一性一节，threadlocal也好，记录线程id的方式也好，如果是线程池的话，需要确认下是否需要clean。另外如果线程能被销毁，再创建的线程id是否会重复？如果重复在某些场景下可能会有问题。<br>2，分布式环境下的单例一节，针对id生成器这种频繁访问的服务，如果频繁加锁效率比较低，可以考虑常用的sequnce方案，每个进程持有一段id range，保证每个(分布式)进程某时间区间不重复即可。 <br>3，尝试回答下课堂讨论，不同的classloader实例加载的class天然不属于一个，new出来的对象应该也不是一个，classloader是类的隔离级别。 <br><br><br><br>","like_count":6,"discussions":[{"author":{"id":1608615,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8b/a7/b6471f02.jpg","nickname":"远逝的栀子花","note":"","ucode":"77DCF684BABEEF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556224,"discussion_content":"感觉跟C++的类对象函数指针是差不多的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647255279,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217556,"user_name":"郭强","can_delete":false,"product_type":"c1","uid":1192928,"ip_address":"","ucode":"38F36F0F4CC775","user_header":"https://static001.geekbang.org/account/avatar/00/12/33/e0/387ab6fd.jpg","comment_is_top":false,"comment_ctime":1589533462,"is_pvip":false,"replies":[{"id":"86786","content":"没啥用的，我就是引申讲一下，训练一下逻辑思维能力","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1594903794,"ip_address":"","comment_id":217556,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23064369942","product_id":100039001,"comment_content":"老师 能讲一讲 线程唯一和集群环境下唯一的单例的实际应用场景吗。光知道如何实现，不知道所谓何用，就变成了屠龙术了。","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474635,"discussion_content":"有的 实战篇","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574040050,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134861,"avatar":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","nickname":"James","note":"","ucode":"48B0F2A334D1C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53598,"discussion_content":"哈哈,全篇这句话就吸引人,却没能深刻理解.\n\n如何给业务建模，如何将真实的世界映射为类或者对象，这让我们更加能聚焦到业务本身，而不是思考如何跟机器打交道\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574178007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1433535,"avatar":"https://static001.geekbang.org/account/avatar/00/15/df/bf/96b50d1e.jpg","nickname":"😚 46","note":"","ucode":"EED0EBBBF80A43","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1134861,"avatar":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","nickname":"James","note":"","ucode":"48B0F2A334D1C1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369063,"discussion_content":"去看《编程的逻辑》李运华老师在这本书里给了完整的方法论，很赞👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618917532,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53598,"ip_address":""},"score":369063,"extra":""}]},{"author":{"id":1433535,"avatar":"https://static001.geekbang.org/account/avatar/00/15/df/bf/96b50d1e.jpg","nickname":"😚 46","note":"","ucode":"EED0EBBBF80A43","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52404,"discussion_content":"期待~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574047624,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186313,"user_name":"寒溪","can_delete":false,"product_type":"c1","uid":1001970,"ip_address":"","ucode":"67B9F1A1C15A20","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/f2/25cfa472.jpg","comment_is_top":false,"comment_ctime":1583824312,"is_pvip":false,"discussion_count":4,"race_medal":1,"score":"14468726200","product_id":100039001,"comment_content":"请教一下老师<br>线程唯一的单例模式中<br>instances.putIfAbsent(currentThreadId, new IdGenerator());<br><br>如果实例已经存在，那后续每次请求是不是都会创建一个游离状态的IdGenerator。<br>这样会不会造成对象的频繁创建与消亡，增加GC压力。<br><br>但是看好多源码中都是这么用的，还请您指教。","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474591,"discussion_content":"这个也算是个不错的理由。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573785440,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2806043,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLBFkSq1oiaEMRjtyyv4ZpCI0OuaSsqs04ODm0OkZF6QhsAh3SvqhxibS2n7PLAVZE3QRSn5Hic0DyXg/132","nickname":"ddh","note":"","ucode":"8E852375365F16","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541894,"discussion_content":"rust呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640596202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1177921,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f9/41/411b1753.jpg","nickname":"石仔","note":"","ucode":"974E4604CE2213","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291061,"discussion_content":"或者说cpu本身就是个面向过程的物件,所以只能接受面向过程的指令所以只有面向过程的语言能更好更快的操作它.面向对象的语言必须翻译成面向对象的指令","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594694652,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1177921,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f9/41/411b1753.jpg","nickname":"石仔","note":"","ucode":"974E4604CE2213","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291060,"discussion_content":"直接操作系统资源是啥意思,系统底层是C写的,那么必然只能通过c提供的接口来调用底层,所有上层应用都无法避免把.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594694498,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177101,"user_name":"LJK","can_delete":false,"product_type":"c1","uid":1199213,"ip_address":"","ucode":"12B2441099FF1D","user_header":"https://static001.geekbang.org/account/avatar/00/12/4c/6d/c20f2d5a.jpg","comment_is_top":false,"comment_ctime":1581274515,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"14466176403","product_id":100039001,"comment_content":"对于集群下的单例实现加锁有点迷惑，对象第一次实例化之后再通过getInstance就不会加锁了直接返回实例，由此有两个问题不太明白：<br>1. 这时如果多个进程都拿到了这个实例，save操作需要做并发控制吗？（还是就是synchronize就行了？对java不是很熟悉）<br>2. 这时该进程没有锁，但是freeInstance会释放一把锁，会有重复释放锁的问题吗？","like_count":3,"discussions":[{"author":{"id":1141173,"avatar":"https://static001.geekbang.org/account/avatar/00/11/69/b5/1e1731cc.jpg","nickname":"zs阿帅","note":"","ucode":"07A54AE7F1CAFF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":165620,"discussion_content":"锁式分布式锁","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1581306956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1261959,"avatar":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","nickname":"Better me","note":"","ucode":"CADF08D357489A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334408,"discussion_content":"这里每次freeInstance都会把instance=null，所以不会存在你说的那种情况","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607841867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309803,"discussion_content":"看代码是线程先加锁public synchronized static IdGenerator getInstance()，此时不同进程的线程可以并发？进程加锁（distributedLock），加载对象，由于synchroinzed 是可重入锁进入freeInstance方法，保存对象至外部存储，释放对象，释放distributedLock,释放synchronized同步锁，完成一个过程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601448122,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1199213,"avatar":"https://static001.geekbang.org/account/avatar/00/12/4c/6d/c20f2d5a.jpg","nickname":"LJK","note":"","ucode":"12B2441099FF1D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":167093,"discussion_content":"我是说instance!=null的时候freeInstance的使用，不是创建对象的时候","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581446237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219448,"user_name":"子夜2104","can_delete":false,"product_type":"c1","uid":1070286,"ip_address":"","ucode":"C4FF54AEA6002F","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/ce/92029d2f.jpg","comment_is_top":false,"comment_ctime":1590026856,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10179961448","product_id":100039001,"comment_content":"看了这一节，感觉问题更多了？<br>Java中单例的唯一性，范围确定在类加载器中。假如现在，我运行了一个JVM，两个JavaWeb（两个端口，两个进程），在每个JavaWeb中，写了一个单例，那么这两个单例是唯一的吗？是在哪个范围内唯一呢？另外，Boot ClassLoader这个类加载器是在一个JVM中唯一吗？还是在一个JavaWeb，一个进程中唯一呢？","like_count":2,"discussions":[{"author":{"id":1035745,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cd/e1/4fbf6b89.jpg","nickname":"军","note":"","ucode":"7F19DD6254BDC5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":403022,"discussion_content":"这里概念你搞混了，一个jvm是一个进程，两个javaweb他也是运行在一个jvm里，只是类加载器隔离了，最典型的就是tomcat，他打破了双亲委派机制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633998821,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1314724,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0f/a4/0b49469f.jpg","nickname":"木子00","note":"","ucode":"8F78CA722EB29B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282417,"discussion_content":"很好的问题。我也想知道。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591968051,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":178334,"user_name":"小喵喵","can_delete":false,"product_type":"c1","uid":1062444,"ip_address":"","ucode":"FDBBB2A59DB8B6","user_header":"https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg","comment_is_top":false,"comment_ctime":1581662729,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10171597321","product_id":100039001,"comment_content":"IdGenerator.freeInstance(); 应该是idGenerator.freeInstance();","like_count":2,"discussions":[{"author":{"id":1609051,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8d/5b/383a49e4.jpg","nickname":"charmsongo","note":"","ucode":"4FBEE716E93A1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411395,"discussion_content":"心细","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635920257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1406090,"avatar":"https://static001.geekbang.org/account/avatar/00/15/74/8a/d5b0cf30.jpg","nickname":"kyl","note":"","ucode":"DBDFD0FEB5A135","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287639,"discussion_content":"优秀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593501283,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177815,"user_name":"杨杰","can_delete":false,"product_type":"c1","uid":1131823,"ip_address":"","ucode":"74817EA9499843","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/2f/b0b0dd74.jpg","comment_is_top":false,"comment_ctime":1581507564,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10171442156","product_id":100039001,"comment_content":"在多例的伪代码里面：<br> public BackendServer getInstance(long serverNo) {   <br>     return serverInstances.get(serverNo); <br> } <br>是不是应该改成：<br> public static BackendServer getInstance(long serverNo) {   <br>     return serverInstances.get(serverNo); <br> } ","like_count":2},{"had_liked":false,"id":177123,"user_name":"Snway","can_delete":false,"product_type":"c1","uid":1102888,"ip_address":"","ucode":"0AD31AECA8A8F7","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/28/3b6546e8.jpg","comment_is_top":false,"comment_ctime":1581297138,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10171231730","product_id":100039001,"comment_content":"对于类加载器，可以简单理解：不同类加载器之间命名空间不一样，不同类加载器加载出来的类实例是不一样的，所以如果使用多个类加载器，可能会导致单例失效而产生多个实例","like_count":2},{"had_liked":false,"id":256980,"user_name":"Tomy","can_delete":false,"product_type":"c1","uid":1192601,"ip_address":"","ucode":"D7E49E90B0D60F","user_header":"https://static001.geekbang.org/account/avatar/00/12/32/99/91b58bf7.jpg","comment_is_top":false,"comment_ctime":1603804016,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5898771312","product_id":100039001,"comment_content":"视频比音频好学，至少视频可以看到代码的运行结果，音频根本看不到，把代码复制到本地跑一下发现spring框架下<br>org..util.包下有一个同名的IdGenerator导致代码跑起来的效果不确定就是老师的效果比如实现线程唯一的单例时打印的结果都是{1=IdGenerator@470e2030}看不出不同线程的对象，都是同一个线程对应同一个对象","like_count":1,"discussions":[{"author":{"id":1940562,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/9c/52/dc770378.jpg","nickname":"yang","note":"","ucode":"67C86E09BA6E4B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368837,"discussion_content":"哪里有视频？为什么我找不到？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618841667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239744,"user_name":"静心","can_delete":false,"product_type":"c1","uid":1335457,"ip_address":"","ucode":"EB264FA6519FDA","user_header":"https://static001.geekbang.org/account/avatar/00/14/60/a1/8f003697.jpg","comment_is_top":false,"comment_ctime":1596631027,"is_pvip":true,"replies":[{"id":"89267","content":"没必要序列方法的。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1597453780,"ip_address":"","comment_id":239744,"utype":1}],"discussion_count":1,"race_medal":5,"score":"5891598323","product_id":100039001,"comment_content":"序列化方式实现单例似乎有问题，因为序列化的一般只能序列化对象的属性，对于方法的实例化，除非使用字节码。另外，如果一个类如果没有属性只有方法呢？","like_count":1},{"had_liked":false,"id":178614,"user_name":"FIGNT","can_delete":false,"product_type":"c1","uid":1540988,"ip_address":"","ucode":"D9DB185AE9E67C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKZ16iaIia0029oI1Qh5NicibpbTiaBAaCOPYXoLplKHr6uQ2rSVxPZanBvpMcL2NuhwKQYCFnaHP5tedQ/132","comment_is_top":false,"comment_ctime":1581759695,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5876726991","product_id":100039001,"comment_content":"类加载时采用双亲委派的机制，优先级排序启动加载器&gt;扩展加载器&gt;应用加载器&gt;自定义加载器。这种机制保证相同的类只能加载一次，而且已java类库的类优先加载，而自定义的后加载。比如自己实现一个String类,类库中也有String类，加载哪个呢？有个优先级，只有高优先级没有加载时低优先级的才能加载。从这个角度看其实单例的唯一性作用于ClassLoader。只不过双亲委派机制保证只有一个类加载器加载。如果没有双亲委派机制，那么实例在类加载器中唯一，在类加载器间不唯一。所以准确说单例类对象的唯一性的作用范围并非进程，而是类加载器。","like_count":1},{"had_liked":false,"id":177750,"user_name":"hanazawakana","can_delete":false,"product_type":"c1","uid":1251721,"ip_address":"","ucode":"E0F6FACBFE7D15","user_header":"https://static001.geekbang.org/account/avatar/00/13/19/89/20488013.jpg","comment_is_top":false,"comment_ctime":1581489898,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5876457194","product_id":100039001,"comment_content":"ThreadLocal底层是基于ThreadLocalMap，他有一个Entry[] table，好像并不是基于HashMap？","like_count":1,"discussions":[{"author":{"id":1082785,"avatar":"https://static001.geekbang.org/account/avatar/00/10/85/a1/2442332c.jpg","nickname":"郭俊杰","note":"","ucode":"D328E5738A4413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":264841,"discussion_content":"不亏是编程界的小学生，不把我们py放在眼里呀。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589350874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177741,"user_name":"Algo","can_delete":false,"product_type":"c1","uid":1119682,"ip_address":"","ucode":"D7B6D147F793E8","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/c2/cd8052c8.jpg","comment_is_top":false,"comment_ctime":1581487832,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5876455128","product_id":100039001,"comment_content":"如果这个类已经被加载，则不会重复加载。如加载A类则也要确保其父类已经被加载完成。且不同的类在JVM中有不同的加载器。","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480596,"discussion_content":"不算，是一种新的编程范式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578379070,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177463,"user_name":"小刀","can_delete":false,"product_type":"c1","uid":1351063,"ip_address":"","ucode":"94DF8C45E09E42","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/iaByN5IfYbE9jMtWrtTDXtPEIHeV77KW1p7ZkiasiaGgA50VXaibo4fbp5ib2JkFP3iaIe4AUudLibufkEIofu5euCNHg/132","comment_is_top":false,"comment_ctime":1581397002,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5876364298","product_id":100039001,"comment_content":"不同类加载器之间命名空间不一样，不同类加载器加载出来的类实例是不一样的，所以如果使用多个类加载器，可能会导致单例失效而产生多个实例","like_count":1},{"had_liked":false,"id":177149,"user_name":"唐龙","can_delete":false,"product_type":"c1","uid":1471657,"ip_address":"","ucode":"87A10AE04F2037","user_header":"https://static001.geekbang.org/account/avatar/00/16/74/a9/5eb3ebc6.jpg","comment_is_top":false,"comment_ctime":1581303654,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5876270950","product_id":100039001,"comment_content":"不是很懂为什么需要多例模式，什么情况下需要用到多例模式。","like_count":1},{"had_liked":false,"id":177100,"user_name":"黄林晴","can_delete":false,"product_type":"c1","uid":1362631,"ip_address":"","ucode":"B15C38AECDA88F","user_header":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","comment_is_top":false,"comment_ctime":1581269163,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5876236459","product_id":100039001,"comment_content":"打卡","like_count":1},{"had_liked":false,"id":339043,"user_name":"夏天","can_delete":false,"product_type":"c1","uid":1285986,"ip_address":"","ucode":"F29D56F9265751","user_header":"https://static001.geekbang.org/account/avatar/00/13/9f/62/960eecc3.jpg","comment_is_top":false,"comment_ctime":1647870634,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647870634","product_id":100039001,"comment_content":"同一个类文件被不同类加载器加载认为是不同的类对象，判断是否同一个类 处理类的全路径相同之外，还要看是否被同一类加载器加载。","like_count":0},{"had_liked":false,"id":330962,"user_name":"Bumblebee","can_delete":false,"product_type":"c1","uid":2051293,"ip_address":"","ucode":"B879C8A511D08D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","comment_is_top":false,"comment_ctime":1642326863,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1642326863","product_id":100039001,"comment_content":"池化技术，是不是可以理解为用多例模式实现的","like_count":0},{"had_liked":false,"id":319715,"user_name":"charmsongo","can_delete":false,"product_type":"c1","uid":1609051,"ip_address":"","ucode":"4FBEE716E93A1A","user_header":"https://static001.geekbang.org/account/avatar/00/18/8d/5b/383a49e4.jpg","comment_is_top":false,"comment_ctime":1635920872,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635920872","product_id":100039001,"comment_content":"总结<br>1、如何理解单例模式中的唯一性<br>\t一个类只允许创建一个实例<br>\t单例类中对象的唯一性的作用范围是进程内的，在进程间是不唯一的。<br>\t“进程唯一”指的是进程内唯一，进程间不唯一<br>\t“进程唯一”还代表了线程内、线程间都唯一，这也是“进程唯一”和“线程唯一”的区别之处<br>2、如何实现线程唯一的单例？<br>\t线程唯一”指的是线程内唯一，线程间可以不唯一<br>\t通过一个 HashMap 来存储对象，其中 key 是线程 ID，value 是对象实例<br>3、如何实现集群环境下的单例？<br>\t“集群唯一”就相当于是进程内唯一、进程间也唯一<br>\t实现方法：把这个单例对象序列化并存储到外部共享存储区（比如文件）<br>4、如何实现一个多例模式？<br>\t一个类可以创建多个对象，但是个数是有限制的，比如只能创建 3 个对象<br>\t另一种理解方式：同一类型的只能创建一个对象，不同类型的可以创建多个对象<br>\t有点类似工厂模式，不同之处是，多例模式创建的对象都是同一个类的对象，而工厂模式创建的是不同子类的对象","like_count":0},{"had_liked":false,"id":317472,"user_name":"wuhan07","can_delete":false,"product_type":"c1","uid":1136385,"ip_address":"","ucode":"0604161D33D2D1","user_header":"https://static001.geekbang.org/account/avatar/00/11/57/01/7d835109.jpg","comment_is_top":false,"comment_ctime":1634806612,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634806612","product_id":100039001,"comment_content":"集群模式的单例，我认为应该使用分布式共识算法实现，要保障数据、逻辑都在一起才能称为集群单例","like_count":0},{"had_liked":false,"id":307629,"user_name":"Geek_b7eb88","can_delete":false,"product_type":"c1","uid":1573715,"ip_address":"","ucode":"0EB46381D9B1CB","user_header":"","comment_is_top":false,"comment_ctime":1629184276,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629184276","product_id":100039001,"comment_content":"通过Map的key标识相同或不同的类对象，感觉就已经玩出花儿了哈哈。","like_count":0},{"had_liked":false,"id":289808,"user_name":"Geek_0b6c55","can_delete":false,"product_type":"c1","uid":2208709,"ip_address":"","ucode":"A442CE216C46D6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIGuXhUHpOhmOLk8udeZaNUguZScYkxAwGoYwuGDmyibpguges7Jj91D8YzgaP2BW7Eu4FvvNMOHHg/132","comment_is_top":false,"comment_ctime":1619182374,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619182374","product_id":100039001,"comment_content":"BackendServer程序不对吧。没有公共构造函数，不能创建实例，也没有静态函数，不能调用类方法。","like_count":0},{"had_liked":false,"id":289124,"user_name":"Geek_b7f2fb","can_delete":false,"product_type":"c1","uid":2519809,"ip_address":"","ucode":"42F51DE78C079B","user_header":"","comment_is_top":false,"comment_ctime":1618882883,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618882883","product_id":100039001,"comment_content":"基于线程的单例在多线程情况下就可以认为是多例对象","like_count":0},{"had_liked":false,"id":289069,"user_name":"yang","can_delete":false,"product_type":"c1","uid":1940562,"ip_address":"","ucode":"67C86E09BA6E4B","user_header":"https://static001.geekbang.org/account/avatar/00/1d/9c/52/dc770378.jpg","comment_is_top":false,"comment_ctime":1618841310,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618841310","product_id":100039001,"comment_content":"我猜java的class. loader应该是跨进程的吧。老师说了进程之间不共享地址空间，类不跨进程的话应该无法在不同函数间被调用吧？java的单例模式在class. loader中唯一，应该也是为了更好的共享类吧？纯属臆测哈","like_count":0},{"had_liked":false,"id":288083,"user_name":"Better me","can_delete":false,"product_type":"c1","uid":1261959,"ip_address":"","ucode":"CADF08D357489A","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","comment_is_top":false,"comment_ctime":1618292162,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1618292162","product_id":100039001,"comment_content":"我们写的代码经过编译器编译生成class文件的jar包，通过机器安装好的jdk环境命令能让操作系统开启一个jvm进程来执行class文件，而jvm实例中的类加载会通过加载、链接、初始化等操作，将磁盘的class文件加载进jvm进程分配的内存中从而生成相应的类对象实例<br>由于双亲委派机制的存在可以保证某些单例类仅被加载一次，从而实现进程内唯一；<br>但是由于自定义加载器的存在，以及不同加载器实例的存在那么就有可能导致class文件被加载多次并生成不同的类对象实例，从而无法实现进程内唯一，而是类加载器唯一。","like_count":0},{"had_liked":false,"id":286258,"user_name":"Geek_86eac6","can_delete":false,"product_type":"c1","uid":1787022,"ip_address":"","ucode":"8C02E398CC6A35","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI4CBQHuLDWOdicOl1elTdSicqMyY1s5JDWXiaHsSk0VSWaVe0U6CTo701ZGz9h6MvibsAGKnvVq7xxFw/132","comment_is_top":false,"comment_ctime":1617235443,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617235443","product_id":100039001,"comment_content":"这里要理解Java的双亲委派模型，不同的类加载器，加载的同一个类也是不同的。","like_count":0},{"had_liked":false,"id":283815,"user_name":"Chloe","can_delete":false,"product_type":"c1","uid":1004953,"ip_address":"","ucode":"C4848ED5B35752","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/99/4bdadfd3.jpg","comment_is_top":false,"comment_ctime":1615946065,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615946065","product_id":100039001,"comment_content":"需要再次感叹一下，王老师真的功力深厚，受教了！谢谢！","like_count":0},{"had_liked":false,"id":275102,"user_name":"fenciso","can_delete":false,"product_type":"c1","uid":2298546,"ip_address":"","ucode":"6546EA008BEEE8","user_header":"https://static001.geekbang.org/account/avatar/00/23/12/b2/c89b16e9.jpg","comment_is_top":false,"comment_ctime":1611307709,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1611307709","product_id":100039001,"comment_content":"王老师，我有个疑惑，麻烦您抽空解答一下，非常感谢。 在说到集群环境单例的时候， “为了保证任何时刻在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取”  这句话的对象加锁有点疑问，进程间对象不是独立的吗，一个进程内对象加锁能限制其他进程再获取？还是说这个加锁的意思是指在“外部共享存储区”进行的加锁？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474648,"discussion_content":"理解的没错。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574130139,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":267642,"user_name":"当你的世界里有风吹过","can_delete":false,"product_type":"c1","uid":2051946,"ip_address":"","ucode":"42712891366309","user_header":"https://static001.geekbang.org/account/avatar/00/1f/4f/6a/0a6b437e.jpg","comment_is_top":false,"comment_ctime":1607853958,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607853958","product_id":100039001,"comment_content":"如果我想实现分布式的环境的变量同步，是否可通过集群单例来实现！ 虽然可使用中间件来解决，但是需要依赖中间件！","like_count":0},{"had_liked":false,"id":261702,"user_name":"郑大钱","can_delete":false,"product_type":"c1","uid":1503067,"ip_address":"","ucode":"114CF48056880E","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/5b/ff28088f.jpg","comment_is_top":false,"comment_ctime":1605494321,"is_pvip":false,"replies":[{"id":"96135","content":"������","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606701272,"ip_address":"","comment_id":261702,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605494321","product_id":100039001,"comment_content":"基于线程的单例暂时先不考虑了，多线程编程对我来说酷似洪水猛兽，不好掌控，更别提基于线程的单例了。<br>进程间的单例直接被iOS的沙盒机制封杀，不要想了。<br>app开发用得最多的就是经典的单例，多例可能会用得到，mark。","like_count":0,"discussions":[{"author":{"id":1328354,"avatar":"https://static001.geekbang.org/account/avatar/00/14/44/e2/763526e9.jpg","nickname":"程晓擘","note":"","ucode":"96986D5AE2B96C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51155,"discussion_content":"过不了多久，AI就可以编程了，我们提供逻辑，计算机就帮我们把代码写好了。哈哈。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573818072,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1206787,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6a/03/cb597311.jpg","nickname":"远心","note":"","ucode":"1157202C315655","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50978,"discussion_content":"你这个想法挺好，我觉得可以起个名字，叫做面向思路编程。这感觉比写需求规格说明书更容易实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573795677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1025003,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a3/eb/d26459ae.jpg","nickname":"时光勿念","note":"","ucode":"72C8EC5A62C700","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1206787,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6a/03/cb597311.jpg","nickname":"远心","note":"","ucode":"1157202C315655","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51017,"discussion_content":"哈哈，谢谢夸奖，不过我觉得面向思路不太好听（￣︶￣）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573799681,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":50978,"ip_address":""},"score":51017,"extra":""}]},{"author":{"id":1025003,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a3/eb/d26459ae.jpg","nickname":"时光勿念","note":"","ucode":"72C8EC5A62C700","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50916,"discussion_content":"有道理，框架层面可以解决，这样来说我想要的可能只是一种更直接的描述设计思路的方式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573786291,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1115439,"avatar":"https://static001.geekbang.org/account/avatar/00/11/05/2f/5d93a37b.jpg","nickname":"严旭珺","note":"","ucode":"A74F0098478FC6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50846,"discussion_content":"我觉得这不是语言层面解决的问题，这应该是框架层面解决的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573779615,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":254649,"user_name":"笨鸟","can_delete":false,"product_type":"c1","uid":1236320,"ip_address":"","ucode":"68029ADA76AA5A","user_header":"https://static001.geekbang.org/account/avatar/00/12/dd/60/a6a4f79a.jpg","comment_is_top":false,"comment_ctime":1603161909,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603161909","product_id":100039001,"comment_content":"提到集群单例,第一个想到的就是session共享","like_count":0},{"had_liked":false,"id":248102,"user_name":"神毓逍遥","can_delete":false,"product_type":"c1","uid":2147220,"ip_address":"","ucode":"83351CB18B190E","user_header":"https://static001.geekbang.org/account/avatar/00/20/c3/94/e89ebc50.jpg","comment_is_top":false,"comment_ctime":1600009909,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1600009909","product_id":100039001,"comment_content":"单例模式下的进程唯一，我写了小demo，发现不同进程实例对应是一样的，代码如下：<br>import threading<br><br><br>class Singleton(object):<br>    # 利用类与基于类创建的所有示例共享类属性的特点<br>    # 基于类 唯一一把锁<br>    _instance_lock = threading.Lock()<br><br>    def __init__(self, name, age, *args, **kwargs):<br>        print(&#39;init&#39;, args, kwargs)<br>        self.name = name<br>        self.age = age<br>        self.args = args<br>        self.kwargs = kwargs<br><br>    def __new__(cls, *args, **kwargs):<br>        print(&#39;new&#39;, args, kwargs)<br>        # 双重检测，一个也不能少<br>        if not hasattr(cls, &#39;_instance&#39;):<br>            with cls._instance_lock:<br>                if not hasattr(cls, &#39;_instance&#39;):<br>                    # 这里不要写成object.__new__(cls, *args, **kwargs)<br>                    # new创建实例，此时还没有绑定参数，init 里初始化参数<br>                    cls._instance = object.__new__(cls)<br>        return cls._instance<br><br><br>if __name__ == &#39;__main__&#39;:<br>    import os<br>    p = os.fork()<br>    if p == 0:<br>        # child process<br>        liming = Singleton(&#39;liming&#39;, 12, &#39;male&#39;, wife=&#39;limei&#39;)<br>        print(id(liming))<br>        print(&#39;执行子进程, pid={} ppid={} p={}&#39;.format(os.getpid(), os.getppid(), p))<br>    elif p &gt; 0:<br>        # parent process<br>        liming2 = Singleton(&#39;liming&#39;, 18, &#39;male&#39;, wife=&#39;limei&#39;)<br>        print(id(liming2))<br>        print(&#39;执行父进程, pid={} ppid={} p={}&#39;.format(os.getpid(), os.getppid(), p))<br>    else:<br>        raise ValueError(&#39; fork error&#39;)","like_count":0},{"had_liked":false,"id":247506,"user_name":"Geek_646ed2","can_delete":false,"product_type":"c1","uid":1908375,"ip_address":"","ucode":"3A1B8A293E30D3","user_header":"","comment_is_top":false,"comment_ctime":1599728733,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1599728733","product_id":100039001,"comment_content":"分布式的单例id生成器 加锁之后，其他线程就不能访问了对么，只有在释放锁之后，其他才可以继续访问，访问又加锁。是这样的设计的思路吗？？","like_count":0,"discussions":[{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309827,"discussion_content":"看代码是线程先加锁public synchronized static IdGenerator getInstance()，此时不同进程的线程可以并发？接着进程加锁（distributedLock），加载对象，由于synchroinzed 是可重入锁进入freeInstance方法，保存对象至外部存储，释放对象，释放distributedLock,释放synchronized同步锁，完成一个过程。整个过程是两层锁，两次加锁，两次解锁。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601454709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244203,"user_name":"北风一叶","can_delete":false,"product_type":"c1","uid":1087302,"ip_address":"","ucode":"30310E66341D2A","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/46/fe1f21d8.jpg","comment_is_top":false,"comment_ctime":1598428025,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598428025","product_id":100039001,"comment_content":"单例模式就解决了一个问题：保证一个对象全局唯一。方式有：<br>1. 懒汉式<br>2.饿汉式<br>3. 双重检查式<br>4. 工厂式<br>5. 静态内部类<br>6. 序列化式","like_count":0},{"had_liked":false,"id":239358,"user_name":"Java垒墙工程师","can_delete":false,"product_type":"c1","uid":1937062,"ip_address":"","ucode":"E76AE44A9C76AE","user_header":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","comment_is_top":false,"comment_ctime":1596510182,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596510182","product_id":100039001,"comment_content":"都在聊双亲委派，没人回答问题啊。<br>    1、隔离性：以tomcat为例，系统的classloader和用户区是隔离的，多个应用之间也是隔离的<br>    2、兼容性：兼容旧接口新老版本相同名称对象的使用","like_count":0},{"had_liked":false,"id":238699,"user_name":"业余爱好者","can_delete":false,"product_type":"c1","uid":1482915,"ip_address":"","ucode":"A890935A982988","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","comment_is_top":false,"comment_ctime":1596264488,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596264488","product_id":100039001,"comment_content":"单例模式是只有一个全局的对象。spring中的bean一般是单例的，但并不是单例模式，不过是使用了一个对象而已，需要的话，完全可以使用多例，或者手动的new，spring中的“单例”不具有强制性。","like_count":0},{"had_liked":false,"id":237986,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1596022501,"is_pvip":false,"replies":[{"id":"88021","content":"进程间锁 百度了解下","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1596109586,"ip_address":"","comment_id":237986,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1596022501","product_id":100039001,"comment_content":"为了保证任何时刻，在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，还需要显式地将对象从内存中删除，并且释放对对象的加锁。<br><br><br>这个加锁是怎么实现的？？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502608,"discussion_content":"进程间锁 百度了解下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596109586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":237871,"user_name":"秦歌","can_delete":false,"product_type":"c1","uid":1461320,"ip_address":"","ucode":"0C6A3861BF6AFE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/vE94VZiawHoIxqWbPZOGDnl34vXEhhYTRWxiaUaRB1GbaOOQ6tjWib3icYQf9iaQvVJswUkY2wg2PR4FmrzIzmqTibHA/132","comment_is_top":false,"comment_ctime":1595991129,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595991129","product_id":100039001,"comment_content":"这一章属于开拓思维的，也是其它教程和书籍看不到的，这也是作者这门课的魅力，总有一些独到之处，令人受益匪浅","like_count":0},{"had_liked":false,"id":237305,"user_name":"zhou","can_delete":false,"product_type":"c1","uid":1087243,"ip_address":"","ucode":"E1CE8575B3F106","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/0b/a943bcb3.jpg","comment_is_top":false,"comment_ctime":1595774029,"is_pvip":false,"discussion_count":0,"race_medal":3,"score":"1595774029","product_id":100039001,"comment_content":"老师单例能说的这么细 真的GET了","like_count":0},{"had_liked":false,"id":235370,"user_name":"未来小娃","can_delete":false,"product_type":"c1","uid":1047329,"ip_address":"","ucode":"477D166EBB6B70","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/21/d017438c.jpg","comment_is_top":false,"comment_ctime":1594985314,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1594985314","product_id":100039001,"comment_content":"【设计模式笔记40】20200717<br>有段时间未更新了，今天周五终于可以好好学习沉淀了。先说下要点吧：单例唯一有哪些类型以及怎么实现？主要分为集群唯一（redis这样的分布式存储实现）、进程唯一（通过经典单例模式实现的就是进程哪唯一）、线程唯一（通过ThreadLocal实现，简单理解就是一个线程一个map）。继续说下课后的问题，我们最常用的进程唯一，因为我们系统运行的最小单元是实例级别，也就是机器级别，那么只需要考虑怎么实现进程唯一了，如果事业能够Java的话，因为JVM的存在，单例的创建是与虚拟机的类加载机制相关的。我们首先复习下jvm是怎么使用双亲委派模型加载类的：为什么要使用双亲委派模型加载类呢？我们可以反过来思考这个问题，如果不是双亲委派模型的类加载机制，那么会出现什么问题呢？就以Object类来说，因为这个类是Java中最基础的类，所以如果每个用户都自己建立一个Object类的话，那么在系统中就会出现多个不同的Object了，把Object类设置成所有类的父类也就没有什么意义，Java的基石就被破坏了，整个程序将会一片混乱。也就是类实例的比较是基于累加载器维度的。这也就是我们能够基于类加载器做进程内的隔离的原因","like_count":0},{"had_liked":false,"id":230433,"user_name":"『至爱闫』","can_delete":false,"product_type":"c1","uid":1475423,"ip_address":"","ucode":"2A4F0E0DE6C196","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/5f/50f2fdf2.jpg","comment_is_top":false,"comment_ctime":1593390660,"is_pvip":false,"replies":[{"id":"85671","content":"请具体说说，我哪里误导人了？","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1593910395,"ip_address":"","comment_id":230433,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1593390660","product_id":100039001,"comment_content":"多个进程为啥能用synchronized加锁。？不要误导人吖","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499886,"discussion_content":"请具体说说，我哪里误导人了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593910395,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1461320,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/vE94VZiawHoIxqWbPZOGDnl34vXEhhYTRWxiaUaRB1GbaOOQ6tjWib3icYQf9iaQvVJswUkY2wg2PR4FmrzIzmqTibHA/132","nickname":"秦歌","note":"","ucode":"0C6A3861BF6AFE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294761,"discussion_content":"老师用的是DistributedLock和synchronized配合使用。synchronized保证一个进程内的多个线程只能创建一个，也就是进程内唯一，方法级的synchronized不用双重检测。\nDistributedLock保证多个进程只能创建一个，也就是进程间只有一份对象存在\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595990871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1087243,"avatar":"https://static001.geekbang.org/account/avatar/00/10/97/0b/a943bcb3.jpg","nickname":"zhou","note":"","ucode":"E1CE8575B3F106","race_medal":3,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294071,"discussion_content":"synchronized 只是为了保障当前进程 不要造成重复创建。另外老师lock.lock(); 是否应该加一个if判断进行双重检测","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595774603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221297,"user_name":"师哥","can_delete":false,"product_type":"c1","uid":1333376,"ip_address":"","ucode":"A86CD1661D370F","user_header":"https://static001.geekbang.org/account/avatar/00/14/58/80/c9e232b6.jpg","comment_is_top":false,"comment_ctime":1590466289,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590466289","product_id":100039001,"comment_content":"不同类加载器加载同一个类文件，JVM 层面算连个类。JVM 区分类是通过类加载器和类全限定名。","like_count":0},{"had_liked":false,"id":203137,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1586143382,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1586143382","product_id":100039001,"comment_content":"编程语言虽然不是很大的障碍，但是在不同的编程语言之间还是有很大的不同的。比如说就相关的单例模式的概念，其他语言就没有java这样的细节。感觉一直看java代码，都要变成java开发人员了，哈哈哈。虽然语言不同，但是思维基本是相通的。学习思维吧。","like_count":0},{"had_liked":false,"id":202101,"user_name":"豪豪豪豪","can_delete":false,"product_type":"c1","uid":1906479,"ip_address":"","ucode":"BD1A4B3E4D21F4","user_header":"https://static001.geekbang.org/account/avatar/00/1d/17/2f/ea285ab5.jpg","comment_is_top":false,"comment_ctime":1585903283,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1585903283","product_id":100039001,"comment_content":"请问一下进程间单例为什么要用外部的同一个文件呢 只要使用分布式锁 其他的仍然是在类中new 应该也可以完成把？","like_count":0},{"had_liked":false,"id":201337,"user_name":"秋风画扇","can_delete":false,"product_type":"c1","uid":1132356,"ip_address":"","ucode":"5BCBC1422C51EC","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/44/964aa665.jpg","comment_is_top":false,"comment_ctime":1585753097,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585753097","product_id":100039001,"comment_content":"集群环境单例意义不大，用时创建不用销毁会带来额外的开销。只需要做到进程单例，借助分布式锁控制串行执行就好了","like_count":0},{"had_liked":false,"id":201336,"user_name":"秋风画扇","can_delete":false,"product_type":"c1","uid":1132356,"ip_address":"","ucode":"5BCBC1422C51EC","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/44/964aa665.jpg","comment_is_top":false,"comment_ctime":1585752907,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585752907","product_id":100039001,"comment_content":"类使用前都要通过classloader加载class文件，classloader的双亲委派机制保证了类型的唯一性，再次使用不必重新加载。 我们所说的单例就是每个类型创建一个对象，这里不会找到重复类型是实现类型单例的保证。","like_count":0},{"had_liked":false,"id":201328,"user_name":"秋风画扇","can_delete":false,"product_type":"c1","uid":1132356,"ip_address":"","ucode":"5BCBC1422C51EC","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/44/964aa665.jpg","comment_is_top":false,"comment_ctime":1585752053,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585752053","product_id":100039001,"comment_content":"集群唯一没有意义，通过分布式锁控制就好了。每个node使用时创建，用完删除本身也会产生不必要的消耗","like_count":0},{"had_liked":false,"id":195645,"user_name":"请叫我和尚","can_delete":false,"product_type":"c1","uid":1703256,"ip_address":"","ucode":"33A8A1CDA103F9","user_header":"https://static001.geekbang.org/account/avatar/00/19/fd/58/1af629c7.jpg","comment_is_top":false,"comment_ctime":1585209081,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1585209081","product_id":100039001,"comment_content":"集群下的单例，这个思路是否会影响性能问题？因为这样就只能被串行操作了","like_count":0},{"had_liked":false,"id":190218,"user_name":"Q罗","can_delete":false,"product_type":"c1","uid":1792098,"ip_address":"","ucode":"E797378F4DA1F4","user_header":"https://static001.geekbang.org/account/avatar/00/1b/58/62/346dd248.jpg","comment_is_top":false,"comment_ctime":1584617161,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584617161","product_id":100039001,"comment_content":"受教了","like_count":0},{"had_liked":false,"id":190155,"user_name":"smartjia","can_delete":false,"product_type":"c1","uid":1330509,"ip_address":"","ucode":"704BCDE56251D2","user_header":"https://static001.geekbang.org/account/avatar/00/14/4d/4d/58c2ffa1.jpg","comment_is_top":false,"comment_ctime":1584607726,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584607726","product_id":100039001,"comment_content":"反序列化成的对象是一个新的对象。<br>public synchroinzed void freeInstance() { <br>storage.save(this, IdGeneator.class); <br>instance = null; &#47;&#47;释放对象 <br>lock.unlock();<br> }<br>instance 可能被外部引用，此处不能保证对象的被释放。","like_count":0},{"had_liked":false,"id":187106,"user_name":"follow_ice","can_delete":false,"product_type":"c1","uid":1105028,"ip_address":"","ucode":"8B8F59AD343180","user_header":"https://static001.geekbang.org/account/avatar/00/10/dc/84/a35ce74d.jpg","comment_is_top":false,"comment_ctime":1584017207,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584017207","product_id":100039001,"comment_content":"不同类加载器加载的对象是相互隔离的<br>通常情况下由系统的三类加载器加载的对象是相互可见的，但是如果通过自定义的类加载器去加载同一个class类的话，由于其命名空间不同，所以相互不可见。由于对象相互不可见，所以不同命名空间的需要独立的单例对象。","like_count":0},{"had_liked":false,"id":185384,"user_name":"饭粒","can_delete":false,"product_type":"c1","uid":1153455,"ip_address":"","ucode":"4C3220B0D43997","user_header":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","comment_is_top":false,"comment_ctime":1583571509,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583571509","product_id":100039001,"comment_content":"没想到之前认为熟悉的单例模式有这么多扩展。","like_count":0},{"had_liked":false,"id":185262,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1583549452,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583549452","product_id":100039001,"comment_content":"<br>这个是因为ClassLoader的加载机制,向父类抛出,当收到加载一个类的指令,先询问父类是否已经加载了,然后依次网上,直到有,或者明确没有,从而避免了类加载重复的问题,同样,如果显式的指定了某一个类加载器,可能会出现一个类被加载了两次的问题","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510241,"discussion_content":"大部分人都是这个感觉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700720,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2806043,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLBFkSq1oiaEMRjtyyv4ZpCI0OuaSsqs04ODm0OkZF6QhsAh3SvqhxibS2n7PLAVZE3QRSn5Hic0DyXg/132","nickname":"ddh","note":"","ucode":"8E852375365F16","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541895,"discussion_content":"crud吗。。。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640596398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183189,"user_name":"雷刚","can_delete":false,"product_type":"c1","uid":1655725,"ip_address":"","ucode":"115FE2BE1AAB61","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/pTD8nS0SsORKiaRD3wB0NK9Bpd0wFnPWtYLPfBRBhvZ68iaJErMlM2NNSeEibwQfY7GReILSIYZXfT9o8iaicibcyw3g/132","comment_is_top":false,"comment_ctime":1582969073,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582969073","product_id":100039001,"comment_content":"我理解单例的本质还是使用缓存将对象保存起来，单例的作用范围实际上看能不能缓存中获取这个对象。如线程内的单例，使用ThreadLocal进行缓存时，对其它线程一可见。普通的单例，无论是枚举或懒汉或贪婪模式都使用static进行缓存，而不同classloader加载的静态空间实际上是不共享的，所以进程间的单例实际上是classloader级别的。如果不同classloader间的static静态空间共享，那么像tomcat容器，每个应用都会初始化一个classloader加载应用，不同应用之间就可能会相互修改其它应用的数据，这样会出很多问题。","like_count":0},{"had_liked":false,"id":183160,"user_name":"lijun","can_delete":false,"product_type":"c1","uid":1116095,"ip_address":"","ucode":"69EC8B86211AD9","user_header":"https://static001.geekbang.org/account/avatar/00/11/07/bf/49f385ec.jpg","comment_is_top":false,"comment_ctime":1582964056,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1582964056","product_id":100039001,"comment_content":"这些单例的代码通过反序列化好像可以被破解，不知道我说的对不对。","like_count":0,"discussions":[{"author":{"id":1541669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/86/25/25ded6c3.jpg","nickname":"zhengyu.nie","note":"","ucode":"FFE0377D323E46","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":245790,"discussion_content":"有方法可以覆写，也可以用枚举，看需求。就像反射能跳过set方法限制一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587700076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182658,"user_name":"旭东(Frank)","can_delete":false,"product_type":"c1","uid":1024486,"ip_address":"","ucode":"176FA629800062","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a1/e6/50da1b2d.jpg","comment_is_top":false,"comment_ctime":1582844736,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582844736","product_id":100039001,"comment_content":"如何实现集群环境下的单例？<br>—————————<br>感觉这段说法很怪，集群如果不是不同集群用系统级别的锁和共享内存实现即可，如果是不同机器，目前的rpc框架客户端都是服务端的代理，或者说傀儡，客户端的动作都在服务端做，这样只要服务端是单例即可","like_count":0},{"had_liked":false,"id":182396,"user_name":"jaryoung","can_delete":false,"product_type":"c1","uid":1077406,"ip_address":"","ucode":"6E72D107DB7E51","user_header":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","comment_is_top":false,"comment_ctime":1582781321,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582781321","product_id":100039001,"comment_content":"课后练习题：换个问法，jvm中如何识别是哪个类？包名+类加载器","like_count":0},{"had_liked":false,"id":182075,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1582703738,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582703738","product_id":100039001,"comment_content":"这里的集群式单例像分布式缓存，分布式锁等。 多例是不是就是指的各种线程池<br>","like_count":0},{"had_liked":false,"id":181542,"user_name":"💢 星星💢","can_delete":false,"product_type":"c1","uid":1254392,"ip_address":"","ucode":"A402B765222C35","user_header":"https://static001.geekbang.org/account/avatar/00/13/23/f8/24fcccea.jpg","comment_is_top":false,"comment_ctime":1582556375,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582556375","product_id":100039001,"comment_content":"每节课都很干，要反复看很多遍。","like_count":0},{"had_liked":false,"id":180741,"user_name":"kylexy_0817","can_delete":false,"product_type":"c1","uid":1068372,"ip_address":"","ucode":"392DD9DD5E4B6E","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/54/9c214885.jpg","comment_is_top":false,"comment_ctime":1582379756,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582379756","product_id":100039001,"comment_content":"集群间单例其实有点类似于文件锁，应用通过锁文件，确保只能启动一个应用进程","like_count":0},{"had_liked":false,"id":180413,"user_name":"乾坤瞬间","can_delete":false,"product_type":"c1","uid":1683130,"ip_address":"","ucode":"15BDCF29CBF8EB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","comment_is_top":false,"comment_ctime":1582276183,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582276183","product_id":100039001,"comment_content":"课后练习回答，类加载器是在代码执行前的一步加载操作而提出来的一种实现。类加载器根据类在不同作用命名空间(域)下，分为root类加载器，扩展类加载器，应用类加载器。并且在不同作用空间下，加载同一份class文件所存储的静态空间是不一样的。同时，类静态空间存储的代码是进程共享的，所以，即使针对同一份class文件，即使在同一进程下，由于类加载器的分层委托特性，可能会存储多分class文件","like_count":0},{"had_liked":false,"id":179645,"user_name":"一名小学生","can_delete":false,"product_type":"c1","uid":1137292,"ip_address":"","ucode":"5C73082E6B6370","user_header":"https://static001.geekbang.org/account/avatar/00/11/5a/8c/1fec5fa2.jpg","comment_is_top":false,"comment_ctime":1582069471,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582069471","product_id":100039001,"comment_content":"yeah，打卡完成","like_count":0},{"had_liked":false,"id":178689,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1581779668,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581779668","product_id":100039001,"comment_content":"课堂讨论: <br><br>简单了解了下classLoader机制.<br>单例模式理论上应该是ApplicationClassLoader内的单例.<br>由JVM的双亲委派模型保证了类不会被重复的加载.","like_count":0},{"had_liked":false,"id":178314,"user_name":"L🚲🐱","can_delete":false,"product_type":"c1","uid":1577856,"ip_address":"","ucode":"08A012739614DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","comment_is_top":false,"comment_ctime":1581659331,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581659331","product_id":100039001,"comment_content":"不同的类加载器类全限定名不一样, 全限定名不一样就不是一个类, 而 jdk 的双亲委派模型会先加载父类, 如果父类没有, 则加载自定义类, 这样才能保证单例","like_count":0},{"had_liked":false,"id":178279,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1581649512,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1581649512","product_id":100039001,"comment_content":"看到留言大家都在讨论类加载器知识点，这是我整理的类加载器知识点，大家可以参考下https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;KseFpfXaaGDGoUdqJNzg8w","like_count":0},{"had_liked":false,"id":177335,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1581349198,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1581349198","product_id":100039001,"comment_content":"今天学到的各种单例，真是打开眼界。其中学到了双亲指派和“类加载”这两个知识点我不熟悉，接下来要研究一下。","like_count":0},{"had_liked":false,"id":177330,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1018370,"ip_address":"","ucode":"7A488CC6FE15E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","comment_is_top":false,"comment_ctime":1581348240,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581348240","product_id":100039001,"comment_content":"通过三节课的学习，对单例模式有了一个全面且深入的认识。原来只是知道单例的基本概念，有几种创建单例的方式，单例的一些简单应用。通过3节课的学习，加深了以前对单例的基本知识，同时也了解了单例存在哪些问题，有哪些解决方案。老实说，以前学过的单例，并没有思考过它有哪些问题，某一种创建方式适用于哪些场景等等。特别是第三节课的内容，让我对单例的认识更加深刻，原来单例还有这些问题需要思考，让我认识到自己以前学过的东西其实没有经过认真的思考，只认识到一些表面的东西。坚持学习吧。","like_count":0},{"had_liked":false,"id":177188,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1581317527,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1581317527","product_id":100039001,"comment_content":"<br>老师，我想请教下。您之前说的进程间单例。有两个具体点请教下。如何将内存对象序列化到外存。这里有两个东西一个是 类，第二个是 值。然后如何对这个对象加锁。这块麻烦老师能细说下不，感激不尽","like_count":0,"discussions":[{"author":{"id":1053509,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/45/16c60da2.jpg","nickname":"@%初%@","note":"","ucode":"2B8A6134675ED7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":216959,"discussion_content":"objectXXXXStream，或者使用一些开源序列化工具都可以，分布式锁，，，可以使用redis，zk等东西，个人理解，这就是进程锁，与线程锁的相关区别吧。。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585493443,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":165828,"discussion_content":"用IO流中的对象流将对象序列化到文件中，分布式锁的实现可以百度下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581334881,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177177,"user_name":"webmin","can_delete":false,"product_type":"c1","uid":1047014,"ip_address":"","ucode":"98B0CA882454E8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/e6/47742988.jpg","comment_is_top":false,"comment_ctime":1581315474,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1581315474","product_id":100039001,"comment_content":"1. 资源的合理使用，不同的实例只是数据不同，但是代码是相同，不需要每次都加载类文件和做JIT，同一版本的可以用同一份代码（OS层面也会缓存共享库的代码的机制）；<br>2. 对JAVA程序来说，JVM就是运行实例“机器”，那自然最好是JVM自己有一个机制来管理，在应用层面把OS的事做掉，这样有利于跨OS。","like_count":0},{"had_liked":false,"id":177151,"user_name":"Ankhetsin","can_delete":false,"product_type":"c1","uid":1028469,"ip_address":"","ucode":"3CA233D08D4A72","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b1/75/60a71bbd.jpg","comment_is_top":false,"comment_ctime":1581304404,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581304404","product_id":100039001,"comment_content":"脑洞大开。见识了集群系统单例，多例模式。不同类加载器有唯一共享吗？","like_count":0},{"had_liked":false,"id":177150,"user_name":"天上星多月不亮","can_delete":false,"product_type":"c1","uid":1283877,"ip_address":"","ucode":"A8CD6A7C094F0C","user_header":"https://static001.geekbang.org/account/avatar/00/13/97/25/8c35cc85.jpg","comment_is_top":false,"comment_ctime":1581303801,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"1581303801","product_id":100039001,"comment_content":"各位 想请问下，有了分布式锁，为什么还需要synchronized进行同步呢？","like_count":0,"discussions":[{"author":{"id":1283739,"avatar":"https://static001.geekbang.org/account/avatar/00/13/96/9b/efd37116.jpg","nickname":"进击的小学生","note":"","ucode":"2E10BF2D67F421","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":166388,"discussion_content":"分布式锁保证分布式环境下的数据一致性，即多进程之间；synchronized保证JVM进程内的数据一致性，即单进程多线程之间。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581389671,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1283877,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/25/8c35cc85.jpg","nickname":"天上星多月不亮","note":"","ucode":"A8CD6A7C094F0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1283739,"avatar":"https://static001.geekbang.org/account/avatar/00/13/96/9b/efd37116.jpg","nickname":"进击的小学生","note":"","ucode":"2E10BF2D67F421","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":189040,"discussion_content":"我知道。。。 老师的这个例子怎么体现的呢？按理说只用分布式锁就可以了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582849959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":166388,"ip_address":""},"score":189040,"extra":""},{"author":{"id":1085006,"avatar":"https://static001.geekbang.org/account/avatar/00/10/8e/4e/985caf6b.jpg","nickname":"悟","note":"","ucode":"9F56AD21CCC7E1","race_medal":2,"user_type":1,"is_pvip":false},"reply_author":{"id":1283877,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/25/8c35cc85.jpg","nickname":"天上星多月不亮","note":"","ucode":"A8CD6A7C094F0C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206402,"discussion_content":"避免进程内并发，分布式锁有网络请求，个人理解这是一种性能优化吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584403939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":189040,"ip_address":""},"score":206402,"extra":""},{"author":{"id":1283877,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/25/8c35cc85.jpg","nickname":"天上星多月不亮","note":"","ucode":"A8CD6A7C094F0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1085006,"avatar":"https://static001.geekbang.org/account/avatar/00/10/8e/4e/985caf6b.jpg","nickname":"悟","note":"","ucode":"9F56AD21CCC7E1","race_medal":2,"user_type":1,"is_pvip":false},"discussion":{"id":220397,"discussion_content":"有理 感谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585875499,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":206402,"ip_address":""},"score":220397,"extra":""}]},{"author":{"id":1085006,"avatar":"https://static001.geekbang.org/account/avatar/00/10/8e/4e/985caf6b.jpg","nickname":"悟","note":"","ucode":"9F56AD21CCC7E1","race_medal":2,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206411,"discussion_content":"在补充一下，不加sysnc的情况下会有并发访问分布式锁问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584404344,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177107,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1581288913,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1581288913","product_id":100039001,"comment_content":"在Java中，一个对象的唯一性是有类加载器和类共同决定的；使用类加载器的原因有2:有助于保护Java本身的官方类，安全性高；允许应用程序自定义类加载器，不同应用场景使用某个类的不同版本，解决类冲突问题。","like_count":0,"discussions":[{"author":{"id":1028469,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b1/75/60a71bbd.jpg","nickname":"Ankhetsin","note":"","ucode":"3CA233D08D4A72","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":165581,"discussion_content":"不是操作系统的本进程里唯一吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581304079,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}