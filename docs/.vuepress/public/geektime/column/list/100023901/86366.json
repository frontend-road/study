{"id":86366,"title":"09 | Java线程（上）：Java线程的生命周期","content":"<p>在Java领域，实现并发程序的主要手段就是多线程。线程是操作系统里的一个概念，虽然各种不同的开发语言如Java、C#等都对其进行了封装，但是万变不离操作系统。Java语言里的线程本质上就是操作系统的线程，它们是一一对应的。</p><p>在操作系统层面，线程也有“生老病死”，专业的说法叫有生命周期。对于有生命周期的事物，要学好它，思路非常简单，只要能搞懂<strong>生命周期中各个节点的状态转换机制</strong>就可以了。</p><p>虽然不同的开发语言对于操作系统线程进行了不同的封装，但是对于线程的生命周期这部分，基本上是雷同的。所以，我们可以先来了解一下通用的线程生命周期模型，这部分内容也适用于很多其他编程语言；然后再详细有针对性地学习一下Java中线程的生命周期。</p><h2>通用的线程生命周期</h2><p>通用的线程生命周期基本上可以用下图这个“五态模型”来描述。这五态分别是：<strong>初始状态、可运行状态、运行状态、休眠状态</strong>和<strong>终止状态</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/9b/e5/9bbc6fa7fb4d631484aa953626cf6ae5.png?wh=1142*714\" alt=\"\"></p><center><span class=\"reference\">通用线程状态转换图——五态模型</span></center><p>这“五态模型”的详细情况如下所示。</p><ol>\n<li><strong>初始状态</strong>，指的是线程已经被创建，但是还不允许分配CPU执行。这个状态属于编程语言特有的，不过这里所谓的被创建，仅仅是在编程语言层面被创建，而在操作系统层面，真正的线程还没有创建。</li>\n<li><strong>可运行状态</strong>，指的是线程可以分配CPU执行。在这种状态下，真正的操作系统线程已经被成功创建了，所以可以分配CPU执行。</li>\n<li>当有空闲的CPU时，操作系统会将其分配给一个处于可运行状态的线程，被分配到CPU的线程的状态就转换成了<strong>运行状态</strong>。</li>\n<li>运行状态的线程如果调用一个阻塞的API（例如以阻塞方式读文件）或者等待某个事件（例如条件变量），那么线程的状态就会转换到<strong>休眠状态</strong>，同时释放CPU使用权，休眠状态的线程永远没有机会获得CPU使用权。当等待的事件出现了，线程就会从休眠状态转换到可运行状态。</li>\n<li>线程执行完或者出现异常就会进入<strong>终止状态</strong>，终止状态的线程不会切换到其他任何状态，进入终止状态也就意味着线程的生命周期结束了。</li>\n</ol><!-- [[[read_end]]] --><p>这五种状态在不同编程语言里会有简化合并。例如，C语言的POSIX Threads规范，就把初始状态和可运行状态合并了；Java语言里则把可运行状态和运行状态合并了，这两个状态在操作系统调度层面有用，而JVM层面不关心这两个状态，因为JVM把线程调度交给操作系统处理了。</p><p>除了简化合并，这五种状态也有可能被细化，比如，Java语言里就细化了休眠状态（这个下面我们会详细讲解）。</p><h2>Java中线程的生命周期</h2><p>介绍完通用的线程生命周期模型，想必你已经对线程的“生老病死”有了一个大致的了解。那接下来我们就来详细看看Java语言里的线程生命周期是什么样的。</p><p>Java语言中线程共有六种状态，分别是：</p><ol>\n<li>NEW（初始化状态）</li>\n<li>RUNNABLE（可运行/运行状态）</li>\n<li>BLOCKED（阻塞状态）</li>\n<li>WAITING（无时限等待）</li>\n<li>TIMED_WAITING（有时限等待）</li>\n<li>TERMINATED（终止状态）</li>\n</ol><p>这看上去挺复杂的，状态类型也比较多。但其实在操作系统层面，Java线程中的BLOCKED、WAITING、TIMED_WAITING是一种状态，即前面我们提到的休眠状态。也就是说<strong>只要Java线程处于这三种状态之一，那么这个线程就永远没有CPU的使用权</strong>。</p><p>所以Java线程的生命周期可以简化为下图：</p><p><img src=\"https://static001.geekbang.org/resource/image/3f/8c/3f6c6bf95a6e8627bdf3cb621bbb7f8c.png?wh=1142*714\" alt=\"\"></p><center><span class=\"reference\">Java中的线程状态转换图</span></center><p>其中，BLOCKED、WAITING、TIMED_WAITING可以理解为线程导致休眠状态的三种原因。那具体是哪些情形会导致线程从RUNNABLE状态转换到这三种状态呢？而这三种状态又是何时转换回RUNNABLE的呢？以及NEW、TERMINATED和RUNNABLE状态是如何转换的？</p><h3>1. RUNNABLE与BLOCKED的状态转换</h3><p>只有一种场景会触发这种转换，就是线程等待synchronized的隐式锁。synchronized修饰的方法、代码块同一时刻只允许一个线程执行，其他线程只能等待，这种情况下，等待的线程就会从RUNNABLE转换到BLOCKED状态。而当等待的线程获得synchronized隐式锁时，就又会从BLOCKED转换到RUNNABLE状态。</p><p>如果你熟悉操作系统线程的生命周期的话，可能会有个疑问：线程调用阻塞式API时，是否会转换到BLOCKED状态呢？在操作系统层面，线程是会转换到休眠状态的，但是在JVM层面，Java线程的状态不会发生变化，也就是说Java线程的状态会依然保持RUNNABLE状态。<strong>JVM层面并不关心操作系统调度相关的状态</strong>，因为在JVM看来，等待CPU使用权（操作系统层面此时处于可执行状态）与等待I/O（操作系统层面此时处于休眠状态）没有区别，都是在等待某个资源，所以都归入了RUNNABLE状态。</p><p>而我们平时所谓的Java在调用阻塞式API时，线程会阻塞，指的是操作系统线程的状态，并不是Java线程的状态。</p><h3>2. RUNNABLE与WAITING的状态转换</h3><p>总体来说，有三种场景会触发这种转换。</p><p>第一种场景，获得synchronized隐式锁的线程，调用无参数的Object.wait()方法。其中，wait()方法我们在上一篇讲解管程的时候已经深入介绍过了，这里就不再赘述。</p><p>第二种场景，调用无参数的Thread.join()方法。其中的join()是一种线程同步方法，例如有一个线程对象thread A，当调用A.join()的时候，执行这条语句的线程会等待thread A执行完，而等待中的这个线程，其状态会从RUNNABLE转换到WAITING。当线程thread A执行完，原来等待它的线程又会从WAITING状态转换到RUNNABLE。</p><p>第三种场景，调用LockSupport.park()方法。其中的LockSupport对象，也许你有点陌生，其实Java并发包中的锁，都是基于它实现的。调用LockSupport.park()方法，当前线程会阻塞，线程的状态会从RUNNABLE转换到WAITING。调用LockSupport.unpark(Thread thread)可唤醒目标线程，目标线程的状态又会从WAITING状态转换到RUNNABLE。</p><h3>3. RUNNABLE与TIMED_WAITING的状态转换</h3><p>有五种场景会触发这种转换：</p><ol>\n<li>调用<strong>带超时参数</strong>的Thread.sleep(long millis)方法；</li>\n<li>获得synchronized隐式锁的线程，调用<strong>带超时参数</strong>的Object.wait(long timeout)方法；</li>\n<li>调用<strong>带超时参数</strong>的Thread.join(long millis)方法；</li>\n<li>调用<strong>带超时参数</strong>的LockSupport.parkNanos(Object blocker, long deadline)方法；</li>\n<li>调用<strong>带超时参数</strong>的LockSupport.parkUntil(long deadline)方法。</li>\n</ol><p>这里你会发现TIMED_WAITING和WAITING状态的区别，仅仅是触发条件多了<strong>超时参数</strong>。</p><h3>4. 从NEW到RUNNABLE状态</h3><p>Java刚创建出来的Thread对象就是NEW状态，而创建Thread对象主要有两种方法。一种是继承Thread对象，重写run()方法。示例代码如下：</p><pre><code>// 自定义线程对象\nclass MyThread extends Thread {\n  public void run() {\n    // 线程需要执行的代码\n    ......\n  }\n}\n// 创建线程对象\nMyThread myThread = new MyThread();\n</code></pre><p>另一种是实现Runnable接口，重写run()方法，并将该实现类作为创建Thread对象的参数。示例代码如下：</p><pre><code>// 实现Runnable接口\nclass Runner implements Runnable {\n  @Override\n  public void run() {\n    // 线程需要执行的代码\n    ......\n  }\n}\n// 创建线程对象\nThread thread = new Thread(new Runner());\n</code></pre><p>NEW状态的线程，不会被操作系统调度，因此不会执行。Java线程要执行，就必须转换到RUNNABLE状态。从NEW状态转换到RUNNABLE状态很简单，只要调用线程对象的start()方法就可以了，示例代码如下：</p><pre><code>MyThread myThread = new MyThread();\n// 从NEW状态转换到RUNNABLE状态\nmyThread.start()；\n</code></pre><h3>5. 从RUNNABLE到TERMINATED状态</h3><p>线程执行完 run() 方法后，会自动转换到TERMINATED状态，当然如果执行run()方法的时候异常抛出，也会导致线程终止。有时候我们需要强制中断run()方法的执行，例如 run()方法访问一个很慢的网络，我们等不下去了，想终止怎么办呢？Java的Thread类里面倒是有个stop()方法，不过已经标记为@Deprecated，所以不建议使用了。正确的姿势其实是调用interrupt()方法。</p><p><strong>那stop()和interrupt()方法的主要区别是什么呢？</strong></p><p>stop()方法会真的杀死线程，不给线程喘息的机会，如果线程持有ReentrantLock锁，被stop()的线程并不会自动调用ReentrantLock的unlock()去释放锁，那其他线程就再也没机会获得ReentrantLock锁，这实在是太危险了。所以该方法就不建议使用了，类似的方法还有suspend() 和 resume()方法，这两个方法同样也都不建议使用了，所以这里也就不多介绍了。</p><p>而interrupt()方法就温柔多了，interrupt()方法仅仅是通知线程，线程有机会执行一些后续操作，同时也可以无视这个通知。被interrupt的线程，是怎么收到通知的呢？一种是异常，另一种是主动检测。</p><p>当线程A处于WAITING、TIMED_WAITING状态时，如果其他线程调用线程A的interrupt()方法，会使线程A返回到RUNNABLE状态，同时线程A的代码会触发InterruptedException异常。上面我们提到转换到WAITING、TIMED_WAITING状态的触发条件，都是调用了类似wait()、join()、sleep()这样的方法，我们看这些方法的签名，发现都会throws InterruptedException这个异常。这个异常的触发条件就是：其他线程调用了该线程的interrupt()方法。</p><p>当线程A处于RUNNABLE状态时，并且阻塞在java.nio.channels.InterruptibleChannel上时，如果其他线程调用线程A的interrupt()方法，线程A会触发java.nio.channels.ClosedByInterruptException这个异常；而阻塞在java.nio.channels.Selector上时，如果其他线程调用线程A的interrupt()方法，线程A的java.nio.channels.Selector会立即返回。</p><p>上面这两种情况属于被中断的线程通过异常的方式获得了通知。还有一种是主动检测，如果线程处于RUNNABLE状态，并且没有阻塞在某个I/O操作上，例如中断计算圆周率的线程A，这时就得依赖线程A主动检测中断状态了。如果其他线程调用线程A的interrupt()方法，那么线程A可以通过isInterrupted()方法，检测是不是自己被中断了。</p><h2>总结</h2><p>理解Java线程的各种状态以及生命周期对于诊断多线程Bug非常有帮助，多线程程序很难调试，出了Bug基本上都是靠日志，靠线程dump来跟踪问题，分析线程dump的一个基本功就是分析线程状态，大部分的死锁、饥饿、活锁问题都需要跟踪分析线程的状态。同时，本文介绍的线程生命周期具备很强的通用性，对于学习其他语言的多线程编程也有很大的帮助。</p><p>你可以通过 <code>jstack</code> 命令或者<code>Java VisualVM</code>这个可视化工具将JVM所有的线程栈信息导出来，完整的线程栈信息不仅包括线程的当前状态、调用栈，还包括了锁的信息。例如，我曾经写过一个死锁的程序，导出的线程栈明确告诉我发生了死锁，并且将死锁线程的调用栈信息清晰地显示出来了（如下图）。导出线程栈，分析线程状态是诊断并发问题的一个重要工具。</p><p><img src=\"https://static001.geekbang.org/resource/image/67/be/67734e1a062adc7cf7baac7d6c17ddbe.png?wh=650*532\" alt=\"\"></p><center><span class=\"reference\">发生死锁的线程栈</span></center><h2>课后思考</h2><p>下面代码的本意是当前线程被中断之后，退出<code>while(true)</code>，你觉得这段代码是否正确呢？</p><pre><code>Thread th = Thread.currentThread();\nwhile(true) {\n  if(th.isInterrupted()) {\n    break;\n  }\n  // 省略业务代码无数\n  try {\n    Thread.sleep(100);\n  }catch (InterruptedException e){\n    e.printStackTrace();\n  }\n}\n</code></pre><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p><p></p>","comments":[{"had_liked":false,"id":77454,"user_name":"姜戈","can_delete":false,"product_type":"c1","uid":1058972,"ip_address":"","ucode":"45C4BE93C8E4CC","user_header":"https://static001.geekbang.org/account/avatar/00/10/28/9c/73e76b19.jpg","comment_is_top":false,"comment_ctime":1552928799,"is_pvip":false,"replies":[{"id":"28280","content":"👍👍👍<br>","user_name":"作者回复","comment_id":77454,"uid":"1269969","ip_address":"","utype":1,"ctime":1552953282,"user_name_real":"王宝令"}],"discussion_count":12,"race_medal":0,"score":"1573510959135","product_id":100023901,"comment_content":"可能出现无限循环，线程在sleep期间被打断了，抛出一个InterruptedException异常，try catch捕捉此异常，应该重置一下中断标示，因为抛出异常后，中断标示会自动清除掉！<br>Thread th = Thread.currentThread();<br>while(true) {<br>  if(th.isInterrupted()) {<br>    break;<br>  }<br>  &#47;&#47; 省略业务代码无数<br>  try {<br>    Thread.sleep(100);<br>  }catch (InterruptedException e)｛<br>    Thread.currentThread().interrupt();<br>    e.printStackTrace();<br>  }<br>}","like_count":366,"discussions":[{"author":{"id":1133702,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4c/86/3be94807.jpg","nickname":"angel😇txy🤓","note":"","ucode":"C0AEE0D8BAF7ED","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5687,"discussion_content":"姜戈老兄，厉害，哪里都能看到你身影，现在在哪工作啊","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1566437695,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537567,"discussion_content":"其实知道中断异常后 直接开始执行退出逻辑就可以了 中断标志位本意是一种控制逻辑。既然本线程已经知道外部被打断（无论是channel还是parkEvent sleepEvent）再对自己设置标志位就显得多余","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1639105703,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443729,"discussion_content":"👍👍👍\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1552953282,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1133702,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4c/86/3be94807.jpg","nickname":"angel😇txy🤓","note":"","ucode":"C0AEE0D8BAF7ED","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5686,"discussion_content":"姜戈老兄，厉害，哪里都能看到你身影，现在在哪工作啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1566437695,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2854129,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/8c/f1/1a55535d.jpg","nickname":"踏雪无痕","note":"","ucode":"BB426066431D4D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572601,"discussion_content":"姜戈老兄，厉害，哪里都能看到你身影，现在在哪工作啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652867532,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1168504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d4/78/66b3f2a2.jpg","nickname":"斯盖丸","note":"","ucode":"B881D14B028F14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346185,"discussion_content":"姜戈老兄，厉害，哪里都能看到你身影，现在在哪工作啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611885660,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1790256,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/51/30/0505339c.jpg","nickname":"归去来兮","note":"","ucode":"6F88546A47631C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338107,"discussion_content":"姜姜同学，为什么抛出异常以后中断标示会清除呀？能不能解答一下，谢谢了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609172696,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1790256,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/51/30/0505339c.jpg","nickname":"归去来兮","note":"","ucode":"6F88546A47631C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361111,"discussion_content":"看看JDK Thread类中interrupt()方法的注释你就清楚了\nIf this thread is blocked in an invocation of the {@link\n Object#wait() wait()}, {@link Object#wait(long) wait(long)}, or {@link\n Object#wait(long, int) wait(long, int)} methods of the {@link Object}\n class, or of the {@link #join()}, {@link #join(long)}, {@link\n #join(long, int)}, {@link #sleep(long)}, or {@link #sleep(long, int)},\n methods of this class, then its interrupt status will be cleared and it\n will receive an {@link InterruptedException}.","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1616594556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":338107,"ip_address":""},"score":361111,"extra":""},{"author":{"id":1815185,"avatar":"","nickname":"松鼠鱼","note":"","ucode":"C0E87CCF71DB44","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1790256,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/51/30/0505339c.jpg","nickname":"归去来兮","note":"","ucode":"6F88546A47631C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543863,"discussion_content":"从逻辑上理解就是，中断异常被捕获并处理之后，就不应该再中断了，否则处理了又继续中断，就失去了意义。所以需要手动重置。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1641317229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":338107,"ip_address":""},"score":543863,"extra":""}]},{"author":{"id":1179533,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ff/8d/8601f035.jpg","nickname":"淞淞同学","note":"","ucode":"529A326B898008","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87277,"discussion_content":"请问如何重置中断标识呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576658212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1058972,"avatar":"https://static001.geekbang.org/account/avatar/00/10/28/9c/73e76b19.jpg","nickname":"姜戈","note":"","ucode":"45C4BE93C8E4CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1179533,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ff/8d/8601f035.jpg","nickname":"淞淞同学","note":"","ucode":"529A326B898008","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":87546,"discussion_content":"代码内已经有啦，抓住异常后，再次interrupt","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1576672549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":87277,"ip_address":""},"score":87546,"extra":""}]},{"author":{"id":1111870,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK2Az5uTh9ZGVA7yQCj1BXtXuicPRkvJicA97AoN9xX3bnPcUYglTMXJeZeoVbPQeJA7ICvQhR3KQ0w/132","nickname":"日不落帝国","note":"","ucode":"6A11ABBD8AC438","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6128,"discussion_content":"赞赞赞，学习了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566718251,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77607,"user_name":"虎虎❤️","can_delete":false,"product_type":"c1","uid":1086535,"ip_address":"","ucode":"157F261E80291A","user_header":"https://static001.geekbang.org/account/avatar/00/10/94/47/75875257.jpg","comment_is_top":false,"comment_ctime":1552970012,"is_pvip":false,"replies":[{"id":"28385","content":"看来我没必要写的很装了😂<br>","user_name":"作者回复","comment_id":77607,"uid":"1269969","ip_address":"","utype":1,"ctime":1552997481,"user_name_real":"王宝令"}],"discussion_count":6,"race_medal":0,"score":"495474209052","product_id":100023901,"comment_content":"我的一位长辈曾告诉我，没有真正学不会的知识或者技术，只是缺乏好的老师。<br><br>有的人可以把复杂的知识讲明白，但是讲解的过程却也是晦涩难懂，不免落了下成。<br><br>而学习王老师的课，我一直都觉得很轻松。云淡风轻地就把并发知识抽丝剥茧，确是更显功力。另一方面，我觉得人的大脑更喜欢接受这些平易近人的文字。看似浅近的文字，却更能带领我深入的思考，留下更深刻的印象。反观一些看起来高端大气上档次的论述，让人觉得云山雾罩，好不容易看懂了，但看过后却什么也想不起来了。大概是读文章的时候脑细胞都用来和晦涩的文字做斗争了，已经没有空间去思考和记忆了。<br><br>再次感谢王老师给大家带来优秀的课程。","like_count":115,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443796,"discussion_content":"看来我没必要写的很装了😂\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552997481,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1359108,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bd/04/fc82a7f1.jpg","nickname":"qwfys200","note":"","ucode":"DFE438CA2F77A2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325174,"discussion_content":"技术论文能通俗易懂固然好，但是逻辑严谨肯定是第一位的，因为要保证逻辑的严谨性，所以在组织论文的时候会显得过于呆板和严肃，但是从论文的严肃性来看肯定是必要的。而教程类文章的目的在于普及知识，所以普及是第一目的，可以在满足普及这一功能性诉求的同时舍弃一些不是很重要的东西，突出一些常用的东西，或者用比较近似的案例来做比喻。没有所谓好与坏，只是写作的目的与阅读对象不同而已。这就好比很多武功秘籍，刚入门的武学修炼者会头脑炸裂，而功力深厚的武学大家则会有一种醍醐灌顶的透彻感。我比较讨厌数学，太晦涩，但是它的晦涩是因为逻辑表达的严谨的所需要的。失去了严谨的数学语言，数学的魅力就会大打折扣。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1605250472,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2192295,"avatar":"https://static001.geekbang.org/account/avatar/00/21/73/a7/c8ea0a62.jpg","nickname":"北京小妞","note":"","ucode":"5A327F761E2DFA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373732,"discussion_content":"这是我目前看过的写的最好的并发课程了，给王老师点个赞","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1620840762,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018620,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/fc/d1dd57dd.jpg","nickname":"ipofss","note":"","ucode":"DE3061C9259F9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":22448,"discussion_content":"对，真的写的好，我都能看懂，如果下来有需要用并发编程的场景，我也许会少走一些坑","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1569640709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1245737,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTILKAZGBQic4OfsWEictY5KjCicia5zqb16yqP2dD0109ym1EaJZbYSEgjrSN54h11ywAPIiagPaCeWcIw/132","nickname":"feelar","note":"","ucode":"64ECEC01E7785A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3862,"discussion_content":"写的的确很好，看完很容易就记住了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1564896287,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1359108,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bd/04/fc82a7f1.jpg","nickname":"qwfys200","note":"","ucode":"DFE438CA2F77A2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325175,"discussion_content":"当然了，老师的文章写的很好，含金量很高。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605250554,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77566,"user_name":"Geek_961eed","can_delete":false,"product_type":"c1","uid":1444566,"ip_address":"","ucode":"A62198D96379F5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erWxMXolPylQk8Z6V6yt2LtibksrksC4bHtmxkuCC4Wzw7trl6CfwmsSFMyHFItFnvl21RvQ8fyOBQ/132","comment_is_top":false,"comment_ctime":1552963292,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"482589300444","product_id":100023901,"comment_content":"希望作者讲解一下每一期的思考题！","like_count":112,"discussions":[{"author":{"id":1345531,"avatar":"https://static001.geekbang.org/account/avatar/00/14/87/fb/bdd3b1f4.jpg","nickname":"徐晓桐","note":"","ucode":"CB31A8E493557F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408228,"discussion_content":"每一期 留言区的大佬们 的答案都够全面了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635210487,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1624355,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c9/23/76511858.jpg","nickname":"洛奇","note":"","ucode":"662B4005721119","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361248,"discussion_content":"我觉得不必","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616633558,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1307497,"avatar":"https://static001.geekbang.org/account/avatar/00/13/f3/69/7039d03f.jpg","nickname":"书策稠浊","note":"","ucode":"A29875CE15FDA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1624355,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c9/23/76511858.jpg","nickname":"洛奇","note":"","ucode":"662B4005721119","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":395971,"discussion_content":"为啥呢，你不想知道作者的思路吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632371350,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":361248,"ip_address":""},"score":395971,"extra":""},{"author":{"id":1624355,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c9/23/76511858.jpg","nickname":"洛奇","note":"","ucode":"662B4005721119","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1307497,"avatar":"https://static001.geekbang.org/account/avatar/00/13/f3/69/7039d03f.jpg","nickname":"书策稠浊","note":"","ucode":"A29875CE15FDA3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":398072,"discussion_content":"不必追求别人告诉我们标准答案，我觉得我们不必对自己这么不自信","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632729704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":395971,"ip_address":""},"score":398072,"extra":""},{"author":{"id":1307497,"avatar":"https://static001.geekbang.org/account/avatar/00/13/f3/69/7039d03f.jpg","nickname":"书策稠浊","note":"","ucode":"A29875CE15FDA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1624355,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c9/23/76511858.jpg","nickname":"洛奇","note":"","ucode":"662B4005721119","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559674,"discussion_content":"想了解作者的思路未必就是不自信吧，反而不敢借鉴别人的思路去完善自己的思路才是不自信","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1648875128,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":398072,"ip_address":""},"score":559674,"extra":""}]}]},{"had_liked":false,"id":85710,"user_name":"Tristan","can_delete":false,"product_type":"c1","uid":1446426,"ip_address":"","ucode":"6CBB92D50C2929","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/15WXictKcv02AGs8PPBGvykHg3tYc7Xb33xs0iayGLMIYdFhlPoHe0ABw5F93yyInM9D5nDSAU7TWwROz4rTk0YA/132","comment_is_top":false,"comment_ctime":1555209106,"is_pvip":false,"replies":[{"id":"30829","content":"是我的错，我确认了一下，隐式锁可以释放。多谢多谢！！！<br>","user_name":"作者回复","comment_id":85710,"uid":"1269969","ip_address":"","utype":1,"ctime":1555233528,"user_name_real":"王宝令"}],"discussion_count":15,"race_medal":0,"score":"392397233042","product_id":100023901,"comment_content":"为什么实战高并发程序设计医术中写道“Tread.stop()方法在结束线程时，会直接终止线程，并且会释放这个线程所持有的锁”，而您文中所写的“果线程持有 synchronized 隐式锁，也不会释放”？？","like_count":91,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446775,"discussion_content":"是我的错，我确认了一下，隐式锁可以释放。多谢多谢！！！\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555233528,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1818343,"avatar":"","nickname":"刘同青","note":"","ucode":"84B62DF8BC61FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289435,"discussion_content":"经过测试，无论是synchronized还是JUC的Lock，在stop线程时都会释放锁，所以stop之所以deprecated和释放不释放锁没有关系，还是因为stop太粗暴，导致终止的位置不确定，所以才不推荐使用的。\n\n测试1：测试synchronized线程被stop，其他线程是否能进入临界区\npublic class TestStopSynchronized {\n    public static void main(String[] args) throws Exception {\n        Thread thread1 = new MyThread();\n        thread1.setName(&#34;thread1&#34;);\n        thread1.start();\n        sleep(3);\n        Thread thread2 = new MyThread();\n        thread2.setName(&#34;thread2&#34;);\n        thread2.start();\n        sleep(3);\n        //直接杀死\n        System.out.println(nowTime() + &#34; stop thread1&#34;);\n        thread1.stop();\n        //等待线程终止\n        thread1.join();\n        thread2.join();\n    }\n    private static class MyThread extends Thread{\n        @Override\n        public void run() {\n            fun1();\n        }\n    }\n    private static synchronized void fun1(){\n        System.out.println(nowTime() + Thread.currentThread().getName() + &#34; start&#34;);\n        sleep(30);\n        System.out.println(nowTime() + Thread.currentThread().getName() + &#34; end&#34;);\n    }\n    private static void sleep(long second){\n        try {\n            TimeUnit.SECONDS.sleep(second);\n        } catch (InterruptedException e) {\n            //重置中断状态\n            Thread.currentThread().interrupt();\n        }\n    }\n\n    private static String nowTime(){\n        SimpleDateFormat sdf = new SimpleDateFormat(&#34;yyyy/MM/dd HH:mm:ss&#34;);\n        return sdf.format(new Date()) + &#34; &#34;;\n    }\n}\n测试1结果：\n\n2020/07/07 13:28:28 thread1 start\n2020/07/07 13:28:34  stop thread1\n2020/07/07 13:28:34 thread2 start\n2020/07/07 13:29:04 thread2 end\n","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1594100543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1181650,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","nickname":"惘 闻","note":"","ucode":"C5909F034BF072","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1818343,"avatar":"","nickname":"刘同青","note":"","ucode":"84B62DF8BC61FB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292748,"discussion_content":"不确定中断在何处的测试结果得多来几个才能看到啊 ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595321496,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":289435,"ip_address":""},"score":292748,"extra":""}]},{"author":{"id":1105828,"avatar":"https://static001.geekbang.org/account/avatar/00/10/df/a4/c28050e2.jpg","nickname":"什么","note":"","ucode":"BAFAF0BAABA57F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":37455,"discussion_content":"这篇文章说会释放锁，即使释放也会有一致性问题，但没说是不是隐式锁才能释放，\nhttps://docs.oracle.com/javase/1.5.0/docs/guide/misc/threadPrimitiveDeprecation.html","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1571619900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1747184,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/a8/f0/529f15e9.jpg","nickname":"第四单元","note":"","ucode":"3ED9D553E1DE17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1105828,"avatar":"https://static001.geekbang.org/account/avatar/00/10/df/a4/c28050e2.jpg","nickname":"什么","note":"","ucode":"BAFAF0BAABA57F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372383,"discussion_content":"这篇文章是官方回答了。总结：隐式锁会释放，显示锁不会释放；stop()废弃的原因：如果在执行临界区代码时被终止，共享变量可能会处于不一致的状态，而stop()时会释放隐式锁，其它线程进入临界区操作这些被“破坏”的变量可能出现不可预料的错误。","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1620303712,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":37455,"ip_address":""},"score":372383,"extra":""}]},{"author":{"id":1114542,"avatar":"https://static001.geekbang.org/account/avatar/00/11/01/ae/f298ef27.jpg","nickname":"岁月如歌","note":"","ucode":"29FA49EEDBFF92","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312694,"discussion_content":"应该是1.5以前的synchronize可以释放，并发包里面后面加的锁不能释放","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602772698,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1818343,"avatar":"","nickname":"刘同青","note":"","ucode":"84B62DF8BC61FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289436,"discussion_content":"测试2：测试lock的线程被stop，其他线程是否能加锁\n\npublic class TestStopLock {\n    private static Lock lock = new ReentrantLock();\n    public static void main(String[] args) throws Exception {\n        Thread thread1 = new MyThread();\n        thread1.setName(&#34;thread1&#34;);\n        thread1.start();\n        sleep(3);\n        Thread thread2 = new MyThread();\n        thread2.setName(&#34;thread2&#34;);\n        thread2.start();\n        sleep(3);\n        //直接杀死\n        System.out.println(nowTime() + &#34; stop thread1&#34;);\n        thread1.stop();\n        //等待线程终止\n        thread1.join();\n        thread2.join();\n    }\n    private static class MyThread extends Thread{\n        @Override\n        public void run() {\n            fun1();\n        }\n    }\n    private static void fun1(){\n        lock.lock();\n        try {\n            System.out.println(nowTime() + Thread.currentThread().getName() + &#34; start&#34;);\n            sleep(30);\n            System.out.println(nowTime() + Thread.currentThread().getName() + &#34; end&#34;);\n        }finally {\n            lock.unlock();\n        }\n    }\n    private static void sleep(long second){\n        try {\n            TimeUnit.SECONDS.sleep(second);\n        } catch (InterruptedException e) {\n            //重置中断状态\n            Thread.currentThread().interrupt();\n        }\n    }\n\n    private static String nowTime(){\n        SimpleDateFormat sdf = new SimpleDateFormat(&#34;yyyy/MM/dd HH:mm:ss&#34;);\n        return sdf.format(new Date()) + &#34; &#34;;\n    }\n}\n\n测试结果：\n\n2020/07/07 13:27:20 thread1 start\n2020/07/07 13:27:26  stop thread1\n2020/07/07 13:27:26 thread2 start\n2020/07/07 13:27:56 thread2 end\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594100584,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1194858,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3b/6a/80d9c545.jpg","nickname":"RD","note":"","ucode":"E3947B6E1681AD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1818343,"avatar":"","nickname":"刘同青","note":"","ucode":"84B62DF8BC61FB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296647,"discussion_content":"你把 unlock 放到 finally 当中。。。它即使杀掉线程，也得遵守 finally 规则呀。。。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1596612772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":289436,"ip_address":""},"score":296647,"extra":""},{"author":{"id":1747184,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/a8/f0/529f15e9.jpg","nickname":"第四单元","note":"","ucode":"3ED9D553E1DE17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1818343,"avatar":"","nickname":"刘同青","note":"","ucode":"84B62DF8BC61FB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372380,"discussion_content":"确实，调用stop的时候，finally块中的代码会被执行。具体到你的例子就是会调用unlock方法。我实测不会释放。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1620303245,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":289436,"ip_address":""},"score":372380,"extra":""}]},{"author":{"id":1323652,"avatar":"","nickname":"sibyl","note":"","ucode":"0D142011860D69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289429,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594098327,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1101581,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cf/0d/f4150547.jpg","nickname":"君不得闲","note":"","ucode":"718AA2C9B410BB","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":25392,"discussion_content":"意思是Lock实现的类 锁不会释放吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570514929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1810576,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","nickname":"M","note":"","ucode":"06F26E1D62E9C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1101581,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cf/0d/f4150547.jpg","nickname":"君不得闲","note":"","ucode":"718AA2C9B410BB","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":244539,"discussion_content":"对的，这是手动加锁解锁的，加了锁后执行stop中断后，就不能解锁了，永远阻塞了；而synchronized的加锁解锁是编译器操作的，stop后编译器会自动解锁","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1587609717,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":25392,"ip_address":""},"score":244539,"extra":""},{"author":{"id":1818343,"avatar":"","nickname":"刘同青","note":"","ucode":"84B62DF8BC61FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1810576,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","nickname":"M","note":"","ucode":"06F26E1D62E9C9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289437,"discussion_content":"根据实测，我发现JUC中的Lock的持锁线程被stop后，其他线程也是能加锁成功的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594100628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":244539,"ip_address":""},"score":289437,"extra":""},{"author":{"id":2653715,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKib3vNM6TPT1umvR3TictnLurJPKuQq4iblH5upgBB3kHL9hoN3Pgh3MaR2rjz6fWgMiaDpicd8R5wsAQ/132","nickname":"陈阳","note":"","ucode":"C8E676C967D23A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1818343,"avatar":"","nickname":"刘同青","note":"","ucode":"84B62DF8BC61FB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386011,"discussion_content":"我也是，放到finaly里面时可以释放的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627381597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":289437,"ip_address":""},"score":386011,"extra":""}]}]},{"had_liked":false,"id":105561,"user_name":"rock","can_delete":false,"product_type":"c1","uid":1126597,"ip_address":"","ucode":"A512CED4619E7A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJZhuQk0ibMqdsASdJib2aUKNjTiaVm1ib3EfjyyiaKBJAyzYFls9KTEQ3w60cpy5CPLRNHsX8uooDoB8g/132","comment_is_top":false,"comment_ctime":1561031721,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"203424494633","product_id":100023901,"comment_content":"new, runnable, block, waiting, time_waiting, terminated <br><br>runnable--&gt;block, 仅线程等待synchronized隐式锁<br>block--&gt;runnable, 线程获得了synchronized隐式锁<br><br>runnable--&gt;waiting,  线程获得了synchronized隐式锁，在临界区类调用wait()，(无时间限制的)等待指定的条件满足。<br>                     线程调用子线程的Thread.jion(),(无时间限制的)等待子线程执行完成返回。<br>                     线程调用LockSupport.park(),(无时间限制的)等待LockSupport.unPark(thead)。【LockSupport.park(),用于创建锁和其他同步类的底层基本线程阻塞原语，使当前线程block from thread scheduling】<br>waiting--&gt;runnable,  上述3种，条件达成后。<br><br>runnable--&gt;time_waiting, 线程获得了synchronized隐式锁，在临界区类调用wait(time)，(有时间限制的)等待指定的条件满足。<br>                         线程调用子线程的Thread.jion(time),(有时间限制的)等待子线程执行完成返回。<br>                         线程调用LockSupport.parkNanos(Object blocker, long deadline).<br>                         线程调用LockSupport.partUntil(long deadline).<br>                         线程调用Thread.sleep(long millis).<br>time_waiting--&gt;runnable, 上述条件满足 或 等待超时<br><br>runnable--&gt;teminated,    线程自动终结：1,线程run方法执行结束退出; 2,线程run方法内部抛出异常退出<br>                         其他线程通过调用本线程的Tread.interrupt()方法，尝试强制中止本线程：【注：不要用Tread.stop()这个废弃方法，危害...】<br>                           1) 本线程处于waiting,timed_waiting状态时，其他线程调用本线程的interrupt(),会使本线程转为Runnable状态，同时本线程抛出InterruptedException.<br>                           2) 本线程处于Runnable状态，且阻塞在java.nio.channels.InterruptedChannel [可中断channel]时，其他线程调用本线程的interrupt(),会使本线程抛出ClosedByInterruptedException。<br>                           3) 本线程处于Runnable状态，且阻塞在java.nio.channels.Selector[可多路复用的异步IO机制]上时,本线程会（从Selector.select()）立即返回。<br>                           4) 本线程处于Runnable状态，且没有阻塞在某个I&#47;O操作上时，其他线程调用本线程的interrupt(),这只是将本线程的中断标志位置为True。<br>                              本线程可以通过调用isInterrupted()来查看本线程的中断标志位是否被置为true，可以决定退出，也可以忽略它(全看代码逻辑)。<br><br>                         重要：本线程抛出InterruptedException后，会把本线程的中断标志位清空，可能已有的中断标志True就消失了，可能会引起本线程失去主动监测中断标志以退出的机会！<br>                              所以，对本线程抛出的InterruptedException的异常try-catch后，再主动置标志位为True。Thead.currentTread().interrupt();","like_count":47},{"had_liked":false,"id":77678,"user_name":"thas","can_delete":false,"product_type":"c1","uid":1444359,"ip_address":"","ucode":"EEAFBC29E68EA4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKb5BzdGZbSYFlk3fx1QIeNuwo9TmRQyb29b7KJd8ibdWt4L6KYGpXJWGPJJh29s09I2ZJtZ59ktJQ/132","comment_is_top":false,"comment_ctime":1552981218,"is_pvip":false,"replies":[{"id":"28378","content":"能和硬件中断联系起来👍👍👍<br>","user_name":"作者回复","comment_id":77678,"uid":"1269969","ip_address":"","utype":1,"ctime":1552997083,"user_name_real":"王宝令"}],"discussion_count":3,"race_medal":0,"score":"186236574946","product_id":100023901,"comment_content":"interrupt是中断的意思，在单片机开发领域，用于接收特定的事件，从而执行后续的操作。Java线程中，（通常）使用interrupt作为线程退出的通知事件，告知线程可以结束了。<br>interrupt不会结束线程的运行，在抛出InterruptedException后会清除中断标志（代表可以接收下一个中断信号了），所以我想，interrupt应该也是可以类似单片机一样作为一种通知信号的，只是实现通知的话，Java有其他更好的选择。<br>因InterruptedException退出同步代码块会释放当前线程持有的锁，所以相比外部强制stop是安全的（已手动测试）。sleep、join等会抛出InterruptedException的操作会立即抛出异常，wait在被唤醒之后才会抛出异常（就像阻塞一样，不被打扰）。<br>另外，感谢老师提醒，I&#47;O阻塞在Java中是可运行状态，并发包中的lock是等待状态。","like_count":43,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443812,"discussion_content":"能和硬件中断联系起来👍👍👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552997083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1624355,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c9/23/76511858.jpg","nickname":"洛奇","note":"","ucode":"662B4005721119","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361274,"discussion_content":"lock.lock()方法内部调用了park方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616635390,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1042241,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e7/41/2ea1f5dc.jpg","nickname":"王二宝","note":"","ucode":"E147D6E597EF5B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":17269,"discussion_content":"老兄搞过单片机","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568963953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79867,"user_name":"Junzi","can_delete":false,"product_type":"c1","uid":1004612,"ip_address":"","ucode":"4AC663769C1873","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/44/4e541a86.jpg","comment_is_top":false,"comment_ctime":1553566090,"is_pvip":false,"replies":[{"id":"29423","content":"👍","user_name":"作者回复","comment_id":79867,"uid":"1269969","ip_address":"","utype":1,"ctime":1553781095,"user_name_real":"王宝令"}],"discussion_count":2,"race_medal":0,"score":"147582454154","product_id":100023901,"comment_content":"当发起中断之后，Thread.sleep(100);会抛出InterruptedException异常，而这个抛出这个异常会清除当前线程的中断标识，导致th.isInterrupted()一直都是返回false的。<br><br>InterruptedException - if any thread has interrupted the current thread. The interrupted status of the current thread is cleared when this exception is thrown.","like_count":34,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444660,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553781095,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1810576,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","nickname":"M","note":"","ucode":"06F26E1D62E9C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":244541,"discussion_content":"大佬V587","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587610074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77761,"user_name":"海鸿","can_delete":false,"product_type":"c1","uid":1104275,"ip_address":"","ucode":"7074EF94EA70AD","user_header":"https://static001.geekbang.org/account/avatar/00/10/d9/93/098e5ef5.jpg","comment_is_top":false,"comment_ctime":1552994940,"is_pvip":false,"replies":[{"id":"28441","content":"阻塞态的线程不响应中断，并发包里的锁有方法能够响应中断<br>","user_name":"作者回复","comment_id":77761,"uid":"1269969","ip_address":"","utype":1,"ctime":1553041408,"user_name_real":"王宝令"}],"discussion_count":5,"race_medal":0,"score":"87452340860","product_id":100023901,"comment_content":"如果线程处于阻塞状态（BLOCKED）,此时调用线程的中断方法，线程会又如何反应?<br>是否会像等待状态一样抛异常?<br>还是会像运行状态一样被标记为已中断状态?<br>还是不受到任何影响?<br>麻烦老师解答一下😁","like_count":20,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443841,"discussion_content":"阻塞态的线程不响应中断，并发包里的锁有方法能够响应中断\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553041408,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645430,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiauonyMORA2s43W7mogGDH4WYjW0gBJtYmUa9icTB6aMPGqibicEKlLoQmLKLWEctwHzthbTZkKR20w/132","nickname":"Spring4J","note":"","ucode":"06F056085A2564","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408362,"discussion_content":"实践是检验真理的唯一标准，也能让人印象更加深刻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635235411,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1256923,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKkeBKshjwVKcpVTs1kGkPibsD5j8odoY6oHrMU1EHqDVjHoLLqzknOd8Q0aWxTDCJjvK1NJIX5Ncg/132","nickname":"Summer","note":"","ucode":"6E51D5574C1EFD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361919,"discussion_content":"好问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616806705,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1743868,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/9b/fc/a3abbe53.jpg","nickname":"白杨","note":"","ucode":"B56DD94706F80B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339633,"discussion_content":"好问题，我也想到了这个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609749659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008933,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/65/25/c6de04bc.jpg","nickname":"斜月浮云","note":"","ucode":"25CECBB175DA02","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300487,"discussion_content":"建议把这段加入正文，不然不完整","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598146158,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79290,"user_name":"WhoAmI","can_delete":false,"product_type":"c1","uid":1445156,"ip_address":"","ucode":"58588E643EB842","user_header":"https://static001.geekbang.org/account/avatar/00/16/0d/24/b07de4f2.jpg","comment_is_top":false,"comment_ctime":1553425018,"is_pvip":false,"replies":[{"id":"28923","content":"不占cpu，操作系统里是阻塞状态。","user_name":"作者回复","comment_id":79290,"uid":"1269969","ip_address":"","utype":1,"ctime":1553436010,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"74567869050","product_id":100023901,"comment_content":"老师，Java调用阻塞API时，Java层面是runnable，那仍然占用CPU吗，此时此线程在操作系统中是什么状态呢？这个问题好几个人都在问，能详细解释下吗？","like_count":17,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444433,"discussion_content":"不占cpu，操作系统里是阻塞状态。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553436010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147726,"user_name":"cky.宇","can_delete":false,"product_type":"c1","uid":1369447,"ip_address":"","ucode":"93A3EAD9D50A5F","user_header":"https://static001.geekbang.org/account/avatar/00/14/e5/67/16322a5d.jpg","comment_is_top":false,"comment_ctime":1572881516,"is_pvip":false,"replies":[{"id":"57451","content":"完全同意！","user_name":"作者回复","comment_id":147726,"uid":"1269969","ip_address":"","utype":1,"ctime":1573225707,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"65997390956","product_id":100023901,"comment_content":"根据接口文档描述，stop()虽然也会中止线程并释放锁，但是没有提供一种补偿的机会，可能某个线程对共享对象进行了不完整的修改，此时如果stop后，该共享对象会继续被其他线程使用，造成线程安全问题。interrupt()则是提供给使用者一种被中断后补偿的机会，例如回滚之前的修改。个人理解是这样的，请老师指点一下。","like_count":15,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473294,"discussion_content":"完全同意！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573225707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77546,"user_name":"alias cd=rm -rf","can_delete":false,"product_type":"c1","uid":1318325,"ip_address":"","ucode":"E7B27D76305B75","user_header":"https://static001.geekbang.org/account/avatar/00/14/1d/b5/971261fd.jpg","comment_is_top":false,"comment_ctime":1552961439,"is_pvip":false,"replies":[{"id":"28394","content":"你这也是个办法<br>","user_name":"作者回复","comment_id":77546,"uid":"1269969","ip_address":"","utype":1,"ctime":1552998018,"user_name_real":"王宝令"}],"discussion_count":5,"race_medal":0,"score":"57387536287","product_id":100023901,"comment_content":"思考题，不能中断循环，异常捕获要放在while循环外面<br>","like_count":13,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443771,"discussion_content":"你这也是个办法\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552998018,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1583588,"avatar":"https://static001.geekbang.org/account/avatar/00/18/29/e4/ade74d94.jpg","nickname":"hejun","note":"","ucode":"DCF01B4159178F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":35667,"discussion_content":"这个名字，哈哈","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1571296740,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008468,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/54/c9475cd0.jpg","nickname":"cz","note":"","ucode":"96385190176F78","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":407637,"discussion_content":"异常块里，放个break也可以起到同样的效果。 就是看起来有点奇怪","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635078520,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1013147,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/75/9b/611e74ab.jpg","nickname":"技术修行者","note":"","ucode":"28CA41A1214D6B","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340775,"discussion_content":"冲着这个名字，必须mark👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610153658,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1214755,"avatar":"https://static001.geekbang.org/account/avatar/00/12/89/23/73569bd7.jpg","nickname":"xj_zh","note":"","ucode":"190609F7AE67CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341,"discussion_content":"名字很酷","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561457337,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82460,"user_name":"缪文","can_delete":false,"product_type":"c1","uid":1042262,"ip_address":"","ucode":"59603B50EF5FC6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e7/56/c72997f3.jpg","comment_is_top":false,"comment_ctime":1554217647,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"48798857903","product_id":100023901,"comment_content":"if(th.isInterrupted()) {<br>    break;<br>  }<br>其实这段代码完全没必要啊，在捕获中断异常后，直接break就好了","like_count":11,"discussions":[{"author":{"id":1621470,"avatar":"https://static001.geekbang.org/account/avatar/00/18/bd/de/e0c994b3.jpg","nickname":"坐地铁的程序员","note":"","ucode":"A04A239D173E2A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5192,"discussion_content":"好好看看文章，当线程处于runnable状态时，被终端是不会抛出异常的，这时候如果不主动进行中断检查是不会起到退出线程的作用的。","likes_number":14,"is_delete":false,"is_hidden":false,"ctime":1566036583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1042262,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e7/56/c72997f3.jpg","nickname":"缪文","note":"","ucode":"59603B50EF5FC6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1621470,"avatar":"https://static001.geekbang.org/account/avatar/00/18/bd/de/e0c994b3.jpg","nickname":"坐地铁的程序员","note":"","ucode":"A04A239D173E2A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":36158,"discussion_content":"明白了，不过这个问题还有另一个解，就是除了主动检查以外，在捕获中断异常后，不需要设置中断标识，直接break跳出while循环就好了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1571325726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":5192,"ip_address":""},"score":36158,"extra":""},{"author":{"id":1115302,"avatar":"https://static001.geekbang.org/account/avatar/00/11/04/a6/18c4f73c.jpg","nickname":"Airsaid","note":"","ucode":"5B90BC0044F376","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1042262,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e7/56/c72997f3.jpg","nickname":"缪文","note":"","ucode":"59603B50EF5FC6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":195956,"discussion_content":"当在代码中调用了一个将抛出 InterruptedException 异常的函数，那么你自己的方法也变成了阻塞方法，也就必须处理对中断的响应。如果你写的是库代码，那么就可以将异常继续往上抛，或者恢复中断，让更上层的代码可以看到这个中断。\n\n只有实现了线程中断策略的代码才可以屏蔽中断请求。在常规的任务或库代码中都不应该屏蔽中断请求。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1583324444,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":36158,"ip_address":""},"score":195956,"extra":""},{"author":{"id":1256923,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKkeBKshjwVKcpVTs1kGkPibsD5j8odoY6oHrMU1EHqDVjHoLLqzknOd8Q0aWxTDCJjvK1NJIX5Ncg/132","nickname":"Summer","note":"","ucode":"6E51D5574C1EFD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1621470,"avatar":"https://static001.geekbang.org/account/avatar/00/18/bd/de/e0c994b3.jpg","nickname":"坐地铁的程序员","note":"","ucode":"A04A239D173E2A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361918,"discussion_content":"讲的好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616805973,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":5192,"ip_address":""},"score":361918,"extra":""}]},{"author":{"id":1583588,"avatar":"https://static001.geekbang.org/account/avatar/00/18/29/e4/ade74d94.jpg","nickname":"hejun","note":"","ucode":"DCF01B4159178F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":35669,"discussion_content":"楼上正解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571296960,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77752,"user_name":"J.M.Liu","can_delete":false,"product_type":"c1","uid":1200037,"ip_address":"","ucode":"B2CB84B8E923A6","user_header":"https://static001.geekbang.org/account/avatar/00/12/4f/a5/71358d7b.jpg","comment_is_top":false,"comment_ctime":1552992524,"is_pvip":false,"replies":[{"id":"28446","content":"block不能响应中断，os里应该都是休眠状态，因为都不能获得cpu使用权<br>","user_name":"作者回复","comment_id":77752,"uid":"1269969","ip_address":"","utype":1,"ctime":1553041995,"user_name_real":"王宝令"}],"discussion_count":2,"race_medal":0,"score":"44502665484","product_id":100023901,"comment_content":"感谢老师提醒，原来jvm层面的线程状态和os层面上的线程状态是不一样的，i&#47;o挂起在jvm也是runable状态。另外并发包的lock其实是处于waitting状态。<br>但是有个疑问，jvm中blocked状态的线程和waitting状态的线程，除了处在不同的队列之外，还有没有什么区别呀？我这里问的区别包括jvm和os两个层面，谢谢老师","like_count":10,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443836,"discussion_content":"block不能响应中断，os里应该都是休眠状态，因为都不能获得cpu使用权\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553041995,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1311772,"avatar":"https://static001.geekbang.org/account/avatar/00/14/04/1c/b0c6c009.jpg","nickname":"zhj","note":"","ucode":"65B9E222D6E075","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":264023,"discussion_content":"Lock.lock()方法，非lockInterruptibly()方法，也是不响应中断的，而且lock后线程处于waiting状态","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589281713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109447,"user_name":"Aven","can_delete":false,"product_type":"c1","uid":1066230,"ip_address":"","ucode":"E2B1D0B57F18D1","user_header":"https://static001.geekbang.org/account/avatar/00/10/44/f6/60f948e1.jpg","comment_is_top":false,"comment_ctime":1562034497,"is_pvip":true,"replies":[{"id":"39682","content":"阻塞式的读文件，读网络数据都是","user_name":"作者回复","comment_id":109447,"uid":"1269969","ip_address":"","utype":1,"ctime":1562069498,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"40216740161","product_id":100023901,"comment_content":"老师，您好，想问下，在讲到“java调用阻塞api的情况下，java程序仍然是Runnable状态”这里的时候，我不太理解，哪些api是属于阻塞api呢","like_count":9,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456415,"discussion_content":"阻塞式的读文件，读网络数据都是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562069498,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78019,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1553055381,"is_pvip":false,"replies":[{"id":"28650","content":"好认真👍👍👍<br>","user_name":"作者回复","comment_id":78019,"uid":"1269969","ip_address":"","utype":1,"ctime":1553257816,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"35912793749","product_id":100023901,"comment_content":"<br>public class TestThread {<br><br>\tpublic static void main(String[] args) throws InterruptedException {<br><br>\t\tWorker t = new Worker();<br>\t\tt.start();<br><br>\t\tThread.sleep(2000);<br>\t\t<br>\t\tSystem.out.println(&quot;-1-1-1-&quot;);<br>\t\tt.interrupt();<br>\t\tSystem.out.println(&quot;000000&quot;);<br>\t\tThread.sleep(2000);<br>\t\tt.stop();<br>\t\tSystem.out.println(&quot;000111&quot;);<br>\t\tThread.sleep(2000);<br>\t\tt.join();<br>\t\tSystem.out.println(&quot;111111&quot;);<br>\t}<br><br>}<br><br>class Worker extends Thread {<br><br>\t@Override<br>\tpublic void run() {<br>\t\tint i = 0;<br>\t\twhile (i&lt;20) {<br>\t\t\tif (Thread.currentThread().isInterrupted()) {<br>\t\t\t\tbreak;<br>\t\t\t}<br>\t\t\t++i;<br>\t\t\tSystem.out.println(Thread.currentThread().getName() + &quot;i: &quot; + i);<br>\t\t\ttry {<br>\t\t\t\tThread.sleep(1000);<br>\t\t\t} catch (InterruptedException e) {<br>\t\t\t\t&#47;&#47; TODO Auto-generated catch block<br>\t\t\t\te.printStackTrace();<br>\t\t\t}<br>\t\t}<br>\t}<br>}<br><br>----------------------------------------------------------------------------<br>忽然发现极客时间网页版的留言窗口好小啊，都看不到自己上面写的东西...<br>----------------------------------------------------------------------------<br><br>1. 如果worker中没有sleep方法，则调用th.interrupt()方法会真正的中断th线程，并且不会抛出InterruptException 但是该演示代码不能体现锁的释放；<br>2. 如果worer中有sleep方法，则调用th.interrupt()方法会抛 java.lang.InterruptException(), 是针对sleep方法抛出的<br>\t同样的Object的wait() wait(带参) 也会抛出java.lang.InterruptException()而从当前的wait&#47;blocked状态被中断（唤醒）<br>\t那也就是说，throws InterruptedException 的方法 在线程被调用interrupt()方法后，会被从当前状态中断<br>\t至于调用interrupy()方法后线程的状态属于哪种，取决于interrupt方法前的执行的方法使得当前线程处于哪种状态，<br>\t老师的总结很到位，需要好好理解，感受~！<br>3. 无论worder的run中有没有slee()方法，stop都会直接中断线程，当前演示代码也无法演示锁没有被释放<br>4. join()总是在等待被调用的线程执行完毕<br>5. while循环放在try里面, 在调用th.interrupt之后，可以有效捕获InterruptException 从而使th线程中断<br><br>说的有点多了， 大家多多讨论~！~！~！<br><br>","like_count":8,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443936,"discussion_content":"好认真👍👍👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553257816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77606,"user_name":"悟","can_delete":false,"product_type":"c1","uid":1442835,"ip_address":"","ucode":"9A560A63DF71ED","user_header":"https://static001.geekbang.org/account/avatar/00/16/04/13/aac9b508.jpg","comment_is_top":false,"comment_ctime":1552969432,"is_pvip":false,"replies":[{"id":"28386","content":"我也不知道搞jvm的人咋想的<br>","user_name":"作者回复","comment_id":77606,"uid":"1269969","ip_address":"","utype":1,"ctime":1552997556,"user_name_real":"王宝令"}],"discussion_count":3,"race_medal":0,"score":"35912707800","product_id":100023901,"comment_content":"老师 stop方法直接杀掉线程了，什么不会释放锁呢","like_count":8,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443795,"discussion_content":"我也不知道搞jvm的人咋想的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552997556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41165,"discussion_content":"因为太突然了，就像游戏中被击杀时，不会让你把装备转给队友","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1572361275,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008933,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/65/25/c6de04bc.jpg","nickname":"斜月浮云","note":"","ucode":"25CECBB175DA02","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300488,"discussion_content":"stop可以释放锁的。不要光听别人说，自己试一试","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598146263,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77660,"user_name":"向往的生活","can_delete":false,"product_type":"c1","uid":1397298,"ip_address":"","ucode":"0E8DB45357820F","user_header":"https://static001.geekbang.org/account/avatar/00/15/52/32/bb570f48.jpg","comment_is_top":false,"comment_ctime":1552979741,"is_pvip":true,"replies":[{"id":"28448","content":"我估计不会有中间的runnable，只是换个队列而已<br>","user_name":"作者回复","comment_id":77660,"uid":"1269969","ip_address":"","utype":1,"ctime":1553042380,"user_name_real":"王宝令"}],"discussion_count":2,"race_medal":0,"score":"27322783517","product_id":100023901,"comment_content":"当线程 A 处于 WAITING、TIMED_WAITING 状态时，如果其他线程调用线程 A 的 interrupt() 方法，会使线程 A 返回到 RUNNABLE 状态，同时线程 A 的代码会触发 InterruptedException 异常。此时如果线程A获取不到锁，岂不是会立马又变成BLOCKED 状态？","like_count":6,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443808,"discussion_content":"我估计不会有中间的runnable，只是换个队列而已\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553042380,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":39026,"discussion_content":"如果不捕获异常，会从可运行变为终止……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571879485,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":116183,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1563799392,"is_pvip":false,"replies":[{"id":"53800","content":"👍","user_name":"作者回复","comment_id":116183,"uid":"1269969","ip_address":"","utype":1,"ctime":1570670510,"user_name_real":"王宝令"}],"discussion_count":2,"race_medal":0,"score":"23038635872","product_id":100023901,"comment_content":"---总结---<br>1. JAVA的线程生命周期模型在操作系统的基础上稍作了修改，一是Runnable表示可运行与运行状态（等待资源依然是Runnable），二是将休眠状态扩展成了Blocked&amp;Waiting&amp;Time_waiting三种状态<br><br>---启发---<br>1. 作为工程师能搞懂理论模型并能在其基础上按需求变化是个必备的能力<br>2. 对使用的任何类，懂得其原理和设计理念能保证更好地使用<br>3. 对使用的任何方法，懂得其操作方式和可能出现的异常也非常重要<br>4. 养成看doc的习惯<br><br>---课后思考---<br>sleep方法的java doc中写道“if any thread has interrupted the current thread. The interrupted status of the current thread is cleared when this exception is thrown.”<br>因此在try-catch中出现的中断异常被捕获后不做处理将会导致interruped status被清理。","like_count":5,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459424,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570670510,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379882,"discussion_content":"sleep方法的。。这里是stop()方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624203609,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":88284,"user_name":"xuery","can_delete":false,"product_type":"c1","uid":1027584,"ip_address":"","ucode":"F461B61BE06131","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/00/025f37e7.jpg","comment_is_top":false,"comment_ctime":1555901800,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"23030738280","product_id":100023901,"comment_content":"看了下留言，感觉自己的思考还可以深一点，应该接着问自己：如果这样不行，那应该采用什么样的写法呢，慢慢培养自己的思维习惯吧","like_count":5},{"had_liked":false,"id":78825,"user_name":"ZOU志伟","can_delete":false,"product_type":"c1","uid":1029179,"ip_address":"","ucode":"439779871CC992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b4/3b/a1f7e3a4.jpg","comment_is_top":false,"comment_ctime":1553249036,"is_pvip":false,"replies":[{"id":"28634","content":"java里的bio，例如读文件写socket<br>","user_name":"作者回复","comment_id":78825,"uid":"1269969","ip_address":"","utype":1,"ctime":1553256102,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"23028085516","product_id":100023901,"comment_content":"老师，我有个疑问，文章中讲到线程调用阻塞式 API 时，不会转换到 BLOCKED 状态，而是保持RUNNABLE状态，想知道这些阻塞式API是什么？","like_count":5,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444244,"discussion_content":"java里的bio，例如读文件写socket\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553256102,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78124,"user_name":"Docker","can_delete":false,"product_type":"c1","uid":1281995,"ip_address":"","ucode":"5789C511CB85B7","user_header":"https://static001.geekbang.org/account/avatar/00/13/8f/cb/4c7ed0d9.jpg","comment_is_top":false,"comment_ctime":1553074641,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23027911121","product_id":100023901,"comment_content":"测试过了，确实一个线程获取不到锁，线程状态为blocked","like_count":5},{"had_liked":false,"id":173837,"user_name":"feihui","can_delete":false,"product_type":"c1","uid":1007294,"ip_address":"","ucode":"13F1D4A82BC650","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/be/9ea55f46.jpg","comment_is_top":false,"comment_ctime":1579725522,"is_pvip":true,"replies":[{"id":"67403","content":"是的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1579743370,"ip_address":"","comment_id":173837,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14464627410","product_id":100023901,"comment_content":"文中这段话“如果你熟悉操作系统线程的生命周期的话，可能会有个疑问：线程调用阻塞式 API 时，是否会转换到 BLOCKED 状态呢？在操作系统层面，线程是会转换到休眠状态的，但是在 JVM 层面，Java 线程的状态不会发生变化，也就是说 Java 线程的状态会依然保持 RUNNABLE 状态。JVM 层面并不关心操作系统调度相关的状态，因为在 JVM 看来，等待 CPU 使用权（操作系统层面此时处于可执行状态）与等待 I&#47;O（操作系统层面此时处于休眠状态）没有区别，都是在等待某个资源，所以都归入了 RUNNABLE 状态。” 是不是表示JVM中的 RUNNABLE 也对应一部分的操作系统中线程的休眠状态？","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482217,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579743370,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":102083,"user_name":"粉色记忆","can_delete":false,"product_type":"c1","uid":1560131,"ip_address":"","ucode":"45C1900981DCBA","user_header":"https://static001.geekbang.org/account/avatar/00/17/ce/43/317ddb97.jpg","comment_is_top":false,"comment_ctime":1560131446,"is_pvip":false,"replies":[{"id":"36888","content":"thread的run方法return，thread就算执行完了。如果run方法里面死循环，那这个thread就永远执行不完","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1560182895,"ip_address":"","comment_id":102083,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14445033334","product_id":100023901,"comment_content":" Thread.join() 这个方法有些不解，举个例子：在主线程起个周期性任务，在周期性任务启动前调用join，join什么时候算执行完？是周期性任务一次执行完？还是周期执行完？如果是周期执行完，那么主线程不是永远备阻塞了，主线程永久阻塞不现实，那就是一次执行完？<br><br><br>老师，虾米在线等？<br>","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453252,"discussion_content":"thread的run方法return，thread就算执行完了。如果run方法里面死循环，那这个thread就永远执行不完","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560182895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":80161,"user_name":"ren","can_delete":false,"product_type":"c1","uid":1461801,"ip_address":"","ucode":"A8787FDFD56956","user_header":"https://static001.geekbang.org/account/avatar/00/16/4e/29/4b0d7a05.jpg","comment_is_top":false,"comment_ctime":1553611491,"is_pvip":true,"replies":[{"id":"29240","content":"线程调度是交给操作系统的，stw期间你看到的线程状态和stw之前应该是一样的，java里的线程状态是给你看的，没必要让你看到不该看的。但是stw期间操作系统层面的状态应该都是阻塞态，不允许调度。这个要看jvm的具体实现<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553648626,"ip_address":"","comment_id":80161,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14438513379","product_id":100023901,"comment_content":"老师。那么jvm在进行gc的时候的停顿所有线程(stw) 这个期间 jvm中的线程应该属于生命周期的哪一个状态呢？ 我看到有资料讲的是 jvm中的线程 会因为jvm设置的安全点和安全区域 执行test指令产生一个自陷异常信号 这个指令应该是汇编中的触发线程中断的 那么之后的恢复成运行状态也都是交给操作系统层面来实现的吗？","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444766,"discussion_content":"线程调度是交给操作系统的，stw期间你看到的线程状态和stw之前应该是一样的，java里的线程状态是给你看的，没必要让你看到不该看的。但是stw期间操作系统层面的状态应该都是阻塞态，不允许调度。这个要看jvm的具体实现\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553648626,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537604,"discussion_content":"具体是在pthread_cond_wait,  pthread_mutex_lock操作时交换底层链表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639114439,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79344,"user_name":"linqw","can_delete":false,"product_type":"c1","uid":1134138,"ip_address":"","ucode":"09DCFE98C54DD8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","comment_is_top":false,"comment_ctime":1553439472,"is_pvip":false,"replies":[{"id":"28944","content":"我尽量不讲源码，讲源码的书有好多，感兴趣的可以去参考。也不回拿出汇编来讲解怎么实现的，网上也有很多。听完这个专栏去再去看代码，你会觉得很简单。<br><br>区分这么多状态的原因我也没有深究，可能是历史原因，如果并发包里的锁也搞一状态，可能会更乱<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553474688,"ip_address":"","comment_id":79344,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14438341360","product_id":100023901,"comment_content":"老师，不知道能否在理论讲解清楚的同时也能补上对源码的分析，比如线程a的interrupt方法被其他线程调用，有两种形式检测，异常和使用isInterrupted检测，但是内部原理还是感觉不清楚不明白，根据异常它是如何中断的？还有java有阻塞和等待状态，但是没能理解java为什么要将其区分开来，比如阻塞是在获取不到锁阻塞，会在锁对象中的队列排队，wait等待状态，不是也会在调用的对象队列中排队么？不太清楚为什么要怎么做？","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444461,"discussion_content":"我尽量不讲源码，讲源码的书有好多，感兴趣的可以去参考。也不回拿出汇编来讲解怎么实现的，网上也有很多。听完这个专栏去再去看代码，你会觉得很简单。\n\n区分这么多状态的原因我也没有深究，可能是历史原因，如果并发包里的锁也搞一状态，可能会更乱\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553474688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537605,"discussion_content":"并发包中的锁就是借鉴了状态机流转来切换管程的阻塞队列与条件队列","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639114496,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":232719,"user_name":"刘同青","can_delete":false,"product_type":"c1","uid":1818343,"ip_address":"","ucode":"84B62DF8BC61FB","user_header":"","comment_is_top":false,"comment_ctime":1594100966,"is_pvip":false,"replies":[{"id":"85922","content":"有finally是可以的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1594130608,"ip_address":"","comment_id":232719,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10184035558","product_id":100023901,"comment_content":"老师好，经过测试stop一个持锁线程，无论是synchronized的隐士锁，还是JUC中的Lock，都是自动释放的，测试如下：<br>测试1：测试synchronized<br>public class TestStopSynchronized {<br>    public static void main(String[] args) throws Exception {<br>        Thread thread1 = new MyThread();<br>        thread1.setName(&quot;thread1&quot;);<br>        thread1.start();<br>        sleep(3);<br>        Thread thread2 = new MyThread();<br>        thread2.setName(&quot;thread2&quot;);<br>        thread2.start();<br>        sleep(3);<br>        System.out.println(nowTime() + &quot; stop thread1&quot;);<br>        thread1.stop();<br>        thread1.join();<br>        thread2.join();<br>    }<br>    private static class MyThread extends Thread{<br>        public void run() {<br>            fun1();<br>        }<br>    }<br>    private static synchronized void fun1(){<br>        System.out.println(nowTime() + Thread.currentThread().getName() + &quot; start&quot;);<br>        sleep(30);<br>        System.out.println(nowTime() + Thread.currentThread().getName() + &quot; end&quot;);<br>    }<br>    private static void sleep(long second){<br>        try {<br>            TimeUnit.SECONDS.sleep(second);<br>        } catch (InterruptedException e) {<br>            Thread.currentThread().interrupt();<br>        }<br>    }<br><br>    private static String nowTime(){<br>        return new SimpleDateFormat(&quot;yyyy&#47;MM&#47;dd HH:mm:ss&quot;).format(new Date()) + &quot; &quot;;<br>    }<br>}<br>测试1结果：<br>2020&#47;07&#47;07 13:28:28 thread1 start<br>2020&#47;07&#47;07 13:28:34  stop thread1<br>2020&#47;07&#47;07 13:28:34 thread2 start<br>2020&#47;07&#47;07 13:29:04 thread2 end<br><br>测试2：测试lock<br>public class TestStopLock {<br>    &#47;&#47;main方法和其他方法省略，和TestStopSynchronized中代码一样<br>    private static Lock lock = new ReentrantLock();<br>    private static void fun1(){<br>        lock.lock();<br>        try {<br>            System.out.println(nowTime() + Thread.currentThread().getName() + &quot; start&quot;);<br>            sleep(30);<br>            System.out.println(nowTime() + Thread.currentThread().getName() + &quot; end&quot;);<br>        }finally {<br>            lock.unlock();<br>        }<br>    }<br>}<br><br>测试结果：<br><br>2020&#47;07&#47;07 13:27:20 thread1 start<br>2020&#47;07&#47;07 13:27:26  stop thread1<br>2020&#47;07&#47;07 13:27:26 thread2 start<br>2020&#47;07&#47;07 13:27:56 thread2 end","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500751,"discussion_content":"有finally是可以的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594130608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1818343,"avatar":"","nickname":"刘同青","note":"","ucode":"84B62DF8BC61FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289556,"discussion_content":"其实我说错啦，以上代码中JUC是Lock不是自动释放的，是主动释放的，实际上是stop线程并不会跳过finally代码块。当然如果没进去try代码块就被stop了，那自然不会执行finally代码块，这会造成&#34;锁&#34;永远不会释放，而其他线程永远无法获取锁。\n\n\n测试代码:\n\npublic class TestStopLockThread {\n    private static Lock lock = new ReentrantLock();\n    public static void main(String[] args) throws Exception {\n        Thread thread1 = new MyThread();\n        thread1.setName(&#34;thread1&#34;);\n        thread1.start();\n        sleep(3);\n        Thread thread2 = new MyThread();\n        thread2.setName(&#34;thread2&#34;);\n        thread2.start();\n        //直接杀死\n        System.out.println(nowTime() + &#34; stop thread1&#34;);\n        thread1.stop();\n        //等待线程终止\n        thread1.join();\n        thread2.join();\n    }\n    private static class MyThread extends Thread{\n        @Override\n        public void run() {\n            fun1();\n        }\n    }\n    private static void fun1(){\n        System.out.println(nowTime() + Thread.currentThread().getName() + &#34; start&#34;);\n        lock.lock();\n        //假设恰好在此刻被stop了,下面通过睡眠来模拟这种特殊情况\n        sleep(10);\n        try {\n            sleep(30);\n            System.out.println(nowTime() + Thread.currentThread().getName() + &#34; end&#34;);\n        }finally {\n            System.out.println(nowTime() + Thread.currentThread().getName() + &#34; finally代码块被执行&#34;);\n            lock.unlock();\n        }\n    }\n    \n}\n\n过了很久很久，控制台输出如下:\n\n2020/07/07 22:44:37 thread1 start\n2020/07/07 22:44:40  stop thread1\n2020/07/07 22:44:40 thread2 start\n\n说明stop线程可能导致lock未释放","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594133772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1240298,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ec/ea/c33e5a3d.jpg","nickname":"何领","note":"","ucode":"F0F2B11CF5C9FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1818343,"avatar":"","nickname":"刘同青","note":"","ucode":"84B62DF8BC61FB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299102,"discussion_content":"大佬你好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597564504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":289556,"ip_address":""},"score":299102,"extra":""}]}]},{"had_liked":false,"id":137331,"user_name":"小白","can_delete":false,"product_type":"c1","uid":1205485,"ip_address":"","ucode":"862EA133563634","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJUhJakYu4BI7eFnheKDdibDjZqz32ia2rhN0Jz5YoR1ZRlDrLcFNr4MJnPg3WiaxaocWotOANeqsBibw/132","comment_is_top":false,"comment_ctime":1569717039,"is_pvip":false,"replies":[{"id":"52829","content":"必须放try finally里，否则就有问题","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1569757043,"ip_address":"","comment_id":137331,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10159651631","product_id":100023901,"comment_content":"stop之后可以释放锁吧。。。","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469037,"discussion_content":"必须放try finally里，否则就有问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569757043,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81155,"user_name":"life is short, enjoy more.","can_delete":false,"product_type":"c1","uid":1074805,"ip_address":"","ucode":"3B5F37D30790A7","user_header":"https://static001.geekbang.org/account/avatar/00/10/66/75/54bb858e.jpg","comment_is_top":false,"comment_ctime":1553822854,"is_pvip":false,"replies":[{"id":"29455","content":"jvm就这么设计的，谁知道呢","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553833470,"ip_address":"","comment_id":81155,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10143757446","product_id":100023901,"comment_content":"老师，请问思考题中，为什么抛异常就会重置标识呢？","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445097,"discussion_content":"jvm就这么设计的，谁知道呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553833470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79821,"user_name":"Lorne.Z","can_delete":false,"product_type":"c1","uid":1109854,"ip_address":"","ucode":"8C67D82246A3AC","user_header":"https://static001.geekbang.org/account/avatar/00/10/ef/5e/381d043b.jpg","comment_is_top":false,"comment_ctime":1553561561,"is_pvip":false,"replies":[{"id":"29098","content":"可以<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553562966,"ip_address":"","comment_id":79821,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10143496153","product_id":100023901,"comment_content":"老师，这样是不是也可以，在异常里加一个break<br>Thread thread = Thread.currentThread();<br>        while (true) {<br>            if (thread.isInterrupted()) {<br>                break;<br>            }<br>            try {<br>                Thread.sleep(100);<br>            } catch (InterruptedException e) {<br>                e.printStackTrace();<br>                break;<br>            }<br>        }","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444642,"discussion_content":"可以\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553562966,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77846,"user_name":"忠艾一生","can_delete":false,"product_type":"c1","uid":1445386,"ip_address":"","ucode":"DE8DF66F379054","user_header":"https://static001.geekbang.org/account/avatar/00/16/0e/0a/1564a5e1.jpg","comment_is_top":false,"comment_ctime":1553007338,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10142941930","product_id":100023901,"comment_content":"这段代码中的线程对象并没有调用th.interrupt（）,只是调用了sleep()方法，此时线程并没有中断，也不会发生异常，sleep（）过后，线程继续自动执行。所以也不会进入到if代码块。<br>不知道我说的对不对啊老师。。。","like_count":2,"discussions":[{"author":{"id":1077931,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Wy62w9wUM6hLpx7wSw0M1SPoT6pKr07yPHOib56CvtzIQ96t7eZkG4UHQ2kgp9jzBJzfxB1mlP8ibosdqxVwicQUw/132","nickname":"三良","note":"","ucode":"1AAAAED847D85E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":199201,"discussion_content":"这段代码的问题在于，当执行这段代码的线程th调用sleep()方法进入TIMED_WAITTING状态后，在sleep()结束返回 RUNNABLE状态之前，其他线程调用了th.interrupt()方法触发了中断，sleep()方法会抛出 InterruptedException。\n这里并没有列出其他线程调用th.interrupt()的代码，但是在try-catch部分考虑了其他线程调用th.interrupt()而触发中断的情况。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583569334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":317273,"user_name":"SharpBB","can_delete":false,"product_type":"c1","uid":2014573,"ip_address":"","ucode":"D30C5B798B8E8C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/bd/6d/7010f98e.jpg","comment_is_top":false,"comment_ctime":1634729194,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5929696490","product_id":100023901,"comment_content":" 这是我写的中断程序代码 便于大家调试     <br><br>   Thread th = Thread.currentThread();<br>        new Thread(()-&gt;{<br>            try {<br>                Thread.sleep(300);<br>            } catch (InterruptedException e) {<br>                e.printStackTrace();<br>            }<br>            th.interrupt();<br>        }).start();<br>        while(true) {<br>            if(th.isInterrupted()) {<br>                break;<br>            }<br>            &#47;&#47; 省略业务代码无数<br>            try {<br>                Thread.sleep(100);<br>            }catch (InterruptedException e){<br>                &#47;&#47;注意这里因为线程的状态被中断 直接抛出异常 且清除标志位 其实就是调用两次interrupt false-&gt;true-&gt;false<br>                System.out.println(Thread.currentThread().isInterrupted());&#47;&#47;打印false<br>                &#47;&#47;所以要再重置下标志位 改为true<br>                Thread.currentThread().interrupt();<br>                System.out.println(Thread.currentThread().isInterrupted());&#47;&#47;打印true<br>                e.printStackTrace();<br>            }<br>        }","like_count":1},{"had_liked":false,"id":301911,"user_name":"ddww","can_delete":false,"product_type":"c1","uid":1184678,"ip_address":"","ucode":"2871112FC9B3F7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJDgV2qia6eAL7Fb4egX3odViclRRwOlkfCBrjhU9lLeib90KGkIDjdddSibNVs47N90L36Brgnr6ppiag/132","comment_is_top":false,"comment_ctime":1625972184,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5920939480","product_id":100023901,"comment_content":"关于王老师，课后思考题。我有这样的想法，不知道对还是不对，希望老师，和同学看到能解答一下。思考题的代码，我觉得，会出现两种情况，当调用Thread.interrupt时，如果正好在判断，是否会中断，程序return.如果在sleep，中断的是sleep。和这个线程无关。大家可以看下，我写的代码示例。<br>public static void main(String[] args) {<br>        Thread thread = new Thread(() -&gt; {<br>                while (true){<br>                    if (Thread.currentThread().isInterrupted()){<br>                        System.out.println(&quot;中断线程&quot;);<br>                        return;<br>                    }<br>                    try {<br>                        Thread.sleep(1000);<br>                    } catch (InterruptedException e) {<br>                        System.out.println(&quot;sleep 被中断&quot;);<br>                        e.printStackTrace();<br>                    }<br>                    &#47;&#47;模拟处理时间,让中断尽可能发生在判断时<br>                    for (int i = 0; i &lt; 1000000000L; i++) {<br><br>                    }<br>                }<br>        });<br>        thread.start();<br>        try {<br>            Thread.sleep(1000);<br>        } catch (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br>        thread.interrupt();<br>    }","like_count":1},{"had_liked":false,"id":281106,"user_name":"LQS  KF","can_delete":false,"product_type":"c1","uid":1364737,"ip_address":"","ucode":"3C0A07A8220094","user_header":"https://static001.geekbang.org/account/avatar/00/14/d3/01/716d45b6.jpg","comment_is_top":false,"comment_ctime":1614584848,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5909552144","product_id":100023901,"comment_content":"最好是使用自定义标志位来判断，因为可能在处理业务的时候别人的jar中有方法吞掉了标志位而没有使用Thread.currentThread().interrupt();重新标记。","like_count":1},{"had_liked":false,"id":216015,"user_name":"bin.chen","can_delete":false,"product_type":"c1","uid":1135604,"ip_address":"","ucode":"5BA49358AB8A1A","user_header":"https://static001.geekbang.org/account/avatar/00/11/53/f4/e277325d.jpg","comment_is_top":false,"comment_ctime":1589167957,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5884135253","product_id":100023901,"comment_content":"1.stop是暴力型的停止线程---最终程序出现意想不到的错误<br>2.interrupt是优雅型通知线程(仅仅是通知)<br>   2.1 interrupt仅仅通知线程你需要停止了(对应程序就是线程设置了一个标志位)<br>   2.2 是否停止是被通知线程自己决定(停不停止自己说了算，别人无法干涉)<br>  <br>  对于有中断异常的处理<br>     1.线程内有检测中断的逻辑<br>     2.执行阻塞得到方法时应该显示的处理中断异常(程序都有提示哪些是需要被处理的阻塞方法)<br><br> 中断标志会被清除的情况<br>            1.抛出中断异常的时候<br>            2.调用Thread.interrupted()时","like_count":1},{"had_liked":false,"id":202370,"user_name":"once","can_delete":false,"product_type":"c1","uid":1170533,"ip_address":"","ucode":"7026094E0B99BF","user_header":"https://static001.geekbang.org/account/avatar/00/11/dc/65/3da02c30.jpg","comment_is_top":false,"comment_ctime":1585978244,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"5880945540","product_id":100023901,"comment_content":"只要 Java 线程处于这三种状态之一，那么这个线程就永远没有 CPU 的使用权  老师 文章里是这样说的 那如果有个线程获取synchronized 锁失败而进入了blocked状态 不就永远没有cpu的使用权了么 那也就不会再去尝试获取锁  然后后面又说获取了锁后就会从block切换为runnable 这里是否矛盾","like_count":1,"discussions":[{"author":{"id":1446874,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK2sqFM20XhgC5xjEfDhbB1lk6rIe7LnqnxEicDdEcRSJ20YCTeBEcYFE84lvHFrJDq9n4WW7P9Zkg/132","nickname":"nothing","note":"","ucode":"B984E8590D0349","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558606,"discussion_content":"没有 CPU 使用权就是没有在使用 CPU,但是可以等待获取 CPU 使用权,等待也可以是抢的过程,不知道这样理解是否正确?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648394178,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174315,"user_name":"在路上","can_delete":false,"product_type":"c1","uid":1641319,"ip_address":"","ucode":"E1184E76B14431","user_header":"https://static001.geekbang.org/account/avatar/00/19/0b/67/dc49a1a8.jpg","comment_is_top":false,"comment_ctime":1580136415,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5875103711","product_id":100023901,"comment_content":"我就是想问下，关于结果中的被打断并抛出异常，为什么会清空中断标记？这个设计的初衷是什么？这不是很误导人吗？","like_count":1},{"had_liked":false,"id":166576,"user_name":"乾坤瞬间","can_delete":false,"product_type":"c1","uid":1683130,"ip_address":"","ucode":"15BDCF29CBF8EB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","comment_is_top":false,"comment_ctime":1577506344,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5872473640","product_id":100023901,"comment_content":"我就是想问下，关于结果中的被打断并抛出异常，为什么会清空中断标记？这个设计的初衷是什么？这不是很误导人吗？","like_count":1},{"had_liked":false,"id":148095,"user_name":"考休","can_delete":false,"product_type":"c1","uid":1053955,"ip_address":"","ucode":"968DFC00D6D0CF","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/03/c0fe1dbf.jpg","comment_is_top":false,"comment_ctime":1572940279,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5867907575","product_id":100023901,"comment_content":"线程的本质实际是操作系统中的线程，只是编程语言通常会对线程进行一些封装，例如操作系统中的休眠状态与Java中的线程状态(Blocked, time_waiting, waiting)三种状态之间的关系。<br>另外线程的中止不能使用stop()方法，通常使用interupt()方法中止线程，因为直接使用stop方法停止线程，有可能造成有点锁永远不会被释放，造成系统问题。 ","like_count":1},{"had_liked":false,"id":136494,"user_name":"runzhliu","can_delete":false,"product_type":"c1","uid":1442431,"ip_address":"","ucode":"CD51D9465D7A05","user_header":"https://static001.geekbang.org/account/avatar/00/16/02/7f/ddf56ac5.jpg","comment_is_top":false,"comment_ctime":1569460201,"is_pvip":false,"replies":[{"id":"52328","content":"😄","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1569464456,"ip_address":"","comment_id":136494,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5864427497","product_id":100023901,"comment_content":"这篇是真的非常经典，而且就在app上，随便一翻就能查阅！","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468665,"discussion_content":"😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569464456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134581,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1568871405,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"5863838701","product_id":100023901,"comment_content":"很明显代码开始和结束的时候都依赖Interrupted信号，但如果在线程Sleep期间被中断，会抛出异常，被catch捕获到之后，循环再次检测应该就检测不到这个中断了(应该是中断标志位被清除了)，也就是编码中要注意的不该吃异常的时候多吃了异常，业务代码这么写会埋很大的坑的啊。","like_count":1,"discussions":[{"author":{"id":1543474,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8d/32/1ba05b8c.jpg","nickname":"阿伦桑","note":"","ucode":"DE9C7A62AAEB34","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70050,"discussion_content":"这时候findbugs工具就会提醒你在catch里加一句Thread.currentThread().interrupt(); \n哈哈 😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575303245,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108392,"user_name":"z.l","can_delete":false,"product_type":"c1","uid":1181055,"ip_address":"","ucode":"805CC5784D3F76","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/7f/d35ab9a1.jpg","comment_is_top":false,"comment_ctime":1561736745,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5856704041","product_id":100023901,"comment_content":"请问线程池中的某个线程任务执行结束后，生命周期如何转化？线程栈的局部变量又如何清理？","like_count":1},{"had_liked":false,"id":108390,"user_name":"z.l","can_delete":false,"product_type":"c1","uid":1181055,"ip_address":"","ucode":"805CC5784D3F76","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/7f/d35ab9a1.jpg","comment_is_top":false,"comment_ctime":1561736591,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5856703887","product_id":100023901,"comment_content":"赞，这篇至少要读3遍","like_count":1},{"had_liked":false,"id":88265,"user_name":"xuery","can_delete":false,"product_type":"c1","uid":1027584,"ip_address":"","ucode":"F461B61BE06131","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/00/025f37e7.jpg","comment_is_top":false,"comment_ctime":1555901530,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5850868826","product_id":100023901,"comment_content":"试着先回答下，<br>当调用当前线程的interrput()方法时，会触发Thread.sleep(100)抛出InterruptedException，之后被catch住，所以th.isInterrupted检测不到中断，无法退出while循环","like_count":1},{"had_liked":false,"id":80983,"user_name":"^_^","can_delete":false,"product_type":"c1","uid":1088001,"ip_address":"","ucode":"EE5DAC03CFC2EE","user_header":"https://static001.geekbang.org/account/avatar/00/10/9a/01/1489f98d.jpg","comment_is_top":false,"comment_ctime":1553768923,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5848736219","product_id":100023901,"comment_content":"class MyThread extends Thread {<br>      @Override<br>       public void run() {<br>      }<br>}<br>","like_count":1},{"had_liked":false,"id":78404,"user_name":"靠人品去赢","can_delete":false,"product_type":"c1","uid":1301286,"ip_address":"","ucode":"7A20F9EBE847E1","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/26/54f2c164.jpg","comment_is_top":false,"comment_ctime":1553141051,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5848108347","product_id":100023901,"comment_content":"（1）Interrupt()只是一个通知可以中断并不能真的去中断线程<br>（2）IsIntrrupt()方法是检查有没有中断<br>于是就会出现一种状况，线程没有中断，while就一直循环。关于try catch会不会重置中断标记，让其中断不了这个我就不了解，不知道具体原理（是异常错误那部分吗？）。<br>还有作者用Jstack命令和Java visualVM工具检查死锁真的是一个很棒的检查死锁的思路。","like_count":1},{"had_liked":false,"id":78294,"user_name":"JGOS","can_delete":false,"product_type":"c1","uid":1237592,"ip_address":"","ucode":"46A905A169408F","user_header":"https://static001.geekbang.org/account/avatar/00/12/e2/58/2468a5e9.jpg","comment_is_top":false,"comment_ctime":1553127000,"is_pvip":false,"replies":[{"id":"28570","content":"其他running会占cpu","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553170734,"ip_address":"","comment_id":78294,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5848094296","product_id":100023901,"comment_content":"老师，调用阻塞API时Java层面是runnable状态，那他是ready状态还是running状态，占用CPU吗？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444038,"discussion_content":"其他running会占cpu","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553170734,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78292,"user_name":"JGOS","can_delete":false,"product_type":"c1","uid":1237592,"ip_address":"","ucode":"46A905A169408F","user_header":"https://static001.geekbang.org/account/avatar/00/12/e2/58/2468a5e9.jpg","comment_is_top":false,"comment_ctime":1553126852,"is_pvip":false,"replies":[{"id":"28537","content":"不占，操作系统里的状态才有用<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553141060,"ip_address":"","comment_id":78292,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5848094148","product_id":100023901,"comment_content":"老师，问下Java调用阻塞API时，Javav层面是runnable，那仍然占用CPU？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444037,"discussion_content":"不占，操作系统里的状态才有用\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553141060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379911,"discussion_content":"Java调用阻塞API时，Java层面是runnable，不占用cpu，在操作系统中是阻塞状态","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624242219,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77469,"user_name":"小华","can_delete":false,"product_type":"c1","uid":1402795,"ip_address":"","ucode":"902E7ED95D73BA","user_header":"https://static001.geekbang.org/account/avatar/00/15/67/ab/facff632.jpg","comment_is_top":false,"comment_ctime":1552953218,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5847920514","product_id":100023901,"comment_content":"isInterrupted方法只是检测线程是否被标记为了中断状态，而不会改变线程的中断状态，代码中，没有调用线程的interrupted方法，所以线程的中断状态为false，while循环不会退出，也不会拋InterruptedException","like_count":1},{"had_liked":false,"id":77467,"user_name":"高源","can_delete":false,"product_type":"c1","uid":1048887,"ip_address":"","ucode":"751B41FD38EF7D","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/37/12e4c9c9.jpg","comment_is_top":false,"comment_ctime":1552951966,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5847919262","product_id":100023901,"comment_content":"我理解第一执行时候不符合条件，执行了sleep，触发了中断异常了进入catch部分处理，因为while true条件程序返回到重新判断是否是此线程的，现在满足条件退出此循环","like_count":1},{"had_liked":false,"id":77463,"user_name":"不靠谱的琴谱","can_delete":false,"product_type":"c1","uid":1243964,"ip_address":"","ucode":"D388EDFD6E5F8C","user_header":"https://static001.geekbang.org/account/avatar/00/12/fb/3c/e92d40f6.jpg","comment_is_top":false,"comment_ctime":1552948885,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5847916181","product_id":100023901,"comment_content":"线程处于runnable时可以退出，思考题大部分处于 wait_timed状态，并且吞了异常；所以有那么一丢丢的几率会退出，大部分情况无法退出","like_count":1},{"had_liked":false,"id":358172,"user_name":"Geek_bbe926","can_delete":false,"product_type":"c1","uid":2736733,"ip_address":"广东","ucode":"573882AED6A49D","user_header":"","comment_is_top":false,"comment_ctime":1663999117,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663999117","product_id":100023901,"comment_content":"老师，当前thread2 是Blocked状态，我在if判断然后重新获取Thread2的状态，得到的是RUNNABLE 状态。<br>  if (thread2.getState().equals(&quot;BLOCKED&quot;)) {<br>            thread2.interrupt();<br>        }","like_count":0},{"had_liked":false,"id":356944,"user_name":"孟萌","can_delete":false,"product_type":"c1","uid":2355072,"ip_address":"广东","ucode":"A248F11822477F","user_header":"https://static001.geekbang.org/account/avatar/00/23/ef/80/deddab6a.jpg","comment_is_top":false,"comment_ctime":1662714164,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662714164","product_id":100023901,"comment_content":"在java线程周期中<br>1）当等待获得显式锁的线程是变换到了什么状态；<br>2）获得显式锁后，调用condition的await()又是什么状态","like_count":0},{"had_liked":false,"id":356943,"user_name":"孟萌","can_delete":false,"product_type":"c1","uid":2355072,"ip_address":"广东","ucode":"A248F11822477F","user_header":"https://static001.geekbang.org/account/avatar/00/23/ef/80/deddab6a.jpg","comment_is_top":false,"comment_ctime":1662714055,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662714055","product_id":100023901,"comment_content":"1）当等待获得显式锁的线程是变换到了什么状态；<br>2）获得显式锁后，调用condition的await()又是什么状态","like_count":0},{"had_liked":false,"id":355125,"user_name":"dokcn","can_delete":false,"product_type":"c1","uid":1467267,"ip_address":"山西","ucode":"26F292C75A9086","user_header":"https://static001.geekbang.org/account/avatar/00/16/63/83/1648b01d.jpg","comment_is_top":false,"comment_ctime":1661100236,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661100236","product_id":100023901,"comment_content":"感谢老师 讲的真的很好","like_count":0},{"had_liked":false,"id":352195,"user_name":"killeroppo","can_delete":false,"product_type":"c1","uid":1815768,"ip_address":"","ucode":"C167BA07268273","user_header":"https://static001.geekbang.org/account/avatar/00/1b/b4/d8/67a31275.jpg","comment_is_top":false,"comment_ctime":1658452547,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1658452547","product_id":100023901,"comment_content":"线程要具备感知中断的能力。举个例子，现在突然关掉电脑，微信还在运行（比如在传送图片），人家wx线程还在传送图片到一半，还没反应过来（可能当时刚好发送一半的图片），你就断电了，你想想别人收到你的图片会是完整的吗？<br><br>sleep之后，如何让sleep的线程醒呢？<br><br><br>答案：中断（指令：0x80）<br><br>在java上叫异常，被中断叫醒后，会把中断标识重置（jdk api上有说这点），所以用isInterrupted()无法判断是否被中断！","like_count":0},{"had_liked":false,"id":348684,"user_name":"浮石沉木","can_delete":false,"product_type":"c1","uid":2223167,"ip_address":"","ucode":"D585768321B84A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/mQddXC7nRiaKHTwdficicTB3bH0q5ic5UoSab51Omic7eyLBz0SNcvbLpQnNib7zP1yJFm7xxx4ia81iahfibRVnbTwHmhw/132","comment_is_top":false,"comment_ctime":1655300726,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655300726","product_id":100023901,"comment_content":"拿就医在门口外排队的例子，病患此时是不是BLOCK状态？","like_count":0},{"had_liked":false,"id":347651,"user_name":"月明风清","can_delete":false,"product_type":"c1","uid":2226367,"ip_address":"","ucode":"65A97CF2E320FA","user_header":"https://static001.geekbang.org/account/avatar/00/21/f8/bf/59f2e600.jpg","comment_is_top":false,"comment_ctime":1654251627,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654251627","product_id":100023901,"comment_content":"RUNNABLE 与 WAITING 的状态转换<br>第一种场景，获得 synchronized 隐式锁的线程，调用无参数的 Object.wait() 方法。<br>这里的 Object.wait() 是什么意思呀，是锁对象的wait() 吗？还是指 Object类的wait()","like_count":0},{"had_liked":false,"id":345789,"user_name":"学习学个屁","can_delete":false,"product_type":"c1","uid":1049017,"ip_address":"","ucode":"DF2D61E6FB2FCE","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","comment_is_top":false,"comment_ctime":1652599971,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652599971","product_id":100023901,"comment_content":"抛出打断异常后，标志会被清除。所以是false 循环会被一直进行下去；<br>还有可能会退出，如果没在睡眠状态被打断，就回退出。","like_count":0},{"had_liked":false,"id":345788,"user_name":"学习学个屁","can_delete":false,"product_type":"c1","uid":1049017,"ip_address":"","ucode":"DF2D61E6FB2FCE","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","comment_is_top":false,"comment_ctime":1652599640,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652599640","product_id":100023901,"comment_content":"可能被中断，也可能不会被中断。<br>Thread.sleep(100); 被try捕获 会重置终端标志。会一直循环下去","like_count":0},{"had_liked":false,"id":345058,"user_name":"凌霄","can_delete":false,"product_type":"c1","uid":1107786,"ip_address":"","ucode":"19C4BFB0298276","user_header":"https://static001.geekbang.org/account/avatar/00/10/e7/4a/4dfb565a.jpg","comment_is_top":false,"comment_ctime":1651992950,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651992950","product_id":100023901,"comment_content":"Thread.currentThread().interrupt();","like_count":0},{"had_liked":false,"id":341658,"user_name":"Geek_92b8a3","can_delete":false,"product_type":"c1","uid":2642899,"ip_address":"","ucode":"706EB1F2575FAA","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLOWucpCLACCUR59wF1fPRMaJI3lUJAlFYo57ib6Maq0U9aweCuQQicAybjRYN1MeUZBQNW6LXFicyew/132","comment_is_top":false,"comment_ctime":1649754854,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649754854","product_id":100023901,"comment_content":"老师，说实话，你这个思考题我没有理解，没有调用thread.interrupt();<br>为什么会发生中断呢？","like_count":0},{"had_liked":false,"id":335684,"user_name":"sotondolphin","can_delete":false,"product_type":"c1","uid":2306394,"ip_address":"","ucode":"136444B47ACDC5","user_header":"","comment_is_top":false,"comment_ctime":1645626970,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1645626970","product_id":100023901,"comment_content":"应该把thread 声明放到while里面。现在的情况只能判断声明当时的线程状态","like_count":0},{"had_liked":false,"id":327657,"user_name":"hunter","can_delete":false,"product_type":"c1","uid":1196266,"ip_address":"","ucode":"EFBF6071BFCE10","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ5ricEp2SDpA2d2iaw6TOVaPfmeicDicP34bamibX1JbHEkJl8wDQOK3ia4vic9WacKjFia9wibeG3nwOIiafA/132","comment_is_top":false,"comment_ctime":1640222888,"is_pvip":false,"replies":[{"id":"119892","content":"不能","user_name":"作者回复","user_name_real":"编辑","uid":"1269969","ctime":1641194148,"ip_address":"","comment_id":327657,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1640222888","product_id":100023901,"comment_content":"请问休眠状态可以直接到终止状态吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543524,"discussion_content":"不能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641194148,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":315936,"user_name":"hello","can_delete":false,"product_type":"c1","uid":1649057,"ip_address":"","ucode":"4F42DAA5DB5C38","user_header":"https://static001.geekbang.org/account/avatar/00/19/29/a1/41607383.jpg","comment_is_top":false,"comment_ctime":1634057235,"is_pvip":true,"replies":[{"id":"114497","content":"并发包里的是进入waiting系状态","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1634122954,"ip_address":"","comment_id":315936,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1634057235","product_id":100023901,"comment_content":"文中说“RUNNABLE 与 BLOCKED 的状态转换只有一种场景会触发这种转换，就是线程等待 synchronized 的隐式锁。”<br>lock 也可以达到synchronized 相同的目的呀，虽然lock 是并发包里面的，但也是java 的呀。但为什么文中说只有synchronized 这一种情况呢？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528210,"discussion_content":"并发包里的是进入waiting系状态","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634122954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314221,"user_name":"Jussi Lee","can_delete":false,"product_type":"c1","uid":1211190,"ip_address":"","ucode":"F2F5948CCD52A2","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/36/fd46331c.jpg","comment_is_top":false,"comment_ctime":1632905712,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632905712","product_id":100023901,"comment_content":"当线程 A 处于 RUNNABLE 状态时，并且阻塞在 java.nio.channels.InterruptibleChannel 上时，如果其他线程调用线程 A 的 interrupt() 方法，线程 A 会触发 java.nio.channels.ClosedByInterruptException 这个异常；而阻塞在 java.nio.channels.Selector 上时，如果其他线程调用线程 A 的 interrupt() 方法，线程 A 的 java.nio.channels.Selector 会立即返回  这里写错了吧","like_count":0},{"had_liked":false,"id":307463,"user_name":"听风有信","can_delete":false,"product_type":"c1","uid":2683430,"ip_address":"","ucode":"2CCB467114FF5C","user_header":"https://static001.geekbang.org/account/avatar/00/28/f2/26/a8ac6b42.jpg","comment_is_top":false,"comment_ctime":1629112192,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1629112192","product_id":100023901,"comment_content":"sleep会清空打断标记","like_count":0},{"had_liked":false,"id":294209,"user_name":"王智","can_delete":false,"product_type":"c1","uid":1079657,"ip_address":"","ucode":"0335277F255F7A","user_header":"https://static001.geekbang.org/account/avatar/00/10/79/69/5960a2af.jpg","comment_is_top":false,"comment_ctime":1621832617,"is_pvip":false,"replies":[{"id":"106775","content":"唤醒的只有线程，锁只能被解锁，解锁后，会唤醒等待锁的线程","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1621900327,"ip_address":"","comment_id":294209,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1621832617","product_id":100023901,"comment_content":"获得 synchronized 隐式锁的线程，调用带超时参数的 Object.wait(long timeout) 方法； 中如何获取隐式锁的线程呢？使用Thread.currentThread()获取吗？这个隐式锁也是没有办法指定唤醒的，是吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520558,"discussion_content":"唤醒的只有线程，锁只能被解锁，解锁后，会唤醒等待锁的线程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621900327,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":292396,"user_name":"gsz","can_delete":false,"product_type":"c1","uid":1147531,"ip_address":"","ucode":"8FD1B41E884B18","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/8b/5340fb27.jpg","comment_is_top":false,"comment_ctime":1620804637,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1620804637","product_id":100023901,"comment_content":"有一个疑问，symchrinized隐式锁是blocked状态，并发包中的ReentrantLock的lock是进入什么状态","like_count":0,"discussions":[{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379917,"discussion_content":"lock后是waiting","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624244707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":286824,"user_name":"张滔","can_delete":false,"product_type":"c1","uid":1322636,"ip_address":"","ucode":"87ABAFF0E861E0","user_header":"https://static001.geekbang.org/account/avatar/00/14/2e/8c/b261e15a.jpg","comment_is_top":false,"comment_ctime":1617616362,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617616362","product_id":100023901,"comment_content":"老师，TIMED_WAITING到RUNNABLE，是到达了参数里面的long毫秒自动切换回来吗？","like_count":0},{"had_liked":false,"id":275766,"user_name":"成电帅才","can_delete":false,"product_type":"c1","uid":2139604,"ip_address":"","ucode":"DDE757138F41D2","user_header":"","comment_is_top":false,"comment_ctime":1611662483,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611662483","product_id":100023901,"comment_content":"如果先sleep，然后设置标记位，会抛出异常，那么如果是先设置标志位，然后再sleep，结果会是什么样子的呢？","like_count":0},{"had_liked":false,"id":262239,"user_name":"Geek_89e362","can_delete":false,"product_type":"c1","uid":2308075,"ip_address":"","ucode":"E596C2CFE1CFAF","user_header":"","comment_is_top":false,"comment_ctime":1605671510,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605671510","product_id":100023901,"comment_content":"思考题：<br>  执行中断操作后，不会退出，还好继续执行，原因是 Thread.sleep()方法会擦除中断标志，可以进行如下更改<br><br>Thread th = Thread.currentThread();<br>while(true) {<br>  if(th.isInterrupted()) {<br>    break;<br>  }<br>  &#47;&#47; 省略业务代码无数<br>  try {<br>    Thread.sleep(100);<br>  }catch (InterruptedException e){<br>    e.printStackTrace();<br>    Thread.currentThread().interrupt();<br>  }<br>}","like_count":0},{"had_liked":false,"id":261301,"user_name":"Geek_c75d82","can_delete":false,"product_type":"c1","uid":2286012,"ip_address":"","ucode":"81202A016FC5D2","user_header":"","comment_is_top":false,"comment_ctime":1605261766,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605261766","product_id":100023901,"comment_content":"Sleep 让出CPU，阻塞线程，等到超过100ms，线程到runnable状态，并没有到terminal状态，所以会一直循环下去","like_count":0},{"had_liked":false,"id":261282,"user_name":"超级蛋蛋饭","can_delete":false,"product_type":"c1","uid":1249616,"ip_address":"","ucode":"AD2BECE789B365","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/wiaQmkQdIh84RibSLrDkIA3HtibAR4IibpnP3VEmiaLzvpiaibXJQEb2LLUrCD4dM7DjvOFD65IbdZm2Mn68O71FxiaAow/132","comment_is_top":false,"comment_ctime":1605257700,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605257700","product_id":100023901,"comment_content":"老师，这章讲的太好了，以前看网上博客讲各种状态，都是云里雾里，看完老师这章，一下子就通透了","like_count":0},{"had_liked":false,"id":241388,"user_name":"Geek_55af7e","can_delete":false,"product_type":"c1","uid":1973271,"ip_address":"","ucode":"A1F599FA0E5C6A","user_header":"","comment_is_top":false,"comment_ctime":1597283308,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1597283308","product_id":100023901,"comment_content":"这里的Thread.sleep()，使线程进入阻塞状态吗？在场景Runnable-&gt;timed_waiting里，没有太明白？差了资料，也是说Thread.sleep进入的使阻塞状态","like_count":0},{"had_liked":false,"id":237813,"user_name":"max","can_delete":false,"product_type":"c1","uid":1773471,"ip_address":"","ucode":"91DDE86511DCDC","user_header":"https://static001.geekbang.org/account/avatar/00/1b/0f/9f/caae319d.jpg","comment_is_top":false,"comment_ctime":1595980309,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595980309","product_id":100023901,"comment_content":"Java 在调用阻塞式 API 时，线程会阻塞，指的是操作系统线程的状态，并不是 Java 线程的状态，也就是说上文描述的都不是JAVA的线程状态，那JAVA的线程状态：会有阻塞这个概念吗","like_count":0},{"had_liked":false,"id":210103,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1587687807,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587687807","product_id":100023901,"comment_content":"interrupt只是设置了线程被中断的标志，像sleep wait这种可被中断的方法，遇到interrupt会抛异常，其实就说明线程被中断了，中断标志位就没作用了，会被清除中断标志位，再次判断的时候中断位永远是false，问题中的方法会陷入死循环。需要重置标志位才行。<br>中断相关的方法有interrupt  isInterrupted interrupted三个","like_count":0},{"had_liked":false,"id":204072,"user_name":"云韵","can_delete":false,"product_type":"c1","uid":1025622,"ip_address":"","ucode":"3DE26DBAAAEDE6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a6/56/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1586329215,"is_pvip":true,"replies":[{"id":"76486","content":"这个建议看看操作系统里面的进程&#47;线程管理相关章节吧，进程&#47;线程都有自己的状态，操作系统不知道有jvm这个东西。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1586430368,"ip_address":"","comment_id":204072,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1586329215","product_id":100023901,"comment_content":"“而 JVM 层面不关心这两个状态，因为 JVM 把线程调度交给操作系统处理了” 操作系统是怎么判断JVM的这两个状态呢？麻烦王老师解答一下","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491068,"discussion_content":"这个建议看看操作系统里面的进程/线程管理相关章节吧，进程/线程都有自己的状态，操作系统不知道有jvm这个东西。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586430368,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203341,"user_name":"女巫在寒江","can_delete":false,"product_type":"c1","uid":1013180,"ip_address":"","ucode":"B3707072224C1C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/bc/664bbdf7.jpg","comment_is_top":false,"comment_ctime":1586177144,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1586177144","product_id":100023901,"comment_content":"当抛出了InterruptedException后，线程的中断标志位会被清掉，按示例中的代码，终端盒再去检查标志位就会发现isInterrupted为false，这样就永远退出不了循环<br><br>正确的做法是，在InterruptedException抛出后，调用Thread.interrupt()把中断标识位重新设为已中断。","like_count":0},{"had_liked":false,"id":202060,"user_name":"指尖流逝","can_delete":false,"product_type":"c1","uid":1005381,"ip_address":"","ucode":"417009F674FAF1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/45/c418ea5c.jpg","comment_is_top":false,"comment_ctime":1585896071,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585896071","product_id":100023901,"comment_content":"写的很棒，思路好流畅。有学习到，感谢~","like_count":0},{"had_liked":false,"id":201203,"user_name":"努力呼吸","can_delete":false,"product_type":"c1","uid":1718303,"ip_address":"","ucode":"52941DD7A01BBA","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKDfO7wKibzpw4YsoqLRCHUKxX4rYRUh7m7RCdOwzWVaN9QLlhcU5ho3w2Qcpib1O69YPj65ib07xQBQ/132","comment_is_top":false,"comment_ctime":1585732907,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585732907","product_id":100023901,"comment_content":"&#47;&#47; 正确的while中断<br>while (!Thread.currentThread().isInterrupted()) {<br>    &#47;&#47; TODO do something......<br>}","like_count":0},{"had_liked":false,"id":201155,"user_name":"Henry","can_delete":false,"product_type":"c1","uid":1929375,"ip_address":"","ucode":"7C554C97935443","user_header":"https://static001.geekbang.org/account/avatar/00/1d/70/9f/741cd6a4.jpg","comment_is_top":false,"comment_ctime":1585724251,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585724251","product_id":100023901,"comment_content":"<br>Thread th = Thread.currentThread();<br>while(true) {<br>  &#47;&#47; 省略业务代码无数<br>  try {<br>    Thread.sleep(100);<br>  }catch (InterruptedException e){<br>    e.printStackTrace();<br>    break;  &#47;&#47;中断后直接在异常捕获块中退出<br>  }<br>}<br>改了下代码，中断后直接在异常捕获块中退出，抛出InterruptedException会清除中断标志导致永远不会退出循环，不知道理解地对不对。","like_count":0},{"had_liked":false,"id":194656,"user_name":"不学不行啊","can_delete":false,"product_type":"c1","uid":1335474,"ip_address":"","ucode":"69368165141C2D","user_header":"https://static001.geekbang.org/account/avatar/00/14/60/b2/ccebcb71.jpg","comment_is_top":false,"comment_ctime":1585095360,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585095360","product_id":100023901,"comment_content":"理解 Java 线程的各种状态以及生命周期对于诊断多线程 Bug 非常有帮助，多线程程序很难调试，出了 Bug 基本上都是靠日志，靠线程 dump 来跟踪问题，分析线程 dump 的一个基本功就是分析线程状态，大部分的死锁、饥饿、活锁问题都需要跟踪分析线程的状态","like_count":0},{"had_liked":false,"id":191504,"user_name":"zhangchao","can_delete":false,"product_type":"c1","uid":1508339,"ip_address":"","ucode":"E665D153A85DE0","user_header":"https://static001.geekbang.org/account/avatar/00/17/03/f3/0bd094ad.jpg","comment_is_top":false,"comment_ctime":1584778092,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584778092","product_id":100023901,"comment_content":"mark","like_count":0},{"had_liked":false,"id":184479,"user_name":"Airsaid","can_delete":false,"product_type":"c1","uid":1115302,"ip_address":"","ucode":"5B90BC0044F376","user_header":"https://static001.geekbang.org/account/avatar/00/11/04/a6/18c4f73c.jpg","comment_is_top":false,"comment_ctime":1583325292,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583325292","product_id":100023901,"comment_content":"「RUNNABLE 与 BLOCKED 的状态转换<br><br>只有一种场景会触发这种转换，就是线程等待 synchronized 的隐式锁。」<br><br>那么显示锁 Lock，就是通过 LockSupport.park() 从 RUNNABLE 转换到 WAITING 状态吧？那为什么 1.5 新增的显示锁没有放到 BLOCKED 中而是放在了 WAITING 中呢？是因为历史遗留问题还有由于一些其他的原因故意设计？","like_count":0},{"had_liked":false,"id":179890,"user_name":"Geek_bb89c3","can_delete":false,"product_type":"c1","uid":1331828,"ip_address":"","ucode":"0F97B5B0F2DDD6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/IZKGetBZDuMEa2VwwtesTELvLORIyV749ItgfAqNPv30n4zEv71wuGNr1aNVIVltG0icvH53DHDuqPuzNpiauWAg/132","comment_is_top":false,"comment_ctime":1582118561,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582118561","product_id":100023901,"comment_content":"在java中的各种状态，主要是<br>new,<br>runnable,当Thread线程调用 <br>waiting,object.wait(),<br>time_waiting:object.wait(ms):join(ms),Thread.sleep(ms),LockSupport.park().LockSupport.park(ms),Thread.join(ms);<br>blocked:synchronized();<br>terminal:正常执行完成。interupt","like_count":0},{"had_liked":false,"id":169360,"user_name":"ysl","can_delete":false,"product_type":"c1","uid":1501496,"ip_address":"","ucode":"06398A1F9149EB","user_header":"","comment_is_top":false,"comment_ctime":1578322406,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578322406","product_id":100023901,"comment_content":"Java 语言里则把可运行状态和运行状态合并了，这两个状态在操作系统调度层面有用，而 JVM 层面不关心这两个状态，因为 JVM 把线程调度交给操作系统处理了。<br><br>老师好，这句话怎么理解","like_count":0},{"had_liked":false,"id":169114,"user_name":"Wh1","can_delete":false,"product_type":"c1","uid":1282715,"ip_address":"","ucode":"6D28506B99A285","user_header":"https://static001.geekbang.org/account/avatar/00/13/92/9b/65f98192.jpg","comment_is_top":false,"comment_ctime":1578276581,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578276581","product_id":100023901,"comment_content":"“运行状态的线程如果调用一个阻塞的 API（例如以阻塞方式读文件）或者等待某个事件（例如条件变量），那么线程的状态就会转换到休眠状态，同时释放 CPU 使用权，休眠状态的线程永远没有机会获得 CPU 使用权。”<br>这里的“等待某个事件，例如条件变量”与“自旋锁中的结束自旋的条件变量”是同一个概念吗？，如果是的话，那么自旋锁不会让当前线程进入阻塞而是不断消耗CPU等待获取锁就与上述结论矛盾了。如果不是的话，请问这里的条件变量的大致场景是什么。","like_count":0},{"had_liked":false,"id":169106,"user_name":"Wh1","can_delete":false,"product_type":"c1","uid":1282715,"ip_address":"","ucode":"6D28506B99A285","user_header":"https://static001.geekbang.org/account/avatar/00/13/92/9b/65f98192.jpg","comment_is_top":false,"comment_ctime":1578274933,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578274933","product_id":100023901,"comment_content":"操作系统休眠的阻塞并非Java线程状态的阻塞！！！真的是一句话点醒了我半年多的困惑！！！","like_count":0},{"had_liked":false,"id":151021,"user_name":"Geek_ab2b44","can_delete":false,"product_type":"c1","uid":1358225,"ip_address":"","ucode":"17CE6624374E3F","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJnfEgoyUEPw8dvMVz42K1nt1YIoOt5dIH8onNE1db4N4ViaOFjv8uPxkguCJ414IyYILqpkeRAzfA/132","comment_is_top":false,"comment_ctime":1573643953,"is_pvip":false,"replies":[{"id":"58160","content":"看35讲吧","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1573654144,"ip_address":"","comment_id":151021,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573643953","product_id":100023901,"comment_content":"老师，如何让运行中的线程退出，我试了一下，线程池中线程运行时，都关不了，现在遇到个项目，难住我了","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474340,"discussion_content":"看35讲吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573654144,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146355,"user_name":"Lee","can_delete":false,"product_type":"c1","uid":1564179,"ip_address":"","ucode":"E36B56BCC3B0D0","user_header":"https://static001.geekbang.org/account/avatar/00/17/de/13/af1324a0.jpg","comment_is_top":false,"comment_ctime":1572504641,"is_pvip":false,"replies":[{"id":"56586","content":"可见性只能靠hb规则来推算，其他方式都不靠谱","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1572570914,"ip_address":"","comment_id":146355,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572504641","product_id":100023901,"comment_content":"老师，想问一下线程的状态发生改变，读取共享变量时是否会刷新缓存。下面的代码中，主线程修改isSleep为false，如果将sleep方法注释掉，子线程输出结果就是死循环，说明子线程读不到共享变量的最新值。如果调用sleep方法，输出结果就是false。<br>public  boolean  isSleep=true;<br><br>    private class readerThread extends Thread{<br>        @Override<br>        public void run(){<br>            while(isSleep){<br>                try {<br>                    this.sleep(1000);<br>                } catch (InterruptedException e) {<br>                    e.printStackTrace();<br>                }<br><br>            }<br>            System.out.println(isSleep);<br>        }<br>    }","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472815,"discussion_content":"可见性只能靠hb规则来推算，其他方式都不靠谱","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572570914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137765,"user_name":"远东通信-应用软件","can_delete":false,"product_type":"c1","uid":1351651,"ip_address":"","ucode":"3A1796000AC089","user_header":"","comment_is_top":false,"comment_ctime":1569840028,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569840028","product_id":100023901,"comment_content":"思考题中为什么抛出的异常InterruptedException被catch以后线程的中断标识位会被清除？","like_count":0},{"had_liked":false,"id":134609,"user_name":"IT橘子","can_delete":false,"product_type":"c1","uid":1066932,"ip_address":"","ucode":"1DBEE96BAF8B0B","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/b4/e8b3f53f.jpg","comment_is_top":false,"comment_ctime":1568878045,"is_pvip":false,"replies":[{"id":"51643","content":"线程调用阻塞式API指的是以阻塞方式调用读文件，socket这些操作系统的API","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1568891468,"ip_address":"","comment_id":134609,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568878045","product_id":100023901,"comment_content":"老师，您在讲“RUNNABLE与BLOCKED的状态转换”这一小节时说，“线程调用阻塞式API时，是否会转换到BLOCKED状态呢？在操作系统层面，线程是会转换到休眠状态的，但是在JVM层面，Java线程的状态不会发生变化，也就是说Java线程的状态会依然保持RUNNABLE状态...所以都归入了RUNNABLE状态”。对于jstack命令获取到的线程状态，应该是操作系统层面的吧？因为它确实可以显示BLOCKED。示例如下：<br>jstack 31634<br>...<br><br>&quot;Thread-0&quot; #12 prio=5 os_prio=31 cpu=1.32ms elapsed=34.24s tid=0x00007fb08601c800 nid=0x5d03 waiting for monitor entry  [0x000070000bc7e000]<br>   java.lang.Thread.State: BLOCKED (on object monitor)<br> at DeadLock.foo(DeadLock.java:18)<br> - waiting to lock &lt;0x000000061ff904c0&gt; (a java.lang.Object)<br> - locked &lt;0x000000061ff904b0&gt; (a java.lang.Object)<br> at DeadLock$$Lambda$1&#47;0x0000000800060840.run(Unknown Source)<br> at java.lang.Thread.run(java.base@11&#47;Thread.java:834)<br><br>&quot;Thread-1&quot; #13 prio=5 os_prio=31 cpu=1.43ms elapsed=34.24s tid=0x00007fb08601f800 nid=0x5f03 waiting for monitor entry  [0x000070000bd81000]<br>   java.lang.Thread.State: BLOCKED (on object monitor)<br> at DeadLock.bar(DeadLock.java:33)<br> - waiting to lock &lt;0x000000061ff904b0&gt; (a java.lang.Object)<br> - locked &lt;0x000000061ff904c0&gt; (a java.lang.Object)<br> at DeadLock$$Lambda$2&#47;0x0000000800063040.run(Unknown Source)<br> at java.lang.Thread.run(java.base@11&#47;Thread.java:834)<br><br>...<br>","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467827,"discussion_content":"线程调用阻塞式API指的是以阻塞方式调用读文件，socket这些操作系统的API","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568891468,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132937,"user_name":"Geek_4002b1","can_delete":false,"product_type":"c1","uid":1605775,"ip_address":"","ucode":"E574B64976EADB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Y4p5ibn3E4Riar5TTpNLZDLoicSbQn64vheYpzqN82ysBUFibQDZsjolzHrPZx4E8OO76LTly5nGiamY4qHfic2jVGibQ/132","comment_is_top":false,"comment_ctime":1568278994,"is_pvip":false,"replies":[{"id":"51422","content":"建议看一下jsr133，java并发编程的艺术这本书里也有介绍，很复杂","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1568766769,"ip_address":"","comment_id":132937,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568278994","product_id":100023901,"comment_content":"我有个疑问<br>如果普通变量a     happens-before    volatile变量b<br>变量b  happens-before  另一个线程的 b==true<br>那么普通变量a   happens-before  另一个线程<br>这其中的实现原理是什么?  即使有内存屏障, 也仅仅是对volatile域的缓存行的刷新到内存把, 请老师指导","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467184,"discussion_content":"建议看一下jsr133，java并发编程的艺术这本书里也有介绍，很复杂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568766769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130630,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1567497408,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567497408","product_id":100023901,"comment_content":"不正确，sleep操作抛出异常之后就会重置中断标志。此时捕获异常，就应该退出；如果不退出，就应该调用thread.interrupt（）重新设置中断标志为true","like_count":0},{"had_liked":false,"id":107649,"user_name":"冬风向左吹","can_delete":false,"product_type":"c1","uid":1066928,"ip_address":"","ucode":"376C45C5134F93","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/b0/a9b77a1e.jpg","comment_is_top":false,"comment_ctime":1561592842,"is_pvip":false,"replies":[{"id":"38929","content":"不是等同的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1561595756,"ip_address":"","comment_id":107649,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561592842","product_id":100023901,"comment_content":"&quot;因为在 JVM 看来，等待 CPU 使用权（操作系统层面此时处于可执行状态）与等待 I&#47;O（操作系统层面此时处于休眠状态）没有区别，都是在等待某个资源，所以都归入了 RUNNABLE&quot;<br><br>这句话无法理解，java线程在执行IO操作时，jvm认为线程是runnable状态，而操作系统已经把线程置为休眠状态了，是这样吗？这样的话，Java的可运行状态和操作系统的可运行状态就不是等同的是吗","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455604,"discussion_content":"不是等同的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561595756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103689,"user_name":"Alvan","can_delete":false,"product_type":"c1","uid":1002468,"ip_address":"","ucode":"D6529DC67898BF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4b/e4/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1560490920,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1560490920","product_id":100023901,"comment_content":"https:&#47;&#47;stackoverflow.com&#47;questions&#47;28378592&#47;java-thread-state-transition-waiting-to-blocked-or-runnable","like_count":0},{"had_liked":false,"id":101482,"user_name":"豪哥笑了","can_delete":false,"product_type":"c1","uid":1445782,"ip_address":"","ucode":"617D3DEFE7413C","user_header":"https://static001.geekbang.org/account/avatar/00/16/0f/96/be53e80f.jpg","comment_is_top":false,"comment_ctime":1559818687,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559818687","product_id":100023901,"comment_content":"楼主我只会新生、就绪、运行、阻塞、死亡","like_count":0},{"had_liked":false,"id":93411,"user_name":"Niuniu","can_delete":false,"product_type":"c1","uid":1103084,"ip_address":"","ucode":"0F4C2CE8C076A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/ec/804c3900.jpg","comment_is_top":false,"comment_ctime":1557465674,"is_pvip":false,"replies":[{"id":"33504","content":"没创建线程，而用的是主线程？","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1557643632,"ip_address":"","comment_id":93411,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557465674","product_id":100023901,"comment_content":"老师求助，为什么在catch里面加了interrupt还是死循环？<br> Thread th = Thread.currentThread();<br>        while(true) {<br>            if(th.isInterrupted()) {<br>                break;<br>            }<br>            &#47;&#47; 省略业务代码无数<br>            try {<br>                Thread.sleep(100);<br>            }catch (InterruptedException e){<br>                Thread.currentThread().interrupt();<br>                e.printStackTrace();<br>            }<br>        }<br>        th.start();<br>        try {<br>            Thread.sleep(1000);<br>        } catch (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br>        Thread.currentThread().interrupt();","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449622,"discussion_content":"没创建线程，而用的是主线程？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557643632,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93391,"user_name":"南北少卿","can_delete":false,"product_type":"c1","uid":1018958,"ip_address":"","ucode":"DFCC59F2BBD8CE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/4e/b81969fa.jpg","comment_is_top":false,"comment_ctime":1557462377,"is_pvip":false,"replies":[{"id":"33505","content":"会","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1557643673,"ip_address":"","comment_id":93391,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557462377","product_id":100023901,"comment_content":"当线程 A 处于 WAITING、TIMED_WAITING状态时，如果其他线程调用线程A的interrupt（）方法，会使线程A返回到RUNNABLE状态。我的问题时为什么调用interrupt（）就能使得线程A从WAITING返回到RUNNABLE状态呢？调用对象的A的interrupt（）方法会中断A的WAITING和TIMED_WAITING状态吗？<br>","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449610,"discussion_content":"会","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557643673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84033,"user_name":"Geek_53bccf","can_delete":false,"product_type":"c1","uid":1481179,"ip_address":"","ucode":"1818C97E5D1CCC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/UfqEYrR3cQXUhPEibnXD3kPSc8f0ibR4bdz6JnibjOBibfcxWrkVlz4iaCAAutOSotiaP2ROYX5esYfhAB3vj4avnYqQ/132","comment_is_top":false,"comment_ctime":1554771690,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1554771690","product_id":100023901,"comment_content":"每个线程都有自己的interrupt方法 为什么其他线程会调用到自己的interrupt方法呢 每个线程执行代码的路径是不一样的 ,那么除非是一个线程类创建了两个线程对象 ，这两个线程对象执行的代码路径是一样的 当其中一个线程调用了自己中断方法 这个线程下次再执行执行的时候 发现自己被自己上一次中断了 进而做相应中断的处理。老师我的理解是不是哪里不对啊 ","like_count":0},{"had_liked":false,"id":80238,"user_name":"WP","can_delete":false,"product_type":"c1","uid":1105956,"ip_address":"","ucode":"4A24C6CAA70220","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/24/4529f2a4.jpg","comment_is_top":false,"comment_ctime":1553643891,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553643891","product_id":100023901,"comment_content":"长知识","like_count":0},{"had_liked":false,"id":79527,"user_name":"ban","can_delete":false,"product_type":"c1","uid":1034204,"ip_address":"","ucode":"E523CE97E48266","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c7/dc/9408c8c2.jpg","comment_is_top":false,"comment_ctime":1553505462,"is_pvip":false,"replies":[{"id":"29014","content":"没有机会阻塞,主动检测也能检测到","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553519694,"ip_address":"","comment_id":79527,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553505462","product_id":100023901,"comment_content":"老师，请问，如果主动检测 interrup的情况，然后线程一直while（true）循环，虽然会判断th.isInterrupted()条件才退出，但是没有机会阻塞的情况，那是不是意味着代码根本接收不到interrup请求，而且会一直循环下去。求解，谢谢","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444528,"discussion_content":"没有机会阻塞,主动检测也能检测到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553519694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79518,"user_name":"ban","can_delete":false,"product_type":"c1","uid":1034204,"ip_address":"","ucode":"E523CE97E48266","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c7/dc/9408c8c2.jpg","comment_is_top":false,"comment_ctime":1553504130,"is_pvip":false,"replies":[{"id":"29015","content":"接收的到","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553519719,"ip_address":"","comment_id":79518,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553504130","product_id":100023901,"comment_content":"老师，如果主动检测 interrup的情况，然后线程一直while（true）循环，虽然会判断th.isInterrupted()条件才退出，但是没有机会阻塞的情况，那是不是意味着代码根本接收不到interrup请求，而且会一直循环下去。求解，谢谢","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444526,"discussion_content":"接收的到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553519719,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79509,"user_name":"ban","can_delete":false,"product_type":"c1","uid":1034204,"ip_address":"","ucode":"E523CE97E48266","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c7/dc/9408c8c2.jpg","comment_is_top":false,"comment_ctime":1553501417,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553501417","product_id":100023901,"comment_content":"我觉得还有另外一种改法，直接把try-catch放在while循环外面就不会再次走while循环。<br><br>Thread th = Thread.currentThread();<br>try {<br>while(true) {<br>  if(th.isInterrupted()) {<br>    break;<br>  }<br>  &#47;&#47; 省略业务代码无数<br> <br>\tThread.sleep(100);<br>\t  <br>   }<br>}catch (InterruptedException e)｛<br>    Thread.currentThread().interrupt();<br>    e.printStackTrace();<br>  }","like_count":0},{"had_liked":false,"id":79256,"user_name":"悟空","can_delete":false,"product_type":"c1","uid":1451125,"ip_address":"","ucode":"F9DFBA74B35B40","user_header":"https://static001.geekbang.org/account/avatar/00/16/24/75/808ac160.jpg","comment_is_top":false,"comment_ctime":1553418101,"is_pvip":false,"replies":[{"id":"28945","content":"状态重置是关键<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553474715,"ip_address":"","comment_id":79256,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553418101","product_id":100023901,"comment_content":"首先做了测试,InterruptedException 会被catch掉,while(true)没有被终止。<br><br>再分析原因:<br>Thread.sleep(xx) 方法的注释说明:如果调用sleep方法,线程的中断状态会被重置<br><br>根据实际效果来看,object.wait抛出异常的时间,早于Thread.isInterrupted()变量的判断。<br><br>那是否还会有另外一种情况,isInterrupted()早于Sleep的exception的调用?","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444419,"discussion_content":"状态重置是关键\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553474715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78885,"user_name":"math","can_delete":false,"product_type":"c1","uid":1432973,"ip_address":"","ucode":"7EE57777F86058","user_header":"https://static001.geekbang.org/account/avatar/00/15/dd/8d/0396fabe.jpg","comment_is_top":false,"comment_ctime":1553268561,"is_pvip":false,"replies":[{"id":"28857","content":"因为th不响应中断，而且很快久结束了","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553388751,"ip_address":"","comment_id":78885,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1553268561","product_id":100023901,"comment_content":"这个王老师，用你的例子写出来的测试后，是退出循环的，假如有A,B两个线程还有一个main主线程，为什么我在B线程中去终端A线程就始终终端不了，下面是例子：<br> Thread th = new Thread(()-&gt;{<br>            System.out.println(&quot;我在执行&quot;);<br><br><br>        });<br>        th.start();<br>        Thread t2 = new Thread(()-&gt;{<br>            System.out.println(&quot;我要中的th&quot;);<br>            th.interrupt();<br>        });<br>        t2.start();<br>        &#47;&#47;th.interrupt();<br>        try {<br>            t2.join();<br>        } catch (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br>        while(true) {<br>            if(th.isInterrupted()) {<br>                break;<br>            }<br>            System.out.println(&quot;th还或者啊&quot;);<br>            try {<br>                Thread.sleep(1000);<br>            } catch (InterruptedException e) {<br>                Thread.currentThread().interrupt();<br>                e.printStackTrace();<br>            }<br>        }<br><br>结果一直在输出：th还或者啊。  th没有中断，这是为啥","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444272,"discussion_content":"因为th不响应中断，而且很快久结束了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553388751,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1184678,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJDgV2qia6eAL7Fb4egX3odViclRRwOlkfCBrjhU9lLeib90KGkIDjdddSibNVs47N90L36Brgnr6ppiag/132","nickname":"ddww","note":"","ucode":"2871112FC9B3F7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555320,"discussion_content":"th一下就结束了，中断毛呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646851058,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78520,"user_name":"Corner","can_delete":false,"product_type":"c1","uid":1446316,"ip_address":"","ucode":"7862D593172536","user_header":"https://static001.geekbang.org/account/avatar/00/16/11/ac/9cc5e692.jpg","comment_is_top":false,"comment_ctime":1553165692,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553165692","product_id":100023901,"comment_content":"老师是不是忘记写中断标识位的内容了啊？思考题会用到的啊。","like_count":0},{"had_liked":false,"id":78500,"user_name":"小小草","can_delete":false,"product_type":"c1","uid":1445173,"ip_address":"","ucode":"7CA28A54F1EC3E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLzhOH0l6xRZJ7lSHTVrN1a6jANXJeeCRy8soS9oZgJibJG9UCibARb0V4iaUWT9gHn3GL0mKyE5W2uQ/132","comment_is_top":false,"comment_ctime":1553160910,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553160910","product_id":100023901,"comment_content":"思考题中，if条件中用isInterrupted() 判断线程是否中断，而思考题中并没有调用th.interrupt()，所以并不会抛异常，sleep()过后，会继续执行<br>","like_count":0},{"had_liked":false,"id":78451,"user_name":"曾轼麟","can_delete":false,"product_type":"c1","uid":1451391,"ip_address":"","ucode":"D418371AC11270","user_header":"https://static001.geekbang.org/account/avatar/00/16/25/7f/473d5a77.jpg","comment_is_top":false,"comment_ctime":1553151645,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553151645","product_id":100023901,"comment_content":"jdk8里面的stop方法是不是改进了？如果发现线程不是刚刚创建的将会被resume，去释放锁，不过貌似还是不推荐使用stop方法<br>","like_count":0},{"had_liked":false,"id":78159,"user_name":"程序员人生","can_delete":false,"product_type":"c1","uid":1113668,"ip_address":"","ucode":"C5C5073D89AAA2","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/44/3e3040ac.jpg","comment_is_top":false,"comment_ctime":1553082398,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553082398","product_id":100023901,"comment_content":"文末的工具我要尝试一下。想想当时查并发问题查得我现在都想哭","like_count":0},{"had_liked":false,"id":78014,"user_name":"Docker","can_delete":false,"product_type":"c1","uid":1281995,"ip_address":"","ucode":"5789C511CB85B7","user_header":"https://static001.geekbang.org/account/avatar/00/13/8f/cb/4c7ed0d9.jpg","comment_is_top":false,"comment_ctime":1553054362,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553054362","product_id":100023901,"comment_content":"RUNNABLE 与 BLOCKED 的状态转换<br><br>只有一种场景会触发这种转换，就是线程等待 synchronized 的隐式锁。<br><br>这个可以给个测试demo代码吗？ 我测试怎么都是runnable<br>","like_count":0},{"had_liked":false,"id":78000,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1553051805,"is_pvip":false,"replies":[{"id":"28487","content":"主要是看官方文档<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553083129,"ip_address":"","comment_id":78000,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553051805","product_id":100023901,"comment_content":"其实我是手动测了一下，并没有看底下的评论<br><br>老师确实把jvm的线程 和 os的线程状态，给了我们一个提醒和认识<br><br>谢谢老师的讲解~ 有木有关于os thread 和 jvm thread 的论文或者文章链接呀， 第二讲里发的真的很赞！","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443931,"discussion_content":"主要是看官方文档\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553083129,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77995,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1553051295,"is_pvip":false,"replies":[{"id":"28688","content":"对，但是忽略了点东西，答疑篇会介绍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553269064,"ip_address":"","comment_id":77995,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553051295","product_id":100023901,"comment_content":"在外面调用th.interrupt()方法，会把th线程从sleep(1000)中立即唤醒而继续在while(true)中执行 业务代码，因此th线程不会中断，只会抛出Exception –– sleep interrupt 而继续执行业务代码。 <br><br>不知道说的对不对，想让老师看一下我说的。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443928,"discussion_content":"对，但是忽略了点东西，答疑篇会介绍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553269064,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77944,"user_name":"包子","can_delete":false,"product_type":"c1","uid":1089345,"ip_address":"","ucode":"6CC4EBB8CD3924","user_header":"https://static001.geekbang.org/account/avatar/00/10/9f/41/82306dfe.jpg","comment_is_top":false,"comment_ctime":1553044526,"is_pvip":false,"replies":[{"id":"28569","content":"我觉得只是为了记录一下休眠原因<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553170462,"ip_address":"","comment_id":77944,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553044526","product_id":100023901,"comment_content":"老师，jvm的三种休眠状态能细致说一下为什么要这样区分吗。在各个状态下对资源的让步是什么策略","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443907,"discussion_content":"我觉得只是为了记录一下休眠原因\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553170462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77818,"user_name":"拒绝","can_delete":false,"product_type":"c1","uid":1335155,"ip_address":"","ucode":"CB0264C4D3FE17","user_header":"https://static001.geekbang.org/account/avatar/00/14/5f/73/bb3dc468.jpg","comment_is_top":false,"comment_ctime":1553004104,"is_pvip":false,"replies":[{"id":"28436","content":"异常是果不是因，你让它抛它就抛<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553040529,"ip_address":"","comment_id":77818,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1553004104","product_id":100023901,"comment_content":"刚接触并发领域，请教一下，为什么当程序运行一段时候后，才抛出InterruptedException?","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443864,"discussion_content":"异常是果不是因，你让它抛它就抛\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553040529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1323652,"avatar":"","nickname":"sibyl","note":"","ucode":"0D142011860D69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289443,"discussion_content":"看看抛异常的方法都是sleep  wait  join，这些都是waiting线程方法，而线程在waiting时我们是无能为力的，可是为了能结束线程，就必须让线程从这些方法中返回，因此java让这些方法监听了中断标记，如果其他线程中断当前线程，那么这些方法就抛出异常来提示当前线程被中断了，换句话说也可以不抛出异常，比如可以返回-1，反正能表示被中断即可","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594101530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77796,"user_name":"悟","can_delete":false,"product_type":"c1","uid":1442835,"ip_address":"","ucode":"9A560A63DF71ED","user_header":"https://static001.geekbang.org/account/avatar/00/16/04/13/aac9b508.jpg","comment_is_top":false,"comment_ctime":1552999810,"is_pvip":false,"replies":[{"id":"28439","content":"释放不了，当然也会破坏程序逻辑<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553041284,"ip_address":"","comment_id":77796,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552999810","product_id":100023901,"comment_content":"应该是会释放该线程所有的锁吧，因为stop是强行停止线程，所以会破坏程序的执行逻辑。不知道是不是这样？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443856,"discussion_content":"释放不了，当然也会破坏程序逻辑\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553041284,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77633,"user_name":"木刻","can_delete":false,"product_type":"c1","uid":1157430,"ip_address":"","ucode":"0A3226FEE3983B","user_header":"https://static001.geekbang.org/account/avatar/00/11/a9/36/972f7abf.jpg","comment_is_top":false,"comment_ctime":1552975344,"is_pvip":false,"replies":[{"id":"28382","content":"这个太难了，理论值解决不了这个问题<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552997287,"ip_address":"","comment_id":77633,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552975344","product_id":100023901,"comment_content":"老师好，如果我一台服务器上跑好几个程序，每个程序都有自己的线程池，那每个程序中的线程池数量都配置自己本程序根据CPU核数和IO等算出的理论值吗","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443803,"discussion_content":"这个太难了，理论值解决不了这个问题\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552997287,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77582,"user_name":"magict4","can_delete":false,"product_type":"c1","uid":1043789,"ip_address":"","ucode":"CB6F063D881AAC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/4d/1d1a1a00.jpg","comment_is_top":false,"comment_ctime":1552965361,"is_pvip":false,"replies":[{"id":"28336","content":"估计是历史原因吧，1.5之前没有并发包。lock后是waiting<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552969803,"ip_address":"","comment_id":77582,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552965361","product_id":100023901,"comment_content":"老师能不能讲讲为什么 Java 要有 blocked 跟 waiting 两种状态？结合上一讲的管程模型，在“入口等待队列”的线程应该处于 blocked 状态，在“条件变量等待队列”的线程应该处于 waiting 状态。不知道线程执行 Lock.lock() 并被阻塞的时候处于什么状态？如果是 waiting 状态，是否意味着它在“条件变量等待队列”中呢？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443785,"discussion_content":"估计是历史原因吧，1.5之前没有并发包。lock后是waiting\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552969803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77489,"user_name":"轻歌赋","can_delete":false,"product_type":"c1","uid":1251574,"ip_address":"","ucode":"22F62446208805","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/f6/2ff7bc7a.jpg","comment_is_top":false,"comment_ctime":1552956234,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552956234","product_id":100023901,"comment_content":"不能。try catch还在while内部，捕获了也出不去","like_count":0},{"had_liked":false,"id":77444,"user_name":"松花皮蛋me","can_delete":false,"product_type":"c1","uid":1000054,"ip_address":"","ucode":"B0846CEEF6B0D1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/76/256bbd43.jpg","comment_is_top":false,"comment_ctime":1552926052,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552926052","product_id":100023901,"comment_content":"在一个线程对象上调用interrupt()方法，真正有影响的是wait，join，sleep方法，当然这三个方法包括它们的重载方法。课后作业题中的while会退出","like_count":0}]}