{"id":740772,"title":"第 9 章 简单 Diff 算法","content":"<p>从本章开始，我们将介绍渲染器的核心 Diff 算法。简单来说，当新旧 <code>vnode</code> 的子节点都是一组节点时，为了以最小的性能开销完成更新操作，需要比较两组子节点，用于比较的算法就叫作 Diff 算法。我们知道，操作 DOM 的性能开销通常比较大，而渲染器的核心 Diff 算法就是为了解决这个问题而诞生的。</p>\n<h2 id=\"nav_point_89\">9.1　减少 DOM 操作的性能开销</h2>\n<p>核心 Diff 只关心新旧虚拟节点都存在一组子节点的情况。在上一章中，我们针对两组子节点的更新，采用了一种简单直接的手段，即卸载全部旧子节点，再挂载全部新子节点。这么做的确可以完成更新，但由于没有复用任何 DOM 元素，所以会产生极大的性能开销。</p>\n<p>以下面的新旧虚拟节点为例：</p>\n<pre class=\"code-rows\"><code> // 旧 vnode\n const oldVNode = {\n   type: 'div',\n   children: [\n     { type: 'p', children: '1' },\n     { type: 'p', children: '2' },\n     { type: 'p', children: '3' }\n   ]\n }\n<p>// 新 vnode<br />\nconst newVNode = {<br />\ntype: ‘div’,<br />\nchildren: [<br />\n{ type: ‘p’, children: ‘4’ },<br />\n{ type: ‘p’, children: ‘5’ },<br />\n{ type: ‘p’, children: ‘6’ }<br />\n]<br />\n}<br />\n</code></pre></p>\n<p>按照之前的做法，当更新子节点时，我们需要执行 6 次 DOM 操作：</p>\n<ul>\n<li>卸载所有旧子节点，需要 3 次 DOM 删除操作；</li>\n<li>挂载所有新子节点，需要 3 次 DOM 添加操作。</li>\n</ul>\n<p>但是，通过观察上面新旧 <code>vnode</code> 的子节点，可以发现：</p>\n<ul>\n<li>更新前后的所有子节点都是 <code>p</code> 标签，即标签元素不变；</li>\n<li>只有 <code>p</code> 标签的子节点（文本节点）会发生变化。</li>\n</ul>\n<p>例如，<code>oldVNode</code> 的第一个子节点是一个 <code>p</code> 标签，且该 <code>p</code> 标签的子节点类型是文本节点，内容是 <code>'1'</code>。而 <code>newVNode</code>  的第一个子节点也是一个 <code>p</code> 标签，它的子节点的类型也是文本节点，内容是 <code>'4'</code>。可以发现，更新前后改变的只有 <code>p</code> 标签文本节点的内容。所以，最理想的更新方式是，直接更新这个 <code>p</code> 标签的文本节点的内容。这样只需要一次 DOM 操作，即可完成一个 <code>p</code> 标签更新。新旧虚拟节点都有 3 个 <code>p</code> 标签作为子节点，所以一共只需要 3 次 DOM 操作就可以完成全部节点的更新。相比原来需要执行 6 次 DOM 操作才能完成更新的方式，其性能提升了一倍。</p><!-- [[[read_end]]] -->\n<p>按照这个思路，我们可以重新实现两组子节点的更新逻辑，如下面 <code>patchChildren</code> 函数的代码所示：</p>\n<pre class=\"code-rows\"><code> function patchChildren(n1, n2, container) {\n   if (typeof n2.children === 'string') {\n     // 省略部分代码\n   } else if (Array.isArray(n2.children)) {\n     // 重新实现两组子节点的更新方式\n     // 新旧 children\n     const oldChildren = n1.children\n     const newChildren = n2.children\n     // 遍历旧的 children\n     for (let i = 0; i &lt; oldChildren.length; i++) {\n       // 调用 patch 函数逐个更新子节点\n       patch(oldChildren[i], newChildren[i])\n     }\n   } else {\n     // 省略部分代码\n   }\n }\n</code></pre>\n<p>在这段代码中，<code>oldChildren</code> 和 <code>newChildren</code> 分别是旧的一组子节点和新的一组子节点。我们遍历前者，并将两者中对应位置的节点分别传递给 <code>patch</code> 函数进行更新。<code>patch</code> 函数在执行更新时，发现新旧子节点只有文本内容不同，因此只会更新其文本节点的内容。这样，我们就成功地将 6 次 DOM 操作减少为 3 次。图 9-1 是整个更新过程的示意图，其中<strong>菱形</strong>代表新子节点，<strong>矩形</strong>代表旧子节点，<strong>圆形</strong>代表真实 DOM 节点。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00528.jpeg\" alt=\"\" width=\"75%\" style=\"width: 75%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-1　仅更新文本子节点</strong></p>\n<p>这种做法虽然能够减少 DOM 操作次数，但问题也很明显。在上面的代码中，我们通过遍历旧的一组子节点，并假设新的一组子节点的数量与之相同，只有在这种情况下，这段代码才能正确地工作。但是，新旧两组子节点的数量未必相同。当新的一组子节点的数量少于旧的一组子节点的数量时，意味着有些节点在更新后应该被卸载，如图 9-2 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00529.jpeg\" alt=\"\" width=\"75%\" style=\"width: 75%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-2　卸载已经不存在的节点</strong></p>\n<p>在图 9-2 中，旧的一组子节点中一共有 4 个 <code>p</code> 标签，而新的一组子节点中只有 3 个 <code>p</code> 标签。这说明，在更新过程中，需要将不存在的 <code>p</code> 标签卸载。类似地，新的一组子节点的数量也可能比旧的一组子节点的数量多，如图 9-3 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00530.jpeg\" alt=\"\" width=\"75%\" style=\"width: 75%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-3　挂载新的节点</strong></p>\n<p>在图 9-3 中，新的一组子节点比旧的一组子节点多了一个 <code>p</code> 标签。在这种情况下，我们应该挂载新增节点。</p>\n<p>通过上面的分析我们意识到，在进行新旧两组子节点的更新时，不应该总是遍历旧的一组子节点或遍历新的一组子节点，而是应该遍历其中长度较短的那一组。这样，我们才能够尽可能多地调用 <code>patch</code> 函数进行更新。接着，再对比新旧两组子节点的长度，如果新的一组子节点更长，则说明有新子节点需要挂载，否则说明有旧子节点需要卸载。最终实现如下：</p>\n<pre class=\"code-rows\"><code> function patchChildren(n1, n2, container) {\n   if (typeof n2.children === 'string') {\n     // 省略部分代码\n   } else if (Array.isArray(n2.children)) {\n     const oldChildren = n1.children\n     const newChildren = n2.children\n     // 旧的一组子节点的长度\n     const oldLen = oldChildren.length\n     // 新的一组子节点的长度\n     const newLen = newChildren.length\n     // 两组子节点的公共长度，即两者中较短的那一组子节点的长度\n     const commonLength = Math.min(oldLen, newLen)\n     // 遍历 commonLength 次\n     for (let i = 0; i &lt; commonLength; i++) {\n       patch(oldChildren[i], newChildren[i], container)\n     }\n     // 如果 newLen &gt; oldLen，说明有新子节点需要挂载\n     if (newLen &gt; oldLen) {\n       for (let i = commonLength; i &lt; newLen; i++) {\n         patch(null, newChildren[i], container)\n       }\n     } else if (oldLen &gt; newLen) {\n       // 如果 oldLen &gt; newLen，说明有旧子节点需要卸载\n       for (let i = commonLength; i &lt; oldLen; i++) {\n         unmount(oldChildren[i])\n       }\n     }\n   } else {\n     // 省略部分代码\n   }\n }\n</code></pre>\n<p>这样，无论新旧两组子节点的数量关系如何，渲染器都能够正确地挂载或卸载它们。</p>\n<h2 id=\"nav_point_90\">9.2　DOM 复用与 <code>key</code> 的作用</h2>\n<p>在上一节中，我们通过减少 DOM 操作的次数，提升了更新性能。但这种方式仍然存在可优化的空间。举个例子，假设新旧两组子节点的内容如下：</p>\n<pre class=\"code-rows\"><code> // oldChildren\n [\n   { type: 'p' },\n   { type: 'div' },\n   { type: 'span' }\n ]\n<p>// newChildren<br />\n[<br />\n{ type: ‘span’ },<br />\n{ type: ‘p’ },<br />\n{ type: ‘div’ }<br />\n]<br />\n</code></pre></p>\n<p>如果使用上一节介绍的算法来完成上述两组子节点的更新，则需要 6 次 DOM 操作。</p>\n<ul>\n<li>调用 <code>patch</code> 函数在旧子节点 <code>{ type: 'p' }</code> 与新子节点 <code>{ type: 'span' }</code> 之间打补丁，由于两者是不同的标签，所以 <code>patch</code> 函数会卸载 <code>{ type: 'p' }</code>，然后再挂载 <code>{ type: 'span' }</code>，这需要执行 2 次 DOM 操作。</li>\n<li>与第 1 步类似，卸载旧子节点 <code>{ type: 'div' }</code>，然后再挂载新子节点 <code>{ type: 'p' }</code>，这也需要执行 2 次 DOM 操作。</li>\n<li>与第 1 步类似，卸载旧子节点 <code>{ type: 'span' }</code>，然后再挂载新子节点 <code>{ type: 'div' }</code>，同样需要执行 2 次 DOM 操作。</li>\n</ul>\n<p>因此，一共进行 6 次 DOM 操作才能完成上述案例的更新。但是，观察新旧两组子节点，很容易发现，二者只是顺序不同。所以最优的处理方式是，通过 DOM 的移动来完成子节点的更新，这要比不断地执行子节点的卸载和挂载性能更好。但是，想要通过 DOM 的移动来完成更新，必须要保证一个前提：新旧两组子节点中的确存在可复用的节点。这个很好理解，如果新的子节点没有在旧的一组子节点中出现，就无法通过移动节点的方式完成更新。所以现在问题变成了：应该如何确定新的子节点是否出现在旧的一组子节点中呢？拿上面的例子来说，怎么确定新的一组子节点中第 1 个子节点 <code>{ type: 'span' }</code> 与旧的一组子节点中第 3 个子节点相同呢？一种解决方案是，通过 <code>vnode.type</code> 来判断，只要 <code>vnode.type</code> 的值相同，我们就认为两者是相同的节点。但这种方式并不可靠，思考如下例子：</p>\n<pre class=\"code-rows\"><code> // oldChildren\n [\n   { type: 'p', children: '1' },\n   { type: 'p', children: '2' },\n   { type: 'p', children: '3' }\n ]\n<p>// newChildren<br />\n[<br />\n{ type: ‘p’, children: ‘3’ },<br />\n{ type: ‘p’, children: ‘1’ },<br />\n{ type: ‘p’, children: ‘2’ }<br />\n]<br />\n</code></pre></p>\n<p>观察上面两组子节点，我们发现，这个案例可以通过移动 DOM 的方式来完成更新。但是所有节点的 <code>vnode.type</code> 属性值都相同，这导致我们无法确定新旧两组子节点中节点的对应关系，也就无法得知应该进行怎样的 DOM 移动才能完成更新。这时，我们就需要引入额外的 <code>key</code> 来作为 <code>vnode</code> 的标识，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> // oldChildren\n [\n   { type: 'p', children: '1', key: 1 },\n   { type: 'p', children: '2', key: 2 },\n   { type: 'p', children: '3', key: 3 }\n ]\n<p>// newChildren<br />\n[<br />\n{ type: ‘p’, children: ‘3’, key: 3 },<br />\n{ type: ‘p’, children: ‘1’, key: 1 },<br />\n{ type: ‘p’, children: ‘2’, key: 2 }<br />\n]<br />\n</code></pre></p>\n<p><code>key</code> 属性就像虚拟节点的“身份证”号，只要两个虚拟节点的 <code>type</code> 属性值和 <code>key</code> 属性值都相同，那么我们就认为它们是相同的，即可以进行 DOM 的复用。图 9-4 展示了有 <code>key</code> 和 无 <code>key</code> 时新旧两组子节点的映射情况。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00531.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-4　有 <code>key</code> 与无 <code>key</code></strong></p>\n<p>由图 9-4 可知，如果没有 <code>key</code>，我们无法知道新子节点与旧子节点间的映射关系，也就无法知道应该如何移动节点。有 <code>key</code> 的话情况则不同，我们根据子节点的 <code>key</code> 属性，能够明确知道新子节点在旧子节点中的位置，这样就可以进行相应的 DOM 移动操作了。</p>\n<p>有必要强调的一点是，DOM 可复用并不意味着不需要更新，如下面的两个虚拟节点所示：</p>\n<pre class=\"code-rows\"><code> const oldVNode = { type: 'p', key: 1, children: 'text 1' }\n const newVNode = { type: 'p', key: 1, children: 'text 2' }\n</code></pre>\n<p>这两个虚拟节点拥有相同的 <code>key</code> 值和 <code>vnode.type</code> 属性值。这意味着，在更新时可以复用 DOM 元素，即只需要通过移动操作来完成更新。但仍需要对这两个虚拟节点进行打补丁操作，因为新的虚拟节点（<code>newVNode</code>）的文本子节点的内容已经改变了（由 <code>'text 1'</code> 变成 <code>'text 2'</code>）。因此，在讨论如何移动 DOM 之前，我们需要先完成打补丁操作，如下面 <code>patchChildren</code> 函数的代码所示：</p>\n<pre class=\"code-rows\"><code> function patchChildren(n1, n2, container) {\n   if (typeof n2.children === 'string') {\n     // 省略部分代码\n   } else if (Array.isArray(n2.children)) {\n     const oldChildren = n1.children\n     const newChildren = n2.children\n<pre><code> // 遍历新的 children\n for (let i = 0; i &amp;lt; newChildren.length; i++) {\n   const newVNode = newChildren[i]\n   // 遍历旧的 children\n   for (let j = 0; j &amp;lt; oldChildren.length; j++) {\n     const oldVNode = oldChildren[j]\n     // 如果找到了具有相同 key 值的两个节点，说明可以复用，但仍然需要调用 patch 函数更新\n     if (newVNode.key === oldVNode.key) {\n       patch(oldVNode, newVNode, container)\n       break // 这里需要 break\n     }\n   }\n }\n</code></pre>\n<p>} else {<br />\n// 省略部分代码<br />\n}<br />\n}<br />\n</code></pre></p>\n<p>在上面这段代码中，我们重新实现了新旧两组子节点的更新逻辑。可以看到，我们使用了两层 <code>for</code> 循环，外层循环用于遍历新的一组子节点，内层循环则遍历旧的一组子节点。在内层循环中，我们逐个对比新旧子节点的 <code>key</code> 值，试图在旧的子节点中找到可复用的节点。一旦找到，则调用 <code>patch</code> 函数进行打补丁。经过这一步操作之后，我们能够保证所有可复用的节点本身都已经更新完毕了。以下面的新旧两组子节点为例：</p>\n<pre class=\"code-rows\"><code> const oldVNode = {\n   type: 'div',\n   children: [\n     { type: 'p', children: '1', key: 1 },\n     { type: 'p', children: '2', key: 2 },\n     { type: 'p', children: 'hello', key: 3 }\n   ]\n }\n<p>const newVNode = {<br />\ntype: ‘div’,<br />\nchildren: [<br />\n{ type: ‘p’, children: ‘world’, key: 3 },<br />\n{ type: ‘p’, children: ‘1’, key: 1 },<br />\n{ type: ‘p’, children: ‘2’, key: 2 }<br />\n]<br />\n}</p>\n<p>// 首次挂载<br />\nrenderer.render(oldVNode, document.querySelector(‘#app’))<br />\nsetTimeout(() =&gt; {<br />\n// 1 秒钟后更新<br />\nrenderer.render(newVNode, document.querySelector(‘#app’))<br />\n}, 1000);<br />\n</code></pre></p>\n<p>运行上面这段代码，1 秒钟后，<code>key</code> 值为 3 的子节点对应的真实 DOM 的文本内容会由字符串 <code>'hello'</code> 更新为字符串 <code>'world'</code>。下面我们详细分析上面这段代码在执行更新操作时具体发生了什么。</p>\n<ul>\n<li>第一步，取新的一组子节点中的第一个子节点，即 <code>key</code> 值为 3 的节点。尝试在旧的一组子节点中寻找具有相同 <code>key</code> 值的节点。我们发现，旧的子节点 <code>oldVNode[2]</code> 的 <code>key</code> 值为 3，于是调用 <code>patch</code> 函数进行打补丁。在这一步操作完成之后，渲染器会把 <code>key</code> 值为 3 的虚拟节点所对应的真实 DOM 的文本内容由字符串 <code>'hello'</code> 更新为字符串 <code>'world'</code>。</li>\n<li>第二步，取新的一组子节点中的第二个子节点，即 <code>key</code> 值为 1 的节点。尝试在旧的一组子节点中寻找具有相同 <code>key</code> 值的节点。我们发现，旧的子节点 <code>oldVNode[0]</code> 的 <code>key</code> 值为 1，于是调用 <code>patch</code> 函数进行打补丁。由于 <code>key</code> 值等于 1 的新旧子节点没有任何差异，所以什么都不会做。</li>\n<li>第三步，取新的一组子节点中的最后一个子节点，即 <code>key</code> 值为 2 的节点，最终结果与第二步相同。</li>\n</ul>\n<p>经过上述更新操作后，所有节点对应的真实 DOM 元素都更新完毕了。但真实 DOM 仍然保持旧的一组子节点的顺序，即 <code>key</code> 值为 3 的节点对应的真实 DOM 仍然是最后一个子节点。由于在新的一组子节点中，<code>key</code> 值为 3 的节点已经变为第一个子节点了，因此我们还需要通过移动节点来完成真实 DOM 顺序的更新。</p>\n<h2 id=\"nav_point_91\">9.3　找到需要移动的元素</h2>\n<p>现在，我们已经能够通过 <code>key</code> 值找到可复用的节点了。接下来需要思考的是，如何判断一个节点是否需要移动，以及如何移动。对于第一个问题，我们可以采用逆向思维的方式，先想一想在什么情况下节点不需要移动？答案很简单，当新旧两组子节点的节点顺序不变时，就不需要额外的移动操作，如图 9-5 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00532.jpeg\" alt=\"\" width=\"65%\" style=\"width: 65%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-5　节点顺序不变</strong></p>\n<p>在图 9-5 中，新旧两组子节点的顺序没有发生变化，图中也给出了旧的一组子节点中各个节点的索引：</p>\n<ul>\n<li><code>key</code> 值为 1 的节点在旧 <code>children</code> 数组中的索引为 <code>0</code>；</li>\n<li><code>key</code> 值为 2 的节点在旧 <code>children</code> 数组中的索引为 <code>1</code>；</li>\n<li><code>key</code> 值为 3 的节点在旧 <code>children</code> 数组中的索引为 <code>2</code>。</li>\n</ul>\n<p>接着，我们对新旧两组子节点采用上一节介绍的更新算法，看看当新旧两组子节点的顺序没有发生变化时，更新算法具有怎样的特点。</p>\n<ul>\n<li>第一步：取新的一组子节点中的第一个节点 <code>p-1</code>，它的 <code>key</code> 为 1。尝试在旧的一组子节点中找到具有相同 <code>key</code> 值的可复用节点，发现能够找到，并且该节点在旧的一组子节点中的索引为 <code>0</code>。</li>\n<li>第二步：取新的一组子节点中的第二个节点 <code>p-2</code>，它的 <code>key</code> 为 2。尝试在旧的一组子节点中找到具有相同 <code>key</code> 值的可复用节点，发现能够找到，并且该节点在旧的一组子节点中的索引为 <code>1</code>。</li>\n<li>第三步：取新的一组子节点中的第三个节点 <code>p-3</code>，它的 <code>key</code> 为 3。尝试在旧的一组子节点中找到具有相同 <code>key</code> 值的可复用节点，发现能够找到，并且该节点在旧的一组子节点中的索引为 <code>2</code>。</li>\n</ul>\n<p>在这个过程中，每一次寻找可复用的节点时，都会记录该可复用节点在旧的一组子节点中的位置索引。如果把这些位置索引值按照先后顺序排列，则可以得到一个序列：<code>0</code>、<code>1</code>、<code>2</code>。这是一个递增的序列，在这种情况下不需要移动任何节点。</p>\n<p>我们再来看看另外一个例子，如图 9-6 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00533.jpeg\" alt=\"\" width=\"65%\" style=\"width: 65%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-6　节点顺序变化</strong></p>\n<p>同样，我们根据图 9-6 中给出的例子再次执行更新算法，看看这一次会有什么不同。</p>\n<ul>\n<li>第一步：取新的一组子节点中的第一个节点 <code>p-3</code>，它的 <code>key</code> 为 3。尝试在旧的一组子节点中找到具有相同 <code>key</code> 值的可复用节点，发现能够找到，并且该节点在旧的一组子节点中的索引为 <code>2</code>。</li>\n<li><p>第二步：取新的一组子节点中的第二个节点 <code>p-1</code>，它的 <code>key</code> 为 1。尝试在旧的一组子节点中找到具有相同 <code>key</code> 值的可复用节点，发现能够找到，并且该节点在旧的一组子节点中的索引为 <code>0</code>。</p>\n<p>到了这一步我们发现，索引值递增的顺序被打破了。节点 <code>p-1</code> 在旧 <code>children</code> 中的索引是 <code>0</code>，它小于节点 <code>p-3</code> 在旧 <code>children</code> 中的索引 <code>2</code>。这说明<strong>节点</strong> <code>p-1</code> <strong>在旧</strong> <code>children</code> <strong>中排在节点</strong> <code>p-3</code> <strong>前面，但在新的</strong> <code>children</code> <strong>中，它排在节点</strong> <code>p-3</code> <strong>后面</strong>。因此，我们能够得出一个结论：<strong>节点</strong> <code>p-1</code> <strong>对应的真实</strong> DOM <strong>需要移动</strong>。</p>\n</li>\n<li><p>第三步：取新的一组子节点中的第三个节点 <code>p-2</code>，它的 <code>key</code> 为 2。尝试在旧的一组子节点中找到具有相同 <code>key</code> 值的可复用节点，发现能够找到，并且该节点在旧的一组子节点中的索引为 <code>1</code>。</p>\n<p>到了这一步我们发现，节点 <code>p-2</code> 在旧 <code>children</code> 中的索引 <code>1</code> 要小于节点 <code>p-3</code> 在旧 <code>children</code> 中的索引 <code>2</code>。这说明，<strong>节点</strong> <code>p-2</code> <strong>在旧</strong> <code>children</code> <strong>中排在节点</strong> <code>p-3</code> <strong>前面，但在新的</strong> <code>children</code> <strong>中，它排在节点</strong> <code>p-3</code> <strong>后面。因此，节点</strong> <code>p-2</code> <strong>对应的真实</strong> DOM <strong>也需要移动</strong>。</p>\n</li>\n</ul>\n<p>以上就是 Diff 算法在执行更新的过程中，判断节点是否需要移动的方式。在上面的例子中，我们得出了节点 <code>p-1</code> 和节点 <code>p-2</code> 需要移动的结论。这是因为它们在旧 <code>children</code> 中的索引要小于节点 <code>p-3</code> 在旧 <code>children</code> 中的索引。如果我们按照先后顺序记录在寻找节点过程中所遇到的位置索引，将会得到序列：<code>2</code>、<code>0</code>、<code>1</code>。可以发现，这个序列不具有递增的趋势。</p>\n<p>其实我们可以将节点 <code>p-3</code> 在旧 <code>children</code> 中的索引定义为：<strong>在旧</strong> <code>children</code> <strong>中寻找具有相同</strong> <code>key</code> <strong>值节点的过程中，遇到的最大索引值</strong>。如果在后续寻找的过程中，存在索引值比当前遇到的最大索引值还要小的节点，则意味着该节点需要移动。</p>\n<p>我们可以用 <code>lastIndex</code> 变量存储整个寻找过程中遇到的最大索引值，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function patchChildren(n1, n2, container) {\n   if (typeof n2.children === 'string') {\n     // 省略部分代码\n   } else if (Array.isArray(n2.children)) {\n     const oldChildren = n1.children\n     const newChildren = n2.children\n<pre><code> // 用来存储寻找过程中遇到的最大索引值\n let lastIndex = 0\n for (let i = 0; i &amp;lt; newChildren.length; i++) {\n   const newVNode = newChildren[i]\n   for (let j = 0; j &amp;lt; oldChildren.length; j++) {\n     const oldVNode = oldChildren[j]\n     if (newVNode.key === oldVNode.key) {\n       patch(oldVNode, newVNode, container)\n       if (j &amp;lt; lastIndex) {\n         // 如果当前找到的节点在旧 children 中的索引小于最大索引值 lastIndex，\n         // 说明该节点对应的真实 DOM 需要移动\n       } else {\n         // 如果当前找到的节点在旧 children 中的索引不小于最大索引值，\n         // 则更新 lastIndex 的值\n         lastIndex = j\n       }\n       break // 这里需要 break\n     }\n   }\n }\n</code></pre>\n<p>} else {<br />\n// 省略部分代码<br />\n}<br />\n}<br />\n</code></pre></p>\n<p>如以上代码及注释所示，如果新旧节点的 <code>key</code> 值相同，说明我们在旧 <code>children</code> 中找到了可复用 DOM 的节点。此时我们用该节点在旧 <code>children</code> 中的索引 <code>j</code> 与 <code>lastIndex</code> 进行比较，如果 <code>j</code> 小于 <code>lastIndex</code>，说明当前 <code>oldVNode</code> 对应的真实 DOM 需要移动，否则说明不需要移动。但此时应该将变量 <code>j</code> 的值赋给变量 <code>lastIndex</code>，以保证寻找节点的过程中，变量 <code>lastIndex</code> 始终存储着当前遇到的最大索引值。</p>\n<p>现在，我们已经找到了需要移动的节点，下一节我们将讨论如何移动节点，从而完成节点顺序的更新。</p>\n<h2 id=\"nav_point_92\">9.4　如何移动元素</h2>\n<p>在上一节中，我们讨论了如何判断节点是否需要移动。移动节点指的是，移动一个虚拟节点所对应的真实 DOM 节点，并不是移动虚拟节点本身。既然移动的是真实 DOM 节点，那么就需要取得对它的引用才行。我们知道，当一个虚拟节点被挂载后，其对应的真实 DOM 节点会存储在它的 <code>vnode.el</code> 属性中，如图 9-7 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00534.jpeg\" alt=\"\" width=\"47%\" style=\"width: 47%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-7　虚拟节点引用了真实 DOM 元素</strong></p>\n<p>因此，在代码中，我们可以通过旧子节点的 <code>vnode.el</code> 属性取得它对应的真实 DOM 节点。</p>\n<p>当更新操作发生时，渲染器会调用 <code>patchElement</code> 函数在新旧虚拟节点之间进行打补丁。回顾一下 <code>patchElement</code> 函数的代码，如下：</p>\n<pre class=\"code-rows\"><code> function patchElement(n1, n2) {\n   // 新的 vnode 也引用了真实 DOM 元素\n   const el = n2.el = n1.el\n   // 省略部分代码\n }\n</code></pre>\n<p>可以看到，<code>patchElement</code> 函数首先将旧节点的 <code>n1.el</code> 属性赋值给新节点的 <code>n2.el</code> 属性。这个赋值语句的真正含义其实就是 DOM 元素的<strong>复用</strong>。在复用了 DOM 元素之后，新节点也将持有对真实 DOM 的引用，如图 9-8 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00535.jpeg\" alt=\"\" width=\"67%\" style=\"width: 67%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-8　使新的子节点也引用真实 DOM 元素</strong></p>\n<p>可以看到，无论是新子节点还是旧子节点，都存在对真实 DOM 的引用，在此基础上，我们就可以进行 DOM 移动操作了。</p>\n<p>为了阐述具体应该怎样移动 DOM 节点，我们仍然引用上一节的更新案例，如图 9-9 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00536.jpeg\" alt=\"\" width=\"65%\" style=\"width: 65%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-9　新旧子节点的关系</strong></p>\n<p>它的更新步骤如下。</p>\n<ul>\n<li>第一步：取新的一组子节点中第一个节点 <code>p-3</code>，它的 <code>key</code> 为 3，尝试在旧的一组子节点中找到具有相同 <code>key</code> 值的可复用节点。发现能够找到，并且该节点在旧的一组子节点中的索引为 <code>2</code>。此时变量 <code>lastIndex</code> 的值为 <code>0</code>，索引 <code>2</code> 不小于 <code>0</code>，所以节点 <code>p-3</code> 对应的真实 DOM 不需要移动，但需要更新变量 <code>lastIndex</code> 的值为 <code>2</code>。</li>\n<li><p>第二步：取新的一组子节点中第二个节点 <code>p-1</code>，它的 <code>key</code> 为 1，尝试在旧的一组子节点中找到具有相同 <code>key</code> 值的可复用节点。发现能够找到，并且该节点在旧的一组子节点中的索引为 <code>0</code>。此时变量 <code>lastIndex</code> 的值为 <code>2</code>，索引 <code>0</code> 小于 <code>2</code>，所以节点 <code>p-1</code> 对应的真实 DOM 需要移动。</p>\n<p>到了这一步，我们发现，节点 <code>p-1</code> 对应的真实 DOM 需要移动，但应该移动到哪里呢？我们知道，<strong>新</strong> <code>children</code> <strong>的顺序其实就是更新后真实 DOM 节点应有的顺序</strong>。所以节点 <code>p-1</code> 在新 <code>children</code> 中的位置就代表了真实 DOM 更新后的位置。由于节点 <code>p-1</code> 在新 <code>children</code> 中排在节点 <code>p-3</code> 后面，所以我们应该<strong>把节点</strong> <code>p-1</code> <strong>所对应的真实</strong> DOM <strong>移动到节点</strong> <code>p-3</code> <strong>所对应的真实</strong> DOM <strong>后面</strong>。移动后的结果如图 9-10 所示。</p>\n<p>可以看到，这样操作之后，此时真实 DOM 的顺序为 <code>p-2</code>、<code>p-3</code>、<code>p-1</code>。</p>\n</li>\n<li><p>第三步：取新的一组子节点中第三个节点 <code>p-2</code>，它的 <code>key</code> 为 2。尝试在旧的一组子节点中找到具有相同 <code>key</code> 值的可复用节点。发现能够找到，并且该节点在旧的一组子节点中的索引为 <code>1</code>。此时变量 <code>lastIndex</code> 的值为 <code>2</code>，索引 <code>1</code> 小于 <code>2</code>，所以节点 <code>p-2</code> 对应的真实 DOM 需要移动。</p>\n</li>\n</ul>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00537.jpeg\" alt=\"\" width=\"80%\" style=\"width: 80%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-10　把节点 <code>p-1</code> 对应的真实 DOM 移动到节点 <code>p-3</code> 对应的真实 DOM 后面</strong></p>\n<p>第三步与第二步类似，节点 <code>p-2</code> 对应的真实 DOM 也需要移动。同样，由于节点 <code>p-2</code> 在新 <code>children</code> 中排在节点 <code>p-1</code> 后面，所以我们应该把节点 <code>p-2</code> 对应的真实 DOM 移动到节点 <code>p-1</code> 对应的真实 DOM 后面。移动后的结果如图 9-11 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00538.jpeg\" alt=\"\" width=\"80%\" style=\"width: 80%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-11　把节点 <code>p-2</code> 对应的真实 DOM 移动到节点 <code>p-1</code> 对应的真实 DOM 后面</strong></p>\n<p>经过这一步移动操作之后，我们发现，真实 DOM 的顺序与新的一组子节点的顺序相同了：<code>p-3</code>、<code>p-1</code>、<code>p-2</code>。至此，更新操作完成。</p>\n<p>接下来，我们着手实现代码。其实并不复杂，如下面 <code>patchChildren</code> 函数的代码所示：</p>\n<pre class=\"code-rows\"><code> function patchChildren(n1, n2, container) {\n   if (typeof n2.children === 'string') {\n     // 省略部分代码\n   } else if (Array.isArray(n2.children)) {\n     const oldChildren = n1.children\n     const newChildren = n2.children\n<pre><code> let lastIndex = 0\n for (let i = 0; i &amp;lt; newChildren.length; i++) {\n   const newVNode = newChildren[i]\n   let j = 0\n   for (j; j &amp;lt; oldChildren.length; j++) {\n     const oldVNode = oldChildren[j]\n     if (newVNode.key === oldVNode.key) {\n       patch(oldVNode, newVNode, container)\n       if (j &amp;lt; lastIndex) {\n         // 代码运行到这里，说明 newVNode 对应的真实 DOM 需要移动\n         // 先获取 newVNode 的前一个 vnode，即 prevVNode\n         const prevVNode = newChildren[i - 1]\n         // 如果 prevVNode 不存在，则说明当前 newVNode 是第一个节点，它不需要移动\n         if (prevVNode) {\n           // 由于我们要将 newVNode 对应的真实 DOM 移动到 prevVNode 所对应真实 DOM 后面，\n           // 所以我们需要获取 prevVNode 所对应真实 DOM 的下一个兄弟节点，并将其作为锚点\n           const anchor = prevVNode.el.nextSibling\n           // 调用 insert 方法将 newVNode 对应的真实 DOM 插入到锚点元素前面，\n           // 也就是 prevVNode 对应真实 DOM 的后面\n           insert(newVNode.el, container, anchor)\n         }\n       } else {\n         lastIndex = j\n       }\n       break\n     }\n   }\n }\n</code></pre>\n<p>} else {<br />\n// 省略部分代码<br />\n}<br />\n}<br />\n</code></pre></p>\n<p>在上面这段代码中，如果条件 <code>j &lt; lastIndex</code> 成立，则说明当前 <code>newVNode</code> 所对应的真实 DOM 需要移动。根据前文的分析可知，我们需要获取当前 <code>newVNode</code> 节点的前一个虚拟节点，即 <code>newChildren[i - 1]</code>，然后使用 <code>insert</code> 函数完成节点的移动，其中 <code>insert</code> 函数依赖浏览器原生的 <code>insertBefore</code> 函数，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> const renderer = createRenderer({\n   // 省略部分代码\n<p>insert(el, parent, anchor = null) {<br />\n// insertBefore 需要锚点元素 anchor<br />\nparent.insertBefore(el, anchor)<br />\n}</p>\n<p>// 省略部分代码<br />\n})<br />\n</code></pre></p>\n<h2 id=\"nav_point_93\">9.5　添加新元素</h2>\n<p>本节我们将讨论添加新节点的情况，如图 9-12 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00539.jpeg\" alt=\"\" width=\"60%\" style=\"width: 60%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-12　新增节点 <code>p-4</code></strong></p>\n<p>观察图 9-12 可知，在新的一组子节点中，多出来一个节点 <code>p-4</code>，它的 <code>key</code> 值为 <code>4</code>，该节点在旧的一组子节点不存在，因此应该将其视为新增节点。对于新增节点，在更新时我们应该正确地将它挂载，这主要分为两步：</p>\n<ul>\n<li>想办法找到新增节点；</li>\n<li>将新增节点挂载到正确位置。</li>\n</ul>\n<p>首先，我们来看一下如何找到新增节点。为了搞清楚这个问题，我们需要根据图 9-12 中给出的例子模拟执行简单 Diff 算法的逻辑。在此之前，我们需要弄清楚新旧两组子节点与真实 DOM 元素的当前状态，如图 9-13 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00540.jpeg\" alt=\"\" width=\"75%\" style=\"width: 75%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-13　新旧两组子节点与真实 DOM 元素的当前状态</strong></p>\n<p>接着，我们开始模拟执行简单 Diff 算法的更新逻辑。</p>\n<ul>\n<li>第一步：取新的一组子节点中第一个节点 <code>p-3</code>，它的 <code>key</code> 值为 3，尝试在旧的一组子节点中寻找可复用的节点。发现能够找到，并且该节点在旧的一组子节点中的索引值为 <code>2</code>。此时，变量 <code>lastIndex</code> 的值为 <code>0</code>，索引值 <code>2</code> 不小于 <code>lastIndex</code> 的值 <code>0</code>，所以节点 <code>p-3</code> 对应的真实 DOM 不需要移动，但是需要将变量 <code>lastIndex</code> 的值更新为 <code>2</code>。</li>\n<li><p>第二步：取新的一组子节点中第二个节点 <code>p-1</code>，它的 <code>key</code> 值为 1，尝试在旧的一组子节点中寻找可复用的节点。发现能够找到，并且该节点在旧的一组子节点中的索引值为 <code>0</code>。此时变量 <code>lastIndex</code> 的值为 <code>2</code>，索引值 <code>0</code> 小于 <code>lastIndex</code> 的值 <code>2</code>，所以节点 <code>p-1</code> 对应的真实 DOM 需要移动，并且应该移动到节点 <code>p-3</code> 对应的真实 DOM 后面。经过这一步的移动操作后，真实 DOM 的状态如图 9-14 所示。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00541.jpeg\" alt=\"\" width=\"80%\" style=\"width: 80%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-14　真实 DOM 的当前状态</strong></p>\n<p>此时真实 DOM 的顺序为 <code>p-2</code>、<code>p-3</code>、<code>p-1</code>。</p>\n</li>\n<li><p>第三步：取新的一组子节点中第三个节点 <code>p-4</code>，它的 <code>key</code> 值为 4，尝试在旧的一组子节点中寻找可复用的节点。由于在旧的一组子节点中，没有 <code>key</code> 值为 4 的节点，因此渲染器会把节点 <code>p-4</code> 看作新增节点并挂载它。那么，应该将它挂载到哪里呢？为了搞清楚这个问题，我们需要观察节点 <code>p-4</code> 在新的一组子节点中的位置。由于节点 <code>p-4</code> 出现在节点 <code>p-1</code> 后面，所以我们应该把节点 <code>p-4</code> 挂载到节点 <code>p-1</code> 所对应的真实 DOM 后面。在经过这一步挂载操作之后，真实 DOM 的状态如图 9-15 所示。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00542.jpeg\" alt=\"\" width=\"80%\" style=\"width: 80%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-15　真实 DOM 的当前状态</strong></p>\n<p>此时真实 DOM 的顺序是：<code>p-2</code>、<code>p-3</code>、<code>p-1</code>、<code>p-4</code>，其中 <code>p-4</code> 是刚刚挂载的。</p>\n</li>\n<li><p>第四步：取新的一组子节点中第四个节点 <code>p-2</code>，它的 <code>key</code> 值为 2，尝试在旧的一组子节点中寻找可复用的节点。发现能够找到，并且该节点在旧的一组子节点中的索引值为 <code>1</code>。此时变量 <code>lastIndex</code> 的值为 <code>2</code>，索引值 <code>1</code> 小于 <code>lastIndex</code> 的值 <code>2</code>，所以节点 <code>p-2</code> 对应的真实 DOM 需要移动，并且应该移动到节点 <code>p-4</code> 对应的真实 DOM 后面。经过这一步移动操作后，真实 DOM 的状态如图 9-16 所示。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00543.jpeg\" alt=\"\" width=\"80%\" style=\"width: 80%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-16　真实 DOM 的当前状态</strong></p>\n</li>\n</ul>\n<p>此时真实 DOM 的顺序是：<code>p-3</code>、<code>p-1</code>、<code>p-4</code>、<code>p-2</code>。至此，真实 DOM 的顺序已经与新的一组子节点的顺序相同了，更新完成。</p>\n<p>接下来，我们着手实现代码，如下面 <code>patchChildren</code> 函数的代码所示：</p>\n<pre class=\"code-rows\"><code> function patchChildren(n1, n2, container) {\n   if (typeof n2.children === 'string') {\n     // 省略部分代码\n   } else if (Array.isArray(n2.children)) {\n     const oldChildren = n1.children\n     const newChildren = n2.children\n<pre><code> let lastIndex = 0\n for (let i = 0; i &amp;lt; newChildren.length; i++) {\n   const newVNode = newChildren[i]\n   let j = 0\n   // 在第一层循环中定义变量 find，代表是否在旧的一组子节点中找到可复用的节点，\n   // 初始值为 false，代表没找到\n   let find = false\n   for (j; j &amp;lt; oldChildren.length; j++) {\n     const oldVNode = oldChildren[j]\n     if (newVNode.key === oldVNode.key) {\n       // 一旦找到可复用的节点，则将变量 find 的值设为 true\n       find = true\n       patch(oldVNode, newVNode, container)\n       if (j &amp;lt; lastIndex) {\n         const prevVNode = newChildren[i - 1]\n         if (prevVNode) {\n           const anchor = prevVNode.el.nextSibling\n           insert(newVNode.el, container, anchor)\n         }\n       } else {\n         lastIndex = j\n       }\n       break\n     }\n   }\n   // 如果代码运行到这里，find 仍然为 false，\n   // 说明当前 newVNode 没有在旧的一组子节点中找到可复用的节点\n   // 也就是说，当前 newVNode 是新增节点，需要挂载\n   if (!find) {\n     // 为了将节点挂载到正确位置，我们需要先获取锚点元素\n     // 首先获取当前 newVNode 的前一个 vnode 节点\n     const prevVNode = newChildren[i - 1]\n     let anchor = null\n     if (prevVNode) {\n       // 如果有前一个 vnode 节点，则使用它的下一个兄弟节点作为锚点元素\n       anchor = prevVNode.el.nextSibling\n     } else {\n       // 如果没有前一个 vnode 节点，说明即将挂载的新节点是第一个子节点\n       // 这时我们使用容器元素的 firstChild 作为锚点\n       anchor = container.firstChild\n     }\n     // 挂载 newVNode\n     patch(null, newVNode, container, anchor)\n   }\n }\n</code></pre>\n<p>} else {<br />\n// 省略部分代码<br />\n}<br />\n}<br />\n</code></pre></p>\n<p>观察上面这段代码。首先，我们在外层循环中定义了名为 <code>find</code> 的变量，它代表渲染器能否在旧的一组子节点中找到可复用的节点。变量 <code>find</code> 的初始值为 <code>false</code>，一旦寻找到可复用的节点，则将变量 <code>find</code> 的值设置为 <code>true</code>。如果内层循环结束后，变量 <code>find</code> 的值仍然为 <code>false</code>，则说明当前 <code>newVNode</code> 是一个全新的节点，需要挂载它。为了将节点挂载到正确位置，我们需要先获取锚点元素：找到 <code>newVNode</code> 的前一个虚拟节点，即 <code>prevVNode</code>，如果存在，则使用它对应的真实 DOM 的下一个兄弟节点作为锚点元素；如果不存在，则说明即将挂载的 <code>newVNode</code> 节点是容器元素的第一个子节点，此时应该使用容器元素的 <code>container.firstChild</code> 作为锚点元素。最后，将锚点元素 <code>anchor</code> 作为 <code>patch</code> 函数的第四个参数，调用 <code>patch</code> 函数完成节点的挂载。</p>\n<p>但由于目前实现的 <code>patch</code> 函数还不支持传递第四个参数，所以我们需要调整 <code>patch</code> 函数的代码，如下所示：</p>\n<pre class=\"code-rows\"><code> // patch 函数需要接收第四个参数，即锚点元素\n function patch(n1, n2, container, anchor) {\n   // 省略部分代码\n<p>if (typeof type === ‘string’) {<br />\nif (!n1) {<br />\n// 挂载时将锚点元素作为第三个参数传递给 mountElement 函数<br />\nmountElement(n2, container, anchor)<br />\n} else {<br />\npatchElement(n1, n2)<br />\n}<br />\n} else if (type === Text) {<br />\n// 省略部分代码<br />\n} else if (type === Fragment) {<br />\n// 省略部分代码<br />\n}<br />\n}</p>\n<p>// mountElement 函数需要增加第三个参数，即锚点元素<br />\nfunction mountElement(vnode, container, anchor) {<br />\n// 省略部分代码</p>\n<p>// 在插入节点时，将锚点元素透传给 insert 函数<br />\ninsert(el, container, anchor)<br />\n}<br />\n</code></pre></p>\n<h2 id=\"nav_point_94\">9.6　移除不存在的元素</h2>\n<p>在更新子节点时，不仅会遇到新增元素，还会出现元素被删除的情况，如图 9-17 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00544.jpeg\" alt=\"\" width=\"65%\" style=\"width: 65%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-17　节点被删除的情况</strong></p>\n<p>在新的一组子节点中，节点 <code>p-2</code> 已经不存在了，这说明该节点被删除了。渲染器应该能找到那些需要删除的节点并正确地将其删除。</p>\n<p>具体要如何做呢？首先，我们来讨论如何找到需要删除的节点。以图 9-17 为例，我们来分析它的更新步骤。在模拟执行更新逻辑之前，我们需要清楚新旧两组子节点以及真实 DOM 节点的当前状态，如图 9-18 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00545.jpeg\" alt=\"\" width=\"80%\" style=\"width: 80%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-18　新旧两组子节点与真实 DOM 节点的当前状态</strong></p>\n<p>接着，我们开始模拟执行更新的过程。</p>\n<ul>\n<li>第一步：取新的一组子节点中的第一个节点 <code>p-3</code>，它的 <code>key</code> 值为 3。尝试在旧的一组子节点中寻找可复用的节点。发现能够找到，并且该节点在旧的一组子节点中的索引值为 <code>2</code>。此时变量 <code>lastIndex</code> 的值为 <code>0</code>，索引 <code>2</code> 不小于 <code>lastIndex</code> 的值 <code>0</code>，所以节点 <code>p-3</code> 对应的真实 DOM 不需要移动，但需要更新变量 <code>lastIndex</code> 的值为 <code>2</code>。</li>\n<li>第二步：取新的一组子节点中的第二个节点 <code>p-1</code>，它的 <code>key</code> 值为 1。尝试在旧的一组子节点中寻找可复用的节点。发现能够找到，并且该节点在旧的一组子节点中的索引值为 <code>0</code>。此时变量 <code>lastIndex</code> 的值为 <code>2</code>，索引 <code>0</code> 小于 <code>lastIndex</code> 的值 <code>2</code>，所以节点 <code>p-1</code> 对应的真实 DOM 需要移动，并且应该移动到节点 <code>p-3</code> 对应的真实 DOM 后面。经过这一步的移动操作后，真实 DOM 的状态如图 9-19 所示。</li>\n</ul>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00546.jpeg\" alt=\"\" width=\"85%\" style=\"width: 85%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-19　真实 DOM 的当前状态</strong></p>\n<p>至此，更新结束。我们发现，节点 <code>p-2</code> 对应的真实 DOM 仍然存在，所以需要增加额外的逻辑来删除遗留节点。思路很简单，当基本的更新结束时，我们需要遍历旧的一组子节点，然后去新的一组子节点中寻找具有相同 <code>key</code> 值的节点。如果找不到，则说明应该删除该节点，如下面 <code>patchChildren</code> 函数的代码所示：</p>\n<pre class=\"code-rows\"><code> function patchChildren(n1, n2, container) {\n   if (typeof n2.children === 'string') {\n     // 省略部分代码\n   } else if (Array.isArray(n2.children)) {\n     const oldChildren = n1.children\n     const newChildren = n2.children\n<pre><code> let lastIndex = 0\n for (let i = 0; i &amp;lt; newChildren.length; i++) {\n   // 省略部分代码\n }\n\n // 上一步的更新操作完成后\n // 遍历旧的一组子节点\n for (let i = 0; i &amp;lt; oldChildren.length; i++) {\n   const oldVNode = oldChildren[i]\n   // 拿旧子节点 oldVNode 去新的一组子节点中寻找具有相同 key 值的节点\n   const has = newChildren.find(\n     vnode =&amp;gt; vnode.key === oldVNode.key\n   )\n   if (!has) {\n     // 如果没有找到具有相同 key 值的节点，则说明需要删除该节点\n     // 调用 unmount 函数将其卸载\n     unmount(oldVNode)\n   }\n }\n</code></pre>\n<p>} else {<br />\n// 省略部分代码<br />\n}<br />\n}<br />\n</code></pre></p>\n<p>如以上代码及注释所示，在上一步的更新操作完成之后，我们还需要遍历旧的一组子节点，目的是检查旧子节点在新的一组子节点中是否仍然存在，如果已经不存在了，则调用 <code>unmount</code> 函数将其卸载。</p>\n<h2 id=\"nav_point_95\">9.7　总结</h2>\n<p>在本章中，我们首先讨论了 Diff 算法的作用。Diff 算法用来计算两组子节点的差异，并试图最大程度地复用 DOM 元素。在上一章中，我们采用了一种简单的方式来更新子节点，即卸载所有旧子节点，再挂载所有新子节点。然而这种更新方式无法对 DOM 元素进行复用，需要大量的 DOM 操作才能完成更新，非常消耗性能。于是，我们对它进行了改进。改进后的方案是，遍历新旧两组子节点中数量较少的那一组，并逐个调用 <code>patch</code> 函数进行打补丁，然后比较新旧两组子节点的数量，如果新的一组子节点数量更多，说明有新子节点需要挂载；否则说明在旧的一组子节点中，有节点需要卸载。</p>\n<p>然后，我们讨论了虚拟节点中 <code>key</code> 属性的作用，它就像虚拟节点的“身份证号”。在更新时，渲染器通过 <code>key</code> 属性找到可复用的节点，然后尽可能地通过 DOM 移动操作来完成更新，避免过多地对 DOM 元素进行销毁和重建。</p>\n<p>接着，我们讨论了简单 Diff 算法是如何寻找需要移动的节点的。简单 Diff 算法的核心逻辑是，拿新的一组子节点中的节点去旧的一组子节点中寻找可复用的节点。如果找到了，则记录该节点的位置索引。我们把这个位置索引称为最大索引。在整个更新过程中，如果一个节点的索引值小于最大索引，则说明该节点对应的真实 DOM 元素需要移动。</p>\n<p>最后，我们通过几个例子讲解了渲染器是如何移动、添加、删除虚拟节点所对应的 DOM 元素的。</p>\n<br style=\"page-break-after:always\" />","comments":[]}