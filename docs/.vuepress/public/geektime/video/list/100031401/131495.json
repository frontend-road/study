{"id":131495,"title":"83 | Kubernetes应用金丝雀发布实验","content":"<ul>\n<li>\n<p>代码：<a href=\"https://gitee.com/geektime-geekbang/staffjoy\">https://gitee.com/geektime-geekbang/staffjoy</a></p>\n</li>\n<li>\n<p>课件：<a href=\"https://pan.baidu.com/s/1Q7eP3yZ1Vm8J2nhle5RzTQ\">https://pan.baidu.com/s/1Q7eP3yZ1Vm8J2nhle5RzTQ</a> 提取码: 1aeh</p>\n</li>\n</ul>","comments":[{"had_liked":false,"id":132914,"user_name":"stone","can_delete":false,"product_type":"c3","uid":1174491,"ip_address":"","ucode":"336DDEC95DF202","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/YlhEhLOxBkVdWfggdGeZmibw3PRXQicuicVsN2nwdrfZhsTLye2MR0nYvmYGO9TjTjEiceIEjIkxZ9bTXdtzNDLa3Q/132","comment_is_top":false,"comment_ctime":1568273877,"is_pvip":false,"replies":[{"id":50943,"content":"k8s默认支持的就是滚动发布(rolling update)，假设你有一个svc v1版本已经发布到k8s，svc v1假设有10个pod实例，那么下次你发布svc的v2新版本，在deployment yml文件中只需修改镜像版本，然后kubectl apply这yml文件，k8s就会自动进行滚动发布，将v2的pod实例陆续拉入，v1的pod实例陆续拉出，例如，k8s会先拉入2个v2的pod实例，然后拉出2个v1的pod实例，间隔一段时间，再拉入2个v2的pod实例，然后拉出2个v1的pod实例，间隔一段时间，依次类推，一直到v2的pod实例全部拉入，v1的pod实例全部拉出，这就是滚动发布的过程，每次拉入拉出的数量(maxSurge)是可以配置的，具体可参考k8s文档:https:&#47;&#47;kubernetes.io&#47;docs&#47;concepts&#47;workloads&#47;controllers&#47;deployment&#47;","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1568290517,"ip_address":"","comment_id":132914,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100031401,"comment_content":"滚动发布是什么流程呀。波波老师能不能简单说一下呢","like_count":4,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467174,"discussion_content":"k8s默认支持的就是滚动发布(rolling update)，假设你有一个svc v1版本已经发布到k8s，svc v1假设有10个pod实例，那么下次你发布svc的v2新版本，在deployment yml文件中只需修改镜像版本，然后kubectl apply这yml文件，k8s就会自动进行滚动发布，将v2的pod实例陆续拉入，v1的pod实例陆续拉出，例如，k8s会先拉入2个v2的pod实例，然后拉出2个v1的pod实例，间隔一段时间，再拉入2个v2的pod实例，然后拉出2个v1的pod实例，间隔一段时间，依次类推，一直到v2的pod实例全部拉入，v1的pod实例全部拉出，这就是滚动发布的过程，每次拉入拉出的数量(maxSurge)是可以配置的，具体可参考k8s文档:https://kubernetes.io/docs/concepts/workloads/controllers/deployment/","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568290517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131941,"user_name":"JefferLiu","can_delete":false,"product_type":"c3","uid":1213125,"ip_address":"","ucode":"3186C9CCC8AEF6","user_header":"https://static001.geekbang.org/account/avatar/00/12/82/c5/bf83a009.jpg","comment_is_top":false,"comment_ctime":1567988841,"is_pvip":false,"replies":[{"id":50478,"content":"金丝雀是很好理解的，升级时候先上一台新版本去试水，这台新版本就是金丝雀，金丝雀没有问题，继续发全量新版本，同时下老版本；如果金丝雀有问题，则下金丝雀，取消升级。再升级还是这样做。\n\n金丝雀源于过去矿工下矿井前，为防止一氧化碳等中毒，先放一个金丝雀下去试，用在发布上也是这个道理，先上一台新版本去试。","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1568029231,"ip_address":"","comment_id":131941,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100031401,"comment_content":"再升级，谁是金丝雀呢","like_count":4,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466687,"discussion_content":"金丝雀是很好理解的，升级时候先上一台新版本去试水，这台新版本就是金丝雀，金丝雀没有问题，继续发全量新版本，同时下老版本；如果金丝雀有问题，则下金丝雀，取消升级。再升级还是这样做。\n\n金丝雀源于过去矿工下矿井前，为防止一氧化碳等中毒，先放一个金丝雀下去试，用在发布上也是这个道理，先上一台新版本去试。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568029231,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":265692,"user_name":"hunterlodge","can_delete":false,"product_type":"c3","uid":1069755,"ip_address":"","ucode":"5B83A79E784161","user_header":"https://static001.geekbang.org/account/avatar/00/10/52/bb/225e70a6.jpg","comment_is_top":false,"comment_ctime":1606984100,"is_pvip":false,"replies":[{"id":96707,"content":"课程只是为了演示形象才用了“www-web-deployment-canary”这样一个名字，实际后面可以跟版本号，例如原来是www-web-v1.0，然后下一版是www-web-v1.1，再下一版www-web-v1.2，诸如此类。不管用哪种版本机制，上新版前都可以先上一个做金丝雀测试，而且这个版本号留着的话发布历史也很清晰。","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1607268682,"ip_address":"","comment_id":265692,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100031401,"comment_content":"老师，金丝雀全量发布以后，线上的deployment就都是www-web-deployment-canary了，这样的话，下次如果再发版，当如何处理呢？回过来再使用www-web-deployment吗？显然这会有点怪。感觉应该有一个机制维持线上最终仍然是www-web-deployment，这样每一次发版，都只是在并存阶段同时存在两种deployment","like_count":2,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511015,"discussion_content":"课程只是为了演示形象才用了“www-web-deployment-canary”这样一个名字，实际后面可以跟版本号，例如原来是www-web-v1.0，然后下一版是www-web-v1.1，再下一版www-web-v1.2，诸如此类。不管用哪种版本机制，上新版前都可以先上一个做金丝雀测试，而且这个版本号留着的话发布历史也很清晰。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607268682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":256306,"user_name":"悟","can_delete":false,"product_type":"c3","uid":1179071,"ip_address":"","ucode":"4D82646444FDA9","user_header":"https://static001.geekbang.org/account/avatar/00/11/fd/bf/17012e71.jpg","comment_is_top":false,"comment_ctime":1603597507,"is_pvip":false,"replies":[{"id":93422,"content":"采用金丝雀发布进行切换的时候，新老版本是要求同时并存一段时间的(老版本不能马上停掉，需要等一个周期时间，例如观察5分钟后下线，这样也是为了后面可以按需回滚)，切换以后，新的流量会到新版本，切换瞬间有些老的流量还是会连在老服务上，可以不受影响，等这些老流量下次再请求的的时候，就会被切到新版本服务上去。","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1603713799,"ip_address":"","comment_id":256306,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100031401,"comment_content":"波波老师要是在线上发布的话，一些用户正在用老的服务，那么全部切换的时候，老的版本停掉，那会影响一些用户正在调用老的版本，这个怎么解决","like_count":1,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507991,"discussion_content":"采用金丝雀发布进行切换的时候，新老版本是要求同时并存一段时间的(老版本不能马上停掉，需要等一个周期时间，例如观察5分钟后下线，这样也是为了后面可以按需回滚)，切换以后，新的流量会到新版本，切换瞬间有些老的流量还是会连在老服务上，可以不受影响，等这些老流量下次再请求的的时候，就会被切到新版本服务上去。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603713799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162455,"user_name":"恰饭哒","can_delete":false,"product_type":"c3","uid":1014023,"ip_address":"","ucode":"0395069A050057","user_header":"https://static001.geekbang.org/account/avatar/00/0f/79/07/2f418316.jpg","comment_is_top":false,"comment_ctime":1576541320,"is_pvip":false,"replies":[{"id":62048,"content":"蓝绿切换后，老版是继续留着一段时间，不是马上kill掉的，这样那些连着老版本的请求将继续得到处理，直到处理完毕，但是新的请求将不会再路由到老版本，而是都路由到新版本，所以蓝绿发布一般是安全的。","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1576679420,"ip_address":"","comment_id":162455,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100031401,"comment_content":"波波老师，这个怎么解决请求了一半的服务了，一个服务请求在路上，突然把来版本kill的问题","like_count":1,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478054,"discussion_content":"蓝绿切换后，老版是继续留着一段时间，不是马上kill掉的，这样那些连着老版本的请求将继续得到处理，直到处理完毕，但是新的请求将不会再路由到老版本，而是都路由到新版本，所以蓝绿发布一般是安全的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576679420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137671,"user_name":"狼鱼","can_delete":false,"product_type":"c3","uid":1109255,"ip_address":"","ucode":"CA06ACA2AF8044","user_header":"https://static001.geekbang.org/account/avatar/00/10/ed/07/3a3e766f.jpg","comment_is_top":false,"comment_ctime":1569816258,"is_pvip":false,"replies":[{"id":52949,"content":"Istio&#47;ServiceMesh是K8s推荐的流量治理(或多版本控制)机制，这个机制的好处是可以做到应用无关，不足是运维门槛成本较高。\n\n其它方案可以考虑软件方式实现，一般采用功能开关或A&#47;B测试技术实现，这个机制需要侵入代码，但是灵活性更高，参考项目：\nhttps:&#47;&#47;github.com&#47;checkr&#47;flagr\nhttps:&#47;&#47;github.com&#47;markphelps&#47;flipt\nhttps:&#47;&#47;github.com&#47;intuit&#47;wasabi","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1569848526,"ip_address":"","comment_id":137671,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100031401,"comment_content":"如果采用SpringBoot+K8S的方式进行微服务部署，如果想实现服务的多版本控制有什么好方法吗？ 如果采用Spring Cloud 可使用 metadata 在加版本号，然后扩展ribbon的路由策略来实现。 基于K8S 除了使用Istio 还有其他方法吗？","like_count":1,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469204,"discussion_content":"Istio/ServiceMesh是K8s推荐的流量治理(或多版本控制)机制，这个机制的好处是可以做到应用无关，不足是运维门槛成本较高。\n\n其它方案可以考虑软件方式实现，一般采用功能开关或A/B测试技术实现，这个机制需要侵入代码，但是灵活性更高，参考项目：\nhttps://github.com/checkr/flagr\nhttps://github.com/markphelps/flipt\nhttps://github.com/intuit/wasabi","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569848526,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}