{"id":647834,"title":"14｜增强模板：如何抽取专门的部件完成专门的任务？","content":"<p>你好，我是郭屹，今天我们继续手写MiniSpring。</p><p>上节课，我们从JDBC这些套路性的程序流程中抽取出了一个通用模板。然后进行了拆解，将SQL语句当作参数传入，而SQL语句执行之后的结果处理逻辑也作为一个匿名类传入，又抽取出了数据源的概念。下面我们接着上节课的思路，继续拆解JDBC程序。</p><p>我们现在观察应用程序怎么使用的JdbcTemplate，看这些代码，还是会发现几个问题。</p><ol>\n<li>SQL语句参数的传入还是一个个写进去的，没有抽取出一个独立的部件进行统一处理。</li>\n<li>返回的记录是单行的，不支持多行的数据集，所以能对上层应用程序提供的API非常有限。</li>\n<li>另外每次执行SQL语句都会建立连接、关闭连接，性能会受到很大影响。</li>\n</ol><p>这些问题，我们都需要在这节课上一个个解决。</p><h2>参数传入</h2><p>先看SQL语句参数的传入问题，我们注意到现在往PreparedStatement中传入参数是这样实现的。</p><pre><code class=\"language-plain\">\tfor (int i = 0; i &lt; args.length; i++) {\n\t\tObject arg = args[i];\n\t\tif (arg instanceof String) {\n\t\t\tpstmt.setString(i+1, (String)arg);\n\t\t}\n\t\telse if (arg instanceof Integer) {\n\t\t\tpstmt.setInt(i+1, (int)arg);\n\t\t}\n\t\telse if (arg instanceof java.util.Date) {\n\t\t\tpstmt.setDate(i+1, new java.sql.Date(((java.util.Date)arg).getTime()));\n\t\t}\n\t}\n</code></pre><!-- [[[read_end]]] --><p>简单地说，这些参数都是一个个手工传入进去的。但我们想让参数传入的过程自动化一点，所以现在我们来修改一下，把JDBC里传参数的代码进行包装，用一个专门的部件专门做这件事情，于是我们引入<strong>ArgumentPreparedStatementSetter</strong>，通过里面的setValues()方法把参数传进PreparedStatement。</p><pre><code class=\"language-plain\">package com.minis.jdbc.core;\n\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\n\npublic class ArgumentPreparedStatementSetter {\n\tprivate final Object[] args; //参数数组\n\n\tpublic ArgumentPreparedStatementSetter(Object[] args) {\n\t\tthis.args = args;\n\t}\n    //设置SQL参数\n\tpublic void setValues(PreparedStatement pstmt) throws SQLException {\n\t\tif (this.args != null) {\n\t\t\tfor (int i = 0; i &lt; this.args.length; i++) {\n\t\t\t\tObject arg = this.args[i];\n\t\t\t\tdoSetValue(pstmt, i + 1, arg);\n\t\t\t}\n\t\t}\n\t}\n    //对某个参数，设置参数值\n\tprotected void doSetValue(PreparedStatement pstmt, int parameterPosition, Object argValue) throws SQLException {\n\t\tObject arg = argValue;\n        //判断参数类型，调用相应的JDBC set方法   \n\t\tif (arg instanceof String) {\n\t\t\tpstmt.setString(parameterPosition, (String)arg);\n\t\t}\n\t\telse if (arg instanceof Integer) {\n\t\t\tpstmt.setInt(parameterPosition, (int)arg);\n\t\t}\n\t\telse if (arg instanceof java.util.Date) {\n\t\t\tpstmt.setDate(parameterPosition, new java.sql.Date(((java.util.Date)arg).getTime()));\t\n\t\t}\n\t}\n}\n</code></pre><p>从代码中可以看到，核心仍然是JDBC的set方法，但是包装成了一个独立部件。现在的示例程序只是针对了String、Int和Date三种数据类型，更多的数据类型我们留到后面再扩展。</p><p>有了这个专门负责参数传入的setter之后，query()就修改成这个样子。</p><pre><code class=\"language-plain\">\tpublic Object query(String sql, Object[] args, PreparedStatementCallback pstmtcallback) {\n\t\tConnection con = null;\n\t\tPreparedStatement pstmt = null;\n\t\t\n\t\ttry {\n            //通过data source拿数据库连接\n\t\t\tcon = dataSource.getConnection();\n\n\t\t\tpstmt = con.prepareStatement(sql);\n            //通过argumentSetter统一设置参数值\n\t\t\tArgumentPreparedStatementSetter argumentSetter = new ArgumentPreparedStatementSetter(args);\t\n\t\t\targumentSetter.setValues(pstmt);\n\t\t\t\n\t\t\treturn pstmtcallback.doInPreparedStatement(pstmt);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tpstmt.close();\n\t\t\t\tcon.close();\n\t\t\t} catch (Exception e) {\t\t\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n</code></pre><p>我们可以看到，代码简化了很多，手工写的一大堆设置参数的代码不见了，这就体现了专门的部件做专门的事情的优点。</p><h2>对返回结果的处理</h2><p>JDBC来执行SQL语句，说起来很简单，就三步，一准备参数，二执行语句，三处理返回结果。准备参数和执行语句这两步我们上面都已经抽取了。接下来我们再优化一下处理返回值的代码，看看能不能提供更多便捷的方法。</p><p>我们先看一下现在是怎么处理的，程序体现在pstmtcallback.doInPreparedStatement(pstmt)这个方法里，这是一个callback类，由用户程序自己给定，一般会这么做。</p><pre><code class=\"language-plain\">\treturn (User)jdbcTemplate.query(sql, new Object[]{new Integer(userid)},\n\t\t(pstmt)-&gt;{\t\t\t\n\t\t\tResultSet rs = pstmt.executeQuery();\n\t\t\tUser rtnUser = null;\n\t\t\tif (rs.next()) {\n\t\t\t\trtnUser = new User();\n\t\t\t\trtnUser.setId(userid);\n\t\t\t\trtnUser.setName(rs.getString(\"name\"));\n\t\t\t\trtnUser.setBirthday(new java.util.Date(rs.getDate(\"birthday\").getTime()));\n\t\t\t} else {\n\t\t\t}\n\t\t\treturn rtnUser;\n\t\t}\n\t);\n</code></pre><p>这个本身没有什么问题，这部分逻辑实际上已经剥离出去了。只不过，它限定了用户只能用这么一种方式进行。有时候很不便利，我们还应该考虑给用户程序提供多种方式。比如说，我们想返回的不是一个对象（对应数据库中一条记录），而是对象列表（对应数据库中多条记录）。这种场景很常见，需要我们再单独提供一个便利的工具。</p><p>所以我们设计一个接口RowMapper，把JDBC返回的ResultSet里的某一行数据映射成一个对象。</p><pre><code class=\"language-plain\">package com.minis.jdbc.core;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\npublic interface RowMapper&lt;T&gt; {\n\tT mapRow(ResultSet rs, int rowNum) throws SQLException;\n}\n</code></pre><p>再提供一个接口ResultSetExtractor，把JDBC返回的ResultSet数据集映射为一个集合对象。</p><pre><code class=\"language-plain\">package com.minis.jdbc.core;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\npublic interface ResultSetExtractor&lt;T&gt; {\n\tT extractData(ResultSet rs) throws SQLException;\n}\n</code></pre><p>利用上面的两个接口，我们来实现一个RowMapperResultSetExtractor。</p><pre><code class=\"language-plain\">package com.minis.jdbc.core;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class RowMapperResultSetExtractor&lt;T&gt; implements ResultSetExtractor&lt;List&lt;T&gt;&gt; {\n\tprivate final RowMapper&lt;T&gt; rowMapper;\n\n\tpublic RowMapperResultSetExtractor(RowMapper&lt;T&gt; rowMapper) {\n\t\tthis.rowMapper = rowMapper;\n\t}\n\n\t@Override\n\tpublic List&lt;T&gt; extractData(ResultSet rs) throws SQLException {\n\t\tList&lt;T&gt; results = new ArrayList&lt;&gt;();\n\t\tint rowNum = 0;\n        //对结果集，循环调用mapRow进行数据记录映射\n\t\twhile (rs.next()) {\n\t\t\tresults.add(this.rowMapper.mapRow(rs, rowNum++));\n\t\t}\n\t\treturn results;\n\t}\n}\n</code></pre><p>这样，SQL语句返回的数据集就自动映射成对象列表了。我们看到，实际的数据映射工作其实不是我们实现的，而是由RowMapper实现的，这个RowMapper既是作为一个参数又是作为一个用户程序传进去的。这很合理，因为确实只有用户程序自己知道自己的数据要如何映射。</p><p>好，有了这个工具，我们可以提供一个新的query()方法来返回SQL语句的结果集，代码如下：</p><pre><code class=\"language-plain\">\tpublic &lt;T&gt; List&lt;T&gt; query(String sql, Object[] args, RowMapper&lt;T&gt; rowMapper) {\n\t\tRowMapperResultSetExtractor&lt;T&gt; resultExtractor = new RowMapperResultSetExtractor&lt;&gt;(rowMapper);\n\t\tConnection con = null;\n\t\tPreparedStatement pstmt = null;\n\t\tResultSet rs = null;\n\t\t\n\t\ttry {\n            //建立数据库连接\n\t\t\tcon = dataSource.getConnection();\n\n            //准备SQL命令语句\n\t\t\tpstmt = con.prepareStatement(sql);\n            //设置参数\n\t\t\tArgumentPreparedStatementSetter argumentSetter = new ArgumentPreparedStatementSetter(args);\t\n\t\t\targumentSetter.setValues(pstmt);\n            //执行语句\n\t\t\trs = pstmt.executeQuery();\n\t\t\t\n            //数据库结果集映射为对象列表，返回\n\t\t\treturn resultExtractor.extractData(rs);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tpstmt.close();\n\t\t\t\tcon.close();\n\t\t\t} catch (Exception e) {\t\t\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n</code></pre><p>那么上层应用程序的service层要改成这样：</p><pre><code class=\"language-plain\">\tpublic List&lt;User&gt; getUsers(int userid) {\n\t\tfinal String sql = \"select id, name,birthday from users where id&gt;?\";\n\t\treturn (List&lt;User&gt;)jdbcTemplate.query(sql, new Object[]{new Integer(userid)},\n\t\t\t\tnew RowMapper&lt;User&gt;(){\n\t\t\t\t\tpublic User mapRow(ResultSet rs, int i) throws SQLException {\n\t\t\t\t\t\tUser rtnUser = new User();\n\t\t\t\t\t\trtnUser.setId(rs.getInt(\"id\"));\n\t\t\t\t\t\trtnUser.setName(rs.getString(\"name\"));\n\t\t\t\t\t\trtnUser.setBirthday(new java.util.Date(rs.getDate(\"birthday\").getTime()));\n\t\t\n\t\t\t\t\t\treturn rtnUser;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n</code></pre><p>service程序里面执行SQL语句，直接按照数据记录的字段的mapping关系，返回一个对象列表。这样，到此为止，MiniSpring的JdbcTemplate就可以提供3种query()方法了。</p><ol>\n<li>public Object query(StatementCallback stmtcallback) {}</li>\n<li>public Object query(String sql, Object[] args, PreparedStatementCallback pstmtcallback) {}</li>\n<li>public <t> List<t> query(String sql, Object[] args, RowMapper<t> rowMapper){}</t></t></t></li>\n</ol><p>实际上我们还可以提供更多的工具，你可以举一反三思考一下应该怎么做，这里我就不多说了。</p><h2>数据库连接池</h2><p>到现在这一步，我们的MiniSpring仍然是在执行SQL语句的时候，去新建数据库连接，使用完之后就释放掉了。我们知道，数据库连接的建立和释放，是很费资源和时间的。所以这个方案不是最优的，那怎样才能解决这个问题呢？有一个方案可以试一试，那就是<strong>池化技术</strong>。提前在一个池子里预制多个数据库连接，在应用程序来访问的时候，就给它一个，用完之后再收回到池子中，整个过程中数据库连接一直保持不关闭，这样就大大提升了性能。</p><p>所以我们需要改造一下原有的数据库连接，不把它真正关闭，而是设置一个可用不可用的标志。我们用一个新的类，叫PooledConnection，来实现Connetion接口，里面包含了一个普通的Connection，然后用一个标志Active表示是否可用，并且永不关闭。</p><pre><code class=\"language-plain\">package com.minis.jdbc.pool;\npublic class PooledConnection implements Connection{\n\tprivate Connection connection;\n\tprivate boolean active;\n\t\n\tpublic PooledConnection() {\t\n\t}\n\tpublic PooledConnection(Connection connection, boolean active) {\n\t\tthis.connection = connection;\n\t\tthis.active = active;\n\t}\n\t\n\tpublic Connection getConnection() {\n\t\treturn connection;\n\t}\n\tpublic void setConnection(Connection connection) {\n\t\tthis.connection = connection;\n\t}\n\tpublic boolean isActive() {\n\t\treturn active;\n\t}\n\tpublic void setActive(boolean active) {\n\t\tthis.active = active;\n\t}\n\tpublic void close() throws SQLException {\n\t\tthis.active = false;\n\t}\n\t@Override\n\tpublic PreparedStatement prepareStatement(String sql) throws SQLException {\n\t\treturn this.connection.prepareStatement(sql);\n\t}\n}\t\n</code></pre><p>实际代码很长，因为要实现JDBC Connection接口里所有的方法，你可以参考上面的示例代码，别的可以都留空。</p><p>最主要的，我们要注意close()方法，它其实不会关闭连接，只是把这个标志设置为false。</p><p>基于上面的PooledConnection，我们把原有的DataSource改成PooledDataSource。首先在初始化的时候，就激活所有的数据库连接。</p><pre><code class=\"language-plain\">package com.minis.jdbc.pool;\n\npublic class PooledDataSource implements DataSource{\n\tprivate List&lt;PooledConnection&gt; connections = null;\n\tprivate String driverClassName;\n\tprivate String url;\n\tprivate String username;\n\tprivate String password;\n\tprivate int initialSize = 2;\n\tprivate Properties connectionProperties;\t\n\t\t\n\tprivate void initPool() {\n\t\tthis.connections = new ArrayList&lt;&gt;(initialSize);\n\t\tfor(int i = 0; i &lt; initialSize; i++){\n\t\t\tConnection connect = DriverManager.getConnection(url, username, password);\n\t\t\tPooledConnection pooledConnection = new PooledConnection(connect, false);\n\t\t\tthis.connections.add(pooledConnection);\n\t\t}\n\t}\n}\n</code></pre><p>获取数据库连接的代码如下：</p><pre><code class=\"language-plain\">\tPooledConnection pooledConnection= getAvailableConnection();\n\twhile(pooledConnection == null){\n\t\tpooledConnection = getAvailableConnection();\n\t\tif(pooledConnection == null){\n\t\t\ttry {\n\t\t\t\tTimeUnit.MILLISECONDS.sleep(30);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\t\t\n  &nbsp; return pooledConnection;\n</code></pre><p>可以看出，我们的策略是死等这一个有效的连接。而获取有效连接的代码如下：</p><pre><code class=\"language-plain\">\tprivate PooledConnection getAvailableConnection() throws SQLException{\n\t\tfor(PooledConnection pooledConnection : this.connections){\n\t\t\tif (!pooledConnection.isActive()){\n\t\t\t\tpooledConnection.setActive(true);\n\t\t\t\treturn pooledConnection;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n</code></pre><p>通过代码可以知道，其实它就是拿一个空闲标志的数据库连接来返回。逻辑上这样是可以的，但是，这段代码就会有一个并发问题，多线程的时候不好用，需要改造一下才能适应多线程环境。我们注意到这个池子用的是一个简单的ArrayList，这个默认是不同步的，我们需要手工来做同步，比如使用Collections.synchronizedList()，或者用两个LinkedBlockingQueue，一个用于active连接，一个用于inactive连接。</p><p>同样，对DataSource里数据库的相关信息，可以通过配置来注入的。</p><pre><code class=\"language-plain\">&lt;bean id=\"dataSource\" class=\"com.minis.jdbc.pool.PooledDataSource\"&gt;&nbsp;&nbsp;\n&nbsp; &nbsp; &lt;property name=\"url\" value=\"jdbc:sqlserver://localhost:1433;databasename=DEMO\"/&gt;&nbsp;&nbsp;\n&nbsp; &nbsp; &lt;property name=\"driverClassName\" value=\"com.microsoft.sqlserver.jdbc.SQLServerDriver\"/&gt;&nbsp;&nbsp;\n&nbsp; &nbsp; &lt;property name=\"username\" value=\"sa\"/&gt;&nbsp;&nbsp;\n&nbsp; &nbsp; &lt;property name=\"password\" value=\"Sql2016\"/&gt;&nbsp;&nbsp;\n&nbsp; &nbsp; &lt;property type=\"int\" name=\"initialSize\" value=\"3\"/&gt;&nbsp;&nbsp;\n&lt;/bean&gt;\n</code></pre><p>整个程序的结构实际上没有什么改动，只是将DataSource的实现变成了支持连接池的实现。从这里也可以看出，独立抽取部件、解耦这些手段给程序结构带来了极大的灵活性。</p><h2>小结</h2><p>我们这节课，在已有的JdbcTemplate基础之上，仍然按照专门的事情交给专门的部件来做的思路，一步步拆解。</p><p>我们把SQL语句参数的处理独立成一个ArgumentPreparedStatementSetter，由它来负责参数的传入。之后对返回结果，我们提供了RowMapper和RowMapperResultSetExtractor，将数据库记录集转换成一个对象的列表，便利了上层应用程序。最后考虑到性能，我们还引入了一个简单的数据库连接池。在这一步步地拆解过程中，JdbcTemplate这个工具越来越完整、便利了。</p><p>完整源代码参见 <a href=\"https://github.com/YaleGuo/minis\">https://github.com/YaleGuo/minis</a>。</p><h2>课后题</h2><p>学完这节课的内容，我也给你留一道思考题。你想一想我们应该怎么改造数据库连接池，保证多线程安全？欢迎你在留言区与我交流讨论，也欢迎你把这节课分享给需要的朋友。我们下节课见！</p>","comments":[{"had_liked":false,"id":372595,"user_name":"马儿","can_delete":false,"product_type":"c1","uid":2247080,"ip_address":"四川","ucode":"542E23D7B6AB01","user_header":"","comment_is_top":false,"comment_ctime":1681319683,"is_pvip":false,"replies":[{"id":136010,"content":"后面有再回首章节，里面给出了参考方案，你看一下。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1681382749,"ip_address":"澳大利亚","comment_id":372595,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"1. initialPool在第一次getConnection的时候初始化，那么就会存在线程安全问题，可以在方法上粗暴的加一个synchronized并在方法中初始化前提前判断是否为空，这样就可以防止连接池中的connections被多次初始化。\n2. 获取连接的时候在没有设置active为true之前两个获取连接的线程同时通过了isActive的判断导致两个线程获取到了同一个链接。这里也可以用synchronized来修饰isActive和setActive两个方法，保证一次只有一个线程访问其中的一个方法，不会有两个线程同时访问。并且，对于多核机器来说线程A可能更新完active字段就释放锁了，但是更新后的值还存在自己线程所在的cpu高速缓存中还没有写回到内存，导致线程B读到的还是内存中旧的active值，所以可以再用volatile保证active值修改后马上写回内存并且别的线程也只能从内存读取。\n\n当然，也可以active字段换成线程安全的AtomicBoolean类。\n\n以上是自己的一些思考，请老师指正一下~","like_count":1,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":613540,"discussion_content":"后面有再回首章节，里面给出了参考方案，你看一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681382749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3866578,"avatar":"https://static001.geekbang.org/account/avatar/00/3a/ff/d2/c1f5334d.jpg","nickname":"dirtychill","note":"","ucode":"4D3172C60E522A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":646457,"discussion_content":"可以在dataSource构造函数里init","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1718013927,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":374628,"user_name":"风轻扬","can_delete":false,"product_type":"c1","uid":1542987,"ip_address":"北京","ucode":"DB972F2DF059C4","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/15ab499a.jpg","comment_is_top":false,"comment_ctime":1684240672,"is_pvip":false,"replies":[{"id":136758,"content":"这是面向接口编程，可以有不同实现，在Spring中其实就不只有一个extractor，只是MiniSpring中仅仅实现了一种。Spring中用了一个内部类QueryStatementCallback，接收ResultSetExtractor接口，在里面回调rse.extractData(rs)。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1684453336,"ip_address":"澳大利亚","comment_id":374628,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"老师，请教一个问题。query方法中，实例化了一个RowMapperResultSetExtractor，直接用的实现类，没有用接口。而且，我想了一下，也不能用接口，因为Extractor接口里的方法extractData，返回值泛型是Object类型，没办法处理List类型。所以只能是返回list时，new出处理List的Extractor，返回object时，new出处理单对象的Extractor。有点不明白，定义Extractor接口的作用是什么？","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":618692,"discussion_content":"这是面向接口编程，可以有不同实现，在Spring中其实就不只有一个extractor，只是MiniSpring中仅仅实现了一种。Spring中用了一个内部类QueryStatementCallback，接收ResultSetExtractor接口，在里面回调rse.extractData(rs)。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1684453336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":372596,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1681342180,"is_pvip":false,"replies":[{"id":136014,"content":"pool size与具体场景有关，看并发中需要访问数据库的连接数。我看到几个中等规模的系统(10000人以内)，并发量大约是1000-2000，设置的数据库连接池是100-200.\n连接池不绑死数据库系统，数据库系统是由driver来支持的。使用Tomcat的话，里面就有很好的连接池。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1681434537,"ip_address":"澳大利亚","comment_id":372596,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"请教老师几个问题：\nQ1：数据库连接池一般设置多大？连接池大小一般是怎么计算的？\nQ2：数据库连接池与特定的数据库绑定吗？ 比如某个连接池可以连接mysql，能连接其他数据库吗？\nQ3：常见的数据库连接池有哪些？\nQ4：数据库连接池与高并发有什么关系？","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":613626,"discussion_content":"pool size与具体场景有关，看并发中需要访问数据库的连接数。我看到几个中等规模的系统(10000人以内)，并发量大约是1000-2000，设置的数据库连接池是100-200.\n连接池不绑死数据库系统，数据库系统是由driver来支持的。使用Tomcat的话，里面就有很好的连接池。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681434537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}