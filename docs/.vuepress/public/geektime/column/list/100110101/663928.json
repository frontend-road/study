{"id":663928,"title":"34｜升级收益：这两年React Native都做了哪些升级？","content":"<p>你好，我是蒋宏伟。这节课我们来聊聊 React Native 的近况。</p><p>经常有朋友问我，现阶段 React Native 的发展如何？新架构是否真的可用？我是否应该对我的业务进行升级？</p><p>今天，我们就来迅速了解下，在过去的两年中 React Native 都做了哪些改进。</p><h2>新架构</h2><p>众所周知，React Native团队在2018年时提出了新架构的设想，2022年开始发布新架构的预览版。又一年过去了，我们先来看看新架构的进展如何。</p><p>去年，新架构的预览版刚推出时，社区发布了 4 篇帖子，比较了新架构和旧架构的性能。一些人测试了ScrollView组件的渲染性能，有些人则测试了View、Text组件，还有人对比了 FlatList 和 ScrollView 场景下的渲染性能。得出的结论是：<strong>虽然新架构在某些场景下有优势，但在更多的场景中新架构的性能却下降了。</strong></p><p>例如，一位社区成员在他的帖子中测试了FlatList（Virtualized）和ScrollView（Non Virtualized）组件，以及渲染导航组件和View组件的性能。</p><p>在ScrollView场景下，所有的组件都会被渲染出来，此时新架构的性能明显不如旧架构。而在FlatList 场景下，只有可视区附近的组件会被渲染出来，这时新架构的导航组件渲染性能优于旧架构，但View组件的渲染性能却弱于旧架构。</p><!-- [[[read_end]]] --><p>测试数据如下：</p><ul>\n<li>ScrollView (毫秒)</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/ef/e0/ef1a0f52b49b3d0b7de756a6e65c5de0.jpg?wh=1604x938\" alt=\"图片\"></p><ul>\n<li>FlatList (毫秒)</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/66/c1/66356cd1436c0dd7c5730c43f1a2bec1.jpg?wh=1596x922\" alt=\"图片\"></p><p>好在，官方已经注意到了新架构预览版的性能问题，目前已经推出了0.72 RC版本，对上述的性能问题进行了修复。性能问题的主要原因竟然是官方忘记了关闭C++层的Debug开关。此外，官方还对Text组件的操作进行了简化。</p><p>优化后，官方通过在ScrollView组件中大量渲染View、Text或Image组件（1500或5000个），以测试新架构的性能。根据官方给出的性能测试报告，Android的渲染性能提升了0%～8%，而iOS的提升更为明显，达到了13%～39%。</p><p>至此，新架构的性能在各方面都超越了旧架构。</p><ul>\n<li>Google Pixel 4</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/a8/0c/a803b472b1dd4179e006dc4f0701da0c.jpg?wh=1594x828\" alt=\"图片\"></p><ul>\n<li>iPhone 12 Pro</li>\n</ul><h2><img src=\"https://static001.geekbang.org/resource/image/7d/c9/7d5b38441563a9350e6c9a629dff95c9.jpg?wh=1600x842\" alt=\"图片\"></h2><h2>Hermes</h2><p>在过去的两年中，React Native 进行的另外一次重大升级是，Hermes 成为了默认 JavaScript 引擎。</p><p>Hermes 是一款专为 React Native 打造的轻量级 JavaScript 引擎。2019 年，0.60 版本时，Facebook 首次将 Hermes 引擎集成到了 React Native Android 中。到了 2021 年，0.64 版本的 React Native iOS 也开始支持手动启用 Hermes 引擎。而在 2022 年，从 0.70 版本开始，Hermes 替代了 JavaScript Core，正式成为了 React Native 的默认引擎。</p><p>另外，已经有更多的开发者开始选择 Hermes 引擎。根据 Expo 公开的数据，到 2023 年 3 月，在其平台上，使用 Hermes 引擎构建的项目数量已经超过了使用 JavaScript Core 引擎的数量。因此，Expo 强烈建议 React Native 开发者和 Expo SDK 的用户们都切换到 Hermes 引擎，以便享受到 Hermes 引擎带来的诸多优势，如改进的调试体验，特别是性能改善。</p><p><img src=\"https://static001.geekbang.org/resource/image/50/c4/50f0be54198d1bec4aa7692f53c9cbc4.png?wh=1502x1303\" alt=\"图片\"></p><p>Hermes 在设计之初，目标是优化在低端设备上运行的 React Native 应用的性能，为了实现这个目标，它采用了一种预编译策略。</p><p>在传统的 JavaScript 引擎，如 JavaScriptCore 中，JavaScript 代码在运行时会经历以下几个阶段。</p><ol>\n<li><strong>解析阶段</strong>：在这个阶段，JavaScript 源代码被解析为一个抽象语法树（AST）。AST 是源代码的树状表示形式，其中每个节点代表代码中的一种结构，如函数、变量声明或表达式。</li>\n<li><strong>编译阶段</strong>：在这个阶段，AST 被转换成字节码，这是一种低级的、与平台无关的代码。这些字节码可以被 JavaScript 引擎直接执行。</li>\n<li><strong>优化阶段</strong>：在这个阶段，JavaScript 引擎可能会对字节码进行进一步的优化，以提高运行时性能。例如，引擎可能会使用即时（JIT）编译器将频繁执行的字节码片段编译成机器代码，以减少解释字节码的开销。</li>\n</ol><p>然而，Hermes 引擎可以将解析和编译的操作提前到构建阶段，当你构建你的 React Native 应用时，它已经完成了解析和编译的过程，并直接生成了字节码。因此，运行时只需要执行字节码，大大节省了解析和编译的时间。</p><p><strong>那么Hermes究竟快多少呢？</strong></p><p>在启动性能上，使用字节码技术的 Hermes 明显优于 JavaScriptCore。根据 CallStack 团队在 2021 年公开的实测数据，对于冷启动的可交互时间（TTI），在三款不同的 iOS 机型上，Hermes 比 JavaScriptCore 快了 36%～40%。我们的团队在今年也进行了类似的启动时间性能测试，结果显示，iOS 和 Android 的性能分别提升了 50% 和 48%。</p><p><img src=\"https://static001.geekbang.org/resource/image/dd/02/dd4425ddf22a9f71ee4b7ab8072fbf02.jpg?wh=1600x842\" alt=\"图片\"></p><p>不过，尽管 Hermes 引擎带来了显著的性能提升，但在 iOS 上启用它需要谨慎。</p><p>国内的 React Native 应用普遍配备了热更新技术，然而热更新与 Hermes 的字节码技术并不兼容。值得注意的是，根据 Apple 的政策，Apple 明确规定只允许使用 JavaScriptCore 引擎动态执行脚本，使用 Hermes 引擎动态执行字节码可能会导致违规。因此，<strong>我并不推荐你在 iOS 上使用 Hermes 进行热更新。</strong></p><p>我更推荐的做法是，在 Android 上使用 Hermes，并开启字节码。而在 iOS 上继续使用 JavaScriptCore。这样也能从 Hermes 引擎带来的性能优化中获益。</p><h2>FlashList</h2><p>FlatList 是 React Native 提供的默认列表组件，然而，这个组件在众多设备上常常遭遇性能问题。在<a href=\"https://time.geekbang.org/column/article/506825\">第 08 讲</a>中，我推荐了一款替代组件——RecyclerListView。近两年来，RecyclerListView 的作者加入了 Shopify，并在原有的 RecyclerListView 基础上，打造了一个更易用的组件，名为 <a href=\"https://shopify.github.io/flash-list/docs/usage\">FlashList</a>。</p><p>过去，我向你解释过 RecyclerListView 的工作原理，其基本思路是通过调整 Absolute 布局元素的 Top 位置值，实现元素复用。然而，要确定每个列表项 Item 的 Top 位置值，就必须先知道每个 Item 的 Height 值。因此，开发者需要手动创建一个 LayoutProvider 类，该类需要对 Item 进行分类，并为每一类 Item 设置固定高度。</p><p>开发者需要定义一个 LayoutProvider 类，代码示例如下：</p><pre><code class=\"language-plain\">const _layoutProvider = new LayoutProvider(\n  index =&gt; {\n    if (index % 3 === 0) {\n      return ViewTypes.FULL;\n    } else {\n      return ViewTypes.HALF_RIGHT;\n    }\n  },\n  (type, dimension) =&gt; {\n    switch (type) {\n      case ViewTypes.HALF_RIGHT:\n        dimension.width = width / 2;\n        dimension.height = 160;\n        break;\n      case ViewTypes.FULL:\n        dimension.width = width;\n        dimension.height = 140;\n        break;\n    }\n  },\n);\n</code></pre><p>这样虽然解决了问题，但实际上开发过的同学都痛苦不已。对于复杂的业务需求，Item 类型太多了，文字高度也不固定。而且一旦计算错误，要定位是哪个 Item 导致的问题，是十分困难的。</p><p>而 FlashList 只通过一个简单的参数 estimatedItemSize 就解决了这个问题。FlashList 的示例代码如下：</p><pre><code class=\"language-plain\">import React from \"react\";\nimport { View, Text, StatusBar } from \"react-native\";\nimport { FlashList } from \"@shopify/flash-list\";\n\nconst DATA = [\n  {\n    title: \"First Item\",\n  },\n  {\n    title: \"Second Item\",\n  },\n];\n\nconst MyList = () =&gt; {\n  return (\n    &lt;FlashList\n      data={DATA}\n      renderItem={({ item }) =&gt; &lt;Text&gt;{item.title}&lt;/Text&gt;}\n      estimatedItemSize={200}\n    /&gt;\n  );\n};\n</code></pre><p>那 FlashList 是如何做到的呢？</p><p><strong>是渲染两次，不过是直接在 Native 层渲染两次。</strong></p><p>前面我们提到，要计算每个列表项 Item 的 Top 位置值，就必须知道每个 Item 的 Height 值。FlashList 第一次渲染时，在 Native 层，通过预估的 Item Height 值，也就是 estimatedItemSize，计算出每个列表项预估的 Top 值，进行渲染。渲染后，获取真实的 Item Height 值，再计算出实际的 Top 值，然后再渲染一次。</p><p>由于两次渲染之间没有 JS 与 Native 的通信，是直接发生在 Native 层的，速度非常快，正常看是看不出抖动的。</p><p>RecyclerListView 是纯 JS 代码，FlashList 在 RecyclerListView 之上借助了 Native 代码，借助两次快速渲染（如果无需高度修正就是一次渲染），实现了自动布局。</p><p>理论上，一次渲染的性能必然大于两次渲染。即便 FlashList 是直接在 Native 层渲染两次，它依旧是多了一次渲染的消耗。因此，如果你能正确地给出每个 Item 的 Height 值，就不要粗略地估计一个 estimatedItemSize 值，然后让 FlashList 帮你去自动纠正。通过二次渲染进行布局纠正，肯定是有性能损耗的。</p><p>在性能达标的前提下，列表 Item 有文字内容，其高度是动态，计算高度非常复杂，那么<strong>让 FlashList 帮你自动去计算布局，也不失为一种好的策略</strong>。这能很大程度地节约开发成本。</p><p>性能上，官方未给出 FlashList 和 RecyclerListView 的性能对比，给出的是 FlashList 和 FlatList 的性能对比，也就是 Shopify 团队提供的 List 组件和 React Native 默认的 List 组件的性能对比。在 Twitter 场景下，整体上 FlatList 只拿到了 39 分，而 FlashList 拿到了 89 分。</p><p>从性能截图中也可以看出，FlatList 的 UI FPS 帧率绝大部分时间保持在 55 帧率以下，而 FlashList 绝大部分时间保持在 55 帧率以上。</p><p><img src=\"https://static001.geekbang.org/resource/image/a7/1c/a7ef03f9938fcedd020c8ae1b321141c.png?wh=1486x708\" alt=\"图片\"></p><h2>总结</h2><p>近两年，新架构预览版的推出和默认引擎 Hermes 的应用，无疑是亮点，这两项技术从根本上为 React Native 带来了显著的性能提升。</p><p>在生态方面，FlashList 组件的推出显著降低了高性能列表组件的开发成本。FlashList 的使用方式与 FlatList 组件相似，因此从 FlatList 迁移到 FlashList 的成本极低，同时可以显著提升 FPS 方面的性能。</p><p>FlashList 不依赖特定版本，只要你能使用，就直接上手吧。至于 Hermes 的字节码技术，你可以在 Android 平台上先行使用，但如果在 iOS 上使用热更新，还是建议放弃，因为下架的风险实在太大。至于新架构，你可以尝试使用，但如果想大规模推广，最好等到正式版发布后再开始。</p><h2>思考题</h2><p>这两年，你还观察到了 React Native 的哪些重要升级？</p><p>欢迎在留言区分享你的看法、交流学习心得或者提出问题，如果觉得有收获，也期待你把今天的内容分享给更多的朋友！</p>","comments":[{"had_liked":false,"id":380681,"user_name":"Geek_accfac","can_delete":false,"product_type":"c1","uid":2562844,"ip_address":"北京","ucode":"EEC233DF92FB92","user_header":"","comment_is_top":false,"comment_ctime":1693985356,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100110101,"comment_content":"您好，请问58同城的APP现在使用是0.72版本吗？还是旧版本没有开启hermes呢","like_count":0},{"had_liked":false,"id":375740,"user_name":"大大小小","can_delete":false,"product_type":"c1","uid":2178133,"ip_address":"广东","ucode":"8A21DC629A24F5","user_header":"https://static001.geekbang.org/account/avatar/00/21/3c/55/74844d08.jpg","comment_is_top":false,"comment_ctime":1685935770,"is_pvip":false,"replies":null,"discussion_count":2,"race_medal":0,"score":2,"product_id":100110101,"comment_content":"请问目前最新的0.71.8的性能也有问题吗？需要更新到0.72 RC版本，性能才会提升？\n","like_count":0,"discussions":[{"author":{"id":1088541,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/1d/f0f10198.jpg","nickname":"蒋宏伟","note":"","ucode":"02226CABD5ECE7","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":620226,"discussion_content":"是的。0.72 RC 之前开启新架构有问题，不开启新架构没有问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1685963330,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2178133,"avatar":"https://static001.geekbang.org/account/avatar/00/21/3c/55/74844d08.jpg","nickname":"大大小小","note":"","ucode":"8A21DC629A24F5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1088541,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/1d/f0f10198.jpg","nickname":"蒋宏伟","note":"","ucode":"02226CABD5ECE7","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":620300,"discussion_content":"感谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1686036951,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":620226,"ip_address":"广东","group_id":0},"score":620300,"extra":""}]}]},{"had_liked":false,"id":375735,"user_name":"大大小小","can_delete":false,"product_type":"c1","uid":2178133,"ip_address":"广东","ucode":"8A21DC629A24F5","user_header":"https://static001.geekbang.org/account/avatar/00/21/3c/55/74844d08.jpg","comment_is_top":false,"comment_ctime":1685933610,"is_pvip":false,"replies":null,"discussion_count":2,"race_medal":0,"score":2,"product_id":100110101,"comment_content":"关于Hermes的使用，Android和iOS如何使用可以展开详细说下吗？\n有几个疑问？iOS不使用Hermes，是整个项目不使用Hermes吗？那我如果是用最新的0.71.8版本的工程，如何关闭Hermes引擎？另外关于iOS的热更新，所谓的与Hermes字节码不兼容是什么意思，expo的热更新不是使用Hermes吗？","like_count":0,"discussions":[{"author":{"id":1088541,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/1d/f0f10198.jpg","nickname":"蒋宏伟","note":"","ucode":"02226CABD5ECE7","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":620227,"discussion_content":"使用 Hermes 热更新存在风险，因此不建议使用 Hermes 进行热更新。\n但如果 Expo 已经大规模上线了，并且没有遇到封禁情况，可以试试，过不过都是苹果说了算。\n\n\n苹果条款原文如下：\n\n4.7 HTML5 游戏与聊天机器人 (Bot) 等\n**App 可包含或运行未嵌入二进制文件的代码 **(如基于 HTML5 的游戏和聊天机器人等)，前提是 App 的主要目的并非代码分发，代码亦没有在商店界面或类似商店的界面中提供，而且相关软件遵循 4.7.1 和 4.7.2 中所述的额外规则。这些额外规则对保持 App Store 用户所期待的体验和帮助确保用户安全来说非常重要。\n4.7.1 根据此规则提供的软件必须符合以下条件：\n仅使用标准 WebKit 视图中提供的功能 (例如，它必须能在 Safari 浏览器中原生打开及运行，而无需修改或借助其他软件)；**使用 WebKit 和 JavaScript Core 来运行第三方软件**，并不得试图扩展或披露原生平台 API 给第三方软件；\n\n备注：App 可包含或运行未嵌入二进制文件的代码的情况之一就是 RN。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1685966131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"伊朗","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2178133,"avatar":"https://static001.geekbang.org/account/avatar/00/21/3c/55/74844d08.jpg","nickname":"大大小小","note":"","ucode":"8A21DC629A24F5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1088541,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/1d/f0f10198.jpg","nickname":"蒋宏伟","note":"","ucode":"02226CABD5ECE7","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":620301,"discussion_content":"感谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1686036973,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":620227,"ip_address":"广东","group_id":0},"score":620301,"extra":""}]}]}]}