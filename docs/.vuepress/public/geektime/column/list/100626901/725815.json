{"id":725815,"title":"12｜智能指针：从所有权看智能指针","content":"<p>你好，我是Mike。从今天开始，我们进入Rust进阶篇。</p><p>相对于基础篇，进阶篇更像外功招式，主要是掌握一些实用的基础设施，提高编程效率。这节课我们就在所有权视角下来学习Rust中的智能指针。</p><h2>智能指针</h2><p>学习智能指针之前，我们先来了解一下指针是什么。</p><h3>指针和指针的类型</h3><p>如果一个变量，里面存的是另一个变量在内存里的地址值，那么这个变量就被叫做<strong>指针</strong>。而我们前面讲到的引用（用&amp;号表示）就是一种指针。</p><p><strong>引用是必定有效的指针</strong>，它一定指向一个目前有效（比如没有被释放掉）的类型实例。而指针不一定是引用。也就是说，在Rust中，还有一些其他类型的指针存在，我们这节课就来学习其中一些。</p><p>我们这里要再次明晰一下<strong>引用的类型</strong>。引用分为不同的类型，单独的&amp;符号本身没有什么意义，但是它和其他类型组合起来就能形成各种各样的引用类型。比如：</p><ul>\n<li>&amp;str 是字符串切片引用类型。</li>\n<li>&amp;String 是所有权字符串的引用类型。</li>\n<li>&amp;u32 是u32的引用类型。</li>\n</ul><p><span class=\"reference\">注：&amp;str、&amp;String、&amp;u32都是一个整体。</span></p><p>这三种都是引用类型，作为引用类型，它们之间是不同的。但是同一种引用类型的实例，比如 &amp;10u32和&amp;20u32，它们的类型是相同的。</p><p>那么，指针其实也类似，指向不同类型实例的指针，它的类型也是有区别的，这叫做<strong>指针的类型</strong>。</p><!-- [[[read_end]]] --><h3>智能指针</h3><p>Rust中指针的概念非常灵活，比如，它可以是一个结构体类型，只要其中的一个字段存储其他类型实例的地址，然后对这个结构体实现一些Rust标准库里提供的trait，就可以把它变成指针类型。这种指针可以在传统指针的基础上添加一些额外信息，比如放在额外的一些字段中；也可以做一些额外操作，比如管理引用计数，资源自动回收等。从而显得更加智能，所以被叫做<strong>智能指针</strong>。</p><p>其实，我们前面碰到的 String 和 <code>Vec&lt;T&gt;</code> 就是一种智能指针。我们来看标准库代码中 <a href=\"https://doc.rust-lang.org/src/alloc/string.rs.html#365\">String</a>  的定义和 <a href=\"https://doc.rust-lang.org/src/alloc/vec/mod.rs.html#396\"><code>Vec&lt;T&gt;</code></a> 的定义。</p><pre><code class=\"language-plain\">pub struct String {\n    vec: Vec&lt;u8&gt;,\n}\n</code></pre><pre><code class=\"language-plain\">pub struct Vec&lt;T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global&gt; {\n    buf: RawVec&lt;T, A&gt;,\n    len: usize,\n}\n</code></pre><p>通过代码我们可以看到，String和 <code>Vec&lt;T&gt;</code> 实际都定义为结构体。</p><p><span class=\"reference\">注：Rust中智能指针的概念也直接来自于C++。C++里面有</span><a href=\"https://en.cppreference.com/w/cpp/memory/unique_ptr\">unique_ptr</a><span class=\"reference\">、</span><a href=\"https://en.cppreference.com/w/cpp/memory/shared_ptr\">shared_ptr</a><span class=\"reference\">。</span></p><p>智能指针可以让代码的开发相对来说容易一些。经过前面的学习，我们知道Rust基于所有权出发，定义了一套完整的所有权和借用规则。很多我们习以为常的代码写法，在Rust中变成了“违法”，这导致很多人觉得学习Rust的门槛很高。而智能指针可以在某些方面降低这种门槛。</p><p>它如何能做到呢？我们稍后揭秘。</p><p>前面我们看到过这种代码：</p><pre><code class=\"language-plain\">fn foo() -&gt; u32 {\n&nbsp; &nbsp; let i = 100u32;\n&nbsp; &nbsp; i\n}\nfn main() {\n&nbsp; &nbsp; let _i = foo();\n}\n</code></pre><p>我们看到，<code>foo()</code> 函数将i返回用的不是move行为，而是copy行为，将100u32这个值复制了一份，返回给外面的_i。<code>foo()</code> 函数调用结束后，<code>foo()</code> 里的局部变量i被销毁。</p><p>我们再回忆一下另一段代码。</p><pre><code class=\"language-plain\">fn foo() -&gt; String {\n&nbsp; &nbsp; let s = \"abc\".to_string();\n&nbsp; &nbsp; s\n}\nfn main() {\n&nbsp; &nbsp; let _s = foo();\n}\n</code></pre><p>上述代码可以在函数 <code>foo()</code> 里生成一个字符串实例，这个字符串实例资源在堆内存中分配，s是foo函数里的局部变量，拥有字符串资源的所有权。在代码的最后一行，s把所有权返回给外部调用者并传递给_s。<code>foo()</code> 调用完成后，栈上的局部变量s被销毁。</p><p>这种写法可行是因为返回了资源的所有权。如果我们把代码里的String换成&amp;String，把s换成&amp;s就不行了。</p><pre><code class=\"language-plain\">fn foo() -&gt; &amp;String {\n&nbsp; &nbsp; let s = \"abc\".to_string();\n&nbsp; &nbsp; &amp;s\n}\nfn main() {\n&nbsp; &nbsp; let _s = foo();\n}\n</code></pre><p>你可能会问，既然String资源本身是在堆中，为什么我们不能拿到这个资源的引用而返回呢？</p><p>我们来看看为什么不行。在 <code>foo()</code> 函数里，其实我们返回的并不是那个堆里字符串资源的引用，而是栈上局部变量s的引用。堆里的字符串资源由栈上的变量s管理，而s在 <code>foo()</code> 函数调用完成后，就被销毁了，堆里的字符串资源也一并被回收了，所以刚刚那段代码当然行不通了。</p><p>同样的，下面这段代码也是不允许的。</p><pre><code class=\"language-plain\">fn foo() -&gt; &amp;u32 {\n&nbsp; &nbsp; let i = 100u32;\n&nbsp; &nbsp; &amp;i\n}\nfn main() {\n&nbsp; &nbsp; let _i = foo();\n}\n</code></pre><p>那么，我们有什么办法能让这种意图变得可行呢？其实是有的，比如使用 <code>Box&lt;T&gt;</code> 智能指针。</p><h2><code>Box&lt;T&gt;</code></h2><p><code>Box&lt;T&gt;</code> 是一个类型整体，作为智能指针 <code>Box&lt;T&gt;</code> 可以把资源强行创建在堆上，并获得资源的所有权，让资源的生命期得以被程序员精确地控制。</p><p><span class=\"reference\">注：堆上的资源，默认与整个程序进程的存在时间一样久。</span></p><p>我们来看使用 <code>Box&lt;T&gt;</code> 如何处理前面那个示例。</p><pre><code class=\"language-plain\">fn foo() -&gt; Box&lt;u32&gt; {\n&nbsp; &nbsp; let i = 100u32;\n&nbsp; &nbsp; Box::new(i)\n}\nfn main() {\n&nbsp; &nbsp; let _i = foo();\n}\n</code></pre><p>通过Box，我们把栈上 i 的值，强行copy了一份并放在堆上某个地址，然后Box指针指向这个地址。</p><p>返回一个整数 i 的指针确实没多大用，如果我们定义了一个结构体，可以采用类似的办法从函数中返回结构体的Box指针。</p><pre><code class=\"language-plain\">struct Point {\n&nbsp; &nbsp; x: u32,\n&nbsp; &nbsp; y: u32\n}\n\nfn foo() -&gt; Box&lt;Point&gt; {\n&nbsp; &nbsp; let p = Point {x: 10, y: 20};  // 这个结构体的实例创建在栈上\n&nbsp; &nbsp; Box::new(p)\n}\nfn main() {\n&nbsp; &nbsp; let _p = foo();\n}\n</code></pre><p>这就很有用了。</p><p>我们看示例的第7行，Point 的实例 p 实际是创建在栈上的。通过 <code>Box::new(p)</code>，把p实例强行按位复制了一份，并且放到了堆上，我们记为 p’。然后 <code>foo()</code> 函数返回，把Box指针实例move给了_p。之后，_p拥有了对 p’ 的所有权。</p><h3><code>Box&lt;T&gt;</code> 中的所有权分析</h3><p>我们继续深入，回顾一下上面示例里讲到的，编译期间已知尺寸的类型实例会默认创建在栈上。Point有两个字段：x、y，它们的尺寸是固定的，都是4个字节，所以Point的尺寸就是8个字节，它的尺寸也是固定的。所以它的实例会被创建在栈上。第7行的 p 拥有这个Point实例的所有权。注意Point并没有默认实现Copy，虽然它的尺寸是固定的。</p><p>在创建 <code>Box&lt;Point&gt;</code> 实例的时候会发生所有权转移：资源从栈上move到了堆上，原来栈上的那片资源被置为无效状态，因此下面的代码编译不会通过。</p><pre><code class=\"language-plain\">struct Point {\n&nbsp; &nbsp; x: u32,\n&nbsp; &nbsp; y: u32\n}\n\nfn foo() -&gt; Box&lt;Point&gt; {\n&nbsp; &nbsp; let p = Point {x: 10, y: 20};&nbsp; &nbsp; \n&nbsp; &nbsp; let boxed = Box::new(p);  // 创建Box实例\n    let q = p;                // 这一句用来检查p有没有被move走\n    boxed\n}\nfn main() {\n&nbsp; &nbsp; let _p = foo();\n}\n</code></pre><p>编译提示：</p><pre><code class=\"language-plain\">error[E0382]: use of moved value: `p`\n&nbsp;--&gt; src/main.rs:9:13\n&nbsp; |\n7 |&nbsp; &nbsp; &nbsp;let p = Point {x: 10, y: 20};&nbsp; &nbsp;&nbsp;\n&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;- move occurs because `p` has type `Point`, which does not implement the `Copy` trait\n8 |&nbsp; &nbsp; &nbsp;let boxed = Box::new(p);&nbsp; &nbsp; &nbsp;// 创建Box实例\n&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - value moved here\n9 |&nbsp; &nbsp; &nbsp;let q = p;&nbsp; &nbsp; &nbsp; &nbsp; // 这一句用来检查p有没有被move走\n&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^ value used here after move\n</code></pre><p>之所以会发生所有权这样的转移，是因为 Point 类型本身就是 move 语义的。作为对照，我们来看一个示例。</p><pre><code class=\"language-plain\">fn foo() -&gt; Box&lt;u8&gt; {\n&nbsp; &nbsp; let i = 5;\n&nbsp; &nbsp; let boxed = Box::new(i);&nbsp; // 创建Box实例\n&nbsp; &nbsp; let q = i;&nbsp; &nbsp; &nbsp; &nbsp;         // 这一句用来检查i有没有被move走\n&nbsp; &nbsp; boxed\n}\n\nfn main() {\n&nbsp; &nbsp; let _i = foo();\n}\n</code></pre><p>这个示例就可以编译通过。也就是说，在执行 <code>Box::new()</code> 创建 Box 实例时，具有copy语义的整数类型和具有move语义的Point类型行为不一样。整数会copy一份自己，Point实例会把自己move到Box里面去。</p><p>一旦创建好Box实例后，这个实例就具有了对里面资源的所有权了，它是move语义的，你可以看一下示例。</p><pre><code class=\"language-plain\">fn foo() -&gt; Box&lt;u8&gt; {\n&nbsp; &nbsp; let i = 5;\n&nbsp; &nbsp; let boxed = Box::new(i);&nbsp; &nbsp; // 创建Box实例\n&nbsp; &nbsp; let q = i;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 这一句用来检查i有没有被move走\n&nbsp; &nbsp; let boxed2 = boxed;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 这一句检查boxed实例是不是move语义\n&nbsp; &nbsp; boxed\n}\n\nfn main() {\n&nbsp; &nbsp; let _i = foo();\n}\n</code></pre><p>不能编译通过，提示：</p><pre><code class=\"language-plain\">error[E0382]: use of moved value: `boxed`\n&nbsp;--&gt; src/main.rs:6:5\n&nbsp; |\n3 |&nbsp; &nbsp; &nbsp;let boxed = Box::new(i);&nbsp; &nbsp; // 创建Box实例\n&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;----- move occurs because `boxed` has type `Box&lt;u8&gt;`, which does not implement the `Copy` trait\n4 |&nbsp; &nbsp; &nbsp;let q = i;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 这一句用来检查i有没有被move走\n5 |&nbsp; &nbsp; &nbsp;let boxed2 = boxed;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 这一句检查boxed实例是不是move语义\n&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ----- value moved here\n6 |&nbsp; &nbsp; &nbsp;boxed\n&nbsp; |&nbsp; &nbsp; &nbsp;^^^^^ value used here after move\n</code></pre><p>这个示例就验证了我们刚才的说法。</p><h3><code>Box&lt;T&gt;</code> 的解引用</h3><p>前面我们讲过，创建一个Box实例把栈上的内容包起来，可以把栈上的值移动到堆上，比如：</p><pre><code class=\"language-plain\">let val: u8 = 5;\nlet boxed: Box&lt;u8&gt; = Box::new(val); // 这里 boxed 里面那个u8就是堆上的值 \n</code></pre><p>还可以在Box实例上使用<strong>解引用符号 </strong>*，把里面的堆上的值再次移动回栈上，比如：</p><pre><code class=\"language-plain\">let boxed: Box&lt;u8&gt; = Box::new(5);\nlet val: u8 = *boxed;    // 这里这个val整数实例就是在栈上的值\n</code></pre><p>解引用是 <code>Box::new()</code> 的<strong>逆操作</strong>，可以看到整个过程是相反的。</p><p>对于具有copy语义的u8类型来说，解引用回来后，boxed还能使用，我们看下示例。</p><pre><code class=\"language-plain\">fn main() {\n&nbsp; &nbsp; let boxed: Box&lt;u8&gt; = Box::new(5);\n&nbsp; &nbsp; let val: u8 = *boxed;\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; println!(\"{:?}\", val);\n&nbsp; &nbsp; println!(\"{:?}\", boxed);  // 用于u8类型，解引用后，boxed实例还能用\n}\n// 输出\n5\n5\n</code></pre><p>而对于具有move语义的类型来说，情况就不一样了，会发生所有权的转移。比如：</p><pre><code class=\"language-plain\">#[derive(Debug)]\nstruct Point {\n&nbsp; &nbsp; x: u32,\n&nbsp; &nbsp; y: u32\n}\n\nfn main() {\n&nbsp; &nbsp; let p = Point {x: 10, y: 20};\n&nbsp; &nbsp; let boxed: Box&lt;Point&gt; = Box::new(p);\n&nbsp; &nbsp; let val: Point = *boxed;  // 这里做了解引用，Point实例回到栈上\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; println!(\"{:?}\", val);\n&nbsp; &nbsp; println!(\"{:?}\", boxed);  // 解引用后想把boxed再打印出来\n}\n</code></pre><p>编译出错，提示 <code>*boxed</code> 已经 move了。</p><pre><code class=\"language-plain\">error[E0382]: borrow of moved value: `boxed`\n&nbsp; --&gt; src/main.rs:13:22\n&nbsp; &nbsp;|\n10 |&nbsp; &nbsp; &nbsp;let val: Point = *boxed;\n&nbsp; &nbsp;|&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ------ value moved here\n...\n13 |&nbsp; &nbsp; &nbsp;println!(\"{:?}\", boxed);\n&nbsp; &nbsp;|&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^^^^ value borrowed here after move\n</code></pre><p>因此 boxed 不能再使用。也就是说，如果 <code>Box&lt;T&gt;</code> 的 T 是 move 语义的，那么对这个Box实例做解引用操作，会把这个Box实例的所有权释放。</p><p>关于这些细节，其实你不用太担心能不能一次性掌握好，因为你用错的时候，Rustc小助手会贴心地准确提示你，所以不要有心理负担。</p><h3><code>Box&lt;T&gt;</code> 实现了trait</h3><p><code>Box&lt;T&gt;</code> 的好处在于它的明确性，它里面的资源一定在堆上，所以我们就不用再去关心资源是在栈上还是堆上这种细节问题了。一种类型，被 <code>Box&lt;&gt;</code> 包起来的过程就叫作这个类型的<strong>盒化</strong>（boxed）。</p><p>Rust在标准库里为 <code>Box&lt;T&gt;</code> 实现了 <code>Deref</code>、<code>Drop</code>、<code>AsRef&lt;T&gt;</code> 等trait，所以 <code>Box&lt;T&gt;</code> 可以直接调用T实例的方法，访问T实例的值。</p><pre><code class=\"language-plain\">#[derive(Debug)]\nstruct Point {\n&nbsp; &nbsp; x: u32,\n&nbsp; &nbsp; y: u32,\n}\n\nimpl Point {\n&nbsp; &nbsp; fn play(&amp;self) {\n&nbsp; &nbsp; &nbsp; &nbsp; println!(\"I'am a method of Point.\");\n&nbsp; &nbsp; }\n}\n\nfn main() {\n&nbsp; &nbsp; let boxed: Box&lt;Point&gt; = Box::new(Point{x: 10, y: 20});\n&nbsp; &nbsp; boxed.play();    // 点操作符触发deref\n&nbsp; &nbsp; println!(\"{:?}\", boxed);\n}\n// 输出\nI'am a method of Point.\nPoint { x: 10, y: 20 }\n</code></pre><p><code>Box&lt;T&gt;</code> 拥有对T实例的所有权，所以可以对T实例进行写操作。</p><pre><code class=\"language-plain\">#[derive(Debug)]\nstruct Point {\n&nbsp; &nbsp; x: u32,\n&nbsp; &nbsp; y: u32,\n}\n\nfn main() {\n&nbsp; &nbsp; let mut boxed: Box&lt;Point&gt; = Box::new(Point{x: 10, y: 20});\n&nbsp; &nbsp; *boxed = Point {    // 这一行，使用解引用操作更新值 \n&nbsp; &nbsp; &nbsp; &nbsp; x: 100,\n&nbsp; &nbsp; &nbsp; &nbsp; y: 200\n&nbsp; &nbsp; };\n&nbsp; &nbsp; println!(\"{:?}\", boxed);\n}\n// 输出\nPoint { x: 100, y: 200 }\n</code></pre><h3><code>Box&lt;T&gt;</code> 的Clone</h3><p><code>Box&lt;T&gt;</code> 能否Clone，需要看 T 是否实现了 Clone，因为我们也需要把 T 的资源克隆一份。你可以看一下我给出的示例。</p><pre><code class=\"language-plain\">#[derive(Debug, Clone)]\nstruct Point {\n&nbsp; &nbsp; x: u32,\n&nbsp; &nbsp; y: u32,\n}\n\nimpl Point {\n&nbsp; &nbsp; fn play(&amp;self) {\n&nbsp; &nbsp; &nbsp; &nbsp; println!(\"I'am a method of Point.\");\n&nbsp; &nbsp; }\n}\n\nfn main() {\n&nbsp; &nbsp; let mut boxed: Box&lt;Point&gt; = Box::new(Point{x: 10, y: 20});\n&nbsp; &nbsp; let mut another_boxed = boxed.clone();   // 克隆\n&nbsp; &nbsp; *another_boxed = Point{x: 100, y: 200};  // 修改新的一份值\n&nbsp; &nbsp; println!(\"{:?}\", boxed);                 // 打印原来一份值\n&nbsp; &nbsp; println!(\"{:?}\", another_boxed);         // 打印新的一份值\n}\n// 输出\nPoint { x: 10, y: 20 }\nPoint { x: 100, y: 200 }\n</code></pre><h3><code>Box&lt;T&gt;</code> 作为函数参数</h3><p>我们可以把 <code>Box&lt;T&gt;</code> 作为参数传入函数，这个我们前面已经见过了。</p><pre><code class=\"language-plain\">#[derive(Debug)]\nstruct Point {\n&nbsp; &nbsp; x: u32,\n&nbsp; &nbsp; y: u32,\n}\n\nfn foo(p: Box&lt;Point&gt;) {    // 这里参数类型是 Box&lt;Point&gt;\n&nbsp; &nbsp; println!(\"{:?}\", p);\n}\n\nfn main() {\n&nbsp; &nbsp; foo(Box::new(Point {x: 10, y: 20}));\n}\n// 输出 \nPoint { x: 10, y: 20 }\n</code></pre><h3><code>&amp;Box&lt;T&gt;</code></h3><p><code>Box&lt;T&gt;</code> 本身作为一种类型，对它做引用操作当然是可以的。</p><pre><code class=\"language-plain\">#[derive(Debug)]\nstruct Point {\n&nbsp; &nbsp; x: u32,\n&nbsp; &nbsp; y: u32,\n}\n\nimpl Point {\n&nbsp; &nbsp; fn play(&amp;self) {\n&nbsp; &nbsp; &nbsp; &nbsp; println!(\"I'am a method of Point.\");\n&nbsp; &nbsp; }\n}\n\nfn main() {\n&nbsp; &nbsp; let boxed: Box&lt;Point&gt; = Box::new(Point{x: 10, y: 20});\n&nbsp; &nbsp; boxed.play();        // 调用类型方法\n&nbsp; &nbsp; let y = &amp;boxed;      // 取boxed实例的引用\n&nbsp; &nbsp; y.play();            // 调用类型方法\n&nbsp; &nbsp; println!(\"{:?}\", y);\n}\n// 输出 \nI'am a method of Point.\nI'am a method of Point.\nPoint { x: 10, y: 20 }\n</code></pre><p>在示例中，boxed是一个所有权型变量，y是一个引用型变量。它们都能调用到Point类型上的方法。</p><p>对Box实例做可变引用（&amp;mut）也是可以的，你可以看一下示例。</p><pre><code class=\"language-plain\">#[derive(Debug)]\nstruct Point {\n&nbsp; &nbsp; x: u32,\n&nbsp; &nbsp; y: u32,\n}\n\nimpl Point {\n&nbsp; &nbsp; fn play(&amp;self) {\n&nbsp; &nbsp; &nbsp; &nbsp; println!(\"I'am a method of Point.\");\n&nbsp; &nbsp; }\n}\n\nfn main() {\n&nbsp; &nbsp; let mut boxed: Box&lt;Point&gt; = Box::new(Point{x: 10, y: 20});\n&nbsp; &nbsp; let y = &amp;mut boxed;     // 这里&amp;mut Box&lt;Point&gt;\n&nbsp; &nbsp; y.play();               // 调用类型方法\n&nbsp; &nbsp; println!(\"{:?}\", y);    // 修改前的值\n&nbsp; &nbsp; **y = Point {x: 100, y: 200};  // 注意这里用了二级解引用\n&nbsp; &nbsp; println!(\"{:?}\", y);    // 修改后的值\n}\n// 输出 \nI'am a method of Point.\nPoint { x: 10, y: 20 }\nPoint { x: 100, y: 200 }\n</code></pre><p>这个示例里值得注意的是第18行，做了两次解引用，第一次是对&amp;mut 做的，第二次是对 <code>Box&lt;T&gt;</code> 做的。</p><h3><code>Box&lt;Self&gt;</code></h3><p>前面我们讲过，类型的方法可以用 self、&amp;self、&amp;mut self 三种形态传入Self参数。其中第一种self形态还有一种变体 <code>Box&lt;Self&gt;</code>，你可以看一下示例。</p><pre><code class=\"language-plain\">#[derive(Debug)]\nstruct Point {\n&nbsp; &nbsp; x: u32,\n&nbsp; &nbsp; y: u32,\n}\n\nimpl Point {\n&nbsp; &nbsp; fn play_ref(&amp;self) {\n&nbsp; &nbsp; &nbsp; &nbsp; println!(\"I'am play_ref of Point.\");\n&nbsp; &nbsp; }\n&nbsp; &nbsp; fn play_mutref(&amp;mut self) {\n&nbsp; &nbsp; &nbsp; &nbsp; println!(\"I'am play_mutref of Point.\");\n&nbsp; &nbsp; }\n&nbsp; &nbsp; fn play_own(self) {\n&nbsp; &nbsp; &nbsp; &nbsp; println!(\"I'am play_own of Point.\");\n&nbsp; &nbsp; }\n&nbsp; &nbsp; fn play_boxown(self: Box&lt;Self&gt;) {    // 注意这里\n&nbsp; &nbsp; &nbsp; &nbsp; println!(\"I'am play_boxown of Point.\");\n&nbsp; &nbsp; }\n}\n\nfn main() {\n&nbsp; &nbsp; let mut boxed: Box&lt;Point&gt; = Box::new(Point{x: 10, y: 20});\n&nbsp; &nbsp; boxed.play_ref();\n&nbsp; &nbsp; boxed.play_mutref();\n&nbsp; &nbsp; boxed.play_boxown();\n&nbsp; &nbsp; // boxed.play_own();  // play_boxown()和 play_own() 只能同时打开一个\n}\n</code></pre><p>注意示例中，<code>play_boxown()</code> 和 <code>play_own()</code> 只能同时打开一个，这是为什么呢？你思考一下。</p><h3>结构体中的Box<t></t></h3><p><code>Box&lt;T&gt;</code> 作为类型，当然是可以出现在struct里的，你可以看一下示例。</p><pre><code class=\"language-plain\">struct Point {\n&nbsp; &nbsp; x: u32,\n&nbsp; &nbsp; y: u32,\n}\nstruct Triangle {\n&nbsp; &nbsp; one: Box&lt;Point&gt;,    // 三个字段类型都是 Box&lt;Point&gt;\n&nbsp; &nbsp; two: Box&lt;Point&gt;,\n&nbsp; &nbsp; three: Box&lt;Point&gt;,\n}\nfn main() {\n&nbsp; &nbsp; let t = Triangle {\n&nbsp; &nbsp; &nbsp; &nbsp; one: Box::new(Point {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x: 10,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y: 10,\n&nbsp; &nbsp; &nbsp; &nbsp; }),\n&nbsp; &nbsp; &nbsp; &nbsp; two: Box::new(Point {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x: 20,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y: 20,\n&nbsp; &nbsp; &nbsp; &nbsp; }),\n&nbsp; &nbsp; &nbsp; &nbsp; three: Box::new(Point {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x: 10,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y: 20,\n&nbsp; &nbsp; &nbsp; &nbsp; }),\n&nbsp; &nbsp; };\n}\n</code></pre><h3><code>Box&lt;dyn trait&gt;</code></h3><p>回忆<a href=\"https://time.geekbang.org/column/article/724776\">第 10 讲</a>的trait object，它代表一种类型，这种类型可以代理一批其他的类型。但是 dyn trait 本身的尺寸在编译期是未知的，所以 dyn trait 的出现总是要借助于引用或智能指针。而 <code>Box&lt;dyn trait&gt;</code> 是最常见的，甚至比 <code>&dyn trait</code> 更常见。原因就是 <code>Box&lt;dyn Trait&gt;</code> 拥有所有权，这就是 <code>Box&lt;T&gt;</code> 方便的地方，而 <code>&dyn Trait</code>  不拥有所有权，有的时候就没那么方便。</p><p>我们来看使用 <code>Box&lt;dyn trait&gt;</code> 做函数参数的一个示例。</p><pre><code class=\"language-plain\">struct Atype;\nstruct Btype;\nstruct Ctype;\n\ntrait TraitA {}\n\nimpl TraitA for Atype {}\nimpl TraitA for Btype {}\nimpl TraitA for Ctype {}\n\nfn doit(x: Box&lt;dyn TraitA&gt;) {}\n\nfn main() {\n&nbsp; &nbsp; let a = Atype;\n&nbsp; &nbsp; doit(Box::new(a));\n&nbsp; &nbsp; let b = Btype;\n&nbsp; &nbsp; doit(Box::new(b));\n&nbsp; &nbsp; let c = Ctype;\n&nbsp; &nbsp; doit(Box::new(c));\n}\n</code></pre><p>这个示例里的 <code>doit()</code> 函数能接收 Atype、Btype、Ctype 三种不同类型的实例。</p><p>如果 dyn trait 出现在结构体里，那么 <code>Box&lt;dyn trait&gt;</code> 形式就比 <code>&amp;dyn trait</code> 形式要方便得多。比如，下面示例里的结构体字段类型是 <code>Box&lt;dyn TraitA&gt;</code>，能正常编译。</p><pre><code class=\"language-plain\">struct Atype;\nstruct Btype;\nstruct Ctype;\n\ntrait TraitA {}\n\nimpl TraitA for Atype {}\nimpl TraitA for Btype {}\nimpl TraitA for Ctype {}\n\nstruct MyStruct {\n&nbsp; &nbsp; x: Box&lt;dyn TraitA&gt;  // 结构体的字段类型是 Box&lt;dyn TraitA&gt;\n}\n\nfn main() {\n&nbsp; &nbsp; let a = Atype;\n&nbsp; &nbsp; let t1 = MyStruct {x: Box::new(a)};\n&nbsp; &nbsp; let b = Btype;\n&nbsp; &nbsp; let t2 = MyStruct {x: Box::new(b)};\n&nbsp; &nbsp; let c = Ctype;\n&nbsp; &nbsp; let t3 = MyStruct {x: Box::new(c)};\n}\n</code></pre><p>而下面这个示例，结构体字段类型是 <code>&amp;dyn TraitA</code>，就没办法通过编译。</p><pre><code class=\"language-plain\">struct Atype;\nstruct Btype;\nstruct Ctype;\n\ntrait TraitA {}\n\nimpl TraitA for Atype {}\nimpl TraitA for Btype {}\nimpl TraitA for Ctype {}\n\nstruct MyStruct {\n&nbsp; &nbsp; x: &amp;dyn TraitA    // 结构体字段类型是 &amp;dyn TraitA \n}\n</code></pre><p>报错如下：</p><pre><code class=\"language-plain\">error[E0106]: missing lifetime specifier\n  --&gt; src/lib.rs:12:8\n   |\n12 |     x: &amp;dyn TraitA\n   |        ^ expected named lifetime parameter\n   |\nhelp: consider introducing a named lifetime parameter\n   |\n11 ~ struct MyStruct&lt;'a&gt; {\n12 ~     x: &amp;'a dyn TraitA\n   |\n</code></pre><p>这个错误涉及到第20讲引用的生命期的概念，现在我们不去深究。</p><p><code>Box&lt;T&gt;</code> 智能指针的内容就讲到这里，下面我们看另一种智能指针 <code>Arc&lt;T&gt;</code>。</p><h2><code>Arc&lt;T&gt;</code></h2><p><code>Box&lt;T&gt;</code> 是单所有权或独占所有权模型的智能指针，而 <code>Arc&lt;T&gt;</code> 是共享所有权模型的智能指针，也就是多个变量可以同时拥有一个资源的所有权。和 <code>Box&lt;T&gt;</code> 一样，<code>Arc&lt;T&gt;</code> 也会保证被包装的内容被分配在堆上。</p><h3>clone</h3><p>Arc的主要功能是和 <code>clone()</code> 配合使用。在Arc实例上每一次新的 <code>clone()</code> 操作，总是会将资源的引用数+1，而保持原来那一份资源不动，这个信息记录在Arc实例里面。每一个指向同一个资源的Arc实例走出作用域，就会给这个引用计数-1。直到最后一个Arc实例消失，目标资源才会被销毁释放。你可以看一下示例。</p><pre><code class=\"language-plain\">use std::sync::Arc;\n\n#[derive(Debug)]    // 这里不需要目标type实现Clone trait\nstruct Point {\n&nbsp; &nbsp; x: u32,\n&nbsp; &nbsp; y: u32,\n}\n\nimpl Point {\n&nbsp; &nbsp; fn play(&amp;self) {\n&nbsp; &nbsp; &nbsp; &nbsp; println!(\"I'am a method of Point.\");\n&nbsp; &nbsp; }\n}\n\nfn main() {\n&nbsp; &nbsp; let arced: Arc&lt;Point&gt; = Arc::new(Point{x: 10, y: 20});\n&nbsp; &nbsp; let another_arced = arced.clone();&nbsp; &nbsp; &nbsp; // 克隆引用\n&nbsp; &nbsp; println!(\"{:?}\", arced);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 打印一份值\n&nbsp; &nbsp; println!(\"{:?}\", another_arced);&nbsp; &nbsp; &nbsp; &nbsp; // 打印同一份值\n&nbsp; &nbsp; arced.play();\n&nbsp; &nbsp; another_arced.play();\n    let arc3_ref = &amp;another_arced;\n    arc3_ref.play();\n}\n// 输出\nPoint { x: 10, y: 20 }\nPoint { x: 10, y: 20 }\nI'am a method of Point.\nI'am a method of Point.\nI'am a method of Point.\n</code></pre><p>我们可以看到，相比于 <code>Box&lt;T&gt;</code>，<code>Arc&lt;T&gt;</code> 的clone不要求T实现了Clone trait。<code>Arc&lt;T&gt;</code> 的克隆行为只会改变Arc的引用计数，而不会克隆里面的内容。由于不需要克隆原始资源，所以性能是很高的。</p><p>类似于 <code>Box&lt;T&gt;</code>，<code>Arc&lt;T&gt;</code> 也实现了Deref、Drop、Clone等trait。因此，<code>Arc&lt;T&gt;</code> 也可以符合人类的习惯，访问到里面类型T的方法。<code>Arc&lt;T&gt;</code> 的不可变引用 <code>&amp;Arc&lt;&gt;</code> 也可以顺利调用到T上的方法。</p><h3>Arc<self></self></h3><p>和 <code>Box&lt;T&gt;</code> 一样，Arc也可以用在方法中的self参数上面，作为所有权self的一个变体形式。</p><p>我们继续扩展上面的代码，你可以看一下扩展后的样子。</p><pre><code class=\"language-plain\">use std::sync::Arc;\n\n#[derive(Debug)]\nstruct Point {\n&nbsp; &nbsp; x: u32,\n&nbsp; &nbsp; y: u32,\n}\n\nimpl Point {\n&nbsp; &nbsp; fn play_ref(&amp;self) {\n&nbsp; &nbsp; &nbsp; &nbsp; println!(\"I'am play_ref of Point.\");\n&nbsp; &nbsp; }\n&nbsp; &nbsp; fn play_mutref(&amp;mut self) {\n&nbsp; &nbsp; &nbsp; &nbsp; println!(\"I'am play_mutref of Point.\");\n&nbsp; &nbsp; }\n&nbsp; &nbsp; fn play_own(self) {\n&nbsp; &nbsp; &nbsp; &nbsp; println!(\"I'am play_own of Point.\");\n&nbsp; &nbsp; }\n&nbsp; &nbsp; fn play_boxown(self: Box&lt;Self&gt;) {&nbsp; &nbsp; // 注意这里\n&nbsp; &nbsp; &nbsp; &nbsp; println!(\"I'am play_boxown of Point.\");\n&nbsp; &nbsp; }\n&nbsp; &nbsp; fn play_arcown(self: Arc&lt;Self&gt;) {&nbsp; &nbsp; // 注意这里\n&nbsp; &nbsp; &nbsp; &nbsp; println!(\"I'am play_arcown of Point.\");\n&nbsp; &nbsp; }\n}\n\nfn main() {\n&nbsp; &nbsp; let mut boxed: Box&lt;Point&gt; = Box::new(Point{x: 10, y: 20});\n&nbsp; &nbsp; boxed.play_ref();\n&nbsp; &nbsp; boxed.play_mutref();\n&nbsp; &nbsp; boxed.play_boxown();\n&nbsp; &nbsp; // boxed.play_own();&nbsp; // play_boxown()和 play_own() 只能同时打开一个\n&nbsp; &nbsp; \n    let arced: Arc&lt;Point&gt; = Arc::new(Point{x: 10, y: 20});\n&nbsp; &nbsp; arced.play_ref();\n&nbsp; &nbsp; // arced.play_mutref();&nbsp; // 不能用\n&nbsp; &nbsp; // arced.play_own();&nbsp; &nbsp; &nbsp;// 不能用，Arc&lt;T&gt; 中的T无法被移出\n&nbsp; &nbsp; arced.play_arcown();&nbsp;\n}\n// 输出\nI'am play_ref of Point.\nI'am play_mutref of Point.\nI'am play_boxown of Point.\nI'am play_ref of Point.\nI'am play_arcown of Point.\n</code></pre><p>通过这个示例我们可以看到，不能通过 <code>Arc&lt;&gt;</code> 直接修改里面类型的值，也不能像 <code>Box&lt;&gt;</code> 的解引用操作那样，把里面的内容从 <code>Arc&lt;&gt;</code> 中移动出来。你可以试着打开示例里注释掉的几行看看Rustc小助手的提示信息。</p><h3><code>Arc&lt;dyn trait&gt;</code></h3><p>我们还可以把前面 <code>Box&lt;dyn trait&gt;</code> 的示例改编成 <code>Arc&lt;T&gt;</code> 的。</p><pre><code class=\"language-plain\">use std::sync::Arc;\n\nstruct Atype;\nstruct Btype;\nstruct Ctype;\n\ntrait TraitA {}\n\nimpl TraitA for Atype {}\nimpl TraitA for Btype {}\nimpl TraitA for Ctype {}\n\nstruct MyStruct {\n&nbsp; &nbsp; x: Arc&lt;dyn TraitA&gt;\n}\n\nfn main() {\n&nbsp; &nbsp; let a = Atype;\n&nbsp; &nbsp; let t1 = MyStruct {x: Arc::new(a)};\n&nbsp; &nbsp; let b = Btype;\n&nbsp; &nbsp; let t2 = MyStruct {x: Arc::new(b)};\n&nbsp; &nbsp; let c = Ctype;\n&nbsp; &nbsp; let t3 = MyStruct {x: Arc::new(c)};\n}\n</code></pre><h3>值的修改</h3><p>多所有权条件下，怎么修改Arc里面的值呢？答案是不能修改。虽然 <code>Arc&lt;T&gt;</code> 是拥有所有权的，但 <code>Arc&lt;T&gt;</code> 不提供修改T的能力，这也是 <code>Arc&lt;T&gt;</code> 和 <code>Box&lt;T&gt;</code> 不一样的地方。后面我们在并发编程部分会讲到Mutex、RwLock等锁。想要修改Arc里面的内容，必须配合这些锁才能完成，比如 <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>。</p><p>其实很好理解，共享所有权的场景下，如果任意一方能随意修改被包裹的值，那就会影响其他所有权的持有者，整个就乱套了。所以要修改的话必须引入锁的机制。</p><h3><code>Arc&lt;T&gt;</code> 与不可变引用&amp;的区别</h3><p>首先，它们都是共享对象的行为，本质上都是指针。但 <code>Arc&lt;T&gt;</code> 是共享了所有权模型，而&amp;只是共享借用模型。共享借用模型就得遵循借用检查器的规则——借用的有效性依赖于被借用资源的scope。对于这个的分析是非常复杂的。而所有权模型是由自己来管理资源的scope，所以处理起来比较方便。</p><h2>小结</h2><p>这节课我们一起学习了最常用的两个智能指针：<code>Box&lt;T&gt;</code> 和 <code>Arc&lt;T&gt;</code>。其实Rust里还有很多智能指针，比如 Rc、Cell、RefCell 等等，每一种智能指针类型都有自己的特点。但是不管怎样，学习的方法都是一样的，那就是从所有权的视角去分析研究。你可以在后面遇到那些类型的时候，再根据这节课提供的方法去研究它们。</p><p>后面我们会看到，在智能指针的加持下，Rust代码写起来会非常流畅，可以和Java不相上下。再结合Rust强大的类型系统建模能力，等你写得熟练之后，在中大项目中，使用Rust甚至会有超越Python的开发效率。</p><p><img src=\"https://static001.geekbang.org/resource/image/86/a9/86yy7a1095414ed7c2e479a5af42cfa9.jpg?wh=1270x1752\" alt=\"\"></p><h2>思考题</h2><p>你试着打开示例中的这两句，看看报错信息，然后分析一下是为什么？</p><pre><code class=\"language-plain\">&nbsp; &nbsp; // arced.play_mutref();&nbsp; // 不能用\n&nbsp; &nbsp; // arced.play_own();&nbsp; &nbsp; &nbsp;// 不能用\n</code></pre><p>欢迎你把自己的分析分享到评论区，也欢迎你把这节课的内容分享给其他朋友，我们下节课再见！</p>","neighbors":{"left":{"article_title":"11｜常见trait解析：标准库中的常见trait应该怎么用？","id":724942},"right":{"article_title":"13｜独立王国：初步了解Rust异步并发编程","id":725837}},"comments":[{"had_liked":false,"id":384668,"user_name":"cfanbo","can_delete":false,"product_type":"c1","uid":1043738,"ip_address":"澳大利亚","ucode":"39D8D71453E575","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/1a/269eb3d6.jpg","comment_is_top":false,"comment_ctime":1701316685,"is_pvip":false,"replies":[{"id":140296,"content":"对的","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1701357309,"ip_address":"重庆","comment_id":384668,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"在执行 Box::new() 创建 Box 实例时，具有 copy 语义的整数类型和具有 move 语义的 Point 类型行为不一样。整数会 copy 一份自己，Point 实例会把自己 move 到 Box 里面去。\n------\n是否可以理解为如果创建的对象有copy语义的话，则进行copy；否则进行move操作？","like_count":4,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632804,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1701357309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383947,"user_name":"刘丹","can_delete":false,"product_type":"c1","uid":1081922,"ip_address":"广东","ucode":"66594D1C957E15","user_header":"https://static001.geekbang.org/account/avatar/00/10/82/42/8b04d489.jpg","comment_is_top":false,"comment_ctime":1700006083,"is_pvip":false,"replies":[{"id":140092,"content":"对的，py代码量上来后，可维护性和可重构性比rust差得太远。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700015083,"ip_address":"重庆","comment_id":383947,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"在中大项目中，使用 Rust 甚至会有超越 Python 的开发效率。","like_count":4,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631826,"discussion_content":"对的，py代码量上来后，可维护性和可重构性比rust差得太远。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1700015083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1120153,"avatar":"https://static001.geekbang.org/account/avatar/00/11/17/99/d2e2ba19.jpg","nickname":"简","note":"","ucode":"48300AD332D244","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635512,"discussion_content":"看起来您Python写的还是不够好。这个结论很武断","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704899832,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"河北","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383969,"user_name":"Taozi","can_delete":false,"product_type":"c1","uid":1021926,"ip_address":"上海","ucode":"DD6567A31B3E33","user_header":"","comment_is_top":false,"comment_ctime":1700032103,"is_pvip":false,"replies":[{"id":140105,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700192056,"ip_address":"重庆","comment_id":383969,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"Arc本质上是个引用，所以不允许同时存在可变引用或者移动。","like_count":3,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631951,"discussion_content":"👍","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1700192056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":641549,"discussion_content":"这感觉不能这么理解，那 Box 呢？不一样是一个引用。\n还是要从“共享”资源的角度去理解，同一份资源（所有权）不能直接进行修改，需要先获取到写权限（锁控制）。\n类似于 let x 和 let mut x 的区别，Arc 的这种写限制应该只是在语言设计层面上的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1712754550,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385859,"user_name":"$侯","can_delete":false,"product_type":"c1","uid":1019939,"ip_address":"浙江","ucode":"488B1BD3924E7E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/90/23/5c74e9b7.jpg","comment_is_top":false,"comment_ctime":1703519241,"is_pvip":false,"replies":[{"id":140626,"content":"这正是一个隐含的知识点，固定尺寸的结构体却默认不是可copy的。目的是为了防止不小心的产生额外复制负担。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1703577398,"ip_address":"重庆","comment_id":385859,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"Box&lt;T&gt; 中的所有权分析 那里\n\n说“Point 类型本身就是 move 语义的”\n\n这里的Point中的元素不都是copy语义的吗，所以这个Point不是应该是copy语义的吗，为什么说是move语义的\n","like_count":1,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634492,"discussion_content":"这正是一个隐含的知识点，固定尺寸的结构体却默认不是可copy的。目的是为了防止不小心的产生额外复制负担。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1703577398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":1,"child_discussions":[{"author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":641554,"discussion_content":"老师我想请问下，这里说 Box&lt;Point&gt; 解引用被从堆上“移动”到了栈上，是指 Point 的值以及它的所有权都被移动了吗？\n\n1: let p1 = Point {x: 10, y: 20};       // 这个结构体的实例 p1 创建在栈上\n2: let boxed: Box = Box::new(p1);  // 通过 Box::new(p1)，把 p1 实例强行按位复制了一份，并且放到了堆上（记为 p1&#39;）\n3: let p2: Point = *boxed;            // 这里做了解引用，Point 实例 p1&#39; 回到栈上\n\nQ1：以上第 2 行代码，boxed 里面指向的应该是 p1&#39; 而不是 p1（因为 p1 在栈上，p1&#39; 在堆上），它为什么说是“复制”？p1 应该移动了所有权！\nQ2：以上第 3 行代码，p2 实例回到栈上，为什么又说是“移动”？实际的操作是不是把 p1&#39; 再按位复制一份到栈上（记为 p2），然后堆上的 p1&#39; 就直接回收了（是解引用后就回收了，还是等到退出函数（所有权作用域）后？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1712755538,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":634492,"ip_address":"广东","group_id":0},"score":641554,"extra":""}]}]},{"had_liked":false,"id":383971,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1118976,"ip_address":"中国香港","ucode":"35F4FFAC4A4B15","user_header":"https://static001.geekbang.org/account/avatar/00/11/13/00/a4a2065f.jpg","comment_is_top":false,"comment_ctime":1700033546,"is_pvip":false,"replies":[{"id":140107,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700192066,"ip_address":"重庆","comment_id":383971,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"play_boxown() 和 play_own() 只能同时打开一个，这两个方法调用都会消耗所有权，导致没法调用另外一个。","like_count":1,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631953,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700192066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383957,"user_name":"duwoodly","can_delete":false,"product_type":"c1","uid":2020398,"ip_address":"重庆","ucode":"12F7BFCB78DB0E","user_header":"https://static001.geekbang.org/account/avatar/00/1e/d4/2e/d478a412.jpg","comment_is_top":false,"comment_ctime":1700018910,"is_pvip":false,"replies":[{"id":140101,"content":"对的，自己动手试验，得到最准确最全面的信息。👍","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700191183,"ip_address":"重庆","comment_id":383957,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100626901,"comment_content":" arced.play_mutref(); &#47;&#47;  Arc&lt;T&gt;没有实现智能指针的DerefMut  trait\narced.play_own(); &#47;&#47;  不能从Arc&lt;T&gt; 中移出值，除非T实现了Copy","like_count":1,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631947,"discussion_content":"对的，自己动手试验，得到最准确最全面的信息。👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700191183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":641555,"discussion_content":"666，这个才是根本原因","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1712755596,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385608,"user_name":"superggn","can_delete":false,"product_type":"c1","uid":3623568,"ip_address":"北京","ucode":"831CCD98B393FE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/7Q403U68Oy4lXG5sFBPVKLrfwaRzBqpBZibpEBXcPf9UOO3qrnh7RELoByTLzBZLkN9Nukfsj7DibynbZjKAKgag/132","comment_is_top":false,"comment_ctime":1702968944,"is_pvip":false,"replies":[{"id":140566,"content":"分析得非常棒！思路也很棒。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1703123543,"ip_address":"重庆","comment_id":385608,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"arced.play_mutref() =&gt; 这个不能用是因为 Arc 这种提供多个引用的类型不支持可变引用\narced.play_own() =&gt; 这个不能用是因为 Arc 这种提供多个引用的类型不支持转移内部值的所有权\n\n一开始我寻思这里会不会是直接抛出 mismatched type, 看 rustc 的提示发现不对， 后来想了想， 可能是因为 rust 找不到类型会先跑 deref coercion, deref coercion 匹配到了就不会报 mismatched type， 报错是在 deref coercion 过程中获取所有权的时候才出现？\n\n总结下： Box&lt;T&gt;, Arc&lt;T&gt;, Rc&lt;T&gt; 调用 T 的方法， 机制都是 deref coercion\n\nBox 还好， 所有权拿走就拿吧， 但 Arc &#47; Rc 这俩都可能会有不同的所有者， 里头的 T 不能是 mut 的， 所有权也不能放出去， 所以会错","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634242,"discussion_content":"分析得非常棒！思路也很棒。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1703123543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384013,"user_name":"鸠摩智","can_delete":false,"product_type":"c1","uid":1106201,"ip_address":"江苏","ucode":"853E584FC4CD64","user_header":"https://static001.geekbang.org/account/avatar/00/10/e1/19/c756aaed.jpg","comment_is_top":false,"comment_ctime":1700103732,"is_pvip":true,"replies":[{"id":140100,"content":"对的，👍。自动解开是因为 Box&lt;T&gt; 实现了到 T 的 Deref：https:&#47;&#47;doc.rust-lang.org&#47;std&#47;boxed&#47;struct.Box.html#impl-Deref-for-Box%3CT,+A%3E","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700191058,"ip_address":"重庆","comment_id":384013,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"     值得注意的是，函数的入参是self:Box&lt;Self&gt;时，调用这个函数的只能是Box包起来的类型，比如这里的Point。\n     let p = Point{x:1,y:2};\n     p.play_boxown();\n     会编译报错method `play_boxown` not found for this struct Point\n     the method is available for `Box&lt;Point&gt;` here\n    consider wrapping the receiver expression with the appropriate type\n    Box::new(p).play_boxown();\n点操作符不会自动用Box包起来，但是会解开Box。","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631946,"discussion_content":"对的，👍。自动解开是因为 Box&lt;T&gt; 实现了到 T 的 Deref：https://doc.rust-lang.org/std/boxed/struct.Box.html#impl-Deref-for-Box%3CT,+A%3E","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700191058,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383990,"user_name":"下雨天","can_delete":false,"product_type":"c1","uid":1008315,"ip_address":"湖北","ucode":"816B3792ECC50A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/62/bb/323a3133.jpg","comment_is_top":false,"comment_ctime":1700046921,"is_pvip":false,"replies":[{"id":140099,"content":"👍。是的，里面的T无法被移出Arc，这点与Box不同。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700190956,"ip_address":"重庆","comment_id":383990,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"let  arced: Arc&lt;Point&gt; = Arc::new(Point{x: 10, y: 20});\n1. arced.play_mutref(); \naced只提供不可变引用，play_mutref参数是可变引用。打开就会报错\n\n\n2. arced.play_own();     &#47;&#47; 不能用\nplay_own的参数self表示 Point , 而arced类型是Arc&lt;Point&gt;  不能强制转换。\n\n","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631945,"discussion_content":"👍。是的，里面的T无法被移出Arc，这点与Box不同。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700190957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383962,"user_name":"-","can_delete":false,"product_type":"c1","uid":1546505,"ip_address":"北京","ucode":"7B34258D346793","user_header":"https://static001.geekbang.org/account/avatar/00/17/99/09/29c46a7b.jpg","comment_is_top":false,"comment_ctime":1700022959,"is_pvip":false,"replies":[{"id":140103,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700191976,"ip_address":"重庆","comment_id":383962,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"play_boxown() 和 play_own() 只能同时打开一个,两个都是所有权转移了，所以就只能调用一次。","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631949,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700191976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383951,"user_name":"哄哄","can_delete":false,"product_type":"c1","uid":3779530,"ip_address":"北京","ucode":"F75FB23BEDC60A","user_header":"https://static001.geekbang.org/account/avatar/00/39/ab/ca/32d6c05d.jpg","comment_is_top":false,"comment_ctime":1700014924,"is_pvip":false,"replies":[{"id":140097,"content":"你讲的没问题，我会把Rc放进阶部分去讲，主要是要照顾从js，py，php等语言过来的同学。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700019650,"ip_address":"重庆","comment_id":383951,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"Arc开销较大，如果不是为了多线程，就应该用Rc","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631837,"discussion_content":"你讲的没问题，我会把Rc放进阶部分去讲，主要是要照顾从js，py，php等语言过来的同学。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700019650,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}