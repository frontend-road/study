{"id":71634,"title":"18 | 如何自己开发一个大数据SQL引擎？","content":"<p>从今天开始我们就进入了专栏的第三个模块，一起来看看大数据开发实践过程中的门道。学习一样技术，如果只是作为学习者，被动接受总是困难的。<strong>但如果从开发者的视角看，很多东西就豁然开朗了，明白了原理，有时甚至不需要学习，顺着原理就可以推导出各种实现细节</strong>。</p><p>各种知识从表象上看，总是杂乱无章的，如果只是学习这些繁杂的知识点，固然自己的知识面是有限的，并且遇到问题的应变能力也很难提高。所以有些高手看起来似乎无所不知，不论谈论起什么技术，都能头头是道，其实并不是他们学习、掌握了所有技术，而是他们是在谈到这个问题的时候，才开始进行推导，并迅速得出结论。</p><p>我在Intel的时候，面试过一个交大的实习生，她大概只学过一点MapReduce的基本知识，我问她如何用MapReduce实现数据库的join操作，可以明显看出她没学习过这部分知识。她说：我想一下，然后盯着桌子看了两三秒的时间，就开始回答，基本跟Hive的实现机制一样。从她的回答就能看出这个女生就是一个高手，高手不一定要很资深、经验丰富，把握住了技术的核心本质，掌握了快速分析推导的能力，能够迅速将自己的知识技能推进到陌生的领域，就是高手。</p><p>这也是我这个专栏的目的，讲述大数据技术的核心原理，分享一些高效的思考和思维方式，帮助你构建起自己的技术知识体系。</p><!-- [[[read_end]]] --><p>在这个模块里，我将以大数据开发者的视角，讲述大数据开发需要关注的各种问题，以及相应的解决方案。希望你可以进入我的角色，跳出纷繁复杂的知识表象，掌握核心原理和思维方式，进而融会贯通各种技术，再通过各种实践训练，最终成为真正的高手。</p><p>前面专栏我们提到过，程序员的三大梦想，也就是开发数据库、操作系统和编译器。今天我们通过一个支持标准SQL语法的大数据仓库引擎的设计开发案例，看看<span class=\"orange\">如何自己开发一个大数据SQL引擎</span>。</p><p>在学习今天的内容前，我们先回顾一下前面讨论过的大数据仓库Hive。作为一个成功的大数据仓库，它将SQL语句转换成MapReduce执行过程，并把大数据应用的门槛下降到普通数据分析师和工程师就可以很快上手的地步。这部分内容如果你忘记了，可以返回<a href=\"http://time.geekbang.org/column/article/69459\">专栏第11期</a>复习一下。</p><p>但是Hive也有自己的问题，由于它使用自己定义的Hive QL语法，这对已经熟悉Oracle等传统数据仓库的分析师来说，还是有一定的上手难度。特别是很多企业使用传统数据仓库进行数据分析已经由来已久，沉淀了大量的SQL语句，并且这些SQL经过多年的修改打磨，非常庞大也非常复杂。我曾经见过某银行的一条统计报表SQL，打印出来足足两张A4纸。这样的SQL光是完全理解可能就要花很长时间，再转化成Hive QL就更加费力，还不说转化修改过程中可能引入的bug。</p><p>2012年那会，我还在Intel亚太研发中心大数据团队，当时团队决定开发一款能够支持标准数据库SQL的大数据仓库引擎，希望让那些在Oracle上运行良好的SQL可以直接运行在Hadoop上，而不需要重写成Hive QL。这就是后来的<a href=\"http://github.com/intel-hadoop/project-panthera-ase\">Panthera</a>项目。</p><p>在开发Panthera前，我们分析一下Hive的主要处理过程，大体上分成三步：</p><p>1.将输入的Hive QL经过语法解析器转换成Hive抽象语法树（Hive AST）。<br>\n2.将Hive AST经过语义分析器转换成MapReduce执行计划。<br>\n3.将生成的MapReduce执行计划和Hive执行函数代码提交到Hadoop上执行。</p><p>Panthera的设计思路是保留Hive语义分析器不动，替换Hive语法解析器，使其将标准SQL语句转换成Hive语义分析器能够处理的Hive抽象语法树。用图形来表示的话，是用红框内的部分代替黑框内原来Hive的部分。</p><p><img src=\"https://static001.geekbang.org/resource/image/72/b0/7236e0335857fd75d7d773634eaf51b0.png?wh=1114*324\" alt=\"\"></p><p>红框内的组件我们重新开发过，浅蓝色的是我们使用的一个开源的SQL语法解析器，将标准SQL解析成标准SQL抽象语法树（SQL AST），后面深蓝色的就是团队自己开发的SQL抽象语法树分析与转换器，将SQL AST转换成Hive AST。</p><p>那么标准SQL和Hive QL的差别在哪里呢？</p><p>标准SQL和Hive QL的差别主要有两个方面，一个是语法表达方式，Hive QL语法和标准SQL语法略有不同；另一个是Hive QL支持的语法元素比标准SQL要少很多，比如，数据仓库领域主要的测试集<a href=\"http://www.tpc.org/tpch/\">TPC-H</a>所有的SQL语句Hive都不支持。尤其是Hive不支持复杂的嵌套子查询，而对于数据仓库分析而言，嵌套子查询几乎是无处不在的。比如下面这样的SQL，在where查询条件existes里面包含了另一条SQL语句。</p><pre><code>select o_orderpriority, count(*) as order_count \nfrom orders \nwhere o_orderdate &gt;= date '[DATE]' \nand o_orderdate &lt; date '[DATE]' + interval '3' month \nand exists \n( select * from lineitem \nwhere l_orderkey = o_orderkey and l_commitdate &lt; l_receiptdate ) \ngroup by o_orderpriority order by o_orderpriority;\n</code></pre><p>所以开发支持标准SQL语法的SQL引擎的难点，就变成<strong>如何将复杂的嵌套子查询消除掉</strong>，也就是where条件里不包含select。</p><p>SQL的理论基础是关系代数，而关系代数的主要操作只有5种，分别是并、差、积、选择、投影。所有的SQL语句最后都能用这5种操作组合完成。而一个嵌套子查询可以等价转换成一个连接（join）操作。</p><p>比如这条SQL</p><pre><code>select s_grade from staff where s_city not in (select p_city from proj where s_empname=p_pname)\n</code></pre><p>这是一个在where条件里嵌套了not in子查询的SQL语句，它可以用left outer join和left semi join进行等价转换，示例如下，这是Panthera自动转换完成得到的等价SQL。这条SQL语句不再包含嵌套子查询，</p><pre><code>select panthera_10.panthera_1 as s_grade from (select panthera_1, panthera_4, panthera_6, s_empname, s_city from (select s_grade as panthera_1, s_city as panthera_4, s_empname as panthera_6, s_empname as s_empname, s_city as s_city from staff) panthera_14 left outer join (select panthera_16.panthera_7 as panthera_7, panthera_16.panthera_8 as panthera_8, panthera_16.panthera_9 as panthera_9, panthera_16.panthera_12 as panthera_12, panthera_16.panthera_13 as panthera_13 from (select panthera_0.panthera_1 as panthera_7, panthera_0.panthera_4 as panthera_8, panthera_0.panthera_6 as panthera_9, panthera_0.s_empname as panthera_12, panthera_0.s_city as panthera_13 from (select s_grade as panthera_1, s_city as panthera_4, s_empname as panthera_6, s_empname, s_city from staff) panthera_0 left semi join (select p_city as panthera_3, p_pname as panthera_5 from proj) panthera_2 on (panthera_0.panthera_4 = panthera_2.panthera_3) and (panthera_0.panthera_6 = panthera_2.panthera_5) where true) panthera_16 group by panthera_16.panthera_7, panthera_16.panthera_8, panthera_16.panthera_9, panthera_16.panthera_12, panthera_16.panthera_13) panthera_15 on ((((panthera_14.panthera_1 &lt;=&gt; panthera_15.panthera_7) and (panthera_14.panthera_4 &lt;=&gt; panthera_15.panthera_8)) and (panthera_14.panthera_6 &lt;=&gt; panthera_15.panthera_9)) and (panthera_14.s_empname &lt;=&gt; panthera_15.panthera_12)) and (panthera_14.s_city &lt;=&gt; panthera_15.panthera_13) where ((((panthera_15.panthera_7 is null) and (panthera_15.panthera_8 is null)) and (panthera_15.panthera_9 is null)) and (panthera_15.panthera_12 is null)) and (panthera_15.panthera_13 is null)) panthera_10 ;\n</code></pre><p>通过可视化工具将上面两条SQL的语法树展示出来，是这样的。</p><p><img src=\"https://static001.geekbang.org/resource/image/2e/2b/2ebce9da37fff01e5701342699b69f2b.png?wh=590*346\" alt=\"\"></p><p>这是原始的SQL抽象语法树。</p><p><img src=\"https://static001.geekbang.org/resource/image/3a/15/3aafd8cf731eb6fd5b0e125847084f15.png?wh=1440*232\" alt=\"\"></p><p>这是等价转换后的抽象语法树，内容太多被压缩得无法看清，不过你可以感受一下（笑）。</p><p>那么，在程序设计上如何实现这样复杂的语法转换呢？当时Panthera项目组合使用了几种经典的设计模式，每个语法点被封装到一个类里去处理，每个类通常不过几十行代码，这样整个程序非常简单、清爽。如果在测试过程中遇到不支持的语法点，只需为这个语法点新增加一个类即可，团队协作与代码维护非常容易。</p><p>使用装饰模式的语法等价转换类的构造，Panthera每增加一种新的语法转换能力，只需要开发一个新的Transformer类，然后添加到下面的构造函数代码里即可。</p><pre><code>   private static SqlASTTransformer tf =\n      new RedundantSelectGroupItemTransformer(\n      new DistinctTransformer(\n      new GroupElementNormalizeTransformer(\n      new PrepareQueryInfoTransformer(\n      new OrderByTransformer(\n      new OrderByFunctionTransformer(\n      new MinusIntersectTransformer(\n      new PrepareQueryInfoTransformer(\n      new UnionTransformer(\n      new Leftsemi2LeftJoinTransformer(\n      new CountAsteriskPositionTransformer(\n      new FilterInwardTransformer(\n      //use leftJoin method to handle not exists for correlated\n      new CrossJoinTransformer(\n      new PrepareQueryInfoTransformer(\n      new SubQUnnestTransformer(\n      new PrepareFilterBlockTransformer(\n      new PrepareQueryInfoTransformer(\n      new TopLevelUnionTransformer(\n      new FilterBlockAdjustTransformer(\n      new PrepareFilterBlockTransformer(\n      new ExpandAsteriskTransformer(\n      new PrepareQueryInfoTransformer(\n      new CrossJoinTransformer(\n      new PrepareQueryInfoTransformer(\n      new ConditionStructTransformer(\n      new MultipleTableSelectTransformer(\n      new WhereConditionOptimizationTransformer(\n      new PrepareQueryInfoTransformer(\n      new InTransformer(\n      new TopLevelUnionTransformer(\n      new MinusIntersectTransformer(\n      new NaturalJoinTransformer(\n      new OrderByNotInSelectListTransformer(\n      new RowNumTransformer(\n      new BetweenTransformer(\n      new UsingTransformer(\n      new SchemaDotTableTransformer(\n      new NothingTransformer())))))))))))))))))))))))))))))))))))));\n</code></pre><p>而在具体的Transformer类中，则使用组合模式对抽象语法树AST进行遍历，以下为Between语法节点的遍历。我们看到使用组合模式进行树的遍历不需要用递归算法，因为递归的特性已经隐藏在树的结构里面了。</p><pre><code>  @Override\n  protected void transform(CommonTree tree, TranslateContext context) throws SqlXlateException {\n    tf.transformAST(tree, context);\n    trans(tree, context);\n  }\n\n  void trans(CommonTree tree, TranslateContext context) {\n    // deep firstly\n    for (int i = 0; i &lt; tree.getChildCount(); i++) {\n      trans((CommonTree) (tree.getChild(i)), context);\n    }\n    if (tree.getType() == PantheraExpParser.SQL92_RESERVED_BETWEEN) {\n      transBetween(false, tree, context);\n    }\n    if (tree.getType() == PantheraExpParser.NOT_BETWEEN) {\n      transBetween(true, tree, context);\n    }\n  }\n</code></pre><p>将等价转换后的抽象语法树AST再进一步转换成Hive格式的抽象语法树，就可以交给Hive的语义分析器去处理了，从而也就实现了对标准SQL的支持。</p><p>当时Facebook为了证明Hive对数据仓库的支持，Facebook的工程师手工将TPC-H的测试SQL转换成Hive QL，我们将这些手工Hive QL和Panthera进行对比测试，两者性能各有所长，总体上不相上下，这说明Panthera自动进行语法分析和转换的效率还是不错的。</p><p>Panthera（ASE）和Facebook手工Hive QL对比测试结果如下。</p><p><img src=\"https://static001.geekbang.org/resource/image/c1/6f/c1866cede6eb563481d917b0f06b176f.png?wh=1014*598\" alt=\"\"></p><p>事实上，标准SQL语法集的语法点非常多，我们经过近两年的努力，绞尽脑汁进行各种关系代数等价变形，依然没有全部适配所有的标准SQL语法。</p><p>我在开发Panthera的时候，查阅了很多关于SQL和数据库的网站和文档，发现在我们耳熟能详的那些主流数据库之外还有很多名不见经传的数据库，此外，还有大量的关于SQL的语法解析器、测试数据和脚本集、各种周边工具。我们经常看到的MySQL、Oracle这些产品仅仅是整个数据库生态体系的冰山一角。还有很多优秀的数据库在竞争中落了下风、默默无闻，而更多的支撑起这些优秀数据库的论文、工具，非业内人士几乎闻所未闻。</p><p>这个认识给了我很大触动，我一直期待我们中国人能开发出自己的操作系统、数据库、编程语言，也看到有很多人前仆后继投入其中。但是这么多年过去了，大部分努力惨淡收场，小部分结果沦落为笑柄，成为人们饭后的谈资。我曾经思考过，为什么会这样？</p><p>开发Panthera之后，我想，我们国家虽然从事软件开发的人数很多，但是绝大多数都在做最顶层的应用开发，底层技术开发和研究的人太少，做出来的成果也太少。我们在一个缺乏周边生态体系、没有足够的竞争产品的情况下，就想直接开发出自己有影响力的操作系统、数据库、编程语言，无异于想在沙漠里种出几棵参天大树。</p><p>不过，庆幸的是，我也看到越来越多有全球影响力的底层技术产品中出现中国人的身影，小草已经在默默生长，假以时日，料想必有大树出现。</p><p>今天我讲的是一个SQL引擎是如何设计出来的，也许在你的工作几乎不可能去开发SQL引擎，但是了解这些基础的知识，了解一些设计的技巧，对你用好数据库，开发更加灵活、有弹性的系统也会很有帮助。</p><h2>思考题</h2><p>SQL注入是一种常见的Web攻击手段，如下图所示，攻击者在HTTP请求中注入恶意SQL命令（drop table users;），服务器用请求参数构造数据库SQL命令时，恶意SQL被一起构造，并在数据库中执行。</p><p><img src=\"https://static001.geekbang.org/resource/image/8c/4f/8c92076fc8b4005ce075734e9641cd4f.png?wh=1352*566\" alt=\"\"></p><p>但是JDBC的PrepareStatement可以阻止SQL注入攻击，MyBatis之类的ORM框架也可以阻止SQL注入，请从数据库引擎的工作机制解释PrepareStatement和MyBatis的防注入攻击的原理。</p><p>欢迎你点击“请朋友读”，把今天的文章分享给好友。也欢迎你写下自己的思考或疑问，与我和其他同学一起讨论。</p>","neighbors":{"left":{"article_title":"17 | 模块答疑：这么多技术，到底都能用在什么场景里？","id":71366},"right":{"article_title":"19 | Spark的性能优化案例分析（上）","id":72056}},"comments":[{"had_liked":false,"id":50528,"user_name":"纯洁的憎恶","can_delete":false,"product_type":"c1","uid":1130512,"ip_address":"","ucode":"5E9757DE6F45DF","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/10/b6bf3c3c.jpg","comment_is_top":false,"comment_ctime":1545007065,"is_pvip":true,"replies":[{"id":"18179","content":"清晰👍🏻","user_name":"作者回复","comment_id":50528,"uid":"1007349","ip_address":"","utype":1,"ctime":1545024618,"user_name_real":"李智慧"}],"discussion_count":1,"race_medal":0,"score":"138983960537","product_id":100020201,"comment_content":"基于SQL的大数据仓库引擎panthera的核心任务是把SQL语义与Hive AST对应起来。难点是SQL的语义远比Hive AST丰富，而幸运的事SQL丰富的表意逻辑主要源于它的嵌套子语句，这在Hive AST中是不存在的。但是SQL的嵌套子语句可以等价于若干jion操作。<br><br>为了在工程上降低实现难度，特意为每个语法点设计一个对象（类），这就将复杂问题分解为无数个小步骤，可以持续交付，不用长期等待，从而将不可能有条件的变为可能。而且每个类的代码十分简洁，遇到问题也便于各个击破。","like_count":32,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433011,"discussion_content":"清晰👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545024618,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":48105,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1544355360,"is_pvip":true,"replies":[{"id":"17341","content":"会，正在走向","user_name":"作者回复","comment_id":48105,"uid":"1007349","ip_address":"","utype":1,"ctime":1544488062,"user_name_real":"李智慧"}],"discussion_count":1,"race_medal":0,"score":"126098406944","product_id":100020201,"comment_content":"Oracle会有走向衰落吗？","like_count":29,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":432028,"discussion_content":"会，正在走向","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544488062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":47833,"user_name":"galen","can_delete":false,"product_type":"c1","uid":1119804,"ip_address":"","ucode":"93056616C4450C","user_header":"https://static001.geekbang.org/account/avatar/00/11/16/3c/eee3e6f5.jpg","comment_is_top":false,"comment_ctime":1544232679,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"100328480487","product_id":100020201,"comment_content":"因为SQL语句在程序运行前已经进行了预编译，在程序运行时第一次操作数据库之前，SQL语句已经被数据库分析，编译和优化，对应的执行计划也会缓存下来并允许数据库已参数化的形式进行查询，当运行时动态地把参数传给PreprareStatement时，即使参数里有敏感字符如 or &#39;1=1&#39;也数据库会作为一个参数一个字段的属性值来处理而不会作为一个SQL指令，如此，就起到了SQL注入的作用了","like_count":24},{"had_liked":false,"id":47822,"user_name":"欧嘉权Felix","can_delete":false,"product_type":"c1","uid":1109587,"ip_address":"","ucode":"5257A38D4D3884","user_header":"https://static001.geekbang.org/account/avatar/00/10/ee/53/b8fe4560.jpg","comment_is_top":false,"comment_ctime":1544230265,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"61673772409","product_id":100020201,"comment_content":"如果用statement jdbc会简单拼接字符串然后作为sql执行<br>preparedstatement就会进行预编译 对其中的换行符等字符做转义 对注入的sql会起到混淆的作用<br>mybatis这些orm框架也是基于preparedstatement mybatis尽量使用#占位符","like_count":14},{"had_liked":false,"id":50676,"user_name":"Well_Ksun","can_delete":false,"product_type":"c1","uid":1054147,"ip_address":"","ucode":"1FAE508F2FFDB2","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/c3/d8564fe2.jpg","comment_is_top":false,"comment_ctime":1545028569,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35904766937","product_id":100020201,"comment_content":"老师能简单聊聊presto吗？也是faceboook开源出来的。据说AWS 的 Athena 就是基于 Presto 的产品。","like_count":8},{"had_liked":false,"id":48014,"user_name":"杰之7","can_delete":false,"product_type":"c1","uid":1297232,"ip_address":"","ucode":"F7DA2E21085332","user_header":"https://static001.geekbang.org/account/avatar/00/13/cb/50/66d0bd7f.jpg","comment_is_top":false,"comment_ctime":1544322538,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35904060906","product_id":100020201,"comment_content":"从这篇文章开始，大数据技术的体系架构知识就告一段落，但并不意味着已经完全掌握，我需要不断的回顾体系架构原理，这样才会有可能沿着这个思路有自己的一点拓展。回到本篇内容，如何自己开发SQL引擎，由于Hive语法元素少于标准SQL,且不支持复杂的嵌套子查询，所以开发的难点就是如何将复杂嵌套消除转化成标准SQL。在老师讲述的过程中，主要通过装饰模式等价转化类的构造，对于每一种新的语法通过开发新的Transformer类，然后通过组合模式将抽象语法树AST进行遍历，最后转化成Hive格式的抽象语法树。通过这样的整个过程，就完成的对Hive语法解析器的替换，保留了Hive语义分析器。通过本节的学习，我相信老师说的这套思路，那些技术厉害的人不是掌握了每一种技术，而是掌握了技术背后的体系和原理，当有新的技术出现时，同样先去思考技术背后的原理是什么，这样就算没有参与其中的技术，也会新的技术有一个好的认识。","like_count":8},{"had_liked":false,"id":49656,"user_name":"反应慢","can_delete":false,"product_type":"c1","uid":1183924,"ip_address":"","ucode":"B7311CDFF2DC5D","user_header":"https://static001.geekbang.org/account/avatar/00/12/10/b4/00680e1f.jpg","comment_is_top":false,"comment_ctime":1544750431,"is_pvip":false,"replies":[{"id":"18185","content":"赞，spark也往这个方向走。","user_name":"作者回复","comment_id":49656,"uid":"1007349","ip_address":"","utype":1,"ctime":1545025664,"user_name_real":"李智慧"}],"discussion_count":1,"race_medal":0,"score":"23019586911","product_id":100020201,"comment_content":"之前有一段时间在学习函数式编程，和sql一样属于命令式编程，所以感觉以函数去解析sql是水到渠成的事情。不过至今没有动手去实现一下，比较遗憾","like_count":4,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":432705,"discussion_content":"赞，spark也往这个方向走。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545025664,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":48010,"user_name":"周翔","can_delete":false,"product_type":"c1","uid":1068734,"ip_address":"","ucode":"E5E12D9B02AF59","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/be/693b5e5e.jpg","comment_is_top":false,"comment_ctime":1544321063,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18724190247","product_id":100020201,"comment_content":"预编译就是sql命令的模板归模板，参数归参数，参数就不会混合到原sql，改变原有的sql语句和执行逻辑。除了数据访问框架本身prepare statement功能，还可以从服务层接收参数就可以屏蔽。","like_count":4},{"had_liked":false,"id":171683,"user_name":"蒙","can_delete":false,"product_type":"c1","uid":1327952,"ip_address":"","ucode":"A2246D60EE666B","user_header":"https://static001.geekbang.org/account/avatar/00/14/43/50/ef2cfbce.jpg","comment_is_top":false,"comment_ctime":1578991290,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14463893178","product_id":100020201,"comment_content":"sql预编译，应该是将原始sql先解析成语法树，入参不能影响语法树的变化","like_count":4},{"had_liked":false,"id":51772,"user_name":"明亮","can_delete":false,"product_type":"c1","uid":1303015,"ip_address":"","ucode":"DAFB3424C4C2D7","user_header":"https://static001.geekbang.org/account/avatar/00/13/e1/e7/d1b2e914.jpg","comment_is_top":false,"comment_ctime":1545236223,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14430138111","product_id":100020201,"comment_content":"可以推荐一些SQL解析的来源产品和资料吗<br>","like_count":3,"discussions":[{"author":{"id":1066058,"avatar":"https://static001.geekbang.org/account/avatar/00/10/44/4a/b85c906d.jpg","nickname":"dashboard","note":"","ucode":"03C1433D3F2E00","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302825,"discussion_content":"阿里开发的 Druid 连接池里有个纯手工的 SQL 解析器","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599039424,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":47863,"user_name":"Oliver","can_delete":false,"product_type":"c1","uid":1045957,"ip_address":"","ucode":"7B47D6031FD295","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/c5/c9a67483.jpg","comment_is_top":false,"comment_ctime":1544239056,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14429140944","product_id":100020201,"comment_content":"保证用户输入的内容仅仅且只能作为查询条件，涉及一些字符转义操作","like_count":3},{"had_liked":false,"id":149201,"user_name":"GeekGay","can_delete":false,"product_type":"c1","uid":1027335,"ip_address":"","ucode":"9194E1FB5964A1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ad/07/20e7d3cf.jpg","comment_is_top":false,"comment_ctime":1573175136,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10163109728","product_id":100020201,"comment_content":"https:&#47;&#47;github.com&#47;lealone<br><br>来看看我们桂林的大才子zhh-4096，一个人开发6年的列锁极数据库，之前也去淘宝做个一两年数据库产品的。","like_count":2},{"had_liked":false,"id":47838,"user_name":"毛毛","can_delete":false,"product_type":"c1","uid":1249698,"ip_address":"","ucode":"AD520D0011227D","user_header":"https://static001.geekbang.org/account/avatar/00/13/11/a2/33be69a6.jpg","comment_is_top":false,"comment_ctime":1544233327,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10134167919","product_id":100020201,"comment_content":"PreparedStatement会先初始化SQL，语句中只有部分变量可以被“？”替代，所以sql注入的攻击方式无效。","like_count":2},{"had_liked":false,"id":182842,"user_name":" 臣馟飞扬","can_delete":false,"product_type":"c1","uid":1116188,"ip_address":"","ucode":"F2F882B7678055","user_header":"https://static001.geekbang.org/account/avatar/00/11/08/1c/ef15e661.jpg","comment_is_top":false,"comment_ctime":1582873849,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5877841145","product_id":100020201,"comment_content":"貌似Panthera项目没有掀起任何波澜。。。","like_count":1},{"had_liked":false,"id":93860,"user_name":"都市夜归人","can_delete":false,"product_type":"c1","uid":1071909,"ip_address":"","ucode":"DFF59BE3D80B42","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/25/d78cc1fe.jpg","comment_is_top":false,"comment_ctime":1557642189,"is_pvip":true,"replies":[{"id":"33528","content":"事实上是非常简单~~ 将非常复杂的SQL语法转换解耦合，有兴趣建议看看更详细的代码","user_name":"作者回复","comment_id":93860,"uid":"1007349","ip_address":"","utype":1,"ctime":1557658542,"user_name_real":"李智慧"}],"discussion_count":2,"race_medal":0,"score":"5852609485","product_id":100020201,"comment_content":"   private static SqlASTTransformer tf =<br>      new RedundantSelectGroupItemTransformer(<br>      new DistinctTransformer(<br>      new GroupElementNormalizeTransformer(<br>      new PrepareQueryInfoTransformer(<br>      new OrderByTransformer(<br>      new OrderByFunctionTransformer(<br>      new MinusIntersectTransformer(<br>      new PrepareQueryInfoTransformer(<br>      new UnionTransformer(<br>      new Leftsemi2LeftJoinTransformer(<br>      new CountAsteriskPositionTransformer(<br>      new FilterInwardTransformer(<br>      &#47;&#47;use leftJoin method to handle not exists for correlated<br>      new CrossJoinTransformer(<br>      new PrepareQueryInfoTransformer(<br>      new SubQUnnestTransformer(<br>      new PrepareFilterBlockTransformer(<br>      new PrepareQueryInfoTransformer(<br>      new TopLevelUnionTransformer(<br>      new FilterBlockAdjustTransformer(<br>      new PrepareFilterBlockTransformer(<br>      new ExpandAsteriskTransformer(<br>      new PrepareQueryInfoTransformer(<br>      new CrossJoinTransformer(<br>      new PrepareQueryInfoTransformer(<br>      new ConditionStructTransformer(<br>      new MultipleTableSelectTransformer(<br>      new WhereConditionOptimizationTransformer(<br>      new PrepareQueryInfoTransformer(<br>      new InTransformer(<br>      new TopLevelUnionTransformer(<br>      new MinusIntersectTransformer(<br>      new NaturalJoinTransformer(<br>      new OrderByNotInSelectListTransformer(<br>      new RowNumTransformer(<br>      new BetweenTransformer(<br>      new UsingTransformer(<br>      new SchemaDotTableTransformer(<br>      new NothingTransformer())))))))))))))))))))))))))))))))))))));<br>这个类在使用的时候该有多麻烦啊？","like_count":1,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449799,"discussion_content":"事实上是非常简单~~ 将非常复杂的SQL语法转换解耦合，有兴趣建议看看更详细的代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557658542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2930333,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/b6/9d/5ba3db6e.jpg","nickname":"金桔🍊","note":"","ucode":"BB69BBE9886F37","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":554241,"discussion_content":"求详细代码，膜拜大神ing……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646278455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":449799,"ip_address":""},"score":554241,"extra":""}]}]},{"had_liked":false,"id":72695,"user_name":"cwx0220","can_delete":false,"product_type":"c1","uid":1235642,"ip_address":"","ucode":"8DEB4BD6FA5D72","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/ba/032800bc.jpg","comment_is_top":false,"comment_ctime":1551696471,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5846663767","product_id":100020201,"comment_content":"正常情况下，当http请求参数带有sql语句的条件时，在 SQL 注入中，参数值作为 SQL 指令的一部分，会被数据库进行编译&#47;解释执行。当使用了 PreparedStatement，带占位符 ( ? ) 的 sql 语句只会被编译一次，之后执行只是将占位符替换为参数值，并不会再次编译&#47;解释，因此从根本上防止了 SQL 注入问题。","like_count":1},{"had_liked":false,"id":349912,"user_name":"精思入神","can_delete":false,"product_type":"c1","uid":1035038,"ip_address":"","ucode":"D5F47DD3C7530A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJUzv6S9wroyaa2CANjhHJcwRwNESncu4lfWTtdkMh3viaVCgEg5vMXFJ4Ne4SaDtLNd9dvkUrFqPg/132","comment_is_top":false,"comment_ctime":1656423033,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1656423033","product_id":100020201,"comment_content":"这节最大的启发是，要从设计者的角度去理解，而不是老以学习者自居。否则，永无出头之日矣。","like_count":0},{"had_liked":false,"id":137236,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1569663114,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569663114","product_id":100020201,"comment_content":"猜测数据库引擎会通过某种方式，把参数就用作参数而不会作为SQL语句去执行。<br>凡事常用带入创造者的方式去思考，确实是个好方法，长期训练也许，真能做到庖丁解牛的效果。","like_count":0},{"had_liked":false,"id":61504,"user_name":"小老鼠","can_delete":false,"product_type":"c1","uid":1257460,"ip_address":"","ucode":"C663A0C863A515","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/f4/2dede51a.jpg","comment_is_top":false,"comment_ctime":1547709185,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547709185","product_id":100020201,"comment_content":"Hive QL也支持预编译吗？","like_count":0},{"had_liked":false,"id":55261,"user_name":"桃园悠然在","can_delete":false,"product_type":"c1","uid":1017637,"ip_address":"","ucode":"704460D9CAD1CB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/25/898dea4e.jpg","comment_is_top":false,"comment_ctime":1546080904,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546080904","product_id":100020201,"comment_content":"请问老师，如果目前手头使用的hive可以支持嵌套子查询，是否说明已经定制优化过了？","like_count":0}]}