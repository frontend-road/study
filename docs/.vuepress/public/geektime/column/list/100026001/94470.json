{"id":94470,"title":"08 | ELF和静态链接：为什么程序无法同时在Linux和Windows下运行？","content":"<p>过去的三节，你和我一起通过一些简单的代码，看到了我们写的程序，是怎么变成一条条计算机指令的；if…else这样的条件跳转是怎么样执行的；for/while这样的循环是怎么执行的；函数间的相互调用是怎么发生的。</p><p>我记得以前，我自己在了解完这些知识之后，产生了一个非常大的疑问。那就是，既然我们的程序最终都被变成了一条条机器码去执行，那为什么同一个程序，在同一台计算机上，在Linux下可以运行，而在Windows下却不行呢？反过来，Windows上的程序在Linux上也是一样不能执行的。可是我们的CPU并没有换掉，它应该可以识别同样的指令呀？</p><p>如果你和我有同样的疑问，那这一节，我们就一起来解开。</p><h2>编译、链接和装载：拆解程序执行</h2><p><a href=\"https://time.geekbang.org/column/article/93359\">第5节</a>我们说过，写好的C语言代码，可以通过编译器编译成汇编代码，然后汇编代码再通过汇编器变成CPU可以理解的机器码，于是CPU就可以执行这些机器码了。你现在对这个过程应该不陌生了，但是这个描述把过程大大简化了。下面，我们一起具体来看，C语言程序是如何变成一个可执行程序的。</p><p>不知道你注意到没有，过去几节，我们通过gcc生成的文件和objdump获取到的汇编指令都有些小小的问题。我们先把前面的add函数示例，拆分成两个文件add_lib.c和link_example.c。</p><!-- [[[read_end]]] --><pre><code>// add_lib.c\nint add(int a, int b)\n{\n    return a+b;\n}\n</code></pre><pre><code>// link_example.c\n\n#include &lt;stdio.h&gt;\nint main()\n{\n    int a = 10;\n    int b = 5;\n    int c = add(a, b);\n    printf(&quot;c = %d\\n&quot;, c);\n}\n</code></pre><p>我们通过gcc来编译这两个文件，然后通过objdump命令看看它们的汇编代码。</p><pre><code>$ gcc -g -c add_lib.c link_example.c\n$ objdump -d -M intel -S add_lib.o\n$ objdump -d -M intel -S link_example.o\n</code></pre><pre><code>add_lib.o:     file format elf64-x86-64\nDisassembly of section .text:\n0000000000000000 &lt;add&gt;:\n   0:   55                      push   rbp\n   1:   48 89 e5                mov    rbp,rsp\n   4:   89 7d fc                mov    DWORD PTR [rbp-0x4],edi\n   7:   89 75 f8                mov    DWORD PTR [rbp-0x8],esi\n   a:   8b 55 fc                mov    edx,DWORD PTR [rbp-0x4]\n   d:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]\n  10:   01 d0                   add    eax,edx\n  12:   5d                      pop    rbp\n  13:   c3                      ret    \n</code></pre><pre><code>link_example.o:     file format elf64-x86-64\nDisassembly of section .text:\n0000000000000000 &lt;main&gt;:\n   0:   55                      push   rbp\n   1:   48 89 e5                mov    rbp,rsp\n   4:   48 83 ec 10             sub    rsp,0x10\n   8:   c7 45 fc 0a 00 00 00    mov    DWORD PTR [rbp-0x4],0xa\n   f:   c7 45 f8 05 00 00 00    mov    DWORD PTR [rbp-0x8],0x5\n  16:   8b 55 f8                mov    edx,DWORD PTR [rbp-0x8]\n  19:   8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]\n  1c:   89 d6                   mov    esi,edx\n  1e:   89 c7                   mov    edi,eax\n  20:   b8 00 00 00 00          mov    eax,0x0\n  25:   e8 00 00 00 00          call   2a &lt;main+0x2a&gt;\n  2a:   89 45 f4                mov    DWORD PTR [rbp-0xc],eax\n  2d:   8b 45 f4                mov    eax,DWORD PTR [rbp-0xc]\n  30:   89 c6                   mov    esi,eax\n  32:   48 8d 3d 00 00 00 00    lea    rdi,[rip+0x0]        # 39 &lt;main+0x39&gt;\n  39:   b8 00 00 00 00          mov    eax,0x0\n  3e:   e8 00 00 00 00          call   43 &lt;main+0x43&gt;\n  43:   b8 00 00 00 00          mov    eax,0x0\n  48:   c9                      leave  \n  49:   c3                      ret    \n</code></pre><p>既然代码已经被我们“编译”成了指令，我们不妨尝试运行一下 ./link_example.o。</p><p>不幸的是，文件没有执行权限，我们遇到一个Permission denied错误。即使通过chmod命令赋予link_example.o文件可执行的权限，运行./link_example.o仍然只会得到一条cannot execute binary file: Exec format error的错误。</p><p>我们再仔细看一下objdump出来的两个文件的代码，会发现两个程序的地址都是从0开始的。如果地址是一样的，程序如果需要通过call指令调用函数的话，它怎么知道应该跳转到哪一个文件里呢？</p><p>这么说吧，无论是这里的运行报错，还是objdump出来的汇编代码里面的重复地址，都是因为 add_lib.o 以及 link_example.o并不是一个<strong>可执行文件</strong>（Executable Program），而是<strong>目标文件</strong>（Object File）。只有通过链接器（Linker）把多个目标文件以及调用的各种函数库链接起来，我们才能得到一个可执行文件。</p><p>我们通过gcc的-o参数，可以生成对应的可执行文件，对应执行之后，就可以得到这个简单的加法调用函数的结果。</p><pre><code>$ gcc -o link-example add_lib.o link_example.o\n$ ./link_example\nc = 15\n</code></pre><p>实际上，“<strong>C语言代码-汇编代码-机器码</strong>”  这个过程，在我们的计算机上进行的时候是由两部分组成的。</p><p>第一个部分由编译（Compile）、汇编（Assemble）以及链接（Link）三个阶段组成。在这三个阶段完成之后，我们就生成了一个可执行文件。</p><p>第二部分，我们通过装载器（Loader）把可执行文件装载（Load）到内存中。CPU从内存中读取指令和数据，来开始真正执行程序。</p><p><img src=\"https://static001.geekbang.org/resource/image/99/a7/997341ed0fa9018561c7120c19cfa2a7.jpg?wh=1767*1535\" alt=\"\"></p><h2>ELF格式和链接：理解链接过程</h2><p>程序最终是通过装载器变成指令和数据的，所以其实我们生成的可执行代码也并不仅仅是一条条的指令。我们还是通过objdump指令，把可执行文件的内容拿出来看看。</p><pre><code>link_example:     file format elf64-x86-64\nDisassembly of section .init:\n...\nDisassembly of section .plt:\n...\nDisassembly of section .plt.got:\n...\nDisassembly of section .text:\n...\n\n 6b0:   55                      push   rbp\n 6b1:   48 89 e5                mov    rbp,rsp\n 6b4:   89 7d fc                mov    DWORD PTR [rbp-0x4],edi\n 6b7:   89 75 f8                mov    DWORD PTR [rbp-0x8],esi\n 6ba:   8b 55 fc                mov    edx,DWORD PTR [rbp-0x4]\n 6bd:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]\n 6c0:   01 d0                   add    eax,edx\n 6c2:   5d                      pop    rbp\n 6c3:   c3                      ret    \n00000000000006c4 &lt;main&gt;:\n 6c4:   55                      push   rbp\n 6c5:   48 89 e5                mov    rbp,rsp\n 6c8:   48 83 ec 10             sub    rsp,0x10\n 6cc:   c7 45 fc 0a 00 00 00    mov    DWORD PTR [rbp-0x4],0xa\n 6d3:   c7 45 f8 05 00 00 00    mov    DWORD PTR [rbp-0x8],0x5\n 6da:   8b 55 f8                mov    edx,DWORD PTR [rbp-0x8]\n 6dd:   8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]\n 6e0:   89 d6                   mov    esi,edx\n 6e2:   89 c7                   mov    edi,eax\n 6e4:   b8 00 00 00 00          mov    eax,0x0\n 6e9:   e8 c2 ff ff ff          call   6b0 &lt;add&gt;\n 6ee:   89 45 f4                mov    DWORD PTR [rbp-0xc],eax\n 6f1:   8b 45 f4                mov    eax,DWORD PTR [rbp-0xc]\n 6f4:   89 c6                   mov    esi,eax\n 6f6:   48 8d 3d 97 00 00 00    lea    rdi,[rip+0x97]        # 794 &lt;_IO_stdin_used+0x4&gt;\n 6fd:   b8 00 00 00 00          mov    eax,0x0\n 702:   e8 59 fe ff ff          call   560 &lt;printf@plt&gt;\n 707:   b8 00 00 00 00          mov    eax,0x0\n 70c:   c9                      leave  \n 70d:   c3                      ret    \n 70e:   66 90                   xchg   ax,ax\n...\nDisassembly of section .fini:\n...\n</code></pre><p>你会发现，可执行代码dump出来内容，和之前的目标代码长得差不多，但是长了很多。因为在Linux下，可执行文件和目标文件所使用的都是一种叫<strong>ELF</strong>（Execuatable and Linkable File Format）的文件格式，中文名字叫<strong>可执行与可链接文件格式</strong>，这里面不仅存放了编译成的汇编指令，还保留了很多别的数据。</p><p>比如我们过去所有objdump出来的代码里，你都可以看到对应的函数名称，像add、main等等，乃至你自己定义的全局可以访问的变量名称，都存放在这个ELF格式文件里。这些名字和它们对应的地址，在ELF文件里面，存储在一个叫作<strong>符号表</strong>（Symbols Table）的位置里。符号表相当于一个地址簿，把名字和地址关联了起来。</p><p>我们先只关注和我们的add以及main函数相关的部分。你会发现，这里面，main函数里调用add的跳转地址，不再是下一条指令的地址了，而是add函数的入口地址了，这就是EFL格式和链接器的功劳。</p><p><img src=\"https://static001.geekbang.org/resource/image/27/b3/276a740d0eabf5f4be905fe7326d9fb3.jpg?wh=2142*1116\" alt=\"\"></p><p>ELF文件格式把各种信息，分成一个一个的Section保存起来。ELF有一个基本的文件头（File Header），用来表示这个文件的基本属性，比如是否是可执行文件，对应的CPU、操作系统等等。除了这些基本属性之外，大部分程序还有这么一些Section：</p><ol>\n<li>\n<p>首先是.text Section，也叫作<strong>代码段</strong>或者指令段（Code Section），用来保存程序的代码和指令；</p>\n</li>\n<li>\n<p>接着是.data Section，也叫作<strong>数据段</strong>（Data Section），用来保存程序里面设置好的初始化数据信息；</p>\n</li>\n<li>\n<p>然后就是.rel.text Secion，叫作<strong>重定位表</strong>（Relocation Table）。重定位表里，保留的是当前的文件里面，哪些跳转地址其实是我们不知道的。比如上面的 link_example.o 里面，我们在main函数里面调用了 add 和 printf 这两个函数，但是在链接发生之前，我们并不知道该跳转到哪里，这些信息就会存储在重定位表里；</p>\n</li>\n<li>\n<p>最后是.symtab Section，叫作<strong>符号表</strong>（Symbol Table）。符号表保留了我们所说的当前文件里面定义的函数名称和对应地址的地址簿。</p>\n</li>\n</ol><p>链接器会扫描所有输入的目标文件，然后把所有符号表里的信息收集起来，构成一个全局的符号表。然后再根据重定位表，把所有不确定要跳转地址的代码，根据符号表里面存储的地址，进行一次修正。最后，把所有的目标文件的对应段进行一次合并，变成了最终的可执行代码。这也是为什么，可执行文件里面的函数调用的地址都是正确的。</p><p><img src=\"https://static001.geekbang.org/resource/image/f6/12/f62da9b29aa53218f8907851df27f912.jpeg?wh=3106*2026\" alt=\"\"></p><p>在链接器把程序变成可执行文件之后，要装载器去执行程序就容易多了。装载器不再需要考虑地址跳转的问题，只需要解析 ELF 文件，把对应的指令和数据，加载到内存里面供CPU执行就可以了。</p><h2>总结延伸</h2><p>讲到这里，相信你已经猜到，为什么同样一个程序，在Linux下可以执行而在Windows下不能执行了。其中一个非常重要的原因就是，两个操作系统下可执行文件的格式不一样。</p><p>我们今天讲的是Linux下的ELF文件格式，而Windows的可执行文件格式是一种叫作<strong>PE</strong>（Portable Executable Format）的文件格式。Linux下的装载器只能解析ELF格式而不能解析PE格式。</p><p>如果我们有一个可以能够解析PE格式的装载器，我们就有可能在Linux下运行Windows程序了。这样的程序真的存在吗？没错，Linux下著名的开源项目Wine，就是通过兼容PE格式的装载器，使得我们能直接在Linux下运行Windows程序的。而现在微软的Windows里面也提供了WSL，也就是Windows Subsystem for Linux，可以解析和加载ELF格式的文件。</p><p>我们去写可以用的程序，也不仅仅是把所有代码放在一个文件里来编译执行，而是可以拆分成不同的函数库，最后通过一个静态链接的机制，使得不同的文件之间既有分工，又能通过静态链接来“合作”，变成一个可执行的程序。</p><p>对于ELF格式的文件，为了能够实现这样一个静态链接的机制，里面不只是简单罗列了程序所需要执行的指令，还会包括链接所需要的重定位表和符号表。</p><h2>推荐阅读</h2><p>想要更深入了解程序的链接过程和ELF格式，我推荐你阅读《程序员的自我修养——链接、装载和库》的1～4章。这是一本难得的讲解程序的链接、装载和运行的好书。</p><h2>课后思考</h2><p>你可以通过readelf读取出今天演示程序的符号表，看看符号表里都有哪些信息；然后通过objdump读取出今天演示程序的重定位表，看看里面又有哪些信息。</p><p>欢迎留言和我分享你的思考和疑惑，你也可以把今天的内容分享给你的朋友，和他一起学习和进步。</p><p></p>","neighbors":{"left":{"article_title":"07 | 函数调用：为什么会发生stack overflow？","id":94427},"right":{"article_title":"09 | 程序装载：“640K内存”真的不够用么？","id":95223}},"comments":[{"had_liked":false,"id":103760,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1560504092,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"409582397212","product_id":100026001,"comment_content":"readelf -s link_example.o &#47;&#47;查看符号表<br>objdump -r link_example.o &#47;&#47;查看重定位表","like_count":96},{"had_liked":false,"id":94120,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1557724747,"is_pvip":true,"replies":[{"id":"33627","content":"一步同学你好，当然，因为很多程序还依赖各种操作系统本身提供的动态链接库，系统调用等等。需要wine提供对应的实现，兼容格式只是万里长征第一步。","user_name":"作者回复","comment_id":94120,"uid":"1053568","ip_address":"","utype":1,"ctime":1557746988,"user_name_real":"徐文浩"}],"discussion_count":2,"race_medal":1,"score":"267845697099","product_id":100026001,"comment_content":"老师，我曾经在linux上使用过wine，有好多window软件不能很好兼容的运行，这是为什么呢？是不是除了执行文件格式之外，还有其他的因素影响软件的运行呢？","like_count":63,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449920,"discussion_content":"一步同学你好，当然，因为很多程序还依赖各种操作系统本身提供的动态链接库，系统调用等等。需要wine提供对应的实现，兼容格式只是万里长征第一步。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1557746988,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1724769,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLICDTy3Aglb3VvyYjSiaR0tkh6jjojiaa8qiccpRHjXGmnJD72iccU36ic29piaenZrREkR1GoPJK1zU9g/132","nickname":"hdongdong123","note":"","ucode":"D74589952987D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363372,"discussion_content":"windows好多东西是闭源的，很多东西都要自己实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617182892,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94113,"user_name":"有米","can_delete":false,"product_type":"c1","uid":1005042,"ip_address":"","ucode":"C9A10B7A67BC12","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/f2/ba68d931.jpg","comment_is_top":false,"comment_ctime":1557723494,"is_pvip":false,"replies":[{"id":"33632","content":"Java是通过实现不同平台上的虚拟机，然后即时翻译javac生成的中间代码来做到跨平台的。跨平台的工作被虚拟机开发人员来解决了","user_name":"作者回复","comment_id":94113,"uid":"1053568","ip_address":"","utype":1,"ctime":1557747153,"user_name_real":"徐文浩"}],"discussion_count":1,"race_medal":0,"score":"220601055590","product_id":100026001,"comment_content":"Java的跨平台运行是如何做到的呢？跟本节内容有关系吗？","like_count":52,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449918,"discussion_content":"Java是通过实现不同平台上的虚拟机，然后即时翻译javac生成的中间代码来做到跨平台的。跨平台的工作被虚拟机开发人员来解决了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557747153,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95764,"user_name":"二星球","can_delete":false,"product_type":"c1","uid":1111552,"ip_address":"","ucode":"89EC5FEB98E7CE","user_header":"https://static001.geekbang.org/account/avatar/00/10/f6/00/2a248fd8.jpg","comment_is_top":false,"comment_ctime":1558168202,"is_pvip":false,"replies":[{"id":"35542","content":"可以这样理解。实际机器启动加电的时候是从BIOS去读取MBR，再加载操作系统等等。<br><br>PE和ELF是在操作系统加载之后的事情了。","user_name":"作者回复","comment_id":95764,"uid":"1053568","ip_address":"","utype":1,"ctime":1559132831,"user_name_real":"徐文浩"}],"discussion_count":3,"race_medal":0,"score":"126112219786","product_id":100026001,"comment_content":"老师好，就是没有操作系统，直接在硬件上运行的可执行程序，其格式应该不是pe或elf，应该是纯的机器指令吧，pe或elf格式的可执行程序是跟操作系统绑定的，经过翻译后成为纯机器指令，才能被执行，不知道这样理解对不。","like_count":30,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450590,"discussion_content":"可以这样理解。实际机器启动加电的时候是从BIOS去读取MBR，再加载操作系统等等。\n\nPE和ELF是在操作系统加载之后的事情了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1559132831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2976412,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/6a/9c/de8f9280.jpg","nickname":"刚毅坚卓","note":"","ucode":"6D16E587400F6F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":571871,"discussion_content":"老师，汇编语言是通pe或elf格式的可执行程序翻译之后才变成成机器指令吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652436498,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":450590,"ip_address":""},"score":571871,"extra":""}]},{"author":{"id":2837328,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/4b/50/fae00aff.jpg","nickname":"HollyWong","note":"","ucode":"03A66A2BCC0A58","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":412364,"discussion_content":"如果CPU一个一个系列，那生成的机器指令应该是一样的，只是不同的OS把他们以不同的方式封装了，所以需要OS自己的加载器去解析，然后放到内存中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636127485,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94286,"user_name":"二星球","can_delete":false,"product_type":"c1","uid":1111552,"ip_address":"","ucode":"89EC5FEB98E7CE","user_header":"https://static001.geekbang.org/account/avatar/00/10/f6/00/2a248fd8.jpg","comment_is_top":false,"comment_ctime":1557759767,"is_pvip":false,"replies":[{"id":"34191","content":"如果不是pe格式也不是elf格式，就不能执行啊。能执行是因为实际执行的不是你的程序。比如你写了一段python代码，实际执行的是python解释器，而不是你的py代码","user_name":"作者回复","comment_id":94286,"uid":"1053568","ip_address":"","utype":1,"ctime":1558099698,"user_name_real":"徐文浩"}],"discussion_count":2,"race_medal":0,"score":"117521876759","product_id":100026001,"comment_content":"老师好，我有个问题，就是我可以用编程语言写一个不依赖操作系统的可执行程序，这个可执行程序不是pe格式，也不是elf的，那为什能执行呢，是不是因为这个可执行程序全是纯的cpu指令，没有其他要解析的东西？","like_count":27,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450001,"discussion_content":"如果不是pe格式也不是elf格式，就不能执行啊。能执行是因为实际执行的不是你的程序。比如你写了一段python代码，实际执行的是python解释器，而不是你的py代码","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1558099698,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2976412,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/6a/9c/de8f9280.jpg","nickname":"刚毅坚卓","note":"","ucode":"6D16E587400F6F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571872,"discussion_content":"解释器把我们写的代码转化为汇编语言，然后再把汇编语言转化为机器指令，放到可执行文件中，通过装载器放到内存的虚拟空间中去","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652436648,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96955,"user_name":"陆离","can_delete":false,"product_type":"c1","uid":1483932,"ip_address":"","ucode":"2C8C206CE36A81","user_header":"https://static001.geekbang.org/account/avatar/00/16/a4/9c/b32ed9e9.jpg","comment_is_top":false,"comment_ctime":1558563512,"is_pvip":false,"replies":[{"id":"35484","content":"如果是编译型的语言都是这样的。<br><br>也有通过解释器，或者虚拟机，转换成实际的机器码指令执行的。","user_name":"作者回复","comment_id":96955,"uid":"1053568","ip_address":"","utype":1,"ctime":1559124314,"user_name_real":"徐文浩"}],"discussion_count":1,"race_medal":0,"score":"96047844024","product_id":100026001,"comment_content":"高级语言都是先编译成汇编语言，再汇编成机器码执行的吗？","like_count":23,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451078,"discussion_content":"如果是编译型的语言都是这样的。\n\n也有通过解释器，或者虚拟机，转换成实际的机器码指令执行的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559124314,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94043,"user_name":"Spring","can_delete":false,"product_type":"c1","uid":1222211,"ip_address":"","ucode":"8175463FB4705B","user_header":"https://static001.geekbang.org/account/avatar/00/12/a6/43/cb6ab349.jpg","comment_is_top":false,"comment_ctime":1557709434,"is_pvip":false,"replies":[{"id":"33635","content":"简单地说，可以认为是在汇编之后变成了机器码放在了elf的代码段里。","user_name":"作者回复","comment_id":94043,"uid":"1053568","ip_address":"","utype":1,"ctime":1557747338,"user_name_real":"徐文浩"}],"discussion_count":1,"race_medal":0,"score":"87457055354","product_id":100026001,"comment_content":"补充一下:<br>ELF其实是一种文件格式的标准，ELF文件有三类:可重定向文件、可执行文件、共享目标文件。代码经过预处理、编译、汇编后形成可重定向文件，可重定向文件经过链接后生成可执行文件。<br>另外我想请教一下，机器码是在哪一步形成的？","like_count":21,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449886,"discussion_content":"简单地说，可以认为是在汇编之后变成了机器码放在了elf的代码段里。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557747338,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94065,"user_name":"有铭","can_delete":false,"product_type":"c1","uid":1046302,"ip_address":"","ucode":"2C7CB36CA5C04C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/3XbCueYYVWTiclv8T5tFpwiblOxLphvSZxL4ujMdqVMibZnOiaFK2C5nKRGv407iaAsrI0CDICYVQJtiaITzkjfjbvrQ/132","comment_is_top":false,"comment_ctime":1557712548,"is_pvip":false,"replies":[{"id":"33629","content":"除了系统调用，还要考虑是否有动态链接库的依赖等等","user_name":"作者回复","comment_id":94065,"uid":"1053568","ip_address":"","utype":1,"ctime":1557747054,"user_name_real":"徐文浩"}],"discussion_count":1,"race_medal":0,"score":"65982221988","product_id":100026001,"comment_content":"所以理论上，只要不涉及到windows和linux的系统api调用，理论上只要搞定了可执行文件格式这个问题，那么C程序就是二进制可移植的？","like_count":16,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449900,"discussion_content":"除了系统调用，还要考虑是否有动态链接库的依赖等等","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557747054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122905,"user_name":"被过去推开","can_delete":false,"product_type":"c1","uid":1276690,"ip_address":"","ucode":"8B4F34FE93FD5B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Cib5umA0W17N9pichI08pnrXAExdbyh7AVzH4nEhD6KN3FXuELk4LJJuqUPPD7xmIy9nq5Hjbgnzic7sVZG5BKiaUQ/132","comment_is_top":false,"comment_ctime":1565572293,"is_pvip":false,"replies":[{"id":"52681","content":"👍","user_name":"作者回复","comment_id":122905,"uid":"1053568","ip_address":"","utype":1,"ctime":1569662923,"user_name_real":"徐文浩"}],"discussion_count":2,"race_medal":0,"score":"48810212549","product_id":100026001,"comment_content":"Java的类加载是由jvm完成，大致过程为装载-链接-初始化-运行，所以是jvm帮我们屏蔽了操作系统之间的差异。为了加快程序启动速度，一些类会延迟加载，所以jvm中有很多动态链接。","like_count":12,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462448,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569662923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1276690,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Cib5umA0W17N9pichI08pnrXAExdbyh7AVzH4nEhD6KN3FXuELk4LJJuqUPPD7xmIy9nq5Hjbgnzic7sVZG5BKiaUQ/132","nickname":"被过去推开","note":"","ucode":"8B4F34FE93FD5B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4601,"discussion_content":"关于动态链接理解有误。因为运行时才知道调用方法的实际引用对象，才会用上动态链接。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565585960,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261499,"user_name":"罗耀龙@坐忘","can_delete":false,"product_type":"c1","uid":1917663,"ip_address":"","ucode":"3CEA258DE7F3C7","user_header":"https://static001.geekbang.org/account/avatar/00/1d/42/df/a034455d.jpg","comment_is_top":false,"comment_ctime":1605362171,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"40260067835","product_id":100026001,"comment_content":"茶艺师学编程<br><br>关键词<br><br>编译 complie<br>汇编 assemble<br>链接 link<br>装载 load<br>装载器 loader<br>链接器 linker<br>目标代码 object program<br>可执行文件 executable flie<br><br>可执行可链接文件 ELF executable and linkable file format<br>符号表 symbols table <br>file header <br>.text section 代码段 （code section ）<br>.data section 数据段<br>.rel text section 重定位 （relocation  table）<br>.symbols section 符号表<br><br>PE protable executable format","like_count":9},{"had_liked":false,"id":97945,"user_name":"kdb_reboot","can_delete":false,"product_type":"c1","uid":1003594,"ip_address":"","ucode":"4C56FCA563FCA3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/50/4a/04fef27f.jpg","comment_is_top":false,"comment_ctime":1558848979,"is_pvip":false,"replies":[{"id":"35462","content":"没错，不过其实你不加入对应的申明编译和运行也是能执行的，但是会有编译器的告警。","user_name":"作者回复","comment_id":97945,"uid":"1053568","ip_address":"","utype":1,"ctime":1559122115,"user_name_real":"徐文浩"}],"discussion_count":1,"race_medal":0,"score":"35918587347","product_id":100026001,"comment_content":"这里(gcc -g -c add_lib.c link_example.c)需要extern int addd(int a, int b);","like_count":8,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451484,"discussion_content":"没错，不过其实你不加入对应的申明编译和运行也是能执行的，但是会有编译器的告警。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559122115,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94158,"user_name":"曾经瘦过","can_delete":false,"product_type":"c1","uid":1240106,"ip_address":"","ucode":"57C32575A1C1FD","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/2a/b11d5ad8.jpg","comment_is_top":false,"comment_ctime":1557734589,"is_pvip":false,"replies":[{"id":"33646","content":"👍这本书对于做系统开发的同学是必读书目之一。","user_name":"作者回复","comment_id":94158,"uid":"1053568","ip_address":"","utype":1,"ctime":1557747964,"user_name_real":"徐文浩"}],"discussion_count":3,"race_medal":0,"score":"31622505661","product_id":100026001,"comment_content":"mark   后面去读一读 程序员的自我修养","like_count":7,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449934,"discussion_content":"👍这本书对于做系统开发的同学是必读书目之一。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557747964,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2763179,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/29/ab/59a6e437.jpg","nickname":"Kevin","note":"","ucode":"3588850B3370C8","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572732,"discussion_content":"不可以，即使是做前端开发，懂得计算机底层技术，也会让人眼界更加开阔，遇到问题解决起来才不会啥也不知道。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652941588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1736720,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/80/10/2406a662.jpg","nickname":"希言自然","note":"","ucode":"8D99A82B05636B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408230,"discussion_content":"我可以理解，系统开发和软件开发是2个概念吧，如果单纯只是软件开发的同学是不是可以绕道，只要理解你本课所讲的知识信息就足够了呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635210878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200984,"user_name":"WENMURAN","can_delete":false,"product_type":"c1","uid":1915404,"ip_address":"","ucode":"5D1CE8B41937C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXNhbTULKiakib8lYXrvGF2zPwfedooBzC2EtSv1nt1MwV1KUvTkcJrvCBFvcdwJicnr3OEXnk9GUCg/132","comment_is_top":false,"comment_ctime":1585702900,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"27355506676","product_id":100026001,"comment_content":"ELF和静态链接<br>   在“C语言代码-汇编代码-机器码”的过程中，计算机执行时由两部分组成：一：编译、汇编、链接。二：通过装载器把可执行文件装载到内存中。<br>   C语言代码&gt;编译器&gt;汇编代码&gt;汇编器&gt;目标文件+静态程序库&gt;链接器&gt;可执行文件&gt;加载器&lt;内存中的过程和数据&lt; CPU<br>从目标代码到可执行文件的过程中，经过了一道叫ELF的手续，它有个符号表，把之前的函数名变量名等到都保存起来，并且和地址关联起来，ELF文件格式把之前的各种信息分成一个一个section保存起来，包括跳转信息。然后CPU这边的加载器只要根据ELF的格式识别一下就可以直接执行了。<br>Section还有这些东西：代码段（保存指令），数据段（保存初始化数据信息），重定位表（跳转地址），符号表。<br>感觉ELF就像再加一层的编译","like_count":6,"discussions":[{"author":{"id":2445350,"avatar":"https://static001.geekbang.org/account/avatar/00/25/50/26/0e9e87af.jpg","nickname":"陈冰清","note":"","ucode":"69C4D94079E84D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351751,"discussion_content":"你这个解释 比作者解释的清晰多了。。我感觉我看懂人话了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614424166,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138161,"user_name":"疯狂土豆","can_delete":false,"product_type":"c1","uid":1273966,"ip_address":"","ucode":"16ADC351B57151","user_header":"https://static001.geekbang.org/account/avatar/00/13/70/6e/27f43b70.jpg","comment_is_top":false,"comment_ctime":1570070392,"is_pvip":false,"replies":[{"id":"53156","content":"盗马将同学，你好<br><br>6b1你可以认为是一个行号，也就是这条指令的内存地址<br>48 89 e5 是指这条指令的二进制表示，用16进制的方式书写出来。毕竟写一堆0和1太占地方了。","user_name":"作者回复","comment_id":138161,"uid":"1053568","ip_address":"","utype":1,"ctime":1570084627,"user_name_real":"徐文浩"}],"discussion_count":2,"race_medal":0,"score":"27339874168","product_id":100026001,"comment_content":"老师，我非科班出身，现在正在看汇编，像上面的汇编片段，我知道汇编指令，但是汇编指令之前的是什么东西，6b1:   48 89 e5                mov    rbp,中的6b1:   48 89 e5大概是干什么用的，汇编刚刚开始学，像JVM等编译的字节码都有这些东西。只希望可以看懂这些是干什么用的。谢谢老师","like_count":6,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469418,"discussion_content":"盗马将同学，你好\n\n6b1你可以认为是一个行号，也就是这条指令的内存地址\n48 89 e5 是指这条指令的二进制表示，用16进制的方式书写出来。毕竟写一堆0和1太占地方了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570084627,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1273966,"avatar":"https://static001.geekbang.org/account/avatar/00/13/70/6e/27f43b70.jpg","nickname":"疯狂土豆","note":"","ucode":"16ADC351B57151","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24326,"discussion_content":"谢谢老师，你之后还会出别的专栏吗？像汇编语言操作系统或者其他的，这样的课程对我们非科班出身的挺不错的！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570096518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94056,"user_name":"Only now","can_delete":false,"product_type":"c1","uid":1038574,"ip_address":"","ucode":"C617473A03AE27","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d8/ee/6e7c2264.jpg","comment_is_top":false,"comment_ctime":1557710879,"is_pvip":false,"replies":[{"id":"33634","content":"👍程序员的自我修养是一本好书。这个专栏的主题是组成原理，希望能带大家入个门。更深入地要去再花时间看书哦","user_name":"作者回复","comment_id":94056,"uid":"1053568","ip_address":"","utype":1,"ctime":1557747246,"user_name_real":"徐文浩"}],"discussion_count":1,"race_medal":0,"score":"23032547359","product_id":100026001,"comment_content":"mark <br>本章内容确实在链接装载与库里有更详尽的说明。","like_count":5,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449896,"discussion_content":"👍程序员的自我修养是一本好书。这个专栏的主题是组成原理，希望能带大家入个门。更深入地要去再花时间看书哦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557747246,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176641,"user_name":"程序水果宝","can_delete":false,"product_type":"c1","uid":1371633,"ip_address":"","ucode":"1700DDFE073A56","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqyicZYyW7ahaXgXUD8ZAS8x0t8jx5rYLhwbUCJiawRepKIZfsLdkxdQ9XQMo99c1UDibmNVfFnAqwPg/132","comment_is_top":false,"comment_ctime":1581126798,"is_pvip":false,"replies":[{"id":"68640","content":"程序水果宝同学，<br><br>objdump命令并不是从6b0开始，只是add函数的text section从6b0开始而已。你可以自己试着在本地dump出来看一下。<br><br>ELF格式的文件有很多section，也有header部分，里面的地址本质上是一个相对的偏移量。想要对ELF格式做更深入的研究，推荐可以先花点时间看完《程序员的自我修养》这本书。","user_name":"作者回复","comment_id":176641,"uid":"1053568","ip_address":"","utype":1,"ctime":1581222368,"user_name_real":"徐文浩"}],"discussion_count":1,"race_medal":0,"score":"18760995982","product_id":100026001,"comment_content":"为啥通过 gcc 的 -o 参数生成对应的可执行文件后，再执行objdump命令查看到的地址不是从0开始而是从6b0开始","like_count":4,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483168,"discussion_content":"程序水果宝同学，\n\nobjdump命令并不是从6b0开始，只是add函数的text section从6b0开始而已。你可以自己试着在本地dump出来看一下。\n\nELF格式的文件有很多section，也有header部分，里面的地址本质上是一个相对的偏移量。想要对ELF格式做更深入的研究，推荐可以先花点时间看完《程序员的自我修养》这本书。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581222368,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123327,"user_name":"skye","can_delete":false,"product_type":"c1","uid":1027840,"ip_address":"","ucode":"C55C9F52C78A00","user_header":"https://static001.geekbang.org/account/avatar/00/0f/af/00/9b49f42b.jpg","comment_is_top":false,"comment_ctime":1565659441,"is_pvip":false,"replies":[{"id":"52673","content":"skye同学，<br><br>你好，据我所知是没有。这个硬件上的指令集差异避不开啊。","user_name":"作者回复","comment_id":123327,"uid":"1053568","ip_address":"","utype":1,"ctime":1569662620,"user_name_real":"徐文浩"}],"discussion_count":1,"race_medal":0,"score":"18745528625","product_id":100026001,"comment_content":"老师，嵌入式开发都需要交叉编译，这个是因为CPU的指令集差异，现在什么方法屏蔽这个差异，实现不交叉编译也能实现程序在嵌入式设备上的运行吗？","like_count":4,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462624,"discussion_content":"skye同学，\n\n你好，据我所知是没有。这个硬件上的指令集差异避不开啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569662620,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94118,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1557724621,"is_pvip":true,"discussion_count":1,"race_medal":1,"score":"18737593805","product_id":100026001,"comment_content":"老师问一下Mac系统的可执行文件格式是什么，也是ELF吗？还是mac自己有自己一套？","like_count":4,"discussions":[{"author":{"id":1274118,"avatar":"https://static001.geekbang.org/account/avatar/00/13/71/06/e17159a9.jpg","nickname":"peterkalven","note":"","ucode":"74AF1D2A01E563","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634,"discussion_content":"mac下的可执行文件格式是Mach-O。参见https://www.jianshu.com/p/21850560caf0","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1561852066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94011,"user_name":"lzhao","can_delete":false,"product_type":"c1","uid":1509217,"ip_address":"","ucode":"9E71888215D3E1","user_header":"","comment_is_top":false,"comment_ctime":1557706418,"is_pvip":false,"replies":[{"id":"33636","content":"👍希望对大家有所帮助","user_name":"作者回复","comment_id":94011,"uid":"1053568","ip_address":"","utype":1,"ctime":1557747353,"user_name_real":"徐文浩"}],"discussion_count":1,"race_medal":0,"score":"18737575602","product_id":100026001,"comment_content":"上周五还在思考这个问题？这答案说来就来，及时雨宋江","like_count":4,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449870,"discussion_content":"👍希望对大家有所帮助","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557747353,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":260986,"user_name":"人在江湖龙在江湖","can_delete":false,"product_type":"c1","uid":2285946,"ip_address":"","ucode":"20850038573DAE","user_header":"https://static001.geekbang.org/account/avatar/00/22/e1/7a/b206cded.jpg","comment_is_top":false,"comment_ctime":1605167226,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14490069114","product_id":100026001,"comment_content":"这一节可执行文件最好用gdb一步一步调试，最好看看每一步汇编，详细的看看内部一些细节才好。推荐陈皓10年前写的“用GDB调试程序”系列：https:&#47;&#47;blog.csdn.net&#47;haoel&#47;article&#47;details&#47;2879","like_count":3},{"had_liked":false,"id":94126,"user_name":"你好呀","can_delete":false,"product_type":"c1","uid":1049361,"ip_address":"","ucode":"2E97656410BACA","user_header":"https://static001.geekbang.org/account/avatar/00/10/03/11/f58c6278.jpg","comment_is_top":false,"comment_ctime":1557726287,"is_pvip":false,"replies":[{"id":"33626","content":"闫循鸣同学你好，关于这一部分，可以看下一讲的程序加载","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1557746890,"ip_address":"","comment_id":94126,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14442628175","product_id":100026001,"comment_content":"整个elf文件都加载到内存吗，还是只加载一部分？","like_count":3,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449924,"discussion_content":"闫循鸣同学你好，关于这一部分，可以看下一讲的程序加载","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557746890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167052,"user_name":"Dana","can_delete":false,"product_type":"c1","uid":1241142,"ip_address":"","ucode":"FE94F5E3987DBA","user_header":"https://static001.geekbang.org/account/avatar/00/12/f0/36/020428c7.jpg","comment_is_top":false,"comment_ctime":1577678123,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10167612715","product_id":100026001,"comment_content":"Linux 系统 最后可执行为的文件为 ELF","like_count":2},{"had_liked":false,"id":124666,"user_name":"袭","can_delete":false,"product_type":"c1","uid":1077573,"ip_address":"","ucode":"D5B8609CDFB145","user_header":"https://static001.geekbang.org/account/avatar/00/10/71/45/126cd913.jpg","comment_is_top":false,"comment_ctime":1565939831,"is_pvip":false,"replies":[{"id":"52662","content":"袭同学你好，<br><br>这个看到后面的程序装载和动态链接部分应该就明白了。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1569661883,"ip_address":"","comment_id":124666,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10155874423","product_id":100026001,"comment_content":"老师请问下，为什么visua studio里面除了静态库以外还有动态库，以及需要指定额外依赖等？","like_count":2,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463268,"discussion_content":"袭同学你好，\n\n这个看到后面的程序装载和动态链接部分应该就明白了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569661883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":353413,"user_name":"X","can_delete":false,"product_type":"c1","uid":1581509,"ip_address":"上海","ucode":"BE05C1D25CE313","user_header":"https://static001.geekbang.org/account/avatar/00/18/21/c5/024e1ef1.jpg","comment_is_top":false,"comment_ctime":1659424917,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5954392213","product_id":100026001,"comment_content":"可执行文件通过装载器，将各个指令装载到内存中，cpu通过读取内存中的指令并执行，将执行结果往输出设备输出。","like_count":1},{"had_liked":false,"id":353406,"user_name":"X","can_delete":false,"product_type":"c1","uid":1581509,"ip_address":"上海","ucode":"BE05C1D25CE313","user_header":"https://static001.geekbang.org/account/avatar/00/18/21/c5/024e1ef1.jpg","comment_is_top":false,"comment_ctime":1659424578,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5954391874","product_id":100026001,"comment_content":"符号表、重定位表。<br>重定位表里面存放的是一些当前文件找不到的东西。<br>符号表是当前文件的一些映射信息。<br>然后通过链接，先将每个文件的符号表链接在一起组成一个更大的符号表（全的）。<br>这个时候重定位表的数据都可以从这个大而全的符号表里找到对应的了。","like_count":1},{"had_liked":false,"id":346586,"user_name":"自强不息","can_delete":false,"product_type":"c1","uid":2986909,"ip_address":"","ucode":"BFB11398FC6BA9","user_header":"https://static001.geekbang.org/account/avatar/00/2d/93/9d/299e4d20.jpg","comment_is_top":false,"comment_ctime":1653268505,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5948235801","product_id":100026001,"comment_content":"objdump -r link_example.o &#47;&#47;查看重定位表。为什么必须要重定位？在硬件上留个偏移地址接口，在多放个加法器，不可以吗？重定位应该算改代码吧，代码稳定点不好吗？","like_count":1},{"had_liked":false,"id":260959,"user_name":"人在江湖龙在江湖","can_delete":false,"product_type":"c1","uid":2285946,"ip_address":"","ucode":"20850038573DAE","user_header":"https://static001.geekbang.org/account/avatar/00/22/e1/7a/b206cded.jpg","comment_is_top":false,"comment_ctime":1605162046,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5900129342","product_id":100026001,"comment_content":"通过一个小例子，一步步分析汇编语句，这种讲解静态链接原理，感觉很好","like_count":1},{"had_liked":false,"id":168013,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1577975692,"is_pvip":false,"replies":[{"id":"68657","content":"gogo同学，<br><br>你好，-t是符号表。--weak-bind 就是弱绑定，应用场景是可以为一些函数库提供默认实现，但是用弱绑定，然后在链接的时候，替换成别的实现。<br>","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1581234969,"ip_address":"","comment_id":168013,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5872942988","product_id":100026001,"comment_content":"不是很懂objdump 执行了一下-help命令<br>objdump -help<br><br>  -lazy-bind               - Display mach-o lazy binding info<br>  -s                       - Display the content of each section<br>  -section-headers         - Display summaries of the headers for each section.<br>  -source                  - Display source inlined with disassembly. Implies disassemble object<br>  -t                       - Display the symbol table<br>  -weak-bind               - Display mach-o weak binding info<br><br><br>-t 就是符号表吧？<br>-s 就是每个section的内容<br>-lazy-bind 就是只有在运行的时候才会链接绑定的吗？<br>-weak-bind 弱绑定 (emmm 想起了java里面的弱引用， 这个是弱绑定，不敢瞎说)<br><br>objdump -source link-example <br><br>link-example:   file format Mach-O 64-bit x86-64<br><br>Disassembly of section __TEXT,__text:<br>__text:<br>省略 地址 指令 数据<br><br>_add:<br>省略 地址 指令 数据<br><br>_main:<br>省略 地址 指令 数据<br><br>Disassembly of section __TEXT,__stubs:<br>__stubs:<br>省略 地址 指令 数据<br><br>__stub_helper:<br>省略 地址 指令 数据<br><br>-------------------<br>objdump -s link-example <br><br>link-example:   file format Mach-O 64-bit x86-64<br><br>Contents of section __text:<br><br>...<br><br>Contents of section __stubs:<br>...<br><br>Contents of section __stub_helper:<br>...<br><br>Contents of section __cstring:<br>...<br><br>Contents of section __nl_symbol_ptr:<br>...<br><br>Contents of section __la_symbol_ptr:<br>...<br>Contents of section __unwind_info:<br>...<br><br><br>------<br><br>按老师说的，是有这些东西应该。但是具体看不太懂。<br><br>嗯 -o是目标文件 不是可执行文件<br>gcc -o link-example add.o main.o<br>将目标文件链接之后 才能生成可执行文件<br>可执行文件里面不仅仅有指令和代码，还有符号表和重定位表。 进一步学习需要看老师推荐的书。","like_count":1,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480099,"discussion_content":"gogo同学，\n\n你好，-t是符号表。--weak-bind 就是弱绑定，应用场景是可以为一些函数库提供默认实现，但是用弱绑定，然后在链接的时候，替换成别的实现。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581234969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":357895,"user_name":"woodie","can_delete":false,"product_type":"c1","uid":2004783,"ip_address":"北京","ucode":"1C2925AD8191DA","user_header":"","comment_is_top":false,"comment_ctime":1663736447,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663736447","product_id":100026001,"comment_content":"总结：a、进一步了解了编译过程：源代码-&gt;编译-&gt;汇编代码-&gt;汇编-&gt;目标代码-&gt;链接(链接多个目标文件)-&gt;ELF文件(可执行文件)-&gt;装载-&gt;内存&lt;- CPU<br>b、linux系统下仅能加载ELF格式的文件(Executable and Linked File Format)，windows仅能在加载PE格式的文件(Portable Executable Format)","like_count":0},{"had_liked":false,"id":348968,"user_name":"xxx","can_delete":false,"product_type":"c1","uid":1096652,"ip_address":"","ucode":"E79CEA70430449","user_header":"https://static001.geekbang.org/account/avatar/00/10/bb/cc/fac12364.jpg","comment_is_top":false,"comment_ctime":1655611658,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655611658","product_id":100026001,"comment_content":"看了这个，对JVM为什么叫虚拟机的理解更深入了。它就是做了一个虚拟的计算机。","like_count":0},{"had_liked":false,"id":336248,"user_name":"会爆炸的小米Note","can_delete":false,"product_type":"c1","uid":2150023,"ip_address":"","ucode":"1DA0B740A7C7B7","user_header":"https://static001.geekbang.org/account/avatar/00/20/ce/87/41c44923.jpg","comment_is_top":false,"comment_ctime":1646032930,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1646032930","product_id":100026001,"comment_content":"老师好，我想问一下linux里面通过execve函数调用加载器删除当前子进程现有的虚拟内存段，并创建一组新的代码、数据、堆和栈段。新的栈和堆段被初始化为零。这个过程是构建页表项的过程吗？把相应的页设置成已分配，未缓存的状态，最后通过缺页中断按需调度。","like_count":0},{"had_liked":false,"id":315163,"user_name":"蒋波","can_delete":false,"product_type":"c1","uid":1526325,"ip_address":"","ucode":"611A1F0629F08E","user_header":"https://static001.geekbang.org/account/avatar/00/17/4a/35/16861bf8.jpg","comment_is_top":false,"comment_ctime":1633716311,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633716311","product_id":100026001,"comment_content":"Java虚拟机翻译的结果是汇编代码，还是已经变成内存里面CPU可以执行的指令呢？Java虚拟机是操作系统上的一个进程，Java代码和虚拟机代码怎么融合到一起的呢？麻烦老师帮我梳理一下这个过程呐，万分谢谢了","like_count":0},{"had_liked":false,"id":311466,"user_name":"指北君","can_delete":false,"product_type":"c1","uid":1250042,"ip_address":"","ucode":"4344EA2FD1AF88","user_header":"https://static001.geekbang.org/account/avatar/00/13/12/fa/2bdf8cc6.jpg","comment_is_top":false,"comment_ctime":1631245035,"is_pvip":true,"replies":[{"id":"113183","content":"VAE同学，<br><br>你好，其实现在大部分新语言都是跨平台的了，基本上在Windows，Linux，以及Mac上你都能搭建起开发环境了。<br><br>支持多平台，虽然有一些工作量，但是整体来说还好。更多的问题来自于驱动、操作系统提供的图形库等等，导致很多程序不能移植，而不是语言不跨平台。<br><br>回到Java，需要考虑到历史原因，在Java兴起的时代，并不像今天大家都用X86的PC架构来作为服务器。比如SUN自己最重要的就是自己的SPARC小型机，当时PowerPC芯片也有一定的市场份额。而且Java当时还想要一通移动端乃至嵌入式设备，所以有J2ME<br><br>从这个角度来说，通过自定义VM来进行跨平台是一个很自然的选择。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1631771861,"ip_address":"","comment_id":311466,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1631245035","product_id":100026001,"comment_content":"老师好，我理解程序要跨平台的痛点是两个操作系统下可执行文件的格式不一样，但是可执行文件都是由高级语言-》汇编-》机器码，然后通过链接生成的，理论上：<br>1.所有语言都是要生成机器码<br>2.保证Linux 有兼容 PE 格式的装载器，Windows 有兼容 WSL的装载器<br>但是现在这两点都是能够保证的，那为啥还有不是跨平台的语言？而且还有什么像Java不依赖操作系统，要自己搞一套JVM来支持跨平台？","like_count":0,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526618,"discussion_content":"VAE同学，\n\n你好，其实现在大部分新语言都是跨平台的了，基本上在Windows，Linux，以及Mac上你都能搭建起开发环境了。\n\n支持多平台，虽然有一些工作量，但是整体来说还好。更多的问题来自于驱动、操作系统提供的图形库等等，导致很多程序不能移植，而不是语言不跨平台。\n\n回到Java，需要考虑到历史原因，在Java兴起的时代，并不像今天大家都用X86的PC架构来作为服务器。比如SUN自己最重要的就是自己的SPARC小型机，当时PowerPC芯片也有一定的市场份额。而且Java当时还想要一通移动端乃至嵌入式设备，所以有J2ME\n\n从这个角度来说，通过自定义VM来进行跨平台是一个很自然的选择。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631771861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":310698,"user_name":"一条有梦想的咸鱼","can_delete":false,"product_type":"c1","uid":1411281,"ip_address":"","ucode":"15BA7CA2C08EFF","user_header":"https://static001.geekbang.org/account/avatar/00/15/88/d1/43ebb68c.jpg","comment_is_top":false,"comment_ctime":1630847310,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630847310","product_id":100026001,"comment_content":"符号表里面的地址是什么地址？","like_count":0},{"had_liked":false,"id":305575,"user_name":"18736297414","can_delete":false,"product_type":"c1","uid":2272314,"ip_address":"","ucode":"F5220462B05D43","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/GbZRicqbu1QJmlcOlfLyW48OPaMmcKSO6zeZaKkc2uFiaLYOysibTKMtrOvOpHvlSHulHUatKX7lVcrENibqCmGhwQ/132","comment_is_top":false,"comment_ctime":1628055095,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628055095","product_id":100026001,"comment_content":"老师，可不可以这么理解：编译就是把高级语言按一定的规则翻译为cpu指令，链接就是根据不同的操作系统内存分配的规则，将地址进行修改，从而让程序可以嵌入cpu的运行任务序列中。","like_count":0},{"had_liked":false,"id":301853,"user_name":"吃饭","can_delete":false,"product_type":"c1","uid":1692756,"ip_address":"","ucode":"AF0D7165D5F049","user_header":"https://static001.geekbang.org/account/avatar/00/19/d4/54/7263deb2.jpg","comment_is_top":false,"comment_ctime":1625916551,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625916551","product_id":100026001,"comment_content":"内存不够大，没法一口气加载怎么办","like_count":0},{"had_liked":false,"id":296320,"user_name":"杰良","can_delete":false,"product_type":"c1","uid":2567349,"ip_address":"","ucode":"5DC1D1C58A4731","user_header":"https://static001.geekbang.org/account/avatar/00/27/2c/b5/10141329.jpg","comment_is_top":false,"comment_ctime":1622898273,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622898273","product_id":100026001,"comment_content":"程序代码经过编译、汇编生成机器码指令后，还需要进一步链接成为可执行程序文件，才能用于加载运行。在最后一步中需要补充组织好指令、数据以及一些辅助的重定位表、符号表数据，这个实现在不同操作系统中是稍有不同的。","like_count":0},{"had_liked":false,"id":248651,"user_name":"Geek_4142d6","can_delete":false,"product_type":"c1","uid":2137689,"ip_address":"","ucode":"6110DE33749C95","user_header":"","comment_is_top":false,"comment_ctime":1600253117,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1600253117","product_id":100026001,"comment_content":"编译、汇编、链接完成后生成可执行文件，然后通过装载器将可执行文件装载到内存里，那编译、汇编、链接是在哪里执行的，最终将可执行文件存储到哪里了？","like_count":0,"discussions":[{"author":{"id":1363348,"avatar":"https://static001.geekbang.org/account/avatar/00/14/cd/94/c08d783c.jpg","nickname":"前来打酱油的","note":"","ucode":"50457A9017AE46","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":315844,"discussion_content":"编译器，汇编器，链接器","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603331377,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":232470,"user_name":"西门吹牛","can_delete":false,"product_type":"c1","uid":1508990,"ip_address":"","ucode":"E5D3624DDE1E83","user_header":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","comment_is_top":false,"comment_ctime":1594013427,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594013427","product_id":100026001,"comment_content":"平常编写的程序，都是写在多个文件内，有可能这个文件中程序的某个方法调用了另一个文件中的某个方法，程序在执行的时候，是按应用程序定义的顺序来执行的，所以就必须把多个目标文件，链接成一个可执行的文件，这样在执行时，cpu只需按照可执行文件中的指令顺序进行执行就可，经过链接后的可执行文件，不可能全部装载在内存中，内存有限，可以先放在硬盘上，得真正运行的时候，在按顺序，分片去硬盘中去，并装载到内存，供cpu执行调用。","like_count":0},{"had_liked":false,"id":200543,"user_name":"雷刚","can_delete":false,"product_type":"c1","uid":1655725,"ip_address":"","ucode":"115FE2BE1AAB61","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/pTD8nS0SsORKiaRD3wB0NK9Bpd0wFnPWtYLPfBRBhvZ68iaJErMlM2NNSeEibwQfY7GReILSIYZXfT9o8iaicibcyw3g/132","comment_is_top":false,"comment_ctime":1585617394,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585617394","product_id":100026001,"comment_content":"有了链接，才能将多个文件组织成一个完整的程序。对于我们软件开发人员来说，代码复用才成为可能，工程可以通过不同的模块组织起来。如果所有的类都有一个文件中，那维护简直就是灾难。","like_count":0},{"had_liked":false,"id":192169,"user_name":"曾子良","can_delete":false,"product_type":"c1","uid":1856182,"ip_address":"","ucode":"3C2F7234E40451","user_header":"https://static001.geekbang.org/account/avatar/00/1c/52/b6/202076f0.jpg","comment_is_top":false,"comment_ctime":1584841705,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584841705","product_id":100026001,"comment_content":"今天听了老师的可，特意去Windows系统安装WSL，可是无法选择安装的目录，默认C盘空间不够，这个怎么指定有谁知道么？？？","like_count":0},{"had_liked":false,"id":190658,"user_name":"大头爸爸","can_delete":false,"product_type":"c1","uid":1276613,"ip_address":"","ucode":"131E25DB04D222","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/gmP4Yh00MZPwNvr4UQdLeXaX3TVyZEEp195S3vD3Sfl1xz5jBr1474Mt6w5OPr0KsrnQObfLRy5PkKNFjSBiasA/132","comment_is_top":false,"comment_ctime":1584678499,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1584678499","product_id":100026001,"comment_content":"第一张图里面有个加载器，英文是什么？好像作者也没提到这是干嘛的？<br>后面讲到装载器(loader)，不知道这两个东西是不是一回事?","like_count":0,"discussions":[{"author":{"id":1371229,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ec/5d/45227d75.jpg","nickname":"顽石少年","note":"","ucode":"397B01176626C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":265044,"discussion_content":"感觉加载器就是loader,翻译不同吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589370592,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184196,"user_name":"Kim","can_delete":false,"product_type":"c1","uid":1236573,"ip_address":"","ucode":"39CC8E1E8EFB8A","user_header":"https://static001.geekbang.org/account/avatar/00/12/de/5d/a7e748db.jpg","comment_is_top":false,"comment_ctime":1583245614,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583245614","product_id":100026001,"comment_content":"徐大，我想问下objdump出来的文件，左边的数字是该指令对应的内存地址么？看前面的文章提到这块，但是还是有些疑问，比如 6b0、6b1等等","like_count":0},{"had_liked":false,"id":156580,"user_name":"czh","can_delete":false,"product_type":"c1","uid":1159078,"ip_address":"","ucode":"649FE5C9269D69","user_header":"https://static001.geekbang.org/account/avatar/00/11/af/a6/3f15ba2f.jpg","comment_is_top":false,"comment_ctime":1574916950,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574916950","product_id":100026001,"comment_content":"第一次接触跨平台这个词是来自于java，但是会造成错误的认识：带java虚拟机的才是跨平台的必备条件。这其中犯了一个局部与整体的错误，井底之蛙说的就是我！跨平台并不属于语言的特性，而是需要从这个计算机体系的角度全面的理解","like_count":0},{"had_liked":false,"id":149629,"user_name":"_stuView","can_delete":false,"product_type":"c1","uid":1244561,"ip_address":"","ucode":"C2D4AAB08515F1","user_header":"https://static001.geekbang.org/account/avatar/00/12/fd/91/65ff3154.jpg","comment_is_top":false,"comment_ctime":1573293607,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573293607","product_id":100026001,"comment_content":"链接器的图里少了一条从add_lib.o的.rel.text Section指向符号解析与重定位的线吧","like_count":0},{"had_liked":false,"id":142834,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1571551795,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571551795","product_id":100026001,"comment_content":"---总结---<br>编译型语言的执行过程：编译-汇编-链接-装载<br>同一个程序在同一台计算机上的Linux和Win中不能兼容运行的原因：可执行文件和目标文件格式的不同<br>ELF文件的组成：文件头&amp;代码段&amp;数据段&amp;重定位表&amp;符号表","like_count":0},{"had_liked":false,"id":115638,"user_name":"极客大王","can_delete":false,"product_type":"c1","uid":1361781,"ip_address":"","ucode":"44DE4107F6BC1C","user_header":"https://static001.geekbang.org/account/avatar/00/14/c7/75/10d19a8b.jpg","comment_is_top":false,"comment_ctime":1563680359,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1563680359","product_id":100026001,"comment_content":"是不是可执行文件的格式不一样，加载到CPU的机器指令的格式就不一样吧？","like_count":0,"discussions":[{"author":{"id":1712572,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/21/bc/a50e08d4.jpg","nickname":"Geek_favorer","note":"","ucode":"0DB47C634568E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":43723,"discussion_content":"可执行文件格式不一样，在具体的操作系统下就无法解析出正确的机器码或者指令序列，而不是机器指令的格式不一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572885662,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":102049,"user_name":"　　　　　　　鸟人","can_delete":false,"product_type":"c1","uid":1035165,"ip_address":"","ucode":"E504B22F336035","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cb/9d/2bc85843.jpg","comment_is_top":false,"comment_ctime":1560126628,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560126628","product_id":100026001,"comment_content":"win有的时候运行文件需要在兼容模式下运行 这又是怎么回事呢","like_count":0},{"had_liked":false,"id":100173,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1559467662,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559467662","product_id":100026001,"comment_content":"老师好!感觉和JVM类加载有点像。符号表存放着方法名(key)，和加载后的内存地址(value)。重定位表里面放的就是加载过程中遇到的方法名。猜测会先去符号表里找，找到了直接填进去了。找不到的加入重定位表。全部加载完以后，回头解决重定位表里面记录的方法。请问老师是这么个流程么?","like_count":0},{"had_liked":false,"id":95601,"user_name":"活的潇洒","can_delete":false,"product_type":"c1","uid":1238830,"ip_address":"","ucode":"666C30CA894754","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/2e/1522a7d6.jpg","comment_is_top":false,"comment_ctime":1558096384,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558096384","product_id":100026001,"comment_content":"这一周紧赶慢赶，总算是赶上了更新的进度。day08天学习笔记<br>https:&#47;&#47;www.cnblogs.com&#47;luoahong&#47;p&#47;10877269.html","like_count":0},{"had_liked":false,"id":94605,"user_name":"Ant","can_delete":false,"product_type":"c1","uid":1079563,"ip_address":"","ucode":"07E6374F91F61E","user_header":"https://static001.geekbang.org/account/avatar/00/10/79/0b/4346a253.jpg","comment_is_top":false,"comment_ctime":1557850254,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1557850254","product_id":100026001,"comment_content":"老师好，有个疑问请教您<br><br>重定位表里，保留的是当前的文件里面，哪些跳转地址其实是我们不知道的。比如我们在 main 函数里面调用了 add 和 printf 这两个函数，但是在链接发生之前，我们并不知道该跳转到哪里，这些信息就会存储在重定位表里；<br>符号表保留了我们所说的当前文件里面定义的函数名称和对应地址的地址簿。<br>链接器会扫描所有输入的目标文件，构成一个全局的符号表。然后再根据重定位表，把所有不确定要跳转地址的代码，根据符号表里面存储的地址，进行一次修正。<br><br>那么链接器为啥要修正重定位表呢？  没有重定位表，直接用符号表行不行？<br><br>","like_count":0,"discussions":[{"author":{"id":1180460,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/2c/33ba4d12.jpg","nickname":"山中无老虎 😪","note":"","ucode":"594247C3A976DE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":115208,"discussion_content":"按道理可以，但是运行时性能不好，毕竟一次修正后以后随便使用，不然得每次用到都去查找","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577983634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1055214,"avatar":"https://static001.geekbang.org/account/avatar/00/10/19/ee/e395a35e.jpg","nickname":"小先生","note":"","ucode":"E5F2052E0323C0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2440,"discussion_content":"应该是修改代码段的代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563617897,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94554,"user_name":"徐","can_delete":false,"product_type":"c1","uid":1502878,"ip_address":"","ucode":"6BE46455FDD491","user_header":"https://static001.geekbang.org/account/avatar/00/16/ee/9e/204ce89c.jpg","comment_is_top":false,"comment_ctime":1557839742,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1557839742","product_id":100026001,"comment_content":"请问老师objdump出来的地址 和执行程序时实际的内存地址是怎么对应起来的","like_count":0,"discussions":[{"author":{"id":1183272,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0e/28/d1acb612.jpg","nickname":"风过檐铃","note":"","ucode":"877006357E8B88","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":165985,"discussion_content":"应该是操作系统基于虚拟内存来解决","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581344219,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94164,"user_name":"许山山","can_delete":false,"product_type":"c1","uid":1241643,"ip_address":"","ucode":"2A5168DEB58F19","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/2b/7d9751bb.jpg","comment_is_top":false,"comment_ctime":1557735699,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557735699","product_id":100026001,"comment_content":"➜  ch7 git:(coding) ✗ objdump -d -M intel -S function_example.o        <br><br>function_example.o:     file format elf64-x86-64<br><br><br>Disassembly of section .text:<br><br>0000000000000000 &lt;add&gt;:<br>#include &lt;stdio.h&gt;<br><br><br>int add(int a, int b)<br>{<br>   0:   55                      push   rbp<br>   1:   48 89 e5                mov    rbp,rsp<br>   4:   89 7d fc                mov    DWORD PTR [rbp-0x4],edi<br>   7:   89 75 f8                mov    DWORD PTR [rbp-0x8],esi<br>    return a + b;<br>   a:   8b 55 fc                mov    edx,DWORD PTR [rbp-0x4]<br>   d:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]<br>  10:   01 d0                   add    eax,edx<br>}<br>  12:   5d                      pop    rbp<br>  13:   c3                      ret    <br><br>0000000000000014 &lt;main&gt;:<br><br>int main(int argc, const char *argv[])<br>{<br>  14:   55                      push   rbp<br>  15:   48 89 e5                mov    rbp,rsp<br>  18:   48 83 ec 20             sub    rsp,0x20<br>  1c:   89 7d ec                mov    DWORD PTR [rbp-0x14],edi<br>  1f:   48 89 75 e0             mov    QWORD PTR [rbp-0x20],rsi<br>    int a = 5;<br>  23:   c7 45 f4 05 00 00 00    mov    DWORD PTR [rbp-0xc],0x5<br>    int b = 10;<br>  2a:   c7 45 f8 0a 00 00 00    mov    DWORD PTR [rbp-0x8],0xa<br>    int u = add(a, b);<br>  31:   8b 55 f8                mov    edx,DWORD PTR [rbp-0x8]<br>  34:   8b 45 f4                mov    eax,DWORD PTR [rbp-0xc]<br>  37:   89 d6                   mov    esi,edx<br>  39:   89 c7                   mov    edi,eax<br>  3b:   e8 00 00 00 00          call   40 &lt;main+0x2c&gt;<br>  40:   89 45 fc                mov    DWORD PTR [rbp-0x4],eax<br>    return 0;<br>  43:   b8 00 00 00 00          mov    eax,0x0<br>}<br>  48:   c9                      leave  <br>  49:   c3                      ret    <br><br>老师我想问一下 main 函数里起始位置 18, 1c, 1f 处的代码是干什么的？起始位置 3b, 40 处的函数调用为什么是直接把 eax 放到 u 里，这时候的 eax 已经是 add 函数运行后的结果了吗？<br><br>刚刚赶上进度，所以把前面遇到的问题也问一下老师，希望老师答疑，谢谢老师了。","like_count":0},{"had_liked":false,"id":94125,"user_name":"林三杠","can_delete":false,"product_type":"c1","uid":1012832,"ip_address":"","ucode":"E667F986D07DC6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/74/60/0403b575.jpg","comment_is_top":false,"comment_ctime":1557726106,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1557726106","product_id":100026001,"comment_content":"回答一下java跨平台的问题。<br>java的跨平台是通过虚拟机jvm实现的，程序员写的代码都编译成class文件，class文件在windows和linux上都是一样的，运行class文件的jvm是不跨平台的。windows有win版本的jvm，linux有linux版本的jvm。","like_count":0},{"had_liked":false,"id":94122,"user_name":"明翼","can_delete":false,"product_type":"c1","uid":1068361,"ip_address":"","ucode":"E77F86BEB3D5C1","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/49/28e73b9c.jpg","comment_is_top":false,"comment_ctime":1557724893,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1557724893","product_id":100026001,"comment_content":"老师我有个疑问经过链接之后行程可执行文件，像函数地址是确定了的，但是程序还没跑起来，这个地址怎么和运行时候内存实际地址做映射那？谢谢","like_count":0,"discussions":[{"author":{"id":1183272,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0e/28/d1acb612.jpg","nickname":"风过檐铃","note":"","ucode":"877006357E8B88","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":165987,"discussion_content":"应该是操作系统基于虚拟内存来解决","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581344273,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1027840,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/af/00/9b49f42b.jpg","nickname":"skye","note":"","ucode":"C55C9F52C78A00","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4678,"discussion_content":"同问？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565659303,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94069,"user_name":"徐凯","can_delete":false,"product_type":"c1","uid":1244991,"ip_address":"","ucode":"12F82BA3649CD5","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/3f/bbb8a88c.jpg","comment_is_top":false,"comment_ctime":1557713634,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557713634","product_id":100026001,"comment_content":"程序无法装载可能是由于系统无法识别目标文件的格式，我记得好像还有ABI的影响吧，函数符号的解析方式 参数的入栈顺序 以及c++底层内存布局 特性底层的不同实现 老师能不能简单讲解一下 ","like_count":0},{"had_liked":false,"id":94031,"user_name":"一塌糊涂","can_delete":false,"product_type":"c1","uid":1106566,"ip_address":"","ucode":"B55DAEFB98D83C","user_header":"https://static001.geekbang.org/account/avatar/00/10/e2/86/90041355.jpg","comment_is_top":false,"comment_ctime":1557708584,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557708584","product_id":100026001,"comment_content":"看一章，木有看够","like_count":0},{"had_liked":false,"id":94013,"user_name":"Linuxer","can_delete":false,"product_type":"c1","uid":1153978,"ip_address":"","ucode":"272D9D8089C3D6","user_header":"https://static001.geekbang.org/account/avatar/00/11/9b/ba/333b59e5.jpg","comment_is_top":false,"comment_ctime":1557706804,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1557706804","product_id":100026001,"comment_content":"请问代码段里面的符号和数据段里面的符号分配的地址范围一样吗？有什么规则?另外动态链接的重定位应该有不同的规则吧","like_count":0,"discussions":[{"author":{"id":2522914,"avatar":"https://static001.geekbang.org/account/avatar/00/26/7f/22/d670af4a.jpg","nickname":"邱マン","note":"","ucode":"92293B1E0D64CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367249,"discussion_content":"《程序员的自我修养——链接、装载和库》的 1～4 章可以看下\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618305761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}