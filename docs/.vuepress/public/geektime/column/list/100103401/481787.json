{"id":481787,"title":"12 | 实战：用Kotlin实现一个网络请求框架KtHttp","content":"<p>你好，我是朱涛，又到了实战环节。</p><p>在前面几节课当中，我们一起学习了Kotlin的委托、泛型、注解、反射这几个高级特性。那么今天这节课，我们将会运用这些特性，来写一个<strong>Kotlin版本的HTTP网络请求框架</strong>。由于它是纯Kotlin开发的，我们就把它叫做是KtHttp吧。</p><p>事实上，在Java和Kotlin领域，有许多出色的网络请求框架，比如 <a href=\"https://github.com/square/okhttp\">OkHttp</a>、<a href=\"https://github.com/square/Retrofit\">Retrofit</a>、<a href=\"https://github.com/kittinunf/fue\">Fuel</a>。而我们今天要实现的KtHttp，它的灵感来自于Retrofit。之所以选择Retrofit作为借鉴的对象，是因为它的底层使用了大量的<strong>泛型、注解和反射</strong>的技术。如果你能跟着我一起用泛型、注解、反射来实现一个简单的网络请求框架，相信你对这几个知识点的认识也会更加透彻。</p><p>在这节课当中，我会带你从0开始实现这个网络请求框架。和往常一样，为了方便你理解，我们的代码会分为两个版本：</p><ul>\n<li>1.0 版本，我们会用Java思维，以最简单直白的方式来实现KtHttp的基础功能——同步式的GET网络请求；</li>\n<li>2.0 版本，我们会用函数式思维来重构代码。</li>\n</ul><p>另外，在正式开始学习之前，我也建议你去clone我GitHub上面的KtHttp工程：<a href=\"https://github.com/chaxiu/KtHttp.git\">https://github.com/chaxiu/KtHttp.git</a>，然后用IntelliJ打开，并切换到<strong>start</strong>分支跟着课程一步步敲代码。</p><!-- [[[read_end]]] --><h2>1.0：Java思维</h2><p>在正式开始之前，我们还是先来看看程序的运行效果：</p><p><img src=\"https://static001.geekbang.org/resource/image/32/bc/321d151db077766997ed8d8b911f1fbc.gif?wh=1294x862\" alt=\"图片\"></p><p>在上面的动图中，我们通过KtHttp请求了一个服务器的API，然后在控制台输出了结果。这其实是我们在开发工作当中十分常见的需求。通过这个KtHttp，我们就可以在程序当中访问任何服务器的API，比如<a href=\"https://docs.github.com/en\">GitHub的API</a>。</p><p>那么，为了描述服务器返回的内容，我们定义了两个数据类：</p><pre><code class=\"language-plain\">// 这种写法是有问题的，但这节课我们先不管。\n\ndata class RepoList(\n    var count: Int?,\n    var items: List&lt;Repo&gt;?,\n    var msg: String?\n)\n\ndata class Repo(\n    var added_stars: String?,\n    var avatars: List&lt;String&gt;?,\n    var desc: String?,\n    var forks: String?,\n    var lang: String?,\n    var repo: String?,\n    var repo_link: String?,\n    var stars: String?\n)\n</code></pre><p>除了数据类以外，我们还要定义一个用于网络请求的接口：</p><pre><code class=\"language-plain\">interface ApiService {\n    @GET(\"/repo\")\n    fun repos(\n        @Field(\"lang\") lang: String,\n        @Field(\"since\") since: String\n    ): RepoList\n}\n</code></pre><p>在这个接口当中，有两个注解，我们一个个分析：</p><ul>\n<li><strong>GET注解</strong>，代表了这个网络请求应该是GET请求，这是<a href=\"https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE\">HTTP</a>请求的一种方式。GET注解当中的“/repo”，代表了API的path，它是和baseURL拼接的；</li>\n<li><strong>Field注解</strong>，代表了GET请求的参数。Field注解当中的值也会和URL拼接在一起。</li>\n</ul><p>也许你会好奇，<strong>GET、Field这两个注解是从哪里来的呢？</strong>这其实也是需要我们自己定义的。根据上节课学过的内容，我们很容易就能写出下面的代码：</p><pre><code class=\"language-plain\">@Target(AnnotationTarget.FUNCTION)\n@Retention(AnnotationRetention.RUNTIME)\nannotation class GET(val value: String)\n\n@Target(AnnotationTarget.VALUE_PARAMETER)\n@Retention(AnnotationRetention.RUNTIME)\nannotation class Field(val value: String)\n</code></pre><p>从这段代码里我们可以看出，GET注解只能用于修饰函数，Field注解只能用于修饰参数。另外，这两个注解的Retention都是AnnotationRetention.RUNTIME，这意味着这两个注解都是运行时可访问的。而这，也正好是我们后面要使用的反射的前提。</p><p>最后，我们再来看看KtHttp是如何使用的：</p><pre><code class=\"language-plain\">fun main() {\n    // ①\n    val api: ApiService = KtHttpV1.create(ApiService::class.java)\n\n    // ②\n    val data: RepoList = api.repos(lang = \"Kotlin\", since = \"weekly\")\n\n    println(data)\n}\n</code></pre><p>上面的代码有两个注释，我们分别来看。</p><ul>\n<li>注释①：我们调用KtHttpV1.create()方法，传入了ApiService::class.java，参数的类型是<code>Class&lt;T&gt;</code>，返回值类型是ApiService。这就相当于创建了ApiService这个接口的实现类的对象。</li>\n<li>注释②：我们调用api.repos()这个方法，传入了Kotlin、weekly这两个参数，代表我们想查询最近一周最热门的Kotlin开源项目。</li>\n</ul><p>看到这里，你也许会好奇，<strong>KtHttpV1.create()是如何创建ApiService的实例的呢？</strong>要知道ApiService可是一个接口，我们要创建它的对象，必须要先定义一个类实现它的接口方法，然后再用这个类来创建对象才行。</p><p>不过在这里，我们不会使用这种传统的方式，而是会用<strong>动态代理</strong>，也就是JDK的<a href=\"https://docs.oracle.com/javase/7/docs/api/java/lang/reflect/Proxy.html\">Proxy</a>。Proxy的底层，其实也用到了反射。</p><p>不过，由于这个案例涉及到的知识点都很抽象，在正式开始编写逻辑代码之前，我们先来看看下面这个动图，对整体的程序有一个粗略的认识。</p><p><img src=\"https://static001.geekbang.org/resource/image/cf/95/cf441d3df1bb4b49432319e160cd3c95.gif?wh=1080x608\" alt=\"\"></p><p>现在，相信你大概就知道这个程序是如何实现的了。下面，我再带你来看看具体的代码是怎么写的。</p><p>这里我要先说明一点，为了不偏离这次实战课的主题，我们不会去深究Proxy的底层原理。在这里，<strong>你只需要知道，我们通过Proxy，就可以动态地创建ApiService接口的实例化对象</strong>。具体的做法如下：</p><pre><code class=\"language-plain\">fun &lt;T&gt; create(service: Class&lt;T&gt;): T {\n\n    // 调用 Proxy.newProxyInstance 就可以创建接口的实例化对象\n    return Proxy.newProxyInstance(\n        service.classLoader,\n        arrayOf&lt;Class&lt;*&gt;&gt;(service),\n        object : InvocationHandler{\n            override fun invoke(proxy: Any?, method: Method?, args: Array&lt;out Any&gt;?): Any {\n                // 省略\n            }\n        }\n    ) as T\n}    \n</code></pre><p>在上面的代码当中，我们在create()方法当中，直接返回了Proxy.newProxyInstance()这个方法的返回值，最后再将其转换成了T类型。</p><p>那么，newProxyInstance()这个方法又是如何定义的呢？</p><pre><code class=\"language-java\">public static Object newProxyInstance(ClassLoader loader,\n                                          Class&lt;?&gt;[] interfaces,\n                                          InvocationHandler h){ \n        ...\n}\n\npublic interface InvocationHandler {\n    public Object invoke(Object proxy, Method method, Object[] args)\n        throws Throwable;\n}\n</code></pre><p>从上面的代码当中，我们可以看到，最后一个参数，InvocationHandler其实是符合SAM转换要求的，所以我们的create()方法可以进一步简化成这样：</p><pre><code class=\"language-plain\">fun &lt;T&gt; create(service: Class&lt;T&gt;): T {\n\n    return Proxy.newProxyInstance(\n        service.classLoader,\n        arrayOf&lt;Class&lt;*&gt;&gt;(service)\n    ) { proxy, method, args -&gt;\n        // 待完成\n    } as T\n}\n</code></pre><p>那么到这里，我们程序的基本框架也就搭建好了。</p><p>细心的你一定发现了，我们<strong>程序的主要逻辑还没实现</strong>，所以接下来，我们就一起看看上面那个“待完成”的InvocationHandler，这个Lambda表达式应该怎么写。这个换句话说，也就是Proxy.newProxyInstance()，会帮我们创建ApiService的实例对象，而ApiService当中的接口方法的具体逻辑，我们需要在Lambda表达式当中实现。</p><p>好了，让我们回过头来看看ApiService当中的代码细节：</p><pre><code class=\"language-plain\">interface ApiService {\n// 假设我们的baseurl是：https://baseurl.com\n// 这里拼接结果会是这样：https://baseurl.com/repo\n//          ↓\n    @GET(\"/repo\")\n    fun repos(\n    //                Field注解当中的lang，最终会拼接到url当中去\n    //            ↓                                                 ↓\n        @Field(\"lang\") lang: String,  // https://baseurl.com/repo?lang=Kotlin\n        @Field(\"since\") since: String // https://baseurl.com/repo?lang=Kotlin&amp;since=weekly\n    ): RepoList\n}\n</code></pre><p>从代码注释中可以看出来，其实我们真正需要实现的逻辑，就是想办法把注解当中的值/repo、lang、since取出来，然后拼接到URL当中去。那么，我们如何才能得到注解当中的值呢？</p><p>答案自然就是我们在上节课学过的：<strong>反射</strong>。</p><pre><code class=\"language-plain\">object KtHttpV1 {\n\n    // 底层使用 OkHttp\n    private var okHttpClient: OkHttpClient = OkHttpClient()\n    // 使用 Gson 解析 JSON\n    private var gson: Gson = Gson()\n\n    // 这里以baseurl.com为例，实际上我们的KtHttpV1可以请求任意API\n    var baseUrl = \"https://baseurl.com\"\n\n    fun &lt;T&gt; create(service: Class&lt;T&gt;): T {\n        return Proxy.newProxyInstance(\n            service.classLoader,\n            arrayOf&lt;Class&lt;*&gt;&gt;(service)\n        //           ①     ②\n        //           ↓      ↓\n        ) { proxy, method, args -&gt;\n            // ③\n            val annotations = method.annotations\n            for (annotation in annotations) {\n                // ④\n                if (annotation is GET) {\n                    // ⑤\n                    val url = baseUrl + annotation.value\n                    // ⑥\n                    return@newProxyInstance invoke(url, method, args!!)\n                }\n            }\n            return@newProxyInstance null\n\n        } as T\n    }\n\n    private fun invoke(url: String, method: Method, args: Array&lt;Any&gt;): Any? {\n        // 待完成\n    }\n}\n</code></pre><p>在上面的代码中，一共有6个注释，我们一个个看。</p><ul>\n<li>注释①：method的类型是反射后的Method，在我们这个例子当中，它最终会代表被调用的方法，也就是ApiService接口里面的repos()这个方法。</li>\n<li>注释②：args的类型是对象的数组，在我们的例子当中，它最终会代表方法的参数的值，也就是“<code>api.repos(\"Kotlin\", \"weekly\")</code>”当中的<code>\"Kotlin\"</code>和<code>\"weekly\"</code>。</li>\n<li>注释③：method.annotations，代表了我们会取出repos()这个方法上面的所有注解，由于repos()这个方法上面可能会有多个注解，因此它是数组类型。</li>\n<li>注释④：我们使用for循环，遍历所有的注解，找到GET注解。</li>\n<li>注释⑤：我们找到GET注解以后，要取出@GET(“/repo”)当中的\"/repo\"，也就是“annotation.value”。这时候我们只需要用它与baseURL进行拼接，就可以得到完整的URL；</li>\n<li>注释⑥：return@newProxyInstance，用的是Lambda表达式当中的返回语法，在得到完整的URL以后，我们将剩下的逻辑都交给了invoke()这个方法。</li>\n</ul><p>接下来，我们再来看看invoke()当中的“待完成代码”应该怎么写。</p><pre><code class=\"language-plain\">private fun invoke(url: String, method: Method, args: Array&lt;Any&gt;): Any? {\n    // ① 根据url拼接参数，也就是：url + ?lang=Kotlin&amp;since=weekly\n    // ② 使用okHttpClient进行网络请求\n    // ③ 使用gson进行JSON解析\n    // ④ 返回结果\n}\n</code></pre><p>在上面的代码中，我们的invoke()方法一共分成了四个步骤，其中的③、④两个步骤其实很容易实现：</p><pre><code class=\"language-plain\">private fun invoke(url: String, method: Method, args: Array&lt;Any&gt;): Any? {\n    // ① 根据url拼接参数，也就是：url + ?lang=Kotlin&amp;since=weekly\n\n    // 使用okHttpClient进行网络请求\n    val request = Request.Builder()\n            .url(url)\n            .build()\n    val response = okHttpClient.newCall(request).execute()\n\n    // ② 获取repos()的返回值类型 genericReturnType\n\n    // 使用gson进行JSON解析\n    val body = response.body\n    val json = body?.string()\n    //                              根据repos()的返回值类型解析JSON\n    //                                            ↓\n    val result = gson.fromJson&lt;Any?&gt;(json, genericReturnType)\n\n    // 返回结果\n    return result\n}\n</code></pre><p>继续看，经过我们的分解，现在的问题变成了下面这样：</p><ul>\n<li>注释①，利用反射，解析出“<code>api.repos(\"Kotlin\", \"weekly\")</code>”这个方法当中的<code>\"Kotlin\"</code>和<code>\"weekly\"</code>，将其与URL进行拼接得到：<code>url + ?lang=Kotlin&amp;since=weekly</code></li>\n<li>注释②，利用反射，解析出repos()的返回值类型，用于JSON解析。</li>\n</ul><p>我们来看看最终的代码：</p><pre><code class=\"language-plain\">private fun invoke(path: String, method: Method, args: Array&lt;Any&gt;): Any? {\n    // 条件判断\n    if (method.parameterAnnotations.size != args.size) return null\n\n    // 解析完整的url\n    var url = path\n    // ①\n    val parameterAnnotations = method.parameterAnnotations\n    for (i in parameterAnnotations.indices) {\n        for (parameterAnnotation in parameterAnnotations[i]) {\n            // ②\n            if (parameterAnnotation is Field) {\n                val key = parameterAnnotation.value\n                val value = args[i].toString()\n                if (!url.contains(\"?\")) {\n                    // ③\n                    url += \"?$key=$value\"\n                } else {\n                    // ④\n                    url += \"&amp;$key=$value\"\n                }\n\n            }\n        }\n    }\n    // 最终的url会是这样：\n    // https://baseurl.com/repo?lang=Kotlin&amp;since=weekly\n\n    // 执行网络请求\n    val request = Request.Builder()\n        .url(url)\n        .build()\n    val response = okHttpClient.newCall(request).execute()\n\n    // ⑤\n    val genericReturnType = method.genericReturnType\n    val body = response.body\n    val json = body?.string()\n    // JSON解析\n    val result = gson.fromJson&lt;Any?&gt;(json, genericReturnType)\n\n    // 返回值\n    return result\n}\n</code></pre><p>上面的代码一共涉及五个注释，它们都是跟注解与反射这两个知识点相关的。</p><ul>\n<li>注释①，method.parameterAnnotations，它的作用是取出方法参数当中的所有注解，在我们这个案例当中，repos()这个方法当中涉及到两个注解，它们分别是<code>@Field(\"lang\")</code>、<code>@Field(\"since\")</code>。</li>\n<li>注释②，由于方法当中可能存在其他注解，因此要筛选出我们想要的Field注解。</li>\n<li>注释③，这里是取出注解当中的值“lang”，以及参数当中对应的值“Kotlin”进行拼接，URL第一次拼接参数的时候，要用“?”分隔。</li>\n<li>注释④，这里是取出注解当中的值“since”，以及参数当中对应的值“weekly”进行拼接，后面的参数拼接格式，是用“&amp;”分隔。</li>\n<li>注释⑤，method.genericReturnType取出repos()的返回值类型，也就是RepoList，最终，我们用它来解析JSON。</li>\n</ul><p>说实话，动态代理的这种模式，由于它大量应用了反射，加之我们的代码当中还牵涉到了泛型和注解，导致这个案例的代码不是那么容易理解。不过，我们其实可以利用<strong>调试</strong>的手段，去查看代码当中每一步执行的结果，这样就能对注解、反射、动态代理有一个更具体的认识。</p><p>前面带你看过的这个动图，其实就是在向你展示代码在调试过程中的关键节点，我们可以再来回顾一下整个代码的执行流程：</p><p><img src=\"https://static001.geekbang.org/resource/image/cf/95/cf441d3df1bb4b49432319e160cd3c95.gif?wh=1080x608\" alt=\"\"></p><p>相信现在，你已经能够体会我们使用 <strong>动态代理+注解+反射</strong> 实现这个网络请求框架的原因了。通过这样的方式，我们就不必在代码当中去实现每一个接口，而是只要是符合这样的代码模式，任意的接口和方法，我们都可以直接传进去。在这个例子当中，我们用的是ApiService这个接口，如果下次我们定义了另一个接口，比如说：</p><pre><code class=\"language-plain\">interface GitHubService {\n    @GET(\"/search\")\n    fun search(\n        @Field(\"id\") id: String\n    ): User\n}\n</code></pre><p>这时候，我们的KtHttp根本不需要做任何的改动，直接这样调用即可：</p><pre><code class=\"language-plain\">fun main() {\n    KtHttpV1.baseUrl = \"https://api.github.com\"\n    //       换一个接口名即可                  换一个接口名即可\n    //              ↓                             ↓                \n    val api: GitHubService = KtHttpV1.create(GitHubService::class.java)\n    val data: User = api.search(id = \"JetBrains\")\n}\n</code></pre><p>可以发现，使用动态代理实现网络请求的优势，它的<strong>灵活性</strong>是非常好的。只要我们定义的Service接口拥有对应的注解GET、Field，我们就可以通过注解与反射，将这些信息拼凑在一起。下面这个动图就展示了它们整体的流程：</p><p><img src=\"https://static001.geekbang.org/resource/image/8b/31/8b5997dc2f036020dc16a1a5efb8c531.gif?wh=1080x608\" alt=\"图片\"></p><p>实际上，我们的KtHttp，就是将URL的信息存储在了注解当中（比如lang和since），而实际的参数值，是在函数调用的时候传进来的（比如Kotlin和weekly）。我们通过泛型、注解、反射的结合，将这些信息集到一起，完成整个URL的拼接，最后才通过OkHttp完成的网络请求、Gson完成的解析。</p><p>好，到这里，我们1.0版本的开发就算是完成了。这里的单元测试代码很容易写，我就不贴出来了，<strong>单元测试是个好习惯，我们不能忘</strong>。</p><p>接下来，我们正式进入2.0版本的开发。</p><h2>2.0：函数式思维</h2><p>其实，如果你理解了1.0版本的代码，2.0版本的程序也就不难实现了。因为这个程序的主要功能都已经完成了，现在要做的只是：<strong>换一种思路重构代码</strong>。</p><p>我们先来看看KtHttpV1这个单例的成员变量：</p><pre><code class=\"language-plain\">object KtHttpV1 {\n    private var okHttpClient: OkHttpClient = OkHttpClient()\n    private var gson: Gson = Gson()\n\n    fun &lt;T&gt; create(service: Class&lt;T&gt;): T {}\n    fun invoke(url: String, method: Method, args: Array&lt;Any&gt;): Any? {}\n}\n</code></pre><p>okHttpClient、gson这两个成员是不支持懒加载的，因此我们首先应该让它们<strong>支持懒加载</strong>。</p><pre><code class=\"language-plain\">object KtHttpV2 {\n    private val okHttpClient by lazy { OkHttpClient() }\n    private val gson by lazy { Gson() }\n\n    fun &lt;T&gt; create(service: Class&lt;T&gt;): T {}\n    fun invoke(url: String, method: Method, args: Array&lt;Any&gt;): Any? {}\n}\n</code></pre><p>这里，我们直接使用了by lazy委托的方式，它简洁的语法可以让我们快速实现懒加载。<br>\n接下来，我们再来看看create()这个方法的定义：</p><pre><code class=\"language-plain\">//                      注意这里\n//                         ↓\nfun &lt;T&gt; create(service: Class&lt;T&gt;): T {\n    return Proxy.newProxyInstance(\n        service.classLoader,\n        arrayOf&lt;Class&lt;*&gt;&gt;(service)\n    ) { proxy, method, args -&gt;\n    }\n}\n</code></pre><p>在上面的代码中，create()会接收一个<code>Class&lt;T&gt;</code>类型的参数。其实，针对这样的情况，我们完全可以省略掉这个参数。具体做法，是使用我们前面学过的<a href=\"https://time.geekbang.org/column/article/477295\">inline</a>，来实现<strong>类型实化</strong>（Reified Type）。我们常说，Java的泛型是伪泛型，而这里我们要实现的就是真泛型。</p><pre><code class=\"language-plain\">//  注意这两个关键字\n//  ↓          ↓\ninline fun &lt;reified T&gt; create(): T {\n    return Proxy.newProxyInstance(\n        T::class.java.classLoader, // ① 变化在这里\n        arrayOf(T::class.java) // ② 变化在这里\n    ) { proxy, method, args -&gt;\n        // 待重构\n    }\n}\n</code></pre><p>正常情况下，泛型参数<a href=\"https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4\">类型会被擦除</a>，这就是Java的泛型被称为“伪泛型”的原因。而通过使用<strong>inline和reified</strong>这两个关键字，我们就能实现类型实化，也就是“真泛型”，进一步，我们就可以在代码注释①、②的地方，使用“T::class.java”来得到Class对象。</p><p>下面，我们来看看KtHttp的主要逻辑该如何重构。</p><p>为了方便理解，我们会使用Kotlin标准库当中已有的高阶函数，尽量不去涉及函数式编程里的高级概念。<strong>在这里我强烈建议你打开IDE一边敲代码一边阅读</strong>，这样一来，当你遇到不熟悉的标准函数时，就可以随时去看它的实现源码了。相信在学习过第7讲的<a href=\"https://time.geekbang.org/column/article/476637\">高阶函数</a>以后，这些库函数都不会难倒你。</p><p>首先，我们来看看create()里面“待重构”的代码该如何写。在这个方法当中，我们需要读取method当中的GET注解，解析出它的值，然后与baseURL拼接。这里我们完全可以<strong>借助Kotlin的标准库函数</strong>来实现：</p><pre><code class=\"language-plain\">inline fun &lt;reified T&gt; create(): T {\n    return Proxy.newProxyInstance(\n        T::class.java.classLoader,\n        arrayOf(T::class.java)\n    ) { proxy, method, args -&gt;\n\n        return@newProxyInstance method.annotations\n            .filterIsInstance&lt;GET&gt;()\n            .takeIf { it.size == 1 }\n            ?.let { invoke(\"$baseUrl${it[0].value}\", method, args) }\n    } as T\n}\n</code></pre><p>这段代码的可读性很好，我们可以像读英语文本一样来阅读：</p><ul>\n<li>首先，我们通过method.annotations，来获取method的所有注解；</li>\n<li>接着，我们用<code>filterIsInstance&lt;GET&gt;()</code>，来筛选出我们想要找的GET注解。这里的filterIsInstance其实是filter的升级版，也就是<strong>过滤</strong>的意思；</li>\n<li>之后，我们判断GET注解的数量，它的数量必须是1，其他的都不行，这里的takeIf其实相当于我们的if；</li>\n<li>最后，我们通过拼接出URL，然后将程序执行流程交给invoke()方法。这里的\"?.let{}\"相当于判空。</li>\n</ul><p>好了，create()方法的重构已经完成，接下来我们来看看invoke()方法该如何重构。</p><pre><code class=\"language-plain\">fun invoke(url: String, method: Method, args: Array&lt;Any&gt;): Any? =\n    method.parameterAnnotations\n        .takeIf { method.parameterAnnotations.size == args.size }\n        ?.mapIndexed { index, it -&gt; Pair(it, args[index]) }\n        ?.fold(url, ::parseUrl)\n        ?.let { Request.Builder().url(it).build() }\n        ?.let { okHttpClient.newCall(it).execute().body?.string() }\n        ?.let { gson.fromJson(it, method.genericReturnType) }\n</code></pre><p>这段代码读起来也不难，我们一行一行来分析。</p><ul>\n<li>第一步，我们通过method.parameterAnnotations，获取方法当中所有的参数注解，在这里也就是<code>@Field(\"lang\")</code>、<code>@Field(\"since\")</code>。</li>\n<li>第二步，我们通过takeIf来判断，参数注解数组的数量与参数的数量相等，也就是说<code>@Field(\"lang\")</code>、<code>@Field(\"since\")</code>的数量是2，那么<code>[\"Kotlin\", \"weekly\"]</code>的size也应该是2，它必须是一一对应的关系。</li>\n<li>第三步，我们将<code>@Field(\"lang\")</code>与<code>\"Kotlin\"</code>进行配对，将<code>@Field(\"since\")</code>与<code>\"weekly\"</code>进行配对。这里的mapIndexed，其实就是map的升级版，它本质还是一种映射的语法，“注解数组类型”映射成了“Pair数组”，只是多了一个index而已。</li>\n<li>第四步，我们使用fold与parseUrl()这个方法，拼接出完整的URL，也就是：<a href=\"https://baseurl.com/repo?lang=Kotlin&since=weekly\">https://baseurl.com/repo?lang=Kotlin&amp;since=weekly</a>。 这里我们使用了<strong>函数引用</strong>的语法“::parseUrl”。而fold这个操作符，其实就是高阶函数版的for循环。</li>\n<li>第五步，我们构建出OkHttp的Request对象，并且将URL传入了进去，准备做网络请求。</li>\n<li>第六步，我们通过okHttpClient发起了网络请求，并且拿到了String类型的JSON数据。</li>\n<li>最后，我们通过Gson解析出JSON的内容，并且返回RepoList对象。</li>\n</ul><p>到目前为止，我们的invoke()方法的主要流程就分析完了，接下来我们再来看看用于实现URL拼接的parseUrl()是如何实现的。</p><pre><code class=\"language-plain\">private fun parseUrl(acc: String, pair: Pair&lt;Array&lt;Annotation&gt;, Any&gt;) =\n    pair.first.filterIsInstance&lt;Field&gt;()\n        .first()\n        .let { field -&gt;\n            if (acc.contains(\"?\")) {\n                \"$acc&amp;${field.value}=${pair.second}\"\n            } else {\n                \"$acc?${field.value}=${pair.second}\"\n            }\n        }\n</code></pre><p>可以看到，这里我们只是把从前的for循环代码，换成了 <strong>Kotlin的集合操作符</strong>而已。大致流程如下：</p><ul>\n<li>首先，我们从注解的数组里筛选出Field类型的注解；</li>\n<li>接着，通过first()取出第一个Field注解，这里它也应该是唯一的；</li>\n<li>最后，我们判断当前的acc是否已经拼接过参数，如果没有拼接过，就用“?”分隔，如果已经拼接过参数，我们就用“&amp;”分隔。</li>\n</ul><p>至此，我们2.0版本的代码就完成了，完整的代码如下：</p><pre><code class=\"language-plain\">object KtHttpV2 {\n\n    private val okHttpClient by lazy { OkHttpClient() }\n    private val gson by lazy { Gson() }\n    var baseUrl = \"https://baseurl.com\" // 可改成任意url\n\n    inline fun &lt;reified T&gt; create(): T {\n        return Proxy.newProxyInstance(\n            T::class.java.classLoader,\n            arrayOf(T::class.java)\n        ) { proxy, method, args -&gt;\n\n            return@newProxyInstance method.annotations\n                .filterIsInstance&lt;GET&gt;()\n                .takeIf { it.size == 1 }\n                ?.let { invoke(\"$baseUrl${it[0].value}\", method, args) }\n        } as T\n    }\n\n    fun invoke(url: String, method: Method, args: Array&lt;Any&gt;): Any? =\n        method.parameterAnnotations\n            .takeIf { method.parameterAnnotations.size == args.size }\n            ?.mapIndexed { index, it -&gt; Pair(it, args[index]) }\n            ?.fold(url, ::parseUrl)\n            ?.let { Request.Builder().url(it).build() }\n            ?.let { okHttpClient.newCall(it).execute().body?.string() }\n            ?.let { gson.fromJson(it, method.genericReturnType) }\n\n\n    private fun parseUrl(acc: String, pair: Pair&lt;Array&lt;Annotation&gt;, Any&gt;) =\n        pair.first.filterIsInstance&lt;Field&gt;()\n            .first()\n            .let { field -&gt;\n                if (acc.contains(\"?\")) {\n                    \"$acc&amp;${field.value}=${pair.second}\"\n                } else {\n                    \"$acc?${field.value}=${pair.second}\"\n                }\n            }\n}\n</code></pre><p>对应的，我们可以再看看1.0版本的完整代码：</p><pre><code class=\"language-plain\">object KtHttpV1 {\n\n    private var okHttpClient: OkHttpClient = OkHttpClient()\n    private var gson: Gson = Gson()\n    var baseUrl = \"https://baseurl.com\" // 可改成任意url\n\n    fun &lt;T&gt; create(service: Class&lt;T&gt;): T {\n        return Proxy.newProxyInstance(\n            service.classLoader,\n            arrayOf&lt;Class&lt;*&gt;&gt;(service)\n        ) { proxy, method, args -&gt;\n            val annotations = method.annotations\n            for (annotation in annotations) {\n                if (annotation is GET) {\n                    val url = baseUrl + annotation.value\n                    return@newProxyInstance invoke(url, method, args!!)\n                }\n            }\n            return@newProxyInstance null\n\n        } as T\n    }\n\n    private fun invoke(path: String, method: Method, args: Array&lt;Any&gt;): Any? {\n        if (method.parameterAnnotations.size != args.size) return null\n\n        var url = path\n        val parameterAnnotations = method.parameterAnnotations\n        for (i in parameterAnnotations.indices) {\n            for (parameterAnnotation in parameterAnnotations[i]) {\n                if (parameterAnnotation is Field) {\n                    val key = parameterAnnotation.value\n                    val value = args[i].toString()\n                    if (!url.contains(\"?\")) {\n                        url += \"?$key=$value\"\n                    } else {\n                        url += \"&amp;$key=$value\"\n                    }\n\n                }\n            }\n        }\n\n        val request = Request.Builder()\n            .url(url)\n            .build()\n\n        val response = okHttpClient.newCall(request).execute()\n\n        val genericReturnType = method.genericReturnType\n        val body = response.body\n        val json = body?.string()\n        val result = gson.fromJson&lt;Any?&gt;(json, genericReturnType)\n\n        return result\n    }\n}\n</code></pre><p>可见，1.0版本、2.0版本，它们之间可以说是天壤之别。</p><h2>小结</h2><p>好了，这节实战就到这里。接下来我们来简单总结一下：</p><ul>\n<li>在1.0版本的代码中，我们灵活利用了<strong>动态代理、泛型、注解、反射</strong>这几个技术，实现了KtHttp的基础功能。</li>\n<li><strong>动态代理</strong>，由于它的底层原理比较复杂，课程当中我是通过ApiImpl这个类，来模拟了它动态生成的Proxy类。用这种直观的方式来帮助你理解它存在的意义。</li>\n<li><strong>泛型</strong>方面，我们将其用在了动态代理的create()方法上，后面我们还使用了“类型实化”的技术，也就是inline + reified关键字。</li>\n<li><strong>注解</strong>方面，我们首先自定义了两个注解，分别是GET、Field。其中，@GET用于标记接口的方法，它的值是URL的path；@Field用于标记参数，它的值是参数的key。</li>\n<li><strong>反射</strong>方面，这个技术点，几乎是贯穿于整个代码实现流程的。我们通过反射的自省能力，去分析repos()方法，从GET注解当中取出了“/repo”这个path，从注解Field当中取出了lang、since，还取出了repos()方法的返回值RepoList，用于JSON数据的解析。</li>\n<li>在2.0版本的代码中，我们几乎删除了之前所有的代码，<strong>以函数式的思维重写</strong>了KtHttp的内部逻辑。在这个版本当中，我们大量地使用了Kotlin标准库里的高阶函数，进一步提升了代码的可读性。</li>\n</ul><p>在前面的<a href=\"https://time.geekbang.org/column/article/478106\">加餐</a>课程当中，我们也讨论过Kotlin的编程范式问题。<strong>命令式还是函数式，这完全取决于我们开发者自身。</strong></p><p>相比起前面实战课中的<a href=\"https://time.geekbang.org/column/article/477295\">单词频率统计程序</a>，这一次我们的函数式范式的代码，实现起来就没有那么得流畅了。原因其实也很简单，Kotlin提供了强大的集合操作符，这就让Kotlin十分擅长“集合操作”的场景，因此词频统计程序，我们不到10行代码就解决了。而对于注解、反射相关的场景，函数式的编程范式就没那么擅长了。</p><p>在这节课里，我之所以费尽心思地用函数式风格，重构出KtHttp 2.0版本，主要还是想让你看到函数式编程在它不那么擅长的领域表现会如何。毕竟，我们在工作中什么问题都可能会遇到。</p><h2>思考题</h2><p>好了，学完这节课以后，请问你有哪些感悟和收获？请在评论区里分享出来，我们一起交流吧！</p>","comments":[{"had_liked":false,"id":335047,"user_name":"白乾涛","can_delete":false,"product_type":"c1","uid":1339841,"ip_address":"","ucode":"0C704B0B90C8D7","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/c1/cbc55e06.jpg","comment_is_top":false,"comment_ctime":1645268721,"is_pvip":false,"replies":[{"id":"122414","content":"是的，这也取决于团队的默契程度。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1645370463,"ip_address":"","comment_id":335047,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14530170609","product_id":100103401,"comment_content":"勉强能看明白，但这代码谁能手写的出来呀？<br><br>就算写出来了，谁保证没 bug？谁能保证别人能看明白？谁能保证后续能维护？","like_count":4,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552273,"discussion_content":"是的，这也取决于团队的默契程度。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645370463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333934,"user_name":"面无表情的生鱼片","can_delete":false,"product_type":"c1","uid":1110076,"ip_address":"","ucode":"C71B9DD25C9018","user_header":"https://static001.geekbang.org/account/avatar/00/10/f0/3c/d72b0d26.jpg","comment_is_top":false,"comment_ctime":1644597949,"is_pvip":false,"replies":[{"id":"122005","content":"在工作中，有时候确实会遇到String类型的需求。要解决这个问题的话，我们只需要将JSON解析相关逻辑抽离出去，然后将逻辑交给业务层去实现即可。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1644724575,"ip_address":"","comment_id":333934,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10234532541","product_id":100103401,"comment_content":"请教老师，如果 method.genericType 是 kotlin 的 Basic Type 的话（例如：String、Int），要怎么做兼容比较好呢？","like_count":2,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550749,"discussion_content":"在工作中，有时候确实会遇到String类型的需求。要解决这个问题的话，我们只需要将JSON解析相关逻辑抽离出去，然后将逻辑交给业务层去实现即可。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644724575,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332029,"user_name":"$Kotlin","can_delete":false,"product_type":"c1","uid":2148188,"ip_address":"","ucode":"098E9C8F60D865","user_header":"https://static001.geekbang.org/account/avatar/00/20/c7/5c/94cb3a1a.jpg","comment_is_top":false,"comment_ctime":1642990517,"is_pvip":false,"replies":[{"id":"121312","content":"后面的长动图我会改成视频形式哈。至于……这节课的动图，就辛苦你多看几遍啦。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1643010358,"ip_address":"","comment_id":332029,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10232925109","product_id":100103401,"comment_content":"动图看起来不太方便，不能暂停，而且这个动图好长。","like_count":3,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548045,"discussion_content":"后面的长动图我会改成视频形式哈。至于……这节课的动图，就辛苦你多看几遍啦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643010358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":337364,"user_name":"syz","can_delete":false,"product_type":"c1","uid":1174704,"ip_address":"","ucode":"54AF17ACD72645","user_header":"https://static001.geekbang.org/account/avatar/00/11/ec/b0/4e22819f.jpg","comment_is_top":false,"comment_ctime":1646791070,"is_pvip":true,"replies":[{"id":"123333","content":"好的，感谢你的建议，后续课程中比较长的动图我都做成视频了，随时可以暂停的。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1646886453,"ip_address":"","comment_id":337364,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5941758366","product_id":100103401,"comment_content":"动态代理的那张动图，播放中不能暂停，要懂这样过一遍没毛病。建议将每一次停顿变成带序号的标注，贴代码上来感觉会好点。","like_count":2,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555379,"discussion_content":"好的，感谢你的建议，后续课程中比较长的动图我都做成视频了，随时可以暂停的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646886453,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332092,"user_name":"木易杨","can_delete":false,"product_type":"c1","uid":1353456,"ip_address":"","ucode":"3C6EFF05AFFACA","user_header":"https://static001.geekbang.org/account/avatar/00/14/a6/f0/50d0931d.jpg","comment_is_top":false,"comment_ctime":1643013020,"is_pvip":false,"replies":[{"id":"121362","content":"别怕，适应了就好。另外，等到了源码篇，我也会集中分析一波Kotlin的高阶函数的原理和意义，请留意哈。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1643076038,"ip_address":"","comment_id":332092,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5937980316","product_id":100103401,"comment_content":"Kotlin这语法越写越变态。Java啰嗦吧，起码能看懂，没那么多语法题","like_count":2,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548190,"discussion_content":"别怕，适应了就好。另外，等到了源码篇，我也会集中分析一波Kotlin的高阶函数的原理和意义，请留意哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643076038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332070,"user_name":"阿康","can_delete":false,"product_type":"c1","uid":2697815,"ip_address":"","ucode":"DF20E1E33A8A34","user_header":"https://static001.geekbang.org/account/avatar/00/29/2a/57/6629c858.jpg","comment_is_top":false,"comment_ctime":1643006659,"is_pvip":false,"replies":[{"id":"121315","content":"其实很好理解：<br><br>return@newProxyInstance代表返回Lambda；而直接的return，代表了返回create()这个函数。<br><br>参考链接：https:&#47;&#47;kotlinlang.org&#47;docs&#47;lambdas.html#underscore-for-unused-variables","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1643010585,"ip_address":"","comment_id":332070,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5937973955","product_id":100103401,"comment_content":"Lambda 表达式当中的返回语法 能讲下吗？或者给个相关的博客连接","like_count":2,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548048,"discussion_content":"其实很好理解：\n\nreturn@newProxyInstance代表返回Lambda；而直接的return，代表了返回create()这个函数。\n\n参考链接：https://kotlinlang.org/docs/lambdas.html#underscore-for-unused-variables","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643010585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1006197,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5a/75/4e0d7419.jpg","nickname":"飓风","note":"","ucode":"18D4E8139CD7B7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548249,"discussion_content":"似乎可以不用 return@newProxyInstance？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643099692,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2697815,"avatar":"https://static001.geekbang.org/account/avatar/00/29/2a/57/6629c858.jpg","nickname":"阿康","note":"","ucode":"DF20E1E33A8A34","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548182,"discussion_content":"您可以使用限定返回语法从 lambda 显式返回一个值。否则，隐式返回最后一个表达式的值。\nints.filter {\n    val shouldFilter = it &gt; 0\n    shouldFilter\n}\n\nints.filter {\n    val shouldFilter = it &gt; 0\n    return@filter shouldFilter\n}\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643074247,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":355504,"user_name":"小江爱学术","can_delete":false,"product_type":"c1","uid":2628601,"ip_address":"四川","ucode":"554F40C6627AF4","user_header":"https://static001.geekbang.org/account/avatar/00/28/1b/f9/018197f1.jpg","comment_is_top":false,"comment_ctime":1661434774,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661434774","product_id":100103401,"comment_content":" val url = baseUrl + annotation.value<br>这行代码循环拿的是get注解的值，只能拿到path，拿不到parameters吧。<br><br>感觉可以再加一个注解，就像feignclient一样，作用在接口上，可以指定baseurl。","like_count":0},{"had_liked":false,"id":352813,"user_name":"郑峰","can_delete":false,"product_type":"c1","uid":1112517,"ip_address":"","ucode":"4D4C0C020E507C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/c5/95b97dfa.jpg","comment_is_top":false,"comment_ctime":1658949580,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658949580","product_id":100103401,"comment_content":"mapIndexed -&gt; zip<br><br>    fun invoke(url: String, method: Method, args: Array&lt;Any&gt;): Any? =<br>        method.parameterAnnotations<br>            .takeIf { it.size == args.size }<br>            ?.zip(args)<br>            ?.fold(url, ::parseUrl)<br>            ?.let { Request.Builder().url(it).build() }<br>            ?.let { okHttpClient.newCall(it).execute().body?.string() }<br>            ?.let { gson.fromJson(it, method.genericReturnType) }<br>}","like_count":0},{"had_liked":false,"id":337428,"user_name":"河山","can_delete":false,"product_type":"c1","uid":1348214,"ip_address":"","ucode":"501AF235E0DAD3","user_header":"https://static001.geekbang.org/account/avatar/00/14/92/76/343c8497.jpg","comment_is_top":false,"comment_ctime":1646817799,"is_pvip":false,"replies":[{"id":"123330","content":"如果你将上面的代码进行反编译就会发现问题了。其中主要的原因还是在于Kotlin的泛型是伪泛型。这里我们调用asT的时候，其实它只是做了一个object强转，所以并不会出问题。如果你将代码改成这样，就肯定会在运行时出现崩溃了：<br><br>```<br>fun &lt;T&gt; Int.toType():T{<br>    return (this as T)<br>}<br>class Animal{<br>    &#47;&#47; 变化在这里<br>    fun getName() = &quot;Animal&quot;<br>}<br>fun main() {<br>    println(100.toType&lt;Animal&gt;().getName())<br>}<br>```","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1646886347,"ip_address":"","comment_id":337428,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1646817799","product_id":100103401,"comment_content":"请问老师 像如下代码 <br>fun &lt;T&gt; Int.toType():T{<br>    return (this as T)<br>}<br>class Animal{}<br>fun main() {<br>    println(100.toType&lt;Animal&gt;())<br>}<br>这个不应该有类型转换异常吗 为什么我运行没有报异常 而且会输出100  但是debug模式 去运行100.toType&lt;Animal&gt;()  这个表达式 却的确会提示类型转换异常 老师 为什么运行没问题啊 ","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555376,"discussion_content":"如果你将上面的代码进行反编译就会发现问题了。其中主要的原因还是在于Kotlin的泛型是伪泛型。这里我们调用asT的时候，其实它只是做了一个object强转，所以并不会出问题。如果你将代码改成这样，就肯定会在运行时出现崩溃了：\n\n```\nfun &lt;T&gt; Int.toType():T{\n    return (this as T)\n}\nclass Animal{\n    // 变化在这里\n    fun getName() = &#34;Animal&#34;\n}\nfun main() {\n    println(100.toType&lt;Animal&gt;().getName())\n}\n```","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646886347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336113,"user_name":"PoPlus","can_delete":false,"product_type":"c1","uid":1574765,"ip_address":"","ucode":"5F0927921317F2","user_header":"https://static001.geekbang.org/account/avatar/00/18/07/6d/4c1909be.jpg","comment_is_top":false,"comment_ctime":1645934665,"is_pvip":false,"replies":[{"id":"122848","content":"其实还是靠练习，熟能生巧。我会在工作里尽量用上来，而在工作之余，我也会写点其他练手的代码，也会刷点算法题之类的。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1645968063,"ip_address":"","comment_id":336113,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1645934665","product_id":100103401,"comment_content":"操作符太多了，日常写业务不常用的话很快就忘了。不知道老师是如何知道这么多没听过的操作符（filterIsInstance、fold）🥲。","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553569,"discussion_content":"其实还是靠练习，熟能生巧。我会在工作里尽量用上来，而在工作之余，我也会写点其他练手的代码，也会刷点算法题之类的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1645968063,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":1574765,"avatar":"https://static001.geekbang.org/account/avatar/00/18/07/6d/4c1909be.jpg","nickname":"PoPlus","note":"","ucode":"5F0927921317F2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":554326,"discussion_content":"链式调用的话，就弄不清中间函数的返回类型了，不知道有什么好办法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646320338,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":553569,"ip_address":""},"score":554326,"extra":""},{"author":{"id":1342000,"avatar":"https://static001.geekbang.org/account/avatar/00/14/7a/30/23fc4089.jpg","nickname":"24隋心所欲","note":"","ucode":"1B8B2789F68C94","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1574765,"avatar":"https://static001.geekbang.org/account/avatar/00/18/07/6d/4c1909be.jpg","nickname":"PoPlus","note":"","ucode":"5F0927921317F2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591877,"discussion_content":"估计就多看源码吧，看下方法签名这种就差不多","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666884129,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":554326,"ip_address":"河北"},"score":591877,"extra":""}]}]},{"had_liked":false,"id":334495,"user_name":"山河入梦","can_delete":false,"product_type":"c1","uid":1480185,"ip_address":"","ucode":"6B8C4896012092","user_header":"https://static001.geekbang.org/account/avatar/00/16/95/f9/0d4801ce.jpg","comment_is_top":false,"comment_ctime":1644977904,"is_pvip":false,"replies":[{"id":"122239","content":"改进的方向是：我们应该尽可能消灭数据类的可空性（加餐四有提到）。具体来说，应该使用非空类型，具体怎么做，我会在后面的课程里提到哈。","user_name":"作者回复","user_name_real":"作者","uid":"1180670","ctime":1645062183,"ip_address":"","comment_id":334495,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1644977904","product_id":100103401,"comment_content":"&#47;&#47; 这种写法是有问题的，但这节课我们先不管。<br>我想问下老师，这种写法的问题在哪，因为我一直这样写来着，从昨天看了文章，就一直纠结着","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551549,"discussion_content":"改进的方向是：我们应该尽可能消灭数据类的可空性（加餐四有提到）。具体来说，应该使用非空类型，具体怎么做，我会在后面的课程里提到哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645062183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":334369,"user_name":"jim","can_delete":false,"product_type":"c1","uid":1491946,"ip_address":"","ucode":"C12DB0F2B570F6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Urc67zDC8R6dh9U1ZFTF36icXewM1seehvOUYUs4hyWSsFzS5WQc2RcrE1Mzs8qtgib5SM5wFrVh22QcQd0JUUBw/132","comment_is_top":false,"comment_ctime":1644903879,"is_pvip":false,"replies":[{"id":"122166","content":"确实，所以要多练习，多适应。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1644938709,"ip_address":"","comment_id":334369,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1644903879","product_id":100103401,"comment_content":"kotlin确实很优雅，有时候写着写着看不懂了！","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551243,"discussion_content":"确实，所以要多练习，多适应。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644938709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332801,"user_name":"梦佳","can_delete":false,"product_type":"c1","uid":1330585,"ip_address":"","ucode":"AF8E384403A86B","user_header":"https://static001.geekbang.org/account/avatar/00/14/4d/99/c4b8c4a7.jpg","comment_is_top":false,"comment_ctime":1643630112,"is_pvip":false,"replies":[{"id":"121646","content":"程序运行需要下载Gradle的依赖，需要一些科学上网的手段。（如果解决了上网问题还是不行的话，可以把错误的日志发出来给我看看。）","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1643720085,"ip_address":"","comment_id":332801,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1643630112","product_id":100103401,"comment_content":"运行不起来","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549195,"discussion_content":"程序运行需要下载Gradle的依赖，需要一些科学上网的手段。（如果解决了上网问题还是不行的话，可以把错误的日志发出来给我看看。）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643720085,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3033735,"avatar":"https://static001.geekbang.org/account/avatar/00/2e/4a/87/791d0f5e.jpg","nickname":"夏帆","note":"","ucode":"D4C9DCD01E85AD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590815,"discussion_content":"用maven也行，不是固定的，想办法跑起来就好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666083551,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332590,"user_name":"只为你停留","can_delete":false,"product_type":"c1","uid":2577082,"ip_address":"","ucode":"DEDF92E0EB0426","user_header":"https://static001.geekbang.org/account/avatar/00/27/52/ba/25f8f998.jpg","comment_is_top":false,"comment_ctime":1643356947,"is_pvip":false,"replies":[{"id":"121530","content":"这里其实是对method.parameterAnnotations当中每一个注解进行map，所以：{ index: Int, it: Annotation-&gt; ... }","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1643433048,"ip_address":"","comment_id":332590,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1643356947","product_id":100103401,"comment_content":"mapIndexed { index, it -&gt; Pair(it, args[index]) }<br>这个函数中 it -&gt; Pair(it, args[index] 怎么理解呢，尤其不理解 it -&gt;","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548880,"discussion_content":"这里其实是对method.parameterAnnotations当中每一个注解进行map，所以：{ index: Int, it: Annotation-&gt; ... }","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643433048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":1236805,"avatar":"https://static001.geekbang.org/account/avatar/00/12/df/45/e3dd6a83.jpg","nickname":"大顺子","note":"","ucode":"E77E29439B6C71","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":549703,"discussion_content":"这里的 it 类型应该是 Array&lt;Annotation&gt;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644216651,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":548880,"ip_address":""},"score":549703,"extra":""},{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1236805,"avatar":"https://static001.geekbang.org/account/avatar/00/12/df/45/e3dd6a83.jpg","nickname":"大顺子","note":"","ucode":"E77E29439B6C71","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549841,"discussion_content":"感谢这位同学的纠正，应该是：Array&lt;Annotation&gt;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644252158,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":549703,"ip_address":""},"score":549841,"extra":""}]}]},{"had_liked":false,"id":332200,"user_name":"l-zesong","can_delete":false,"product_type":"c1","uid":2880199,"ip_address":"","ucode":"7BE93E5AAA3616","user_header":"https://static001.geekbang.org/account/avatar/00/2b/f2/c7/c5855ff3.jpg","comment_is_top":false,"comment_ctime":1643094743,"is_pvip":false,"replies":[{"id":"121385","content":"它代表了返回Lambda的函数体，也就是退出InvocationHandler的invoke方法。<br><br>具体语法可以看这里：https:&#47;&#47;kotlinlang.org&#47;docs&#47;lambdas.html#returning-a-value-from-a-lambda-expression","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1643125339,"ip_address":"","comment_id":332200,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1643094743","product_id":100103401,"comment_content":"return@newProxyInstance  是什么意思啊？没看懂","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548325,"discussion_content":"它代表了返回Lambda的函数体，也就是退出InvocationHandler的invoke方法。\n\n具体语法可以看这里：https://kotlinlang.org/docs/lambdas.html#returning-a-value-from-a-lambda-expression","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643125339,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332142,"user_name":"sunlight","can_delete":false,"product_type":"c1","uid":1684437,"ip_address":"","ucode":"9E8251F9281183","user_header":"https://static001.geekbang.org/account/avatar/00/19/b3/d5/93b704b6.jpg","comment_is_top":false,"comment_ctime":1643047431,"is_pvip":false,"replies":[{"id":"121361","content":"你的理解是对的。不过，如果你想深入了解动态代理部分的内容，你去搜索一下“Java Proxy动态代理”即可，这是一个单独的Java知识点。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1643075817,"ip_address":"","comment_id":332142,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1643047431","product_id":100103401,"comment_content":"有个地方疑惑，动态代理一般会有两种使用方式吗？<br><br>方式一 create()方法中会多传个被代理对象，通过method.invoke(被代理对象)，实现拦截。外层返回代理对象<br>方式二 create()方法中只会有接口，没有手动实现被代理对象。因为我们不关心接口的具体实现，只关心接口中的注解参数，拦截获取到参数即可<br><br>文中是使用第二种，并没有手动实现被代理对象，只是最终返回了代理对象。请问这样理解对么<br>","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548187,"discussion_content":"你的理解是对的。不过，如果你想深入了解动态代理部分的内容，你去搜索一下“Java Proxy动态代理”即可，这是一个单独的Java知识点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643075817,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332064,"user_name":"7Promise","can_delete":false,"product_type":"c1","uid":2879220,"ip_address":"","ucode":"BF7C7F042E51F3","user_header":"https://static001.geekbang.org/account/avatar/00/2b/ee/f4/27a5080a.jpg","comment_is_top":false,"comment_ctime":1643004862,"is_pvip":false,"replies":[{"id":"121314","content":"这也说明你在进步，真替你感到高兴，加油~","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1643010406,"ip_address":"","comment_id":332064,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1643004862","product_id":100103401,"comment_content":"深奥的东西在经过学习原理后都是会有恍然开朗的感觉。","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548047,"discussion_content":"这也说明你在进步，真替你感到高兴，加油~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643010407,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}