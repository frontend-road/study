{"id":623106,"title":"18｜值对象（上）：到底什么是值对象？","content":"<p>你好，我是钟敬。</p><p>前面几节课我们学习了聚合，这节课我们继续学习DDD中另一个有用的概念——值对象。</p><p>DDD 把领域对象分成了两种：一种是实体，另一种是值对象。前面我们讨论的组织、员工等等都是实体。而值对象则往往是用来描述实体的属性“值”的。值对象在一些方面和实体有明显的区别，但在 DDD 提出以前，人们建模的时候，一般都只重视实体，对值对象的研究不够。DDD 强调实体和值对象的区别，可以让领域建模更加准确和深入。</p><p>但是，值对象的概念有些不太好理解，不过没关系，你可以暂时忘掉这个词本身，咱们用例子来一步一步地说明。</p><h2>例一：员工状态</h2><p>第一个例子是员工状态。在<a href=\"https://time.geekbang.org/column/article/621713\">第16课</a>，我们实现了关于<strong>员工状态</strong>（EmpStatus）的两个业务规则：<br>\n<img src=\"https://static001.geekbang.org/resource/image/3c/b3/3c8568565db9846c14d900e5316918b3.jpg?wh=3512x1136\" alt=\"\"></p><p>还记得吗？在那节课末尾，我们问了一个问题：在目前的程序里，改变员工状态的业务规则是在<strong>员工</strong>对象中实现的，你觉得放在哪里会更合适？</p><p>可能你已经想到了，应该放在<strong>员工状态</strong>（EmpStatus）本身。其实<strong>员工状态</strong>就是个值对象，至于为什么，我们后面再说。这里我们先看看实现逻辑。</p><p>之前的员工状态转换代码是后面这样。</p><pre><code class=\"language-java\">package chapter18.unjuanable.domain.orgmng.emp;\n// imports ...\n\npublic class Emp extends AggregateRoot {\n    // 其他属性 ...\n    protected EmpStatus status;\n\n    //其他方法 ...\n    \n    public Emp becomeRegular() {\n        onlyProbationCanBecomeRegular();\n        status = REGULAR;\n        return this;\n    }\n\n    public Emp terminate() {\n        shouldNotTerminateAgain();\n        status = TERMINATED;\n        return this;\n    }\n\n    private void onlyProbationCanBecomeRegular() {\n        if (status != PROBATION) {\n            throw new BusinessException(\"试用期员工才能转正！\");\n        }\n    }\n\n    private void shouldNotTerminateAgain() {\n        if (status == TERMINATED) {\n            throw new BusinessException(\"已经终止的员工不能再次终止！\");\n        }\n    }\n}\n</code></pre><!-- [[[read_end]]] --><p>现在我们把规则校验移到<strong>员工状态</strong>（EmpStatus）里面。</p><pre><code class=\"language-java\">package chapter18.unjuanable.domain.orgmng.emp;\n// imports ...\n\npublic enum EmpStatus {\n    REGULAR(\"REG\"),           // 正式\n    PROBATION(\"PRO\"),         // 试用期\n    TERMINATED(\"TER\");        // 终止\n\n    private final String code;\n\n    EmpStatus(String code) {\n        this.code = code;\n    }\n\n    public String code() {\n        return code;\n    }\n\n    //其他方法 ...\n    \n    public EmpStatus becomeRegular() {\n        if (this != PROBATION) {\n            throw new BusinessException(\"试用期员工才能转正！\");\n        }\n        return REGULAR;\n    }\n\n    public EmpStatus terminate() {\n        if (this == TERMINATED) {\n            throw new BusinessException(\"已经终止的员工不能再次终止！\");\n        }\n        return TERMINATED;\n    }\n}\n</code></pre><p>这里，EmpStatus 的<strong>转正</strong>【 becomeRegular()】方法，首先会验证自己是否满足转正的条件，满足的话就返回“正式工”（REGULAR）状态，否则抛出异常。terminate() 方法也是类似的。也就是说<strong>员工状态</strong>对象自己知道怎样的状态转换是正确的。这种逻辑的封装，才是符合面向对象设计的。</p><p>采用了新的<strong>员工状态</strong>（EmpStatus）的<strong>员工</strong>（Emp）类，就可以改成后面这样了。</p><pre><code class=\"language-java\">package chapter18.unjuanable.domain.orgmng.emp;\n// imports ...\n\npublic class Emp extends AggregateRoot {\n    // 其他属性 ...\n    protected EmpStatus status;\n\n    //其他方法 ...\n    \n    public Emp becomeRegular() {\n        status = status.becomeRegular();\n        return this;\n    }\n\n    public Emp terminate() {\n        status = status.terminate();\n        return this;\n    }\n\n    // 删除了 onlyProbationCanBecomeRegular() \n    // 删除了 shouldNotTerminateAgain() \n    \n}\n</code></pre><p>现在，Emp自己不再校验这两条业务规则了，而是委托给了EmpStatus，程序变得更加简洁。</p><p>现在，你可以先想一下，像<strong>员工状态</strong>这样的对象，和像<strong>员工</strong>这样的<strong>实体</strong>对象，有什么不一样？</p><h2>例二：时间段</h2><p>带着这个问题，我们再看一个值对象的例子。先观察一下目前的整个模型图。<br>\n<img src=\"https://static001.geekbang.org/resource/image/ab/fc/ab77a8bee5ed785e3c61c830f6c406fc.jpg?wh=2804x2373\" alt=\"\"></p><p>发现了吧？这里有好几个实体都用到了<strong>开始日期</strong>和<strong>结束日期</strong>。让我们思考几个问题。</p><p>首先，<strong>工作经验</strong>实体里“时间段不能重叠”这条业务规则，其实也应该适用于<strong>客户经理</strong>、<strong>合同经理</strong>和<strong>项目经理</strong>，只不过之前我们漏掉了。</p><p>其次，不论对于哪个实体，都应该满足“结束日期不能小于开始日期”这条规则。只不过这条规则是不言自明的，一般来说，业务人员不会专门提出来。但我们在程序里，还是要校验的，之前也还没有实现。</p><p>在目前的代码里，<strong>工作经验</strong>的“时间段不能重叠”这条规则是在<strong>员工</strong>（Emp）对象里面实现的。那么“结束日期不能小于开始日期”这个规则，是否也应该在员工对象里实现呢？如果是，根据类似的思路，对于<strong>客户经理</strong>、<strong>合同经理</strong>几个对象的同样的规则，是不是也要在<strong>客户</strong>、<strong>合同</strong>等等对象里面实现呢？显然不应该，这样会导致代码重复。</p><p>那么，这些逻辑应该在哪里实现呢？如果按照过程式的思路，我们可以写一个工具类，里面用两个静态方法来实现这两条规则，然后给其他的类调用。那么，如果按照面向对象的思路应该怎么做呢？</p><p>没错，我们可以建一个<strong>时间段</strong>对象，英文可以叫 Period，把有关<strong>时间段</strong>的数据和逻辑封装起来。我们还是以<strong>工作经验</strong>为例，先看看领域模型怎么画。原来的样子是这样的。<br>\n<img src=\"https://static001.geekbang.org/resource/image/4a/8c/4a3c15a4b5bd6497ee95a410aeaeb78c.jpg?wh=2947x1768\" alt=\"\"></p><p>有了<strong>时间段</strong>对象以后呢，就变成了这样。<br>\n<img src=\"https://static001.geekbang.org/resource/image/65/3d/650592335b96b4d5eda49878f068943d.jpg?wh=3355x1883\" alt=\"\"></p><p><strong>开始日期</strong>、<strong>结束日期</strong>、“结束日期不能小于开始日期”的<strong>规则</strong>以及判断<strong>时间段重叠</strong>的方法都移到了新建的<strong>时间段</strong>对象。这样，<strong>工作经验</strong>对象只需把<strong>时间段</strong>作为属性就可以了。另外，为了在代码里说明问题，我们在<strong>时间段</strong>里又增加了一个<strong>合并</strong>操作，用于把两个时间段合并为一个时间段。尽管我们目前的例子还用不上。</p><p>现在我们来看看程序的变化。首先是新建的<strong>时间段</strong>类。</p><pre><code class=\"language-java\">package chapter18.unjuanable.domain.orgmng.emp;\nimport java.time.LocalDate;\n\npublic class Period {\n    private LocalDate start;\n    private LocalDate end;\n\n    private Period(LocalDate start, LocalDate end) {\n        //创建时校验基本规则\n        if (start == null || end == null || start.isAfter(end)) {\n            throw new IllegalArgumentException(\n                      \"开始和结束日期不能为空，且结束日期不能小于开始日期！\");\n        }\n        this.start = start;\n        this.end = end;\n    }\n\n    //用于构造对象\n    public static Period of(LocalDate start, LocalDate end){\n        return new Period(start, end);\n    }\n\n    // 判断是否与另一时间段重叠\n    public boolean overlap(Period other) {\n        if (other == null) {\n            throw new IllegalArgumentException(\"入参不能为空！\");\n        }\n        return other.start.isBefore(this.end) \n                      &amp;&amp; other.end.isAfter(this.start);\n    }\n\n    // 合并两个时间段\n    public Period merge(Period other) {\n        LocalDate newStart = this.start.isBefore(other.start) ? \n                            this.start : other.start;\n        \n        LocalDate newEnd = this.end.isAfter(other.end) ? \n                            this.end : other.end;\n                            \n        return new Period(newStart, newEnd);\n    }\n    \n    public LocalDate getStart() {\n        return start;\n    }\n\n    public LocalDate getEnd() {\n        return end;\n    }\n}\n</code></pre><p>首先，我们把校验“结束日期不能小于开始日期”的逻辑放在了构造器里，以便保证最基本的正确性。</p><p>然后，判断<strong>时间段</strong>重叠的 overlap() 方法从原来的 <strong>Emp</strong> 类里面移到了这里。</p><p>接着，我们要注意一下合并两个<strong>时间段</strong>的 merge() 方法。它并没有改动当前的<strong>时间段</strong>和入参里的<strong>时间段</strong>，而是又新建了一个<strong>时间段</strong>，作为合并后的结果返回。事实上，你可能已经发现了，整个<strong>时间段</strong>类里，都没有可以改变自身值的方法，也就是说，时间段对象是<strong>只读对象</strong>。</p><p>应用了<strong>时间段</strong>对象的<strong>工作经验</strong>类就变成了后面这样。</p><pre><code class=\"language-java\">package chapter18.unjuanable.domain.orgmng.emp;\n//imports ...\n\npublic class WorkExperience extends AuditableEntity {\n    private Long id;\n    private Long tenantId;\n    private Period period;\n    protected String company;\n\n    protected WorkExperience(Long tenantId, Period period\n            , LocalDateTime createdAt, Long createdBy) {\n\n        super(createdAt, createdBy);\n        this.tenantId = tenantId;\n        this.period = period;\n    }\n\n    // setters and getters ...\n}\n</code></pre><p>这个类里面原来的<strong>开始日期</strong>和<strong>结束日期</strong>两个属性被<strong>时间段</strong>取代了。</p><p>咱们再看看<strong>员工</strong>类（Emp）的变化。</p><pre><code class=\"language-java\">package chapter18.unjuanable.domain.orgmng.emp;\n//imports ...\n\npublic class Emp extends AggregateRoot {\n    //其他属性 ...\n    protected List&lt;WorkExperience&gt; experiences;\n\n    // 其他方法 ...\n    \n    //原来的开始日期和结束日期两个参数变成了时间段\n    public void addExperience(Period period, String company\n                              , Long userId) {\n        durationShouldNotOverlap(period);\n\n        WorkExperience newExperience = new WorkExperience(\n                tenantId\n                , period\n                , LocalDateTime.now()\n                , userId)\n                .setCompany(company);\n\n        experiences.add(newExperience);\n    }\n\n    //这个方法的实现发生了变化\n    private void durationShouldNotOverlap(Period newPeriod) {\n        if (experiences.stream().anyMatch(\n                        e -&gt; e.getPeriod().overlap(newPeriod))) {\n            throw new BusinessException(\"工作经验的时间段不能重叠!\");\n        }\n    }\n\n    // 其他方法 ... \n}\n</code></pre><p>这里主要的变化就是，durationShouldNotOverlap() 里判断重叠的逻辑委托给了<strong>时间段</strong>对象来实现，而不是原来那样，由<strong>员工</strong>对象自己来实现。</p><h2>值对象的概念</h2><p>现在，我们来看一看<strong>员工状态</strong>（EmpStatus）和<strong>时间段</strong>（Period）这两个对象有什么共性。为了说明问题，我们把它们和<strong>员工</strong>这样的<strong>实体</strong>对照着看。</p><p>首先，咱们要先说一个“同一性”的概念，英文是 identity。如果表面上看起来有两个对象，但实际上指的是同一个东西，就说这两者具有同一性。判断同一性的问题，就是如何确定“一个对象就是这个对象自身”的问题。</p><p>比如说，在一个公司里，用员工号来区分员工，或者说员工对象的标识是员工号。张三的员工号是“001”。他去年的年龄是32岁，或者说这个员工对象的年龄属性是32。今年年龄变成了33岁。但是他的员工号还是“001”。</p><p>所以，我们就知道，尽管属性变了，但还是那个张三。即使这个公司里还有另一个叫张三的人，员工号是“002”，年龄也是33岁，但由于员工号不同，尽管姓名和年龄这两个属性都相同，我们也知道这是两个不同的员工对象。</p><p>所以说，<strong>实体是靠独立于其他属性的标识来确定“同一性”的</strong>。顺便说一句，这里说的“标识”的英文也是 identity，和“同一性”其实是一个词。</p><p>而<strong>员工状态</strong>和<strong>时间段</strong>就没有这样的标识。也可以说，它们的所有属性加在一起就是自身的标识，所以就没有独立于其他属性的标识。</p><p>比如说，<strong>时间段</strong>的标识就是<strong>起始日期</strong>和<strong>结束日期</strong>两个属性组合在一起，不需要其他单独的属性作为标识了。也就是说，<strong>时间段的所有属性值作为一个整体确定了自身的“同一性”</strong>。换句话说，只要属性值“变”了，那就已经是另外一个对象了，也就是不具有同一性了。</p><p>让我们想一下，如果时间段【2022年1月1日 ～ 2022年2月1日】的结束日期“变成”了2022年3月1日，这时，新的时间段【2022年1月1日 ～ 2022年3月1日】就已经是另外一个对象了，而原来的【2022年1月1日 ～ 2022年2月1日】这个对象本身还在那里，并没有发生改变。所以，说<strong>时间段</strong>对象“变化”本身是没有意义的。所以<strong>时间段</strong>是不可变的。</p><p>同样，<strong>员工状态</strong>也是不可变的。你可能会问了：不对呀，员工状态明明是可以改变的，比如说，可以由“试用期”改成“正式工”？</p><p>让我们仔细品一品。员工的状态（status）是员工的一个属性。这个属性的类型是员工状态（EmpStatus）。“试用期”和“正式工”这两个对象是员工状态类型的实例。员工的状态属性值可以由“试用期”变为“正式工”。这时变化的是员工的属性，而“试用期”和“正式工”这两个对象本身是不变的。</p><p>在DDD里，像<strong>员工</strong>这样有单独的标识，理论上可以改变的对象，就叫做<strong>实体</strong>（Entiy）；像<strong>员工状态</strong>和<strong>时间段</strong>这样没有单独的标识，并且不可改变的对象，就叫<strong>值对象</strong>（Value Object)。</p><p>从直观上看，实体是一个“东西”，而值对象是一个“值”，往往用来描述一个实体的属性，这也是<strong>值对象</strong>名字的由来。</p><p>那么在程序上，怎么实现这种概念上的不变性呢？我们只需要把这些对象的属性值，作为构造器参数传入来创建对象，而不提供任何方法来改变对象就可以了。</p><h2>多种多样的值对象</h2><p>在生活中我们会遇到多种多样的值对象，但值对象的概念比实体要难理解一些。所以下面，我再多举一些例子，并且把它们分一分类，以便你加深理解。</p><h3>原子值对象 vs 复合值对象</h3><p>首先，我们可以把值对象分成原子的和复合的。</p><p><strong>所谓原子值对象，是在概念上不能再拆分的值对象</strong>。比如说，整数、布尔值，日期、颜色以及状态等等，一般都建模成值对象。他们只有一个属性，不能再分了。</p><p><strong>而复合值对象是其他对象组合起来的值对象。</strong></p><p>举个例子，“长度”对象是由“数值”和“长度单位”两个属性组成的，比如“5米”“3毫米”等等。“姓名”一般也认为是值对象，由“姓”和“名”两个属性组成，如果考虑国际化，还要加上“中间名”。“地址”常常也认为是值对象，属性包括“国家”“省”“市”“区”“街道”“门牌号”等。还有，“字符串”也是复合值对象，它是由一系列的字符组成的，这种组合方式和前面几种不太一样。</p><p>现在你知道为什么Java里面String对象是不可变的了吧？因为它是<strong>值对象</strong>。但是你可能又发现一个问题，Java里Date（日期）是可变的，而我们上面说日期是值对象，不可变。这是为什么呢？</p><p>其实呀，把Date实现成可变的，是早期JDK设计的一个错误，这带来了很多问题（比如说线程不安全）。直到JDK8引入了新的日期和时间库，也就是LocalDate、LocalDatetime这些类型，才完美地解决了这个问题。而这些新的类型都是不可变的。</p><p>你看，哪怕是发明Java的牛人，有时候也没搞清楚什么是值对象。</p><p><strong>最后还有一种常见的复合值对象，就是所谓“快照”。</strong></p><p>比如修改员工的时候，可能需要把修改历史留下来，也就是我们可以看到员工信息的各个版本。一种做法就是建一个员工历史表，里面的字段和员工表差不多。每次修改，都把修改前的员工数据存一份到历史表。这些信息，就是员工在某个时刻的“快照”。快照是不可变的，因为它是历史信息，历史是不可改变的。多数值对象都比较小，但快照有时会很大，但仍然是值对象。</p><h3>独立的值对象 vs 依附于实体的值对象</h3><p>另外，<strong>值对象还可以分成独立的和依附于实体的</strong>。比如说，“时间段”“整数”都是独立的，它们可以用来描述任何实体的属性，所以可以不依附于任何实体而单独存在。但是，<strong>员工状态</strong>就是依附于实体的，它只能表达员工这个实体的状态，脱离了员工，员工状态也就没有单独存在的意义了。</p><h3>可数值对象 vs 连续值对象</h3><p><strong>值对象也可以分成可数的和连续的。</strong>可数值对象是离散的，可以一个一个列出来。比如说整数和日期、员工状态都是可数的。而实数则是连续的值对象。像颜色这样的值对象，在自然界里本来是连续的，但由于技术的限制，在计算机里一般实现为可数的，比如说，一些老式的系统只支持256种颜色。</p><h3>预定义值对象 vs 非预定义值对象</h3><p>最后，值对象还可以分成预定义的和非预定义的。</p><p><strong>所谓预定义的，就是需要以某种方式在系统里，把这种对象的值定义出来</strong>，常见的方式有程序里的枚举类型、数据库定义表，配置文件等。比如说，员工状态的三个对象“试用期”“正式工”“终止”，就是用枚举的方式定义在程序里的。而用于构造地址的“省”“市”则常常定义在数据库表里。</p><p><strong>非预定义的值对象就不必预先定义在系统里了</strong>，比如说“整数”，由于是无限的，根本就没有办法预定义。我们不可能用一个数据库表把所有整数都定义进去，当然，也没这个必要。</p><p>我们列举了这么多种值对象，把它们和前面值对象的定义对比着来想，是不是明白多了？</p><h2>总结</h2><p>好，今天先讲到这，我们来总结一下。</p><p>这节课，我们首先把业务规则封装到了<strong>员工状态</strong>和<strong>时间段</strong>两个对象中。然后把这两个对象，和员工实体做对比，总结出了<strong>实体</strong>和<strong>值对</strong>象的区别。主要包括两方面：</p><p>第一，从“同一性”来说，实体靠独立于其他属性的标识来确定“同一性”；而值对象靠所有属性值作为一个整体来确定“同一性”，没有脱离其他属性的单独的标识。</p><p>第二，从“可变性”来说，实体是可变的；值对象是不可变的。值对象的不可变性，并不来自于外在的约束，而是来自于值对象的本质，也就是说，谈论值对象是否可变本身是没有意义的。实体和值对象在可变性上的区别，其实，又是从“同一性”推导出来。</p><p>讨论完概念，我们又按照不同的维度给<strong>值对象</strong>分类，并举了更多的例子，以便你加深理解。</p><p>值对象的理解，比实体要稍微难一些，如果你还有些不太想得通的地方，没关系，在后面的课里，我们还会更深入的学习。</p><h2>思考题</h2><p>1.日期包括了年、月、日三个属性，那么，为什么日期是原子值对象，而不是复合值对象呢？</p><p>2.货币（Money） 也是常见的值对象，包括“币值”和“币种”两个属性。你能不能写个货币类的程序，实现两个货币的值相加的功能呢？例如，“5元加5元等于10元”。</p><p>好，今天的课程结束了，有什么问题欢迎在评论区留言，下节课，我们会探讨为什么要使用值对象。</p>","neighbors":{"left":{"article_title":"17｜聚合的实现（下）：怎样用事务保护聚合？","id":622338},"right":{"article_title":"19｜值对象（中）：值对象有什么好处？","id":623512}},"comments":[{"had_liked":false,"id":367275,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"北京","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":true,"comment_ctime":1675088414,"is_pvip":true,"replies":[{"id":135194,"content":"笔记记得很好，继续努力！\n状态机代码可以放在Enum。\n汇率转换，可能放在单独的“转换率”对象里比较好。关于货币的其他思路没问题。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1678978639,"ip_address":"广东","comment_id":367275,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"Java 代码写的少，居然不知道 enum 里面也可以有方法。按照类似的思路，是不是类似于状态机的代码都可以放在枚举类里面？\n\n员工状态这样的对象（enum）是没有”生命“的。\n\n时间段类也是第一次见到，原谅我书读得少，其实这段代码解决之前困扰我的一个问题，也是和历史版本相关的。\n\n这里对于代码的重构是通过”设计“来完成的。\n\n实体是靠独立于其他属性的标识 identity 来确定同一性 identity 的。\n\n有单独标识，理论上可以改变的对象，叫做实体 Entity，是一个”东西“；\n没有单独标识，并且不可以改变的对象，叫做值对象 Value Object，是一个”值“。\n\n对于思考题，\n\n1. 日期中的年、月、日三个属性，如果单独来看，拆散了”日期“这个对象的原始意义，只有当三个值都存在的时候，”日期“才有意义，时间也类似。\n2. 货币如果要写成代码话，需要把币种种类也加进来，然后可能还需要增加一个”转换汇率“的属性值？同种货币的数值与数值相加，然后保留币种。","like_count":3,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609460,"discussion_content":"笔记记得很好，继续努力！\n状态机代码可以放在Enum。\n汇率转换，可能放在单独的“转换率”对象里比较好。关于货币的其他思路没问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678978639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366611,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"浙江","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1673969876,"is_pvip":false,"replies":[{"id":134780,"content":"第1题，正如你说的，日期本质上是一个不可分割的时点。年、月、日只是一种表达方式，是表象；比如说，理论上也可以用从公元1年1月1日到现在的总日期数来表达日期。\n第2题，代码写得不错，可贵的是还有单元测试。可以在Money对象里直接有一个equals()方法，这样就不用通过value()来判断相等了。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1677931696,"ip_address":"广东","comment_id":366611,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"思考题\n1. 在日期的定义为“以年月日确定某一天”的前提下，它在概念上不能再拆分，符合“原子值对象”的定义。例如：生日、节假日、工资到账时间这些都能定位到具体的日期，年月日缺一不可。\n2. 代码如下\n\npublic enum Currency {\n    GOLD_COIN(&quot;金币&quot;),\n    GEEK_COIN(&quot;极客币&quot;),\n    ;\n\n    private String name;\n\n    Currency(String name) {\n        this.name = name;\n    }\n}\n\nimport java.math.BigDecimal;\n\npublic class Money {\n    private final BigDecimal value;\n    private final Currency currency;\n\n    public Money(BigDecimal value, Currency currency) {\n        this.value = value;\n        this.currency = currency;\n    }\n\n    public Money add(Money other) {\n        if (other == null) {\n            throw new IllegalArgumentException(&quot;货币不能为空&quot;);\n        }\n        if (this.currency != other.currency) {\n            throw new IllegalArgumentException(&quot;货币类型不一致，请转换成相同货币类型后进行计算&quot;);\n        }\n\n        return new Money(this.value.add(other.value), this.currency);\n    }\n\n    public BigDecimal value() {\n        return value;\n    }\n}\n\nimport org.junit.jupiter.api.Test;\nimport java.math.BigDecimal;\nimport static org.assertj.core.api.AssertionsForClassTypes.assertThat;\n\nclass MoneyTest {\n    @Test\n    void returns_3_when_1_plus_2(){\n        Money one = new Money(new BigDecimal(&quot;1&quot;), Currency.GOLD_COIN);\n        Money two = new Money(new BigDecimal(&quot;2&quot;), Currency.GOLD_COIN);\n        BigDecimal result = one.add(two).value();\n\n        assertThat(result).isEqualTo(new BigDecimal(&quot;3&quot;));\n    }\n}\n\n读后感\n\n原来 Java 中的 String 是值对象！\n快照也是值对象\n简单理解：不可变的对象就是值对象\n开始日期、结束日期封装在了“时间段对象”以后模型也跟着变了，确实是保持了“模型与代码一致”","like_count":7,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":607538,"discussion_content":"第1题，正如你说的，日期本质上是一个不可分割的时点。年、月、日只是一种表达方式，是表象；比如说，理论上也可以用从公元1年1月1日到现在的总日期数来表达日期。\n第2题，代码写得不错，可贵的是还有单元测试。可以在Money对象里直接有一个equals()方法，这样就不用通过value()来判断相等了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1677931696,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":607642,"discussion_content":"谢谢老师的建议","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678065981,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":607538,"ip_address":"浙江","group_id":0},"score":607642,"extra":""}]}]},{"had_liked":false,"id":367813,"user_name":"Ice","can_delete":false,"product_type":"c1","uid":1082095,"ip_address":"四川","ucode":"B2C0AD8F970981","user_header":"https://static001.geekbang.org/account/avatar/00/10/82/ef/0badf9dc.jpg","comment_is_top":false,"comment_ctime":1675650089,"is_pvip":false,"replies":[{"id":134002,"content":"数据库一般不调整，在仓库转换","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1675832296,"ip_address":"广东","comment_id":367813,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"开始时间和结束时间修改成值对象之后，与之对应的数据库结构是否需要调整呢？ 还是说在持久化层再做一次映射转换","like_count":5,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":602653,"discussion_content":"数据库一般不调整，在仓库转换","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675832296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386462,"user_name":"一剑","can_delete":false,"product_type":"c1","uid":1022127,"ip_address":"江西","ucode":"93ADD5B5215D4C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/98/af/3945cea4.jpg","comment_is_top":false,"comment_ctime":1704866583,"is_pvip":false,"replies":[{"id":141220,"content":"EmpStatus是值对象，因此，他的becomeRegular()方法只是返回一个新的值对象，而不会改变任何现有的东西。所以emp.status.becomeRegular()并不会改变emp的任何状态。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1708162063,"ip_address":"广东","comment_id":386462,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"老师，我有个问题：EmpStatus的方法是Public的，所以Emp的EmpStatus属性是为了控制状态变更不被外部直接调用所以设成了protected么？但是在实际项目里，状态应该是要用Public对外公开的吧？但是一旦公开，就可能会被人绕过聚合根而直接调用emp.status.becomeRegular()了，这个怎么解决？","like_count":1,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":637237,"discussion_content":"EmpStatus是值对象，因此，他的becomeRegular()方法只是返回一个新的值对象，而不会改变任何现有的东西。所以emp.status.becomeRegular()并不会改变emp的任何状态。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1708162064,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":391972,"user_name":"Geek_0052b7","can_delete":false,"product_type":"c1","uid":3906776,"ip_address":"重庆","ucode":"47D3222FD6F6B4","user_header":"","comment_is_top":false,"comment_ctime":1719544652,"is_pvip":false,"replies":[{"id":143666,"content":"最好不要有 addTo这样的方法，add就足够了。如果一定要有 addTo 方法，那么确实就不是值对象了。不过要想一下这么做的必要性在哪里。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1731489774,"ip_address":"广东","comment_id":391972,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"一般money对象有两类方法，如add,addTo方法。第一种方法返回值是一个新的money对象。但addTo这样的方法，就会改变money的属性值。说是它是值对象，就不对？值对象不会改变自身属性？\npublic Money addTo(Money other) {\n\t\tassertSameCurrencyAs(other);\n\n\t\tthis.cent += other.cent;\n\n\t\treturn this;\n\t}","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":653869,"discussion_content":"最好不要有 addTo这样的方法，add就足够了。如果一定要有 addTo 方法，那么确实就不是值对象了。不过要想一下这么做的必要性在哪里。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1731489774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":375492,"user_name":"YUHONGQIAN","can_delete":false,"product_type":"c1","uid":3601736,"ip_address":"北京","ucode":"958908FCCBA0EB","user_header":"https://static001.geekbang.org/account/avatar/00/36/f5/48/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1685536186,"is_pvip":false,"replies":[{"id":137135,"content":"领域模型是逐步演进的，遇到的时候识别就可以了。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1685968582,"ip_address":"广东","comment_id":375492,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"钟老师您好，我有一个疑惑，领域模型中没有每个领域实体的具体字段，是如何识别的值对象，会不会识别的不够准确。按照理解应该是每个阶段的输出结果都能对下一个阶段起到支撑，但值对象这一章，感觉没办法通过之前的成果完整的分析值对象","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":620233,"discussion_content":"领域模型是逐步演进的，遇到的时候识别就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1685968583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370603,"user_name":"benhuang","can_delete":false,"product_type":"c1","uid":2978465,"ip_address":"广西","ucode":"ED07BD37C2050E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/MHQjS55Skf9rIMV3icORoWdK7Q4dh7BJPicicAP7swA3Ca4jR96wsGfDaDZK7Md6dSia2ovnTO8Vsy0xavhnurgqww/132","comment_is_top":false,"comment_ctime":1679019528,"is_pvip":false,"replies":[{"id":135231,"content":"比如说线程不安全","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1679034220,"ip_address":"广东","comment_id":370603,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"文中提到JAVA date对象是可变的带了很多问题，具体是什么问题","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609573,"discussion_content":"比如说线程不安全","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679034220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368495,"user_name":"6点无痛早起学习的和尚","can_delete":false,"product_type":"c1","uid":1703256,"ip_address":"北京","ucode":"33A8A1CDA103F9","user_header":"https://static001.geekbang.org/account/avatar/00/19/fd/58/1af629c7.jpg","comment_is_top":false,"comment_ctime":1676411819,"is_pvip":false,"replies":[{"id":135168,"content":"addTwoMoney 可以改成非静态的:\npublic Money add(Money other) {\n    ....... &#47;&#47;校验是同一种货币\n    return new Money(this.value + other.value, this.currency);\n    \n}","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1678974315,"ip_address":"广东","comment_id":368495,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"思考题和一些问题：\n问题：1. 所以本篇文章举例的员工状态、时间段\n员工状态：原子值对象+依附于实体的值对象\n时间段：复合值对象+独立的值对象\n所以多种多样的值对象分类之间并不是完全独立不相交\n\n思考题：\npublic class Money {\n\n    private Long value;\n    private Currency currency;\n\n    private Money(Long value, Currency currency) {\n        this.value = value;\n        this.currency = currency;\n    }\n\n    public static Money of(long value, Currency currency) {\n        return new Money(value, currency);\n    }\n\n    public static Money addTwoMoney(Money money1, Money money2) {\n        &#47;&#47; 这里引入货币计算规则，把 2 个货币全部转成人民币，然后进行计算，再 new Money(value，人民币)返回\n        return new Money(0L, Currency.CNY);\n    }\n\n    @Getter\n    @AllArgsConstructor\n    public enum Currency {\n        CNY(&quot;CNY&quot;);\n        &#47;&#47;省略其他货币...\n        private String name;\n    }\n\n\n}","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609424,"discussion_content":"addTwoMoney 可以改成非静态的:\npublic Money add(Money other) {\n    ....... //校验是同一种货币\n    return new Money(this.value + other.value, this.currency);\n    \n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678974315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366476,"user_name":"Geek_ab5b86","can_delete":false,"product_type":"c1","uid":3264289,"ip_address":"上海","ucode":"A3D451394DC5A6","user_header":"","comment_is_top":false,"comment_ctime":1673839678,"is_pvip":false,"replies":[{"id":133667,"content":"是的","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1674449226,"ip_address":"广东","comment_id":366476,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"老师，类似员工实体中的身份证号idNum，我认为也是原子值对象，是不是说明也是不能修改的，实体内部不能加set方法，只能通过构造器传入值对象属性重新构造员工实体呢？","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600493,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674449226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366454,"user_name":"Geek_1e04e7","can_delete":false,"product_type":"c1","uid":2996075,"ip_address":"广东","ucode":"95DDD87FF8ECC7","user_header":"","comment_is_top":false,"comment_ctime":1673828995,"is_pvip":false,"replies":[{"id":133669,"content":"日期是时间轴上一个点，本来无所谓再分属性。年月日只是一种表示方法，还可以有其他表示法，不影响日期不可分的本质。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1674450081,"ip_address":"广东","comment_id":366454,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"分别表达年月日的值对象也是有的，职责不一样","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600496,"discussion_content":"日期是时间轴上一个点，本来无所谓再分属性。年月日只是一种表示方法，还可以有其他表示法，不影响日期不可分的本质。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674450081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366427,"user_name":"阿昕","can_delete":false,"product_type":"c1","uid":1012906,"ip_address":"浙江","ucode":"F3AD093B68E074","user_header":"https://static001.geekbang.org/account/avatar/00/0f/74/aa/178a6797.jpg","comment_is_top":false,"comment_ctime":1673770315,"is_pvip":false,"replies":[{"id":133670,"content":"没错","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1674450139,"ip_address":"广东","comment_id":366427,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"1.从含义上来看，年月日组合在一起是日期的一种固有格式，是一个整体，所以是原子值对象；\n2.货币相加，需要先校验币种是否统一，是否需要转换；","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600497,"discussion_content":"没错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674450139,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366392,"user_name":"bin","can_delete":false,"product_type":"c1","uid":1047442,"ip_address":"广东","ucode":"F540DADF3AAD87","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/92/4de0c05c.jpg","comment_is_top":false,"comment_ctime":1673690092,"is_pvip":false,"replies":[{"id":133672,"content":"我想你说的地址是值对象类型，订单地址是订单的属性吧？","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1674451285,"ip_address":"广东","comment_id":366392,"utype":1}],"discussion_count":6,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"订单地址是值对象还是实体？这样看下来是实体？两个订单地址所有字段值都一样，很明显就违反了同一性。其实地址是值对象，订单地址不是。","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600499,"discussion_content":"我想你说的地址是值对象类型，订单地址是订单的属性吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674451285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1047442,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fb/92/4de0c05c.jpg","nickname":"bin","note":"","ucode":"F540DADF3AAD87","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":600643,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674656611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":600499,"ip_address":"四川","group_id":0},"score":600643,"extra":""}]},{"author":{"id":1016155,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/81/5b/0b04626a.jpg","nickname":"kobepeng","note":"","ucode":"59F986491764DD","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":599794,"discussion_content":"是不是依附于订单的订单地址是值对象，但是对用户地址管理而言，这个是实体。到底是值对象还是实体，感觉还得根据上下文来判断","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673797556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1047442,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fb/92/4de0c05c.jpg","nickname":"bin","note":"","ucode":"F540DADF3AAD87","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1016155,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/81/5b/0b04626a.jpg","nickname":"kobepeng","note":"","ucode":"59F986491764DD","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":599813,"discussion_content":"依附于两个上下文，它们是不同的实体。这个跟值对象没啥关系了。但是地址里面有姓和名，这个就是值对象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673831118,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":599794,"ip_address":"广东","group_id":0},"score":599813,"extra":""}]},{"author":{"id":1012906,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/74/aa/178a6797.jpg","nickname":"阿昕","note":"","ucode":"F3AD093B68E074","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":599750,"discussion_content":"那订单状态是值对象吗？两个订单状态也可能一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673770408,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1047442,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fb/92/4de0c05c.jpg","nickname":"bin","note":"","ucode":"F540DADF3AAD87","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1012906,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/74/aa/178a6797.jpg","nickname":"阿昕","note":"","ucode":"F3AD093B68E074","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":599760,"discussion_content":"状态可以是值对象啊，但是订单状态一样，不代表它们是同一个东西，订单号就不一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673772546,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":599750,"ip_address":"广东","group_id":0},"score":599760,"extra":""}]}]},{"had_liked":false,"id":394024,"user_name":"py","can_delete":false,"product_type":"c1","uid":1496577,"ip_address":"上海","ucode":"2372522D715419","user_header":"https://static001.geekbang.org/account/avatar/00/16/d6/01/2448b4a9.jpg","comment_is_top":false,"comment_ctime":1725584482,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"当描述实体的属性本身有复杂值操作和约束时，属性可以引入值对象来优化代码","like_count":0}]}