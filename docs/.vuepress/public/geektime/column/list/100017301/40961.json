{"id":40961,"title":"05 | 数组：为什么很多编程语言中数组都从0开始编号？","content":"<p>提到数组，我想你肯定不陌生，甚至还会自信地说，它很简单啊。</p><p>是的，在每一种编程语言中，基本都会有数组这种数据类型。不过，它不仅仅是一种编程语言中的数据类型，还是一种最基础的数据结构。尽管数组看起来非常基础、简单，但是我估计很多人都并没有理解这个基础数据结构的精髓。</p><p>在大部分编程语言中，数组都是从0开始编号的，但你是否下意识地想过，<strong><span class=\"orange\">为什么数组要从0开始编号，而不是从1开始呢？</span></strong> 从1开始不是更符合人类的思维习惯吗？</p><p>你可以带着这个问题来学习接下来的内容。</p><h2>如何实现随机访问？</h2><p>什么是数组？我估计你心中已经有了答案。不过，我还是想用专业的话来给你做下解释。<strong>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</strong></p><p>这个定义里有几个关键词，理解了这几个关键词，我想你就能彻底掌握数组的概念了。下面就从我的角度分别给你“点拨”一下。</p><p>第一是<strong>线性表</strong>（Linear List）。顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。</p><p><img src=\"https://static001.geekbang.org/resource/image/b6/77/b6b71ec46935130dff5c4b62cf273477.jpg?wh=1142*833\" alt=\"\"></p><p>而与它相对立的概念是<strong>非线性表</strong>，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/6e/69/6ebf42641b5f98f912d36f6bf86f6569.jpg?wh=1142*727\" alt=\"\"></p><p>第二个是<strong>连续的内存空间和相同类型的数据</strong>。正是因为这两个限制，它才有了一个堪称“杀手锏”的特性：“随机访问”。但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。</p><p>说到数据的访问，那你知道数组是如何实现根据下标随机访问数组元素的吗？</p><p>我们拿一个长度为10的int类型的数组int[] a = new int[10]来举例。在我画的这个图中，计算机给数组a[10]，分配了一块连续内存空间1000～1039，其中，内存块的首地址为base_address = 1000。</p><p><img src=\"https://static001.geekbang.org/resource/image/98/c4/98df8e702b14096e7ee4a5141260cdc4.jpg?wh=1142*580\" alt=\"\"></p><p>我们知道，计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：</p><pre><code>a[i]_address = base_address + i * data_type_size\n</code></pre><p>其中data_type_size表示数组中每个元素的大小。我们举的这个例子里，数组中存储的是int类型数据，所以data_type_size就为4个字节。这个公式非常简单，我就不多做解释了。</p><p>这里我要特别纠正一个“错误”。我在面试的时候，常常会问数组和链表的区别，很多人都回答说，“链表适合插入、删除，时间复杂度O(1)；数组适合查找，查找时间复杂度为O(1)”。</p><p>实际上，这种表述是不准确的。数组是适合查找操作，但是查找的时间复杂度并不为O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是O(logn)。所以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。</p><h2>低效的“插入”和“删除”</h2><p>前面概念部分我们提到，数组为了保持内存数据的连续性，会导致插入、删除这两个操作比较低效。现在我们就来详细说一下，究竟为什么会导致低效？又有哪些改进方法呢？</p><p>我们先来看<strong>插入操作</strong>。</p><p>假设数组的长度为n，现在，如果我们需要将一个数据插入到数组中的第k个位置。为了把第k个位置腾出来，给新来的数据，我们需要将第k～n这部分的元素都顺序地往后挪一位。那插入操作的时间复杂度是多少呢？你可以自己先试着分析一下。</p><p>如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为O(1)。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是O(n)。 因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为(1+2+...n)/n=O(n)。</p><p>如果数组中的数据是有序的，我们在某个位置插入一个新的元素时，就必须按照刚才的方法搬移k之后的数据。但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数据插入到第k个位置，为了避免大规模的数据搬移，我们还有一个简单的办法就是，直接将第k位的数据搬移到数组元素的最后，把新的元素直接放入第k个位置。</p><p>为了更好地理解，我们举一个例子。假设数组a[10]中存储了如下5个元素：a，b，c，d，e。</p><p>我们现在需要将元素x插入到第3个位置。我们只需要将c放入到a[5]，将a[2]赋值为x即可。最后，数组中的元素如下： a，b，x，d，e，c。</p><p><img src=\"https://static001.geekbang.org/resource/image/3f/dc/3f70b4ad9069ec568a2caaddc231b7dc.jpg?wh=1142*511\" alt=\"\"></p><p>利用这种处理技巧，在特定场景下，在第k个位置插入一个元素的时间复杂度就会降为O(1)。这个处理思想在快排中也会用到，我会在排序那一节具体来讲，这里就说到这儿。</p><p>我们再来看<strong>删除操作</strong>。</p><p>跟插入数据类似，如果我们要删除第k个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。</p><p>和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为O(1)；如果删除开头的数据，则最坏情况时间复杂度为O(n)；平均情况时间复杂度也为O(n)。</p><p>实际上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率是不是会提高很多呢？</p><p>我们继续来看例子。数组a[10]中存储了8个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除a，b，c三个元素。</p><p><img src=\"https://static001.geekbang.org/resource/image/b6/e5/b69b8c5dbf6248649ddab7d3e7cfd7e5.jpg?wh=1142*311\" alt=\"\"></p><p>为了避免d，e，f，g，h这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。</p><p>如果你了解JVM，你会发现，这不就是JVM标记清除垃圾回收算法的核心思想吗？没错，数据结构和算法的魅力就在于此，<strong><span class=\"orange\">很多时候我们并不是要去死记硬背某个数据结构或者算法，而是要学习它背后的思想和处理技巧，这些东西才是最有价值的</span></strong>。如果你细心留意，不管是在软件开发还是架构设计中，总能找到某些算法和数据结构的影子。</p><h2>警惕数组的访问越界问题</h2><p>了解了数组的几个基本操作后，我们来聊聊数组访问越界的问题。</p><p>首先，我请你来分析一下这段C语言代码的运行结果：</p><pre><code>int main(int argc, char* argv[]){\n    int i = 0;\n    int arr[3] = {0};\n    for(; i&lt;=3; i++){\n        arr[i] = 0;\n        printf(&quot;hello world\\n&quot;);\n    }\n    return 0;\n}\n</code></pre><p>你发现问题了吗？这段代码的运行结果并非是打印三行“hello word”，而是会无限打印“hello world”，这是为什么呢？</p><p>因为，数组大小为3，a[0]，a[1]，a[2]，而我们的代码因为书写错误，导致for循环的结束条件错写为了i&lt;=3而非i&lt;3，所以当i=3时，数组a[3]访问越界。</p><p>我们知道，在C语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。根据我们前面讲的数组寻址公式，a[3]也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量i的内存地址，那么a[3]=0就相当于i=0，所以就会导致代码无限循环。</p><p>数组越界在C语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。因为，访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。</p><p>这种情况下，一般都会出现莫名其妙的逻辑错误，就像我们刚刚举的那个例子，debug的难度非常的大。而且，很多计算机病毒也正是利用到了代码中的数组越界可以访问非法地址的漏洞，来攻击系统，所以写代码的时候一定要警惕数组越界。</p><p>但并非所有的语言都像C一样，把数组越界检查的工作丢给程序员来做，像Java本身就会做越界检查，比如下面这几行Java代码，就会抛出java.lang.ArrayIndexOutOfBoundsException。</p><pre><code>int[] a = new int[3];\na[3] = 10;\n</code></pre><h2>容器能否完全替代数组？</h2><p>针对数组类型，很多语言都提供了容器类，比如Java中的ArrayList、C++ STL中的vector。在项目开发中，什么时候适合用数组，什么时候适合用容器呢？</p><p>这里我拿Java语言来举例。如果你是Java工程师，几乎天天都在用ArrayList，对它应该非常熟悉。那它与数组相比，到底有哪些优势呢？</p><p>我个人觉得，ArrayList最大的优势就是<strong>可以将很多数组操作的细节封装起来</strong>。比如前面提到的数组插入、删除数据时需要搬移其他数据等。另外，它还有一个优势，就是<strong>支持动态扩容</strong>。</p><p>数组本身在定义的时候需要预先指定大小，因为需要分配连续的内存空间。如果我们申请了大小为10的数组，当第11个数据需要存储到数组中时，我们就需要重新分配一块更大的空间，将原来的数据复制过去，然后再将新的数据插入。</p><p>如果使用ArrayList，我们就完全不需要关心底层的扩容逻辑，ArrayList已经帮我们实现好了。每次存储空间不够的时候，它都会将空间自动扩容为1.5倍大小。</p><p>不过，这里需要注意一点，因为扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好<strong>在创建ArrayList的时候事先指定数据大小</strong>。</p><p>比如我们要从数据库中取出10000条数据放入ArrayList。我们看下面这几行代码，你会发现，相比之下，事先指定数据大小可以省掉很多次内存申请和数据搬移操作。</p><pre><code>ArrayList&lt;User&gt; users = new ArrayList(10000);\nfor (int i = 0; i &lt; 10000; ++i) {\n  users.add(xxx);\n}\n</code></pre><p>作为高级语言编程者，是不是数组就无用武之地了呢？当然不是，有些时候，用数组会更合适些，我总结了几点自己的经验。</p><p>1.Java ArrayList无法存储基本类型，比如int、long，需要封装为Integer、Long类，而Autoboxing、Unboxing则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。</p><p>2.如果数据大小事先已知，并且对数据的操作非常简单，用不到ArrayList提供的大部分方法，也可以直接使用数组。</p><p>3.还有一个是我个人的喜好，当要表示多维数组时，用数组往往会更加直观。比如Object[][] array；而用容器的话则需要这样定义：ArrayList&lt;ArrayList<object> &gt; array。<p></p>\n<p>我总结一下，对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。</p>\n<h2>解答开篇</h2>\n<p>现在我们来思考开篇的问题：为什么大多数编程语言中，数组要从0开始编号，而不是从1开始呢？</p>\n<p>从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。前面也讲到，如果用a来表示数组的首地址，a[0]就是偏移为0的位置，也就是首地址，a[k]就表示偏移k个type_size的位置，所以计算a[k]的内存地址只需要用这个公式：</p>\n<pre><code>a[k]_address = base_address + k * type_size\n</code></pre>\n<p>但是，如果数组从1开始计数，那我们计算数组元素a[k]的内存地址就会变为：</p>\n<pre><code>a[k]_address = base_address + (k-1)*type_size\n</code></pre>\n<p>对比两个公式，我们不难发现，从1开始编号，每次随机访问数组元素都多了一次减法运算，对于CPU来说，就是多了一次减法指令。</p>\n<p>数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从0开始编号，而不是从1开始。</p>\n<p>不过我认为，上面解释得再多其实都算不上压倒性的证明，说数组起始编号非0开始不可。所以我觉得最主要的原因可能是历史原因。</p>\n<p>C语言设计者用0开始计数数组下标，之后的Java、JavaScript等高级语言都效仿了C语言，或者说，为了在一定程度上减少C语言程序员学习Java的学习成本，因此继续沿用了从0开始计数的习惯。实际上，很多语言中数组也并不是从0开始计数的，比如Matlab。甚至还有一些语言支持负数下标，比如Python。</p>\n<h2>内容小结</h2>\n<p>我们今天学习了数组。它可以说是最基础、最简单的数据结构了。数组用一块连续的内存空间，来存储相同类型的一组数据，最大的特点就是支持随机访问，但插入、删除操作也因此变得比较低效，平均情况时间复杂度为O(n)。在平时的业务开发中，我们可以直接使用编程语言提供的容器类，但是，如果是特别底层的开发，直接使用数组可能会更合适。</p>\n<h2>课后思考</h2>\n<ol>\n<li>\n<p>前面我基于数组的原理引出JVM的标记清除垃圾回收算法的核心理念。我不知道你是否使用Java语言，理解JVM，如果你熟悉，可以在评论区回顾下你理解的标记清除垃圾回收算法。</p>\n</li>\n<li>\n<p>前面我们讲到一维数组的内存寻址公式，那你可以思考一下，类比一下，二维数组的内存寻址公式是怎样的呢？</p>\n</li>\n</ol>\n<p>欢迎留言和我分享，我会第一时间给你反馈。</p>\n<hr>\n<p><span class=\"orange\">我已将本节内容相关的详细代码更新到GitHub，<a href=\"https://github.com/wangzheng0822/algo\">戳此</a>即可查看。</span></p>\n</object></p>","comments":[{"had_liked":false,"id":29421,"user_name":"杰杰","can_delete":false,"product_type":"c1","uid":1121620,"ip_address":"","ucode":"1E9C42DB1D8A7D","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/54/adb7bf82.jpg","comment_is_top":true,"comment_ctime":1538366727,"is_pvip":false,"replies":[{"id":"10614","content":"完全正确✅","user_name":"作者回复","comment_id":29421,"uid":"1190123","ip_address":"","utype":1,"ctime":1538405850,"user_name_real":"gg"}],"discussion_count":65,"race_medal":0,"score":"9.2233789189308006e+18","product_id":100017301,"comment_content":"JVM标记清除算法：<br><br>大多数主流虚拟机采用可达性分析算法来判断对象是否存活，在标记阶段，会遍历所有 GC ROOTS，将所有 GC ROOTS 可达的对象标记为存活。只有当标记工作完成后，清理工作才会开始。<br><br>不足：1.效率问题。标记和清理效率都不高，但是当知道只有少量垃圾产生时会很高效。2.空间问题。会产生不连续的内存空间碎片。<br><br>二维数组内存寻址：<br><br>对于 m * n 的数组，a [ i ][ j ] (i &lt; m,j &lt; n)的地址为：<br><br>address = base_address + ( i * n + j) * type_size<br><br>另外，对于数组访问越界造成无限循环，我理解是编译器的问题，对于不同的编译器，在内存分配时，会按照内存地址递增或递减的方式进行分配。老师的程序，如果是内存地址递减的方式，就会造成无限循环。<br><br>不知我的解答和理解是否正确，望老师解答？<br><br>","like_count":1602,"discussions":[{"author":{"id":2172508,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/PWicmBOULZ1oBhxDV3AywVSY5T5ATnuofZPF0xyXj2rd3BaMUxh2Bia6DpjLb0miastZkjRokCoTYrBwlIaicSbP4Q/132","nickname":"Crystal","note":"","ucode":"21350F1B96D5A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335011,"discussion_content":"我看它是明知故问","likes_number":19,"is_delete":false,"is_hidden":false,"ctime":1608048292,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1283461,"avatar":"https://static001.geekbang.org/account/avatar/00/13/95/85/15cd21c2.jpg","nickname":"杨锋","note":"","ucode":"85A7828A538FB0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":265673,"discussion_content":"二维数组也是连续存储，所以二维数组的存储地址应该是一维的地址加二维的地址。i*n*type_size+j*type_size=（i*n+j）*type_size","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1589427390,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":10,"child_discussions":[{"author":{"id":1972810,"avatar":"","nickname":"Geek_123d4e","note":"","ucode":"3E10A793C90C31","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1283461,"avatar":"https://static001.geekbang.org/account/avatar/00/13/95/85/15cd21c2.jpg","nickname":"杨锋","note":"","ucode":"85A7828A538FB0","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":275467,"discussion_content":"good","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590718435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":265673,"ip_address":""},"score":275467,"extra":""},{"author":{"id":1972810,"avatar":"","nickname":"Geek_123d4e","note":"","ucode":"3E10A793C90C31","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1283461,"avatar":"https://static001.geekbang.org/account/avatar/00/13/95/85/15cd21c2.jpg","nickname":"杨锋","note":"","ucode":"85A7828A538FB0","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":275469,"discussion_content":"good 2","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590718592,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":265673,"ip_address":""},"score":275469,"extra":""},{"author":{"id":1283461,"avatar":"https://static001.geekbang.org/account/avatar/00/13/95/85/15cd21c2.jpg","nickname":"杨锋","note":"","ucode":"85A7828A538FB0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1972810,"avatar":"","nickname":"Geek_123d4e","note":"","ucode":"3E10A793C90C31","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":276711,"discussion_content":"为毛要good2","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590932435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":275469,"ip_address":""},"score":276711,"extra":""}]},{"author":{"id":2067660,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/8c/cc/f11a17d1.jpg","nickname":"Simon_real","note":"","ucode":"C84A03DCEA885A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366106,"discussion_content":"补充一下可作为GC ROOTS的对象有哪些：\n1.虚拟机栈中引用的对象\n2.方法区类的静态成员引用的对象\n3.方法区常量引用的对象\n4.本地方法栈中JNI引用的对象","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1617960549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2839715,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/54/a3/f188a152.jpg","nickname":"MONSTER","note":"","ucode":"6B1D38BA7F1717","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2067660,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/8c/cc/f11a17d1.jpg","nickname":"Simon_real","note":"","ucode":"C84A03DCEA885A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":414320,"discussion_content":"补充：\n1.同步锁（synchronized）持有的对象\n2.JVM内部的引用，如基本数据类型的class对象，常驻异常对象（OOM）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636720124,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":366106,"ip_address":""},"score":414320,"extra":""},{"author":{"id":2555914,"avatar":"https://static001.geekbang.org/account/avatar/00/27/00/0a/078e4347.jpg","nickname":"东","note":"","ucode":"98A57ADA38A7DF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2067660,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/8c/cc/f11a17d1.jpg","nickname":"Simon_real","note":"","ucode":"C84A03DCEA885A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531387,"discussion_content":"静态成员变量存储在堆中","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1637301324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":366106,"ip_address":""},"score":531387,"extra":"{\"user_type\":1}"}]},{"author":{"id":1751177,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/b8/89/0a7fff96.jpg","nickname":"　     °^°","note":"","ucode":"6504F565CD9694","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":160898,"discussion_content":"你就是辣个课代表","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1580831137,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1754583,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/c5/d7/cd076f3a.jpg","nickname":"D","note":"","ucode":"858CAC2BDAFFC6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":71100,"discussion_content":"二维数组int[m][n]，第一层m个元素，第二层数组n个元素，所以对于int[i][j]，第一层取i个元素，包含i*n个元素，再去第二层的第j个，所以是i*n+j","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1575386346,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1179020,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fd/8c/9c00e165.jpg","nickname":"三叶草","note":"","ucode":"3718E89ABA2066","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1754583,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/c5/d7/cd076f3a.jpg","nickname":"D","note":"","ucode":"858CAC2BDAFFC6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":83784,"discussion_content":"你这个解释太抽象","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1576463502,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":71100,"ip_address":""},"score":83784,"extra":""},{"author":{"id":1245294,"avatar":"https://static001.geekbang.org/account/avatar/00/13/00/6e/11362a1e.jpg","nickname":"感动超人","note":"","ucode":"DDBFE64A9DB28D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1179020,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fd/8c/9c00e165.jpg","nickname":"三叶草","note":"","ucode":"3718E89ABA2066","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":165803,"discussion_content":"第一层里每个元素有n个第二层元素:所以内存偏移量是i*n,第二层的偏移量是j","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1581332019,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":83784,"ip_address":""},"score":165803,"extra":""},{"author":{"id":1972810,"avatar":"","nickname":"Geek_123d4e","note":"","ucode":"3E10A793C90C31","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1179020,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fd/8c/9c00e165.jpg","nickname":"三叶草","note":"","ucode":"3718E89ABA2066","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275585,"discussion_content":"二维数组可以看成一栋楼，i代表楼层，j代表每层的第几单元，a[i][j]表示总共多少个单元","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1590734876,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":83784,"ip_address":""},"score":275585,"extra":""}]},{"author":{"id":2437388,"avatar":"","nickname":"yafei","note":"","ucode":"FD61E193799E19","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351261,"discussion_content":"对于一个前端来讲，数组的访问越界问题我直接略过，压根不存在","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1614219005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2809373,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/KYdfKriaVxKe7P0Hk5e0eDwOoqjEPE4HYGqWlmTq8R7SibjyOKAhc95P13uAfH9ltGW8ib8SgfSwCnPEszicv2hXYA/132","nickname":"Geek_a94d7b","note":"","ucode":"8D438069B7DF5A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2437388,"avatar":"","nickname":"yafei","note":"","ucode":"FD61E193799E19","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590938,"discussion_content":"为什么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666176504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":351261,"ip_address":"上海"},"score":590938,"extra":""}]},{"author":{"id":2100644,"avatar":"","nickname":"Geek_8e2759","note":"","ucode":"EBDBA4D92B5C50","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326302,"discussion_content":"C 语言临时变量是存储在栈上，栈底为高位地址，栈顶为低位地址，所以 arr[3] 其实就是 i 变量的地址","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1605577264,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1671073,"avatar":"https://static001.geekbang.org/account/avatar/00/19/7f/a1/f96eec6d.jpg","nickname":"红不棱登","note":"","ucode":"9C9BAABD81E6A8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72743,"discussion_content":"PN或者G1都是使用标记复制算法，不会有内存碎片，只有老年代的标记清除才会产生内存碎片，但是老年代中有两个阶段也是并行的，系统可以正常执行业务。正常的小内存使用ParNew一般1G也就几十毫秒，而G1是可以设置GC最多花费时间的，不知道效率不高是怎么理解的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1575522576,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425593,"discussion_content":"完全正确✅","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1538405850,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1122150,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1f/66/59e0647a.jpg","nickname":"万历十五年","note":"","ucode":"3D8CF5DF847AE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":534573,"discussion_content":"二刷争哥算法，三年过去了，争哥竟然还在持续解答，赞一个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638235096,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":425593,"ip_address":""},"score":534573,"extra":""}]},{"author":{"id":1048525,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ff/cd/9c44f2d5.jpg","nickname":"Mong狗","note":"","ucode":"9DF0D65D75984E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360340,"discussion_content":"标记清除算法说的针对HotSpot虚拟机来说明显不对！！！是根据可达性分析算法找到与GC Roots不可达的可回收对象，而不是存活对象。 清理操作也是清理的标记为可回收的对象！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1616420935,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2672980,"avatar":"https://static001.geekbang.org/account/avatar/00/28/c9/54/c68ea92f.jpg","nickname":"雾深","note":"","ucode":"947C77DEBEAF4C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1048525,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ff/cd/9c44f2d5.jpg","nickname":"Mong狗","note":"","ucode":"9DF0D65D75984E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388187,"discussion_content":"所有对象默认设置标志为0，根据算法将可达对象置为1表示存活。清除为0的对象，并把为1的对象重新置为0。每清除一次就是重复执行以上操作。(核心就是标记可达对象，清除不可达对象）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628646441,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":360340,"ip_address":""},"score":388187,"extra":""}]},{"author":{"id":1533999,"avatar":"https://static001.geekbang.org/account/avatar/00/17/68/2f/fb25a9ef.jpg","nickname":"sunflower","note":"","ucode":"E1E494D59F88C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330955,"discussion_content":"大小端的问题,和处理器有关系","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1606739330,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1943619,"avatar":"","nickname":"进击的小菜","note":"","ucode":"DEDC4D31DA0DF1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":316121,"discussion_content":"二维数组我觉得理解成类似一条龙（线性表）比较形象","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603362729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2198755,"avatar":"https://static001.geekbang.org/account/avatar/00/21/8c/e3/b9e926f9.jpg","nickname":"面罩","note":"","ucode":"E85F2550D7C6D6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1943619,"avatar":"","nickname":"进击的小菜","note":"","ucode":"DEDC4D31DA0DF1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388237,"discussion_content":"嗯，看他给的公式，应该是每一行串起来，排成一排存在内存中","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1628665119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":316121,"ip_address":""},"score":388237,"extra":""}]},{"author":{"id":1255043,"avatar":"https://static001.geekbang.org/account/avatar/00/13/26/83/56086536.jpg","nickname":"执念","note":"","ucode":"D888626F69B233","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":75982,"discussion_content":"在内存分配时，会按照内存地址递增或递减的方式进行分配,我有俩个我问题不清楚问下老师。\n比如函数调用时分配的栈是20个字节，栈顶地址固定\n1.分配内存 递增方式这20个字节中是不是栈顶的地址最大，栈底的最小\n没次压栈从栈底往栈顶走，使用的分配的内存地址是递增的，\n递减方式， 栈顶地址最小，栈底最大 每次压栈都是从栈底往栈顶走，地址越来越小\n\n2.数组在压栈的时候是第一个元素先入栈 还是最后一个先入栈\n比如int a[3]  是a[0]还是a[2]先入栈\n也即是a[0]挨着i的地址还是a[2]挨着i的地址，i肯定是第一个吧\n\n如果说是编译器内存分配方式是递减的\n那么栈底地址最大，也就是i地址的值最大，也就是a[2]会挨着i, 是数组的最后一个元素先入栈,\n\nint k = 0;\nint m[3];\nprintf(&#34;k 的地址为：%p\\n&#34;,&amp;k);\nprintf(&#34;m[0] 的地址为：%p\\n&#34;,&amp;m[0]);\nprintf(&#34;m[1] 的地址为：%p\\n&#34;,&amp;m[1]);\nprintf(&#34;m[2] 的地址为：%p\\n&#34;,&amp;m[2]);\n\n\nk 的地址为：0x7fff711153dc\nm[0] 的地址为：0x7fff711153d0\nm[1] 的地址为：0x7fff711153d4\nm[2] 的地址为：0x7fff711153d8\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575802971,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1112210,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f8/92/eaafff96.jpg","nickname":"Amos","note":"","ucode":"61DB72D99AF9EA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1255043,"avatar":"https://static001.geekbang.org/account/avatar/00/13/26/83/56086536.jpg","nickname":"执念","note":"","ucode":"D888626F69B233","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":277494,"discussion_content":"深入理解计算机系统（第三版）P128：x86-64中，栈向低地址方向增长，所以压栈是减小栈指针（寄存器%rsp）的值，并将数据存放到内存中，而出栈是从内存中读数据，并增加栈指针的值。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1591062035,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":75982,"ip_address":""},"score":277494,"extra":""}]},{"author":{"id":1269996,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/ec/11cf22de.jpg","nickname":"名:海东","note":"","ucode":"0BBF4402F75D07","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46424,"discussion_content":"什么是可达？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573169617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1037940,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d6/74/6f04af6f.jpg","nickname":"鸿溟","note":"","ucode":"C8FC4C3DB6161E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1269996,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/ec/11cf22de.jpg","nickname":"名:海东","note":"","ucode":"0BBF4402F75D07","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57239,"discussion_content":"JVM 中有称为一系列的GCRoots的对象，如果一个对象没有任何一条与GCRoots相连的路径时，就称为不可达。","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1574585058,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":46424,"ip_address":""},"score":57239,"extra":""},{"author":{"id":1103353,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d5/f9/1f9a2c3c.jpg","nickname":"磨砖做镜","note":"","ucode":"D8B8196AE1ED98","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1269996,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/ec/11cf22de.jpg","nickname":"名:海东","note":"","ucode":"0BBF4402F75D07","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275965,"discussion_content":"方法区里的常量和静态变量，栈空间的引用对象作为root起点，可以找到的关联对象形成gc roots链，也即可达","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590796316,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":46424,"ip_address":""},"score":275965,"extra":""},{"author":{"id":2555914,"avatar":"https://static001.geekbang.org/account/avatar/00/27/00/0a/078e4347.jpg","nickname":"东","note":"","ucode":"98A57ADA38A7DF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1103353,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d5/f9/1f9a2c3c.jpg","nickname":"磨砖做镜","note":"","ucode":"D8B8196AE1ED98","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531388,"discussion_content":"静态变量在堆中","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637301380,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":275965,"ip_address":""},"score":531388,"extra":"{\"user_type\":1}"}]},{"author":{"id":1137353,"avatar":"https://static001.geekbang.org/account/avatar/00/11/5a/c9/933ee0a8.jpg","nickname":"冉野","note":"","ucode":"2CAEA424996876","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348,"discussion_content":"对于优先行存储的方式 例如a(3x3)的二维数组，a[2][3] 在计算机理解时候会直接翻译成 a[i*n+j][3] ,可以把a[2][3]看成是首地址是a[2] 下标为3，还可看作是（每行有多少个元素 + j） * 类型字符所占字节数","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1561465953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1435733,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e8/55/92f82281.jpg","nickname":"MClink","note":"","ucode":"F479190923355C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573425,"discussion_content":"首先只要是数组，就是连续空间的，不管是几维的，可以当做一排连续的豆腐块。假设是二维，第一块就是 a[0][0],第二块是 a[0][1] 如此排列下去，想知道地址，就可以直接算了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653404983,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1183518,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0f/1e/6b6eb987.jpg","nickname":"我们在路上","note":"","ucode":"0DB77DB7C64C47","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572894,"discussion_content":"我觉得寻址公式不对啊：二维数组寻址只能一个个元素往后找？不应该是先找到a[i]的位置，再从a[i][0]开始找到a[i][j]吗，怎么会是a[0][0]找到a[0][j]....这样一个个寻找到a[i][j]呢?二维数组只是每个维里内存地址连续，不一定是整个二维数组内存地址连续吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653032479,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2682840,"avatar":"https://static001.geekbang.org/account/avatar/00/28/ef/d8/455e2194.jpg","nickname":"葉落归尘","note":"","ucode":"63442DA2CAFF0A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385173,"discussion_content":"有行优先和列优先存储之分？此类是行优先","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626932055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2107673,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erWv2fBsDOF4R5uxUqjVt6e5eF20blU0Vvf8fHxrtncoNR0f8uZ9jnoKhgg7vCOoCfrG3ibs8UHxXA/132","nickname":"Geek_86a66d","note":"","ucode":"24E996C5FF91A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363633,"discussion_content":"你怎么这么优秀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617250316,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1112210,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f8/92/eaafff96.jpg","nickname":"Amos","note":"","ucode":"61DB72D99AF9EA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":277490,"discussion_content":"“在内存分配时，会按照内存地址递增或递减的方式进行分配。” 这个是大端方式和小端方式的差别么 ？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591061508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2016786,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/c6/12/7c36aa3a.jpg","nickname":"Black船长","note":"","ucode":"B0B73E8DEB56C4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1112210,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f8/92/eaafff96.jpg","nickname":"Amos","note":"","ucode":"61DB72D99AF9EA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":280839,"discussion_content":"我理解不是。比如一个int 占32位4字节，这4个字节中，对应内存中4个地址（每个地址只能存一个字节数据），大小端只这4个字节的数据和4个地址的映射关系，高位字节的数据是放在高地址还是低地址。大小端不是编译器能决定的，貌似是CPU那块定的。层主说的应该是这个上一层次的内存分配（比如给数组里每一个int分配地址（4个内存地址）的时候，内存是递增还是递减，大小端是这4个地址内部数据的存储方式）","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1591619230,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":277490,"ip_address":""},"score":280839,"extra":""},{"author":{"id":1394147,"avatar":"https://static001.geekbang.org/account/avatar/00/15/45/e3/26d1e69c.jpg","nickname":"Aaron 延亮","note":"","ucode":"48DE83DDF45A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1112210,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f8/92/eaafff96.jpg","nickname":"Amos","note":"","ucode":"61DB72D99AF9EA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295099,"discussion_content":"没什么关系，看栈的存储结构，这个与操作系统有关了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596089864,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":277490,"ip_address":""},"score":295099,"extra":""}]},{"author":{"id":1234871,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d7/b7/3b64c016.jpg","nickname":"tzqiang","note":"","ucode":"88AB97F139A9BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":65272,"discussion_content":"什么时候回开始标记？内存不足时？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574992722,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1763345,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/e8/11/d79c9bdf.jpg","nickname":"无题","note":"","ucode":"764866153A2266","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1234871,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d7/b7/3b64c016.jpg","nickname":"tzqiang","note":"","ucode":"88AB97F139A9BF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74541,"discussion_content":"看jvm设置的参数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575646384,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":65272,"ip_address":""},"score":74541,"extra":""},{"author":{"id":2839715,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/54/a3/f188a152.jpg","nickname":"MONSTER","note":"","ucode":"6B1D38BA7F1717","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1763345,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/e8/11/d79c9bdf.jpg","nickname":"无题","note":"","ucode":"764866153A2266","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":414321,"discussion_content":"能细说一下吗，没找到相关的东西","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636720426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":74541,"ip_address":""},"score":414321,"extra":""},{"author":{"id":2555914,"avatar":"https://static001.geekbang.org/account/avatar/00/27/00/0a/078e4347.jpg","nickname":"东","note":"","ucode":"98A57ADA38A7DF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2839715,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/54/a3/f188a152.jpg","nickname":"MONSTER","note":"","ucode":"6B1D38BA7F1717","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531389,"discussion_content":"看具体的垃圾回收器，cms，g1都有默认的内存占用达到多少比例后进行垃圾回收 ，cms是这个参数设置-XX:CMSlnitiatingOccupanyFraction ，g1是这个 -XX：+InitiatingHeapOccupancyPercent","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637301510,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":414321,"ip_address":""},"score":531389,"extra":"{\"user_type\":1}"}]},{"author":{"id":1658778,"avatar":"https://static001.geekbang.org/account/avatar/00/19/4f/9a/e71af464.jpg","nickname":"慧","note":"","ucode":"E0FC2EF7AE33B2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55670,"discussion_content":"为什么内存地址递减的方式，就会造成无限循环？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574388462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1665332,"avatar":"https://static001.geekbang.org/account/avatar/00/19/69/34/2fa34bcc.jpg","nickname":"Yzt","note":"","ucode":"776372E85D96DF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1658778,"avatar":"https://static001.geekbang.org/account/avatar/00/19/4f/9a/e71af464.jpg","nickname":"慧","note":"","ucode":"E0FC2EF7AE33B2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70503,"discussion_content":"函数调用所用变量及参数是在栈内存空间(LIFO)，压栈是往内存低地址方向增长。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575362911,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":55670,"ip_address":""},"score":70503,"extra":""}]},{"author":{"id":1448864,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1b/a0/7c7d1b4a.jpg","nickname":"徐帅","note":"","ucode":"BDF904280E2330","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8207,"discussion_content":"对于数组越界无限循环的问题，除了地址分配从高到低，要好满足release版本才会无限，而debug版本中间会多分配几个字节为debug信息，这是我测试的结果。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567830228,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1644586,"avatar":"https://static001.geekbang.org/account/avatar/00/19/18/2a/7a12c412.jpg","nickname":"日月焕星辰","note":"","ucode":"E60D2188D73418","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7171,"discussion_content":"address = base_address + ( i * n + j) * type_size   为啥不是address = base_address + ( i + j) * type_size?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567413908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":11,"child_discussions":[{"author":{"id":1646248,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1e/a8/b6d901a6.jpg","nickname":"浮生","note":"","ucode":"2D3256F7595E1B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1644586,"avatar":"https://static001.geekbang.org/account/avatar/00/19/18/2a/7a12c412.jpg","nickname":"日月焕星辰","note":"","ucode":"E60D2188D73418","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7396,"discussion_content":"个人理解：对于二维数组的存储实际上就事多个一维数组的存储，如a[2][3]={{1 ,2, 3},{4, 5, 6}},所以说对于m*n的二维数组，a[i][j]的地址address = base_address + ( i * n + j) * type_size","likes_number":12,"is_delete":false,"is_hidden":false,"ctime":1567503916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7171,"ip_address":""},"score":7396,"extra":""},{"author":{"id":1644586,"avatar":"https://static001.geekbang.org/account/avatar/00/19/18/2a/7a12c412.jpg","nickname":"日月焕星辰","note":"","ucode":"E60D2188D73418","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1646248,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1e/a8/b6d901a6.jpg","nickname":"浮生","note":"","ucode":"2D3256F7595E1B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7576,"discussion_content":"ok，明白了，3q","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1567573514,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7396,"ip_address":""},"score":7576,"extra":""},{"author":{"id":1684311,"avatar":"https://static001.geekbang.org/account/avatar/00/19/b3/57/2d92cf9a.jpg","nickname":"姜川","note":"","ucode":"0F8A349623EAB5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1646248,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1e/a8/b6d901a6.jpg","nickname":"浮生","note":"","ucode":"2D3256F7595E1B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":23146,"discussion_content":"意思是二维数组在内存分配时，并非二维的，也是连续存储空间，存完一行，在末尾追了第二行，追加第三行，所以a[m][n]的数组，在内存存储是连续分配了m*n*type_size的空间，a[i][j]就是 i行 第j个，i行前面有 i*n个数据，所有就是 (i*n+j)","likes_number":20,"is_delete":false,"is_hidden":false,"ctime":1569759999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7396,"ip_address":""},"score":23146,"extra":""}]}]},{"had_liked":false,"id":29358,"user_name":"slvher","can_delete":false,"product_type":"c1","uid":1018964,"ip_address":"","ucode":"F4ED6980C8248B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/54/deb19880.jpg","comment_is_top":false,"comment_ctime":1538357772,"is_pvip":false,"replies":[{"id":"10629","content":"👍 高手！","user_name":"作者回复","comment_id":29358,"uid":"1190123","ip_address":"","utype":1,"ctime":1538407496,"user_name_real":"gg"}],"discussion_count":36,"race_medal":0,"score":"7852738574860","product_id":100017301,"comment_content":"对文中示例的无限循环有疑问的同学，建议去查函数调用的栈桢结构细节（操作系统或计算机体系结构的教材应该会讲到）。<br><br>函数体内的局部变量存在栈上，且是连续压栈。在Linux进程的内存布局中，栈区在高地址空间，从高向低增长。变量i和arr在相邻地址，且i比arr的地址大，所以arr越界正好访问到i。当然，前提是i和arr元素同类型，否则那段代码仍是未决行为。","like_count":1829,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425563,"discussion_content":"👍 高手！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538407496,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1921816,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLI2N2EugEticG0EgoE97g7iaQ53QLboMQuHhW7ANsc84n65ypyic7RnrZZfyQGPl5hmtgmzRRSB8WEw/132","nickname":"he","note":"","ucode":"EEAF1416346DD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":247228,"discussion_content":"不知道理解的对不对，栈分配地址是从高到低，arr数组内部的地址是从低到高，arr[3]的地址恰好是i的地址","likes_number":20,"is_delete":false,"is_hidden":false,"ctime":1587805820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1805022,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/8a/de/da52615e.jpg","nickname":"访冬","note":"","ucode":"69C097FDA67026","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":227476,"discussion_content":"我当场裂开，太强了吧！","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1586495594,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1779257,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKfLxAj43sGzJTnmdh8iawoNJ1VsdFvJHTHccxkX7HhtOFtTV9icG3B2Gt5EztPOicsicc3xG0XTlyUVg/132","nickname":"luoyayun361","note":"","ucode":"D3AD83D44EE721","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211743,"discussion_content":"“且i比arr的地址大，所以arr越界正好访问到i ”  但是此时的i不是应该等于3吗  为什么是变成了0呢，还是没明白","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1584885897,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1985298,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/4b/12/cf361333.jpg","nickname":"Henry","note":"","ucode":"A259F2B1E939E3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1779257,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKfLxAj43sGzJTnmdh8iawoNJ1VsdFvJHTHccxkX7HhtOFtTV9icG3B2Gt5EztPOicsicc3xG0XTlyUVg/132","nickname":"luoyayun361","note":"","ucode":"D3AD83D44EE721","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261466,"discussion_content":"a[3] = 0 ，给a[3]的地址赋值，就把i变成0了","likes_number":12,"is_delete":false,"is_hidden":false,"ctime":1588955452,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":211743,"ip_address":""},"score":261466,"extra":""},{"author":{"id":2385529,"avatar":"https://static001.geekbang.org/account/avatar/00/24/66/79/4ccd25c7.jpg","nickname":"Adelaide","note":"","ucode":"5E76210F7A8C77","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1985298,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/4b/12/cf361333.jpg","nickname":"Henry","note":"","ucode":"A259F2B1E939E3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337478,"discussion_content":"终于明白了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608941929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":261466,"ip_address":""},"score":337478,"extra":""},{"author":{"id":2198755,"avatar":"https://static001.geekbang.org/account/avatar/00/21/8c/e3/b9e926f9.jpg","nickname":"面罩","note":"","ucode":"E85F2550D7C6D6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1779257,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKfLxAj43sGzJTnmdh8iawoNJ1VsdFvJHTHccxkX7HhtOFtTV9icG3B2Gt5EztPOicsicc3xG0XTlyUVg/132","nickname":"luoyayun361","note":"","ucode":"D3AD83D44EE721","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388238,"discussion_content":"a[3] 越界，且正好是 i 的地址，a[3] = 0 就是把 i 赋值为 0","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628665435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":211743,"ip_address":""},"score":388238,"extra":""}]},{"author":{"id":1566153,"avatar":"https://static001.geekbang.org/account/avatar/00/17/e5/c9/1a46f935.jpg","nickname":"春华秋实","note":"","ucode":"6C02AE45095D03","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":65782,"discussion_content":"i 和 arr 的定义更改一下位置，还是会无限循环，这是为什么呢","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1575028454,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2268524,"avatar":"https://static001.geekbang.org/account/avatar/00/22/9d/6c/e96a9229.jpg","nickname":"唐继馀(yú)","note":"","ucode":"1E09BF3B55E49D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1566153,"avatar":"https://static001.geekbang.org/account/avatar/00/17/e5/c9/1a46f935.jpg","nickname":"春华秋实","note":"","ucode":"6C02AE45095D03","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325911,"discussion_content":"为什么。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605459871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":65782,"ip_address":""},"score":325911,"extra":""},{"author":{"id":2699316,"avatar":"https://static001.geekbang.org/account/avatar/00/29/30/34/2c487821.jpg","nickname":"HashWky","note":"","ucode":"3F95646EA9725A","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":1566153,"avatar":"https://static001.geekbang.org/account/avatar/00/17/e5/c9/1a46f935.jpg","nickname":"春华秋实","note":"","ucode":"6C02AE45095D03","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584376,"discussion_content":"是的，我也疑惑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660793185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":65782,"ip_address":"湖北"},"score":584376,"extra":""}]},{"author":{"id":1276563,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7a/93/c9302518.jpg","nickname":"高志强","note":"","ucode":"68737002043752","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332145,"discussion_content":"厉害厉害，计算机学的很透彻","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1607074434,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1796720,"avatar":"","nickname":"涤生","note":"","ucode":"09084D994BEFA4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":165754,"discussion_content":"首先定义的i=0，再定义的a，当数组越界之后，为嘛会让i重新定义呢？\n刚看评论，已经晓得答案了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1581322714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238514,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/f2/21ea4d37.jpg","nickname":"独舟泛海","note":"","ucode":"E35C8CEFAF062D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":37086,"discussion_content":"栈是从高地址空间向小的方向增长，那数组arr分配的时候，第0个元素，直接分配的最小的地址？因为数组的寻址是向大的方向增长的啊","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1571498030,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2399040,"avatar":"https://static001.geekbang.org/account/avatar/00/24/9b/40/4880fd0b.jpg","nickname":"俨-zen","note":"","ucode":"7CF6CAF6F0DFDB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360631,"discussion_content":"汇编！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1616494154,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2161180,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/jtNYcW0hUoI1RzVic1tpJ7mkh4nccicC3aaC4aicYQCy9R1RZBMSWn8qDxjvVKqca9LnWxCfsicEqeW0bUkX6Bogyg/132","nickname":"Geek_d586af","note":"","ucode":"2966DBC6BD9B20","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329723,"discussion_content":"绝对的大佬","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1606450239,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2056201,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/60/09/a8e7913b.jpg","nickname":"SandCarving","note":"","ucode":"6B97DB71613A46","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295192,"discussion_content":"太强了，膜拜","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596113517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2067839,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/8d/7f/5a623195.jpg","nickname":"JustToFaith","note":"","ucode":"2E04AC5C418812","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291863,"discussion_content":"太强了，虽然知识点都知道，但是真没有想到这一点。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594978893,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1245956,"avatar":"https://static001.geekbang.org/account/avatar/00/13/03/04/44692930.jpg","nickname":"Rick","note":"","ucode":"E088D8AA9E985F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":156816,"discussion_content":"刚有疑问 就有大神解答，这就是极客时间的魅力","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1580397781,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1926508,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/65/6c/be97a3ae.jpg","nickname":"Geek_bb2310","note":"","ucode":"022885B257DEB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1245956,"avatar":"https://static001.geekbang.org/account/avatar/00/13/03/04/44692930.jpg","nickname":"Rick","note":"","ucode":"E088D8AA9E985F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":256590,"discussion_content":"嗯嗯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588501343,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":156816,"ip_address":""},"score":256590,"extra":""}]},{"author":{"id":2699316,"avatar":"https://static001.geekbang.org/account/avatar/00/29/30/34/2c487821.jpg","nickname":"HashWky","note":"","ucode":"3F95646EA9725A","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584377,"discussion_content":"变量还数组定义顺序更改，依旧时无限循环","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660793256,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"湖北"},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645599,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/1f/49155f50.jpg","nickname":"黑暗中行走","note":"","ucode":"12FAA327ECDE72","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":567752,"discussion_content":"要理解这个为什么会循环，还是得懂数组在内存中如何存储的才行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650985232,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2107804,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ7VKDBDPfEML4J8gtSxTLv9f4kAdE46IC3leV4DS88HqZLj5dQOEicLTkJmkGV14KKruhP0Xv1jlA/132","nickname":"LalexH","note":"","ucode":"D35144BD4EB872","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558286,"discussion_content":"    int arr1[3] = {0};\n    printf(&#34;数组的第一个元素的地址：%p\\n&#34;, &amp;arr1[0]);\n    printf(&#34;数组的第二个元素的地址：%p\\n&#34;, &amp;arr1[1]);\n    printf(&#34;数组的第三个元素的地址：%p\\n&#34;, &amp;arr1[2]);\n\n    int i1 = 0;\n    printf(&#34;i1的地址:%p\\n&#34;, &amp;i1);\n\n    int j1 = 0;\n    printf(&#34;j1的地址:%p\\n&#34;, &amp;j1);\n\n    int k1 = 0;\n    printf(&#34;k1的地址:%p\\n&#34;, &amp;k1);\n\n我定义了4个局部变量，然后输出他们的内存地址：\n数组的第一个元素的地址：0x7ffeeb51d34c\n数组的第二个元素的地址：0x7ffeeb51d350\n数组的第三个元素的地址：0x7ffeeb51d354\ni1的地址:0x7ffeeb51d334\nj1的地址:0x7ffeeb51d330\nk1的地址:0x7ffeeb51d32c\n\n发现，数组的元素地址是4c 50 54，按照您的理解应该是 4c 48 44才对，并且arr1[3] 的地址将会是 40\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648191021,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1544275,"avatar":"","nickname":"B la c k AI","note":"","ucode":"3E4DA6AC2F8D23","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":407574,"discussion_content":"这个跟具体的c语言实现是相关的吗，如果是的话，是不是不宜作为一个c语言的例子，因为不同的实现会导致行为不一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635063655,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2631446,"avatar":"https://static001.geekbang.org/account/avatar/00/28/27/16/00716947.jpg","nickname":"Screw","note":"","ucode":"4BCC5912E0DC4C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386072,"discussion_content":"感谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627392537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1031174,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/bc/06/806fa222.jpg","nickname":"赖small强","note":"","ucode":"4C33BBBEE31150","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366146,"discussion_content":"但实际测试下，打印4次后 系统Crash","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617969963,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015512,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7e/d8/92a98fb6.jpg","nickname":"逍遥思","note":"","ucode":"340F05C786730F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":64581,"discussion_content":"let tcl = 太强了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574950944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1034936,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ca/b8/2424e0c6.jpg","nickname":"Kisto","note":"","ucode":"F00CF6D13AEB67","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55612,"discussion_content":"天呐 怎么都这么厉害","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574386025,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066430,"avatar":"https://static001.geekbang.org/account/avatar/00/10/45/be/c04a40ce.jpg","nickname":"3W1H","note":"","ucode":"F6B4864128103C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40503,"discussion_content":"为啥i 的地址比arr的地址大呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572225845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1712104,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/1f/e8/42c25742.jpg","nickname":"暖心疯子不要死","note":"","ucode":"A03220F52E36D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1066430,"avatar":"https://static001.geekbang.org/account/avatar/00/10/45/be/c04a40ce.jpg","nickname":"3W1H","note":"","ucode":"F6B4864128103C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40979,"discussion_content":"我查了一下 如果栈的内存分配是从高地址到低地址的话 i的地址就是arr[3]的地址","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1572317947,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":40503,"ip_address":""},"score":40979,"extra":""},{"author":{"id":1712104,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/1f/e8/42c25742.jpg","nickname":"暖心疯子不要死","note":"","ucode":"A03220F52E36D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1066430,"avatar":"https://static001.geekbang.org/account/avatar/00/10/45/be/c04a40ce.jpg","nickname":"3W1H","note":"","ucode":"F6B4864128103C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40990,"discussion_content":"你可以评论区稍微往后拉一下 有一位hope的朋友  你去看看他评论的回复就明白了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1572319454,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":40503,"ip_address":""},"score":40990,"extra":""}]},{"author":{"id":1074310,"avatar":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","nickname":"多襄丸","note":"","ucode":"1AA1497C5A293C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":32207,"discussion_content":"说到好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571016325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1520267,"avatar":"","nickname":"Geek_382ccc","note":"","ucode":"3E40727B8772AA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":25635,"discussion_content":"膜拜大神，请问未决行为是什么意思？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570543956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1378111,"avatar":"https://static001.geekbang.org/account/avatar/00/15/07/3f/43872dff.jpg","nickname":"积微","note":"","ucode":"373DF8B1DC002B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":25506,"discussion_content":"拿起我的小本记下大神的解读","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570534600,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1621658,"avatar":"https://static001.geekbang.org/account/avatar/00/18/be/9a/b0b89be3.jpg","nickname":"不动声色满心澎湃","note":"","ucode":"80D8F9E49AF7C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5909,"discussion_content":"本来要反驳的， 结果发现下面已经有大神解释了，这里就不多解释了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566532353,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1211178,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7b/2a/7d8b5943.jpg","nickname":"LH","note":"","ucode":"819B9B2409E834","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2661,"discussion_content":"如果不是同类型是不是在两个不同的栈里面？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563849216,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30520,"user_name":"夜下凝月","can_delete":false,"product_type":"c1","uid":1256730,"ip_address":"","ucode":"247824573D25B5","user_header":"https://static001.geekbang.org/account/avatar/00/13/2d/1a/fcfd9872.jpg","comment_is_top":false,"comment_ctime":1538905384,"is_pvip":false,"discussion_count":43,"race_medal":0,"score":"4970816066856","product_id":100017301,"comment_content":"突然想到了垃圾桶。<br>生活中，我们扔进屋里垃圾桶的垃圾，<br>并没有消失，只是被  &#39;&#39;标记&#39;&#39;  成了垃圾，<br>只有垃圾桶塞满时，才会清理垃圾桶。<br>再次存放垃圾","like_count":1158,"discussions":[{"author":{"id":2708065,"avatar":"https://static001.geekbang.org/account/avatar/00/29/52/61/0c0a5982.jpg","nickname":"Leetion","note":"","ucode":"D7BD236D4C55F0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384828,"discussion_content":"我觉得垃圾桶应该叫垃圾栈比较合理，因为垃圾往往先入后出。","likes_number":25,"is_delete":false,"is_hidden":false,"ctime":1626765556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2761095,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/21/87/5671e970.jpg","nickname":"ᴄʜᴇʀɪs.","note":"","ucode":"FFA1ECE11F4EA2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2708065,"avatar":"https://static001.geekbang.org/account/avatar/00/29/52/61/0c0a5982.jpg","nickname":"Leetion","note":"","ucode":"D7BD236D4C55F0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":409011,"discussion_content":"牛啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635350178,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":384828,"ip_address":""},"score":409011,"extra":""}]},{"author":{"id":2255165,"avatar":"https://static001.geekbang.org/account/avatar/00/22/69/3d/436a7407.jpg","nickname":"月见草","note":"","ucode":"C0A2B0B14E73D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374623,"discussion_content":"垃圾桶的一个作用是后悔药，类似数据假删除，一个作用是降低清理垃圾的次数，避免下楼丢垃圾，这个操作很耗时，主要还是太懒。","likes_number":14,"is_delete":false,"is_hidden":false,"ctime":1621292275,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2198755,"avatar":"https://static001.geekbang.org/account/avatar/00/21/8c/e3/b9e926f9.jpg","nickname":"面罩","note":"","ucode":"E85F2550D7C6D6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2255165,"avatar":"https://static001.geekbang.org/account/avatar/00/22/69/3d/436a7407.jpg","nickname":"月见草","note":"","ucode":"C0A2B0B14E73D1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388239,"discussion_content":"是的，后悔药，大不了再出栈嘛","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628665491,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":374623,"ip_address":""},"score":388239,"extra":""}]},{"author":{"id":1439568,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f7/50/cbfe1bc0.jpg","nickname":",","note":"","ucode":"191431A878D7B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294879,"discussion_content":"严重怀疑GC垃圾回收算法设计者就是来源于这样的思想！","likes_number":14,"is_delete":false,"is_hidden":false,"ctime":1596023771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121187,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1b/a3/64a37f40.jpg","nickname":"小兵","note":"","ucode":"B7E49B7C772036","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60276,"discussion_content":"有点不太恰当，垃圾桶固定到一个位置，垃圾需要放入里面，标记垃圾还在原来的位置只不过做了一个标记而已。","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1574725017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1198158,"avatar":"https://static001.geekbang.org/account/avatar/00/12/48/4e/51896855.jpg","nickname":"落风","note":"","ucode":"D70B221D22A439","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1121187,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1b/a3/64a37f40.jpg","nickname":"小兵","note":"","ucode":"B7E49B7C772036","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":121030,"discussion_content":"可以理解成操作系统桌面上的垃圾桶","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1578309565,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":60276,"ip_address":""},"score":121030,"extra":""},{"author":{"id":1861945,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/4nRUmVqj6g59wwDwPvNiafK5wRPJY9YB6GUKFXV6qdicIVtjvlricF0dbpvFmV8TyNsw9ciak5LLVbxDQBYl3UYILQ/132","nickname":"HCY","note":"","ucode":"D779EDF89EE6B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1198158,"avatar":"https://static001.geekbang.org/account/avatar/00/12/48/4e/51896855.jpg","nickname":"落风","note":"","ucode":"D70B221D22A439","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":223604,"discussion_content":"也不太对吧，操作系统桌面上的垃圾桶，文件的内存地址变了啊。\n感觉标记的关键在于，物理地址没有发生变化吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586239957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":121030,"ip_address":""},"score":223604,"extra":""},{"author":{"id":1322362,"avatar":"https://static001.geekbang.org/account/avatar/00/14/2d/7a/3a37efe4.jpg","nickname":"金霖","note":"","ucode":"8CFE41BEEB5EF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1861945,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/4nRUmVqj6g59wwDwPvNiafK5wRPJY9YB6GUKFXV6qdicIVtjvlricF0dbpvFmV8TyNsw9ciak5LLVbxDQBYl3UYILQ/132","nickname":"HCY","note":"","ucode":"D779EDF89EE6B5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278579,"discussion_content":"对于文件来说，他们的定位符应该是磁盘地址。操作系统的垃圾桶删除，并不会改变磁盘地址，所以可以称之为物理地址没有发生变化","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591197848,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":223604,"ip_address":""},"score":278579,"extra":""}]},{"author":{"id":1132312,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/18/293cd24d.jpg","nickname":"o0oi1i","note":"","ucode":"D1F6AD4AAEAFBE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":233622,"discussion_content":"神比喻，顿时茅塞顿开！","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1586935074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1007000,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/98/98fe8de3.jpg","nickname":"zcqshine","note":"","ucode":"9DABA78369344E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3902,"discussion_content":"垃圾扔的快慢决定了暂停的时间","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1564965812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1974867,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/22/53/9184ae28.jpg","nickname":"盲人骑瞎马","note":"","ucode":"9C07B77A069656","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263648,"discussion_content":"豁然开朗！","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1589237986,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1103353,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d5/f9/1f9a2c3c.jpg","nickname":"磨砖做镜","note":"","ucode":"D8B8196AE1ED98","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275971,"discussion_content":"标记，整理","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1590796978,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304876,"discussion_content":"这么理解，只能说是 对 jvm 垃圾收集出现cms之前的一个解释，后续的并行收集，包含G1已经做了更细化的处理","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1599704565,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1475167,"avatar":"https://static001.geekbang.org/account/avatar/00/16/82/5f/8c6ae297.jpg","nickname":"一只半","note":"","ucode":"9E3F1FF369D82C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389280,"discussion_content":"每家的垃圾桶和小区垃圾桶的区别？小区有多个垃圾桶并行收集","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629201961,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":304876,"ip_address":""},"score":389280,"extra":""}]},{"author":{"id":1352726,"avatar":"https://static001.geekbang.org/account/avatar/00/14/a4/16/6463e374.jpg","nickname":"jack","note":"","ucode":"5260F7D2219542","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260617,"discussion_content":"手动点赞","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1588867875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1042644,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e8/d4/a0c2569d.jpg","nickname":"骑白马的菜鸟","note":"","ucode":"6BD69C742B3AE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":403561,"discussion_content":"真是高手，果然编程思想也是来自生活呀","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1634108374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2529532,"avatar":"https://static001.geekbang.org/account/avatar/00/26/98/fc/df6a9ed7.jpg","nickname":"ZzzL","note":"","ucode":"01B09ACD8BEF4E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382898,"discussion_content":"棒","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1625759951,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1101926,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d0/66/2323121c.jpg","nickname":"凡夫俗子","note":"","ucode":"3B96CA4A816051","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369526,"discussion_content":"拆迁是不是更好理解一些","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1619066037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2549659,"avatar":"https://static001.geekbang.org/account/avatar/00/26/e7/9b/a7980371.jpg","nickname":"chris","note":"","ucode":"E1F3CB9A4E13A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368828,"discussion_content":"深有同感","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1618840739,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2067660,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/8c/cc/f11a17d1.jpg","nickname":"Simon_real","note":"","ucode":"C84A03DCEA885A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366108,"discussion_content":"但是垃圾桶的目的其实跟这个不太一样，垃圾桶的目的其实是“后悔药”，并不是因为你删除文件太过频繁导致系统性能下降。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1617960691,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2198755,"avatar":"https://static001.geekbang.org/account/avatar/00/21/8c/e3/b9e926f9.jpg","nickname":"面罩","note":"","ucode":"E85F2550D7C6D6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2067660,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/8c/cc/f11a17d1.jpg","nickname":"Simon_real","note":"","ucode":"C84A03DCEA885A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388242,"discussion_content":"他说得没错呀。打个比方，如果没有垃圾桶，每次丢垃圾就得去楼下，多麻烦呀，先标记在垃圾桶里，满了再扔到楼下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628665582,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":366108,"ip_address":""},"score":388242,"extra":""}]},{"author":{"id":1103353,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d5/f9/1f9a2c3c.jpg","nickname":"磨砖做镜","note":"","ucode":"D8B8196AE1ED98","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275970,"discussion_content":"666","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590796914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1037940,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d6/74/6f04af6f.jpg","nickname":"鸿溟","note":"","ucode":"C8FC4C3DB6161E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57240,"discussion_content":"厉害厉害","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574585144,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1728997,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLvnDicRPf9kDIo0Mkaj6DTQSt4mWVbXwIqorvV7ln1XADia07GfNeSN6ZIdlOkI6mibS77vaEicuA4Ew/132","nickname":"Geek_3adef8","note":"","ucode":"EA7E0ED8E41DAC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55936,"discussion_content":"这是高手\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574414462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1419246,"avatar":"https://static001.geekbang.org/account/avatar/00/15/a7/ee/7ecb0ba2.jpg","nickname":"lambertylin","note":"","ucode":"ED1B0A004641BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7272,"discussion_content":"你这个比喻太好了！谢谢你！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567460255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2973403,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/5e/db/fd751769.jpg","nickname":"繁华落尽","note":"","ucode":"95299159D2947B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590954,"discussion_content":"666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666187067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1605058,"avatar":"https://static001.geekbang.org/account/avatar/00/18/7d/c2/e6332a1b.jpg","nickname":"东方拓睿","note":"","ucode":"1FD25D75CAC7C1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576021,"discussion_content":"比喻不够形象，因为垃圾桶丢进去去确实是标记了，但是是移动了连续在一起了，垃圾桶应该是标记整理算法了，因为把垃圾都移到一块了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655248088,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1009140,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/65/f4/bb81f857.jpg","nickname":"水户洋平","note":"","ucode":"806545270EB6C0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413346,"discussion_content":"what a clever boy!","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636452748,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1530594,"avatar":"https://static001.geekbang.org/account/avatar/00/17/5a/e2/698ec825.jpg","nickname":"wpl","note":"","ucode":"2E6E91BC0DD43E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386641,"discussion_content":"说的很好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627704859,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2654925,"avatar":"","nickname":"笙箫","note":"","ucode":"FC8AD39BD862E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379315,"discussion_content":"很深动","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623826720,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2397463,"avatar":"https://static001.geekbang.org/account/avatar/00/24/95/17/bfc95ae8.jpg","nickname":"geek","note":"","ucode":"ECB46425B33577","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371471,"discussion_content":"优秀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619781812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2541815,"avatar":"https://static001.geekbang.org/account/avatar/00/26/c8/f7/29b431cb.jpg","nickname":"🇧 🇪 🇦 🇷","note":"","ucode":"DFBCE2D953BF77","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362991,"discussion_content":"比喻非常恰当，点赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617086643,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1081205,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7f/75/551c5d6c.jpg","nickname":"CrazyCodes","note":"","ucode":"C9C0E72522EB5B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358427,"discussion_content":"说得好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615981082,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1147979,"avatar":"https://static001.geekbang.org/account/avatar/00/11/84/4b/e4738ba8.jpg","nickname":"delete is create","note":"","ucode":"A8C751219A7746","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287067,"discussion_content":"太懒了吧哈哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593356613,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1658912,"avatar":"https://static001.geekbang.org/account/avatar/00/19/50/20/1c7b039d.jpg","nickname":"彬彬","note":"","ucode":"81A72B9B00FAD3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55700,"discussion_content":"太赞了! 喜欢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574390393,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1747059,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/a8/73/3987ce84.jpg","nickname":"永岁飘零","note":"","ucode":"362D2B3B448C0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52236,"discussion_content":"太形象了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574006818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1731006,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLAvtsZsukLwnV3Nru8IiciaB2Wz8ejqicMYFibpnKfZXrXot0FMsFsP6JJdsOt8M4EAH5UTb7VX1GG9g/132","nickname":"yuajuan","note":"","ucode":"B451AAD2B8ADAB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49652,"discussion_content":"哇，这个比喻非常形象！赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573618242,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1687442,"avatar":"https://static001.geekbang.org/account/avatar/00/19/bf/92/d3e9eba5.jpg","nickname":"蓝夜星辉","note":"","ucode":"444633E371C3F6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40280,"discussion_content":"说得太对了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572148545,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1555732,"avatar":"https://static001.geekbang.org/account/avatar/00/17/bd/14/29e8cb77.jpg","nickname":"网名还没想好","note":"","ucode":"533BC9CF0A1BB7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40191,"discussion_content":"服气服气","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572101188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1677264,"avatar":"https://static001.geekbang.org/account/avatar/00/19/97/d0/cbc243d7.jpg","nickname":"枫叶水林","note":"","ucode":"BDB45925FD4616","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":39197,"discussion_content":"666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571902476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1291529,"avatar":"https://static001.geekbang.org/account/avatar/00/13/b5/09/874f7275.jpg","nickname":"G~旖旎中子","note":"","ucode":"9E15D7CF3AC78D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":33647,"discussion_content":"这个精辟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571139242,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1647345,"avatar":"https://static001.geekbang.org/account/avatar/00/19/22/f1/11d1f383.jpg","nickname":"疯情","note":"","ucode":"785237367A9B33","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":29256,"discussion_content":"厉害厉害厉害","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570757539,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29357,"user_name":"不诉离殇","can_delete":false,"product_type":"c1","uid":1239350,"ip_address":"","ucode":"4F7BB1220ECED7","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/36/f62471c5.jpg","comment_is_top":false,"comment_ctime":1538357709,"is_pvip":false,"replies":[{"id":"10630","content":"高手！","user_name":"作者回复","comment_id":29357,"uid":"1190123","ip_address":"","utype":1,"ctime":1538407533,"user_name_real":"gg"}],"discussion_count":22,"race_medal":0,"score":"2995130563021","product_id":100017301,"comment_content":"例子中死循环的问题跟编译器分配内存和字节对齐有关 数组3个元素 加上一个变量a 。4个整数刚好能满足8字节对齐 所以i的地址恰好跟着a2后面 导致死循环。。如果数组本身有4个元素  则这里不会出现死循环。。因为编译器64位操作系统下 默认会进行8字节对齐 变量i的地址就不紧跟着数组后面了。","like_count":697,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425562,"discussion_content":"高手！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538407533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1245456,"avatar":"https://static001.geekbang.org/account/avatar/00/13/01/10/5d188111.jpg","nickname":"Bomb","note":"","ucode":"C1A346D48EA215","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":253323,"discussion_content":"用dev测试了。其实不管把数组位数设置成多少都会无限循环吧。只要把i设置成double型就不会这样了，因为浮点数的存放格式跟整型还是不一样的，所以后两字节即使全部置0也不会影响i的值。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1588226087,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1934969,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/86/79/066a062a.jpg","nickname":"非同凡想","note":"","ucode":"713FD449A49D5A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":232560,"discussion_content":"《深入理解计算机系统》书中讲得很清楚","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1586872492,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1514292,"avatar":"https://static001.geekbang.org/account/avatar/00/17/1b/34/4d8c5694.jpg","nickname":"Movan","note":"","ucode":"D5A2E9E2E7A439","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":230435,"discussion_content":"一直不明白学计算机组成原理有啥用，这个专栏的评论一直让我开眼界，感谢","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1586744855,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1914742,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/37/76/6c85bc5a.jpg","nickname":"水到渠成","note":"","ucode":"6767FC5108226E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":242071,"discussion_content":"果然改成7也会出现死循环!","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1587463761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1445106,"avatar":"https://static001.geekbang.org/account/avatar/00/16/0c/f2/eff644f9.jpg","nickname":"Geek_f04d81","note":"","ucode":"ECD9F1BE0B2186","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300794,"discussion_content":"和这个关系不大吧 ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598265299,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1581208,"avatar":"https://static001.geekbang.org/account/avatar/00/18/20/98/806cecdc.jpg","nickname":"如願","note":"","ucode":"538F04D108C27A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7711,"discussion_content":"那如果是64位系统的话，将数组设置为七个元素也一样会死循环了吧？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567649134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1103353,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d5/f9/1f9a2c3c.jpg","nickname":"磨砖做镜","note":"","ucode":"D8B8196AE1ED98","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1581208,"avatar":"https://static001.geekbang.org/account/avatar/00/18/20/98/806cecdc.jpg","nickname":"如願","note":"","ucode":"538F04D108C27A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275973,"discussion_content":"前面评论有人证明了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590797336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7711,"ip_address":""},"score":275973,"extra":""}]},{"author":{"id":1207038,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6a/fe/7566542f.jpg","nickname":"布衣","note":"","ucode":"BFAD9049508330","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":662,"discussion_content":"估计GCC编译器会是按照扎样的规则,但是我用的是苹果公司的LLVM直接崩溃了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1561900861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1258401,"avatar":"https://static001.geekbang.org/account/avatar/00/13/33/a1/f3835f01.jpg","nickname":"社会猪","note":"","ucode":"CFF5EA7F247373","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1207038,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6a/fe/7566542f.jpg","nickname":"布衣","note":"","ucode":"BFAD9049508330","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7220,"discussion_content":"可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567422978,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":662,"ip_address":""},"score":7220,"extra":""}]},{"author":{"id":1446976,"avatar":"https://static001.geekbang.org/account/avatar/00/16/14/40/2fb15a61.jpg","nickname":"七里香","note":"","ucode":"16A3957A14AA26","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309182,"discussion_content":"不明觉厉  ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601207919,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1990297,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/5e/99/d5488c67.jpg","nickname":"小马过河","note":"","ucode":"CB8AD608237361","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":279784,"discussion_content":"这个有点意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591415515,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1916654,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/3e/ee/82c2ef12.jpg","nickname":"是海港呀","note":"","ucode":"32AD09DB7B1F3B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212785,"discussion_content":"请教，字节对齐是啥意思。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585015359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1803259,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/83/fb/621adceb.jpg","nickname":"linker","note":"","ucode":"6C5799F2FC2C82","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":155179,"discussion_content":"意思是如果数组与i的类型不是int,而是char，就不会出现问题？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580219658,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1153978,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9b/ba/333b59e5.jpg","nickname":"Linuxer","note":"","ucode":"272D9D8089C3D6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":63677,"discussion_content":"是不是更确切的说是因为栈的空间分配是从高地址到低地址，才导致了a[3]正好是i的位置","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574902571,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1683130,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","nickname":"乾坤瞬间","note":"","ucode":"15BDCF29CBF8EB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":29197,"discussion_content":"有个问题，为什么i的地址会在arr地址之后，在代码中i地址是先于arr定义的，i地址应该小于art地址。不过调换声明次序，仍然会出现死循环","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570754450,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":6,"child_discussions":[{"author":{"id":1066430,"avatar":"https://static001.geekbang.org/account/avatar/00/10/45/be/c04a40ce.jpg","nickname":"3W1H","note":"","ucode":"F6B4864128103C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1683130,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","nickname":"乾坤瞬间","note":"","ucode":"15BDCF29CBF8EB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40504,"discussion_content":"同样的疑问 求解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572226022,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":29197,"ip_address":""},"score":40504,"extra":""},{"author":{"id":1072460,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5d/4c/5189c8a8.jpg","nickname":"维x","note":"","ucode":"F426777EE86E24","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1683130,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","nickname":"乾坤瞬间","note":"","ucode":"15BDCF29CBF8EB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50760,"discussion_content":"就是因为编译器按内存地址递减的方式为局部变量分配内存，高地址会分配给先声明的变量，低地址分配给后声明的变量。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1573749236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":29197,"ip_address":""},"score":50760,"extra":""},{"author":{"id":1208981,"avatar":"https://static001.geekbang.org/account/avatar/00/12/72/95/5f83598c.jpg","nickname":"Hello World","note":"","ucode":"368D87D53DC58F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1683130,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","nickname":"乾坤瞬间","note":"","ucode":"15BDCF29CBF8EB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":166056,"discussion_content":"可以百度搜索“大端小端”；intel 使用的小端模式，数据字节的高低位与内存地址的高低位一致。栈中数据存放是由高地址到地地址，所以 压栈顺序为 i ->a[2]->a[1]->a[0]，出栈顺序相反，a[3]取到的值为i。","likes_number":17,"is_delete":false,"is_hidden":false,"ctime":1581347263,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":29197,"ip_address":""},"score":166056,"extra":""}]}]},{"had_liked":false,"id":29854,"user_name":"zyzheng","can_delete":false,"product_type":"c1","uid":1042716,"ip_address":"","ucode":"E44F327230319E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e9/1c/be4ac7af.jpg","comment_is_top":false,"comment_ctime":1538562922,"is_pvip":false,"replies":[{"id":"10715","content":"就喜欢你这种自己动手研究的同学","user_name":"作者回复","comment_id":29854,"uid":"1190123","ip_address":"","utype":1,"ctime":1538581223,"user_name_real":"gg"}],"discussion_count":24,"race_medal":0,"score":"1929978878826","product_id":100017301,"comment_content":"关于数组越界访问导致死循环的问题，我也动手实践了一下，发现结果和编译器的实现有关，gcc有一个编译选项（-fno-stack-protector）用于关闭堆栈保护功能。默认情况下启动了堆栈保护，不管i声明在前还是在后，i都会在数组之后压栈，只会循环4次；如果关闭堆栈保护功能，则会出现死循环。请参考：https:&#47;&#47;www.ibm.com&#47;developerworks&#47;cn&#47;linux&#47;l-cn-gccstack&#47;index.html","like_count":450,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425740,"discussion_content":"就喜欢你这种自己动手研究的同学","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538581223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1072460,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5d/4c/5189c8a8.jpg","nickname":"维x","note":"","ucode":"F426777EE86E24","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50762,"discussion_content":"这是高手，我也看到了这篇文章，重要的是当加了堆栈保护的编译选项后编译器会调整变量分配地址的顺序，不是原来的按地址递减的方式分配内存的，而是相反，这样就能从一定成都上防止堆栈溢出。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1573749460,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1615539,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI6LXcIqb5K48nia8d4zmdsD1M9AZeyXoGrLzX5xvqfN0fqXOsYKUWLbZvZ8TtJCXWmYbCkCXg93dQ/132","nickname":"漏脚脖","note":"","ucode":"214AE52EC201E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3026,"discussion_content":"读了评论真是受益匪浅，全是大神","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1564120251,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1461770,"avatar":"https://static001.geekbang.org/account/avatar/00/16/4e/0a/0ff15eaa.jpg","nickname":"pencilCool","note":"","ucode":"49A9FE2DEE2911","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":131219,"discussion_content":"学习果然要在社区中学习，因为会有意想不到的收获","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1578833169,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1482839,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a0/57/3a729755.jpg","nickname":"灯盖","note":"","ucode":"0F8455A593D60C","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311106,"discussion_content":"牛","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602222515,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1081615,"avatar":"https://static001.geekbang.org/account/avatar/00/10/81/0f/e8dc7528.jpg","nickname":"星野结衣","note":"","ucode":"BFEB2822B83563","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":222500,"discussion_content":"的确 自己试了下","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586150001,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1374282,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f8/4a/d5401843.jpg","nickname":"圈子不同，别硬融","note":"","ucode":"110349C0A4264E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":114131,"discussion_content":"为啥我用js实现了一下，并没有出现无限循环的情况呢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577959300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1208981,"avatar":"https://static001.geekbang.org/account/avatar/00/12/72/95/5f83598c.jpg","nickname":"Hello World","note":"","ucode":"368D87D53DC58F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1374282,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f8/4a/d5401843.jpg","nickname":"圈子不同，别硬融","note":"","ucode":"110349C0A4264E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":166074,"discussion_content":"高级语言是有越界检查的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1581347544,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":114131,"ip_address":""},"score":166074,"extra":""},{"author":{"id":1367048,"avatar":"https://static001.geekbang.org/account/avatar/00/14/dc/08/64f5ab52.jpg","nickname":"陈斌","note":"","ucode":"B639AB5F6AA03D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1374282,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f8/4a/d5401843.jpg","nickname":"圈子不同，别硬融","note":"","ucode":"110349C0A4264E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290463,"discussion_content":"尴尬啵，兄弟！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594480611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":114131,"ip_address":""},"score":290463,"extra":""}]},{"author":{"id":2699316,"avatar":"https://static001.geekbang.org/account/avatar/00/29/30/34/2c487821.jpg","nickname":"HashWky","note":"","ucode":"3F95646EA9725A","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584378,"discussion_content":"大佬大佬，的确如此","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660793923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"湖北"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2445592,"avatar":"https://static001.geekbang.org/account/avatar/00/25/51/18/f8cd5294.jpg","nickname":"邱锋","note":"","ucode":"0AA3C11B7EEF2C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":406388,"discussion_content":"地址不管是递增还是递减，编译器改成1字节对齐就解决了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634744251,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1678620,"avatar":"https://static001.geekbang.org/account/avatar/00/19/9d/1c/8d8510dd.jpg","nickname":"来自非洲的锦鲤","note":"","ucode":"FEBCB34A7A06CD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381192,"discussion_content":"是真的优秀，又学到了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624949818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1339586,"avatar":"https://static001.geekbang.org/account/avatar/00/14/70/c2/0df5cc71.jpg","nickname":"Melon","note":"","ucode":"8E4A96B3BA0239","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368673,"discussion_content":"验证了没加编译选项不行，加了之后确实无限循环打印\n-fno-stack-protector, -fno-stack-protector-strong\nNo stack overflow security checks are enabled for the relevant routines.\nhttps://scc.ustc.edu.cn/zlsc/tc4600/intel/2017.0.098/compiler_f/common/core/GUID-E00CA6E2-F510-4BA1-84C3-0800039F5890.html","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618799096,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2100644,"avatar":"","nickname":"Geek_8e2759","note":"","ucode":"EBDBA4D92B5C50","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326335,"discussion_content":"-fstack-protector：启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码。\n\n-fstack-protector-all：启用堆栈保护，为所有函数插入保护代码。\n\n-fno-stack-protector：禁用堆栈保护。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605580693,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1013855,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/78/5f/32bc9975.jpg","nickname":"陈祥龙","note":"","ucode":"6B0C331EE415F5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":323437,"discussion_content":"牛，在xcode 里验证了一下，确实是这样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604935489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1397631,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKVUskibDnhMt5MCIJ8227HWkeg2wEEyewps8GuWhWaY5fy7Ya56bu2ktMlxdla3K29Wqia9efCkWaQ/132","nickname":"衬衫的价格是19美元","note":"","ucode":"655F925451F772","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307726,"discussion_content":"clang-1001.0.46.4下加上-fno-stack-protector会打印四次然后退出，不会报错，不加-fno-stack-protector也会打印四次，然后报Abort trap: 6","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600742968,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2188952,"avatar":"https://static001.geekbang.org/account/avatar/00/21/66/98/f90f0e73.jpg","nickname":"江源","note":"","ucode":"CC275673F2D0FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307346,"discussion_content":"强大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600607893,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1984068,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKDCEibaYsiaaLHH440T8ibzvR0ibqeNuNpmm7qE2iaehpL7AU0QQ4EvHtC0UC0zuB0qIuIRYEibyUrZ8lQ/132","nickname":"Fozei","note":"","ucode":"C9004B1FED8749","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":258049,"discussion_content":"楼主正解，gcc9.3.0，默认会报错*** stack smashing detected ***: terminated程序结束，不会死循环，加上编译参数-fno-stack-protector后，死循环。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588642683,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1194060,"avatar":"https://static001.geekbang.org/account/avatar/00/12/38/4c/5426e2e0.jpg","nickname":"CJJ","note":"","ucode":"7E02A6A8547559","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":233991,"discussion_content":"大神","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586954467,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1634044,"avatar":"https://static001.geekbang.org/account/avatar/00/18/ee/fc/8717c26b.jpg","nickname":"柠檬","note":"","ucode":"AF73A8B705CE76","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":63275,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574868896,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1021556,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/96/74/ef636095.jpg","nickname":"Dom","note":"","ucode":"A036B0D88A4D6E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":43464,"discussion_content":"确实是这样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572876042,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1621658,"avatar":"https://static001.geekbang.org/account/avatar/00/18/be/9a/b0b89be3.jpg","nickname":"不动声色满心澎湃","note":"","ucode":"80D8F9E49AF7C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5908,"discussion_content":"这是高手","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566532324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1616165,"avatar":"https://static001.geekbang.org/account/avatar/00/18/a9/25/bd36028f.jpg","nickname":"echorez","note":"","ucode":"AFA6CD5F3634BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4492,"discussion_content":"我也尝试过，确实是这样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565489666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1079417,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/79/8f5c0fc3.jpg","nickname":"Terry·LI","note":"","ucode":"2516FBCCE33236","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4371,"discussion_content":"不错，我也发现这个问题了，果然评论区都是大神","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565339627,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29317,"user_name":"Nirvanaliu","can_delete":false,"product_type":"c1","uid":1255092,"ip_address":"","ucode":"A2576845D5A18E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELVTictrUd4I3icvCtoibG2WibaiaILSxj0TAXvk27evBR6nfnYuEqIfmfW6pRl42IibcZyiaoqrXqDnzymw/132","comment_is_top":false,"comment_ctime":1538352318,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"1564906448062","product_id":100017301,"comment_content":"文章结构：<br>数组看起来简单基础，但是很多人没有理解这个数据结构的精髓。带着为什么数组要从0开始编号，而不是从1开始的问题，进入主题。<br>1.\t数组如何实现随机访问<br>1）\t数组是一种线性数据结构，用连续的存储空间存储相同类型数据<br>I）\t线性表：数组、链表、队列、栈 非线性表：树 图<br>II）\t连续的内存空间、相同的数据，所以数组可以随机访问，但对数组进行删除插入，为了保证数组的连续性，就要做大量的数据搬移工作<br>a)\t数组如何实现下标随机访问。<br>引入数组再内存种的分配图，得出寻址公式<br>b)\t纠正数组和链表的错误认识。数组的查找操作时间复杂度并不是O(1)。即便是排好的数组，用二分查找，时间复杂度也是O（logn）。<br>正确表述：数组支持随机访问，根据下标随机访问的时间复杂度为O（1）<br>2.\t低效的插入和删除<br>1）\t插入：从最好O(1) 最坏O(n) 平均O(n)<br>2）\t插入：数组若无序，插入新的元素时，可以将第K个位置元素移动到数组末尾，把心的元素，插入到第k个位置，此处复杂度为O(1)。作者举例说明<br>3）\t删除：从最好O(1) 最坏O(n) 平均O(n)<br>4）\t多次删除集中在一起，提高删除效率<br>记录下已经被删除的数据，每次的删除操作并不是搬移数据，只是记录数据已经被删除，当数组没有更多的存储空间时，再触发一次真正的删除操作。即JVM标记清除垃圾回收算法。<br>3.\t警惕数组的访问越界问题<br>用C语言循环越界访问的例子说明访问越界的bug。此例在《C陷阱与缺陷》出现过，很惭愧，看过但是现在也只有一丢丢印象。翻了下书，替作者加上一句话：如果用来编译这段程序的编译器按照内存地址递减的方式给变量分配内存，那么内存中的i将会被置为0，则为死循环永远出不去。<br>4.\t容器能否完全替代数组<br>相比于数字，java中的ArrayList封装了数组的很多操作，并支持动态扩容。一旦超过村塾容量，扩容时比较耗内存，因为涉及到内存申请和数据搬移。<br>数组适合的场景：<br>1）\tJava ArrayList 的使用涉及装箱拆箱，有一定的性能损耗，如果特别管柱性能，可以考虑数组<br>2）\t若数据大小事先已知，并且涉及的数据操作非常简单，可以使用数组<br>3）\t表示多维数组时，数组往往更加直观。<br>4）\t业务开发容器即可，底层开发，如网络框架，性能优化。选择数组。<br>5.\t解答开篇问题<br>1）\t从偏移角度理解a[0] 0为偏移量，如果从1计数，会多出K-1。增加cpu负担。为什么循环要写成for(int i = 0;i&lt;3;i++) 而不是for(int i = 0 ;i&lt;=2;i++)。第一个直接就可以算出3-0 = 3 有三个数据，而后者 2-0+1个数据，多出1个加法运算，很恼火。<br>2）\t也有一定的历史原因<br>","like_count":364,"discussions":[{"author":{"id":1049017,"avatar":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","nickname":"学习学个屁","note":"","ucode":"DF2D61E6FB2FCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":126050,"discussion_content":" 很恼火  你为什么这么牛逼","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1578496603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2189145,"avatar":"https://static001.geekbang.org/account/avatar/00/21/67/59/10c28baa.jpg","nickname":"画中·话","note":"","ucode":"ADD63227318056","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306956,"discussion_content":"课代表","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1600430633,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2045997,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/38/2d/f3c6493e.jpg","nickname":"罗樱罂","note":"","ucode":"9072E79E625ED1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286781,"discussion_content":"谢谢课代表","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1593279948,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1457246,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLVZRHorm7z67yJxOCpYWJESPfhia00RDg4oicvPuyCwTKln2BFRMiahOKz9z22RnnEmickA64bHdB7pA/132","nickname":"土豆小小","note":"","ucode":"5621EEDE50EA48","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":203879,"discussion_content":"课代表？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584095330,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1622071,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c0/37/3e4ac0d9.jpg","nickname":"兴趣使然","note":"","ucode":"8219E197DF64ED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288280,"discussion_content":"这就是课代表吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593700346,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1284857,"avatar":"https://static001.geekbang.org/account/avatar/00/13/9a/f9/6d55ee0b.jpg","nickname":"Tiger","note":"","ucode":"6F9CAB3C29BAD7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60725,"discussion_content":"总结的相当到位！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574749304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1593762,"avatar":"https://static001.geekbang.org/account/avatar/00/18/51/a2/84e9efe2.jpg","nickname":"马祖晖","note":"","ucode":"7866916C8EF9DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51462,"discussion_content":"很恼火 哈哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573877257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1311995,"avatar":"https://static001.geekbang.org/account/avatar/00/14/04/fb/40f298bb.jpg","nickname":"小罗希冀","note":"","ucode":"88416458FF0041","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3644,"discussion_content":"为何这么牛逼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564656032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29303,"user_name":"Rain","can_delete":false,"product_type":"c1","uid":1238221,"ip_address":"","ucode":"6A270D922A3B9D","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","comment_is_top":false,"comment_ctime":1538346056,"is_pvip":false,"discussion_count":16,"race_medal":0,"score":"783222393928","product_id":100017301,"comment_content":"根据我们前面讲的数组寻址公式，a[3] 也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。<br><br>*而这个地址正好是存储变量 i 的内存地址*这个地方没看太懂，为什么正好就是i的内存地址呢？<br><br>谢谢老师。","like_count":182,"discussions":[{"author":{"id":1758307,"avatar":"","nickname":"韩方兴","note":"","ucode":"3C02DC65F3BB83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214531,"discussion_content":"a[3]的地址此时是变量 i 的地址，所以将 a[3] 修改为 0，也就是将 i 值由 3 重新修改为 0 了，0 <= 3， 所以又继续循环了 ","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1585203674,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181473,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/21/b3394aa2.jpg","nickname":"Robot","note":"","ucode":"7215462D5AC0FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":233431,"discussion_content":"此处说的是，a[3]跟i指向了同一块地址空间，修改a[3]的值，i的值自然也就变了","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1586925036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1779257,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKfLxAj43sGzJTnmdh8iawoNJ1VsdFvJHTHccxkX7HhtOFtTV9icG3B2Gt5EztPOicsicc3xG0XTlyUVg/132","nickname":"luoyayun361","note":"","ucode":"D3AD83D44EE721","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211749,"discussion_content":"此时的i不是应该等于3吗？为什么是0，看了评论还是没明白","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584885949,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":7,"child_discussions":[{"author":{"id":1161921,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIp92icEY6lvLEJlW6dh56yUEH3tskuMnoWtIvoglRdTSFfkePAf8D9hHoJAfWwYBzu4oOxYh4Bdrg/132","nickname":"根号三百万","note":"","ucode":"36FAE84D645C5A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1779257,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKfLxAj43sGzJTnmdh8iawoNJ1VsdFvJHTHccxkX7HhtOFtTV9icG3B2Gt5EztPOicsicc3xG0XTlyUVg/132","nickname":"luoyayun361","note":"","ucode":"D3AD83D44EE721","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":240526,"discussion_content":"假设变量 i 的储存地址是 123456，a[3] 已经不属于数组 a 了，此时 a[3] 的地址也是 123456, a[3]=0 也就是说把地址为 123456 的这块内存设置为了0，i 也是这块内存，自然i的值也是0。变量名称和地址的关系要搞清楚（理解c里面的指针概念）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587371594,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":211749,"ip_address":""},"score":240526,"extra":""},{"author":{"id":1966046,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erltcsXwF11h9mfqMOjUicwg8jUmMwYsRLfKF88fKNTxZsCE9n0wUbaw0xt9p5Qicibiap9U2liaY0iaXXQ/132","nickname":"MrGao","note":"","ucode":"C1F2E18B715C3B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1161921,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIp92icEY6lvLEJlW6dh56yUEH3tskuMnoWtIvoglRdTSFfkePAf8D9hHoJAfWwYBzu4oOxYh4Bdrg/132","nickname":"根号三百万","note":"","ucode":"36FAE84D645C5A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261776,"discussion_content":"那为啥a[3]与i指向了同一个地址","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589004636,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":240526,"ip_address":""},"score":261776,"extra":""},{"author":{"id":1103353,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d5/f9/1f9a2c3c.jpg","nickname":"磨砖做镜","note":"","ucode":"D8B8196AE1ED98","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1966046,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erltcsXwF11h9mfqMOjUicwg8jUmMwYsRLfKF88fKNTxZsCE9n0wUbaw0xt9p5Qicibiap9U2liaY0iaXXQ/132","nickname":"MrGao","note":"","ucode":"C1F2E18B715C3B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275975,"discussion_content":"栈地址分配方向从高到低，变量定义地址从大到小，数组求址从小到大，越界后到达了当前栈顶地址，栈顶是变量i","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1590797792,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":261776,"ip_address":""},"score":275975,"extra":""}]},{"author":{"id":1245871,"avatar":"https://static001.geekbang.org/account/avatar/00/13/02/af/c46ef3c3.jpg","nickname":"李姗姗","note":"","ucode":"F3A0CF544D551C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553609,"discussion_content":"跟编译器分配内存和字节对齐有关。数组3个元素，加上变量arr，4个整数正好满足8字节对齐，所以i的地址恰好跟在arr[2]后面，导致arr[3]的地址跟i一样。。如果数组本身有4个元素，则不会出现死循环。。因为编译器64位操作系统下，默认会进行8字节对齐，变量的地址就不会紧跟在数组后面了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645977585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2034259,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/0a/53/5264f9ce.jpg","nickname":"💪Lane","note":"","ucode":"30FB0DDB9B824C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374412,"discussion_content":"调用栈的原因","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621170824,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2431838,"avatar":"https://static001.geekbang.org/account/avatar/00/25/1b/5e/34da927f.jpg","nickname":"药师琉璃光王佛","note":"","ucode":"65F0316F7968D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350431,"discussion_content":"也就是说，虽然代码先声明了变量i，再声明变量arr ，但是编译器是先分配给占内存大的变量，即先给arr分配地址空间，接着给i分配地址空间，所以arr[3]的地址就是变量i的地址。这样理解对吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613873421,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1197986,"avatar":"https://static001.geekbang.org/account/avatar/00/12/47/a2/c307b03e.jpg","nickname":"Yum","note":"","ucode":"DE0C86067EF6D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6525,"discussion_content":"我也是  i  为什么会等于0不理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566956496,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1044785,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f1/31/5001390b.jpg","nickname":"Lonely绿豆蛙","note":"","ucode":"0862179B614974","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1197986,"avatar":"https://static001.geekbang.org/account/avatar/00/12/47/a2/c307b03e.jpg","nickname":"Yum","note":"","ucode":"DE0C86067EF6D2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":36939,"discussion_content":"前面的几个高赞回答解释地很好呢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1571466624,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":6525,"ip_address":""},"score":36939,"extra":""},{"author":{"id":1103353,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d5/f9/1f9a2c3c.jpg","nickname":"磨砖做镜","note":"","ucode":"D8B8196AE1ED98","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1197986,"avatar":"https://static001.geekbang.org/account/avatar/00/12/47/a2/c307b03e.jpg","nickname":"Yum","note":"","ucode":"DE0C86067EF6D2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275976,"discussion_content":"一次遍历结束前的最后操作室a3数组赋值为0","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590797909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":6525,"ip_address":""},"score":275976,"extra":""}]}]},{"had_liked":false,"id":29481,"user_name":"Zzzzz","can_delete":false,"product_type":"c1","uid":1234821,"ip_address":"","ucode":"01CDDB17F905C1","user_header":"https://static001.geekbang.org/account/avatar/00/12/d7/85/f2d5997a.jpg","comment_is_top":false,"comment_ctime":1538390695,"is_pvip":false,"replies":[{"id":"10622","content":"👍","user_name":"作者回复","comment_id":29481,"uid":"1190123","ip_address":"","utype":1,"ctime":1538407146,"user_name_real":"gg"}],"discussion_count":13,"race_medal":0,"score":"744567732903","product_id":100017301,"comment_content":"对于死循环那个问题，要了解栈这个东西。栈是向下增长的，首先压栈的i，a[2]，a[1]，a[0]，这是我在我vc上调试查看汇编的时候看到的压栈顺序。相当于访问a[3]的时候，是在访问i变量，而此时i变量的地址是数组当前进程的，所以进行修改的时候，操作系统并不会终止进程。","like_count":173,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425633,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538407146,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":3078266,"avatar":"https://static001.geekbang.org/account/avatar/00/2e/f8/7a/b3b5e29e.jpg","nickname":"Li,Yanjie","note":"","ucode":"708A4982F272C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":584259,"discussion_content":"老师何不把这个加到讲义里？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660711229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":425633,"ip_address":"北京"},"score":584259,"extra":""}]},{"author":{"id":2664108,"avatar":"","nickname":"周孙宇","note":"","ucode":"12DD24F34FC140","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382446,"discussion_content":"前面几个都没看懂，这个秒懂🤙🤙🤙","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1625575453,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1194060,"avatar":"https://static001.geekbang.org/account/avatar/00/12/38/4c/5426e2e0.jpg","nickname":"CJJ","note":"","ucode":"7E02A6A8547559","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":234008,"discussion_content":"如果是这样的压栈顺序就懂了一点，但是我还是有个疑问，为什么压栈顺序是i，a[2]，a[1]，a[0]而不是i, a[0]，a[1]，a[2]呢？求大神指教😊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586955185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1944276,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/aa/d4/ee811d8f.jpg","nickname":"积极丰","note":"","ucode":"A43612E0B96D13","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1194060,"avatar":"https://static001.geekbang.org/account/avatar/00/12/38/4c/5426e2e0.jpg","nickname":"CJJ","note":"","ucode":"7E02A6A8547559","race_medal":1,"user_type":1,"is_pvip":true},"discussion":{"id":237718,"discussion_content":"我猜想是根据那个存储地址算法公式得来的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1587179732,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":234008,"ip_address":""},"score":237718,"extra":""},{"author":{"id":1194060,"avatar":"https://static001.geekbang.org/account/avatar/00/12/38/4c/5426e2e0.jpg","nickname":"CJJ","note":"","ucode":"7E02A6A8547559","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":1944276,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/aa/d4/ee811d8f.jpg","nickname":"积极丰","note":"","ucode":"A43612E0B96D13","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":240306,"discussion_content":"大佬啥公式呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587350588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":237718,"ip_address":""},"score":240306,"extra":""},{"author":{"id":2320398,"avatar":"","nickname":"Geek_6b6e5d","note":"","ucode":"26097F678719CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1194060,"avatar":"https://static001.geekbang.org/account/avatar/00/12/38/4c/5426e2e0.jpg","nickname":"CJJ","note":"","ucode":"7E02A6A8547559","race_medal":1,"user_type":1,"is_pvip":true},"discussion":{"id":353562,"discussion_content":"a[k]_address = base_address + k * type_size","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615173654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":240306,"ip_address":""},"score":353562,"extra":""}]},{"author":{"id":2250376,"avatar":"https://static001.geekbang.org/account/avatar/00/22/56/88/a131c24d.jpg","nickname":"xiao-lan🌻","note":"","ucode":"763B6D9327BE52","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":316707,"discussion_content":"压栈这个会根据变量声明顺序来存储吗？如果这样，i在arr后面声明，是否就不会死循环了？不过也会产生其它为止行为","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603443266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1943619,"avatar":"","nickname":"进击的小菜","note":"","ucode":"DEDC4D31DA0DF1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220500,"discussion_content":"我好像也懂了一点点👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585884997,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1201054,"avatar":"https://static001.geekbang.org/account/avatar/00/12/53/9e/e932c1a8.jpg","nickname":"jing","note":"","ucode":"C0186996EBD25A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":160337,"discussion_content":"看懂了，太赞了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580789941,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1737846,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/84/76/6091523d.jpg","nickname":"进击的小明","note":"","ucode":"7C9A774C504177","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":152982,"discussion_content":"我好像看懂了 😁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580011833,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1943619,"avatar":"","nickname":"进击的小菜","note":"","ucode":"DEDC4D31DA0DF1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1737846,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/84/76/6091523d.jpg","nickname":"进击的小明","note":"","ucode":"7C9A774C504177","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220501,"discussion_content":"看到了熟悉的名儿😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585885058,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":152982,"ip_address":""},"score":220501,"extra":""},{"author":{"id":1737846,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/84/76/6091523d.jpg","nickname":"进击的小明","note":"","ucode":"7C9A774C504177","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1943619,"avatar":"","nickname":"进击的小菜","note":"","ucode":"DEDC4D31DA0DF1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":225389,"discussion_content":"朋友你好","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586357176,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":220501,"ip_address":""},"score":225389,"extra":""}]}]},{"had_liked":false,"id":29561,"user_name":"何江","can_delete":false,"product_type":"c1","uid":1240042,"ip_address":"","ucode":"80B61A21CB591F","user_header":"https://static001.geekbang.org/account/avatar/00/12/eb/ea/4461196d.jpg","comment_is_top":false,"comment_ctime":1538442475,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"615718765803","product_id":100017301,"comment_content":"有个小问题，我觉得 随机访问Ramdom Acess 更应该翻译成 任意访问，更能表达数组的特性。不过国内书籍都是翻译成随机。新手朋友刚看到时会有一些理解问题，如数组怎么会是随机访问的呢(当初我就是这么想的)","like_count":143,"discussions":[{"author":{"id":1160050,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b3/72/8c6366aa.jpg","nickname":"烈鸟","note":"","ucode":"F568728E862D50","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":173099,"discussion_content":"是的，第一次听说随机访问，还以为程序为什么要给我随机访问，难道不要我指定么？哈哈","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1581829283,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1139583,"avatar":"https://static001.geekbang.org/account/avatar/00/11/63/7f/ebd1881e.jpg","nickname":"LarryLearnCode","note":"","ucode":"590783ED253372","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385938,"discussion_content":"朋友顶你，说出了我的心声。Random Acess你说的翻译方式更合理：数组通过下标访问其中任意元素/任意访问其中元素，“随机访问”是个什么鬼？一会儿访问a[1]，一会儿访问a[2]吗？国内翻译水平很烂，大部分都不是搞计算机专业的，这种东西拿出来很容易误人子弟","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1627355852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2066987,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/8a/2b/f2dca1fd.jpg","nickname":"有没有口罩一个给我","note":"","ucode":"EF9BCF9C5F5378","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348678,"discussion_content":"任意访问没办法表达出那个意思，任意访问听起来有点像：你可以访问任意一个数，但链表也可以访问任意一个数呢，就是Any Acess了。重点还是在于Random噢","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1612677175,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1640978,"avatar":"https://static001.geekbang.org/account/avatar/00/19/0a/12/f8b988b8.jpg","nickname":"Kyle(","note":"","ucode":"0C14C4C086CAA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2066987,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/8a/2b/f2dca1fd.jpg","nickname":"有没有口罩一个给我","note":"","ucode":"EF9BCF9C5F5378","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350907,"discussion_content":"你有offset了不能任意访问你想访问的数据嘛\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614070311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":348678,"ip_address":""},"score":350907,"extra":""}]},{"author":{"id":1926508,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/65/6c/be97a3ae.jpg","nickname":"Geek_bb2310","note":"","ucode":"022885B257DEB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":256595,"discussion_content":"哈哈\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588501680,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2415448,"avatar":"https://static001.geekbang.org/account/avatar/00/24/db/58/a7a0a85b.jpg","nickname":"二饼","note":"","ucode":"48120565D135F7","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572353,"discussion_content":"有道理。翻译成任意访问，更让人容易理解了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652717369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2813557,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/ee/75/de97ae21.jpg","nickname":"快乐学习","note":"","ucode":"30F4197863FB47","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568609,"discussion_content":"我也是搞蒙了，以为内存条呢哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651188909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92988,"user_name":"Neuject","can_delete":false,"product_type":"c1","uid":1346309,"ip_address":"","ucode":"4DCFF6CDC4186E","user_header":"https://static001.geekbang.org/account/avatar/00/14/8b/05/3315b855.jpg","comment_is_top":false,"comment_ctime":1557373145,"is_pvip":false,"discussion_count":13,"race_medal":0,"score":"512658481369","product_id":100017301,"comment_content":"花时间研究了一下多维数组的寻址公式，写完感觉豁然开朗：<br>      虽然我们可以把二维数组中成员看作行和列两个方向构成的格子中的数据，三维数组成员看作长宽高构成的立体格子中的数据，但这只是有助于理解的形象表示，实质上数组在内存中是连续线性的。<br>      那么对于二维数组 x[][](长度为a1*a2)来说，求x[i][j]的时候（不会考虑i j越界的情况），要到i的时候，一定走完了i*a2的长度，在x[i][0]往后找j个长度就是x[i][j]，所以会从初始地址增加 （i*a2+j）个单位长度。<br>      对于三维数组， x[][][](长度为a1*a2*a3)来说，求x[i][j][k]的时候，要到i的时候，一定走完了i*a2*a3的长度，在x[i][0][0]往后找j*a3个长度就是x[i][j][0]，再往后找k个长度就是x[i][j][k]，所以会从初始地址增加 （i*a2*a3+j*a3+k）个单位长度。以此类推如下：<br>     <br>数组 为x ,an为某一维度长度  <br>      一维数组：（a1）x[i]_address = base_address + i * type_size<br>      二维数组：（a1*a2）x[i][j]_address = base_address + ( i * a2 + j ) * type_size<br>      三位数组：（a1*a2*a3）x[i][j][k]_address = base_address + ( i * a2*a3 + j * a3 + k ) * type_size<br>      四位数组：（a1*a2*a3*a4）x[i][j][k][l]_address = base_address + ( i * a2*a3*a4 + j *a3*a4 + k *a4 + l ) * type_size<br>      。。。。。。<br>      n维数组：（a1*a2*a3*...an）x[i1][i2][i3]...[in] = base_address +  ( i1 * a2*a3*...*an + i2 * a3*a4*...*an + i3 * a4*a5*...*an +......i(n-1) * an + in) * type_size<br>","like_count":120,"discussions":[{"author":{"id":2653275,"avatar":"https://static001.geekbang.org/account/avatar/00/28/7c/5b/900521d9.jpg","nickname":"逆时针","note":"","ucode":"71CA48AD211CF3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384137,"discussion_content":"感谢，讲解的很清晰，其中type_size是最基本存储类型的长度，如整体，base_address + ( i * a2 + j ) * type_size 的a2表示二维数据的长度，i*a2表示的一维数据i的起始位置， +j 表示的就是二维数组的位置了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1626400985,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2058203,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/67/db/abc379e0.jpg","nickname":"L。","note":"","ucode":"17CFF742690560","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289520,"discussion_content":"看了你的才懂😂","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1594129322,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1159044,"avatar":"https://static001.geekbang.org/account/avatar/00/11/af/84/c65b43fb.jpg","nickname":"Ron","note":"","ucode":"EE78756918FA0A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361415,"discussion_content":"豁然开朗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1616666056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134618,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK0wXEfsGnCiarxEUEvZz45bFEpSaWL79eK5DfUUbrNwLv6I6WDkMnmhb2fZvm2MtmIoU2yhBz7iaew/132","nickname":"舍予","note":"","ucode":"F333699D14213A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326970,"discussion_content":"一目了然，容易懂。谢谢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605710166,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1334570,"avatar":"https://static001.geekbang.org/account/avatar/00/14/5d/2a/7e4350bf.jpg","nickname":"W℡","note":"","ucode":"343AB81883EE3C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285730,"discussion_content":"太棒了，看完你的解答才明白前面为什么 i*n+j 这里的n是哪里来的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1592922137,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1295609,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJRFRX8kNzNet7FibNvtavbVpAwK09AhIhrib9k762qWtH6mre8ickP7hM5mgZC4ytr8NnmIfmAhxMSQ/132","nickname":"老大不小","note":"","ucode":"35BCDD3CB13467","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579962,"discussion_content":"a1,a2看着费劲，建议下次直接用abc这种","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657784783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1968013,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/07/8d/3e76560f.jpg","nickname":"王建峰","note":"","ucode":"8BF1AEFFA7EA5F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348814,"discussion_content":"数组按列优先排布 是你这种方式进行存取的吧，如果数组内容按行排列不是这样的喔~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612743820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134735,"avatar":"https://static001.geekbang.org/account/avatar/00/11/50/8f/01e7ea90.jpg","nickname":"小孟会發財","note":"","ucode":"697E0660180751","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346830,"discussion_content":"大神，我想问一下 为什么到 i 的时候 一定是走完了 i*a2 的长度？ ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612075316,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2584721,"avatar":"https://static001.geekbang.org/account/avatar/00/27/70/91/e4729107.jpg","nickname":"山海观雾","note":"","ucode":"7EF8338024B5EE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1134735,"avatar":"https://static001.geekbang.org/account/avatar/00/11/50/8f/01e7ea90.jpg","nickname":"小孟会發財","note":"","ucode":"697E0660180751","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370462,"discussion_content":"换下一行 前面不就刚好是列数个元素*a_size","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619423930,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":346830,"ip_address":""},"score":370462,"extra":""}]},{"author":{"id":1195438,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3d/ae/daa07f0c.jpg","nickname":"无痕","note":"","ucode":"AE8546EEA7FD00","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338988,"discussion_content":"清晰","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609470453,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2060502,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo19qicyia7fD26H239vm5gHyvw6RLQMPyncNXCADE18mJnP1NGtrPsPgByZmnVpCOVVbeK9ibEM2Wcg/132","nickname":"楼灏亮","note":"","ucode":"6A2A898891577B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320922,"discussion_content":"解答的很棒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604503476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1511436,"avatar":"https://static001.geekbang.org/account/avatar/00/17/10/0c/0064aadd.jpg","nickname":"Banana คิดถึง","note":"","ucode":"9C412BD1A6684A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":209907,"discussion_content":"看完你的才懂前面的🤣","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584687637,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1794074,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/60/1a/04a7669c.jpg","nickname":"一枝花","note":"","ucode":"F3CF46A9215C96","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":172283,"discussion_content":"看前面的都没完全懂，看您说的完全明白了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581774940,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29478,"user_name":"shane","can_delete":false,"product_type":"c1","uid":1056157,"ip_address":"","ucode":"1B8C545501A898","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/9d/ba8dc797.jpg","comment_is_top":false,"comment_ctime":1538388266,"is_pvip":false,"replies":[{"id":"10623","content":"形象👍","user_name":"作者回复","comment_id":29478,"uid":"1190123","ip_address":"","utype":1,"ctime":1538407190,"user_name_real":"gg"}],"discussion_count":7,"race_medal":0,"score":"422445183274","product_id":100017301,"comment_content":"无限循环的问题，我认为内存分配是从后往前分配的。例如，在Excel中从上往下拉4个格子，变量i会先被分配到第4个格子的内存，然后变量arr往上数分配3个格子的内存，但arr的数据是从分配3个格子的第一个格子从上往下存储数据的，当访问第3索引时，这时刚好访问到第4个格子变量i的内存。<br>不知道对不对，望指正！","like_count":98,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425631,"discussion_content":"形象👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538407190,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1103353,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d5/f9/1f9a2c3c.jpg","nickname":"磨砖做镜","note":"","ucode":"D8B8196AE1ED98","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275989,"discussion_content":"你这个反人类","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590799969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1691581,"avatar":"https://static001.geekbang.org/account/avatar/00/19/cf/bd/4fa01a1c.jpg","nickname":"wd2010","note":"","ucode":"E194E4EFECA013","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57051,"discussion_content":"fuwu说的很形象哦","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574562228,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1056157,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1d/9d/ba8dc797.jpg","nickname":"shane","note":"","ucode":"1B8C545501A898","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1691581,"avatar":"https://static001.geekbang.org/account/avatar/00/19/cf/bd/4fa01a1c.jpg","nickname":"wd2010","note":"","ucode":"E194E4EFECA013","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":156385,"discussion_content":"丹丹？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1580356530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":57051,"ip_address":""},"score":156385,"extra":""}]},{"author":{"id":1182391,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0a/b7/6a37b0f9.jpg","nickname":"tian0311","note":"","ucode":"45C9BA01816B0D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582719,"discussion_content":"翻到这里看懂了+10086","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659604264,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1254012,"avatar":"https://static001.geekbang.org/account/avatar/00/13/22/7c/7169323f.jpg","nickname":"飘逸的翔云","note":"","ucode":"0E756D3AC3D889","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532807,"discussion_content":"在这里终于懂了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637710457,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2834742,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/41/36/b78c5e0b.jpg","nickname":"王艺林","note":"","ucode":"23B7C7791C1C20","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411982,"discussion_content":"翻到这里终于懂了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636038826,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29862,"user_name":"李朋远","can_delete":false,"product_type":"c1","uid":1241782,"ip_address":"","ucode":"A8C1AEDD10973F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/b6/d3afc1ec.jpg","comment_is_top":false,"comment_ctime":1538570156,"is_pvip":false,"replies":[{"id":"10711","content":"说的没错 👍","user_name":"作者回复","comment_id":29862,"uid":"1190123","ip_address":"","utype":1,"ctime":1538580901,"user_name_real":"gg"}],"discussion_count":6,"race_medal":0,"score":"366610790316","product_id":100017301,"comment_content":"老师，您好，个人觉得您举例的内存越界的循环应该限制在x86架构的小端模式，在别的架构平台上的大端模式应该不是这样的！","like_count":85,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425745,"discussion_content":"说的没错 👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538580901,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1391354,"avatar":"https://static001.geekbang.org/account/avatar/00/15/3a/fa/21f64eaa.jpg","nickname":"mimof9","note":"","ucode":"C83B3E2CD62BBD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350282,"discussion_content":"楼主对大、小端概念理解不准确。大、小端是描述超过8字节的单个类型如何分配内存地址的，例子的越界是申明多个类型时，如何分配栈地址引起的。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1613795157,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1890053,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/MWs6nBSHJBC5O85iaic2ibtW5ic86sSURTSraQJ8Pz5rEdUowdtVf6ZxciaKyibIDoJV9VA82p1uMkZRib0VX9iaTJxUvw/132","nickname":"大葡萄王","note":"","ucode":"0BD97442AFC79A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393990,"discussion_content":"和大小端模式没关系的，大小端是对一个变量内部的不同字节之前的存储顺序，变量与变量之间整体还是符合从低地址到高地址的读取的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1631680379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2066987,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/8a/2b/f2dca1fd.jpg","nickname":"有没有口罩一个给我","note":"","ucode":"EF9BCF9C5F5378","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348679,"discussion_content":"差点忘了还有小端、大端这个概念","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612677336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1794349,"avatar":"","nickname":"sivagZhang","note":"","ucode":"95FB725C8F895C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":98848,"discussion_content":"3个int元素的后面放一个四字节的i变量。并不需要更多的对齐。\n这个也不是一定的，编译器不同，平台不同导致可能覆盖为0， 也可能不覆盖","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577188845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1370225,"avatar":"https://static001.geekbang.org/account/avatar/00/14/e8/71/c14348fb.jpg","nickname":"Michael","note":"","ucode":"68D332398159E1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":71304,"discussion_content":"不知道我对字位对齐的理解对不对。 64位的机器上，按照字位对齐，是不是就没这种问题？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575389477,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29428,"user_name":"hope","can_delete":false,"product_type":"c1","uid":1250784,"ip_address":"","ucode":"468A802184AB32","user_header":"https://static001.geekbang.org/account/avatar/00/13/15/e0/bc9f556c.jpg","comment_is_top":false,"comment_ctime":1538368552,"is_pvip":false,"replies":[{"id":"10624","content":"1. 不同的语言对数组访问越界的处理方式不同，即便是同一种语言，不同的编译器处理的方式也不同。至于你熟悉的语言是怎么处理的，请行百度。<br>2. C语言中，数组访问越界的处理是未决。并不一定是错，有同学做实验说没问题，那并不代表就是正确的。<br>3. 我觉得那个例子，栈是由高到低位增长的，所以，i和数组的数据从高位地址到低位地址依次是：i, a[2], a[1], a[0]。a[3]通过寻址公式，计算得到地址正好是i的存储地址，所以a[3]=0，就相当于i=0.<br>4. 大家有不懂的多看看留言，留言区还是有很多大牛的！我可能有时候回复的不及时，或者同样的问题只回复一个同学！","user_name":"作者回复","comment_id":29428,"uid":"1190123","ip_address":"","utype":1,"ctime":1538407266,"user_name_real":"gg"}],"discussion_count":6,"race_medal":0,"score":"302186079272","product_id":100017301,"comment_content":"根据我们前面讲的数组寻址公式，a[3] 也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。<br><br>这块不是十分清晰，希望老师详细解答一下，谢谢！<br><br>看完了 ，之前说总结但是没总结，这次前连天的总结也补上了，打卡","like_count":70,"discussions":[{"author":{"id":2153719,"avatar":"https://static001.geekbang.org/account/avatar/00/20/dc/f7/20840937.jpg","nickname":"悟者","note":"","ucode":"B50C8FF5CDE045","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303421,"discussion_content":"建议 没看懂的地方 先看几遍，然后在评论区说说自己的看法，改天或者过段时间再回看，也有可能会突然懂","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1599236449,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1307719,"avatar":"https://static001.geekbang.org/account/avatar/00/13/f4/47/cdea9def.jpg","nickname":"叫不醒装睡的人","note":"","ucode":"19A427BBBA98FF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":200039,"discussion_content":"还有a[3]和i都是同一类型，所以a[3]才能访问到i","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1583649593,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1943619,"avatar":"","nickname":"进击的小菜","note":"","ucode":"DEDC4D31DA0DF1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1307719,"avatar":"https://static001.geekbang.org/account/avatar/00/13/f4/47/cdea9def.jpg","nickname":"叫不醒装睡的人","note":"","ucode":"19A427BBBA98FF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220506,"discussion_content":"差点忽略啊👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585885407,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":200039,"ip_address":""},"score":220506,"extra":""}]},{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425597,"discussion_content":"1. 不同的语言对数组访问越界的处理方式不同，即便是同一种语言，不同的编译器处理的方式也不同。至于你熟悉的语言是怎么处理的，请行百度。\n2. C语言中，数组访问越界的处理是未决。并不一定是错，有同学做实验说没问题，那并不代表就是正确的。\n3. 我觉得那个例子，栈是由高到低位增长的，所以，i和数组的数据从高位地址到低位地址依次是：i, a[2], a[1], a[0]。a[3]通过寻址公式，计算得到地址正好是i的存储地址，所以a[3]=0，就相当于i=0.\n4. 大家有不懂的多看看留言，留言区还是有很多大牛的！我可能有时候回复的不及时，或者同样的问题只回复一个同学！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1538407266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1779257,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKfLxAj43sGzJTnmdh8iawoNJ1VsdFvJHTHccxkX7HhtOFtTV9icG3B2Gt5EztPOicsicc3xG0XTlyUVg/132","nickname":"luoyayun361","note":"","ucode":"D3AD83D44EE721","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211752,"discussion_content":"“计算得到地址正好是i的存储地址，所以a[3]=0，就相当于i=0.”  就算访问到i 的地址，那i的地址就算为0，地址里面存储的i 的值为啥也为0呢？求解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584886136,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1943619,"avatar":"","nickname":"进击的小菜","note":"","ucode":"DEDC4D31DA0DF1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1779257,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKfLxAj43sGzJTnmdh8iawoNJ1VsdFvJHTHccxkX7HhtOFtTV9icG3B2Gt5EztPOicsicc3xG0XTlyUVg/132","nickname":"luoyayun361","note":"","ucode":"D3AD83D44EE721","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220504,"discussion_content":"i = a[3] = 0?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585885368,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":211752,"ip_address":""},"score":220504,"extra":""}]}]},{"had_liked":false,"id":29823,"user_name":"港","can_delete":false,"product_type":"c1","uid":1122464,"ip_address":"","ucode":"35931FC6198180","user_header":"https://static001.geekbang.org/account/avatar/00/11/20/a0/1fca96c0.jpg","comment_is_top":false,"comment_ctime":1538554855,"is_pvip":false,"replies":[{"id":"10723","content":"👍","user_name":"作者回复","comment_id":29823,"uid":"1190123","ip_address":"","utype":1,"ctime":1538581691,"user_name_real":"gg"}],"discussion_count":1,"race_medal":0,"score":"276416461799","product_id":100017301,"comment_content":"1. 我认为文中更准确的说法可能是标记-整理垃圾回收算法。标记-清除算法在垃圾收集时会先标记出需要回收的对象，标记完成后统一回收所有被标记的对象。清除之后会产生大量不连续的内存碎片。标记-整理垃圾回收算法在标记完成之后让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。<br>2. 假设二维数组大小为m*n，那么寻址公式为<br>a[i][j]_address = base_address + (i * n+j)*data_type_size<br><br>3. C语言变量的内存申请可以看做是地址按照从大到小连续申请的，因为i在arr前面申请，所以arr[3]的地址和i的地址相同。<br><br>例如对于如下代码：    <br>int i = 0;int j = 1;int k = 2;    int arr[3] = {0};    cout&lt;&lt;&quot;i-&quot;&lt;&lt;&amp;i&lt;&lt;endl;    <br>cout&lt;&lt;&quot;j-&quot;&lt;&lt;&amp;j&lt;&lt;endl;    <br>cout&lt;&lt;&quot;k-&quot;&lt;&lt;&amp;k&lt;&lt;endl;    <br>cout&lt;&lt;&quot;arr-&quot;&lt;&lt;&amp;arr&lt;&lt;endl;<br>cout&lt;&lt;&quot;arr3-&quot;&lt;&lt;&amp;arr[3]&lt;&lt;endl;<br><br>运行结果：<br>i-0x28ff0c\r<br>j-0x28ff08\r<br>k-0x28ff04\r<br>arr-0x28fef8\r<br>arr3-0x28ff04<br>","like_count":64,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425729,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538581691,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29630,"user_name":"小帅b","can_delete":false,"product_type":"c1","uid":1234521,"ip_address":"","ucode":"D866A428967480","user_header":"https://static001.geekbang.org/account/avatar/00/12/d6/59/cb4e7ed8.jpg","comment_is_top":false,"comment_ctime":1538463241,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"242056631817","product_id":100017301,"comment_content":"————总结一下————<br><br>什么是数组<br><br>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。<br><br><br><br>1.线性表<br>线性表就是数据排成像一条线一样的结构。<br>常见的线性表结构：数组，链表、队列、栈等。<br><br>2. 连续的内存空间和相同类型的数据<br><br>优点：两限制使得具有随机访问的特性<br>缺点：删除，插入数据效率低<br><br>数组怎么根据下标随机访问的？<br><br>通过寻址公式，计算出该元素存储的内存地址：<br>a[i]_address = base_address + i * data_type_size<br><br>为何数组插入和删除低效<br><br>插入：<br>若有一元素想往int[n]的第k个位置插入数据，需要在k-n的位置往后移。<br>最好情况时间复杂度 O(1)<br>最坏情况复杂度为O(n)<br>平均负责度为O(n)<br><br>如果数组中的数据不是有序的，也就是无规律的情况下，可以直接把第k个位置上的数据移到最后，然后将插入的数据直接放在第k个位置上。<br><br>这样时间复杂度就将为 O（1）了。<br><br>删除：<br>与插入类似，为了保持内存的连续性。<br>最好情况时间复杂度 O(1)<br>最坏情况复杂度为O(n)<br>平均负责度为O(n)<br><br>提高效率：将多次删除操作中集中在一起执行，可以先记录已经删除的数据，但是不进行数据迁移，而仅仅是记录，当发现没有更多空间存储时，再执行真正的删除操作。这也是 JVM 标记清除垃圾回收算法的核心思想。<br><br>数组访问越界问题<br>C语言中的数据越界是一种未决行为，一般比较难发现的逻辑错误。相比之下，Java会有越界检查。<br><br>用数组还是容器？<br>数组先指定了空间大小<br>容器如ArrayList可以动态扩容。<br>1.希望存储基本类型数据，可以用数组<br>2.事先知道数据大小，并且操作简单，可以用数组<br>3.直观表示多维，可以用数组<br>4.业务开发，使用容器足够，开发框架，追求性能，首先数组。<br><br>为什么数组要从 0 开始编号？<br>由于数组是通过寻址公式，计算出该元素存储的内存地址：<br>a[i]_address = base_address + i * data_type_size<br>如果数组是从 1 开始计数，那么就会变成：<br>a[i]_address = base_address + （i-1）* data_type_size<br><br>对于CPU来说，多了一次减法的指令。<br>当然，还有一定的历史原因。<br><br>————课后思考————<br><br>1.我理解的JVM标记清除垃圾回收算法：在标记阶段会标记所有的可访问的对象，在清除阶段会遍历堆，回收那些没有被标记的对象。现在想想，和「如果数组中的数据不是有序的，也就是无规律的情况下，可以直接把第k个位置上的数据移到最后，然后将插入的数据直接放在第k个位置上。」思想类似。<br><br>2. 对于一维数组：a[i]_address = base_address + （i）* data_type_size<br>二维数组如果是m*n，那么a[i][j]== base_address + （i*n+j）* data_type_size。<br>2.","like_count":56},{"had_liked":false,"id":83501,"user_name":"Teanmy","can_delete":false,"product_type":"c1","uid":1209599,"ip_address":"","ucode":"89F466CC698583","user_header":"","comment_is_top":false,"comment_ctime":1554629197,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"220597961293","product_id":100017301,"comment_content":"汇总一下各位大神关于那段代码无限循环的总结：<br>这段代码无限循环原因有2，以及一个附加条件:<br>1.栈空间从高往低依次分配，i占4字节，接着arr占12字节，内存从高往低是这样：存i的4字节|arr[2]|arr[1]|arr[0]，数组访问是通过“baseAddr+index乘typeSize”得到，算下来当index=3时，刚好是i的地址<br>2.这里刚好满足字节对齐，系统为64位系统，字长64，那么字节对齐必须是8字节的倍数，刚好i变量和arr变量占了16字节，对齐了<br>如果这里将arr[3]改为arr[4]，为了对齐，内存从高往低是这样：存i的4字节|空4字节|arr[3]|arr[2]|arr[1]|arr[0]，那么arr[4]刚好是空的4字节，无法影响到i的值，则并不会无限循环<br><br>附加条件：编译时gcc默认会自动添加越界保护，此处要达到无限循环效果，编译时需加上-fno-stack-protector去除该保护","like_count":51,"discussions":[{"author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4098,"discussion_content":"为什么是 arr[2]|arr[1]|arr[0] 呢？不是 0  1 2 呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1565110854,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2094925,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/f7/4d/09554c96.jpg","nickname":"iron bo","note":"","ucode":"4BFB1331637AA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582334,"discussion_content":"Mark，很赞，很全","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659401551,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1972505,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/19/19/d82e24fb.jpg","nickname":"李润东","note":"","ucode":"65CFEA3C8B27C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":245375,"discussion_content":"厉害了，讲的真的好！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587656468,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1690568,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/iclloMUx1mWeicrY0WuxVotpIEiciczJXGpzQ40v4BuxXtFic8byfUQGMpzyeic8rA68RXvcZJHQybbBtM2rVt2kUNEw/132","nickname":"Geek_175506","note":"","ucode":"15397D44A39987","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":25024,"discussion_content":"arr[3]变为arr[4]循环是i<=3,是能够访问到arr[3]元素的 并不会发生无限循环呀，何来的空字节呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570371487,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31460,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1539185544,"is_pvip":false,"replies":[{"id":"11424","content":"👍","user_name":"作者回复","comment_id":31460,"uid":"1190123","ip_address":"","utype":1,"ctime":1539269598,"user_name_real":"gg"}],"discussion_count":1,"race_medal":0,"score":"126093237128","product_id":100017301,"comment_content":"以问题为思路学习本节（国庆10天假，加来完成当初立下的flag，求支持鼓励）<br>一、引子：为什么很多编程语言的数组都是从0开始编号的？<br>\t1、从数组存储的内存模型上来看，“下标”确切的说法就是一种“偏移”，相比从1开始编号，从0开始编号会少一次减法运算，数组作为非常基础的数组结构，通过下标随机访问元素又是非常基础的操作，效率的优化就要尽可能的做到极致。<br>\t2、主要的原因是历史原因，C语言的设计者是从0开始计数数组下标的，之后的Java、JS等语言都进行了效仿，或者说是为了减少从C转向Java、JS等的学习成本。<br>二、什么是数组？<br>\t数组是一个线性数据结构，用一组连续的内存空间存储一组具有相同类型的数据。<br>\t其实数组、链表、栈、队列都是线性表结构；树、图则是非线性表结构。<br>三、数组和链表的面试纠错？<br>\t1、数组中的元素存在一个连续的内存空间中，而链表中的元素可以不存在于连续的内存空间。<br>\t2、数组支持随机访问，根据下标随机访问的时间复杂度是O(1)；链表适合插入、删除操作，时间复杂度为O(1）。<br>四、容器是否完全替代数组？<br>\t容器的优势：对于Java语言，容器封装了数组插入、删除等操作的细节，并且支持动态扩容。<br>\t对于Java，一些更适合用数组的场景：<br>\t1、Java的ArrayList无法存储基本类型，需要进行装箱操作，而装箱与拆箱操作都会有一定的性能消耗，如果特别注意性能，或者希望使用基本类型，就可以选用数组。<br>\t2、若数组大小事先已知，并且对数组只有非常简单的操作，不需要使用到ArrayList提供的大部分方法，则可以直接使用数组。<br>\t3、多维数组时，使用数组会更加直观。<br>五、JVM标记清除算法？<br>\tGC最基础的收集算法就是标记-清除算法，如同他们的名字一样，此算法分为“标记”、“清除”两个阶段，先标记出需要回收的对象，再统一回收标记的对象。不足有二，一是效率不高，二是产生碎片内存空间。<br>六、数组的内存寻址公式？<br>\t一维数组：a[i]_address=base_address+i*type_size<br>\t二维数组：二维数组假设是m*n， a[i][j]_address=base_address + (i*n+j)*type_size<br>\t三维数组：三维数组假设是m*n*q， a[i][j][k]_address=base_address + (i*n*q + j*q + k)*type_size<br><br>若理解有误，欢迎指正，谢谢！","like_count":29,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426352,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539269598,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29328,"user_name":"qx","can_delete":false,"product_type":"c1","uid":1060126,"ip_address":"","ucode":"5681418A3D99CC","user_header":"https://static001.geekbang.org/account/avatar/00/10/2d/1e/c6359873.jpg","comment_is_top":false,"comment_ctime":1538354173,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"117502471165","product_id":100017301,"comment_content":"1.老师您好，二维数组存储也是连续的吧。<br>2.对于数组删除abc，还没太理解?申请的是三个地址空间，a（3）越界了，那么它会去找哪个地址的数据呢？而且for循环就是三次啊，如何无限打印?<br>3.老师时候每讲完一节数据结构可以对应到一些编程题目给大家思考啊例如leetcode或其他的?","like_count":27,"discussions":[{"author":{"id":1103353,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d5/f9/1f9a2c3c.jpg","nickname":"磨砖做镜","note":"","ucode":"D8B8196AE1ED98","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275991,"discussion_content":"循环了四次，你这","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590800126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29704,"user_name":"CathyLin","can_delete":false,"product_type":"c1","uid":1240546,"ip_address":"","ucode":"F7CDFF5E1A235F","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/e2/0e1c6c5a.jpg","comment_is_top":false,"comment_ctime":1538492213,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"113207641909","product_id":100017301,"comment_content":"看完 &amp; 写完笔记来打卡，发现评论区好多大牛！光是翻看了评论区就收获了好多！","like_count":26,"discussions":[{"author":{"id":1911733,"avatar":"","nickname":"且听风吟","note":"","ucode":"51549E28661CEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":207529,"discussion_content":"是了，评论区都能学到好多东西哈哈~","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584502750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2528636,"avatar":"https://static001.geekbang.org/account/avatar/00/26/95/7c/cf4fc9e0.jpg","nickname":"Insolence","note":"","ucode":"9FE0AA6CA47724","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":359713,"discussion_content":"同意","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616253912,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29476,"user_name":"执__生","can_delete":false,"product_type":"c1","uid":1141545,"ip_address":"","ucode":"F74B5AB30A9D8A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Gkedlmv1ibTmUcALf69BCDhg5j0CGtqxaHHtpnbWc6yF8Wld7ILmgoScJtk4QiblfqoUJl9jyNhjgib9aEBGlIh8Q/132","comment_is_top":false,"comment_ctime":1538386032,"is_pvip":true,"replies":[{"id":"10589","content":"说得好！","user_name":"作者回复","comment_id":29476,"uid":"1190123","ip_address":"","utype":1,"ctime":1538400540,"user_name_real":"gg"}],"discussion_count":1,"race_medal":0,"score":"87437731952","product_id":100017301,"comment_content":"我也是js开发者，前面的那位js开发者同学的问题其实不难解决。<br>如果不知道老师的“数组”究竟是什么，只要查一下数据结构里的“数组”和“链表”的定义，然后搜一些关于js引擎对js定义下“数组”的底层实现的文章，比如“深究 JavaScript 数组 —— 演进&amp;性能”。就知道老师在说什么了。<br>互联网从业者更要善用互联网，加油！","like_count":20,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425629,"discussion_content":"说得好！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538400540,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29333,"user_name":"HCG","can_delete":false,"product_type":"c1","uid":1137137,"ip_address":"","ucode":"6858ED53AA1FB6","user_header":"https://static001.geekbang.org/account/avatar/00/11/59/f1/5a043e01.jpg","comment_is_top":false,"comment_ctime":1538355082,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"87437701002","product_id":100017301,"comment_content":"对于无线循环那个问题解释<br><br>个人认为应该按照这样的顺序声明：<br>int arr［3］＝｛0｝;<br>int i;<br>因为在计算机中程序一般顺序分配存储空间，这样声明，首先分配0 1 2三个存储单元给数组arr，然后再分配 4 存储单元给变量i，然后根据数组访问公式即会出现无线循环。<br>不知道对不对，还请老师指点。","like_count":20,"discussions":[{"author":{"id":2629022,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM4G9tNMvTmsouicic61x5DbyZ774eVAozZgjgsaINHpYKNa8ia6U7Wic6TBA1nVjfQKmrY7RZOqW3YlAg/132","nickname":"Geek_0806c1","note":"","ucode":"76E4BB521BE44E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374813,"discussion_content":"No. You can try to debug using GDB","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621371455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83127,"user_name":"蒙奇•D•273°","can_delete":false,"product_type":"c1","uid":1179601,"ip_address":"","ucode":"5570919A507386","user_header":"https://static001.geekbang.org/account/avatar/00/11/ff/d1/28adb620.jpg","comment_is_top":false,"comment_ctime":1554430957,"is_pvip":false,"replies":[{"id":"30081","content":"我们这里讲的数据结构里的数组，跟编程语言中的数组还有一定区别的。这个讲起来比较复杂，我写了篇长文，解释一下。<br>https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;E-c41h2v_AfffrlAQpkyLg","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1554517016,"ip_address":"","comment_id":83127,"utype":1}],"discussion_count":4,"race_medal":0,"score":"70273907693","product_id":100017301,"comment_content":"int类型是固定长度的，string数组在内存中又是如何分配的，放的地址吗？","like_count":16,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445875,"discussion_content":"我们这里讲的数据结构里的数组，跟编程语言中的数组还有一定区别的。这个讲起来比较复杂，我写了篇长文，解释一下。\nhttps://mp.weixin.qq.com/s/E-c41h2v_AfffrlAQpkyLg","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554517016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2198755,"avatar":"https://static001.geekbang.org/account/avatar/00/21/8c/e3/b9e926f9.jpg","nickname":"面罩","note":"","ucode":"E85F2550D7C6D6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388248,"discussion_content":"文章没了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1628667418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2223167,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/mQddXC7nRiaKHTwdficicTB3bH0q5ic5UoSab51Omic7eyLBz0SNcvbLpQnNib7zP1yJFm7xxx4ia81iahfibRVnbTwHmhw/132","nickname":"浮石沉木","note":"","ucode":"D585768321B84A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582174,"discussion_content":"基本数据类型的长度在不同语言中的是非固定的,例如c++中的int的长度并没有固定，只是提供了一些限制性的原则：\nshort至少16位；\nint至少与short一样长；\nlong至少32位，且至少与int一样长；\nlong long 至少64位，且至少与long一样长。\njava是为了方便开发，所有固定死了基本数据类型的长度。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659276597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135761,"avatar":"https://static001.geekbang.org/account/avatar/00/11/54/91/845de758.jpg","nickname":"L","note":"","ucode":"68954D2A92AB01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":21759,"discussion_content":"有意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569513247,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29343,"user_name":"Kudo","can_delete":false,"product_type":"c1","uid":1036948,"ip_address":"","ucode":"21965914B72AEB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d2/94/8bd217f1.jpg","comment_is_top":false,"comment_ctime":1538356217,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"70257832953","product_id":100017301,"comment_content":"假设二维数组的维度为m * n，则 a[i][j]_address = base_address + (i * n + j) * type_size","like_count":16},{"had_liked":false,"id":29334,"user_name":"HI","can_delete":false,"product_type":"c1","uid":1238921,"ip_address":"","ucode":"C65218113883E6","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/89/207cc841.jpg","comment_is_top":false,"comment_ctime":1538355233,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"57372930081","product_id":100017301,"comment_content":"标记清除：就是将要释放清除的对象标记，之后再执行清除操作，缺点就是会产生内存碎片的问题，很有可能导致下一次分配一块连续较大的内存空间，由于找不到合适的，又触发一次垃圾回收操作，一般试用于老年代的回收<br><br>二维数组的寻址操作：首先二维数组本质也是一个连续的一维数组，只不过每个元素都为一个一维数组，在内存空间的分配是按照行的方式将每一行拼接起来，比如数组a[1][2]   来说，看做是一个一维数组的话1就代表这个一维属于的第二个元素，第二个元素为一维数组然后根据2找到这一维数组中第三的元素","like_count":13},{"had_liked":false,"id":154811,"user_name":"NEVER SETTLE","can_delete":false,"product_type":"c1","uid":1101894,"ip_address":"","ucode":"9C86BDAFDBF768","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/46/1a9229b3.jpg","comment_is_top":false,"comment_ctime":1574571678,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"53114179230","product_id":100017301,"comment_content":"Go语言GC算法主要是基于Mark and Sweep (标记清除)算法，在此基础上进行改进和优化。<br>1). Mark and Sweep(标记清除)算法主要是以下2个步骤：<br>标记(Mark): 找出所有不可达对象，然后做上标记<br>清除(Sweep): 回收标记好的对象<br><br>标记清除具体步骤如下：<br>a). 开始标记，程序暂停<br>b). 找到所有可达对象，并做上标记<br>c). 标记完成后开始清除未标记的对象<br>d). 清除完成<br><br>2). 标记清除算法存在以下几个问题<br>a). STW (stop the world) 标记对象的时候程序需要暂停，导致程序出现卡顿 (最主要的问题)<br>b). 标记需要扫描整个堆<br>c). 清除对象会产生堆碎片<br>STW指的是runtime把所有的协程都冻结了，意味着用户逻辑是暂停的，这样所有的对象都不会被修改，这个时候去扫描是绝对安全的。<br><br>3). Tri-color Marking<br>为了解决标记清除算法带来的问题，Go在标记清除算法基础上提出来Tri-color Marking(三色标记法)算法来优化GC过程，大体流程如下：<br>a). 最开始所有的对象都是白色的<br>b). GC开始，扫描所有可达的对象，标记为灰色<br>c). 从灰色对象中找到其引用对象并标记为灰色，自己标记为黑色<br>d). 监控对象修改，循环上一步骤，直到没有任何灰色对象<br>e). GC回收白色对象<br>f). 最后把所有黑色对象变成白色<br><br>4). 三色标记法通过2点来优化STW问题<br>a). 标记操作和用户逻辑并行:  <br>用户逻辑经常会生成或改变对象引用，那如何保证标记和用户逻辑并行呢？Go为了解决这个问题引入了写屏障机制，在GC的过程中会监控对象的内存修改，并对对象进行重新标记，这个时候用户逻辑也可以执行 (实际上是很短暂的STW，然后对对象重新标记)，所以标记操作可以做到一定程度和用户逻辑并行。<br><br>b). 清除操作和用户逻辑并行: <br>三色标记法中最后只剩下的黑白两种对象，黑色对象是程序恢复后接着使用的对象，如果不碰触黑色对象，只清除白色的对象，肯定不会影响程序逻辑，所以清除白色对象和用户逻辑可以并行。<br><br>通过允许用户逻辑在标记和清除操作上做到并行处理来缩短STW的时间，提升整体GC的性能。","like_count":12},{"had_liked":false,"id":66682,"user_name":"LadyForest","can_delete":false,"product_type":"c1","uid":1348673,"ip_address":"","ucode":"17D9198016DD7C","user_header":"https://static001.geekbang.org/account/avatar/00/14/94/41/be0af1c4.jpg","comment_is_top":false,"comment_ctime":1549980103,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"53089587655","product_id":100017301,"comment_content":"龟系学习，基本刷完了leetcode的array","like_count":12,"discussions":[{"author":{"id":1902002,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/05/b2/93b64021.jpg","nickname":"Geek_jikuo","note":"","ucode":"D4AF9E736701B8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329622,"discussion_content":"相同操作，哈哈","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1606437020,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1896868,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/f1/a4/79c36b87.jpg","nickname":"流云","note":"","ucode":"26C5A9166EC6D8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297538,"discussion_content":"leetcode的array哪些值得一刷？可否方便提供一个列表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596963415,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133209,"user_name":"rovernerd","can_delete":false,"product_type":"c1","uid":1401217,"ip_address":"","ucode":"C8620AAF0E4920","user_header":"https://static001.geekbang.org/account/avatar/00/15/61/81/9e34165b.jpg","comment_is_top":false,"comment_ctime":1568443962,"is_pvip":false,"replies":[{"id":"51221","content":"ipad Paper","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1568588424,"ip_address":"","comment_id":133209,"utype":1}],"discussion_count":1,"race_medal":0,"score":"48813084218","product_id":100017301,"comment_content":"请教老师老师一个问题，老师专栏的图片是用什么软件画的呢？非常直观好看呢","like_count":11,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467295,"discussion_content":"ipad Paper","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568588424,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30060,"user_name":"金炜","can_delete":false,"product_type":"c1","uid":1240446,"ip_address":"","ucode":"0CD20149636B94","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/7e/255fb6ee.jpg","comment_is_top":false,"comment_ctime":1538640876,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"44488313836","product_id":100017301,"comment_content":"前面“不诉离殇“ 提到的内存对齐会影响结果的说法有点问题，对于数组内存对齐是按数组里的元素对齐的，所以即使是长度为4的数组，变量i还是和数组最后一个元素挨着相邻。","like_count":10},{"had_liked":false,"id":29864,"user_name":"_yj","can_delete":false,"product_type":"c1","uid":1249990,"ip_address":"","ucode":"7A7787B9E8656F","user_header":"https://static001.geekbang.org/account/avatar/00/13/12/c6/0c1f8e4d.jpg","comment_is_top":false,"comment_ctime":1538570164,"is_pvip":false,"replies":[{"id":"10710","content":"兄dei啊，我没说一定就会死循环呀，我说是这种数组越界是未决的，是编程语言和编译器都有关的，麻烦看看仔细看看我的文章和留言好不啦~","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538580597,"ip_address":"","comment_id":29864,"utype":1}],"discussion_count":2,"race_medal":0,"score":"40193275828","product_id":100017301,"comment_content":"疑问：<br>老师说压栈是从高地址向低地址扩展<br>但是我使用gcc编译打印变量地址发现地址是向上增长，于是我怀疑是不是哪里出了问题<br>经过百度我了解到bsp寄存器会存储栈顶地址<br>我便把我写的代码编译成 test.S 查看编译后的汇编代码<br>我发现bsp进行了一个subl的操作<br>因为我并没有研究过x86的汇编<br>所以我猜想：<br>这儿实际是通过向下扩展腾出变量所需的栈空间<br>但是压栈的顺序是由编译器来完成的<br>所以压栈确实是从高地址向低地址扩展<br>但为什么地址会向上增长是由编译器决定<br>所以这儿所说的i的地址为什么刚好在arr后面<br>事实上是编译器决定的<br>我在我的虚拟机上实验的结果表明编译器会先把数组的地址依次从最低位向上压栈<br>其他的变量地址在数组之后按照定义的次序压栈<br>所以：<br>我认为老师说的从高位向低位压栈arr【3】寻址访问到 i 在这儿是有问题的<br>因为实际压栈从高位往低位压还是反过来压是由编译器所决定<br>如果有误望指出","like_count":9,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425746,"discussion_content":"兄dei啊，我没说一定就会死循环呀，我说是这种数组越界是未决的，是编程语言和编译器都有关的，麻烦看看仔细看看我的文章和留言好不啦~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538580597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1147711,"avatar":"https://static001.geekbang.org/account/avatar/00/11/83/3f/bc2ea80d.jpg","nickname":"陌.寒哲","note":"","ucode":"B7079FF211D712","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":44925,"discussion_content":"我觉得老师说法有问题，你在文中虽然没说一定出现死循环，但你也没有说清楚只在某些特定情况才会出现死循环。作为读者，当然认为你写的就是对的，一定时这样子的结果啊。这能怪同学嘛？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572986438,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29412,"user_name":"姜威","can_delete":false,"product_type":"c1","uid":1244051,"ip_address":"","ucode":"C58EB9A5AD634D","user_header":"https://static001.geekbang.org/account/avatar/00/12/fb/93/f19a5364.jpg","comment_is_top":false,"comment_ctime":1538365478,"is_pvip":false,"replies":[{"id":"10619","content":"java二维数组是分块连续的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538406409,"ip_address":"","comment_id":29412,"utype":1}],"discussion_count":3,"race_medal":0,"score":"40193071142","product_id":100017301,"comment_content":"五、扩展知识点<br>1.为什么数组下标从0开始？<br>因为数组的首地址是数组第1个元素存储空间的起始位置，若用下标0标记第1元素则通过寻址公式计算地址时直接使用下标值计算，即a[0]_address = base_address + 0 * data_type_size。若用下标1标记第1个元素则通过寻址公式计算地址时需将下标值减1再计算，即a[1]_address = base_address + (1-1) * data_type_size，这样每次寻址计算都多了一步减法操作，增加了性能开销。<br>2.多维数组如何寻址？<br>这个在Java中没有意义，因为Java中多维数组的内存空间是不连续的，所以，暂不考虑。<br>3.JVM垃圾回收器算法的核心精髓是什么？<br>若堆中的对象没有被引用，则其就被JVM标记为垃圾但并没有释放内存空间，当数组空间不足时，再一次性释放被标记的对象的内存空间，这就是JVM垃圾回收器算法的核心精髓。","like_count":9,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425586,"discussion_content":"java二维数组是分块连续的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538406409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1691500,"avatar":"https://static001.geekbang.org/account/avatar/00/19/cf/6c/87faa554.jpg","nickname":"MoeRookie","note":"","ucode":"E860D73EE91F00","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":69276,"discussion_content":"什么是分块连续？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575278132,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1589627,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKxr7C1K4CsTficFVDE1QicId6R34nxqsjyqZDNictUVhicO2icSQNn4ojagcTDPTcUD2ibW5lzvZRAyRug/132","nickname":"Geek_747271","note":"","ucode":"ECD9B603B84F59","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":44167,"discussion_content":"什么叫分块连续？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572936355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156807,"user_name":"猫切切切切切","can_delete":false,"product_type":"c1","uid":1075033,"ip_address":"","ucode":"F350BA1B7FFDC4","user_header":"https://static001.geekbang.org/account/avatar/00/10/67/59/017b5726.jpg","comment_is_top":false,"comment_ctime":1574961330,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"35934699698","product_id":100017301,"comment_content":"对于一个二维数组：<br>[<br>    [a01, a02, a03, ..., a0j],<br>    [a11, a12, a13, ..., a1j],<br>    [a21, a22, a23, ..., a2j],<br>    ...<br>    [ai1, ai2, ai3, ..., aij],<br>]<br>其根据下标（i 和 j）的寻址公式为：<br>a[i,j]_addr = base_addr[j] + j * data_type_size<br>其中 base_addr[j] 为第 i 个数组的基准地址<br>也就是说，第 i 个数组是一个一维数组，它的第 j 个元素的寻址公式和一维数组是一样的<br>而 base_addr[j] = base_addr + i * data_type_size[i]<br>其中 data_type_size[i] 是第 i 个数组的长度，<br>所以 data_type_size[i] = n * data_type_size<br>于是寻址公式化为：<br>a[i,j]_addr = base_addr + i * (n * data_type_size) + j * data_type_size<br>= base_dir + (i * n + j) * data_type_size","like_count":8},{"had_liked":false,"id":31918,"user_name":"coulson","can_delete":false,"product_type":"c1","uid":1125035,"ip_address":"","ucode":"ADBC6AEED866FC","user_header":"https://static001.geekbang.org/account/avatar/00/11/2a/ab/6b2475e9.jpg","comment_is_top":false,"comment_ctime":1539329506,"is_pvip":false,"replies":[{"id":"11607","content":"可以，我回复的也很心累。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539403436,"ip_address":"","comment_id":31918,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35899067874","product_id":100017301,"comment_content":"写的超级赞！提个小意见：评论那么多，看起来很碎，老师能不能定期写一篇问题汇总贴，把高频问题和优质答案进行汇总，这样看着很方便！","like_count":8,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426565,"discussion_content":"可以，我回复的也很心累。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539403436,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31274,"user_name":"meteor","can_delete":false,"product_type":"c1","uid":1194091,"ip_address":"","ucode":"100C21E2B3D056","user_header":"https://static001.geekbang.org/account/avatar/00/12/38/6b/f844fe80.jpg","comment_is_top":false,"comment_ctime":1539141096,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"31603912168","product_id":100017301,"comment_content":"数组的删除操作这段没看懂。<br><br>搬移由三次变成一次是理解的。但下面这段话不懂<br><br>“我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除”，这句话是什么意思啊？","like_count":7,"discussions":[{"author":{"id":1046846,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f9/3e/b29bdf14.jpg","nickname":"bugest","note":"","ucode":"1092ED3BDB87F1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":210850,"discussion_content":"我理解就是打个标记，有程序再次使用这个数据时，标记会告诉它数据“已删除”，即不可用，等标记达到真正物理删除标准后，集中处理","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584782851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1256428,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2b/ec/af6d0b10.jpg","nickname":"caohuan","note":"","ucode":"4B092E33F3DF1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":186759,"discussion_content":"觉得 像假删除，其实没有被真正删除，只是被标记了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582712003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1474214,"avatar":"https://static001.geekbang.org/account/avatar/00/16/7e/a6/4e331ef4.jpg","nickname":"骑行的掌柜J","note":"","ucode":"3163102651C653","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":64017,"discussion_content":"个人理解是每次我们都先对要删除的那个数据做个标记 他已经划分到被删除的那一边了 但是并不是真的删除它 也不会去搬移后面的数据 \n\n等三次标记做完后 才真正的一次性删除刚刚划分的标记为“删除”那一堆数据 并搬移后面的数据   、\n不知道这样讲你们懂没有？😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574930542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1131957,"avatar":"https://static001.geekbang.org/account/avatar/00/11/45/b5/c3cfb198.jpg","nickname":"王振华 程序员","note":"","ucode":"31BB337642B882","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":63451,"discussion_content":"我也没看懂，哪位大神来解答一下？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574871003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31928,"user_name":"浮夸伴身","can_delete":false,"product_type":"c1","uid":1017874,"ip_address":"","ucode":"5D1F240D7F87B5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/88/12/bb129795.jpg","comment_is_top":false,"comment_ctime":1539332826,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27309136602","product_id":100017301,"comment_content":"关于无限循环打印“hello world”有疑惑的同学，可以看看这篇关于gcc堆栈保护机制的文章https:&#47;&#47;blog.csdn.net&#47;u012796139&#47;article&#47;details&#47;46635567","like_count":6},{"had_liked":false,"id":31386,"user_name":"Scarlett","can_delete":false,"product_type":"c1","uid":1130648,"ip_address":"","ucode":"42BB1EB2309A9F","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/98/e5109fca.jpg","comment_is_top":false,"comment_ctime":1539168744,"is_pvip":false,"replies":[{"id":"11436","content":"👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539270091,"ip_address":"","comment_id":31386,"utype":1}],"discussion_count":2,"race_medal":0,"score":"27308972520","product_id":100017301,"comment_content":"无限循环那个试了好几次，都试不出来，觉得应该就是编译器（xcode）的问题。后来看见上面的同学回复说-fno-stack-protector编译选项，果断尝试了一下，发现xcode也有堆栈保护，设置上就出现无限循环了，果然多看评论有好处。","like_count":6,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426317,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539270091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1013855,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/78/5f/32bc9975.jpg","nickname":"陈祥龙","note":"","ucode":"6B0C331EE415F5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":323429,"discussion_content":"目测这位同学是 iOS 开发","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604934274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29315,"user_name":"fenghuo","can_delete":false,"product_type":"c1","uid":1107514,"ip_address":"","ucode":"88A9F5BE0BBAA5","user_header":"https://static001.geekbang.org/account/avatar/00/10/e6/3a/5e8be862.jpg","comment_is_top":false,"comment_ctime":1538351081,"is_pvip":true,"replies":[{"id":"10632","content":"1. 不同的语言对数组访问越界的处理方式不同，即便是同一种语言，不同的编译器处理的方式也不同。至于你熟悉的语言是怎么处理的，请行百度。<br>2. C语言中，数组访问越界的处理是未决。并不一定是错，有同学做实验说没问题，那并不代表就是正确的。<br>3. 我觉得那个例子，栈是由高到低位增长的，所以，i和数组的数据从高位地址到低位地址依次是：i, a[2], a[1], a[0]。a[3]通过寻址公式，计算得到地址正好是i的存储地址，所以a[3]=0，就相当于i=0.<br>4. 大家有不懂的多看看留言，留言区还是有很多大牛的！我可能有时候回复的不及时，或者同样的问题只回复一个同学！","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538407671,"ip_address":"","comment_id":29315,"utype":1}],"discussion_count":2,"race_medal":0,"score":"27308154857","product_id":100017301,"comment_content":"根据我们前面讲的数组寻址公式，a[3] 也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，这个地方不明白，老师可以再讲解下吗？","like_count":6,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425549,"discussion_content":"1. 不同的语言对数组访问越界的处理方式不同，即便是同一种语言，不同的编译器处理的方式也不同。至于你熟悉的语言是怎么处理的，请行百度。\n2. C语言中，数组访问越界的处理是未决。并不一定是错，有同学做实验说没问题，那并不代表就是正确的。\n3. 我觉得那个例子，栈是由高到低位增长的，所以，i和数组的数据从高位地址到低位地址依次是：i, a[2], a[1], a[0]。a[3]通过寻址公式，计算得到地址正好是i的存储地址，所以a[3]=0，就相当于i=0.\n4. 大家有不懂的多看看留言，留言区还是有很多大牛的！我可能有时候回复的不及时，或者同样的问题只回复一个同学！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538407671,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1240273,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ec/d1/a45d2715.jpg","nickname":"Michael","note":"","ucode":"CAB7B55F51981E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373880,"discussion_content":"在xcode里面尝试了一下，先定义一个int a，再定义一个int b[3],再定义一个int c[3]，打印栈地址的时候，数组b的确是高地址，数组c紧挨着b，但是a是最低的地址。所以用xcode跑这一部分c代码没出现死循环，不知道是不是xcode里面编译器给变量分配地址时，默认把基本变量放低地址了，把聚合类型的放高地址，或许就是为了防止这种死循环而出现的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620902620,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71014,"user_name":"鹏磊","can_delete":false,"product_type":"c1","uid":1193401,"ip_address":"","ucode":"959B012911729C","user_header":"https://static001.geekbang.org/account/avatar/00/12/35/b9/68b16970.jpg","comment_is_top":false,"comment_ctime":1551244821,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"23026081301","product_id":100017301,"comment_content":"《05 | 数组：为什么很多编程语言中数组都从0开始编号？》<br>笔记：<br><br># 数组如何实现随机访问<br><br>## 什么是数组？<br><br>数组（Array）是一种线性表数据结构，它用一组连续的内存空间，来存储相同类型的数据。<br><br>## 什么是线性表（Linear List）？<br><br>线性表就是数据排成一条线一样的结构，每个线性表的数据最多只有前后两个方向。<br><br>例如：数组，链表，队列，栈 等都是线性表结构<br><br>## 什么是非线性表？<br><br>例如：二叉树，堆，图，等，是非线性表，是因为，在非线性表中，数据之间并不是简单的前后关系<br><br>## 数组是如何实现根据下标随机访问数组元素的吗？<br><br>例如：`int[] a = new int[10]` <br><br>1，计算机给数组a[10]，分配了一组连续的内存空间 <br>2，比如内存块的首地址为 `base_address = 1000` <br>3，当计算给每个内存单元分配一个地址，计算机通过地址来访问数据。当计算机需要访问数组的某个元素的时候，会通过一个**寻址公式**来计算存储的内存地址。<br><br>公式如下：<br><br>```java<br>a[i]_address = base_address + i * data_type_size<br>```<br>arr[i] 首地址 = 数组内存块首地址 + 数据类型大小 * i ，其中i为偏移量。<br><br>**base_address**：内存块的首地址<br>**data_type_size**：数组中每个元素的大小，比如每个元素大小是4个字节。<br><br><br>1，数组使用二分法查找元素，时间复杂度是O(logn)<br>2，根据下标随机访问的时间复杂度是O(1)<br><br># 低效的“插入”和“删除”<br><br>**插入**：从最好O(1) 最坏O(n) 平均O(n) <br><br>**什么时候会是O(1)？**<br><br>数组若无序，插入新的元素时，可以将第K个位置元素移动到数组末尾，把新的元素，插入到第k个位置，此处复杂度为O(1)。<br><br>例如：a[10] 数组存储了5个元素： `A B C D E`<br><br>我们现在需要将元素 x 插入到第 3 个位置。我们只需要将 c 放入到 a[5]，将 a[2] 赋值为 x 即可。<br><br>最后，数组中的元素如下： `A，C，X，D，E，C`。<br><br>**什么时候会是最坏O(n)？**<br><br>从数组开头插入数据，所有的数据往后移一位，情况最差，时间复杂度为O(n) ； <br>每一位插入的概率一样，所以平均时间复杂度为(1+2+...+n)&#47;n = (1+n)&#47;2 = O(n)<br><br>**删除**：从最好O(1) 最坏O(n) 平均O(n) <br><br>和插入数据类似，如果我们要删除 K 个位置的数据，我了内存的连续性，我们需要搬移 K 位置后的所有数据往前移动一位，不然的话内存就不连续了<br><br>**什么时候会是O(1)？**<br><br>删除开头的数据<br><br>**什么时候会是最坏O(n)？**<br><br>同数组插入的原理类似<br><br>**数组如何提高效率？**：<br><br>将多次删除操作中集中在一起执行，可以先记录已经删除的数据，但是不进行数据迁移，而仅仅是记录，当发现没有更多空间存储时，再执行真正的删除操作，这样减少数据搬移次数节省耗时。<br><br>这也是跟 JVM 标记清除垃圾回收算法的核心思想。<br><br>**标记-整理垃圾回收算法**。<br><br>在垃圾收集时此算法分为“标记”、“清除”两个阶段，先标记出需要回收的对象，再统一清除标记的对象。清除之后会产生大量不连续的内存碎片。<br><br>**标记-整理垃圾回收算法**：<br><br>在标记完成之后让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。<br><br># 用数组还是容器？ <br><br>数组先指定容器大小，容器ArrayList可以动态扩容，并且封装了好多方法，一旦超过存储容量，扩容时比较耗时，因为涉及 内存申请和数据复制搬移到扩容后的数组。<br><br>1，如果已知数据大小，且涉及的数据操作比较简单，可以用数组。<br>2，比如已知 1 万条数据要存入 ArrayList，我们就可以事先指定容器大小，就可以，省掉多次的，内存申请，和数据搬移操作<br><br>3，容器无法存储基本类型，比如 int long 需要转换成包装类型，类型的转换有性能消耗<br>4，业务开发，使用容器足够，追求性能，首先用数组<br><br>**为什么数组要从 0 开始编号，而不是1？**<br><br>从偏移角度理解a[0] 0为偏移量，如果从1计数，会多出K-1。增加cpu负担。为什么循环要写成for(int i = 0;i&lt;3;i++) 而不是for(int i = 0 ;i&lt;=2;i++)。第一个直接就可以算出3-0 = 3 有三个数据，而后者 2-0+1个数据，多出1个加法运算，很恼火。 <br><br><br>","like_count":5,"discussions":[{"author":{"id":1758307,"avatar":"","nickname":"韩方兴","note":"","ucode":"3C02DC65F3BB83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214568,"discussion_content":"这个都要做 4 次判断，而不是你理解的那样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585208789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29410,"user_name":"莫弹弹","can_delete":false,"product_type":"c1","uid":1239978,"ip_address":"","ucode":"60A25C709A665F","user_header":"https://static001.geekbang.org/account/avatar/00/12/eb/aa/db213a66.jpg","comment_is_top":false,"comment_ctime":1538365338,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23013201818","product_id":100017301,"comment_content":"1， 数组越界导致无限循环，会因为编译器不一样而出现不一样的结果，不会说必然无限循环；并且声明的顺序应该是<br>int [] arr;<br>int i;<br>这样更大概率让数组越界一位后命中变量i，把i放前面基本不会被命中。<br>至于为什么越界后会命中i，这个是c语言基础，不懂的同学可以看看c语言关于数组的内存分配说明。<br><br>2， 标记清除法应该是需要借助容器类实现，单纯的基本类型数组并不能产生标记行为或者属性；<br>也就是说，<br>可能需要分配一个额外的数组记录当前数据数组的数据元素是否被删除<br>可能需要把数组元素进行包装，添加一个属性用来标记这个元素是否被删除<br>当数组标记足够多，数组空闲元素不多的时候，就需要对数组进行真正的删除，这个真正的删除过程称为碎片整理，也就是jvm的gc了，非常消耗性能，所以JAVA里有个优化策略叫减少gc次数。<br><br>个人理解，欢迎指正","like_count":5},{"had_liked":false,"id":104408,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1560746971,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18740616155","product_id":100017301,"comment_content":"算法_005<br># 作业：<br>1. JVM标记清除垃圾回收算法<br>根据今天的思路，又去查了一下，可分为两个阶段：<br>- 标记阶段：标记所有可达到对象<br>- 清除阶段：清除所有未被标记的对象<br><br>2. 二位数组的内存寻址公式<br>二位数组在我们直观的理解中是矩阵形式的，可在物理性的内存中也是线性的连续存储空间。<br><br>用一个例子推导：<br>arr[3][3]<br>我们的直观理解：<br>1 2 3<br>4 5 6<br>7 8 9<br>内存中的时机排列：<br>1 2 3 4 5 6 7 8 9<br><br>data_addres(arr[i][j]) = base_address + (i * line_length + j) * data_type_size;<br><br># 内容：<br>- 数组：内存连续、线性表<br>- 数组特点：随机访问效率高、插入&#47;删除效率低。<br>- 数组与集合的选择：开发效率和运行效率的取舍。<br><br># 感受：<br>数组的关键词就是内存连续、线性表。只是记住这两点还不够，数组这种结构，之所以这么设计，是因为它满足了某些应用场景的事物关系，正是由于内存连续的这一原理，也造成了它的优点与缺点(随机访问效率高，插入&#47;删除效率低)。<br><br>魔鬼在细节里，比如今天的内容中那个arr[3]与i指向相同内存地址的问题，刚听到的时候觉得不对，认真看了两遍，感觉是地址分配的问题，果断查看评论区，发现高手们已经有各种解释了，以后每篇的评论区都要刷了。","like_count":4},{"had_liked":false,"id":92084,"user_name":"某小浩","can_delete":false,"product_type":"c1","uid":1511556,"ip_address":"","ucode":"F0A65F516B17BB","user_header":"","comment_is_top":false,"comment_ctime":1557187482,"is_pvip":false,"replies":[{"id":"33018","content":"你的疑问很典型，前端的同学请看我写的这篇文章：<br>详解数据结构中的“数组”与编程语言中的“数组”的区别和联系<br>https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;E-c41h2v_AfffrlAQpkyLg","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1557228246,"ip_address":"","comment_id":92084,"utype":1}],"discussion_count":3,"race_medal":0,"score":"18737056666","product_id":100017301,"comment_content":"关于数组这里定义的描述有点疑惑，在javascript中，因为其弱语言特性，并没有限制数组中的存放的数据类型是一致的，所以这里的javascript中的数组是不是和本身数组的约束有冲突？<br>或者说相同数据类型并不是数组的绝对条件？<br>所以按照寻址来计算也不能简单的用老师给的公式，如果对于可以混合存放类型的数组结构，每个元素的寻址必须依赖前一个元素的写法是不是更合理？","like_count":4,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449140,"discussion_content":"你的疑问很典型，前端的同学请看我写的这篇文章：\n详解数据结构中的“数组”与编程语言中的“数组”的区别和联系\nhttps://mp.weixin.qq.com/s/E-c41h2v_AfffrlAQpkyLg","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557228246,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1461520,"avatar":"https://static001.geekbang.org/account/avatar/00/16/4d/10/5c9bc771.jpg","nickname":"懒懒想睡觉","note":"","ucode":"3979C31A90B504","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":139960,"discussion_content":"其实只要知道很多编程语言中的数组被二次改造过就行了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579334931,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1624016,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLOWucpCLACCYJic5IicKuo9RVSoFsEId2sazOqhnvSUSFztH8vu8skYkIwxgkXpOqmHjTprFWF1GmA/132","nickname":"jyzhang","note":"","ucode":"1311666BD87B86","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":129652,"discussion_content":"老师这篇文章中各个语言对比和图例都很好，但是对js还是讲的太少了，一笔带过，建议参考这篇文章详细了解js内存相关知识https://juejin.im/entry/59ae664d518825244d207196","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578723690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":65953,"user_name":"kim","can_delete":false,"product_type":"c1","uid":1193203,"ip_address":"","ucode":"D839AE8BD4520B","user_header":"https://static001.geekbang.org/account/avatar/00/12/34/f3/37264433.jpg","comment_is_top":false,"comment_ctime":1549796850,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"18729666034","product_id":100017301,"comment_content":"老师，文中提到&quot;如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 O(1)。&quot; 这里需要重新申请空间才行吧，因为数组内存空间是固定大小的，插入就需要重新申请空间，复制数据，所以我觉得应该是O（n)吧","like_count":4,"discussions":[{"author":{"id":1897816,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/f5/58/5c9ba9aa.jpg","nickname":"卢克糖","note":"","ucode":"8F3B1D8C2A1423","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369589,"discussion_content":"即便是扩充数组，均摊时间复杂度也是O(1)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619087494,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1689365,"avatar":"https://static001.geekbang.org/account/avatar/00/19/c7/15/24bf166a.jpg","nickname":"pikachu122","note":"","ucode":"43FE4DBC872FFA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":109274,"discussion_content":"老师说的数组末尾应该是在没有填满的数组中最后一个元素后面添加一个元素，不是指已经被填满的数组。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577679459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36026,"user_name":"顾骨","can_delete":false,"product_type":"c1","uid":1131165,"ip_address":"","ucode":"3F6BA592AB7723","user_header":"https://static001.geekbang.org/account/avatar/00/11/42/9d/c36b7ef7.jpg","comment_is_top":false,"comment_ctime":1540897656,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"18720766840","product_id":100017301,"comment_content":"无限循环的很有意思：   <br>0x0000000000400574 &lt;+8&gt;:     movq   $0x0,-0x10(%rbp)<br>0x000000000040057c &lt;+16&gt;:    movl   $0x0,-0x8(%rbp)<br>0x0000000000400583 &lt;+23&gt;:    movl   $0x0,-0x4(%rbp)<br>a[0]的地址是-0x10(%rbp)<br>a[1]的地址是-0xc(%rbp)<br>a[2]的地址是-0x8(%rbp)<br>i的地址是-0x4(%rbp)<br>按照数组内存连续的原则，那么a[3]的地址就是-0x4(%rbp)，和i的地址重合了，i又重新变为0了。<br>这个和缓冲区溢出攻击是同一个道理，有意思<br><br>","like_count":4,"discussions":[{"author":{"id":1256428,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2b/ec/af6d0b10.jpg","nickname":"caohuan","note":"","ucode":"4B092E33F3DF1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":186771,"discussion_content":"很直观的无限循环","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582712766,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33109,"user_name":"大师兄_于硕","can_delete":false,"product_type":"c1","uid":1212845,"ip_address":"","ucode":"62DA927A8C0617","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/ad/7d1a3422.jpg","comment_is_top":false,"comment_ctime":1539745523,"is_pvip":false,"replies":[{"id":"12049","content":"也可以的 你说的没错👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539788267,"ip_address":"","comment_id":33109,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18719614707","product_id":100017301,"comment_content":"老师您好，关于数组删除小节有问题希望您解答一下。<br>数组删除a b c如何进行标记已删除（不进行其他数据的搬移）？<br>为什么不像前面cha入操作一样，把最后的元素覆盖到前面要删除的元素，类似于上一节插入那样，时间复杂度应该也是O(1)","like_count":4,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426935,"discussion_content":"也可以的 你说的没错👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539788267,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29439,"user_name":"途","can_delete":false,"product_type":"c1","uid":1178240,"ip_address":"","ucode":"7715FE183557FF","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/80/f8be387d.jpg","comment_is_top":false,"comment_ctime":1538373563,"is_pvip":false,"replies":[{"id":"10604","content":"👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538401358,"ip_address":"","comment_id":29439,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18718242747","product_id":100017301,"comment_content":"jvm标记清除算法顾名思义就是标记和清除，标记阶段其实就是和专栏中讲得标记删除有着异曲同工之妙，只不过jvm中标记的是保留对象而非辣鸡对象，清除阶段做的是真正的删除的操作","like_count":4,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425605,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538401358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":231116,"user_name":"Geek_93d0fd","can_delete":false,"product_type":"c1","uid":2050816,"ip_address":"","ucode":"11A478482829F8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIZILv4jZfYyGhDm0kMViaxy1tnnH7N3icnfPQZj6Y6ib0eopvCzvbFhz15BOcSQdkzaKMz9iab278Z1Q/132","comment_is_top":false,"comment_ctime":1593588305,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14478490193","product_id":100017301,"comment_content":"评论区一堆高手  来晚了<br>","like_count":3},{"had_liked":false,"id":139452,"user_name":"五月的雪","can_delete":false,"product_type":"c1","uid":1064673,"ip_address":"","ucode":"B2EBD28E8E9476","user_header":"https://static001.geekbang.org/account/avatar/00/10/3e/e1/58e78c7e.jpg","comment_is_top":false,"comment_ctime":1570639697,"is_pvip":false,"replies":[{"id":"53988","content":"这个要看具体的应用场景，你说的场景可能并不适合这么存储数据。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1570748316,"ip_address":"","comment_id":139452,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14455541585","product_id":100017301,"comment_content":"我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。<br>那查询的时候，根据寻址得到的结果不就是错误的吗？","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469952,"discussion_content":"这个要看具体的应用场景，你说的场景可能并不适合这么存储数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570748316,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":39199,"user_name":"我们都是大好青年🙌","can_delete":false,"product_type":"c1","uid":1294094,"ip_address":"","ucode":"E09F8E2F17C996","user_header":"https://static001.geekbang.org/account/avatar/00/13/bf/0e/eae05ad9.jpg","comment_is_top":false,"comment_ctime":1542208659,"is_pvip":false,"replies":[{"id":"14043","content":"👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542247098,"ip_address":"","comment_id":39199,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14427110547","product_id":100017301,"comment_content":"老师好，同学好，刚开始学习数据结构，我把我知道的也写在留言中，如果大家发现有不对的地方，热烈欢迎指导！<br>python也有垃圾回收机制，python通过对引用对象计数的方式，当某个对象的引用计数为0时，对该对象进行回收，并释放内存，暂时存放于python自带的内存池中，方便使用(pymolic)。<br>","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428961,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542247098,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2869118,"avatar":"","nickname":"Geek_73c432","note":"","ucode":"3E11EB02B14DE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580946,"discussion_content":"补充下，对于循环引用的情况，Python 还提供分代等其他算法。可以参数内置的 gc 模块","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658412080,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36770,"user_name":"李大飞","can_delete":false,"product_type":"c1","uid":1052889,"ip_address":"","ucode":"3264FA5EE734A6","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/d9/6d456c8e.jpg","comment_is_top":false,"comment_ctime":1541319098,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14426220986","product_id":100017301,"comment_content":"感谢王大大和评论区的大牛们。我越来越感受到这门课的刺激了，上一堂课中有个“数组会被清楚掉”和这节课的“无线循环”，我也第一次看到时也有些懵逼，但是我去思考了我去实践了，让我更多的去思考去实践了，自己动手也做了，去百度点C语言的语法，理解后才发现与评论区的大牛想法是如此的接近，很有成就感！感谢王大大输出这么高质量的课程。GoGoGo...","like_count":3},{"had_liked":false,"id":31655,"user_name":"追风者","can_delete":false,"product_type":"c1","uid":1055092,"ip_address":"","ucode":"879BC372A6B605","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIjUDIRQ0gRiciax3Wo78c5rVjuWDiaw4ibcCiby8xiaMXJh5ibjU5242vfCGOK4ehibe1IKyxex2A4IX4XSA/132","comment_is_top":false,"comment_ctime":1539254930,"is_pvip":false,"replies":[{"id":"11373","content":"正确","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539255527,"ip_address":"","comment_id":31655,"utype":1}],"discussion_count":3,"race_medal":0,"score":"14424156818","product_id":100017301,"comment_content":"关于插入情况的平均情况时间复杂度为 (1+2+…n)&#47;n=O(n)。我的理解是：<br>在第1元素插入，需要向后移动n个元素；<br>在第2元素插入，需要向后移动n-1个元素；<br>。。。<br>在第倒数第2个元素插入，需要向后移动2个元素；<br>在第倒数第1个元素插入，需要向后移动1个元素；<br>末尾追加，直接插入，不需要移动元素。<br> 所以平均时间复杂度就是(n+n-1+...+2+1+0)&#47;n，也就是(1+2+…n)&#47;n=O(n).<br>不知道这样理解是否正确？","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426452,"discussion_content":"正确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539255527,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1322487,"avatar":"https://static001.geekbang.org/account/avatar/00/14/2d/f7/d5c23b53.jpg","nickname":"这一章，姑且叫蛰伏吧","note":"","ucode":"BA2E8130F8E88E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571521,"discussion_content":"我也正困惑呢，这下清晰了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652256143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1178136,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fa/18/710018cb.jpg","nickname":"飞翔明天","note":"","ucode":"F2E6FEAC77070B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340021,"discussion_content":"我正好不理解，谢了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609864573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31196,"user_name":"coder","can_delete":false,"product_type":"c1","uid":1020749,"ip_address":"","ucode":"A65DB1CB1B15D3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/93/4d/84200fe1.jpg","comment_is_top":false,"comment_ctime":1539131368,"is_pvip":false,"replies":[{"id":"11229","content":"意思是数组也是。数组和链表直接是逗号。其他三个直接是顿号","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539135361,"ip_address":"","comment_id":31196,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14424033256","product_id":100017301,"comment_content":"“其实除了数组，链表、队列、栈等也是线性表结构。”<br>—- &#47;&#47;<br>这里“除了”是不是要去掉？<br><br>","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426256,"discussion_content":"意思是数组也是。数组和链表直接是逗号。其他三个直接是顿号","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539135361,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30498,"user_name":"王虹凯","can_delete":false,"product_type":"c1","uid":1018862,"ip_address":"","ucode":"CA01E64E125CFF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8b/ee/56823fd7.jpg","comment_is_top":false,"comment_ctime":1538892468,"is_pvip":false,"replies":[{"id":"11034","content":"查一查 搞清楚之后 欢迎发到留言区 给其他小伙伴也看看","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538959625,"ip_address":"","comment_id":30498,"utype":1}],"discussion_count":3,"race_medal":0,"score":"14423794356","product_id":100017301,"comment_content":"为什么容器类型不支持原始类型？flag,回去查一下","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426024,"discussion_content":"查一查 搞清楚之后 欢迎发到留言区 给其他小伙伴也看看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538959625,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1114093,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ff/ed/b2fc0e7c.jpg","nickname":"7","note":"","ucode":"10A6E57A027D42","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":221836,"discussion_content":"java编程思想说：如果指定了特定的类型，则容器就无法成为一个“常规用途”的工具。集合实际容纳的是类型为Object的一些对象的句柄（也就是Object的对象）；\n所以容器只能存放对象，而基础数据类型不属于对象。所以不支持。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586069810,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1194982,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3b/e6/86ae0cd9.jpg","nickname":"满场飞奔","note":"","ucode":"5F8F4238BC93C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":63953,"discussion_content":"感觉像是Java本身的设计原因,容器需要对象,而基本类型是对象(Object),虽然有自动装箱的存在,但还是会有一定的性能消耗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574925224,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29884,"user_name":"杨伟","can_delete":false,"product_type":"c1","uid":1239937,"ip_address":"","ucode":"D5B521A0688E02","user_header":"https://static001.geekbang.org/account/avatar/00/12/eb/81/43f4b52c.jpg","comment_is_top":false,"comment_ctime":1538579690,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14423481578","product_id":100017301,"comment_content":"#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;string.h&gt;<br><br>struct array {<br>\tint size;<br>\tint used;<br>\tint *arr;<br>};<br><br>void dump(struct array *array)<br>{<br>\tint idx;<br>\t<br>\tfor (idx = 0; idx &lt; array-&gt;used; idx++)<br>\t\tprintf(&quot;[%02d]: %08d\\n&quot;, idx, array-&gt;arr[idx]);<br>}<br><br>void alloc(struct array *array)<br>{<br>\tarray-&gt;arr = (int *)malloc(array-&gt;size * sizeof(int));<br>}<br><br>int insert(struct array *array, int elem)<br>{<br>\tint idx;<br>\tif (array-&gt;used &gt;= array-&gt;size)<br>\t\treturn -1;<br><br>\tfor (idx = 0; idx &lt; array-&gt;used; idx++) {<br>\t\tif (array-&gt;arr[idx] &gt; elem)<br>\t\t\tbreak;<br>\t}<br><br>\tif (idx &lt; array-&gt;used)<br>\t\tmemmove(&amp;array-&gt;arr[array-&gt;used], &amp;array-&gt;arr[idx],<br>\t\t\t(array-&gt;used - idx) * sizeof(int));<br><br>\tarray-&gt;arr[idx] = elem;<br>\tarray-&gt;used++;<br>\treturn idx;<br>}<br><br>int delete(struct array *array, int idx)<br>{<br>\tif (idx &lt; 0 || idx &gt;= array-&gt;used)<br>\t\treturn -1;<br><br>\tmemmove(&amp;array-&gt;arr[idx], &amp;array-&gt;arr[idx+1], <br>\t\t(array-&gt;used - idx) * sizeof(int));<br>\tarray-&gt;used--;<br>\treturn 0;<br>}<br><br>int search(struct array *array, int elem)<br>{<br>\tint idx;<br><br>\tfor (idx = 0; idx &lt; array-&gt;used; idx++) {<br>\t\tif (array-&gt;arr[idx] == elem)<br>\t\t\treturn idx;<br>\t\tif (array-&gt;arr[idx] &gt; elem)<br>\t\t\treturn -1;<br>\t}<br><br>\treturn -1;<br>}<br><br>int main()<br>{<br>\tint idx;<br>\tstruct array ten_int = {10, 0, NULL};<br><br>\talloc(&amp;ten_int);<br>\tif (!ten_int.arr)<br>\t\treturn -1;<br>\tinsert(&amp;ten_int, 1);<br>\tinsert(&amp;ten_int, 3);<br>\tinsert(&amp;ten_int, 2);<br>\tprintf(&quot;=== insert 1, 3, 2\\n&quot;);<br>\tdump(&amp;ten_int);<br><br>\tidx = search(&amp;ten_int, 2);<br>\tprintf(&quot;2 is at position %d\\n&quot;, idx);<br>\tidx = search(&amp;ten_int, 9);<br>\tprintf(&quot;9 is at position %d\\n&quot;, idx);<br><br>\tprintf(&quot;=== delete [6] element \\n&quot;);<br>\tdelete(&amp;ten_int, 6);<br>\tdump(&amp;ten_int);<br>\tprintf(&quot;=== delete [0] element \\n&quot;);<br>\tdelete(&amp;ten_int, 0);<br>\tdump(&amp;ten_int);<br>\treturn 0;<br>}","like_count":3},{"had_liked":false,"id":29618,"user_name":"梦其不可梦","can_delete":false,"product_type":"c1","uid":1241487,"ip_address":"","ucode":"145C43CB072C88","user_header":"https://static001.geekbang.org/account/avatar/00/12/f1/8f/b3273afe.jpg","comment_is_top":false,"comment_ctime":1538455541,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14423357429","product_id":100017301,"comment_content":"老师，我有一个疑问:<br>用记录的方式记录一下删除了的数据，这不就破坏了数组的随机访问特性吗？","like_count":3},{"had_liked":false,"id":29310,"user_name":"良辰美景","can_delete":false,"product_type":"c1","uid":1074803,"ip_address":"","ucode":"B36E6955A2872D","user_header":"https://static001.geekbang.org/account/avatar/00/10/66/73/fd1e37a2.jpg","comment_is_top":false,"comment_ctime":1538349611,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14423251499","product_id":100017301,"comment_content":"二维数组就是数组中的数组咯。所以寻址做两次就好。先算出一维数组的空间地址。然后在将算出的地址作为baseadder算二维的地址","like_count":3},{"had_liked":false,"id":181251,"user_name":"小肥羊","can_delete":false,"product_type":"c1","uid":1081582,"ip_address":"","ucode":"9F44BAA1A59FAD","user_header":"https://static001.geekbang.org/account/avatar/00/10/80/ee/bbee3ec1.jpg","comment_is_top":false,"comment_ctime":1582527457,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10172462049","product_id":100017301,"comment_content":"之前看不懂的，再看一遍，豁然开朗，这是个值得反复品的好专栏。另外，老师那个今天看不懂，不代表失败的想法真的受教。","like_count":2},{"had_liked":false,"id":150802,"user_name":"eviltion","can_delete":false,"product_type":"c1","uid":1515445,"ip_address":"","ucode":"022DE8510B825E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/mWicFKgbjL299CQPEhoFdSAphVb4UpibkhF8loRxryBRt3H7ZGkibibhaKANTxvSiatic4PLCy2MsbEMH1hc76YefPUw/132","comment_is_top":false,"comment_ctime":1573611722,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10163546314","product_id":100017301,"comment_content":"光看评论里就能增长很多知识啊。。。<br>","like_count":2},{"had_liked":false,"id":106979,"user_name":"cjxz","can_delete":false,"product_type":"c1","uid":1588610,"ip_address":"","ucode":"9735F51D4721E9","user_header":"","comment_is_top":false,"comment_ctime":1561430888,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10151365480","product_id":100017301,"comment_content":"1.标记清除算法：为了减少垃圾回收器来回执行次数，将需要回收的内存进行标记，在一定的时候进行统一回收，针对这种回收算法会产生大量的碎片内存又产生了复制标记清除算法。首先是将内存一份为二，然后只是用一边的内存空间，将需要清除的内存进行标记，一次性将为回收的内存复制到另一边，然后当前使用的这边的数据直接一次性清空。<br>2.二维数组的寻址公式应该有两种，看是按行存储还是按列存储。假设二维数组为a[n][m]<br>按行存储：address=base_address+i*m*base_type_size+j*base_type_size<br>按列存储：address=base_address+j*m*base_type_size+i*base_type_size","like_count":2},{"had_liked":false,"id":95978,"user_name":"ANTIPE","can_delete":false,"product_type":"c1","uid":1446155,"ip_address":"","ucode":"0BC6609DB877F8","user_header":"https://static001.geekbang.org/account/avatar/00/16/11/0b/433b5fe8.jpg","comment_is_top":false,"comment_ctime":1558282610,"is_pvip":false,"replies":[{"id":"34383","content":"你可以看下这篇文章的解释：<br>详解数据结构中的“数组”与编程语言中的“数组”的区别和联系<br>https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;E-c41h2v_AfffrlAQpkyLg","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1558338741,"ip_address":"","comment_id":95978,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10148217202","product_id":100017301,"comment_content":"老师我有个问题，对于每个元素size不固定的对象数组（比如Java中的String[]）它是怎么实现随机访问的？","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450666,"discussion_content":"你可以看下这篇文章的解释：\n详解数据结构中的“数组”与编程语言中的“数组”的区别和联系\nhttps://mp.weixin.qq.com/s/E-c41h2v_AfffrlAQpkyLg","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558338741,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1388940,"avatar":"","nickname":"落叶有义","note":"","ucode":"12673608190E55","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342778,"discussion_content":"java对象数组都是引用（指针）数组，所以string[]里面存放的是引用，长度是固定的大小32位，所以String s = string[2]是把第三个string对象的引用赋值给s","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610807612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1178136,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fa/18/710018cb.jpg","nickname":"飞翔明天","note":"","ucode":"F2E6FEAC77070B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340026,"discussion_content":"很棒的问题，又可以扩展知识了，谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609864969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90931,"user_name":"犇","can_delete":false,"product_type":"c1","uid":1241705,"ip_address":"","ucode":"CCA66C9BF3EBAB","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/69/a925db7a.jpg","comment_is_top":false,"comment_ctime":1556732993,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10146667585","product_id":100017301,"comment_content":"作为一个小白，具体答案就不发了，给像我一样的小白发一个思路，在查资料的时候看了一些不必要的资料我就不说了。首先，去看阮一峰博客里对汇编入门的介绍，些有助于你理解堆栈结构，然后再百度一下数组在栈里是怎样存的，我搜索的关键字是java和高地址，低地址。这样你就基本可以明白为什么死循环了。再然后，又去知乎看了java虚拟机的堆，栈，堆栈如何去理解。最后又看了深入理解java虚拟机关于gc回收算法的介绍的那部分。然后就可以对这个章节有比较好的认识了。这些都是理论的东西，还是要敲代码。。","like_count":2},{"had_liked":false,"id":53676,"user_name":"不专注的linuxer","can_delete":false,"product_type":"c1","uid":1050191,"ip_address":"","ucode":"28ED11C1E2942C","user_header":"https://static001.geekbang.org/account/avatar/00/10/06/4f/14cc4b53.jpg","comment_is_top":false,"comment_ctime":1545708771,"is_pvip":false,"replies":[{"id":"19664","content":"写法问题 都一样","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545826737,"ip_address":"","comment_id":53676,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10135643363","product_id":100017301,"comment_content":"话说，老师你写for循环的时候，变量i为什么老在for循环外定义，为什么不是for(int i = 0; i &lt; 10; i++)，有什么好处么，先定义循环用到的变量","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434218,"discussion_content":"写法问题 都一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545826737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":40843,"user_name":"对方正在输入","can_delete":false,"product_type":"c1","uid":1257515,"ip_address":"","ucode":"57C3A444E33832","user_header":"https://static001.geekbang.org/account/avatar/00/13/30/2b/bc5873c6.jpg","comment_is_top":false,"comment_ctime":1542681124,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10132615716","product_id":100017301,"comment_content":"1.ArrayList中实际存放的只是对象的引用,每个集合元素都是一个引用变量，实际内容都放在堆内存或者方法区里面，但是基本数据类型是在栈内存上分配空间的，栈上的数据随时就会被收回的。<br><br>2. 比如 int,float...  是基本数据类型,在具体的内存分配上<br>对象是放在堆里的，基本数据类型是放在栈里的，看看容器的具体实现，你就能更理解为什么ArrayList只能存放引用类型了<br><br><br>","like_count":2,"discussions":[{"author":{"id":1388940,"avatar":"","nickname":"落叶有义","note":"","ucode":"12673608190E55","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342779,"discussion_content":"new int[10]也是在堆里分配呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610807918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34154,"user_name":"高源","can_delete":false,"product_type":"c1","uid":1048887,"ip_address":"","ucode":"751B41FD38EF7D","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/37/12e4c9c9.jpg","comment_is_top":false,"comment_ctime":1540023747,"is_pvip":false,"replies":[{"id":"12192","content":"这个跟你高中学数学一样的，理论老师都交了给你。但是，考试中的题目你并不一定能联想到老师讲过的解法。这之间需要你多练、多思考、多总结，才能见到题目就想到对应的解法。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540047790,"ip_address":"","comment_id":34154,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10129958339","product_id":100017301,"comment_content":"请问老师学习数据结构算法的使用技巧，如何能够灵活应用，解决实际问题，在现实中遇到问题有时候不一定能马上知道用哪种方法解决，例如中国象棋我知道肯定要用算法解决，算法好坏决定你的难度，但是我不知道是用哪个现成算法，还是自己写新算法","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427136,"discussion_content":"这个跟你高中学数学一样的，理论老师都交了给你。但是，考试中的题目你并不一定能联想到老师讲过的解法。这之间需要你多练、多思考、多总结，才能见到题目就想到对应的解法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540047790,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32509,"user_name":"史帅","can_delete":false,"product_type":"c1","uid":1252096,"ip_address":"","ucode":"11429A8D082395","user_header":"https://static001.geekbang.org/account/avatar/00/13/1b/00/aef3202e.jpg","comment_is_top":false,"comment_ctime":1539595449,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10129530041","product_id":100017301,"comment_content":"老师，在java中的二维数组中，第一维度数组是必须要指定长度，第二维度数组在声明时非必须，即：二维数组在声明时并不一定初始化；而且在idea中使用DEBUG模式，第二维度的数组的内存地址，跟第一维度的内存地址并没有必然联系。在置顶的留言中address = base_address + ( i * n + j) * type_size这个公式至少是不适合于Java的。","like_count":2},{"had_liked":false,"id":30952,"user_name":"行走着的宋公子","can_delete":false,"product_type":"c1","uid":1002416,"ip_address":"","ucode":"3FA47B1580A327","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4b/b0/2ae78627.jpg","comment_is_top":false,"comment_ctime":1539052046,"is_pvip":false,"replies":[{"id":"11177","content":"对","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539083135,"ip_address":"","comment_id":30952,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10128986638","product_id":100017301,"comment_content":"m×n二维数组 a[i][j] 地址 ＝base + （i × n + j）×type_size","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426156,"discussion_content":"对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539083135,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1014984,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7c/c8/8627f5c1.jpg","nickname":"右耳朵猫咪","note":"","ucode":"3AB186CC780FBB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341770,"discussion_content":"请问是怎么计算的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610519663,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29292,"user_name":"张初炼","can_delete":false,"product_type":"c1","uid":1023546,"ip_address":"","ucode":"FED261D077DC8F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9e/3a/7d70960c.jpg","comment_is_top":false,"comment_ctime":1538327194,"is_pvip":false,"replies":[{"id":"10633","content":"能详细讲讲 base address - type size 只需要计算一次这块的理由吗","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538407786,"ip_address":"","comment_id":29292,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10128261786","product_id":100017301,"comment_content":"老师有个问题想问一下，假如数组下标从 1 开始：<br>a[k]_address = base_address + (k-1)*type_size = (base_address - type_size) + k*type_size。虽然 base_address 在编译时不确定，可加载程序时就知道了，因此 (base_address - type_size) 只需要计算一次，前半部分就可以认为是“常数”。这样来看，数组下标从 1 开始带来的“性能消耗”其实是可以避免的。","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425541,"discussion_content":"能详细讲讲 base address - type size 只需要计算一次这块的理由吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538407786,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312202,"user_name":"大葡萄王","can_delete":false,"product_type":"c1","uid":1890053,"ip_address":"","ucode":"0BD97442AFC79A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/MWs6nBSHJBC5O85iaic2ibtW5ic86sSURTSraQJ8Pz5rEdUowdtVf6ZxciaKyibIDoJV9VA82p1uMkZRib0VX9iaTJxUvw/132","comment_is_top":false,"comment_ctime":1631681515,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5926648811","product_id":100017301,"comment_content":"关于无限循环示例：<br>1.函数体内部的变量是在栈空间存储的，而栈空间是先定义的变量在高地址，后定义的变量在低地址，且是连续的。如果使用文中的编译器，那么i在高地址例如0xaacc，arr在低地址位如0xaac0。那么arr[0]地址0xaac0、arr[1]地址0xaac4、arr[2]地址0xaac8。产生越界的数组就是arr[3]地址0xaacc刚好为变量i。<br>2.这是使用linux的gcc编译器才有可能的结果，如果是其他编译器，大概率会对数据的越界问题做优化，比如在数组最后一个元素之后用一个元素类型的长度做填充。这样在arr[4]的时候才会产生循环。<br>3.如果i不是int，要考虑内存对齐保证值的大小，如果不是4，此处也不会死循环<br>4.数组在栈空间中是，先申请一段对应大小的空间，然后在这段空间上按照index0-n的顺序从低地址空间存到高地址空间。所以才会存在arr[3]越界<br>5.此处越界与大小端模式无关，因为大小端模式是对变量内部的字节序列的限制，变量之间都是从低地址往高地址读取。<br>这是我个人理解，望老师解答。","like_count":1},{"had_liked":false,"id":274180,"user_name":"CQ","can_delete":false,"product_type":"c1","uid":2067365,"ip_address":"","ucode":"F4899EEBE3CD8D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/8b/a5/4598dc7b.jpg","comment_is_top":false,"comment_ctime":1610892283,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5905859579","product_id":100017301,"comment_content":"1、JVM对新生代、老年代有不同的垃圾回收算法。新生代是复制算法，老年代是标记整理和标记清除算法。<br>2、m * n 的数组二维数组，a [ i ][ j ] (i &lt; m,j &lt; n)的地址为address = base_address + ( i * n + j) * type_size。","like_count":1},{"had_liked":false,"id":213698,"user_name":"iris","can_delete":false,"product_type":"c1","uid":1986106,"ip_address":"","ucode":"8D54D1DBEA6F64","user_header":"https://static001.geekbang.org/account/avatar/00/1e/4e/3a/1932100c.jpg","comment_is_top":false,"comment_ctime":1588516233,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5883483529","product_id":100017301,"comment_content":"JVM标记清除算法：分为标记和清除。先标记，待内存满了将所有标记的删掉。<br>二维数组内存寻址：a[i,j]=i*行大小+j*单位内存大小<br>本篇收获：<br>1、从0作为下标开始是因为计算的是偏移量，后来再有的语言沿承c语言习惯<br>2、无限循环打印的那段代码思考了一下get了<br>3、警惕数组越界问题。<br>有很多语言里面具有容器这种存储，封装了很多数组的细节性操作，能有效防止数组越界的错误。<br>但例如Java的ArrayList 最好是预先设定数组大小，否则每次存满时他会自动重新申请1.5倍空间去复制当前内容再插入相应数据，这涉及到申请和复制的操作很耗时。<br>4、数组适合用底层编码，效率更高。正常的业务开发适合使用容器更加易于操作","like_count":1},{"had_liked":false,"id":212857,"user_name":"Bomb","can_delete":false,"product_type":"c1","uid":1245456,"ip_address":"","ucode":"C1A346D48EA215","user_header":"https://static001.geekbang.org/account/avatar/00/13/01/10/5d188111.jpg","comment_is_top":false,"comment_ctime":1588226588,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5883193884","product_id":100017301,"comment_content":"数组无限循环问题<br>我用dev测试了。其实不管把数组位数设置成多少都会无限循环。只要把i设置成double型就不会这样了，因为浮点数的存放格式跟整型还是不一样的，所以后两字节即使全部置0也不会影响i的值。<br>总的来说这个问题跟之前留言里说的字节对齐无关，只是因为栈的存放顺序是从高位到低位而已。","like_count":1},{"had_liked":false,"id":193031,"user_name":"Geek_31036c","can_delete":false,"product_type":"c1","uid":1902203,"ip_address":"","ucode":"C1EF8A0C0C7055","user_header":"","comment_is_top":false,"comment_ctime":1584882720,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879850016","product_id":100017301,"comment_content":"我看很少朋友提到新生代，老生代的问题，综合其他朋友的一些讲解，这里补充一下JVM主要的垃圾回收算法，希望能够抛砖引玉。<br>分代收集算法（针对JDK1.8以下）：<br>根据对象的存活周期分为老年代，新生代，永久代<br>a、在新生代中，每次GC时都发现有大批对象死去，只有少量存活，使用复制算法。即在垃圾回收时，将正在使用的内存中存活对象复制到另一块未使用的内存中。之后清理正在使用的内存中所有对象，交换两块内存角色。反复进行，完成垃圾回收。<br>b、在老年代中，因为对象存活率高、没有额外空间对他进行分配担保，使用“标记-清理”&#47;“标记-整理”算法。即在标记阶段，遍历所有的GC Roots，然后将所有GC Roots可达的对象标记为存活的对象。清除阶段，清除的过程将遍历堆中所有的对象，将没有标记的对象全部清除掉。<br>c、永久代（Permanet Generation）&#47; 元空间（Metaspace）<br>永久代用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。是JVM规范中方法区的具体实现。<br>是Hotspot虚拟机特有的概念，方法区&#47;永久代是非堆内存。<br><br>第二个问题：<br>对于 m * n 的数组，a [ i ][ j ] (i &lt; m,j &lt; n)的地址。<br>因为数据的内存地址是线性的，相当于在二维坐标图中找第i行第j列的元素地址，找到第i行的首地址i*n的第j个元素即为a [ i ][ j ] 地址<br>即address = base_address + ( i * n + j) * type_size","like_count":1},{"had_liked":false,"id":156197,"user_name":"ゞ 正在缓冲99%","can_delete":false,"product_type":"c1","uid":1754145,"ip_address":"","ucode":"4DF9E56006E5C5","user_header":"https://static001.geekbang.org/account/avatar/00/1a/c4/21/ef3e5cb0.jpg","comment_is_top":false,"comment_ctime":1574833381,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869800677","product_id":100017301,"comment_content":"二维数组a[m][n]的寻址公式a[j][k]=&amp;a[0][0]+（n*j+k）*tape_size","like_count":1},{"had_liked":false,"id":154797,"user_name":"NEVER SETTLE","can_delete":false,"product_type":"c1","uid":1101894,"ip_address":"","ucode":"9C86BDAFDBF768","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/46/1a9229b3.jpg","comment_is_top":false,"comment_ctime":1574567460,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869534756","product_id":100017301,"comment_content":"1、线性表<br>数据排列成结构，数据最多只有前和后两个方向。<br>如：数组，链表、队列、栈。<br><br>2、非线性表<br>数据之间并不是简单的前后关系。<br>如：二叉树、堆、图。<br><br>3、数组<br>数组（Array）是一种线性表数据结构。<br>它用一组连续的内存空间，来存储一组具有相同类型的数据。<br><br>4、数组是如何实现根据下标随机访问数组元素？<br>数组是连续的内存空间和相同类型的数据。<br>计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。<br>当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：a[i]_address = base_address + i * data_type_size<br>其中 data_type_size 表示数组中每个元素的大小。<br>比如，数组中存储的是 int 类型数据，所以 data_type_size 就为 4 个字节。<br><br>5、“链表适合插入、删除，时间复杂度 O(1)；数组适合查找，查找时间复杂度为 O(1)？”<br>这种表述是不准确的。<br>数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。<br>即便是排好序的数组，用二分查找，时间复杂度也是 O(logn)。<br>正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。<br><br>6、数组低效的“插入”<br>数组为了保持内存数据的连续性，会导致插入、删除这两个操作比较低效。<br>需要将一个数据插入到长度为n的数组中的第 k 个位置。<br>为了把第 k 个位置腾出来，需要将第 k～n 这部分的元素都顺序地往后挪一位。<br><br>在数组的末尾插入元素，不需要移动数据了，最坏时间复杂度为 O(1)。<br>在数组的开头插入元素，所有的数据都需要依次往后移动一位，最坏时间复杂度是 O(n)。<br>在每个位置插入元素的概率是一样的，平均情况时间复杂度为 (1+2+…n)&#47;n=O(n)。<br><br>8、特定场景下的高效“插入”<br>如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。<br>在这种情况下，如果要将某个数组插入到第 k 个位置，为了避免大规模的数据搬移，可以直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。<br>时间复杂度就会降为 O(1)。<br><br>8、数组低效的“删除”<br>删除第 k 个位置的数据，为了内存的连续性，也需要搬移数据，不然内存就不连续。<br>删除数组末尾的数据，最好情况时间复杂度为 O(1)；<br>删除数组开头的数据，最坏情况时间复杂度为 O(n)；<br>平均情况时间复杂度为 O(n)。<br><br>9、特定场景下的高效“删除”<br>可以将多次删除操作集中在一起执行，效率会提高很多。<br>为了避免数据多次搬移，以先记录下已经删除的数据。<br>每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。<br>当数组没有更多空间存储数据时，再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。<br>JVM 标记清除垃圾回收算法的核心思想<br><br>10、警惕数组的访问越界问题<br>在 C 语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。<br>数组越界在 C 语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。<br>因为，访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。<br>所以写代码的时候一定要警惕数组越界，一定要做越界检查。<br><br>11、容器能否完全替代数组？<br>C++ STL 中的 vector将很多数组操作的细节封装起来，并且支持动态扩容。<br><br>数组本身在定义的时候需要预先指定大小，因为需要分配连续的内存空间。<br>如果申请了大小为 10 的数组，当第 11 个数据需要存储到数组中时，就需要重新分配一块更大的空间，将原来的数据复制过去，然后再将新的数据插入。<br>注意：扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好在创建 vector 就先指定数据大小。<br><br>对于业务开发，直接使用容器。<br>底层的开发，比如开发网络框架，数组的性能优于容器，成为首选。<br>","like_count":1},{"had_liked":false,"id":151019,"user_name":"Amosヾ","can_delete":false,"product_type":"c1","uid":1567014,"ip_address":"","ucode":"833F6FCB4042AD","user_header":"https://static001.geekbang.org/account/avatar/00/17/e9/26/afc08398.jpg","comment_is_top":false,"comment_ctime":1573643808,"is_pvip":true,"discussion_count":3,"race_medal":1,"score":"5868611104","product_id":100017301,"comment_content":"数组 a[10] 中存储了 8 个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除 a，b，c 三个元素。为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。<br><br>老师，我比较疑问的是：起初只有a b c d e f g h然后删除a b c但不搬移d e f g h，后面还可以存储2个，假如存储i j那么就存储满了，数组中没有更多存储空间用来存储数据了，执行一次删除操作，那么d e f g h i j岂不是都需要往前移动3个位置？这不是增加了数据的迁移吗？","like_count":1,"discussions":[{"author":{"id":1365541,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d6/25/a95a2064.jpg","nickname":"luwei","note":"","ucode":"0960A09F7B8D59","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72241,"discussion_content":"谁说移动每次只能移动一个位置了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575472492,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1567014,"avatar":"https://static001.geekbang.org/account/avatar/00/17/e9/26/afc08398.jpg","nickname":"Amosヾ","note":"","ucode":"833F6FCB4042AD","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":1365541,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d6/25/a95a2064.jpg","nickname":"luwei","note":"","ucode":"0960A09F7B8D59","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74698,"discussion_content":"？？？什么意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575676021,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":72241,"ip_address":""},"score":74698,"extra":""},{"author":{"id":1365541,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d6/25/a95a2064.jpg","nickname":"luwei","note":"","ucode":"0960A09F7B8D59","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1567014,"avatar":"https://static001.geekbang.org/account/avatar/00/17/e9/26/afc08398.jpg","nickname":"Amosヾ","note":"","ucode":"833F6FCB4042AD","race_medal":1,"user_type":1,"is_pvip":true},"discussion":{"id":273051,"discussion_content":"a[0]=a[3]","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590401623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":74698,"ip_address":""},"score":273051,"extra":""}]}]},{"had_liked":false,"id":145316,"user_name":"小肥羊","can_delete":false,"product_type":"c1","uid":1081582,"ip_address":"","ucode":"9F44BAA1A59FAD","user_header":"https://static001.geekbang.org/account/avatar/00/10/80/ee/bbee3ec1.jpg","comment_is_top":false,"comment_ctime":1572249583,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5867216879","product_id":100017301,"comment_content":"我看了第五章github的代码一直纳闷，用数组实现数组有意义么，直到我自己写了个GenericArray才发现即使是用数组本身来实现，也有鲁棒性需要检验，最简单的就是checkIndex。<br>本来被leetcode虐的怀疑人生了，直到回顾了下最简单的数据结构，才对编程重拾了信心，希望自己能把后面的代码都实现一遍。","like_count":1},{"had_liked":false,"id":144677,"user_name":"小肥羊","can_delete":false,"product_type":"c1","uid":1081582,"ip_address":"","ucode":"9F44BAA1A59FAD","user_header":"https://static001.geekbang.org/account/avatar/00/10/80/ee/bbee3ec1.jpg","comment_is_top":false,"comment_ctime":1571995023,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5866962319","product_id":100017301,"comment_content":"1.jvm没关注过，不过数组通过标记删除从而减少时间上的操作，这个还是挺厉害的<br>2.我认为二维数组在内存中的存储方式跟一维是一样的，也就是a［3］［3］和a［9］的存储方式一样，只不过是a00 a01 a02的顺序进行的<br>3.点个赞。下一课","like_count":1},{"had_liked":false,"id":82288,"user_name":"岁月如歌","can_delete":false,"product_type":"c1","uid":1428828,"ip_address":"","ucode":"1AEBD6F79941B7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/QFE00aXGzaS6ibbfJSJsDrpIkqs0OrIYjzZv6L9vZmMhOlut2j24iaeZb0MCQazToE6FRXN960nNiaTrsmw09YjGw/132","comment_is_top":false,"comment_ctime":1554176469,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5849143765","product_id":100017301,"comment_content":"1) 线性表、连续空间和相同类型<br>2) 支持随机访问 按下标随机访问时间复杂度O(1) <br>3) 数组删除操作,为了保证空间连续 需要进行位置移动,  但是频繁移动会消耗极大的时间. 故而删除元素时候先标记为删除, 将多个删除进行一次合并 减少空间移动的频率. <br>4)  数组删除操作思想与JVM垃圾回收算法很相似, <br>  标记-清除算法JVM最基础的垃圾回收算法, 通常使用GC ROOT判断对象是否可被回收并打上标记 垃圾回收会清除被标记的对象. 算法简单, 同时存在明显缺点: 标记清除效率低、造成内存碎片<br>  标记-整理-清除算法思想: 首先也是进行标记 然后会将存活的对象往一端移动 最后直接清除另一段端空间 不会造成对应内存碎片问题<br>5) 二维数组: a[m][n]  比如访问 a[x][y] 对应的地址为 a[x][y] = base_address + (n*x + y) * data_type_size <br>","like_count":1},{"had_liked":false,"id":79442,"user_name":"CalanceHao","can_delete":false,"product_type":"c1","uid":1401137,"ip_address":"","ucode":"068B4AC4D1D402","user_header":"https://static001.geekbang.org/account/avatar/00/15/61/31/211ac1a9.jpg","comment_is_top":false,"comment_ctime":1553484310,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5848451606","product_id":100017301,"comment_content":"笔记📝<br><br>- 数组<br>\t- 特性：连续的内存空间和相同类型的数据 <br>\t\t- ✅可以随机访问 ➜ 适合查找O(logn)&#47;&#47;二分<br>\t\t&gt; a[i]_address = base_address + i * data_type_size<br>\t\t- ❎插入删除数据很贵 Avg=O(n)<br>\t\t- Mainly：从0开始 反例：matlab、python<br>\t- 改进思路：<br>\t\t- Insert:<br>\t\t\t- 数组有序：将第 k～n 这部分的元素都顺序地往后挪一位，再插入k中<br>\t\t\t- 💡if数组无序：将第 k 位的数据搬移到末尾，把新元素直接放入k 🌰快排<br>\t\t- Delete：<br>\t\t\t- 💡记录然后批量删除 🌰JVM垃圾回收<br>\t- ⚠️访问越界：<br>\t\t- 不做检查：<br>\t\t\t- C <br>\t\t- 做越界检查：<br>\t\t\t- Java ：if 违反 then throw java.lang.ArrayIndexOutOfBoundsException<br>\t- 容器类：业务开发<br>\t\t- ✅封装操作细节，支持动态扩容 <br>\t\t- C++ : STL vector<br>\t\t- Java : ArrayList<br>\t\t\t- 使用：<br>\t\t\t\t- if事先可知数据大小：创建ArrayList时事先指定数据大小<br>\t\t\t- 用数组更合适的场景：底层开发 e.g：框架<br>\t\t\t\t1. 希望使用基本类型<br>\t\t\t\t&gt; Java Array List无法存储基本类型,比如int、long,需为 Integer、Long类。而 \tAutoboxing、 Unboxing则有一定的性能消耗,所以如果特别关注性能,或者希望使用基本类\t型,就可以选用数组<br>\t\t\t\t2. 数据大小事先已知 &amp;&amp; 操作非常简单,用不到ArrayList提供的大部分方法<br>\t\t\t\t3. 表示多维数组时,用数组往往会更加直观。<br>\t\t\t\t&gt; 比如Object[][] array;而用容器的话则需要这样定义: ArrayList&lt; ArrayList&gt;aray<br>","like_count":1},{"had_liked":false,"id":70114,"user_name":"李宁","can_delete":false,"product_type":"c1","uid":1427718,"ip_address":"","ucode":"6F2E7681D2BEBE","user_header":"https://static001.geekbang.org/account/avatar/00/15/c9/06/6cbc7eb6.jpg","comment_is_top":false,"comment_ctime":1550999520,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5845966816","product_id":100017301,"comment_content":"评论区好的大牛潜伏，看了评论区内容，有涨了不少知识，哈哈！都可以写成文章了","like_count":1},{"had_liked":false,"id":70035,"user_name":"LIAMCEES","can_delete":false,"product_type":"c1","uid":1439358,"ip_address":"","ucode":"0CDFA63E1A3885","user_header":"https://static001.geekbang.org/account/avatar/00/15/f6/7e/f707cea7.jpg","comment_is_top":false,"comment_ctime":1550971567,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5845938863","product_id":100017301,"comment_content":"牛逼啊，都是大佬，受益匪浅！","like_count":1},{"had_liked":false,"id":47606,"user_name":"王楚然","can_delete":false,"product_type":"c1","uid":1238608,"ip_address":"","ucode":"E0C8184C34908E","user_header":"https://static001.geekbang.org/account/avatar/00/12/e6/50/656a0012.jpg","comment_is_top":false,"comment_ctime":1544164503,"is_pvip":false,"replies":[{"id":"17198","content":"存的应该是对象的地址吧","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1544408153,"ip_address":"","comment_id":47606,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5839131799","product_id":100017301,"comment_content":"js是弱类型语言，那么js的数组是怎么做到可以存储不同类型数据而且支持随机访问的呢？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431828,"discussion_content":"存的应该是对象的地址吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544408153,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37967,"user_name":"小鱼","can_delete":false,"product_type":"c1","uid":1258839,"ip_address":"","ucode":"9F3D087A95D0C9","user_header":"https://static001.geekbang.org/account/avatar/00/13/35/57/ab4ba792.jpg","comment_is_top":false,"comment_ctime":1541828909,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5836796205","product_id":100017301,"comment_content":"Java的垃圾清除机制应该和.net是一样的。他们都采取了延迟清除的机制。没有频繁的清除内存数据可以提高效率","like_count":1},{"had_liked":false,"id":36225,"user_name":"🍃 ℳr.唐🐲🍂","can_delete":false,"product_type":"c1","uid":1276482,"ip_address":"","ucode":"3D4390BC3953DB","user_header":"https://static001.geekbang.org/account/avatar/00/13/7a/42/439d6f83.jpg","comment_is_top":false,"comment_ctime":1540986695,"is_pvip":false,"replies":[{"id":"12890","content":"看看留言区的回答","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541036388,"ip_address":"","comment_id":36225,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5835953991","product_id":100017301,"comment_content":"老师您好，我想请问一下：<br>原文如下：<br>我们知道，在 C 语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。根据我们前面讲的数组寻址公式，a[3] 也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。<br>这里的a[3]=0为什么相当于i=0呢，这个有点不理解，请老师百忙中帮忙解答一下。","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427790,"discussion_content":"看看留言区的回答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541036388,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34315,"user_name":"李延志","can_delete":false,"product_type":"c1","uid":1149554,"ip_address":"","ucode":"A23DABF8910AFA","user_header":"https://static001.geekbang.org/account/avatar/00/11/8a/72/349661af.jpg","comment_is_top":false,"comment_ctime":1540102638,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5835069934","product_id":100017301,"comment_content":"有一个疑问：在数组越界时导致无限循环的问题中，变量分配不是按照内存递增或递减方式，但是无论变量i在数组的前面还是后面都会无限循环，请大神指点一下。(测试环境centos的x86_64)","like_count":1},{"had_liked":false,"id":31543,"user_name":"芒果","can_delete":false,"product_type":"c1","uid":1154458,"ip_address":"","ucode":"08E6D77030CEE8","user_header":"https://static001.geekbang.org/account/avatar/00/11/9d/9a/4cf0e500.jpg","comment_is_top":false,"comment_ctime":1539225485,"is_pvip":false,"replies":[{"id":"11386","content":"恁真是性情中人啊 一会表扬我 一会批评我😄","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539256740,"ip_address":"","comment_id":31543,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5834192781","product_id":100017301,"comment_content":"感觉这个专栏特别棒，例如：数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)，作为学生党，觉得特别精华。","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426392,"discussion_content":"恁真是性情中人啊 一会表扬我 一会批评我😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539256740,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30088,"user_name":"王伟zzz","can_delete":false,"product_type":"c1","uid":1023443,"ip_address":"","ucode":"F2BADC0EA6CD6A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9d/d3/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1538654407,"is_pvip":false,"replies":[{"id":"10890","content":"嗯嗯 可以","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538749062,"ip_address":"","comment_id":30088,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5833621703","product_id":100017301,"comment_content":"插入操作的 平均情况时间复杂度是不是应该这么算？ (1+2+…n+1)&#47;n+1 ？ 因为一共n+1种情况","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425849,"discussion_content":"嗯嗯 可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538749062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29888,"user_name":"Ant","can_delete":false,"product_type":"c1","uid":1079563,"ip_address":"","ucode":"07E6374F91F61E","user_header":"https://static001.geekbang.org/account/avatar/00/10/79/0b/4346a253.jpg","comment_is_top":false,"comment_ctime":1538580959,"is_pvip":false,"replies":[{"id":"10836","content":"用手机回复留言都把我搞崩溃很多次了！","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538659603,"ip_address":"","comment_id":29888,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5833548255","product_id":100017301,"comment_content":"你们都是用手打的这么多字吗？   如果手打的话用pad真的不够方便呀。你们是不是在电脑端看的啊？   如果要是用APP并能手打的话。记忆力太好了","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425759,"discussion_content":"用手机回复留言都把我搞崩溃很多次了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538659603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29708,"user_name":"ecanfly","can_delete":false,"product_type":"c1","uid":1011042,"ip_address":"","ucode":"D8F1D9C324E246","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6d/62/824e8aff.jpg","comment_is_top":false,"comment_ctime":1538495131,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5833462427","product_id":100017301,"comment_content":"老师在文章中用的代码，在 Xcode 上创建一个 C 工程，复制代码执行 4 次就 Crash。在 Android Studio 中创建一个 .java 文件，执行3次就 Crash。<br><br>请问下，老师你的这个代码在什么机器，什么编译器下可以无线循环起来？<br>@slvher @Zzzzz 你们呢，有可运行起来的编译器或者环境吗？","like_count":1},{"had_liked":false,"id":29669,"user_name":"佑强","can_delete":false,"product_type":"c1","uid":1252011,"ip_address":"","ucode":"9C8B55127FEFCD","user_header":"https://static001.geekbang.org/account/avatar/00/13/1a/ab/b352a655.jpg","comment_is_top":false,"comment_ctime":1538477067,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5833444363","product_id":100017301,"comment_content":"JVM对象在内存中不被任何引用类型引用也没有引用路径到达这个对像时，会被标记为可删除对象，jvm 在为新对象分配内存空间时，如果发现内存不够分配或者没有连续的内存区域给大对象分配，则会调用垃圾回收器进行对象删除操作，这就是标记清除算法，因为被标记的对象可能不是连续的，所以回收后会产生对象碎片，所以标记清除算法并不是最佳的清理方法，一般用复制算法或者标记整理算法","like_count":1},{"had_liked":false,"id":29403,"user_name":"惟新","can_delete":false,"product_type":"c1","uid":1037553,"ip_address":"","ucode":"93D07C4D97F7AD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d4/f1/c06aa702.jpg","comment_is_top":false,"comment_ctime":1538363520,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5833330816","product_id":100017301,"comment_content":"数组和链表的区别:<br>链表适合插入、删除，时间复杂度 O(1)；数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。<br><br>Java 中数组和 ArrayList 的选择问题：<br>1、ArrayList 无法存储基本类型，需要把 int、long 转化为 Integer、Long 类，这种Autoboxing、Unboxing 需要消耗一定的性能。所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。<br>2、如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。<br>3、当要表示多维数组时，用数组往往会更加直观。比如 Object[][] array；而用容器的话则需要这样定义：ArrayList&lt;ArrayList&gt; array。<br>总结：对于业务开发，直接使用容器就足够了，省时省力。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。<br><br>二维数组寻址公式：<br>举例：一个 m x n 的二维数组arr，arr[i][j](0&lt;=i&lt;m &amp;&amp; 0&lt;=j&lt;n) 的内存地址。<br>a[i][j]_address = base_address + i * type_size * n + j;<br><br><br>求指正。","like_count":1},{"had_liked":false,"id":29368,"user_name":"caidy","can_delete":false,"product_type":"c1","uid":1188783,"ip_address":"","ucode":"AEFB529C32C7EE","user_header":"https://static001.geekbang.org/account/avatar/00/12/23/af/84f4714e.jpg","comment_is_top":false,"comment_ctime":1538359122,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5833326418","product_id":100017301,"comment_content":"二维数组计算公式，假设二维数组为Array[n][m]<br>则Array[i][j]=Base_Address+(i*m+j)*type_size;<br>i&lt;n,j&lt;m;","like_count":1},{"had_liked":false,"id":29361,"user_name":"hf","can_delete":false,"product_type":"c1","uid":1245444,"ip_address":"","ucode":"B0FC5A68F8D02D","user_header":"https://static001.geekbang.org/account/avatar/00/13/01/04/108efea1.jpg","comment_is_top":false,"comment_ctime":1538358221,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5833325517","product_id":100017301,"comment_content":"无限打印那个，应该是因为计算机存储大小端的问题吧，存储的声明顺序和实际物理地址顺序其实是相反的，x86机器好像是这样的","like_count":1},{"had_liked":false,"id":29341,"user_name":"长安","can_delete":false,"product_type":"c1","uid":1235228,"ip_address":"","ucode":"149EE6E7472CE7","user_header":"https://static001.geekbang.org/account/avatar/00/12/d9/1c/aa08ae6b.jpg","comment_is_top":false,"comment_ctime":1538356155,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5833323451","product_id":100017301,"comment_content":"二维数组内存寻址要考虑行优先和列优先两种情况<br>若定义一个数组a[n][m]<br>行优先 <br>a[k][j]_address = base_address+k*m*type_size + j*type_size<br>列优先 <br>a[k][j]_address = base_address+j*n*type_size + k*type_size<br>不知道是不是这样 希望老师指正","like_count":1},{"had_liked":false,"id":29332,"user_name":"凌","can_delete":false,"product_type":"c1","uid":1257995,"ip_address":"","ucode":"41369B360C794F","user_header":"https://static001.geekbang.org/account/avatar/00/13/32/0b/81ae214b.jpg","comment_is_top":false,"comment_ctime":1538354884,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5833322180","product_id":100017301,"comment_content":"go的gc也是标记的?<br>另外请教下a*是不是也是一种图","like_count":1},{"had_liked":false,"id":29329,"user_name":"五岳寻仙","can_delete":false,"product_type":"c1","uid":1247467,"ip_address":"","ucode":"88A46A4E1832CE","user_header":"https://static001.geekbang.org/account/avatar/00/13/08/eb/594e9e6c.jpg","comment_is_top":false,"comment_ctime":1538354353,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5833321649","product_id":100017301,"comment_content":"1. 不熟java，对python的垃圾回收机制有一点很肤浅的了解。<br>python中变量的值都是对象，变量名是指向这个对象的一个引用，每个对象都会有个记录被引用次数的标记。比如 “a = 1; b = 1” 其实系统只创建了一个“值为1的整数对象” ，这个对象的被引用次数为2，当被引用次数降为0的时候，代表没有人引用它了，系统就会把它清楚。<br><br>2. 在C中，数组是通过首地址加偏移来实现随机访问的。二维数组中，第一维存放的都是“第二维数组的首地址”，访问时通过两次偏移就可以了。比如 a[i][j]，第一次偏移 i 找到了第二维数组的首地址，第二次偏移 j 找到了存放的元素值。","like_count":1},{"had_liked":false,"id":29302,"user_name":"Rain","can_delete":false,"product_type":"c1","uid":1238221,"ip_address":"","ucode":"6A270D922A3B9D","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","comment_is_top":false,"comment_ctime":1538345858,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5833313154","product_id":100017301,"comment_content":"1. 现在只能想起来一点点了。。JVM GC就是Mark Sweep, 不同的回收策略在执行过程中有单线程和多线程的。谢谢在a,b,c标记再删除的点拨<br>2. a[k,j]_address= base_address+ k* type_size*x + j* type_size, 设二维数组内部长度为x.","like_count":1},{"had_liked":false,"id":29296,"user_name":"叫我阿 K 好了","can_delete":false,"product_type":"c1","uid":1247697,"ip_address":"","ucode":"36E66EA6B82CB6","user_header":"https://static001.geekbang.org/account/avatar/00/13/09/d1/3872f8c8.jpg","comment_is_top":false,"comment_ctime":1538328591,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5833295887","product_id":100017301,"comment_content":"老师你好，我18年毕业生，大学期间专业自动化，想学习编程，想问问您方向性的知道，或者说推荐几本书也可以，麻烦老师了。","like_count":1},{"had_liked":false,"id":360143,"user_name":"码狐","can_delete":false,"product_type":"c1","uid":1234879,"ip_address":"新加坡","ucode":"A4666D3AF30D6E","user_header":"https://static001.geekbang.org/account/avatar/00/12/d7/bf/9d8984b7.jpg","comment_is_top":false,"comment_ctime":1666230967,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1666230967","product_id":100017301,"comment_content":"二维数组的内存寻址<br>a[i][j] <br>address = base + ( i * size + j ) * data_size","like_count":0},{"had_liked":false,"id":358574,"user_name":"kevin","can_delete":false,"product_type":"c1","uid":1009786,"ip_address":"广东","ucode":"9993B42B5437F3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/68/7a/09ca3326.jpg","comment_is_top":false,"comment_ctime":1664435515,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664435515","product_id":100017301,"comment_content":"1. JVM 中存在新生代和老年代区域，标记清理主要发生在新生代区，当进行gc时会清理不再被使用的对象，如果被使用则标记年龄加一，当达到一定年龄会进入老年代，否则就会被清理。<br>2. 经测试，在golang中，二维数组是连续的内存空间，所以对于二维数组[m][n]int{}的寻址应该是 address=base_address+(i*n+j)*data_type_size","like_count":0},{"had_liked":false,"id":358545,"user_name":"Geek_93cecd","can_delete":false,"product_type":"c1","uid":3176219,"ip_address":"浙江","ucode":"1AEA57E57AC174","user_header":"","comment_is_top":false,"comment_ctime":1664421026,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664421026","product_id":100017301,"comment_content":"1. 数组（Array）是一种**线性表**数据结构。它用一组**连续的内存空间**，来存储一组具有**相同类型的数据**。<br><br>2. 下标确切的定义是偏移量，定义a[0]的偏移量为0 ，那么啊a[k]就表示k个偏移量的位置。<br><br>   ```java<br>   a[k]_address = base_address + k * type_size<br>   ```<br><br>3. 对于数组的插入和删除，效率较低，为了提高效率，插入可以采取把第k位元素移至末尾，再把要插入元素放入第k位；删除，可以采取先标记，记录删除，当内存不够时一次性删除所有要删除元素，类似于JVM的标记清除垃圾回收算法。<br><br>4. 数组的访问越界问题<br><br>   数组越界后会直接访问到非法地址，有可能导致一些很难排除的错误，所以要警惕数组越界问题。<br><br>   java中自身会做越界检查，会抛出异常java.lang.ArrayIndexOutOfBoundsException。<br><br>5. 器能否完全替代数组？<br><br>​      对于业务开发，直接使用容器就足够了；如果做非常底层的开发，数组优先于容器。<br><br><br><br>课后思考：<br><br>&gt; 标记清除垃圾回收算法：算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。<br><br>```java<br>&#47;&#47; 共m行，n列<br>a[i][j]_address = base_address + （m*i+j） * type_size<br>```<br><br>","like_count":0},{"had_liked":false,"id":358429,"user_name":"tingting","can_delete":false,"product_type":"c1","uid":2035702,"ip_address":"新加坡","ucode":"61E6B0C4EC59C5","user_header":"https://static001.geekbang.org/account/avatar/00/1f/0f/f6/609ded9f.jpg","comment_is_top":false,"comment_ctime":1664293992,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664293992","product_id":100017301,"comment_content":"var a [m][n]Type <br>a[i][j]的寻址公式为： base_address + (n*i+j)*data_type_size ","like_count":0},{"had_liked":false,"id":358263,"user_name":"111","can_delete":false,"product_type":"c1","uid":3109487,"ip_address":"北京","ucode":"D6E8E83A118A3E","user_header":"https://static001.geekbang.org/account/avatar/00/2f/72/6f/44c10658.jpg","comment_is_top":false,"comment_ctime":1664155383,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664155383","product_id":100017301,"comment_content":"1. jvm中的一种会标记要删除的内容，在需要的时候将未标记的复制到另一个内存地址，直接将当前地址完全标记清楚。<br>2. 二维也是连续的，只是将一段连续的地址当作一维的内容<br>总结：1. 数组为什么从0开始：历史原因<br>2. 什么时候使用数组：需要追求极致性能<br>3. 数组按下标查找是O(1)<br>4. 数组插入删除可以优化","like_count":0},{"had_liked":false,"id":357667,"user_name":"tanatang","can_delete":false,"product_type":"c1","uid":2349826,"ip_address":"四川","ucode":"7526705D25959A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/FhibmYQUzY7ibPac8Id5PwbibqCbvj5rWibeQhEyvYguc9pvPNUciaQydicrUjJKkhhp1s2AgfP7LRTZA8zqaa82yC8g/132","comment_is_top":false,"comment_ctime":1663551085,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1663551085","product_id":100017301,"comment_content":"个人感觉，在学习C语言的时候，会经常用数组来解决很多问题（有些巧妙利用空间，但不好懂）。但后来接触C#等更偏向应用的语言时，感觉数组的使用被弱化了。<br>说C语言运行效率更高，排除指针的因素外，是否跟其灵活使用数组也有关？直接使用数组，内存访问更快速？","like_count":0},{"had_liked":false,"id":357636,"user_name":"Geek_33401d","can_delete":false,"product_type":"c1","uid":3181572,"ip_address":"广东","ucode":"90FFA6A06DA1D8","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIBtzficN8xtZibYa39YXpRFttdkSqKLwKJhYRsl7xEPpqpSgWE9XiaMficia0YTP6GAc69wByUKaXAJAQ/132","comment_is_top":false,"comment_ctime":1663508690,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663508690","product_id":100017301,"comment_content":"jvm垃圾回收算法学到其一","like_count":0},{"had_liked":false,"id":356641,"user_name":"在路上","can_delete":false,"product_type":"c1","uid":1476245,"ip_address":"日本","ucode":"2668A965FA79F2","user_header":"https://static001.geekbang.org/account/avatar/00/16/86/95/b9d960d9.jpg","comment_is_top":false,"comment_ctime":1662463281,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662463281","product_id":100017301,"comment_content":"标记清除：垃圾清理时不是立即将不需要的对象从内存中清理掉，而是标记该对象需要清理。等到内存空间不足时触发清除所有标记的对象。这时还会判断此对象的引用是否被其他对象持有，若持有就清除标记，没有持有就清理掉<br>二维数组中存放的是一维数组的首元素地址，可将二维数组抽象为一维数组，里面存放的是一维数组根据一维数组的寻址公式a[k]_address = base_address + k * type_size * n即为一维数组的首元素地址再到此一维数组中其他索引的元素对应的寻址公式即为：(k &lt; n;l &lt; n) a[k][l]_address = base_address + (k * n + l) * type_size","like_count":0},{"had_liked":false,"id":356508,"user_name":"大Grace","can_delete":false,"product_type":"c1","uid":1519098,"ip_address":"江苏","ucode":"BD662B78E7E050","user_header":"https://static001.geekbang.org/account/avatar/00/17/2d/fa/ee196a7e.jpg","comment_is_top":false,"comment_ctime":1662370421,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662370421","product_id":100017301,"comment_content":"二维数组内存寻址的问题，看了评论区好多条回复有点懂了，先记下来。有点像找格子，哈哈。<br>二维数组寻址公式：\r<br>a[i,j]_address = base_address + (i*line_length + j) * data_type_size","like_count":0},{"had_liked":false,"id":356500,"user_name":"大Grace","can_delete":false,"product_type":"c1","uid":1519098,"ip_address":"江苏","ucode":"BD662B78E7E050","user_header":"https://static001.geekbang.org/account/avatar/00/17/2d/fa/ee196a7e.jpg","comment_is_top":false,"comment_ctime":1662368750,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662368750","product_id":100017301,"comment_content":"数组(array)是一种线性表数据结构。它用一组连续的内存空间来存储一组具有相同类型的数据，所以它具有“随机访问”的特性，但是插入、删除等操作复杂度就会提高，因为要保持连续性。其他内容看了还不太懂，老师，我再看看课程内容以及评论区(Ｔ▽Ｔ)","like_count":0},{"had_liked":false,"id":356373,"user_name":"Sherk","can_delete":false,"product_type":"c1","uid":2156245,"ip_address":"重庆","ucode":"AFE3E7F158258D","user_header":"https://static001.geekbang.org/account/avatar/00/20/e6/d5/4f1fc074.jpg","comment_is_top":false,"comment_ctime":1662210769,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662210769","product_id":100017301,"comment_content":"思考题：jvm标记清除算法，会通过可达性分析来标记JVM对象是否为垃圾。<br><br>这节主要讲了什么数组的应用，为什么从0开始。<br><br>    1. 数组存储在连续开辟的内存空间里， 因此可以随机查找。<br>    2.删除，插入效率不高。<br>  list集合和数组的区别：<br>       list可以随机扩缩容，封装了插入和删除的移动操作。<br>       业务开发可以使用list, 不在乎这点性能。<br>      底层框架开发用数组。","like_count":0},{"had_liked":false,"id":355713,"user_name":"🐻","can_delete":false,"product_type":"c1","uid":1043072,"ip_address":"北京","ucode":"534EDAD496A0E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ea/80/8759e4c1.jpg","comment_is_top":false,"comment_ctime":1661680308,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661680308","product_id":100017301,"comment_content":"创建二维数组 arr[m][n], 则对于数组中的元素 arr[i][j] (i&lt;m, j&lt;n)，期访问地址是<br><br>arr[i][j]_address = base_address + type_size * (i * n + j)","like_count":0},{"had_liked":false,"id":355605,"user_name":"蒋慕平","can_delete":false,"product_type":"c1","uid":2302901,"ip_address":"重庆","ucode":"57B8FF7F00C042","user_header":"https://static001.geekbang.org/account/avatar/00/23/23/b5/639a12ec.jpg","comment_is_top":false,"comment_ctime":1661528782,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661528782","product_id":100017301,"comment_content":"使用选择<br>1. 底层代码、简单代码建议使用数组。<br>2. ArrayList，能明确大小指定大小。减少自动扩容时间<br>- 插入、删除自动移动位置<br>- 自动扩容<br>","like_count":0},{"had_liked":false,"id":355604,"user_name":"蒋慕平","can_delete":false,"product_type":"c1","uid":2302901,"ip_address":"重庆","ucode":"57B8FF7F00C042","user_header":"https://static001.geekbang.org/account/avatar/00/23/23/b5/639a12ec.jpg","comment_is_top":false,"comment_ctime":1661528538,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661528538","product_id":100017301,"comment_content":"1. Array 线性表数据结构、一组连续的内存空间，相同类型的数据，支持随机访问(顺序访问-链表)<br>2. 线性表：数组、链表、队列、栈<br>3.  a[i]_address = base_address + i * data_type_size  从0开始少一次减法运算<br>a[i][j]_address = base_address + i * [data_type_size*j]+ j* data_type_size<br>4. 操作效率<br>- 访问,下标随机访问  时间复杂度O(1)<br>- 插入,最坏是O(n),最好是O(1),平均1&#47;n+1机会,O(n)--优化一种方式,待入K位置直接替换新值,K值移动最后<br>- 删除,最坏是O(n),最好是O(1),平均1&#47;n+1机会,O(n)---先做标记，然后触发批量删除操作。JVM标记清除垃圾回收算法、业务逻辑删除、mysql删除数据,undo日志，最终循环利用","like_count":0},{"had_liked":false,"id":355243,"user_name":"小板栗的粑粑","can_delete":false,"product_type":"c1","uid":1063294,"ip_address":"四川","ucode":"C843F4A32679EC","user_header":"https://static001.geekbang.org/account/avatar/00/10/39/7e/5a5fd103.jpg","comment_is_top":false,"comment_ctime":1661222553,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661222553","product_id":100017301,"comment_content":"歪个楼。<br>数组初始化的写法，文章中写的是int a[3]={0}.这样写法有可能不会给数组中每个元素赋值为0。<br>我们组内推荐的规范写法是int a[3]={0,0,0}。<br>大家觉得哪种数组初始化的写法比较规范呢？","like_count":0},{"had_liked":false,"id":354498,"user_name":"樹","can_delete":false,"product_type":"c1","uid":3119609,"ip_address":"江苏","ucode":"41E789F4062EAF","user_header":"https://static001.geekbang.org/account/avatar/00/2f/99/f9/10c6d492.jpg","comment_is_top":false,"comment_ctime":1660465869,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660465869","product_id":100017301,"comment_content":"二维数组寻址：假设a[m][n]求a[i][j]：<br>a[i][j]_address=base_address+(i*n+j)*type_size","like_count":0},{"had_liked":false,"id":353623,"user_name":"nikbobo","can_delete":false,"product_type":"c1","uid":2313460,"ip_address":"广东","ucode":"5A5C4C1347AF68","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/pcCjmRKf1h5Dpiclmdiak2eyl9sicRGEUiaiaebZB8sr1oria14RVeOAO87OjumuFvpAu3cCbINO7eYPm0Hep2x3QJxw/132","comment_is_top":false,"comment_ctime":1659613049,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1659613049","product_id":100017301,"comment_content":"对于作者提到的数组模拟的垃圾标记回收，有数组的示例代码吗？包括如何标记垃圾、如何判定数组满、如何回收垃圾使数组有序，想不出来。","like_count":0},{"had_liked":false,"id":352692,"user_name":"Geek_b14c55","can_delete":false,"product_type":"c1","uid":2027632,"ip_address":"","ucode":"C98EAEC045F13D","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/MOuCWWOnoQjOr8KjicQ84R7xu6DRcfDv3VAuHseGJ1gxXicKJboA24vOcrcJickTJPwFAU38VuwCGGkGq7f8WkTIg/132","comment_is_top":false,"comment_ctime":1658885415,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658885415","product_id":100017301,"comment_content":"对于m*n的数组 ，二维数组的寻址，比如a[i][j] （i&lt;m, j&lt;n）address = bassaddress + (i*n+j)*typesize","like_count":0},{"had_liked":false,"id":351437,"user_name":"老大不小","can_delete":false,"product_type":"c1","uid":1295609,"ip_address":"","ucode":"35BCDD3CB13467","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJRFRX8kNzNet7FibNvtavbVpAwK09AhIhrib9k762qWtH6mre8ickP7hM5mgZC4ytr8NnmIfmAhxMSQ/132","comment_is_top":false,"comment_ctime":1657786978,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657786978","product_id":100017301,"comment_content":"二维数组a[3][4]，三行四列，总共12个元素。m=3,n=4 <br>a[0][0], a[0][1], a[0][2], a[0][3] <br>a[1][0], a[1][1], a[1][2], a[1][3] <br>a[2][0], a[2][1], a[2][2], a[2][3] <br><br>从上面就可以看出来，二维数组a[i][j]偏移量是: i*n+j 例如a[1][0] = 1*4+0 = 4 <br>所以a[i][j] = base_address + ( i * n + j ) * type_size","like_count":0},{"had_liked":false,"id":350781,"user_name":"无言的约定","can_delete":false,"product_type":"c1","uid":1128953,"ip_address":"","ucode":"5E8046EB6B7956","user_header":"https://static001.geekbang.org/account/avatar/00/11/39/f9/acfb9a48.jpg","comment_is_top":false,"comment_ctime":1657187290,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657187290","product_id":100017301,"comment_content":"二维数组的寻址公式 https:&#47;&#47;blog.csdn.net&#47;lorarae&#47;article&#47;details&#47;118721272","like_count":0},{"had_liked":false,"id":349186,"user_name":"yl120064227","can_delete":false,"product_type":"c1","uid":2865070,"ip_address":"","ucode":"66E19E8A027D29","user_header":"https://static001.geekbang.org/account/avatar/00/2b/b7/ae/376dd048.jpg","comment_is_top":false,"comment_ctime":1655789752,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655789752","product_id":100017301,"comment_content":"二维数组内存寻址：<br>对于 m * n 的数组，a [ i ][ j ] (i &lt; m,j &lt; n)的地址为：<br>address = base_address + ( i * n + j) * type_size","like_count":0},{"had_liked":false,"id":348601,"user_name":"东方拓睿","can_delete":false,"product_type":"c1","uid":1605058,"ip_address":"","ucode":"1FD25D75CAC7C1","user_header":"https://static001.geekbang.org/account/avatar/00/18/7d/c2/e6332a1b.jpg","comment_is_top":false,"comment_ctime":1655247151,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655247151","product_id":100017301,"comment_content":"二维数组，首先申请一维数组的内存空间，然后将一维数组每个元素的地址段划分为一段连续的地址块，比如int[][]，一维数组的每个数据块的起始地址确定好了，就是每一个二维数组的起始地址，再按个数分段","like_count":0},{"had_liked":false,"id":347938,"user_name":"leon","can_delete":false,"product_type":"c1","uid":2152986,"ip_address":"","ucode":"15BA1A5271B20B","user_header":"https://static001.geekbang.org/account/avatar/00/20/da/1a/0b179bd7.jpg","comment_is_top":false,"comment_ctime":1654594054,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1654594054","product_id":100017301,"comment_content":"猜一下二维数组的寻址公式:<br>a[j]_address = base_address + j * type_size  <br>a[j][k]_address = a[j]_address + k * type_size","like_count":0},{"had_liked":false,"id":347420,"user_name":"栀言","can_delete":false,"product_type":"c1","uid":2237361,"ip_address":"","ucode":"D0838F9385CF61","user_header":"https://static001.geekbang.org/account/avatar/00/22/23/b1/f6e337fd.jpg","comment_is_top":false,"comment_ctime":1654004611,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1654004611","product_id":100017301,"comment_content":"数组定义：&quot;数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。&quot;<br>疑问1：如果我想申请20字节的数组，内存中有100字节可用内存（内存碎片），但是最大的连续内存块是16字节，这时候会申请失败；<br>疑问2：如果成功创建了20字节的数组arr，如果需要扩容时在1的情况下也会扩容失败对吧，因为是需要申请新的连续内存地址存放数据；<br>不知道理解是否正确","like_count":0},{"had_liked":false,"id":347316,"user_name":"大黄","can_delete":false,"product_type":"c1","uid":3012440,"ip_address":"","ucode":"8F2203D29AFF93","user_header":"https://static001.geekbang.org/account/avatar/00/2d/f7/58/6bb4d710.jpg","comment_is_top":false,"comment_ctime":1653918949,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1653918949","product_id":100017301,"comment_content":"请问一下，数据插入如果是无序的，每次插入到最后一位，这样可以保证连续性，也很高效，为什么文中要用交换位置来举例呢？","like_count":0},{"had_liked":false,"id":346707,"user_name":"bd7xzz","can_delete":false,"product_type":"c1","uid":1003006,"ip_address":"","ucode":"420199A024D4F5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fe/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1653374162,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653374162","product_id":100017301,"comment_content":"1.标记清除的gc，常见的cms gc。基本思想就是标记阶段，标记出可清理的对象，即与gc root不可达，作为可清理的依据，然后再执行针对标记后的清除，调用系统调用去清理内存。对于cms力求降低gc给应用带来的停顿耗时，所以细分出了5个阶段，包括了初始化阶段，接着并行标记即标记与应用线程并行标执行，由于并行标记产生了少量碎片，再进行重标记(此时会stw，但由于标记少量，耗时很短)，再进行并行清理垃圾，最后重置。当然，这是没有配置碎片压缩的。。<br>2.无论数组多少维，在内存中都是连续排开的，比如二维数组对于人来看是个矩阵，是个表格。但内存里第一维后面排着第二维，所以第二维第一个元素可以用第一维的最后一个元素当做基地址做累加。公式就是i*n*type_size+j*type_size=（i*n+j）*type_size","like_count":0},{"had_liked":false,"id":344851,"user_name":"chase_hong","can_delete":false,"product_type":"c1","uid":2788958,"ip_address":"","ucode":"C8CC27ED0A5FD4","user_header":"https://static001.geekbang.org/account/avatar/00/2a/8e/5e/a9d5defc.jpg","comment_is_top":false,"comment_ctime":1651823182,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651823182","product_id":100017301,"comment_content":"集中删除的时间复杂度是多少呢？","like_count":0},{"had_liked":false,"id":344256,"user_name":"beetcb","can_delete":false,"product_type":"c1","uid":2105664,"ip_address":"","ucode":"9436830F6CBF59","user_header":"","comment_is_top":false,"comment_ctime":1651399578,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651399578","product_id":100017301,"comment_content":"在笔试中遇到过行序和列序储存的地址计算问题，不算主流，还是贴一下(●&#39;◡&#39;●)<br><br>```js<br>&#47;&#47; 二维行序储存，先填满行<br>&#47;&#47;&#47; columns 表示列的数量(也就是每行的长度)<br>columns = arr[0].length<br>arr[k][kk]_address = base_address + (k * columns + kk) * type_size<br><br>&#47;&#47; 二维列序存储，先填满列<br>&#47;&#47;&#47; rows 表示行的数量(也就是每列的长度)<br>rows = arr[0][0].length<br>arr[k][kk]_address = base_address + (kk * rows + k) * type_size<br>```","like_count":0},{"had_liked":false,"id":344039,"user_name":"小杰","can_delete":false,"product_type":"c1","uid":2853200,"ip_address":"","ucode":"BBDF8E9F348F65","user_header":"https://static001.geekbang.org/account/avatar/00/2b/89/50/aee9fdab.jpg","comment_is_top":false,"comment_ctime":1651204685,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1651204685","product_id":100017301,"comment_content":"a[2][3]在内存中的排列方式，a[0][0]-a[0][1]-a[0][2]  a[1][0]-a[1][1]-a[1][2]，可以看到这是一个2行3列的数组。比如第5个元素a[1][1]的地址为 address = base_address + 1 * 3 * type_size + 1 * type_size。那么第2个元素a[0][1]的地址为 address = base_address + 0 * 3 * type_size + 1 * type_size。那么得出二维数组的a[m][n]，a[i][j](i &lt; m, j&lt; n)寻址公式 address = base_address + i * n * type_size + j * type_size = base_address + (i * n + j ) type_size","like_count":0},{"had_liked":false,"id":343886,"user_name":"杨少君","can_delete":false,"product_type":"c1","uid":1251143,"ip_address":"","ucode":"39AA0AE742D257","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/47/f9e1a563.jpg","comment_is_top":false,"comment_ctime":1651112822,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1651112822","product_id":100017301,"comment_content":"老师好，这句话不是很明白，为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。如何做到记录数据删除呢","like_count":0},{"had_liked":false,"id":342092,"user_name":"NaturelLee","can_delete":false,"product_type":"c1","uid":1031383,"ip_address":"","ucode":"BD123ED683C0CD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bc/d7/e517fd03.jpg","comment_is_top":false,"comment_ctime":1650011519,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650011519","product_id":100017301,"comment_content":"Rust说: 不好意思，俺不用垃圾回收机制！","like_count":0},{"had_liked":false,"id":341322,"user_name":"yejianxin1116","can_delete":false,"product_type":"c1","uid":1206896,"ip_address":"","ucode":"CE1FCF8A05DE16","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/YLYGKqr6ycdR9Aw1YYk0HicibdBsCpTSxY3u2neV9DPLE40oCqawBNjLMEhakW0vGAGtHOwbxicG61l0S6ynaF7yA/132","comment_is_top":false,"comment_ctime":1649519056,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649519056","product_id":100017301,"comment_content":"如果数据规模为m*n，i &lt; m,j&lt;n的话，地址应该为：<br>a[i][j]_address = base_address + (i * n + j) * type_size <br><br>分步解析如下：<br>其中(i*n)表示一级元素偏移量，即a[i]的偏移量，i之前的每个元素都占用n个type_size。<br>a[i]_address = base_address + (i * n) * type_size<br><br>然后二级元素，将a[i][0]视为首地址，可以得到a[i][j]的地址为<br>a[i][j]_address = a[i]_address + j * type_size;<br><br>综合可得出<br>a[i][j]_address = base_address + (i * n + j) * type_size <br>","like_count":0},{"had_liked":false,"id":341318,"user_name":"yejianxin1116","can_delete":false,"product_type":"c1","uid":1206896,"ip_address":"","ucode":"CE1FCF8A05DE16","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/YLYGKqr6ycdR9Aw1YYk0HicibdBsCpTSxY3u2neV9DPLE40oCqawBNjLMEhakW0vGAGtHOwbxicG61l0S6ynaF7yA/132","comment_is_top":false,"comment_ctime":1649518034,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649518034","product_id":100017301,"comment_content":"给自己留个作业：<br>看看php的垃圾回收机制是否有可以参考的点。帮助理解。","like_count":0},{"had_liked":false,"id":341238,"user_name":"zhihui","can_delete":false,"product_type":"c1","uid":1649037,"ip_address":"","ucode":"780ED9E443525F","user_header":"https://static001.geekbang.org/account/avatar/00/19/29/8d/2869a10b.jpg","comment_is_top":false,"comment_ctime":1649460919,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649460919","product_id":100017301,"comment_content":"二维数组的分配的内存地址也不是二维空间表示的  也是一个线性的内存地址 <br>a[i][j]=base_address+（i*n+j）*type_size","like_count":0},{"had_liked":false,"id":341237,"user_name":"zhihui","can_delete":false,"product_type":"c1","uid":1649037,"ip_address":"","ucode":"780ED9E443525F","user_header":"https://static001.geekbang.org/account/avatar/00/19/29/8d/2869a10b.jpg","comment_is_top":false,"comment_ctime":1649459999,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649459999","product_id":100017301,"comment_content":"标记清除：是指的是通过gc root节点对象进行可达性分析，如果不可达就标记为黑色，就是三色标记的思想，然后标记完以后做统一的清除。","like_count":0},{"had_liked":false,"id":338822,"user_name":"林海俭","can_delete":false,"product_type":"c1","uid":1973346,"ip_address":"","ucode":"403020C3201C90","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM6ssNfBGQXiafTSCBHtl4L7ykIBjqZMMpWU3v4ibwP0APYzWk88zELRaJXUNMIVcuWpkb0Q3x0CicYxg/132","comment_is_top":false,"comment_ctime":1647753769,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647753769","product_id":100017301,"comment_content":"标记清除回收算法就是垃圾回收线程对已经没有被使用的对象标记删除，由其他线程针对性的回收被标记的对象，不过由于业标记后不会马上清除，而业务代码和垃圾回收线程是可并发运行的，所以又会针对性的出现了三色标记发和GC root根对象查找失效对象。","like_count":0},{"had_liked":false,"id":338270,"user_name":"hyx","can_delete":false,"product_type":"c1","uid":2217004,"ip_address":"","ucode":"7987F771C78357","user_header":"https://static001.geekbang.org/account/avatar/00/21/d4/2c/d8f626f3.jpg","comment_is_top":false,"comment_ctime":1647400928,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647400928","product_id":100017301,"comment_content":"关于无限print的问题，做了下测试，测试代码：<br>#include &lt;stdio.h&gt;<br><br>int foo1(int argc, char* argv[]){<br>    int i = 0;<br>    int arr[3] = {0};<br>    printf(&quot;Address of i: %p\\n&quot;, &amp;i);<br>    printf(&quot;Address of arr[-5]: %p\\n&quot;, &amp;arr[-5]);<br>    printf(&quot;Address of arr[3]: %p\\n&quot;, &amp;arr[3]);<br><br><br>    for(; i&lt;=3; i++){<br>        arr[i] = 0;<br>        printf(&quot;hello world\\n&quot;);<br>    }<br>    return 0;<br>}<br><br>int main() {<br>    foo1(1, &quot;afaf&quot;);<br>    return 0;<br>}<br>输出结果:<br>Address of i: 0x16ce37734<br>Address of arr[-5]: 0x16ce37734<br>Address of arr[3]: 0x16ce37754<br>hello world<br>hello world<br>hello world<br>hello world<br><br>会发现无法复现这个现象，经过多次测试发现，函数内不论先声明int i还是先声明int arr[3]都会导致，arr[3]在栈空间的高地址上，i在低地址。<br>这可能和编译器有关（或许高版本的编译器会优先给arr分配内存，防止越界导致的问题），我是用的编译器版本是：Apple clang version 13.0.0 (clang-1300.0.29.30)<br>不知道其他同学有没有复现的。","like_count":0},{"had_liked":false,"id":336881,"user_name":"Geek_sz","can_delete":false,"product_type":"c1","uid":2449060,"ip_address":"","ucode":"72E86D7D6554CF","user_header":"https://static001.geekbang.org/account/avatar/00/25/5e/a4/d48b8298.jpg","comment_is_top":false,"comment_ctime":1646447409,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646447409","product_id":100017301,"comment_content":"要不要什么留言都放出来，还有评论功能很垃圾，都没有打字自由","like_count":0},{"had_liked":false,"id":336401,"user_name":"谭雪娇","can_delete":false,"product_type":"c1","uid":1375252,"ip_address":"","ucode":"B20AB23E0D20E0","user_header":"https://static001.geekbang.org/account/avatar/00/14/fc/14/b6b50f91.jpg","comment_is_top":false,"comment_ctime":1646128715,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646128715","product_id":100017301,"comment_content":"function main(){<br> let i = 0;<br> let arr = [1,2,3];<br> for(; i&lt;=3; i++){<br> arr[i] = 0;<br> console.log(&quot;hello world\\n&quot;,i,arr); <br>}<br> return 0;<br>}<br>main()<br><br>&#47;&#47; hello world<br> &#47;&#47;0 (3) [0, 2, 3]<br>&#47;&#47; hello world<br> &#47;&#47;1 (3) [0, 0, 3]<br>&#47;&#47; hello world<br> &#47;&#47;2 (3) [0, 0, 0]<br>&#47;&#47; hello world<br> &#47;&#47;3 (4) [0, 0, 0, 0]<br>我在浏览器下面直接运行的，js里面数组好像没有越界问题？","like_count":0},{"had_liked":false,"id":336398,"user_name":"谭雪娇","can_delete":false,"product_type":"c1","uid":1375252,"ip_address":"","ucode":"B20AB23E0D20E0","user_header":"https://static001.geekbang.org/account/avatar/00/14/fc/14/b6b50f91.jpg","comment_is_top":false,"comment_ctime":1646127849,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646127849","product_id":100017301,"comment_content":"链表适合插入、删除，时间复杂度 O(1)，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。","like_count":0},{"had_liked":false,"id":336246,"user_name":"明","can_delete":false,"product_type":"c1","uid":1457844,"ip_address":"","ucode":"B0ECF9525861C5","user_header":"https://static001.geekbang.org/account/avatar/00/16/3e/b4/84a0b50b.jpg","comment_is_top":false,"comment_ctime":1646032051,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646032051","product_id":100017301,"comment_content":"对于二维数组M*N, arr[i][j], i &gt; 0, y &gt; 0的内存地址公式为：<br>arr[i][y]_address = base_address + (I * k + y) * type_size","like_count":0},{"had_liked":false,"id":336244,"user_name":"Echo","can_delete":false,"product_type":"c1","uid":1878585,"ip_address":"","ucode":"1542D4B4154CA9","user_header":"","comment_is_top":false,"comment_ctime":1646031585,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1646031585","product_id":100017301,"comment_content":"好像极客上面是不是比实体书少一章节，少 数据结构中的数组和编程语言中的数组的区别呢？","like_count":0},{"had_liked":false,"id":335809,"user_name":"Today","can_delete":false,"product_type":"c1","uid":1235000,"ip_address":"","ucode":"4FA397F0BD8C6E","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/38/41027bda.jpg","comment_is_top":false,"comment_ctime":1645696029,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645696029","product_id":100017301,"comment_content":"二维数组的寻址公式<br>对于 m * n 的数组<br>arr_address[i][j] = base_address + (i * n + j) * type_size;<br>其中 i * n + j 表示行的偏移量 + 列的偏移量","like_count":0},{"had_liked":false,"id":335421,"user_name":"🐟 🐟 🐟","can_delete":false,"product_type":"c1","uid":2556217,"ip_address":"","ucode":"EB2EDEF667F30F","user_header":"https://static001.geekbang.org/account/avatar/00/27/01/39/bd834cc6.jpg","comment_is_top":false,"comment_ctime":1645513441,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645513441","product_id":100017301,"comment_content":"2. 二维数组内存公式<br>对于m * n数组，a[i][j](i&lt;m, j&lt;n)内存公式：<br>a[i][j]_address = base_address + (i *n + j)data_type_size<br>","like_count":0},{"had_liked":false,"id":335258,"user_name":"援来有度","can_delete":false,"product_type":"c1","uid":1977545,"ip_address":"","ucode":"317285927A243D","user_header":"https://static001.geekbang.org/account/avatar/00/1e/2c/c9/34725781.jpg","comment_is_top":false,"comment_ctime":1645429821,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1645429821","product_id":100017301,"comment_content":"小争哥，JS有个数据类型叫ArrayBuffer，其中的Buffer是什么意思，为什么要取这个名字啊？","like_count":0},{"had_liked":false,"id":334292,"user_name":"独孤九剑","can_delete":false,"product_type":"c1","uid":2912555,"ip_address":"","ucode":"478E97D012AD66","user_header":"https://static001.geekbang.org/account/avatar/00/2c/71/2b/7d636be0.jpg","comment_is_top":false,"comment_ctime":1644851946,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644851946","product_id":100017301,"comment_content":"没想明白，为啥角标从1开 base + (k-1)type_size，脚标从0开始不是base +k*type_size?","like_count":0},{"had_liked":false,"id":333650,"user_name":"Kylin。","can_delete":false,"product_type":"c1","uid":1514053,"ip_address":"","ucode":"C02B16B79C7141","user_header":"https://static001.geekbang.org/account/avatar/00/17/1a/45/5c11e1d2.jpg","comment_is_top":false,"comment_ctime":1644459421,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1644459421","product_id":100017301,"comment_content":"栈空间地址是从高往低铺的，arr 作为一个整体在 i 的地址下面，但是 arr 数组内部的地址依旧是从低地址开始往高地址增长，所以  &amp;arr[3] == &amp;i","like_count":0},{"had_liked":false,"id":331586,"user_name":"Geek_fea1dd","can_delete":false,"product_type":"c1","uid":2898200,"ip_address":"","ucode":"9F5BAD9EA75632","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/7cvP8dHRjNak32zH6bGRg3mQABxj7Bj6icGop9pXc8f6jxkAfiasA1UJQTHpmiaNGbyicTEaXe4yia1UAmJ1OAIkNtA/132","comment_is_top":false,"comment_ctime":1642664601,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642664601","product_id":100017301,"comment_content":"“为了避免 d，e，f，g，h 这几个数据会被搬移三次”，为什么是搬移三次？必须一格一格搬移吗？","like_count":0},{"had_liked":false,"id":331123,"user_name":"葫芦爷救娃娃","can_delete":false,"product_type":"c1","uid":2027485,"ip_address":"","ucode":"ED79963B815491","user_header":"https://static001.geekbang.org/account/avatar/00/1e/ef/dd/f2d1bc39.jpg","comment_is_top":false,"comment_ctime":1642432887,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642432887","product_id":100017301,"comment_content":"我是unity开发的，从java的ArrayList类比了下C#的Lit，发现有不同，C# new一个空List，List的容量为0，当add一个数据到List中时，List的容量为4，当List的长度为4时，再往List中add一个数据时，List的容量变成了8，所以C#的List扩容是每4个扩容一次<br>然后我还想到了lua语言的数组下标是从1开始的","like_count":0},{"had_liked":false,"id":330789,"user_name":"小柯","can_delete":false,"product_type":"c1","uid":1228978,"ip_address":"","ucode":"43E9D6D98A5BCC","user_header":"https://static001.geekbang.org/account/avatar/00/12/c0/b2/635ba9d9.jpg","comment_is_top":false,"comment_ctime":1642162810,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642162810","product_id":100017301,"comment_content":"JVM标记清除算法：<br>在标记阶段，会遍历 所有的GC ROOTS，将其标记为存活状态。只有当标记工作完成的时候，清除工作才开始。<br>不足：效率不高，需要等所有的标记工作都完成之后才开始清除。会产生不连续的内存空间。<br>二维数组寻址：<br>对于m*n的数组，a[i][j](i&lt;m, j&lt;n)的地址为<br>address = base_address + (i * j)* type_size<br>","like_count":0},{"had_liked":false,"id":330558,"user_name":"Fearless.","can_delete":false,"product_type":"c1","uid":2416390,"ip_address":"","ucode":"0870B7BB23E294","user_header":"https://static001.geekbang.org/account/avatar/00/24/df/06/72f90828.jpg","comment_is_top":false,"comment_ctime":1642042302,"is_pvip":false,"replies":[{"id":"120534","content":"你可以先试读两篇，判断下适合自己学习不","user_name":"编辑回复","user_name_real":"编辑","uid":"1059377","ctime":1642048907,"ip_address":"","comment_id":330558,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1642042302","product_id":100017301,"comment_content":"不会c 和java能学这个吗？","like_count":0,"discussions":[{"author":{"id":1059377,"avatar":"https://static001.geekbang.org/account/avatar/00/10/2a/31/9edbf8a6.jpg","nickname":"贾静","note":"","ucode":"081E70CC01F6B8","race_medal":0,"user_type":8,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545770,"discussion_content":"你可以先试读两篇，判断下适合自己学习不","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642048907,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":8}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330288,"user_name":"cath","can_delete":false,"product_type":"c1","uid":2887039,"ip_address":"","ucode":"648BC0C396A610","user_header":"https://static001.geekbang.org/account/avatar/00/2c/0d/7f/654d8995.jpg","comment_is_top":false,"comment_ctime":1641893877,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641893877","product_id":100017301,"comment_content":"雄心勃勃开始，想给算法混个眼熟。结果才开始就懵逼了。老师很多“默认你知道”的东西，比如栈、数组。我非专业，学了点python皮毛来的，脑子里一直想的列表。越听越懵，以为自己数据类型都记错了。后来听到说“容器”才反应过来。又去百度了一下才明白。无限循环那里也是卡了一下。有点吃力，全靠评论区大神","like_count":0},{"had_liked":false,"id":329722,"user_name":"不朽immortalt","can_delete":false,"product_type":"c1","uid":1587625,"ip_address":"","ucode":"4A411F5376C1C7","user_header":"https://static001.geekbang.org/account/avatar/00/18/39/a9/02d761b9.jpg","comment_is_top":false,"comment_ctime":1641512841,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641512841","product_id":100017301,"comment_content":"看完感觉像是复习了一节数据结构的课程，不错","like_count":0},{"had_liked":false,"id":329064,"user_name":"Geek_a6de14","can_delete":false,"product_type":"c1","uid":2755712,"ip_address":"","ucode":"90F6B9DFAD56A0","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKSbyc5JMDFq5s4mhrNSsFM2Esz1HfzEEKp0zB3p2T5KodmM58P3wD55cibwI499Cayd7jFP9xadjA/132","comment_is_top":false,"comment_ctime":1641091651,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641091651","product_id":100017301,"comment_content":"数组的收获：<br>1.为什么数组下标从0开始？一是历史原因；二是下标确切的含义是偏移量（offset），下标从零开始每次随机访问数组都能够减少一次减法运算。<br>2.容器类比如ArrayList的优势：一是可以将数组操作的细节封装起来（比如，插入和删除元素时牵扯到的数据搬移）；二是支持动态扩容（但是事先定义时尽量准确）。<br>3.数组相比于容器更适合的场景（3条），详见文稿“容器能否完全替代数组？”。","like_count":0},{"had_liked":false,"id":328975,"user_name":"Geek_986dab","can_delete":false,"product_type":"c1","uid":2844245,"ip_address":"","ucode":"B617279140B81B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKEoM9X3SwJ0Zb1g1TbAicyJJvTzblLJf5wazfEgUD00OHos0RrhHaHoa31wsU6S4InPUTU2fckKvA/132","comment_is_top":false,"comment_ctime":1640966510,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640966510","product_id":100017301,"comment_content":"数组不是能存 不同类型的数据么？","like_count":0},{"had_liked":false,"id":328623,"user_name":"YOU","can_delete":false,"product_type":"c1","uid":2878843,"ip_address":"","ucode":"7F4CE735A863C2","user_header":"https://static001.geekbang.org/account/avatar/00/2b/ed/7b/a0e0280c.jpg","comment_is_top":false,"comment_ctime":1640790937,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640790937","product_id":100017301,"comment_content":"二维数据的取值a[i][j], ( i&lt;n, j&lt; m)x = i* m+ j<br>今天学习了数据的插入删除都需要移位其他元素，特殊的插入方法，当前插入元素放到最后，然后直接插入到当前位置，特殊删除方法，删除的时候做标记，等待时机后，统一删除","like_count":0},{"had_liked":false,"id":326595,"user_name":"cqh","can_delete":false,"product_type":"c1","uid":2812604,"ip_address":"","ucode":"80B383D94C0B2F","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIlBiaNaPKczt1dzeDMHPSkicOnRnwOGm0J64ESiblmr5shZ9FpD4W9DvFp3U45WKfhrq8gmw9N5kYXQ/132","comment_is_top":false,"comment_ctime":1639574702,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639574702","product_id":100017301,"comment_content":"数组<br>逻辑结构：线性<br>存储结构：一段连续的内存空间<br>功能：增删改查（视具体情况，操作有不用的效率）。<br>特点：可按下标随机访问O(1)。操作时，可能需要移动很多元素。","like_count":0},{"had_liked":false,"id":324216,"user_name":"Justin","can_delete":false,"product_type":"c1","uid":1109632,"ip_address":"","ucode":"E6C4119C752465","user_header":"https://static001.geekbang.org/account/avatar/00/10/ee/80/db52af6b.jpg","comment_is_top":false,"comment_ctime":1638340345,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638340345","product_id":100017301,"comment_content":"gcroot，可达标记","like_count":0},{"had_liked":false,"id":323897,"user_name":"Geek_a414f8","can_delete":false,"product_type":"c1","uid":1912035,"ip_address":"","ucode":"AB0FA394C09FA4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ccpIPibkaTQeOPClugKDicV10vrpcpGBUHtVSrFpZmd1jFicXFDoNC7BJibQicQr6PnNvL5iaoGOVict2cXdaUvnTCaFg/132","comment_is_top":false,"comment_ctime":1638199309,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638199309","product_id":100017301,"comment_content":"ArrayList的实现也是连续的内存地址空间的话，为什么性能会相对数组差一点呢","like_count":0},{"had_liked":false,"id":322920,"user_name":"Tina","can_delete":false,"product_type":"c1","uid":2851354,"ip_address":"","ucode":"8D6D9F6E3D0A99","user_header":"https://static001.geekbang.org/account/avatar/00/2b/82/1a/30676c2e.jpg","comment_is_top":false,"comment_ctime":1637658769,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637658769","product_id":100017301,"comment_content":"对于数组，有几个重要的点，一个是线性表，可以理解为像一条线连起来的结构，同类型的还有链表，队列，栈等，非线性表是树，图等结构，第二个是连续的内存空间和相同类型的数据，表示数组是占用一段连续的内存空间，从而也方便进行随机访问（随机访问是通过内存地址和下标来实现的），根据下标随机访问的复杂度为o(1)，而查找，即使是有序的二分查找，复杂度也是O(logn)，访问和查找不一样，数组内只能存放相同类型的数据。数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。<br><br>正是因为数组是占用连续的内存空间，所有如果要插入或者删除一个元素，便要移动大量数据，最好情况时间复杂度为O(1)，插入到最后或者删除最后，最坏情况时间复杂度为O(n)，需要移动几乎所有数据，平均复杂度为O(n)。所以如果要连续删除几个数据的话，可以先标记要被删除的元素，然后再一起删除，这样只需要移动一次，而不是多次了，提高了性能，JVM标记清除垃圾回收算法便是如此。<br><br>在越界问题中，看到留言区同学的回答感觉好理解，函数体内的局部变量存在栈上，且是连续压栈。在Linux进程的内存布局中，栈区在高地址空间，从高向低增长。变量i和arr在相邻地址，且i比arr的地址大，所以arr越界正好访问到i。当然，前提是i和arr元素同类型，否则那段代码仍是未决行为。自己画个图，根据栈的结构可以发现，越界之后那段代码正好是i = 0的地址，且i=0与arr元素是同类型，便会产生循环，也与计算机操作系统与编译器等有关。<br><br>Java中也封装了ArrayList等容器，用起来更方便，但是如果涉及到底层，且功能没那么复杂时，Array仍然是比较好的选择。<br><br>为什么大多数编程语言数组都是从0开始编号呢？从1不是更加符合人类的习惯吗？从数组 存储的内存模型来看，下标更确切的说法应该是偏移量，a[0]便是偏离于首地址为0，以此类推，如果从1开始计数，那计算内存地址时还要有一个减一的操作，对于CPU来说，就多了一次减法指令，最主要是开始C语言的设计者从0开始计数，后面的语言为了减少学习成本也从0开始，有些语言也不是从0开始的。<br><br>一维数组的寻址公式是：address_a[k] = base_address + k*type_size;<br>二维数组a[m,n]的寻址公式是：address_a[i,j] = base_address + (i*n+j)*type_size;","like_count":0},{"had_liked":false,"id":322500,"user_name":"Geek_7e6229","can_delete":false,"product_type":"c1","uid":2600397,"ip_address":"","ucode":"51438E4C8829D5","user_header":"","comment_is_top":false,"comment_ctime":1637423946,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637423946","product_id":100017301,"comment_content":"二维数组寻址——幻想<br>首先是二层的寻找：<br>假设知道a00的地址，就能按照一维数组的寻找方式找到a01的<br>然后是一层的寻找：<br>a0<br>怎么根据a0去找a00的地址呢<br>a00=a00+k*size <br><br><br>","like_count":0},{"had_liked":false,"id":321512,"user_name":"windf1sh","can_delete":false,"product_type":"c1","uid":1157244,"ip_address":"","ucode":"9745EC7820493D","user_header":"https://static001.geekbang.org/account/avatar/00/11/a8/7c/bb08fba5.jpg","comment_is_top":false,"comment_ctime":1636912383,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636912383","product_id":100017301,"comment_content":"1.数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。<br>2.线性表（Linear List）。顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。而与它相对立的概念是非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。<br>3.连续的内存空间和相同类型的数据。正是因为这两个限制，它才有了一个堪称“杀手锏”的特性：“随机访问”。但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。<br>4.数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。","like_count":0},{"had_liked":false,"id":321200,"user_name":"Roger","can_delete":false,"product_type":"c1","uid":1519362,"ip_address":"","ucode":"4CDEEA3B1C074B","user_header":"https://static001.geekbang.org/account/avatar/00/17/2f/02/e7289586.jpg","comment_is_top":false,"comment_ctime":1636704363,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636704363","product_id":100017301,"comment_content":"为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。<br><br>如果这时想要根据下标访问数组元素，读取的数据不会有问题吗？","like_count":0},{"had_liked":false,"id":320489,"user_name":"wessonwang","can_delete":false,"product_type":"c1","uid":1000441,"ip_address":"","ucode":"A9BA5E3A3F278E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/43/f9/723ee153.jpg","comment_is_top":false,"comment_ctime":1636352970,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1636352970","product_id":100017301,"comment_content":"二维数组寻址<br>假设 二维数组是 x[n][m]<br>x[i][j]的地址是 = base_addr + (i+n*j)*type_size<br>","like_count":0},{"had_liked":false,"id":320343,"user_name":"Geek_5b2ab1","can_delete":false,"product_type":"c1","uid":2628460,"ip_address":"","ucode":"C1AF841A9F0B6C","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK9Yvy5STDw874VEEuPehIcONR9kEq7knIicUNuINU0ovf2ViabhFqiabZiaoXC5FqL89YDCxp3tBnFzA/132","comment_is_top":false,"comment_ctime":1636266865,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1636266865","product_id":100017301,"comment_content":"在docker 里的Ubuntu 测试了一下，打印了4行 hello world 就停了，显示”*** stack smashing detected ***: terminated<br>Aborted“<br>大概是只能访问本程序申请的地址","like_count":0},{"had_liked":false,"id":320127,"user_name":"悠悠做神仙","can_delete":false,"product_type":"c1","uid":2836018,"ip_address":"","ucode":"86DDAD806EF983","user_header":"https://static001.geekbang.org/account/avatar/00/2b/46/32/c5232058.jpg","comment_is_top":false,"comment_ctime":1636091797,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636091797","product_id":100017301,"comment_content":"印象中有点混淆了，标记清除，和年轻代移到老年代，我记得有一个是计数的，数好像是15.。。<br>看来得回顾一下了。。","like_count":0},{"had_liked":false,"id":319907,"user_name":"一只小吃吃","can_delete":false,"product_type":"c1","uid":2643217,"ip_address":"","ucode":"6749B92610D383","user_header":"https://static001.geekbang.org/account/avatar/00/28/55/11/0adfc3df.jpg","comment_is_top":false,"comment_ctime":1636006814,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636006814","product_id":100017301,"comment_content":"C语言从0开始计数，之前我一直以为是数学上的原因：0是最小的自然数","like_count":0},{"had_liked":false,"id":319052,"user_name":"Geek_1d4382","can_delete":false,"product_type":"c1","uid":2826799,"ip_address":"","ucode":"D6C0105FDD01B8","user_header":"","comment_is_top":false,"comment_ctime":1635527303,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635527303","product_id":100017301,"comment_content":"随机访问:随意根据下标进行访问<br>jvm:先进行标记，内存满了再清除<br>二维数组的访问:（in+j）type_size","like_count":0},{"had_liked":false,"id":317982,"user_name":"Changeme_123","can_delete":false,"product_type":"c1","uid":2207442,"ip_address":"","ucode":"94B72668B1D6BC","user_header":"https://static001.geekbang.org/account/avatar/00/21/ae/d2/e00a5084.jpg","comment_is_top":false,"comment_ctime":1635085604,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635085604","product_id":100017301,"comment_content":"感觉数组删除操作的改进方法好像没有插入操作的改进方法那样有效，删除操作一定要做一次数据搬移操作，时间复杂度为O(n)，不知道理解的对不对😌","like_count":0},{"had_liked":false,"id":315763,"user_name":"Geek_b7b4c1","can_delete":false,"product_type":"c1","uid":2347357,"ip_address":"","ucode":"E9E8DC68E372E9","user_header":"","comment_is_top":false,"comment_ctime":1633968464,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633968464","product_id":100017301,"comment_content":"数组越界让我又学到了","like_count":0},{"had_liked":false,"id":314441,"user_name":"倔强","can_delete":false,"product_type":"c1","uid":2792413,"ip_address":"","ucode":"4C588A1E7C0F7C","user_header":"https://static001.geekbang.org/account/avatar/00/2a/9b/dd/97a690a2.jpg","comment_is_top":false,"comment_ctime":1633059053,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633059053","product_id":100017301,"comment_content":"a[k]_address = base_address + k * type_size<br>根据寻址公式，a[0]_address=1000+0*4=1000,a[1]_adresss=1000+1*4=1004。懂了。<br>那么假设二维数组a[2][3]，a[0][0]_address=base_address+0*type_size,<br>a[0][1]_address=base_address+1*type_size,a[0][2]_address=base_address+2*type_size<br>a[1][0]_address=base_address+3*type_size,a[1][1]_address=base_address+(1*3+1)*type_size<br>a[1][2]_address=base_address+（1*3+2）*type_size<br>所以二位数组寻址公式是设定m*n的数组，a[i][j](i&lt;m,n&lt;j)<br>a[i][j]_address=base_address+(i*n+j)*type_size.","like_count":0},{"had_liked":false,"id":314436,"user_name":"倔强","can_delete":false,"product_type":"c1","uid":2792413,"ip_address":"","ucode":"4C588A1E7C0F7C","user_header":"https://static001.geekbang.org/account/avatar/00/2a/9b/dd/97a690a2.jpg","comment_is_top":false,"comment_ctime":1633056594,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633056594","product_id":100017301,"comment_content":"a[i]_address=base_address+i*date_type_seze<br>老师，你说base_address=1000,那么a[0]=1000+1*4=1004了，可是a[1]才从1004开始啊？这个应该怎么理解？","like_count":0},{"had_liked":false,"id":314284,"user_name":"张健平","can_delete":false,"product_type":"c1","uid":2542958,"ip_address":"","ucode":"45F86880F3CFF1","user_header":"https://static001.geekbang.org/account/avatar/00/26/cd/6e/78ab0121.jpg","comment_is_top":false,"comment_ctime":1632950030,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632950030","product_id":100017301,"comment_content":"小小一个数组竟然有这么多我以前理解不到位的东西。","like_count":0},{"had_liked":false,"id":314187,"user_name":"俯瞰风景.","can_delete":false,"product_type":"c1","uid":1044166,"ip_address":"","ucode":"A6DB68B7B84AEE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/c6/bebcbcf0.jpg","comment_is_top":false,"comment_ctime":1632891773,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632891773","product_id":100017301,"comment_content":"数组中的数据在计算机物理空间上是连续排列的，所以通过数据下标和寻址公式可以定位到每一个元素，通过下标访问数组元素的时间复杂度为O(1)。<br><br>但是正因为连续排列，所以插入和删除元素时，为了保证连续性，需要进行数据挪移。而数据挪移的平均时间复杂度为O(N)。<br><br>当然，如果数组中的数据不需要保持有序性，那么插入时可以用替换元素的方式代替数据挪移，时间复杂度为O(1)。删除元素可以采用“先标记删除，然后集中删除”的方式，也能减少数据搬移。<br><br>Java中ArrayList容器的底层数据结果是数组，并封装了数组的常用方法，使用很方便，并且能够做自动扩容。如果对性能要求不高的场景，可以直接使用。","like_count":0},{"had_liked":false,"id":314174,"user_name":"Im  feeling good","can_delete":false,"product_type":"c1","uid":1390627,"ip_address":"","ucode":"C899279EDB1D4E","user_header":"https://static001.geekbang.org/account/avatar/00/15/38/23/f2472c5b.jpg","comment_is_top":false,"comment_ctime":1632885873,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632885873","product_id":100017301,"comment_content":"看评论也能学到很多知识👍","like_count":0},{"had_liked":false,"id":314140,"user_name":"chase_hong","can_delete":false,"product_type":"c1","uid":2788958,"ip_address":"","ucode":"C8CC27ED0A5FD4","user_header":"https://static001.geekbang.org/account/avatar/00/2a/8e/5e/a9d5defc.jpg","comment_is_top":false,"comment_ctime":1632875543,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632875543","product_id":100017301,"comment_content":"我来杠一下，插入的时间复杂度的分析中，时间复杂度为O(1)的情况，说了没有顺序要求，那为什么一定要在位置k插入一个元素，既然本来在k位置的元素可以直接、无条件移到最后，那说明本来要插入在k位置的数据直接放到最后，应该也无伤大雅。能否再深入一点，或者举个例子","like_count":0},{"had_liked":false,"id":313727,"user_name":"我们在路上","can_delete":false,"product_type":"c1","uid":1183518,"ip_address":"","ucode":"0DB77DB7C64C47","user_header":"https://static001.geekbang.org/account/avatar/00/12/0f/1e/6b6eb987.jpg","comment_is_top":false,"comment_ctime":1632639757,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632639757","product_id":100017301,"comment_content":"给像我一样非科班出身的科普下概念：<br>所谓的大端模式（Big-endian），是指数据的高字节，保存在内存的低地址中，而数据的低字节，保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；<br><br>所谓的小端模式（Little-endian），是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低，和我们的逻辑方法一致。<br><br>为什么会有大小端模式之分呢？这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为 8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器），另外，对于位数大于 8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如何将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。<br><br>Intel的80x86系列芯片是唯一还在坚持使用小端的芯片，ARM芯片默认采用小端，但可以切换为大端；而MIPS等芯片要么采用全部大端的方式储存，要么提供选项支持大端——可以在大小端之间切换。另外，对于大小端的处理也和编译器的实现有关，在C语言中，默认是小端（但在一些对于单片机的实现中却是基于大端，比如Keil 51C），Java是平台无关的，默认是大端。在网络上传输数据普遍采用的都是大端。","like_count":0},{"had_liked":false,"id":313393,"user_name":"小于","can_delete":false,"product_type":"c1","uid":1723363,"ip_address":"","ucode":"F46D8A844277DF","user_header":"https://static001.geekbang.org/account/avatar/00/1a/4b/e3/5f354e60.jpg","comment_is_top":false,"comment_ctime":1632405216,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1632405216","product_id":100017301,"comment_content":"堆和栈老是分不清？","like_count":0},{"had_liked":false,"id":312746,"user_name":"lyt","can_delete":false,"product_type":"c1","uid":1526706,"ip_address":"","ucode":"8C179F339C2A27","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/OwolYO3ppfrxTcX81cswxNkD4tIlHM7vrnfroMzoTx878mDCnfJ3esicvbhm7ricUAbR7T9DjEDstVklh9z6uzjQ/132","comment_is_top":false,"comment_ctime":1631964196,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631964196","product_id":100017301,"comment_content":"N×M维二维数组a寻址公式，a[x][y]的内存地址=base_address + type_size * (x*M+y)","like_count":0},{"had_liked":false,"id":312364,"user_name":"Geek_7d3007","can_delete":false,"product_type":"c1","uid":2767122,"ip_address":"","ucode":"48BD6E6402C1B7","user_header":"","comment_is_top":false,"comment_ctime":1631774339,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631774339","product_id":100017301,"comment_content":"二维数组内存寻址： 对于 m * n 的数组，a [ i ][ j ] (i &lt; m,j &lt; n)的地址为： address = base_address + ( i * n + j) * type_size","like_count":0},{"had_liked":false,"id":311206,"user_name":"Aaron","can_delete":false,"product_type":"c1","uid":1104812,"ip_address":"","ucode":"DFE9AD55030805","user_header":"https://static001.geekbang.org/account/avatar/00/10/db/ac/d4f18665.jpg","comment_is_top":false,"comment_ctime":1631104462,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631104462","product_id":100017301,"comment_content":"学习这节课，收获颇多，越来越感觉算法的奇妙，对于程序而言，算法既是基础又是精华。<br>标记清除算法的设计初衷个人理解是: 一是为了更充分地利用cpu多线程运算能力，可以多线程并发扫描标记垃圾对象，二是先零星标记再批量清理，更高效率地回收内存。相应的副作用就是会有补连续的内存碎片产生，造成一定程度上的内存利用不充分，所以适用于内存比较大，回收停顿时间要求少的场景。","like_count":0},{"had_liked":false,"id":310113,"user_name":"Soopor","can_delete":false,"product_type":"c1","uid":1180151,"ip_address":"","ucode":"DD2C37A9892E9E","user_header":"https://static001.geekbang.org/account/avatar/00/12/01/f7/68e1e521.jpg","comment_is_top":false,"comment_ctime":1630488557,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630488557","product_id":100017301,"comment_content":"二维数组寻址方式通过一维寻址方式找到一位数组对应的位置，该位置存储的是二维的首地址，通过首地址重复寻址动作。","like_count":0},{"had_liked":false,"id":310093,"user_name":"Donkey","can_delete":false,"product_type":"c1","uid":2753834,"ip_address":"","ucode":"3DB4DFF6D99035","user_header":"https://static001.geekbang.org/account/avatar/00/2a/05/2a/cfbcb0b2.jpg","comment_is_top":false,"comment_ctime":1630483446,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630483446","product_id":100017301,"comment_content":"我有个疑问, 二维数组内存一定是连续的吗?<br>java代码:<br>int[][] ints = new int[2][];<br>ints[0] = new int[2];&#47;&#47;重新开辟空间<br>ints[1] = new int[3];<br>这样后指定的, 还是连续的吗?<br>望解答","like_count":0},{"had_liked":false,"id":309177,"user_name":"🌴林子洛","can_delete":false,"product_type":"c1","uid":2744724,"ip_address":"","ucode":"DE0C88D16AADF8","user_header":"https://static001.geekbang.org/account/avatar/00/29/e1/94/2c5e62d1.jpg","comment_is_top":false,"comment_ctime":1629968804,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629968804","product_id":100017301,"comment_content":"请问github上的代码都是什么题目呢？Md文件介绍的吗？对github不太熟悉有点乱","like_count":0},{"had_liked":false,"id":307760,"user_name":"一只半","can_delete":false,"product_type":"c1","uid":1475167,"ip_address":"","ucode":"9E3F1FF369D82C","user_header":"https://static001.geekbang.org/account/avatar/00/16/82/5f/8c6ae297.jpg","comment_is_top":false,"comment_ctime":1629248895,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1629248895","product_id":100017301,"comment_content":"环境：RHEL7.3<br>编译器：gcc version 4.8.5 20150623<br>代码：[root@localhost ~]# cat array.c<br>int main(int argc, char* argv[]){<br>    int i = 0;<br>    int arr[3] = {0};<br>    printf(&quot;%pn&quot;,&amp;i);<br>    for(; i&lt;=3; i++){<br>        arr[i] = 0;<br>        printf(&quot;hello world\\n&quot;);<br>        printf(&quot;%d %pn %pn&quot;,i,&amp;i,&amp;arr[i]);#打印变量i值，内存地址，数组成员内存地址<br>    }<br>    return 0;<br>}<br>运行结果：<br>[root@localhost ~]# .&#47;a.out<br>0x7ffef03c89dcnhello world<br>0 0x7ffef03c89dcn 0x7ffef03c89d0nhello world<br>1 0x7ffef03c89dcn 0x7ffef03c89d4nhello world<br>2 0x7ffef03c89dcn 0x7ffef03c89d8nhello world<br>0 0x7ffef03c89dcn 0x7ffef03c89d0nhello world<br>1 0x7ffef03c89dcn 0x7ffef03c89d4nhello world<br>2 0x7ffef03c89dcn 0x7ffef03c89d8nhello world<br>0 0x7ffef03c89dcn 0x7ffef03c89d0nhello world<br>1 0x7ffef03c89dcn 0x7ffef03c89d4nhello world<br>2 0x7ffef03c89dcn 0x7ffef03c89d8nhello world<br>0 0x7ffef03c89dcn 0x7ffef03c89d0nhello world<br>1 0x7ffef03c89dcn 0x7ffef03c89d4nhello world<br>2 0x7ffef03c89dcn 0x7ffef03c89d8nhello world<br>。<br>。<br>。<br>出现无限循环，从地址上看i确实在数组下面4bit。","like_count":0},{"had_liked":false,"id":307354,"user_name":"侯恩训","can_delete":false,"product_type":"c1","uid":1162376,"ip_address":"","ucode":"F4DC47EECA0F00","user_header":"https://static001.geekbang.org/account/avatar/00/11/bc/88/fbb6022e.jpg","comment_is_top":false,"comment_ctime":1629040686,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629040686","product_id":100017301,"comment_content":"学习总结： <br>1. 数组定义：线性表 连续空间 相同类型 随机访问<br>2. 随机访问时间复杂的O(1) 插入删除O(N), 某些特殊场景借助某些技巧插入和删除可以实现O(1)<br>3. 数组和arraylist：业务开发选择arraylist方便，扩容操作已经做好了，性能损失一丢丢；底层开发把性能压缩到极致可以考虑数组","like_count":0},{"had_liked":false,"id":307353,"user_name":"侯恩训","can_delete":false,"product_type":"c1","uid":1162376,"ip_address":"","ucode":"F4DC47EECA0F00","user_header":"https://static001.geekbang.org/account/avatar/00/11/bc/88/fbb6022e.jpg","comment_is_top":false,"comment_ctime":1629040402,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629040402","product_id":100017301,"comment_content":"2. address = addr_base + (i*n +j) * type_size","like_count":0},{"had_liked":false,"id":306544,"user_name":"测试昵称","can_delete":false,"product_type":"c1","uid":1107001,"ip_address":"","ucode":"8FC9D76F9E6584","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLg1BhBeNfibU9lW9fWWIhwRdqjmZzAJ6tW850qGibdFPmRia2CDIEAsYciaiag43ElaHRtBcHLggM9zuw/132","comment_is_top":false,"comment_ctime":1628603421,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628603421","product_id":100017301,"comment_content":"个人理解可能是地址存储的问题<br>数组实际地址的计算可能是base_address+offset*length<br>offset也是需要存储的 落到存储上就是二进制的 那么二进制无符号全空的状态就是全0换到十进制还是0所以数组下标的开始都是从0开始的","like_count":0},{"had_liked":false,"id":305801,"user_name":"微笑的鱼","can_delete":false,"product_type":"c1","uid":2150696,"ip_address":"","ucode":"8D32BA183BDF45","user_header":"https://static001.geekbang.org/account/avatar/00/20/d1/28/5e4c9547.jpg","comment_is_top":false,"comment_ctime":1628170119,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628170119","product_id":100017301,"comment_content":"二维数组寻址公式：a[i][j] _address= base_address+i*len*data_type_size+j*data_type_size","like_count":0},{"had_liked":false,"id":305498,"user_name":"黄争辉","can_delete":false,"product_type":"c1","uid":1070692,"ip_address":"","ucode":"970DD0C5D876FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/56/64/7d80093c.jpg","comment_is_top":false,"comment_ctime":1627999154,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627999154","product_id":100017301,"comment_content":"二维数组的寻址：a[m][n]<br>base_address + (i*n+j)type_address","like_count":0},{"had_liked":false,"id":305452,"user_name":"Dale","can_delete":false,"product_type":"c1","uid":1242602,"ip_address":"","ucode":"AD19A33FE5EEDF","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/ea/5f046856.jpg","comment_is_top":false,"comment_ctime":1627978605,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627978605","product_id":100017301,"comment_content":"用 JavaScript 实现了一个简易的标记删除<br>---------------------------------------------------------------<br>class PatchArray {<br>  callbacks = [];<br>  toDeleteIndexList = [];<br>  task = null;<br>  array = [];<br>  length = 0;<br>  constructor(array) {<br>    this.array = array || [];<br>    this.length = this.array.length;<br>  }<br>  $nextTick(fn) {<br>    if (!this.task) {<br>      this.callbacks.push(fn);<br>    } else {<br>      this.task.then(fn)<br>    }<br>  }<br>  deleteByIndex(index) {<br>    &#47;&#47; 每次执行并不真正删除，只是标记它应该被删除<br>    this.toDeleteIndexList.push(index);<br><br>    &#47;&#47; 利用 Promise 建立一个异步的微任务，模拟垃圾回收<br>    if (!this.task) {<br>      this.task = Promise.resolve();<br>      this.task.then(() =&gt; {<br>        this._patchDelete();<br><br>        const copy = this.callbacks.slice(0);<br>        this.callbacks = [];<br>        copy.forEach(cb =&gt; cb());<br>        this.task = null;<br>      })<br>    }<br>  }<br>  &#47;&#47; 真正执行删除操作<br>  _patchDelete() {<br>    for (let i = 0; i &lt; this.array.length; i++) {<br>      const offset = this.toDeleteIndexList.filter(item =&gt; item &lt; i).length;<br>      this.array[i - offset] = this.array[i];<br>    }<br>    this.length = this.array.length - this.toDeleteIndexList.length;<br><br>    &#47;&#47; 删除完成后，清理删除标记<br>    this.toDeleteIndexList = [];<br>  }<br><br>  &#47;&#47; array 中下标大于 length 属性的部分，实际已经删除<br>  getValue() {<br>    return this.array.slice(0, this.length);<br>  }<br>}<br><br>const patchArray = new PatchArray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);<br><br>patchArray.deleteByIndex(1);<br>patchArray.deleteByIndex(3);<br>patchArray.deleteByIndex(8);<br><br>&#47;&#47; 删除只是添加了一个删除标记，真实数据还没有被删除<br>console.log(&#39;before delete: &#39;, patchArray.getValue());  &#47;&#47; before delete: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br><br>&#47;&#47; 未来某个时刻才会真正批量删除<br>patchArray.$nextTick(() =&gt; {<br>  console.log(&#39;after delete: &#39;, patchArray.getValue()); &#47;&#47; after delete: [0, 2, 4, 5, 6, 7, 9, 10]<br>})<br>","like_count":0},{"had_liked":false,"id":304281,"user_name":"程序员二师兄","can_delete":false,"product_type":"c1","uid":1205697,"ip_address":"","ucode":"C9E3B5B3358BDF","user_header":"https://static001.geekbang.org/account/avatar/00/12/65/c1/afcd981b.jpg","comment_is_top":false,"comment_ctime":1627312685,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1627312685","product_id":100017301,"comment_content":"数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。<br><br>数组特性：<br><br>1. 线性表<br><br>线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。<br><br>非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。<br><br>2. 连续的内存空间和相同类型的数据<br><br>特性：“随机访问”。但有利就有弊，这两个限制也让数组的很多操作变得非常低效。<br><br>比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。<br><br><br>计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。<br><br>寻址公式：<br><br>`a[i]_address = base_address + i * data_type_size`<br><br><br>面试的时候，常常会问数组和链表的区别，很多人都回答说:<br><br>“链表适合插入、删除，时间复杂度 O(1)；<br>数组适合查找，查找时间复杂度为 O(1)”。<br><br>实际上，这种表述是不准确的。数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。<br><br>即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)。<br><br>所以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。<br><br>## 容器能否完全替代数组？<br><br>在项目开发中，什么时候适合用数组，什么时候适合用容器呢？<br><br>Java 工程师，几乎天天都在用 ArrayList，对它应该非常熟悉。那它与数组相比，到底有哪些优势呢？<br><br>**优势：**<br><br>ArrayList 最大的优势是可以将很多数组操作的细节封装起来，比如数组的插入、删除数据时需要搬移其他的数据等。<br><br>ArrayList 还有一个优势是支持动态扩容。每次存储空间不够的时候，它都会将空间自动扩容为 1.5 倍大小。<br><br>**注意点：**<br><br>因为扩容操作涉及内存申请和数据搬移，是比较耗时的。<br><br>所以，如果事先能确定需要存储的数据大小，最好在创建 ArrayList 的时候事先指定数据大小。<br><br>事先指定数据大小可以省掉很多次内存申请和数据搬移操作。<br><br>**什么情况下使用数组更合适?**<br><br>1. Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。<br><br>2. 如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。<br><br>3. 还有一个是我个人的喜好，当要表示多维数组时，用数组往往会更加直观。比如 Object[][] array；而用容器的话则需要这样定义：ArrayList &gt; array。<br><br>**总结：**<br><br><br>对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。<br><br>但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。<br><br><br>数组下标从 0 开始的好处：<br><br>从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。<br><br><br><br>## 课后题<br><br>1. 前面我基于数组的原理引出 JVM 的标记清除垃圾回收算法的核心理念。我不知道你是否使用 Java 语言，理解 JVM，如果你熟悉，可以在评论区回顾下你理解的标记清除垃圾回收算法。<br><br>2. 前面我们讲到一维数组的内存寻址公式，那你可以思考一下，类比一下，二维数组的内存寻址公式是怎样的呢？<br><br><br>答：<br><br>**JVM标记清除算法：**<br><br>大部分主流虚拟机采用的是可达性分析算法来判断对象是否存活，在标记截断，会遍历所有的 GC ROOTS。<br><br>将所有 GC ROOTS 可达的对象标记为存活。只有当标记完成后，清理工作才会开始。<br><br>不足：<br><br>1. 效率问题。标记和清理效率都不高，但是当只有少量垃圾产生时会很高效。<br><br>2. 空间问题。会产生不连续的内存空间碎片。<br><br>**二维数组内存寻址：**<br><br>对于 m * n 的数组，a [ i ][ j ] (i &lt; m,j &lt; n)的地址为：<br><br>`address = base_address + ( i * n + j) * type_size`<br><br><br><br>**标记清楚算法生活案例：**<br><br>突然想到了垃圾桶。<br>生活中，我们扔进屋里垃圾桶的垃圾，<br>并没有消失，只是被 &#39;&#39;标记&#39;&#39; 成了垃圾，<br>只有垃圾桶塞满时，才会清理垃圾桶。<br>再次存放垃圾<br>","like_count":0},{"had_liked":false,"id":303611,"user_name":"Geek_962f6d","can_delete":false,"product_type":"c1","uid":2705451,"ip_address":"","ucode":"5C9D1499BF10EA","user_header":"","comment_is_top":false,"comment_ctime":1626874539,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626874539","product_id":100017301,"comment_content":"标记-清除算法：根据GC机制的回收逻辑（引用计数法、可达性计数法）标记需要回收的对象，然后统一回收掉被标记的对象。缺点有：1.时间上：标记和清除的效率都不高；2.空间上：会产生大量不连续的空间碎片，当程序需要分配较大内存对象而无法找到足够的连续内存空间时，会不得不提前GC。","like_count":0},{"had_liked":false,"id":303585,"user_name":"哎呦先生","can_delete":false,"product_type":"c1","uid":1200430,"ip_address":"","ucode":"24076486C75030","user_header":"https://static001.geekbang.org/account/avatar/00/12/51/2e/6f7b0e7c.jpg","comment_is_top":false,"comment_ctime":1626864801,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1626864801","product_id":100017301,"comment_content":"数组存放同一类型的数据，这里在js中并不适合，js中一个数组可以存放任何类型的数据。","like_count":0},{"had_liked":false,"id":302757,"user_name":"Alex_GT","can_delete":false,"product_type":"c1","uid":1312926,"ip_address":"","ucode":"86ADB50A2736FA","user_header":"https://static001.geekbang.org/account/avatar/00/14/08/9e/ac07b0c8.jpg","comment_is_top":false,"comment_ctime":1626354996,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626354996","product_id":100017301,"comment_content":"05 为什么很多编程语言中数组都从0开始编号<br><br>1 数组的含义<br>数组—(Array)是一种线性表数据结构。它用一组连续连续的内存空间，来存储一组具有相同类型的数据。<br>特征1）线性，除了数组，线性数据结构还有队列、栈等，非线性的则有二叉树、堆、图等；<br>特征2）连续的内存空间和相同类型的数据<br><br>on one hand, 这两个特性给了数组“随机访问”的特性。<br>on the other hand, 数组的操作也变得抵消，在数组中删除、插入伴随着大量数据搬运工作。<br>简而言之，就是方便查询，增删复杂；<br>add：<br>￼<br>remove：<br>￼<br>此处将a,b,c删除，为了防止搬运三次，可以先记录下来数据已经被删除，等到数组空间不够时再进行搬运。这则类似于JVM标记清除垃圾回收的思想。<br><br>2 数组访问越界问题<br>尤其是在C语言中，只要是访问的内存不受限，则可以自由访问。当arr[length]位存储着循环控制变量i的时候。（这一例子依赖于C语言及系统环境分配内存的具体行为）。相对而言，java中能跑出越界Exception则省去了程序员许多麻烦。<br><br>3 容器能否替代数组<br>如java中的ArrayList，就封装了很多数组的操作（其最大优势），另外java中的ArrayList支持动态扩容（1.5倍）。当然，最好还是事先制定数据大小，以节省扩容搬运的操作。多数开发时，功能不复杂，牺牲一对对性能，使用方便的ArrayList完全ok。<br>确实方便，然而，on the other hand (again),ArrayList（java中）输给正常[ ]的地方在于：<br>1）ArrayList不能存储基础数据类型（int，long等）；<br>2）如果数据大小一致，操作也简单时；<br>3）多维数组更直观。<br><br>4 关于从0开始<br>一定程度上，有的高级语言如java、JavaScript都沿用C的特点从0编号。但也有的语言不是，比如matlab、python<br><br>结论：<br>平时的业务开发中，可以直接使用编程语言的容器类，如果是特别底层的开发，直接使用数组更合适。<br><br>思考题：<br>1.JVM的垃圾回收机制，仍需学习；<br>2.二维数组的位移量与一纬类似，arr[m][n]数组中，元素arr[a][b]的寻址位移量为 (a*m+b)*unit<br>","like_count":0},{"had_liked":false,"id":302484,"user_name":"Geek_842f07","can_delete":false,"product_type":"c1","uid":2698987,"ip_address":"","ucode":"ED772AF755FE7E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/WP4Ge8ABcINFkccKaNYKibicFnI0JAoojBBAUGrichNeRAgzm5RGbHG7GqYrFX3ELEzenuEbicQHJy2HZ72RxSOuMA/132","comment_is_top":false,"comment_ctime":1626237958,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626237958","product_id":100017301,"comment_content":"二维数组寻址公式<br><br>a[i][j]_address = base_address + i * type_size * j + i * type_size<br>= base_address + (j + 1) * i * type_size","like_count":0},{"had_liked":false,"id":301652,"user_name":"fei","can_delete":false,"product_type":"c1","uid":2691974,"ip_address":"","ucode":"CEB9A1C195A074","user_header":"https://static001.geekbang.org/account/avatar/00/29/13/86/89e255c3.jpg","comment_is_top":false,"comment_ctime":1625799367,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625799367","product_id":100017301,"comment_content":"jvm标记清除算法：GCROOT可达性分析后，对存活对象进行标记，标记后在某个cup时间片下进行清除操作，需要将不连续的内存整理为连续内存，并且清除操作会有大量的数据移动，比较耗时。适用于不频繁的jvm内存回收下使用。<br>二维数组寻址：a[k][j]_address = base_address + k * _address.length *  type_size + j * type_size","like_count":0},{"had_liked":false,"id":301528,"user_name":"爱Y","can_delete":false,"product_type":"c1","uid":2691123,"ip_address":"","ucode":"8EA65FBFE3F678","user_header":"https://static001.geekbang.org/account/avatar/00/29/10/33/ccf3d295.jpg","comment_is_top":false,"comment_ctime":1625728747,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625728747","product_id":100017301,"comment_content":"由于数组事线性的，二维数组首标是块，二标则是指要找的数据，这就像是可以折叠的蛇一样，所以把二维数组的长度拉长，等同于把一条弯曲的蛇拉长即是总长度，每折叠的那一下就是前面首标所指的块。公式自然就出来了","like_count":0},{"had_liked":false,"id":301055,"user_name":"Benson_Geek","can_delete":false,"product_type":"c1","uid":1519415,"ip_address":"","ucode":"D95B5C2BA09961","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/dr34H3hOMVsibL0XV1iaBWFiaTnYssX8sNjmJDpiaBUVv2X39nFzDjNpe288cKkZfH3P9sVRxZ1lzYZEcRR3vJNYtA/132","comment_is_top":false,"comment_ctime":1625498667,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625498667","product_id":100017301,"comment_content":"小笔记，<br>1. 数组为何从0开始，主要跟数组寻址有关，根据寻址公式a[k]_address = base_address + k * type_size，不从0开始则需要变成k - 1，CPU执行时需要多执行一条减法指令，优化性能极致故从0开始。<br>2. 内存中的栈从高地址向低地址分配<br>3. 标记清除法","like_count":0},{"had_liked":false,"id":300593,"user_name":"伟大嫡——waterG","can_delete":false,"product_type":"c1","uid":2681775,"ip_address":"","ucode":"E346C129C6011B","user_header":"https://static001.geekbang.org/account/avatar/00/28/eb/af/f9ebeffd.jpg","comment_is_top":false,"comment_ctime":1625235446,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625235446","product_id":100017301,"comment_content":"最后的二维数组算内存，例如a[i][j]，i&lt;m，j&lt;n<br>i和j都是从0开始，最后一个就是m*n-1<br>但变量是i和j，i=m-1，j=n-1<br>带进去，k=i*n+j","like_count":0},{"had_liked":false,"id":300559,"user_name":"节操何在😳","can_delete":false,"product_type":"c1","uid":2596050,"ip_address":"","ucode":"499C85C218ED84","user_header":"https://static001.geekbang.org/account/avatar/00/27/9c/d2/3c1b05ba.jpg","comment_is_top":false,"comment_ctime":1625218088,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625218088","product_id":100017301,"comment_content":"既然Arraylist 是存放类型相同的数据，那我也可以给它放入不同类型的对象。比如说，list.set(0,student) list.set(1,user) 还怎么寻址呢？来看看有没有人回答☺️。那如果我放长度不同的数组呢？","like_count":0},{"had_liked":false,"id":300495,"user_name":"WDNMD","can_delete":false,"product_type":"c1","uid":2665424,"ip_address":"","ucode":"222B48AEC7B068","user_header":"https://static001.geekbang.org/account/avatar/00/28/ab/d0/2b72354a.jpg","comment_is_top":false,"comment_ctime":1625196037,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625196037","product_id":100017301,"comment_content":"JavaScript的垃圾回收程序可以总结如下:<br>离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被删除。<br>主流的垃圾回收算法是标记清理，即先给当前不使用的值加上标记，再回来回收它们的内存。<br>引用计数是另一种垃圾回收策略，需要记录值被引用了多少次。JavaScript引擎不再使用这种算法，但某些旧版本的IE仍然会受这种算法的影响，原因是JavaScript会访问非原生JavaScript对象（如DOM元素）,造成循环引用问题<br>解除变量的引用不仅可以消除循环引用，而且对垃圾回收也有帮助。为促进内存回收，全局对象、全局对象的属性和循环引用都应该在不需要时解除引用。","like_count":0},{"had_liked":false,"id":300014,"user_name":"红尘","can_delete":false,"product_type":"c1","uid":1445504,"ip_address":"","ucode":"CCCD5736755DF5","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/gVfU7icdia3o5ZNaHjaWAdgkSYIpU1rdhIlVYiahYCvRlDZu2K6oPSvVobNjzwZbUaiayQcKjicZ44WjfWJCj5xdlPA/132","comment_is_top":false,"comment_ctime":1624955903,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624955903","product_id":100017301,"comment_content":"<br>数组是一种线性表数据结构，是一块连续的内存空间，存储的是一组相同的数据结构<br>线性表：就是数据排成像一条线一样的数据结构，每个线性表最多只有前和后两个方向，代表的是数组，栈，链表等<br>非线性表：数据结构并非只有前后两种简单的关系，代表的有树，图，堆等<br>因为数组是一块连续存储的内存空间和相同类型的数据结构，所以随机访问数据很快，<br>数组随机查找之所以这样快，是因为计算机会给每个内存单元分配一个地址，地址的计算公式，a[i]_address(实际地址) = base_address(初始化地址)+i(数组的下标)*data_type_size(数组中每个元素的字节大小)<br>数组支持随机访问，根据下标随机访问的时间复杂度为O（1）<br>有序数组和无序数组的区别，数组的长度是n<br>插入：<br>有序数组插入一个新元素时，就必须将插入数据的下标一直到数组的最后一位向后移动，比如插入的下标是k，那么数组将会在k位置移动数据（n-k）个，复杂度为O(N)<br>无序数组插入一个新元素时，如果插入的位置为k那么将k原来位置的元素取出来，放在数组的末尾，将新元素放入在下标k的位置，复杂度为O(1)<br>删除<br>有序数组删除一个元素和插入元素是一样的逻辑，时间复杂度为O(N)<br>无序数组删除一个元素会采用jvm垃圾回收算法的标记清扫算法，也叫惰性删除，先将需要删除的数据标记，等到数据空间不够用的时候，再统一执行删除操作。<br>标记清扫算法缺点容易产生内存碎片，导致出现虽然内存空间充足，但是会出出现无法放置的诡异现象<br>之所以数组从0开始，因为数组的每个数据都会分配一个内存地址，如果数组从1开始，那么每次计算的逻辑都会是a[i]_address(实际地址) = base_address(初始化地址)+(i-1)(数组的下标)*data_type_size(数组中每个元素的字节大小)，这样cpu每次都会做一次减法运算。<br>容器和数组的区别：<br>容器支持动态扩容，封装了数组的很多操作，例如arrayList，扩容比较消耗内存，如果是业务开发的话开发用容器就足够， 如果对于底层的开发，性能优化，可以选择数组<br>二维数组计算内存地址<br>因为一维数组的公式a[i]_address = base_address+i*data_type_size<br>所以m * n 二维数组为a[i][j]_address= base_address+(i*n+j)*data_type_size","like_count":0},{"had_liked":false,"id":299754,"user_name":"王加武","can_delete":false,"product_type":"c1","uid":1665471,"ip_address":"","ucode":"DDCFE578C6C428","user_header":"https://static001.geekbang.org/account/avatar/00/19/69/bf/50a824a4.jpg","comment_is_top":false,"comment_ctime":1624845752,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624845752","product_id":100017301,"comment_content":"Jvm标记清除算法<br>从根集合开始扫描、对存活的对象进行标记，然后扫描整个内存空间，回收未被标记的对象<br>但是也有缺点的，此算法需要暂停整个应用，会产生内存碎片，也就是说当程序运行时，若可以使用的内存被耗尽，GC线程就会被触发并将程序暂停，随后将依旧存活的对象标记一遍，最终再将堆中所有没被标记的对象全部清除，接下来程序恢复运行","like_count":0},{"had_liked":false,"id":299220,"user_name":"Geek_039a5c","can_delete":false,"product_type":"c1","uid":1651848,"ip_address":"","ucode":"08F4FA864D4B65","user_header":"","comment_is_top":false,"comment_ctime":1624516607,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1624516607","product_id":100017301,"comment_content":"假设二维数组是[i][j]<br><br>对于array[x][y] 的寻址公式是 base_address +x*j*data_type_size +y*data_type_size","like_count":0},{"had_liked":false,"id":298628,"user_name":"Geek_4051d2","can_delete":false,"product_type":"c1","uid":2660938,"ip_address":"","ucode":"F439D59087C990","user_header":"","comment_is_top":false,"comment_ctime":1624243013,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624243013","product_id":100017301,"comment_content":"JVM<br>标记算法<br><br>引用计数算法：给每个对象添加一个引用计数器，当被引用时，计算器加1，当引用失效时，计算器减1<br><br>可达性分析算法：通过一系列GCRoots，往下遍历，遍历所走过的路径被称为引用链，当一个对象没有引用链跟GCRoots关联时，表示对象“已死”<br><br>JAVA语言采用可达性分析算法，为什么不使用引用计数算法是因为对象如果存在循环引用，会导致对象永远无法被回收，导致内存泄漏，如果内存泄漏多了，就导致内存溢出，而python语言则使用引用计数算法<br><br>标记清除算法：首先通过标记算法，标记还存活的对象，然后清除掉未标记的对象，缺点清理后内存空间不连续，需要使用空闲列表来记录那些空闲内存<br><br>复制算法：将内存空间划分为大小相同的两块，每次只使用其中一块，当一块内存使用完后，将还存活的对象，复制到另一块内存中，然后清理掉使用完的内存，缺点内存使用率减少一半<br><br>标记整理算法：标记过程与标记清除算法类似，标记完后，将还存活对象往一端移动，然后清理掉边界外的内存<br><br>分代收集算法：没有什么新思想，而是根据对象存活时间的不同使用不同的算法，新生代，对象大部分朝生夕死，可以使用复制算法，只需付出一点内存代价，老年代，对象存活时间长，没有额外的担保空间，可以使用标记清除算法或标记整理算法<br><br>二维数组内存寻址<br>a[i][j]_address = base_address + (i*n+j) * type_size ","like_count":0},{"had_liked":false,"id":297493,"user_name":"Geek_2c8a24","can_delete":false,"product_type":"c1","uid":2334040,"ip_address":"","ucode":"5DDD7AEF3668A8","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/4O0oeYUkS2GuRrhEQCYY62YISgSbLrWMNG3FjagMQm9icGlLTH2AIIibWia3ZYxGvI8mp8LXagv4DkNRjAgh4hCyg/132","comment_is_top":false,"comment_ctime":1623578294,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623578294","product_id":100017301,"comment_content":"a[k][ i]_address = base_address + (k*n+i) * type_size","like_count":0},{"had_liked":false,"id":297405,"user_name":"小肥羊","can_delete":false,"product_type":"c1","uid":1081582,"ip_address":"","ucode":"9F44BAA1A59FAD","user_header":"https://static001.geekbang.org/account/avatar/00/10/80/ee/bbee3ec1.jpg","comment_is_top":false,"comment_ctime":1623504885,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623504885","product_id":100017301,"comment_content":"通过思考二维数组的寻址方式，我想我知道为啥数组定义的时候要定长了。<br>非定长的数组没法记录准确的跨度，所以也就没法准确的寻址了。<br>","like_count":0},{"had_liked":false,"id":296988,"user_name":"PG","can_delete":false,"product_type":"c1","uid":1249747,"ip_address":"","ucode":"722E7668E5F0E5","user_header":"https://static001.geekbang.org/account/avatar/00/13/11/d3/795d79af.jpg","comment_is_top":false,"comment_ctime":1623251319,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623251319","product_id":100017301,"comment_content":"数组这个例子真的牵扯了一大堆基础知识，编译原理，计算机系统","like_count":0},{"had_liked":false,"id":295815,"user_name":"下雨天","can_delete":false,"product_type":"c1","uid":1413399,"ip_address":"","ucode":"FB3851E3A79C3B","user_header":"https://static001.geekbang.org/account/avatar/00/15/91/17/89c3d249.jpg","comment_is_top":false,"comment_ctime":1622609082,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622609082","product_id":100017301,"comment_content":"对于m行n列的数组，第i行j列的数据的寻址公式为：arr[i][j] = base_address+(n*i+j)*type_size","like_count":0},{"had_liked":false,"id":295715,"user_name":"Issac慜","can_delete":false,"product_type":"c1","uid":1793361,"ip_address":"","ucode":"690B69FC1C0BB2","user_header":"https://static001.geekbang.org/account/avatar/00/1b/5d/51/87fc7ef9.jpg","comment_is_top":false,"comment_ctime":1622556147,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622556147","product_id":100017301,"comment_content":"二维数组按列存储： a [ i ] [ j ]的地址 = 首地址 + (i * col + j) * 元素大小，其中的col是二维数组的列数。<br>二维数组按行存储： a [ i ] [ j ]的地址 = 首地址 + (j * row + i) * 元素大小，其中的row是二维数组的行数。","like_count":0},{"had_liked":false,"id":295544,"user_name":"小Y","can_delete":false,"product_type":"c1","uid":1739621,"ip_address":"","ucode":"24A43BB71805F8","user_header":"https://static001.geekbang.org/account/avatar/00/1a/8b/65/0f1f9a10.jpg","comment_is_top":false,"comment_ctime":1622471204,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622471204","product_id":100017301,"comment_content":"一维数组a: a[i]_address = base_address + i*type_size<br>二维数组a: m行n列，a[i][j]_address = base_address + (i*n+j) * type_size","like_count":0},{"had_liked":false,"id":295510,"user_name":"海崖","can_delete":false,"product_type":"c1","uid":2552745,"ip_address":"","ucode":"9D42E0B0D30A56","user_header":"https://static001.geekbang.org/account/avatar/00/26/f3/a9/bb9d8450.jpg","comment_is_top":false,"comment_ctime":1622455642,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622455642","product_id":100017301,"comment_content":"叮~打卡！","like_count":0},{"had_liked":false,"id":294735,"user_name":"Geek_28d7d8","can_delete":false,"product_type":"c1","uid":2616650,"ip_address":"","ucode":"191033029D8E5A","user_header":"","comment_is_top":false,"comment_ctime":1622078065,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622078065","product_id":100017301,"comment_content":"i=3的时候为什么会无线循环下去","like_count":0},{"had_liked":false,"id":294329,"user_name":"YNANG","can_delete":false,"product_type":"c1","uid":2630811,"ip_address":"","ucode":"4EB5D4899134DA","user_header":"https://static001.geekbang.org/account/avatar/00/28/24/9b/3394b626.jpg","comment_is_top":false,"comment_ctime":1621901791,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621901791","product_id":100017301,"comment_content":"规定集合长度向其中添加一千万个元素所需时间为16毫秒，不规定集合长度向其中添加一千万个元素所需时间为2680毫秒🧐","like_count":0},{"had_liked":false,"id":294191,"user_name":"夜薇","can_delete":false,"product_type":"c1","uid":1331222,"ip_address":"","ucode":"B63B6AAE5A1F05","user_header":"https://static001.geekbang.org/account/avatar/00/14/50/16/509de8df.jpg","comment_is_top":false,"comment_ctime":1621825223,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621825223","product_id":100017301,"comment_content":"一：JVM垃圾回收算法：<br>1.标记-清除法：对对象已经死掉的内存空间进行标记，触发GC时，进行清除。后果时造成大量的内存碎片，不利于大对象的内存分配。<br>2.标记-整理法：对对象已经死掉的内存空间进行标记，GC时，将存活的对象向内存的一侧进行移动，同时清除掉边界以外的所有内存。<br>3.回收算法：将内存分成两半，一次使用其中的一半，回收是将活着的内存转移到另一半，同时对这一半进行清除<br>4.分代回收：将内存分为新生代和老年代。新生代是新对象的内存区域，老年代是存活时间比较长的对象所在。因为复制算法对于老年代对象来说，需要多次执行复制操作，效率低下，所以老年代一般不采用复制算法，而是标记-整理算法。而新生代每次都是大量的对手死去，少量的活下来，所以才用复制算法。<br><br>二、二维数组(m*n)的寻址<br><br>a[i][j]_address = base_address + (i*n+j)*type_size<br>","like_count":0},{"had_liked":false,"id":293789,"user_name":"M.O(∩_∩)O","can_delete":false,"product_type":"c1","uid":1498641,"ip_address":"","ucode":"B245C2BA20DDA8","user_header":"https://static001.geekbang.org/account/avatar/00/16/de/11/72f96304.jpg","comment_is_top":false,"comment_ctime":1621557929,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621557929","product_id":100017301,"comment_content":"JVM标记清除算法：分为标记和清除两个阶段<br>标记：根据可达性分析算法判断对象是否存活，对存活对象标记或对为存活对象标记<br>清除：根据标记方式的不同，进行清除未标记的回收对象或清除标记的回收对像<br>缺点：执行效率会随着对象数量的增长二降低；存在空间碎片化问题<br><br>二维数组内存寻址：<br>若二维数据a[m][n]  那a[i][j]_address=base_address+(i*n+j)*type_size","like_count":0},{"had_liked":false,"id":293552,"user_name":"葡萄糖sugar","can_delete":false,"product_type":"c1","uid":2600726,"ip_address":"","ucode":"82559E37922976","user_header":"https://static001.geekbang.org/account/avatar/00/27/af/16/51149d2b.jpg","comment_is_top":false,"comment_ctime":1621428518,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621428518","product_id":100017301,"comment_content":"JVM回收算法主要有三种算法，标记清除，标记整理，标记复制，前者是最开始提出来的，标记复制是为了解决前者不足而改进的算法，而标记整理是为了解决标记复制的不足而设计的。标记清除算法，首先会标记所有存活对象（反过来也可以），之后对其他消亡的对象进行清除内存的操作。该操作优点就是简单，缺点也很明显，首先就是如果存在大量地存活对象，那么虚拟机就不得不进行大量地标记。还有一个是会产生大量地内存碎片，使得可能存在大对象无法分配而导致FULL GC的情况，所以几乎没有收集老年代的收集器采取这种算法（CMS除外，CMS也因此有这个缺点）。后面两种通过复制或是移动的方式避免了这种方式，但同时也带来更大的移动开销。","like_count":0},{"had_liked":false,"id":293541,"user_name":"Gryffindor🎃Muggle","can_delete":false,"product_type":"c1","uid":1405246,"ip_address":"","ucode":"49406E2A1EB3F3","user_header":"https://static001.geekbang.org/account/avatar/00/15/71/3e/ed5b929c.jpg","comment_is_top":false,"comment_ctime":1621424817,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621424817","product_id":100017301,"comment_content":"疑问：无线循环例子中，假如现在需要插入在数组中下标1插入一个元素？未插入之前数组a和变量i是连续的内存地址空间，文章插入一节讲到插入需要搬移下标1之后的元素，那么此时i的地址需要搬移吗？还是编译器直接重新开辟一块新的内存地址，预分配四个连续内存地址，进行插入操作，这种操作情况下，假设循环条件变为i&lt;= 4，应该不会发生无线循环的结果了吧？如果需要搬移，假如i之后有很多变量i1,i2....in都需要搬移吗？也还是会发生无线循环吧？  谢谢老师解答","like_count":0},{"had_liked":false,"id":293210,"user_name":"蔡","can_delete":false,"product_type":"c1","uid":2569296,"ip_address":"","ucode":"9FE10683CED9F7","user_header":"https://static001.geekbang.org/account/avatar/00/27/34/50/74306b5b.jpg","comment_is_top":false,"comment_ctime":1621265728,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621265728","product_id":100017301,"comment_content":"1、JVM垃圾标记清理算法：还没复习JAVA的八股文，先谈下之前理解的算法思想吧。JVM首先利用一个先验，也即大多数对象新建后被使用一小段时间即死亡，而有的对象如果过了很长时间还没死亡，那么接下来大概率也会继续留存。因此先将存放对象的堆分成年轻代和年老代，分别用来存储容易年轻对象和年老对象，引入分代回收的思想。标记清理算法是在gc的时候，先通过比如选定一系列GC roots进行引用可达分析，标记出不可用（死亡对象），而后将其内存释放也即清理的过程。当然这个清理会导致空间碎片的问题产生，后续的复制算法或者标记整理法也是在这个的基础上提出的，同时又考虑分代年龄层死亡几率的特点，复制用于年轻代，标记整理用于年老代。<br>2、假设数组定义为arr[3][5]，则arr[1][2]的内存位置为base_add+1*5*type_size+2*type_size<br>本节感悟：感觉作者引人入胜的能力好强，将一个简单的数组结构，与内存连续性，随机访问，插入删除的特定情景，为何从0开始，同时与溢出攻击等甚至JVM垃圾回收等问题串联起来，真是受益匪浅","like_count":0},{"had_liked":false,"id":292846,"user_name":"刘易宁","can_delete":false,"product_type":"c1","uid":1566569,"ip_address":"","ucode":"EE337683D08B9A","user_header":"https://static001.geekbang.org/account/avatar/00/17/e7/69/0c426b52.jpg","comment_is_top":false,"comment_ctime":1621007873,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621007873","product_id":100017301,"comment_content":"课后思考题：<br>1、标记清除垃圾回收算法：分为两个阶段，首先将需要清除的垃圾标记出来，在标记完成后统一进行清除<br>2、int a[n][m] = {}<br>a[i][j]_address = base_address + (i * m + j) * type_size","like_count":0},{"had_liked":false,"id":292819,"user_name":"布小丁","can_delete":false,"product_type":"c1","uid":2577268,"ip_address":"","ucode":"3EDD7C5A0E4C8C","user_header":"https://static001.geekbang.org/account/avatar/00/27/53/74/17c18b44.jpg","comment_is_top":false,"comment_ctime":1620993697,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620993697","product_id":100017301,"comment_content":"“我们知道，在 C 语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。根据我们前面讲的数组寻址公式，a[3]也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。”<br>请问，这里和JavaScript不一样吧，js不会存在这个问题","like_count":0},{"had_liked":false,"id":292613,"user_name":"落","can_delete":false,"product_type":"c1","uid":2275817,"ip_address":"","ucode":"79525752D3A1B1","user_header":"https://static001.geekbang.org/account/avatar/00/22/b9/e9/19cd7d9c.jpg","comment_is_top":false,"comment_ctime":1620895449,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620895449","product_id":100017301,"comment_content":"标记清除算法：<br>1.标记阶段：遍历所有的GC Roots，将所有可达的对象标记为存活对象<br>2.清除阶段：遍历堆下的所有对象，将没有被标记的对象清除掉<br><br>二维数组：<br>假设数组为n*m的二维数组,i&lt;n,j&lt;m<br>a[i][j]_address = base_address + (i*m + j)*data_type_size","like_count":0},{"had_liked":false,"id":291447,"user_name":"焱","can_delete":false,"product_type":"c1","uid":1113301,"ip_address":"","ucode":"677BF1BE4B94D5","user_header":"https://static001.geekbang.org/account/avatar/00/10/fc/d5/1cf5fd56.jpg","comment_is_top":false,"comment_ctime":1620290613,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620290613","product_id":100017301,"comment_content":"1.jvm标记清理，感觉就是一个缓存池，池子满了触发清理操作减少平凡gc次数这样想不知道对不对<br>2.二维数组的那个我试了下一，每次都要先把横坐标排完才到下一个a[m][n] 假设m，n都是3则是a[0][0]<br>,a[0][1],a[0][2],a[1][0],a[1][1],a[1][2],a[2][0],a[2][1],a[2][2]依次排列如果要唯一确定地址则依据一维数组类推公式如下： a[0][0] = base_address + ( 0 * 3 + 0) * type_size<br>                     a[0][1] = base_address + ( 0 * 3 + 1) * type_size<br>                     a[0][2] = base_address + ( 0 * 3 + 2) * type_size<br>          .........  a[m] [n] =  base_address + ( i * n + j) * type_size<br><br>                    ","like_count":0},{"had_liked":false,"id":291436,"user_name":"孑然う枫Phoenix","can_delete":false,"product_type":"c1","uid":2159434,"ip_address":"","ucode":"12F83DFC5693C2","user_header":"https://static001.geekbang.org/account/avatar/00/20/f3/4a/6aab64c4.jpg","comment_is_top":false,"comment_ctime":1620287639,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620287639","product_id":100017301,"comment_content":"有个疑问，在低效的“插入”和“删除”那里的插入操作例子中，最坏时间复杂度的情况下，需要移动n个元素，那n个元素的移动方式是什么样的啊，是第一个移到第二个，第二个移到第三个么，那1-&gt;2的时候，2的数据要怎么保留，在移动的时候一定要移动n次么","like_count":0},{"had_liked":false,"id":291200,"user_name":"Geek_694aed","can_delete":false,"product_type":"c1","uid":2574357,"ip_address":"","ucode":"E8BAE339FC99EC","user_header":"","comment_is_top":false,"comment_ctime":1620112660,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620112660","product_id":100017301,"comment_content":"对于m*n的二维数组，a[i][j]的地址为address = base_address + (i*n+j)*type_size","like_count":0},{"had_liked":false,"id":290882,"user_name":"双木公子","can_delete":false,"product_type":"c1","uid":1116567,"ip_address":"","ucode":"751885864D3AB7","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/97/4314e2d8.jpg","comment_is_top":false,"comment_ctime":1619831874,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619831874","product_id":100017301,"comment_content":"标记清除算法：<br>JVM采用可达性算法判断对象是否存活，在标记阶段，会遍历所有GC ROOTS，将所有GC ROOTS可达的对象标记为存活，标记工作完成后，清除工作就会开始。<br><br>缺点：（1）标记和清除的效率都不高，但是当知道只有少量垃圾产生时，效率会比较高。（2）会产生大量的内存碎片 <br><br>访问二维数组的方法：<br>对于 m * n 的数组，a [ i ][ j ] (i &lt; m,j &lt; n)的地址为：<br><br>address = base_address + ( i * n + j) * type_size<br>","like_count":0},{"had_liked":false,"id":290846,"user_name":"焱","can_delete":false,"product_type":"c1","uid":1113301,"ip_address":"","ucode":"677BF1BE4B94D5","user_header":"https://static001.geekbang.org/account/avatar/00/10/fc/d5/1cf5fd56.jpg","comment_is_top":false,"comment_ctime":1619778354,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619778354","product_id":100017301,"comment_content":" base_address + (i*n+j) * type_size;","like_count":0},{"had_liked":false,"id":290666,"user_name":"Kami","can_delete":false,"product_type":"c1","uid":1498216,"ip_address":"","ucode":"AE1DA7A7AB2F4F","user_header":"https://static001.geekbang.org/account/avatar/00/16/dc/68/b6668932.jpg","comment_is_top":false,"comment_ctime":1619681245,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1619681245","product_id":100017301,"comment_content":"关于样例代码循环：<br><br>[ebp - 0x04] -&gt; 局部变量i的内存<br>[ebp - 0x08] -&gt; 局部数据变量arr下标i=2<br>[ebp - 0x0C] -&gt; 局部数据变量arr下标i=1<br>[ebp - 0x10]  -&gt; 局部数据变量arr下标i=0<br><br>如果是在堆上分配，可能就会触发中断，像C语言程序都是一堆0xCC，但在栈上分配的话，i=4的话，内存就溢出到变量i了，有一种服务器攻击手法就是类似strcpy这种拷贝数据不带长度，会溢出到栈上去，然后替换ret地址到任意内存位置，实现远程执行代码然后提权。","like_count":0},{"had_liked":false,"id":290508,"user_name":"马志远","can_delete":false,"product_type":"c1","uid":1480892,"ip_address":"","ucode":"AAD8875343E5FC","user_header":"https://static001.geekbang.org/account/avatar/00/16/98/bc/6d5affd3.jpg","comment_is_top":false,"comment_ctime":1619596391,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619596391","product_id":100017301,"comment_content":"# 数组总结  <br>### ==1.如何实现随机访问？== <br>**==定义==:**  <br>数组（Array）是一种线性表数据结构。它用一组==连续==的内存空间，来存储一组具有相同类型的数据。  <br>数据结构按照内存存储结构划分: 1.连续内存 2.非连续内存  <br>数据结构: 用来表示数据关系的，不同的数据结构表示不同的数据之间的关系。实际存储方式还是只有==连续和非连续两种==  <br><br>==**特性**:==  <br>数组是适合查找操作，但是查找的时间复杂度并不为O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)  <br>数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)  <br><br>### ==2.低效的“插入”和“删除”==<br>**==插入操作==**:   <br>1.==有序插入== 平均时间复杂度O(n)  <br>2.==非有序插入==   时间复杂度O(1)   <br>例如:将元素 x 插入到第 3 个位置。我们只需要将 c 放入到 a[5]，将 a[2]赋值为 x 即可。最后，数组中的元素如下： a，b，x，d，e，c。<br><br>**==删除操作==**:  <br>1.==有序删除== 平均时间复杂度O(n)  <br>2.==非有序删除==   时间复杂度O(1)   <br>例如:  <br>数组 a[10]中存储了8个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除 a，b，c 三个元素。为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。  <br><br>### ==3.警惕数组的访问越界问题==  <br>**出现死循环**  <br><br>### ==4.容器能否完全替代数组？==  <br>**ArrayList特点:**  <br>1. 可以将很多数组操作的细节封装起来  <br>2. 可以将很多数组操作的细节封装起来进行1.5倍扩容  <br><br>注意点:  <br>因为扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好在创建 ArrayList 的时候事先指定数据大小。  <br>数组和容器的选择:  <br>1. Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。  <br>2. 如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。  <br>3. 当要表示多维数组时，用数组往往会更加直观。比如 Object[][] array；而用容器的话则需要这样定义：ArrayList&lt;ArrayList&lt;object&gt; &gt; array。","like_count":0},{"had_liked":false,"id":290014,"user_name":"小马哥","can_delete":false,"product_type":"c1","uid":1358045,"ip_address":"","ucode":"B2C0FF38F8C9BC","user_header":"https://static001.geekbang.org/account/avatar/00/14/b8/dd/37726c34.jpg","comment_is_top":false,"comment_ctime":1619321649,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619321649","product_id":100017301,"comment_content":"Q1: 标记清除垃圾回收算法。<br>A1: 失去引用的对象标记为可以被删除, 记录垃圾对象占用的空间地址, JVM到达没有可分配空间的时间点, 一次删除所有可被回收空间, 多个删除动作累积在一次进行, 减少了移动数据的操作<br><br>Q2:二维数组的内存寻址公式<br>A2: 设数组的形状是: array[m][n]<br>\tarray[j][i] = baseAddress + (j*n+i)*dataType","like_count":0},{"had_liked":false,"id":289876,"user_name":"Allan","can_delete":false,"product_type":"c1","uid":1310388,"ip_address":"","ucode":"8DA4DBECC2C45C","user_header":"https://static001.geekbang.org/account/avatar/00/13/fe/b4/295338e7.jpg","comment_is_top":false,"comment_ctime":1619246310,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619246310","product_id":100017301,"comment_content":"第三波：<br>1、标记清除 算法是最基础的算法，之后的算法大多都是以他为基础。标记清除 分为两部分，一是标记，而是清除。先标记哪些对象需要清除，然后统一回收所有标记的对象。标记清除的缺点：第一个执行效率不稳定，如果java中包含大量的对象，并且都是需要被回收的。那么就需要进行大量的标记和清除动作，随着对象的增加标记清除的执行效率就会降低。第二个 清除完后会产生内存碎片也就是空间不连续，导致有大对象存储时候没法获取到空间从而不得不提前触发另一次垃圾收集动作。<br>2、二维数组 array[n][m]，根据一位数组的寻址方式，array[i][j] = base_address + (i*m+j)*type_size,就是我们二维数组那个点所在的位置，i表示第几行 * m就表示所在位置之前有多少个点，一行有m个点，i行实际是说的 真实行数-1的全行，然后再加上 j就表示本行的第几个位置，这样一加起来就是总共的点。 ","like_count":0},{"had_liked":false,"id":289850,"user_name":"千无","can_delete":false,"product_type":"c1","uid":1813715,"ip_address":"","ucode":"C43C9D532AE50A","user_header":"https://static001.geekbang.org/account/avatar/00/1b/ac/d3/3e461046.jpg","comment_is_top":false,"comment_ctime":1619230488,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1619230488","product_id":100017301,"comment_content":"<br>前面解释没问题，但公式想差了，表述方式也很业务，学习前排同学的评论后，做个纠正。<br><br>二维数组内存寻址：<br><br>对于 m * n 的数组，a [ i ][ j ] (i &lt; m,j &lt; n)的地址为：<br><br>address = base_address + i * n *type_size + j * type_size<br>","like_count":0},{"had_liked":false,"id":289849,"user_name":"千无","can_delete":false,"product_type":"c1","uid":1813715,"ip_address":"","ucode":"C43C9D532AE50A","user_header":"https://static001.geekbang.org/account/avatar/00/1b/ac/d3/3e461046.jpg","comment_is_top":false,"comment_ctime":1619230274,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1619230274","product_id":100017301,"comment_content":"二维数组也是数组，也申请了一段连续的内存空间。<br>那么对于二维数组array[][](一维、二维长度分别为m,n)来说，从物理视觉上看，它实际就是m个长度为n的一维数组连续拼接在一起，成为一个长度为m*n的一维数组。<br>那么对于a[i][j]来说，它的寻址公式就呼之欲出了，即a[i][j]_address=base_address+i*(m-1)*type_size + j*type_size。<br>简单解释就是，基址+前面一维数组的总偏移量+它在当前一维数组的偏移量。<br>","like_count":0},{"had_liked":false,"id":289807,"user_name":"颜桦","can_delete":false,"product_type":"c1","uid":1099576,"ip_address":"","ucode":"1CD7250E052B32","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/38/d1a50cd6.jpg","comment_is_top":false,"comment_ctime":1619182331,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1619182331","product_id":100017301,"comment_content":"老师，数组内的元素也不都是相同类型吧，比如Java中如果定一个object类型的数组，元素可以是任意类型，这种也是连续存储的吗？","like_count":0,"discussions":[{"author":{"id":1099576,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c7/38/d1a50cd6.jpg","nickname":"颜桦","note":"","ucode":"1CD7250E052B32","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370536,"discussion_content":"老师能解答一下吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619446055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":289578,"user_name":"卢克糖","can_delete":false,"product_type":"c1","uid":1897816,"ip_address":"","ucode":"8F3B1D8C2A1423","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f5/58/5c9ba9aa.jpg","comment_is_top":false,"comment_ctime":1619087256,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619087256","product_id":100017301,"comment_content":"本片得到：<br>1.数组就是：线性数据结构+连续内存空间<br>2.数组的随机访问复杂度O(1)，查找复杂度O(n)<br>3.数组删除优化：标记删除法。<br>4.数组插入优化：替换转移数组末端法(特定场景适用)。<br>5.不同语言对数组下标的处理，下标以0起始的原因：下标表示地址偏移量。<br>6.数组的优势：省去封装的功夫，性能比较高。","like_count":0},{"had_liked":false,"id":289189,"user_name":"胡了","can_delete":false,"product_type":"c1","uid":1042339,"ip_address":"","ucode":"A36D7870DD0783","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e7/a3/229d9704.jpg","comment_is_top":false,"comment_ctime":1618907444,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1618907444","product_id":100017301,"comment_content":"请问老师，如果数组存储的是引用类型String，那么每个元素占用多少个字节？String可存储的字符到底最大是多少？","like_count":0},{"had_liked":false,"id":288959,"user_name":"Melon","can_delete":false,"product_type":"c1","uid":1339586,"ip_address":"","ucode":"8E4A96B3BA0239","user_header":"https://static001.geekbang.org/account/avatar/00/14/70/c2/0df5cc71.jpg","comment_is_top":false,"comment_ctime":1618799293,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618799293","product_id":100017301,"comment_content":"标记清除：我想应该是事先设置一个阈值，内存使用达到阈值，触发gc。做可达性分析，从gc roots开始标记可达对象，那么剩下不可达的对象即可回收对象，将其清除。<br>缺点：<br>1.stw<br>2.内存碎片","like_count":0},{"had_liked":false,"id":288709,"user_name":"yang","can_delete":false,"product_type":"c1","uid":1940562,"ip_address":"","ucode":"67C86E09BA6E4B","user_header":"https://static001.geekbang.org/account/avatar/00/1d/9c/52/dc770378.jpg","comment_is_top":false,"comment_ctime":1618634645,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618634645","product_id":100017301,"comment_content":"我就很喜欢matlab的从1开始的数组下标。","like_count":0},{"had_liked":false,"id":288512,"user_name":"等等 女皇","can_delete":false,"product_type":"c1","uid":1549661,"ip_address":"","ucode":"81423644144550","user_header":"https://static001.geekbang.org/account/avatar/00/17/a5/5d/22829a03.jpg","comment_is_top":false,"comment_ctime":1618499960,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618499960","product_id":100017301,"comment_content":"老师你的图都是用什么工具画的呀 好有趣","like_count":0},{"had_liked":false,"id":288304,"user_name":"黑桃8","can_delete":false,"product_type":"c1","uid":2528072,"ip_address":"","ucode":"EB57A46B0A1AD2","user_header":"https://static001.geekbang.org/account/avatar/00/26/93/48/8d9c5672.jpg","comment_is_top":false,"comment_ctime":1618401323,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618401323","product_id":100017301,"comment_content":"数组的特点：<br>  1. 线性表 -&gt; 数据最多只有前后两个方向<br>  2. 连续内存空间内存储类型相同的数据 -&gt; 支持根据下标随机访问 O(1)<br><br>数组的缺陷：<br>  为了保证插入&#47;删除后，依旧能够保持有序性&#47;连续性，需要进行数据搬移 平均O(n)<br>    在没有有序性要求的数组中，插入可以优化为：将要插入位置的数据移至数组末尾，并插入数据 平均O(1)<br>    在没有连续性要求的数组中，删除可以先标记，待数组中没有空余位置时，触发一次数据搬移 均摊O(1)<br><br>容器ArrayList的优点：<br>  1. 封装了很多数组的操作细节，方便使用<br>  2. 通过申请1.5倍的新数组，并执行数据搬移已达到动态扩容 均摊O(1)<br>适合使用数组，而非容器的情况：<br>  1. 在使用基本类型时，避免自动拆装箱操作<br>  2. 在数组大小固定，并且操作相对简单时<br>  3. 在标示二维数组时<br><br>数组下标为什么从0开始：<br>  1. 下标表示偏移量<br>  2. 根据下标计算存储地址时，可以减少一次减法指令<br>  3. 向C语言看齐<br><br>使用数组&#47;容器时，需要注意：<br>  1. 数组下标越界问题<br>  2. ArrayList在能估算出数据量的情况下，应该初始化大小","like_count":0},{"had_liked":false,"id":287606,"user_name":"Geek_ecef6d","can_delete":false,"product_type":"c1","uid":2541756,"ip_address":"","ucode":"82F607FDBE110B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/T1yWWsOsVjpw9URXBMv86LnBh0T2BS66P6I1RGiaSe0lLKv2wFXYGaJdTdUXsLuUuoicjABQsP2XfzCia6knAy23g/132","comment_is_top":false,"comment_ctime":1618046971,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618046971","product_id":100017301,"comment_content":"1、数组支持根据下标随机访问，时间复杂度为O(1)<br>2、数组的插入和删除操作，最好时间复杂度为O(1)，最坏时间复杂度为O(n)，平均时间复杂度也为O(n)。<br>3、警惕数组的越界访问<br>4、数组和容器类选用对比","like_count":0},{"had_liked":false,"id":287588,"user_name":"oops","can_delete":false,"product_type":"c1","uid":1102831,"ip_address":"","ucode":"1DEC23A503F8A3","user_header":"https://static001.geekbang.org/account/avatar/00/10/d3/ef/9c5e695b.jpg","comment_is_top":false,"comment_ctime":1618040832,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618040832","product_id":100017301,"comment_content":"用可达性分析算 判断对象是否存活。以GC ROOT为起点开始搜索对象图，搜索的路径叫做引用链，如果一个对象到任何GC ROOTs 都没有引用链时，表示不可用。<br>三色标记 白 灰 黑<br>初始标记：三色标记会先GC roots 标记到灰色集合。<br>并发标记：从GC roots开始搜索对象图<br>重新标记：纠正并发标记阶段 错标，漏标的虚像<br>并发清楚：白色集合的对象表示可以回收","like_count":0},{"had_liked":false,"id":287115,"user_name":"孙思强","can_delete":false,"product_type":"c1","uid":1813790,"ip_address":"","ucode":"6E3F01DDFC1310","user_header":"https://static001.geekbang.org/account/avatar/00/1b/ad/1e/aeb8d6f3.jpg","comment_is_top":false,"comment_ctime":1617782132,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617782132","product_id":100017301,"comment_content":"1.标记清除算法：当一个对象失效的时候jvm回对该对象标记为删除状态，展示不进行垃圾回收，当内存空间不足的时候会扫描内存中所有拥有删除标记的对象统一进行垃圾回收。<br>2.a[k，i]_address = base_address + k * type_size+i*type_high  我猜的<br>","like_count":0},{"had_liked":false,"id":287060,"user_name":"张知信","can_delete":false,"product_type":"c1","uid":2144474,"ip_address":"","ucode":"7C896BB3214B3D","user_header":"https://static001.geekbang.org/account/avatar/00/20/b8/da/42284f64.jpg","comment_is_top":false,"comment_ctime":1617763475,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617763475","product_id":100017301,"comment_content":"数组最重要的特性是支持 O(1) 的下标随机访问，之所以能 O(1) 是因为可以根据元素类型 (每个元素多大) + 下标 (偏移) 直接计算出内存地址。这也决定了数组必须连续并且只能存储相同类型的元素，否则就不能直接计算内存地址。<br>当进行插入 (删除) 操作时，为了继续保证 O(1) 的随机访问，我们不得不移动插入 (删除) 位置之后的元素。<br>所以天下没有免费的午餐，为了保证 O(1) 的随机访问，我们就必须在插入 (删除) 的时候做更多的处理。而链表正好相反，链表在进行插入和删除的时候，只要 O(1) 的时间复杂度，我们无需做其他额外操作，随之而来的查找代价是 O(n) 。","like_count":0},{"had_liked":false,"id":286664,"user_name":"Peter","can_delete":false,"product_type":"c1","uid":1808601,"ip_address":"","ucode":"FCEAC9E4D89C86","user_header":"https://static001.geekbang.org/account/avatar/00/1b/98/d9/aa77514b.jpg","comment_is_top":false,"comment_ctime":1617464437,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617464437","product_id":100017301,"comment_content":"老师，为什么我用vs2015编译运行就没有进入死循环？","like_count":0},{"had_liked":false,"id":286662,"user_name":"hhk","can_delete":false,"product_type":"c1","uid":1138826,"ip_address":"","ucode":"72EC677FBDC79B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/gvfibNc3Bol6DzLMG5ia9wSLVYseoq326iae7TczmgmBj9u3Jwt8c0hl9KSzY4GNTFn0ic9m1ibzicqJ3aGzeQemec2Q/132","comment_is_top":false,"comment_ctime":1617462794,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617462794","product_id":100017301,"comment_content":"# 05 | 数组：为什么很多编程语言中数组都从0开始编号？<br><br>数组用一组连续的内存空间, 来存储一组具有相同类型的数据, 是一种线性表(linear list)<br><br><br><br>## CRUD<br><br>因为是连续的内存空间+数据类型相同, 所以可以根据下标算出元素对应内存地址<br><br><br><br>对于读取和更新: 可以根据数组下标随机访问元素, 复杂度是O(1)<br><br><br><br>对于插入和删除:<br><br>得看是否需要保证数组的连续性<br><br>如果需要保证插入或者删除以后, 数组仍然有序, 那就必须得做大量的数据搬移工作, 复杂度是O(n)<br><br>如果不需要的话, 那可以做一些优化<br><br>比如插入的时候, 直接插入到对应下标, 下标原来有的元素直接放到数组后面<br><br>删除时候, 可以先逻辑删除, 把要删除的元素先标记起来, 等没有更多内存空间存数据的时候, 再触发一次真正的删除操作, 这个时候才去搬移数据<br><br><br><br>## 数组越界<br><br>数组越界在c里是undefined behavior, 需要程序员自己去保证数组没有越界<br><br>java会抛 java.lang.ArrayIndexOutOfBoundsException 异常<br><br>js的数组其实有些特殊, 和这里的数组不太搭嘎, 更像java里的ArrayList和C++ STL中的vector 等学多一点再补充<br><br><br><br>## 下标从0开始?<br><br>大学上课的时候老师都应该有讲过这个问题<br><br>可以参考知乎里的一些问题<br><br> https:&#47;&#47;www.zhihu.com&#47;question&#47;24289367<br><br>https:&#47;&#47;www.zhihu.com&#47;question&#47;23323374<br><br>用0开始来算内存地址是可以理论上减少一次减法操作的:<br><br>比如一维数组, 求`a[k]`:<br><br>```<br>0 based:<br>a[k]_address = base_address + k * type_size<br><br>1 based:<br>a[k]_address = base_address + (k - 1) * type_size<br>```<br><br>我更倾向是一种偏好, 历史原因, 非要用1的话matlab就是<br><br><br><br>## 课后思考<br><br>- JVM垃圾回收, 前端不熟JVM, 但是我也不熟悉V8, 以后看情况补补吧<br><br>- 二维数组内存寻址公式, 假设 mxn 的二维数组, 求`a[i][j]`<br><br>  ```<br>  a[i][j]_address = base_address + (i*n + j) * type_size<br>  ```<br><br>https:&#47;&#47;github.com&#47;acfasj&#47;blog&#47;issues&#47;2#issuecomment-812878508<br><br><br><br><br><br><br>","like_count":0},{"had_liked":false,"id":285370,"user_name":"洛北","can_delete":false,"product_type":"c1","uid":1050515,"ip_address":"","ucode":"CD14C21BC17709","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/93/997aa75f.jpg","comment_is_top":false,"comment_ctime":1616756782,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616756782","product_id":100017301,"comment_content":"1.先STW标记出GC Roots直接指向的对象<br>2.然后标记出间接引用的对象<br>3.STW标记出第2步新增的对象<br>4.回收掉不可达对象","like_count":0},{"had_liked":false,"id":285050,"user_name":"Mmi223","can_delete":false,"product_type":"c1","uid":1150430,"ip_address":"","ucode":"A49A024333C01C","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/HOIjvMJfj8Qg9EdLyvLXEldpo3qEhHOpsibFaAb7kc4wc6xoHQqKX7gUO3YHhnAJHFdibdI7Mef0cZ9zLsRlpQ2Q/132","comment_is_top":false,"comment_ctime":1616592088,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616592088","product_id":100017301,"comment_content":"对于mxn数组，a[i][j]=base_address + (i*n+j)*type_size","like_count":0},{"had_liked":false,"id":284766,"user_name":"Geek_272a2e","can_delete":false,"product_type":"c1","uid":1691776,"ip_address":"","ucode":"C3F82497030D0C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLibX06ACicicBdkD4hkSTkVm9fIT1xwdXV52GvQahFmTVSFHhxbDWjNOk5mdwE3hRFLO6QjRYIKoffA/132","comment_is_top":false,"comment_ctime":1616464617,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616464617","product_id":100017301,"comment_content":"标记清除算法：<br>从GC Root 集合开始遍历内存空间，将GC Root能够直接或间接引用到的对象进行标记，剩下的对象则当做垃圾处理，过程分为两步<br>1. 标记阶段：从GC Root开始遍历，对所有直接或间接引用到的对象进行标记，剩余的对象标记为垃圾对象<br>2. 清除阶段：将垃圾对象进行清除，回收内存空间<br><br>优点：实现简单，不需要移动对象<br>缺点：由于清除对象后并不会重新整理内存空间，容易产生内存碎片，提高垃圾回收频率，<br>同时算法执行时也会中断其它组件的运行<br><br>二维数组寻址公式<br>对于一个有m行n列的二维数组a[m][n]，第x行y列的地址为<br>a[x][y] = a0 + (x - 1) * n * type_size + (y-1) * type_size<br>二维数组的存储结构是先存储一行的所有元素，然后存储下一行，<br>所以 (x - 1) * n * type_size 表示从0行0列到x行0列占用的内存大小，(y-1) * type_size 表示从x行0列开始到x行y列占用的内存大小，相加即从0行0列到x行y列占用的内存大小。<br><br><br><br><br>","like_count":0},{"had_liked":false,"id":284709,"user_name":"LJM","can_delete":false,"product_type":"c1","uid":1009242,"ip_address":"","ucode":"39FDF66A5C6FEB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/66/5a/e3d19ed0.jpg","comment_is_top":false,"comment_ctime":1616424821,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616424821","product_id":100017301,"comment_content":"详解数据结构中的“数组”与编程语言中的“数组”的区别和联系 https:&#47;&#47;juejin.cn&#47;post&#47;6844903813749407757","like_count":0},{"had_liked":false,"id":284575,"user_name":"小青蛙和大公鸡","can_delete":false,"product_type":"c1","uid":1006657,"ip_address":"","ucode":"C0D23CBA1B8F8E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/41/bf2c9ae0.jpg","comment_is_top":false,"comment_ctime":1616370014,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616370014","product_id":100017301,"comment_content":"笔记<br>1.数组定义:线性表.连续内存空间，相同类型数据<br>2.操作和时间负责度: <br>a .随机读取 O(1) 根据数据起点位置指针 + 查询元素下标*存储类型的长度(字节)<br>b. 指定下标的插入 O(n) 需要向后搬移插入元素下之后的元素-对不要求顺序数组，可以通过交换元素来优化<br>c. 指定下标删除 O(n) 需要向前搬移删除元素之后的元素-可以通过先逻辑删除，等到数组存储不足够时，将逻辑删除的元素一起物理删除，并重新调整数组 - 类似jvm的标记清除算法<br>3.Java中arraylist与数组的比较<br>a. arraylist提供了丰富api(随机下标读取，自动扩容, 插入，删除，遍历)，数组需要自己实现<br>b. array list不支持基本类型，如int存储，需要封装为对象类型， 数组支持直接存储基本类型<br>4.为什么数组用下标0开始<br>a.极致的性能 - 少减一次<br>b.历史原因:c就是用0开始做下标的，后续Java跟着c，其实有，写语言的array已经不是从0开始了，如Python支持负数的下标","like_count":0},{"had_liked":false,"id":283552,"user_name":"quan","can_delete":false,"product_type":"c1","uid":2523818,"ip_address":"","ucode":"1D9BDED7F4FDCA","user_header":"","comment_is_top":false,"comment_ctime":1615815379,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615815379","product_id":100017301,"comment_content":"random access，是否翻译成任意访问比较合适呢？我实在理解不了数组的随机访问是怎么个随机法，翻译成任意会不会更贴切？","like_count":0},{"had_liked":false,"id":283457,"user_name":"心静如水","can_delete":false,"product_type":"c1","uid":1712523,"ip_address":"","ucode":"295631D721C3FD","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/HFTNSboUOlebZEG3sFa4ewCWkyYyTFGhQhDYT4lQ1XgLBGG6JozjibygicofEG2fJBH5zru4ckA4ryOnrRKIKOvQ/132","comment_is_top":false,"comment_ctime":1615790819,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615790819","product_id":100017301,"comment_content":"c语言数组下标从0开始的话，计算偏移地址的语句就能写的简洁些了","like_count":0},{"had_liked":false,"id":283359,"user_name":"小童","can_delete":false,"product_type":"c1","uid":1763395,"ip_address":"","ucode":"300444B520E79D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/e8/43/f9c0faed.jpg","comment_is_top":false,"comment_ctime":1615726488,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615726488","product_id":100017301,"comment_content":"笔记:<br>数组特点:<br>1. 具有随机访问性;<br>2.寻址公式: address=base_address + i*type_size;","like_count":0},{"had_liked":false,"id":283179,"user_name":"生海","can_delete":false,"product_type":"c1","uid":2510297,"ip_address":"","ucode":"1FFBB0E56CE380","user_header":"https://static001.geekbang.org/account/avatar/00/26/4d/d9/e3cc62f3.jpg","comment_is_top":false,"comment_ctime":1615608605,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615608605","product_id":100017301,"comment_content":"第二题：如果【m，n】数组按行排列，i &lt; m, j &lt; n, arr[i][j]_address = base_address + (j * m + i) * data_type_size<br>如果【m，n】数组按列排列，i &lt; m, j &lt; n， arr[i][j]_address = base_address + (i * n + j)*data_type_size","like_count":0},{"had_liked":false,"id":283123,"user_name":"Houdini_Z","can_delete":false,"product_type":"c1","uid":2502008,"ip_address":"","ucode":"E8830E556EF087","user_header":"https://static001.geekbang.org/account/avatar/00/26/2d/78/53161394.jpg","comment_is_top":false,"comment_ctime":1615559111,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615559111","product_id":100017301,"comment_content":"数据结构和算法的教学帖看的不少了，能把一个最简单的数组讲的那么妙的还真是罕见，感谢王争老师。<br>同时感谢各位大佬写的笔记，受益匪浅。","like_count":0},{"had_liked":false,"id":282759,"user_name":"Charles","can_delete":false,"product_type":"c1","uid":1088301,"ip_address":"","ucode":"996D0F4B6196E5","user_header":"https://static001.geekbang.org/account/avatar/00/10/9b/2d/8afd979f.jpg","comment_is_top":false,"comment_ctime":1615389661,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615389661","product_id":100017301,"comment_content":"数组下标为啥从0开始？没啥道理，因为最早的语言从 0 开始，哈哈哈哈！我想起了那个梗，为什么运载火箭的宽度是两匹马的屁股决定的。","like_count":0},{"had_liked":false,"id":282735,"user_name":"米饭噗噗","can_delete":false,"product_type":"c1","uid":1902239,"ip_address":"","ucode":"9E7AECF01CE84C","user_header":"https://static001.geekbang.org/account/avatar/00/1d/06/9f/5a6e5f17.jpg","comment_is_top":false,"comment_ctime":1615382560,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615382560","product_id":100017301,"comment_content":"看了评论里大家的分享感受颇深，自己总结几点<br>1、首先是二维数组的寻址公式，首先二维是一个面，大家可以想象二维寻址就是在面上点一个点，然后一列一列的画线过去，直到画到那个点位置；这样的话、三维、四维、多维度的寻址公式也不难分析，从点到面最后到体一步步往下走即可<br>2、老师在文章中分享了一个很重要的点就是：”数组的查找元素时间复杂度为O(1)“；老实讲我一开始也没反应过来，”按照下标查找确实是O(1)啊？“我一开始也这么想，但是老师这么一讲瞬间觉得有些羞愧，如果数组查找的时间复杂度是O(1)，那么很多复杂的算法也就不需要了，直接存在数组里面多方便，数组只是通过下标来访问元素的时候时间复杂度是O(1)罢了<br>3、还有老师对于垃圾回收算法的推广以及学习方法的总结也是赞，评论区一位同学的”垃圾桶“例子也是十分的形象易懂","like_count":0},{"had_liked":false,"id":282571,"user_name":"terrytian","can_delete":false,"product_type":"c1","uid":1235217,"ip_address":"","ucode":"04FA907AEA16AF","user_header":"https://static001.geekbang.org/account/avatar/00/12/d9/11/f180f34a.jpg","comment_is_top":false,"comment_ctime":1615304176,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615304176","product_id":100017301,"comment_content":"JVM标记清除算法;<br>首先需要确定那一些是垃圾，主要有两种方式：<br>1.GCROOTS 可达性分析：标记阶段，会遍历所有的GCROOTS对象，GCROOTS到对象的路径为可达链，有可达链的对象则为存活的，然后将不存活的清理掉，主流虚拟机都采用这种方式；<br>2.计数器：对象被使用时，使用次数+1；不使用时，对象使用次数-1；当GC时，如果对象的使用次数为0，则在标记阶段，将非0的标记为存活，将不存货的清理掉。<br>二维数组内存寻址：<br><br>对于 m * n 的数组，a [ i ][ j ] (i &lt; m,j &lt; n)的地址为：<br><br>address = base_address + ( i * n + j) * type_size","like_count":0},{"had_liked":false,"id":281924,"user_name":"Geek_86a66d","can_delete":false,"product_type":"c1","uid":2107673,"ip_address":"","ucode":"24E996C5FF91A3","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erWv2fBsDOF4R5uxUqjVt6e5eF20blU0Vvf8fHxrtncoNR0f8uZ9jnoKhgg7vCOoCfrG3ibs8UHxXA/132","comment_is_top":false,"comment_ctime":1614953004,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614953004","product_id":100017301,"comment_content":"看评论，都是年薪百万的","like_count":0},{"had_liked":false,"id":281863,"user_name":"这就是生活","can_delete":false,"product_type":"c1","uid":2378295,"ip_address":"","ucode":"847EE53DA017C8","user_header":"https://static001.geekbang.org/account/avatar/00/24/4a/37/fb06fb79.jpg","comment_is_top":false,"comment_ctime":1614929000,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614929000","product_id":100017301,"comment_content":"j*k   我是把他想成一个矩阵<br>j行 k列   每行k个元素<br>那么[x,y]元素的地址为：<br>address[x,y] = base_address + (x*k + y) * type_size<br>（感觉这个地方挺拧巴的，就是因为从0开始）<br><br>JVM内存回收理解有限<br>现在基本上用的都是分代策略了<br>年轻代<br>       8：1：1的比例分Eden 、 servivor0 、和servivor1     <br>       采用的copying策略的停止复制法      在换位置的时候程序等待时间长、内存使用效率高，但是使用率只有二分之一<br>       新分配的实例占据Eden，回收发生时，Eden中存活的对象复制到S0中，清空Eden<br>       当S0满了，就把Eden和S0中存活的实例复制到S1中，并清空Eden和S0，并把S1和S0互换位置<br>       当S1已经存不下Eden和S0中的存活的实例的时候，则将所有存活的实例放到年老代中<br><br>年老代<br>       是年轻代的两倍空间，如果满了触发一次major GC 采用的是需要句柄和句柄表的标记整理策法<br>       <br>持久代<br>       就是JVM中的方法区，方法区分三部分  已加载类信息区  运行时常量池   JIT编码区<br>       已加载类信息区 包括8个部分   类信息、类常量、类成员变量、类静态变量、方法信息、方法表<br>                                                     类实例的引用（反射用）  类加载器的引用（区分声明空间） <br>       运行时常量池就是程序运行起来后，类信息区中的类变量<br>       JIT（JUST IN TIME）即时编译器 编译出来的部分重复性高的本地字节码<br>       这里面很少进行GC操作<br>          1，方法区内的所有常量如果没有了引用则回收<br>          2，类信息区中的类回收要达到三个条件    堆中没有它任何的实例、加载它的类加载器已经被回收、类信息区中的类原始实例没有任何地方引用且在任何地方都无法通过反射访问此类的方法（最后一条好严格，其实最后一条满足了，前两天就已经满足了，因为反射访问只能在声明空间内进行，而同一声明空间又是通过查看是否是同一个加载器加载的）<br><br>       根检索算法是判断对象是否存活的方法基础   即标记<br>       至于是标记清除    还是标记整理    还是停止复制   都需要用到<br>       GC ROOTS是根集合，其中包括7种  两堆两栈一线程一加载一GC<br>       两堆      方法区类常量引用的对象、方法区类静态变量引用的对象<br>       两栈      虚拟机栈种局部变量表种引用的对象、本地方法栈JNI引用的对象<br>       一线程     运行中的线程中引用的对象<br>       一加载器     由启动类加载器加载的类的对象<br>       一GC           GC控制的对象<br>       凡是和上面有直接关系或者间接关系的统统铐起来带走（哦，不   是标记为存活对象）<br>       其他对象标记为无用对象，等死就完了。<br><br>        感谢老师让我又回忆了一次JVM内存回收的知识（好多都忘记了，又回去翻的笔记）<br>        ","like_count":0},{"had_liked":false,"id":281733,"user_name":"小青年","can_delete":false,"product_type":"c1","uid":2034735,"ip_address":"","ucode":"7168E10235A2E5","user_header":"https://static001.geekbang.org/account/avatar/00/1f/0c/2f/a9cbcb76.jpg","comment_is_top":false,"comment_ctime":1614862970,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614862970","product_id":100017301,"comment_content":"PHP的数组？","like_count":0},{"had_liked":false,"id":281717,"user_name":"Geek_08cfb9","can_delete":false,"product_type":"c1","uid":2117748,"ip_address":"","ucode":"F3A863AA0B16D7","user_header":"https://static001.geekbang.org/account/avatar/00/20/50/74/67009969.jpg","comment_is_top":false,"comment_ctime":1614857178,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614857178","product_id":100017301,"comment_content":"1. 本节的主题? 作者从哪几个角度进行讲解?<br>答:本节讲解了数组, 从问题入手讲解了数组的定义,寻址方式,如何能高效的使用数组及数组的使用场景.<br>2. 本节的分论点是全部有道理还是部分有道理?<br>  答:关于这点&quot;如果你了解 JVM，你会发现，这不就是 JVM 标记清除垃圾回收算法的核心思想吗？&quot; 关于先标记后清除,减少内存碎片是一个原因,jvm的可达性分析也是一个原因<br>3. 这节和我有什么关系?哪里可能用到?<br>   答:数组是数据结构的基础,在学习其它数据结构时要思考其与数组的关系.<br> <br>","like_count":0},{"had_liked":false,"id":281337,"user_name":"Ting.","can_delete":false,"product_type":"c1","uid":1016882,"ip_address":"","ucode":"9C424A538F7B56","user_header":"https://static001.geekbang.org/account/avatar/00/0f/84/32/f84d9ca5.jpg","comment_is_top":false,"comment_ctime":1614694838,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614694838","product_id":100017301,"comment_content":"又是笔记比内容还多的一课。","like_count":0},{"had_liked":false,"id":280882,"user_name":"songYH","can_delete":false,"product_type":"c1","uid":2382651,"ip_address":"","ucode":"ABB2C4D2518840","user_header":"https://static001.geekbang.org/account/avatar/00/24/5b/3b/397214f2.jpg","comment_is_top":false,"comment_ctime":1614437462,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614437462","product_id":100017301,"comment_content":"数组采用一块连续的内存空间，来存储相同类型的一组数据，最大的特点是支持随机访问，但插入删除操作也因此变得比较低效。address = base_address+(i*n+j)*type_size","like_count":0},{"had_liked":false,"id":280257,"user_name":"罗耀龙@坐忘","can_delete":false,"product_type":"c1","uid":1917663,"ip_address":"","ucode":"3CEA258DE7F3C7","user_header":"https://static001.geekbang.org/account/avatar/00/1d/42/df/a034455d.jpg","comment_is_top":false,"comment_ctime":1614144532,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1614144532","product_id":100017301,"comment_content":"茶艺师学编程<br><br>要刷新的知识点：<br><br>1、数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。<br><br>2、数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。<br><br>3、a[k]_address = base_address + k * type_size   首地址+偏移<br><br>4、小心下标越界<br><br>5、删除，有一个一个的删，也有先标记好然后一起删的<br><br>思考题：<br><br>1、不会<br><br>2、我猜的，先算后面，再算前面的。","like_count":0},{"had_liked":false,"id":280246,"user_name":"陈威洋","can_delete":false,"product_type":"c1","uid":2264679,"ip_address":"","ucode":"DCF84B4D3A7354","user_header":"https://static001.geekbang.org/account/avatar/00/22/8e/67/afb412fb.jpg","comment_is_top":false,"comment_ctime":1614141658,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614141658","product_id":100017301,"comment_content":"1. JVM 的标记清除垃圾回收算法：就像你在房间里学习，打了喷嚏用到了纸巾就放在桌面的靠近门的位置，但没有扔到一楼的垃圾桶，因为不可能每次用完纸巾就下去一楼扔掉，很浪费时间，所以你暂时放在桌面的靠近门的位置，这时候你妈来看你来了，发现一堆用过的纸巾，就帮你清理掉了，保持你桌面的干净，是不是很感谢你妈妈，帮你省时间了。<br>2. 至于二维内存地址，应该是套用一个公式就能计算： i * n + j，n表示第一维的大小。<br><br><br>看完所有评论，深深可怜下老师的手机：<br><br>你们都是用手打的这么多字吗？ 如果手打的话用pad真的不够方便呀。你们是不是在电脑端看的啊？ 如果要是用APP并能手打的话。记忆力太好了<br>作者回复: 用手机回复留言都把我搞崩溃很多次了！<br>","like_count":0},{"had_liked":false,"id":279164,"user_name":"北极的大企鹅","can_delete":false,"product_type":"c1","uid":1045577,"ip_address":"","ucode":"8935346D08E109","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f4/49/2add4f6b.jpg","comment_is_top":false,"comment_ctime":1613641423,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613641423","product_id":100017301,"comment_content":"这一节讲解了数组下标为何从0开始,有的编程语言不从0开始(Matlab),有的反而也用负数做下标(Python)","like_count":0},{"had_liked":false,"id":279124,"user_name":"Geek_368e95","can_delete":false,"product_type":"c1","uid":2445352,"ip_address":"","ucode":"936C239BC0BCED","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/OHbDdelsu57BYPr2Nak32oMVq8b2OOx9rMhZXuWbMwmDnla31FK0IODreSfQCiaVhUJK4slJW6ichUYUoq84Kwhg/132","comment_is_top":false,"comment_ctime":1613630146,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613630146","product_id":100017301,"comment_content":"老师的理解的确深刻，足见内功深厚。<br>我回忆一下本章：<br>1、数组是一种的线性表结构。特点是：需要连续的内存空间，存放相同类型的数据。<br>线性表结构：诸如数组、链表、栈（可以串成直线）。非线性表结构：如树、图。<br>补：数组元素a[i]地址计算：item_addr = base_addr + i * type_size<br>2、数组优点：支持随机访问，已知下标下的随机访问的时间复杂度为O(1)；数组缺点：删除、插入这类结构性改变（改变长度）时间复杂度为O(n)。<br>3、上述两个缺点的打补丁思想：①插入：空位法：把原位置元素挪到末尾去，从而位置空出来，时间复杂度降为O(1)。②删除：标记延后清除法：删除时先采用标记位来伪删除，待插入时空间不够再统一删除和基址归位（数组向左挪动，使得连续）。（JVM中GC的标记清除法也才用此思想）<br>4、ArrayList与数组：ArrayList是对数组常用操作的封装，提供一个官方的轮子，省去了一些底层逻辑，比如add时的扩容（java大多数情况为1.5倍），insert时的右侧元素挪动，delete时向左重新整合。<br>补：因为扩容会产生性能消耗，所以建议如果已知要存储大量数据，可在初始化ArrayList时设置好初始大小，以减少扩容产生。<br>5、数组中ArrayList难以替代的优点：①支持基础数据类型，而容器仅支持包装类型，且box、unbox有性能消耗。②表示二维时，数组int[][]比List&lt;List&lt;Integer&gt;&gt;操作方便。<br><br>总结：<br>什么时候用数组：①元素项少，变动不大，操作简单时。②多维元素时。③希望使用基础数据类型时。<br>④非常看重性能时，如底层框架开发<br>（但对大多数业务开发者来说，ArrayList使用得多，因为官方封装的足够好了）","like_count":0},{"had_liked":false,"id":278787,"user_name":"陈峯","can_delete":false,"product_type":"c1","uid":2414165,"ip_address":"","ucode":"7337EB89B92E99","user_header":"https://static001.geekbang.org/account/avatar/00/24/d6/55/7031ebdc.jpg","comment_is_top":false,"comment_ctime":1613348867,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613348867","product_id":100017301,"comment_content":"<br>a[f][k]_address = base_address + f*total_column*type_size+ k * type_size","like_count":0},{"had_liked":false,"id":278422,"user_name":"八九","can_delete":false,"product_type":"c1","uid":1191617,"ip_address":"","ucode":"B996A884BFA474","user_header":"https://static001.geekbang.org/account/avatar/00/12/2e/c1/0fcd29ab.jpg","comment_is_top":false,"comment_ctime":1612938361,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612938361","product_id":100017301,"comment_content":"总结：<br>1.数组：线性表数据结构，具有相同的数据类型。<br>\t线性表:前和后两个方向（数组、链表、队列、栈）<br>\t非线性表：数据之间并不是简单的前后关系（二叉树、堆、图）<br>2.连续的内存空间和相同类型的数据使数组具有随机访问的特性。数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。<br>3.数组插入：len=n，将一个数据插入到数组中的第k个位置。<br>\t1)插末尾：O(1)、插开头：O(n)、平均：O(n)<br>\t2)数组有序，k放末尾，新元素放k的位置：O(1)\t\t<br>4.数组删除:删除k，为了内存连续性，需要搬移数据，不然中间就出现了空洞，就不连续了。<br>\t1)删末尾：O(1)、删开头：O(n)、平均：O(n)<br>\t2)记录下要删除的，当数组没有更多空间存储数据时，再触发一次真正的删除，减少了删除导致的数据搬移。<br>5.警惕数组越界问题<br>c访问：访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不报任何异常。<br>       数组越界在 C 语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。<br>java访问：会做越界检查。<br>6.关于数组越界访问导致死循环的问题（评论：slvher）<br>函数体内的局部变量存在栈上，且是连续压栈。在Linux进程的内存布局中，栈区在高地址空间，从高向低增长。<br>变量i和arr在相邻地址，且i比arr的地址大，所以arr越界正好访问到i。当然，前提是i和arr元素同类型，否则那段代码仍是未决行为。<br>这个结果和编译器的实现有关，gcc有一个编译选项（-fno-stack-protector）用于关闭堆栈保护功能。<br>默认情况下启动了堆栈保护，不管i声明在前还是在后，i都会在数组之后压栈，<br>开启了堆栈保护的程序中，局部变量的顺序被重新组织了。如果关闭堆栈保护功能，则会出现死循环。<br>7.容器能否替代数组<br>ArrayList的优势：可以将很多数组操作的细节封装起来；支持动态扩容（自动扩容1.5倍）<br>*在创建ArrayList的时候事先指定数组大小可以省掉很多次内存申请和数据搬移操作（扩容）。<br>\t1)ArrayList无法存储基本类型，而拆箱、装箱会有性能损耗，特别关注性能且希望使用基本类型时，可以使用数组。<br>\t2)如果数组大小事先可知，并且对数据操作简单，用不到ArrayList大部分方法时，也可直接使用数组。<br>\t3)表示多维数组时，用数组较为直观。如：Object[][]array;用容器则是：ArrayList&lt;ArrayList&lt;Object&gt;&gt;array;<br>\t4)业务开发用容器即可，损耗可忽略。底层开发用数组。<br>\t<br>8.为什么大多数开发语言中，数组从0开始编号，而不是从1开始呢？<br>\t1)从数组存储的内存模型上来看，下标确切的定义应该是偏移（offset），存执方式如下：<br>\t从0开始：a[k]_address=base_dress+k*type_size<br>\t从1开始：a[k]_address=base_dress+(k-1)*type_size<br>\t可见，从1开始每次随机访问数组元素都多了一次减法运算，对于cpu来说，多了一次减法指令。<br>\t2)历史原因:c语言从0开始，效仿c语言而诞生的语言为了减少学习成本，因此沿用了从0开始。<br>\t<br>9.JVM标记清除垃圾回收算法（评论：李小四）<br>标记阶段：标记所有可达到对象<br>清除阶段：清除所有未被标记的对象<br>10.二维数组在我们直观的理解中是矩阵形式的，可在物理性的内存中也是线性的连续存储空间。<br>用一个例子推导：<br>arr[3][3]<br>我们的直观理解：<br>1 2 3<br>4 5 6<br>7 8 9<br>内存中的时机排列：<br>1 2 3 4 5 6 7 8 9<br><br>第一层里每个元素有n个第二层元素:所以内存偏移量是i*n,第二层的偏移量是j<br>对于 m * n 的数组，arr [ i ][ j ] (i &lt; m,j &lt; n)的地址为：data_addres(arr[i][j]) = base_address + (i * n + j) * type_size;<br><br>11.补充<br>大端方式和小端方式：这两个术语指代字节顺序（https:&#47;&#47;www.cnblogs.com&#47;little-white&#47;p&#47;3236548.html）<br>1)大端模式：Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。（其实大端模式才是我们直观上认为的模式，和字符串存储的模式差类似）<br>2)小端模式：Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。<br><br>感谢老师及各位小伙伴！<br>","like_count":0},{"had_liked":false,"id":278279,"user_name":"孩子shuo如果爱就请深深爱","can_delete":false,"product_type":"c1","uid":1475656,"ip_address":"","ucode":"40577CA814C611","user_header":"https://static001.geekbang.org/account/avatar/00/16/84/48/85e29645.jpg","comment_is_top":false,"comment_ctime":1612855580,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612855580","product_id":100017301,"comment_content":"为什么在 CLion 中 死循环的那个例子怎么不是死循环？","like_count":0},{"had_liked":false,"id":277978,"user_name":"zj坚果","can_delete":false,"product_type":"c1","uid":1070601,"ip_address":"","ucode":"D6E787FF032D7B","user_header":"https://static001.geekbang.org/account/avatar/00/10/56/09/4a9d4a35.jpg","comment_is_top":false,"comment_ctime":1612689113,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612689113","product_id":100017301,"comment_content":"关于数组的标记删除有个疑问，如果a[10]中存储了 8 个元素：a，b，c，d，e，f，g，h，我标记了 c，d，f 被删除，那如何能够正确高效索引到正确的元素。如果每次每次索引元素还要每次都判断元素是否删除，是的话去判断下个位置，那这不还是提高了复杂度吗","like_count":0},{"had_liked":false,"id":277230,"user_name":"Jeremy","can_delete":false,"product_type":"c1","uid":1245507,"ip_address":"","ucode":"93882376F5DC6C","user_header":"https://static001.geekbang.org/account/avatar/00/13/01/43/44255fb5.jpg","comment_is_top":false,"comment_ctime":1612322575,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1612322575","product_id":100017301,"comment_content":"二维数组的内存寻址公式：对于二维数组，假设有row行col列。如果用 a 来表示数组的首地址，则a[i][j]的地址为a[i][j]_address = base_address + i * col * type_size + j * type_size","like_count":0},{"had_liked":false,"id":276678,"user_name":"小孟会發財","can_delete":false,"product_type":"c1","uid":1134735,"ip_address":"","ucode":"697E0660180751","user_header":"https://static001.geekbang.org/account/avatar/00/11/50/8f/01e7ea90.jpg","comment_is_top":false,"comment_ctime":1612075534,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612075534","product_id":100017301,"comment_content":"老师，多维数组的寻址公式能详细说说吗？整不明白","like_count":0},{"had_liked":false,"id":275391,"user_name":"Calvino","can_delete":false,"product_type":"c1","uid":2420675,"ip_address":"","ucode":"9412B460FF3CD7","user_header":"https://static001.geekbang.org/account/avatar/00/24/ef/c3/bd245c22.jpg","comment_is_top":false,"comment_ctime":1611499889,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611499889","product_id":100017301,"comment_content":"看了大家留言后实践了一下C代码 Google了一下zsh：abort，原因是数组长度不够。<br>然后java不熟，要同步看一下了","like_count":0},{"had_liked":false,"id":273534,"user_name":"哈哈","can_delete":false,"product_type":"c1","uid":2412410,"ip_address":"","ucode":"800D79000A4831","user_header":"","comment_is_top":false,"comment_ctime":1610627672,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610627672","product_id":100017301,"comment_content":"草稿纸上画完图之后会更清晰：<br>假设数组为a[m][n],当前需要查找的是第a[i][j]<br>a[i][j] = base_adress + (i*n + j)*type_adress<br>不知道结果对不对，望大神们确认。","like_count":0},{"had_liked":false,"id":273495,"user_name":"右耳朵猫咪","can_delete":false,"product_type":"c1","uid":1014984,"ip_address":"","ucode":"3AB186CC780FBB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7c/c8/8627f5c1.jpg","comment_is_top":false,"comment_ctime":1610614134,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1610614134","product_id":100017301,"comment_content":"ArrayList users = new ArrayList(10000);for (int i = 0; i &lt; 10000; ++i) { users.add(xxx);}文中说事先指定数据大小可以省掉很多次内存申请和数据搬移操作，但未必执行效率就高，当初始化值为1000万的时候，事先指定数据大小的效率低于没有事先指定数据大小的效率。","like_count":0},{"had_liked":false,"id":271889,"user_name":"xxx","can_delete":false,"product_type":"c1","uid":1356978,"ip_address":"","ucode":"E78B1F15BC10F7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIcLjatV3GHdibZXCTIgL1X2A7jpByIeLH3Zyia8KXdT4JRcicmVSgq5ekRHCFCFenMqicsAwaWYibHkTw/132","comment_is_top":false,"comment_ctime":1609852596,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609852596","product_id":100017301,"comment_content":"数组是连续内存空间的线性表，可以根据下标实现随机访问，下标代表地址的偏移。其插入和删除的时间复杂度都是O(n)。","like_count":0},{"had_liked":false,"id":271695,"user_name":"吃鱼","can_delete":false,"product_type":"c1","uid":1812912,"ip_address":"","ucode":"848835584F6099","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/b0/0c701ef3.jpg","comment_is_top":false,"comment_ctime":1609759924,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609759924","product_id":100017301,"comment_content":"标记-清除算法<br><br>首先把需要清除的内存区域进行标记不进行删除，等内存不足YongGC的时候在进行清理。<br><br>缺点：存在内存碎片,<br><br>优点：快<br><br><br><br>标记-清除-整理算法<br><br>比上面那种算法多了一个整理阶段，清理的基础上整理了一下，让内存空间连续，解决内存碎片的问题。虽然复制算法也能阶段内存碎片，但是对于比较活跃存活率较高的对象是不适合的，例如老年代对象就比较活跃，就不适合用复制算法。<br><br>优点：解决内存碎片<br><br>缺点：慢<br><br>数组内存寻址<br><br> a[i]_address = base_address + i * data_type_size <br><br>a[i] [j]address = base_address + j * data_type_size + data_type_size[i].length","like_count":0},{"had_liked":false,"id":271348,"user_name":"Geek_2cbcde","can_delete":false,"product_type":"c1","uid":2126339,"ip_address":"","ucode":"A87FC5832D6377","user_header":"","comment_is_top":false,"comment_ctime":1609573094,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609573094","product_id":100017301,"comment_content":"老师可以帮忙解答一下，C语言数组越界导致无线循环那个问题，如果先定义数组，在定义i，还会有无限循环的问题吗？希望老师能解答，或者有大佬看到帮忙解答一下谢谢，我是学前端的呜呜","like_count":0},{"had_liked":false,"id":269978,"user_name":"j","can_delete":false,"product_type":"c1","uid":2324722,"ip_address":"","ucode":"96BAF9A9524C9F","user_header":"https://static001.geekbang.org/account/avatar/00/23/78/f2/02eb3b5c.jpg","comment_is_top":false,"comment_ctime":1608866930,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608866930","product_id":100017301,"comment_content":"1. 数组的随机访问，为什么可以随机访问？找到首地址，通过声明的数组中元素数据类型占用内存空间大小进行计算，故Ｏ(1)复杂度就可以访问数组内元素。 同样正因为数组中元素在连续空间存储，导致删除，插入，新增操作会产生O(n)复杂度。在不考虑数组中元素顺序的情况下，插入操作可以在尾部新增被插入位置的元素，实现O(1)的复杂度。<br>2. 二维数组的内存寻址：等于首地址arr[0][0]地址 + typeSize * （i * n + j）, i是行，j是列。<br>3. 标记清除算法。不太会Java。 自己的理解是：遇到需要多次删除数组中或切片中的元素（指定索引位置）时，可以将要删除的元素值赋值为业务上不可能存在的值，逻辑上删除。当然这个理解不准确","like_count":0},{"had_liked":false,"id":269451,"user_name":"olivia-byte","can_delete":false,"product_type":"c1","uid":1273891,"ip_address":"","ucode":"D54B3833995923","user_header":"https://static001.geekbang.org/account/avatar/00/13/70/23/92d188aa.jpg","comment_is_top":false,"comment_ctime":1608651519,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608651519","product_id":100017301,"comment_content":"Mark-Sweep，标记就是遍历所有的GC Roots，然后将所有GC Roots可达的对象标记为存活的对象。<br>清除就是遍历堆中所有的对象，将没有标记的对象全部清除掉。","like_count":0},{"had_liked":false,"id":269450,"user_name":"olivia-byte","can_delete":false,"product_type":"c1","uid":1273891,"ip_address":"","ucode":"D54B3833995923","user_header":"https://static001.geekbang.org/account/avatar/00/13/70/23/92d188aa.jpg","comment_is_top":false,"comment_ctime":1608651162,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608651162","product_id":100017301,"comment_content":"int a[m][n]，对于a[i][j]（i&lt;m，j&lt;n），address = 首地址 + (i * n + j) * 元素地址大小。<br>比如首地址为100，每个元素地址大小为4，声明整形数组int a[4][4]，则元素a[3][2]的地址为 (3 * 4 + 2) * 4 + 100 = 156。","like_count":0},{"had_liked":false,"id":269399,"user_name":"元滚滚","can_delete":false,"product_type":"c1","uid":1474213,"ip_address":"","ucode":"29FFA81EA9D275","user_header":"https://static001.geekbang.org/account/avatar/00/16/7e/a5/2c14f155.jpg","comment_is_top":false,"comment_ctime":1608633019,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608633019","product_id":100017301,"comment_content":"“跟插入数据类似，如果我们要删除第 k 个位置的数据，为了内存的连续性，也需要搬移数据” <br>有点难理解这个，按照描述的k位置数据删除之后，k位置后面的数据都往前搬移，那是不是删除k之后，k依旧是有数据的，只不过它的数据是删除之前的k+1位的数据，也不知道我理解的对不对；平时在程序中（php）数组k位置数据删除之后，k就不存在了，感觉我之前接触的数组都不是数组","like_count":0},{"had_liked":false,"id":268697,"user_name":"型火🔥","can_delete":false,"product_type":"c1","uid":1003205,"ip_address":"","ucode":"C2322918B31E60","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/c5/78626367.jpg","comment_is_top":false,"comment_ctime":1608294966,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1608294966","product_id":100017301,"comment_content":"标记清除就是批处理，存到一批之后处理，减少高成本的操作，比如kafka批量消息","like_count":0},{"had_liked":false,"id":268505,"user_name":"bowen","can_delete":false,"product_type":"c1","uid":1073569,"ip_address":"","ucode":"B0979D12090C7D","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/a1/f2ddc098.jpg","comment_is_top":false,"comment_ctime":1608220079,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608220079","product_id":100017301,"comment_content":"个人觉得数组很像简化的哈希表，下标是键，剑指offer里寻找重复数字这题就使用了这种思想","like_count":0},{"had_liked":false,"id":268504,"user_name":"bowen","can_delete":false,"product_type":"c1","uid":1073569,"ip_address":"","ucode":"B0979D12090C7D","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/a1/f2ddc098.jpg","comment_is_top":false,"comment_ctime":1608219813,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608219813","product_id":100017301,"comment_content":"JVM垃圾回收机制对应的数组删除操作，也就是先标记攒起来再一次删除","like_count":0},{"had_liked":false,"id":268503,"user_name":"bowen","can_delete":false,"product_type":"c1","uid":1073569,"ip_address":"","ucode":"B0979D12090C7D","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/a1/f2ddc098.jpg","comment_is_top":false,"comment_ctime":1608219680,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608219680","product_id":100017301,"comment_content":"课后思考2<br> 一维数组寻址是地址加偏移乘单位，二维就是地址加第一个偏移乘一行的单位再加第二个偏移乘单位，果然数学公式的好处就是简洁<br>总结<br>数组属于线性表，是一段连续的内存空间，从0开始是因为可以把下标看做偏移，从1开始会让寻址操作多一次减法运算。用下标访问的时间复杂度是O(1),删除和插入O(n)。在已知数组大小且没有复杂操作的情况下优先选用数组，否则我还是更青睐容器，毕竟可以自动扩容，且封装好了插入删除排序等操作","like_count":0},{"had_liked":false,"id":268188,"user_name":"羽","can_delete":false,"product_type":"c1","uid":2369723,"ip_address":"","ucode":"F841D2EF2A016B","user_header":"https://static001.geekbang.org/account/avatar/00/24/28/bb/5fcd8d73.jpg","comment_is_top":false,"comment_ctime":1608097208,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608097208","product_id":100017301,"comment_content":"Python使用者，对Java不熟悉，所以第一问不能回答<br>关于二维数组寻址，数组是优先以连续地址进行存储，当数组为二维时优先顺序存储行数据再按列先后依次存储，则<br>对于一个二维数组array[m][n]，若已知初始位置&amp;array[0][0] = base_address<br>则对于任意数组元素array[i][j] (0 &lt;= i &lt;= m - 1, 0 &lt;= j &lt;= n - 1)，其地址应为<br>&amp;array[i][j] = base_address + element_type_size * (i * n + j)","like_count":0},{"had_liked":false,"id":267272,"user_name":"Allan","can_delete":false,"product_type":"c1","uid":1310388,"ip_address":"","ucode":"8DA4DBECC2C45C","user_header":"https://static001.geekbang.org/account/avatar/00/13/fe/b4/295338e7.jpg","comment_is_top":false,"comment_ctime":1607665767,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607665767","product_id":100017301,"comment_content":"标记清除垃圾回收算法：自己也是看jvm虚拟机了解的， 没有看过源码。大概的描述就是对需要清理的对象进行标记，再对他进行清除。但容易造成内存的不连续，导致空间浪费。","like_count":0},{"had_liked":false,"id":267085,"user_name":"Gabriel","can_delete":false,"product_type":"c1","uid":1437358,"ip_address":"","ucode":"714772A93E93DC","user_header":"https://static001.geekbang.org/account/avatar/00/15/ee/ae/855b7e6e.jpg","comment_is_top":false,"comment_ctime":1607591656,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607591656","product_id":100017301,"comment_content":"二维数据的内存寻址：像arr[3][4],这样的数据。计算机在分配内存地址的时候<br>长度是：len = i * j，len = 3 * 4<br>然后计算机在分配的时候也是应该按照 a[0]，分配a[0]*4的连续内存空间，a[0][0],a[0][1],a[0][2],a[0][3]<br>所以 一位数据的计算公式是：<br>a[k]_address = base_address + （i*n+j） * type_size","like_count":0},{"had_liked":false,"id":266680,"user_name":"geek_666888","can_delete":false,"product_type":"c1","uid":2024635,"ip_address":"","ucode":"3E348CCE186ACF","user_header":"","comment_is_top":false,"comment_ctime":1607436418,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607436418","product_id":100017301,"comment_content":"本质上二位数组存储的数据与一维数组一致，一样都是连续内存，而非逻辑理解上的X-Y轴的二维数据。<br>二维数组的存储结构分为两种，一种是行主顺序，一种是列主顺序。<br>&#47;&#47;列为m,行为n<br>&#47;&#47;行主顺序的内存寻址公式：<br>Address a[i][j]= base_address + (i*n+j)*data_size;<br>&#47;&#47;列主顺序：<br>Address a[i][j] = base_address + (i+j*m)*data_size;","like_count":0},{"had_liked":false,"id":265992,"user_name":"慕高迪","can_delete":false,"product_type":"c1","uid":1448126,"ip_address":"","ucode":"EB1CB5EA4E3A90","user_header":"https://static001.geekbang.org/account/avatar/00/16/18/be/ad3127e0.jpg","comment_is_top":false,"comment_ctime":1607092162,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607092162","product_id":100017301,"comment_content":"总结：<br><br>数组是一段连续分配的内存结构。它是一种基础的数据结构，广泛的存在于各种编程语言中。<br><br>它的寻址公式为 baseAddress + i * type_size ; type_size 为每个元素所占用空间的大小， i 是数组的下标。baseAddress 为数组的起始地址。<br><br>它支持下标随机访问，时间复杂度为O(1)<br><br>为了保证的地址上的连续性，添加和删除操作可能会导致数据的移位。所以对于添加和删除操而言，就不能单纯的使用时间复杂度来分析，需要额外考虑最好情况下的复杂度，最坏情况下的复杂度，平均时间复杂度。<br>最好时间的复杂度则是在数组末尾添加元素或者是删除数组末尾的元素，复杂度为O(1)<br>最坏情况下的复杂度则是在数组头位置添加或者是删除元素，数组中的其他元素都需要进行移位，复杂度为O(n)<br>平均情况下的复杂度也是O(n)。计算过程如下：在数组任意位置添加元素的概率都是相等的，假设为 1&#47;n 。即为 1&#47; n *1 + 1&#47;n * 2 ..... 1&#47;n *(n-1) = O(n) 。<br><br>在某些场景下，我们在向指定位置添加元素时，可以将该位置的旧元素添加到元素的末尾，空出来位置存放新元素，将时间复杂度降为O(1)，例如数组的用途仅仅是存放数据且数据无规律。<br>而对于删除某个位置的元素，在某些不要求数组中的有效数据保持连续性场景下，可以先标记数据被删除了。当数组的容量满了，在一次性清除，移动数据，这中间省下了多次移动数据的过程。有点类似于JVM的标记清除垃圾回收算法。<br><br>在一些高级语言中，数组出现的频次较低，往往被封装为了更高层次的数据结构，例如 ArrayList。高层次的结构屏蔽了底层数组的扩容（在可以预知大小的情况下，设置容量，防止频繁扩容），数据移动等细节操作，仅对外提供简单易用的API。那这是不是就代表数组没有应用场景了呢？<br>其实是有的。<br>比如你针对数组进行一些简单的操作，数组容量固定的情况下，使用数组往往比使用高层次的封装来的直接。<br>在者就是高层次的封装往往操作较多，难免存在性能问题。有些程序需要追求极致的性能，往往都是直接使用的数组。","like_count":0},{"had_liked":false,"id":265980,"user_name":"慕高迪","can_delete":false,"product_type":"c1","uid":1448126,"ip_address":"","ucode":"EB1CB5EA4E3A90","user_header":"https://static001.geekbang.org/account/avatar/00/16/18/be/ad3127e0.jpg","comment_is_top":false,"comment_ctime":1607087802,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607087802","product_id":100017301,"comment_content":"思考题：<br>2. 在二维数组中，一维的数组中每个元素的地址为二维的数组的起始地址。有因为数据组是连续开辟的内存空间。所以地址分布为：a[0][0]a[0][1]....a[0][n] a[1][0]a[1][1].....a[1][n]。假设二维数组的长度分别为：m,n。寻址公式为：a[k][j]=baseAddress + k * n * type_size + j * type_size。<br>","like_count":0},{"had_liked":false,"id":265972,"user_name":"GZ","can_delete":false,"product_type":"c1","uid":2122198,"ip_address":"","ucode":"EF443A4D5F89A7","user_header":"https://static001.geekbang.org/account/avatar/00/20/61/d6/58c3a6ab.jpg","comment_is_top":false,"comment_ctime":1607083001,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607083001","product_id":100017301,"comment_content":"虽然是非常常见简单的数据结构，读完作者的文章依然能学习到不少的新的感悟，真好。","like_count":0},{"had_liked":false,"id":265491,"user_name":"赤耳小永","can_delete":false,"product_type":"c1","uid":1796622,"ip_address":"","ucode":"4B8B736336C5D9","user_header":"https://static001.geekbang.org/account/avatar/00/1b/6a/0e/1aae7cf9.jpg","comment_is_top":false,"comment_ctime":1606914221,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606914221","product_id":100017301,"comment_content":"我觉得内存是从0开始编号的，数组中的数据都是存在内存的。","like_count":0},{"had_liked":false,"id":265419,"user_name":"Geek_0ddc80","can_delete":false,"product_type":"c1","uid":2350585,"ip_address":"","ucode":"57B8C059E6800D","user_header":"","comment_is_top":false,"comment_ctime":1606893778,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606893778","product_id":100017301,"comment_content":"jvm垃圾回收标记清除算法：jvm会根据gcroot算法标记可达对象，gcroot的根节点指的是（1.栈帧中本地变量表的引用，2.方法区静态属性引用及常量引用，3.本地方法引用）gc线程进行扫描标记没有引用的对象进行回收，回收之后jvm内存会出现碎片化，导致jvm在分配对象内存大小时候要考量当前有无连续的内存放置当前对象，严重浪费内存。<br>对于 m * n 的数组  寻址公式a[i][k]_address = base_address + (i*n+k)*type_size<br>","like_count":0},{"had_liked":false,"id":263434,"user_name":"Wangyf","can_delete":false,"product_type":"c1","uid":2226219,"ip_address":"","ucode":"349068A07CB1D4","user_header":"https://static001.geekbang.org/account/avatar/00/21/f8/2b/339660f1.jpg","comment_is_top":false,"comment_ctime":1606132712,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1606132712","product_id":100017301,"comment_content":"想起了操作系统删除文件的东西。之前准备玩 GTA5，文件确实很大，下载了一上午才下载完。之后准备学习卸载游戏的时候，噌地进度条一下就满了，不到一分钟 80 多 G 就删除完毕了。当时就很奇怪为啥下载要那么长的时间，删除只用了一会儿。后来才知道，删除只是标记了一下，硬盘那个区域可以被其他程序使用了，原来的文件其实还在的。覆盖写就行，这也就提醒了我们，硬盘什么的不用了最好用物理手段粉碎或者砸一下，不然很可能上面的隐私数据会被恢复","like_count":0},{"had_liked":false,"id":261614,"user_name":"cyan-mountain","can_delete":false,"product_type":"c1","uid":2318781,"ip_address":"","ucode":"2797C0D846130C","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/fKD3fHiaJajYHkBNnLBYb40ggEqA5lykW4jrqHvXtiap2rPmq8Cj7pj4nTU7BdqHTIzIRKRt5mylnucgwibOZ2Z9g/132","comment_is_top":false,"comment_ctime":1605444571,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605444571","product_id":100017301,"comment_content":"关于为什么 ArrayList 只能存储 包装类型的数据，而不能存储 基础数据类型，是因为 基础数据类型 是存储在栈中的，而  ArrayList 是存储在堆中的，所以 ArrayList 只能存储 同样是保存在堆中的 包装类型的数据。","like_count":0},{"had_liked":false,"id":261569,"user_name":"Hello World","can_delete":false,"product_type":"c1","uid":2174668,"ip_address":"","ucode":"17E61AC9D8397E","user_header":"https://static001.geekbang.org/account/avatar/00/21/2e/cc/d21d86c1.jpg","comment_is_top":false,"comment_ctime":1605425875,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605425875","product_id":100017301,"comment_content":"1、标记清除算法，是将不可达的对象进行标记，先不处理，第二次GC的时候如果还是不可达，那就进行清除<br>2、如果二维数组是int[i][j]的话，寻址的公式是 baseaddr + (i * size_in + j) * size","like_count":0},{"had_liked":false,"id":261251,"user_name":"tron","can_delete":false,"product_type":"c1","uid":1624821,"ip_address":"","ucode":"F94DB2BE804998","user_header":"https://static001.geekbang.org/account/avatar/00/18/ca/f5/3f95bf91.jpg","comment_is_top":false,"comment_ctime":1605251610,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605251610","product_id":100017301,"comment_content":"老师，请问js声明的二维数组，类似于[[1,2,3],[4,5]]这样的，每个元素的内存长度是怎么个情况呢，虽然课程很久了，但还是期待回复ing","like_count":0},{"had_liked":false,"id":260731,"user_name":"Maske","can_delete":false,"product_type":"c1","uid":1696847,"ip_address":"","ucode":"A19BB41A47E852","user_header":"https://static001.geekbang.org/account/avatar/00/19/e4/4f/df6d810d.jpg","comment_is_top":false,"comment_ctime":1605090607,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1605090607","product_id":100017301,"comment_content":"a[k][n]_address = base_address + k * type_size_k + n * type_size_n","like_count":0},{"had_liked":false,"id":260669,"user_name":"InvisibleDes","can_delete":false,"product_type":"c1","uid":1566802,"ip_address":"","ucode":"56908581681771","user_header":"https://static001.geekbang.org/account/avatar/00/17/e8/52/931888d7.jpg","comment_is_top":false,"comment_ctime":1605080735,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1605080735","product_id":100017301,"comment_content":"老师太厉害了，一个数组能讲出来这么多东西，让本来觉得深刻认识数组的自己，感到羞愧<br>","like_count":0},{"had_liked":false,"id":260235,"user_name":"hugozhang","can_delete":false,"product_type":"c1","uid":2273801,"ip_address":"","ucode":"3DADDB522B126F","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/LicibaBrUGZVYicQcJ3PH0HwKIe7x5gld8MtvoA0wzNyPEEibkLy3V9Wzvic0iaUHSx1Od25u3SHSTepp3Sv7dgfMvicg/132","comment_is_top":false,"comment_ctime":1604967467,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604967467","product_id":100017301,"comment_content":"关于无限循环的问题主要涉及到的问题就有两个，一个是c语言本身不提供数组下标越界检查，二是方法栈的特性，入栈有先后，当i=3的时候修改的是栈中i变量的值为0，因此会无限循环。","like_count":0},{"had_liked":false,"id":258798,"user_name":"Z7k","can_delete":false,"product_type":"c1","uid":1238680,"ip_address":"","ucode":"39373D7A6E6EE1","user_header":"https://static001.geekbang.org/account/avatar/00/12/e6/98/5853eb73.jpg","comment_is_top":false,"comment_ctime":1604559148,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604559148","product_id":100017301,"comment_content":"1.当堆中的有效空间被耗尽时，jvm就会停止程序去进行标记清除。首先将存活的对象标记一波，没有被标记的对象就是垃圾对象，统一清除掉。<br><br>2.a[i][j]_address = base_address + [i*(len(a[0]))+j]* type_size","like_count":0},{"had_liked":false,"id":258250,"user_name":"klchang","can_delete":false,"product_type":"c1","uid":2281046,"ip_address":"","ucode":"792355B14607ED","user_header":"","comment_is_top":false,"comment_ctime":1604360056,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604360056","product_id":100017301,"comment_content":"1. 对Java不熟悉；<br>2. a[i][j]_address = base_address + i*ncols*type_size + j*type_size<br>其中，ncols 为二维数组a的列数，a[i][j] 表示二维数组第 i 行第 j 列的元素。","like_count":0},{"had_liked":false,"id":257976,"user_name":"Nullptr","can_delete":false,"product_type":"c1","uid":1911665,"ip_address":"","ucode":"8EC72438680F8D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLpCwvSDHKuwJklN3gosIbJh0AX97ULSXw4cgopjU28eQHR7DxcCWDFSBv7ZQJElBuCFu58xoWaTg/132","comment_is_top":false,"comment_ctime":1604231703,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604231703","product_id":100017301,"comment_content":"垃圾回收机制让我想起了C++里面的智能指针，通过引用计数来避免程序员忘掉释放内存空间。这里应该也有这部分思想。","like_count":0},{"had_liked":false,"id":257567,"user_name":"Albert.Ejiestein","can_delete":false,"product_type":"c1","uid":1665385,"ip_address":"","ucode":"CC342398930C25","user_header":"https://static001.geekbang.org/account/avatar/00/19/69/69/f7cde15c.jpg","comment_is_top":false,"comment_ctime":1604028982,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604028982","product_id":100017301,"comment_content":"老师，按照定义，数组应该是固定长度的连续内存，但是在js中，一般是不固定长度的，同时也没有出现访问越界问题，这是底层做了什么特殊处理吗，还是说js中的数组就是ArrayList","like_count":0},{"had_liked":false,"id":256562,"user_name":"wsh","can_delete":false,"product_type":"c1","uid":1006628,"ip_address":"","ucode":"C0FE187C6EECED","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/24/d2575310.jpg","comment_is_top":false,"comment_ctime":1603678997,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603678997","product_id":100017301,"comment_content":"看完最大的收获是，有些实践中，添加元素时把原元素放到最后，同理，删除元素时，可以把最后的元素放到删除位置，这种场景一般似乎不多，因为无序的集合一般用set，当然系统编程很多底层的编码确实有这种需求，把数组当集合用，主要用来遍历访问，不知道讲师怎么看？","like_count":0},{"had_liked":false,"id":256430,"user_name":"Geek_e02a6e","can_delete":false,"product_type":"c1","uid":2257273,"ip_address":"","ucode":"069C3B666DAFF7","user_header":"","comment_is_top":false,"comment_ctime":1603622361,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603622361","product_id":100017301,"comment_content":"标记清除算法：<br>采用可达性分析算法，对GC ROOTS进行扫描，对整个存活的对象进行标记，标记完成后再对整个内存空间未标记的对象进行扫描，进行回收<br>缺点：效率低，会产生大量的空间碎片，在对象频繁创建的情况下，会频繁出发GC<br>二位数组a[n][m]的寻址：<br>a[i][j]_adress = base_adress + (i*n+j) * type_size <br>例如：二位数组a[5][5], a[1][5]的寻址地址是<br>a[1][5] = base_adress + (1*5 + 5) * type_size","like_count":0},{"had_liked":false,"id":256013,"user_name":"Geek_73ec50","can_delete":false,"product_type":"c1","uid":2249079,"ip_address":"","ucode":"AD91B8112A5A7F","user_header":"https://static001.geekbang.org/account/avatar/00/22/51/77/de3788f3.jpg","comment_is_top":false,"comment_ctime":1603506551,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603506551","product_id":100017301,"comment_content":"二维数组是按照行连续存储，实际内存也是线性存储，所以问题的关键是计算给定元素的存储下标","like_count":0},{"had_liked":false,"id":255769,"user_name":"Rookie-Red","can_delete":false,"product_type":"c1","uid":1627358,"ip_address":"","ucode":"A2CC287D3442D7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJia5Ax51D8Nyap5xcPkaveicguf5Nm4715fXKT4TfccvBYKiabWVJTeHtrejmDNtdmM12JYLzxiaUVEQ/132","comment_is_top":false,"comment_ctime":1603424979,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603424979","product_id":100017301,"comment_content":"第一个问题：<br>先标记，最后一次性回收（不是删除1次清一次）。<br><br>第二个问题：<br>arr[i][j]  , i &lt; m , j &lt; n 。的地址为： address = base_address + ( i * n + j) * type_size 。 ","like_count":0},{"had_liked":false,"id":255589,"user_name":"80碎脑投","can_delete":false,"product_type":"c1","uid":1550399,"ip_address":"","ucode":"5E81336BE0A0A5","user_header":"https://static001.geekbang.org/account/avatar/00/17/a8/3f/f0456492.jpg","comment_is_top":false,"comment_ctime":1603376726,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603376726","product_id":100017301,"comment_content":"Python的列表是不限制存储的数据类型的，但是Python的列表也支持随机访问呀，Python是怎么做的呀？","like_count":0},{"had_liked":false,"id":253894,"user_name":"珊珊的老公","can_delete":false,"product_type":"c1","uid":2141859,"ip_address":"","ucode":"706123866CF60C","user_header":"https://static001.geekbang.org/account/avatar/00/20/ae/a3/8af25a27.jpg","comment_is_top":false,"comment_ctime":1602939570,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602939570","product_id":100017301,"comment_content":"数组地址从零开始，是不是一定是偶地址开始，这样偶地址对齐，访问速度快，8086从偶地址读取字节，字，或者从奇地址读写一个字节都是一个总线周期，而从奇地址读写一个字就是2个总线周期，您讲的这个也是汇编中的寻找方式，基址+变址","like_count":0},{"had_liked":false,"id":252899,"user_name":"i-neojos","can_delete":false,"product_type":"c1","uid":1702997,"ip_address":"","ucode":"1808C25269948A","user_header":"https://static001.geekbang.org/account/avatar/00/19/fc/55/e03bb6db.jpg","comment_is_top":false,"comment_ctime":1602511447,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602511447","product_id":100017301,"comment_content":"内容其实挺不错的","like_count":0},{"had_liked":false,"id":252289,"user_name":"chuck","can_delete":false,"product_type":"c1","uid":1692886,"ip_address":"","ucode":"2229324EB1CD8B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKx6EdicYYuYK62r5aphMtYw6HskzPhbI3xRicxWticwKMhaO3Z63OYmr55FcjvNRClg93yhQ1U2BQXw/132","comment_is_top":false,"comment_ctime":1602224897,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602224897","product_id":100017301,"comment_content":"“如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 O(1)。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 O(n)。 因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 (1+2+…n)&#47;n=O(n)”<br>老师，你好。我了解到C中一维数组初始化的时候，没有指定元素的数组位置默认就是0。那么这个情况下，这个一维数组中每个位置都是有元素的。<br>是否改为&quot;在线性表的末尾插入元素&quot;，更合适呢？线性表的长度和数组的长度，应该不是一个概念吧，这里线性表的长度应该小于等于数组的长度啊。","like_count":0},{"had_liked":false,"id":250723,"user_name":"念","can_delete":false,"product_type":"c1","uid":2136411,"ip_address":"","ucode":"2B1B5DA9877904","user_header":"https://static001.geekbang.org/account/avatar/00/20/99/5b/5173ea22.jpg","comment_is_top":false,"comment_ctime":1601201763,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601201763","product_id":100017301,"comment_content":"python的数组是可以存不同类型的数据","like_count":0},{"had_liked":false,"id":250045,"user_name":"刘成","can_delete":false,"product_type":"c1","uid":1352662,"ip_address":"","ucode":"F1ED0EB840FFA6","user_header":"https://static001.geekbang.org/account/avatar/00/14/a3/d6/c0d0cb25.jpg","comment_is_top":false,"comment_ctime":1600914851,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600914851","product_id":100017301,"comment_content":"m * n 数组，a[i, j]_address = base_address + (i * count + j) * type_size","like_count":0},{"had_liked":false,"id":249084,"user_name":"傻傻的帅","can_delete":false,"product_type":"c1","uid":1668617,"ip_address":"","ucode":"14A795523A682E","user_header":"https://static001.geekbang.org/account/avatar/00/19/76/09/62a10668.jpg","comment_is_top":false,"comment_ctime":1600423898,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600423898","product_id":100017301,"comment_content":"二维数组可以理解为数组中的数组，即一维数组存储的不再是具体的数据，而是数据的地址空间。<br>a[i][j]= a[0]_address+i*data_type_size +j*data_type_size","like_count":0},{"had_liked":false,"id":249061,"user_name":"Belizer","can_delete":false,"product_type":"c1","uid":2175243,"ip_address":"","ucode":"17DA133DC0BDDF","user_header":"https://static001.geekbang.org/account/avatar/00/21/31/0b/91f317a0.jpg","comment_is_top":false,"comment_ctime":1600417704,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600417704","product_id":100017301,"comment_content":"这里的数据连续性要怎么理解？<br>","like_count":0},{"had_liked":false,"id":248978,"user_name":"A.....","can_delete":false,"product_type":"c1","uid":1178258,"ip_address":"","ucode":"8078CD50894D59","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/92/3c6a224c.jpg","comment_is_top":false,"comment_ctime":1600393975,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600393975","product_id":100017301,"comment_content":"当我们声明一个数组时 int[] a = new int[10]; 那么 这个a所指向的是什么地址，数组第一个值得地址么？","like_count":0},{"had_liked":false,"id":248776,"user_name":"大力","can_delete":false,"product_type":"c1","uid":1364353,"ip_address":"","ucode":"1B2125C519443D","user_header":"https://static001.geekbang.org/account/avatar/00/14/d1/81/89ba9d81.jpg","comment_is_top":false,"comment_ctime":1600308013,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600308013","product_id":100017301,"comment_content":"（需要先理解二维数组在内存中是怎么存储的。）<br>a[][] = a[m][n]<br>a[i][j]_address = (base_address + i * n * type_size) + j * type_size","like_count":0},{"had_liked":false,"id":247523,"user_name":"Aresx","can_delete":false,"product_type":"c1","uid":2159788,"ip_address":"","ucode":"AE90EC3724EF98","user_header":"https://static001.geekbang.org/account/avatar/00/20/f4/ac/3e6b4b77.jpg","comment_is_top":false,"comment_ctime":1599731583,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599731583","product_id":100017301,"comment_content":"二维数组在内存中其实也是一维连续存储的，二维数组的内存公式为：a[i][k]_address = base_address + i*(k * type_size) +k*type_size","like_count":0},{"had_liked":false,"id":247459,"user_name":"R","can_delete":false,"product_type":"c1","uid":2172520,"ip_address":"","ucode":"3721FC8C8DE174","user_header":"https://static001.geekbang.org/account/avatar/00/21/26/68/b86dc4df.jpg","comment_is_top":false,"comment_ctime":1599713742,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1599713742","product_id":100017301,"comment_content":"二维数组在内存中的地址也是连续的，分为行和列也是按照我们的“逻辑”来划分的。事实上，当数组第一行结束后，第二行的第一个元素的地址和第一行最后一个元素的地址只差一个sizeof(type)。假设二维数组为a[rows][cols]，如果我们取二维数组a[0][0]的地址为base_add(这里表示为C语言的指针)，那么a[m][n]的内存地址就是base_add + m * cols + n（前提是不会发生数组下标越界）。<br><br>int a[ROWS][COLS];<br>int *base_add = &amp;a[0][0];<br>int m , n ;<br>scanf(&quot;%d%d&quot;, &amp;m, &amp;n);<br>printf(&quot;a[%d][%d] = %d\\n&quot;, m, n, *(base_add + m * COLS + n));<br>printf(&quot;a[%d][%d] = %d\\n&quot;, m, n, a[m][n]);<br><br>按地址取值和直接按数组下标取值结果是一样的！<br>二维数组可以定义为a[][COLS]，只写列，不用写行，应该也是由于这个原因吧！","like_count":0},{"had_liked":false,"id":247392,"user_name":"金先生","can_delete":false,"product_type":"c1","uid":2168501,"ip_address":"","ucode":"F8F02BAE1235DE","user_header":"https://static001.geekbang.org/account/avatar/00/21/16/b5/f0ba2764.jpg","comment_is_top":false,"comment_ctime":1599699103,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599699103","product_id":100017301,"comment_content":"老师 你说数组扩容会重新申请更大内存，那么为啥扩容了 但数组地址还没有变化","like_count":0},{"had_liked":false,"id":247006,"user_name":"淡淡の盐","can_delete":false,"product_type":"c1","uid":1137883,"ip_address":"","ucode":"CB496263F3E4B5","user_header":"https://static001.geekbang.org/account/avatar/00/11/5c/db/e2a65cc6.jpg","comment_is_top":false,"comment_ctime":1599555980,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599555980","product_id":100017301,"comment_content":"JVM 和数组有什么关系？为什么在数组篇想 JVM 问题，没理解作者的用意思。作者可以公布下答案吗？","like_count":0},{"had_liked":false,"id":246984,"user_name":"淡淡の盐","can_delete":false,"product_type":"c1","uid":1137883,"ip_address":"","ucode":"CB496263F3E4B5","user_header":"https://static001.geekbang.org/account/avatar/00/11/5c/db/e2a65cc6.jpg","comment_is_top":false,"comment_ctime":1599550064,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599550064","product_id":100017301,"comment_content":"@作者 data_type_size 谁规定是4个字节呢，如果存的是 string 每个元素大小不同，这时要怎么寻址呢？","like_count":0},{"had_liked":false,"id":246971,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1599546544,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599546544","product_id":100017301,"comment_content":"<br><br>第一题:JVM标记清除法:<br>无论是什么垃圾收集算法，其实大的步骤，概括起来都是两个大步骤<br>第一:标记，白话就是如何判断和标记一个对象是否存活，是否是垃圾，最开始的引用计数法，但是有孤岛问题，后来才出现的可达性分析方法，从GC ROOT出发，GC ROOTS包括栈上的变量，本地方法栈上的变量，方法区中的静态变量，方法区中常量池里面的常量。<br>第二:清除，就是删除掉这部分对象占用的内存，但是清除以后会导致内存不连续，断断续续的，产生很多内存碎片，当我们要分配一个大的对象的时候，可能会导致因为没有足够的内存而又触发垃圾收集<br>第二题:a[i][j]_address=base_address+(i*n+j)*size_type","like_count":0},{"had_liked":false,"id":246818,"user_name":"星朝","can_delete":false,"product_type":"c1","uid":1848539,"ip_address":"","ucode":"DFCF2512D6DAE0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/LqGZd83zp1y9fpbliaSgGh5qib5eGzU41xibTzib06ZAlaiaJibkJB89JuVEozCScUsVK90jpq7Na30AHDngQzI7YwiaA/132","comment_is_top":false,"comment_ctime":1599485871,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599485871","product_id":100017301,"comment_content":"垃圾标记清除基本原理确实入老师说的那样。不过java的更复杂，首先给引用做了分类，其次是通过GCRoot，通过记录正向可达的引用。最后把没有统计到不可达的强引用等直接清楚，不过目前主要研究方向是减少清除的这个停顿时间","like_count":0},{"had_liked":false,"id":246740,"user_name":"WilliamVector","can_delete":false,"product_type":"c1","uid":1898112,"ip_address":"","ucode":"E0D3C3D4FCB7C9","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f6/80/85ec2c2a.jpg","comment_is_top":false,"comment_ctime":1599468764,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599468764","product_id":100017301,"comment_content":"【要点】<br>1、数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。<br>2、由于数组是用连续的内存空间存储相同类型的元素，所以可以通过下标随机访问。寻址公式为：a[i]_address = base_address + i * data_type_size<br>3、如果数组中元素为非顺序排列，则可以通过将要插入位置k的元素搬移到末尾，然后再将新元素插入k，时间复杂度为O(1)。<br>4、如果数据中元素为非顺序排列，删除数据时，则可先标记已删除的元素，等数组中没有多余空间存储新元素时再集体触发一次删除操作，将之前标记的删除元素全部删除。<br>5、很多时候我们并不是要去死记硬背某个数据结构或者算法，而是要学习它背后的思想和处理技巧，这些东西才是最有价值的。<br>6、对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。<br>【思考】<br>1、JVM垃圾收集算法：<br>(1)引用计数法：jvm为每一个对象设立一个引用计数器，当该对象被引用时，计数器就加一，引用取消时则减一。当jvm开始gc时，jvm判断该对象的引用计数器是否为0，若为0则标记为可清除对象。引用计数器有个致命的缺点是无法解决循环依赖问题，这也导致这个算法被弃用。引用计数器有个致命的缺点是无法解决循环依赖问题，这也导致这个算法被弃用。<br>(2)根搜索算法：根搜索算法会以根对象集合中的根对象出发，进行自上往下的搜索，与根对象直接连接或间接连接的对象都可以被搜索。当JVM无法到达某个对象时，它会被标记为可清除对象。根对象集合指的是：JAVA栈中的对象引用、本地方法栈的对象引用、运行时常量池中的对象引用、方法区中的类静态属性的对象引用、类对应的唯一数据类型的Class对象(每个类都有一个Class对象用于表示这个类在运行时被JVM加载的相关信息，如类名、方法、属性等，可以使用ClassName.class、实例化对象.class、Class.forName()，获取该类的Class对象)。<br>2、对于二维数据，a[i][j],i &lt; n, j &lt; m,的寻址公式为：<br>a[i][j]_address = base_address + (i * m + j) * data_type_size。","like_count":0},{"had_liked":false,"id":245260,"user_name":"陆元春_deman","can_delete":false,"product_type":"c1","uid":1609018,"ip_address":"","ucode":"56484CA282DC2F","user_header":"https://static001.geekbang.org/account/avatar/00/18/8d/3a/b5076a06.jpg","comment_is_top":false,"comment_ctime":1598878598,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598878598","product_id":100017301,"comment_content":"- 1.标记清除垃圾回收算法，简单来说就是先标记，在clear。现在的JVM，都通过可达性分析算法，来评估和分析GC。<br>简单来说就是GC是需要时间的，所以GC有周期性。然后在发生GC的时候，需要标记哪些内存被释放了，就clear它。时间并不是刷0或者其他操作，只是标记为该内存可以被使用。这里讲C++&#47;C 比java块，就有很多方面，这里也是一个方面。如果是C&#47;C++，在分配一块内存以后，内存是野的，也就是内存不知道是啥内容，需要我们自己初始化下。<br>而java是不能自己申请内存的，所以只能new 一个类，在这个过程中，<br>jvm会帮我们把初始化的事情干了。<br>- 2.二位数组的内存寻址公式<br>假设数组 int a[m][n] 寻址地址  address = baseaddres+(i*n+j)*type_size<br>i&lt;m &amp; j&lt;n","like_count":0},{"had_liked":false,"id":244983,"user_name":"迷羊","can_delete":false,"product_type":"c1","uid":1286251,"ip_address":"","ucode":"85AF8CED3436C8","user_header":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","comment_is_top":false,"comment_ctime":1598773179,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598773179","product_id":100017301,"comment_content":"我觉得原因是物理层面最初的地址就是从0开始往上加的","like_count":0},{"had_liked":false,"id":244206,"user_name":"黄金","can_delete":false,"product_type":"c1","uid":1261700,"ip_address":"","ucode":"3CF4417C9D9264","user_header":"https://static001.geekbang.org/account/avatar/00/13/40/84/65032a15.jpg","comment_is_top":false,"comment_ctime":1598428554,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1598428554","product_id":100017301,"comment_content":"二维数组个人的理解就是：内存还是一维的，给了人们一个简便的访问能力<br>比如二维数组a[2][2], 就是[(0,0),(0,1),(1,0),(1,1,)] 因此m行n列的数组分配的空间就是m*n*type_size<br>寻址的话，假设(0,0)是base，(0,1)就是base+1，(1,0)是base+2以此类推<br>所以m行n列数组访问(i,j) 应该就是 base+(n*i+j)*type_size<br>这里注意一点：m行n列数组，一行应该是n个元素，所以是i*n，可以在纸上画一个2行3列的图片就能看出来了","like_count":0},{"had_liked":false,"id":243492,"user_name":"西风胡杨","can_delete":false,"product_type":"c1","uid":1488212,"ip_address":"","ucode":"7A35856E27F27B","user_header":"https://static001.geekbang.org/account/avatar/00/16/b5/54/3f78e3c8.jpg","comment_is_top":false,"comment_ctime":1598154213,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598154213","product_id":100017301,"comment_content":"学数组的意外之喜，重新回顾了栈地址分配，栈地由高地址向低地址生长。评论区真是人才济济。","like_count":0},{"had_liked":false,"id":243289,"user_name":"爱码士","can_delete":false,"product_type":"c1","uid":1516495,"ip_address":"","ucode":"8E31D7E69F2C26","user_header":"https://static001.geekbang.org/account/avatar/00/17/23/cf/7429d6e8.jpg","comment_is_top":false,"comment_ctime":1598020495,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598020495","product_id":100017301,"comment_content":"标记删除算法，标记整理算法，G1(垃圾优先算法)","like_count":0},{"had_liked":false,"id":242897,"user_name":"凌波漫步","can_delete":false,"product_type":"c1","uid":1567545,"ip_address":"","ucode":"4CDAABBFB491E8","user_header":"https://static001.geekbang.org/account/avatar/00/17/eb/39/5c13ed3b.jpg","comment_is_top":false,"comment_ctime":1597886959,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597886959","product_id":100017301,"comment_content":"JAVA中数组的首地址为什么要定义为a［0］","like_count":0},{"had_liked":false,"id":242258,"user_name":"残天噬魂","can_delete":false,"product_type":"c1","uid":1506609,"ip_address":"","ucode":"A2AD8303A4518D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/q2HwchogzNiavKhIB4GfAxH6B88NhSoC7B7keVEUqiaP6JPokDUNJLYehocOyqYqrhA3iaxywyRXLYkYJjDUQESZw/132","comment_is_top":false,"comment_ctime":1597650202,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597650202","product_id":100017301,"comment_content":"二维数组内存寻址：<br>假设二维数组定义为arr[m][n]，对于arr[i][j](i&lt;m,j&lt;n)寻址公式应该是：a[i][j]_addr = base_addr + (n*(i-1)+j)*data_type+size","like_count":0},{"had_liked":false,"id":242244,"user_name":"DWong","can_delete":false,"product_type":"c1","uid":2103645,"ip_address":"","ucode":"2E7F567C228EE3","user_header":"","comment_is_top":false,"comment_ctime":1597646079,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597646079","product_id":100017301,"comment_content":"老师讲的数组删除算法的应用场景 好像像是JVM 中的标记整理算法","like_count":0},{"had_liked":false,"id":242108,"user_name":"剑影梦残","can_delete":false,"product_type":"c1","uid":1284481,"ip_address":"","ucode":"A5C5DAA49F6996","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/XSnxM4uP67mVu7ZtPxWqUIvFH15pibGt1rFd34EiblN6NFfgKEKBuibLlI1kUjOIfbY56icwBibn6MmXzSEXm7AHicdQ/132","comment_is_top":false,"comment_ctime":1597591093,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597591093","product_id":100017301,"comment_content":"1.jvm跟mono虚拟机应该是一样，如果内存不足，再去触发垃圾回收，会清除已经标记为垃圾的数据，再清空。清空后不足的话，再申请新的内存空间。   2.address = baseaddress+（i*n+j）*typesize","like_count":0},{"had_liked":false,"id":240734,"user_name":"李和桃","can_delete":false,"product_type":"c1","uid":1015877,"ip_address":"","ucode":"97E66953070EE0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/80/45/d719f7df.jpg","comment_is_top":false,"comment_ctime":1597047919,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597047919","product_id":100017301,"comment_content":"看到了正确答案 纠正错误答案<br>对于 m * n 的数组，a [ i ][ j ] (i &lt; m,j &lt; n)的地址为： address = base_address + ( i * n + j) * type_size","like_count":0},{"had_liked":false,"id":240733,"user_name":"李和桃","can_delete":false,"product_type":"c1","uid":1015877,"ip_address":"","ucode":"97E66953070EE0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/80/45/d719f7df.jpg","comment_is_top":false,"comment_ctime":1597047788,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597047788","product_id":100017301,"comment_content":"1、标记清除算法的步骤是：首先根据GCROOTS引用链路查找到尚存活的对象，做好标记。清除其他未被标记的对象。<br>缺点就是：产生内存碎片。所以对应的处理方式有CMS的空间整理，或者是带有标记-整理算法的垃圾回收器，如Parallel Old, Serial Old。<br>2、二维数组寻址公式，我理解的是object[][]首先通过一维坐标定位到一个object[]的地址，再通过第二维的坐标进行定位具体的object对象。具体的定位就是base_address + n * type_size，二维也是如此。","like_count":0},{"had_liked":false,"id":240724,"user_name":"Geek_b157dd","can_delete":false,"product_type":"c1","uid":2108508,"ip_address":"","ucode":"048B61439DD9BE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKT7Exm9wh9wlQo0B8Ry5DRCp3LfEibPEvZCPdX4fL2hkCe6x680UcJVL8RemrnOC6Ictsh533rn8Q/132","comment_is_top":false,"comment_ctime":1597045361,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597045361","product_id":100017301,"comment_content":"当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。<br>我这里有的没看懂,文中讲的是只有数组没有更多空间存储数据时才会执行一次真正的删除操作,那么如果我执行了删除下标为i与i+1的数组数据,这时我访问数组下标i的数据,因为没有执行数据搬移岂不是会有问题?还是说在查找的时候也会做一次删除和数据搬移然后再查找?","like_count":0},{"had_liked":false,"id":240312,"user_name":"授人以🐟，不如授人以渔","can_delete":false,"product_type":"c1","uid":1193874,"ip_address":"","ucode":"BD53829E924B66","user_header":"https://static001.geekbang.org/account/avatar/00/12/37/92/961ba560.jpg","comment_is_top":false,"comment_ctime":1596857649,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1596857649","product_id":100017301,"comment_content":"数组的逻辑结构：线性表结构；存储结构：连续的内存空间存储。数组支持随机访问，时间复杂度为O(1)。","like_count":0},{"had_liked":false,"id":239760,"user_name":"Jiantao","can_delete":false,"product_type":"c1","uid":1163504,"ip_address":"","ucode":"444580EC5EF109","user_header":"https://static001.geekbang.org/account/avatar/00/11/c0/f0/1aabc056.jpg","comment_is_top":false,"comment_ctime":1596635220,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596635220","product_id":100017301,"comment_content":"#cp&amp;modify<br>一、引子：为什么很多编程语言的数组都是从0开始编号的？<br>1、从数组存储的内存模型上来看，“下标”确切的说法就是一种“偏移”，相比从1开始编号，从0开始编号会少一次减法运算，数组作为非常基础的数组结构，通过下标随机访问元素又是非常基础的操作，效率的优化就要尽可能的做到极致。<br>2、主要的原因是历史原因，C语言的设计者是从0开始计数数组下标的，之后的Java、JS等语言都进行了效仿，或者说是为了减少从C转向Java、JS等的学习成本。<br>二、什么是数组？<br>数组是一个线性数据结构，用一组连续的内存空间存储一组具有相同类型的数据。<br>其实数组、链表、栈、队列都是线性表结构；树、图则是非线性表结构。<br>三、数组和链表的面试纠错？<br>1、数组中的元素存在一个连续的内存空间中，而链表中的元素可以不存在于连续的内存空间。<br>2、数组支持随机访问，根据下标随机访问的时间复杂度是O(1)；链表适合插入、删除操作，时间复杂度为O(1）。<br>四、容器是否完全替代数组？<br>容器的优势：对于Java语言，容器封装了数组插入、删除等操作的细节，并且支持动态扩容。<br>对于Java，一些更适合用数组的场景：<br>1、Java的ArrayList无法存储基本类型，需要进行装箱操作，而装箱与拆箱操作都会有一定的性能消耗，如果特别注意性能，或者希望使用基本类型，就可以选用数组。<br>2、若数组大小事先已知，并且对数组只有非常简单的操作，不需要使用到ArrayList提供的大部分方法，则可以直接使用数组。<br>3、多维数组时，使用数组会更加直观。<br>4. 非常底层的开发，性能的优化需要做到极致，这个时候数组就会优于容器。<br>五、JVM标记清除算法？<br>GC最基础的收集算法就是标记-清除算法，如同他们的名字一样，此算法分为“标记”、“清除”两个阶段，先标记出需要回收的对象，再统一回收标记的对象。不足有二，一是效率不高，二是产生碎片内存空间。<br>六、数组的内存寻址公式（前提：定长数组）<br>一维数组：a[i]_address=base_address+i*type_size<br>二维数组：二维数组假设是m*n， a[i][j]_address=base_address + (i*n+j)*type_size<br>三维数组：三维数组假设是m*n*q， a[i][j][k]_address=base_address + (i*n*q + j*q + k)*type_size","like_count":0},{"had_liked":false,"id":238835,"user_name":"老姚","can_delete":false,"product_type":"c1","uid":2049652,"ip_address":"","ucode":"61D8F2095DB538","user_header":"https://static001.geekbang.org/account/avatar/00/1f/46/74/0f6bdc0d.jpg","comment_is_top":false,"comment_ctime":1596338958,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596338958","product_id":100017301,"comment_content":"对于m * n 数组，二维数组寻址公式为：<br>a[i][j]_address = base_address + (i * n + j) * type_size","like_count":0},{"had_liked":false,"id":238813,"user_name":"Tomy","can_delete":false,"product_type":"c1","uid":1192601,"ip_address":"","ucode":"D7E49E90B0D60F","user_header":"https://static001.geekbang.org/account/avatar/00/12/32/99/91b58bf7.jpg","comment_is_top":false,"comment_ctime":1596330051,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596330051","product_id":100017301,"comment_content":"ArrayList与LinkedList比较","like_count":0},{"had_liked":false,"id":238294,"user_name":"SandCarving","can_delete":false,"product_type":"c1","uid":2056201,"ip_address":"","ucode":"6B97DB71613A46","user_header":"https://static001.geekbang.org/account/avatar/00/1f/60/09/a8e7913b.jpg","comment_is_top":false,"comment_ctime":1596113231,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596113231","product_id":100017301,"comment_content":"数组的寻址公式：<br>下标从0开始<br>Arr[i]=baseaddress+i*data_size<br>二维数组的寻址公式：<br>如果分配的容量是Arr[n][m]，则<br>Arr[i][j]=baseaddress+i*n*data_size+j*data_size=baseaddress+(i*n+j)*data_size<br>对于Java的JVM没有了解过，不过通过文章大致的意思是，JVM的垃圾回收机制是<br>通过标记来标识内存中需要清理的对象，然后把这个回收工作延迟到某一个节点进行，<br>这样可以减少内存回收的次数，但有可能每次回收会比较耗时，且这个会有一定的开销。","like_count":0},{"had_liked":false,"id":238293,"user_name":"SandCarving","can_delete":false,"product_type":"c1","uid":2056201,"ip_address":"","ucode":"6B97DB71613A46","user_header":"https://static001.geekbang.org/account/avatar/00/1f/60/09/a8e7913b.jpg","comment_is_top":false,"comment_ctime":1596113184,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596113184","product_id":100017301,"comment_content":"数组的寻址公式：<br>下标从0开始<br>Arr[i]=baseaddress+i*data_size<br>二维数组的寻址公式：<br>如果分配的容量是Arr[n][m]，则<br>Arr[i][j]=i*n*data_size+j*data_size=(i*n+j)*data_size<br>对于Java的JVM没有了解过，不过通过文章大致的意思是，JVM的垃圾回收机制是<br>通过标记来标识内存中需要清理的对象，然后把这个回收工作延迟到某一个节点进行，<br>这样可以减少内存回收的次数，但有可能每次回收会比较耗时，且这个会有一定的开销。","like_count":0},{"had_liked":false,"id":238179,"user_name":"Aaron 延亮","can_delete":false,"product_type":"c1","uid":1394147,"ip_address":"","ucode":"48DE83DDF45A61","user_header":"https://static001.geekbang.org/account/avatar/00/15/45/e3/26d1e69c.jpg","comment_is_top":false,"comment_ctime":1596090034,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596090034","product_id":100017301,"comment_content":"栈缓冲区溢出，有兴趣的可以研究下c语言在不同编译器下的调用约定和栈结构","like_count":0},{"had_liked":false,"id":238038,"user_name":"talor","can_delete":false,"product_type":"c1","uid":1350638,"ip_address":"","ucode":"245EE908DA39EC","user_header":"https://static001.geekbang.org/account/avatar/00/14/9b/ee/211e86cd.jpg","comment_is_top":false,"comment_ctime":1596033797,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596033797","product_id":100017301,"comment_content":"用gdb看了下，i 的地址的确是&amp;a[2]+4，这样就明白为什么会无限循环了","like_count":0},{"had_liked":false,"id":237580,"user_name":"imoling","can_delete":false,"product_type":"c1","uid":1049854,"ip_address":"","ucode":"9BACE03314D3BA","user_header":"https://static001.geekbang.org/account/avatar/00/10/04/fe/f3b31bcc.jpg","comment_is_top":false,"comment_ctime":1595875953,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595875953","product_id":100017301,"comment_content":"评论和原文一样精彩，受益匪浅","like_count":0},{"had_liked":false,"id":237171,"user_name":"Geek_Yummy","can_delete":false,"product_type":"c1","uid":2058676,"ip_address":"","ucode":"4481A45A88F92D","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM5VicLUumiaZbMUZT7CzNL5AFjtovSia11GzwiayycTYMAlYOFInoXyCPRd2kClicB1dVsth337ABlCZng/132","comment_is_top":false,"comment_ctime":1595713546,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1595713546","product_id":100017301,"comment_content":"把这节课内容都搞懂花了我一天时间，各种知识的拓展：<br>- 数组内存储存方式，a[0]在低位，a[n-1]在高位<br>- 多维数组存储地址，参考@Neuject 同学<br>- 数组的插入和删除，原来也可以有巧思，可以提高效率<br>- 代码里的 i 和 a[3] 数组越界问题，要考虑到局部变量在程序里的存储位置是栈，从高位向低位拓展，且数据类型一样。所以当声明时是以int i，a[3] 的顺序时，就会出现因为越界而死循环的情况 （复习操作系统的程序内存分布）<br>- 容器和数组，容器动态扩容时大小有1.5倍。经测试，不同编译器策略不同，VS是1.5倍，GCC是2倍，python的list是先2倍后线性增长 （欢迎指正 https:&#47;&#47;editor.csdn.net&#47;md&#47;?articleId=107584921）<br><br>一个知识点可以牵引出n个知识点呀~~<br>评论区大牛还是多！！","like_count":0,"discussions":[{"author":{"id":1178136,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fa/18/710018cb.jpg","nickname":"飞翔明天","note":"","ucode":"F2E6FEAC77070B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340124,"discussion_content":"你也是大牛","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609909560,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236917,"user_name":"Geek_6725b5","can_delete":false,"product_type":"c1","uid":1991426,"ip_address":"","ucode":"379B3DDD67B774","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/JuoHr2r7lA9Sh7Phmrw86JVObha0hKsSYraibvicmVHdYe4UibB3htibR3IqdXGbzHYGicViblSseqdzG2hrSMD1OewA/132","comment_is_top":false,"comment_ctime":1595584157,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1595584157","product_id":100017301,"comment_content":"数组由于在内存中连续排列且类型相同，因此对于随机访问的算法复杂度为O(1),这是数组最大的优势。同样由于连续排列，因此插入，删除的平均复杂度为O(n)。不过可以通过标记，删除调换的方法将复杂度降低。均摊复杂度依然为O(1)，改善了性能。可见数据结构和算法是死的，但是用的人可以改进扬长避短。容器的使用降低了效率，在容器数量的分配上也需要注意。","like_count":0},{"had_liked":false,"id":236904,"user_name":"朱雯","can_delete":false,"product_type":"c1","uid":1035744,"ip_address":"","ucode":"064C45FBF6B51F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cd/e0/c85bb948.jpg","comment_is_top":false,"comment_ctime":1595580648,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1595580648","product_id":100017301,"comment_content":"老师谈到了arraylist，我想问一下arraylist是数组吗。有没有数组随机访问的效果呢。我查到的相关信息是arraylist是动态数组，也就是您在这变讲的当数组到达边界数量不够的时候，他就扩容1.5倍。如果是数组，那如何实现随机访问的效果呢，int的长度是4，short长度2，但是arraylist同时可以存int和short。这里我比较迷糊。","like_count":0},{"had_liked":false,"id":236584,"user_name":"陈琦","can_delete":false,"product_type":"c1","uid":1607864,"ip_address":"","ucode":"48F974137EF0BE","user_header":"https://static001.geekbang.org/account/avatar/00/18/88/b8/7527da95.jpg","comment_is_top":false,"comment_ctime":1595472082,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595472082","product_id":100017301,"comment_content":"使用VS2019 Debug 模式下使用C++，下述代码没有死循环：<br>int main(int argc, char* argv[]){<br>    int i = 0;<br>    int arr[3] = {0};<br>    for(; i&lt;=3; i++){<br>        arr[i] = 0;<br>        printf(&quot;hello world\\n&quot;);<br>    }<br>    return 0;<br>}","like_count":0},{"had_liked":false,"id":236287,"user_name":"寒江雪","can_delete":false,"product_type":"c1","uid":2073453,"ip_address":"","ucode":"0738459213414C","user_header":"https://static001.geekbang.org/account/avatar/00/1f/a3/6d/2107f4a0.jpg","comment_is_top":false,"comment_ctime":1595385494,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595385494","product_id":100017301,"comment_content":"删除标记是不是要占用额外的内存空间？这样的话是牺牲空间效率换取时间效率吗？<br>","like_count":0},{"had_liked":false,"id":235672,"user_name":"🐻🔫🐸","can_delete":false,"product_type":"c1","uid":1308880,"ip_address":"","ucode":"40BABFD9D358BF","user_header":"https://static001.geekbang.org/account/avatar/00/13/f8/d0/ecc68a4f.jpg","comment_is_top":false,"comment_ctime":1595145696,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595145696","product_id":100017301,"comment_content":"这个无限循环挺有意思，在我的macos上i属于内存低位 arr属于高位，所以就循环四次结束了","like_count":0},{"had_liked":false,"id":234451,"user_name":"Geek_92b89e","can_delete":false,"product_type":"c1","uid":2061044,"ip_address":"","ucode":"6ECC4DC862DEAF","user_header":"","comment_is_top":false,"comment_ctime":1594694407,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594694407","product_id":100017301,"comment_content":"1、只要内存够就不删除，标记一下供后续程序使用即可<br>2、二维数组寻址公式：address = base_address + (i * n + j) * data_type","like_count":0},{"had_liked":false,"id":234117,"user_name":"醉梦了红尘","can_delete":false,"product_type":"c1","uid":1889141,"ip_address":"","ucode":"DB742865BAD6B6","user_header":"","comment_is_top":false,"comment_ctime":1594600041,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594600041","product_id":100017301,"comment_content":"二维地址寻址: 定义数据int a[i][j]，二维数组内存行优先即 a[0][0],a[0][1]...a[0][j-1], a[1][0]...<br>所以 a[m][n] = &amp;a[0] + sizeof(int)*j*m + sizeof(int)*n；","like_count":0},{"had_liked":false,"id":234050,"user_name":"Merry","can_delete":false,"product_type":"c1","uid":1024036,"ip_address":"","ucode":"E2A114E10814BA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a0/24/68c679c8.jpg","comment_is_top":false,"comment_ctime":1594565195,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594565195","product_id":100017301,"comment_content":"思考2:a[i][j]_address = bass_address + {(i-1)* row_size + j} * type_size<br>&#47;&#47; row_size为二维数组行长度","like_count":0},{"had_liked":false,"id":233839,"user_name":"白大米","can_delete":false,"product_type":"c1","uid":1001545,"ip_address":"","ucode":"0A4EC07A708406","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/49/32316d12.jpg","comment_is_top":false,"comment_ctime":1594469935,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594469935","product_id":100017301,"comment_content":"对多维数组寻址不明白的同学可以点击这个链接学习一下多维数据的情况<br><br>https:&#47;&#47;www.liaoxuefeng.com&#47;wiki&#47;1252599548343744&#47;1259544232593792","like_count":0},{"had_liked":false,"id":233392,"user_name":"小吴大人","can_delete":false,"product_type":"c1","uid":1795769,"ip_address":"","ucode":"4187A1E3AFCE84","user_header":"https://static001.geekbang.org/account/avatar/00/1b/66/b9/52e303cf.jpg","comment_is_top":false,"comment_ctime":1594306468,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594306468","product_id":100017301,"comment_content":"记录数组已经删除的数据，这里的内存需要重新申请还是其它怎么操作？","like_count":0},{"had_liked":false,"id":233332,"user_name":"ABCD","can_delete":false,"product_type":"c1","uid":2055971,"ip_address":"","ucode":"CC604A344D98BA","user_header":"https://static001.geekbang.org/account/avatar/00/1f/5f/23/c9a57cc3.jpg","comment_is_top":false,"comment_ctime":1594289784,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594289784","product_id":100017301,"comment_content":"之前做过一个效率上的对比，就是使用数组分别保存三维的x,y,z坐标数据，另一个实现当时是用C++定义的节点类，定义节点坐标获取的get接口，分别在release和debug下面做过效率的比较，注意是单纯测试坐标的访问效率，测试结果有点奇怪，就是在debug模式下可以明显看出使用数组的优势，但是在release下面却是另一个相反的结果，老师知道这是为什么吗？","like_count":0},{"had_liked":false,"id":232646,"user_name":"雨中送陈萍萍","can_delete":false,"product_type":"c1","uid":1457879,"ip_address":"","ucode":"409FA76EEED669","user_header":"https://static001.geekbang.org/account/avatar/00/16/3e/d7/399d2ba5.jpg","comment_is_top":false,"comment_ctime":1594079115,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594079115","product_id":100017301,"comment_content":"Lua语言table就是从1开始的","like_count":0},{"had_liked":false,"id":232008,"user_name":"williamcai","can_delete":false,"product_type":"c1","uid":1158294,"ip_address":"","ucode":"B158F52C2D39BC","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/96/46b13896.jpg","comment_is_top":false,"comment_ctime":1593830205,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593830205","product_id":100017301,"comment_content":"1、jvm中标记清除算法，先标记呆删除的对象，然后等gc触发的时候，统一清除，但是这样容易产生内存碎片，如果要为大的对象分配，找不到合适的空间的话，就会触发gc,进而影响程序运行，一般不建议用，用的比较多的是 标记复制算法和标记压缩算法；<br>2、二维数组a[i][j] ,如果是按照行存储，a[i][j]_address=base_address+i*5+j;如果按照列存储，a[i][j]_address=base_address+j*3+i;","like_count":0},{"had_liked":false,"id":231840,"user_name":"小小灬厮","can_delete":false,"product_type":"c1","uid":1445003,"ip_address":"","ucode":"F4197D2F73364B","user_header":"https://static001.geekbang.org/account/avatar/00/16/0c/8b/3f7e9e74.jpg","comment_is_top":false,"comment_ctime":1593784557,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593784557","product_id":100017301,"comment_content":"李兵老师的课 V8垃圾回收机制：<br>https:&#47;&#47;time.geekbang.org&#47;column&#47;article&#47;131233<br>13 | 垃圾回收：垃圾数据是如何自动回收的？<br><br>1. 在 V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。<br>2. 副垃圾回收器，主要负责新生代的垃圾回收。主垃圾回收器，主要负责老生代的垃圾回收。<br>3. 副垃圾回收器 新生代 Scavenge 算法：<br>1. 分为对象区域和空闲区域（老对象所在区域）<br>2. 进行标记<br>3. 存活对象移动到空闲区域，并排序整理<br>4. 清理对象区域<br>5. 翻转两个区域<br>6. 继续重复第二步进行清理<br>7. 新生区的空间不大，经过两次回收还存活的对象，通过 对象晋升策略 移动到老生区中<br>4. 主垃圾回收器 主生代 标记 - 清除（Mark-Sweep）：<br>1. 标记：遍历调用栈，如果未找到对应地址的引用，标记为垃圾数据，否则标记为活动对象<br>2. 清除标记为垃圾的数据<br>3. 整理非连续的内存碎片","like_count":0},{"had_liked":false,"id":231064,"user_name":"憎爱不关心","can_delete":false,"product_type":"c1","uid":1133580,"ip_address":"","ucode":"A868ACB200C798","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/0c/ada45f25.jpg","comment_is_top":false,"comment_ctime":1593573191,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593573191","product_id":100017301,"comment_content":"谢谢老师。<br>1.不熟悉Java<br>2.m*n的数组，a[i][j] = a首地址+(i*n+j)*typesize","like_count":0},{"had_liked":false,"id":230688,"user_name":"jack","can_delete":false,"product_type":"c1","uid":1898292,"ip_address":"","ucode":"A2253AC8570C5E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/jibauP3icEFic4w56L2ddVghL7h2gGKhFdW8lBfE9rpwwRgzUKkLFY9wb4w70AXz7retME96a6EBRTA0LvSLn0ib8A/132","comment_is_top":false,"comment_ctime":1593453801,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1593453801","product_id":100017301,"comment_content":"对于第一个问题：JVM的标记清除垃圾算法——JVM不会马上清理“标记为垃圾的资源：，只有待存储垃圾的内存空间已满才会清除垃圾（释放资源，回收空间）；<br>对于第二个问题：对于二维数组元素a[i][j]（i&lt;m，j&lt;n），其地址=base_address+(i * n + j) * size_vartype。","like_count":0},{"had_liked":false,"id":230531,"user_name":"Gosling⁶先生","can_delete":false,"product_type":"c1","uid":2041090,"ip_address":"","ucode":"CD2A69096A9287","user_header":"https://static001.geekbang.org/account/avatar/00/1f/25/02/0cc143f6.jpg","comment_is_top":false,"comment_ctime":1593410765,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593410765","product_id":100017301,"comment_content":"标记清除法是遍历所有的GC ROOT，分别标记处可达的对象和不可达的对象，然后将不可达的对象回收。<br>数组：<br>1.如何实现下标随机访问数组元素<br>a[k]_address = base_address + k * type_size（字节大小）<br>数组在每一个内存块都会分配一个连续的内存空间，<br>然后根据首地址和对应的数组下标*数据类型的字节大小去查询地址，在根据地址去查询数组的位置<br>2.为什么下标是从0开始<br>因为在计算数组元素地址时，是根据数组下标去计算的，如果以1开始，就会计算下标-1的地址位置，这样就会多了一次-1的计算逻辑<br>3.为什么是低效的插入和删除<br>因为每一个插入和删除，数组都要做移位，但是假设在删除的时候，先做标记删除，当数组没有内存空间的时候，在进行实际删除，这样就会节省了数组移位的过程。<br>4.数据越界<br>首先为什么数组会越界，因为对于数组长度来说是有限制的，如果说对应查找的值比数组长度要大的时候，就会超过数组而查不到值，但是在内存里面，按栈的角度来说，从高位到低位，也就是当下标大于最大数组长度时，是位于最高位，通过地址搜寻法，就会出现最高位找不到值的时候，由于基础类型默认值是0，就会出现与数组下标0最开始的值，导致死循环。<br>而在jvm底层代码逻辑里，无论是插入还是查询都会进行判断数组长度和下标的匹配（!a-&gt;is_within_bounds(index)），当下标大于数组长度的时候，就会抛出java.lang.ArrayIndexOutOfBoundsException的异常，这是属于java特有的对数组长度的处理机制。<br>","like_count":0},{"had_liked":false,"id":230438,"user_name":"jack","can_delete":false,"product_type":"c1","uid":1898292,"ip_address":"","ucode":"A2253AC8570C5E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/jibauP3icEFic4w56L2ddVghL7h2gGKhFdW8lBfE9rpwwRgzUKkLFY9wb4w70AXz7retME96a6EBRTA0LvSLn0ib8A/132","comment_is_top":false,"comment_ctime":1593391456,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1593391456","product_id":100017301,"comment_content":"“a[3]也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址”，那请问：老师，为何a[3]被定位的地址恰好是变量i的内存地址？","like_count":0},{"had_liked":false,"id":230088,"user_name":"村雨遥","can_delete":false,"product_type":"c1","uid":1984060,"ip_address":"","ucode":"BA00666B968527","user_header":"https://static001.geekbang.org/account/avatar/00/1e/46/3c/cd82adba.jpg","comment_is_top":false,"comment_ctime":1593254726,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593254726","product_id":100017301,"comment_content":"这是我学习数组篇之后所做的笔记，欢迎大家一起交流学习！<br>https:&#47;&#47;blog.csdn.net&#47;github_39655029&#47;article&#47;details&#47;106986323","like_count":0},{"had_liked":false,"id":229837,"user_name":"Ray","can_delete":false,"product_type":"c1","uid":2046685,"ip_address":"","ucode":"37E86CE67F004B","user_header":"https://static001.geekbang.org/account/avatar/00/1f/3a/dd/e44bacb8.jpg","comment_is_top":false,"comment_ctime":1593159400,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593159400","product_id":100017301,"comment_content":"每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。<br>那么问题来了，只是记录数据已经被删除，那当我查询被删除的元素，不就查到了吗","like_count":0},{"had_liked":false,"id":229445,"user_name":"Tino＇s Park","can_delete":false,"product_type":"c1","uid":1288013,"ip_address":"","ucode":"57FABA7F28BCF9","user_header":"https://static001.geekbang.org/account/avatar/00/13/a7/4d/096e99ec.jpg","comment_is_top":false,"comment_ctime":1592997592,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592997592","product_id":100017301,"comment_content":"首先并不是所有的标记清理算法都是先标记，然后到内存不够用再清扫。<br><br>原始发标记-清扫算法是串行的。但是已经很少使用，现在大多数实际应用的算法都是并行的。例如三色标记算法加wb。扫描基本思路前面一位童鞋已经说过。只补充下扫描阶段会有stw. ","like_count":0},{"had_liked":false,"id":229392,"user_name":"李瑞景","can_delete":false,"product_type":"c1","uid":1987448,"ip_address":"","ucode":"FD8CF4E132360C","user_header":"","comment_is_top":false,"comment_ctime":1592983297,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592983297","product_id":100017301,"comment_content":"1、对于删除操作只做标记不删除的操作，如果是一个会频繁查询的业务场景那在查找的同时是不是也需要进行对此元素是否删除的判断，那这样他的时间复杂度就会根据你要删除数据的数量而增加，这样对于一个频繁查询的业务来说应该算是得不偿失吧。<br>2、数组中如果存的不是基本类型数据，那数组中存的是内存地址吗？","like_count":0},{"had_liked":false,"id":228764,"user_name":"浩然","can_delete":false,"product_type":"c1","uid":1378201,"ip_address":"","ucode":"FC771E92869796","user_header":"https://static001.geekbang.org/account/avatar/00/15/07/99/2c12c56c.jpg","comment_is_top":false,"comment_ctime":1592803393,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592803393","product_id":100017301,"comment_content":"老师您好 我想问下javascript中的数组寻址是如何进行的。<br>js的数组是无类型的<br>js的数组还有稀疏数组和连续数组，这样是如何寻址的呢。<br>寻址的方式是由浏览器来实现的？","like_count":0},{"had_liked":false,"id":228165,"user_name":"大大大熊myeh","can_delete":false,"product_type":"c1","uid":1139413,"ip_address":"","ucode":"4832C2E7CEB151","user_header":"https://static001.geekbang.org/account/avatar/00/11/62/d5/1f5c5ab6.jpg","comment_is_top":false,"comment_ctime":1592572964,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592572964","product_id":100017301,"comment_content":"1.标记清除算法：根据可达性分析算法，从Root节点开始遍历，将所有可达到的对象标记为存活。标记完成后，将所有未被标记为完成的对象清除。<br>标记清除算法会导致存在不连续的空间碎片。<br><br>2.二维数组寻址：没有了解过，猜测根据数组大小进行计算。比如int二维数组，大小为10*10，那么前40个空间为第一行，以此类推。","like_count":0},{"had_liked":false,"id":227742,"user_name":"Mike Zheng","can_delete":false,"product_type":"c1","uid":2039829,"ip_address":"","ucode":"D7F062DDE2A93A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Ccdlzibsv0umJB4QeX0K6JBAas41F3Xobib8rudwic6vNgNYVa4WUdhU9vMKfKRuU3P0u3V0flrn2tlOrDdlCBFmQ/132","comment_is_top":false,"comment_ctime":1592468155,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592468155","product_id":100017301,"comment_content":"王老师好，想请教下「删除无序数组的第 k 个元素」，能否通过搬移数组尾部元素到该位置，实现时间复杂度 O(1)？","like_count":0},{"had_liked":false,"id":227454,"user_name":"Mamba","can_delete":false,"product_type":"c1","uid":1475049,"ip_address":"","ucode":"8B3EC90736B8EB","user_header":"https://static001.geekbang.org/account/avatar/00/16/81/e9/d131dd81.jpg","comment_is_top":false,"comment_ctime":1592383045,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592383045","product_id":100017301,"comment_content":"1.还没实战经验，只能从理论谈谈——标记清除垃圾回收算法分为两步，标记阶段需要标记出所有需要回收的对象，而清除阶段则在其后统一回收掉所有被标记的对象。这个算法也有缺点，就是会造成大量碎片。<br>2.类比一维数组，对于m行n列的二维数组arr，其中某一个元素arr[i][j]的位置则为<br>arr[i][j]_address=base_address+（i*m+j）*type_size<br><br>对于数组越界的问题我先是看了评论区几位大佬的回答，然后做了实验，对于我的电脑以及我的编译器dev，结果表明分配空间是从高地址到低地址，而且是16位对齐的","like_count":0},{"had_liked":false,"id":226489,"user_name":"CoderArthur","can_delete":false,"product_type":"c1","uid":1625233,"ip_address":"","ucode":"5B591914F0F67C","user_header":"https://static001.geekbang.org/account/avatar/00/18/cc/91/d56a81af.jpg","comment_is_top":false,"comment_ctime":1592120231,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592120231","product_id":100017301,"comment_content":"【问题1】<br>不了解<br><br>【问题2】<br>数组大小  m*n<br>a[i][j] 的地址： base_addr + ( n * i + j) * element_size  ","like_count":0},{"had_liked":false,"id":226374,"user_name":"L","can_delete":false,"product_type":"c1","uid":1228268,"ip_address":"","ucode":"26BB686671F7D4","user_header":"https://static001.geekbang.org/account/avatar/00/12/bd/ec/cc7abf0b.jpg","comment_is_top":false,"comment_ctime":1592054165,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1592054165","product_id":100017301,"comment_content":"对于删除的标记的疑问<br>假如给删除的内容做一次标记，那么查找的时候不是还要针对标记进行判断，反而导致了更加常见的查找操作的速度变慢？","like_count":0},{"had_liked":false,"id":226188,"user_name":"总会有那么一天","can_delete":false,"product_type":"c1","uid":1741846,"ip_address":"","ucode":"5B1A5ED06E6A78","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLrbyvyBdlQfH4qEuPvALXPxbG4qMrLibibntO4WInf7ViaVYcIUmriblbEosNLKoEdATSBTKmrk1YrXw/132","comment_is_top":false,"comment_ctime":1591974743,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591974743","product_id":100017301,"comment_content":"这次学到的内容：<br>1.数组用一组连续的内存空间存储一组相同类型的数据结构。分类，线性表：数组，链表，栈，队列；非线性表，树和图。<br>2.数组的特性，数组支持随机访问，根据下标随机访问的时间复杂度为O(1).而插入和删除会增加大量的性能，时间复杂度为O(n)。在不关心数据的顺序的情况下，插入的时间复杂度可以为O（1），删除多个元素的时间复杂度也可以大大降低。<br>3.数组越界，C语言中局部变量会压栈，i，a[2],a[1],a[0],a[3]=0等价于i为0，因此会无限循环下去。<br>但是很多高级语言，Java会做越界检查。<br>4.容器，容器会将很多数组的操作细节封装起来，并支持动态扩容，每次将空间自动扩容为原来的1.5倍。在平时的业务开发中，还是多用容器操作；只有在底层设计，可以考虑数组。<br>思考题<br>JVM标记清楚回收算法，由于不懂JVM,但是留言还是很多大神，自己课下多补补基础。<br>二维数组啊m行n列a[m][n]其中：a[i][j] = base  + I*n*size + j * size;<br><br>","like_count":0},{"had_liked":false,"id":225993,"user_name":"LeeWong","can_delete":false,"product_type":"c1","uid":1457272,"ip_address":"","ucode":"14A39710472221","user_header":"https://static001.geekbang.org/account/avatar/00/16/3c/78/9f052793.jpg","comment_is_top":false,"comment_ctime":1591925425,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591925425","product_id":100017301,"comment_content":"想问下 数组只能存放相同类型的数据 那么在OC中的数组是可以存放不同类型的数据的(多种对象) 那么 OC中的数组是 到底是不是数组呢？或者理解为数组中存放的都是指针 指向某一块内存地址！","like_count":0},{"had_liked":false,"id":225895,"user_name":"rice","can_delete":false,"product_type":"c1","uid":2033770,"ip_address":"","ucode":"7F50AEABE82BB5","user_header":"https://static001.geekbang.org/account/avatar/00/1f/08/6a/20500b73.jpg","comment_is_top":false,"comment_ctime":1591884564,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591884564","product_id":100017301,"comment_content":"JVM标记清除算法<br>标记：通过GC Roots可达性分析，遍历所有对象的GC Roots，然后将所有GC Roots不可达的对象标记为待清除的对象。<br>清除：然后遍历所有的对象，将被标记的待清除的对象进行清除<br><br>二维数组的寻址方式：<br>对于一个m*n的二维数组进行分析<br>其中对arr[i][j] （i&lt;m, j&lt;n）进行分析<br>a[i][j]_address = base_address + i * (n * type_size) + j * type_size<br>                    = base_address + type_size * (i * n + j)","like_count":0},{"had_liked":false,"id":225025,"user_name":"极客学子","can_delete":false,"product_type":"c1","uid":1149510,"ip_address":"","ucode":"40051597564EB7","user_header":"https://static001.geekbang.org/account/avatar/00/11/8a/46/71747b18.jpg","comment_is_top":false,"comment_ctime":1591619733,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591619733","product_id":100017301,"comment_content":"1. 标记清除垃圾回收算法就是在触发GC的时候，通过可达性分析算法以GC root为根进行引用链分析，如果一个对象能从GC Root 开始遍历引用关系能到达它，就证明这个对象可达，会被标记为可达，当对象全部分析完后，会对不可达的对象进行清理;<br>2. 比如二维数组 Object[i][j] 的内存地址 = 首地址 +  i *  Object[0].len + j","like_count":0},{"had_liked":false,"id":224681,"user_name":"小文","can_delete":false,"product_type":"c1","uid":1177540,"ip_address":"","ucode":"974071FAA5F173","user_header":"https://static001.geekbang.org/account/avatar/00/11/f7/c4/bd7dd30a.jpg","comment_is_top":false,"comment_ctime":1591505733,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591505733","product_id":100017301,"comment_content":"删除如果是无序的话也可以是O(1)复杂度删除吧，把要删除的数和末尾的数调个位置然后删除，也不需要移动那么多数","like_count":0},{"had_liked":false,"id":224308,"user_name":"keanuhrb","can_delete":false,"product_type":"c1","uid":2030694,"ip_address":"","ucode":"CFE83FF18DD24C","user_header":"","comment_is_top":false,"comment_ctime":1591341979,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591341979","product_id":100017301,"comment_content":"数组从0开始也是遵循计算机从0开始计数的理念吧？还有，觉得老师在这里有一句话容易引起歧义。python支持负数下标，但是这个负数下标是表示从后往前的访问，希望不会有同学以为是从0位置开始再往前访问。","like_count":0},{"had_liked":false,"id":223503,"user_name":"Geek_849f9f","can_delete":false,"product_type":"c1","uid":2027473,"ip_address":"","ucode":"67601F35A91999","user_header":"","comment_is_top":false,"comment_ctime":1591103918,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591103918","product_id":100017301,"comment_content":"二维数组大小m*n，对于第a[i][j]上的内存寻址：base_address+(i*n + j)*type_size","like_count":0},{"had_liked":false,"id":222191,"user_name":"刘胜","can_delete":false,"product_type":"c1","uid":1251625,"ip_address":"","ucode":"487374D72543E3","user_header":"https://static001.geekbang.org/account/avatar/00/13/19/29/f9490983.jpg","comment_is_top":false,"comment_ctime":1590714657,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590714657","product_id":100017301,"comment_content":"我理解的标记清除算法，是当程序进程的内存消耗较大的时候，虚拟机触发标记算法，如果对象没有被引用就标记为可回收，这样当内存不够触发GC的时候，就把之前攒的标记为可回收的对象一次性全部回收掉。二位数组存储对象前后位a[j][k]=a[0][0] + (j+1)*(k+1)-1datatypesize ","like_count":0},{"had_liked":false,"id":220364,"user_name":"刘同青","can_delete":false,"product_type":"c1","uid":1818343,"ip_address":"","ucode":"84B62DF8BC61FB","user_header":"","comment_is_top":false,"comment_ctime":1590227039,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590227039","product_id":100017301,"comment_content":"课后题：<br><br>2、m行n列的数组，位置（i,j）的寻址是 base + i * (n * type_size) + j * type_size","like_count":0},{"had_liked":false,"id":218041,"user_name":"Mason","can_delete":false,"product_type":"c1","uid":2007705,"ip_address":"","ucode":"3F37A0905D08D0","user_header":"https://static001.geekbang.org/account/avatar/00/1e/a2/99/61c24fbd.jpg","comment_is_top":false,"comment_ctime":1589700990,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589700990","product_id":100017301,"comment_content":"二维数组就是多了一个一维数组的长度的指针跳转长度","like_count":0},{"had_liked":false,"id":217914,"user_name":"吴贤龙","can_delete":false,"product_type":"c1","uid":1220566,"ip_address":"","ucode":"45085FE86D6030","user_header":"https://static001.geekbang.org/account/avatar/00/12/9f/d6/f66133b4.jpg","comment_is_top":false,"comment_ctime":1589645654,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589645654","product_id":100017301,"comment_content":"老师，那个无线循环的例子里， 为何超出索引范围的a[3]，为什么它的地址刚好是变量i的地址，怎么算出来的呢？","like_count":0},{"had_liked":false,"id":217445,"user_name":"Geek_Coke","can_delete":false,"product_type":"c1","uid":1795779,"ip_address":"","ucode":"CEBA67D4A41079","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/lZziapCQpYNzHHOzSRhcBO3pHm6VddSgediaTZe1KU9kNrGnh13oSes5kVfe6NaQNouP6kG0rU8bibQgBcGwueibmw/132","comment_is_top":false,"comment_ctime":1589506287,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589506287","product_id":100017301,"comment_content":"想问一下，数组的交换内存地址是怎样变化的","like_count":0},{"had_liked":false,"id":216473,"user_name":"fxlego","can_delete":false,"product_type":"c1","uid":1634260,"ip_address":"","ucode":"32B09E5B542BBA","user_header":"https://static001.geekbang.org/account/avatar/00/18/ef/d4/292132f9.jpg","comment_is_top":false,"comment_ctime":1589267481,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589267481","product_id":100017301,"comment_content":"一位数组寻址公式：<br>a[i]_address = base_address + i * type_size<br><br>假设二维数组大小是m*n，则其寻址公式为：<br>a[i][j]_address = base_address + (i*n+j) * type_size","like_count":0},{"had_liked":false,"id":216307,"user_name":"punnpkin","can_delete":false,"product_type":"c1","uid":1691517,"ip_address":"","ucode":"E635BD016D892F","user_header":"https://static001.geekbang.org/account/avatar/00/19/cf/7d/d9085aaa.jpg","comment_is_top":false,"comment_ctime":1589239733,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589239733","product_id":100017301,"comment_content":"二刷二刷","like_count":0},{"had_liked":false,"id":215875,"user_name":"七月","can_delete":false,"product_type":"c1","uid":1988043,"ip_address":"","ucode":"876EE5EAEC9DC4","user_header":"https://static001.geekbang.org/account/avatar/00/1e/55/cb/9c23f47d.jpg","comment_is_top":false,"comment_ctime":1589123456,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589123456","product_id":100017301,"comment_content":"从第一次开始听，半知半解;第二次听看文稿理解，在配合留言区里的大牛回答真正弄懂;第三次听遍写文章，很赞。","like_count":0},{"had_liked":false,"id":215848,"user_name":"归零","can_delete":false,"product_type":"c1","uid":1103208,"ip_address":"","ucode":"C99B8E93009A46","user_header":"https://static001.geekbang.org/account/avatar/00/10/d5/68/2201b6b9.jpg","comment_is_top":false,"comment_ctime":1589117849,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1589117849","product_id":100017301,"comment_content":"问一个小白问题，在争哥举得C语言越界的例子中，为什么arr[3]的地址是i的内存地址？求大神解答","like_count":0},{"had_liked":false,"id":215729,"user_name":"wuwei","can_delete":false,"product_type":"c1","uid":1689329,"ip_address":"","ucode":"DA60894F10C71F","user_header":"https://static001.geekbang.org/account/avatar/00/19/c6/f1/aac154fe.jpg","comment_is_top":false,"comment_ctime":1589088399,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589088399","product_id":100017301,"comment_content":"数组：<br>最基本的数据结构，支持快速的随机访问O(1)，但插入和删除效率不高O(n)，因为数组是连续的内存，元素发生变化就要移动元素保证内存的连续。<br><br>下标a[i][j](mxn )= base_adress + ( i*n + m)","like_count":0},{"had_liked":false,"id":215507,"user_name":"改变就是好事","can_delete":false,"product_type":"c1","uid":1768206,"ip_address":"","ucode":"12179F324E7DB5","user_header":"https://static001.geekbang.org/account/avatar/00/1a/fb/0e/8109b839.jpg","comment_is_top":false,"comment_ctime":1589005651,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589005651","product_id":100017301,"comment_content":"假设计算 a[k][j] 的内存位置：<br>&#47;&#47;一维数组中内存位置<br>a[k] = base_address + k * type_size<br>&#47;&#47;一维数组中的内存位置即二维数组中的起始位置，<br>a[k][j] = base_address + k * type_size + j * type2_size ","like_count":0},{"had_liked":false,"id":215482,"user_name":"苏玉虎","can_delete":false,"product_type":"c1","uid":1997283,"ip_address":"","ucode":"34E3623F093932","user_header":"https://static001.geekbang.org/account/avatar/00/1e/79/e3/918fedca.jpg","comment_is_top":false,"comment_ctime":1588999416,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588999416","product_id":100017301,"comment_content":"二维数组在内存块中的空间分配和数值存储 例如 Int[m][n] （m&gt;1,m&gt;1）,存储后 int[0][0] 与 in[0][1]、int[1][0] 哪个在地址上是连续的 是否还与 行优先 列优先有关？","like_count":0},{"had_liked":false,"id":215038,"user_name":"酸辣土豆丝","can_delete":false,"product_type":"c1","uid":1751234,"ip_address":"","ucode":"0E3E4AFB31E1E6","user_header":"https://static001.geekbang.org/account/avatar/00/1a/b8/c2/d1904d74.jpg","comment_is_top":false,"comment_ctime":1588894985,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588894985","product_id":100017301,"comment_content":"二维数组的寻址方式，先寻址最外层的地址，然后最外层的地址，作为首地址，来进一步根据偏移量来计算","like_count":0},{"had_liked":false,"id":214926,"user_name":"tjxcoding","can_delete":false,"product_type":"c1","uid":1317640,"ip_address":"","ucode":"7DEA9ECAF4A75B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKWXs9ibD6uTSK6bFXbibNibMibUIMyKxUtl8KP9zDHgFyPa2w2icLxLKGOmibpuA2qqDMMkGABa0PJicUiaA/132","comment_is_top":false,"comment_ctime":1588851969,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588851969","product_id":100017301,"comment_content":"1. 数组： 线性表结构、连续内存空间、相同类型<br>2.  随机访问时间复杂度O(1)<br>3. 标记清除：标记阶段、清除阶段<br>4","like_count":0},{"had_liked":false,"id":214848,"user_name":"四爷来了","can_delete":false,"product_type":"c1","uid":1245318,"ip_address":"","ucode":"735988B0D65CE6","user_header":"https://static001.geekbang.org/account/avatar/00/13/00/86/fba78197.jpg","comment_is_top":false,"comment_ctime":1588832543,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588832543","product_id":100017301,"comment_content":"标记清除算法：主要分两个阶段：<br>1、标记阶段：分析GC Roots 和GC Roots有直接或者间接引用关系的 就将其标记为灰色（可用） 否则将其标记为 黑色（垃圾）<br>2、清除阶段：将被标记为黑色的标签清除。<br><br>优点：快速效率高<br>缺点：造成内存碎片","like_count":0},{"had_liked":false,"id":214325,"user_name":"无颜","can_delete":false,"product_type":"c1","uid":1422645,"ip_address":"","ucode":"7EE3CE8AB96D2A","user_header":"https://static001.geekbang.org/account/avatar/00/15/b5/35/c8b82745.jpg","comment_is_top":false,"comment_ctime":1588725032,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588725032","product_id":100017301,"comment_content":"标记清除垃圾回收算法：当jvm触发垃圾回收的时候，他们把是内存垃圾的空间标记出来，然后统一清除已经标记了是垃圾的内存，这样清理会出现一个问题，那就是会导致大量的内存碎片","like_count":0},{"had_liked":false,"id":213187,"user_name":"momo","can_delete":false,"product_type":"c1","uid":1875126,"ip_address":"","ucode":"E7DE4095DFEF5D","user_header":"https://static001.geekbang.org/account/avatar/00/1c/9c/b6/f6acc0a6.jpg","comment_is_top":false,"comment_ctime":1588325552,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588325552","product_id":100017301,"comment_content":"学习数据结构学习背后的思想，而不是死记硬背。","like_count":0},{"had_liked":false,"id":212866,"user_name":"寇展","can_delete":false,"product_type":"c1","uid":1986825,"ip_address":"","ucode":"34DD0DFAE7B9D1","user_header":"https://static001.geekbang.org/account/avatar/00/1e/51/09/97100013.jpg","comment_is_top":false,"comment_ctime":1588228817,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588228817","product_id":100017301,"comment_content":"无限循环的问题之前编程刚好遇到过，不论windows还是linux，不论x86还是x64，每次定义的全局变量相同类型连在一起才会出现这种情况，比如文中代码，在main函数外先定义arr，在定义i，程序就会无限输出helloworld。<br>","like_count":0},{"had_liked":false,"id":212842,"user_name":"刘聪为","can_delete":false,"product_type":"c1","uid":1139128,"ip_address":"","ucode":"8DFDCA7B37D04E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJh4fE4WryeIpjKCYB7TuWS2IEFV0paiaZt3hSh8jrPZRD8cvalPWndTv1VbdDiaEKibY0IgGGPEMbCw/132","comment_is_top":false,"comment_ctime":1588221698,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588221698","product_id":100017301,"comment_content":"老师，非int型的数组无法知道每个元素字节大小，怎么快速定位随机元素的呢？","like_count":0},{"had_liked":false,"id":212838,"user_name":"严丹","can_delete":false,"product_type":"c1","uid":1798204,"ip_address":"","ucode":"96FA634D06C3FD","user_header":"https://static001.geekbang.org/account/avatar/00/1b/70/3c/a002615b.jpg","comment_is_top":false,"comment_ctime":1588220442,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1588220442","product_id":100017301,"comment_content":"数组下标叫做偏移量，从0开始还是讲的通。一切的锅丢给历史原因，稳妥","like_count":0},{"had_liked":false,"id":212782,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1588210619,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588210619","product_id":100017301,"comment_content":"标记清除，也就是Mark-Sweep，CMS垃圾收集器的实现原理，会产生内存碎片，标记清除效率低，所以一般新生代采用复制算法，老年代使用标记清除或者标记整理算法。老年代使用CMS时因为产生内存碎片可能分配大对象连续空间不足导致MajorGC，所以一般就可以通过设置JVM参数进行FULLGC前的Compact。","like_count":0},{"had_liked":false,"id":212674,"user_name":"Geek_ac7784","can_delete":false,"product_type":"c1","uid":1981613,"ip_address":"","ucode":"62F0E5E6D6F4BA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/8Dj4ugujXwY24G8pcpgDFGiciarXetG3ItQ4M9mSQMLyRdRRXEXXJVfib48mGUQAu87QcvImwyJIVJlEFeEguV44w/132","comment_is_top":false,"comment_ctime":1588172714,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588172714","product_id":100017301,"comment_content":"数组支持下标访问，通过下标访问的时间复杂度为O(1) 。数组的插入删除比较耗时，但是如果不太关注数组的顺序，插入可以将要插入的位置的原数据放在数组最后。删除可以标记删除的位置，一段时间后再统一移动位置，这样更省时间(JVM垃圾回收机制)。所以数据结构是很灵活的事情，具体情况具体分析。一些语言已经对数组封装成了容器，不做底层操作时，可以用。二维数组比较大，写成容器形式并不好，所以还是用数组比较好(看情况，容器确实好操作的多) 。<br>JVM回收机制不了解，查找皮毛资料如下：<br>1. JVM是Java virtual machine Java虚拟机的简称 ，垃圾回收是GC<br>2. 算法有很多：标记清除算法、复制算法、标记压缩算法、分代管理算法<br>3. 标记清除算法只是标记了活，没有标记的地址都可用，不涉及对象移动，但是会产生内存碎片<br>   复制算法：内存分为两个区域from和to，一段时间将from中的活对象复制到to区，from对象清空<br>   标记压缩算法：这应该是本文中讲的算法，标记阶段，将活对象标记，压缩阶段，将活对象向数组一端移动<br>   分代管理算法：根据对象的生存周期，分为新生代、老年代和永久代，不同的代不同的管理策略<br>4. 判断对象存活的算法是可达性分析算法，不用引用计数法用的原因是无法解决相互引用问题<br>在C&#47;C++语言中，二维数组A[m][n]计算(a,b) 的地址，应该是*(A+a) +b 。但如果内存连续，则应为A+ axn + b。内存连续与否要看如何定义。如果直接定义为A[M][N] = {.....},则内存连续（网上查的），而如果为动态分配，连续不连续则要看你如何分配，决定权在你手中。","like_count":0},{"had_liked":false,"id":212430,"user_name":"guan0078","can_delete":false,"product_type":"c1","uid":1090467,"ip_address":"","ucode":"53B15FF3752A40","user_header":"https://static001.geekbang.org/account/avatar/00/10/a3/a3/804fb3e9.jpg","comment_is_top":false,"comment_ctime":1588122566,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588122566","product_id":100017301,"comment_content":"比较了下用ArrayList默认初始长度和，手动初始化，用封装类型初始化数组和用基本类型初始化数组的时间。还是有些意思的。<br>int size = 10000000;<br>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();<br>long startTime = System.currentTimeMillis();<br>for(int i=0; i&lt;size; i++) {<br>    list.add(i);<br>}<br>long endTime = System.currentTimeMillis();<br>System.out.print(&quot;默认初始长度用时：&quot;);<br>System.out.println(endTime - startTime);<br><br>List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;(size);<br>long startTime2 = System.currentTimeMillis();<br>for(int i=0; i&lt;size; i++) {<br>    list2.add(i);<br>}<br>long endTime2 = System.currentTimeMillis();<br>System.out.print(&quot;手动初始化用时：&quot;);<br>System.out.println(endTime2 - startTime2);<br><br><br>Integer[] arrList = new Integer[size];<br>long startTime3 = System.currentTimeMillis();<br>for(int i=0; i&lt;size; i++) {<br>    arrList[i] = i;<br>}<br>long endTime3 = System.currentTimeMillis();<br>System.out.print(&quot;数组封装类型用时：&quot;);<br>System.out.println(endTime3 - startTime3);<br><br>int[] arrList2 = new int[size];<br>long startTime4 = System.currentTimeMillis();<br>for(int i=0; i&lt;size; i++) {<br>    arrList[i] = i;<br>}<br>long endTime4 = System.currentTimeMillis();<br>System.out.print(&quot;基本类型用时：&quot;);<br>System.out.println(endTime4 - startTime4);<br>-----------------------------------------<br>默认初始长度用时：2061<br>手动初始化用时：355<br>数组封装类型用时：40<br>基本类型用时：230","like_count":0},{"had_liked":false,"id":212254,"user_name":"guan0078","can_delete":false,"product_type":"c1","uid":1090467,"ip_address":"","ucode":"53B15FF3752A40","user_header":"https://static001.geekbang.org/account/avatar/00/10/a3/a3/804fb3e9.jpg","comment_is_top":false,"comment_ctime":1588080159,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588080159","product_id":100017301,"comment_content":"标记清除算法：在内存中通过可达性分析，将所有可达对象做标记。完成标记后做垃圾对象的清理。但清除后会留下垃圾碎片。<br>标记整理算法：在内存中通过可达性分析，将所有可达对象做标记。完成标记后做垃圾对象的清理，然后将可达对象整理到一块连续空间。从而减少磁盘碎片。<br><br>a[i][j]二维数组的k字节的寻址方式：<br>a[p][q] = a[0][0]_address+(p*j+q)*k      其中p&lt;i,q&lt;j","like_count":0},{"had_liked":false,"id":211308,"user_name":"熊熊","can_delete":false,"product_type":"c1","uid":1104611,"ip_address":"","ucode":"D4E5B5C4FCF059","user_header":"https://static001.geekbang.org/account/avatar/00/10/da/e3/51295241.jpg","comment_is_top":false,"comment_ctime":1587947722,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587947722","product_id":100017301,"comment_content":"Java的自动封装和拆封是由编译器处理的，应该不存在性能问题，望指正","like_count":0},{"had_liked":false,"id":209930,"user_name":"弓林","can_delete":false,"product_type":"c1","uid":1652133,"ip_address":"","ucode":"CF04B083578D6B","user_header":"https://static001.geekbang.org/account/avatar/00/19/35/a5/72ef587a.jpg","comment_is_top":false,"comment_ctime":1587637215,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587637215","product_id":100017301,"comment_content":"1.标记清除垃圾回收算法。（java）<br>“标记-清除”算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。<br><br>标记清除算法的优点和缺点<br>1. 优点<br>- 是可以解决循环引用的问题<br>- 必要时才回收(内存不足时)<br>-<br>2. 缺点：<br>- 回收时，应用需要挂起，也就是stop the world。<br>- 标记和清除的效率不高，尤其是要扫描的对象比较多的时候<br>- 会造成内存碎片(会导致明明有内存空间,但是由于不连续,申请稍微大一些的对象无法做到)。<br><br>2.二维数组的内存寻址公式是怎样的呢？<br><br>对于 m * n 的数组，a [ i ][ j ] (i &lt; m,j &lt; n)的地址为：<br>address = base_address + ( i * n + j) * type_size.<br>备注（一维数组寻址公式：a[i]_address = base_address + i * data_type_size）<br>","like_count":0},{"had_liked":false,"id":208584,"user_name":"小童","can_delete":false,"product_type":"c1","uid":1763395,"ip_address":"","ucode":"300444B520E79D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/e8/43/f9c0faed.jpg","comment_is_top":false,"comment_ctime":1587387027,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1587387027","product_id":100017301,"comment_content":"javascript定位数组的时候 从没有给定大小，没听说过 js数组的越界问题。","like_count":0,"discussions":[{"author":{"id":1763395,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/e8/43/f9c0faed.jpg","nickname":"小童","note":"","ucode":"300444B520E79D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":245937,"discussion_content":"试了下，js不会越界，应该属于自动扩容的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587714032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208187,"user_name":"fomy","can_delete":false,"product_type":"c1","uid":1125834,"ip_address":"","ucode":"CD87EA03B1F327","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/ca/02b0e397.jpg","comment_is_top":false,"comment_ctime":1587295658,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587295658","product_id":100017301,"comment_content":"标记清除算法：根据可达性分析，标记出不再使用的内存区域。然后在垃圾回收时，清除该内存空间。<br><br>二维数组访问过程：先定位到x轴的位置，然后定位y轴位置。","like_count":0},{"had_liked":false,"id":207999,"user_name":"hahalaugh","can_delete":false,"product_type":"c1","uid":1970145,"ip_address":"","ucode":"3CAC2C5C2C83F1","user_header":"https://static001.geekbang.org/account/avatar/00/1e/0f/e1/8df88da9.jpg","comment_is_top":false,"comment_ctime":1587236233,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587236233","product_id":100017301,"comment_content":"关于数组的表述 - “来存储相同类型的一组数据”是否不太准确？Python数组并不强制数据类型。","like_count":0},{"had_liked":false,"id":207905,"user_name":"石头","can_delete":false,"product_type":"c1","uid":1142419,"ip_address":"","ucode":"DC24472A35EA40","user_header":"https://static001.geekbang.org/account/avatar/00/11/6e/93/6fef7aaa.jpg","comment_is_top":false,"comment_ctime":1587213043,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587213043","product_id":100017301,"comment_content":"1、JVM这块还不清楚，已经相关内容已经列入阅读计划清单了。<br>2、二维数组计算：a[m][n]中，a[i][j]=base_address+(i*n+j)*type_size。 (参考杰杰) 不过二维数组这块让我想到了散列表中的分离链接法，结构相似。<br><br>","like_count":0},{"had_liked":false,"id":207255,"user_name":"₯㎕","can_delete":false,"product_type":"c1","uid":1080182,"ip_address":"","ucode":"6E06492D0FBA54","user_header":"https://static001.geekbang.org/account/avatar/00/10/7b/76/69aada7c.jpg","comment_is_top":false,"comment_ctime":1587038150,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587038150","product_id":100017301,"comment_content":"数据从0开始，因为数组存储在一块连续的内存空间，访问一个元素，需要从开始位置偏移下标来进行访问，第一个位置是开始位置，所以访问第一个元素从0开始","like_count":0},{"had_liked":false,"id":207244,"user_name":"IsaacGao","can_delete":false,"product_type":"c1","uid":1057611,"ip_address":"","ucode":"95C640D185A060","user_header":"https://static001.geekbang.org/account/avatar/00/10/23/4b/5578cbd1.jpg","comment_is_top":false,"comment_ctime":1587033696,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587033696","product_id":100017301,"comment_content":"#### 低效的“插入”和“删除”<br>- 为何低效<br>\t- 因为数组的内存地址是连续的，所以进行数据插入或删除时，还需要进行数据移动<br>- 时间复杂度<br>\t- 最差 O(1)<br>\t- 最优O(n)<br>\t- 平均O(N)<br>- 如何解决<br>\t- 插入：如果对顺序没有要求，可以对待插入位置数据进行替换，将原有数据放到最后<br>\t- 删除：对待删除位置数据进行标记，待数组空间不足时进行批量删除（类似于标记-清除）<br>    <br>#### 数组的访问越界问题<br>- 在 C 语言中会导致不可预知的问题<br>- 在 Java 中会报数组越界异常<br><br>#### 容器能否完全替代数组<br>- 如果对性能没有极致的要求，可以替代<br>- 容器的优点<br>     - 提供了更高级的API<br>       - 例如数组的 删除&#47;插入 不需要手动移动数据<br>     - 可以自动扩容（如果容量确定，最好指定capacity）<br>- 容器的缺点<br>     - 不支持基本数据类型，有拆装箱的性能损耗。","like_count":0},{"had_liked":false,"id":207192,"user_name":"Geek_ca540c","can_delete":false,"product_type":"c1","uid":1903258,"ip_address":"","ucode":"DA56EE2C0CD480","user_header":"","comment_is_top":false,"comment_ctime":1587022085,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587022085","product_id":100017301,"comment_content":"感觉自己关于数组越界内容中给出的示例代码理解的不正确，我的理解如下，请老师帮忙检查一下对不对:<br>1. arr[i]=0; 这段代码是为了举这个例子特意加上去的，将其删除，程序还是能打印出3个 Hello world <br>2. a[3]=0,会将 i 的值，由i=3 变成 i=0，然后一个新的循环就开始了。","like_count":0},{"had_liked":false,"id":206946,"user_name":"雪山飞狐","can_delete":false,"product_type":"c1","uid":1475485,"ip_address":"","ucode":"66FBC2AB10B77F","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/9d/fe638260.jpg","comment_is_top":false,"comment_ctime":1586961225,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586961225","product_id":100017301,"comment_content":"1、没学过Java，暂时不清楚；<br>2、对于m*n的二位数组a，则二维数组a的内存寻址公式为a[i][j]=base_addr + (n * i + j) * type_size","like_count":0},{"had_liked":false,"id":206846,"user_name":"小阳","can_delete":false,"product_type":"c1","uid":1296135,"ip_address":"","ucode":"97A162992E6A81","user_header":"https://static001.geekbang.org/account/avatar/00/13/c7/07/5798c17e.jpg","comment_is_top":false,"comment_ctime":1586944508,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586944508","product_id":100017301,"comment_content":"jvm 标记清理算法：<br>       <br>      jvm的标记清理算法分为两个阶段，标记阶段和回收阶段。标记阶段，从根开始扫描（GC-root）, 标记出所有存活的对象。回收阶段，将未标记的对象进行统一的回收。回收后，会产生内存碎片，java大对象申请内存时，需要连续的内存空间。这时虽然可用内存满足需求，但由于碎片过多不连续，无法满足大对象的需求，仍然会触发gc<br><br>二维数组的寻址公式： <br>        二维数组从逻辑上是二维，但计算机只能从一维上分配连续的一整块内存给二维数组。理解起来就是n个一维数组的内存拼接在一起。因此，可得假设int[ ][ ] a = new int[ k ][ n ] <br>           a[ i ][ j ]_address = base_address + (i * n + j)*type_size","like_count":0},{"had_liked":false,"id":206791,"user_name":"o0oi1i","can_delete":false,"product_type":"c1","uid":1132312,"ip_address":"","ucode":"D1F6AD4AAEAFBE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/18/293cd24d.jpg","comment_is_top":false,"comment_ctime":1586935635,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586935635","product_id":100017301,"comment_content":"看留言真是涨见识啊！差的不是十万八千里而是无底洞啊！","like_count":0},{"had_liked":false,"id":206789,"user_name":"o0oi1i","can_delete":false,"product_type":"c1","uid":1132312,"ip_address":"","ucode":"D1F6AD4AAEAFBE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/18/293cd24d.jpg","comment_is_top":false,"comment_ctime":1586935014,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586935014","product_id":100017301,"comment_content":"1.不会java，不太清楚<br>2.对于 m * n 的数组，a [ i ][ j ] (i &lt; m,j &lt; n)的地址为：<br>  address = base_address + ( i * n + j) * type_size","like_count":0},{"had_liked":false,"id":206732,"user_name":"russellyue","can_delete":false,"product_type":"c1","uid":1541894,"ip_address":"","ucode":"0758ACF772F9C1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epIMwPE6FwsicZ6bjhu7ZpWLnoib8G76sA1XL8y5W8GxqfQEjBub6g57E60mzjWzrA6icMRw1QT5CpyA/132","comment_is_top":false,"comment_ctime":1586923024,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1586923024","product_id":100017301,"comment_content":"总结：数组的一个强大功能是支持随机访问，其原理是因为数组是一段在内存上的连续空间并且存储的数据是相同类型的（保证了数据类型的大小相同）。但也正因为这个特性，导致数组在插入和删除的时候，平均时间复杂度为O(n)。在插入和删除元素的时候，都有相应的优化方式。如果对于元素的顺序没有要求，那么插入和删除的时候，可以通过将插入位的数据copy到结尾或者将删除的数据用末尾数据替代的方式，将插入和删除的时间复杂度降为O(1)。此外，删除还可以通过标记删除的方式来优化，即执行删除操作时，并不真正删除数据，而是标记该位置，直到数组没有足够的空间时，再执行一次真正的删除操作。","like_count":0},{"had_liked":false,"id":206707,"user_name":"前端男孩","can_delete":false,"product_type":"c1","uid":1541708,"ip_address":"","ucode":"58668020D2D5BD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/hkBfzo6cRvbBmFZKPxlzRnKyria9gzID4WQ9mI1NdBBox5lRox7eMuhicXPB7eU1ecOa0lD9fhNTG3H6yJlII50A/132","comment_is_top":false,"comment_ctime":1586919117,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586919117","product_id":100017301,"comment_content":"标记清除垃圾回收算法：<br>根据wiki垃圾回收的解释，“先暂停整个程序的全部运行线程，让回收线程以单线程进行扫描标记，并进行直接清除回收，然后回收完成后，恢复运行线程。这样会产生大量的空闲空间碎片，和使大容量对象不容易获得连续的内存空间，而造成空间浪费。”<br>二维数组的内存寻址公式(个人理解)：a[i][j]_address = base_address + i * data_type_size + j * data_type_size","like_count":0},{"had_liked":false,"id":206687,"user_name":"yw","can_delete":false,"product_type":"c1","uid":1632195,"ip_address":"","ucode":"F937C47767822B","user_header":"https://static001.geekbang.org/account/avatar/00/18/e7/c3/f7066fd1.jpg","comment_is_top":false,"comment_ctime":1586917198,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586917198","product_id":100017301,"comment_content":"今天重新学习数组，特别是对于数组为什么依下标为0开始有了重新认识，主要是方便随机访问的寻址。其中思考题1，jvm的标记清除算法，在gc是，从根对象查找是否能够到达该对象，如果能够就标记为存活，否则就标记为清除，遍历完成后，完成垃圾回收，这种算法在遍历时候，jvm会stop all the world,因此用在max gc阶段，同时还会存在内存碎片的问题。现在jvm都是多种算法混合使用来完成垃圾回收，如标记整理，复制等；<br>第二个问题，二维数组a[m][n]的数组，a[i][j]=base+[(i*n)+j]*tpyedata","like_count":0},{"had_liked":false,"id":206659,"user_name":"Spencer","can_delete":false,"product_type":"c1","uid":1470125,"ip_address":"","ucode":"E043F0D3CDAF23","user_header":"https://static001.geekbang.org/account/avatar/00/16/6e/ad/37f84502.jpg","comment_is_top":false,"comment_ctime":1586914443,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586914443","product_id":100017301,"comment_content":"想到了一个问题，在容器类中是可以存放不同类型的数据的，是怎么做到随机访问的","like_count":0},{"had_liked":false,"id":206655,"user_name":"Spencer","can_delete":false,"product_type":"c1","uid":1470125,"ip_address":"","ucode":"E043F0D3CDAF23","user_header":"https://static001.geekbang.org/account/avatar/00/16/6e/ad/37f84502.jpg","comment_is_top":false,"comment_ctime":1586914250,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586914250","product_id":100017301,"comment_content":"有一个问题，当数组进行扩容时，回去申请内存后再将数组迁移过去，是不是相当于数组的地址变了。但在容器类中，新增元素后容器地址没变","like_count":0},{"had_liked":false,"id":206507,"user_name":"张雄","can_delete":false,"product_type":"c1","uid":1960845,"ip_address":"","ucode":"422F2786CA4374","user_header":"","comment_is_top":false,"comment_ctime":1586871970,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586871970","product_id":100017301,"comment_content":"看完了老师讲的，突然觉得我之前像没学习过数组一样","like_count":0},{"had_liked":false,"id":206212,"user_name":"Roy","can_delete":false,"product_type":"c1","uid":1930723,"ip_address":"","ucode":"909B8B605C317A","user_header":"https://static001.geekbang.org/account/avatar/00/1d/75/e3/ef489d57.jpg","comment_is_top":false,"comment_ctime":1586823898,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586823898","product_id":100017301,"comment_content":"又复习了一遍Linux内存布局","like_count":0},{"had_liked":false,"id":206025,"user_name":"默默","can_delete":false,"product_type":"c1","uid":1006635,"ip_address":"","ucode":"AF798B9D327F24","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/2b/8b771383.jpg","comment_is_top":false,"comment_ctime":1586775283,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586775283","product_id":100017301,"comment_content":"a[i]_address = base_address + (i*n+j)*type_size","like_count":0},{"had_liked":false,"id":205672,"user_name":"拉普达","can_delete":false,"product_type":"c1","uid":1930686,"ip_address":"","ucode":"0E524C0D99B2A0","user_header":"https://static001.geekbang.org/account/avatar/00/1d/75/be/6f3ab95e.jpg","comment_is_top":false,"comment_ctime":1586699647,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586699647","product_id":100017301,"comment_content":"如果是集合，直接在尾部插入就行了啊，不用搬移数据。只有删除时，需要把最后的数据搬到删除位置就行了。","like_count":0},{"had_liked":false,"id":205417,"user_name":"BugBean","can_delete":false,"product_type":"c1","uid":1834181,"ip_address":"","ucode":"B51232281AD9BC","user_header":"https://static001.geekbang.org/account/avatar/00/1b/fc/c5/ff8b770e.jpg","comment_is_top":false,"comment_ctime":1586613107,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586613107","product_id":100017301,"comment_content":"“如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 O(1)。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 O(n)。 因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 (1+2+…n)&#47;n=O(n)。”这里更准确的计算公式是(0+1+2+...+n)&#47;(n+1)，因为在长度为n的数组有n+1个插入的位置。不过这个无伤大雅，不需要纠结","like_count":0},{"had_liked":false,"id":205396,"user_name":"晓森","can_delete":false,"product_type":"c1","uid":1112603,"ip_address":"","ucode":"3D5EB11B9E0FD7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/1b/5d82d759.jpg","comment_is_top":false,"comment_ctime":1586607699,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586607699","product_id":100017301,"comment_content":"习题 2：<br>对于一个二维数组 a[m][n]<br>a[i][j]_address = base_address + (i*n+j)*type_size","like_count":0},{"had_liked":false,"id":204862,"user_name":"L-伟彪","can_delete":false,"product_type":"c1","uid":1930296,"ip_address":"","ucode":"9A21FD80FD7A93","user_header":"https://static001.geekbang.org/account/avatar/00/1d/74/38/93e4694a.jpg","comment_is_top":false,"comment_ctime":1586484026,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586484026","product_id":100017301,"comment_content":" 因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 (1+2+…n)&#47;n=O(n)。<br>有点纠结， (1+2+…n)&#47;n不是等于 （n+1）&#47;2  吗？","like_count":0},{"had_liked":false,"id":204673,"user_name":"秋风画扇","can_delete":false,"product_type":"c1","uid":1132356,"ip_address":"","ucode":"5BCBC1422C51EC","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/44/964aa665.jpg","comment_is_top":false,"comment_ctime":1586440278,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586440278","product_id":100017301,"comment_content":"数据的操作 和  JVM操作一样，都是作用于内存地址。<br><br>标记清理算法好比数据删除不移动元素，会留空洞；复制算法好比数组的整理，把有用的数据copy到一段连续地址上。","like_count":0},{"had_liked":false,"id":204671,"user_name":"秋风画扇","can_delete":false,"product_type":"c1","uid":1132356,"ip_address":"","ucode":"5BCBC1422C51EC","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/44/964aa665.jpg","comment_is_top":false,"comment_ctime":1586440130,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586440130","product_id":100017301,"comment_content":"数据的操作同JVM的对象分配与回收，都是对内存地址的操作。","like_count":0},{"had_liked":false,"id":204308,"user_name":"美美","can_delete":false,"product_type":"c1","uid":1148422,"ip_address":"","ucode":"44CC95C45AF345","user_header":"https://static001.geekbang.org/account/avatar/00/11/86/06/72b01bb7.jpg","comment_is_top":false,"comment_ctime":1586361902,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586361902","product_id":100017301,"comment_content":"二维数组寻址：base_addr+i*type_size+j*type_size","like_count":0},{"had_liked":false,"id":204304,"user_name":"美美","can_delete":false,"product_type":"c1","uid":1148422,"ip_address":"","ucode":"44CC95C45AF345","user_header":"https://static001.geekbang.org/account/avatar/00/11/86/06/72b01bb7.jpg","comment_is_top":false,"comment_ctime":1586361723,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586361723","product_id":100017301,"comment_content":"1.标记清除垃圾回收算法<br>没开发过Java，自我思考🤔<br>记下待删除元素内存片段，假设删除开始位置为0，结束地址为 2；从3开始所有元素赋值给下标-3的元素；但这样一来所有元素都需要移动一次，这个算法肯定没这么粗陋，具体的不是很清楚了。<br><br>","like_count":0},{"had_liked":false,"id":204003,"user_name":"yoummg","can_delete":false,"product_type":"c1","uid":1067856,"ip_address":"","ucode":"1B809CFDD7A508","user_header":"https://static001.geekbang.org/account/avatar/00/10/4b/50/fdecd51a.jpg","comment_is_top":false,"comment_ctime":1586317574,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586317574","product_id":100017301,"comment_content":"数组<br>优点：通过下标查询，效率快<br>缺点：删除，新增，效率慢<br><br>平时业务代码建议使用容器，基础类型确实有包装，解包的问题，影响效率。底层网络模块等使用数据，很中肯的建议。<br><br>课后习题：<br>1. 标记清除算法， 是老年代cms使用的算法，优点：标记清除快速，缺点：内存碎片。解决：标记清除，在一定程度上，进行整理。<br>2.a[i][j] m*n<br>address = base +( n *i +j)* type_size","like_count":0},{"had_liked":false,"id":203721,"user_name":"Hinimix","can_delete":false,"product_type":"c1","uid":1316937,"ip_address":"","ucode":"7994136C93BD89","user_header":"https://static001.geekbang.org/account/avatar/00/14/18/49/b1d864e5.jpg","comment_is_top":false,"comment_ctime":1586259127,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586259127","product_id":100017301,"comment_content":"(1+2+…n)&#47;n=O(n)是不是==(1+n-1 + 2+n-2 + 3+n-3 +n)&#47;n == n&#47;2 = O(n)啊","like_count":0},{"had_liked":false,"id":203255,"user_name":"🍀","can_delete":false,"product_type":"c1","uid":1905300,"ip_address":"","ucode":"E3930B6B5DDDED","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Wn1fiaKdereKzlnd2vM0gib5Aia6VIJC8t6gcacvVIWPicbRTX4NY24SrgmBlc0ibnIJuhm7Qzia6mNPBgsUicnoUfYXA/132","comment_is_top":false,"comment_ctime":1586161629,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586161629","product_id":100017301,"comment_content":"1.标记—清除算法：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。<br>缺点：（1）效率问题：标记和清除过程的效率都不高；<br>          （2）空间问题：标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，碎片过多会导致大对象无法分配到足够的连续内存，从而不得不提前触发GC，甚至Stop The World。<br>2.二维数组的寻址公式，对于m*n的二维数组，a[i][j]_address=base_address+(i*m+j)*type_size","like_count":0},{"had_liked":false,"id":203251,"user_name":"Geek_3ba85e","can_delete":false,"product_type":"c1","uid":1446784,"ip_address":"","ucode":"106586BF969A80","user_header":"","comment_is_top":false,"comment_ctime":1586160938,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586160938","product_id":100017301,"comment_content":"问题一：jvm标记清除算法<br>标记清除算法是JVM最基础的垃圾回收算法，算法分为标记和清除2个阶段。标记阶段的基础是可达性分析算法：通过一系列的&quot;GC Roots&quot;对象作为起点，从这些节点开始向下搜索走过的路径称为引用链，当一个对象到GCRoots没有任何引用链的存在，即这个对象不可达，所有不可达的对象会被判定为需要回收的对象。所有在可达性分析中不可达的对象不一定非死不可，算是处于缓刑阶段。这些对象会经过两次标记：（1）可达性分析之后判定不可达的对象被第一次标记！且有一次筛选，筛选条件是该对象是否有必要执行finalize()方法，如果该对象没有覆盖finalize()方法或finalize()方法已经被虚拟机调用过，虚拟机就判定没有必要执行finalize()方法，该对象暂时安全。(2)如果在第一次标记的筛选过程中对象被判定需要执行finalize(）方法，这个对象就会被加入F-Queue队列中等待Finalizer线程真正的回收，GC会对FQ队列中的对象进行第二次小范围标记，如果这个过程中对象重新建立了引用链，那么它就会被移除即将回收的组合，如果第二次标记还没有建立引用链，那它算是死定了。 第二步骤清除：就是将所有标记为等待回收的对象清除，回收内存碎片。    标记清除算法有2个不足：1)效率不高，标记过程和清除过程效率都不行 2)空间问题。标记清除之后会产生大量的内存碎片，导致以后如果有大的对象需要分配时，无法找到足够的连续内存空间从而提前触发一次垃圾回收。<br>问题二：二维数组寻址<br>数组元素在内存中按照行优先的顺序排列，每次换行的地方实际上内存地址也是连续的，这样就能理解了。比如A[5][3]数组，它作为一个5行3列的数组，a[0][2]和a[1][0]之间的偏移量一个是个数据类型长度单位，比如int就是4. 计算公式是：&amp;D[i][j] = base_address + L(C*i + j ); 其中L是数据类型长度，C是“定义的行长度”其实就是列数，因为对于行而言它的长度单位不就是列么。","like_count":0},{"had_liked":false,"id":202881,"user_name":"亢（知行合一的路上）","can_delete":false,"product_type":"c1","uid":1347013,"ip_address":"","ucode":"958AF7C96EB9E8","user_header":"https://static001.geekbang.org/account/avatar/00/14/8d/c5/898b13b4.jpg","comment_is_top":false,"comment_ctime":1586079134,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586079134","product_id":100017301,"comment_content":"Golang 中的 slice 是对数组封装的容器，支持动态扩容，平时基本用这个，如老师所说，尽量在创建时指定大小，减少内存申请和数据搬移的消耗。","like_count":0},{"had_liked":false,"id":201795,"user_name":"邵正强","can_delete":false,"product_type":"c1","uid":1127129,"ip_address":"","ucode":"76175BB2B87868","user_header":"https://static001.geekbang.org/account/avatar/00/11/32/d9/ac3edc48.jpg","comment_is_top":false,"comment_ctime":1585838240,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585838240","product_id":100017301,"comment_content":"死循环的问题刚才跑了一下代码发现:当arr[3]={0};的时候i&lt;=3就是死循环,但是当arr[5]={0}的时候i&lt;=5就没有死循环,通过地址打印 发现arr[7]的地址才和i的地址是一致的.<br>","like_count":0},{"had_liked":false,"id":201358,"user_name":"麦克斯韦妖","can_delete":false,"product_type":"c1","uid":1938385,"ip_address":"","ucode":"ADAE586302A104","user_header":"https://static001.geekbang.org/account/avatar/00/1d/93/d1/9eb38793.jpg","comment_is_top":false,"comment_ctime":1585755318,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585755318","product_id":100017301,"comment_content":"我因为只学了一点python，所以对数据结构的理解非常粗浅。尽管如此，还是发表一下自己的总结和理解<br>数组核心概念：<br>第一，是一种线性表结构<br>第二，连续的内存空间<br>第三，存放相同的数据类型<br>数组特性：<br>因为数组需要连续存放数据，所以便于查找，但不便于删除和插入。<br>顺序查找的时间复杂度是0(1)，删除和插入的时间复杂度是0(n)。<br>数组核心概念引申：<br>1.线性表结构：具有线性关系的表，包括数组链表，栈等，与之相对的是非线性表，比如树，图。<br>2.内存原理：计算机会给每个内存单元分配一个地址。计算机会根据这个地址访问内存中的数据。当计算机要访问数组中的元素时，就要根据寻址公式，计算该元素所在的地址。<br>3.寻址公式：a[i]_address = base_address + i * data_type_size<br>如何改善数组的劣势：<br>插入：<br>如果是无序数组，比如把某一个元素插到k的位置，原来是腾出k的位置，把k到n的每一个元素往后移一位，而现在只需要把k元素移到最后，把外来的元素插入k的位置就可以了。<br>删除：<br>原来是每次删除都要移位，现在是先记录要删除的数据，然后没有内存空间的时候，统一移位。类似spark里的惰性计算，一个rdd转另一个rdd的时候先不急着转，先记在心里，等需要转的时候再转，这个需要就是rdd的action。<br>警惕越界：<br>越界指的是以开始头指针指向的地址为基地址，向左向右移动头指针，使其指向数组的内存空间内的地址，从而可以访问数组中的元素。如果指针的移动超过了数组所在的内存空间的范围，就会造成越界。<br>数组小标为0的原因：<br>奥卡姆剃须刀原理，若非必要，删除联系。<br>下标代表偏移，基地址就是零偏移，k个数据对应的内存地址就是<br>a[k]_address = base_address + k* data_type_size。<br>如果从1开始，公式里面的k就要变成k-1了。<br>增加计算复杂度，没有这个必要。<br>","like_count":0},{"had_liked":false,"id":200458,"user_name":"何江涛","can_delete":false,"product_type":"c1","uid":1938247,"ip_address":"","ucode":"844470733623BF","user_header":"https://static001.geekbang.org/account/avatar/00/1d/93/47/ef2c3c4e.jpg","comment_is_top":false,"comment_ctime":1585587932,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585587932","product_id":100017301,"comment_content":"address = base_address + ( i * n + j) * type_size","like_count":0},{"had_liked":false,"id":200181,"user_name":"蜗牛","can_delete":false,"product_type":"c1","uid":1086220,"ip_address":"","ucode":"01CC18F12E556D","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/0c/0a6a0d5e.jpg","comment_is_top":false,"comment_ctime":1585553639,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585553639","product_id":100017301,"comment_content":"1. 标记-清除算法，主要分2大步，一个是标记，一个是清除。这个是老年代比较喜欢用的一个算法，他的好处就是速度比较快(标记-整理比)，劣势就是会造成垃圾碎片化。所以想CMS中就是利用标记-清除算法写的。然后针对配置，一定次数内做一次标记-整理。来处理垃圾碎片化的问题。<br>2. a[i][j]_address = base_address + (i*n+j) * type_size","like_count":0},{"had_liked":false,"id":200099,"user_name":"寒光","can_delete":false,"product_type":"c1","uid":1206187,"ip_address":"","ucode":"061BE413595F21","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/ab/fcf0cec4.jpg","comment_is_top":false,"comment_ctime":1585543600,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1585543600","product_id":100017301,"comment_content":"既然顺序不重要，不管插入下标为几，都往最后一个放，即a[x]=m等价于a[已插入元素个数]=m不是更好吗？还省去了移动一次😄","like_count":0,"discussions":[{"author":{"id":1156074,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a3/ea/53333dd5.jpg","nickname":"HoSalt","note":"","ucode":"610B03E2A002D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":234455,"discussion_content":"感觉好有道理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586964827,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":199570,"user_name":"Regis","can_delete":false,"product_type":"c1","uid":1435632,"ip_address":"","ucode":"3911E4EDE27F4E","user_header":"https://static001.geekbang.org/account/avatar/00/15/e7/f0/d0bf3a5f.jpg","comment_is_top":false,"comment_ctime":1585491692,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585491692","product_id":100017301,"comment_content":"打卡，主要也是刷一刷评论区","like_count":0},{"had_liked":false,"id":199551,"user_name":"王力国","can_delete":false,"product_type":"c1","uid":1310913,"ip_address":"","ucode":"3219C138948CAD","user_header":"https://static001.geekbang.org/account/avatar/00/14/00/c1/38eb4289.jpg","comment_is_top":false,"comment_ctime":1585491299,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585491299","product_id":100017301,"comment_content":"👍","like_count":0},{"had_liked":false,"id":198938,"user_name":"rexcai","can_delete":false,"product_type":"c1","uid":1595589,"ip_address":"","ucode":"E3AEB9A6D94EE8","user_header":"https://static001.geekbang.org/account/avatar/00/18/58/c5/433de59b.jpg","comment_is_top":false,"comment_ctime":1585473932,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585473932","product_id":100017301,"comment_content":"了解了数组的底层原理，连续的地址空间分配给数组，之所以下标为0开始访问数组，是因为寻址的特性；时间复杂度最好情况为ｏ1，最坏情况为on，平均情况为on；也知道数组其实在底层实现有很大的作用，但是业务上，还是使用容器类会更为方便","like_count":0},{"had_liked":false,"id":197635,"user_name":"lyh","can_delete":false,"product_type":"c1","uid":1247951,"ip_address":"","ucode":"A35C3AEE94C37E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ajNVdqHZLLBWjSjrBYr4DpMktO8XeRnpXeJFLWP0kpiaKFlsoeOoCN87PUDfbqicjPibuWIH4rdyoa0hE1iannzVKg/132","comment_is_top":false,"comment_ctime":1585388907,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585388907","product_id":100017301,"comment_content":"例子用死循环那个，根据变量分配到栈的尝试，结合X86计算中小端模式，首先栈是有高到底进行分配的，因此首先i是在高地址，然后在向下分配三个地址，从高到底依次为a[2], a[1], a[0],如果程序运行中指到了a[3],则正好就是i的地址，因此就会每次将i置为0。","like_count":0},{"had_liked":false,"id":197625,"user_name":"贵贵","can_delete":false,"product_type":"c1","uid":1196359,"ip_address":"","ucode":"97D5F277B5317D","user_header":"https://static001.geekbang.org/account/avatar/00/12/41/47/7e4bdd7b.jpg","comment_is_top":false,"comment_ctime":1585388567,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585388567","product_id":100017301,"comment_content":"重新学习了一下数组，容器，使用场景。同时阅读了arraylist的源码，了解扩容的过程。知道了使用两者的注意事项。然后阅读了jvm相关的垃圾回收内容。尽管日常开发并不会在意虚拟机的内存溢出问题，但是项目如果好的话，确实会碰到性能瓶颈。先在脑子中有一个垃圾回收的概念，解决问题的过程中，才有思路。","like_count":0},{"had_liked":false,"id":196703,"user_name":"牛牛","can_delete":false,"product_type":"c1","uid":1194626,"ip_address":"","ucode":"CFCE68B4F92209","user_header":"https://static001.geekbang.org/account/avatar/00/12/3a/82/1ff83a38.jpg","comment_is_top":false,"comment_ctime":1585304046,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585304046","product_id":100017301,"comment_content":"这遍认认真真的学习~~~、今天的学习笔记:<br><br>1. 如何实现随机访问 ?<br>数组是一种线性表数据结构、用一组连续的内存空间、来存储一组具有相同类型的数据.<br><br>1) 线性表: 一组数据排成线一样的结构. eg. 数组、链表、队列、桟<br>   非线性表: 二叉树、堆、图 等; 数据之间不是简单的前后关系<br>2) 连续的内存空间: 让数组具有高效的随机访问能力, 但为了维护这个能力、导致数据的增删操作的成本变大、需要大量的数据搬移工作.<br><br>2. 那数组是如何实现根据下标随机访问元素的呢 ?<br>假设长度为10的int类型数组、int[] a = new int[10], 分配了一段连续空间 1000~1039<br>计算机随机访问元素时、会通过 a[i]_address = base_address + i * data_type_size 来访问<br><br>3. 低效的插入和删除<br>1) 插入: 假设数组长度为n、需要将一个数据插入第k个位置、那么需要将 k~n 个元素顺序后移.<br>   最好时间复杂度O(1) - 尾部插入<br>   最坏时间复杂度O(n) - 头部插入<br>   平均时间复杂度O(n) = (1+2+3+..+n)&#47;n<br>   若数据不要求有序呢 ? 可以将第k个元素搬移到最后、在第k个位置插入即可, 复杂度为 O(1)<br>2) 删除: 若删除第k个位置的元素、也需要数据搬移<br>   与插入类似、最好时间复杂度 O(1), 最坏O(n), 平均O(n)<br>   若批量删除呢? 多次删除、一次搬移. eg. JVM的标记清除算法、其实核心就是多次标记、一次搬移<br>   <br>4. 注意点:<br>1) 数组越界 数组越界在C语言中是一种未决行为、未规定编译器如何处理, <br>           访问数组的本质就是访问一段连续内存、只要通过偏移计算得到的内存地址可访问、程序就不报错. Java会有越界检测. <br><br>5. 探讨:<br>容器能否代替数组 ?<br>1. 容器的最大优势是可以将很多数组操作细节封装、还可以动态扩容<br>2. 数组本身需要预先指定大小. <br>不过、若在创建ArrayList时、预先知道数据量大小、避免数据搬移、也会提高效率.<br>综合来说:<br>1) ArrayList无法存储基本类型、需要封装成 包装类、而Autoboxing, Unboxing则有一定的性能消耗、若特别关注性能、可以使用数组<br>2) 若预先已知大小、且对数据的操作很简单、用不到ArrayList的方法、也可以使用数组<br>3) 多维数组可能使用数组更直观~~~","like_count":0},{"had_liked":false,"id":196374,"user_name":"王加武","can_delete":false,"product_type":"c1","uid":1665471,"ip_address":"","ucode":"DDCFE578C6C428","user_header":"https://static001.geekbang.org/account/avatar/00/19/69/bf/50a824a4.jpg","comment_is_top":false,"comment_ctime":1585276717,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585276717","product_id":100017301,"comment_content":"JVM标记清除算法<br>堆中的每个对象都有一个引用计数，当对象被引用一次，计数加1，当被引用对象为null，则计数减1，直到计数为0，则对象就变为了无用对象，接下来就会被清除，优点是算法简单，缺点是“循环引用的无用对象”无法被识别<br><br>二维数组内存寻址<br>对于 n * m的数组<br>arr[i][j])(i &lt; n, j &lt; m)的地址为<br>address = base_address + (i * m + j) * type_size","like_count":0},{"had_liked":false,"id":195162,"user_name":"L","can_delete":false,"product_type":"c1","uid":1024473,"ip_address":"","ucode":"34F3A54FBF676B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a1/d9/cec95c47.jpg","comment_is_top":false,"comment_ctime":1585142678,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585142678","product_id":100017301,"comment_content":"标记清除垃圾回收算法，应该和C++的智能指针差不多，当指向该内存对象的引用计数为0时，就表示可以回收该内存。<br>二维数组a[m][n]为例，寻址公式应该是 a+sizeof(a[0])*m+sizeof(type)*n","like_count":0},{"had_liked":false,"id":194182,"user_name":"SteelHuaSheng","can_delete":false,"product_type":"c1","uid":1396126,"ip_address":"","ucode":"BC8127FC5207FC","user_header":"https://static001.geekbang.org/account/avatar/00/15/4d/9e/04ec08bf.jpg","comment_is_top":false,"comment_ctime":1585034859,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585034859","product_id":100017301,"comment_content":"数组最大的特点就是支持随机访问，<br>但插入、删除操作也因此变得比较低效，平均情况时间复杂度为 O(n)。","like_count":0},{"had_liked":false,"id":193892,"user_name":"会飞的大象","can_delete":false,"product_type":"c1","uid":1520299,"ip_address":"","ucode":"080A36D971E6CF","user_header":"https://static001.geekbang.org/account/avatar/00/17/32/ab/272af78e.jpg","comment_is_top":false,"comment_ctime":1584977790,"is_pvip":false,"discussion_count":0,"race_medal":2,"score":"1584977790","product_id":100017301,"comment_content":"在PHP中进行越界访问的时候，一般是会提示Notice: Undefined offset 0 ，原因是编译器在处理的时候对该类情况进行捕捉，然后抛出一个非致命错误，用于告知编程人员","like_count":0},{"had_liked":false,"id":192969,"user_name":"Geek_xhyan","can_delete":false,"product_type":"c1","uid":1762746,"ip_address":"","ucode":"30B4955EA57474","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epjKKBAP8qibhJR0Vc8SRWrEyNJy3QbRaicT3SDJs4HItiaWoDmxrwmBoiaNqTwgqcS3Jnk9HicVMzibkcg/132","comment_is_top":false,"comment_ctime":1584880730,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584880730","product_id":100017301,"comment_content":"二维数组j的长度为L<br>则二维数组的寻址公式为 a[k][j]_address = base_address + k * L* type_size + j * type_size","like_count":0},{"had_liked":false,"id":191816,"user_name":"獨自去遠方","can_delete":false,"product_type":"c1","uid":1503941,"ip_address":"","ucode":"E246B33F397441","user_header":"https://static001.geekbang.org/account/avatar/00/16/f2/c5/2a441c27.jpg","comment_is_top":false,"comment_ctime":1584798564,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584798564","product_id":100017301,"comment_content":"数组<br>\t数组为何要从0开始编号<br>\t\t数组的内存模型来看：下标的定义是偏移<br>\t\t\ta[k]_address = base_address + k * type_size<br><br><br><br>\t线性表<br>\t\t链表、队列、栈<br>\t\t非线性表<br>\t\t\t二叉树、堆、图<br>\t连续的内存空间、相同类型的数据（大小相同）<br>\t\t根据下标随机访问<br><br>\t数组根据下表访问的时候是O(1)<br><br><br>\t操作：<br>\t\t插入<br>\t\t\t时间复杂度O(n)<br><br>\t\t\t如果数组无序，可以将插入位置的元素放到数组末尾，将要插入的元素放到插入位置<br><br>\t\t删除<br>\t\t\t时间复杂度O(n)<br><br>\t\t\t标记删除的元素，然后统一删除，减少数据的搬移<br><br>\t警惕数组越界<br><br>\t容器能否完全替代数组\t<br>\t\t容器的优势<br>\t\t\t将数组的操作细节进行了封装<br>\t\t\t支持动态扩容<br>\t\t\t\t如果实现能够确定要储存的数据大小，最好创建时指定大小<br><br>\t\t使用数组的场景<br>\t\t\t1.容器无法存储基本类型，基本类型会存在Autoboxing,Unboxing 有性能消耗<br>\t\t\t2.数据大小已知，对数据操作简单<br>\t\t\t3.多维数组，数组更加直观","like_count":0},{"had_liked":false,"id":191480,"user_name":"ezekiel","can_delete":false,"product_type":"c1","uid":1158795,"ip_address":"","ucode":"AB4AB6FA8612D8","user_header":"https://static001.geekbang.org/account/avatar/00/11/ae/8b/43ce01ca.jpg","comment_is_top":false,"comment_ctime":1584777151,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584777151","product_id":100017301,"comment_content":"对文中示例的无限循环有疑问的同学，建议去查函数调用的栈桢结构细节（操作系统或计算机体系结构的教材应该会讲到）。<br><br>函数体内的局部变量存在栈上，且是连续压栈。在Linux进程的内存布局中，栈区在高地址空间，从高向低增长。变量i和arr在相邻地址，且i比arr的地址大，所以arr越界正好访问到i。当然，前提是i和arr元素同类型，否则那段代码仍是未决行为。<br><br>如果涉及到重排序，<br><br>int i = 0; <br>int arr[3] = {0};<br><br>谁前谁后，是否不一定？","like_count":0},{"had_liked":false,"id":191190,"user_name":"雨落千木的时节","can_delete":false,"product_type":"c1","uid":1796430,"ip_address":"","ucode":"A268063299F0D6","user_header":"https://static001.geekbang.org/account/avatar/00/1b/69/4e/7ef7604b.jpg","comment_is_top":false,"comment_ctime":1584753180,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584753180","product_id":100017301,"comment_content":"GC算法：引用计数，标记清除，标记覆盖，标记复制，分代算法","like_count":0},{"had_liked":false,"id":190865,"user_name":"勇敢的心","can_delete":false,"product_type":"c1","uid":1198639,"ip_address":"","ucode":"43678591F1A558","user_header":"https://static001.geekbang.org/account/avatar/00/12/4a/2f/42aa48d7.jpg","comment_is_top":false,"comment_ctime":1584700886,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584700886","product_id":100017301,"comment_content":"核心摘要：<br>1.不要混淆数组随机访问和查找的概念，随机访问时间复杂度O(1)，查找看具体算法，例如二分查找O(lgn)<br>2.数组插入、删除操作的平均时间复杂度O(n)，但是可以进行改良。for插入，将插入位置i上的元素移动到数组末尾再插入；for删除来说， 可以采用标记的方法，标记哪些已经删除，最后统一操作，减少移动。<br>3.对于容器类，如果能够提前预估数组大小，则给定，避免动态扩容带来的性能损耗<br>","like_count":0},{"had_liked":false,"id":190679,"user_name":"Java bb","can_delete":false,"product_type":"c1","uid":1107707,"ip_address":"","ucode":"61E18422881A44","user_header":"https://static001.geekbang.org/account/avatar/00/10/e6/fb/ce524fb0.jpg","comment_is_top":false,"comment_ctime":1584680991,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584680991","product_id":100017301,"comment_content":"Java的多维数组内存空间也是连续的吗","like_count":0},{"had_liked":false,"id":189643,"user_name":"周瑜","can_delete":false,"product_type":"c1","uid":1247161,"ip_address":"","ucode":"B2BB6FB792538A","user_header":"https://static001.geekbang.org/account/avatar/00/13/07/b9/a6092850.jpg","comment_is_top":false,"comment_ctime":1584537883,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584537883","product_id":100017301,"comment_content":"方便寻址计算。","like_count":0},{"had_liked":false,"id":189159,"user_name":"kaiser","can_delete":false,"product_type":"c1","uid":1390375,"ip_address":"","ucode":"F9438786E9A57B","user_header":"https://static001.geekbang.org/account/avatar/00/15/37/27/b023ada7.jpg","comment_is_top":false,"comment_ctime":1584461799,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584461799","product_id":100017301,"comment_content":"JVM 的标记清理算法是通过标记与清理两个阶段进行的，标记阶段将不用的数据标记为垃圾，然后当内存不足时，进入清理阶段再将标记的垃圾数据进行清理回收。<br><br>有两个不足之处，一是标记与清理的效率很低，二是清理完毕之后会产生内存碎片，当需要创建大对象时，由于没有连续的内存空间，就不得不再次进行垃圾回收，清理内存，来为大对象分配连续的内存空间。<br>它和文中提到的数组元素合并删除的思想一样，但是标记清除算法是不会进行内存整理，而标记整理算法是先标记垃圾数据在清理并且整理内存，对应数组的删除数据操后将n~k 个元素往前挪移的过程。","like_count":0},{"had_liked":false,"id":186979,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1217554,"ip_address":"","ucode":"C5A540BC5A60B9","user_header":"https://static001.geekbang.org/account/avatar/00/12/94/12/15558f28.jpg","comment_is_top":false,"comment_ctime":1583981784,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583981784","product_id":100017301,"comment_content":"二维数组的寻址是a[i][j]的地址是base_addr+i*n+j，二维数组可以看成被铺开的一维数组，第二行可以看成跟在第一行后面","like_count":0},{"had_liked":false,"id":186877,"user_name":"wholly","can_delete":false,"product_type":"c1","uid":1089235,"ip_address":"","ucode":"3CB7D06CC6C670","user_header":"https://static001.geekbang.org/account/avatar/00/10/9e/d3/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1583942532,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583942532","product_id":100017301,"comment_content":"标记法很巧妙，二维数组寻址：a[i][j]，*(a*i+j)","like_count":0},{"had_liked":false,"id":186844,"user_name":"Roc","can_delete":false,"product_type":"c1","uid":1802610,"ip_address":"","ucode":"0D71BD87E3DD54","user_header":"https://static001.geekbang.org/account/avatar/00/1b/81/72/e6dbf6f3.jpg","comment_is_top":false,"comment_ctime":1583937551,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583937551","product_id":100017301,"comment_content":"Array m*n, A[i][j]=base_address+i*m*type_size+j*type_size","like_count":0},{"had_liked":false,"id":186384,"user_name":"o0oi1i","can_delete":false,"product_type":"c1","uid":1132312,"ip_address":"","ucode":"D1F6AD4AAEAFBE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/18/293cd24d.jpg","comment_is_top":false,"comment_ctime":1583832781,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583832781","product_id":100017301,"comment_content":"打卡5","like_count":0},{"had_liked":false,"id":185695,"user_name":"Dybala不缺钙","can_delete":false,"product_type":"c1","uid":1805130,"ip_address":"","ucode":"F51EE2BA41C40B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/8b/4a/66a1cb50.jpg","comment_is_top":false,"comment_ctime":1583665499,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583665499","product_id":100017301,"comment_content":"数组轮训查找的时间复杂度是O(n)，排序好的数组使用二分法查找时间复杂度是O(logn)","like_count":0},{"had_liked":false,"id":184466,"user_name":"赤云","can_delete":false,"product_type":"c1","uid":1093258,"ip_address":"","ucode":"67476D582D8B6A","user_header":"https://static001.geekbang.org/account/avatar/00/10/ae/8a/e67def95.jpg","comment_is_top":false,"comment_ctime":1583322473,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583322473","product_id":100017301,"comment_content":"public static void main(String[] args) {<br>        long start = System.currentTimeMillis();<br><br>        int capacity = 100000000;<br><br>        ArrayList&lt;Object&gt; users = new ArrayList&lt;&gt;(capacity);<br>        for (int i = 0; i &lt; capacity; ++i) {<br>            users.add(new Object());<br>        }<br>        long end = System.currentTimeMillis();<br>        System.out.println(end - start);<br><br>        start = System.currentTimeMillis();<br><br>        users = new ArrayList&lt;&gt;();<br>        for (int i = 0; i &lt; capacity; ++i) {<br>            users.add(new Object());<br>        }<br>        end = System.currentTimeMillis();<br>        System.out.println(end - start);<br>    }<br>&#47;&#47; 测试结果指定容量：79s<br>&#47;&#47; 不指定 20s<br>老师，求解答","like_count":0},{"had_liked":false,"id":184386,"user_name":"谭方敏","can_delete":false,"product_type":"c1","uid":1710960,"ip_address":"","ucode":"728DC7ECB7C902","user_header":"https://static001.geekbang.org/account/avatar/00/1a/1b/70/547042ee.jpg","comment_is_top":false,"comment_ctime":1583304893,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583304893","product_id":100017301,"comment_content":"线性数据结构：数组，链表，栈，队列，<br>非线性数据结构：二叉树，图，堆。<br><br>java的内存回收机制是有听说的，不过具体并没有用过，不过找先记录标志，后做处理，这样能减少频繁处理带来的内存抖动，虽然是以牺牲部分空间为代价。<br><br>一维数组转二维数组，求地址的话，如果预言本身默认按照行式存储的话，那么就是如同各位同学给出答案写的一样<br>addr（a[i][j]，0&lt;i&lt;m, 0&lt;j&lt;n）=a[0][0] + (i*n + j)*data-type-size. ","like_count":0},{"had_liked":false,"id":183754,"user_name":"落","can_delete":false,"product_type":"c1","uid":1240710,"ip_address":"","ucode":"EA306D36D818BC","user_header":"https://static001.geekbang.org/account/avatar/00/12/ee/86/9f47c0dc.jpg","comment_is_top":false,"comment_ctime":1583127172,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583127172","product_id":100017301,"comment_content":"终结一下前排关系循环打印的答案：<br>1、内存按递减方式分配，变量i的地址刚好处于a[2]的后面。<br>2、为什么i和a的地址是连续的？因为内存按4字节(页)对齐，所以变量和数组变量刚好分配到一块连续的地址。<br>3、关闭堆栈保护，即可复现此现象<br>gcc -fno-stack-protector -z execstack array.c -o array<br><br>&#47;*array.c*&#47;<br>int main(int argc, char* argv[]) {<br>static int count = 0;<br>printf(&quot;count的地址%p\\n&quot;, &amp;count);<br>    int\ti = 0; <br>    int a[3] = {0};<br>    for (; i &lt;= 3 ; i++) {<br>\tprintf(&quot;变量i的地址%p，a[%d]的地址%p\\n&quot;, &amp;i, i, &amp;a[i]);<br>    \ta[i] = 0;<br>\tif(count==10){<br>break;<br>\t}<br>count++;<br>    }       <br>   return 0;<br>}<br>","like_count":0},{"had_liked":false,"id":183243,"user_name":"融梨","can_delete":false,"product_type":"c1","uid":1033405,"ip_address":"","ucode":"66D0A4054612C6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c4/bd/72180435.jpg","comment_is_top":false,"comment_ctime":1582981336,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582981336","product_id":100017301,"comment_content":"数组的数据结构适合解决什么问题？适合查找操作。","like_count":0},{"had_liked":false,"id":182128,"user_name":"caohuan","can_delete":false,"product_type":"c1","uid":1256428,"ip_address":"","ucode":"4B092E33F3DF1E","user_header":"https://static001.geekbang.org/account/avatar/00/13/2b/ec/af6d0b10.jpg","comment_is_top":false,"comment_ctime":1582714192,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582714192","product_id":100017301,"comment_content":"专栏中，发现 可以用数组的 优化方法做 添加（把需要位置的数据移到最后，然后把数据插入到里面）和删除（假删除）可以达到时间复杂度为O（1），而不是一般的O（n）。<br>java中虚拟机（JVM）的垃圾回收（GC）模式就是类似上面的假删除的方法，达到少操作内存的目标，不占用计算资源，提升性能。<br><br>数据结构二维数组的存储地址实际上线性存储在空间中的，按照王老师的一维数组下标地址的方程式，那么二位数组比如a[m][n]，a[i][j]的下标地址为j+i*n","like_count":0},{"had_liked":false,"id":181760,"user_name":"ayu","can_delete":false,"product_type":"c1","uid":1640515,"ip_address":"","ucode":"8DB850105E4379","user_header":"https://static001.geekbang.org/account/avatar/00/19/08/43/d2a8d8c8.jpg","comment_is_top":false,"comment_ctime":1582629367,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582629367","product_id":100017301,"comment_content":"**解决为何 c 语言中越界访问，循环打印 hello world：**<br><br>必要知识提要：栈在内存中地址向下增长，也即从高地址向底地址增长分配内存且数组在内存中是线性连续分配。<br><br>假设先定义的 i 分配在地址 0x1000-0x1003，定义的长度为 3，内容为 4 个字节的整型的数组 arr 分配在地址 0x1004-0x1015 中，其中 0x1012-0x1015 分配数组第一个元素，0x1008-0x1011 分配数组第二个元素，0x1004-0x1007 分配数组第三个元素。<br><br>当访问越界的 arr[3] 时，访问到的地址就是 0x1000-0x1003，也即变量 i 的地址，从而使得变量的 i 重新被赋值为 0","like_count":0},{"had_liked":false,"id":181743,"user_name":"峰","can_delete":false,"product_type":"c1","uid":1885002,"ip_address":"","ucode":"16C29CA22B71A2","user_header":"https://static001.geekbang.org/account/avatar/00/1c/c3/4a/e3f90437.jpg","comment_is_top":false,"comment_ctime":1582626483,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582626483","product_id":100017301,"comment_content":"真正的集中删除是指怎样的呢，没明白","like_count":0},{"had_liked":false,"id":181487,"user_name":"张宗伟","can_delete":false,"product_type":"c1","uid":1374181,"ip_address":"","ucode":"1447A20C7A8982","user_header":"https://static001.geekbang.org/account/avatar/00/14/f7/e5/ec543f3b.jpg","comment_is_top":false,"comment_ctime":1582550612,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582550612","product_id":100017301,"comment_content":"一、不了解java，但是我是前端，对于js来说，它的垃圾回收机制是，首先有两个规则：1. 大部分新生对象倾向于早死；2. 不死的对象，能活的更久；并且分为新生代和老生代，新生代使用的是scavenge算法，老生代使用的是Mark sweep 标记清除，会产生内存碎片，或者Mark compat 标记整理，没有内存碎片，但是时间比较长。在进行垃圾回收时，之前是全停顿，即不并行执行其他逻辑，很明显会出现阻塞其他任务；之后是增量标记&#47;延迟清理，即交替执行垃圾回收和其他任务。<br><br>2. 对于一个二维数组arr[m][n]，它的寻址公式为：arr[i][j] = base_address + (i*m+j)*data_type_size","like_count":0},{"had_liked":false,"id":181415,"user_name":"Eternal","can_delete":false,"product_type":"c1","uid":1188023,"ip_address":"","ucode":"EA6FE7CC98F740","user_header":"https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg","comment_is_top":false,"comment_ctime":1582536912,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582536912","product_id":100017301,"comment_content":"数组地址的寻址策略可以理解就是一个hash函数，通过下表hash算出真实地址","like_count":0},{"had_liked":false,"id":181402,"user_name":"Eternal","can_delete":false,"product_type":"c1","uid":1188023,"ip_address":"","ucode":"EA6FE7CC98F740","user_header":"https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg","comment_is_top":false,"comment_ctime":1582535695,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582535695","product_id":100017301,"comment_content":"文中比较了数组和容器，分了一维数组的地址分配策略，还类比了数组删除和JVM的垃圾回收，知识点的思考和举一反三很是佩服，这样学知识肯定能非常深刻和牢固，自勉","like_count":0},{"had_liked":false,"id":181394,"user_name":"Eternal","can_delete":false,"product_type":"c1","uid":1188023,"ip_address":"","ucode":"EA6FE7CC98F740","user_header":"https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg","comment_is_top":false,"comment_ctime":1582534555,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582534555","product_id":100017301,"comment_content":"<br>标记清除回收算法：主要思想是异步删除数据，首先将需要删除的数据标记，然后当内存资源不足的时候或者超过定义的回收阈值后触发删除操作<br>通过批量异步删除清除数据来减少清除数据本身消耗的资源，减少业务的暂停时间；<br>标记清除的时候可能完全暂停下来标记垃圾，也可以应用程序边运行边标记；<br><br><br>二维数组的地址定位其实和一维数组差不多：如果是一个4x4二维，a[k][m]_address = base_address +(4*k +m)*type_size","like_count":0},{"had_liked":false,"id":181271,"user_name":"华新","can_delete":false,"product_type":"c1","uid":1068724,"ip_address":"","ucode":"B6DB20898F5F99","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/b4/335e58d6.jpg","comment_is_top":false,"comment_ctime":1582529302,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582529302","product_id":100017301,"comment_content":"#### 概念<br>数据是一种线性表数据结构，用一组连续的内存空间，来存储一组具有相同类型的数据<br><br>#### 特点<br><br>* 线性<br>* 连续的内存空间和相同类型的数据<br>* 利：随机访问,时间复杂度O(1)<br>* 弊：插入、删除，时间复杂度O(n)<br>    <br>优化方案：<br>* 插入不排序<br>* 先标记后批量删除（Jvm垃圾回收）<br>备注:数组随机访问的时间复杂度为O(1),查找的时间复杂度不是，最小为折半查找O(logn)<br><br>#### 数组优于ArrayList场景<br>* 使用基本类型，不封装<br>* 数据大小事先已知且固定<br>* 多维数组<br><br>#### ArrayList特点<br>* 底层操作封装，无需过多干涉<br>* 扩容耗时，最好创建时事先指定数据大小。","like_count":0},{"had_liked":false,"id":181115,"user_name":"JustRunning","can_delete":false,"product_type":"c1","uid":1061157,"ip_address":"","ucode":"2F18DB26500AC4","user_header":"https://static001.geekbang.org/account/avatar/00/10/31/25/1a55bb52.jpg","comment_is_top":false,"comment_ctime":1582480004,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582480004","product_id":100017301,"comment_content":"问题一：<br>标记清除算法，核心标记、清除两阶段，先标记处需回收对象，最后再统一触发回收清除，减少频繁的GC阻塞。<br>问题二：<br>二维数组的寻址表达式：<br>object arr[][] = new object[n][m]<br>arr[i][j]_address = base_address+(i*n+j)*data_type_size","like_count":0},{"had_liked":false,"id":180297,"user_name":"Purson","can_delete":false,"product_type":"c1","uid":1446120,"ip_address":"","ucode":"5F0C1BB3C0C0A2","user_header":"https://static001.geekbang.org/account/avatar/00/16/10/e8/ec11e306.jpg","comment_is_top":false,"comment_ctime":1582252373,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582252373","product_id":100017301,"comment_content":"按列优先可以用公式 address = base_address + (i * n + j) * type_size<br>按行优先可以用公式 address = base_address + (i * m +j) * type_size<br><br>","like_count":0},{"had_liked":false,"id":180292,"user_name":"Purson","can_delete":false,"product_type":"c1","uid":1446120,"ip_address":"","ucode":"5F0C1BB3C0C0A2","user_header":"https://static001.geekbang.org/account/avatar/00/16/10/e8/ec11e306.jpg","comment_is_top":false,"comment_ctime":1582251641,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582251641","product_id":100017301,"comment_content":"JVM不太了解。","like_count":0},{"had_liked":false,"id":180123,"user_name":"晓","can_delete":false,"product_type":"c1","uid":1036354,"ip_address":"","ucode":"3C6E971C630DB2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d0/42/df3a3642.jpg","comment_is_top":false,"comment_ctime":1582192406,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582192406","product_id":100017301,"comment_content":"查找是对值而言的，因此查找前你并不知道数据在哪。访问是针对数组位置的，可以通过地址偏移直接找到","like_count":0},{"had_liked":false,"id":179952,"user_name":"JEX的小迷弟","can_delete":false,"product_type":"c1","uid":1398581,"ip_address":"","ucode":"48664D65C1EB3B","user_header":"https://static001.geekbang.org/account/avatar/00/15/57/35/a7f72c07.jpg","comment_is_top":false,"comment_ctime":1582126251,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582126251","product_id":100017301,"comment_content":"老师，你删除操作哪里的连续删除标记的例子，JVM垃圾核心思想那个。如果我想用数组自己来编码试一试，请问标记这个操作我该怎么弄？是将被标记的数组元素下标存储到另一个 mark 数组中吗？当我进行添加操作时，检查存储数组是否满了，如果满了就将mark 数组中的下标用来删除存储数组中的数据。我不知道有没有表达清楚，希望老师能解答一下","like_count":0},{"had_liked":false,"id":178944,"user_name":"烈鸟","can_delete":false,"product_type":"c1","uid":1160050,"ip_address":"","ucode":"F568728E862D50","user_header":"https://static001.geekbang.org/account/avatar/00/11/b3/72/8c6366aa.jpg","comment_is_top":false,"comment_ctime":1581861991,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581861991","product_id":100017301,"comment_content":"二维数组内存寻址公式：假设数组arr是m*n，那随机访问公式就是arr[i][j] = base_address + (i*n + j) * type_size","like_count":0},{"had_liked":false,"id":178855,"user_name":"拾迹","can_delete":false,"product_type":"c1","uid":1025093,"ip_address":"","ucode":"38F367B77FF2D7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a4/45/3cb5cdc6.jpg","comment_is_top":false,"comment_ctime":1581840977,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1581840977","product_id":100017301,"comment_content":"数组是用一组连续的内存空间，来存储一组具有相同类型数据的数据结构。使得数组天然就支持“随机访问”这个“杀手锏”的特点，其时间复杂度为 O(1)，但同时，这使得数组的插入和删除操作非常低效，其时间复杂度为 O(n)。在 js 中的 Array 和文中提到的 ArrayList 类似，其本质做了很多的封装和处理，有时间深究一下这里面的实现。","like_count":0},{"had_liked":false,"id":177658,"user_name":"小蛋糕","can_delete":false,"product_type":"c1","uid":1807662,"ip_address":"","ucode":"335A6F4301CF22","user_header":"https://static001.geekbang.org/account/avatar/00/1b/95/2e/f8575abb.jpg","comment_is_top":false,"comment_ctime":1581467002,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581467002","product_id":100017301,"comment_content":"我的理解是，二维数组的存储方式相当于把多个长度相同的一维数组连续在一起。<br><br>也就是说假如有二维数组 a[m][n]，就等于连续开辟了 m 个长度为 n 的数组。<br><br>base_address -&gt; [],[],[], ... [] 一共 m 个，每个长度为 n。<br><br>所以对于 a[i][k] 的寻址就应该是如下的计算方式：<br><br>a[i][k]_address = base_address + (i * n + k) * type_size<br><br>跳过前 i 个长度为 n 的数组，然后再偏移 k 位","like_count":0},{"had_liked":false,"id":177470,"user_name":"起而行","can_delete":false,"product_type":"c1","uid":1131399,"ip_address":"","ucode":"4F116B0B740776","user_header":"https://static001.geekbang.org/account/avatar/00/11/43/87/7604d7a4.jpg","comment_is_top":false,"comment_ctime":1581400362,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1581400362","product_id":100017301,"comment_content":"第一次了解JVM的垃圾回收机制，先标记再回首，有点像上节课提到的count,你认为是垃圾的地方，就可以覆盖存放数据。同样，你认为是垃圾的地方就可以标记出来，最后一起回收，然后一起整理内存空间使之连续<br>二维公式 num[m,n],i为行标，j为列标<br>addr=base+(i*n+j)*size","like_count":0},{"had_liked":false,"id":176647,"user_name":"王jojo","can_delete":false,"product_type":"c1","uid":1812840,"ip_address":"","ucode":"1ABE7FA2614F86","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/68/ec442a70.jpg","comment_is_top":false,"comment_ctime":1581128850,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581128850","product_id":100017301,"comment_content":"无序数据的数组的插入和删除的方法确实不错 学到了","like_count":0},{"had_liked":false,"id":176329,"user_name":"ascrutae","can_delete":false,"product_type":"c1","uid":1002623,"ip_address":"","ucode":"BD03202B601E2B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4c/7f/72ac100e.jpg","comment_is_top":false,"comment_ctime":1581036734,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581036734","product_id":100017301,"comment_content":"循环问题的本质就是你申请了一个长度为4的数组，i的值就是数组下标为3的值。这样一来，循环中第三个下标为3的值永远都被赋为0，循环就跳不出来了","like_count":0},{"had_liked":false,"id":176215,"user_name":"Andy","can_delete":false,"product_type":"c1","uid":1805708,"ip_address":"","ucode":"32061232765E6A","user_header":"https://static001.geekbang.org/account/avatar/00/1b/8d/8c/2d1065bf.jpg","comment_is_top":false,"comment_ctime":1580991489,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580991489","product_id":100017301,"comment_content":"老师您好我有个问题请您解答。ArrayList容器的自动扩容是将原来的空间扩展为1.5倍大小。还是在申请一个1.5倍大小的空间。那如果ArrayList容器是将原来的空间扩展为1.5倍大小，已经是在原来的基础上了那为什么扩容操作会涉及数据的搬移。","like_count":0},{"had_liked":false,"id":176131,"user_name":"linker","can_delete":false,"product_type":"c1","uid":1803259,"ip_address":"","ucode":"6C5799F2FC2C82","user_header":"https://static001.geekbang.org/account/avatar/00/1b/83/fb/621adceb.jpg","comment_is_top":false,"comment_ctime":1580966628,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580966628","product_id":100017301,"comment_content":"@王老师，有没有把各个数组结构的创建，插入，删除，查找实现都背会，还是自己实现一遍就行了?","like_count":0},{"had_liked":false,"id":175732,"user_name":"小伟","can_delete":false,"product_type":"c1","uid":1359701,"ip_address":"","ucode":"124953423491E2","user_header":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","comment_is_top":false,"comment_ctime":1580810014,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580810014","product_id":100017301,"comment_content":"思考题：<br>1. 总体来说，GC时JVM从堆栈中的局部变量或静态变量出发，递归标记所有可达对象，然后清理所有未被标记的对象。<br>2.二位数组寻址公式是： base_address + (i*j+k) * data_type_size，i是一维下标，j是二维长度，k是二维下标","like_count":0},{"had_liked":false,"id":175251,"user_name":"musing","can_delete":false,"product_type":"c1","uid":1238304,"ip_address":"","ucode":"B1D05DC71EAEFA","user_header":"https://static001.geekbang.org/account/avatar/00/12/e5/20/e71600b1.jpg","comment_is_top":false,"comment_ctime":1580631240,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580631240","product_id":100017301,"comment_content":"无限打印“hello world”的代码中，按理说将i = 0; 与int arr[3] = {0};调换顺序后就不会出现无限循环，然而还是会出现，但是在for之前获取i的地址后，即加入printf(&quot;%p\\n&quot;, &amp;i);后，却能够正常打印四次&quot;hello world&quot;，感觉有点玄学，不知道这是什么原因，老师能否告知一下","like_count":0},{"had_liked":false,"id":175238,"user_name":"一只独立特行的猪","can_delete":false,"product_type":"c1","uid":1473358,"ip_address":"","ucode":"52263607CCBE6F","user_header":"https://static001.geekbang.org/account/avatar/00/16/7b/4e/73a9deec.jpg","comment_is_top":false,"comment_ctime":1580626019,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580626019","product_id":100017301,"comment_content":"我比较菜，看到数组把一个数据插入到K位置的时候，老是想着直接覆盖k位置的不就可以了吗，为什么要移动K位置之后的数据。后来看了ArrayList的方法后，才知道这些操作在add方法里已经帮我我们做好了，完全不需要我们担心，这些移动的操作已经封装好了，大部分情况下，我们直接用ArrayList提供的方法即可。","like_count":0},{"had_liked":false,"id":174937,"user_name":"宪成小哥","can_delete":false,"product_type":"c1","uid":1526406,"ip_address":"","ucode":"7C1A4F25ACCB4A","user_header":"https://static001.geekbang.org/account/avatar/00/17/4a/86/3cd4144e.jpg","comment_is_top":false,"comment_ctime":1580465653,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580465653","product_id":100017301,"comment_content":"1、Jvm中的标记清除算法：标记的数据并不会立马被清除，而是当内存不够时才会触发数据清除操作，但是会形成内存碎片，而标记清除整理算法时在清除完数据后，将数据进行对齐<br>2、数字a[m][n]中，a[k][k]_address = base_address + k*n*type_size","like_count":0},{"had_liked":false,"id":174124,"user_name":"进击的小明","can_delete":false,"product_type":"c1","uid":1737846,"ip_address":"","ucode":"7C9A774C504177","user_header":"https://static001.geekbang.org/account/avatar/00/1a/84/76/6091523d.jpg","comment_is_top":false,"comment_ctime":1580011758,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1580011758","product_id":100017301,"comment_content":"今年过年不太平 静心学习一下 水平有限 请多指教<br><br>1.现学现卖 jvm标记算法 就是将不可达的内存区域先做标记，存入一个待适放的列表里 可以起名为free，然后等到内存不足时，发动gc清除这个列表。<br><br>2.如果变为二维数组a( i, j) 内存地址计算方法为: address=base_address + (i*base_address + j)<br><br>","like_count":0,"discussions":[{"author":{"id":1737846,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/84/76/6091523d.jpg","nickname":"进击的小明","note":"","ucode":"7C9A774C504177","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":153098,"discussion_content":"2.如果变为二维数组a( i, j) 内存地址计算方法为: address=base_address + (i*data_type+ j) 修正第二地点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580024903,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173059,"user_name":"睡着的海豚","can_delete":false,"product_type":"c1","uid":1338125,"ip_address":"","ucode":"E5F069F7C9E1BC","user_header":"https://static001.geekbang.org/account/avatar/00/14/6b/0d/74aeb985.jpg","comment_is_top":false,"comment_ctime":1579418995,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579418995","product_id":100017301,"comment_content":"示例中的无限循环的解释跟验证后的有差异呢？如果arr[3]恰好指向i的话，那么arr[3]的地址和i的地址应该一致才对，可是经过我写代码打印出地址以后发现不一致呢？<br>int i=0;<br>  printf(&quot;i====&gt;%p\\n&quot;,&amp;i);<br>  int a[3]={0};<br>  for(;i&lt;=3;i++)<br>  {<br>    a[i]=0;<br>    printf(&quot;a[%d]====&gt;%p\\n&quot;,i,&amp;a[i]);<br>    printf(&quot;hello world! \\n&quot;);<br>  }<br><br>i====&gt;0x7fffd447d50c<br>a[0]====&gt;0x7fffd447d510<br>hello world! <br>a[1]====&gt;0x7fffd447d514<br>hello world! <br>a[2]====&gt;0x7fffd447d518<br>hello world! <br>a[3]====&gt;0x7fffd447d51c<br>hello world! <br><br>i是50c而arr[3]是51c 这该如何解释？","like_count":0},{"had_liked":false,"id":172660,"user_name":"马志远","can_delete":false,"product_type":"c1","uid":1480892,"ip_address":"","ucode":"AAD8875343E5FC","user_header":"https://static001.geekbang.org/account/avatar/00/16/98/bc/6d5affd3.jpg","comment_is_top":false,"comment_ctime":1579247758,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579247758","product_id":100017301,"comment_content":"05 | 数组：为什么很多编程语言中数组都从0开始编号？<br>一.why-为什么使用数组这种数据结构<br>1.线性数据存储<br><br>二.what-数组的概念<br>1.数组:<br>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。<br>2.特点:<br>&lt;1&gt;<br>线性表（Linear List）。顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。(元素 两者存储关系 前后关系)<br>&lt;2&gt;<br>连续的内存空间和相同类型的数据<br>tips：<br>数组和链表的区别:<br>数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)。所以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)<br>数组是适合随机访问 不要和适合查找混淆<br>&lt;3&gt;缺点:<br>1.低效的“插入”和“删除”<br>不考虑顺序关系优化插入：如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数据插入到第 k 个位置，为了避免大规模的数据搬移，我们还有一个简单的办法就是，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。<br>不考虑顺序关系优化删除：为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移(JVM 标记清除垃圾回收算法)<br>2.警惕数组的访问越界问题<br><br>三.应用场景<br>1.Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。<br>2. 如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。<br>3. 当要表示多维数组时，用数组往往会更加直观。比如 Object[][] array；而用容器的话则需要这样定义：ArrayList&lt;ArrayList&lt;object&gt; &gt; array。","like_count":0},{"had_liked":false,"id":172600,"user_name":"AMIR","can_delete":false,"product_type":"c1","uid":1782777,"ip_address":"","ucode":"65142D9669071B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/33/f9/50b76abe.jpg","comment_is_top":false,"comment_ctime":1579231181,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579231181","product_id":100017301,"comment_content":"1.线性 2连续性 =&gt;随机访问 3.c数组越界不报错问题 4.数组下标从0开始问题","like_count":0},{"had_liked":false,"id":172531,"user_name":"Geek_212c40","can_delete":false,"product_type":"c1","uid":1746216,"ip_address":"","ucode":"93335D388232BA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/a5/28/9dd784ec.jpg","comment_is_top":false,"comment_ctime":1579220685,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579220685","product_id":100017301,"comment_content":"二维数组寻址公式 <br>a[k][j]_address = base_address + (k *j+j)* type_size","like_count":0},{"had_liked":false,"id":170736,"user_name":"Geek_f93234","can_delete":false,"product_type":"c1","uid":1769504,"ip_address":"","ucode":"1E5DC903A5429E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJGXndj5N66z9BL1ic9GibZzWWgoVeWaWTL2XUnCYic7iba2kAEvN9WfjmlXELD5lqt8IJ1P023N5ZWicg/132","comment_is_top":false,"comment_ctime":1578697667,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1578697667","product_id":100017301,"comment_content":"课后思考<br><br>1.我们基于数组原理引出JVM的标记清除垃圾回收算法的核心理念，我不知道你是否使用JAVA语言，理解JVM，如果你熟悉，可以在评论区回顾标记清除垃圾回收算法<br><br>JVM回收标记清除垃圾回收算法：<br><br>1.标记出所需要回收的对象<br><br>2.统一回收所有被标记的对象<br><br>缺点：<br><br>1.效率问题：标记，清除的过程效率都不高<br><br>2.空间问题：标记清除后，可能会造成大量不连续的内存碎片，碎片太多会导致大对象\t无法分配到足够的连续内存，不得不提前触发GC.<br><br>2.前面讲到一维数组的内存寻址公式，可以思考一下，二维数组的内存寻址公式是怎样的呢？<br><br>二维数组的寻址公式：<br><br>对于m*n的数组，a [i] [j] (i&lt;m,j&lt;n)地址公式：<br><br>a [i] [j]_address=base_address+ (i * n + j)*type_size<br>","like_count":0},{"had_liked":false,"id":170311,"user_name":"枯萎食客","can_delete":false,"product_type":"c1","uid":1131359,"ip_address":"","ucode":"5CDCDCAEE51DB0","user_header":"https://static001.geekbang.org/account/avatar/00/11/43/5f/6b4dc212.jpg","comment_is_top":false,"comment_ctime":1578565746,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578565746","product_id":100017301,"comment_content":"老师，js中数组存储的类型可以不一样","like_count":0},{"had_liked":false,"id":170168,"user_name":"扬子#Full Stack Developer","can_delete":false,"product_type":"c1","uid":1060490,"ip_address":"","ucode":"A1D77D054BF088","user_header":"https://static001.geekbang.org/account/avatar/00/10/2e/8a/ee82e8f6.jpg","comment_is_top":false,"comment_ctime":1578542021,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578542021","product_id":100017301,"comment_content":"m*n的二维数组内存寻址公式：<br>a[k][j]_address = base_address + (k*n + j)*type_size","like_count":0},{"had_liked":false,"id":170051,"user_name":"一粒","can_delete":false,"product_type":"c1","uid":1582813,"ip_address":"","ucode":"FB5F583CC6AE3C","user_header":"https://static001.geekbang.org/account/avatar/00/18/26/dd/d58156b1.jpg","comment_is_top":false,"comment_ctime":1578498146,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1578498146","product_id":100017301,"comment_content":"老师，数组的插入和删除操作如何执行的，不是已经在底层固定了么？你后面提到，在不追求数据连续性场景下的一些优化操作，只是一种思想吧，并不是说数组也可以这样做？","like_count":0},{"had_liked":false,"id":169713,"user_name":"板栗","can_delete":false,"product_type":"c1","uid":1239741,"ip_address":"","ucode":"35B8B2CB2E0214","user_header":"https://static001.geekbang.org/account/avatar/00/12/ea/bd/aba4b2c9.jpg","comment_is_top":false,"comment_ctime":1578410409,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578410409","product_id":100017301,"comment_content":"数组的下标从0开始：<br>  创建一个数组int[] a,计算机会在内存中创建一个地址连续空间用来保存数组,并记录内存块的首地址 bassAddress = ox01<br>  那么数组中任意值的位置 就是 a[i]Address = bassAddress+i*dataTypeSize(单个元素大小) 第0 个表示的就是 bassAddress<br>  从而查询每次的时间复杂度就是O(1),下标表示的是偏移地址<br>  &amp;历史原因 C语言是从0 开始的 ヾ(o◕∀◕)ﾉヾ<br><br>数组支持随机访问,根据下标的随机访问时间复杂度是O(1),如果是遍历查询,即时是已经排序的数组,用二分法差早的复杂度也是O(log n)<br>二维数组<br> 在不溢出的情况下 <br> a[i][j] = bassAddress + (i*n+j)*dataTypeSize<br> 考虑数组是引用变量的话<br> a[i][j] 应该 先查询出 a[i]Address = bassAddress_a[0]+i*dataTypeSize <br>         然后查询 a[i][j]Address =  bassAddress_a[i][0]+j**dataTypeSize","like_count":0},{"had_liked":false,"id":169187,"user_name":"Anthony","can_delete":false,"product_type":"c1","uid":1309908,"ip_address":"","ucode":"9E0C98A9123365","user_header":"https://static001.geekbang.org/account/avatar/00/13/fc/d4/743d3f02.jpg","comment_is_top":false,"comment_ctime":1578287939,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578287939","product_id":100017301,"comment_content":"对于一个大小为m,n的二维数组，a[i][j] = base_address + (i*n+j)*type_size","like_count":0},{"had_liked":false,"id":168338,"user_name":"杰瑞的Jerry","can_delete":false,"product_type":"c1","uid":1690017,"ip_address":"","ucode":"5FBF22B528B721","user_header":"https://static001.geekbang.org/account/avatar/00/19/c9/a1/24c2e54e.jpg","comment_is_top":false,"comment_ctime":1578049908,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1578049908","product_id":100017301,"comment_content":"学完本节打卡：<br><br>组（array）是一种线性表数据结构。要求：内存空间连续，存储数据类型相同。这两个要求使得数组具有了“随机访问”的特性。<br><br>线性表：线性表上的数据只有前和后两个方向，如：数组、链表、队列、栈等。<br>非线性表：如：树、堆、图等等。<br><br>数组的插入操作：平均时间复杂度为O(n)，如果不考虑数组的顺序，可以降为O(1)。<br>数据的删除操作：平均时间复杂度为O(n)。通常情况下，可以先记录下某些数据被删除，当数组空间不够时，再进行一次真正的删除操作。","like_count":0},{"had_liked":false,"id":168161,"user_name":"Attract","can_delete":false,"product_type":"c1","uid":1112638,"ip_address":"","ucode":"DEB10AF9AB5A41","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/3e/92d74b38.jpg","comment_is_top":false,"comment_ctime":1578022589,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578022589","product_id":100017301,"comment_content":"数组多项删除，采用标记法的话，也会影响读操作吧，如果读的时候取出来再跟标记了删除的对比筛选，则又增大了计算量（应该增加了O(n)<br><br>应该只是算法意义，实际中不这么做","like_count":0},{"had_liked":false,"id":167388,"user_name":"毛玉娇","can_delete":false,"product_type":"c1","uid":1249192,"ip_address":"","ucode":"BC0F0FEEEAD5DD","user_header":"https://static001.geekbang.org/account/avatar/00/13/0f/a8/5bec6811.jpg","comment_is_top":false,"comment_ctime":1577782263,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1577782263","product_id":100017301,"comment_content":"学到的思想：o(1)的插入思想，为减少数据移动的批量删除思想。深入理解了数组和容器的关系。之前就知道arraylist是通过数组来实现的，可没想到其实ArrayList其实就是封装数组的为简便操作而提供的api类。<br>数组和容器的性能上的差异。数组是一种底层的数据结构，而容器只是是数据类型，是对基本数据结构的封装类。","like_count":0,"discussions":[{"author":{"id":2264679,"avatar":"https://static001.geekbang.org/account/avatar/00/22/8e/67/afb412fb.jpg","nickname":"陈威洋","note":"","ucode":"DCF84B4D3A7354","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351059,"discussion_content":"又是你！~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614140486,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167156,"user_name":"liyghting","can_delete":false,"product_type":"c1","uid":1108970,"ip_address":"","ucode":"439794ECEEFD26","user_header":"https://static001.geekbang.org/account/avatar/00/10/eb/ea/7d00f657.jpg","comment_is_top":false,"comment_ctime":1577700816,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577700816","product_id":100017301,"comment_content":"本节总结：最基础的数据结构，数组，使用一块连续的内存空间，存储相同类型的一组数据。最大的特点是支持随机访问，基于下标的访问时间复杂度为O(1)，因此插入和删除变的比较低效，其平均时间复杂度为O(n)。<br>点题：为啥大多数编程语言数组下标从0开始？因为C语言是从0开始，其他高级语言参考，最大的原因是历史原因，还有一种解释，基于下标访问的时候寻址更加快。<br>一维数组a[n]第k个元素的寻址公式   a[k]_address =  base_address + k*data_type_size;<br>二维数组a[n][m]第i行第j个元素寻址公式    a[i][j]_address = base_address + (i * n + j) * data_type_size <br><br>jvm标记清除垃圾回收算法，顾名思义的解释，一块连续的内存存储了不同的java对象，如对象生命周期结束后，标记为可回收，等到新对象分配内存空间不足时，垃圾回收的一种算法。缺点是会造成内存碎片，不连续。可能明明内存空间足，但是分配不了一块连续的内存空间，会造成fullGC。<br>","like_count":0},{"had_liked":false,"id":167125,"user_name":"阿顾","can_delete":false,"product_type":"c1","uid":1605676,"ip_address":"","ucode":"6DFD19C57559EC","user_header":"","comment_is_top":false,"comment_ctime":1577696177,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577696177","product_id":100017301,"comment_content":"假如是m*n的数组，( i &lt; m , j &lt; n ) , a [i] [j]  的address = base_address + (n * i + j ) * type_size","like_count":0},{"had_liked":false,"id":167100,"user_name":"maybe","can_delete":false,"product_type":"c1","uid":1640973,"ip_address":"","ucode":"2C0D1D26853DB3","user_header":"https://static001.geekbang.org/account/avatar/00/19/0a/0d/7bac5bcb.jpg","comment_is_top":false,"comment_ctime":1577691476,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577691476","product_id":100017301,"comment_content":"如果数组的偏移量从0开始：a[i][j]_address = base_address*i + j*type_size<br>数组的偏移量从1开始：a[i][j]_address = base_address*i + （j-1）*type_size","like_count":0},{"had_liked":false,"id":167058,"user_name":"pikachu122","can_delete":false,"product_type":"c1","uid":1689365,"ip_address":"","ucode":"43FE4DBC872FFA","user_header":"https://static001.geekbang.org/account/avatar/00/19/c7/15/24bf166a.jpg","comment_is_top":false,"comment_ctime":1577679321,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577679321","product_id":100017301,"comment_content":"（1）由于目前还没有学习到JVM的相关知识，不太清楚。<br>（2）二维数组arr[x][y]就是一个具有x个元素的一维数组，但每个元素也是一个y个元素的一维数组。内存寻址公式要找下标为arr[a][b]，要先找到arr[a][0]的地址，再找arr[a][b]的地址。<br>arr[a][0]_add = arr[0][0]_add + a * (y * data_type_size)<br>arr[x][y]_add = arr[a][0]_add + b * data_type_size","like_count":0},{"had_liked":false,"id":166605,"user_name":"隰有荷","can_delete":false,"product_type":"c1","uid":1357944,"ip_address":"","ucode":"2BE9A32AB28963","user_header":"https://static001.geekbang.org/account/avatar/00/14/b8/78/2828195b.jpg","comment_is_top":false,"comment_ctime":1577517832,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577517832","product_id":100017301,"comment_content":"老师，既然数组的访问是根据下标进行访问，为什么称为随机访问呢？按照下标进行访问不是确定的吗，这个随机是我们一般理解的随机吗？","like_count":0},{"had_liked":false,"id":166222,"user_name":"知止而制","can_delete":false,"product_type":"c1","uid":1682967,"ip_address":"","ucode":"189B200D8E4C09","user_header":"https://static001.geekbang.org/account/avatar/00/19/ae/17/fb8d6a06.jpg","comment_is_top":false,"comment_ctime":1577418011,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577418011","product_id":100017301,"comment_content":"想了好一会无限循环问题，我的理解这样，假设i变量地址是1，那数组a三个变量地址的分别是：4，3，2，在访问第四个变量时就成了地址是1的位置，也就是变量i，对吧？","like_count":0},{"had_liked":false,"id":165060,"user_name":"lyt","can_delete":false,"product_type":"c1","uid":1526706,"ip_address":"","ucode":"8C179F339C2A27","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/OwolYO3ppfrxTcX81cswxNkD4tIlHM7vrnfroMzoTx878mDCnfJ3esicvbhm7ricUAbR7T9DjEDstVklh9z6uzjQ/132","comment_is_top":false,"comment_ctime":1577154175,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577154175","product_id":100017301,"comment_content":"老师您好，想请教一下，在这个数组越界的例中，提到a[3] 也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环，那为什么不会判断for循环中的条件，i＜＝3，当i再增加一条件就不满足了","like_count":0},{"had_liked":false,"id":164786,"user_name":"🌻向阳而生 🍀","can_delete":false,"product_type":"c1","uid":1788687,"ip_address":"","ucode":"D3170D48C24CA9","user_header":"https://static001.geekbang.org/account/avatar/00/1b/4b/0f/f2b59bea.jpg","comment_is_top":false,"comment_ctime":1577091722,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577091722","product_id":100017301,"comment_content":"数组下标代表偏移量这个解释好好","like_count":0},{"had_liked":false,"id":164363,"user_name":"别看我，学习呢","can_delete":false,"product_type":"c1","uid":1792573,"ip_address":"","ucode":"5485C64247766C","user_header":"https://static001.geekbang.org/account/avatar/00/1b/5a/3d/40871fb6.jpg","comment_is_top":false,"comment_ctime":1576945625,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576945625","product_id":100017301,"comment_content":"从逻辑上：数组一个线性表<br>从物理上：数组是一块连续的空间<br>而正是由于数组是一块连续的空间，所以数组访问可以通过计算得出a[i]=a[0]+i*类型大小，所以它可以通过下标访问到里面的每一个元素，可以有一些很有意思的算法，比如完全二叉树，他的子节点的下标等于当前下标两倍+1+2(2*N+1)<br>正是他是一块连续的空间，造成他的缺点，在保证有序性的前提下插入删除要有大量元素移动，一般而言平均时间复杂度为O(n)<br>同样的要记住，他随机访问时间复杂度为O(1),查找不是","like_count":0},{"had_liked":false,"id":164169,"user_name":"ChenJZ","can_delete":false,"product_type":"c1","uid":1123518,"ip_address":"","ucode":"50DF1CFB41C90D","user_header":"https://static001.geekbang.org/account/avatar/00/11/24/be/19c9d3e1.jpg","comment_is_top":false,"comment_ctime":1576899671,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576899671","product_id":100017301,"comment_content":"i s address:0x7ffcd539e818<br>arr address:0x7ffcd539e81c<br>arr[0] address:0x7ffcd539e81c<br>arr[1] address:0x7ffcd539e820<br>arr[2] address:0x7ffcd539e824<br>","like_count":0},{"had_liked":false,"id":164148,"user_name":"ChenJZ","can_delete":false,"product_type":"c1","uid":1123518,"ip_address":"","ucode":"50DF1CFB41C90D","user_header":"https://static001.geekbang.org/account/avatar/00/11/24/be/19c9d3e1.jpg","comment_is_top":false,"comment_ctime":1576895743,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576895743","product_id":100017301,"comment_content":"“在 C 语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。根据我们前面讲的数组寻址公式，a[3] 也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。”我觉得不对，上电脑上跑程序也不对啊？？","like_count":0},{"had_liked":false,"id":164007,"user_name":"耀","can_delete":false,"product_type":"c1","uid":1634462,"ip_address":"","ucode":"3692BEC242A399","user_header":"https://static001.geekbang.org/account/avatar/00/18/f0/9e/cf6570f7.jpg","comment_is_top":false,"comment_ctime":1576846491,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576846491","product_id":100017301,"comment_content":"#include&lt;stdio.h&gt;<br><br>int main(int argc, char* argv[]){<br>    int i = 0;<br>    int arr[3] = {0};<br>    for(; i&lt;=3; i++){<br>        arr[i] = 0;<br>        printf(&quot;hello world\\n&quot;);<br>    }<br>    return 0;<br>}<br>这段代码，我运行并不会死循环，为何？","like_count":0},{"had_liked":false,"id":163940,"user_name":"jackstraw","can_delete":false,"product_type":"c1","uid":1137207,"ip_address":"","ucode":"C967D2D6158F99","user_header":"https://static001.geekbang.org/account/avatar/00/11/5a/37/8775d714.jpg","comment_is_top":false,"comment_ctime":1576831765,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576831765","product_id":100017301,"comment_content":"1. 粗略的讲就是标记一定不再会使用的对象后，在适当时候统一删除；详细的讲还是看相关文章。","like_count":0},{"had_liked":false,"id":163675,"user_name":"俺能学个啥","can_delete":false,"product_type":"c1","uid":1026742,"ip_address":"","ucode":"30740C5B58774C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/aa/b6/46a5bbf3.jpg","comment_is_top":false,"comment_ctime":1576765537,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576765537","product_id":100017301,"comment_content":"标记清除算法，分为标记和清除两个阶段，标记阶段会遍历所有的GC roots，这些对象可以到达的对象都做一个标记为可达对象，那些不可达的对象，就会在清除阶段被GC处理掉。GC roots对象有虚拟机中引用的对象、方法区中类静态属性引用的对象、方法区中常量引用的对象以及JNI中引用的对象","like_count":0},{"had_liked":false,"id":162124,"user_name":"三叶草","can_delete":false,"product_type":"c1","uid":1179020,"ip_address":"","ucode":"3718E89ABA2066","user_header":"https://static001.geekbang.org/account/avatar/00/11/fd/8c/9c00e165.jpg","comment_is_top":false,"comment_ctime":1576463891,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576463891","product_id":100017301,"comment_content":"二维数组内存寻址：<br>对于 m * n 的数组，a [ i ][ j ] (i &lt; m,j &lt; n)的地址为：<br>a[i][i] = base_address +(i*n+j) ata_type_size。着实是想不明白(i*n)里面的n和m*n的关系。<br>假设a(3*3)的数组。如果求解a[2][2]的内存地址是这样：base_address +(2*3+3) data_type_size？","like_count":0},{"had_liked":false,"id":161970,"user_name":"skyclia","can_delete":false,"product_type":"c1","uid":1783695,"ip_address":"","ucode":"6A0AF20E31E184","user_header":"https://static001.geekbang.org/account/avatar/00/1b/37/8f/a9b3152f.jpg","comment_is_top":false,"comment_ctime":1576419193,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576419193","product_id":100017301,"comment_content":"为什么a[3]的地址是i的啊？不太清楚，求告知","like_count":0},{"had_liked":false,"id":161096,"user_name":"灰灰","can_delete":false,"product_type":"c1","uid":1122397,"ip_address":"","ucode":"907A2FD339E158","user_header":"https://static001.geekbang.org/account/avatar/00/11/20/5d/69170b96.jpg","comment_is_top":false,"comment_ctime":1576117896,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576117896","product_id":100017301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":160805,"user_name":"D0 N0W","can_delete":false,"product_type":"c1","uid":1602108,"ip_address":"","ucode":"F7A82748E15BAA","user_header":"https://static001.geekbang.org/account/avatar/00/18/72/3c/b5c70806.jpg","comment_is_top":false,"comment_ctime":1576034591,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576034591","product_id":100017301,"comment_content":" 假设每行有n个元素，则a[i][j]_address = base_address + (i * n + j) * type_size","like_count":0},{"had_liked":false,"id":160570,"user_name":"GitHubGanKai","can_delete":false,"product_type":"c1","uid":1477351,"ip_address":"","ucode":"BF6D6F8F3EED31","user_header":"https://static001.geekbang.org/account/avatar/00/16/8a/e7/a6c603cf.jpg","comment_is_top":false,"comment_ctime":1575976500,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575976500","product_id":100017301,"comment_content":"请教一个问题 在一个二叉树中 js代码：root === null  和 root.val === null 分别代表着什么意思？在网上有人说，root===null代表当前树不存在，那root.val===null代表什么呢？","like_count":0},{"had_liked":false,"id":160356,"user_name":"junshuaizhang","can_delete":false,"product_type":"c1","uid":1101502,"ip_address":"","ucode":"5734A9BEA03149","user_header":"https://static001.geekbang.org/account/avatar/00/10/ce/be/5cf3f1a0.jpg","comment_is_top":false,"comment_ctime":1575940712,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575940712","product_id":100017301,"comment_content":"mark","like_count":0},{"had_liked":false,"id":160118,"user_name":"小文","can_delete":false,"product_type":"c1","uid":1177540,"ip_address":"","ucode":"974071FAA5F173","user_header":"https://static001.geekbang.org/account/avatar/00/11/f7/c4/bd7dd30a.jpg","comment_is_top":false,"comment_ctime":1575874082,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575874082","product_id":100017301,"comment_content":"都是高手呀","like_count":0},{"had_liked":false,"id":159679,"user_name":"小童","can_delete":false,"product_type":"c1","uid":1763395,"ip_address":"","ucode":"300444B520E79D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/e8/43/f9c0faed.jpg","comment_is_top":false,"comment_ctime":1575726465,"is_pvip":false,"replies":[{"id":"61140","content":"弱类型语言中的数组，底层并不一定是用数据结构汇总的数组来实现，你可以看我写的这篇文章：<br>https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;E-c41h2v_AfffrlAQpkyLg","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1575897584,"ip_address":"","comment_id":159679,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1575726465","product_id":100017301,"comment_content":"寻址公式在弱类型语言也都一样吗？要是一样，我数组里面放不同类型的数据会怎么样？难道在内存中的地址就不连续了吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477142,"discussion_content":"弱类型语言中的数组，底层并不一定是用数据结构汇总的数组来实现，你可以看我写的这篇文章：\nhttps://mp.weixin.qq.com/s/E-c41h2v_AfffrlAQpkyLg","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575897584,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1763395,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/e8/43/f9c0faed.jpg","nickname":"小童","note":"","ucode":"300444B520E79D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":95382,"discussion_content":"我以为需要中的数组和数据结构中的数组一样的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577021762,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159667,"user_name":"小童","can_delete":false,"product_type":"c1","uid":1763395,"ip_address":"","ucode":"300444B520E79D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/e8/43/f9c0faed.jpg","comment_is_top":false,"comment_ctime":1575724158,"is_pvip":false,"replies":[{"id":"61141","content":"你可以看下我写的这篇文章：<br>https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;E-c41h2v_AfffrlAQpkyLg","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1575897602,"ip_address":"","comment_id":159667,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1575724158","product_id":100017301,"comment_content":"javascript的内存地址公式是什么? 因为它数组可以放任意类型，所以我很好奇，还有每种类型的datatypesize这个数据是哪里能查阅到？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477138,"discussion_content":"你可以看下我写的这篇文章：\nhttps://mp.weixin.qq.com/s/E-c41h2v_AfffrlAQpkyLg","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575897602,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1763395,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/e8/43/f9c0faed.jpg","nickname":"小童","note":"","ucode":"300444B520E79D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":89558,"discussion_content":"好的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576757716,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159663,"user_name":"HoshinoKanade","can_delete":false,"product_type":"c1","uid":1770245,"ip_address":"","ucode":"AA8B4F90FB9E5F","user_header":"https://static001.geekbang.org/account/avatar/00/1b/03/05/140068f9.jpg","comment_is_top":false,"comment_ctime":1575723247,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575723247","product_id":100017301,"comment_content":"我完全不懂C 還是嘗試解一下死循環例子<br>假設基地址1000<br>int i = 0; &#47;&#47; push i = 0 到地址1000<br>int arr[3] = {0}; &#47;&#47; push arr[2] = 0到1004, arr[1] = 0 到1008, push arr[0] = 0到1012<br>當迴圈執行到 i = 4<br>這裡闖禍了, 因為arr[3]會被resolve成為1000地址, 也就是i 的所在<br>後面的大家都清楚了... i 重新被賦值為0<br>程序就不能自拔了<br><br>比起&quot;C可以自由訪問任何一塊內存&quot; 我更偏向理解為&quot;一塊內存可以在C裡面有多於一個定義&quot;<br>嘗試舉一例:<br>00 00 03 E8 (BE)<br>你可以把4byte解成一個DWORD = 1000d<br>透過訪問方法的不同 可以看成例如2個WORD:<br>WORD 00 00 = 0d 以及 WORD 03 E8 = 1000d<br>甚至向右偏移一個byte再開始讀一個WORD, 那就是00 03 = 3d<br>要把這片內存怎麼樣去看完全是個人決定的, 編譯器沒有固定的intention或者說喜好去看待這內存<br>完全不會因為你是聲明成int就必須任何時候把這4 byte一起去看待<br>內存本身沒有型別 形態是你說是的就是 你說的不是就不是唄<br><br>請多加指正","like_count":0},{"had_liked":false,"id":159156,"user_name":"Tyh","can_delete":false,"product_type":"c1","uid":1688428,"ip_address":"","ucode":"E253C4E89FFC80","user_header":"https://static001.geekbang.org/account/avatar/00/19/c3/6c/47ad5ead.jpg","comment_is_top":false,"comment_ctime":1575549286,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575549286","product_id":100017301,"comment_content":"老师你好，有个地方让我有点困惑，删除数组中的元素的时候，先标记，等没有更多储存空间的时候再删除。这里的没有更多储存空间是指什么没有存储空间？","like_count":0},{"had_liked":false,"id":157738,"user_name":"Ew!","can_delete":false,"product_type":"c1","uid":1333332,"ip_address":"","ucode":"BC76E93DAFB873","user_header":"https://static001.geekbang.org/account/avatar/00/14/58/54/7ff93358.jpg","comment_is_top":false,"comment_ctime":1575252825,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575252825","product_id":100017301,"comment_content":"数组删除那块儿我不太明白，   arr[10]（a,b,c,d,e,f)<br> 我要删除a,b,d我需要将c,d的位置调换，变成（a,b,d,c,e,f)。<br>自己做标记，只有arr（3）及以后的数据才能获取而且有效？如果数据插入超过了10个数就替换a，b，d并扩容？","like_count":0},{"had_liked":false,"id":157377,"user_name":"永光","can_delete":false,"product_type":"c1","uid":1102702,"ip_address":"","ucode":"0C54531ABED1B0","user_header":"https://static001.geekbang.org/account/avatar/00/10/d3/6e/281b85aa.jpg","comment_is_top":false,"comment_ctime":1575125257,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575125257","product_id":100017301,"comment_content":"1、从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。（最主要的原因可能是历史原因）<br>2、每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。如果你了解 JVM，你会发现，这不就是 JVM 标记清除垃圾回收算法的核心思想吗？","like_count":0},{"had_liked":false,"id":157316,"user_name":"俗人or诗","can_delete":false,"product_type":"c1","uid":1357122,"ip_address":"","ucode":"C23CCA8B5BE8A8","user_header":"https://static001.geekbang.org/account/avatar/00/14/b5/42/21ed2f7b.jpg","comment_is_top":false,"comment_ctime":1575106957,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575106957","product_id":100017301,"comment_content":"1、产生背景<br>    基础的数据结构。<br>2、数据结构特性<br>     1.保存数据类型一致；2.线性表；3.连续的内存空间；4.支持随机访问，且时间复杂度为O(1);5.有序下的插入和删除的平均时间复杂度为O（n）；6.插入和删除可以采用其它方案优化，例如标记清楚，累积删除达到一定阀值后进行操作。<br>3、应用场景<br>在业务场景可以应用编程语言封装好的数据结构，但在底层的开发，利用数组更为合适。","like_count":0},{"had_liked":false,"id":157127,"user_name":"捕风捉影","can_delete":false,"product_type":"c1","uid":1713935,"ip_address":"","ucode":"E7F75B2521C8CF","user_header":"https://static001.geekbang.org/account/avatar/00/1a/27/0f/4af4daff.jpg","comment_is_top":false,"comment_ctime":1575037761,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575037761","product_id":100017301,"comment_content":"day03<br>1.数组来历，自身特点，适用场景，实际应用场景分别是？<br>1.1 数组来历：线性表，一组连续的内存空存储相同类型的数据，一条线，只有前后两个方向，还包括链表，栈，队列；当然还有非线性表，多个方向，二叉树，堆，图。<br><br>1.2 自身特点：随机访问数组中的元素，实现随机访问的前提，连续的内存地址和相同的数据类型，但是他也同样导致了插入和删除的复杂度提升，为了保证内存地址连续，插入和删除需要挪动数据使内存地址连续。<br>插入时如果数据无序，插入直接赋值到对应位置上，将原先的值加到最后。<br>删除时我们可以先记录删除的数据，就像引用计数一样，计数为0删除，数组是空间不足时统一删除，节省每次删除挪动数据花费的时间。<br><br>1.3 适用场景：便于查找数据，在用下标随机访问时复杂度为O（1），大批量的同类型数据，需要快速提取时<br><br>1.4 实际应用场景：<br>没头绪，似乎很多存数据都用得到，但又说不上上来。<br>2.数组下标越界：<br>c语言是继续访问连续地址的下一个，因为c语言除了受限的内存地址外，其他都可以自由访问。所以有可能无限循环，或者引发别的错误。<br>不同的语言不同的机制，python是直接诱发错误。<br><br>3.为什么下标都是从0开始？<br>从0开始可以内存访问公式可以减少计算量。<br>另很多都沿用了C语言的模式，降低编程语言的学习难度，它最开始用0开始的。<br><br>疑惑点<br>1.能够实现随机访问的前提是连续的内存和相同的数据类型吗？ 那么python的list类型能够根据下标随机访问，那么他的内存是连续的吗？ 它允许用不同的数据类型，甚至多个基本类型共存，字典，列表，元组，是将每个元素的大小分别计数，然后经过内存再加上去访问吗？但是如果不是相同数据类型，内存大小不同，又怎么做到根据这个内存地址加下标访问呢？numpy可以根据下标访问，这个倒是同样的数据类型<br>2.数组和链表的差别，为什么说链表更有利于插入和删除？下节课弄明白。<br>3.实际应用场景为什么说不上来呢？<br>4.jvm清除垃圾回收算法的原理以及python引用计数之间的区别？<br>5.二维数组内存寻址公式，对于m*n的数组，address=baseline+(i*n+j)*type_size ,i乘以n代表着什么？","like_count":0},{"had_liked":false,"id":157013,"user_name":"清风明月","can_delete":false,"product_type":"c1","uid":1086309,"ip_address":"","ucode":"37E01E81F9A353","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/65/6016b046.jpg","comment_is_top":false,"comment_ctime":1575013151,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1575013151","product_id":100017301,"comment_content":"今天学习了数组。关键字：线性的，连续空间，相同类型的数据。<br>优点在于用下标随机查找的效率是O(1),<br>缺点是插入和删除效率低，因为要保证位置的联系<br>但是插入和删除分别都有优化的地方。<br>插入：如果数据不联系，可以将新数据直接插入到要求位置，原本的该位置数据放置到最后。<br>删除：可以先标记删除，最后一次物理删（业务中会用到这种思想，感受到了算法思想的魅力）<br>容器和数组：容器封装了一些操作，适合业务开发；数组更高效，适合底层开发<br>为什么要从0开始编号，因为随机二地址的公式是 base+i*data_size，如果不是0开始，公式是base+(i-1)*data_size，对了一次减法操作，对于基础结构来说，不高效。<br>关于数组越界问题：<br>局部变量在栈上，从高到底压栈，那arr[0]是0000，arr[1]是0004，arr[2]是0008,i是0012，所以当越界给arr[3](0012)赋值时，其实就是给i赋值<br>看评论说是小端模式才会，已经忘记为什么了","like_count":0},{"had_liked":false,"id":156817,"user_name":"技术修行者","can_delete":false,"product_type":"c1","uid":1013147,"ip_address":"","ucode":"28CA41A1214D6B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/9b/611e74ab.jpg","comment_is_top":false,"comment_ctime":1574980110,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1574980110","product_id":100017301,"comment_content":"思维导图：https:&#47;&#47;mubu.com&#47;doc&#47;m_gL7-tt-0<br><br>关于思考题，基本上和大家留言的思路是一致的。<br><br>这个专栏的留言是我目前看到的质量最高的，专栏和留言一起看，收获更大！","like_count":0},{"had_liked":false,"id":156805,"user_name":"莫问流年","can_delete":false,"product_type":"c1","uid":1249663,"ip_address":"","ucode":"23140E031AED4B","user_header":"https://static001.geekbang.org/account/avatar/00/13/11/7f/80d56c1c.jpg","comment_is_top":false,"comment_ctime":1574961077,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574961077","product_id":100017301,"comment_content":"1.标记清除算法<br>JVM 从GC Root 开始对对象进行可达分析，并将可达对象标记为存活状态。标记完成后，才开始清理工作。这么做的效率不高，而且会产生内存碎片。<br><br>2.二维数组寻址公式<br>a[i][j]_address = base_address + (i * n + j) * type_size<br><br>3.数组越界问题的原因<br>栈空间的变量地址分配是从高到低的，因此栈中元素为i,a[2],a[1],a[0]的顺序，a[3]赋值实际上是在给i赋值。这样便出现了循环无法退出的现象。","like_count":0},{"had_liked":false,"id":156781,"user_name":"Lee Chen","can_delete":false,"product_type":"c1","uid":1220486,"ip_address":"","ucode":"F04F73B6AD656C","user_header":"https://static001.geekbang.org/account/avatar/00/12/9f/86/624fd145.jpg","comment_is_top":false,"comment_ctime":1574954372,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574954372","product_id":100017301,"comment_content":"从本节课对数组的操作，体会到功夫都体现在细节中啊。<br>另外，留言也让我大开眼界，很赞。","like_count":0},{"had_liked":false,"id":156751,"user_name":"nica_ho","can_delete":false,"product_type":"c1","uid":1060304,"ip_address":"","ucode":"34B01FC7F4D710","user_header":"https://static001.geekbang.org/account/avatar/00/10/2d/d0/9b4157ee.jpg","comment_is_top":false,"comment_ctime":1574947484,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574947484","product_id":100017301,"comment_content":"说到数组，想起之前用OC实现几百万次的循环时，用的是NSMutableArray。但耗时非常多，最后用了C数组来优化，最后速度快了不只一丢丢。我想NSMutableArray（NSArray）就是容器的概念吧","like_count":0},{"had_liked":false,"id":156683,"user_name":"骑行的掌柜J","can_delete":false,"product_type":"c1","uid":1474214,"ip_address":"","ucode":"3163102651C653","user_header":"https://static001.geekbang.org/account/avatar/00/16/7e/a6/4e331ef4.jpg","comment_is_top":false,"comment_ctime":1574935404,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574935404","product_id":100017301,"comment_content":"翻了大半截大家的评论 发现很少用python来解释“数组访问越界”的情况  <br>所以我用python试着改写了一下王争老师的那段C语言代码：<br>import array<br><br>arr = array.array(&#39;i&#39;, []) #初始化定义一个数组<br>print(arr)<br>arr[3] = 0<br>#循环添加i到数组，并打印出每次arr的值、数组的当前内存地址和长度以及“Hello World”<br>for i in range(3):<br>    arr.append(i)<br>    i = i + 1<br>    print(arr)<br>    print(&#39;\\n获取用于存放数组内容的缓冲区元素的当前内存地址和长度，以元组形式（地址，长度）返回：&#39;)<br>    #注意： 当在 C 或 C++ 编写的代码中使用数组对象时（这是有效使用此类信息的唯一方式），使用数组对象所支持的缓冲区接口更为适宜。<br>    print(arr.buffer_info())<br>    print(&#39;Hello World&#39;)<br>else:<br>    print(&#39;0&#39;)<br><br>结果python成功的抛出异常报错：<br>IndexError: array assignment index out of range  <br>我想这就是python里面对 数组访问越界 的检查吧 <br>然后只需要删除刚刚那行代码（arr[3]=0）即可正常运行程序<br>import array<br><br>arr = array.array(&#39;i&#39;, []) #初始化定义一个数组<br>print(arr)<br><br>#循环添加i到数组，并打印出每次arr的值和“Hello World”<br>for i in range(3):<br>    arr.append(i)<br>    i = i + 1<br>    print(arr)<br>    print(&#39;\\n获取用于存放数组内容的缓冲区元素的当前内存地址和长度，以元组形式（地址，长度）返回：&#39;)<br>    #注意： 当在 C 或 C++ 编写的代码中使用数组对象时（这是有效使用此类信息的唯一方式），使用数组对象所支持的缓冲区接口更为适宜。 此方法仅保留用作向下兼容，应避免在新代码中使用。 缓冲区接口的文档参见 缓冲协议。<br>    print(arr.buffer_info())<br>    print(&#39;Hello World&#39;)<br>else:<br>    print(&#39;0&#39;)<br><br>PS：当然python里面还存在多维数组的情况，可以详见Numpy官方文档里面的数组部分；<br>list （列表）我之前打卡的时候说错了，它其实就是python里面常见的四种内置容器类型之一。更多内容更可以参考python的官方文档（https:&#47;&#47;docs.python.org&#47;zh-cn&#47;）。<br>以上个人见解，仅供参考<br>","like_count":0},{"had_liked":false,"id":156554,"user_name":"无始","can_delete":false,"product_type":"c1","uid":1758577,"ip_address":"","ucode":"B96982583496B1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d5/71/308fe8a4.jpg","comment_is_top":false,"comment_ctime":1574911113,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574911113","product_id":100017301,"comment_content":"我基础比较差，开始看了不明白，后面看了大佬们的各种留言，又自己查了一下，总结了一下不知道对不对。<br>|-----|<br>|  i=0   |          1012-1015<br>|  0      | 下标2 1008-1011<br>|  0      | 下标1 1004-1007<br>|  0      | 下标0 1000-1003<br>|          | <br><br>同理二维数组，压栈后也是线性结构，m*n数组，那么array[m-1][n-1]是在最高位，array[0][0]应该就是起始地址<br>后来我想看一下java中数组是否也是这样的，查了一下数组是引用类型，jvm中方法的变量都存储在局部变量表的slot中，而真实的内存地址是指向存在堆中地址可能连续，也可能不连续，无法做参考","like_count":0},{"had_liked":false,"id":156546,"user_name":"灏","can_delete":false,"product_type":"c1","uid":1294967,"ip_address":"","ucode":"FCDEA52E06FBAD","user_header":"https://static001.geekbang.org/account/avatar/00/13/c2/77/a874625e.jpg","comment_is_top":false,"comment_ctime":1574909105,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574909105","product_id":100017301,"comment_content":"随机访问","like_count":0},{"had_liked":false,"id":156544,"user_name":"Tiger","can_delete":false,"product_type":"c1","uid":1284857,"ip_address":"","ucode":"6F9CAB3C29BAD7","user_header":"https://static001.geekbang.org/account/avatar/00/13/9a/f9/6d55ee0b.jpg","comment_is_top":false,"comment_ctime":1574908602,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574908602","product_id":100017301,"comment_content":"有个疑问，请教一下老师，数组是在内存里申请连续的内存空间。如果你要申请内存连续空间不够你申请的数组大小了，咋办啊？","like_count":0},{"had_liked":false,"id":156493,"user_name":"Linuxer","can_delete":false,"product_type":"c1","uid":1153978,"ip_address":"","ucode":"272D9D8089C3D6","user_header":"https://static001.geekbang.org/account/avatar/00/11/9b/ba/333b59e5.jpg","comment_is_top":false,"comment_ctime":1574902696,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574902696","product_id":100017301,"comment_content":"2题 <br>a[i][j]_address = base_address + (i*n+j)*type_size  n是列数","like_count":0},{"had_liked":false,"id":156427,"user_name":"sulatwx","can_delete":false,"product_type":"c1","uid":1348141,"ip_address":"","ucode":"366237F13DE8A7","user_header":"","comment_is_top":false,"comment_ctime":1574869861,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574869861","product_id":100017301,"comment_content":"二维数组寻址：<br>a[i][j]的地址：base+i×type_size×二维的长度+j×type_size","like_count":0},{"had_liked":false,"id":156408,"user_name":"Geek_JOJO","can_delete":false,"product_type":"c1","uid":1754326,"ip_address":"","ucode":"945C38ECF443B4","user_header":"https://static001.geekbang.org/account/avatar/00/1a/c4/d6/73656a64.jpg","comment_is_top":false,"comment_ctime":1574867512,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574867512","product_id":100017301,"comment_content":"我们继续来看例子。数组 a[10] 中存储了 8 个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除 a，b，c 三个元素。这个例子没看明白？到底哪个操作是真正的删除操作呀？有点懵","like_count":0},{"had_liked":false,"id":156401,"user_name":"流云","can_delete":false,"product_type":"c1","uid":1563806,"ip_address":"","ucode":"3F5B9C54178C65","user_header":"https://static001.geekbang.org/account/avatar/00/17/dc/9e/91860711.jpg","comment_is_top":false,"comment_ctime":1574866950,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574866950","product_id":100017301,"comment_content":"标记清除算法分为两步，标记阶段和清除阶段。标记阶段采用可达性分析算法对对象进行标记，在对象的头部标记该对象为可达或者不可达，在清除阶段，收集器会遍历所有的对象，将标记为不可达的对象进行清除。整个过程中程序停止，不可使用，为stop-the-world。<br>优点：<br>  1.实现简单<br>  2.不移动对象，与保守式GC算法兼容。在保守式GC算法中对象是不能移动的。<br>缺点：<br>    1.回收时需要先停止虚拟机的工作<br>    2.标记清除要遍历整个堆，效率低<br>    3.清除后会产生大量碎片区域，无法为大对象分配连续的内存<br>","like_count":0},{"had_liked":false,"id":156394,"user_name":"追逐繁星的孩纸~","can_delete":false,"product_type":"c1","uid":1593884,"ip_address":"","ucode":"69DC37A9E39C7E","user_header":"https://static001.geekbang.org/account/avatar/00/18/52/1c/e902de0f.jpg","comment_is_top":false,"comment_ctime":1574866318,"is_pvip":true,"discussion_count":0,"race_medal":4,"score":"1574866318","product_id":100017301,"comment_content":"思考题<br>1.我印象中的标记清除法，标记的是有效的引用，也就是从root开始遍历可达的引用，其他的没标记的就清除掉<br>2.每维长度为N，则a[i][j]_address = base_address + (i*N+j) * data_type_size<br>","like_count":0},{"had_liked":false,"id":156389,"user_name":"黄鑫荣","can_delete":false,"product_type":"c1","uid":1256331,"ip_address":"","ucode":"80B72CC68F7E06","user_header":"https://static001.geekbang.org/account/avatar/00/13/2b/8b/ea70179f.jpg","comment_is_top":false,"comment_ctime":1574865764,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574865764","product_id":100017301,"comment_content":"1.数组是如何实现随机访问的：由于数组的特性，连续的内存空间和相同类型的数据，所以我们可以通过a[i]_address = base_address + i * data_type_size来实现随机访问；<br>2.低效的“插入”和“删除”：数组为了保持内存数据的连续性，在“插入”和“删除”之后，需要有额外的数据搬移操作；<br>3.数组的访问越界问题：访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误；<br>4.容器能否完全代替数组：a.Java ArrayList 无法存储基本类型；b.如果数据大小已知，使用数组更高效。<br>","like_count":0},{"had_liked":false,"id":156348,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1574860224,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1574860224","product_id":100017301,"comment_content":"这一篇其实完美的解答了为什么数组下表从零开始计数这个问题，原因在于数组下标表明了数组重元素相对于数组首地址的偏移位置。当然，历史原因也很重要。<br><br>另一个有价值的句子就在于，“数组支持随机访问，根据下标随机访问的时间复杂度为O(1)”，而不是简单的“数组适合查找，查找时间复杂度为 O(1)”<br><br>对于那段无限打印 hello world 的代码，略有疑惑的地方在于，数组访问越界之后，a[3] = 0 恰好覆盖了存储变量 i 的内存地址。这个似乎和 C 语言的内存分配有关系，我对这一部分并不是特别的熟悉。<br><br>我估计 Java 程序员一般都会倾向于使用 ArrayList 而不是数组，作者也说，“对于业务开发，直接使用容器就足够了”。<br><br>对 JVM 并不熟悉，但是在印象中应该是会标记那些可能已经没有用了的对象的地址，然后在触发阈值，需要进行垃圾回收的时候，通过一定算法，对那些标记过的地址进行排序清除。其中是否为了有更大的空闲内存地址，而进行数据的迁移，我并不是特别清楚。<br><br>二维数组寻址公式我不小心写错了，问题恰恰出在了对于数组下标从零开始计数的理解上，我在计算的时候都多减了 1 ，估计这样可以记得更深。","like_count":0},{"had_liked":false,"id":156330,"user_name":"毛启圣","can_delete":false,"product_type":"c1","uid":1330056,"ip_address":"","ucode":"233DA95ED28C11","user_header":"https://static001.geekbang.org/account/avatar/00/14/4b/88/272b4562.jpg","comment_is_top":false,"comment_ctime":1574857467,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574857467","product_id":100017301,"comment_content":"遍历图，在数组上进行标记，最后清除数组中标记的数据","like_count":0},{"had_liked":false,"id":156328,"user_name":"毛启圣","can_delete":false,"product_type":"c1","uid":1330056,"ip_address":"","ucode":"233DA95ED28C11","user_header":"https://static001.geekbang.org/account/avatar/00/14/4b/88/272b4562.jpg","comment_is_top":false,"comment_ctime":1574857323,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574857323","product_id":100017301,"comment_content":"遍历图","like_count":0},{"had_liked":false,"id":156286,"user_name":"Geek rick","can_delete":false,"product_type":"c1","uid":1754279,"ip_address":"","ucode":"1A9216B2A47E92","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/QlHaicGZOD7c68A6gHC5dGuukQ4VJtVpGCeHHc8ANvHxQ8K9GibVwLHQVURQeWGed8yOWcMqKDnibaSd7S6Y4WKSQ/132","comment_is_top":false,"comment_ctime":1574849654,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574849654","product_id":100017301,"comment_content":"使用gcc编译数组越界的代码的时候, 发现只循环了4次, 看了评论区才发现这个涉及到入栈的操作顺序以及gcc的一些默认参数, 受益匪浅, 果然高手在于细节.","like_count":0},{"had_liked":false,"id":156278,"user_name":"big智慧","can_delete":false,"product_type":"c1","uid":1202616,"ip_address":"","ucode":"272C32E19EAE1A","user_header":"https://static001.geekbang.org/account/avatar/00/12/59/b8/2a4624c3.jpg","comment_is_top":false,"comment_ctime":1574847782,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574847782","product_id":100017301,"comment_content":"打卡Day3：<br>1、日期：<br>* 2019年11月27日<br><br>2、是什么：<br>* 数组是一种线性表数据结构。用一组连续的存储空间来存相同类型的数据。 <br><br>3、为什么：<br>* 数组可以高效的存储相同类型的数据，而且支持随机访问，通过下标随机访问时复杂度为O(1) <br>* 数组支持存储基本类型数据，在强关注效率的场景是优先选择 <br>* 数组的内存大小事先确定，可以在编码早起就做好内存规划  <br>4、怎么做：<br>* 声明数组的大小和存储数据的类型，并初始化<br>* 可以按需通过下标随机访问 <br>* 插入和删除时如需保持原有序列则需要搬运数据复杂度O(n)，如不要求顺序，则可以做到复杂度O(1) <br><br>5、与项目管理怎么结合：<br>* 项目计划的好处，在一个时间段内安排了任务项，可以快速的通过日期找到当天要做什么任务；但是一旦插入任务，如果任务是额外且必须做的就会“越过原计划的界”产生延期，如果任务可替换某个代做任务项且时间一样则计划。 <br>* 敏捷思想与数组类型更项，在同需求标准、固定的人力、短周期内推进，可以有“复杂度近似O(1)”的任务处理效率 <br><br>6、对应项目管理的关键点：<br>* 固定周期（时间盒）、相同类型（用户故事） ","like_count":0},{"had_liked":false,"id":156267,"user_name":"Ethan","can_delete":false,"product_type":"c1","uid":1246139,"ip_address":"","ucode":"ED197A378EE91B","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/bb/c5f139cc.jpg","comment_is_top":false,"comment_ctime":1574846056,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574846056","product_id":100017301,"comment_content":"day03 - 温习数组<br><br>1.什么是数组？<br>\t数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。<br><br>2.数组如何实现随机访问？<br>\t因为数组分配的是一组连续的内存空间，且存的数据类型相同，所以可以通过数组的起始地址和下标计算出指定下标元素的地址，从而实现随机访问。<br>\t<br>3.数组的增删操作如何优化？<br>\t3.1 添加元素的时候，如果不是添加到数组末尾，可以先将指定下标的元素放到数组末尾，再将添加元素放到指定下标，减少数组移动<br>\t3.2 删除元素的时候，如果空间还足够，删除操作可以标记删除元素，并不需要立刻移动元素，到内存不够了再统一移动，减少数组移动<br>\t<br>4.使用数组需要注意的问题。<br>\t需要警惕下标越界，C 语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的，下标越界可能会访问到其他不属于数组的地址上。<br>\t<br>5.为什么数组下标从0开始？<br>\t5.1 从公式的角度<br>\t从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。<br>\t如果用 a 来表示数组的首地址，a[0] 就是偏移为 0 的位置，也就是首地址，a[k] 就表示偏移 k 个 type_size 的位置，<br>\t所以计算 a[k] 的内存地址只需要用这个公式：a[i]_address = base_address + i * data_type_size，<br>\t如果i从1开始，公式需要变成：a[i]_address = base_address + (i-1) * data_type_size，多了一次减法操作<br>\t5.2 历史的角度（主要原因）<br>\t\tC 语言设计者用 0 开始计数数组下标<br>\t\t<br>6.容器和数组的选择？<br>\t不追求极致的性能情况下，容器提供了很多方便的操作，增删改查，使用方便。<br>\tJava中容器不支持基本类型，需要将基本类型包装成对象，要求性能的场景下数组操作会比容器操作性能更好。<br>7.思考题<br>\t7.1 JVM中标记清除算法<br>\t对可回收的对象进行标记，之后在合适的时间清除，会产生内存碎片，标记清除效率不高<br>\t7.2 二维数组内存寻址：<br>\t对于 m * n 的数组，a [ i ][ j ] (i &lt; m,j &lt; n)的地址为：<br>\taddress = base_address + ( i * n + j) * type_size","like_count":0},{"had_liked":false,"id":156262,"user_name":"Geek_7d97ca","can_delete":false,"product_type":"c1","uid":1756030,"ip_address":"","ucode":"002170F74F76F8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLMR8PF1W7ITNbGXU8iaeAribkIfqr7aEj9Jj4m4dhZ4sy5nOEBO8v97uxxtuV1YlBphDw1DmoZicqfw/132","comment_is_top":false,"comment_ctime":1574844765,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574844765","product_id":100017301,"comment_content":"day 03<br>课后题：<br>JVM垃圾回收标记-清除算法:当jvm内存不够用时，会停止运用开启GC,会去看对象的引用，如果有引用则标记为可达，没被引用则标记为不可达，遍历一遍所有的后，回去清理标记为不可达的对象，就像数组删除放一块删<br>缺点：jvm标记清除算法容易造成内存不连贯，导致碎片化<br>二维数组寻址公式：初始化a[i][j]  取a[m][n]的地址  address = base_address+(m*j+n)*type_size<br>本章知识点：<br>数组 ：数组的数据结构：线性表   数组是用一组连续的存储空间，存放的一组相同数据类型的数据<br>线性表：数据排列成一条直线的结构，数据只有前和后 有数组，链表，栈，队列<br>非线性表：数据排列不是一条直线，数据不止前和后，有二叉树，堆，图<br>数组越界：在java中会报错，c中会放到数组外的内存<br>数组的插入&#47;数据的删除思想<br>java中的容器和数组的比较：如果写的是底层，且数据类型不是封装类型，可以用数组，速度快，在写业务时，可以直接用ArrayList,java已经优化好了删除和插入并且可以自动以1.5倍进行扩容，在确定数组的大小的情况下，直接指定ArrayList的大小，可以减少扩容和数据签移进行的消耗<br>数组下标从0开始：<br>1.下标不如说是首个数据的偏移量<br>2.在C之后的语言为了统一，方便C工程师学习而沿用了C的设计","like_count":0},{"had_liked":false,"id":156221,"user_name":"刘丶小备","can_delete":false,"product_type":"c1","uid":1102106,"ip_address":"","ucode":"F4D5EF592B7030","user_header":"https://static001.geekbang.org/account/avatar/00/10/d1/1a/3564c9da.jpg","comment_is_top":false,"comment_ctime":1574838699,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574838699","product_id":100017301,"comment_content":"1.标记清除垃圾算法：在标记阶段，遍历所有的GC ROOTS，标记可达的对象为存活，然后标记阶段结束后，执行清理阶段。<br>2.二维数组内存寻址：a[i][j]_address = base_address + ( i * n + j) * type_size","like_count":0},{"had_liked":false,"id":156092,"user_name":"SteveYang","can_delete":false,"product_type":"c1","uid":1754829,"ip_address":"","ucode":"C42BCA4F40A9EF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKCbnOvEatUN4ysE2cl6zJNoAJVXXuQVhicQ1jxh6Z2Towrmmc1I6PndaicuQQ0RyyJPyJQicv4tSib9Q/132","comment_is_top":false,"comment_ctime":1574819001,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574819001","product_id":100017301,"comment_content":"<br>二维数组地址计算：假设i&lt;m, j&lt;n, a[i][j]_address = base_address + (i*n+j)*type_size","like_count":0},{"had_liked":false,"id":156049,"user_name":"梦想的优惠券","can_delete":false,"product_type":"c1","uid":1257418,"ip_address":"","ucode":"D3B44F6C618CA7","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/ca/cbce6e94.jpg","comment_is_top":false,"comment_ctime":1574815546,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1574815546","product_id":100017301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":155928,"user_name":"在路上","can_delete":false,"product_type":"c1","uid":1143372,"ip_address":"","ucode":"335960F683C23C","user_header":"https://static001.geekbang.org/account/avatar/00/11/72/4c/4d636a23.jpg","comment_is_top":false,"comment_ctime":1574779826,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574779826","product_id":100017301,"comment_content":"这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。<br>这里怎么理解的，存储变量i的地址什么时候变成了a[3]的地址了？","like_count":0},{"had_liked":false,"id":155784,"user_name":"evolution","can_delete":false,"product_type":"c1","uid":1088402,"ip_address":"","ucode":"105C59822BF75B","user_header":"https://static001.geekbang.org/account/avatar/00/10/9b/92/c0863297.jpg","comment_is_top":false,"comment_ctime":1574756440,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574756440","product_id":100017301,"comment_content":"下标为0，与其说主要原因是历史原因的话，倒不如说是为了优化。虽然JAVA等高级语言参照了C，但是C没参照谁。那么C的出发点就是为了优化。","like_count":0},{"had_liked":false,"id":155699,"user_name":"克","can_delete":false,"product_type":"c1","uid":1069206,"ip_address":"","ucode":"6DDFBB05E0F4E9","user_header":"https://static001.geekbang.org/account/avatar/00/10/50/96/18612c89.jpg","comment_is_top":false,"comment_ctime":1574738448,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574738448","product_id":100017301,"comment_content":"1. 回顾JVM标记清楚算法<br>   过程：<br>   1、标记阶段：标记正所有需要回收的对象。其标记的过程就是判断对象有效性，执行可达性分析的过程。<br>   2、清除阶段：遍历堆，清除被标记的对象。<br>   优点：实现简单，易与其他算法组合。相比复制算法，对堆空间利用率较高。<br>   缺点：会产生内存碎片。<br>2. 思考二维数组如何寻址<br>       a[i][j]_address = base_address + (i * length + j) * type_size<br>       length表示第一维度数组长度<br>   ","like_count":0},{"had_liked":false,"id":155591,"user_name":"Cy23","can_delete":false,"product_type":"c1","uid":1591293,"ip_address":"","ucode":"8DC561C5151758","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/fd/895f0c27.jpg","comment_is_top":false,"comment_ctime":1574724702,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574724702","product_id":100017301,"comment_content":"对数组又进一步深入了理解","like_count":0},{"had_liked":false,"id":155521,"user_name":"鱿鱼先森","can_delete":false,"product_type":"c1","uid":1694627,"ip_address":"","ucode":"543FB3F2AA852B","user_header":"https://wx.qlogo.cn/mmopen/vi_32/ox4nIqvFdt77xSW2rm5QJcYPj0r10up6etUXohw47B50Giby7wexBksrpcSu3n9n7iaqGFCGt2STMkJlJgKaTzvg/132","comment_is_top":false,"comment_ctime":1574695315,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574695315","product_id":100017301,"comment_content":"1、数组插入和删除，低效的关键在于数据搬移，其中，各自trick在于：<br>①插入：对于无序数组的插入，可以选择将指定插入位置的元素扔到末尾，新元素补到腾出来的位置里去；<br>②删除：当对数据连续型的要求不高时，可以将需删除的元素先标记为删除，等数组满了，再一次性删去，其中有可能能减少一些重复数据搬移的操作。<br>2、容器和数组各有优劣，实际使用过程中，要视情况灵活选择。容器中对于数组操作的封装较好，但是数组对于数据类型的支持更好，而且多维数组的代码表示也更直观。","like_count":0},{"had_liked":false,"id":155515,"user_name":"鱿鱼先森","can_delete":false,"product_type":"c1","uid":1694627,"ip_address":"","ucode":"543FB3F2AA852B","user_header":"https://wx.qlogo.cn/mmopen/vi_32/ox4nIqvFdt77xSW2rm5QJcYPj0r10up6etUXohw47B50Giby7wexBksrpcSu3n9n7iaqGFCGt2STMkJlJgKaTzvg/132","comment_is_top":false,"comment_ctime":1574694653,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574694653","product_id":100017301,"comment_content":"数组查找，线性查找(On)和二分查找算法(Ologn)；其中 需要注意的是，在排好序的数组中，根据下标访问指定元素，时间复杂度是O(1)。","like_count":0},{"had_liked":false,"id":155455,"user_name":"所以然","can_delete":false,"product_type":"c1","uid":1719978,"ip_address":"","ucode":"57BE96CE3AD939","user_header":"https://static001.geekbang.org/account/avatar/00/1a/3e/aa/8c7125c1.jpg","comment_is_top":false,"comment_ctime":1574690501,"is_pvip":false,"replies":[{"id":"60061","content":"随机是相对于链表的顺序访问来说的。随机的意思是我可以取下标是1、5、19的数据，并且时间复杂度是O（1）。而链表是做不到的。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1574859000,"ip_address":"","comment_id":155455,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1574690501","product_id":100017301,"comment_content":"随机访问，暂时只能理解到：数组是基于下标的随机访问。但是，这个访问为什么被定义为随机访问，不能是其他访问有些疑惑。老师有时间，希望给解个惑。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475758,"discussion_content":"随机是相对于链表的顺序访问来说的。随机的意思是我可以取下标是1、5、19的数据，并且时间复杂度是O（1）。而链表是做不到的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574859000,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1719978,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/3e/aa/8c7125c1.jpg","nickname":"所以然","note":"","ucode":"57BE96CE3AD939","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62735,"discussion_content":"好的，谢谢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574860056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155375,"user_name":"Loren","can_delete":false,"product_type":"c1","uid":1330316,"ip_address":"","ucode":"672280193FEAA5","user_header":"https://static001.geekbang.org/account/avatar/00/14/4c/8c/44b88ce8.jpg","comment_is_top":false,"comment_ctime":1574683378,"is_pvip":false,"replies":[{"id":"60055","content":"ipad paper","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1574858477,"ip_address":"","comment_id":155375,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574683378","product_id":100017301,"comment_content":"你好，我想请问一下上面的图是用什么软件画出来的？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475734,"discussion_content":"ipad paper","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574858477,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154892,"user_name":"大海","can_delete":false,"product_type":"c1","uid":1001446,"ip_address":"","ucode":"20913D0265971B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/47/e6/67b0b711.jpg","comment_is_top":false,"comment_ctime":1574592858,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574592858","product_id":100017301,"comment_content":"思考题：<br>不熟悉 java，在 JavaScript 里面，数组是引用类型，如果是二维数组，第一层保存的元素是数组的指针，指向真正的地址。","like_count":0},{"had_liked":false,"id":154702,"user_name":"菽绣","can_delete":false,"product_type":"c1","uid":1755477,"ip_address":"","ucode":"60955E14C39C6B","user_header":"https://static001.geekbang.org/account/avatar/00/1a/c9/55/0e627a31.jpg","comment_is_top":false,"comment_ctime":1574515049,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574515049","product_id":100017301,"comment_content":"二维数组的话，那就存地址，地址指向内层数组，address = value(base_address + i * data_size) + j * inner_data_size","like_count":0},{"had_liked":false,"id":154661,"user_name":"Helr","can_delete":false,"product_type":"c1","uid":1488631,"ip_address":"","ucode":"A24C99263E657B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoAoDJJLy1iciaOxXNqwwnB8oV5TRyxNaI0FMRtjRK0QTsmo378OZYZRosOOqjrBhnomsDJQflpr0Fw/132","comment_is_top":false,"comment_ctime":1574502508,"is_pvip":false,"replies":[{"id":"60062","content":"因为需要支持随机访问，如果存储不同类型的数据，就无法通过寻址公式来定位数据了","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1574859057,"ip_address":"","comment_id":154661,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574502508","product_id":100017301,"comment_content":"请问一下为什么数组要限制相同数据类型","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475539,"discussion_content":"因为需要支持随机访问，如果存储不同类型的数据，就无法通过寻址公式来定位数据了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574859057,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154012,"user_name":"Sun Fei","can_delete":false,"product_type":"c1","uid":1032631,"ip_address":"","ucode":"092EC0992050BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c1/b7/57f153f6.jpg","comment_is_top":false,"comment_ctime":1574346789,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574346789","product_id":100017301,"comment_content":"打卡。","like_count":0},{"had_liked":false,"id":153954,"user_name":"一零二四","can_delete":false,"product_type":"c1","uid":1735195,"ip_address":"","ucode":"5F5C3D2E3DF402","user_header":"https://static001.geekbang.org/account/avatar/00/1a/7a/1b/2c78be5f.jpg","comment_is_top":false,"comment_ctime":1574337003,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574337003","product_id":100017301,"comment_content":"棒","like_count":0},{"had_liked":false,"id":153759,"user_name":"神执念の浅言多行","can_delete":false,"product_type":"c1","uid":1373637,"ip_address":"","ucode":"59C0659C7E3ACC","user_header":"https://static001.geekbang.org/account/avatar/00/14/f5/c5/9b06bdb5.jpg","comment_is_top":false,"comment_ctime":1574303324,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574303324","product_id":100017301,"comment_content":"老师，当我看到您说的数组的定义，其中说到“数组是用一组连续的内存空间，来存储已租具有相同类型的数据”，这个在C类型语言中是OK的，那么，在JS的数组中，一个数据也可以用来存储各种类型，是怎么解释呢？<br>我的猜想是，多个数组拼接而成，但如果是拼接的，怎么保证是连续的内存空间呢。","like_count":0},{"had_liked":false,"id":153129,"user_name":"Warn","can_delete":false,"product_type":"c1","uid":1465310,"ip_address":"","ucode":"F2F7FCDB0940D0","user_header":"https://static001.geekbang.org/account/avatar/00/16/5b/de/152f1c2c.jpg","comment_is_top":false,"comment_ctime":1574164722,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574164722","product_id":100017301,"comment_content":"数组的随机访问特性，区分于链表的插入、删除特性。好尴尬，逐个删除的事情做过。","like_count":0},{"had_liked":false,"id":153059,"user_name":"HLi-D","can_delete":false,"product_type":"c1","uid":1664684,"ip_address":"","ucode":"749F2861C744FF","user_header":"https://static001.geekbang.org/account/avatar/00/19/66/ac/dd34e199.jpg","comment_is_top":false,"comment_ctime":1574149890,"is_pvip":false,"replies":[{"id":"59141","content":"ipad paper","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1574334098,"ip_address":"","comment_id":153059,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574149890","product_id":100017301,"comment_content":"老师您好，刚开始学习您的课程；不知您文章中的  炫酷的图 是用什么软件画的呢？叫什么图，纠结好久了，老看见别人文章中有这样的图，自己想学确不知道门路，望指点下方向，感谢！","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475030,"discussion_content":"ipad paper","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574334098,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152961,"user_name":"陈六毛","can_delete":false,"product_type":"c1","uid":1001632,"ip_address":"","ucode":"6A0AB34CADF14A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/a0/85271710.jpg","comment_is_top":false,"comment_ctime":1574130070,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1574130070","product_id":100017301,"comment_content":"大家好！<br>我是阿里巴巴天猫超市的技术专家tanyue，<br>我们正在急招java技术专家、java高级开发工程师的岗位。<br>工作地点在杭州，阿里巴巴总部（西溪园区）。<br><br>我们事业部是阿里巴巴新零售生态布局的排头兵，去年底刚刚升级为独立的事业群，有非常好的发展空间。<br>​简历直接发送到我的邮箱tanyue.ct@alibaba-inc.com内推！机会难得，我们期待优秀的你！<br><br><br>如果你在北京，并且考虑来杭州发展，我们11.19日在北京会举办一场专场招聘，面试流程一天走完，不需要向以往那样等待较长时间的流程，机会难得，欢迎把简历发送到我的邮箱哦！<br>​请放心，我们有严格的数据安全保护流程，会保护好你的个人信息！","like_count":0,"discussions":[{"author":{"id":1266620,"avatar":"https://static001.geekbang.org/account/avatar/00/13/53/bc/72baeee8.jpg","nickname":"林黛玉","note":"","ucode":"F8507366012881","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":199457,"discussion_content":"哈哈哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583590544,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152854,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1025030,"ip_address":"","ucode":"62A89FD460827A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a4/06/cf6b6d0f.jpg","comment_is_top":false,"comment_ctime":1574089573,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574089573","product_id":100017301,"comment_content":"1、老年代的 CMS 用的就是标记清理算法：分成初始标记、并发标记、重新标记和并发清理四个阶段。没有被 GC Roots 引用的对象就会被标记为垃圾对象，垃圾对象会在并发清理阶段被清理。<br><br>2、二维数组的寻址公式：当前地址+(i*n+j)*size<br>","like_count":0},{"had_liked":false,"id":152199,"user_name":"tucker","can_delete":false,"product_type":"c1","uid":1730521,"ip_address":"","ucode":"075AFD7BAA71FB","user_header":"https://static001.geekbang.org/account/avatar/00/1a/67/d9/0aff49e3.jpg","comment_is_top":false,"comment_ctime":1573910813,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573910813","product_id":100017301,"comment_content":"垃圾回收算法：<br>1.标记清除：标记可回收对象并进行回收<br>2.标记整理：标记存活对象向一端移动，然后清理另一端<br>3.\b复制：复制存活对象到另一块内存，然后回收垃圾<br>4.分代收集：老年代用标记清除和标记整理，新生代用复制","like_count":0},{"had_liked":false,"id":151880,"user_name":"木子00","can_delete":false,"product_type":"c1","uid":1314724,"ip_address":"","ucode":"8F78CA722EB29B","user_header":"https://static001.geekbang.org/account/avatar/00/14/0f/a4/0b49469f.jpg","comment_is_top":false,"comment_ctime":1573805116,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1573805116","product_id":100017301,"comment_content":"列子中:<br>数组 a[10] 中存储了 8 个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除 a，b，c 三个元素为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时....<br>这里的十足没有更多的空间存储数据呢？<br>不是删除操作吗？为什么数据空间会不够呢？ ","like_count":0},{"had_liked":false,"id":151850,"user_name":"魏春河","can_delete":false,"product_type":"c1","uid":1117048,"ip_address":"","ucode":"DDD2998C157639","user_header":"https://static001.geekbang.org/account/avatar/00/11/0b/78/22410c47.jpg","comment_is_top":false,"comment_ctime":1573799888,"is_pvip":false,"replies":[{"id":"58606","content":"ipad paper","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1574040503,"ip_address":"","comment_id":151850,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1573799888","product_id":100017301,"comment_content":"老师您这里面的插图使用什么软件画的？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474636,"discussion_content":"ipad paper","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574040503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151637,"user_name":"Geek_d4fb46","can_delete":false,"product_type":"c1","uid":1744103,"ip_address":"","ucode":"69BE7B4DBB6DAF","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ePdic5bvt1mhBC4j2P2IibIVQDCzM3O8rjmGkmFQkHdhbKbKMKsMRmYxm8QE1ibQn1VQ9QfsCfgwlzuGRHkxW9AXw/132","comment_is_top":false,"comment_ctime":1573773409,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573773409","product_id":100017301,"comment_content":"二维数组寻址: addr = i×sizeof(type)×maxj+j×sizeof(type)","like_count":0},{"had_liked":false,"id":151594,"user_name":"Ronnyz","can_delete":false,"product_type":"c1","uid":1488280,"ip_address":"","ucode":"9F34527B1D343D","user_header":"https://static001.geekbang.org/account/avatar/00/16/b5/98/ffaf2aca.jpg","comment_is_top":false,"comment_ctime":1573746649,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573746649","product_id":100017301,"comment_content":"对于一个a[m][n]的数组<br><br>a[i][j]_address = base_address + (i*n+j) * type_size","like_count":0},{"had_liked":false,"id":151259,"user_name":"渴望做梦","can_delete":false,"product_type":"c1","uid":1398219,"ip_address":"","ucode":"9EB47530A69C91","user_header":"https://static001.geekbang.org/account/avatar/00/15/55/cb/1efe460a.jpg","comment_is_top":false,"comment_ctime":1573692331,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573692331","product_id":100017301,"comment_content":"老师，我在想像javascript这样的动态弱类型语言，定义数组时不需要事先确定数组大小，相当于可以动态扩容，也没有类型限制，数组里面可以存不同类型数据。<br>这是如何实现动态扩容和随机访问的呢？","like_count":0},{"had_liked":false,"id":150614,"user_name":"攻城狮Ra","can_delete":false,"product_type":"c1","uid":1681051,"ip_address":"","ucode":"4D6F97A6481166","user_header":"https://static001.geekbang.org/account/avatar/00/19/a6/9b/20b9fce3.jpg","comment_is_top":false,"comment_ctime":1573568561,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573568561","product_id":100017301,"comment_content":"总结：<br> 1、线性表是数据排成像一条线一样的结构，每个线性表最多只有前和后两个方向，数组、链表、队列、栈等都是线性表；<br><br><br> 2、数组是一种线性表数据结构，它用一组连续的内存结构，来存储一组具有相同数据类型的数据；<br>数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。数组为了保持内存空间的连续性，会导致插入、删除两个操作的低效性；<br> <br><br><br>注意：数组越界在C语言是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。因为，访问数组的本质就是顾问一段连续的内存，只要数组通过偏移计算得到的内存空间时可用的，那么程序可能就不报任何错误<br> <br><br><br><br>针对数组类型，Java提供容器类：ArrayList最大的优势就是可以将很多数组操作的细节封装起来，比如数组插入、删除数据时需要搬移其他数据等。另外，它还有一个优势，就是支持动态扩容<br><br>","like_count":0},{"had_liked":false,"id":150526,"user_name":"Geek_fcb60e","can_delete":false,"product_type":"c1","uid":1117962,"ip_address":"","ucode":"83BDA792DEF0B5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoFjkKTSiceSmJbpnVqUiaf04icePSUU5OISTA14mVxoZcK3lLZBu7Q8wvPm8PFUcqWNPTx6sY4aKyNg/132","comment_is_top":false,"comment_ctime":1573549707,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573549707","product_id":100017301,"comment_content":"如果有些名词，最后能附上一些资料的链接。让我这种小白可以去看，去学习","like_count":0},{"had_liked":false,"id":150522,"user_name":"Geek_fcb60e","can_delete":false,"product_type":"c1","uid":1117962,"ip_address":"","ucode":"83BDA792DEF0B5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoFjkKTSiceSmJbpnVqUiaf04icePSUU5OISTA14mVxoZcK3lLZBu7Q8wvPm8PFUcqWNPTx6sY4aKyNg/132","comment_is_top":false,"comment_ctime":1573549106,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573549106","product_id":100017301,"comment_content":"对于这些转行看起来很吃力。前几章多次拜读，还是很吃力，继续努力，慢慢看。","like_count":0},{"had_liked":false,"id":150490,"user_name":"握不住手中沙","can_delete":false,"product_type":"c1","uid":1097132,"ip_address":"","ucode":"F194E47C4D42C9","user_header":"https://static001.geekbang.org/account/avatar/00/10/bd/ac/49494ed8.jpg","comment_is_top":false,"comment_ctime":1573544684,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573544684","product_id":100017301,"comment_content":"思考题：<br>1、JVM标记--清除算法分为两阶段操作，第一阶段：由root开始遍历所有的对象，将root可达的对象marked标记为存活状态true（默认为false）；第二阶段：遍历堆中所有的对象，将marked==false的对象释放回收，同时将marked==true对象的marked标识改回默认值false。<br>优点：在内存不足的情况下才进行回收；有效解决对象循环引用问题；<br>缺点：标记和清除的效率不高，需要遍历堆中所有的对象；容易产生不连续的内存空间碎片；进行清除回收时应用需要挂起；<br>2、二位数组的内存寻址公式<br>对于 m * n 的数组，a [ i ][ j ] (i &lt; m，j &lt; n)的地址为：address = base_address + ( i * n + j) * type_size","like_count":0},{"had_liked":false,"id":150403,"user_name":"朱润杰","can_delete":false,"product_type":"c1","uid":1738957,"ip_address":"","ucode":"6436C3D58D0FC3","user_header":"https://static001.geekbang.org/account/avatar/00/1a/88/cd/7ee7e9db.jpg","comment_is_top":false,"comment_ctime":1573528611,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573528611","product_id":100017301,"comment_content":"JVM标记清除算法是：首先进行可达性分析，如果对象和GC roots间没有链接那么就会标记为可清除，等标记完成后再做清理。但是会造成内存出现大量碎片，效率也比较低。<br>","like_count":0},{"had_liked":false,"id":149957,"user_name":"夜空咏叹调","can_delete":false,"product_type":"c1","uid":1189074,"ip_address":"","ucode":"CC9350BCF218CD","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/d2/a5e272ce.jpg","comment_is_top":false,"comment_ctime":1573436136,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573436136","product_id":100017301,"comment_content":"数组下标以0开始是因为数组的内存地址是内存首地址加上内存偏移量，如果下标是0开始，直接就是下标0的首地址+内存块偏移量*下标数，而如果以1开始就是下标1的地址+内存块偏移量*(下标数-1)，后者会多一次减法计算，但是这个是以前对内存使用率要求高造成的，更多的其实是历史原因。","like_count":0},{"had_liked":false,"id":149764,"user_name":"zzh","can_delete":false,"product_type":"c1","uid":1174510,"ip_address":"","ucode":"0FC6BD729E5801","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJmcPTvjtSbhBNic4wb61Pj77nIHcLG64MnAXicsHBrMWvjCQPoiaHTtYmbnlVSkSWZEnN2QlicekqLhg/132","comment_is_top":false,"comment_ctime":1573371619,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573371619","product_id":100017301,"comment_content":"2019年11月10日 15点40打卡","like_count":0},{"had_liked":false,"id":149325,"user_name":"binさま","can_delete":false,"product_type":"c1","uid":1737433,"ip_address":"","ucode":"10CCD3AA84EA06","user_header":"https://static001.geekbang.org/account/avatar/00/1a/82/d9/b839e3ff.jpg","comment_is_top":false,"comment_ctime":1573193373,"is_pvip":false,"replies":[{"id":"57636","content":"在我讲的场景中，删除操作需要搬移数据。而标记再删除的方式，可以减少搬移操作。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1573424907,"ip_address":"","comment_id":149325,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1573193373","product_id":100017301,"comment_content":"依次删除 a，b，c 三个元素和先标记最后一起删除移动次数不该是一样的，而且还多了标记的时间。不太清楚这个例子的含义，望老师解答一下😂","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473817,"discussion_content":"在我讲的场景中，删除操作需要搬移数据。而标记再删除的方式，可以减少搬移操作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573424907,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1737433,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/82/d9/b839e3ff.jpg","nickname":"binさま","note":"","ucode":"10CCD3AA84EA06","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":48836,"discussion_content":"就是说节省了接下来可能被删除的记录的移动时间吗？？我好像有点明白了😂谢谢(*°∀°)=3","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573531795,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148891,"user_name":"微风","can_delete":false,"product_type":"c1","uid":1701782,"ip_address":"","ucode":"C448DEF37B2500","user_header":"https://static001.geekbang.org/account/avatar/00/19/f7/96/06fc7f1c.jpg","comment_is_top":false,"comment_ctime":1573104036,"is_pvip":true,"replies":[{"id":"57640","content":"跟数组的随机定位特性有关，如果存储不同类型的，那每个元素的大小就不同，就不能用寻址公式了。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1573425163,"ip_address":"","comment_id":148891,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573104036","product_id":100017301,"comment_content":"用了这么多年的数组，有一个性质就是，要存储一组具有相同类型的数据。<br><br>请问老师：我想了解一下，是什么制约了数组不能存储不同类型的数据呢？这和内存有关系吗？<br><br>以前一直默认使用，也没有好好思考这个问题。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473655,"discussion_content":"跟数组的随机定位特性有关，如果存储不同类型的，那每个元素的大小就不同，就不能用寻址公式了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573425163,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148511,"user_name":"Hua100","can_delete":false,"product_type":"c1","uid":1723325,"ip_address":"","ucode":"4E7A749C343E90","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLLeKVmTFdR2hQsCaNxxTK8wvnXXBayKLLoITqnbW9yjloAZWU99mOGaf1DkWqM6dol77aER9ickibA/132","comment_is_top":false,"comment_ctime":1573022964,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573022964","product_id":100017301,"comment_content":"标记清除，标记整理，复制。","like_count":0},{"had_liked":false,"id":147980,"user_name":"JAMES","can_delete":false,"product_type":"c1","uid":1170796,"ip_address":"","ucode":"63015120144DDB","user_header":"https://static001.geekbang.org/account/avatar/00/11/dd/6c/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1572924792,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572924792","product_id":100017301,"comment_content":"2019&#47;11&#47;05 JAMES 滴滴","like_count":0},{"had_liked":false,"id":146470,"user_name":"酒薄不堪饮","can_delete":false,"product_type":"c1","uid":1612675,"ip_address":"","ucode":"82ECDE075BCA20","user_header":"https://static001.geekbang.org/account/avatar/00/18/9b/83/c56e4e46.jpg","comment_is_top":false,"comment_ctime":1572530729,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572530729","product_id":100017301,"comment_content":"先记录下已经删除的数据.记录到哪里,,怎么记录??还有那个无限循环的...还有二维数组寻址的,怎么看都很蒙蔽","like_count":0},{"had_liked":false,"id":145463,"user_name":"星","can_delete":false,"product_type":"c1","uid":1102793,"ip_address":"","ucode":"B452366224FBBF","user_header":"https://static001.geekbang.org/account/avatar/00/10/d3/c9/b6f44f1a.jpg","comment_is_top":false,"comment_ctime":1572277519,"is_pvip":false,"replies":[{"id":"56460","content":"😁 那要看具体的操作啊","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1572487486,"ip_address":"","comment_id":145463,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572277519","product_id":100017301,"comment_content":"老师，我问下为什么上一篇讲数组的平均复杂度是O1，到这一篇又是On了呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472411,"discussion_content":"😁 那要看具体的操作啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572487486,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145441,"user_name":"Mr.Fu","can_delete":false,"product_type":"c1","uid":1613254,"ip_address":"","ucode":"F1E4304C5CDE52","user_header":"https://static001.geekbang.org/account/avatar/00/18/9d/c6/a72db706.jpg","comment_is_top":false,"comment_ctime":1572273655,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572273655","product_id":100017301,"comment_content":"一.What-数组定义：一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据<br>线性表：数据排成像一条线一样的结构，每个线性表上的数据最多只有前和后两个方向(非线性表中，数据之间并不是简单的前后关系)<br>连续的内存空间和相同类型的数据：支持随机访问，寻址公式a[i]_address = base_address + i * data_type_size<br>内存数据的连续性，导致插入、删除比较低效<br>二.数组的遍历、插入和删除<br>数组的遍历<br>由于连续的内存空间，当根据下标随机访问时，时间复杂度为 O(1)<br>但是当查询数组中是否包含指定元素时，即使是二分查找，时间复杂度也是O(logn)<br>数组的插入<br>移动新插入的数据之后的所有节点:{3,2,0,1}-&gt;{3,5,2,0,1}，此时最好O(1)，最坏O(n)，平均O(n)<br>不移动新插入的数据之后的节点，仅是互换相应节点的值:{3,2,0,1}-&gt;{3,5,0,1,2}，此时都是O(1)<br>数组的删除<br>为了内存的连续性，删除第 k 个位置的数据需要搬移数据，此时最好O(1)，最坏O(n)，平均O(n)。<br>数组{a，b，c，d，e，f，g，h}，要删除a、b、c三个元素，为了避免 d，e，f，g，h 被搬移三次，每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，再触发执行一次真正的删除，这样大大减少删除操作导致的数据搬移-JVM 标记清除垃圾回收算法<br>三.容器和数组简单对比<br>容器提供更好用的API接口<br>容器封装了数据搬移、动态扩容等细节<br>容器不支持基本数据类型(仅引用数据类型)，而自动装箱损耗性能<br>多维存储数据时，二维数组更直观Object[][] array&gt;ArrayList &gt; array<br>底层的开发，很注重性能时，首选数组<br>四.几个问题<br>为什么Java中，数组要从 0 开始编号，而不是从 1 开始呢？<br>如果从1开始，寻址公式变成a[k]_address = base_address + (k-1)*type_size，数组是太底层的数据结构，k-1损耗性能<br>Java由C实现，C的数组也是从0开始，效仿沿用C的用法，降低学习成本<br>二维数组寻址公式<br>对于 m * n 的数组，a [ i ][ j ] (i &lt; m,j &lt; n)寻址公式为address = base_address + ( i * n + j) * type_size\t","like_count":0},{"had_liked":false,"id":145016,"user_name":"小超人","can_delete":false,"product_type":"c1","uid":1411096,"ip_address":"","ucode":"0D8A433F3E3737","user_header":"https://static001.geekbang.org/account/avatar/00/15/88/18/9744d5ec.jpg","comment_is_top":false,"comment_ctime":1572161499,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572161499","product_id":100017301,"comment_content":"c++ 的智能指针也不错啊，引用计数，自动回收♻内存空间","like_count":0},{"had_liked":false,"id":144950,"user_name":"吃瓜胖子😂","can_delete":false,"product_type":"c1","uid":1325243,"ip_address":"","ucode":"174240CB0097A6","user_header":"https://static001.geekbang.org/account/avatar/00/14/38/bb/e3bf1040.jpg","comment_is_top":false,"comment_ctime":1572135627,"is_pvip":false,"replies":[{"id":"55972","content":"0是头呀","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1572229612,"ip_address":"","comment_id":144950,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572135627","product_id":100017301,"comment_content":"数组哪边是头 哪边是尾？  0是尾？ lenth-1 是头？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472183,"discussion_content":"0是头呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572229612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144121,"user_name":"吃瓜胖子😂","can_delete":false,"product_type":"c1","uid":1325243,"ip_address":"","ucode":"174240CB0097A6","user_header":"https://static001.geekbang.org/account/avatar/00/14/38/bb/e3bf1040.jpg","comment_is_top":false,"comment_ctime":1571845269,"is_pvip":false,"replies":[{"id":"56001","content":"当然可以啊","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1572231561,"ip_address":"","comment_id":144121,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1571845269","product_id":100017301,"comment_content":"int数组中每个元素的内存地址是否可以打印出来？ java语言","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471819,"discussion_content":"当然可以啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572231561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1325243,"avatar":"https://static001.geekbang.org/account/avatar/00/14/38/bb/e3bf1040.jpg","nickname":"吃瓜胖子😂","note":"","ucode":"174240CB0097A6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40539,"discussion_content":"咋打印呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572232035,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144004,"user_name":"春阳","can_delete":false,"product_type":"c1","uid":1236231,"ip_address":"","ucode":"82C9B7D2717C01","user_header":"https://static001.geekbang.org/account/avatar/00/12/dd/07/39eaca28.jpg","comment_is_top":false,"comment_ctime":1571822982,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571822982","product_id":100017301,"comment_content":"数组用一块连续的内存空间，来存储相同类型的一组数据，最大的特点就是支持随机访问，但插入、删除操作也因此变得比较低效，平均情况时间复杂度为 O(n)。","like_count":0},{"had_liked":false,"id":143962,"user_name":"Eleven","can_delete":false,"product_type":"c1","uid":1168452,"ip_address":"","ucode":"FB4A0C8CA732BE","user_header":"https://static001.geekbang.org/account/avatar/00/11/d4/44/0ec958f4.jpg","comment_is_top":false,"comment_ctime":1571815892,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571815892","product_id":100017301,"comment_content":"我们知道，在 C 语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。根据我们前面讲的数组寻址公式，a[3] 也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。 老师，这个地方不是很明白，怎么越界的地址就是i的内存地址呢？","like_count":0},{"had_liked":false,"id":143911,"user_name":"wend","can_delete":false,"product_type":"c1","uid":1014096,"ip_address":"","ucode":"45EE220931FE91","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJyzUm3M4HMj0wXv8Pr34OhOiaFJjFMSjVKnaJoOWR9Uo1T4RBI4MYtguolJgOwb6eKsAUOq4MGlrw/132","comment_is_top":false,"comment_ctime":1571805967,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571805967","product_id":100017301,"comment_content":"二维数组寻址<br>a[x][y] = a + y*size + x*length*size","like_count":0},{"had_liked":false,"id":143373,"user_name":"黄振宇","can_delete":false,"product_type":"c1","uid":1686397,"ip_address":"","ucode":"976BC7B46DA419","user_header":"https://static001.geekbang.org/account/avatar/00/19/bb/7d/26340713.jpg","comment_is_top":false,"comment_ctime":1571700696,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571700696","product_id":100017301,"comment_content":"<br>- 数组是一种**线性表数据结构**，它用**连续的内存空间，来存储一组具有相同类型的数据**。<br>  数组适合**随机访问**，其随机访问是根据连续存储的特点，通过简单的寻址公式来实现，时间复杂度是O(1)<br>- 数组的插入和删除就显的低效了。主要涉及到数据的搬迁<br>  - 插入，如果在末尾，即最好情况时间复杂度为O(1)，如果在队头，即最坏情况时间复杂度为O(n)，平均情况时间复杂度也为O(n)<br>  - 如果不涉及到数据的搬迁，插入则直接替换两下标的位置即可，这在插入排序中会用到。<br>  - 删除，如果在末尾，即最好情况时间复杂度为O(1)，如果在队头，即最坏情况时间复杂度为O(n)，平均情况时间复杂度也为O(n)<br><br>  - JVM删除的机制，不执行真正的删除，只是标记下数据已经被删除。当数据空间不够的时候再执行一次真正的删除操作。<br><br>    <br><br>- 警惕数据越界<br><br>  只要不是访问受限的内存，所有的内存空间都是自由访问的。如果要访问的数组下标超过了数组的范围，就会访问到界外空间，造成代码莫名其妙的逻辑错误。<br><br><br><br>- 动态扩容<br><br>  ```c++<br>  #include &lt;iostream&gt;<br>  #include &lt;vector&gt;<br>  #include &lt;iterator&gt;<br>  <br>  int main()<br>  {<br>      std::vector&lt;int&gt; v;<br>      for (int i = 0; i &lt; 10; i++)<br>      {<br>          v.push_back(i);<br>          std::cout &lt;&lt; &quot;Insert &quot; &lt;&lt; i &lt;&lt; &quot;. The capacity of the vector is &quot; &lt;&lt; v.capacity() &lt;&lt; std::endl;<br>      }<br>  <br>      for (std::vector&lt;int&gt;::iterator it = v.begin(); it != v.end();it ++)<br>      {<br>          std::cout &lt;&lt; *it &lt;&lt; std::endl;   <br>      }<br>  }<br>  ```<br><br>  在不断给vector添加数据的时候，vector的大小不断成倍的扩张。<br><br>  打印输出：<br><br>  ```<br>  Insert 0. The capacity of the vector is 1<br>  Insert 1. The capacity of the vector is 2<br>  Insert 2. The capacity of the vector is 4<br>  Insert 3. The capacity of the vector is 4<br>  Insert 4. The capacity of the vector is 8<br>  Insert 5. The capacity of the vector is 8<br>  Insert 6. The capacity of the vector is 8<br>  Insert 7. The capacity of the vector is 8<br>  Insert 8. The capacity of the vector is 16<br>  Insert 9. The capacity of the vector is 16<br>  ```<br><br>  <br><br>但若是实现给vector固定大小的容器，则不会出现此情况。<br><br>```c++<br>#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br>#include &lt;iterator&gt;<br><br>int main()<br>{<br>    std::vector&lt;int&gt; v;<br>    v.resize(20);<br>    for (int i = 0; i &lt; 10; i++)<br>    {<br>        v.push_back(i);<br>        std::cout &lt;&lt; &quot;Insert &quot; &lt;&lt; i &lt;&lt; &quot;. The capacity of the vector is &quot; &lt;&lt; v.capacity() &lt;&lt; std::endl;<br>    }<br><br>}<br>```<br><br>输出为：<br><br>```<br>Insert 0. The capacity of the vector is 40<br>。。。<br>```<br><br>此时的容量一直是40，即2倍的我赋予的20。","like_count":0},{"had_liked":false,"id":143367,"user_name":"黄振宇","can_delete":false,"product_type":"c1","uid":1686397,"ip_address":"","ucode":"976BC7B46DA419","user_header":"https://static001.geekbang.org/account/avatar/00/19/bb/7d/26340713.jpg","comment_is_top":false,"comment_ctime":1571698858,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571698858","product_id":100017301,"comment_content":"C++中容器vector的动态扩容，<br>#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br>#include &lt;iterator&gt;<br><br>int main()<br>{<br>    std::vector&lt;int&gt; v;<br>    for (int i = 0; i &lt; 10; i++)<br>    {<br>        v.push_back(i);<br>        std::cout &lt;&lt; &quot;Insert &quot; &lt;&lt; i &lt;&lt; &quot;. The capacity of the vector is &quot; &lt;&lt; v.capacity() &lt;&lt; std::endl;<br>    }<br><br>    for (std::vector&lt;int&gt;::iterator it = v.begin(); it != v.end();it ++)<br>    {<br>        std::cout &lt;&lt; *it &lt;&lt; std::endl;<br>        <br>    }<br>}<br><br>运行结果为：<br>Insert 0. The capacity of the vector is 1<br>Insert 1. The capacity of the vector is 2<br>Insert 2. The capacity of the vector is 4<br>Insert 3. The capacity of the vector is 4<br>Insert 4. The capacity of the vector is 8<br>Insert 5. The capacity of the vector is 8<br>Insert 6. The capacity of the vector is 8<br>Insert 7. The capacity of the vector is 8<br>Insert 8. The capacity of the vector is 16<br>Insert 9. The capacity of the vector is 16<br>0<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br><br>每次容量不够大的时候都会进行2倍的扩容。如果事先resize了这个容器则不会有动态扩容的问题。","like_count":0},{"had_liked":false,"id":143159,"user_name":"grace","can_delete":false,"product_type":"c1","uid":1572488,"ip_address":"","ucode":"6F32FE8C849C68","user_header":"https://static001.geekbang.org/account/avatar/00/17/fe/88/44ef809f.jpg","comment_is_top":false,"comment_ctime":1571640924,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571640924","product_id":100017301,"comment_content":"讲的很好呢！","like_count":0},{"had_liked":false,"id":141739,"user_name":"contract","can_delete":false,"product_type":"c1","uid":1263121,"ip_address":"","ucode":"74E4271DB02E73","user_header":"https://static001.geekbang.org/account/avatar/00/13/46/11/dbfe5f71.jpg","comment_is_top":false,"comment_ctime":1571216609,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571216609","product_id":100017301,"comment_content":"标记-清除：mark-sweep:标记：标记要回收的对象；清除：根据标记回收被标记的对象，缺点，容易产生碎片<br>copy：将内存分为两块，每次只是用其中一块，当该块内存被使用完了，就将或者的对象复制到另外一块内存上，而用完的那块内存则全部清理掉<br>标记-整理：标记-整理-清除：标记完成后，将存活内存向一端移动，然后清理掉边界以外的内存===》对应于文中所讲的数组删除优化算法","like_count":0},{"had_liked":false,"id":141648,"user_name":"学个球","can_delete":false,"product_type":"c1","uid":1019725,"ip_address":"","ucode":"7343F3C0CA981D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8f/4d/65fb45e6.jpg","comment_is_top":false,"comment_ctime":1571206852,"is_pvip":false,"replies":[{"id":"55222","content":"说的没错：）","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1571618433,"ip_address":"","comment_id":141648,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571206852","product_id":100017301,"comment_content":"对于将元素集中触发删除操作，这个删除操作是不是权衡了需要标记待删除元素的额外空间和时间的关系，类似于用“空间换时间”？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470834,"discussion_content":"说的没错：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571618433,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141595,"user_name":"萱萱","can_delete":false,"product_type":"c1","uid":1689698,"ip_address":"","ucode":"3AF284379A3D62","user_header":"https://static001.geekbang.org/account/avatar/00/19/c8/62/b6f453f5.jpg","comment_is_top":false,"comment_ctime":1571198014,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571198014","product_id":100017301,"comment_content":"想问一下在数组的删除操作中提出了先记录abc三个元素再删除的操作方法，这里的记录是定义了一个新的长度为3的数组吗？什么情况算是没有更多存储空间存储数据呢？触发一次真正的删除操作之后原数组不会存在空洞吗？","like_count":0},{"had_liked":false,"id":141402,"user_name":"Geek_272a2e","can_delete":false,"product_type":"c1","uid":1691776,"ip_address":"","ucode":"C3F82497030D0C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLibX06ACicicBdkD4hkSTkVm9fIT1xwdXV52GvQahFmTVSFHhxbDWjNOk5mdwE3hRFLO6QjRYIKoffA/132","comment_is_top":false,"comment_ctime":1571147934,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571147934","product_id":100017301,"comment_content":"1. 只大概记录这种算法分两个步骤，第一步先判断一个对象是否有GC Root对象直接或间接引用，如果没有任何对象引入则标记为可回收，第二步对所有标记的对象进行回收；（要去补一下了）<br>2. 假设是一个m行n列的数组<br>那么a[i][j]_address = base_address + i * n * data_type_size + j * data_type_size<br>i * n * data_type_size表示每行开头的元素的内存地址，加上j * data_type_size就是i行j列元素的内存地址<br>","like_count":0},{"had_liked":false,"id":140730,"user_name":"Geek_5ed595","can_delete":false,"product_type":"c1","uid":1599346,"ip_address":"","ucode":"821454637335F8","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/7BnNphSkVlmswEmuv0laclvyDGIsMsrZOqPXJxvrazs4PLbrnM6jNxPVj0SGrJBv6HBfBWEVYicLOGWoXYv58aw/132","comment_is_top":false,"comment_ctime":1571039363,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571039363","product_id":100017301,"comment_content":"go语言 _5_array中的Insert函数<br>其中一个判断条件是<br>if index != this.length &amp;&amp; this.isIndexOutOfRange(index)，这样写的用意是什么？有什么好处？是不是意味着在数组申请的空间中可以任意插入数据？<br>为什么不这样写 if  this.isIndexOutOfRange(index) || index &gt; this.length","like_count":0},{"had_liked":false,"id":140200,"user_name":"mkii","can_delete":false,"product_type":"c1","uid":1674466,"ip_address":"","ucode":"534914EC7EA304","user_header":"https://static001.geekbang.org/account/avatar/00/19/8c/e2/48f4e4fa.jpg","comment_is_top":false,"comment_ctime":1570848498,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570848498","product_id":100017301,"comment_content":"标记清除算法：如果对象不存在与gcroot联通的路劲，则这些对象会被标记，然后在发生gc的时候被回收。<br>标记清除会导致内存碎片化，可应用在新生代垃圾回收器中，因为新生代的对象存活时间短，频繁被回收。<br>一个对象至少会经过两次标记才会真正被回收，可以调用finalized方法逃离回收。","like_count":0},{"had_liked":false,"id":140056,"user_name":"為之一","can_delete":false,"product_type":"c1","uid":1674350,"ip_address":"","ucode":"20F89A8B9810D1","user_header":"https://static001.geekbang.org/account/avatar/00/19/8c/6e/8ecea194.jpg","comment_is_top":false,"comment_ctime":1570798028,"is_pvip":false,"replies":[{"id":"54156","content":"可以这么理解","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1570831673,"ip_address":"","comment_id":140056,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1570798028","product_id":100017301,"comment_content":"是不是可以理解为：访问数组元素的本质就等价于访问一段地址空间。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470223,"discussion_content":"可以这么理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570831673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139086,"user_name":"Geek_949cc1","can_delete":false,"product_type":"c1","uid":1690476,"ip_address":"","ucode":"F8ACDBF2FA8CC2","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKFRiaFrpOTVBuKicMficasBFuF2VY7EnUnLeFcvIn0R5OiaQsOcpJHNM5TusoPHMjIvSfia46c0EWH9mQ/132","comment_is_top":false,"comment_ctime":1570543137,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570543137","product_id":100017301,"comment_content":"数组：<br>1：讲解数组的优势与劣势，优势是支持随机访问，时间复杂度为O(1)，但是对于插入，删除操作就相对于复杂，时间复杂度一般会是O(n),但是对于插入来说，对于不需要排序，就不需要对数组元素进行移位，直接把指定位置的元素移到后面就可以，对于删除操作也可以通过JVM思想进行优化。<br>2：可以从性能上考虑，通过对数组地址的计算公式的分析，得到为什么很多的数组下标是从0开始的。<br>3：要注意数组访问越界的情况。<br>二维数组的地址计算公式：<br>实际上的二维数组内存分配和一维数组是一样的，地址都是连续的，对于一个int array[m][n]其实就是由m*n个sizeof(int)组成，所以地址公式为：address=base_address+(i*n+j)*sizeof(int) 0&lt;=i&lt;m,0&lt;=j&lt;n;","like_count":0},{"had_liked":false,"id":138815,"user_name":"fire","can_delete":false,"product_type":"c1","uid":1374905,"ip_address":"","ucode":"24032D33930F7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/fa/b9/d75647dc.jpg","comment_is_top":false,"comment_ctime":1570459634,"is_pvip":false,"replies":[{"id":"53619","content":"第i个元素插入到第i个位置怎么理解呢？我如果想把数据a插入到第i个位置，但第i个位置已经有数据占用了，这个时候就有可能要移动一下数据了。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1570582172,"ip_address":"","comment_id":138815,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1570459634","product_id":100017301,"comment_content":"关于数组插入时需要移动数据我有点不太明白。我的理解是，当数组创建并初始化好后，系统已经分配好了所有的内存，由于数组中每个元素是相同类型，所以每个元素占用的空间是相同的，因此每个元素的内存地址也能知道，那么在插入时，把第i个元素插入第i个元素对应的内存地址不就好了，为什么需要移动呢？我可能对一些知识还不太了解，望解答。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469658,"discussion_content":"第i个元素插入到第i个位置怎么理解呢？我如果想把数据a插入到第i个位置，但第i个位置已经有数据占用了，这个时候就有可能要移动一下数据了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570582172,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138740,"user_name":"范建海","can_delete":false,"product_type":"c1","uid":1690581,"ip_address":"","ucode":"7296B019816FE1","user_header":"https://static001.geekbang.org/account/avatar/00/19/cb/d5/f1340355.jpg","comment_is_top":false,"comment_ctime":1570436601,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570436601","product_id":100017301,"comment_content":"# 1. 数组的定义<br>- 数组Array是一种 **线性表** 数据结构。 它用一组 **连续的内存空间**，来存储一组具有 **相同类型的数据**。 数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。<br><br># 2. 低效的“插入”和“删除”<br>- 假设数组的长度为n, 讲一个数据插入到数组的第k个位置<br>    - 最优时间复杂度 O(1)<br>    - 最坏时间复杂度 O(n)<br>    - 平均时间复杂度 O(n)<br>    <br>- 如果数组中存储的数据没有任何规律， 可以把要插入位置的元素和最后一个（指定位置）元素互换，时间复杂度为O(1)<br><br>- 数组的删除和插入类似， 最后时间复杂度为O(1), 最坏时间复杂度为O(n), 平均时间复杂度为O(n)<br><br>- JVM 标记清除垃圾回收算法的核心思想<br>    - 大多数主流虚拟机采用可达性分析算法来判断对象是否存活，在标记阶段，会遍历所有 GC ROOTS，将所有 GC ROOTS 可达的对象标记为存活。只有当标记工作完成后，清理工作才会开始。<br><br>    - 不足：1.效率问题。标记和清理效率都不高，但是当知道只有少量垃圾产生时会很高效。2.空间问题。会产生不连续的内存空间碎片。<br><br><br># 3. 警惕数组访问越界问题<br># 4. 用数组什么情况更合适<br>- Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，如果特别关注性能，或者希望使用基本类型，就可以选用数组<br>- 如果数据大小事先已知， 并且对数据的操作非常简单， 用不到ArrayList提供的大部分方法， 也可以直接使用数组<br>- 当要表示多维数组时，用数组往往会更加直观<br><br># 5. 二维数组内存寻址：<br>- 对于 m * n 的数组，a [ i ][ j ] (i &lt; m,j &lt; n)的地址为：address = base_address + ( i * n + j) * type_size<br>```<br>int main(int argc, char* argv[]){<br>    int i = 0;<br>    int arr[3] = {0};<br>    for(; i&lt;=3; i++){<br>        arr[i] = 0;<br>        printf(&quot;hello world\\n&quot;);<br>    }<br>    return 0;<br>}<br><br><br>对于死循环那个问题，要了解栈这个东西。栈是向下增长的，首先压栈的i，a[2]，a[1]，a[0]，这是我在我vc上调试查看汇编的时候看到的压栈顺序。相当于访问a[3]的时候，是在访问i变量，而此时i变量的地址是数组当前进程的，所以进行修改的时候，操作系统并不会终止进程。<br>```","like_count":0},{"had_liked":false,"id":138711,"user_name":"Chris","can_delete":false,"product_type":"c1","uid":1689346,"ip_address":"","ucode":"50A51AE2110A7A","user_header":"https://static001.geekbang.org/account/avatar/00/19/c7/02/8346ebf6.jpg","comment_is_top":false,"comment_ctime":1570428903,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570428903","product_id":100017301,"comment_content":"数组长度为n的插入操作，可以插入数据的位置实际上是n+1个，所以 可能应该是(1+2+…n + （n+1）)&#47;n=O(n)","like_count":0},{"had_liked":false,"id":138615,"user_name":"Hill","can_delete":false,"product_type":"c1","uid":1270705,"ip_address":"","ucode":"EFE232938B170B","user_header":"https://static001.geekbang.org/account/avatar/00/13/63/b1/133a6e21.jpg","comment_is_top":false,"comment_ctime":1570369849,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570369849","product_id":100017301,"comment_content":"从0开始计数是人类从远古时代就流传下来的，最典型的就是用来计算猎物的个数","like_count":0},{"had_liked":false,"id":138421,"user_name":"stonyjerry","can_delete":false,"product_type":"c1","uid":1686515,"ip_address":"","ucode":"DD1C0C7C619E0B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJEWMeroibyjVVcXlf81C7WicDAfUv01jVnwDUooHk5zDU51zbLPsYnAAa2icz1ySSQab2bxQqzD5xEg/132","comment_is_top":false,"comment_ctime":1570230310,"is_pvip":false,"replies":[{"id":"53623","content":"删除第一个元素需要搬移数据吧，不然会有数据空洞呀","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1570582398,"ip_address":"","comment_id":138421,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1570230310","product_id":100017301,"comment_content":"Array 里面删除开头元素的为啥是O(n)呢？只要保证内存的连续性，那么删除第一个和删除最后一个复杂度不应该一样么？都不用别的地方挪动，也没有空洞。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469517,"discussion_content":"删除第一个元素需要搬移数据吧，不然会有数据空洞呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570582398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138263,"user_name":"蔡泽华","can_delete":false,"product_type":"c1","uid":1462654,"ip_address":"","ucode":"E3B83391DDB04F","user_header":"https://static001.geekbang.org/account/avatar/00/16/51/7e/54353af6.jpg","comment_is_top":false,"comment_ctime":1570126977,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1570126977","product_id":100017301,"comment_content":"二维数组的寻址公式<br>a[i][j]_address =  a[i]_base_address + j * data_type_size<br>                      =  base_address + i*n*data_type_size + j * data_type_size","like_count":0},{"had_liked":false,"id":138047,"user_name":"Lance","can_delete":false,"product_type":"c1","uid":1686840,"ip_address":"","ucode":"CCE52F86EEBBED","user_header":"https://static001.geekbang.org/account/avatar/00/19/bd/38/6d436088.jpg","comment_is_top":false,"comment_ctime":1569997151,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569997151","product_id":100017301,"comment_content":"笔记：<br>ArrayList相比数组最大的优势是可以将很多数组操作的细节封装起来，并且支持动态扩容，当存储空间不够的时候，它会将空间自动扩容为1.5倍大小。事先指定ArrayList数据大小可以省掉很多次内存申请和数据搬移操作带来的耗时问题。<br><br>数据从0开始编号而不是从1开始编号的原因是在随机访问数组元素时可以减少一次减法运算<br>0：a[k]_addr = base_address + k*type_size<br>1：a[k]_addr = base_address + (k-1)*type_size<br><br>在平时业务开发时，可以直接使用编程语言提供的容器类，而如果是特别底层的开发，用数组可以提高性能。","like_count":0},{"had_liked":false,"id":138046,"user_name":"Lance","can_delete":false,"product_type":"c1","uid":1686840,"ip_address":"","ucode":"CCE52F86EEBBED","user_header":"https://static001.geekbang.org/account/avatar/00/19/bd/38/6d436088.jpg","comment_is_top":false,"comment_ctime":1569996940,"is_pvip":false,"replies":[{"id":"53769","content":"你再仔细看看，这个问题不复杂","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1570661167,"ip_address":"","comment_id":138046,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569996940","product_id":100017301,"comment_content":"关于删除操作有点疑问，假设最底层的逻辑是每次只能删除1个元素接着进行数据搬移，那么连续删除3个元素则需要进行3次搬移，可延迟删除意义在哪呢？好像有点想弯了，望解答！","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469363,"discussion_content":"你再仔细看看，这个问题不复杂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570661167,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137004,"user_name":"薀渘の說脕鮟","can_delete":false,"product_type":"c1","uid":1257600,"ip_address":"","ucode":"6E1978D1002392","user_header":"https://static001.geekbang.org/account/avatar/00/13/30/80/4541f805.jpg","comment_is_top":false,"comment_ctime":1569574203,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569574203","product_id":100017301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":136912,"user_name":"随风","can_delete":false,"product_type":"c1","uid":1250040,"ip_address":"","ucode":"2883C362D6C2B4","user_header":"https://static001.geekbang.org/account/avatar/00/13/12/f8/888a9b9d.jpg","comment_is_top":false,"comment_ctime":1569552149,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569552149","product_id":100017301,"comment_content":"之前看了专栏一段时间，基本看了大概70%的内容。断了一段时间没看，发现好多都忘了，于是打算再来一遍。<br>关于JVM回收算法，有三种算法：复制算法、标记清除算法、标记整理法。<br>复制算法是将内存分为两块大小一样空间，一块空闲面，一块为对象面，对象面的空间用于程序分配空间。发生GC时，将对象面中不能被回收的对象复制到空闲面，之后清除对象面的所有对象。此时的对象面就转为空闲面，空闲面转为对象面。<br>标记算法是GC时，直接标记可以被回收的对象，之后进行清除，这种算法有个缺点，就是容易造成碎片。<br>标记整理发，是将不可以回收的对象标记起来，之后将对象复制整理到内存的开头连续空间，之后清除剩余空间的所有对象。<br>目前的JVM实现基本会将内存分为“年轻代”、“老年代”，年轻代中每次回收都只有少量对象存活，适用“复制算法”。老年代存活率高、适用标记整理算法。","like_count":0},{"had_liked":false,"id":136424,"user_name":"陈 | 先 | 生 |","can_delete":false,"product_type":"c1","uid":1016647,"ip_address":"","ucode":"F2866A71A360F5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/83/47/33648a00.jpg","comment_is_top":false,"comment_ctime":1569429338,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569429338","product_id":100017301,"comment_content":"Q1：python的垃圾回收机制<br><br>A：1. 引用计数机制；2. 标记清除机制；3. 分代回收机制<br><br>Q2：二位数组的内存地址计算<br><br>A2：`a[i][j]`的地址是`p+(i*col+j)*d`<br><br>传送门：[二维数组中数组元素存储地址的计算一问](https:&#47;&#47;blog.csdn.net&#47;sxhelijian&#47;article&#47;details&#47;86710755)<br><br>![](https:&#47;&#47;img-blog.csdnimg.cn&#47;20190131082513554.JPG?x-oss-process=image&#47;watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N4aGVsaWppYW4=,size_16,color_FFFFFF,t_70)","like_count":0},{"had_liked":false,"id":134299,"user_name":"橘右京","can_delete":false,"product_type":"c1","uid":1584155,"ip_address":"","ucode":"48B5C1BC699284","user_header":"https://static001.geekbang.org/account/avatar/00/18/2c/1b/4a62af85.jpg","comment_is_top":false,"comment_ctime":1568798227,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568798227","product_id":100017301,"comment_content":"a[m][n]=base_addr+(m*col_length+n)*size","like_count":0},{"had_liked":false,"id":134020,"user_name":"王加武","can_delete":false,"product_type":"c1","uid":1665471,"ip_address":"","ucode":"DDCFE578C6C428","user_header":"https://static001.geekbang.org/account/avatar/00/19/69/bf/50a824a4.jpg","comment_is_top":false,"comment_ctime":1568721969,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568721969","product_id":100017301,"comment_content":"JVM垃圾回收机制的核心就在于当某个数据不再被使用，JVM会自动的去判断这个数据是还活着，活着，先不动你，死了，就把它收了！<br>二维数组的寻址公式：<br>adress = 首地址 + 数据类型大小 * （定义的行的长度 * I + J）<br>I 和J 为数组的下标","like_count":0},{"had_liked":false,"id":133518,"user_name":"云师兄","can_delete":false,"product_type":"c1","uid":1010459,"ip_address":"","ucode":"4475AF1598FBFD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/1b/4b397b80.jpg","comment_is_top":false,"comment_ctime":1568596661,"is_pvip":false,"replies":[{"id":"51417","content":"说得在理，不过我就是为了展示一个小处理技巧，别太较真哈：）","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1568760973,"ip_address":"","comment_id":133518,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568596661","product_id":100017301,"comment_content":"将 c 放入到 a[5]，将 a[2] 赋值为 x，这样c的位置变了，应该会影响到取值。如果逻辑运算跟位置无关，又何必非要插入到下标为2？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467411,"discussion_content":"说得在理，不过我就是为了展示一个小处理技巧，别太较真哈：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568760973,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133071,"user_name":"花落菩提","can_delete":false,"product_type":"c1","uid":1019958,"ip_address":"","ucode":"B297448E82DEFC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ9oglNbMCiauibXTw8KbpxhSEboDMdbRyHN1fK3EEj19KbQRlvj8GXqw5g9r2MibPlmlzqqGBXSsteA/132","comment_is_top":false,"comment_ctime":1568345721,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1568345721","product_id":100017301,"comment_content":"1、JVM的标记垃圾回收算法：java对象有一个引用计数的字段，当被引用时，该字段加1，不被引用时，该字段减1，垃圾回收程序会定期扫描内存中各个对象该字段的值，把引用值为0的对象统一删除。<br>2、二维数组的内存寻址公式：<br>假设二维数组大小为m x n<br>a[i][j]_address = base_address +（ i *  n + j）* data_type_size<br>例如有一个大小为 8行 x 5列的二维数组<br>a[2][4]_address = base_address +（ 2 *  5 + 4）* data_type_size<br><br>","like_count":0},{"had_liked":false,"id":132873,"user_name":"David","can_delete":false,"product_type":"c1","uid":1023472,"ip_address":"","ucode":"1C76747719CD3B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9d/f0/6c34b90f.jpg","comment_is_top":false,"comment_ctime":1568256634,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568256634","product_id":100017301,"comment_content":"1.通过根搜索算法找到标记被引用的对象，清理未被引用的对象。<br>2.a[j][k]_address = base_address + (j * k_size + k) * type_size","like_count":0},{"had_liked":false,"id":132844,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1568250745,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568250745","product_id":100017301,"comment_content":"对于C语言那段代码，无限循环不理解，i不是先定义放到了内存中吗，为什么越界到i上了呢？难道是分配完大小，重后往前存储？？","like_count":0},{"had_liked":false,"id":131344,"user_name":"胡永","can_delete":false,"product_type":"c1","uid":1200543,"ip_address":"","ucode":"6C8BA1E0BED9C0","user_header":"https://static001.geekbang.org/account/avatar/00/12/51/9f/1840385e.jpg","comment_is_top":false,"comment_ctime":1567728568,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567728568","product_id":100017301,"comment_content":"a[m][k]_address <br>base_address_k = a[m]_address = base_address + m*type_size;<br>a[m][k]_address = base_address_k + k*type_size;<br>ArrayList好像和前两天看的go语言里面的container概念很类似，不过扩大1.5倍到了一定的数值会倍数发生变化","like_count":0},{"had_liked":false,"id":129704,"user_name":"林肯","can_delete":false,"product_type":"c1","uid":1008582,"ip_address":"","ucode":"D2C97220230DE5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/c6/d6ea3df3.jpg","comment_is_top":false,"comment_ctime":1567222964,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567222964","product_id":100017301,"comment_content":"除了类似java 标记清理机制，和mysql的删除操作也是类似的，mysql删除一条数据时并不会释放空间，而是先做标记，如果新增了数据在条件合适的情况下会直接使用这个标记删除的空间，","like_count":0},{"had_liked":false,"id":127757,"user_name":"wrzgeek","can_delete":false,"product_type":"c1","uid":1031589,"ip_address":"","ucode":"69C4980053E388","user_header":"","comment_is_top":false,"comment_ctime":1566788598,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566788598","product_id":100017301,"comment_content":"笔记：<br>1. 数组可以随机读取数据，但是在保持原有数据顺序的前提下插入&#47;删除效率不高O（n）<br>2.提高删除效率的一个优化点，对于删除的操作，只是标记下被删除数据的下标，当数组空间被用完时，再统一对已标记的数据进行删除<br>思考：<br>1.JVM标记清除算法(垃圾回收)：先标记被清除的对象，当标记完成之后再统一回收标记的对象。<br> 2个不足：(1)标记清除效率都不高（2）标记清除之后会产生大量不连续的碎片，当大对象分配不到连续内存时，会提前触发GC<br>2.假如二维数组大小a[m][n]，a[i][j] = base_addr + n*i*size + j*size = base_addr + (n*i+j)*size;","like_count":0},{"had_liked":false,"id":127204,"user_name":"Jacen","can_delete":false,"product_type":"c1","uid":1378332,"ip_address":"","ucode":"A1EC8D8FE11230","user_header":"https://static001.geekbang.org/account/avatar/00/15/08/1c/ab50923c.jpg","comment_is_top":false,"comment_ctime":1566610935,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566610935","product_id":100017301,"comment_content":"1、jvm采用分代垃圾手机算法，其中新生代的Eden和Survivor区就采用文中提到的“标记-整理清除算法”。<br>通过可达性分析，标记存活，eden区满的时候，将eden区和S0存活的对象复制和整理到另外S1区，形成一段连续的内存地址。<br>2、二位数组的寻址应该是：base_address + (k * n + j) * type_size 吧","like_count":0},{"had_liked":false,"id":126991,"user_name":"不动声色满心澎湃","can_delete":false,"product_type":"c1","uid":1621658,"ip_address":"","ucode":"80D8F9E49AF7C2","user_header":"https://static001.geekbang.org/account/avatar/00/18/be/9a/b0b89be3.jpg","comment_is_top":false,"comment_ctime":1566531107,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566531107","product_id":100017301,"comment_content":"C语言的那个越界并不一定回产生死循环。得具体看内存是怎么储存的。但是结果肯定是未决的","like_count":0},{"had_liked":false,"id":126982,"user_name":"梁小松","can_delete":false,"product_type":"c1","uid":1628255,"ip_address":"","ucode":"AE8B71206E207A","user_header":"https://static001.geekbang.org/account/avatar/00/18/d8/5f/312497f1.jpg","comment_is_top":false,"comment_ctime":1566530511,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566530511","product_id":100017301,"comment_content":"二位数组寻址：<br>对于 m * n 的数组，a[i][j] (i &lt; m,j &lt; n)的地址为：<br>address = base_address + (i * n + j) * type_size<br>解析：二维数组中子数组的length = n，基于数组内存是连续的，所以 n * i表示的是二维数组中的第 i 子数组： a[i] = base_address + i * n * type_size 的首地址<br>所以 a[i][j] =  base_address + i * n * type_size + j * type_size = base_address + (i * n + j) * type_size","like_count":0},{"had_liked":false,"id":126197,"user_name":"林林","can_delete":false,"product_type":"c1","uid":1613227,"ip_address":"","ucode":"7B6318B971E430","user_header":"https://static001.geekbang.org/account/avatar/00/18/9d/ab/6589d91a.jpg","comment_is_top":false,"comment_ctime":1566348564,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566348564","product_id":100017301,"comment_content":"a[i][j]_addr = a[i]_addr + j*typesize = a_addr + i*typesize + j*typesize    是这样吗？","like_count":0},{"had_liked":false,"id":125145,"user_name":"贺佳贝","can_delete":false,"product_type":"c1","uid":1524331,"ip_address":"","ucode":"0FA1347292252F","user_header":"https://static001.geekbang.org/account/avatar/00/17/42/6b/2779e5a9.jpg","comment_is_top":false,"comment_ctime":1566098789,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566098789","product_id":100017301,"comment_content":"二维数组n行m列的内存寻址公式： A [i][j] = base_address + j * type_size + i * type_size  * m ","like_count":0},{"had_liked":false,"id":123048,"user_name":"码上Java","can_delete":false,"product_type":"c1","uid":1295726,"ip_address":"","ucode":"C616EC77DE6695","user_header":"https://static001.geekbang.org/account/avatar/00/13/c5/6e/82ef354b.jpg","comment_is_top":false,"comment_ctime":1565597419,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565597419","product_id":100017301,"comment_content":"为什么数组要从0开始编号，而不是从1开始呢？<br>     数组是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。<br>\t      1.线性表，顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。<br>\t\t  2.非线性表，在非线性表中，数据之间并不是简单的前后关系。如二叉树、堆、图等。<br>\t\t  3.数据是连续的内存空间和相同类型的数据。<br>     数组是如何实现根据下标随机访问数组元素？<br>\t     首先我们知道，计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过的寻址方式<br>\t\t  （a[i]_address = base_address + i * data_type_size） ，计算出该元素存储的内存地址。其中data_type_size表示数组中每个元素的大小。","like_count":0},{"had_liked":false,"id":122488,"user_name":"冰风落叶","can_delete":false,"product_type":"c1","uid":1128059,"ip_address":"","ucode":"E4DE480B95A17D","user_header":"https://static001.geekbang.org/account/avatar/00/11/36/7b/3788ca13.jpg","comment_is_top":false,"comment_ctime":1565406386,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565406386","product_id":100017301,"comment_content":"知识点总结：<br>1.线性表是一个数据排成像一条线一样的结构，线性表上的数据最多只有前后两个方向，数组、链表、队列、栈都是线性表结构；<br>2.非线性表，数据之间并不是简单的前后关系，例如：二叉树、堆、图等等；<br>3.数组是线性表结构，具有连续的内存空间，支持随机访问，通过下标随机访问的时间复杂度是O(1)，用二分法查找某个元素的时间复杂度是O(logn)；<br>4.数组根据下标查找是高效的，而数组的插入和删除是低效的，因为是连续的内存空间，插入和删除的平均时间复杂度是O(n)，所以比较低效;<br>5.优化数组插入和删除的低效，可以通过标记删除法，先对删除的元素做标记，并不做真正的删除操作，等到数组空间满了之后，再做一次性的删除操作，避免多次删除时多次搬运数据的重复过程，这也正是JVM标记清除垃圾回收算法的核心；<br>6.数组下标从0开始，主要还是效仿C语言的历史原因，从效率层面看的话，如果下标从1开始，每次通过下标访问数组元素，都会多一次减法运算，也就是多了一次减法指令，由于对效率的极致追求，从0开始比较好：<br>下标从0开始，a[k]的内存地址为：a[k]_address = base_address + k * type_size<br>下标从1开始，a[k]的内存地址为：a[k]_address = base_address + (k-1) * type_size<br><br>关于二维数组内存寻址问题：<br>对于m*n二维数组，a[i][j](i&lt;m,j&lt;n)的地址为：<br>1.当二维数组的空间和一维数组的空间是连续的：a[i][j]_address = base_address + (i*n+j)*type_size<br>2.当二维数组的空间与一维数组的空间不连续，也就是a[i]中存放a[j]的基地址：a[i][j]_address = *(base_address + i*type_size) +  j*type_size<br><br>老师，二维数据的内存空间一定和一维数组的内存空间连续吗?","like_count":0},{"had_liked":false,"id":122389,"user_name":"刘学习来学习","can_delete":false,"product_type":"c1","uid":1464013,"ip_address":"","ucode":"5078B1EC8D8A66","user_header":"https://static001.geekbang.org/account/avatar/00/16/56/cd/0add8290.jpg","comment_is_top":false,"comment_ctime":1565354851,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565354851","product_id":100017301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":120439,"user_name":"Joiner","can_delete":false,"product_type":"c1","uid":1071941,"ip_address":"","ucode":"7F67D4C325E71F","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/45/5dc5437e.jpg","comment_is_top":false,"comment_ctime":1564895426,"is_pvip":false,"replies":[{"id":"44221","content":"https:&#47;&#47;github.com&#47;wangzheng0822","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1564959855,"ip_address":"","comment_id":120439,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1564895426","product_id":100017301,"comment_content":"老师，github上面怎么查看您写的代码？找不到啊，而且，notes下面只有一些文字，没有代码（递归前面的内容也没有）","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461334,"discussion_content":"https://github.com/wangzheng0822","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564959855,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1071941,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5b/45/5dc5437e.jpg","nickname":"Joiner","note":"","ucode":"7F67D4C325E71F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3911,"discussion_content":"这上面我看了，大部分都是您的merge的pull request，我想看您官方的代码😂，难道是我没找到？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564971795,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120185,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1564804501,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1564804501","product_id":100017301,"comment_content":"1.jvm标记清除也是对内存块清除，是在一次垃圾回收后清除标记没在用的块，然后整理下内存块，这个可以设置多少次垃圾回收后进行内存块整理","like_count":0},{"had_liked":false,"id":118474,"user_name":"Angus","can_delete":false,"product_type":"c1","uid":1377467,"ip_address":"","ucode":"7CC3BA1550FB5B","user_header":"https://static001.geekbang.org/account/avatar/00/15/04/bb/5e5c37c1.jpg","comment_is_top":false,"comment_ctime":1564371676,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564371676","product_id":100017301,"comment_content":"理解了真正数组的概念和意义，再查了下JavaScript中数组的概念，豁然开朗。也明白了数组和链表的定义与区别、优缺点。","like_count":0},{"had_liked":false,"id":117955,"user_name":"L.","can_delete":false,"product_type":"c1","uid":1543396,"ip_address":"","ucode":"9803C2EDC799DC","user_header":"https://static001.geekbang.org/account/avatar/00/17/8c/e4/ad3e7c39.jpg","comment_is_top":false,"comment_ctime":1564198559,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1564198559","product_id":100017301,"comment_content":"有一个点不太明白。在数组越界的例子中，为什么a[3]访问到的内存地址的存储内容是变量i呢？","like_count":0},{"had_liked":false,"id":117834,"user_name":"小明见万里","can_delete":false,"product_type":"c1","uid":1194363,"ip_address":"","ucode":"01ACB05816B406","user_header":"https://static001.geekbang.org/account/avatar/00/12/39/7b/9382a0e6.jpg","comment_is_top":false,"comment_ctime":1564144353,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564144353","product_id":100017301,"comment_content":"这个分享写的很清楚，推荐 https:&#47;&#47;blog.csdn.net&#47;u012796139&#47;article&#47;details&#47;46635567","like_count":0},{"had_liked":false,"id":117087,"user_name":"Hwan","can_delete":false,"product_type":"c1","uid":1205627,"ip_address":"","ucode":"A728C6790511BD","user_header":"https://static001.geekbang.org/account/avatar/00/12/65/7b/66b9befd.jpg","comment_is_top":false,"comment_ctime":1563965202,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563965202","product_id":100017301,"comment_content":"对于n*m二维数组，<br>二维数组    a[i][j] = base_address + (m * i + j) * type_size","like_count":0},{"had_liked":false,"id":114938,"user_name":"树上有只狼","can_delete":false,"product_type":"c1","uid":1135603,"ip_address":"","ucode":"8A99E203FD8E94","user_header":"https://static001.geekbang.org/account/avatar/00/11/53/f3/160885f7.jpg","comment_is_top":false,"comment_ctime":1563436453,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563436453","product_id":100017301,"comment_content":"标记-清扫算法，是垃圾回收算法中的始祖算法，之后的标记-整理、复制等算法都是基于此改进。其算法分为两个阶段：标记与清扫。在标记过程中通过可达性分析算法，对Roots进行向下遍历，被遍历到的对象实例会被标记起来，通过三色抽象的形式。最终，被标记的对象实例视为存活，反之其余对象实例则视为死亡。在清扫阶段，垃圾回收器会依次将未被标记的对象实例直接回收。到此整个回收阶段完成，该算法优点在于简单及快，缺点在于会产生内存碎片。<br><br>数组大小int[m][n]，m &gt;= i, n &gt;= j<br>寻找int[i][j]，则：base_address + (i * n + j) * type_size","like_count":0},{"had_liked":false,"id":114255,"user_name":"之城","can_delete":false,"product_type":"c1","uid":1252519,"ip_address":"","ucode":"12451253E366A2","user_header":"https://static001.geekbang.org/account/avatar/00/13/1c/a7/6a837523.jpg","comment_is_top":false,"comment_ctime":1563262152,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563262152","product_id":100017301,"comment_content":"随机访问这个词，有一定误导性。一开始以为要先产生一个随机数索引，然后进行访问。但好像实际意思就是“访问任意一个元素”的意思。。。","like_count":0},{"had_liked":false,"id":114150,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1563243366,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563243366","product_id":100017301,"comment_content":"线性表：数据之前只有前后关系（前驱和后继），如数组、链表、栈、队列等<br>非线性表：数据之间不是简单的前后关系，如树、图等<br>关于表述的严谨性：“数组在根据下标随机访问的时间复杂度为o(1)”的表述非常严谨，可见我们在谈论一个论点时精准把握其原因、假设和结论的重要性，让我想起了之前在《学会提问》中学习的如何推演一个论点的正确性和严谨性<br><br>为什么很多编程语言中数组都从0开始编号？<br>自我的想法：数组从0开始编号可能是为了地址计算时的性能，如果从1开始编号，那么a[k]的地址的计算则是base_address+(k-1)* size_type，而从0开始编号，a[k]的地址计算则是base_address+k* size_type，可以看到，会少一次减法运算。<br><br>从老师的提问中的启发：之前学习数组的时候，学校老师只是指出，C语言汇总数组是从0开始编号的，大家记住就好了，加上自己缺乏思辨的能力，总是跟着“权威”走，以至于缺少了程序员的最核心的一点要求：好奇心。我们学习的过程最重要的是自我思考的过程，当然也需要有输出反馈输入的过程，但自我思考始终是第一步。很多问题是很难找到统一的标准答案的，我们能做的不过是让自我的思维保持严谨地得出思考的结论，再以输出反馈输入。<br><br>标记-删除的算法：除了在JVM中有运用，在LSMTree中也有类似的思想，删除并非是真的删除元素，而是记录一个tombstone标记，在“合适的时机”统一执行删除算法。“合适的时机”根据不同的场景会有不同的设定，比如说JVM会在标记工作完成后，其他还有内存不足时、主动API调用时，CPU空闲时等等。<br>二维数组的寻址公式：目前大多数语言的实现中数组二维数组应该是行存储的（FORTRAN语言中是按列存储的），基于这个前提下，对于二维数组a[m][n],a[k][j] = base_address+k* n* size_type + j * size_type","like_count":0},{"had_liked":false,"id":114126,"user_name":"阿飞","can_delete":false,"product_type":"c1","uid":1200043,"ip_address":"","ucode":"1F239F9896F74B","user_header":"https://static001.geekbang.org/account/avatar/00/12/4f/ab/e1a024dd.jpg","comment_is_top":false,"comment_ctime":1563240201,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563240201","product_id":100017301,"comment_content":"您好，我想请问你说的那个数组越界的那里例子，应该是输出4次字符串hello world ，然后程序会退出而不是无限输出hello world","like_count":0},{"had_liked":false,"id":114090,"user_name":"|G. XIAO|","can_delete":false,"product_type":"c1","uid":1168127,"ip_address":"","ucode":"75DA0B3047A2F0","user_header":"https://static001.geekbang.org/account/avatar/00/11/d2/ff/99d2e7f5.jpg","comment_is_top":false,"comment_ctime":1563237707,"is_pvip":false,"replies":[{"id":"42195","content":"直接使用数组，更灵活、性能会更好点。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1563573756,"ip_address":"","comment_id":114090,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563237707","product_id":100017301,"comment_content":"在平时的业务开发中，我们可以直接使用编程语言提供的容器类，但是，如果是特别底层的开发，直接使用数组可能会更合适。<br><br>这个不太理解","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458511,"discussion_content":"直接使用数组，更灵活、性能会更好点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563573756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":113364,"user_name":"huanyehappy","can_delete":false,"product_type":"c1","uid":1603969,"ip_address":"","ucode":"0A5372104B7EBE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLiaWKn5ibqO92ic7tzWrXEoZUuduaoRIiaf2icT7E1ia9ViaE2U8Tas9IgFhkpFXicKUHTdqVUPmHauS7XRg/132","comment_is_top":false,"comment_ctime":1562984545,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562984545","product_id":100017301,"comment_content":"收获：<br>1. 了解了数组的特点，随机访问，插入删除复杂性高O（n）<br>2. 数组的寻址公式<br>","like_count":0},{"had_liked":false,"id":113362,"user_name":"huanyehappy","can_delete":false,"product_type":"c1","uid":1603969,"ip_address":"","ucode":"0A5372104B7EBE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLiaWKn5ibqO92ic7tzWrXEoZUuduaoRIiaf2icT7E1ia9ViaE2U8Tas9IgFhkpFXicKUHTdqVUPmHauS7XRg/132","comment_is_top":false,"comment_ctime":1562984302,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562984302","product_id":100017301,"comment_content":"m*n<br>int[x][y]<br>base + (x*n + y)*type_size","like_count":0},{"had_liked":false,"id":113198,"user_name":"Leo","can_delete":false,"product_type":"c1","uid":1217896,"ip_address":"","ucode":"947C5785A7EDF1","user_header":"https://static001.geekbang.org/account/avatar/00/12/95/68/41546e8a.jpg","comment_is_top":false,"comment_ctime":1562912929,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562912929","product_id":100017301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":113007,"user_name":"memdreams","can_delete":false,"product_type":"c1","uid":1599165,"ip_address":"","ucode":"0AE081B72CF0C0","user_header":"","comment_is_top":false,"comment_ctime":1562876100,"is_pvip":false,"replies":[{"id":"41567","content":"不报错，自动扩容的。需要申请新的空间和copy原始数据到新的空间。<br>你可以看下github上的实现代码<br>https:&#47;&#47;github.com&#47;wangzheng0822&#47;algo","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1563232773,"ip_address":"","comment_id":113007,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562876100","product_id":100017301,"comment_content":"动态扩容意思是事先不给定数组长度吗？还是说给定a[n]，但是在使用的时候，如果需要a[n+1]， 则自动扩容而不是报错？也不需要再重新定义一个新的a[n+n]大小的数组？<br>期待您的回复。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458010,"discussion_content":"不报错，自动扩容的。需要申请新的空间和copy原始数据到新的空间。\n你可以看下github上的实现代码\nhttps://github.com/wangzheng0822/algo","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563232773,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":113000,"user_name":"Alex","can_delete":false,"product_type":"c1","uid":1079331,"ip_address":"","ucode":"93F2D5B7DAF97F","user_header":"https://static001.geekbang.org/account/avatar/00/10/78/23/42233378.jpg","comment_is_top":false,"comment_ctime":1562863827,"is_pvip":false,"replies":[{"id":"41290","content":"可以定义一个包含x y的类，用一维数组存储类对象","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1562977397,"ip_address":"","comment_id":113000,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562863827","product_id":100017301,"comment_content":"我只做过用二维数组来标示方格类游戏的xy坐标，要表示xy这类的结构除了二维数组还有其他的数据结构可以表示吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458007,"discussion_content":"可以定义一个包含x y的类，用一维数组存储类对象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562977397,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":111399,"user_name":"Hxd","can_delete":false,"product_type":"c1","uid":1357303,"ip_address":"","ucode":"B8B04AA5738CC9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKg3ia2DDFuGLZRtHw6to43icxKyia1eHbxTUh1CY1dSuTp5WmQN01A1aLAia1lkaR8EAkXD4h76n8Bog/132","comment_is_top":false,"comment_ctime":1562551860,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562551860","product_id":100017301,"comment_content":"垃圾回收算法：<br>1.标记清除算法<br>2.标记整理算法<br>3.复制算法<br>对象是否存活判断方法：<br>1.可达性分析（GC root）<br>2.引用计数算法<br>hostspot主流垃圾回收器:<br>1.CMS<br>2.G1","like_count":0},{"had_liked":false,"id":111112,"user_name":"追逐繁星的孩纸~","can_delete":false,"product_type":"c1","uid":1593884,"ip_address":"","ucode":"69DC37A9E39C7E","user_header":"https://static001.geekbang.org/account/avatar/00/18/52/1c/e902de0f.jpg","comment_is_top":false,"comment_ctime":1562478125,"is_pvip":true,"discussion_count":0,"race_medal":4,"score":"1562478125","product_id":100017301,"comment_content":"2.m*n的二维数组中：<br>a[i][k]_address = base_address + (i*n+k) * type_size","like_count":0},{"had_liked":false,"id":110841,"user_name":"SMTCode","can_delete":false,"product_type":"c1","uid":1109038,"ip_address":"","ucode":"0D837A753E4FAB","user_header":"https://static001.geekbang.org/account/avatar/00/10/ec/2e/49d13bd2.jpg","comment_is_top":false,"comment_ctime":1562373026,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1562373026","product_id":100017301,"comment_content":"X86_64平台数组越界，循环打印hello world可以这么来玩：<br>#include &lt;stdio.h&gt;<br>int main(){<br>    int i =0; <br>    int a[3]={0};<br>    for (i=2; i&gt;=-1; i--){<br>        a[i]=2;<br>        printf(&quot;hello world %d\\n&quot;,i);    <br>    }    <br>    return 0;<br>}<br>","like_count":0},{"had_liked":false,"id":110203,"user_name":"无名道长","can_delete":false,"product_type":"c1","uid":1387960,"ip_address":"","ucode":"0F694D17459CC0","user_header":"https://static001.geekbang.org/account/avatar/00/15/2d/b8/7e49a241.jpg","comment_is_top":false,"comment_ctime":1562207315,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562207315","product_id":100017301,"comment_content":"在学习过程中,从类比或隐喻来学习是一个非常好的学习方法,但当学习完之后,还是只能用类比和隐喻来解释.和较高层次的人交流的时候不能说明原理或者细节,这个学习就失败了!!","like_count":0},{"had_liked":false,"id":109463,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1562037085,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562037085","product_id":100017301,"comment_content":"数组的本质就是相同大小的连续存储，因而可用偏移量来随机定位大块中一个小块的位置<br>。这样使得查询比较高效(log n)。<br>数组可以在尾部单方向扩展和收缩。<br>如果逻辑上也要求各个小块有序，这里有序就成了影响整块的属性，为了维护这个属性，就要全局调整。如果没有全局属性，调整局部还是很高效的，可以通过调整尾部实现。","like_count":0},{"had_liked":false,"id":109460,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1562036608,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562036608","product_id":100017301,"comment_content":"二维数组的内存寻址是开头和两个偏移量，第一个偏移量乘以地址的大小找到一个一维数组的起始位置，下面一步就和一维数组一样了。","like_count":0},{"had_liked":false,"id":109334,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1562017627,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562017627","product_id":100017301,"comment_content":"我没记错的话，JVM的垃圾回收是对堆变量做引用计数，当引用计数为0的时候就标记为可以清除，在必要的时候就垃圾回收。引用计数的数值是通过代码自身模块结构形成的有向无环图做标记的。","like_count":0},{"had_liked":false,"id":108760,"user_name":"®","can_delete":false,"product_type":"c1","uid":1269358,"ip_address":"","ucode":"FDC00DC0162C8D","user_header":"https://static001.geekbang.org/account/avatar/00/13/5e/6e/fbeb942a.jpg","comment_is_top":false,"comment_ctime":1561876554,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561876554","product_id":100017301,"comment_content":"1. c程序。作者那个是不行的！必须是这样。&#47;*****************************************<br> *   Copyright (C) 2019 All rights reserved.<br> *   File：arrIndex.c<br> *   Auth：LiuLang<br> *   Mail：datuhao@foxmail.com<br> *   Date：2019-06-30 14:09<br> *   Desc：<br> *****************************************&#47;<br><br>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;unistd.h&gt;<br><br>int arr[3] = {0};<br>int i=0;<br><br>int main()<br>{<br>\tprintf(&quot;arr:%p\\n&quot;, &amp;arr);<br>\tprintf(&quot;i:%p\\n&quot;, &amp;i);<br><br>\tfor(; i&lt;=3; i++)<br>\t{<br>\t\tarr[i] = 0;<br>\t\tprintf(&quot;arr[%d]:%p\\n&quot;,i, &amp;arr[i]);<br>\t\tprintf(&quot;hello world!, %d\\n&quot;, i);<br>\t\tsleep(1);<br>\t}<br><br>\treturn 0;<br>}<br><br>2. c语言其实支持数组index为负，作者可以尝试一下。","like_count":0},{"had_liked":false,"id":108741,"user_name":"少盐","can_delete":false,"product_type":"c1","uid":1305743,"ip_address":"","ucode":"BCC7E264B75702","user_header":"https://static001.geekbang.org/account/avatar/00/13/ec/8f/8299495a.jpg","comment_is_top":false,"comment_ctime":1561870639,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561870639","product_id":100017301,"comment_content":"数组为线性串，在内存中存储连续，数据类型相同，根据下标可以随机访问，时间复杂度为O（1）<br>如果需要多次删除多个数组中的数据，可以把变更记录下来，回头进行一次操作，节省时间，类似于MySQL 中的relog ，也是把数据的变化记录到其中，在非忙碌时间持久化到磁盘，对Java只能看懂代码，对垃圾回收机理不清楚<br>关于数组下标起始于0，就是习惯和历史沿革问题，具体多一个少一个减法运算，无关宏旨<br>高级语言中的容器，可能是对数组的封装，以性能为代价换取到便利性<br>因为通过手机学习的，屏幕小而且切换很麻烦，不能边看原文边留言，看完就记住这些，不知道有没有落下<br>苹果手机不能同时运行多个程序，所以当前程序感觉特别流畅，安卓好像不是这样","like_count":0},{"had_liked":false,"id":107370,"user_name":"定格 丶Phospherus","can_delete":false,"product_type":"c1","uid":1400343,"ip_address":"","ucode":"004BD43C5CB4B9","user_header":"https://static001.geekbang.org/account/avatar/00/15/5e/17/dbca15d5.jpg","comment_is_top":false,"comment_ctime":1561520776,"is_pvip":false,"replies":[{"id":"38949","content":"不会的。很少有跟语言特性相关的东西，如果真遇到了，忽略就好了。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1561598251,"ip_address":"","comment_id":107370,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561520776","product_id":100017301,"comment_content":"老师好，我不是很了解C语言无限循环的问题，和JVM的问题，会对后面的学习有影响吗","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455489,"discussion_content":"不会的。很少有跟语言特性相关的东西，如果真遇到了，忽略就好了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561598251,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107091,"user_name":"船头尺","can_delete":false,"product_type":"c1","uid":1031095,"ip_address":"","ucode":"AAD139EA6D46DB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bb/b7/2a669915.jpg","comment_is_top":false,"comment_ctime":1561457774,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561457774","product_id":100017301,"comment_content":"即便是slvher所说，压栈，变量i也应该是和arr[0]相邻啊。<br>","like_count":0},{"had_liked":false,"id":107090,"user_name":"船头尺","can_delete":false,"product_type":"c1","uid":1031095,"ip_address":"","ucode":"AAD139EA6D46DB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bb/b7/2a669915.jpg","comment_is_top":false,"comment_ctime":1561457471,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561457471","product_id":100017301,"comment_content":"我想问一下，数组arr[3]的地址经过计算怎么会正好是变量i的地址呢？变量i的定义不是在数组arr定义之前吗？","like_count":0},{"had_liked":false,"id":106886,"user_name":"😀cooking007","can_delete":false,"product_type":"c1","uid":1485294,"ip_address":"","ucode":"8F6EB28933D734","user_header":"https://static001.geekbang.org/account/avatar/00/16/a9/ee/843d114d.jpg","comment_is_top":false,"comment_ctime":1561422322,"is_pvip":false,"replies":[{"id":"38956","content":"双向链表的后继指针也并不是指向前驱指针呀。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1561598857,"ip_address":"","comment_id":106886,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561422322","product_id":100017301,"comment_content":"单向链表后继指针指向下一个节点，双向链表后继指针指向前驱指针，指向下一个节点和指向下一个节点的前驱指针有什么区别吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455267,"discussion_content":"双向链表的后继指针也并不是指向前驱指针呀。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561598857,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105269,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1560951751,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560951751","product_id":100017301,"comment_content":"标记清除算法：针对新生代和老年代两个分区吧，永久代保存的是class和方法的元数据，还有Java SE 类库，新生代里边分eden和 survivor 0 survivor 1，通过不同的标记清除周期来删除没用的对象和移动存活的对象，新生代里边的垃圾回收会出发STW，所有程序线程暂停，当老年代进行 Major GC 的时候也会触发STW。","like_count":0},{"had_liked":false,"id":104611,"user_name":"wolfog","can_delete":false,"product_type":"c1","uid":1005815,"ip_address":"","ucode":"89BFEBE2E00B18","user_header":"https://static001.geekbang.org/account/avatar/00/0f/58/f7/22ea9761.jpg","comment_is_top":false,"comment_ctime":1560784708,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560784708","product_id":100017301,"comment_content":"jvm标记清楚算法不是特别了解；<br>对于二位数组的内存寻址公式我是这样思考的，base_address + j*(type_size*len(a[0]) + i*type_size。其中a是一个二维数组，a[0]表示二维数组中的第0个一维数组，type_size一个元素的大小，j表示二维数组中的第j个一维数组，i表示第j个一维数组中第i个元素。","like_count":0},{"had_liked":false,"id":104391,"user_name":"salmonl","can_delete":false,"product_type":"c1","uid":1010160,"ip_address":"","ucode":"0F85E5AD2C52B2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/69/f0/714c2f83.jpg","comment_is_top":false,"comment_ctime":1560742257,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560742257","product_id":100017301,"comment_content":"接上一条：非线性数据结构树也有链式存储，这个怎么解释呢","like_count":0},{"had_liked":false,"id":104388,"user_name":"salmonl","can_delete":false,"product_type":"c1","uid":1010160,"ip_address":"","ucode":"0F85E5AD2C52B2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/69/f0/714c2f83.jpg","comment_is_top":false,"comment_ctime":1560742061,"is_pvip":false,"replies":[{"id":"38006","content":"别扣文字了，你管他是线性表还是xxx表呢，你说呢😁","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1560900136,"ip_address":"","comment_id":104388,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560742061","product_id":100017301,"comment_content":"链表也是一种线性表么，看到很多资料说，链表是线性表的一种链式存储结构。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454253,"discussion_content":"别扣文字了，你管他是线性表还是xxx表呢，你说呢😁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560900136,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104021,"user_name":"喵了个咪的汪","can_delete":false,"product_type":"c1","uid":1338163,"ip_address":"","ucode":"8D6BDF3B681147","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKTDI00ykOfZ1UFxHGZ1Yhknb2BIqrwZgjFD6ykDlN3KUEMN4YgKa8N9TVib8vrtQ2Uk0tFCGAwNsw/132","comment_is_top":false,"comment_ctime":1560592130,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560592130","product_id":100017301,"comment_content":"在看了这篇文章（https:&#47;&#47;www.cnblogs.com&#47;xiaokangkp&#47;p&#47;8521236.html）以后，加上画图分析，我终于明白了address = base_address + ( i * n + j) * type_size是怎么得出来的","like_count":0},{"had_liked":false,"id":103765,"user_name":"时光剪影","can_delete":false,"product_type":"c1","uid":1093159,"ip_address":"","ucode":"CC6F24C30AE3E6","user_header":"https://static001.geekbang.org/account/avatar/00/10/ae/27/3dfcc699.jpg","comment_is_top":false,"comment_ctime":1560505658,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560505658","product_id":100017301,"comment_content":"数组是线性表，开辟连续内存空间存储相同类型数据，通过删除元素联系到jvm标记算法，挺有新意。目前java容器类底层源码有关于数组的删除操作基本是使用system.arraycopy ()也就是一个一个元素往前挪。不能将末尾的元素填充到删除的index元素，这种做法倒是贴近红黑树删除元素的操作。从0开始当作下标除了提高性能+沿用其他编程语言的使用方式 这个解释个人觉得是靠谱。 另外array list默认初始化是10为什么扩容是采用1.5倍呢？Google的说法是1.5倍扩容方式最多只会浪费33%，相比扩容2倍3倍的情况更节约内存空间。","like_count":0},{"had_liked":false,"id":103302,"user_name":"邓海涵","can_delete":false,"product_type":"c1","uid":1473900,"ip_address":"","ucode":"DCCA91C3B4CBAE","user_header":"https://static001.geekbang.org/account/avatar/00/16/7d/6c/e7163342.jpg","comment_is_top":false,"comment_ctime":1560410783,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560410783","product_id":100017301,"comment_content":"讲的太好了，这个钱花的值。","like_count":0},{"had_liked":false,"id":102837,"user_name":"tong467","can_delete":false,"product_type":"c1","uid":1560667,"ip_address":"","ucode":"544F6FB2C5A936","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJjw7KXibCGnibOm3O73xCGyCzdmgKuc017X8IQZCdNvAWxoWxHSgMTLgd7rGs1LCBPaU5oHbO16F0A/132","comment_is_top":false,"comment_ctime":1560310535,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560310535","product_id":100017301,"comment_content":"容器不支持基本类型，是因为容器是存储在堆上的，而基本类型是存储在栈上，所以容器类不能存储基本类型。<br>如不对，请老师指正。","like_count":0},{"had_liked":false,"id":102425,"user_name":"孙旗","can_delete":false,"product_type":"c1","uid":1554968,"ip_address":"","ucode":"DCED9A616139BE","user_header":"https://static001.geekbang.org/account/avatar/00/17/ba/18/0990c1d9.jpg","comment_is_top":false,"comment_ctime":1560219453,"is_pvip":false,"replies":[{"id":"37140","content":"跟连续访问对立的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1560298904,"ip_address":"","comment_id":102425,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560219453","product_id":100017301,"comment_content":"这种访问为什么叫做随机访问呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453418,"discussion_content":"跟连续访问对立的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560298904,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":102231,"user_name":"上善若水","can_delete":false,"product_type":"c1","uid":1565462,"ip_address":"","ucode":"7E783812D2D164","user_header":"https://static001.geekbang.org/account/avatar/00/17/e3/16/0e476be6.jpg","comment_is_top":false,"comment_ctime":1560165682,"is_pvip":false,"replies":[{"id":"36899","content":"int类型要般都是4字节呢","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1560209523,"ip_address":"","comment_id":102231,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560165682","product_id":100017301,"comment_content":"我们举的这个例子里，数组中存储的是 int 类型数据，所以 data_type_size 就为 4 个字节。<br>老师，这个为什么会是4字节","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453302,"discussion_content":"int类型要般都是4字节呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560209523,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101674,"user_name":"Leeyw","can_delete":false,"product_type":"c1","uid":1566645,"ip_address":"","ucode":"2598D59C9DAD62","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLhAf4cGxUmSmxH9Hhy9h9YJdwiarbLnjOcGgQlpibAUcyEHlNGj3vqhHTedO444MMUNic8Tz1tCrp5A/132","comment_is_top":false,"comment_ctime":1559910918,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1559910918","product_id":100017301,"comment_content":"JVM辣鸡回收：通过标记来判断是否存货，遍历一遍后将非存活数据进行清理工作，(会产生内存空间碎片)<br>二维数组寻址公式:<br>a[k][j]_address = base_address + (k * j)*typeSize","like_count":0},{"had_liked":false,"id":101024,"user_name":"Geek_9bf6a1","can_delete":false,"product_type":"c1","uid":1555916,"ip_address":"","ucode":"43D25B53FAB7E8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLECf8usseL8LTaXXSrnEdwG32t3DEnIXOslKZJnAQcWCOXUCbxQrZESZw4mXZp5lg76bFDzGDn2A/132","comment_is_top":false,"comment_ctime":1559702420,"is_pvip":false,"replies":[{"id":"36471","content":"有关的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1559775888,"ip_address":"","comment_id":101024,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559702420","product_id":100017301,"comment_content":"栈就是从高地址向低地址分配的，和编译器无关吧","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452782,"discussion_content":"有关的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559775888,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":100947,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1559694212,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559694212","product_id":100017301,"comment_content":"关于设计问题，从性能，安全，可移植性，可扩展性这些角度思考总会得出一些答案。<br>关于数组越界那部分，确实涉及到了操作系统和编译原理的知识，需要回去研究。","like_count":0},{"had_liked":false,"id":100850,"user_name":"申鹏飞","can_delete":false,"product_type":"c1","uid":1331464,"ip_address":"","ucode":"429211A63F6314","user_header":"https://static001.geekbang.org/account/avatar/00/14/51/08/0460f6eb.jpg","comment_is_top":false,"comment_ctime":1559654740,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559654740","product_id":100017301,"comment_content":"数组特点：连续内存地址  ， 存储相同类型数据。<br><br>特性：<br>    1.支持快速随机访问，  O(1)<br>    2.增加删除 需要搬移数据，O(n)<br><br>使用技巧：<br>    1.延迟搬移。  应用：标记清除算法。<br><br>容器 VS 数组<br>1.容器是对数组的封装。  对数组的操作细节封装。支持动态扩容。<br>封箱开箱 有性能损耗。<br>2.ArrayList 不支持基本类型<br>3.在明确数据大小，且无复杂操作时，可以直接使用数组。<br>4.多维数组是 直接使用数组更为直观。Object[][]  ArrayList&lt;ArrayList&gt; array.","like_count":0},{"had_liked":false,"id":100809,"user_name":"水电工٩(｡•ω•｡)﻿و","can_delete":false,"product_type":"c1","uid":1348364,"ip_address":"","ucode":"C43B6B4DDA9BE7","user_header":"https://static001.geekbang.org/account/avatar/00/14/93/0c/dd383681.jpg","comment_is_top":false,"comment_ctime":1559643045,"is_pvip":false,"replies":[{"id":"36374","content":"有点不对 你看看留言里其他同学的回答","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1559689504,"ip_address":"","comment_id":100809,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559643045","product_id":100017301,"comment_content":"猜想：二维的数组寻址公式是否类似坐标轴确定位置，横向上一个公式，纵向上一个公式。<br>         a[k][]_address = base_address1  + k * type_size<br>         a[][j]_address=base_adress2+k*type_size<br>没有基础，可能不对，请老师指导。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452685,"discussion_content":"有点不对 你看看留言里其他同学的回答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559689504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99800,"user_name":"杰飞Harry","can_delete":false,"product_type":"c1","uid":1555013,"ip_address":"","ucode":"175DDAB485BEEB","user_header":"https://static001.geekbang.org/account/avatar/00/17/ba/45/77d230b4.jpg","comment_is_top":false,"comment_ctime":1559304404,"is_pvip":false,"replies":[{"id":"36264","content":"跟java没太大关系的哦","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1559611895,"ip_address":"","comment_id":99800,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559304404","product_id":100017301,"comment_content":"a[k][j]_adress = base_address + k * j * type_size + j * type_size<br>JVM不懂，java也不懂。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452275,"discussion_content":"跟java没太大关系的哦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559611895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99795,"user_name":"杰飞Harry","can_delete":false,"product_type":"c1","uid":1555013,"ip_address":"","ucode":"175DDAB485BEEB","user_header":"https://static001.geekbang.org/account/avatar/00/17/ba/45/77d230b4.jpg","comment_is_top":false,"comment_ctime":1559303418,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559303418","product_id":100017301,"comment_content":"那个hello world例子，刚好因为越界造成i = 0的概率不大。大部分的编译器，会打出四个hello world。","like_count":0},{"had_liked":false,"id":99510,"user_name":"奔跑的蜗牛","can_delete":false,"product_type":"c1","uid":1384698,"ip_address":"","ucode":"C5277C80B423A0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK6Nic6V6iawbbIF1RRbRlwNmC0Cmt3LlQRAiaiayCibpplSDPXticVyOp97CEypEuQm2Iib7ZYCjrrlIgWQ/132","comment_is_top":false,"comment_ctime":1559233019,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559233019","product_id":100017301,"comment_content":"应该是address = base_address + ( (i -1)* n + j) * type_size","like_count":0},{"had_liked":false,"id":98074,"user_name":"reven404","can_delete":false,"product_type":"c1","uid":1022868,"ip_address":"","ucode":"F84AAF2DC1D18F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/94/4977913a.jpg","comment_is_top":false,"comment_ctime":1558891960,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1558891960","product_id":100017301,"comment_content":"无限循环问题，在gcc未开启优化时(我使用的是9)可复现，但开启了优化(`-o1`)之后仅删除4次但在clang(Apple LLVM version 10.0.1 (clang-1001.0.46.4))中并未重现（编译通过，但运行aborted）。<br><br>由于基础有限，未找到相关说明。求指导，clang做了些啥？","like_count":0},{"had_liked":false,"id":98000,"user_name":"长满石楠的荒原","can_delete":false,"product_type":"c1","uid":1543389,"ip_address":"","ucode":"88CF9E497CD264","user_header":"https://static001.geekbang.org/account/avatar/00/17/8c/dd/c31fc248.jpg","comment_is_top":false,"comment_ctime":1558866338,"is_pvip":false,"replies":[{"id":"35214","content":"应该跟编译优化有关","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1559007133,"ip_address":"","comment_id":98000,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1558866338","product_id":100017301,"comment_content":"int main(int argc, char* argv[]){<br><br>    int arr[3] = {0};int i = 0;<br>    cout&lt;&lt;&quot;i----&quot;&lt;&lt;&amp;i&lt;&lt;endl;<br>    for(; i&lt;=3; i++){<br>        arr[i] = 0;<br>        printf(&quot;hello world\\n&quot;);<br>    }<br>    return 0;<br>}<br>老师您好，这段代码我运行的时候并没有死循环，但是将输出i的地址那一行注释掉就会产生死循环，这是为什么？老师可以给解答一下吗，谢谢~","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451506,"discussion_content":"应该跟编译优化有关","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559007133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97691,"user_name":"do it","can_delete":false,"product_type":"c1","uid":1309911,"ip_address":"","ucode":"E0753912E8F2AF","user_header":"https://static001.geekbang.org/account/avatar/00/13/fc/d7/b102034a.jpg","comment_is_top":false,"comment_ctime":1558750178,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558750178","product_id":100017301,"comment_content":"个人小结<br>数组的定义：是一种线性表结构。使用一组连续的内存空间，来存储一组具有相同类型的数据。【关键词：线性表、连续内存、相同类型】<br>线性表：数组、链表、队列、栈。<br>非线性表：二叉树、图、堆等。<br>数组和链表的区别：<br>错误的表述：{<br>数组适合查找，查找时间复杂度为O(1)。<br>聊表适合插入、删除，时间复杂度为O(1).}<br>正确的表述{<br>数组支持随机访问，根据小标随机访问的时间复杂度为O(1).}<br>插入操作：{<br>最好情况下是直接在末尾插入，最好时间复杂度为O(1);<br>最坏情况下是每次都在头部插入，所有数据都需往后搬移一位，最坏时间复杂度位O(n);<br>在每个位置插入元素的概率是一样的，所以平均时间复杂度为(1+2+...+n)&#47;n）=O(n);}<br>删除操作同插入操作一样。<br>容器和数组比较：<br>容器：1、封装细节，提供必要接口；2、支持动态扩容；<br>数组：1、表示多维更直观。<br>业务开发，直接使用编程语言提供的容器类；<br>特别底层的开发，直接使用数组更合适。<br>为什么大多数编程语言，数组从0开始编号，而不是1开始？<br>从数组存储的内存模型上来看，“下表”最确切的定义应该是“偏移（Offset））”。<br>以0为起始的内存地址：a[k]_address=base_address+k*type_size;<br>以1为起始的内存地址：a[k]_address=base_address+(k-1)*type_size;<br>标记以上两个公式不难发现，从1开始编号，每次随机访问数组元素都多了一次减法操作，多余CPU来说就是多了一次减法指令。<br>1、极致的效率优化。<br>2、历史原因。&lt;C语言设计者采用0开始计数数组下标，之后的JAVA、C++...都效仿了C语言。&gt;<br>","like_count":0},{"had_liked":false,"id":97604,"user_name":"88591","can_delete":false,"product_type":"c1","uid":1254656,"ip_address":"","ucode":"04CE3E46455185","user_header":"https://static001.geekbang.org/account/avatar/00/13/25/00/3afbab43.jpg","comment_is_top":false,"comment_ctime":1558709757,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558709757","product_id":100017301,"comment_content":"数组为什么从0开始？为了寻址计算通用方便，并且少一次减1的操作。为什么数组要求，连续，数据类型相同，也是为了寻址。<br>数组操作的一些优化思想:1-如果能够确认数据大小，分配固定大小空间。不使用动态扩容。2-如果需要动态扩容，需要依据数据是否要求有序，来添加元素。如果数据要求无序，则直接插入，尽量少的移动元素。3-如果是删除元素，可以使用标记算法，统一删除，提高空间利用率。减少删除数据移动次数（先丢垃圾到垃圾桶，垃圾桶满了在倒垃圾，这个比喻很形象），jvm垃圾标记整理算法，先找到需要回收的对象（找垃圾），标记回收对象（丢进垃圾桶），清理空对象（移动存活的对象到连续空间，垃圾分类整理）<br>4-数组越界访问异常，危险操作。所以Java中不允许数组越界访问。","like_count":0},{"had_liked":false,"id":97484,"user_name":"嘉木","can_delete":false,"product_type":"c1","uid":1317999,"ip_address":"","ucode":"AF4877693782C0","user_header":"https://static001.geekbang.org/account/avatar/00/14/1c/6f/3ea2a599.jpg","comment_is_top":false,"comment_ctime":1558681870,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558681870","product_id":100017301,"comment_content":"假设定义一个二维数组 int a[I][J] = {0};<br>那么它的内存寻址公式应该是 a[i][j]_addr = base_address + (i * J + j) * type_size","like_count":0},{"had_liked":false,"id":96752,"user_name":"William","can_delete":false,"product_type":"c1","uid":1346215,"ip_address":"","ucode":"55F5D9DEE485B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","comment_is_top":false,"comment_ctime":1558497582,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1558497582","product_id":100017301,"comment_content":"线性表: 只有前后节点. 无其他分支节点. <br>数组（Array）是一种线性表数据结构。它用一组连续的内存空间,统一数据类型的数据结构.<br><br>数组优点: 查询方便,  指定下标的查询时间复杂滴为O(1) ,  单说:数组时间复杂度为:O(log n ).<br>       缺点: 删除插入,除了在最后的位置插入删除 复杂度为O(1), 其余的需要移动复制节点元素, 所以为O(n)<br><br>内存空间: ;连续的内存地址空间. <br>","like_count":0},{"had_liked":false,"id":96741,"user_name":"路 远","can_delete":false,"product_type":"c1","uid":1520745,"ip_address":"","ucode":"2237BB3676F450","user_header":"https://static001.geekbang.org/account/avatar/00/17/34/69/96c35aaa.jpg","comment_is_top":false,"comment_ctime":1558495714,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558495714","product_id":100017301,"comment_content":"这么说，Python里面的List更像是一个容器，而不是数组。","like_count":0},{"had_liked":false,"id":96480,"user_name":"靠人品去赢","can_delete":false,"product_type":"c1","uid":1301286,"ip_address":"","ucode":"7A20F9EBE847E1","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/26/54f2c164.jpg","comment_is_top":false,"comment_ctime":1558432163,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558432163","product_id":100017301,"comment_content":"可以的，（1）关于为什么从0开始计数，如果从偏移量来看这个，非常的合理<br>（2）关于容器，感觉貌似要更高大上，其实相当于在基本类型上做了底层的封装，更加的灵活的同时，复杂度提升，空间占用的更多（ArrayList默认有一个长度，长度不够还会再扩容。）。基本类型的数组有的时候也许是一个优化的切入点。<br>（3）有的时候不需要删除，其实标记一下就可以了，真的空间不够再删也不迟，JVM类似，实际工作中也类似。（删除数据真的删那就太可惜了，数据是有价值的，给一个标记，置为失效就可以了，这个思路真的太赞了）。","like_count":0},{"had_liked":false,"id":96431,"user_name":"꧁花间一壶酒꧂","can_delete":false,"product_type":"c1","uid":1542238,"ip_address":"","ucode":"71CBBCFC4A926E","user_header":"https://static001.geekbang.org/account/avatar/00/17/88/5e/e9a8417d.jpg","comment_is_top":false,"comment_ctime":1558422008,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558422008","product_id":100017301,"comment_content":"厉害了,大道至简","like_count":0},{"had_liked":false,"id":96408,"user_name":"Jeason Lee","can_delete":false,"product_type":"c1","uid":1523070,"ip_address":"","ucode":"CCF0BB264EAF49","user_header":"https://static001.geekbang.org/account/avatar/00/17/3d/7e/1b92d463.jpg","comment_is_top":false,"comment_ctime":1558413199,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558413199","product_id":100017301,"comment_content":"如果实现业务不注意性能的话，时间久了就成了ACRD的程序员，等想要优化的时候发现不行了，其实还是要自己多注意","like_count":0},{"had_liked":false,"id":96097,"user_name":"Geek_544e36","can_delete":false,"product_type":"c1","uid":1450625,"ip_address":"","ucode":"AE7D01F2BA3D65","user_header":"https://static001.geekbang.org/account/avatar/00/16/22/81/3115e3eb.jpg","comment_is_top":false,"comment_ctime":1558328959,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558328959","product_id":100017301,"comment_content":"对于 m * n 的数组，a [ i ][ j ] (i &lt; m,j &lt; n)的地址为：<br><br>address = base_address + ( i * n + j) * type_size","like_count":0},{"had_liked":false,"id":94627,"user_name":"大鹏","can_delete":false,"product_type":"c1","uid":1004481,"ip_address":"","ucode":"F56D9D1DE892D8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/53/c1/34bb9b24.jpg","comment_is_top":false,"comment_ctime":1557871129,"is_pvip":false,"replies":[{"id":"33859","content":"你说的没错。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1557881441,"ip_address":"","comment_id":94627,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557871129","product_id":100017301,"comment_content":"a[3] 也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。<br>问题：如果a［3］得内存地址不是i的内存地址，是不是就不为无线循环了？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450146,"discussion_content":"你说的没错。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557881441,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93816,"user_name":"Geek_cf29f0","can_delete":false,"product_type":"c1","uid":1337800,"ip_address":"","ucode":"F635968AE2656C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bWpFdAQwTzBg70ib6QTQomfQV3Ak1CFQPXun20w2Kz3PCLtsV75nNrqBuDEvehtlCoTkyT3icNWnvO7nPMc1RFfg/132","comment_is_top":false,"comment_ctime":1557628889,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557628889","product_id":100017301,"comment_content":"1.JVM 的标记清除垃圾回收算法的核心理念<br>主要是两个步骤，先对所有的对象进行标记，如果是live的被使用的对象，就会被标记。第二步是回收，遍历所有的对象，如果是已经被标记的，就设置为未被标记，以便下一轮；如果未被标记，就被回收。<br>2.二维数组的排序方式是按行排序，假设数据是m*n，那么二维数组的寻址公式是a[i][j]=a[0][0]+(i*n+j)*步长，这里的步长指的是基本类型的字节数","like_count":0},{"had_liked":false,"id":93770,"user_name":"ljf10000","can_delete":false,"product_type":"c1","uid":1494064,"ip_address":"","ucode":"44957329A61EAE","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eop9WylZJicLQ5wib49kcMPqCTRT1aThh6mMAVl6qseLwbVOLhicVLjZCxCoyQd5CrrHHibs2CVPaoK3g/132","comment_is_top":false,"comment_ctime":1557585305,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557585305","product_id":100017301,"comment_content":"我认为，用偏移做索引，最大的原因是语言有指针&#47;地址概念。从数组的概念模型上看，数组指针一定等于数组首元素地址，这就要求用偏移做索引。<br>没有地址和指针运算的高级语言，可以选择数组索引为base1的。","like_count":0},{"had_liked":false,"id":93104,"user_name":"Poppy","can_delete":false,"product_type":"c1","uid":1501505,"ip_address":"","ucode":"AF656A00521037","user_header":"https://static001.geekbang.org/account/avatar/00/16/e9/41/7cb2cf64.jpg","comment_is_top":false,"comment_ctime":1557398863,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557398863","product_id":100017301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":92282,"user_name":"半城柳色 &#47; 半声笛","can_delete":false,"product_type":"c1","uid":1514634,"ip_address":"","ucode":"277503993FF3C2","user_header":"https://static001.geekbang.org/account/avatar/00/17/1c/8a/90c9a8ea.jpg","comment_is_top":false,"comment_ctime":1557220810,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557220810","product_id":100017301,"comment_content":"按照slhver同学的解释，如果i的定义在arr之后，是不是就不会出现无限循环的问题了？因为arr[3]访问到的就不是i的位置了","like_count":0},{"had_liked":false,"id":92027,"user_name":"xk_","can_delete":false,"product_type":"c1","uid":1514305,"ip_address":"","ucode":"DFE1AC38EA78A7","user_header":"https://static001.geekbang.org/account/avatar/00/17/1b/41/dbb7d785.jpg","comment_is_top":false,"comment_ctime":1557156571,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557156571","product_id":100017301,"comment_content":"数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。","like_count":0},{"had_liked":false,"id":92026,"user_name":"xk_","can_delete":false,"product_type":"c1","uid":1514305,"ip_address":"","ucode":"DFE1AC38EA78A7","user_header":"https://static001.geekbang.org/account/avatar/00/17/1b/41/dbb7d785.jpg","comment_is_top":false,"comment_ctime":1557156509,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557156509","product_id":100017301,"comment_content":"今日总结。<br>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。<br>因此，","like_count":0},{"had_liked":false,"id":91453,"user_name":"郑佳宇","can_delete":false,"product_type":"c1","uid":1239639,"ip_address":"","ucode":"538EE8AA8EA375","user_header":"https://static001.geekbang.org/account/avatar/00/12/ea/57/5d4bc563.jpg","comment_is_top":false,"comment_ctime":1557041232,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557041232","product_id":100017301,"comment_content":"数组的概念，数组的随机访问特性，为什么下标是从0开始，数组中的查询，插入，删除的原理，Java中的ArrayList","like_count":0},{"had_liked":false,"id":91335,"user_name":"你在不远的未来","can_delete":false,"product_type":"c1","uid":1318404,"ip_address":"","ucode":"5B34C8BD03B71A","user_header":"https://static001.geekbang.org/account/avatar/00/14/1e/04/f902047e.jpg","comment_is_top":false,"comment_ctime":1556983446,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556983446","product_id":100017301,"comment_content":"问题1jvm不了解<br>问题二：假设二维数组 int [i][j] arr<br>猜测二维只是将多个连续的地址以组的形式划分到二维这个概念上，那么二维数组的寻址应该是 a[k1][k2]address = base_address + (k1 * j + k2) *type_size<br>不知道对不对","like_count":0},{"had_liked":false,"id":91332,"user_name":"莫小鹏","can_delete":false,"product_type":"c1","uid":1158881,"ip_address":"","ucode":"0EE0654FD0FB85","user_header":"https://static001.geekbang.org/account/avatar/00/11/ae/e1/78701ecf.jpg","comment_is_top":false,"comment_ctime":1556982468,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556982468","product_id":100017301,"comment_content":"不理解JVM， 说下看法，标记清除语法，是如何找到垃圾，找垃圾使用的是图遍历算法广度优先算法，对于没有父节点的内存为垃圾内存，标记为垃圾。<br>二维数组的寻址公式：数组a[m][n],元素a[i][j]的地址是base_address + (i * n + j)  * data_type_size<br><br><br><br>","like_count":0},{"had_liked":false,"id":90905,"user_name":"不屈战神","can_delete":false,"product_type":"c1","uid":1184059,"ip_address":"","ucode":"D81ACC3887A443","user_header":"https://static001.geekbang.org/account/avatar/00/12/11/3b/592ba297.jpg","comment_is_top":false,"comment_ctime":1556719503,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556719503","product_id":100017301,"comment_content":"其实数组从零开始，与补码的机器表示有关，吧！这样方便表示负数。","like_count":0},{"had_liked":false,"id":90701,"user_name":"10^100个邱怡霖","can_delete":false,"product_type":"c1","uid":1517246,"ip_address":"","ucode":"414414618FA93A","user_header":"https://static001.geekbang.org/account/avatar/00/17/26/be/c7249aea.jpg","comment_is_top":false,"comment_ctime":1556612166,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556612166","product_id":100017301,"comment_content":"用C++的同学注意：不同于java，C++容器扩容是高效的，没必要设定大小，除非所有元素都相同 ，否则提前设定大小的效果比直接在空容器上添加效果更差","like_count":0},{"had_liked":false,"id":90435,"user_name":"快乐少年郎","can_delete":false,"product_type":"c1","uid":1488186,"ip_address":"","ucode":"A6DF373FEB50F7","user_header":"https://static001.geekbang.org/account/avatar/00/16/b5/3a/9f2e0d8e.jpg","comment_is_top":false,"comment_ctime":1556519883,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556519883","product_id":100017301,"comment_content":"二维数组遵旨：<br>在c语言中二维数组的存储方式和一维数组一样，连续的内存空间，那么寻址方式也一样。在M行N列的二维数组中，a[m][n]_address=abase_address+type_address*(N*m+n)，只要正确算出偏移量就可以了。","like_count":0},{"had_liked":false,"id":90253,"user_name":"Dispy","can_delete":false,"product_type":"c1","uid":1483495,"ip_address":"","ucode":"1BF7870B32AB15","user_header":"","comment_is_top":false,"comment_ctime":1556460488,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556460488","product_id":100017301,"comment_content":"a[i]_address = base_address + i * data_type_size，对于这个公式第一遍看的时候，觉得很正确直接过了。然而看到评论区第一人对于二维数组求解地址的公式的时候，出现了个小疑惑；我借用老师的一维数组公式描述一下：<br>exp:<br>    int a[] = {1,2,3,4};<br>    cout &lt;&lt; &amp;a[0] &lt;&lt; endl;<br>    cout &lt;&lt; (&amp;a[0] + 2) &lt;&lt; endl; &#47;&#47; cout &lt;&lt; (&amp;a[0] + 2*sizeof(int)) &lt;&lt; endl;<br>    a[2]的地址,这么写输出结果是正确的，解引用也能得出对应的值<br>疑惑之处在于如果按照公式的表示方式，就是注释区域的代码，输出的结果就不对了<br>求指正。。。。（按照公式上面的内存分布图是可以理解的，但是又纠结了一下具体的表述方式）","like_count":0},{"had_liked":false,"id":90121,"user_name":"Edison","can_delete":false,"product_type":"c1","uid":1500120,"ip_address":"","ucode":"ADB01AF2966736","user_header":"https://static001.geekbang.org/account/avatar/00/16/e3/d8/6462cfdb.jpg","comment_is_top":false,"comment_ctime":1556419846,"is_pvip":false,"replies":[{"id":"32374","content":"看你怎么定义第一个元素了？如果arr[0]算第一个元素的话，那就是a。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1556502969,"ip_address":"","comment_id":90121,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556419846","product_id":100017301,"comment_content":"老师，那个数组的删除操作，如果只是记录数据被删除，实际不去做空间的删除操作，那么当我访问数组第一个元素，那访问的应该是d还是a呢？？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448397,"discussion_content":"看你怎么定义第一个元素了？如果arr[0]算第一个元素的话，那就是a。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556502969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90062,"user_name":"锋芒","can_delete":false,"product_type":"c1","uid":1320419,"ip_address":"","ucode":"BB5284E3C8D78D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ach5TNuIu8T4Of8ibvfWM4JPic5uQn9Y7TgGjBHLp2iar4icxJzs14bpUXV9OdYiciblvJl14zSqXjwtDffHnSTqbD6g/132","comment_is_top":false,"comment_ctime":1556383404,"is_pvip":false,"replies":[{"id":"32291","content":"c写法","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1556407062,"ip_address":"","comment_id":90062,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556383404","product_id":100017301,"comment_content":"老师请问例子中这是啥写法 ？ int arr[3] = {0};<br>java 中应该不能这样写吧？<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448375,"discussion_content":"c写法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556407062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90027,"user_name":"阿邱","can_delete":false,"product_type":"c1","uid":1281762,"ip_address":"","ucode":"A3D1A90E01D83D","user_header":"https://static001.geekbang.org/account/avatar/00/13/8e/e2/1e70c61d.jpg","comment_is_top":false,"comment_ctime":1556372671,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556372671","product_id":100017301,"comment_content":"你好这个解释一下，ArrayList 最大的优势就是可以将很多数组操作的细节封装起来。","like_count":0},{"had_liked":false,"id":88977,"user_name":"贝如科技","can_delete":false,"product_type":"c1","uid":1507584,"ip_address":"","ucode":"2B792C68D7A081","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqT1ykjFve5LJmVhfTXicibvFaAq4aTERwic63YSzW0YZ8IooaDV6aDPprva70HGkwbAicm6XNcmDYhLw/132","comment_is_top":false,"comment_ctime":1556038020,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556038020","product_id":100017301,"comment_content":"老师说的数组插入删除方法真的让我惊叹，以前居然重来没想过<br> 二维数组的话，应该就是以为数组里存了一些列的内存地址","like_count":0},{"had_liked":false,"id":87611,"user_name":"ok绷","can_delete":false,"product_type":"c1","uid":1441991,"ip_address":"","ucode":"7B2303B3319C4D","user_header":"https://static001.geekbang.org/account/avatar/00/16/00/c7/59caefa7.jpg","comment_is_top":false,"comment_ctime":1555640913,"is_pvip":false,"replies":[{"id":"31592","content":"这个跟java语言本身的优化有关 我抽空写个文章说说吧 留言一句两句说不清楚","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1555717968,"ip_address":"","comment_id":87611,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555640913","product_id":100017301,"comment_content":"老师，您好，我按您的方法换了一下顺序执行，确实和您说的一样，提前申请效率会提高很多，但是不太明白为什么要换一下顺序？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447532,"discussion_content":"这个跟java语言本身的优化有关 我抽空写个文章说说吧 留言一句两句说不清楚","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555717968,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87474,"user_name":"ok绷","can_delete":false,"product_type":"c1","uid":1441991,"ip_address":"","ucode":"7B2303B3319C4D","user_header":"https://static001.geekbang.org/account/avatar/00/16/00/c7/59caefa7.jpg","comment_is_top":false,"comment_ctime":1555602951,"is_pvip":false,"replies":[{"id":"31492","content":"你把两部分代码执行的先后顺序颠倒下，再看下执行时间","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1555639762,"ip_address":"","comment_id":87474,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555602951","product_id":100017301,"comment_content":"老师，您好，我测试了一下List&lt;Integer&gt;,不太明白，List 存储 int 类型，为什么提前申请好 size，但是效率更低了，不是都会有拆箱和封箱吗这两个 List?<br><br>public static void testInteger() {<br>        long st = System.currentTimeMillis();<br>        List&lt;Integer&gt; list = new ArrayList&lt;&gt;(10000000);<br>        for (int i = 0; i &lt; 10000000; ++i) {<br>            list.add(i);<br>        }<br>        System.out.println(&quot;Test1: &quot; + (System.currentTimeMillis() - st));<br>        long s1 = System.currentTimeMillis();<br>        List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;();<br>        for (int i = 0; i &lt; 10000000; ++i) {<br>            list1.add(i);<br>        }<br>        System.out.println(&quot;Test2: &quot; + (System.currentTimeMillis() - s1));<br>    }<br>输出时间：<br>Test1: 3084<br>Test2: 2252","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447471,"discussion_content":"你把两部分代码执行的先后顺序颠倒下，再看下执行时间","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555639762,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87438,"user_name":"群书","can_delete":false,"product_type":"c1","uid":1437036,"ip_address":"","ucode":"BA9EE71D2D818A","user_header":"https://static001.geekbang.org/account/avatar/00/15/ed/6c/6fb35017.jpg","comment_is_top":false,"comment_ctime":1555594082,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1555594082","product_id":100017301,"comment_content":"https:&#47;&#47;blog.csdn.net&#47;u012796139&#47;article&#47;details&#47;46635567<br>这个链接中说的数组和变量的地址关系是错的<br>数组的地址是低地址，变量的地址是高地址。 变量先压栈，数组后压栈 ，栈的地址是向着低地址的方向生长, 机器实际测试的结果！","like_count":0},{"had_liked":false,"id":87432,"user_name":"群书","can_delete":false,"product_type":"c1","uid":1437036,"ip_address":"","ucode":"BA9EE71D2D818A","user_header":"https://static001.geekbang.org/account/avatar/00/15/ed/6c/6fb35017.jpg","comment_is_top":false,"comment_ctime":1555593247,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1555593247","product_id":100017301,"comment_content":"数组总是最后压入栈的 栈是向低地址的方向生长 GCC x86_64 Linux ","like_count":0},{"had_liked":false,"id":84746,"user_name":"黑洞","can_delete":false,"product_type":"c1","uid":1451364,"ip_address":"","ucode":"840A4330B1B2F0","user_header":"https://static001.geekbang.org/account/avatar/00/16/25/64/d66ea739.jpg","comment_is_top":false,"comment_ctime":1554901764,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554901764","product_id":100017301,"comment_content":"所以，语言标准说某种情况下行为未定义，于是可以有各种可能，还要参考具体编译器厂家的实现和优化，是没有标准答案的。","like_count":0},{"had_liked":false,"id":84744,"user_name":"黑洞","can_delete":false,"product_type":"c1","uid":1451364,"ip_address":"","ucode":"840A4330B1B2F0","user_header":"https://static001.geekbang.org/account/avatar/00/16/25/64/d66ea739.jpg","comment_is_top":false,"comment_ctime":1554901475,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554901475","product_id":100017301,"comment_content":"二维数组在内存中分两种存储顺序：行序优先，列序优先。我记得，当年学习FORTRAN语言的时候，记得它就是列序优先存储的，不知道我记得是否准确。而我们知道，C &#47;C++&#47;JAVA都是按照行序优先存储的。所以计算公式就不一样。","like_count":0},{"had_liked":false,"id":83900,"user_name":"QUINCY","can_delete":false,"product_type":"c1","uid":1236845,"ip_address":"","ucode":"ECB80013B19CA1","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/6d/b227801c.jpg","comment_is_top":false,"comment_ctime":1554730844,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554730844","product_id":100017301,"comment_content":"你好，我有一个疑问。就是关于数组越界的时候，文中提到“a[3]也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量i的内存地址，那么a[3]=0就相当于i=0” 我不理解，为什么这个地址正好是i的内存地址，以及a[3]=0？ 请大佬们赐教","like_count":0},{"had_liked":false,"id":82584,"user_name":"right-chen","can_delete":false,"product_type":"c1","uid":1435172,"ip_address":"","ucode":"E0E940E80E7A2D","user_header":"https://static001.geekbang.org/account/avatar/00/15/e6/24/30806a88.jpg","comment_is_top":false,"comment_ctime":1554254855,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554254855","product_id":100017301,"comment_content":"想起了数据库的分页查找，传入页码后还要把（页码-1）x页数找到数据开始位置，而页码从0开始就减少了-1这个计算过程","like_count":0},{"had_liked":false,"id":81671,"user_name":"天王","can_delete":false,"product_type":"c1","uid":1239337,"ip_address":"","ucode":"C074B2F9A5F007","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/29/629d9bb0.jpg","comment_is_top":false,"comment_ctime":1554002281,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554002281","product_id":100017301,"comment_content":"总结：数组一种线性结构，像队列，栈，链表都是线性结构。树，图是非线性结构。<br>线性结构，是只有前后2个方向，用一根线能够串起来。<br>数组是连续存储的线性结构。比如数组存储的是int类型，内存地址从1000开始，1个数占用4个地址。<br>数组的寻址方式：第i个元素的地址=第一个元素的地址+i*4;<br>索引从0开始，不是从1开始，如果是从1开始 第i个元素的地址=第一个元素的地址+(i-1)*4<br>对CPU来说，多了一次位移的运算。<br>数组支持随机访问，通过下标查找数组的时间复杂度是O(1)，是因为能直接计算出，第n个元素的地址，通过地址访问数组的时间复杂度是O(1)。<br>在有序数组中查找数据，时间复杂度最好的是O(logn)。<br>数组的插入，最好时间复杂度是O(1)，最坏时间复杂度是O(n)，平均时间复杂度是O(1)，均摊时间复杂度也是O(1)。<br>数组的删除，最好时间复杂度是O(1)，最坏时间复杂度是O(n)，平均时间复杂度是O(1)，均摊时间复杂度也是O(1)。<br>为了减少频繁的数据移动，删除的时候，先把删除的数据打上标记，再统一的进行处理。垃圾回收的原理就是这样的。<br>容器和数组使用场景<br>容器封装了增加，删除和查询的方法，支持动态扩容，使用起来比较方便。<br>数组的使用场景：<br>1 ArrayList无法存储基本类型，数组可以，如果想把性能做到极致，<br>2 能提前确定大小，而且操作起来比较简单，数组<br>做业务开发，无所谓，做底层开发，需要把性能做到极致。<br>数组的下标，其实就是偏移。<br>a[k]就是偏移数组首地址 k * element_size（1个元素占的位置）的位置。","like_count":0},{"had_liked":false,"id":81332,"user_name":"会飞的鱼","can_delete":false,"product_type":"c1","uid":1257205,"ip_address":"","ucode":"BA3FC4E0BF7B39","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erloYzyia2hRy19E3aCtc0pf10MiaGmzEcXw8UZ3jC3LAibD8icWAFVCXGAlAic3mpjBUrHvyreyhAjIFw/132","comment_is_top":false,"comment_ctime":1553864649,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553864649","product_id":100017301,"comment_content":"最有价值的不是特定的数据结构和算法，而是思考它背后遇到问题处理的思想和技巧。学到了，这对于我来说很大的启发。","like_count":0},{"had_liked":false,"id":81113,"user_name":"火狼王","can_delete":false,"product_type":"c1","uid":1152184,"ip_address":"","ucode":"76919311EA41A1","user_header":"https://static001.geekbang.org/account/avatar/00/11/94/b8/09d86400.jpg","comment_is_top":false,"comment_ctime":1553818783,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1553818783","product_id":100017301,"comment_content":"数组虽然简单，仍包含数据结构的思想，从特点出发，造成了他的特性表示，也造成了与其他数据结构的不同。","like_count":0},{"had_liked":false,"id":80990,"user_name":"jokar","can_delete":false,"product_type":"c1","uid":1005214,"ip_address":"","ucode":"4FD20C9D4C71A8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/56/9e/e15a63bb.jpg","comment_is_top":false,"comment_ctime":1553770574,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553770574","product_id":100017301,"comment_content":"老师，你的课程质量真高！学起来感觉很愉快！","like_count":0},{"had_liked":false,"id":80982,"user_name":"樊铮","can_delete":false,"product_type":"c1","uid":1216032,"ip_address":"","ucode":"42F293BA437BE9","user_header":"https://static001.geekbang.org/account/avatar/00/12/8e/20/8aafbc00.jpg","comment_is_top":false,"comment_ctime":1553768890,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553768890","product_id":100017301,"comment_content":"在新生代中伊甸园区空间不够，会进行gc处理(无用的对象),如果伊甸园满了就判断新生代存活区(from space to space ) ,如果存活区满了就会找老年代空间 ，老年代满了 会执行FULL GC 回收机制,如果都满了  就会抛出OOM错误。 可以使用G1收集器(有自己的伊甸园，老年代，元空间).","like_count":0},{"had_liked":false,"id":80835,"user_name":"泡泡余","can_delete":false,"product_type":"c1","uid":1478267,"ip_address":"","ucode":"1B08D810A6F0C4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/4XQyTibQ00aoLWXUI74ykWdCUQUeRapVhETzLTpPZyWRpicwODWPdd254TPgfZ6cRBIDR4bGlZ8KIl4QAmty1JxQ/132","comment_is_top":false,"comment_ctime":1553740119,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553740119","product_id":100017301,"comment_content":"java中arraylist初始大小为10,每次扩容1,5倍<br><br>private static final int DEFAULT_CAPACITY = 10;<br><br>private void grow(int minCapacity) {<br>        &#47;&#47; overflow-conscious code<br>        int oldCapacity = elementData.length;<br>        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);<br>        if (newCapacity - minCapacity &lt; 0)<br>            newCapacity = minCapacity;<br>        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)<br>            newCapacity = hugeCapacity(minCapacity);<br>        &#47;&#47; minCapacity is usually close to size, so this is a win:<br>        elementData = Arrays.copyOf(elementData, newCapacity);<br>    }","like_count":0},{"had_liked":false,"id":80323,"user_name":"Geek_Captain","can_delete":false,"product_type":"c1","uid":1235165,"ip_address":"","ucode":"B568129ADC59FF","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/dd/ae43b0fd.jpg","comment_is_top":false,"comment_ctime":1553649071,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553649071","product_id":100017301,"comment_content":"## 定义<br>数组是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据。<br><br>## 关键词<br>- 线性表：数据线性，每个线性表上的数据最多只有前和后两个方向。<br>- 连续的内存空间和相同类型的数据。这个特点使得数组有优点“**随机访问**”，同时也造成数组删除和插入元素的效率低<br><br>## 优点：数组根据下标随机访问数组元素<br>计算机会给每个内存单元分配一个地址，计算机通过地址访问内存中的数据。所以当计算机要随机访问内存中某个数组元素时，需要先确定元素存储的内存地址，这里有一个公式<br>    <br>    a[i]_address = base_address + i * data_type_size<br><br>  - data_type_size表示数组中每个元素的大小<br><br>## 缺点：插入和删除的效率低<br>为保证内存数据的连续性，当插入和删除元素时需要大规模的数据搬移，<br><br>## 面试题：数组和链表的区别<br>链表适合插入和删除，时间复杂度是$O(1)$,数组支持随机访问，根据下标随机访问的时间复杂度是$O(1)$<br><br>## JVM标记清除算法<br>在标记阶段，会遍历所有GC ROOTS，将所有GC ROOTS可达的对象标记为存货，只有当标记工作完成后，清理工作才会开始。问题：标记和清理效率都不高，会产生不连续的内存空间碎片<br>","like_count":0},{"had_liked":false,"id":79721,"user_name":"小k","can_delete":false,"product_type":"c1","uid":1304236,"ip_address":"","ucode":"AE0C5ADEB489F5","user_header":"https://static001.geekbang.org/account/avatar/00/13/e6/ac/5b99aa18.jpg","comment_is_top":false,"comment_ctime":1553525898,"is_pvip":false,"replies":[{"id":"29244","content":"数据一直在存储，肯定会存在满了的情况啊","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1553648926,"ip_address":"","comment_id":79721,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553525898","product_id":100017301,"comment_content":"&quot;当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作&quot;<br>这种情况下，数组怎么会出现没有更多空间存储数据呢？<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444595,"discussion_content":"数据一直在存储，肯定会存在满了的情况啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553648926,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79676,"user_name":"Geek_Captain","can_delete":false,"product_type":"c1","uid":1235165,"ip_address":"","ucode":"B568129ADC59FF","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/dd/ae43b0fd.jpg","comment_is_top":false,"comment_ctime":1553519711,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553519711","product_id":100017301,"comment_content":"定义<br>数组是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据。<br><br>关键词<br>线性表：数据线性，每个线性表上的数据最多只有前和后两个方向。<br>连续的内存空间和相同类型的数据。这个特点使得数组有优点“随机访问”，同时也造成数组删除和插入元素的效率低<br><br>优点：数组根据下标随机访问数组元素<br>计算机会给每个内存单元分配一个地址，计算机通过地址访问内存中的数据。所以当计算机要随机访问内存中某个数组元素时，需要先确定元素存储的内存地址，这里有一个公式<br><br>a[i]_address = base_address + i * data_type_size<br><br>data_type_size表示数组中每个元素的大小<br><br>缺点：插入和删除的效率低<br>为保证内存数据的连续性，当插入和删除元素时需要大规模的数据搬移，<br><br>面试题：数组和链表的区别<br>链表适合插入和删除，时间复杂度是O(1)O(1),数组支持随机访问，根据下标随机访问的时间复杂度是O(1)O(1)<br><br>JVM标记清除算法<br>在标记阶段，会遍历所有GC ROOTS，将所有GC ROOTS可达的对象标记为存货，只有当标记工作完成后，清理工作才会开始。问题：标记和清理效率都不高，会产生不连续的内存空间碎片","like_count":0},{"had_liked":false,"id":78855,"user_name":"qqq","can_delete":false,"product_type":"c1","uid":1006786,"ip_address":"","ucode":"91B0ACF8CBE7BD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/c2/8ffd2ad0.jpg","comment_is_top":false,"comment_ctime":1553258336,"is_pvip":true,"replies":[{"id":"28968","content":"这个跟js数组的实现原理有关 js数组存储的是对象的内存地址","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1553477463,"ip_address":"","comment_id":78855,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553258336","product_id":100017301,"comment_content":"JS 中存储不同类型变量的数组也支持随机访问，还符合第二条规律吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444259,"discussion_content":"这个跟js数组的实现原理有关 js数组存储的是对象的内存地址","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553477463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78779,"user_name":"A-Zhao-刚","can_delete":false,"product_type":"c1","uid":1455934,"ip_address":"","ucode":"E3DCEF47D962EB","user_header":"https://static001.geekbang.org/account/avatar/00/16/37/3e/ae3f65db.jpg","comment_is_top":false,"comment_ctime":1553239830,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553239830","product_id":100017301,"comment_content":"数组是一种线性数据结构，用一组连续的存储空间存储数据类型相同的数据。数组适合随机访问，链表适合插入和删除。","like_count":0},{"had_liked":false,"id":77385,"user_name":"宫志鹏","can_delete":false,"product_type":"c1","uid":1434268,"ip_address":"","ucode":"697661BB60912A","user_header":"https://static001.geekbang.org/account/avatar/00/15/e2/9c/1dc6ea03.jpg","comment_is_top":false,"comment_ctime":1552916881,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552916881","product_id":100017301,"comment_content":"我用的ubuntu的gcc编译的C文件，然而只打印了四遍hello，world！，<br>体验不到无限循环到宕机的欢乐感<br>gcc -o  xx  xx.c","like_count":0},{"had_liked":false,"id":77133,"user_name":"白马啸西风","can_delete":false,"product_type":"c1","uid":1316710,"ip_address":"","ucode":"099E1E810A5B46","user_header":"https://static001.geekbang.org/account/avatar/00/14/17/66/27efea92.jpg","comment_is_top":false,"comment_ctime":1552862576,"is_pvip":false,"replies":[{"id":"28120","content":"嗯嗯 很多编程语言中的数组类型并不是我们这里说的经典的数据结构中的数组类型。你可以看下js中数组的底层存储模型，实际上，数据是独立存储的，数组只存储数据的指针（或者叫内存地址）","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1552875727,"ip_address":"","comment_id":77133,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552862576","product_id":100017301,"comment_content":"在讲数组定义的时候，老师说数组来存储一组具有相同类型的数据。这有些片面了，这要具体分语言的，比如，在Java中对，在javascript中就不对，js数组可以存储不同类型的数据。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443595,"discussion_content":"嗯嗯 很多编程语言中的数组类型并不是我们这里说的经典的数据结构中的数组类型。你可以看下js中数组的底层存储模型，实际上，数据是独立存储的，数组只存储数据的指针（或者叫内存地址）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552875727,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76779,"user_name":"小东","can_delete":false,"product_type":"c1","uid":1080466,"ip_address":"","ucode":"1F8300E21A5157","user_header":"https://static001.geekbang.org/account/avatar/00/10/7c/92/63ae5917.jpg","comment_is_top":false,"comment_ctime":1552707313,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552707313","product_id":100017301,"comment_content":"#include&lt;stdio.h&gt;<br><br>int main(int argc, char *argv[]) {<br>    int i = 0;<br>    int arr[3] = {0};<br>    for (; i &lt; 3; ++i) {<br>        arr[i] = 0;<br>        printf(&quot;hello world\\n&quot;);<br>    }<br>    printf(&quot;array base:%p\\n&quot;, (void *)&amp;arr);<br>    printf(&quot;i address %p\\n&quot;, (void *)&amp;i);<br>    printf(&quot;address difference %d\\n&quot;, (int)((void *)&amp;arr - (void *)&amp;i));<br>    return 0;<br>}<br><br>&#47;*<br>运行环境: <br>操作系统: macOS Mojave(64bit)<br>编译器: Apple LLVM version 10.0.0 (clang-1000.11.45.5)<br><br>情况1: 默认编译器开启栈保护<br>编译命令: `gcc Geek_Algorithms_5.c -o program`<br>输出:<br>1: 循环结束条件 i &lt; 3<br>``` <br>hello world<br>hello world<br>hello world<br>array base:0x7ffeeb0bff1c<br>i address 0x7ffeeb0bff04<br>address difference 24<br>```<br><br>2: 循环结束条件 i &lt;=3<br>```<br>hello world<br>hello world<br>hello world<br>hello world<br>array base:0x7ffee3016f1c<br>i address 0x7ffee3016f04<br>address difference 24<br>[1]    93316 abort      .&#47;program<br>```<br>讨论: 这里有gcc默认开启了栈保护，不管i是在数组前面或者后面声明的，i都被会分配到数组的后面。<br>疑问: 这里的地址差为什么是24, 没想明白？<br><br>情况2: 手动关闭栈保护<br>编译命令: `gcc -fno-stack-protector Geek_Algorithms_5.c -o program`<br>输出:<br>1: 循环结束条件 i &lt; 3<br>```<br>hello world<br>hello world<br>hello world<br>array base:0x7ffee5a51f10<br>i address 0x7ffee5a51f1c<br>address difference -12<br>```<br><br>2: 循环结束条件 i &lt;=3<br>```<br>hello world<br>hello world<br>hello world<br>......       &#47;&#47; 遇到循环输出的情况<br>```<br>讨论: 关闭栈保护后，情况就是我们可以理解的那样。栈位于高地址空间，向地址分配新的空间。栈地址分配时是连续压栈。在我的运行环境中 `sizeof(int)` 是4个字节，先分配i变量地址。再分配3个元素的数组地址。数组地址在更低的位置，所以 `-12`也是合理的。<br>*&#47;","like_count":0},{"had_liked":false,"id":75924,"user_name":"GGL","can_delete":false,"product_type":"c1","uid":1215892,"ip_address":"","ucode":"AED10B8248D1E7","user_header":"https://static001.geekbang.org/account/avatar/00/12/8d/94/150dfe78.jpg","comment_is_top":false,"comment_ctime":1552492179,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552492179","product_id":100017301,"comment_content":"C语言中的数组与指针相似，数组名代表的是数组首元素地址，指针可以指向数组的某一元素，对指针使用[]操作完全是可以的，同样也可以对数组名使用*操作；不管是*还是[]其实都是寻址解析内存数据操作。","like_count":0},{"had_liked":false,"id":75855,"user_name":"Z7k","can_delete":false,"product_type":"c1","uid":1238680,"ip_address":"","ucode":"39373D7A6E6EE1","user_header":"https://static001.geekbang.org/account/avatar/00/12/e6/98/5853eb73.jpg","comment_is_top":false,"comment_ctime":1552482177,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552482177","product_id":100017301,"comment_content":"jvm标记清除：标记要回收的对象，然后清除。让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。<br>二维数组为 m*n  则 a[i][j]_address = base_address + (i*m+j)*type_size","like_count":0},{"had_liked":false,"id":75729,"user_name":"孤傲的泥鳅","can_delete":false,"product_type":"c1","uid":1342787,"ip_address":"","ucode":"26B2FED1B1FCEB","user_header":"https://static001.geekbang.org/account/avatar/00/14/7d/43/ac1d10a8.jpg","comment_is_top":false,"comment_ctime":1552459756,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552459756","product_id":100017301,"comment_content":"计算机在寻址的时候,对于m*n的二维数组a<br>的元素a[i][j],如果是行优先存储,会翻译成a[i*n+j]去寻找,也就是你提到的公式,如果是列优先,比如matlab这种,就会翻成a[j*m+i]的形式, 感觉应该是这样理解的吧","like_count":0},{"had_liked":false,"id":74794,"user_name":"teddytyy","can_delete":false,"product_type":"c1","uid":1268738,"ip_address":"","ucode":"E1569D81A4154E","user_header":"https://static001.geekbang.org/account/avatar/00/13/5c/02/e7af1750.jpg","comment_is_top":false,"comment_ctime":1552298994,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552298994","product_id":100017301,"comment_content":"对于a[m][n]：<br>a[i][j]_address = base_address + (i*n+j)*type_size<br>","like_count":0},{"had_liked":false,"id":74565,"user_name":"Geek_68a3d8","can_delete":false,"product_type":"c1","uid":1244905,"ip_address":"","ucode":"A8D4DF5460F50B","user_header":"https://static001.geekbang.org/account/avatar/00/12/fe/e9/8fc7a875.jpg","comment_is_top":false,"comment_ctime":1552238355,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552238355","product_id":100017301,"comment_content":"我记得JAVA二维数组，其实就是一个一维数组（母体），而数组元素是个一维数组（子体）。<br>那么在存储时，这个母体中存的是子体的内存地址，而多个子体间是内存不连续的。<br>所以针对a［i］［j］的内存地址可分两步，第一步拿整个子体（第i个子体）元素的地址，获取该值；第二步以该值为头计算第j个元素地址，并获取到最终结果","like_count":0},{"had_liked":false,"id":74428,"user_name":"小小杨","can_delete":false,"product_type":"c1","uid":1105218,"ip_address":"","ucode":"7E4DC9A782FFD6","user_header":"https://static001.geekbang.org/account/avatar/00/10/dd/42/4a82631e.jpg","comment_is_top":false,"comment_ctime":1552223987,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552223987","product_id":100017301,"comment_content":"虽然做java开发，但是对jvm的垃圾回收没有深入了解。标记删除应该和老师讲的一样，如果插入新的元素发现没有可用空间，优先利用已删除元素的空间。jvm应该也是发现内存不足，触发垃圾回收。<br>假设二维数组的为n行m列，第i行j列的寻址为：baseadress+(i*m+j)*data_typesize","like_count":0},{"had_liked":false,"id":74303,"user_name":"张珂","can_delete":false,"product_type":"c1","uid":1451555,"ip_address":"","ucode":"63D5760B253A59","user_header":"https://static001.geekbang.org/account/avatar/00/16/26/23/e99ff49f.jpg","comment_is_top":false,"comment_ctime":1552184871,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552184871","product_id":100017301,"comment_content":"对于jvm的底层不了解，只知道当程序中不存在一个对象的有效引用时，该对象就会被垃圾回收机制回收","like_count":0},{"had_liked":false,"id":74264,"user_name":"skying","can_delete":false,"product_type":"c1","uid":1041865,"ip_address":"","ucode":"E7CFF50AB64BB1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e5/c9/1061582b.jpg","comment_is_top":false,"comment_ctime":1552149081,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1552149081","product_id":100017301,"comment_content":"@作者，示例中的 数组插入指定序号的元素，应该不影响指定位置 后元素的顺序吧。<br><br>我们现在需要将元素 x 插入到第 3 个位置。我们只需要将 ...<br><br>极客时间版权所有: https:&#47;&#47;time.geekbang.org&#47;column&#47;article&#47;0?cid=126","like_count":0},{"had_liked":false,"id":73513,"user_name":"looper","can_delete":false,"product_type":"c1","uid":1162159,"ip_address":"","ucode":"899D50A315BCAE","user_header":"https://static001.geekbang.org/account/avatar/00/11/bb/af/2624cc07.jpg","comment_is_top":false,"comment_ctime":1551919376,"is_pvip":false,"replies":[{"id":"26795","content":"不同的语言，实现方式不一样的。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551924478,"ip_address":"","comment_id":73513,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551919376","product_id":100017301,"comment_content":"关于二维数组的存储，感觉应该是 分别创建几个一维数组，然后在创建一个一维数组来存储这几个一维数组的首地址。 所以这几个一维数组应该是可以不连续的。  不知道这样分析的对还是错，请老师指点一下","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442122,"discussion_content":"不同的语言，实现方式不一样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551924478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73394,"user_name":"绝影","can_delete":false,"product_type":"c1","uid":1437760,"ip_address":"","ucode":"EA3C85D21DE210","user_header":"https://static001.geekbang.org/account/avatar/00/15/f0/40/219be32a.jpg","comment_is_top":false,"comment_ctime":1551876681,"is_pvip":false,"replies":[{"id":"26787","content":"是的，👍，考虑的很全面！","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551923951,"ip_address":"","comment_id":73394,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551876681","product_id":100017301,"comment_content":"对于 m * n 的数组，如果数组以行为主a [ i ][ j ] (i &lt; m,j &lt; n)的地址为：<br><br>address = base_address + ( i * n + j) * type_size<br>如果以列为主a [ i ][ j ] (i &lt; m,j &lt; n)的地址为：<br><br>address = base_address + ( j*m+i) * type_size是这样吗","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442062,"discussion_content":"是的，👍，考虑的很全面！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551923951,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73170,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1551835050,"is_pvip":false,"replies":[{"id":"26808","content":"是的，要遍历一遍。但是，数据的搬移就少了。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551926194,"ip_address":"","comment_id":73170,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551835050","product_id":100017301,"comment_content":"为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。<br><br><br>虽然加了标记，但是最终怎么去锁定那些标记的要删除的数据呢？是不是要遍历一次求数组找到要删除的数据？如果是这样的话，时间复杂度也是O(n)啊","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441947,"discussion_content":"是的，要遍历一遍。但是，数据的搬移就少了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551926194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72936,"user_name":"-Violet Evergarden-","can_delete":false,"product_type":"c1","uid":1182731,"ip_address":"","ucode":"B483A3ACFB36F8","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/0b/1ccc90b7.jpg","comment_is_top":false,"comment_ctime":1551756712,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551756712","product_id":100017301,"comment_content":"总结一下该课内容<br><br>1. 为什么数组下标从0开始而不是从1开始 (从内存寻址公式入手)<br>2. 数组的优势在于根据下标随机访问的时间复杂度为O(1)<br>3. 如何优化数组的插入和删除的效率 (引出JVM标记清除算法)<br>4. ArrayList等容器于普通数组的优劣。优: 封装了数组的很多操作，如扩容删除等。 劣: 开箱封箱操作效率等，以及多维数组的表示不如普通数组省事","like_count":0},{"had_liked":false,"id":72649,"user_name":"等待戈多","can_delete":false,"product_type":"c1","uid":1445564,"ip_address":"","ucode":"80092A3352F9AA","user_header":"https://static001.geekbang.org/account/avatar/00/16/0e/bc/97606317.jpg","comment_is_top":false,"comment_ctime":1551685409,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551685409","product_id":100017301,"comment_content":"对于链表的插入和删除，我觉得应该说的具体些吧，要找到插入的位置和删除的位置，也需要一个循环遍历链表，然后找到确定的问题，进行插入或者删除。","like_count":0},{"had_liked":false,"id":72324,"user_name":"大豆腐","can_delete":false,"product_type":"c1","uid":1244050,"ip_address":"","ucode":"1E8D4F938F9AEA","user_header":"https://static001.geekbang.org/account/avatar/00/12/fb/92/e3b0e597.jpg","comment_is_top":false,"comment_ctime":1551586701,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551586701","product_id":100017301,"comment_content":"由于基础薄弱,看老师的专栏,只能对老师讲解的内容了解个大概,对于内存模型还有编译器方面的内容完全没有概念,但是看完专栏,认真看评论区的留言,也觉得收获多多.","like_count":0},{"had_liked":false,"id":72223,"user_name":"L.D","can_delete":false,"product_type":"c1","uid":1222769,"ip_address":"","ucode":"7406DD521E2818","user_header":"https://static001.geekbang.org/account/avatar/00/12/a8/71/f7faef63.jpg","comment_is_top":false,"comment_ctime":1551536947,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551536947","product_id":100017301,"comment_content":"不得不说，老师将JVM标记清除垃圾回收算法与数组结构的删除操作关联起来那一刻，突然就想到一句话“大繁至简”，互联网万变不离其宗。<br><br>标记-清除算法：<br>垃圾回收器会从堆栈，静态存储区出发，遍历所有引用，从而找出所有存活的对象，为每个存活对象加上标记，在所有存活对象标记完成后，直接释放未被标记的对象实例，得到一段不连续的内存空间。<br>通常来说，标记-清除算法经常与停止-复制算法搭配干活，停止-复制算法会将所有存活对象从旧堆中复制到一个新堆中，然后清空旧堆对象。","like_count":0},{"had_liked":false,"id":72146,"user_name":"小太白","can_delete":false,"product_type":"c1","uid":1041975,"ip_address":"","ucode":"96C1A35BCDAA0F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e6/37/74ec8fbb.jpg","comment_is_top":false,"comment_ctime":1551528724,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1551528724","product_id":100017301,"comment_content":"Object[i][j]_address= Object_baseAddress+ i*iTypeSize + j*jTypeSize<br>","like_count":0},{"had_liked":false,"id":71609,"user_name":"Valor","can_delete":false,"product_type":"c1","uid":1220431,"ip_address":"","ucode":"80E92953C6F5F7","user_header":"https://static001.geekbang.org/account/avatar/00/12/9f/4f/c0574d23.jpg","comment_is_top":false,"comment_ctime":1551401119,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551401119","product_id":100017301,"comment_content":"通俗易懂，谢谢老师。","like_count":0},{"had_liked":false,"id":71109,"user_name":"Aven","can_delete":false,"product_type":"c1","uid":1066230,"ip_address":"","ucode":"E2B1D0B57F18D1","user_header":"https://static001.geekbang.org/account/avatar/00/10/44/f6/60f948e1.jpg","comment_is_top":false,"comment_ctime":1551267165,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1551267165","product_id":100017301,"comment_content":"买争哥的极客时间也有段时间了，终于腾出时间来听一听，字里行间对数组的讲解还是非常透彻的，看完整篇文章后心中略有几个疑问，想不到在翻阅留言板的过程中，被大牛们全解决了，第一次感受到留言区的作用，真的很感动，与大牛们一起学习这门课，应该是件很激动的事情，为自己加油！","like_count":0},{"had_liked":false,"id":70718,"user_name":"A0.何文祥","can_delete":false,"product_type":"c1","uid":1052569,"ip_address":"","ucode":"2549126DAEA15D","user_header":"https://static001.geekbang.org/account/avatar/00/10/0f/99/0d72321f.jpg","comment_is_top":false,"comment_ctime":1551168963,"is_pvip":false,"replies":[{"id":"25399","content":"IPAD paper","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551232462,"ip_address":"","comment_id":70718,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551168963","product_id":100017301,"comment_content":"画图工具牛","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440792,"discussion_content":"IPAD paper","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551232462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":70170,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1551021121,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551021121","product_id":100017301,"comment_content":"就是标记清除法的原理，我们不是一有垃圾就下楼倒掉而是进行把垃圾扔进垃圾桶，进行标记，知道垃圾满了才打包倒掉，哈哈","like_count":0},{"had_liked":false,"id":69937,"user_name":"小孩","can_delete":false,"product_type":"c1","uid":1112367,"ip_address":"","ucode":"A7F587FC641E63","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/2f/01b32495.jpg","comment_is_top":false,"comment_ctime":1550911493,"is_pvip":false,"replies":[{"id":"25054","content":"根据下标查找是O(1)的。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551060920,"ip_address":"","comment_id":69937,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1550911493","product_id":100017301,"comment_content":"数组根据下标查找，不是类似索引吗，为什么复杂度不是O（1）","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440363,"discussion_content":"根据下标查找是O(1)的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551060920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":69731,"user_name":"MarlboroKay","can_delete":false,"product_type":"c1","uid":1099304,"ip_address":"","ucode":"3F6B5861795A61","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/28/d6f49ec2.jpg","comment_is_top":false,"comment_ctime":1550822086,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550822086","product_id":100017301,"comment_content":"结合之前学的知识，个人认为：<br>一维数组的空间复杂度为O(n);<br>二维数组的空间复杂度为O(m*n);","like_count":0},{"had_liked":false,"id":69704,"user_name":"LEO","can_delete":false,"product_type":"c1","uid":1396809,"ip_address":"","ucode":"4268DB35C3F3E9","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/49/898cb635.jpg","comment_is_top":false,"comment_ctime":1550813265,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550813265","product_id":100017301,"comment_content":"看了才知道，原来ElasticSearch的删除索引操作也用到了JVM的标记删除的思想，哈哈","like_count":0},{"had_liked":false,"id":68653,"user_name":"Jamin","can_delete":false,"product_type":"c1","uid":1236792,"ip_address":"","ucode":"0449B773FE4D21","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJhyK1QiaqyNox3wr3GmBibziau9pPDxN5HjYBpYCd7ytDmLNtJ1cKKaq2WYFF3jpRSg6638M8NFDf2w/132","comment_is_top":false,"comment_ctime":1550567954,"is_pvip":false,"replies":[{"id":"24627","content":"base_address是第一个元素的地址呢，k+1怎么理解呢？","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1550720021,"ip_address":"","comment_id":68653,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1550567954","product_id":100017301,"comment_content":"但是，如果数组从 1 开始计数，那我们计算数组元素 a[k] 的内存地址就会变为：<br>a[k]_address = base_address + (k-1)*type_size<br><br>这块为啥不能是<br>a[k]_address = base_address + (k+1)*type_size<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439781,"discussion_content":"base_address是第一个元素的地址呢，k+1怎么理解呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550720021,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":68632,"user_name":"cnhjq","can_delete":false,"product_type":"c1","uid":1285923,"ip_address":"","ucode":"C9913D5F069EF4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoMlOBZg2HYWh4Fu5dCXlmHmQ67YG9H3hbjBwuicltia18flYHiaYZ2c1aqNsPVp8Ttqo5Qc8NiaEvFZg/132","comment_is_top":false,"comment_ctime":1550563138,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550563138","product_id":100017301,"comment_content":"提两个问题供大家思考：<br>1、为什么Vector&#47;ArrayList采用2倍&#47;1.5倍扩容方式，是否可以以3倍、4倍扩容？<br>2、为什么Vector&#47;ArrayList采用倍数扩容方式，是否可以固定大小扩容？","like_count":0},{"had_liked":false,"id":68627,"user_name":"张茜","can_delete":false,"product_type":"c1","uid":1175328,"ip_address":"","ucode":"9D9BF8AEAC4754","user_header":"https://static001.geekbang.org/account/avatar/00/11/ef/20/17b888bc.jpg","comment_is_top":false,"comment_ctime":1550561990,"is_pvip":false,"replies":[{"id":"24820","content":"这个能否回答你的问题呢：<br>https:&#47;&#47;twodam.net&#47;why-non-private-can-simlify-nested-class-access","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1550831998,"ip_address":"","comment_id":68627,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1550561990","product_id":100017301,"comment_content":"老师您好，请问为什么ArrayList中的elementData为什么没有private修饰？源码中的注释为non-private to simplify nested class access，为了嵌套类可达。可是即使外部类的成员变量为private，非静态嵌套类依然可达。我以为默认可见性是为了同文件中其他顶级类可达，然而ArrayList中也没有其他的顶级类。谢谢老师。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439762,"discussion_content":"这个能否回答你的问题呢：\nhttps://twodam.net/why-non-private-can-simlify-nested-class-access","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550831998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":68169,"user_name":"阿信","can_delete":false,"product_type":"c1","uid":1389604,"ip_address":"","ucode":"50616ED68A5B40","user_header":"https://static001.geekbang.org/account/avatar/00/15/34/24/34ca1d23.jpg","comment_is_top":false,"comment_ctime":1550453352,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550453352","product_id":100017301,"comment_content":"a[m][n]_adress=base_adress+type_size*(m*n+n)","like_count":0},{"had_liked":false,"id":67695,"user_name":"___","can_delete":false,"product_type":"c1","uid":1228457,"ip_address":"","ucode":"F6B9BAB2F1B95E","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/a9/dea56349.jpg","comment_is_top":false,"comment_ctime":1550223946,"is_pvip":false,"replies":[{"id":"24759","content":"n表示第一维的大小，你可以举个例子看看。这里默认是按行存储的。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1550810540,"ip_address":"","comment_id":67695,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1550223946","product_id":100017301,"comment_content":"二维数组的内存寻址为什么是这个:address = base_address + ( i * n + j) * type_size  ,我怎么觉得是 i*m呢? 望老师回复","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439333,"discussion_content":"n表示第一维的大小，你可以举个例子看看。这里默认是按行存储的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550810540,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":66636,"user_name":"千山2018","can_delete":false,"product_type":"c1","uid":1396827,"ip_address":"","ucode":"112C467ED56B52","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/5b/1525d8ed.jpg","comment_is_top":false,"comment_ctime":1549971561,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549971561","product_id":100017301,"comment_content":"相见恨晚鸭","like_count":0},{"had_liked":false,"id":65853,"user_name":"一只牛","can_delete":false,"product_type":"c1","uid":1397092,"ip_address":"","ucode":"1048D66A8A3F0D","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/64/47c19133.jpg","comment_is_top":false,"comment_ctime":1549701543,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549701543","product_id":100017301,"comment_content":"为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移，只是记录数据已经被删除。当数组没有更多空间存储时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。<br>这句话不理解.  怎么记录下已经删除的数据?统一删除的话java也不能实现啊?数组没有更多空间存储时再删除指的是数组的长度都被用完了么?那此时统一删除,是异步的啊?","like_count":0},{"had_liked":false,"id":65569,"user_name":"马海滨","can_delete":false,"product_type":"c1","uid":1389112,"ip_address":"","ucode":"5126DE40C5A635","user_header":"","comment_is_top":false,"comment_ctime":1549460181,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549460181","product_id":100017301,"comment_content":"首先：对于内存对象的清除是比较耗时间的，所以采取对未可达对象进行标记，然后到达一定时间之后进行清楚，并且重新整理对象池<br><br><br>base_address+ i*j*type_size + j*","like_count":0},{"had_liked":false,"id":65293,"user_name":"Pre-Y","can_delete":false,"product_type":"c1","uid":1396900,"ip_address":"","ucode":"A13D13A37F3ABC","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/a4/8d2e454b.jpg","comment_is_top":false,"comment_ctime":1549205098,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549205098","product_id":100017301,"comment_content":"今日份的打卡。<br>👀看了评论区的大佬们的解答，不禁感叹所知甚少。<br>对于二维数组A[x1-x2][y1-y2]，求A[i][j]的地址<br>已知locA[x1][y1]，每个元素占k个存储单元<br>locA[i][j]＝locA[x1][y1]+[（y2-y1+1）*（i-x1）+（j-y1）]*k<br>","like_count":0},{"had_liked":false,"id":65180,"user_name":"谭晓龙","can_delete":false,"product_type":"c1","uid":1306765,"ip_address":"","ucode":"D71200DD29B4C0","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epZ0KJAWQ5OtibzXaeOLbvG2icASHialeB96via6lCafNNRXAG7u3UYJ0gZPWESU1iaPMYrXZUReqwW9Cg/132","comment_is_top":false,"comment_ctime":1549091371,"is_pvip":false,"replies":[{"id":"24291","content":"root就是指没有被引用的内存对象。这个都是JVM系统对象。我自己是这么理解的。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1550542463,"ip_address":"","comment_id":65180,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1549091371","product_id":100017301,"comment_content":"一直不理解垃圾回收的标记阶段一开始那个root是指什么？老师能解释一下吗？？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438349,"discussion_content":"root就是指没有被引用的内存对象。这个都是JVM系统对象。我自己是这么理解的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550542463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":65040,"user_name":"Mingjie","can_delete":false,"product_type":"c1","uid":1356943,"ip_address":"","ucode":"0B83CD820E5F61","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLwVgXx5UCmXuUJIibytjfxlfia7XJBX6ricaVuGpAREA9fm8mK7WwKXEzictLQRIicvrIgRCGtrwfsS9g/132","comment_is_top":false,"comment_ctime":1549009801,"is_pvip":false,"replies":[{"id":"24300","content":"貌似没有。散列表有的。也就是hashmap","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1550542875,"ip_address":"","comment_id":65040,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1549009801","product_id":100017301,"comment_content":"我有一个问题：JVM中有ArrayList扩容方法，有没有缩减的方法？想缩减肯定是能实现的，不知道在实际应用中会不会考虑到这个问题？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438290,"discussion_content":"貌似没有。散列表有的。也就是hashmap","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550542875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":65035,"user_name":"衬衫的价格是19美元","can_delete":false,"product_type":"c1","uid":1397631,"ip_address":"","ucode":"655F925451F772","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKVUskibDnhMt5MCIJ8227HWkeg2wEEyewps8GuWhWaY5fy7Ya56bu2ktMlxdla3K29Wqia9efCkWaQ/132","comment_is_top":false,"comment_ctime":1549008791,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549008791","product_id":100017301,"comment_content":"数组是最基本的数据结构，与编程语言没有关系<br>每种编程语言都提供了自己的类来实现数组的功能，比如Java 有ArrayList；python 有list<br>所以，当我们说数据结构的时候，我们说的是基础的数据结构，而不是由语言实现的某种类<br>","like_count":0},{"had_liked":false,"id":65027,"user_name":"a檬檬檬檬奇","can_delete":false,"product_type":"c1","uid":1396692,"ip_address":"","ucode":"802160A94BE924","user_header":"https://static001.geekbang.org/account/avatar/00/15/4f/d4/6b31cfc3.jpg","comment_is_top":false,"comment_ctime":1549006722,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549006722","product_id":100017301,"comment_content":"用Java编写代码使用数组需要事先定义数组大小，所以，在Java语言中，其实是没有办法直接往一个数组插入或删除数据的，只有通过复制数组的方法才能实现插入或删除数据的问题，也就是说，在Java中，不管插入或删除的数据在哪个位置，都需要循环n＋1或循环n-1次，是不是这样子？虽然时间复杂度依然是O(n)。","like_count":0},{"had_liked":false,"id":64818,"user_name":"颇忒妥","can_delete":false,"product_type":"c1","uid":1026448,"ip_address":"","ucode":"AA86AD1049BC2E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a9/90/0c5ed3d9.jpg","comment_is_top":false,"comment_ctime":1548917994,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548917994","product_id":100017301,"comment_content":"对于二维数组 a[m][n]<br>a[i][j]_addr = base_addr + (i * n + j) * type_size<br><br>对于三维数组 a[m][n][p]<br>a[i][j][k]_addr = base_addr + (i * n * p + j * p + k) * type_size","like_count":0},{"had_liked":false,"id":64726,"user_name":"linux驱动层","can_delete":false,"product_type":"c1","uid":1391619,"ip_address":"","ucode":"E0E2E54E5E46A0","user_header":"https://static001.geekbang.org/account/avatar/00/15/3c/03/fd1e6638.jpg","comment_is_top":false,"comment_ctime":1548893004,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548893004","product_id":100017301,"comment_content":"那个数组越界造成的无限循环的原因是因为，数组越界的过程中，对a〔i〕赋值，会造成对i赋值，即i＝0，i永远达不到循环结束的条件，所以造成了无限循环。","like_count":0},{"had_liked":false,"id":64692,"user_name":"高山高","can_delete":false,"product_type":"c1","uid":1120547,"ip_address":"","ucode":"4F1D91E3C3FBB9","user_header":"https://static001.geekbang.org/account/avatar/00/11/19/23/849beae4.jpg","comment_is_top":false,"comment_ctime":1548860434,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548860434","product_id":100017301,"comment_content":"置顶的杰杰同学的留言，有一些描述是不准确的，标记-清除算法执行标记时，标记的是需要回收的对象","like_count":0},{"had_liked":false,"id":64226,"user_name":"晓龙","can_delete":false,"product_type":"c1","uid":1004576,"ip_address":"","ucode":"78CDCEBD183D3A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/20/93c79f7c.jpg","comment_is_top":false,"comment_ctime":1548722930,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548722930","product_id":100017301,"comment_content":"二维数组：int a[n][m]<br>for i in n<br>  for j in m<br>     line = n * sizeof( int)<br>     value = a + line + j * sizeof(int)","like_count":0},{"had_liked":false,"id":63598,"user_name":"Henry","can_delete":false,"product_type":"c1","uid":1327275,"ip_address":"","ucode":"F4C38220B91A59","user_header":"https://static001.geekbang.org/account/avatar/00/14/40/ab/0aafd926.jpg","comment_is_top":false,"comment_ctime":1548411939,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548411939","product_id":100017301,"comment_content":"数组不应该是连续的吗？如果 a b c d e 插入 x 变成 a b x d e c，岂不是改变了存储顺序，那么 array[3] 依然跟插入之前一样（都是 d ，插入后，array[3] 就当是 c 吧？）。删除部分同理。不明白@_@","like_count":0},{"had_liked":false,"id":62980,"user_name":"康斯坦丁","can_delete":false,"product_type":"c1","uid":1368096,"ip_address":"","ucode":"C130E800E8D5C9","user_header":"https://static001.geekbang.org/account/avatar/00/14/e0/20/003190c1.jpg","comment_is_top":false,"comment_ctime":1548219220,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548219220","product_id":100017301,"comment_content":"标记清除算法，可达性分析标记&#47; 清除内存空间. 有碎片问题.<br><br>对于 o * t的数组<br>a[k][j]_address = base_address + k * t * type_size + j * type_size.","like_count":0},{"had_liked":false,"id":61878,"user_name":"双子座的马克思","can_delete":false,"product_type":"c1","uid":1150663,"ip_address":"","ucode":"4D43FB644E9870","user_header":"https://static001.geekbang.org/account/avatar/00/11/8e/c7/6d08d502.jpg","comment_is_top":false,"comment_ctime":1547826195,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547826195","product_id":100017301,"comment_content":"如果内存中的数据在一段时间后没有被引用了，该数据就会被垃圾回收器回收。结合今天的课来看，是这些未被引用的数据在内存中被标记为了删除，当垃圾回收器空间满了后，就像数组的清除一样，被统一清除，减少执行次数，提高效率。在进一步讲，当垃圾回收器频繁执行删除数据时，就会出现程序卡顿的情况。","like_count":0},{"had_liked":false,"id":61875,"user_name":"双子座的马克思","can_delete":false,"product_type":"c1","uid":1150663,"ip_address":"","ucode":"4D43FB644E9870","user_header":"https://static001.geekbang.org/account/avatar/00/11/8e/c7/6d08d502.jpg","comment_is_top":false,"comment_ctime":1547825783,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547825783","product_id":100017301,"comment_content":"我对“随机访问”的理解：通过下标访问数组中的元素，下标值是随机的，访问就是随机的，","like_count":0},{"had_liked":false,"id":61873,"user_name":"双子座的马克思","can_delete":false,"product_type":"c1","uid":1150663,"ip_address":"","ucode":"4D43FB644E9870","user_header":"https://static001.geekbang.org/account/avatar/00/11/8e/c7/6d08d502.jpg","comment_is_top":false,"comment_ctime":1547825545,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547825545","product_id":100017301,"comment_content":"确实是，0是计算机中非常重要的数字，不从0开始总感觉不完整","like_count":0},{"had_liked":false,"id":61850,"user_name":"海军上校","can_delete":false,"product_type":"c1","uid":1104290,"ip_address":"","ucode":"7B0D9EC01A3F36","user_header":"https://static001.geekbang.org/account/avatar/00/10/d9/a2/afbc447c.jpg","comment_is_top":false,"comment_ctime":1547819369,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547819369","product_id":100017301,"comment_content":"看评论也涨姿势～内存对齐一直不是很懂～","like_count":0},{"had_liked":false,"id":61801,"user_name":"linluu","can_delete":false,"product_type":"c1","uid":1360974,"ip_address":"","ucode":"BCAEFD0BEB2D64","user_header":"","comment_is_top":false,"comment_ctime":1547803017,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547803017","product_id":100017301,"comment_content":"想问个问题：数组查找为a[i]_address = base_address + i * data_type_size<br> def find(f):<br>                    list = [x for x in range(n)]<br>                    addr  =  1000  # 首个内存空间地址<br>                    data_size = 3 # 数据大小<br>                    for X in range(len(list)):<br>                        if list[x] == f:<br>                            return addr + data_size * X<br>这是用python写的按照这种说法 那么数组为何是O(logn)而不是O(n)","like_count":0},{"had_liked":false,"id":61628,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1018370,"ip_address":"","ucode":"7A488CC6FE15E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","comment_is_top":false,"comment_ctime":1547737690,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547737690","product_id":100017301,"comment_content":"JVM标记清除算法分为两个阶段：标记和清除。首先标记出需要被回收的所有对象，再标记完成之后统一做回收处理。但是该算法有两个缺点：一个是效率不高，无论是标记或是清除。另一个是会产生内存碎片。如果后期申请较大内存时，无法申请到合适大小的内存时会提前触发另一个垃圾收集动作。","like_count":0},{"had_liked":false,"id":61482,"user_name":"双子座的马克思","can_delete":false,"product_type":"c1","uid":1150663,"ip_address":"","ucode":"4D43FB644E9870","user_header":"https://static001.geekbang.org/account/avatar/00/11/8e/c7/6d08d502.jpg","comment_is_top":false,"comment_ctime":1547706441,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547706441","product_id":100017301,"comment_content":"计算机中的内存地址是连续的字节数据，字节是由比特组成，比特是0和1，又到了光信号的低电平和高电平","like_count":0},{"had_liked":false,"id":61463,"user_name":"慧慧","can_delete":false,"product_type":"c1","uid":1375821,"ip_address":"","ucode":"C1CDB9BF4564C7","user_header":"https://static001.geekbang.org/account/avatar/00/14/fe/4d/e5c33794.jpg","comment_is_top":false,"comment_ctime":1547703118,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547703118","product_id":100017301,"comment_content":"想知道oc或者Java中用的是标记删除还是低效删除","like_count":0},{"had_liked":false,"id":59993,"user_name":"Apollo","can_delete":false,"product_type":"c1","uid":1183821,"ip_address":"","ucode":"3A0C79CCB21FD9","user_header":"https://static001.geekbang.org/account/avatar/00/12/10/4d/f548bc68.jpg","comment_is_top":false,"comment_ctime":1547435238,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547435238","product_id":100017301,"comment_content":"写的很深入，最近刚看了嵌入式boot loader 的实现相关内容，以及C语言环境的构建，arm 的满降栈的实现，以及看了前几个大牛的分析对这个问题的理解就不一样了","like_count":0},{"had_liked":false,"id":59255,"user_name":"我是一个见谁爱谁的坏小孩","can_delete":false,"product_type":"c1","uid":1362392,"ip_address":"","ucode":"1E7DC41C4D6CF4","user_header":"https://static001.geekbang.org/account/avatar/00/14/c9/d8/e54f0e27.jpg","comment_is_top":false,"comment_ctime":1547343746,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547343746","product_id":100017301,"comment_content":"老师写的很详细很棒 补起了当年数据结构的痛啊","like_count":0},{"had_liked":false,"id":58950,"user_name":"saber","can_delete":false,"product_type":"c1","uid":1193468,"ip_address":"","ucode":"D02F8D129DB41C","user_header":"https://static001.geekbang.org/account/avatar/00/12/35/fc/6d3e0035.jpg","comment_is_top":false,"comment_ctime":1547258645,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547258645","product_id":100017301,"comment_content":"我在linux下实验无线循环那个代码，发现即使关闭堆栈保护。也只是打印 4 次。而且我打印地址信息，发现他们离的大概有16个字节远。建议老师下次再有这种实验时能够指出在什么情况下会出现某种现象。","like_count":0},{"had_liked":false,"id":57122,"user_name":"Simon少明","can_delete":false,"product_type":"c1","uid":1358133,"ip_address":"","ucode":"F7ABE6DE4E55DE","user_header":"https://static001.geekbang.org/account/avatar/00/14/b9/35/96fb49d6.jpg","comment_is_top":false,"comment_ctime":1546654765,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546654765","product_id":100017301,"comment_content":"这边查了下PHP关于数组的资料：<br>1.PHP5.3以后在SPL扩展中提供了SplFixedArray，这个数组更接近于文中说的数组结构，性能更接近于C语言，不同的是数组中存储类型可以不同。<br>2.我们经常使用的数组其实是用哈希表实现的<br>总结：<br>底层或注重性能可以考虑使用读写性能更优的SplFixedArray，日常使用普通数组即可","like_count":0},{"had_liked":false,"id":56700,"user_name":"zachary","can_delete":false,"product_type":"c1","uid":1349192,"ip_address":"","ucode":"2559469DCF083F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/HRicO9C2gHpCxibedw0370AtpeqE9uo5kkBW4XCrsF9btibJPIq4vSribYdsjiaOFPK7YMfNmSSdIQlUMXGwgicTLTCg/132","comment_is_top":false,"comment_ctime":1546523840,"is_pvip":false,"replies":[{"id":"21839","content":"第一维应该是连续的，第二维可能不是了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1547708084,"ip_address":"","comment_id":56700,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546523840","product_id":100017301,"comment_content":"对于已经指定了二维的每一维的大小时，随机访问容易写出公式。在 Java 中，初始化二维数组时，高维必须指定，低维是不需要指定的。这种情况下，内存是连续的空间吗？随机访问是如何做到的呢？<br>\t\tint[][] a = new int[3][];<br>\t\ta[1] = new int[5];<br>\t\tSystem.out.println(a[1][2]);","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435182,"discussion_content":"第一维应该是连续的，第二维可能不是了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547708084,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":56640,"user_name":"李军","can_delete":false,"product_type":"c1","uid":1046761,"ip_address":"","ucode":"74FE3AF37E74CD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/e9/f25cce9e.jpg","comment_is_top":false,"comment_ctime":1546514158,"is_pvip":true,"replies":[{"id":"20482","content":"是不是存储的对象的地址呢","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1546566026,"ip_address":"","comment_id":56640,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546514158","product_id":100017301,"comment_content":"js的数组不是真正意义上的数组吗？ var arr = []; 可以存储各种类型啊?","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435163,"discussion_content":"是不是存储的对象的地址呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546566026,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":55422,"user_name":"波波安","can_delete":false,"product_type":"c1","uid":1002452,"ip_address":"","ucode":"2A677908E5A75D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4b/d4/b7719327.jpg","comment_is_top":false,"comment_ctime":1546170222,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1546170222","product_id":100017301,"comment_content":"数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。","like_count":0},{"had_liked":false,"id":55421,"user_name":"波波安","can_delete":false,"product_type":"c1","uid":1002452,"ip_address":"","ucode":"2A677908E5A75D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4b/d4/b7719327.jpg","comment_is_top":false,"comment_ctime":1546170140,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1546170140","product_id":100017301,"comment_content":"二维数组：二维数组假设是m*n， a[i][j]_address=base_address + (i*n+j)*type_size","like_count":0},{"had_liked":false,"id":55420,"user_name":"波波安","can_delete":false,"product_type":"c1","uid":1002452,"ip_address":"","ucode":"2A677908E5A75D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4b/d4/b7719327.jpg","comment_is_top":false,"comment_ctime":1546170139,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1546170139","product_id":100017301,"comment_content":"二维数组：二维数组假设是m*n， a[i][j]_address=base_address + (i*n+j)*type_size","like_count":0},{"had_liked":false,"id":55184,"user_name":"阿章","can_delete":false,"product_type":"c1","uid":1006895,"ip_address":"","ucode":"4A0316F2CB0537","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5d/2f/707c10b5.jpg","comment_is_top":false,"comment_ctime":1546061216,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546061216","product_id":100017301,"comment_content":"在对数组进行数据删除的时候，不是马上删除，而是做一个标记，等到数组没有空间的时候，再把删除的元素真正删除掉，然后移动数组中的元素，可以节约时间，实际上JVM的垃圾回收中的标记清除算法，就是采用了这个思想。","like_count":0},{"had_liked":false,"id":55183,"user_name":"阿章","can_delete":false,"product_type":"c1","uid":1006895,"ip_address":"","ucode":"4A0316F2CB0537","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5d/2f/707c10b5.jpg","comment_is_top":false,"comment_ctime":1546061075,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546061075","product_id":100017301,"comment_content":"如果数组当中的元素没有什么规律，要想在k个位置插入一个元素，可以把原来第k个位置的元素移动到末尾，然后把第k个位置的值设为这个值，这样时间复杂度就是1了，实际上快排就是利用了这个思想。","like_count":0},{"had_liked":false,"id":55180,"user_name":"阿章","can_delete":false,"product_type":"c1","uid":1006895,"ip_address":"","ucode":"4A0316F2CB0537","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5d/2f/707c10b5.jpg","comment_is_top":false,"comment_ctime":1546060549,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546060549","product_id":100017301,"comment_content":"有个面试题问数组和链表的区别，有人说，数组适合查找，时间复杂度是1，链表适合插入和删除，时间复杂度是1，其实这种表述是错误的，数组是适合随机访问，随机访问的时间复杂度是1，而查找即使是排序好的数组采用二分查找时间复杂度也是n*lgn","like_count":0},{"had_liked":false,"id":55171,"user_name":"想想คิดถึง","can_delete":false,"product_type":"c1","uid":1323770,"ip_address":"","ucode":"E13BD3DCEC8EB2","user_header":"https://static001.geekbang.org/account/avatar/00/14/32/fa/71c460d9.jpg","comment_is_top":false,"comment_ctime":1546057572,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546057572","product_id":100017301,"comment_content":"没学过JVM，JAVA暂且不提，；二维数组寻址公式需要好好想。","like_count":0},{"had_liked":false,"id":54632,"user_name":"LadyForest","can_delete":false,"product_type":"c1","uid":1348673,"ip_address":"","ucode":"17D9198016DD7C","user_header":"https://static001.geekbang.org/account/avatar/00/14/94/41/be0af1c4.jpg","comment_is_top":false,"comment_ctime":1545919496,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545919496","product_id":100017301,"comment_content":"假设有二维数组a[m][n] , 则address[i][j] = base_address + (n * i + j) * type_ size, 其中 0 &lt;= i &lt;= m, 0 &lt;= j &lt; n","like_count":0},{"had_liked":false,"id":54576,"user_name":"achenbj","can_delete":false,"product_type":"c1","uid":1178990,"ip_address":"","ucode":"E5A4F7EB173C2F","user_header":"","comment_is_top":false,"comment_ctime":1545903499,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545903499","product_id":100017301,"comment_content":"对于数据结构真是一点看不进去怎么破...","like_count":0},{"had_liked":false,"id":54460,"user_name":"achenbj","can_delete":false,"product_type":"c1","uid":1178990,"ip_address":"","ucode":"E5A4F7EB173C2F","user_header":"","comment_is_top":false,"comment_ctime":1545874590,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545874590","product_id":100017301,"comment_content":"看了您git上面的代码，就是拿着数组实现了一个Array类；<br>就是基本实现list的方式，这么理解对吗？","like_count":0},{"had_liked":false,"id":53813,"user_name":"hoyouly","can_delete":false,"product_type":"c1","uid":1353976,"ip_address":"","ucode":"706521C81CF211","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PKhYJtPJpdAYMXkho8yibaudUf1AgGb1zJoo7pIAy2NabuHZWuB5viauZUm0dF7kpxx3nTdQsiboYgAhmvFzjg5YQ/132","comment_is_top":false,"comment_ctime":1545733547,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545733547","product_id":100017301,"comment_content":"二维数组内存寻址方式，尽管叫二维数组，其实在内存中也是一个线性结构，<br>例如int arr[2][3],在内存中存放的顺序就是arr[0][0],arr[0][1],arr[0][2],arr[1][0],arr[1][1],arr[1][2],和数组int arr1[6],内存中存放顺序是一致的，所以arr[1][1]的内存地址就是：  base_address+(1*3+1)*4<br>总结就是： 数组 array[n][m]中 array[i][j]的地址为 base_address+(i*m+4)*type_size","like_count":0},{"had_liked":false,"id":53674,"user_name":"不专注的linuxer","can_delete":false,"product_type":"c1","uid":1050191,"ip_address":"","ucode":"28ED11C1E2942C","user_header":"https://static001.geekbang.org/account/avatar/00/10/06/4f/14cc4b53.jpg","comment_is_top":false,"comment_ctime":1545708634,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545708634","product_id":100017301,"comment_content":"@slvher，你说Linux是从高到低的地址分配模式，然后说i比a［3］地址大不对吧，应该是i的地址比较小呀，毕竟是数组a先定义的，占据了较高地址空间，然后才是i呀。","like_count":0},{"had_liked":false,"id":53431,"user_name":"俊伟","can_delete":false,"product_type":"c1","uid":1111175,"ip_address":"","ucode":"7905B4F25637F4","user_header":"https://static001.geekbang.org/account/avatar/00/10/f4/87/644c0c5d.jpg","comment_is_top":false,"comment_ctime":1545643649,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1545643649","product_id":100017301,"comment_content":"数组：是一种线性表结构，用一块连续的内存存储相同类型的数据。线性表就是一种数据按一条线一样排列的结构。连续内存指的是一整块连续的内存。<br>一个二维数组连续连续访问的计算公式为：<br>假设数组为a[n][m]访问为i,j的位置<br>base_address + i *(m*size) +  j*size<br>","like_count":0},{"had_liked":false,"id":51828,"user_name":"Yayu","can_delete":false,"product_type":"c1","uid":1058015,"ip_address":"","ucode":"5E7842458D8229","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/df/645f8087.jpg","comment_is_top":false,"comment_ctime":1545267848,"is_pvip":false,"replies":[{"id":"18779","content":"其他语言也有的 都类似 可以自己分析下 我也只是作为一个引子  更多的还是靠自己搜搜研究研究","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545271070,"ip_address":"","comment_id":51828,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545267848","product_id":100017301,"comment_content":"讲到容器数据类型上来就那 Java 举例子，如果没有用过 Java 的同学怎么来理解呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433636,"discussion_content":"其他语言也有的 都类似 可以自己分析下 我也只是作为一个引子  更多的还是靠自己搜搜研究研究","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545271070,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":51801,"user_name":"+@+","can_delete":false,"product_type":"c1","uid":1137873,"ip_address":"","ucode":"58067127007683","user_header":"https://static001.geekbang.org/account/avatar/00/11/5c/d1/9bdd6906.jpg","comment_is_top":false,"comment_ctime":1545264296,"is_pvip":false,"replies":[{"id":"18782","content":"paper","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545271193,"ip_address":"","comment_id":51801,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1545264296","product_id":100017301,"comment_content":"想问下老师 这些图是用什么软件制作的呢 感觉很清晰 很随和","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433625,"discussion_content":"paper","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545271193,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2264679,"avatar":"https://static001.geekbang.org/account/avatar/00/22/8e/67/afb412fb.jpg","nickname":"陈威洋","note":"","ucode":"DCF84B4D3A7354","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351061,"discussion_content":"Ipad paper","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614140897,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":51159,"user_name":"Luke","can_delete":false,"product_type":"c1","uid":1203115,"ip_address":"","ucode":"16DC5BD899CCE5","user_header":"https://static001.geekbang.org/account/avatar/00/12/5b/ab/aac30656.jpg","comment_is_top":false,"comment_ctime":1545122696,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545122696","product_id":100017301,"comment_content":"C# 矩阵数组 本质是一维数组存储 寻址 a[i,j]_address=base_address + i*type_size + j，多维数组就搞不清楚了","like_count":0},{"had_liked":false,"id":51157,"user_name":"Violin","can_delete":false,"product_type":"c1","uid":1140715,"ip_address":"","ucode":"25BA978F662744","user_header":"https://static001.geekbang.org/account/avatar/00/11/67/eb/9a041634.jpg","comment_is_top":false,"comment_ctime":1545122082,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545122082","product_id":100017301,"comment_content":"无限循环那个，在c上栈区是由高到低，堆内存是由低向高，；；理论上在内存中的模型是(由低到高地址)arr[0],arr[1],arr[2],i..... ，但是我在x64 vs2013 vc上试的，发现a[3]的地址并不是和i重合，说明arr[2]与i之间不是连续的，可能是因为对齐问题导致的(因为改成4字节或者8字节，都不重合，但地址确实有差距)","like_count":0},{"had_liked":false,"id":50955,"user_name":"Lisa💓💓","can_delete":false,"product_type":"c1","uid":1350893,"ip_address":"","ucode":"B522FCB5A6E09E","user_header":"https://static001.geekbang.org/account/avatar/00/14/9c/ed/8be154cc.jpg","comment_is_top":false,"comment_ctime":1545093342,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545093342","product_id":100017301,"comment_content":"不懂C++，只会一点点python。代码看不懂，好多理解不了，怎么办呢？","like_count":0},{"had_liked":false,"id":50882,"user_name":"鱼子酱","can_delete":false,"product_type":"c1","uid":1074872,"ip_address":"","ucode":"9D9B33A7B78142","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJic27dia65Z8OdictLLDOWic2fjFtiaQNQ1ou4icQ7AOjic4gK2iaOlYAUkNX7OoFnLs1hr1u5ib4Khcjib4DA/132","comment_is_top":false,"comment_ctime":1545060255,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545060255","product_id":100017301,"comment_content":"1. 什么是数组？<br>数组是一种线性表结构，用一段连续的内存存储一组相同类型的数据元素。<br>线性表结构有数组、链表、队列、栈等。<br><br>2. 数组与链表的区别：数组支持随机访问，时间复杂度为O(1)；而链表适合插入和删除操作，时间复杂度为O(1)。<br><br>3.数组是如何实现随机访问的？<br>数组中元素的内存地址是连续的，可以通过寻址公司得到元素的内存地址：<br>ai[i]_address = base_adress + i * unit_size，<br>因此只要知道索引便可迅速得到对应的内存地址。<br><br>4.为什么数组的插入和删除是低效的？<br><br>数组插入的操作过程：假设向数组的第k个元素插入元素，则首先需要将第k个至最后一个元素全部往后移动，然后才能将元素插入到索引为k的位置。<br>最好时间复杂度：O(1)<br>最坏时间复杂度；O(n)<br>平均时间复杂度：O(n)<br><br>删除操作：跟插入元素类似，删除某个索引元素时，需要将后续的所有元素往前移动。<br>时间复杂度与插图元素的一致。<br><br>5. 高效的插入和删除：<br>当不需要考虑元素的先后顺序时，为了提高效率，在第i的索引插入元素时，可以将原来的索引i对应的元素移到数组的最后，然后将新元素插入到索引i。<br><br>6.什么情况下使用数组和容器？<br>如果是业务开发，建议使用容器，因为容器中封装了很多方法，并支持动态扩容，可以牺牲一点性能换取更高的开发效率；如果是开发底层模块，例如网络连接等，优先考虑性能的时候最好采用数组。<br><br>7.为什么数组的索引一般是从0开始呢？<br>上述介绍的寻址公式是从0开始计算的，假设索引从1开始，则新的公式为：<br>ai[i]_address = base_adress + (i -1) *unit_size，<br>这种情况下需要多执行一次减法操作；另外也有一些历史原因。<br>","like_count":0},{"had_liked":false,"id":50685,"user_name":"abs","can_delete":false,"product_type":"c1","uid":1181674,"ip_address":"","ucode":"04CF4E57913A41","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/ea/b82fd545.jpg","comment_is_top":false,"comment_ctime":1545029831,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545029831","product_id":100017301,"comment_content":"1、数组是一组内存连续、存储相同数据类型、线性的数据结构<br>2、数组按偏移访问的时间复杂度为O(1)，访问公式为<br>    arr[i]首地址=数组首地址+数据类型大小*i ， 其中i为偏移量<br>3、java中使用容器ArrayList尽量指定初始容量，减少不必要的扩容<br>4、使用基本类型数组可以减少封箱拆箱操作，早操作频繁和性能要求高的场景使用<br>5、C语言使用0为下标的原因是根据地址偏移量计算内存地址的是否不需要为偏移量减一，之后语言为了保持习惯，或也出于C语言设计者同样的目的使用0作为下标，但也有一些语言以1作为数组下标<br>6、JVM标记清除算法的优点是每次不需要移动对象，节省每次的清理 时间，但会产生内存碎片，对于对象存活比较多，只有少部分对象死亡的场景比较适用，所以多应用于老年代的垃圾回收。","like_count":0},{"had_liked":false,"id":50681,"user_name":"abs","can_delete":false,"product_type":"c1","uid":1181674,"ip_address":"","ucode":"04CF4E57913A41","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/ea/b82fd545.jpg","comment_is_top":false,"comment_ctime":1545028891,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545028891","product_id":100017301,"comment_content":"看了各位的留言总算理解了，不知道描述的是否准确<br>栈的结构如下，栈底部地址大于栈顶部，所以数组下标越大，地址就越靠近栈底部，<br>由于i首先分配的，所以i的地址比arr[2]大，且类型都是int，如果存在arr[3]的话正好是arr[3]的地址<br>当访问arr[3]的时候越界访问到i<br><br>|||||||||||||||||||||<br>|||||||||||||||||||||<br>|||||||||||||||||||||  空闲空间<br>||||| arr[0] ||||<br>||||| arr[1] ||||<br>||||| arr[2] ||||   arr入栈<br>|||||   i      ||||   i首先入栈<br>     栈<br>","like_count":0},{"had_liked":false,"id":50395,"user_name":"Geek_04e22a","can_delete":false,"product_type":"c1","uid":1184505,"ip_address":"","ucode":"B64FF12EA28BA6","user_header":"https://static001.geekbang.org/account/avatar/00/12/12/f9/7e6e3ac6.jpg","comment_is_top":false,"comment_ctime":1544966043,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544966043","product_id":100017301,"comment_content":"1、java标记清除:gcroot 不可达，标记清除标识，然后统一删除<br>2、二维数组m*n<br>a=base_addr+（i*n+j）","like_count":0},{"had_liked":false,"id":50216,"user_name":"废材","can_delete":false,"product_type":"c1","uid":1347916,"ip_address":"","ucode":"DDB85EACFB257A","user_header":"https://static001.geekbang.org/account/avatar/00/14/91/4c/32c9403c.jpg","comment_is_top":false,"comment_ctime":1544926883,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544926883","product_id":100017301,"comment_content":"gc 判断是否存活，最简单的是用引用数，但是又缺点，如果2个对象相互引用，这样的对象就无法回收，目前大部分的机器都是可达性，这种可达性具体实现是由图实现的。<br>对于gc产生的碎片，在年轻带中，因为复制清理，这种碎片不多；产生碎片主要是老年代，但老年代又标记清理，和标记整理，标记整理会产生的碎片理论上是没有的。<br>具体的清理：内存使用打到了设定的大小，产生gc，首先会标记一次，执行预处理操作，然后又再次标记操作，最后执行删除，这种事老年代执行的gc算法。<br>老师，我理解的对吗？<br>这里有个疑问，线性表是连续的储存空间，但是，链表的结构，决定了链表数据的寻址是由每节链存储的内存地址去寻找上一个，或者下一个，所以，链表不是连续的存储空间存储的吧？","like_count":0},{"had_liked":false,"id":50112,"user_name":"宇","can_delete":false,"product_type":"c1","uid":1350789,"ip_address":"","ucode":"1E79B50CBB21A5","user_header":"https://static001.geekbang.org/account/avatar/00/14/9c/85/9c920838.jpg","comment_is_top":false,"comment_ctime":1544869182,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1544869182","product_id":100017301,"comment_content":"问个小白问题。 这里的讲解数组中元素的数据类型是相同的， 在php中数据的元素类型是不同的， 或者在go中可以定义interface{}类型的切片，像这种数组的任意访问是怎么寻址的呢？","like_count":0},{"had_liked":false,"id":49573,"user_name":"↗晴¤天","can_delete":false,"product_type":"c1","uid":1347956,"ip_address":"","ucode":"CF9C90EF930D72","user_header":"https://static001.geekbang.org/account/avatar/00/14/91/74/aaaa8838.jpg","comment_is_top":false,"comment_ctime":1544718077,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544718077","product_id":100017301,"comment_content":"对于java 标记清除算法，虽然有评论里那位朋友说的缺点，如会产生不连续的内存空间，但标记清除算法可以有效的处理两个互相持有对方引用的对象内存而无法被清除的情况！","like_count":0},{"had_liked":false,"id":49529,"user_name":"🍀Yan的么擦黑烫唔子🐽","can_delete":false,"product_type":"c1","uid":1345684,"ip_address":"","ucode":"EB3B628F1CCA7C","user_header":"https://static001.geekbang.org/account/avatar/00/14/88/94/169d4e44.jpg","comment_is_top":false,"comment_ctime":1544706246,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544706246","product_id":100017301,"comment_content":"jvm 标记清除会产生内存碎片，标记压缩会释放连续内存空间","like_count":0},{"had_liked":false,"id":48476,"user_name":"XiangJiawei","can_delete":false,"product_type":"c1","uid":1324641,"ip_address":"","ucode":"AAC11557A3477B","user_header":"https://static001.geekbang.org/account/avatar/00/14/36/61/8863e18c.jpg","comment_is_top":false,"comment_ctime":1544450350,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1544450350","product_id":100017301,"comment_content":"最大的收获应该是老师提到的数组随机访问快，指的是基于已知下标的前提下。","like_count":0},{"had_liked":false,"id":48379,"user_name":"泉","can_delete":false,"product_type":"c1","uid":1099760,"ip_address":"","ucode":"914709BE802A8D","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/f0/aa2e0749.jpg","comment_is_top":false,"comment_ctime":1544432062,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1544432062","product_id":100017301,"comment_content":"标记清除法分为标记和清除两个过程，java gc会遍历可达的元素，标记为1，然后清除未被标记的，回收内存","like_count":0},{"had_liked":false,"id":47989,"user_name":"‭‭","can_delete":false,"product_type":"c1","uid":1326444,"ip_address":"","ucode":"186811937EE646","user_header":"https://static001.geekbang.org/account/avatar/00/14/3d/6c/935bdc7d.jpg","comment_is_top":false,"comment_ctime":1544282241,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544282241","product_id":100017301,"comment_content":"因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 (1+2+…n)&#47;n=O(n)。不是有n+1插入情况","like_count":0},{"had_liked":false,"id":47867,"user_name":"Mr_杨","can_delete":false,"product_type":"c1","uid":1008065,"ip_address":"","ucode":"AD31C2320DF6A2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/61/c1/9ad88d67.jpg","comment_is_top":false,"comment_ctime":1544240155,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544240155","product_id":100017301,"comment_content":"看似简单，是因为知道的少啊，受教","like_count":0},{"had_liked":false,"id":47840,"user_name":"Zahputor","can_delete":false,"product_type":"c1","uid":1182978,"ip_address":"","ucode":"80BB1D3FEA6F1D","user_header":"https://static001.geekbang.org/account/avatar/00/12/0d/02/4f4484f6.jpg","comment_is_top":false,"comment_ctime":1544234436,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1544234436","product_id":100017301,"comment_content":"老师我有几个问题想请教一下：<br>1.为什么数组执行尾端插入时间复杂度是O（1）而不是O（0），如果说是对插入这个数本身计算了一个复杂度，为什么在数组首部插入不是O（n+1)而是O（n)?还是说这个复杂度是看声明时候的空间a[10]={1,2,3},尾部插入是执行a[3]=x;首部插入是a[0]=x...a[9]=a[8]?<br>2.为什么说在位置K插入一个数可以将k位置的元素放到末尾，那我这样访问数组时候的顺序就变化了吗？比如我数组是还是上面的a，我在1位置插入值4，那数组变成{1,4,3,2},但是我想要的效果是{1,4,2,3}，和我实际想要的效果不同，还是说这边只是说对一个方法的封装？只是一个方法的思路？<br>请老师指点迷津，谢谢！","like_count":0},{"had_liked":false,"id":47443,"user_name":"hzlzh","can_delete":false,"product_type":"c1","uid":1336276,"ip_address":"","ucode":"17FA61C3F87305","user_header":"https://static001.geekbang.org/account/avatar/00/14/63/d4/f44f7015.jpg","comment_is_top":false,"comment_ctime":1544144423,"is_pvip":false,"replies":[{"id":"16914","content":"那个已经不是数组了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1544147422,"ip_address":"","comment_id":47443,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1544144423","product_id":100017301,"comment_content":"我看见很多人的课后总结，对数组的定义，是没经过自己的思考直接照搬原文呢，还是说都是学强类型语言的，像JS的数组中，元素的数据类型就不一定必须要是同一种类型啊！可以是字符串，也可以是整数，浮点数","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431768,"discussion_content":"那个已经不是数组了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544147422,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":47379,"user_name":"小小","can_delete":false,"product_type":"c1","uid":1325647,"ip_address":"","ucode":"8662F061F50923","user_header":"https://static001.geekbang.org/account/avatar/00/14/3a/4f/92df5916.jpg","comment_is_top":false,"comment_ctime":1544139110,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544139110","product_id":100017301,"comment_content":"又一节结束，加油(ง •̀_•́)ง","like_count":0},{"had_liked":false,"id":47237,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1544085616,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544085616","product_id":100017301,"comment_content":"数组这种基础数据结构的精髓是什么？随机存取，指定大小------线性（一前一后） 连续空间，相同数据类型<br>java中有对应的容器<br><br>数组，链表，队列，栈 都是线性表；非线性 图和树<br>数组长于------随机访问------移动数组<br>链表长于------插入删除------遍历<br><br>数组<br>两个思考题都没有答上来：<br>先标记再删除<br><br>来历：结合内存分配特点而存在<br>特点：随机访问，插入删除需要移动，或者标记  <br>适合解决的问题：随机访问<br>实际应用：jvm内存管理","like_count":0},{"had_liked":false,"id":47219,"user_name":"Acrisius","can_delete":false,"product_type":"c1","uid":1136041,"ip_address":"","ucode":"F56302B3D33764","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/a9/08ba9ecd.jpg","comment_is_top":false,"comment_ctime":1544080009,"is_pvip":false,"replies":[{"id":"16929","content":"👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1544148848,"ip_address":"","comment_id":47219,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1544080009","product_id":100017301,"comment_content":"对JVM不太了解，我把这个算法类比成mysql更新操作中redo log跟change buffer的作用，先缓存更新操作，减少对数据IO操作和刷新索引，等到mysql处于闲暇时间或更新操作记录足够多的时候再统一进行更新操作，不是正不正确这个类比","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431700,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544148848,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":47214,"user_name":"zhangxy","can_delete":false,"product_type":"c1","uid":1336582,"ip_address":"","ucode":"0C2747DA59FA35","user_header":"https://static001.geekbang.org/account/avatar/00/14/65/06/9c87322e.jpg","comment_is_top":false,"comment_ctime":1544078189,"is_pvip":false,"replies":[{"id":"16930","content":"存的是指针 不是对象本身","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1544148887,"ip_address":"","comment_id":47214,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1544078189","product_id":100017301,"comment_content":"您好,文中提到的寻址公式a[i]_address = base_address + i * data_type_size.在Object[]中也是适用的吗?毕竟Object[]可以存放任何类型,int,String,各种对象实例等,这时候data_type_size是不是就不一样了?哪位大佬给解惑一下","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431698,"discussion_content":"存的是指针 不是对象本身","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544148887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":46996,"user_name":"力挽狂澜爆炸输出的臭臭宁","can_delete":false,"product_type":"c1","uid":1155904,"ip_address":"","ucode":"E8D26181129BCA","user_header":"https://static001.geekbang.org/account/avatar/00/11/a3/40/e0df3b84.jpg","comment_is_top":false,"comment_ctime":1544016178,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544016178","product_id":100017301,"comment_content":"看到数据插入和删除的优化（尤其引到了JVM垃圾回收上）的时候感觉非常妙，开拓了新思路","like_count":0},{"had_liked":false,"id":46870,"user_name":"飘澪忘川","can_delete":false,"product_type":"c1","uid":1200202,"ip_address":"","ucode":"9539EB60C01F6C","user_header":"https://static001.geekbang.org/account/avatar/00/12/50/4a/50275b50.jpg","comment_is_top":false,"comment_ctime":1543994597,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543994597","product_id":100017301,"comment_content":"读后总结：<br><br>1、数组是什么<br>数组是用来存储一组具有相同类型数据的一组连续内存空间。是一种线性数据结构。<br><br>2、数组的特性以及优缺点<br>特性：连续的内存空间和相同类型的数据。<br>优点：具有随机访问的特性。<br>缺点：删除，插入数据效率低<br><br>3、如何实现随机下标访问<br><br>根据数组内存首地址和每个数组元素的大小去计算<br><br>一维数组：a[i]_address = base_address + i * data_type_size<br>二维数组：Array[m][n]， a[i][j]_address=base_address + (i*n+j)*data_type_size<br><br>4、提高数组的插入删除效率<br>将多次删除操作中集中在一起执行，可以先记录已经删除的数据，但是不进行数据迁移，而仅仅是记录，当发现没有更多空间存储时，再执行真正的删除操作。<br><br>5、数组为什么下标从0开始<br>依据数组实现随机下标访问的原理，如果从1开始，会多执行一次减法运算。这是不必要的浪费。也有一方面历史原因在里面。<br><br>6、文中关于死循环的问题<br>这个在不同的架构上以及不同的编辑器上的结果是不一样的。需要自己动手去试。<br><br>另外，并不懂Java，对JVM没有一点的了解，所以没做总结。","like_count":0},{"had_liked":false,"id":46688,"user_name":"野马","can_delete":false,"product_type":"c1","uid":1065176,"ip_address":"","ucode":"CC58CBF541D34A","user_header":"https://static001.geekbang.org/account/avatar/00/10/40/d8/69722032.jpg","comment_is_top":false,"comment_ctime":1543971636,"is_pvip":false,"replies":[{"id":"16661","content":"操作系统 软件层面的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543973624,"ip_address":"","comment_id":46688,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1543971636","product_id":100017301,"comment_content":"老师好，我想知道内存空间是由计算机中的谁分配的？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431507,"discussion_content":"操作系统 软件层面的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543973624,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":46651,"user_name":"李梵松","can_delete":false,"product_type":"c1","uid":1335291,"ip_address":"","ucode":"D79F33876AE230","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/4RTKnq96jsQoEnUHhBBzVVpib5oNIPHiaLozyKlEH0oLk6D06TNtG6WHWZFiaCaaiac1ojtn5Q4NzZJYfn14vOvd8Q/132","comment_is_top":false,"comment_ctime":1543969347,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543969347","product_id":100017301,"comment_content":"根据我们前面讲的数组寻址公式，a[3] 也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。<br><br>a[3]为何这个地址恰好是变量i的地址呢","like_count":0},{"had_liked":false,"id":46370,"user_name":"小秋","can_delete":false,"product_type":"c1","uid":1243320,"ip_address":"","ucode":"68AC584C14DC95","user_header":"https://static001.geekbang.org/account/avatar/00/12/f8/b8/4df14e11.jpg","comment_is_top":false,"comment_ctime":1543909280,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543909280","product_id":100017301,"comment_content":"老师，这个路径下：algo&#47;c-cpp&#47;05_array&#47;的代码，可以缺少一个array.h文件，现在只有如下三个文件能帮忙补全吗？谢谢您！<br> Array_gp.c <br> Array_gp.h<br> array.c ","like_count":0},{"had_liked":false,"id":46314,"user_name":"何领","can_delete":false,"product_type":"c1","uid":1240298,"ip_address":"","ucode":"F0F2B11CF5C9FA","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/ea/c33e5a3d.jpg","comment_is_top":false,"comment_ctime":1543898836,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543898836","product_id":100017301,"comment_content":"回来再读一遍，第一次看时没弄懂的东西终于懂了，开心！😊<br>但同时也明白了自己基础好差，难过！😔","like_count":0},{"had_liked":false,"id":46062,"user_name":"左胜利","can_delete":false,"product_type":"c1","uid":1327195,"ip_address":"","ucode":"E17B4F4285170D","user_header":"https://static001.geekbang.org/account/avatar/00/14/40/5b/3fe51d4a.jpg","comment_is_top":false,"comment_ctime":1543841019,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543841019","product_id":100017301,"comment_content":"标记清除算法分为两个部分：<br>1、标记：程序将所有的对象引用关系看作一张图，然后从一个GC ROOT开始，寻找对应的引用节点，然后继续寻找此节点对应的引用节点，当所有的节点寻找完后，那些没有没有被遍历到的对象节点就被标记为不可用。<br>2、清理：在标记完成后，统一回收那些被标记的对象<br><br>标记清除算法的优劣势：<br>优势：不需要进行对象的移动，只清理被标记的对象，简单<br>劣势：1、标记和清除的效率都比较低 2、会产生大量的内存碎片，当程序需要为大对象分配内存的时候因为无法找到足够的连续内存而提前触发垃圾搜集的动作。","like_count":0},{"had_liked":false,"id":45945,"user_name":"小秋","can_delete":false,"product_type":"c1","uid":1243320,"ip_address":"","ucode":"68AC584C14DC95","user_header":"https://static001.geekbang.org/account/avatar/00/12/f8/b8/4df14e11.jpg","comment_is_top":false,"comment_ctime":1543823808,"is_pvip":false,"replies":[{"id":"16533","content":"都是其他同学上传的 暂时还没时间整理 不确定能不能运行","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543888126,"ip_address":"","comment_id":45945,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1543823808","product_id":100017301,"comment_content":"老师想问一下，git上c-pp的代码那三个文件可以运行起来吗？是c还是c++","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431284,"discussion_content":"都是其他同学上传的 暂时还没时间整理 不确定能不能运行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543888126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":45854,"user_name":"墨禾","can_delete":false,"product_type":"c1","uid":1216590,"ip_address":"","ucode":"81BA44231AABE8","user_header":"https://static001.geekbang.org/account/avatar/00/12/90/4e/efaea936.jpg","comment_is_top":false,"comment_ctime":1543803635,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543803635","product_id":100017301,"comment_content":"\t\t一般我们都是 这样用index==0，为啥这里要 0 == index，之间有何区别呢？\t<br>                if(0 == index ){<br>\t\t\t\t<br>\t\t\t\tdata[j+1] = tmp[index+1];<br>\t\t\t<br>\t\t\t}else{<br>\t\t\t\t\t<br>\t\t\t\tdata[j+1] = tmp[index-1];<br>\t\t\t\t<br>\t\t\t}","like_count":0},{"had_liked":false,"id":45221,"user_name":"Semon","can_delete":false,"product_type":"c1","uid":1238989,"ip_address":"","ucode":"EAC4329D97369B","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/cd/91126163.jpg","comment_is_top":false,"comment_ctime":1543562234,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543562234","product_id":100017301,"comment_content":"我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。.当数组没有更多空间存储数据时，我们再触发执行一次真正的删除。<br>这句话我还是不太明白。","like_count":0},{"had_liked":false,"id":44828,"user_name":"黄宇婷","can_delete":false,"product_type":"c1","uid":1160249,"ip_address":"","ucode":"8A89AC1A43FB57","user_header":"https://static001.geekbang.org/account/avatar/00/11/b4/39/d9429b27.jpg","comment_is_top":false,"comment_ctime":1543496831,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543496831","product_id":100017301,"comment_content":"假设数组大小为M*N<br>a[j][k]_address = base_address + (j*N + k)*type_size<br>超感谢留言的大神！涨了很多知识！","like_count":0},{"had_liked":false,"id":44693,"user_name":"Leo","can_delete":false,"product_type":"c1","uid":1220277,"ip_address":"","ucode":"7A11B26AEA5510","user_header":"https://static001.geekbang.org/account/avatar/00/12/9e/b5/17ff83e6.jpg","comment_is_top":false,"comment_ctime":1543477213,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543477213","product_id":100017301,"comment_content":"关于二维数组的计算方式：<br>二维数组首先它在内存中也是一块连续的内存地址。一个a[m][n]的二维数组，可以想象成一个a[m*n]的一维数组，跟a[m][n]二维数组长度是一致的。只是把一维数组分割成了m份，每一份的首地址就是a[m][0]，每一份数组的长度是n。一个a[5][3]长度的二维数组的地址计算公式就是：a[i][j]_address = base_address+(i*3+j)*type_size；","like_count":0},{"had_liked":false,"id":44636,"user_name":"匆匆","can_delete":false,"product_type":"c1","uid":1333414,"ip_address":"","ucode":"4DB39C6CD5743B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/H8NxrljQXliccaT5fjdXJQYS3ou3Z9ykAuKw6EgicicEA9L4jQLz3h85P0odgDSaK0cA9oTyUKibbiagdNvnHuuV5mQ/132","comment_is_top":false,"comment_ctime":1543467803,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543467803","product_id":100017301,"comment_content":"数组篇总结<br>数组特点：1、一种线性表 ；2、连续内存空间；3、储存相同类型数据；4、可随机访问；<br><br>线性表有哪些？：数组、队列、栈、链表；<br><br>非线性表有哪些？：树、图等；<br><br>数组的随机访问十分方便，复杂度为O(1)；但插入和删除比较低效，复杂度为O(n)，若追求性能则需要对插入和删除操作使用一些特殊的算法（比如标记删除）;<br>另外数组的使用要谨防内存越界，因为越界后可能程序并不报错，不容易debug；<br><br>所以一般业务开发使用时可以考虑使用容器，省时省力，但是最底层的东西比如网络框架的搭建，则最好使用数组以追求性能的极致；<br><br>最后数组的开头下标为什么是0呢？：主要有两点因素1、数组下标含义为“偏移”。内存地址计算为a[k]_address = base_address + k * type_size，若从1开始的话，底层的内存计算需要多计算一步k+1，这在性能上影响较大。2、最开始的C语言设计者是以0为开始，后面的各种语言则习惯性沿袭以减少程序员的学习成本。<br>","like_count":0},{"had_liked":false,"id":43979,"user_name":"小先生","can_delete":false,"product_type":"c1","uid":1055214,"ip_address":"","ucode":"E5F2052E0323C0","user_header":"https://static001.geekbang.org/account/avatar/00/10/19/ee/e395a35e.jpg","comment_is_top":false,"comment_ctime":1543360564,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543360564","product_id":100017301,"comment_content":"数组属于线性表一种。<br>通过下标访问，时间复杂度为1。<br>删除，插入，效率比较低。<br>为什么下标是从0开始呢？因为代表的是偏移量。<br>C 语言中没有越界的做法。<br>高级语言中的容器类用在业务开发中足够了。","like_count":0},{"had_liked":false,"id":43802,"user_name":"探索无止境","can_delete":false,"product_type":"c1","uid":1044178,"ip_address":"","ucode":"91D2A9907DFA79","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/d2/7024431c.jpg","comment_is_top":false,"comment_ctime":1543299037,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543299037","product_id":100017301,"comment_content":"老师你好，经过优化后的删除算法，只是将多次删除变成一次删除，而这一次删除时间复杂度依然是O（n），不知道是否正确，求指正","like_count":0},{"had_liked":false,"id":43675,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1543279887,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543279887","product_id":100017301,"comment_content":"思考题:<br>1. 标记整理算法和标记清楚算法都是在线程处于安全点或安全区域的时候通过可达性分析算法对堆中的对象是否有引用进行逐个标记, 在本轮标记结束后进行统一的整理和清除.<br>2. 对于array[m][n], 有array[i,j]_address = array[0,0]_address + (i*n+j)*type_size","like_count":0},{"had_liked":false,"id":43673,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1543279837,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543279837","product_id":100017301,"comment_content":"11月27日<br>把该讲内容总结为几个问题, 大家复习的时候可以先尝试回答这些问题检查自己的掌握程度:<br><br>\t1. <br>数组的概念是什么? 什么叫做线性表? 什么叫连续的内存空间和相同的类型的数据?<br>\t2. <br>数组为什么可以实现高效的随机访问?<br>\t3. <br>插入和删除的时间复杂度是多少, 为什么对于数组这两种操作是低效的? 各有什么改进方法? 哪些应用体现了这种思想.<br>\t4. <br>容器和数组的共同点和不同点各是什么?<br>\t5. <br>数组为什么从0开始计数?<br><br>","like_count":0},{"had_liked":false,"id":43420,"user_name":"AdmaBoy","can_delete":false,"product_type":"c1","uid":1192626,"ip_address":"","ucode":"7B5A1901FB082E","user_header":"https://static001.geekbang.org/account/avatar/00/12/32/b2/e22bb496.jpg","comment_is_top":false,"comment_ctime":1543224986,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543224986","product_id":100017301,"comment_content":"Jvm不太了解，二维数组的地址公式为<br>a[i][j]_address = base_address +(i*max +j)*data_type_size  其中max为定义的二维数组列数","like_count":0},{"had_liked":false,"id":43318,"user_name":"遥遥无妻","can_delete":false,"product_type":"c1","uid":1251243,"ip_address":"","ucode":"30A765B411D059","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/ab/c0235b70.jpg","comment_is_top":false,"comment_ctime":1543212322,"is_pvip":false,"replies":[{"id":"15594","content":"对象的话 看看存储的是对象的内存地址还是对象本身 不管哪种 都是有大小的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543285120,"ip_address":"","comment_id":43318,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1543212322","product_id":100017301,"comment_content":"麻烦问下，a[k]_address = base_address + k * type_size<br>在这个寻址公式中，typesize如果是一个对象的话怎么算呢，例子中用的是基本数据类型所以知道大小。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":430359,"discussion_content":"对象的话 看看存储的是对象的内存地址还是对象本身 不管哪种 都是有大小的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543285120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":43071,"user_name":"nan","can_delete":false,"product_type":"c1","uid":1326228,"ip_address":"","ucode":"B3338FDFAD2EEF","user_header":"https://static001.geekbang.org/account/avatar/00/14/3c/94/fe14d548.jpg","comment_is_top":false,"comment_ctime":1543154633,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543154633","product_id":100017301,"comment_content":"，base+（i*n+j)  *  type_size","like_count":0},{"had_liked":false,"id":42840,"user_name":"小一","can_delete":false,"product_type":"c1","uid":1240201,"ip_address":"","ucode":"E92DB9907C2076","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/89/681d9b13.jpg","comment_is_top":false,"comment_ctime":1543055126,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543055126","product_id":100017301,"comment_content":"1. Java的标记清除内存回收算法:<br>Java主要是针对堆内存进行回收，而堆内存中，根据对象的存活时间又分为青年代、老年代、永久代。标记清除主要是青年代的回收算法。青年代将内存进一步分为三个区域，首先对前两个区域进行可达性分析扫描，存活的对象转移到第三个区域，扫描完成后将前两个区域的内存清空.<br><br>2. 二维数组的内存寻址公式：<br>假定二维数组为m行n列，每个元素占用b个字节, 那a[i][j]的内存地址为: base_address + (i * n + j) * b ","like_count":0},{"had_liked":false,"id":42037,"user_name":"阿姆斯壮","can_delete":false,"product_type":"c1","uid":1265599,"ip_address":"","ucode":"87D5923D639CD6","user_header":"https://static001.geekbang.org/account/avatar/00/13/4f/bf/6584bdeb.jpg","comment_is_top":false,"comment_ctime":1542895794,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542895794","product_id":100017301,"comment_content":"作为一名资深潜水党，一般听完课程。做好自己的幕布笔记。就进入下一课程了。今天在吃完番茄钟的休息时间。突然不知道为啥，兴致大发，看了一下留言。才发现。牛人杠杠，小白也忒多。老王出专栏不容易。回答问题起来，估计也是，情绪也估计如同股市上上下下。建议极客时间，帮助专栏作者搞一个小姐姐助理。","like_count":0},{"had_liked":false,"id":41651,"user_name":"寒江雪","can_delete":false,"product_type":"c1","uid":1233685,"ip_address":"","ucode":"1A240BE1938AB1","user_header":"https://static001.geekbang.org/account/avatar/00/12/d3/15/1981c142.jpg","comment_is_top":false,"comment_ctime":1542813664,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542813664","product_id":100017301,"comment_content":"老师关于数组插入和删除的特殊情况分析，还是很有参考价值的","like_count":0},{"had_liked":false,"id":40319,"user_name":"meijing0114","can_delete":false,"product_type":"c1","uid":1012416,"ip_address":"","ucode":"B349D33E2F3ECC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/72/c0/b09911a0.jpg","comment_is_top":false,"comment_ctime":1542592693,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542592693","product_id":100017301,"comment_content":"文中的两个trick让人印象深刻，一个是删除某个下标元素的时候，标记删除再统一处理。还有一个是插入元素的时候，将对应位置元素预置到数组的后方。","like_count":0},{"had_liked":false,"id":40050,"user_name":"halo","can_delete":false,"product_type":"c1","uid":1138057,"ip_address":"","ucode":"782892605CC855","user_header":"https://static001.geekbang.org/account/avatar/00/11/5d/89/93b837d6.jpg","comment_is_top":false,"comment_ctime":1542456550,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542456550","product_id":100017301,"comment_content":"那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。<br><br>请问  为什么a[3]=0就相当于i＝0？","like_count":0},{"had_liked":false,"id":39927,"user_name":"K战神","can_delete":false,"product_type":"c1","uid":1139367,"ip_address":"","ucode":"527E6BB26BB766","user_header":"https://static001.geekbang.org/account/avatar/00/11/62/a7/3e6fee86.jpg","comment_is_top":false,"comment_ctime":1542390504,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542390504","product_id":100017301,"comment_content":"数组插入元素，需要判断原来基础上是否可以申请连续内存？有就插入。没有，申请新的内存然后拷贝？","like_count":0},{"had_liked":false,"id":39717,"user_name":"飞飞","can_delete":false,"product_type":"c1","uid":1043635,"ip_address":"","ucode":"08C6F3360F3BBA","user_header":"","comment_is_top":false,"comment_ctime":1542340700,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542340700","product_id":100017301,"comment_content":"int main(int argc, char* argv[]){<br>    int i = 0;<br>    int arr[3] = {0};<br>    for(; i&lt;=3; i++){<br>        arr[i] = 0;<br>        printf(&quot;hello world\\n&quot;);<br>    }<br>    return 0;<br>}<br>这段代码不一定会循环输出“hello world”，应该是回报一个内存错误。GCC编译，Linux上测试过了。","like_count":0},{"had_liked":false,"id":39557,"user_name":"你爽","can_delete":false,"product_type":"c1","uid":1188511,"ip_address":"","ucode":"CBCAB7019F2F28","user_header":"https://static001.geekbang.org/account/avatar/00/12/22/9f/5aabeeae.jpg","comment_is_top":false,"comment_ctime":1542302396,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542302396","product_id":100017301,"comment_content":"老师您好，按照之前优化插入的逻辑，删除的时候，直接用最末尾的一个数据去覆盖要删除的数据，然后把最末尾的数据删掉，也是很节省性能的？","like_count":0},{"had_liked":false,"id":39244,"user_name":"Legolas","can_delete":false,"product_type":"c1","uid":1283714,"ip_address":"","ucode":"D515DD706E3D2E","user_header":"https://static001.geekbang.org/account/avatar/00/13/96/82/44f72ed6.jpg","comment_is_top":false,"comment_ctime":1542239228,"is_pvip":false,"replies":[{"id":"14112","content":"看看留言里其他盆友的解释吧","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542280382,"ip_address":"","comment_id":39244,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542239228","product_id":100017301,"comment_content":"根据我们前面讲的数组寻址公式，a[3] 也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。<br><br>请问为什么越界访问后，a[3]的内存地址正好会是i的地址？ 计数器i 不是在数组之前定义的吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428980,"discussion_content":"看看留言里其他盆友的解释吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542280382,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":38703,"user_name":"田佳伟","can_delete":false,"product_type":"c1","uid":1034087,"ip_address":"","ucode":"D31C9799F383D2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c7/67/0077314b.jpg","comment_is_top":false,"comment_ctime":1542110763,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542110763","product_id":100017301,"comment_content":"老师，文中举的例子是int型的数组，预先知道长度，可以快速随机访问，那么如果是字符串数组呢？内存怎么分配和快速随机访问？（不懂C语言，所以问了这么个小白的问题）","like_count":0},{"had_liked":false,"id":38563,"user_name":"Hansen","can_delete":false,"product_type":"c1","uid":1260211,"ip_address":"","ucode":"6757362A09987A","user_header":"https://static001.geekbang.org/account/avatar/00/13/3a/b3/97945ef8.jpg","comment_is_top":false,"comment_ctime":1542075085,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542075085","product_id":100017301,"comment_content":"我在Xcode试了下无限循环的C语言代码，可能xcode开启了堆栈保护，我也不知道在哪关闭。。。然后我在执行完a[3]就崩溃了。看了很多留言都说是a[3]的地址会覆盖i地址，但是我打印地址的时候数组的地址分配是从高到低分配的，而i的地址总是高于arr的首地址，如果一直往下溢出，a[n]的地址也不会覆盖i的地址啊（如果往下分配到0的时候，会从首地址往上进行分配地址？）。我觉得我肯定哪里理解错了！ 求解","like_count":0},{"had_liked":false,"id":38005,"user_name":"aguan(^･ｪ･^)","can_delete":false,"product_type":"c1","uid":1107177,"ip_address":"","ucode":"04833EF2D18E1A","user_header":"https://static001.geekbang.org/account/avatar/00/10/e4/e9/0dd3829f.jpg","comment_is_top":false,"comment_ctime":1541852198,"is_pvip":false,"replies":[{"id":"13714","content":"直接把地址打印出来看呢？","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541987163,"ip_address":"","comment_id":38005,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1541852198","product_id":100017301,"comment_content":"王老师，你好<br>我是极客小透明<br>关于上节课数组越界无限循环的问题，看了其他同学分享的解答和资料，自己也上网找了一些，大概都能理解。我想自己尝试用java做一下实验，看一下局部变量栈的分配，应该怎么查看呢？网路上找了半天没找着，不知道是不是我的关键词没选对：如何查看java局部变量内存地址？？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428560,"discussion_content":"直接把地址打印出来看呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541987163,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37970,"user_name":"cw","can_delete":false,"product_type":"c1","uid":1264296,"ip_address":"","ucode":"82A6B50462F9F9","user_header":"https://static001.geekbang.org/account/avatar/00/13/4a/a8/b7e36dd2.jpg","comment_is_top":false,"comment_ctime":1541830375,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541830375","product_id":100017301,"comment_content":"地址=base_adress+（i*n+j）*count_adress<br>标记回收 分为两步：标记，回收。如果没有引用乐，就会被回收、常用于老年代。先标记，当内存（也可以当作数组没有空间时）触发回收算法。","like_count":0},{"had_liked":false,"id":37863,"user_name":"Kevin.zhang🌏","can_delete":false,"product_type":"c1","uid":1247039,"ip_address":"","ucode":"5C52AE51538906","user_header":"https://static001.geekbang.org/account/avatar/00/13/07/3f/53ae01f6.jpg","comment_is_top":false,"comment_ctime":1541755040,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541755040","product_id":100017301,"comment_content":"那个死循环程序可以有多种解决办法(deepin linux15.5下gcc编译测试通过)：<br>１．错开地址法<br>   改之前：<br>　　　　　　int i = 0;　 <br>　　　　　　int arr[3] = {0};<br>　改之后：　int i=0, j=8;　 &#47;&#47; 增加一个变量，使　i　不再占用　arr[3]<br>　　　　　　int arr[3] = {0};<br> 2 .   修改循环变量法<br>   改之前：   <br>                       for(; i&lt;=3; i++){<br>                                  arr[i] =0;<br>　改之后：　<br>                        for(; i&lt;=3; i++){<br>                                  arr[i] =8;   &#47;&#47; &gt;=3的数都可以 ","like_count":0},{"had_liked":false,"id":37857,"user_name":"邵峰","can_delete":false,"product_type":"c1","uid":1240036,"ip_address":"","ucode":"1017E31C6255F7","user_header":"https://static001.geekbang.org/account/avatar/00/12/eb/e4/dabff318.jpg","comment_is_top":false,"comment_ctime":1541753567,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541753567","product_id":100017301,"comment_content":"假如一个长为10的数组，我要删除第2，4，8个元素，怎样用一次搬移删除，哪位大佬用代码实现下？","like_count":0},{"had_liked":false,"id":37843,"user_name":"K战神","can_delete":false,"product_type":"c1","uid":1139367,"ip_address":"","ucode":"527E6BB26BB766","user_header":"https://static001.geekbang.org/account/avatar/00/11/62/a7/3e6fee86.jpg","comment_is_top":false,"comment_ctime":1541746945,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541746945","product_id":100017301,"comment_content":"评论中卧虎藏龙，我看不懂","like_count":0},{"had_liked":false,"id":37437,"user_name":"搬砖的孟达","can_delete":false,"product_type":"c1","uid":1201067,"ip_address":"","ucode":"8F280479C2C83D","user_header":"https://static001.geekbang.org/account/avatar/00/12/53/ab/20f1f4e8.jpg","comment_is_top":false,"comment_ctime":1541585460,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541585460","product_id":100017301,"comment_content":"这章就是讲了数组的相关内容。结构（连续内存空间）特点（查询快）缺点（插入和删除）。有趣的问题数组下标为何是由0开始的？jvm标记清除的思想由来。","like_count":0},{"had_liked":false,"id":36970,"user_name":"无名","can_delete":false,"product_type":"c1","uid":1110113,"ip_address":"","ucode":"2D2E877CF97138","user_header":"https://static001.geekbang.org/account/avatar/00/10/f0/61/68462a07.jpg","comment_is_top":false,"comment_ctime":1541409203,"is_pvip":false,"replies":[{"id":"13255","content":"应该是没有缩容","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541468089,"ip_address":"","comment_id":36970,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1541409203","product_id":100017301,"comment_content":"jdk 1.8中的ArrayList源码实现中，看到了扩容机制，但为何没有看到缩容算法啊？是我没看懂还是？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428102,"discussion_content":"应该是没有缩容","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541468089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36937,"user_name":"日拱一卒","can_delete":false,"product_type":"c1","uid":1067990,"ip_address":"","ucode":"3203DE70F0573F","user_header":"https://static001.geekbang.org/account/avatar/00/10/4b/d6/cf5d806b.jpg","comment_is_top":false,"comment_ctime":1541397211,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541397211","product_id":100017301,"comment_content":"不太明白数组压栈的顺序先是a[2]、再是a[1]、最后才是a[0]，希望老师能解答下。","like_count":0},{"had_liked":false,"id":36542,"user_name":"CHEN川","can_delete":false,"product_type":"c1","uid":1001694,"ip_address":"","ucode":"4B4D11141A68B9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/de/d9a88304.jpg","comment_is_top":false,"comment_ctime":1541145291,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541145291","product_id":100017301,"comment_content":"大部分留言关于垃圾回收算法的说法都是正确的，但有一点请注意，这是原则性问题。垃圾回收算法中被标记的对象都是活的，是活的，被删除的对象不是这些“活”的对象，只是通过标记“活”的对象，找到“死的”对象，然后清理。","like_count":0},{"had_liked":false,"id":36364,"user_name":"Allen","can_delete":false,"product_type":"c1","uid":1248304,"ip_address":"","ucode":"56F10976A79D20","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/30/a2e7728a.jpg","comment_is_top":false,"comment_ctime":1541059164,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541059164","product_id":100017301,"comment_content":"关于文中提到的实例，数组越界为什么会循环打印helo world，这是栈布局结构有关，一般的栈的压栈顺序是函数参数，按照倒序压栈，接着是函数返回值，再次是局部变量，局部变量的压栈顺序是后定义的先压栈，所以变量i的地址是在a[3]的高地址，当数组a越界，就会指向i的地址，因此会出现循环打印，如果把变量i的定义个数组位置变换一下，结果也就不一样了","like_count":0},{"had_liked":false,"id":36166,"user_name":"Kim","can_delete":false,"product_type":"c1","uid":1236573,"ip_address":"","ucode":"39CC8E1E8EFB8A","user_header":"https://static001.geekbang.org/account/avatar/00/12/de/5d/a7e748db.jpg","comment_is_top":false,"comment_ctime":1540959711,"is_pvip":false,"replies":[{"id":"12900","content":"需要的 这里多次搬移优化为一次搬移","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541037396,"ip_address":"","comment_id":36166,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540959711","product_id":100017301,"comment_content":"还是不太明白数组中删除时标记算法的含义，到最后难道不需要数组数据搬移么？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427769,"discussion_content":"需要的 这里多次搬移优化为一次搬移","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541037396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36080,"user_name":"Walton","can_delete":false,"product_type":"c1","uid":1246984,"ip_address":"","ucode":"C79F04E61200BD","user_header":"https://static001.geekbang.org/account/avatar/00/13/07/08/0fc1bba6.jpg","comment_is_top":false,"comment_ctime":1540936463,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540936463","product_id":100017301,"comment_content":"二维数组寻址方式<br>第一步<br>a[k]_address = base_address + k*type_size<br>第二步<br>a[k][i]_address =a[k][0]_address  + i*type_size","like_count":0},{"had_liked":false,"id":35887,"user_name":"黑喵酱","can_delete":false,"product_type":"c1","uid":1199706,"ip_address":"","ucode":"2ED1A5DD5C2F36","user_header":"https://static001.geekbang.org/account/avatar/00/12/4e/5a/4c61cd94.jpg","comment_is_top":false,"comment_ctime":1540835147,"is_pvip":false,"replies":[{"id":"12830","content":"哈哈 可以这么叫","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540950639,"ip_address":"","comment_id":35887,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540835147","product_id":100017301,"comment_content":"为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可...<br><br>极客时间版权所有: https:&#47;&#47;time.geekbang.org&#47;column&#47;article&#47;40961<br>这个例子里的做法 似乎叫 lazy deletion？~","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427700,"discussion_content":"哈哈 可以这么叫","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540950639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35845,"user_name":"逾清风","can_delete":false,"product_type":"c1","uid":1275452,"ip_address":"","ucode":"B23D93E57C916D","user_header":"https://static001.geekbang.org/account/avatar/00/13/76/3c/c65912b7.jpg","comment_is_top":false,"comment_ctime":1540821607,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540821607","product_id":100017301,"comment_content":"数组是一个线性表结构，用一段连续的内存，来存储具有相同类型的数据。<br>缺点：<br>数组具有低效的插入和删除操作，数组的插入和删除操作的最坏时间复杂度是O(n)，最好是O(1)，平均时间复杂度是O(n)。<br>另外，数组在访问时存在访问越界问题。<br><br>下标从0开始确切的可定义为偏移，a表示首地址，a[k]表示偏移k个type_size的位置。元素位置计算公式：<br>a[k]_address = base_address + k * type_size","like_count":0},{"had_liked":false,"id":35690,"user_name":"江雨","can_delete":false,"product_type":"c1","uid":1017022,"ip_address":"","ucode":"4C9B8BEBF68F48","user_header":"https://static001.geekbang.org/account/avatar/00/0f/84/be/105df233.jpg","comment_is_top":false,"comment_ctime":1540751656,"is_pvip":false,"replies":[{"id":"12700","content":"学到后面就懂了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540777520,"ip_address":"","comment_id":35690,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540751656","product_id":100017301,"comment_content":"如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数组插入到第 k 个位置，为了避免大规模的数据搬移，我们还有一个简单的办法就是，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。<br>没懂，如果数据没有规律，为何不直接将新插的数据添加到末尾，还要拷贝k位置数据？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427627,"discussion_content":"学到后面就懂了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540777520,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35637,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1540721105,"is_pvip":false,"replies":[{"id":"12670","content":"我是不想数组中的数据之间有空隙","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540740025,"ip_address":"","comment_id":35637,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540721105","product_id":100017301,"comment_content":"老师，问个问题，看了Java ArrayList源码，其中的add方法，为什么要判断if (index &gt; size || index &lt; 0)。其中index&lt;0判断可以理解，因为索引是不能为负数。但是为什么要判断插入指定的索引不能大于当前数组元素的个数。如果大于了，那么我这个默认为null，不行吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427610,"discussion_content":"我是不想数组中的数据之间有空隙","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540740025,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35498,"user_name":"o","can_delete":false,"product_type":"c1","uid":1104326,"ip_address":"","ucode":"4028A59700647A","user_header":"https://static001.geekbang.org/account/avatar/00/10/d9/c6/a295275b.jpg","comment_is_top":false,"comment_ctime":1540628405,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540628405","product_id":100017301,"comment_content":"大佬，对于开篇的问题。我有另外一个想法，就是内存最终是按照位来运算的，也就是说，最简单的二进制数字是0，不知道是不是这样也算合理的原因之一？","like_count":0},{"had_liked":false,"id":35466,"user_name":"拜雨","can_delete":false,"product_type":"c1","uid":1122191,"ip_address":"","ucode":"BA71EB0910D219","user_header":"https://static001.geekbang.org/account/avatar/00/11/1f/8f/837a14a7.jpg","comment_is_top":false,"comment_ctime":1540606467,"is_pvip":false,"replies":[{"id":"12686","content":"前面的和是n*(n+1)&#47;2 除以n就是(n+1)&#47;2，去掉系数，常数，不就是O(n)吗","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540740655,"ip_address":"","comment_id":35466,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540606467","product_id":100017301,"comment_content":"(1+2+…n)&#47;n=O(n)。不明白😭","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427546,"discussion_content":"前面的和是n*(n+1)/2 除以n就是(n+1)/2，去掉系数，常数，不就是O(n)吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540740655,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35191,"user_name":"轩月","can_delete":false,"product_type":"c1","uid":1243429,"ip_address":"","ucode":"E5277B5718CA30","user_header":"https://static001.geekbang.org/account/avatar/00/12/f9/25/576088ef.jpg","comment_is_top":false,"comment_ctime":1540453586,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540453586","product_id":100017301,"comment_content":"无限循环，到3的地址是变量i，把i改为0","like_count":0},{"had_liked":false,"id":35079,"user_name":"吴峰","can_delete":false,"product_type":"c1","uid":1240016,"ip_address":"","ucode":"49FC23A807F674","user_header":"https://static001.geekbang.org/account/avatar/00/12/eb/d0/56977a90.jpg","comment_is_top":false,"comment_ctime":1540395872,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540395872","product_id":100017301,"comment_content":"数组的概念：是一种线性表数据结构，用一串连续的内存空间，来存储一组具有相同类型的数据；<br><br>线性表的概念：数据排成像一条线一样的结构。包括数组、链表，队列，栈等；<br><br>非线性表：二叉树、堆、图<br><br>寻址公式：<br>a[i]_address = base_address + i * data_type_size<br>第i个数据的地址等于首地址加上i乘以i个元素的大小<br>data_type_size表示数据中每个元素的大小<br><br><br>插入操作：<br>如果在数组中插入的数据刚好在最后一位，则不需要移动数据，时间复杂度为O(1)；<br>如果在数组中插入的数据刚好在第一位，则需要移动数据，时间复杂度为O(n)；<br>平均则为（1+2+….+n）&#47;n=O(n)；<br>如果只是最简单的插入操作，不考虑排序等问题，则最快的插入操作为，将数据插入第i个位置，将i个位置放到n+1上<br>，则时间复杂度为O(1)<br><br>删除操作：<br>如果删除的数据是第一位，则需要移动数据，时间复杂度为O(n)<br>如果删除的数据是最后一位，则不需要移动数据，时间复杂度为O(1)<br>平均也为（1+2+….+n）&#47;n=O(n)；<br>由于删除的数据可能不是连续性的删除，所以我们可以将需要删除的数据标记下，等到出现连续的内存地址在统一删除，则将减少移动数据，此为标记-清除算法的概念<br>标记清除的缺点：<br>1、效率问题：标记和清除的效率不高；<br>2、碎片化严重，如果出现分配大对象时，无法找到连续内存则不得不执行垃圾收集动作<br>容器能否代替数组：<br>数组必须指定大小，<br>arrayList则包含了数组的基本操作，以及支持扩容，但是arrayList不支持基本类型；<br><br>关于为甚么数组必须从0开始的问题；<br>由于寻址公式为：a[i]_address = base_address + i * data_type_size<br>如果从1开始，则公示为a[i]_address = base_address + （i-1） * data_type_size<br>则相当于多一次减法运算<br>a[i][j]<br>因为二维数组，实际上便是矩阵；<br>假如数组为a*b（a行b列）<br>需要查找第i行第j列的地址，则行地址为(i*b)*data_type_size，列地址为j*data_type_size<br>则公式为base_address+(i*b)*data_type_size+(j*data_type_size)，即base_address+((i*b)+j)*data_type_size","like_count":0},{"had_liked":false,"id":34943,"user_name":"1‰","can_delete":false,"product_type":"c1","uid":1237086,"ip_address":"","ucode":"220A9F2CDCF697","user_header":"https://static001.geekbang.org/account/avatar/00/12/e0/5e/87b47b4a.jpg","comment_is_top":false,"comment_ctime":1540364483,"is_pvip":false,"replies":[{"id":"12497","content":"看看留言区大牛们的留言吧","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540394380,"ip_address":"","comment_id":34943,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540364483","product_id":100017301,"comment_content":"无限循环那个还是不太理解","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427394,"discussion_content":"看看留言区大牛们的留言吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540394380,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34704,"user_name":"ForzaJuve","can_delete":false,"product_type":"c1","uid":1047302,"ip_address":"","ucode":"E090D83AE78EE6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/06/0e6b6365.jpg","comment_is_top":false,"comment_ctime":1540263187,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540263187","product_id":100017301,"comment_content":"访问数组的本质就是访问一段连续内存  <br>a[i]_address = base_address + i * data_type_size<br>课中从复杂度分析方面解析了为什么数组访问快（随机访问，O1，原因见寻址公式）而增删慢（On）<br>编程以来只用容器从没用过数组，但如果确定需要存储数据大小，最好指定ArrayList大小，因为动态扩容需要涉及申请内存和搬迁数据，耗时影响一些效率。<br>数组在有些时候更合适，比如容器存储基本类型还涉及装箱操作<br><br>int main(int argc, char* argv[]){<br>    int i = 0;<br>    int arr[3] = {0};<br>    for(; i&lt;=3; i++){<br>        arr[i] = 0;<br>        printf(&quot;hello world\\n&quot;);<br>    }<br>    return 0;<br>}<br><br>这段c语言代码会神奇的无限循环，原因评论区藏龙卧虎，已有解释<br>对文中示例的无限循环有疑问的同学，建议去查函数调用的栈桢结构细节（操作系统或计算机体系结构的教材应该会讲到）。<br><br><br>函数体内的局部变量存在栈上，且是连续压栈。在Linux进程的内存布局中，栈区在高地址空间，从高向低增长。变量i和arr在相邻地址，且i比arr的地址大，所以arr越界正好访问到i。当然，前提是i和arr元素同类型，否则那段代码仍是未决行为。<br><br>例子中死循环的问题跟编译器分配内存和字节对齐有关 数组3个元素 加上一个变量a 。4个整数刚好能满足8字节对齐 所以i的地址恰好跟着a2后面 导致死循环。。如果数组本身有4个元素 则这里不会出现死循环。。因为编译器64位操作系统下 默认会进行8字节对齐 变量i的地址就不紧跟着数组后面了。","like_count":0},{"had_liked":false,"id":34637,"user_name":"意无尽","can_delete":false,"product_type":"c1","uid":1234489,"ip_address":"","ucode":"DA179626C46B81","user_header":"https://static001.geekbang.org/account/avatar/00/12/d6/39/6b45878d.jpg","comment_is_top":false,"comment_ctime":1540228345,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540228345","product_id":100017301,"comment_content":"哈哈，有好多天没来学习了，现在来一波数组的总结~<br>1、什么是数组？<br>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。它组不仅是一种编程语言中的数据类型，还是一种最基础的数据结构。<br><br>关键词：<br>1) 线性表(Linear List)：简单来说，数据像线一样的结构，如：数组，链表、队列、栈等；<br>    非线性表：数据之间并不是简单的前后关系；如：二叉树、堆、图等。<br>2) 连续的内存空间和相同类型的数据：正因为这两种限制，因此具有“随机访问”的特性！<br>    但同时也让数组的很多操作变得非常低效。<br><br>链表和数组的区别：链表适合插入、删除，时间复杂度 O(1)；数组适合查找，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。<br><br>“插入”和“删除”<br>插入：如果数组中存储的数据没有任何规律，要将某个数据插入到第 k 个位置，为避免大规模的数据搬移，可以将第 k 个位置的数据搬移到数组元素的最后，将新的元素之间放到第 k 个位置。<br>删除：若要删除多个数据，为避免剩余数据被多次搬移，我们可以先记录已经删除的数据，每次的删除并不是真正的搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。<br><br>什么是 JVM ? 记得查找资料了解了解！<br><br>警惕数组的访问越界<br>很多计算机病毒也正是利用到了代码中的数组越界可以访问非法地址的漏洞，来攻击系统，所以写代码的时候一定要警惕数组越界。<br><br>相比于容器，数组的优势：<br>(容器：数组类型，很多语言都提供了容器类，比如 Java 中的 ArrayList、C++ STL 中的 vector。)<br>1) Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long类，而 <br>   Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，<br>   就可以选用数组。<br>2) 如果数据大小事先已知，并且对数据的操作非常简单，用不到ArrayList 提供的大部分方法，也可以<br>    直接使用数组。<br>3) 当要表示多维数组时，用数组往往会更加直观。<br>总之，对于业务开发，直接使用容器就足够了，省时省力。但如果你是做一些非常底层的开发，优先选择数组。<br><br>为什么大多数编程语言中，数组要从 0 开始编号，而不是从1 开始呢？<br>从数组存储的内存模型上来看，“下标”最确切的定义应该是&quot;偏移 (offset)&quot;。a[0] 就是偏移为 0 的位置，也就是首地址，a[k] 就就表示偏移 k 个 type_size 的位置。<br>如果从 1 开始编号，每次随机访问数组元素都多了一次剪发运算，对 CPU 来说就是多了一次减法指令。数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。","like_count":0},{"had_liked":false,"id":34625,"user_name":"小小鹿","can_delete":false,"product_type":"c1","uid":1234101,"ip_address":"","ucode":"7A401F2EE87C67","user_header":"https://static001.geekbang.org/account/avatar/00/12/d4/b5/b72b83f8.jpg","comment_is_top":false,"comment_ctime":1540222988,"is_pvip":false,"replies":[{"id":"12325","content":"那个是其他同学写的 可能会有bug","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540258393,"ip_address":"","comment_id":34625,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540222988","product_id":100017301,"comment_content":"老师您好，java 版本 GenericArray 脚本中 remove函数有点疑问<br>1、为什么进行 size --; 之后执行 data[size] = null; 而不是先进行 data[size] = null;再进行size --; ？<br>2、当index == size 的时候 函数理应一个元素都不会移除，因为超过数组有效元素可读范围了，但是按照逻辑仍然会执行 size--; 这样实际上元素不就移除掉一个了吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427274,"discussion_content":"那个是其他同学写的 可能会有bug","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540258393,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34499,"user_name":"类星体Sisi","can_delete":false,"product_type":"c1","uid":1269003,"ip_address":"","ucode":"DA2284ECAB2138","user_header":"https://static001.geekbang.org/account/avatar/00/13/5d/0b/b80080c3.jpg","comment_is_top":false,"comment_ctime":1540190852,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540190852","product_id":100017301,"comment_content":"数组随机访问的时间复杂度是O(1)，插入和删除操作（改变长度）的时间复杂度是O(n)<br>链表随机访问的时间复杂度是O(n)，插入和删除操作的时间复杂度是O(1)","like_count":0},{"had_liked":false,"id":34491,"user_name":"小和尚笨南北","can_delete":false,"product_type":"c1","uid":1204628,"ip_address":"","ucode":"17C9BBB6DD25D2","user_header":"https://static001.geekbang.org/account/avatar/00/12/61/94/713b38ef.jpg","comment_is_top":false,"comment_ctime":1540189424,"is_pvip":false,"replies":[{"id":"12308","content":"感觉都可以啊","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540221725,"ip_address":"","comment_id":34491,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540189424","product_id":100017301,"comment_content":"@杰杰 评论中写到将所有存活的对象进行标记。<br>我在深入理解Java虚拟机一书中所写的标记清除算法是标记要回收的对象。<br>老师解答一下。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427225,"discussion_content":"感觉都可以啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540221725,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34416,"user_name":"走走停停","can_delete":false,"product_type":"c1","uid":1244152,"ip_address":"","ucode":"C71A049BAD6863","user_header":"https://static001.geekbang.org/account/avatar/00/12/fb/f8/7fb99855.jpg","comment_is_top":false,"comment_ctime":1540168056,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540168056","product_id":100017301,"comment_content":"总结<br>数组支持随机访问，按索引访问的时间复杂度为o1<br>链表更适合插入删除操作，时间复杂度为o1。<br>在数组插入元素的高效方法，用插入元素替换原来元素，将原来的元素放到末尾，这只适合顺序不影响数组本身的情况。<br>在数组高效删除的方法，将要删除的先记下，最后一起操作。<br>做底层开发时最好用数组，做容器时可以用arraylist","like_count":0},{"had_liked":false,"id":34381,"user_name":"Bupt_daydayup","can_delete":false,"product_type":"c1","uid":1248375,"ip_address":"","ucode":"5E2BBE695288B5","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/77/d855bfb2.jpg","comment_is_top":false,"comment_ctime":1540133713,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540133713","product_id":100017301,"comment_content":"数组的随机性访问利用的是首地址递推法","like_count":0},{"had_liked":false,"id":34380,"user_name":"Bupt_daydayup","can_delete":false,"product_type":"c1","uid":1248375,"ip_address":"","ucode":"5E2BBE695288B5","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/77/d855bfb2.jpg","comment_is_top":false,"comment_ctime":1540133648,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540133648","product_id":100017301,"comment_content":"数组的随机访问极其便利，且对于无序的数组，插入操作讲原位置元素搬运到最后就可以实现，令其复杂度为O（1），而不是平均时间复杂度的（1+2+3+4+……n）&#47;n的复杂度","like_count":0},{"had_liked":false,"id":34236,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1540045220,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540045220","product_id":100017301,"comment_content":"阅过留痕<br><br>学过次节之后，感觉对于数组又加深了一些认识<br>1：数组这种数据类型在平时编程时使用的也挺多的，当然他不仅仅是一种数据类型，还是一种数据结构，这种数据结构的特点如下<br>线性的：元素之间在逻辑上有前后的关系<br>连续的：元素之间的物理内存空间具有连续性<br>相同类型的：每个元素开辟的存储空间大小是一样的<br><br>2：数据结果按照元素的结构特点来分类可以大体分为两类，一是线性表结构，二是非线性表结构，线性表结构的特点是元素之间在逻辑上有前后的逻辑关系，一个个元素拉平来看好像拴在一条绳子之上，比如：数组、链表、队列、栈等数据结构都是线性表结构的。非线性表结构的数据结构元素之间则是另外的一种关系，比如：树、图等元素之间的关系更加的复杂。<br>数组这种线性表结构的数据结构不但逻辑上是线性的连续的物理上也是线性的连续的。<br><br>3：数组的结构特点决定了它的功能特点或者操作特点，这应该就是结构决定功能，内因决定外形的道理吧！数组的最大特点就是能够实现数组元素的随机访问，它能随机访问的本质就是通过数组的元素的寻址公式 a[i]_address = base_address + i*data_type_size，这个寻址公式也暗含了数组这种数据结构的特点，比如：分配的内存是连续的、存储的数据类型是相同的。<br>当然，其他的特点，也是有其结构的特点决定的，比如：插入、删除元素相对较耗性能。但是根据数据的特点也是能够做出一些优化的，比如：插入的时候，如果是尾部，则不需要一定其他元素，如果是其他位置，则可以选择仅移动要插入位置的元素，然后将新元素插入到对应的位置，删除元素时也可以根据情况作出相应的优化，总之，少做事情，又懒又能实现相应的功能就行。<br><br>4：老师文中列举的例子，清楚方法内变量内存分配的很容易理解，不清楚的就费劲了，这个还要看具体的系统环境，是个好玩事情，要求有一定的功底，可以简单理解为，分配了四块内存，分别是<br>a[0]_a[1]_a[2]_i很不幸，当数组越界访问时就是访问a[3]时巧合相当于访问的同时也是i的内存地址，这样就容易理解无限循环的场景了，i的值一直会在0&#47;1&#47;2&#47;3内循环往复<br><br>5：高级编程语言都有对数组的封装，比如：java中有ArrayList，那么什么情况下还会照样使用数组呢？<br>5-1：存储基本类型的时候，因为ArrayList等不支持基本类型，为什么不支持基本类型，因为他们定义的时候，仅支持对象类型的数据，基本类型不是对象<br>5-2：事先已知长度，且操作简单，数组便可满足需要<br>5-3：表示多维的数组结构时<br>5-4：出于性能考量，数组更加的底层和纯粹，性能会更佳，这也是数组下标从0开始的一个原因<br><br>6：为什么数组的下标从0开始而非1或者其他？<br>原因有两个，<br>一是从性能的角度考量，随机访问数组中的某个元素的寻址公式，如果是从0开始，则会少做一次减法操作性能更好一点<br>二是历史原因，最初为什么这样来做，估计也和性能相关，毕竟大牛做事都会倾向于做大极致，把性能问题解决好了，才是真牛逼<br><br>7：数组删除的优化确实很像GC的标记清楚算法，可以将jvm的内存结构相像成为一个一组，最佳的删除元素的算法的核心思想本就是一样的吧！<br><br>8：二维数组，多为数组，本质上都是用一维数组来表现的，画个图自己推到一下公式是怎么样的吧！<br>     一维数组，每个元素的偏移大小是元素的数据类型大小<br>     a[i]_address = base_address + i*data_type_size<br>     二维数组，每个元素的偏移大小有第二维的数组长度加上数组元素类型的大小<br>     a[i][j]_address=base_address + (i*n+j)*data_type_size （对于m*n的数组而言）","like_count":0},{"had_liked":false,"id":34086,"user_name":"Alexis何春光","can_delete":false,"product_type":"c1","uid":1181149,"ip_address":"","ucode":"614570FAE3B56A","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/dd/b201cf13.jpg","comment_is_top":false,"comment_ctime":1539995841,"is_pvip":false,"replies":[{"id":"12196","content":"怎么优化呢？感觉没啥优化的余地了。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540047992,"ip_address":"","comment_id":34086,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539995841","product_id":100017301,"comment_content":"那请问在Java具体实现中，array的插入是依次移动每一个还是做了优化呢？在实际编程中，如果是做了优化的话，是不是也不用太考虑数组插入的低效性了呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427112,"discussion_content":"怎么优化呢？感觉没啥优化的余地了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540047992,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34084,"user_name":"Alexis何春光","can_delete":false,"product_type":"c1","uid":1181149,"ip_address":"","ucode":"614570FAE3B56A","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/dd/b201cf13.jpg","comment_is_top":false,"comment_ctime":1539995275,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539995275","product_id":100017301,"comment_content":"数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)。所以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。<br>这句话真的太棒了！解开了我的疑惑！","like_count":0},{"had_liked":false,"id":34051,"user_name":"蓝色~冰*羽","can_delete":false,"product_type":"c1","uid":1205873,"ip_address":"","ucode":"E2F6424766AD7C","user_header":"https://static001.geekbang.org/account/avatar/00/12/66/71/8a5d02ab.jpg","comment_is_top":false,"comment_ctime":1539963713,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539963713","product_id":100017301,"comment_content":"二维数组寻址公式为什么是address = base_address + ( i * n + j) * type_size啊？百度了半天，始终理解不了","like_count":0},{"had_liked":false,"id":34034,"user_name":"cruzyang","can_delete":false,"product_type":"c1","uid":1244598,"ip_address":"","ucode":"11D66E2D47CE35","user_header":"https://static001.geekbang.org/account/avatar/00/12/fd/b6/ccf614f5.jpg","comment_is_top":false,"comment_ctime":1539958953,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539958953","product_id":100017301,"comment_content":"老师，您好！文中导致死循环的例子，是因为在函数执行时参数压栈，变量i刚好就是a数组后面，访问时就直接赋值给i 了。<br>","like_count":0},{"had_liked":false,"id":33985,"user_name":"chris","can_delete":false,"product_type":"c1","uid":1060618,"ip_address":"","ucode":"AD358E51C01748","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/0a/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1539938495,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539938495","product_id":100017301,"comment_content":"自己实验了一下固定长度和非固定长度的arraylist的性能，发现在arrayList扩容的阈值内，不指定长度的性能比固定长度的要高，当超出arraylist扩容阈值后，固定长度的arraylist性能优势才会显现出来。","like_count":0},{"had_liked":false,"id":33953,"user_name":"Benny","can_delete":false,"product_type":"c1","uid":1254655,"ip_address":"","ucode":"062648FD8743BF","user_header":"https://static001.geekbang.org/account/avatar/00/13/24/ff/4647e8a5.jpg","comment_is_top":false,"comment_ctime":1539928617,"is_pvip":false,"replies":[{"id":"12207","content":"如果是java语言 那存储的就是引用 根本不是对象本身。如果是c语言 那既可以是指针 也可以是user对象 对象大小也确定的 不存在你说的大小不确定","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540050382,"ip_address":"","comment_id":33953,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539928617","product_id":100017301,"comment_content":"老师您好，<br><br>对a[i]_address = base_address + i * data_type_size有个疑问，麻烦解答下（可能已有相同问题，但是翻了很多没有发现存在）。<br><br>举例中若数组保存的数据类型是int型（或其他基本类型），所需存储空间默认是4个字节是固定不会变的，所以可以按照上面寻址公式根据数组下标随机访问。<br><br>但是在实际场景中数组中存放的可能是自定义类型的对象。例如用户对象User，由于User的信息并不都是一样的，所需的存储空间也并不都是一样的。<br><br>问题1：在往素组中存User对象时，数组已经申请了内存空间了，怎么保证单个元素默认的空间可以支持所有的User对象。<br><br>问题2：公式a[i]_address = base_address + i * data_type_size中data_type_size应该是动态的，那怎么根据公式随机访问。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427085,"discussion_content":"如果是java语言 那存储的就是引用 根本不是对象本身。如果是c语言 那既可以是指针 也可以是user对象 对象大小也确定的 不存在你说的大小不确定","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540050382,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33849,"user_name":"霸王龙","can_delete":false,"product_type":"c1","uid":1240386,"ip_address":"","ucode":"CFA3FECED111CA","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/42/94d45ca8.jpg","comment_is_top":false,"comment_ctime":1539910968,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539910968","product_id":100017301,"comment_content":"我给Java开发者拖后腿了 做了这么久的开发并没有详细的了解过JVM 我要去继续好好学习了","like_count":0},{"had_liked":false,"id":33780,"user_name":"Fisher","can_delete":false,"product_type":"c1","uid":1089543,"ip_address":"","ucode":"49C0EB546971ED","user_header":"https://static001.geekbang.org/account/avatar/00/10/a0/07/8d91021c.jpg","comment_is_top":false,"comment_ctime":1539881627,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539881627","product_id":100017301,"comment_content":"1、JVM标记-清除（mark-sweep）算法是最基础的垃圾收集算法，如同它的名字一样，分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它的缺点有两个。一个是效率问题，一个是空间问题。<br>顺着这条线，一并查看了java的四种引用方式：strong reference,soft reference,weak reference and phantom reference。<br>2、数组的内存存储方式是连续的。java中的数组没有多维数组，不管是几维数组，java都按照一维数组来处理。假设二维数组有m*n个元素，二维数组的寻址公式：a[i][j]_address = base_address+(i*n+j)*data_type_size。","like_count":0},{"had_liked":false,"id":33706,"user_name":"1024","can_delete":false,"product_type":"c1","uid":1086407,"ip_address":"","ucode":"DCC31F6EC54F43","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/c7/86352ccc.jpg","comment_is_top":false,"comment_ctime":1539857789,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539857789","product_id":100017301,"comment_content":"今日所学：<br>线性表：数据呈直线排列，数据之间的关系只有「前后」就能表示<br>定义：数组，是线性表数据结构，用一组连续的内存空间，存储相同类型的数据<br>使用场景：数组适合随机访问，不适合增删。<br>提高「增」的效率可以将被替换元素放到数组末尾，时间复杂度有O(n)--&gt;O(1)<br>提高「删」的效率可以将多次删除先进行标记，再进行统一删除，将多次O(n)变为一次O(n)操作<br>ArrayList封装了array，好处是自动扩容、增删操作的封装。如果存储的元素个数确定，则直接创建固定长度的ArrayList，减少扩容带来的开销。<br>数组从0开始标记，在随机访问元素时减少了一次减法计算，真真的佩服设计者~，也体现了算法的魅力","like_count":0},{"had_liked":false,"id":33639,"user_name":"Novapath ☀","can_delete":false,"product_type":"c1","uid":1256605,"ip_address":"","ucode":"A65E5AB8B58E1C","user_header":"https://static001.geekbang.org/account/avatar/00/13/2c/9d/e5af3fd4.jpg","comment_is_top":false,"comment_ctime":1539841861,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539841861","product_id":100017301,"comment_content":"05 数组<br><br>一. 数组可以实现随机访问<br><br>1.1 数组是一种线性数据结构，用连续的存储空间存储相同类型数据；<br><br>i.线性数据结构：数组、链表、队列、栈；<br>非线性数据结构：树、图；<br>ii. 数组是连续的内存空间、存储着相同类型的数据，所以数组可以随机访问；<br>iii. 对数组进行删除插入，为了保证数组的连续性，就要做大量的数据搬移工作<br>1.2 数组如何实现下标随机访问<br><br>引入数组再内存种的分配图，得出寻址公式a[i]_address = base_address + i * data_type_size；其中data_type_size表示每个元素的大小；<br><br>1.3 纠正数组和链表的错误认识<br><br>数组的查找操作时间复杂度并不是O(1)。即便是排好的数组，用二分查找，时间复杂度也是O（logn）。 正确表述：数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。<br><br>二. 数组特点：低效的插入和删除<br><br>插入方法1<br>从数组末尾插入数据情况最好，时间复杂度为O(1)；<br>从数组开头插入数据，所有的数据往后移一位，情况最差，时间复杂度为O(n) ；<br>每一位插入的概率一样，所以平均时间复杂度为(1+2+...+n)&#47;n = (1+n)&#47;2 = O(n)<br><br>插入方法2<br>数组若无序，插入新的元素时，可以将第k个位置元素移动到数组末尾，把新的元素插入到第k个位置，此处时间复杂度为O(1)。<br><br>删除方法1<br>删除数组末尾的数据，最好情况时间复杂度O(1)；<br>删除数组开头数据，最坏情况时间复杂度O(n)；<br>平均时间复杂度O(n)<br><br>删除方法2<br>多次删除集中在一起，提高删除效率。<br>记录下已经被删除的数据，每次的删除操作并不是搬移数据，只是记录数据已经被删除，当数组没有更多的存储空，时，再触发一次真正的删除操作，即JVM标记清除垃圾回收算法核心思想。<br>eg.房间里有个垃圾桶（数组），把垃圾（删除记录数据）丢进去垃圾（数据）并不会消失，当垃圾桶（数组）装满之后，再把垃圾拿出去倒掉（真正删除）。<br><br>三. 数组的访问越界问题<br><br>无限循环例题：<br>出现原因：C语言没有规定数组访问越界时编译器会如何处理，如果用来编译这段程序的编译器按照内存地址递减的方式给变量分配内存，那么内存中的i将会被置为0，则为死循环永远出不去。<br><br>详细解释：<br>栈从高位到低位增长的；<br>先把变量i分配到最底下格子的内存；变量arr往上以此分配三个内存；i和数组的数据从高位地址到低位地址依次是：i, a[2], a[1], a[0]；<br>通过寻址公式，当访问到a[3]的时候，计算得到a[3]的地址恰好是变量i的存储地址，相当于i=0<br><br>四. 容器能否完全替代数组<br>相比于数组，Java中的ArrayList封装了数组的很多操作，并支持动态扩容。扩容时比较消耗内存，因为涉及到内存申请和数据搬移。<br>数组适合的场景：<br>Java ArrayList的使用涉及装箱拆箱，有一定的性能损耗，关注性能，或者希望使用基本类型，就可以选用数组；<br>数据大小事先已知，并且涉及的数据操作非常简单，使用数组；<br>表示多维数组时，数组往往更加直观；<br>业务开发容器即可，底层开发，如网络框架，性能优化。选择数组。<br><br>五. 解答开篇问题<br>Q：为什么大多数编程语言从0开始编号，而不是1？<br>A1：从偏移角度理解a[0]，0为偏移量（offset），如果从1计数，每个数组元素会多出1次减法计算，增加cpu负担；<br>A2：一定的历史原因，C语言首先使用，后面Java等效仿；不过如MATLAB就不是从0开始，Python还支持负数下标。<br><br>六.课后思考<br>Q1：说说你理解ed标记清除垃圾回收算法。<br>A1：房间里有个垃圾桶（数组），把垃圾（删除记录数据）丢进去垃圾（数据）并不会消失，当垃圾桶（数组）装满之后，再把垃圾拿出去倒掉（真正删除）。<br><br>Q2：二维数组的寻址公式是怎样的？<br>A2：一维数组a[n]的寻址公式为：a[i]_address = base_address + i * type_size；<br>类比得到，二维数组a[m][n]要找第i行第j列的元素时，a[i][j]_address = base_address + ( i * n + j) * type_size","like_count":0},{"had_liked":false,"id":33628,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1539839260,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539839260","product_id":100017301,"comment_content":"今天刚买专栏，看的第一篇就是数组。因为前段时间补了一下算法知识，再加上工作这么多年的沉淀，重新刷新了一下数组知识。<br><br>今天看完作者介绍完数组，从内心深处已经认可了作者的水平，点个👍<br><br>个人认为，算法功底扎实不扎实，对算法理解深不深，聊聊数组和链表就能窥知一二","like_count":0},{"had_liked":false,"id":33554,"user_name":"Zz","can_delete":false,"product_type":"c1","uid":1257798,"ip_address":"","ucode":"F76ECC7BF7AD11","user_header":"https://static001.geekbang.org/account/avatar/00/13/31/46/7e9e2d7e.jpg","comment_is_top":false,"comment_ctime":1539825023,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539825023","product_id":100017301,"comment_content":"快速排序中，partition部分那个思想能再清楚一点么。不是很明白，明白数组插入的操作。这个不是太懂。","like_count":0},{"had_liked":false,"id":32990,"user_name":"Leoorz","can_delete":false,"product_type":"c1","uid":1030657,"ip_address":"","ucode":"8912628AD6ADE0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/01/5ce8ce0b.jpg","comment_is_top":false,"comment_ctime":1539739100,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539739100","product_id":100017301,"comment_content":"希望老师多抛点东西出来，评论区大牛好多，受教了","like_count":0},{"had_liked":false,"id":32764,"user_name":"阿良","can_delete":false,"product_type":"c1","uid":1070874,"ip_address":"","ucode":"79F993EE9E2C0C","user_header":"https://static001.geekbang.org/account/avatar/00/10/57/1a/57e13b4d.jpg","comment_is_top":false,"comment_ctime":1539691575,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539691575","product_id":100017301,"comment_content":"使用寻址公式要通过偏移将量k，从0开始减少计算","like_count":0},{"had_liked":false,"id":32756,"user_name":"朱雯","can_delete":false,"product_type":"c1","uid":1035744,"ip_address":"","ucode":"064C45FBF6B51F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cd/e0/c85bb948.jpg","comment_is_top":false,"comment_ctime":1539688159,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1539688159","product_id":100017301,"comment_content":"我也来写一些我的感悟<br>1:数组是连续的内存空间，存储一组具有相同的数据类型的数据。关于连续内存存在疑问，比如js数组可以存储不同的数据类型，但是我也可以强行将这个解释为对象。或者干脆认为js的数组并不是传统意义的数组，而是栈或者队列这样的线性表<br>2:数组的查找的时间复杂度并不是O(1),根据下标的随机访问特性才是时间复杂度才是O(1),插入和删除的时间复杂度为O(n)<br>3:为了解决低效的插入和删除操作，将采取特殊的方式解决，比如插入插入，将插入元素插入到某个位置，然后将该位置的数据移动移动到末尾，这样可以降低时间复杂度为O(1),删除操作可以将多次删除的操作计中到一次，提高一定的效率，但是这是特定情况下的操作。比如jvm标记清除算法(不懂java)<br>4：老师给的c语言的例子，再某些cpu或者操作系统可以实现，在另外一些不可以，取决于是否为小端法，压栈方式，编译器是否添加参数等<br>5：java容器arraylist在方法各种操作对数组做了很多封装，非常方便使用，还支持动态扩容，但是使用方便的代价就是牺牲一定的时间复杂度和空间复杂度,如果在性能要求比较高的地方，使用数组就会比较高 <br>6：数组编号从0开始，有一定的道理比如c语言的偏移量，python的切片优雅，但是根本的原因是历史的习惯原因，出自于节约计算机内存。<br><br>7:课后思考题第一题不会，因为不懂java和jvm 第二题大概公式为这个<br>address = base_address + ( i * n + j) * type_size","like_count":0},{"had_liked":false,"id":32755,"user_name":"朱雯","can_delete":false,"product_type":"c1","uid":1035744,"ip_address":"","ucode":"064C45FBF6B51F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cd/e0/c85bb948.jpg","comment_is_top":false,"comment_ctime":1539688141,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1539688141","product_id":100017301,"comment_content":"我也来写一些我的感悟<br>1:数组是连续的内存空间，存储一组具有相同的数据类型的数据。关于连续内存存在疑问，比如js数组可以存储不同的数据类型，但是我也可以强行将这个解释为对象。或者干脆认为js的数组并不是传统意义的数组，而是栈或者队列这样的线性表<br>2:数组的查找的时间复杂度并不是O(1),根据下标的随机访问特性才是时间复杂度才是O(1),插入和删除的时间复杂度为O(n)<br>3:为了解决低效的插入和删除操作，将采取特殊的方式解决，比如插入插入，将插入元素插入到某个位置，然后将该位置的数据移动移动到末尾，这样可以降低时间复杂度为O(1),删除操作可以将多次删除的操作计中到一次，提高一定的效率，但是这是特定情况下的操作。比如jvm标记清除算法(不懂java)<br>4：老师给的c语言的例子，再某些cpu或者操作系统可以实现，在另外一些不可以，取决于是否为小端法，压栈方式，编译器是否添加参数等<br>5：java容器arraylist在方法各种操作对数组做了很多封装，非常方便使用，还支持动态扩容，但是使用方便的代价就是牺牲一定的时间复杂度和空间复杂度,如果在性能要求比较高的地方，使用数组就会比较高 <br>6：数组编号从0开始，有一定的道理比如c语言的偏移量，python的切片优雅，但是根本的原因是历史的习惯原因，出自于节约计算机内存。<br><br>7:课后思考题第一题不会，因为不懂java和jvm 第二题大概公式为这个<br>address = base_address + ( i * n + j) * type_size","like_count":0},{"had_liked":false,"id":32751,"user_name":"fish","can_delete":false,"product_type":"c1","uid":1253273,"ip_address":"","ucode":"DF2FCC9F6CDF6F","user_header":"https://static001.geekbang.org/account/avatar/00/13/1f/99/0c773be9.jpg","comment_is_top":false,"comment_ctime":1539687359,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539687359","product_id":100017301,"comment_content":"https:&#47;&#47;github.com&#47;wangzheng0822&#47;algo&#47;blob&#47;master&#47;java&#47;05_array&#47;%08GenericArray.java中的add方法时间复杂度 O(m+n)，怎么理解呢，我的理解是m表示index到数组尾的元素个数，所以m&lt;=n的，所以不管是否扩容，时间复杂度直接就是O（n），不知道理解的对不对<br>","like_count":0},{"had_liked":false,"id":32712,"user_name":"Zherlock","can_delete":false,"product_type":"c1","uid":1248208,"ip_address":"","ucode":"02D321D434E72C","user_header":"https://static001.geekbang.org/account/avatar/00/13/0b/d0/a5eacd8c.jpg","comment_is_top":false,"comment_ctime":1539674802,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539674802","product_id":100017301,"comment_content":"不熟悉jvm<br>二维数组寻址，肯定是<br>每一行长度为l,每一个元素长度为t<br>Array[a][b] ＝ start ＋(a)l ＋(b)t","like_count":0},{"had_liked":false,"id":32706,"user_name":"小六子","can_delete":false,"product_type":"c1","uid":1046542,"ip_address":"","ucode":"B4E48C9AAF2030","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/0e/7a992528.jpg","comment_is_top":false,"comment_ctime":1539673950,"is_pvip":false,"replies":[{"id":"11943","content":"好","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539702045,"ip_address":"","comment_id":32706,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539673950","product_id":100017301,"comment_content":"“你发现问题了吗？这段代码的运行结果并非是打印三行“hello word”，而是会无限打印“hello world”，这是为什么呢？”<br><br>同样的代码在我的电脑上（VS Community2015）只打印了四行，建议老师在“在这段大码的运行结果...”前面增加“在您的电脑上...在其他电脑或者编译器下也许结果会不同”来说明下。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426865,"discussion_content":"好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539702045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32551,"user_name":"海贼王","can_delete":false,"product_type":"c1","uid":1239233,"ip_address":"","ucode":"9F35793FAA3F5E","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/c1/e2cc1d04.jpg","comment_is_top":false,"comment_ctime":1539606950,"is_pvip":false,"replies":[{"id":"11952","content":"我考虑一下","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539703544,"ip_address":"","comment_id":32551,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539606950","product_id":100017301,"comment_content":"老师您好，能提供一版您的代码吗？有错我们可以通过其他分支的方式进行修改，如果每个人都修改您的代码就无法按照您可课件的思路进行理解了，这很容易让新学者产生误区，谢谢🙏","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426813,"discussion_content":"我考虑一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539703544,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32448,"user_name":"lennon","can_delete":false,"product_type":"c1","uid":1000577,"ip_address":"","ucode":"EE6632E4FB84D6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/81/aa0b0b0e.jpg","comment_is_top":false,"comment_ctime":1539575231,"is_pvip":false,"replies":[{"id":"11876","content":"请看下留言区其他同学的解释吧","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539614908,"ip_address":"","comment_id":32448,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539575231","product_id":100017301,"comment_content":"如果是内存地址递减的方式，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循。有点不明白这一段，为什么递减的时候，就回到了i=0的位置呢，请指教","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426775,"discussion_content":"请看下留言区其他同学的解释吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539614908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32256,"user_name":"Lorne.Z","can_delete":false,"product_type":"c1","uid":1109854,"ip_address":"","ucode":"8C67D82246A3AC","user_header":"https://static001.geekbang.org/account/avatar/00/10/ef/5e/381d043b.jpg","comment_is_top":false,"comment_ctime":1539502764,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539502764","product_id":100017301,"comment_content":"--总结--<br>数组：<br>1. 线性表：数据最多只有前后两个方向，如：（数组，链表，队列，栈）<br>2. 一组连续的内存空间<br>3. 相同类型的数据<br>特点：随机访问<br>数组查找的时间复杂度并不是O(1)，数组的随机访问时间复杂度是O(1)<br>数组排好序，再用二分查找的时间复杂度也是O(logn)<br>非线性表：数据之间并不是简单地前后关系，如（树，堆，图）<br><br>数组的寻址地方计算方式为：a[i]_address = base_address + i * data_type_size<br><br>JVM的标记-清理垃圾回收算法：虚拟机采用可达性分析算法来判断对象是否存活，遍历所有GC ROOTS，将所有GC ROOTS可达的对象标记为存活，标记完成后进行清理工作（这种方式会有内存碎片的问题）<br><br>JVM的标记-整理垃圾回收算法：在标记清理垃圾回收算法的基础上，将所有存活的数据向一端移动，then，清理掉边界以为的内存。","like_count":0},{"had_liked":false,"id":32245,"user_name":"Brighton王","can_delete":false,"product_type":"c1","uid":1235657,"ip_address":"","ucode":"4C6DF7C0191C3C","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/c9/ed1ac545.jpg","comment_is_top":false,"comment_ctime":1539495245,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539495245","product_id":100017301,"comment_content":"这节课干货满满，学到很多，谢谢老师o(^o^)o","like_count":0},{"had_liked":false,"id":32195,"user_name":"kakasi","can_delete":false,"product_type":"c1","uid":1237297,"ip_address":"","ucode":"64F357E6A08CA5","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/31/eb103bdc.jpg","comment_is_top":false,"comment_ctime":1539481653,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539481653","product_id":100017301,"comment_content":"补充: 列表容器与数组的选择。<br>业务开发基本可以选择列表，而底层可能要考虑数组。<br>列表对于数组而言优势是已经封装好，使用起来很方便，动态扩容也封装了。而劣势是，无法使用基本类型作为元素，对于包装类会有自动装箱损耗一些性能。<br>因此很简单的处理，并且知道数据大小，那么用数组吧，其他用列表。","like_count":0},{"had_liked":false,"id":32175,"user_name":"黑化肥","can_delete":false,"product_type":"c1","uid":1083451,"ip_address":"","ucode":"564185846CB43F","user_header":"https://static001.geekbang.org/account/avatar/00/10/88/3b/d1b3a9e7.jpg","comment_is_top":false,"comment_ctime":1539478216,"is_pvip":true,"replies":[{"id":"11755","content":"从1还是0是习惯和喜好的问题 都可以的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539528695,"ip_address":"","comment_id":32175,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539478216","product_id":100017301,"comment_content":"有一个疑问，为什么oracle里面定义的数组都是从1开始呢？包括它的一些函数如substr 之类也是从1开始……","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426665,"discussion_content":"从1还是0是习惯和喜好的问题 都可以的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539528695,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32141,"user_name":"黑桃K","can_delete":false,"product_type":"c1","uid":1234939,"ip_address":"","ucode":"1439F7F46B4982","user_header":"https://static001.geekbang.org/account/avatar/00/12/d7/fb/384ef0a1.jpg","comment_is_top":false,"comment_ctime":1539431688,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539431688","product_id":100017301,"comment_content":"总结：<br>数组是线性表，区别于二叉树，图等。<br>数组内存连续，支持随机访问，通过下标访问的时间复杂度o（1），同时由于内存连续，插入删除，平均时间复杂度o（n），可以进行优化，例如插入时将插入位置移至最后，删除时，只进行标记，统一删除。<br>数组可能会导致越界访问，有些编译器不会检查，老师讲到的由于局部变量在栈中的内存地址由高到低增长，a（3）即为i的地址，所以会越界修改数据i。<br>容器相较于数组，可以省去很多操作，指定容器大小较好，也可以在需要性能的时候使用数组。<br>关于下标0开始问题，c语言历史遗留，且可以简化cpu运算。<br>问题：<br>jvm垃圾回收，标记阶段，标记可用的对象，清除阶段将不可用的全部清除。和数组删除的优化有异曲同工之妙。<br>二维数组，m行n列，则a[i][j] 地址为 基地址 加 i ✖m ➕ j","like_count":0},{"had_liked":false,"id":31946,"user_name":"OP_未央","can_delete":false,"product_type":"c1","uid":1036902,"ip_address":"","ucode":"571C9E0C4E84CD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d2/66/811970de.jpg","comment_is_top":false,"comment_ctime":1539337678,"is_pvip":true,"replies":[{"id":"11612","content":"你可以看看留言区里其他同学的回复，都讲的很好了。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539403518,"ip_address":"","comment_id":31946,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539337678","product_id":100017301,"comment_content":"int main(int argc, char* argv[...<br>内存覆盖的问题，如果WIN系统是这样的，linux并非如此会按照结构体大小排序。仅个人测试结果，请正哥看一下，帮忙解答一下，谢谢！","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426574,"discussion_content":"你可以看看留言区里其他同学的回复，都讲的很好了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539403518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31868,"user_name":"djane","can_delete":false,"product_type":"c1","uid":1249032,"ip_address":"","ucode":"5315AA246AFDD8","user_header":"","comment_is_top":false,"comment_ctime":1539315916,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539315916","product_id":100017301,"comment_content":"【笔记】<br>一、如何实现随机访问？<br>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。<br>1、线性表：线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。<br>（常见的线性表结构：数组，链表、队列、栈等。）<br>非线性表：二叉树、堆、图等。<br>2、连续的内存空间和相同类型的数据。<br>特性：“随机访问”。但让数组的很多操作变得非常低效。比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。<br>（数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。）<br><br>二、低效的“插入”和“删除”<br>1、在数组末尾插入元素，不需要移动数据，最好时间复杂度为 O(1)。<br>在数组开头插入元素，所有的数据都需要依次往后移动一位，最坏时间复杂度是 O(n)。<br>在每个位置插入元素的概率是一样的，平均情况时间复杂度为 (1+2+…n)&#47;n=O(n)。<br>2、删除数组末尾的数据，最好情况时间复杂度为 O(1)。<br>删除开头的数据，则最坏情况时间复杂度为 O(n)。<br>平均情况时间复杂度也为 O(n)。<br>（很多时候我们并不是要去死记硬背某个数据结构或者算法，而是要学习它背后的思想和处理技巧，这些东西才是最有价值的。）<br><br>三、警惕数组的访问越界问题<br>数组越界在 C 语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。因为，访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。这种情况下，一般都会出现莫名其妙的逻辑错误，debug 的难度非常的大。而且，很多计算机病毒也正是利用到了代码中的数组越界可以访问非法地址的漏洞，来攻击系统，所以写代码的时候一定要警惕数组越界。<br><br>四、容器能否完全替代数组？<br>1、Java ArrayList 无法存储基本类型。特别关注性能，或者希望使用基本类型，就可以选用数组。<br>2、如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。<br>3、表示多维数组时，用数组往往会更加直观。<br>4、对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。<br>5、如果是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。<br><br>五、为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始呢？<br>1、为了减少一次减法操作。如果从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。<br>2、历史原因。C 语言设计者用 0 开始计数数组下标，之后的 Java、JavaScript 等高级语言都效仿了 C 语言，或者说，为了在一定程度上减少 C 语言程序员学习 Java 的学习成本，因此继续沿用了从 0 开始计数的习惯。<br><br>【思考】<br>1、JS标记清除垃圾回收算法<br>这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。<br>（参考资料：https:&#47;&#47;developer.mozilla.org&#47;zh-CN&#47;docs&#47;Web&#47;JavaScript&#47;Memory_Management）<br><br>2、一维数组的内存寻址公式：a[i]_address = base_address + i * data_type_size<br>二维数组(a[m][n])的内存寻址公式：a[i][j] = base_address + (i*n+j) * data_type_size","like_count":0},{"had_liked":false,"id":31860,"user_name":"kakasi","can_delete":false,"product_type":"c1","uid":1237297,"ip_address":"","ucode":"64F357E6A08CA5","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/31/eb103bdc.jpg","comment_is_top":false,"comment_ctime":1539313903,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539313903","product_id":100017301,"comment_content":"数组的定义：线性表的数据结构。一组连续的内存空间，存储相同数据类型的数据。<br><br>数组的存储空间是连续的，元素的地址计算可以这样表示：address = first_address + i * data_type_size, data_type_size表示一个元素的字节大小，如int就是4个字节。这也是为什么数组一般都是从0开始，因为下标 i 其实代表“偏移量”，如果要从1开始的话就是address = first_address + （i - 1） * data_type_size 那么CPU就会多一次减法指令，是得不偿失的。<br><br>根据留言区大神的发言，也知道了为什么那段代码是无限循环的。不同的编译器分配内存空间时有递增和递减的方式。从这个示例中能看到 i 是在数组相邻的高地址，因此会直接访问到 i","like_count":0},{"had_liked":false,"id":31831,"user_name":"王建","can_delete":false,"product_type":"c1","uid":1153792,"ip_address":"","ucode":"68000818D8AA41","user_header":"https://static001.geekbang.org/account/avatar/00/11/9b/00/8c1b9631.jpg","comment_is_top":false,"comment_ctime":1539308189,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539308189","product_id":100017301,"comment_content":"代码中<br>int insert(struct array *array, int elem)<br><br>1 if (idx &lt; array-&gt;used)<br>2\t\tmemmove(&amp;array-&gt;arr[array-&gt;used], &amp;array-&gt;arr[idx],\t(array-&gt;used - idx) * sizeof(int));<br>应该是<br>3 if (idx &lt; array-&gt;used)<br>4\t\tmemmove(&amp;array-&gt;arr[idx+1], &amp;array-&gt;arr[idx],\t(array-&gt;used - idx) * sizeof(int));<br>为什么1，2 也能运行呢，没有看懂。测试了下当数组 元素和数组 相同时是是错的。没有找到原因","like_count":0},{"had_liked":false,"id":31807,"user_name":"城","can_delete":false,"product_type":"c1","uid":1035315,"ip_address":"","ucode":"32C4FCE1944000","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cc/33/19f150d9.jpg","comment_is_top":false,"comment_ctime":1539305861,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539305861","product_id":100017301,"comment_content":"个人对死循环问题，有点不一样的看法。在有堆栈溢出保护的情况下(一般编译器都有这个)，后定义的先入栈，而我们知道，栈的生长方向是从高地址到低地址。所以arr数组的地址是高于i的。因此出现不会死循环。如果堆栈保护关闭，则是先定义的入栈，就会出现死循环问题。","like_count":0},{"had_liked":false,"id":31581,"user_name":"机遇号","can_delete":false,"product_type":"c1","uid":1105053,"ip_address":"","ucode":"A2940DE77BCAEA","user_header":"https://static001.geekbang.org/account/avatar/00/10/dc/9d/e20b37d7.jpg","comment_is_top":false,"comment_ctime":1539236981,"is_pvip":false,"replies":[{"id":"11382","content":"再看遍文章吧","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539256356,"ip_address":"","comment_id":31581,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539236981","product_id":100017301,"comment_content":"int main(int argc, char* argv[]){<br>    int i = 0;<br>    int arr[3] = {0};<br>    for(; i&lt;=3; i++){<br>        arr[i] = 0;<br>        printf(&quot;hello world\\n&quot;);<br>    }<br>    return 0;<br>}<br>你好，我在java里调试此代码没有无限循环","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426414,"discussion_content":"再看遍文章吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539256356,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31576,"user_name":"glbfor.gtw","can_delete":false,"product_type":"c1","uid":1225344,"ip_address":"","ucode":"20BAD3CB52366F","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/80/e9223398.jpg","comment_is_top":false,"comment_ctime":1539235662,"is_pvip":false,"replies":[{"id":"11383","content":"👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539256461,"ip_address":"","comment_id":31576,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539235662","product_id":100017301,"comment_content":"a[m][n] 数组，a[i][j] 的地址写成如下形式<br>更容易理解二维数组的内存存储结构<br>address = base_address + i * n  * type_size +  j * type_size<br>拆解：<br>a[i] 的address_i = base_address + i * n  * type_size<br>设定z = a[i]<br>则 z[j] = address_i  *  j  *  type_size<br>既 a[i][j] = address_i  *  j  *  type_size<br>代入既为最初公式","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426410,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539256461,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31512,"user_name":"hqx","can_delete":false,"product_type":"c1","uid":1233994,"ip_address":"","ucode":"68013874054274","user_header":"https://static001.geekbang.org/account/avatar/00/12/d4/4a/e921f579.jpg","comment_is_top":false,"comment_ctime":1539221060,"is_pvip":false,"replies":[{"id":"11418","content":"我没说内存碎片呀","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539269060,"ip_address":"","comment_id":31512,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539221060","product_id":100017301,"comment_content":"数组中间没存值，会导致内存碎片，这不理解。<br>既然是数组了，那么整个内存就给数组用了，是业务决定的，不是内存分配器决定的。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426380,"discussion_content":"我没说内存碎片呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539269060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31490,"user_name":"刘榴","can_delete":false,"product_type":"c1","uid":1063491,"ip_address":"","ucode":"08C51E3CE77889","user_header":"https://static001.geekbang.org/account/avatar/00/10/3a/43/6abf3b7d.jpg","comment_is_top":false,"comment_ctime":1539218149,"is_pvip":false,"replies":[{"id":"11421","content":"我的意思是a[3]和i指向了同一个内存空间，a[3]=0就相当于i=0","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539269331,"ip_address":"","comment_id":31490,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539218149","product_id":100017301,"comment_content":"我有一个疑问：i 内存里的值不是一直变吗？因此访问 a[3] 的时候 i 值应该不是 0 ，而是 4。不知道理解对不对","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426369,"discussion_content":"我的意思是a[3]和i指向了同一个内存空间，a[3]=0就相当于i=0","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539269331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31384,"user_name":"好吃二师兄","can_delete":false,"product_type":"c1","uid":1242173,"ip_address":"","ucode":"A367B52BC79199","user_header":"https://static001.geekbang.org/account/avatar/00/12/f4/3d/ec3d6348.jpg","comment_is_top":false,"comment_ctime":1539168006,"is_pvip":false,"replies":[{"id":"11439","content":"加油💪","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539270169,"ip_address":"","comment_id":31384,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539168006","product_id":100017301,"comment_content":"评论的大佬好多，大佬们都如此努力，更加有动力学习了","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426316,"discussion_content":"加油💪","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539270169,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31288,"user_name":"Pineleen","can_delete":false,"product_type":"c1","uid":1257829,"ip_address":"","ucode":"0758FC9C7F0771","user_header":"https://static001.geekbang.org/account/avatar/00/13/31/65/15199a06.jpg","comment_is_top":false,"comment_ctime":1539143140,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539143140","product_id":100017301,"comment_content":"数组是一种线性表数据结构，用一组连续的内存空间，来存储一组具有相同类型的数据。<br><br>线性表：数据排成一条线一样的结构。每个线性表上的数据最多只有前和后两个方向，是为线性表。<br>数组、链表、队列、栈都是线性表结构。<br><br>二叉树（每一个元素有分叉）、堆、图（数据互相有多个关系）是非线性表。<br><br>连续的内存空间，和相同数据类型，导致了数组最重要的特性：  可以随意访问数据。<br><br>随机访问的本质是 a[i]_addr = base_addr + i   *  data_type_size。 本质是地址可以通过下标进行换算，从而一步找到数据的地址。<br><br>对于数组的插入操作， 如果数组是有序的，需要移位， 如果数组是无序的，可以把要插入的元素放在最后，是O(n)的操作， 把要插入的值，赋值给对应的位上就可以了，是O(1)的操作。 如果需要移位的，其实可以用memcpy系统调用来做，不至于去一个个移位。<br><br>数组和链表的区别：<br>数组可以随机访问数据，复杂度是O(1)<br>链表访问数据的复杂度是O（n），链表的插入和删除操作简单，复杂度是O(1)。<br>","like_count":0},{"had_liked":false,"id":31152,"user_name":"张亮","can_delete":false,"product_type":"c1","uid":1180355,"ip_address":"","ucode":"CC3526F0A96318","user_header":"https://static001.geekbang.org/account/avatar/00/12/02/c3/e9026d82.jpg","comment_is_top":false,"comment_ctime":1539127287,"is_pvip":false,"replies":[{"id":"11231","content":"😂 很多人都这么回答","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539135444,"ip_address":"","comment_id":31152,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539127287","product_id":100017301,"comment_content":"面试回答数组适合查找，时间复杂度为O(1)我也干过。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426250,"discussion_content":"😂 很多人都这么回答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539135444,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31149,"user_name":"Mr.J","can_delete":false,"product_type":"c1","uid":1242443,"ip_address":"","ucode":"1ABC816526CC22","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/4b/76588b52.jpg","comment_is_top":false,"comment_ctime":1539123779,"is_pvip":false,"replies":[{"id":"11232","content":"这个寻址公式看着有点奇怪 你可以看看留言区中其他同学的回复","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539135521,"ip_address":"","comment_id":31149,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539123779","product_id":100017301,"comment_content":"二维数组的寻址公式：a[k][j]_address = bass_address + k * type_k_size + j * type_j_size","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426249,"discussion_content":"这个寻址公式看着有点奇怪 你可以看看留言区中其他同学的回复","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539135521,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31148,"user_name":"Mr.J","can_delete":false,"product_type":"c1","uid":1242443,"ip_address":"","ucode":"1ABC816526CC22","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/4b/76588b52.jpg","comment_is_top":false,"comment_ctime":1539123521,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539123521","product_id":100017301,"comment_content":"JVM的垃圾回收机制，也是标记，他会标记两次，可达性分析之后，没有与GC Roots相连接的引用链，那它将会被第一次标记，第一次标记后接着会进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。在finalize()方法中没有重新与引用链建立关联关系的，将被进行第二次标记。经过两次标记后，会执行一次删除操作，根据内存区域不同，执行不同的删除算法。","like_count":0},{"had_liked":false,"id":31139,"user_name":"qinggeouye","can_delete":false,"product_type":"c1","uid":1251536,"ip_address":"","ucode":"5B53EEDD7BEC9C","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/d0/49b06424.jpg","comment_is_top":false,"comment_ctime":1539102981,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539102981","product_id":100017301,"comment_content":"警惕数组越界问题，关于无限循环分析了讲解内容和留言区，总结如下：<br><br>    int main(int argc, char* argv[]){<br>        int i = 0;<br>        int arr[3] = 0;<br>        for(; i&lt;=3; i++){<br>            arr[i] = 0;<br>            printf(&quot;hello world\\n&quot;);<br>        }<br>        return 0;<br>    }<br><br>结论：无限循环打印 &quot;hello world&quot; 。<br><br>原因：<br><br>1. 变量 i 和数组 arr 的数据类型相同<br>2. 变量 i 和数组 arr 申请的内存空间是连续的<br>3. 这里认为，编译器在内存分配时，按照内存地址递增或递减的方式进行分配。<br>4. 例如 栈是由高位向低位增长的，所以 i 和 数组 arr 的数据从高位地址到低位地址依次为 i, arr[2], arr[1], arr[0] 。<br>5. arr[3] 访问越界，通过寻址公式，对应的正好是 i 的存储地址，arr[3] 和 i 的存储地址相同，此时给 arr[3] 赋值 0 就相当于 i=0。<br>6. 数组越界在 C 语言中是一种未决行为，C 语言没有规定数组访问越界时编译器应该如何处理。访问数组本质上是访问一段连继内存，只要数组通过偏移计算得到的内存地址可用，那么程序不会报任何错误。<br>","like_count":0},{"had_liked":false,"id":31132,"user_name":"现禾霞","can_delete":false,"product_type":"c1","uid":1046056,"ip_address":"","ucode":"8AAAA69A866460","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f6/28/91f222cb.jpg","comment_is_top":false,"comment_ctime":1539098757,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539098757","product_id":100017301,"comment_content":"死循环的理解，可以参照深入理解计算机系统的p128对栈的讲述","like_count":0},{"had_liked":false,"id":31016,"user_name":"永远年轻","can_delete":false,"product_type":"c1","uid":1097653,"ip_address":"","ucode":"349BF9EEB4FE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/bf/b5/a8db0572.jpg","comment_is_top":false,"comment_ctime":1539067269,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539067269","product_id":100017301,"comment_content":"1、GC 标记清除法: 对内存中不可达对象进行标记，累积到一定程度触发一次清除操作。<br>缺点：标记和清除的效率不高，会产生不连续的内存碎片。<br>2、<br>假设 int a[][] = new int[3][3]<br>申请了 1000 ~ 1035 的内存空间，因为此二维数组可以看作三个连续的数组:<br>a[0][0] ~ a[0][2]: 1000 ~ 1011<br>a[1][0] ~ a[1][2]: 1012 ~ 1023<br>a[2][0] ~ a[2][2]: 1024 ~ 1035<br>二维数组的内存寻址公式<br>a[i][j]_address = base_address + （i * a[i].length + j)* data_type_size","like_count":0},{"had_liked":false,"id":31011,"user_name":"Triple Z 💤","can_delete":false,"product_type":"c1","uid":1233998,"ip_address":"","ucode":"A6DB7C91B903CE","user_header":"https://static001.geekbang.org/account/avatar/00/12/d4/4e/5813df2f.jpg","comment_is_top":false,"comment_ctime":1539065615,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539065615","product_id":100017301,"comment_content":"前面我基于数组的原理引出 JVM 的标记清除垃圾回收算法的核心理念。我不知道你是否使用 Java 语言，理解 JVM，如果你熟悉，可以在评论区回顾下你理解的标记清除垃圾回收算法。<br><br>&gt; Java 的 JVM GC 的方式我不是特别了解，但是在 Python 中，GC 同样也有标记清除的方式。当没有空闲内存时，就从寄存器和程序栈上的引用出发，遍历以对象为节点，引用为边构成的图，把所有可以访问到的对象都打上标记，最后清扫一遍内存空间，把没有打上标记的对象释放。<br><br>前面我们讲到一维数组的内存寻址公式，那你可以思考一下，类比一下，二维数组的内存寻址公式是怎样的呢？<br><br>&gt; a[i][j]_address = base_address + (i * max_column_count + j) * type_size<br>&gt;<br>&gt; `max_column_count` 为数组每行的列数值。","like_count":0},{"had_liked":false,"id":30967,"user_name":"良辰美景","can_delete":false,"product_type":"c1","uid":1074803,"ip_address":"","ucode":"B36E6955A2872D","user_header":"https://static001.geekbang.org/account/avatar/00/10/66/73/fd1e37a2.jpg","comment_is_top":false,"comment_ctime":1539054364,"is_pvip":false,"replies":[{"id":"11147","content":"看起来不对呢 你看看其他同学的答案","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539059334,"ip_address":"","comment_id":30967,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539054364","product_id":100017301,"comment_content":"二维数组找地址公式：(base_address + a*type_size) + b*type_size， a为一维偏移量， b为二维偏移量","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426161,"discussion_content":"看起来不对呢 你看看其他同学的答案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539059334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30953,"user_name":"李小草","can_delete":false,"product_type":"c1","uid":1240476,"ip_address":"","ucode":"83DAA0BFDC2068","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/9c/7afa883f.jpg","comment_is_top":false,"comment_ctime":1539052258,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539052258","product_id":100017301,"comment_content":"不诉离殇：例子中死循环的问题跟编译器分配内存和字节对齐有关 数组3个元素 加上一个变量a 。4个整数刚好能满足8字节对齐 所以i的地址恰好跟着a2后面 导致死循环。。如果数组本身有4个元素 则这里不会出现死循环。。因为编译器64位操作系统下 默认会进行8字节对齐 变量i的地址就不紧跟着数组后面了。     这段话不对吧？编译器64位操作系统下int是4字节，如果数组有四个元素，刚好满足8字节对齐，则编译器依然在紧贴着分配8字节存储i来满足8字节内存对齐啊。请作者回答下看正确与否。。。","like_count":0},{"had_liked":false,"id":30935,"user_name":"lcp","can_delete":false,"product_type":"c1","uid":1147461,"ip_address":"","ucode":"3C9975BFF7654E","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/45/981ac8ab.jpg","comment_is_top":false,"comment_ctime":1539049431,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539049431","product_id":100017301,"comment_content":"go 版本数组<br>func (this *Array) isIndexOutOfRange(index uint) bool {<br>\tif this.length != 0 &amp;&amp; index &gt; this.length {<br>\t\treturn true<br>\t}<br>\treturn false<br>}<br>想问一下，这里判断是否越界为什么是index &gt; this.length，而不是index &gt;= this.length？","like_count":0},{"had_liked":false,"id":30892,"user_name":"Geek_e1336f","can_delete":false,"product_type":"c1","uid":1243814,"ip_address":"","ucode":"AAF8D8BDBBBAEB","user_header":"https://static001.geekbang.org/account/avatar/00/12/fa/a6/cb7350b9.jpg","comment_is_top":false,"comment_ctime":1539044856,"is_pvip":false,"replies":[{"id":"11094","content":"看看其他同学的留言吧","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539048714,"ip_address":"","comment_id":30892,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539044856","product_id":100017301,"comment_content":"为什么那个死循环原因有从栈结构来讲有从内存字节对齐来讲，本质原因究竟是啥啊？我看老师回复里面也是用感觉来说，不太确定呀","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426135,"discussion_content":"看看其他同学的留言吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539048714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30879,"user_name":"醉比","can_delete":false,"product_type":"c1","uid":1248399,"ip_address":"","ucode":"79E65F62BE7809","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/8f/4ebd303a.jpg","comment_is_top":false,"comment_ctime":1539038883,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539038883","product_id":100017301,"comment_content":"若考虑性能，则选用数组。若用与一半的业务开发，使用容器即可。<br>数组下标为0是因为从cpu性能考虑。","like_count":0},{"had_liked":false,"id":30874,"user_name":"舍得","can_delete":false,"product_type":"c1","uid":1147685,"ip_address":"","ucode":"2146A08D2D79B6","user_header":"https://static001.geekbang.org/account/avatar/00/11/83/25/10dac87c.jpg","comment_is_top":false,"comment_ctime":1539027696,"is_pvip":false,"replies":[{"id":"11104","content":"👍 3维的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539049503,"ip_address":"","comment_id":30874,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539027696","product_id":100017301,"comment_content":"Type arr[i][j][k]  == <br>*reinterpret_cast&lt;Type*&gt;(reinterpret_cast&lt;size_t&gt;(&amp;arr) + i*sizeof(arr[0]) + j*sizeof(arr[0][0]) + k*sizeof(arr[0][0][0]));","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426123,"discussion_content":"👍 3维的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539049503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30857,"user_name":"冯","can_delete":false,"product_type":"c1","uid":1161601,"ip_address":"","ucode":"7369C8B1A50D29","user_header":"https://static001.geekbang.org/account/avatar/00/11/b9/81/1680ec3f.jpg","comment_is_top":false,"comment_ctime":1539013496,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539013496","product_id":100017301,"comment_content":"数组是内存连续的，对cpu的缓存非常友好，cpu从主存加载时会一并将相邻的数据加载至cpu的缓存中(cache line)，如果是连续的数组访问，非常快，不用每次都读主存.","like_count":0},{"had_liked":false,"id":30856,"user_name":"Rancood","can_delete":false,"product_type":"c1","uid":1204333,"ip_address":"","ucode":"052BDF2221F480","user_header":"https://static001.geekbang.org/account/avatar/00/12/60/6d/e2576fda.jpg","comment_is_top":false,"comment_ctime":1539013489,"is_pvip":false,"replies":[{"id":"11109","content":"寻址公式不对 看看留言区其他同学的答案","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539050232,"ip_address":"","comment_id":30856,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539013489","product_id":100017301,"comment_content":"jvm 标记清除垃圾回收，是把堆中标记为可回收的对象进行清除，这会造成一个问题，就是堆中内存空间碎片化，如果有个比较大的对象实例被创建，那就得在进行一次垃圾回收了，所以有了标记整理垃圾回收算法，清除完之后，把堆内存空间整理一遍，把未清除的对象实例整理为一个连续存储的形式。<br>二维 a[i][j]=base_address + i*type_size + j*type_size","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426118,"discussion_content":"寻址公式不对 看看留言区其他同学的答案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539050232,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30814,"user_name":"零壹协奏","can_delete":false,"product_type":"c1","uid":1049124,"ip_address":"","ucode":"A90A14413DB458","user_header":"https://static001.geekbang.org/account/avatar/00/10/02/24/1d450194.jpg","comment_is_top":false,"comment_ctime":1539003749,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539003749","product_id":100017301,"comment_content":"关于无限循环的问题，查看了一些资料，总结如下：<br>0. 栈增长方向和操作系统加CPU有关，在Linux&#47;x86架构下，是从高地址到低地址生长，其他的不能做假设。栈的生长方向决定了函数调用栈帧的地址相对大小<br>1. 在单个函数栈帧内，局部变量的分配完全由编译器决定，也就是说标准只要求数组空间连续，至于是高地址在前还是低地址在前没有强制要求<br>2. 综上，出现死循环的情况需要特定的架构以及特定的编译器实现<br>求指正<br>","like_count":0},{"had_liked":false,"id":30763,"user_name":"玉皇大亮","can_delete":false,"product_type":"c1","uid":1019849,"ip_address":"","ucode":"5C4FDF1FDCF8A9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8f/c9/833d5060.jpg","comment_is_top":false,"comment_ctime":1538990865,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538990865","product_id":100017301,"comment_content":"1.垃圾内存回收的机制有四种，分别为标记-清除算法，标记-压缩算法，复制算法和引用计数算法，JVM的垃圾回收机制主要依赖于标记-清除算法，关键点如下：两个核心概念，mutator和collector,其中mutator负责分配内存(new)、读取内存(Read)、写内存(Write),collector负责内存的回收；标记阶段，collector从mutator的根对象开始遍历，将每一个mutator的可达对象都打上一个标识；\b清除阶段，collector从分配的内存区从头到尾开始线性遍历，对于没有标识的内存区块，将其回收，同时每次collector回收时，都会暂停mutator的工作，这应该也是JVM多次GC时影响性能的原因之一。显然标记-清除算法解决了插入数据、删除数据时的数组移动问题，但是缺点也很明显，由于collector回收时，并不从新组织内存数据，因而造成的内存碎片问题也很严重，所以如果某个数据块的内存刚好不够装入内存碎片，则会触发多次回收，直到out of memory。<br>2.首先逻辑上的二维数组，实际上是一维数组，假设为m行，n列，所以a[i][j] = base_addr + (i * n  + j) * type_size","like_count":0},{"had_liked":false,"id":30754,"user_name":"Effort","can_delete":false,"product_type":"c1","uid":1240393,"ip_address":"","ucode":"C64474AA48CE57","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/49/a7b56c99.jpg","comment_is_top":false,"comment_ctime":1538989195,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538989195","product_id":100017301,"comment_content":"老师您好，我在看insert方法中，memmove(&amp;array-&gt;arr[array-&gt;used],&amp;array-&gt;arr[idx],(array-&gt;used - idx)*sizeof(int));如果在需要插曲数据的地方后面存在多个数据。我经过测试会出现bug，所以我修改了方法参数<br>memmove(&amp;array-&gt;arr[idx],&amp;array-&gt;arr[idx+1],(array-&gt;used - idx)*sizeof(int));<br>经过测试可以胜任插曲时候的拷贝工作。这是我的理解，也可能我并没有明白您那段代码有其他更深层次的用意，所以希望您的指正。","like_count":0},{"had_liked":false,"id":30730,"user_name":"_STone","can_delete":false,"product_type":"c1","uid":1235536,"ip_address":"","ucode":"FB2412D98B0554","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/50/c4594897.jpg","comment_is_top":false,"comment_ctime":1538984160,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538984160","product_id":100017301,"comment_content":"热评第一和第二结合起来看就能懂了","like_count":0},{"had_liked":false,"id":30718,"user_name":"Andy","can_delete":false,"product_type":"c1","uid":1012037,"ip_address":"","ucode":"D69ED1BAF42262","user_header":"https://static001.geekbang.org/account/avatar/00/0f/71/45/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1538982317,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538982317","product_id":100017301,"comment_content":"用VS的编译器并不会出现死循环，实验发现，每个变量中间会预留8个字节的空位，所以在上述代码中a[5]才存放的是i ","like_count":0},{"had_liked":false,"id":30715,"user_name":"Andy","can_delete":false,"product_type":"c1","uid":1012037,"ip_address":"","ucode":"D69ED1BAF42262","user_header":"https://static001.geekbang.org/account/avatar/00/0f/71/45/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1538981743,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538981743","product_id":100017301,"comment_content":"我用VS2015测试，发现a[3]并不是i ,  反而在内存中看到a[5]是i 这是为什么呢？","like_count":0},{"had_liked":false,"id":30654,"user_name":"Durian","can_delete":false,"product_type":"c1","uid":1240859,"ip_address":"","ucode":"22C66AEF8F7E49","user_header":"https://static001.geekbang.org/account/avatar/00/12/ef/1b/b2be3e68.jpg","comment_is_top":false,"comment_ctime":1538966267,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538966267","product_id":100017301,"comment_content":"留言里面大佬好啊。本来对于为何能无限循环弄不懂，也自己用python试了一下，也用C在xcode上试了一下，发现都没有无限循环。最后还是留言大佬解答的好。不同编译器会造成不同。<br>JVM：了解得不是太多。但是知道垃圾回收有好几种方法，每个厂商使用的垃圾回收方式也不完全相同，但我了解的大多就是标记清除法<br><br>二维数组寻址方式：a[m][n] = base_iddress + (i*n + j)*data_size","like_count":0},{"had_liked":false,"id":30640,"user_name":"15221031154","can_delete":false,"product_type":"c1","uid":1250537,"ip_address":"","ucode":"0EE6255716517A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epx4KyvThXw7Sm1y7p2Mt0KAwADcU0tynbK58Ik6xTibN2dId4PrLfbhpHZ0DIDhVVxJXvTzeSDEicw/132","comment_is_top":false,"comment_ctime":1538963803,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538963803","product_id":100017301,"comment_content":"通过标记-清除算法，更好的理解了数组的概念","like_count":0},{"had_liked":false,"id":30635,"user_name":"有朋自远方来","can_delete":false,"product_type":"c1","uid":1083600,"ip_address":"","ucode":"23A12829DEB119","user_header":"https://static001.geekbang.org/account/avatar/00/10/88/d0/6e75f766.jpg","comment_is_top":false,"comment_ctime":1538962824,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538962824","product_id":100017301,"comment_content":"计算机内存的随机访问<br>是否和您讲的这个是同理呢？","like_count":0},{"had_liked":false,"id":30524,"user_name":"毛玉娇","can_delete":false,"product_type":"c1","uid":1249192,"ip_address":"","ucode":"BC0F0FEEEAD5DD","user_header":"https://static001.geekbang.org/account/avatar/00/13/0f/a8/5bec6811.jpg","comment_is_top":false,"comment_ctime":1538907316,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538907316","product_id":100017301,"comment_content":"不知道，留言的回复是否是作者：王争大神。希望能官方认证下留言最可取性，说实话留言下的第一和第三我有点分辨不了那个是最正确的说法","like_count":0},{"had_liked":false,"id":30459,"user_name":"Reiser","can_delete":false,"product_type":"c1","uid":1078669,"ip_address":"","ucode":"E5DBBBA2F86FCE","user_header":"https://static001.geekbang.org/account/avatar/00/10/75/8d/c6a2a048.jpg","comment_is_top":false,"comment_ctime":1538875293,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1538875293","product_id":100017301,"comment_content":"二维数组寻址公式<br>a[ j ][ k ] = base_address + j * arrary_size+k * type_size<br>","like_count":0},{"had_liked":false,"id":30403,"user_name":"Haoz","can_delete":false,"product_type":"c1","uid":1022665,"ip_address":"","ucode":"DBDBF78877A7B7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9a/c9/08852337.jpg","comment_is_top":false,"comment_ctime":1538827988,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538827988","product_id":100017301,"comment_content":"一、什么是数组？<br>数组（Array）是一种「线性表」数据结构，它用一组「连续的内存空间」，来存储一组具有「相同类型」的数据。<br><br>线性表：数据排成像一条线一样的结构，每个线性表上的数据最多只有前和后两个方向<br><br>连续的内存空间和相同的数据类型：** 使得数组具有「随机访问」的特性，但也让删除和插入等操作变得非常低效。<br><br>计算机访问数组中某个元素时，所使用的公式：<br>a[i]_address = base_address + i * data_type_size<br><br>二、对数组中的操作进行优化<br><br>2.1 插入操作<br>如果数组中存储的数据并没有任何规律，数组只是被当做一个存储数据的集合，在这种情况下，如果要将某个数据插入到第 k 个位置，为了避免大规模的数据搬移，我们可以直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。<br><br>2.2 删除操作<br>在某些特殊场景下，我们并不一定非得追求数组中数据的连续性，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。<br><br>三、数组在高级语言中的使用场景<br>1、Java ArrayList 无法存储基本类型，而自动拆装箱会有一定的性能消耗，所以如果需要特别关注性能，或者希望使用基本类型，就可以选用数组。<br><br>2、如果数据大小事先已知，并对数据的操作非常简单，也可以直接使用数组。<br><br>3、在表示多维数组时，用数组会更加直观<br><br><br>四、为什么数组从 0 开始编号？<br>1、如果从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。<br><br>2、历史原因，C 语言设计者用 0 开始计数数组下标，之后的 Java、JavaScript 等高级语言都效仿了 C 语言，或者说，为了在一定程度上减少 C 语言程序员学习 Java 的成本。","like_count":0},{"had_liked":false,"id":30369,"user_name":"木子皿","can_delete":false,"product_type":"c1","uid":1242778,"ip_address":"","ucode":"3FDEAFABB4C427","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJUzv6S9wroyXaoFIwvC1mdDiav4BVS4BbPTuwtvWibthL5PyMuxFNicY06QJMZicVpib7E88S19nH4I9Q/132","comment_is_top":false,"comment_ctime":1538811641,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538811641","product_id":100017301,"comment_content":"C++版的代码（和老师的java实现完全相同的接口及功能）：<br>#include &lt;iostream&gt;<br><br>using namespace std;<br><br>namespace  LemonDataStructure {<br><br>template<br>&lt; typename T &gt;<br>class Array<br>{<br>private:<br>    int* m_array;<br>    int m_length;<br>    int m_capacity;<br><br>public:<br>    Array(int capacity)<br>    {<br>        m_array = new T[capacity];  &#47;* 这里不判断m_array是否为空，否则又要引入异常以及重载new操作符... *&#47;<br>                                    &#47;* ...（重载new操作符是为了保证new行为在不同编译器下行为一致性）    *&#47;<br>        m_capacity = capacity;<br>        m_length = 0;<br>    }<br><br>    bool find(int index, T&amp; e)<br>    {<br>        bool ret = (0 &lt;= index) &amp;&amp; (index &lt; m_length);<br><br>        if (ret)<br>        {<br>            e = m_array[index];<br>        }<br><br>        return ret;<br>    }<br><br><br>    bool remove(int index)<br>    {<br>        bool ret = (0 &lt;= index) &amp;&amp; (index &lt; m_length);<br><br>        if (ret)<br>        {<br>            for (int i=index; i&lt;m_length-1; i++)<br>            {<br>                m_array[i] = m_array[i+1];<br>            }<br><br>            m_length--;<br>        }<br><br>        return ret;<br>    }<br><br>    bool insert(int index, const T&amp; e)<br>    {<br>        bool ret = (0 &lt;= index) &amp;&amp; (index &lt;= m_length) &amp;&amp; (m_length &lt; m_capacity);<br><br>        if (ret)<br>        {<br>            for (int i=index; i&lt;m_length; i++)<br>            {<br>                m_array[i+1] = m_array[i];<br>            }<br><br>            m_array[index] = e;<br>            m_length++;<br>        }<br><br>        return ret;<br>    }<br><br>    bool insertToTail(const T&amp; e)<br>    {<br>        bool ret = (m_length &lt; m_capacity);<br><br>        if (ret)<br>        {<br>            m_array[m_length++] = e;<br>        }<br><br>        return ret;<br>    }<br><br>    void printAll()<br>    {<br>        for (int i=0; i&lt;m_length; i++)<br>        {<br>            cout &lt;&lt; m_array[i] &lt;&lt; &quot; &quot;;<br>        }<br><br>        cout &lt;&lt; endl;<br>    }<br><br>    ~Array()<br>    {<br>        delete[] m_array;<br>    }<br>};<br>}<br><br>","like_count":0},{"had_liked":false,"id":30366,"user_name":"Annie","can_delete":false,"product_type":"c1","uid":1247370,"ip_address":"","ucode":"6D4854D53B3F4B","user_header":"https://static001.geekbang.org/account/avatar/00/13/08/8a/94c3f265.jpg","comment_is_top":false,"comment_ctime":1538810204,"is_pvip":false,"replies":[{"id":"10957","content":"两个的做法很相似，你不觉得吗？","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538838356,"ip_address":"","comment_id":30366,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538810204","product_id":100017301,"comment_content":"不明白数组中删除数据提高效率的思想，文中说是JVM标记清除垃圾回收算法的核心思想？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425961,"discussion_content":"两个的做法很相似，你不觉得吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538838356,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30352,"user_name":"QLing","can_delete":false,"product_type":"c1","uid":1245000,"ip_address":"","ucode":"9D3DDA939B72AC","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/48/67342109.jpg","comment_is_top":false,"comment_ctime":1538805509,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538805509","product_id":100017301,"comment_content":"看了这篇文章明白了数组的最底层运行方式：分配一个连续的内存地址，带下标存储地址通过：a[i]_address = base_address + i * data_type_size 方式获取，不管是插入、删除都会更改内存地址。在首插入&#47;删除、在尾插入&#47;删除，它们复杂度不一样。有这样一个基本原理就可以运用到实际开发中，根据实际数据进行分析使用的方法优劣程度。","like_count":0},{"had_liked":false,"id":30347,"user_name":"周平","can_delete":false,"product_type":"c1","uid":1259488,"ip_address":"","ucode":"4954DC474C4FDF","user_header":"https://static001.geekbang.org/account/avatar/00/13/37/e0/23f288ae.jpg","comment_is_top":false,"comment_ctime":1538802103,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538802103","product_id":100017301,"comment_content":"关于标记删除，mysql的MYISAM引擎也是用的这个方法。 删除数据时，是标记删除，磁盘空间并不释放，以提高删除操作的性能。如果想真正的清理掉数据，需要使用optimize命令，来释放磁盘空间。","like_count":0},{"had_liked":false,"id":30184,"user_name":"莫问流年","can_delete":false,"product_type":"c1","uid":1249663,"ip_address":"","ucode":"23140E031AED4B","user_header":"https://static001.geekbang.org/account/avatar/00/13/11/7f/80d56c1c.jpg","comment_is_top":false,"comment_ctime":1538716408,"is_pvip":false,"replies":[{"id":"10892","content":"对的！<br>","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538749157,"ip_address":"","comment_id":30184,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538716408","product_id":100017301,"comment_content":"二维数组地址计算公式：<br>a[i][j]_address = base_address +(i * n + j) * type_size<br>其中，i &lt; m，j &lt; n。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425884,"discussion_content":"对的！\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538749157,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30115,"user_name":"智慧树叶","can_delete":false,"product_type":"c1","uid":1246066,"ip_address":"","ucode":"58DA4631AA3584","user_header":"","comment_is_top":false,"comment_ctime":1538669367,"is_pvip":false,"replies":[{"id":"10886","content":"我们复杂度那一节讲过可以忽略掉系数、常数、低阶。感觉你还是没对复杂度的定义有个很好在掌握。当然可以表示成O(n+1&#47;2)，但是意义不大，或者说没有意义。我们都是简化成O(n)来表示的。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538748879,"ip_address":"","comment_id":30115,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538669367","product_id":100017301,"comment_content":"老师，删除的平均时间复杂度化简为O(n+1&#47;2)，然后就可以直接化简为O(n)吗？虽然常用的是O(n)，但是这个时间复杂度不能写成O(n+1&#47;2)吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425858,"discussion_content":"我们复杂度那一节讲过可以忽略掉系数、常数、低阶。感觉你还是没对复杂度的定义有个很好在掌握。当然可以表示成O(n+1/2)，但是意义不大，或者说没有意义。我们都是简化成O(n)来表示的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538748879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30094,"user_name":"茎待佳阴","can_delete":false,"product_type":"c1","uid":1042464,"ip_address":"","ucode":"21A7DC2C3EA389","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e8/20/3374ea9e.jpg","comment_is_top":false,"comment_ctime":1538656930,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538656930","product_id":100017301,"comment_content":"针对于@slvher的回复，补充一点，一般现在的编译器都会插入一些垃圾值来保护，所以未必就会无限循环","like_count":0},{"had_liked":false,"id":30074,"user_name":"李之村","can_delete":false,"product_type":"c1","uid":1239512,"ip_address":"","ucode":"3E3BCBF8B9DD58","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/d8/a94ba376.jpg","comment_is_top":false,"comment_ctime":1538647104,"is_pvip":false,"replies":[{"id":"10798","content":"👍，就喜欢你这种动手实验的同学！不过，也请看看其他同学的留言。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538656476,"ip_address":"","comment_id":30074,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538647104","product_id":100017301,"comment_content":"用vim试了下死循环那个例子，发现没有死循环。对于数组a，压栈的顺序是a［0］，a［1］，a［2］。所以将代码改为初始化i 为2，循环范围是i ≥-1。这样才能在vim中实现死循环。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425845,"discussion_content":"👍，就喜欢你这种动手实验的同学！不过，也请看看其他同学的留言。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538656476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30062,"user_name":"大坏蛋","can_delete":false,"product_type":"c1","uid":1240376,"ip_address":"","ucode":"E5728F85273D14","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/38/217ecccb.jpg","comment_is_top":false,"comment_ctime":1538641210,"is_pvip":false,"replies":[{"id":"10799","content":"我定义的数组中的元素是紧密排列，所以不允许任意位置插入。当然，你也可以按照你说的来定义insert方法，只要能满足你的需求就可以。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538656636,"ip_address":"","comment_id":30062,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538641210","product_id":100017301,"comment_content":"请教下：<br>https:&#47;&#47;github.com&#47;wangzheng0822&#47;algo&#47;blob&#47;master&#47;java&#47;05_array&#47;Array.java中的insert、delete方法中<br>if (index &lt; 0 || index &gt;= count) return false;<br>是不是应为<br>if (index &lt; 0 || index &gt;=n) return false;<br> n存储的数组length；count存储的数组元素个数，只要index未越界，应该就可以进行insert、delete操作吧。望老师解答，谢谢。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425839,"discussion_content":"我定义的数组中的元素是紧密排列，所以不允许任意位置插入。当然，你也可以按照你说的来定义insert方法，只要能满足你的需求就可以。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538656636,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29904,"user_name":"缓哟","can_delete":false,"product_type":"c1","uid":1241391,"ip_address":"","ucode":"0D560AFCA6BECA","user_header":"https://static001.geekbang.org/account/avatar/00/12/f1/2f/3ec9fcfb.jpg","comment_is_top":false,"comment_ctime":1538586102,"is_pvip":false,"replies":[{"id":"10831","content":"说的很对，是要分行优先还是列优先。问题没看懂。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538659518,"ip_address":"","comment_id":29904,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538586102","product_id":100017301,"comment_content":"二维数组寻址方式，是不是要分为按行优先和按列优先。<br>对于二维数组A[m][n]，求A[i][j](0≤i≤m，0≤j≤n)的地址，按行优先是A[0][0]+(i*n+j)*k，按列优先是A[0][0]+(j*m+i)*k<br><br>那么，如果二维数组越界了，此时的地址要怎么计算呢？？？？<br><br>回复我一下回复我一下回复我一下","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425771,"discussion_content":"说的很对，是要分行优先还是列优先。问题没看懂。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538659518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29899,"user_name":"wean","can_delete":false,"product_type":"c1","uid":1239735,"ip_address":"","ucode":"3E069F95C25EAD","user_header":"https://static001.geekbang.org/account/avatar/00/12/ea/b7/1f7316e6.jpg","comment_is_top":false,"comment_ctime":1538584457,"is_pvip":false,"replies":[{"id":"10832","content":"👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538659538,"ip_address":"","comment_id":29899,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538584457","product_id":100017301,"comment_content":"这节课主要讲了数组的概念及对应特点的影响，还跟 Java 的 ArrayList 做了比较。<br><br>概念<br>数据是一种线性表数据结构，所谓线性表，就是数据排成像一条线一样的数据结构。<br>这里数组用一组连续的内存空间，来存储相同类型的数据。<br>数组支持随机访问。这个特点也是因为它占有连续的内存空间。数组的寻址公式是 :<br>a[i]_address = base_address + i *data_type_size<br>当面试时，我们不应该说数组的查找时间复杂度是 O(1)，排序好的数组，用二分查找，时间复杂度是 O(logn)。正确的表述是，根据下标随机访问的时间复杂度是 O(1)。<br><br>但是也是因为这个原因，数组的插入和删除非常“低效”。为了保持连续性，需要做大量的数据迁移工作。<br><br>插入<br>如果数据是有序的，每次插入到数组的第 k 个位置，需要把 k~n 这部分数据都往后移以为，若是在每个位置插入元素的概率是一样的，那么平均时间复杂度是 (1+2+...n)&#47;n=O(n)。<br><br>若数据是无序的，数组只是一个存储数据的集合，这种情况下，要把数据插入到第 k 个位置，可以尝试把第 k 个元素移到数组的最后面，把新元素插入到第 k 个位置，这样在特定场景下，插入一个元素到第 k 个位置时间复杂度可以降为 0。<br><br>删除<br>和插入一样，最好情况下时间复杂度是 O(1)，如果删除开头的数据，则是最坏情况时间复杂度 O(n)，平均情况下时间复杂度是 O(n)。<br><br>如果我们将多次删除操作集中在一起删除，就可以提高删除的效率，这也是 jvm 的标记清楚垃圾回收算法。<br><br>容器<br>ArrayList 相比数组，最大的优势就是将许多细节封装起来了，比如前面提到的数组插入、删除时需要搬移其他数据等。另外的优势就是自动扩容了。<br><br>但不是所有情况都需要用到 ArrayList。比如<br><br>ArrayList 无法存储基本类型。自动封箱拆箱需要性能消耗。<br>有些操作较为简单，无需用到 ArrayList。<br>定义多维数组时，若是用 ArrayList 看起来不直观。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425768,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538659538,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29896,"user_name":".                 Rain。","can_delete":false,"product_type":"c1","uid":1250816,"ip_address":"","ucode":"944BDA1C1F6571","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/00/fb37baf1.jpg","comment_is_top":false,"comment_ctime":1538583145,"is_pvip":false,"replies":[{"id":"10779","content":"对的！","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538624864,"ip_address":"","comment_id":29896,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538583145","product_id":100017301,"comment_content":"（发现不能回复自己的留言）<br>二维数组（m*n）内存地址公式：a[i][j]_address = base_address + (i*n+j) * data_type_size","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425765,"discussion_content":"对的！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538624864,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29879,"user_name":"SunshlnW","can_delete":false,"product_type":"c1","uid":1211252,"ip_address":"","ucode":"7B82BBC5F30633","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/74/63563202.jpg","comment_is_top":false,"comment_ctime":1538578141,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538578141","product_id":100017301,"comment_content":"如果是C和C++，用指针表示二维数组，每行都分开申请内存，那这个数组是不连续的，这个时候就不能简单的利用java的那个公式计算吧？希望能老师能解答一下，谢谢！","like_count":0},{"had_liked":false,"id":29878,"user_name":"SunshlnW","can_delete":false,"product_type":"c1","uid":1211252,"ip_address":"","ucode":"7B82BBC5F30633","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/74/63563202.jpg","comment_is_top":false,"comment_ctime":1538577897,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538577897","product_id":100017301,"comment_content":"栈的增长方向与架构有关系,x86机器是向下增长，所以先存储i，接着存储数组a，i的地址比数组a的高，同时c语言中是数组起始即a[0]应该放在最低地址。所以有高地址-&gt;低地址。对应i-&gt;a[2]-&gt;a[1]-&gt;a[0],同时评论区大佬指出，64位系统默认是8字节对齐，所以这四个int数据刚好符合，所以访问a[3]时可以访问到i，但是如果数组有四个int元素，则这四个刚好对齐，这时候i的地址就不紧跟着数组a了，所以不一定会无限循环。<br><br>","like_count":0},{"had_liked":false,"id":29863,"user_name":"Duo An","can_delete":false,"product_type":"c1","uid":1058085,"ip_address":"","ucode":"901C9802511B07","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/25/fb2ba003.jpg","comment_is_top":false,"comment_ctime":1538570162,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538570162","product_id":100017301,"comment_content":"Jvm使用GCRoot作为根节点进行可达性分析，标记可达对象，标记算法又有很多种，经典的要说三色标记了。在清理阶段不同的算法可能不同实现，新创建对象申请不到内存时，就会gc 这个时候就是作者文中说到的先标记后删除的删除阶段。","like_count":0},{"had_liked":false,"id":29857,"user_name":".                 Rain。","can_delete":false,"product_type":"c1","uid":1250816,"ip_address":"","ucode":"944BDA1C1F6571","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/00/fb37baf1.jpg","comment_is_top":false,"comment_ctime":1538566458,"is_pvip":false,"replies":[{"id":"10713","content":"二维数组寻址公式不对 再想想吧","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538581061,"ip_address":"","comment_id":29857,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538566458","product_id":100017301,"comment_content":"数组的定义：数据是一种线性表数据结构。它用一组连续的内存空间，来存储一组相同类型的数据。<br>线性表：数组，链表，队列，栈<br>非线性表：树，堆，图<br>数组特性：随机访问<br>随机访问原理：通过寻址公式，计算被访问元素存储的内存地址<br>寻址公式：a[i]_address = base_address + i * data_type_size<br>数组与链表的区别：链表适合插入与删除，数组具有随机访问的特性<br>有序数组定位插入：<br>无序数组定位插入：k位置元素放入数组末端，待插入元素放入k位置<br> <br>多次删除集中执行：先记录已删除数据（数据未真正删除），当无内存空间存储数据时，触发集中删除操作\t\t\t\t\t（联系  JVM 标记清除垃圾回收算法的核心思想）<br>数组越界：<br>容器与数组的选择：业务开发，选择容器，损耗部分性能，不影响系统整体性能；底层开发，选择数组，优化性能<br>二维数组（m*n）内存地址公式：a[i][j]_address = base_address + ((i-1)*m+j) * data_type_size<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425743,"discussion_content":"二维数组寻址公式不对 再想想吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538581061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29842,"user_name":"燕明","can_delete":false,"product_type":"c1","uid":1239470,"ip_address":"","ucode":"6783DC4BB489C1","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/ae/8908e32f.jpg","comment_is_top":false,"comment_ctime":1538558464,"is_pvip":false,"replies":[{"id":"10716","content":"👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538581271,"ip_address":"","comment_id":29842,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538558464","product_id":100017301,"comment_content":"标记清除算法分为两个阶段:标记和清除阶段。首先标记出所有要回收的对象，在标记完成后统一回收所有被标记的对象。一个对象真正被回收至少要经历两次标记过程:如果对象在进行可达性分析后发现没有与GC ROOTS相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。如果这个对象被判定为有必要执行finalize()方法，这个对象会被放置在f-Queue的队列之中。稍后GC会对F-Queue中的对象进行第二次小规模标记，判断对象在finalise()方法中是否成功与GC ROOTS建立关键，如果仍没有建立关联，还对象就被真正标记为可回收。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425736,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538581271,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29840,"user_name":"姚震.Prometheus","can_delete":false,"product_type":"c1","uid":1238276,"ip_address":"","ucode":"6FB6574696B5F4","user_header":"https://static001.geekbang.org/account/avatar/00/12/e5/04/4c7d988e.jpg","comment_is_top":false,"comment_ctime":1538558106,"is_pvip":false,"replies":[{"id":"10717","content":"你这个是什么呀？c++中的vector容器？limiandeset是啥？","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538581368,"ip_address":"","comment_id":29840,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538558106","product_id":100017301,"comment_content":"有个问题就是类似vector&lt;set&gt;这样的结构他到底是顺序存储还是随机的呢","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425735,"discussion_content":"你这个是什么呀？c++中的vector容器？limiandeset是啥？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538581368,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29837,"user_name":"Only U","can_delete":false,"product_type":"c1","uid":1139167,"ip_address":"","ucode":"94FD3F8E87D72D","user_header":"https://static001.geekbang.org/account/avatar/00/11/61/df/11db20f2.jpg","comment_is_top":false,"comment_ctime":1538557069,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538557069","product_id":100017301,"comment_content":"根据内存分配策略及寻址方式，把int i = 0与int a[3] = {0}交换位置就只会输出四次hello world便执行结束。","like_count":0},{"had_liked":false,"id":29810,"user_name":"leo","can_delete":false,"product_type":"c1","uid":1107385,"ip_address":"","ucode":"0A3D3508398328","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLhicDSmL4vicPF4mF9g5icORERwDSqZv5Guk0TyhiacuBsiaVxCdktI6oCrKzcycwFlpyL6Q1nDbvJZzA/132","comment_is_top":false,"comment_ctime":1538548416,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538548416","product_id":100017301,"comment_content":"Redis的压缩列表就是基于连续型存储结构实现的，由于是在内存中的布局是一块连续的内存空间，所以可以减小内存碎片的产生，是一种用时间换空间的思想。","like_count":0},{"had_liked":false,"id":29804,"user_name":"katsueiki","can_delete":false,"product_type":"c1","uid":1016400,"ip_address":"","ucode":"0B4DF961583A83","user_header":"https://static001.geekbang.org/account/avatar/00/0f/82/50/d70af165.jpg","comment_is_top":false,"comment_ctime":1538547037,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538547037","product_id":100017301,"comment_content":"why numbering should start at zero<br><br><br><br>http:&#47;&#47;note.youdao.com&#47;noteshare?id=7189c5b12a087e7f9a2a141b588aadc1","like_count":0},{"had_liked":false,"id":29799,"user_name":"Shanks-王冲","can_delete":false,"product_type":"c1","uid":1042983,"ip_address":"","ucode":"C4B90A17850E20","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ea/27/a3737d61.jpg","comment_is_top":false,"comment_ctime":1538543768,"is_pvip":false,"replies":[{"id":"10728","content":"对！","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538582177,"ip_address":"","comment_id":29799,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538543768","product_id":100017301,"comment_content":"# 二维数组寻址公式<br>a[i]_address = base_address + i * a[i].length * data_type_size<br>a[i][j]_address = base_address + (i * a[i].length + j) * data_type_size","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425721,"discussion_content":"对！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538582177,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29792,"user_name":"cserbo","can_delete":false,"product_type":"c1","uid":1240958,"ip_address":"","ucode":"C8D1A83A675CA0","user_header":"https://static001.geekbang.org/account/avatar/00/12/ef/7e/ecea53d2.jpg","comment_is_top":false,"comment_ctime":1538542868,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538542868","product_id":100017301,"comment_content":"我觉得标记清除算法在单纯的数组上会很难实现，这个思想是好的，实现的时候可能需要增加空间的消耗，老师能就这个问题示范一下吗？","like_count":0},{"had_liked":false,"id":29783,"user_name":"Fieldhunter","can_delete":false,"product_type":"c1","uid":1250680,"ip_address":"","ucode":"AAEAAE6AF64137","user_header":"https://static001.geekbang.org/account/avatar/00/13/15/78/8298abb8.jpg","comment_is_top":false,"comment_ctime":1538539171,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538539171","product_id":100017301,"comment_content":"二维数组的内存寻址，我用坐标系来类比比较好描述，左上角最顶端的数据为首地址，也就相当于坐标系的原点，要去找二维数组中的数据，只要知道要找的数据相对于首地址（即原点）x，y轴方向偏移的值就行了。表述可能不是很好......","like_count":0},{"had_liked":false,"id":29780,"user_name":"cserbo","can_delete":false,"product_type":"c1","uid":1240958,"ip_address":"","ucode":"C8D1A83A675CA0","user_header":"https://static001.geekbang.org/account/avatar/00/12/ef/7e/ecea53d2.jpg","comment_is_top":false,"comment_ctime":1538538876,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538538876","product_id":100017301,"comment_content":"int〔〕  a   这是作者的伪代码表达吗？cc++应该都没有这个吧？","like_count":0},{"had_liked":false,"id":29763,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1538534178,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1538534178","product_id":100017301,"comment_content":"jvm标记清除算法会在运行时将不可达对象打上删除标记，但是不做真正删除清理动作。在垃圾回收条件达到时，会stw，将所有被标记对象清除，释放堆内存。","like_count":0},{"had_liked":false,"id":29699,"user_name":"ERROR","can_delete":false,"product_type":"c1","uid":1243507,"ip_address":"","ucode":"588CF98447612F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f9/73/2a0c56d5.jpg","comment_is_top":false,"comment_ctime":1538490712,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538490712","product_id":100017301,"comment_content":"看到有人讲死循环用栈来理解，让我想起来在看链表C#时，找到的文章说了线程栈和托管堆。线程栈存储了值类型和引用类型实例的地址，托管堆存储引用类型实例。搜了一下线程栈的叫法似乎是.NET才有，不知道老师会不会讲到这部分。","like_count":0},{"had_liked":false,"id":29685,"user_name":"Fly55","can_delete":false,"product_type":"c1","uid":1251563,"ip_address":"","ucode":"FFA9D5C6EDD6F4","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/eb/fd0b4a1f.jpg","comment_is_top":false,"comment_ctime":1538486608,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1538486608","product_id":100017301,"comment_content":"“标记-清除”（Mark-Sweep）分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。","like_count":0},{"had_liked":false,"id":29670,"user_name":"佑强","can_delete":false,"product_type":"c1","uid":1252011,"ip_address":"","ucode":"9C8B55127FEFCD","user_header":"https://static001.geekbang.org/account/avatar/00/13/1a/ab/b352a655.jpg","comment_is_top":false,"comment_ctime":1538477764,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538477764","product_id":100017301,"comment_content":"JVM在对象失去引用，或者通过可达性分析算法判断对象可回收之后，标记该对象，标记后的对象还是存活的并没有，只是逻辑删除，当虚拟机为新对象分配内存空间或者为大对象分配空间时没有连续的内存区域可供存储，则会调用垃圾回收器对所有被标记的对象进行真正的删除操作，这就是标记删除算法，由于被标记的对象可能不是在连续的内存空间，所以该算法会产生内存碎片，一般主流的虚拟机会根据不同生命周期的对象用标记整理算法或者复制算法来清除对象","like_count":0},{"had_liked":false,"id":29666,"user_name":"liangjf","can_delete":false,"product_type":"c1","uid":1058812,"ip_address":"","ucode":"681A6CCF098F55","user_header":"https://static001.geekbang.org/account/avatar/00/10/27/fc/b8d83d56.jpg","comment_is_top":false,"comment_ctime":1538476045,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538476045","product_id":100017301,"comment_content":"第一篇正式文章就勾引起我对数组的存储方式，特性，例子里同一进程变量入栈特点(为什么刚好出现无限循环的原因)，标准的寻址公式，为啥下标从0开始...<br>谢谢老师","like_count":0},{"had_liked":false,"id":29642,"user_name":"小老鼠","can_delete":false,"product_type":"c1","uid":1257460,"ip_address":"","ucode":"C663A0C863A515","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/f4/2dede51a.jpg","comment_is_top":false,"comment_ctime":1538466328,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538466328","product_id":100017301,"comment_content":"如果釆用用标记性删除，那么计算数组中有效元数个数不就变得复杂了？","like_count":0},{"had_liked":false,"id":29640,"user_name":"yaya","can_delete":false,"product_type":"c1","uid":1233856,"ip_address":"","ucode":"8C7FAC8F828BA4","user_header":"https://static001.geekbang.org/account/avatar/00/12/d3/c0/d38daa2d.jpg","comment_is_top":false,"comment_ctime":1538466105,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538466105","product_id":100017301,"comment_content":"在栈中，地址由高向低，所以arr的空间走完之后就访问到了i，导致无限循环。<br>为什么下标从0开始基于地址计算是由offset决定的。如果从1需要多做一次减法指令操作。历史原因。看了这个解释很疑惑为什么matlab要从1开始呢，有什么原因吗。<br>jvm垃圾回收机制，不是很了解。删除这里没有太明白。他批量删除是把末位元素复制在前吗？还是整个向前复制。<br>作业:a[i][j]的地址:＊(a+i)+j","like_count":0},{"had_liked":false,"id":29639,"user_name":"小老鼠","can_delete":false,"product_type":"c1","uid":1257460,"ip_address":"","ucode":"C663A0C863A515","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/f4/2dede51a.jpg","comment_is_top":false,"comment_ctime":1538465648,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538465648","product_id":100017301,"comment_content":"1，在无序的数组中，删除操作的时间复杂度也可为O(1)，具体解释为a[5]={1,2,3,4,5}，现在要刪除3，我们可以把3删除后，把末尾的5移入到3处。即最后a[5]={1,2,5,4, }。<br>2，请教下在python 中数组的insert、del方法的内部具体实现方法及其时间复杂度。<br>a[5]={1,2,3,4,5}<br>a.insert(2,7)：在数组a变量2的位置加入数值7。<br>del a[2]：删除数组a变量2的位置的数值。","like_count":0},{"had_liked":false,"id":29631,"user_name":"星夜幽空","can_delete":false,"product_type":"c1","uid":1249485,"ip_address":"","ucode":"34B737B72829B8","user_header":"https://static001.geekbang.org/account/avatar/00/13/10/cd/d132bb75.jpg","comment_is_top":false,"comment_ctime":1538463668,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538463668","product_id":100017301,"comment_content":"日常交流中涉及 第1个元素。那有没有第0个元素。 到底是从第几个开始的，容易造成歧义。 其实我认为下标就应该从1开始！。","like_count":0},{"had_liked":false,"id":29616,"user_name":"梦其不可梦","can_delete":false,"product_type":"c1","uid":1241487,"ip_address":"","ucode":"145C43CB072C88","user_header":"https://static001.geekbang.org/account/avatar/00/12/f1/8f/b3273afe.jpg","comment_is_top":false,"comment_ctime":1538453089,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538453089","product_id":100017301,"comment_content":"对于顶楼的哪位同学的问题(为什么a[3]刚好等于i ？)，我的理解是这样的。<br>这涉及到一点底层的内容:<br>在内存分配时，变量存储在栈中，栈在内存中的增长方向由高到低，<br>假设分配i时地址是100,那么100-103就是i的空间了，然后有分配了数组a[3]，共3个int，需要12个位置，故a就在100-12=88的位置了，<br>a[0]在88-91，a[1]在92-95，a[2]在96-99，<br>而c没有做越界保护，计算a[3]的地址时:88+3×4=100，刚好是i的位置。所以把i给变成0了。","like_count":0},{"had_liked":false,"id":29613,"user_name":"陈蒙","can_delete":false,"product_type":"c1","uid":1250013,"ip_address":"","ucode":"9E8303709AFAF5","user_header":"https://static001.geekbang.org/account/avatar/00/13/12/dd/74fca186.jpg","comment_is_top":false,"comment_ctime":1538452621,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538452621","product_id":100017301,"comment_content":"1.老师对数组的分析，加深了我对容器的理解。容器相当于基于数组这种数据结构对CRUD操作的优化的算法封装，容器对于大多数应用场景其时间复杂度都比较好，在没有十足的把握情况下一般就考虑使用容器，但对于一个特定的使用场景，自己写个专门的算法肯定更优（有难度）。<br>2.关于JVM的标记清除算法，JVM有很多的垃圾回收算法，算法本身没有好坏，要对应不同的场景进行区分。垃圾清理的核心思路和方向在于垃圾分类 ：D，老年代、新生代、分区清理等。标记清除适用于垃圾量较少的情况，先行标记，积累到一定量后统一清理，相反适用复制算法。在此基础上再进行细粒度的分区回收。","like_count":0},{"had_liked":false,"id":29596,"user_name":"李奇","can_delete":false,"product_type":"c1","uid":1251720,"ip_address":"","ucode":"71406A298DE398","user_header":"https://static001.geekbang.org/account/avatar/00/13/19/88/77bba747.jpg","comment_is_top":false,"comment_ctime":1538449821,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538449821","product_id":100017301,"comment_content":"a[i][j]_address = base_address +i * m * sizeofdata +j     *sizeofdata。其中i表示行，j表示列，m是列数。","like_count":0},{"had_liked":false,"id":29577,"user_name":"学渣！！！","can_delete":false,"product_type":"c1","uid":1224654,"ip_address":"","ucode":"A224265D9E7CCC","user_header":"https://static001.geekbang.org/account/avatar/00/12/af/ce/d7ae8da9.jpg","comment_is_top":false,"comment_ctime":1538446533,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538446533","product_id":100017301,"comment_content":"标记清除算法是在标记阶段，标记需要纺一回收的标记对象，在清除阶段进行清除，缺点是标记清除的对象可能是不连续的，容易造成垃圾碎片。jvm还有一种标记整理算法，前面阶段一样，后面在清理的时候会会让所有的存活对象进行移动，然后清理垃圾对象，这样就没有垃圾碎片了。二维数组应该也是一块连续的内存块，每个数组元素里面放的是一个一维数组。","like_count":0},{"had_liked":false,"id":29574,"user_name":"Mr.Panda","can_delete":false,"product_type":"c1","uid":1238864,"ip_address":"","ucode":"655A3013B5E849","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/50/d476ed6c.jpg","comment_is_top":false,"comment_ctime":1538445904,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538445904","product_id":100017301,"comment_content":"文章非常棒！留言区也卧虎藏龙，真幸福！总结写在云笔记上了，自律给我自由！共勉","like_count":0},{"had_liked":false,"id":29572,"user_name":"古月","can_delete":false,"product_type":"c1","uid":1256787,"ip_address":"","ucode":"A7113A73B44976","user_header":"https://static001.geekbang.org/account/avatar/00/13/2d/53/56ca9a1c.jpg","comment_is_top":false,"comment_ctime":1538445438,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538445438","product_id":100017301,"comment_content":"课后思考题2：<br>假设：二维数组可表示为：a[n][m]，要找的元素为a[x][y];则位置为：首地址+{（x-1）*n+m}*地址单元类型大小","like_count":0},{"had_liked":false,"id":29560,"user_name":"涛","can_delete":false,"product_type":"c1","uid":1039265,"ip_address":"","ucode":"204AE0F083D483","user_header":"https://static001.geekbang.org/account/avatar/00/0f/db/a1/7f9baa17.jpg","comment_is_top":false,"comment_ctime":1538439825,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538439825","product_id":100017301,"comment_content":"总结:<br>1. 什么是数组?<br>数组（Array）是一种线性表数据结构。它用一组连续的内存空间,存储一组相同类型的数据. 注意三个关键点, 线性表的数据结构,内存空间连续,数据结构相同.<br>2. 数组的特点:<br> 2.1 插入和删除低效. 如果是无序数组,只是为了存储数据,可以把插入值与最后一个值交换. 删除低效可以使用标记删除的方法改进.<br> 2.2 警惕数组的访问越界问题<br>3. 容器与数组的对比:<br> 3.1 容器支持动态扩容.容器无法存储基本类型.<br> 3.2 业务开发使用容器就够了,底层,框架开发,优先考虑性能.<br><br><br>","like_count":0},{"had_liked":false,"id":29559,"user_name":"涛","can_delete":false,"product_type":"c1","uid":1245815,"ip_address":"","ucode":"555B9877F6AA4D","user_header":"https://static001.geekbang.org/account/avatar/00/13/02/77/f307372e.jpg","comment_is_top":false,"comment_ctime":1538439696,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538439696","product_id":100017301,"comment_content":"一个二维数组被写成m*n我不知道对不对，m*n难道不是m维吗？二维 难道不是 2*n吗？","like_count":0},{"had_liked":false,"id":29546,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1538410381,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538410381","product_id":100017301,"comment_content":"JVM的标记清除垃圾回收算法：JVM把堆内存空间视为一个长数组进行管理，在一次GC时，把需要清理的位置进行标记，然后再统一清除。优点单次执行比较快，缺点是内存利用率不高，产生碎片。<br><br>类比一维数组：<br>有T[] a = new int[n]，且a的地址为 ADD_a，则a[n] = ADD_a + sizeof(T) * n<br>二维数组：<br>有T[][] b = new int[m][n]，且b的地址为ADD_b，则b[x][y] = ADD_b + sizeof(T) * (n * x + y)<br>","like_count":0},{"had_liked":false,"id":29542,"user_name":"韩","can_delete":false,"product_type":"c1","uid":1218674,"ip_address":"","ucode":"75BB3E48AE7E45","user_header":"https://static001.geekbang.org/account/avatar/00/12/98/72/0dccb3e7.jpg","comment_is_top":false,"comment_ctime":1538408929,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538408929","product_id":100017301,"comment_content":"二维数组寻址:baseAddr + i x lengthOfType + j x lengthOfType<br><br>老师，我有个疑问:上面这个式子是说明了寻址结果的计算方式，而不是底层内部实现吧？因为按照式子来看每次访问二维数组元素都需要两个乘法指令 + 两个加法指令<br><br>如果在二维数组声明时就记录下每一行行首地址，每次的寻址时间就和一维的情况一样了，只是多了点存储开销。实际二维数组底层的实现是这样的吗？","like_count":0},{"had_liked":false,"id":29541,"user_name":"sea","can_delete":false,"product_type":"c1","uid":1219713,"ip_address":"","ucode":"599730A093D356","user_header":"https://static001.geekbang.org/account/avatar/00/12/9c/81/78107cf1.jpg","comment_is_top":false,"comment_ctime":1538408853,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538408853","product_id":100017301,"comment_content":"gc标记是把需要gc的标记好，然后集中gc，这样就可以把连续内存当成一段内存GC，就节省了多次迁移相关内存的性能。","like_count":0},{"had_liked":false,"id":29540,"user_name":"sea","can_delete":false,"product_type":"c1","uid":1219713,"ip_address":"","ucode":"599730A093D356","user_header":"https://static001.geekbang.org/account/avatar/00/12/9c/81/78107cf1.jpg","comment_is_top":false,"comment_ctime":1538408628,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538408628","product_id":100017301,"comment_content":"根据一维数据的公式，二维数组内存公式应该是a[k][j]address  =  baseAddress  + (k * jSize + j) * typeSize","like_count":0},{"had_liked":false,"id":29537,"user_name":"阳仔","can_delete":false,"product_type":"c1","uid":1046920,"ip_address":"","ucode":"79F73D85EDF3E2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/88/cdda9e6f.jpg","comment_is_top":false,"comment_ctime":1538407555,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538407555","product_id":100017301,"comment_content":"学习反馈：<br>数组可以说是最简单的数据结构。从它的定义中看出两个重要的方面：<br>1、是一个线性表；<br>2、在一组连续的空间上存储相同的数据类型；<br>数组支持下标随机访问元素，时间复杂度为O(1)；它的“删除”和“插入”操作并不高效，需要移动数据中大规模数据，时间复杂度为O(n)。<br>要访问数组第k个元素的寻址计算公式为：<br>a[k]=a数组首地址+k*数组中的数据类型大小。<br>要注意数组访问越界的问题<br>对于在平时开发过程中，选择数组还是容器的问题<br>1、容器封装了数组操作的细节，且支持动态扩容。因此在做业务开发时，可以牺牲一点点性能，换取编码的效率；在使用容器的时候，可以尽量为容器指定大小，避免做很多无用的扩容操作。<br>2、在开发对性能要求较高的底层框架时，可以考虑选择数组。<br>开篇问题<br>这个问题答案个人觉得不是特别重要，它是一个吸引人注意的话题。从解析这个话题的过程中，我们了解了数组的特点，知道了它的寻址计算方式，以及与其他数组结构的区别。<br>","like_count":0},{"had_liked":false,"id":29536,"user_name":"观望者","can_delete":false,"product_type":"c1","uid":1142107,"ip_address":"","ucode":"08F3D79D3C811D","user_header":"https://static001.geekbang.org/account/avatar/00/11/6d/5b/03763d38.jpg","comment_is_top":false,"comment_ctime":1538407527,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538407527","product_id":100017301,"comment_content":"二维数组的寻址，a[i, j] _ address = base_address + type_size * i + j * typesize","like_count":0},{"had_liked":false,"id":29535,"user_name":"观望者","can_delete":false,"product_type":"c1","uid":1142107,"ip_address":"","ucode":"08F3D79D3C811D","user_header":"https://static001.geekbang.org/account/avatar/00/11/6d/5b/03763d38.jpg","comment_is_top":false,"comment_ctime":1538407347,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538407347","product_id":100017301,"comment_content":"@Rain<br>如果你熟悉C语言的话，就会知道C里面的函数在内存中是用“栈”的数据结构把变量压入的。<br>所以编译器会把main翻译成，将变量i入栈，然后再把数组入栈，结果你访问越界数组的时候，正好就访问到了i的内存地址上。","like_count":0},{"had_liked":false,"id":29533,"user_name":"六六六","can_delete":false,"product_type":"c1","uid":1252230,"ip_address":"","ucode":"933BC99EC09001","user_header":"https://static001.geekbang.org/account/avatar/00/13/1b/86/22a9362f.jpg","comment_is_top":false,"comment_ctime":1538405313,"is_pvip":false,"replies":[{"id":"10620","content":"👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538407079,"ip_address":"","comment_id":29533,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538405313","product_id":100017301,"comment_content":"1. 标记清除垃圾回收算法分为标记和清除两个阶段。标记：使用根搜索算法，遍历GC Roots，将所有GC Root可达的对象标记为存活对象。清除：遍历所有对象，将没有标记的对象全部清除<br>2. 二维数组的寻址公式：二维数组的地址也是连续地址，所以假设数组大小为a[m][n],则a[i][j]_address = base_address + i * n * type_size + j * type_size  ","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425652,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538407079,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29531,"user_name":"花生","can_delete":false,"product_type":"c1","uid":1252241,"ip_address":"","ucode":"93A097D5129495","user_header":"https://static001.geekbang.org/account/avatar/00/13/1b/91/66f0d38a.jpg","comment_is_top":false,"comment_ctime":1538405273,"is_pvip":false,"replies":[{"id":"10621","content":"👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538407107,"ip_address":"","comment_id":29531,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538405273","product_id":100017301,"comment_content":"高赞有个关于 无限循环 的回答很好啊，补充一下，可以看编译原理对这部分的解释。编译原理 虎书 活动记录那一部分<br><br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425651,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538407107,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29530,"user_name":"韩","can_delete":false,"product_type":"c1","uid":1218674,"ip_address":"","ucode":"75BB3E48AE7E45","user_header":"https://static001.geekbang.org/account/avatar/00/12/98/72/0dccb3e7.jpg","comment_is_top":false,"comment_ctime":1538404657,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538404657","product_id":100017301,"comment_content":"另外再赞一个，我觉得这个课程的内容简直太好了。如果我大学的时候数据结构学的是这个课程，恍然大悟的估计还会更早一些。我觉得课程可以考虑和校方合作，这么优质的课程，现在大学里的大学生可能都不知道！","like_count":0},{"had_liked":false,"id":29528,"user_name":"Northern","can_delete":false,"product_type":"c1","uid":1060908,"ip_address":"","ucode":"6B8DB4CF385029","user_header":"https://static001.geekbang.org/account/avatar/00/10/30/2c/333d7080.jpg","comment_is_top":false,"comment_ctime":1538403643,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538403643","product_id":100017301,"comment_content":"根据我们前面讲的数组寻址公式，a[3] 也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址。最后一句话怎么理解？","like_count":0},{"had_liked":false,"id":29523,"user_name":"HouShangLing","can_delete":false,"product_type":"c1","uid":1240213,"ip_address":"","ucode":"4D6B2F7B3769BE","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/95/9ac3d611.jpg","comment_is_top":false,"comment_ctime":1538402815,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538402815","product_id":100017301,"comment_content":"不知道java还有装箱拆箱的概念。","like_count":0},{"had_liked":false,"id":29521,"user_name":"Mr.钧👻","can_delete":false,"product_type":"c1","uid":1249939,"ip_address":"","ucode":"D781E030E79245","user_header":"https://static001.geekbang.org/account/avatar/00/13/12/93/3470fc43.jpg","comment_is_top":false,"comment_ctime":1538402239,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538402239","product_id":100017301,"comment_content":"数组，是一种线性存储的数据结构，是内存中一块连续的内存空间，存储相同类型的元素。<br>数组的删除，可以先对被删除的元素进行标记，然后当数组满容量后再触发删除操作，这样更加高效。而jvm就是这样的运行原理。<br>索引越界的危害，不太懂","like_count":0},{"had_liked":false,"id":29515,"user_name":"安静的boy","can_delete":false,"product_type":"c1","uid":1196475,"ip_address":"","ucode":"F5F44B75228A85","user_header":"https://static001.geekbang.org/account/avatar/00/12/41/bb/21ce60d2.jpg","comment_is_top":false,"comment_ctime":1538400359,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538400359","product_id":100017301,"comment_content":"问题回答：<br> 问题一：JVM会先标记所有要清除的对象，然后同意清除。和数组删除优化的思路是一样的。<br>问题二：如果查找二维数组的元素是 arr[i][j]。那么寻址公式是先找出arr[i]的内存地址：arr[i]_address = (base_address + i * data_type_size)。arr[i]内存地址中存的是arr[i][j]的内存首地址。如果记为arr[j]_address，那么arr[i][j]的寻址公式为arr[i][j]_address = arr[j]_address + j * data_type_size。<br>回答的结果请老师审阅一下。又错误的话指出一下。谢谢！","like_count":0},{"had_liked":false,"id":29504,"user_name":"虎虎❤️","can_delete":false,"product_type":"c1","uid":1086535,"ip_address":"","ucode":"157F261E80291A","user_header":"https://static001.geekbang.org/account/avatar/00/10/94/47/75875257.jpg","comment_is_top":false,"comment_ctime":1538398001,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538398001","product_id":100017301,"comment_content":"gc 分为 minor gc 和 full gc。<br><br>重点说下Minor gc，分为survivor1 survicor2 和老生代。当survivor1中的内存满了之后，把没有被标记的内存顺序拷贝到survivor2中，反之亦然。新生代为什么分为两个区呢?你可以考虑一下如果只有一个区，做内存整理的难度。举个例子，比如磁盘整理算法中，需要把磁盘分页。然后，把若干次minor gc中一直存活的对象copy的老生代中。<br><br>full gc会清理老生代。一般会产生比较大的开销，java会停下其他的进程，出现卡死的状态。如果你的程序经常出现full gc，你该考虑一下原因啦。","like_count":0},{"had_liked":false,"id":29494,"user_name":"杨伟","can_delete":false,"product_type":"c1","uid":1239937,"ip_address":"","ucode":"D5B521A0688E02","user_header":"https://static001.geekbang.org/account/avatar/00/12/eb/81/43f4b52c.jpg","comment_is_top":false,"comment_ctime":1538394675,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538394675","product_id":100017301,"comment_content":"留言的人还挺多的啊，点赞","like_count":0},{"had_liked":false,"id":29487,"user_name":"D→_→M","can_delete":false,"product_type":"c1","uid":1184017,"ip_address":"","ucode":"5EFDE9E2ED2C8B","user_header":"https://static001.geekbang.org/account/avatar/00/12/11/11/52a78856.jpg","comment_is_top":false,"comment_ctime":1538391694,"is_pvip":false,"replies":[{"id":"10586","content":"1. 有序数组用二分查找的时间复杂度是O(logn)，不过建议再看一下我文章中表述<br>2. 我在周末的时候写篇文章可以集中答疑一下","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538400317,"ip_address":"","comment_id":29487,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538391694","product_id":100017301,"comment_content":"老师我想问一下为何数组查找操作的时间复杂度是O(logn);<br>还有就是一点小建议，可否将每节课后面的思考题，在下一节课中解析一下。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425637,"discussion_content":"1. 有序数组用二分查找的时间复杂度是O(logn)，不过建议再看一下我文章中表述\n2. 我在周末的时候写篇文章可以集中答疑一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538400317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29484,"user_name":"TheTingTings","can_delete":false,"product_type":"c1","uid":1245528,"ip_address":"","ucode":"729CCE441856F5","user_header":"https://static001.geekbang.org/account/avatar/00/13/01/58/1788a7e6.jpg","comment_is_top":false,"comment_ctime":1538390842,"is_pvip":false,"replies":[{"id":"10588","content":"对！但公式的格式可以再优化下","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538400412,"ip_address":"","comment_id":29484,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538390842","product_id":100017301,"comment_content":"声明二维数组int[a][b]<br>a[i][j]ad=(base+i*b*type_size)+j*type_size。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425635,"discussion_content":"对！但公式的格式可以再优化下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538400412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29472,"user_name":"aof","can_delete":false,"product_type":"c1","uid":1062864,"ip_address":"","ucode":"5815D63C4926BC","user_header":"https://static001.geekbang.org/account/avatar/00/10/37/d0/26975fba.jpg","comment_is_top":false,"comment_ctime":1538384012,"is_pvip":false,"replies":[{"id":"10590","content":"后面二维数组的不对 再想想","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538400619,"ip_address":"","comment_id":29472,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538384012","product_id":100017301,"comment_content":"标记清除算法，JVM将把要回收的对象做标记，等到没有连续可用空间时全部将标记对象回收，最大的缺点就是会产生很多不连续的内存空间。<br><br>二维数组因为需要两个下标才能确定一个元素，可以看成一个矩阵matrix，如果是把行下标和列下标直接相加或相乘肯定是不行的，比如1 * 2 等于 2 * 1。推断一下，a[i][j]_address = (base_address + i * data_type_size) * j","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425626,"discussion_content":"后面二维数组的不对 再想想","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538400619,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29470,"user_name":"$Jason","can_delete":false,"product_type":"c1","uid":1040403,"ip_address":"","ucode":"BB0DB558D5BBB3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e0/13/6c2a5bd2.jpg","comment_is_top":false,"comment_ctime":1538383645,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538383645","product_id":100017301,"comment_content":"“数组(Array)是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。”<br>数组在javascript中是可以存储不同类型的数据的。只是说明下。<br>另外期待老师讲解上面大家都提到的问题<br>“根据我们前面讲的数组寻址公式，a[3] 也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。”","like_count":0},{"had_liked":false,"id":29466,"user_name":"胡军","can_delete":false,"product_type":"c1","uid":1234125,"ip_address":"","ucode":"AF4E13E6CF9922","user_header":"https://static001.geekbang.org/account/avatar/00/12/d4/cd/8b155b74.jpg","comment_is_top":false,"comment_ctime":1538382775,"is_pvip":false,"replies":[{"id":"10591","content":"对的！","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538400704,"ip_address":"","comment_id":29466,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538382775","product_id":100017301,"comment_content":"二维数组元素寻址公式：<br><br>设a为一个二维数组a[m][n]<br>a的成员占用内存大小为type_size<br>a的起始位置为base_address<br><br>a[k][j]_address = base_address + k * (type_size * n) + j * type_size","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425622,"discussion_content":"对的！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538400704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29465,"user_name":"勤劳的小胖子-libo","can_delete":false,"product_type":"c1","uid":1158344,"ip_address":"","ucode":"5BB20CD5A56568","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/c8/4b1c0d40.jpg","comment_is_top":false,"comment_ctime":1538382504,"is_pvip":false,"replies":[{"id":"10600","content":"回答正确✅","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538400933,"ip_address":"","comment_id":29465,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538382504","product_id":100017301,"comment_content":"数组地址也是连在一起的，低维的一个一个类型长度连在一起，高维的是一个一个低一级维度的连在一起。<br><br>二维数组计算公式，假设二维数组为Array[n][m]<br>则Array[i][j]=Base_Address+(i*m+j)*type_size;<br>i&lt;n,j&lt;m;","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425621,"discussion_content":"回答正确✅","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538400933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29442,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1538374161,"is_pvip":false,"replies":[{"id":"10603","content":"对的👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538401329,"ip_address":"","comment_id":29442,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538374161","product_id":100017301,"comment_content":"数组插入时间复杂度推导过程:<br>最后一个元素往后移动1次。<br>倒数第二个元素往后移动2次<br>...<br>第一个元素往后移动n位<br><br>假设每个位置插入元素的概率是一样的为1&#47;n。那么移动的时间复杂度为：1*1&#47;n+2*1&#47;n+3*1&#47;n+..n*1&#47;n=(1+2+3+4...+n)&#47;n=n(n+1)&#47;2n。去除常数、及低次项所以为O(n)<br>老师我讲的对吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425607,"discussion_content":"对的👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538401329,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29436,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1538372517,"is_pvip":false,"replies":[{"id":"10606","content":"是的 你理解的没错","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538401396,"ip_address":"","comment_id":29436,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538372517","product_id":100017301,"comment_content":"数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。其实就是int[] a=new int[]。a[index]=?这种访问方式把。而不是Arrays.binarySearch这种访问","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425602,"discussion_content":"是的 你理解的没错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538401396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29429,"user_name":"来碗绿豆汤","can_delete":false,"product_type":"c1","uid":1070051,"ip_address":"","ucode":"B0AB63B8D9729F","user_header":"https://static001.geekbang.org/account/avatar/00/10/53/e3/39dcfb11.jpg","comment_is_top":false,"comment_ctime":1538369015,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538369015","product_id":100017301,"comment_content":"数组最大的优势就是随机访问，不足就是插入，删除数据比较耗时，因为要移动数据。所以如果我们能想办法把劣势消除，那就完美了。在有些情况下确实可以做到。插入的时候如果不需要维护之前数组的顺序，就可以将要插入位置的数据移走，然后直接插入，快速排序就是这样干的;如果是删除操作，可以先标记，等最后一次性删除，也可以减少移动次数，jvm就是这样做的。","like_count":0},{"had_liked":false,"id":29425,"user_name":"夏洛克的救赎","can_delete":false,"product_type":"c1","uid":1021334,"ip_address":"","ucode":"44453DD27A3216","user_header":"https://static001.geekbang.org/account/avatar/00/0f/95/96/0020bd67.jpg","comment_is_top":false,"comment_ctime":1538367598,"is_pvip":false,"replies":[{"id":"10609","content":"好像没有这么说的。你说的这块可以看看操作系统、计算机组成原理","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538401631,"ip_address":"","comment_id":29425,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538367598","product_id":100017301,"comment_content":"“所以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。”<br><br>这句话是否可以进一步理解为：CPU寻址的时间复杂度为 O(1)？ 如果是，那CPU寻址的时间复杂度又如何计算？需要进一步深入了解操作系统？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425595,"discussion_content":"好像没有这么说的。你说的这块可以看看操作系统、计算机组成原理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538401631,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29424,"user_name":"三景页","can_delete":false,"product_type":"c1","uid":1243410,"ip_address":"","ucode":"38588DDAA495BC","user_header":"https://static001.geekbang.org/account/avatar/00/12/f9/12/0e6620cd.jpg","comment_is_top":false,"comment_ctime":1538367597,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538367597","product_id":100017301,"comment_content":"根据我们前面讲的数组寻址公式，a[3] 也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。<br><br>个人觉得在编译器未定义的情况下，说a[3]的地址被定位到i的地址是不严谨的。而且int i定义在数组定义的前面，所以就算可以访问也应该是a[-1]才是。班门弄斧一下","like_count":0},{"had_liked":false,"id":29416,"user_name":"John","can_delete":false,"product_type":"c1","uid":1036468,"ip_address":"","ucode":"449164FE4255CB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d0/b4/a6c27fd0.jpg","comment_is_top":false,"comment_ctime":1538366227,"is_pvip":false,"replies":[{"id":"10615","content":"为什么说按照下标查找会不对呢？","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538405958,"ip_address":"","comment_id":29416,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538366227","product_id":100017301,"comment_content":"老师好，有几个疑问请解答下？1.如果数组采用标记删除的话，这个数组按下标查找就不对了啊，也就没有随机访问的优势了。2.垃圾回收是因为里面维护了内存的使用情况的信息表，不需要随机访问，且维护效率才采用标记清除的吧。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425590,"discussion_content":"为什么说按照下标查找会不对呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538405958,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29415,"user_name":"钟衍辉","can_delete":false,"product_type":"c1","uid":1030229,"ip_address":"","ucode":"EF807515E86D37","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b8/55/3c220676.jpg","comment_is_top":false,"comment_ctime":1538366021,"is_pvip":false,"replies":[{"id":"10616","content":"对！","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538405987,"ip_address":"","comment_id":29415,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1538366021","product_id":100017301,"comment_content":"1、我是这样理解标记清除垃圾回收算法的，确定对象要回收，会将该对象占用内存空间标记为可回收，但并不会马上执行内存的释放。等申请内存空间不够时，才会对已标记的内存空间进行清除。这种方式会造成内存碎片比较多，当需要申请较大内存空间时，可能因为连续可用的空间不够，再次造成GC。<br>2、仿造老师的公式，二维数组内存寻址公式为：a[k][n]_address = base_address + (k * N + n) * type_size;<br>其中N为二维数组中数组元素的长度。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425589,"discussion_content":"对！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538405987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29414,"user_name":"Tenderness","can_delete":false,"product_type":"c1","uid":1124304,"ip_address":"","ucode":"840A6104972502","user_header":"https://static001.geekbang.org/account/avatar/00/11/27/d0/7e18e9a2.jpg","comment_is_top":false,"comment_ctime":1538366000,"is_pvip":false,"replies":[{"id":"10617","content":"👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538406041,"ip_address":"","comment_id":29414,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538366000","product_id":100017301,"comment_content":"回答下思考，不知道描述的准不准确<br>1.标记-清楚算法<br>    分为两个阶段，首先是标记出所有需要回收的对象，标记方法有引用计数法和可达性分析，个人局的一般都是用可达性分析吧，毕竟涉及到互相引用问题。其次就是同意对标记的对象进行回收。<br>2.二维数组寻址<br>    一维数组地址分别是 a , a+i<br>    二维数组a[m][n]的地址表示为：a+i为二位数组第i行的首地址，a[i][j] 元素的地址为 *(a+i) + j , address = base_address + (i*m+j） *  type_size 。地址分配是连续的，逐行分配。 ","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425588,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538406041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29413,"user_name":"Tenderness","can_delete":false,"product_type":"c1","uid":1124304,"ip_address":"","ucode":"840A6104972502","user_header":"https://static001.geekbang.org/account/avatar/00/11/27/d0/7e18e9a2.jpg","comment_is_top":false,"comment_ctime":1538365528,"is_pvip":false,"replies":[{"id":"10618","content":"👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538406053,"ip_address":"","comment_id":29413,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538365528","product_id":100017301,"comment_content":"回答下思考，不知道描述的准不准确<br>1.标记-清除算法<br>    分为两个阶段，首先是标记出所有需要回收的对象，标记方法有引用计数法和可达性分析，个人觉得一般都是用可达性分析吧，毕竟涉及到互相引用问题。其次就是统一对标记的对象进行回收。<br>2.二维数组寻址<br>    一维数组地址分别是a ，a+i<br>    二维数组地址表示为 a+i为二维数组第i行的首地址，a[i][j]元素的地址为*(a+i)+j，address=base_address+(i*m+j)*type_address，m为数组的行数。地址分配是连续的，一行接一行。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425587,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538406053,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29402,"user_name":"windliang","can_delete":false,"product_type":"c1","uid":1234620,"ip_address":"","ucode":"D31E26BFB09DE6","user_header":"https://static001.geekbang.org/account/avatar/00/12/d6/bc/026ac6b1.jpg","comment_is_top":false,"comment_ctime":1538363426,"is_pvip":false,"replies":[{"id":"10625","content":"1. 不同的语言对数组访问越界的处理方式不同，即便是同一种语言，不同的编译器处理的方式也不同。至于你熟悉的语言是怎么处理的，请行百度。<br>2. C语言中，数组访问越界的处理是未决。并不一定是错，有同学做实验说没问题，那并不代表就是正确的。<br>3. 我觉得那个例子，栈是由高到低位增长的，所以，i和数组的数据从高位地址到低位地址依次是：i, a[2], a[1], a[0]。a[3]通过寻址公式，计算得到地址正好是i的存储地址，所以a[3]=0，就相当于i=0.<br>4. 大家有不懂的多看看留言，留言区还是有很多大牛的！我可能有时候回复的不及时，或者同样的问题只回复一个同学！","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538407314,"ip_address":"","comment_id":29402,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538363426","product_id":100017301,"comment_content":"尝试了先定义 i 再定义数组，先定义数组再定义 i ，发现都不是无限循环。把地址输出，也没有发现 i 的地址和数组的地址有什么联系。<br><br>求老师讲一下这块的意思。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425583,"discussion_content":"1. 不同的语言对数组访问越界的处理方式不同，即便是同一种语言，不同的编译器处理的方式也不同。至于你熟悉的语言是怎么处理的，请行百度。\n2. C语言中，数组访问越界的处理是未决。并不一定是错，有同学做实验说没问题，那并不代表就是正确的。\n3. 我觉得那个例子，栈是由高到低位增长的，所以，i和数组的数据从高位地址到低位地址依次是：i, a[2], a[1], a[0]。a[3]通过寻址公式，计算得到地址正好是i的存储地址，所以a[3]=0，就相当于i=0.\n4. 大家有不懂的多看看留言，留言区还是有很多大牛的！我可能有时候回复的不及时，或者同样的问题只回复一个同学！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538407314,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29398,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1538362921,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538362921","product_id":100017301,"comment_content":"关于死循环的例子，int 类型占 4 个字节，理论上来说 i 的地址不会跟在 3 个元素的 arr 后面，因为一般计算机内存是字节对齐的，会按 8 的整数倍来分配内存。<br><br>我在 Xcode 里面测试了下这段代码，越界直接奔溃了，i 的栈地址也比 arr 小，老师举这个例子可能只是为了说明数组随机访问的风险，至于什么风险是未知的，不同计算机上的表现也不一定一致，没必要死扣为什么第 4 个元素刚好是 i 的地址吧……","like_count":0},{"had_liked":false,"id":29389,"user_name":"李恒达","can_delete":false,"product_type":"c1","uid":1120147,"ip_address":"","ucode":"E9F1AC9E74CA16","user_header":"https://static001.geekbang.org/account/avatar/00/11/17/93/981dc959.jpg","comment_is_top":false,"comment_ctime":1538362055,"is_pvip":true,"replies":[{"id":"10626","content":"1. 不同的语言对数组访问越界的处理方式不同，即便是同一种语言，不同的编译器处理的方式也不同。至于你熟悉的语言是怎么处理的，请行百度。<br>2. C语言中，数组访问越界的处理是未决。并不一定是错，有同学做实验说没问题，那并不代表就是正确的。<br>3. 我觉得那个例子，栈是由高到低位增长的，所以，i和数组的数据从高位地址到低位地址依次是：i, a[2], a[1], a[0]。a[3]通过寻址公式，计算得到地址正好是i的存储地址，所以a[3]=0，就相当于i=0.<br>4. 大家有不懂的多看看留言，留言区还是有很多大牛的！我可能有时候回复的不及时，或者同样的问题只回复一个同学！","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538407334,"ip_address":"","comment_id":29389,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1538362055","product_id":100017301,"comment_content":"老师，你讲到“而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，”<br>这个是为什么？为什么正好是这个地址？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425575,"discussion_content":"1. 不同的语言对数组访问越界的处理方式不同，即便是同一种语言，不同的编译器处理的方式也不同。至于你熟悉的语言是怎么处理的，请行百度。\n2. C语言中，数组访问越界的处理是未决。并不一定是错，有同学做实验说没问题，那并不代表就是正确的。\n3. 我觉得那个例子，栈是由高到低位增长的，所以，i和数组的数据从高位地址到低位地址依次是：i, a[2], a[1], a[0]。a[3]通过寻址公式，计算得到地址正好是i的存储地址，所以a[3]=0，就相当于i=0.\n4. 大家有不懂的多看看留言，留言区还是有很多大牛的！我可能有时候回复的不及时，或者同样的问题只回复一个同学！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538407334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29387,"user_name":"程","can_delete":false,"product_type":"c1","uid":1006991,"ip_address":"","ucode":"66386B3603D39F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5d/8f/16e1da5d.jpg","comment_is_top":false,"comment_ctime":1538361889,"is_pvip":false,"replies":[{"id":"10627","content":"1. 不同的语言对数组访问越界的处理方式不同，即便是同一种语言，不同的编译器处理的方式也不同。至于你熟悉的语言是怎么处理的，请行百度。<br>2. C语言中，数组访问越界的处理是未决。并不一定是错，有同学做实验说没问题，那并不代表就是正确的。<br>3. 我觉得那个例子，栈是由高到低位增长的，所以，i和数组的数据从高位地址到低位地址依次是：i, a[2], a[1], a[0]。a[3]通过寻址公式，计算得到地址正好是i的存储地址，所以a[3]=0，就相当于i=0.<br>4. 大家有不懂的多看看留言，留言区还是有很多大牛的！我可能有时候回复的不及时，或者同样的问题只回复一个同学！","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538407367,"ip_address":"","comment_id":29387,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538361889","product_id":100017301,"comment_content":"无限打印helloworld那个在Ubuntu14.04里面实现过了，arr[i]和i的定义调过来也是，都是只打印4行。arr[i]的位置碰巧是i的位置的机率很小的吧","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425573,"discussion_content":"1. 不同的语言对数组访问越界的处理方式不同，即便是同一种语言，不同的编译器处理的方式也不同。至于你熟悉的语言是怎么处理的，请行百度。\n2. C语言中，数组访问越界的处理是未决。并不一定是错，有同学做实验说没问题，那并不代表就是正确的。\n3. 我觉得那个例子，栈是由高到低位增长的，所以，i和数组的数据从高位地址到低位地址依次是：i, a[2], a[1], a[0]。a[3]通过寻址公式，计算得到地址正好是i的存储地址，所以a[3]=0，就相当于i=0.\n4. 大家有不懂的多看看留言，留言区还是有很多大牛的！我可能有时候回复的不及时，或者同样的问题只回复一个同学！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538407367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29383,"user_name":"优雅一点","can_delete":false,"product_type":"c1","uid":1126534,"ip_address":"","ucode":"DA9608594E7602","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/86/c4e4d753.jpg","comment_is_top":false,"comment_ctime":1538361736,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538361736","product_id":100017301,"comment_content":"定义，就相当于给了我们一个标准。标记回收算法则相当于在规则之内更有效率的使用数据结构。","like_count":0},{"had_liked":false,"id":29381,"user_name":"简单","can_delete":false,"product_type":"c1","uid":1249521,"ip_address":"","ucode":"D0E8463C847BE4","user_header":"https://static001.geekbang.org/account/avatar/00/13/10/f1/ba7a4d86.jpg","comment_is_top":false,"comment_ctime":1538361369,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538361369","product_id":100017301,"comment_content":"1.数组越界的问题<br>i的内存有可能和数组的内存是连续的（测试时没有复现）<br>那么此时的地址有可能 ox ---- --FF   &#47;1515           array[0] <br>                                   ox ---- --FC  &#47;1512            array[1]<br>                                                        &#47;1509           array[2]<br>                                                          1506           i<br>array[3]越界时，访问到紧接着的i了，并且把i = 0；所以就死循环了<br><br>2.2维数组的问题<br>因为内存是一维的，所以问题转化为怎么求偏移量<br>这里就需要考虑行优先还是列优先的问题  ，如果是行优先的话<br>int a[3][3] = {0};<br>a[1][1]   offset = baseaddr + （1 * 列数 + 1） * sizeof(int);<br>因此&amp;a[i][j] = &amp;a + sizeof(type)*(列数+j);<br><br>因为不会看汇编，不太清楚是先算出行地址,比如a[1]的地址，在去加j，还是直接通过<br>首地址a[0][0]来计算偏移量。<br><br>","like_count":0},{"had_liked":false,"id":29380,"user_name":"于前鹏","can_delete":false,"product_type":"c1","uid":1237810,"ip_address":"","ucode":"E07CE46F246FAC","user_header":"https://static001.geekbang.org/account/avatar/00/12/e3/32/087ceaa2.jpg","comment_is_top":false,"comment_ctime":1538361350,"is_pvip":false,"replies":[{"id":"10628","content":"适合啊 有什么疑问吗","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538407440,"ip_address":"","comment_id":29380,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538361350","product_id":100017301,"comment_content":"老师，你讲的这个适合python语言么？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425570,"discussion_content":"适合啊 有什么疑问吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538407440,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29377,"user_name":"易水寒","can_delete":false,"product_type":"c1","uid":1238961,"ip_address":"","ucode":"F5D8127ED4754E","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/b1/5c63be67.jpg","comment_is_top":false,"comment_ctime":1538361138,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538361138","product_id":100017301,"comment_content":"标记清楚算法:通过可达性分析算法将不可达对象标记出来，然后进行清楚，这种方式会产生内存碎片，常用于老年代垃圾回收。但一般都是用标记整理算法，就是在标记清楚的基础上来一次内存整理。像CMS这种提供可配置方式，可以每次回收后都进行整理，也可以在执行多次回收后来一次整理","like_count":0},{"had_liked":false,"id":29350,"user_name":"Riordon","can_delete":false,"product_type":"c1","uid":1127497,"ip_address":"","ucode":"E2F6855B5FE5F9","user_header":"https://static001.geekbang.org/account/avatar/00/11/34/49/6b27feb1.jpg","comment_is_top":false,"comment_ctime":1538356914,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538356914","product_id":100017301,"comment_content":"标记-清除：标记阶段O(logn)和清除阶段O(1),清除后产生大量不连续内存碎片，下次有大对象过来还得触发gc。标记-整理：整理阶段把活对象移向一端，清除边界外空间。","like_count":0},{"had_liked":false,"id":29335,"user_name":"蔷薇骑士","can_delete":false,"product_type":"c1","uid":1246743,"ip_address":"","ucode":"09F0F8AF71C75C","user_header":"https://static001.geekbang.org/account/avatar/00/13/06/17/9e6ec02e.jpg","comment_is_top":false,"comment_ctime":1538355286,"is_pvip":false,"replies":[{"id":"10631","content":"对！","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538407562,"ip_address":"","comment_id":29335,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538355286","product_id":100017301,"comment_content":"a[i][j]=baseAddr+i*len*typeSize+j*typeSize，len为第二维的长度，对否？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425555,"discussion_content":"对！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538407562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29322,"user_name":"刘岚乔月","can_delete":false,"product_type":"c1","uid":1095289,"ip_address":"","ucode":"99A9AB4E4E1111","user_header":"https://static001.geekbang.org/account/avatar/00/10/b6/79/22e582a5.jpg","comment_is_top":false,"comment_ctime":1538353038,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538353038","product_id":100017301,"comment_content":"标记清理gc会有空间碎片的问题 在fullgc的时候会导致卡顿时间过长 不知道java11中的新gc策略怎么样 <br>其实可以根据具体的业务场景来选择适合的gc策略","like_count":0},{"had_liked":false,"id":29320,"user_name":"橙子ちゃん","can_delete":false,"product_type":"c1","uid":1249573,"ip_address":"","ucode":"E93D188F53DE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/11/25/1bf50430.jpg","comment_is_top":false,"comment_ctime":1538352657,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538352657","product_id":100017301,"comment_content":"老师你好，我是一名JS开发者。JS中的array和其他语言的不太相同，array既没有固定长度，也没有固定type。js作为当前最流行的语言之一，希望老师可以稍微提一下，要不然js的初学者会很疑惑🤔比如我🤣🤣","like_count":0},{"had_liked":false,"id":29319,"user_name":"刘岚乔月","can_delete":false,"product_type":"c1","uid":1095289,"ip_address":"","ucode":"99A9AB4E4E1111","user_header":"https://static001.geekbang.org/account/avatar/00/10/b6/79/22e582a5.jpg","comment_is_top":false,"comment_ctime":1538352555,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538352555","product_id":100017301,"comment_content":"标记回收gc会产生空间碎片 需要整理<br>","like_count":0},{"had_liked":false,"id":29298,"user_name":"Ace","can_delete":false,"product_type":"c1","uid":1115371,"ip_address":"","ucode":"7AC48C860DAB1B","user_header":"https://static001.geekbang.org/account/avatar/00/11/04/eb/5abae178.jpg","comment_is_top":false,"comment_ctime":1538331125,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538331125","product_id":100017301,"comment_content":"感觉讲解非常清楚，学到了。🙏","like_count":0}]}