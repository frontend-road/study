{"id":511795,"title":"实战二｜MQTT开发：如何实现联网控制？","content":"<p>你好，我是郭朝斌。</p><p>在上一节中，我们基于平头哥RVB2601开发板完成了智能电灯硬件的搭建和嵌入式应用的开发，但是打造一款物联网设备，我们还需要将硬件接入物联网平台。接下来，我就来讲解一下RVB2601开发板通过MQTT协议接入阿里云生活物联网平台的流程及方法。</p><p>在开始本节内容的阅读之前，你可以重新打开<a href=\"https://time.geekbang.org/column/article/322528\">第17讲</a>，了解一下Python语言的实现代码。对比着本节的C语言代码，你将会对程序开发有更深入的理解。</p><h2>生活物联网平台的准备工作</h2><p>阿里云生活物联网平台，又称为飞燕平台，是面向消费级产品的物联网开放平台。它具备完整的、面向家居物联网场景的功能定义，可以非常方便地完成智能设备的物联网接入工作。</p><p>接下来，我们就在这个平台上完成智能灯的联网控制实验。</p><h3>创建项目和产品</h3><p>首先，登录<a href=\"https://living.aliyun.com\">生活物联网平台</a>，我们进行第一个项目的创建。项目的名称，我们可以填写“智能电灯”。对于项目类型，你可以根据产品需求来决定，因为我们不计划接入天猫精灵生态，所以这里选择“自有品牌项目”。</p><p><img src=\"https://static001.geekbang.org/resource/image/e8/1c/e8c304c43ed2yyd0ac86c8b1ca50ff1c.png?wh=1014x754\" alt=\"\"></p><p>接着，我们为这个“智能电灯”项目创建一个新产品“Led_1”。</p><p><img src=\"https://static001.geekbang.org/resource/image/15/be/15fac49fc02321208fc2c7e7f08d13be.png?wh=1858x554\" alt=\"\"></p><p>产品的参数可以这样设置：</p><ul>\n<li>所属品类，选择“电工照明”–&gt;“灯”。</li>\n<li>节点设备，选择“设备”。是否接入网关，选择“否”。</li>\n<li>连网方式，选择“WiFi”。</li>\n<li>数据格式，选择“ICA标准数据格式（Alink JSON）”。</li>\n</ul><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/3b/72/3b07a69c927e1044ac15c4fd9fb02c72.png?wh=1220x1062\" alt=\"\"><br>\n<img src=\"https://static001.geekbang.org/resource/image/25/4b/25275157ebd091863bb2f6f79063a04b.png?wh=1220x892\" alt=\"\"></p><h3>产品功能定义</h3><p>创建完产品，我们进入产品的研发流程。物联网平台把流程分为4个阶段，分别是：功能定义、人机交互、设备调试和批量投产。</p><p>首先，我们来完成功能定义的部分，也就是物联网设备的物模型定义。</p><p>基于创建产品时我们选择的产品类型和数据格式，平台已经为智能电灯自动生成了一个标准的物模型。针对你开发的智能灯的功能需求，你可以对各项功能进行编辑、删除，或者新增标准模版没有的功能。比如像我这里展示的一样，保留“开关”、“亮度”和“色温”，删除其他功能项，同时增加“RGB调色”功能。“RGB调色”功能项，对应了我们智能灯的三色LED模块。</p><p><img src=\"https://static001.geekbang.org/resource/image/9c/87/9cc88d1efafd17b3df580c9beb9b9e87.png?wh=1752x968\" alt=\"\"></p><h3>人机交互设计</h3><p>完成功能定义后，我们进入下一步，人机交互。在人机交互中，我们主要完成配网方式和手机App相关界面的设计。</p><p>首先，我们选择使用公版App控制产品。这样可以省掉我们开发独立App的工作。</p><p><img src=\"https://static001.geekbang.org/resource/image/84/d1/840a382b8cd04459fc6d7b1e5ab57bd1.png?wh=2462x454\" alt=\"\"></p><p>在“产品展示”标签页中，设置一下产品名称。</p><p><img src=\"https://static001.geekbang.org/resource/image/f2/25/f277da06b5c5d5e7c4210f22cfe50725.png?wh=2458x896\" alt=\"\"></p><p>在“设备面板”中，你可以点击进入“选择面板”页面，选择一个智能灯在App上的展示和操作界面。因为默认面板中没有适配“RGB调色”的面板，所以，你需要编辑一下“灯泡冷暖灯”模版来替代使用。否则，平台会显示错误信息，提示面板与物模型的属性定义不一致。</p><p><img src=\"https://static001.geekbang.org/resource/image/27/67/274cd8dd412dd288b03d78568e221467.png?wh=1820x1284\" alt=\"\"></p><p>配网方式，我们保持默认设置即可。在“自动化与定时”标签页中，我们要勾选“开关”的“作为执行”选项。这样，在自动化场景的创建中，智能电灯的开关就可以作为执行动作起到控制的效果了。</p><h3>设备调试设置</h3><p>在设备调试页面中，我们需要先选择产品使用的芯片或者模组。对于我们的实验项目，这里直接选择列表最后一项——未知芯片即可。</p><p>然后，我们新建一个测试设备。因为我们需要获得一个设备证书，也就是智能灯连接物联网平台的五元组信息。</p><p>点击“新建测试设备”，你需要为测试设备输入一个名称，比如，可以是“RVB2601HoloLed1”。然后，点击“确定”，页面就会新增一个设备条目。</p><p><img src=\"https://static001.geekbang.org/resource/image/65/64/652c6d5cd03a189fe9f81ab7d9aa6164.png?wh=1172x630\" alt=\"\"></p><p>在新增设备条目中，点击“设备证书”，你就可以看到设备五元组信息。这里要记得复制、保存这些字符串，因为我们在后面的应用代码中需要用到。</p><p><img src=\"https://static001.geekbang.org/resource/image/f3/27/f31999ae09b207dbfedc5244ceb7c027.png?wh=1176x756\" alt=\"\"></p><p>你可以看到，这个新增测试设备的状态显示“未激活”。因为只有当设备通过MQTT协议第一次连接到物联网平台后，这个测试设备才会被激活，并且可以发送消息进行在线调试。</p><h2>智能灯如何接入物联网</h2><p>那么，智能灯如何接入物联网平台实现后续的调试、使用呢？下面，我们来开发一下智能灯的联网控制功能。</p><h3>联网功能开发</h3><p>RVB2601开发板中的W800模组提供了Wi-Fi和BLE通信能力，而且模组还集成了连接阿里云生活物联网平台（飞燕）的功能。主控芯片CH2601通过SPI接口与W800模组通信，它只需要发送/接收W800定义的AT指令，就可以实现相应的功能。</p><p>W800模组的AT指令集可以参考<a href=\"https://occ-oss-prod.oss-cn-hangzhou.aliyuncs.com/userFiles/3717897501090217984/resource/3717897501090217984XBSRZBtccb.pdf\">官方文档</a>。我们就基于文档中飞燕平台的相关AT指令来实现与平台的通信。它的底层实现依然是MQTT协议，不过封装成了AT指令的接口形式。</p><p>这里，我们就需要修改W800的驱动代码，增加联网接口函数，其中具体包括：</p><ul>\n<li>设置设备五元组接口</li>\n<li>建立MQTT连接接口</li>\n<li>物模型属性设置回调注册接口</li>\n<li>物模型属性上报接口</li>\n</ul><p>具体要怎么做呢？</p><p>我们需要在项目中引入W800的驱动模块drv_wifi_at_w800。在CDK中，点击右键打开“Packages for Led”，在模块窗口左侧找到drv_wifi_at_w800模块，点击箭头导入右侧列表中。</p><p><img src=\"https://static001.geekbang.org/resource/image/6f/2f/6fd57acd5c77daa65d1484fde6a3652f.png?wh=620x458\" alt=\"\"><br>\n<img src=\"https://static001.geekbang.org/resource/image/ca/6f/ca8410036690753cd7fa27ceaa87c76f.png?wh=1247x846\" alt=\"\"></p><p>在W800的驱动模块drv_wifi_at_w800中，打开w800_api.h文件，增加函数接口定义。</p><pre><code class=\"language-c++\">int w800_living_idmau(const char *mykey,const char *myname,const char *mysecret,const char *mypsecret);\nint w800_living_idmcon(void);\nvoid w800_living_recv_callback_register(const char *cmd, void *callback, void *context);\nint w800_living_send_attribute(const char *dev_id, const char *msg);\n</code></pre><p>在w800_api.c文件中，增加函数接口的实现代码。</p><pre><code class=\"language-c++\">int w800_living_idmau(const char *mykey,const char *myname,const char *mysecret,const char *mypsecret)\n{\n\tint ret = -1;\n\t\n\taos_mutex_lock(&amp;g_cmd_mutex,AOS_WAIT_FOREVER);\n\t\n\tatparser_clr_buf(g_atparser_uservice_t);\n\t\n\tif (atparser_send(g_atparser_uservice_t,\n\t\t\"AT+IDMAU=\\\"%s\\\",\\\"%s\\\",\\\"%s\\\",\\\"%s\\\"\", mykey, myname, mysecret, mypsecret) == 0) {\n\t\tif (atparser_recv(g_atparser_uservice_t, \"OK\\n\") == 0) {\n\t\t\tret = 0;\n\t\t}\n\t\telse {\n\t\t\tprintf(\"Destination Host Unreachable!\\r\\n\");\n\t\t}\n\t}\n\t\n\tatparser_cmd_exit(g_atparser_uservice_t);\n\t\n\tif (ret == 0) {\n\t\tprintf(\"key = %s name = %s secret = %s psecret = %s!\\r\\n\", mykey, myname, mysecret, mypsecret);\n\t}\n\t\n\taos_mutex_unlock(&amp;g_cmd_mutex);\n\treturn ret;\n}\n\nint w800_living_idmcon(void)\n{\n\tint ret = -1;\n\t\n\taos_mutex_lock(&amp;g_cmd_mutex,AOS_WAIT_FOREVER);\n\t\n\tatparser_clr_buf(g_atparser_uservice_t);\n\t\n\tif (atparser_send(g_atparser_uservice_t, \"AT+IDMCON\") == 0) {\n\t\tif (atparser_recv(g_atparser_uservice_t, \"OK\\n\") == 0) {\n\t\t\tret = 0;\n\t\t} else {\n\t\t\tprintf(\"Destination Host Unreachable!\\r\\n\");\n\t\t}\n\t}\n\t\n\tatparser_cmd_exit(g_atparser_uservice_t);\n\t\n\tif (ret == 0) {\n\t\tprintf(\"AT+IDMCON \\r\\n\");\n\t}\n\t\n\taos_mutex_unlock(&amp;g_cmd_mutex);\n\treturn ret;\n}\n\nvoid w800_living_recv_callback_register(const char *cmd, void *callback, void *context)\n{\n&nbsp; &nbsp; atparser_oob_create(g_atparser_uservice_t, cmd, callback, context);\n}\n\nint w800_living_send_attribute(const char *dev_id, const char *msg)\n{\n&nbsp; &nbsp; int ret = -1;\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; if (!dev_id || !msg) {\n&nbsp; &nbsp; &nbsp; &nbsp; return ret;\n&nbsp; &nbsp; }\n\t\n&nbsp; &nbsp; aos_mutex_lock(&amp;g_cmd_mutex, AOS_WAIT_FOREVER);\n\t\n&nbsp; &nbsp; atparser_clr_buf(g_atparser_uservice_t);\n\t\n&nbsp; &nbsp; printf(\"Send msg: %s\\r\\n\", msg);\n&nbsp; &nbsp; if (atparser_send(g_atparser_uservice_t, \"AT+IDMPP=0,\\\"%s\\\"\", msg) == 0) {\n&nbsp; &nbsp; &nbsp; &nbsp; if (atparser_recv(g_atparser_uservice_t, \"OK\\n\") == 0) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = 0;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(\"Send at cmd ok\\n\");\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; } else {\n&nbsp; &nbsp; &nbsp; &nbsp; printf(\"Send at cmd err\\n\");\n&nbsp; &nbsp; }\n\t\n&nbsp; &nbsp; atparser_cmd_exit(g_atparser_uservice_t);\n\t\n&nbsp; &nbsp; aos_mutex_unlock(&amp;g_cmd_mutex);\n\n&nbsp; &nbsp; return ret;\n}\n</code></pre><p>这里，物模型属性设置回调注册接口的实现采用了非侵入的方式，以尽量减少对原代码的修改。所以，这就需要接口调用者，在应用代码中明确地指定AT指令的代码。通常来说，更好的实现方式是通过消息机制来实现，但是这需要定义唯一的、不冲突的消息编号，并且在w800_module_init函数体中增加回调注册代码，侵入性太大，所以并没有选择这样的实现方式。</p><h3>智能灯平台交互的封装</h3><p>对于智能灯与平台之间的交互逻辑，我们可以新建代码来封装实现。在C语言中，为方便接口函数的调用，我们需要先新建一个头文件—— app_living.h 。</p><pre><code class=\"language-c++\">#ifndef __APP_LIVING_H__\n#define __APP_LIVING_H__\n\n#include &lt;uservice/eventid.h&gt;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define EVENT_LIVING_ATTR_POWER&nbsp; &nbsp; &nbsp; &nbsp;(EVENT_USER + 1)\n#define EVENT_LIVING_ATTR_BRIGHTNESS&nbsp; (EVENT_USER + 2)\n#define EVENT_LIVING_ATTR_COLOR&nbsp; &nbsp; &nbsp; &nbsp;(EVENT_USER + 3)\n\ntypedef struct RgbColor\n{\n&nbsp; &nbsp; unsigned char r;\n&nbsp; &nbsp; unsigned char g;\n&nbsp; &nbsp; unsigned char b;\n} RgbColor;\n\nvoid update_attr(uint8_t powerstate, uint8_t bright, RgbColor rgb);\n\nint connect_iot_demo(void);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __APP_LIVING_H__ */\n</code></pre><p>然后，新建app_living.c源文件来实现代码逻辑。为了解析从平台发送的JSON格式消息，我们引入了cJSON模块。</p><pre><code class=\"language-c++\">#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;aos/debug.h&gt;\n#include &lt;devices/w800.h&gt;\n#include &lt;yoc/atparser.h&gt;\n#include \"cJSON.h\"\n#include \"app_living.h\"\n\n#define TAG \"app_living\"\n\nextern int w800_living_idmau(const char *mykey,const char *myname,const char *mysecret,const char *mypsecretconst);\nextern int w800_living_idmcon(void);\nextern void w800_living_recv_callback_register(const char *cmd, void *callback, void *context);\nextern int w800_living_send_attribute(const char *dev_id, const char *msg);\n\nvoid update_attr(uint8_t powerstate, uint8_t bright, RgbColor rgb)\n{\n\tprintf(\"enter update \\n\");\n\tconst char *dev_id = \"0\";\n\tchar msg[128] = {0};\n\tconst char *msg_format = \"{\\\\\\\"powerstate\\\\\\\":%d,\\\\\\\"brightness\\\\\\\":%d,\\\\\\\"RGBColor\\\\\\\":{\\\\\\\"Red\\\\\\\":%d,\\\\\\\"Green\\\\\\\":%d,\\\\\\\"Blue\\\\\\\":%d}}\";\n\t\n\tsprintf(msg, msg_format, powerstate, bright, rgb.r,rgb.g,rgb.b);\n\t\n\tw800_living_send_attribute(dev_id, msg);\n}\n\nstatic int parse_living_msg(const char *msg)\n{\n&nbsp; &nbsp; cJSON *root = NULL;\n\n&nbsp; &nbsp; /* Parse Root */\n&nbsp; &nbsp; root = cJSON_Parse(msg);\n&nbsp; &nbsp; if (root == NULL || !cJSON_IsObject(root)) {\n&nbsp; &nbsp; &nbsp; &nbsp; printf(\"JSON Parse Error\\n\");\n&nbsp; &nbsp; &nbsp; &nbsp; return -1;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; cJSON *item = cJSON_GetObjectItem(root, \"powerstate\");\n\tstatic uint8_t power_on;\n&nbsp; &nbsp; if (item &amp;&amp; cJSON_IsNumber(item)) {\n&nbsp; &nbsp; &nbsp; &nbsp; if (item-&gt;valueint) {\n\t\t\tpower_on = 1;\n&nbsp; &nbsp; &nbsp; &nbsp; } else {\n\t\t\tpower_on = 0;\n&nbsp; &nbsp; &nbsp; &nbsp; }\n\t\tevent_publish(EVENT_LIVING_ATTR_POWER, &amp;power_on);\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; item = cJSON_GetObjectItem(root, \"brightness\");\n\tstatic uint8_t bright;\n&nbsp; &nbsp; if (item &amp;&amp; cJSON_IsNumber(item)) {\n\t\tbright = item-&gt;valueint;\n\t\tevent_publish(EVENT_LIVING_ATTR_BRIGHTNESS, &amp;bright);\n&nbsp; &nbsp; }\n\t\n\titem = cJSON_GetObjectItem(root, \"RGBColor\");\n\tstatic RgbColor rgb;\n\tif (item &amp;&amp; cJSON_IsObject(item)) {\n\t\tcJSON *sub_item = cJSON_GetObjectItem(item, \"Red\");\n\t\tif (sub_item &amp;&amp; cJSON_IsNumber(sub_item)) {\n\t\t\trgb.r = sub_item-&gt;valueint;\n\t\t}\n\t\tsub_item = cJSON_GetObjectItem(item, \"Green\");\n\t\tif (sub_item &amp;&amp; cJSON_IsNumber(sub_item)) {\n\t\t\trgb.g = sub_item-&gt;valueint;\n\t\t}\n\t\tsub_item = cJSON_GetObjectItem(item, \"Blue\");\n\t\tif (sub_item &amp;&amp; cJSON_IsNumber(sub_item)) {\n\t\t\trgb.b = sub_item-&gt;valueint;\n\t\t}\n\t\tevent_publish(EVENT_LIVING_ATTR_COLOR, &amp;rgb);\n\t}\n\n&nbsp; &nbsp; cJSON_Delete(root);\n\n&nbsp; &nbsp; return 0;\n}\n\nstatic int living_set_attr_callback(atparser_uservice_t *at, void *priv, oob_data_t *oob_data)\n{\n\tint did = 0;\n\tint len = 0;\n\tchar msg[128] = {0};\n\tchar *str = strchr(oob_data-&gt;buf, ':');\n\tif (str != NULL) {\n\t\tsscanf(oob_data-&gt;buf, \"%d,%d,%s\\r\\n\", &amp;did, &amp;len, msg);\n\t\tLOGD(TAG,\"==&gt;recv data %d(%d):%s\\r\\n\",did, len, msg);\n\t\tparse_living_msg(msg);\n\t\toob_data-&gt;used_len = len;\n\t}\n\n&nbsp; &nbsp; return 0;\n}\n\nint connect_iot_demo(void)\n{\n\tchar *my_key = \"a1AMULi68xV\";//ProductKey\n\tchar *my_name = \"RVB2601GeekHoloLed1\";//DeviceName\n\tchar *my_secret = \"fcdf55e206b907d649e2249aed8c948a\";//DeviceSecret\n\tchar *my_p_secret = \"BReZtzPVrLcdY1H4\";//Product Secret\n\n\tint ret2 = -1;\n\tint ret3 = -1;\n\n\tw800_living_recv_callback_register(\"+IDMPS:\", living_set_attr_callback, NULL);\n\n\tret2 = w800_living_idmau(my_key,my_name,my_secret,my_p_secret);\n\t\n\tif (ret2 == 0){\n\t\tprintf(\"AT+IDMAU:OK!\\n\");\n\t} else {\n\t\tprintf(\"AT+IDMAU:ERROR!\\n\");\n\t}\n\t\n\tret3 = w800_living_idmcon();\n\tif (ret3 == 0){\n\t\tprintf(\"AT+IDMCON:OK!\\n\");\n\t} else {\n\t\tprintf(\"AT+IDMCON:ERROR!\\n\");\n\t}\n\t\n\tif(ret2 == 0 &amp;&amp; ret3 == 0){\n\t\treturn 0;\n\t}else{\n\t\treturn -1;\n\t}\n}\n</code></pre><blockquote>\n<p>注意替换上面代码中connect_iot_demo函数使用的设备五元组信息。</p>\n</blockquote><h3>LED颜色控制实现</h3><p>为了控制亮度，我们也需要对上一节中的LED控制代码进行改造，具体代码如下。</p><pre><code class=\"language-c++\">\n/*********************\n&nbsp;*&nbsp; &nbsp; &nbsp; INCLUDES\n&nbsp;*********************/\n#define _DEFAULT_SOURCE /* needed for usleep() */\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;time.h&gt;\n#include &lt;aos/aos.h&gt;\n#include \"app_config.h\"\n#include \"app_main.h\"\n#include \"csi_config.h\"\n\n#include \"board_config.h\"\n#include \"drv/gpio_pin.h\"\n#include &lt;drv/pin.h&gt;\n#include &lt;drv/pwm.h&gt;\n\n#ifdef CONFIG_PWM_MODE\n\nstatic csi_pwm_t&nbsp; r;\n\nvoid led_pinmux_init()\n{\n&nbsp; &nbsp; &nbsp; &nbsp; //7\n&nbsp; &nbsp; csi_error_t ret;\n&nbsp; &nbsp; csi_pin_set_mux(PA7, PA7_PWM_CH7);\n&nbsp; &nbsp; csi_pin_set_mux(PA25, PA25_PWM_CH2);\n&nbsp; &nbsp; csi_pin_set_mux(PA4, PA4_PWM_CH4);\n\n&nbsp; &nbsp; ret = csi_pwm_init(&amp;r, 0);\n&nbsp; &nbsp; if (ret != CSI_OK) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(\"===%s, %d\\n\", __FUNCTION__, __LINE__);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ;\n&nbsp; &nbsp; }\n}\n\nvoid rgb_light(uint32_t red, uint32_t green, uint32_t blue, uint8_t brightness)\n{\n\tcsi_error_t ret;\n\tret = csi_pwm_out_config(&amp;r, 7 / 2, 300, red*300*brightness/100/255, PWM_POLARITY_HIGH);\n&nbsp; &nbsp; if (ret != CSI_OK) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(\"===%s, %d\\n\", __FUNCTION__, __LINE__);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; ret = csi_pwm_out_start(&amp;r, 7 / 2);\n&nbsp; &nbsp; if (ret != CSI_OK) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(\"===%s, %d\\n\", __FUNCTION__, __LINE__);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; //25\n&nbsp; &nbsp; ret = csi_pwm_out_config(&amp;r, 2 / 2, 300, green*300*brightness/100/255, PWM_POLARITY_HIGH);\n&nbsp; &nbsp; if (ret != CSI_OK) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(\"===%s, %d\\n\", __FUNCTION__, __LINE__);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; ret = csi_pwm_out_start(&amp;r, 2 / 2);\n&nbsp; &nbsp; if (ret != CSI_OK) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(\"===%s, %d\\n\", __FUNCTION__, __LINE__);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; //4\n&nbsp; &nbsp; ret = csi_pwm_out_config(&amp;r, 4 / 2, 300, blue*300*brightness/100/255, PWM_POLARITY_HIGH);\n&nbsp; &nbsp; if (ret != CSI_OK) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(\"===%s, %d\\n\", __FUNCTION__, __LINE__);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; ret = csi_pwm_out_start(&amp;r, 4 / 2);\n&nbsp; &nbsp; if (ret != CSI_OK) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(\"===%s, %d\\n\", __FUNCTION__, __LINE__);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ;\n&nbsp; &nbsp; }\n}\n#endif&nbsp;\n\n#ifdef CONFIG_GPIO_MODE\nstatic uint32_t g_ctr = 0;\nstatic csi_gpio_pin_t r;\nstatic csi_gpio_pin_t g;\nstatic csi_gpio_pin_t b;\nvoid led_pinmux_init()\n{\n&nbsp; &nbsp; csi_pin_set_mux(PA7, PIN_FUNC_GPIO);\n&nbsp; &nbsp; csi_pin_set_mux(PA25, PIN_FUNC_GPIO);\n&nbsp; &nbsp; csi_pin_set_mux(PA4, PIN_FUNC_GPIO);\n&nbsp; &nbsp; csi_gpio_pin_init(&amp;r, PA7);\n&nbsp; &nbsp; csi_gpio_pin_dir(&amp;r, GPIO_DIRECTION_OUTPUT);\n\tcsi_gpio_pin_mode(&amp;r, GPIO_MODE_PUSH_PULL);\n&nbsp; &nbsp; csi_gpio_pin_init(&amp;g, PA25);\n&nbsp; &nbsp; csi_gpio_pin_dir(&amp;g, GPIO_DIRECTION_OUTPUT);\n\tcsi_gpio_pin_mode(&amp;g, GPIO_MODE_PUSH_PULL);\n&nbsp; &nbsp; csi_gpio_pin_init(&amp;b, PA4);\n&nbsp; &nbsp; csi_gpio_pin_dir(&amp;b, GPIO_DIRECTION_OUTPUT);\n\tcsi_gpio_pin_mode(&amp;b, GPIO_MODE_PUSH_PULL);\n&nbsp; &nbsp; g_ctr = 0;\n}\n\n//fake rgb, because of only high or low state of gpio\nvoid rgb_light(uint32_t red, uint32_t green, uint32_t blue)\n{\n\t(red &lt; 50)?csi_gpio_pin_write(&amp;r, GPIO_PIN_LOW):csi_gpio_pin_write(&amp;r, GPIO_PIN_HIGH);\n\t(green &lt; 50)?csi_gpio_pin_write(&amp;r, GPIO_PIN_LOW):csi_gpio_pin_write(&amp;g, GPIO_PIN_HIGH);\n\t(blue &lt; 50)?csi_gpio_pin_write(&amp;r, GPIO_PIN_LOW):csi_gpio_pin_write(&amp;b, GPIO_PIN_HIGH);\n}\n#endif\n\n</code></pre><h3>继电器状态获取实现</h3><p>为了获取继电器状态，也就是LED灯的开关状态，我们同样需要对继电器代码进行改造。具体代码如下。</p><pre><code class=\"language-c++\">/*********************\n&nbsp;*&nbsp; &nbsp; &nbsp; INCLUDES\n&nbsp;*********************/\n#define _DEFAULT_SOURCE /* needed for usleep() */\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;time.h&gt;\n#include &lt;aos/aos.h&gt;\n#include \"app_config.h\"\n#include \"csi_config.h\"\n#include \"app_main.h\"\n\n#include \"board_config.h\"\n#include \"drv/gpio_pin.h\"\n#include &lt;drv/pin.h&gt;\n\nstatic csi_gpio_pin_t relay;\n\nunsigned char get_state()\n{\n\treturn csi_gpio_pin_read(&amp;relay);\n}&nbsp;\n\nvoid relay_pinmux_init()&nbsp;\n{\n\tcsi_pin_set_mux(PA26, PIN_FUNC_GPIO);\n\tcsi_gpio_pin_init(&amp;relay, PA26);\n&nbsp; &nbsp; csi_gpio_pin_dir(&amp;relay, GPIO_DIRECTION_OUTPUT);\n}\n\nvoid relay_toggle(bool on)\n{\n\tif(on)\n\t{\n\t\tcsi_gpio_pin_write(&amp;relay, GPIO_PIN_HIGH);\n\t}&nbsp;\n\telse&nbsp;\n\t{\n\t\tcsi_gpio_pin_write(&amp;relay, GPIO_PIN_LOW);\n\t}\n}\n\n</code></pre><h3>网络初始化实现</h3><p>在编写应用的主逻辑之前，我们需要先对RVB2601开发板进行初始化。其中，网络初始化是我们为实现联网新增的代码逻辑。</p><p>网络初始化分为两步。第一步是初始化W800模块：在设置好GPIO口、波特率和缓冲大小后，通过调用wifi_w800_register函数初始化；第二步是配置网络管理器（netmgr）模块：这里你需要将netmgr_config_wifi函数中的入参替换成自己的Wi-Fi网络SSID和密码，并且注意修改入参中的数字为SSID字符串和密码字符串的长度。</p><pre><code class=\"language-c++\">#include &lt;stdbool.h&gt;\n#include &lt;aos/kv.h&gt;\n#include &lt;yoc/partition.h&gt;\n#include &lt;yoc/init.h&gt;\n#include &lt;drv/pin.h&gt;\n#include &lt;yoc/at_port.h&gt;\n#include &lt;devices/w800.h&gt;\n#include &lt;devices/drv_snd_alkaid.h&gt;\n\n#include \"app_main.h\"\n#include \"board.h\"\n\n#define TAG \"init\"\n\nnetmgr_hdl_t app_netmgr_hdl;\nextern at_channel_t spi_channel;\n\nstatic void network_init()\n{\n&nbsp; &nbsp; w800_wifi_param_t w800_param;\n&nbsp; &nbsp; /* init wifi driver and network */\n&nbsp; &nbsp; w800_param.reset_pin&nbsp; &nbsp; &nbsp; = PA21;\n&nbsp; &nbsp; w800_param.baud&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1*1000000;\n&nbsp; &nbsp; w800_param.cs_pin&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= PA15;\n&nbsp; &nbsp; w800_param.wakeup_pin&nbsp; &nbsp; &nbsp;= PA25;\n&nbsp; &nbsp; w800_param.int_pin&nbsp; &nbsp; &nbsp; &nbsp; = PA22;\n&nbsp; &nbsp; w800_param.channel_id&nbsp; &nbsp; &nbsp;= 0;\n&nbsp; &nbsp; w800_param.buffer_size&nbsp; &nbsp; = 4*1024;\n\n&nbsp; &nbsp; wifi_w800_register(NULL, &amp;w800_param);\n&nbsp; &nbsp; app_netmgr_hdl = netmgr_dev_wifi_init();\n\n&nbsp; &nbsp; if (app_netmgr_hdl) {\n&nbsp; &nbsp; &nbsp; &nbsp; utask_t *task = utask_new(\"netmgr\", 2 * 1024, QUEUE_MSG_COUNT, AOS_DEFAULT_APP_PRI);\n&nbsp; &nbsp; &nbsp; &nbsp; netmgr_service_init(task);\n&nbsp; &nbsp; &nbsp; &nbsp; netmgr_config_wifi(app_netmgr_hdl, \"你的wifi SSID\", 11, \"你的wifi AP密码\", 11);\n&nbsp; &nbsp; &nbsp; &nbsp; netmgr_start(app_netmgr_hdl);\n&nbsp; &nbsp; }\n}\n\nvoid board_yoc_init(void)\n{\n&nbsp; &nbsp; board_init();\n&nbsp; &nbsp; event_service_init(NULL);\n&nbsp; &nbsp; console_init(CONSOLE_UART_IDX, 115200, 512);\n&nbsp; &nbsp; ulog_init();\n&nbsp; &nbsp; aos_set_log_level(AOS_LL_DEBUG);\n\n&nbsp; &nbsp; int ret = partition_init();\n&nbsp; &nbsp; if (ret &lt;= 0) {\n&nbsp; &nbsp; &nbsp; &nbsp; LOGE(TAG, \"partition init failed\");\n&nbsp; &nbsp; } else {\n&nbsp; &nbsp; &nbsp; &nbsp; LOGI(TAG, \"find %d partitions\", ret);\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; aos_kv_init(\"kv\");\n\n&nbsp; &nbsp; network_init();\n\n&nbsp; &nbsp; board_cli_init();\n}\n\n</code></pre><h3>智能灯主逻辑实现</h3><p>在完成了W800驱动程序的增补、平台交互功能的封装以及LED模块、继电器代码的改造等一系列准备之后，我们就可以编写智能灯的主逻辑了。智能灯的主逻辑在app_main.c文件中实现。</p><p>主逻辑包含几个模块：首先是初始化开发板、LED灯和继电器模块；然后是注册网络管理器事件的回调函数，和注册我们在平台交互模块中定义的属性设置事件的回调函数；最后，就是在while循环中建立物联网平台连接，并定期上报智能灯状态。</p><p>我们看一下具体的代码：</p><pre><code class=\"language-c++\">#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;aos/list.h&gt;\n#include &lt;aos/debug.h&gt;\n#include &lt;uservice/uservice.h&gt;\n#include &lt;uservice/eventid.h&gt;\n#include &lt;yoc/sysinfo.h&gt;\n#include &lt;board.h&gt;\n#include \"drv/gpio_pin.h\"\n#include &lt;drv/pin.h&gt;\n#include &lt;drv/pwm.h&gt;\n#include \"app_living.h\"\n#include \"app_main.h\"\n\n#define TAG \"APP\"\n\nstatic bool g_wifi_ok;\nstatic uint8_t led_brightness;\nstatic RgbColor led_color;\n\nstatic void led_control(uint8_t power) {\n\trelay_toggle(power);\n}\n\nstatic void led_set_brightness(uint8_t bright) {\n\tled_brightness = bright;\n\trgb_light(led_color.r, led_color.g, led_color.b, bright);\n}\n\nstatic void led_set_color(RgbColor color) {\n\tled_color.r = color.r;\n\tled_color.g = color.g;\n\tled_color.b = color.b;\n\trgb_light(color.r, color.g, color.b, led_brightness);\n}\n\nstatic void living_event(uint32_t event_id, const void *param, void *context)\n{\n\tswitch(event_id) {\n&nbsp; &nbsp; case EVENT_LIVING_ATTR_POWER:\n&nbsp; &nbsp; &nbsp; &nbsp; printf(\"set attr power:%d\\n\", *(uint8_t *)param);\n\t\tled_control(*(uint8_t *)param);\n&nbsp; &nbsp; &nbsp; &nbsp; break;\n&nbsp; &nbsp; case EVENT_LIVING_ATTR_BRIGHTNESS:\n&nbsp; &nbsp; &nbsp; &nbsp; printf(\"set attr bright:%d\\n\", *(uint8_t *)param);\n\t\tled_set_brightness(*(uint8_t *)param);\n&nbsp; &nbsp; &nbsp; &nbsp; break;\n\tcase EVENT_LIVING_ATTR_COLOR:\n\t\tprintf(\"set attr color\\n\");\n\t\tled_set_color(*(RgbColor *)param);\n\t\tbreak;\n&nbsp; &nbsp;}\n&nbsp; &nbsp; /*do exception process */\n&nbsp; &nbsp; app_exception_event(event_id);\n}\n\nstatic void network_event(uint32_t event_id, const void *param, void *context)\n{\n&nbsp; &nbsp; switch(event_id) {\n&nbsp; &nbsp; case EVENT_NETMGR_GOT_IP:\n&nbsp; &nbsp; &nbsp; &nbsp; LOGD(TAG, \"net got ip\");\n\t\tg_wifi_ok = true;\n&nbsp; &nbsp; &nbsp; &nbsp; break;\n&nbsp; &nbsp; case EVENT_NETMGR_NET_DISCON:\n&nbsp; &nbsp; &nbsp; &nbsp; LOGD(TAG, \"net disconnect\");\n&nbsp; &nbsp; &nbsp; &nbsp; break;\n&nbsp; &nbsp;}\n&nbsp; &nbsp; /*do exception process */\n&nbsp; &nbsp; app_exception_event(event_id);\n}\n\nint main(void)\n{\n\tuint32_t time_cnt = 0;\n\tbool mqtt_conn = false;\n&nbsp; &nbsp; board_yoc_init();\n\t\n\tled_pinmux_init();\n\trelay_pinmux_init();\n\t\n\tled_color.r = 255;\n\tled_color.g = 255;\n\tled_color.b = 0;\n\tled_brightness = 100;\n\trgb_light(led_color.r, led_color.g, led_color.b, led_brightness);\n\trelay_toggle(true);\n\n&nbsp; &nbsp; /* Subscribe */\n&nbsp; &nbsp; event_subscribe(EVENT_NETMGR_GOT_IP, network_event, NULL);\n&nbsp; &nbsp; event_subscribe(EVENT_NETMGR_NET_DISCON, network_event, NULL);\n\tevent_subscribe(EVENT_LIVING_ATTR_POWER, living_event, NULL);\n\tevent_subscribe(EVENT_LIVING_ATTR_BRIGHTNESS, living_event, NULL);\n\tevent_subscribe(EVENT_LIVING_ATTR_COLOR, living_event, NULL);\n\t\n\twhile(1){\n\t\tif (g_wifi_ok) {\n\t\t\tint ret = connect_iot_demo();\n\t\t\tif (ret == 0){\n\t\t\t\tprintf(\"connerct iot success\");\n\t\t\t\tmqtt_conn = true;\n\t\t\t}else{\n\t\t\t\tprintf(\"connerct iot error\");\n\t\t\t}\n\t\t\tg_wifi_ok = false;\n\t\t}\n\t\t\n\t\tif (mqtt_conn &amp;&amp; time_cnt &gt;= 10) {\n\t\t\tupdate_attr(get_state(), led_brightness, led_color);\n\t\t\ttime_cnt = 0;\n\t\t}\n\t\t\n\t\ttime_cnt += 1;\n\t\taos_msleep(500);\n\t}\n&nbsp;\n}\n\n</code></pre><p>最后，主逻辑app_main.c的头文件内容如下，供你参考。其中包含了硬件初始化接口函数，和LED模块、继电器功能接口函数的声明，以便源代码引用。</p><pre><code class=\"language-c++\">/*\n&nbsp;* Copyright (C) 2019-2020 Alibaba Group Holding Limited\n&nbsp;*/\n#ifndef _APP_MAIN_H_\n#define _APP_MAIN_H_\n\n#include &lt;uservice/uservice.h&gt;\n#include &lt;yoc/netmgr_service.h&gt;\n\nvoid board_cli_init();\n\n#include &lt;stdint.h&gt;\nextern netmgr_hdl_t app_netmgr_hdl;\n\nvoid app_exception_event(uint32_t event_id);\nvoid board_yoc_init(void);\nvoid led_pinmux_init();\nvoid rgb_light(uint32_t red, uint32_t green, uint32_t blue, uint8_t brightness);\nvoid relay_pinmux_init();\nvoid relay_toggle(bool on);\nunsigned char get_state();\n\n#endif\n</code></pre><h2>设备调试</h2><p>在完成代码编写后，我们依然按照上一节中步骤，编译——烧录——运行，让智能灯开始工作，并接入物联网平台。</p><p>这时，我们就可以对智能灯进行在线调试了。打开阿里云生活物联网平台的设备调试页面后，我们点击测试设备条目中的“调试”操作，就会进入在线调试页面。</p><p>在调试页面中，我们可以选择调试功能“开关”，方法选择“设置”。下面的消息框中会自动根据物模型准备好JSON格式的消息体。</p><p><img src=\"https://static001.geekbang.org/resource/image/df/7d/df6yy6b7f1d09657cda991e58d1b507d.png?wh=1076x1300\" alt=\"\"></p><p>点击“发送指令”后，这个属性设置消息就会发送到智能灯，实现对智能灯的控制。当然，你也可以选择其他的属性进行设备测试。</p><p>另外，我们还可以在公版云智能App中测试、使用已接入平台的智能灯。这里要怎么实现公版云智能App的控制呢？你需要进入“批量投产”页面，然后点击“配网+App下载二维码”，根据提示下载云智能App到手机。接着，点击“产品发布”完成产品上线。</p><p><img src=\"https://static001.geekbang.org/resource/image/39/49/395747e61c1ebf089810764b9b2bdd49.png?wh=2036x1154\" alt=\"\"></p><p>完成这些准备工作后，你就可以在云智能App中添加我们的测试设备了。这里需要注意的是，要保证App和智能灯设备都连接到同一个Wi-Fi网络中，否则，云智能App是不能发现智能灯设备的。</p><p>App上的具体展示内容如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/06/0d/063f63945f3174f047815bde4c22490d.jpg?wh=1142x795\" alt=\"\"></p><h2>小结</h2><p>到这里，我们就完成了智能灯的联网控制开发任务。</p><p>在实验中，我们使用的物联网平台是阿里云生活物联网平台，整体的创建流程与第17讲的平台类似。重点是物模型的定义和人机交互界面的设计。</p><p>在智能灯的联网控制开发中，我们使用W800模组提供的AT指令来实现平台的交互。AT指令是通信领域常用的控制协议，在嵌入式领域也有广泛的应用，你可以基于本实验对它进行扩展学习。在连接Wi-Fi网络时，我们会使用到YoC嵌入式系统平台提供的网络管理器模块。关于YoC是什么，和模块的关系又是什么，我会在下一节详细讲解。</p><h2>思考题</h2><p>最后，我给你留一个思考题。你可能注意到源代码中有些函数的前面有static关键字，有些函数前面没有这个关键字。比如函数parse_living_msg前面有static，这是为什么呢？欢迎你在评论区写一下自己的理解，也欢迎你将这一节分享给你的朋友，大家一起交流学习。</p>","comments":[{"had_liked":false,"id":344488,"user_name":"LDxy","can_delete":false,"product_type":"c1","uid":1188710,"ip_address":"","ucode":"956432CE7B7761","user_header":"https://static001.geekbang.org/account/avatar/00/12/23/66/413c0bb5.jpg","comment_is_top":false,"comment_ctime":1651584315,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651584315","product_id":100063601,"comment_content":"static函数仅可以在本文件中使用，不是static的函数除了能够在本文件中使用，还能在其他文件中使用","like_count":1},{"had_liked":false,"id":343726,"user_name":"种花家","can_delete":false,"product_type":"c1","uid":1486568,"ip_address":"","ucode":"1BBBF4E10255E9","user_header":"https://static001.geekbang.org/account/avatar/00/16/ae/e8/d01b90c3.jpg","comment_is_top":false,"comment_ctime":1651025171,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1651025171","product_id":100063601,"comment_content":"老师，reb2601 咋么实现4G&#47;5G联网，以及不在同一wifi 下手机控制灯呢？","like_count":0,"discussions":[{"author":{"id":2302171,"avatar":"https://static001.geekbang.org/account/avatar/00/23/20/db/b04f43dc.jpg","nickname":"郭朝斌","note":"","ucode":"2969986E1B3851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568514,"discussion_content":"需要有4G/5G的通信模组（芯片）才能支持4G/5G联网，rvb2601本身不具备的。只要已经联网了，不在同一个Wi-Fi下也是可以控制灯。课程中提到的同一Wi-Fi下是指在App搜索添加设备阶段。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651154178,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}