{"id":505780,"title":"07｜TextInput：如何实现一个体验好的输入框？","content":"<p>你好，我是蒋宏伟。</p><p>上一讲，我们介绍了如何去打磨点按组件的体验细节，这一讲我们就开始介绍如何打磨一个文本输入组件 TextInput 的体验细节。</p><p>作为一个优秀工程师，要想优化页面的用户体验，只知道打磨点按组件是远远不够的，而且，相对于点按组件组件来说，要把文本输入组件 TextInput 的细节体验弄好，要更难一些。</p><p>这个难点主要有两方面。首先，TextInput 组件是自带状态的宿主组件。TextInput 输入框中的文字状态、光标状态、焦点状态在 React Native 的 JavaScript 框架层的框架层有一份，在 Native 的还有一份，有时候业务代码中还有一份。那多份状态到底以谁为主呢？这件事我们得搞清楚。</p><p>其次，TextInput 组件和键盘是联动的，在处理好 TextInput 组件的同时，我们还得关心一下键盘。当然键盘本身是有 <code>Keyboard</code> API 的，但是键盘类型是“普通键盘”还是“纯数字键盘”，或者键盘右下角的按钮文字是“确定”还是“搜索”，都是由 TextInput 组件控制的。</p><p>这一讲，我将以如何实现一个体验好的输入框为线索，和你介绍使用 TextInput 组件应该知道的三件事。</p><h2>输入框的文字</h2><p>第一件事，你得知道如何处理输入框的文字。</p><!-- [[[read_end]]] --><p>关于如何处理输入框的文字，网上有两种说法。有些人倾向于使用非受控组件来处理，他们认为“不应该使用 useState 去控制 TextInput 的文字状态”，因为 ref 方案更加简单；有些人倾向于使用受控组件来处理，这些人认为“直接使用 ref 去操作宿主组件这太黑科技了”。这两种说法是相互矛盾的，究竟哪种是正确的呢？</p><p>我们先从最简单的<strong>非受控（Uncontrolled）组件</strong>说起。</p><p>非受控的意思就是不使用 state，直接对从宿主组件上将文本的值同步到 JavaScript。一个非受控的 UncontrolledTextInput 组件示例如下：</p><pre><code class=\"language-plain\">const UncontrolledTextInput = () =&gt; &lt;TextInput /&gt; \n</code></pre><p>只要这一行代码，用户就可以输入文字了。在 UncontrolledTextInput  组件中， TextInput 元素是不受 state 控制，但在 JavaScript 代码中却并不知道用户输入的是什么，因此还要一个变量来存储用户输入的值。</p><p>用什么变量呢？首先在组件中声明局部变量是不行的，我们知道 render 就是组件函数的执行，每次执行局部变量也会重新赋值，局部变量保存的值不能跨越两次 render。其次，用全局变量或文件作用域的变量也是不行的，组件销毁时这些全局变量是不会销毁的，有内存泄露的风险。再者，用 state 也是不行的，用了 state 就成了受控组件了。</p><p>对于非受控组件来说，存储跨域两次 render 的可行方案是 ref。<strong>ref 的值不会因为组件刷新而重新声明，它是专门用来存储组件级别的信息的。</strong><a href=\"https://beta.reactjs.org/learn/referencing-values-with-refs#when-to-use-refs\">React 官方推荐</a>有三种场景我们可以用它：</p><ul>\n<li>存储 setTimeout/setInterval 的 ID；</li>\n<li>存储和操作宿主组件（在 Web 中是 DOM 元素）；</li>\n<li>存储其他不会参与 JSX 计算的对象。</li>\n</ul><p>我们使用 ref 保存非受控输入框的值，就属于第三种场景，示例代码如下：</p><pre><code class=\"language-plain\">function UncontrolledTextInput2() {\n  const textRef = React.useRef('');\n  return &lt;TextInput onChangeText={text =&gt; textRef.current = text}/&gt;\n}\n</code></pre><p>你看，首先我们使用 <code>useRef</code> 创建了一个用于保存用户输入的文字的对象 <code>textRef</code>。每当用户输入文字的时候，会触发 TextInput 的<code>onChangeText</code>事件，在该事件的回调中，我们将最新的<code>text</code>赋值给了<code>textRef.current</code>进行保存。这时，每次获取文字就都是最新的文字了。</p><p>非受控组件的原理是最简单的，用户输入的“文本原件”是存在宿主组件上的，JavaScript 中的只是用<code>textRef</code>复制了一份 “文本的副本”而已。</p><p>但正是因为非受控组件使用的是副本，一些复杂的操作是做不了的，比如将用户输入的字母由大写强制改为小写，等等。在新架构 Fabric 之前，React Native 还提供了直接修改宿主组件属性的<code>setNativeProps</code>方法，但是 Fabric 之后（包括 Fabric 预览版），<code>setNativeProps</code> 就不能用了。</p><p>因此我们要操作文本原件，必须得用<strong>受控（Controlled）组件</strong>。</p><p>受控的意思说的是使用 JavaScript 中的 state 去控制宿主组件中的值。一个受控的 ControlledTextInput 组件示例如下：</p><pre><code class=\"language-plain\">function ControlledTextInput() {\n  const [text, setText] = React.useState('');\n  return  &lt;TextInput value={text} onChangeText={setText} /&gt;\n}\n</code></pre><p>在这个示例中，我们先使用了 <code>useState</code> 创建了一个状态 <code>text</code> 和状态更新函数<code>setText</code>，并将状态<code>text</code>赋值给了 TextInput 的属性 <code>value</code>，<code>value</code> 是控制 TextInput 宿主组件展示的值用的。在用户输入文字后，会触发 onChangeText 事件，这时就会调用 <code>setText</code>，将状态 <code>text</code> 更新为用户最新输入的值。</p><p>那受控组件和非受控组件有什么区别呢？我把它们之间的实现原理画了一张图：</p><p><img src=\"https://static001.geekbang.org/resource/image/76/a9/7621791793d0d73030124e472f9117a9.png?wh=1920x672\" alt=\"图片\"></p><p>你看，对于非受控组件来说，用户输入文字和文字展示到屏幕的过程，全部都是在宿主应用层面进行的，JavaScript 业务代码是没有参与的。</p><p>然而，对于受控组件来说，用户输入文字和文字展示这两步，依旧是在宿主应用层面进行的。但后续 JavaScript 业务代码也参与进去了，业务代码依次执行了 onChangeText 函数、setText 函数、controlledTextInput 函数，并且再次更新了展示值。</p><p>也就是说，受控组件更新了两次展示的值，只是因为两次展示的值是一样的，用户看不出来而已。对于受控组件而言，即便存在系统或 Native 修改文本的情况，在 TextInput 的底层，也会将其强制更新为当前 TextInput 的 value 属性值。所以对于受控组件来说，输入框的文字始终是由 state 驱动的。</p><p>更新两次的好处在于，可以更加自由地控制输入的文本，比如语音输入文字、通过地图定位填写详细地址。这些复杂场景下，用户既可以自由输入文字，也可以引入程序参与进来。而非受控组件只适用于用户自由输入的场景。</p><p>不过，你可能会对更新两次有性能上的担忧。我也写了两个极限情况下的 demo，模拟了文字改变事件中需要处理 1s 任务，并且分别试了 onChangeText 的异步更新，和新架构提供的 unstable_onChangeSync 同步更新：</p><pre><code class=\"language-plain\">&lt;TextInput\n  onChangeText={text =&gt; {\n    const time = Date.now();\n    while (Date.now() - time &lt;= 1000) {}\n    setText(text);\n  }}\n/&gt;\n&lt;TextInput\n  unstable_onChangeSync={event =&gt; {\n    const text = event.nativeEvent.text;\n    const time = Date.now();\n    while (Date.now() - time &lt;= 1000) {}\n    setText(text);\n  }}\n/&gt;\n</code></pre><p>异步更新情况下，JavaScript 线程和 UI 主线程是独立运行的，此时即便 JavaScript 线程卡了 1s，主线程依旧可以正常输入文字。但同步更新的情况下，从输入文字到展示文字会有 1s 的延迟， JavaScript 线程有 1s 的阻塞，UI 主线程也会卡死 1s。</p><p>当然，大多数情况下处理文字改变事件肯定用不了 1s，甚至用不了 1ms。模拟极限情况，只是为了说明新架构的同步和异步是可选的，如果你担心性能问题，用异步就好了。</p><p>现在如果要我给个处理输入框的文本建议，那我的建议就是<strong>使用受控组件，并且使用异步的文字改变事件</strong>，这也符合大部分人的代码习惯。</p><h2>输入框的焦点</h2><p>你需要关注的第二件事是，如何控制输入框的焦点。通常光标放置在哪个输入框上，那个输入框就是页面的唯一焦点。</p><p>有些场景下，输入框的焦点是程序自动控制的，无需开发者处理。比如用户点击手机屏幕上的输入框，此时焦点和光标都会移到输入框上。</p><p>有些场景下，是需要代码介入控制焦点的。比如你购物搜索商品，从首页跳到搜索页时，搜索页的焦点就是用代码控制的。或者你在填写收货地址时，为了让你少点几次输入框，当你按下键盘的下一项按钮时，焦点就会从当前输入框自动转移到下一个输入框。</p><p>我们先来看怎么实现自动“对焦”，以搜索页的搜索输入框自动对焦为例，示例代码如下：</p><pre><code class=\"language-plain\">&lt;TextInput autoFocus/&gt;\n</code></pre><p>TextInput 的 autoFocus 属性，就是用于控制自动对焦用的，其默认值是 false。也就是说，所有的 TextInput 元素默认都不会自动的对焦，而我们将 TextInput 的 autoFocus 属性设置为 true 时，框架会在 TextInput 元素挂载后，自动帮我们进行对焦。</p><p>搜索页面只有一个搜索框的场景下 ，autoFocus 是好用的。但当一个页面有多个输入框时，autoFocus 就没法实现焦点的转移了。</p><p>比如，在购物 App 中填写收货地址时，你每完成一项填写，点击键盘中的下一项按钮，焦点就会自动转移一次，从姓名到电话再到地址。我们以前讲过，React/React Native 是声明式的，但是在操作自带状态的宿主属性时，比如焦点转移，声明式就不管用了，还得用给宿主组件下命令。</p><p>那怎么下命令呢？我们先从最简单的控制 TextInput 焦点讲起，示例代码如下：</p><pre><code class=\"language-plain\">function AutoNextFocusTextInputs() {\n  const ref1 = React.useRef&lt;TextInput&gt;(null);\n\n  useEffect(()=&gt;{\n    ref1.current?.focus()\n  },[])\n\n  return  (\n    &lt;TextInput ref={ref1}  /&gt;\n    )\n}\n</code></pre><p>在这段代码中，先声明了一个 <code>ref1</code> 用于保存 TextInput 宿主组件。在该宿主组件上封装了 Native/C++ 层暴露给 JavaScript 的命令，比如对焦<code>focus()</code>、失焦<code>blur()</code>、控制选中文字的光标<code>setSelection</code>。</p><p><code>AutoNextFocusTextInputs</code>组件在挂载完成后，程序会调用<code>ref1.current.focus()</code>，将焦点对到 TextInput 元素上，这就是使用<code>focus()</code>实现对焦的原理。</p><p>使用 <code>focus()</code>命令对焦和使用<code>autoFocus</code>属性对焦，在原生应用层面的实现原理是一样的，只不过在 JavaScript 层面，前者是命令式的，后者是声明式的。对自带状态的宿主组件而言，命令式的方法能够进行更复杂的操作。</p><p>那要实现每点一次键盘的“下一项”按钮，将焦点对到下一个 TextInput 元素上，怎么实现呢？具体的示例代码如下：</p><pre><code class=\"language-plain\">function AutoNextFocusTextInputs() {\n  const ref1 = React.useRef&lt;TextInput&gt;(null);\n  const ref2 = React.useRef&lt;TextInput&gt;(null);\n  const ref3 = React.useRef&lt;TextInput&gt;(null);\n\n  return (\n    &lt;&gt;\n      &lt;TextInput ref={ref1} onSubmitEditing={ref2.current?.focus} /&gt; // 姓名输入框\n      &lt;TextInput ref={ref2} onSubmitEditing={ref3.current?.focus} /&gt; // 电话输入框\n      &lt;TextInput ref={ref3} /&gt; // 地址输入框\n    &lt;/&gt;\n  );\n}\n</code></pre><p>首先，我们得声明 3 个 <code>ref</code> 用于保存 3 个 TextInput 元素。其次，实现这三个元素，它们依次是姓名输入框、电话输入框、地址输入框。最后，需要监听点击键盘完成按钮的提交事件<code>onSubmitEditing</code>，在<code>onSubmitEditing</code>的回调中，将焦点通过<code>ref.focus()</code>转移到下一个 TextInput 元素上。</p><p>这里再多说一句，为了简单起见，我们把三个 TextInput 元素都封装到了同一个组件中。在真实的项目中，这三个输入框往往不是封装成同一个组件中的，姓名输入框、电话输入框、地址输入框每个都是一个独立的组件，然后再有一个大的复合组件将它们组合在一起的。</p><p>那么这时，如何获取到 TextInput 元素 <code>ref</code> 呢？如果你遇到了这个问题，你可以查一下<a href=\"https://zh-hans.reactjs.org/docs/forwarding-refs.html\">React 文档</a>中，关于使用 <code>React.forwardRef</code>转发 <code>ref</code>的具体用法，这里我就不展开了。</p><h2>联动键盘的体验</h2><p>你需要关注的第三件事是，输入键盘的体验细节。</p><p>我们前面提到过，输入框和键盘是联动的，键盘的很多属性都可以用 TextInput 组件来设置。因此，除了输入框的值、输入框的焦点，我们还需要关心如何控制键盘。我们一起来看看那些优秀的 App 都是怎么处理这个细节的。</p><p>先来看第一个体验细节，iOS 微信搜索框的键盘右下角按钮有一个<strong>“置灰置蓝”</strong>的功能。默认情况下，键盘右下角的按钮显示的是置灰的“搜索”二字，当你在搜索框输入文字后，置灰的“搜索”按钮会变成蓝色背景的“搜索”二字。</p><p>置灰的作用是提示用户，没有输入文字不能进行搜索，按钮变蓝提示的是有内容了，可以搜索了。</p><p>控制键盘右下角按钮置灰置蓝的，是 TextInput 的<code>enablesReturnKeyAutomatically</code>属性，这个属性是 iOS 独有的属性，默认是<code>false</code>，也就是任何使用键盘右下角的按钮，都可以点击。你也可以通过将其设置为 <code>true</code>，使其在输入框中没有文字时置灰。</p><p><img src=\"https://static001.geekbang.org/resource/image/de/58/de5c8eb7862fd38405b1caba07eaf258.png?wh=1018x222\" alt=\"图片\"></p><p>第二个体验细节是，键盘右下角按钮的文案是可以变化的，你可以根据不同的业务场景进行设置。</p><p>有两个属性可以设置这些文案，包括 iOS/Android 通用的<a href=\"https://reactnative.dev/docs/next/textinput#returnkeytype\"> returnKeyType </a>和 Android 独有的 <a href=\"https://reactnative.dev/docs/next/textinput#returnkeylabel-android\">returnKeyLabel</a>。全部的属性你可以查一下文档，我这里只说一下通用属性：</p><ul>\n<li><code>default</code>：显示的文案是换行；</li>\n<li><code>done</code>：显示的文案是“完成”，它适合作为最后一个输入框的提示文案；</li>\n<li><code>go</code>：显示的文案是“前往”，它适合作为浏览器网站输入框或页面跳出的提示文案；</li>\n<li><code>next</code>：显示的文案是“下一项”，它适合作为转移焦点的提示文案；</li>\n<li><code>search</code>：显示的文案是“搜索”，它适合作为搜索框的提示文案；</li>\n<li><code>send</code>：显示的文案是“发送”，它比较适合聊天输入框的提示文案。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/dy/fd/dyyda94cdbb8d899c9852225d7e6f4fd.png?wh=1576x224\" alt=\"图片\"></p><p>比如，在用户填写收货地址表单的场景中，你可以在用户完成填写时，将键盘按钮文案设置成“下一项”，并在用户点击“下一项”时，把当前输入框的焦点聚焦到一下个输入框上。</p><p>第三个体验细节是，登录页面的自动填写账号密码功能。虽然现在有了二维码登录，但传统的账号密码登录场景还是非常多的。每次登录的时候，要输入一遍账号密码，就很麻烦了。</p><p>无论是 iOS 还是 Android，它们都有系统层面的记住账号密码的功能，帮助用户快速完成账号密码的填写。完成快速填写功能的 TextInput 属性，在 iOS 上叫做<code>textContentType</code>，在 Android 上叫做<code>autoComplete</code>。</p><p>你可以将账号输入框的快速填写属性设置为<code>username</code>，将密码输入框的快速填写属性设置为<code>password</code>，帮助用户节约一些时间，提高一下整体的成功率。除此之外，一些姓名、电话、地址信息也可以快速填写。</p><p><img src=\"https://static001.geekbang.org/resource/image/aa/6c/aa7378ddf3c2c193832f76b90323316c.png?wh=828x384\" alt=\"图片\"></p><p>还有一些键盘的体验细节，比如<code>keyboardType</code>可以控制键盘类型，可以让用户更方便地输入电话号码<code>phone-pad</code>、邮箱地址<code>email-address</code>等等。</p><p><img src=\"https://static001.geekbang.org/resource/image/6d/6f/6decc25dc3b45cc03e19ea533f15dc6f.png?wh=828x876\" alt=\"图片\"></p><p>当你知道这些键盘细节后，你就可以利用这些系统的特性，帮你的 App 体验变得更好。现在，我们回过头，再来改善一下，我们之前实现的自动聚焦组件 <code>AutoNextFocusTextInputs</code>吧。示例代码如下：</p><pre><code class=\"language-plain\">function AutoNextFocusTextInputs() {\n  const ref1,ref2,ref3 ...\n\n  return (\n    &lt;&gt;\n      &lt;TextInput ref={ref1} placeholder=\"姓名\" textContentType=\"name\" returnKeyType=\"next\" onSubmitEditing={ref2.current?.focus}/&gt;\n      &lt;TextInput ref={ref2} placeholder=\"电话\"  keyboardType=\"phone-pad\" returnKeyType=\"done\" onSubmitEditing={ref3.current?.focus}\n      /&gt;\n      &lt;TextInput  ref={ref3}  placeholder=\"地址\"  returnKeyType=\"done\" /&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre><p>在这段代码中，我们使用了<code>placeholder</code>来提醒用户该输入框应该输入什么，使用了 <code>textContentType=\"name\"</code> 来辅助用户填写姓名，使用了 <code>keyboardType=\"phone-pad\"</code> 来指定键盘只用于输入电话号码，使用<code>returnKeyType=\"next\" 或 \"done\"</code>来提示用户当前操作的含义，当然还有<code>ref.current.focus()</code>的自动聚焦功能。</p><h2>总结</h2><p>这一讲，我们还是围绕着交互体验这个角度来讲组件，从交互体验这个角度看 TextInput 组件，我们需要注意三件事：</p><ol>\n<li>学会处理输入框的文字。有两种处理方式受控组件和非受控组件，受控组件更强大一些，也更符合大多数 React/React Native 开发者的习惯；</li>\n<li>学会处理输入框的焦点。处理焦点有两种方式：一种是声明式的<code>autoFocus</code>属性，另一种是命令式的<code>ref.current.focus()</code>方法，前者适用场景有限，后者适用场景更多；</li>\n<li>学会处理与输入框联动的键盘，包括键盘右下角的按钮、键盘提示文案、键盘类型等等。</li>\n</ol><p>日常工作中，用到 TextInput 输入框的场景非常多，有聊天框、搜索框、信息表单等等，相信学完这一讲后，你能更好地处理 TextInput 体验细节。</p><h2>附加材料</h2><ol>\n<li>iOS 模拟器上，点击 TextInput 元素并没有键盘弹窗，必须使用真机进行测试。iOS 如何在真机上进行打包请参考<a href=\"https://www.jianshu.com/p/f31116a76ea9\">《iOS个人证书真机调试及报错》</a>。</li>\n<li>0.68 之后，新架构预览版已经能在本地跑起来了。如果你想跑 iOS RNTest App（Android 版哪位朋友帮忙提供一下？），也就是官方用于测试的 React Native App，你可以按照如下步骤进行操作：</li>\n</ol><pre><code class=\"language-plain\">$ git clone https://github.com/facebook/react-native.git\n$ cd react-native\n$ yarn\n$ cd packages/react-native-codegen\n$ yarn build\n$ cd ../rn-tester\n$ yarn\n$ USE_CODEGEN_DISCOVERY=1  RCT_NEW_ARCH_ENABLE=1 pod install\n$ xed .\n\n=&gt; 打开 xcode 后，点击构建模拟器 App\n=&gt; 真机构建参考，附加材料 1\n=&gt; 真机构建遇到 Undefined symbol:folly 报错，试着注释掉 packages/rn-tester/Podfile 文件中的如下代码：\n  # if !USE_FRAMEWORKS\n  #   use_flipper!\n  # end\n</code></pre><p>3、今天的Demo我依然放在了<a href=\"https://github.com/jiangleo/react-native-classroom/tree/main/src/07_TextInput\">GitHub</a>上，你可以自己动手试试。</p><h2>作业</h2><ol>\n<li>\n<p>请你实现一个如图所示的用于填写验证码的输入框组件：<br>\n<img src=\"https://static001.geekbang.org/resource/image/ce/96/ce50be3a09dcd4b531d14d9a733f1f96.png?wh=828x468\" alt=\"图片\"></p>\n</li>\n<li>\n<p>请你思考一下 TextInput 的异步 onChange 和同步 onChangeSync 的区别是什么？Fabric 的同步特性将给 React Native 带来什么变化？</p>\n</li>\n</ol><p>欢迎在评论区留言。我是蒋宏伟，咱们下节课见。</p>","neighbors":{"left":{"article_title":"06｜Pressable：如何实现一个体验好的点按组件？","id":504527},"right":{"article_title":"08｜List：如何实现高性能的无限列表？","id":506825}},"comments":[{"had_liked":false,"id":342139,"user_name":"AEPKILL","can_delete":false,"product_type":"c1","uid":1953977,"ip_address":"","ucode":"42443112F5846E","user_header":"https://static001.geekbang.org/account/avatar/00/1d/d0/b9/4870af0b.jpg","comment_is_top":false,"comment_ctime":1650033913,"is_pvip":false,"replies":[{"id":125195,"content":"iOS 模拟器可以弹出键盘，学到了👍\n除了隐藏 TextInput 我还有一种思路，就是直接使用显示的 TextInput + letterSpacing 控制字间距。","user_name":"作者回复","user_name_real":"编辑","uid":1088541,"ctime":1650419419,"ip_address":"","comment_id":342139,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100110101,"comment_content":"iOS 模拟器也是可以弹出键盘的，只要把 Hardware -&gt; Keyboard -&gt; Connect HardWare KeyBoard 的勾去掉就可以了。\n验证码组件我的思路是这样的:\n1. 放置一个隐藏的 TextInput\n2. 画短信验证码输入的 UI (其实就是几个格子)\n3. 点击验证码 UI 的时候调用 textInptRef.focus()\n4. 接受输入，划到对应的验证码格子里\n\n完整代码: https:&#47;&#47;gist.github.com&#47;AEPKILL&#47;3557c4b5b621a3aec36e7e3cd8571e56","like_count":8,"discussions":[{"author":{"id":1088541,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/1d/f0f10198.jpg","nickname":"蒋宏伟","note":"","ucode":"02226CABD5ECE7","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":565241,"discussion_content":"iOS 模拟器可以弹出键盘，学到了👍\n除了隐藏 TextInput 我还有一种思路，就是直接使用显示的 TextInput + letterSpacing 控制字间距。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650419419,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2322128,"avatar":"https://static001.geekbang.org/account/avatar/00/23/6e/d0/6875ea5a.jpg","nickname":"小天儿","note":"","ucode":"F29533891584E3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572317,"discussion_content":"我也尝试过使用 ref.focus()，但是我用手机测试的时候发现键盘收起之后，就弹不出来了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652705124,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1087879,"avatar":"https://static001.geekbang.org/account/avatar/00/10/99/87/5066026c.jpg","nickname":"dao","note":"","ucode":"4181FB270462CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":563801,"discussion_content":"弹出键盘: cmd + k","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650080406,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345886,"user_name":"小天儿","can_delete":false,"product_type":"c1","uid":2322128,"ip_address":"","ucode":"F29533891584E3","user_header":"https://static001.geekbang.org/account/avatar/00/23/6e/d0/6875ea5a.jpg","comment_is_top":false,"comment_ctime":1652673785,"is_pvip":false,"replies":[{"id":126320,"content":"你可以试着将 ScrollView 组件的 keyboardShouldPersistTaps 属性设置为 handled 试试。\n\n文档如下：\n\nkeyboardShouldPersistTaps：Determines when the keyboard should stay visible after a tap.\n\n- &#39;never&#39; tapping outside of the focused text input when the keyboard is up dismisses the keyboard. When this happens, children won&#39;t receive the tap.\n- &#39;always&#39;, the keyboard will not dismiss automatically, and the scroll view will not catch taps, but children of the scroll view can catch taps.\n- &#39;handled&#39;, the keyboard will not dismiss automatically when the tap was handled by children of the scroll view (or captured by an ancestor).","user_name":"作者回复","user_name_real":"编辑","uid":1088541,"ctime":1652887549,"ip_address":"","comment_id":345886,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100110101,"comment_content":"老师，TextInput 间进行跳转时，键盘总是会先收起再弹出，而在某些应用中，多个输入框之间跳转是不会收起键盘的，如何解决这个问题呢？","like_count":3,"discussions":[{"author":{"id":1088541,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/1d/f0f10198.jpg","nickname":"蒋宏伟","note":"","ucode":"02226CABD5ECE7","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572676,"discussion_content":"你可以试着将 ScrollView 组件的 keyboardShouldPersistTaps 属性设置为 handled 试试。\n\n文档如下：\n\nkeyboardShouldPersistTaps：Determines when the keyboard should stay visible after a tap.\n\n- &#39;never&#39; tapping outside of the focused text input when the keyboard is up dismisses the keyboard. When this happens, children won&#39;t receive the tap.\n- &#39;always&#39;, the keyboard will not dismiss automatically, and the scroll view will not catch taps, but children of the scroll view can catch taps.\n- &#39;handled&#39;, the keyboard will not dismiss automatically when the tap was handled by children of the scroll view (or captured by an ancestor).","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1652887549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342283,"user_name":"dao","can_delete":false,"product_type":"c1","uid":1087879,"ip_address":"","ucode":"4181FB270462CF","user_header":"https://static001.geekbang.org/account/avatar/00/10/99/87/5066026c.jpg","comment_is_top":false,"comment_ctime":1650169200,"is_pvip":false,"replies":[{"id":125177,"content":"给你认真的学习态度点赞。\n1. 实际上输入手机验证码这道题，它只需要一个，textinput 能够实现哦，我看到你有比较多 text，这一块还有改进空间。\n关键提示：letterSpacing\n2. onChangeSync 它还是一个私有的属性，你可以在源码中看到。","user_name":"作者回复","user_name_real":"编辑","uid":1088541,"ctime":1650416457,"ip_address":"","comment_id":342283,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100110101,"comment_content":"1， 新手，代码 https:&#47;&#47;github.com&#47;hdouhua&#47;hybrid-mobile-app&#47;tree&#47;main&#47;AwesomeProject&#47;src&#47;c07。\n2，不知道怎么的，在文档里找不到 TextInput 的方法 onChangeSync","like_count":0,"discussions":[{"author":{"id":1088541,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/1d/f0f10198.jpg","nickname":"蒋宏伟","note":"","ucode":"02226CABD5ECE7","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":565176,"discussion_content":"给你认真的学习态度点赞。\n1. 实际上输入手机验证码这道题，它只需要一个，textinput 能够实现哦，我看到你有比较多 text，这一块还有改进空间。\n关键提示：letterSpacing\n2. onChangeSync 它还是一个私有的属性，你可以在源码中看到。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650416457,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1087879,"avatar":"https://static001.geekbang.org/account/avatar/00/10/99/87/5066026c.jpg","nickname":"dao","note":"","ucode":"4181FB270462CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":566429,"discussion_content":"试做了 letterspaing 版本 v3，代码比较简洁。在视觉上调整间距费了些时间，可能使用等宽字体会相对容易调整。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650683402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1087879,"avatar":"https://static001.geekbang.org/account/avatar/00/10/99/87/5066026c.jpg","nickname":"dao","note":"","ucode":"4181FB270462CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":566291,"discussion_content":"也做了单个 textinput 的版本v2。\nletterSpacing 这个主意比较新颖，我要去试试。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650640301,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345992,"user_name":"见字如晤","can_delete":false,"product_type":"c1","uid":2641149,"ip_address":"","ucode":"2CBA86D3254B85","user_header":"https://static001.geekbang.org/account/avatar/00/28/4c/fd/2e4cd48f.jpg","comment_is_top":false,"comment_ctime":1652753949,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100110101,"comment_content":"还有一个特别重要的细节是，输入框与键盘的位置。键盘弹起的时候，是否有遮盖输入框的表现；如果没有，键盘会不会把整个页面往上顶起；Android和iOS表现这方面表现是否一致","like_count":2},{"had_liked":false,"id":394923,"user_name":"Zeke","can_delete":false,"product_type":"c1","uid":1089812,"ip_address":"北京","ucode":"D5BEC1FDCC0235","user_header":"https://static001.geekbang.org/account/avatar/00/10/a1/14/b487945f.jpg","comment_is_top":false,"comment_ctime":1728823130,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100110101,"comment_content":"并没有 `onChangeSync` 这个方法，从 RN 官网没有找到有这个，只有 onChange 和 onChangeText ","like_count":0},{"had_liked":false,"id":385712,"user_name":"demoker","can_delete":false,"product_type":"c1","uid":1455563,"ip_address":"北京","ucode":"5F56248AC90592","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJsnP3W12jSoGYBoAbjMW7kKqWsD1Imnic4TX9nOR0kvkTq5ap4n0aNfuicXibKDJib0zl0PEvhcBHe3g/132","comment_is_top":false,"comment_ctime":1703152590,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100110101,"comment_content":"下载的demo在iPhone上运行报错呢？Invariant Violation: requireNativeComponent: &quot;RTNCustomView&quot; was not found in the UIManager.","like_count":0},{"had_liked":false,"id":362887,"user_name":"Wcly👺","can_delete":false,"product_type":"c1","uid":2865756,"ip_address":"广东","ucode":"2031893B4EA160","user_header":"https://static001.geekbang.org/account/avatar/00/2b/ba/5c/ca8f01b4.jpg","comment_is_top":false,"comment_ctime":1669013145,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100110101,"comment_content":"要做一个文本编辑器，怎么控制光标适中在可视区域，就是横向输入长文本到输入框的时候能自动横向滚动，垂直换行的时候能自动垂直滚动，类似vscode的编辑页面。","like_count":0},{"had_liked":false,"id":354098,"user_name":"郭浩","can_delete":false,"product_type":"c1","uid":2440442,"ip_address":"广东","ucode":"FADCE07AC849D8","user_header":"https://static001.geekbang.org/account/avatar/00/25/3c/fa/b88b8b4e.jpg","comment_is_top":false,"comment_ctime":1660096089,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100110101,"comment_content":"TextInput是不是没法禁止它复制粘贴？在Android上不生效","like_count":0},{"had_liked":false,"id":350535,"user_name":"大神博士","can_delete":false,"product_type":"c1","uid":1195144,"ip_address":"","ucode":"8C4318095949F0","user_header":"https://static001.geekbang.org/account/avatar/00/12/3c/88/6bef27d6.jpg","comment_is_top":false,"comment_ctime":1656992316,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100110101,"comment_content":"“但是 Fabric 之后（包括 Fabric 预览版），setNativeProps 就不能用了。”\n\n有传送门吗？","like_count":0},{"had_liked":false,"id":348445,"user_name":"下一刻。","can_delete":false,"product_type":"c1","uid":1161123,"ip_address":"","ucode":"8D2C7CF81FF8F9","user_header":"https://thirdqq.qlogo.cn/qqapp/101423631/0FD57A9C0C5BFBDA3DA69AE26B3514FB/100","comment_is_top":false,"comment_ctime":1655108779,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100110101,"comment_content":"老师问一下：TextInput如何插入图片（自定义表情），如何使不同段的文字颜色不一样（话题）。","like_count":0},{"had_liked":false,"id":345896,"user_name":"小天儿","can_delete":false,"product_type":"c1","uid":2322128,"ip_address":"","ucode":"F29533891584E3","user_header":"https://static001.geekbang.org/account/avatar/00/23/6e/d0/6875ea5a.jpg","comment_is_top":false,"comment_ctime":1652685468,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100110101,"comment_content":"1. 代码：https:&#47;&#47;snack.expo.dev&#47;@sh-winter&#47;textinput\n2. onChnage 与 onChangeSync 的区别：个人认为 onChangeSync 比 onChange 响应的更快，适用于更高优先级的场景；Fabric 同步的特性与 react 18 结合将带来并发渲染，可中断渲染等新特性，实现在大规模 UI 更新时保持响应","like_count":0}]}