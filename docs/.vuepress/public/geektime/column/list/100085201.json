[{"article_id":406053,"article_title":"开篇词｜让我们来写一门计算机语言吧","article_content":"<p>你好，我是宫文学，一名技术创业者。</p><p>20多年前，我从北大毕业，搞过一些基础软件，也创过业，最近也一直在研究编译器、操作系统这样的底层技术。</p><p>我其实是极客时间的老面孔了，我曾在极客时间开过两门课，<a href=\"https://time.geekbang.org/column/intro/100034101\">《编译原理之美》</a>和<a href=\"https://time.geekbang.org/column/intro/100052801\">《编译原理实战》</a>。这两门课都聚焦于编译技术，一个是“读万卷书”，带你掌握编译原理；另一个是“行万里路”，教你怎么用编译技术。</p><p>今天我又设计了这门新课，带你来实现一门计算机语言。但是，你要知道，对于实现一门计算机语言而言，编译技术只是构成要素之一。它还有另外两块大的要素：一个是计算机语言的特性，包括类型系统、面向对象、函数式编程等；另一个是运行时技术，如虚拟机技术、内存管理等。</p><p>通过这门课你更好地把握计算机语言中涉及的各类技术的全貌，体会一下实现一门计算机语言的过程。</p><p>可能你还有点懵：我为啥要经历实现一门计算机语言的过程呢？这件事能帮我们提升哪些方面的能力或者成就感呢？接下来，我慢慢告诉你。</p><h2>为什么要自己折腾一门编程语言？</h2><p>现在，每个程序员都熟悉一门或几门计算机语言，但是，我们很少有人想过自己去动手实现一门语言。又或者，虽然豪情万丈地计划过，却又因为种种原因不曾真正付诸实践。</p><p>当然，我们也会为自己找很多理由。</p><!-- [[[read_end]]] --><p>最常见的想法是，计算机语言已经很多了，我们会用就行，干嘛要自己去实现呢？另一个常见的想法是，计算机语言，我学习起来都挺不容易，要想去实现它，那更是难以逾越的吧？</p><p>这些顾虑看起来都很有说服力，可是，尽管如此，仍然有不少人还是会摆脱这些顾虑，去动手亲自实现一下计算机语言。为什么要做这样看上去很不理性的事情呢？我从我自身的体会来谈一下。</p><p><strong>第一，实现一门计算机语言所带来的能力，是真的有用。</strong></p><p>我们有时候觉得实现一门计算机语言这样的事情，纯属闲着没事干，因为要让一门计算机语言成功的机会太渺茫了，条件太苛刻了。</p><p>不过，在实现一门计算机语言的时候，你能接触到编译技术、运行时技术、汇编语言、硬件架构和各种算法，基本上是从顶层到底层把技术做穿。有了这些硬功夫，其实你已经能够胜任大多数高层次的软件开发工作了。比如，据我了解，Python语言的异步IO模块的开源贡献者，前一阵创业就去做一种创新的异步数据库产品了。</p><p>你一样也可以。从前你只会用人家写的东西，现在你要自己来实现了，肯定能更好地理解这套东西的核心逻辑，也能获得更多技术上的高维优势。最现实的就是你能拿下一个个难啃的技术难题，获得更多的晋升机会。</p><p><strong>第二，不仅有用，而且这个过程真的很爽。</strong></p><p>在我的前两门课里，有同学在实现了一个简单的脚本解释器之后，留言说“激动得浑身发抖”。是的，钻研一些比较深入的技术，会给人带来极大的成就感。特别是对于天天使用计算机语言的程序员来说，如果你有机会把计算机语言实现一遍，洞悉其中的技术秘密，那带来的成就感更是难以比拟的！</p><p><strong>第三，像计算机语言这样的领域，更是大有前景。</strong></p><p>如果你在关注中国技术发展，那你肯定知道我们目前正奋力在补基础技术方面的课，希望有朝一日也能拥有我们中国自己的优秀基础软件，比如HarmonyOS就在做这种尝试。而且，我们会看到中国涌现出越来越多的编程平台，很多产品会具备二次编程能力，甚至我们自己的计算机语言也会出现并逐步成熟。</p><p>要实现这样的突破，需要有更多具备底层编程能力的人才加入进来，要能够深刻理解程序在计算机硬件和操作系统之上运行的基础机制，以及计算机语言编译和运行所需要的技术。而学习如何实现一门计算机语言的过程，就能够带给你这些方面的提高。</p><p>现在，我相信你已经了解了，为什么你有必要掌握实现一门计算机语言所涉及的各种技术。不管仅仅是兴趣爱好的原因，还是为了自己的发展，甚至是为了在科技创新的趋势中弄潮，我都邀请你参与进来，一起来玩一玩这些技术。</p><p>而要开始实现一门计算机语言，我们首先就需要做一个决策：去实现一门什么样的语言？</p><h2>我要带你实现什么样的语言？</h2><p>首先，我否决了去设计一门全新的语言。</p><p>因为设计一门语言真的很有难度，也是最容易引起争议的话题。而且，这项工作不仅是一项技术工作，还是一个产品设计工作，需要兼顾艺术性和用户体验，是个见仁见智的话题。</p><p>其次，我也不想像一些教科书那样，去实现一个玩具语言，这些语言往往不具备最后真正意义上的实用性。</p><p>经过几番思考，<strong>最终我选择去实现一门已经存在的语言：TypeScript</strong>。一门计算机语言其实可以有多个具体实现，像JavaScript就有V8（用于Chrome和Node.js）、TraceMonkey（用于FireFox）、QuickJS等多个不同的实现，每个实现都有不同的适用场景。<strong>而我要带你做的是，TypeScript的一个全新的实现。</strong></p><p>TypeScript（以及JavaScript）的程序员群体相当庞大，并且它还具备编译成原生应用的潜力，所以HarmonyOS选择了TypeScript作为主力开发语言。</p><p>我前一阵参与发起了一个开源工业操作系统的项目。为顺应HarmonyOS的趋势，我也准备用TypeScript实现工业控制软件的开发。过去这些领域都是用C++做开发，其实用TS也完全可以。我甚至也跟JavaScript（ECMAScript）标准组的一名专家热烈讨论过，我们可以把HarmonyOS的基于TypeScript的前端开发工具扩展开来，用于支持安卓、IOS、桌面应用乃至小程序的开发，变成一个跨平台的开发工具，这也完全可以。</p><p>所以说，我们这门课选择TypeScript，是看好它未来有更大的发展空间。HarmonyOS已经开了个头，我们还可以做更多的探索。</p><p>而且，这门课的大部分内容，比如编译功能等，我们也是采用TypeScript来实现的。对于前端工程师来说，他们本身就很熟悉TypeScript。对于众多的后端工程师而言，由于TypeScript是静态类型的语言，所以他们上手起来也会很快。对于移动端的开发者而言，未来肯定需要了解在HarmonyOS上如何开发应用，所以熟悉一下TypeScript也是有必要的。</p><p>那接下来，我们看看在这门课里，我会带你完成哪些工作和挑战。</p><h2>我会带着你完成什么挑战？</h2><p>总的来说，实现一门计算机语言，我们需要实现编译器、运行时，还要实现面向对象等各种语言特性。</p><p><strong>具体一点，首先，我会带着你实现一个纯手写的编译器前端。</strong></p><p>编译器前端指的是词法分析、语法分析和语义分析功能。我们目前使用的大多数计算机语言，比如Java、Go、JavaScript等，其编译器前端功能都是纯手写的，而不是采用工具生成的。我会带你了解那些被这些语言所广泛采用的最佳实践，比如LL算法、运算符优先级算法等等。</p><p>这种纯手写的实现方式，能让你最大程度体会相关算法的原理。另外，也非常有利于你根据自己的需要进行修改，来满足特定领域的需求。比如，我同学的公司有一个产品，支持在浏览器里编写代码，处理遥感数据。这样的需求，完全可以用TypeScript实现，再编译成JavaScript在浏览器里运行即可。</p><p><strong>第二，我还会带你实现纯手写的编译器后端。</strong></p><p>编译器后端指的是生成目标代码的功能，而目标代码呢，指的是字节码或汇编代码。编译器后端不仅要生成代码，还要对代码进行优化，尽量提升它的性能。</p><p>编译器后端的工作量通常更大，所以像Rust、Julia等新兴起的语言，往往采用一个后端工具，比如LLVM，而不是自己编写后端，这样可以节省大量的工作。不过这个方式也有缺陷，比如针对移动应用或者浏览器运行环境，在资源占用、即时编译速度等方面就不够理想。所以，像JVM、Android的运行时、V8等，都会自己去实现后端。</p><p>而且，如果你对语言的运行机制有特殊的要求，并且跟C/C++这些不同，那么你最好自己实现一个后端，比如Go语言就是这样。</p><p>编译器后端通常还包含大量的优化算法（有时候，我们把这些优化功能归为中端），这些优化算法具有比较强的工程性，所以教科书里的描述往往不够具体，也不能体现业界的一些最佳实践。在这门课里呢，我们可以自己动手去体会这些最佳实践，包括基于图的IR，以及一些优化算法，从而对优化算法的理解更加具象化。</p><p>在编译器后端里，因为我们还要生成汇编代码，所以能带你掌握汇编语言的精髓。在实现一些系统级软件的时候，我们有时候必须能够想象出来，这些软件的逻辑落实到汇编代码层面是什么样子的，这样才能确定最佳的技术策略。而破除对汇编代码的陌生感，是打通技术人员奇经八脉的重要一环。</p><p><strong>第三，我还会带你实现多个运行时机制。</strong></p><p>要让编译后的程序运行起来，我们必须要设计程序的运行机制。当然了，让一个程序跑起来的方法很多。在这门课里，我将带你实现多种运行时机制，让你能体会它们各自的设计思想，并能进行相互间的比较。</p><p>首先，我会带你实现一个AST解释器，也就是通过遍历AST的方式来运行程序。这种方式虽然简单，但很实用，对很多应用需求来说都够用了。</p><p>接着，我会把AST编译成字节码，在虚拟机上运行。像Java、JavaScript、Python等语言，都支持这种运行方式。在这个环节，我们会讲解栈机和寄存器机的差别，设计字节码，并实现一个栈机。</p><p>并且，我还会带你实现两个不同版本的虚拟机，一个是基于TypeScript实现的，一个是基于C语言实现的。当你采用C语言时，你对于运行时的一些实现细节拥有更多的掌控能力。你会看到，只有掌控了像内存分配这些技术细节，才能让基于C语言的虚拟机在性能上胜出。</p><p>当然，最后，我还会带你把程序编译成本地可执行文件来运行。在这个过程中，我最希望你能够彻底搞清楚，当一个编译成本地代码的程序在运行的时候，到底CPU、操作系统和计算机语言本身各自都扮演了什么角色。这是打通技术上的奇经八脉来说，是非常重要的一环。</p><p>你会发现，作为计算机语言的实现者，你其实拥有比自己想象中大得多的发挥空间。所以，当你实现像协程、JIT机制等高级特性的时候，就能够更好地设计或理解相应的技术方案。</p><p>对于一些技术细节，比如通过汇编代码做栈桢的管理，我们也会上手获得细致的理解。基于这些透彻的理解，你会有能力基于栈桢的机制来实现尾递归和尾调用的优化，从而让你增强对于物理机的运行机制的掌控感。</p><p>最重要的是，每实现一个运行时机制，我们都会进行性能的测试和比拼。这些真实的测试和数据，会让你对于运行时机制产生非常具象的感受。下面这张图就是在课程的某一讲中，我们集齐了5个版本的运行时进行对比测试的结果。更重要的是，这几个版本的运行时，你都可以自己动手做出来。<br>\n<img src=\"https://static001.geekbang.org/resource/image/58/65/58c9c3bcyy290f1ae0277f9dc1b2ef65.png?wh=1664x835\" alt=\"\"><br>\n<strong>第四，我会带你理解一些高级语言的特性是如何实现的。</strong></p><p>在实现了计算机语言的一些基本特性以后，我们会去讨论一些高级一点的话题，比如类型体系的实现；在支持面向对象时，如何用最小的代价实现运行时的多态特性；在支持函数编程特性时，又是如何实现高阶函数功能、闭包功能等。</p><p>而对象、闭包等特性，又不可避免地会引出运行时的内存管理问题，因此，我们也会实现一个自己的垃圾收集器。</p><h2>我会怎么带你一步步实现？</h2><p>看着我前面大段大段的介绍，你觉得这些东西难吗？有编译，有运行时，还有一些更高级的语言特性，看上去还挺难吧？内容也很多，你可能心里已经开始打“退堂鼓”了：这么多内容，难度又不小，我能跟下来吗？</p><p>请打住！其实你根本不用担心。我在课程内容的设计上是逐步递进的，你会自然而然地跟着走下来，不会感觉有很大的学习困难。我会从原理出发，带你走完整个语言的实现过程，一方面能避免各种繁琐的编程工作，对你理解原理带来干扰；另一方面又能保留足够多的技术细节，让我们的教学语言具备足够的实用性。</p><p>哪怕你只学了几节课，你也能够掌握编译器前端的基础技能，实现一个AST解释器。再学几节课呢，就能搞出一个基于TypeScript的虚拟机出来。然后再加两节呢，又搞出一个C语言版本的虚拟机出来。不知不觉间，你就走出很远，爬得很高了。</p><p>在第一部分起步篇中，我会主要选取少量的语言特性，带你迅速实现从前到后的技术贯穿，这样你就能对计算机语言涉及的各项技术有一个全局性的了解。</p><p>这一部分又分成了三个阶段。在第一个阶段，我会带你用AST解释器把TypeScript跑起来，并在这个过程中带你掌握业界最常用的词法分析技术、语法分析技术和语义分析技术。在第二个阶段，我会升级解释运行的机制，带你掌握字节码技术和栈机。而在第三个阶段，我们就已经能够让程序编译成本地代码运行了！<br>\n<img src=\"https://static001.geekbang.org/resource/image/7c/0e/7c365a0dafdddcc864f6efd94099980e.jpg?wh=2248x1590\" alt=\"\"><br>\n紧接着在第二部分进阶篇呢，我会把这条路拓宽，也就是增加更丰富的语言特性，比如支持更多的数据类型、支持面向对象和函数式编程特性，等等。在这一部分，你能够丰富知识面，从而有能力解决更多的基础技术问题，其中就有内存管理这个关键技术。<br>\n<img src=\"https://static001.geekbang.org/resource/image/7c/a0/7cebeaa9c1542b933cd71bd743fa5fa0.jpg?wh=2248x718\" alt=\"\"><br>\n学完进阶篇以后，你对实现一门计算机语言中所涉及的知识点，掌握得就比较全面了。剩下的知识点，通常只有专门从事这个领域工作的人或研究人员才会去涉足，这里面就包含编译优化技术。</p><p>每一门语言都会特别重视性能，而优化技术就是提升语言性能的关键。我还看到现实中一些做开发平台的项目中，真正的硬骨头往往就是优化技术。所以在最后在第三部分优化篇里，我就主要介绍一下优化技术。我会用比较浅显和直观的方式，让你了解Java、JavaScript等语言所采用的前沿优化技术，洞悉它们最深处的奥秘，让你有能力去承担那些攻坚性的任务。<br>\n<img src=\"https://static001.geekbang.org/resource/image/3a/86/3a5f10e8277a3b4710fa93yy0d7c5686.jpg?wh=2248x810\" alt=\"\"></p><p>更具体的详细目录你可以看看这个：<br>\n<img src=\"https://static001.geekbang.org/resource/image/c8/23/c8652c14c656799b63123b9829789823.jpg?wh=1564x7941\" alt=\"\"></p><p>如果把实现一门计算机语言看成是一场冒险，那么现在我已经给你规划好了目标和路线，也会在路途中给你不断充实“武器”和“弹药”。</p><p>但俗语也有说，“兵马未动，粮草先行。”贴心的我还给你储备好了“衣物”和“粮草”，我给你备好了有着上万行的实验代码的<a href=\"https://gitee.com/richard-gong/craft-a-language/tree/master\">代码库</a>。而且，我们课中采用的技术，是基于我手头正在做的一门实用级语言为素材的，而且会作为开源项目一直进行版本迭代，所以你甚至可以拿这个开源项目作为自己工作的基础。当然了，我也无比欢迎你加入其中和我一起共建，为我们的“后勤保障”添砖加瓦。</p><p>好了，现在万事俱备，只欠东风。加入我吧，我已经迫不及待和你开启这一场计算机语言的冒险了！</p><h3><a href=\"https://jinshuju.net/f/eMNUpx\">欢迎点击链接加入交流群</a></h3>","neighbors":{"left":[],"right":{"article_title":"课前热身｜开始学习之前我们要准备什么？","id":406073}}},{"article_id":406073,"article_title":"课前热身｜开始学习之前我们要准备什么？","article_content":"<p>你好！我是宫文学，欢迎来到《手把手带你写一门编程语言》的课程。</p><p>其实，你从课程题目就可以看出，我们这个课强调动手实践。所以在这一节课，我要给你介绍一下我们这个课程示例代码所采用的计算机语言，以及相关编程环境的搭建。这样，会方便你阅读、运行和修改课程的示例代码。</p><p>对于课程里用到的汇编语言、编译原理知识，如果你之前没有相关的经验，也不要担心。我会介绍一下我们这方面的设计思路，保证你通过这个课程会更快、更扎实地掌握它们。</p><p>通过这篇导读，你会对课程里用到的语言、工具、技术心里有数，以便更好地开启你的学习之旅。</p><p>好，我们先从使用的计算机语言和环境说起。</p><h2>怎么快速上手TypeScript语言</h2><p>我们这个课程的目标呢，是要实现TypeScript的编译器和各种运行时。既然如此，那么我就尽可能地用TypeScript来实现这个目标。</p><p>虽然我们这个课程主体的代码都是用TypeScript写的，但我正式使用TypeScript其实是从2021年5月份开始，也就是我开始准备这个课的时间。</p><p>我知道你肯定会问：用几个月的时间，既要了解TypeScript，又要用TypeScript写自己的编译器，是不是太不靠谱了？当然，你可能也是因为要学习这门课程，第一次使用TypeScript，所以我就分享一下自己的一些经验。</p><!-- [[[read_end]]] --><p><strong>第一，使用它！</strong></p><p>我一直觉得，真正的语言学习开始于你使用它的那一刻。否则，你就是一直看这门语言的资料，也只能留下个大概印象，而且很快就会忘掉，只有动手使用，才会形成肌肉记忆。比如，现在我一写for循环，手指不自觉地打出“for (let i = …)”或\"for (let x of …)\"开头，这就是形成肌肉记忆了。</p><p><strong>第二，看资料！</strong></p><p>说实在的，现在学习计算机语言实在是太方便了，各种资料应有尽有，又有很多热心同学在网上的分享，遇到什么需求一查就有，用过才会记住。</p><p>如果你让我推荐一本学习资料，我比较推荐流浪小猫写的开源电子书<a href=\"http://ts.xcatliu.com/\">《TypeScript入门教程》</a>。这个作者可能比较懂我想看什么，提供的内容会到点上。比如，我们做面向对象编程的时候，都关心该语言是否具备运行时的类型判断能力，因为这个功能几乎百分之百会被用到，而这个教程里就专门有<a href=\"http://ts.xcatliu.com/basics/type-assertion.html\">类型断言</a>的章节。</p><p><strong>第三，靠经验直觉！</strong></p><p>其实，很多同学都学过多门语言，那么学一门新语言的速度就会很快。有经验的程序员会建立一些直觉，能够猜到一门语言可能具备什么特性。</p><p>在准备课程代码的时候，我有一次要编写一个类，代表汇编指令中的寄存器操作数。而在x86的汇编指令中，不同位数的寄存器的名称是不一样的，所以，我需要用一个成员变量bits，来表示这个寄存器的位数。这个时候，我想当然地写出了下面的代码：</p><pre><code class=\"language-plain\">class Register extends Oprand{\n    bits:32|64 = 32;  //寄存器的位数\n    ...\n}\n</code></pre><p>也就是位数只能取两个值，要么是32，要么是64，赋其他值给它都是错误的。</p><p>在使用这个写法的时候，我其实不是很确定是否可以用两个值的集合来描述变量的类型，因为在教程里提到<a href=\"http://ts.xcatliu.com/basics/union-types.html\">联合类型</a>（Union Types）的时候，只是说了可以用两个类型的联合。我直觉上觉得也应该支持两个值的联合，因为如果我是TypeScript的作者，我可能不会忽视这种使用场景。我根据自己的猜测试了一下，然后就成功了。</p><p>如果上升到类型理论的高度，那么我们可以说，类型本来就是可以取的值的集合。但如果我们不上升到理论高度，仅凭直觉，其实也能去正确地使用类型。</p><p>说到老程序员的直觉，其实这门课程的一个重要目标，就是想帮你建立起更多的直觉，建立仅仅通过高级语言的语法表象就能看透其内部实现机制的能力，让计算机语言在你面前成为一个白盒子，从而让你能够更加自如地去支配不同的语言来为自己服务。</p><p>好了，了解了怎么上手以后，我们再来看看在这门课程中的TypeScript的环境配置问题。</p><h2>TypeScript的环境配置</h2><p>我们这个课程关于TypeScript的环境配置主要包括这些：</p><p><strong>1.编译和运行环境：Node.js。</strong></p><p>首先，我使用Node.js来编译和运行TypeScript，所以你要先在自己的电脑上安装Node.js，配置好相应的环境。这方面的资料很多，我就不提供链接了。</p><p><strong>2.安装和配置TypeScript。</strong></p><p>使用下面的命令，可以安装TypeScript：</p><pre><code class=\"language-plain\">npm install typescript -g\n</code></pre><p>之后，你可以用git命令下载示例代码：</p><pre><code class=\"language-plain\">git clone https://gitee.com/richard-gong/craft-a-language.git\n</code></pre><p>在用git下载了示例代码以后，需要你在示例代码的目录中运行下面这个命令，安装示例程序依赖的node.js中的一些包。安装完毕以后，会在craft-a-language目录中建立一个node_modules子目录：</p><pre><code class=\"language-plain\">npm i --save-dev @types/node\n</code></pre><p><strong>3.IDE：Visual Studio Code（简称VS Code）。</strong></p><p>我在课程里使用了VS Code作为IDE，VS Code缺省就支持TypeScript语言，毕竟这个IDE本身就是用TypeScript编写的。</p><p>而且，我们每一节课的代码，都会被放在我们<a href=\"https://gitee.com/richard-gong/craft-a-language/tree/master\">代码库</a>里的一个单独的目录下，比如01、02……在每个目录下，都会有几个json文件，是TypeScript的工程配置文件。你只要在目录下输入tsc，就会编译该工程的所有.ts文件。</p><p>打开tscongfig.json，你会看到我提供的一些配置项：</p><ul>\n<li>target项是编译目标，这里我用的是es6，因为es6具备了很多高级特性。</li>\n<li>module项是模块管理工具，我们选用的是CommonJS。</li>\n<li>另外，有“exclude”选项，是排除了一些.ts文件，不纳入编译范围。这些.ts文件都是以example开头，是我们自己课程的一些例子，给我们自己的编译器使用的，就不用tsc编译了。</li>\n</ul><p><strong>4.运行我们自己的语言：</strong></p><p>我们自己的语言的入口，是play.ts，你可以通过下面这个命令来运行example.ts程序：</p><pre><code class=\"language-plain\">node play example.ts\n</code></pre><h2>C语言相关的功能和配置</h2><p>我们这个课程的部分内容还使用了C语言，主要用来实现一些运行时的功能，包括：</p><ul>\n<li><strong>实现了一个运行字节码的虚拟机：</strong></li>\n</ul><p>我们首先用TypeScript实现了一个虚拟机，然后用C语言又实现了一版。因为现实世界的很多虚拟机，都是用C/C++实现的，所以我们要体会一下系统级的语言来实现虚拟机有什么不同，特别是性能上会有什么提升。同时，也能体会到字节码带来的跨平台特性：针对相同的字节码，不同的虚拟机的运行结果是完全一样的。</p><ul>\n<li><strong>实现了一些内置函数：</strong></li>\n</ul><p>每门语言都有一些内置的函数，由于其功能比较底层，所以要用系统级的语言来实现。比如，我们在语言里提供了一个println()的内置函数，用来打印信息，方便程序调试。这个函数我是用C语言的标准库实现的，然后在生成的汇编代码中调用这个函数就行。</p><p>还有一些内置函数，叫做Intrinsics，它们不是给开发者使用的，而是被编译器所调用。比如，为了实现TypeScript对字符串数据类型的支持，我用C语言写了几个函数，分别用于创建字符串对象、返回字符串长度，还有进行字符串连接等功能。很多时候，语言的使用者意识不到这些内核函数的存在，但他们使用TypeScript本身的语法来处理字符串的时候，在运行时里就会调用这些内置函数。</p><ul>\n<li><strong>实现了内存管理功能：</strong></li>\n</ul><p>TypeScript是面向对象的语言，在使用对象的过程中，需要内存管理功能来生成内存中的对象。在必要的时候，又会运行垃圾收集功能，回收不再被使用的对象，这些功能也是用C语言实现的。</p><p>我想，大部分同学对C语言应该还是比较熟悉的。虽然有很多同学在工作以后可能不太使用C语言，但很多在大学的时候都学习过，做过课程练习，所以阅读和编写课程中的示例代码，应该难度不大。C语言的特点就是很简洁，所以也受到很多极客的欢迎。如果我用C++来写这些代码，可能就会给你带来一些阅读障碍了。</p><p>我们这门课C语言的配置环境是这样的：</p><p><strong>1.编译器等工具链。</strong></p><p>我平常工作采用的是MacOS系统，所以系统有自带的clang工具链。同时，你也可以使用gcc，我在课程里使用的clang命令，其实换成gcc都能运行。所以，如果你用Linux/Windows系统做课程练习，就可以用gcc开发环境，Windows系统可以参考<a href=\"https://www.jianshu.com/p/dc0fc5d8c900\">这篇文档</a>。</p><p><strong>2.IDE：Visual Studio Code。</strong></p><p>如果你要编写和调试这些C语言的代码，仍然用VS Code就可以了。而且，我用起来已经比较习惯了，觉得没必要采用一个商用的IDE。</p><p>这门课的C语言的代码都被我放在了<a href=\"https://gitee.com/richard-gong/craft-a-language/tree/master\">代码库</a>里的vm和rt两个子目录下，一个是虚拟机的代码，一个是运行时的代码。在这两个目录下，都有一个.vscode目录，里面有一些配置文件，告诉VS Code如何做编译和代码调试。</p><p>最后，我想说明一下，我在课程里使用C语言其实还有另一个重要的用途，就是观察同样的功能，用C语言生成的汇编代码是什么样子的，从而加以学习和模仿。根据我的经验，这是最快熟悉器汇编语言的途径。</p><p>那我们接下来就说说汇编语言。</p><h2>你是否需要懂汇编语言？</h2><p>在这个课程里，我们会实现编译器的后端，也就是把TypeScript编译成汇编代码，从而生成二进制的可执行文件。所以，从这个意义上说，<strong>我们需要了解汇编语言</strong>。</p><p>但从现实角度，除了一些嵌入式开发、芯片开发、驱动开发、操作系统，还有编译器等领域的工程师，很少有人日常也使用汇编语言。就算使用，也很少人能够熟悉各种不同芯片的指令集。</p><p><strong>所以，这个课程关于汇编语言的部分，不需要你提前学过相关课程</strong>。我会用一节课，给你介绍一下物理计算机的运行时原理，这是使用汇编语言的背景知识；然后再用一节课，介绍汇编语言的一些共性的知识，包括不同芯片的指令集都会有的一些共性的指令、指令的构成，以及我们课程所针对的x86架构的CPU的一些信息，比如寄存器的名称和用途等。</p><p>有这些知识，基本就能够你开始使用汇编语言了。而要真正掌握汇编语言，把它用出感觉来，只有一条途径：<strong>在实践中使用它们</strong>。</p><p>在这个课里，你可以用我们自己实现的编译器生成汇编代码，或者把C/C++程序生成汇编代码，这样反复比较对比，你就会去除对汇编语言的陌生感。到最后，你会发现汇编语言其实真的挺简单的。</p><p>除了汇编语言这个问题外，还有一点我想跟你说一下。其实，我们要实现一门计算机语言，是绕不开编译技术的，你可能也会担心这一点，会不会让你学了编译原理再来，我现在跟你解释一下。</p><h2>你是否需要懂编译原理？</h2><p>我们这门课程主要是一门实践课，所以我尽量不对一些理论性的知识做过多的要求，不需要你懂编译原理。</p><p>反之，其实很多编译方面的知识点，仅仅从理论方面学习，很难学得会，反倒是动手实现，并没有想象的那么难。比如语法分析的算法，是编译原理课的难点，但在这个课程中，我会介绍当前主流计算机语言实现的方法。你自己实现的时候，那些抽象的知识点一下子变得很具体，会产生“原来就是这么回事呀”的感觉，学习门槛一下子就降低了。</p><p>另有一些知识内容，属于工程性的知识，本来在教科书上就不多见，比如如何实现一个虚拟机等，就更需要通过实践来学习了。还有很多内容超出了编译原理的课程范围，有些国外的学校，会提供一些关于运行时的课程、计算机语言设计的课程，但都比较小众。</p><p>所以说，我们这门课程，围绕实现一门语言，用到什么技术，就介绍什么技术，横跨的知识面很大，很综合。比如在运行时方面，涉及了AST解释器、运行字节码的虚拟机和编译成本地代码等多个机制、多个版本的实现，我很少能见到能把这些所有内容都贯穿起来的课程或书籍。</p><p>总结起来，我们这门课，更多的是“行万里路”，而不是“读万卷书”，强调在动手实践的过程中学习。而在这个过程中，一旦获得了各个知识点的直觉理解，再反过去学那些纯理论性的内容，会更加容易。</p><h2>利用好课程中的示例代码</h2><p>在这个课程中，我提供了用TypeScript和C语言的示例代码。在课程的文稿中，我主要写的是设计思路，但要真正理解这些设计思路和相关知识点，不是仅仅看看文稿就够的，还是要看代码、运行代码、修改代码，加上这些实践环节后，你的学习效果会更加理想。</p><p>并且，我也鼓励你用你顺手的语言重新实现。在我的其他课程里，有很多同学就用自己习惯的语言来重写课程的示例代码，用什么语言的都有，比如Go语言、Swift、C++、TypeScript等。这个优秀的传统，我希望可以在这门课里继续发扬！</p><p>当然，我也会尽量把示例代码的结构理得清晰一些，多加一些注释，让你更容易看懂。如果对代码有什么疑问或建议（我自己就经常发现旧代码里的bug），可以在评论区给我留言，或者在码云上提issue，我会想办法去解决。</p><p>好了，上课前的准备工作就是这些。你赶紧把环境配置好，我们就开始上手学习和实践啦！相信在这门课里，你会在很多地方产生“噢，原来是这样！”的感受，帮助你打通计算机技术的奇经八脉，真的很爽！</p><p>来吧，我在课程里等你！</p><h3><a href=\"https://jinshuju.net/f/eMNUpx\">欢迎点击链接加入交流群</a></h3>","neighbors":{"left":{"article_title":"开篇词｜让我们来写一门计算机语言吧","id":406053},"right":{"article_title":"01｜实现一门超简单的语言最快需要多久？","id":406179}}},{"article_id":406179,"article_title":"01｜实现一门超简单的语言最快需要多久？","article_content":"<p>你好，我是宫文学。</p><p>说到实现一门计算机语言，你肯定觉得这是一个庞大又复杂的工程，工作量巨大！</p><p>这个理解，我只能说部分正确。其实，有的时候，实现一门语言的速度也可以很快。比如，当年兰登·艾克（Brendan Eich）只花了10天时间就把JavaScript语言设计出来了。当然，语言跟其他软件一样，也需要不断迭代，至今JS的标准和实现仍在不停的演化。</p><p>如果我说，你也完全可以在这么短的时间内实现一门语言，甚至都不需要那么长时间，你一定会觉得我是在哗众取宠、标题党。</p><p>别急，我再补充说明一下，你马上就会认可我的说法了。这个让你一开始实现的版本，只是为了去探索计算机语言的原理，是高度简化的版本，并不要求马上能实用。你可以把它看做是一个原型系统，仅此而已，实现起来不会太复杂。</p><p>好吧，我知道你肯定还在心里打鼓：再简单的计算机语言，那也是一门语言呀，难度又能低到哪里去？</p><p>这样，先保留你的疑虑，我们进入今天的课程。<strong>今天我就要带你挑战，仅仅只用一节课时间，就实现一门超简洁的语言。</strong>我会暂时忽略很多的技术细节，带你抓住实现一门计算机语言的骨干部分，掌握其核心原理。在这节课中，你会快速获得两个技能：</p><ul>\n<li>如何通过编译器来理解某个程序；</li>\n<li>如何解释执行这个程序。</li>\n</ul><!-- [[[read_end]]] --><p>这两个点，分别是编译时的核心和运行时的核心。理解了这两个知识点，你就大致理解计算机语言是如何工作的了！</p><h2>我们的任务</h2><p>这节课，我们要让下面这个程序运行起来：</p><pre><code class=\"language-plain\">//一个函数的声明，这个函数很简单，只打印\"Hello World!\"\nfunction sayHello(){\n    println(\"Hello World!\");\n}\n//调用刚才声明的函数\nsayHello();\n</code></pre><p>这个程序做了两件事：第一件是声明了一个函数，叫做sayHello；第二件事，就是调用sayHello()函数。运行这个程序的时候，我们期待它会输出“Hello World！”。</p><p>这个程序看上去还挺像那么回事的，但其实为降低难度，我们对JavaScript/TypeScript做了极度的简化：它只支持声明函数和调用函数，在我们的sayHello()函数里，它只能调用函数。你可以调用一个自己声明的函数，如foo，也可以调用语言内置的函数，如示例中的println()。</p><p>这还不够，为了进一步降低难度，我们的编译器是从一个数组里读取程序，而不是读一个文本文件。这个数组的每一个元素是一个单词，分别是function、sayHello、左括号、右括号等等，这些单词，我们叫它Token，它们是程序的最小构成单位。注意，最后一个Token比较特殊，它叫做EOF，有时会记做$，表示程序的结尾。</p><p><img src=\"https://static001.geekbang.org/resource/image/7a/be/7aea783003f9758f40bd3efdd2de48be.jpg?wh=1920x329\" alt=\"图片\" title=\"图1：Token串（图中不同的颜色代表不同类型的Token）\n\"></p><p>好了，现在任务清楚了，那我们开始第一步，解析这个程序。</p><h2>解析这个程序</h2><p>解析，英文叫做Parse，是指读入程序，并形成一个计算机可以理解的数据结构的过程。能够完成解析工作的程序，就叫做解析器（Parser），它是编译器的组成部分之一。</p><p>那么，什么数据结构是计算机能够理解的呢？很简单，其实就是一棵树，这棵树叫做<strong>抽象语法树，英文缩写是AST（Abstract Syntax Tree）</strong>。针对我们的例子，这棵AST是下面的样子：<br>\n<img src=\"https://static001.geekbang.org/resource/image/c3/37/c3109f472253e98057f255f7dbf57c37.jpg?wh=1920x1080\" alt=\"图片\" title=\"图2：示例代码对应的AST\"></p><p>你仔细看一下这棵树，你会发现它跟我们程序想表达的思想是一样的：</p><ul>\n<li>根节点代表了整个程序；</li>\n<li>根节点有两个子节点，分别代表一个函数声明和一个函数调用语句；</li>\n<li>函数声明节点，又包含了两个子节点，一个是函数名称，一个是函数体；</li>\n<li>函数体中又包含一个函数调用语句；</li>\n<li>而函数调用语句呢，则是由函数名称和参数列表构成的；</li>\n<li>……</li>\n</ul><p>通过这样自顶向下的层层分析，你会发现这棵树确实体现了我们原来的程序想表达的意思。其实，这就跟我们自己在阅读文章的时候是一样的，我们的大脑也是把段落分解成句子，再把句子分解成主语、谓语、宾语等一个个语法单元，最终形成一棵树型的结构，我们的大脑是能够理解这种树型结构的。</p><p>总结起来，<strong>解析器的工作，就是要读取一个Token串，然后把它转换成一棵AST</strong>。</p><p>好了，知道了解析的工作目标后，我们就来实现这个解析器吧！</p><p>可是，这怎么下手呢？</p><p>你可以琢磨一下，你的大脑是如何理解这些程序，并且把它们在不知不觉之间转化成一棵树的。我们假设，人类的大脑采用了一种自顶向下的分析方式，也就是把一个大的解析任务逐步分解成小的任务，落实到解析器的实现上也是如此。</p><p>首先，我们的目的是识别Token串的特征，并把它转换成AST。我们暂时忽略细节，假设我们能够成功地完成这个解析，那么把这个解析动作写成代码，就是：</p><pre><code class=\"language-plain\">prog = parseProg()；\n</code></pre><p>我们再具体一点，看看实现parseProg()需要做什么事情。</p><p>parseProg()需要建立程序的子节点，也就是函数声明或者函数调用。我们规定一个程序可以有零到多个函数声明或函数调用。我们把这个语法规则用比较严谨的方法表达出来，是这样的：</p><pre><code class=\"language-plain\">prog = (functionDecl | functionCall)* ;\n</code></pre><p>咦？这个表达方式看上去有点熟悉呀？这个式子的格式叫做EBNF格式（扩展巴科斯范式）。你可以看到，它的左边是一个语法成份的名称，右边说的是这个语法成份是由哪些子成分构成的。这样，整个式子就构成了一条语法规则。</p><p>不过，编译原理的教科书里，有时会用产生式的格式。EBNF格式和产生式是等价的，区别是产生式不允许使用？、*和+号，而是用递归来表示多个元素的重复，用ε来表示不生成任何字符串。如果我们把上述语法规则用产生式来表示的话，相当于下面四条：</p><pre><code class=\"language-plain\">prog -&gt; statement prog\nprog -&gt; ε\nstatement -&gt; functionDecl\nstatement -&gt; functionCall\n</code></pre><p>你马上就能看出来，还是EBNF格式更简洁吧？</p><p>好了，根据这条语法规则，一个程序要么是由函数声明构成的，要么是由函数调用构成的，那么我们就把它们一一解析出来，变成prog的子节点就好了！</p><p>可是，我们如何知道接下来遇到的是函数声明还是函数调用呢？</p><p>有办法！办法就是：试试看！</p><p>什么叫试试看？就是先试试是不是函数声明。如果成功的话，解析器就会返回一棵代表函数声明的子树；如果不成功的话，解析器就会返回null，然后你可以再试试看是不是函数调用。你可能会问：就这么简单？对，就这么简单。</p><p>实现上述逻辑的代码如下：</p><pre><code class=\"language-plain\">parseProg():Prog{\n    let stmts: Statement[] = [];\n    let stmt: Statement|null|void = null;\n    while(true){  //每次循环解析一个语句\n        //尝试一下函数声明\n        stmt = this.parseFunctionDecl();\n        if (stmt != null){\n            stmts.push(stmt);  \n            continue;\n        }\n        \n        //如果前一个尝试不成功，那么再尝试一下函数调用\n        stmt = this.parseFunctionCall();\n        if (stmt != null){\n            stmts.push(stmt);  \n            continue; \n        }\n\n        //如果都没成功，那就结束\n        if (stmt == null){\n            break;\n        }\n    }\n    return new Prog(stmts);\n}\n</code></pre><p>现在我们再往下一层，看看如何解析函数声明。</p><p>函数声明包括function关键字、函数名称、一对括号和函数体。我们依然将它表达成语法规则，是这样的：</p><pre><code class=\"language-plain\">functionDecl: \"function\" Identifier \"(\" \")\"  functionBody; \n</code></pre><p>注意，在这个新的语法规则里，我们发现了“function”、“Identifier”这样的元素，这些元素是不能再展开的，我们把它们叫做终结符。你会发现，终结符都是从Token转化而来的。而像“functionBody”这些用小写字母开头的元素，还可以再继续展开，所以叫做非终结符。</p><p>那这该怎么解析呢？</p><p>还是得挨个去试。先试一下第一个Token是不是“function”，再试下第二个Token是不是一个合法的标识符，接着试第三个Token是不是左括号，依此类推就行了。</p><p>其实，在函数声明的语法规则里，像“function”、“Identifier”这些，都已经是最终的Token了，所以直接把它们从Token串中取出来就行了，其中“Identifier”变成了AST中的函数名称。</p><p>而函数声明中的另一部分，也就是函数体，是一个比较复杂的结构，所以我们将它拆出来单独定义。体现在AST中，它就是函数声明的子节点。这里，我索性把剩余的有关函数体、函数调用的语法规则都写出来。</p><pre><code class=\"language-plain\">functionBody : '{' functionCall* '}' ;\nfunctionCall : Identifier '(' parameterList? ')' ;\nparameterList : StringLiteral (',' StringLiteral)* ;\n</code></pre><p>解析上述语法规则对应的程序如下：</p><pre><code class=\"language-plain\">/**\n     * 解析函数声明\n     * 语法规则：\n     * functionDecl: \"function\" Identifier \"(\" \")\"  functionBody;\n     */\n    parseFunctionDecl():FunctionDecl|null|void{\n        let oldPos:number = this.tokenizer.position();\n        let t:Token = this.tokenizer.next();\n        if (t.kind == TokenKind.Keyword &amp;&amp; t.text == \"function\"){\n            t = this.tokenizer.next();       \n            if (t.kind == TokenKind.Identifier){\n                //读取\"(\"和\")\"\n                let t1 = this.tokenizer.next();\n                if (t1.text==\"(\"){\n                    let t2 = this.tokenizer.next();\n                    if (t2.text==\")\"){\n                        let functionBody = this.parseFunctionBody();\n                        if (functionBody != null){\n                            //如果解析成功，从这里返回\n                            return new FunctionDecl(t.text, functionBody);\n                        }\n                    }\n                    else{\n                        console.log(\"Expecting ')' in FunctionDecl, while we got a \" + t.text);\n                        return;\n                    }\n                }\n                else{\n                    console.log(\"Expecting '(' in FunctionDecl, while we got a \" + t.text);\n                    return;\n                }            \n            }\n        }\n\n        //如果解析不成功，回溯，返回null。\n        this.tokenizer.traceBack(oldPos);\n        return null;\n    }\n\n    /**\n     * 解析函数体\n     * 语法规则：\n     * functionBody : '{' functionCall* '}' ;\n     */\n    parseFunctionBody():FunctionBody|null|void{\n        let oldPos:number = this.tokenizer.position();\n        let stmts:FunctionCall[] = [];\n        let t:Token = this.tokenizer.next();\n        if(t.text == \"{\"){\n            let functionCall = this.parseFunctionCall();\n            while(functionCall != null){  //解析函数体\n                stmts.push(functionCall);\n                functionCall = this.parseFunctionCall();\n            }\n            t = this.tokenizer.next();\n            if (t.text == \"}\"){\n                return new FunctionBody(stmts);\n            }\n            else{\n                console.log(\"Expecting '}' in FunctionBody, while we got a \" + t.text);\n                return;\n            }\n        }\n        else{\n            console.log(\"Expecting '{' in FunctionBody, while we got a \" + t.text);\n            return;\n        }\n        \n        //如果解析不成功，回溯，返回null。\n        this.tokenizer.traceBack(oldPos);\n        return null;\n    }\n\n    /**\n     * 解析函数调用\n     * 语法规则：\n     * functionCall : Identifier '(' parameterList? ')' ;\n     * parameterList : StringLiteral (',' StringLiteral)* ;\n     */\n    parseFunctionCall():FunctionCall|null|void{\n        let oldPos:number = this.tokenizer.position();\n        let params:string[] = [];\n        let t:Token = this.tokenizer.next();\n        if(t.kind == TokenKind.Identifier){\n            let t1:Token = this.tokenizer.next();\n            if (t1.text == \"(\"){\n                let t2:Token = this.tokenizer.next();\n                //循环，读出所有\n                while(t2.text != \")\"){\n                    if (t2.kind == TokenKind.StringLiteral){\n                        params.push(t2.text);\n                    }\n                    else{\n                        console.log(\"Expecting parameter in FunctionCall, while we got a \" + t2.text);\n                        return;  //出错时，就不在错误处回溯了。\n                    }\n                    t2 = this.tokenizer.next();\n                    if (t2.text != \")\"){\n                        if (t2.text == \",\"){\n                            t2 = this.tokenizer.next();\n                        }\n                        else{\n                            console.log(\"Expecting a comma in FunctionCall, while we got a \" + t2.text);\n                            return;\n                        }\n                    }\n                }\n                //消化掉一个分号：;\n                t2 = this.tokenizer.next();\n                if (t2.text == \";\"){\n                    return new FunctionCall(t.text, params);\n                }\n                else{\n                    console.log(\"Expecting a comma in FunctionCall, while we got a \" + t2.text);\n                    return;\n                }\n            }\n        }\n\n        //如果解析不成功，回溯，返回null。\n        this.tokenizer.traceBack(oldPos);\n        return null;\n    }\n}\n</code></pre><p>到这里你会发现，我们做语法分析的思路很简单：</p><ul>\n<li><strong>首先，写出语法规则</strong>，比如说用EBNF格式。</li>\n<li><strong>第二，根据语法规则，分别匹配每个子元素。</strong>如果这个语法规则中用到了另一个语法规则，就像函数声明里用到了函数体，那么我们就需要递归地匹配这条语法规则。这个层层下降的匹配过程，叫做“<strong>递归下降（Recursive Descent）</strong>”，这就是我们刚刚采用的算法，Java、V8等很多编译器也都采用了这个递归下降算法。</li>\n<li><strong>第三，如果一条语法规则可能有多个展开方式</strong>，就像程序里面既可以是函数声明，也可以是函数调用，<strong>那么我们就要依次尝试去匹配</strong>。如果尝试失败，就回退，再去尝试另一个展开方式。</li>\n</ul><p>好了，你也知道了，我们刚才用到的方法就是大名鼎鼎的“递归下降算法”。当然，这是它的初级版本，会存在一些缺陷，这个我们后面会讲。不过，即使是像JDK里的Java编译器、V8的JaveScript编译器、Go语言的编译器这些成熟的编译器，采用的都是递归下降算法，所以你应该足够重视它。</p><h2>做一点简单的语义分析</h2><p>好了，现在我们已经完成了语法分析工作，并形成了AST。但是，在解释执行这个程序之前，我们还要做一点微小的工作：就是<strong>引用消解（Refrence Resolving）</strong>。</p><p>这是什么意思呢？</p><p>在我们的程序中有两处函数调用：一处是println()，我们现在把它看做内置函数就好了，而另一处，是调用我们自定义的函数sayHello()。那么<strong>引用消解，就是把函数的调用和函数的定义关联到一起</strong>，否则，程序就没法正常运行。由于我们目前的语言很简单，所以引用消解工作也很简单，你可以看看下面的参考代码：</p><pre><code class=\"language-plain\">//遍历prog中的所有语句，找到一个名称匹配的函数声明\nprivate findFunctionDecl(prog:Prog, name:string):FunctionDecl|null{\n    for(let x of prog?.stmts){\n        let functionDecl = x as FunctionDecl;\n        if (typeof functionDecl.body === 'object' &amp;&amp; \n            functionDecl.name == name){\n            return functionDecl;\n        }\n    }\n    return null;\n}\n</code></pre><p>引用消解是语义分析过程中必须要做的一项工作，其他更多的语义分析工作我们仍然可以忽略。做完了语义分析以后，AST上增加了一些信息：<br>\n<img src=\"https://static001.geekbang.org/resource/image/31/f0/3136fc4f3d74f607e0edc9454d71e6f0.jpg?wh=1920x1080\" alt=\"图片\" title=\"图3：在AST增加了引用信息，可以找到函数的定义\"><br>\n在上图中，你可以看到对sayHello()函数做调用的AST节点，指向了sayHello的函数声明节点。这样，在解释器里执行sayHello()的时候，就能找到该执行什么代码了！</p><h2>做一个简单的解释器来运行这个程序</h2><p>好了，完成好上面各项准备工作，接下来要实现解释器了。</p><p>解释器怎么运行呢？很简单，自顶向下、深度优先地遍历一下AST就行了。</p><p>具体过程是这样的：<br>\n<img src=\"https://static001.geekbang.org/resource/image/0e/ff/0e90bfdb9ec8fb4dc1866025d72d18ff.jpg?wh=1920x1080\" alt=\"图片\" title=\"图4：通过遍历AST来解释执行程序\"><br>\n第1步，我们要来访问prog节点。</p><p>第2步，接着访问prog的第一个子节点的，但这个子节点是一个函数声明，函数声明是不能直接运行的，所以此时访问这个节点不会产生任何动作。</p><p>第3步，访问prog的第二个子节点。这个子节点是一个函数调用，由于我们已经做了引用消解，我们已经知道这个函数在AST中的位置了。</p><p>第4步，我们要跳到函数定义的位置去执行这个函数，然后在第5步中执行这个函数的函数体。</p><p>第6步，我们再执行函数体的下一级节点，也就是println(“Hello World”)。这实际上是调用一个内置函数，因此我们把“Hello World”作为参数传递给内置函数就行了。</p><p>到此，程序执行完毕，输出了“Hello World”。</p><p>为了加深你的理解，我再举一个例子。</p><p>假如我们的语言现在已经支持表达式了，那么对于2+3*5这样一个表达式，解析器也会自动形成一棵AST。这时，对表达式求值的过程，也就是遍历AST的过程。</p><p><img src=\"https://static001.geekbang.org/resource/image/3c/ae/3cf0eb845e3e03f54b81a14ffe7cc9ae.jpg?wh=1920x917\" alt=\"图片\" title=\"图5：通过遍历AST来计算表达式的值（图中标号，是完全访问完毕一棵子树的顺序）\"></p><h2>课程小结</h2><p>好了，这就是我们今天的全部内容了。虽然我们做了很多的简化，但我们毕竟已经能让一个程序运行起来了。你还可以把示例程序改写一下，比如多写几个自定义的函数，多做几个函数调用，打印出调用过程，等等。</p><p>例如，在下面的示例程序中，我又新声明了一个函数bar，并在bar中调用foo，检验一下多级函数调用是否会正常运行。</p><pre><code class=\"language-plain\">function foo(){\n  println(\"in foo...\");\n}\n\nfunction bar(){\n  println(\"in bar...\");\n  foo();\n}\n\nbar();\n</code></pre><p>你看，虽然我们的程序特性很少，但毕竟能玩起来了。你只要遵守语言的特性，编写出来的任意程序都是能正确执行的，这就是计算机语言最有魅力的地方！而且，你也可以亲手实现。</p><p>我给你把这节课的要点总结一下：</p><ul>\n<li>要实现一门计算机语言，首先要有一个编译器来把程序转化成计算机可理解的数据（这里是AST），然后需要有一个解释器来执行它。</li>\n<li>编译器有很多功能，词法分析功能在这讲被我们故意跳过了。在语法分析部分，我们了解了如何用EBNF格式来表达语法规则，并初步介绍了递归下降算法；在语义分析部分，我们做了函数的引用消解。</li>\n<li>我们当前版本的解释器，是通过遍历AST来运行程序的，方便你理解原理。在后面的课程中，我们会把AST转换成更适合解释执行的中间代码（Intermediate Representation，IR），就像Java的字节码一样，然后我们再实现一个新的解释器。</li>\n</ul><p>这节课我们忽略了很多技术细节，别担心，之后的课程，我们会一一补上这些知识点，让你平滑地学到实现一门语言的所有技能。</p><h2>思考题</h2><p>我们今天的课程就到这里了，我给你布置了两个思考题来巩固下今天学习的内容。</p><p>问题1：在这节课讲述的语法规则中，我们做了一些简化，比如在函数声明的时候，我们并没有管参数。如果加上参数，你会怎样改写一下语法规则呢？另外，我们目前用的还是JavaScript的语法，如果改成TypeScript的语法，带上类型声明，语法规则又会是什么样子呢？你可以练习一下。</p><p>问题2：在今天的课程里，我们的语法分析的算法是“递归下降”算法。不知道你有没有发现，我们的程序里并没有出现函数的递归调用呀，为什么还要说它是递归的呢？</p><p>感谢你和我一起学习，如果你觉得我这节课讲得还不错，也欢迎你把它分享给更多对编程语言感兴趣的朋友。我是宫文学，我们下节课见。</p><h2>资源链接</h2><p><a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/01/play.ts\">这节课的示例代码在这里！</a></p>","neighbors":{"left":{"article_title":"课前热身｜开始学习之前我们要准备什么？","id":406073},"right":{"article_title":"02｜词法分析：识别Token也可以很简单吗？","id":406555}}},{"article_id":406555,"article_title":"02｜词法分析：识别Token也可以很简单吗？","article_content":"<p>你好，我是宫文学。</p><p>上一节课，我们用了很简单的方法就实现了语法分析。但当时，我们省略了词法分析的任务，使用了一个Token的列表作为语法分析阶段的输入，而这个Token列表呢，就是词法分析的结果。</p><p>其实，编译器的第一项工作就是词法分析，也是你实现一门计算机语言的头一项基本功。今天，我们就来补补课，学习一下怎么实现词法分析功能，词法分析也就是把程序从字符串转换成Token串的过程。</p><p>词法分析难不难呢？我们来对比一下，语法分析的结果是一棵AST树，而词法分析的结果是一个列表。直观上看，列表就要比树结构简单一些，所以你大概会猜想到，词法分析应该会更简单一些。</p><p>那么，具体来说，<strong>词法分析要用什么算法呢？词法是不是也像语法一样有规则？词法规则又是如何表达的？这一节课，我会带着你实现一个词法分析器，来帮你掌握这些技能。</strong></p><p>在这里，我有个好消息告诉你。你在上一节课学到的语法分析的技能，很多可以用在词法分析中，这会大大降低你的学习难度。好了，我们开始了。</p><h2>词法分析的任务</h2><p>你已经知道，词法分析的任务就是把程序从字符串转变成Token串，那它该怎么实现呢？我们这里先不讲具体的算法，先来看看下面这张示意图，分析一下，我们人类的大脑是如何把这个字符串断成一个个Token的？<br>\n<img src=\"https://static001.geekbang.org/resource/image/bb/9d/bb2999fdb744515f715eac0d0eb4559d.jpg?wh=1920x851\" alt=\"图片\" title=\"图1：词法分析是把字符串转变为Token串\"><br>\n你可能首先会想到，借助字符串中的空白字符（包括空格、回车、换行），把这个字符串截成一段段的，每一段作为一个Token，行不行？</p><!-- [[[read_end]]] --><p>按照这个方法，function关键字可以被单独识别出来。但是你看，我们还有一些圆括号、花括号等等，这些符号跟前一个单词之间并没有空格或回车，我们怎么把它们断开呢？</p><p>OK，你可以说，凡是遇到圆括号、花括号、加号、减号、点号等这些符号，我们把它们单独作为Token识别出来就好了。比如，对于cat.weight这样的对象属性访问的场景，点符号就是一个单独的Token。</p><p>但是，你马上会发现这个规则仍然不能处理所有的情况，例如，对于一个浮点数的字面量“3.14”的情况，点符号是浮点数的一部分，不能作为单独的Token。我稍微解释一下，这里的字面量（Literal），是指写在程序中的常量值，包括整数值、浮点数值、字符串等。</p><p>此外，还有一些难处理的情况，比如像“==”、“+=”、“-=”、“- -”、“&amp;&amp;”这些由两个或两个以上字符构成的运算符，程序处理时是要跟“=”、“+”、“-”等区分开的。</p><p>再比如，在JavaScript/TypeScript中，十六进制的字面量用“0x”开头，里面有a到f的字母，比如0x1F4；八进制的字面量用“0”开头，后面跟0~7的数字；而二进制的字面量用“0b”开头，后面跟着0或1。</p><p>所以，你可以看到，做词法分析需要考虑的情况还挺多，不是用简单的一两个规则就能解决的，我们必须寻找一种系统性的解决方法。</p><p>在这里，为了让你对词法分析的任务有更全面的了解，我梳理了各种不同的处理工作，你可以看看下面这张表：<br>\n<img src=\"https://static001.geekbang.org/resource/image/ff/c1/fff3a97687d06a8062b94fcefee726c1.jpg?wh=1920x1080\" alt=\"图片\"><br>\n那么，如何用系统性的方法进行词法分析呢？</p><p>借助这节课一开头的提示，我们试一下能否用语法分析的方法来处理词法，也就是说<strong>像做语法分析一样，我们要先用一个规则来描述每个Token的词法，然后让程序基于词法规则来做处理。</strong></p><h2>词法规则</h2><p>同语法规则一样，我们可以用正则表达式来描述词法。在这里，标识符的规则是用字母开头，后面的字符可以是字母、数字或下划线，标识符的词法规则可以写成下面这样：</p><pre><code class=\"language-plain\">Identifier: [a-zA-Z_][a-zA-Z0-9_]* ;\n</code></pre><p>实际上，JavaScript的标识符是允许使用合法的Unicode字符的，我们这里做了简化。</p><p>看上去，词法规则跟上一节学过的语法规则没什么不同嘛，只不过词法的构成要素是字符，而语法的构成要素是Token。</p><p>表面上是这样，其实这里还是有一点不同的。实际上，词法规则使用的是正则文法（Formal Grammar），而语法规则使用的是上下文无关文法（Context-free Gammar，CFG）。正则文法是上下文无关文法的一个子集，至于对这两者差别的深入分析，我们还是放到后面的课上，这里我们先专注于完成词法分析功能。</p><p>我们再写一下前面讨论过的浮点数字面量的词法规则，这里同样是精简的版本，省略了指数部分、二进制、八进制以及十六进制的内容：</p><pre><code class=\"language-plain\">DecimalLiteral: IntegerLiteral '.' [0-9]* \n              | '.' [0-9]+\n              | IntegerLiteral \n              ;\nIntegerLiteral: '0' | [1-9] [0-9]* ;\n</code></pre><p>对于上面这个DecimalLiteral词法规则，我们总结一下有这几个特点：</p><ul>\n<li>一个合法的浮点数可以是好几种格式，3.14、.14、3等等都行；</li>\n<li>整数部分要么只有一个0，要么是1~9开头的数字；</li>\n<li>可以没有小数点前的整数部分，但这时候小数点后至少要有一位数字，否则这就只剩了一个点号了；</li>\n<li>也可以完全没有小数部分，只有整数部分。</li>\n</ul><p>好了，目前我们已经知道如何用词法规则来描述不同的Token了。接下来，我们要做的就是用程序实现这些词法规则，然后生成Token。</p><h2>用程序实现词法分析</h2><p>上节课我们在讲语法分析的时候，提到了递归下降算法。这个算法比较让人喜欢的一点是，程序结构基本上就是对语法规则的一对一翻译。</p><p>其实词法分析程序也是一样的，比如我们要识别一个浮点数，我们照样可以根据上述DecimalLiteral的几条规则一条条地匹配过去。</p><p>首先，我们匹配第一条规则，就是既有整数部分又有小数部分的情况；如果匹配不上，就尝试第二条规则，也就是以小数点开头的情况；如果还匹配不上，就尝试第三条，即只有整数部分的情况。只要这三条匹配里有一条成功，就意味着我们匹配浮点数成功。</p><p>我们来看看具体的程序实现：</p><pre><code class=\"language-plain\">if (this.isDigit(ch)){\n    this.stream.next();\n    let ch1 = this.stream.peek();\n    let literal:string = '';\n    //首先解析整数部分\n    if(ch == '0'){//暂不支持八进制、二进制、十六进制\n        if (!(ch1&gt;='1' &amp;&amp; ch1&lt;='9')){\n            literal = '0'; //整数部分只有0\n        }\n        else {报编译错误}\n    }\n    else if(ch&gt;='1' &amp;&amp; ch&lt;='9'){\n        literal += ch;\n        while(this.isDigit(ch1)){\n            ch = this.stream.next();\n            literal += ch;\n            ch1 = this.stream.peek();\n        }\n    }\n    //解析小数部分\n    if (ch1 == '.'){\n        literal += '.';\n        this.stream.next();\n        ch1 = this.stream.peek();\n        while(this.isDigit(ch1)){\n            ch = this.stream.next();\n            literal += ch;\n            ch1 = this.stream.peek();\n        }\n        return {kind:TokenKind.DecimalLiteral, text:literal};\n    }\n    else{\n        //返回一个整型直面量\n        return {kind:TokenKind.IntegerLiteral, text:literal};\n    }\n}\n//解析以.开头的小数，要求后面至少有一个数字\nelse if (ch == '.'){\n    this.stream.next();\n    let ch1 = this.stream.peek();\n    if (this.isDigit(ch1)){\n        //小数字面量\n        let literal = '.';\n        while(this.isDigit(ch1)){\n            ch = this.stream.next();\n            literal += ch;\n            ch1 = this.stream.peek();\n        }\n        return {kind:TokenKind.DecimalLiteral, text:literal};\n    }\n    else{\n        ...\n    }\n}\n</code></pre><p>如果浮点数匹配不成功呢？也没关系。其实计算机语言的词法规则分为很多条，有匹配浮点数的，也有匹配标识符的，还有匹配运算符的，等等。我们可以把这些词法规则依次匹配过去。只要某个规则匹配成功了，我们就算识别出了一种Token。</p><p>这么看来，<strong>词法分析的过程，就是依次匹配不同的词法规则的过程</strong>。匹配成功以后，就把这个Token从字符串中截下来，再去尝试匹配下一个Token。</p><p>这里有两个细节你要注意一下：一是当扫描到注释的时候，直接去掉，并不生成Token；第二是对于空白字符的处理，也是一样，直接去掉。所以整体的处理逻辑如下：</p><pre><code class=\"language-plain\">while (!EOF){\n  跳过空白字符；\n  如果是注释，丢弃掉；\n  尝试匹配词法规则1；\n  不成功，则回溯，尝试匹配词法规则2；\n  不成功，则回溯，尝试匹配词法规则3；\n  ...\n  直到成功匹配一个词法规则；\n}\n</code></pre><p>你根据这个逻辑，就可以写出整个词法分析程序了！</p><p>不过，你可能很快就发现了一个问题，我们的词法规则很多，可能有几十条甚至上百条。如果每次都从头开始依次尝试，会造成很多浪费，词法分析的性能也会很低，那我们有没有什么办法提速呢？</p><p>接下来，我们就把算法优化一下。</p><h2>有限自动机：提升词法分析性能</h2><p>怎么优化呢？你可能马上会想到一个好办法：虽然词法规则很多，但大部分Token都可以通过开头的第一个字符区分开。</p><ul>\n<li>如果第一个字符是-号，那么只可能是三种Token：- -，-=和-；</li>\n<li>如果第一个字符是一个字母，那么只可能是标识符或各种关键字；</li>\n<li>如果第一个字符是0，那么必然是十六进制字面量、八进制字面量或者二进制字面量。</li>\n</ul><p>你看，通过预读一个字符，程序可以马上缩小选择范围，使得性能大大提升。</p><p>尝到甜头以后，我们马上可以想到，如果需要的话，能不能再继续预读第二个字符，进一步确定是哪个Token呢？</p><p>当然是可以的。比如，对于- -、-=和-这三个Token，我们可以再往下预读一个字符。如果是-号，那么就收获一个- -Token；如果是=，那么就收获一个-=Token；除了这两种之外，后面不管是什么字符，我们都把-号单独作为一个Token提取出来。</p><p>我们把这个判断过程画成一个状态迁移图，这个状态迁移图我们叫做一个有限自动机。<br>\n<img src=\"https://static001.geekbang.org/resource/image/15/9f/15f7d80cf68cd903df93e5f15128ca9f.jpg?wh=1920x1027\" alt=\"图片\" title=\"图2：解析-、- -和==三种Token的有限自动机\"><br>\n恭喜你，到这里你已经在不知不觉间，实现出了教科书级的方法，也就是通过有限自动机（Finite-State Automata，FSA）来做词法分析了。</p><p>有限自动机可以分为两种。如果一个有限自动机针对每个输入，都会发生一次确定的迁移，这种有限自动机就被叫做确定性有限自动机（Determinisitic Finite-State Automata, DFA）。</p><p>与之对应的，是另一种有限自动机，叫做非确定性的有限自动机（Non-deterministic Finite-State Automata，NFA）。它在某些状态下，针对一个输入可能会迁移到不止一个状态，或者在没有任何输入的情况下，也会从一个状态迁移到另一个状态。</p><p>不过，任何一个NFA，都可以通过一个算法转换成DFA，这个算法你可以参见<a href=\"https://time.geekbang.org/column/article/137286\">《编译原理之美》</a>中的算法篇。</p><p>言归正传，我们刚才已经画出了能识别三种Token的有限自动机，我们还可以把这个有限自动机扩大，像下图一样增加对多行注释、/、/=、标识符、关键字和空白字符的处理能力。<br>\n<img src=\"https://static001.geekbang.org/resource/image/c3/16/c30a3db73cc926f9086d54cc4db99c16.jpg?wh=1920x1080\" alt=\"图片\" title=\"图3：增加了处理能力的有限自动机\"><br>\n你还可以继续扩展这个图，直到它能够提取所有的Token为止。有了这个大图之后，你就可以照着这个图写程序了。我这里给出了一个程序片段，供你参考。</p><pre><code class=\"language-plain\">//从字符串流中获取一个新Token。\nprivate getAToken():Token{\n    this.skipWhiteSpaces();\n    if (this.stream.eof()){\n        return {kind:TokenKind.EOF, text:\"\"};\n    }\n    else{\n        //预读一个Token\n        let ch:string = this.stream.peek();\n        //处理标识符（包含关键字）\n        if (this.isLetter(ch) || ch == '_'){\n            return this.parseIdentifer();\n        }\n        //处理字符串字面量\n        else if (ch == '\"'){\n            return this.parseStringLiteral();\n        }\n        else if (ch == '(' || ch == ')' || ch == '{' || ch == '}' || ch == '[' || ch == ']' || \n                 ch == ',' || ch == ';' || ch == ':' || ch == '?' || ch == '@'){\n            this.stream.next();\n            return {kind:TokenKind.Seperator,text:ch};\n        }\n        //处理多行注释、/、/=\n        else if (ch == '/'){\n            this.stream.next();\n            let ch1 = this.stream.peek();\n            if (ch1 == '*'){\n                this.skipMultipleLineComments();\n                return this.getAToken();\n            }\n            else if (ch1 == '/'){\n                this.skipSingleLineComment();\n                return this.getAToken();\n            }\n            else if (ch1 == '='){\n                this.stream.next();\n                return {kind:TokenKind.Operator,text:'/='};\n            }\n            else{\n                return {kind:TokenKind.Operator,text:'/'};\n            }\n        }\n        //处理+、+=、++\n        else if (ch == '+'){\n            this.stream.next();\n            let ch1 = this.stream.peek();\n            if (ch1 == '+'){\n                this.stream.next();\n                return {kind:TokenKind.Operator,text:'++'};\n            }else if (ch1 == '='){\n                this.stream.next();\n                return {kind:TokenKind.Operator,text:'+='};\n            }\n            else{\n                return {kind:TokenKind.Operator,text:'+'};\n            }\n        }\n        //省略了更多的情况……\n        else{ \n            //暂时去掉不能识别的字符\n            console.log(\"Unrecognized pattern meeting ': \" +ch+\"', at\" + this.stream.line + \" col: \" + this.stream.col);\n            this.stream.next();\n            return this.getAToken();\n        }\n    }\n}\n</code></pre><p>如果你仔细看上面的图3，你会发现，我的标识符和关键字都是统一处理的，因为标识符的词法其实已经包含了关键字。<strong>做词法分析的一个最佳实践，就是先把标识符和关键字统一提取出来，然后再从里面把关键字单独提取出来就行了。</strong></p><p>好了，前面我们通过“预读”的思路，升级了词法分析的算法，使之能够正确地提取出所有的Token。在这个过程中，我们已经不知不觉摸索出了编译原理教科书中都会讲的有限自动机算法。</p><p>可是这还没完。你可能会想到，采用有限自动机的情况下，程序每次都可以根据下一个输入，准确地确定接下来应该执行的逻辑，完全规避了回溯的问题。那我们是不是也可以用这个思路来提升语法分析的效率呢？好想法，我们现在就来试试看。</p><h2>思路迁移：提升语法分析效率</h2><p>我们先来回顾一下在语法分析中，回溯是怎么发生的，以及它会造成怎样的性能上的损失。</p><p>在语法分析的递归下降算法中，当一个语法规则由多个子规则构成时，我们采用的是挨个试的方法来进行匹配。比如，首先试一下某语句是否是一个函数声明，接着试一下它是否是一个函数调用。</p><p>在匹配某个语法规则失败的时候，我们需要把已经消化掉的Token还回去，恢复到没做匹配之前的状态，这个过程叫做回溯（Backtracking）。</p><p>由于整个算法是递归下降的，某一级的匹配失败也可能会导致上一级的失败，从而导致逐级回溯。比如，我们用下面的表达式的语法规则去匹配2+3*5的时候，就会发生逐级回溯的现象：</p><pre><code class=\"language-plain\">//加法表达式，可以是一个乘法表达式，或者是一个乘法表达式+另一个加法表达式\nadd : mul \n    | mul '+' add\n    ;\n//乘法表达式，可以是一个基础表达式，或者是一个基本表达式*另一个乘法表达式    \nmul : pri \n    | pri '*' mul \n    ;\n//基础表达式，可以是一个整形字面量，或者是括号括起来的一个加法表达式\npri : IntLiteral \n    | '(' add ')'\n    ;\n</code></pre><p>匹配过程是这样的：</p><pre><code class=\"language-plain\">2+3*5符合add规则吗？\n  -&gt;2+3*5符合mul规则吗？\n    -&gt;2+3*5符合pri规则吗？\n      -&gt;2+3*5符合IntLiteral吗？不符合，因为它显然不只是一个整数常量\n      -&gt;2+3*5符合'('add')'规则吗？不符合，因为第一个Token不是'('\n    -&gt;回溯到mul，去尝试第二个选项\n    -&gt;2+3*5符合pri '*' mul吗？\n      -&gt;匹配一个pri\n        -&gt;匹配一个IntLiteral，成功\n      -&gt;再匹配一个'*'，失败，遇到的是'+'\n  -&gt;回溯到add，去尝试第二个选项\n  -&gt;2+3*5符合mul '+' add吗？\n    -&gt;匹配一个mul\n      -&gt;匹配一个pri\n        -&gt;匹配一个IntLiteral,成功\n    -&gt;匹配一个'+'，成功\n    -&gt;匹配一个add\n    接下来，又回遇到一开头使用add规则的那种回溯的情形\n    ...        \n</code></pre><p>在这个例子中，我们还只是采用了3级嵌套的语法，如果语法的层次更多的话，由回溯造成的无用功就更多。从这里，你应该能体会到回溯的危害了。</p><p>不过，受到词法分析中预读字符的启发，我们在语法分析中也可以通过预读一个Token可以减少尝试的次数。比如，如果第一个Token是“function”关键字，那肯定是要匹配一个函数声明，这就不用考虑其他选项了，这不就可以提高性能了吗？</p><p>确实是这样的。在语法分析中，我们经常可以遇到有多个语法规则可供选择的情况。比如，在上一节的例子中，statement就有两种可能性，这还是简化的情况；在完整的语法规则中，statement有20多种可能性，像if语句、各种循环语句、各种声明等，都属于statement。在这种情况下，预读所带来的性能改善就非常可观了！</p><p><img src=\"https://static001.geekbang.org/resource/image/36/e4/364c5f9f20b8b5d04396ef92409fbae4.png?wh=616x1338\" alt=\"图片\"></p><p>为了通过预读实现性能的优化，我们需要知道每个语法规则开头的Token都可能有哪些。比如，if语句永远是以if开头的，这个比较简单。但有的语法规则就比较复杂一些，比如表达式语句，它本身就是由很多子规则构成的，所以其第一个Token有很多可能：</p><pre><code class=\"language-plain\">++i;   //第一个Token是++\nfoo(); //第一个Token是一个标识符\n\"Hello World\"; //第一个Token是一个字面量 \n(2+3); //第一个Token是括号       \n</code></pre><p>这怎么办呢？也好办。我们把表达式语句所有可能出现的第一个Token的集合，叫做First集合。</p><p>对于statement来说，我们可以求出每个子规则的First集合，只要所有的这些集合都没有交集，那么我们总是可以通过预读一个Token来决定采用哪条子规则的。</p><p>如果整个语法规则都只需要预读一个Token就可以实现，那么我们把这个语法规则叫做LL(1)文法，而我们刚才说到的通过预读来唯一确定分支路径的算法，就是LL(1)算法，这个算法避免了由于回溯而导致的性能开销。</p><p>不过，对于LL两个字母的含义，我们留到下节课再讲，你现在只要记住这种算法名称叫做LL算法就好了。LL(1)中的1，意思是需要预读一个Token。</p><p>另外，LL算法还有一种特殊情况需要处理，比如语句块中可以有一个语句列表（statementLIst），也可能是一个空语句块：</p><pre><code class=\"language-plain\">block\n    : '{' statementList? '}'\n    ;\nstatementList\n    : statement+\n    ;\n</code></pre><p>我们在解析语句块的时候，取出了“{”以后，后面可能是一个语句列表（statementList），也有可能直接遇到“}”，这就意味着这是一个空语句块，也就是“{}”。</p><p>那这个时候呢，我们在程序里要多加一个判断：如果预读的Token在statementList的First集合里，那么就要去解析一个statementList；而如果遇到的是“}”，那就没必要了。</p><p>由于这个“}”是出现在statemtnList之后的，我们可以说“}”属于statementList的Follow集合。我们根据statemntList的First和Follow集合，就能解决语法规则中statementList后面跟一个?号的情况。除了?号，在处理*号和+号的时候，也都会需要用到Follow集合。</p><p>总结起来，完整的LL算法，需要用到每个语法规则的First和Follow集合，来确定我们应该采用哪个子规则的分支，从而避免回溯，实现性能上的提升。</p><h2>课程小结</h2><p>好了，这一节课就先到这里了。这节课，我们不仅学到了如何做词法分析，还把语法分析的技能又提升了一级。</p><p>总结一下，词法分析也可以使用EBNF来描述词法规则，并且也可以使用类似递归下降的算法。不过，通过预读字符，我们可以降低尝试的次数。最终，通过构造一个有限自动机，我们可以对每一个输入都做一个确定的状态转移，从而高效地实现词法分析。</p><p>接着，我们把“预读”的思维放到了语法分析中的递归下降算法上，又介绍了First集合和Follow集合的概念，借助这两个集合，我们不需要回溯，也能够实现语法分析，从而大大提高了语法分析的效率。</p><h2>思考题</h2><p>最后我给你出了一个思考题。你看，我们在程序里需要处理负数字面量，比如-3。你认为，负数的负号应该是作为运算符来处理，分别解析成一个-号和一个字面量3，还是把-3整体作为一个字面量识别出来呢？为什么？</p><p>欢迎你和我一起学习编程语言，也欢迎你将这门课分享给更多对编程语言感兴趣的朋友。我是宫文学，我们下节课见。</p><h2>资源链接</h2><p><a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/02/play.ts\">这节课的示例代码在这里！</a></p>","neighbors":{"left":{"article_title":"01｜实现一门超简单的语言最快需要多久？","id":406179},"right":{"article_title":"03｜支持表达式：解析表达式和解析语句有什么不同？","id":407295}}},{"article_id":407295,"article_title":"03｜支持表达式：解析表达式和解析语句有什么不同？","article_content":"<p>你好，我是宫文学。</p><p>到目前为止，我们已经学习了一些语法分析的算法。不过，我们主要是分析了如何来解析语句，比如函数声明、函数调用，没有把重点放在解析表达式上。</p><p>其实我是刻意为之的，故意把表达式的解析往后推迟一下。原因是表达式解析，特别是像“2+3*5”这样的看似特别简单的二元运算的表达式解析，涉及的语法分析技术反而是比较复杂的。所以，从循序渐进的角度来说，我们要把它们放在后面。</p><p>表达式的解析复杂在哪里呢？是这样，我们在解析二元表达式的时候，会遇到递归下降算法最大的短板，也就是不支持左递归的文法。如果遇到左递归的文法，会出现无限循环的情况。</p><p><strong>在这一节里，我会给你分析这种左递归的困境，借此加深你对递归下降算法运算过程的理解。</strong></p><p>同时，我也要给出避免左递归问题的方法。这里，我没有采用教科书上经常推荐的改写文法的方法，而是使用了业界实际编译器中更常用的算法：<strong>运算符优先级解析器（Operator-precedence parser）</strong>。JDK的Java编译器、V8的JaveScript编译器和Go语言的GC编译器，都毫无例外地采用了这个算法，所以这个算法非常值得我们掌握。</p><p>好了，那我们首先来了解一下用递归下降算法解析算术表达式会出现的这个左递归问题。</p><!-- [[[read_end]]] --><h2>左递归问题</h2><p>我们先给出一种简化的加法表达式的语法规则：</p><pre><code class=\"language-plain\">add : add '+' IntLiteral\n    | IntLiteral\n    ;\n</code></pre><p>对这个规则的解读是这样的：一个加法表达式，它要么是一个整型字面量，要么是另一个加法表达式再加上一个整型字面量。在这个规则下，2、2+3、2+3+4都是合格的加法表达式。</p><p>那如果用递归下降算法去解析2+3，我们会采用“add ‘+’ IntLiteral”的规则。而这个规则呢，又要求匹配出一个add来，从而算法又会递归地再次调用“add ‘+’ IntLiteral”规则，导致无限递归下去。</p><pre><code class=\"language-plain\">2+3是不是一个add表达式？\n  -&gt;先匹配出一个add表达式来，再是+号，再是整型字面量\n    -&gt;先匹配出一个add表达式来，再是+号，再是整型字面量\n      -&gt;先匹配出一个add表达式来，再是+号，再是整型字面量\n        -&gt;无限递归...\n</code></pre><p>这就是著名的<strong>左递归问题</strong>，是递归下降算法或者LL算法都无法解决的。</p><p>你可能会问，如果把产生式的写法换一下，把add放在后面，不就会避免左递归了吗？</p><pre><code class=\"language-plain\">add : IntLiteral '+' add\n    | IntLiteral\n    ;\n</code></pre><p>这个也是不行的，因为这样会导致运算的结合性出错。如果执意按照这个语法解析，解析2+3+4这个表达式所形成的AST会是右结合的：</p><p><img src=\"https://static001.geekbang.org/resource/image/80/f1/8073e5cbae54c025db36a0ca7f6593f1.jpg?wh=1920x883\" alt=\"图片\" title=\"图1：基于右递归语法会生成右结合的AST\"></p><p>你会看到，基于使用右递归文法生成的AST，实际是先计算3+4，再跟2相加。这违背了加法运算的结合性的规定。正确的运算顺序，应该是先计算2+3，然后再加上4，是左结合，对应的AST应该是右边的那个。这种结合性的错误，看上去对于加法影响不大，但如果换成减法或者除法，那计算结果就完全错误了。</p><p>好了，现在你已经理解了左递归问题了。那我们要如何解决这个问题呢？一个可行的解决方法就是改写文法，并且要在解析算法上做一些特殊的处理，你可以参考《编译原理之美》课程<a href=\"https://time.geekbang.org/column/article/120388\">04讲</a>。除了改写文法的方法以外，还有一些研究者提出了其他一些算法，也能解决左递归问题。</p><p>不过，针对二元表达式的解析，今天我要采用的是被实际编译器广泛采用的<strong>运算符优先级算法</strong>。</p><h2>运算符优先级算法</h2><p>这是个怎么样的算法呢？我想先用简单的方式帮你理解运算符优先级算法的原理，然后再一步步深化。</p><p>在<a href=\"https://time.geekbang.org/column/article/406179\">01讲</a>介绍递归下降算法的时候，我提到，它对应的是人类的一种思维方式，也就是从顶向下逐步分解。但人类还有另一种思维方式：自底向上逐步归纳。<strong>而运算符优先级算法，对应的就是自底向上的一种思维方式。</strong></p><p>首先我们来看2+3+4这个表达式，如果我们用自底向上归纳的思路做语法分析是怎么样一个思考过程呢？</p><p>第1步，首先看到2。你心里想，这里有一个整数了，那它是不是一个算术表达式的组成部分呀？是一个加法表达式的，还是乘法表达式的一部分呢？我们再往下看一看就知道。</p><p>第2步，看到一个+号。噢，你说，原来是一个加法表达式呀。这时候，我们知道，2肯定是要参与加法运算的，所以是加法的左子树。但加法后面可以跟很多东西的，比如另一个整数，或者是一个乘法表达式什么的，都有可能。那我们继续向下看。<br>\n<img src=\"https://static001.geekbang.org/resource/image/ed/e8/edb3bb5ee38d31ace0e8b261e48c35e8.jpg?wh=1309x889\" alt=\"图片\" title=\"图2：第2步时，2是肯定与+号结合的\"><br>\n第3步，看到整数3。奥，你心里想，原来是2+3呀。那我现在根据这三个Token是不是可以先凑出一棵AST的子树来呢？先等一等，我们现在还不知道3后面跟的是什么。</p><p>如果3后面跟的是+号或者-号，那没问题，3是先参与前面这个+号的计算，再把2+3的结果一起，去参与后面的计算的。</p><p>但如果3后面遇到的是 * 号呢？那么3就要先参与乘法运算，计算完的才参与前面的加法的。这两个不同的计算顺序，导致AST的结构是不一样的，<strong>而影响AST结构的，其实就是3前后的两个运算符的优先级。</strong><br>\n<img src=\"https://static001.geekbang.org/resource/image/b0/38/b060918091c30e02e59057810564b238.jpg?wh=1920x1049\" alt=\"图片\" title=\"图3：根据第4个Token的优先级，3会与不同的运算符结合\"><br>\n第4步，看到第2个+号。这个时候，你心里知道了，原来3后面的运算符的优先级跟前面的是一样的呀，那么按照结合性的规定，应该先算前面的加法，再算后面的加法，所以3应该跟前面的2和+号一起凑成一个AST子树。并且，这棵子树会作为一个稳定的单元，参与后面的AST的构建。<br>\n<img src=\"https://static001.geekbang.org/resource/image/3b/7d/3b7711c5539fb426c4862a7d59d45d7d.jpg?wh=1653x956\" alt=\"图片\" title=\"图4：2+3对应的AST子树已经稳定，不会被拆散了\"><br>\n第5步，看到整数4。现在的情况跟第3步是一样的，我们不知道4后面跟着的是什么。如果4后面跟着一个 * 号，那么4还要先参与后面的计算，然后再跟前面这一堆做加法。如果4后面也是一个加法运算符，那4就要先参与前面的计算，4在AST中的位置也就会变得确定。<br>\n<img src=\"https://static001.geekbang.org/resource/image/15/cd/15c1yyb8bc281591f4ff3c218b8e09cd.jpg?wh=1920x1080\" alt=\"图片\" title=\"图5：根据第6个Token的运算符的优先级，AST结构会不同\"><br>\n第6步，再往下看，发现后面的Token既不是+号，也不是 * 号，而是EOF，也就是Token串的结尾。这样的话，整个AST就可以确定下来了。<br>\n<img src=\"https://static001.geekbang.org/resource/image/75/3e/75824d0b58d460b6a3f725166635703e.jpg?wh=1529x806\" alt=\"图片\" title=\"图6：遇到EOF后，解析结束\"><br>\n好了，这是一个比较简单的算法运行的场景。你可以多读几遍，借此找找自底向上分析的直观感觉。</p><p>接下来，我们再换一个任务，分析一下2+3*5。你会发现，跟前一个例子相比，一直到第5步的时候，也就是读入了5以后，仍然没有形成一棵稳定的AST子树：<br>\n<img src=\"https://static001.geekbang.org/resource/image/34/83/34d19dac3da05f25c6061657be0c3683.jpg?wh=1398x846\" alt=\"图片\" title=\"图7：第5步时的AST结构\"><br>\n这是为什么呢？</p><p>因为根据5后面读入的Token的不同，形成的AST的结构会有很大的区别。这里我们展示3种情形：</p><p><img src=\"https://static001.geekbang.org/resource/image/6e/98/6ecc0002a5fe5d76d95153eb6c642298.jpg?wh=1920x1080\" alt=\"图片\" title=\"图8：AST的结构取决于第6个Token的运算符优先级\"></p><p><strong>情形1，第6个Token是+号</strong>：它的优先级不高于最后一个运算符 * 号，所以3 * 5这棵子树的结构就是确定的；进一步看，它也不高于第一个运算符的优先级，所以整个2+3 * 5这棵子树的结构都可以确定下来，并且肯定是最后一个+号的左子树。</p><p><strong>情形2，第6个Token是 * 号</strong>：这时候它的优先级仍然不高于最后一个运算符 * 号，所以3 * 5这棵子树的结构也可以确定下来，并成为新的 * 号的左子树。</p><p><strong>情形3，如果第6个Token是 ** 号</strong>：也就是做幂运算，那么5就会首先参与幂运算，而不是参与前面的乘法运算。</p><p>当然，还有最后一种情形，就是<strong>第六个Token是EOF</strong>：这会跟第一种情形相似，形成一棵确定的AST。</p><p>好了，这就是对第二个例子的分析。它比第一个例子要复杂一些，也能让你对运算符优先级算法的理解更深化。</p><p>目前我们的表达式，用到了两个优先级的运算符。你还可以增加更多的优先级进来，比如“2+3 * 5&gt;10”这个关系表达式，有3个优先级；“2+3 * 5&gt;10 &amp;&amp; ture”是一个逻辑表达式，有4个优先级。</p><p>那么怎么把它实现成算法呢？其实我在上面的图里已经有所铺垫。在每个图里，我都画了两个工作区，也就是两个栈。一个栈用来放运算符，一个栈用来放待装配的AST片段。</p><p>算法的设计也很简单，每次新取出一个运算符的时候，都跟栈顶的运算符做比较。如果新的运算符的优先级高于栈顶的运算符，就把该运算符继续压栈；否则，就从栈里弹出所存的运算符，并把它跟AST片段栈中的元素组合，变成一棵新的AST子树，重新压入AST片段栈。怎么样，很简单吧？</p><p>从上面的描述中，你还能得出一个推论：<strong>运算符栈里的元素，总是一个比一个的优先级高</strong>。</p><p>具体实现算法的时候，可以按照刚才描述的逻辑，用两个栈作为工作区，来实现解析。不过，你可能知道，基于栈的算法往往有等价的递归算法，而且递归算法会更简洁。这里我把等价的递归算法写出来。你可以用这个算法把前面的两个例子推演一遍，看看它们为什么是等价的。</p><pre><code class=\"language-plain\">/**\n * 解析一个二元表达式，形成一棵AST子树，其根节点的优先级不超过prec\n */\nparseBinary(prec:number):Expression|null{\n    // 首先解析一个基础表达式，作为左子节点\n    let exp1 = this.parsePrimary();\n    if (exp1 != null){\n        //预读运算符\n        let t = this.scanner.peek();\n        //获取运算符的优先级\n        let tprec = this.getPrec(t.text);\n        //只要优先级比当前要求的优先级大\n        while (t.kind == TokenKind.Operator &amp;&amp;  tprec &gt; prec){\n            this.scanner.next();  //跳过运算符\n            //针对优先级更高的运算符，获取一棵AST子树\n            let exp2 = this.parseBinary(tprec);\n            if (exp2 != null){\n                //创建一棵新的AST，把刚刚获取的AST子树作为右子树\n                let exp:Binary = new Binary(t.text, exp1, exp2);\n                exp1 = exp;\n                t = this.scanner.peek()\n                tprec = this.getPrec(t.text);\n            }\n            else{//报编译错误}\n        }\n        return exp1;\n    }\n    else{//报编译错误}\n}\n</code></pre><p>在实际的编译器中，有的采用的是基于栈的算法，如JDK（以JDK14为例）；有的采用的是递归算法，如Go语言编译器（以1.14.2版本为例）。你可以根据自己的喜好采用。</p><p>注意，我们这节课只讨论了二元运算。而一元运算，比如++i，或i++，用我们之前<a href=\"https://time.geekbang.org/column/article/406555\">02讲</a>中讲过的LL算法已经能够解决，你再去复习就好了。</p><p>掌握了运算符优先级算法以后，我们语法解析器实际上就混合了两种算法，主体是用LL算法，能够解析语句等各种成分；唯独留下二元表达式，用运算符优先级算法来实现。这也是像Java、V8、Go语言等这些编译器采用的较为成熟的实现方法。</p><p>在完成了这节课的主要任务之后，我再基于运算符优先级算法，把自底向上算法的知识面给你稍微扩展一下，这也让你能够基于更大的背景来理解运算符优先级算法。</p><h2>了解LR算法</h2><p>前面也说了，我们今天介绍的运算符优先级算法，属于自底向上的算法。而自底向上的算法，除了运算符优先级算法之外，最著名的就是LR算法家族。LR算法在工作的时候和运算符优先级算法一样，都是采用一个工作区来组装AST的片段。其中读取Token的过程叫做Shift，也就是移进；把工作区里的Token组装成AST片段的过程叫做Reduce，也就是规约。所以，这种特点的算法又被叫做移进-规约算法。</p><p>说到LR，你会想起上一节课，我还有一个名词没有给你展开介绍，就是LL。那在这里，我结合LR一起给你解释一下。</p><p><strong>LL是中的第一个L是“Left-to-right” ”的意思，代表从左向右处理输入的字符串；第二个 L，是“Left-most Derivation”的意思，也就是最左推导。</strong></p><p>那什么是最左推导呢？就是对于语法规则而言，我们每次总展开最左边的非终结符，之后再处理右边的非终结符。</p><p>我们还是拿简化版的加法计算的文法做例子。为了便于推导，我这次采用了产生式的写法。此文法要求加法表达式必须用括号括起来，这样就是一个合格的LL文法，避免了左递归：</p><pre><code class=\"language-plain\">add -&gt; (add + add)   \nadd -&gt; IntLiteral\n</code></pre><p>基于这个规则，如果要推导出“((2+3)+4)”这个串，推导顺序是：</p><pre><code class=\"language-plain\">add -&gt; (add + add）   //采用第一个产生式展开\n    //展开最左边的元素，仍然采用第一个产生式\n    -&gt; ((add + add)+add) \n    //从左到右依次展开每个add，采用第二个产生式\n    -&gt; ((IntLiteral + add) + add)\n    -&gt; ((IntLiteral + IntLiteral) + add)\n    -&gt; ((IntLiteral + IntLiteral) + IntLiteral)\n</code></pre><p>理解了LL的意思，那么LR的意思你大概也能猜出来了。第一个字母L仍然是“Left-to-right”的意思，而第二字母R的意思是“Right-most Derivation”，也就是最右推导。你可以把上面的例子用最右推导来试一下其展开过程。</p><p>而LR算法的实际执行过程，是最右推导过程的逆过程。也就是从((IntLiteral + IntLiteral) + IntLiteral)一步步的反向做规约，最后规约成一个add非终结符的过程。</p><p>如果你想了解LR算法的细节，可以看看《编译原理之美》的<a href=\"https://time.geekbang.org/column/article/139628\">18讲</a>。</p><h2>课程小结</h2><p>今天这节课，我们借助解析二元表达式的任务，首先介绍了递归下降算法的一个短板，就是不能处理左递归语法。</p><p>接着，我们介绍了业界编译器为解决二元表达式的解析问题而普遍采用的一个算法，也就是运算符优先级算法。我希望你能像这节课里示范的一样，去推导解析二元表达式的过程，从而帮助你建立直觉认知。在建立了这种直觉认知以后，写成算法就不是难事了。借此，你也能触摸到所有自底向上的算法的思维方式，比如LR算法家族。</p><p>最后，我花了很小的篇幅，介绍了LR和LL这两个词汇的准确含义。再次强调一下，我们这门课没有专门花精力追求理论方面的全面性，而是更重视最佳实现技术。</p><h2>思考题</h2><p>在这节课中，我们提到了加减乘除等运算是左结合的。那么有没有右结合的运算呢？对于右结合的运算，我们应该如何实现呢？说说你的想法。你也可以看看我们本节的示例代码，看看跟你的想法是否一致。</p><p>欢迎你和我一起学习，如果你觉得这节课讲得还不错，也欢迎分享给更多感兴趣的朋友。我是宫文学，我们下节课见。</p>","neighbors":{"left":{"article_title":"02｜词法分析：识别Token也可以很简单吗？","id":406555},"right":{"article_title":"04｜如何让我们的语言支持变量和类型？","id":407731}}},{"article_id":407731,"article_title":"04｜如何让我们的语言支持变量和类型？","article_content":"<p>你好，我是宫文学。</p><p>到目前为止，我们的语言已经能够处理语句，也能够处理表达式，并且都能够解释执行了。不过，我们目前程序能够处理的数据，还都只是字面量而已。接下来，我们要增加一个重要的能力：<strong>支持变量</strong>。</p><p>在程序中声明变量、对变量赋值、基于变量进行计算，是计算机语言的基本功能。只有支持了变量，我们才能实现那些更加强大的功能，比如，你可以用程序写一个计算物体下落的速度和位置，如何随时间变化的公式。这里的时间就是变量，通过给时间变量赋予不同的值，我们可以知道任意时间的物体速度和位置。</p><p>这一节，我就带你让我们手头上的语言能够支持变量。在这个过程中，你还会掌握语义分析的更多技能，比如类型处理等。</p><p>好了，我们已经知道了这一节的任务。那么第一步要做什么呢？你可以想到，我们首先要了解与处理变量声明和初始化有关的语法规则。</p><h2>与变量有关的语法分析功能</h2><p>在TypeScript中，我们在声明变量的时候，可以指定类型，这样有助于在编译期做类型检查：</p><pre><code class=\"language-plain\">let myAge : number = 18;\n</code></pre><p>如果编译成JavaScript，那么类型信息就会被抹掉：</p><pre><code class=\"language-plain\">var myAge = 18;\n</code></pre><p>不过，因为我们的目标是教给你做类型分析的方法，以后还要静态编译成二进制的机器码，所以我们选择的是TypeScript的语法。</p><!-- [[[read_end]]] --><p>此外，在上面的例子中，变量在声明的时候就已经做了初始化。你还可以把这个过程拆成两步。第一步的时候，只是声明变量，之后再给它赋值：</p><pre><code class=\"language-plain\">let myAge : number;\nmyAge = 18;\n</code></pre><p>知道了如何声明变量以后，你就可以试着写出相关的语法规则。我这里给出一个示范的版本：</p><pre><code class=\"language-plain\">variableDecl : 'let' Identifier typeAnnotation？ ('=' singleExpression)?;\ntypeAnnotation : ':' typeName;\n</code></pre><p>学完了前面3节课，我相信你现在应该对阅读语法规则越来越熟悉了。接下来，就要修改我们的语法分析程序，让它能够处理变量声明语句。这里有什么关键点呢？</p><p>这里你要注意的是，我们采用的语法分析的算法是LL算法。而在<a href=\"https://time.geekbang.org/column/article/406555\">02讲</a>中，我们知道LL算法的关键是计算First和Follow集合。</p><p>首先是First集合。在变量声明语句的上一级语法规则（也就是statement）中，要通过First集合中的不同元素，准确地确定应该采用哪一条语法规则。由于变量声明语句是用let开头的，这就使它非常容易辨别。只要预读的Token是let，那就按照变量声明的语法规则来做解析就对了。</p><p>接下来是Follow集合。在上面的语法规则中你能看出，变量的类型注解和初始化部分都是可选的，它们都使用了?号。</p><p>由于类型注解是可选的，那么解析器在处理了变量名称后，就要看一下后面的Token是什么。如果是冒号，由于冒号是在typeAnnotation的First集合中，那就去解析一个类型注解；如果这个Token不是冒号，而是typeAnnotation的Follow集合中的元素，就说明当前语句里没有typeAnnotation，所以可以直接略过。</p><p>那typeAnnotation的Follow集合有哪些元素呢？我就不直说了，你自己来分析一下吧。</p><p>再往后，由于变量的初始化部分也是可选的，还要计算一下它的Follow集合。你能看出，这个Follow集合只有;号这一个元素。所以，在解析到变量声明部分的时候，我们可以通过预读准确地判断接下来该采取什么动作：</p><ul>\n<li>如果预读的Token是=号，那就是继续做变量初始化部分的解析；</li>\n<li>如果预读的Token是;号，那就证明该语句没有变量初始化部分，因此可以结束变量声明语句的解析了；</li>\n<li>如果读到的是=号和;号之外的任何Token呢，那就触发语法错误了。</li>\n</ul><p>相关的实现很简单，你参考一下这个示例代码：</p><pre><code class=\"language-plain\">let t1 = this.scanner.peek();\n//可选的类型标注\nif (t1.text == ':'){\n    this.scanner.next();\n    t1 = this.scanner.peek();\n    if (t1.kind == TokenKind.Identifier){\n        this.scanner.next();\n        varType = t1.text;\n        t1 = this.scanner.peek();\n    }\n    else{\n        console.log(\"Error parsing type annotation in VariableDecl\");\n        return null;\n    }\n}\n\n//可选的初始化部分\nif (t1.text == '='){\n    this.scanner.next();\n    init = this.parseExpression();\n}\n\n//分号，结束变量声明\nt1 = this.scanner.peek();\nif (t1.text==';'){\n    this.scanner.next();\n    return new VariableDecl(varName, varType, init);\n}\nelse{\n    console.log(\"Expecting ; at the end of varaible declaration, while we meet \" + t1.text);\n    return null;\n}\n</code></pre><p>采用增强后的语法分析程序，去解析“let myAge:number = 18;”这条语句，就会形成下面的AST，这表明我们的解析程序是有效的：<br>\n<img src=\"https://static001.geekbang.org/resource/image/0e/66/0e59b79b0530b920e620c42641983266.jpg?wh=1385x837\" alt=\"图片\" title=\"图1：变量声明语句对应的AST\"><br>\n在这个AST中，我们用一个VariableDecl节点代表一个变量声明语句。如果这个变量声明语句带有初始化部分，那么我们就用一个单独的节点来表示用于初始化的表达式。</p><p>好了，生成了这个AST，说明现在我们已经支持变量声明和初始化语句了。那么如何支持变量赋值语句呢？其实，在大多数语言中，我们把赋值运算看作是跟加减乘除一样性质的运算。myAge=18被看作是一个赋值表达式。你还可以把=换成+=、-=等运算符，形成像myAge += 2这样的表达式。如果这些表达式后面直接跟一个;号，那就变成了一个表达式语句了。</p><pre><code class=\"language-plain\">expressionStatement : singleExpression ';' ;\n</code></pre><p>而在上一节，我们已经能够用运算符优先级算法来解析各种二元表达式。不过，<strong>赋值表达式跟加减乘数等表达式有一点不同：它是右结合的。</strong>比如，对于a=b=3这个表达式，是先把3赋值给b，再把b赋值给a。所以呢，对应的语法解析程序也要做一下调整，从而生成体现右结合的AST。</p><p>具体我们可以参照解析器的parseAssignment()方法的代码。由于赋值表达式的优先级比较低，按照自顶向下的解析原则，可以先解析赋值表达式。而赋值表达式的每个子节点，就是一个其他的二元表达式。所以，我们的语法规则可以大致修改成下面的样子：</p><pre><code class=\"language-plain\">singleExpression : assignment;\nassignment : binary (AssignmentOp binary)*\nbinary: primary (BinaryOp primary)*\n</code></pre><p>那现在，我们采用修改完毕的解析器，试着解析一下“a=b=c+3;”这个语句，会打印出下面这个AST：<br>\n<img src=\"https://static001.geekbang.org/resource/image/c0/ea/c0297eff0645e211b54a70ac363c81ea.png?wh=700x294\" alt=\"图片\" title=\"图2：解析赋值语句a=b=3;形成的AST\"><br>\n讲到这里，其实我们与变量有关的语法分析工作就完成了。接下来的工作是什么呢？是实现一些有关的语义分析功能。</p><h2>语义分析：引用消解和符号表</h2><p>不知道你还记不记得，在第1节，我们曾经接触过一点语义分析功能。那个时候我们主要是在函数调用和函数声明之间做了链接。这个工作叫做“引用消解”（Reference Resolve），或者“名称消解”。</p><p>对于变量，我们也一样要做这种消解工作。比如下面的示例程序“myAge + 2”这个表达式中，必须知道这个myAge是在哪里声明的。</p><pre><code class=\"language-plain\">let myAge : number = 18;\nlet yourAge : number;\nyourAge = myAge + 2;\n</code></pre><p>请你回忆一下，在<a href=\"https://time.geekbang.org/column/article/406179\">01讲</a>里，我们是怎么实现引用消解的呢？是在AST的不同节点之间直接做了个链接。这个实现方式比较简单，但实际上不太实用。为什么呢？因为你每次在程序里遇到一个函数或者变量的话，都要遍历AST才能找到它的定义，这有点太麻烦了。</p><p>我有一个效率更高的方法，就是建立一个符号表（Symbol Table），用来保存程序中的所有符号。那什么是符号呢？符号就是我们在程序中自己定义对象，如变量、函数、类等等。它们通常都对应一个标识符，作为符号的名称。</p><p>采用符号表以后，我们可以在做语义分析的时候，每当遇到函数声明、变量声明，就把符号加到符号表里去。这样，如果别的地方还要使用该符号，我们就直接到符号表里去查就行了。</p><p>那这个符号表里要保存哪些信息呢？其实就是我们声明的那些对象的定义信息，比如：</p><ul>\n<li>名称，也就是变量名称、类名称和函数名称等；</li>\n<li>符号种类，也就是变量、函数、类等；</li>\n<li>其他必要的信息，如函数的签名、变量的类型、类的成员，等等。</li>\n</ul><p>你不要小看了这个符号表，符号表在整个编译过程中都有着重要的作用，它的生命周期可以横跨整个编译过程。有的编译器，在词法分析的时候就会先形成符号表，因为每个标识符肯定会对应一个符号。</p><p>不过，大部分现代的编译器，都是在语义分析阶段开始建立符号表的。在Java的字节码文件里，也是存在符号表的，也就是各个类、类的各个成员变量和方法的声明信息。对于C/C++这样的程序，如果要生成可调试的目标代码，也需要用到符号表。所以，在后面的课程中，我们会不断的跟符号表打交道。</p><p>初步了解了符号表以后，我们再回到引用消解的任务上来。首先，我们要建立符号表，这需要对AST做第一次遍历：</p><pre><code class=\"language-plain\">/**\n * 把符号加入符号表。\n */\nexport class Enter extends AstVisitor{\n    symTable : SymTable;\n    constructor(symTable:SymTable){\n        super();\n        this.symTable = symTable;\n    }\n\n    /**\n     * 把函数声明加入符号表\n     * @param functionDecl \n     */\n    visitFunctionDecl(functionDecl: FunctionDecl):any{\n        if (this.symTable.hasSymbol(functionDecl.name)){\n            console.log(\"Dumplicate symbol: \"+ functionDecl.name);\n        }\n        this.symTable.enter(functionDecl.name, functionDecl, SymKind.Function);\n    }\n\n    /**\n     * 把变量声明加入符号表\n     * @param variableDecl \n     */\n    visitVariableDecl(variableDecl : VariableDecl):any{\n        if (this.symTable.hasSymbol(variableDecl.name)){\n            console.log(\"Dumplicate symbol: \"+ variableDecl.name);\n        }\n        this.symTable.enter(variableDecl.name, variableDecl, SymKind.Variable);\n    }\n}\n</code></pre><p>然后我们要基于符号表做引用消解，需要对AST再做第二次的遍历：</p><pre><code class=\"language-plain\">/**\n * 引用消解\n * 遍历AST。如果发现函数调用和变量引用，就去找它的定义。\n */\nexport class RefResolver extends AstVisitor{ \n    symTable:SymTable;\n    constructor(symTable:SymTable){\n        super();\n        this.symTable = symTable;\n    }\n\n    //消解函数引用\n    visitFunctionCall(functionCall:FunctionCall):any{\n        let symbol = this.symTable.getSymbol(functionCall.name);\n        if (symbol != null &amp;&amp; symbol.kind == SymKind.Function){\n            functionCall.decl = symbol.decl as FunctionDecl;\n        }\n        else{\n            if (functionCall.name != \"println\"){  //系统内置函数不用报错\n                console.log(\"Error: cannot find declaration of function \" + functionCall.name);\n            }\n        }\n    }\n\n    //消解变量引用\n    visitVariable(variable: Variable):any{\n        let symbol = this.symTable.getSymbol(variable.name);\n        if (symbol != null &amp;&amp; symbol.kind == SymKind.Variable){\n            variable.decl = symbol.decl as VariableDecl;\n        }\n        else{\n            console.log(\"Error: cannot find declaration of variable \" + variable.name);\n        }\n    }\n}\n</code></pre><p>好了，现在我们通过新建符号表升级了我们的引用消解功能。有了符号表的支持，我们在程序中使用变量时，就可以直接从符号表里知道变量的类型，调用一个函数时，也能够直接从符号表里找到该函数的代码，也就是函数声明中的函数体。不过，还有一个语义分析功能也最好现在就实现一下，就是与类型处理有关的功能。</p><h2>语义分析：类型处理</h2><p>相比JavaScript，TypeScript的一个重要特性，就是可以清晰地指定类型，这能够在编译期进行类型检查，减少程序的错误。比如，在下面的程序中，myAge是number类型的。这时候，如果你把一个字符串赋值给myAge，TypeScript编译器就会报错：</p><pre><code class=\"language-plain\">let myAge:number;\nmyAge = \"Hello\";\n</code></pre><p>运行TypeScript编译器，报错信息如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/80/f7/8077cf398fbfe962a184e06254ea00f7.png?wh=1488x260\" alt=\"图片\" title=\"图3：TypeScript编译器的类型检查功能\"><br>\n那么，如何检查程序中的类型是否匹配呢？这需要用到一种叫做属性计算的技术。它其实就是给AST节点附加一些属性，比如类型等。然后通过一些AST节点的属性，去计算另一些节点的属性。</p><p>其实，对表达式求值的过程，就可以看做是属性计算的过程，这里的属性就是表达式的值。我们通过遍历AST，可以通过叶子节点的值逐步计算更上层节点的值。</p><p>类似的技术还可以用于计算类型。比如，对于myAge = \"Hello\"这个表达式对应的AST节点，我们可以设置两个属性：一个属性是type_req，也就是赋值操作中，左边的变量所需要的类型；另一个属性是type，也就是=号右边的表达式实际的类型。</p><p>所谓类型检查，就是检查这两个类型是否匹配就可以了。其中，type_req可以通过查符号表获得，也就是在声明myAge时所使用的类型。而=号右边表达式的type属性，可以像计算表达式的值一样，自底向上逐级计算出来。</p><p>对于当前例子来说，我们一下子就能知道“Hello”字面量是字符串型的。如果是一个更复杂一点的表达式，比如\"Hello\"+3 * 5，它的类型就需要自底向上的逐级计算得到。这种自下而上逐级计算得到的属性，我们把它叫做综合属性（Synthesized Attribute）。</p><p>还有一个与综合属性相对应的概念，叫继承属性（Inherited Attribute），它是指从父节点或者兄弟节点计算出来的属性，这里我举一个例子来帮助你理解一下。</p><p>其实在解释器执行“a+3”和“a=3”这两个表达式的时候，对这两个变量a的操作是不一样的。对于“a+3”，只需要取出a的值就行了。而对于“a=3”，则需要给a赋一个新的值。a如果在赋值符号的左边，我们就叫它左值，其他情况就叫右值。</p><p>为了让解释器顺利地运行，我们在遍历AST的时候，需要知道当前的这个变量是左值还是右值。所以，我就给表达式类型的AST节点添加了一个isLeftValue的属性。这个属性呢，是一个典型的继承属性，因为它的值是通过上级节点计算得到的。当变量是赋值运算符的第一个子节点的时候，它是个左值。</p><p><img src=\"https://static001.geekbang.org/resource/image/35/63/352d53cb6c7f644998a25026da86c863.jpg?wh=1526x788\" alt=\"图片\"></p><p>现在我们再回到类型计算。知道了类型检查的思路，我们其实还可以再进一步，进行类型的推断。</p><p>在类型声明的语法规则中，我们会发现typeAnnotation是可选的。当你不显式规定类型的情况下，其实TypeScript是可以根据变量初始化部分的类型，来进行类型推论的。比如下面的例子中，myAge的类型可以被自动推断出来是number，这样第二个赋值语句就会被报错。</p><pre><code class=\"language-plain\">let myAge = 18;\nmyAge = \"Hello\";\n</code></pre><p>好了，现在我们已经做了引用消解和类型处理这两项关键的语义分析工作。不过，要保证一个程序正确，还要做很多语义分析工作。</p><h2>更多的语义分析工作</h2><p>语义分析的工作其实比较多和杂的。语言跟语言的差别，很多情况下也体现在语义方面。对于我们当前的语言功能，还需要去做的语义分析功能包括：</p><ul>\n<li>在赋值语句中，=号左边必须是可以被赋值的表达式，我们把它叫做左值。变量就可以作为左值，而字面量就不可以；</li>\n<li>字符串可以用+号跟数值进行连接运算，但不可以参与-号、 * 号和/号的运算等等。</li>\n</ul><p>实际上，在JavaScript语言的标准（<a href=\"https://262.ecma-international.org/6.0/#sec-addition-operator-plus\">ECMAScript语言规格2015版</a>）中，大量的内容都是对语义的规定，比如下面的截图中，就是对+号运算符的语义规定。</p><p><img src=\"https://static001.geekbang.org/resource/image/52/c8/52e3bed6ce9bcafebc20e3242726bac8.png?wh=1718x1302\" alt=\"图片\" title=\"图4：JavaScript中加法运算的语义描述\"><br>\n不过，这些语义分析和处理工作通常并不复杂，大部分都可以通过遍历AST来实现。我也给出了参考实现，你可以查阅相关的代码。</p><p>做完语义分析工作以后，我们基本上就能够保证程序的正确性了。接下来，我们要对解释器做一下提升，让它也能够支持变量声明和赋值。</p><h2>增强解释器的功能</h2><p>让目前的解释器支持变量，其实比较简单，我们只需要有一个机制能够保存变量的值就可以了。</p><p>在我的参考实现里，我用了一个map的数据结构来保存每个变量的值。解释器可以从map里查找一个变量的值，也可以更新某个变量的值，具体你可以看下面这些代码：</p><pre><code class=\"language-plain\">**\n * 遍历AST，并执行。\n */\nclass Intepretor extends AstVisitor{   \n    //存储变量值的区域\n    values:Map&lt;string, any&gt; = new Map();\n\n    /**\n     * 变量声明\n     * 如果存在变量初始化部分，要存下变量值。\n     */\n    visitVariableDecl(variableDecl:VariableDecl):any{\n        if(variableDecl.init != null){\n            let v = this.visit(variableDecl.init);\n            if (this.isLeftValue(v)){\n                v = this.getVariableValue((v as LeftValue).variable.name);\n            }\n            this.setVariableValue(variableDecl.name, v);\n            return v;\n        }\n    }\n\n    /**\n     * 获取变量的值。\n     * 这里给出的是左值。左值既可以赋值（写），又可以获取当前值（读）。\n     * @param v \n     */\n    visitVariable(v:Variable):any{\n        return new LeftValue(v);\n    }\n    //获取变量值\n    private getVariableValue(varName:string):any{\n        return this.values.get(varName);\n    }\n    //设置变量值\n    private setVariableValue(varName:string, value:any):any{\n        return this.values.set(varName, value);\n    }\n    //检查是否是左值\n    private isLeftValue(v:any):boolean{\n        return typeof (v as LeftValue).variable == 'object';\n    }\n    //省略其他部分...\n}\n</code></pre><p>这样，通过引入一个简单的map，我们的程序在每一次引用变量时，都能获得正确的值。当然，这个机制目前是高度简化的。我们在后面会持续演化，引入栈帧等进一步的概念。</p><p>好了，现在我们的功能又得到了提升，你可以编写几个程序试一下它的能力。我编写了下面的一个程序，你可以试试看它的运行结果是什么。</p><pre><code class=\"language-plain\">/**\n * 示例程序，由play.js解析并执行。\n * 特性：对变量的支持。\n */\n\n//那年才18\nlet myAge:number = 18;\n\n//转眼10年过去\nmyAge = myAge + 10;\n\nprintln(\"myAge is: \");\nprintln(myAge);\n</code></pre><h2>课程小结</h2><p>今天这节课，我们为了让程序支持变量，分别升级了语法分析、语义分析和解释器。通过这种迭代开发方式，我们可以让语言的功能一点点的变强。</p><p>在今天的旅程中，我希望你能记住下面这几个关键点：</p><p>首先，我给你演示了如何增加新的语法规则，在这里你要继续熟悉如何用EBNF来书写语法规则。然后，我也给你说明了如何通过计算First和Follow集合来使用LL算法，你要注意EBNF里所有带?号或者 * 号、+号的语法成分，都需要计算它的Follow集合，以便判断到底是解析这个语法成分，还是跳过去。通过这样一次次的练习，你会对LL算法越来越熟练。</p><p>在语义分析部分，我们引入了符号表这个重要的数据结构，并通过它简化了引用消解机制。我们在后面的课程还会深化对符号表的理解。</p><p>另外，与类型有关的处理也很重要。你可以通过属性计算的方式，实现类型的检查和自动推断。你还要记住，语义分析工作的内容是很多的，建立符号表、引用消解和类型检查是其中的重点工作，但还有很多其他语义分析工作。</p><p>最后，解释器如果要支持变量，就必须要能够保存变量在运行时的值。我们是用了一个map数据结构来保存变量的值，在后面的课程里，我们还会升级这个机制。</p><p>不过，我们现在只能在顶层代码里使用变量。如果在函数里使用，还有一些问题，比如作用域和局部变量的机制、函数传参的机制、返回值的机制等等。我们会在下一节去进一步升级我们的语言，让它的功能更强大。</p><h2>思考题</h2><p>今天的思考题，我想问下你，在变量声明的语法规则中，你能否计算出typeAnnotation的Follow集合都包含哪些元素？欢迎在留言区给我留言。</p><p>感谢你和我一起学习，如果你觉得这节课讲得还不错，也欢迎分享给更多感兴趣的朋友。我是宫文学，我们下节课见。</p><h2>资源链接</h2><p><a href=\"https://gitee.com/richard-gong/craft-a-language/tree/master/04\">这节课的示例代码在这里！</a></p>","neighbors":{"left":{"article_title":"03｜支持表达式：解析表达式和解析语句有什么不同？","id":407295},"right":{"article_title":"05｜函数实现：是时候让我们的语言支持函数和返回值了","id":408912}}},{"article_id":408912,"article_title":"05｜函数实现：是时候让我们的语言支持函数和返回值了","article_content":"<p>你好，我是宫文学。</p><p>不知道你还记不记得，我们在<a href=\"https://time.geekbang.org/column/article/406179\">第一节课</a>就支持了函数功能。不过那个版本的函数功能是被高度简化了的，比如，它不支持声明函数的参数，也不支持函数的返回值。</p><p>在上一节课实现了对变量的支持以后，我们终于可以进一步升级我们的函数功能了。为什么要等到这个时候呢？因为其实函数的参数的实现机制跟变量是很类似的。</p><p>为了升级我们的函数功能，我们需要完成几项任务：</p><ol>\n<li><strong>参考变量的机制实现函数的参数机制</strong>；</li>\n<li><strong>支持在函数内部声明和使用本地变量</strong>，这个时候，我们需要能够区分函数作用域和全局作用域，还要能够在退出函数的时候，让本地变量的生命期随之结束；</li>\n<li><strong>要支持函数的返回值</strong>。</li>\n</ol><p>你可以想象到，在实现了这节课的功能以后，我们的语言就越来像样了。你甚至可以用这个语言来实现一点复杂的功能了，比如设计个函数，用来计算圆的周长、面积什么的。</p><p>好吧，让我们赶紧动手吧。首先，像上节课一样，我们还是要增强一下语法分析功能，以便解析函数的参数和返回值，并支持在函数内部声明本地变量。</p><h2>增强语法分析功能</h2><p>我们原来的函数声明的语法比较简陋，现在我们采用一下TypeScript完整的函数声明语法。采用这个语法，函数可以有0到多个参数，每个参数都可以指定类型，就像变量一样，还可以指定函数返回值的类型。</p><!-- [[[read_end]]] --><pre><code class=\"language-plain\">//函数声明，由'function'关键字、函数名、函数签名和函数体构成。\nfunctionDeclaration\n    : 'function' Identifier callSignature '{' functionBody '}';\n\n//函数签名，也就是参数数量和类型正确，以及函数的返回值类型正确    \ncallSignature\n    : '(' parameterList? ')' typeAnnotation?\n    ;\n\n//参数列表，由1到多个参数声明构成。    \nparameterList : parameter (',' parameter)* ;\n\n//参数，由参数名称和可选的类型标注构成\nparameter : Identifier typeAnnotation? ;\n\n//返回语句\nreturnStatement: 'return' expression? ';' ;\n</code></pre><p>采用该规则以后，你可以声明一个像下面的函数，比如，你给这个函数传入圆的半径的值，它会给你计算出圆的面积：</p><pre><code class=\"language-plain\">//计算圆的面积\nfunction circleArea(r : number):number{\n  let area : number = 3.14*r*r;\n  return area;\n}\nlet r:number =4;\nprintln(\"r=\" + r +\", area=\"+circleArea(r));\nr = 5;\nprintln(\"r=\" + r +\", area=\"+circleArea(r));\n</code></pre><p>好了，修改好语法规则以后，我们就按照该语法规则来升级一下语法分析程序，跟<a href=\"https://time.geekbang.org/column/article/407731\">04讲</a>一样，我们同样需要计算一下相关元素的First和Follow集合。在这里，我就不再演示计算First集合和Follow集合了，而是把它们留到了思考题的部分，让你自己来计算一个语法成分的Follow集合，这样能让你对LL算法理解得更加深入。</p><p>这里，我贴上几个代码片段，如果你想看更完整的代码，你可以阅读<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/05/parser.ts\">parser.ts</a>。</p><pre><code class=\"language-plain\">//解析语句\nparseStatement():Statement{\n    let t = this.scanner.peek();\n    //根据'function'关键字，去解析函数声明\n    if (t.code == Keyword.Function){\n        return this.parseFunctionDecl();\n    }\n    //根据'return'关键字，解析return语句\n    else if (t.code == Keyword.Return){\n        return this.parseReturnStatement();\n    }\n    //...\n}\n\n//解析函数签名\nparseCallSignature():CallSignature{\n    let beginPos = this.scanner.getNextPos();\n    //跳过'('\n    let t = this.scanner.next();\n\n    let paramList = null;\n    if (this.scanner.peek().code != Seperator.CloseParen){  //')'\n        paramList = this.parseParameterList();\n    }\n\n    //看看后面是不是')'\n    t = this.scanner.peek();\n    if (t.code == Seperator.CloseParen){  //')'\n        //跳过')'\n        this.scanner.next();\n\n        //解析typeAnnotation\n        let theType:string = 'any';\n        if (this.scanner.peek().code == Seperator.Colon){  //':'\n            theType = this.parseTypeAnnotation();\n        }\n        return new CallSignature(beginPos,this.scanner.getLastPos(),paramList, theType);\n    }\n    else{\n        console.log(\"Expecting a ')' after for a call signature\");\n        return new CallSignature(beginPos,this.scanner.getLastPos(),paramList, 'unknown', true);\n    }\n}\n</code></pre><p>做完语法分析后，按照惯例，我们还是要再迭代一下语义分析程序。在这一节课里，我们会在语义分析环节，开始接触作用域的概念。</p><h2>语义分析：作用域</h2><p>我们在学习任何一门语言的时候，都会涉及到作用域的概念。</p><p>作用域就是变量能够起作用的代码范围。当我们声明一个变量的时候，这个变量起作用的范围是有限的，比如，在一个函数体内声明的变量，在函数之外就不能引用了。区分了作用域，我们就能保护函数内部的变量的值不会被外部的代码所改变。同时，我们在函数外面使用变量的时候，也不用担心跟函数内部的变量名称冲突。</p><p>上一节课，我们已经建立了符号表，并且能够存储每个变量的值。可是，我们当时并没有区分变量的作用域，也没有限制局部变量的生存期。所以，对于下面的程序，由于函数内部和外部都有一个相同名称的变量a，可能就会出现错误：</p><pre><code class=\"language-plain\">function foo(){\n  //局部变量a\n  let a:number = 3;\n}\n\n//全局变量a\nlet a:number;\nprintln(a);   //打印出3来。\n</code></pre><p>所以，在语义分析阶段，我们要区分开不同变量的作用域。目前我们只需要支持全局作用域和函数内部的作用域两种就可以了，我们后面还会针对语句块、类等引入更多的作用域。</p><p>在具体实现上，我们需要修改符号表的设计，引入一个作用域类，也就是Scope。这样，全局的符号和和每个函数的符号就可以分别保存在各自的Scope对象中，也就不会冲突了。</p><p>另外，你要注意，作用域是一层套一层，形成一个树状结构的，比如，函数的作用域就是全局作用域的子作用域。所以，我们在Scope的属性中，能够发现作用域所形成的层级结构。</p><pre><code class=\"language-plain\">export class Scope{\n    //以名称为key存储符号\n    name2sym:Map&lt;string,Symbol&gt; = new Map();\n    //上级作用域\n    enclosingScope: Scope|null; //顶级作用域的上一级是null\n    //...\n}\n</code></pre><p>我们再把建立符号表的程序更新一下（参见<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/05/semantic.ts#L77\">Enter类</a>），重点看一下visitBlock方法。</p><pre><code class=\"language-plain\">visitBlock(block:Block):any{\n    //创建下一级scope\n    let currentScope = new Scope(this.scope);\n    block.scope = currentScope;\n\n    // 修改当前的Scope\n    this.scope = currentScope;\n\n    //调用父类的方法，遍历所有的语句\n    super.visitBlock(block);\n\n    //重新设置当前的Scope\n    if (this.scope.enclosingScope != null){\n        this.scope = this.scope.enclosingScope;\n    }\n    return currentScope;\n}\n</code></pre><p>注意，我们创建新的作用域，都是在遇到Block的时候。因为每个函数的函数体都是一个Block，所以会确保每个函数都对应一个新的Scope。这样的话，在函数体中声明的变量，就会添加到函数的作用域中，而不是全局作用域。</p><pre><code class=\"language-plain\">/**\n * 把变量声明加入符号表\n * @param functionDecl \n */\nvisitVariableDecl(variableDecl : VariableDecl):any{\n    //重复变量声明的检查\n    if (this.scope.hasSymbol(variableDecl.name)){\n        console.log(\"Dumplicate symbol: \"+ variableDecl.name);\n        return;\n    }\n    //把变量加入当前的符号表\n    let sym = new VarSymbol(variableDecl.name, variableDecl.theType, variableDecl);\n    this.scope.enter(variableDecl.name, sym);\n\n    //把本地变量也加入函数符号中，可用于后面生成代码\n    this.functionSym?.vars.push(sym);\n}\n</code></pre><p>更新了建立符号表的程序以后，我们再更新一下引用消解的程序（参见<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/05/semantic.ts#L185\">RefResolver类</a>）。在下面的示例程序中，你会注意到，程序是沿着作用域的层级结构，逐级查找符号的。这是因为，TypeScript或JavaScript中的函数，允许访问函数外面声明的变量。</p><pre><code class=\"language-plain\">/**\n * 变量引用消解\n * @param variable \n */\nvisitVariable(variable: Variable):any{\n    //从当前作用域逐级向上查找，确定该变量的符号\n    let symbol = (this.scope as Scope).getSymbolCascade(variable.name);\n    if (symbol != null &amp;&amp; symbol.kind == SymKind.Variable){\n        variable.sym = symbol as VarSymbol;\n    }\n    else{\n        console.log(\"Error: cannot find declaration of variable \" + variable.name);\n    }\n}\n</code></pre><p>好了，通过更新建立符号表的程序和引用消解的程序，我们可以把函数的作用域跟全局作用域区分开了。我们现在可以针对这节课一开篇的那个circleArea示例程序运行一下语义分析程序，会输出下面的符号表：</p><p><img src=\"https://static001.geekbang.org/resource/image/fe/d8/febc62ba728be664cdcb8af9992bfcd8.png?wh=882x250\" alt=\"图片\"></p><p>你会看到，现在作用域已经分成了两级：主函数(_main)和circleArea函数。两级作用域都有一个本地变量r，其中circleArea中的r是函数参数。这证明我们划分不同变量的作用域的努力是成功的。</p><p>不过，虽然区分了变量的作用域，我们还需要给函数内的本地变量设置正确的生存期。在函数运行结束以后，它的本地变量所占据的内存就应该被回收，避免造成内存使用上的浪费，甚至导致内存泄漏。</p><p>为了正确管理本地变量的生存期，我们需要更新当前的解释器，并引入一个栈桢（Stack Frame）的机制。</p><h2>解释器：实现栈桢</h2><p>在现代语言中，本地变量基本上都是通过栈来管理的，栈又是由一个个的栈桢组成的，所以函数的调用层次，就体现在了栈桢上。</p><p>每个函数对应着一个栈桢，在调用一个函数时，就会往栈里压入一个新的栈桢，用来保存支撑该函数运行的相关信息。在退出函数时，该栈桢就会被弹出。这样，随着函数的调用和退出，栈就会不停地伸缩。</p><p>我们以下面的示例程序为例：</p><pre><code class=\"language-plain\">function foo(){\n  some statement\n}\n\nfunction bar(){\n  foo();\n}\nbar();\n</code></pre><p>当我们在主程序中调用bar的时候，bar又会调用foo，在程序运行过程中栈桢的变化如下：<br>\n<img src=\"https://static001.geekbang.org/resource/image/e9/33/e9cb45964787b526927b090c8f8c7933.jpg?wh=1920x568\" alt=\"图片\" title=\"图1：示例程序运行时栈桢的变化\"><br>\n栈桢保存着与一个函数正确运行有关的各种信息，其中最重要的就是本地变量的值以及参数的值，其他还有返回值等信息。不过，对于不同的语言来说，栈桢的具体设计可以是不同的，但基本原理是一样的。</p><p>在某些编译原理的教科书上，你还会看到“活动记录（Activation Record）”这样一个概念。它跟栈桢的意思是差不多的。</p><p>只不过，栈桢有时候指的是更加物理层面的设计。当程序以本地代码的形式运行时，为了提高性能，我们会把尽量多的数据放在寄存器，而不是放在内存的栈桢里。</p><p>而相对来说，活动记录是逻辑意义上一个函数运行过程中所需要维护的状态信息，不管放在栈桢里还是寄存器里，它们都属于该函数的活动记录。</p><p>好，回到我们自己的解释器上来。我们通过引入栈桢这么一个数据结构（参见<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/05/play.ts#L380\">StackFrame类</a>），通过动态的构建和释放栈桢，我们就能管理好本地变量的生存期。栈桢的设计也很简单，包括变量的值和返回值，你可以看看下面这个代码：</p><pre><code class=\"language-plain\">/**\n * 栈桢\n * 每个函数对应一级栈桢.\n */\nclass StackFrame{\n    //存储变量的值\n    values:Map&lt;string, any&gt; = new Map();\n    \n    //返回值，当调用函数的时候，返回值放在这里\n    retVal:any = undefined;\n}\n</code></pre><p>由于我们目前的运行时是基于node.js实现的，所以当我们释放栈桢时，实际上是通过V8的垃圾收集机制回收内存的。如果我们把运行时改为用C语言单独实现，就可以实时释放了。</p><p>接着再修改我们的解释器（参见<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/05/play.ts#L23\">Interprator类</a>），让它支持栈桢。这其中，最关键的就是调用函数的程序，它要负责栈桢的创建和释放。请看下面的参考实现：</p><pre><code class=\"language-plain\">/**\n * 运行函数调用。\n * 原理：根据函数定义，执行其函数体。\n * @param functionCall \n */\nvisitFunctionCall(functionCall:FunctionCall):any{\n    if (functionCall.name == \"println\"){ //内置函数\n        return this.println(functionCall);\n    }\n    \n    if(functionCall.sym != null){\n        //清空返回值\n        this.currentFrame.retVal = undefined;\n\n        //1.创建新栈桢\n        let frame = new StackFrame();\n        //2.计算参数值，并保存到新创建的栈桢\n        let functionDecl = functionCall.sym.node as FunctionDecl;\n        if (functionDecl.callSignature.paramList != null){\n            let params = functionDecl.callSignature.paramList.params;\n            for (let i = 0; i&lt; params.length; i++){\n                let variableDecl = params[i];\n                let val = this.needLeftValue(this.visit(functionCall.arguments[i]));\n                frame.values.set(variableDecl.name, val);  //设置到新的frame里。\n            }\n        }\n\n        //3.把新栈桢入栈 \n        this.pushFrame(frame);\n\n        //4.执行函数\n        this.visit(functionDecl.body);            \n\n        //5.弹出当前的栈桢\n        this.popFrame();\n\n        //6.函数的返回值\n        return this.currentFrame.retVal;\n    }\n    else{\n        console.log(\"Runtime error, cannot find declaration of \" + functionCall.name +\".\");\n        return;\n    }\n}\n</code></pre><p>在上面这个示例程序中，你会看到调用一个函数的完整的过程，包括传递参数的过程，以及在调用函数前后将栈桢入栈和出栈的过程。</p><p>并且，在退出函数的时候，如果我们执行了一个Return语句，并且带有返回值，那么该返回值就会被设置到上一级栈桢中。</p><pre><code class=\"language-plain\">/**\n * 处理Return语句时，要把返回值封装成一个特殊的对象，用于中断后续程序的执行。\n * @param returnStatement \n */\nvisitReturnStatement(returnStatement: ReturnStatement):any{\n    let retVal:any;\n    if (returnStatement.exp != null){\n        retVal = this.needLeftValue(this.visit(returnStatement.exp)); \n        this.setReturnValue(retVal);\n    }\n    return new ReturnValue(retVal);  //这里是传递一个信号，让Block和for循环等停止执行。\n}\n\n//把返回值设置到上一级栈桢中（也就是调用者的栈桢）\nprivate setReturnValue(retVal:any){\n    let frame = this.callStack[this.callStack.length-2];\n    frame.retVal = retVal;\n}\n</code></pre><p>不过，关于Return语句，我们还有一个重要的机制需要注意。当程序遇到Return语句的时候，后面的代码就不执行了，直接退出函数。</p><p>可是，我们当前的解释器，是通过遍历AST来实现的。那么，缺省我们是会遍历每棵子树，也就是执行每个语句。可是，return语句又要求程序跳过某些语句，这应该如何实现呢？</p><p>我给你一个解决方案。上面的示例代码中，在visitReturnStatement方法的最后一句，你会看到示例代码中返回了一个ReturnValue对象。这里，我相当于做了一个特殊的标记。在遍历树的时候，告诉上一级函数，这里遇到了一个return语句，这样就可以跳过后面的语句了。</p><p>我们再来看一下visitBlock中的代码，当检测出某个语句返回的是ReturnValue对象的时候，就会中断该Block的执行。并且，你还看到，visitBlock接着把这个ReturnValue对象往外抛，这是考虑到Block会嵌套的情况。在下一节，当我们使用if语句和for循环语句的时候，就会遇到这种情况。但是，不管嵌套了多少个Block，程序的执行流程都会一直往外跳，直到整个当前函数停止运行。</p><pre><code class=\"language-plain\">/**\n * 遍历一个块\n * @param block \n */\nvisitBlock(block:Block):any{\n    let retVal:any;\n    for(let x of block.stmts){\n        retVal = this.visit(x);\n        //如果当前执行了一个返回语句，那么就直接返回，不再执行后面的语句。\n        //如果存在上一级Block，也是中断执行，直接返回。\n        \n        if (typeof retVal == 'object' &amp;&amp;\n            ReturnValue.isReturnValue(retVal)){\n            return retVal;\n        }\n    }\n    return retVal;\n}\n</code></pre><p>在这里，你也会看到，基于AST的解释器在处理像return这样的流程跳转语句的时候，其实是比较困难的。其他流程跳转语句还包括break、continue这种，处理起来也都比较麻烦。这也是后面我们会引入一个新的解释器——基于字节码的解释器的原因之一。</p><p>好了，到目前为止，我们这节课的任务就完成了。我们的函数可以支持参数和返回值了，成为了真正意义上的函数。现在，你就可以试着写几个函数，来验证一下我们语言的功能了，比如，我运行了一下下面的示例程序，用来打印不同半径的圆的面积：</p><pre><code class=\"language-plain\">function circleArea(r : number):number{\n  let area : number = 3.14*r*r;\n  return area;\n}\nlet r:number =4;\nprintln(\"r=\" + r +\", area=\"+circleArea(r));\nr = 5;\nprintln(\"r=\" + r +\", area=\"+circleArea(r));\n</code></pre><p>运行该程序，可以得到下面的输出结果：</p><p><img src=\"https://static001.geekbang.org/resource/image/28/0c/2822bb05c8c46a99aa9d3dde2cd47b0c.png?wh=512x134\" alt=\"图片\"></p><p>看来，函数的传参功能和返回值功能运行都正常。</p><p>如果你喜欢动手，还可以在解释器里加一些调试代码，打印程序运行期间栈和栈桢的情况，加深对栈桢机制的理解。</p><p>最后，我们再加一个小彩蛋。也就是不知不觉间，其实我们的语言已经支持在函数内部声明函数了。</p><h2>彩蛋：在函数内部声明的函数</h2><p>仔细审视我们当前的语法规则，你会发现，函数声明是一种语句。而我们在任何一个Block里面，包括函数体里面，允许各种类型的语句，那当然也就允许声明函数。在下面的示例代码中，我把circleArea函数改写了一下，里面声明了一个inner函数：</p><pre><code class=\"language-plain\">function circleArea(a:number):number{\n    function inner(b:number):number{\n        return b*b;\n    }\n    return 3.14*inner(a);\n}\nlet r:number =4;\nprintln(\"r=\" + r +\", area=\"+circleArea(r));\nr = 5;\nprintln(\"r=\" + r +\", area=\"+circleArea(r));\n</code></pre><p>下图是circleArea对应的AST，你看到，函数声明内部又嵌套了另一个函数声明。</p><p><img src=\"https://static001.geekbang.org/resource/image/54/16/548ayy7d8d68d9bbdb4ca5f499ee1816.png?wh=1060x804\" alt=\"图片\"></p><p>在函数体内部声明的函数，其作用域只在函数内部，这在程序输出的符号表中能够看出来。inner函数是circleArea中的一个符号，整个程序形成了三级作用域，分别是主函数(_main)、circleArea和inner。</p><p><img src=\"https://static001.geekbang.org/resource/image/69/9a/6913e71yy01642480e5759e58762549a.png?wh=878x374\" alt=\"图片\"></p><p>你可以运行一下使用内部函数版本的circleArea，它也完全能正常运行，我们并不需要为支持内部函数而做什么特殊的事情！从这里，你也能看出在我们实现计算机语言的过程中，有一个很有魔力的地方：<strong>只要你制定</strong><strong>了规则，你的语言就会遵守该规则运行，哪怕有些运行场景你自己都没有意识到。</strong>你在后面也会越来越多地体会到这一点。</p><p>不过，目前我们只是支持了内部函数而已，还没有高级函数的特性，也就是把函数本身当做参数和返回值来传递。这个过程中，通常又会涉及到闭包特性，我们会在后面的课程中涉及到这个知识点。那个时候，我们会在已经编译成本地代码的版本中讨论实现函数式编程涉及的知识点。</p><h2>课程小结</h2><p>好了，到这里我们今天的课就结束了，让我们来简单回顾一下吧。</p><p>这节课我们继续迭代和增强了我们的语言，让它支持了完整的函数功能。在这个过程中，我们仍然要把语法分析功能、语义分析功能和基于AST的解释器都升级一遍。</p><p>在这个过程中，比较重要的知识点有三个。</p><p>首先是作用域。通过Scope对象，我们让符号表变成了一个层次结构，让不同的变量和函数归属到不同层次的作用域。在现代语言中，符号表通常都是采用类似的层次结构来保存的。</p><p>第二个知识点是栈桢。在运行期，通过采用栈桢，我们可以让函数的本地变量的生存期与函数的生存期相一致，从而达到节省内存的目的。</p><p>最后，我们也讨论了return语句的实现机制。返回值是被保存到上一级栈桢的返回值字段的。并且，通过特殊设计的机制，我们保证了在遇到return语句的时候，程序会跳过其他的语句，直接从函数中退回。</p><p>在下一节课里，我们借助if语句和for循环语句，会进一步加深你对作用域的理解。</p><h2>思考题</h2><p>今天，我给你留了两个思考题：</p><p>1.在函数声明相关的语法规则中，parameter的Follow集合是什么？有什么作用？</p><p>2.在这节课中，我们是同等看待参数和本地变量的。但是，它们在使用起来真的没有差别吗？请你试着分析一下。</p><p>欢迎在留言区给我留言。感谢你和我一起学习，如果你觉得这节课讲得还不错，也欢迎分享给更多感兴趣的朋友。我是宫文学，我们下节课见。</p><h2>资源链接</h2><p><a href=\"https://gitee.com/richard-gong/craft-a-language/tree/master/05\">这节课的代码在这里！</a></p>","neighbors":{"left":{"article_title":"04｜如何让我们的语言支持变量和类型？","id":407731},"right":{"article_title":"06｜怎么支持条件语句和循环语句？","id":409811}}},{"article_id":409811,"article_title":"06｜怎么支持条件语句和循环语句？","article_content":"<p>你好，我是宫文学。</p><p>我们现在的语言已经支持表达式、变量和函数了。可是你发现没有，到现在为止，我们还没有支持流程控制类的语句，比如条件语句和循环语句。如果再加上这两类语句的话，我们的语言就能做很复杂的事情了，甚至你会觉得它已经是一门比较完整的语言了。</p><p>那么今天，我们就来加上条件语句和循环语句。在这个过程中，我们会加深对作用域和栈桢的理解，包括跨作用域的变量引用、词法作用域的概念，以及如何在运行时访问其他作用域的变量。这些知识点会帮助你加深对计算机语言的运行机制的理解。</p><p>而这些理解和认知，会有助于我们后面把基于AST的解释器升级成基于字节码的解释器，也有助于我们理解编译成机器码后的运行时机制。</p><p>好了，首先我们先从语法层面支持一下这两种语句。</p><h2>语法分析：支持一元表达式</h2><p>按照惯例，我们首先要写下新的语法规则，然后使用LL算法来升级语法分析程序。新的语法规则如下：</p><pre><code class=\"language-plain\">ifStatement\n&nbsp; &nbsp; : If '(' expression ')' statement (Else statement)?\n&nbsp; &nbsp; ;\nforStatement\n    :For '(' expression? ';' expression? ';' expression? ')' statement\n    ;\nstatement:\n    : block\n    | functionDecl\n    | varaibleStatement\n    | expressionStatement\n    | returnStatement\n    | ifStatement\n    | forStatement\n    | emptyStatement\n    ;\n</code></pre><!-- [[[read_end]]] --><p>你从上面的语法可以得到这几个信息：</p><p>首先，if语句中，else部分是可选的。这样，我们在解析完if条件后面的语句以后，要去看看后面跟着的是不是’else’关键字，从而决定是否解析else后面的语句块。更具体的你可以参见<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/06/parser.ts#L176\">parseIfStatement函数</a>的代码。</p><p>第二，在for循环语句中，for括号里用分号分割的三个表达式都是可选的，在解析的时候也要根据Follow集合来判断是否需要解析这三个表达式。这点你具体可以参见<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/06/parser.ts#L223\">parseForStatement函数</a>的代码。</p><p>最后，从statement的语法规则中，我们也可以发现，我们的语言所支持的语句越来越多了，这也使得语言特性越来越丰富了。</p><p>现在，升级我们的语法解析程序，对你来说已经没有太大的困难了，你可以参照我的参考实现动手自己做一下。</p><p>不过，为了实现for语句，我们还有一个语言特性需要升级一下，这就是对一元运算的支持。</p><p>哪些是一元运算呢？比如，在for语句中，我们经常会使用下面的写法：</p><pre><code class=\"language-plain\">for(i = 0; i&lt; 10; i++)\n</code></pre><p>其中i++就是使用了一元运算。在这里，为了方便，我们干脆就让程序支持所有的一元运算！</p><p>一元运算符除了++以外，还有–、~、!等。甚至还有更复杂一点的情况，+号和-号除了作为二元运算符以外，还可以作为一元运算符使用，比如下面这个例子：</p><pre><code class=\"language-plain\">myAge = +myAge + -10;\n</code></pre><p>你甚至可以将多个一元运算符叠加使用，比如我们把上面的例子修改一下，仍然和原来的计算结果相同：</p><pre><code class=\"language-plain\">myAge = + +myAge + - - -10;\n</code></pre><p>注意了，这里面的两个+号或两个-号之间是留有空格的，否则就会被词法分析程序识别成++和–了。</p><p>上面的示例程序有一些负数，比如-10。在这里，-10是一个表达式，由一个符号和一个字面量构成，而不是把-10整体上作为一个字面量。</p><p>在第二节介绍词法分析的时候，我曾经留了个思考题，问像-3这样的负数，是识别成-号和3，还是把-3整体作为一个Token识别出来？</p><p>答案是前者。原因是，如果不这样处理，2-3这样的表达式就会识别错。在词法分析阶段，我们只需要把-号作为Token识别出来就行了，至于它是作为一元运算符还是二元运算符来使用，那就交给语法分析程序来处理吧！</p><p>为了支持一元运算，我们需要把与表达式相关的语法规则升级一下：</p><pre><code class=\"language-plain\">expression: assignment;\nassignment: binary (assignmentOp binary)* ;\nbinary: unary (binOp unary)* ;\nunary: primary | prefixOp unary | primary postfixOp ;\nprimary: StringLiteral | DecimalLiteral | IntegerLiteral | functionCall | '(' expression ')' ;\nprefixOp = '+' | '-' | '++' | '--' | '!' | '~';\npostfixOp = '++' | '--'; \n</code></pre><p>在我们升级后的语法规则中，二元表达式能够分解成一元表达式，而一元表达式，又分成下面这三种情况。</p><p>第一种情况下，一元表达式就是一个基础表达式。</p><p>第二种情况是一个右递归的语法规则，可以由一个前缀一元运算符再加一个一元表达式组成，所以我们前面的“+ +myage”的表达式是正确的。</p><p>第三种情况，是一个基础表达式后面再跟上后缀一元运算符。后缀一元运算只有++和–两个，并且是不允许递归的，也就是说，像“myage++ ++”这样的表达式就是错误的。</p><p>具体解析一元表达式的代码你可以参见<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/06/parser.ts#L747\">parseUnary函数</a>。</p><p>我们可以试着用支持一元运算符的解析器解析下面的示例程序，这个示例程序中有很多个+号和-号，你第一眼看上去可能很难判断出它们分别属于哪个语法成分。</p><pre><code class=\"language-plain\">//示例代码：example_unary.ts\nlet myAge:number = 18;\nmyAge = + +myAge++ + - - -10;\nprintln(\"myAge=\"+myAge);\n</code></pre><p>但基于我们的语法规则，我们的解析器能够准确地分析出每个+号或-号所属的语法成分。比如，对于第二个语句，我们的解析器输出的AST是下图这个样子的，其中1个+号属于加法表达式，有两个+号和3个-号的都属于前缀一元运算符，而++号则属于后缀运算符。</p><p><img src=\"https://static001.geekbang.org/resource/image/99/d6/9953723ddd7652a53a42972384258ed6.jpg?wh=1485x557\" alt=\"图片\"></p><p>那到此为止，我们的语法分析功能就升级完毕了。接下来，我们顺着已经养成的习惯，继续来看看这两个语句在语义方面有没有带来新的内容。</p><h2>语义分析：深化对作用域的理解</h2><p>你会发现，在程序里用上if语句和for语句以后，一个直观的表现就是出现了很多的语句块，而这些语句块是能够影响作用域的。我们把这些语句块所构成的作用域，叫做<strong>块作用域</strong>。</p><p>在早期的JavaScript版本是不支持块作用域的，比如，在下面的程序中，我们在块的外面仍然可以访问变量i，并且打印出i的值。</p><pre><code class=\"language-plain\">function foo(){\n    {\n        var i = 4;\n    }\n    console.log(i);\n}\nfoo();\n</code></pre><p>但在ES6版本以后，JavaScript也支持了块作用域。你可以用let关键字在块中声明变量，这个变量的作用域仅限于当前块，如果从作用域外面访问，编译器就会报错。</p><pre><code class=\"language-plain\">function foo(){\n    {\n        let i = 4;\n    }\n    console.log(i);   //报编译错误\n}\nfoo();\n</code></pre><p>在这种情况下，即使是块中变量的名称与块外的变量名相同也没关系。你看，在下面这个示例程序中，if语句块中的myAge和外面的myAge就是两个不同的变量，甚至类型都不相同。</p><pre><code class=\"language-plain\">function bar() {\n    let myAge = 18;\n    if (myAge &lt; 30) {\n        let myAge = '';\n        myAge = 'young';\n        console.log(\"myAge, inside: \" + myAge);\n    }\n    console.log(\"myAge, outside: \" + myAge);\n}\n</code></pre><p>这个程序是可以正常运行的，在if块的内部和外部，都可以正常的打印myAge的值，但使用的是两个不同作用域中的变量。</p><p>你也看到了，块作用域的机制使得我们在语句块中使用变量名称的时候可以更加自由，不用担心在块中声明的变量会影响到块外面，从而减少了程序出错的概率，也让程序员在书写逻辑的时候更加自由。</p><p>而且，上面的示例程序在编译过程中会形成下面这个Scope结构。你会看到，每个Block都形成了自己的作用域，所有这些作用域构成了一个树状结构。每个作用域，可以看到在该作用域中声明的符号，以及上面各级的符号，但看不到兄弟作用域和下级作用域的符号。</p><p><img src=\"https://static001.geekbang.org/resource/image/90/bb/909ec4737444573f6497d812fab39bbb.jpg?wh=1187x292\" alt=\"图片\"></p><p>你要注意，if语句的条件部分和if下面的块其实属于两个作用域。在if条件中的myAge变量，指的是外面的这个myAge，它是number型的，因此我们把它用在“myAge&lt;30”这样一个条件表达式里。</p><p>读到这里，你可能产生一个疑问：在语句块中，如果在声明新的myAge之前，是否也可以像在if的条件表达式里那样来使用外部的myAge变量呢？我们可以试一下，把程序改成下面的样子，看看会产生什么结果。</p><pre><code class=\"language-plain\">function bar() {\n    let myAge = 18;\n    if (myAge &lt; 30) {\n        myAge = 30;\n        let myAge = '';\n        myAge = 'young';\n    }\n}\n</code></pre><p>你会发现，如果我们用Typescript编译，编译器会报错，说块中的myAge在没有初始化的时候，就被访问了：</p><p><img src=\"https://static001.geekbang.org/resource/image/56/94/566c472686675e49b5a2b4cccfef0794.png?wh=1290x276\" alt=\"图片\"></p><p>这个例子说明了，在TypeScript中，如果存在和外部同名的变量，那你只能引用块中声明的变量，是没有办法引用外部变量的，无论块中声明的变量的位置是靠前还是靠后。</p><p>那是不是所有的语言，对于块作用域都是这样规定的呢？不是的，你可以用不同的语言试验一下。</p><p>首先是Java语言。Java语言也支持块定义域，但不允许块中的变量与外部变量名称相同。</p><pre><code class=\"language-plain\">public static int bar(){\n    int  myAge = 18;\n    if (myAge &lt; 30) {\n        string myAge = \"young\"; //错误：变量名称重复\n        int yourAge = 20;    //块中的变量\n    }     \n    else{\n        int yourAge = 10;    //第二个块中可以有同名的变量\n    } \n    return myAge + yourAge;  //错误：找不到yourAge\n}\n</code></pre><p>再看看C语言。C语言允许在块中声明新的变量名称之前，引用外部的变量，也就是说，上面的示例代码如果用C语言改写一下，也是完全合法的。</p><pre><code class=\"language-plain\">void bar(){\n    int myAge = 18;\n    if (myAge &lt; 30) {\n        myAge = 30;      //给外层的myAge赋值\n        const char* myAge = \"young\";  //新声明一个myAge\n        printf(\"myAge=%s\\n\",myAge);   //打印内层的myAge的值\n    }\n    printf(\"myAge=%d\\n\",myAge);       //打印外层的myAge的值\n}\n</code></pre><p>那么，对于你日常使用的语言，在块作用域的语义上有什么不同呢？你也可以分析一下。</p><p>按照这节课对作用域的剖析方法，下次你再见到一段代码的时候，你可以迅速在大脑中划分出清晰的作用域的范围，形成作用域的树。作为语言的实现者，你也会对语言的特性有更加清晰的了解，这算是你学习这门课的额外收获吧！</p><p>那么，上面这些不同语言对于作用域的不同规定，会如何影响到语义分析程序呢？我们来看一下。</p><p>在前面的课程中，我们做语义分析的时候，分成了清晰的两个阶段：Enter阶段是建立符号表，Resolve阶段是去做引用消解。如果存在块内外变量同名的情况，在块中的变量引用，都会指向在块中声明的变量。</p><p>这种处理方法，对于C语言是不行的。使用上述方法，会导致第一个myAge引用的变量出错。也就是说，我们在做引用消解的时候，必须考虑语句的顺序，要注意我们在块中声明同名称的myAge之前，引用的实际是块外面的变量。</p><p>这就导致为C语言编写引用消解的程序要更复杂一些，建立符号表的工作和引用消解的工作必须是针对每一条语句同步去进行的。随着对每一个语句的扫描，符号表逐渐建立起来后，引用消解时总是指向最近的那一个声明。</p><p>我们现在的处理方法，用来处理Java程序，其实也是行不通的。在Java的块里，虽然不允许变量跟外部变量重名，但也必须是先声明后使用，所以也只能一边建符号表，一边做引用消解，这样才能发现在声明之前使用变量的错误。</p><p>那么，我们现在的处理方法，针对TypeScript或JavaScript（指ES6以上的版本）是不是就没有问题了呢？</p><p>其实还是有问题的，现在的算法没有办法检查出myAge在声明在前就被引用的错误，并像在Node.js里运行那样报错。</p><p>那要如何解决这个问题呢？其实只要把问题分析清楚了，解决起来也不是太难。</p><p>在我们的语义分析程序中，我们先用Enter类对AST做了一遍遍历，把包括变量的每个符号都正确地加入到了符号表中，也就是由Scope形成的一个层次数据结构。接下来，我们用RefResolver类对AST再做一次遍历，来建立引用消解，但在这次遍历中，我们用了一个临时的数据结构，来保存当前已经声明了的变量。</p><p>这样做的目的，是在引用消解的时候，我们既要看该变量是否属于该作用域，又要看当前该变量是否被声明了。如果该变量不属于当前作用域，那么我们就去引用外部作用域中的变量；而如果该变量属于当前作用域，那它必须在变量声明之后才能使用。</p><p>比如，对于下面程序中的\"myAge = 30\"这一行，编译器会认为这个myAge是块中声明的那个string类型的myAge，而不是外部作用域中的myAge。同时，由于目前块中的myAge还没有声明，如果提前使用它是错误的。</p><pre><code class=\"language-plain\">function bar() {\n    let myAge = 18;\n    if (myAge &lt; 30) {\n        myAge = 30;  //编译错误\n        let myAge = '';\n        myAge = 'young';\n    }\n}\n</code></pre><p>我们可以画一张图来表现当编译器遍历到“myAge=30;”这个语句的时候，相关内部状态信息的情况，以及编译器是如何决策的。</p><p><img src=\"https://static001.geekbang.org/resource/image/e6/8d/e6ca00082597ae94a836b2689432a98d.jpg?wh=1920x1080\" alt=\"图片\"></p><p>你看，在遍历AST的过程中，我们的语义分析程序会不断更新一个集合中的值，这个集合就是“已声明的变量”。同时，我们的语义分析程序还会知道当前作用域中变量的集合的值。对比这两个集合的值，程序就会发现那些在声明之间就被使用的变量，并报错。</p><p>这种随着程序的执行流程，去动态计算一些数据的值，并根据这些值来做分析的方法，叫做<strong>数流分析框架</strong>。数据流分析框架在做语义分析和代码优化的时候都很有用，我们后面还会见到它的更多用途。</p><p>好了，理解了原理，写代码就简单了，你可以参考<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/06/semantic.ts#L203\">RefResolver类</a>中我给出的示例代码。</p><p>不过，关于引用消解，我还要再补充两个语义规则，这两个规则我们也要在算法中有所体现：</p><p>第一，在TypeScript中，函数的声明和引用的顺序是不受限制的。也就是说，完全可以声明在后，使用在前。所以，在引用消解程序中，处理变量的消解算法和函数的消解的算法是不同的。</p><p>第二，在同一个作用域中，不可以有名称相同的符号，变量和函数的名称也不可以冲突。所以，我在Scope类的设计中，使用了一个以名称为key，以符号为value的Map对象来保存该作用域中的符号，就隐含了名称唯一的要求。</p><p>好了，关于语义分析工作，我们就到这里。接下来，我们继续完成这节课的工作，让我们目前的解释器也能支持if语句和for语句。</p><h2>升级解释器</h2><p>首先看if语句。在解释器里，我们实现了visitIfStatement()方法，用于执行if语句。你可以看看下面的这个示例代码：</p><pre><code class=\"language-plain\"> /**\n * 执行if语句\n * @param ifStmt \n */\nvisitIfStatement(ifStmt:IfStatement):any{\n    //计算条件\n    let conditionValue = this.needLeftValue(this.visit(ifStmt.condition));\n    //条件为真，则执行then部分\n    if (conditionValue){ \n        return this.visit(ifStmt.stmt);\n    }\n    //条件为false，则执行else部分\n    else if (ifStmt.elseStmt !=null){ \n        return this.visit(ifStmt.elseStmt);\n    }\n}\n</code></pre><p>这个逻辑是很清晰的。首先我们来计算if条件的值，如果为真，则执行if后面的语句或语句块；如果为假，则执行else后面的语句或语句块。</p><p>实现for循环的思路也差不多，遵循for语句的语义来运行就行了，你可以参考下面的示例代码：</p><pre><code class=\"language-plain\">/**\n * 执行for语句\n * @param forStmt \n */\nvisitForStatement(forStmt:ForStatement):any{\n    //执行init\n    if(forStmt.init !=null){\n        this.visit(forStmt.init);\n    }\n\n    //计算循环结束的条件\n    let notTerminate = forStmt.termination == null ? true : this.visit(forStmt.termination);\n    while(notTerminate){\n        //执行循环体\n        let retVal = this.visit(forStmt.stmt);\n        //处理循环体中的Return语句\n        if (typeof retVal == 'object' &amp;&amp; ReturnValue.isReturnValue(retVal)){\n            // console.log(\"is ReturnValue!!\")\n            return retVal;\n        }\n\n        //执行递增部分\n        if (forStmt.increment!=null){\n            this.visit(forStmt.increment);\n        }\n\n        //执行循环判断\n        notTerminate = forStmt.termination == null ? true : this.visit(forStmt.termination);\n    }\n}\n</code></pre><p>其中，循环的初始化部分在一开始执行的，而且只执行一次，接着我们就要计算循环的终止条件。如果不满足终止条件，则开始进入循环。每次循环，首先执行循环体，然后执行递增部分的语句，最后再检查一遍循环退出条件。</p><p>你可以写几个例子来测试if语句和for循环语句是否能正确运行。在这里，我提供了一个计算斐波那契数列的示例程序给你参考：</p><pre><code class=\"language-plain\">function fibonacci(n:number):number{\n    if (n &lt;= 1){\n        return n;\n    }\n    else{\n        return fibonacci(n-1) + fibonacci(n-2);\n    }\n}\n\nfor (let i:number = 0; i&lt; 32; i++){\n    println(fibonacci(i));\n}\n</code></pre><p>这个程序不仅演示了if语句和for循环，还演示了函数的递归调用。运行这个程序，就会打印出一个斐波那契数列，如下图所示：<br>\n<img src=\"https://static001.geekbang.org/resource/image/9b/81/9b9789a30a96f26714124649493f4581.png?wh=454x1328\" alt=\"图片\"></p><h2>课程小结</h2><p>好了，到这里我们今天这节课就讲完了，我们来简单回顾一下。</p><p>这节课我们增加了对流程控制类语句的支持。在支持了if语句和for循环语句之后，我们的语言特性已经很丰富了，我们已经可以用这些特性编写很复杂的程序了，比如生成斐波那契数列的示例程序。</p><p>在这个过程中，<strong>最重要的知识点是对块作用域的理解</strong>。不同的语言在块作用域上的特性是不同的，所以我们要采用不同的算法来做引用消解。</p><p>TypeScript允许在块中声明新的变量覆盖外部作用域中的变量，块中所有该名称的变量都会引用这个新变量，但必须先声明再使用。TS的这个特点，就要求我们的算法要采用数据流分析框架，在遍历AST的过程中，知道某个变量在当前代码的位置是否已经被声明过了。你先把数据流分析框架记住，它非常有用，我们后面还会有很多场景要用到它。</p><p>此外，我们为了支持For循环，还增加了对一元运算符的支持。像++和–这样的运算符，在求值和未来生成字节码方面都有一些特殊性，你可以多注意示例代码对它们的处理。</p><h2>思考题</h2><p>今天的思考题，我想问一下，对于for循环语句来说，一般包含几层的作用域？为什么？你可以运行一个例子，看看打印出来的符号表的层次，验证一下你的想法，欢迎在留言区留言。</p><p>感谢你和我一起学习编程语言，也欢迎你将这门课分享给更多对编程语言感兴趣的朋友。我是宫文学，我们下节课见。</p><h2>资源链接</h2><p><a href=\"https://gitee.com/richard-gong/craft-a-language/tree/master/06\">这节课的示例代码在这里！</a></p>","neighbors":{"left":{"article_title":"05｜函数实现：是时候让我们的语言支持函数和返回值了","id":408912},"right":{"article_title":"07｜怎么设计属于我们自己的虚拟机和字节码？","id":410442}}},{"article_id":410442,"article_title":"07｜怎么设计属于我们自己的虚拟机和字节码？","article_content":"<p>你好，我是宫文学。</p><p>到目前为止，我们的语言看上去已经有点像模像样了。但是有一个地方，我还一直是用比较凑合的方式来实现的，这就是<strong>解释器</strong>，这节课我想带你把它升级一下。</p><p>在之前的内容中，我们用的解释器都是基于AST执行的，而实际上，你所能见到的大多数解释执行的脚本语言，比如Python、PHP、JavaScript等，内部都是采用了一个虚拟机，用字节码解释执行的。像Java这样的语言，虽然是编译执行，但编译的结果也是字节码，JVM虚拟机也能够解释执行它。</p><p>为什么这些语言都广泛采用虚拟机呢？这主要是由基于AST的解释器的不足导致的。今天这节课，我就带你先来分析一下AST解释器的缺陷，然后了解一下像JVM这样的虚拟机的运行原理，特别是栈机和寄存器机的差别，以便确定我们自己的虚拟机的设计思路。</p><p>看上去任务有点多，没关系，我们一步一步来，我们先来分析一下基于AST的解释器。</p><h2>基于AST的解释器的缺陷</h2><p>其实，我们目前采用的解释器，是一种最简单的解释器。它有时被称为“树遍历解释器”(Tree-walking Interpreter)，或者更简单一点，也被叫做“AST解释器”。</p><p>为什么我刚刚会说我们这个基于AST的解释器有点凑合呢？你可能会想通过遍历AST来执行程序不是挺好的吗？</p><!-- [[[read_end]]] --><p>确实，AST解释器虽然简单，但很有用。比如，最常见的就是对一个表达式做求值，实现类似公式计算的功能，这在电子表格等系统里很常见。甚至在MySQL中，也是基于AST做表达式的计算，还有一些计算机语言的早期版本（如Ruby），以及一些产品中自带的脚本功能，也是用AST解释器就足够了！</p><p>不过，虽然AST解释器很有用，但它仍然有明显的缺陷。<strong>最主要的问题，就是性能差，在运行时需要消耗更多的CPU时间和内存。</strong>在上一节课里，你可能使用过我们的函数特性计算过斐波那契数列，在参数值比较大的情况下（比如n大于30以后），你会看到程序的运行速度确实比较慢。</p><p>为什么会这样呢？你再来看我们的解释器，会发现它哪怕只是做一个表达式求值，也要层层做很多次的函数调用。比如，简单的计算2+3*5，需要做的调用包括：</p><pre><code class=\"language-plain\">visitBlock()\n  visitStatement()\n    visitExpressionStatement()\n      visitBinary()   //+号\n        visitIntegerLiteral() //2\n        visitBinary() //*号\n          visitIntegerLiteral() //3\n          visitIntegerLiteral() //5\n</code></pre><p>从表面上看起来，这只是做了8次的函数调用。其实，如果你仔细看我们代码的细节，就会发现，由于我们的程序采用了Visitor模式，每一次调用还都有一个Visitor.visit(AstNode)和AstNode.accept(Visitor)来回握手的过程，所以加起来一共做了24次函数调用。</p><p>这样的函数调用的开销是很大的。在上一节课，你已经知道了，每次函数调用都需要创建一个栈桢，这会导致内存的消耗。调用函数和从函数返回，也都需要耗费额外的CPU时间。在后面的课程里，等我们对程序的运行时机制的细节了解得更清楚以后，你会更加理解这些额外的开销发生在什么地方。</p><p>除了性能问题，AST解释器还有其他的问题。比如，我们已经看到，在实现Return语句的时候，需要额外的冗余处理，以便跳过Return后面的语句，类似的情况还发生在Break、Continue等语句中。总的来说，在控制流的跳转方面，用AST都不方便。</p><p>还有，我们执行函数调用的时候，需要从函数调用的AST节点跳到函数声明的节点，这让人有点眼花缭乱。如果我们后面支持类、Lambda等更加丰富的特性，需要运行类的构造函数、进行类成员的初始化，查找并执行正确的父类或子类的方法，那么程序的执行过程会更加让人难以理解。</p><p>而且，从根本上来说，AST这种数据结构，比较忠实地体现了高级语言的语法特征。而高级语言呢，是设计用来方便人类理解的，并不是适合机器执行的。把计算机语言从适合人类阅读，变成适合机器执行，本来就是编译器要做的事情。不过，把高级语言变成AST，我们叫做解析（Parse），还不能称上是编译（Compile）。要称得上编译，要对程序的表示方式做更多的变换才行。</p><p>那接下来呢，我们就探讨一下如何把程序编译成对机器更友好的方式。按照循序渐进的学习原则，我们不会一下子就编译成机器码，而是先编译成字节码，并试着实现一个虚拟机。</p><h2>初步了解虚拟机</h2><p>说到虚拟机，我们大多数人都不陌生。比如Java语言最显著的特征之一，就是运行在虚拟机上，而不是像C语言或Go语言那样，编译成可执行文件直接运行；.NET也是用了类似的架构。就算现在Java支持AOT（Ahead of Time）编译方式了，它的可执行文件中仍然打包了一个小型的虚拟机，以便支持某些特别的语言特性。</p><p>至于其他语言，如Python、JavaScript等，虽然我们不怎么提及它们的虚拟机，但它们通常都是基于虚拟机来运行的。</p><p>虚拟机如此流行，不是偶然现象，因为它提供了一些明显的优点。其中最值得注意的，就是<strong>程序可以独立于具体的计算机硬件和操作系统而运行</strong>。所以，我们在任何设备上，无论是Mac电脑、Windows电脑、安卓手机还是iPad，都可以用浏览器打开一个页面，并运行里面的JavaScript。而如果采用C语言那样的运行方式，那么针对每种不同的CPU和操作系统的组合，都要生成不同的可执行文件，这对于像浏览器一样的很多应用场景，显然都是很麻烦的。</p><p>虚拟机还能提供其他好处，比如通过托管运行提供更高的安全性，还有通过标准的方式使用不同计算机上的文件资源、网络资源、线程资源和图形资源等等。</p><p>实际上，虚拟化是计算机领域的一个基本思路。比如，云计算平台能够虚拟出很多不同的操作系统，在基于ARM芯的Mac上可以仿真运行基于X86的Windows等等，都是不同角度的虚拟化。</p><p><strong>所以说，要实现一门现代计算机语言，就不能忽视虚拟机方面的知识。</strong></p><p>那语言的虚拟机都要包含哪些功能呢？又是由哪些部分构成的呢？</p><p>介绍虚拟机的文章很多，特别是针对像JVM和安卓的ART这样广泛使用的平台，有专门的书籍和课程来深入剖析。在我们的课程里，由于我们自己要实现一下虚拟机，因此我也会简单介绍一下虚拟机的原理和构成，当然更多的就要靠你动手实践来掌握虚拟机的精髓了。</p><p>总的来说，虚拟机可以看做是一台虚拟的计算机，它能像物理计算机一样，给程序提供一个完整的运行环境。</p><p>首先，虚拟机像物理计算机一样，会支持一个指令集。我们的程序按照这个指令集编译成目标代码后，就可以在虚拟机上执行了。</p><p>第二，虚拟机也像物理计算机一样，提供内存资源。比如在JVM中，你可以使用栈和堆两种内存。根据不同语言的内存管理机制的不同，在虚拟机里通常还要集成垃圾收集机制。</p><p>第三，虚拟机要像物理计算机一样，能够加载程序的代码并执行。程序的目标代码文件中，除了可执行的代码（也就是虚拟机指令），还会包含一些静态的数据，比如程序的符号表，这会让你的程序支持元编程功能，比如运行时的类型判断、基于反射来运行代码等等。静态数据还包括程序中使用的一些常量，比如字符串常量、整数常量等等。对于代码和静态数据，会被虚拟机放在特定的区域，并且能够被指令访问。</p><p>此外，虚拟机还要在IO、并发等方面提供相应的支持。这样，我们才可以实现像在终端打印字符这样的功能。</p><p>好了，我们已经大概了解了虚拟机相关的概念。不过，不同的虚拟机在运行代码的机制方面是有所区别的，这也会影响到字节码的设计和算法的实现，所以我们现在展开介绍一下。</p><p>你可能听说过寄存器机和栈机，这就是比较流行两种程序运行机制。</p><h2>栈机和寄存器机</h2><p>使用栈机的典型代表，就是JVM，它能够运行Java的字节码。Web Assembly是为浏览器设计的字节码，它的设计也是栈机的架构。</p><p>使用寄存器机的典型代表是能够运行JavaScript的V8，V8里面有一个基于寄存器机的字节码解释器。而Lua和Erlang内部也是采用了寄存器机作为程序的运行机制，其实我们现在使用物理计算机，也是寄存器机。</p><p><strong>栈机和寄存器机的主要区别，是获取操作数的方式不同：栈机是从操作数栈里获取操作数，而寄存器机是从寄存器里获取。</strong>比如要计算“a+3”这个表达式，虚拟机通常都提供了一个指令用来做加法。a和3呢，则是加法指令的操作数，其中a是一个本地变量，其值为2，另一个操作数是常量3。那怎么完成这个加法操作呢？</p><p>栈机的运行方式，是先把a的值从内存取出来，压到一个叫做操作栈的区域（使用load指令），然后把常量3压到操作数栈里（使用push指令），接着执行add指令。在执行add指令的时候，就从操作数栈里弹出a和3，做完加法以后，再把结果5压到栈里。<br>\n<img src=\"https://static001.geekbang.org/resource/image/99/d9/99753bda45c78379ffe7ab1276cb7bd9.jpg?wh=1407x777\" alt=\"\"><br>\n而寄存器机的运行方式，是先把a的值加载到寄存器，在执行add指令的时候，从这寄存器取数，加上常量3以后，再把结果5放回到寄存器。<br>\n<img src=\"https://static001.geekbang.org/resource/image/4a/3c/4a3329c35a7694c279a27697e8b1453c.jpg?wh=1708x812\" alt=\"\"><br>\n总结起来，栈机和寄存器机的区别有这三个方面：</p><p><strong>第一，操作数的存储机制不同</strong>。栈机的操作数放在操作栈，操作数栈的大小几乎不受限制；而寄存器机的操作数是放在寄存器里，寄存器的数量是有限的。需要说明的是，对于物理机来说，寄存器指的是物理寄存器；而对于虚拟机来说，寄存器通常只是几个本地变量。但因为这些变量被频繁访问，根据寄存器分配算法，它们有比较大的概率被映射成物理寄存器，从而大大提高运行性能。</p><p><strong>第二，指令的格式不同</strong>。寄存器机的指令，需要在操作数里指定运算所需的源和目的操作数。而栈机的运算性的指令，比如加减乘除等，是不需要带操作数的，因为操作数就在栈顶；而像push、load这样的指令，是把数据压到栈里，也不需要指定目的地，因为这个数据也一定是存到栈顶的。</p><p><strong>第三，生成字节码的难度不同</strong>。从AST生成栈机的代码是比较容易的，你在后面就可以体会到。而生成寄存器机的代码的难度就更高一些，因为寄存器的数量是有限的，我们必须要添加寄存器分配算法。</p><p>了解了栈机和寄存器机的这些差别以后，我们就可以根据自己的需求做取舍。比如，如果要更关注运行性能，就选用寄存器机；而如果想实现起来简单一点，并且指令数量更少，便于通过网络传输，我们就可以用栈机。</p><p>好了，现在我们已经初步了解了两种运行机制和两类指令集的特点了，是时候设计我们自己的虚拟机和字节码了！</p><h2>设计我们自己的虚拟机</h2><p>设计一个虚拟机是一项挺有挑战的工作，不过，如果我们仍然采取先迈出一小步，然后慢慢迭代的思路，就没那么复杂了。</p><p>在实现一个虚拟机之前，有些关键的技术决策是要确定一下的，这些决策影响到虚拟机的特性和我们所采用的技术。</p><p><strong>决策1：选择栈机还是寄存器机？</strong></p><p>其实，栈机和寄存器都能满足我们对于程序运行的核心需求，因为我们目前对性能、字节码的大小都没有什么特别的要求。不过，经过思考，<strong>我最终选择了栈机</strong>，主要有这几个考虑：</p><p>首先，Java的JVM用的就是栈机，而且讲述JVM的资料也很多，方便我们借鉴和学习它成熟的设计思路。</p><p>第二，由于我们最后是要生成面向物理机的机器码，而物理机就是寄存器机，所以我们肯定会学到这方面的知识。从扩大知识面的角度，我们在虚拟机层面熟悉一下栈机就更好了。</p><p>第三，Web Assembly是一个很有前途的技术领域，目前各门语言都在添加编译成Web Assembly的工作。而自己动手实现一个栈机的经验，有助于我们理解Web Assembly，为未来支持Web Assembly打下基础。</p><p><strong>决策2：字节码如何设计？</strong></p><p>这个决策也简单。<strong>既然已经选择了栈机的机制，那就参考最成熟的Java的字节码就好了</strong>。这样，我们只要能生成类似于Java的字节码，就能保证编译程序的正确性。</p><p>说到这里，你其实还想到一个可能性：是不是可以把TypeScript编译以后，放在JVM上运行呢？</p><p>这是完全可能的，这样的工作也很有意义，你将来如果有需要可以做这样的一个实现。作为参考，我前一阵在技术会议上认识的一个极客朋友，做了一项很有意思的工作，就是把游戏领域的DSL编译成.NET的字节码，从而驱动游戏引擎。通过这个核心技术，他开发了一个低代码游戏开发平台，大大降低了开发游戏的成本，提高了开发效率。不过由于JVM不是我们这个课程的重点，我们这个课程就不去专门生成能跑在JVM上的字节码文件了。</p><p><strong>决策3：最先支持哪些数据类型？</strong></p><p>字节码的设计，跟语言特性是紧密相关的。比如，在Python的字节码中，所有操作都是针对对象的，因为在Python中，所有的数据都是对象化的。而在Java语言中，数据类型包括基础数据类型和对象两类，所以相应的指令也分为了两类，一类用于操作整型、浮点型等基础数据类型，一类用于操作对象。</p><p>TypeScript/JavaScript语言提供了number、string、boolean等内置数据类型，也支持自定义类型。但我们目前还没有探讨到像class这样的自定义类型机制。不过，到目前为止，我们的语言特性基本上只支持数值运算。</p><p><strong>所以第一步，我们就先只支持number类型就好了。甚至为了简单起见，我们就只支持整型运算就好了。</strong>一旦通过整型把整个实现机制跑通，再去支持其他数据类型也就没那么复杂了。</p><p><strong>决策4：采用什么语言来实现虚拟机？</strong></p><p>到目前为止，我们的课程采用的语言一直是TypeScript和JavaScript，但虚拟机却对运行性能的要求比较高，所以最好能够进行一些底层的控制，比如如何为栈桢分配内存、如何最高效地存储和访问常量等等，所以真实世界的虚拟机，大多是采用C和C++实现的。</p><p>所以在这节课中，我们采取这样的策略：<strong>一方面，采用TypeScript语言做原型</strong>，这样可以帮助我们迅速理清楚设计思路，掌握原理。<strong>另一方面，我们又会用C语言做一个参考实现</strong>，这样我们能够充分享受到采用基于字节码的虚拟机所带来的优点。好消息是，大部分同学都或多或少接触过C语言，所以理解和使用起来并不会特别困难。</p><h2>课程小结</h2><p>今天这节课，我们迈入了一个新的领域，也就是采用虚拟机作为新的运行机制。</p><p>相比我们之前运行的AST解释器，运行字节码的虚拟机的性能更高，更容易运行流程控制语句。而且，字节码也是更加面向机器的代码表示方式，因此也更便于机器运行，但不利于人类阅读。</p><p>而虚拟机中有一个重要部分，就是程序的运行机制。对运行机制的了解是你实现一门语言时所需要的基本功。今天我们初步介绍了栈机和虚拟机两种比较流行的程序运行机制的区别，主要是在操作数的存储机制、指令的格式和生成字节码的难度这三点上，在后面的课程里，你会对这两种运行机制有更加深入的了解。</p><p>最后，我们对虚拟机做了一些设计决策。我们选择了栈机，决定参考最成熟的Java的字节码，最先实现number类型和整型运算，而且我还会带你用TypeScript和C语言实现两种虚拟机。虽然这节课还没有做具体的实现，但理清设计思路可能比实现还重要，特别是面对虚拟机这样一个比较新的话题时。不要着急，我们下一节就会实现出一个简单的栈机！</p><h2>思考题</h2><p>你所使用的语言有没有内置一个虚拟机？有什么特点？里面有没有字节码解释器？它是栈机还是寄存器机？欢迎你和我分享一下。</p><p>另外，如果你是带着实际的项目需求来学习这门课程的。那么，对于你的需求，AST解释器是否够用，还是要必须采用其他的运行机制？为什么？</p><p>感谢你和我一起学习，如果你觉得我这节课讲得还不错，也欢迎你把它分享给更多对编程语言感兴趣的朋友。我是宫文学，我们下节课见。</p>","neighbors":{"left":{"article_title":"06｜怎么支持条件语句和循环语句？","id":409811},"right":{"article_title":"08｜基于TypeScript的虚拟机（一）：实现一个简单的栈机","id":411227}}},{"article_id":411227,"article_title":"08｜基于TypeScript的虚拟机（一）：实现一个简单的栈机","article_content":"<p>你好，我是宫文学。</p><p>上一节课，我们已经探讨了设计一个虚拟机所要考虑的那些因素，并做出了一些设计决策。那么今天这一节课，我们就来实现一个初级的虚拟机。</p><p>要实现这个初级虚拟机，具体来说，我们要完成下面三方面的工作：</p><p>首先，我们要设计一些字节码，来支持第一批语言特性，包括支持函数、变量和整型数据的运算。也就是说，我们的虚拟机要能够支持下面程序的正确运行：</p><pre><code class=\"language-plain\">//一个简单的函数，把输入的参数加10，然后返回\nfunction foo(x:number):number{\n    return x + 10;\n}\n//调用foo，并输出结果\nprintln(foo(18));\n</code></pre><p>第二，我们要做一个字节码生成程序，基于当前的AST生成正确的字节码。</p><p>第三，使用TypeScript，实现一个虚拟机的原型系统，验证相关设计概念。</p><p>话不多说，开搞，让我们先设计一下字节码吧！</p><h2>“设计”字节码</h2><p>说是设计，其实我比较懒，更愿意抄袭现成的设计，比如Java的字节码设计。因为Java字节码的资料最充分，比较容易研究，不像V8等的字节码，只有很少的文档资料，探讨的人也很少。另外，学会手工生成Java字节码还有潜在的实用价值，比如你可以把自己的语言编译后直接在JVM上运行。那么我们就先来研究一下Java字节码的特点。</p><!-- [[[read_end]]] --><p>上面的用TypeScript编写的示例代码，如果用Java改写，会变成下面的程序：</p><pre><code class=\"language-plain\">//实现同样功能的Java程序。\npublic class A{\n    public static int foo(int a){\n        return a + 10;\n    }\n    public static void main(String args[]){\n        System.out.println(foo(8));\n    }\n}\n</code></pre><p>我们首先把这个Java程序编译成字节码。</p><pre><code class=\"language-plain\">javac A.java\n</code></pre><p>这个文件是一个二进制文件。我们可以用hexdump命令查看它的内容。</p><pre><code class=\"language-plain\">hexdump -C A.class\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/19/2e/19380b1b13c608e9db8c842a3a7de92e.jpg?wh=1492x1199\" alt=\"图片\"></p><p>从hexdump显示的信息中，你能看到一些可以阅读的字符，比如“java/lang/Object”、\"java/lang/System\"等等，这些是常量表中的内容。还有一些内容显然不是字符，没法在屏幕上显示，所以hexdump就用一个.号来表示。其中某些字节，代表的是指令，我在图中把代表foo函数、main函数和构造函数的指令标注了出来，这些都是。用于运行的字节码指令，其他都是一些符号表等描述性的信息。</p><p>通过上图，你还能得到一个直观的印象：<strong>字节码文件并不都是由指令构成的</strong>。</p><p>没错，指令只是一个程序文件的一部分。除了指令以外，在字节码文件中还要存储不少其他内容，才能保证程序的正常运行，比如类和方法的符号信息、字符串和数字常量，等等。至于字节码文件的格式，是由字节码的规范来规定的，你有兴趣的话，可以按照规范生成这样的字节码文件。这样的话，我们的程序就可以在JVM上运行了。</p><p>不过，我现在不想陷入字节码文件格式的细节里，而是想用自己的方式生成字节码文件，够支持现在的语言特性，能够在我们自己的虚拟机上运行就行了。</p><p>上面这张图显示的字节码文件不是很容易阅读和理解。所以，我们用javap命令把它转化成文本格式来看看。</p><pre><code class=\"language-plain\">javap -v A.class &gt; A.bc\n</code></pre><p>在这个新生成的文件里，我们可以清晰地看到每个函数的定义以及指令，我也在图里标注了主要的指令的含义。</p><p><img src=\"https://static001.geekbang.org/resource/image/c9/a1/c90344b05e25ffae95a2c3e9e1a804a1.jpg?wh=1328x1265\" alt=\"图片\" title=\"文本格式的字节码文件\"></p><p>看到这个字节码文件的内容，你可能会直观地觉得：这看上去跟我们的高级语言也没有那么大的区别嘛。程序照样划分成几个函数，只不过每个函数里的语句变成了栈机的指令而已，函数之间照样需要互相调用。</p><p>实际上也确实没错。字节码文件里本来就存储了各个类和方法的符号信息，相当于保存了高级语言里的主体框架。当然，每个方法体里的代码就看不出if语句、循环语句这样的结构了，而是变成了字节码的指令。</p><p>通过研究这些指令，加上查阅<a href=\"https://docs.oracle.com/javase/specs/jvms/se12/html/jvms-6.html\">JVM规则</a>中对于字节码的规定，你会发现为了实现上面示例代码中的功能，我们目前只需要这几个指令就够了：</p><p><img src=\"https://static001.geekbang.org/resource/image/60/20/608cdfd47efe1e162e8bd7ca88f1d420.jpg?wh=1919x1265\" alt=\"图片\"></p><p><img src=\"https://static001.geekbang.org/resource/image/55/f6/55334d4a30a41ed87bf7bc82c64c9ef6.jpg?wh=1920x1220\" alt=\"图片\" title=\"常数入栈指令\"></p><p><img src=\"https://static001.geekbang.org/resource/image/e5/8b/e52ef425d612381fe33628818c75c68b.jpg?wh=1920x1166\" alt=\"图片\" title=\"二元运算指令，以及函数调用和返回指令\"></p><p>你先花一两分钟看一下这些指令，看上去挺多，其实可以分为几组。</p><p>首先是iload系列，这是把指定下标的本地变量入栈。注意，变量的下标是由声明的顺序决定的，参数也算本地变量，并且排在最前面。所以，iload 0的意思，就是把第一个参数入栈。如果没有参数，就是把第一个本地变量入栈。</p><p>iload后面的那几个指令，是压缩格式的指令，也就是利用指令末尾富余的位，把操作数和指令压缩在了一起，这样可以少一个字节码，能够缩小最后生成的字节码文件的大小。从这里面，你能借鉴到字节码设计的一些好的实践。所以你看，学习成熟的设计是有好处的吧？</p><p>第二组是istore系列，它做的工作刚好跟iload相反，是把栈顶的值存到指定下标的变量里去。</p><p>第三组，是对常数做入栈的操作。对于0~5这几个数字，Java字节码也是提供了压缩格式的指令。对于8位整数（-128~127），使用bipush指令。对于16位整数（-32768~32767），使用sipush指令。而对于更大的常数，则要使用ldc指令，从常量池里去取。</p><p>第四组，是几个二元运算的指令。它们都是从栈里取两个操作数，计算完毕之后，再压回栈里。</p><p>最后一组指令，是函数调用和返回的指令。函数调用的时候，也是从栈里取参数。返回值呢，则压回栈里。</p><p>通过这些指令，我们就完全能够实现一些基本的功能了，之后我们再根据需要添加更多的指令就好。</p><p>现在，我们把这些指令做成枚举值，方便程序使用：</p><pre><code class=\"language-plain\">/**\n * 指令的编码\n */\nenum OpCode{\n    iconst_0= 0x03,\n    iconst_1= 0x04,\n    iconst_2= 0x05,\n    iconst_3= 0x06,\n    iconst_4= 0x07,\n    iconst_5= 0x08,\n    bipush  = 0x10,  //8位整数入栈\n    sipush  = 0x11,  //16位整数入栈\n    iload   = 0x15,  //本地变量入栈\n    iload_0 = 0x1a,\n    iload_1 = 0x1b,\n    iload_2 = 0x1c,\n    iload_3 = 0x1d,\n    istore  = 0x36,\n    istore_0= 0x3b,\n    istore_1= 0x3c,\n    istore_2= 0x3d,\n    istore_3= 0x3e,\n    iadd    = 0x60,\n    isub    = 0x64,\n    imul    = 0x68,\n    idiv    = 0x6c,\n    ireturn = 0xac,\n    return  = 0xb1,\n    invokestatic= 0xb8, //调用函数\n}\n</code></pre><p>好了，我们通过全盘照抄的方式，“设计”出了自己所需要的字节码。不过这些都只是指令的部分。还要有常量池的部分，我们在下面使用到的时候再去设计。</p><p>接下来，我们来生成自己的字节码。</p><h2>生成字节码</h2><p>生成栈机的字节码是比较简单的。为什么呢？因为栈机的字节码基本上跟AST是同构的，通过深度优先的顺序遍历AST就可以实现。相对来说，生成寄存器机的指令的算法就要稍微绕一点，我们也会在后面的课程中体会到。</p><p>怎么来深度优先地遍历AST、生成栈机的字节码呢？以“3+a”这样一个简单的表达式为例，我们处理的顺序依次是字面量3、变量a和+号。</p><p>首先来处理字面量。处理整型字面量的时候，我们需要根据整数的不同长度，分别使用不同的常量指令。其中的一个细节是，当整数是16位时，操作数要拆成两个字节。而当大于16位时，我们干脆就把字面量放在常量池里，操作数只是该常数在常量池的索引值。</p><p>这里的处理你可以参照下面这个代码：</p><pre><code class=\"language-plain\">visitIntegerLiteral(integerLiteral: IntegerLiteral):any{\n    let ret:number[] = [];\n    let value = integerLiteral.value;\n    //0-5之间的数字，直接用快捷指令\n    if (value &gt;= 0 &amp;&amp; value &lt;= 5) {\n        switch (value) {\n            case 0:\n                ret.push(OpCode.iconst_0);\n                break;\n            ...省略1、2、3、4的情况\n            case 5:\n                ret.push(OpCode.iconst_5);\n                break;\n        }\n    }\n\n    //如果是8位整数，用bipush指令，直接放在后面的一个字节的操作数里就行了\n    else if (value &gt;= -128 &amp;&amp; value &lt;128){\n        ret.push(OpCode.bipush);\n        ret.push(value);\n    }\n\n    //如果是16位整数，用sipush指令\n    else if (value &gt;= -32768 &amp;&amp; value &lt;32768){\n        ret.push(OpCode.sipush);\n        //要拆成两个字节\n        ret.push(value &gt;&gt; 8);\n        ret.push(value &amp; 0x00ff);\n    }\n\n    //大于16位的，采用ldc指令，从常量池中去取\n    else{\n        //把value值放入常量池。\n        this.module.consts.push(value); \n        ret.push(this.module.consts.length -1);\n    }\n    return ret;\n}\n</code></pre><p>接着来处理变量a。在处理变量的时候，我们要区分左值和右值的情况。在“3+a”这个表达式中，a是个右值，我们需要取出a的值，也就是要生成iload指令。但对于“a=3”这样的表达式，a是个左值，这个时候返回a的符号即可，在处理赋值运算的时候再生成istore指令。</p><pre><code class=\"language-plain\">/**\n * 左值的情况，返回符号。否则，生成iload指令。\n * @param v \n */\nvisitVariable(v:Variable):any{\n    if (v.isLeftValue){\n        return v.sym;\n    }\n    else{\n        return this.getVariableValue(v.sym);\n    }\n}\n\n/**\n * 生成获取本地变量值的指令\n * @param varName \n */\nprivate getVariableValue(sym:VarSymbol|null):any{\n    if (sym != null){\n        let code:number[] = [];  //生成的字节码\n        //本地变量的下标\n        let index = this.functionSym?.vars.indexOf(sym);\n        assert(index != -1, \"生成字节码时（获取变量的值），在函数符号中获取本地变量下标失败！\");\n        //根据不同的下标生成指令，尽量生成压缩指令\n        switch (index){\n            case 0:\n                code.push(OpCode.iload_0);\n                break;\n            case 1:\n                code.push(OpCode.iload_1);\n                break;\n            case 2:\n                code.push(OpCode.iload_2);\n                break;\n            case 3:\n                code.push(OpCode.iload_3);\n                break;\n            default:\n                code.push(OpCode.iload);    \n                code.push(index as number);               \n        }            \n        return code;\n    }\n}\n\n</code></pre><p>然后，我们要对加减乘除这些二元运算来生成代码，我们可以先为左右子树分别生成代码，再把加减乘除的运算指令放在最后。注意，赋值运算的处理逻辑是不同的，它要生成istore指令。</p><pre><code class=\"language-plain\">visitBinary(bi:Binary):any{\n    let code:number[];\n    let code1 = this.visit(bi.exp1);\n    let code2 = this.visit(bi.exp2);\n\n    ////1.处理赋值\n    if (bi.op == Op.Assign){\n        let varSymbol = code1 as VarSymbol; \n        //加入右子树的代码\n        code = code2;\n        //加入istore代码\n        code = code.concat(this.setVariableValue(varSymbol));\n    }\n    ////2.处理其他二元运算\n    else{\n        //加入左子树的代码\n        code = code1;\n        //加入右子树的代码\n        code = code.concat(code2);\n        //加入运算符的代码\n        switch(bi.op){\n            case Op.Plus: //'+'\n                code.push(OpCode.iadd);\n                break;\n            case Op.Minus: //'-'\n                code.push(OpCode.isub);\n                break;\n            case Op.Multiply: //'*'\n                code.push(OpCode.imul);\n                break;\n            case Op.Divide: //'/'\n                code.push(OpCode.idiv);\n                break;\n            default:\n                console.log(\"Unsupported binary operation: \" + bi.op);\n                return [];\n        }\n    }\n    return code;\n}\n</code></pre><p>好了，到此这里，我们对处理基本的表达式就没有问题了。接下来，我们再增加与函数调用和返回有关的指令。</p><p>在进行函数调用的时候，我们要依次生成与参数计算有关的指令，最后生成invokestatic指令。</p><pre><code class=\"language-plain\">let code:number[] = [];\n//1.依次生成与参数计算有关的指令\nfor(let param of functionCall.paramValues){\n    let code = this.visit(param);\n    if (typeof code == 'object'){\n        code = code.concat(code as number[]);\n    }\n}\n//2.生成invoke指令\nlet index = this.module.consts.indexOf(functionCall.sym);\ncode.push(OpCode.invokestatic);\ncode.push(index&gt;&gt;8);\ncode.push(index);\nreturn code;\n</code></pre><p>然后，在处理return语句的时候，也要注意，我们要根据是否有返回值，分别生成ireturn和return指令。</p><pre><code class=\"language-plain\">let code:number[] = [];\n//1.为return后面的表达式生成代码\nif(returnStatement.exp != null){\n    let code1 = this.visit(returnStatement.exp);\n    if (typeof code1 == 'object'){\n        code = code.concat(code1 as number[]);\n        //生成ireturn代码\n        code.push(OpCode.ireturn);\n        return code;\n    }\n}\nelse{\n    //2.生成return代码，返回值是void\n    code.push(OpCode.return);\n    return code;\n}\n</code></pre><p>到这里，我们已经能够顺利的生成字节码了。生成字节码以后，接下来就只剩最后一步了：实现一个虚拟机，让这些字节码真正运行起来！</p><h2>实现一个TypeScript版本的虚拟机</h2><p>如果你是学习Java的同学，那你在面试的时候肯定经常会被问到与虚拟机有关的知识点。你也会根据自己了解的知识，对操作数栈、常量池等发表一通见解。但是，你心里多多少少对这些概念还会隔着一层面纱。</p><p>直到你自己亲自动手实现一遍，哪怕只是实现一个原型系统，你对这些概念，以及对虚拟机到底是如何运行的，才会有真真切切的理解。所以，我鼓励你动手实现一遍。而且，我可以告诉你，真的花不了多少时间。如果你看看我给出的示例代码，其实就是一个大函数，针对不同的字节码指令做处理而已。</p><p>不过，为了便于你理解代码，我还是先画一个虚拟机的示意图。我们这个简单的虚拟机主要涉及几个对象：</p><p><img src=\"https://static001.geekbang.org/resource/image/76/a0/76a4640bbe5c0d394c1ed8e330c214a0.jpg?wh=1584x1265\" alt=\"图片\"></p><p><strong>首先是模块。</strong>模块代表了我们的程序，模块里最重要的就是一个常量表。常量表中的常量包含字符串常量、数字常量和函数符号。而函数符号里有一个bytecode属性，保存了这个函数的字节码。这样，我们就可以找到函数的代码并运行它们了。</p><pre><code class=\"language-plain\">export class BCModule{\n  //常量\n  consts:any[] = [];\n  \n  //入口函数\n  _main:FunctionSymbol|null = null;\n}\n</code></pre><p><strong>然后是运行程序的栈机。</strong>栈机里最重要的数据结构是一个调用栈，在AST解释器里也有类似的数据结构。调用栈是由栈桢构成的，在执行每个函数的时候，都需要在栈顶新加一个栈桢，而在退出函数的时候，就会弹出这个函数的栈桢。</p><pre><code class=\"language-plain\">//栈机\nexport class VM{\n    //调用栈\n    callStack:StackFrame[]=[];\n    //执行一个模块\n    execute(bcModule:BCModule):number{\n    ...\n    }\n}\n</code></pre><p>你要注意，栈桢是一个关键的数据结构，它用来保存每个函数运行时所需要保存的状态信息。每个栈桢里又有几个关键的组成部分。</p><ul>\n<li>操作数栈：用来保存函数执行过程中各个指令所需要用到的操作数；</li>\n<li>存放本地变量的数组：可以在这里存取变量值；</li>\n<li>返回地址：也是在调用子函数的时候，告诉子函数返回以后，从哪条代码接着运行。</li>\n</ul><p>栈机里的execute方法，就是虚拟机的核心执行引擎。下面我摘一些有代表性的代码给你讲一下，你先看一下示例代码的结构。</p><pre><code class=\"language-plain\">//一直执行代码，直到遇到return语句\nlet opCode = code[codeIndex];\nwhile(true){\n    switch (opCode){\n        case OpCode.iconst_0: //加载常量\n            frame.oprandStack.push(0);\n            opCode = code[++codeIndex];\n            continue;\n        ...\n        case OpCode.sipush:  //加载32位常量，需要取出2个字节\n            let byte1 = code[++codeIndex];\n            let byte2 = code[++codeIndex];\n            frame.oprandStack.push(byte1&lt;&lt;8|byte2); \n            opCode = code[++codeIndex];\n            continue;\n        ...\n        case OpCode.iload_0: //从变量里取值\n            frame.oprandStack.push(frame.localVars[0]);\n            opCode = code[++codeIndex];\n            continue;\n        ...\n        case OpCode.istore_0: //给变量赋值\n            frame.localVars[0] = frame.oprandStack.pop();\n            opCode = code[++codeIndex];\n            continue;\n        ...\n        case OpCode.iadd:     //加减乘除\n            frame.oprandStack.push(frame.oprandStack.pop() + frame.oprandStack.pop());\n            opCode = code[++codeIndex];\n            continue;\n        ...\n    }\n}\n</code></pre><p>你可能马上会注意到，<strong>整个程序执行的过程就是一个大的while循环</strong>。</p><p>几乎所有的虚拟机的核心执行引擎都是这么写的，因为程序的执行过程就是不停地读取指令，然后根据指令做相应的动作。其中的代码计数器，一直指向下一个要执行的指令的位置。由于指令的种类比较多，所以switch后面会罗列很多个case，代码也会很长。你用电脑看这些代码的话，可能要翻很多屏。</p><p>虽然这个函数的代码很长，我们一般也不会把它拆成多个函数。为什么呢？这似乎违背了通常的编程理念呀。通常我们都不会编写太长的函数，这不容易阅读，也不容易维护。</p><p>但事情总有例外。对于虚拟机的执行引擎来说，性能上的考虑是第一位的。执行一个指令，可能开销并不大。但如果执行这条指令要调用一个专门的函数，那函数调用的额外开销会比执行指令本身的开销都大，那显然就不合理了，这也是我们为什么弃用AST解释器的原因。</p><p>我们这个示例代码中体现了加载常量、加载变量、保存变量和执行加减乘除的运算的实现方式。你能通过这些代码，再一次验证栈机的工作原理，这里所有操作都是围绕着操作数栈来进行的。</p><p>而函数的调用和返回，则显得复杂一点。这两部分代码，也有助于你更加细致的了解栈桢的使用方式。</p><p>首先我们来看看函数调用：</p><pre><code class=\"language-plain\">case OpCode.invokestatic:\n    //从常量池找到被调用的函数\n    byte1 = code[++codeIndex];\n    byte2 = code[++codeIndex];\n    let functionSym = bcModule.consts[byte1&lt;&lt;8|byte2] as FunctionSymbol;\n    \n    //设置返回值地址，为函数调用的下一条指令\n    frame.returnIndex = codeIndex;\n    \n    //创建新的栈桢\n    let lastFrame = frame;\n    frame = new StackFrame(functionSym);\n    this.callStack.push(frame);\n    \n    //传递参数\n    let paramCount = (functionSym.decl as FunctionDecl).callSignature.params.length;\n    for(let i = paramCount -1; i&gt;= 0; i--){\n        frame.localVars[i] = lastFrame.oprandStack.pop();\n    }\n    \n    //设置新的code、codeIndex和oPCode\n    if (frame.funtionSym.bytecode !=null){\n        //切换到被调用函数的代码\n        code = frame.funtionSym.bytecode;\n        //代码指针归零\n        codeIndex = 0;\n        opCode = code[codeIndex];\n        continue;\n    }\n</code></pre><p>在函数调用的时候，我们要完成这几项工作：</p><ul>\n<li>设置返回地址，被调用的函数在执行return指令的时候，会回到这个位置；</li>\n<li>为被调用的函数生成新的栈桢，并加到调用栈中；</li>\n<li>从操作数栈中取出参数的值，并赋给新的栈桢，因为参数也算作本地变量，因此只需要对新栈桢的前几个本地变量赋值就可以了；</li>\n<li>把代码切换到被调用函数的代码，并且把代码计数器设置为0，也就是从第一个字节码指令开始执行。</li>\n</ul><p>而函数返回是函数调用的逆向操作：</p><pre><code class=\"language-plain\">case OpCode.ireturn:\ncase OpCode.return:\n    //确定返回值\n    let retValue = undefined;\n    if(opCode == OpCode.ireturn){\n        retValue = frame.oprandStack.pop();\n    }\n\n    //弹出栈桢，返回到上一级函数，继续执行\n    this.callStack.pop();\n    if (this.callStack.length == 0){ //主程序返回，结束运行\n        return 0;\n    }\n    else { //返回到上一级调用者\n        frame = this.callStack[this.callStack.length-1];\n        //设置返回值到上一级栈桢\n        // frame.retValue = retValue;\n        if(opCode == OpCode.ireturn){\n            frame.oprandStack.push(retValue);\n        }    \n        //设置新的code、codeIndex和oPCode\n        if (frame.funtionSym.byteCode !=null){\n            //切换到调用者的代码\n            code = frame.funtionSym.byteCode;\n            //设置指令指针为返回地址，也就是调用该函数的下一条指令\n            codeIndex = frame.returnIndex;\n            opCode = code[codeIndex];\n            continue;\n        }\n        else{\n            console.log(\"Can not find code for \"+ frame.funtionSym.name);\n            return -1;\n        }\n    }\n    continue;\n</code></pre><p>函数返回时，我们需要完成下面这几项工作：</p><ul>\n<li>设置返回值，如果确实有一个返回值，那么就从当前操作数栈中取出来，返回值加载到上一级栈桢里的操作数栈；</li>\n<li>从调用栈中弹出当前栈桢；</li>\n<li>把代码切换成调用者的代码，并且把代码指针设置成函数调用指令的下一条指令，继续函数调用之后的工作；</li>\n<li>这里还有一个特殊情况，执行到return指令的时候，你会发现当前栈桢之上，再也没有上一级栈桢了。这说明当前所在的函数已经是最顶层了，也就是我们的编译器内部的_main()函数。这个时候，return指令就会结束整个while循环，也意味着整个程序运行结束。</li>\n</ul><p>好了，这就是函数调用和返回的过程。通过这个过程，你会发现这两类指令其实是遵循了一些共同的约定。</p><p>这些约定包括：我们传参数的时候，把参数放在哪里？函数返回的时候，又把返回值放在哪里？还有，调用函数的时候，我们应该在一个双方都知道的位置设置返回地址，以便函数返回后调到这个地址继续执行。</p><p>这里，你又学到一个概念，叫做<strong>调用约定（Calling Convention）</strong>。计算机语言的设计者，可以设计自己的调用约定，这样用自己的编译器编译出来的模块，都能互相调用。但如果一种语言想调用另一种语言编写的模块，那么它们必须遵循相同的调用约定，或者要在不同的调用约定之间做转换。比如，Java调用C语言写的模块，要使用JNI接口，就是要完成这种调用约定的转换。</p><p>跟调用约定差不多的一个概念叫做<strong>ABI（Application Binary Interface）</strong>。ABI这个名字更强调如何在二进制的层面上实现互相调用，以及二进制程序文件的格式，等等，所以更适合描述像C、C++这些编译成二进制目标代码的情形。</p><p>好了，现在我们已经拥有了一个简化版的虚拟机了，你可以用它跑几个程序试一下。因为现在我们这个虚拟机还不支持if语句和循环语句，所以还不方便做性能测试。这个工作，我们放在下一节课再去做。</p><h2>课程小结</h2><p>好了，今天这节课到这里就结束了，让我们来简单回顾一下。</p><p>今天，我们设计并实现了一个简单的基于栈机的虚拟机，实现了我们在虚拟机领域0的突破。如果你认真跟着学完了这一节，我相信你一定会有很多收获。</p><p>首先，我们学了栈机的指令，通常包括加载常数、加载变量、保存变量、加减乘除、函数调用和返回这些，用这些指令就能让程序运行起来了。下一节课我们还会多学习一些指令，特别是分支指令。</p><p>第二，我们已经可以通过遍历AST的方式生成字节码。其中稍微有点难度的地方，是在访问变量节点的时候，要区分左值和右值，分别生成给变量赋值的代码和读取变量值的代码。</p><p>第三，在虚拟机里，我们用了BCModule这个数据结构来表示可被执行的程序。其实你把这个数据结构保存到文件里就是字节码文件了，它里面主要的内容就是一个常量表。常量表里除了字符串、数字这样的常规意义上的常数以外，最重要的还有函数符号，函数符号中包含了要运行的字节码。</p><p>第四，栈机的执行引擎是一个很大的循环，要依次执行每条指令，在这个过程中操作数栈会不停的压入数据、弹出数据。在调用函数和返回函数的时候，要建立栈桢和弹出栈桢。函数参数被设置到新栈桢的本地变量里，而返回值则被设置到上一级栈桢的操作数栈里，这就构成了函数之间的调用约定。</p><p>虽然我们目前是在虚拟机层面上了解这些概念，但是，即使是到了我们把程序编译成机器码的时候，这些基本概念仍然是差不多的。你现在学习的成果，会为后面的学习内容打下很好的基础。</p><p>在下一节课，我们将继续深化我们虚拟机。到时候它会在哪些方面取得突破呢？敬请期待吧！</p><h2>思考题</h2><p>在这节课的BCModule中有一个常量表，为什么把函数符号也看做是常量呢？刨去其中的字节码，这些符号信息可能有什么潜在的用途呢？欢迎在留言区发表你的看法！</p><p>感谢你和我一起学习，欢迎你把我这节课分享给更多对字节码虚拟机感兴趣的朋友。我是宫文学，我们下节课见！</p><h2>课程资源</h2><p><a href=\"https://gitee.com/richard-gong/craft-a-language/tree/master/16-18\">这节课的示例代码在这里！</a></p>","neighbors":{"left":{"article_title":"07｜怎么设计属于我们自己的虚拟机和字节码？","id":410442},"right":{"article_title":"09｜基于TypeScript的虚拟机（二）：丰富特性，支持跳转语句","id":412039}}},{"article_id":412039,"article_title":"09｜基于TypeScript的虚拟机（二）：丰富特性，支持跳转语句","article_content":"<p>你好，我是宫文学。</p><p>在上一节课里，我们已经实现了一个简单的虚拟机。不过，这个虚拟机也太简单了，实在是不够实用啊。</p><p>那么，今天这节课，我们就来增强一下当前的虚拟机，让它的特性更丰富一些，也为我们后续的工作做好铺垫，比如用C语言实现一个更强的虚拟机。</p><p>我们在这一节课有两项任务要完成：</p><p>首先，要支持if语句和for循环语句。这样，我们就能熟悉与程序分支有关的指令，并且还能让虚拟机支持复杂一点的程序，比如我们之前写过的生成斐波那契数列的程序。</p><p>第二，做一下性能比拼。既然我们已经完成了字节码虚拟机的开发，那就跟AST解释器做一些性能测试，看看性能到底差多少。</p><p>话不多说，开干！首先，我们来实现一下if语句和for循环语句。而实现这两个语句的核心，就是要支持跳转指令。</p><h2>了解跳转指令</h2><p>if语句和for循环语句，有一个特点，就是让程序根据一定的条件执行不同的代码。这样一个语法，比较适合我们人类阅读，但是对于机器执行并不方便。机器执行的代码，都是一条条指令排成的直线型的代码，但是可以根据需要跳转到不同的指令去执行。</p><p>针对这样的差异，编译器就需要把if和for这样结构化编程的代码，转变成通过跳转指令跳转的代码，其中的关键是<strong>计算出正确的跳转地址</strong>。</p><!-- [[[read_end]]] --><p>我们举个例子来说明一下，下面是我用Java写的一个示例程序，它有一个if语句。</p><pre><code class=\"language-plain\">public static int foo3(int a){\n    int b;\n    if (a &gt; 10){\n        b =  a + 8;\n    }\n    else{\n        b = a - 8;\n    }\n    return b;\n}\n</code></pre><p>我们先用javac命令编译成.class文件，然后再用javap命令以文本方式显示生成的字节码：</p><p><img src=\"https://static001.geekbang.org/resource/image/31/5c/312670050f96b2663750b184f9bc095c.jpg?wh=1310x978\" alt=\"图片\"></p><p>我主要是想通过这个示例程序，给你展现两条跳转指令。</p><p><strong>一条是if_icmple，它是一条有条件的跳转指令。</strong>它给栈顶的两个元素做&lt;=（less equal，缩写为le）运算。如果计算结果为真，那么就跳转到分支地址14。</p><p><img src=\"https://static001.geekbang.org/resource/image/ed/1d/edb202fcbb86e454362b369c21da411d.png?wh=808x286\" alt=\"图片\"></p><p>你可能会发现一个问题，为什么我们的源代码是&gt;号，翻译成字节码却变成了&lt;=号了呢？没错，虽然符号变了，但其实我们的语义并没有发生变化。</p><p>我给你分析一下，在源代码里面，程序用&gt;号计算为真，就执行if下面的块；那就意味着如果&gt;号计算为假，或者说&lt;=号为真，则跳转到else下面的那个块，这两种说法是等价的。</p><p>但现在我们要生成的是跳转指令，所以用&lt;=做判断，然后再跳转，就是比较自然了。具体你可以看看我们下文中为if语句生成代码的逻辑和相关的图，就更容易理解了。</p><p><strong>你在字节码中还会看到另一个跳转指令，是goto指令，它是一个无条件跳转指令。</strong></p><p>在计算机语言发展的早期，人们用高级语言写程序的时候，也会用很多goto语句，导致程序非常难以阅读，程序的控制流理解起来困难。虽然直到今天，C和C++语言里还保留了goto语句。不过，一般不到迫不得已，你不应该使用goto语句。</p><p>这种迫不得已的情况，我指的是使用goto语句实现一些奇特的效果，这些效果是用结构化编程方式（也就是不用goto语句，而是用条件语句和循环语句表达程序分支）无法完成的。比如，采用goto语句能够从一个嵌套很深的语句块，一下子跳到外面，然后还能再跳进去，接着继续执行！这相当于能够暂停一个执行到一半的程序，然后需要时再恢复上下文，接着执行。</p><p>我在说什么呢？这可以跟协程的实现机制关联起来，协程要求在应用层把一个程序停止下来，然后在需要的时候再继续执行。那么利用C/C++的goto语句的无条件跳转能力，你其实就可以实现一个协程库，如果你想了解得更具体一些，可以看看我之前的《编译原理实战课》。</p><p>总结起来，goto的这种跳转方式，是更加底层的一种机制。所以，在编译程序的过程中，我们会多次变换程序的表达方式，让它越来越接近计算机容易理解的形式，这个过程叫做<strong>Lower过程</strong>。而Lower到一定程度，就会形成线性代码加跳转语句的代码格式，我们有时候就会把这种格式的IR叫做“<strong>goto格式（goto form）</strong>”。</p><p>好了，刚才聊的关于goto语句的这些知识点，是为了加深大家对它的认识，希望能够对你的编程思想有所启发。</p><p>回到正题，现在我们已经对跳转指令有了基本的认识，那么我就把接下来要用到的跳转指令列出来，你可以看看下面这两张表：<br>\n<img src=\"https://static001.geekbang.org/resource/image/ac/3d/ac7395bba02f6acf0ed1fbb3e8b0c63d.jpg?wh=2248x1238\" alt=\"\"><img src=\"https://static001.geekbang.org/resource/image/1a/66/1ab23f48b04952b01594d7ec466a7b66.jpg?wh=2248x1391\" alt=\"\"><br>\n如果后面要增加对浮点数和对象引用的比较功能，我们可以再增加一些指令。但由于目前我们还是只处理整数，所以这些指令就够了。</p><p>接着，我们就修改一下字节码生成程序和虚拟机中的执行引擎，让它们能够支持if语句和for语句。</p><h2>为if语句和for循环语句生成字节码</h2><p>让if语句生成字节码的代码你可以参考<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/08-09/vm.ts#L253\">visitIfStatement方法</a>。在这个方法里，我们首先为if条件、if后面的块、else块分别生成了字节码。</p><pre><code class=\"language-plain\">//条件表达式的代码\nlet code_condition:number[] = this.visit(ifstmt.condition);\n//if块的代码\nlet code_ifBlock:number[] = this.visit(ifstmt.stmt);\n//else块的代码\nlet code_elseBlock:number[] = (ifstmt.elseStmt == null) ? []: this.visit(ifstmt.elseStmt);\n</code></pre><p>接下来，我们要把这三块块代码拼接到一起，这就需要计算出每块代码的起始地址，以便跳转语句能够做出正确地跳转。比如，if块的起始位置是代码条件块的长度加3，这个3是我们生成的跳转指令的长度。</p><pre><code class=\"language-plain\">let offset_ifBlock:number = code_condition.length + 3;                   //if语句块的地址\nlet offset_elseBlock:number = code_condition.length + code_ifBlock.length + 6;  //else语句块的地址\nlet offset_nextStmt:number = offset_elseBlock + code_elseBlock.length;   //if语句后面跟着下一个语句的地址\n</code></pre><p>计算出每块代码的起始地址后，接下来我们就说说如何生成跳转指令。</p><p>在前面Java生成的字节码中，我们看到编译器对于“a&gt;10”生成了一条“if_icmple”指令。但我为了生成代码的逻辑更简单，采用了另一个实现思路。也就是先对a&gt;10做计算，如果结果为真，就在栈顶放一个1，否则就放一个0。</p><p>接下来，我们再生成一条ifeq指令，根据栈顶的值是1还是0来做跳转。那么这个ifeq指令就要占据3个字节，其中操作码占1个字节，操作数占两个字节。我的算法生成了两条指令，你也可以思考一下如何能够像Java编译器那样只生成一条指令。</p><p>计算好偏移量以后，我们就可以把condition块、if块和else块的代码拼接成完整的if语句的代码了：</p><pre><code class=\"language-plain\">//条件\ncode = code.concat(code_condition);\n\n//跳转:去执行else语句块\ncode.push(OpCode.ifeq);\ncode.push(offset_elseBlock&gt;&gt;8);\ncode.push(offset_elseBlock);\n\n//条件为true时执行的语句\ncode = code.concat(code_ifBlock);\n\n//跳转：到整个if语句之后的语句\ncode.push(OpCode.goto);\ncode.push(offset_nextStmt&gt;&gt;8);\ncode.push(offset_nextStmt);\n\n//条件为false时执行的语句\ncode = code.concat(code_elseBlock);\n</code></pre><p>你也看到了，在示例代码中，我们生成了两个跳转指令，分别是ifeq指令和goto指令，这样就能保证所有语句块之间正确的跳转关系。</p><p>那到这里，是不是就大功告成了，为if语句生成了正确的字节码了呢？<br>\n<img src=\"https://static001.geekbang.org/resource/image/1f/86/1f98b2f8fa412e54b65df6f15053ba86.jpg?wh=1265x1866\" alt=\"\"><br>\n不是的。你仔细体会一下，是不是有点什么不对劲？哪里不对劲呢？</p><p>你看，在我们生成的跳转指令中，一定要设置好正确的跳转地址，否则代码就错误了。可是，在if块和else块的代码中可能也包含了跳转指令呀。现在你把if语句中的各个块拼成了一个整体的字节码数组，那么各个块中包含的跳转指令的地址就错了呀。原来的跳转地址，都是基于各自的字节码数组中的位置，现在拼成一个新数组，这个位置也就变了。<br>\n<img src=\"https://static001.geekbang.org/resource/image/7c/9a/7c4082aed6f36c05d4960d4c4567yy9a.jpg?wh=1265x1262\" alt=\"\"><br>\n所以，这些跳转指令的跳转地址，都需要做一下调整，加上我们计算出来的偏移量，来保证整体的跳转不出问题。</p><pre><code class=\"language-plain\">this.addOffsetToJumpOp(code_ifBlock, offset_ifBlock);\nthis.addOffsetToJumpOp(code_elseBlock, offset_elseBlock);\n</code></pre><p>其实，这个调整跳转指令地址的过程，是每次做代码拼接的时候都会被调用的。比如，当前if语句生成的代码，在上一级的AST节点中做拼接的时候，也需要做地址的调整，这样就会保证为函数最终生成的字节码中，每个跳转指令的地址都是正确的。</p><p>实现完了If语句，你可以再实现一下<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/08-09/vm.ts#L298\">for循环语句</a>。for循环语句的实现思路也是差不多的，都是先生成各个部分的代码，然后再正确地拼接到一起。</p><p>好了，到目前为止，我们已经扩展了字节码编译器的功能，让它能够为if语句和for循环语句正确地生成字节码了。接下来，我们再扩展一下字节码解释器的功能，让它能够正确地运行这些跳转指令就行了。</p><h2>升级字节码虚拟机</h2><p>对于ifeq、ifneq、if_cmplt等跳转指令，解释器的处理逻辑差不多都是一样的。它在遇到这些指令的时候，都会计算一下栈顶的值是否符合跳转条件。如果符合，就计算出一个新的指令地址并跳转过去。否则，就顺序执行下一条指令就可以了。</p><pre><code class=\"language-plain\">case OpCode.ifeq:\n    byte1 = code[++codeIndex];\n    byte2 = code[++codeIndex];\n    //如果栈顶的值是0，那么就计算一个新的指令地址，以便跳转过去\n    if(frame.oprandStack.pop() == 0){\n    &nbsp; &nbsp; codeIndex = byte1&lt;&lt;8|byte2;\n    &nbsp; &nbsp; opCode = code[codeIndex];\n    }\n    //否则，就继续执行下一条指令\n    else{\n    &nbsp; &nbsp; opCode = code[++codeIndex];\n    }\n</code></pre><p>在增加了对跳转指令的支持以后，我们就完成了对虚拟机的升级工作。<strong>现在，我们已经拥有两个运行时了，一个是AST解释器，一个是字节码虚拟机。</strong>在我们启动字节码虚拟机的设计之前，我们曾经希望它能提升程序运行的性能。那现在是否达到了这个目标呢？让我们测试一下吧！</p><h2>做一下性能比拼</h2><p>我们仍然采用斐波那契数列的例子来做性能测试。这个例子的好处，就是随着数列的变大，所需要的计算量会指数级地上升，所以更容易比较出性能差异来。现在，我们用AST解释器和字节码虚拟机都来执行下面的代码：</p><pre><code class=\"language-plain\">function fibonacci(n:number):number{\n    if (n &lt;= 1){\n        return n;\n    }\n    else{\n        return fibonacci(n-1) + fibonacci(n-2);\n    }\n}\n\nfor (let i:number = 0; i&lt; 26; i++){\n    println(fibonacci(i));\n}\n</code></pre><p>我让n依次取不同的数值，分别测量出两个运行时所花费的时间，做成了一个表格。<br>\n<img src=\"https://static001.geekbang.org/resource/image/d1/45/d19ba51ba1d615975dd368e2b5fe1845.jpg?wh=2248x1668\" alt=\"\"><br>\n你可以从表格中看到，TypeScript栈机所花费的计算时间，基本上只是AST解释器的一半。所以，我们确实按照预期获得了性能上的提升。</p><p>如果把表格画成图表，就能更清晰地显示出运行速度变化的趋势。你能看出，这两条线都是指数上升的，并且栈机花费的时间始终只有AST解释器的一半。</p><p><img src=\"https://static001.geekbang.org/resource/image/2f/11/2fb90592ca2b2e4b639644f5d1d9ee11.png?wh=1695x756\" alt=\"图片\"></p><p>好了，我们的第一个版本的虚拟机已经完成了。在性能方面，也确实如我们所愿，获得了重大的提升，可以说比较圆满地完成了我们这节课的目标！</p><h2>课程小结</h2><p>这节课，我们主要实现了对if语句和for循环语句的支持。在这个过程中，我们学习了一类新的指令，也就是跳转指令。你如果多接触几种指令集就会发现，包括物理CPU的指令集在内的各种指令集，都有跳转指令，并且名称也都差不多。所以，我们这里学到的知识，也有助于后面降低你学习汇编语言的难度。</p><p>在为跳转指令生成代码的时候，关键点是<strong>要正确地计算跳转地址，</strong>地址是相对于这个函数的字节码数组的开头位置的偏移量。只有在为整个函数都生成了字节码以后，我们才能计算出所有的基本块的准确起始地址。</p><p>最后，我们还对虚拟机的性能做了测试。现在的性能只提高了一倍，当生成的斐波那契数列比较大的时候，我还是觉得挺慢的。那么，我们能否有办法进一步提升虚拟机的性能呢？像JVM和V8这样的虚拟机，都是用C++写的。那么，如果采用C/C++这样的系统级语言写一个新版本的虚拟机，会不会获得性能上更大的提升呢？那么在下一节课，我们就动手实现一个C语言版本的虚拟机吧。</p><h2>思考题</h2><p>又来到了我们例行的思考题环节，我想问下，现在你对我们虚拟机的性能测试结果满意吗？你觉得我们还可以做哪些改进，来提升TypeScript版本的虚拟机的性能呢？欢迎在留言区留言。</p><p>感谢你和我一起学习，也欢迎你把这节课分享给更多对字节码虚拟机感兴趣的朋友。我是宫文学，我们下节课见。</p><h2>资源链接</h2><p><a href=\"https://gitee.com/richard-gong/craft-a-language/tree/master/08-09\">这节课的示例代码在这里！</a></p>","neighbors":{"left":{"article_title":"08｜基于TypeScript的虚拟机（一）：实现一个简单的栈机","id":411227},"right":{"article_title":"10｜基于C语言的虚拟机（一）：实现一个简单的栈机","id":412865}}},{"article_id":412865,"article_title":"10｜基于C语言的虚拟机（一）：实现一个简单的栈机","article_content":"<p>你好，我是宫文学。</p><p>到目前为止，我们已经用TypeScript实现了一个小而全的虚拟机，也在这个过程中稍微体会了一下虚拟机设计的一些要点，比如字节码的设计、指令的生成和栈机的运行机理等等，而且我们还通过性能测试，也看到了栈机确实比AST解释器的性能更高。</p><p>虽然，上面这些工作我们都是用TypeScript实现的，但既然我们已经生成了字节码，我不由地产生了一个想法：我们能不能用C语言这样的更基础的语言来实现一个虚拟机，同样来运行这些字节码呢？</p><p>我这样的想法可不是凭空产生的。你看，字节码最大的好处，就是和平台无关的能力。不管什么平台，只要有个虚拟机，就可以运行字节码，这也是安卓平台一开始选择字节码作为运行机制的原因。你甚至也可以来试一试，假设现在时间回到智能手机刚出现的时代，你是否也能够快速设计一个虚拟机，来运行手机上的应用呢？</p><p>那么进一步，在这种移动设备上运行的应用，很重要的功能就是去调用底层操作系统的API。用C和C++实现的虚拟机，显然在这方面有优势，能够尽量降低由于ABI转换所带来的性能损失。</p><p>所以，<strong>这一节课，我就带你用C语言重新实现一遍虚拟机</strong>。在这个过程中，你会对字节码文件的设计有更细致的体会，对于符号表的作用的理解也会加深，也会掌握如何用C语言设计栈桢的知识点。</p><!-- [[[read_end]]] --><p>好了，我们首先实现第一步的目标，把程序保存成字节码文件，再把字节码文件加载到内存。</p><h2>读写字节码文件</h2><p>在TypeScript版的虚拟机中，我们用了模块（BCModule）来保存程序的相关信息，有了这样一个模块，程序就可以生成一个独立的字节码文件，就像Java语言里，每个.java文件会编译生成一个.class文件那样。</p><p><strong>首先，我们要先来定字节码的文件格式。</strong></p><p>我们也说过，Java语言的字节码文件，是依据了专门的技术规范。其实我们仍然可以采用Java字节码文件的格式，你查阅相应的技术规格就可以。这样的话，我们编译后的结果，就直接可以用Java虚拟机来运行了！</p><p>有时间的同学可以做一下这个尝试。这项工作在某些场景下会很有意义。你可以定义自己的DSL，直接生成字节码，跟Java编写的程序一起混合运行。我认识的一位极客朋友就做了类似的使用，用低代码的编程界面直接生成了.NET的字节码，形成了一个基于Unity的游戏开发平台。</p><p>不过，我们目前的语言比较简单，所以不用遵循那么复杂的规范，我们就设计自己的文件格式就好了。</p><p><strong>第二，我们需要考虑：保存什么信息到字节码文件里，才足够用于程序的运行？</strong></p><p>从我们目前实现的虚拟机来看，其实不需要太多的信息。你可以回忆一下，其实要保证程序的运行，只需要能够从常量表里查找到函数的一些基本信息即可，最重要的信息包括：</p><ul>\n<li>这个函数的字节码；</li>\n<li>这个函数有几个本地变量？我们需要在栈桢里保留存储位置；</li>\n<li>这个函数的操作数栈的最大尺寸是多少？也就是最多的时候，需要在栈里保存几个操作数，以便我们预留存储空间。</li>\n</ul><p>除了这些信息外，再就是我们的代码里用到了的部分数字常量，也需要从常量表里加载，就像ldc指令那样。</p><p>所以说，只要把函数常量、数字常量存成字节码文件，就足够我们现在的虚拟机使用了。你也可以看到，我们现在甚至连函数名称、函数的签名都不需要，如果需要的话，也是为了在运行期来显示错误信息而已。</p><p>不过，如果把函数名称和函数签名的信息加进去，会有利于我们实现多模块的运行机制。也就是说，如果一个模块中的函数要调用另一个模块中的函数，那么我们可以创造一种机制，实现模块之间的代码查找。</p><p>这其实就是Java的类加载机制和多个.class文件之间互相调用的机制，我们仍然可以借鉴。而且，即使像C语言那样的编译成本地代码的语言，也是通过暴露出函数签名的信息，来实现多个模块之间的静态链接和动态链接机制的。</p><p>那再进一步，既然需要函数签名，那么我们就需要知道一些类型信息，比如往函数里要传递什么类型的参数，返回的是什么类型的数据，这样调用者和被调用者之间才能无缝衔接到一起。</p><p>像C语言这样的系统语言，以及在操作系统的ABI里，支持的都是一些基础的数据类型的信息，比如整数、浮点数、整数指针、字符串指针之类的。而像Java等语言，它们建立了具有较高抽象度的类型体系，还可以包含这些高级的类型信息，从而实现像运行时的类型判断、通过反省的方式动态运行程序等高级功能。</p><p>上面这几段的分析总结起来，就是我们需要往目标文件里或多或少地保存一些类型信息。</p><p>那么现在就清楚了，我们需要把常量信息和类型信息写到字节码里，就足够程序运行了。</p><p><strong>现在，我们来到了第三个步骤：序列化。</strong></p><p>具体来说，序列化就是把这些信息以一定的格式写到文件里，再从文件里恢复的过程，是一个比较啰嗦的、充满细节的过程。也就是说，我们在内存里是一种比较结构化的数据，而在文件里保存，或者通过网络传输，都是采用一个线性的数据结构。</p><p>在我的编程经验里，所有这些序列化的工作都比较繁琐，但大致的实现方式都是一样的。无论是保存成二进制格式、XML格式、json格式，还是基于一种网络协议在网络上传输，都是一个把内存中的数据结构变成线性的数据结构，然后再从线性的数据结构中恢复的过程。</p><p>你可以看看BCModuleWriter和BCModuleReader中的代码，实现的技巧也很简单，<strong>最重要的就是你要知道每个数据占了多少个字节</strong>。比如，当你向文件里写一个字符串的时候，你先要写下字符串的长度，再写字符串的实际数据，用这样的方法，当你读文件的时候，就能把相关信息顺利还原了。</p><p><strong>这类程序中稍微有点难的地方，是保证对象之间正确的引用关系</strong>。比如，函数引用了变量和类型，而高级的类型之间也是互相有引用关系的，比如子类型的关系等等，这样就构成了一张网状的数据结构，相互之间有引用。</p><p>当你写入文件的时候，要注意，这个网的每个节点只能写一次，不能因为两个函数的返回值都引用了某个类型，就把这个类型写了两次。在读的时候呢，则要重新建立起对象之间正确的引用关系。</p><p>好了，了解了实现思路以后，再阅读相应的示例代码就很容易了。在TypeScript中，我用BCModuleWriter把斐波那契数列程序的字节码写成了文件，然后用hexdump命令来显示一下看看：<br>\n<img src=\"https://static001.geekbang.org/resource/image/d2/69/d2ff1d5709a2f55d8f3663ebe1580669.jpg?wh=2236x861\" alt=\"\"><br>\n乍一看，这个跟Java的字节码文件还挺像的，不过我们用的是自己的简单格式。我在图中做了标注，标明了字节是什么含义。其中_main函数和fibonacci函数的字节码指令，我也标了出来。</p><p>之后，我可以用BCModuleReader把这个字节码文件再读入内存，重建BCModule，包括里面的符号信息。如果基于这个新的BCModule，程序同样可以顺畅地运行，那就说明我们的字节码文件里面确实包含了足够的运行信息。</p><p>好了，现在我们的字节码文件以及相应的读写机制已经设计成功，也用TypeScript做完了所有的设计验证。在这个基础上，重新用C语言实现一个虚拟机，就是一个比较简单的事情了。你可以发现，虽然我们的语言换了，但虚拟机的实现机制没有变。</p><p>接下来，我们就需要用C语言把字节码文件读到内存，并在内存重建BCModule相关的各种对象结构。</p><h2>用C语言读入字节码文件</h2><p>关于C语言版本的字节码读取程序，你可以参考一下readBCModule函数的代码。在读取了字节码文件以后，我还写了一个dumpBCModule的函数，可以在控制台显示BCModule的信息，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/74/c5/747504b30c7c85ce648f647bf77ca1c5.png?wh=1726x1249\" alt=\"图片\"></p><p>你可能会注意到，我们最后的模型里的类型信息和函数都比字节码文件里的要多。不要担心，多出来的其实是系统内置的类型（比如number类型）和内置函数（比如println），它们不需要被保存在字节码文件里，但是会被我们的程序引用到，所以我们要在内存的数据结构中体现。</p><p>在这里，我重新梳理一下内存里的对象模型，这个对象模型就是我们运行时所需要的所有信息。我们读取了字节码文件以后，会在内存里形成这个结构化的对象模型，来代表一个程序的信息。<br>\n<img src=\"https://static001.geekbang.org/resource/image/7e/1b/7e8abe4d347ac8b9264619078213e01b.jpg?wh=2248x1300\" alt=\"\"><br>\n这里我再讲一个小技术点，看着上面的类图，你可能会问：C语言不是不支持面向对象吗？你为什么还能用面向对象的方式来保存这些信息？</p><p>其实，用C语言也能模拟类似面向对象的机制。以符号为例，我们是这样声明Symbol和FunctionSymbol的，让FunctionSymbol包含基类Symbol中的数据：</p><pre><code class=\"language-plain\">typedef struct _Symbol{\n    char* name;     //符号名称\n    Type* theType;  //类型\n    SymKind kind;   //符号种类\n} Symbol;\ntypedef struct _FunctionSymbol{\n    Symbol symbol;        //基类数据\n    int numVars;          //本地变量数量\n    VarSymbol ** vars;    //本地变量信息\n    int opStackSize;      //操作数栈大小\n    int numByteCodes;     //字节码数量\n    unsigned char* byteCode; //字节码指令\n} FunctionSymbol;\n</code></pre><p>在内存里，FunctionSymbol最前面的字段，就是Symbol的字段，因此你可以把FunctionSymbol的指针强制转换成Symbol的指针，从而访问Symbol的字段。这种编程方式在一些用C语言编写的系统软件里非常普遍，包括其他作者写的一些编译器的代码，以及Linux操作系统内核中的代码中都有体现。<br>\n<img src=\"https://static001.geekbang.org/resource/image/9c/f9/9c931084500bff407ef9c764755987f9.jpg?wh=2248x1305\" alt=\"\"><br>\n好了，现在我们已经成功地读入了字节码文件，接下来就让我们运行它吧！</p><h2>用C语言实现栈机</h2><p>现在，我们要用C语言再重新实现一遍栈机，这也很快，因为机理我们前面都梳理清楚了。实际上，整个C语言版本的虚拟机的代码，我就用了一个周末，就从TypeScript版本中移植到了C语言中。我也鼓励你用自己熟悉的语言多做几次移植的工作，每做一遍，你对虚拟机的内在机制的理解就会更加深入。</p><p>好，我来描述一下这个移植过程中的重点工作。</p><p><strong>首先，你仍然可以建立一个枚举数据，来描述我们所使用的指令集，也让程序更容易阅读：</strong></p><p><img src=\"https://static001.geekbang.org/resource/image/6d/cc/6d88b6af53a1cdb0c858fb86281343cc.png?wh=816x1992\" alt=\"图片\"></p><p><strong>第二，设计运行栈的数据结构。</strong>我用了一个链表来把各个栈桢链接在一起：</p><pre><code class=\"language-plain\">typedef struct _StackFrame{\n    //本栈桢对应的函数，用来找到代码\n    FunctionSymbol* functionSym;\n    //返回地址\n    int returnIndex;\n    //本地变量数组\n    NUMBER* localVars;  \n    //操作数栈\n    OprandStack* oprandStack;\n    //指向前一个栈桢的链接\n    struct _StackFrame * prev;\n}StackFrame;\n</code></pre><p>在运行的时候，我们只要保持一个指向栈顶的指针就能访问栈桢中的数据。<br>\n<img src=\"https://static001.geekbang.org/resource/image/85/68/85a95efce93297783e335a48bb3a5068.jpg?wh=2248x664\" alt=\"\"><br>\n<strong>第三，设计操作数栈。</strong>在栈桢中，你会看到有一个操作数栈，我们用一个数组来表示操作数栈就可以了，然后用一个字段指向当前的栈顶。</p><pre><code class=\"language-plain\">/**\n * 操作数栈\n * 当栈为空的时候，top = -1;\n * */\ntypedef struct _OprandStack{\n    NUMBER * data; //数组\n    int top;       //栈顶的索引值\n}OprandStack;\n</code></pre><p><strong>最后，就是做一个解释器，解释执行字节码。</strong>这里解释器的实现跟TypeScript版本的没啥区别，就是一个无穷循环，不断读取字节码指令，并根据指令做相关的动作，我就不重复介绍了，你可以回顾一下08节的内容。</p><p>到这里，整个移植工作就算完成了。整个代码也就1000来行，其中大部分代码都是House Keeping类型的代码，用于完成字节码读写、打印调试信息等啰嗦的工作，核心代码并不多。所以你在阅读代码的时候，也不要有什么心理负担。</p><p>现在，到了检验我们新版本虚拟机的时候了。我们像之前一样，运行斐波那契数列的示例程序，检验一下基于C语言实现的虚拟机的性能到底如何。</p><h2>性能比拼和优化设计</h2><p>其实，我在一开头，是期望新版虚拟机的性能是能够马上碾压前两个运行时的，也就是AST解释器和TypeScript栈机。可是实际运行结果却出乎我的预料：<strong>新版虚拟机的性能，只有TypeScript栈机的一半，甚至连AST解释器的性能也比不上</strong>。</p><p>你可能不相信，这怎么可能呢？不过，性能测试的数字是不会说谎的，你自己也可以去运行一下测试用例试试看。</p><p>在测试用例中，我打印了n从30到36的斐波那契数列，对比了各个解释器的性能：<br>\n<img src=\"https://static001.geekbang.org/resource/image/1a/10/1abdb8f9f595ddbc3b6836c861d52210.jpg?wh=2248x1202\" alt=\"\"><br>\n我还绘制成了图表，这样能够让性能比较看上去更直观：</p><p><img src=\"https://static001.geekbang.org/resource/image/32/5e/326553a6cee67528570538f7c2691f5e.png?wh=1418x756\" alt=\"图片\"><br>\n你在前一节已经看过了AST解释器和TypeScript版栈机的性能对比曲线了。现在加上了C语言版栈机的数据，它的曲线竟然是在最上面的，也就是最慢的。</p><p><strong>接下来的问题来了：如何评价这个评测结果呢？难道用C语言编写，性能还不如JavaScript吗？你能帮我思考一下原因吗？</strong></p><p>对于这个问题的分析和解决，我想放到下一节课。在分析和解决这个问题的过程中，你也会对虚拟机设计上的一些重要因素产生更深入的了解。</p><h2>课程小结</h2><p>好了，今天这节课到这里就结束了，让我们来简单回顾一下。</p><p>这一节课，我们实现了一个简单版本的虚拟机，主要工作包括几个方面：</p><p>首先，我们设计了一个字节码文件的格式，并分析了需要保存哪些信息，才能让字节码的程序运行起来，这些分析有助于你理解二进制目标文件的设计。</p><p>为了让程序运行起来，我们其实只需要有每个函数编译后形成的字节码指令，以及指令中会引用到的常量值就可以了。但我们还会保存一些符号信息和类型信息，以便支持模块之间连接，让虚拟机未来能够加载和运行多个模块。在后面的课程中，我们会把汇编代码编译成二进制目标文件，这个原理其实是相通的。</p><p>第二，我们需要编写程序，实现内存中的数据结构与顺序保存的文件数据之间的转换。这是一个程序员需要掌握的基本功，重建对象之间的引用关系是其中的难点，往往需要引入一些辅助的数据结构，比如示例代码中的SimpleTypeInfo和FunctionTypeInfo。</p><p>第三，用C语言实现栈桢、操作数栈和一个栈机，这个过程我们只是做代码移植，与TypeScript版的栈机的原理是一样的。</p><p>最后，我们实现了一个初版的C语言栈机，但很遗憾，这个虚拟机性能并没有达到我们的预期。关于这个版本的虚拟机性能不佳的问题，我们会在下一节课去详细分析并解决。</p><h2>思考题</h2><p>今天我们的思考题是：通过阅读和分析代码，你能找出C语言版本的栈机性能比较低的原因吗？希望你能在进入下一节课前独立分析一下，并在下一节课验证一下你的想法。</p><p>感谢你和我一起学习，也欢迎你把这节课分享给更多对字节码虚拟机感兴趣的朋友。我是宫文学，我们下节课再见！</p><h2>资源链接</h2><p><a href=\"https://gitee.com/richard-gong/craft-a-language/tree/master\">这节课的示例代码在这里！</a></p>","neighbors":{"left":{"article_title":"09｜基于TypeScript的虚拟机（二）：丰富特性，支持跳转语句","id":412039},"right":{"article_title":"11｜基于C语言的虚拟机（二）：性能增长10倍的秘密","id":413632}}},{"article_id":413632,"article_title":"11｜基于C语言的虚拟机（二）：性能增长10倍的秘密","article_content":"<p>你好，我是宫文学。</p><p>上一节课，我们初步实现了一个C语言版本的虚拟机，让它顺利地跑起来了。你想想看，用TypeScript生成字节码文件，然后在一个C语言实现的虚拟机上去运行，这个设计，其实和Java应用、Andorid应用、Erlang应用、Lua应用等的运行机制是一样的。也就是说，如果退回到智能手机刚诞生的年代，你完全可以像Android的发明人一样，用这种方式提供一个移动应用开发工具。</p><p>其实，我国最新的自主操作系统HarmonyOS，也是采用了像我们这门课一样的虚拟机设计机制，而且用的就是TypeScript语言，这也是我这门课采用TypeScript作为教学语言的原因之一。虽然我还没有看到HarmonyOS的虚拟机代码，但并不妨碍我去理解它的实现原理。当然了，你在学完这门课以后，也会更容易理解HarmonyOS的开发方式，而且也有助于你阅读它的虚拟机的代码。</p><p>好了，对于我们当前成果的吹捧到此打住。让我们回到现实，现实有点残酷：<strong>我们当前实现的基于C语言的虚拟机，在上一节课的性能测试中，竟然排名倒数第一。</strong>这显然不正常，这也说明了在虚拟机的设计中，我们还有一些重要的设计考虑被忽视了。</p><p>那这一节课呢，我们就来分析一下导致我们虚拟机性能不高的原因，并且针对性地解决掉这个问题。在这个过程中，你会加深对计算机语言的运行时技术的理解，特别是对内存管理的理解。</p><!-- [[[read_end]]] --><p>那首先，让我们把产生性能问题的可能原因分析一下。</p><h2>性能问题的分析</h2><p><strong>首先，我们应该了解到一点，现代的JavaScript引擎，性能确实挺高的。</strong></p><p>在我们TypeScript版本的虚拟机中，TypeScript被编译成了JavaScript，并在Node.js中运行，而Node.js又是基于V8引擎的。</p><p>在互联网的早期，JavaScript的运行效率比较低。但是后来，以V8为代表的JavaScript引擎，性能有了大幅度的提升，使得现在的Web前端可以实现很复杂的功能。</p><p>V8在运行JavaScript的时候，会做即时编译（JIT）。V8的即时编译器，能够根据运行时收集的信息对类型做推测，这也就避免了由于运行时的类型判断而产生的额外开销，从而生成了跟提前编译（AOT）差不多的代码。如果你想了解更多细节，你可以去看看我在<a href=\"https://time.geekbang.org/column/intro/100052801\">《编译原理实战课》</a>中对V8的剖析。</p><p>从原理上来说，运行时的推测机制，甚至会生成比提前编译（AOT）更高效的代码。因为它拥有运行时的统计信息，并通过某些优化算法（参考JVM的局部逃逸分析算法）实现了更好的编译优化。</p><p>换一句话说，V8也是编译生成了机器码，甚至有时候会生成更高效的机器码。仅从这一点看，它并不会比C语言的提前编译差。</p><p>不过，JavaScript毕竟是动态类型的语言，它的编译和运行过程会有一些额外的开销。</p><p>比如，编译后的目标代码总要留出一些口子，用来处理类型预测失效的情况。这个时候，它会从运行本地代码的状态退回到解释器去执行。</p><p>所以，平均来说，JavaScript编写的程序，性能不会比C/C++更高。它在某些场景下能接近C/C++的性能，已经相当惊人了。</p><p>可是，在上一节中TypeScript版本虚拟机的性能居然是C语言版本的2倍半，这就太不正常了。一定还有别的因素在起作用。</p><p><strong>所以，我们来看看第二方面的因素，就是运行时的设计。</strong></p><p>在前面的讨论中，我们比较关注的是编译技术与性能的关系。不过，在一个虚拟机中，还会有其他影响性能的因素，这就是<strong>语言的运行时</strong>。运行时就是支撑我们的应用程序运行所需要的一些软件功能，<strong>最常见的运行时功能就是内存管理机制和并发机制</strong>。</p><p>在这里，我们重点要看一下内存管理机制。通常我们提到内存管理的时候，一下子就想到垃圾收集机制去了。其实，这只是内存管理的一半工作，完整的内存管理功能还要包括内存的申请机制。</p><p>在像Java、JavaScript这样的语言中，语言的运行时需要根据程序的指令，随时在内存中创建对象，然后在程序用不到这些对象的时候，再使用垃圾收集机制，把这些对象所占据的内存释放掉。</p><p>那么重点就来了：<strong>申请和释放内存，有时会导致巨大的性能开销</strong>。一个好的运行时，必须想办法降低这些开销。</p><p>我们初版的C语言虚拟机可能就存在这方面的问题。不过，计算机语言的运行时，都是从堆里申请和管理内存的。为了让你理解内存管理和性能的关系，更好地排查出影响C语言虚拟机性能的原因，我们首先回顾一下栈和堆这两种基础的内存管理机制。</p><h2>两种内存管理机制：栈和堆</h2><p>在现代的操作系统中，为了支持应用的运行，通常会提供栈和堆这两种内存管理机制。当我们在一个C语言的函数里使用本地变量时，这些本地变量所需的内存是在栈里申请的，这也就是这个函数所使用的栈桢。而当我们用C语言的malloc函数申请一块内存的时候，这块内存就是从堆里申请的。</p><p>不过，只有像C/C++这样直接编译成本地代码的语言，才可以使用操作系统的栈来保存栈桢。在后面的课程中，我们也会生成与栈桢管理有关的汇编代码，管理栈桢通常需要修改特定寄存器的值，以及使用push、pop等辅助的指令。</p><p>在我们的解释器所使用的栈桢是自己管理的，本质都是从堆里申请的。<strong>从栈里和堆里申请内存的开销是不一样的。</strong></p><p>从栈里申请内存很简单，基本上只需要修改栈顶指针，也就是某个特定寄存器的值就行了，栈就会自动地伸缩，整个栈的地址空间始终是连续的一整块内存。</p><p>而堆就不是了。从堆里申请的内存，由于每个对象的生存期是不一样的，所以就会形成很多的“空洞”，导致内存碎片化。这样，再次申请内存的时候，操作系统需要找到一块大小合适的自由内存空间。这个过程，就需要消耗一定的计算量。在内存碎片化越来越严重的情况下，找到一块可用内存空间的开销会越来越大。</p><p>另外，程序的并发也会为堆的内存申请带来额外的开销。在现代操作系统中，每个线程都有自己独享的栈，相互之间不会干扰，但堆却是各个线程所共享的。所以，在分配内存的时候，操作系统会进行线程间的同步，每次只能为一个线程分配内存，避免同一块内存被分配给多个线程。这显然也会降低系统的性能。</p><p>现在你再回头来看看我们的C语言虚拟机的实现。在栈桢和操作数栈这两个数据结构中，有好几个地方都是指针，比如本地变量的数组、操作数栈，以及操作数栈中的数据区。按照常规的编程方法，我们为每个指针都单独申请了内存。</p><pre><code class=\"language-plain\">typedef struct _StackFrame{\n    //本栈桢对应的函数，用来找到代码\n    FunctionSymbol* functionSym;\n    //返回地址\n    int returnIndex;\n    //本地变量数组\n    NUMBER* localVars;  \n    //操作数栈\n    OprandStack* oprandStack;\n    //指向前一个栈桢的链接\n    struct _StackFrame * prev;\n}StackFrame;\n\n/**\n * 操作数栈\n * 当栈为空的时候，top = -1;\n * */\ntypedef struct _OprandStack{\n    NUMBER * data; //数组\n    int top;       //栈顶的索引值\n}OprandStack;\n</code></pre><p>这样就导致我们一个栈桢的内存布局被切成了4小块：</p><p><img src=\"https://static001.geekbang.org/resource/image/28/cd/28dab40e138aaeece61dd817e72c06cd.jpg?wh=1920x1253\" alt=\"图片\"></p><p>很显然，这是一个可以优化的设计。其实，我们可以一次就申请出整个栈桢所需的内存，而不是分成4次。这样减少了malloc的调用次数，并且还会更好地避免内存的碎片化。好，现在我们就来做第一次的优化看看。</p><h2>第一次优化：把栈桢组合成一个整体</h2><p>这个时候，我们重新编写一下为栈桢申请内存的程序。</p><p>首先我们需要计算整个栈桢的整体大小。在下图中，我列出了每块内存大小的计算公式。加到一起后就是整个栈桢的大小了。</p><p><img src=\"https://static001.geekbang.org/resource/image/0a/0d/0a8f0920c9a77f80d58d0b49d7ae4f0d.jpg?wh=1549x2248\" alt=\"图片\"></p><p>在申请了一整块内存以后，我们就获得了一个指针，指向内存块的起始位置。然后，我们可以安排内存的布局，并计算出本地变量的数组、操作数栈，以及操作数栈中的数据区这三个指针的值。</p><p>这样的话，你就可以在程序中使用这些指针来访问数据了，这跟单独为每个指针申请内存没啥区别。这就是C/C++语言的一些便利之处：<strong>你可以自己给每个指针赋值</strong>。当然，这种操作要小心一点，如果地址计算错误，会引发程序执行的问题。</p><p>好了，这样做之后，我们成功地把内存申请和释放的次数降低到了原来的1/4。那么，还有没有可以进一步优化的地方呢？还是有的，我们来开始第二次优化。</p><h2>第二次优化：基于Arena机制来管理栈桢</h2><p>在我们的虚拟机中，每一次函数调用，都要创建一次栈桢。这样的话，每一次函数调用都要做一次内存申请。</p><p>fibonacci(n)函数的时间复杂度是指数级。随着n的增加，函数调用的次数会迅速增加。具体来说，fibonacci(n)函数的时间复杂度是下面这个公式：</p><p><img src=\"https://static001.geekbang.org/resource/image/03/6d/03e8c0e2e40be4048ef7c3cdc4e1b06d.png?wh=528x114\" alt=\"图片\"></p><p>比如，当n=30时，需要做832,040次函数调用，当n=40时，那就需要做1亿多次函数调用。如果按照我们现有的内存管理机制，就要做1亿多次内存申请和释放的动作。</p><p>那有没有办法减少这个数值呢？当然有。</p><p>我们面临的问题，其实像V8和JVM这些虚拟机都会遇到。并且，它们不仅仅需要降低由于栈桢导致的内存分配和释放的开销，这些虚拟机在运行时还会产生很多小对象，也可能像我们这个例子那样，产生上亿次分配内存的请求，从而导致大量的性能开销。</p><p><strong>解决这类问题的一个思路，是采用Arena内存管理技术。</strong>Arena机制的大致意思是，从操作系统申请一些比较大块的内存。当程序需要比较小块的内存时，从这些大块中自行分配就行，就不去调用操作系统的接口了。这样，从操作系统的角度看，内存分配的请求会大大减少。</p><p>说白了，就是把内存申请从零售改为批发。在所获得的一整块内存里，可以根据软件自己的特点，去合理的管理内存，并提高分配和回收的性能。</p><p>并且，我们如果用Arena的方式来管理栈桢的申请，那可以非常简单。因为栈肯定是连续伸缩的，要申请一个新的栈桢，我们只需要在内存块上移动栈顶指针就行。</p><p>具体的管理方案你可以看看下面这张图：</p><p><img src=\"https://static001.geekbang.org/resource/image/10/b6/100bd5e316b115865abcaf13073e3cb6.png?wh=1354x212\" alt=\"图片\"></p><p>当计算fib(5)的时候，虚拟机会逐级产生多个栈桢。每次划分出一个栈桢来以后，我们要多占一个位置，用于保存前一个栈桢的栈顶位置。这样，在弹出栈桢的时候，我们直接把栈顶指针指到前一个栈桢的栈顶就可以了。</p><p>如果一个内存块不够怎么办？那就用多个内存块，一个块满了就去用下一个。</p><p><img src=\"https://static001.geekbang.org/resource/image/11/35/1125c32544f4e6fe6142fc00b93a1135.jpg?wh=1920x875\" alt=\"图片\"></p><p>弹出栈桢的时候，则是一个逆向的过程，栈顶指针也会从一个块退回到前一个块。</p><p>好了，用Arena来管理栈桢的原理就是这样。具体的实现细节，你可以去看看这节课的示例代码中与Arena有关的算法。另外，我还在playvm.h里设置了一个叫做USE_ARENA的预编译开关。你如果注释掉“#define USE_ARENA”语句，就会回到我们前一个用幼稚的方法申请内存的版本，这样你就能比较它们的性能差异了。</p><p>现在又到了检验成果的时候了。我们新的内存管理机制到底能否带来性能上的改进呢？会带来多少改进呢？我们还是赶紧上手测试一下吧！</p><h2>再次做性能测试</h2><p>我把测试结果放在了下面的表格中。你能发现，性能的提升是惊人的，<strong>基本上比之前版本的性能提升了10倍</strong>！</p><p><img src=\"https://static001.geekbang.org/resource/image/4f/92/4f25100647d23f2fb0d6b298b5763392.jpg?wh=1920x903\" alt=\"图片\"></p><p>同样的，我也做了个图表，让性能比较数据更直观：代表新版虚拟机的线在最下方，性能最快；而原来的版本在最上方，性能最慢。</p><p><img src=\"https://static001.geekbang.org/resource/image/3f/06/3f209d5f9c3e5d28830c9d5a5458fd06.png?wh=1416x756\" alt=\"图片\"></p><p>你看，这个测试结果证明，我们在内存管理方面做优化的思路是正确的。而基于C语言版的栈机也终于在性能上展露出优势，是TypeScript版栈机的4倍左右。</p><h2>课程小结</h2><p>今天这节课，我们通过分析和提升基于C语言的解释器的性能，初步接触了内存管理方面的知识。栈是一种低成本的获取内存的方式，而从堆中申请内存的开销就要大一些。我们可以通过合并小的内存、采用Arena技术等方式，大幅度降低从操作系统申请内存的次数，从而提升系统的整体性能。</p><p>除了内存管理机制上的优化外，其实还有一些技术来提升虚拟机的性能。我之前就提过，核心的字节码解释器，最好用一个大函数来实现，尽量减少函数调用的次数。像对操作数栈的压栈和出栈操作，我们目前是用两个小函数实现的，这两个小函数最好内联到主程序execute函数中，从而降低函数调用所导致的开销。不过，C语言的编译器缺省就会对这样的小函数做内联处理。</p><p>另外，我们要让程序尽量访问物理寄存器而不是访问内存，这样也能大大提高性能。目前，我们的操作数都是放在内存中的，每一次计算都会对内存做操作。通过一些技术，是有可能把对操作数栈的操作转换成对物理的寄存器的操作的。你可以考虑一下怎样才能实现这个设想。我们后面会讲到寄存器的使用，你可以记着这个话题，到时候再前后印证一下。</p><p>在这个过程中，你应该也意识到了，要实现好一门语言，运行时是很重要的。而要实现好运行时，我们需要对操作系统、硬件架构等都有比较深入的了解才行，我们在下一节课会重点讨论这个话题。</p><h2>思考题</h2><p>这一节我们为栈桢设计了一个新的内存布局，请你仔细看一下，这个内存布局还有没有进一步优化的可能性，比如栈桢所占的空间是不是可以再缩小一点？</p><p>另外，这一节我们做优化的思路，能不能反过来再用在TypeScript版本的栈机上，提升一下那个版本的性能呢？你可以分析一下，然后试试看，这样能帮助你加深对JavaScript虚拟机的理解。</p><p>感谢你和我一起学习，也欢迎你将这节课分享给更多对虚拟机和内存管理机制感兴趣的朋友。我是宫文学，我们下节课再见。</p><h2>资源链接</h2><p><a href=\"https://gitee.com/richard-gong/craft-a-language/tree/master/10-11\">这节课的示例代码在这里！</a></p>","neighbors":{"left":{"article_title":"10｜基于C语言的虚拟机（一）：实现一个简单的栈机","id":412865},"right":{"article_title":"12｜物理机上程序运行的硬件环境是怎么样的？","id":414397}}},{"article_id":414397,"article_title":"12｜物理机上程序运行的硬件环境是怎么样的？","article_content":"<p>你好，我是宫文学。</p><p>在经过了几节课的努力以后，我们的语言运行引擎，从AST解释器升级成了TypeScript版的虚拟机，又升级成了C语言版的虚拟机。这个过程中，我们的语言的性能在不断地提升。并且，我们的关注点，也越来越从高层的语法语义处理层面，往底层技术方向靠拢了。</p><p>虽然我们现在的语言特性还不够丰富，但我还是想先带你继续往下钻。我们的目标是先把技术栈钻透，然后再在各个层次上扩大战果。</p><p>所以，在接下来的几节课里，我们会把程序编译成汇编代码，然后再生成二进制的可执行程序。在这个过程中，你会把很多过去比较模糊的底层机制搞清楚，我也会带你去除一些知识点的神秘面纱，让你不再畏惧它们。</p><p>在此之前，为了让你编译后的程序能够在计算机上跑起来，<strong>你必须把物理计算机上程序的运行机制搞清楚，特别是要搞清楚应用程序、操作系统和底层硬件的互动关系。</strong>这里面的一些知识点，通常很多程序员都理解得似是而非，不是太透彻。而理解了这些程序运行机制，除了能够让我们的语言在计算机上顺利地运行，还能够帮助你胜任一些系统级软件的开发任务。</p><p>今天这节课，我想先带你透彻了解程序运行的硬件环境，以及硬件架构跟我们实现计算机语言的关系。在下节课，我则会带你透彻了解程序运行的软件环境。</p><!-- [[[read_end]]] --><h2>硬件环境和程序的运行机制</h2><p>其实，我们现在用的计算机、手机、物联网等大部分智能设备，它们的硬件架构都是差不多的，基本遵循下面这张图所展示的架构。而这张图上画出来的部分，都是需要我们在实现一门计算机语言的时候需要了解的。<br>\n<img src=\"https://static001.geekbang.org/resource/image/fa/f3/fa43bdf9441116e82f225bef807b5cf3.jpg?wh=1265x1491\" alt=\"图片\"></p><p>首先我们从整体向部分逐个击破，<strong>先来看看计算机的总体架构和程序运行的原理</strong>。</p><p><strong>对于计算机，我们最关心的是两个硬件，一个是CPU，一个是内存</strong>。它们通过计算机的总线连接在一起，这样CPU就可以读取内存中的数据和程序，并把数据写回内存。而CPU内部还会细分成更多的成分，包括高速缓存、寄存器和各种处理单元。</p><p>那在这种硬件环境下，程序是怎么运行起来的呢？通常，CPU上会有个寄存器，叫做<strong>PC计数器</strong>。通过PC计数器的值，CPU能够计算出下一条需要执行的代码的地址，然后读取这个代码并执行（根据不同的CPU架构，PC计数器中的值可能不是直接的内存地址，而需要进行一点转换和计算）。通常情况下，程序都是顺序执行的。但当遇到跳转指令时，PC计数器就会指向新的代码地址，从新的地址开始执行代码。</p><p>除了跳转指令会改变PC计数器的值，CPU的异常机制也会改变PC计数器的值，跳转到异常处理程序，处理完毕之后再回来。CPU的异常机制是CPU架构设计的一个重要组成部分。典型的异常是由硬件触发的中断。我们每次敲打键盘，都会触发一个中断，处理完毕以后会再接着运行原来的程序。也有的时候，中断可以由软件触发，比如当你Debug程序的时候，你可以控制着程序一条一条代码的执行，这也是利用了中断机制。</p><p>了解了程序总体的运行原理后，我们再通过一段代码的执行过程，深入了解一下其中的机理，并了解各个硬件成分是如何协同工作的。</p><h2>一段代码的执行过程</h2><p>这段示例代码是三条汇编代码，你先看一下：</p><pre><code class=\"language-plain\">movl   -4(%rbp), %eax\naddl   $10, %eax\nmovl   %eax, -r(%rbp)\n</code></pre><p>这三条代码都采用了统一的格式：<strong>操作码的助记符、源操作数和目标操作数</strong>。注意，不同CPU的指令集和不同的汇编器，会采用不同的格式，我这里只是举个例子。</p><p>这三条代码的意思也很简单，我来解释一下：</p><ul>\n<li>第1条是一个movl指令，movl能够把一个整数从一个地方拷贝到另一个地方。这里是从一个内存地址取出一个值，放到%eax寄存器，而这个内存地址是%rpb寄存器的值减去4；</li>\n<li>第2条是一个addl指令，它把常数10加到%eax寄存器上；</li>\n<li>第3条又是一个movl指令，这次是把%eax寄存器的值又写回第一行的那个内存地址。</li>\n</ul><p>理解了这三条代码的意思以后，我们来看看具体执行的时候都发生了些什么。</p><p><strong>第一步，CPU读入第一行代码。</strong></p><p>我们这三条代码都是存在内存里的。CPU会根据PC计数器的值，从内存里把第一条代码读进CPU里。</p><p>这里你要注意，我们刚才使用了汇编代码来表示程序，但内存里保存的，实际上是机器码。汇编代码通过汇编器可以转换成机器码。</p><p>在设计CPU的指令集的时候，我们会设计机器码的格式。比如，下图是我在RISC-V手册中找到的一张图，描述了RISC-V指令的几种编码方式。你能看到，每条指令占用32位，也就是一个整数的长度。其中opcode的意思是操作码，占用低7位，rs是源寄存器器，rd的意思是目的寄存器，imm是立即数，也就是常数。</p><p><img src=\"https://static001.geekbang.org/resource/image/65/44/65489c06158e8097ffc1a6a94c7d1d44.png?wh=1360x370\" alt=\"图片\" title=\"来源：The RISC-V Instruction Set Manual Volume I: Unprivileged ISA Document, Version 20190608-Base-Ratified\"></p><p>这些指令被读入内存以后，会有一个解码的过程，也就是把操作码、源操作数、目标操作数这些信息从一条指令里拆解出来，用于后续的处理。这个解码的功能，是由CPU内部的一个功能单元完成的。</p><p><strong>那么CPU是直接从内存中读入代码的吗？</strong></p><p>不是的，其实CPU是从高速缓存中读入代码和数据的。通常代码和数据的高速缓存是分开的，分别叫做Instruction Cache和Data Cache。只有高速缓存中没有这些代码或数据的时候，才会从内存中读取。</p><p><strong>高速缓存</strong>是内存和CPU之间的缓冲区。高速缓存的读写速度比内存快，能够减少CPU在读写内存过程中的等待时间。当CPU从内存里读一个数据的时候，它其实是从高速缓存中读到的；如果在高速缓存里没有，术语叫做没有命中，CPU会把这个数据旁白的一批数据都读到高速缓存，这样再读下一个数据的时候，又可以直接从高速缓存中读取了。</p><p>高速缓存可能分多级，比如叫做L1~L3，速度从高到底，容量则反过来，从低到高。并且，一般较低速的缓存是多个核共享的，而更高速的是每个核独享的。</p><p><strong>那高速缓存的相关知识对我们实现计算机语言有什么帮助呢？</strong></p><p>有一类优化技术，是提高程序数据的局部性，也就是把代码前后需要用到的数据，尽量都聚集在一起，这样便于一次性地加载到高速缓存。在读取下一个数据的时候，就不需要访问内存了，直接从高速缓存就可以获得了，从而提高了系统的性能。这就是数据局部性的好处。</p><p>从这个角度看，你回想一下，上一节课我们就是把栈桢的数据都放在一个连续的内存块里，也是在不经意间提高了数据的局部性。</p><p>不过，高速缓存也会带来一些麻烦。比如，当两个内核都去读写同一个内存数据的时候，它们各自使用自己的高速缓存，可能就会出现数据不一致的情况。所以，如果我们在语言层面上支持并发编程的特性，就像Java那样，那么在生成指令时就要保证数据的一致性。如果你想具体了解一下这些技术，可以再去看一下<a href=\"https://time.geekbang.org/column/intro/100052801\">《编译原理实战课》</a>。</p><p><strong>理解了高速缓存以后，我们接着继续看第一条指令的执行过程。在这条指令里，目标操作数，也就是数据加载的目的地是一个寄存器。那我们再了解一下寄存器。</strong></p><p>寄存器是CPU做运算的操作区。在典型的情况下，CPU都是把数据加载到寄存器，然后再在寄存器里做各种运算。</p><p>相比高速缓存来说，寄存器的读写速度更高，大约是内存的100倍。整体来说，寄存器、高速缓存和内存的读写速度是寄存器&gt;高速缓存&gt;内存。</p><p>在CPU的设计中，有些寄存器是有特定用途的，比如PC计数器用于计算代码地址，EFlags寄存器用于保存一些运算结果产生的状态等。</p><p>还有一些寄存器叫做通用寄存器，它们可以被我们的代码所使用，进行加减乘除等各种计算。在把程序编译成汇编代码的时候，我们要尽量去利用这些通用寄存器来运算。但如果寄存器不够用，就需要临时保存到内存中，把寄存器的空间腾出来。</p><p>好，现在我们对寄存器也有了基本的了解了，我们接着往下分析。在第一条指令里，还有一个源操作数，是-4(%rbp)，这代表了一个内存地址。CPU需要从内存地址里获取数据。</p><p><strong>那CPU是如何从内存里获取数据的呢？这个过程其实比较复杂，是由多个步骤构成的，并不是一蹴而就的。</strong></p><p>首先，CPU需要计算出内存地址。也就是从%rbp寄存器中取出现在的值，再减去4，得到要访问的数据的内存地址。这个地址计算的过程，通常也是由CPU内部一个单独的功能模块负责的。</p><p>那是不是从这个地址读取数据就行了呢？还不行，因为这个地址可能是个逻辑地址。现代CPU一般都有一个MMU单元。MMU是Memory Management Unit的缩写，也就是内存管理单元。它提供了虚拟内存管理的功能。也就是说，我们刚才计算出来的地址可能只是个逻辑地址，要经过MMU的翻译，才能获得物理的内存地址。</p><p>要实现完整的虚拟内存管理功能，还需要操作系统的支持，这个我们在下一节课还会探讨。</p><p>那现在，CPU终于得到了物理内存的地址。那么它会先从高速缓存中读数据，如果高速缓存中没有这个数据，才从内存加载。</p><p>你看，一个简单的内存访问功能，竟然涉及到这么多的细节。</p><p>解析完毕第一条指令之后，你大致也能理解第二条、第三条指令是如何执行的了。其中第二条指令，是做了一个加法运算，在这个过程中，会用到CPU内部的另一个功能单元：<strong>ALU，也就是算术逻辑运算单元</strong>。</p><p>到这里为止，我们已经提到了计算机内部的多个功能单元了，所以我们再把CPU内部的功能单元和流水线功能给总结一下。</p><h2>CPU内部的功能单元和流水线</h2><p>对于CPU内部的结构，我们已经了解了高速缓存和寄存器。除此之外，CPU内部还包含了很多的功能单元，每个单元负责不同的功能。比如，有的单元负责获取指令，有的单元负责对指令译码，有的单元负责真正的运算，有的单元负责读取数据，有的单元负责写入数据，等等。</p><p>在阅读CPU的手册的时候，你会看到关于这个CPU的内部结构的一些信息，这个内部结构也被叫做<strong>微架构</strong>。你可以多看看这些图，即使你不能完全理解其中每个单元的含义，这也会有助于你理解CPU到底是如何运作的。下面这张图是我从Intel的手册中看到的Ice Lake型号的CPU的微架构的示意图：</p><p><img src=\"https://static001.geekbang.org/resource/image/90/54/90cb12f1286af29df93425effa8dd854.png?wh=1356x1086\" alt=\"图片\" title=\"来源：图2-1，Intel® 64 and IA-32 Architectures Optimization Reference Manual\"></p><p>我稍微解释一下这个微架构。你会看到，在图的左上角，指令高速缓存中的指令会被解码，解码后变成<strong>微指令</strong>。这里就涉及到了X86设计上的一些细节。X86使用的指令属于复杂指令集（CISC），CISC会针对特定的功能来设计一些指令，所以指令的执行效率会比较高，就像我们为了某个应用目的专门写一个程序来处理那样。</p><p>但复杂指令集也有坏处，就是指令的条数太多了，导致硬件设计会变得复杂，也不容易利用我们下面将要讲到的流水线的优势。所以，其实现代使用CISC的CPU，在内部设计上也借鉴了RISC的优点，把复杂的指令拆解成了简单的指令，或者叫做微指令，也就是图中的uop。</p><p>微指令会排成队列去执行任务，它们会到达一个调度器，由调度器调度不同的处理单元去完成不同的任务。调度器通过不同的端口（Port）来调度任务，不同的功能单元则在端口上接收任务。有的单元负责保存数据，有的单元负责加载数据，这些单元都会接到高速缓存上。还有几个端口是专门做计算的。不同的计算任务又分别由不同的计算单元承担，比如ALU是做算术运算的，LEA是做地址运算的，FMA是做浮点数运算的，等等。</p><p>不过，不同的CPU，其内部功能单元的划分是不同的。但总的来说，在执行一条指令的时候，CPU内部实际是多个单元按顺序去处理的，这被叫做<strong>指令流水线</strong>。不同CPU的流水线设计是不同的，有的分5个步骤，有的分成8个、10个甚至更多个步骤。</p><p>采用流水线技术最大的好处，就是我们不用等一条指令完全执行完毕，才去执行第二条指令。假设每条指令需要用到5个功能单元，分成5个步骤。那么在第一条指令的第一个步骤执行完毕以后，第一个功能单元就空出来了，就可以处理第二条指令了。总的来说，相当于有5条指令在并行运行。</p><p><img src=\"https://static001.geekbang.org/resource/image/fe/cb/fe51d04b76edfe51d768324935b33ecb.png?wh=548x320\" alt=\"图片\"></p><p>当然了，实际上的执行过程并没有这么理想，因为不同的指令会用到不同的功能单元。比如上面示例程序的三条指令中，addl指令用到了ALU单元，而其他两条指令就没用到。而且，每个功能单元所需要的时钟周期也是不同的。所以，各条指令在执行过程中就会出现等待的情况。</p><p>在编译技术中，专门有一种叫做指令重排序的技术，通过重新排列指令的顺序，在不影响计算结果的情况下，能够让CPU的流水线发挥更大的工作效率，如果你想了解更多关于这方面的知识，可以看看<a href=\"https://time.geekbang.org/column/intro/100034101\">《编译原理之美</a>》。</p><p>在现代CPU的设计中，在硬件层面也提供了乱序执行的功能，这样也可以减少指令的互相等待，提高运行效率。但当CPU提前执行后面的一些指令的时候，有可能会产生错误。比如，如果某个指令后面跟着一个分支跳转指令，那这个时候到底要执行哪个分支，要由前面的的指令执行结果来决定。</p><p>所以你也能看到，前面我给的CPU微架构图里就会有一个分支预测单元（BPU），尽量争取能准确地预测接下来的分支。如果预测失败，那么CPU就会把流水线清空，把已经完成的计算的结果废弃掉。</p><p>流水线技术可以看做是指令级的一种并行技术，是一种微观的并行技术。不过，计算机系统还可以通过多处理器、多核和超线程技术来支持并行，现在我们就来介绍一下这部分的内容。</p><h2>并行和并发的硬件支持</h2><p>在一台计算机中，你可以安装多颗CPU，从而支持多个程序并行执行。每颗CPU都拥有自己的一套完整的寄存器，各自读取指令并执行，这种技术通常用于服务器。</p><p>现代的CPU还可以更进一步，在一颗CPU中支持多个内核，同样可以并行地运行多个程序。我们现在的PC电脑和智能手机的的CPU，基本上都是多核的。</p><p>再进一步，有的CPU还支持超线程（Hyper Threading）技术，在一个内核上也可以运行两个或多个程序并行执行，每个程序都有一套相互独立的寄存器，基本上互不干扰。</p><p>不过，就算一颗CPU只有一个内核，在同一时刻只支持运行一个程序，我们仍然可以通过时间片轮转的技术，让这颗CPU运行多个任务。而我们前面提到的中断机制，就可以用来定期停止一个正在执行的任务，让CPU去执行另一个任务，这种机制叫做并发，而不是并行。</p><p>现代语言都支持并行和并发，上述这些硬件机制，就是实现并行和并发的基础。我们下一节课会在操作系统和语言层面讨论更多有关并发和多任务的话题。</p><h2>课程小结</h2><p>好了，对程序运行的硬件环境的介绍，我们就先到这里。</p><p>今天这节课，我们梳理了在物理机上的程序的运行原理，弄清楚这些原理对于我们实现计算机语言非常关键。这里我再跟你强调以下几个要点：</p><p>从硬件层面，我们主要关注CPU和内存两个硬件。在我们未来生成的汇编代码里，CPU的寄存器和内存地址会被作为指令的操作数。</p><p>总的来说，物理机上的程序的运行原理是：我们只要把机器码放在内存里，并把PC计数器指向代码的地址，CPU就可以执行这些代码了。所以，在编译程序的时候，我们只需要生成顺序排列的汇编码，再编译成顺序排列的机器码，再把这些机器码加载到内存里，并将PC计数器指向这段代码的地址，就可以保证程序能够正常执行了。</p><p>这里我们要注意，分支（或跳转）指令会修改PC计数器的值，让程序跳到另外的地方执行代码。而硬件中断等CPU提供的异常机制也会强行打断程序，跳转到其他地方去执行。这些异常机制是实现BIOS、操作系统的底层调度机制等功能的基础，非常重要。</p><p>另外我们还讨论了CPU内部的高速缓存、功能单元和流水线机制。这些CPU架构的知识会影响到我们如何编译程序。比如：</p><ul>\n<li>指令重排序算法会利用CPU的流水线机制提高指令级并发的性能；</li>\n<li>实现数据的局部化会提升高速缓存的命中率，减少内存读写；</li>\n<li>由于高速缓存中的数据和内存中的数据可能存在不一致的情况，因此我们在为并发程序生成代码的时候，要提供一定的机制来保证数据的一致性。</li>\n</ul><p>最后，我特别强调，<strong>如果你想要深入了解计算机硬件架构的知识，一定要养成阅读CPU手册的习惯</strong>，这些手册你都很容易在厂商的官网上找到。</p><p>在后面的课程中，我们也会在自己动手生成汇编代码的过程中，加深对这些知识点的理解。</p><h2>思考题</h2><p>在讨论程序的运行机制以及后面有关汇编语言的课程中，我都会不断跟你强调要养成查阅手册的习惯。很多看似难以理解的问题，其实一查手册你就明白了。</p><p>那今天的思考题，我其实就是让你练习一下查手册。请你找一下，Intel CPU或其他CPU中，各级高速缓存访问速度是多少？我在这节课的末尾，放了一些手册的链接，你一定要下载查阅一下。</p><p>感谢你和我一起学习，也欢迎你把这节课分享给更多对物理计算机的程序运行机制感兴趣的朋友。我是宫文学，我们下节课见。</p><h2>资源链接</h2><p>1.<a href=\"https://software.intel.com/content/dam/develop/external/us/en/documents-tps/64-ia-32-architectures-optimization-manual.pdf\">Intel® 64 and IA-32 Architectures Optimization Reference Manual</a>。这本手册描述了CPU的很多内部细节。要为Intel CPU做编译优化的话，一定需要阅读这本手册。</p><p>2.<a href=\"https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-software-developers-manual-volume-1-basic-architecture.html\">Intel® 64 and IA-32&nbsp;architectures software&nbsp;developer’s manual&nbsp;volume 1: Basic&nbsp;architecture</a>。这是Intel CPU开发者手册的第一卷，属于必读的内容。特别要读一下第3章：基础执行环境。</p><p>3.这里有下载Intel CPU<a href=\"https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html\">各种手册的目录</a>。</p>","neighbors":{"left":{"article_title":"11｜基于C语言的虚拟机（二）：性能增长10倍的秘密","id":413632},"right":{"article_title":"13｜物理机上程序运行的软件环境是怎么样的？","id":415077}}},{"article_id":415077,"article_title":"13｜物理机上程序运行的软件环境是怎么样的？","article_content":"<p>你好，我是宫文学。</p><p>上一节课，我们主要讨论了程序运行的硬件环境。在某些编程场景下（比如嵌入式编程），我们的语言需要直接跑在裸设备上。所以，你要能够理解在裸设备上运行某个语言的程序所需要的技术。</p><p>不过，现代语言大部分情况下都运行在某个操作系统里，操作系统为语言提供了基础的运行环境，比如定义了可执行文件的格式、程序在内存中的布局、内存管理机制，还有并发机制等等。计算机语言需要跟操作系统紧密配合，才能更好地运行。</p><p>今天这节课，我们就来讨论一下操作系统中与计算机语言有关的那些知识点，包括内存管理、任务管理和ABI，为进一步实现我们的计算机语言打下良好的基础。</p><p>首先我们来看看操作系统的内存管理功能和程序的关系。</p><h2>内存管理</h2><p>操作系统的一个重要功能就是管理内存，它会把内存虚拟化，并进行内存访问的权限管理。</p><p><strong>那什么是虚拟化呢？</strong></p><p>虚拟化就是让每个进程都有一个自己可以用的寻址空间，不过这些地址是假的地址。但就这些假地址，我们通过指令发给CPU，CPU也是认的。因为CPU中有一个内存管理单元，缩写是MMU，它能够根据这个逻辑地址，计算出在内存里真实的物理地址。MMU还可以跟操作系统配合，设置每个内存页面的权限，包括是否可读、可写和可执行。</p><!-- [[[read_end]]] --><p>这种逻辑地址与物理地址转换的功能，对我们做编译很有用。我们的程序编译成目标代码的时候，里面的每个函数、常量和全局变量的地址，都是确定的。这样，在操作系统加载了可执行程序以后，就可以正确地调用每个函数，访问每个数据了。</p><p>如果没有这个逻辑地址的功能，那运行多个程序就困难了。我们要保证每个程序使用的地址都互相不冲突才行，否则大家就乱了套了。在不使用操作系统的编程领域（比如某些嵌入式编程），重点就要解决好这些问题。</p><p>在虚拟化机制下，只有你用到某个地址，操作系统才会为这个地址分配真实的物理内存。这些物理内存一般划分成页来管理，MMU会根据这些分页信息把逻辑地址转换成物理地址。</p><p><strong>这里我们横向延展一下，我们在</strong><a href=\"https://time.geekbang.org/column/article/413632\"><strong>第11节课</strong></a><strong>说过，在栈里申请内存的时候很简单，只需要移动一下栈顶指针就行了，其实这个内部机制和我们上面说的虚拟化也是有关的。</strong></p><p>在X64架构下，栈顶指针使用的是rsp寄存器。但其实，这时候并没有真正分配内存，你只是改变了寄存器的值而已。但如果你访问栈里的某个地址，而且这个地址又没有被分配物理的内存页，那么CPU在访问内存的时候就会知道这里出错了。它就会触发一个缺页中断，跳转到中断处理程序，去分配页面。分配完毕以后，又跳回原来的程序接着执行，我们的程序并不知道背后发生了这么多的事情。</p><p>说到中断，我再额外跟你补充一点。CPU在处理中断的时候，要保护当前的现场，比如各个寄存器的状态。否则，如果各个寄存器的值被弄乱了，原来的程序就没法执行了。然后在返回原来的程序的时候，CPU要恢复现场。整个过程对我们的程序是透明的。</p><p>所以说，这个rsp只是起到一个标记作用，是我们的程序跟操作系统之间的一个约定。我们只要修改了rsp里的值，操作系统就要保证给我们提供足够的内存。如果你违背了这个约定去乱访问一些地址，在MMU和操作系统的配合下，也会被识别出来，就会报内存访问的错误。</p><p>既然这只是个约定，那么有的操作系统就比较为程序着想了，它规定你可以访问栈顶之外的一定范围内的内存。比如，Linux和大多数类Unix的系统都遵循System V AMD64 ABI，它规定可以访问栈顶之外的128个字节范围内的内存。</p><p>这有什么好处呢？好处是，对于程序中的叶子函数，也就是这个函数没有调用其他函数，并且它所使用的数据不会超过128个字节的情况，我们根本不需要去建立栈桢，也就省去了把栈顶指针的值保存到内存，修改栈顶指针，最后再从内存中恢复栈顶指针这一系列操作，这样就节省了大量的内存读写时间，让系统性能得到优化。</p><p>在堆中申请内存也是一样，也不是真实的分配，只是提供了一些标记信息，之后可供MMU使用而已。</p><p>好了，关于从栈和堆里申请内存的延伸就到这里，我们回归主线，继续来看虚拟化机制带来的结果。简单的说，虚拟化机制，可以让运行中的各种程序，使用相同的逻辑地址，但实际上对应的是不同的物理地址。这样各个程序加载到内存后，就都可以使用标准的内存布局。</p><p><strong>那一个可执行程序在内存中的布局情况是怎样的呢？</strong>我们用一个C语言的程序的例子来分析一下。</p><p>在Linux或macOS系统中，一个C语言的程序加载到内存以后，它的内存布局大概是下面的样子：<br>\n<img src=\"https://static001.geekbang.org/resource/image/91/13/91c3ef829ae234312274cef3947a8013.jpg?wh=1265x1740\" alt=\"\"><br>\n你可以看到，其中代码段（.text）和数据段（包括.data和.bss）是从可执行文件直接加载进内存的。可执行文件中提前计算好的函数、常量和全局变量的地址，也就变成了内存中的地址。</p><p>另外两个重要的区域是栈和堆。栈是从高地址向低地址延伸的，而堆则是从低地址向高地址延伸的。</p><p>但是，在不同的操作系统中，上图中每个部分的具体地址都是不大相同的，比如，macOS和Linux的就不同。不过，你可以写个程序，打印出不同区域中的地址。我写了个示例程序address.c，你可以参考一下，这里你要好好琢磨一下示例代码中每个地址是如何获取的。</p><p>另外，我是在macOS上运行的，如果你用的是不同的操作系统，也可以运行一下，看看打印出来的地址跟我的有什么区别。</p><p>这个程序是这样的：</p><pre><code>#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n\n//全局变量\nint global_a = 10;\nchar * global_b = &quot;hello&quot;;\n\nint main(int argc, char** argv){\n    printf(&quot;命令行参数/\\&quot;address\\&quot;的地址:\\t0x%12lX\\n&quot;, (size_t)argv[0]);\n    printf(&quot;命令行参数/argv数组的地址:  \\t0x%12lX\\n&quot;, (size_t)argv);\n   \n    printf(&quot;栈/参数argc的地址:         \\t0x%12lX\\n&quot;, (size_t)&amp;argc);\n    printf(&quot;栈/参数argv的地址:         \\t0x%12lX\\n&quot;, (size_t)&amp;argv);\n\n    int local_a = 20;\n    printf(&quot;栈/local_a的地址:         \\t0x%12lX\\n&quot;, (size_t)&amp;local_a);\n\n    int * local_b = (int*)malloc(sizeof(int));\n    printf(&quot;栈/local_b的地址:         \\t0x%12lX\\n&quot;, (size_t)&amp;local_b);\n    printf(&quot;堆/local_b指向的地址:      \\t0x%12lX\\n&quot;, (size_t)local_b);\n    free(local_b);\n\n    printf(&quot;data段/global_b的地址:    \\t0x%12lX\\n&quot;, (size_t)&amp;global_b);\n\n    printf(&quot;data段/global_a的地址:    \\t0x%12lX\\n&quot;, (size_t)&amp;global_a);\n\n    printf(&quot;text段/\\&quot;hello\\&quot;的地址:    \\t0x%12lX\\n&quot;, (size_t)global_b);\n\n    printf(&quot;text段/main函数的地址:     \\t0x%12lX\\n&quot;, (size_t)main);\n}\n\n</code></pre><p>示例程序的运行结果如下，我是按照高地址到低地址的顺序打印各个不同的地址的：</p><p><img src=\"https://static001.geekbang.org/resource/image/e1/e3/e192438ef5b7ba97de61485ab8d066e3.png?wh=974x524\" alt=\"\"></p><p>我也画了一个示意图：<br>\n<img src=\"https://static001.geekbang.org/resource/image/dc/b5/dc8c61f741f564af5f2b381e5bb562b5.jpg?wh=1265x1634\" alt=\"\"><br>\n你看这张图，最上面的是命令行参数。main函数的参数argv[0]，实际上是操作系统提供的一个命令行参数，也就是可执行文件的名称，而argv[0]的值，就是字符串“address”的地址。</p><p>顺着看下来，下面的是两个参数。参数是被放在栈里的，第一个参数排在前面，第二个参数排在后面。其中第二个参数是argv，它的值是指向一个参数数组。</p><p>接下来是两个本地变量local_a和local_b，它们也是放在栈里的。其中local_b是一个指针，指向堆里申请的一小块内存的地址。</p><p>再往下是两个全局变量，它们存在.data段。其中global_b是一个指针，指向一个字符串常量“hello”。</p><p>最后是.text段，这里有字符串常量“hello”，也有main函数对应的机器码。</p><p>你看，这样小的程序，都涉及了这么多个地址。全局变量、常数和代码的地址是由编译和链接程序确定的，命令行参数的地址是由操作系统分配的，而函数参数、本地变量和从堆中申请的内存，是在运行期分配的。</p><p><strong>那接下来，一个问题就来了：无论哪种语言，它的内存布局都是这样的吗？</strong></p><p>也不完全是。像C、C++这些静态编译的语言，要提前编译成可执行文件，把可执行文件加载到内存以后，内存布局就是上面的样子。其中，可执行文件的格式、如何加载到内存、每个段的起始地址是多少、如何让程序能够访问环境变量和命令行参数、调用系统API时的调用约定等等，都是由操作系统的ABI规定的。</p><p>但也有的语言，特别是带有即时编译能力的语言，以及想要实现自己的并发机制的语言，会用更灵活的方式来使用内存。</p><p>我拿即时编译的情况举个例子。现代很多语言是编译成机器码运行的，但却不是提前编译的，而是在运行时编译的，典型的就是Java和基于V8的JavaScript。既然是即时编译成机器码的，那也就不可能像C语言那样提前计算好每个函数的代码地址，并且放到内存中的文本段，而是动态地从堆中申请内存，来保存这些机器码，并且运行它们。</p><p>这里我用一个示例程序来给你演示一下即时编译的原理。这个程序能够把一段二进制的机器码加载到内存，然后运行它。</p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/mman.h&gt;\n\n/*\n * 机器码，对应下面函数的功能：\n * int foo(int a){\n *     return a + 2;\n * }\n */\nuint8_t machine_code[] = {\n        0x55, 0x48, 0x89, 0xe5,\n        0x8d, 0x47, 0x02, 0x5d, 0xc3\n};\n\n//加载并运行机器码。\nint main() {\n    //分配一块内存，设置权限为读和写\n    void *mem = mmap(NULL, sizeof(machine_code), PROT_READ | PROT_WRITE,\n                     MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n    if (mem == MAP_FAILED) {\n        perror(&quot;mmap&quot;);\n        return 1;\n    }\n\n    //把机器码写到刚才的内存中\n    memcpy(mem, machine_code, sizeof(machine_code));\n\n    //把这块内存的权限改为读和执行\n    if (mprotect(mem, sizeof(machine_code), PROT_READ | PROT_EXEC) == -1) {\n        perror(&quot;mprotect&quot;);\n        return 2;\n    }\n\n    //用一个函数指针指向这块内存，并执行它\n    int32_t(*fn)(int32_t) = (int32_t(*)(int32_t)) mem;\n    int32_t result = fn(1);\n    printf(&quot;result = %d\\n&quot;, result);\n\n    //释放这块内存\n    if (munmap(mem, sizeof(machine_code)) == -1) {\n        perror(&quot;munmap&quot;);\n        return 3;\n    }\n\n    return 0;\n}\n\n</code></pre><p>整个程序的逻辑很简单。我们声明了一个数组，里面保存了几个机器码指令，然后申请了一块内存，把这些机器码拷贝到这片内存，并给这片内存设置了可读和可执行的权限。</p><p>接着，神奇的事情发生了。我们把这块内存的指针，强制转化成了一个函数指针，那么我们就可以把这段代码当做一个函数来执行，并正确地返回执行结果了！</p><p>示例程序中的机器码指令相当于下面这个函数编译后的结果：</p><pre><code>int foo(int a){\n    return a + 2;\n} \n</code></pre><p><strong>那这个例子说明了什么呢？</strong></p><p>一方面，对于计算机来说，代码跟数据没啥区别。对于编译器来说，这些机器码是编译器所生成的数据。而对于CPU来说，这是它可以认识并执行的指令，你只要喂给它，它就能执行这行指令。</p><p>另一方面，作为语言的实现者，你可以从这个例子中发现，其实你拥有很大的自由去决定如何使用内存，在哪儿放数据，在哪儿放代码，从而可以采取最佳的技术策略来实现你的设计目标。</p><p>好，关于内存管理我们就先说这么多。现在我们来看操作系统的另一个重要功能：任务管理。</p><h2>任务管理</h2><p>任务管理，我们主要指的就是多任务的处理，现代计算机都支持多任务的处理。在上一节课，我们讲了CPU为多任务处理所提供的硬件支撑，通过多处理器、多核以及超线程技术，我们可以让多个任务并行地执行。在硬件能力较低的情况下，哪怕我们只有一条真实的执行线索，我们仍然可以借助硬件的中断机制（主要是时钟中断）让多个任务分时执行，从而实现并发机制。</p><p>所以说，以这些硬件的功能为基础，其实即使没有操作系统的支持，作为语言的编写者，其实你也有办法让程序支持并行和并发。</p><p><strong>但在操作系统的支持下，让程序实现多任务处理会更简单一些。</strong></p><p>因为操作系统在硬件提供的能力的基础上，封装出了进程、线程这样的并发调度机制，让我们可以忽略很多任务管理中的细节。比如，进程和线程都对应着一些上下文信息，像寄存器之类的信息，等等。在进行任务的切换时，操作系统会为我们的程序自动保存和恢复这些上下文信息，调度过程对我们的程序来说是透明的，编译器不需要做什么额外的工作。</p><p>但是，云计算时代的到来，使得并发任务越来越多，仅仅靠操作系统级提供的并发机制已经不能满足我们的要求了。所以，在语言层面，各个语言也开始提供并发机制，比如协程机制、Actor机制等。</p><p><strong>在语言层面上实现的并发机制，和操作系统级别的机制，是有所区别的。</strong></p><p>操作系统的多任务机制，一般是抢占式的。也就是说，操作系统可以强行把当前任务调度走，去执行其他任务，像Linux和Windows系统，都是抢占式的。这个过程需要用到中断机制，由操作系统内核态的代码去处理中断。</p><p>而用户的程序是运行在用户态的，所以由计算机语言本身支持的并发机制，一般是协作式的，因为我们没有办法打断别的任务的运行。所以，如果一个协程一直不停下来，不主动交出CPU来，我们通常是没有办法干涉的。</p><p>但是，编译器和运行时配合，我们仍然是可以做一些工作，避免某些任务长时间占据CPU。比如，Erlang是基于虚拟机运行的，这时候虚拟机就像一个物理的CPU一样，检查某个并发任务执行了多长时间，需要时把它调度走。</p><p>而Go语言的Goroutine，是编译成本地代码运行的，并没有一个解释器来控制代码的执行，但它也会在编译后的程序里插入一些代码，用于并发调度。程序在执行到这里的时候，运行时会去检查Goroutine是否超时了，超时就把它挂起来，或者把一些等候过久的任务挪到比较空闲的线程去执行。</p><p><strong>并且，在语言级实现的多任务机制，也涉及任务的数据和状态信息的管理问题。</strong></p><p>比如，操作系统中，只为每个线程准备了一个栈，随着函数的逐级调用，栈会不停地伸缩。而采用了协程以后，有多个并发的任务在执行，每个任务都会形成自己的调用栈。这个时候，语言的运行时就要打破操作系统传统的栈管理机制，形成自己的管理机制。</p><p>其实这个方法我们也不陌生，在前一节课实现基于C语言的虚拟机的时候，栈桢不就是我们自己管理的吗？这也再次印证了前面我们内存管理部分提到的内容，也就是计算机语言的设计者有很大的自由度决定如何使用内存。</p><p><strong>总结起来，现代计算机支持多任务，通常需要CPU、操作系统和计算机语言（含编译器和运行时）三方的通力合作才行。</strong>当谈论到并发的时候，你要知道哪些是计算机语言的作者可以控制的，尽量发挥我们的创造性，可以在不少领域产生很好的成果。</p><p>好了，我们已经讨论了操作系统最重要的两个作用，以及它们和我们实现计算机语言的关系。但除了这两点大的内容以外，还有其他一些内容，它们其实可以被归结在ABI里面。</p><h2>ABI</h2><p>ABI，我们前面讲过，是Application Binary Interface的意思，也就是应用程序的二进制接口。对谁的接口呢？对操作系统的。所以，操作系统都提供了二进制接口方面的规范。</p><p>在上一节课，我建议大家多看CPU的手册，来理解程序运行的硬件环境。而要全面了解程序的软件环境，其实也是查手册就行了，这里最重要的就是ABI的手册。像Linux和macOS这些类Unix的操作系统，遵循的都是SYSTEM V APPLICATION BINARY INTERFACE。为了方便你的阅读，我把一些常用的ABI文档上传到了<a href=\"https://gitee.com/richard-gong/craft-a-language/tree/master/13\">码云</a>，你一定要打开看看。</p><p>ABI文档里包含的内容很多，基本上，要让一个二进制程序能够在某个操作系统上跑起来所需要的所有信息，都在这里规定了。比如：</p><ul>\n<li>对二进制文件格式的规定；</li>\n<li>如何加载程序，以及实现动态链接；</li>\n<li>在系统里可以用到的标准库；</li>\n<li>等等。</li>\n</ul><p>还有一些内容，要根据所采用的CPU架构来做规定。比如，在针对AMD64架构的补充手册（System V Application Binary Interface AMD64 Architecture Processor Supplement）中，有一个3.2节，标题是函数调用顺序（Function Calling Sequence），就规定了栈桢的结构、如何传递参数、哪些寄存器是由被调用者负责保护的等等，这些信息在我们后面生成汇编代码的时候特别有用。</p><p>这些规定，有些是我们必须遵守的，比如在调用函数时对栈桢的内存对齐的规定，否则操作系统就会报错。有些呢，我们语言的设计者可以不用严格遵守，为我们的语言发明我们自己的机制，就像函数如何传参、如何接收返回值等调用约定。比如，Go语言支持多个返回值，显然就跟C语言的机制是不同的。但是，如果我们要调用系统的标准库，那么就必须遵守ABI里所规定的调用约定才行。</p><h2>课程小结</h2><p>今天这节课，我们总结了程序运行与操作系统的关系，了解了在设计自己的语言时，如何充分利用操作系统所提供的能力，而且充分运用作为语言的作者可发挥的空间。</p><p>操作系统最大的作用，是为我们的程序提供了<strong>内存管理</strong>和<strong>任务管理</strong>的支持。</p><p>从内存管理方面，操作系统为应用程序提供了一个逻辑的地址空间，使得运行中的各种程序，虽然使用相同的逻辑地址，但实际的物理地址都是不同的。这样各个程序加载到内存后，就都可以使用标准的内存布局。不过，在采用JIT机制时，语言的设计者也可以设计自己的内存布局。</p><p>在任务管理方面，操作系统在底层硬件提供的功能之上，封装成了进程和线程的并发调度机制，计算机语言可以和这些并发机制相配合，并提供应用级的、协作式的、更加轻量级的并发能力。</p><p>最后，<strong>如果要充分吃透程序运行的操作系统环境，你一定要阅读ABI手册</strong>。你在教科书上找不到的知识点，往往能在手册里找到准确的答案。</p><h2>思考题</h2><p>请你思考一下，把一个程序编译成在没有操作系统的计算机上运行，会跟有操作系统的计算机上运行有啥不同？你可以仔细思考一下各方面的因素，这会有利于你加深对程序运行机制的理解。</p><p>感谢你和我一起学习，也欢迎你把这节课分享给更多对物理计算机的运行机制感兴趣的朋友。我是宫文学，我们下节课见。</p><h2>资源链接</h2><p>1.<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/13/SYSTEM%20V%20APPLICATION%20BINARY%20INTERFACE%20Edition%204.1.pdf\">SYSTEM V APPLICATION BINARY INTERFACE Edition 4.1</a> 这是Linux、macOS等类Unix的系统都遵守的二进制接口规范。</p><p>2.<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/13/SYSTEM%20V%20APPLICATION%20BINARY%20INTERFACE%20Intel386%20Architecture%20Processor%20Supplement.pdf\">SYSTEM V APPLICATION BINARY INTERFACE Intel386 Architecture Processor Supplement</a>，这是上面ABI针对Intel架构CPU的补充规定。</p><p>3.<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/13/System%20V%20Application%20Binary%20Interface%20AMD64%20Architecture%20Processor%20Supplement%20Draft%20Version%200.99.6.pdf\">System V Application Binary Interface AMD64 Architecture Processor Supplement</a>，这是上面ABI针对X86的64位模式（叫做AMD64，因为AMD公司最先做出了64位模式X86芯片）的补充规定。</p><p>4.<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/13/Executable%20and%20Linking%20Format%20(ELF)%20%20specification%20v1.2.pdf\">Executable and Linking Format (ELF) specification v1.2</a>，这是Linux二进制目标文件的格式标准。</p><p>5.<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/13/Formats%20Specification%20for%20Windows%20v1.0.pdf\">Formats Specification for Windows v1.0</a>，这是Windows二进制目标文件的格式标准。</p>","neighbors":{"left":{"article_title":"12｜物理机上程序运行的硬件环境是怎么样的？","id":414397},"right":{"article_title":"14｜汇编代码学习（一）：熟悉CPU架构和指令集","id":416043}}},{"article_id":416043,"article_title":"14｜汇编代码学习（一）：熟悉CPU架构和指令集","article_content":"<p>你好，我是宫文学。</p><p>经过了上一节课的学习，你已经对物理机的运行期机制有了一定的了解。其中最重要的知识点就是，为了让一个程序运行起来，硬件架构、操作系统和计算机语言分别起到了什么作用？对这些知识的深入理解，是让你进入高手行列的关键。</p><p>接下来，就让我们把程序编译成汇编代码，从而生成在物理机上运行的可执行程序吧！</p><p>慢着，不要太着急。为了让你打下更好的基础，我决定再拿出一节课来，带你了解一下CPU架构和指令集，特别是ARM和X86这两种使用最广泛的CPU架构，为你学习汇编语言打下良好的基础。</p><p>首先，我们讨论一下什么是CPU架构，以及它对学习汇编语言的作用。</p><h2>掌握汇编语言的关键，是了解CPU架构</h2><p>提到汇编语言，很多同学都会觉得很高深、很难学。其实这是个误解，汇编语言并不难掌握。</p><p>为什么这么说呢？其实前面在实现虚拟机的时候，我们已经接触了栈机的字节码。你觉得它难吗？JVM的字节码理论上不会超过128条，而我们通过前面几节课已经了解了其中的好几十条指令，并且已经让他们顺利地运转起来了。</p><p>而且，汇编代码作为物理机的指令，也不可能有多么复杂。因为CPU的设计，就是要去快速地执行一条条简单的指令，所以这些指令不可能像高级语言那样充满复杂的语义。</p><!-- [[[read_end]]] --><p>我们可以把学习汇编语言跟学习高级语言做一下类比。如果你接触过多门计算机语言，很快就能找到这些计算机语言的相似性，比如都有基础数据类型、都支持加减乘除等各种运算、都支持各种表达式和语句等等。抓住这些基本规律以后，学习一门新语言的速度会很快。</p><p>汇编语言也是一样的。不同的CPU有不同的指令集，但它们的指令的格式有一些共性，比如都包含操作码的助记符和操作数，而操作数通常也都包含立即数、寄存器和内存地址这三个类别。它们也都包含数据处理、内存读写、跳转、子过程调用等几种大类的指令。所以，你也可以很快掌握这些规律或模式，做到触类旁通，游刃有余。</p><p><strong>说了那么多，那么学习汇编语言的关键是什么呢？</strong></p><p>由于汇编语言是跟具体的CPU打交道的，所以不同的CPU架构，它们的汇编语言就会有所差别。如果你能够深刻了解某款CPU的架构，自然也就会为它编写汇编代码了。</p><p>这里提到了一个词，<strong>架构</strong>。所谓架构，是指一个处理器的功能规范，定义了CPU在什么情况下会产生什么行为。你也可以把它理解成软件和硬件之间的一个桥梁，规定了硬件如何提供功能被软件所调用。所以，如果你要搞编译技术，就必须要了解目标CPU的架构。</p><p>我把CPU架构里的内容整合在这张表里，你可以保存起来：</p><p><img src=\"https://static001.geekbang.org/resource/image/7f/87/7f506095932158702ed85eaef6ef8387.jpg?wh=1920x1080\" alt=\"图片\"></p><p>看上去，要深入了解一个CPU架构，涉及的知识还蛮多的。不过，<strong>作为初学者，我们最重要的是关注两个方面就行了：指令集和寄存器集，因为它们跟汇编代码的关系最密切。</strong></p><p>那么如何了解一个CPU的架构呢？正如我在<a href=\"https://time.geekbang.org/column/article/414397\">第12节课</a>说的那样，其实最重要的方式，就是阅读CPU的手册。</p><p>那么这节课我们就分析两种主流的CPU架构，看看能获得哪些知识点。首先我们就来看一下ARM架构的CPU的特点，它是目前大多数智能手机所采用的CPU。</p><h2>了解ARM架构</h2><p>ARM处理器是ARM公司推出的一系列处理器的名称。ARMv8是它比较新的架构，当前大多数高端智能手机都是采用这个架构。了解这个架构的方法呢，当然是下载<a href=\"https://developer.arm.com/documentation/ddi0487/latest\">ARMv8的手册</a>。</p><p>不过这本手册比较厚，有8000多页。为了加速你的理解，我挑其中最有用、跟编写汇编代码最相关的几个知识点跟你聊聊。</p><p>首先，ARMv8支持32位和64位运行模式，分别叫做AArch32和AArch64。在64位模式下，它的指令集叫做A64。</p><p>接着，我们看看ARMv8的寄存器。在AArch64架构下，它的寄存器有下面这几个（参见手册的B1.2.1部分）。</p><ul>\n<li>R0-R30：是31个通用寄存器。当它们被用于64位计算或32位计算的时候，分别被叫做X0-X30（X表示64位），以及W0-W30（W是Word的意思，表示32位）。这31个处理器是我们用做数据处理的主力。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/05/c5/05bbyy215e11822ca76947a6d86159c5.png?wh=1312x242\" alt=\"图片\"></p><ul>\n<li>SP寄存器：64位的栈指针寄存器，用于指向栈顶的地址。</li>\n<li>PC寄存器：64位的程序代码寄存器，PC是Program Code的意思。这个寄存器记录了内存中当前指令的地址，CPU会从这个地址读取指令并执行。当程序执行跳转指令、进入异常或退出异常的时候，这个寄存器的值会被自动修改。</li>\n<li>另外，还有一组寄存器是用于处理浮点数运算和矢量计算的，你可以去官方手册看看。</li>\n</ul><p>这些就是我们的汇编代码中会涉及到的寄存器，还有一些寄存器是系统级的寄存器，我们平常的应用代码用不上，就先不管了。</p><p>谈到寄存器，我插个话题。我注意到，你如果在网上搜索某个CPU架构的文章，往往得到的是模棱两可的、甚至是错误的信息，你千万要注意不要被它们误导了。</p><p>比如，我看到有的文章说在某个架构的CPU中，哪些寄存器是用来放返回值的，哪些寄存器是用来传参数的，而哪些寄存器又分别是由调用者或被调用者保护的，等等，还配了图做说明。</p><p>但如果你对调用约定或ABI的概念有所了解的话马上就会知道，这些其实都是软件层面上的一些约定，不是CPU架构层面上的规定。如果你还想了解得更具体一些，可以参考涉及到ARM架构的一些<a href=\"https://github.com/ARM-software/abi-aa/releases\">ABI规范文档</a>，特别是其中的“Procedure Call Standard for the Arm® 64-bit”，这篇文档就规定了如何使用这些通用寄存器等信息。但作为语言的作者，你其实可以设计自己的ABI，你拥有更大的自由度。</p><p>与寄存器相关的一个概念，叫做Process State，或者PSTATE，它是CPU在执行指令时形成的一些状态信息，这些状态信息在物理层面是保存在一些特殊目的寄存器里。</p><p>PSTATE有什么用呢？比如，它的用途之一是辅助跳转指令的运行。当我们执行一个条件跳转指令之前，会先执行一个比较指令，这个比较指令就会设置某个状态信息，而后续的跳转指令就可以基于这个状态信息进行正确的跳转了。</p><p>此外，PSTATE还可以用于判断算术运算是否溢出、是否需要进位等等。</p><p>最后，我们终于谈到CPU架构中的主角，<strong>指令集</strong>了。你先看一下A64指令集中的一些常见的指令：</p><p><img src=\"https://static001.geekbang.org/resource/image/41/b7/411c8fde9d8948d4ac17cc9088f67bb7.jpg?wh=1594x1305\" alt=\"图片\"></p><p>你看这些指令，是不是跟前面学过的Java字节码的指令集有很多相似之处？我们来比较一下看，上面的指令大概可以分为四组。</p><p><strong>第一组指令，是加减乘除等算术运算的指令。</strong></p><p>回忆一下，在我们之前学栈机的时候，是不是也有这些运算指令？但栈机和寄存器机的指令有一些差别。栈机的运算指令，是不需要带操作数的，因为操作数已经在操作数栈里。这几个指令会从栈顶取出两个操作数，做完加减乘除运算后，再放回栈顶。这样，下一条指令就可以把这个值作为操作数，继续进行计算。</p><p>但寄存器机上没有操作数栈，典型的寄存器机，所有运算都发生在寄存器里。我们来看看下面这个示例程序：</p><pre><code class=\"language-plain\">int foo(int a){\n    return a + 10;\n}\n</code></pre><p>你可以用下面这个命令生成ARM64指令集的汇编代码：</p><pre><code class=\"language-plain\">clang -arch arm64 -S&nbsp; foo.c -o foo_arm64.s -O2\n</code></pre><p>汇编代码的主要部分是下面这几行：</p><pre><code class=\"language-plain\">_foo:                                   ; @foo\n    add w0, w0, #10                     ; =10\n    ret\n</code></pre><p>其中“add w0, w0, #10”的意思，是把w0寄存器的值加上10，结果仍然放到w0。</p><p>在CPU指令里，我们把常量一般叫做立即数（immediate）。在这条代码里，#10就是个立即数。根据当前的调用约定，当我们调用foo函数的时候，参数a是传入到w0寄存器的。然后，这个寄存器的值又加上了10，返回值也放在w0里就可以了，函数调用者会从w0里获取这个返回值。</p><p><strong>第二组指令，只有一个mov指令</strong>，它能把数据从一个寄存器拷贝到另一个寄存器，也可以把一个立即数设置到目标寄存器。</p><p><strong>第三组指令，是内存读写的指令。</strong></p><p>在ARM指令集中，算术运算性的指令只能基于寄存器，但是原始数据通常来自于内存，计算结果最后也通常保存回内存，所以我们还需要一组指令把数据从内存加载到寄存器，以及从寄存器再写回内存，这就是load和store指令。</p><p>这两个指令我们也很熟悉，因为它们在栈机的指令里也出现过。在栈机里，我们是用load命令把本地变量和常量加载到操作数栈，用store命令操作数栈中的数据写回到本地变量。而在寄存器机里，操作数栈变成了寄存器。</p><p>比如，“str\tw0, [sp, #12]”的意思，是把w0的值保存到一个内存地址，这个内存地址是sp寄存器的值加12。sp是寄存器指向栈顶的指针，操作系统会根据这个寄存器的值自动为栈分配内存。</p><p><strong>第四组指令，是各种跳转指令。</strong></p><p>跳转指令的基本原理，是修改程序计数器的值，让CPU去执行另一个地方的代码。</p><p>高级语言中的if语句、for循环语句等，翻译成汇编代码后，就会生成跳转指令。在跳转之前，一般要做一个数值的比较，依据比较结果再做跳转，做比较的指令是CMP。比较完之后，就可以根据比较结果做跳转了，比如jeq表示两边相等就可以跳转了。</p><p>而函数调用、方法调用，我们都把它们统称为子过程调用，本质上也是做指令的跳转。只不过做子过程调用的时候，要建立新的栈帧并保证原来的栈帧不被破坏，一些寄存器的值也要保护起来，并且还要记下返回地址，所以我们通常要花费多条指令才能完成子过程调用的工作。</p><p>上面四组指令是各类不同CPU的指令集都具备的。当然，我当前给你选的都是一些常用的，也是一看就容易明白的指令。明白了这些之后，你可以进一步研究更多的指令了。</p><p>在初步研究了ARM架构以后，我们再接再厉，了解一下X86架构。因为我们的台式机和服务器，目前大多采用的还都是X86架构的CPU。对于64位的CPU，这个系列的架构也叫做X64架构，或者是AMD64架构。并且，你还可以把它跟ARM架构做对比，了解它们的相同点和不同点，对比着学习，你可以有更多的收获。</p><h2>了解X86架构</h2><p>X86架构的CPU有着很长的历史，贯穿了整个PC的发展史。要了解X86架构，当然也是看手册就行了，手册名称叫做《<a href=\"https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-software-developers-manual-volume-1-basic-architecture.html\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a>》。对于初学者，只需要看第一卷就行了，这一卷不是太厚，但已经足够你获得丰富的信息了。</p><p><strong>首先，我们仍然看看寄存器方面的信息</strong>，X86的架构下的寄存器可以分为下面几种。</p><ul>\n<li>通用寄存器：随着X86架构在不断地演化，它的可用的寄存器的数量也在不断增加。在64位模式下，一共有16个通用寄存器可以使用，这些寄存器可以用8位、16位、32位和64位的模式访问，分别拥有不同的名称，但实际上对应的是同一个物理寄存器。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/97/5b/97a4d4f82ffa3263ce4388f122b2585b.jpg?wh=1920x668\" alt=\"图片\"></p><ul>\n<li>段寄存器：在32位模式下，CPU使用多个段寄存器，分别指向内存中不同段的起始地址，比如代码段、数据段和栈，来帮助计算代码、数据和栈操作的最后的地址，但在64位模式下，段寄存器就没有用了。</li>\n<li>指令指针（EIP/RIP）：在32位模式下，EIP寄存器保存着下一条要执行的指令在代码段中的偏移量。<strong>换句话，代码段的段寄存器的地址加上EIP的地址，就是指令的逻辑地址。</strong>当然，在64位模式下，段寄存器没有用，RIP里的地址就是下一条要执行的指令的地址，它就相当于ARM中的PC寄存器。</li>\n<li>EFLAGS寄存器：这个寄存器有点像ARM中的PSTATE，也是保存了指令执行过程中产生的状态信息，用于执行跳转指令等场景。</li>\n</ul><p>这里我补充一下，我前面费这么大的劲介绍段寄存器和指令指针，就是为了让你看出来，虽然不同的CPU架构都能够知道下一条指令的地址，但它的实现机制却是不同的。</p><p><strong>接着，我们再看看X86的指令集。</strong></p><p>X86架构的CPU采用的是复杂指令集（CISC），而前面介绍的ARM和RISC-V指令集，都是精简指令集（RISC）。这两者的差别，体现在多个方面，但这些差别不是我们这节课的重点，我建议你自己去查阅一下资料，这里我们主要研究一下指令上的差别。</p><p>我在下面这张表里列出了X86指令集中的一些常见的指令，这些指令基本上从字面上也一看就懂。<br>\n<img src=\"https://static001.geekbang.org/resource/image/01/81/01f26fe85868d99afecba5caf7213181.jpg?wh=1265x1688\" alt=\"\"><br>\n你要注意的是，这些指令存在8位、16位、32位和64位的模式，你在汇编指令中使用时要带上不同的后缀：<br>\n<img src=\"https://static001.geekbang.org/resource/image/b8/9b/b85f562e1680595c0692465bbd7b0a9b.jpg?wh=1900x774\" alt=\"图片\"><br>\n接下来，我们再分析一下X86指令的特点。</p><p><strong>首先，大多数指令的源和目标，都支持使用内存地址，而不像精简指令集那样，一般只用load和store指令来做内存的读写。</strong>在计算机发展的早期，寄存器的数量是很少的，这样的指令使用起来更方便。但是现在的手机芯片，都支持比较多的通用寄存器（比如16个甚至更高），可以尽量减少内存读写操作，所以RISC指令的设计方式就更有优势了。</p><p><strong>第二，mov指令的不同。</strong>在ARM的指令中，mov只支持对寄存器的操作。而X86的mov指令，由于支持内存地址作为操作数，所以实际上支持把数据从内存加载到寄存器，从寄存器保存到内存，实现了RISC指令集中的load和store指令的功能。</p><p><strong>第三，对于栈的维护和子过程的调用，X86也有一些特别的指令，方便我们编程。</strong></p><p>比如，通过push指令，我们可以把一个寄存器的值压到栈里，同时修改栈顶指针的值。所以，一条push %rbx指令，相当于下面两条指令，但花费的时间更少。</p><pre><code class=\"language-plain\">subq $8, %rsp&nbsp; &nbsp; &nbsp; &nbsp; #把%rsp的值减8，也就是栈增长8个字节，从高地址向低地址增长\nmovq %rbp, (%rsp)&nbsp; &nbsp; #把%rbp的值写到当前栈顶指示的内存位置\n</code></pre><p>pop指令则是push指令的反向操作。</p><p>类似的还有一对指令：call和ret。前者是先把返回地址压到栈里，然后跳转到被调用的子过程的地址。比如“callq _foo”其实相当于下面两条指令：</p><pre><code class=\"language-plain\">pushq %rip&nbsp; # 保存下一条指令的地址，用于函数返回继续执行\njmp _foo&nbsp; &nbsp;# 跳转到函数_fun1\n</code></pre><p>ret指令则是一个反向的操作。从栈里取出返回地址，并设置到rip中，让程序跳回来。</p><p>关于X86架构及其指令集，我们就先了解到这里。其实我们还有不少细节没有讲到，不过因为下一节课我们就要为X86架构的CPU生成汇编代码了，我们会继续介绍更多的知识点。</p><h2>课程小结</h2><p>今天的内容就是这些了，我希望你在这一节课记住这些重要的知识点。</p><p>首先，汇编语言是针对具体的CPU架构的，而每种架构的CPU，都有不同的设计，所以它们的汇编语言也都是不同的。CPU架构相当于针对软件开发所提供的一个接口规范，包括了寄存器、指令集、异常处理、内存模式等内容。学习CPU架构相关的知识，最重要的就是学会下载和阅读手册。</p><p>我们这一节课初步研究了ARM架构和X86架构的CPU，你会发现它们有一些共性。比如，在寄存器方面，都提供了一些通用寄存器，也都有用于计算代码地址的寄存器，并都能够提供一种机制，用于保存指令执行过程中产生的一些标志信息（或状态信息），用于指令跳转等目的。在指令集方面，它们也都有用于数据处理、数据拷贝（mov）、跳转等类别的指令。</p><p>当然，它们也有一些差别，比如X86的数据处理类的指令也可以直接把内存地址作为操作数，等等。</p><p>我建议你可以再多看几个不同的指令集，对比着来分析。学习不同的指令集，能避免你的思维被限制在一种CPU设计模式里，这样也可以加深你对各种不同架构的理解。在这里，我特别建议你关注<strong>RISC-V指令集</strong>。由于它开源开放的特点，未来在我国会拥有巨大的发展潜力。运行你的程序的下一个设备，采用的可能就是RISC-V指令集。</p><p>好了，今天的要点就是这些。下一节课，我们将开始为X86架构生成汇编代码，继续在底层机制上深钻。</p><h2>思考题</h2><p>我们今天学到了指令集的概念，其实你当前使用的CPU可能会同时支持多个指令集。那你知道怎么来查询你的电脑的CPU支持的指令集吗？你可以把查询方法和这些指令集分享出来，并且查一查这些指令集都有什么用途，欢迎分享在留言区。</p><p>感谢你和我一起学习，也欢迎你把这节课分享给更多对汇编代码感兴趣的朋友。我是宫文学，我们下节课见。</p><h2>资源链接</h2><p>1.<a href=\"https://developer.arm.com/documentation/ddi0487/latest\">Arm Architecture Reference Manual - Armv8, for A profile Architecture</a></p>","neighbors":{"left":{"article_title":"13｜物理机上程序运行的软件环境是怎么样的？","id":415077},"right":{"article_title":"15｜汇编语言学习（二）：熟悉X86汇编代码","id":416809}}},{"article_id":416809,"article_title":"15｜汇编语言学习（二）：熟悉X86汇编代码","article_content":"<p>你好，我是宫文学。</p><p>上一节课，在开始写汇编代码之前，我先带着你在CPU架构方面做了一些基础的铺垫工作。我希望能让你有个正确的认知：<strong>其实汇编语言的语法等层面的知识是很容易掌握的</strong>。但要真正学懂汇编语言，关键还是要深入了解CPU架构。</p><p>今天这一节课，我们会再进一步，特别针对X86汇编代码来近距离分析一下。我会带你吃透一个汇编程序的例子，在这个过程中，你会获得关于汇编程序构成、指令构成、内存访问方式、栈桢维护，以及汇编代码优化等方面的知识点。掌握这些知识点之后，我们后面生成汇编代码的工作就会顺畅很多了！</p><p>好了，我们开始第一步，通过实际的示例程序，看看X86的汇编代码是什么样子的。</p><h2>学习编译器生成的汇编代码</h2><p>按我个人的经验来说，<strong>学习汇编最快的方法，就是让别的编译器生成汇编代码给我们看。</strong></p><p>比如，你可以用C语言写出表达式计算、函数调用、条件分支等不同的逻辑，然后让C语言的编译器编译一下，就知道这些逻辑对应的汇编代码是什么样子了，而且你还可以分析每条代码的作用。这样看多了、分析多了以后，你自然就会对汇编语言越来越熟悉，也敢自己上手写了。</p><p>我们还是采用上一节课那个用C语言写的示例函数foo，我们让这个函数接受一个整型的参数，把它加上10以后返回：</p><!-- [[[read_end]]] --><pre><code class=\"language-plain\">int foo(int a){\n    return a+10;\n}\n</code></pre><p>接着，再输入下面的clang或gcc命令：</p><pre><code class=\"language-plain\">clang -S foo.c -o foo.s \n或\ngcc -S foo.c -o foo.s\n</code></pre><p>然后我们用一个文本编辑器打开foo.s，你就会看到下面这些汇编代码：</p><pre><code class=\"language-plain\">    .section    __TEXT,__text,regular,pure_instructions\n    .build_version macos, 11, 0 sdk_version 11, 3\n    .globl  _foo                            ## -- Begin function foo\n    .p2align    4, 0x90\n_foo:                                   ## @foo\n    .cfi_startproc\n## %bb.0:\n    pushq   %rbp\n    .cfi_def_cfa_offset 16\n    .cfi_offset %rbp, -16\n    movq    %rsp, %rbp\n    .cfi_def_cfa_register %rbp\n    movl    %edi, -4(%rbp)\n    movl    -4(%rbp), %eax\n    addl    $10, %eax\n    popq    %rbp\n    retq\n    .cfi_endproc\n                                        ## -- End function\n.subsections_via_symbols\n</code></pre><p>你第一次看到这样的代码的时候，可能会有点被吓着。这都是些什么呀！</p><p>不要怕，我给你梳理和解释一番，你就能慢慢适应这种代码形式，并且能看出其中的门道了。我做了一张图，几乎把这里面的每一行都做了解释，你先看一下:</p><p><img src=\"https://static001.geekbang.org/resource/image/20/ea/20c99e6871d52b7825383019f91a1bea.jpg?wh=1920x1012\" alt=\"图片\"></p><p>首先我要说明一下，这个汇编文件采用的是GNU汇编器的语法。可能你之前学的是其他汇编器，语法可能会不同，不过看一阵子也就会习惯了。如果你在使用中遇到什么问题，也可以随时查阅<a href=\"https://sourceware.org/binutils/docs/as/index.html\">GNU汇编器的手册</a>。</p><p>GNU汇编器语法的特点是：</p><pre><code class=\"language-plain\">助记符 源操作数，目的操作数\n</code></pre><p>也就是说，比如在“addl&nbsp; &nbsp; $10, %eax”这条指令中，addl是指令的助记符，$10是源操作数，%eax是目的操作数。整条指令的意思就是把立即数10加到eax寄存器原来的值上，并把结果保存在eax寄存器。</p><p>好，我们现在回到图中这个汇编代码里来，你先看看这个汇编代码的头几行。你会注意到，头几行都是以“.”号开头的。这些以“.”号开头的指令，叫做<strong>伪指令</strong>，或者叫做directive。它是写给汇编器看的，不是翻译成机器码的指令，这些伪指令会帮助汇编器生成正确的目标文件。</p><p>比如，第一句用了一个.section伪指令。汇编器生成的目标文件中，会有1到多个section，或者叫做<strong>段</strong>。每个段里面放不同的内容，有的是放代码的，有的是放数据的。</p><p><strong>目标文件中的这些段，会被链接程序合并、组装到一起，形成可执行文件。</strong>当可执行文件加载到内存的时候，就会形成我们在<a href=\"https://time.geekbang.org/column/article/414397\">第12节课</a>里讲到的那种内存布局，分为文本段、初始化后的数据段、未初始化的数据段等。这一切的源头，就是在汇编代码中定义的section，以及子section。当前我们定义的section，是一个文本段，里面放的是纯代码。</p><p>接下来，.build_version提供了目标代码的运行环境和标准库的版本。对于macOS和Linux来说，它们的二进制目标文件的格式是不同的。</p><p>.globl _foo的意思，是_foo标签可以被外部模块所链接。也就是说，如果另一个模块里引用了foo函数，那么它可以跳转到_foo标签所指示的代码地址来。</p><p>.p2align的意思是，对于该section生成的二进制程序片段，必要时汇编器要在尾部添加一些填充性的内容，让它总的字节数能够被16整除。</p><p>这是什么意思呢？这涉及到CPU在内存中读取数据的性能问题。通常，如果数据是内存对齐的，读取数据的性能更高。甚至有些指令，特别是向量计算的指令，要求读取的数据必须是内存对齐的。在这里，我们是把生成的机器码做内存对齐，这样CPU读取机器码的性能会更高。内存对齐是在汇编代码中常见的一个现象，我这里先简单介绍一下，后面你在设计栈桢的时候还会再次遇到。</p><p>除了这几个伪指令之外，还有几个以.cfi开头的。这些伪指令都是为了生成与debug有关的信息。如果你去掉它们，也不会影响剩下的汇编代码编译成正常的可执行文件。</p><p>实际上，这个文件里大部分伪指令都可以去掉，都不影响最后的编译和链接。你看一下下面这个示例代码，这里面我去掉了大部分令人眼花缭乱的伪指令，看上去清爽多了。</p><pre><code class=\"language-plain\">#foo_x86_pure.s   去掉了大部分伪指令的汇编代码\n.globl  _foo                            ## -- Begin function foo\n_foo:                                   ## @foo\n    pushq   %rbp\n    movq    %rsp, %rbp\n    movl    %edi, -4(%rbp)\n    movl    -4(%rbp), %eax\n    addl    $10, %eax\n    popq    %rbp\n    retq\n</code></pre><p>其中，我保留了.globl _foo，因为我想在另一个程序中调用foo函数。这个调用者的代码如下：</p><pre><code class=\"language-plain\">//callfoo.c  调用采用汇编代码编写的foo函数，并打印出计算结果。\n#include \"stdio.h\"\n\nint foo(int a);\n\nint main(){\n    printf(\"foo(2) = %d\\n\", foo(2));\n}\n</code></pre><p>接着，我再执行下面两行命令，就会生成一个叫做callfoo的可执行文件。</p><pre><code class=\"language-plain\">as foo_x86_pure.s -o foo_x86_pure.o\nclang callfoo.c foo_x86_pure.o -o callfoo\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/65/1d/65c86075e810b7bfba54a27a52b0e41d.png?wh=1270x164\" alt=\"图片\"></p><p>这里面，第二句的clang命令暗中做了两件事情。首先是把callfoo.c编译成目标文件，然后用ld工具把两个目标文件链接成了一个可执行文件。</p><p>通过上面的练习，一方面你能了解一个多模块的程序是如何链接到一起的，另一方面呢，你也可以放开手脚，大胆地写纯汇编代码，不用担心不了解那么多伪指令了。</p><p>好了，我们再回到纯净版本的汇编代码中，看看这些代码都做了些什么事情，这样你会慢慢对汇编代码熟悉起来。</p><h2>理解汇编代码的语法和功能</h2><p>为了让你更清晰地阅读，我给代码也都加上了注释。</p><pre><code class=\"language-plain\">.globl  _foo           #伪指令，让foo可以被其他模块所引用                \n_foo:                  #标签。别的代码可以通过这个标签跳转到该函数。\n    #序曲（prologue）\n    pushq   %rbp       #把rpb寄存器的值压到栈中。这会导致栈顶指针（也就是rsp寄存器）的值减少8，也就是栈顶往下长8个字节。\n    movq    %rsp, %rbp #把当前栈顶的值赋给rbp，现在rbp指向栈底，暂时跟rsp的值是相同的。\n\n    #函数体\n    movl    %edi, -4(%rbp) #把参数1，也就是a的值，从edi寄存器拷贝到rbp-4的内存位置。\n    movl    -4(%rbp), %eax #把参数1，也就是a的值，又从rbp-4的内存位置拷贝eax寄存器。\n    addl    $10, %eax      #在eax寄存器上加上立即数10\n\n    #尾声（epilogue）\n    popq    %rbp       #弹出栈顶的值到rbp，栈顶指针也会增加8，也就是栈缩小了8个字节。\n    retq               #返回调用者。也就是从栈里弹出返回地址，赋给rip寄存器，从而让程序执行调用foo函数之后的代码。\n</code></pre><p>在这段代码中，“_foo:”是一个标签，可以作为代码跳转的目的地。在这里你就知道了，<strong>汇编语言里是没有函数的概念的，函数也不过意味着一段代码的开始地址而已。</strong>在后面，我们也会为if语句和for语句等生成跳转指令，跳转指令的目的地也是一个标签，本质上跟函数入口的这个标签没啥区别。</p><p>foo函数对应的所有汇编代码，被我划分成了序曲、函数体和尾声三个部分。序曲和尾声两个部分，都是用来维护栈桢的。</p><p>在这里，我想借着这段代码，再带你了解一下与栈桢有关的知识点。我画了几个图，依次给你展示了栈和寄存器里的数据随着代码执行不断变化的情况。</p><p>我们先来看第一、二步的示意图：</p><p><img src=\"https://static001.geekbang.org/resource/image/ac/6e/acc1986999770afdb5fe3debfb9bff6e.jpg?wh=1716x1044\" alt=\"图片\"></p><p><strong>第一步是调用者执行callq _foo指令。</strong></p><p>这个时候，callq指令会把rip寄存器的值压入到栈中。rip的值是当前指令的下一条指令，也就是callq之后的指令。把这个值压入到栈里以后，栈顶指针的值会减8，指向新的栈顶。那这里为什么会是减法呢？这个原因我们已经在第12节说过了，栈是从高地址向低地址延伸的。</p><p><strong>第二步，执行pushq %rbp。</strong></p><p>这条指令是把rbp寄存器的值压到栈里。rbp是一个64位的寄存器，所以要占用8个字节。push指令还会移动栈顶指针，让rsp的值减8。</p><p>然后我们再来看第三、四步的执行结果：</p><p><img src=\"https://static001.geekbang.org/resource/image/98/da/9812960462726c5b7d839ae0f5026eda.jpg?wh=1716x1044\" alt=\"图片\"></p><p><strong>第三步，执行movq %rsp %rbp。</strong></p><p>这条指令会把rsp的值拷贝到rbp，所以rbp寄存器现在拥有了一个新值，跟rsp一起，都指向了新的栈顶。如果我们后面扩展栈桢，那么rsp的值会继续减少，保持指向栈顶，而rbp会一直指向这里，也就是栈桢的底部。</p><p><strong>第四步，执行movl&nbsp;%edi, -4(%rbp)。</strong></p><p>这是把edi寄存器的值保存到栈底向下的4个字节中。因为这是一个32位整数，所以只需要占据4个字节。</p><p>注意，这里edi的值，就是foo函数第一个参数的值，也就是参数a。根据c语言的调用约定，前6个参数都是通过寄存器来传递的，这样性能更高。超过6个的之后的参数呢，还是要通过栈桢传递。</p><p>这行代码里还有一个操作数是-4(%rbp)。这是一个内存地址，它的具体值是rbp寄存器的值减去4，这就涉及到X86架构下内存的寻址方式这个知识点。</p><p>在X86下访问内存，有<strong>直接内存访问</strong>和<strong>间接内存访问</strong>两种方式。直接内存访问指的是在指令后面直接跟内存的地址，比如“mov 地址值, %eax”的意思，就是把某地址的内容拷贝到寄存器。在跳转和函数调用等指令中，我们通常是用标签来代替实际的内存地址，因为标签在链接的时候就会被计算成内存地址。</p><p>而间接内存访问，是基于寄存器的值去计算内存地址。间接内存访问的完整格式是：</p><p><strong>偏移量（基址，索引值，字节数）</strong></p><p>计算出来的内存地址是：基址 + 索引值 * 字节数 + 偏移量</p><p>我这里举例说一下：</p><ul>\n<li>8(%rbp)，是比 %rbp 寄存器的值加 8。</li>\n<li>-8(%rbp)，是比 %rbp 寄存器的值减 8。</li>\n<li>（%rbp, %eax, 4）的值，等于 %rbp + %eax*4。这个地址格式相当于访问 C 语言中的数组中的元素，数组元素是 32 位的整数，它的索引值是 %eax，而数组的起始位置是 %rbp。其中字节数只能取 1、2、4、8 这四个值。这种寻址方式为数组或矢量数据的访问提供了便利。</li>\n</ul><p>好了，内存寻址方式我们就了解到这里。对于每种CPU架构，支持的寻址方式都是不太相同的，你在接触一个新的架构时需要关注一下这个点。</p><p>现在回到正题，来看第五、六条的指令：</p><p><img src=\"https://static001.geekbang.org/resource/image/a2/9e/a2d7d8cdfba04f5163866e7c89f2ec9e.jpg?wh=1716x1044\" alt=\"图片\"></p><p><strong>第五步，执行movl&nbsp; -4(%rbp), %eax。</strong></p><p>这个语句现在你自己也能看懂了。它是把刚才那个地址中的值，拷贝到eax寄存器中。</p><p><strong>第六步，addl&nbsp;$10, %eax。</strong></p><p>这条语句的意思是在eax寄存器上加上立即数10。在X86的汇编代码中，立即数是以$开头的。</p><p>最后我们来看下最后两步的执行结果：</p><p><img src=\"https://static001.geekbang.org/resource/image/8c/21/8c819cb48d445eaee054eb547afb0d21.jpg?wh=1716x1044\" alt=\"图片\"></p><p><strong>第七步，popq&nbsp;%rbp。</strong></p><p>这里是说弹出栈顶的值到rbp，栈顶指针也会增加8，也就是栈缩小了8个字节。</p><p><strong>最后一步，执行ret指令。</strong></p><p>这个指令会从栈里弹出返回地址，设置到rip中去。同时，栈顶指针rsp的值也加了8，栈进一步缩小。执行完ret指令以后，CPU就会去执行rip指向的代码，也就是调用者的代码中callq _foo之后的代码。</p><p>那返回值在哪里呢？根据调用约定，foo函数的调用者是就是从eax寄存器中取返回值的。</p><p><strong>刚才这8个步骤，就是foo函数从被调用到返回的全过程。</strong>多分析几次这样的汇编代码，你就能对栈的变化过程，以及各个寄存器的值的变化过程有一个直观的认知，这样就能从最底层理解程序运行的过程了。</p><p>不过，我们的分析还没有停止。我们继续打量一下上面的汇编代码，你可能还会产生几个问题。通过解决这些问题，你可以更深入地了解X86汇编代码，并初步学习到对汇编代码进行优化的技术。</p><h2>汇编代码的优化</h2><p><strong>问题1：在第4步，执行movl&nbsp;%edi, -4(%rbp)，也就是把edi的值保存到内存的时候，你会发现目标地址其实是在栈顶外面的，超越了rsp指向的位置。这是怎么回事呢？难道我们的程序还可以访问栈之外的内存吗？</strong></p><p>确实如此，这其实是一个ABI的规定。System V ABI中针对amd64架构规定，程序可以访问栈顶之外128个字节的内存空间，这128个字节足够保存16个长整型数据，或者32个整型数据，还是挺大的。这样有什么好处呢？这可以减少我们的指令数量。否则，我们就要为foo函数新增加两条指令，用来移动栈顶指针了。</p><p><strong>再来说说问题2：我们之前讲过栈顶指针，也就是rsp。怎么这个程序里还有一个指针rbp呀？它有什么用？</strong></p><p>答案是，你不一定非要用它，这是个历史遗留的习惯。这个指针的作用，是在退出函数的时候，可以一步回到前一个栈桢，或者通过rbp的值来访问超过6个之外的参数（保存在调用者的栈桢里）。但你通过rsp值的加和减、以及成对的push和pop指令，其实也可以保证正确回到前一个栈桢。</p><p>所以，在新的架构下，其实我们不用这个指针也是可以的。这样的话，也就没有必要为了使用rbp而把它原来的值保存到内存里，这样也就能减少了两次内存读写操作，提升系统的性能。</p><p><strong>然后是问题3：你可能会说，我怎么觉得这个程序里的很多代码都在做无用功呀。特别是，先把edi寄存器的值保存到内存中，然后又从内存拷贝到eax寄存器，在eax上做计算。为什么不直接从edi拷贝到eax呢？这样就不需要做内存读写了呀？</strong></p><p>确实如此。因为我们当前生成的汇编代码是没有做优化的。而寄存器机最重要的优化，就是尽量多使用寄存器，减少内存读写。我们后面还会介绍寄存器分配的思路和算法。不过，我们现在就可以先手工优化一下这段汇编代码，把刚才的问题2和问题3涉及的内容都优化一下：</p><pre><code class=\"language-plain\">##foo_x86_opt2.s\n.globl  _foo           #伪指令，让foo可以被其他模块所引用                \n_foo:                  #标签。别的代码可以通过这个标签跳转到该函数。\n    #函数体\n    movl    %edi, %eax     #把参数1，也就是a的值，从edi寄存器拷贝到eax。\n    addl    $10, %eax      #在eax寄存器上加上立即数10\n\n    #尾声（epilogue）\n    retq               #返回调用者。也就是从栈里弹出返回地址，赋给rip寄存器，从而让程序执行调用foo函数之后的代码。\n</code></pre><p>修改完毕以后，你会发现，foo函数从7条指令减少到了3条，并且减少了4次内存读写。既缩小了代码尺寸，又提高了性能，这就是我们这次代码优化起到的作用。</p><p>那这已经优化到了最佳状态了吗？其实还没有，还是有优化空间的。请看下面的代码：</p><pre><code class=\"language-plain\">##foo_x86_opt2.s\n.globl  _foo           #伪指令，让foo可以被其他模块所引用                \n_foo:                  #标签。别的代码可以通过这个标签跳转到该函数。\n    #函数体\n    leal   10(%rdi), %eax  #把参数1加上10，然后拷贝到eax。\n\n    #尾声（epilogue）\n    retq               #返回调用者。也就是从栈里弹出返回地址，赋给rip寄存器，从而让程序执行调用foo函数之后的代码。\n</code></pre><p>这里呢，我把用一条lea指令代替了原来函数体中的两条指令。指令数量又减少了一条，并且foo函数整体所花费的时钟周期也减少了。你可以在编译命令中加上-O1或-O2参数，也会获得类似的代码。</p><p>我这里再给你介绍一下<strong>lea指令</strong>，这个指令原本是用于做地址计算的。lea是“load effective address”的缩写，装载有效地址。它的源操作数是一个间接寻址模式的地址，在计算出地址值之后赋值给目的操作数。</p><p>在这里，我们是利用了lea指令在一条指令里能够同时完成计算和给寄存器赋值的能力，把它用于数学运算了。这就相当于上一节课我们接触到的ARM架构的add指令，那个add指令能接受两个源和1个目的，也能够同时完成加法运算和给寄存器赋值。</p><p>这种同样的功能可以用不同的指令实现，并且选择最优的指令组合的机制，叫做<strong>指令选择</strong>。这也是一种代码优化技术。</p><h2>课程小结</h2><p>好了，这就是今天课程的全部内容了。我们这节课近距离观察和分析了X86汇编的代码，我希望你记住这几个知识点：</p><p>GNU汇编器支持的X86汇编由伪指令、指令和标签构成。伪指令是写给汇编器的，你在学习的过程中可以暂时忽略大部分的伪指令。指令能够生成最后的机器码，标签会被链接器转化成内存地址，用于支持函数调用、跳转等功能。</p><p>X86的指令由助记符、源操作数和目的操作数构成。不过，有的指令没有目的操作数（如pushq %rbp），还有的指令只有助记符（如retq）。操作数可以是立即数、寄存器或内存地址。内存地址包括直接内存访问和间接内存访问两种方式。</p><p>在运行一个函数时，会涉及到与栈的使用有关的代码。我们用rsp寄存器指向栈顶。push、pop、call和ret指令，都会导致rsp指针移动。在后面的课程里，你还可以手工修改rsp的值，从而改变栈的大小。</p><p>最后，我们还有多种技术可以对汇编代码进行优化。首先是寄存器分配算法，可以让程序尽量少访问内存，多利用寄存器进行计算，我们后面的课程里也会围绕这个算法展开比较多的讨论。另外，指令选择算法也会挑选出更优的指令组合，让代码的性能更高。</p><p>今天这节课，我们已经初步熟悉了X86汇编代码。那么下节课，我们就动手用编译器生成这样的汇编代码吧！在这个过程中，你还会学习到更多关于X86汇编代码的知识。</p><h2>思考题</h2><p>我们这节课是以整数运算为例来讲解的。如果把整数换成长整数，也就是foo函数的参数和返回值都改成长整型，对应的汇编代码会有什么不同呢？我建议你尝试一下，然后把你的发现在留言区分享出来。</p><p>感谢你和我一起学习，也欢迎你把这节课分享给更多对汇编代码感兴趣的朋友。我是宫文学，我们下节课见。</p><h2>资源链接</h2><p><a href=\"https://sourceware.org/binutils/docs/as/index.html\">这里我放了一个GNU汇编器的手册。</a></p>","neighbors":{"left":{"article_title":"14｜汇编代码学习（一）：熟悉CPU架构和指令集","id":416043},"right":{"article_title":"16｜生成本地代码第1关：先把基础搭好","id":417353}}},{"article_id":417353,"article_title":"16｜生成本地代码第1关：先把基础搭好","article_content":"<p>你好，我是宫文学。</p><p>到目前为止，我们已经初步了解了CPU架构和X86汇编代码的相关知识点，为我们接下来的让编译器生成汇编代码的工作打下了不错的基础。</p><p>不过，我总是相信最好的学习方法就是实践。因为，只有你自己动手尝试过用编译器生成汇编代码，你才会对CPU架构和汇编的知识有更深刻的了解，总之，遇到问题，解决问题就好了。</p><p>所以呢，今天这节课，我们就开始着手生成X86汇编代码。我会带你分析生成汇编代码的算法思路，理解寄存器机与栈机在生成代码上的差别，以及了解如何在内存里表示汇编代码。</p><p>看上去工作有点多，不着急，我们一步步来。那首先，我们就通过一个实例，让你对生成汇编代码的算法思路有一个直觉上的认知。</p><h2>生成汇编代码的算法思路</h2><p>在前面的课里，我们已经学会了如何生成字节码。你也知道了，基本上，我们只需要通过遍历AST就能生成栈机的字节码。</p><p>但当时我们也说过，为栈机生成代码是比较简单的，比寄存器机要简单，这具体是为什么呢？</p><p>你可以保留这个疑问，先来跟我分析一个例子，看看我们要怎么把它转化成汇编代码，以及在这个过程中会遇到什么问题：</p><pre><code class=\"language-plain\">function foo(a:number, b:number):number{\n  let c = a+b+10;\n  return a+c;\n}\n</code></pre><!-- [[[read_end]]] --><p>你可以看到，这个函数有两个参数。为了提高程序的运行效率，在参数数量不多的情况下，参数通常都是通过寄存器传递的，我们暂且把传递这两个参数的两个寄存器叫做r1和r2。</p><p>接下来，我们要执行运算，也就是a+b+10。这该怎么做呢？这里你要注意的是，在生成指令的时候，我们通常不能直接把b的值加到a上，也就是从r2加到r1上。因为这样就破坏了r1原来的值，而这个值后面的代码有可能用到。</p><p>所以呢，我们这里就要生成两条指令。第一条指令，是把a的值从r1拷贝到一个新的寄存器r3；第2条指令，是把b的值从r2加到r3上，最终结果也就保存到了r3。</p><pre><code class=\"language-plain\">mov r1, r3\nadd r2, r3\n</code></pre><p>之后，我们要再加10。这个时候，我们可以放心地把10加到r3上。因为r3是我们自己生成的一个临时变量，我们可以确保其他代码不会用到它，所以我们可以放心地改变它的值。</p><pre><code class=\"language-plain\">add 10, r3\n</code></pre><p>接着，我们要把表达式a+b+10的值赋给本地变量c。对于本地变量，我们也是尽可能地把它放到寄存器里。不过呢，由于r3作为临时变量的任务已经圆满完成了，所以这个时候，我们可以用r3来表示c的值，这下我们就节省了一个寄存器。因此，这里我们不需要添加任何新的指令。</p><p>再接着，我们要计算a+c的值。为了不影响已有寄存器的值，我们又使用了一个新的寄存器r4，用来保存计算结果：</p><pre><code class=\"language-plain\">mov r1, r4\nadd r3, r4\n</code></pre><p>最后，我们要把计算结果返回。通常，根据调用约定，返回值也是放在某个寄存器里的。我们这里假设这个寄存器是r0。所以，我们可以用这两条指令返回：</p><pre><code class=\"language-plain\">mov r4, r0\nret\n</code></pre><p>到此为止，我们就已经成功地为foo函数生成了汇编代码。当然，这个汇编代码只是示意性的、逻辑性的，如果要让它成为真正可用的汇编代码，还要做一些调整，比如把寄存器的名称换成正式的物理寄存器的名称，如rax等。我这样叙述，是为了尽量保持简洁，避免你过早陷入到具体CPU架构的细节中去，增加认知负担。</p><p>好了，回顾我们的工作成果，你可能很快会发现一个问题：<strong>这么小的一个程序就占据了4个寄存器，如果我再多加点参数或者本地变量，那寄存器岂不会很快就会被用光？</strong></p><p>这个担心是很有道理的，你可以先看看下面的例子：</p><pre><code class=\"language-plain\">function foo(a:number, b:number, d:number, f:number):number{\n  let c = a+b+10;\n  let g = ...\n  let h = ...\n  return g+h;\n}\n</code></pre><p>在这个例子中，参数a、b、d、f和本地变量c、g、h，都会额外占用一个寄存器，并且每个变量的计算过程都有可能消耗额外的寄存器来保存临时变量，所以寄存器很快就会被用光。</p><p>到这里，你可能已经体会到了为什么给寄存器机生成代码会更难了。在栈机里，根本没有这样的问题，因为我们可以用操作数栈来保存中间结果，而操作数栈的大小是没有限制的。</p><p>那我们要如何解决寄存器数量有限的问题呢？</p><p>这就涉及到寄存器分配算法了。寄存器分配算法能够让程序最大限度地利用有限的物理寄存器，在物理寄存器数量不够的情况下，会把数据写到内存（通常是在栈里），把寄存器腾出来。</p><p>不过，我们现在还不是学习寄存器分配算法的时候，我们会在后面会有专门一节课来实现寄存器分配算法。我们现在的目标，是用相对简单的办法来生成汇编代码和可执行程序。</p><p><strong>那在不用寄存器算法的情况下，我们还能怎么办呢？</strong></p><p>其实，现代编译器都有一些算法可以快速生成汇编代码（机器码），而不用去做太多优化。特别是在JIT编译器中，有时编译速度本身是最重要的，要求能够快速生成机器码，对优化程度反而要求不高，比如JVM中的C1编译器就是这样的。有合适的机会，虚拟机才会调用优化编译器，对代码进行深度地优化。</p><p>在上一节课，我们已经见识到了编译器生成的未经优化的汇编代码。在那样的代码里，你可以把所有的参数和变量全部写到栈里，每次用到的时候就从栈桢里读出来。用内存来保存变量，那当然就不受寄存器数量的限制了，所以我们很容易就能生成汇编代码。</p><p>不过，在进行运算的时候，还是要用到寄存器的，比如加减乘数等操作，目标操作数要放在寄存器里，而不能直接在内存进行运算。所以，假设本地变量a、b、c都是内存中的变量，那么c=a+b对应的汇编代码就需要引入一个寄存器，也就是：</p><pre><code class=\"language-plain\">mov a, r1\nadd b, r1\nmov r1, c\n</code></pre><p>你看到，r1正是我们在前面的分析过程中所引入的临时变量。所以，在算法中只需要为临时变量分配物理寄存器就好了。</p><p>好，大的算法思路已经有了。那么在生成汇编代码之前，我们还需要设计一套数据结构。这套数据结构用于在内存里表示汇编代码，编译程序要先生成这些结构化的数据对象，然后再把这些数据对象输出成文本格式，才能获得汇编代码文件。</p><h2>内存数据结构</h2><p>目前，我们自己的编译器已经把文本格式的源代码，编译成AST和符号表这两个内部数据结构了。而我们现在的任务，是要把这些内部数据结构编译成汇编代码那样文本结构。</p><p>在之前的课程里，我们曾经基于AST和符号表来生成字节码，那时候我们遍历一下AST就生成了，算法比较简单。</p><p>但是生成汇编代码的过程就要复杂一些了，我们如果要直接通过遍历AST生成汇编代码，是比较困难的。所以，我们还要再设计一些中间的数据结构，那我们现在就先基于AST和符号表来生成这些中间的数据结构。</p><p>基于这个中间的数据结构，我们可以做多步的处理工作。比如，我们给每个函数生成的汇编代码要添加序曲和尾声部分，在序曲部分呢，我们要把这个函数用到的需要Callee保护的寄存器压到栈里。</p><p>而这个函数会用到哪些Callee保护的寄存器呢？这需要我们把函数体的代码生成后才能知道。像这样比较多步的处理过程，基于一个内存数据结构来做就会比较容易一些。等都处理完毕了，我们再基于这个内存数据结构生成汇编代码。</p><p>注意，我们有时候也把这种内存数据结构看做是一种IR，也就是中间代码。因为它也是我们程序的一种表示方式。这种表示方式比较贴近底层物理机的机制，所以也被叫做LIR。</p><p>我把当前用于在内存里表示汇编代码的数据结构画成了一张类图，你可以看一下。</p><p><img src=\"https://static001.geekbang.org/resource/image/82/2f/824239465075181a58d5ea14179dc12f.jpg?wh=1920x1080\" alt=\"图片\"></p><p>我一层层地给你分析一下这个数据结构，它包含了模块、基本块、指令、操作数这些对象。</p><p>先看第一层，AsmModule代表了一个模块，或者说相当于一个汇编代码的文件。</p><p>然后是第二层，BasicBlock代表了一个基本块。</p><p>什么是基本块呢？基本块是一系列顺序执行的指令。也就是说，你只能从第一条指令开始运行这个基本块，从最后一条指令离开基本块。没有办法从中间的某一条开始执行，也没有办法从中间离开。如果有一个跳转指令跳到这个基本块，那也只能跳转到基本块的第一条指令。基本块的最后一条指令可能是个跳转指令，可以跳转到别的基本块或者当前基本块。</p><p>在我们上一节课的例子中，一个函数只有一个基本块。但如果我们用了if语句和循环语句，那就会形成多个基本块，多个块之间通过跳转指令跳转，这个现象我们在生成字节码时已经看到了。</p><p>再进一步，因为从一个基本块可以跳转到另一个基本块，那么一个函数的多个基本块通过跳转语句就会连成一个图，这个图就叫做<strong>控制流图（CFG）</strong>。CFG是用于程序优化的一种重要的数据结构。llvm（C和C++等语言的编译器）和Go语言的优化算法，就是典型的基于CFG的结构。</p><p>我们接着看第三层，Inst代表了一条指令。每个指令都有一个操作码（OpCode）。它的子类Inst_0、Inst_1和Inst_2则分别代表没操作数的指令、一个操作数的指令和两个操作数的指令。</p><p>最后一层，Oprand代表了一个操作数。我们知道，在汇编代码里，操作数只有三类：立即数、寄存器和内存访问。在这里，我又添加了几个抽象度比较高的类型，比如逻辑寄存器、基本块、函数、字符串常量等。在后面的课程里，我会再跟你解释为什么需要这些抽象度较高的种类。这里操作数的类型用枚举量OprandKind表示。</p><p>好了，这些就是表示汇编代码的内存数据结构。基本的算法思路理好了，内存数据结构也有了，接下来我们终于可以着手生成汇编代码了。</p><h2>为基础功能生成汇编代码</h2><p>我们还是先针对我们这节课一开头的那个示例程序，先把生成汇编代码的逻辑走通，生成一些基础功能的汇编代码。之后，我们再来处理if语句、for循环语句、函数调用等等复杂的情况，具体的代码你可以参考代码库里的AsmGenerator。</p><p>你可以看到，我们整个算法仍然是通过遍历AST来完成的。在遍历prog节点的时候，我们就会生成主程序对应的LIR，也就是基本块、指令、操作数这些。我们可以把这个主程序看做一个函数，相当于C语言的main函数。而在遍历到函数声明节点的时候，程序就会生成这个函数所对应的LIR。</p><p>你可以重点看看几个关键节点的处理过程。</p><p>首先，我们在处理整数字面量节点（visitIntegerLiteral）的时候，只需要生成一个立即数类型的Oprand返回给上级节点就行了。</p><pre><code class=\"language-plain\">visitIntegerLiteral(integerLiteral:IntegerLiteral):any{\n    return new Oprand(OprandKind.immediate, integerLiteral.value);\n}\n</code></pre><p>然后，在处理变量（visitVariable）的时候，我们要生成一个变量下标类型的Oprand。</p><pre><code class=\"language-plain\">visitVariable(variable:Variable):any{\n    if (this.functionSym !=null &amp;&amp; variable.sym!=null){\n        return new Oprand(OprandKind.varIndex, this.functionSym.vars.indexOf(variable.sym));\n    }\n}\n</code></pre><p>这里你可能会问：怎么会有一个变量下标类型的操作数呢？我们之前讲汇编代码的时候，并没有这种类型的操作数呀？</p><p>其实，这就是按照我们前面的算法思路来的。在一开始，我们会认为当前CPU有无限个寄存器，每个寄存器有一个下标，对应一个变量，包括参数、本地变量和临时变量。所以，变量下标就可以看做是一个逻辑寄存器。之后，在寄存器分配算法中，我们再根据物理寄存器的数量，把这些逻辑寄存器对应到物理寄存器。如果逻辑寄存器的数量超出了物理寄存器的数量，我们再在栈里为逻辑寄存器分配内存空间。</p><p>接下来我们再看看如何处理二元表达式（visitBinary）。思路是这样的，我们首先获得左右两颗子树的返回值，也就是两个Oprand。然后基于这两个Oprand生成指令，并存入当前的基本块，最后的返回值也是一个Oprand，也就是存放表达式结果的那个寄存器。</p><pre><code class=\"language-plain\">visitBinary(bi:Binary):any{\n    ...\n    let left = this.visit(bi.exp1) as Oprand;  //左边操作数\n    ...\n    let right = this.visit(bi.exp2) as Oprand; //右边操作数\n    ...\n\n    let dest = ...   //计算出一个目标操作数    \n\n    switch(bi.op){\n        case Op.Minus: //'-'\n            insts.push(new Inst_2(OpCode.subl,right, dest));  //组合成一条指令\n            ...\n    }\n}\n</code></pre><p>在这节课前面的分析中，我们就讨论过临时变量的使用场景，以及如何尽量节省临时变量所占用的寄存器数量的问题。这里的做法也是一样的，在我们计算a+b+10的时候，a和b各自已经占据了一个逻辑寄存器，但a+b的结果还需要用一个临时变量来保存，并且我们也为这个临时变量申请一个逻辑寄存器t。那我们在计算t+10的时候呢，就不用再申请一个新的逻辑寄存器了，我们只需要把结果保存到t里就行了。</p><pre><code class=\"language-plain\">//计算出一个目标操作数\nlet dest: Oprand;\n\n//确定应该返回的Oprand，尽量重用已有的临时变量，并且释放不再使用的临时变量\nif (this.isTempVar(left) || bi.op == Op.Assign){  //'='\n    dest = left;\n    if (this.isTempVar(right)){\n        this.deadTempVars.push(right.value);\n    }\n}\nelse{\n    dest = new Oprand(OprandKind.varIndex, this.allocateTempVar());\n}\n</code></pre><p>从这个过程中，我们可以得到一个结论：<strong>无论这个表达式有多长，我们其实只需要少量临时变量就可以了，这样我们能最大程度地节省寄存器。</strong></p><p>另外，如果有些临时变量没有用了，那么我们的程序需要能够复用这些临时变量。比如，对于a * 3 + b * 4这样的表达式，+号两侧都会生成两个临时变量，我们先假设它们是t1和t2。但最后整个表达式的计算结果，只需要保存在t1里就行了（把t2的值加到t1上），那t2这个逻辑寄存器就空出来了。我们就可以把它加到一个deadTempVars的列表中，并在申请下一次申请临时变量时复用。</p><p>好了，算法逻辑我就先写这些。基于上面这些逻辑，我们已经可以把简单的函数编译成汇编代码了，你可以运行编译器试一下。编译器会生成以.s结尾的文件，然后你再用clang或gcc把这个.s文件编译成可执行文件就可以了。</p><p>而且，我已经把这些操作变成了Makefile的配置，比如，你用\"make example\"命令就可以把example.ts编译成example.s，然后再生成可执行文件example了。</p><h2>课程小结</h2><p>好了，今天的课就到这里了，我希望你记住下面这几个知识点：</p><p>首先，为寄存器机生成代码，最大的难点是物理寄存器的数量是有限的。通常在算法上我们会首先采用逻辑寄存器，假设寄存器的数量是无限的。之后，再把逻辑寄存器映射到物理寄存器或栈中的内存。</p><p>其实，<strong>这种先采用比较抽象的指令，然后再转化成更加具体的实现的过程，叫做Lower</strong>。Lower的思路是贯穿在整个编译过程中的。源代码的抽象度是最高的，最接近人类理解的，机器码是最具体的，是便于机器理解的。我们把源代码编译成机器码的过程，就是一个不断Lower的过程，中间我们可能会设计多级的中间代码，也就是IR。后面的课程中，我们还会继续体会这种Lower的过程。</p><p>第二，为了生成汇编代码，我们需要设计一套内存数据结构，用来表示模块、基本块、指令和操作数等。多个基本块会构成CFG，CFG是很多编译器中进行代码优化算法的基础。</p><p>在内存中的这套数据结构，其实也是一种中间代码，而且是比较靠近物理实现的中间代码，所以被叫做LIR，L是Low Level的意思。</p><p>在下节课里，我们会涉及到更多的知识点，包括如何实现简单的寄存器分配算法（也就是把逻辑寄存器映射到物理寄存器）、为if语句和for循环语句生成代码，以及维护栈桢等等。</p><h2>思考题</h2><p>通过最近几节课的内容，我相信你已经了解寄存器机的特点了。而在之前的课程中，我们设计的虚拟机是一个栈机。那如果我现在再请你实现一个虚拟机，这次用寄存器机，你有什么设计思路呢？如何设计它的指令？如何让它比栈机具有更高的性能？请分享一下你的想法。</p><p>感谢你和我一起学习，也欢迎你把这节课分享给更多对生成本地代码感兴趣的朋友。我是宫文学，我们下节课见。</p><h2>资源链接</h2><p><a href=\"https://gitee.com/richard-gong/craft-a-language/tree/master/16-18\">这节课的代码在这里！</a></p>","neighbors":{"left":{"article_title":"15｜汇编语言学习（二）：熟悉X86汇编代码","id":416809},"right":{"article_title":"17｜生成本地代码第2关：变量存储、函数调用和栈帧维护","id":418317}}},{"article_id":418317,"article_title":"17｜生成本地代码第2关：变量存储、函数调用和栈帧维护","article_content":"<p>你好，我是宫文学。</p><p>在上一节课里，我们已经初步生成了汇编代码和可执行文件。不过，很多技术细节我还没有来得及给你介绍，而且我们支持的语言特性也比较简单。</p><p>那么，这一节课，我就来给你补上这些技术细节。比如，我们要如何把逻辑寄存器映射到物理寄存器或内存地址、如何管理栈桢，以及如何让程序符合调用约定等等。</p><p>好了，我们开始吧。先让我们解决逻辑寄存器的映射问题，这其中涉及一个简单的寄存器分配算法。</p><h2>给变量分配物理寄存器或内存</h2><p>在上一节课，我们在生成汇编代码的时候，给参数、本地变量和临时变量使用的都是逻辑寄存器，也就是只保存了变量的下标。那么我们要怎么把这些逻辑寄存器对应到物理的存储方式上来呢？</p><p>我们还是先来梳理一下实现思路吧。</p><p>其实，我们接下来要实现的寄存器分配算法，是一个比较初级的算法。你如果用clang或gcc把一个C语言的文件编译成汇编代码，并且不带-O1、-O2这样的优化选项，生成出来的汇编代码就是采用了类似的寄存器分配算法。现在我们就来看看这种汇编代码在实际存储变量上的特点。</p><p>首先，程序的参数都被保存到了内存里。具体是怎么来保存的呢？你可以先看看示例程序<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/16-18/param.c\">param.c</a>：</p><pre><code class=\"language-plain\">void println(int a);\n\nint foo(int p1, int p2, int p3, int p4, int p5, int p6, int p7, int p8){\n    int x1 = p1*p2;\n    int x2 = p3*p4;\n    return x1 + x2 + p5*p6 + p7*p8;\n}\n\nint main(){\n    int a = 10;\n    int b = 12;\n    int c = a*b + foo(a,b,1,2,3,4,5,6) + foo(b,a,7,8,9,10,11,12);\n    println(c);\n    return 0;\n}\n</code></pre><!-- [[[read_end]]] --><p>这个示例程序所对应的汇编代码是<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/16-18/param.s\">param.s</a>，我摘取了其中的一部分，这段代码展示了参数是如何被保存到内存的：</p><pre><code class=\"language-plain\">## 把参数值保存到内存\nmovl   %edi, -4(%rbp)\nmovl    %esi, -8(%rbp)\nmovl    %edx, -12(%rbp)\nmovl    %ecx, -16(%rbp)\nmovl    %r8d, -20(%rbp)\nmovl    %r9d, -24(%rbp)\n</code></pre><p>在这个示例程序中，foo函数有8个参数。根据<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/13/System%20V%20Application%20Binary%20Interface%20AMD64%20Architecture%20Processor%20Supplement%20Draft%20Version%200.99.6.pdf\">System V AMD64的ABI</a>和C语言的调用约定，其中前6个参数是通过寄存器传递的，其他两个参数是通过栈桢传递的。</p><p>在汇编代码中，我们会发现这6个通过寄存器传递的参数，都先被保存到了栈桢中。这6个寄存器和参数的对应关系是这样的：<br>\n<img src=\"https://static001.geekbang.org/resource/image/22/33/22ff0091312f4df5fb6313bdf3045333.jpg?wh=1920x570\" alt=\"图片\"><br>\n我也把它们保存在栈桢里的位置画成了一张图，你可以看一下：<br>\n<img src=\"https://static001.geekbang.org/resource/image/21/e1/213c71d3e770fdc7972b622c77b8d6e1.jpg?wh=1920x1080\" alt=\"图片\"><br>\n你可以看到，这里面的前6个参数的位置，都是从rbp的位置依次向下4个字节，也就是一个整数的位置。参数1是-4(%rbp)，参数2是-8(%rbp)，依此类推。</p><p>而大于6个的参数，是保存在调用者的栈桢里的。其中参数7的地址是16(%rbp)，也就是rbp指针往上16个字节。这里为什么要加上16个字节呢？这是因为，这16个字节中，有8个字节是返回地址，是由callq _foo指令压到栈里的，还有8个字节是rbp之前的值，是由pushq rbp压到栈里的。</p><p>好，到目前为止，我们就知道如何在汇编代码里访问每个参数了。你可以查看代码库里的<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/16-18/asm_x86-64.ts#L1178\">lowerVars</a>代码，它把每个参数转变成了一个内存地址类型的Oprand。</p><pre><code class=\"language-plain\">//处理参数\nfor (let varIndex:number = 0; varIndex&lt;this.numTotalVars; varIndex++){\n    let newOprand:Oprand;\n    if (varIndex &lt; this.numParams){\n        if (varIndex &lt; 6){\n            //从自己的栈桢里访问。在程序的序曲里，就把这些变量拷贝到栈里了。\n            let offset = -(varIndex + 1) *4; \n            newOprand = new MemAddress(Register.rbp,offset); \n        }\n        else{\n            //从Caller的栈里访问参数\n            //+16是因为有一个callq压入的返回地址，一个pushq rbp又加了8位\n            let offset = (varIndex - 6)*8 + 16;  \n            newOprand = new MemAddress(Register.rbp,offset);        \n        }   \n    }\n    ...\n}\n</code></pre><p>接下来，我们再看看本地变量。在示例程序<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/16-18/param.c\">param.c</a>中，有x1和x2两个本地变量，你可以阅读<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/16-18/param.s\">param.s</a>，看看它们都是存在哪的。</p><p>我相信，经过这么多节课的训练，现在你阅读汇编代码应该越来越熟练了。在这个代码里，你可以看到x1实际上是存在-28(%rbp)的，而x2是存在-32(%rbp)的。也就是说，在栈桢里，它们是紧挨着参数的区域继续往下延伸的，你可以看看下面这张图。</p><p><img src=\"https://static001.geekbang.org/resource/image/9b/45/9b4b437edbe28b3e69f77990e17dd345.jpg?wh=1920x1080\" alt=\"图片\"></p><p>好了，<strong>现在对于参数和本地变量的保存，我们都搞清楚了，它们都是保存在内存的栈桢里的</strong>。那么临时变量呢？临时变量也保存在内存里吗？</p><p>这是不行的。为什么呢？这是因为，X86指令集中加减乘除等指令和mov指令对内存地址的使用是有限制的。</p><p>怎么理解呢？我们分析一下x1=p1*p2这条语句来看看。在上节课中，我们已经知道这条语句在生成汇编代码时，需要用到一个临时变量t1，所以整条语句在逻辑上相当于下面这三条汇编代码：</p><pre><code class=\"language-plain\">movl p1, t1  #把p1拷贝到t1\nimull p2, t1 #把p2乘到t1上\nmovl t1, x1  #把t1赋给x1\n</code></pre><p>在这里，p1和p2都是内存地址。如果t1也是内存地址，我们假设它是-36(%rbp)，那么这三条汇编代码就会变成：</p><pre><code class=\"language-plain\">movl -4(%rbp), -36(%rbp)  #把p1拷贝到t1\nimull -8(%rbp), -36(%rbp) #把p2乘到t1上\nmovl -36(%rbp), -4(%rbp)  #把t1赋给x1\n</code></pre><p>但是如果你用汇编器编译这三条代码，汇编器会报错。</p><p>这是为什么呢？因为x86中汇编代码的规则虽然比较宽松，在加减乘除等很多运算性指令里都支持使用内存地址作为操作数，但它只允许源操作数是内存地址，不允许目标操作数是内存地址。而mov指令支持目标操作数是内存地址，但这个时候源操作数必须是立即数或寄存器，不支持把数据从一个内存地址拷贝到另一个内存地址。</p><p>那么我们要怎么来修改这三条代码，让它变成合法的X86汇编代码呢？</p><p>很简单，我们只要给临时变量t1分配一个物理寄存器就可以了。你可以参考<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/16-18/param.s\">param.s</a>的代码，它给t1分配了一个%ecx寄存器，完美地解决了这个问题：</p><pre><code class=\"language-plain\">movl   -4(%rbp), %ecx   #把p1拷贝到t1\nmull   -8(%rbp), %ecx   #把p2乘到t1上\nmovl    %ecx, -28(%rbp) #把t1赋给x1\n</code></pre><p>所以，现在我们就清楚了：<strong>对于临时变量，我们都统一给它们分配寄存器就行了</strong>。</p><p>那进一步的问题又来了：我们给这些临时变量分配哪些寄存器呢？是先分配那些由Caller保护的寄存器，还是Callee保护的寄存器？用哪类寄存器的代价更低呢？这几个问题你可以先记着，自己想一会，后面你看看示例代码是如何实现的。</p><p>好了，现在我们已经给参数、本地变量和临时变量都分配了物理的存储方式。这个过程，我们叫做把变量做Lower处理的过程，你可以看一下<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/16-18/asm_x86-64.ts#L1178\">lowerVars</a>方法。</p><p>并且，基于我们上面这个分配方法，所有的二元计算都能生成正确的汇编代码。你可以在<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/16-18/example.ts\">example.ts</a>中写一些表达式计算的代码，然后再用make example命令做构建。这会生成汇编代码文件example.s和可执行文件example，你再看看它们能否正确地运行。</p><p>接下来，我们再研究一下如何实现函数的调用。</p><h2>实现函数调用</h2><p>我们仍然用示例代码<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/16-18/param.c\">param.c</a>来做研究。在示例代码中，我们用main函数调用了foo函数。由于foo函数的参数比较多，所以我建议你好好看一下<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/16-18/param.s\">param.s</a>中传参的具体过程。</p><pre><code class=\"language-plain\">movl   -8(%rbp), %edi   ##参数1，变量a\nmovl    -12(%rbp), %esi ##参数2，变量b\nmovl    $1, %edx        ##参数3\nmovl    $2, %ecx        ##参数4\nmovl    $3, %r8d        ##参数5\nmovl    $4, %r9d        ##参数6\nmovl    $5, (%rsp)      ##参数7\nmovl    $6, 8(%rsp)     ##参数8\n...\ncallq   _foo\n</code></pre><p>根据我们目前掌握的参数传递的知识，这里的前6个参数赋给了6个寄存器，而第7和第8个参数，则是基于rsp，赋给(%rsp)和8(%rsp)这两个内存地址。而在被调用者中，访问这两个参数则是使用16(%rbp)和24(%rbp)。</p><p>我也画了一张图，给你展示了如何在Caller和Callee的栈桢中访问参数7和参数8：</p><p><img src=\"https://static001.geekbang.org/resource/image/8e/fd/8e15e972dd84d7a9352dff7227c253fd.jpg?wh=1920x1080\" alt=\"图片\"></p><p>你要注意，这里每个参数都占用了8个字节，而不是像前面在Caller的栈桢里保存参数和本地变量那样，占用4个字节。你能不能想一想这是什么原因呢？</p><p>我估计你已经猜到了。这是因为在制定ABI的时候，要兼容尽量多的场景。这个规定，使得我们能够用同样的方式传递整型和长整型的参数，而长整型就需要占据8个字节。</p><p>你可以看看<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/16-18/param_long.c\">param_long.c</a>及其对应的<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/16-18/param_long.s\">param_long.s</a>汇编代码文件。你会发现，在这个示例文件中，我们把整型的参数改成了长整型，但是传递第7个和第8个参数的方法方式没有任何改变。在代码里访问这两个参数值的内存地址的表达方式，也是一样的。</p><p>好了，我们已经了解了函数调用中传参的过程了，具体实现你可以参见代码库中的<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/16-18/asm_x86-64.ts#L1419\">lowerFunctionCall</a>方法。那么现在我们是不是就可以调用callq指令来做函数调用了呢？还不行。为什么呢？因为我们还有一项重要的工作要做，就是<strong>保护好某些寄存器的值。</strong></p><p>还记得吗？在函数调用的过程中，有些寄存器的值是由Caller负责保护的，而另一些寄存器的值是由Callee负责保护的，这是为了避免可能由于多方使用同一个寄存器，导致寄存器的值被破坏，从而导致计算错误的问题。</p><p>我们还是通过示例代码来分析一下寄存器的使用可能产生的冲突。你会看到，在<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/16-18/param.c\">param.c</a>中有下面的一行代码：</p><pre><code class=\"language-plain\">int c = a*b + foo(a,b,1,2,3,4,5,6) + foo(b,a,7,8,9,10,11,12);\n</code></pre><p>这行代码是我故意设计的，目的就是制造出寄存器使用上的冲突。整个计算过程大致可以分成下面这几步，其中涉及到t1、t2和t3三个临时变量。</p><pre><code class=\"language-plain\">t1 = a*b\nt2 = foo(a,b,1,2,3,4,5,6)\nt1 = t1 + t2\nt3 = foo(b,a,7,8,9,10,11,12)\nt1 = t1 + t3\nc = t1\n</code></pre><p>首先，我们需要计算表达式a*b，这个结果我们用t1表示，并把它映射到寄存器。在<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/16-18/param.s\">param.s</a>里，这个寄存器是eax。</p><p>接着，我们需要调用foo()函数，假设返回值保存在t2中。这里要注意，根据ABI，foo()函数的返回是要保存到eax中的，所以t2和t1都要使用eax寄存器。为了防止t1的值被破坏，我们就必须先把它写到栈里去。</p><pre><code class=\"language-plain\">movl   %eax, -20(%rbp)      ## 4-byte Spill\ncallq  _foo\nmovl    -20(%rbp), %ecx     ## 4-byte Reload\naddl   %eax, %ecx           ## t1 = t1 + t2，把t2的值加到t1上\n</code></pre><p>接下来，在调用foo函数以后，我们要把t1和t2相加。在此之前，我们又需要把t1从内存中恢复到寄存器里来。但这个寄存器不再是eax，因为现在t2已经占用了eax。所以，t1被装载到了ecx寄存器中。</p><p>再接着，我们还要再一次调用foo函数。在这次调用中，寄存器的使用再次产生了冲突，因为这次我们要用ecx来传递foo函数的第四个参数。那这又要怎么办呢？我们还是要把t1的值从ecx寄存器里保存到内存中，在调用完foo之后，再从内存恢复到寄存器。</p><pre><code class=\"language-plain\">movl   %ecx, -24(%rbp)    ## 4-byte Spill\n...\ncallq  _foo\nmovl    -24(%rbp), %ecx   ## 4-byte Reload\naddl    %eax, %ecx        ## t1 = t1 + t3, 把t3的值再加到t1上。\nmovl   %ecx, -16(%rbp)    ## c = t1\n</code></pre><p>好了，通过上面这个例子的分析，我相信你已经对寄存器的冲突有了比较直观的了解。这里，我再带你总结一下可能发生冲突的场景：</p><ul>\n<li>场景1，某个临时变量使用了eax，但接下来的函数返回值也要使用eax，也就是这个eax 在Callee中去做了设置；</li>\n<li>场景2，某个临时变量使用了edi、esi、edx、ecx、r8d和r9d这6个寄存器其中的一个，接下来的函数调用还要这个寄存器来传递参数；</li>\n<li>场景3，在Caller中使用了不由Callee保护的寄存器，比如r10d、r11d等等。在ABI中，规定只有ebx、r12d~r15d这几个寄存器是由Callee保护的，所以其他的寄存器，都需要由Caller保护，避免被Callee破坏。</li>\n</ul><p>那我们要如何保护这些寄存器呢？我们需要把它们的值写到栈桢里，之后再从栈桢里恢复。</p><p>注意，把一个临时变量t保存到内存的过程叫做Spill，也叫做溢出，我们在后面专门学习寄存器分配算法的时候会再次见到这个词汇。把t从内存再重新装载到寄存器的过程，叫做Reload。不过这里你也要注意，虽然新的寄存器不一定是原来那个寄存器，但编译器会知道，这还是原来那个临时变量t。</p><p>Spill和Reload的实现，你仍然可以参见<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/16-18/asm_x86-64.ts#L1419\">lowerFunctionCall</a>方法。</p><p>那么，到目前为止，我们已经往栈桢里放了很多数据，包括返回值地址、rbp的原值、参数，还有本地变量。而且，把临时变量溢出（Spill）到内存里也需要预留一些空间，调用函数时给函数传参也需要使用栈的空间。</p><p>那我们现在就再进一步，梳理一下栈桢里的内容，也来分析一下我们要怎么做好栈桢的维护。</p><h2>栈桢的维护</h2><p>你可以先看一下，采用我们目前的算法形成的栈桢结构是这样的：</p><p><img src=\"https://static001.geekbang.org/resource/image/f5/a3/f5ab10b57d420d11265434ec74ec52a3.jpg?wh=1920x1080\" alt=\"图片\"></p><p>一个栈桢从上到下，依次是返回值、rbp原值、Callee保护的寄存器（目前我们的示例程序中还没有用到这些寄存器）、参数、本地变量、溢出到内存的临时变量。</p><p>然后你再从栈顶，也就是栈桢的最底下往上看，这里是我们在调用函数时，为超过6个的参数所保存的空间。</p><p>然后你还会注意到，在栈桢中间可能还有一些多余的空间。为什么会这样呢？</p><p>第一个原因，是这个函数可能会调用多个函数，而被调用的多个函数所需的参数数量是不同的，因此我们需要为参数最多的那个函数预留出足够的用于保存参数的空间。</p><p>第二个原因，是内存对齐。原来，在ABI中规定，如果这个函数要调用另一个函数，那么参数区的尾部应该是16字节对齐的。所以说，参数区的尾部也是两个栈桢之间的分界线。换句话说，在控制转移到函数入口的那一刻，(%rsp+8)的值是能够被16整除的。这里的8，是因为callq指令把8位的一个返回地址压到了栈里。</p><p>我建议你看看<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/13/System%20V%20Application%20Binary%20Interface%20AMD64%20Architecture%20Processor%20Supplement%20Draft%20Version%200.99.6.pdf\">ABI文档</a>中对栈桢的描述，我截取了一小段，你可以看看：</p><p><img src=\"https://static001.geekbang.org/resource/image/97/0d/979a6b4f32d2d48f3ab02762dbd0970d.png?wh=1524x442\" alt=\"图片\" title=\"来源：System V Application Binary Interface AMD64 Architecture Processor Supplement Draft Version 0.99.6\"></p><p>基于上面的原则，我们在为一个函数建立栈桢的时候，需要计算出rsp移动的量，以便确定正确的栈桢尺寸。在<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/16-18/param.s\">param.s</a>的_main函数中，序曲和尾声部分各有一行指令，就是用来移动rsp指针的。</p><pre><code class=\"language-plain\">##序曲\npushq  %rbp\nmovq    %rsp, %rbp\nsubq    $48, %rsp    ##把栈桢扩展48个字节。整个栈桢的大小是48+16字节\n\n##函数体\n...\n\n##尾声\naddq\t$48, %rsp    ##缩回栈桢\npopq\t%rbp\nretq\n</code></pre><p>不过，刚才我们看的是main函数的栈桢的情况。但对于foo函数来说，它的栈桢会有所不同。</p><p>有什么区别呢？区别就在于，foo函数是叶子函数，也就是说它没有调用其他函数。在这个情况下，我们根本没有必要移动rsp指针来为栈桢申请内存。只要foo函数占用的内存不超过128个字节，我们直接使用红区（RedZone）就行了。它的栈桢结构如下图所示，这时rsp的值和rbp的值是相同的。</p><p><img src=\"https://static001.geekbang.org/resource/image/94/54/942530836aecb652579f505a13a7ee54.jpg?wh=1920x1080\" alt=\"图片\"></p><p>关于红区的知识点，我仍然建议你阅读<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/13/System%20V%20Application%20Binary%20Interface%20AMD64%20Architecture%20Processor%20Supplement%20Draft%20Version%200.99.6.pdf\">ABI文档</a>，我在这里也贴了一小段，供你参考。</p><p><img src=\"https://static001.geekbang.org/resource/image/9e/c7/9ec76b76c6da5d3b04469bac92876cc7.png?wh=1488x326\" alt=\"图片\" title=\"来源：System V Application Binary Interface AMD64 Architecture Processor Supplement Draft Version 0.99.6\"></p><p>现在，栈桢维护的原理，我们已经讲清楚了，至于具体的计算栈桢大小、维护栈桢的代码，你可以在代码库中的<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/16-18/asm_x86-64.ts#L1262\">addPrologue</a>和<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/16-18/asm_x86-64.ts#L1312\">addEpilogue</a>两个函数中看到。在这里，你要特别关注一下其中计算栈桢大小的相关代码，以此为线索你就能搞清楚整个栈桢的内存布局了。我相信，在明白原理之后，你再阅读这些代码，可以保持一条比较清晰的思路。</p><h2>课程小结</h2><p>好了，今天的内容就是这些，到今天这节课为止，我们的语言已经能够为表达式计算和函数调用等功能生成汇编代码和可执行文件了。那么今天这节课，我希望你记住下面几个关键的知识点：</p><p>首先，我们在采用简单的寄存器分配算法时，通常是把参数、本地变量都保存到栈桢里，但临时变量则要用使用寄存器，在这个过程中，我们加深了对x86指令的理解。像加减乘除等运算，目标操作数应该是寄存器，而对源操作数就没有这个要求了。另外，mov指令虽然在源操作数和目标操作数中都可以使用内存地址，但不能两个操作数都是内存地址。</p><p>第二，我们再次熟悉了函数调用的约定，也就是前6个参数用寄存器，超过6个的参数使用Caller的栈桢。不过这次，我们更细致地了解了从Caller和Callee中应该如何访问这些额外的参数。具体来说，在Caller中我们要基于rsp寄存器来寻址，但在Callee中则要基于rbp寄存器来寻址。</p><p>第三，在调用函数时，会发生寄存器使用冲突的情况，这个时候我们需要把保存在寄存器中的临时变量溢出到内存中，需要时再装载回来，而这两个操作使用的寄存器可能并不是同一个。</p><p>最后，我们总结了栈桢的内存布局设计，并指出了如何正确地移动栈顶指针rsp来申请内存。在这个过程中，栈桢要保证16字节内存对齐。而对于叶子函数，我们还可以直接使用RedZone，不用移动栈顶指针rsp。不过，这里要指出的是，对于这个内存布局，只有超过6个的额外参数的位置、返回地址的位置，还有内存对齐等少量内容是由ABI规定的，其他大部分栈桢空间都是语言的设计者自己决定如何使用的。</p><p>最后再补充一句，到目前为止，我在这节课提到的所有寄存器，都是与整数计算有关的寄存器。如果你要进行浮点数计算，使用的寄存器会是另外一组，我们在后面的课程里再详细介绍。</p><h2>思考题</h2><p>在这节课的示例代码中，我们看到临时变量首先使用的是Caller保护的寄存变量，比如eax，而不是Callee保护的。这又是什么道理呢？请你分析一下。</p><p>感谢你和我一起学习，也欢迎你把这节课分享给更多对生成本地代码感兴趣的朋友。我是宫文学，我们下节课见。</p><h2>资源链接</h2><p><a href=\"https://gitee.com/richard-gong/craft-a-language/tree/master/16-18\">这节课的示例代码在这里！</a></p>","neighbors":{"left":{"article_title":"16｜生成本地代码第1关：先把基础搭好","id":417353},"right":{"article_title":"18｜生成本地代码第3关：实现完整的功能","id":418808}}},{"article_id":418808,"article_title":"18｜生成本地代码第3关：实现完整的功能","article_content":"<p>你好，我是宫文学。</p><p>到目前为止，我们已经把挑战生成本地代码的过程中会遇到的各种难点都解决了，也就是说，我们已经实现基本的寄存器分配算法，并维护好了栈桢。在这个基础上，我们只需要再实现其他的语法特性就行了。</p><p>所以，在今天这节课，我们要让编译器支持条件语句和循环语句。这样的话，我们就可以为前面一直在使用的一些例子，比如生成斐波那契数列的程序，生成本地代码了。然后，我们可以再比较一次不同运行时机制下的性能表现。</p><p>还记得吗？我们在前面已经分别使用了AST解释器、基于JavaScript的虚拟机和基于C语言的虚拟机来生成斐波那契数列。现在我们就看看用我们自己生成的本地代码，性能上是否会有巨大的变化。</p><p>在这个过程中，我们还会再次认识CFG这种数据结构，也会考察一下如何支持一元运算，让我们的语言特性更加丰富。</p><p>那首先我们来看一下，如何实现if语句和for循环语句。</p><h2>支持if语句和for循环语句</h2><p>在前面的课程中，我们曾经练习过为if语句和for循环语句生成字节码。不知道你还记不记得，其中的难点就是生成跳转指令。在今天这节课，我们会完成类似的任务，但采用的是一个稍微不同的方法。</p><p>我们还是先来研究一下if语句，看看针对if语句，编译器需要生成什么代码。我们采用下面一个C语言的示例程序，更详细的代码你可以参见代码库中的<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/16-18/if.c\">if.c</a>：</p><!-- [[[read_end]]] --><pre><code class=\"language-plain\">int foo(int a){\n    if (a &gt; 10)\n        return a + 8;\n    else\n        return a - 8;\n}\n</code></pre><p>C语言的编译器针对这段示例程序，会生成下面的汇编代码（参见代码库中的<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/16-18/if.s\">if.s</a>），我对汇编代码进行了整理，并添加了注释。</p><p>这段汇编代码是未经优化的。不过，我相信你经过前面课程的训练，应该可以看出来很多可以用手工优化的地方。不过现在我们关注的重点是跳转指令，所以你可以重点看一下代码中的cmpl指令、jle指令和jmp指令。</p><p><img src=\"https://static001.geekbang.org/resource/image/8f/1e/8fdce9c2357d7f91809ca31fd199011e.png?wh=1182x922\" alt=\"图片\"></p><p>我们现在来分析一下。第一个cmpl指令的作用是比较两个整数的大小。在这个例子中，是比较a和10的大小，计算结果会设置到eflags寄存器中相应的标志位。</p><p>第二个jle指令，它的作用是根据eflags寄存器中标志位决定是否进行跳转，如果发现是小于等于的结果，那么就进行跳转，这里是跳转到else块。如果是大于呢，就会顺着执行下面的指令，也就是if块的内容。</p><p>最后我们来看jmp指令，这是无条件跳转指令，相当于我们前面学过的字节码中的goto指令。</p><p>认识了这三个指令以后，我们就知道程序的跳转逻辑了。在这个C语言的示例程序中，一共有四个基本块，我把它们之间的跳转关系画成了图，可以更加直观一些：</p><p><img src=\"https://static001.geekbang.org/resource/image/6f/64/6f93391a1538f9c83cbcfc74a1yy3964.jpg?wh=1920x1080\" alt=\"图片\"></p><p>在分析清楚了整个思路以后，为if语句生成本地代码的逻辑也就很清楚了，我们现在就动手吧。完整的代码你可以查看代码库里的<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/16-18/asm_x86-64.ts#L488\">visitIfStmt方法</a>，我这里挑重点和你分析一下。</p><p>首先，我们要生成4个基本块：</p><pre><code class=\"language-plain\">//条件\nlet bbCondition = this.getCurrentBB();\nlet compOprand = this.visit(ifStmt.condition) as Oprand;\n\n//if块\nlet bbIfBlcok = this.newBlock();\nthis.visit(ifStmt.stmt);\n\n//else块\nlet bbElseBlock:BasicBlock|null = null\nif (ifStmt.elseStmt != null){\n    bbElseBlock = this.newBlock();\n    this.visit(ifStmt.elseStmt);\n}\n\n//最后，要新建一个基本块,用于If后面的语句。\nlet bbFollowing = this.newBlock();\n</code></pre><p>接着，我们要添加跳转指令，在4个基本块之间建立正确的跳转关系。这其中，最关键的就是我们怎么来为基本块0，也就是if条件所在的基本块生成跳转指令。</p><p>你会看到，在<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/16-18/asm_x86-64.ts#L624\">visitBinary</a>函数中，我们为if条件中的比较表达式生成了一条cmpl指令。那这个时候，visitBinary为上级调用者返回什么操作数呢？</p><p>回忆一下，在上一节课，当我们为其他表达式生成指令之后，会返回一个操作数，代表该指令的执行结果会放在该操作数中，这个操作数通常会是一个逻辑寄存器。不过，cmpl指令跟加减乘除等指令不同，该指令不会改变目标寄存器的值，而是改变eflags寄存器的值。</p><p>为了体现这个逻辑，我就使用了一种新的操作数类型，也就是flag类型。这样的话，比较运算就返回一个flag类型的操作数就好了，而且这个操作数里也会记录下比较运算符。</p><pre><code class=\"language-plain\">case Op.G:    \ncase Op.L:\ncase Op.GE:\ncase Op.LE:\ncase Op.EQ:      \ncase Op.NE: \n    insts.push(new Inst_2(OpCode.cmpl, right, dest)); \n    dest = new Oprand(OprandKind.flag, this.getOpsiteOp(bi.op));\n    break;      \n</code></pre><p>现在，根据这个操作数中记录的比较运算符，我们可以生成正确的跳转指令了。比如，如果比较运算符是大于，那么生成的跳转指令就是小于等于，也就是jle。跳转到哪里呢？跳转到基本块2，对应的指令是“jle LBB0_2”。其中，0_2代表第0个函数的第2个基本块。</p><p>不过，在这个阶段，我并没有基于计算出这个标签值来，而是采用了类型为“bb”的一个操作数，指向目标基本块即可。接下来，我们会再通过一个<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/16-18/asm_x86-64.ts#L1329\">Lower过程</a>，计算出每个基本块准确的标签值。在这里，我们又一次使用了抽象类型的操作数，这会使指令生成过程得到简化。</p><p>这里你要注意，在编译器生成基本块的过程中，有些基本块可能是空的块，也就是块中没有代码。这也很容易理解，因为有些Block可能就是空的。那么在Lower的过程中，这些空块也会被去除掉。</p><p>好了，到目前为止，我们已经能够为if语句正确的生成指令了。</p><p><strong>那接下来，我们为for循环语句生成指令的要点也是类似的，都是生成多个基本块，并且用跳转指令进行正确的拼接。</strong>你可以参考一下代码库里的<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/16-18/example_for.ts\">example_for.ts</a>。</p><p>我这里也摘取了一个关键的示例程序，我们来简单分析一下：</p><pre><code class=\"language-plain\">let sum:number = 0;\n\nfor (let i:number =0; i&lt;10; i++){\n    sum = sum + i;\n}\n\nprintln(sum);\n</code></pre><p>这个示例程序的CFG是这样的（基于<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/16-18/for.s\">for.s</a>生成）：</p><p><img src=\"https://static001.geekbang.org/resource/image/5d/63/5d33015898c5c1a62dfe08279327bd63.jpg?wh=1920x1080\" alt=\"图片\"></p><p>你可以多熟悉一下这些if和for循环结构所对应的CFG图，因为我们后面在学习寄存器分配算法的时候，还要跟这样的CFG打交道。</p><p>在实现for循环语句的过程中，我们还会碰到一个小的技术点，也就是一元运算。一元运算，特别是++和- -这样的运算符，实现起来有点特殊，也值得我们稍微探讨一下。</p><h2>实现一元运算</h2><p>在for循环语句中，我们通常都会使用一个递增变量。比如在<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/16-18/example_for.ts\">example_for.ts</a>中，你就会看到i++这种表达式。</p><p>对于i++来说，我们需要返回i的当前值，然后再让i的值加1。但对于++i来说，则是先让i的值加1，然后返回增加后的值。</p><p>这里的具体实现你可以参照代码库里<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/16-18/asm_x86-64.ts#L744\">visitUnary</a>方法，下面我摘取了其中处理++和- -的代码片段，我们来分析一下。</p><pre><code class=\"language-plain\">let oprand = this.visit(u.exp) as Oprand;\n\n//用作返回值的Oprand\nlet result:Oprand = oprand;  \n\n//++和--\nif(u.op == Op.Inc || u.op == Op.Dec){\n    let tempVar = new Oprand(OprandKind.varIndex, this.allocateTempVar());\n    insts.push(new Inst_2(OpCode.movl, oprand, tempVar));\n    if(u.isPrefix){  //前缀运算符\n        result = tempVar;\n    }\n    else{  //后缀运算符\n        //把当前操作数放入一个临时变量作为返回值\n        result = new Oprand(OprandKind.varIndex, this.allocateTempVar());\n        insts.push(new Inst_2(OpCode.movl, oprand, result));\n        this.s.deadTempVars.push(tempVar.value);\n    }\n    //做+1或-1的运算\n    let opCode = u.op == Op.Inc ? OpCode.addl : OpCode.subl;\n    insts.push(new Inst_2(opCode, new Oprand(OprandKind.immediate,1), tempVar));\n    insts.push(new Inst_2(OpCode.movl, tempVar, oprand));\n}\n</code></pre><p>对于++i来说，计算逻辑大致如下面的伪代码。也就是我们先申请一个临时变量t1，把t1加1，再赋给i，最后返回t1。这个时候返回值就是i+1。</p><pre><code class=\"language-plain\">t1 = i\nt1 = t1+1\ni = t1\nreturn t1\n</code></pre><p>但对于i++来说，它的计算逻辑就要多引入一个临时变量t2了，并且一开始要让t1和t2都等于i。t1的作用，仍然是i增加了1，但返回值却是t2，也就是i原来的值。</p><pre><code class=\"language-plain\">t1 = i\nt2 = i\nt1 = t+1\ni = t1\nreturn t2;\n</code></pre><p>除了++和- -外，还有其他的一元运算符，如+和-。</p><p>对+号的处理比较简单，实际上我们直接忽略就行了。其实，忽略+号的这个动作甚至不用等到生成汇编代码的环节，我们应该在代码优化的环节就把它去掉。</p><p>对于-号，它的计算逻辑则是用0去减当前的值。在这个过程中，我们仍然需要用到临时变量，你可以看看下面这个代码：</p><pre><code class=\"language-plain\">//-\nelse if (u.op == Op.Minus){\n    let tempVar = new Oprand(OprandKind.varIndex, this.allocateTempVar());\n    //用0减去当前值\n    insts.push(new Inst_2(OpCode.movl, new Oprand(OprandKind.immediate,0), tempVar));\n    insts.push(new Inst_2(OpCode.subl, oprand, tempVar));\n    result = tempVar;\n    if (this.isTempVar(oprand)){\n        this.s.deadTempVars.push(oprand.value);\n    }\n}\n</code></pre><p>好了，在实现了if语句和for循环语句以后，我们几乎已经完成生成本地代码的所有工作了。那现在又到了检验我们工作成果的时候了，我们再做一次性能比拼，看看这一次，我们的程序性能有多高。</p><h2>再一次进行性能比拼</h2><p>我们还是用斐波那契数列的例子来做测试，你用make example_fibo命令就可以编译并生成汇编代码和可执行文件，并且能够打印出每次执行所花费的时间。你还可以用make fibo命令编译C语言版本的示例程序，用来做性能比较。</p><p>我把比较结果放在下面的表格中，这次，我们只比较C语言的栈机和本地代码版就可以了，因为本地代码版速度实在是快太多了，以至于跟AST解释器和TypeScript版的栈机做比较已经没有太大意义了。</p><p><img src=\"https://static001.geekbang.org/resource/image/93/6d/934a282a25ddd316ffa25639cae37b6d.jpg?wh=1920x1051\" alt=\"图片\"></p><p>从表格可以看出，本地代码版的速度基本上是栈机版的20多倍，可以说性能有了极大的提升。</p><p>另外，我们还把用纯C语言写的版本（<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/16-18/fibo.c\">fibo.c</a>）的性能加到了表格里，作为比较。我还绘制了曲线图。</p><p><img src=\"https://static001.geekbang.org/resource/image/a3/c7/a3a37270cc5bb25655db6176fd65b1c7.png?wh=1466x854\" alt=\"图片\"></p><p>你可能不放大这张图仔细观察，还注意不到本地代码的曲线在哪里。因为我们生成的本地代码和C语言生成的本地代码，性能上的差异已经比较小了，不过也还是有一小点差异的。我把它俩的对比又单独画了一张图，你再看一下。</p><p><img src=\"https://static001.geekbang.org/resource/image/3e/fd/3e3ea4f885yye81d594821b4fec6cdfd.png?wh=1466x854\" alt=\"图片\"></p><p>那这种差异来自于哪里呢？我们不是都用了相同的寄存器分配算法吗？</p><p>如果你比较一下二者的汇编代码，还是能看出一小点差别来的。<strong>最主要的差别，就在于如何处理Caller需要保护的寄存器。</strong></p><p>在我们这门课当前使用的算法里，我们记录了在一个函数中，如果有Caller保护的寄存器被使用了，那么我们在每次调用函数的时候，要把所有被使用的这些寄存器都保存到内存里。</p><p>这里有一些浪费。因为其实有些寄存器不再用了，也就意味着它不再需要保护了。如果我们进一步优化一下的话，这里其实需要一个算法，来检测哪些临时变量仍然是在使用中的，然后保护它们正在使用的寄存器就可以了。</p><p>我们在下节课里，在实现升级版的寄存器分配算法的时候，就会做变量活跃性的检测。所以，这种优化我们会在下一节课一并实现。</p><h2>课程小结</h2><p>这就是今天这节课的所有内容了。这节课的内容相对简单，你只需要记住以下几个知识点就可以了：</p><p>首先，我们又重温了一下如何生成跳转指令。对于条件跳转来说，首先要把两个操作数做比较，比较结果会被设置到eflags寄存器中。这样，我们后面的条件跳转指令就可以根据eflags寄存器的内容来做跳转了。并且，对于条件跳转，我们再一次看到了一个现象，就是生成的跳转指令跟比较操作符恰好是相反的。对于&gt;号的比较运算符，生成的反倒是jle指令，也就是如果小于等于，则跳转。</p><p>不过，我们目前的if条件仍然只支持一个简单的条件表达式，还不支持把多个条件表达式组合成一个逻辑表达式的情况。你有兴趣的话，可以研究一下怎么扩展这方面的特性。</p><p>另外，对于一元运算，我们也稍微展开讲了一下。你要注意，特别是针对i++这样的表达式，怎样实现不同的当前值和返回值</p><p>最后，我们又一次用斐波那契数列做了一下性能的对比测试。相比C语言的栈机版本，这次我们的性能提高了20多倍。看来，我们这好几节课努力学习底层架构和汇编代码的相关技术，还是很值得的。</p><p>掌握了我们当前的生成汇编代码的技术，其实你已经可以去实现很多有用的底层功能了，比如做一个图形化的开发工具，用来生成能够在物联网设备、自动设备上运行的机器码。</p><p>不过，我们当然不会满足于现在的成绩。下节课，我们将升级寄存器分配算法，继续提升程序的性能！</p><h2>思考题</h2><p>今天这节课里，我们画了两个CFG的图。CFG是一种图的数据结构。那么，我们例子中的两个图有什么特点呢？这个特点对于图的处理有什么好处呢？</p><p>欢迎在留言区分享你的看法。由于我们后面会经常用到图的数据结构，所以你现在要开始把有关图的算法熟悉起来了！我是宫文学，我们下节课见。</p>","neighbors":{"left":{"article_title":"17｜生成本地代码第2关：变量存储、函数调用和栈帧维护","id":418317},"right":{"article_title":"19｜怎么实现一个更好的寄存器分配算法：原理篇","id":420155}}},{"article_id":420155,"article_title":"19｜怎么实现一个更好的寄存器分配算法：原理篇","article_content":"<p>你好，我是宫文学。</p><p>到目前为止，我们的语言已经能够生成机器码了，并且性能确实还挺高的。不过我们也知道，现在我们采用的寄存器分配算法呀，还是很初级的。</p><p>那这个初级的寄存器分配算法会遇到什么问题呢？我们还有更优化的分配寄存器的思路吗？</p><p>当然是有的。接下来的这两节课，我们就会来回答这两个问题，我会带你从原理到实操，理解和实现一个更好的算法，叫做<strong>线性扫描算法</strong>，让寄存器的分配获得更好的优化效果。</p><p>首先，我们来分析一下当前寄存器分配算法的局限性。</p><h2>初级算法的不足</h2><p>在前两节课中，我们实现了一个初级的寄存器分配算法。这个算法的特点呢，是主要的数据都保存在内存的栈桢中，包括参数和本地变量。而临时变量，则是映射到寄存器，从而保证各类运算指令的合法性，因为像加减乘数这种运算，不能两个操作数都是内存地址。</p><p>这个算法有什么不足呢？你可以暂停一会儿，先自己想一下，大概有两点。</p><p>我们现在来揭晓答案。</p><p><strong>第一点不足在生成的代码性能上。</strong></p><p>你知道，我们做编译的目标，是要让生成的代码的性能最高，但这个算法在这方面显然是不合格的。因为参数和本地变量都是从内存中访问的，这会导致代码的性能大大降低。</p><p><strong>第二点不足就在对需要Caller保护的寄存器的处理上。</strong></p><!-- [[[read_end]]] --><p>在上一节课后面的性能比拼中，我们发现，其实我们自己的语言编译生成的可执行程序，它的性能还略低于C语言生成的、同样未经优化的版本，按理说它们的性能应该是一样的才对。</p><p>深究原因，还是在调用函数的时候，程序需要保存那些需要Caller保护的寄存器。而我们的算法，多保护了一些其实已经不需要被保护的寄存器，从而拖累了性能。</p><p>不过，这两个方面的局限性，我们通过今天的算法，都可以很好地解决。我们现在就通过一个示例程序来找一下更好的寄存器分配算法的思路。</p><h2>寄存器分配算法的改进思路</h2><p>你先看看我们下面这个示例程序：</p><pre><code class=\"language-plain\">function foo(p1:number,p2:number,p3:number,p4:number,p5:number,p6:number){\n    let x7 = p1;\n    let x8 = p2;\n    let x9 = p3;\n    let x10 = p4;\n    let x11 = p5;\n    let x12 = p6 + x7 + x8 + x9 + x10 + x11;\n    \n    let sum = x12;\n    for (let i:number = 0; i&lt; 10000; i++){\n        sum += i;\n    }\n\n    return sum;\n}\n</code></pre><p>你看这里有p1~p6共6个参数，还有x7~x12这6个本地变量。但在变量x12的计算过程中，我们还需要用到1个临时变量t1。接下来是一个循环语句，这个语句又涉及到sum和i两个本地变量。</p><p><strong>那我们怎么给它们分配寄存器呢？</strong></p><p>最简单的思路，就是给每个变量分配一个寄存器。所以，p1~p6、x7~x12、t1和sum这一共14个变量，就占据了14个寄存器。而且，你要知道，X86在进行整数运算时只有16个通用寄存器可用，扣除用于指示栈桢位置的rsp和rbp以后，本来就只剩下14个。</p><p><strong>那现在这14个寄存器都被占满了，接下来的变量i，是不是就只能放在内存里了呢？</strong></p><p>不是的。因为并不是每个寄存器都需要被我们的变量一直占据的。每个变量其实有不同的生存期，在生存期之后，程序就再也不会访问这个变量了。</p><p>我这里画了一张图，显示了我们这块代码中前13个寄存器的生存期。在图中，我用r1~r13代表了13个寄存器，方便我们分析。不过，实际代码中，你可要换成edi、esi这些具体的寄存器名称。</p><p><img src=\"https://static001.geekbang.org/resource/image/d2/48/d20ccf140cd6009a5d766f1190910a48.jpg?wh=1920x823\" alt=\"图片\"></p><p>你可以看到，在运行第一行代码以后，p1对应的寄存器（r1）就被释放出来了，同时，x7对应的寄存器（r7）就开始投入使用。</p><p>随着代码的运行，r2~r6逐步被释放，而r8~r12也逐步被启用。最后，当我们给sum赋值完毕以后，前13个寄存器就都被释放出来了。所以，对于后面的i变量，我们其实有很多寄存器可以使用，根本不用使用内存。</p><p>在前面的分析过程中，我们着重计算了每个变量的生存期。<strong>总的来说，只要两个变量的生存期是不交叉的，那就可以共享同一个物理寄存器。</strong></p><p>所以，p1和x7可以共用寄存器r1，p2和x8可以共用寄存器r2，等等。最后，t1、sum和i这三个变量，也是复用已有的寄存器就可以了。</p><p>我把这个优化后的寄存器使用情况画在了下面这张图中：</p><p><img src=\"https://static001.geekbang.org/resource/image/97/b8/970f91706981734eb1bc795d7eb202b8.jpg?wh=1920x823\" alt=\"图片\"></p><p>你现在算一下，基于这个优化的分配算法，我们的示例程序最多的时候只需要占用6个寄存器（不算rsp和rbp），而且大部分运行时间，都是在循环中做1万次计算，只占用了两个寄存器。</p><p>那么，你现在已经明白我们这次算法优化的思路了吗？其实就是<strong>多个变量可以复用相同的寄存器，只要它们的生存期不重叠就行</strong>。这具体怎么实现呢？</p><h2>线性扫描算法</h2><p>目前，在成熟语言的编译器中，比较常用的寄存器分配算法有两个：寄存器染色算法和线性扫描算法。其中，寄存器染色算法的优化效果比较好，但算法复杂度比较高，会消耗比较多的编译时间；而线性扫描算法的复杂度比较低，但在大部分情况下也能得到相当不错的优化结果。</p><p>所以今天这节课，我就重点带你实现一下线性扫描算法。如果你对寄存器染色算法也感兴趣的话，可以去看看<a href=\"https://time.geekbang.org/column/intro/100034101\">《编译原理之美》</a>中对这个算法的解析，也可以在留言区和我们分享一下。</p><p>线性扫描算法是很容易理解的，这里面的关键就是<strong>计算出每个变量的生存期</strong>。计算生存期可以用数据流分析算法，分析出每个变量的活跃状态，这个我们等会儿再说。</p><p>我们再把前面这个示例程序，用线性扫描算法的思路来描述分析一遍。</p><p>首先，在程序刚开始执行时，p1~p6这6个变量都是活跃的，分别占用了1个寄存器。每个寄存器我们用了一个颜色来表示，以便区分。</p><p><img src=\"https://static001.geekbang.org/resource/image/55/df/557980c2e63a884106cb350e488393df.jpg?wh=1265x1215\" alt=\"图片\"></p><p>接着在第二个时间段，我们把p1赋给x7，这时p1不再活跃，而x7变得活跃起来。这个时候，让x7代替p1来使用r1寄存器就可以了，不需要再增加新的寄存器。</p><p><img src=\"https://static001.geekbang.org/resource/image/c1/31/c1c013947bca0068c9b6d89fb060a331.jpg?wh=1265x1215\" alt=\"图片\"></p><p>这样继续往下执行。在给x12赋值的时候，其实是会引入一个临时变量，形成下面一系列计算步骤：</p><pre><code class=\"language-plain\">t1 = p6;\nt1 += x7;\nt1 += x8;\nt1 += x9;\nt1 += x10;\nt1 += x11;\nx12 = t1;\n</code></pre><p>这样，随着计算过程的推进，x7~x11的生存期逐步结束，相应的寄存器也会被释放出来。</p><p><img src=\"https://static001.geekbang.org/resource/image/33/1a/334d36fc06ea3ee18b962e7eafbca91a.jpg?wh=1265x1215\" alt=\"图片\"></p><p>等到给x12赋值的这个表达式完全计算完毕，在这个时间点上，你会发现只有x12需要占用一个寄存器，前面11个变量的生存期都已经结束了。</p><p><img src=\"https://static001.geekbang.org/resource/image/79/15/795fd0cc51eb4145fe89d429549d8815.jpg?wh=1265x1215\" alt=\"图片\"></p><p>最后，我们要执行for循环的代码。在这个过程中，只需要占据两个寄存器。</p><p><img src=\"https://static001.geekbang.org/resource/image/66/3e/6644c02a5ff134d2d148bda11af0e83e.jpg?wh=1265x1215\" alt=\"图片\"></p><p>好了，刚才的分析就是示例程序执行线性扫描算法的过程。在这个例子中，我们只用了6个寄存器，少于X86-64架构中通用寄存器的数量。所以，整个程序运行过程都使用寄存器就可以了。</p><p><strong>但事情总有例外。如果一个程序写得特别复杂，用到的变量特别多，每个变量的生存期又很长，那物理寄存器的数量还是有可能不够的。那这个时候，算法又该如何处理呢？</strong></p><p>这个时候，我们需要选择一个寄存器，把它的数据保存到内存中，把这个寄存器腾出来。比如说，在前面的例子中，假设我们使用的CPU只有5个寄存器，应该怎样分配呢？</p><p>在一开始，p1~p5还可以每个变量占据一个寄存器。但p6就没有可用的寄存器了，那么我们就先把它放在内存里。因为p6还不会马上被使用，直到给t1赋值的时候，才会用到p6。</p><p><img src=\"https://static001.geekbang.org/resource/image/d2/4c/d2f11844bc2519f21cedac35e6bf254c.jpg?wh=1265x1215\" alt=\"图片\"></p><p>接着，程序开始一步步地运行，寄存器的使用权也被陆续转移。比如，执行完毕x7=p1以后，寄存器r1从p1转移给了x7。</p><p><img src=\"https://static001.geekbang.org/resource/image/89/88/892a9a5ac8b06fdd831f1e61abf33488.jpg?wh=1265x1215\" alt=\"图片\"></p><p>程序继续执行。在执行t1=p6之前，我们要先把p6加载到寄存器。这个时候，我们需要把另一个变量保存到内存，腾出一个寄存器。这次，我们把x11保存到内存，当然你选另几个变量也是可以的。</p><p><img src=\"https://static001.geekbang.org/resource/image/80/97/8030429d6cf7ab500650f3c71yy9bc97.jpg?wh=1265x1215\" alt=\"图片\"></p><p>再然后，t1接替p6，占据r5寄存器。</p><p><img src=\"https://static001.geekbang.org/resource/image/26/f8/266b31cca17c9e0dc8e764d68fa9d1f8.jpg?wh=1265x1215\" alt=\"图片\"></p><p>接下来，和前面一样，在执行t1+=x11之前，我们要把x11装载到内存中。这个时候，其实我们已经有很多空闲的寄存器可用了，我们选择了r1。</p><p><img src=\"https://static001.geekbang.org/resource/image/61/75/61b0e9e75b6d6c8d3055c2b378363675.jpg?wh=1265x1215\" alt=\"图片\"></p><p>到这里，我们把寄存器溢出的场景也分析完了。这两个分析过程，我主要是用图来直观地表示的。所以，你要多看几遍这些图，体会寄存器分配的过程，就能够充分理解线性扫描算法了。</p><p>通过这个线性扫描算法，我们已经解决了我们上节课初级寄存器算法的第一点不足，也就是我们已经把参数和本地变量都放在寄存器上去访问了，优化了我们生成的本地代码的性能。而第二点的不足呢，我们也会在实现线性扫描算法的过程中，顺道解决，这就要归功于我们接下来要学习的变量活跃性分析。</p><p>从前面这个例子你也能看出来，<strong>实现线性扫描算法的关键，是要知道每个变量的生存期</strong>。要知道这个，我们就需要进行<strong>变量活跃性分析</strong>了。</p><p>变量活跃性分析是<strong>数据流分析框架</strong>的应用之一，而数据流分析框架，是编译器中使用的最重要的技术之一，在语义分析、代码优化等多个领域都会被用到。我们借变量活跃性分析的例子，来熟悉一下这种分析方法。</p><h2>变量活跃性分析</h2><p>我们还是针对我们前面的示例程序，来演示一下怎么来做变量活跃性分析。</p><p>下面这张图，是我针对这个程序整理的变量活跃性分析图。每一行语句的前方都有一个集合，这个集合中的元素指的是当前位置活跃的变量。也就是说，在这个位置上，我们要给这些变量分配寄存器。而其他变量，由于它们并不活跃，所以也就不需要占据寄存器了。</p><p><img src=\"https://static001.geekbang.org/resource/image/1e/d9/1e8be774a1abcf2a8f8a066de0ec19d9.jpg?wh=1920x1080\" alt=\"图片\"></p><p>现在我们直接来看具体的分析过程。不同的数据流分析，它的分析方向是不同的。有的是自上向下分析，有的是自下向上分析，变量活跃性分析是就是从下往上进行的。</p><p>一开始，活跃变量的集合是一个空集。</p><p>然后算法遇到最底下的一条语句，也就是return语句。由于return语句使用了sum变量，所以这个时候sum变量必须是活跃的。所以现在我们活跃变量的集合就有了第一个元素：sum。</p><p>再往前一句，由于“sum+=i”中用到了i，所以i也被加入了活跃变量集合。</p><p>往前到for语句之前，由于i是在for语句中声明的，在此之前并没有i，所以我们就可以从活跃变量集合中去掉i了。</p><p>然后我们继续往前到“let sum = x12”这一句。由于这个语句用到了x12，所以集合里就加入x12。但sum变量是在这个语句中声明的，在此之前没有sum，所以我们再从集合中去掉sum。</p><p>接下来，我们继续依次类推进行活跃变量集合的计算就行了。计算规则是：<strong>只要发现某个语句用到了某个变量，就把这个变量加入集合；只要发现了某个变量的声明语句，那就从集合中去掉这个变量。</strong></p><p>这样，一直到函数的开头位置，你会看到，我们活跃变量的集合剩下了foo函数的6个参数。</p><p>通过这样的变量活跃性分析，我们就能够准确地知道每个变量的生存期，也就可以据此进行寄存器的分配了。</p><p>在做好了所有的算法梳理以后，我们就可以动手进行实现了。实现过程的技术细节，我们放在了下一节课里。</p><h2>课程小结</h2><p>今天这节课，我们讲解了实现一个优化的寄存器分配算法的原理。你要记住几个知识点：</p><p>寄存器分配的原理是只要两个变量的生存期不重叠，那就可以共享寄存器。而线性扫描算法，也特别简单，就是每次在需要一个寄存器的时候，只要线性扫描所有寄存器，看看哪个寄存器上的变量的生存期已经结束了，就可以分配给新的变量。</p><p>不过，寄存器分配算法是有可能遇到寄存器数量不够的情况的。这个时候，算法就会选择一个变量，暂时把它溢出到内存，等遇到使用这个变量的语句的时候，再把它从内存里装载到寄存器就可以了。</p><p>接着，我们发现，寄存器分配算法的前提，是要进行变量活跃性分析，这里需要用到数据流分析框架。我们会从下到上针对每一条语句做分析。每一次分析，都往活跃变量集合里增加或者减少元素：遇到使用某个变量的语句，就把它加到集合里；遇到声明某个变量的语句，就把它从集合里去除。</p><p>怎么样？寄存器分配算法看上去也挺简单嘛！在理解了算法的原理之后，你再做技术实现上就会有清晰的思路了。不过，在实现过程中，要注意的技术细节还是蛮多的，所以我们就放在下一节课仔细讨论吧。</p><h2>思考题</h2><p>如果你学过线性规划等最优化理论的课程，你会意识到，线性扫描算法得到的结果可能并不是最优解。你能举出一个例子来说明一下这个潜在的缺陷吗？那又有哪些算法思路会帮助你得到最优解或较优解呢？它们的算法复杂性是怎样的呢？</p><p>希望你思考一下，也欢迎你在留言区分享自己想法，这会让你对寄存器分配算法的实质，有更深入的理解。我是宫文学，我们下节课见。</p>","neighbors":{"left":{"article_title":"18｜生成本地代码第3关：实现完整的功能","id":418808},"right":{"article_title":"20｜怎么实现一个更好的寄存器分配算法：实现篇","id":420555}}},{"article_id":420555,"article_title":"20｜怎么实现一个更好的寄存器分配算法：实现篇","article_content":"<p>你好，我是宫文学。</p><p>在上一节课，我们已经介绍了寄存器分配算法的原理。不过呢，我们这门课，不是停留在对原理的理解上就够了，还要把它具体实现出来才行。在实现的过程中，你会发现有不少实际的具体问题要去解决。而你一旦解决好了它们，你对寄存器分配相关原理的理解也会变得更加通透和深入。</p><p>所以，今天这一节课，我就会带你具体实现寄存器分配算法。在这个过程中，你会解决这些具体的技术问题：</p><ul>\n<li>首先，我们会了解如何基于我们现在的LIR来具体实现变量活跃性分析。特别是，当程序中存在多个基本块的时候，分析算法该如何设计。</li>\n<li>第二，我们也会学习到在实现线性扫描算法中的一些技术点，包括如何分配寄存器、在调用函数时如何保存Caller需要保护的寄存器，以及如何正确的维护栈桢。</li>\n</ul><p>解决了这些问题之后，我们会对我们的语言再做一次性能测试，看看这次性能的提升有多大。那么接下来，就让我们先看看实现变量活跃性分析，需要考虑哪些技术细节吧。</p><h2>实现变量活跃性分析</h2><p>我们先来总结一下，在实现变量活跃性分析的时候，我们会遇到哪几个技术点。我们一般要考虑如何保存变量活跃性分析的结果、如何表达变量的定义，以及如何基于CFG来做变量活跃性分析这三个方面。</p><p>现在我们就一一来分析一下。</p><!-- [[[read_end]]] --><p>首先，我们要设计一个数据结构，把活跃性分析的结果保存下来，方便我们后面在寄存器分配算法中使用。</p><p>这个数据结构很简单，我们使用一个Map即可。这个Map的key是指令，而value是一个数组，也就是执行当前指令时，活跃变量的集合。</p><pre><code class=\"language-plain\">liveVars:Map&lt;Inst, number[]&gt; = new Map();\n</code></pre><p>确定了数据结构以后，我们再讨论一下算法的实现。在算法的执行过程中呢，我们倒着扫描一条条指令。对于每条指令，我们要分析它的操作数。如果操作数是一个变量下标，那我们就把这个变量加到活跃变量的集合中。所以，往集合里加变量实现起来很简单。</p><p>可是，从集合里减变量就不那么简单了。为什么呢？根据我们上一节课讲过的算法，我们需要在变量声明的时候，把这个变量从集合里去掉。可是，我们当前的LIR中并没有记录哪个变量是在什么时候声明的，也就没办法知道变量的生存期是从什么时候开始的了。</p><p>那怎么来解决这个问题呢？我的办法是，向LIR里再加一条指令，这条指令专门用来指示变量的声明。我把这条指令的OpCode叫做<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/20/asm_x86-64.ts#L126\">declVar</a>。</p><p>由于这条指令并不能转化成具体的可执行的指令，所以你可以把它叫做伪指令。它仅用于我们的寄存器分配算法。</p><p>好了，在加入了这条指令以后，我们就能对一个基本块进行变量活跃性分析了。具体实现你可以参考代码LivenessAnalyzer，其中的核心逻辑我放在下面了：</p><pre><code class=\"language-plain\">//为每一条指令计算活跃变量集合\nfor (let i = bb.insts.length - 1; i &gt;=0; i--){\n    let inst = bb.insts[i];\n    if (inst.numOprands == 1){\n        let inst_1 = inst as Inst_1;\n        //变量声明伪指令，从liveVars集合中去掉该变量\n        if (inst_1.op == OpCode.declVar){\n            let varIndex = inst_1.oprand.value as number;\n            let indexInArray = vars.indexOf(varIndex);\n            if (indexInArray != -1){\n                vars.splice(indexInArray,1);\n            }\n        }\n        //查看指令中引用了哪个变量，就加到liveVars集合中去\n        else{\n            this.updateLiveVars(inst_1, inst_1.oprand, vars);\n        }\n    }\n    else if (inst.numOprands == 2){\n        let inst_2 = inst as Inst_2;\n        this.updateLiveVars(inst_2, inst_2.oprand1, vars);\n        this.updateLiveVars(inst_2, inst_2.oprand2, vars);\n    } \n\n    result.liveVars.set(inst, vars);\n    vars = vars.slice(0); //克隆一份，用于下一条指令\n}\n</code></pre><p>我们可以用这个算法跑一个例子看看，这个例子是上一节课的示例程序的前半截：</p><pre><code class=\"language-plain\">function foo(p1:number,p2:number,p3:number,p4:number,p5:number,p6:number){\n    let x7 = p1;\n    let x8 = p2;\n    let x9 = p3;\n    let x10 = p4;\n    let x11 = p5;\n    let x12 = p6 + x7 + x8 + x9 + x10 + x11;  \n    let sum = x12;\n    return sum;\n}\n</code></pre><p>你可以运行node play example_reg.ts -v --dumpAsm来显示分析的结果。我把终端的输出放到下面了。你能看到，每个语句对应的活跃变量集合，跟我们前一节的分析是吻合的。也证明我们的实现是正确的。</p><pre><code class=\"language-plain\">function: foo\nbb:LBB0               \n[ 5, 4, 3, 2, 1, 0 ]\ndeclVar\tvar6\n[\n&nbsp; 6, 5, 4, 3,\n&nbsp; 2, 1, 0\n]\nmovl\tvar0, var6\n[ 6, 5, 4, 3, 2, 1 ]\ndeclVar\tvar7\n[\n&nbsp; 7, 6, 5, 4,\n&nbsp; 3, 2, 1\n]\nmovl\tvar1, var7\n[ 7, 6, 5, 4, 3, 2 ]\ndeclVar\tvar8\n[\n&nbsp; 8, 7, 6, 5,\n&nbsp; 4, 3, 2\n]\nmovl\tvar2, var8\n[ 8, 7, 6, 5, 4, 3 ]\ndeclVar\tvar9\n[\n&nbsp; 9, 8, 7, 6,\n&nbsp; 5, 4, 3\n]\nmovl\tvar3, var9\n[ 9, 8, 7, 6, 5, 4 ]\ndeclVar\tvar10\n[\n&nbsp; 10, 9, 8, 7,\n&nbsp;&nbsp; 6, 5, 4\n]\nmovl\tvar4, var10\n[ 10, 9, 8, 7, 6, 5 ]\ndeclVar\tvar13\n[\n&nbsp; 13, 10, 9, 8,\n&nbsp;&nbsp; 7,&nbsp; 6, 5\n]\nmovl\tvar5, var13\n[ 13, 10, 9, 8, 7, 6 ]\naddl\tvar6, var13\n[ 13, 10, 9, 8, 7 ]\naddl\tvar7, var13\n[ 13, 10, 9, 8 ]\naddl\tvar8, var13\n[ 13, 10, 9 ]\naddl\tvar9, var13\n[ 13, 10 ]\naddl\tvar10, var13\n[ 13 ]\ndeclVar\tvar11\n[ 11, 13 ]\nmovl\tvar13, var11\n[ 11 ]\ndeclVar\tvar12\n[ 12, 11 ]\nmovl\tvar11, var12\n[ 12 ]\nmovl\tvar12, returnSlot\n[]\n</code></pre><p>可是，这个例子中仅有一个基本块，所以我们的算法只需要把这个基本块的代码从下往上扫描一遍就行了。</p><p>可如果存在多个基本块，该如何处理呢？比如，我们如果在示例程序中加入循环语句以后，就会产生不止一个基本块了。难道我们只需要把每个基本块分别做一下分析就可以了吗？</p><p>不是的。当存在多个基本块的时候，基本块之间的关系会形成一个CFG，也就是控制流图。一个基本块的活跃变量的情况，会影响它前序的基本块的变量活跃性分析结果。这里我们具体展开来看一下。</p><h2>基于CFG的变量活跃性分析</h2><p>在前面几节课，我们讲到if语句和for循环语句的时候，说到它们的执行流程可以用一个CFG来表示。我借用了之前我在<a href=\"https://time.geekbang.org/column/intro/100034101\">《编译原理之美》</a>课程中用过的一个例子，来和你说明一下如何基于CFG来做数据流分析。</p><p>我们先来看第一个图，这是一个带有if分支的CFG。这个CFG里，每个基本块都编了号。<br>\n<img src=\"https://static001.geekbang.org/resource/image/86/f7/86bdebdbfbabe87e5f9f5a8e500132f7.jpg?wh=1080x1202\" alt=\"\"><br>\n在进行变量活跃性分析的时候，根据我们上一节课提到过的由下到上的顺序，我们需要倒着从第5个基本块进行分析。你会看到，第5个基本块需要活跃变量x，这就形成了对基本块4的需求。所以，我们知道了，基本块4一开始的活跃变量集合不是空集，而是{x}。<br>\n<img src=\"https://static001.geekbang.org/resource/image/93/e6/93895b76a9da8314b01db5d6306f2ae6.jpg?wh=1080x1202\" alt=\"\"><br>\n再进一步，基本块4又形成了对2和3的需求，要求它们提供{a,b,c,d}共4个活跃变量。</p><p>依次类推，基本块2和3又形成了对基本块1的需求，要求基本块1提供{a,b,c}共3个活跃变量。</p><p>到这就完事了。这看上去也不复杂呀，就是沿着CFG中的边，逆向遍历一遍图就行了呗！</p><p>慢着，我们刚刚举的例子只是一个比较简单的情况。在这个例子中，图里没有形成环，是个有向无环图，是图的数据结构中几乎最简单的一种，算法处理比较容易。但是我们实际的程序，会形成更复杂的图。比如，for循环语句就会形成带有环的图，使得里面的基本块形成循环依赖，这会导致算法复杂度的提升。</p><p>我们接着来看看下面的例子，这个例子中我们增加了从基本块4到1的控制流，从而构成了环路。我们还是沿着刚才的计算顺序，分别计算基本块5-&gt;4-&gt;3-&gt;2-&gt;1，这会形成下面的活跃变量集合。<br>\n<img src=\"https://static001.geekbang.org/resource/image/06/af/068cf59b926a582dfe82e59feb2b01af.jpg?wh=1080x1202\" alt=\"\"><br>\n但是，这并没有计算完毕。你看，由于存在着从4到1的环路，所以1的输出，会形成对4的活跃变量的需求。所以，我们这里又要重新计算一遍基本块4的活跃变量，进而导致我们需要对基本块3、2和1都再次计算一遍，引起它们的活跃变量集合的变化。<br>\n<img src=\"https://static001.geekbang.org/resource/image/58/16/580523c02799ab7a7fde4b99dec53d16.jpg?wh=1080x1202\" alt=\"\"><br>\n这样的循环可能会重复多次，直到每个基本块的活跃变量集合不再有变化为止。</p><p>上面这些就是我们对基于CFG的变量活跃性分析的算法思路的分析。你会看到，它比针对单个基本块的分析确实复杂了不少，接下来就让我们实现一下吧。</p><p><strong>首先，我们要对数据结构做一个调整。</strong>在这部分，我们需要记录下每个基本块初始的活跃变量集合。这个集合可能不再是一个空集，因为后序基本块可能要求前序基本块必须提供某些活跃变量。</p><p>所以，我们要记下每个基本块初始的活跃变量集合。在打印活跃变量的时候，把这个初始的集合显示在最下面。</p><pre><code class=\"language-plain\">/**\n * 变量活跃性分析的结果\n */\nclass LivenessResult{\n    liveVars:Map&lt;Inst, number[]&gt; = new Map();\n    initialVars:Map&lt;BasicBlock, number[]&gt; = new Map();\n}\n</code></pre><p><strong>第二，我们要为每个函数构建CFG。</strong>当前，每个函数里已经保存了一些基本块，但它们并没有表达成直观的CFG。比如，我们现在还没有简单的方法知道每个基本块都有哪些前序基本块和后续基本块。因此，我们专门设计一个CFG的类，来体现图的数据结构。</p><pre><code class=\"language-plain\">class CFG{\n    //基本块的列表。第一个和最后一个BasicBlock是图的root。\n    bbs:BasicBlock[];\n\n    //每个BasicBlock输出的边\n    edgesOut:Map&lt;BasicBlock, BasicBlock[]&gt;=new Map();\n\n    //每个BasicBlock输入的边\n    edgesIn:Map&lt;BasicBlock,BasicBlock[]&gt; = new Map();\n    ...\n}\n</code></pre><p>在这个CFG类中，有两个Map很有用。一个Map记录了所有进入某个基本块的边，另一个Map则记录了从该基本块到其他基本块的边。通过这两个Map，我们可以很容易地沿着这些边进行正向或逆向的遍历。<br>\n在这里，我们通过了一个专门的buildCFG方法来构建CFG。如果你用node play example_if.ts -v --dumpAsm命令，可以打印出为每个函数构建的CFG出来。 我附了一张截图：</p><p><img src=\"https://static001.geekbang.org/resource/image/c2/8e/c2018e37471b82650e68c97158c55b8e.png?wh=410x766\" alt=\"图片\"></p><p><strong>第三，我们实现要实现基于CFG的活跃变量分析算法。</strong>这个算法的思路，是逆向遍历整个CFG，而且只要某个基本块的分析结果会影响到前序的基本块，那我们就需要持续不停地进行迭代分析，直到每个基本块的活跃变量集合都不再变化为止。</p><p>我放了一块比较关键的代码，具体实现你可以参考代码库中的<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/20/asm_x86-64.ts#L1809\">analyzeFunction</a>方法。</p><pre><code class=\"language-plain\">//持续遍历图，直到没有BasicBlock的活跃变量需要被更新\nlet bbsToDo:BasicBlock[] = bbs.slice(0);\nwhile (bbsToDo.length&gt;0){\n    let bb = bbsToDo.pop() as BasicBlock;\n    this.analyzeBasicBlock(bb, result);\n    //取出第一行的活跃变量集合，作为对前面的BasicBlock的输入\n    let liveVars = bb.insts.length == 0? [] : (result.liveVars.get(bb.insts[0]) as number[]); \n    let fromBBs = cfg.edgesIn.get(bb);\n    if (typeof fromBBs != 'undefined'){\n        for (let bb2 of fromBBs){\n            let liveVars2 = result.initialVars.get(bb2) as number[];\n            //如果能向上面的BB提供不同的活跃变量，则需要重新分析bb2\n            if (!this.isSubsetOf(liveVars, liveVars2)){\n                if (bbsToDo.indexOf(bb2) == -1)\n                    bbsToDo.push(bb2);\n                let unionVars = this.unionOf(liveVars, liveVars2);\n                result.initialVars.set(bb2, unionVars);\n            }\n        }\n    }\n}\n</code></pre><p>这里你仍然可以用node play example_if.ts -v --dumpAsm命令来显示分析后的结果。</p><p>好了，在实现了基于CFG的分析算法以后，现在我们已经彻底完成了变量活跃性分析。接下来，就是具体实现线性扫描算法了！</p><h2>实现线性扫描算法</h2><p>根据我们上节课原理篇的安排，在原来的简单寄存器分配算法的基础上，我们要进行一些调整，把它改成线性扫描算法。</p><p><strong>第一个重要的技术点，也是其中</strong><strong>最主要的修改，是对lowerOprand方法的修改。</strong>在这个方法中，我们会把变量下标类型的操作数（也就是逻辑寄存器）映射成物理寄存器。</p><p>在lowerOprand方法中，我们会调用<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/20/asm_x86-64.ts#L1582\">getFreeRegister</a>方法来获取一个寄存器。在这个方法里呢，算法会首先试图复用已分配过的寄存器，也就是检查现在已经被分配了寄存器的变量，看看现在哪个变量的生存期已经结束了，这样就可以腾出这个寄存器来了。</p><p>如果没有可复用的寄存器，那么就需要从未分配的寄存器里分配出一个来。那如果所有寄存器都用完了呢？</p><p>这个时候，我们就需要溢出（Spill）一个现成的寄存器。我们现在溢出寄存器的算法比较简单，只要找到第一个可用的寄存器，就把它溢出就好了。</p><p><strong>第二个重要的技术点，是在调用函数的前后，要对寄存器做保护和重载。</strong>对寄存器做保护，实际上就是把它溢出到内存中就可以了，等函数调用完毕，我们再把它们从内存加载到寄存器里来。这里你可以参考spillVar和reloadVar方法。</p><p>这里还有个技术细节要讨论一下。在调用函数的时候，我们到底需要保护哪些寄存器呢？这个是需要计算一下的，我们这里还是要利用变量活跃性分析的结果，也就是函数调用时的活跃变量。</p><p>但是，如果在调用_foo前后，变量活跃性集合是不同的，我们应该以哪个集合为准呢？你可以看看下面的例子，并思考一下。</p><pre><code class=\"language-plain\">[x1, x2, x3]\nfoo(x1);\n[x2, x3]\n</code></pre><p>答案是函数调用之后的活跃变量集合。因为在例子中，x1作为参数使用过以后，后面就不再用它了，所以就没有必要保护它的值了。</p><p><strong>第三个重要的技术点，就是栈桢的维护。</strong>采用新的寄存器分配算法以后，我们栈桢的内容会有所不同。这个时候了，我们就没有必要再在内存里逐个保存参数和本地变量了，而是只为溢出的变量提供空间就可以了。</p><p>我们以这张图为例分析一下：</p><p><img src=\"https://static001.geekbang.org/resource/image/ba/98/ba63dd73b4f96a7062b82bb7e639d098.png?wh=632x576\" alt=\"图片\"></p><p>这里栈帧维护的重点，是要能够准确计算出每个被溢出的变量的地址相对于rbp的偏移量。</p><p>而这里就有一个不确定的因素了，就是在溢出变量的存储空间上部，是为Callee保护的寄存器而留出的空间。但是我们到底需要保存几个Callee保护的寄存器，这要在寄存器分配算法执行完毕以后才能知道。</p><p>所以你会看到，所有被Spill的变量的准确内存地址，是需要在算法的最后调整一次的。你可以看一下lowerFunction中的这段代码：</p><pre><code class=\"language-plain\">//把spilledVars中的地址修改一下，加上CalleeProtectedReg所占的空间\nif (this.usedCalleeProtectedRegs.length &gt;0){\n    let offset = this.usedCalleeProtectedRegs.length*8;\n    for (let address of this.spilledVars2Address.values()){\n        let oldValue = address.value as number;\n        address.value = oldValue+offset;\n    }\n}\n</code></pre><p>好了，关于各种技术实现的细节，讲到这里就差不多了。现在我们已经拥有了一个升级版的寄存器分配算法。采用这个算法生成的汇编文件，看上去就很顺眼了，你会看到大部分指令的操作数都是寄存器了。</p><p>那么，现在又到了检验我们的成果的时候了。是不是现在这个版本的性能会提升很多呢？毕竟，在之前的版本中，我们在使用本地变量和参数的时候，都要访问内存。而且根据我们前面的经验，内存会比寄存器慢差不多100倍呀。</p><h2>再次进行性能比拼</h2><p>与其在这猜测，不如直接动手验证吧。</p><p>你可以运行make example_fibo命令，再来构建一次斐波那契数列的例子，然后用./example_fibo命令来执行它。并且，你还可以用make fibo命令来编译一遍fibo.c，也就是C语言版本的斐波那契数列程序。</p><p>在这节课的Makefile文件中，我给fibo命令添加了-O2编译选项，也就是生成的代码是优化过的，也会使用寄存器。</p><p>我再一次把计算结果贴上来，你可以看看下面的表格。不过这里你要注意一下，在表格里，我把当前实现的这个TypeScript的版本叫做PlayScript，称呼起来更加方便一些。这是我比较喜欢的一个名称，我在<a href=\"https://time.geekbang.org/column/intro/100034101\">《编译原理之美》</a>课程中就用过这个名称。</p><p><img src=\"https://static001.geekbang.org/resource/image/da/d6/da91bf11f0148772057f8ca0895af3d6.jpg?wh=1920x1080\" alt=\"图片\"></p><p>而且，我仍然做了一张曲线图，让你能够更直观地看到各个版本之间的差别。</p><p><img src=\"https://static001.geekbang.org/resource/image/c9/34/c950d8f99b497ea5e58c29d8129f4c34.png?wh=1466x854\" alt=\"图片\"></p><p>从这些数据和图表中，你能得到什么结论呢？你可以停一两分钟，自己先想一下。</p><p>首先，采用了线性扫描算法以后，我们程序的性能果然有提升（图中的蓝线），超过了采用简单寄存器算法的版本，也超过未优化的C语言版本。</p><p>不过，你有没有觉得有点不对劲？哪里不对劲呢？<strong>看上去，这性能的提升也没有特别大呀，还不到1倍</strong>。在我内心中，其实期待着更大的性能提升。毕竟我们说过，内存读写的速度可比寄存器的速度慢上百倍呢。</p><p>那么，是什么原因导致了这个结果？你可以想一下。其实，你想想我们前面介绍过的关于CPU的架构的知识就知道了。导致这个结果的原因，其实是<strong>CPU的高速缓存</strong>。</p><p>在程序运行期间，我们栈桢里的那点数据，都被放到高速缓存去了，导致读写速度要比内存快得多。这个例子也从侧面反映出了，保证数据的局部性有多么重要。</p><p>那是不是我们费这么大劲升级的寄存器分配算法其实没啥用呢？</p><p>也不是的。在我测试的时候，我的电脑只运行了这一个比较占用CPU的程序。而如果你写的是一个服务器程序，有大量并发访问，每个并发访问都要访问内存中不同地方的数据，那么CPU的高速缓存的内容就要不断地刷新，它对内存访问的增速作用就会大打折扣。</p><p>这个时候，采用优化的寄存器分配算法的程序，在性能上一定会有碾压。如果你有兴趣，可以搭建一个这样的测试环境测一下，看看实际的性能差别到底会多大。</p><p>好了，这是我从数据中看到的第一个疑问，以及对这个疑问的分析。</p><p><strong>然后呢，还有第二个疑问：用-O2参数优化了的C语言的版本，还是比PlayScript的优化版快，快了大约50%，这又是什么原因导致的呢？</strong>按理说，这两个版本都是用寄存器来作为操作数的，性能差异应该不大才对呀。</p><p>你可以比较一下<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/20/example_fibo.s\">example_fibo.s</a>和<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/20/fibo.s\">fibo.s</a>这两个汇编代码的差别。你现在看这些汇编代码应该越来越亲切了吧？</p><p>你看，虽然实现的都是相同的功能，但我们生成的汇编代码，确实跟C语言（也就是llvm）生成的不一样，区别有几个方面。</p><p>首先是使用的具体寄存器不一样，但这个其实对性能没有什么影响。</p><p>第二方面的差别呢，是使用的某些指令不同。比如我们做减法的时候用的是subl指令，而fibo.s中用的是leal指令。leal指令能用一条指令完成计算和给另一个寄存器赋值的动作，所以性能确实更高一点。</p><p>但这也不是导致50%那么多的性能差异的原因啊。如果你不信，你可以把example_fibo.s中的subl和movl两条指令用leal指令来替换一下，然后再编译一下看看，性能其实没有太大区别。</p><p>那这个主要的原因到底在哪呢？你如果再仔细看fibo.s，你会发现其实它是在<strong>运行逻辑</strong>上做了比较大的优化。</p><p>比如，斐波那契数列的公式是：f(n) = f(n-1) + f(n-2)。</p><p>把f(n-2)展开后，又得到：f(n) = f(n-1)+f(n-3)+f(n-4)。</p><p>像这样把最后一项持续展开，又得到：f(n) = f(n-1) + f(n-3) + f(n-5) + … + f(2)或f(1)。</p><p>你会注意到，采用上面这样的算法，fibo.s中的递归调用变成了循环调用，每个循环要把n的值减少2。</p><p>把递归转化为循环，其实是编译技术中常见的一个技术，它能有效地减少总的函数调用次数，从而减少每次函数调用由于建立新栈桢、保护寄存器等引起的开销，看来这就是我们性能不如人的主要原因了。</p><p>当然了，我们目前对优化技术的接触还不太多。其实我们这两节课学习到的寄存器分配算法，算是后端优化技术的一种，其他优化技术其实还很多。</p><p>看来，我们仍然有不少知识点需要探索呀！不过也没关系，就把这些挑战当成我们进一步学习的动力吧！</p><h2>课程小结</h2><p>今天这节课我们就讲到这里了，通过这节课，我希望你记住这几个知识点:</p><p>首先，在变量活跃性分析的具体实现上，我们需要能够知道每个变量是在什么时候定义的、什么使用使用的。在我们原来的LIR中，能够获取变量使用的信息，但缺少变量定义的信息。所以我增加了一个伪指令，用来弥补这个缺陷。</p><p>第二，在存在多个基本块的情况下，我们要首先计算出CFG，然后采用基于图的算法来计算每个基本块的变量活跃性集合。这个计算过程可能要迭代多次，直到所有基本块的变量活跃性集合不再变化为止。</p><p>第三，在具体实现线性扫描算法时，其中的重点就是根据变量的活跃性寻找可用的寄存器。如果寄存器数量不足，我们就要选择一个变量溢出到内存中。而且在调用函数时，也是通过溢出到内存的方法，来保存Caller需要保护的寄存器。最后，我们要计算清楚每个溢出的变量的准确内存地址和所占空间，从而正确的维护栈桢。</p><h2>思考题</h2><p>你能否研究一下PlayScript当前生成的汇编代码，看看它还有哪些地方可以进一步优化的？优化的思路是什么呢？欢迎在留言区分享你的观点。</p><p>欢迎你把这节课分享给更多感兴趣的朋友。我是宫文学，我们下节课见。</p><h2>资源链接</h2><p><a href=\"https://gitee.com/richard-gong/craft-a-language/tree/master/20\">这节课的示例代码在这里！</a></p>","neighbors":{"left":{"article_title":"19｜怎么实现一个更好的寄存器分配算法：原理篇","id":420155},"right":{"article_title":"21｜加深对栈的理解：实现尾递归和尾调用优化","id":421602}}},{"article_id":421602,"article_title":"21｜加深对栈的理解：实现尾递归和尾调用优化","article_content":"<p>你好，我是宫文学。</p><p>前面几节课，我们在实现生成本地代码的过程中，对汇编语言、栈和栈桢有关的知识点都进行了比较深入的了解。通过这些学习，你应该对程序的运行机制有了更加透彻的理解。</p><p>那么今天这节课，作为第一部分起步篇的结尾，我们就来检验一下自己的学习成果吧！具体一点，我们就是要运用我们前面已经学过的知识点，特别是关于栈和栈桢的知识点，来实现两个有用的优化功能，也就是尾递归和尾调用的优化。</p><p>这两个优化有助于我们更好地利用栈里的内存空间，也能够提高程序的性能，对于我们后面实现函数式编程特性也具有很重要的意义。另外，这样的练习，也会加深我们对栈和栈桢、对程序的控制流，还有对程序的运行机制的理解。</p><p>好了，我们先从尾递归入手吧，说说尾递归是怎么回事，还有它有怎样的运行特点，看看我们为什么需要去优化它。</p><h2>递归函数和尾递归</h2><p>学习编程的同学都应该知道，递归是一种重要的思维方式。我们现实世界的很多事物，用递归来表达是非常自然的。<strong>在递归的思维里，解决整体的问题和解决局部问题的思路是相同的。</strong></p><p>在我们这个课程里，我们学习的语法分析的方法，也采用了递归的思维：我们给一个大程序做语法分析，会分解成给每一个函数、每一条语句做语法分析。不管在哪个颗粒度上，算法的思路都是相同的。</p><!-- [[[read_end]]] --><p>递归思想的一个更具体的使用方式，就是<strong>递归函数</strong>。当前的各种高级语言，都会支持递归函数，也就是允许在一个函数内部调用自身。</p><p>你可以看看下面这个例子，这个例子是用来实现阶乘的计算的。</p><pre><code class=\"language-plain\">function factorial (n:number):number{\n  if (n &lt; 1)\n    return 1;\n  else\n    return n * factorial(n-1); \n}\n</code></pre><p>在这里，n的阶乘f(n)，就等于n * f(n-1)。这是典型的递归思维，解决一个整体问题f(n)，能够被转化为解决其局部问题f(n-1)。n的值变化了，但解决问题的思路是一致的。</p><p>最近几年，函数式编程的思想又重新流行起来。在一些纯函数式的编程语言中，递归是其核心编程机制，被大量使用。</p><p><strong>不过，递归函数的大量使用，对程序的运行时机制是一个挑战。</strong>因为我们已经知道，在标准的程序运行模式下，每一次函数调用，都要为这个函数创建一个栈桢。如果递归的层次很深，那么栈桢的数量就会非常多，最终引起“stack overflow”，也就是栈溢出的错误，这是我们在使用栈的时候最怕遇到的问题。</p><p>另外，我们还知道，<strong>当我们在进行函数调用的时候，还会产生比较大的性能开销</strong>。这些开销包括：设置参数、设置返回地址、移动栈顶指针、保护相关的寄存器，等等。特别是，在这个过程中，一般都会产生内存读写的动作，这会对性能产生比较大的影响。</p><p>所以说，虽然递归函数很有用，但你在学习编程的时候，可能你的老师会告诉你，如果对性能和内存占用有较高的要求，那么我们尽量不用递归算法实现，而是把递归算法改成等价的非递归算法。</p><p>不过，现代编译器也在努力帮助解决这个问题。比如在上一节课中，我们就已经见到了C语言编译器的一个功能，它在编译斐波那契数列的过程中，能够把其中一半的递归调用转变成一个循环语句，从而减少了递归调用导致的开销。</p><p>但在这一节课呢，我们不会试图一下子就实现这么复杂的编译优化功能，而是先针对递归调用中的一个特殊情况而进行优化，这个特殊情况就是<strong>尾递归</strong>。</p><p>那什么是尾递归呢？<strong>尾递归就是在return语句中，return后面只跟了一个递归调用的情况</strong>。在上面的例子中，你会看到return后面跟着的是n * factorial(n-1)，这种情况不是尾递归。不过，我们可以把示例程序改写成尾递归的情形，我写在了下面：</p><pre><code class=\"language-plain\">function factorial(n:number, total:number):number{\n  if (n &lt;= 1)\n    return total;\n  else\n    return factorial(n-1, n*total); \n}\n</code></pre><p>这个新的阶乘函数使用了两个参数，其中第二个参数保存的是阶乘的累积值。如果要计算10的阶乘，那么我们需要函数factorial(10, 1)。你可以仔细看一下factorial函数的两个不同的版本，它们确实是等价的。但第二个版本中的第二个return语句呢，就是一个标准的尾递归调用。</p><p>我们为什么要谈论尾递归呢？这是因为尾递归在栈桢的使用上有其独特的特点，使得我们可以用很简单的方法就能实现优化。</p><p>那么接下来，我们就分析一下递归函数在栈的使用上的特点，这有利于我们制定优化策略。</p><h2>递归函数对栈的使用</h2><p>你可以用我们上一节课的PlayScript版本，使用make example_fact命令来生成上面示例程序的汇编代码和可执行文件。</p><p>这个汇编文件是没有做尾递归优化的，你可以看一下它的内容，看看它的栈桢是什么结构。</p><pre><code class=\"language-plain\">_factorial:\n    .cfi_startproc\n## bb.0\n    pushq   %rbp\n    movq    %rsp, %rbp\n    cmpl    $1, %edi                #  cmpl $1, var0\n    jg  LBB0_2\n## bb.1\n    movl    %esi, %eax              #  movl var1, returnSlot\n    jmp LBB0_3\nLBB0_2:\n    movl    %edi, %r10d             #  movl var0, var2\n    subl    $1, %r10d               #  subl $1, var2\n    movl    %edi, %r11d             #  movl var0, var3\n    imull   %esi, %r11d             #  imull    var1, var3\n    movl    %r10d, %edi\n    movl    %r11d, %esi\n    callq   _factorial\n    movl    %eax, %edx              #  movl returnSlot, var4\n    movl    %edx, %eax              #  movl var4, returnSlot\nLBB0_3:\n    popq    %rbp\n    retq\n    .cfi_endproc\n</code></pre><p>从汇编代码中，你能看出来，这个函数的栈桢特别简单。在factorial函数中，n和total两个参数是保存在寄存器中的，在栈桢里只保存了rbp寄存器的旧值和返回地址。如果递归函数复杂一点，或者我们采用的是比较简单的寄存器分配算法，那么栈桢里可能会保存一些其他信息，比如溢出的变量等。</p><p><img src=\"https://static001.geekbang.org/resource/image/a5/62/a55b3dc800a963af5c7311f497c5b062.png?wh=732x602\" alt=\"图片\"></p><p>然后，每次的递归调用，都会创建一个栈桢。递归嵌套多少层，就需要建立多少级的栈桢。如果说我们要计算10000的阶乘，那就需要10000个栈桢。</p><p>这样说的话，到目前为止，我们的编译器所生成的程序，是完全合乎规则的，似乎没啥问题啊？</p><p>不过，如果你细看一下，就会发现一个现象：<strong>在每一级调用结束之后，我们都会返回到上一级函数。而且上一级函数也会立即结束，继续返回上一级。这个过程会一直持续下去，直到退出最上面一级的factorial函数。</strong></p><p><img src=\"https://static001.geekbang.org/resource/image/7b/bf/7bd9ae1bbc1b91396bd2efc983424bbf.png?wh=762x602\" alt=\"图片\"></p><p>在逐级返回的过程中，其实程序再也没有访问n和total这两个本地变量，只有%eax寄存器是有用的，因为这里面保存了返回值。</p><p>这样看起来，这些一层层的上级栈桢，都是没有什么用的，这里的内存空间，完全是浪费的。也就是说，在计算10000的阶乘的时候，前9999个栈桢其实都是没有用的。另外，寄存器里保存的变量的值，也已经结束了生存期。所以，我们在调用下一级函数的时候，根本没有必要去保护它们原来的值。</p><p>既然如此，那我们能不能做一些优化，提高程序的性能呢？</p><p>这就需要用到<strong>尾递归优化</strong>的技术了。</p><h2>尾递归优化</h2><p>这要怎么优化呢？总的思路是这样的：<strong>既然旧函数的栈桢没有用，那么我们就没有必要为递归调用产生一个新的栈桢，而是复用当前栈桢就行了</strong>。</p><p>那怎么实现这一点呢？我先直接说答案吧。我们的解决思路，就是把call语句改成一个jmp指令，跳到程序的开头重新执行。</p><p>这个时候，参数1和参数2的值已经分别被更新成了n-1和n * total。所以，当我们跳到程序开头再一次执行的时候，就相当于调用factorial(n-1, n * total)，从而取得了和尾递归调用相同的计算结果，你可以看看下面这个截图。</p><p><img src=\"https://static001.geekbang.org/resource/image/f5/2b/f5b811dff17ee6199cd4395c454b912b.png?wh=1428x1056\" alt=\"图片\"></p><p>这里我稍微岔开一个小话题，在上面的图中，你会看到我还把callq后面的两条指令打了叉，去掉了。这个原因也很简单，这两条语句其实是做了无用功。第一条指令把eax中的值拷贝到edx，第二条又从edx拷贝回了eax，作为返回值的eax其实并没有变化。</p><p>你还记不记得，在上一节课的思考题中，我让你去检查，我们目前生成的汇编代码还有哪些地方需要优化，这里就是其中一个例子。不过，具体如何去完善这些代码，我们以后再说。</p><p>我们还是回到尾递归的话题上来。对着上面的汇编代码，你可能会发现，这不就是一个循环语句的结构吗？每次循环，就把n减1。也就是说，上面的汇编代码其实相当于下面的高级语言代码：</p><pre><code class=\"language-plain\">function factorial(n:number, total:number):number{\n  for (; n&gt;=1; n--){\n    if (n&lt;=1)\n      return total;\n    else\n      total = n*total;\n  }\n}\n</code></pre><p>没错！<strong>尾递归调用是一定能够转化成一个循环语句的</strong>。也正因为如此，所以我们没有必要为每次调用都生成一个新的栈桢，这样就能既避免了栈溢出的风险，又提升了性能。</p><p><strong>那么，我们应该如何升级PlayScript，来实现尾递归的优化呢？</strong></p><p>首先，我们必须能够分析出来什么样的函数调用属于尾递归。这个判断起来也比较简单，如果一个return语句中的表达式，只有一个递归调用，那么这个递归调用就是尾递归。</p><p>我们看看它的AST有什么特点。你用node play example_fact.ts -v 命令，可以打印出程序的AST信息。你会发现，ReturnStatement节点只有一个FunctionCall子节点，并且FunctionCall所调用的函数正是factorial自身，是一个递归调用。</p><p><img src=\"https://static001.geekbang.org/resource/image/44/50/44e9f4ae8cda660c1e06db4b051e9350.png?wh=1552x976\" alt=\"图片\"></p><p>掌握了AST的这个特点后，我们很容易就可以写一个分析程序，识别出哪个函数调用是尾递归，从而改变后面生成汇编代码的逻辑，这里具体代码你可以参考代码库里的<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/21/tail.ts#L13\">TailAnalyzer</a>。</p><p>TailAnalyzer的运行结果，是一个<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/21/tail.ts#L90\">TailAnalysisResult</a>对象。这个对象里保存了所有尾递归的FunctionCall节点。这样，在生成Asm的时候，我们就可以针对尾递归专门生成不同的代码了。</p><p>接下来，我们再使用这节课的PlayScript版本，再次执行make example_fact，就会生成针对尾递归优化后的汇编代码和可执行程序。我们看一下新版本的汇编代码：</p><p><img src=\"https://static001.geekbang.org/resource/image/9d/8b/9d99c1a27d29b80c4c287ef4f683ae8b.png?wh=1188x990\" alt=\"图片\"></p><p>在新版本生成的汇编代码里，你会看到我们新加了一个基本块，作为跳转指令的目标。而原来的callq指令，则变成跳转到这个基本块的一个jmp指令。</p><p>你可以运行一下新版本的程序，你会发现两个版本的运行结果是相同的，也就是说它们的功能是完全等价的。如果你有兴趣的话还可以做一个测试程序，测一下优化前后的性能差异到底有多大。</p><p>你可以把阶乘的例子变成一个累加的例子来测试，也就是f(n) = n+f(n-1)。为什么呢？因为阶乘的值增加得太快了，很快就会超过整数的范围，比如16的阶乘就超出了一个32位整数的表达能力。</p><p>好了，现在我们已经完成了尾递归的优化。但在这节课的开头，我们还提出了另一个概念，就是<strong>尾调用</strong>。那么尾调用又是什么呢？我们把尾递归和尾调用放在一起介绍，是否意味着我们也可以采用尾递归优化的思路来优化尾调用呢？我们接着往下分析。</p><h2>尾调用优化</h2><p>什么是尾调用呢？<strong>尾调用就是在return语句后面直接跟一个函数调用的情况</strong>。比如，对于下面两个函数foo和bar，foo中有一个return语句，直接调用了bar，这就是一个尾调用的情况。</p><pre><code class=\"language-plain\">function foo(p1:number, p2:number):number{\n  ...\n  return bar();\n}\nfuntion bar():number{\n  ...\n}\n</code></pre><p>如果你利用我们分析尾递归所获得的知识去分析尾调用，就会发现它们是有相似点的。也就是，<strong>在做尾调用的时候，调用者的栈桢和寄存器已经没有用了，所以被调用者完全没有必要新建立一个栈桢，而是复用调用者的栈桢就可以了</strong>。</p><p>那么这具体要怎么进行优化呢？其实跟尾递归一样，我们都是使用jmp指令来代替callq指令就行了。只不过，这一次jmp跳转目标，是_bar，也就是bar函数的入口位置。</p><p>我们之前就说过，在汇编语言里，函数名称也只不过是一个标签而已，所以它们可以作为跳转指令的目标。而原本callq指令，也只不过是相当于两条指令：</p><pre><code class=\"language-plain\">pushq 返回地址\njmp 函数标签\n</code></pre><p>但在尾调用的情形下，我们没必要修改返回地址。因为bar返回foo以后，接着就会返回foo的调用者。所以，我们这里只用一个jmp指令就可以了，这样也能减少保存返回地址导致的性能开销。</p><p>具体实现，你可以通过make example_tail命令，去编译<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/21/example_tail.ts\">example_tail.ts</a>示例代码，并研究一下它所生成的汇编代码。</p><h2>课程小结</h2><p>好了，到这里我们今天这节课就讲完了。这节课，我们借助尾递归和尾调用优化的话题，加深了对栈、栈桢和程序运行机制的了解。我希望你记住并产生以下这几个认知：</p><p>首先，对于任何程序来说，当它在执行return语句的时候，所有的变量的生存期其实都已经结束了，所以栈桢和变量所占据的寄存器就都没用了。而尾递归和尾调用的优化，就是借助了这一特点，复用了调用者的栈桢，从而达到了节省内存和提高性能的目的。</p><p>第二，我已经多次提到一个观点，就是<strong>计算机语言的设计者，其实拥有很大的自由度来决定如何使用栈桢</strong>。这节课的内容也能够再次印证我这个观点，我们对栈和栈桢的使用不是僵化的、一成不变的，而是针对不同的语言特性，我们可以做不同的使用。比如，在实现协程机制的时候，我们使用栈的方式跟传统的函数调用方式也有不同。如果你想进一步了解这方面的知识，你可以参考一下《编译原理实战课》的<a href=\"https://time.geekbang.org/column/article/280269\">第34节</a>。</p><p>最后，这节课也是我们第一次接触编译器中的优化技术。对于编译器来说，第一项任务当然是把高级语言的代码翻译成目标代码，而第二项重要的任务就是在翻译的过程中，做各种优化，尽量保证生成的是最高效的机器码。而优化采用的技术也有很多，并且会发生在编译过程的各个阶段。优化工作其实也是编译器中工作量最大、难度最高的工作。在后面的课程中，我们也会接触到更多的优化技术。</p><h2>思考题</h2><p>你会发现，在我们<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/21/example_tail.ts\">example_tail.ts</a>这个尾调用的例子中，只有一个程序的出口，也就是只有一个return语句，所以我们做指令的改写还是比较容易的。那如果存在两个或两个以上的return语句，并改写其中的一个尾调用语句，让它变成jmp指令，这样生成的汇编代码又会有什么不同呢？</p><p>欢迎你研究一下，并在留言区分享你的发现，这个研究会帮助你加深对程序控制流的理解。我是宫文学，我们下节课见。</p><h2>资源链接</h2><p><a href=\"https://gitee.com/richard-gong/craft-a-language/tree/master/21\">这节课的示例代码在这里！</a></p>","neighbors":{"left":{"article_title":"20｜怎么实现一个更好的寄存器分配算法：实现篇","id":420555},"right":{"article_title":"期中测试｜快来检验你在起步篇的学习成果吧","id":423940}}},{"article_id":423940,"article_title":"期中测试｜快来检验你在起步篇的学习成果吧","article_content":"<p>你好，我是宫文学。</p><p>不知不觉间，我们的课程已经更新过半了。前几天，我们也更新完了第一部分，也就是起步篇的内容。到这里，我其实已经带你完整地跑完了，实现一门计算机语言需要的全部流程了。不知道你学习得怎么样呀？不如做套题来检验一下吧？</p><p>趁着国庆假期，我根据我们第一部分起步篇里讲过的知识，给你出了20道选择题，你可以检验一下自己的学习成果。如果你有什么不理解的地方，欢迎在留言区留言，也可以直接来我们的<a href=\"https://jinshuju.net/f/eMNUpx\">微信交流群</a>找我。</p><p>快点击下面的按钮开始测试吧，我期待着你满分的好消息。</p><p><a href=\"http://time.geekbang.org/quiz/intro?act_id=974&exam_id=2805\"><img src=\"https://static001.geekbang.org/resource/image/28/a4/28d1be62669b4f3cc01c36466bf811a4.png?wh=1142x201\" alt=\"\"></a></p><!-- [[[read_end]]] -->","neighbors":{"left":{"article_title":"21｜加深对栈的理解：实现尾递归和尾调用优化","id":421602},"right":{"article_title":"“他山之石”｜Sugar：这门课你可以试试这么学","id":424229}}},{"article_id":424229,"article_title":"“他山之石”｜Sugar：这门课你可以试试这么学","article_content":"<p>你好，我是这门课程的助教 Sugar，曾供职于百度，现就职于某大型互联网公司，是一名软件工程师。和你一样，我也是一名编译技术的爱好者。</p><p>我们的课程更新到今天，已经过半了，不知道你学习得怎么样呢？有没有卡在哪个知识点的实现上？不要担心，如果你有任何的问题，除了在留言区留言外，还可以添加我们的<a href=\"https://jinshuju.net/f/eMNUpx\">微信交流群</a>，直接 @ 我或者是宫老师，或者是其他志同道合的同学们，我们都会来帮你解决。</p><p>回归正题，今天，刚好是国庆假期，我们第一部分的起步篇也更新完了。我们就先停下来休息休息，夯实基础。在这篇分享里，我想跟你聊聊我对编译技术的看法。我也会从我个人的角度，给你总结一下已更新完的起步篇都讲了什么，以及在日常工作中，我们又可以从哪些方向把这门课学到的知识落到实践中来。最开始，我们聊聊为什么要学习编译技术这个话题。</p><h2>我为什么推荐你学习编译技术？</h2><p>我大概是在2014年入行互联网行业的，一晃就是7年。这7年间，很多公司的口号和观点都从“从PC业务向移动端转型”，变成了“国内移动端用户饱和，期待其他新兴领域带来业务增量”。科技行业发展之快，令人欣喜也叫人唏嘘。</p><p>不得不说，作为一名计算机专业科班出身的同学，我很惭愧。我其实是在走上工作岗位后，才对作为本科必修课的编译原理有了真正的了解，也真正感受到了这个技术领域独特的魅力。所以现在，我也推荐你关注这项技术。</p><!-- [[[read_end]]] --><p>为什么我会推荐你学习编译技术呢？如果你一定要问我理由，我想给你分享两点。</p><p><strong>第一点，网红热点的“花开花落”，远不如底层技术的“静水流深”有力量。</strong></p><p>在我还是一名“产品工程师”（Product Engineer）的时候，我从事过客户端、前端、服务端，以及一些面向业务应用的算法方面的工作。</p><p>近些年，每一个技术领域都涌现过各种新概念、新趋势，这可能会让你陷入“学习了这门新技术，就能分享这种技术形态的成长红利，提升自我价值”的错觉。我也曾追赶过这些“技术时尚”：做后端时一会儿学学这个语言，一会儿瞧瞧那个中间件；做前端时，一会儿用用这个框架，一会儿看看那个三方库。</p><p>但冷静下来，你就会发现，这些“网红型”技术热点，能够沉淀下来、为业务长期赋能的寥寥无几。真正值得长期学习和不断实践的，反倒是计算机专业的那些基础课，包括但不限于数据结构与算法、计算机网络、操作系统、编译原理、计算机体系结构，还有软件工程等等。这些课程你在学校里学习的时候，可能感觉枯燥乏味、过于抽象，甚至毫无成就感，然而在工作以后你才会发现，这可能是一名 coder 应对“行业内卷”最坚实有力的后盾。</p><p><strong>第二点，技术上卡的“脖子”也正意味着更多的机会和可能。</strong></p><p>其实，近两年来，我们国内IT行业很多龙头企业都遭遇了“技术卡脖子”的情况。一时间，芯片、操作系统以及其他基础软件国产化的呼声，都起来了。但是，在我看来，这些“low-level-stuff”需要的不止是时间与金钱的投入，更需要技术人才的“梯队化”。</p><p>国外的许多大公司里，你都能见到50多岁，甚至年龄更大的资深程序员。他们往往不是从事一些面向用户的业务逻辑开发，而是做一些被称为 Infrastructure 的基础架构工作。我们国内这样的趋势还不够明朗，毕竟我们起步太晚，做这些基础技术的工作，又需要公司雄厚且稳定的营收去支撑。这个差距是显而易见的，甚至短期内都没法快速弥补上。</p><p>我曾经就遇到过一个Google V8引擎方面的技术难题。我当时是在一个C++的程序中集成了 V8，通过 V8 的 ObjectTemplate 和 HandleScope 等优化尽可能快速生成 jsObject，并传递到 V8-Isolate 内部的 jsContext 里。但我用尽了所有方法，依然达不到原生 JavaScript 中字面量 Object 的性能。我跟身边许多架构师同事进行了探讨，也通过e-mail和V8项目的一些参与者进行了交流。但是我发现，相比起国外的技术社区，国内工程师们能给出的一些建议确实非常有限。</p><p>当然，我不认为这是技术水平、或者是智力这些因素造成的，事实上，国内有大量非常聪明，而且比国外更加勤劳（内卷所致）的软件工程师。在我看来，造成这个现象的原因，主要是 V8 项目的历史实在太久远了，而且早期的核心开发人员又有许多来自于历史更久远的 Java 虚拟机。整个过程具有很强的“技术继承性”，国内的工程师很难有机会，真正深入地了解这些系统的技术内幕。</p><p>或许，这就是我们在很多核心技术领域被“卡脖子”现象的主要原因之一。不过，困境也就意味者突破和机会。在底层软硬件国产化的浪潮下，编译器和操作系统是两座绕不过、躲不开的大山，国产芯片也会创造出大量让编译技术大放异彩的机会。在可预见的未来5～10年内，国内的这个技术趋势都是存在的。所以，我看好编译技术、操作系统等这些技术领域的发展，也推荐你深入学习这些底层技术。</p><h2>起步篇讲了什么？</h2><p>前面聊完了“为什么”，现在我们就来解析一下“是什么”，聊聊我们这门课已更新完的起步篇里，都讲了什么。</p><p>不过，在这里我希望你能理解一点，当前这门课程是宫老师讲编译技术的第三季课程了，所以不可避免地存在着一定的知识继承性和延续性。对于编译器的前端部分，这次的课程中讲得相对没有那么深入。如果你想深入了解前端的知识，我建议你去看看<a href=\"https://time.geekbang.org/column/intro/100034101\">第一季《编译原理之美》</a>和<a href=\"https://time.geekbang.org/column/intro/100052801\">第二季《编译原理实战课》</a>。第三季的重点是放在了编译器后端部分，和物理机、操作系统打交道。</p><p>如果你看到我梳理的概念中，有很多是你无法理解的，你也可以带着疑问，试着把整个流程串起来。有了一个整体的“大局观”之后，再回头去第一季和第二季中找寻答案，当然也可以在我们的微信交流群里提问。</p><p>编译器是一个工业级的基础软件，因此从理论体系上我们就将编译器分成了前端、中端和后端三部分（有些文献上也把中端算为后端）。</p><p>你在学习中也会发现，宫老师起步篇的安排，也是按照这个顺序：02是讲词法分析，03和04的前半部分是讲语法分析，后面的04到06的部分则是循序渐进地把编译器前端的语义分析和语法分析的功能，拆成一个个具体的 feature 一点一点放到我们的示范程序中来完成、实现。</p><p>07到11节部分呢，是有关虚拟机的话题。严格意义上，其实虚拟机相关的技术并不算是传统的编译原理范畴。在编译技术的三大圣经（《龙书》、《虎书》和《鲸书》）里有关虚拟机、垃圾回收等方面的篇幅少之又少。不过这也是因为历史的局限性，毕竟 Java 这样的语言在1995年才诞生。不过我们的课程却是与时俱进的，在读到宫老师的这部分内容时候，我眼前一亮。</p><p>接下来的11-12两节课呢，是一些基础知识的铺垫。这里涉及到编译器与操作系统、和计算机硬件之间“打交道”时的一些“责任边界”。后面的14-18节，则是对编译器后端技术的实践。由于我们课程的受众大部分是软件工程师，所以在14和15两节课，宫老师又花了不少篇幅为大家科普芯片指令集的一些基础知识。</p><p>在我看来，理解芯片和汇编语言有一个很好的方法，就是把芯片看成我们中学时期用过的“科学计算器”，甚至是更简单的“日常使用的普通计算器”。唯一的不同之处就是，芯片没有给人类手指去触摸的按钮，取而代之的是需要用程序通过一组组汇编代码去操纵这个“超级微型却功能强大的计算器”。希望我这样的描述，能减少你对芯片指令集的陌生感、缓解你对“超纲知识”的恐惧。</p><p>起步篇最后的19-21这三节课呢，是对一些难点知识的精讲。如果你的基础不牢固，我建议你优先学习前面的知识内容。除此之外，我还为你整理了一张脑图，帮你“高亮”出了一些学习这门课有必要弄懂的关键概念：</p><p><img src=\"https://static001.geekbang.org/resource/image/a2/f8/a2d33b172b4e12d2994fc468045f72f8.png?wh=1698x1500\" alt=\"图片\"></p><h2>动手实践才是目的</h2><p>理清了我们起步篇的内容，最后我们聊聊在日常工作中，我们可以从哪些方向把这门课学到的知识落到实践中来。我想从我从事过的前端、客户端、服务端和算法这四个软件工程师岗位，给你讲讲我是如何在日常工作中实践编译技术的，希望能对你有一些参考价值。</p><p>平心而论，我非常建议你，把课程作为自己学习的一个起点而不是终点。只有你真正实践过，你才能真正明白为什么大部分语言的前端都在依靠手写递归下降+算符优先级算法的组合去实现，而鲜有教科书上那样设计精巧的LL算法实现（因为first和follow集的维护成本太高了！）。</p><h3>领域一：前端</h3><p>你可能会问，前端领域真的有必要，学习编译原理这样的技术吗？我理解，毕竟很多前端的同学，每天的工作就是机械地进行设计稿（PS、Sketch等生成的文件）到 HTML+ CSS 代码的转换。但你可能忽略了一些我们前端每天都在使用的构建工具，比如webpack、Rollup，或者是近两年涌现出的ESbuild、swc等等，这些恰恰是我在从事前端工作期间，认为最有意思的一些infra类的工作。</p><p>而且，我们这门课也使用了 JavaScript/TypeScript 语言作为教学工具。如果你就从事前端，那我非常建议你把上面这些构建工具作为自己的研究目标，像电影《速度与激情》里的剧情一样，把自己每天开的“车子”拿过来拆开看看，动手改装“魔改”一番，这会是一件非常有乐趣和成就感的事。</p><p>另外，从 Typescript 到 Wasm 这些新工具、新技术的出现也能看出，前端是最有可能在近几年内，因为编译技术而出现新变革的技术领域。如何设计出一种在开发阶段可以使用JavaScript技术栈、而在运行时又能提供尽可能像C++一样高性能的编程语言工具链，将成为业界的一个关键课题。</p><h3><strong>领域二：客户端</strong></h3><p>准确地说，客户端开发这并不是一个单一的技术领域。但在今天这个时间点，它在语义上至少可以包含移动端上的 Android（Java-JVM技术栈）和 iOS（OC/Swift技术栈）两个研发岗位，涉及桌面PC端的话通常意味着 Windows 平台的开发（C#、C++技术栈）。</p><p>谈到这里，我想起了我在本科期间非常热衷研究的逆向工程技术（这是信息安全的一个细分领域），就是依靠对已经编译好、打包的客户端程序，通过反解、静态分析和动态调试等一系列技术手段，获悉到其源程序代码中的部分甚至全部逻辑，从而达到自己的目的。</p><p>客户端开发应该是逆向工程这门技术最主要的攻防战场，这个领域很能满足你对“黑客”这种角色的向往。但今天我回头再看，当年自己用过的像IDA Pro这样的神器，其底层实现原理就完全离不开编译技术，包括做动态调试的话，其实很多时候需要对底层汇编、IR或者 Smali 这些贴近硬件的语言有足够的了解，这也是我们课程中所涉及到的知识。</p><p>另外，近几年，移动端对代码热更新、动态化方面的探索也涌现出了很多优秀的开源方案，这也离不开编译技术。你也完全可以自行设计一套自行编译、动态下发、解释执行甚至AOT的动态化技术方案，这是一件非常锻炼人能力的事情。我还能想到，“端智能”也是一个可以让编译技术大展身手的场景，不过这个话题我们放在下面的算法岗位部分再谈。</p><h3>领域三：服务端</h3><p>在我的印象里，后端工程师在一个研发团队中非常像足球场上的中场球员，他对技术全面性的要求最高，同时业务线上的服务端工程师也是最辛苦的一个岗位（有过oncall期间夜里12点刚完成代码的全量发布上线，又在凌晨三四点被服务器短信报警叫醒的经历之后，你会深刻体会到这一点）。</p><p>你可能也有体会，因为我们和业务数据离得近，总会有各种临时性的“需求”不仅会打断我们原本的工作计划，而且经常是无法计入研发排期的“脏活累活”，费力不讨好。我就曾经经历过这样一段时期，团队缺人，经常还有其他非技术岗同学排着队来我这里提这些临时性的统计数据需求。</p><p>工程师就该从技术的角度去想办法，于是我当时自己设计了一套简易的DSL，用于描述特定的一些数据维度（比如用户PV、比如文章分类Tag），你可以理解为这是一个SQL语言的子集，不过不同之处是使用中文的“查询”、“关联”这些名词作为代码的关键词，方便非技术岗的同学。然后我专门开发了一个简单的编译工具，将这个DSL转译成集群中跑的HQL（Hive SQL）。最后，我把这个工具，配合详细的文档，提供给了每天排队给我提需求的其他同事。自此我就完美地解决了这个问题，不知这个case是否对你有所启发。</p><p>当然了，服务端工程师其实有特别好的技术研究土壤，你可以根据自己团队所使用的语言运行机制，比如Java、PHP、Golang等，进行一些针对性的集群改造、甚至对语言编译期、运行时本身进行“魔改”。最初往往都是从研读语言本身编译器、解释器的源码开始，逐步输出一些对业务代码写法上的优化改造开始的，逐步才会过度到开发一些 C扩展、甚至开始魔改解释器本身，以上都是很多后端 Infra 团队经历过的过程。这些都是实实在在能够产生业务价值的技术研究性课题，相信这也会给你带来非凡的成就感和价值感。</p><h3>领域四：算法</h3><p>算法岗位通常意味着，依靠AI算法来解决业务场景中的实际问题。在今天的互联网公司里，最常见的算法岗就是检索、推荐和广告这三个业务场景。</p><p>算法岗位在技术探索的角度上是我们软件工程师的“星辰大海”，上至数学理论、下至底层硬件技术，都可能为这个领域涉足，而编译技术在算法这一技术领域同样有它的广阔应用前景。在许多人看来，未来的自动驾驶、智能家居、智能穿戴等诸多新的业务场景，将带来移动端时代成百上千倍的数据规模。更大的数据规模当然意味着更大的训练样本，而基于现有的芯片硬件架构提供的算力，显然是吃不消的。</p><p>现阶段的深度学习往往是使用GPU进行大量矩阵运算，而各个公司也都在进行新一代AI专有芯片的研究探索，包括NPU、XPU等等。这也包括我们前文中提到的“端智能”场景，也就是出于性能和隐私安全等诸多原因，把一些AI相关的计算逻辑搬到手机本地的一块芯片上。</p><p>在未来，如何更好地将上游的数学计算问题转化为底层芯片上的逻辑运算，这将会是算法岗位偏工程团队关注的一大课题。如果你对此方向有兴趣，我建议你考虑加入你所在的公司的算法工程架构团队，比如现在很多企业都在用的 Tensorflow、PyTorch等框架的服务端集群进行运维工作一般就是交由这样的团队来处理的，他们通常以 Python 和 C++ 作为主要的技术栈。</p><p>不过，算法领域其实是一个非常大、并且涉及到很多不同专业背景的工程师共同协作完成的一个技术领域，有很多其他计算机基础技术理论也都可以在这个岗位上进行实践，这里就不一一列举了。</p><p>最后，我想说，每当我们抱怨自己深陷繁重而又重复的业务开发工作中，无暇去实践很多有意思的技术问题的时候，其实机会往往就在我们每天工作的日常当中。我希望你能动手实践起来，把这些硬知识都结合到工作中来。</p>","neighbors":{"left":{"article_title":"期中测试｜快来检验你在起步篇的学习成果吧","id":423940},"right":{"article_title":"“屠龙之秘”｜实现计算机语言这样的技术能用在哪里？（一）","id":424365}}},{"article_id":424365,"article_title":"“屠龙之秘”｜实现计算机语言这样的技术能用在哪里？（一）","article_content":"<p>你好，我是宫文学。</p><p>在学习这么多硬知识的间隙里，我给你准备了一些相对轻松一点的内容，想让你转换一下，让大脑休息休息。</p><p>不知道你在学习这门课的时候，有没有这样的困惑：<strong>实现计算机语言这样的“屠龙技”，到底在哪里能够发挥作用呢？</strong>毕竟，不是每个人都有机会成为像Java、JavaScript这样的通用语言的发明者的。</p><p>我的答案是：其实在任何软件领域，只要你做得足够深，其实都能用上这门课程的知识。我也一直在给你传达一个理念：<strong>任何好的软件，其实到最后都会变成一个开发平台，所以也就需要用到实现计算机语言的这些相关技术</strong>。</p><p>所以，在这里，我想分成两节课或者更多节课，给你介绍一些有意思的应用场景，希望你能从中得到启发，在自己的工作中也能更好地运用我们这节课的知识，做出一些耀眼的成绩。</p><p>今天这节课，我会跟你分享自动化控制领域（或者简称自控领域），对软件编程的需求，以及如何设计一个开发平台来满足这样的需求。在学习这节课的过程里，你可以不断地做一些印证，想想你可以用在门课学到的知识，怎么来满足这个领域的需求。</p><p>但是，我需要补充一句，我自己并不是自控领域的从业者。只不过，我恰好有一些朋友，是国内这个领域顶级的、资深的专家，所以我就有机会学习到了这个领域的一点知识。并且，我跟他们参与了一个工业领域的操作系统项目的策划工作，这也激发了我对这个领域的编程模式的兴趣。但是呢，我对这个领域了解得并不那么深，也不那么专业，我主要关注其中与编程技术有关的部分。</p><!-- [[[read_end]]] --><p>那么首先，我们来了解一下自控系统的作用和应用场景，方便我们理解它对编程技术的需求。</p><h2>自控系统的应用场景</h2><p>计算机技术在工业领域有着丰富的应用，其中一个应用领域，就是自动化控制。</p><p>其实自动化控制离我们特别近，你肯定不陌生。比如，当你乘坐地铁或高铁的时候，它们总是能够准确地停在站台边，停靠的位置甚至可以精准到厘米级。这里面就有自动控制的程序在起作用。</p><p>自动化控制也有在工厂里的应用，你可能没那么熟悉，但也跟你的生活密切相关。比如在发电厂里，我们需要对发电机组机组进行精确地控制。如果转子的旋转速度出了问题，那就会酿成巨大的灾难。在核电厂里，我们也需要对核燃料进行精确地控制，以便正常发电，不要引起事故。</p><p>你知道，制造业是一个现代国家的根本。而现代工厂的生产过程，几乎全部都会用到自动控制系统，包括离散制造型企业，就是给我们制造手机、电脑、汽车的企业；还有流程型企业，比如各种化工厂，还有前面提到的电厂。</p><p>最后，其实我们身边应用得非常广泛的物联网，也属于广义上的自控领域。比如，你家里的智能电表、智能门锁，还有小区停车场的自动道闸等等。</p><p>所有这些应用场景，基本上都会采用类似下面的这种技术架构：</p><p><img src=\"https://static001.geekbang.org/resource/image/5d/07/5dd10bc857b6a3d23ff4b1ae160e7007.png?wh=1450x1079\" alt=\"图片\"></p><p>你看这张图，最底下是各种生产设备。在这层之上呢，是一些自动化的控制器。控制器最重要的作用就是控制设备的运行。它的原理是这样的：设备在运行过程中，会不断产生信号，信号会被实时传输给控制器。控制器接收到信息以后，在内部进行实时计算，然后根据需要输出一些控制信号，让设备的运行做出一些改变。</p><p>通常来讲，控制器对计算能力的要求不会太高，控制的逻辑通常也并不是特别复杂，因为控制程序的时延必须很低。这也很容易理解，比如你开车的时候，肯定不能容忍刹车的响应很慢，那会出事故的。也正是因为实时性的要求，自动系统一般都运行在实时操作系统上，甚至运行在裸设备上。</p><p>而且，控制器会跟一个上位机连接，并通过某种工业协议进行通信。上位机的计算能力和存储能力都会比控制器更强。我们通过上位机，就可以了解每个控制器的运行情况，可以对控制器做一些操作，比如升级控制器上的程序等等。</p><p>好了，这就是自控领域最基本的计算架构，以及系统的运行场景。那么为了满足自控系统的需求，需要什么样的开发工具呢？是不是用普通的编程语言和开发工具就能满足自动的需求呢？</p><h2>自控系统的技术特征</h2><p>自控程序的开发和运行有特殊的要求。我们平常用到的开发语言和开发工具，很难满足这些需求，因此我们必须设计专门的工具。我来给你分析一下。</p><p><strong>首先，自控系统运行的硬件环境是不同的。</strong></p><p>从硬件架构来看，这些控制器的设计跟我们平常的手机和桌面电脑都不一样。。</p><p>从硬件的电气特性来看，这些硬件在环境适应上的要求要比普通民用的更加严苛。这些硬件在设计上能够更好适应比较恶劣的工业环境，比如能承受比较大的震动、电磁、灰尘等的影响。普通民用的硬件设计，在这种环境下可能会从硬件产生出错误的信号，或者存储的数据发生错误，甚至无法正常工作。</p><p>从编程者的角度看，这些控制器的CPU的架构也跟我们手机和电脑不大相同。CPU架构的概念我们前面已经学过了。不同的CPU架构，意味着不同的指令集、不同的寄存器、不同的内存寻址方式，以及不同的异常处理机制等等。</p><p>不同的CPU架构，自然会导致程序开发方式的不同。普通的编译器，有可能都不支持这些芯片，或者没有针对这些硬件进行专门的优化。这个时候，如果你掌握了一些编译技术的后端知识，就知道如何以最优的方式生成机器码，并充分发挥硬件的能力。</p><p><strong>第二，自控系统运行的软件环境也是不同的。</strong></p><p>我们前面提到过，对于实时性要求比较高的场景，自控程序通常运行在实时操作系统里，或者是在裸设备上运行。所以，我们的开发工具也要能够生成在实时操作系统或裸设备上运行的程序。</p><p>不知道你还记不记得，我们前面讲过，在操作系统上运行，需要遵守相应的ABI，让程序能够跟操作系统相互配合起来。所以，这就需要开发工具支持实时操作系统才可以。当然，如果运行在裸设备上，那么就需要我们的开发平台本身来提供一些运行时功能，有支持IO、任务调度等能力，那这个运行时在某种意义上也是一个简化版的实时操作系统。</p><p><strong>第三，自控系统的软件更新机制是不同的。</strong></p><p>自控系统跟我们其他软件一样，在开发过程上也需要进行版本迭代。不过它的版本迭代有时候要求更高。比如，像发电机组等设备一旦投入运行，是不可以随意停机的。每次停机，都会造成很大的成本和影响。还有像卫星、太空舱上面的关键设备，大概也是这样的。这就需要自控系统能够在不重启的情况下实现更新。在这种需求下，自控软件的更新可能会有下面几个特点：</p><p>第一个特点：通常这些系统的更新都不是整体更新，而是支持一个个小模块的动态更新。</p><p>如果我们拿Java语言来打个比方，这相当于程序在运行的时候每次只更新一个类。从这个角度看，我们在课程里讲过的动态编译并形成可运行的模块的技术，就会派上用场了。但是静态编译并不能满足这个场景的要求，因为静态编译后的程序，在代码区里的内容通常是固定的、不能修改的。</p><p>第二个特点：在更新的时候，要满足实时性的需求。</p><p>在自控系统上，通常会有这样的场景：在10毫秒前的一次调用，可能使用的是前一个版本，在下一次调用，就已经无缝切换成了新版本。在这种情况下，程序之间不是静态链接在一起的。当我们要执行某个函数的时候，需要动态查询这个函数的地址，然后再跳转。在采用JIT技术的系统中，通常也会采用类似的技术。</p><p>第三个特点：在模块更新的时候，要能够保留程序中原来的状态信息。</p><p>自控软件在控制设备运行的时候，需要正确地掌握设备过去的状态。拿我们熟悉的场景来举个例子，如果你要升级红绿灯的控制软件，那么程序中的状态信息就要包括每个灯的状态是什么、已经持续了多久。</p><p>如果按照原来的规则，红灯要在5秒后转绿，那么软件升级后，必须仍然是在5秒后转绿，系统整体的运行逻辑才不受影响。否则的话，可能会出现路口两个方向都是绿灯的错误状态，从而引发交通事故。这种状态的错误，如果出现在电梯控制上、发电机组控制上，都会导致致命的后果。</p><p><strong>第四，自控系统对可靠性和安全性有着很高的要求。</strong></p><p>通过前面的描述，你应该已经体会到了，自控系统对于可靠性和安全性，有着很高的要求。我们可以想象一下，在未来的战争中，可能我们受到的第一波攻击并不是从天而降的导弹，而是来自网络的攻击。如果网络攻击就瘫痪掉来一个国家的高铁、核电、各种基础设施和工厂，那么战争也就根本不用打了。</p><p>可靠性和安全性要通过多个方面的工作来保证，包括管理角度、物理防护角度等等。落实到IT技术上，也会有多个层面的工作。比如，在操作系统层面，我们会进行可靠性方面的增强，尽量消除由于硬件的原因而产生的数据错误，比如网络传输中的数据错误、由于存储设备的原因导致的数据错误，等等。</p><p>从软件开发和运行的角度，在可靠性和安全性方面也有很多可以提升的地方。比如，传统的软件运行方式，代码段的地址都是固定的，所以就会比较容易导致攻击，比如内存溢出攻击。如果你的运行机制，让每个函数的代码地址都是随机的，那么就可能避开这种类型的攻击。</p><p>通过我们前面这些对自控程序的运行特征的分析，你会发现它确实跟我们普通的桌面软件、服务端软件、移动APP软件都不太相同。所以，针对这个领域，我们就需要专门的开发工具。那我们就看看这个领域的开发工具都有哪些特点。</p><h2>自控系统的开发平台</h2><p>由于自控领域自身的独特性，所以多年来这个领域也发展出了一系列独特的技术。这些技术被统称为OT，也就是Operational Technology。而你熟悉的互联网系统等，则属于IT领域。在OT领域，也形成了相应的国际组织和技术标准。在过去，这些组合和标准的话语权主要在国外一些企业的手中。</p><p>在OT领域，软件开发被叫做“组态”开发。组态是英文Configuration的意思。从字面上你可以这样理解，我们给控制器开发的软件，相当于是对控制器在做配置。</p><p>而这些控制器呢，在OT领域有个广为人知的名称，叫做PLC，也就是可编程控制器（Program Logic Controller）。那么我们可以怎么为可编程控制器编程呢？</p><p>根据相关国际标准（IEC 61131-3），如果我们要给PLC编程，可以使用5中不同的编程语言，如下图：</p><p><img src=\"https://static001.geekbang.org/resource/image/29/4e/29c82513c4d3d285c3a0b8624334214e.png?wh=1122x556\" alt=\"图片\"></p><p><strong>首先是文本化的编程语言。</strong>我们平常用的编程语言其实都是文本化的，这里面又细分为两种。一种是指令表，它相当于一种语法特别简单的计算机语言。虽然简单，但是对某些编程需求来说却足够。第二种是结构化的文本，这个跟普通的高级语言差不多，语法上有点像Pascal语言。</p><p>除了这两种文本化的编程语言以外，还有<strong>三种图形化编程语言，包括梯形图、功能块图和顺序功能流图</strong>。我相信，这几个图对大多数IT领域的同学来说，应该都不太熟悉。但对于弱电领域或OT领域的很多工程师来说，阅读这些图是他们的基本功。</p><p>通过这些图，他们就能很容易地理解程序的逻辑。其实在IT领域，一直也有图形化编程的方式，比如少儿编程领域，就可以通过拖拉图形块的方式来编程。而最近越来越为人所知的低代码开发平台，也大量采用了图形化编程的方式。</p><p>我这里给出了几张图，是对某个组态开发平台的截屏，可以帮助你更直观地理解这些编程语言。</p><p><img src=\"https://static001.geekbang.org/resource/image/01/87/01bd760c4a02e37746a1ec9de0506187.png?wh=1532x924\" alt=\"图片\"></p><p><img src=\"https://static001.geekbang.org/resource/image/a5/ac/a5291aa68cb8b09fe6549920ea32dfac.png?wh=1532x924\" alt=\"图片\"></p><p>那么，问题来了，你可以怎么来利用我们这门课学到的知识点，来实现上面这样一个开发平台呢？</p><p><strong>首先，针对这5种语言，无论是文本化的语言，还是图形化的语言，你都可以利用词法分析、语法分析和语义分析技术，形成统一的、正确的AST</strong>。</p><p><strong>第二，基于这个统一的AST，你再可以继续编译成机器码</strong>。我们在课程里讲过了如何针对x86-64架构的CPU生成汇编代码。不过呢，你要根据PLC所采用的芯片，来为它生成针对该芯片的汇编代码。一般芯片厂商都要提供工具链，能够把相应的汇编代码生成机器码。</p><p><strong>第三，我们要设计一个专门的运行时。</strong>在我们的课程中，我们已经实现过虚拟机，这就是一种运行时。不过，针对OT的需求，PLC的运行时要复杂一些，比如要能够实现软件模块的动态加载和更新的管理、代码地址的转换、状态信息的维护，还有与通讯模块和底层操作系统的衔接等工作。</p><p><strong>第四，我们要对程序进行优化。</strong>对于比较复杂的控制逻辑，我们要运用优化算法，提高程序的性能。程序的性能越高，可以满足的实时性要求就越高。像控制机器人臂这样的场景，对实时性要求就是很高的。如果我们不把代码进行充分优化，那就很难满足这些高实时性场景的要求。</p><p>所以，我们在课程的第三部分，会专门花时间学习优化技术。如果你能把优化技术也掌握透彻，那么你就有可能成为这个领域的顶级技术专家了。</p><p>通过上面的这些分析，你会发现，其实很多知识点，我们在前面的课程中都已经涉及了，还有一些知识点我们会在后面继续学习。所以，只要你认真掌握了我们这门课的内容，你基本上就可以胜任这些技术工作了！</p><h2>课程小结</h2><p>今天的加餐，我分享了自动控制领域的一些背景信息，也讨论了如何针对这个领域的需求来研发相应的组态软件平台。我写这篇加餐其实有几个目的：</p><p>第一，是开阔你的视野。你可能并不是OT领域的技术人员，以后也不会做OT有关的事情。但是，它山之石可以攻玉。OT和IT在发展过程中，一直在互相影响。比如，OT处理高可靠性的一些思路，就有可能用于高可靠的IT应用中。</p><p>第二，我希望你能理解我们这节课的知识点，是怎么用于解决具体领域的问题的。比如，你可能发现，我在这门课里特别重视让你理解程序的运行机制，包括程序跟CPU架构的关系、跟操作系统的关系、理解ABI等等。从今天的分享中你会看到，要解决一个特定领域的问题，特别是当你需要自己研发相关工具的时候，这些知识都很重要。</p><p>最后，我也希望通过今天这节课，能让工业领域之外的人也了解一点工业软件。毕竟，工业是我们国家的立身之本。而工业领域的基础软件，还有很多工作，需要有志之士参与进来，提升我们国家在这个领域的创新能力和话语权。</p><p>我在后面的加餐里，还准备给你分析一些其他的应用领域和开发工具。我们总说“学以致用”，了解更多的应用场景，也会有助于你理解和掌握我们这门课程的知识点。</p><h2>思考题</h2><p>如果你是来自于自控领域的，我想请你帮我补充一些信息，包括自控领域的其他应用场景、编程技术等等。</p><p>如果你来自其他领域，那么我想问问，你们的领域有没有跟自控领域类似的技术问题，以至于需要研发专门的开发平台呢？欢迎在留言区和我分享。</p><p>我是宫文学，我们下节课见。</p>","neighbors":{"left":{"article_title":"“他山之石”｜Sugar：这门课你可以试试这么学","id":424229},"right":{"article_title":"22｜增强编译器前端功能第1步：再识数据流分析技术","id":422442}}},{"article_id":422442,"article_title":"22｜增强编译器前端功能第1步：再识数据流分析技术","article_content":"<p>你好，我是宫文学。</p><p>到目前为止，实现一门计算机语言的流程，我已经带你完整地走了一遍：从编译器前端的技术，到AST解释器，再到字节码虚拟机，最后生成了汇编代码并编译成了可执行文件。在这个过程中，我们领略了沿途的风光，初步了解了实现一门计算机语言的各种关键技术。</p><p>可是，我们在第一部分起步篇里，都是顾着奋力攀爬，去开出一条路来。可是这条路实在有点窄，是条羊肠小道，现在我们就需要把它拓宽一下。也就是把我们PlayScript语言的特性增强一下，拓宽我们的知识面。</p><p>这个拓宽的方式呢，我选择的是围绕<strong>数据类型</strong>这条主线进行。这是因为，现代计算机语言的很多特性，都是借助类型体系来呈现的。</p><p>不知道你注意到没有，到目前为止，除了最早的AST解释器以外，我们的后几个运行机制都只支持整型。所以，我们要在第二部分进阶篇中让PlayScript支持浮点型、字符串和自定义对象等数据类型。做这些工作的目的，不仅仅是增加我们语言支持的数据类型，而且，随着你对字符串类型、和自定义对象等类型的学习，你也会对对象的处理能力，包括对象的属性、方法、对象内存的自动管理等知识有更深刻的理解。</p><p>为了降低工作量，我后面的课程主要实现的是实现静态编译的版本。因为这种运行机制涉及的知识点比较广，并且我的目标之一就是要<strong>实现一个高效的、静态编译的TypeScript版本，</strong>到这里我的目标也算达到了。如果你有兴趣，你也可以把字节码虚拟机版本扩展一下，用于支持对象特性等高级特性。</p><!-- [[[read_end]]] --><p>不过，在我们开启第二段征程之时，我们需要回到编译器的前端部分，把词法分析、语法分析和语义分析等功能都增强一下，以便支持后面的语法特性。在这个过程中，你会学习到前端的数据流分析技术、前端的优化技术和类型计算方面的知识点，让你的编译器前端的知识得到迭代提升。</p><p>那么，首先我们就来看看，我们语言在编译器前端功能方面的现状，找找增强这些功能的办法。</p><h2>编译器前端功能上的现状</h2><p>编译器的前端，也就是词法分析、语法分析和语义分析功能。我们逐个回顾一下，看看我们现在做到怎么样了。</p><p>首先来看我们的<strong>词法分析</strong>功能，跟语法分析和语义分析功能相比，它应该算是最完善的了。为什么这么说呢？因为我们目前的语言特性已经涉及到了大部分种类的Token，这些词法分析器都能提供。但相对来说，我们支持的语法规则还比较有限，所需要的语义分析功能也有很多缺失。不过，词法分析仍然有一些功能不够充分，比如<strong>数字字面量和字符串字面量等</strong>。</p><p>在数字字面量这边，我们目前虽然已经支持比较简单的整数和浮点数的字面量。但还有二进制、八进制和十六进制的数字、科学计数法表达的数字，我们都还没去支持。而且，字符串字面量上，我们也不支持Unicode和转义字符，并且字符串只能用双引号，还没使用单引号的版本。</p><p>接着，我们再来看<strong>语法分析</strong>功能。我们目前使用的都是一些比较高频的语法规则，<strong>忽略了一些比较低频的语法</strong>。比如，目前函数的参数只支持固定的参数数量，不支持变动数量的参数，也不支持参数的缺省值。再比如，我们目前的循环语句只支持for循环，并且不支持对集合的枚举，等等。</p><p>所以说，我们的词法分析和语法分析都还有不少功课需要去补呢。不过，我目前并不着急补这两方面。我的计划是，随着课程的推进，每当我们需要增加新特性的时候，就扩展一下这方面所需的词法和语法分析功能就好了。这样能够让你见证到像计算机语言这样的高难度软件一步步迭代成熟的过程，增强你自己驾驭类似的软件的信心。</p><p><strong>既然词法和语法分析功能都不是我们这节课的重点，那语义分析功能自然就是重点了。</strong></p><p>这是因为，实际上，在我们实现编译器的前端功能的时候，语义分析的工作量是最大的，但我们目前实现的功能确实有限。如果你有兴趣，可以参考我在<a href=\"http://time.geekbang.org/column/intro/100052801\">《编译原理实战课》</a>中对Java前端编译器的分析。在把编译工作分成的多个阶段中，大部分阶段都是去做语义分析相关的工作。</p><p>那我们现在的语义分析功能做到哪一步了呢？</p><p>在前面的课程中，我们已经实现了一些必要的语义分析功能，比如建立符号表、进行引用消解、分析哪个表达式是左值，以及进行简单的类型检查等等。不过这些功能其实还远远不够，因为还有很多潜在的语义错误没有被检查出来，因此需要我们逐步把这些工作补上。</p><p>在这个过程中，你会学习如何把数据流分析技术、类型计算技术用于语义分析工作。今天这节课，我们就先主要聚焦在数据流分析技术上。接下来，我们就举几个典型的场景，来学习如何在语义分析中使用数据流分析技术。</p><h2>场景一：代码活跃性分析之程序是否return了？</h2><p>我们在写函数的时候，如果这个函数需要返回值，那么在编译时，编译器会检查一下，是不是你所有的程序分支都以return语句结尾了。如果没有，编译器就会报错。我们举个例子：</p><pre><code class=\"language-plain\">function foo(a:number):number{\n    if (a &gt; 10){\n        let b:number = a+5;\n        return b;\n        b = a + 10; //这段代码不可到达。\n    }\n} \n</code></pre><p>你可以看一下，这段代码有什么问题呢？</p><p>首先，你会发现，这段代码里只有在if语句块有return语句。所以，当不满足if条件的时候，程序的执行流程就不会遇到这个return语句。那根据TypeScript的语义，此时的返回值是undefined。而函数的返回值类型里呢，又不包含undefined。所以这时，如果你用“tsc --strict example_return.ts”命令去编译它，tsc会报下面的错误：</p><p><img src=\"https://static001.geekbang.org/resource/image/2b/ec/2b4d8f55fb256a1359814d7031316eec.png?wh=1398x232\" alt=\"图片\"></p><p>当然，如果函数的前面是下面的样子，在返回值里包含undefined，那就是正确的。</p><pre><code class=\"language-plain\">function foo(a:number):number|undefined\n</code></pre><p>好，这是我们从示例代码中发现的第一个问题。那么第二个问题是什么呢？</p><p>你会看到，在return语句的下面还有一行代码“b = a + 10”，这一行代码其实是永远也不会被执行的。当然，这并不是一个错误，用tsc来编译也不会报错。但是，编译器或IDE工具最好要能够检查出这些问题，给程序员以提示。在编译生成代码的时候，编译器也可以直接把这些代码优化掉。</p><p>那如何检查出上面这些语义问题呢？那又需要用到<strong>数据流分析技术</strong>了。</p><p>到目前为止，我们已经多次接触到数据流分析技术了。在进行变量引用分析的时候，我们就曾实现过一个功能，检查出“变量是否在声明前就被引用”的错误。</p><p>它的处理逻辑是：语义分析程序遍历整个AST，相当于自上而下地分析每一条代码。当程序遇到变量声明节点的时候，就会标记该变量已经被声明了。而当程序遇到变量引用节点时，如果它发现该变量虽然属于某个作用域，但它当前还没有被声明，那么它就会报语义分析错误。具体的实现，你可以参考RefResolver类中的代码。</p><p><img src=\"https://static001.geekbang.org/resource/image/b8/2d/b88d7f2b46c63e7ff0aa71cb37c4902d.png?wh=946x322\" alt=\"图片\"></p><p>另外，在实现寄存器分配算法时，我们也曾经使用过数据流分析技术，来计算每个变量的生存期，从而确定多个变量如何共享寄存器。在那个时候，我们是在CFG上进行数据流分析的，并且分析方向是自下而上的顺序。</p><p>针对我们前面实操过的这两个例子，你可以总结出来数据流分析的几个特点：</p><p><strong>首先，数据流分析技术可以用在像AST和CFG等多种数据结构上</strong>，未来你还会见到我们把它用到其他的数据结构上；</p><p><strong>第二，针对不同的分析任务，数据流分析方向是不同的</strong>，有的是自上而下，有的是自下而上，你需要确定清楚；</p><p><strong>第三，数据流分析的过程，都会针对一个分析变量，并会不断改变这个变量的值。</strong>分析变量可能是一个单个的值，或者叫做标量，也可能是一组数值，比如向量和集合。在我们的前面的两个例子中，这个变量都是集合。第一个例子的分析变量是“已声明的变量的集合”，第二个例子的分析变量是“活跃变量集合”。</p><p><strong>第四，我们需要有一个规则或函数，基于这个规则来处理每行代码，从而计算新的变量值。</strong>比如，在变量活跃性分析中，这个规则是只要遇到变量使用的语句，就往集合里添加该变量，遇到变量声明的语句，就从集合中去掉该变量。</p><p><strong>第五，要确定变量的初始值</strong>。在第一个例子中，初始值是一个空集。在第二个例子中，每个基本块可能会有一个活跃变量的初始值，这些初始值是由CFG中的其他基本块决定的。</p><p><img src=\"https://static001.geekbang.org/resource/image/b4/32/b4065beb36c5yyf0f422b4772c397b32.jpg?wh=1920x1080\" alt=\"图片\"></p><p><strong>还有最后一个共性，它们都有交汇函数</strong>。交汇函数是用来在多个控制流交汇的时候，计算出交汇的值。在第二个例子中，当两个基本块交汇的时候，活跃变量集合是取两个集合的并集。</p><p><img src=\"https://static001.geekbang.org/resource/image/d9/53/d947a156d103ffa007c610625a2e4d53.jpg?wh=1920x1080\" alt=\"图片\"></p><p>好了，上面这些就是数据流分析技术的核心特点。抓住这些核心特点，我们可以把这个技术用于更多的场景。比如说，我们就可以用这些特性解决上面这个程序是否正确return的问题。</p><p>在开始解决这个问题之前，我们先来梳理一个分析框架，看看我们具体要从哪些方面着手。</p><p>我们可以把一个程序在执行过程中是否遇到了return语句，用一个变量来描述，就是当前执行流程是不是alive的。我们从程序的开头，一行行代码的往下分析。在一开始，alive的初始值是true。当遇到return语句以后，alive就变成了false。</p><p><img src=\"https://static001.geekbang.org/resource/image/9e/f0/9e5dbae671a5ee722ba713ab6a3c67f0.png?wh=770x330\" alt=\"图片\"></p><p>对于分支语句，比如if分支语句，则需要每个分支都要遇到一个return语句。如果一个分支的alive值是alive1，另一个分支的alive值是alive2，那么合起来的alive值是什么呢？是alive1 || alive2。也就是说，必须每个分支都遇到return语句后，总的alive才是false。这就是我们的交汇函数。</p><p>现在你应该就明白了，我们这次的数据流分析框架中需要具备这几个关键要素：</p><ul>\n<li>变量：alive，代表代码是否是活的，也就是是否遇到了return。</li>\n<li>初始值：true；</li>\n<li>变换函数：当遇到return的时候，alive变为false;</li>\n<li>交汇函数：逻辑或运算；</li>\n<li>分析方向：自上向下。</li>\n</ul><p>具体怎么来解决这个问题呢？你可以参考<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/22/semantic.ts#L898\">LiveAnalyzer</a>的代码。我也把几段有代表性的代码放在了文稿里。</p><p><strong>第一段代码，是对语句块的分析。</strong>在语句块中，编译器按自上向下的顺序检查每条语句。如果遇到return，就把alive改成false。对于return后面的语句，则作为“死代码”检测了出来。甚至，我们还可以修改AST，直接把死代码从程序中去掉。这也是一种优化技术，名字就叫做“死代码消除”。</p><p>当然，死代码不仅仅指return之后的语句，有些return之前的语句可能也是死代码，是执行和不执行都没有影响的。如果你想了解这些，可以额外找些资料，也可以在留言区和我交流一下。</p><pre><code class=\"language-plain\">visitBlock(block:Block):any{\n    let alive:boolean = true;\n    let deadCodes:Statement[] = []; //死代码\n    for (let stmt of block.stmts){\n        if (alive){\n            alive = this.visit(stmt) as boolean;\n        }\n        //return语句之后的语句，都是死代码。\n        else{ \n            //作为Warning，而不是错误。\n            this.addWarning(\"Unreachable code detected.\",stmt);\n            deadCodes.push(stmt);\n        }        \n    }\n\n    //去除死代码\n    for (let stmt of deadCodes){\n        let index = block.stmts.indexOf(stmt);\n        block.stmts.splice(index,1);\n    }\n    return alive;\n}\n</code></pre><p><strong>第二段代码，是对If分支语句的分析</strong>。核心代码是3句，体现了多个分支的交汇逻辑。也就是说，只有两个分支都是false的情况下，总的计算结果才是false。</p><pre><code class=\"language-plain\">let alive1 = this.visit(ifStmt.stmt) as boolean;\nlet alive2 = ifStmt.elseStmt == null ? true : (this.visit(ifStmt.elseStmt) as boolean);\nalive = alive1 || alive2;  //只有两个分支都是false，才返回false；\n</code></pre><p>你可以用node play example_return.ts命令，编译一下试一试。我们的编译器就会报一个Error和一个Warning，你可以看一下截屏。</p><p><img src=\"https://static001.geekbang.org/resource/image/6c/c0/6c83c07217f4b241635babcce342c5c0.png?wh=1354x224\" alt=\"图片\"></p><p>好了，现在我们已经解决了与return有关的分析工作了。那还有没有别的场景可以发挥数据流分析技术的威力呢？</p><p>有的。我们再来做一个变量赋值的分析看看。</p><h2>场景二：变量赋值分析</h2><p>什么是变量赋值的分析呢？我们看下面这个例子。</p><pre><code class=\"language-plain\">function foo(a:number):number{\n    let b:number;\n    let c = a+b;\n    if (a &gt; 10){\n        b = 1;\n    }\n    // else{\n    //     b = 2;\n    // }\n    let d = a-b; //如果前面加上else部分，那么b就是被赋值的。\n    return c+d;\n}\n</code></pre><p>在这个示例程序中，我们在第一个行声明了一个变量b，但并没有给它赋值。接着，在第二个语句中，我们引用了b。另外，在if语句之后，let d = a-b语句也引用了变量b。</p><p>你如果运行命令tsc --strict example_assign.ts，那么tsc编译器会报错：“Variable ‘b’ is used before being assigned.”。</p><p><img src=\"https://static001.geekbang.org/resource/image/f8/7c/f8e2e163a2c9d4e742018230e0f03b7c.png?wh=1360x554\" alt=\"图片\"></p><p>相信你看完这个例子就明白了，变量赋值分析要解决的就是变量被赋值之前就已经被使用的问题。这个问题也适合用数据流分析技术来解决，因为我们只要顺序查找对变量进行赋值和使用的代码，就能知道是否存在错误了。</p><p><strong>那么，我们该如何套用前面说过的数据流分析框架，来解决赋值分析问题呢？</strong></p><hr><p>首先是<strong>分析变量</strong>。这里分析变量就是在每一条语句那里，每个变量是不是肯定被赋值了。我们可以用一个Map来记录每个变量的赋值状态。</p><pre><code class=\"language-plain\">assigned:Map&lt;VariableSym,boolean&gt; = new Map();\n</code></pre><p>第二，<strong>初始值</strong>。在一开始，每个变量都没有被赋值。</p><p>第三，<strong>变换函数</strong>。我们每次遇到给一个变量赋值语句或者变量初始化语句，都就可以改变该变量的赋值状态。</p><p>第四，<strong>交汇函数</strong>。在遇到分支的时候，我们必须保证每个分支都给这个变量赋值了，那么这个变量才肯定赋值了。</p><p>第五，<strong>分析方向。</strong>程序自上向下进行分析。</p><p>具体实现你可以参见<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/22/semantic.ts#L753\">AssignAnalyzer</a>。这个程序比前一个要稍微复杂一点，我在这里也给你标出了一些核心步骤。</p><p>首先，我们要一次记录多个变量是否被赋值的信息，我这里用了一个map。</p><pre><code class=\"language-plain\">//每个变量的赋值情况\nassignMode:Map&lt;VarSymbol, boolean&gt; = new Map();\n</code></pre><p>接着，要在变量声明的时候，我们把变量加到这个map里。如果变量在声明时就被初始化了，那么记录它的赋值状态为true。如果通过单独的赋值语句被赋值，赋值状态也会被改成true。</p><pre><code class=\"language-plain\">//变量声明中可能会初始化变量\nvisitVariableDecl(variableDecl: VariableDecl):any{\n    if (variableDecl.init != null) this.visit(variableDecl.init);\n    //如果有初始化部分，那么assigned就设置为true\n    this.assignMode.set(variableDecl.sym as VarSymbol, variableDecl.init != null);\n}\n\n//处理赋值语句\nvisitBinary(binary:Binary):any{\n    if (Operators.isAssignOp(binary.op)){\n        this.visit(binary.exp2); //表达式右侧要照常遍历，但左侧就没有必要了。\n        if (typeof (binary.exp1 as Variable).sym == 'object'){\n            let varSym = (binary.exp1 as Variable).sym as VarSymbol;\n            this.assignMode.set(varSym, true);\n        }\n    }\n    else{\n        super.visitBinary(binary);\n    }\n}\n</code></pre><p>接着，你要在变量被引用的地方，基于该map检查该变量是否被初始化了。</p><pre><code class=\"language-plain\">//变量声明中可能会初始化变量\nvisitVariable(variable: Variable):any{\n    let varSym = variable.sym as VarSymbol;\n    if (this.assignMode.has(varSym)){\n        let assigned = this.assignMode.get(varSym) as boolean;\n        if (!assigned){\n            this.addError(\"variable '\" + variable.name + \"' is used before being assigned.\", variable);\n        }\n    }\n    else{\n        console.log(\"whoops,不可能到这里@semantic.ts/visitVariable\");\n    }\n}\n</code></pre><p>再然后，我们仍然要处理流程分枝的情况。这个时候，要针对每个分枝计算一个assignMode对象，然后合并每个分枝的结果。</p><pre><code class=\"language-plain\">visitIfStatement(ifStmt:IfStatement):any{\n    //算法：把assignMode克隆两份，分别代表遍历左支和右支的结果，然后做交汇运算\n    let oldMode = this.cloneMap(this.assignMode);\n    //遍历if块\n    this.visit(ifStmt.stmt);\n    let mode1 = this.assignMode;\n    //遍历else块\n    this.assignMode = this.cloneMap(oldMode);\n    if (ifStmt.elseStmt != null) this.visit(ifStmt.elseStmt);\n    let mode2 = this.assignMode;\n    //交汇运算\n    this.assignMode = this.merge(mode1, mode2);        \n}\n</code></pre><p>最后一个细节，是要忽略死代码。如果变量是在死代码里被赋值的，那仍然不算数，因为实际的控制流并不会到达这里。</p><pre><code class=\"language-plain\">//略过死代码\nvisitBlock(block:Block):any{\n    for (let stmt of block.stmts){\n        let alive = this.visit(stmt) as boolean;\n        if(typeof alive == 'boolean'){\n            //如果遇到return语句，后面的就是死代码了，必须忽略掉。\n            return;\n        }     \n    }\n}\n\n//检测return语句\nvisitReturnStatement(rtnStmt: ReturnStatement):any{\n    if(rtnStmt.exp != null)  this.visit(rtnStmt.exp);\n    return false;  //表示代码活跃性为false\n}\n</code></pre><h2>课程小结</h2><p>好了，今天的内容就是这些。我带你回顾一下本节的重点：</p><p>首先，我们回顾了一下PlayScript当前的编译器前端功能的现状。词法分析和语法分析这两部分的功能呢，目前基本够用。如果增加新的语言特性，那我们就迭代增加就好了。而语义分析功能呢，我们却必须要做一些额外的补充，来检查出程序中的一些错误。</p><p>第二，在补充语义分析功能的过程中，我们这节课重点使用了数据流分析方法。我们之前就提过数据流分析方法很有用，相信你在这节课里也体会到了。每次采用数据流分析方法的时候，你都要识别出五个关键的要素：变量、变量的初始值、变换函数、交汇函数和分析方向。只要你识别出这五个要素，那么编程实现就比较简单了。</p><p>第三，我们今天进行了代码活跃性分析和赋值分析。代码活跃性分析能够分析出程序的控制流是否都匹配了return语句，还能分析出一些死代码，并进行优化。赋值分析能够分析出变量是否在赋值之前就被使用的错误。</p><p>下一节课，我们还会介绍另一个重要的技术，就是<strong>类型计算</strong>，这会进一步增强我们PlayScript的语义分析功能。</p><h2>思考题</h2><p>我们今天提到，语义分析的功能是有很多的。你能否说一说，到目前为止，我们还欠缺哪些语义分析功能呢？欢迎在留言区和我分享。</p><p>欢迎你把这门课分享给更多对语义分析感兴趣的朋友。我是宫文学，我们下节课见。</p><h2>资源链接</h2><p><a href=\"https://gitee.com/richard-gong/craft-a-language/tree/master/22\">这节课的示例代码在这里！</a></p>","neighbors":{"left":{"article_title":"“屠龙之秘”｜实现计算机语言这样的技术能用在哪里？（一）","id":424365},"right":{"article_title":"23｜增强编译器前端功能第2步：增强类型体系","id":423049}}},{"article_id":423049,"article_title":"23｜增强编译器前端功能第2步：增强类型体系","article_content":"<p>你好，我是宫文学。</p><p>你可能也注意到了，我们在第二部分的主要任务，是要让PlayScript扩展到支持更多的类型。在这个任务中，对类型的处理能力就是一个很重要的功能。</p><p>其实在第一部分，我们已经实现了一定的类型处理功能，包括类型检查、类型自动推断等，但其实还有更多的类型处理能力需要支持。</p><p>对于一门语言来说，类型系统是它的核心。语言之间的差别很多时候都体现在类型系统的设计上，程序员们通常也会对类型处理的内部机制很感兴趣。而TypeScript比JavaScript语言增强的部分，恰恰就是一个强大而又灵活的类型系统，所以我们就更有必要讨论一下与类型有关的话题了。</p><p>那么通过今天这节课，我们就来增强一下PlayScript的类型处理能力，在这过程中，我们也能学习到更多与类型系统有关的知识点，特别是能对类型计算的数学实质有所认知。</p><p>首先，我们来看看TypeScript的类型系统有什么特点。</p><h2>TypeScript的类型系统</h2><p>从TypeScript的名字上，你就可以看出来，这门语言在类型系统的设计上，一定是下了功夫的。也确实是这样，TypeScript在设计之初，就想弥补JavaScript弱类型、动态类型所带来的缺点。特别是，当程序规模变大的时候，弱类型、动态类型很容易不经意地引入一些错误，而且还比较难以发现。</p><!-- [[[read_end]]] --><p>所以TypeScript的设计者，希望通过提供一个强类型体系，让编译器能够检查出程序中潜在的错误，这也有助于IDE工具提供更友好的特性，比如准确提示类的属性和方法，从而帮助程序员编写更高质量的程序。</p><p>而TypeScript也确实实现了这个设计目标。它的类型系统功能很强大，表达能力很强，既有利于提高程序的正确性，同时又没有削弱程序员自由表达各种设计思想的能力。</p><p>那么我们现在就来看一看TypeScript的类型系统到底有什么特点。</p><p><strong>首先，TypeScript继承了JavaScript的几个预定义的类型，比如number、string和boolean等。</strong></p><p>在JavaScript中，我们不需要声明类型，比如下面两句代码就是。在程序运行的时候，系统会自动给age和name1分别关联一个number和string类型的值。</p><pre><code class=\"language-plain\">var age = 18;\nvar name1 = \"richard\";\n</code></pre><p>而在TypeScript中呢，你需要用let关键字来声明变量。在下面的示例程序中，age和number被我们用let关键字分别赋予了number和string类型。</p><pre><code class=\"language-plain\">let age = 18;\nlet name1 = \"richard\";\n</code></pre><p>这两行代码里的类型是被推导出来的，它们跟显式声明类型的方式是等价的。</p><pre><code class=\"language-plain\">let age:number = 18;\nlet name1:string = \"richard\";\n</code></pre><p><strong>第二，TypeScript禁止了变量类型的动态修改。</strong></p><p>在JavaScript中，我们可以动态地修改变量的类型。比如在下面两行代码中，age一开头是number型的，后来被改成了string型，也是允许的：</p><pre><code class=\"language-plain\">var age = 18;\nage = \"eighteen\";\n</code></pre><p>但在TypeScript中，如果你一开头给age赋一个number的值，后面再赋一个string类型的值，编译器就会报错：</p><pre><code class=\"language-plain\">let age = 18;\nage = \"eighteen\";  //错误！\n</code></pre><p>这是因为，上面的第一行代码等价于显式声明age为number类型，因为TypeScript会根据变量初始化的部分，来推断出age的类型。而这个类型一旦确定，后面就不允许再修改了。</p><pre><code class=\"language-plain\">let age:number = 18;\nage = \"eighteen\";\n</code></pre><p>不过，如果完全不允许类型动态变化，可能会失去JavaScript灵活性这个优点，会让某些程序员觉得用起来不舒服。所以，TypeScript还留了一个口子，就是any类型。</p><p><strong>第三，只有any类型允许动态修改变量的类型。</strong></p><p>在TypeScript中，如果你声明变量的时候不指定任何类型，或者显式地指定变量类型为any，那变量的类型都是any，程序也就可以动态地修改变量的类型，我们可以看看下面这个例子：</p><pre><code class=\"language-plain\">let age;  //等价于 let age:any;\nage = 18;\nconsole.log(typeof age);\nage = \"eighteen\";\nconsole.log(typeof age);\n</code></pre><p>如果我们编译并运行这个示例程序，我们会得到这样的结果：</p><p><img src=\"https://static001.geekbang.org/resource/image/54/7c/54735aefecfe35af1b01ae9eca70407c.png?wh=650x148\" alt=\"图片\"></p><p>你会看到，在我们第二次给age赋值的时候，age的类型真的被改变了。</p><p><strong>第四，TypeScript支持联合类型。</strong></p><p>你在使用TypeScript编程的时候，应该会很快注意到它的联合类型的特性。比如，在下面这个例子中，value的类型可以是number或string，那你给value赋这两种类型的值都是可以的。当然，如果你给value赋一个boolean值，那仍然是错误的，因为联合类型中不包含boolean类型。</p><pre><code class=\"language-plain\">let value:number|string;\nvalue = 18;        //OK\nvalue = \"richard\"; //也OK\nvalue = true;      //错误！\n</code></pre><p><strong>第五，TypeScript支持把值作为类型。</strong></p><p>什么意思呢？我们依然来看一个例子。你看，在下面的语句中，我们可以让name1取值为string或者null。这在编程中很方便，特别是在声明对象属性的时候。因为我们可能一开始不知道名称是什么，我们就可以先让它的值为null。之后，等知道了名称以后，我们再给name1赋予正式的值就好了。</p><pre><code class=\"language-plain\">var name1;\nname1 = null;\nconsole.log(typeof name1);  //输出：object\nname1 = \"richard\";\nconsole.log(typeof name1);  //输出：string\n</code></pre><p>不过，这个null并不是类型，而是一个值，它实际的类型是对象（object），你可以看看示例程序运行的结果来验证一下，我这里也放了张截图：</p><p><img src=\"https://static001.geekbang.org/resource/image/0f/b3/0f537c2a5c252c5f897b46250c4fe9b3.png?wh=650x148\" alt=\"图片\"></p><p>除了在联合类型里使用值，你甚至还可以用一个单独的值作为类型注解。比如在下面的示例程序中，value2只能取0值。这可能在实际编程中没有太大的用，因为value2相当于是一个常量，而不是变量。我们更可能像value1那样，规定合法的取值是多个值中的一个。</p><pre><code class=\"language-plain\">let value1 : 0|1;\nlet value2 : 0;\nvalue1 = 0;   //OK\nvalue1 = 2;   //错误！\nvalue2 = 2;   //错误！\n</code></pre><p>其实，TypeScript的类型系统还有更多丰富的特性，比如数组类型、交集类型（Intersection Type）、通过class和interface实现自定义的类型、泛型等等，非常强大。不过我们还是按照循序渐进的原则，先从比较简单的特性入手，然后逐步深化。</p><p>所以，我们就先聚焦在前面提到的几点特性上。特别是<strong>联合类型</strong>和<strong>值类型</strong>，这都是我们之前没有实现过的，我们就先来实现一下。在这个过程中，我们就能先小小体会一下TypeScript类型系统到底有多强大。</p><p>那么现在，我们首先针对联合类型、值类型，来升级我们对类型的支持能力。</p><h2>支持联合类型和值类型</h2><p>在目前的语法解析器中，我们对类型的解析很简单。比如像“let a : number;”这样一个简单的语句，我们只要把number作为一个关键字提取出来，然后再转换成一个代表number类型的内部对象就可以了。所以，我们语法解析器中与变量声明有关的语法规则是很简单的，我总结了下写在了下面：</p><pre><code class=\"language-plain\">variableDecl : Identifier typeAnnotation？ ('=' expression)? ;\ntypeAnnotation : ':' typeName;\ntypename : 'number' | 'boolean' | 'string' | 'any' | 'void' ;\n</code></pre><p>不过，我们在课程里已经很久没有写过语法规则了，不知道你还能不能重拾对它们的记忆呢？我帮你简单解释一下这三条规则。</p><ul>\n<li>变量声明(variableDecl)：在变量声明里，标识符后面可以跟一个可选的类型注解；</li>\n<li>类型注解(typeAnnotation)：类型注解以“:”号开头，后面跟一个类型名称。</li>\n<li>类型名称(typeName)：类型名称可以是number、boolean、string、any或void这几个值之一，这也是目前PlayScript所能识别的少量类型。</li>\n</ul><p>但是，我们现在对我们的要求可不一样了。我们现在需要PlayScript支持联合类型和值类型，并且后面还要支持更复杂的类型体系，那我们现在就必须扩展一下我们语言中针对类型的语法规则了。</p><p>新的语法规则我放在了下面，你可以阅读一下，看看能不能读懂它们的含义：</p><pre><code class=\"language-plain\">typeAnnotation : ':' type_;\ntype_ : unionOrIntersectionOrPrimaryType ;\nunionOrIntersectionOrPrimaryType : primaryType ('|' | '&amp;' primaryType)* ;\nprimaryType : predefinedType | literal | typeReference | '(' type_ ')' | primaryType '[' ']' ;\npredefinedType : 'number' | 'string' | 'boolean' | 'any' | 'void' ;\n</code></pre><p>你可以看到，这个新的规则有一些不同。</p><p>首先，我们的类型注解(typeAnnotation)有了变化，现在改成了“:”号后面跟着类型（type_）;</p><p>然后，我们在看类型（type_），类型可以有多种，但目前我们的语法规则里只有unionOrIntersectionOrPrimaryType这一类，以后还可以拓展。</p><p>第三个，unionOrIntersectionOrPrimaryType：它的字面意思是联合类型、交集类型或基础类型。从规则中你可以看到，联合类型是由一个个基础类型用“|”号连接在一起的。交集类型与联合类型相似，差别在于它使用“&amp;”号来连接基础类型的。当然，交集类型目前我们还用不到，但我们先在语法规则中预留下它的位置。</p><p>第四个不同点在于基础类型（primaryType），基础类型包括预定义的类型、字面量、类型引用、被括号括起来的类型，以及数组类型。目前我们只会用到前两个，预定义的类型就是之前的number、string这些。而字面量包括数字字面量、字符串字面量、布尔字面量等，它们在解析后会形成我们前面提到的值类型。</p><p><strong>好了，现在我们已经把与类型有关的语法规则写好了。接下来，就要升级一下解析器，让它能够支持这些新的语法规则。</strong></p><p>根据我们之前学习过的语法分析的知识，其实你只要写出来了语法规则，照着规则来实现语法分析程序并不难。你可以看一下parseType、parseUnionOrIntersectionOrPrimaryType、parsePrimTypeExp这几个方法。</p><p>不过呢，语法解析的结果，是要形成AST，所以我们这里还必须<strong>增加一些AST节点</strong>，来代表解析出来的这些类型信息。</p><p>与类型有关的AST节点，我也画成了类图，并放在了下面。这里面包括TypeExp、PrimTypeExp、PredefinedTypeExp、LiteralTypeExp和UnionOrIntersectionTypeExp等节点，并且它们之间还有继承和引用的关系。</p><p><img src=\"https://static001.geekbang.org/resource/image/52/54/52e99c1df620e450d6705dc9046d4654.jpg?wh=1920x1080\" alt=\"\"></p><p>不过，课程上到这里，在谈到AST节点设计的时候，我觉得有必要插一个小知识点，也就是关于AST和CST的区别。</p><p>这里出现了一个新的缩略词CST。CST是Concrete Syntax Tree的缩写，意思是具体语法树。从这个名称，你就能看出来，它跟AST，也就是抽象语法树（Abstract Sytax Tree）是相对的。那么它们有什么差别呢？</p><p>你可能已经注意到了，我在课程里所设计的AST节点，并不是跟语法规则的名称完全一样的，所形成的语法树也跟解析的过程不完全一致。以解析表达式2+(3+4)为例，如果忠实地按照解析的过程来形成语法树，跟现在的语法树会有很大的不同：</p><p><img src=\"https://static001.geekbang.org/resource/image/e5/34/e5fe34f8bc337b7da2353528a6e38634.png?wh=904x1274\" alt=\"图片\"></p><p>你能看出来，相比AST，CST更加忠实地体现了源代码的结构。比如，它没有丢掉源代码中的任何一个Token，包括+号和圆括号，这样可以把AST和源代码精准地对应起来，这也能更友好地显示一些错误信息。比如，你可以在IDE里标出某个括号用错了。CST作为对解析过程和源代码的忠实体现，它也被称作解析树（Parse Tree）。</p><p>而在AST里，更多体现的源代码的内在含义，而不是去纠结有没有跟源代码一一对应上。如果我们把它们两种翻译比作英语翻译的话，AST是意译，而CST是直译。不过AST的特点也很明显。一方面它更简洁，另一方面AST节点的对象设计更容易体现程序的内在含义。</p><p>在实际使用中呢，有的编译器会先生成CST，再基于CST生成AST。但这样显然会增加编译过程的计算量，降低编译器的性能。所以，大部分编译器都是直接生成AST。不过，如果你写的编译器主要是用于支持IDE工具，那么CST可能会发挥更大的作用，因为它跟源代码的直接对应能力更强。</p><p>好，回到我们的主线上来。现在你应该明白了，为什么我们关于类型的AST节点不是跟语法规则直接对应的了。这样的设计会更有利于对类型进行进一步的处理。</p><p>不过到这还没有完。我们刚才设计的只是有关类型的AST节点的对象结构。但是我们在程序内部保存类型信息的时候，是不可能去保存一些AST节点的，还需要<strong>一套对象结构</strong>来表示类型。我也画出了相应的类图，你可以看一下。<br>\n<img src=\"https://static001.geekbang.org/resource/image/02/b0/023053f35e4cc04233611a202af69bb0.jpg?wh=1920x1080\" alt=\"\"></p><p>在这里，我们把Type作为各种类型的基类，这下面有NamedType、ValueType、FunctionType、UnionType等等类型。另外，我还设计了一个SysTypes类，里面存放了预定义的一些类型的实例，比如Boolean、Number、String、Any和Void都是NamedType的实例，而Null、Undefined是值类型的实例。</p><p>设计完表达类型的对象结构以后，我们还要<strong>基于AST解析出类型信息</strong>来。针对这个功能，我写了一个语义分析程序，叫做TypeResolver。它能够把与类型有关的AST节点，转化成类型对象。这个TypeResolver程序，我们还会不断地演化，让它能够处理更复杂的类型。特别是在我们后面实现了自定义类型的时候，类型的消解算法还会变得比现在复杂一些。</p><p>好了，现在类型信息也能够被正确地消解了。换句话说，现在我们的程序，已经能够正确解析带有联合类型和值类型的程序了。</p><p>我们现在就动手试试看，我这里给了一个示例程序：</p><pre><code class=\"language-plain\">let age : string|number;\nlet name1 : string|null;\n</code></pre><p>你可以用node play example.ts -v命令，显示出解析后的AST。你会看到AST里面已经体现了与类型有关的AST节点信息，以及类型消解后的结果。</p><p><img src=\"https://static001.geekbang.org/resource/image/9a/d1/9aa7cb1e6335927733a009cc21159bd1.png?wh=782x516\" alt=\"图片\"></p><p>但是还差一点，如果我们要给示例程序中的变量赋值，那么我们还必须升级类型检查的算法，来支持新的联合类型和值类型。</p><h2>升级类型检查功能</h2><p>我们都知道，在给变量赋值的时候，我们必须要进行类型的检查。我们之前也介绍过类型检查功能。不过，这节课我想带你从不同的视角来认识类型检查，这会涉及我们之前提到过的类型计算技术。</p><p>在这节课，当我们介绍TypeScript的类型体系的时候，你可能或多或少会有一种感觉：<strong>怎么TypeScript的类型有点像集合呀？</strong>没错！你看，联合类型就是多个类型的合集。我们还隐约提到了交集类型，而交集显然也是对集合的一种运算。</p><p>是的，集合这种数学方法，可以非常好地用于表达类型的计算。你可以这么想，什么是类型呢？类型就是一组值的集合。比如，number类型就是所有数字的集合，string类型就是所有字符串的集合。当然，我们也可以做个更大的集合，同时包含number和string，这就形成了一个新类型；你也可以做一个更小的集合，比如只包含几个数字，这也是一个新类型。</p><p>那么从集合运算的角度看，什么是类型检查呢？</p><p>类型检查的规则，就是给变量所赋的值，一定要属于变量的类型所对应的集合。对于“let a : number = 1; ”这个语句来说，显然1属于number的集合，所以是合法的。而对于“let a  : 0 | 1 = 1”来说，1也属于集合{0,1}，因此也是合法的。</p><p>所以，我们升级的类型检查算法，就用到了集合运算。了解了原理以后，你就可以再去看看<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/23/semantic.ts#L521\">TypeChecker</a>和<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/23/types.ts#L7\">Type</a>类中的实现，应该就比较容易看懂了。</p><p>不过，类型检查只是类型计算技术的一个体现。在下一节课里，我们还会结合前一节课的数据流分析技术和这节课的类型计算技术，实现更多有趣的特性，比如实现null安全性，你也可以先简单预习一下相关的知识。</p><h2>课程小结</h2><p>这节课到这里就讲完了，今天我希望你能够记住下面这几个知识点：</p><p>首先，我们学习了TypeScript类型体系的部分特征。TypeScript能够通过显式的方式来声明类型。除了any类型之外，TypeScript变量的类型都是不能动态改变的。在基础类型之上，TypeScript还支持值类型和联合类型。</p><p>第二，在升级TypeScript与类型相关的语法规则的时候，我们设计了一些新的代表AST节点的类。在这里，我们穿插介绍了CST的概念。与AST相比，CST更加忠实地反映源代码的结构、语法规则和解析过程，能够对IDE工具有更好的支持。但它也有缺点，就是树的结构更大，在后序处理时会更加繁琐。</p><p>第三，在升级类型检查功能的时候，我们介绍了类型计算所采用的数学方法，也就是集合计算。在程序里把变量a的值赋给变量b，就是要求类型a的集合是类型b的集合的子集。你可以试着以集合的思维去重新解读，你以前了解的与类型有关的知识，比如类的继承关系，相信会给你带来崭新的视角。</p><h2>思考题</h2><p>在你熟悉的其他语言中，有类似TypeScript的联合类型和值类型的特性吗？或者，它们跟TypeScript的特性有什么差别呢？欢迎你在留言区分享观点。</p><p>欢迎你把这节课分享给更多感兴趣的朋友。我是宫文学，我们下节课见。</p><h2>资源链接</h2><p>1.<a href=\"https://gitee.com/richard-gong/craft-a-language/tree/master/23\">这节课示例代码目录</a></p><p>2.与类型有关的<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/23/ast.ts#L402\">AST节点</a></p><p>3.<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/23/types.ts\">类型对象</a></p><p>4.这节课的测试程序<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/23/example_type.ts\">example_type.ts</a></p>","neighbors":{"left":{"article_title":"22｜增强编译器前端功能第1步：再识数据流分析技术","id":422442},"right":{"article_title":"24｜增强编译器前端功能第3步：全面的集合运算","id":424592}}},{"article_id":424592,"article_title":"24｜增强编译器前端功能第3步：全面的集合运算","article_content":"<p>你好，我是宫文学。</p><p>在上一节课，我们扩展了我们语言的类型体系，还测试了几个简单的例子。从中，我们已经能体会出一些TypeScript类型体系的特点了。</p><p>不过，TypeScript的类型体系其实比我们前面测试的还要强大得多，能够在多种场景下进行复杂的类型处理。</p><p>今天这节课，我们会通过多个实际的例子，来探索TypeScript的类型处理能力。并且，在这个过程中，你还会进一步印证我们上一节课的一个知识点，就是<strong>类型计算实际上就是集合运算</strong>。在我们今天的这些例子中，你会见到多种集合运算，包括子集判断、重叠判断，以及交集、并集和补集的计算。</p><p>首先，让我们看几个例子，来理解一下类型计算的使用场景。</p><h2>类型计算的场景</h2><p>我们先看第一个例子：</p><pre><code class=\"language-plain\">function foo1(age : number|null){\n    let age1 : string|number;\n    age1 = age;   //编译器在这里会检查出错误。\n    console.log(age1);\n}\n</code></pre><p>在这个例子中，我们用到了age和age1两个变量，它们都采用了联合类型。一个是number|null，一个是string|number。</p><p>如果你用–strict选项来编译这个程序，那么tsc会报错：</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/cc/24/cc57e718200cf6c9416fa2c89ca47424.png?wh=1382x368\" alt=\"图片\"></p><p>这个错误信息的意思是：类型number|null不能赋给类型string|number。具体来说，null是不能赋给string|number的。</p><p>这说明什么呢？这说明对于赋值语句，比如x = y来说，它会有一个默认要求，要求y的类型要么跟x一样，要么是x的子集才可以。我们把这个关系记做y.type &lt;= x.type。</p><p>那么，其他的二元运算，是不是也像赋值运算那样，需要一个类型是另一个类型的子集呢？</p><p>不是的。不同的运算，做类型检查的规则是不同的。比如，对于“==”和“!=”这两个运算符，只需要两个类型有交集就可以。你可以用tsc编译一下这个例子：</p><pre><code class=\"language-plain\">function foo2(age1 : number|null, age2:string|number){\n    if (age1 == age2){     //OK。只要两个类型有交集就可以。\n        console.log(\"same age!\");\n    }\n}\n</code></pre><p>你会看到，编译器并不会报错。这说明，两个不同的类型，只要它们有交集，就可以进行等值和不等值比较。并且，即使age1的值是null，age2的值是一个字符串，等值比较仍然是有意义的，比较的结果是不相等。</p><p>那如果两个类型没有交集，会发生什么情况呢？我们看看下面的例子，参数x和y属于不同的类型，它们之间没有交集。</p><pre><code class=\"language-plain\">function foo3(x : number|null, y:string|boolean){\n    if (x == y){   //编译器报错：两个类型没有交集\n        console.log(\"x and y is the same\");\n    }\n}\n</code></pre><p>这次，如果你用tsc去编译，即使不加–strict选项，编译器也会报错：</p><p><img src=\"https://static001.geekbang.org/resource/image/c2/34/c2d10ddc726929d1c67ee389bd251f34.png?wh=1382x336\" alt=\"图片\"></p><p>编译器会说，这个条件表达式会永远返回false，因为这两个类型没有交集。</p><p><strong>到此为止，我们就了解清楚等值比较的规则了，也就是要求两个类型有交集才可以，或者说两个类型要存在重叠。</strong></p><p>那其他的比较运算符，比如&gt;，&gt;=，&lt;，&lt;=，也遵循相同的规则吗？</p><p>我们把foo2中的==运算符改为&gt;=运算符，得到一个新的示例程序：</p><pre><code class=\"language-plain\">function foo4(age1 : number|null, age2:string|number){\n    if (age1 &gt;= age2){  //编译器报错\n        console.log(\"bigger age!\");\n    }\n}\n</code></pre><p>我们再把这个示例程序用tsc --strict模式编译一下，编译器也会报错：</p><p><img src=\"https://static001.geekbang.org/resource/image/d4/8a/d4f943a7f0731b4b0ddc984c7752b68a.png?wh=1382x302\" alt=\"图片\"></p><p>这次报错的原因，是age1有可能取值为null，而null是不能做大小的比较的。这说明，有些类型是不能做大小比较的。</p><p>那什么类型之间可以做大小比较呢？number、string、boolean类型之间都是可以的。但object类型、undefined类型，就不可以做比较了。所以，如果我们把foo4示例程序中age1的类型中去掉null值之后，编译器就不会报错了。</p><pre><code class=\"language-plain\">function foo5(age1 : number, age2:string|number){\n    if (age1 &gt;= age2){  //OK。\n        console.log(\"bigger age!\");\n    }\n}\n</code></pre><p>刚才我们总结了等值比较和大小比较做类型检查的规则。你还可以进一步研究一下加减乘除这几个运算的类型检查的规则，我这里也整理了一下。</p><p>首先是+号运算符。+号运算符有两个语义：一个是作为字符串的连接符使用，这时候类型检查的规则是，只要+号运算符一边的类型是string型的，那么另一边可以是任意的类型，因为任意的类型都可以转化成字符串；+号的另一个语义是做数字的算术运算，在这种情况下，运算符两边只能是数字类型，包括number类型和枚举类型。</p><p>其次是-号、*号和/号。它们做类型检查的规则，跟+号的第二个语义的规则是一样的，也就是运算符的两边只能是数字类型。</p><p>再进一步，你还可以研究一下逻辑运算符，也就是&amp;&amp;、||和!这几个运算符。这几个运算符要求操作数是boolean值的。不过，在TypeScript中，任意类型都可以转化为boolean值，包括string、number、object和undefined类型。这些类型中，有些值等价于true，而其他值等价于false。等价于false的值包括：数字0、对象null、空字符串、NaN，以及undefined。</p><p>所以，看来类型检查中涉及的语义规则，还真是挺丰富的。而要实现上面这些类型检查功能，关键点就是实现类型的计算。在上面的例子中，我们看到需要实现两个运算：<strong>LE运算和overlap运算，我们又把它们叫做子类型判断和重叠判断</strong>。</p><h2>子类型和重叠的判断</h2><p>我们这里提到了一个术语，子类型。什么是子类型呢？如果A是B的子类型，那意味着A的每个成员，也都是B的成员。如果采用集合的术语，这意味着A集合是B集合子集。</p><p>在学习面向对象的时候，你肯定知道子类和父类的概念，它们之间的关系就是子类型关系。我们举一个例子：我们都知道“人”是“哺乳动物”的子类，那么我们可以说任何一个“人”，都肯定是一个“哺乳动物”。“人”的集合是“哺乳动物”集合的子集。</p><p>不过，除了面向对象的子类关系外，还有其他的子类型，<strong>只要二者之间具有子集的关系就行</strong>。比如：</p><ul>\n<li>类型“0|1”，也就是只能取0和1两个值的类型，它是number的子类型，也是“0|1|2”的子类型；</li>\n<li>类型string，是“string|number”的子类型，也是“string|null”的子类型。</li>\n</ul><p>实现子类型判断，你可以参考TypeUtil类的LE方法。它里面的运算规则比较多，我挑重点的和你解释一下：</p><p><strong>首先，我们要如何判断一个NamedType是另一个NamedType的子类型呢？</strong></p><p>对于string、number和boolean这些基础类型来说，它们都是并列的，相互之间没有子类型的关系。不过，由于后面我们会讲到面向对象特性，而面向对象中的类型之间是有子类型关系的，所以我这里预先做了准备。</p><p>你看看NamedType类的设计，会发现它有一个upperTypes属性，这里就存了该类型的多个父类型。所以，基于这个upperTypes属性，父类和子类就被关联到了一起，我们的编译器也就能够基于此来判断一个类型是否是另一个类型的子类型。</p><p>而且，在PlayScript中，我提供了Number的两个子类型，分别是Integer和Decimal，可以用来验证这个特性。在类型消解的时候，编译器会把整型字面量的类型标注为Integer的，而把浮点型字面量的类型标注为Decimal的。在赋值的时候，Integer和Decimal类型的值，都可以赋给number类型的变量。</p><p><strong>第二，如何判断一个值类型是否是某个NamedType的子类型呢？</strong></p><p>这个问题比较简单，我们对每个值类型都记录了它所属的NamedType基础类型。比如，整数值类型是Integer，所以整数的值类型一定是Integer的子类型。而Integer又是number的子类型，那么整数值类型也是number的子类型。</p><p><strong>第三，如何判断一个NamedType或ValueType是UnionType的子类型呢？</strong></p><p>你会看到，UnionType中有一个types数组，代表了多个类型的联合。如果一个NamedType或ValueType是UnionType中任何一个元素的子类型，那么它就是该UnionType的子类型。</p><p><strong>最后，我们如何判断一个UnionType是另一个UnionType的子类型呢？</strong>比如“0|1”是否是“0| 1|2”的子类型，或者是否是“number|string”的子类型呢？</p><p>这就要求第一个UnionType类型的每个成员都得是第二个UnionType的子类型才可以。</p><p>好了，上面就是我们做子类型的检查的思路了。那第二个运算，检查类型之间是否有交集，或者说是否重叠，也可以借鉴类似的思路，算法上稍有区别。你参考下TypeUtil类的overlap方法就行。</p><p>在实现了子类型和overlap的检测以后，我们就能完成前面那些场景中的类型检查了。</p><p>不过，TypeScript做类型计算的能力不止于此，它还有些更强大的能力，这会用到其他的集合运算，包括交集、并集和补集的计算。</p><p>让我们通过这些新的场景来探索一下。</p><h2>交集、并集和补集的计算场景</h2><p>我们还是回到这节课的第一个例子程序来分析分析。在这个例子中，编译器不允许把age赋值给age1，因为age可能取值为null，不能赋值给“string|number”。</p><p>现在我们把这个例子改一下，加一句“age = 18;”，然后再给age1赋值，看看会发生什么变化：</p><pre><code class=\"language-plain\">function foo6(age : number|null){\n    let age1 : string|number;\n    age = 18;     //age的值域现在变成了一个值类型：18\n    age1 = age;   //这里编译器不再报错。\n    console.log(age1);\n}\n</code></pre><p>你看看这个例子程序，现在age的值是18。那么这时再把age的值赋给age2，编译器还会不会报错呢？</p><p>你肯定不希望编译器报错，因为现在age的值是一个number，不是null，所以肯定是可以赋给age1的呀。</p><p>确实如你所愿，tsc编译器这次没有再报错了。这个编译器真的是挺聪明的。</p><p>可是，这个编译器是如何做到这一点的呢？不是说age必须是age1的子类型吗？</p><p><strong>原来，TypeScript的编译器，结合数据流分析技术，随着程序的执行，可以动态地改变变量的值域，也就是取值范围。</strong>比如，在“age = 18”这句之后，age的值域就变成了一个值类型18。如果用我们这个新的类型来做类型检查，自然就不会出错。</p><p>那如果我们再给age赋一个新值，让它等于null会怎样呢？你可以参考下面的例子程序。</p><pre><code class=\"language-plain\">function foo7(age : number|null){\n    let age1 : string|number;\n    age = 18;     //age的值域现在变成了一个值类型：18\n    age1 = age;   //OK。\n    age = null;   //age的值域现在变成了null\n    age1 = age;   //错误！\n    console.log(age1);\n}\n</code></pre><p>这个时候，age的值域变成了null。如果我们这个时候把age赋给age1，那么编译器就会报错。</p><p>除了赋值语句、变量初始化语句能够改变变量的值域以外，if语句中的条件，也会影响到变量的值域，你再看看下面的例子。</p><pre><code class=\"language-plain\">function foo8(age : number|null){\n    let age1 : string|number;\n    if (age != null){   //age的值域现在是number\n        age1 = age;     //OK!\n        console.log(age1);\n    }\n    else{               //age==null, 值域现在变成了null\n        console.log(\"age is empty!\");\n    }\n}\n</code></pre><p>在这个例子中，if条件是“age!=null”。这个条件跟age原来的类型“number|null”相结合，就会求出if块中的age类型变成了“number”，把null这个选项去掉了。</p><p>这个过程是怎么实现的呢？</p><p>在这里，你可以把求age值域的过程看做是做集合运算的过程。在if条件中的表达式，会生成一个age的值域，这个值域是所有不等于null的值，我记做!null。这个值域跟原来age的值域“number|null”做交集运算，最后的结果就是number。我画了一张示意图，表示交集运算的过程，你可以看一下：</p><p><img src=\"https://static001.geekbang.org/resource/image/de/01/de6f8581e7db8b981f8f19ffcfbce701.png?wh=944x666\" alt=\"图片\"></p><p>在这个示意图里，长方形的区域表示全集。全集里面有一个蓝色的圈，表示number集合。还有一个小点，表示null这个值，这两个部分都是蓝色的，代表了“number|null”。</p><p>而打斜线的区域，是在全集中抠去null那个点后剩余的部分，是{null}的补集，我记做!null。这两个集合的交集，就是代表number的那个圆圈。所以，这个圆圈既带有蓝色，又打了斜线。</p><p>在这里，你会发现，我们的算法又需要支持两个集合运算。第一个运算，是<strong>求交集运算</strong>。在这里，我们可以先来简单总结一下交集运算的规则：</p><p><strong>规则一：</strong>对于两个NamedType，如果一个是另一个的子类型，那么交集就是子类型。在下图中，number和integer的交集是integer。</p><p><img src=\"https://static001.geekbang.org/resource/image/18/40/18236214b10511881e77ca8a6640ee40.png?wh=944x666\" alt=\"图片\"></p><p><strong>规则二：</strong>如果两个类型之间没有子类型关系，那么它们的交集就是空集。就像下图中的number和string。</p><p><img src=\"https://static001.geekbang.org/resource/image/1f/6d/1fa42c696233e4efcdd95018a5f4a46d.png?wh=944x666\" alt=\"图片\"></p><p>在算法中，用什么来表示空集呢？在PlayScript的代码中，我用了一个特殊的NamedType，叫做Never，它对应了TypeScript中内置的类型never。关于never类型的介绍，你可以参考<a href=\"https://www.typescriptlang.org/docs/handbook/2/narrowing.html#the-never-type\">TypeScript手册中的内容</a>。</p><p>说完了NamedType之间求交集，你还可以进一步思考一下如何在NamedType、ValueType和UnionType之间互相求交集。总体上，遵循集合运算的规则就行了。</p><p>除了交集运算，还需要<strong>求补集</strong>。在前面的例子中，我们用到了null的补集。那如何表达null的补集呢？我用的方法，是在ValueType对象里加了一个isComplement属性。如果这个属性为true，就代表这个值对象其实是该值的补集。</p><p>除了值对象有补集，其实NamedType也可以有补集。比如，你在if条件中可以放“typeof age != ‘string’”这样的语句，这时候age的值域就是!string，也就是string的补集。</p><p>在上面的示例程序中，我们还有一个地方用到了补集，这就是计算else块中的值域的时候。在else块中，要对if条件生成的值域取补集，也就是把!null再做一次补集运算，得到的结果就是null。也就是说，在else块中，age的取值肯定是null。</p><p>现在我们就说完了求交集和补集这两个集合运算。不过，你可能马上又会想到，<strong>在集合运算里还有求并集的运算呀，那在我们类型计算里是不是也有这个场景呢？</strong></p><p>有的。如果我们把if条件复杂化一点，用上逻辑运算“||”，那么这个if条件形成的值域就是18|81。这里就做了一次求并集的运算，把18和81两个值类型并在了一起。我们让这个并集再跟“number|null”做交集运算，结果仍然是18|81。</p><pre><code class=\"language-plain\">function foo9(age : number|null){\n    if (age == 18 || age == 81){ //age的值域是 18|81\n        console.log(\"18 or 81\");\n    }\n    else{                  //age的值域是 (number | null) &amp; !18 &amp; !81\n        console.log(\"age is empty!\")\n    }\n}\n</code></pre><p>我们把这个例子再往下深化分析一下。如果if块中age的值域是18|81，那么else块中是什么呢？那就是number|null中去掉18和81就可以了。</p><p>具体计算过程，是先对 18|81求补集，也就是!( 18|81) = !18 &amp; !81。其中&amp;是交集的意思。然后再跟(number|null)求交集，得到的结果是(number|null) &amp; !18 &amp; !81。</p><p>到这里，我们又必须引入另一个表示类型的对象，叫做IntersectionType，用于表示多个类型之间的交集。交集类型中，多个成员之间使用&amp;连接的。</p><p>并且，运用集合运算的知识，你还能意识到交集对象和联合对象之间是有转换关系的。UnionType的补集，就是一个IntersectionType，而IntersectionType的补集呢，则是UnionType。</p><p>那到目前为止，我们用于表示类型的对象体系就更加完善了。我们增加了一个新的类型，是IntersectionType。并且，我们还把ValueType和NamedType都加上了是否是补集的属性。</p><p>好了，求集合的补集、交集和并集等运算我们都讲过了。但对于刚才这个例子。我们还需要用数据流分析方法动态地求变量的值域。不过，今天的新知识点已经足够多了，我们还是把这个任务放到下一节课。在下一节课，我们会综合运用多种语义分析技术，来获得更强大的效果。</p><h2>课程小结</h2><p>在今天这节课，我们举了多个例子，示范了多个类型计算的场景。在这个过程中，我们接触到了个多种集合运算，包括子集判断、重叠判断、求补集、求交集和求并集。</p><p>第一，子集判断的典型场景是赋值运算。比如x=y语句，要求y的类型和x的类型相等，或者y的类型是x的类型的子集。如果y的类型是x的类型的子集，我们可以简单地说y是x的子类型。面向对象编程中的继承关系就是子类型的一种体现。</p><p>第二，重叠判断的典型场景是==和!=运算符。它们要求两边的类型有重叠的部分。如果没有重叠的部分，编译器就会报错。</p><p>第三，并集的使用场景，是if条件中带有逻辑运算||的情况，在下一节你还会看到另一个使用场景。</p><p>第四，交集的使用场景，一个是if条件中有逻辑运算&amp;&amp;的情况，另一个是If条件中得到的值域，与变量原来的值域求交集，得到if块中变量的值域。</p><p>第五，补集有多个使用场景，一个是针对!=运算符，第二个是if条件中使用!运算符，还有一个是求else块中的变量值域时。如果对UnionType求补集，我们会得到一个IntersectionType。</p><p>这节课的例子，你都可以通过node play example_type2.ts来运行。关于类型计算的实现，可以参考TypeChecker和TypeUtil两个类。</p><p>我们这节课的内容，全面地运用了集合计算，这也是TypeScript具备强大的类型处理能力的原因。很多现代语言的类型处理能力现在也变得越来越强，这背后的数学知识都是集合运算。所以，你一定要重视这个知识点。你要学会像这节课这样，分析在各种场景下，编译器到底是如何使用集合运算来做类型处理的。</p><h2>思考题</h2><p>在这节课，我们涉猎了很多集合运算的知识点，让整个类型处理变成了一个自洽的体系。今天的思考题，我们继续把这种类型计算的方式跟其他语言做一下对比。你在其他语言做见过对类型做交集、并集、补集、判断子集和判断重叠的运算吗？欢迎在留言区分享你的发现。</p><p>欢迎你把这节课分享给更多对类型计算感兴趣的朋友。我是宫文学，我们下节课见。</p><h2>资源链接</h2><p>1.这节课的示例代码目录在<a href=\"https://gitee.com/richard-gong/craft-a-language/tree/master/24\">这里</a>！</p><p>2.主要看语义分析的代码(<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/24/semantic.ts#L505\">semantic.ts</a>)和类型体系的代码(<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/24/types.ts\">types.ts</a>)。</p><p>3.例子代码：<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/24/example_type2.ts\">example_type2.ts</a></p>","neighbors":{"left":{"article_title":"23｜增强编译器前端功能第2步：增强类型体系","id":423049},"right":{"article_title":"25｜增强编译器前端功能第4步：综合运用多种语义分析技术","id":425353}}},{"article_id":425353,"article_title":"25｜增强编译器前端功能第4步：综合运用多种语义分析技术","article_content":"<p>你好，我是宫文学。</p><p>在上一节课，我们比较全面地分析了怎么用集合运算的算法思路实现类型计算。不过，在实际的语义分析过程中，我们往往需要综合运用多种技术。</p><p>不知道你还记不记得，我们上一节课举了一个例子，里面涉及了数据流分析和类型计算技术。不过这还不够，今天这节课，我们还要多举几个例子，来看看如何综合运用各种技术来达到语义分析的目的。在这个过程中，你还会加深对类型计算的理解、了解常量折叠和常量传播技术，以及实现更精准的类型推导。</p><p>好，我们首先接着上一节课的思路，看一看怎么把数据流分析与类型计算结合起来。</p><h2>在类型计算中使用数据流分析技术</h2><p>我们再用一下上节课的示例程序foo7。在这个程序中，age的类型是number|null，age1的类型是string|number。我们先让age=18，这时候把age赋给age1是合法的。之后又给age赋值为null，然后再把age赋给age1，这时编译器就会报错。</p><pre><code class=\"language-plain\">function foo7(age : number|null){\n    let age1 : string|number;\n    age = 18;     //age的值域现在变成了一个值类型：18\n    age1 = age;   //OK\n    age = null;   //age的值域现在变成了null\n    age1 = age;   //错误！\n    console.log(age1);\n}\n</code></pre><!-- [[[read_end]]] --><p>在这个过程中，age的值域是动态变化的。在这里，我用了“值域”这个词。它其实跟类型是同一个意思。我这里用值域这个词，是强调动态变化的特征。毕竟，如果说到类型，你通常会觉得变量的类型是不变的。如果你愿意，也可以直接把它叫做类型。</p><p>你马上就会想到，数据流分析技术很擅长处理这种情况。具体来说，就是在扫描程序代码的过程中，某个值会不断地变化。</p><p>提到数据流分析，那自然我们就要先来识别它的5大关键要素了。我们来分析一下。</p><p><strong>首先是分析方向。</strong>这个场景中，分析方向显然是自上而下的。</p><p><strong>第二，是数据流分析针对的变量。</strong>在这个场景中，我们需要分析的是变量的值域。所以，我用了一个varRanges变量，来保存每个变量的值域。varRanges是一个map，每个变量在里面有一个key。</p><pre><code class=\"language-plain\">varRanges:Map&lt;VarSymbol, Type&gt; = new Map();\n</code></pre><p><strong>第三，我们要确定varRanges的初始值。</strong>在这个例子中，每个变量的值域的初始值就是它原来的类型。比如age一开始的值域就是number|null。</p><p><strong>第四，我们要确定转换函数，也就是在什么情况下，变量的值域会发生变化。</strong>在当前的例子中，我们只需要搞清楚变量赋值的情况就可以了。如果我们要在变量声明中进行初始化，那也可以看做是变量赋值。</p><p>在变量赋值时，如果=号右边的值是一个常量，那么变量的值域都会变成一个值对象，这种情况我们已经在前一节课分析过了。</p><p>那如果=号右边的值不是常量，而是另一个变量呢？比如下面一个例子foo10，x的类型是number|string，y的类型是string。然后把y赋给x。我相信你也看出来，现在x的值域就应该跟y的一样了，都是string。</p><pre><code class=\"language-plain\">function foo10(x : number|string, y : string){\n   x = y;    //x的值域变成了string\n   if (typeof x == 'string'){  //其实这个条件一定为true\n       println(\"x is string\");\n   }\n}\n</code></pre><p>研究一下这个例子，你会发现通过赋值操作，我们把x的值域收窄了。在TypeScript的文档中，这被叫做\"<a href=\"https://www.typescriptlang.org/docs/handbook/2/narrowing.html\">Narrowing</a>\"。翻译成汉语的话，我们姑且称之为“窄化”吧。</p><p>不过，除了赋值语句，还有其他情况可以让变量的值域窄化，包括使用typeof运算符、真值判断、等值判断、instanceof运算符，以及使用类型断言等等。其中最后两种方法，涉及到对象，我们目前还没有支持对象特性，所以先不讨论了。我们就讨论一下typeof运算符、真值判断和等值判断这三种情况。</p><p>首先讨论一下<strong>typeof运算符</strong>。其实在前面的例子foo10中，我们就使用了typeof运算符。typeof是一个类型运算符，它能返回代表变量类型的字符串。不过它的结果只有少量几个值，包括number、string、boolean、object、undefined、symbol和bigint。</p><p>我们再举一个例子foo11，看看typeof是如何影响变量的值域的。</p><pre><code class=\"language-plain\">function foo11(x : number|string){\n   let y: string;\n   if (typeof x === 'string'){  //x的值域变为string\n       y = x;                  //OK。\n   }\n}\n</code></pre><p>你可以看到，在示例程序foo11中，x原来的类型是number|string。但在if条件中，我们用typeof进行了类型的检测，只有当x的类型是string的时候，才会进入if块。所以，在if块中，我们用x给string类型的变量y赋值是没有错的。</p><p>在使用typeof的表达式中，你可以用四个运算符：===、!==、==和!=。其中===和==的效果是一样的，只不过前者的性能更高。同样，!==和!=也是等价的。</p><p>接着，我们看看真值判断。什么是真值判断呢？我们还是举一个例子，这样理解起来更直观一些。</p><pre><code class=\"language-plain\">function foo12(x : string|null){\n    let y: string;\n    if (x){        //x的值域变为string &amp; !\"\"\n        y = x;     //OK。\n    }\n}\n</code></pre><p>在这个例子中，x的类型是string|null。但在if语句中，通过判断x是否为真，把x=null这个选项去掉了，这样就可以把x赋给string类型的y了。</p><p>这里，我还要给你补充点背景知识。在TypeScript/JavaScript中，我们其实可以把其他类型的值放入需要boolean值的地方，比如string、number、object等，它们会被自动转化成boolean值。不过，其中有一些值会被转化成false，它们是：0、NaN、“” (空字符串)、0n (bigint类型中的0)、null，以及undefined。</p><p>除此之外的值，转化为boolean值以后都是true。所以，在上面foo12示例程序的if条件中，x是true，那它就不可能是null值了，也不可能是空字符串。这样，最后的形成的值域就是string &amp; !“”。</p><p>最后，我们再看看<strong>等值判断</strong>。其实我们在上一节就见过等值判断的例子，我们把那个例子程序再拿过来看一下。</p><pre><code class=\"language-plain\">function foo9(age : number|null){\n    if (age == 18 || age == 81){  //age的值域现在是 18|81\n        console.log(\"18 or 81\");\n    }\n    else{                         //age的值域是 !18 &amp; !81 &amp; (number | null)\n        console.log(\"age is empty!\")\n    }\n}\n</code></pre><p>在这个例子中有一个if语句，其中的条件表达式会生成一个值域，“18|81”。而对于else块，则需要先把“18|81”取补集，然后再跟age原来的值域求交集。</p><p>好了，现在我们就分析完了数据流分析中的第四个要素，也就是转换函数。<strong>接下来我们看看最后一个要素，就是汇聚函数</strong>。</p><p>什么时候需要用到汇聚函数呢？对于if语句来说，如果程序在if块和else块中都修改了某个变量的值域，那在if语句后面，变量的值域就需要做汇聚。我们还是通过一个例子来说明一下。</p><p>在下面的例子foo13中有一个if语句。在这个if语句中，if块和else块分别都有一个对y赋值的语句。在if块中赋值语句是y=x。在这里，x的值域是number，所以y的值域也是number。在else块中，赋值语句是y = 18，那y的值域就是18。</p><pre><code class=\"language-plain\">function foo13(x : number|null){\n    let y:number|string;\n    let z:number;\n    if (x != null){ //x的值域是number \n        y = x;      //y的值域是number\n    }\n    else{\n        y = 18;     //y的值域是18\n    }               //if语句之后，y的值域是number       \n    z = y;          //OK\n    return z;\n}\n</code></pre><p>那么，在退出if语句的时候，y的值域应该是什么呢？你稍微分析一下就能看出来，这里应该取两个分支的并集，也就是number。所以把y赋给z是可以的。</p><p>你可以把这个例子稍微修改一下，把else块中的赋值语句改为y = “eighteen”。那当退出if语句以后，y的值域是number|“eighteen”。这样你再把y赋给z，编译器就会报错。</p><pre><code class=\"language-plain\">function foo14(x : number|null){\n    let y:number|string;\n    let z:number;\n    if (x != null){ //x的值域是number \n        y = x;      //y的值域是number\n    }\n    else{\n        y = \"eighteen\"; //y的值域是18\n    }               //if语句之后，y的值域是number|\"eighteen\"       \n    z = y;          //编译器报错！\n    return z;\n}\n</code></pre><p>好了，到目前为止，我已经把数据流分析的5个要素都识别清楚了。思路清楚以后，你就可以去实现了。至于我的参考实现，你可以看一下<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/25/semantic.ts#L506\">TypeChecker</a>。</p><p>在这里，我要再分享一点心得。你会发现，即使我们已经多次使用数据流分析技术了，每次我还要把5个要素都过一遍。这是因为，我们做研发的时候，有个思维框架很重要，它可以引导你的思路，避免一些思维盲区。</p><p>比如，我在类型计算中使用数据流分析的时候，一开始注意力被其他技术点吸引了，忘记了用整个分析框架检查一遍，结果就忘记了实现汇聚函数，这就会导致一些功能缺失。后来用框架一检查，马上就补上了这个功能。</p><p>好了，到这里，我们已经基本介绍清楚了如何使用数据流分析技术来做类型计算。不过，类型计算还可能受到其他技术的影响。接下来我就介绍一下常量折叠（Constant Folding）和常量传播（Constant Propagation）。常量折叠和常量传播的结果，会进一步影响到类型计算的结果。</p><h2>常量折叠和常量传播</h2><p>我们还是先看一个例子来理解一下这两个概念。这个例子中有x1，x2和x3三个变量。我们首先给x2赋予常量10。接着，我们把x2+8赋给x3。从这里你能计算出，其实x3的值也是一个常量，它的值是18。</p><pre><code class=\"language-plain\">function foo15(x1:number|null):number{\n    let x2 = 10;       //x2是常量10\n    let x3 = x2 + 8;   //x3是常量18\n    if (x1 == x3 ){    //x1的值域是18\n        return x1;     //OK!\n    }\n    return x2;\n}\n</code></pre><p>你看，执行到这里，我们其实在编译期就把x2+8的值计算出来。这样，在生成汇编代码的时候，我们就不需要进行相应的计算了，直接给x3赋值为18就行了。这个技术就叫做<strong>常量折叠</strong>。它能让一些常量的计算在编译期完成，这样就能提高程序在运行期的性能。</p><p>同时，在x3 = x2+8这行程序中，还有一个现象，叫做<strong>常量传播</strong>。什么意思呢？在这行中，x2的值已经是一个常量10了，它的常量值被传播到了x2+8这个表达式中，从而计算出了一个新的常量x3。</p><p>再接下来是一个if语句。这个时候，x3的值传播到了if条件中。这就影响到了x1的值域。现在x1的值域就变成18了。所以，当我们在if块中执行return x1的时候，代码是正确的，满足返回值必须是number的要求。</p><p>那常量传播具体怎么实现呢？</p><p>在PlayScript的实现中，我们给每个表达式都添加了一个constValue属性。通过遍历树的方式，就可以求出每个表达式的常量值，并记录到constValue属性。在生成目标代码的时候，就可以直接使用这个常量值，不需要在运行期做计算。</p><p>好了，现在我们已经了解了常量折叠和常量传播技术，也分析了它对类型计算的影响。</p><p>不过，到目前为止，对于类型计算的结果，我们都是用在类型检查的场景里。其实，类型计算的结果也能用于类型推导，能够提高类型推导的准确程度。而常量折叠和传播，也会在其中起到作用。</p><h2>类型推导</h2><p>在之前PlayScript版本中，我们也实现了基本的类型推导功能。但那个时候，类型推导都是基于变量声明时的类型，而不是基于数据流分析来获得变量动态的值域，再根据这个值域做类型推导。基于变量声明进行推导的结果肯定是不够精准的。</p><p>同样，我们举个例子看一下。在这个例子中，变量a的类型是number|string，我们再给a赋值为“hello”，现在a的值域是“hello”。再然后呢，我们声明了一个变量b，并把变量a作为它的初始化值。</p><pre><code class=\"language-plain\">function foo16(a:number|string){\n    a = \"hello\";    //a的值域是\"hello\"\n    let b = a;      //推导出b的类型是string\n    console.log(typeof b); \n}\n</code></pre><p>那么问题来了，现在b应该是什么类型呢？我给你两个候选答案，让你选一下：</p><p>选项1：b的类型a原来的类型是一样的，都是number|string。</p><p>选项2：b的类型是string，因为采用常量传播技术，我们已经知道a的值是“hello”了。</p><p>我估计你应该会选出正确的答案，就是选项2。其实，上面的“let b = a”这个语句，就等价于“let b = “hello””，所以你应该能够推导出b的类型是string。</p><p>不过，这里要注意，我们不能因为a当前的值域是“hello”，就推导出变量b的类型也是值类型“hello”，这就把变量b限制得太死了。TypeScript会采用“hello”的基础类型string。</p><p>类型推导还有更复杂一点的场景。比如，在下面的例子中，我们仍然用a来初始化变量b。不过，现在a的值域是10|null。</p><pre><code class=\"language-plain\">function foo17(a:number|string|null){\n    if(a == 10 || a == null){ //a的值域是10|null\n        let b = a;            //推导出b的类型是number|null\n        if (b == \"hello\"){    //编译器报错！\n            console.log(\"whoops\"); \n        }\n    }\n}\n</code></pre><p>基于a的值域，编译器会把b的类型推导为number|null。所以，这个时候如果我们用b==\"hello\"让b跟字符串做比较，编译器就会报错，指出类型number|null和string之间没有重叠，所以不能进行==运算。</p><p><img src=\"https://static001.geekbang.org/resource/image/fe/92/fe60768d8287005d5671b75233a1fd92.png?wh=1450x332\" alt=\"图片\"></p><p>好了，通过刚才的分析，相信你对类型计算的在类型推导中的作用，也有了一些直观的了解。</p><h2>课程小结</h2><p>今天的内容就是这些。在今天这节课，我希望你能在以下几个方面有所收获。</p><p>首先，我们采用数据流分析的框架，可以动态地计算变量在每行代码处的值域，或者叫做类型。通过变量赋值、typeof运算符、真值判断和等值判断等操作，变量的值域会不停地被窄化。不过，在多个条件分支汇聚的地方，又会通过求并集而把值域变宽。</p><p>第二，常量折叠技术能够在编译期提前计算出常量，这样我们就不需要在运行期再计算了，从而提高程序性能。而常数传播技术，能够把常数随着代码传播到其他地方，从而计算出更多的常量。这些传播出去的常量，还会让类型计算的结果更加准确。</p><p>第三，类型计算的结果不仅可以用于类型检查，还可以用于类型推导，让类型推导的结果更加准确。</p><p>今天这节课实现的功能，你仍然可以参考<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/25/types.ts#L7\">TypeUtil</a>和<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/25/semantic.ts#L506\">TypeChecker</a>的实现，并且运行<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/25/semantic.ts#L506\">example_type2.ts</a>示例程序。</p><p>为了更好地支持类型计算的功能，我还给编译器增加了对typeof语法的支持。增加的新语法规则叫做typeOfExp。</p><pre><code class=\"language-plain\">primary:  literal | functionCall | '(' expression ')' | typeOfExp ;\ntypeOfExp : 'typeof' primary;\n</code></pre><p>另外，我还增加了对于===和!==的支持。现在你对于支持新的语法规则应该已经驾轻就熟了，所以我在这里就不多展开了。你可以去看看<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/25/parser.ts#L948\">示例程序的源代码</a>。</p><p>那么，对TypeScript的类型系统和其他编译器前端功能的实现，我们到此就告一个段落了。这些功能将会给我们后面实现编译器后端特性提供很好的支撑！</p><h2>思考题</h2><p>今天的思考题是关于类型推导的。如果b的值域是0 | 1 | true | false，那么在“let a = b”这样一个变量声明语句中，编译器推导出的a的类型应该是什么呢？</p><p>欢迎你把这节课分享给更多对编译器前端感兴趣的朋友。我是宫文学，我们下节课见。</p><h2>资源链接</h2><p>1.这节课示例代码的<a href=\"https://gitee.com/richard-gong/craft-a-language/tree/master/25\">目录</a>；<br>\n2.这节课你仍然需要关注<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/25/semantic.ts#L506\">TypeChecker</a>和<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/25/types.ts#L7\">TypeUtil</a>的代码；<br>\n3.Parser中解析<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/25/parser.ts#L948\">TypeOfExp</a>的代码，非常简单；<br>\n4.测试程序仍然是放在<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/25/example_type2.ts\">example_types.ts</a>中，不过例子更多了。你每次可以注释掉其他的例子，只运行其中的一个，测试编译器的行为。</p>","neighbors":{"left":{"article_title":"24｜增强编译器前端功能第3步：全面的集合运算","id":424592},"right":{"article_title":"26｜增强更丰富的类型第1步：如何支持浮点数？","id":426150}}},{"article_id":426150,"article_title":"26｜增强更丰富的类型第1步：如何支持浮点数？","article_content":"<p>你好，我是宫文学。</p><p>我们前面几节课，讲的都是编译器前端的功能。虽然，要实现完善的前端功能，我们要做的工作还有很多。不过，我们现在已经不“虚”了！因为我们已经把编译器前端部分的主要知识点都讲得差不多了，其他的我们可以慢慢完善。</p><p>所以，现在我们重新把精力放回到编译器后端功能和运行时上来，这部分的功能我们还有待加强。在第一部分起步篇中，为了尽量简化实现过程，我们的语言只支持了整数的运算，甚至都没区分整型的长度，统一使用了32位的整型。</p><p>但这在实用级的语言中可行不通，我们还需要在里面添加各种丰富的数据类型。所以，接下来，我们会花几节课的时间，丰富一下我们语言支持的数据类型。首先我们会添加一些内置的基础类型，比如浮点型、字符串和数组。之后，我们还要通过对面向对象编程特性，支持用户自定义自己的类型。</p><p>在这一节课，我们先来看一下如何让我们的语言支持浮点型数据。为实现这个目的，我们需要先了解CPU为了支持浮点数有哪些特别的设计，ABI方面又有一些什么规定，以及如何修改汇编代码生成逻辑。而且，为了正确地在汇编代码中表示浮点型字面量，你还会学到浮点数编码方面的国际标准。</p><p>首先，让我们了解一下CPU硬件和ABI对浮点数运算提供的支持。</p><!-- [[[read_end]]] --><h2>CPU和ABI对浮点数运算的支持</h2><p>我们先来回顾一下起步篇中关于整数运算的知识。已经有些日子没见到它们了，不知道你还记不记得？你可以和下面我们重点讲解的浮点数的处理模式对比着来看，看看它们有怎样的不同，这也能加强你对这些重点知识的记忆。</p><p>X86架构的CPU在64位模式下对整数运算的支持，最重要的就是这两个知识点：</p><ul>\n<li>寄存器。整数运算可以使用16个通用寄存器；</li>\n<li>指令。对整数进行加减乘除的指令分别是addl、subl、imull和idivl。</li>\n</ul><p>另外，ABI也针对整数运算做了一些规定，比如：</p><ul>\n<li>参数传递。根据ABI，参数传递过程中会使用6个寄存器。超过6个参数，则放在调用者的栈桢里；</li>\n<li>寄存器保护。有一些寄存器要能够跨函数调用保存数据，也就是说函数调用者需要保护这些寄存器，而另一些寄存器则不需要保护；</li>\n<li>返回值。根据ABI，从函数中返回整数值时，使用的是%eax寄存器；</li>\n<li>栈桢结构。ABI对于栈桢里存放参数、返回地址做了规定，并且规定栈桢需要16字节内存对齐，还规定了如何使用栈桢外的红区等等。</li>\n</ul><p>那么，我们再来看看CPU对浮点数运算的支持是怎么样的。</p><p>其实，最早期的X86CPU只支持整数运算，并不支持浮点数运算。如果我们要进行浮点数运算，就要用整数运算来模拟。但是这样的话，浮点数运算的速度就会比较慢。</p><p>而现代CPU解决了这个问题，普遍从硬件层面进行浮点运算，所以编译器也要直接生成浮点运算的机器码，最大程度地发挥硬件的性能。</p><p>我们之前说过，一款CPU可能支持多个指令集。而某些指令集，就是用于支持浮点数计算的。在X86的历史上，CPU最早是通过一个协处理器来处理浮点数运算，这个协处理器叫做FPU（浮点处理单元），它采用的指令集叫做X87。后来这个协处理器就被整合到CPU中了。</p><p>再后来，为了提高对多媒体数据的处理能力，厂商往CPU里增加了新的指令集，叫做MMX指令集。MMX的具体含义，有人说是多媒体扩展（MultiMedia eXtension），有人说是矩阵数学扩展（Matrix Math eXtension）。不管缩写的含义是什么，MMX主要就是增强了对浮点数的处理能力，因为多媒体的处理主要就是浮点数运算。</p><p>并且，MMX还属于SIMD类型的指令集。SIMD（Single Instruction Multiple Data）是一条指令对多个数据完成加减乘数运算的意思，因此MMX指令能让CPU的处理效率更高。</p><p>MMX指令集后来又升级成为了SSE指令集，还形成了多个版本，每个版本都会增加一些新的指令和功能。最新的版本是SSE4.2。SSE是流式SIMD扩展（Streaming SIMD Extensions）的意思。到今天，X86计算机进行浮点数运算的时候，基本上都是采用SSE指令集，不再使用x87指令集，除非是使用那些特别早的型号的CPU。</p><p>不知道你还记不记得，我们之前提过，你可以查询自己电脑的CPU所支持的指令集。在macOS上，我用下面的命令就可以查到：</p><pre><code class=\"language-plain\">sysctl machdep.cpu.features machdep.cpu.leaf7_features\n</code></pre><p>然后你会在命令行终端，得到关于CPU特性的信息。这些特性就对应着指令集。比如，出现在第一个的FPU，就对应着X87指令集。你也会从其中看到多个版本的SSE指令集。</p><p><img src=\"https://static001.geekbang.org/resource/image/64/5c/640dd74e5be7692026ec3a113fecyy5c.png?wh=1528x292\" alt=\"图片\"></p><p>如果你嫌上面的命令太长，那也可以使用一个短一点的命令。这个命令会打印出更多关于CPU的信息，比如CPU所支持的线程数，等等。其中也包括该CPU的指令集。</p><pre><code class=\"language-plain\">sysctl machdep.cpu\n</code></pre><p>这里我插一个小知识点，不知道你会不会有这个疑惑，我们操作系统是怎么知道某CPU支持哪些指令集的呢？原来，X86架构的CPU提供了一个cpuid指令。你用这个指令就可以得到CPU类型、型号、制造商信息、商标信息、序列号、缓存，还有支持特性（也就是指令集）等一系列信息了。所以你看，要理解软件的功能，经常都需要底层硬件架构的知识。</p><p>好了，既然我们需要用到SSE指令集，那就需要了解一下SSE指令集的特点。并且，SSE其实不仅能处理浮点数，还能处理整数。不过现在我们主要关心与浮点数有关的特性。这些信息从哪里获得呢？当然是从Intel的手册。下面这些信息就来自于《<a href=\"https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-software-developers-manual-volume-1-basic-architecture.html\">Intel® 64 and IA-32 Architectures Software Developer’s Manual，Volume 1: Basic Architecture</a>》，我给你稍微总结一下。</p><p><strong>首先，我们看看SSE指令所使用的寄存器。</strong></p><p>在64位模式下，SSE可以使用16个128位的寄存器，分别叫做xmm0~xmm15。</p><p>此外，SSE还会使用一个32位的MXCSR寄存器，用于保存浮点数运算时的控制信息和状态信息。比如，如果你做除法的时候，除数是0，那么就会触发一个异常。而MXCSR寄存器上的某个标志位会决定如何处理该异常：是采用内置的标准方法来处理呢，还是触发一个软件异常来处理。关于MXCSR的详细信息，你可以按需要查看一下手册。</p><p><strong>第二，我们看一下SSE对数据类型的支持。</strong></p><p>SSE指令支持32位的单精度数，也支持64位的双精度数。不过，单精度数和双精度数的格式，都遵循IEEE 754标准。</p><p>在SSE指令中，寄存器里可以只放一个浮点数，这个时候我们把它叫做标量（Scalar）。还可以把多个浮点数打包放在一个寄存器里，这种数据格式叫做打包格式（&nbsp;Packed Data Types），或者叫做向量格式。下图就显示了在一个128位寄存器里存放4个单精度浮点数的情况。</p><p><img src=\"https://static001.geekbang.org/resource/image/c2/d7/c2f6ec640402f24f802247beaf5896d7.png?wh=1200x234\" alt=\"图片\" title=\"来源：Intel® 64 and IA-32 Architectures Software Developer’s Manual，Volume 1: Basic Architecture\n\"></p><p>打包格式是用于SIMD类型的指令的，这样一条指令就能处理寄存器里的4个单精度浮点数的计算。不过，我们关注的还是对标量数据的处理，所以就先忽略向量数据处理的情况，有需要我们再补充。</p><p><strong>第三，我们看看SSE指令的情况。</strong></p><p>SSE对处理浮点数的指令，包括向量指令和标量指令。另外，在JavaScript中，number是以双精度数来表示的，所以我们的语言也就可以忽略与单精度浮点数有关的指令，直接关注双精度浮点数指令就好了。</p><p>我在下面这张表中，列出了SSE中与标量的、双精度浮点数处理有关的一些主要的指令：<br>\n<img src=\"https://static001.geekbang.org/resource/image/21/0d/218908c1ffe9569f903430a36a704c0d.jpg?wh=1980x1114\" alt=\"\"><br>\n你能看到，其实这些指令数量也并不太多，很容易掌握。当然，SSE完整的指令还是不少的。SSE针对向量数据处理、整型数据处理都有单独的指令，还有一些指令是用于管理MXCSR寄存器的状态，以及对高速缓存进行管理的。如果你想了解这些，可以阅读Intel手册的第二卷：《<a href=\"https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-2a-2b-2c-and-2d-instruction-set-reference-a-z.html\">Intel® 64 and IA-32 architectures software developer’s manual combined volumes 2A, 2B, 2C, and&nbsp; 2D: Instruction set reference, A- Z</a>》</p><p>到此为止，我们初步了解了CPU硬件对浮点数计算的支持。接下来，我们还需要了解ABI方面的一些知识。</p><p>寻找ABI方面的知识，当然还是去看手册。下面的信息来自于《System V Application Binary Interface AMD64 Architecture Processor Supplement》，我也替你稍微梳理了一下重点。</p><p>首先我们要看<strong>参数传递</strong>。采用SSE指令集传递参数时，可以使用8个寄存器，从xmm0到xmm7。如果要传递的参数超过8个，也是通过栈传递。</p><p>再看看<strong>返回值</strong>。对于64位标量计算来说，我们用xmm0来传递返回值就可以了。</p><p>最后我们再看<strong>对寄存器的保护</strong>。SSE指令集用到的寄存器，都不需要跨函数调用保存。也就是说，Callee不需要保护这些寄存器中的值。</p><h2>修改汇编代码的生成功能</h2><p>在了解了硬件对浮点数运算的支持和ABI方面的规定以后，我们就可以去动手修改我们语言中汇编代码的生成功能了。</p><p>其实，为浮点数运算和整数运算生成汇编代码的逻辑，整体上是差不多的。你只需要按照CPU架构和ABI的规定做一定的调整就可以了。这些调整主要包括：</p><p><strong>第一，调整算法所生成的指令。</strong></p><p>这个时候，算术运算的指令，已经从原来的addl和subl等整数运算指令，变成了addsd、subsd这些浮点数运算指令。数据移动的指令，也从原来的movl变成了movsd。其他指令也做了类似这样的调整。</p><p><strong>第二，调整寄存器分配算法。</strong></p><p>由于整数运算和浮点数运算使用的寄存器是不同的，所以我们可以针对两种运算分别运行寄存器分配算法来分配寄存器。</p><p><strong>第三，调整栈桢维护逻辑。</strong></p><p>为什么要调整这个呢？是这样，如果我们需要把双精度浮点数溢出到栈桢里保存，那它要占据8个字节。但是，原来的32位整数只需要占据4个字节呀。所以这个时候，计算维护栈桢的相关逻辑要调整了，包括计算栈桢大小，以及需要如何移动栈顶指针rsp等等都需要变动。</p><p><strong>第四，调整函数调用逻辑。</strong></p><p>在调用函数时，如果我们需要传递浮点数的参数，那要使用浮点数的寄存器，并且可以使用8个。超过了8个之后，是放到调用者的栈桢里。对于浮点型的返回值，也是放在浮点数寄存器xmm0里的。</p><p>但这里其实有一个隐藏的问题：如果一个函数既需要传递整型参数，又需要传递浮点型参数，那该怎么办呢？这是一个很有趣的技术点。不仅仅是传这两种参数，后面我们还需要传递字符串指针、对象指针，还有布尔值等等，其实这些在ABI手册里都有规定，你直接去查ABI手册就可以了。不过，目前我们还是先简化一下，我们规定函数的参数和返回值都必须是双精度型的，后面我们再去支持混合参数的场景。</p><p>做完这些调整以后，我们的汇编代码生成算法，基本上就能够支持浮点数运算了。具体的实现，你仍然可以去查看一下<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/26/asm_x86-64_d.ts#L454\">AsmGenerator</a>和<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/26/asm_x86-64_d.ts#L1298\">Lower</a>的代码。</p><p>不过，除了上面这些调整以外，还有一个看似很小的技术点，但这个技术点涉及到浮点数运算的原理，所以我们有必要单独拿出来讲一讲。</p><h2>浮点数的编码标准</h2><p>编码标准这个小的技术点，涉及到我们如何在汇编代码里使用浮点型的常数，我们也叫它立即数。为什么这是一个问题呢？我们通过示例代码看一下。</p><p>我们把param_double.c代码，来编译成汇编代码看一下里面是如何使用浮点数常量的。</p><pre><code class=\"language-plain\">double foo(double p1, double p2, double p3, double p4, double p5, double p6, double p7, double p8, double p9, double p10);\ndouble bar(){\n    return foo(1, 2, 3, 4, 5, 6.1, 7.2, 8.3, 9.4, 10.5);\n}\n</code></pre><p>param_double.c的代码很简单。里面首先有一个foo函数的签名，但并没有具体实现。然后在bar函数里传了10个参数给foo函数，这10个参数都是常数。有的参数是以整数格式提供的，但根据语言的设计，编译器会把它们强制转换为double。</p><p>然后我们用clang -S param_double.c -o param_double.s生成汇编代码。其中bar函数对应的汇编代码如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/cd/a5/cdc649d8dc52eab825ee68f049150ba5.png?wh=1308x1250\" alt=\"图片\"></p><p>在这个汇编代码中，你会看到，在把常数赋值给寄存器的地方，用到的都是一个个的标签。比如，LCPI0_0(%rip)是第一个参数的标签，这个参数是常量1。这个标签可以被转化为一个文本段（也就是代码区）的一个地址。我们知道，%rip寄存器保存的是CPU下一条要执行的指令的地址，所以LCPI0_0(%rip)实际上记录的是常量的地址与下一条指令的地址的偏移量。通过下一条指令的地址，加上这个偏移量，就能找到常量1的存储位置。</p><p>我们再看看这个汇编代码文件的前半部分，你会看到一个文本段，用于放8字节的字面量。你可以参考下图。我在图上标注了一些必要的说明。</p><p><img src=\"https://static001.geekbang.org/resource/image/6a/bd/6aa233167e08567efa9ba1cf01885fbd.png?wh=1536x1128\" alt=\"图片\"></p><p>这里，.quad表示一个四个字的字面量。其中，每个字是2个字节、16位，所以加起来是8个字节、64位，正好是一个double型所需要的空间。</p><p>相信你也注意到了，在计算机里表示整数是比较简单的，基本上就是把10进制的数字转化为二进制就行了。顶多再加上一个符号位，表示正数和负数。但是要表达浮点数，就没有那么简单了。从汇编代码中你能看到，即使是1这个最简单的整数，表达成一个double型的字面量之后，也会显得很复杂。这个double值，如果我们用16进制整型格式显示，是0x3ff0000000000000。</p><p>并且，你也能看到，像1、2、3、4、5这5个整数，以及10.5这个小数，用double格式可以精确地表示出它们的数值。而对于6.1、7.2、8.3、9.4这几个小数，用double格式就只能近似地表达其值。它跟原始的值还有一点小小的误差，大约是小数点后16位的一个很小的值。这都是由浮点数的编码方式决定的。</p><p>现在问题就来了，在生成汇编代码的过程中，我们要把代码里的字面量转换成像0x3ff0000000000000（也就是1）、0x401ccccccccccccd（也就是7.2）这样的格式才可以。所以，你就必须了解浮点数的编码格式。</p><p>浮点数的编码，是在国际标准IEEE 754中规定的。对于双精度浮点数来说，它所占据64位被划分成了3段。一开头，是一个符号位，符号位是0，则表明这是个整数，如果是1，则表示负数。接下来是11位的指数位，最后是52位的有效数字位。这样加起来一共是64位。</p><p><img src=\"https://static001.geekbang.org/resource/image/cd/ac/cd7ddace07c7272d78dac6fac1857bac.png?wh=1582x170\" alt=\"图片\"></p><p>那什么是指数位？什么是有效数字位？它们又是如何用来表示一个浮点数的呢？</p><p>原来，<strong>浮点数使用的是二进制的科学计数法来表示数字</strong>。也就是说，任何一个数字都可以表达成1.xxxxx乘以2的n次方的格式：</p><p><img src=\"https://static001.geekbang.org/resource/image/8d/fb/8d3418e188f3e352fea27c706f5ac2fb.png?wh=374x54\" alt=\"图片\"></p><p>比如说，5这个数字，变成二进制格式是101，如果写成二进制的科学计数法，我们小数点前面只保留1位，就是：</p><p><img src=\"https://static001.geekbang.org/resource/image/13/01/1381eb3dde02dfb223ab07b63e87fe01.png?wh=238x54\" alt=\"图片\"></p><p>那具体编码的时候，是不是在有效数字区里存个101，在指数区存个10（也就是2）就行了呢？就像下图那样。</p><p><img src=\"https://static001.geekbang.org/resource/image/d4/07/d47fa064627ea9b114e0510aa3c4f707.png?wh=1580x86\" alt=\"图片\"></p><p>这是不行的。这里有两个地方需要调整，才能符合IEEE 754标准：</p><p><strong>首先，我们要调整有效数字的存储。</strong>由于所有的有效数字的整数位都是1，所以我们从节约存储空间的角度看，这一位就没有必要存了。也就是说，101只存个01就行。</p><p><strong>第二，我们要调整指数的存储。</strong>指数是可以有正有负的。比如0.05，写成二进制是0.00001100110011001100110011001100110011001100110011001101，写成科学计数法是：</p><p><img src=\"https://static001.geekbang.org/resource/image/0d/43/0da207a8c258cea7dd645e4e15fbab43.png?wh=1510x56\" alt=\"图片\"></p><p>这个时候，指数位就是-5。</p><p>所以，为了能够表达指数是正数和负数的情况，IEEE754规定，要把指数加上一个常数，让所有的指数都变成正数来表达。因为2的11次方是2048，理论上指数位能够表达2048个指数值。但标准规定，当这11位都是1时，是用来表示特殊数字的：如果有效位数全为零，表示正负的无穷大（±Infinity）；如果有效位不全为0，则表示NaN。</p><p>这样的话，我们就只能使用2047个指数了，其中整数1023个，负数1023个，指数0占一个。所以，我们把所有的指数都加上常数1023，就都变成正数了。而5的指数位就需要记录1023+2=1025，表达成二进制是10000000001，正好是11位，一前一后都是1，其他位是0。</p><p>好了，完成上面两个调整以后，字面量5的double格式就是：</p><p><img src=\"https://static001.geekbang.org/resource/image/e6/43/e64cf0383963c650e877f12a9ffb9a43.png?wh=1578x174\" alt=\"图片\"></p><p>这个数字如果表示成16进制，那就是0x4014000000000000，跟汇编代码里字面量5的数值是完全一致的。</p><p>好了，看到这里，我相信你已经掌握了双精度浮点型数字的存储方式了。掌握了原理以后，你可以自己写段代码来生成IEEE 754格式的浮点数。在课程的示例代码里，我用了一个第三方的node.js库（<a href=\"https://github.com/feross/ieee754\">feross/ieee754</a>）来把number的常数转换成用16进制的格式，就像汇编代码里的那些double常数一样。你需要用“npm install ieee754”命令来安装这个库。</p><h2>课程小结</h2><p>好了，今天的内容就是这些。我们用了一节课的时间，讲解了支持浮点数运算的关键知识点。现在我们再来总结一下：</p><p>首先，对于每一个CPU架构来说，对浮点数运算都会有专门的支持。对于X86-64来说，我们主要使用SSE指令集进行浮点数运算。这个指令集中，标量浮点数运算的指令，跟我们前面学过的📄运算的指令，是很相似的，所以我们很容易接受。这个指令集会用到16个128位寄存器，我们做双精度浮点数的标量运算时，只会用到这些寄存器的低64位。在寄存器分配算法中，我们要针对处理浮点数和整数的指令，分别分配寄存器。</p><p>第二，我们也学习了ABI对于处理浮点数的不同规定。主要表现在参数传递和返回值上。参数传递可以使用xmm0~xmm7共8个寄存器，返回值可以使用xmm0寄存器。其他方面，比如栈桢格式方面，与之前我们学过的知识点没有什么区别。</p><p>最后，我们学习了浮点数的编码标准。根据IEEE 754标准，双精度浮点数使用1个符号位、11个指数位和52个有效数字位构成的。在这里，你最好能够了解如何手工计算出一个浮点数的存储格式，这会让你加深对这个知识点的理解。而且，我建议你不要忽略这个知识点。因为当你能对编码格式了然于胸的时候，会有助于你更顺畅地理解使用到浮点型字面量的汇编代码，也有助于你理解CPU是如何处理浮点数的。</p><h2>思考题</h2><p>到现在，我们的课程已经讲到了整型和双精度浮点型这两种数据类型，它们都得到了X86架构的CPU的支持。你能不能查一下，X86架构的CPU还支持哪些数据类型呢？处理这些数据类型的指令都有哪些？这些在Intel手册的第一卷都能查到。欢迎你在留言区分享你的发现。</p><p>欢迎你把这节课分享给更多感兴趣的朋友。我是宫文学，我们下节课见。</p><h2>资源链接</h2><p>这节课涉及的代码都在<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/26/asm_x86-64_d.ts\">asm_x86-64_d.ts</a>中。这个代码文件是复制了asm_x86-64.ts，把它改成了支持double类型的版本。</p>","neighbors":{"left":{"article_title":"25｜增强编译器前端功能第4步：综合运用多种语义分析技术","id":425353},"right":{"article_title":"27｜增加更丰富的类型第2步：如何支持字符串？","id":426846}}},{"article_id":426846,"article_title":"27｜增加更丰富的类型第2步：如何支持字符串？","article_content":"<p>你好，我是宫文学。</p><p>今天我们继续来丰富我们语言的类型体系，让它能够支持字符串。字符串是我们在程序里最常用的数据类型之一。每一门高级语言，都需要对字符串类型的数据提供充分的支持。</p><p>但是，跟我们前面讨论过的整型和浮点型数据不同，在CPU层面并没有直接支持字符串运算的指令。所以，相比我们前面讲过的这两类数据类型，要让语言支持字符串，我们需要做更多的工作才可以。</p><p>那么，在这一节课里，我们就看看要支持字符串类型的话，我们语言需要做哪些工作。在这个过程中，我们会接触到对象内存布局、内置函数（Intrinsics），以及字符串、字面量的表示等知识点。</p><p>首先，我们来分析一下，在这种情况下，我们的编译器和运行时需要完成哪些任务，然后我们再依次完成它们就可以了。</p><h2>任务分析</h2><p>你可以看到，在一些强调易用性的脚本语言里，字符串常常作为内置的数据类型，并拥有更高优先级的支持。比如，在JavaScript里，你可以用+号连接字符串，并且，其他数据类型和字符串连接时，也会自动转换成字符串。这比在Java、C等语言使用字符串更方便。</p><p>为了支持字符串类型，实现最基础的字符串操作功能，我们就需要解决下面这几个技术问题：</p><p><strong>第一，如何在语言内部表示一个字符串？</strong></p><!-- [[[read_end]]] --><p>在像JavaScript、Java、Go和C#这样的高级语言中，所有的数据类型可以分为两大类。一类是CPU在底层就支持的，就像整数和浮点数，我们一般叫做基础类型（Primitive Type）或者叫做值类型（Value Type）。</p><p>这些类型可以直接表示为指令的操作数，在赋值、传参的时候，也是直接传递值。比如，当我们声明一个number类型的变量时，我们在语言内部用CPU支持的双精度浮点数来存储变量的值就可以了。当给变量赋值的时候，我们也是把这个double值用mov指令拷贝过去就行。</p><p>但对于基础类型之外的复杂数据类型来说，它们并不能受到CPU指令级别的直接支持。所以，我们就需要设计，当我们声明一个字符串，以及给字符串赋值的时候，它对应的确切操作是什么。</p><p>那么计算机语言的设计者，通常会怎么做呢？我们要<strong>把这些复杂数据类型在内部实现成一个内存对象</strong>，而变量赋值、传参这样的操作，实际上传递的是对象的引用，对象引用能够转换为对象的内存地址。</p><p>所以，<strong>从今天这节课开始，我们也将正式支持对象机制</strong>。其实，string也好，数组也好，还是后面的自定义类型也好，它们在内存里都是一个对象。当进行赋值操作的时候，传递的都是对象的引用。那这个时候，我们就需要设计对象的内存结构，以及确定什么是对象的引用。</p><p><strong>第二，在运行时里提供一些内置函数，用于支持字符串的基本功能。</strong></p><p>为了支持字符串类型的数据，我们要能够支持字符串对象的创建、字符串拼接、其他类型的数据转为字符串，还有字符串的比较，等等功能。这些功能是以内置函数（intrincics）的形式来实现的。编译成汇编代码的时候，我们要调用这些内置函数来完成相应的功能。</p><p><strong>第三，我们还要处理一些编译器后端的工作。</strong></p><p>在编译器的后端方面，我们要能生成对字符串进行访问和处理的汇编代码。这里面的重点就是，我们要知道如何在汇编代码里表示字符串字面量，以及如何获取字符串字面量的地址。</p><p>好了，任务安排妥当了，我们开始行动吧。首先我们来看第一个任务，如何在语言内部表示一个字符串类型的数据。</p><h2>如何表示一个字符串</h2><p>这个问题其实又包含三个子问题：字符编码的问题、string对象的内存布局，以及如何来表示一个对象的引用。</p><p><strong>首先，我们看看字符的编码问题。</strong></p><p>我们知道，CPU只知道0101这些值，并不知道abcd这些概念。实际上，是我们人类给每个字符编了码，让CPU来理解的。比如规定65代表大写字母a，97代表小写字母a，而48代表字符0，这就是广为使用的ASCII编码标准。但要支持像中文这么多的字符，ASCII标准还不够用，就需要Unicode这样的编码标准。</p><p>不过，在我们当前的实现中，我们还是先做一些简化吧，先不支持Unicode，只支持ASCII码就好了。这样，在内存里，我们只需要用一个字节来表示字符就行了，这跟C语言是一样的。至于Unicode，我们后面再支持。毕竟我们的语言PlayScript，是一个开源项目，会继续扩展功能。你也可以走在我前面，自己先去思考并实现一下怎么支持Unicode编码。</p><p><strong>第二，我们看看string的内存布局。</strong></p><p>如何在内存里表示一个字符串呢？</p><p>我们站在巨人的肩膀上，看看C语言是怎么做的。在C语言中，字符串在内存里就相当于一个char的数组，这个数组以0结尾。所以，“Hello”在内存里大概是这样保存的，加起来一共是6个字节：</p><p><img src=\"https://static001.geekbang.org/resource/image/1c/39/1cc34a2ec21c28bc8bb2687b36764f39.png?wh=1194x254\" alt=\"图片\"></p><p>我们也可以借鉴C语言的做法，用一个数组来表示字符串。不过，C语言需要程序员自己去处理字符串使用的内存：要么通过声明一个数组，在栈里申请内存；要么在堆里申请一块内存，使用完毕以后再手工释放掉。</p><p>而JavaScript是不需要程序员来手工管理内存的，而是采用了自动内存管理机制。自动内存管理机制管理的是一个个内存对象。当对象不再被使用以后，就可以被回收。</p><p>那么我们的设计，也必须实现自动的内存管理，因为TypeScript并没有底层的内存管理能力。</p><p>说到内存对象，我们还有一个设计目标，就是在语言内部，对各种类型的对象都有统一的管理机制，包括统一的内存管理机制、统一的运行时类型查询机制等等。这样，才能铺垫好TypeScript对象化的基础，并在后面实现更丰富的语言特性。所以，我们就需要对如何在内存里表示一个对象进行一下设计。</p><p>这方面，我们又可以参考一下其他语言是怎么做的。比如，在Java等语言里，对象都有一些统一的内存布局设计。其典型特征，就是每个对象都有一个固定的对象头，对象头之后才是对象的实际数据。</p><p><img src=\"https://static001.geekbang.org/resource/image/ee/fd/ee3ae5eb88c69e046aa57aa95c8f93fd.png?wh=260x308\" alt=\"图片\"></p><p>对象头里面保存了一些信息，用来对这个对象进行管理。进行哪些管理呢？首先是自动内存管理。对象头里有一些标志位，是用于垃圾收集程序的。比如，通过算法来标记某个对象是否是垃圾。我们在后面会具体实现一个垃圾收集算法，那个时候就会用到这些标志位。</p><p>标志位还有一个用途就是并发管理。你可以用一些特殊的指令，锁住一个对象，使得该对象在同一时间只可以被一个线程访问。在锁住对象的时候，也要在对象头做标识。此外，对象头里还有引用了类的定义，这样我们就可以在运行时知道这个对象属于哪个类，甚至通过反射等元编程机制去动态地调用对象的方法。</p><p>我们可以参考一下Java对象头的设计。它包含类指针和标志位两个部分。类指针指向类定义的地址。标志位就是内部分割成多个部分，用来存放与锁、垃圾收集等标记，还会存放对象的哈希值。</p><p><img src=\"https://static001.geekbang.org/resource/image/35/e7/35ca8dffeb3ce2e96d23bb5985b90de7.png?wh=1004x302\" alt=\"图片\"></p><p>当然，其他语言的对象，也都有类似的内存布局设计。我在<a href=\"https://time.geekbang.org/column/intro/100052801\">《编译原理实战课》</a>中，对Java、Python和Julia等语言的对象内存布局都做了讨论，如果你感兴趣可以去看看。</p><p>参考这些设计，我们也可以做出自己的设计。在PlayScript中，我们首先设计一个Object对象，里面有一个标志位的字段和一个指向对象的类定义的指针。我们后面再探讨它们的用途。</p><pre><code class=\"language-plain\">//所有对象的对象头。目前的设计占用16个字节。\ntypedef struct _Object{\n    //指向类的指针\n    struct _Object * ptrKlass; \n\n    //与并发、垃圾收集有关的标志位。\n    unsigned long flags;        \n}Object;\n</code></pre><p>所有对象都要继承自Object对象，字符串对象也不例外。我们把字符串对象叫做PlayString，其数据结构中包含了字符串的长度。真实的字符串数据是接在PlayString之后的。而且，我们基于PlayString的地址，就能计算出字符串的存储位置，所以并不需要一个单独的指针，这样也就节省了内存空间。</p><pre><code class=\"language-plain\">typedef struct _PlayString{\n    Object object;\n    //字符串的长度\n    size_t length;  \n         \n    //后面跟以0结尾的字符串，以便复用C语言的一些功能。实际占用内存是length+1。\n    //我们不需要保存这个指针，只需要在PlayString对象地址的基础上增加一个偏移量就行。\n    //char* data;     \n}PlayString;\n</code></pre><p>采用这个结构后，实际上PlayString的内存布局如下。对象头占16个字节，字符串长度占4个字节，其余的才是字符串数据，占用空间的大小是字符串的长度再加1个字节：</p><p><img src=\"https://static001.geekbang.org/resource/image/76/5b/7665e4f02b90ef9ec93958a52799ae5b.png?wh=476x414\" alt=\"图片\"></p><p>不过，在这里，我们还有一个技术细节需要做一下决策。</p><p>C语言中是以0结尾的数组来表示一个字符串的。所以，在C语言中，我们每次为字符串申请内存的时候，都要多申请一个字节，用于存放字符串的结尾标志，也就是0。那么，在我们自己实现的语言里，是否需要也多申请一个字节的空间，也在字符串后面放一个0呢？</p><p>本质上是不需要的。因为我们已经用了一个字段来表示字符串的长度。不过，像打印字符串这种功能，我们想直接使用C语言的标准函数来实现，所以还是决定采用C语言存储字符串的格式，尽管这可能会浪费一点存储空间。当然你也可以不使用这个设计，但在实现字符串输出等功能的时候，就需要去做额外的工作了。</p><p><strong>好了，我们已经设计出了字符串对象的内存布局。那么再看看最后一个问题，如何表示一个对象引用？</strong></p><p>我们前面也说了，当我们给string或者其他以对象格式保存的变量赋值的时候，传递的实际是个对象引用。那这个对象引用到底是什么呢？</p><p>其实我们知道，不管对象引用怎么设计，都必须能够通过对象引用获得对象的地址，以便操作对象内部的数据。不过在具体实现的时候，理论上有很多种可能性。</p><p>比如，你可以给所有在系统中创建的对象编号，在内存里通过某个数据结构来保存对象编号和内存地址的关系，再通过编号来查找出对象的内存地址。</p><p>不过，大多数语言，就是直接使用内存地址来作为对象引用的，因为这样可以用最快的速度访问对象的内容，免去了计算对象地址的额外工作量。</p><p>我们的实现，也采用同样的设计，即直接拿内存地址作为对象的引用。在64位模式下，内存地址是64位的，那这个对象引用就可以用一个64位的长整型表示。</p><p>不过，直接以内存地址作为对象引用，有一个潜在的、需要考虑的技术问题，就是<strong>垃圾收集算法</strong>。有的垃圾收集算法会在内存里移动对象，从一个内存区域拷贝到另一个区域。这个时候，对象的内存地址就会改变，也就是对象引用会改变。这个时候，就需要我们把所有指向这个对象的引用都修改一遍才行。</p><p>好了，关于如何在语言内部表示字符串对象，我们就讨论到这里。接下来，我们看看运行时和内置函数方面的工作。</p><h2>运行时和内置函数</h2><p>为了支持对string对象进行处理，我们需要实现几个内置函数，分别用于创建字符串对象、字符串连接，以及从number类型转成字符串类型：</p><pre><code class=\"language-plain\">//创建指定长度的字符串\nPlayString* string_create_by_length(size_t length);\n//连接字符串\nPlayString* string_concat(PlayString* str1, PlayString* str2);\n//数字型转字符串\nPlayString* double_to_string(double num);\n</code></pre><p>在这些创建PlayString对象的函数代码里，你可以更加清楚地看到内存是如何布局的。总的来说，我们是一次性地申请了PlayString对象需要的所有内存，这样可以减少内存申请的次数，提高内存访问的性能。我们在实现C语言版本的虚拟机的时候，已经体会到这个技术点的重要性。而真正的字符串数据是接在PlayString对象之后的。</p><p>你可能也注意到了，我不止一次地提到了内置函数这个概念。那什么是内置函数呢？跟println这样的函数有什么区别呢？println不也是我们在语言里预先提供的函数吗？</p><p>其实，我们刚才提到的这几个函数，包括创建字符串对象的函数、字符串连接的函数，跟println这样的函数是不一样的。哪里不一样呢？println是可以由程序员直接使用的。而像刚才那几个函数，一般只是由编译器和运行时所使用的，程序员一般不能直接使用，所以它们就被称为“内置函数”。当我们在程序里使用+号来连接两个字符串的时候，编译器会自动去调用字符串连接的内置函数来实现这个功能，这个过程对程序员是透明的。</p><p>我们这里提到的内置函数，在一些编译技术有关的文章里通常叫做Intrinsics（在GCC里会被叫做Built-in）。可能直接叫它的英文名称，更不容易产生混淆。有些Intrinsics是直接用汇编代码编写的，这样性能更高，或者能使用一些特别的指令。</p><p>这些内置函数是一个语言的运行时的一部分。如果把程序静态编译，那么它们会以动态库的形式存在，或者直接编译进可执行文件里。如果采用虚拟机的方式运行，那么它们也是虚拟机的组成部分。</p><p>好了，实现完了运行时和内置函数，我们就可以生成汇编代码，让语言来支持字符串特性了！</p><h2>修改编译器后端</h2><p>在前一节课，我们实现了对浮点数的支持以后，你可能已经在修改编译器后端方面取得了一些经验，这些工作都是有共性的。</p><p>在今天这节课，我们主要关注两个技术点：<strong>一个是在汇编代码中保存字符串字面量，一个是在程序里访问这些字符串的地址</strong>。</p><p>首先看看字符串字面量的保存。</p><p>我们在程序里经常会用到字符串字面量，比如需要打印输出的提示信息，等等。那在汇编代码里是如何表达和使用它们的呢？</p><p>作为对比，我们回忆一下，我们在上节课曾经处理过浮点数字面量。它们不能直接作为立即数使用，而是保存在一个单独的文本段里，然后通过标签来访问它们的内存地址。</p><p>对字符串字面量的处理也很类似。你可以用C语言写一个很简单的字符串处理程序，看看生成的汇编代码是什么样子的。</p><p>我这里写了一个C语言的示例程序，它只简单地实现了一个字符串打印的功能：</p><pre><code class=\"language-plain\">#include &lt;stdio.h&gt;\nint main(){\n    printf(\"Hello PlayScript!\\n\");\n}\n</code></pre><p>这个例子编译后生成的汇编代码如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/f7/d5/f742a8771731933b3e287037817934d5.png?wh=1500x1176\" alt=\"图片\"></p><p>在这段代码里，你会看到一个单独的文本段，用来保存C语言格式的字符串。</p><pre><code class=\"language-plain\">.section\t__TEXT,__cstring,cstring_literals\n</code></pre><p>所以，采用C语言格式，就意味着每个字符串在内存中都是以0结尾的，这跟我们的设计是一样的。</p><p>接下来，你会看到两行。第一行是一个标签，用来引用这个字符串常量。第二行用了一个.asciz伪指令，后面带着字符串具体的值。</p><pre><code class=\"language-plain\">L_.str:                                 ## @.str\n    .asciz  \"Hello PlayScript!\"\n</code></pre><p>到这里，我们就知道了。<strong>字符串字面量和上一节的浮点数字面量一样，都是保存在文本段的。在编译之后，它们就会进入到可执行文件中</strong>。</p><p>知道了这个原理后，其实你就可以搞点黑客小技巧了。比如，你可以用工具修改二进制文件里的字符串常量，篡改程序里显示的信息。</p><p><img src=\"https://static001.geekbang.org/resource/image/48/c0/483842c0aff5749fba5fbaa0976d8dc0.png?wh=1672x544\" alt=\"图片\"></p><p>同理，你还可以修改可执行程序中数据区里的一些数据。很多玩游戏的同学会使用这个手段，来修改自己的游戏参数，让自己的账号具备“超能力”。</p><p>从这里你也可以看到，<strong>设计一门计算机语言的时候，其实你还要考虑程序的安全因素</strong>。从这个角度看，现代很多语言都采用托管的方式运行，而不是直接编译成在操作系统上运行的可执行程序，这在安全方面是有一些优势的。不过安全性就是另一个话题了，我们不多展开。从这里你能再次体会到，了解一些底层实现机制，能帮助你对很多技术问题的理解更深刻。</p><p>回到原来的话题。现在，我们已经知道如何来存储字符串字面量了。<strong>那么如何在汇编代码里访问字符串呢？</strong></p><p>要想访问字符串，我们必须获取字符串的地址。在上面的汇编代码里，你会看到一个leaq指令，也就是64位的lea执行。</p><p>lea是Load Effective Address的意思。这个指令能够进行内存地址的计算，并把计算结果保存到寄存器里。我们之前就曾经讨论过如何用lea指令来做加法运算。但它真正的用途其实是计算内存地址的。在这里，我们可以用lea指令取得字符串字面量的地址，然后把这个地址作为参数传递给打印函数。</p><p>对于我们的语言来说，只要我们获取了字符串的地址，接下来就可以做很多其他的事情了，包括：创建我们内置的PlayString对象，以及将两个PlayString做拼接、生成新的字符串对象，等等。</p><p>懂得原理之后，我们再去修改生成汇编的程序。你可以重点看一下对StringLiteral对象和+号运算符的处理。</p><p>在处理StringLiteral时，我们首先把字符串保存到常量区，然后生成一个PlayString对象，并把对象的地址作为一个操作数返回。</p><pre><code class=\"language-plain\">visitStringLiteral(stringLiteral:StringLiteral):any{\n    //加到常数表里\n    if (this.asmModule != null){\n        //把字符串字面量保存到模块中。基于这些字面量可以生成汇编代码中的一个文本段。\n        let strIndex = this.asmModule.stringConsts.indexOf(stringLiteral.value as string);\n        if( strIndex == -1){\n            this.asmModule.stringConsts.push(stringLiteral.value as string);\n            strIndex = this.asmModule.stringConsts.length - 1;\n        }\n\n        //新申请一个临时变量\n        let tempVar = this.allocateTempVar(getRegisterKind(stringLiteral.theType as Type));\n\n        //用leaq指令把字符串字面量加载到一个变量（虚拟寄存器）\n        let inst = new Inst_2(OpCode.leaq, new Oprand(OprandKind.stringConst, strIndex), tempVar);\n        this.getCurrentBB().insts.push(inst);\n\n        //调用一个内置函数来创建PlayString\n        let args:Oprand[] = [];\n        args.push(tempVar);\n\n        //调用内置函数，返回值是PlayString对象的地址\n        return this.callIntrinsics(\"string_create_by_str\", args);\n    }\n}\n</code></pre><p>在处理+号时，如果类型是String，那么就调用内置函数实现字符串的连接。</p><pre><code class=\"language-plain\">switch(bi.op){\n    case Op.Plus: //'+'\n        if (bi.theType === SysTypes.String){ //字符串加\n            let args:Oprand[] = [];\n            args.push(left);\n            args.push(right);\n            this.callIntrinsics(\"string_concat\", args);\n        }\n    ...\n}\n</code></pre><p>现在，我们的语言就能进行基本的字符串处理了。你可以写几个测试程序，并编译成可执行文件试试看，比如下面这个示例程序：</p><pre><code class=\"language-plain\">let s1 = \"Hello\";\nlet s2:string;\ns2 = \" PlayScript!\";\nlet s3 = s1 + s2;\nprintln(s3);\n</code></pre><h2>课程小结</h2><p>好了，今天的内容就这些了。为了实现对字符串的支持，你要掌握下面这些知识点：</p><p>首先，你要知道如何表示字符串。这里面涉及三个技术点。第一个技术点，是如何给字符编码，简单的就是采用ASCII编码，复杂一点，就要支持unicode这样的编码。第二个技术点，是如何把字符串作为对象在内存中管理。为此，我们设计了一个标准的内存结构，每个对象都有标准的对象头。这个对象头会被用于内存管理、并发管理、元编程等功能。我们后面几节课的数组对象、自定义类等，也都要遵循这个内存结构。第三个技术点，是如何表达对象的引用。在PlayScript里，我们就直接用对象的内存地址就行了。</p><p>第二，为了支持字符串对象的创建、连接等操作，我们需要实现几个内置函数。内置函数叫做Intrincics，是在语言内部被使用的函数，一般不由程序员直接使用。</p><p>第三，我们学习了如何在汇编代码中保存和访问字符串常量。字符串常量是保存在程序的文本段里，可以用标签访问。我们可以用leaq指令和rip寄存器来计算字符串常量的地址。</p><p>最后，其实针对字符串处理，我们还有两个遗留问题：</p><p>一个问题是，我们在程序里只为字符串对象申请了内存，从来没有释放过，这显然会造成内存泄漏。这个问题我们放在内存管理的部分再去解决。</p><p>第二个问题是我们目前只支持ASCII编码，未来我们会扩展到支持Unicode编码。</p><h2>思考题</h2><p>对象的内存布局设计，是计算机语言的一个重要设计决策。在这节课，我们讨论了Java的对象布局设计，作为我们实现的参考。在这里，我想问一下，你熟悉的语言，它的对象内存布局有什么特点？有哪些你喜欢或者不喜欢的地方？欢迎在留言区分享你的观点。</p><p>欢迎你把这节课分享给更多感兴趣的朋友，我是宫文学，我们下节课见。</p><h2>资源链接</h2><p>1.这节课的<a href=\"https://gitee.com/richard-gong/craft-a-language/tree/master/27\">示例代码目录</a>；</p><p>2.对象头有关的代码，在<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/27/rt/object.h\">rt/object.h</a>；</p><p>3.PlayString有关的内置函数，在<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/27/rt/string.h\">rt/string.h</a>、<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/27/rt/string.c\">rt/string.c</a>；</p><p>4.对编译器后端的修改，仍然要查看<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/27/asm_x86-64_d.ts\">asm_x86-64_d.ts</a>。</p>","neighbors":{"left":{"article_title":"26｜增强更丰富的类型第1步：如何支持浮点数？","id":426150},"right":{"article_title":"28｜增加更丰富的类型第3步：支持数组","id":427480}}},{"article_id":427480,"article_title":"28｜增加更丰富的类型第3步：支持数组","article_content":"<p>你好，我是宫文学。</p><p>前面我们已经给我们的语言，增加了两种数据类型：浮点数和字符串。那么，今天这一节课，我们再继续增加一种典型的数据类型：数组。</p><p>数组也是计算机语言中最重要的基础类型之一。像C、Java和JavaScript等各种语言，都提供了对数组的原生支持。</p><p>数组跟我们之前已经实现过的number、string类型的数据类型相比，有明显的差异。所以在这里，你也能学到一些新的知识点，包括，如何对数组做类型处理、如何设计数组的内存布局，如何正确访问数组元素，等等。</p><p>在完成这节课的任务后，我们的语言将支持在数组中保存number和string类型的数据，甚至还可以支持多维数组。是不是感觉很强大呢？那就赶紧动手试一试吧！</p><p>那么这实现的第一步，我们需要修改编译器前端的代码，来支持与数组处理有关的语法。</p><h2>修改编译器前端</h2><p>在编译器前端，我们首先要增加与数组有关的语法规则。要增加哪些语法规则呢？我们来看看一个最常见的使用数组的例子中，都会涉及哪些语法特性。</p><pre><code class=\"language-plain\">let names:string[] = [\"richard\", \"sam\", \"john\"];\nlet ages:number[] = [8, 18, 28];\nlet a2:number[][] = [[1,2,3],[4,5]];\nfor (let i = 0; i&lt; names.length; i++){\n  println(names[i]);\n}\n</code></pre><!-- [[[read_end]]] --><p>在这个例子中，我们首先声明了一个字符串类型的数组，然后用一个数组字面量来初始化它。你还可以用同样的方法，声明并初始化一个number数组。最后，我们用names[i]这样的表达式来访问数组元素。</p><p>在这个例子中，你会发现三个与数组有关的语法现象，分别是<strong>数组类型</strong>、<strong>数组字面量</strong>和<strong>下标表达式</strong>。</p><p>首先是数组类型。在声明变量的时候，我们可以用string[]、number[]来表示一个数组类型。这个数组类型是一个基础类型再加上一对方括号[]。在这里，我们甚至还声明了一个二维数组。</p><p>所以，我们还需要扩展与类型有关的语法规则。你看看下面的语法规则，<strong>你可以这样表示数组类型：“primaryType ‘[’ ‘]’”。而primaryType本身也可以是一个数组类型，这样就能表达多维数组了，比如a[][]。</strong></p><pre><code class=\"language-plain\">primaryType : predefinedType | literal | typeReference | '(' type_ ')' | primaryType '[' ']' ;\n</code></pre><p>不过，这是一个左递归的文法，就会遇到我们之前学过的左递归问题。我们可以改写一下，变成下面的文法：</p><pre><code class=\"language-plain\">primaryType : primaryTypeLeft ('[' ']')* ;\nprimaryTypeLeft : predefinedType | literal | typeReference | '(' type_ ')' | primaryType  ;\n</code></pre><p>这样的话，我们每次解析完毕一个primaryTypeLeft以后，再看看后面有没有跟着一对方括号就行了。如果出现多对方括号，就表示这是一个多维数组。</p><p>第二个语法现象是数组字面量，比如string字面量[“richard”, “sam”, “john”]和number字面量[8, 18, 28]。</p><p>这里，我们也总结出了数组字面量的语法规则：<strong>每个数组字面量都是以方括号括起来的，方括号里面可以有一组元素，这些元素可以是一个表达式，或者是一个标识符，中间以逗号分割。</strong></p><pre><code class=\"language-plain\">primary:  literal | functionCall | '(' expression ')' | typeOfExp | arrayLiteral;\narrayLiteral : ('[' elementList? ']');\nelementList : arrayElement (','+ arrayElement)* ;\narrayElement : expression ','? ;\n</code></pre><p>你要注意最后一条语法规则“arrayElement : expression ‘,’? ;”。这条语法规则的意思是，数组中的最后一个元素，后面仍然可以跟一个逗号。比如上面的number数组等价于[8, 18, 28, ]。</p><p>第三个语法现象是下标表达式。我们可以用names[i]来引用数组的第i个元素。</p><p>所以，我们要扩展表达式的语法规则，<strong>让基础式后面可以跟上一对方括号，变成一个下标表达式</strong>。修改后的语法规则如下。这个文法的书写方式也同样避免了左递归。</p><pre><code class=\"language-plain\">expression: 'typeof' expression | assignment ('[' expression ']')* ;\n</code></pre><p>上面就是目前我们需要扩展的语法规则了。为了支持新的语法规则，我们要创建几个新的AST节点对象：一个是ArrayPrimType，代表数组类型节点；第二个是ArrayLiteral，代表数组字面量；还有一个是IndexedExp，表示像a[2]这样的带有index的下标表达式。</p><p>在这里，你要注意，凡是表达式后面跟一个[index]，都表示访问该表达式的第n个元素。这个表达式不一定是个数组，只要是能够用下标访问的对象就行。比如，你可以像下面的程序那样，用下标访问一个字符串中的字符。</p><pre><code class=\"language-plain\">let name = \"Richard\";\nname[1];   //返回'i'\n</code></pre><p>在补充了相应的AST节点以后，我们就可以根据语法规则修改语法解析程序了。你可以试着运行下面这个的测试程序，用“node play example.ts -v”命令，带上参数-v，打印出AST来看看。</p><pre><code class=\"language-plain\">let a: number[];    //数组类型\nlet b = 4;\na = [1, 2, 3+3, b]; //数组字面量，其中的元素可以是表达式\nprintln(a[2]);      //下标表达式\n</code></pre><p>在终端输出的AST如下图所示，我在里面标注了上面讨论到的几种AST节点。</p><p><img src=\"https://static001.geekbang.org/resource/image/df/dc/dfccd7b741bc8020e376950238d047dc.png?wh=1404x1182\" alt=\"图片\"></p><p>你还可以看看语法分析程序对多维数组的支持情况，比如下面的示例程序：</p><pre><code class=\"language-plain\">let a2:number[][] = [[1,2,3],[4,5]];  //二维数组\nprintln(a2);\nprintln(a2[1]);            //打印其中一个维度\nprintln(a2[0][2]);         //打印一个元素\n</code></pre><p>它的AST结构如下图所示，你要注意，数组类型、数组字面量和数组元素的引用都是如何形成层层嵌套的结构的。</p><p><img src=\"https://static001.geekbang.org/resource/image/f6/dc/f64a681fae422196fc8cfbd4166132dc.png?wh=1078x1254\" alt=\"图片\"></p><p>除了语法方面的工作以外，我们语义分析方面也要做一些增强，包括<strong>类型处理</strong>和<strong>左值分析</strong>等方面的工作。</p><p>为了实现类型处理，我们首先需要添加新的ArrayType类型。ArrayType类型会引用一个基础类型。到现在为止，我们的类型体系越来越丰富了，我把原来的类型体系图更新了一版，你可以看一下：</p><p><img src=\"https://static001.geekbang.org/resource/image/cf/43/cf23228f09b4a9356dcb637de4a11643.png?wh=968x876\" alt=\"图片\"></p><p>然后，在类型处理的时候，你还需要完成这几项工作。</p><p>首先，我们要能够根据类型声明的AST节点，计算出变量的类型。你可以参考<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/28/semantic.ts#L123\">TypeResolver</a>中的代码：</p><pre><code class=\"language-plain\">visitArrayPrimTypeExp(te:ArrayPrimTypeExp):any{\n    //求出基础类型\n    let t = this.visit(te.primType) as Type;\n\n    //创建ArrayType\n    let t1 =  new ArrayType(t);\n    \n    return t1;\n}\n</code></pre><p>第二，要计算出数组字面量的类型，并检查类型是否一致。比如，下面的示例程序中，数组字面量的类型是stirng[]，而变量a3的类型是number[]，所以会检查出类型错误出来。</p><pre><code class=\"language-plain\">let a3:number[] = [\"Hello\", \"PlayScript\"];\n</code></pre><p>并且，如果数组字面量中的个别元素跟类型声明不一致，也需要能够检查出来：</p><pre><code class=\"language-plain\">let a4:number[] = [2, \"PlayScript\"];\n</code></pre><p>具体实现你可以参考<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/28/semantic.ts#L512\">TypeChecker</a>中的<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/28/semantic.ts#L1062\">visitArrayLiteral</a>和<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/28/semantic.ts#L715\">visitBinary</a>方法。代码有点多，我就不贴在文稿里了，你可以点击链接查看。</p><p>第三，我们还要能够根据下标表达式，计算每个表达式节点的类型。比如，在下面的示例程序中，a2、a2[1]、a2[0][2]的类型就需要被精确地计算出来，这样才能在编译器后端生成正确的汇编代码。</p><pre><code class=\"language-plain\">let a2:number[][] = [[1,2,3],[4,5]];\nprintln(typeof a2);        //类型是number[][]\nprintln(typeof a2[1]);     //类型是number[]\nprintln(typeof a2[0][2]);  //类型是number\n</code></pre><p>你可以在语义分析后的AST中看到这些表达式的类型信息，我在图片中都标注出来了。</p><p><img src=\"https://static001.geekbang.org/resource/image/24/f1/241810b96e75c4b4f6aed3950d9ec7f1.png?wh=996x1252\" alt=\"图片\"></p><p>你也可以看看typeof运算所打印出的结果。不过，TypeScript的typeof运算符输出的类型信息比较有限，只能看出a2和a2[1]是object类型，而a2[0][2]是number类型，缺少更多的细节。</p><p><img src=\"https://static001.geekbang.org/resource/image/9d/00/9df8a569b7a6a8111f217a0450809f00.png?wh=488x190\" alt=\"图片\"></p><p>最后，我们还要让ArrayType能够像NamedType、ValueType等类型一样，采用集合运算的方法进行类型计算，以支持联合类型、类型窄化等场景。这里我就先不展开了，你可以看看<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/28/types.ts\">TypeUtil</a>中的实现。</p><p>好了，完成与类型有关的处理以后，我们还要增强一下另一个功能，就是<strong>左值分析</strong>。</p><p>你还记得什么是左值吗？在表达式中，能够出现在赋值运算符左边的，就叫做左值。左值相当于是一个变量的地址。你通过这个地址，可以修改变量的值。</p><p>在下面的示例程序中，我们可以给数组元素赋值，那么这些数组元素也必须是左值才可以：</p><pre><code class=\"language-plain\">let a2:number[][] = [[1,2,3],[4,5]];\na2[0] = [4,5,6];\na2[0][1] = 7;\n</code></pre><p>具体的实现，可以看一下<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/28/semantic.ts#L437\">LeftValueAttributor</a>中的相关代码。</p><p>好了，完成上面工作以后，我们对编译器前端的增强就差不多了。接下来我们看看运行时的功能。</p><h2>增强AST解释器</h2><p>我们首先看看AST解释器。我们之前版本的AST解释器并不支持数组操作，所以我们把这个功能补上，以便跟编译成可执行程序的版本互相对比和验证。</p><p>要增强AST解释器，其实要做的工作还真不是太多。主要就是增加了<strong>对下标表达式（IndexedExp）的处理</strong>。它能返回下标表达式的值，包括左值和右值，分别用于对数组元素的写和读。</p><pre><code class=\"language-plain\">visitIndexedExp(exp:IndexedExp):any{\n    //下标应该是个整数\n    let index = this.visit(exp.indexExp);\n    \n    let v = this.visit(exp.baseExp);\n    if (exp.isLeftValue){ //返回左值\n        if (v instanceof VarSymbol){\n            return new ArrayElementAddress(v, [index]);\n        }\n        else if (v instanceof ArrayElementAddress){\n            let indices = v.indices.concat([index]);\n            return new ArrayElementAddress(v.varSym, indices);\n        }\n        else{\n            console.log(\"Runtime error, '\" + exp.baseExp.toString() + \"' should return a left value\");\n        }\n    }\n    else{ //返回右值\n        if (v instanceof VarSymbol){\n            let values = this.getVariableValue(v) as [];\n            return values[index];   \n        }\n        else{ //如果是多维数组，比如a[0][1]，那么访问baseExp的时候(a[0])，会返回一个一维数组。\n            let values = v as[];\n            return values[index];\n        }\n    }\n}\n</code></pre><p>这样修改完毕AST解释器以后，你可以用一个小小的测试程序看看它能否正常运行。比如你可以运行一下面的测试程序：</p><pre><code class=\"language-plain\">//字符串数组\nlet names:string[] = [\"richard\",\"sam\", \"john\"];\nnames[1] = \"julia\";      //数组元素赋值，左值\nfor (let i = 0; i&lt; 3; i++){\n   println(names[i]);    //读取数组元素，右值\n}\n\n//number数组\nlet ages:number[] = [8, 18, 28];\nages[2] = 38;           //数组元素赋值，左值\nlet sum:number = 0;\nfor (let i = 0; i&lt;3; i++){\n    sum = sum + ages[i];//读取数组元素，右值\n}\nprintln(sum);\n\n//二维数组\nlet a:number[][] = [[1,2,3],[4,5]];  //二维数组\na[0] = [4,5,6];          //修改一个维度\na[0][1] = 7;             //修改一个元素\nprintln(a);              //打印二维数组\nprintln(a[1]);           //打印一维数组\nprintln(a[0][2]);        //打印一个元素\n</code></pre><p>这个程序的输出结果我放在下面了，你能看到它确实能够处理数组了。</p><p><img src=\"https://static001.geekbang.org/resource/image/e4/08/e48e8d0339386a88674b1e9a787f1e08.png?wh=488x338\" alt=\"图片\"></p><p>那接下来，我们再接再厉，让PlayScript能够把带有数组处理功能的程序编译成可执行文件。根据我们上两节课的经验，我们需要先设计一下与数组有关的内部对象以及相应的内置函数。</p><h2>运行时的功能：PlayArray对象和内置函数</h2><p>我们把内部的数组对象叫做PlayArray。PlayArray的设计与上一节课的PlayString有点类似，你可以看看它的代码：</p><pre><code class=\"language-plain\">typedef struct _PlayArray{\n    Object object;\n    //字符串的长度\n    size_t length;  \n\n    //后面跟着的是数组数据\n    //我们不需要保存这个指针，只需要在PlayArray对象地址的基础上增加一个偏移量就行。\n    // void * data;     \n}PlayArray;\n</code></pre><p>从代码中你能看出，PlayArray对象有一个对象头、还有一个字段记录数组中的元素个数，再后面跟着的就是具体的数组数据。</p><p>并且，我们也提供了几个内置函数，来支持基本的数组操作。其中最重要的就是创建指定长度的数组。我还写了一个宏来计算数组中某个元素的地址，这样我们就能对数组进行读写操作。</p><pre><code class=\"language-plain\">//创建指定元素个数的数组\nPlayArray* array_create_by_length(size_t length);\n\n//获取数组中某个元素的地址\n#define PTR_ARRAY_ELEM(parr, index) (void *)(parr + sizeof(Object) + sizeof(size_t) + sizeof(double)*index)\n</code></pre><p>在PlayArray对象的设计中，有一个问题需要你注意，就是怎么存储不同类型的数组元素。比如，PlayScript现在已经支持了浮点型数据和字符串数据，那如何用同一个PlayScript对象来存储这两种数据呢？</p><p>其实，对PlayArray对象来说，它并不关心存储的到底是什么类型的元素，它只关心这些元素占据多少个字节的内存，便于申请内存。</p><p>对于double数据来说，它们占据8个字节64位。而对于PlayString对象来说，我们只需要存储对象的引用，也就是对象的内存地址，这个地址也是8个字节64位的。所以，现在这个版本的PlayArray中，我们暂且认为每个元素占据8个字节就好了。如果数组大小是n，那就要为数组数据申请n*8个字节的内存。</p><p>你也可以看到，在上面的宏中，如果你要获取数组元素的地址，会返回一个void *。你可以把它强制转换成其他类型，比如转换成double *，就能存取double型的数据。转换成PlayScript *<em>，就能存取字符串对象的引用，也就是PlayScript</em>。</p><p>我用C语言做了一个示例程序<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/28/array.c\">array.c</a>，来测试PlayArray对象有关的功能。你可以看一下我是如何获取数组元素的地址，并给数组元素赋值的。比如下面这个程序就是给数组元素赋double值：</p><pre><code class=\"language-plain\">//创建示例的number数组\nPlayArray* sample_array_double(){\n    //创建数组\n    PlayArray * parr = array_create_by_length(3);\n\n    //给数据元素赋值\n    *((double *)PTR_ARRAY_ELEM(parr,0)) = 5;\n    *((double *)PTR_ARRAY_ELEM(parr,1)) = 10.5;\n    *((double *)PTR_ARRAY_ELEM(parr,2)) = 10.6;\n\n    return parr;\n}\n</code></pre><p>然后你可以再把这些数据从double数组里读出来，并进行汇总。</p><pre><code class=\"language-plain\">//把number数组的元素汇总\ndouble sum_array_double(PlayArray * parr){\n    //读取数据并汇总\n    double sum = 0;\n    for (int i = 0; i&lt; parr-&gt;length; i++){\n        sum += *((double *)PTR_ARRAY_ELEM(parr,i));\n    }\n\n    return sum;\n}\n</code></pre><p>对于字符串数组，我们也可以进行类似的处理。只不过，现在存取的对象是PlayScript*，也就是字符串引用。</p><pre><code class=\"language-plain\">//创建示例的字符串数组\nPlayArray* sample_array_string(){\n //创建数组\n    PlayArray * parr = array_create_by_length(2);\n\n    //给数据元素赋值\n    *((PlayString **)PTR_ARRAY_ELEM(parr,0)) = string_create_by_cstr(\"Hello\");\n    *((PlayString **)PTR_ARRAY_ELEM(parr,1)) = string_create_by_cstr(\" PlayScript!\");\n\n    return parr;\n}\n\n//把字符串数组的元素拼接在一起，形成一个新的字符串\nPlayString* concat_array_string(PlayArray * parr){\n    PlayString* pstr;\n\n    if (parr-&gt;length &gt; 0)  pstr = *((PlayString**)PTR_ARRAY_ELEM(parr, 0));\n\n    for (int i = 1; i&lt; parr-&gt;length; i++){\n        PlayString* pstr1 = *((PlayString**)PTR_ARRAY_ELEM(parr, i));\n        pstr = string_concat(pstr, pstr1);\n    }\n\n    return pstr; \n}\n</code></pre><p>甚至，你还可以往数组里存其他数组的对象引用，这也就是多维数组的情况：</p><pre><code class=\"language-plain\">//创建一个示例的二维数组，其中一个维度是double类型，另一个维度是字符串数组\nPlayArray * sample_array_2d(){\n    //创建数组\n    PlayArray * parr = array_create_by_length(2);\n\n    *((PlayArray **)PTR_ARRAY_ELEM(parr,0)) = sample_array_double();\n    *((PlayArray **)PTR_ARRAY_ELEM(parr,1)) = sample_array_string();\n\n    return parr;\n}\n</code></pre><p>最后，你可以用make array命令，编译一下array.c示例程序，然后用./array来运行一下这个示例程序，看看它是否成功完成了与数组有关的操作，包括创建数组、往数组里存不同类型的数据，以及从数组里读取数据。</p><p>好，现在我们已经完成了运行时的准备工作了。现在只差最后一步工作了，就是修改编译器后端，来生成正确的汇编代码，从而编译成可执行文件。</p><h2>修改编译器后端</h2><p>在编译器的后端，为了支持数组运算，最重要的是完成下面几项工作：<strong>根据数组字面量来创建数组对象，获取数组元素的地址，以及对寄存器分配算法进行必要的调整</strong>。</p><p>我们先来看看第一项任务：把数组字面量转变成数组对象。</p><p>这是在<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/28/asm_x86-64.ts#L1436\">visitArrayLiteral</a>中处理的。首先，它要调用内置函数创建一个数组对象。接着，要再计算出数组元素的地址，以便给数组的元素赋值。你可以查看一下示例代码。</p><p>第二项任务，是获取数组元素的地址。</p><p>在array.c示例程序中，你已经看到，在读写数组元素的时候，我们必须获取数组元素的地址。在生成汇编代码的时候，我们也要完成类似的任务。</p><p>首先，我们要根据PlayArray对象的地址计算出数组数据的地址。你已经知道，所有对象头的大小是16个字节，而记录数组元素个数的length字段占据4个字节。所以，你可以用一条指令把PlayArray的地址加上20，得到数组数据的地址。</p><p>那怎么访问数组中的某个元素呢？我们在汇编代码中已经使用过内存访问的操作数，就是基于寄存器的值，再加上或者减去一个偏移量的形式。假设我们把数组数据的开头地址存放到rax寄存器里，那么数组的第一个元素的内存地址是(%rax)，第二个元素的地址是8(%rax)，第三个元素的地址是16(%rax)，依次类推。</p><p>不过，上面这种格式是间接内存访问的简化形式。如果你还记得间接内存地址访问的完整形式，那么上述两个步骤可以合并成一条指令，比如使用20(%rax,%rdi,8)这样的格式可以直接计算出数组元素的地址。其中，20是对象头的偏移量，%rdi的值假设是2，2指的是第二个数组元素，8指的是每个数组元素占据8个字节。所以最后的地址是：%rax + 2*8 + 20，正好就是第2个数组元素的地址。</p><p>第三项任务，是对寄存器分配算法进行必要的调整。</p><p>在对数组元素进行操作的时候，我们最好也先把它们挪到寄存器，在寄存器里进行相关计算。相关示例代码你可以查看<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/28/asm_x86-64.ts#L1636\">Lower类</a>。</p><p>在对编译器的后端进行了上述修改以后，你就可以用它来编译带有数组运算的代码，并且生成可执行程序了。你可以参考<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/28/example_array.ts\">example_array.ts</a>示例代码，用make example_array命令编译成汇编代码和可执行程序。你也可以多写点不同的程序玩一玩。</p><p>看着现在我们的语言能够支持复杂的、与数组有关的语法，甚至能支持多维数组，你会不会觉得很有成就感呢？</p><h2>课程小结</h2><p>这就是今天的所有的内容了。今天我们用了一节课的时间，给PlayScript增加了处理数组的能力。我建议你记住几个关键点：</p><p>首先，是语法处理方面的知识点。在今天的语法规则中，有两处规则如果处理不好，就会变成左递归文法。比如声明多维数组类型let a : number[][]时，以及访问多维数组元素时，如a[i][j]。你要看看我是怎么处理这两处文法的。在之前的课程中，我们处理连续赋值表达式，比如a=b=c的时候，我也使用了类似的文法和解析程序。如果后面有机会，我会把这个知识点再展开给你讲一讲。</p><p>第二，是内存布局设计方面的知识点。我们用一个统一的PlayScript对象来保存各种数据，包括基础数据number，以及以对象格式保存的String，甚至其他数组对象的引用。下一节课我们会讲到自定义对象，到时候你仍然可以把这些对象的引用保存到数组里。</p><p>第三，是关于如何访问数组的元素。在语义分析阶段，我们要能够区分左值和右值的场景。左值返回的是地址，而右值返回的是地址中的值。而在编译器的后端，你需要知道如何正确的计算数组元素的地址，从而转化成正确的操作数。</p><h2>思考题</h2><p>目前的设计中，数组中存放的元素的大小都是8个字节。如果我们需要存储其他长度的元素，比如4个字节的整型，应该如何修改当前的设计？哪些地方的程序也需要进行调整？欢迎在留言区分享你的观点。</p><p>欢迎把这节课分享给更多感兴趣的朋友。我是宫文学，我们下节课见。</p><h2>资源链接</h2><p><a href=\"https://gitee.com/richard-gong/craft-a-language/tree/master/28\">这节课的示例代码在这里！</a></p>","neighbors":{"left":{"article_title":"27｜增加更丰富的类型第2步：如何支持字符串？","id":426846},"right":{"article_title":"29｜面向对象编程第1步：先把基础搭好","id":428273}}},{"article_id":428273,"article_title":"29｜面向对象编程第1步：先把基础搭好","article_content":"<p>你好，我是宫文学。</p><p>到目前为止，我们的语言已经简单支持了number类型、string类型和数组。现在，我们终于要来实现期待已久的面向对象功能了。</p><p>在我们的课程中，为了实现编译器的功能，我们使用了大量自定义的类。最典型的就是各种AST节点，它们都有共同的基类，然后各自又有自己属性或方法。这就是TypeScript面向对象特性最直观的体现。</p><p>面向对象特性是一个比较大的体系，涉及了很多知识点。我们会花两节课的时间，实现其中最关键的那些技术点，比如声明自定义类、创建对象、访问对象的属性和方法，以及对象的继承和多态，等等，让你理解面向对象的基础原理。</p><p>首先，我们仍然从编译器的前端部分改起，让它支持面向对象特性的语法和语义处理工作。</p><h2>修改编译器前端</h2><p><strong>首先是对语法的增强</strong>。我们还是先来看一个例子，通过这个例子看看，我们到底需要增加哪些语法特性：</p><pre><code class=\"language-plain\">class Mammal{\n    weight:number;\n    color:string;\n    constructor(weight:number, color:string){\n        this.weight = weight;\n        this.color = color;\n    }\n    speak(){\n        println(\"Hello!\");\n    }\n}\n\nlet mammal = new Mammal(20,\"white\");\nprintln(mammal.color);\nprintln(mammal.weight);\nprintln(mammal.speak);\n</code></pre><!-- [[[read_end]]] --><p>在这个例子中，我们声明了一个class，Mammal。这个类描述了哺乳动物的一些基础属性，包括它的体重weight、颜色color。它还提供了哺乳动物的一些行为特征，比如提供了一个speak方法。</p><p>Mammal类还有一个特殊的方法，叫做构造方法。通过调用构造方法，可以创建类的实例，也就是对象。然后，我们可以访问对象的属性和方法。</p><p>其实TypeScript的类还有很多特性，包括私有成员、静态成员等等。这里我们还是先考虑一个最小的特性集合，先让语言支持最基础的类和对象特性。</p><p>看看这个示例程序，我们能总结出多个需要增强的语法点，包括类的声明、调用类的构造方法，this关键字，以及通过点符号来引用对象的属性和方法。</p><p>我们首先看看类的声明。我们提供了下面这些语法规则，来支持类的声明：</p><pre><code class=\"language-plain\">classDecl : Class Identifier classTail ;\nclassTail :  '{' classElement* '}' ;\nclassElement : constructorDecl| propertyMemberDecl;\nconstructorDecl : Constructor '(' parameterList? ')' '{' functionBody '}' ;\npropertyMemberDecl : Identifier typeAnnotation? ('=' expression)? ';'                  \n                   | Identifier callSignature  '{' functionBody '}' ;\n</code></pre><p>这些规则看似很多，但其实解析起来并不复杂。并且，很多基础成分在我们之前的函数声明的语法结构中都有了，比如参数列表（parameterList）、函数签名（callSignature）、函数体（functionBody）等等，所以这会给我们节省很多工作量。</p><p>第二，我们再看看如何调用类的构造方法来创建对象，比如“new Mammal(20,“white”)”这个表达式。</p><p>相关的语法规则如下：</p><pre><code class=\"language-plain\">primaryLeft: Identifier | functionCall | constructorCall |其他表达式\n</code></pre><p>第三，在构造方法里，我们可以使用一个特殊的this关键字。这个关键字被解析以后，也会形成一个表达式，就叫做This表达式。</p><pre><code class=\"language-plain\">primaryLeft: Identifier | functionCall | constructorCall | This | 其他表达式\n</code></pre><p>最后，我们需要用点符号来引用对象的属性和方法，比如用mammal.weight代表mammal对象的weight属性，这些都是我们平时很习惯使用的语法。</p><p>点号表达式跟上一节课的下标表达式一样，都是在别的表达式后面加个后缀，所以语法规则可以写成这样：</p><pre><code class=\"language-plain\">primary:  primaryLeft ('[' expression ']') | '.' expression)* ;\n</code></pre><p>好了，语法规则就是这些。</p><p>对应着这些语法规则，我们也需要增加一些AST节点，包括ClassDecl、ConstructorDecl、PropertyDecl、MethodDecl、ConstructorCall、ThisExp和DotExp等。</p><p>语法分析和AST节点的参考实现，你可以看看<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/29/parser.ts\">parser.ts</a>和<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/29/ast.ts\">ast.ts</a>。</p><p><strong>接下来，你肯定会猜到，我们还需要做一些语义分析的工作，包括再一次增强类型体系，以及符号表、引用消解等方面的工作，还要做一些必要的语义检查</strong>。</p><p>在示例程序中，我们每次使用class声明一个新的类，实际上就是创建了一个自定义的类型。接下来，我们就可以用这个类型来声明变量，并进行类型检查。</p><p>这就给我们的语义分析增加了一些工作量，这个工作叫做类型消解。也就是说，当我们每次使用一个自定类型的时候，要知道这个类型是在哪里声明的。这就不像number和string这样的内置的类型，我们每次见到它们都可以自动识别出来。所以我们要多做一点工作，建立类型的声明和使用之间的关系。这种消解工作跟变量的消解、函数的消解是差不多的，可以尽量复用之前的算法。</p><p>在类型消解之后，我们就可以利用类的声明信息来进行类型检查了。比如，你可以在程序里用点符号访问weight属性、color属性和speak()方法。但如果访问了没有定义过的属性或者方法，那就要报语义分析的错误。</p><p>除了这些，针对类的语义分析我们还有一些其他工作。比如，当我们创建对象的时候，对象的数据成员必须被正确地初始化。当然，那些可以取值为undefined的属性除外。所以，你需要使用我们<a href=\"https://time.geekbang.org/column/article/422442\">第22节课</a>学过的赋值分析技术，来完成这项工作。</p><p>好了，完成了语法分析和语义分析以后，编译器前端部分的工作就基本完成了。你可以运行我们的解析器，输出示例程序的AST看看。我把截屏放在了文稿里，并做了一些标注，方便你熟悉类的声明和类成员访问等语法对应的AST结构。</p><p><img src=\"https://static001.geekbang.org/resource/image/10/be/1067cb66d155d28372c9deb052e6d3be.png?wh=1408x1482\" alt=\"\"></p><p>完成了编译器前端的工作以后，我们接下来看看运行时方面需要做一些什么工作。首先，我们还是要升级一下AST解释器。</p><h2>升级AST解释器</h2><p>为了让AST解释器支持面向对象特性，我们需要做4个方面的工作，包括<strong>创建对象、在栈桢里保存对象数据、通过点符号来引用对象的属性和方法，以及执行对象的方法</strong>。</p><p>首先看创建对象的过程。你可以通过new关键字调用构造方法来创建对象。构造方法最重要的工作是初始化对象的属性。这里的具体实现，你可以参见<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/29/play.ts\">visitConstructorCall</a>方法。</p><p>不过，对象的属性不仅仅是在构造函数里初始化的。其实，你在声明类的时候，就可以给属性带上初始化表达式。所以，实际对象的初始化过程，是首先使用这些初始化表达式，来给对象属性赋值，之后才会执行构造方法。</p><p>我们再看看第二个工作，在栈桢里保存对象数据。这里我用了一个简单的Map对象，来建立对象的属性和数据的映射关系。</p><p>接着是第三项任务，就是访问对象的属性。访问对象的属性需要借助点符号表达式。点符号左边的表达式，能够返回一个对象引用。在AST解释器里，这个对象引用和其他变量一样，都是一个VarSymbol。基于这个VarSymbol，程序就可以从栈桢里找到对象的数据，也就是我们前面说到的Map对象。你可以在这个Map里查找对象属性的值。</p><p>最后，是执行对象的方法。执行对象的方法跟执行普通函数其实差不多。主要的区别，<strong>就是你必须给方法传递一个特殊的参数，也就是对象引用，具体来说就是一个VarSymbol</strong>。这样的话，你才可以在方法里用this.weight这样的表达式来访问对象的属性。这里的this，就是传到方法里的对象引用。</p><p>好了，实现完这些机制以后，AST解释器就顺利升级了。你可以用这个解释器运行一下前面的示例程序，输出结果如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/d7/dd/d791be44ede1bcec078d4f481f0534dd.png?wh=626x184\" alt=\"\"></p><p>那么，升级完AST解释器以后，我们再进一步，尝试把我们这节课的示例程序编译成可执行程序。首先，我们仍然要设计一下对象的内存布局，并实现几个必要的内置函数。</p><h2>内存布局和内置函数</h2><p>在前面两节课，我们已经实现过了字符串和数组的内存结构。这些知识点我们今天仍然可以借鉴，降低我们这节课在设计和实现上的工作量。</p><p>我们用PlayObject来保存对象的数据。每个PlayObject跟PlayString、PlayArray等一样，也具备公共的对象头。在对象头之后，就是对象的属性数据。</p><p>目前我们可以存储4种类型的属性，包括number型、string型、数组型和其他的自定义对象。它们都有一个共同的特点，就是<strong>都需要在PlayObject中占据8个字节空间，用来保存数据或对象引用</strong>。这是一个好消息，因为我们可以先简化对象的设计，不用考虑太多字节对齐等话题。</p><p>不过，如果你想了解字节对齐，你可以去参考一下C语言的结构体是如何安排每个字段在内存中的位置的。这些字段并不是一个挨着一个来存放的，相反，每个字段的其实地址，往往可以被4字节、8字节等整除，这就导致字段之间可能存在空隙。这样做的原因，是让CPU在读取字节对齐的数据的时候速度更快，只需要在内部做一次读取操作就可以完成了。而读取不对齐的数据，CPU在内部需要的读取操作，可就不止一次了。</p><p>这里我先不展开，你只需要知道内存布局设计上要考虑这个因素就行了。目前我们大可以不必担忧，因为我们存放的各种数据都是8字节大小，可以紧挨着排列，一点都不浪费空间，而且都是字节对齐的。</p><p>设计完内存布局之后，我们再实现一下内置函数。其中最主要的，当然就是在内存里创建对象的函数。</p><pre><code>PlayObject* object_create_by_length(size_t length);\n</code></pre><p>我也用C语言写了一个<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/29/class.c\">class.c</a>的测试程序，来测试创建对象、访问对象属性等功能。你可以用make class命令编译并运行一下看看。</p><p>好了，关于内存布局和内置函数，我们就讨论完毕了。接下来又到了最后一个环节：修改编译器后端。</p><h2>修改编译器后端</h2><p>在修改编译器后端的时候，我们需要把注意力放在两个方面：<strong>访问对象的属性</strong>和<strong>调用对象的方法</strong>。</p><p>我们先看看如何访问对象的属性。在上一节课，我们曾经实现过访问数组元素的功能。访问对象的属性和访问数组元素的原理，其实是一样的，关键点就是要正确地计算出内存地址。根据我们的内存布局设计，这其实就是在对象地址的基础上，加上一定的偏移量就可以了，实现起来很简单。</p><p>那我们再看看如何调用对象的方法。这倒是一个新的知识点，不过这跟调用函数有很多相似之处。我们对调用函数已经很熟悉了，而调用对象方法和它只有一个地方不同，就是方法的第一个参数，其实是对象引用。而原来方法声明中的第一个和第二个参数等等，则依次被往后移了一个位置，成为了第二个、第三个参数。其实，C++和Java等面向对象的语言，基本上也是用这样的方法传递对象引用的，让方法中的代码可以访问对象中的数据。</p><p>修改编译器后端的这些示例代码，我仍然放在了<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/29/asm_x86-64.ts\">asm_x86-64.ts</a>中，你可以参考一下。这里，你特别要注意看一下我是如何计算对象属性的内存地址，以及如何用参数机制给方法传递对象引用的。</p><h2>课程小结</h2><p>今天的主要内容就是这些了，我们再一起回顾一下这节课的重点：</p><p>在编译器前端方面，我们最近这几节课一直在迭代、增加一些语法规则，这一节课一下子又增加了不少。在我们课程的第一阶段，可能你需要花很多时间才能实现一小点语法规则。而现在，你可以大刀阔斧地快速实现很多语法规则了。是不是已经感受到了自己的技能提升了很多？</p><p>在这里，我也分享一点我的心得。在实现这些语法功能的时候，最重要的其实就是<strong>设计出正确的语法规则</strong>。一旦你能够清晰地写出语法规则，那么照着规则去实现语法分析程序就不是什么难事了。你可能不能一次写出完全正确的语法规则，这也没有关系，多尝试几次就好了。你会不断积累经验，直到对各种形式的语法都得心应手。</p><p>在内存布局方面，我们基本上沿袭了前几节课的设计。但关于字节对齐这个知识点，虽然我们当前的简化设计不会遇到字节对齐问题，但你仍然要了解它，以便以后升级我们的对象设计，支持更多的数据类型，特别是小于8个字节的基础数据类型，比如boolean和32位的整型等。</p><p>最后，在编译器后端的实现上，重点是对象方法的调用机制。我们需要把对象引用作为第一个参数传递给方法。</p><p>好了，今天我们已经实现了基础的自定义对象功能。下一节课，我们会在这个基础上，增加面向对象编程最核心的一个特性，继承和多态功能，这会有助于加深你对面向对象的底层机制的理解。</p><h2>思考题</h2><p>TypeScript中的几乎任何类型的数据，都可以用点符号来访问其内部的属性和方法。比如，我们可以访问字符串和数组的length属性，甚至也可以用一些方法调用number类型的数据。那么，基于今天课程中的知识点，你能不能思考一下，我们具体能如何实现上述这些功能呢？欢迎在留言区分享你的观点。</p><p>欢迎把这节课分享给更多感兴趣的朋友。我是宫文学，我们下节课见。</p><h2>资源链接</h2><p><a href=\"https://gitee.com/richard-gong/craft-a-language/tree/master/29\">这节课的示例代码都在这里！</a></p>","neighbors":{"left":{"article_title":"28｜增加更丰富的类型第3步：支持数组","id":427480},"right":{"article_title":"30｜面向对象编程第2步：剖析一些技术细节","id":429135}}},{"article_id":429135,"article_title":"30｜面向对象编程第2步：剖析一些技术细节","article_content":"<p>你好，我是宫文学。</p><p>在上一节课里，我们实现了基本的面向对象特性，包括声明类、创建对象、访问对象的属性和方法等等。</p><p>本来，我想马上进入对象的继承和多态的环节。但在准备示例程序的过程中，我发现有一些技术细节还是值得单独拿出来，和你剖析一下的，以免你在看代码的时候可能会抓不住关键点，不好消化。俗话说，魔鬼都在细节中。搞技术的时候，经常一个小细节就会成为拦路虎。</p><p>我想给你剖析的技术细节呢，主要是<strong>语义分析</strong>和<strong>AST解释器</strong>方面的。通过研究这些技术细节，你会对面向对象的底层实现技术有更加细致的了解。</p><h2>技术细节：语义分析</h2><p>语义分析方面的技术细节包括：如何设计和保存class的符号、如何设计class对应的类型、如何给This表达式做引用消解、如何消解点符号表达式中变量等等。</p><p><strong>首先看看第一个问题，就是如何在符号表里保存class的符号</strong>。</p><p>我们知道，符号表里存储的是我们自己在程序里声明出来的那些符号。在上一节课之前，我们在符号表里主要保存了两类数据：变量和函数。而class也是我们用程序声明出来的，所以也可以被纳入到符号表里保存。</p><p>你应该还记得，我们的符号表采用的是一种层次化的数据结构，也就是Scope的层层嵌套。而且，TypeScript只允许在顶层的作用域中声明class，不允许在class内部或函数内部嵌套声明class，所以class的符号总是被保存在顶层的Scope中。</p><!-- [[[read_end]]] --><p>其实在TypeScript中，我们还可以在一个文件（或模块）里引用另一个文件里定义的类，这样你就能在当前文件里使用这些外部的类了。但我们其实并不是把外部类的全部代码都导入进来，而是只需要引入它们的符号就行了。在class符号里有这些类的描述信息，这些信息叫做元数据。元数据里会包括它都有哪些属性、哪些方法，分别都是什么类型的，等等。这些保存在符号里的这些信息，其实足够我们使用这个类了，我们不用去管这个类的实现细节。</p><p>你也可以对比一下FunctionSymbol的设计。FunctionSymbol里会记录函数的名称、参数个数、参数类型和返回值类型。你通过这些信息就可以调用一个函数，完全不用管这个函数的实现细节，也不用区分它是内置函数，还是你自己写的函数，调用方式都是一样的。</p><p><strong>说完了class的符号设计和保存，我们再进入第二个技术点，讨论一下class的类型问题</strong>。</p><p>我们说过，class给我们提供了一个自定义类型的能力。那这个自定义的类型如何表达呢？</p><p>在前面的课程中，我们已经形成了自己的一套类型体系，用于进行类型计算。而在这个类型体系中，有一种类型叫做NamedType。这些类型都有名称，并且还有父类型。我们用NamedType首先表示了Number、String、Boolean这些TypeScript官方规定的类型，还用它来表示了Integer和Decimal这两个Number类型的子类型，这两个类型是我们自己设计的。</p><p>那其实NamedType就可以用来表示一个class的类型信息，以便参与类型计算。</p><p>这里你可能会提出一个问题：class本身不就是类型吗？我们在ClassSymbol里已经保存了类的各种描述信息，为什么还要用到NamedType呢？</p><p>采用这样的设计有几个原因。首先，并不是所有的类型都是用class定义出来的。比如系统里有一些内置的类型。再比如，如果你用TypeScript调用其他语言编写的库，比如一些AI库，你可以把其他语言的类型映射成TypeScript语言的类型。所以说，类型的来源并不只有自定义的class。</p><p>第二个原因是由类型计算的性质导致的。在我们目前的类型计算中，我们基本只用到了类型的名称和父子类型关系这两个信息，其他信息都没有用到，所以就不需要在类型体系中涉及。</p><p>不过，使用NamedType这种设计其实有个潜台词，就是我们类型系统是Norminal的类型系统。这是什么意思呢？Norminal的意思是说，我们在做类型比较的时候，仅仅是通过类型的名称来确定两个类型是否相同，或者是否存在父子关系。与之对应的另一种类型系统是structural的，也就是只要两个类型拥有的方法是一致的，那就认为它们是相同的类型。像Java、C++这些语言，采用的是Nominal的类型系统，而TypeScript和Go等语言，采用的是Structural的类型系统。这个话题我们就不展开了，有兴趣你可以多查阅这方面的资料。</p><p>不过，为了简单，我们目前的实现暂且采用Norminal的类型，只通过名称来区分相互之间的关系。</p><p><strong>在分析完了class的符号和类型之后，我们再来看看它的用途。这就进入了第三个技术点，也就是如何消解This表达式。</strong></p><p>我们知道，this表达式的使用场景，是在类的方法中指代当前对象的数据。那么它的类型是什么呢？在做引用消解的时候，应该让它引用哪个符号呢？</p><p>this的类型，不用说，肯定就是指当前的这个class对应的类型，这个不会有疑问。</p><p>那它应该被关联到什么符号上呢？我们知道，当程序中出现某个变量名称或函数名称的时候，我们会把这些AST节点关联到符号表里的VarSymbol和FunctionSymbol上，this当然也不会例外。this在被用于程序中的时候，其用法跟普通的一个对象类型的变量是没有区别的。那我们是否应该在每个用到this的方法里，创建一个this变量呢？</p><p>这样当然可以，但其实也没有必要。因为每个函数都可能用到this关键字，所以如果在每个方法里都创建一个this变量有点啰嗦。我们只需要简单地把this变量跟ClassSymbol关联起来就行了，在使用的时候也没有什么不方便的。我们下面在讲AST解释器的实现机制里，会进一步看看如何通过this来访问对象数据。</p><p><strong>接下来，我们再看看第四个技术点：对点符号表达式的引用消解。</strong></p><p>在上一节课的示例程序中，我们可以通过“this.weight”、“mammal.color”、“mammal.speak()”这样的点符号表达式访问对象的属性和方法。</p><p>我们知道，在做引用消解的时候，需要把这里面的this、mammal、color、speak()都关联到相应的符号上，这样我们就知道这些标识符都是在哪里声明的了。</p><p>不过，之前我们不是已经都做过引用消解了吗？为什么这里又要把点符号的引用消解单独拎出来分析呢？</p><p>这是因为，之前我们做变量和函数的引用消解的时候，只需要利用变量和函数的名称信息就行了。但在点符号这边，只依赖名称是不行的，还必须依赖类型信息。</p><p>比如，对于mammal.color这个表达式。我们在上下文里，很容易找到mammal是在哪里声明的。但color就不一样了。这个color是在哪里声明的呢？这个时候，你就必须知道mammal的类型，然后再找到mammal的定义。这样，你才能知道mammal是否有一个叫做color的属性。</p><p>那你可能说，这很简单呀，我们只需要先计算出每个表达式的类型，然后再做引用消解就可以了呀。</p><p>没那么简单。为什么呢？因为类型计算的时候，也需要用到引用消解的结果。比如在mammal.color中，如果你不知道mammal是在哪里声明的，就不能知道它的类型，那也就更没有办法去消解color属性了。</p><p>所以，在语义分析中，我们需要把类型计算和引用消解交叉着进行才行，不能分成单独的两个阶段。在<a href=\"https://time.geekbang.org/column/intro/100052801\">《编译原理实战课》</a>中，我曾经分析过Java的前端编译器的特点。这种多个分析工作穿插执行的情况，是Java编译器代码中最难以阅读和跟踪的部分，但你要知道这背后的原因。</p><p>我还给你提供了一个更复杂一点的例子，你可以先看一下：</p><pre><code class=\"language-plain\">class Human{\n    swim(){\n        console.log(\"swim\");\n    }\n}\n\nclass Bird{\n    fly(){\n        console.log(\"fly\");\n    }\n}\n\nfunction foo(animal:Human|Bird){\n    if (animal instanceof Human){\n        animal.swim();\n    }\n    else{\n        animal.fly();\n    }\n}\n</code></pre><p>这个例子里有Human和Bird两个类，Human有swim()方法，而Bird有fly()方法。不过，我们可以声明一个变量animal，是Human和Bird的联合类型。那么，你什么时候可以调用animal的swim()方法，什么时候可以调用它的fly()方法呢？这个时候你就要基于数据流分析方法，先进行类型的窄化，然后才能把swim()和fly()两个方法正确地消解。</p><p>好了，关于语义分析部分的一些技术点，我就先剖析到这里。接着我们看看AST解释器中的一些技术。</p><h2>技术细节：Ast解释器</h2><p>实现Ast解释器的时候，我们也涉及了不少的技术细节，包括如何表示对象数据、对象数据在栈桢中的存储方式、如何以左值和右值的方式访问对象的属性等。</p><p><strong>首先我们看看如何表示对象的数据。</strong>上一节课里，我们提到用一个Map&lt;Symbol, any&gt;来存储对象数据就行了。我们在类中声明的每一个属性，都对应着一个Symbol，所以我们就可以用Symbol作为key，来访问对象的数据。</p><p>其实，我们的栈桢也是这样设计的。每个栈桢也是一个Map&lt;Symbol, any&gt;。你如果想访问哪个变量的数据，就把变量的Symbol作为key，到Map里去查找就好了。</p><p>不过，如果只用一个Map来代表对象数据，数据的接收方可能不知道该数据是属于哪个类的，在实现一些功能的时候不方便。所以我们就专门设计了一个PlayObject对象，在对象里包含了ClassSymbol和对象数据两方面的信息，具体实现如下：</p><pre><code class=\"language-plain\">class PlayObject{\n    classSym:ClassSymbol;\n    data:Map&lt;Symbol,any&gt; = new Map();\n    constructor(classSym:ClassSymbol){\n        this.classSym = classSym;\n    }\n}\n</code></pre><p><strong>那对象数据在栈桢里是如何保存的呢？</strong></p><p>其实，每个方法都跟函数一样，会对应着一个栈桢。在方法里，如果我们用到了this关键字，那就可能会访问对象的属性或方法。</p><p>那我们就一定要在栈桢里放一个PlayObject对象。这个对象的key，就是ClassSymbol。正好，我们在前面让this表达式关联到了ClassSymbol上。所以，我们使用this表达式就可以访问对象中的属性了。你看看下面的图，里面显示了栈桢和对象数据之间的关系，以及如何访问对象的属性。</p><p><img src=\"https://static001.geekbang.org/resource/image/ca/78/ca7d377737bebb5dd0a91byy3beyy078.png?wh=874x242\" alt=\"\"></p><p>那栈桢里的PlayObject对象是在什么时候被放到栈桢里的呢？其实是在调用构造方法和普通方法的时候。</p><p>在调用构造方法之前，我们首先要创建一个PlayObject对象，把它放到构造方法使用的栈桢里。在构造方法里，这样就可以用this来访问对象属性，并给这些属性赋予初始值了。另外，构造方法是没有返回值的。在调用构造方法之后，我们就把这个新创建的PlayObject当做返回值就好了。</p><p>在调用普通的对象方法的时候，比如用mammal.speak()对mammal求值的话，会返回一个PlayObject对象。然后我们把这个对象放在speak()方法的栈桢里就行了。</p><p>把PlayObject放在栈桢里，其实就相当于把PlayObject作为函数的第一个参数传到函数内部。总之，这样就能够在speak方法里使用this表达式了。</p><p><strong>最后，我们再看一下点符号表达式的左值和右值的使用场景</strong>。在下面的示例程序中，第一句是给mammal.color赋值，所以我们需要一个左值。而第二句是获取mammal.color当前的值，所以是一个右值。</p><pre><code class=\"language-plain\">mammal.color=\"yellow\"; //左值\nprintln(mammal.color); //右值\n</code></pre><p>对于这两种场景，点符号表达式要分别返回左值和右值。在需要右值的时候，mammal.color返回的是一个字符串。而在需要左值的时候，我们应该返回什么呢？</p><p>之前在处理本地变量的时候，我们已经学过，在需要左值的时候，直接返回变量的Symbol就好了。这样后续的赋值程序就可以把这个Symbol作为Key来修改栈桢中变量的值。</p><p>在<a href=\"https://time.geekbang.org/column/article/427480\">28讲</a>中，在实现数组特性的时候，有时候我们需要修改某个数组元素的值。这个时候，我们就不能简单地用数组变量的Symbol来表达一个左值了，因为我们还需要知道数组元素的下标。所以那个时候，我们专门设计了另一个左值对象，叫做ArrayElementRef。它里面甚至可以存放多个下标值，来引用多维数组中的某个元素。</p><pre><code class=\"language-plain\">class ArrayElementRef{\n    varSym : VarSymbol;  //数组的基础变量对应的Symbol\n    indices : number[];  //(多维)数组元素的下标。\n    constructor(varSym:VarSymbol, indices:number[]){\n        this.varSym = varSym;\n        this.indices = indices;\n    }\n}\n</code></pre><p>用于访问对象属性的左值，其实也可以采用类似的设计。这个类的名字叫做ObjectPropertyRef，意思是这是对一个对象的属性的引用，里面有PlayObject对象，还有被访问的属性的Symbol。基于这样一个左值，我们就可以修改对象的属性了。</p><pre><code class=\"language-plain\">class ObjectPropertyRef{\n    object: PlayObject;\n    prop:Symbol;\n    constructor(object:PlayObject, prop:Symbol){\n        this.object = object;\n        this.prop = prop;\n    }\n}\n</code></pre><h2>课程小结</h2><p>今天的内容就是这些。通过这节课分享的一些技术实现细节，我希望你能记住几个关键点。</p><p>首先，在语义分析方面，我们需要对class建立符号，并存到符号表里。class的符号应该包含足够的描述信息，包括名称，以及属性和方法的描述。为了进行类型计算，我们还要把class符号关联到一个NamedType对象中。这种类型计算方式的设计思路，是基于Nominal的类型系统而来的。</p><p>在支持点符号表达式以后，我们的引用消解和类型计算需要交错起来进行，这会导致语义分析程序变得复杂。你在查看各种编译器的源代码的时候，也可以多关注它们在这方面是如何实现的。</p><p>第二，在AST解释器的实现机制上，你的脑海里需要对栈桢有一个清晰的图像。在对象方法的栈桢里，我们一定会放一个PlayObject对象数据，这样就可以用this来访问对象的属性了。在访问对象属性时，又要分为左值和右值的情况。对于左值，我们要设计一种数据结构，清晰地表达出如何访问对象的属性。</p><p>最后，关于课程代码的学习，我还要再叮嘱你几句。</p><p>在课程起步篇的后半段和我们现在的进阶篇里，课程的示例代码的体量明显加大。并且，由于每节课示例代码都在迭代，你在阅读代码的时候可能会感觉到有一定的负担。</p><p>这里我想强调的是，编译器针对词法分析和语法分析这样功能的代码，往往大家的实现都差不多。因为这两部分的理论化是最强的，基本上你理解了理论就能写出差不多的代码来了。</p><p>而语义分析、编译器的后端等的代码，工程特点就比较强了，各个编译器的实现差异很大。你需要把握其中的关键技术点，就比如今天我们这节课分析的这些点。这样在具体实现上，你可以不用拘泥于哪种具体的方式。就比如，在这节课中，关于如何消解this，以及如何把对象数据提供给方法，并通过this访问，其实可以有多种技术方案。你可以活学活用，只要把握住其中的关键点就可以了。</p><h2>思考题</h2><p>今天我们讲到了class的符号中包含的信息。那你能不能思考一下，这些符号是否需要在虚拟机或者可执行程序中保存？保存这些信息有什么用途？你能不能结合你熟悉的语言来分享一下？</p><p>另外，今天我们提到的Norminal和Structural的类型系统，你在使用它们的时候有什么体会？如果我们想要实现Sturctural的类型系统，那应该如何设计？欢迎你在留言区分享观点。</p><p>欢迎把这节课分享给更多感兴趣的朋友。我是宫文学，我们下节课见。</p>","neighbors":{"left":{"article_title":"29｜面向对象编程第1步：先把基础搭好","id":428273},"right":{"article_title":"31｜面向对象编程第3步：支持继承和多态","id":429917}}},{"article_id":429917,"article_title":"31｜面向对象编程第3步：支持继承和多态","article_content":"<p>你好，我是宫文学。</p><p>经过前面两节课对面向对象编程的学习，今天这节课，我们终于要来实现到面向对象中几个最核心的功能了。</p><p>面向对象编程是目前使用最广泛的编程范式之一。通常，我们说面向对象编程的核心特性有封装、继承和多态这几个方面。只要实现了这几点，就可以获得面向对象编程的各种优势，比如提高代码的可重用性、可扩展性、提高编程效率，等等。</p><p>这节课，我们就先探讨一下面向对象的这些核心特性是如何实现的，然后我会带着你动手实现一下，破解其中的技术秘密。了解了这些实现机制，能够帮助你深入理解现代计算机语言更深层次的机制。</p><p>首先，我们先来分析面向对象的几个核心特性，并梳理一下实现思路。</p><h2>面向对象的核心特性及其实现机制</h2><p><strong>第一，是封装特性。</strong></p><p>封装是指我们可以把对象内部的数据和实现细节隐藏起来，只对外提供一些公共的接口。这样做的好处，是提高了代码的复用性和安全性，因为内部实现细节只有代码的作者才能够修改，并且这种修改不会影响到类的使用者。</p><p>其实封装特性，我们在上两节课已经差不多实现完了。因为我们提供了方法的机制，让方法可以访问对象的内部数据。之后，我们只需要给属性和方法添加访问权限的修饰成分就可以了。比如我们可以声明某些属性和方法是private的，这样，属性和方法就只能由内部的方法去访问了。而对访问权限的检查，我们在语义分析阶段就可以轻松做到。</p><!-- [[[read_end]]] --><p>上一节课，我们已经分析了如何处理点符号表达式。你在程序里可以分析出点号左边的表达式的类型信息，也可以获得对象的属性和方法。再进一步，我们可以给这些属性和方法添加上访问权限的信息，那么这些私有的属性就只可以在内部访问了，比如使用this.xxx表达式，等等。而公有的属性仍然可以在外部访问，跟现在的实现没有区别。</p><p><strong>第二，我们看看继承。</strong></p><p>用直白的话来说，继承指的是一个class，可以免费获得父类中的属性和方法，从而降低了开发工作量，提高了代码的复用度。</p><p>我写了一个示例程序，你可以看一下：</p><pre><code>function println(data:any=&quot;&quot;){\n    console.log(data);\n}\n\nclass Mammal{\n    weight:number = 0;\n    // weight2;\n    color:string;\n    constructor(weight:number, color:string){\n        this.weight = weight;  \n        this.color = color;\n    }\n    speak(){\n        println(&quot;Hello, I'm a mammal, and my weight is &quot; + this.weight + &quot;.&quot;);\n    }\n}\n\nclass Human extends Mammal{  //新的语法要素：extends\n    name:string;\n    constructor(weight:number, color:string, name:string){\n        super(weight,color); //新的语法要素：super\n        this.name = name;\n    }\n    swim(){\n        println(&quot;My weight is &quot; +this.weight + &quot;, so I swimming to exercise.&quot;);\n    }\n}\n\nclass Cat extends Mammal{\n    constructor(weight:number, color:string){\n        super(weight,color);\n    }\n    catchMouse(){\n        println(&quot;I caught a mouse! Yammy!&quot;);\n    }\n}\n\nfunction foo(mammal:Mammal){\n    mammal.speak();\n}\n\nlet mammal1 : Mammal;\nlet mammal2 : Mammal;\n\nmammal1 = new Cat(1,&quot;white&quot;);\nmammal2 = new Human(20, &quot;yellow&quot;, &quot;Richard&quot;);\n\nfoo(mammal1);\nfoo(mammal2);\n</code></pre><p>在这个示例程序中，Human和Cat都继承了Mammal类。但人类和猫当然有很大的不同，比如人类通常会有一个姓名，具备游泳的能力，而猫则有抓老鼠的能力。</p><p>但因为它们都属于哺乳动物，所以也一定有一些共同的特征，比如都有体重和颜色，也都可以发出声音。这里，使用了继承功能以后，像weight、color和speak()这样的属性和方法，我们就不需要Human和Cat去重复实现了。</p><p>那实现继承特性的关键点是什么呢？你可以基于我们现在的技术实现来分析一下。你会发现，当我们调用cat.color的时候，<strong>最关键的是要对color属性进行定位</strong>。在编译期，我们需要通过引用消解，把color属性定位到声明它的地方，也就是在父类Mammal中。而在运行期，我们需要知道父类的属性的存储位置，这样才可以访问它们。</p><p>具体实现，我们在接下来的讲解中依次展开。现在我们分析一下面向对象的第三个特性，也就是多态。</p><p><strong>第三，多态特性。</strong></p><p>多态指的是一个类的不同子类，都实现了某个共同的方法，但具体表现是不同的。多态的好处，是我们可以在一个比较稳定的、抽象的层面上编程，而不被更加具体的、易变的实现细节干扰。</p><p>举例来说，如果我们想要在手机和电脑之间发送信息。那么在抽象的层面上，我们只需要提供sendData和receiveData这样的编程接口。而在具体实现上，这些信息可能是通过Wi-Fi传递的，也可能是通过5G网络或蓝牙传递的。系统可以根据不同的网络环境选择不同的机制，但是我们上层使用sendData和recieveData接口来编写的应用程序，不需要根据传输方式的不同而修改应用逻辑，这样就降低了整体系统的维护成本。</p><p>我们也可以修改一下示例程序来说明多态特性。我们给Human和Cat都增加了一个speak()方法，覆盖掉了父类的缺省实现，分别执行了不同的逻辑。</p><pre><code class=\"language-plain\">class Human extends Mammal{  //新的语法要素：extends\n    name:string;\n    constructor(weight:number, color:string, name:string){\n        super(weight,color); //新的语法要素：super\n        this.name = name;\n    }\n    swim(){\n        println(\"My weight is \" +this.weight + \", so I swimming to exercise.\");\n    }\n    speak(){\n        println(\"Hello PlayScript!\");\n    }\n}\n\nclass Cat extends Mammal{\n    constructor(weight:number, color:string){\n        super(weight,color);\n    }\n    catchMouse(){\n        println(\"I caught a mouse! Yammy!\");\n    }\n    speak(){\n        println(\"Miao~~\");\n    }\n}\n</code></pre><p>你要注意speak()方法后面的几行代码，这里就展现了多态的强大之处。你可以声明多个Mammal类型的变量，给每个变量赋予Mammal的不同子类的对象实例。而在foo函数程序里，我们接受一个Mammal类型的参数，并让它speak()。</p><p>你会看到，无论Mammal的子类将来扩展到多少种，都不会影响到foo函数的逻辑，foo函数只要保持它的抽象性就好了。这种在抽象层面上编程的技术，是实现可重用的编程框架的基础，也通常是一个公司里资深的技术人员的职责。</p><p>那如果要实现多态功能，其实我们不能在编译期做什么事情，这主要是运行期的功能。因为你编译foo函数的时候，只知道传进来的参数是Mammal类型，去调用Mammal的speak()方法就好了。而在运行期，这个speak()方法要正确地定位到具体子类的实现上。这个技术，就做动态绑定（Dynamic Binding），或者后期绑定（Late Binding），这也是面向对象之父阿伦 · 凯伊（Alan Kay）所提倡的面向对象应该具备的核心特征。</p><p>接下来，我们会分别在AST解释器和静态编译的两个版本上，讨论运行期绑定的实现细节。</p><p>在此之前，我们还是要先修改一下编译器的前端，让它能够支持今天我们讲到的特性。</p><h2>修改编译器前端</h2><p>在编译器前端方面，我们仍然需要增强一下语法规则，并进行一些语义分析工作。</p><p>语法方面，主要是<strong>增加类继承的语法</strong>，比如：“class Humman extends Mammal”。我们把原来类声明的语法规则稍加修改就行：</p><pre><code class=\"language-plain\">classDecl : Class Identifier ('extends' Identifier)? classTail ;\n</code></pre><p>另外，在实现了继承以后，我们还需要用到跟this相对应的另一个关键字，super。通过super关键字，我们可以调用父类的方法。特别是，我们需要在子类的构造方法里，通过super()这样的格式，来调用父类的构造方法。</p><p>相对来说，我们在语义分析方面要做的工作会更多一点，主要包括：</p><ul>\n<li>在calss的符号信息里，要增加与继承关系有关的信息；</li>\n<li>在NamedType类型信息里，也要建立起正确的父子关系，便于进行类型计算；</li>\n<li>在子类的构造方法里，第一个语句必须用super()调用父类的构造方法。</li>\n</ul><p>这些工作倒是没有太复杂的实现难度，你参考一下<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/31/semantic.ts\">semantic.ts</a>中的代码。</p><p>接下来，我们仍然增强一下AST解释器，来支持继承和多态特性。</p><h2>修改AST解释器</h2><p>AST解释器方面需要增强的工作包括：</p><ul>\n<li>为了实现继承特性，要能够在子类中访问父类的属性和方法；</li>\n<li>为了实现多态特性，在调用方法时，要能够正确调用具体的子类的实现。</li>\n</ul><p><strong>首先我们看如何继承父类的属性。</strong>对于AST解释器这种运行机制来说，属性的继承实现起来比较简单。因为我们是用PlayObject来存放对象数据的，具体存储方式是一个Map。无论是父类还是子类的属性，都保存在这个Map中就可以了。然后我们再以对象属性的Symbol为Key去访问这些数据就行了。</p><p>刚才讲的是属性的继承，那么继承父类的方法也是一样的吗？</p><p>不知道你还记不记得，在上一节课中，我们在PlayObject中包含了该对象所属的类的符号信息。而这个符号里，又引用了它的父类的符号。所以，我们可以借助这些父子关系的信息，逐级向上查找，直到在某一级父类里找到这个方法。</p><p>你有没有看出这里面的关键点？<strong>我们是在运行时才知道，到底要调用那个层级的父类所实现的方法的。这也说明，我们在前端的语义分析阶段，不能把方法的调用跟具体的实现绑死，绑定的动作要留到运行时。</strong>虽然在做引用消解的时候，我们把方法调用指向了某个方法的Symbol，但这个Symbol只是用来在运行时去定位真正要调用的方法。</p><p><img src=\"https://static001.geekbang.org/resource/image/da/2a/da9714cce08d6e95d440fc292ae5f92a.png?wh=956x566\" alt=\"图片\"></p><p>这个在运行时绑定的原则，其实也是实现多态特性的背后机制。在上面的示例程序中，虽然foo函数的签名针对的都是Mammal类型，但在运行时具体调用方法的时候，我们传递给方法的都是PlayObject对象，而PlayObject对象中保存的ClassSymbol呢，是具体的子类的符号信息，这当然就会导致调用不同子类的方法，从而也就实现了多态。</p><p>所以说，<strong>方法的继承和多态这两件事，落实到实现上是同一件事，都是根据PlayObject中的符号信息，去查找到真正应该调用的方法就好了</strong>。</p><p>具体实现上，你可以参考<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/31/play.ts\">play.ts</a>的中的示例程序。</p><p><img src=\"https://static001.geekbang.org/resource/image/2c/b8/2c0f8aa02fb6cc0d726196554eaedfb8.png?wh=476x154\" alt=\"图片\"></p><p>整个实现下来，你会感觉到似乎也不太难呀。对于解释执行的运行时来说，确实如此。但对于编译执行的运行时机制来说，就需要更多的技巧才能实现继承和多态的机制。</p><h2>在可执行程序中实现继承和多态</h2><p>在解释执行的运行机制中，我们在访问对象的属性和方法之前可以做很多工作，能让我们确定属性的地址，或者定位具体的方法。但这个过程会导致不少的额外开销。</p><p>比如，在AST解释器中，去访问一个属性的时候，需要查找一个Map。这样的话，一次赋值过程可能要导致内部多次函数调用。对比我们生成的汇编语言的代码，在访问一个对象数据的时候，只需要用几个指令做内存地址的计算和数据的访问就可以了，性能很高。</p><p>调用方法也是如此。在C++这样的语言中，函数调用不可以有太多的额外开销，因为它毕竟是一门系统级的语言，是用于开发操作系统、数据库这类软件的，所以要求性能尽量高，资源占用尽量少。</p><p>所以，我们就要细致地设计一下对象的内存布局和方法的动态绑定机制，让我们的程序既具备面向对象带来的灵活性，又不会导致额外的开销。</p><p>在这节课的实现中，我们就借鉴一下C++的实现机制。这个实现方式很经典，值得好好掌握。</p><p>首先说一下对象的内存布局。在对象继承的情况下，怎么保存所有的属性数据呢？包括自己这一级的属性和各级父类的属性。</p><p>你可以稍作思考。有了前面我们设计对象内存布局的经验，我相信你一定会拿出正确的技术方案。这个方案就是，不管父类和子类的数据，都集中在一块内存里连续存放。并且，我们要先放父类的数据，再放子类的数据。你可以参考一下这张图：</p><p><img src=\"https://static001.geekbang.org/resource/image/2c/37/2c4657922d729039f9cb74ab51c92737.png?wh=524x196\" alt=\"图片\"></p><p>那为什么要先放父类的数据，再放子类的数据呢？</p><p>这是因为，这可以让我们在程序中无缝的进行类型的转换。比如，你可以把一个Cat对象的引用赋给一个Mammal变量。因为Cat对象的指针和Mammal的指针是同一个地址。反过来，你在知道一个Mammal变量的具体类型的情况下，也可以把一个Mammal引用强制转换成一个Cat引用，来访问cat特有的属性。在TypeScript的前端，这种类型转换是用as关键字实现的。在运行时，可以从基地址开始，加上一定的偏移量，就可以计算出各级子类的属性的地址。</p><p>好了，如何访问对象属性的机制就搞清楚了。那么如何在运行时找到正确的对象方法呢？这就要提一下著名<strong>vtable机制</strong>了。</p><p>vtable的原理是什么呢？</p><p>我们先回顾一下，对于普通的函数，我们是怎么调用的。这很简单，就是用一个标签标记一下函数的入口，然后从调用者那里就可以直接跳转过来。在编译期，我们就知道对这个函数的调用肯定要跳转到这个标签。而这个标签，最后会变成内存里文本段的确定的代码地址。这就是静态绑定。</p><p>那我们如何把它改成动态绑定呢？我们可以借鉴AST运行时中的机制。在AST的运行时中，我们是在获得了PlayObject对象之后，根据PlayObject对象中的ClassSymbol来绑定具体的方法。</p><p>所以，vtable也是采用了这么一个机制。vtable是一个表格，保存了对象的每个可被覆盖的方法的代码地址。vtable中的每个条目，都对应了一个方法。</p><p>比如一个Human对象的vtable中，条目1对应的是speak()方法，条目2对应的是swim()方法。如果Human没有重载父类的speak()方法，那条目1里存的就是父类的方法地址。那么如果Human重载了这个方法呢？那我们就用新的方法地址覆盖掉它。这样在程序执行的时候，我们通过Mammal对象的指针，再查找vtable来获得speak()方法的地址的时候，不同的子类的speak()方法的地址就是不同的。这样也就实现了方法的继承和多态。</p><p>那具体要生成什么样的汇编代码，来支持我们刚才说到的vtable机制和程序的跳转机制呢？我们可以看看C++是怎么实现的。</p><p>我写了一个C++的示例程序（<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/31/class2.cpp\">class2.cpp</a>），仍然实现了Mammal、Human和Cat这三个类。其中父类有两个方法speak()和run()可以被子类覆盖，也就是带有virtual关键字；它还有一个breath()方法不可以被子类覆盖。在foo函数中，我们分别调用了mammal的speak()方法和breath()方法。</p><pre><code class=\"language-plain\">#include \"stdio.h\"\n\nclass Mammal{\n    public:\n    double weight;\n    //这个方法不可被子类覆盖\n    void breath(){\n        printf(\"mammal breath~~\\n\"); //这里用c语言的库，而不是c++的cout，是为了让生成的汇编代码更简洁\n    }\n    //这个方法以virtual开头，可以被子类覆盖\n    virtual void speak(){\n        printf(\"I'm mammal.\\n\");\n    }\n    //第二个virtual方法\n    virtual void run(){\n        printf(\"I'm mammal.\\n\");\n    }\n};\n\nclass Cat : public Mammal{\n    public:\n    double jumpHeight;\n    //覆盖了父类的speak方法\n    void speak(){\n        printf(\"I can jump %lf m.\\n\", jumpHeight);\n    }\n    //子类自己的方法\n    void catchMouse(){\n        printf(\"I can catch mouse.\\n\");\n    }\n};\n\nclass Human : public Mammal{\n    public:\n    double age;\n    //覆盖了父类的speak方法\n    void speak(){\n        printf(\"I'm %lf years old.\\n\", age);\n    }\n};\n\nvoid foo(Mammal* mammal){\n    mammal-&gt;breath();\n    mammal-&gt;speak();\n}\n\nint main(){\n    Cat * cat = new Cat();\n    cat-&gt;weight = 10;\n    cat-&gt;jumpHeight = 5;\n    \n    Human * human = new Human();\n    human-&gt;weight = 80;\n    human-&gt;age = 18;\n\n    foo(cat);\n    foo(human); \n\n    delete cat;\n    delete human;\n\n    return 0;\n}\n\n</code></pre><p>然后我们用“clang++ class2.cpp -o class2”命令，把这个C++程序编译成可执行文件。然后再运行这个class2程序，就可以得到下面的输出：</p><p><img src=\"https://static001.geekbang.org/resource/image/af/b6/af91bf2d11f2bae3c60d2267a92d6bb6.png?wh=1032x242\" alt=\"图片\"></p><p>你能看到，对于breath()方法，程序调用的是父类Mammal的实现，这是继承。而对于speak()方法来说，程序调用的是两个子类各自的实现，这是重载。</p><p>接下来，你可以用“clang++ -S class2.cpp -o class2.s”命令生成汇编文件<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/31/class2.s\">class2.s</a>，观察C++语言是怎么实现vtable的。</p><p>这个汇编代码有点长，如果你不熟悉它的结构，可能一下子会有点晕。不过，在你找到了规律，知道了生成汇编代码的思路以后，就会觉得容易接受了。</p><p>在这里，我带你分析一下它里面的主要代码，让你理解C++程序编译后，到底是如何形成vtable的，又是如何实现动态绑定的。</p><p>首先看看main函数所生成的代码。我从里面截取了一段，对应于源代码中的前三行代码。</p><p><img src=\"https://static001.geekbang.org/resource/image/5c/22/5c309c80211b980d5688acf472b28422.png?wh=1216x1256\" alt=\"图片\"></p><p>从这段代码中你能看出，程序为Cat对象申请了24个字节的内存。其中前8个字节存的就是vtable的指针，后面16个字节分别是weight和jumpHeight。其中weight来自父类，而jumpHeight则是在Cat类中声明的。</p><p>其中的__ZN3CatC1Ev是做Cat的对象初始化工作。你跟踪这个函数的代码，会发现它又调用了__ZN3CatC2Ev。而在__ZN3CatC2Ev中做了两件重要的事情。</p><p><img src=\"https://static001.geekbang.org/resource/image/fb/b3/fb81f9e086b1057b0927a8443d1896b3.png?wh=892x1114\" alt=\"图片\"></p><p>首先，是它调用了一个为父类Mammal做初始化的函数。然后是一条重要的语句“movq\t__ZTV3Cat@GOTPCREL(%rip), %rax”。它的意思是，把__ZTV3Cat这个标签的地址，相对于代码寄存器中的值的偏移量，存到rax寄存器中去。</p><p>__ZTV3Cat这个标签指向的是一个数据段，里面保存了一些常量，就像我们之前用过的double常量和字符串常量一样。而这里的一些常量，是关于Cat类的一些描述，其中包括类型信息，以及vtable。编译后这些信息进入可执行程序的数据区，并且可以用刚才的的指令访问。</p><p>接下来，后面几条指令，是把__ZTV3Cat的地址值加上16个字节，写到了Cat对象的对象头里，也就是前8个字节。</p><p>那为什么要加上16个字节呢？这就需要我们到__ZTV3Cat这个标签下，看看这个数据段里到底有一些什么数据。你可以看看下面的图。</p><p><img src=\"https://static001.geekbang.org/resource/image/52/74/525f677789c763240bb323abfcaa5774.png?wh=1156x478\" alt=\"图片\"></p><p>你会看到，在这个段中，一共有4个8字节常量。其中第一个常量是0，这个常量我们不用管它。第二个8字节常量，则是另一个标签，指向另一个数据区，里面保存了Cat的一些类型信息，包括类型名称等等。这些信息可被用于RTTI功能，也就是运行时的类型判断功能。</p><p>这里的重点在第三和第四个8字节区域，它们分别保存了两个虚函数的标签。第一个虚函数是speak函数，这个函数指向的是Cat所实现的speak函数，而不是父类的函数。而第二个虚函数，则是指向Mammal的实现，因为Cat并没有覆盖父类中的实现。这最后的16个字节，就是Cat类的vtable。</p><p>那么，程序里具体是如何使用vtable来调用函数的呢？你可以再接着看看foo函数的实现。</p><p><img src=\"https://static001.geekbang.org/resource/image/48/6a/4850e2dc23c647892a60e721ed38d76a.png?wh=1190x1156\" alt=\"\"></p><p>函数调用了3个函数。在调用breath()方法的时候，是直接使用了breath()方法的标签，并没有经过vable。这是由C++的语言特性决定的。如果一个方法前面没有用virtual来修饰，那它就不可以被子类覆盖，因此自然也就不需要vtable了。</p><p>而在调用speak()方法的时候，代码里使用了“callq\t<em>(%rcx)”。这条指令的意思是，%rcx寄存器里保存了一个内存地址。这个内存地址里保存了要执行的代码的地址，然后去执行这个代码。实际上，%rcx寄存器就是刚才的数据区的起始地址加上16字节后的值，这个值正是vtable的地址。而</em>(%rcx)，实际上就是vtable中记录的第一个虚函数的地址。如果你要调用第二个虚函数，那么需要使用callq\t*8(%rcx)指令，基于vtable开头的位置偏移8个字节。</p><p>好了，到这里，我们就把C++实现继承和多态，以及vtable的技术细节都分析清楚了。那么，我们在后端同样也可以做一个这样的参考实现。我们实现起来可以比C++的机制更加简化。这是因为，首先，我们目前还不需要运行时类型机制，可以简化掉这部分。第二，我们把所有父类的方法都放在vtable中，因为目前所有父类的方法都是公共的，都是允许被覆盖的。</p><p>我提供的参考实现，仍然在<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/31/asm_x86-64.ts\">asm_x86-64.ts</a>中。</p><h2>课程小结</h2><p>今天的内容就是这些。关于面向对象的核心特性，我希望你记住以下几个知识点：</p><p>首先，继承和多态的核心点，都是来自动态绑定技术。也就是说，在编译期并不知道实际调用的是哪一级的方法，只有在运行期根据对象的具体类型才知道。</p><p>第二，在AST解释器中，我们借助PlayObject中存储的ClassSymbol信息，就能动态地找到方法的正确实现。</p><p>第三，在编译成可执行文件时，我们要借助vtable技术来实现继承和多态特性。vtable是在编译时就生成了的，保存在一个数据区。在创建对象的时候，我们就把数据区中vtable的地址写入到对象头中。最后，我们只用一条类似于callq *8(%rcx)指令，就能查找出vtable中记录的函数地址，从而跳转过去执行。</p><p>今天这节课的内容是非常有用的。如果你使用过C++技术，那么今天我带你剖析了C++的汇编代码后，你会对C++的实现机制理解得更加深入。如果你没有使用过C++，那你也一定要记住vtable这种技术，因为它是静态编译的语言实现面向对象特性的关键。</p><p>我们用了三节课的时间，实现了面向对象最核心的一些特性。在此基础上，我们可以扩展到支持更多的特性，比如TypeScript是支持接口的，我们可以把接口特性添加上。再比如，我们还可以把Norminal的类型系统改成Structural的，让类型之间的兼容更灵活，并且还可以看看这个时候用vtable来实现多态还行不行。</p><h2>思考题</h2><p>我们今天讨论了用vtable在静态编译中实现多态。那么你能不能挑战一下，看能不能提供另外的方案来实现多态？你可以天马行空地想一想，并在留言区分享你的观点。</p><p>并且，如果我们的类型系统改成Structural的，那么我们需要如何修改现在的vtable机制，才能准确地在运行时绑定正确的方法呢？对于这个问题，你也可以谈谈想法。</p><p>欢迎你把这节课分享给更多感兴趣的朋友。我是宫文学，我们下节课见！</p><h2>资源链接</h2><p><a href=\"https://gitee.com/richard-gong/craft-a-language/tree/master/31\">这节课的代码目录在这里！</a></p>","neighbors":{"left":{"article_title":"30｜面向对象编程第2步：剖析一些技术细节","id":429135},"right":{"article_title":"32｜函数式编程第1关：实现高阶函数","id":431494}}},{"article_id":431494,"article_title":"32｜函数式编程第1关：实现高阶函数","article_content":"<p>你好，我是宫文学。</p><p>前面三节课，我们探讨了怎么在现代语言中实现面向对象编程的特性。面向对象是一种重要的编程范式。还有另一种编程范式，也同样重要，并且近年来使用得很多，这就是函数式编程。从今天这节课开始，我们就来实现一下函数式编程。</p><p>函数式编程思想其实比面向对象编程思想的历史更长，早期的Lisp等语言都是函数式编程语言。像JavaScript等后来的语言，也继承了Lisp语言在函数式编程方面的思想，对函数式编程也有不错的支持。</p><p>近年，函数式编程思想得到了一定程度的复兴，部分原因是由于函数式编程能够更好地应对大规模的并发处理。我自己最近参与的项目，也在全面使用一门函数式编程语言，这也是对函数式编程的优势的认可。此外，像Erlang这种能够开发高可靠性系统的函数式编程语言，也一直是我感兴趣的研究对象。</p><p>对于函数式编程这个话题，很多书和文章都对它有过讲解。我在《编译原理实战课》的<a href=\"https://time.geekbang.org/column/article/285636\">第39节</a>，也对函数式编程特性的一些技术点做了分析。在我们的这门课里，因为要动手实现出来，所以目标不能太大，我们就挑几个最核心的技术点来实现一下，让你对函数式编程的底层机制有一次穿透性的了解。</p><p>今天这节课，我们主要来实现高阶函数的特性。对于函数式编程来说，高阶函数是实现其他功能的基础，属于最核心的技术点。那么，我们就先分析一下什么是高阶函数。</p><!-- [[[read_end]]] --><h2>高阶函数的例子</h2><p>高阶函数的核心思想，是<strong>函数本身可以当做数据来使用</strong>，就像number数据和string数据那样。那既然可以当做数据使用，那自然可以用它来声明变量、作为参数传递给另一个函数，以及作为返回值从另一个函数中返回。如果一门计算机语言把函数和数据同等对待，这时候我们说函数是一等公民（First-class Citizen）。</p><p>我用TypeScript写了一个reduce函数的例子，带你来感受一下高阶函数的特性。这个函数能够遍历一个number数组，并且返回一个number值。</p><pre><code class=\"language-plain\">//reduce函数：遍历数组中的每个元素，最后返回一个值\nfunction reduce(numbers:number[], fun:(prev:number,cur:number)=&gt;number):number{\n    let prev:number = 0;\n    for (let i = 0; i &lt; numbers.length; i++){\n        prev = fun(prev, numbers[i]);\n    }\n    return prev;\n}\n\n//累计汇总值\nfunction sum(prev:number, cur:number):number{\n    return prev + cur;\n}\n\n//累计最大值\nfunction max(prev:number, cur:number):number{\n    if (prev &gt;= cur)\n        return prev;\n    else\n        return cur;\n}\n\nlet numbers = [2,3,4,5,7,4,5,2];\n\nprintln(reduce(numbers, sum));\nprintln(reduce(numbers, max));\n</code></pre><p>这个reduce函数很有意思的一点，是它能接受一个函数作为参数。在每遍历一个数组元素的时候，都会调用这个传进来的函数。根据传入的函数不同，reduce函数能完成不同的功能。当传入max函数的时候，reduce函数能返回数组元素的最大值；而当传入sum函数的时候，则能返回数组元素的汇总值。</p><p>这个例子能够部分体现函数式编程的优势：<strong>把系统的功能拆解成函数，再灵活组合。</strong></p><p>那这些高阶函数的特性具体怎么实现呢？按照惯例，我们还是先看看在编译器前端方面，我们要做什么工作。</p><h2>修改编译器前端</h2><p>要实现上面的功能，编译器前端需要增加新的语法规则，并做一些与函数类型有关的语义处理工作。</p><p><strong>首先我们看看语法方面的工作。</strong></p><p>我们需要要增加与函数类型有关的语法，支持示例程序中的(prev:number, cur:number)=&gt;number这样的格式。</p><p>涉及的语法规则如下：</p><pre><code class=\"language-plain\">type_ : unionOrIntersectionOrPrimaryType | functionType;\nfunctionType : '(' parameterList? ')' '=&gt;' type_;\n</code></pre><p>你看到，我们增加了新的类型表达式。与此相对应的，我们也要增加新的AST节点：FunctionTypeExp，用于记录解析出来的函数类型信息。</p><p><strong>接着，我们再看看语义分析方面的工作。</strong></p><p>在语义分析方面，我们需要扩展现在的类型系统，来支持函数类型。对函数类型表达式的AST节点进行解析后，我们就能够生成对应的函数类型了。函数类型的设计如下：</p><pre><code class=\"language-plain\">export class FunctionType extends Type{\n    returnType:Type;    //返回值类型\n    paramTypes:Type[];  //参数的类型\n    ...\n}\n</code></pre><p>这样的话，变量、参数的类型，就可以设置为这种函数类型。接下来，我们需要对类型计算和类型检查的代码升级。比如，联合类型中也可以包含函数类型，给函数类型的变量赋值的时候，我们要检查类型是否匹配。</p><p>另外，我们在函数的引用消解方面也要做一些工作。比如，在示例程序中，我们使用了fun(prev, cur)这样的表达式。在这节课之前，我们肯定要把fun关联到一个具体的函数声明。但现在，fun有可能是一个具体的函数，也有可能是一个函数类型的变量，这在引用消解的时候要区分开。fun消解后，关联的符号是一个变量符号，而不是一个函数符号。</p><p>好了，编译器前端的工作就是这些。基本上没有太大的技术难度，其实也没有新的技术点，基本上是在原来的技术框架下做扩展，但工作量还是有的。</p><p>具体的实现，你可以参照<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/32/parser.ts\">parser.ts</a>和<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/32/semantic.ts\">semantic.ts</a>。</p><p>相比编译器前端而言，运行时中涉及的新技术点就更多一些了。我们先看看AST解释器的运行时。</p><h2>升级AST解释器</h2><p>在AST解释器中，我们需要把函数当作值来传递。那这个值应该是什么呢？你可以思考一下。</p><p>在我们当前的实现中，其实可以直接把函数的符号当作变量值来传递就行了。你看，我们之前调用函数时候，这个FunctionCall表达式已经被消解，从而其sym属性就指向了一个具体的函数符号，通过这个函数符号就能找函数声明，从而解释执行这个函数。</p><p><img src=\"https://static001.geekbang.org/resource/image/80/c1/808172248e7127d1155426c7cd82eac1.jpg?wh=1980x544\" alt=\"\"></p><p>现在我们可以用一个变量表示一个函数，那么这个变量的sym属性指向的是变量声明的地方，而变量的值才是该函数的符号。这个时候，我们可以取出变量的值，也就是一个函数符号，就可以解释执行这个函数了。</p><p><img src=\"https://static001.geekbang.org/resource/image/f5/94/f51b98ba2c9468aef9f7a84c4ca74594.jpg?wh=1980x544\" alt=\"\"></p><p>通过这样的分析，你应该可以弄清楚直接调用函数和调用一个函数变量的区别了。前者要访问其sym属性来获得函数符号，而后者是通过变量的值来获得函数符号，进而解释执行该符号所关联的函数声明的AST。</p><p>AST解释器的参考实现，我仍然放在了<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/32/play.ts\">play.ts</a>中。你可以运行一下<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/32/example_fp.ts\">example_fp.ts</a>示例程序，看看能不能得到正确的运行结果。</p><p>好，接下来我们再看看在编译成可执行程序的情况下，如何使用函数式编程特性。</p><h2>编译成可执行程序</h2><p>我们刚刚已经说过，要支持函数式编程特性，最重要的是能够把函数当做值来传递。在AST解释器中，这个值是函数符号。那在编译成汇编代码的时候，我们用什么来代表一个函数呢？</p><p>你现在已经接触过很多汇编代码了，我相信你肯定知道，其实像函数这种高抽象度的语言要素，在Lower到汇编代码这个层面时，只是一个标签而已。在汇编代码转换成机器码的时候，这个标签就是代表了一段代码在程序文本段的一个地址而已。<strong>所以说，传递一个函数，就是传递一个函数地址。</strong></p><p>当你在程序里显式地调用一个函数的时候，只要让我们生成的汇编代码，直接跳转到这个函数的标签就行了。但当我们调用一个函数型的变量的时候，实质上就是要跳转到这个变量所存储的地址中。也就是说，这个地址不是在编译时能够确定的，而是在运行时根据函数型变量的值来确定。</p><p>这种在运行时来确定被调用的函数的机制，我们其实在上一节已经部分接触过了。在调用类的方法的时候，具体的方法地址，要去查vtable。不过，函数式编程中来获取函数地址就变得更灵活了，干脆是通过变量和参数来传递的。</p><p>我们还是用C语言写一个例子，看看这种地址传递是如何实现的。这里你可能会问了：我没听说过C语言是函数式编程语言呀？为什么可以用C语言写函数式编程的例子呢？</p><p>不着急。你看一下代码就知道了。在下面的示例程序中，我们用C语言重写了上面的示例程序，也包括reduce、max和sum这几个函数。</p><pre><code class=\"language-plain\">#include \"stdio.h\"\n\ndouble reduce(double* numbers, int length, double(*fun)(double, double)){ //使用函数指针\n    int prev = 0;\n    for (int i = 0; i&lt; length; i++){\n        prev = fun(prev, numbers[i]);\n    }\n    return prev;\n}\n\ndouble max(double prev, double cur){\n    if (prev &gt;= cur)\n        return prev;\n    else\n        return cur;\n}\n\ndouble sum(double prev, double cur){\n    return prev + cur;\n}\n\nint main(){\n    double numbers[8] = {2,3,4,5,7,4,5,2};\n    printf(\"%lf\\n\", reduce(numbers, 8, sum));\n    printf(\"%lf\\n\", reduce(numbers, 8, max));\n}\n\n</code></pre><p>在reduce函数中，最后一个参数是一个函数指针，这个函数指针会接受两个double类型的输入参数，返回一个double值。在C语言中，函数指针能够被作为数值传递，而这个指针的值实际上就是一个函数的入口地址。</p><p>所以说，虽然C语言并不强调函数式编程能力，其实你仍然可以用它来体现函数式编程思想的。就像C语言也不是面向对象的语言，但你仍然可以用它来体现面向对象编程思想。</p><p>那我们现在看看这段C语言的代码编译成汇编代码是什么样子。你可以用“clang -S fp.c -o fp.s”编译成汇编代码。然后，你可以查看main函数中下面这几行代码，这几行代码代表了“reduce(numbers, 8, sum)”。其中第三行代码就是获取了sum函数的地址，并作为reduce函数的第三个参数。</p><p><img src=\"https://static001.geekbang.org/resource/image/a4/e5/a4b61420e14906988f8c490d455e0de5.png?wh=1176x204\" alt=\"图片\"></p><p>你也可以再看看reduce函数中的代码片段。其中“callq *%rax”就是把sum或max函数的地址放在了rax寄存器里，然后跳转到这个地址去执行就行了。</p><p><img src=\"https://static001.geekbang.org/resource/image/06/24/0650a2f0dfbb7c42a23557cdb68f7824.png?wh=800x1254\" alt=\"图片\"></p><p>好了，现在我们通过剖析，已经弄清楚了如何把函数作为值传递了。不过，为了能够编译这节课的示例程序，我们还要实现一个小的技术点，就是能够正确的获取数组的长度，也就是示例代码中的“numbers.length”。这里要使用点符号表达式，访问数组对象的length属性。</p><p>这个话题我们在前几节课讨论过。我们目前已经从自定义的class对象中获取对象属性。而对于数组和字符串这样的内置数据类型，我们也可以访问它的一些属性。要访问这些属性，我们也是把它们翻译成内存地址就可以了，也就是在PlayObject的地址基础上加上一定的偏移量。</p><p>在实现了这个技术点之后，我们就可以编译并运行示例程序了。你也可以自己动手写几个程序，试一试高阶函数的特性。</p><p>具体的实现，我放在了<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/32/asm_x86-64.ts\">asm_x86-64.ts</a>中。</p><h2>课程小结</h2><p>今天这节课，我们初步实现了函数式编程的一个特性，把函数变成了跟其他数据一样的一等公民，从而可以支持高阶函数。这节课，我们记住这几个知识点就好了：</p><p>首先，为了把函数当做数据，我们需要支持函数类型，让我们可以声明函数类型的变量。</p><p>第二，在AST解释器中，函数类型的变量的值，可以表示为函数符号。</p><p>第三，在编译成可执行文件时，函数类型的变量的值，会被Lower成函数的地址。</p><p>在下一节课里，我们将会继续探究函数式编程的特性。</p><h2>思考题</h2><p>在函数式编程语言里，我们经常使用lambda表达式来表示一个函数。你能否分析一下，要支持lambda表达式，我们需要做一些什么工作？</p><p>欢迎你把这节课分享给更多对函数式编程感兴趣的朋友。我是宫文学，我们下节课见。</p><h2>资源链接</h2><p><a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/32\">这节课的代码目录在这里！</a></p>","neighbors":{"left":{"article_title":"31｜面向对象编程第3步：支持继承和多态","id":429917},"right":{"article_title":"33｜函数式编程第2关：实现闭包特性","id":432102}}},{"article_id":432102,"article_title":"33｜函数式编程第2关：实现闭包特性","article_content":"<p>你好，我是宫文学。</p><p>上节课，我们实现了函数式编程的一个重要特性：高阶函数。今天这节课，我们继续来实现函数式编程的另一个重要特性，也就是闭包。</p><p>闭包机制能实现信息的封装、缓存内部状态数据等等，所以被资深程序员所喜欢，并被用于实现各种框架、类库等等。相信很多程序员都了解过闭包的概念，但往往对它的内在机制不是十分清楚。</p><p>今天这节课，我会带你了解闭包的原理和实现机制。在这个过程中，你会了解到闭包数据的形成机制、词法作用域的概念、闭包和面向对象特性的相似性，以及如何访问位于其他栈桢中的数据。</p><p>首先，让我们了解一下闭包的技术实质，从而确定如何让我们的语言支持闭包特性。</p><h2>理解闭包的实质</h2><p>我们先通过一个例子来了解闭包的特点。在下面的示例程序中有一个ID的生成器。这个生成器是一个函数，但它把一个内部函数作为返回值来返回。这个返回值被赋给了函数类型的变量id1，然后调用这个函数。</p><pre><code class=\"language-plain\">function idGenerator():number{//()=&gt;number{\n    let nextId = 0;\n\n    function getId(){\n        return nextId++;  //访问了外部作用域的一个变量\n    }\n\n    return getId;\n}\n\nprintln(\"\\nid1:\");\nlet id1 = idGenerator();\nprintln(id1());  //0\nprintln(id1());  //1\n\n//新创建一个闭包，重新开始编号\nprintln(\"\\nid2:\");\nlet id2 = idGenerator();\nprintln(id2());  //0\nprintln(id2());  //1\n\n//闭包可以通过赋值和参数传递，在没有任何变量引用它的时候，生命周期才会结束。\nprintln(\"\\nid3:\");\nlet id3 = id1;\nprintln(id3());  //2\n</code></pre><!-- [[[read_end]]] --><p>然后神奇的事情就发生了。每次你调用id1()，它都会返回一个不同的值，依次是0、1、2……</p><p>为什么每次返回的值会不一样呢？</p><p>你看这个代码，内部函数getId()访问了外部函数的一个本地变量nextId。当外部函数退出以后，内部函数仍然可以使用这个本地变量，并且每次调用内部函数时，都让nextId的值加1。这个现象，就体现了闭包的特点。</p><p>总结起来，闭包是这么一种现象：<strong>一个函数可以返回一个内部函数，但这个内部函数使用了它的作用域之外的数据</strong>。这些作用域之外的数据会一直伴随着该内部函数的生命周期，内部函数一直可以访问它。</p><p>说得更直白一点，就是<strong>当内部函数被返回时，它把外部作用域中的一些数据打包带走了，随身携带，便于访问</strong>。</p><p>这样分析之后你就明白了。为了支持闭包，你需要让某些函数有一个私有的数据区，用于保存一些私有数据，供这个函数访问。在我们这门课里，我们可以把这个函数专有的数据，叫做闭包数据，或者叫做闭包对象。</p><p>然后我们再运行这个示例程序，并分析它的输出结果：</p><p><img src=\"https://static001.geekbang.org/resource/image/87/83/872a6b6c86df681dc76c2da42c315a83.png?wh=328x442\" alt=\"图片\"></p><p>你会发现这样一个事实：id1和id2分别通过调用idGenerator()函数获得了一个内部函数，而它们各自拥有自己的闭包数据，是互不干扰的。</p><p>从这种角度看，<strong>闭包有点像面向对象特性。每次new一个对象的时候，都会生成不同的对象实例。</strong>实际上，在函数式语言里，我们确实可以用闭包来模拟某些面向对象编程特性。不过这里你要注意，并不是函数所引用的外部数据，都需要放到私有的数据区中的。我们可以再通过一个例子来看一下。</p><p>我把前面的示例程序做了一点修改。这一次，我们的内部函数可以访问两个变量了。</p><pre><code class=\"language-plain\">//编号的组成部分\nlet segment:number = 1000;\n\nfunction idGenerator():()=&gt;number{\n    let nextId = 0;\n\n    function getId(){\n        return segment + nextId++;  //访问了2个外部变量\n    }\n\n    //在与getId相同的作用域中调用它\n    println(\"getId:\" + getId());\n    println(\"getId:\" + getId());\n\n    //恢复nextId的值\n    nextId = 0;\n\n    return getId;\n}\n\nprintln(\"\\nid1:\");\nlet id1 = idGenerator();\nprintln(id1());  //1000\nprintln(id1());  //1001\n\n//修改segment的值，会影响到id1和id2两个闭包。\nsegment = 2000;\n\n//新创建一个闭包，重新开始编号\nprintln(\"\\nid2:\");\nlet id2 = idGenerator();\nprintln(id2());  //2000\nprintln(id2());  //2001\n\n//闭包可以通过赋值和参数传递，在没有任何变量引用它的时候，生命周期才会结束。\nprintln(\"\\nid3:\");\nlet id3 = id1;\nprintln(id3());  //2002\n</code></pre><p>你看，我们增加了一个全局变量segment，而内部函数最后生成的id等于segment + nextId。比如，当segment=1000，nextId=8的情况下，生成的id就是1008。</p><p>并且，我们在两个不同的地方调用了这个内部函数。一个地方是在idGenerator内部，也就是声明getId()的函数作用域，而另一个调用则在全局程序中。在这两个情况下，函数访问变量数据的方式是不同的。</p><p>你能看到，在idGenerator内部调用函数getId()时，我们不需要为它设置私有数据区。为什么呢？因为getId()运行时所处的作用域和声明它的作用域是一样的，所以可以直接访问nextId和segment这两个变量。并且，nextId和segmentid的生存期都超过了调用getId()的时间区间，所以也不会出现像在第一个示例程序中，idGenerator中的nextId变量会随着idGenerator运行结束而消失的情形。</p><p>但在外部来调用id1()、id2()的时候，我们就需要把nextId变量放到私有数据区了。这是因为，调用id1()和id2()所在的作用域，与声明getId()的时候是不同的。在运行时的作用域中，已经“看不到”nextId变量了，所以必须把它放到私有数据区。不过，在这个作用域仍然是能够“看到”segment变量的，所以segment变量不需要放到私有数据区。</p><p>这样看起来，<strong>闭包现象跟作用域密切相关</strong>。所以这里我再引申一下，介绍一个术语，叫做<strong>词法作用域（Lexical Scope）</strong>，它的意思是声明一个符号时所在的作用域。对于函数来说，它总是在函数声明的作用域中绑定它所引用的各种变量。这样，我们以后不管在哪里执行这个函数，都会“记住”它们，也就是访问这个作用域中的变量的值。现代大部分语言使用的都是词法作用域。</p><p>词法作用域又叫做静态作用域。与静态作用域相对的呢，是动态作用域。动态作用域中，函数中使用的变量不是在语义分析阶段绑定好的，而是可以在运行期动态地绑定。比如，如果TypeScript使用的是动态作用域，而我们在调用id1()、id2()之前，声明了一个叫做nextId的变量，那么id1()和id2()执行的时候，其函数内部的那个nextId变量，就会跟刚声明的这个nextId变量绑定。那这个时候，也就不需要闭包了。</p><p>通过对比词法作用域和动态作用域，我希望你能加深对闭包的理解。对于学习了这门课程的你来说，理解它们的差别应该更容易。因为你已经清晰地知道，变量引用的消解都是发生在语义分析阶段，不会在运行期来改变这种引用关系。</p><p>最后，在示例程序中，你还会看到id3这个函数类型的变量，并且我们把id1赋给了id3。id1和id3引用的是同一个闭包。所以虽然我们不再使用变量id1了，但闭包所占用的内存并不会释放。并且，你还可以把这个闭包以参数的方式传给其他函数，甚至再被包含在其他闭包里。只要还有变量在使用这个闭包，那它的内存就不会被释放。这一点跟面向对象特性中的对象也是完全一致的。</p><p>好了，我们花了不少的篇幅来分析闭包的实质。但这些分析不是白费的。基于这些分析，你就可以迅速拿出实现方案来。</p><p>现在，就让我们直接上手试试。按照惯例，我们仍然要先修改编译器的前端。</p><h2>修改编译器前端</h2><p>在编译器的前端方面，我们主要是做一些语义分析工作。</p><p>根据前面的分析，<strong>首先我们要分析出一个函数里引用的变量中，哪些是在函数之外声明的</strong>。这项工作比较简单，因为我们在引用消解的时候，已经能够把变量的引用和变量的声明建立起关联关系，并且能够知道每个变量是在哪个作用域里声明的。</p><p>你可以用“node play example_closure.ts -v”，把示例程序的符号表打印出来，看看每个变量所属的作用域。这样，你就可以很容易地分析出内部函数所引用的外部变量。</p><p><img src=\"https://static001.geekbang.org/resource/image/71/42/71a8fd25b5b3f121440e00c22ffd0b42.png?wh=1462x1408\" alt=\"图片\"></p><p>在完成第一项分析以后，我们还要做第二个分析。也就是说，<strong>我们要识别出哪些变量仍然能够被访问到，而哪些是不能的</strong>。</p><p>这次分析是在调用外部函数并返回闭包的时候进行的。对于那些能够访问到的变量，我们可以继续访问，比如示例程序中的segment变量。而对于哪些已经不能够访问到的变量，我们则要创建一个私有的数据区来保管它们，比如示例程序中的nextld变量。</p><p>语义分析的参考实现，你可以参见<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/33/semantic.ts\">semantic.ts</a>。</p><p>在语义分析之后，我们继续来修改AST解释器，让它支持闭包特性。</p><h2>修改AST解释器</h2><p>在AST解释器里，为了让闭包正常运行，我们需要让函数能够正确访问外部的变量。根据我们前面的分析，这又分成两种情况。第一种情况，是要支持函数的私有数据区，用来保存nextId这样的变量。第二种情况，是能够访问其他函数栈桢中的变量，比如segment变量。</p><p><strong>首先我们看看第一种情况，就是为闭包设计私有的数据区。</strong></p><p>这里，我设计了一个ClosureObject数据结构，这个数据结构和PlayObject、StackFrame的设计相差不大，都用了一个Map来保存变量的数据，闭包函数可以从这里访问私有数据。</p><pre><code class=\"language-plain\">//闭包对象\nclass ClosureObject{\n    functionSym:FunctionSymbol;\n    data:Map&lt;Symbol,any&gt; = new Map();\n    constructor(functionSym:FunctionSymbol){\n        this.functionSym = functionSym;\n    }\n}\n</code></pre><p>在示例程序的栈桢中，id1和id3指向一个相同的ClosureObject，而id2指向另一个ClosureObject。当给函数变量赋值时，我们就把这个闭包对象赋给新的变量。闭包对象中包含了一个FunctionSym引用，这样解释器就知道要运行哪个函数的代码了。</p><p><img src=\"https://static001.geekbang.org/resource/image/a7/a8/a775ab6eae0795878b1f9bf14b6e9fa8.jpg?wh=1980x544\" alt=\"\"></p><p>你能看出来，使用ClosureObject跟使用PlayObject是很相似的。对于函数中的数据，我们要区分出来哪些是位于函数作用域中的，哪些是位于ClosueObject中的。而在运行对象方法时，我们也是要区分方法的本地变量和存放在PlayObject中的对象属性。</p><p><strong>好了，现在我们设计完了闭包的数据对象。接下来我们看看如何让函数访问其他函数的栈桢中的变量，比如访问segment变量。</strong></p><p>这个时候，函数的调用栈如下图所示。segment位于全局函数的栈桢中。而id1()所调用的函数逻辑，需要先找到segment所在的函数的栈桢，然后才能访问segment变量的值。可是如何能找到segment变量所在的栈桢呢？</p><p><img src=\"https://static001.geekbang.org/resource/image/24/ff/24a895267b661d078a2cd39b84df0aff.jpg?wh=1980x544\" alt=\"\"></p><p>你可能会说，这还不简单，不就是当前栈桢的上一级栈桢吗？图中就是这么显示的呀。</p><p>不，事情没那么简单。你看，我在原来的示例函数的基础上再增加了一点代码。我们增加了一个函数foo()，在foo里调用idGenerator()来生成闭包。</p><pre><code class=\"language-plain\">function foo():()=&gt;number{\n    println(\"\\nid4:\");\n    let id4 = idGenerator();\n    println(id4());\n    println(id4());\n    return id4;\n}\n\nlet id5 = foo();\nprintln(\"\\nid5:\");\nprintln(id5());\nprintln(id5());\n</code></pre><p>这个时候，调用栈就变成了下面这样，一共三级。你还可以再设计出更复杂的调用场景，产生更多级的栈桢。所以，id1()的上一级栈桢并不是segment变量所在的栈桢。</p><p><img src=\"https://static001.geekbang.org/resource/image/26/dc/26be4116ee194dda3e2e05055050yydc.jpg?wh=1891x841\" alt=\"\"></p><p>那如何找到segment变量所在的栈桢呢？这就需要我们的栈桢能够跟函数关联起来，让算法知道哪个栈桢是由哪个函数产生的，然后就可以找到正确的栈桢了。</p><pre><code class=\"language-plain\">class StackFrame{\n    //存储变量的值\n    values:Map&lt;Symbol, any&gt; = new Map();\n    \n    //返回值，当调用函数的时候，返回值放在这里\n    retVal:any = undefined;\n\n    //产生当前栈桢的函数\n    functionSym:FunctionSymbol;\n\n    constructor(functionSym:FunctionSymbol){\n        this.functionSym = functionSym;\n    }\n}\n</code></pre><p>好了，现在我们已经知道如何在AST解释器中支持闭包特性了。你可以查看<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/33/play.ts\">play.ts</a>中参考实现，研究一下其中的技术细节。</p><p>接下来我们再来分析一下，如何把闭包特性编译进可执行程序。</p><h2>编译成可执行程序</h2><p><strong>我们先来实现一下闭包的私有数据区。</strong></p><p>在这个技术特性上，我们完全可以借鉴面向对象特性的实现技术。我们可以把闭包函数，比作一个类的方法。至于闭包数据，我们就可以把它当做是对象的属性。</p><p>而当程序调用一个闭包函数的时候，它必须把闭包数据通过第一个参数传递进去，这个过程跟调用对象方法也是一样的。当调用对象方法的时候，对象引用也是第一个参数。</p><p>所以说，在有了实现面向对象特性的底子以后，我们再实现对闭包数据的管理，就会容易很多，可以充分借鉴原来的技术思路。</p><p><strong>不过，要实现另一个特性，也就是从别的函数的栈桢里找到所引用的外部变量的数据，就没那么简单了。</strong></p><p>按照AST解释器的实现逻辑，我们需要知道哪个栈桢是由哪个函数生成的。可是，我们马上就遇到了两个需要解决的技术点。</p><p><strong>第一个技术点，是我们并没有在可执行文件里保存函数符号的信息</strong>。在编译后的可执行文件里，每个函数都只是一些机器码而已。在汇编代码中用来标识每个函数入口的标签，也消失不见了，因为它的作用已经完成了。它的作用，就是用于计算函数的入口地址而已。我们甚至可以说，在我们现在生成的机器码里，根本就没有任何关于函数的概念。</p><p>这个问题是可以解决的。我们可以在可执行程序的数据区保存程序的符号信息。在研究C++程序生成的汇编代码中，我们已经看到，C++会在可执行文件里保存一些与类型有关的信息以及vtable。我们可以采用相同的技术手段，保存我们自己想保存的信息。</p><p>实际上，如果我们要调试程序，那就要往可执行文件里保存很多符号信息和调试信息，否则没办法知道栈桢和寄存器里的哪个数据对应的是哪个变量。所以，当我们用debug模式生成可执行文件时，要比release模式的可执行文件大很多。</p><p><strong>第二个技术点，是我们并没有在原来的栈桢里保存对函数的引用信息。</strong>所以，我们就难以搞清楚哪个栈桢是哪个函数生成的，也很难从中找到相应的变量。这个技术点也是可以解决的，这需要我们往栈桢里添加额外的信息，来建立栈桢和函数之间的对应关系。</p><p>不过，要实现这两个技术点，涉及的代码工作量有点大，我们在这节课的参考实现里就不包含这个特性了，你可以先自己动手试试。不用担心，这点我会在课程完结前补上。同时，在我们后面再迭代的、作为开源项目的PlayScript代码库中，也会添加这个特性，届时你再可以对照着看看。</p><h2>课程小结</h2><p>今天的内容就是这些。为了掌握闭包的特性，你需要记住以下几个知识点：</p><p>首先，闭包的产生，是由于声明时所引用的外部作用域中的变量，在运行时的作用域中并不存在，所以我们需要一个专门的数据区来保存这些数据。</p><p>第二，TypeScript采用的是词法作用域，也就是在语义分析阶段就把变量的使用和声明做了绑定，并且不再改变。这是需要闭包机制的根本原因。</p><p>第三，闭包特性跟面向对象特性有很多相似之处，闭包数据就类似于对象数据。我们调用闭包函数的时候，也要把闭包对象的引用传递给函数，类似于调用对象的方法。</p><p>第四，如果要访问其他函数的栈桢内的数据，我们需要记录每个栈桢是由哪个函数生成的。</p><h2>思考题</h2><p>今天的思考题，我想让你分享一下你使用闭包特性的场景，以及为什么要使用闭包特性。欢迎你在留言区留言。</p><p>欢迎你把这节课分享给更多感兴趣的朋友。我是宫文学，我们下节课见。</p><h2>资源链接</h2><p><a href=\"https://gitee.com/richard-gong/craft-a-language/tree/master/33\">这节课的代码目录在这里！</a></p>","neighbors":{"left":{"article_title":"32｜函数式编程第1关：实现高阶函数","id":431494},"right":{"article_title":"34｜内存管理第1关：Arena技术和元数据","id":433981}}},{"article_id":433981,"article_title":"34｜内存管理第1关：Arena技术和元数据","article_content":"<p>你好，我是宫文学。</p><p>通过前面8节课的学习，我们实现了对浮点数、字符串、数组、自定义对象类型和函数类型的支持，涵盖了TypeScript的一些关键数据类型，也了解了实现这些语言特性所需要的一些关键技术。</p><p>在这些数据类型中，字符串、数组、class实例，还有闭包，都需要从堆中申请内存，但我们目前还没有实现内存回收机制。所以，如果用我们现在的版本，长时间运行某些需要在堆中申请内存的程序，可能很快会就把内存耗光。</p><p>所以，接下来的两节课，我们就来补上这个缺陷，实现一个简单的内存管理模块，支持内存的申请、内存垃圾的识别和回收功能。在这个过程中，你会对内存管理的原理产生更加清晰的认识，并且能够自己动手实现基本的内存管理功能。</p><p>那么，首先我们要分析一下内存管理涉及的技术点，以此来确定我们自己的技术方案。</p><h2>内存管理中的技术点</h2><p>计算机语言中的内存管理模块，能够对内存从申请到回收进行全生命周期的管理。</p><p>内存的申请方面，一般不会为每个对象从操作系统申请内存资源，而是要提供自己的内存分配机制。</p><p>而垃圾回收技术则是内存管理中的难点。垃圾回收有很多个技术方案，包括标记-清除、标记-整理、停止-拷贝和自动引用计数这些基础的算法。在产品级的实现里，这些算法又被进一步复杂化。比如，你可以针对老的内存对象和新内存对象，使用不同的回收算法，从而形成分代管理的方案。又比如，为了充分减少由于垃圾收集所导致的程序停顿，发展出来了增量式回收和并行回收的技术。</p><!-- [[[read_end]]] --><p>关于这些算法的介绍，你可以参考《编译原理之美》的33节，里面介绍了各种垃圾收集算法。还有《编译原理实战课》的第32节，里面分析了Python、Java、JavaScript、Julia、Go、Swift、Objective-C等各种语言采用的内存管理技术的特点，也讨论了这些技术与语言特性的关系。在这节课里，我就不重复介绍这些内容了。</p><p>垃圾收集对语言运行的影响是很大的，因此我们希望垃圾回收导致的程序停顿越短越好，消耗的系统资源越少越好。这些苛刻的要求，导致在很多现代语言中，垃圾回收器（GC）成了运行时中技术挑战很高的一个模块。不过，再难的技术都是一口口吃下的。在这节课里，我们先不去挑战那些特别复杂的算法，而是选择一个最容易上手的、入门级的算法，<strong>标记-清除算法</strong>来做示范。</p><p>标记-清除算法的思路比较简单，只需要简单两步：</p><ul>\n<li>首先，我们要找出哪些内存对象不是垃圾，并进行标记；</li>\n<li>第二，回收掉所有没做标记的对象，也就是垃圾对象。</li>\n</ul><p>我们通过一个例子来看一下。在下图中，x和y变量分别指向了两个内存对象，这两个内存对象可能是自定义类的实例，也有可能是闭包、字符串或数组。这些对象中的字段，又可能会引用另外的对象。</p><p><img src=\"https://static001.geekbang.org/resource/image/00/74/007d0e8f91edec3fc88d17623a5dc774.jpg?wh=1891x841\" alt=\"\"></p><p>在图中，当变量x失效以后，它直接引用和间接引用的对象就会成为内存垃圾，你就可以回收掉它了。这就是标记-清除算法的原理，非常简单。</p><p><img src=\"https://static001.geekbang.org/resource/image/f3/y4/f3dc67e4daf9d0d7910048c1069d3yy4.jpg?wh=1891x841\" alt=\"\"></p><p>在这个图里，变量x和y叫做GC的根（GC root）。算法需要从这些根节点出发，去遍历它直接或间接引用的对象。这个过程，实际上就是图的遍历算法。</p><p>好了，算法上大的原理我们就搞清楚了。那接下来，我们需要讨论一些实现上的技术点，包括如何管理内存的申请和释放、如何遍历所有的栈帧和内存对象，等等。</p><p>首先说一下如何管理内存的申请和释放。</p><h2>内存的申请和释放</h2><p>在我们前面实现的、C语言版本的字节码虚拟机中，我们就曾经讨论过如何高效申请内存的问题。我们发现，如果调用操作系统的接口频繁地申请和释放小的内存块，会大大降低系统的整体性能。所以，我们采用了Arena技术，也就是一次性地从操作系统中申请比较大块的内存，然后再自行把这块大内存划分成小块的内存，给自己的语言使用。</p><p>在今天这节课，我们仍然使用Arena技术来管理内存：<strong>当我们创建新的内存对象的时候，就从Arena中找一块未被占用的内容空间；而在回收内存对象的时候，就把内存对象占的内存区域标记成自由空间。</strong></p><p>在这里你会发现，为了记住哪些内存是被分配出去的，那些内存是可用的，我们需要一个数据结构来保存这些信息。在我的参考实现里，我用了一个简单的链表来保存这些信息。每块被分配出去的内存，都是链表的一个节点。节点里保存了当前内存对象的大小，以及下一个节点的地址。</p><p><img src=\"https://static001.geekbang.org/resource/image/a7/f7/a7cdea038c6c2e55d0d20ebe109897f7.jpg?wh=1080x1687\" alt=\"\"></p><p>顺着这个链表，你可以查找出自由的内存。假设节点1的地址是80，对象大小是48字节，节点2地址是180，那么节点1和2之间就有52个字节的自由空间。</p><p>当我们要申请内存的时候，如果我们要申请的对象大小低于52个字节，那就可以把这块空间分配给它。这个时候，我们就要修改链表的指针，把新的节点插入到节点1和节点2之间。</p><p><img src=\"https://static001.geekbang.org/resource/image/46/57/461591430867520697abe1039d36b357.jpg?wh=1080x1687\" alt=\"\"></p><p>如果要回收内存呢？也比较简单，我们就从链表中去掉这个节点就好了。</p><p>了解了内存申请和释放的内容后，接下来，我们就需要查找并标记哪些内存是仍然被使用的，从而识别出内存垃圾。这就需要程序遍历所有栈帧中的GC根引用的对象，以及这些对象引用的其他对象。而要完成这样的遍历，我们需要知道函数、类和闭包等的元数据信息才可以。</p><h2>管理元数据</h2><p>我们前面说过，<strong>GC根就是那些引用了内存对象的变量</strong>。而我们知道，我们的程序中用到的变量，有可能是在栈中的，也有可能是在寄存器里的。那到底栈里的哪个位置是变量，哪个寄存器是变量呢？另外，如何遍历所有的栈帧呢？如何知道每个栈帧的开头和结尾位置？又如何知道哪个栈帧是第一个栈帧，从而结束遍历呢？这些都是需要解决的技术问题，我们一个一个来看。</p><p>首先，我们要确定栈帧和寄存器里，哪些是变量，也就是GC根。</p><p>这就需要我们保存变量在栈帧中的布局信息。对于每个函数来说，这些布局信息都是唯一的。这些信息可以看做是函数的元数据的一部分。其他元数据信息包括函数的名称，等等。</p><p>我们用一个例子来分析一下变量布局情况。下面的foo函数的栈帧里，包括几个本地变量和几个临时变量。基于我们的寄存器分配算法，这些变量有些会被Spill到栈帧中。比如，如果某个变量使用的寄存器是需要Caller保护的，那么在调用另一个函数的时候，这些变量就会被Spill到内存中。</p><pre><code class=\"language-plain\">function foo(b:number):number{\n    let a:number[] = [1,2,b];   \n    let s:string = \"Hello PlayScript!\";\n    println(s);\n    println(a[2]);\n    return b*10;\n}\n\nprintln(foo(2));\n</code></pre><p>另外，如果一个函数用到了需要Callee保护的寄存器，那么这些寄存器的信息也会被写入到栈帧，这些寄存器的值也可能是调用者的某个变量。算法可以查询调用者的变量布局信息来确认这一点。</p><p>最终，对于foo函数来说，这些变量在栈帧中的布局如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/84/09/844de3b629312582ef1c325dcb2f5309.jpg?wh=1980x1080\" alt=\"\"></p><p>那包含了变量布局的元数据信息，应该保存到哪里呢？你可能已经想到了，它们可以被保存在可执行文件的数据区呀，就像之前我们保存vtable那样。</p><p>在具体实现的时候，这个数据区可以分成多个组成部分。像vtable这样的数据，出于性能上的要求，我们最好能够比较快捷地访问，所以我们让程序通过“1跳”，也就是只做一次获取地址的操作，就能到查到方法的入口地址。而对于其他元数据信息，由于数据类型跟vtable的不一样，可以安排到另一个数据区中，并从第一个数据区链接过去。元数据在静态数据区的布局如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/9d/f5/9d05b441206dc73c7fd26611011096f5.jpg?wh=1980x1080\" alt=\"\"></p><p>它们在汇编代码中可以写成下面的样子：</p><pre><code class=\"language-plain\">.section   __DATA,__const\n    .globl  _foo.meta               ## can be accessed globally\n    .p2align    3                   ## 8 byte alignment\n_foo.meta:\n    .quad   _foo.name               ## link to function name section\n    .quad   2                       ## var count\n    .quad   0x0000000001000010      ## var0, type: 1, address offset: 16\n    .quad   0x0000000106000018      ## var1, type: 6, address offset: 24\n\n    .section    __TEXT,__const\n    .globl  _foo.name               ## can be accessed globally\n    .p2align    3                   ## 8 byte alignment\n_foo.name:\n    .asciz  \"foo\"\n</code></pre><p>好了，通过函数的元数据，我们已经可以知道栈帧内每个变量的地址是什么，以及哪些变量才是对象引用。</p><p>可是，如果内存对象是一个class实例，或者是一个数组、一个闭包，那它们还可以引用其他的内存对象。所以我们还要继续往下查找并做标记。</p><p>对于对象实例来说，我们需要知道对象的属性都是一些什么类型，是否是对象引用，它们的地址又是什么。所以，我们需要扩展刚才的元数据区，保存class的元数据，包括这个class有哪些属性、每个属性的类型，以及该属性在对象数据中的位置。另外，我们还需要记录该class的父类，用一个指针指向父类的元数据，从而能够访问从父类继承下来的属性的信息。</p><p>那如何基于对象实例访问到这些元数据信息呢？</p><p>这个简单，因为我们已经在每个对象的对象头都预留了8字节的一个位置，用来保存类引用。那么，在每次创建对象的时候，我们就在这个位置存上类的元数据信息的起始地址就好了。<br>\n<img src=\"https://static001.geekbang.org/resource/image/d4/36/d4ee76b12d2a8c7c7b4f960c247b5f36.jpg?wh=1080x1073\" alt=\"\"></p><p>我们再来看看如何处理数组对象。如果数组中存放的数据是对象引用，那我们需要遍历数组的元素。不过因为一个数组里每个元素的类型是一样的（目前为了简单，暂且不支持类型为any的数组），所以我们可以偷懒，让数组对象头里的类引用也指向元素类型所对应的元数据就好了。对于系统内置的类型，比如number、string等，我们可以特殊处理，建立特殊的元数据信息。</p><p>最后，我们再看看闭包。我们知道，闭包也会在堆里形成对象，所以我们也需要知道闭包对象里的数据是否引用了其他对象。不过，处理闭包的复杂之处在于，对于闭包所引用的变量，如果它所在的函数的生存期还没有结束，那么要从该函数的栈帧里访问变量数据；而如果它所在的函数的生存期已经结束，那么这个变量的数据是保存在闭包对象中的。所以，在运行期，当我们要访问一个闭包数据的时候，总是要先从现有栈帧中去查找，之后才在闭包对象中查找。</p><p>为了支持上面这些的数据查找过程，我们需要设计与闭包有关的元数据信息。这个倒也简单，就是把函数引用的所有外部作用域中的变量，以及该变量所在的函数信息保存起来就行。你可以看一下我画的图示。</p><p><img src=\"https://static001.geekbang.org/resource/image/ac/cd/acbe88486f1dc0a37728d56a98e162cd.jpg?wh=1080x1073\" alt=\"\"></p><p>这样的话，你通过闭包的元数据，就能找到闭包中的每个变量所在的函数，从而确定它的类型信息了。你还可以遍历栈帧，来找到该变量具体的值。如果我们在栈帧里找不到这个变量，那么到闭包对象中去找就好了。</p><p>不过这里要注意一下，在闭包对象中，我们为每个闭包变量都预留了一个位置，即使这个位置有可能用不上。比如，在下面闭包的例子中，当闭包位于bar()函数中的时候，它是可以访问segment2变量的。但如果它到了main函数中，就不能在栈帧中访问segment2了，而是要从闭包对象中访问。所以，我们要提前在闭包对象中预留这个内存空间才可以。</p><pre><code class=\"language-plain\">//编号的组成部分\nlet segment:number = 1000;\n\nfunction bar():()=&gt;number{\n    //编号的另一个组成部分\n    let segment2:number = 100;\n    function idGenerator():()=&gt;number{\n        let nextId = 0;\n    \n        function getId(){\n            return segment + segment2 + nextId++;  //访问了3个外部变量\n        }\n    \n        //在与getId相同的作用域中调用它\n        println(\"getId in bar:\" + getId());\n        segment2 += 100;\n        println(\"getId in bar:\" + getId());\n    \n        //恢复nextId的值\n        nextId = 0;\n    \n        return getId;\n    }\n\n    //在bar函数中调用，这时候可以看到segment2变量\n    println(\"\\nid6:\");\n    let id6 = idGenerator();\n    println(\"\\nid6:\");\n    println(id6());\n    println(id6());\n\n    return id6;\n}\n\n//在main函数中调用，这时候可以看到segment变量\n//而segment2和nextId都保存在闭包对象里了。\nprintln(\"\\nid7:\");\nlet id7 = bar();\nprintln(id7());\nprintln(id7());\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/0f/a2/0fb7acf68bba863bbd106b1d78d44ca2.jpg?wh=1080x1073\" alt=\"\"></p><p>好了，关于元数据的讨论就是这些。你可以运行\"node play example_metadata.ts --dumpAsm\"命令，生成带有元数据信息的汇编文件，看看各类元数据信息都是如何保存的。</p><h2>课程小结</h2><p>这节课的内容就是这些。关于内存管理和垃圾回收技术，我希望你能对下面这些知识点留下深刻的印象。</p><p>首先，垃圾收集的算法是很多的，GC也是现代语言运行时中的一个重要组成部分。GC中可能会综合采用多种算法。但只有先掌握像标记-清除、停止-拷贝这样的基础算法，才能进一步去掌握更复杂的算法。</p><p>第二，内存管理技术不仅包括垃圾收集功能，还包括语言自己的内存分配功能。内存分配模块要能记住哪些内存是被分配出去的，还要能够找到合适大小的可用内存给新对象，也要能够把回收后的内存释放出来。</p><p>第三，为了遍历所有的栈帧中的GC根，以及内存对象所引用的其他对象，我们必须保存函数、类和闭包的元数据信息，元数据信息保存在可执行文件的数据区中。在函数的栈帧和内存对象中，我们都要保存指向这些元数据的引用。</p><p>你应该也注意到了，我们花了大量的篇幅讨论元数据，也讨论了如何把它们编译到可执行文件中去。这项技术很重要，如果我们要debug程序，就非常依赖这些信息。而且，如果我们未来还要支持一些元编程功能，比如像Java的Reflection机制那样，去在运行时动态调用类的方法，那也需要依靠这些元数据信息。</p><p>最后，我再补充一点。在C、C++这些语言的工具链中，我们今天提到的这些元数据信息，跟符号信息其实是差不多的意思。而Java等语言，似乎更愿意用\"元数据\"这样的术语。你只要理解它们是差不多的就行了。</p><p>在下一节课里，我们将利用现在保存好的元数据信息，去遍历所有的栈帧和对象，识别内存垃圾，并进行回收。</p><h2>思考题</h2><p>为了在汇编代码中保存一些静态数据，我们用到了越来越多的伪指令。所以，我又要建议你去多熟悉手册。这次，我希望你把<a href=\"https://sourceware.org/binutils/docs-2.37/as/index.html\">GNU汇编器的手册</a>熟悉起来。那么今天的思考题呢，就要让你查查手册，看看我们这节课生成的汇编代码中，.asciz、.p2align和.quad都是什么意思。另外，如果我要向数据区写4字节的整型数据，应该用什么伪指令呢？</p><p>欢迎把这节课分享给更多感兴趣的朋友。我是宫文学，我们下节课见。</p><h2>资源链接</h2><p><a href=\"https://gitee.com/richard-gong/craft-a-language/tree/master/34-35\">这节课的示例代码在这里！</a></p>","neighbors":{"left":{"article_title":"33｜函数式编程第2关：实现闭包特性","id":432102},"right":{"article_title":"35｜内存管理第2关：实现垃圾回收","id":435868}}},{"article_id":435868,"article_title":"35｜内存管理第2关：实现垃圾回收","article_content":"<p>你好，我是宫文学。</p><p>今天这节课，我们继续上一节课未完成的内容，完成垃圾回收功能。</p><p>在上一节课，我们已经实现了一个基于Arena做内存分配的模块。并且，我们还在可执行程序里保存了函数、类和闭包相关的元数据信息。</p><p>有了上一节课的基础之后，我们这节课就能正式编写垃圾回收的算法了。算法思路是这样的：</p><ul>\n<li>首先，我们要有一个种机制来触发垃圾回收，进入垃圾回收的处理程序；</li>\n<li>第二，我们要基于元数据信息来遍历栈帧，找到所有的GC根；</li>\n<li>第三，从每个GC根出发，我们需要去标记GC根直接和间接引用的内存对象；</li>\n<li>最后，我们再基于对象的标记信息，来回收内存垃圾。</li>\n</ul><p>在今天这节课，你不仅仅会掌握标记-清除算法，其中涉及的知识点，也会让你能够更容易地实现其他垃圾回收算法，并且让我们的程序能更好地与运行时功能相配合。</p><p>那接下来，我们就顺着算法实现思路，看看如何启动垃圾回收机制。</p><h2>启动垃圾回收机制</h2><p>在现代的计算机语言中，我们可以有各种策略来启动垃圾回收机制。比如，在申请内存时，如果内存不足，就可以触发垃圾回收。甚至，你也可以每隔一段时间就触发一下垃圾收集。不过不论采取哪种机制，我们首先要有办法从程序的正常执行流程，进入垃圾回收程序才行。</p><p>进入垃圾回收程序，其实有一个经常使用的时机，就是在<strong>函数返回</strong>的时候。这个时候，我们可以不像平常那样，使用retq跳回调用者，而是先去检查是否需要做垃圾回收：如果需要做垃圾回收，那就先回收完垃圾，再返回到原来函数的调用者；如果不需要做垃圾回收，那就直接跳转到函数的调用者。</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/84/a8/8469d534e77f0e46a792aac104232ba8.jpg?wh=1891x841\" alt=\"\"></p><p>实现这个功能很简单，只需要在return语句之前调用frame_walker这个内置函数，并把当前%rbp寄存器的值作为参数传进去就好了：</p><pre><code class=\"language-plain\">visitReturnStatement(rtnStmt:ReturnStatement):any{\n  if (rtnStmt.exp!=null){\n      let ret = this.visit(rtnStmt.exp) as Oprand;\n\n      //调用一个内置函数，来做垃圾回收\n      this.callBuiltIns(\"frame_walker\",[Register.rbp]);//把当前%rbp的值传进去\n\n      //把返回值赋给相应的寄存器\n      let dataType = getCpuDataType(rtnStmt.exp.theType as Type);\n      this.movIfNotSame(dataType, ret, Register.returnReg(dataType));\n  ...\n  }\n}\n</code></pre><p>这样，我们就能获得调用GC程序的时机。</p><p>在这段代码中，frame_walker内置函数的功能是遍历整个调用栈。这就是我们启动垃圾回收机制后，要进行的下一个任务。接下来我们就来分析一下具体怎么做。</p><h2>遍历栈帧和对象</h2><p>遍历栈帧其实很简单，因为我们能够知道每个栈帧的起始地址。从哪里知道呢？就是rbp寄存器。rbp寄存器里保存的是每个栈帧的底部地址。</p><p>每次新建立一个栈帧的时候，我们总是把前一个栈帧的rbp值保护起来，这就是你在每个函数开头看到的第一行指令：pushq %rbp。因此，我们从栈帧里的第一个8字节区域，就可以读出前一个栈帧的%rbp值，这就意味着我们得到了前一个栈帧的栈底。然后你可以到这个位置，再继续获取更前一个栈帧的地址。具体你可以看下面这张图：</p><p><img src=\"https://static001.geekbang.org/resource/image/1c/80/1c5f725c3db3f4d8b34dbee123db5a80.jpg?wh=1080x1073\" alt=\"\"></p><p>那这个思路真的有用吗？我们直接动手试一下！</p><p>首先，我写了一个简单的测试程序。在这个程序里，main函数调用了foo，foo又调用了bar。这样，在foo和bar返回前，我们都可以启动垃圾回收，但从main函数返回的时候就没有必要启动了，因为这个时候进程结束，进程从操作系统申请的所有内存，都会还给操作系统。</p><pre><code class=\"language-plain\">function foo(a:number):string{\n    let s:string = \"PlayScript!\"\n    let b:number = bar(a+5);\n    return s;\n}\n\nfunction bar(b:number):number{\n    let a:number[] = [1,2,b];   \n    let s:string = \"Hello\";\n    println(s);\n    println(a[2]);\n    b = b*10;\n    return b;\n}\n\nprintln(foo(2));\n\n</code></pre><p>接下来，我又写了一个frame_walker.c的程序。这个程序很简单，就是依次打印出每个栈帧所保存的rbp寄存器的地址。在程序里，rbpValue0是调用frame_walker.c程序的函数的rbp值，这个值是当前栈帧的底部。在这个地址里，保存的是前一个栈帧原来的rbp值，也就是前一个栈帧的rbp的地址，依次类推。</p><pre><code class=\"language-plain\">//遍历栈帧\nvoid frame_walker(unsigned long rbpValue0){\n    //当前栈帧的rbp值\n    printf(\"\\nrbpValue0:\\t0x%lx(%ld)\\n\", rbpValue0, rbpValue0);  \n    \n    //往前一个栈帧的rbp值\n    unsigned long rbpValue1 = *(unsigned long*)rbpValue0;\n    printf(\"rbpValue1:\\t0x%lx(%ld)\\n\", rbpValue1, rbpValue1);  \n\n    //再往前一个栈帧\n    unsigned long rbpValue2 = *(unsigned long*)rbpValue1;   \n    printf(\"rbpValue2:\\t0x%lx(%ld)\\n\", rbpValue2, rbpValue2);  \n\n    //再往前一个栈帧\n    unsigned long rbpValue3 = *(unsigned long*)rbpValue2;   \n    printf(\"rbpValue3:\\t0x%lx(%ld)\\n\", rbpValue3, rbpValue3);  \n    \n    //再往前一个栈帧\n    unsigned long rbpValue4 = *(unsigned long*)rbpValue3;   \n    printf(\"rbpValue4:\\t0x%lx(%ld)\\n\", rbpValue4, rbpValue4);  \n}\n</code></pre><p>最后，你可以用make example_gc命令，编译成可执行文件。运行这个可执行文件，会打印出下面的输出内容：</p><p><img src=\"https://static001.geekbang.org/resource/image/21/94/213a5cccafb1f04ddf88be0a9b3bf194.png?wh=1200x640\" alt=\"图片\"></p><p>你可能注意到了，frame_walker一共打印了5个栈帧的rbp值。但是我们的程序最多的时候也只用到了3个栈帧呀，那之前更多的那些栈帧是什么呢？这个问题我留给你，看看你能不能用操作系统的知识来回答这个问题。</p><p>但目前，我们还只是能找到每个栈帧，接下来我们还要进一步解析栈帧里的内容，从而找到GC根，并经由GC跟查找到内存对象。<strong>这就需要我们查找函数的元数据了</strong>。</p><p>这时候你会发现，为了查找函数的元数据，我们必须知道每个栈帧是由哪个函数生成的。这个问题我们在闭包的那一节课也曾经讨论过，正好在这里实现。</p><p>具体实现起来倒也不复杂。我们可以约定，在栈帧的一开头、紧挨着保存%rbp寄存器的信息的下面，保存该函数的元数据区的指针。这样，每个函数的汇编代码的序曲部分就会像下面那样。其中，后两行代码就是用来保存meta区的地址的：</p><pre><code class=\"language-plain\">pushq   %rbp\nmovq    %rsp, %rbp\nmovq    _foo.meta@GOTPCREL(%rip), %rax\nmovq    %rax, -8(%rbp)\n</code></pre><p>在这里，“_foo.meta@GOTPCREL(%rip)”是使用相对于%rip寄存器的偏移量，也就是通过下一行代码地址的偏移量来确定_foo.meta标签的地址的。</p><p>我们曾经也用过相对于%rip寄存器寻址的方式，比如获取double型字面量。你会发现这里有一点不同，当时我们并没有“@GOTPCREL”这一小段文字。这里会涉及到链接器和代码定位的一些技术细节。在这里，你可以理解为，因为我们把这些元数据声明在数据段，而不是像double字面量一样声明在文本段，所以就要用到一个不同的定位方式就行了。</p><p>好了，现在我们可以从每个函数的栈帧出发，来找到函数的元数据了。所以，我又写了一个新版本的frame_walker函数，来访问函数元数据，打印出每个栈帧里的变量的情况。我们给这个函数传递的参数，是当前栈帧rbp的值。</p><pre><code class=\"language-plain\">void frame_walker(unsigned long rbpValue){\n    printf(\"\\nwalking the stack:\\n\");\n    while(1){\n        //rbp寄存器的值，也就是栈底的地址\n        printf(\"rbp value:\\t\\t\\t0x%lx(%ld)\\n\", rbpValue, rbpValue); \n\n        //函数元数据区的地址\n        unsigned long metaAddress = *(unsigned long*)(rbpValue -8);\n        printf(\"address of function meta:\\t0x%lx(%ld)\\n\", metaAddress, metaAddress);\n\n        //函数名称的地址，位于元数据区的第一个位置\n        unsigned long pFunName = *(unsigned long*)metaAddress;\n        printf(\"address of function name:\\t0x%lx(%ld)\\n\", pFunName,pFunName);\n\n        //到函数名称区，去获取函数名称\n        const char* funName = (const char*)pFunName;\n        printf(\"function name:\\t\\t\\t%s\\n\", funName);\n\n        //变量数量，位于元数据区的第二个位置\n        unsigned long numVars = *(unsigned long*)(metaAddress+8);\n        printf(\"number of vars:\\t\\t\\t%ld\\n\", numVars);\n\n        //遍历所有的变量\n        for (int i = 0; i&lt; numVars; i++){\n            //获取变量属性的压缩格式，3个属性压缩到了8个字节中\n            unsigned long varAttr = *(unsigned long*)(metaAddress+8*(i+2));\n            printf(\"var attribute(compact):\\t\\t0x%lx(%ld)\\n\", varAttr,varAttr);\n\n            //拆解出变量的属性\n            unsigned long varIndex = varAttr&gt;&gt;32;  //变量下标，4个字节\n            unsigned long typeTag =  (varAttr&gt;&gt;24) &amp; 0x00000000000000ff; //变量类型编号，1个字节\n            unsigned long offset = varAttr &amp; 0x0000000000ffffff;   //变量在栈帧中的地址偏移量\n\n            printf(\"var attribute(decoded):\\t\\tvarIndex:%ld, typeTag:%ld, offset:%ld\\n\", varIndex, typeTag, offset);\n        }\n\n        //去遍历上一个栈帧\n        rbpValue = *(unsigned long*)rbpValue;\n\n        printf(\"\\n\");\n\n        //如果遇到main函数，则退出\n        if (strcmp(funName, \"main\")==0) break;\n    }\n}\n\n\n\n</code></pre><p>再次编译并运行，就会打印出每个函数栈帧里的信息。这些信息是在bar函数快要返回的时候，遍历各个栈帧打印出来的。从这些信息里，你能够清晰地看到每个函数的栈帧里保存了哪些变量，还有每个变量在栈帧中的位置和每个变量的类型。</p><p><img src=\"https://static001.geekbang.org/resource/image/7e/0e/7ec414116c96549f4640f3ba9d24d20e.png?wh=1424x1080\" alt=\"图片\"></p><p><strong>接着我们来找GC根和它直接引用的对象。</strong>你可以看到，bar函数的栈帧里一共有2个变量，分别是参数b和变量a。其中参数b是整型的，所以不是GC根。而变量a是一个数组，它是GC根，所以我们要标记该数组对象为活跃的。而foo函数的栈帧里也有两个变量，分别是参数a和变量s。</p><p>不过，看到这个结果，你肯定会产生一些疑问。首先，为什么bar函数里字符串变量s没有出现在栈帧里，而foo函数里同样的字符串变量s却出现在了栈桢里呢？</p><p>这是因为，在bar函数要返回的时刻，字符串s已经被bar函数使用完毕了，变成内存垃圾了。而foo函数现在是执行到第二个语句，并且调用了bar函数。在从bar函数返回以后，它还要在第三条语句中用到字符串变量s，所以s仍然是alive的，需要被保存下来。</p><p>bar函数里的参数b也是一样的，因为它是被return语句引用的，所以在返回之前，仍然是alive。</p><p>那可能你又要问了，不对呀，按照这么说，bar函数中的数组变量a和foo函数中的参数a，应该都没有用了呀，不用去遍历了呀。特别是bar函数中的数组，应该作为内存垃圾回收了才对。</p><p>没错，这是我们当前算法的缺陷。我们没有去保存变量活跃性分析的结果，也就是说在每一行代码处，到底哪些变量是活跃的，我们是不知道的。这样，我们也就没有办法精确地判断哪些变量其实已经失效了。并且，其实我们也没有办法精确地判断，每个函数现在执行到了哪一行代码，哪些代码是活跃的。</p><p>所以，我们这里用了一个近似的算法：只要是曾经被spill到栈帧里的变量，我们都认为它们是值得被保护的，还是活跃的。这个算法其实这在实际的应用中已经足够了。</p><p><strong>那既然找到了对象引用，接下来我们就可以标记这个对象了</strong>。在每个对象的头部，我们都预留了8个字节的空间，用来设置各种标志位。这8个字节，在一开始申请内存的时候，都被设置成了0。我们现在要做的也比较简单，只需要把第一位作为“是否是内存垃圾”的标记位就好了。如果该标志位为1，那就说明这对象是有用的，不能回收。如果是0，那么就说明它是内存垃圾。</p><p>好了，现在我们已经完成了最复杂的任务，也就是遍历栈帧，找到并标记对象引用。<strong>接下来，我们还要基于这些对象，进一步找出它们所引用的其他内存对象</strong>。</p><p>在这一部分，针对自定义对象、数组和闭包，我们都需要编写相对应的遍历方法，但原理跟前面我们遍历函数寻找GC根是一致的，都是去查找元数据，这里我就不一一展开了，你可以去看mem.c中的源代码。</p><p>现在标记完所有的对象以后，接下来的事情就简单了。接下来，我们可以遍历Arena中的每个内存块，然后再在内存块里遍历每一个对象，把没有标记的对象删掉。对于标记过的对象，我们就要把它的标记去掉，为下一次垃圾收集做好准备。</p><p>好了到这里，我们相关算法的实现思路已经梳理清楚了。现在是时候验证我们的成果了，我们内存管理的相关算法到底是否能成功呢？</p><h2>测试垃圾回收算法</h2><p>我们直接运行程序，来检验一下。你可以运行命令make example_gc，生成可执行程序，并运行它，会得到如下输出结果：<br>\n<img src=\"https://static001.geekbang.org/resource/image/9d/9b/9dec8cbaab7c1ccc9df8beb4ef94409b.png?wh=1000x1080\" alt=\"\"></p><p>你可以看到，程序bar函数和foo函数结束的时候，分别释放了一些内存垃圾。并且，每次申请内存和垃圾回收，GC都打印出了当前Arena中的信息，你会看到Arena中内存分配的详细信息。在做完垃圾回收以后，相关内存空间确实被释放掉了。</p><p>也就是说，我们的垃圾回收算法算是圆满成功了！</p><h2>课程小结</h2><p>今天这一节课，我们接着上一节完成了垃圾回收算法。我希望你能记住几个要点：</p><p>第一，我们有很多种方式可以启动垃圾回收机制。在这里，我们用了最简单的一种方式，也就是在退出函数前触发垃圾回收机制。类似的，你还可以在循环语句的地方检查是否需要做垃圾回收，因为程序中的循环可能会耗费很长的时间，积累很多内存垃圾。这里，我们的程序和运行时就形成了一种协作机制。</p><p>其实这种协作机制，也是实现另一个重要的运行时功能，并发管理的基础，特别是协程机制，需要当前程序与协程的调度器主动配合，才能完成细颗粒度的并发调度。你从这节课中，应该会直观地感受到这些运行时的调度机制是怎么运作的。</p><p>第二，我们是通过查询栈帧的布局信息去寻找GC根的。我们可以认为，没有出现在栈帧布局中的变量，肯定是已经失效了的。而出现在栈帧布局中的变量，有些其实也已经失效了，但我们当前没有必要去做更加精细化地管控。</p><p>第三，这节课示范了如何具体访问各种元数据信息。这些技能很重要，能让你可以在可执行文件里自由地存放各种自己需要的静态数据，让程序的运行机制拥有更多的可能性。</p><p>最后，我们通过两节课实现了内存分配和垃圾回收的工作。虽然实现得比较简单，但却是一个良好的开始。你在此基础上，可以更快地实现其他的算法。比如，你可以把内存整理一下，减少内存碎片，这样就是实现了标记-整理算法。你还可以把所有分配了的内存对象拷贝到一个新的区域，这就实现了停止-拷贝算法，也就是Java等语言普遍采用的算法。</p><p>不过，当你在内存中移动对象的时候，又会遇到新的技术挑战。比如，你需要知道栈帧中的哪些变量是引用了这个对象，再来更新这些值。再比如，当你的程序正在读写一个数组的时候，整个数组却被GC挪到了另一个位置，那与数组处理有关的功能就可能会出错。当然，这些技术点也都有解决办法，相关的书籍和文章已经有很多。但有了我们这两节的基础，你可以自己动手来验证这些知识点了。</p><p>在作为开源项目的PlayScript代码库中，我会继续迭代、修改与垃圾收集有关的算法，如果你有兴趣可以继续一起研究。</p><h2>思考题</h2><p>在这节课的示例程序中，为了启动垃圾回收机制，我采用了一个普通的函数调用的方式。但是，有没有办法对这个方式进行优化？比如，因为当前函数要退出了，除了返回值，其他变量都不用检查了。再比如，这个函数的栈桢也可以被垃圾回收函数复用，就像尾调用优化那样。我想问一下，你要如何修改现有的调用垃圾回收函数的机制，才能实现上面的优化呢？</p><p>欢迎把这节课分享给更多对内存管理感兴趣的朋友。我是宫文学，我们下节课见。</p><h2>资源链接</h2><p><a href=\"https://gitee.com/richard-gong/craft-a-language/tree/master/34-35\">这节课的示例代码目录在这里！</a></p>","neighbors":{"left":{"article_title":"34｜内存管理第1关：Arena技术和元数据","id":433981},"right":{"article_title":"36｜节点之海：怎么生成基于图的IR？","id":436924}}},{"article_id":436924,"article_title":"36｜节点之海：怎么生成基于图的IR？","article_content":"<p>你好，我是宫文学。</p><p>从今天这节课开始，我们就要学习我们这门课的最后一个主题，也就是优化篇。</p><p>在前面的起步篇和进阶篇，我们基本上把编译器前端、后端和运行时的主要技术点都过了一遍。虽然到现在，我们语言支持的特性还不够丰富，但基本上都是工作量的问题了。当然，每个技术点我们还可以继续深挖下去，比如我们可以在类型计算中增加泛型计算的内容，可以把上两节课的垃圾收集算法改成更实用的版本，等等。在这个过程中，你还需要不断克服新冒出来的各种技术挑战。不过，基本上，你已经算入了门了，已经把主要的知识脉络都打通了。</p><p>而第三部分的内容，是我们整个知识体系中相对独立、相对完整的一部分，也是我们之前屡次提起过，但一直没有真正深化的内容，这就是优化。</p><p>优化是现代语言的编译器最重要的工作之一。像V8和其他JavaScript虚拟机的速度，比早期的JavaScript引擎提升了上百倍，让运行在浏览器中的应用可以具备强大的处理能力，这都是优化技术的功劳。</p><p>所以，在这第三部分，我会带你涉猎优化技术中的一些基础话题，让你能够理解优化是怎么回事，并能够上手真正做一些优化。</p><p>那在这第一节课，我会带你总体了解优化技术的作用、相关算法和所采用的数据结构。接着，我会介绍本课程所采用的一个行业内前沿的数据结构，基于图的IR，又叫节点之海，从而为后面具体的优化任务奠定一个基础。</p><!-- [[[read_end]]] --><p>那首先，我们先简单介绍一下与优化有关的背景知识。</p><h2>有关优化的背景知识</h2><p>如果我要把优化的内容和算法都大致介绍一下，可能也需要好几节课的篇幅。不过，我在《编译原理之美》的<a href=\"https://time.geekbang.org/column/article/155338\">第27节</a>和<a href=\"https://time.geekbang.org/column/article/156878\">28节</a>，对优化算法的场景和分类，做了一些通俗的介绍。对于优化算法，特别是基于数据流分析的优化算法，也做了一些介绍。</p><p>而在《编译原理实战课》中，我在<a href=\"https://time.geekbang.org/column/article/256914\">第14节</a>、<a href=\"https://time.geekbang.org/column/article/257504\">15节</a>、<a href=\"https://time.geekbang.org/column/article/262041\">21节</a>、<a href=\"https://time.geekbang.org/column/article/264643\">23节</a>、<a href=\"https://time.geekbang.org/column/article/266379\">24节</a>分别涉及了Java、JavaScript、Julia和Go语言的编译器中的优化技术。所以，我这里就不重复那些内容了，只提炼几个要点，重点和你说一下优化的目标、分类、算法，以及数据结构，让你做好讨论优化技术的知识准备。</p><h3>优化的目标</h3><p><strong>优化工作最常见的目标，是提高代码运行的性能</strong>。在有些场景下，我们还会关注降低目标代码的大小、优化IO次数等其他方面。</p><h3>优化工作的分类</h3><p>优化技术的种类非常多，我们很难用一个分类标准把各种优化工作都涵盖进去。但通常，我们会按照几个不同的维度来进行分类。</p><p>从优化算法的作用范围（或者空间维度）来说，可以分为局部优化（针对基本块的优化）、全局优化（针对整个函数）和过程间优化（多个函数一起统筹优化）。</p><p>从优化的时机（也就是时间维度）来说，我们在编译和运行的各个阶段都可以做优化。所以llvm的主要发起人Chris Lattner曾经发表了一篇论文，主题就是<strong>全生命周期优化</strong>。在编译期呢，编译器的前端就可以做优化，比如我们已经做过一些常数折叠工作。在后端也可以做一些优化，比如我们前面讲过的尾递归和尾调用优化。</p><p>但大部分优化是发生在前端和后端中间的过渡阶段，这个阶段有时候也被叫做中端。除了这些，还有运行时的优化。对于V8这种JIT的引擎，在运行时还可以收集程序运行时的一些统计信息，对程序做进一步的优化编译，在某些场景下，甚至比静态编译的效果还好。</p><h3>优化的算法</h3><p>优化涉及的算法也有很多。比如，前面我们做常量折叠的时候，基本上遍历一下AST，进行属性计算就行了 ，但在做尾递归和尾调用优化的时候，我们就需要基于栈桢的知识对生成的汇编代码做调整，这里面就涉及到了一些优化的算法。但其中最有用的，则是<strong>控制流</strong>和<strong>数据流分析</strong>。</p><p>对于数据流分析，我们已经讲过不少了。那控制流分析是怎么回事呢？<strong>控制流分析的重点是分析程序跳转的模式</strong>，比如识别出来哪些是循环语句、哪些是条件分支语句等等，从而找到可以优化的地方。</p><p>比如，如果一个循环内部的变量，是跟循环无关的。那我们就可以把它提到循环外面，避免重复计算该变量的值，这种优化叫做“循环无关变量外提”。比如下面的示例程序中，变量c的值跟循环是无关的，所以我们就没必要每次循环都去计算它了。而要实现这种优化，需要优化算法把程序的控制流分析清楚。</p><pre><code class=\"language-plain\">function foo(a:number):number{\n  let b = 0;\n  for (let i = 0; i&lt; a; i++){\n      let c = a*a;  //变量c的值与循环无关，导致重复计算！\n      b = i + c;\n  }\n  return b;\n}\n\n</code></pre><h3>优化算法所依托的数据结构</h3><p>针对中端的优化工作，我们最经常采用的数据结构是<strong>控制流图</strong>，也就是CFG。在生成汇编代码的时候，我们已经接触过控制流图了。当时我们把代码划分成一个个的基本块，每个基本块都保存一些汇编代码，基本块之间形成控制流的跳转。控制流图的数据结构用得很广泛，比如llvm编译器就是基于CFG的，这也意味着像C、C++、Rust、Julia这些基于llvm的语言都受益于CFG数据结构。另外，虽然Go语言并不是基于llvm编译器的，但也采用了CFG。</p><p><strong>控制流图最大的优点，当然是能够非常清楚地显示出控制流来，也就是程序的全局结构</strong>。而我们做数据流分析的时候，通常也要基于这样一个控制流的大框架来进行。比如，我们在做变量活跃性分析的时候，就是先分析了在单个的基本块里的变量活跃性，然后再扩展到基于CFG，在多个基本块之间做数据流分析。</p><p>不过，虽然CFG的应用很普遍，但它并不是唯一用于优化的数据结构。特别是，像Java编译器Graal和JavaScript的V8引擎，都采用了另一种基于图的IR。不过构成这个图的节点并不是基本块。我在这节课后面会重点介绍这个数据结构，并且说明为什么采用这个数据结构的原因。</p><p>刚才我挑重点介绍了与优化有关的背景知识。不过，我用短短的篇幅浓缩了太多的干货，你可能会觉得过于抽象。所以，我还是举几个例子更加直观地说明一下与优化有关的知识点，借此我们也可以继续讨论下面关于IR的话题。</p><h2>一个优化的例子</h2><p>我们先来看这个代码片段，这段代码中，x和y都被赋值成了a+b。</p><pre><code class=\"language-plain\">x = a + b\ny = a + b\nz = y - x\n</code></pre><p>你用肉眼就能看出来，第二行代码是可以被优化的，因为x和y的值是一样的，所以在第二行代码中，我们就不需要再计算一遍a+b了，直接把x赋值给y就行。这种优化，叫做“<strong>公共子表达式删除（Common Subexpression Elimination）</strong>”：</p><pre><code class=\"language-plain\">x = a + b\ny = x\nz = y - x\n</code></pre><p>再接着看，其实第三行也是可以优化的。因为y是等于x的，所以 z := x - x，也就是 z : = 0。这种优化方法，是把y的值传播到了第三行，所以就叫做<strong>“拷贝传播（Copy Propagation）</strong>”。</p><pre><code class=\"language-plain\">x = a + b\ny = x\nz = x - x  //进一步可以优化成 z = 0\n</code></pre><p>再进一步，我们假设这个代码片段后面跟着的代码，不需要再用变量y了，那我们就可以把第二行代码删除，这个方法就叫做“<strong>死代码删除（Dead Code Elimination）</strong>”。</p><p>为了实现上面这些优化工作，我们经常使用的就是数据流分析算法。比如说，使用我们之前学过的变量活跃性分析，我们就可以知道在第二行处，其实y是不活跃的，是死代码，可以删除。</p><p>同时，我们在优化算法中，还会经常使用一种叫做“<strong>使用-定义链(Use-def chain</strong>)”的技术，也就是在变量的定义和使用之间建立连接。从变量的定义，可以找到所有使用它的地方。反过来，在每个使用变量的地方，也可以找到它的定义。</p><p>我们用这种技术分析一下上面的第一个代码片段。在这段代码中，x的定义使用到了a和b，而它自己又被y和x所使用，这样就构成了use-def链。</p><p><img src=\"https://static001.geekbang.org/resource/image/42/52/4210235fc24c28ddf2d186b96ceb9252.jpg?wh=1785x640\" alt=\"图片\"></p><p>那use-def链有什么用途呢？我们通过use-def链知道了变量和定义之间的关系以后，实际上也就清楚了数据是怎么从一个变量流动到另一个变量的，这其实就是程序中的数据流。知道了这些之后，我们就能更容易地进行数据流分析，也更容易实现优化。</p><p>比如，既然y的定义是x，那么x可以顺着use-def链往下传，传播到z的定义中，也就是第三行代码中，实现拷贝传播。</p><p>而且，用def-use链判断死代码也更容易。比如，在第三个代码片段中，是没有变量引用y的，所以我们就能断定用来定义y的第二行肯定是死代码了。</p><p>所以，use-def链是一项很有用的技术，比如llvm等很多编译器都采用了它。</p><p>不过，为了更好地使用use-def链技术，更清晰地表达程序中的数据流，我们对于要使用的IR是有一定要求的，也就是要求IR是符合SSA格式的。</p><h2>静态单赋值（SSA）格式的IR</h2><p>我们首先说说什么是IR。我估计你应该知道IR的意思的。IR是Intermediate Representation的缩写，字面意思是中间表达，也就是我们的程序在转变成目标代码之前的一些中间格式。</p><p>从广义角度来说，介于源代码和目标代码之间的各种中间格式，都可以叫做IR。从这个意义上来说，AST也可以看做是一种IR。不过，<strong>当我们提到IR的时候，更多时候指的是它比较狭义的意思，也就是用于优化的中间格式</strong>。</p><p>IR也是有很多种的。在上面的示例程序中，我使用的这种IR叫做“三地址代码”，这也是教科书中经常使用的一种IR。这种IR的每个变量就是一个地址，比如x = a + b中，赋值符号左边是一个地址，右边最多可以有两个地址。</p><p>那我刚才提到的，要求IR是符合SSA格式的，又是什么意思呢？</p><p>SSA是Static Single Assignment的缩写，也就是<strong>静态单赋值</strong>。它的意思是，<strong>在代码中每个变量只能被定义一次</strong>。比如，如果我们之前定义x为a+b，之后又定义它为c+d，那这个IR就不符合SSA格式了。</p><pre><code class=\"language-plain\">x = a + b\n...\nx = c + d\n</code></pre><p>这说的也是单赋值，那静态单赋值中的静态又是什么意思呢？</p><p>其实，如果某个变量的赋值是出现在一个循环中，那么在程序运行的时候，这个变量可能被赋值了多次，这是程序的动态情况。而我们目前对代码所做的分析，都是静态分析。我们可以说，只要在代码中，变量只被赋值过一次，就是符合SSA的。</p><p>如果每个变量只被赋值过一次，那么用“定义”这个词汇就很准确了，因为每个变量都是被其他变量所唯一定义的，在使用过程中一直不变的。</p><p>不过，为什么要求IR必须是SSA格式的呢？因为SSA格式的IR会产生很多好处，使得优化算法更加简单。</p><p>比如在下面的代码片段中，a一开始被赋值为c，后来被赋值为d。那么这个时候，虽然x和y的定义相同，但它们实际的值是不同的，因为a的定义发生了变化，所以这里我们就不能进行子表达式删除的优化了。如果我们仍然要用use-def链来保存定义和使用的关系的话，那就必须要把a的这两个值区分开，比如变成a1和a2，这样实际上也就变成了SSA格式。</p><pre><code class=\"language-plain\">a = c\nx = a + b\na = d\ny = a + b\n</code></pre><p>我再用TypeScript举一个例子。在下面这个代码片段中，变量a被赋值了两次。在第一次，a是一个整型数据，在第二次，它变成了字符串型。</p><pre><code class=\"language-plain\">let a:number|string;\na = 2;             //a现在是整型\nconsole.log(a+3);  //打印出5\na = \"2\";           //a变成了字符串型\nconsole.log(a+3);  //打印出字符串\"23\"\n</code></pre><p>在这里例子中，前后两个a的定义其实是完全不相关的，连类型都不一样，所以这里本来就应该写成两个变量才更合理。</p><p>好了，我想你大致应该明白了SSA的含义以及使用SSA的原因了。那我们再进一步，介绍一种先进的、用图来表示的IR。</p><h2>基于图的IR：节点之海</h2><p>在前面的示例程序中，变量之间的定义-使用链是能够形成一张图的。如果再加上运算符，我们就可以用这张图来表达程序的逻辑了。</p><p>比如，这里有一个程序片段：</p><pre><code class=\"language-plain\">x = a + b\ny = a + b\nz = y * 10\n</code></pre><p>如果我们把变量之间的数据流关系以及运算符画成图，就是下面的样子：</p><p><img src=\"https://static001.geekbang.org/resource/image/a2/2b/a23d5dfd69f48f12acdc93c4c97f4f2b.jpg?wh=1188x640\" alt=\"图片\"></p><p>乍一看，你会觉得这是一颗倒过来的AST。如果按照AST来看，z的值确实就是(a+b)*10，一点都没错。</p><p>这里你要注意的是，在生成这个图的时候，我们可以把相同的表达式合并。比如，x和y的值都是a + b，那么我们就用同一个子图来表示就好了，这样，我们自然而然地就实现了公共子表达式的删除的优化。从这一点上，你就能初步看到这种IR的优势了。</p><p><img src=\"https://static001.geekbang.org/resource/image/e2/41/e2b4ee887741b6abbbc10125a2c6f741.jpg?wh=1188x640\" alt=\"图片\"></p><p>我们再接着看这个子图，你会发现，+号运算符有两条输出的边，代表它依赖这两条边所指向的a和b变量来提供值。还有一条输入的边，这里代表另一节点依赖这个节点数据。不过，也有的论文会把箭头反过来画，这样的话箭头方向代表的就是数据的流动方向，而不是数据依赖关系了，但它们表达的意思是一样的。</p><p>不过，目前我们画出来的图，只能用来表示数据流，表达像刚才这样的进行算术运算的直线式执行的逻辑，但不能表达控制流逻辑，比如if语句、for循环语句和调用函数这些。不过，你现在已经学习过生成汇编代码了，所以你应该知道这些控制流逻辑都有一个共同的特点，就是它们会生成跳转指令，跳转到另外的代码地址去执行。</p><p>但我们仍然可以用图的方式来表达控制流逻辑。现在让我们先来分析一个带有if语句的简单的函数的例子，这个例子是用TypeScript写的：</p><pre><code class=\"language-plain\">function foo(a:number, b:number):number{\n  let x:number;\n  if (a&gt;10){\n    x = a + b;\n  }\n  else{\n    x = a - b;\n  }\n  return x;\n}\n</code></pre><p>把这个程序转化成图，是下面的样子：</p><p><img src=\"https://static001.geekbang.org/resource/image/6d/1d/6d67505a10a288c9c6cfce56fb53e91d.jpg?wh=1486x1080\" alt=\"图片\"></p><p>我解释一下这张图。</p><p>首先，我们先看一下数据流的部分，也就是橙色线的和橙色节点的部分。你会看到，原来的变量x，现在要变成x1和x2这两个变量，这样才符合SSA的要求，每个变量只赋值一次。</p><p>但这个时候就有个问题了，我们最后一条语句“return x”中的x，到底是x1还是x2呢？</p><p>这显然取决于程序的控制流走得是哪个语句块。如果走得是if块呢，那么就使用x1，否则就使用x2。</p><p>所以，这里我们引入了一个phi节点。这个节点的作用，就是根据控制流提供的信息，来确定选择两个值中的哪一个。我在图中用黑线表示了从控制流中提供过来的信息。从这个例子中，你也可以看出，<strong>phi运算是SSA格式的IR中必然会采用的一种运算，用来从多个可能的数据流分支中选择一个值</strong>。</p><p>那接下来我们再看看控制流，也就是程序中的蓝色节点和蓝色箭头的部分。</p><p>控制流是从start节点开始的，这也是进入函数的点。接着，在if语句那里，控制流会根据if条件为真还是假，形成两条分支。因此，if节点需要从“a&gt;10”这个节点获得条件表达式的计算结果。由于这个值是与控制流有关的，所以我也把这条箭头线也画成了黑色。</p><p>从if语句发出的两条控制流都以begin开头，以end结尾。如果每条分支里还有嵌套的if语句和循环语句，新的控制流节点就会出现在begin和end之间。这两条控制流在merge节点合并在一起，并且它们会给merge节点提供一个信息，说明控制流到底是从哪条分支过来的。这个信息又会给到数据流中的phi节点，告诉phi节点应该计算哪个数据流分支的数据。</p><p>到这里，整个图就完成了。这个图也忠实地体现了原来程序的逻辑。</p><p>其实这个图，就是当前JavaScript的V8编译器和Java的Graal编译器都在使用的一种IR。我们后面的课程还会进一步解析这个IR，也会再分析如何基于这个IR来编译程序。</p><p>最后说说“节点之海”这个别名。你可以看到，我们的示例程序是非常简单的，但都形成了由这么多的节点构成的图。可以想象，如果程序更复杂一点，节点就会更多。并且，我们在优化时还会把多个函数的图按照调用关系拼在一起，形成更大的图，就会更加令人眼花缭乱，所以这个IR也被叫做节点之海。好在，计算机的处理能力可比我们的眼睛强多了，完全能够基于这样的IR愉快地完成优化和编译工作。</p><h2>课程小结</h2><p>这节课到这里就结束了。今天这节课，我以非常紧凑的篇幅，介绍了与优化有关的背景知识，目的是帮助你把思路转移到优化这个主题上，开始一起思考与优化有关的技术。而今天这节课重点呢，显然是介绍JavaScript和Java编译器都在使用的一种基于图的IR。这里，我希望你记住几个知识点。</p><p>首先，你需要记住优化技术的常用分类，比如按照空间维度，也就是优化的范围，可以分为本地优化、全局优化和过程间优化。从时间维度，优化技术可以贯穿整个程序的生命周期。</p><p>第二，从算法角度，优化算法也有很多，数据流分析算法仍然很有用。</p><p>第三，从数据结构角度，优化算法需要依托定义良好的数据结构和IR。之前我们使用过的CFG是常用的、成熟的数据结构，而基于图的IR则是更前沿的、值得我们关注的一个数据结构。</p><p>第四，你还需要熟悉一些常见的优化场景，比如这节课提到的子表达式删除、拷贝传播、死代码删除、循环无关变量外提，等等。这样，你在思考与优化有关的技术的时候，会更容易联系实际。</p><p>第五，目前成熟语言的编译器里用于做优化的IR都是符合SSA格式的，它的好处是更容易形成use-def链、分隔开原本就应该是不同的变量、更有利于算法运行，等等。这节课介绍的基于图的IR也是符合SSA格式的，因为每个节点代表一个变量，所以每个节点当然只能静态赋值一次。你要注意，SSA格式的IR遇到控制流的分支和合并时，需要一个phi运算帮助确定到底选择哪条数据流线路上的值。</p><p>第六、关于基于图的IR，你目前只需要记住它能够同时表达数据流和控制流，并且它也能够像AST一样忠实地反映源代码的逻辑就好了，在后面的课程中我们还会继续深入了解它。</p><p>总结一遍以后，发现今天的知识点还真是挺密集的，我希望你能多看几遍，加深印象。</p><h2>思考题</h2><p>今天这节课，我们介绍了几个的简单的优化场景。你能不能再给我们分享一下你知道的优化场景和优化技术？多了解这些场景，会让我们的学习更加联系实际。</p><p>欢迎你把这节课分享给更多感兴趣的朋友。我是宫文学，我们下节课见。</p>","neighbors":{"left":{"article_title":"35｜内存管理第2关：实现垃圾回收","id":435868},"right":{"article_title":"37 | 从AST到IR：体会数据流和控制流思维","id":439771}}},{"article_id":439771,"article_title":"37 | 从AST到IR：体会数据流和控制流思维","article_content":"<p>你好，我是宫文学。</p><p>在上一节课，我们已经初步认识了基于图的IR。那接下来，我们就直接动手来实现它，这需要我们修改之前的编译程序，基于AST来生成IR，然后再基于IR生成汇编代码。</p><p>过去，我们语言的编译器只有前端和后端。加上这种中间的IR来过渡以后，我们就可以基于这个IR添加很多优化算法，形成编译器的中端。这样，我们编译器的结构也就更加完整了。</p><p>今天这节课，我先带你熟悉这个IR，让你能够以数据流和控制流的思维模式来理解程序的运行逻辑。之后，我还会带你设计IR的数据结构，并介绍HIR、MIR和LIR的概念。最后，我们再来讨论如何基于AST生成IR，从而为基于IR做优化、生成汇编代码做好铺垫。</p><p>首先，我还是以上一节课的示例程序为础，介绍一下程序是如何基于这个IR来运行的，加深你对控制流和数据流的理解。</p><h2>理解基于图的运行逻辑</h2><p>下面是上节课用到的示例程序，一个带有if语句的函数，它能够比较充分地展示数据流和控制流的特点：</p><pre><code class=\"language-plain\">  function foo(a:number, b:number):number{\n    let x:number;\n    if (a&gt;10){\n      x = a + b;\n    }\n    else{\n      x = a - b;\n    }\n    return x;\n  }\n</code></pre><p>我们把这个程序转化成图，是这样的：</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/13/65/13fe00d052e8ccc7923424b7a2b34e65.jpg?wh=1920x1047\" alt=\"图片\"></p><p>我们之前说了，这个图能够忠实地反映源代码的逻辑。那如果程序是基于这个图来解释执行的，它应该如何运行呢？我们来分析一下。</p><p>第1步，从start节点进入程序。</p><p>第2步，程序顺着控制流，遇到if节点，并且要在if节点这里产生分支。但为了确定如何产生分支，if节点需要从数据流中获取一个值，这个值是由“&gt;”运算符节点提供的。所以，“a&gt;10”这个表达式，必须要在if节点之前运行完毕，来产生if节点需要的值。</p><p>第3步，我们假设a&gt;10返回的是true，那么控制流就会走最左边的分支，也就是if块，直到这个块运行结束。而如果返回的是false，那么就走右边的分支，也就是else块，直到这个块运行结束。这里，if块和else块都是以Begin节点开始，以End节点结束。如果块中有if或for循环这样导致控制流变化的语句，那么它们对应的控制流就会出现在Begin和End之间，作为子图。</p><p>第4步，在if块或else执行结束后，控制流又会汇聚到一起。所以图中这里就出现了一个Merge节点。这个节点把两个分支的End节点作为输入，这样我们就能知道实际程序执行的时候，是从哪个分支过来的。</p><p>第5步，控制流到达Return节点。Return节点需要返回x的值，所以这就要求数据流必须在Return之前把x的值提供出来。那到底是x1的值，还是x2的值呢？这需要由Phi节点来确定。而Phi节点会从控制流的Merge节点获取控制流路径的信息，决定到底采用x1还是x2。</p><p>最后，return语句会把所获取的x值返回，程序结束。</p><p>在我这个叙述过程中，你有没有发现一个重要的特点，就是<strong>程序的控制流和数据流是相对独立的，只是在个别地方有交互</strong>。这跟我们平常写程序的思维方式是很不一样的。在写程序的时候，我们是把数据流与控制流混合在一起的，不加以区分。</p><p>比如，针对当前我们的示例程序，我们的源代码里一个if语句，然后在if块和else块中分别写一些代码。这似乎意味着，只能在进入if块的时候，才运行x1=a+b的代码，而在进入else块的时候，才可以运行x2=a-b的逻辑。</p><p>但如果你把数据流和控制流分开来思考，你会发现，其实我们在任何时候都可以去计算x1和x2的值，只要在return语句之前计算完就行。比如说，你可以把x1和x2的计算挪到if语句前面去，相当于把程序改成下面的样子：</p><pre><code class=\"language-plain\">function foo(a:number, b:number):number{\n  x1 = a + b;\n  x2 = a - b;\n  if (a&gt;10){\n    x = x1;\n  }\n  else{\n    x = x2;\n  }\n  return x;\n}\n</code></pre><p>当然，针对我们现在的例子，把x1和x2提前计算并没有什么好处，反倒增加了计算量。我的用意在于说明，<strong>其实数据流和控制流之间可以不必耦合得那么紧，可以相对独立。</strong></p><p>我们可以用这种思想再来分析下我们上节课提到的几个优化技术。</p><p>比如，我们上一节课曾经提到过“循环无关变量外提”的优化技术。而基于当前的IR，我们马上就会识别出，其实与这个变量有关的数据流，是跟循环语句的控制流没有依赖关系的，所以自然就可以提到外面去。</p><p>如果采用CFG的数据结构，我们需要把代码从一个基本块挪到另一个基本块，这个过程比较复杂。而采用基于图的IR，我们只需要在生成代码的时候，再决定把数据流对应的代码生成到哪个基本块里就好了。</p><p>其实，虽然llvm采用了CFG表示大的控制流逻辑，但它同时也采用了use-def链来表示程序中的数据流逻辑，因为优化算法需要同时用到这两方面的信息。但相对来说，我们现在的IR让控制流和数据流更大程度地解耦了，带来了算法上的便利。</p><p>而且，这个例子中的数据流节点，并不受限于if语句的控制流，在任何时候你都可以计算它，可以灵活地调整执行的先后顺序，这个时候我们说它们是浮动（floating）节点。它们的计算顺序只受输入关系的限制。</p><p>我们后面还会遇到一些情况，比如数据流的某些节点没有那么自由，它们不可以随意改变计算顺序，那我们说这些节点是固定的。</p><p>好了，你现在已经对基于IR的运行逻辑有了一定的理解了。那接下来，我们就开始动手做实现吧！首先，我们要用TypScript设计一些数据结构，来表示这种基于图的IR，就像我们之前设计了一些数据结构来表示AST那样。</p><h2>设计IR的数据结构</h2><p>要表达这种基于图的IR，重点就是<strong>设计各种各样的节点</strong>。而节点之间的连线呢，则是<strong>通过节点之间的互相引用来表示</strong>的。</p><p>我先设计了一个叫IRNode的基类，其他的节点都是从这个基类派生的。</p><pre><code class=\"language-plain\">//基类\nexport abstract class IRNode{\n}\n</code></pre><p>IRNode有两个直接的子类，DataNode和ControlNode。</p><p>DataNode是所有数据节点的基类。DataNode可能从别的DataNode获得输入，也会成为其他DataNode的输入，这样就构成了use-def链。这个链是双向的连接，DataNode的子类只需要维护自己的input的一边，uses是被使用到它的其他节点在构造函数里自动维护的。</p><pre><code class=\"language-plain\">//数据流节点的基类\nexport abstract class DataNode extends IRNode{\n    //该节点的输入\n    abstract get inputs():DataNode[];\n\n    //使用该节点的节点，形成use-def链,自动维护\n    uses:DataNode[] = []; \n\n    //数据类型\n    theType:Type;   \n}\n</code></pre><p>DataNode的一个子类是二元运算节点。在这里，你可以看看其中的uses是如何被自动维护的：</p><pre><code class=\"language-plain\">//二元运算节点\nexport class BiOpNode extends DataNode{\n    left:DataNode;\n    right:DataNode;\n\n    constructor(left:DataNode, right:DataNode, theType:Type){\n        super(theType);\n        this.left = left;\n        this.right = right;\n\n        //自动建立双向的use-def链\n        left.uses.push(this);\n        right.uses.push(this);\n    }\n\n    get inputs():DataNode[]{\n        return [this.left, this.right];\n    }\n}\n</code></pre><p>IRNode的另一个子类ControlNode，是各种控制节点的共同基类。控制节点可能有多个后序节点，但最多只能有一个前序节点。</p><pre><code class=\"language-plain\">//控制流节点的基类\nexport abstract class ControlNode extends IRNode{\n     //后序节点列表\n     abstract get successors():IRNode[];\n\n     //前序节点列表,自动维护\n     predecessors:IRNode[] = []; \n}\n</code></pre><p>在ControlNode的子类中，我们只需要维护自己的后序节点，形成正向的链接就好了。而前序节点是被自动维护的，形成反向的链接。这样，前后两个节点之间就有了双向链接。</p><p>ControlNode的一个子类是IfNode。它有两个后序节点，并且还需要一个来自DataNode的输入作为if的条件。</p><pre><code>//if节点\nexport class IfNode extends ControlNode{\n    thenBranch:Begin;\n    elseBranch:Begin;\n    condition:DataNode;  //If条件\n    \n    constructor(condition:DataNode, thenBranch:Begin, elseBranch:End){\n        super();\n        this.condition = condition;\n        this.thenBranch = thenBranch;\n        this.elseBranch = elseBranch;\n\n        thenBranch.predecessors.push(this);\n        elseBranch.predecessors.push(this);\n    }\n\n    get successors():IRNode[]{\n        return [this.thenBranch, this.elseBranch];\n    }\n}\n</code></pre><p>基于这个思路，我们可以设计出目前需要的各种IR节点，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/60/8b/604402e08f7d654f32a473697ca07b8b.jpg?wh=1080x1132\" alt=\"图片\"></p><p>这里的具体实现，你可以看<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/37/ir.ts\">ir.ts</a>。</p><p>你看到这里，肯定会有很多的问题。你可能会问，为什么要设计出这样的节点？IR中包含哪些类型的节点，有没有什么依据呀？这些节点怎么跟AST差不多呀？那我们就来分析一下这几个IR设计的问题。</p><h2>HIR、MIR和LIR</h2><p>其实，我们目前设计的IR节点，都是抽象度比较高的。换句话说，它跟AST在语义上是差不多的，只不过是换了一种表示方式而已。这种比较贴近源代码的、抽象层次比较高的IR，被叫做<strong>HIR</strong>。</p><p>与之相对应的另一端，是比较贴近机器实现的、容易转化成机器码或者汇编码的IR，叫做<strong>LIR</strong>。</p><p>我们具体说说HIR和LIR的区别，也就是说，抽象层级的差别，到底体现在哪里。</p><p><strong>首先，是一些控制流节点的差别</strong>。在HIR里，你会见到像if节点这样的元素，显然这种元素来自源代码。在LIR里，像if节点这样的节点会被类似跳转指令的节点所代替。它们都是实现控制流的管理的，但一个抽象层级更高，一个更底层。</p><p><strong>第二，在数据节点方面也有区别。</strong>在HIR里，我们用加减乘数这样的节点来表达运算。每个运算节点可以由两个节点来提供数据，计算结果保存到另一个节点，这样一共是3个地址。而在LIR里，有的CPU架构和指令集，比如X86的架构，是不支持三地址运算的，只能把一个数据加到另一个数据上，所以还必须进行IR的转换。</p><p><strong>最后，在数据类型方面也有很大差别。</strong>高级语言中有丰富的类型系统，你可以在HIR中使用它们。但到了LIR层面，你只能使用CPU可以识别的数据类型，比如各种不同位数的整型和浮点型。但是对象、数组这些，通通都消失不见了。</p><p>通过这样的对比，你大概能够明白HIR和LIR的区别了。</p><p>那最后，位于HIR和LIR之间，还有一种叫做<strong>MIR</strong>。它既能让我们人类比较容易理解，又能够尽量保持对特定硬件平台的独立性。</p><p><strong>在传统的编译器中，我们需要分别设计HIR、MIR和LIR，然后实现依次的转换。这个过程，就叫做Lower的过程。</strong></p><p>在前面的课程里，我们曾经使用了一些内部的数据结构，比如Inst和Oprand来表示汇编代码，这就可以看做是很Low很Low的IR了，因为它很贴近X86架构的实现，没有什么跨硬件平台的能力。就算这样，我们仍然从中分出了两个层次。像函数调用、浮点数字面量的实现，我们一开始还是采用比较抽象的Oprand，之后再Lower到跟汇编代码能够完全一一对应的Oprand。</p><p>这里我要说明一下，基于图的IR还有另一个重要的优点，就是<strong>我们可以用同一种数据结构来表示HIR、MIR和LIR</strong>。它们的区别，只是体现在不同的节点类型上。在Lower的过程中，你可以用低抽象度的节点替换高抽象度的节点就行了。</p><p>好了，我们现在理解了IR设计中的抽象层次问题。那接下来，我们就要把AST翻译成IR。</p><h2>把AST翻译成IR</h2><p>我们一开始只需要把AST翻译成HIR。因为这两者在语义上是比较相似的，所以翻译的难度比较低。相比而言，我们之前直接从AST翻译成汇编代码，中间的跨度就有点大，需要处理的细节就很多。</p><p>首先，我们看最简单的情况，也就是没有if语句、for循环语句这种程序分支的情况。比如下面的代码：</p><pre><code class=\"language-plain\">function foo(a:number, b:number){\n    let x:number = a + b;\n    let y:number = a + b;\n    let z:number = x + y + 1;\n}\n</code></pre><p>在这种情况下，a和b被翻译成参数节点，1被翻译成常量节点，每个表达式都被翻译成了一个运算节点，这些节点也是x、y和z三个本地变量的定义。</p><p><img src=\"https://static001.geekbang.org/resource/image/7e/03/7ecb77f3eb515e649172c1987db3cc03.jpg?wh=1528x905\" alt=\"图片\"></p><p>这里你要注意几个点。首先，本地变量都是被参数、常数和其他变量定义出来的，是数据流的中间节点。而参数和常量节点才可以是叶子节点。这是IR跟AST的一个很大的不同，因为AST中，本地变量是可以作为叶子节点的。</p><p>第二，一个运算节点可能跟多个变量相关联，比如示例程序中的a + b，就既代表了x变量，又代表了y变量。</p><p>最后，上面的示例程序中还有一个现象，就是在变量z的定义中，出现了连续的加法运算。这个时候，中间的一个+号节点并不对应某个变量的符号，这时候它相当于一个临时变量。</p><p><strong>接下来，我们把这个例子再复杂化一点，让变量x做了第二次赋值。这个时候，我们需要把这两个x区分开，从而让生成的IR保持SSA格式。</strong></p><pre><code class=\"language-plain\">function foo(a:number, b:number){\n    let x:number = a + b;\n    let y:number = a + b;\n    x = a - b;\n    let z:number = x + y + 1;\n}\n</code></pre><p>把x分解成x1和x2以后，这个示例程序就相当于变成了下面的样子：</p><pre><code class=\"language-plain\">function foo(a:number, b:number){\n    let x1:number = a + b;\n    let y:number = a + b;\n    let x2 = a - b;\n    let z:number = x2 + y + 1;\n}\n</code></pre><p>其中，变量z的定义引用的是x2，跟x1没有关系。所以说，在直线式运行的代码中，我们能很容易地对同一个变量的多个分身进行区分。我们总是采用最后一个分身的值。</p><p>不过，当存在控制流的分支的时候，要确定采用哪个分身的值，就没这么简单了，这也是<strong>Phi运算</strong>要发挥作用的时候。</p><p>现在我们就来讨论一下如何把if语句转化成IR。我们还是用这节课一开头的例子，改成SSA格式以后大约相当于下面的伪代码：</p><pre><code>function foo(a:number, b:number):number{\n  let x1:number;\n  let x2:number;\n  if (a&gt;10){\n    x1 = a + b;\n  }\n  else{\n    x2 = a - b;\n  }\n  let x = phi(which-if-branch,x1,x2);  //根据if分支来确定使用x1还是x2。\n  return x;\n}\n</code></pre><p>这里，我用x1和x2代替了原来的x，在if语句之后，用了一个Phi运算来得到最后x的值。</p><p>if语句的控制流部分和条件部分，我们可以根据这节课一开头我们的分析，生成相应的节点就好了。这里涉及的控制节点包括IfNode、BeginNode、EndNode和MergeNode。在IfNode和MergeNode这里，要跟数据流建立连接。</p><p>这里的具体实现，你可以参考<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/37/ir.ts\">ir.ts</a>中的源代码。另外，你还可以运行node play example_ir.ts --dumpIR命令，这会把ir输出成.dot文件。.dot文件可以用graphviz软件打开查看，你能看到编译生成的ir图。这里其实还有更简单的办法，就是直接在visual studio code中打开，并用预览模式查看图形。</p><p>这样，我们就把if语句分析完了。下一节，我会继续带你分析一个更复杂一点的例子，就是for循环语句，带你更加深入的掌握生成IR的思路，从而也能够更加洞察这种IR的内在逻辑。</p><h2>课程小结</h2><p>今天课程的新内容也不少。我梳理一下其中的要点，希望你能记住：</p><p>首先，在基于图的IR中，控制流和数据流是相对独立的，耦合度较低。数据流节点往往是浮动的，并不像源代码里那样被限制在某个基本块中。这个特征有利于代码在不同的基本块中的迁移，实现一些优化效果。</p><p>第二，IR的设计中，数据节点要保存输入信息，形成自己的定义。同时，数据节点也会被自动维护该节点使用信息，也就是自己构成了哪些其他变量的定义，从而形成了双向的use-def链。而控制节点则要保存自己的后序节点信息，它的前序节点会被自动维护，这样也就构成了可以双向导航的链。在当前的设计方案中，每个控制节点最多只能有一个前序节点。</p><p>第三，IR可以划分为HIR、MIR和LIR，它们的抽象层次越来越低，从贴近高级语言，逐步Lower到贴近CPU架构。抽象层次体现在使用的节点的类型和数据类型等方面。基于图的IR的有一个优点，就是它能够用同一个数据结构，承载不同抽象层次的IR，只需要我们把节点逐步替换就行。</p><p>最后，在把AST翻译成IR的过程中，你要体会出AST和基于图的IR的不同之处。包括本地变量不会作为端点出现，必然是被其他节点定义出来的。再比如，一个节点可能对应AST中的两个变量。</p><h2>思考题</h2><p>我们今天讲到了HIR、MIR和LIR的区别。那么，我这里有三个使用IR的场景，你能帮我判断一下它应该属于哪类IR吗？</p><ul>\n<li>场景1：访问对象mammal的属性weight；</li>\n<li>场景2：根据对象引用，加上一个偏移量，然后获取该地址的数值；</li>\n<li>场景3：根据对象在x86-64架构下的地址，加上一个64位的偏移量，获取这个地址下的双精度浮点数值。</li>\n</ul><p>欢迎你把这节课分享给更多感兴趣的朋友。我是宫文学，我们下节课见。</p><h2>资源链接</h2><p><a href=\"https://gitee.com/richard-gong/craft-a-language/tree/master/37\">今天的示例代码目录在这里！</a></p>","neighbors":{"left":{"article_title":"36｜节点之海：怎么生成基于图的IR？","id":436924},"right":{"article_title":"38｜中端优化第1关：实现多种本地优化","id":440792}}},{"article_id":440792,"article_title":"38｜中端优化第1关：实现多种本地优化","article_content":"<p>你好，我是宫文学。</p><p>上一节课，我们设计了IR的数据结构，并且分析了如何从AST生成IR。并且，这些IR还可以生成.dot文件，以直观的图形化的方式显示出来。</p><p>不过，我们上一节课只分析了if语句，这还远远不够。这节课，我会先带你分析for循环语句，加深对你控制流和数据流的理解。接着，我们就会开始享受这个IR带来的红利，用它来完成一些基本的本地优化工作，包括公共子表达式删除、拷贝传播和死代码删除，让你初步体会基于IR做优化的感觉。</p><p>那么，我们先接着上一节课，继续把for循环从AST转换成IR。</p><h2>把For循环转换成IR</h2><p>同样地，我们还是借助一个例子来做分析。这个例子是一个实现累加功能的函数，bar函数接受一个参数a，然后返回从1到a的累加值。</p><pre><code class=\"language-plain\">function bar(a:number):number{\n    let sum:number = 0;\n    for(let i = 1; i &lt;= a; i++){\n        sum = sum + i;\n    }\n    return sum;\n}\n</code></pre><p>这里，我先直接画出最后生成的IR图的样子：</p><p><img src=\"https://static001.geekbang.org/resource/image/13/81/137c1353cd0bac2638f94103c2217b81.jpg?wh=1080x1387\" alt=\"图片\"></p><p>你一看这个图，肯定会觉得有点眼花缭乱，摸不清头绪。不过没关系，这里面是有着清晰的逻辑的。</p><p><strong>第一步，我们先来看控制流的部分。</strong></p><p><img src=\"https://static001.geekbang.org/resource/image/f7/5e/f7278yye0c0d34914631cc0d6287645e.jpg?wh=1080x1387\" alt=\"图片\"></p><p>在程序开头的时候，依然还是一个Start节点。</p><!-- [[[read_end]]] --><p>而下面的LoopBegin节点，则代表了整个for循环语句的开始。开始后，它会根据for循环的条件，确定是否进入循环体。这里，我们引入了一个If节点，来代表循环条件。If节点要依据一个if条件，所以这里有一条黑线指向一个条件表达式节点。</p><p>当循环条件为true的时候，程序就进入循环体。循环体以Begin开头，以LoopEnd结尾。而当循环条件为false的时候，程序则要通过LoopExit来退出循环。最后再通过Return语句从函数中返回。</p><p>并且，LoopEnd和LoopExit各自都有一条输入边，连接到LoopBegin。这样，循环的开始和结束就能正确地配对，不至于搞混。</p><p>不过，你可能注意到了一个现象，Start节点的后序节点并不马上是循环的开始LoopBegin。为什么呢？因为其实有两条控制流能够到达LoopBegin：一条是从程序开始的上方进去，另一条是在每次循环结束以后，又重新开始循环。所以LoopBegin相当于我们上一节见过的Merge节点，两条控制流在这里汇聚。而我们在控制流中，如果用一条蓝线往下连接其他节点，只适用于单一控制流和流程分叉的情况，不包括流程汇聚的情况。我们上节课也说过，每个ControlNode最多只有一个前序节点。</p><p>那控制流的部分就说清楚了。<strong>第二步，我们就来看一下数据流。</strong></p><p>在数据流中，我们需要计算i和sum这两个变量。我们先看i：</p><pre><code class=\"language-plain\">function bar(a:number):number{\n    let sum1:number = 0;\n    for(let i1 = 1; i &lt;= a; i2 = i + 1){\n        sum2 = sum + i;   \n    }\n    return sum;\n}\n</code></pre><p>这里，变量i被静态赋值了两次。一开始被赋值为1，后来又通过i++来递增。为了符合SSA格式，我们要把它拆分成i1和i2两个变量，然后再用Phi节点把它们聚合起来，用于循环条件的判断。</p><p>我们把与i有关的数据流加入到图中，就是下面这样：</p><p><img src=\"https://static001.geekbang.org/resource/image/ae/3f/aea5cc2403282bdfeaff3c4b82628f3f.jpg?wh=1080x1387\" alt=\"图片\"></p><p>我再解释一下这张图。i1=1这个表达式，在刚进入循环时被触发，一次循环结束后，会触发i2 = i + 1。所以，在i&lt;=a这个条件中的i，在刚进入循环的时候，会选择i1；而在循环体中循环过一次以后，会选择i2。因此，我们图中这个phi节点有一条输入边指向LoopBegin，用于判断控制流到底是从上面那条边进入的，还是从LoopEnd返回的。</p><p>对于i2 = i + 1中的i，也是一样。它在一开始等于i1，循环过一次以后，就等于i2了。</p><p>我们可以用同样的方式加入与sum变量有关的数据流：</p><p><img src=\"https://static001.geekbang.org/resource/image/b4/31/b4abf8a448yy61621533b9f7e3cf2231.jpg?wh=1080x1387\" alt=\"图片\"></p><p>这张图中，sum1在循环体外被赋值为0，后来在循环体内，则是执行sum2 = sum + i。这里的sum，也是刚进入循环体的时候取sum1，循环过一次以后就取sum2，所以这里也需要一个Phi节点。</p><p>到这里，借助Phi节点，sum的值也已经算出来了。那么在最后的return语句中，是不是就可以直接把这个值返回了呢？</p><p>不可以。为什么呢？因为return语句是在for循环语句之后的，而我们刚才计算的sum值，是循环体内的sum值。我们在程序里，必须要保证是在退出循环以后再获取的这个值，不能违背这个控制流带来的约束。所以，我们添加了一个ValueProxy节点，以LoopExit作为输入，确保这个值的计算是在循环之外。但它实际的值，就是刚才由Phi节点计算出的sum的值。</p><p><img src=\"https://static001.geekbang.org/resource/image/fc/b2/fc4d40b7135a1bd178e5425e0f3f77b2.jpg?wh=1080x1387\" alt=\"图片\"></p><p>到此为止，整个for循环的IR就生成完毕了。一开始，你感觉会有点复杂，但如果你逐渐习惯了控制流和数据流的思维方式，分析起来就会越来越快了。</p><p>不过，回报和付出总是相匹配的。我们花了这么大代价来生成这个IR，会让某些优化工作变得异常简单，接下来我们就来体会一下吧！</p><h2>公共子表达式删除</h2><p>首先，我们看看怎么利用这个IR来删除公共子表达式。</p><p>我们来看下面这个示例程序。这个程序中有两个变量x和y，它们的定义都是a + b，所以它们有公共的子表达式。并且，变量z的定义中也有a+b这个公共的子表达式。</p><pre><code class=\"language-plain\">//删除公共子表达式\nfunction commonSubExp(a:number, b:number):number{\n    let x = a + b;\n    let y = a + b;\n    let z = a + b + 10;\n    let m = x + y + z\n    return m;\n}\n</code></pre><p>如果用我们的IR来删除这个示例程序中的公共子表达式，我们甚至都不需要等到优化阶段，而是在生成IR的时候，顺带手就可以做了。</p><p>你可以运行一下node play example_opt1.ts --dumpIR命令，生成下面的图。我手工在节点旁边标注了一下变量名称。你能看到，图中只有一张子图代表“a+b”这个公共子表达式，而且它被多个变量的定义引用了。</p><p><img src=\"https://static001.geekbang.org/resource/image/77/d4/775d8a811ed496944d2f0e83972c12d4.jpg?wh=1080x1387\" alt=\"\"></p><p>那具体这个公共子表达式是怎么被共享的呢？首先，为了保存我们的IR图，我们设计了一个graph类，里面保存了所有节点的列表。</p><pre><code class=\"language-plain\">//IR图\nexport class Graph{\n    nodes:IRNode[] =[];\n}\n</code></pre><p>然后，在遍历AST生成IR的时候，我们会先生成针对某个AST节点的DataNode，然后再加入到Graph中。这个节点实际上就代表了一个子图。\b我们以加法运算节点为例，这个子图包含了一个BinaryOpNode，还有left和right这两个input。</p><p>但是，这个子图可能在Graph中已经存在了。比如，在上面的示例程序中，当处理变量x的定义的时候，程序就为“a+b”这个表达式生成了一个BinaryOpNode，它的左右两个input分别是参数a和b，然后我们把这个节点加入到了Graph中。而当处理变量y的定义的时候，程序也会生成一个BinaryOpNode，它的左右两个input也是参数a和b。</p><p>这个时候，我们就没有必要把第二个BinaryOpNode，或者说子图，加入到Graph中了，我们直接用之前那个子图就行了。所以，我们要添加一个功能，用来比较两个DataNode节点是不是相同的。如果我们准备加入的节点在Graph中已经存在，那就返回原来的节点。这部分具体实现，你可以参考<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/38/ir.ts\">ir.ts</a>中的Graph类中的<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/38/ir.ts#L25\">addDataNode()</a>方法。另外，为了比较两个节点是否相同，我还为每个DataNode都实现了一个equals()方法。</p><p>接下来，你可以继续看看变量z的定义。在变量z定义中也存在“a+b”这个子表达式，它直接引用了原来的DataNode节点，然后再跟常量10相加。</p><p>最后，在变量m的定义中，我们先使用了一个临时变量来计算“x+y”。你在图中能看到，这个临时变量的两个input都指向了代表“a+b”的DataNode。这就说明变量x和y引用的都是同一个DataNode。</p><p>这部分的具体实现是这样的，在<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/38/ir.ts#L531\">IRGenerator</a>程序的<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/38/ir.ts#L748\">visitVariable()</a>方法中，根据变量的符号，我们可以从Graph中把对应的DataNode都查出来。这是因为，IRGenerator在处理好AST以后，会生成一个IRModule，而IRModule中就保存每个变量跟DataNode的对应关系。</p><p>好了，现在你已经了解了如何基于我们的IR来删除公共子表达式了。接下来，我们再看看它在处理其他优化任务时是否也同样方便。我们看一下拷贝传播。</p><h2>拷贝传播</h2><p>实际上，基于我们的IR来处理拷贝传播，也是手到擒来，几乎不需要做什么额外的工作。</p><p>我们看一段示例代码。在这段代码中，变量x的定义是a+b。然后，我们又用了x来定义y，那你推理一下就知道，现在y也应该等于a+b。</p><pre><code class=\"language-plain\">// 拷贝传播\nfunction copyPropagation(a:number, b:number):number{\n    let x = a + b;\n    let y = x;\n    let z = y - x;\n    return z;\n}\n</code></pre><p>你仍然可以用我们现在的编译器加上–dumpIR选项来生成.dot图，我把它放在下面了。</p><p><img src=\"https://static001.geekbang.org/resource/image/38/6f/38d8855ce975f9f7165a9f8a4018106f.jpg?wh=1080x1387\" alt=\"\"></p><p>你会看到，变量x和y都引用了相同的DataNode。这里具体的实现你可以看一下<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/38/ir.ts#L531\">IRGenerator</a>中的<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/38/ir.ts#L800\">visitVariableDecl()</a>方法。在声明变量y的时候，我们会获取变量初始化表达式对应的DataNode，再把它跟该变量绑定。而变量y的初始化表达式就是x，x对应的DataNode就是图中的Plus节点，所以这个节点也跟变量y关联到了一起。拷贝传播就是这么在处理变量声明的过程中自然而然地发生了。</p><p>最后，你在图中再看一下变量z的定义。你会看到，减法运算的左右两个input都是指向了同一个DataNode。所以，接下来我们就可以自然而然地做一个优化了，直接计算出z=0就可以了。在做优化的时候，我们经常会遇到这种情况，就是一个优化的处理结果，为其他优化创造了机会。就像当前的例子，拷贝传播的结果就是给减法运算的优化创造了机会。</p><p>不过，在实际的优化算法中，我们通常会让IR经历多个Pass的处理，每个Pass处理一种优化场景。并且，经常同一种优化算法会被使用多次，原因就是在做完优化A以后，可能又制造出了优化B的机会。</p><p>最后，我们再看看死代码删除的情况，看看我们的IR又会带来什么惊喜。</p><h2>死代码删除</h2><p>我们还是看一个存在死代码的例子程序。这个例子中有x、y、z和dc共4个变量。你用肉眼看一下就能发现，定义dc变量的这行代码是多余的。因为在定义出dc以后，再也没有代码用到它了。</p><pre><code class=\"language-plain\">//删除死代码\nfunction deadCode(a:number, b:number):number{\n    let x = a + b;\n    let y = a - b;\n    let dc = a - 2;\n    let z = x + y + 10;\n    return z;\n}\n</code></pre><p>我之前给你介绍过变量活跃性分析的数据流方法。我们可以自底向上地遍历这个代码块，并不断更新一个“活跃变量”的集合。等分析到声明dc这一行的时候，我们会发现当前活跃变量集合里是没有dc的，这样就知道这行代码是死代码了。</p><p>如果使用我们现在的IR，那应该如何检测死代码呢？我们还是先看编译器生成的IR图，看看死代码在图中有什么特点。</p><p><img src=\"https://static001.geekbang.org/resource/image/72/2d/72186cf24872016e89d78295888c372d.jpg?wh=1080x1387\" alt=\"\"></p><p>我在图中标出了作为死代码的dc变量。你从图中可以直观地看到，这个节点有一个显著的特点，就是没有其他节点引用它，因此它不是任何其他节点的input。</p><p>你应该记得，我们在DataNode中设置了一个uses属性，指向所有使用该节点的其他节点，是一个反向的链接。那这个时候，其实dc变量对应的DataNode的uses列表是空的。所以，只要是uses为空的节点，我们就可以把它从图中去掉。而我们把Minus_6去掉以后，常量2也没有任何节点使用了，所以我们也可以把它去掉。</p><p>你看，现在我们要去除死代码的话，简单到<strong>只是查询DataNode的uses属性是否为空集合</strong>就行了。是不是太方便了？具体实现你可以看看ir.ts中的<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/38/ir.ts#L800\">DeadCodeElimination</a>类。</p><p>不过，需要注意的是，上面只是产生死代码的其中一个场景，还有另一个场景是出现在return、break等语句之后的代码，也都是死代码。这种类型死代码，也是在生成IR的时候就可以去掉的。也就是，在遇到return语句以后，我们不再为同一个块中的其他语句生成IR就行了。</p><h2>课程小结</h2><p>今天的内容就是这些。今天这节课，我首先接着上一节分析了如何为for循环语句生成IR，让你熟悉另一种常用的IR结构，接着分析了如何基于该IR实现几种常见的本地优化算法。我希望你记住以下的重点：</p><p>首先，在For循环中，LoopBegin和Merge节点一样，都是实现了多个控制流的汇聚。LoopEnd代表一次循环的结束，而LoopExit代表退出循环，它们都要跟LoopBegin配对。对于循环变量，我们需要用Phi节点来获取其不同控制流分支上的取值。</p><p>第二，在生成IR的过程中，我们顺手就可以实现对公共子表达式的删除，这需要实现DataNode的比较。并且要求在DataNode加入Graph的过程中，不能存在相同的DataNode，或者子图。</p><p>第三，在生成IR的过程中，我们通过处理变量声明，也可以自然而然地实现拷贝的传播。</p><p>第四，如果一个IR的uses属性是一个空集合，那我们就可以判断出它是一个没有用的变量，可以把它删除掉，这就实现了死代码删除的功能。</p><p>最后，一种优化工作的结果会为其他的优化创造机会。所以，编译器在优化一个IR的时候，会前后多次调用同一个优化算法。</p><h2>思考题</h2><p>今天我们讨论的这些优化的例子，都是本地优化的情况，也就是在同一个基本块中代码做优化，没有考虑控制流跳转的情况。那你能不能分析一下，当存在if语句和循环语句的情况下，能不能也像这节课这样实现公共子表达式的删除、常量传播和死代码删除？</p><p>欢迎你把这节课分享给更多感兴趣的朋友。我是宫文学，我们下节课见。</p><h2>资源链接</h2><p><a href=\"https://gitee.com/richard-gong/craft-a-language/tree/master/38\">这节课示例代码的目录在这里！</a></p>","neighbors":{"left":{"article_title":"37 | 从AST到IR：体会数据流和控制流思维","id":439771},"right":{"article_title":"39｜中端优化第2关：全局优化要怎么搞？","id":442804}}},{"article_id":442804,"article_title":"39｜中端优化第2关：全局优化要怎么搞？","article_content":"<p>你好，我是宫文学。</p><p>上一节课，我们用了一些例子，讨论了如何用基于图的IR来实现一些优化，包括公共子表达式删除、拷贝传播和死代码删除。但这些例子，都属于本地优化的场景。也就是说，在未来生成的汇编代码中，这些代码其实都位于同一个基本块。</p><p>不过，复杂一点的程序，都会有if语句和循环语句这种流程控制语句，所以程序就会存在多个基本块。那么就会存在跨越多个基本块的优化工作，也就是全局优化。</p><p>所以，今天这节课，我们就来讨论一下如何基于当前的IR做全局优化。同时，为了达到优化效果，我们这一节课还需要把浮动的数据节点划分到具体的基本块中去，实现指令的调度。</p><p>但在讨论全局优化的场景之前，我还要先给你补充一块知识点，就是变量的版本和控制流的关系，让你能更好地理解全局优化。</p><h2>变量的版本和控制流的关系</h2><p>通过前几节课我们已经知道，我们的IR生成算法能够对一个变量产生多个版本的定义，从而让IR符合SSA格式。可是，我们是如何来表示不同版本的定义的，又是如何确定程序中到底引用的是变量的哪个版本呢？</p><p>在IR的模型中，我引入了一个VarProxy类，来引用变量的一个版本，就像d0、d1和d2，也有的文献把变量的一个定义叫做变量的一个定值。VarProxy里面保存了一个VarSymbol，还包括了一个下标：</p><!-- [[[read_end]]] --><pre><code class=\"language-plain\">//代表了变量的一次定义。每次变量重新定义，都会生成一个新的Proxy，以便让IR符合SSA格式\nclass VarProxy{\n    varSym:VarSymbol;\n    index:number;  //变量的第几个定义\n    constructor(varSym:VarSymbol, index:number){\n        this.varSym = varSym;\n        this.index = index;\n    }\n    get label():string{\n        return this.varSym.name+this.index;\n    }\n}\n</code></pre><p>每次遇到变量声明、变量赋值，以及像i++这样能够导致变量值改变的语句时，我们就会产生一个新的变量定义，也就是一个VarProxy。这个VarProxy会被绑定到一个具体的DataNode上。所以，我在IR中显示DataNode节点的时候，也会把绑定在这个节点上的变量定义一并显示出来。</p><p>那当我们在程序中遇到一个变量的时候，如何确定它采用的是哪个版本呢？</p><p>这就需要我们在生成IR的过程中，把VarProxy与当前的控制流绑定。每个控制流针对每个变量，只有一个确定的版本。</p><pre><code class=\"language-plain\">//把每个变量绑定到控制流，从而知道当前代码用到的是变量的哪个定义\n//在同一个控制流里，如果有多个定义，则后面的定义会替换掉前面的。\nvarProxyMap:Map&lt;AbstractBeginNode,Map&lt;VarSymbol,VarProxy&gt;&gt; = new Map();\n</code></pre><p>在这里，我们还用了一个AbstractBeginNode节点来标识一个控制流。因为每个控制流都是存在一个起点的。而每个控制流节点，透过它的predecessor链，总能找到自己这条控制流的开始节点。</p><pre><code class=\"language-plain\">//获取这条控制流的开头节点\nget beginNode():AbstractBeginNode{\n    if (this instanceof AbstractBeginNode){\n        return this;\n    }\n    else{\n        return (this.predecessor as UniSuccessorNode).beginNode;  \n    }\n}\n</code></pre><p>但是，如果变量不是在当前控制流中定义的，而是在前面的控制流中定义的，那我们可以递归地往前查找。这里具体的实现，你可以参考一下<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/39-40/ir.ts#L701\">getVarProxyFromFlow()</a>。</p><p>最后，如果控制流的起点是一个merge节点，那这个变量就可能是在分支语句中定义的，那我们就要生成一个Phi节点，并把这个Phi节点也看成是变量定义的一个版本，方便我们在后续程序中引用。</p><p>好了，相信现在你已经可以更清晰地理解变量版本与控制流之间的关系了。现在我们基于这些前置知识，就可以开始讨论全局优化的场景了。</p><h2>全局的死代码删除</h2><p>上一节课，我们实现了基本块中的死代码删除功能。那个时候，我们基本上只需要考虑数据流的特点，把uses属性为空的节点删除掉就行了。因为这些节点对应的变量定义没有被引用，所以它们就是死代码。</p><p>那么，现在考虑带有程序分支的情况，会怎么样呢？</p><p>我们还是通过一个例子来分析一下。你可以先停下来两分钟，用肉眼看一下，看看哪些代码可以删除：</p><pre><code class=\"language-plain\">function deadCode2(b:number,c:number){\n    let a:number = b+c;\n    let d:number;\n    let y:number;\n    if (b &gt; 0){\n        b = a+b;\n        d = a+b;\n    }\n    else{\n        d = a+c;\n        y = b+d; \n    }\n    let x = a+b;\n    y = c + d;\n    return x;\n}\n</code></pre><p>我也把答案写出来了，看看跟你想的是否一样。在整个代码优化完毕以后，其实只剩下很少的代码了。变量c、d和y的定义都被优化掉了。</p><pre><code class=\"language-plain\">function deadCode2(b:number,c:number){\n    let a:number = b+c;\n    if (b &gt; 0){\n        b = a+b;\n    }\n    let x = a+b;\n    return x;\n}\n</code></pre><p>这个例子其实是我在《编译原理之美》第28节中举的一个例子。在那里，我是基于CFG做变量活跃性分析，再基于分析结果去做优化。你有兴趣的话可以去看一下。那个算法的核心，是跨越多个基本块做变量活跃性分析。一个基本块的输出，会顺着控制流，成为另一个基本块的输入。在这门课的第20节，我也介绍过这种变量活跃性分析的思路，所以这里我就不再去重复了。</p><p>那在这节课中，我们感兴趣的是，<strong>基于现在的IR，我们能否更便捷地实现变量活跃性分析，实现死代码的删除呢？</strong></p><p>我们先来运行一下“node play example_opt2.ts --dumpIR”命令，看一下deadCode2函数对应的IR是什么样子的。</p><p><img src=\"https://static001.geekbang.org/resource/image/c2/88/c2d61a707d0cbcbd42c84a25a53f7988.png?wh=824x1080\" alt=\"图片\"></p><p>你会发现，这个图里加入了If节点，并产生了流程分支，然后又通过Merge节点合并到了一起，不同流程分支的变量产生了多个定义。相应的，IR中也有Phi节点，用来选择不同流程分支的变量定义。</p><p>以变量d为例，实际上现在我们的程序保存了d的三个定义，在if块中定义了d0，在else块中定义了d1，“y = c + d”这一句中还有一个。不过在“y = c + d”这一句中的变量d，要通过phi节点来获得。类似的，变量b也有三个定义，而变量y也有两个不同的定义。</p><p>同时，你还会发现，图中有几个节点的uses属性为空集合。比如y0和y1，所以我们又可以把它们从图中去掉。而在去掉了y0和y1以后，d0、d1和d2也不再有用，所以也可以去掉。做过这些优化以后，IR图就变成了下面的样子：</p><p><img src=\"https://static001.geekbang.org/resource/image/f2/c7/f2431b6d6b96eddb777e59671af3abc7.png?wh=696x1080\" alt=\"图片\"></p><p>而最后这个版本，其实就可以对应上优化后的那个源代码了。</p><p>所以，我们在全局做死代码的删除，其实跟前一节课的本地优化没有区别，都是<strong>根据uses属性来做判断</strong>。<strong>因为这个时候，控制流并没有影响我们的优化算法。</strong></p><p>不过，并不是在所有情况下，控制流都不会影响到优化。我们再来分析一种优化技术，就是部分冗余消除。在这个场景下，控制流的影响就会体现出来。</p><h2>部分冗余消除（PRE）</h2><p>我们之前讨论过公共子表达式删除（CSE），说的是如果两个表达式有公共的子表达式，那么这个子表达式可以只计算一次。</p><p>在全局优化中有一种类似的情况，两个表达式中也存在公共子表达式，但是它们位于不同的流程分支，这种情况下我们可以使用<strong>部分冗余消除算法</strong>。</p><p>部分冗余消除（Partial Redundancy Elimination，PRE），是公共子表达式消除的一种特殊情况。我这里用了一个来自<a href=\"https://time.geekbang.org/column/article/248770#:~:text=%E6%AF%94%E5%A6%82%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%9D%A5%E8%87%AA-,Wikipedia,-%E7%9A%84%E4%BE%8B%E5%AD%90%E4%B8%AD\">wikipedia</a>的例子，这个程序里一个分支有“x+4”这个公共子表达式，而另一个分支则没有。</p><p>你用肉眼就可以看出，这个例子优化得不够好的地方，比如，如果some_condition为true，那么x+4这个子表达式就要计算两次：</p><pre><code class=\"language-plain\">if (some_condition) {\n&nbsp; &nbsp;// some code that does not alter x\n&nbsp; &nbsp;y = x + 4;\n&nbsp;}\n&nbsp;else {\n&nbsp; &nbsp;// other code that does not alter x\n&nbsp;}\n&nbsp;z = x + 4;\n</code></pre><p>这些代码经过优化以后，可以改成下面这样。当some_condition为true的时候，x+4也只需要计算一次：</p><pre><code class=\"language-plain\">if (some_condition) {\n&nbsp; &nbsp;// some code that does not alter x\n&nbsp; &nbsp;t = x + 4;\n&nbsp; &nbsp;y = t;\n&nbsp;}\n&nbsp;else {\n&nbsp; &nbsp;// other code that does not alter x\n&nbsp; &nbsp;t = x + 4;\n&nbsp;}\n&nbsp;z = t;\n</code></pre><p>这个时候，两个条件分支里都有t = x+4这个语句，那我们还可以把它提到外面去，让生成的代码更小一点：</p><pre><code class=\"language-plain\">t = x + 4;\nif (some_condition) {\n&nbsp; &nbsp;// some code that does not alter x\n&nbsp; &nbsp;y = t;\n&nbsp;}\n&nbsp;else {\n&nbsp; &nbsp;// other code that does not alter x\n&nbsp;}\n&nbsp;z = t;\n</code></pre><p>如果用我们的IR对这个例子进行优化，也很容易实现。我们先把这个wikipedia的例子用TypeScript改写一下：</p><pre><code class=\"language-plain\">function PRE(x:number):number{\n    let y:number = 0;\n    if (x&gt;0){\n        y = x+4;\n    }\n    let z = x+4;\n    return y+z;\n}\n</code></pre><p>然后再生成它的IR看一下：</p><p><img src=\"https://static001.geekbang.org/resource/image/25/88/250e84d0e267f3fc1b8b2b78974d2d88.png?wh=740x1080\" alt=\"图片\"></p><p>从这个IR中你能看到，x+4对应着编号为8的节点，y1和z的值都是x+4，最后的返回值是13号节点，也就是y2+z。而y2是一个phi节点，根据流程分支，它的值可能是常量0，也可能是x+4。</p><p>我们再进一步，如果你研究13号节点的def链，你会发现它肯定会依赖到8号节点，也就是x+4。无论程序是否经过if语句的那条控制流，都会是这样。所以，当我们把节点划分到基本块的时候，8号节点可以划分到if语句之前的基本块，这样就实现了对x+4只计算一次的目的。相当于下面的代码：</p><pre><code class=\"language-plain\">function PRE(x:number):number{\n    let y:number = 0;\n    let t = x+4;\n    if (x&gt;0){\n        y = t;\n    }\n    let z = t;\n    return y+z;\n}\n</code></pre><p>从这个例子你能看出来，其实基于我们的IR，数据流的计算总能达到最节省计算量的效果。<strong>那么在全局优化中，重点其实就变成了如何把不同的数据节点划分到不同的基本块中</strong>。就像刚才，我们可以把x+4计算放在if语句中，也可以放在外面。在某些情况下，这种不同的划分会影响到程序的性能。</p><p>所以，接下来我们就讨论一下如何划分基本块，并进行指令的调度。</p><h2>划分基本块和指令调度（Schedule）</h2><p>我们当前的IR采用的是一个基于图的数据结构。可是我们在生成汇编代码的时候，还是要把整个程序划分成基本块，并在基本块之间实现跳转。这个时候，我们就要采用一个调度算法，确定把哪条代码放到哪个基本块。</p><p>划分基本块其实比较简单，我们基于控制流做运算就行了。每产生一个控制流分支的时候，我们就划分一个新的基本块。比如，我们刚才的PRE示例程序就可以划分成四个基本块，if语句前后各有一个，而if语句的两个分支也分别是一个基本块。</p><p><img src=\"https://static001.geekbang.org/resource/image/30/98/302c0911443487a21730bf9ec935e698.png?wh=1220x888\" alt=\"\"></p><p>接下来，我们就要把各个数据流节点也纳入到不同的基本块中去。由于数据节点是浮动的，它其实有比较大的自由度，可以归到不同的基本块中去。<strong>那我们这里的算法，就是如果某个表达式的计算会出现在多个流程分支里，我们就尽量把它提到外面去</strong>。比如对x+4的计算，我们就把它放到第1个基本块中了。</p><p>那看着前面这张图，你可能会产生疑问：难道if条件的两个流程分支都是空的基本块吗？按照源代码，在x&gt;0的时候，应该有一个y=t的赋值呀？</p><p>没错，我们现在把控制流的Merge节点和数据流的Phi节点都归到了第4个基本块。但其实phi节点会在Merge节点之前的两个基本块中生成代码的。只不过是因为，我们现在在HIR的阶段，只能画成这样，没法把phi节点划分到前面两个不同的基本块去。在生成LIR或汇编代码的时候，phi节点就会被转化成位于基本块中的代码。所以，这个阶段，我们只需要记住phi节点生成代码的特点就行了。</p><p>看到这里，我相信你已经基本了解如何划分基本块和做代码调度了。其实，在这里讨论这些，我是为了引出下一个全局优化，也就是循环无关代码外提。</p><h2>循环无关代码外提（LICM）</h2><p>我们在第36节课曾经讨论锅一个循环无关代码外提（Loop-Invariant Code Motion，LICM）的例子。在这个例子中，变量c的定义是与循环无关的，却被放到了循环的内部，导致每次循环都要计算一遍a*a：</p><pre><code class=\"language-plain\">function LICM(a:number):number{\n  let b = 0;\n  for (let i = 0; i&lt; a; i++){\n      let c = a*a;  //变量c的值与循环无关，导致重复计算！\n      b = i + c;\n  }\n  return b;\n}\n</code></pre><p>所以，理想的优化结果，就是这行代码提到循环的外面。这样，a*a的值只需要计算一次就行了：</p><pre><code class=\"language-plain\">function LICM(a:number):number{\n  let b = 0;\n  let c = a*a;  //外提\n  for (let i = 0; i&lt; a; i++){\n      b = i + c;\n  }\n  return b;\n}\n</code></pre><p>当然，这么做也有一个风险，就是如果程序并不进入循环，那么这次计算就白做了，反倒多消耗了计算量。不过，这个情况总归是小概率事件。除非我们有运行时的统计数据作依托，不然我们很难做出更准确地选择。</p><p>在静态编译的情况下，我们只能假设把它放到循环外面，大概率是比放在循环里面更好一些。从这个场景中，你也能再次体会到“全生命周期优化”的意义，<strong>AOT编译并不总是能得到最好的效果</strong>。</p><p>那要如何实现这个优化呢？我们还是把这个程序生成IR来看一下：</p><p><img src=\"https://static001.geekbang.org/resource/image/b2/57/b2fd95c0a693a693c80a48d1f3bafd57.jpg?wh=1692x1504\" alt=\"\"></p><p>从这个IR图中，我们能看出a*a计算确实是与循环无关的，是可以在循环内部和外部浮动的。相比之下，变量i和b1的计算，则受限于控制流的结构，只能出现在LoopBegin之后。</p><p>所以，基于我们的指令调度算法，我们就把a*a这个节点归入第1个基本块，这样就实现了循环无关代码的外提。</p><h2>课程小结</h2><p>好了，这就是今天这节课全部的内容了。这节课里，我们讨论了在全局做优化会涉及的的一些技术点，包括：</p><p>首先，在SSA格式下，变量可以产生多个定义。在生成IR的过程中，我们要把每个变量定义跟产生它的控制流相关联，这样我们在数据流中引用变量的时候，就能找到正确的定义了。</p><p>第二，在全局死代码删除的时候，我们只需要考虑数据节点的属性就行，也就是看uses属性是否为空就好了。这跟在一个基本块中做死代码删除没有区别。</p><p>第三，在全局做公共子表达式删除的时候，我们会遇到部分冗余消除的优化场景。基于我们当前的IR，可以保证公共子表达式只计算一次。</p><p>第四，在全局优化中，我们需要考虑把数据节点放到哪个基本块中，这叫做指令调度。在有些场景下，比如循环无关代码外提，把指令划分到不同的基本块会导致不同的性能。在AOT编译时，我们通常总是把循环无关的代码提到循环外面。</p><h2>思考题</h2><p>我们这两节课分析了不少优化算法，不知道你还有没有了解过其他优化算法？它们在我们的IR中是否也很容易实现呢？比如，我在《编译原理实战课》的第07讲，提到了很多优化算法。我建议你研究一下全局值编号（GVN）和代码提升（Code Hoisting）在我们的IR上如何实现。欢迎在留言区分享你的发现。</p><p>欢迎你把这节课分享给更多感兴趣的朋友。我是宫文学，我们下节课见。</p><h2>资源链接</h2><p>这节课的示例代码目录在<a href=\"https://gitee.com/richard-gong/craft-a-language/tree/master/39-40\">这里</a>，主要看<a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/39-40/ir.ts\">ir.ts</a>。</p>","neighbors":{"left":{"article_title":"38｜中端优化第1关：实现多种本地优化","id":440792},"right":{"article_title":"40｜中端优化第3关：一起来挑战过程间优化","id":444361}}},{"article_id":444361,"article_title":"40｜中端优化第3关：一起来挑战过程间优化","article_content":"<p>你好，我是宫文学。</p><p>在前面两节课，我们分析了本地优化和全局优化的场景。我们发现，由于基于图IR的优点，也就是<strong>控制流和数据流之间耦合度比较低</strong>的这个特点，我们很多优化算法的实现都变得更简单了。</p><p>那么，对于过程间优化的场景，我们这个基于图IR是否也会带来类似的便利呢？</p><p>过程间优化（Inter-procedural Optimization）指的是跨越多个函数（或者叫做过程），对程序进行多方面的分析，包括过程间的控制流分析和数据流分析，从而找出可以优化的机会。</p><p>今天这节课，我们就来分析两种常用的过程间优化技术，也就是内联优化和全局的逃逸分析，让你能了解过程间优化的思路，也能明白如何基于我们的IR来实现这些优化。之后，我还会给你补充另一个优化技术方面的知识点，也就是规范化。</p><h2>内联优化</h2><p>内联优化是最常见到的一个过程间优化场景，说的就是当一个函数调用一个子函数时，干脆把子函数的代码拷贝到调用者中，从而减少由于函数调用导致的开销。</p><p>特别是，如果调用者是在一个循环中调用子函数，那么由很多次循环累积而导致的性能开销是很大的。内联优化的优势在这时就会得到体现。</p><p>而在面向对象编程中，我们通常会写很多很简短的setter和getter方法，并且在程序里频繁调用。如果编译器能自动把这些短方法做内联优化，我们就可以放心大胆地写这些短方法，而不用担心由此导致的性能开销了。</p><!-- [[[read_end]]] --><p>现在我们就举一个非常简单的、可以做内联的例子看看。在这个示例中，inline函数是调用者，它调用了add函数。</p><pre><code class=\"language-plain\">//内联\nfunction inline(x:number):number{\n    return add(x, x+1);\n}\n\nfunction add(x:number, y:number):number{\n    return x + y;\n}\n</code></pre><p>显然，在编译inline函数的时候，我们没必要额外多产生一次对add函数的调用，而是把add函数内联进来就行了，形成下面这些优化后的代码：</p><pre><code class=\"language-plain\">//内联\nfunction inline(x:number):number{\n    return x + (x+1);\n}\n</code></pre><p><strong>那要如何基于我们的IR实现内联优化呢？</strong></p><p>首先，我们还是看看在没有优化以前，inline和add两个函数的IR：</p><p><img src=\"https://static001.geekbang.org/resource/image/f0/f8/f0d6d718057d7be83e80b7c8eeb73cf8.png?wh=790x820\" alt=\"图片\"></p><p>在inline函数的IR里，你能发现两个新的节点：一个是Invoke节点，代表函数调用的控制流；另一个是CallTarget节点，代表函数调用的数据流。</p><p>而内联优化就是要把这两个IR图合并，形成一个大的IR。如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/52/5d/526b5acb87f4a5c2b2bf36bc2e66115d.png?wh=312x820\" alt=\"图片\"></p><p>具体来说，要实现上面的合并，我们需要完成两个任务：</p><ul>\n<li>首先，把inline函数中的函数调用的节点替换成add函数中的加法节点；</li>\n<li>第二，将加法节点中的x和y两个形式参数，替换成inline函数里的两个实际参数。</li>\n</ul><p>总的来说，整个算法都是去<strong>做节点的替换和重新连接</strong>，思路还是很清晰的。</p><p>我们之前说过，编译器在做了一种优化以后，经常可以给其他优化制造机会。在这里，内联优化不仅仅减少了函数调用导致的开销，它还会导致一些其他优化。比如说，我们在Inline函数里调用add函数的时候，传入两个参数x和-x，如下面的示例代码：</p><pre><code class=\"language-plain\">//内联\nfunction inline2(x:number):number{\n    return add(x, -x);\n}\n\nfunction add(x:number, y:number):number{\n    return x + y;\n}\n</code></pre><p>那么内联之后，这里就相当于计算x+(-x)的值，那也能计算出一个常量0。至于如何把x+(-x)化简成0，我先留个悬念，你先自己思考一下，我们这节课后面会介绍到。</p><pre><code class=\"language-plain\">//内联\nfunction inline(x:number):number{\n    return x + (-x);  //常量0\n}\n</code></pre><p>再比如，我们在主函数里调用add的时候，传的参数是常量。那么内联以后，我们就可以进行常量传播和常量折叠的优化，在编译期就能计算出结果为5：</p><pre><code class=\"language-plain\">//内联\nfunction inline2(x:number):number{\n    return add(2, 3);\n}\n\nfunction add(x:number, y:number):number{\n    return x + y;\n}\n</code></pre><p>当然了，内联优化是最常见的一种过程间优化。除了内联优化之外，过程间的逃逸分析也值得拿出来单独说一下。</p><h2>逃逸分析</h2><p>对于像Java这样的面向对象语言来说，逃逸分析是经常被采用的技术。我在《编译原理实战课》的<a href=\"https://time.geekbang.org/column/article/257504\">第15节</a>，曾经专门讨论了Java JIT编译器中的逃逸分析技术。</p><p>简单来说，逃逸分析的目的，是<strong>分析一个对象的生命期有没有超过函数的生存期</strong>，从而进行一些优化。比如下面这段代码中，我们声明了一个Rectangle类，它有width和height的属性，并且有一个方法能够计算面积。然后在一个foo函数中，我们创建了一个Rectangle对象，并且为了调用它的area方法，计算出面积。</p><pre><code class=\"language-plain\">class Rectangle{\n  width:number;\n  height:number;\n  constructor(width:number, height:number){\n    this.width=width;\n    this.height = height;\n  }\n  area():number{\n    return this.width*this.height;\n  }\n}\n\nfunction foo(width:number, height:number){\n  let rect = new Rectangle(width, height);\n  return rect.area();\n}\n</code></pre><p>分析foo的代码，你会发现rect的生存期始终在foo函数之内。这个时候，我们说rect对象没有逃逸。当foo函数返回时，这个对象也就没有用了。因为这个特点，所以我们可以做三个方面的优化：</p><p><strong>第一个优化是栈上内存分配。</strong>通常，我们是在堆里为对象申请内存的，然后在某个时机用垃圾回收程序来回收。但rect对象的生存期小于foo函数的生存期，也就是说，在foo函数返回以后，也不会有其他的程序来访问这个对象，所以这个对象所需要的内存，直接在栈上申请就行了。这样，当函数退出的时候，rect对象的内存也就直接被回收，不需要通过GC回收了，内存管理的性能就更高了。</p><p><strong>第二个优化是标量替换。</strong>也就是把对象的属性拆散，变成width和height两个本地变量。这样，它们就可以被放到寄存器里，而不是非要通过内存来访问，从而提高了性能。</p><p><strong>第三个优化是锁消除或者同步消除。</strong>在编写并发程序的时候，我们需要用锁来做线程的同步，从而避免多个线程同时访问某个对象而引起数据的混乱。而且，因为rect对象没有逃逸出函数体，也就是说它注定只能被一个线程访问，所以我们对rect对象的访问也就不需要做线程间的同步，这也就消除了由于同步而引起的性能开销。</p><p>好，上面就是对逃逸分析的概要介绍。<strong>逃逸分析可以基于单个函数或方法，也可以跨域多个函数来分析，从而做出优化。</strong></p><p>比如，基于上面的例子，我又写了两个新的函数。其中函数biggerThan，能够接受两个Rectangle对象，并比较它们面积的大小。在bar函数里，我创建了两个Rectangle对象，并调用了biggerThan函数。</p><pre><code class=\"language-plain\">function bar(w1, h1, w2, h2):booelan{\n  let rect1 = new Rectangle(w1, h1);\n  let rect2 = new Rectangle(w2, h2);\n  return biggerThan(rect1, rect2);\n}\n\nfunction biggerThan(rect1:Rectangle, rect2:Rectangle):boolean{\n  return rect1.area()&gt;rect2.area;\n}\n</code></pre><p>你用肉眼就可以看出，虽然rect1和rect2从bar函数传递了出去，传给了biggerThan函数，但它们并没有继续从biggerThan函数往外逃逸。所以，如果我们把这两个函数看做一个整体，那么rect1和rect2对象仍然是没有逃逸的。</p><p>所以呢，你仍然可以运用这个分析结果，来实现一些优化，比如说实现栈上内存分配和同步消除的优化。</p><p><strong>那了解了逃逸分析的作用以后，我们如何基于当前的IR来实现逃逸分析呢？</strong></p><p>经典的逃逸分析采用一种叫做<strong>连接图</strong>（Connection Graph）的算法。简单地说，就是分析出程序中对象之间的引用关系。整个分析算法是建立在这样一种直觉认知上的：基于一个连接图，也就是对象之间的引用关系图，如果 A 引用了 B，而 A 逃逸了，那么也就意味着B逃逸了。也就是说，<strong>逃逸是有传染性的</strong>。</p><p>而基于当前的IR，我们可以很方便地得到上面说的的连接图，有利于我们分析对象逃逸的情况。当然，单个的对象是很容易分析的。不过，即使是多个对象之间存在关联，也能够在数据流中体现出来。我们可以看下这个例子：</p><pre><code class=\"language-plain\">let person = new Person();\nperson.name = \"Richard\";\n</code></pre><p>在这里，我们给person的name属性做了赋值。这样，person对象就跟一个string对象建立了关联。如果person对象逃逸到了函数或方法之外，那么该string对象也跟随着逃逸。反之，那么这两个对象都没有逃逸，那都可以在栈上申请内存。</p><p>表达上面两个对象之间关系的IR如下图。基于这个IR，我们就能得到对象之间的关联了：</p><p><img src=\"https://static001.geekbang.org/resource/image/63/da/63d9f1873a03274000f3d66925e734da.jpg?wh=428x282\" alt=\"\"></p><p>好了，到目前为止，我们已经分析了基于IR在本地、全局和过程间做优化的一些场景。在实际的编译器中，我们还会实现很多的场景，比如把循环拉直，调整内循环和外循环，把用不到的分支去掉等等。但这些优化的本质，都是基于控制流和数据流的分析对IR图进行修改。你把握住这个关键点就行了。</p><p>最后，我再讲一个Java的JIT编译器Graal中经常见到的一种优化方法，作为这三节课的结尾，这个优化方法就是规范化。</p><h2>规范化（Canonicalize）</h2><p>在《编译原理实践课》中，我曾经对Graal编译器做过剖析。如果你跟踪Graal的编译过程，你会发现它的编译过程中会涉及100多个pass，也就是用各种算法对一个IR图处理了一百多遍。其中很多pass都是我们已经讲过的，比如死代码删除、逃逸分析，等等。但还有一个使用频率很高的优化方法，叫做Canonicalizer，也就是规范化。</p><p>那什么是规范化呢？规范化就是<strong>针对各种计算节点所做的化简操作</strong>。比如，对于减法运算，如果减法两边的Node是同一个节点，那我们就可以计算出常量0来：</p><pre><code class=\"language-plain\">let y = x - x;  //规范化结果为0。\n</code></pre><p>而对于加法运算，如果两个其中一个节点是另一个节点取负值，那也可以化简，结果为0。</p><pre><code class=\"language-plain\">let y = x + (-x);  //规范化结果为0。\n</code></pre><p>其他类似的规范化操作还包括：</p><ul>\n<li>对于a+0、a-0、0+a，可以化简成a， 0-a化简为-a；</li>\n<li>对于(a - b) + b、b + (a - b)、(a+b)-b，可以化简为a，(a+b)-a化简为b，(a-b)-a化简为-b;</li>\n<li>对于(a + 1) + 2，可以化简为a+3；</li>\n<li>a + (-b)，可以化简为a-b，-a+b则化简为b-a。</li>\n</ul><p>刚才列出的这些，都属于加法和减法运算。类似的是，对于其他运算，我们也都可以进行化简或者变形。比如，对于a<em>2或a</em>4，规范化后会变成移位运算。</p><p>你也可以想象出来，上述规范化的操作，基于我们现在的IR，实现起来都不是很复杂，我们仍然只要对图中的节点进行模式的匹配和修改就行了。</p><p>总的来说，上述化简操作，属于算术化简和符号运算的范畴。比如，把1+ 2化简成3，这属于算术化简，基于算术运算的规则就行。而把(a - b) + b化简成a，这就属于符号运算的范畴，也就是说，运算的对象不再是具体的数字，而是像代数里的一个个变量。</p><p>符号运算是从编译原理衍生出来的一项技术。一些数学软件包，具备基于符号进行运算的能力。比如，你输入一个复杂的公式，它能够把它化简成一个简单的公式。或者你输入一个命题，它能给你推理，并证明该命题是真还是假。</p><p>我自己特别关注的是对关系运算和逻辑运算的化简，比如(!a || !b)会被化简成!(a&amp;&amp;b)，a || false会被化简成a，a || true会被化简成ture，等等。我对它们比较关注的原因，是想把它们借鉴进类型运算中。比如，变量a的类型声明为string|null，如果再加上一个条件if(a)，那么if块中，a的类型就会被窄化成string：</p><pre><code class=\"language-plain\">let a: string|null;\n//some code\nif(a){\n  //现在a的类型肯定是string。\n}\n</code></pre><p>之前我们也学习了类型窄化，目前，在我们这门课中实现的类型窄化的算法，都是采用集合运算的规则进行处理的。如果我们在这里面加入符号运算，那么我们再进行类型窄化就会变得更简单。我会在开源版本的PlayScript中再进行算法的迭代，你感兴趣的话可以继续关注。</p><h2>课程小结</h2><p>这节课的内容就是这些了。在这节课里，我通过内联优化和过程间的逃逸分析，让你建立对过程间优化的直观认识。对于这节课的重点，我们再重新回顾一下：</p><p>首先，内联优化的实质是把两个函数的IR拼接在一起，把形参节点替换成实参节点。内联优化通常还会为其他优化创造出机会。</p><p>第二，逃逸分析的作用在于，一旦我们确定出某个对象并没有逃逸，那么就可以实现栈上内存分配、标量替换和同步消除的优化。通过跨越多个函数进行分析，我们可以发现出更多的对象是没有逃逸的，从而可以做更多优化。逃逸分析也可以基于IR图来进行。</p><p>最后，除了过程间优化，我在这节课还补充了一个规范化方面的知识点。规范化主要是针对各种运算节点，实现符号化简和代数化简。其中的符号运算方面的技术，值得我们关注，它会帮助我们更好地进行类型的处理。</p><p>关于基于IR做中端优化，我们就介绍这些。下一节课，我们将介绍如何把这些IR做Lower处理，并最终生成汇编代码。在这个过程中，我们仍然需要用到一些优化技术。</p><h2>思考题</h2><p>在讲解中端优化的内容中，我们发现，受益于基于图的IR的优点，实现很多优化算法都变得更简单了。但是，事物往往是平衡的，有一方面的优点，往往就会带来另一方面的缺点。那么你能不能分析一下，这种基于图的IR，会让哪些操作反而变得更复杂呢？</p><p>欢迎你基于对图这种数据结构的认识来发表一下观点。这种分析，会让你从更高的高度来审视对数据结构设计的取舍。</p><p>欢迎你把这节课分享给更多感兴趣的朋友。我是宫文学，我们下节课见。</p><h2>资源链接</h2><p><a href=\"https://gitee.com/richard-gong/craft-a-language/tree/master/39-40\">这节课的示例代码目录在这里！</a></p>","neighbors":{"left":{"article_title":"39｜中端优化第2关：全局优化要怎么搞？","id":442804},"right":{"article_title":"41｜后端优化：生成LIR和指令选择","id":446048}}},{"article_id":446048,"article_title":"41｜后端优化：生成LIR和指令选择","article_content":"<p>你好，我是宫文学。</p><p>前面几节课中，我们讨论的主要是中端的优化。中端优化是跟具体硬件关系并不大，但由于我们还要生成针对具体CPU的汇编代码或机器码，所以做完中端优化之后，我们还要针对具体CPU的特性来做一些优化，也就是后端优化。</p><p>其实，我们已经接触过一些后端优化技术了。比如，之前我们已经讲过寄存器分配算法、尾调用和尾递归的优化，这些基本上都属于后端优化。不过，那个时候，我们是从AST直接生成汇编代码，然后在这个过程中做一些后端优化的。</p><p>在第三部分优化篇中，我们引入了新的、基于图的IR，进行了很多与硬件无关的优化。用这个基于图的IR来做后端优化，效果又怎样呢？接下来，我们就要修改以前的生成汇编代码的逻辑，改成从这个IR来生成汇编代码，并在这个过程中做一些优化。</p><p>今天这一节课，我就带你从中端过渡到后端，看看如何实现后端优化，并生成目标代码。这其中包括IR的Lower、生成LIR和指令选择，以及寄存器分配、指令重排序、窥孔优化和汇编代码的生成，等等工作。不过有些知识点我之前已经讲过了，还有一些知识点不是我们这门课的重点，我就不再展开讲了，重点帮你贯穿一下整个过程。</p><p>首先，我们先了解一下给IR做Lower的过程。</p><!-- [[[read_end]]] --><h2>Lower过程</h2><p>HIR要经过一系列Lower过程，最后变成LIR。我先举一个例子，让你理解一下在Lower过程中会发生什么事情。这是一个简单的例子，它只实现了给mammal对象weight字段赋值的功能：</p><pre><code class=\"language-plain\">function accessField(mammal:Mammal, weight:number){\n&nbsp; &nbsp; mammal.weight = weight;\n}\n</code></pre><p>针对对象属性的赋值，通常编译器要生成写内存的指令。这是因为，对象通常使用的是在堆里申请的内存。而且，由于一个对象可能会由多个线程访问，所以只有把对象属性写到内存里，另一个线程才能访问到更新后的属性。</p><p>当然，我们前一节课也说过，如果这个对象并没有逃逸，那就是另一种情况了。我们先假设该对象是逃逸的，那么我们要给对象属性赋值，首先就需要进行<strong>写内存</strong>的操作。</p><p>对于这个简单的场景，一开始这个程序的IR是下面这样：</p><p><img src=\"https://static001.geekbang.org/resource/image/f3/1e/f353cc73b80yy3dc94f200a29514ac1e.jpg?wh=860x422\" alt=\"\"></p><p>这里，我们使用了一个抽象度比较高的节点，叫做StoreField。它接受两个输入：一个输入是对象的引用，也就是对象地址；第二个输入是weight属性的值。</p><p>在编译的过程中，这个IR会被做Lower处理。StoreField节点会被一个Write节点代替，Write节点是一个写内存的操作。而内存地址呢，用OffsetAddress表示，也就是一个基地址加上一定的偏移量。基地址就是对象的地址，偏移量是对象头的大小。在PlayScript的设计中，它是16个字节。Lower过一次的IR图是这样的：</p><p><img src=\"https://static001.geekbang.org/resource/image/2a/29/2a8c8a9bd7951018a7c9641f75183a29.jpg?wh=1144x580\" alt=\"\"></p><p>到目前为止，这个IR还是跟具体CPU无关的。因为按照这张IR图，无论针对什么CPU，你都可以通过在某个地址的基础上加上一个偏移量，来获得新的地址。</p><p>然后这个IR还会进一步被Lower，让地址的表示方式更贴近x86-64（或AMD64）架构的具体寻址方式。我们曾经学过x86-64的寻址方式，它的完整形式包括基地址、偏移量、下标值、元素字节数等多个参数。但这里我们只需要它的简化方式，也就是基地址加上一个偏移量就行。进一步Lower的IR变成了这样：</p><p><img src=\"https://static001.geekbang.org/resource/image/a9/5a/a94c895a6f9d966bd57090576853235a.jpg?wh=1036x568\" alt=\"\"></p><p>到了这一步，我们的IR已经变得跟具体CPU架构相关了。接下来，我们就把它彻底转化成LIR的格式。</p><h2>生成LIR和指令选择</h2><p>那LIR又是什么样子的呢？你可以思考一下，如果你来设计编译器，应该如何设计LIR呢？</p><p>LIR的目的，是进行机器相关的优化，并最后生成汇编代码。所以，<strong>大部分LIR的设计，都是跟汇编代码是同构的</strong>。也就是说，LIR是由一条条指令构成的，指令是放在基本块中的，而基本块之间存在跳转关系。</p><p>从这个意义上说，我们之前生成汇编代码的时候，已经设计过这样的LIR。而Graal、LLVM、Go语言的gc编译器，在生成汇编代码或机器码之前也都有类似的LIR设计。这个数据结构看上去仍然是基于CFG的，但我们目前已经不需要分析它的控制流和数据流，并调整里面的代码了。这些工作，我们在中端优化的时候都已经完成了。<strong>现在，基于这个LIR，我们关心的主要是指令选择、寄存器分配和指令重排序（或者叫做指令调度）这样的话题</strong>。</p><p>由于我们的IR设计借鉴了Graal编译器，那么同样的，我们继续跟着Graal看看它是怎么处理LIR的。图中是Graal编译器中生成的LIR的例子，你可以通过它建立对LIR的直观感觉：</p><p><img src=\"https://static001.geekbang.org/resource/image/67/67/6708e219aa7924b510680faa90739567.png?wh=1442x1236\" alt=\"图片\"></p><p>这张图中一行行的文本，是为了显示LIR中内容，便于调试，实际上的LIR都是内存里的一条条的指令对象。在这个图中，你还能看到Graal编译器的后端处理过程，包括生成LIR、寄存器分配，一直到生成目标代码。<strong>我们自己实现的编译器，也需要完成类似的功能。</strong></p><p>好了，我们现在已经理解了LIR是什么样子了。那我们现在就从HIR生成LIR，并在这个过程中进行指令的选择，这又可以分成几项子任务。</p><p>首先，我们要把<strong>HIR中的不同节点分配到不同的基本块</strong>中，这被叫做调度算法（Schedule）。</p><p>我们在39节已经介绍过，由于很多数据流节点是浮动的，我们可以自由地选择在什么时候进行计算。但我们在生成汇编代码之前，还是要把确定这些数据节点的计算时机，因此要把它们分配到具体的基本块中。</p><p>而且，我们需要基于一些规则来完成这个分配工作，比如对于循环无关的代码，我们会提到循环外边；而基于控制流来求值的代码，比如if语句的两个不同分支的代码，我们尽量分配到这两个分支对应的基本块中。制定这些规则的出发点，是尽可能地提升程序的性能，但其实并不能完全保证。在比较AOT和JIT时，我们已经讲过这点了。</p><p>在划分好基本块以后，我们再做第二项工作，<strong>把IR图转化成LIR的指令，并在这个过程中进行指令的选择。</strong></p><p>如果细讲起来，指令选择有两层含义，而这两层含义的工作经常是一起实现的。指令选择的第一层含义，是把抽象的运算，准确地Lower到硬件的具体指令上。比如说，我们可以从比较抽象的层次，对整数和浮点数都执行加法运算。但到了CPU层面，整数的加法指令和浮点数的加法指令就不一样了。其他指令，比如比较运算、数据拷贝的指令，也是跟数据类型和所采用的指令集相关的，编译器要确定出正确的指令。</p><p>指令选择的第二层含义，指的是相同的功能，可以用不同的指令组合来实现，而我们要尽量选择让整体性能最优的那组指令。这实际上是一个最优化问题。</p><p>关于指令选择的算法，我在《编译原理之美》的29节做过一些理论性的介绍，在《编译原理实战课》的16节，我也介绍过Graal编译器的具体实现。这门课，我也会参考Graal的思路，做一个比较简化的实现。</p><p>在我看来，要理解指令选择，除了学习算法，更重要的是<strong>要了解很多具体的指令选择场景</strong>。下面，我们就以x86-64架构的指令来举几个例子，帮助你建立直观理解。经过这些讲解后，你就能理解那些抽象的算法到底在说些什么了。</p><p>第一个例子，是经常出现在if语句中的条件跳转指令：</p><pre><code class=\"language-plain\">if(a&gt;b){\n  //somecode\n}\nelse{\n  //some other code\n}\n</code></pre><p>回忆一下，我们在这门课的第9节、为字节码虚拟机生成字节码的时候，if条件和跳转相关的字节码是分两步来生成的：第一步，处理if条件，计算条件表达式\"a&lt;b\"，并生成1或0两个值，代表true和false；第二步，处理if节点，根据&lt;节点的值来生成跳转指令。跳转指令使用JE或JNE就行了，也就是比较if条件是不是1。</p><p>用这个方式生成指令比较简单。算法上说，就是对每个AST节点依次进行处理。像字面量、变量这样的节点，我们会返回一个Operand。而对于计算性节点，我们就要生成指令，并把指令运行的结果作为Operand来返回。</p><p>不过，大部分CPU或虚拟机都提供了更丰富的条件跳转指令，比如JL指令就可以用于在a&lt;b的时候做跳转，而JG指令就可以用于在a&gt;b的时候跳转。这个时候，我们需要同时处理if和&lt;号两个节点，确定采用什么指令，你可以看一下这张示意图：</p><p><img src=\"https://static001.geekbang.org/resource/image/b3/5d/b32450875897c4d54b58c8aba33d225d.jpg?wh=1032x688\" alt=\"图片\"></p><p>这就是指令选择算法的特点，我们需要一次性地考虑AST或IR中的多个节点，并生成合适的指令，只要最后算法确实覆盖了所有节点就行。</p><p>第二类经常需要做指令选择的情况，是对内存的访问。我还是用这节课开头这个、给mammal对象的weight属性赋值的例子来做说明：</p><pre><code class=\"language-plain\">function accessField(mammal:Mammal, weight:number){\n&nbsp; &nbsp; mammal.weight = weight;\n}\n</code></pre><p>在生成指令的时候，我们需要在对象的基地址的基础上，添加一个偏移量，获得weight属性的地址，然后再给这个地址赋值。</p><p>要完成这个操作，我们有两个办法。第一个办法是分成两步来生成指令，第一步是先计算出weight属性的地址，第二步是往内存地址写weight的值：</p><p><img src=\"https://static001.geekbang.org/resource/image/9d/ee/9d4cde4047cf3603eebe84df1a46ebee.jpg?wh=1096x572\" alt=\"图片\"></p><p>这两步对应的LIR相当于下面两条代码：</p><pre><code class=\"language-plain\">add $16, p0   #把p0,也就是对象的地址加上偏移量\nmov p1, (p0)  #把p1赋给p0指向的内存地址\n</code></pre><p>不过，我们还有第二个方法来生成指令，这就是直接使用x86-64的寻址方式，用一条指令就能完成地址计算和写内存这两个操作。我们的指令选择算法需要一次性处理Write和AMD64Address两个节点：</p><p><img src=\"https://static001.geekbang.org/resource/image/34/51/34d202b1851a4300410ee1e6aa17d451.jpg?wh=1152x528\" alt=\"图片\"></p><p>生成的LIR相当于下面的一条代码：</p><pre><code class=\"language-plain\">mov p1, 16(p0)   #把p1赋给p0指向的内存地址再加16的偏移量。\n</code></pre><p>通过我举的这两个场景，你大概应该明白指令选择的工作原理了。在生成LIR的过程中，类似的场景还有很多。这里的共同点，都是<strong>因为目标CPU往往能用更简洁的方式，一次性完成两项甚至多项运算工作，从而达到节省指令、提高效率的目标</strong>。</p><p>那在生成了LIR以后，编译器接下来还要做哪些工作呢？</p><h2>后续优化工作</h2><p>首先，是我们已经学习过的<strong>寄存器分配工作</strong>。这项工作，我们之前已经基于前一个版本的LIR做过了。在升级LIR之后，我们只需要适当做一些完善就行了。</p><p>在我们新的LIR中，一开始变量还都是用名称表示的，或者说它们是逻辑寄存器。而寄存器分配算法，是要把它们映射成物理寄存器。并且，当物理寄存器不够的时候，需要把某个寄存器的值spill到栈桢中来腾出寄存器。而调用其他函数的时候，还需要把Caller保护的寄存器保护起来。在Callee中，也有需要保护的寄存器。所有这些寄存器的管理工作，都是在寄存器分配算法中完成的。</p><p>再接下来呢，有些编译器会使用一个<strong>代码重排序</strong>的算法，通过调整指令的执行顺序，在不改变程序运行结果的情况下，利用CPU的流水线功能，提升程序运行的效率。</p><p>这是一个可选的功能，而且我在《编译原理之美》第30节课具体分析过，在这里我就不再展开了，如果你有兴趣实现这个功能，可以参考那一节课。不过我注意到，现在很多编译器都没有实现这个功能，这有两个原因。一个原因，是现代CPU在硬件层面上已经有很好的乱序执行能力了，所以编译器层面上的优化带来的收益不高。</p><p>第二个原因，是对于并发执行的程序，改变指令的执行顺序需要考虑更多的影响。比如在单线程的情况下，改变指令顺序不影响计算结果，但在多线程的情况下，就可能导致计算结果的不一致。</p><p>最后呢，我们通常还会<strong>基于LIR再做一些优化工作</strong>。其中一项常用的技术，叫做<strong>窥孔优化</strong>。窥孔优化是什么意思呢？我还是通过举例子来说明。</p><p>如果你仔细阅读了我们当前编译器生成的字节码或者汇编代码，会发现里面有一些像是废话的代码。你可以看看下面这个示例代码：</p><pre><code class=\"language-plain\"># some code\ncall _foo\nmovsd %xmm0, %xmm1   #把返回值拷贝到xmm1\n# 一些代码，并没有修改xmm0的值\nmovsd %xmm1, %xmm0   #把xmm1的值拷贝到xmm0，作为函数返回值\n</code></pre><p>这里，在调用foo函数之后，我首先把返回值从xmm0拷贝到了一个新的寄存器xmm1。这么做的原因，是因为xmm0有可能在调用函数之前，分配给了一个别的变量，而在调用函数之后，需要把该变量从内存恢复回xmm0。所以，为了防止返回值被破坏，我们通常需要把它赋给一个临时变量，而寄存器分配算法会给这个临时变量分配单独的寄存器，比如xmm1。</p><p>但实际的代码执行过程中，后面并没有代码来修改xmm0的值。而在返回当前函数的时候，我们又把xmm1拷贝回xmm0，作为函数的返回值。</p><p>你用肉眼就可以看出，这里存在着优化的机会，也就是后面的两个movsd指令都是多余的，可以去掉。</p><p>不仅我们课程里生成的汇编代码和字节码有这样的瑕疵，你如果不用优化参数来调用clang或gcc编译器，生成的汇编代码中也都有很多这样的冗余指令。</p><p>所谓窥孔优化，就可以用于处理这种场景。<strong>它的原理，是通过一个窗口扫描LIR、汇编代码或者是机器码，每次扫描n行，这n行就是窗口的大小。</strong>程序可以分析这个窗口里的代码有没有什么冗余的代码，或者其他可以优化的机会，并进行优化。比如，如果一个窗口能够覆盖我们前面的示例代码，那就可以发现其中的问题。这个窗口可以沿着代码不断的滑动，从而发现所有代码中的优化机会。</p><p>不过，如果编译器在前序的工作中处理得越好，留给后面窥孔优化的机会就越少。就像我刚才举的例子中，如果我生成指令和做寄存器分配的算法更聪明一些，就可以不用在寄存器之间来回倒腾数据了，也就不需要后面来做这种窥孔优化了，这个优化算法同样是个可选项。在后续迭代的PlayScript项目中，如果遇到了需要窥孔优化的场景，我会再加上它。</p><p>在基于LIR做完所有的优化以后，最后一个环节就是<strong>生成目标代码</strong>。</p><p>这是一个比较直接的转换过程，并不复杂，在我们之前的asm_x86-64.ts的代码中就有实现。不过，我们是生成文本的汇编代码，而很多编译器，特别是JIT编译器，是直接生成机器码来运行。生成机器码相比生成汇编代码其实并没有什么特别的难点，我们只需要额外做一点翻译工作就好了。</p><p>对于JIT编译器而言，生成机器码反倒省去了程序的静态链接的工作。它并不需要像静态编译那样，把所有函数都连续存储在内存的文本区，再计算出每个函数的入口地址，方便操作系统加载到内存并运行。在使用JIT的虚拟机里，每个函数的地址都可以在运行时查询获得。</p><h2>课程小结</h2><p>今天这节课，我们把中端优化之后，编译器的后续工作过了一遍，把之前我们已经讲过的与后端有关的功能也串联了一下，让你产生一个清晰的、全局的认知。我希望你记住下面的重点：</p><p>首先，你需要对IR的Lower过程有直观的认识。在Lower的过程中，IR的节点会越来越与具体硬件上的实现相关。你可以记住这节课举的给对象赋值的例子。在实现编译器的过程中，你自己就会发现更多这样的场景。</p><p>第二，LIR通常可以跟具体CPU架构的汇编代码直接对应。它是由指令构成的，指令放在基本块中，基本块之间有跳转。</p><p>第三，指令选择算法，通常表现为一次性匹配多个IR节点，发现其中的模式，并用一条指令实现多个功能，这样就能减少指令的数量，实现性能的提升。</p><p>第四，编译器后端的优化还包括寄存器分配、指令重排序和窥孔优化等。寄存器分配是必须的，而指令重排序和窥孔优化是可选的。</p><h2>思考题</h2><p>如果要理解指令选择，这个关键就是要知道一些实际的场景。我在这节课中举了两个场景，之前我还曾提过lea指令的场景。</p><p>那么，你还知道有哪些具体的指令选择的场景吗？比如，我在《编译原理实战课》的16节，给出了一个代码链接：<a href=\"https://time.geekbang.org/column/article/258162#:~:text=%E8%AF%B7%E4%BD%A0%E9%98%85%E8%AF%BB-,AMD64NodeMatchRules,-%E4%B8%AD%E7%9A%84%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99\">AMD64NodeMatchRules</a>，里面是Java的Graal编译器所实现的一些指令选择的规则。如果你阅读过这些编译器的代码，或者是你自己也实现过一些指令选择的场景，可以在留言区分享一下。</p><p>欢迎你把这节课分享给更多感兴趣的朋友。我是宫文学，我们下节课见。</p>","neighbors":{"left":{"article_title":"40｜中端优化第3关：一起来挑战过程间优化","id":444361},"right":{"article_title":"42｜到这里，我们的收获和未尽的工作有哪些？","id":446848}}},{"article_id":446848,"article_title":"42｜到这里，我们的收获和未尽的工作有哪些？","article_content":"<p>你好，我是宫文学。</p><p>到今天这节课为止，我们已经把这门课程的主要内容都学完了。感谢你一路的坚持！</p><p>所以，在今天这节课，我想做一个简单的总结。我想先带你回顾一下我们一起闯过的那些技术关卡，以及取得的成果。接下来，我还想梳理一下我们尚未完成的工作，也对我们后续作为开源项目的PlayScript语言做一下规划。</p><p>在这个过程中，你可以暂时从技术细节中解脱出来，站在一个语言的架构师的角度，一起做一些高层面的思考，锻炼一下架构思维。</p><p>首先，我们简单总结一下当前已经完成的工作。</p><h2>当前的收获</h2><p>到目前为止，我们在40多节课的内容里，塞进了大量的知识点。我们按课程顺序来梳理一下。</p><h3>基础篇：三大关卡</h3><p>在第一部分基础篇中，我带你连续闯了三个关卡。</p><p><strong>第一个关卡，是编译器前端技术，包括词法分析、语法分析和语义分析技术。</strong></p><p>在词法和语法分析方面，我们这门课没有带你进入相关算法的迷魂阵，而是带你去掌握最佳实践。一方面，这些算法我在《编译原理之美》课程中已经讲过了。另一方面，如果你只是写个编译器，而不是写个像Yacc、Antlr这样的编译器生成工具，其实不需要深究那些算法，只要大概明白原理就行了。</p><p>即使是这样，对于递归下降中的左递归问题这样偏理论性的知识点，很多同学免不了还是有疑惑。比如，有同学会问我，我在课程里用到的有些文法，为什么仍然有一些是左递归的呢？这里其实涉及到PEG文法的一个知识点，我会在后面的加餐里讲一下PEG。其实，并不是所有的左递归都没有办法处理。关于左递归，直到现在仍然是做算法研究的人感兴趣的一个领域。</p><!-- [[[read_end]]] --><p>在语义分析方面，我们体会了如何建立符号表、如何做引用消解、如何检查一些语义错误的过程，这样，你会对课本中讲到的一些抽象概念建立具象的理解。</p><p>为了编译TypeScript语言，编译器在语义分析阶段最重要的功能是进行类型的处理，其中的关键点又是类型的联合和窄化。在这门课里，我们主要采用了集合运算的手法来处理类型。在PlayScript开源项目中，我计划把这部分进一步优化，让类型计算更简洁、更精准。</p><p>对很多同学来说，闯过编译器前端的这个关卡，其实已经收获满满，可以在自己的项目里大展身手了。不过，如果你喜欢钻研底层实现，显然还不会满足止步于此，那你就可以继续闯第二关。</p><p><strong>在第二关，我们实现了两个版本的字节码虚拟机。一个版本是用TypeScript实现的，另一个版本使用C语言实现的。</strong></p><p>通过这个实现过程，你会了解到像Java这样的成熟语言的字节码是如何设计的，又是如何实际运行的。这样，在需要的时候，我希望你能够敢于自己生成Java或.NET的字节码，实现自己想要的软件编程功能。</p><p>并且，通过实现C语言版本的虚拟机，我们也能初步了解运行时的功能。特别是，你要知道，如果我们不能做好内存的管理，系统运行的性能就会大受影响。而且，通过我们多次的性能测试，你应该已经对一个解释器中影响性能的因素产生了直观的理解，这样你自己写程序的时候，也能够进行更明智的决策。</p><p><strong>在初步实现了字节码解释器以后，我们又进入了第三关，挑战把源代码编译成二进制的可执行程序。</strong></p><p>为了完成第三关的任务，我们必须对程序的运行机制有深入的了解，包括程序运行跟硬件是什么关系，跟操作系统和ABI又是什么关系。再进一步，我们还需要了解CPU架构和它支持的指令集，学会阅读甚至手写汇编代码。</p><p>生成汇编代码有两个关键点：第一，要熟悉ABI，正确地维护栈桢和寄存器的状态，否则程序运行时就会报segment错误；第二，就是要实现寄存器分配算法。你要知道，不同的指令集会使用不同的寄存器，并且我们在函数调用前后要保护某些寄存器。做好这些以后，程序就可以充分利用寄存器，飞一般地运行了。</p><p>在闯完这三关以后，你已经从前端到后端打通了技术路线。接下来在第二部分进阶篇中，我们把这条路线做了拓宽。</p><h3>进阶篇：拓宽路径</h3><p>怎么去做拓宽呢？我们的主线是支持更多的数据类型，包括浮点数、字符串和数组这几个基础类型，还包括自定义对象、高阶函数这种高级的类型。</p><p>为了支持这些类型，我们必须增强运行时的功能，需要设计对象的内存布局。在访问对象属性、数组成员的时候，我们也要能够正确计算出内存地址来。</p><p>进阶篇最难的部分，是<strong>自动内存管理功能，</strong>包括基于Arena的内存申请机制，以及垃圾回收机制。而实现垃圾回收的关键点，在于找到GC根，并顺着GC根去找到直接引用和间接引用的对象。因此，我们需要保存栈桢的布局信息、对象的元数据信息、闭包的元数据信息等各种静态信息。</p><p>如果你充分掌握了内存管理涉及的技术点，那么你在后面实现很多高级功能的时候都能用上。比如对程序做调试、支持运行时的类型判断和元编程功能，都需要用到我们提前保存的元数据信息。</p><p>学完第二部分以后，你对实现像面向对象、函数式编程等各种语言特性基本上心里有数了。在第三部分优化篇，我们就专注于解决一个问题，就是优化问题。</p><h3>优化篇：基于图的IR</h3><p>优化是编译器最重要的功能之一。优化可以发生在全生命周期，包括前端、中端、后端和运行过程中。第三部分的核心，就是一个基于图的IR。这个IR被Java和JavaScript的编译器采用，你可以想象一定有它的优势。</p><p>在使用这个IR的过程中，我们确实发现，我们很多优化的实现都变得很简单了。像公共子表达式删除，我们在生成IR的过程中顺带着就能完成。还有，像拷贝传播、死代码删除、值编号等这些优化，实现起来也很简单。最重要的是，这个IR更容易打通本地优化、全局优化和过程间优化三者的边界，让代码更容易在不同的基本块中移动，获取我们想要的优化效果。</p><p>并且，我们还了解了基于这个IR不断地做lower，直到生成LIR，然后基于LIR做指令选择、寄存器分配等后端优化的完整过程。通过这一部分的学习，你对于前端、中端、后端优化要做的工作就都比较清晰了。</p><p>好了，以上就是这门课中我们领略的各种技术风光，我希望你能够充分掌握，一方面这能开阔你的技术思路，另一方面这些技术也能用到你的实际项目中。</p><p>不过，受限于时间，我还没有把一门完整的语言完全实现完。所以，我后面会把这门课的示例代码，作为一个开源项目继续迭代下去，并形成完整的、实用的版本。至于当前已有的基础，我们就把它作为0.1版本吧！</p><p>那如果我们要实现一个实用的版本，还有哪些工作要做呢？</p><h2>后续工作</h2><p><strong>第一，我们要对编译器前端做比较大的增强和重构。</strong></p><p>首先，当前我们已有的词法分析、语法分析和语义分析功能，都要支持更多的特性，比如，除了我们已经支持的for循环和if分支语句外，还有while循环、switch语句，等等。</p><p>而且，我们对编译错误的处理要更加友好。你应该也感受到了，目前我们的编译器，在遇到某些语法错误的时候，会持续不停地尝试，不断打印错误信息。这显然太不友好了，要做优化。</p><p>然后还有一个比较大的工作，就是对类型系统进行升级。我们要重构一下我们之前类型计算的算法，让它变得更加简洁和准确。我们目前使用的Nominal的类型系统，也要修改成支持structural的类型系统，并且我们还要让我们的类型计算支持泛型。</p><p>另外，我们在升级编译器前端的时候，对AST和符号表这两个重要的数据结构，也需要重构和优化一下。</p><p><strong>第二，我们要把面向对象和函数式编程的特性实现完整。</strong></p><p>比如，面向对象方面，我们需要实现严格的对象的初始化流程，需要支持访问权限，还要支持接口。在函数式编程方面，怎么着也要把Lambda表达式这些基础功能实现。这主要是工作量的问题，但需要前端、中端、后端和运行时各方面的配合。</p><p><strong>第三，是升级编译器的中端优化功能。</strong></p><p>基于目前的IR，我们只实现了少量的优化，并且还没有支持面向对象等复杂的语言特性，这些都需要进行扩展和支持。在这个实现的过程中，我们IR的数据结构也会得到丰富和完善。</p><p><strong>第四，是升级编译器的后端功能。</strong></p><p>我们之前的编译器后端主要是基于AST来生成汇编代码。所以，在引入IR以后，我们编译器的后端也需要重构一下。从AST生成IR后，再基于HIR生成LIR，然后在LIR的基础上重新实现指令选择和寄存器分配。</p><p>另外，我们目前只支持x86-64架构，并且也没有在多个操作系统上做测试。在后面，我们要支持至少两种CPU架构，我计划先支持的是x86-64和Aarch64。前者被广泛用于PC和服务器中，后者被广泛用于智能手机和苹果新一代Mac电脑中。而且，我们还要兼容多种操作系统。</p><p><strong>第五，是内存管理方面的升级。</strong></p><p>在垃圾收集方面，我们的GC还是很基础的，达不到实用级别。那么，接下来我们首先要完善基本的标记-清除算法。之后，我计划实现一个自动引用计数的（ARC）的机制。</p><p>ARC的原理是记录每个对象的引用数，当引用数为零的时候，就自动作为垃圾清理掉。ARC的好处就是垃圾回收不会引起大的停顿，能让系统的响应比较平缓。苹果的Objective-C和Swift都采用了ARC，这也是苹果的系统很少卡顿的原因之一。</p><p><strong>第六，实现并发机制。</strong></p><p>你应该也注意到了，目前我们这门课中并没有涉及并发机制。但如果不实现并发机制，显然会是一个遗憾。所以后面，我会给出协程功能的一个参考实现。至于另外的并发功能的设想，我接下来还会介绍到。</p><p>好了，上面就是要实现一个完整的、实用的、静态编译的语言会涉及到的工作量，细细看一下，还真是挺大的。不过，你也不用怵，这里并没有太多技术点是我们这门课没有涵盖到的，更多的是工作量和工程化的问题。</p><p>花费这么多的工作量，我并不完全是为了兴趣爱好，或者是做技术验证，还是想未来有一天，能把它用于一些实际的应用场景中。那接下来，我就谈谈对开源的PlayScript语言项目的一些规划。</p><h2>对PlayScript的规划</h2><p>为什么我会产生自己动手实现一门语言的想法呢？这其实是出于一些实际的需求。现有的语言，或者已有语言的现有实现，有时会让我很不满意。所以我就想，与其等着别人来满足我的需求，不如自己动手试试看。</p><p>我就分享一下我的这几个需求，看看你是否也遇到过类似的问题。</p><p><strong>首先，我对后端编程语言不满意。</strong></p><p>你知道吗？要实现像微信这样的应用的后端，你只能使用C++这样的语言。并且，微信团队还开发了自己的协程库，才能应对海量并发的需求。我们每天用微信，觉得它总是会实时响应，其实后端的挑战是巨大的。你想想看就知道，成亿的用户，加上成亿的并发，绝对是顶级的技术挑战。</p><p>Java、Go等典型的后端语言，都不能满足这种场景的需求。Java的内存占用太大，自带的并发机制只有线程。虽然Go语言好一点，但它和Java都有一个致命的弱点，就是垃圾回收导致的停顿是不可控的。这对于微信这种大型的、高并发的平台，会带来灾难性的后果。但是，让普通的技术团队用C++开发应用，门槛有点高。</p><p>而且，我对现有后端语言提供的可靠性也不满意。在这方面，我比较喜欢Erlang，它的并发机制和其他特性结合起来，能提供9个9的可靠性。我觉得，如果每个应用都能实现这么高的可靠性就好了。但是，我对Erlang的性能又不满意，而且它的语法对于大多数程序员来说，也不是太友好。</p><p>实现一门高可靠性的语言，其实有隐含一个需求，就是语言中的功能是能够在运行时被动态替换的，因为你没有办法停下整个系统。所以，我们不能仅仅实现AOT的功能，还要有JIT、动态优化、动态部署、动态Dispatch的功能。</p><p>所以，我理想的后端语言，是能够用比较低的成本，开发出高并发、高可靠性、资源消耗低的应用。不知道你是不是也有类似的需求呢？</p><p><strong>第二，我对前端编程环境也不太满意。</strong></p><p>我感觉，现在的前端编程环境太碎片化了，包括浏览器、Android、IOS、Windows、macOS、Linux等不同的平台，而且国内还有好几个不同的小程序平台。</p><p>所以，我想要是有一个语言或者工具，能够开发一次，部署到很多客户端，那就好了。</p><p><strong>第三，我对企业应用的编程语言也不满意。</strong></p><p>我曾经参与过很多企业应用的开发工作。在企业应用的开发中，很多时候我们要更关注业务逻辑。但是，现在很多应用的业务逻辑和技术逻辑都是混杂的，企业应用的开发成本太高了。</p><p>我一直认为，如果你是做企业软件的厂商，那应该有相应的开发语言才好，比如，德国的SAP就有自己的ABAP语言。不过，这个语言在现代的应用架构下已经过时了，用ABAP开发不出很容易横向扩展的应用。再有一点，这个语言是企业私有的，不是公共的。</p><p>当然，现在我们已经迎来了低代码开发的一波浪潮。但是，如果低代码工具的开发者不是像微软这么有实力的厂商，很难维护一个完全私有的生态。这样的情况下，客户在你私有的平台上开发应用，就是比较有风险的，所以还是应该有一个公共开放的语言。</p><p>而且，就算是低代码开发，我也希望是基于某个语言的，而不是仅仅提供一些图形化的定制工具。最好呢，是语言可以转化为图形，图形也可以转化为代码。这种代码和图形化表达双向转化的能力，我在华为的HarmonyOS开发工具上看到了，感觉很喜欢。其实我觉得，低代码开发工具也应该实现类似的功能才算合格，这种能把应用表达为代码的能力，是保证应用的可移植性、保护企业投资的关键。</p><p><strong>第四，如有可能，我希望能让物联网应用的开发变得更简单一点。</strong></p><p>我在之前的一篇加餐里，介绍过工控领域软件开发的情况。工控领域的技术原来叫做OT，它们的技术跟IT是不一样的。但在我看来，现在很多IT技术可以进入OT领域。比如，现在儿童编程都可以用一个图形化开发工具控制机器人，这跟控制发电机、控制高铁，其实没有本质的区别。所以，我们应该也可以把这两个领域的开发工具打通才对。就算是OT强调高可靠性，但其实，IT里现在就有更高可靠性的技术，比如我前面提到过的Erlang的9个9的可靠性。</p><p>另外，OT的技术生态，原来都把控在少数外国的企业手里。我觉得，如有可能，我们最好可以搞搞破坏，把它搞成一个开放的生态。</p><p>最后，现在工控应用和消费级的物联网应用，开发成本还是太高了。我觉得，我们应该可以用TypeScript这样简单的语言，就能生成footprint很小、性能很高、能够方便地跟硬件接口打交道的应用才对。</p><p>上面就是我对新的语言和开发工具的一些需求，也是我对现有的语言和工具不满意的地方。但我目前只把PlayScript作为一个开源的兴趣项目，不一定能完全实现这些目标。我现在只是把观点和期待在这里分享一下。</p><p>PlayScript的项目地址在这里：<a href=\"https://gitee.com/richard-gong/PlayScript\">https://gitee.com/richard-gong/PlayScript</a>。我会把代码整理一下放进去，并保持更新。如果你对哪方面的特性感兴趣，也欢迎你一起参与。</p><p>最后，还有一个重要的观点需要说明一下：<strong>实现一门语言和设计一门语言是两码事</strong>。你也看到了，我们这门课讨论的都是如何实现语言，并没有讨论怎么去设计一门语言。一方面，我自己对设计一门语言并没有把握。另一方面，我觉得我的这些需求，似乎也并不需要设计一门全新的语言，而是对现有的某个语言重新做一个实现就行了。使用大家都已经熟悉的语法，对我来说似乎是更好的选择。</p><h2>课程小结</h2><p>今天这节课，我把我们这门课的内容做了一下总结，也梳理了我们后续要继续实现的功能。所以，这节课并没有什么需要你记住的硬知识点。</p><p>不过，通过对这门课程的学习，以及我们今天的梳理，我希望你能产生一个信心，就是<strong>实现一门语言所需要的技术，其实并没有那么高不可攀</strong>。其实到现在，我们真的已经涉猎了几乎所有的技术点，现在已经没有哪个技术点是真正有难度的、能够挡住你的。</p><p>在这个信心的基础上，我们再讨论PlayScript未来的演化，讨论需要一些新的语言或者开发工具的场景，才有意义。因为你要知道，你其实是有能力完成这些工作的。我们在中国的软件领域，可以做很多类似的、基础性的，甚至开创性的工作，不用什么事情都仰人鼻息。</p><h2>思考题</h2><p>今天，我分享了我的职业生涯中，对现有的语言和工具各种不满意，并且，我也分享了希望有人能够站出来改进的一些方面。你有没有类似的需求和感受呢？请你也跟我们分享一下吧！</p><p>欢迎你把这节课分享给更多感兴趣的朋友。我是宫文学，我们下节课见。</p>","neighbors":{"left":{"article_title":"41｜后端优化：生成LIR和指令选择","id":446048},"right":{"article_title":"期末考试｜实现编程语言这些核心知识点，你掌握得咋样了？","id":447708}}},{"article_id":447708,"article_title":"期末考试｜实现编程语言这些核心知识点，你掌握得咋样了？","article_content":"<p>你好，我是宫文学。</p><p>我们的课程已接近尾声，要学的内容我们都已经全部学完了。不知道你掌握得怎么样了呢？今天，我给你准备了20道选择题，满分100分，范围囊括我们这门课的众多核心知识，一起来挑战一下吧！</p><p><a href=\"http://time.geekbang.org/quiz/intro?act_id=1128&exam_id=3130\"><img src=\"https://static001.geekbang.org/resource/image/28/a4/28d1be62669b4f3cc01c36466bf811a4.png?wh=1142x201\" alt=\"\"></a></p><p>如果有什么不明白的，欢迎直接在留言区提问，也可以在<a href=\"https://jinshuju.net/f/eMNUpx\">交流群</a>找我，期待你满分的好消息！</p><p>另外，我还给你准备了一份<a href=\"https://jinshuju.net/f/wDM5tl\">调查问卷</a>，想听一下你对我这门课的看法和建议。题目不多，两分钟就可以填完，非常希望能看到你的反馈。</p><p><a href=\"https://jinshuju.net/f/wDM5tl\"><img src=\"https://static001.geekbang.org/resource/image/f1/84/f1a7c7c4a7a45d1ab144855a4c2d9784.jpg?wh=1142x801\" alt=\"\"></a></p><!-- [[[read_end]]] -->","neighbors":{"left":{"article_title":"42｜到这里，我们的收获和未尽的工作有哪些？","id":446848},"right":{"article_title":"结束语｜等待你大展身手的那些领域","id":450960}}},{"article_id":450960,"article_title":"结束语｜等待你大展身手的那些领域","article_content":"<p>你好，我是宫文学。</p><p>到今天为止，我们这门课的主要内容就都更新完了。不过，还有一些补充性的内容，我会通过加餐和开源项目的方式，继续和你保持沟通。</p><p>今天的结束语，我想跟你探讨一下，<strong>学习实现一门语言的相关技术，到底会有什么用途。</strong></p><p>我会分成领域编程语言、平台级的软件和通用编程语言这三个话题，分析一下 编程语言技术能帮助你抓住哪些机会，让你有机会从普通的程序员进阶成大神级的程序员，并创造出一些卓越的产品。</p><p>首先，我们来谈谈领域编程语言这个话题。</p><h2>领域编程语言（DSL）</h2><p>对于我们大部分同学来说，其实很难有机会，或者也没有这个意愿，去参与实现一门通用性编程语言。不过，其实在大部分情况下，我们也没有必要追求那么大的目标。有时候，针对我们所在的领域，实现一门领域编程语言，就是很有意义、很有成就感的事情。</p><p>我举几个我遇到的DSL的例子，看看能否抛转引玉，让你找到更多可以设计和使用DSL的场景。</p><h3>MiniZinc：最优化领域的开发工具</h3><p>在2020年的12月，我曾经研究了一下最优化算法相关的技术和工具，看看它能否用于我们的一个产品。</p><p>很多同学在大学都学过最优化相关的理论，像线性规划、非线性规划这些，都属于这个领域。你也可能听说过运筹学，它们的意思差不多。最优化理论在实践中有很多用途。比如，我要解决一个应用问题，就是在某个领域，有很多员工，也有很多任务要完成。每个员工的技能是不同的，我需要通过算法来安排这些员工的工作，取得整体最优的效果。</p><!-- [[[read_end]]] --><p>为了实现最优化求解，有人开发了各种求解器，有商业的，也有开源的。但对于我一个新手来说，我一开始并不知道要用哪个工具，有点茫然。</p><p>通过某些途径，我了解到了MiniZinc这个工具。这个工具提供了一种DSL，能够描述各种最优化问题，然后调用各种不同的求解器来求解。比如在下图，你能看到菜单栏有一个下拉菜单，里面有多个求解器。</p><p><img src=\"https://static001.geekbang.org/resource/image/c1/6e/c109d16629a805fd4eb06bdcae4d766e.png?wh=1920x1596\" alt=\"图片\"></p><p>MiniZinc这个工具一下子解决了我的两个需求。首先，这个DSL很友好、很直观。你完全可以按照最优化的理论，描述一个问题的变量、参数、约束条件，然后就可以求解了，非常方便。第二，我暂时也不用关心不同的求解器的差别，可以随便选一个先用着，或者换着用不同的求解器，看看它们在性能和求解结果有哪些差异。</p><p>所以我很快就用MiniZinc编写了几个小程序来验证我的想法，并在较短的时间内取得了一些成果。</p><p>在使用这个工具的时候，我就在想，上过我这门课的同学，有没有能力做这么一个工具呢？我们来分析一下。</p><p>其实，要实现MiniZinc，主要的工作就是<strong>实现一个编译器的前端</strong>，做词法分析、语法分析和语义分析工作。这个DSL的语法和语义都不是很复杂，所以工作量并不大。</p><p>做完前端的工作以后，程序就可以基于AST来解释执行了。解释执行的过程，其实就是调用各个求解器的API，并把结果显示到界面上。</p><p>这么一个小工具，会给那些最优化领域的工作者和科研人员带来很大的便利。因为他们通常专注于研究算法，对于通用的计算机编程并不是很熟练。</p><p>那在你的领域中，是不是也有这样的情况呢？你是IT专业的人员，而你同事可能是其他专业的专家，比如是工程专家、投资专家、财务专家等等。你能否针对他们的领域，设计出一些DSL，并提供一个开发工具来解决他们的一些痛点问题呢？</p><p>我们再看看第二个例子，这个例子是遥感领域的一个二次开发平台。</p><h3>遥感领域的二次开发平台</h3><p>我硕士的专业是在遥感和GIS领域，我有一个硕士同学在这个领域做出了一个上市公司。他们有一个产品，是一个遥感云平台，也就是把全国各地的很多遥感资料都放到云上管理。这个云平台里有一个开发工具，能够让用户在浏览器里编写程序，调用云平台的API，实现遥感数据分析等功能。</p><p><img src=\"https://static001.geekbang.org/resource/image/db/db/dbd66ff373a08540af4662ef37d15ddb.png?wh=1456x910\" alt=\"图片\"></p><p>据说这个平台是跟Google Earth对标的，国外很多科学家都会在Google Earth平台上写程序处理遥感数据，并构建自己领域的应用。</p><p>如果让你去实现这个开发工具，你会怎么做呢？</p><p>首先，你肯定需要<strong>一个基于Web的代码编辑器</strong>，这方面有好几个开源工具，所以这点并不是难题。</p><p>接下来，你仍然要实现<strong>编译器前端的工作</strong>。这一次，你需要编译的是JavaScript语言，它的语法特性和语义特性都比较多，所以实现的工作量要大一些。你可以把我们现在的词法分析器和语法分析器改一改，来实现JavaScript的解析。如果你想偷懒，还可以直接用antlr和现成的语法规则生成一下解析器。不过，无论如何，语义分析的工作是省不了的。你需要建立符号表、进行符号的消解，但不需要像我们这门课这样做那么多的类型处理。</p><p>完成编译器前端以后，还要做些什么呢？我们还要<strong>做一些中端的优化工作</strong>。因为这个开发工具要调用与遥感有关的API。而如何调用这些API才会让效率最高呢？所以这一点上，我们实际上是要做一些优化的。</p><p>做完中端优化后，后续的编译和运行过程，有可能只要交给一个成熟的JavaScript引擎就可以了。</p><p>怎么样？使用我们这门课上学过的技术，你可以把很多科研工作者、各个行业的应用开发人员，都聚集到一个平台上，充分释放海量遥感数据的价值，这是不是一件挺酷的事情？</p><p>接下来，我再举一个CAD领域的例子，这个产品是OpenCAD。</p><h3>OpenCAD</h3><p>几个月前，我一时兴起买了一台3D打印机，想自己打印点好玩的东西。但是在打印之前，还需要建立3D模型，所以我就搜了搜建模工具，发现了一个叫做OpenCAD的软件。</p><p>这个软件提供了一个编程界面。你可以在这个界面中，通过编程来创建长方体、圆柱体这样的三维对象，也可以通过编程来控制它们的位置、旋转的角度。</p><p>另外，你还可以创建模块，把多个基础的对象拼成复杂的对象，比如把一些长方体、圆柱体拼成一辆车。之后，这辆车就可以作为一个整体，用来构架更复杂的场景。</p><p>并且，模块还可以带参数，就像一个函数或者一个类那样。你通过调整模块的参数，就可以调整生成的3D对象。比如同样是一辆车，你可以通过调整参数生成一辆很大的车，也可以生成一辆玩具车。</p><p><img src=\"https://static001.geekbang.org/resource/image/bd/86/bdef461f012122bcfe7906b7bdfe8f86.png?wh=1920x1200\" alt=\"图片\"></p><p>我并不熟悉CAD领域，所以很难把这个软件跟其他CAD软件做客观地对比。不过，我能够看出，OpenCAD通过编程来建模的形式，有几个特别的优势：</p><p>第一个优势是精准。在建立某些机械模型的时候，零件的大小、位置等信息必须是精准的。而使用编程语言，你可以用数学公式做出各种精准地计算。比如，上面的例子就使用了三角函数来精确的绘制曲线。</p><p>第二个优势是可重用性。可重用性是编程语言的基本特征，模块、函数、类，都是可重用的元素。并且，这种可重用的元素都是参数化的。在不同的场景中，可以通过调整参数来获得想要的功能。</p><p>所以，要开发一款优秀的CAD软件，我们需要充分吸收编程语言的技术。类似的领域还有建筑建模软件（BIM）、城市建模软件（CIM）等，现在很多公司的产品，都声称提供了低代码的数字城市平台，那这些产品也应该充分使用计算机语言的技术，并形成特定领域的DSL。</p><p>你看，我们现在分析了三个案例，看到了三个领域对计算机语言的要求。其实，这样的领域还有很多，并且它们都可以受益于领域编程语言。我希望你能受到这些例子的启发，看看在自己的领域内还有没有这样的需求，说不定你会也能做出一些开创性的事情。因为这样级别的工作，必须在掌握了我们这门课的知识体系以后，你才有能力驾驭。</p><p>上面这些采用了DSL的软件，基本都属于一些平台级的软件。那我们再围绕如何实现平台级的软件这个话题，展开讨论一下编程语言技术的作用，和你当前面对的机会。</p><h2>实现平台级的软件</h2><p>Lisp语言的重要推广者、《黑客与画家》的作者、创业孵化器Y Combinator的创始人保罗·格雷厄姆曾经说过一段话，大概就是说，每个软件演化到最后，都会内置一个Lisp语言的实现。</p><p>他的这段话，其实是说，任何软件，如果想覆盖尽量多的应用场景，都需要提供一定的编程能力。我举几个例子来说明一下这个观点：</p><ul>\n<li>为了更高效的管理很多服务器上的操作系统，搞运维的技术人员都会用Python来写脚本。这个时候，我们是在用脚本语言来扩展操作系统的功能；</li>\n<li>数据库系统之所以能够满足各种应用的需求，是因为它是通过SQL语言来访问数据库的功能；</li>\n<li>微软的各种应用产品，几乎都提供了二次开发的能力，这让你可以基于微软的产品形成各种不同领域的解决方案。比如，如果你能够熟练使用Excel里面的宏和编程技术，你可以完成很多的数据分析需求；</li>\n<li>三维游戏引擎提供编程功能，让你能够创建各种三维游戏场景；</li>\n<li>各种报表或BI工具，都提供了定义数据源、定义报表公式等功能，方便你设计各种报表；</li>\n<li>工作流或BPM系统，需要提供流程设计、公式定义和自定义逻辑的功能，来满足各种不同的流程场景了；</li>\n<li>对于一个API网关来说，需要提供一定的编程逻辑，来定义在什么情况下，把API访问路由到哪个微服务，或者进行熔断。</li>\n</ul><p>类似的例子还有很多。</p><p>如果你的软件只是为某个用户个性化定制的，只需要满足这一个客户的需求，那么你只要弄清楚需求，然后实现出来就行了。但如果你想让更多的用户使用你的软件，那该怎么办呢？</p><p>在少量情况下，你可以设计一套标准的软件，并让所有的用户都满意。比如，几乎所有的字处理软件的功能都差不多，你只需要购买一个License就行了，很少会提出个性化的需求。</p><p>但这样的通用软件是很少的。更多的情况下，特别是在企业应用领域，我们都需要对软件的标准功能做一定的调整，让它符合某个客户特定的需求。比如，你可能需要调整某些业务规则、某些流程、某些数据项，等等。</p><p>而国内大部分软件公司，目前都是通过修改源代码来满足这些个性化的需求。这就导致软件的实施成本很高，版本难以维护，这是很多应用软件开发商所处的困境。你在的公司，也可能存在这样的困境。</p><p>这个时候，如果你能把应用软件上升为平台，也就是在不修改原来的源代码的基础上，提供二次开发的能力，二次开发的部分由各个客户自行维护，才可以从根本上打破这种困境。从这个角度看，我们每个同学所在的领域，都存在着大量的潜在机会，采用这门课学习到的编程语言技术，你可以把你所在领域的软件，提升成一个平台级的软件。</p><p>还有最后一种情况，就是你本来就要开发平台级的软件，比如数据库系统、表单系统、报表系统、游戏引擎等，那么编程能力就更加是缺省的要求。</p><p>不管怎样，只要你想让你的软件变成平台级的软件，具备适应各种不同应用场景的能力，具备扩展功能的能力，你就需要采用这门课教给你的编程语言技术，对这些软件进行改造。在我看来，国内有太多软件产品需要进行这种提升了，这都是你可以施展身手的机会。</p><p>好了，聊完了领域编程语言和平台级软件以后，你还有没有其他机会来大显身手呢？有的，这就是实现通用编程语言这个终极大Boss。</p><h2>通用编程语言</h2><p>像Java、C、Go这些语言，能够用于很多领域，所以它们被叫做通用编程语言。到目前为止，我们国家还没有正式发布的、被广泛接受的通用编程语言。</p><p>不过信息灵通的同学可能也知道，我们多个大厂，其实都在内部酝酿和研发这样的语言。我本人也在参与某门语言的内测和评价工作。鉴于保密协议的约束，在这门语言没有正式发布前，我是不能谈论它的名称和技术细节的。</p><p>所以，如果你对实现通用编程语言很感兴趣的话，其实现在就有机会进入这些团队，贡献自己的一份力量。</p><p>如果你参与了这样的项目团队，那么你就可以选定一个具体的领域，深入研究我们这门课涉及的那些知识点。有人可能变成语法分析的专家，有人可能成为优化技术的专家，有人可能成为后端技术的专家，还有人可能会成为运行时方面的专家。</p><p>而我相信，<strong>正是你们这些未来的专家，将来必然会让中国的通用编程语言领域大放异彩！</strong></p><h2>写在最后</h2><p>这门课程的主体内容，到这里就正式结束了，不过我还会跟同学们保持联系。保持联系的方式有几个，一是<a href=\"https://gitee.com/richard-gong/PlayScript\">开源项目PlayScript</a>，一是计划不定期发布的几篇加餐，还有就是这门课的<a href=\"https://jinshuju.net/f/eMNUpx\">微信群</a>。</p><p>我会继续在编程语言的领域探索和实践，希望能够跟你多多交流。也希望你在前进的道路上，能够找到更多的志同道合的朋友，一起砥砺前行，创造出优秀的作品！</p><p>另外，我还给你准备了一份<a href=\"https://jinshuju.net/f/wDM5tl\">毕业问卷</a>，题目不多，希望你能在问卷里聊一聊你对这门课的看法。欢迎你点击下面的图片，用1～2分钟的时间填写一下。当然了，如果你对课程内容还有什么问题，也欢迎你在留言区或交流群继续提问，我会持续回复你的留言。</p><p><a href=\"https://jinshuju.net/f/wDM5tl\"><img src=\"https://static001.geekbang.org/resource/image/45/dc/45073828dd91c25127f6192dda9265dc.jpg?wh=1142x801\" alt=\"\"></a></p><p>我是宫文学，我们江湖再见。</p>","neighbors":{"left":{"article_title":"期末考试｜实现编程语言这些核心知识点，你掌握得咋样了？","id":447708},"right":[]}}]