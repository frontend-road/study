{"id":95715,"title":"22 | 进程空间管理：项目组还可以自行布置会议室","content":"<p>上两节，我们讲了内存管理的三个方面，虚拟内存空间的管理、物理内存的管理以及内存映射。你现在对进程内存空间的整体布局应该有了一个大致的了解。今天我们就来详细看看第一个方面，进程的虚拟内存空间是如何管理的。</p><p>32位系统和64位系统的内存布局有的地方相似，有的地方差别比较大，接下来介绍的时候，请你注意区分。好，我们现在正式开始！</p><h2>用户态和内核态的划分</h2><p>进程的虚拟地址空间，其实就是站在项目组的角度来看内存，所以我们就从task_struct出发来看。这里面有一个struct mm_struct结构来管理内存。</p><pre><code>struct mm_struct\t\t*mm;\n</code></pre><p>在struct mm_struct里面，有这样一个成员变量：</p><pre><code>unsigned long task_size;\t\t/* size of task vm space */\n</code></pre><p>我们之前讲过，整个虚拟内存空间要一分为二，一部分是用户态地址空间，一部分是内核态地址空间，那这两部分的分界线在哪里呢？这就要task_size来定义。</p><p>对于32位的系统，内核里面是这样定义TASK_SIZE的：</p><pre><code>#ifdef CONFIG_X86_32\n/*\n * User space process size: 3GB (default).\n */\n#define TASK_SIZE\t\tPAGE_OFFSET\n#define TASK_SIZE_MAX\t\tTASK_SIZE\n/*\nconfig PAGE_OFFSET\n        hex\n        default 0xC0000000\n        depends on X86_32\n*/\n#else\n/*\n * User space process size. 47bits minus one guard page.\n*/\n#define TASK_SIZE_MAX\t((1UL &lt;&lt; 47) - PAGE_SIZE)\n#define TASK_SIZE\t\t(test_thread_flag(TIF_ADDR32) ? \\\n\t\t\t\t\tIA32_PAGE_OFFSET : TASK_SIZE_MAX)\n......\n</code></pre><p>当执行一个新的进程的时候，会做以下的设置：</p><pre><code>current-&gt;mm-&gt;task_size = TASK_SIZE;\n</code></pre><p>对于32位系统，最大能够寻址2^32=4G，其中用户态虚拟地址空间是3G，内核态是1G。</p><p>对于64位系统，虚拟地址只使用了48位。就像代码里面写的一样，1左移了47位，就相当于48位地址空间一半的位置，0x0000800000000000，然后减去一个页，就是0x00007FFFFFFFF000，共128T。同样，内核空间也是128T。内核空间和用户空间之间隔着很大的空隙，以此来进行隔离。</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/89/59/89723dc967b59f6f49419082f6ab7659.jpg?wh=2613*960\" alt=\"\"></p><h2>用户态布局</h2><p>我们先来看用户态虚拟空间的布局。</p><p>之前我们讲了用户态虚拟空间里面有几类数据，例如代码、全局变量、堆、栈、内存映射区等。在struct mm_struct里面，有下面这些变量定义了这些区域的统计信息和位置。</p><pre><code>unsigned long mmap_base;\t/* base of mmap area */\nunsigned long total_vm;\t\t/* Total pages mapped */\nunsigned long locked_vm;\t/* Pages that have PG_mlocked set */\nunsigned long pinned_vm;\t/* Refcount permanently increased */\nunsigned long data_vm;\t\t/* VM_WRITE &amp; ~VM_SHARED &amp; ~VM_STACK */\nunsigned long exec_vm;\t\t/* VM_EXEC &amp; ~VM_WRITE &amp; ~VM_STACK */\nunsigned long stack_vm;\t\t/* VM_STACK */\nunsigned long start_code, end_code, start_data, end_data;\nunsigned long start_brk, brk, start_stack;\nunsigned long arg_start, arg_end, env_start, env_end;\n</code></pre><p>其中，total_vm是总共映射的页的数目。我们知道，这么大的虚拟地址空间，不可能都有真实内存对应，所以这里是映射的数目。当内存吃紧的时候，有些页可以换出到硬盘上，有的页因为比较重要，不能换出。locked_vm就是被锁定不能换出，pinned_vm是不能换出，也不能移动。</p><p>data_vm是存放数据的页的数目，exec_vm是存放可执行文件的页的数目，stack_vm是栈所占的页的数目。</p><p>start_code和end_code表示可执行代码的开始和结束位置，start_data和end_data表示已初始化数据的开始位置和结束位置。</p><p>start_brk是堆的起始位置，brk是堆当前的结束位置。前面咱们讲过malloc申请一小块内存的话，就是通过改变brk位置实现的。</p><p>start_stack是栈的起始位置，栈的结束位置在寄存器的栈顶指针中。</p><p>arg_start和arg_end是参数列表的位置， env_start和env_end是环境变量的位置。它们都位于栈中最高地址的地方。</p><p>mmap_base表示虚拟地址空间中用于内存映射的起始地址。一般情况下，这个空间是从高地址到低地址增长的。前面咱们讲malloc申请一大块内存的时候，就是通过mmap在这里映射一块区域到物理内存。咱们加载动态链接库so文件，也是在这个区域里面，映射一块区域到so文件。</p><p>这下所有用户态的区域的位置基本上都描述清楚了。整个布局就像下面这张图这样。虽然32位和64位的空间相差很大，但是区域的类别和布局是相似的。</p><p><img src=\"https://static001.geekbang.org/resource/image/f8/b1/f83b8d49b4e74c0e255b5735044c1eb1.jpg?wh=1731*1972\" alt=\"\"></p><p>除了位置信息之外，struct mm_struct里面还专门有一个结构vm_area_struct，来描述这些区域的属性。</p><pre><code>struct vm_area_struct *mmap;\t\t/* list of VMAs */\nstruct rb_root mm_rb;\n</code></pre><p>这里面一个是单链表，用于将这些区域串起来。另外还有一个红黑树。又是这个数据结构，在进程调度的时候我们用的也是红黑树。它的好处就是查找和修改都很快。这里用红黑树，就是为了快速查找一个内存区域，并在需要改变的时候，能够快速修改。</p><pre><code>struct vm_area_struct {\n\t/* The first cache line has the info for VMA tree walking. */\n\tunsigned long vm_start;\t\t/* Our start address within vm_mm. */\n\tunsigned long vm_end;\t\t/* The first byte after our end address within vm_mm. */\n\t/* linked list of VM areas per task, sorted by address */\n\tstruct vm_area_struct *vm_next, *vm_prev;\n\tstruct rb_node vm_rb;\n\tstruct mm_struct *vm_mm;\t/* The address space we belong to. */\n\tstruct list_head anon_vma_chain; /* Serialized by mmap_sem &amp;\n\t\t\t\t\t  * page_table_lock */\n\tstruct anon_vma *anon_vma;\t/* Serialized by page_table_lock */\n\t/* Function pointers to deal with this struct. */\n\tconst struct vm_operations_struct *vm_ops;\n\tstruct file * vm_file;\t\t/* File we map to (can be NULL). */\n\tvoid * vm_private_data;\t\t/* was vm_pte (shared mem) */\n} __randomize_layout;\n</code></pre><p>vm_start和vm_end指定了该区域在用户空间中的起始和结束地址。vm_next和vm_prev将这个区域串在链表上。vm_rb将这个区域放在红黑树上。vm_ops里面是对这个内存区域可以做的操作的定义。</p><p>虚拟内存区域可以映射到物理内存，也可以映射到文件，映射到物理内存的时候称为匿名映射，anon_vma中，anoy就是anonymous，匿名的意思，映射到文件就需要有vm_file指定被映射的文件。</p><p>那这些vm_area_struct是如何和上面的内存区域关联的呢？</p><p>这个事情是在load_elf_binary里面实现的。没错，就是它。加载内核的是它，启动第一个用户态进程init的是它，fork完了以后，调用exec运行一个二进制程序的也是它。</p><p>当exec运行一个二进制程序的时候，除了解析ELF的格式之外，另外一个重要的事情就是建立内存映射。</p><pre><code>static int load_elf_binary(struct linux_binprm *bprm)\n{\n......\n  setup_new_exec(bprm);\n......\n  retval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),\n\t\t\t\t executable_stack);\n......\n  error = elf_map(bprm-&gt;file, load_bias + vaddr, elf_ppnt,\n\t\t\t\telf_prot, elf_flags, total_size);\n......\n  retval = set_brk(elf_bss, elf_brk, bss_prot);\n......\n  elf_entry = load_elf_interp(&amp;loc-&gt;interp_elf_ex,\n\t\t\t\t\t    interpreter,\n\t\t\t\t\t    &amp;interp_map_addr,\n\t\t\t\t\t    load_bias, interp_elf_phdata);\n......\n  current-&gt;mm-&gt;end_code = end_code;\n  current-&gt;mm-&gt;start_code = start_code;\n  current-&gt;mm-&gt;start_data = start_data;\n  current-&gt;mm-&gt;end_data = end_data;\n  current-&gt;mm-&gt;start_stack = bprm-&gt;p;\n......\n}\n</code></pre><p>load_elf_binary会完成以下的事情：</p><ul>\n<li>\n<p>调用setup_new_exec，设置内存映射区mmap_base；</p>\n</li>\n<li>\n<p>调用setup_arg_pages，设置栈的vm_area_struct，这里面设置了mm-&gt;arg_start是指向栈底的，current-&gt;mm-&gt;start_stack就是栈底；</p>\n</li>\n<li>\n<p>elf_map会将ELF文件中的代码部分映射到内存中来；</p>\n</li>\n<li>\n<p>set_brk设置了堆的vm_area_struct，这里面设置了current-&gt;mm-&gt;start_brk = current-&gt;mm-&gt;brk，也即堆里面还是空的；</p>\n</li>\n<li>\n<p>load_elf_interp将依赖的so映射到内存中的内存映射区域。</p>\n</li>\n</ul><p>最终就形成下面这个内存映射图。</p><p><img src=\"https://static001.geekbang.org/resource/image/7a/4c/7af58012466c7d006511a7e16143314c.jpeg?wh=3406*2743\" alt=\"\"></p><p>映射完毕后，什么情况下会修改呢？</p><p>第一种情况是函数的调用，涉及函数栈的改变，主要是改变栈顶指针。</p><p>第二种情况是通过malloc申请一个堆内的空间，当然底层要么执行brk，要么执行mmap。关于内存映射的部分，我们后面的章节讲，这里我们重点看一下brk是怎么做的。</p><p>brk系统调用实现的入口是sys_brk函数，就像下面代码定义的一样。</p><pre><code>SYSCALL_DEFINE1(brk, unsigned long, brk)\n{\n\tunsigned long retval;\n\tunsigned long newbrk, oldbrk;\n\tstruct mm_struct *mm = current-&gt;mm;\n\tstruct vm_area_struct *next;\n......\n\tnewbrk = PAGE_ALIGN(brk);\n\toldbrk = PAGE_ALIGN(mm-&gt;brk);\n\tif (oldbrk == newbrk)\n\t\tgoto set_brk;\n\n\n\t/* Always allow shrinking brk. */\n\tif (brk &lt;= mm-&gt;brk) {\n\t\tif (!do_munmap(mm, newbrk, oldbrk-newbrk, &amp;uf))\n\t\t\tgoto set_brk;\n\t\tgoto out;\n\t}\n\n\n\t/* Check against existing mmap mappings. */\n\tnext = find_vma(mm, oldbrk);\n\tif (next &amp;&amp; newbrk + PAGE_SIZE &gt; vm_start_gap(next))\n\t\tgoto out;\n\n\n\t/* Ok, looks good - let it rip. */\n\tif (do_brk(oldbrk, newbrk-oldbrk, &amp;uf) &lt; 0)\n\t\tgoto out;\n\n\nset_brk:\n\tmm-&gt;brk = brk;\n......\n\treturn brk;\nout:\n\tretval = mm-&gt;brk;\n\treturn retval\n</code></pre><p>前面我们讲过了，堆是从低地址向高地址增长的，sys_brk函数的参数brk是新的堆顶位置，而当前的mm-&gt;brk是原来堆顶的位置。</p><p>首先要做的第一个事情，将原来的堆顶和现在的堆顶，都按照页对齐地址，然后比较大小。如果两者相同，说明这次增加的堆的量很小，还在一个页里面，不需要另行分配页，直接跳到set_brk那里，设置mm-&gt;brk为新的brk就可以了。</p><p>如果发现新旧堆顶不在一个页里面，麻烦了，这下要跨页了。如果发现新堆顶小于旧堆顶，这说明不是新分配内存了，而是释放内存了，释放的还不小，至少释放了一页，于是调用do_munmap将这一页的内存映射去掉。</p><p>如果堆将要扩大，就要调用find_vma。如果打开这个函数，看到的是对红黑树的查找，找到的是原堆顶所在的vm_area_struct的下一个vm_area_struct，看当前的堆顶和下一个vm_area_struct之间还能不能分配一个完整的页。如果不能，没办法只好直接退出返回，内存空间都被占满了。</p><p>如果还有空间，就调用do_brk进一步分配堆空间，从旧堆顶开始，分配计算出的新旧堆顶之间的页数。</p><pre><code>static int do_brk(unsigned long addr, unsigned long len, struct list_head *uf)\n{\n\treturn do_brk_flags(addr, len, 0, uf);\n}\n\n\nstatic int do_brk_flags(unsigned long addr, unsigned long request, unsigned long flags, struct list_head *uf)\n{\n\tstruct mm_struct *mm = current-&gt;mm;\n\tstruct vm_area_struct *vma, *prev;\n\tunsigned long len;\n\tstruct rb_node **rb_link, *rb_parent;\n\tpgoff_t pgoff = addr &gt;&gt; PAGE_SHIFT;\n\tint error;\n\n\n\tlen = PAGE_ALIGN(request);\n......\n\tfind_vma_links(mm, addr, addr + len, &amp;prev, &amp;rb_link,\n\t\t\t      &amp;rb_parent);\n......\n\tvma = vma_merge(mm, prev, addr, addr + len, flags,\n\t\t\tNULL, NULL, pgoff, NULL, NULL_VM_UFFD_CTX);\n\tif (vma)\n\t\tgoto out;\n......\n\tvma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);\n\tINIT_LIST_HEAD(&amp;vma-&gt;anon_vma_chain);\n\tvma-&gt;vm_mm = mm;\n\tvma-&gt;vm_start = addr;\n\tvma-&gt;vm_end = addr + len;\n\tvma-&gt;vm_pgoff = pgoff;\n\tvma-&gt;vm_flags = flags;\n\tvma-&gt;vm_page_prot = vm_get_page_prot(flags);\n\tvma_link(mm, vma, prev, rb_link, rb_parent);\nout:\n\tperf_event_mmap(vma);\n\tmm-&gt;total_vm += len &gt;&gt; PAGE_SHIFT;\n\tmm-&gt;data_vm += len &gt;&gt; PAGE_SHIFT;\n\tif (flags &amp; VM_LOCKED)\n\t\tmm-&gt;locked_vm += (len &gt;&gt; PAGE_SHIFT);\n\tvma-&gt;vm_flags |= VM_SOFTDIRTY;\n\treturn 0;\n</code></pre><p>在do_brk中，调用find_vma_links找到将来的vm_area_struct节点在红黑树的位置，找到它的父节点、前序节点。接下来调用vma_merge，看这个新节点是否能够和现有树中的节点合并。如果地址是连着的，能够合并，则不用创建新的vm_area_struct了，直接跳到out，更新统计值即可；如果不能合并，则创建新的vm_area_struct，既加到anon_vma_chain链表中，也加到红黑树中。</p><h2>内核态的布局</h2><p>用户态虚拟空间分析完毕，接下来我们分析内核态虚拟空间。</p><p>内核态的虚拟空间和某一个进程没有关系，所有进程通过系统调用进入到内核之后，看到的虚拟地址空间都是一样的。</p><p>这里强调一下，千万别以为到了内核里面，咱们就会直接使用物理内存地址了，想当然地认为下面讨论的都是物理内存地址，不是的，这里讨论的还是虚拟内存地址，但是由于内核总是涉及管理物理内存，因而总是隐隐约约发生关系，所以这里必须思路清晰，分清楚物理内存地址和虚拟内存地址。</p><p>在内核态，32位和64位的布局差别比较大，主要是因为32位内核态空间太小了。</p><p>我们来看32位的内核态的布局。</p><p><img src=\"https://static001.geekbang.org/resource/image/83/04/83a6511faf802014fbc2c02afc397a04.jpg?wh=1947*1323\" alt=\"\"></p><p>32位的内核态虚拟地址空间一共就1G，占绝大部分的前896M，我们称为<strong>直接映射区</strong>。</p><p>所谓的直接映射区，就是这一块空间是连续的，和物理内存是非常简单的映射关系，其实就是虚拟内存地址减去3G，就得到物理内存的位置。</p><p>在内核里面，有两个宏：</p><ul>\n<li>\n<p>__pa(vaddr) 返回与虚拟地址 vaddr 相关的物理地址；</p>\n</li>\n<li>\n<p>__va(paddr) 则计算出对应于物理地址 paddr 的虚拟地址。</p>\n</li>\n</ul><pre><code>    #define __va(x)\t\t\t((void *)((unsigned long)(x)+PAGE_OFFSET))\n    #define __pa(x)\t\t__phys_addr((unsigned long)(x))\n    #define __phys_addr(x)\t\t__phys_addr_nodebug(x)\n    #define __phys_addr_nodebug(x)\t((x) - PAGE_OFFSET)\n\n</code></pre><p>但是你要注意，这里虚拟地址和物理地址发生了关联关系，在物理内存的开始的896M的空间，会被直接映射到3G至3G+896M的虚拟地址，这样容易给你一种感觉，这些内存访问起来和物理内存差不多，别这样想，在大部分情况下，对于这一段内存的访问，在内核中，还是会使用虚拟地址的，并且将来也会为这一段空间建设页表，对这段地址的访问也会走上一节我们讲的分页地址的流程，只不过页表里面比较简单，是直接的一一对应而已。</p><p>这896M还需要仔细分解。在系统启动的时候，物理内存的前1M已经被占用了，从1M开始加载内核代码段，然后就是内核的全局变量、BSS等，也是ELF里面涵盖的。这样内核的代码段，全局变量，BSS也就会被映射到3G后的虚拟地址空间里面。具体的物理内存布局可以查看/proc/iomem。</p><p>在内核运行的过程中，如果碰到系统调用创建进程，会创建task_struct这样的实例，内核的进程管理代码会将实例创建在3G至3G+896M的虚拟空间中，当然也会被放在物理内存里面的前896M里面，相应的页表也会被创建。</p><p>在内核运行的过程中，会涉及内核栈的分配，内核的进程管理的代码会将内核栈创建在3G至3G+896M的虚拟空间中，当然也就会被放在物理内存里面的前896M里面，相应的页表也会被创建。</p><p>896M这个值在内核中被定义为high_memory，在此之上常称为“高端内存”。这是个很笼统的说法，到底是虚拟内存的3G+896M以上的是高端内存，还是物理内存896M以上的是高端内存呢？</p><p>这里仍然需要辨析一下，高端内存是物理内存的概念。它仅仅是内核中的内存管理模块看待物理内存的时候的概念。前面我们也说过，在内核中，除了内存管理模块直接操作物理地址之外，内核的其他模块，仍然要操作虚拟地址，而虚拟地址是需要内存管理模块分配和映射好的。</p><p>假设咱们的电脑有2G内存，现在如果内核的其他模块想要访问物理内存1.5G的地方，应该怎么办呢？如果你觉得，我有32位的总线，访问个2G还不小菜一碟，这就错了。</p><p>首先，你不能使用物理地址。你需要使用内存管理模块给你分配的虚拟地址，但是虚拟地址的0到3G已经被用户态进程占用去了，你作为内核不能使用。因为你写1.5G的虚拟内存位置，一方面你不知道应该根据哪个进程的页表进行映射；另一方面，就算映射了也不是你真正想访问的物理内存的地方，所以你发现你作为内核，能够使用的虚拟内存地址，只剩下1G减去896M的空间了。</p><p>于是，我们可以将剩下的虚拟内存地址分成下面这几个部分。</p><ul>\n<li>\n<p>在896M到VMALLOC_START之间有8M的空间。</p>\n</li>\n<li>\n<p>VMALLOC_START到VMALLOC_END之间称为内核动态映射空间，也即内核想像用户态进程一样malloc申请内存，在内核里面可以使用vmalloc。假设物理内存里面，896M到1.5G之间已经被用户态进程占用了，并且映射关系放在了进程的页表中，内核vmalloc的时候，只能从分配物理内存1.5G开始，就需要使用这一段的虚拟地址进行映射，映射关系放在专门给内核自己用的页表里面。</p>\n</li>\n<li>\n<p>PKMAP_BASE到FIXADDR_START的空间称为持久内核映射。使用alloc_pages()函数的时候，在物理内存的高端内存得到struct page结构，可以调用kmap将其映射到这个区域。</p>\n</li>\n<li>\n<p>FIXADDR_START到FIXADDR_TOP(0xFFFF F000)的空间，称为固定映射区域，主要用于满足特殊需求。</p>\n</li>\n<li>\n<p>在最后一个区域可以通过kmap_atomic实现临时内核映射。假设用户态的进程要映射一个文件到内存中，先要映射用户态进程空间的一段虚拟地址到物理内存，然后将文件内容写入这个物理内存供用户态进程访问。给用户态进程分配物理内存页可以通过alloc_pages()，分配完毕后，按说将用户态进程虚拟地址和物理内存的映射关系放在用户态进程的页表中，就完事大吉了。这个时候，用户态进程可以通过用户态的虚拟地址，也即0至3G的部分，经过页表映射后访问物理内存，并不需要内核态的虚拟地址里面也划出一块来，映射到这个物理内存页。但是如果要把文件内容写入物理内存，这件事情要内核来干了，这就只好通过kmap_atomic做一个临时映射，写入物理内存完毕后，再kunmap_atomic来解映射即可。</p>\n</li>\n</ul><p>32位的内核态布局我们看完了，接下来我们再来看64位的内核布局。</p><p>其实64位的内核布局反而简单，因为虚拟空间实在是太大了，根本不需要所谓的高端内存，因为内核是128T，根本不可能有物理内存超过这个值。</p><p>64位的内存布局如图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/7e/f6/7eaf620768c62ff53e5ea2b11b4940f6.jpg?wh=2448*2557\" alt=\"\"></p><p>64位的内核主要包含以下几个部分。</p><p>从0xffff800000000000开始就是内核的部分，只不过一开始有8T的空档区域。</p><p>从__PAGE_OFFSET_BASE(0xffff880000000000)开始的64T的虚拟地址空间是直接映射区域，也就是减去PAGE_OFFSET就是物理地址。虚拟地址和物理地址之间的映射在大部分情况下还是会通过建立页表的方式进行映射。</p><p>从VMALLOC_START（0xffffc90000000000）开始到VMALLOC_END（0xffffe90000000000）的32T的空间是给vmalloc的。</p><p>从VMEMMAP_START（0xffffea0000000000）开始的1T空间用于存放物理页面的描述结构struct page的。</p><p>从__START_KERNEL_map（0xffffffff80000000）开始的512M用于存放内核代码段、全局变量、BSS等。这里对应到物理内存开始的位置，减去__START_KERNEL_map就能得到物理内存的地址。这里和直接映射区有点像，但是不矛盾，因为直接映射区之前有8T的空当区域，早就过了内核代码在物理内存中加载的位置。</p><p>到这里内核中虚拟空间的布局就介绍完了。</p><h2>总结时刻</h2><p>还记得咱们上一节咱们收集项目组需求的时候，我们知道一个进程要运行起来需要以下的内存结构。</p><p>用户态：</p><ul>\n<li>\n<p>代码段、全局变量、BSS</p>\n</li>\n<li>\n<p>函数栈</p>\n</li>\n<li>\n<p>堆</p>\n</li>\n<li>\n<p>内存映射区</p>\n</li>\n</ul><p>内核态：</p><ul>\n<li>\n<p>内核的代码、全局变量、BSS</p>\n</li>\n<li>\n<p>内核数据结构例如task_struct</p>\n</li>\n<li>\n<p>内核栈</p>\n</li>\n<li>\n<p>内核中动态分配的内存</p>\n</li>\n</ul><p>现在这些是不是已经都有了着落？</p><p>我画了一个图，总结一下进程运行状态在32位下对应关系。</p><p><img src=\"https://static001.geekbang.org/resource/image/28/e8/2861968d1907bc314b82c34c221aace8.jpeg?wh=3256*3571\" alt=\"\"></p><p>对于64位的对应关系，只是稍有区别，我这里也画了一个图，方便你对比理解。</p><p><img src=\"https://static001.geekbang.org/resource/image/2a/ce/2ad275ff8fdf6aafced4a7aeea4ca0ce.jpeg?wh=3256*3571\" alt=\"\"></p><h2>课堂练习</h2><p>请通过命令行工具查看进程虚拟内存的布局和物理内存的布局，对照着这一节讲的内容，看一下各部分的位置。</p><p>欢迎留言和我分享你的疑惑和见解，也欢迎你收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习、进步。</p><p><img src=\"https://static001.geekbang.org/resource/image/8c/37/8c0a95fa07a8b9a1abfd394479bdd637.jpg?wh=1110*659\" alt=\"\"></p>","comments":[{"had_liked":false,"id":95465,"user_name":"有铭","can_delete":false,"product_type":"c1","uid":1046302,"ip_address":"","ucode":"2C7CB36CA5C04C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/3XbCueYYVWTiclv8T5tFpwiblOxLphvSZxL4ujMdqVMibZnOiaFK2C5nKRGv407iaAsrI0CDICYVQJtiaITzkjfjbvrQ/132","comment_is_top":false,"comment_ctime":1558060251,"is_pvip":false,"replies":[{"id":"34091","content":"是的，内核对于所有的进程，不但物理内存只有一份，虚拟内存也是只有一份。也就是说A进程用户态访问x虚拟地址和B进程用户态访问x虚拟地址是不同的虚拟地址，也即A进程用户态在x虚拟地址里面放了一个数值w，B进程用户态的x虚拟地址看不到w，对应的也是不同的物理地址。A进程内核态访问的y虚拟地址，和B进程内核态访问的y虚拟地址，是通一个虚拟地址，也对应相同的物理地址。也即A进程内核态在y虚拟地址方一个数值n，B进程的内核态如果能够访问y虚拟地址的话，也能看到n","user_name":"作者回复","comment_id":95465,"uid":"1001590","ip_address":"","utype":1,"ctime":1558067575,"user_name_real":"刘超@网易云"}],"discussion_count":6,"race_medal":0,"score":"199126555867","product_id":100024701,"comment_content":"老师，之前你说过，内核态对于所有进程都是相同的，那时我就问过，这话的意思是不是说内核态内存在真实的物理内存里其实只有1份？","like_count":47,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450467,"discussion_content":"是的，内核对于所有的进程，不但物理内存只有一份，虚拟内存也是只有一份。也就是说A进程用户态访问x虚拟地址和B进程用户态访问x虚拟地址是不同的虚拟地址，也即A进程用户态在x虚拟地址里面放了一个数值w，B进程用户态的x虚拟地址看不到w，对应的也是不同的物理地址。A进程内核态访问的y虚拟地址，和B进程内核态访问的y虚拟地址，是通一个虚拟地址，也对应相同的物理地址。也即A进程内核态在y虚拟地址方一个数值n，B进程的内核态如果能够访问y虚拟地址的话，也能看到n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558067575,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1161325,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b8/6d/aeb34336.jpg","nickname":"黄文昊","note":"","ucode":"FC5F74FB91C8CB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":132328,"discussion_content":"所以内核态也可以认为是进程间沟通的媒介","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1578898031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066409,"avatar":"https://static001.geekbang.org/account/avatar/00/10/45/a9/3d48d6a2.jpg","nickname":"Lorry","note":"","ucode":"BD4754D0F1D786","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389802,"discussion_content":"为什么内核态共享内存，但是用户态要按照进程进行隔离呢？\n因为安全；进程是用户不受限完成的，比如如果可以方便访问，那么太危险了；但是作为内核态是由一个可控团队完成，实现的功能都是可控的，所以可以不受限，于是可以所有的内核task共享内存资源","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1629435006,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1450864,"avatar":"https://static001.geekbang.org/account/avatar/00/16/23/70/91ac1a08.jpg","nickname":"wateruc","note":"","ucode":"78301BFA7C6088","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584895,"discussion_content":"这个内核态到底指的是什么呢？切换到内核态到底是谁在被cpu执行？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661214529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1131300,"avatar":"https://static001.geekbang.org/account/avatar/00/11/43/24/3f9f7c70.jpg","nickname":"zixuan","note":"","ucode":"C72920DD05B074","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1450864,"avatar":"https://static001.geekbang.org/account/avatar/00/16/23/70/91ac1a08.jpg","nickname":"wateruc","note":"","ucode":"78301BFA7C6088","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589372,"discussion_content":"内核代码就一份，每个cpu都各跑各的。内核态也就一个，所有进程陷入的都是同一个&#34;内核态&#34;。切换到内核态是内核代码逻辑在被cpu执行，由外部干预（硬件中断、缺页异常等）或主动陷入软中断（特殊指令）触发。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664776760,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":584895,"ip_address":"广东"},"score":589372,"extra":""}]},{"author":{"id":1015918,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/80/6e/7f78292e.jpg","nickname":"无","note":"","ucode":"CF9F79815606F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536340,"discussion_content":"&#39;内核对于所有的进程，不但物理内存只有一份，虚拟内存也是只有一份。&#39;这样对于现代计算机,多进程,多外设,32位肯定不够用哎","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638762709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98583,"user_name":"Rainbow","can_delete":false,"product_type":"c1","uid":1134254,"ip_address":"","ucode":"EB858CD1DEDE78","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/ae/db875ccf.jpg","comment_is_top":false,"comment_ctime":1559034486,"is_pvip":false,"replies":[{"id":"35372","content":"多看几遍哈，重点关注机制和流程","user_name":"作者回复","comment_id":98583,"uid":"1001590","ip_address":"","utype":1,"ctime":1559100207,"user_name_real":"刘超@网易云"}],"discussion_count":7,"race_medal":0,"score":"177652693622","product_id":100024701,"comment_content":"越来越看不懂了，有什么好办法吗？","like_count":42,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451744,"discussion_content":"多看几遍哈，重点关注机制和流程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559100207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1339820,"avatar":"https://static001.geekbang.org/account/avatar/00/14/71/ac/8295e3e7.jpg","nickname":"书忆江南","note":"","ucode":"90776A7CE06D66","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":168402,"discussion_content":"强烈建议看过极客时间《深入浅出计算机组成原理》之后再来看这个课，能大大降低理解门槛","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1581579102,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1655940,"avatar":"https://static001.geekbang.org/account/avatar/00/19/44/84/4da14994.jpg","nickname":"呆瓜","note":"","ucode":"C98C7B224D0640","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1339820,"avatar":"https://static001.geekbang.org/account/avatar/00/14/71/ac/8295e3e7.jpg","nickname":"书忆江南","note":"","ucode":"90776A7CE06D66","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261869,"discussion_content":"我下篇要是再看不懂也要去先学下你推荐的课程了T_T","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589017051,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":168402,"ip_address":""},"score":261869,"extra":""}]},{"author":{"id":1510495,"avatar":"https://static001.geekbang.org/account/avatar/00/17/0c/5f/4cbcbfb9.jpg","nickname":"hello","note":"","ucode":"C6FC61A90F202B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6851,"discussion_content":"没看懂的回过去多看几遍的确可以的","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1567141128,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1102362,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d2/1a/19365924.jpg","nickname":"爱上飞飞的面码","note":"","ucode":"3399E3DC30776E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7280,"discussion_content":"我现在的策略是细节能看懂就看看不懂放弃熏熏。课后总结再认真看看，把握主流程。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1567473543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3050087,"avatar":"","nickname":"Geek_2d8b2b","note":"","ucode":"1DD98F61179887","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582085,"discussion_content":"给后面的同学一个建议吧，如果你感觉越来越看不懂，一定要把前面的课程先消化好，再继续看，这种硬核课程不能一味的图快，理解记忆才是根本","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1659192817,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江西"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1463873,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIO2hQgGGq9htCBJNNAMH33VFvCBicwOjwCVXTg3WxYBkI3of3ibfQWib4ibF8m2y9vORT5mSibuqw5LNA/132","nickname":"带头大哥","note":"","ucode":"DA49D606C1E6DF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":240581,"discussion_content":"看不懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587376110,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96846,"user_name":"why","can_delete":false,"product_type":"c1","uid":1012937,"ip_address":"","ucode":"C9E796E53F6F5E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/74/c9/d3439ca4.jpg","comment_is_top":false,"comment_ctime":1558519267,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"100342767075","product_id":100024701,"comment_content":"- 内存管理信息在 task_struct 的 mm_struct 中<br>- task_size 指定用户态虚拟地址大小<br>    - 32 位系统：3G 用户态, 1G 内核态<br>    - 64 位系统(只利用 48 bit 地址): 128T 用户态; 128T 内核态<br>- 用户态地址空间布局和管理<br>    - mm_struct 中有映射页的统计信息(总页数, 锁定页数, 数据&#47;代码&#47;栈映射页数等)以及各区域地址<br>    - 有 vm_area_struct 描述各个区域(代码&#47;数据&#47;栈等)的属性(包含起始&#47;终止地址, 可做的操作等), 通过链表和红黑树管理<br>    - 在 load_elf_bianry 时做 vm_area_struct 与各区域的映射, 并将 elf 映射到内存, 将依赖 so 添加到内存映射<br>    - 在函数调用时会修改栈顶指针; malloc 分配内存时会修改对应的区域信息(调用 brk 堆; 或调用 mmap 内存映射)<br>    - brk 判断是否需要分配新页, 并做对应操作; 需要分配新页时需要判断能否与其他 vm_area_struct 合并<br>- 内核地址空间布局和管理<br>    - 所有进程看到的内核虚拟地址空间是同一个<br>    - 32 位系统, 前 896MB 为直接映射区(虚拟地址 - 3G = 物理地址)<br>        - 直接映射区也需要建立页表, 通过虚拟地址访问(除了内存管理模块)<br>        - 直接映射区组成: 1MB 启动时占用; 然后是内核代码&#47;全局变量&#47;BSS等,即 内核 ELF文件内容; 进程 task_struct 即内核栈也在其中<br>        - 896MB 也称为高端内存(指物理内存)<br>        - 剩余虚拟空间组成: 8MB 空余; 内核动态映射空间(动态分配内存, 映射放在内核页表中); 持久内存映射(储存物理页信息); 固定内存映射; 临时内存映射(例如为进程映射文件时使用)<br>    - 64 位系统: 8T 空余; 64T 直接映射区域; 32T(动态映射); 1T(物理页描述结构 struct page); 512MB(内核代码, 也采用直接映射)","like_count":24,"discussions":[{"author":{"id":1655940,"avatar":"https://static001.geekbang.org/account/avatar/00/19/44/84/4da14994.jpg","nickname":"呆瓜","note":"","ucode":"C98C7B224D0640","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261031,"discussion_content":"老哥你稳得很,每篇都能占到评论区C位!","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588931904,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1025474,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a5/c2/41fa26df.jpg","nickname":"楊威","note":"","ucode":"8BA77716CE8179","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219070,"discussion_content":"内存管理模块是说的2号线程吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585730986,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1287774,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a6/5e/b05254a6.jpg","nickname":"Mhy","note":"","ucode":"DE19BCAD1F856E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1025474,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a5/c2/41fa26df.jpg","nickname":"楊威","note":"","ucode":"8BA77716CE8179","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":260821,"discussion_content":"内存管理单元（MMU）：将虚拟内存映射成物理内存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588904976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":219070,"ip_address":""},"score":260821,"extra":""}]}]},{"had_liked":false,"id":205554,"user_name":"garlic","can_delete":false,"product_type":"c1","uid":1019579,"ip_address":"","ucode":"FEB147EDB5774E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/bb/c039dc11.jpg","comment_is_top":false,"comment_ctime":1586672264,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"57421247112","product_id":100024701,"comment_content":"可以通过以下文件查看虚拟内存与物理内存映射关系<br>- `&#47;proc&#47;pid&#47;pagemap`<br>- `&#47;proc&#47;kpagecount`<br>- `&#47;proc&#47;kpageflags`<br>- `&#47;proc&#47;kpagecgroup`<br>笔记<br>https:&#47;&#47;garlicspace.com&#47;2020&#47;04&#47;12&#47;linux%e8%bf%9b%e7%a8%8b%e5%86%85%e5%ad%98%e5%b8%83%e5%b1%80%e5%8f%8a%e6%98%a0%e5%b0%84%e4%bf%a1%e6%81%af&#47;","like_count":14},{"had_liked":false,"id":124002,"user_name":"tuyu","can_delete":false,"product_type":"c1","uid":1448863,"ip_address":"","ucode":"B235325B541408","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/BIRpwViaN51yynIeFonD7QRlwDCVtKibrG956NTxzEqibOZZVjhMMgibOPmd3VicfYxpknZsic1oJq8KicZvXkmmiajuQg/132","comment_is_top":false,"comment_ctime":1565790015,"is_pvip":false,"replies":[{"id":"46283","content":"是的，重点关注数据结构和流程，代码作为参考","user_name":"作者回复","comment_id":124002,"uid":"1001590","ip_address":"","utype":1,"ctime":1566280976,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"40220495679","product_id":100024701,"comment_content":"看到这里, 我觉得我们不能太关注code问题, 应该多关注数据结构和数据结构的关系, 这样就有目标了","like_count":9,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462952,"discussion_content":"是的，重点关注数据结构和流程，代码作为参考","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566280976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":286529,"user_name":"侧耳倾听","can_delete":false,"product_type":"c1","uid":1512642,"ip_address":"","ucode":"5BF2A2440B54F0","user_header":"https://static001.geekbang.org/account/avatar/00/17/14/c2/46ebe3a0.jpg","comment_is_top":false,"comment_ctime":1617358311,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"35977096679","product_id":100024701,"comment_content":"看了评论觉得大家有些绕进去了，首先，要清晰的理解虚拟地址和物理地址的不同，虚拟地址只是起到一个标记作用，它不一一对应物理地址，对每个进程都是公平的4G虚拟空间，但是物理地址是进程共享的，这就不可避免的会有多个进程映射同一内存页，内存管理的作用一是对虚拟地址和物理地址进行映射，同时，如果没有空闲内存页的情况下会进行换页，先把当前页的数据写到磁盘上，然后把该页分配给进程，如果你的内存小，就会导致频繁的换进换出，进程就会卡顿。","like_count":9},{"had_liked":false,"id":102999,"user_name":"G.S.K","can_delete":false,"product_type":"c1","uid":1222966,"ip_address":"","ucode":"88217F9289EB48","user_header":"https://static001.geekbang.org/account/avatar/00/12/a9/36/d054c979.jpg","comment_is_top":false,"comment_ctime":1560346577,"is_pvip":false,"replies":[{"id":"49087","content":"不是的，堆就不一定连续","user_name":"作者回复","comment_id":102999,"uid":"1001590","ip_address":"","utype":1,"ctime":1567590198,"user_name_real":"刘超@网易云"}],"discussion_count":6,"race_medal":0,"score":"35920084945","product_id":100024701,"comment_content":"老师好，vm_area_struct描述内存区域，内存区域有text，data，bss，堆，mmap映射，栈区域，一个进程的vm_area_struct个数只有这6个吗？","like_count":9,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453682,"discussion_content":"不是的，堆就不一定连续","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567590198,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2785458,"avatar":"","nickname":"Geek_7e392f","note":"","ucode":"07BFE0B0B3FCB2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408712,"discussion_content":"堆对应的vm_area_struct在什么情况下会有多个？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1635305993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1945881,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/b1/19/7a34d288.jpg","nickname":"陈言松","note":"","ucode":"B5F9E6310E6596","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282575,"discussion_content":"这里有一张图，有说明\nhttps://zhuanlan.zhihu.com/p/67435146\nhttps://manybutfinite.com/post/how-the-kernel-manages-your-memory/","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1592018959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1131300,"avatar":"https://static001.geekbang.org/account/avatar/00/11/43/24/3f9f7c70.jpg","nickname":"zixuan","note":"","ucode":"C72920DD05B074","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589366,"discussion_content":"可能调用一次大的mmap就会建立一个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664770155,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1007254,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/96/a03175bc.jpg","nickname":"莫名","note":"","ucode":"E28F2602BA25DD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":267656,"discussion_content":"堆只有一个。进程可以有多个vma，最简单的cat命令运行时vma个数也有10多个，可以使用pmap或者cat /proc/<pid>/maps查看。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589675375,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1291105,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJnRUibp7LV1lyHFWEUz5pIwvuXVIJ9ZlFKFOOQQEc7FO3Umt03FUrvYHa3gXQbvT3M70m6V0LibXvw/132","nickname":"Geek_366a52","note":"","ucode":"B6AE9146878244","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214234,"discussion_content":"mmap映射是不连续的，可能有多个，但是堆应该是一个，因为堆的分配是通过修改brk指针实现的，这样理解对吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585151558,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99880,"user_name":"Geek_49fbe5","can_delete":false,"product_type":"c1","uid":1451542,"ip_address":"","ucode":"3824BB1AC51268","user_header":"","comment_is_top":false,"comment_ctime":1559351619,"is_pvip":false,"replies":[{"id":"49215","content":"要区分虚拟地址空间和物理地址空间，可以虚拟的大，物理的小","user_name":"作者回复","comment_id":99880,"uid":"1001590","ip_address":"","utype":1,"ctime":1567603572,"user_name_real":"刘超@网易云"}],"discussion_count":2,"race_medal":0,"score":"27329155395","product_id":100024701,"comment_content":"老师，如果一台X86的物理机的内存只有1G，那是不是意味着这台机子装不了linux操作系统呢，因为内核就得用1G的内存？","like_count":6,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452308,"discussion_content":"要区分虚拟地址空间和物理地址空间，可以虚拟的大，物理的小","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567603572,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1479120,"avatar":"https://static001.geekbang.org/account/avatar/00/16/91/d0/35bc62b1.jpg","nickname":"无咎","note":"","ucode":"B9759B5646F3AB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2126,"discussion_content":"不是。内核可访问的虚拟地址空间1G，但是不必也不会用完，内核大概用个几十M到几百M。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1563271270,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104161,"user_name":"幸运的🐴","can_delete":false,"product_type":"c1","uid":1464707,"ip_address":"","ucode":"D09A0B5AA103B8","user_header":"https://static001.geekbang.org/account/avatar/00/16/59/83/1ff4888f.jpg","comment_is_top":false,"comment_ctime":1560671822,"is_pvip":false,"replies":[{"id":"49035","content":"在内核里面，得使用虚拟地址将内容读取到内存来。读一部分，映射一部分。load_elf_binary会最终调用do_mmap_pgoff，一样的","user_name":"作者回复","comment_id":104161,"uid":"1001590","ip_address":"","utype":1,"ctime":1567583109,"user_name_real":"刘超@网易云"}],"discussion_count":3,"race_medal":0,"score":"23035508302","product_id":100024701,"comment_content":"刘老师，为什么内核在load用户空间的内存映射到物理页的时候要自己在内核的持久映射区也建议一个映射呢，不能使用用户空间的映射吗？这样的话，持久映射区会不会有空间不够的情况？因为这块的虚拟空间很小(&lt;1G)，如果我mmap一个很大的文件到用户空间，那很明显没办法把这个文件映射到内核的虚拟空间来呀，这块它是怎么做的呢？另外，这个过程跟load elf不是类似的么？对于用户空间的进程的代码区，数据区等，还是需要把磁盘上的页读进内存吧？这个过程也需要在内核先映射，读完之后再解除映射？","like_count":5,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454150,"discussion_content":"在内核里面，得使用虚拟地址将内容读取到内存来。读一部分，映射一部分。load_elf_binary会最终调用do_mmap_pgoff，一样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567583109,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1131300,"avatar":"https://static001.geekbang.org/account/avatar/00/11/43/24/3f9f7c70.jpg","nickname":"zixuan","note":"","ucode":"C72920DD05B074","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589375,"discussion_content":"文件映射这个，考虑几个问题：\n1. 是否有必要一次全部读进来.\n2. 事先知道用户态要访问哪一部分吗？\n3. 缺页机制下，能直接用用户态虚拟地址实现延迟加载吗？\n\n首先，操作系统一般是按需延迟加载的，没有必要把一个大文件全部加载到物理内存，因为用户可能只访问中间一小段，所以刚开始时虚拟地址的页表项指向的是文件位置，而未分配物理内存。\n\n假设此时进程读取文件第100M这个位置的内容（对应的虚拟内存地址为A），内核经查页表发现A对应的目标位置还没加载就会触发缺页中断，中断处理程序里面再负责分配物理内层，读取相应的内容。那此时还会用A作为目标位置吗？当然不会，不然就永远递归执行缺页中断了，所以内核会选择另一块临时的区域做映射，读取文件目标位置的内容到物理内存，最后修改A的页表项指向此物理内存。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664779688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2285946,"avatar":"https://static001.geekbang.org/account/avatar/00/22/e1/7a/b206cded.jpg","nickname":"人在江湖龙在江湖","note":"","ucode":"20850038573DAE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":353127,"discussion_content":"为什么内核态不直接操作虚拟用户地址把文件读入物理内存，操作系统多这一步有什么好处，或者就是由于开始写操作系统这部分的人就这么写了，以后就成了惯例了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615019972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96125,"user_name":"小松松","can_delete":false,"product_type":"c1","uid":1298152,"ip_address":"","ucode":"B9B5FFE7CAA548","user_header":"https://static001.geekbang.org/account/avatar/00/13/ce/e8/12cb8e99.jpg","comment_is_top":false,"comment_ctime":1558338514,"is_pvip":true,"replies":[{"id":"49293","content":"伙伴系统是物理内存的分配，slub是划分为更小，但是都要变成虚拟地址才能被访问。","user_name":"作者回复","comment_id":96125,"uid":"1001590","ip_address":"","utype":1,"ctime":1567610313,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"18738207698","product_id":100024701,"comment_content":"请问下，像slab、伙伴系统这些工具跟用户空间和内核空间的虚拟内存、物理内存有什么关系呢？   一直很迷惑，请老师解答下。","like_count":4,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450730,"discussion_content":"伙伴系统是物理内存的分配，slub是划分为更小，但是都要变成虚拟地址才能被访问。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567610313,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207870,"user_name":"book尾汁","can_delete":false,"product_type":"c1","uid":1446375,"ip_address":"","ucode":"AE2B8DFC643ACC","user_header":"https://static001.geekbang.org/account/avatar/00/16/11/e7/044a9a6c.jpg","comment_is_top":false,"comment_ctime":1587201184,"is_pvip":true,"replies":[{"id":"83914","content":"直接映射区是一个区域的名称，不代表直接映射的部分把整个区域都用完，如果用不完，mmap也是可以放在这个区域里面的，只不过不是直接映射的方式访问，就像客厅叫客厅，也可以摆个床睡觉","user_name":"作者回复","comment_id":207870,"uid":"1001590","ip_address":"","utype":1,"ctime":1592458387,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"14472103072","product_id":100024701,"comment_content":"问个问题，假如我创建一个只有512M内存的32位的虚拟机，那岂不是所有的物理内存都是对应内核的直接映射区，用户态程序还怎么通过mmap申请内存？","like_count":3,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492266,"discussion_content":"直接映射区是一个区域的名称，不代表直接映射的部分把整个区域都用完，如果用不完，mmap也是可以放在这个区域里面的，只不过不是直接映射的方式访问，就像客厅叫客厅，也可以摆个床睡觉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592458387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103688,"user_name":"🍀吴昊","can_delete":false,"product_type":"c1","uid":1181559,"ip_address":"","ucode":"5A0447E0B9240D","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/77/bff4af27.jpg","comment_is_top":false,"comment_ctime":1560490914,"is_pvip":false,"replies":[{"id":"49050","content":"可能是图有些误解，堆在High memory区域。图中指的是数据结构都保存在直接映射区。但是vmalloc分配出来是给内核用的。<br><br>内核代码，全局变量，bss都是在代码段的。其他动态生成的变量都是在直接映射区的","user_name":"作者回复","comment_id":103688,"uid":"1001590","ip_address":"","utype":1,"ctime":1567584697,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"14445392802","product_id":100024701,"comment_content":"我请问下最后两张图没有看明白<br>1  32位直接映射区为什么还保存了堆信息？不是存在vmalloc来直接分配内存的嘛？<br>2 64位512M 用于存放内核代码段、全局变量、BSS 等。为什么图中却只映射到代码，而是由直接映射区去映射？","like_count":3,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453965,"discussion_content":"可能是图有些误解，堆在High memory区域。图中指的是数据结构都保存在直接映射区。但是vmalloc分配出来是给内核用的。\n\n内核代码，全局变量，bss都是在代码段的。其他动态生成的变量都是在直接映射区的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567584697,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248820,"user_name":"Geek_1e6930","can_delete":false,"product_type":"c1","uid":2006553,"ip_address":"","ucode":"2B0DAD1C01471D","user_header":"","comment_is_top":false,"comment_ctime":1600323080,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10190257672","product_id":100024701,"comment_content":"老师，每个vm_area_struct不是表示虚拟地址空间的各个段吗，为什么在brk申请内存时还要重新申请vm_area_struct并加到链表上","like_count":2,"discussions":[{"author":{"id":1472051,"avatar":"https://static001.geekbang.org/account/avatar/00/16/76/33/928ffd21.jpg","nickname":"AlexS","note":"","ucode":"3DA81A613CE645","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329542,"discussion_content":"sorry 我看错，是这节课内容。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606400379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1472051,"avatar":"https://static001.geekbang.org/account/avatar/00/16/76/33/928ffd21.jpg","nickname":"AlexS","note":"","ucode":"3DA81A613CE645","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329535,"discussion_content":"这是上一节课的问题吧XD... 它没重新申请vma啊，它是merge到prev vma也就是heap的vma的最后了呀。我看了code，大概是这样。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606400118,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223219,"user_name":"南瓜","can_delete":false,"product_type":"c1","uid":1079562,"ip_address":"","ucode":"53561F551857A4","user_header":"https://static001.geekbang.org/account/avatar/00/10/79/0a/a417ec1c.jpg","comment_is_top":false,"comment_ctime":1591023038,"is_pvip":false,"replies":[{"id":"83009","content":"不要背诵，如果对着总结图能说出大概原理就可以啦","user_name":"作者回复","comment_id":223219,"uid":"1001590","ip_address":"","utype":1,"ctime":1591753223,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"10180957630","product_id":100024701,"comment_content":"具体实现细节太多，这里一个指针、那里一个结构，是否应该更多考虑，这背后的思想，以及如何理解？毕竟不常接触这块儿，总不能去背诵。","like_count":2,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497060,"discussion_content":"不要背诵，如果对着总结图能说出大概原理就可以啦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591753223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215562,"user_name":"呆瓜","can_delete":false,"product_type":"c1","uid":1655940,"ip_address":"","ucode":"C98C7B224D0640","user_header":"https://static001.geekbang.org/account/avatar/00/19/44/84/4da14994.jpg","comment_is_top":false,"comment_ctime":1589016995,"is_pvip":false,"replies":[{"id":"83474","content":"赞","user_name":"作者回复","comment_id":215562,"uid":"1001590","ip_address":"","utype":1,"ctime":1592186670,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"10178951587","product_id":100024701,"comment_content":"每一篇都像是一部电影,这篇料放的有点猛,接不住,反复读了四五遍才大致理清楚脉络(略带懵逼 T_T ||)","like_count":2,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494477,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592186670,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95606,"user_name":"一笔一画","can_delete":false,"product_type":"c1","uid":1495254,"ip_address":"","ucode":"2B9BC8ADF97106","user_header":"https://static001.geekbang.org/account/avatar/00/16/d0/d6/f335954b.jpg","comment_is_top":false,"comment_ctime":1558098542,"is_pvip":false,"replies":[{"id":"49308","content":"设计的时候就预留的呀。如果分配堆有高端内存是会优先使用的","user_name":"作者回复","comment_id":95606,"uid":"1001590","ip_address":"","utype":1,"ctime":1567611223,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"10148033134","product_id":100024701,"comment_content":"老师，请教下，64位布局里面，为什么会有这个8T空档？另外，32位上用户进程是优先使用高端内存吗？","like_count":2,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450534,"discussion_content":"设计的时候就预留的呀。如果分配堆有高端内存是会优先使用的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567611223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":335409,"user_name":"Roy Liang","can_delete":false,"product_type":"c1","uid":1098898,"ip_address":"","ucode":"1DF5FC831A35DA","user_header":"https://static001.geekbang.org/account/avatar/00/10/c4/92/338b5609.jpg","comment_is_top":false,"comment_ctime":1645509908,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5940477204","product_id":100024701,"comment_content":"请问老师，Intel傲腾持久内存的页表映射关系和普通易失性内存一样吗？如果不一样，会是怎样的？如果一样，应用程序和操作系统如何区分持久型内存和非持久型内存呢？","like_count":1},{"had_liked":false,"id":320086,"user_name":"幼儿编程教学","can_delete":false,"product_type":"c1","uid":1237199,"ip_address":"","ucode":"F13F3150E6CAE9","user_header":"https://static001.geekbang.org/account/avatar/00/12/e0/cf/43f201f2.jpg","comment_is_top":false,"comment_ctime":1636078758,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5931046054","product_id":100024701,"comment_content":"请教下老师<br>不管是用户态还是内核态，不管是32位还是64位，为什么都有空洞，不连续？<br>比如，64位内核态，你图中<br>0x0000 8000 0000 0000 -&gt; 0xFFFF 8000 0000 0000 这里有空洞<br>0xFFFF 8000 0000 0000 -&gt; 0xFFFF 8800 0000 0000 这里有8T空洞<br>0xFFFF C800 0000 0000 -&gt; 0xFFFF C900 0000 0000 这里1T<br>0xFFFF E900 0000 0000 -&gt; 0xFFFF EA00 0000 0000 这里1T<br>......<br>这么多空洞，这么设计是为什么？总觉得应该紧凑一点比较合理","like_count":1},{"had_liked":false,"id":223862,"user_name":"八台上","can_delete":false,"product_type":"c1","uid":1391143,"ip_address":"","ucode":"FB3D74B522C720","user_header":"https://static001.geekbang.org/account/avatar/00/15/3a/27/5d218272.jpg","comment_is_top":false,"comment_ctime":1591198005,"is_pvip":false,"replies":[{"id":"83005","content":"内存里，特殊位置","user_name":"作者回复","comment_id":223862,"uid":"1001590","ip_address":"","utype":1,"ctime":1591752972,"user_name_real":"刘超@网易云"}],"discussion_count":2,"race_medal":0,"score":"5886165301","product_id":100024701,"comment_content":"请问页表数据是存在哪了呢？","like_count":1,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497269,"discussion_content":"内存里，特殊位置","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591752972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2346917,"avatar":"https://static001.geekbang.org/account/avatar/00/23/cf/a5/5224b297.jpg","nickname":"cafe babe","note":"","ucode":"6205DF67AD86F8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578772,"discussion_content":"。。。。。到底在内存哪里啊？？？？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657004984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218331,"user_name":"杉松壁","can_delete":false,"product_type":"c1","uid":1080578,"ip_address":"","ucode":"ED904CE27CD3C4","user_header":"https://static001.geekbang.org/account/avatar/00/10/7d/02/4862f849.jpg","comment_is_top":false,"comment_ctime":1589782278,"is_pvip":false,"replies":[{"id":"83084","content":"还不够呀","user_name":"作者回复","comment_id":218331,"uid":"1001590","ip_address":"","utype":1,"ctime":1591785769,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"5884749574","product_id":100024701,"comment_content":"64位系统虽然理论上可以用非常大的内存空间，但是linux系统用户空间最大只有128T可用？","like_count":1,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495434,"discussion_content":"还不够呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591785769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211627,"user_name":"vsan","can_delete":false,"product_type":"c1","uid":1896461,"ip_address":"","ucode":"20D3C0BF575C9D","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f0/0d/1ddba1aa.jpg","comment_is_top":false,"comment_ctime":1587990805,"is_pvip":false,"replies":[{"id":"83784","content":"是的，但是以一个为主","user_name":"作者回复","comment_id":211627,"uid":"1001590","ip_address":"","utype":1,"ctime":1592359510,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"5882958101","product_id":100024701,"comment_content":"老师，分段管理和分页管理是共存的吗？","like_count":1,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493318,"discussion_content":"是的，但是以一个为主","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592359510,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95427,"user_name":"whoami","can_delete":false,"product_type":"c1","uid":1367079,"ip_address":"","ucode":"32679440DC9646","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKZTnPw18RNia9StSG151q8TE9WDlqfa6Eb9zuo1Hib7v4WAw32FJJlcfsDwRIu7dZUjucfklpzurvQ/132","comment_is_top":false,"comment_ctime":1558055654,"is_pvip":false,"replies":[{"id":"34092","content":"也是分页的，一页之内联系，超过一页不保证","user_name":"作者回复","comment_id":95427,"uid":"1001590","ip_address":"","utype":1,"ctime":1558067613,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"5853022950","product_id":100024701,"comment_content":"老师，进程堆，栈，BBS，mmap，也是随机分布在内存中不是连续的吧？","like_count":1,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450452,"discussion_content":"也是分页的，一页之内联系，超过一页不保证","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558067613,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":349457,"user_name":"Geek_964a1d","can_delete":false,"product_type":"c1","uid":2776720,"ip_address":"","ucode":"C2653552516662","user_header":"","comment_is_top":false,"comment_ctime":1655976524,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655976524","product_id":100024701,"comment_content":"刘老师，64位的linux系统，应该不能运行32位的可执行程序吗？这和虚拟内存布局有关系吧？","like_count":0},{"had_liked":false,"id":348146,"user_name":"功不唐捐","can_delete":false,"product_type":"c1","uid":2967778,"ip_address":"","ucode":"A5812C794AA3A8","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/bibWTLkOic0gB943oF2Pia0G4RFk58hlCJUnEH53V3xA2kyFGCbenQFE3JtRjpblxEFUd5kg1ky6btVXDWNqbKnQA/132","comment_is_top":false,"comment_ctime":1654779782,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654779782","product_id":100024701,"comment_content":"在  《用户态和内核态的划分》  这一小节最后有张图，这个图画的地址有点问题。地址写的0x7f ff ffff f000，大小缺写的是128T。<br><br>User space process size. 47bits minus one guard page.<br><br>左移 47 位是 128T，所以 64 位的用户态大小实际上是 128T - 1K。","like_count":0},{"had_liked":false,"id":345673,"user_name":"王建峰","can_delete":false,"product_type":"c1","uid":1968013,"ip_address":"","ucode":"8BF1AEFFA7EA5F","user_header":"https://static001.geekbang.org/account/avatar/00/1e/07/8d/3e76560f.jpg","comment_is_top":false,"comment_ctime":1652502049,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652502049","product_id":100024701,"comment_content":"有一事不明，如果内核层使用kmalloc接口，获取的虚拟地址是在内核空间的哪个区域？物理块是如何分配的？在64位系统上，被分配的物理空间是否是在内核&quot;直接映射区&quot;映射范围内？","like_count":0},{"had_liked":false,"id":331673,"user_name":"龍蝦","can_delete":false,"product_type":"c1","uid":1000076,"ip_address":"","ucode":"BE1D500833F070","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/8c/373d4027.jpg","comment_is_top":false,"comment_ctime":1642698085,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1642698085","product_id":100024701,"comment_content":"老师你好，32位环境，如果直接映射区对应的物理内存已经被某个进程的用户态空间映射了，现在内核要访问这个地址，会如何处理呢？会把用户态空间的映射“挪开”嘛？","like_count":0},{"had_liked":false,"id":330353,"user_name":"Geek_d40030","can_delete":false,"product_type":"c1","uid":2029525,"ip_address":"","ucode":"91A94D7C8F3F71","user_header":"","comment_is_top":false,"comment_ctime":1641948300,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1641948300","product_id":100024701,"comment_content":"老师您好，看代码调用brk得时候，堆上是有可能新建vma对象的，但是我在测试的时候，查看&#47;proc&#47;process_id&#47;maps，发现不管怎样分配内存都只有一个堆vma对象，请问老师堆有可能会存在多个vma对象吗？","like_count":0},{"had_liked":false,"id":325983,"user_name":"linker","can_delete":false,"product_type":"c1","uid":1803259,"ip_address":"","ucode":"6C5799F2FC2C82","user_header":"https://static001.geekbang.org/account/avatar/00/1b/83/fb/621adceb.jpg","comment_is_top":false,"comment_ctime":1639294090,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639294090","product_id":100024701,"comment_content":"刚才的提问自己解决了，是物理地址啊","like_count":0},{"had_liked":false,"id":325978,"user_name":"linker","can_delete":false,"product_type":"c1","uid":1803259,"ip_address":"","ucode":"6C5799F2FC2C82","user_header":"https://static001.geekbang.org/account/avatar/00/1b/83/fb/621adceb.jpg","comment_is_top":false,"comment_ctime":1639289447,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639289447","product_id":100024701,"comment_content":"关于64为的内核地址映射，我这边做实验，查看了&#47;proc&#47;kallsyms 这个文件，发现里面有些地址是0x000000000001d000，这种以多个0开头的，有些疑问<br>1. 这个地址应该是需要地址吗？<br>2. 如果是虚拟地址的话，不应该至少是0xffff88以上的地址吗？<br>求各位大佬解惑","like_count":0},{"had_liked":false,"id":307294,"user_name":"ysh","can_delete":false,"product_type":"c1","uid":1113305,"ip_address":"","ucode":"17D1994A7D5DA6","user_header":"https://static001.geekbang.org/account/avatar/00/10/fc/d9/8483510b.jpg","comment_is_top":false,"comment_ctime":1629015611,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629015611","product_id":100024701,"comment_content":"有个问题，内核的内存布局没有内核栈","like_count":0},{"had_liked":false,"id":305827,"user_name":"Geek_e66f66","can_delete":false,"product_type":"c1","uid":2725970,"ip_address":"","ucode":"68047716E79C44","user_header":"","comment_is_top":false,"comment_ctime":1628181023,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628181023","product_id":100024701,"comment_content":"老师, brk和mmap调用的分界线是 128K的空间, 这个128K是怎么得出来的呀?","like_count":0},{"had_liked":false,"id":295965,"user_name":"IMBFD","can_delete":false,"product_type":"c1","uid":2149899,"ip_address":"","ucode":"2E7B3D01C537A0","user_header":"https://static001.geekbang.org/account/avatar/00/20/ce/0b/b1e244e6.jpg","comment_is_top":false,"comment_ctime":1622685186,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622685186","product_id":100024701,"comment_content":"老师，为啥有时候访问越界会报segfault，有时候又不会报错？感觉跟内存管理这块有关。","like_count":0},{"had_liked":false,"id":293949,"user_name":"RyuGou","can_delete":false,"product_type":"c1","uid":1200793,"ip_address":"","ucode":"8D424CB6005DD7","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/99/4a7f2fc9.jpg","comment_is_top":false,"comment_ctime":1621645902,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621645902","product_id":100024701,"comment_content":"用户态栈区为什么增长顺序由高至低？我搜索的答案是：第一栈区数据结构为栈，由高至低恰好符合LIFO的规则；第二mmap区属于缓存区，栈和堆都有可能延伸至此，先到先得；我理解的对吗？","like_count":0},{"had_liked":false,"id":282674,"user_name":"Emmcd","can_delete":false,"product_type":"c1","uid":2004534,"ip_address":"","ucode":"8B8BFDD26CB89A","user_header":"https://static001.geekbang.org/account/avatar/00/1e/96/36/37b9e314.jpg","comment_is_top":false,"comment_ctime":1615360942,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615360942","product_id":100024701,"comment_content":"vm_area_struct 里面的 vm_start 和 vm_end 是不是和上一层 mm 中的 start_code、end_code、start_data这些指向是一样的，如果是的话为什么要存储两份呢？","like_count":0},{"had_liked":false,"id":276145,"user_name":"马保国二弟子","can_delete":false,"product_type":"c1","uid":1900632,"ip_address":"","ucode":"239A1628E6B02C","user_header":"https://static001.geekbang.org/account/avatar/00/1d/00/58/7d7932e2.jpg","comment_is_top":false,"comment_ctime":1611810927,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611810927","product_id":100024701,"comment_content":"直接映射区减去PAGE_OFFSET（0xffff880000000000）和代码段减去__START_KERNEL_map（0xffffffff80000000）不都是从物理地址0开始的吗？为啥还说有8T的空档，难道说__PAGE_OFFSET_BASE和PAGE_OFFSET这两个值不一样？","like_count":0},{"had_liked":false,"id":244062,"user_name":"花树","can_delete":false,"product_type":"c1","uid":1542107,"ip_address":"","ucode":"810A5B42EEE264","user_header":"https://static001.geekbang.org/account/avatar/00/17/87/db/c132ef37.jpg","comment_is_top":false,"comment_ctime":1598369290,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"1598369290","product_id":100024701,"comment_content":"老师，内核对于所有进程都只有一份，多进程共享这一份不会产生冲突吗？另外内核可不可以访问一个进程的用户态的虚拟地址对应的物理内存呀？","like_count":0,"discussions":[{"author":{"id":1066409,"avatar":"https://static001.geekbang.org/account/avatar/00/10/45/a9/3d48d6a2.jpg","nickname":"Lorry","note":"","ucode":"BD4754D0F1D786","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389806,"discussion_content":"内核空间是共享的，但是明确到每个task的内存空间是彼此独立的，不会有冲突","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629436524,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2285946,"avatar":"https://static001.geekbang.org/account/avatar/00/22/e1/7a/b206cded.jpg","nickname":"人在江湖龙在江湖","note":"","ucode":"20850038573DAE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":353130,"discussion_content":"另外内核可不可以访问一个进程的用户态的虚拟地址对应的物理内存呀？ 我也有这个疑问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615020284,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1066409,"avatar":"https://static001.geekbang.org/account/avatar/00/10/45/a9/3d48d6a2.jpg","nickname":"Lorry","note":"","ucode":"BD4754D0F1D786","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2285946,"avatar":"https://static001.geekbang.org/account/avatar/00/22/e1/7a/b206cded.jpg","nickname":"人在江湖龙在江湖","note":"","ucode":"20850038573DAE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389807,"discussion_content":"当然可以，系统调用，在内核态返回用户态的时候，就是将值返回给了用户态的啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629436588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":353130,"ip_address":""},"score":389807,"extra":""}]},{"author":{"id":1472051,"avatar":"https://static001.geekbang.org/account/avatar/00/16/76/33/928ffd21.jpg","nickname":"AlexS","note":"","ucode":"3DA81A613CE645","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329540,"discussion_content":"copy_from_user. copy_to_user?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606400342,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":243802,"user_name":"花树","can_delete":false,"product_type":"c1","uid":1542107,"ip_address":"","ucode":"810A5B42EEE264","user_header":"https://static001.geekbang.org/account/avatar/00/17/87/db/c132ef37.jpg","comment_is_top":false,"comment_ctime":1598279494,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1598279494","product_id":100024701,"comment_content":"老师，用户态所有的vm_area_struct在红黑树中按照什么组织起来的，选哪个作为根节点啊？","like_count":0,"discussions":[{"author":{"id":1472051,"avatar":"https://static001.geekbang.org/account/avatar/00/16/76/33/928ffd21.jpg","nickname":"AlexS","note":"","ucode":"3DA81A613CE645","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329538,"discussion_content":"它是按vm_start/vm_end地址大小组织的。至于哪个是根，介个你就要了解一下红黑树了，它是平衡二叉查找树，根是地址不大不小排在中间的哪个vma.","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1606400236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":233810,"user_name":"Geek_63bb29","can_delete":false,"product_type":"c1","uid":2017041,"ip_address":"","ucode":"65C27FA7531722","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/5kv7IqibneNnMLqtWZQR5f1et8lJmoxiaU43Ttzz3zqW7QzBqMkib8GCtImKsms7PPbWmTB51xRnZQAnRPfA1wVaw/132","comment_is_top":false,"comment_ctime":1594460998,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1594460998","product_id":100024701,"comment_content":"老师，是每个进程在用户态和内核态都有自己的进程空间吗？还是说只有包含系统调用的进程，内核态才有进程空间，比如说内核的栈空间？","like_count":0,"discussions":[{"author":{"id":1066409,"avatar":"https://static001.geekbang.org/account/avatar/00/10/45/a9/3d48d6a2.jpg","nickname":"Lorry","note":"","ucode":"BD4754D0F1D786","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389810,"discussion_content":"要分清楚内存分配，以及线程和task；\n\n内核态只有task哦，没有进程概念，进程是只有用户态才有的；用户态有线程pthread，只有需要调用内核态功能的时候，才会通过系统调用生成task完成调用任务；\n\n不过内存分配方面，则是在创建进程的时候，就把用户态和内核态都分配了；","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629436862,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":226647,"user_name":"业余爱好者","can_delete":false,"product_type":"c1","uid":1482915,"ip_address":"","ucode":"A890935A982988","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","comment_is_top":false,"comment_ctime":1592178650,"is_pvip":false,"replies":[{"id":"83451","content":"后面会有页表的简述，的确有自己管理自己，比较绕","user_name":"作者回复","comment_id":226647,"uid":"1001590","ip_address":"","utype":1,"ctime":1592185701,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"1592178650","product_id":100024701,"comment_content":"内存管理部门自己的代码和数据也需要分页分段，它是如何自己管理自己的呢?  留个痕","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498315,"discussion_content":"后面会有页表的简述，的确有自己管理自己，比较绕","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592185701,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174660,"user_name":"淤白","can_delete":false,"product_type":"c1","uid":1206503,"ip_address":"","ucode":"D1E65DC40DAF68","user_header":"https://static001.geekbang.org/account/avatar/00/12/68/e7/ee47d0e2.jpg","comment_is_top":false,"comment_ctime":1580311517,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580311517","product_id":100024701,"comment_content":"本篇文章看了几遍才勉强理解，离记忆还差些，但还是消除了心中的疑惑。<br><br>通过本篇文章，主要了解的知识是：对于用户态的内存布局，32 位和 64 位并没有太大区别，记录着需要用到的类似数据结构；而对于内核态的内存布局，32 位的内存紧张，有一个 896 M 的直接映射区，其余的内存区域就比较小且紧凑，对于 64 位系统来说，内核态虚拟内存非常宽裕，所以分配起来会和 32 位的有区别。","like_count":0},{"had_liked":false,"id":174068,"user_name":"yanger","can_delete":false,"product_type":"c1","uid":1233837,"ip_address":"","ucode":"491426CA7DE1E8","user_header":"https://static001.geekbang.org/account/avatar/00/12/d3/ad/bfaae364.jpg","comment_is_top":false,"comment_ctime":1579940289,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1579940289","product_id":100024701,"comment_content":"直接映射区前有8T空间，早就过了内核代码加载到物理内存的位置，没看懂，请问下什么意思","like_count":0,"discussions":[{"author":{"id":2523660,"avatar":"https://static001.geekbang.org/account/avatar/00/26/82/0c/cc106ab1.jpg","nickname":"Samaritan.","note":"","ucode":"A3730B90313C26","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586204,"discussion_content":"是啊，这句话我也看不懂，有点莫名其妙","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662031150,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"福建"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1168361,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d3/e9/59ff9004.jpg","nickname":"Fibonacci","note":"","ucode":"31DB723EB4BBA1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400054,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633149616,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1140236,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/0c/72de4414.jpg","nickname":"疆封","note":"","ucode":"16D753FC75DED4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":179789,"discussion_content":"我也没看明白，那8T的空洞并不属于直接映射区呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582253510,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162488,"user_name":"烬默","can_delete":false,"product_type":"c1","uid":1080229,"ip_address":"","ucode":"6BF7C7C5FC0C56","user_header":"https://static001.geekbang.org/account/avatar/00/10/7b/a5/31fd290d.jpg","comment_is_top":false,"comment_ctime":1576545434,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576545434","product_id":100024701,"comment_content":"用户空间的mmap区域和其他地方不同呀，大部分都是写的由低到高，为什么这边是由高到低","like_count":0},{"had_liked":false,"id":160508,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1575967145,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575967145","product_id":100024701,"comment_content":"32位的内核代码、数据、bss放到哪个区域呢？","like_count":0},{"had_liked":false,"id":154711,"user_name":"追风筝的人","can_delete":false,"product_type":"c1","uid":1488020,"ip_address":"","ucode":"2993D60F94C396","user_header":"https://static001.geekbang.org/account/avatar/00/16/b4/94/2796de72.jpg","comment_is_top":false,"comment_ctime":1574517906,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574517906","product_id":100024701,"comment_content":"看不懂了","like_count":0},{"had_liked":false,"id":149274,"user_name":"88591","can_delete":false,"product_type":"c1","uid":1254656,"ip_address":"","ucode":"04CE3E46455185","user_header":"https://static001.geekbang.org/account/avatar/00/13/25/00/3afbab43.jpg","comment_is_top":false,"comment_ctime":1573181462,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573181462","product_id":100024701,"comment_content":"老师，程序运行中的变量值。是怎么被虚拟内存管理的？比如 int a=1。它是怎么知道写入到哪一个物理地址的","like_count":0},{"had_liked":false,"id":147001,"user_name":"柳长青","can_delete":false,"product_type":"c1","uid":1716747,"ip_address":"","ucode":"3EA2B7BD5DBCAF","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/1pMbwZrAl5gVy4FictX9HiaDicYOjRI2E6flxrXLhLTcneF74TowWK6rJW6oKs9iakPl0dqHsWjav0TjK6vyEZTlJA/132","comment_is_top":false,"comment_ctime":1572757927,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572757927","product_id":100024701,"comment_content":"老师，可不可以这样理解：即用户的虚拟内存和内核的虚拟内存在物理内存上并不是连续的，所以它们都可以在直接映射区（前896M）进行操作。","like_count":0},{"had_liked":false,"id":143558,"user_name":"耀明","can_delete":false,"product_type":"c1","uid":1446437,"ip_address":"","ucode":"99D03E4547EB70","user_header":"https://static001.geekbang.org/account/avatar/00/16/12/25/f9cdf7e9.jpg","comment_is_top":false,"comment_ctime":1571730823,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571730823","product_id":100024701,"comment_content":"那两个图看不太懂，跟文字描述的有很大的不同。","like_count":0},{"had_liked":false,"id":133082,"user_name":"book尾汁","can_delete":false,"product_type":"c1","uid":1446375,"ip_address":"","ucode":"AE2B8DFC643ACC","user_header":"https://static001.geekbang.org/account/avatar/00/16/11/e7/044a9a6c.jpg","comment_is_top":false,"comment_ctime":1568351773,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1568351773","product_id":100024701,"comment_content":"请问 系统调用brk里用这样一段 if (do_brk(oldbrk, newbrk-oldbrk, &amp;uf) &lt; 0) ；  goto out，如果do_brk返回小于0的值是分配堆内存失败了吗？do_brk会返回do_brk_flags的返回值，但是看do_brk_flags这个函数里只会返回0啊，是do_brk_flags没写全吗","like_count":0},{"had_liked":false,"id":126105,"user_name":"haozhang","can_delete":false,"product_type":"c1","uid":1505549,"ip_address":"","ucode":"B4FC40EBFFB10E","user_header":"","comment_is_top":false,"comment_ctime":1566313489,"is_pvip":false,"replies":[{"id":"46532","content":"内核的虚拟地址空间","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1566354742,"ip_address":"","comment_id":126105,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566313489","product_id":100024701,"comment_content":"内核栈在哪呢？","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463832,"discussion_content":"内核的虚拟地址空间","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566354742,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108502,"user_name":"饭粒","can_delete":false,"product_type":"c1","uid":1153455,"ip_address":"","ucode":"4C3220B0D43997","user_header":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","comment_is_top":false,"comment_ctime":1561787696,"is_pvip":false,"replies":[{"id":"48825","content":"内存的分配就在直接映射区了。","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567499922,"ip_address":"","comment_id":108502,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1561787696","product_id":100024701,"comment_content":"老师，我想问下文中描述的是虚拟内存的布局，即使物理地址比较小，比如32位系统小于4g，于进程而言使用的还是4g的虚拟地址？但现在如果物理内存小于896M，这样物理内存大小小于内核态中直接一对一映射区域的大小，这种linux怎么处理？","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456010,"discussion_content":"内存的分配就在直接映射区了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567499922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1609871,"avatar":"https://static001.geekbang.org/account/avatar/00/18/90/8f/9c691a5f.jpg","nickname":"奔跑的码仔","note":"","ucode":"AB3B02B07B8B8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6428,"discussion_content":"经测试，直接映射区域的大小即为实际物理内存的大小","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1566895336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97184,"user_name":"烈日融雪","can_delete":false,"product_type":"c1","uid":1131925,"ip_address":"","ucode":"E462E30FB0AFC0","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/95/968fd89f.jpg","comment_is_top":false,"comment_ctime":1558603848,"is_pvip":false,"replies":[{"id":"49254","content":"在编译的时候，结构体的数据存放不会按照声明顺序，而是根据函数名以及随机种子，打乱存储顺序。","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567607700,"ip_address":"","comment_id":97184,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1558603848","product_id":100024701,"comment_content":"请问 __randomize_layout 是让struct 结构变量在编译时候 里面熟悉不按默认的定义顺序存储么？","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451170,"discussion_content":"在编译的时候，结构体的数据存放不会按照声明顺序，而是根据函数名以及随机种子，打乱存储顺序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567607700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97024,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1558573588,"is_pvip":false,"replies":[{"id":"34858","content":"一开始讲过前1m的，后面的内存管理那一节讲","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1558680915,"ip_address":"","comment_id":97024,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1558573588","product_id":100024701,"comment_content":"内核自身启动的内核进程是如何布局内存的？","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451102,"discussion_content":"一开始讲过前1m的，后面的内存管理那一节讲","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558680915,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95745,"user_name":"飞翔","can_delete":false,"product_type":"c1","uid":1349270,"ip_address":"","ucode":"72252157268A12","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/J3dqALgicfVklewMjVkpyLbTk9YiamnBf5QQZ3NPHGlMeVSdLDB5yHLicEZHKBbUets76KOFwbl9ju0xJw1VeGa1A/132","comment_is_top":false,"comment_ctime":1558163134,"is_pvip":false,"replies":[{"id":"49302","content":"局部变量不在可执行文件中，可执行文件中只有编译阶段就知道值的哪些静态变量啊，全局变量啊","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567610870,"ip_address":"","comment_id":95745,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1558163134","product_id":100024701,"comment_content":"老师，局部变量是在进程的栈里，它在可执行文件ElF的哪里呢？","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450584,"discussion_content":"局部变量不在可执行文件中，可执行文件中只有编译阶段就知道值的哪些静态变量啊，全局变量啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567610870,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2285946,"avatar":"https://static001.geekbang.org/account/avatar/00/22/e1/7a/b206cded.jpg","nickname":"人在江湖龙在江湖","note":"","ucode":"20850038573DAE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386677,"discussion_content":"可以这样认为，局部变量的值是在代码段里，哈哈","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1627720838,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}