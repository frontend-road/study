{"id":595456,"title":"23｜质量保证（下）：测试金字塔与React单元测试","content":"<p>你好，我是宋一玮，欢迎回到React应用开发的学习。</p><p>从上节课开始，我们进入了大中型React项目最重要的实践之一：自动化测试的学习。</p><p>我们首先了解了人工测试与自动化测试的区别，以及自动化测试对大型前端项目的重要意义，也建议由业务功能的开发者亲自来编写自动化测试脚本。然后我们学习了如何利用现代自动化测试框架Playwright，开发自动化E2E测试用例。</p><p>这节课，我们会继续学习大中型React项目的质量保证，利用单元测试进一步提升项目质量。同时也了解一下测试金字塔的理论，有助于你更深入理解端到端和单元测试的关系。</p><p>下面开始这节课的内容。</p><h2>前端开发者应该了解的测试金字塔</h2><p>首先回顾一下上节课提到的关于测试范围的观点：</p><blockquote>\n<p>……不会去尝试穷举所有可能性，否则开发出来的测试用例就算比源码都大好多好多倍，也都不一定能达到100%覆盖。</p>\n</blockquote><p>假设一段程序先后有2个条件分支，那么如果希望全覆盖到，则需要设计4个测试用例。如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/c4/88/c440d3d59c709c73c61780d9d6a9a988.jpg?wh=1920x1080\" alt=\"图片\"></p><p>图中的4条颜色的连线对应了4个测试用例，分别是：</p><ul>\n<li>A → B1 → C1 → D；</li>\n<li>A → B1 → C2 → D；</li>\n<li>A → B2 → C1 → D；</li>\n<li>A → B2 → C2 → D。</li>\n</ul><p>而在一个完整的前端应用中，这样的分支绝不在少数。可想而知，无论从编写效率还是执行效率来看，E2E测试都无法覆盖所有逻辑和交互分支。</p><!-- [[[read_end]]] --><p>那换个思路，如果把E2E无法覆盖的部分测试点打散，改用其他更加高效的方式测试它们，不就能提高覆盖率了吗？</p><p>这就引出了一个软件测试领域的重要概念：测试金字塔。</p><p><strong>测试金字塔（Test Pyramid）<strong>最初由敏捷开发鼻祖Mike Cohn在其著作《Scrum敏捷软件开发》中提出，主张</strong>分层次开展自动化测试以提高测试效率</strong>。</p><p>金字塔从上到下三层分别是E2E测试、整合测试和单元测试。其中E2E和整合测试属于黑盒测试，整合程度更高，单元测试属于白盒测试，运行耗时更短。之所以呈金字塔形状，是因为从测试用例的比重看，E2E的最少（占10%左右），单元测试最多（占70%左右），如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/1e/24/1ec2ceda9f19ce962f023f7b61536924.jpg?wh=1920x1080\" alt=\"图片\"></p><p>我们上节课学习了E2E测试，知道E2E包含了前端和后端，整合测试会将软件模块和它的真实依赖一起测试，如后端的HTTP接口测试。而单元测试则会设定特定的输入和输出，对软件中尽量小的构成单元进行测试，前端、后端都可以做单元测试。</p><p>接下来，我们就来学习React应用的单元测试。</p><h2>React单元测试的范围和目标</h2><p>理想情况自然是为React项目中的所有源码都加上单元测试，这个范围在小型React项目还能做得到，但大中型项目往往就比较难了。从测试优先级来排序，需要测试的代码类型包括：</p><ul>\n<li>React组件；</li>\n<li>自定义Hooks；</li>\n<li>Redux的Action、Reducer、Selector等；</li>\n<li>其他。</li>\n</ul><p>需要说明的是，近年来React组件测试实践越来越丰富，根据实际需要，可以将父子组件写在同一个测试用例里，也可以组件带着自定义Hooks一起测。可以说，这已经逐渐模糊了组件单元测试和整合测试的界限。</p><p>但类比连着真实数据库一起测的后端整合测试，前端React组件测试使用<strong>模拟（Mock）</strong>的比重还是很大的，所以这里依旧把组件测试归类到单元测试的范畴。</p><p>单元测试的目标是比较容易量化的，大部分单元测试框架都支持统计<strong>代码覆盖率（Code Coverage）</strong>，即运行测试用例时所执行的源码占源码总量的比重。若想提高测试的覆盖率，需要测试用例尽可能进入源码中更多的分支。</p><p>当企业要求产品源码的测试覆盖率，无论前端还是后端都要达到90%以上时，多少是可以体现出企业对软件质量的重视程度的。</p><h2>用Jest + RTL编写单元测试</h2><p>目前React技术社区最为流行的单元测试框架是<strong>Jest + RTL（React Testing Library）</strong>。Jest是FB推出的一款开源JavaScript测试框架（<a href=\"https://jestjs.io/zh-Hans/\">官网</a>），RTL（React Testing Library）是一款开源的轻量级React组件测试库（<a href=\"https://testing-library.com/docs/react-testing-library/intro/\">官网</a>）。</p><p>其实你早在<a href=\"https://time.geekbang.org/column/article/553817\">第三节课</a>用CRA创建React项目时就已经接触过Jest + RTL了，还记得那个 <code>src/App.test.js</code> 文件吗？那个就是Jest的单元测试文件：</p><pre><code class=\"language-typescript\">import { render, screen } from '@testing-library/react';\nimport App from './App';\n\ntest('renders learn react link', () =&gt; {\n&nbsp; render(&lt;App /&gt;);\n&nbsp; const linkElement = screen.getByText(/learn react/i);\n&nbsp; expect(linkElement).toBeInTheDocument();\n});\n</code></pre><p>如果现在在oh-my-kanban下跑一下 <code>npm test</code> ，它应该会失败，并显示如下提示：</p><pre><code class=\"language-bash\">&nbsp;FAIL&nbsp; src/App.test.js\n&nbsp; ✕ renders learn react link (29 ms)\n\n&nbsp; ● renders learn react link\n\n&nbsp; &nbsp; TestingLibraryElementError: Unable to find an element with the text: /learn react/i. This could be because the text is broken up by multiple elements. In this case, you can provide a function for your text matcher to make your matcher more flexible.\n\n&nbsp; &nbsp; Ignored nodes: comments, &lt;script /&gt;, &lt;style /&gt;\n&nbsp; &nbsp; &lt;body&gt;\n&nbsp; &nbsp; &nbsp; &lt;div&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;div\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; class=\"App\"\n&nbsp; &nbsp; &nbsp; &nbsp; &gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;header\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; class=\"App-header\"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;h1&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 我的看板\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;button&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 保存所有卡片\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;/button&gt;\n    # ...\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;/div&gt;\n&nbsp; &nbsp; &nbsp; &lt;/div&gt;\n&nbsp; &nbsp; &lt;/body&gt;\n\n&nbsp; &nbsp; &nbsp; 4 | test('renders learn react link', () =&gt; {\n&nbsp; &nbsp; &nbsp; 5 |&nbsp; &nbsp;render(&lt;App /&gt;);\n&nbsp; &nbsp; &gt; 6 |&nbsp; &nbsp;const linkElement = screen.getByText(/learn react/i);\n&nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^\n&nbsp; &nbsp; &nbsp; 7 |&nbsp; &nbsp;expect(linkElement).toBeInTheDocument();\n&nbsp; &nbsp; &nbsp; 8 | });\n&nbsp; &nbsp; &nbsp; 9 |\n\n&nbsp; &nbsp; &nbsp; at Object.getElementError (node_modules/@testing-library/dom/dist/config.js:38:19)\n&nbsp; &nbsp; &nbsp; at node_modules/@testing-library/dom/dist/query-helpers.js:90:38\n&nbsp; &nbsp; &nbsp; at node_modules/@testing-library/dom/dist/query-helpers.js:62:17\n&nbsp; &nbsp; &nbsp; at getByText (node_modules/@testing-library/dom/dist/query-helpers.js:111:19)\n&nbsp; &nbsp; &nbsp; at Object.&lt;anonymous&gt; (src/App.test.js:6:30)\n&nbsp; &nbsp; &nbsp; at TestScheduler.scheduleTests (node_modules/@jest/core/build/TestScheduler.js:333:13)\n&nbsp; &nbsp; &nbsp; at runJest (node_modules/@jest/core/build/runJest.js:404:19)\n\nTest Suites: 1 failed, 1 total\nTests:&nbsp; &nbsp; &nbsp; &nbsp;1 failed, 1 total\nSnapshots:&nbsp; &nbsp;0 total\nTime:&nbsp; &nbsp; &nbsp; &nbsp; 0.665 s, estimated 1 s\nRan all test suites related to changed files.\n\nWatch Usage\n&nbsp;› Press a to run all tests.\n&nbsp;› Press f to run only failed tests.\n&nbsp;› Press q to quit watch mode.\n&nbsp;› Press i to run failing tests interactively.\n&nbsp;› Press p to filter by a filename regex pattern.\n&nbsp;› Press t to filter by a test name regex pattern.\n&nbsp;› Press Enter to trigger a test run.\n</code></pre><p>很快修复一下？有错的不是源码，而是测试用例：</p><pre><code class=\"language-bash\">test('渲染保存所有卡片按钮', () =&gt; {\n&nbsp; render(&lt;App /&gt;);\n&nbsp; const btnElem = screen.getByText(/保存所有卡片/i);\n&nbsp; expect(btnElem).toBeInTheDocument();\n});\n</code></pre><p>Jest会自动重新运行失败的测试用例，这次通过了：</p><pre><code class=\"language-bash\">&nbsp;PASS&nbsp; src/App.test.js\n&nbsp; ✓ 渲染保存所有卡片按钮 (27 ms)\n\nTest Suites: 1 passed, 1 total\nTests:&nbsp; &nbsp; &nbsp; &nbsp;1 passed, 1 total\nSnapshots:&nbsp; &nbsp;0 total\nTime:&nbsp; &nbsp; &nbsp; &nbsp; 0.709 s, estimated 1 s\nRan all test suites related to changed files.\n\nWatch Usage: Press w to show more.\n</code></pre><p>如果React项目不是用CRA搭建的，则需要安装Jest + RTL。Jest的安装可以参考官网的<a href=\"https://jestjs.io/zh-Hans/docs/getting-started\">快速开始文档</a>，RTL则使用以下命令：</p><pre><code class=\"language-bash\">npm install -D @testing-library/react\n</code></pre><p>在 <code>package.json</code> 中加入一个 <code>test</code> 脚本：</p><pre><code class=\"language-bash\">&nbsp; \"scripts\": {\n&nbsp; &nbsp; \"test\": \"jest\"\n&nbsp; },\n</code></pre><p>不论是否是CRA创建的React项目，只要装好了Jest，在单元测试的同时可以很方便的统计代码覆盖率。在 <code>package.json</code> 中加入一个 <code>cov</code> 脚本：</p><pre><code class=\"language-bash\">&nbsp; \"scripts\": {\n&nbsp; &nbsp; \"cov\": \"jest --coverage\"\n&nbsp; },\n</code></pre><p>运行 <code>npm run cov</code> 就可以看到覆盖率报告（好低）：</p><pre><code class=\"language-bash\">&nbsp;PASS&nbsp; src/App.test.js\n&nbsp; ✓ 渲染保存所有卡片按钮 (27 ms)\n\n-----------------|---------|----------|---------|---------|-------------------------\nFile&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s\n-----------------|---------|----------|---------|---------|-------------------------\nAll files&nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; &nbsp;39.21 |&nbsp; &nbsp; 35.29 |&nbsp; &nbsp;13.63 |&nbsp; &nbsp;40.81 |\n&nbsp;App.js&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; &nbsp;51.72 |&nbsp; &nbsp; &nbsp; &nbsp; 0 |&nbsp; &nbsp; &nbsp; 20 |&nbsp; &nbsp;55.55 | 34-40,44-49,57,60-61,66\n&nbsp;KanbanColumn.js |&nbsp; &nbsp;22.72 |&nbsp; &nbsp; &nbsp; &nbsp;40 |&nbsp; &nbsp; 8.33 |&nbsp; &nbsp;22.72 | 54,57-58,64-102\n-----------------|---------|----------|---------|---------|-------------------------\nTest Suites: 1 passed, 1 total\nTests:&nbsp; &nbsp; &nbsp; &nbsp;1 passed, 1 total\nSnapshots:&nbsp; &nbsp;0 total\nTime:&nbsp; &nbsp; &nbsp; &nbsp; 0.439 s, estimated 1 s\nRan all test suites.\n</code></pre><p>开发测试用例时，你可以参照单元测试的<a href=\"https://wiki.c2.com/?ArrangeActAssert\">3A模式</a><strong>：Arrange（准备）→ Act（动作）→ Assert（断言）</strong>。</p><h3>为React组件编写单元测试</h3><p>我们依旧以 <code>oh-my-kanban</code> 项目为例，学习一下如何为React组件编写单元测试。</p><p>虽然上节课添加E2E测试时创建了一个test目录，但建议把单元测试文件放在与被测试的源码文件尽量近的位置（但也不用像CRA默认的 <code>src/App.test.js</code> 那么近）。Jest鼓励把测试文件放在源码文件同级的 <code>__tests__</code> 目录下，后缀插入 <code>.test</code> ，那我们创建一个 <code>src/__tests__/KanbanNewCard.test.js</code> 文件，内容如下：</p><pre><code class=\"language-javascript\">import { act, fireEvent, render } from '@testing-library/react';\nimport KanbanNewCard from '../KanbanNewCard';\n\ndescribe('KanbanNewCard', () =&gt; {\n&nbsp; it('添加新卡片', async () =&gt; {\n&nbsp; &nbsp; // Arrange 准备\n&nbsp; &nbsp; const onSubmit = jest.fn();\n&nbsp; &nbsp; // Act 动作\n&nbsp; &nbsp; const { findByText, findByRole } = render(\n&nbsp; &nbsp; &nbsp; &lt;KanbanNewCard onSubmit={onSubmit} /&gt;\n&nbsp; &nbsp; );\n\n&nbsp; &nbsp; // Assert 断言\n&nbsp; &nbsp; const titleElem = await findByText('添加新卡片');\n&nbsp; &nbsp; expect(titleElem).toBeInTheDocument();\n\n&nbsp; &nbsp; const inputElem = await findByRole('textbox');\n&nbsp; &nbsp; expect(inputElem).toHaveFocus();\n\n&nbsp; &nbsp; // Act 动作\n&nbsp; &nbsp; act(() =&gt; {\n&nbsp; &nbsp; &nbsp; fireEvent.change(inputElem, { target: { value: '单元测试新卡片-1' } });\n&nbsp; &nbsp; &nbsp; fireEvent.keyDown(inputElem, { key: 'Enter' });\n&nbsp; &nbsp; });\n\n&nbsp; &nbsp; // Assert 断言\n&nbsp; &nbsp; expect(onSubmit).toHaveBeenCalledTimes(1);\n&nbsp; &nbsp; expect(onSubmit.mock.lastCall[0]).toHaveProperty('title', '单元测试新卡片-1');\n&nbsp; });\n});\n</code></pre><p>保存文件，Jest会自动执行：</p><pre><code class=\"language-bash\">&nbsp;PASS&nbsp; src/App.test.js\n&nbsp;PASS&nbsp; src/__tests__/KanbanNewCard.test.js\n\nTest Suites: 2 passed, 2 total\nTests:&nbsp; &nbsp; &nbsp; &nbsp;2 passed, 2 total\nSnapshots:&nbsp; &nbsp;0 total\nTime:&nbsp; &nbsp; &nbsp; &nbsp; 0.788 s, estimated 1 s\nRan all test suites.\n\nWatch Usage: Press w to show more.\n</code></pre><p>从代码可以看出，这个测试用例是典型的3A模式。测试用例it的回调函数是一个 <code>async</code> 异步函数，先用jest.fn()方法准备模拟函数 <code>onSubmit</code> ，然后用RTL提供的 <code>render</code>  API渲染 <code>KanbanNewCard</code> 组件，接着用 <code>render</code> 返回结果中的查询器，异步查找标题文字并断言标题被渲染出来了。</p><p>接下来的 <code>findByRole</code> 是RTL里比较有特色的一个方法。</p><p>RTL库的<a href=\"https://testing-library.com/docs/guiding-principles\">设计原则</a>是：“<strong>你的测试代码越是贴近软件的真实用法，你从测试中得到的信心就越足</strong>。”</p><p>所以RTL里的API设计，基本都<strong>不鼓励</strong>去深挖DOM结构这种实现细节。 <code>findByRole</code> 里的Role特指<a href=\"https://www.w3.org/TR/wai-aria-1.2/\">WAI-ARIA</a>，即W3C推出的富互联网应用可访问性标准中的Roles。HTML里包括 <code>&lt;input type=\"text\"&gt;</code> 在内的大部分标签都有默认的Role，比标签名本身更具业务意义，具体可以参考这个<a href=\"https://www.w3.org/TR/html-aria/#docconformance\">标准表格</a>。因为文本框默认 <code>role=\"textbox\"</code> ，而 <code>KanbanNewCard</code> 组件中只存在一个文本框，所以可以很容易定位到。</p><p>如果你实在手痒想用CSS选择器或者XPath来查找DOM节点，可以折中一下，为HTML标签加入 <code>data-testid</code> 。对，就是上节课E2E里用到的那个同款属性，然后调用RTL的 <code>findByTestId</code> 来查找。</p><p>定位到文本框，断言它已经获得了焦点，然后开始调用RTL的 <code>act</code>  API开展动作。先利用 <code>fireEvent</code> 输入一个卡片标题，然后回车。最后来断言一开始准备的模拟函数 <code>onSubmit</code> 被调用过一次，且参数包含刚输入的卡片标题。</p><p>到这里，你就完成了一个基础的React组件单元测试用例。除了这种<strong>预期路径（Happy Path）</strong>，你还需要编写一些<strong>负向的用例（Negative Cases）</strong>，用来测试出错的情况以及一些<strong>边界情况</strong>。</p><p>正如这节课一开始的前后两个分支的例子，如果用单元测试来覆盖，那我们需要分别编写A、B1、B2、C1、C2、D的单元测试，看似数量上比4条路径多，但开发和运行成本要低得多。</p><p>如果为 <code>src/App.js</code> 编写一个真正的单元测试，很难避免测试用例中会同时渲染子组件 <code>KanbanBoard</code> 和后代组件 <code>KanbanColumn</code> ，这是不是类似上节课提到的“ <code>App</code> 组件的可测试性有问题？”其实还好。</p><p>早期在React技术社区，开发者会利用一款测试框架Enzyme对组件做“浅渲染”，可以将渲染和测试的范围限制在 <code>App</code> 本身；而React进入新版后，开发者经常会遇到需要渲染稍微“深”一点的情况，原来的“浅渲染”不够灵活了。</p><p>现在更常见的方法，是利用Jest强大的模拟功能，将被测组件所导入的其他组件替换成简化的模拟版本，具体可以参考React官方文档的<a href=\"https://zh-hans.reactjs.org/docs/testing-recipes.html#mocking-modules\">Mock模块章节</a>。</p><h3>为Hooks编写单元测试</h3><p>这里简单提一下，如何为自定义Hooks编写单元测试。</p><p>因为自定义Hooks不能在React函数组件以外的环境中执行，所以首先需要创建一个封装器组件来调用自定义Hooks，在测试用例里渲染该组件后再做断言。RTL库团队曾推出一款开源库 <a href=\"https://github.com/testing-library/react-hooks-testing-library\">react-hooks-testing-library</a> ，封装了上面提到的逻辑，后来已经合并到RTL 13.1以上的版本中，成为了其中的 <code>renderHook</code>  API。</p><p>目前 <code>oh-my-kanban</code> 中没有自定义Hooks的例子，我们姑且看一下<a href=\"https://time.geekbang.org/column/article/579582\">第19节课</a>的 <code>useFetchBooks</code> ：</p><pre><code class=\"language-javascript\">const MagazineList = ({ categoryId }) =&gt; {\n&nbsp; const {\n&nbsp; &nbsp; books,\n&nbsp; &nbsp; isLoading,\n&nbsp; &nbsp; hasNextPage,\n&nbsp; &nbsp; onNextPage\n&nbsp; } = useFetchBooks(categoryId, '/api/magazines');\n  // ...\n</code></pre><p>为它开发一个单元测试，下面是部分代码：</p><pre><code class=\"language-javascript\">describe('useFetchBooks', () =&gt; {\n&nbsp; it('获取书籍列表', async () =&gt; {\n&nbsp; &nbsp; jest.spyOn(global, 'fetch').mockImplementation(() =&gt;\n&nbsp; &nbsp; &nbsp; Promise.resolve({\n&nbsp; &nbsp; &nbsp; &nbsp; json: () =&gt; Promise.resolve({\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; items: [\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { id: 1, title: '百年孤独' },\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { id: 2, title: '嫌疑人X的献身' },\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ], totalPages: 5\n&nbsp; &nbsp; &nbsp; &nbsp; })\n&nbsp; &nbsp; &nbsp; })\n&nbsp; &nbsp; );\n\n&nbsp; &nbsp; const { result, rerender } = renderHook(() =&gt; useFetchBooks(categoryId));\n&nbsp; &nbsp; const {\n&nbsp; &nbsp; &nbsp; books,\n&nbsp; &nbsp; &nbsp; isLoading,\n&nbsp; &nbsp; &nbsp; hasNextPage,\n&nbsp; &nbsp; &nbsp; onNextPage\n&nbsp; &nbsp; } = result.current;\n&nbsp; &nbsp; expect(/*...*/);\n\n&nbsp; &nbsp; global.fetch.mockRestore();\n&nbsp; });\n});\n</code></pre><p>单元测试是不应该有副作用的。从这段代码中，你可以看到在测试用例开头，先用 <code>jest.spyOn</code> 方法将全局的 <code>fetch</code> 方法替换成了模拟函数，经过动作、断言，最后要记得把被替换的全局 <code>fetch</code> 方法还原。否则，有可能影响到其他测试用例。</p><h2>小结</h2><p>这节课我们学习了测试金字塔的概念，认识到可以用更多的、成本更低的单元测试来弥补E2E覆盖不到的地方。然后我们学习了如何用Jest + RTL为React组件和Hooks编写单元测试。经过上节课和这节课的学习，我相信你对大中型React项目的质量保证有了一定的掌握。</p><p>比起“独狼”开发，在团队协作过程中，人与人交流频率会更高，信息失真也会成为问题，最终影响到开发效率和效果。包括自动化测试在内的现代前端工程化实践，就成为团队开发大中型React应用的必经之路。</p><p>下节课是这个专栏的最后一节正课内容，我会带着你总结一下前面的内容，然后为你介绍大型React应用项目中的团队协作和工程化。最后还会带来一个特别企划，请你跟我一起，以开源软件的方式合作开发一个大型React项目。</p><h2>思考题</h2><ol>\n<li>请你用学到的知识配合Jest和RTL的文档，为KanbanColumn写单元测试。</li>\n<li>请你复习一遍模块三的内容，想想每节课的知识点都在大中型React项目和团队协作中能发挥什么作用？</li>\n</ol><p>这节课内容就到这里，我们下节课不见不散！</p>","neighbors":{"left":{"article_title":"22｜质量保证（上）：每次上线都出Bug？你需要E2E测试","id":594428},"right":{"article_title":"24｜工程化与团队协作：让我们合作开发一个大型React项目","id":596369}},"comments":[{"had_liked":false,"id":360721,"user_name":"若尘","can_delete":false,"product_type":"c1","uid":1098239,"ip_address":"北京","ucode":"EAF8C2DDBB3A11","user_header":"https://static001.geekbang.org/account/avatar/00/10/c1/ff/c870b262.jpg","comment_is_top":false,"comment_ctime":1666780767,"is_pvip":false,"replies":[{"id":"131288","content":"你好，若尘，是的，《模块三》中第15到23节课的代码我还没有提交。其实这一模块的代码并不全是基于oh-my-kanban来写的，部分与oh-my-kanban相关的，每节课代码的前后关联性也不像《模块二》中那么强。所以我太不确定是否还有必要提交到代码仓库中，你觉得呢？<br><br>另外，模块三第24节课的开源项目代码已经发布到：<br><br>    https:&#47;&#47;gitee.com&#47;evisong&#47;geektime-column-oh-my-kit<br><br>非常欢迎你参与进来！","user_name":"作者回复","user_name_real":"编辑","uid":"1033973","ctime":1666954624,"ip_address":"北京","comment_id":360721,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1666780767","product_id":100119601,"comment_content":"大佬最近的代码是不是没有push呀","like_count":0,"discussions":[{"author":{"id":1033973,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c6/f5/dae613e0.jpg","nickname":"宋一玮","note":"","ucode":"55E5B710556C1E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591958,"discussion_content":"你好，若尘，是的，《模块三》中第15到23节课的代码我还没有提交。其实这一模块的代码并不全是基于oh-my-kanban来写的，部分与oh-my-kanban相关的，每节课代码的前后关联性也不像《模块二》中那么强。所以我太不确定是否还有必要提交到代码仓库中，你觉得呢？\n\n另外，模块三第24节课的开源项目代码已经发布到：\n\n    https://gitee.com/evisong/geektime-column-oh-my-kit\n\n非常欢迎你参与进来！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666954624,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}