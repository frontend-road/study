{"id":143669,"title":"33 | 存储数据结构之LSM","content":"<p><strong>课件和Demo地址</strong></p><p><a href=\"https://gitee.com/geektime-geekbang/geekbang-zk-course\">https://gitee.com/geektime-geekbang/geekbang-zk-course</a></p>","comments":[{"had_liked":false,"id":204278,"user_name":"顾渊离","can_delete":false,"product_type":"c3","uid":1636439,"ip_address":"","ucode":"2DFFFE80F21701","user_header":"https://static001.geekbang.org/account/avatar/00/18/f8/57/94ca9675.jpg","comment_is_top":false,"comment_ctime":1586359081,"is_pvip":false,"replies":[{"id":79209,"content":"在讲读操作的时候，我讲的有点简略，但是没有讲错。\n\n每个sstable里面保存的key是有序的。但是LSM引擎需要把memtable和所有sstable里面的key合并在一起，才能提证全局的key有序。\n\n读取一个sstable的时候，首先通过sstable的bloom filter(缓存在内存中)判断这个key是不是有可能在这个sstable中。如果bloom filter返回是，会在sstable的index(也缓存在内存中)里面进行查找。如果能在index里面找到，才会实际读取sstable里面的key-value数据。","user_name":"作者回复","user_name_real":"Geek_215586","uid":1591870,"ctime":1588558069,"ip_address":"","comment_id":204278,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100034201,"comment_content":"有的地方都讲错了，LSM引擎的key是有序的，每个sstable有自己维护的数据的key的范围，查找过成根本就不需要读取所有的sstable。\n","like_count":0,"discussions":[{"author":{"id":1591870,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJyDiaaDJrwRsdUia9HxA8EuWaDVLr4E1gMG5y2ZTxV7BNUhdNABCmH3GMZTzib796X5duibiaeuRmNXeg/132","nickname":"Geek_215586","note":"","ucode":"5916AC9CC5FBE2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491125,"discussion_content":"在讲读操作的时候，我讲的有点简略，但是没有讲错。\n\n每个sstable里面保存的key是有序的。但是LSM引擎需要把memtable和所有sstable里面的key合并在一起，才能提证全局的key有序。\n\n读取一个sstable的时候，首先通过sstable的bloom filter(缓存在内存中)判断这个key是不是有可能在这个sstable中。如果bloom filter返回是，会在sstable的index(也缓存在内存中)里面进行查找。如果能在index里面找到，才会实际读取sstable里面的key-value数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588558069,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1487584,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b2/e0/d856f5a4.jpg","nickname":"余松","note":"","ucode":"89EC9CE3AD0281","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":254795,"discussion_content":"你可能理解有些问题加上老师讲得太一笔带过没有深入。每一个SSTable中的key是排序的可以进行范围查找，但是每一个SSTable并不包含所有的key（比如最新的一个SSTable文件中并不包含很久没更新的key了），这个时候我们查找某一个key的顺序就是先在内存表中查找，然后依次按时间逆序查找SSTable的文件，查询到了就返回（因为新文件中的key肯定比老文件中相同key的value更新）。最坏的情况就是这个Key不存在，要查询所有的SSTable才发现key在所有SSTable中不存在。所以才有了老师讲的布隆过滤器解决这个情况。\n为了进一步优化要查询多个SStable才能查找到指定key的情况，LSM会在后台合并SSTable文件，合并后扩大了一个文件的key的范围，可以贴近你说的再单个文件中查找指定范围的key的目标，但由于LSM的设计理念就是日志的分段与压缩提高效率，不太可能最终只有一个文件，所以某些情况还是需要遍历多个文件。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1588344260,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":278863,"user_name":"Geek_zbvt62","can_delete":false,"product_type":"c3","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/d28174a9.jpg","comment_is_top":false,"comment_ctime":1613397375,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100034201,"comment_content":"我反倒觉得LSM讲得没啥问题。\n但与B+树的对比的部分，有值得提醒一下的地方。课程中描述的是纯B+树，但数据库具体实现时一般也带着WAL，写操作时也是写WAL，更新内存，脏页刷盘大多也是后台完成。","like_count":2}]}