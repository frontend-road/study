{"id":264179,"title":"11 | 实战案例：使用Spring Security搭建一套基于JWT的OAuth 2.0架构","content":"<p>你好，我朱晔，是<a href=\"https://time.geekbang.org/column/intro/294\">《Java业务开发常见错误100例》</a>专栏课程的作者。</p><p>《OAuth 2.0实战课》上线之后，我也第一时间关注了这门课。在开篇词中，我看到有一些同学留言问道：“如何使用Spring Security来实现OAuth 2.0？”这时，我想到之前自己写过一篇相关的文章，于是就直接在开篇词下留了言。后面我很快收到了不少用户的点赞和肯定，紧接着极客时间编辑也邀请我从自己的角度为专栏写篇加餐。好吧，功不唐捐，于是我就将之前我写的那篇老文章再次迭代、整理为今天的这一讲内容，希望可以帮助你掌握OAuth 2.0。</p><p>如果你熟悉Spring Security的话，肯定知道它因为功能多、组件抽象程度高、配置方式多样，导致了强大且复杂的特性。也因此，Spring Security的学习成本几乎是Spring家族中最高的。但不仅于此，在结合实际的复杂业务场景使用Spring Security时，我们还要去理解一些组件的工作原理和流程，不然需要自定义和扩展框架的时候就会手足无措。这就让使用Spring Security的门槛更高了。</p><p>因此，在决定使用Spring Security搭建整套安全体系（授权、认证、权限、审计）之前，我们还需要考虑的是：将来我们的业务会多复杂，徒手写一套安全体系来得划算，还是使用Spring Security更好？我相信，这也是王老师给出课程配套代码中，并没有使用Spring Security来演示OAuth 2.0流程的原因之一。</p><!-- [[[read_end]]] --><p>反过来说，如果你的应用已经使用了Spring Security来做鉴权、认证和权限管理的话，那么仍然使用Spring Security来实现OAuth的成本是很低的。而且，在学习了OAuth 2.0的流程打下扎实的基础之后，我们再使用Spring Security来配置OAuth 2.0就不会那么迷茫了。这也是我在工作中使用Spring Security来实现OAuth 2.0的直观感受。</p><p>所以，我就结合自己的实践和积累，带你使用Spring Security来一步一步地搭建一套基于JWT的OAuth 2.0授权体系。这些内容会涉及OAuth 2.0的三角色（客户端、授权服务、受保护资源），以及资源拥有者凭据许可、客户端凭据许可和授权码许可这三种常用的授权许可类型（隐式许可类型，不太安全也不太常用）。同时，我还会演示OAuth 2.0的权限控制，以及使用OAuth 2.0实现SSO单点登录体系。</p><p>这样一来，今天这一讲涉及到的流程就会比较多，内容也会很长。不过不用担心，我会手把手带你从零开始，完成整个程序的搭建，并给出所有流程的演示。</p><h2>项目准备工作</h2><p>实战之前，我们先来搭建项目父依赖和初始化数据库结构，为后面具体的编码做准备。</p><p>首先，我们来创建一个父POM，内含三个模块：</p><ul>\n<li>springsecurity101-cloud-oauth2-client，用来扮演客户端角色；</li>\n<li>springsecurity101-cloud-oauth2-server，用来扮演授权服务器角色；</li>\n<li>springsecurity101-cloud-oauth2-userservice，是用户服务，用来扮演资源提供者角色。</li>\n</ul><pre><code>&lt;project xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;me.josephzhu&lt;/groupId&gt;\n    &lt;artifactId&gt;springsecurity101&lt;/artifactId&gt;\n    &lt;packaging&gt;pom&lt;/packaging&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;2.2.1.RELEASE&lt;/version&gt;\n        &lt;relativePath/&gt;\n    &lt;/parent&gt;\n\n    &lt;modules&gt;\n        &lt;module&gt;springsecurity101-cloud-oauth2-client&lt;/module&gt;\n        &lt;module&gt;springsecurity101-cloud-oauth2-server&lt;/module&gt;\n        &lt;module&gt;springsecurity101-cloud-oauth2-userservice&lt;/module&gt;\n    &lt;/modules&gt;\n\n    &lt;properties&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n    &lt;/properties&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n            &lt;optional&gt;true&lt;/optional&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;dependencyManagement&gt;\n        &lt;dependencies&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;\n                &lt;version&gt;Greenwich.SR4&lt;/version&gt;\n                &lt;type&gt;pom&lt;/type&gt;\n                &lt;scope&gt;import&lt;/scope&gt;\n            &lt;/dependency&gt;\n        &lt;/dependencies&gt;\n    &lt;/dependencyManagement&gt;\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n&lt;/project&gt;\n</code></pre><p>然后，我们来创建一个oauth数据库，初始化将来会用到的5个表。</p><ul>\n<li>authorities表：记录账号的权限，需要我们在后面配置。</li>\n<li>oauth_approvals表：记录授权批准的状态。</li>\n<li>oauth_client_details表：记录OAuth的客户端，需要我们在后面做配置。</li>\n<li>oauth_code表：记录授权码。</li>\n<li>users表：记录账号，需要我们在后面做初始化。</li>\n</ul><pre><code>SET NAMES utf8mb4;\nSET FOREIGN_KEY_CHECKS = 0;\n\n-- ----------------------------\n-- Table structure for authorities\n-- ----------------------------\nDROP TABLE IF EXISTS `authorities`;\nCREATE TABLE `authorities` (\n  `username` varchar(50) NOT NULL,\n  `authority` varchar(50) NOT NULL,\n  UNIQUE KEY `ix_auth_username` (`username`,`authority`),\n  CONSTRAINT `fk_authorities_users` FOREIGN KEY (`username`) REFERENCES `users` (`username`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n\n-- ----------------------------\n-- Table structure for oauth_approvals\n-- ----------------------------\nDROP TABLE IF EXISTS `oauth_approvals`;\nCREATE TABLE `oauth_approvals` (\n  `userId` varchar(256) DEFAULT NULL,\n  `clientId` varchar(256) DEFAULT NULL,\n  `partnerKey` varchar(32) DEFAULT NULL,\n  `scope` varchar(256) DEFAULT NULL,\n  `status` varchar(10) DEFAULT NULL,\n  `expiresAt` datetime DEFAULT NULL,\n  `lastModifiedAt` datetime DEFAULT NULL\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n-- ----------------------------\n-- Table structure for oauth_client_details\n-- ----------------------------\nDROP TABLE IF EXISTS `oauth_client_details`;\nCREATE TABLE `oauth_client_details` (\n  `client_id` varchar(255) NOT NULL,\n  `resource_ids` varchar(255) DEFAULT NULL,\n  `client_secret` varchar(255) DEFAULT NULL,\n  `scope` varchar(255) DEFAULT NULL,\n  `authorized_grant_types` varchar(255) DEFAULT NULL,\n  `web_server_redirect_uri` varchar(255) DEFAULT NULL,\n  `authorities` varchar(255) DEFAULT NULL,\n  `access_token_validity` int(11) DEFAULT NULL,\n  `refresh_token_validity` int(11) DEFAULT NULL,\n  `additional_information` varchar(4096) DEFAULT NULL,\n  `autoapprove` varchar(255) DEFAULT NULL,\n  PRIMARY KEY (`client_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n\n-- ----------------------------\n-- Table structure for oauth_code\n-- ----------------------------\nDROP TABLE IF EXISTS `oauth_code`;\nCREATE TABLE `oauth_code` (\n  `code` varchar(255) DEFAULT NULL,\n  `authentication` blob\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n\n-- ----------------------------\n-- Table structure for users\n-- ----------------------------\nDROP TABLE IF EXISTS `users`;\nCREATE TABLE `users` (\n  `username` varchar(50) NOT NULL,\n  `password` varchar(100) NOT NULL,\n  `enabled` tinyint(1) NOT NULL,\n  PRIMARY KEY (`username`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n\nSET FOREIGN_KEY_CHECKS = 1;\n</code></pre><p>这5个表是Spring Security OAuth需要用到的存储表，我们不要去修改既有的表结构。这里可以看到，我们并没有在数据库中创建相应的表，来存放访问令牌和刷新令牌。这是因为，我们之后的实现会使用JWT来传输令牌信息，以便进行本地校验，所以并不一定要将其存放到数据库中。基本上所有的这些表都是可以自己扩展的，只需要继承实现Spring的一些既有类即可，这里不做展开。</p><p>接下来，我们开始搭建授权服务器和受保护资源服务器。</p><h2>搭建授权服务器</h2><p>我们先创建第一个模块，也就是授权服务器。首先创建POM，配置依赖：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;parent&gt;\n        &lt;artifactId&gt;springsecurity101&lt;/artifactId&gt;\n        &lt;groupId&gt;me.josephzhu&lt;/groupId&gt;\n        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n    &lt;/parent&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;artifactId&gt;springsecurity101-cloud-oauth2-server&lt;/artifactId&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/project&gt;\n</code></pre><p>这里，我们使用了Spring Cloud的spring-cloud-starter-oauth2组件，而不是直接使用的Spring Security，因为前者做了一些自动化配置的工作，使用起来会更方便。</p><p>此外，我们还在POM中加入了数据访问、Web等依赖，因为我们的受保护资源服务器需要使用数据库来保存客户端的信息、用户信息等数据，同时也会引入thymeleaf模板引擎依赖，来稍稍美化一下登录页面。</p><p>然后创建一个配置文件application.yml实现程序配置：</p><pre><code>server:\n  port: 8080\n\nspring:\n  application:\n    name: oauth2-server\n  datasource:\n    url: jdbc:mysql://localhost:6657/oauth?useSSL=false\n    username: root\n    password: kIo9u7Oi0eg\n    driver-class-name: com.mysql.jdbc.Driver\n</code></pre><p>可以看到，我们配置了oauth数据库的连接字符串，定义了授权服务器的监听端口是8080。</p><p>最后，使用keytool工具生成密钥对，把密钥文件jks保存到资源目录下，并要导出一个公钥留作以后使用。</p><p>以上完成了项目框架搭建工作，接下来，我们正式开始编码。</p><p>第一步，创建一个最核心的类用于配置授权服务器。我把每段代码的作用放在了注释里，你可以直接看下。</p><pre><code>@Configuration\n@EnableAuthorizationServer //开启授权服务器\npublic class OAuth2ServerConfiguration extends AuthorizationServerConfigurerAdapter {\n    @Autowired\n    private DataSource dataSource;\n    @Autowired\n    private AuthenticationManager authenticationManager;\n\n    /**\n     * 我们配置了使用数据库来维护客户端信息。虽然在各种Demo中我们经常看到的是在内存中维护客户端信息，通过配置直接写死在这里。\n     * 但是，对于实际的应用我们一般都会用数据库来维护这个信息，甚至还会建立一套工作流来允许客户端自己申请ClientID，实现OAuth客户端接入的审批。\n     * @param clients\n     * @throws Exception\n     */\n    @Override\n    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {\n        clients.jdbc(dataSource);\n    }\n\n    /**\n     * 这里干了两件事儿。首先，打开了验证Token的访问权限（以便之后我们演示）。\n     * 然后，允许ClientSecret明文方式保存，并且可以通过表单提交（而不仅仅是Basic Auth方式提交），之后会演示到这个。\n     * @param security\n     * @throws Exception\n     */\n    @Override\n    public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {\n        security.checkTokenAccess(&quot;permitAll()&quot;)\n                .allowFormAuthenticationForClients().passwordEncoder(NoOpPasswordEncoder.getInstance());\n    }\n\n    /**\n     * 干了以下4件事儿：\n     * 1. 配置我们的令牌存放方式为JWT方式，而不是内存、数据库或Redis方式。\n     * JWT是Json Web Token的缩写，也就是使用JSON数据格式包装的令牌，由.号把整个JWT分隔为头、数据体、签名三部分。\n     * JWT保存Token虽然易于使用但是不是那么安全，一般用于内部，且需要走HTTPS并配置比较短的失效时间。\n     * 2. 配置JWT Token的非对称加密来进行签名\n     * 3. 配置一个自定义的Token增强器，把更多信息放入Token中\n     * 4. 配置使用JDBC数据库方式来保存用户的授权批准记录\n     * @param endpoints\n     * @throws Exception\n     */\n    @Override\n    public void configure(AuthorizationServerEndpointsConfigurer endpoints) {\n        TokenEnhancerChain tokenEnhancerChain = new TokenEnhancerChain();\n        tokenEnhancerChain.setTokenEnhancers(\n                Arrays.asList(tokenEnhancer(), jwtTokenEnhancer()));\n\n        endpoints.approvalStore(approvalStore())\n                .authorizationCodeServices(authorizationCodeServices())\n                .tokenStore(tokenStore())\n                .tokenEnhancer(tokenEnhancerChain)\n                .authenticationManager(authenticationManager);\n    }\n\n    /**\n     * 使用JDBC数据库方式来保存授权码\n     * @return\n     */\n    @Bean\n    public AuthorizationCodeServices authorizationCodeServices() {\n        return new JdbcAuthorizationCodeServices(dataSource);\n    }\n\n    /**\n     * 使用JWT存储\n     * @return\n     */\n    @Bean\n    public TokenStore tokenStore() {\n        return new JwtTokenStore(jwtTokenEnhancer());\n    }\n\n    /**\n     * 使用JDBC数据库方式来保存用户的授权批准记录\n     * @return\n     */\n    @Bean\n    public JdbcApprovalStore approvalStore() {\n        return new JdbcApprovalStore(dataSource);\n    }\n\n    /**\n     * 自定义的Token增强器，把更多信息放入Token中\n     * @return\n     */\n    @Bean\n    public TokenEnhancer tokenEnhancer() {\n        return new CustomTokenEnhancer();\n    }\n\n    /**\n     * 配置JWT使用非对称加密方式来验证\n     * @return\n     */\n    @Bean\n    protected JwtAccessTokenConverter jwtTokenEnhancer() {\n        KeyStoreKeyFactory keyStoreKeyFactory = new KeyStoreKeyFactory(new ClassPathResource(&quot;jwt.jks&quot;), &quot;mySecretKey&quot;.toCharArray());\n        JwtAccessTokenConverter converter = new JwtAccessTokenConverter();\n        converter.setKeyPair(keyStoreKeyFactory.getKeyPair(&quot;jwt&quot;));\n        return converter;\n    }\n\n    /**\n     * 配置登录页面的视图信息（其实可以独立一个配置类，这样会更规范）\n     */\n    @Configuration\n    static class MvcConfig implements WebMvcConfigurer {\n        @Override\n        public void addViewControllers(ViewControllerRegistry registry) {\n            registry.addViewController(&quot;login&quot;).setViewName(&quot;login&quot;);\n        }\n    }\n}\n</code></pre><p>第二步，还记得吗，刚才在第一步的代码中我们还用到了一个自定义的Token增强器，把用户信息嵌入到JWT Token中去（如果使用的是客户端凭据许可类型，这段代码无效，因为和用户没关系）。</p><p>这是一个常见需求。因为，默认情况下Token中只会有用户名这样的基本信息，我们往往需要把关于用户的更多信息返回给客户端（在实际应用中，你可能会从数据库或外部服务查询更多的用户信息加入到JWT Token中去）。这个时候，我们就可以自定义增强器来丰富Token的内容：</p><pre><code>public class CustomTokenEnhancer implements TokenEnhancer {\n\n    @Override\n    public OAuth2AccessToken enhance(OAuth2AccessToken accessToken, OAuth2Authentication authentication) {\n        Authentication userAuthentication = authentication.getUserAuthentication();\n        if (userAuthentication != null) {\n            Object principal = authentication.getUserAuthentication().getPrincipal();\n            //把用户标识嵌入JWT Token中去(Key是userDetails)\n            Map&lt;String, Object&gt; additionalInfo = new HashMap&lt;&gt;();\n            additionalInfo.put(&quot;userDetails&quot;, principal);\n            ((DefaultOAuth2AccessToken) accessToken).setAdditionalInformation(additionalInfo);\n        }\n        return accessToken;\n    }\n}\n</code></pre><p>第三步，实现安全方面的配置。你可以直接看下代码注释，来了解关键代码的作用。</p><pre><code>@Configuration\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n    @Autowired\n    private DataSource dataSource;\n\n    @Override\n    @Bean\n    public AuthenticationManager authenticationManagerBean() throws Exception {\n        return super.authenticationManagerBean();\n    }\n\n    /**\n     * 配置用户账户的认证方式。显然，我们把用户存在了数据库中希望配置JDBC的方式。\n     * 此外，我们还配置了使用BCryptPasswordEncoder哈希来保存用户的密码（生产环境中，用户密码肯定不能是明文保存的）\n     * @param auth\n     * @throws Exception\n     */\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        auth.jdbcAuthentication()\n                .dataSource(dataSource)\n                .passwordEncoder(new BCryptPasswordEncoder());\n    }\n\n    /**\n     * 开放/login和/oauth/authorize两个路径的匿名访问。前者用于登录，后者用于换授权码，这两个端点访问的时机都在登录之前。\n     * 设置/login使用表单验证进行登录。\n     * @param http\n     * @throws Exception\n     */\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.authorizeRequests()\n                .antMatchers(&quot;/login&quot;, &quot;/oauth/authorize&quot;)\n                .permitAll()\n                .anyRequest().authenticated()\n                .and()\n                .formLogin().loginPage(&quot;/login&quot;);\n    }\n}\n</code></pre><p>第四步，在资源目录下创建一个templates文件夹，然后创建一个login.html登录页：</p><pre><code>&lt;body class=&quot;uk-height-1-1&quot;&gt;\n\n&lt;div class=&quot;uk-vertical-align uk-text-center uk-height-1-1&quot;&gt;\n    &lt;div class=&quot;uk-vertical-align-middle&quot; style=&quot;width: 250px;&quot;&gt;\n        &lt;h1&gt;Login Form&lt;/h1&gt;\n\n        &lt;p class=&quot;uk-text-danger&quot; th:if=&quot;${param.error}&quot;&gt;\n            用户名或密码错误...\n        &lt;/p&gt;\n\n        &lt;form class=&quot;uk-panel uk-panel-box uk-form&quot; method=&quot;post&quot; th:action=&quot;@{/login}&quot;&gt;\n            &lt;div class=&quot;uk-form-row&quot;&gt;\n                &lt;input class=&quot;uk-width-1-1 uk-form-large&quot; type=&quot;text&quot; placeholder=&quot;Username&quot; name=&quot;username&quot;\n                       value=&quot;reader&quot;/&gt;\n            &lt;/div&gt;\n            &lt;div class=&quot;uk-form-row&quot;&gt;\n                &lt;input class=&quot;uk-width-1-1 uk-form-large&quot; type=&quot;password&quot; placeholder=&quot;Password&quot; name=&quot;password&quot;\n                       value=&quot;reader&quot;/&gt;\n            &lt;/div&gt;\n            &lt;div class=&quot;uk-form-row&quot;&gt;\n                &lt;button class=&quot;uk-width-1-1 uk-button uk-button-primary uk-button-large&quot;&gt;Login&lt;/button&gt;\n            &lt;/div&gt;\n        &lt;/form&gt;\n\n    &lt;/div&gt;\n&lt;/div&gt;\n&lt;/body&gt;\n</code></pre><p>至此，授权服务器的编码工作就完成了。</p><h2>搭建受保护资源服务器</h2><p>接下来，我们搭建一个用户服务模拟资源提供者（受保护资源服务器）。我们先看看项目初始化工作。</p><p>这次创建的POM没有什么特殊，依赖了spring-cloud-starter-oauth2：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;parent&gt;\n        &lt;artifactId&gt;springsecurity101&lt;/artifactId&gt;\n        &lt;groupId&gt;me.josephzhu&lt;/groupId&gt;\n        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n    &lt;/parent&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;artifactId&gt;springsecurity101-cloud-oauth2-userservice&lt;/artifactId&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/project&gt;\n</code></pre><p>配置文件非常简单，只是声明了资源服务端口为8081：</p><pre><code>server:\n  port: 8081\n</code></pre><p>同时，还要记得把我们之前在项目准备工作时生成的密钥对的公钥命名为public.cert，并放到资源文件下。这样，资源服务器可以本地校验JWT的合法性。内容大概是这样的：</p><pre><code>-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwR84LFHwnK5GXErnwkmD\nmPOJl4CSTtYXCqmCtlbF+5qVOosu0YsM2DsrC9O2gun6wVFKkWYiMoBSjsNMSI3Z\nw5JYgh+ldHvA+MIex2QXfOZx920M1fPUiuUPgmnTFS+Z3lmK3/T6jJnmciUPY1pe\nh4MXL6YzeI0q4W9xNBBeKT6FDGpduc0FC3OlXHfLbVOThKmAUpAWFDwf9/uUA//l\n3PLchmV6VwTcUaaHp5W8Af/GU4lPGZbTAqOxzB9ukisPFuO1DikacPhrOQgdxtqk\nLciRTa884uQnkFwSguOEUYf3ni8GNRJauIuW0rVXhMOs78pKvCKmo53M0tqeC6ul\n+QIDAQAB\n-----END PUBLIC KEY-----\n</code></pre><p>好了，让我们正式开始编码吧。</p><p>第一步，创建一个可以匿名访问的接口GET /hello，用来测试无需登录就可以访问的服务端资源：</p><pre><code>@RestController\npublic class HelloController {\n    @GetMapping(&quot;hello&quot;)\n    public String hello() {\n        return &quot;Hello&quot;;\n    }\n}\n</code></pre><p>第二步，创建三个需要登录+授权才能访问到的接口。我们通过@PreAuthorize在方法执行前进行权限控制：</p><ul>\n<li>GET /user/name接口，读权限或写权限可访问，返回登录用户名；</li>\n<li>GET /user接口，读权限或写权限可访问，返回登录用户信息；</li>\n<li>POST /user接口，只有写权限可以访问，返回访问令牌中的额外信息（也就是自定义的Token增强器CustomTokenEnhancer加入到访问令牌中的额外信息，Key是userDetails），这里也演示了使用TokenStore来解析Token的方式。</li>\n</ul><pre><code>@RestController\n@RequestMapping(&quot;user&quot;)\npublic class UserController {\n\n    @Autowired\n    private TokenStore tokenStore;\n\n    /***\n     * 读权限或写权限可访问，返回登录用户名\n     * @param authentication\n     * @return\n     */\n    @PreAuthorize(&quot;hasAuthority('READ') or hasAuthority('WRITE')&quot;)\n    @GetMapping(&quot;name&quot;)\n    public String name(OAuth2Authentication authentication) {\n        return authentication.getName();\n    }\n\n    /**\n     * 读权限或写权限可访问，返回登录用户信息\n     * @param authentication\n     * @return\n     */\n    @PreAuthorize(&quot;hasAuthority('READ') or hasAuthority('WRITE')&quot;)\n    @GetMapping\n    public OAuth2Authentication read(OAuth2Authentication authentication) {\n        return authentication;\n    }\n\n    /**\n     * 只有写权限可以访问，返回访问令牌中的额外信息\n     * @param authentication\n     * @return\n     */\n    @PreAuthorize(&quot;hasAuthority('WRITE')&quot;)\n    @PostMapping\n    public Object write(OAuth2Authentication authentication) {\n        OAuth2AuthenticationDetails details = (OAuth2AuthenticationDetails) authentication.getDetails();\n        OAuth2AccessToken accessToken = tokenStore.readAccessToken(details.getTokenValue());\n        return accessToken.getAdditionalInformation().getOrDefault(&quot;userDetails&quot;, null);\n    }\n}\n</code></pre><p>第三步，创建核心的资源服务器配置类。这里我们需要注意下面两点：</p><ul>\n<li>我们硬编码了资源服务器的ID为userservice；</li>\n<li>现在我们使用的是不落数据库的JWT方式+非对称加密，需要通过本地公钥进行验证，因此在这里我们配置了公钥的路径。</li>\n</ul><pre><code>@Configuration\n@EnableResourceServer //启用资源服务器\n@EnableGlobalMethodSecurity(prePostEnabled = true) //启用方法注解方式来进行权限控制\npublic class ResourceServerConfiguration extends ResourceServerConfigurerAdapter {\n\n    /**\n     * 声明了资源服务器的ID是userservice，声明了资源服务器的TokenStore是JWT\n     * @param resources\n     * @throws Exception\n     */\n    @Override\n    public void configure(ResourceServerSecurityConfigurer resources) throws Exception {\n        resources.resourceId(&quot;userservice&quot;).tokenStore(tokenStore());\n    }\n\n    /**\n     * 配置TokenStore\n     * @return\n     */\n    @Bean\n    public TokenStore tokenStore() {\n        return new JwtTokenStore(jwtAccessTokenConverter());\n    }\n\n    /**\n     * 配置公钥\n     * @return\n     */\n    @Bean\n    protected JwtAccessTokenConverter jwtAccessTokenConverter() {\n        JwtAccessTokenConverter converter = new JwtAccessTokenConverter();\n        Resource resource = new ClassPathResource(&quot;public.cert&quot;);\n        String publicKey = null;\n        try {\n            publicKey = new String(FileCopyUtils.copyToByteArray(resource.getInputStream()));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        converter.setVerifierKey(publicKey);\n        return converter;\n    }\n\n    /**\n     * 配置了除了/user路径之外的请求可以匿名访问\n     * @param http\n     * @throws Exception\n     */\n    @Override\n    public void configure(HttpSecurity http) throws Exception {\n        http.authorizeRequests()\n                .antMatchers(&quot;/user/**&quot;).authenticated()\n                .anyRequest().permitAll();\n    }\n}    \n</code></pre><p>到这里，我们来想一下，如果授权服务器产生Token的话，受保护资源服务器必须要有一种办法来验证Token，那如果这里的Token不是JWT的方式，我们可以怎么办呢？</p><p>我来说下我的方法吧：</p><ul>\n<li>首先，Token可以保存在数据库或Redis中，资源服务器和授权服务器共享底层的TokenStore来验证；</li>\n<li>然后，资源服务器可以使用RemoteTokenServices，来从授权服务器的/oauth/check_token端点进行Token校验。</li>\n</ul><p>到这里，资源服务器就配置完成了，我们还在资源服务器中分别创建了两个控制器HelloController和UserController，用于分别测试可以匿名访问以及受到权限保护的资源。</p><h2>初始化数据配置</h2><p>在实现了授权服务器和受保护资源服务器代码后，我们再来初始化oauth数据库的数据就非常容易理解了。总结起来，我们需要配置用户、权限和客户端三部分。</p><ol>\n<li>配置两个用户。其中，读用户reader具有读权限，密码为reader；写用户writer具有读写权限，密码为writer。还记得吗，密码我们使用的是BCryptPasswordEncoder加密（准确说是哈希）？</li>\n</ol><pre><code>INSERT INTO `users` VALUES ('reader', '$2a$04$C6pPJvC1v6.enW6ZZxX.luTdpSI/1gcgTVN7LhvQV6l/AfmzNU/3i', 1);\nINSERT INTO `users` VALUES ('writer', '$2a$04$M9t2oVs3/VIreBMocOujqOaB/oziWL0SnlWdt8hV4YnlhQrORA0fS', 1);\n</code></pre><ol start=\"2\">\n<li>配置两个权限，也就是配置reader用户具有读权限，writer用户具有写权限：</li>\n</ol><pre><code>INSERT INTO `authorities` VALUES ('reader', 'READ');\nINSERT INTO `authorities` VALUES ('writer', 'READ,WRITE');\n</code></pre><ol start=\"3\">\n<li>配置三个客户端，其中客户端userservice1使用资源拥有者凭据许可类型，客户端userservice2使用客户端凭据许可类型，客户端userservice3使用授权码许可类型。</li>\n</ol><pre><code>INSERT INTO `oauth_client_details` VALUES ('userservice1', 'userservice', '1234', 'FOO', 'password,refresh_token', '', 'READ,WRITE', 7200, NULL, NULL, 'true');\nINSERT INTO `oauth_client_details` VALUES ('userservice2', 'userservice', '1234', 'FOO', 'client_credentials,refresh_token', '', 'READ,WRITE', 7200, NULL, NULL, 'true');\nINSERT INTO `oauth_client_details` VALUES ('userservice3', 'userservice', '1234', 'FOO', 'authorization_code,refresh_token', 'https://baidu.com,http://localhost:8082/ui/login,http://localhost:8083/ui/login,http://localhost:8082/ui/remoteCall', 'READ,WRITE', 7200, NULL, NULL, 'false');\n</code></pre><p>值得说明的是：</p><ul>\n<li>三个客户端账号能使用的资源ID都是userservice，对应我们受保护资源服务器刚才配置的资源ID，也就是userservice，这两者需要一致。</li>\n<li>三个客户端账号的密码都是1234。</li>\n<li>三个客户端账号的授权范围都是FOO（并不是关键信息），它们可以拿到的权限是读写。不过，对于和用户相关的授权许可类型（比如资源拥有者凭据许可、授权码许可），最终拿到的权限还取决于客户端权限和用户权限的交集。</li>\n<li>通过grant_types字段配置支持不同的授权许可类型。这里为了便于测试观察，我们给三个客户端账号各自配置了一种授权许可类型；在实际业务场景中，你完全可以为同一个客户端配置支持OAuth 2.0的四种授权许可类型。</li>\n<li>userservice1和userservice2我们配置了用户自动批准授权（不会弹出一个页面要求用户进行授权）。</li>\n</ul><h2>演示三种授权许可类型</h2><p>到这里，授权服务器和受保护资源服务器程序都搭建完成了，数据库也配置了用于测试的用户、权限和客户端。接下来，我们就使用Postman来手工测试一下OAuth 2.0的授权码许可、资源拥有者凭据许可、客户端凭据许可这三种授权许可类型吧。</p><h3>资源拥有者凭据许可类型</h3><p>首先，我们测试的是资源拥有者凭据许可，POST请求地址是：</p><pre><code>http://localhost:8080/oauth/token?grant_type=password&amp;client_id=userservice1&amp;client_secret=1234&amp;username=writer&amp;password=writer\n</code></pre><p>得到如下图所示结果：</p><p><img src=\"https://static001.geekbang.org/resource/image/18/e4/18cd7b24ff152e28806b1176b0a560e4.png?wh=2548*1794\" alt=\"\"></p><p>再使用<a href=\"http://jwt.io/\">JWT解析工具</a>看下请求Token中的信息：</p><p><img src=\"https://static001.geekbang.org/resource/image/8e/7e/8e4c2dd1931a31197df55cc251b2a07e.png?wh=3006*1482\" alt=\"\"></p><p>可以看到，Token中果然包含了Token增强器加入的userDetails自定义信息。如果我们把公钥粘贴到页面的话，可以看到这个JWT校验成功了：</p><p><img src=\"https://static001.geekbang.org/resource/image/4d/ae/4d701319144d3de7c5d743f59e4991ae.png?wh=3054*1408\" alt=\"\"></p><p>除了本地校验外，还可以访问授权服务器来校验JWT：</p><pre><code>http://localhost:8080/oauth/check_token?client_id=userservice1&amp;client_secret=1234&amp;token=...\n</code></pre><p>得到如下结果：</p><p><img src=\"https://static001.geekbang.org/resource/image/28/95/2835c0d2b49ac515c9f6c537dd2f7195.png?wh=2552*1730\" alt=\"\"></p><h3>客户端授权许可类型</h3><p>我们再来测试下客户端授权许可类型。POST请求地址：</p><pre><code>http://localhost:8080/oauth/token?grant_type=client_credentials&amp;client_id=userservice2&amp;client_secret=1234\n</code></pre><p>如下图所示，可以直接拿到Token：</p><p><img src=\"https://static001.geekbang.org/resource/image/81/e9/81722855fd6935aea594ec62b64bf0e9.png?wh=2546*1014\" alt=\"\"></p><p>这里需要注意的是，并没有提供刷新令牌。这是因为，刷新令牌用于避免访问令牌失效后需要用户再次登录的问题，而客户端授权许可类型没有用户的概念，因此没有刷新令牌，也无法注入额外的userDetails信息。</p><p><img src=\"https://static001.geekbang.org/resource/image/fc/da/fcf2b1c1a53ecc33d3a0abc72b6d83da.png?wh=3024*1636\" alt=\"\"></p><p>也可以试一下，如果我们的授权服务器没有开启allowFormAuthenticationForClients参数（允许表单提交认证）的话，客户端的凭证需要通过Basic Auth传过去而不是通过Post：</p><p><img src=\"https://static001.geekbang.org/resource/image/ce/6f/ce391c3c93e2131e1cf8fb4e3324b66f.png?wh=2544*1330\" alt=\"\"></p><h3>授权码许可类型</h3><p>最后，我们来测试下比较复杂的授权码许可。</p><p><strong>第一步</strong>，打开浏览器访问地址：</p><pre><code>http://localhost:8080/oauth/authorize?response_type=code&amp;client_id=userservice3&amp;redirect_uri=https://baidu.com\n</code></pre><p>注意，客户端跳转地址需要和数据库中配置的一致（百度的URL <a href=\"https://baidu.com\">https://baidu.com</a></p><p>我们之前已经在数据库中有配置了）。访问后页面会直接跳转到登录界面，我们使用用户名“reader”、密码“reader”来登录：</p><p><img src=\"https://static001.geekbang.org/resource/image/73/11/73c3bd926e4e350b220447cd8b97d811.png?wh=2212*1424\" alt=\"\"></p><p>由于我们在数据库中设置的是禁用自动批准授权的模式，所以登录后来到了批准界面：</p><p><img src=\"https://static001.geekbang.org/resource/image/9c/01/9cac3b06b632220166d7e43607da4901.png?wh=2114*548\" alt=\"\"></p><p>点击同意后可以看到，数据库中也会产生授权通过记录：</p><p><img src=\"https://static001.geekbang.org/resource/image/9e/6f/9e942cc7c22ff8b4540e9f6736d56b6f.png?wh=1370*302\" alt=\"\"></p><p><strong>第二步，</strong>我们可以看到浏览器转到了百度并且提供给了我们授权码：</p><pre><code>https://www.baidu.com/?code=XKkHGY\n</code></pre><p>数据库中也记录了授权码：</p><p><img src=\"https://static001.geekbang.org/resource/image/ef/3e/eff235ff90aafb559d6e45b07a4d173e.png?wh=1344*254\" alt=\"\"></p><p>然后POST访问下面的地址（code参数替换为刚才获得的授权码）：</p><pre><code>http://localhost:8080/oauth/token?grant_type=authorization_code&amp;client_id=userservice3&amp;client_secret=1234&amp;code=XKkHGY&amp;redirect_uri=https://baidu.com\n</code></pre><p>可以通过授权码换取访问令牌：</p><p><img src=\"https://static001.geekbang.org/resource/image/ea/d7/ea401694bf55f83353f7db65d17ab6d7.png?wh=2544*1800\" alt=\"\"></p><p>虽然userservice3客户端可以有读权限和写权限，但是因为我们登录的用户reader只有读权限，所以最后拿到也只有读权限。</p><h2>演示权限控制</h2><p>现在我们来测试一下之前定义的两个账号，也就是读账号和写账号，看看它们的权限控制是否有效。</p><p>首先，测试一下我们的安全配置，访问/hello端点不需要认证可以匿名访问：</p><p><img src=\"https://static001.geekbang.org/resource/image/76/59/7646fe1e6e4cc9914f79881576126459.png?wh=790*220\" alt=\"\"></p><p>访问/user需要身份认证：</p><p><img src=\"https://static001.geekbang.org/resource/image/3b/f6/3b22a89392c92187960aecd4bc3cf8f6.png?wh=2302*436\" alt=\"\"></p><p>不管以哪种模式拿到访问令牌，我们用具有读权限的访问令牌访问资源服务器的如下地址</p><p>（请求头加入Authorization: Bearer XXXXXXXXXX，其中XXXXXXXXXX代表访问令牌）：</p><pre><code>http://localhost:8081/user/\n</code></pre><p>可以得到如下结果：</p><p><img src=\"https://static001.geekbang.org/resource/image/06/d5/0606fbb094de245d346ed17d9yycd6d5.png?wh=2504*1746\" alt=\"\"></p><p>以POST方式访问http://localhost:8081/user/，显然是失败的：</p><p><img src=\"https://static001.geekbang.org/resource/image/a7/88/a71bcef74da7577aa1529bf2d9546588.png?wh=2552*978\" alt=\"\"></p><p>因为这个接口要求有写权限：</p><pre><code>@PreAuthorize(&quot;hasAuthority('WRITE')&quot;)\n@PostMapping\npublic Object write(OAuth2Authentication authentication) {\n</code></pre><p>我们换一个具有读写权限的访问令牌来试试：</p><p><img src=\"https://static001.geekbang.org/resource/image/a7/fc/a754a6fdcb9666e07f1b820052a4e2fc.png?wh=2550*1230\" alt=\"\"></p><p>可以发现，果然访问成功了。这里输出的内容是Token中的userDetails额外信息，说明资源服务器的权限控制有效。</p><h2>搭建客户端程序</h2><p>在上面的演示中，我们使用的是Postman，也就是手动HTTP请求的方式来申请和使用Token。最后，我们来搭建一个OAuth客户端程序自动实现这个过程。</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n\n    &lt;parent&gt;\n        &lt;artifactId&gt;springsecurity101&lt;/artifactId&gt;\n        &lt;groupId&gt;me.josephzhu&lt;/groupId&gt;\n        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n    &lt;/parent&gt;\n\n    &lt;artifactId&gt;springsecurity101-cloud-oauth2-client&lt;/artifactId&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n    &lt;/dependencies&gt;\n&lt;/project&gt;\n</code></pre><p>配置文件如下：</p><pre><code>server:\n  port: 8083\n  servlet:\n    context-path: /ui\nsecurity:\n  oauth2:\n    client:\n      clientId: userservice3\n      clientSecret: 1234\n      accessTokenUri: http://localhost:8080/oauth/token\n      userAuthorizationUri: http://localhost:8080/oauth/authorize\n      scope: FOO\n    resource:\n      jwt:\n        key-value: |\n          -----BEGIN PUBLIC KEY-----\n          ***\n          -----END PUBLIC KEY-----\nspring:\n  thymeleaf:\n    cache: false\n\n#logging:\n#  level:\n#    ROOT: DEBUG\n</code></pre><p>客户端项目端口8082，几个需要说明的地方：</p><ul>\n<li>本地测试的时候有一个坑，也就是我们需要配置context-path，否则可能会出现客户端和授权服务器服务端Cookie干扰，导致CSRF防御触发的问题。这个问题出现后程序没有任何错误日志输出，只有开启DEBUG模式后才能看到DEBUG日志里有提示，因此这个问题非常难以排查。说实话，我也不知道Spring为什么不把这个信息作为WARN级别的日志输出。</li>\n<li>作为OAuth客户端，我们需要配置OAuth服务端获取Token的地址、授权（获取授权码）的地址，需要配置客户端的ID、密码和授权范围。</li>\n<li>因为使用的是JWT Token，我们需要配置公钥（当然，如果不在这里直接配置公钥的话，也可以配置从授权服务器服务端获取公钥）。</li>\n</ul><p>接下来，我们可以开始编码了。</p><p>第一步，实现MVC的配置：</p><pre><code>@Configuration\n@EnableWebMvc\npublic class WebMvcConfig implements WebMvcConfigurer {\n\n    /**\n     * 配置RequestContextListener用于启用session scope的Bean\n     * @return\n     */\n    @Bean\n    public RequestContextListener requestContextListener() {\n        return new RequestContextListener();\n    }\n\n    /**\n     * 配置index路径的首页Controller\n     * @param registry\n     */\n    @Override\n    public void addViewControllers(ViewControllerRegistry registry) {\n        registry.addViewController(&quot;/&quot;)\n                .setViewName(&quot;forward:/index&quot;);\n        registry.addViewController(&quot;/index&quot;);\n    }\n}\n</code></pre><p>这里做了两件事情：</p><ol>\n<li>配置RequestContextListener，用于启用session scope的Bean；</li>\n<li>配置了index路径的首页Controller。</li>\n</ol><p>第二步，实现安全方面的配置：</p><pre><code>@Configuration\n@Order(200)\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n    /**\n     * /路径和/login路径允许访问，其它路径需要身份认证后才能访问\n     * @param http\n     * @throws Exception\n     */\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n                .authorizeRequests()\n                .antMatchers(&quot;/&quot;, &quot;/login**&quot;)\n                .permitAll()\n                .anyRequest()\n                .authenticated();\n    }\n}\n</code></pre><p>这里我们实现的是/路径和/login路径允许访问，其它路径需要身份认证后才能访问。</p><p>第三步，我们来创建一个控制器：</p><pre><code>@RestController\npublic class DemoController {\n    @Autowired\n    OAuth2RestTemplate restTemplate;\n    //演示登录后才能访问的安全页面\n    @GetMapping(&quot;/securedPage&quot;)\n    public ModelAndView securedPage(OAuth2Authentication authentication) {\n        return new ModelAndView(&quot;securedPage&quot;).addObject(&quot;authentication&quot;, authentication);\n    }\n    //演示通过OAuth2RestTemplate调用受保护资源\n    @GetMapping(&quot;/remoteCall&quot;)\n    public String remoteCall() {\n        ResponseEntity&lt;String&gt; responseEntity = restTemplate.getForEntity(&quot;http://localhost:8081/user/name&quot;, String.class);\n        return responseEntity.getBody();\n    }\n}\n</code></pre><p>这里我们实现了两个功能：</p><ol>\n<li>securedPage页面，实现的功能是，把用户信息作为模型传入了视图，这样打开页面后就能显示用户名和权限。</li>\n<li>remoteCall接口，实现的功能是，通过引入OAuth2RestTemplate，在登录后就可以使用凭据直接从受保护资源服务器拿资源，不需要繁琐地实现获得访问令牌、在请求头里加入访问令牌的过程。</li>\n</ol><p>第四步，配置一下刚才用到的OAuth2RestTemplate Bean，并启用OAuth2Sso功能：</p><pre><code>@Configuration\n@EnableOAuth2Sso //这个注解包含了@EnableOAuth2Client\npublic class OAuthClientConfig {\n    /**\n     * 定义了OAuth2RestTemplate，网上一些比较老的资料给出的是手动读取配置文件来实现，最新版本已经可以自动注入OAuth2ProtectedResourceDetails\n     * @param oAuth2ClientContext\n     * @param details\n     * @return\n     */\n    @Bean\n    public OAuth2RestTemplate oauth2RestTemplate(OAuth2ClientContext oAuth2ClientContext,\n                                                 OAuth2ProtectedResourceDetails details) {\n        return new OAuth2RestTemplate(details, oAuth2ClientContext);\n    }\n}\n</code></pre><p>第五步，实现首页：</p><pre><code>&lt;body&gt;\n&lt;div class=&quot;container&quot;&gt;\n    &lt;div class=&quot;col-sm-12&quot;&gt;\n        &lt;h1&gt;Spring Security SSO Client&lt;/h1&gt;\n        &lt;a class=&quot;btn btn-primary&quot; href=&quot;securedPage&quot;&gt;Login&lt;/a&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n&lt;/body&gt;\n</code></pre><p>以及登录后才能访问的securedPage页面：</p><pre><code>&lt;body&gt;\n&lt;div class=&quot;container&quot;&gt;\n    &lt;div class=&quot;col-sm-12&quot;&gt;\n        &lt;h1&gt;Secured Page&lt;/h1&gt;\n        Welcome, &lt;span th:text=&quot;${authentication.name}&quot;&gt;Name&lt;/span&gt;\n        &lt;br/&gt;\n        Your authorities are &lt;span th:text=&quot;${authentication.authorities}&quot;&gt;authorities&lt;/span&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n&lt;/body&gt;\n</code></pre><h2>演示单点登录</h2><p>好，客户端程序搭建好之后，我们先来测试一下单点登录的功能。启动客户端项目，打开浏览器访问：</p><pre><code>http://localhost:8082/ui/securedPage\n</code></pre><p>可以看到，页面自动转到了授权服务器（8080端口）的登录页面：</p><p><img src=\"https://static001.geekbang.org/resource/image/05/81/05b76f316304e3ef2d1494bae501c381.png?wh=2074*1370\" alt=\"\"></p><p>登录后显示了当前用户名和权限：</p><p><img src=\"https://static001.geekbang.org/resource/image/7d/37/7d24bc73267506c15f9feyy546557237.png?wh=1162*454\" alt=\"\"></p><p>我们再启动另一个客户端网站，端口改为8083，然后访问同样的地址：</p><p><img src=\"https://static001.geekbang.org/resource/image/7a/46/7a50619ace3e40c8ff7c0aa860f11246.png?wh=1038*396\" alt=\"\"></p><p>可以看到直接是登录状态，单点登录测试成功。是不是很方便？其实，为了达成单点登录的效果，程序在背后自动实现了多次302重定向，整个流程为：</p><pre><code>http://localhost:8083/ui/securedPage -&gt;\nhttp://localhost:8083/ui/login -&gt;\nhttp://localhost:8080/oauth/authorize?client_id=userservice3&amp;redirect_uri=http://localhost:8083/ui/login&amp;response_type=code&amp;scope=FOO&amp;state=Sobjqe -&gt;\nhttp://localhost:8083/ui/login?code=CDdvHa&amp;state=Sobjqe -&gt;\nhttp://localhost:8083/ui/securedPage\n</code></pre><h2>演示客户端请求资源服务器资源</h2><p>还记得吗，在上一节“搭建客户端程序”中，我们还定义了一个remoteCall接口，直接使用OAuth2RestTemplate来访问远程资源服务器的资源。现在，我们来测试一下这个接口是否可以实现自动的OAuth流程。访问：</p><pre><code>http://localhost:8082/ui/remoteCall\n</code></pre><p>会先转到授权服务器登录，登录后自动跳转回来：</p><p><img src=\"https://static001.geekbang.org/resource/image/01/27/016f28b7161d2c600197aa2392b0de27.png?wh=832*220\" alt=\"\"></p><p>可以看到输出了用户名，对应的资源服务器服务端接口是：</p><pre><code>@PreAuthorize(&quot;hasAuthority('READ') or hasAuthority('WRITE')&quot;)\n@GetMapping(&quot;name&quot;)\npublic String name(OAuth2Authentication authentication) {\n    return authentication.getName();\n}\n</code></pre><p>换一个writer用户登录试试，也能得到正确的输出：</p><p><img src=\"https://static001.geekbang.org/resource/image/yy/84/yy2bca66c45cefa56d2d727c3a136a84.png?wh=910*214\" alt=\"\"></p><h2>总结</h2><p>今天这一讲，我们完整演示了如何使用Spring Cloud的OAuth 2.0组件基于三个程序角色（授权服务器、受保护资源服务器和客户端）实现三种OAuth 2.0的授权许可类型（资源拥有者凭据许可、客户端凭据许可和授权码许可）。</p><p>我们先演示了三种授权许可类型的手动流程，然后也演示了如何实现权限控制和单点登录，以及如何使用客户端程序来实现自动的OAuth 2.0流程。</p><p>我把今天用到的所有代码都放到了GitHub上，你可以点击<a href=\"https://github.com/JosephZhu1983/SpringSecurity101\">这个链接</a>查看。</p><p>最后，我再提一下，将来Spring对于OAuth 2.0的支持可能会转移到<a href=\"https://spring.io/blog/2020/04/15/announcing-the-spring-authorization-server\">由社区推进的Spring Authorization Server项目上来继续运作</a>。如果你感兴趣的话，可以及时关注这个项目的进展。</p>","comments":[{"had_liked":false,"id":292217,"user_name":"苗","can_delete":false,"product_type":"c1","uid":1088710,"ip_address":"","ucode":"5ECCC6C855E541","user_header":"https://static001.geekbang.org/account/avatar/00/10/9c/c6/05a6798f.jpg","comment_is_top":false,"comment_ctime":1620723412,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"35980461780","product_id":100053901,"comment_content":"导出公钥证书的命令：keytool -list -rfc --keystore mytest.jks | openssl x509 -inform pem -pubkey","like_count":8,"discussions":[{"author":{"id":1993603,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/6b/83/5fb44cd0.jpg","nickname":"Jagger Chen","note":"","ucode":"7C6ACBCF32ED12","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375660,"discussion_content":"还可以通过调用 /oauth/token_key 接口获取公钥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621788842,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236548,"user_name":"而立斋","can_delete":false,"product_type":"c1","uid":1087258,"ip_address":"","ucode":"5FED6E9E148195","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/1a/389eab84.jpg","comment_is_top":false,"comment_ctime":1595465209,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27365268985","product_id":100053901,"comment_content":"爱了，我要去手撸一遍，验证一下真伪。哈哈","like_count":6},{"had_liked":false,"id":242747,"user_name":"Younger Ku","can_delete":false,"product_type":"c1","uid":1323102,"ip_address":"","ucode":"D157DC38BDB515","user_header":"https://static001.geekbang.org/account/avatar/00/14/30/5e/c42bc33f.jpg","comment_is_top":false,"comment_ctime":1597829865,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14482731753","product_id":100053901,"comment_content":"能把源码带着看一遍，再把经常需要定制化的地方讲一下就好了。无论如何只停留在demo使用层面总感觉心里不踏实。","like_count":3},{"had_liked":false,"id":268614,"user_name":"Geek_0d99c9","can_delete":false,"product_type":"c1","uid":1797556,"ip_address":"","ucode":"82F2FC79DF1969","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqdH1VzVC9fJ3ZrSicnCjPXyvicYRkC3LFzVWcsjhibnAPCHBicia8Wk7J6rJfEuGGLqLV9wuWnqWuxFFQ/132","comment_is_top":false,"comment_ctime":1608273453,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"10198208045","product_id":100053901,"comment_content":"代码有点问题.直接访问8082&#47; 还是被重定向到login页面.OAuth2ClientApplication这个里面的EnableOAuth2Sso注解会覆盖WebSecurityConfig里面的免登录配置.所以应该把两个合并下<br><br>package me.josephzhu.springsecurity101.cloud.auth.client;<br><br>import org.springframework.boot.autoconfigure.security.oauth2.client.EnableOAuth2Sso;<br>import org.springframework.context.annotation.Bean;<br>import org.springframework.context.annotation.Configuration;<br>import org.springframework.core.annotation.Order;<br>import org.springframework.security.config.annotation.web.builders.HttpSecurity;<br>import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;<br>import org.springframework.security.oauth2.client.OAuth2ClientContext;<br>import org.springframework.security.oauth2.client.OAuth2RestTemplate;<br>import org.springframework.security.oauth2.client.resource.OAuth2ProtectedResourceDetails;<br><br>@EnableOAuth2Sso<br>@Configuration<br>@Order(200)<br>public class WebSecurityConfig extends WebSecurityConfigurerAdapter {<br>    &#47;**<br>     * &#47;路径和&#47;login路径允许访问，其它路径需要身份认证后才能访问<br>     *<br>     * @param http<br>     * @throws Exception<br>     *&#47;<br>    @Override<br>    protected void configure(HttpSecurity http) throws Exception {<br>        http<br>                .authorizeRequests()<br>                .antMatchers(&quot;&#47;test&quot;,&quot;&#47;&quot;, &quot;&#47;login**&quot;,&quot;&#47;**&#47;test&quot;,&quot;&#47;ui&#47;test&quot;, &quot;&#47;logout&quot;)<br>                .permitAll()<br>                .anyRequest()<br>                .authenticated().and()<br>                .logout().logoutSuccessUrl(&quot;&#47;&quot;);;<br>    }<br><br>      @Bean<br>  public OAuth2RestTemplate oauth2RestTemplate(OAuth2ClientContext oAuth2ClientContext,<br>                                               OAuth2ProtectedResourceDetails details) {<br>  return new OAuth2RestTemplate(details, oAuth2ClientContext);<br>  }<br><br>}<br><br>","like_count":2,"discussions":[{"author":{"id":2055809,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/5e/81/82709d6e.jpg","nickname":"码小呆","note":"","ucode":"44532D6ABF9340","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590579,"discussion_content":"提个bug ,然后修复一下吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665900905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1439123,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f5/93/154e2776.jpg","nickname":"AMSC30","note":"","ucode":"3800721F5C8894","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573973,"discussion_content":"确实如此，没看评论，研究了好久","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653751826,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1993603,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/6b/83/5fb44cd0.jpg","nickname":"Jagger Chen","note":"","ucode":"7C6ACBCF32ED12","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376282,"discussion_content":"解决了访问 /ui 根路径时直接跳转至登录界面的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622047600,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":265426,"user_name":"Anony","can_delete":false,"product_type":"c1","uid":1174733,"ip_address":"","ucode":"4B7D06B8C7BFD3","user_header":"https://static001.geekbang.org/account/avatar/00/11/ec/cd/52753b9e.jpg","comment_is_top":false,"comment_ctime":1606895055,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10196829647","product_id":100053901,"comment_content":"客户端使用了@EnableOAuth2Sso，里面包含自己的WebSecurity会拦截所有请求。而后自己定义的WebSecurity，Order是200，实际上是不起作用的吧，即使让某些url permitAll，也会直接跳转到授权服务器的登录页。请求都会直接被靠前的EnableOAuth2Sso里的过滤链处理 。","like_count":2,"discussions":[{"author":{"id":2035993,"avatar":"","nickname":"void01","note":"","ucode":"F7C5571416E837","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573621,"discussion_content":"那这个应该怎么解决呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653551783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":353663,"user_name":"行一善","can_delete":false,"product_type":"c1","uid":1189632,"ip_address":"浙江","ucode":"4C188470B46AF9","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/00/7ba54f5c.jpg","comment_is_top":false,"comment_ctime":1659665953,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5954633249","product_id":100053901,"comment_content":" 生成jks密钥库\t生成.jks文件<br> keytool -genkey -alias tutorialspedia -keyalg RSA -keystore &quot;&#47;home&#47;yaoshenglu&#47;keytool&#47;tutorialspedia.jks&quot;<br>  keytool -genkey -alias jwt -keyalg RSA -keystore &quot;&#47;home&#47;yaoshenglu&#47;keytool&#47;jwt.jks&quot;<br><br> 导出公共证书 .cer文件<br> keytool -export -alias tutorialspedia -file &quot;&#47;home&#47;yaoshenglu&#47;keytool&#47;tutorialspedia_public_cert.cer&quot; -keystore &quot;&#47;home&#47;yaoshenglu&#47;keytool&#47;tutorialspedia.jks&quot;<br>  keytool -export -alias jwt -file &quot;&#47;home&#47;yaoshenglu&#47;keytool&#47;public.cert&quot; -keystore &quot;&#47;home&#47;yaoshenglu&#47;keytool&#47;jwt.jks&quot;<br> <br> 查看公钥<br> keytool -list -rfc --keystore tutorialspedia.jks | openssl x509 -inform pem -pubkey<br>  keytool -list -rfc --keystore jwt.jks | openssl x509 -inform pem -pubkey","like_count":2},{"had_liked":false,"id":333658,"user_name":"jiangb","can_delete":false,"product_type":"c1","uid":1030861,"ip_address":"","ucode":"A09415749CA88D","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJrqLEic7DVicYY1s9ldH0vGBialDoplVGpicZUJ0Fdaklw27Frv8Ac67eicb5LibhL74SUxAzlick2nfltA/132","comment_is_top":false,"comment_ctime":1644461751,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5939429047","product_id":100053901,"comment_content":"实操了一遍，运行OK。","like_count":1},{"had_liked":false,"id":247448,"user_name":"benxiong","can_delete":false,"product_type":"c1","uid":1624574,"ip_address":"","ucode":"F6498059D439D9","user_header":"https://static001.geekbang.org/account/avatar/00/18/c9/fe/874b172b.jpg","comment_is_top":false,"comment_ctime":1599710905,"is_pvip":false,"replies":[{"id":"90888","content":"MySQL 5.7 之后这个限制放宽到了 3072 字节，所以我没问题","user_name":"作者回复","comment_id":247448,"uid":"1001470","ip_address":"","utype":1,"ctime":1599712124,"user_name_real":"朱晔"}],"discussion_count":2,"race_medal":0,"score":"5894678201","product_id":100053901,"comment_content":"创建表的时候报错了：<br>CREATE TABLE `oauth_client_details` (<br>  `client_id` varchar(255) NOT NULL,<br>  `resource_ids` varchar(255) DEFAULT NULL,<br>  `client_secret` varchar(255) DEFAULT NULL,<br>  `scope` varchar(255) DEFAULT NULL,<br>  `authorized_grant_types` varchar(255) DEFAULT NULL,<br>  `web_server_redirect_uri` varchar(255) DEFAULT NULL,<br>  `authorities` varchar(255) DEFAULT NULL,<br>  `access_token_validity` int(11) DEFAULT NULL,<br>  `refresh_token_validity` int(11) DEFAULT NULL,<br>  `additional_information` varchar(255) DEFAULT NULL,<br>  `autoapprove` varchar(255) DEFAULT NULL,<br>  PRIMARY KEY (`client_id`)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4<br>&gt; 1071 - Specified key was too long; max key length is 767 bytes<br>&gt; 时间: 0s<br><br>网上说是 mysql innodb存储引擎 的 varchar 主键只支持不超过767个字节 或者 768&#47;2=384个双字节 或者767&#47;3=255个三字节 或者 767&#47;4=191个四字节的字段，GBK是双字节的，UTF8是三字节的，utf8mb4是四字节的，我按照这个说法，把主键 client_id 字段长度改为 VARCHAR(111)，就创建成功了。<br><br>但是我是很信服朱晔老师的，他非常严谨，他肯定是测试通过以后才发表的文章，所以我觉得应该还有别的原因导致他可以创建，而我却报错。<br><br>这个原因期待老师和别的小伙伴帮忙解答。","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505403,"discussion_content":"MySQL 5.7 之后这个限制放宽到了 3072 字节，所以我没问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599712124,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1624574,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c9/fe/874b172b.jpg","nickname":"benxiong","note":"","ucode":"F6498059D439D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304924,"discussion_content":"原来是这样，我电脑的mysql版本还是5.5.61。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599713979,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241801,"user_name":"布吉岛","can_delete":false,"product_type":"c1","uid":1356423,"ip_address":"","ucode":"0E4D113D62AD24","user_header":"https://static001.geekbang.org/account/avatar/00/14/b2/87/833d9bb6.jpg","comment_is_top":false,"comment_ctime":1597449982,"is_pvip":false,"replies":[{"id":"89302","content":"为啥要讲呢","user_name":"作者回复","comment_id":241801,"uid":"1001470","ip_address":"","utype":1,"ctime":1597551043,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"5892417278","product_id":100053901,"comment_content":"csrf攻击不讲嘛？","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503849,"discussion_content":"为啥要讲呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597551043,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239890,"user_name":"Geek_fb74a8","can_delete":false,"product_type":"c1","uid":1926523,"ip_address":"","ucode":"802A47B46697B7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/mZrw2nVk1Aw8eYh5GPWpI9OHVBhXdFpMZx9mDyAHJuSZlpXCfKcOUxSUTewtibW8KBb0d9ftNl9F0n6ptudxBwQ/132","comment_is_top":false,"comment_ctime":1596685087,"is_pvip":false,"replies":[{"id":"88605","content":"jwt可以自验证 要实现登出等 需要改为透明token","user_name":"作者回复","comment_id":239890,"uid":"1001470","ip_address":"","utype":1,"ctime":1596702382,"user_name_real":"朱晔"}],"discussion_count":3,"race_medal":0,"score":"5891652383","product_id":100053901,"comment_content":"请教一下老师，使用jwt的话应该怎么处理过期以及登出等处理？可否将jwt令牌存入Redis？","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503266,"discussion_content":"jwt可以自验证 要实现登出等 需要改为透明token","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596702382,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1220780,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a0/ac/a23f48e3.jpg","nickname":"lane","note":"","ucode":"9F76D2BEB610AA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365607,"discussion_content":"这种指定要通过redis黑名单拦截的，所以所谓的无状态是半无状态","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617849853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181647,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/cf/b0d6fe74.jpg","nickname":"L.","note":"","ucode":"46A2F679C094E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340867,"discussion_content":"Jwt 本身就是透明token啊，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610184899,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236533,"user_name":"工资不交税","can_delete":false,"product_type":"c1","uid":1110795,"ip_address":"","ucode":"C3ECBCC5622B65","user_header":"https://static001.geekbang.org/account/avatar/00/10/f3/0b/0128ae45.jpg","comment_is_top":false,"comment_ctime":1595460764,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5890428060","product_id":100053901,"comment_content":"对于sso的实现还是不理解。看起来全程没有用到cookie，那授权服务是如何知道来自两个域名的请求是同一个用户？","like_count":1,"discussions":[{"author":{"id":1637085,"avatar":"https://static001.geekbang.org/account/avatar/00/18/fa/dd/f640711f.jpg","nickname":"哈德韦","note":"","ucode":"E7C9B3D087D2D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293179,"discussion_content":"不懂 Java，粗看了一下，应该是使用了 Cookie。可能是 Spring 框架隐含了，不必自己手写实现。\n\n文中提到：\n\n本地测试的时候有一个坑，也就是我们需要配置 context-path，否则可能会出现客户端和授权服务器服务端 Cookie 干扰，导致 CSRF 防御触发的问题。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595469373,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1601316,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIaH2o8W1n6Mmw5VdHLdNVPtMNtMibrdyK6qFutg6YZvaIXQQvDwDXeNpw8avoib4iaNe4MunZ9EQkiaw/132","nickname":"就叫包子吧","note":"","ucode":"382FF22B859C66","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408741,"discussion_content":"应该是你和认证服务器通过cookie一直建立着关联","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635313825,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339699,"user_name":"Geek_4b4d7b","can_delete":false,"product_type":"c1","uid":2955881,"ip_address":"","ucode":"3E96BBA66DFAC4","user_header":"","comment_is_top":false,"comment_ctime":1648300000,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648300000","product_id":100053901,"comment_content":"老师好，请教下单点登录为啥会有http:&#47;&#47;localhost:8083&#47;ui&#47;login的访问地址，登录页面不是在认证服务8080上吗？","like_count":0},{"had_liked":false,"id":339260,"user_name":"孩童的心，永远在迷失","can_delete":false,"product_type":"c1","uid":2046355,"ip_address":"","ucode":"6705BF27DCA12B","user_header":"https://static001.geekbang.org/account/avatar/00/1f/39/93/914db62f.jpg","comment_is_top":false,"comment_ctime":1648015287,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648015287","product_id":100053901,"comment_content":"客户端端口是先设置为8082，测试完8082，又改为8083。菜鸡的我一开始没注意，还奇怪8082端口为啥没跳转login成功。","like_count":0},{"had_liked":false,"id":338894,"user_name":"Geek_16e01a","can_delete":false,"product_type":"c1","uid":1843371,"ip_address":"","ucode":"791D5AA6BAA018","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK5dh80UCnDwic7jHWRGVMbqFBjFbBAKO4bqzB5Sr39iaib5JPmF3d06dV1ibXHflNdQKgcKBsEkfXc6g/132","comment_is_top":false,"comment_ctime":1647778917,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647778917","product_id":100053901,"comment_content":"老师您好，下面是我在你的课件中看到的两句话：<br>“首先，Token 可以保存在数据库或 Redis 中，资源服务器和授权服务器共享底层的 TokenStore 来验证；然后，资源服务器可以使用 RemoteTokenServices，来从授权服务器的 &#47;oauth&#47;check_token 端点进行 Token 校验。”<br>我在实践中发现，只要共享tokenStore共享同一个jdbc的数据源，那么在我并没有配置RemoteTokenService的情况下，token也是能被校验的。就是说我传错误的token会被识别出来是invalid的。请问老师，这个是什么情况，我不是很清楚，是否有什么默认的配置","like_count":0},{"had_liked":false,"id":337988,"user_name":"ascend","can_delete":false,"product_type":"c1","uid":1268755,"ip_address":"","ucode":"4F63892FB42590","user_header":"https://static001.geekbang.org/account/avatar/00/13/5c/13/d1a75b2e.jpg","comment_is_top":false,"comment_ctime":1647224167,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647224167","product_id":100053901,"comment_content":"前后端分离的情况下，oauth2的认证流程怎么走呢","like_count":0},{"had_liked":false,"id":335380,"user_name":"Geek_16e01a","can_delete":false,"product_type":"c1","uid":1843371,"ip_address":"","ucode":"791D5AA6BAA018","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK5dh80UCnDwic7jHWRGVMbqFBjFbBAKO4bqzB5Sr39iaib5JPmF3d06dV1ibXHflNdQKgcKBsEkfXc6g/132","comment_is_top":false,"comment_ctime":1645496319,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645496319","product_id":100053901,"comment_content":"老师，我再使用客户端使用这个方法的时候    public OAuth2RestTemplate oauth2RestTemplate(OAuth2ClientContext oAuth2ClientContext, OAuth2ProtectedResourceDetails details)   代码里会报这个错误Could not autowire. There is more than one bean of &#39;OAuth2ClientContext&#39; type.<br>您遇到过这个问题么，该怎么解决","like_count":0},{"had_liked":false,"id":303293,"user_name":"liuyong","can_delete":false,"product_type":"c1","uid":1128318,"ip_address":"","ucode":"D68555E8057F6E","user_header":"https://static001.geekbang.org/account/avatar/00/11/37/7e/219dd994.jpg","comment_is_top":false,"comment_ctime":1626703960,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1626703960","product_id":100053901,"comment_content":"现在Spring OAuth2已经被标记为deprecate了，新系统应该不推荐继续用这个了吧？","like_count":0,"discussions":[{"author":{"id":1601316,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIaH2o8W1n6Mmw5VdHLdNVPtMNtMibrdyK6qFutg6YZvaIXQQvDwDXeNpw8avoib4iaNe4MunZ9EQkiaw/132","nickname":"就叫包子吧","note":"","ucode":"382FF22B859C66","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408740,"discussion_content":"如果要自己搭建认证服务器的话还是只得用spring oauth2, spring security只迁移了资源服务器和客户端","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635313657,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300679,"user_name":"泥鳅儿","can_delete":false,"product_type":"c1","uid":1323000,"ip_address":"","ucode":"26B47C8FC67615","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ojfRyNRvy1x3Mia0nssz6CNPHrHXwPPmibvds1URgoHQuKXrGiaxrEbsT6sAvuK4N4AOicySh8S9iaWcOLjteOl6Kgg/132","comment_is_top":false,"comment_ctime":1625302140,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1625302140","product_id":100053901,"comment_content":"老师你好，oauth2.0客户端如何自动注册呢 ？oauth_client_details这个表里的数据怎么新增的 是手动往里加记录吗","like_count":0,"discussions":[{"author":{"id":1079495,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/c7/083a3a0b.jpg","nickname":"新世界","note":"","ucode":"4473DC1505F158","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408386,"discussion_content":"这个应该可以做个管理，做个页面，让第三方客户端去申请","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635238989,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296875,"user_name":"Geek_9f3b9b","can_delete":false,"product_type":"c1","uid":2530414,"ip_address":"","ucode":"34D456354EC5BE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er8I0UfHsvn66T1BxW7sniaWXpTLqQ5X2qNlwuEWFfw9666dt1kAKmoScgRkjGfbRIpbDXY5dgEAnw/132","comment_is_top":false,"comment_ctime":1623208595,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623208595","product_id":100053901,"comment_content":"github取不到代码了","like_count":0},{"had_liked":false,"id":290558,"user_name":"达尼亚尔","can_delete":false,"product_type":"c1","uid":1556489,"ip_address":"","ucode":"028C3BF9AE55EC","user_header":"https://static001.geekbang.org/account/avatar/00/17/c0/09/f1280359.jpg","comment_is_top":false,"comment_ctime":1619619172,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"1619619172","product_id":100053901,"comment_content":"老师，您好！ 您是怎么用keytool生成的秘钥对？我生成秘钥对在受保护服务启动的过程中报错了，但是授权服务中正常。能把keytool的使用方法讲一下吗？谢谢！！<br>以下是报错信息：<br> For MAC signing you do not need to specify the verifier key separately, and if you do it must match the signing key","like_count":0,"discussions":[{"author":{"id":1368038,"avatar":"https://static001.geekbang.org/account/avatar/00/14/df/e6/bd1b3c0b.jpg","nickname":"Jesse","note":"","ucode":"727CA882B84DA0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588429,"discussion_content":"大佬好，我也遇到这个问题，请问你解决了吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663755479,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1993603,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/6b/83/5fb44cd0.jpg","nickname":"Jagger Chen","note":"","ucode":"7C6ACBCF32ED12","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375661,"discussion_content":"删除掉 BEGIN CERTIFICATE 至 END CERTIFICATE","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621788953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":269319,"user_name":"杨毅","can_delete":false,"product_type":"c1","uid":2377406,"ip_address":"","ucode":"189923D892549F","user_header":"","comment_is_top":false,"comment_ctime":1608610548,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608610548","product_id":100053901,"comment_content":"老师您好， 这块的sso如果是基于多个不同的一级域名还好使吗？ 如果不好使大致要怎么做啊","like_count":0},{"had_liked":false,"id":261906,"user_name":"永旭","can_delete":false,"product_type":"c1","uid":1068819,"ip_address":"","ucode":"C9C74BE32C8F46","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/13/5197f8d2.jpg","comment_is_top":false,"comment_ctime":1605575270,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605575270","product_id":100053901,"comment_content":"老师，你好.<br>这篇案例的sso实现，不是基于oidc实现的啊？还是底层屏蔽ID令牌的细节？","like_count":0},{"had_liked":false,"id":261697,"user_name":"永旭","can_delete":false,"product_type":"c1","uid":1068819,"ip_address":"","ucode":"C9C74BE32C8F46","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/13/5197f8d2.jpg","comment_is_top":false,"comment_ctime":1605492987,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1605492987","product_id":100053901,"comment_content":"老师你好. <br>我生成了私钥库 jks文件, 使用命令只能导出cer, crt文件 . 通过-rfc查询后放到cert文件里还是报错.<br>能说下使用keytool生成cert文件的命令吗 ? <br>非常感谢","like_count":0,"discussions":[{"author":{"id":1068819,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4f/13/5197f8d2.jpg","nickname":"永旭","note":"","ucode":"C9C74BE32C8F46","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326355,"discussion_content":"这个找到答案了, 生成公钥得提前安装openssl .命令如下\nkeytool -list -rfc --keystore xxxxx.jks | openssl x509 -inform pem -pubkey","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605583186,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":260475,"user_name":"流云","can_delete":false,"product_type":"c1","uid":2232976,"ip_address":"","ucode":"5C31C34F8B9236","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIq15Qq887bH7Z5aQHfXu5vHUj4Iz68RotmUIR12vG5Y3L7icUcYgL4hicwAKYyicAmPTtoZPNPfDPOg/132","comment_is_top":false,"comment_ctime":1605018672,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605018672","product_id":100053901,"comment_content":"请教老师，公司内部系统登录怎么对接oauth平台呢？还是要单独做一套登录系统比价合适，希望老师能够指导一下，感谢","like_count":0},{"had_liked":false,"id":257918,"user_name":"梦想的优惠券","can_delete":false,"product_type":"c1","uid":1257418,"ip_address":"","ucode":"D3B44F6C618CA7","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/ca/cbce6e94.jpg","comment_is_top":false,"comment_ctime":1604212839,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1604212839","product_id":100053901,"comment_content":"老师，我在验证授权码许可类型的时候，授权服务器不返回Code，表oauth_code也没写进去值，页面跳转后返回的是【https:&#47;&#47;www.baidu.com&#47;?error=access_denied&amp;error_description=User%20denied%20access】","like_count":0},{"had_liked":false,"id":250260,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1601004964,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601004964","product_id":100053901,"comment_content":"向老师请教 资源拥有者凭据许可 模式，也就是俗称的 密码 模式；主要是提供给第一方的客户端使用的模式。<br>这种情况下，使用的是 资源拥有者（也就是用户）的【用户名】+【密码】+【客户端id】+【客户端Secret】来获取token。<br>客户端的id和Secret应该是不能存放在页面应用中的吧》？感觉会不安全。<br><br>我看到的其他的文章和博客，描述的意思大概是： 用户把自己的用户名和密码告诉客户端，客户端再带着自己的 客户端ic和Secret 向授权服务器交换用户的token。把token返给用户后，用户再带着token请求自己的资源。请问是这样嘛？如果是这样，实际客户端时如何向授权服务交换用户token的呢？查阅多个博客，文档的demo，样例都是使用postman，输入 客户端id+Secret+用户名+密码 直接请求tokne的。。。","like_count":0},{"had_liked":false,"id":248633,"user_name":"十九路军","can_delete":false,"product_type":"c1","uid":1344161,"ip_address":"","ucode":"11E16184AD661F","user_header":"https://static001.geekbang.org/account/avatar/00/14/82/a1/76878dc5.jpg","comment_is_top":false,"comment_ctime":1600247903,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600247903","product_id":100053901,"comment_content":"微服务架构中，一般都有网关，请问你这个资源服务器，应该搭建在哪里呢","like_count":0},{"had_liked":false,"id":247001,"user_name":"业哥","can_delete":false,"product_type":"c1","uid":1054026,"ip_address":"","ucode":"2918CBF9C6649D","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/4a/2bfdf441.jpg","comment_is_top":false,"comment_ctime":1599554569,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599554569","product_id":100053901,"comment_content":"您好，单点登录这块我验证会出现异常：<br>操作步骤1： 启动3个服务   --都启动正常<br>操作步骤2： 谷歌浏览器访问：http:&#47;&#47;localhost:8082&#47;ui&#47;securedPage，跳转到8080的登录页，输入reader&#47;reader用户信息；浏览器返回:http:&#47;&#47;localhost:8080&#47;oauth&#47;authorize?client_id=userservice3&amp;redirect_uri=http:&#47;&#47;localhost:8082&#47;ui&#47;login&amp;response_type=code&amp;scope=FOO&amp;state=eoI41h ，页面显示：该网页无法正常运作localhost 将您重定向的次数过多。尝试清除 Cookie.ERR_TOO_MANY_REDIRECTS，同时后台异常信息：<br>java.lang.IllegalStateException: Access token provider returned a null access token, which is illegal according to the contract.<br>\tat org.springframework.security.oauth2.client.OAuth2RestTemplate.acquireAccessToken(OAuth2RestTemplate.java:223) ~[spring-security-oauth2-2.3.4.RELEASE.jar:na]<br>\tat org.springframework.security.oauth2.client.OAuth2RestTemplate.getAccessToken(OAuth2RestTemplate.java:173) ~[spring-security-oauth2-2.3.4.RELEASE.jar:na]<br>\tat org.springframework.security.oauth2.client.filter.OAuth2ClientAuthenticationProcessingFilter.attemptAuthentication(OAuth2ClientAuthenticationProcessingFilter.java:105) ~[spring-security-oauth2-2.3.4.RELEASE.jar:na]<br>\tat org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:212) ~[spring-security-web-5.2.1.RELEASE.jar:5.2.1.RELEASE]<br>\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.2.1.RELEASE.jar:5.2.1.RELEASE]<br>\tat org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:116) ~[spring-security-web-5.2.1.RELEASE.jar:5.2.1.RELEASE]<br>\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.2.1.RELEASE.jar:5.2.1.RELEASE]<br>\tat org.springframework.security.web.csrf.CsrfFilter.doFilterInternal(CsrfFilter.java:117) ~[spring-security-web-5.2.1.RELEASE.jar:5.2.1.RELEASE]<br>\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) <br>","like_count":0},{"had_liked":false,"id":238484,"user_name":"AgCl","can_delete":false,"product_type":"c1","uid":1408804,"ip_address":"","ucode":"2C7660E3C5565D","user_header":"https://static001.geekbang.org/account/avatar/00/15/7f/24/719ce9d4.jpg","comment_is_top":false,"comment_ctime":1596181637,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596181637","product_id":100053901,"comment_content":"老师，看你文中提到了RemoteTokenService，配置时候需要设定clientId的，那这个resourceServer是不是也就这一个ClientId可访问了","like_count":0},{"had_liked":false,"id":238194,"user_name":"overland","can_delete":false,"product_type":"c1","uid":1208835,"ip_address":"","ucode":"609A463519E5F0","user_header":"https://static001.geekbang.org/account/avatar/00/12/72/03/da1fcc81.jpg","comment_is_top":false,"comment_ctime":1596092712,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1596092712","product_id":100053901,"comment_content":"keytool 这个是怎么生成密钥对的，RSA 吗？还有密钥对有效期过期了怎么办，还是设置个超级大的日期，不让过期呢","like_count":0,"discussions":[{"author":{"id":1590038,"avatar":"https://static001.geekbang.org/account/avatar/00/18/43/16/d18be4c5.jpg","nickname":"...？","note":"","ucode":"8CB8669180F9D8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304013,"discussion_content":"# 通过\\JDK8\\bin keytool生成jks文件\nkeytool -genkey -alias gj-jwt -keyalg RSA -keysize 1024 -keystore gj-jwt.jks -validity 365 -keypass gjtest -storepass gjtest \n\n获取jks文件的公钥\nkeytool -list -rfc --keystore gj-jwt.jks | openssl x509 -inform pem -pubkey","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1599449219,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":237876,"user_name":"iiskee","can_delete":false,"product_type":"c1","uid":1315450,"ip_address":"","ucode":"475BF76CEA67D2","user_header":"https://static001.geekbang.org/account/avatar/00/14/12/7a/516d5396.jpg","comment_is_top":false,"comment_ctime":1595993392,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1595993392","product_id":100053901,"comment_content":"jwt的单点登出要怎么处理？","like_count":0},{"had_liked":false,"id":236925,"user_name":"Tim Zhang","can_delete":false,"product_type":"c1","uid":1214499,"ip_address":"","ucode":"4956AC5FE45EE1","user_header":"https://static001.geekbang.org/account/avatar/00/12/88/23/a0966b4d.jpg","comment_is_top":false,"comment_ctime":1595588242,"is_pvip":false,"replies":[{"id":"88446","content":"1、这些SpringSecurity都可以直接做<br>2、权限应该统一维护在认证中心比较好<br>3、微服务网关可以做token到uid的翻译以及鉴权<br>4、SpringSecurity都可以直接做<br>5、用户表应该只存在一处，比如认证中心，其他系统都存uid关联","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1596530918,"ip_address":"","comment_id":236925,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1595588242","product_id":100053901,"comment_content":"有个问题，请指教：<br>我的需求是想开发一个统一认证平台，公司内所有应用需要认证，资源权限管控的都走这个应用<br><br>用户首先访问a应用的某个webapi(受保护应用)，a应用发现token不存在，跳转到我的统一认证授权中心的登录界面，选择使用微信进行认证，认证成功后，根据我的数据库中的rbac表，查询这个用户在a应用的权限与角色，生成token，将token返回给受保护资源的应用a，然后a应用进行验证。<br><br>我的问题如下：<br>1、那些刷新accesstoken，refrshtoken过期的重新跳转的逻辑，是否只能写在不同a、b、c、d这些受保护资源应用的filter逻辑中<br><br>2、比如公司有100个应用需要做认证授权，是否这些应用的(用户，角色，资源)表结构都维护在统一认证中心所对应的db中。<br><br>3、我看老师引用了网关，是否网关可以切面做掉点通用逻辑<br><br>4、受保护资源保护的资源(webapi)，假设是基于http rest的spring mvc编写的，是否就是那些control<br>ler中的路由url，在这些url之上使用切面逻辑来验证token中的资源权限是否与当前路由匹配（比如验证http方法+url路径）<br><br>5、受保护资源应用自己的数据库中假设存有用户表，是否还要与统一认证中的用户表进行实时关联，比如a应用的用户aa删除了，还需要实时删除统一认证中的aa用户在a应用中的数据<br><br>问题较多，乱，请老师抽空回复下，谢谢了","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502255,"discussion_content":"1、这些SpringSecurity都可以直接做\n2、权限应该统一维护在认证中心比较好\n3、微服务网关可以做token到uid的翻译以及鉴权\n4、SpringSecurity都可以直接做\n5、用户表应该只存在一处，比如认证中心，其他系统都存uid关联","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596530918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236531,"user_name":"往事随风，顺其自然","can_delete":false,"product_type":"c1","uid":1235692,"ip_address":"","ucode":"F266EC6B143E38","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/ec/779c1a78.jpg","comment_is_top":false,"comment_ctime":1595459347,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595459347","product_id":100053901,"comment_content":"内容很多，需要实操一下，体会更深刻","like_count":0}]}