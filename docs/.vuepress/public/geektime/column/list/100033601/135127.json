{"id":135127,"title":"17 | WebAPI：XMLHttpRequest是怎么实现的？","content":"<p>在<a href=\"https://time.geekbang.org/column/article/134456\">上一篇文章</a>中我们介绍了setTimeout是如何结合渲染进程的循环系统工作的，那本篇文章我们就继续介绍另外一种类型的WebAPI——XMLHttpRequest。</p><p>自从网页中引入了JavaScript，我们就可以操作DOM树中任意一个节点，例如隐藏/显示节点、改变颜色、获得或改变文本内容、为元素添加事件响应函数等等， 几乎可以“为所欲为”了。</p><p>不过在XMLHttpRequest出现之前，如果服务器数据有更新，依然需要重新刷新整个页面。而XMLHttpRequest提供了从Web服务器获取数据的能力，如果你想要更新某条数据，只需要通过XMLHttpRequest请求服务器提供的接口，就可以获取到服务器的数据，然后再操作DOM来更新页面内容，整个过程只需要更新网页的一部分就可以了，而不用像之前那样还得刷新整个页面，这样既有效率又不会打扰到用户。</p><p>关于XMLHttpRequest，本来我是想一带而过的，后来发现这个WebAPI用于教学非常好。首先前面讲了那么网络内容，现在可以通过它把HTTP协议实践一遍；其次，XMLHttpRequest是一个非常典型的WebAPI，通过它来讲解浏览器是如何实现WebAPI的很合适，这对于你理解其他WebAPI也有非常大的帮助，同时在这个过程中我们还可以把一些安全问题给串起来。</p><!-- [[[read_end]]] --><p>但在深入讲解XMLHttpRequest之前，我们得先介绍下<strong>同步回调</strong>和<strong>异步回调</strong>这两个概念，这会帮助你更加深刻地理解WebAPI是怎么工作的。</p><h2>回调函数 VS 系统调用栈</h2><p>那什么是回调函数呢（Callback Function）？</p><p>将一个函数作为参数传递给另外一个函数，那作为参数的这个函数就是<strong>回调函数</strong>。简化的代码如下所示：</p><pre><code>let callback = function(){\n    console.log('i am do homework')\n}\nfunction doWork(cb) {\n    console.log('start do work')\n    cb()\n    console.log('end do work')\n}\ndoWork(callback)\n</code></pre><p>在上面示例代码中，我们将一个匿名函数赋值给变量callback，同时将callback作为参数传递给了doWork()函数，这时在函数doWork()中callback就是回调函数。</p><p>上面的回调方法有个特点，就是回调函数callback是在主函数doWork返回之前执行的，我们把这个回调过程称为<strong>同步回调</strong>。</p><p>既然有同步回调，那肯定也有异步回调。下面我们再来看看异步回调的例子：</p><pre><code>let callback = function(){\n    console.log('i am do homework')\n}\nfunction doWork(cb) {\n    console.log('start do work')\n    setTimeout(cb,1000)   \n    console.log('end do work')\n}\ndoWork(callback)\n</code></pre><p>在这个例子中，我们使用了setTimeout函数让callback在doWork函数执行结束后，又延时了1秒再执行，这次callback并没有在主函数doWork内部被调用，我们把这种回调函数在主函数外部执行的过程称为<strong>异步回调</strong>。</p><p>现在你应该知道什么是同步回调和异步回调了，那下面我们再深入点，站在消息循环的视角来看看同步回调和异步回调的区别。理解了这些，可以让你从本质上理解什么是回调。</p><p>我们还是先来回顾下页面的事件循环系统，通过<a href=\"https://time.geekbang.org/column/article/132931\">《15 | 消息队列和事件循环：页面是怎么“活”起来的？》</a>的学习，你应该已经知道浏览器页面是通过事件循环机制来驱动的，每个渲染进程都有一个消息队列，页面主线程按照顺序来执行消息队列中的事件，如执行JavaScript事件、解析DOM事件、计算布局事件、用户输入事件等等，如果页面有新的事件产生，那新的事件将会追加到事件队列的尾部。所以可以说是<strong>消息队列和主线程循环机制保证了页面有条不紊地运行</strong>。</p><p>这里还需要补充一点，那就是当循环系统在执行一个任务的时候，都要为这个任务维护一个<strong>系统调用栈</strong>。这个<strong>系统调用栈</strong>类似于JavaScript的调用栈，只不过系统调用栈是Chromium的开发语言C++来维护的，其完整的调用栈信息你可以通过chrome://tracing/来抓取。当然，你也可以通过Performance来抓取它核心的调用信息，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/d3/77/d3d66afb1a103103e5c3f86c823efb77.png?wh=1142*205\" alt=\"\"></p><center><span class=\"reference\">消息循环系统调用栈记录</span></center><p>这幅图记录了一个Parse HTML的任务执行过程，其中黄色的条目表示执行JavaScript的过程，其他颜色的条目表示浏览器内部系统的执行过程。</p><p>通过该图你可以看出来，Parse HTML任务在执行过程中会遇到一系列的子过程，比如在解析页面的过程中遇到了JavaScript脚本，那么就暂停解析过程去执行该脚本，等执行完成之后，再恢复解析过程。然后又遇到了样式表，这时候又开始解析样式表……直到整个任务执行完成。</p><p>需要说明的是，整个Parse HTML是一个完整的任务，在执行过程中的脚本解析、样式表解析都是该任务的子过程，其下拉的长条就是执行过程中调用栈的信息。</p><p>每个任务在执行过程中都有自己的调用栈，那么同步回调就是在当前主函数的上下文中执行回调函数，这个没有太多可讲的。下面我们主要来看看异步回调过程，异步回调是指回调函数在主函数之外执行，一般有两种方式：</p><ul>\n<li>第一种是把异步函数做成一个任务，添加到信息队列尾部；</li>\n<li>第二种是把异步函数添加到微任务队列中，这样就可以在当前任务的末尾处执行微任务了。</li>\n</ul><h2>XMLHttpRequest运作机制</h2><p>理解了什么是同步回调和异步回调，接下来我们就来分析XMLHttpRequest背后的实现机制，具体工作过程你可以参考下图：</p><p><img src=\"https://static001.geekbang.org/resource/image/29/c6/2914a052f4f249a52077692a22ee5cc6.png?wh=1142*523\" alt=\"\"></p><center><span class=\"reference\">XMLHttpRequest工作流程图</span></center><p>这是XMLHttpRequest的总执行流程图，下面我们就来分析从发起请求到接收数据的完整流程。</p><p>我们先从XMLHttpRequest的用法开始，首先看下面这样一段请求代码：</p><pre><code> function GetWebData(URL){\n    /**\n     * 1:新建XMLHttpRequest请求对象\n     */\n    let xhr = new XMLHttpRequest()\n\n    /**\n     * 2:注册相关事件回调处理函数 \n     */\n    xhr.onreadystatechange = function () {\n        switch(xhr.readyState){\n          case 0: //请求未初始化\n            console.log(&quot;请求未初始化&quot;)\n            break;\n          case 1://OPENED\n            console.log(&quot;OPENED&quot;)\n            break;\n          case 2://HEADERS_RECEIVED\n            console.log(&quot;HEADERS_RECEIVED&quot;)\n            break;\n          case 3://LOADING  \n            console.log(&quot;LOADING&quot;)\n            break;\n          case 4://DONE\n            if(this.status == 200||this.status == 304){\n                console.log(this.responseText);\n                }\n            console.log(&quot;DONE&quot;)\n            break;\n        }\n    }\n\n    xhr.ontimeout = function(e) { console.log('ontimeout') }\n    xhr.onerror = function(e) { console.log('onerror') }\n\n    /**\n     * 3:打开请求\n     */\n    xhr.open('Get', URL, true);//创建一个Get请求,采用异步\n\n\n    /**\n     * 4:配置参数\n     */\n    xhr.timeout = 3000 //设置xhr请求的超时时间\n    xhr.responseType = &quot;text&quot; //设置响应返回的数据格式\n    xhr.setRequestHeader(&quot;X_TEST&quot;,&quot;time.geekbang&quot;)\n\n    /**\n     * 5:发送请求\n     */\n    xhr.send();\n}\n</code></pre><p>上面是一段利用了XMLHttpRequest来请求数据的代码，再结合上面的流程图，我们可以分析下这段代码是怎么执行的。</p><p><strong>第一步：创建XMLHttpRequest对象。</strong></p><p>当执行到<code>let xhr = new XMLHttpRequest()</code>后，JavaScript会创建一个XMLHttpRequest对象<strong>xhr</strong>，用来执行实际的网络请求操作。</p><p><strong>第二步：为xhr对象注册回调函数。</strong></p><p>因为网络请求比较耗时，所以要注册回调函数，这样后台任务执行完成之后就会通过调用回调函数来告诉其执行结果。</p><p>XMLHttpRequest的回调函数主要有下面几种：</p><ul>\n<li>ontimeout，用来监控超时请求，如果后台请求超时了，该函数会被调用；</li>\n<li>onerror，用来监控出错信息，如果后台请求出错了，该函数会被调用；</li>\n<li>onreadystatechange，用来监控后台请求过程中的状态，比如可以监控到HTTP头加载完成的消息、HTTP响应体消息以及数据加载完成的消息等。</li>\n</ul><p><strong>第三步：配置基础的请求信息。</strong></p><p>注册好回调事件之后，接下来就需要配置基础的请求信息了，首先要通过open接口配置一些基础的请求信息，包括请求的地址、请求方法（是get还是post）和请求方式（同步还是异步请求）。</p><p>然后通过xhr内部属性类配置一些其他可选的请求信息，你可以参考文中示例代码，我们通过<code>xhr.timeout = 3000</code>来配置超时时间，也就是说如果请求超过3000毫秒还没有响应，那么这次请求就被判断为失败了。</p><p>我们还可以通过<code>xhr.responseType = \"text\"</code>来配置服务器返回的格式，将服务器返回的数据自动转换为自己想要的格式，如果将responseType的值设置为json，那么系统会自动将服务器返回的数据转换为JavaScript对象格式。下面的图表是我列出的一些返回类型的描述：</p><p><img src=\"https://static001.geekbang.org/resource/image/85/bf/856d1965676fafa46122e3ad1235dfbf.png?wh=1142*590\" alt=\"\"></p><p>假如你还需要添加自己专用的请求头属性，可以通过xhr.setRequestHeader来添加。</p><p><strong>第四步：发起请求。</strong></p><p>一切准备就绪之后，就可以调用<code>xhr.send</code>来发起网络请求了。你可以对照上面那张请求流程图，可以看到：渲染进程会将请求发送给网络进程，然后网络进程负责资源的下载，等网络进程接收到数据之后，就会利用IPC来通知渲染进程；渲染进程接收到消息之后，会将xhr的回调函数封装成任务并添加到消息队列中，等主线程循环系统执行到该任务的时候，就会根据相关的状态来调用对应的回调函数。</p><ul>\n<li>如果网络请求出错了，就会执行xhr.onerror；</li>\n<li>如果超时了，就会执行xhr.ontimeout；</li>\n<li>如果是正常的数据接收，就会执行onreadystatechange来反馈相应的状态。</li>\n</ul><p>这就是一个完整的XMLHttpRequest请求流程，如果你感兴趣，可以参考下Chromium对XMLHttpRequest的实现，<a href=\"https://chromium.googlesource.com/chromium/src/+/refs/heads/master/third_party/blink/renderer/core/xmlhttprequest/\">点击这里查看代码</a>。</p><h2>XMLHttpRequest使用过程中的“坑”</h2><p>上述过程看似简单，但由于浏览器很多安全策略的限制，所以会导致你在使用过程中踩到非常多的“坑”。</p><p>浏览器安全问题是前端工程师避不开的一道坎，通常在使用过程中遇到的“坑”，很大一部分都是由安全策略引起的，不管你喜不喜欢，它都在这里。本来很完美的一个方案，正是由于加了安全限制，导致使用起来非常麻烦。</p><p>而你要做的就是去正视这各种的安全问题。也就是说要想更加完美地使用XMLHttpRequest，你就要了解浏览器的安全策略。</p><p>下面我们就来看看在使用XMLHttpRequest的过程中所遇到的跨域问题和混合内容问题。</p><h3>1. 跨域问题</h3><p>比如在极客邦的官网使用XMLHttpRequest请求极客时间的页面内容，由于极客邦的官网是<a href=\"https://www.geekbang.org\">www.geekbang.org</a>，极客时间的官网是<a href=\"https://time.geekbang.org\">time.geekbang.org</a>，它们不是同一个源，所以就涉及到了跨域（在A站点中去访问不同源的B站点的内容）。默认情况下，跨域请求是不被允许的，你可以看下面的示例代码：</p><pre><code>var xhr = new XMLHttpRequest()\nvar url = 'https://time.geekbang.org/'\nfunction handler() {\n    switch(xhr.readyState){\n        case 0: //请求未初始化\n        console.log(&quot;请求未初始化&quot;)\n        break;\n        case 1://OPENED\n        console.log(&quot;OPENED&quot;)\n        break;\n        case 2://HEADERS_RECEIVED\n        console.log(&quot;HEADERS_RECEIVED&quot;)\n        break;\n        case 3://LOADING  \n        console.log(&quot;LOADING&quot;)\n        break;\n        case 4://DONE\n        if(this.status == 200||this.status == 304){\n            console.log(this.responseText);\n            }\n        console.log(&quot;DONE&quot;)\n        break;\n    }\n}\n   \nfunction callOtherDomain() {\n  if(xhr) {    \n    xhr.open('GET', url, true)\n    xhr.onreadystatechange = handler\n    xhr.send();\n  }\n}\ncallOtherDomain()\n</code></pre><p>你可以在控制台测试下。首先通过浏览器打开<a href=\"https://www.geekbang.org\">www.geekbang.org</a>，然后打开控制台，在控制台输入以上示例代码，再执行，会看到请求被Block了。控制台的提示信息如下：</p><pre><code>Access to XMLHttpRequest at 'https://time.geekbang.org/' from origin 'https://www.geekbang.org' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.\n</code></pre><p>因为 www.geekbang.org 和 time.geekbang.com 不属于一个域，所以以上访问就属于跨域访问了，这次访问失败就是由于跨域问题导致的。</p><h3>2. HTTPS混合内容的问题</h3><p>了解完跨域问题后，我们再来看看HTTPS的混合内容。HTTPS混合内容是HTTPS页面中包含了不符合HTTPS安全要求的内容，比如包含了HTTP资源，通过HTTP加载的图像、视频、样式表、脚本等，都属于混合内容。</p><p>通常，如果HTTPS请求页面中使用混合内容，浏览器会针对HTTPS混合内容显示警告，用来向用户表明此HTTPS页面包含不安全的资源。比如打开站点 <a href=\"https://www.iteye.com/groups\">https://www.iteye.com/groups</a> ，可以通过控制台看到混合内容的警告，参考下图：</p><p><img src=\"https://static001.geekbang.org/resource/image/4b/63/4b4a210a1e078d9a26fe31e6eab34963.png?wh=1142*336\" alt=\"\"></p><center><span class=\"reference\">HTTPS混合内容警告</span></center><p>从上图可以看出，通过HTML文件加载的混合资源，虽然给出警告，但大部分类型还是能加载的。而使用XMLHttpRequest请求时，浏览器认为这种请求可能是攻击者发起的，会阻止此类危险的请求。比如我通过浏览器打开地址 <a href=\"https://www.iteye.com/groups\">https://www.iteye.com/groups</a>  ，然后通过控制台，使用XMLHttpRequest来请求 <a href=\"http://img-ads.csdn.net/2018/201811150919211586.jpg\">http://img-ads.csdn.net/2018/201811150919211586.jpg</a> ，这时候请求就会报错，出错信息如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/46/a1/46c22d4e54815942c1a86f11b14516a1.png?wh=1142*517\" alt=\"\"></p><center><span class=\"reference\">使用XMLHttpRequest混合资源失效</span></center><h2>总结</h2><p>好了，今天我们就讲到这里，下面我来总结下今天的内容。</p><p>首先我们介绍了回调函数和系统调用栈；接下来我们站在循环系统的视角，分析了XMLHttpRequest是怎么工作的；最后又说明了由于一些安全因素的限制，在使用XMLHttpRequest的过程中会遇到跨域问题和混合内容的问题。</p><p>本篇文章跨度比较大，不是单纯地讲一个问题，而是将回调类型、循环系统、网络请求和安全问题“串联”起来了。</p><p>对比<a href=\"https://time.geekbang.org/column/article/134456\">上一篇文章</a>，setTimeout是直接将延迟任务添加到延迟队列中，而XMLHttpRequest发起请求，是由浏览器的其他进程或者线程去执行，然后再将执行结果利用IPC的方式通知渲染进程，之后渲染进程再将对应的消息添加到消息队列中。如果你搞懂了setTimeout和XMLHttpRequest的工作机制后，再来理解其他WebAPI就会轻松很多了，因为大部分WebAPI的工作逻辑都是类似的。</p><h2>思考时间</h2><p>网络安全很重要，但是又很容易被忽视，因为项目需求很少涉及到基础的Web安全。如果忽视了这些基础安全策略，在开发过程中会处处遇到安全策略挖下的“大坑”，所以对于一名开发者来说，Web安全理论很重要，也必须要学好。</p><p>那么今天我留给你一道开放性的思考题：你认为作为一名开发工程师，要如何去高效地学习前端的Web安全理论呢？</p><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p><p></p>","comments":[{"had_liked":false,"id":132913,"user_name":"蓝配鸡","can_delete":false,"product_type":"c1","uid":1348738,"ip_address":"","ucode":"C79A7CA8885B7C","user_header":"https://static001.geekbang.org/account/avatar/00/14/94/82/d0a417ba.jpg","comment_is_top":false,"comment_ctime":1568273496,"is_pvip":false,"replies":[{"id":"50924","content":"很赞，学安全一定要知道why，知道why才知道how！<br><br>等到了我们专栏的安全篇时，这套理论再结合实践就完美了。<br><br>","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1568279483,"ip_address":"","comment_id":132913,"utype":1}],"discussion_count":10,"race_medal":0,"score":"254971343960","product_id":100033601,"comment_content":"如何高效学习安全理论<br><br>1. why， 知道为什么有这个安全机制， 历史是什么样的<br><br>2. how，知道why之后自己先想想怎么解决这个问题， 再去看看别人是怎么解决的， 分析利弊<br><br>3. 学完之后自己上手试试<br><br>4. 拉个你身边最蠢的小伙伴把这件事给他说明白","like_count":60,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467173,"discussion_content":"很赞，学安全一定要知道why，知道why才知道how！\n\n等到了我们专栏的安全篇时，这套理论再结合实践就完美了。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568279483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1231317,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c9/d5/b08a27ed.jpg","nickname":"灵感_idea","note":"","ucode":"E0DBDDFA6040F6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340713,"discussion_content":"我好奇你那个听你讲了这玩意还心里美滋滋的那个小伙伴知道你这么说他？","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1610104119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1195144,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3c/88/6bef27d6.jpg","nickname":"大神博士","note":"","ucode":"8C4318095949F0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1231317,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c9/d5/b08a27ed.jpg","nickname":"灵感_idea","note":"","ucode":"E0DBDDFA6040F6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376982,"discussion_content":"阿巴阿巴","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622450740,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":340713,"ip_address":""},"score":376982,"extra":""},{"author":{"id":1100751,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cb/cf/417a5ec2.jpg","nickname":"黑豹","note":"","ucode":"B9F94D0AFA89DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1231317,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c9/d5/b08a27ed.jpg","nickname":"灵感_idea","note":"","ucode":"E0DBDDFA6040F6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390607,"discussion_content":"我们现在就坐在这里听课。。。。。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1629938376,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":340713,"ip_address":""},"score":390607,"extra":""}]},{"author":{"id":1233489,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d2/51/07bdce08.jpg","nickname":"张旭.cheri","note":"","ucode":"3369D87E70D372","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":103138,"discussion_content":"第四点是费曼学习法的精髓啊","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1577371276,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1644811,"avatar":"https://static001.geekbang.org/account/avatar/00/19/19/0b/13329677.jpg","nickname":"喵喵喵","note":"","ucode":"16D61FB3591234","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":138436,"discussion_content":"现在我身边就缺个最蠢的小伙伴了\n","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1579243075,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1910075,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/25/3b/a971fc8e.jpg","nickname":"阿感","note":"","ucode":"7BCB7E44A832D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1644811,"avatar":"https://static001.geekbang.org/account/avatar/00/19/19/0b/13329677.jpg","nickname":"喵喵喵","note":"","ucode":"16D61FB3591234","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":255866,"discussion_content":"汪汪汪","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588430612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":138436,"ip_address":""},"score":255866,"extra":""}]},{"author":{"id":1132775,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/e7/8b31bea3.jpg","nickname":"曾小伟","note":"","ucode":"6905E4AFE5FC87","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303094,"discussion_content":"如果时间允许，可以去打打ctf","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599139298,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1243584,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f9/c0/20b4a205.jpg","nickname":"啊哈哈","note":"","ucode":"A8542946C03707","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289741,"discussion_content":"我想做你最蠢的小伙伴，快讲给我听😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594198272,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1328142,"avatar":"https://static001.geekbang.org/account/avatar/00/14/44/0e/ce14b7d3.jpg","nickname":"-_-|||","note":"","ucode":"94B21594658BF9","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74025,"discussion_content":"蓝羽鸡","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575624452,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133146,"user_name":"Geek_d972f2","can_delete":false,"product_type":"c1","uid":1379184,"ip_address":"","ucode":"72381CF0C973B7","user_header":"","comment_is_top":false,"comment_ctime":1568389883,"is_pvip":false,"replies":[{"id":"50978","content":"open方法仅仅是配置数据，没有任何真实的连接产生，所有连接阶段都是在send之后","user_name":"作者回复","user_name_real":"无理数","uid":"1141464","ctime":1568418729,"ip_address":"","comment_id":133146,"utype":1}],"discussion_count":2,"race_medal":0,"score":"186251983611","product_id":100033601,"comment_content":"建立tcp连接是在xhr open还是send?","like_count":44,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467271,"discussion_content":"open方法仅仅是配置数据，没有任何真实的连接产生，所有连接阶段都是在send之后","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568418729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2159152,"avatar":"https://static001.geekbang.org/account/avatar/00/20/f2/30/5b677e8d.jpg","nickname":"Yvan","note":"","ucode":"DA5BB215E65ED3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535019,"discussion_content":"xhr.open方法名称歧义太大了","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1638332361,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132938,"user_name":"yihang","can_delete":false,"product_type":"c1","uid":1012361,"ip_address":"","ucode":"A5506F085D1793","user_header":"https://static001.geekbang.org/account/avatar/00/0f/72/89/1a83120a.jpg","comment_is_top":false,"comment_ctime":1568279168,"is_pvip":false,"replies":[{"id":"50979","content":"fetch采用了promise来封装，在使用方式上更强现代化，同时还原生支持async&#47;await。在chromium中，fetch是完全重新实现的，和xmlhttprequest没有什么关系！<br><br>在项目中推荐使用fetch","user_name":"作者回复","user_name_real":"无理数","uid":"1141464","ctime":1568419145,"ip_address":"","comment_id":132938,"utype":1}],"discussion_count":3,"race_medal":0,"score":"134712265344","product_id":100033601,"comment_content":"请教老师，我看到 es6中可以通过一个 fetch api来请求，它的实现是用了 xmlHttpRequest么？如果不是，原理上有什么不同？","like_count":32,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467185,"discussion_content":"fetch采用了promise来封装，在使用方式上更强现代化，同时还原生支持async/await。在chromium中，fetch是完全重新实现的，和xmlhttprequest没有什么关系！\n\n在项目中推荐使用fetch","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568419145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1654564,"avatar":"https://static001.geekbang.org/account/avatar/00/19/3f/24/46e4691d.jpg","nickname":"CodingMan1203","note":"","ucode":"BB1B0F8D3763A8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286758,"discussion_content":"fetch有一点不太友好，就是自己内部没有设置超时时间，这块需要自行完善，个人觉得还是使用axios比较方便顺手\n","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1593272570,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1630502,"avatar":"https://static001.geekbang.org/account/avatar/00/18/e1/26/a5bae6c3.jpg","nickname":"。丑","note":"","ucode":"F1006EBF13E95F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1654564,"avatar":"https://static001.geekbang.org/account/avatar/00/19/3f/24/46e4691d.jpg","nickname":"CodingMan1203","note":"","ucode":"BB1B0F8D3763A8","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":376559,"discussion_content":"没错 现在就是用的是axios","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622192061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":286758,"ip_address":""},"score":376559,"extra":""}]}]},{"had_liked":false,"id":133200,"user_name":"レイン小雨","can_delete":false,"product_type":"c1","uid":1219933,"ip_address":"","ucode":"45BED977EFE852","user_header":"https://static001.geekbang.org/account/avatar/00/12/9d/5d/3fdead91.jpg","comment_is_top":false,"comment_ctime":1568441142,"is_pvip":false,"discussion_count":13,"race_medal":0,"score":"78877852470","product_id":100033601,"comment_content":"老师后面能详细的讲一下浏览器同源策略的具体实现吗？作为前端最基本的常识性知识却总是感觉理解的不够深入，开始我以为是跨域的请求是被浏览器“拦截在了门内”----即请求没有发送出去，但是看了很多文章中说，其实跨域的请求是发送出去了，服务器也接收到了并响应了，而是在返回的时候被浏览器“拦截在门外”，还有人说，不同的浏览器实现也不一样，很是困惑这里，希望老师能给一个确定的答案。","like_count":18,"discussions":[{"author":{"id":1272789,"avatar":"https://static001.geekbang.org/account/avatar/00/13/6b/d5/0e4b70a2.jpg","nickname":"Sean","note":"","ucode":"BC0715BF423613","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41329,"discussion_content":"我看到有文档说最初的时候是直接拦在门内，就没有发出去。后来，大多数浏览器都是收到响应之后再去检查，不同源的被拦截。其实结合响应头【Access-Control-Allow-Origin】这个字段，就能理解了吧。只有发出请求、接收到响应之后，才能检查响应头里里面是否有设置服务器允许的跨域站点白名单。有的话两厢情愿浏览器也不会阻拦，没有的话浏览器才会把这个响应结果丢弃。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1572399881,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645648,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/50/217d8bb4.jpg","nickname":"飏","note":"","ucode":"419D35CD60D280","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1272789,"avatar":"https://static001.geekbang.org/account/avatar/00/13/6b/d5/0e4b70a2.jpg","nickname":"Sean","note":"","ucode":"BC0715BF423613","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":86958,"discussion_content":"http://www.ruanyifeng.com/blog/2016/04/cors.html 参考鸟哥的一篇文章，浏览器通过读取响应头的相关字段进行判定","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576634125,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":41329,"ip_address":""},"score":86958,"extra":""}]},{"author":{"id":1086570,"avatar":"https://static001.geekbang.org/account/avatar/00/10/94/6a/d40f64ec.jpg","nickname":"尝试者说","note":"","ucode":"305ABCD369E7D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285571,"discussion_content":"如果是跨域，并且是简单请求，就不会有options进行预请求，也就是询问服务器我这个请求可不可以。如果请求不是简单请求，就要进行options","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1592882544,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1110944,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f3/a0/5979d4a4.jpg","nickname":"祝","note":"","ucode":"34563625CA1206","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211981,"discussion_content":"CORS, preflight request，会先发起 OPTIONS 请求，server 允许的话，才发起实际的请求\n\nhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584921868,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1562743,"avatar":"https://static001.geekbang.org/account/avatar/00/17/d8/77/123b6608.jpg","nickname":"得闲读书","note":"","ucode":"44969F6575E94B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":14012,"discussion_content":"我也想知道，求解答","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568720987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1228268,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bd/ec/cc7abf0b.jpg","nickname":"L","note":"","ucode":"26BB686671F7D4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":20571,"discussion_content":"浏览器可以安装一些插件，允许跨域","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569329951,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":6,"child_discussions":[{"author":{"id":1266698,"avatar":"https://static001.geekbang.org/account/avatar/00/13/54/0a/9a002ad5.jpg","nickname":"Adam Lau","note":"","ucode":"7E542D6E789500","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1228268,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bd/ec/cc7abf0b.jpg","nickname":"L","note":"","ucode":"26BB686671F7D4","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":356918,"discussion_content":"啥插件？你想跨域就跨域，不问问服务器答应不吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615707280,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":20571,"ip_address":""},"score":356918,"extra":""},{"author":{"id":1374181,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f7/e5/ec543f3b.jpg","nickname":"张宗伟","note":"","ucode":"1447A20C7A8982","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1266698,"avatar":"https://static001.geekbang.org/account/avatar/00/13/54/0a/9a002ad5.jpg","nickname":"Adam Lau","note":"","ucode":"7E542D6E789500","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":359779,"discussion_content":"我理解的跨域不应该是浏览器的策略导致的吗？就像有一种解决跨域的方式是通过服务器转发。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616290485,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":356918,"ip_address":""},"score":359779,"extra":""},{"author":{"id":1266698,"avatar":"https://static001.geekbang.org/account/avatar/00/13/54/0a/9a002ad5.jpg","nickname":"Adam Lau","note":"","ucode":"7E542D6E789500","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1374181,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f7/e5/ec543f3b.jpg","nickname":"张宗伟","note":"","ucode":"1447A20C7A8982","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360347,"discussion_content":"嗯嗯，你说得对，是浏览器限制的，通过服务器就不存在跨域一说了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616421800,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":359779,"ip_address":""},"score":360347,"extra":""}]},{"author":{"id":1047340,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fb/2c/8aeb0ed6.jpg","nickname":"雅奇","note":"","ucode":"7ED6D462870509","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":13205,"discussion_content":"老师，给这条评论做个解答吧。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568645684,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144195,"user_name":"imperial","can_delete":false,"product_type":"c1","uid":1465302,"ip_address":"","ucode":"8D0693B3C142B1","user_header":"https://static001.geekbang.org/account/avatar/00/16/5b/d6/d6c26ea2.jpg","comment_is_top":false,"comment_ctime":1571877986,"is_pvip":false,"replies":[{"id":"56715","content":"延时队列中的任务包含JS通过定时器设置的回调函数、还有一些浏览器内部的延时回调函数。  它们属于宏任务！<br><br>另外正常的消息队列中的任务也属于宏任务！<br><br>所以通常我说放入消息队列就是指放入了宏任务队列（包括了延时队列或者正常的消息队列）<br><br>因为分开来描述会有点啰嗦！<br><br>","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1572618773,"ip_address":"","comment_id":144195,"utype":1}],"discussion_count":1,"race_medal":0,"score":"70291354722","product_id":100033601,"comment_content":"老师，异步函数的调用不应该有三种方式吗，可以放到队列尾，微任务中，也可以放入延迟队列中，为什么不放入延迟队列中呢","like_count":16,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471844,"discussion_content":"延时队列中的任务包含JS通过定时器设置的回调函数、还有一些浏览器内部的延时回调函数。  它们属于宏任务！\n\n另外正常的消息队列中的任务也属于宏任务！\n\n所以通常我说放入消息队列就是指放入了宏任务队列（包括了延时队列或者正常的消息队列）\n\n因为分开来描述会有点啰嗦！\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572618773,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133874,"user_name":"淡","can_delete":false,"product_type":"c1","uid":1456392,"ip_address":"","ucode":"6856CA319DE2F0","user_header":"https://static001.geekbang.org/account/avatar/00/16/39/08/09055b47.jpg","comment_is_top":false,"comment_ctime":1568688819,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"40223394483","product_id":100033601,"comment_content":"老师你好，我有以下几个疑问：<br>1.渲染进程里的主线程while循环空转，为啥不会造成系统卡死？我们自己code里空while死循环会造成卡死<br>2.就是网络进程IPC给渲染进程时，渲染进程收到消息。这里的”消息“具体包含哪些内容啊？<br>谢谢。","like_count":9,"discussions":[{"author":{"id":1242593,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f5/e1/b21c74a4.jpg","nickname":"prozac","note":"","ucode":"8D1557F035582B","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":166580,"discussion_content":"这两个循环不是一个概念。渲染线程里的空循环是指该线程处于一个随时“待命”的状态，此时的它处于空闲状态，不会有任何问题。而我们自己写的while死循环，则是一个执行时间无限长的任务，接到这个任务之后，渲染线程一直在工作，根本没有空闲去处理比如交互事件/JS执行等任务，这就是“卡死”的真正原因。","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1581414222,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1024485,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a1/e5/1956d405.jpg","nickname":"17丶A","note":"","ucode":"F8BBAC339FC8AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1242593,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f5/e1/b21c74a4.jpg","nickname":"prozac","note":"","ucode":"8D1557F035582B","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":280884,"discussion_content":"自己写的while死循环，则是一个执行时间无限长的任务，接到这个任务之后，渲染线程一直在工作？应该是JavaScript引擎线程一直在执行，而渲染线程和JS线程是互斥的，导致渲染线程一直被挂起，才引发的“卡死”的原因吧？JS线程一直占用，渲染线程还能工作吗？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1591624612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":166580,"ip_address":""},"score":280884,"extra":""},{"author":{"id":1242593,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f5/e1/b21c74a4.jpg","nickname":"prozac","note":"","ucode":"8D1557F035582B","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":1024485,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a1/e5/1956d405.jpg","nickname":"17丶A","note":"","ucode":"F8BBAC339FC8AE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288187,"discussion_content":"渲染进程不能工作就是“卡死”啊，你说的和我说的是一个意思吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593673743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":280884,"ip_address":""},"score":288187,"extra":""},{"author":{"id":2299674,"avatar":"","nickname":"王世昌","note":"","ucode":"DAF76789ECE6B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1242593,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f5/e1/b21c74a4.jpg","nickname":"prozac","note":"","ucode":"8D1557F035582B","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":326608,"discussion_content":"他可能是个纯前端不太接触后端吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605626321,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":288187,"ip_address":""},"score":326608,"extra":""}]},{"author":{"id":1235099,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d8/9b/f9a00567.jpg","nickname":"why.","note":"","ucode":"C9E9B10F2BC0EB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296080,"discussion_content":"https://source.chromium.org/chromium/chromium/src/+/master:base/message_loop/message_pump_default.cc\n本质上也是一个for死循环，只不过多了一个event_.Wait() 让线程挂起，其他线程提交任务时，通过event_.Signal() 再唤醒刚刚挂起的线程去执行相应的任务","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1596447371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133213,"user_name":"Hurry","can_delete":false,"product_type":"c1","uid":1138560,"ip_address":"","ucode":"12FEE2A50CC667","user_header":"https://static001.geekbang.org/account/avatar/00/11/5f/80/51269d88.jpg","comment_is_top":false,"comment_ctime":1568445385,"is_pvip":false,"replies":[{"id":"51055","content":"进程间通信，比如浏览器进程需要网络进程下载数据，浏览器进程就是通过IPC告诉网络进程需要下载哪些数据，网络进程接收到之后才会开启下载流程","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1568450108,"ip_address":"","comment_id":133213,"utype":1}],"discussion_count":2,"race_medal":0,"score":"40223151049","product_id":100033601,"comment_content":"IPC是什么","like_count":10,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467298,"discussion_content":"进程间通信，比如浏览器进程需要网络进程下载数据，浏览器进程就是通过IPC告诉网络进程需要下载哪些数据，网络进程接收到之后才会开启下载流程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568450108,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1293186,"avatar":"https://static001.geekbang.org/account/avatar/00/13/bb/82/5a32de87.jpg","nickname":"泷沁心","note":"","ucode":"E811D9F1A17689","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336583,"discussion_content":"Interprosses communication  进程间通信","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608629009,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132880,"user_name":"oc7","can_delete":false,"product_type":"c1","uid":1436976,"ip_address":"","ucode":"05067ED84F1493","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJibVeub5HnlS9HgLdrDSnQma6VINyAyf1bTOhKh4MGQkMydoCVs7ofbicePRomxjDM873A56fqx97w/132","comment_is_top":false,"comment_ctime":1568258161,"is_pvip":false,"replies":[{"id":"50925","content":"Promise的resolve和reject会创建微任务。<br><br>还有MutationObserver，如果监听了某个节点，那么通过DOMAPI修改这些被监听的节点也会产生微任务。","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1568279816,"ip_address":"","comment_id":132880,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27338061937","product_id":100033601,"comment_content":" 异步回调的第二种方式 把异步函数添加到微任务队列中 具体是哪些WebAPI呢? Promise.then?","like_count":6,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467159,"discussion_content":"Promise的resolve和reject会创建微任务。\n\n还有MutationObserver，如果监听了某个节点，那么通过DOMAPI修改这些被监听的节点也会产生微任务。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568279816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132803,"user_name":"bobi","can_delete":false,"product_type":"c1","uid":1616931,"ip_address":"","ucode":"6796146DFB791D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/xRYuVOluJxeuRtmKPjwwkSibKeeHEia1fVyiaK14JQtdM3bLqHShGTSvF3yRY4Mp81gz2hLw6BZoY02AXSFHZiaBxg/132","comment_is_top":false,"comment_ctime":1568242956,"is_pvip":false,"replies":[{"id":"50926","content":"后面三节<br><br>微任务<br>Promise<br>async&#47;await","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1568279864,"ip_address":"","comment_id":132803,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23043079436","product_id":100033601,"comment_content":"老师，什么时候专门讲微任务？","like_count":5,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467126,"discussion_content":"后面三节\n\n微任务\nPromise\nasync/await","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568279864,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132800,"user_name":"mfist","can_delete":false,"product_type":"c1","uid":1373624,"ip_address":"","ucode":"4F99F422C23FB4","user_header":"https://static001.geekbang.org/account/avatar/00/14/f5/b8/9f165f4b.jpg","comment_is_top":false,"comment_ctime":1568241527,"is_pvip":false,"replies":[{"id":"50927","content":"通过这些实践理解安全问题是个好方法，最好还要搞清楚为什么有这种或者那种的安全问题，这样我们对安全问题就会融会贯通。<br><br>","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1568279974,"ip_address":"","comment_id":132800,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18748110711","product_id":100033601,"comment_content":"作为一名前端开发工程师，要如何高效地学习前端web安全理论呢？<br>作为web工程师可以稍微把自己领域知识向后端扩展一些，这样理解web问题、网络传输问题会<br>更加得心应手。比如说前端浏览器因为跨域block，后端到底有没有处理请求；XSS 漏洞 以及CSRF<br>漏洞如果能前后端一起模拟一下，会更容易理解的。<br><br>今日总结<br>xmlhttprequest是为了解决网页局部数据刷新产生的技术。通过同步回调和异步回调以及系统调用栈来引出了<br>xmlhttprequest运行机制。一个xhr主要包含下面四个步骤：1. 创建xmlhttprequest对象；2. 为xhr对象<br>注册回调函数（ontimeout、onerror、onreadystatechange）；3. 打开请求（xhr.open（&#39;GET&#39;, url,true））4. 配置基础的请求信息（timeout&#47;responseType&#47;setRequestHeader）；5. 发送请求。xhr中场景的坑（<br>跨域和混合内容）","like_count":4,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467125,"discussion_content":"通过这些实践理解安全问题是个好方法，最好还要搞清楚为什么有这种或者那种的安全问题，这样我们对安全问题就会融会贯通。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568279974,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235084,"user_name":"蹦哒","can_delete":false,"product_type":"c1","uid":1458931,"ip_address":"","ucode":"56591A657DE7C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epcs6PibsP9vEXv4EibUw3bhQPUK04zRTOvfrvF08TwM67xPb1LBh2uRENHQwo2VqYfC5GhJmM7icxHA/132","comment_is_top":false,"comment_ctime":1594887769,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14479789657","product_id":100033601,"comment_content":"老师请问是否可以这样理解：<br>异步的本质，就是通过把方法（函数）添加到消息队列尾部，通过循环系统在下一次循环中去执行；<br>同步的本质，就是在当前方法中执行另外一个方法，执行完之后接着执行原来的方法","like_count":3,"discussions":[{"author":{"id":2913864,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/MYShyjtRtib2GIQiaK4hV3ZP9pQ1qiaS74DA4K4YHY4SIiaFDfsCKgiaMWwm9zFsSn3bt5pawp5Kdn5MWgiaw5909nug/132","nickname":"Geek_aa1c31","note":"","ucode":"1AC14C053638AF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552111,"discussion_content":"异步也可以放到微任务中, 当次循环就执行\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645285936,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143389,"user_name":"l1shu","can_delete":false,"product_type":"c1","uid":1624297,"ip_address":"","ucode":"FCF3E36905B404","user_header":"https://static001.geekbang.org/account/avatar/00/18/c8/e9/c7c5cbf5.jpg","comment_is_top":false,"comment_ctime":1571704090,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"14456605978","product_id":100033601,"comment_content":"为什么有些文章说渲染进程中有一个定时器线程用来计时的 到时间后会把回调函数塞到消息队列  而没有提到延迟队列这个说法  求老师解答","like_count":3,"discussions":[{"author":{"id":1050196,"avatar":"https://static001.geekbang.org/account/avatar/00/10/06/54/16bb64d0.jpg","nickname":"蛋黄酱","note":"","ucode":"2351562F282B68","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339770,"discussion_content":"这样讲也没错\n延迟队列是个hashmap，是无序的记录了到期信息\n老师说每次任务结束就去遍历一遍这个延迟队列找到已到期的任务，这些任务其实就作为新的宏任务插在了现有任务后面。（这点其实我感觉老师没讲清楚造成了一些误解，那章好多评论问这个的）","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1609772559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1366121,"avatar":"","nickname":"张越","note":"","ucode":"10E354930A611A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288190,"discussion_content":"也没有说老师讲的不对，可能有的浏览器就这么去实现的呢，一直在看老师的课程，还是很精辟的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593674082,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1366121,"avatar":"","nickname":"张越","note":"","ucode":"10E354930A611A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288189,"discussion_content":"按照标准里面的说法，简单来讲，就没有延迟队列这个说法，而且消息队列准确来说，也不是一个队列，是分优先级的，放进这个“队列”里面的事件，优先级高的会先执行，优先级低的会后执行。同等优先级的才会是队列的表现，先进入的，先执行。对于setTimeout这种，也是，到时间后会被推到“队列”里面。只是我没有看到标准里面关于优先级的排序，哪些属于高优先级，哪些属于低优先级，没看到有这块儿。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593674007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132991,"user_name":"朱维娜🍍","can_delete":false,"product_type":"c1","uid":1625918,"ip_address":"","ucode":"2BE89ABFE2BF0C","user_header":"https://static001.geekbang.org/account/avatar/00/18/cf/3e/5c684022.jpg","comment_is_top":false,"comment_ctime":1568294006,"is_pvip":false,"replies":[{"id":"50951","content":"不是，宏任务，定时器产生的任务都会保存到延时队列中","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1568336415,"ip_address":"","comment_id":132991,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14453195894","product_id":100033601,"comment_content":"想知道 延时任务是不是一种微任务啊","like_count":3,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467204,"discussion_content":"不是，宏任务，定时器产生的任务都会保存到延时队列中","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568336415,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135460,"user_name":"AICC","can_delete":false,"product_type":"c1","uid":1020746,"ip_address":"","ucode":"C1D18B1E8B2DCE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/93/4a/de82f373.jpg","comment_is_top":false,"comment_ctime":1569168856,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10159103448","product_id":100033601,"comment_content":"老师什么时候出一个web安全的专栏啊，好想系统性的学学","like_count":2,"discussions":[{"author":{"id":1055073,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/sOvjoV6STk6SYPHRqVOo7DkiajY0KKuKLHSnDNvOKic5lllRNGEQo6W1oE6FrPiaSzUia1vCw9lqmV0vibCOtYtIfHQ/132","nickname":"余昭","note":"","ucode":"29EEEA1BFFE16B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400534,"discussion_content":"web安全攻防实战","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633314073,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133255,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1568465901,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"10158400493","product_id":100033601,"comment_content":"文中说：网络进程接收到数据之后，就会利用 IPC 来通知渲染进程；渲染进程接收到消息之后，会将 xhr 的回调函数封装成任务并添加到消息队列中<br>---------------------------------------------------------<br>这里网络进程收到数据之后，会进行资源请求的结果状态判断吗？ 只是把对应的资源请求的结果状态 和 响应数据通知给 渲染进程，然后渲染进程 根据请求结果状态选择对应的回调函数添加人任务队列中的呢？","like_count":2},{"had_liked":false,"id":132820,"user_name":"一粟","can_delete":false,"product_type":"c1","uid":1058773,"ip_address":"","ucode":"2EE966F3C36B5F","user_header":"https://static001.geekbang.org/account/avatar/00/10/27/d5/0fd21753.jpg","comment_is_top":false,"comment_ctime":1568247387,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10158181979","product_id":100033601,"comment_content":"随着互联网金融的发展，web安全越来越重要了","like_count":2},{"had_liked":false,"id":225080,"user_name":"james","can_delete":false,"product_type":"c1","uid":1232771,"ip_address":"","ucode":"AC42035106E5B9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/yyibGRYCArsUNBfCAEAibua09Yb9D5AdO8TkCmXymhAepibqmlz0hzg06ggBLxyvXicnjqFVGr7zYF0rQoZ0aXCBAg/132","comment_is_top":false,"comment_ctime":1591630432,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"5886597728","product_id":100033601,"comment_content":"三个点：<br>what（是什么）、why（为什么）、how（怎么做）","like_count":1},{"had_liked":false,"id":221308,"user_name":"zhangbao","can_delete":false,"product_type":"c1","uid":1383052,"ip_address":"","ucode":"9CA3D465BFBBF1","user_header":"https://static001.geekbang.org/account/avatar/00/15/1a/8c/d91b01a6.jpg","comment_is_top":false,"comment_ctime":1590468599,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5885435895","product_id":100033601,"comment_content":"老师好！关于 XMLHttpRequest 的工作机制，有一个疑问，想不太明白：xhr 的 onreadystatechange 回调，在整个请求过程中，会触发好几次，那么封装成任务的 xhr 的回调函数，第一次从消息队列中取出执行一次后，不就没有了吗，怎么能保证后续 state 改变时的还有回调来执行的呢？<br><br> ","like_count":1,"discussions":[{"author":{"id":2832562,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/38/b2/70464331.jpg","nickname":"不一样的少年～","note":"","ucode":"E015A50DF1BA96","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569814,"discussion_content":"onreadystatechange是一个事件，state的值发生改变就会触发执行onreadystatechange的事件句柄，事件监听这个过程中浏览器有专门的模块去处理，一旦触发事件，这个监听该事件的模块会有线程去处理onreadystatechange事件，处理后的结果即回调函数添加到消息队列中，等待主线程调用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651562912,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1698735,"avatar":"https://static001.geekbang.org/account/avatar/00/19/eb/af/e49af9a8.jpg","nickname":"JC.彦","note":"","ucode":"E87C1420B140F4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311120,"discussion_content":"我猜测是只执行状态中的某一个语句，也就是说，如果状态为4的话，前面的就不会执行了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602228743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1147347,"avatar":"https://static001.geekbang.org/account/avatar/00/11/81/d3/f0a88806.jpg","nickname":"🍐 🍾 🔆","note":"","ucode":"1B7C90800AD4D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278485,"discussion_content":"我也有这样的🤔️","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591192264,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204736,"user_name":"健忘症。","can_delete":false,"product_type":"c1","uid":1516183,"ip_address":"","ucode":"7B7BA77D3756A5","user_header":"https://static001.geekbang.org/account/avatar/00/17/22/97/5263baeb.jpg","comment_is_top":false,"comment_ctime":1586447610,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5881414906","product_id":100033601,"comment_content":"老师，我有一些疑问想请教您一下。<br><br>您说过 MutationObserver、和 Promise 是可以实现微任务的两种方式。<br>而微任务的执行时机又是主线程执行结束后，当前宏任务结束前的时机。<br>那么说明微任务是依赖与宏任务存在的，而宏任务是指存放在消息队列中的回调函数。<br>那是不是可以说，我使用 Promise 包装了一下 XMLHttpRequest 请求，有 .then 的操作，<br>那么 XMLHttpRequest 请求成功后返回的结果，通过 IPC 包装成了宏任务进入了消息队列中。<br>当消息队列执行到XMLHttpRequest 回调函数的时候，是执行了一个宏任务，那么为什么.then 中的回调函数就可以被判定为微任务而去执行的呢？？<br>还有一个问题就是，如果 Promise 并没有进行异步操作，而是直接 new Promise(resolve =&gt; {resolve(1)}).then((res) =&gt; {})<br>那么.then 中的回调函数还是否是一个微任务了呢？？<br><br>望指点一二，再次感谢老师的付出。","like_count":1,"discussions":[{"author":{"id":2542781,"avatar":"https://static001.geekbang.org/account/avatar/00/26/cc/bd/b067cb54.jpg","nickname":"DL","note":"","ucode":"420FEBEC9916EB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374776,"discussion_content":"promise不是微任务么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621343563,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1910075,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/25/3b/a971fc8e.jpg","nickname":"阿感","note":"","ucode":"7BCB7E44A832D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":256203,"discussion_content":"变成下一轮宏任务？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588435956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204205,"user_name":"KaKaKa","can_delete":false,"product_type":"c1","uid":1480732,"ip_address":"","ucode":"07D1980A71F321","user_header":"https://static001.geekbang.org/account/avatar/00/16/98/1c/d7a1439e.jpg","comment_is_top":false,"comment_ctime":1586351317,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5881318613","product_id":100033601,"comment_content":"执行 JS 代码是一个任务，执行任务时会维护一个系统调用栈。那当执行 JS 代码这个任务时，系统调用栈和 JS 代码内的执行上下文栈有什么关联？","like_count":1,"discussions":[{"author":{"id":1196864,"avatar":"https://static001.geekbang.org/account/avatar/00/12/43/40/e7ef18de.jpg","nickname":"嘉一","note":"","ucode":"8D16BD0B75B019","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263849,"discussion_content":"执行js代码是执行任务中间的一个环节，所以js代码的执行上下文和系统调用栈不是一个维度的东西，可以把执行任务看成是今天要上班，而执行js看成是上班过程中要写代码，而整个上班的过程你可能干了很多事情，比如说吃饭，午睡，写代码，和同事撕逼","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1589255023,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1910075,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/25/3b/a971fc8e.jpg","nickname":"阿感","note":"","ucode":"7BCB7E44A832D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":255886,"discussion_content":"等待回答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588431298,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133562,"user_name":"Geek_177f82","can_delete":false,"product_type":"c1","uid":1606961,"ip_address":"","ucode":"C1BF9B51E92995","user_header":"","comment_is_top":false,"comment_ctime":1568606285,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5863573581","product_id":100033601,"comment_content":"有个疑惑，就是使用setTimeout执行任务时会把任务添加到延迟消息队列，但是在函数中使用setTimeout就是异步回调。而异步回调函数有两种方式：1， 放入微任务处理；2，放入消息队列处理。这样以来就有点迷糊了。那使用setTimeout执行的任务到底应该放哪里执行。还是依据执行环境分别处理。希望老师解答疑惑。谢谢🙏！","like_count":1,"discussions":[{"author":{"id":1147347,"avatar":"https://static001.geekbang.org/account/avatar/00/11/81/d3/f0a88806.jpg","nickname":"🍐 🍾 🔆","note":"","ucode":"1B7C90800AD4D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":65414,"discussion_content":"看你的问题我懵了 延迟消息队列的的任务 最后还是会被放到消息队列去执行  settimeout 就只有这一种 不存在什么微任务 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575001481,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1672247,"avatar":"https://static001.geekbang.org/account/avatar/00/19/84/37/9c4dd979.jpg","nickname":"24601","note":"","ucode":"F6F0652D12D882","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":22820,"discussion_content":"1、上节有讲到 setTimeout执行任务时会把任务添加到“延迟队列”中，不是“消息队列”。2、异步回调函数 加入到“消息队列”有两种方式：1. 放入微任务处理；2.放入消息队列的队尾处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569687181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015542,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7e/f6/abb7bfe3.jpg","nickname":"永远蔡","note":"","ucode":"ABE9FA50A3C28D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":15959,"discussion_content":"同时希望老师解答疑惑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568864447,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":356485,"user_name":"Geek_89dbe0","can_delete":false,"product_type":"c1","uid":3119484,"ip_address":"浙江","ucode":"EEAF84552A1A5C","user_header":"","comment_is_top":false,"comment_ctime":1662360975,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662360975","product_id":100033601,"comment_content":"留下jio印","like_count":0},{"had_liked":false,"id":338179,"user_name":"zgy","can_delete":false,"product_type":"c1","uid":1387798,"ip_address":"","ucode":"05EA6845199250","user_header":"https://static001.geekbang.org/account/avatar/00/15/2d/16/b525a71d.jpg","comment_is_top":false,"comment_ctime":1647336365,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647336365","product_id":100033601,"comment_content":"突然出现的安全篇，是为下文点题吗？感觉上有点突兀。","like_count":0},{"had_liked":false,"id":325012,"user_name":"天择","can_delete":false,"product_type":"c1","uid":2166878,"ip_address":"","ucode":"ED2B08DB2F2B38","user_header":"https://static001.geekbang.org/account/avatar/00/21/10/5e/42f4faf7.jpg","comment_is_top":false,"comment_ctime":1638779522,"is_pvip":true,"discussion_count":0,"race_medal":4,"score":"1638779522","product_id":100033601,"comment_content":"这里面有个问题，网络请求回来之后，浏览器怎么知道把哪个callback任务放入队列呢？是每个callback和tcp请求之间（socket标识？）有映射关系？","like_count":0},{"had_liked":false,"id":321575,"user_name":"nabaonan","can_delete":false,"product_type":"c1","uid":1479089,"ip_address":"","ucode":"42FD44A56A08DD","user_header":"https://static001.geekbang.org/account/avatar/00/16/91/b1/ae745f2f.jpg","comment_is_top":false,"comment_ctime":1636952073,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636952073","product_id":100033601,"comment_content":"xmlhttprequest是开启的进程还是线程？我看网上有的文章说是开启的线程","like_count":0},{"had_liked":false,"id":307362,"user_name":"云销雨霁","can_delete":false,"product_type":"c1","uid":2547859,"ip_address":"","ucode":"0F3F5867B9EC82","user_header":"https://static001.geekbang.org/account/avatar/00/26/e0/93/c512e343.jpg","comment_is_top":false,"comment_ctime":1629042724,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629042724","product_id":100033601,"comment_content":"ontimeout， onerror 这些回调，已经在消息队列里，onreadystatechange = 4消息正确的被接受了，这些ontimeout， onerror任务什么时候会被清理呢","like_count":0},{"had_liked":false,"id":304617,"user_name":"Geek_bing","can_delete":false,"product_type":"c1","uid":2064266,"ip_address":"","ucode":"4000A30EDAF71C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/vkqibkINia6dxVOv5zia2zbkmQbrJUsQw8vDfiauib2DfyvJQ4PDUC7M8p4vqFiaQj70yYwIO8JlHFA450KPmgpsXlsw/132","comment_is_top":false,"comment_ctime":1627524072,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627524072","product_id":100033601,"comment_content":"解析html过程中，遇到样式表也会去解析，这是不是意味着解析样式表中css也会阻塞页面的渲染过程吗？css的解析和html的解析并不是同步的？","like_count":0},{"had_liked":false,"id":302597,"user_name":"温玉双","can_delete":false,"product_type":"c1","uid":2682989,"ip_address":"","ucode":"ECCD2BEA2EBB76","user_header":"https://static001.geekbang.org/account/avatar/00/28/f0/6d/a6be9d16.jpg","comment_is_top":false,"comment_ctime":1626275561,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626275561","product_id":100033601,"comment_content":"老师 我有个问题 http异步请求结束后会将回调通过进程通信 返回到消息队列中 那宏任务队列和这个回调的顺序是不固定的呢 比如我消息队列空了 开始从宏任务队列拿下一个宏任务的时候xhr返回了 那这个执行顺序是？<br>","like_count":0},{"had_liked":false,"id":301521,"user_name":"Lafite","can_delete":false,"product_type":"c1","uid":1391107,"ip_address":"","ucode":"42B3430F366930","user_header":"https://static001.geekbang.org/account/avatar/00/15/3a/03/bd7d8a6d.jpg","comment_is_top":false,"comment_ctime":1625727277,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625727277","product_id":100033601,"comment_content":"您好 李老师，能说一下xmlHttpRequest是如何实现针对页面进行部分无刷新更新的吗","like_count":0},{"had_liked":false,"id":291749,"user_name":"llIII😷","can_delete":false,"product_type":"c1","uid":2545180,"ip_address":"","ucode":"6D810B8186B8B5","user_header":"https://static001.geekbang.org/account/avatar/00/26/d6/1c/e4508ad2.jpg","comment_is_top":false,"comment_ctime":1620462535,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620462535","product_id":100033601,"comment_content":"if(this.status == 200||this.status == 304){ console.log(this.responseText); }<br>这个地方为什么可以用this来表示xhr实例？","like_count":0},{"had_liked":false,"id":291241,"user_name":"Lehamber","can_delete":false,"product_type":"c1","uid":2416820,"ip_address":"","ucode":"5882CCFD72C26A","user_header":"https://static001.geekbang.org/account/avatar/00/24/e0/b4/a8b7b04c.jpg","comment_is_top":false,"comment_ctime":1620136246,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620136246","product_id":100033601,"comment_content":"可以把系统调用栈比作 js的执行上下文栈，把子任务比作 js中的函数上下文，把主任务，比作全局执行上下文，这样的话，系统调用栈和 子任务的关系就可以搞清楚了。不知道我这样理解对不对？","like_count":0},{"had_liked":false,"id":291219,"user_name":"Lehamber","can_delete":false,"product_type":"c1","uid":2416820,"ip_address":"","ucode":"5882CCFD72C26A","user_header":"https://static001.geekbang.org/account/avatar/00/24/e0/b4/a8b7b04c.jpg","comment_is_top":false,"comment_ctime":1620125925,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620125925","product_id":100033601,"comment_content":"子任务在执行过程中是否也自己的 系统调用栈？执行完之后 是否也会去执行 自己的 微任务队列？","like_count":0},{"had_liked":false,"id":286547,"user_name":"Geek_2014ce","can_delete":false,"product_type":"c1","uid":2136469,"ip_address":"","ucode":"167B4CCDA4D5BD","user_header":"https://static001.geekbang.org/account/avatar/00/20/99/95/1e332315.jpg","comment_is_top":false,"comment_ctime":1617368175,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617368175","product_id":100033601,"comment_content":"只能老师再出个专栏才能高效的学习Web安全知识了，别说安全了。看了您讲的消息队列和事件循环才发现我之前听某大牛讲的是错的。","like_count":0},{"had_liked":false,"id":273300,"user_name":"啊哈哈","can_delete":false,"product_type":"c1","uid":1243584,"ip_address":"","ucode":"A8542946C03707","user_header":"https://static001.geekbang.org/account/avatar/00/12/f9/c0/20b4a205.jpg","comment_is_top":false,"comment_ctime":1610528174,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610528174","product_id":100033601,"comment_content":"有个疑惑，在一个事件循环中，执行完消息队列中的一个任务以后，紧接着执行延时队列中的到期任务，那它是把所有到期的延时任务呢还是执行一个，等在下次事件循环中再执行一个？","like_count":0},{"had_liked":false,"id":247765,"user_name":"超捻","can_delete":false,"product_type":"c1","uid":1471665,"ip_address":"","ucode":"9F19EFAD134006","user_header":"https://static001.geekbang.org/account/avatar/00/16/74/b1/5127757e.jpg","comment_is_top":false,"comment_ctime":1599824047,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599824047","product_id":100033601,"comment_content":"用jsp写的前端，有什么思路可以做到发送请求前对参数做加密？","like_count":0},{"had_liked":false,"id":241022,"user_name":"A君","can_delete":false,"product_type":"c1","uid":1940105,"ip_address":"","ucode":"FE96F089C2312C","user_header":"https://static001.geekbang.org/account/avatar/00/1d/9a/89/babe8b52.jpg","comment_is_top":false,"comment_ctime":1597153338,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1597153338","product_id":100033601,"comment_content":"flash是否就是用xmlhttprequest来实现页面数据更新的？","like_count":0},{"had_liked":false,"id":235621,"user_name":"Jankin","can_delete":false,"product_type":"c1","uid":2067161,"ip_address":"","ucode":"16084255D43B2C","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/o4jsp3yKTVthd1XfEA0ib1mXYFDULB2uUskUbLrtLbxy0AJFtuJqHAKjDSuDwiciazSAfE6fy2OfffLU8ayXmrWkg/132","comment_is_top":false,"comment_ctime":1595128662,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1595128662","product_id":100033601,"comment_content":"“每个任务在执行过程中都有自己的调用栈”<br>老师，这里讲的。。。每句话的意思是每个任务，比如解HTML，都是放在js引擎（主线程）里执行的吗，这样的话，调用栈就是执行上下文栈咯？","like_count":0,"discussions":[{"author":{"id":1516144,"avatar":"https://static001.geekbang.org/account/avatar/00/17/22/70/ab911260.jpg","nickname":"太白北路","note":"","ucode":"3C7E54D38408A3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298080,"discussion_content":"这里的调用栈应该是指浏览器维护的调用栈，和js引擎的调用栈不是一回事","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597164042,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235620,"user_name":"Jankin","can_delete":false,"product_type":"c1","uid":2067161,"ip_address":"","ucode":"16084255D43B2C","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/o4jsp3yKTVthd1XfEA0ib1mXYFDULB2uUskUbLrtLbxy0AJFtuJqHAKjDSuDwiciazSAfE6fy2OfffLU8ayXmrWkg/132","comment_is_top":false,"comment_ctime":1595128610,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595128610","product_id":100033601,"comment_content":"“每个任务在执行过程中都有自己的调用栈”","like_count":0},{"had_liked":false,"id":232673,"user_name":"Geek_525a15","can_delete":false,"product_type":"c1","uid":1643443,"ip_address":"","ucode":"422AC55BD5D618","user_header":"","comment_is_top":false,"comment_ctime":1594084678,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594084678","product_id":100033601,"comment_content":"我要是“怎么实现的”，不是它的调用方式","like_count":0},{"had_liked":false,"id":228026,"user_name":"OOP","can_delete":false,"product_type":"c1","uid":2015986,"ip_address":"","ucode":"FA536DFBF793F8","user_header":"https://static001.geekbang.org/account/avatar/00/1e/c2/f2/b3b349a4.jpg","comment_is_top":false,"comment_ctime":1592538586,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592538586","product_id":100033601,"comment_content":"讲的好棒","like_count":0},{"had_liked":false,"id":218368,"user_name":"江霖","can_delete":false,"product_type":"c1","uid":1051487,"ip_address":"","ucode":"D197B3FD012944","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLHOZjqhVkWgUrUibLnXkiaFkhJdfWT2BZP3LldE3tArIoHASlhTSp8tiatiamLbQOjKeMcYHkAexoyCg/132","comment_is_top":false,"comment_ctime":1589790209,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589790209","product_id":100033601,"comment_content":"function a() {<br>    new Promise(function b(resolve){<br>        axios.get().then(function c(){<br>            resolve()<br>        })<br>    })<br>}<br><br>a()<br><br>老师这段代码执行的过程是怎样的呢？<br>a执行后，ajax的回调会放入宏队列还是微队列呢？<br>如果是微队列，其他的宏队列的任务会等ajax返回后a的微队列处理完成再执行吗？","like_count":0},{"had_liked":false,"id":210047,"user_name":"shanzi","can_delete":false,"product_type":"c1","uid":1608695,"ip_address":"","ucode":"013D91BC16382F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJib1lsydmKBBqtOg3An1XdPh0kUzWrStVsU9HicVBQVibs5T6icdqACXR9GJAMj9pV9qGrHuVGIzm2lA/132","comment_is_top":false,"comment_ctime":1587656664,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587656664","product_id":100033601,"comment_content":"老师 这里我有个问题？<br>宏任务执行结束 然后执行当前宏任务中的微任务，你又说正常消息队列里的宏任务执行完后回把hashmap里到期的任务执行完， 那这三者的执行顺序是什么呢？<br>宏任务 ---&gt; 当前宏任务中的微任务 ---&gt; hashmap里到期的任务 ？<br>宏任务 ---&gt; hashmap里到期的任务 ---&gt; 当前宏任务中的微任务 ？","like_count":0},{"had_liked":false,"id":207205,"user_name":"Geek_gaoqin","can_delete":false,"product_type":"c1","uid":1646743,"ip_address":"","ucode":"760365FDCE6E27","user_header":"https://static001.geekbang.org/account/avatar/00/19/20/97/919f5e6b.jpg","comment_is_top":false,"comment_ctime":1587023832,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587023832","product_id":100033601,"comment_content":"老师你的文章真的写得很好啊，理解的很清楚! 老师可以后面加餐讲讲fetch的原理吗","like_count":0},{"had_liked":false,"id":158974,"user_name":"海之蓝心","can_delete":false,"product_type":"c1","uid":1098193,"ip_address":"","ucode":"C15210C86CDC13","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLReFZCZAq532WRg5Bjabx1WX997t0EVnsrLYcBnsNZDaDjk5jHvKDfRibjwibVjqtlm7S3eBJkwPtg/132","comment_is_top":false,"comment_ctime":1575509552,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1575509552","product_id":100033601,"comment_content":"老师，只有XMLHttpRequest 这种异步请求会出现的跨域问题吗，同步的请求也会吧？","like_count":0,"discussions":[{"author":{"id":1347300,"avatar":"https://static001.geekbang.org/account/avatar/00/14/8e/e4/f126ef1b.jpg","nickname":"芬兰湖边小画匠","note":"","ucode":"31289C9C4F4085","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":141468,"discussion_content":"跨域跟同步异步没有关系，是浏览器的安全策略","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579422822,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148552,"user_name":"双","can_delete":false,"product_type":"c1","uid":1465198,"ip_address":"","ucode":"FC31BC06C1592C","user_header":"https://static001.geekbang.org/account/avatar/00/16/5b/6e/37018f5e.jpg","comment_is_top":false,"comment_ctime":1573029775,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573029775","product_id":100033601,"comment_content":"老师，您好，有个疑惑想请教一下：<br>如果当前js执行过程中产生了异步回调，回调函数被封装成任务添加在消息队列末尾，正在执行的任务结束后（当前的js代码）,拉取消息队列中的回调函数进行执行，这时候的执行环境是什么呢，之前的js执行上下文已经消失了？？？","like_count":0},{"had_liked":false,"id":139896,"user_name":"韦一","can_delete":false,"product_type":"c1","uid":1438055,"ip_address":"","ucode":"8C9162A3F6B7B0","user_header":"https://static001.geekbang.org/account/avatar/00/15/f1/67/5e07d437.jpg","comment_is_top":false,"comment_ctime":1570761583,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570761583","product_id":100033601,"comment_content":"1，了解web安全历史，通过历史了解到都暴露出了哪些安全问题，然后他们是怎么解决的。<br>2，研究为什么会有这些安全问题，深究原因，才能更好理解解决方案。","like_count":0},{"had_liked":false,"id":134154,"user_name":"Lx","can_delete":false,"product_type":"c1","uid":1632217,"ip_address":"","ucode":"90F4EEE985A9B0","user_header":"https://static001.geekbang.org/account/avatar/00/18/e7/d9/83d1346c.jpg","comment_is_top":false,"comment_ctime":1568768071,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568768071","product_id":100033601,"comment_content":"之前看别的文章说浏览器有网络进程，而在渲染进程中除了js引擎线程，gui线程，定时器线程，异步请求线程，事件触发线程。我不太懂，异步请求线程和网络进程的功能边界是什么？","like_count":0},{"had_liked":false,"id":133403,"user_name":"summerrr","can_delete":false,"product_type":"c1","uid":1374579,"ip_address":"","ucode":"8AFF6EBF9202C5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Dib3LnwhqEL1cr0bWxM4picwSu2iaTchjy9YibeiboBIx0PaibBULUzgficsUzxPibyP66n18qWTbufKEGyGqzujph4Krg/132","comment_is_top":false,"comment_ctime":1568553129,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568553129","product_id":100033601,"comment_content":"老师，为什么xhr请求的回调是放在消息队列里面，而我们用axios这种http库发出的请求最后回调是放在微任务里面啊，虽然axios里面用到了promise，promise的回调是微任务，可是axios说到底还是对原生xhr的封装啊。","like_count":0},{"had_liked":false,"id":132892,"user_name":"隔夜果酱","can_delete":false,"product_type":"c1","uid":1319638,"ip_address":"","ucode":"5AFEB62E832BCB","user_header":"https://static001.geekbang.org/account/avatar/00/14/22/d6/9378f4d5.jpg","comment_is_top":false,"comment_ctime":1568261849,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1568261849","product_id":100033601,"comment_content":"老师您好,读了老师今天的分享,有些疑问想请教下.<br>xhr的配置信息会应用于网络进程么?<br>比如xhr超时设置为3s,网络进程如果到时没有收到相应信息,就主动通过IPC向消息队列添加一个err的任务么?<br>还是说这个配置信息是应用于渲染进程的?<br>","like_count":0,"discussions":[{"author":{"id":1480732,"avatar":"https://static001.geekbang.org/account/avatar/00/16/98/1c/d7a1439e.jpg","nickname":"KaKaKa","note":"","ucode":"07D1980A71F321","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":224715,"discussion_content":"设置完请求方法、url、超时时长后，建立 tcp 连接，这个时候网络进程是知道如果3秒没有返回的话，就通过 IPC 向渲染进程发通知，渲染进程就向消息队列添加一个 err 的任务，我是这样想的，如果说的有误请回复我~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586325013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}