{"id":508859,"title":"18｜DI Container（6）：如何实现循环依赖的检查？","content":"<p>你好，我是徐昊。今天我们继续使用TDD的方式实现注入依赖容器。</p><h2>回顾代码与任务列表</h2><p>到目前为止，我们的代码是这样的：</p><pre><code> ContextConfig.java: \n    \n    package geektime.tdd.di;\n    \n    import jakarta.inject.Inject;\n    import java.lang.reflect.Constructor;\n    import java.lang.reflect.InvocationTargetException;\n    import java.lang.reflect.Parameter;\n    import java.util.HashMap;\n    import java.util.List;\n    import java.util.Map;\n    import java.util.Optional;\n    import java.util.stream.Collectors;\n    import static java.util.Arrays.asList;\n    import static java.util.Arrays.stream;\n        \n    public class ContextConfig {\n        private Map&lt;Class&lt;?&gt;, ComponentProvider&lt;?&gt;&gt; providers = new HashMap&lt;&gt;();\n        private Map&lt;Class&lt;?&gt;, List&lt;Class&lt;?&gt;&gt;&gt; dependencies = new HashMap&lt;&gt;();\n        \n        public &lt;Type&gt; void bind(Class&lt;Type&gt; type, Type instance) {\n            providers.put(type, context -&gt; instance);\n            dependencies.put(type, asList());\n        }\n        \n        public &lt;Type, Implementation extends Type&gt;\n        void bind(Class&lt;Type&gt; type, Class&lt;Implementation&gt; implementation) {\n            Constructor&lt;Implementation&gt; injectConstructor = getInjectConstructor(implementation);\n            providers.put(type, new ConstructorInjectionProvider&lt;&gt;(type, injectConstructor));\n            dependencies.put(type, stream(injectConstructor.getParameters()).map(Parameter::getType).collect(Collectors.toList()));\n        }\n        \n        public Context getContext() {\n            for (Class&lt;?&gt; component: dependencies.keySet()) {\n                for (Class&lt;?&gt; dependency: dependencies.get(component)) {\n                    if (!dependencies.containsKey(dependency)) throw new DependencyNotFoundException(component, dependency);\n                }\n            }\n            return new Context() {\n                @Override\n                public &lt;Type&gt; Optional&lt;Type&gt; get(Class&lt;Type&gt; type) {\n                    return Optional.ofNullable(providers.get(type)).map(provider -&gt; (Type) provider.get(this));\n                }\n            };\n        }\n        \n        interface ComponentProvider&lt;T&gt; {\n            T get(Context context);\n        }\n        \n        class ConstructorInjectionProvider&lt;T&gt; implements ComponentProvider&lt;T&gt; {\n            private Class&lt;?&gt; componentType;\n            private Constructor&lt;T&gt; injectConstructor;\n            private boolean constructing = false;\n            public ConstructorInjectionProvider(Class&lt;?&gt; componentType, Constructor&lt;T&gt; injectConstructor) {\n                this.componentType = componentType;\n                this.injectConstructor = injectConstructor;\n            }\n            @Override\n            public T get(Context context) {\n                if (constructing) throw new CyclicDependenciesFoundException(componentType);\n                try {\n                    constructing = true;\n                    Object[] dependencies = stream(injectConstructor.getParameters())\n                            .map(p -&gt; context.get(p.getType())\n                                    .orElseThrow(() -&gt; new DependencyNotFoundException(componentType, p.getType())))\n                            .toArray(Object[]::new);\n                    return injectConstructor.newInstance(dependencies);\n                } catch (CyclicDependenciesFoundException e) {\n                    throw new CyclicDependenciesFoundException(componentType, e);\n                } catch (InvocationTargetException | InstantiationException | IllegalAccessException e) {\n                    throw new RuntimeException(e);\n                } finally {\n                    constructing = false;\n                }\n            }\n        }\n        \n        private &lt;Type&gt; Constructor&lt;Type&gt; getInjectConstructor(Class&lt;Type&gt; implementation) {\n            List&lt;Constructor&lt;?&gt;&gt; injectConstructors = stream(implementation.getConstructors())\n                    .filter(c -&gt; c.isAnnotationPresent(Inject.class)).collect(Collectors.toList());\n            if (injectConstructors.size() &gt; 1) throw new IllegalComponentException();\n            return (Constructor&lt;Type&gt;) injectConstructors.stream().findFirst().orElseGet(() -&gt; {\n                try {\n                    return implementation.getConstructor();\n                } catch (NoSuchMethodException e) {\n                    throw new IllegalComponentException();\n                }\n            });\n        }\n    }\n        \n    Context.java:\n        \n    package geektime.tdd.di;\n        \n    import java.util.Optional;\n     \n    public interface Context {\n        &lt;Type&gt; Optional&lt;Type&gt; get(Class&lt;Type&gt; type);\n    }\n</code></pre><p>任务列表状态为：</p><p><img src=\"https://static001.geekbang.org/resource/image/ce/4c/cebe21e8012af25ae8b11824cd73c44c.jpg?wh=6294x10999\" alt=\"\"></p><h2>视频演示</h2><p>让我们进入今天的部分：<br>\n<video poster=\"https://media001.geekbang.org/8714e798d59d4d9585e89584fc7dadc2/snapshots/e8856781ba0b4d1a910100899d82960b-00005.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/77ee8ec-1802c83b6fa-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/960df478457d43698e9ac3771eca498a/726039d610d5467a909ebb58c3bd227d-de0cb5f4b3a0dbab45b36e33498c0ba9-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><h2>思考题</h2><p>为了我们更好的交流与互动，从这节课开始，思考题目除了固定的技术问题外，我还会设置一道较为轻松的题目，供你选择与回答。</p><ol>\n<li>在当前的代码结构下，后续任务需要做何种改变？</li>\n<li>在学习课程的过程中，你对TDD的认识有发生什么变化吗？</li>\n</ol><p>欢迎把你的想法分享在留言区，也欢迎把你的项目代码的链接分享出来。相信经过你的思考与实操，学习效果会更好！</p><!-- [[[read_end]]] -->","neighbors":{"left":{"article_title":"17｜DI Container（5）：API接口该怎么设计？","id":508843},"right":{"article_title":"19｜DI Container（7）：如何实现Field Injection部分的功能？","id":510489}},"comments":[{"had_liked":false,"id":343392,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1650813000,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10240747592","product_id":100109401,"comment_content":"老师在微信群中提了一个思考题：学习重构这部分需要注意的地方<br>- 第一个，你们可以反思一下，bad smell 是什么的，是怎么发现的。这个最重要。<br>- 第二个，对比重构前和重构后的代码结构。到底做了什么改变。这个慢慢你们就会养成习惯，有重构的大局观。<br>- 第三个，列一下用的重构手法，看如何改变的。这个反而没那么重要，每个人做法也不一样。<br><br>我的理解<br><br>- 一、bad smell 是什么的，是怎么发现的<br>  - 违反**DRY原则**（Don’t repeat yourself）的最多<br>    - 实现逻辑：代码重复基本可以直接看出来（收留心观察就行）<br>    - 测试类：需要在重构后留意是否有重复的逻辑<br>  - 违反**YAGNI原则**（You ain’t gonna need it）<br>    - 实现逻辑：一波操作后，Idea 会提示没有被用到的变量、方法<br>    - 测试类：需要在重构后留意是否有没有被用到的代码<br>  - 违反 **KISS原则**（Keep it simple, stupid）<br>    - 实现逻辑：尽量让代码朝着更简单的方向发展<br>  - 违反**单一职责原则**<br>    - 一个类或方法承担了多个职责<br>  - 总结：设计原则的时候，就是 bad smell，需要及时重构<br>- 二、对比重构前和重构后的代码结构，到底做了什么改变<br>  - 重构前：<br>    - 简单粗暴实现功能，不要给我说什么设计原则、设计模式、数据结构、拿起键盘就是干！一把梭！<br>    - 对测试友好（因为是 TDD，代码再烂也不能直接翻车）<br>    - 对后期维护不友好，代码有点乱<br>  - 重构后：<br>    - 大部分代码符合设计原则、合理套用设计模式、正确使用数据结构<br>    - 对测试友好<br>    - 对后期维护友好，代码整洁、逻辑清晰<br>- 三、列一下用的重构手法，看如何改变的<br>  - 使用 Idea 快捷键进行重构（Extract 变量、方法参数、方法、类；inLine 方法；构造工厂方法；尽量使用接口等）<br>  - 通过**绞杀植物模式**替换旧的实现<br>    - 姚琪琳老师的 [遗留系统现代化实战 | 06 | 以增量演进为手段：为什么历时一年的改造到头来是一场空？](http:&#47;&#47;gk.link&#47;a&#47;11lAM)中有详细介绍<br><br>附录<br>设计原则：https:&#47;&#47;wyyl1.com&#47;post&#47;18&#47;02&#47;#51-%E4%B8%BA%E4%BD%95%E8%A6%81%E5%85%B3%E5%BF%83%E8%AE%BE%E8%AE%A1<br><br>格式化后的思考题：https:&#47;&#47;wyyl1.com&#47;post&#47;19&#47;wq&#47;#%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%AD%A6%E4%B9%A0%E9%87%8D%E6%9E%84%E8%BF%99%E9%83%A8%E5%88%86-","like_count":3},{"had_liked":false,"id":343391,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1650812955,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5945780251","product_id":100109401,"comment_content":"奇怪的问题<br>单独运行测试 void should_throw_exception_if_transitive_dependency_not_found() 不通过<br>整体运行 ContainerTest 则通过<br>使用命令运行和老师的测试结果一样：.&#47;gradlew test<br>代码：https:&#47;&#47;github.com&#47;wyyl1&#47;geektime-tdd-di-container&#47;tree&#47;di-container-6-strange<br>开发工具：IntelliJ IDEA 2021.3.3 (Community Edition)<br>环境：openjdk version &quot;17.0.1&quot; 2021-10-19","like_count":1,"discussions":[{"author":{"id":1246273,"avatar":"https://static001.geekbang.org/account/avatar/00/13/04/41/082e2706.jpg","nickname":"keep_curiosity","note":"","ucode":"794DC1D3FB9214","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569373,"discussion_content":"我也遇到过类似的现象，我是因为用了静态的map，case之间的上下文会互相影响。改成非静态的就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651415957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346186,"user_name":"奇小易","can_delete":false,"product_type":"c1","uid":1171151,"ip_address":"","ucode":"E06B4DFB5352BB","user_header":"https://static001.geekbang.org/account/avatar/00/11/de/cf/ef2e0501.jpg","comment_is_top":false,"comment_ctime":1652877535,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1652877535","product_id":100109401,"comment_content":"Q1：在当前的代码结构下，后续任务需要做何种改变？<br>按照现有代码结构下，方法注入和字段注入的实现可以预见应该是提供两个provider的实现来完成。<br>按照这个预期可以直接将这两部分的功能直接分到新的测试单元中进行测试。<br>因为目前的结构比较清晰，而最开始的时候并没有一个清晰的结构。<br>其它的功能目前同样没有明确的结构，所以不需要调整。这是我的理解。<br><br>Q2：在学习课程的过程中，你对 TDD 的认识有发生什么变化吗？<br>1、必须要在多种场景下见识下，TDD能够自己演进出合理的结构，才能真正的相信这种假设。<br>（这次重构后再次感受这种现实）<br>2、感觉在调整整个结构时的满足感好像比前面的重构更大。","like_count":0},{"had_liked":false,"id":345136,"user_name":"新的一页","can_delete":false,"product_type":"c1","uid":1509854,"ip_address":"","ucode":"DEF7A511BD905C","user_header":"https://static001.geekbang.org/account/avatar/00/17/09/de/eed196cf.jpg","comment_is_top":false,"comment_ctime":1652072687,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1652072687","product_id":100109401,"comment_content":"1. 我觉得后续的调整可以这样走，happy path放在config中，sadly path放在provider里面；<br>2. 实践TDD的时候，我发现需要一台好的机器，以支持我频繁的跑测试。","like_count":0},{"had_liked":false,"id":344276,"user_name":"keep_curiosity","can_delete":false,"product_type":"c1","uid":1246273,"ip_address":"","ucode":"794DC1D3FB9214","user_header":"https://static001.geekbang.org/account/avatar/00/13/04/41/082e2706.jpg","comment_is_top":false,"comment_ctime":1651416303,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651416303","product_id":100109401,"comment_content":"循环依赖抛出异常时，抛出具体要实例化的类型相比只抛接口的类型是不是对用户更友好？<br>本节课跟练结束后的tag：https:&#47;&#47;github.com&#47;codingthought&#47;TDD-DI&#47;releases&#47;tag&#47;18","like_count":0},{"had_liked":false,"id":343436,"user_name":"胡小寒","can_delete":false,"product_type":"c1","uid":2804273,"ip_address":"","ucode":"33271CB48A9F5D","user_header":"","comment_is_top":false,"comment_ctime":1650852811,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1650852811","product_id":100109401,"comment_content":"测试","like_count":0,"discussions":[{"author":{"id":1181867,"avatar":"https://static001.geekbang.org/account/avatar/00/12/08/ab/caec7bca.jpg","nickname":"humor","note":"","ucode":"9B48C4C7BEC92C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":567434,"discussion_content":"你这是回答的哪个问题啊？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650907277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343117,"user_name":"临风","can_delete":false,"product_type":"c1","uid":1145430,"ip_address":"","ucode":"59A7F3DDD94D76","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/56/29877cb9.jpg","comment_is_top":false,"comment_ctime":1650639071,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1650639071","product_id":100109401,"comment_content":"重构到contextConfig部分的时候，和老师的实现有所不同。我的理解中，老师是将通过一个context接口，将get逻辑通过context接口进行了二次的封装，来间接调用provider中的ComponentProvider来获取实例，再将原有的get方法从contextConfig调用，改为context调用，有点像对get方法做了一个aop的增强，这样就能实现dependencies的前置校验校验。<br>在我的实现中，我是将原本的context变为contextConfiguration，代码基本保持不变，新增initContainer方法。通过该方法将providers生成的实例，直接传递给新的Context类，在新的Context中保存在Map&lt;Class&lt;?&gt;, Object&gt; container中，然后把get方法移到Context类中。这样contextConfiguration只有bind的逻辑，而新的Context只有get的逻辑。但是我不知道我这样写会有什么问题，希望老师能指点一下。<br>https:&#47;&#47;github.com&#47;lenwind&#47;TDD-Learn","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":566510,"discussion_content":"生命周期 你这样岂不是默认都是单例了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650709032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342965,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1650552279,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650552279","product_id":100109401,"comment_content":"消除坏味道，这句语气很可爱","like_count":0},{"had_liked":false,"id":342539,"user_name":"Flynn","can_delete":false,"product_type":"c1","uid":1174517,"ip_address":"","ucode":"293321CC198C0C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/aY5QA2COoiaGy7P3MJzUIam3GG94GpA0fTx8yJN3OyBiaP3eNL65ia99H4RbaqC4fypg7JhBOujlJs7bBTdJKdMUQ/132","comment_is_top":false,"comment_ctime":1650331349,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650331349","product_id":100109401,"comment_content":"加餐想老师搞一节Android开发的TDD","like_count":0}]}