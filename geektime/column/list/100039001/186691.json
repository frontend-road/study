{"id":186691,"title":"29 | 理论三：什么是代码的可测试性？如何写出可测试性好的代码？","content":"<p>在上一节课中，我们对单元测试做了介绍，讲了“什么是单元测试？为什么要编写单元测试？如何编写单元测试？实践中单元测试为什么难贯彻执行？”这样几个问题。</p><p>实际上，写单元测试并不难，也不需要太多技巧，相反，写出可测试的代码反倒是件非常有挑战的事情。所以，今天，我们就再来聊一聊代码的可测试性，主要包括这样几个问题：</p><ul>\n<li>什么是代码的可测试性？</li>\n<li>如何写出可测试的代码？</li>\n<li>有哪些常见的不好测试的代码？</li>\n</ul><p>话不多说，让我们正式开始今天的学习吧！</p><h2>编写可测试代码案例实战</h2><p>刚刚提到的这几个关于代码可测试性的问题，我准备通过一个实战案例来讲解。具体的被测试代码如下所示。</p><p>其中，Transaction是经过我抽象简化之后的一个电商系统的交易类，用来记录每笔订单交易的情况。Transaction类中的execute()函数负责执行转账操作，将钱从买家的钱包转到卖家的钱包中。真正的转账操作是通过调用WalletRpcService RPC服务来完成的。除此之外，代码中还涉及一个分布式锁DistributedLock单例类，用来避免Transaction并发执行，导致用户的钱被重复转出。</p><pre><code>public class Transaction {\n  private String id;\n  private Long buyerId;\n  private Long sellerId;\n  private Long productId;\n  private String orderId;\n  private Long createTimestamp;\n  private Double amount;\n  private STATUS status;\n  private String walletTransactionId;\n  \n  // ...get() methods...\n  \n  public Transaction(String preAssignedId, Long buyerId, Long sellerId, Long productId, String orderId) {\n    if (preAssignedId != null &amp;&amp; !preAssignedId.isEmpty()) {\n      this.id = preAssignedId;\n    } else {\n      this.id = IdGenerator.generateTransactionId();\n    }\n    if (!this.id.startWith(&quot;t_&quot;)) {\n      this.id = &quot;t_&quot; + preAssignedId;\n    }\n    this.buyerId = buyerId;\n    this.sellerId = sellerId;\n    this.productId = productId;\n    this.orderId = orderId;\n    this.status = STATUS.TO_BE_EXECUTD;\n    this.createTimestamp = System.currentTimestamp();\n  }\n  \n  public boolean execute() throws InvalidTransactionException {\n    if ((buyerId == null || (sellerId == null || amount &lt; 0.0) {\n      throw new InvalidTransactionException(...);\n    }\n    if (status == STATUS.EXECUTED) return true;\n    boolean isLocked = false;\n    try {\n      isLocked = RedisDistributedLock.getSingletonIntance().lockTransction(id);\n      if (!isLocked) {\n        return false; // 锁定未成功，返回false，job兜底执行\n      }\n      if (status == STATUS.EXECUTED) return true; // double check\n      long executionInvokedTimestamp = System.currentTimestamp();\n      if (executionInvokedTimestamp - createdTimestap &gt; 14days) {\n        this.status = STATUS.EXPIRED;\n        return false;\n      }\n      WalletRpcService walletRpcService = new WalletRpcService();\n      String walletTransactionId = walletRpcService.moveMoney(id, buyerId, sellerId, amount);\n      if (walletTransactionId != null) {\n        this.walletTransactionId = walletTransactionId;\n        this.status = STATUS.EXECUTED;\n        return true;\n      } else {\n        this.status = STATUS.FAILED;\n        return false;\n      }\n    } finally {\n      if (isLocked) {\n       RedisDistributedLock.getSingletonIntance().unlockTransction(id);\n      }\n    }\n  }\n}\n</code></pre><p>对比上一节课中的Text类的代码，这段代码要复杂很多。如果让你给这段代码编写单元测试，你会如何来写呢？你可以先试着思考一下，然后再来看我下面的分析。</p><!-- [[[read_end]]] --><p>在Transaction类中，主要逻辑集中在execute()函数中，所以它是我们测试的重点对象。为了尽可能全面覆盖各种正常和异常情况，针对这个函数，我设计了下面6个测试用例。</p><ol>\n<li>正常情况下，交易执行成功，回填用于对账（交易与钱包的交易流水）用的walletTransactionId，交易状态设置为EXECUTED，函数返回true。</li>\n<li>buyerId、sellerId为null、amount小于0，返回InvalidTransactionException。</li>\n<li>交易已过期（createTimestamp超过14天），交易状态设置为EXPIRED，返回false。</li>\n<li>交易已经执行了（status==EXECUTED），不再重复执行转钱逻辑，返回true。</li>\n<li>钱包（WalletRpcService）转钱失败，交易状态设置为FAILED，函数返回false。</li>\n<li>交易正在执行着，不会被重复执行，函数直接返回false。</li>\n</ol><p>测试用例设计完了。现在看起来似乎一切进展顺利。但是，事实是，当我们将测试用例落实到具体的代码实现时，你就会发现有很多行不通的地方。对于上面的测试用例，第2个实现起来非常简单，我就不做介绍了。我们重点来看其中的1和3。测试用例4、5、6跟3类似，留给你自己来实现。</p><p>现在，我们就来看测试用例1的代码实现。具体如下所示：</p><pre><code>public void testExecute() {\n  Long buyerId = 123L;\n  Long sellerId = 234L;\n  Long productId = 345L;\n  Long orderId = 456L;\n  Transction transaction = new Transaction(null, buyerId, sellerId, productId, orderId);\n  boolean executedResult = transaction.execute();\n  assertTrue(executedResult);\n}\n</code></pre><p>execute()函数的执行依赖两个外部的服务，一个是RedisDistributedLock，一个WalletRpcService。这就导致上面的单元测试代码存在下面几个问题。</p><ul>\n<li>如果要让这个单元测试能够运行，我们需要搭建Redis服务和Wallet RPC服务。搭建和维护的成本比较高。</li>\n<li>我们还需要保证将伪造的transaction数据发送给Wallet RPC服务之后，能够正确返回我们期望的结果，然而Wallet RPC服务有可能是第三方（另一个团队开发维护的）的服务，并不是我们可控的。换句话说，并不是我们想让它返回什么数据就返回什么。</li>\n<li>Transaction的执行跟Redis、RPC服务通信，需要走网络，耗时可能会比较长，对单元测试本身的执行性能也会有影响。</li>\n<li>网络的中断、超时、Redis、RPC服务的不可用，都会影响单元测试的执行。</li>\n</ul><p>我们回到单元测试的定义上来看一下。单元测试主要是测试程序员自己编写的代码逻辑的正确性，并非是端到端的集成测试，它不需要测试所依赖的外部系统（分布式锁、Wallet RPC服务）的逻辑正确性。所以，如果代码中依赖了外部系统或者不可控组件，比如，需要依赖数据库、网络通信、文件系统等，那我们就需要将被测代码与外部系统解依赖，而这种解依赖的方法就叫作“mock”。所谓的mock就是用一个“假”的服务替换真正的服务。mock的服务完全在我们的控制之下，模拟输出我们想要的数据。</p><p>那如何来mock服务呢？mock的方式主要有两种，手动mock和利用框架mock。利用框架mock仅仅是为了简化代码编写，每个框架的mock方式都不大一样。我们这里只展示手动mock。</p><p>我们通过继承WalletRpcService类，并且重写其中的moveMoney()函数的方式来实现mock。具体的代码实现如下所示。通过mock的方式，我们可以让moveMoney()返回任意我们想要的数据，完全在我们的控制范围内，并且不需要真正进行网络通信。</p><pre><code>public class MockWalletRpcServiceOne extends WalletRpcService {\n  public String moveMoney(Long id, Long fromUserId, Long toUserId, Double amount) {\n    return &quot;123bac&quot;;\n  } \n}\n\npublic class MockWalletRpcServiceTwo extends WalletRpcService {\n  public String moveMoney(Long id, Long fromUserId, Long toUserId, Double amount) {\n    return null;\n  } \n}\n</code></pre><p>现在我们再来看，如何用MockWalletRpcServiceOne、MockWalletRpcServiceTwo来替换代码中的真正的WalletRpcService呢？</p><p>因为WalletRpcService是在execute()函数中通过new的方式创建的，我们无法动态地对其进行替换。也就是说，Transaction类中的execute()方法的可测试性很差，需要通过重构来让其变得更容易测试。该如何重构这段代码呢？</p><p>在<a href=\"https://time.geekbang.org/column/article/177444\">第19节</a>中，我们讲到，依赖注入是实现代码可测试性的最有效的手段。我们可以应用依赖注入，将WalletRpcService对象的创建反转给上层逻辑，在外部创建好之后，再注入到Transaction类中。重构之后的Transaction类的代码如下所示：</p><pre><code>public class Transaction {\n  //...\n  // 添加一个成员变量及其set方法\n  private WalletRpcService walletRpcService;\n  \n  public void setWalletRpcService(WalletRpcService walletRpcService) {\n    this.walletRpcService = walletRpcService;\n  }\n  // ...\n  public boolean execute() {\n    // ...\n    // 删除下面这一行代码\n    // WalletRpcService walletRpcService = new WalletRpcService();\n    // ...\n  }\n}\n</code></pre><p>现在，我们就可以在单元测试中，非常容易地将WalletRpcService替换成MockWalletRpcServiceOne或WalletRpcServiceTwo了。重构之后的代码对应的单元测试如下所示：</p><pre><code>public void testExecute() {\n  Long buyerId = 123L;\n  Long sellerId = 234L;\n  Long productId = 345L;\n  Long orderId = 456L;\n  Transction transaction = new Transaction(null, buyerId, sellerId, productId, orderId);\n  // 使用mock对象来替代真正的RPC服务\n  transaction.setWalletRpcService(new MockWalletRpcServiceOne()):\n  boolean executedResult = transaction.execute();\n  assertTrue(executedResult);\n  assertEquals(STATUS.EXECUTED, transaction.getStatus());\n}\n</code></pre><p>WalletRpcService的mock和替换问题解决了，我们再来看RedisDistributedLock。它的mock和替换要复杂一些，主要是因为RedisDistributedLock是一个单例类。单例相当于一个全局变量，我们无法mock（无法继承和重写方法），也无法通过依赖注入的方式来替换。</p><p>如果RedisDistributedLock是我们自己维护的，可以自由修改、重构，那我们可以将其改为非单例的模式，或者定义一个接口，比如IDistributedLock，让RedisDistributedLock实现这个接口。这样我们就可以像前面WalletRpcService的替换方式那样，替换RedisDistributedLock为MockRedisDistributedLock了。但如果RedisDistributedLock不是我们维护的，我们无权去修改这部分代码，这个时候该怎么办呢？</p><p>我们可以对transaction上锁这部分逻辑重新封装一下。具体代码实现如下所示：</p><pre><code>public class TransactionLock {\n  public boolean lock(String id) {\n    return RedisDistributedLock.getSingletonIntance().lockTransction(id);\n  }\n  \n  public void unlock() {\n    RedisDistributedLock.getSingletonIntance().unlockTransction(id);\n  }\n}\n\npublic class Transaction {\n  //...\n  private TransactionLock lock;\n  \n  public void setTransactionLock(TransactionLock lock) {\n    this.lock = lock;\n  }\n \n  public boolean execute() {\n    //...\n    try {\n      isLocked = lock.lock();\n      //...\n    } finally {\n      if (isLocked) {\n        lock.unlock();\n      }\n    }\n    //...\n  }\n}\n</code></pre><p>针对重构过的代码，我们的单元测试代码修改为下面这个样子。这样，我们就能在单元测试代码中隔离真正的RedisDistributedLock分布式锁这部分逻辑了。</p><pre><code>public void testExecute() {\n  Long buyerId = 123L;\n  Long sellerId = 234L;\n  Long productId = 345L;\n  Long orderId = 456L;\n  \n  TransactionLock mockLock = new TransactionLock() {\n    public boolean lock(String id) {\n      return true;\n    }\n  \n    public void unlock() {}\n  };\n  \n  Transction transaction = new Transaction(null, buyerId, sellerId, productId, orderId);\n  transaction.setWalletRpcService(new MockWalletRpcServiceOne());\n  transaction.setTransactionLock(mockLock);\n  boolean executedResult = transaction.execute();\n  assertTrue(executedResult);\n  assertEquals(STATUS.EXECUTED, transaction.getStatus());\n}\n</code></pre><p>至此，测试用例1就算写好了。我们通过依赖注入和mock，让单元测试代码不依赖任何不可控的外部服务。你可以照着这个思路，自己写一下测试用例4、5、6。</p><p>现在，我们再来看测试用例3：交易已过期（createTimestamp超过14天），交易状态设置为EXPIRED，返回false。针对这个单元测试用例，我们还是先把代码写出来，然后再来分析。</p><pre><code>public void testExecute_with_TransactionIsExpired() {\n  Long buyerId = 123L;\n  Long sellerId = 234L;\n  Long productId = 345L;\n  Long orderId = 456L;\n  Transction transaction = new Transaction(null, buyerId, sellerId, productId, orderId);\n  transaction.setCreatedTimestamp(System.currentTimestamp() - 14days);\n  boolean actualResult = transaction.execute();\n  assertFalse(actualResult);\n  assertEquals(STATUS.EXPIRED, transaction.getStatus());\n}\n</code></pre><p>上面的代码看似没有任何问题。我们将transaction的创建时间createdTimestamp设置为14天前，也就是说，当单元测试代码运行的时候，transaction一定是处于过期状态。但是，如果在Transaction类中，并没有暴露修改createdTimestamp成员变量的set方法（也就是没有定义setCreatedTimestamp()函数）呢？</p><p>你可能会说，如果没有createTimestamp的set方法，我就重新添加一个呗！实际上，这违反了类的封装特性。在Transaction类的设计中，createTimestamp是在交易生成时（也就是构造函数中）自动获取的系统时间，本来就不应该人为地轻易修改，所以，暴露createTimestamp的set方法，虽然带来了灵活性，但也带来了不可控性。因为，我们无法控制使用者是否会调用set方法重设createTimestamp，而重设createTimestamp并非我们的预期行为。</p><p>那如果没有针对createTimestamp的set方法，那测试用例3又该如何实现呢？实际上，这是一类比较常见的问题，就是代码中包含跟“时间”有关的“未决行为”逻辑。我们一般的处理方式是将这种未决行为逻辑重新封装。针对Transaction类，我们只需要将交易是否过期的逻辑，封装到isExpired()函数中即可，具体的代码实现如下所示：</p><pre><code>public class Transaction {\n\n  protected boolean isExpired() {\n    long executionInvokedTimestamp = System.currentTimestamp();\n    return executionInvokedTimestamp - createdTimestamp &gt; 14days;\n  }\n  \n  public boolean execute() throws InvalidTransactionException {\n    //...\n      if (isExpired()) {\n        this.status = STATUS.EXPIRED;\n        return false;\n      }\n    //...\n  }\n}\n</code></pre><p>针对重构之后的代码，测试用例3的代码实现如下所示：</p><pre><code>public void testExecute_with_TransactionIsExpired() {\n  Long buyerId = 123L;\n  Long sellerId = 234L;\n  Long productId = 345L;\n  Long orderId = 456L;\n  Transction transaction = new Transaction(null, buyerId, sellerId, productId, orderId) {\n    protected boolean isExpired() {\n      return true;\n    }\n  };\n  boolean actualResult = transaction.execute();\n  assertFalse(actualResult);\n  assertEquals(STATUS.EXPIRED, transaction.getStatus());\n}\n</code></pre><p>通过重构，Transaction代码的可测试性提高了。之前罗列的所有测试用例，现在我们都顺利实现了。不过，Transaction类的构造函数的设计还有点不妥。为了方便你查看，我把构造函数的代码重新copy了一份贴到这里。</p><pre><code>  public Transaction(String preAssignedId, Long buyerId, Long sellerId, Long productId, String orderId) {\n    if (preAssignedId != null &amp;&amp; !preAssignedId.isEmpty()) {\n      this.id = preAssignedId;\n    } else {\n      this.id = IdGenerator.generateTransactionId();\n    }\n    if (!this.id.startWith(&quot;t_&quot;)) {\n      this.id = &quot;t_&quot; + preAssignedId;\n    }\n    this.buyerId = buyerId;\n    this.sellerId = sellerId;\n    this.productId = productId;\n    this.orderId = orderId;\n    this.status = STATUS.TO_BE_EXECUTD;\n    this.createTimestamp = System.currentTimestamp();\n  }\n</code></pre><p>我们发现，构造函数中并非只包含简单赋值操作。交易id的赋值逻辑稍微复杂。我们最好也要测试一下，以保证这部分逻辑的正确性。为了方便测试，我们可以把id赋值这部分逻辑单独抽象到一个函数中，具体的代码实现如下所示：</p><pre><code>  public Transaction(String preAssignedId, Long buyerId, Long sellerId, Long productId, String orderId) {\n    //...\n    fillTransactionId(preAssignId);\n    //...\n  }\n  \n  protected void fillTransactionId(String preAssignedId) {\n    if (preAssignedId != null &amp;&amp; !preAssignedId.isEmpty()) {\n      this.id = preAssignedId;\n    } else {\n      this.id = IdGenerator.generateTransactionId();\n    }\n    if (!this.id.startWith(&quot;t_&quot;)) {\n      this.id = &quot;t_&quot; + preAssignedId;\n    }\n  }\n</code></pre><p>到此为止，我们一步一步将Transaction从不可测试代码重构成了测试性良好的代码。不过，你可能还会有疑问，Transaction类中isExpired()函数就不用测试了吗？对于isExpired()函数，逻辑非常简单，肉眼就能判定是否有bug，是可以不用写单元测试的。</p><p>实际上，可测试性差的代码，本身代码设计得也不够好，很多地方都没有遵守我们之前讲到的设计原则和思想，比如“基于接口而非实现编程”思想、依赖反转原则等。重构之后的代码，不仅可测试性更好，而且从代码设计的角度来说，也遵从了经典的设计原则和思想。这也印证了我们之前说过的，代码的可测试性可以从侧面上反应代码设计是否合理。除此之外，在平时的开发中，我们也要多思考一下，这样编写代码，是否容易编写单元测试，这也有利于我们设计出好的代码。</p><h2>其他常见的Anti-Patterns</h2><p>刚刚我们通过一个实战案例，讲解了如何利用依赖注入来提高代码的可测试性，以及编写单元测试中最复杂的一部分内容：如何通过mock、二次封装等方式解依赖外部服务。现在，我们再来总结一下，有哪些典型的、常见的测试性不好的代码，也就是我们常说的Anti-Patterns。</p><h3>1.未决行为</h3><p>所谓的未决行为逻辑就是，代码的输出是随机或者说不确定的，比如，跟时间、随机数有关的代码。对于这一点，在刚刚的实战案例中我们已经讲到，你可以利用刚才讲到的方法，试着重构一下下面的代码，并且为它编写单元测试。</p><pre><code>public class Demo {\n  public long caculateDelayDays(Date dueTime) {\n    long currentTimestamp = System.currentTimeMillis();\n    if (dueTime.getTime() &gt;= currentTimestamp) {\n      return 0;\n    }\n    long delayTime = currentTimestamp - dueTime.getTime();\n    long delayDays = delayTime / 86400;\n    return delayDays;\n  }\n}\n</code></pre><h3>2.全局变量</h3><p>前面我们讲过，全局变量是一种面向过程的编程风格，有种种弊端。实际上，滥用全局变量也让编写单元测试变得困难。我举个例子来解释一下。</p><p>RangeLimiter表示一个[-5, 5]的区间，position初始在0位置，move()函数负责移动position。其中，position是一个静态全局变量。RangeLimiterTest类是为其设计的单元测试，不过，这里面存在很大的问题，你可以先自己分析一下。</p><pre><code>public class RangeLimiter {\n  private static AtomicInteger position = new AtomicInteger(0);\n  public static final int MAX_LIMIT = 5;\n  public static final int MIN_LIMIT = -5;\n\n  public boolean move(int delta) {\n    int currentPos = position.addAndGet(delta);\n    boolean betweenRange = (currentPos &lt;= MAX_LIMIT) &amp;&amp; (currentPos &gt;= MIN_LIMIT);\n    return betweenRange;\n  }\n}\n\npublic class RangeLimiterTest {\n  public void testMove_betweenRange() {\n    RangeLimiter rangeLimiter = new RangeLimiter();\n    assertTrue(rangeLimiter.move(1));\n    assertTrue(rangeLimiter.move(3));\n    assertTrue(rangeLimiter.move(-5));\n  }\n\n  public void testMove_exceedRange() {\n    RangeLimiter rangeLimiter = new RangeLimiter();\n    assertFalse(rangeLimiter.move(6));\n  }\n}\n</code></pre><p>上面的单元测试有可能会运行失败。假设单元测试框架顺序依次执行testMove_betweenRange()和testMove_exceedRange()两个测试用例。在第一个测试用例执行完成之后，position的值变成了-1；再执行第二个测试用例的时候，position变成了5，move()函数返回true，assertFalse语句判定失败。所以，第二个测试用例运行失败。</p><p>当然，如果RangeLimiter类有暴露重设（reset）position值的函数，我们可以在每次执行单元测试用例之前，把position重设为0，这样就能解决刚刚的问题。</p><p>不过，每个单元测试框架执行单元测试用例的方式可能是不同的。有的是顺序执行，有的是并发执行。对于并发执行的情况，即便我们每次都把position重设为0，也并不奏效。如果两个测试用例并发执行，第16、17、18、23这四行代码可能会交叉执行，影响到move()函数的执行结果。</p><h3>3.静态方法</h3><p>前面我们也提到，静态方法跟全局变量一样，也是一种面向过程的编程思维。在代码中调用静态方法，有时候会导致代码不易测试。主要原因是静态方法也很难mock。但是，这个要分情况来看。只有在这个静态方法执行耗时太长、依赖外部资源、逻辑复杂、行为未决等情况下，我们才需要在单元测试中mock这个静态方法。除此之外，如果只是类似Math.abs()这样的简单静态方法，并不会影响代码的可测试性，因为本身并不需要mock。</p><h3>4.复杂继承</h3><p>我们前面提到，相比组合关系，继承关系的代码结构更加耦合、不灵活，更加不易扩展、不易维护。实际上，继承关系也更加难测试。这也印证了代码的可测试性跟代码质量的相关性。</p><p>如果父类需要mock某个依赖对象才能进行单元测试，那所有的子类、子类的子类……在编写单元测试的时候，都要mock这个依赖对象。对于层次很深（在继承关系类图中表现为纵向深度）、结构复杂（在继承关系类图中表现为横向广度）的继承关系，越底层的子类要mock的对象可能就会越多，这样就会导致，底层子类在写单元测试的时候，要一个一个mock很多依赖对象，而且还需要查看父类代码，去了解该如何mock这些依赖对象。</p><p>如果我们利用组合而非继承来组织类之间的关系，类之间的结构层次比较扁平，在编写单元测试的时候，只需要mock类所组合依赖的对象即可。</p><h3>5.高耦合代码</h3><p>如果一个类职责很重，需要依赖十几个外部对象才能完成工作，代码高度耦合，那我们在编写单元测试的时候，可能需要mock这十几个依赖的对象。不管是从代码设计的角度来说，还是从编写单元测试的角度来说，这都是不合理的。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p><strong>1.什么是代码的可测试性？</strong></p><p>粗略地讲，所谓代码的可测试性，就是针对代码编写单元测试的难易程度。对于一段代码，如果很难为其编写单元测试，或者单元测试写起来很费劲，需要依靠单元测试框架中很高级的特性，那往往就意味着代码设计得不够合理，代码的可测试性不好。</p><p><strong>2.编写可测试性代码的最有效手段</strong></p><p>依赖注入是编写可测试性代码的最有效手段。通过依赖注入，我们在编写单元测试的时候，可以通过mock的方法解依赖外部服务，这也是我们在编写单元测试的过程中最有技术挑战的地方。</p><p><strong>3.常见的Anti-Patterns</strong></p><p>常见的测试不友好的代码有下面这5种：</p><ul>\n<li>代码中包含未决行为逻辑</li>\n<li>滥用可变全局变量</li>\n<li>滥用静态方法</li>\n<li>使用复杂的继承关系</li>\n<li>高度耦合的代码</li>\n</ul><h2>课堂讨论</h2><ol>\n<li>实战案例中的void fillTransactionId(String preAssignedId)函数中包含一处静态函数调用：IdGenerator.generateTransactionId()，这是否会影响到代码的可测试性？在写单元测试的时候，我们是否需要mock这个函数？</li>\n<li>我们今天讲到，依赖注入是提高代码可测试性的最有效的手段。所以，依赖注入，就是不要在类内部通过new的方式创建对象，而是要通过外部创建好之后传递给类使用。那是不是所有的对象都不能在类内部创建呢？哪种类型的对象可以在类内部创建并且不影响代码的可测试性？你能举几个例子吗？</li>\n</ol><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>","comments":[{"had_liked":false,"id":169761,"user_name":"失火的夏天","can_delete":false,"product_type":"c1","uid":1241770,"ip_address":"","ucode":"10C6E66EB2A65F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","comment_is_top":false,"comment_ctime":1578443379,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"701658112627","product_id":100039001,"comment_content":"思考题1，该方法逻辑就是填充一个ID，基本都是内部实现的一个id生成器，可以不用重写。一定要重写也行，自己弄一个自增id实现就行了。<br>思考题2，提供方法的类不要new，也就是我们常说的service类，这个是要依赖注入的。提供属性的类，比如vo，bo，entity这些就可以new。","like_count":164,"discussions":[{"author":{"id":1114093,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ff/ed/b2fc0e7c.jpg","nickname":"7","note":"","ucode":"10A6E57A027D42","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541163,"discussion_content":"思考题二，补充一点。主代码的执行情况，并不与new出来对象的方法执行情况耦合","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640271429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2475056,"avatar":"https://static001.geekbang.org/account/avatar/00/25/c4/30/711b03e5.jpg","nickname":"Geek_Candice","note":"","ucode":"0F2CBCF624F905","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371969,"discussion_content":"棒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620109415,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173308,"user_name":"楊_宵夜","can_delete":false,"product_type":"c1","uid":1019302,"ip_address":"","ucode":"7BA0CADC5F23BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/a6/22c37c91.jpg","comment_is_top":false,"comment_ctime":1579501200,"is_pvip":false,"replies":[{"id":"67739","content":"也是没办法的事情，理论上应该是private的。所以会有@VisibleForTesting这样的annotation","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1580117345,"ip_address":"","comment_id":173308,"utype":1}],"discussion_count":8,"race_medal":0,"score":"302227211920","product_id":100039001,"comment_content":"争歌, 代码中isExpired()方法的修饰符是protected, 如果某些方法从设计原则来说应该设置为private的话, 那么这样的手动mock的方式是否就不适用了呢?<br>换个角度来提问: 为了维持可测试性, 在代码中加入过多protected的方法, 是否合理呢?","like_count":71},{"had_liked":false,"id":169774,"user_name":"安静的boy","can_delete":false,"product_type":"c1","uid":1196475,"ip_address":"","ucode":"F5F44B75228A85","user_header":"https://static001.geekbang.org/account/avatar/00/12/41/bb/21ce60d2.jpg","comment_is_top":false,"comment_ctime":1578445377,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"250686548545","product_id":100039001,"comment_content":"这节满满的干货👍👍👍","like_count":59},{"had_liked":false,"id":169785,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1578446537,"is_pvip":true,"discussion_count":7,"race_medal":0,"score":"156197269193","product_id":100039001,"comment_content":"参考争哥今天的代码写了例子中的测试（可运行）：<br>https:&#47;&#47;github.com&#47;gdhucoder&#47;Algorithms4&#47;tree&#47;master&#47;designpattern&#47;u29<br><br>今天学习到了高级的单元测试方法：<br>1、依赖外部单例：将单例封装<br>2、未决行为：例时间、随机数。将未决行为重新封装，测试时mock，使用匿名类。<br><br> 关于讨论1：需要mock的情况id会写入数据库的话，测试后需要恢复现场。曾经遇到过这么一个情况，id是通过一张表维护的，大于0，在代码中id的数据类型是Integer（遗留代码），由于测试时没有恢复现场，导致测试数据库中id增加过快，超过了代码中Integer的表示范围，而产生了意想不到的问题。","like_count":37,"discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":131121,"discussion_content":"哪里，别叫我大神了，这段时间在上学，三年没写也业务代码了。这篇是郑晔老师讲关于测试的：https://time.geekbang.org/column/article/79494，关于测试问题他还写了框架：https://github.com/dreamhead/moco 3k stars。看能否对你有帮助。另外你的问题最后如果解决了的话，希望能告诉我一下解决方法，谢谢！","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1578828147,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1092806,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ac/c6/30820fa2.jpg","nickname":"李阳","note":"","ucode":"22492F371F4C84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297648,"discussion_content":"这种测试用例一般用spring test就行了，测试完加上注解不提交事务。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597016466,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1325226,"avatar":"https://static001.geekbang.org/account/avatar/00/14/38/aa/5efa5ded.jpg","nickname":"_Sea","note":"","ucode":"8547A37BA766E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":130976,"discussion_content":"大神，请教一下；现在我们项目在做第三方支付的模块，也需要写单元测试，而且代码覆盖率要求90以上；有个问题就是在调用支付宝第三方接口的时候，写单元测试时很不好写，特别是异步回调验签的时候，逻辑分支多，需要自己照着支付宝的返回数据格式预置很多数据，类似这种调用第三方API支付与校验的有没有比较好的方法测试？ ps:我们使用的是Spring junit5","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578816196,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1610643,"avatar":"","nickname":"Geek_02ab4d","note":"","ucode":"2EC4198426A4A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":409990,"discussion_content":"public isExpere() -> protected?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635564810,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2115387,"avatar":"https://static001.geekbang.org/account/avatar/00/20/47/3b/70198ceb.jpg","nickname":"Aibo","note":"","ucode":"2CE3E77BD2D014","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325830,"discussion_content":"有数据库操作，不就是类似文章中对redis的依赖吗。可以重构去mock吧，或者就是一套功能按一个流程测试，先新增再修改，最后删除。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605440506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1003644,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/50/7c/9082fb04.jpg","nickname":"林","note":"","ucode":"727C1E5E21E126","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":156561,"discussion_content":"「高级的单元测试方法」的1、2，都是将相关逻辑封装起来，使用匿名类进行mock吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580379830,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1698258,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIx7FdRzUuQf4Fopr7DOXEHZyCFfH4GQViaqo7bymf1qaANcOvuEhHyTNwOOUFW7psxEeSQ5k9uXWw/132","nickname":"阿顺","note":"","ucode":"36F2AD6F980B11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":134923,"discussion_content":"beforeEach和afterEach派上用场了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579055372,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221883,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1590628368,"is_pvip":false,"replies":[{"id":"87067","content":"这个不叫高度耦合吧。不是说耦合很多就是高度耦合，也要看业务需求啊，确实要这么多数据，那必然要以来这么多服务。还有，为了前端获取数据简单，可以用facade模式，包裹一层接口。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1595207745,"ip_address":"","comment_id":221883,"utype":1}],"discussion_count":1,"race_medal":0,"score":"83195006992","product_id":100039001,"comment_content":"老师，下面这句话不是很理解，如果我的某个接口就是需要依赖很多服务才能把结果正确返回给前端，这时候怎么办？比如查询购物车，需要访问商品服务的商品信息，优惠服务的优惠信息，同时访问价格服务的价格信息等等，这个时候，高度耦合怎么去避免呢？<br><br><br><br>如果一个类职责很重，需要依赖十几个外部对象才能完成工作，代码高度耦合，那我们在编写单元测试的时候，可能需要 mock 这十几个依赖的对象。不管是从代码设计的角度来说，还是从编写单元测试的角度来说，这都是不合理的。","like_count":20,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496598,"discussion_content":"这个不叫高度耦合吧。不是说耦合很多就是高度耦合，也要看业务需求啊，确实要这么多数据，那必然要以来这么多服务。还有，为了前端获取数据简单，可以用facade模式，包裹一层接口。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595207745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169758,"user_name":"桂城老托尼","can_delete":false,"product_type":"c1","uid":1306032,"ip_address":"","ucode":"139E4B8EE88B79","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJcxSpNMqwqyicMvdOSr9ic0p1ABiauHnv7g7YQVSJuoHPoQbYDu3YzdpgmSAk2KricUBQ5yibWBWIq75w/132","comment_is_top":false,"comment_ctime":1578441893,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"61707984037","product_id":100039001,"comment_content":"感谢争哥分享<br>课后讨论1.id的生成逻辑有点没看懂，单纯从代码覆盖上看，fillTransactionId 未覆盖完全，需要mock下这个静态方法，当然也有其他分支逻辑可以覆盖。<br>id没有在execute方法中不是核心属性(mock方法的入参)，不影响execute的可测试性。 id的生成用静态方法真的好么？<br>2.有行为的对象不适合在类中new，尽量使用依赖注入，依赖接口编程，而不是具体的实现。 数据对象适合在类中new 比如各种model do vo info 。<br>一家之言欢迎讨论指正。","like_count":15,"discussions":[{"author":{"id":1132304,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/10/2d673601.jpg","nickname":"好饿早知道送外卖了","note":"","ucode":"AED22DB5BF8FC7","race_medal":2,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":167485,"discussion_content":"小白问个问题啊，为什么数据对象适合在类中new呢。如果测试的时候需要特定的数据？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581501985,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1306032,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJcxSpNMqwqyicMvdOSr9ic0p1ABiauHnv7g7YQVSJuoHPoQbYDu3YzdpgmSAk2KricUBQ5yibWBWIq75w/132","nickname":"桂城老托尼","note":"","ucode":"139E4B8EE88B79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1132304,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/10/2d673601.jpg","nickname":"好饿早知道送外卖了","note":"","ucode":"AED22DB5BF8FC7","race_medal":2,"user_type":1,"is_pvip":false},"discussion":{"id":168843,"discussion_content":"我的理解是数据对象对外没有行为，只是作为数据传输用途，不会对实现产生依赖。 ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581596723,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":167485,"ip_address":""},"score":168843,"extra":""}]}]},{"had_liked":false,"id":169917,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1578472448,"is_pvip":false,"replies":[{"id":"65939","content":"😁 感谢认可！","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1578488789,"ip_address":"","comment_id":169917,"utype":1}],"discussion_count":2,"race_medal":0,"score":"53118080000","product_id":100039001,"comment_content":"看到一半，我就来评论，老师收下我的膝盖，太强了","like_count":13},{"had_liked":false,"id":183919,"user_name":"Jessica","can_delete":false,"product_type":"c1","uid":1084877,"ip_address":"","ucode":"9FC7E9BD3FE9F1","user_header":"https://static001.geekbang.org/account/avatar/00/10/8d/cd/b6bdc1b2.jpg","comment_is_top":false,"comment_ctime":1583162302,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"40237867966","product_id":100039001,"comment_content":"public class Demo { <br>    public long caculateDelayDays(Date dueTime，long currentTimestamp) { <br>        if (dueTime.getTime() &gt;= currentTimestamp) { <br>            return 0; <br>        } <br>        long delayTime = currentTimestamp - dueTime.getTime(); <br>        long delayDays = delayTime &#47; 86400; return delayDays; <br>    }<br><br>    private long getCurrentTimestamp() {<br>        return System.currentTimeMillis(); <br>    }<br>}<br><br>mock掉getCurrentTimestamp（）, dueTime给定固定的时间，只检查逻辑是否符合预期","like_count":9,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473230,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572912393,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1261108,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3e/34/dd0a3c61.jpg","nickname":"爱吃彩虹糖的猫~","note":"","ucode":"9EC7A8FD4B7DB1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":43183,"discussion_content":"王争老师应该会用伪代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572861821,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1623626,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c6/4a/3bd896fc.jpg","nickname":"Heiky","note":"","ucode":"03AA79E1BC4AE4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1261108,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3e/34/dd0a3c61.jpg","nickname":"爱吃彩虹糖的猫~","note":"","ucode":"9EC7A8FD4B7DB1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":43235,"discussion_content":"看介绍，课程说明是用的Java来讲授","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572864832,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":43183,"ip_address":""},"score":43235,"extra":""}]}]},{"had_liked":false,"id":173254,"user_name":"小伟","can_delete":false,"product_type":"c1","uid":1359701,"ip_address":"","ucode":"124953423491E2","user_header":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","comment_is_top":false,"comment_ctime":1579487383,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35939225751","product_id":100039001,"comment_content":"思考题：<br>1. 看IdGenerator怎么实现，如果要查数据库或分布式服务，那么会有影响，需要mock；如果是本地生产，不需要mock。<br>2. 个人观点，不要在方法里new对象，依赖都要以注入的方式获取。","like_count":9},{"had_liked":false,"id":169811,"user_name":"Jesse","can_delete":false,"product_type":"c1","uid":1368038,"ip_address":"","ucode":"727CA882B84DA0","user_header":"https://static001.geekbang.org/account/avatar/00/14/df/e6/bd1b3c0b.jpg","comment_is_top":false,"comment_ctime":1578450183,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"35938188551","product_id":100039001,"comment_content":"思考题1，该方法产生一个唯一的ID,我认为不需要mock。<br>思考题2，我觉得如果对象有行为，并且行为与外部系统交互或者执行的结果具有不确定性，就需要依赖注入来完成测试。如果对象的行为是可预测的并且唯一的，可以直接new。","like_count":9},{"had_liked":false,"id":169875,"user_name":"逍遥思","can_delete":false,"product_type":"c1","uid":1015512,"ip_address":"","ucode":"340F05C786730F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/d8/92a98fb6.jpg","comment_is_top":false,"comment_ctime":1578467085,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27348270861","product_id":100039001,"comment_content":"1. 不会影响可测试性，因为 generateTransactionId 并不需要依赖什么外部服务，所以也不需要 mock<br>2. 不是。不依赖外部服务的类就可以内部创建，比如 String","like_count":6},{"had_liked":false,"id":227552,"user_name":"Vincent.X","can_delete":false,"product_type":"c1","uid":1538604,"ip_address":"","ucode":"8A40B5B2F4B102","user_header":"https://static001.geekbang.org/account/avatar/00/17/7a/2c/54b48459.jpg","comment_is_top":false,"comment_ctime":1592406872,"is_pvip":false,"replies":[{"id":"83993","content":"只能@一下编辑了","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1592525525,"ip_address":"","comment_id":227552,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23067243352","product_id":100039001,"comment_content":"手机看代码有老是要拖动，有什么解决的办法吗？？","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498681,"discussion_content":"只能@一下编辑了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592525525,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169938,"user_name":"下雨天","can_delete":false,"product_type":"c1","uid":1008315,"ip_address":"","ucode":"816B3792ECC50A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/62/bb/323a3133.jpg","comment_is_top":false,"comment_ctime":1578477594,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18758346778","product_id":100039001,"comment_content":"问题回答：<br>1. IdGenerator.generateTransactionId()有未决行为逻辑，但不是说有未决行为就一定影响可测试性，前提是需要看未决行为是否有测试必要性，此处生成一个随机数(类似 System.currentTimeMillis())，测试意义不大！<br><br>2.贫血模型实体类","like_count":4},{"had_liked":false,"id":169800,"user_name":"美美","can_delete":false,"product_type":"c1","uid":1148422,"ip_address":"","ucode":"44CC95C45AF345","user_header":"https://static001.geekbang.org/account/avatar/00/11/86/06/72b01bb7.jpg","comment_is_top":false,"comment_ctime":1578447997,"is_pvip":false,"replies":[{"id":"65942","content":"可以借助springtest测试框架来做","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1578488960,"ip_address":"","comment_id":169800,"utype":1}],"discussion_count":4,"race_medal":0,"score":"18758317181","product_id":100039001,"comment_content":"有多个通过spring注入的类时，应该怎么做测试呢？","like_count":4,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480724,"discussion_content":"可以借助springtest测试框架来做","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578488960,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":143015,"discussion_content":"mockito+jmockit，mock界的super star","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1579487662,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1103189,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d5/55/ce3f814f.jpg","nickname":"莴笋","note":"","ucode":"2B9650104285AD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":124852,"discussion_content":"用Mockito","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578453784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1109844,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ef/54/58a61a50.jpg","nickname":"룡걸이","note":"","ucode":"ACC366BD4E7385","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":124810,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578451577,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":256924,"user_name":"郑大钱","can_delete":false,"product_type":"c1","uid":1503067,"ip_address":"","ucode":"114CF48056880E","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/5b/ff28088f.jpg","comment_is_top":false,"comment_ctime":1603784929,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14488686817","product_id":100039001,"comment_content":"作为一个码农，职责是在有限时间里，完成尽可能多的、高可维护性、高扩展性的、高可靠性的代码。<br>这么多好代码评判标准里面，我认为可靠性是最不能妥协的。<br>时间可以商量，任务可以分工，维护性可以加班来搞，扩展性可以后期优化。唯有代码的可靠性，需要整个业务团队来承担它带来的影响。<br>郑大钱想挣更多钱<br>可以因为能写高质量的代码要到更高的工资<br>可以通过优化代码的可靠性来提升代码的质量<br>可以通过单元测试来提升代码的可靠性<br>单元测试覆盖率，是一个可以量化的指标，是一个可以集中资源优化的点，是一个挣大钱的好战略。<br>（好的战略 = 一个清晰的目标 + 可以集中资源优化的点 ——《好战略，坏战略》）","like_count":3,"discussions":[{"author":{"id":2061547,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/74/eb/791d0f5e.jpg","nickname":"拿了橘子跑哇","note":"","ucode":"D7A281AE06DDF3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":566465,"discussion_content":"朴实无华！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650697229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173362,"user_name":"相逢是缘","can_delete":false,"product_type":"c1","uid":1060730,"ip_address":"","ucode":"CB299F53A95654","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg","comment_is_top":false,"comment_ctime":1579511091,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14464412979","product_id":100039001,"comment_content":"打卡<br>1、什么是代码可测试性：<br>针对代码编写单元测试的难易程度。如果编写单元测试很难，意味着代码设计不够合理，代码的可测试性不好。<br><br>2、如何编写可测试性的代码<br>1、通过依赖注入，我们在编写单元测试的时候，可以通过 mock 的方法解依赖外部服务<br>2、依赖外部单例：将单例封装<br>3、未决行为：例时间、随机数。将未决行为重新封装，测试时mock。<br><br>3、常见的测试不友好的代码有下面这 5 种：<br>1、代码中包含未决行为逻辑<br>2、滥用可变全局变量<br>3、滥用静态方法<br>4、使用复杂的继承关系<br>5、高度耦合的代码","like_count":3},{"had_liked":false,"id":173241,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1579483991,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14464385879","product_id":100039001,"comment_content":"不依赖框架的类，都可以手动new，比如Person对象，可以内部new，而像Spring的Service、Repository、Controller这些依赖框架的，需要用到依赖注入","like_count":3},{"had_liked":false,"id":170342,"user_name":"达文西","can_delete":false,"product_type":"c1","uid":1398824,"ip_address":"","ucode":"01C1063F23D634","user_header":"https://static001.geekbang.org/account/avatar/00/15/58/28/c86340ca.jpg","comment_is_top":false,"comment_ctime":1578574692,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14463476580","product_id":100039001,"comment_content":"内容都是干货,不够看啊","like_count":3},{"had_liked":false,"id":169853,"user_name":"平风造雨","can_delete":false,"product_type":"c1","uid":1014349,"ip_address":"","ucode":"F9EE4704F31E22","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/4d/b0228a1a.jpg","comment_is_top":false,"comment_ctime":1578458702,"is_pvip":true,"discussion_count":3,"race_medal":0,"score":"14463360590","product_id":100039001,"comment_content":"&#47;&#47; 抽取了当前时间获取的逻辑，方便测试<br>    private long currentTimeMillis;<br>    private Date dueTime;<br>    public Demo(Date dueTime){<br>        this.dueTime = dueTime;<br>        this.currentTimeMillis = getCurrentTimeMillis();<br>    }<br><br>    protected long getCurrentTimeMillis(){<br>        return System.currentTimeMillis();<br>    }<br>    public long caculateDelayDays() {<br>        if(dueTime.getTime() &gt;= currentTimeMillis){<br>            return 0;<br>        }<br>        long delayTime = currentTimeMillis - dueTime.getTime();<br>        long delayDays = delayTime &#47; 86400_000;<br>        return delayDays;<br>    }<br>    @Test<br>    public void testCaculateDelayDays(){<br>        TimeZone timeZone = TimeZone.getTimeZone(&quot;Asia&#47;ShangHai&quot;);<br>        Calendar calendar = Calendar.getInstance(timeZone);<br>        calendar.clear();<br>        calendar.set(2020, Calendar.FEBRUARY,1,0,0,0);<br>        Date dueTime = calendar.getTime();<br>        Demo demo = new DemoClassOne(dueTime);<br>        Assert.assertEquals(demo.caculateDelayDays(), 0);<br>        calendar.clear();<br>        calendar.set(2019, Calendar.DECEMBER, 31, 0,0,0);<br>        dueTime = calendar.getTime();<br>        demo = new DemoClassOne(dueTime);<br>        Assert.assertEquals(demo.caculateDelayDays(), 1);<br>    }<br><br>    public static class DemoClassOne extends Demo {<br>        public DemoClassOne(Date dueTime) {<br>            super(dueTime);<br>        }<br>        @Override<br>        protected long getCurrentTimeMillis() {<br>            TimeZone timeZone = TimeZone.getTimeZone(&quot;Asia&#47;ShangHai&quot;);<br>            Calendar calendar = Calendar.getInstance(timeZone);<br>            calendar.clear();<br>            calendar.set(2020, Calendar.JANUARY,1,0,0,0);<br>            return calendar.getTimeInMillis();<br>        }<br>    }","like_count":3,"discussions":[{"author":{"id":1901146,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK28icgzo9R0rXE5s4nIjdme2VLRLbFtcaiaibaOEEFewnoIgco4sUXhibiabDvRbGN5NOZdcEBvFvytow/132","nickname":"phpCoder","note":"","ucode":"963C378BDBF49B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261991,"discussion_content":"我觉得这样是不是为了测试而设计了 感觉怪怪的🤨","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589030972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1714287,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/28/6f/e430eaaa.jpg","nickname":"平行线","note":"","ucode":"033F8BA2D1470E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1901146,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK28icgzo9R0rXE5s4nIjdme2VLRLbFtcaiaibaOEEFewnoIgco4sUXhibiabDvRbGN5NOZdcEBvFvytow/132","nickname":"phpCoder","note":"","ucode":"963C378BDBF49B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308635,"discussion_content":"我也感觉怪怪的，像是自己在骗自己一样，  争哥例子中的isExpired函数，为了单侧直接返回true, 总感觉哪里不对呢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601014608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":261991,"ip_address":""},"score":308635,"extra":""}]},{"author":{"id":1254656,"avatar":"https://static001.geekbang.org/account/avatar/00/13/25/00/3afbab43.jpg","nickname":"88591","note":"","ucode":"04CE3E46455185","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206682,"discussion_content":"我觉得可以简单点，用两入参（两个时间）就可以。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584426981,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":271493,"user_name":"Better me","can_delete":false,"product_type":"c1","uid":1261959,"ip_address":"","ucode":"CADF08D357489A","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","comment_is_top":false,"comment_ctime":1609665807,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10199600399","product_id":100039001,"comment_content":"思考题1，IdGenerator.generateTransactionId()是一个静态方法，根据老师文中所说的，如果只是类似 Math.abs() 这样的简单静态方法，并不会影响代码的可测试性，因为本身并不需要 mock。所以我们需要鉴别IdGenerator.generateTransactionId()本身是否有其他依赖，如果是依赖其他服务（数据库等）的全局发号器则有必要Mock<br><br>思考题2，依赖注入，就是不要在类内部通过 new 的方式创建对象，而是要通过外部创建好之后传递给类使用。根据面向接口而非实现的编程原则，当我们要做单元测试的类依赖了外部服务接口的具体实现时，可以由外部传入实现类并Mock相关函数返回值。而与具体行为无关的数据对象可通过new 的方式创建对象，即被测试类函数逻辑并不是强依赖外部类实现这种","like_count":2},{"had_liked":false,"id":183865,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1583149524,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10173084116","product_id":100039001,"comment_content":"思考题1不会有影响，因为这个id只是一个值而已，对逻辑判断，测试场景没有影响","like_count":2},{"had_liked":false,"id":183207,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1582972607,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10172907199","product_id":100039001,"comment_content":"回答一下提问2：<br>我认为对象生命周期都被类包含的时候，可以在类内部通过new构建，而且不影响测试。<br><br>譬如一个集合类，内置了一个List，这个List的活动范围仅限于这个集合类，任何方法都不会发布这个对象出去，那么这List的对象可以在集合初始化的时候通过new进行构造。","like_count":2},{"had_liked":false,"id":314234,"user_name":"慕言","can_delete":false,"product_type":"c1","uid":2731028,"ip_address":"","ucode":"4918FA682F3895","user_header":"https://static001.geekbang.org/account/avatar/00/29/ac/14/a8ff8fec.jpg","comment_is_top":false,"comment_ctime":1632907972,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5927875268","product_id":100039001,"comment_content":"我针对案例中4、5、6三个测试用例编写的测试代码：<br>public class TransactionTest {<br>    @Test<br>    public void testExecute_with_TransactionExecuted() throws InvalidTransactionException {<br>        Transaction t = new Transaction(null, 123L, 234L, 345L, &quot;567&quot;, (double)89) {<br>            @Override<br>            protected boolean isExecuted() {<br>                return true;<br>            }<br>        };<br>        WalletRpcService wallet = new WalletRpcService();<br>        t.setWalletRpcService(wallet);<br>        TransactionLock lock = new TransactionLock();<br>        t.setTransactionLock(lock);<br>        boolean result = t.execute();<br>        Assert.assertTrue(result);<br>    }<br><br>    @Test<br>    public void testExecute_with_TransactionMoveFailed() throws InvalidTransactionException {<br>        Transaction t = new Transaction(null, 123L, 234L, 345L, &quot;567&quot;, (double)89);<br>        WalletRpcService wallet = new WalletRpcService() {<br>            @Override<br>            public String moveMoney(String id, Long buyerId, Long sellerId, Double amount) {<br>                return null;<br>            }<br>        };<br>        t.setWalletRpcService(wallet);<br>        TransactionLock lock = new TransactionLock();<br>        t.setTransactionLock(lock);<br>        boolean result = t.execute();<br>        Assert.assertFalse(result);<br>        Assert.assertEquals(Status.FAILED, t.getStatus());<br>    }<br><br>    @Test<br>    public void testExecute_with_TransactionExecuting() throws InvalidTransactionException {<br>        Transaction t = new Transaction(null, 123L, 234L, 345L, &quot;567&quot;, (double)89);<br>        WalletRpcService wallet = new WalletRpcService();<br>        t.setWalletRpcService(wallet);<br>        TransactionLock lock = new TransactionLock() {<br>            @Override<br>            public boolean lock(String id) {<br>                return false;<br>            }<br>        };<br>        t.setTransactionLock(lock);<br>        boolean result = t.execute();<br>        Assert.assertFalse(result);<br>    }<br>}","like_count":1},{"had_liked":false,"id":270641,"user_name":"JRich","can_delete":false,"product_type":"c1","uid":1114901,"ip_address":"","ucode":"66AE9D61533960","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/15/293a185d.jpg","comment_is_top":false,"comment_ctime":1609203500,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5904170796","product_id":100039001,"comment_content":"如果依赖注入是用spring的autowire注解，没有setter方法，该怎么去用mock对象替换呢","like_count":1,"discussions":[{"author":{"id":1095136,"avatar":"https://static001.geekbang.org/account/avatar/00/10/b5/e0/fc3ac264.jpg","nickname":"stronger.","note":"","ucode":"AD0F2BE338824C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408808,"discussion_content":"spring建议通过构造器注入，而不是属性注入","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1635326562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2588697,"avatar":"https://static001.geekbang.org/account/avatar/00/27/80/19/ac06db0b.jpg","nickname":"New","note":"","ucode":"406DF65BD05FAA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372893,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620490470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184421,"user_name":"xk_","can_delete":false,"product_type":"c1","uid":1514305,"ip_address":"","ucode":"DFE1AC38EA78A7","user_header":"https://static001.geekbang.org/account/avatar/00/17/1b/41/dbb7d785.jpg","comment_is_top":false,"comment_ctime":1583311840,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5878279136","product_id":100039001,"comment_content":"我有用过mock框架，也写过很多复杂的单元测试。现在测试框架好强大，各种mock，静态方法，代码中注入自定义对象…<br>说一下我对思考题的看法：<br>1.生成id不用覆盖，因为没有测试的点。如果硬要测试的话要单独测试这个方法，不过要写生成这个方法的单元测试可能会非常复杂。越简单的，基础的方法越难测。<br>2.如果没有争哥说的那五种情况，其实在哪里创建对象都好测试，最难测的五种情况都在文章中了。","like_count":1},{"had_liked":false,"id":173126,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1579428727,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5874396023","product_id":100039001,"comment_content":"IdGenerator.generateTransactionId()本身就是产生随机数的，对测试流程不影响","like_count":1},{"had_liked":false,"id":171373,"user_name":"Walker Jiang","can_delete":false,"product_type":"c1","uid":1023818,"ip_address":"","ucode":"92AE855D428917","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9f/4a/f5b8c6b3.jpg","comment_is_top":false,"comment_ctime":1578911540,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5873878836","product_id":100039001,"comment_content":"收获很多，要是文章结尾有个完整代码就更好了，不然现在还得一点点去复制才能看到全貌。","like_count":1},{"had_liked":false,"id":170841,"user_name":"饭粒","can_delete":false,"product_type":"c1","uid":1153455,"ip_address":"","ucode":"4C3220B0D43997","user_header":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","comment_is_top":false,"comment_ctime":1578737956,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5873705252","product_id":100039001,"comment_content":"读完这篇感觉一下就认识了代码的可测试性。依赖注入提高代码的可测试性，那 spring 里推荐使用 setter 方法形式的 @autowired 注入 bean 更好哎。<br>然后我认为 IdGenerator.generateTransactionId() 不需要 mock，它的功能应该就是生成一个全局唯一的 id，对 Transaction   而言功能简单，不影响测试性，本身的实现逻辑不在 Transaction  测试。","like_count":1},{"had_liked":false,"id":170533,"user_name":"石仔","can_delete":false,"product_type":"c1","uid":1177921,"ip_address":"","ucode":"974E4604CE2213","user_header":"https://static001.geekbang.org/account/avatar/00/11/f9/41/411b1753.jpg","comment_is_top":false,"comment_ctime":1578627542,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5873594838","product_id":100039001,"comment_content":"继续优化Demo:<br>public class Demo {<br>    private long currentTimestamp;<br>    private long dueTimestamp;<br>    private long delayDays;<br><br>    public Demo(long currentTimestamp, long dueTimestamp) {<br>        this.currentTimestamp = currentTimestamp;<br>        this.dueTimestamp = dueTimestamp;<br>        this.delayDays = (this.currentTimestamp - this.dueTimestamp) &#47; 86400;<br>    }<br><br>    &#47;**<br>     * 计算延迟天数<br>     *<br>     * @return<br>     *&#47;<br>    public long caculateDelayDays() {<br>        if (!isDelayDays()) {<br>            return 0;<br>        }<br>        return delayDays;<br>    }<br><br>    &#47;**<br>     * 是否延迟<br>     *<br>     * @return<br>     *&#47;<br>    public boolean isDelayDays() {<br>        if (this.delayDays &lt;= 0) {<br>            return false;<br>        }<br>        return true;<br>    }<br>}","like_count":1},{"had_liked":false,"id":169988,"user_name":"再见孙悟空","can_delete":false,"product_type":"c1","uid":1025518,"ip_address":"","ucode":"57E12A2F9CD915","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a5/ee/6bbac848.jpg","comment_is_top":false,"comment_ctime":1578489306,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5873456602","product_id":100039001,"comment_content":"今天老师讲的为了更好的单元测试而进行的重构，原来工作中无形间已经用到了。在对接三方 api 时，有时候缺少必要的参数信息，我们只能模拟调通，这时候我们就写一个类继承原始类，重写原方法，返回自己需要的数据，不过还有很多做的不足，例如对于不确定数据的mock 没有抽成方法等，持续学习，老师棒！","like_count":1},{"had_liked":false,"id":169793,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1578447537,"is_pvip":false,"replies":[{"id":"65943","content":"”代码结构扁平化的极端结果“能举个例子吗？","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1578489044,"ip_address":"","comment_id":169793,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5873414833","product_id":100039001,"comment_content":"想到一个问题，代码结构扁平化的极端结果可能会造成依赖对象过多吗？这种情况mock不是依然难搞吗","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480722,"discussion_content":"”代码结构扁平化的极端结果“能举个例子吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578489044,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1444122,"avatar":"https://static001.geekbang.org/account/avatar/00/16/09/1a/e0f95684.jpg","nickname":"空空","note":"","ucode":"8F6EFE5A6F6F64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":173281,"discussion_content":"如果极端扁平，我的理解会出现fan-out 问题，所以组合和继承的使用还是要视场景而定","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581843917,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":337585,"user_name":"千锤百炼领悟之极限","can_delete":false,"product_type":"c1","uid":1744257,"ip_address":"","ucode":"224B5CF2101716","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9d/81/d748b7eb.jpg","comment_is_top":false,"comment_ctime":1646904126,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646904126","product_id":100039001,"comment_content":"重构之后的fillTransactionId函数，返回id不是更好吗，而不是在函数内部赋值给this.id<br><br>例如:<br>  public Transaction(String preAssignedId, Long buyerId, Long sellerId, Long productId, String orderId) {<br>    &#47;&#47;...<br>    this.id = fillTransactionId(preAssignId);<br>    &#47;&#47;...<br>  }<br>  <br>  protected void fillTransactionId(String preAssignedId) {<br>    if (preAssignedId != null &amp;&amp; !preAssignedId.isEmpty()) {<br>      id = preAssignedId;<br>    } else {<br>      id = IdGenerator.generateTransactionId();<br>    }<br>    if (!id.startWith(&quot;t_&quot;)) {<br>      id = &quot;t_&quot; + preAssignedId;<br>    }<br>    return id;<br>  }","like_count":0},{"had_liked":false,"id":330936,"user_name":"你好旅行者","can_delete":false,"product_type":"c1","uid":1154101,"ip_address":"","ucode":"5C72A428DC28F3","user_header":"https://static001.geekbang.org/account/avatar/00/11/9c/35/9dc79371.jpg","comment_is_top":false,"comment_ctime":1642312961,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642312961","product_id":100039001,"comment_content":"关于第二个问题，谜底就在谜面上，不影响代码可测试性的类就可以在类的内部创建。","like_count":0},{"had_liked":false,"id":324222,"user_name":"友","can_delete":false,"product_type":"c1","uid":2536820,"ip_address":"","ucode":"972A4333A8B101","user_header":"https://static001.geekbang.org/account/avatar/00/26/b5/74/cd80b9f4.jpg","comment_is_top":false,"comment_ctime":1638343339,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638343339","product_id":100039001,"comment_content":"关于测试 status的代码 可以想 time一样处理。测试交易中的代码 由于我用的是go  我会开一个协程去模拟","like_count":0},{"had_liked":false,"id":315307,"user_name":"charmsongo","can_delete":false,"product_type":"c1","uid":1609051,"ip_address":"","ucode":"4FBEE716E93A1A","user_header":"https://static001.geekbang.org/account/avatar/00/18/8d/5b/383a49e4.jpg","comment_is_top":false,"comment_ctime":1633824470,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633824470","product_id":100039001,"comment_content":"外部依赖注入可以提高代码的可测试性，尽量少用未决代码、全局变量、静态变量、复杂的集成、耦合度高的代码","like_count":0},{"had_liked":false,"id":303078,"user_name":"布拉姆","can_delete":false,"product_type":"c1","uid":1311125,"ip_address":"","ucode":"479FF27D73BCAD","user_header":"https://static001.geekbang.org/account/avatar/00/14/01/95/fd09e8a8.jpg","comment_is_top":false,"comment_ctime":1626579764,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626579764","product_id":100039001,"comment_content":"不依赖外部服务的类就可以内部创建，比如 String","like_count":1},{"had_liked":false,"id":297549,"user_name":"江南一笑","can_delete":false,"product_type":"c1","uid":2234620,"ip_address":"","ucode":"E38938A1178827","user_header":"https://static001.geekbang.org/account/avatar/00/22/18/fc/4f92ee4e.jpg","comment_is_top":false,"comment_ctime":1623619037,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623619037","product_id":100039001,"comment_content":"一个疑问：修改前，Transaction的调用者不需要知道 WalletRpcService， 就可以直接调用Transaction，更符合 least knowledge 原则。现在为了提高可测试性，调用者需要先创建 WalletRpcService 对象，再通过依赖注入的方式调用 Transaction对象。这样对 Transaction的调用者是否友好？","like_count":0},{"had_liked":false,"id":296919,"user_name":"编号","can_delete":false,"product_type":"c1","uid":1037836,"ip_address":"","ucode":"1633A363592A1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d6/0c/df0d5152.jpg","comment_is_top":false,"comment_ctime":1623224706,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623224706","product_id":100039001,"comment_content":"争哥，private static AtomicInteger position = new AtomicInteger(0)这种静态全局变量要怎么测试呢，或者代码要怎么重构啊","like_count":0},{"had_liked":false,"id":296539,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1623034440,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1623034440","product_id":100039001,"comment_content":"干货","like_count":0},{"had_liked":false,"id":292451,"user_name":"JKwar","can_delete":false,"product_type":"c1","uid":1047466,"ip_address":"","ucode":"B733CA24D5701F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/aa/01fedf6c.jpg","comment_is_top":false,"comment_ctime":1620827157,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1620827157","product_id":100039001,"comment_content":"思考题1：不会。void fillTransactionId(String preAssignedId) 函数本身就是一个id生成器，如果传入的id为空，就通过 IdGenerator.generateTransactionId() 生成一个id。<br>思考题2：不依赖外部服务的类，提供方法的类可以 new，比如说 Service 类就可以在内部创建并且不影响代码的可测试性","like_count":0},{"had_liked":false,"id":289060,"user_name":"偏执","can_delete":false,"product_type":"c1","uid":1304576,"ip_address":"","ucode":"B397172D654C92","user_header":"https://static001.geekbang.org/account/avatar/00/13/e8/00/f94bb1c5.jpg","comment_is_top":false,"comment_ctime":1618836600,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618836600","product_id":100039001,"comment_content":"有一个疑惑，静态方法mock难在哪里？ <br>1. Java里PowerMock提供了静态方法的mock方式。<br>2. Python里可以使用mock.patch(&#39;your.package.module.Classs.func&#39;)的方式mock<br>可以提供一个实例说明static方法的难处在哪里吗？<br>","like_count":0},{"had_liked":false,"id":288501,"user_name":"JoeyforJoy","can_delete":false,"product_type":"c1","uid":1466467,"ip_address":"","ucode":"5598501E71D35D","user_header":"https://static001.geekbang.org/account/avatar/00/16/60/63/d2c91e2b.jpg","comment_is_top":false,"comment_ctime":1618493728,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618493728","product_id":100039001,"comment_content":"依赖注入是提高代码可测试性的有效手段。具体例子可以参考mock的实现","like_count":0},{"had_liked":false,"id":287236,"user_name":"Spoon","can_delete":false,"product_type":"c1","uid":1959822,"ip_address":"","ucode":"2FF9193AD482C2","user_header":"https://static001.geekbang.org/account/avatar/00/1d/e7/8e/318cfde0.jpg","comment_is_top":false,"comment_ctime":1617850812,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617850812","product_id":100039001,"comment_content":"真的是收获满满","like_count":0},{"had_liked":false,"id":285872,"user_name":"Geek_86eac6","can_delete":false,"product_type":"c1","uid":1787022,"ip_address":"","ucode":"8C02E398CC6A35","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI4CBQHuLDWOdicOl1elTdSicqMyY1s5JDWXiaHsSk0VSWaVe0U6CTo701ZGz9h6MvibsAGKnvVq7xxFw/132","comment_is_top":false,"comment_ctime":1617061941,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617061941","product_id":100039001,"comment_content":"题目1，这段代码不影响整体逻辑，所以不需要mock","like_count":0},{"had_liked":false,"id":270989,"user_name":"隆隆.ago","can_delete":false,"product_type":"c1","uid":1710528,"ip_address":"","ucode":"9EFE43F0A2C6BB","user_header":"https://static001.geekbang.org/account/avatar/00/1a/19/c0/693b946f.jpg","comment_is_top":false,"comment_ctime":1609340050,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609340050","product_id":100039001,"comment_content":"1. ID生成器本身很简单，不需要mock。测试fillTransactionId功能已经很简单了，造一个id传进去或者一个空id传进去测试，不需要再mock生成ID。<br>2. 很确定而简单的，不依赖外部的服务可以new。提供特定属性的model这些可以new。比如封装各种ID的一个贫血数据类","like_count":0},{"had_liked":false,"id":266227,"user_name":"突围","can_delete":false,"product_type":"c1","uid":1090414,"ip_address":"","ucode":"03E865CC8A6F2A","user_header":"https://static001.geekbang.org/account/avatar/00/10/a3/6e/52580973.jpg","comment_is_top":false,"comment_ctime":1607246333,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607246333","product_id":100039001,"comment_content":"单元测试太难推了，我们公司项目单测覆盖率能到达30%就不错了","like_count":0},{"had_liked":false,"id":265912,"user_name":"狼行天下","can_delete":false,"product_type":"c1","uid":1053161,"ip_address":"","ucode":"A3F22B276B88B1","user_header":"https://static001.geekbang.org/account/avatar/00/10/11/e9/13f28df2.jpg","comment_is_top":false,"comment_ctime":1607067239,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607067239","product_id":100039001,"comment_content":"思考题1：看该方法是否有依赖其它组件，如果是本机生成算法，可以不用mock；<br>思考题2：model对象可以不用外部传入；","like_count":0},{"had_liked":false,"id":254938,"user_name":"erDuo","can_delete":false,"product_type":"c1","uid":1016135,"ip_address":"","ucode":"691E716E6D0E39","user_header":"https://static001.geekbang.org/account/avatar/00/0f/81/47/e5b206d9.jpg","comment_is_top":false,"comment_ctime":1603237897,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603237897","product_id":100039001,"comment_content":"大赞，马上回去重构","like_count":0},{"had_liked":false,"id":250607,"user_name":"一尾","can_delete":false,"product_type":"c1","uid":1517556,"ip_address":"","ucode":"67D404036231D1","user_header":"https://static001.geekbang.org/account/avatar/00/17/27/f4/a1ce6248.jpg","comment_is_top":false,"comment_ctime":1601169921,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601169921","product_id":100039001,"comment_content":"感谢，这节课都是干货","like_count":0},{"had_liked":false,"id":250013,"user_name":"David","can_delete":false,"product_type":"c1","uid":1021825,"ip_address":"","ucode":"22CBBC13FC97A9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/97/81/e1eaf621.jpg","comment_is_top":false,"comment_ctime":1600905491,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1600905491","product_id":100039001,"comment_content":"1. id生成逻辑简单 我认为不用mock<br>2. 注入优于new","like_count":0},{"had_liked":false,"id":249688,"user_name":"Younger Ku","can_delete":false,"product_type":"c1","uid":1323102,"ip_address":"","ucode":"D157DC38BDB515","user_header":"https://static001.geekbang.org/account/avatar/00/14/30/5e/c42bc33f.jpg","comment_is_top":false,"comment_ctime":1600762086,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600762086","product_id":100039001,"comment_content":"1、IdGenerator.generateTransactionId()只是一个生成交易ID的静态方法，如果需要依赖外部系统或者不可控组件就需要单独mock。如果仅仅是生成一个随机字符串则不需要mock。当然，如果交易ID有预设的生成规则，可能也需要单独对生成规则进行测试。<br>2、如果要用到的类中的方法不会产生未决行为、并且没有依赖外部系统及不可控组件，对单元测试没有影响，那么就可以直接new出来。","like_count":0},{"had_liked":false,"id":247316,"user_name":"JerryZhu","can_delete":false,"product_type":"c1","uid":1591223,"ip_address":"","ucode":"76850CD45786C1","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","comment_is_top":false,"comment_ctime":1599657634,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599657634","product_id":100039001,"comment_content":"真是写了6年的代码。。 很少写单元测试， 惭愧至极了","like_count":1},{"had_liked":false,"id":246758,"user_name":"宇天飞","can_delete":false,"product_type":"c1","uid":1126444,"ip_address":"","ucode":"3FB37D1E2DAA61","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/2c/06375913.jpg","comment_is_top":false,"comment_ctime":1599470858,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1599470858","product_id":100039001,"comment_content":"问题1：<br>1、不会影响。函数比较简单，很快返回，不会有太多依赖<br>问题2：<br>1、非业务逻辑上的对象可以新建，不影响业务逻辑走向的","like_count":0},{"had_liked":false,"id":245616,"user_name":"大雁小鱼","can_delete":false,"product_type":"c1","uid":1101017,"ip_address":"","ucode":"44090581E59FDA","user_header":"https://static001.geekbang.org/account/avatar/00/10/cc/d9/20d4f7c2.jpg","comment_is_top":false,"comment_ctime":1599009514,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599009514","product_id":100039001,"comment_content":"我：这段代码不太好写单元测试不好，需要重写。<br>别人：你有病吧，是你自己能力不行，不会写单元测试吧。<br>我：……","like_count":0},{"had_liked":false,"id":244580,"user_name":"蛀牙","can_delete":false,"product_type":"c1","uid":1153349,"ip_address":"","ucode":"F765A67DFEADFD","user_header":"","comment_is_top":false,"comment_ctime":1598585428,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598585428","product_id":100039001,"comment_content":"思考题1： 我觉得需要重写，因为在unit test里也需要验证id是否被正确的fill了，一个deterministic的id generator 会方便test验证","like_count":0},{"had_liked":false,"id":244192,"user_name":"Mew151","can_delete":false,"product_type":"c1","uid":1002201,"ip_address":"","ucode":"D4793F5874F345","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/d9/75dd7cf9.jpg","comment_is_top":false,"comment_ctime":1598423602,"is_pvip":false,"replies":[{"id":"90138","content":"你指的处理什么呢？","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1598834236,"ip_address":"","comment_id":244192,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1598423602","product_id":100039001,"comment_content":"有一个问题，如果测试方法A()中调用了本类的私有方法B()，这个时候该怎么处理呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504514,"discussion_content":"你指的处理什么呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598834236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":233946,"user_name":"可爱的饲养员","can_delete":false,"product_type":"c1","uid":1160213,"ip_address":"","ucode":"A5B6A4A4110E0C","user_header":"https://static001.geekbang.org/account/avatar/00/11/b4/15/2e6716d7.jpg","comment_is_top":false,"comment_ctime":1594526872,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594526872","product_id":100039001,"comment_content":"思考题1：看IdGenerator.generateTransactionId()的生成逻辑，分布式系统避免ID重复都会查库，如果这样的话就要mock。<br>思考题2：实现业务逻辑的要注入，做数据载体的POJO要new","like_count":0},{"had_liked":false,"id":232356,"user_name":"大方方","can_delete":false,"product_type":"c1","uid":1354013,"ip_address":"","ucode":"621AD8F1485753","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/6cyOoRd2dROgiblAJkW6RLhUyH1wwU0NNibIIuV930eQ9TiaNT41K61kBSVkvYoDYg7mJtuEoCQY1awBmV0WW6BFg/132","comment_is_top":false,"comment_ctime":1593964894,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593964894","product_id":100039001,"comment_content":"这节是真干货， 完整的把前面讲过的设计模式和单元测试理论在实践中正向激励循环展示出来了，而且确实学到了实用技巧，能够应用到自己的代码重构中，很实用，谢谢。","like_count":0},{"had_liked":false,"id":230650,"user_name":"克尔苏加德","can_delete":false,"product_type":"c1","uid":1459388,"ip_address":"","ucode":"E35A6DFA012F37","user_header":"https://static001.geekbang.org/account/avatar/00/16/44/bc/0bb265a7.jpg","comment_is_top":false,"comment_ctime":1593440276,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593440276","product_id":100039001,"comment_content":"受益良多","like_count":0},{"had_liked":false,"id":230599,"user_name":"YsnowLove","can_delete":false,"product_type":"c1","uid":1439301,"ip_address":"","ucode":"70433D98592481","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/rMgAbbKiasa1qR35ht0GEfwsHXbusPZAe9JFgicDgVRy8vQET2hypuDgwtHoPVU23RUoMdK7qA7gibMlTExpYibtbw/132","comment_is_top":false,"comment_ctime":1593426261,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593426261","product_id":100039001,"comment_content":"总感觉execute方法并发的时候出现多转钱的问题，分布式锁，锁住的是transactionId，而transactionId有可能是在execute方法生成的。","like_count":0},{"had_liked":false,"id":226077,"user_name":"benxiong","can_delete":false,"product_type":"c1","uid":1624574,"ip_address":"","ucode":"F6498059D439D9","user_header":"https://static001.geekbang.org/account/avatar/00/18/c9/fe/874b172b.jpg","comment_is_top":false,"comment_ctime":1591947212,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591947212","product_id":100039001,"comment_content":"public class Demo { <br>    public long caculateDelayDays(Date dueTime) { <br>        long currentTimestamp = System.currentTimeMillis(); <br>        long delayTime = currentTimestamp - dueTime.getTime();<br>        if ( isDelayed(delayTime) ) {<br>            return delayTime &#47; 86400;<br>        } else {<br>            return 0;<br>        }<br>    }<br>    <br>    public boolean isDelayed(long delayTime) {<br>         return delayTime &gt; 0 ? true : false;<br>    }<br>}","like_count":0},{"had_liked":false,"id":225309,"user_name":"花花大脸猫","can_delete":false,"product_type":"c1","uid":1117318,"ip_address":"","ucode":"8ABDB3F7F4FB0F","user_header":"https://static001.geekbang.org/account/avatar/00/11/0c/86/8e52afb8.jpg","comment_is_top":false,"comment_ctime":1591711704,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1591711704","product_id":100039001,"comment_content":"1.我认为不需要，其实就是生成个ID，业务不相关的<br>2.贫血型的自定义java pojo对象 ","like_count":0},{"had_liked":false,"id":223901,"user_name":"远方","can_delete":false,"product_type":"c1","uid":1064732,"ip_address":"","ucode":"244C74F9857196","user_header":"https://static001.geekbang.org/account/avatar/00/10/3f/1c/1e4dfbc9.jpg","comment_is_top":false,"comment_ctime":1591228687,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591228687","product_id":100039001,"comment_content":"慢慢干货，这个专栏实在是太值了","like_count":0},{"had_liked":false,"id":221424,"user_name":"技术骨干","can_delete":false,"product_type":"c1","uid":1098720,"ip_address":"","ucode":"8FCF8DE6D29201","user_header":"https://static001.geekbang.org/account/avatar/00/10/c3/e0/3db22579.jpg","comment_is_top":false,"comment_ctime":1590497209,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590497209","product_id":100039001,"comment_content":"干活满满，学不动了😭😭😭😭","like_count":0},{"had_liked":false,"id":220987,"user_name":"buggetout","can_delete":false,"product_type":"c1","uid":1880582,"ip_address":"","ucode":"63A948EF415FDD","user_header":"https://static001.geekbang.org/account/avatar/00/1c/b2/06/2086d76d.jpg","comment_is_top":false,"comment_ctime":1590373081,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590373081","product_id":100039001,"comment_content":"这个Transaction类是贫血模型吗？依赖了外部的service","like_count":0},{"had_liked":false,"id":220090,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1590152646,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590152646","product_id":100039001,"comment_content":"不在类内部实例化外部依赖，而是在类外部创建好对象传入构造函数或函数。<br>golang中数据和方法不允许分离，通过接口参数传入的实例化对象只能使用其方法不能直接使用对象的实体数据。<br>Java的spring用的是数据和方法分离，强依赖数据，方法依赖接口实现可扩展。","like_count":0},{"had_liked":false,"id":215256,"user_name":"刘同青","can_delete":false,"product_type":"c1","uid":1818343,"ip_address":"","ucode":"84B62DF8BC61FB","user_header":"","comment_is_top":false,"comment_ctime":1588942576,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1588942576","product_id":100039001,"comment_content":"答题<br><br>1.不需要。大家似乎都遗漏了一个关键点，单元测试只关注接口或者方法的定义，不要关注实现逻辑。void fillTransactionId(String preAssignedId) 的定义是填充一个id，如果pre不为空则填充pre，否则主动生成一个id来填充。所以对于它的测试，并不关注如何主动生成，而是关注能不能生成。至于生成的对不对，那是这个生成器的单元测试应该关注的。<br><br><br>2.和第一题一样，和接口功能定义无关的对象可以new，有关的那就可能是测试点了","like_count":0,"discussions":[{"author":{"id":1818343,"avatar":"","nickname":"刘同青","note":"","ucode":"84B62DF8BC61FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261148,"discussion_content":"补充一下:\n\n1.如果id生成依赖第三方组件，比如数据库或者rpc，那需要mock，否则运行不了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588942879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":210869,"user_name":"qpzm7903","can_delete":false,"product_type":"c1","uid":1138683,"ip_address":"","ucode":"C7C14962D34BE7","user_header":"https://static001.geekbang.org/account/avatar/00/11/5f/fb/af061ca7.jpg","comment_is_top":false,"comment_ctime":1587858200,"is_pvip":false,"replies":[{"id":"78763","content":"单元测试跟贫不贫血没关系吧","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1588042521,"ip_address":"","comment_id":210869,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1587858200","product_id":100039001,"comment_content":"请问贫血模式的mvc中的service怎么进行单元测试呢","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493135,"discussion_content":"单元测试跟贫不贫血没关系吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588042521,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208525,"user_name":"进击的前端er","can_delete":false,"product_type":"c1","uid":1506085,"ip_address":"","ucode":"9229B410F48B85","user_header":"https://static001.geekbang.org/account/avatar/00/16/fb/25/f6743e97.jpg","comment_is_top":false,"comment_ctime":1587375347,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587375347","product_id":100039001,"comment_content":"这节是真的看的爽啊！！","like_count":0},{"had_liked":false,"id":208390,"user_name":"三年过后","can_delete":false,"product_type":"c1","uid":1283157,"ip_address":"","ucode":"5E9106C5F11BED","user_header":"https://static001.geekbang.org/account/avatar/00/13/94/55/afc64956.jpg","comment_is_top":false,"comment_ctime":1587348848,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587348848","product_id":100039001,"comment_content":"思考题：<br>1、ID 发号器确保唯一即可。可以不用测试<br>2、充血模型的DDD不需要依赖注入","like_count":0},{"had_liked":false,"id":207616,"user_name":"lanco","can_delete":false,"product_type":"c1","uid":1188352,"ip_address":"","ucode":"C24A0A8716C78C","user_header":"https://static001.geekbang.org/account/avatar/00/12/22/00/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1587119727,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587119727","product_id":100039001,"comment_content":"如果你觉得这段代码的单元测试非常难写，那你需要考虑一下你的代码了","like_count":0},{"had_liked":false,"id":205984,"user_name":"改名不换人","can_delete":false,"product_type":"c1","uid":1118242,"ip_address":"","ucode":"7E25577829FA0F","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/22/910f705c.jpg","comment_is_top":false,"comment_ctime":1586767919,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586767919","product_id":100039001,"comment_content":"MVC三层结构，依赖数据库的那一层也可以使用Mock的方式来进行测试了，反而之前用过一种通过junit配置文件获取依赖关系来写单元测试的方式并不好，和数据库以及其他的组件耦合。有接口的依赖就实现接口，没有接口的依赖类就继承。<br>干货满满，学到了好多东西。","like_count":0},{"had_liked":false,"id":205226,"user_name":"肖臧","can_delete":false,"product_type":"c1","uid":1047733,"ip_address":"","ucode":"4FAC9FF54DD6A0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fc/b5/ac717737.jpg","comment_is_top":false,"comment_ctime":1586573554,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1586573554","product_id":100039001,"comment_content":"看到很多朋友把System.currentTimeMillis()封装在一个方法里，然后在测试方法里override这个方法，输出自己想要的值。我认为这种方法并不可取，caculateDelayDays方法对currentTimestamp是强依赖，整个方法的正确性，依赖于是否能获取currentTimestamp，所以我认为应该从入参上下手，先获取当前系统时间，然后按照测试需求，加减一定的变量得到dueTime","like_count":0,"discussions":[{"author":{"id":1047733,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fc/b5/ac717737.jpg","nickname":"肖臧","note":"","ucode":"4FAC9FF54DD6A0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295202,"discussion_content":"当然Override可以，我想表达的是怎么样做更好而已，条条大路通罗马，按你喜欢的方式来，实践会教育你我。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596117602,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1515149,"avatar":"https://static001.geekbang.org/account/avatar/00/17/1e/8d/5b242931.jpg","nickname":"Fish","note":"","ucode":"C20719F8B0F7C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295009,"discussion_content":"不太同意。感觉override 获取系统时间更好。因为获取系统时间本身很简单，测试目的是测试计算delay这个逻辑。\noverride获取系统时间时，可以在dueTime基础上加减，这样结果是确定的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596069559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203148,"user_name":"岁月","can_delete":false,"product_type":"c1","uid":1337598,"ip_address":"","ucode":"29A2A2BC3C4FE4","user_header":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","comment_is_top":false,"comment_ctime":1586144640,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1586144640","product_id":100039001,"comment_content":"只有我一个人看不懂这是什么意思嘛？<br><br>public void testExecute_with_TransactionIsExpired() {<br>  Long buyerId = 123L;<br>  Long sellerId = 234L;<br>  Long productId = 345L;<br>  Long orderId = 456L;<br>  Transction transaction = new Transaction(null, buyerId, sellerId, productId, orderId) {<br>    protected boolean isExpired() {<br>      return true;<br>    }<br>  };<br>  boolean actualResult = transaction.execute();<br>  assertFalse(actualResult);<br>  assertEquals(STATUS.EXPIRED, transaction.getStatus());<br>}<br><br>创建一个对象之后能直接重写某个方法？？？？？不需要创建一个新的类吗？我看很多编程语言都没这种功能吧。。。。","like_count":0,"discussions":[{"author":{"id":1735740,"avatar":"","nickname":"Geek_bb8d16","note":"","ucode":"964BD4DB3D9653","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":225632,"discussion_content":"这个是匿名类，比较特殊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586387749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":202603,"user_name":"墨鱼","can_delete":false,"product_type":"c1","uid":1022720,"ip_address":"","ucode":"8FB5E4DCB8A024","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/00/654be3f7.jpg","comment_is_top":false,"comment_ctime":1586014162,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586014162","product_id":100039001,"comment_content":"代码的可测试性：针对代码编写测试的难以程度。<br><br>编写可测试代码的方式：依赖注入 <br><br>测试不友好的代码：<br>1.代码中包含未决行为逻辑<br>2.滥用可变全局变量<br>3.滥用静态方法<br>4.复杂的继承关系<br>5.高度耦合的代码","like_count":0},{"had_liked":false,"id":200367,"user_name":"Geek_06c34d","can_delete":false,"product_type":"c1","uid":1593258,"ip_address":"","ucode":"C7910FAECFFE2F","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erf1o3QrluWme4LxFCickxtOTkGVQHMBOXo647FvEqwibBa9LfvX8F3EuvibFgE5XXFtpiaGicX73gMHcw/132","comment_is_top":false,"comment_ctime":1585577331,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585577331","product_id":100039001,"comment_content":"非常有启发性的思考","like_count":0},{"had_liked":false,"id":198179,"user_name":"Wizard","can_delete":false,"product_type":"c1","uid":1916084,"ip_address":"","ucode":"EEC2AC00BBED06","user_header":"https://static001.geekbang.org/account/avatar/00/1d/3c/b4/60e20977.jpg","comment_is_top":false,"comment_ctime":1585412753,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585412753","product_id":100039001,"comment_content":"在編寫單元測試的過程中，本身就是一個重構的過程。無法簡單被單元測試的類，也一定是一個不滿足ＳＯＬＩＤ，高內聚，低耦合的類。","like_count":0},{"had_liked":false,"id":196852,"user_name":"秋风画扇","can_delete":false,"product_type":"c1","uid":1132356,"ip_address":"","ucode":"5BCBC1422C51EC","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/44/964aa665.jpg","comment_is_top":false,"comment_ctime":1585318463,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585318463","product_id":100039001,"comment_content":"学到了，干活满满~以前想自己编写测试用例，最后因为难测试放弃了，看了今天的课程豁然开朗","like_count":0},{"had_liked":false,"id":189833,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1584574523,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584574523","product_id":100039001,"comment_content":"实战的例子太精彩了","like_count":1},{"had_liked":false,"id":186678,"user_name":"自古橘猫出胖子","can_delete":false,"product_type":"c1","uid":1344134,"ip_address":"","ucode":"C76F80D8C008B4","user_header":"https://static001.geekbang.org/account/avatar/00/14/82/86/712c1067.jpg","comment_is_top":false,"comment_ctime":1583900336,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583900336","product_id":100039001,"comment_content":"1.如果id没有业务逻辑，且生成id耗时不长。可以不mock。如果id生成依赖了外部服务或数据库，则需要mock<br>2.什么样的对象不能new，什么样的能new。边界外的对象需要注入，方便测试。边界内的是否就可以new？如果带有行为的对象都做成单例service注入，那ddd和充血模型应该如何设计呢？希望接下来的学习可以解决我的困惑。","like_count":0,"discussions":[{"author":{"id":1042354,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e7/b2/334bc992.jpg","nickname":"AlfredLover","note":"","ucode":"A3A998F362CC37","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219588,"discussion_content":"这家公司现在跑路了吗","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1585787058,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1862936,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/6d/18/e05f72ee.jpg","nickname":"冰原的苍蓝星","note":"","ucode":"84120EC31A63AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":254068,"discussion_content":"看完作者前两篇，我连你说的dp是啥都没知道","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1588293542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1023885,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9f/8d/d725d32c.jpg","nickname":"李德政","note":"","ucode":"3AC49F5671485C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1862936,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/6d/18/e05f72ee.jpg","nickname":"冰原的苍蓝星","note":"","ucode":"84120EC31A63AF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":267523,"discussion_content":"Design pattern？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1589643060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":254068,"ip_address":""},"score":267523,"extra":""},{"author":{"id":1547667,"avatar":"https://static001.geekbang.org/account/avatar/00/17/9d/93/4159edaa.jpg","nickname":"朴素柠檬c","note":"","ucode":"2D4CBB70D801B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1023885,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9f/8d/d725d32c.jpg","nickname":"李德政","note":"","ucode":"3AC49F5671485C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324637,"discussion_content":"这个DP缩写 简直了","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1605146738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":267523,"ip_address":""},"score":324637,"extra":""}]},{"author":{"id":2555790,"avatar":"https://static001.geekbang.org/account/avatar/00/26/ff/8e/b16d75c6.jpg","nickname":"Yuki","note":"","ucode":"936E2C34F16B72","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368605,"discussion_content":"还以为是dp算法。。。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1618758332,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015483,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","nickname":"程序员小跃","note":"","ucode":"25BB96E0791A60","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51001,"discussion_content":"所以实战才是对代码的尊重，设计模式在实战中提现，真的是太棒了。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1573798034,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1547667,"avatar":"https://static001.geekbang.org/account/avatar/00/17/9d/93/4159edaa.jpg","nickname":"朴素柠檬c","note":"","ucode":"2D4CBB70D801B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1015483,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","nickname":"程序员小跃","note":"","ucode":"25BB96E0791A60","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":324638,"discussion_content":"不写代码吓逼逼的程序员都是废物","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605146763,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":51001,"ip_address":""},"score":324638,"extra":""}]},{"author":{"id":1182984,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0d/08/2f825f69.jpg","nickname":"丁源(156*****518)","note":"","ucode":"BDBB8B7D0745FC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46407,"discussion_content":"期待作者给出一些够味的设计范例","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1573167378,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1661704,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5b/08/b0b0db05.jpg","nickname":"丁丁历险记","note":"","ucode":"A43829E454C067","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1182984,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0d/08/2f825f69.jpg","nickname":"丁源(156*****518)","note":"","ucode":"BDBB8B7D0745FC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46427,"discussion_content":"me 2","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573170127,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":46407,"ip_address":""},"score":46427,"extra":""}]},{"author":{"id":1243370,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f8/ea/98738420.jpg","nickname":"Jaswine","note":"","ucode":"EE39D9629204DB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":44966,"discussion_content":"规则引擎？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1572996393,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2848276,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIRrgrGQYmic2V6bkmbtfXXrsjk3boxpt8KyBuQvazSVHpvtzzvdT4p192jdG5JgIN1nPVziav8Auew/132","nickname":"Geek_38d160","note":"","ucode":"AE3588D61FBB6D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536815,"discussion_content":"还以为出bug了，怎么把算法那边的评论带过来了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1638874556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1024294,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","nickname":"null","note":"","ucode":"F9039EFED6B55D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":45096,"discussion_content":"好巧，我也重构过类似项目，用户匹配规则，奖励下发内容，通知机制，都抽象出来，只留下几个不可变的逻辑代码类。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573003789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2044957,"avatar":"","nickname":"coc","note":"","ucode":"64FC186B1055B7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578648,"discussion_content":"现在应该是跑路了，全国的P2P已经清空了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656922894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1045577,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f4/49/2add4f6b.jpg","nickname":"北极的大企鹅","note":"","ucode":"8935346D08E109","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":354294,"discussion_content":"dp\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615269686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1441810,"avatar":"https://static001.geekbang.org/account/avatar/00/16/00/12/7048984b.jpg","nickname":"Krystal","note":"","ucode":"A8986403DE927C","race_medal":3,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297703,"discussion_content":"我以为是深度优先","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597027718,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":2056201,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/60/09/a8e7913b.jpg","nickname":"SandCarving","note":"","ucode":"6B97DB71613A46","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1441810,"avatar":"https://static001.geekbang.org/account/avatar/00/16/00/12/7048984b.jpg","nickname":"Krystal","note":"","ucode":"A8986403DE927C","race_medal":3,"user_type":1,"is_pvip":true},"discussion":{"id":340692,"discussion_content":"深度优先是df吧，应该是动态规划🆗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1610099134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":297703,"ip_address":""},"score":340692,"extra":""},{"author":{"id":1194060,"avatar":"https://static001.geekbang.org/account/avatar/00/12/38/4c/5426e2e0.jpg","nickname":"CJJ","note":"","ucode":"7E02A6A8547559","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":2056201,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/60/09/a8e7913b.jpg","nickname":"SandCarving","note":"","ucode":"6B97DB71613A46","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345780,"discussion_content":"这里的dp是指设计模式吧哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611794467,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":340692,"ip_address":""},"score":345780,"extra":""},{"author":{"id":2446982,"avatar":"https://static001.geekbang.org/account/avatar/00/25/56/86/db4c0d1c.jpg","nickname":"ljx","note":"","ucode":"6133FC98C44498","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1441810,"avatar":"https://static001.geekbang.org/account/avatar/00/16/00/12/7048984b.jpg","nickname":"Krystal","note":"","ucode":"A8986403DE927C","race_medal":3,"user_type":1,"is_pvip":true},"discussion":{"id":350103,"discussion_content":"难道不是动态规划吗😂 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613709214,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":297703,"ip_address":""},"score":350103,"extra":""}]},{"author":{"id":1055624,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1b/88/ac69f57a.jpg","nickname":"磉盘","note":"","ucode":"1C245991F30A73","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":47658,"discussion_content":"作业部分怎么体现出设计模式的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573386949,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1736485,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/7f/25/f6c3a5d8.jpg","nickname":"符明明","note":"","ucode":"44028EA9967627","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":45910,"discussion_content":"1. 我不会写大型程序。2. 没有。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573097124,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1566477,"avatar":"https://static001.geekbang.org/account/avatar/00/17/e7/0d/506bd8d1.jpg","nickname":"蝈蝈不是蛐蛐","note":"","ucode":"ADE5747408081A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1736485,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/7f/25/f6c3a5d8.jpg","nickname":"符明明","note":"","ucode":"44028EA9967627","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300793,"discussion_content":"������������","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598264937,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":45910,"ip_address":""},"score":300793,"extra":""}]},{"author":{"id":1134861,"avatar":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","nickname":"James","note":"","ucode":"48B0F2A334D1C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":45417,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573036653,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1577856,"avatar":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","nickname":"L🚲🐱","note":"","ucode":"08A012739614DE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":43424,"discussion_content":"设计模式和算法数据结构一样重要，只用过单例和工厂模式， 在争哥的带领下好好学习","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572873904,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1661704,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5b/08/b0b0db05.jpg","nickname":"丁丁历险记","note":"","ucode":"A43829E454C067","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1577856,"avatar":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","nickname":"L🚲🐱","note":"","ucode":"08A012739614DE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":43430,"discussion_content":"一起加油","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1572874129,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":43424,"ip_address":""},"score":43430,"extra":""},{"author":{"id":1577856,"avatar":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","nickname":"L🚲🐱","note":"","ucode":"08A012739614DE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1661704,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5b/08/b0b0db05.jpg","nickname":"丁丁历险记","note":"","ucode":"A43829E454C067","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50054,"discussion_content":"嗯嗯 一起加油","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573658993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":43430,"ip_address":""},"score":50054,"extra":""}]}]},{"had_liked":false,"id":185057,"user_name":"batman","can_delete":false,"product_type":"c1","uid":1266482,"ip_address":"","ucode":"73C30ACFC0D612","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/IIkdC2gohpcibib0AJvSdnJQefAuQYGlLySQOticThpF7Ck9WuDUQLJlgZ7ic13LIFnGBXXbMsSP3nZsbibBN98ZjGA/132","comment_is_top":false,"comment_ctime":1583474148,"is_pvip":true,"discussion_count":1,"race_medal":1,"score":"1583474148","product_id":100039001,"comment_content":"createTimestamp，是在构造函数初始化的当前系统时间，<br>executionInvokedTimestamp，是在execute执行的时候初始化的系统时间<br>怎么可能会存在14天过期的情况。<br><br>代码逻辑有问题，还是我没看懂代码？","like_count":0,"discussions":[{"author":{"id":2226367,"avatar":"https://static001.geekbang.org/account/avatar/00/21/f8/bf/59f2e600.jpg","nickname":"月明风清","note":"","ucode":"65A97CF2E320FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575895,"discussion_content":"笑死我了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655175187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3015503,"avatar":"","nickname":"Geek_08a0f7","note":"","ucode":"C2D78F6B714B88","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573993,"discussion_content":"人才！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653788860,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2820671,"avatar":"","nickname":"require","note":"","ucode":"3AA3DCE0CD73E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542072,"discussion_content":"有画面感了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640658560,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1103353,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d5/f9/1f9a2c3c.jpg","nickname":"磨砖做镜","note":"","ucode":"D8B8196AE1ED98","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":249498,"discussion_content":"是啊，来的早吃肉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587944678,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184915,"user_name":"batman","can_delete":false,"product_type":"c1","uid":1266482,"ip_address":"","ucode":"73C30ACFC0D612","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/IIkdC2gohpcibib0AJvSdnJQefAuQYGlLySQOticThpF7Ck9WuDUQLJlgZ7ic13LIFnGBXXbMsSP3nZsbibBN98ZjGA/132","comment_is_top":false,"comment_ctime":1583452208,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1583452208","product_id":100039001,"comment_content":"this.status = STATUS.TO_BE_EXECUTD;<br>初始化对象的时候已经赋值了 ，而代码的35，42行的检查什么情况下会被执行？<br><br>希望老师能说明下哈","like_count":0},{"had_liked":false,"id":182815,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1582870009,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582870009","product_id":100039001,"comment_content":"1.从可测试性来说,这个方法只是一个自动生成id的方法,对于可测试性来说,并不影响,但是从实际生产的角度来说,这个方法是一个全局的自增id方法,多次测试可能会出现某些不可预料的问题,但是也可以因此发现某些问题,我不建议重写,当然重写也行,就是通过依赖注入的方式进行使用,然后注入我们自己编的mock<br>2.对于第二个问题,在常见的mvc三层框架中,上层代码会生成下层代码,供其使用,这就是类内部new的方式创建的","like_count":0},{"had_liked":false,"id":178478,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1581697166,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1581697166","product_id":100039001,"comment_content":"private 方法在Java进行单元测试的时候，可以通过反射获取","like_count":0,"discussions":[{"author":{"id":2356993,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/KMVyjF3bDDa7oot4QVWiaiaicMho9JtZ2E8nWqK8562B6HEicOwyfmAGwocLsvTMMnqWqEob5BrlI0OJpTvLMx7U5Q/132","nickname":"Geek_c7292f","note":"","ucode":"BB6F9413C0A0D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335096,"discussion_content":"看来你的编码热情非常高，我欣赏你","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1608090975,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2882086,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/fa/26/a38f4b5d.jpg","nickname":"jl","note":"","ucode":"3EC1591B396600","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543334,"discussion_content":"我也想获得这种快乐","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641093908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1122533,"avatar":"https://static001.geekbang.org/account/avatar/00/11/20/e5/f66d6144.jpg","nickname":"九先生","note":"","ucode":"A63A333299D485","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385678,"discussion_content":"当年我也是这样，哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627203732,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1363834,"avatar":"https://static001.geekbang.org/account/avatar/00/14/cf/7a/51951b07.jpg","nickname":"微笑","note":"","ucode":"6E8E2964D0191F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51681,"discussion_content":"哈哈  感觉单例  直接用注解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573914926,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1593289,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","nickname":"编程界的小学生","note":"","ucode":"4A5BE9A5E877FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1363834,"avatar":"https://static001.geekbang.org/account/avatar/00/14/cf/7a/51951b07.jpg","nickname":"微笑","note":"","ucode":"6E8E2964D0191F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51704,"discussion_content":"被spring管理的可以直接一个注解，不被spring管理的就需要手动写了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573916381,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":51681,"ip_address":""},"score":51704,"extra":""}]}]},{"had_liked":false,"id":178088,"user_name":"小兵","can_delete":false,"product_type":"c1","uid":1261674,"ip_address":"","ucode":"AA3BA727C25179","user_header":"https://static001.geekbang.org/account/avatar/00/13/40/6a/ab1cf396.jpg","comment_is_top":false,"comment_ctime":1581584528,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581584528","product_id":100039001,"comment_content":"4,5,6的测试都可以通过执行两次execute方法来实现，第一遍改变状态，第二遍真正的测试。<br>另外一个感受，如果是由于依赖关系导致的难以测试，就需要考虑是不是紧耦合了。<br>如果不是，那么可能就不应该通过抽取单独的方法的方式来方便测试。因为抽取单独的方法也就相当于对外开放了修改权限了。像案例中的过期时间方法，protected修饰就可能有问题。","like_count":0},{"had_liked":false,"id":177727,"user_name":"Edward Lee","can_delete":false,"product_type":"c1","uid":1228518,"ip_address":"","ucode":"156223F1D7E94A","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/e6/7808520d.jpg","comment_is_top":false,"comment_ctime":1581482039,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581482039","product_id":100039001,"comment_content":"TransactionLock 通过适配器来提供可测试的代码实在太惊艳了<br><br>原来单元测试难度不在于怎么提高测试覆盖率而是改造已有的代码成可测试代码，在开发过程就要考虑代码的可测试性，如果在单元测试的时候再考虑重构的话工作量就比较大了<br><br>if (preAssignedId != null &amp;&amp; !preAssignedId.isEmpty()) {<br>  this.id = preAssignedId;<br>} else {<br>  this.id = IdGenerator.generateTransactionId();<br>}<br>if (!this.id.startWith(&quot;t_&quot;)) {<br>  this.id = &quot;t_&quot; + preAssignedId;<br>}<br><br>IdGenerator.generateTransactionId() 个人认为不需要 Mock 了，另外 this.id = &quot;t_&quot; + preAssignedId; 是不是有 bug 呢？是不是应该 this.id = &quot;t_&quot; + this.id; 才对呢？","like_count":0},{"had_liked":false,"id":177622,"user_name":"楊_宵夜","can_delete":false,"product_type":"c1","uid":1019302,"ip_address":"","ucode":"7BA0CADC5F23BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/a6/22c37c91.jpg","comment_is_top":false,"comment_ctime":1581435794,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581435794","product_id":100039001,"comment_content":"争哥, 又有两个问题:<br>if (status == STATUS.EXECUTED) ;<br>进行了double check, 但这句前面获取的是分布式锁;<br><br>1. 那这个double check主要意义何在呢? 或者是针对解决那种业务场景呢??<br>2. 虽然与设计模式无关, 但status这个变量是否应该设置为volatile??","like_count":0},{"had_liked":false,"id":177575,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1015754,"ip_address":"","ucode":"00DF2FEC58D2E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","comment_is_top":false,"comment_ctime":1581427301,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1581427301","product_id":100039001,"comment_content":"争哥，一直对于编写单元测试有一个疑问：如果要测试的代码涉及到数据库的操作，当测试用例跑完了后，如何对数据库进行后处理呢？对于在测试过程中产生的数据，也通过其测试用例来删除？抑或是，访问数据库的点不需要测试？？请争哥抽时间帮忙解惑！感谢了","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473261,"discussion_content":"函数式编程感觉还是没面向对象流行 所以专栏中没讲","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572922845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1274328,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLicryBoLjDicckia0c5bkOoAlYoR2I9NMK8BiaD7HCGxhS1eM9YSfDuUJuZC90uwv9FvHIVSsBoxFgZw/132","nickname":"MwumLi","note":"","ucode":"9A8A72334ADF6E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51719,"discussion_content":"觉得可可以单独一篇进行对比一下","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573917455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1479082,"avatar":"https://static001.geekbang.org/account/avatar/00/16/91/aa/374cc963.jpg","nickname":"流水人家","note":"","ucode":"9BB4367CAAF781","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":43436,"discussion_content":"函数式编程和面向对象不冲突吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572874423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175374,"user_name":"Corner","can_delete":false,"product_type":"c1","uid":1446316,"ip_address":"","ucode":"7862D593172536","user_header":"https://static001.geekbang.org/account/avatar/00/16/11/ac/9cc5e692.jpg","comment_is_top":false,"comment_ctime":1580698140,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580698140","product_id":100039001,"comment_content":"可不可以这么理解呢，如果静态方法依赖外部系统或者逻辑复杂，是不是最好重写为面向对象的实例方法呢？","like_count":0},{"had_liked":false,"id":174222,"user_name":"沈杰","can_delete":false,"product_type":"c1","uid":1230818,"ip_address":"","ucode":"20D1D820CAD60D","user_header":"https://static001.geekbang.org/account/avatar/00/12/c7/e2/27d00854.jpg","comment_is_top":false,"comment_ctime":1580094629,"is_pvip":true,"discussion_count":0,"race_medal":4,"score":"1580094629","product_id":100039001,"comment_content":"666，还是很实用，特别是重构代码可测试性部分很有启发","like_count":0},{"had_liked":false,"id":172782,"user_name":"satoshi","can_delete":false,"product_type":"c1","uid":1114872,"ip_address":"","ucode":"11508C95259E97","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLQcr5YD5xznNjMxltFI04NgpTWWicKD3QicBfshIEWtckXNYMicjdNfQu8w5hSTGicuxUg6sOI8yfoNw/132","comment_is_top":false,"comment_ctime":1579310750,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579310750","product_id":100039001,"comment_content":"豁然开朗...","like_count":0},{"had_liked":false,"id":171673,"user_name":"睁眼看世界","can_delete":false,"product_type":"c1","uid":1206388,"ip_address":"","ucode":"F94CF34BC5B2AC","user_header":"https://static001.geekbang.org/account/avatar/00/12/68/74/461b202d.jpg","comment_is_top":false,"comment_ctime":1578989534,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578989534","product_id":100039001,"comment_content":"有对象生命周期的需要依赖注入，基于接口而非实现；对于局部对象，如相关*VO对象可直接new，因为其是临时的。","like_count":0},{"had_liked":false,"id":171152,"user_name":"jaryoung","can_delete":false,"product_type":"c1","uid":1077406,"ip_address":"","ucode":"6E72D107DB7E51","user_header":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","comment_is_top":false,"comment_ctime":1578874629,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578874629","product_id":100039001,"comment_content":"思考1，无需实现，随机生成的ID不应该影响业务主流程，除非ID有业务含义就另当别论。<br>思考二，如果类本身是当前类的内部类？","like_count":0},{"had_liked":false,"id":170686,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1578665397,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1578665397","product_id":100039001,"comment_content":"争哥，想请教一个问题。我们在mock RedisDistributedLock的时候，将其封装成TransactionLock，这样原Transaction类中调用RedisDistributedLock的地方都改成了调用TransactionLock。<br>这样不就破坏了原有类的实现吗？如果这样的mock很多，最后忘记修改，会不会有问题？","like_count":0,"discussions":[{"author":{"id":1126534,"avatar":"https://static001.geekbang.org/account/avatar/00/11/30/86/c4e4d753.jpg","nickname":"优雅一点","note":"","ucode":"DA9608594E7602","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":43213,"discussion_content":"我连观察者模式都没用过","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1572863503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1601101,"avatar":"https://static001.geekbang.org/account/avatar/00/18/6e/4d/22de9c0e.jpg","nickname":"SweetyTang","note":"","ucode":"5EB1431FA66F1D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1126534,"avatar":"https://static001.geekbang.org/account/avatar/00/11/30/86/c4e4d753.jpg","nickname":"优雅一点","note":"","ucode":"DA9608594E7602","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":43219,"discussion_content":"一起让争哥带飞 😃","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572863829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":43213,"ip_address":""},"score":43219,"extra":""}]},{"author":{"id":1258839,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/57/ab4ba792.jpg","nickname":"小鱼","note":"","ucode":"9F3D087A95D0C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51191,"discussion_content":"我做后端也经常用观察者模式啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573822445,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134761,"avatar":"https://static001.geekbang.org/account/avatar/00/11/50/a9/3f8c7418.jpg","nickname":"冰糕不冰","note":"","ucode":"B754FE464BA426","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":43343,"discussion_content":"做客户端开发的同学吧？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1572869561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1601101,"avatar":"https://static001.geekbang.org/account/avatar/00/18/6e/4d/22de9c0e.jpg","nickname":"SweetyTang","note":"","ucode":"5EB1431FA66F1D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1134761,"avatar":"https://static001.geekbang.org/account/avatar/00/11/50/a9/3f8c7418.jpg","nickname":"冰糕不冰","note":"","ucode":"B754FE464BA426","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":43406,"discussion_content":"嗯，你这都可以看出来，佩服","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572872433,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":43343,"ip_address":""},"score":43406,"extra":""},{"author":{"id":1134761,"avatar":"https://static001.geekbang.org/account/avatar/00/11/50/a9/3f8c7418.jpg","nickname":"冰糕不冰","note":"","ucode":"B754FE464BA426","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1601101,"avatar":"https://static001.geekbang.org/account/avatar/00/18/6e/4d/22de9c0e.jpg","nickname":"SweetyTang","note":"","ucode":"5EB1431FA66F1D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":43518,"discussion_content":"因为我们公司安卓经常给我说观察者模式，通知这个那个页面更新UI，哈哈。还有eventbus","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572879415,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":43406,"ip_address":""},"score":43518,"extra":""}]}]},{"had_liked":false,"id":170685,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1578665348,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578665348","product_id":100039001,"comment_content":"争哥，想请教一个问题。我们在mock RedisDistributedLock的时候，将其封装成TransactionLock，这样原Transaction类中调用RedisDistributedLock的地方都改成了调用TransactionLock。<br>这样不就破坏了原有类的实现吗？如果这样的mock很多，最后忘记修改，会不会有问题？","like_count":0},{"had_liked":false,"id":170625,"user_name":"L🚲🐱","can_delete":false,"product_type":"c1","uid":1577856,"ip_address":"","ucode":"08A012739614DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","comment_is_top":false,"comment_ctime":1578646035,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578646035","product_id":100039001,"comment_content":"关于思考题:  思考题 一 IdGenerator.generateTransactionId() 只是生成一个 id 生成器, 不需要mock 这个函数, 就生成一个随机数, 没多大测试意义.<br>思考题二 有实现方法的类应该用依赖注入减少依赖, entity bo vo 等bean 可以 new 不需要依赖注入","like_count":0},{"had_liked":false,"id":170619,"user_name":"堵车","can_delete":false,"product_type":"c1","uid":1145404,"ip_address":"","ucode":"7BC1E50A4F8D3D","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/3c/87e015f8.jpg","comment_is_top":false,"comment_ctime":1578645172,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578645172","product_id":100039001,"comment_content":"请问单元测试在什么时候做比较好？是一个模块写完再测试还是一个方法写完再测试？文中获取redis锁用静态方法，一行代码就搞定了，而且几乎所有的分布式锁都是这样的写法，用起来很方便，后期几乎不会变动。为了可测试性，每个业务都封装了一个lock,是不是过度解耦了。","like_count":0},{"had_liked":false,"id":170565,"user_name":"花儿少年","can_delete":false,"product_type":"c1","uid":1318540,"ip_address":"","ucode":"CFE4F64243673B","user_header":"https://static001.geekbang.org/account/avatar/00/14/1e/8c/450fe5cb.jpg","comment_is_top":false,"comment_ctime":1578633966,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578633966","product_id":100039001,"comment_content":"mock的通常是外部服务，id生成器如果是个外部服务那就需要mock，不过通常来说id生成不会影响业务逻辑。<br>什么时间可以new，需要取决于new的对象是否有外部依赖，有则需要注入，否则可以new","like_count":0},{"had_liked":false,"id":170531,"user_name":"石仔","can_delete":false,"product_type":"c1","uid":1177921,"ip_address":"","ucode":"974E4604CE2213","user_header":"https://static001.geekbang.org/account/avatar/00/11/f9/41/411b1753.jpg","comment_is_top":false,"comment_ctime":1578627244,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578627244","product_id":100039001,"comment_content":"[原则]是:不依赖网络,IO或者第三方服务的就可以不需要mock.<br>1.本实战案例 并没有要对TransactionId进行验证,所以只要它能正常生成就完成了它的任务不需要mock.<br>2.类内部通过 new 的方式创建对象,只要这个对象的创建不违反[原则]而且不需要在后续测试依赖到就可以放在内部new来创建.<br><br>3.未决行为Demo:<br><br>public class Demo {<br>    private long currentTimestamp;<br>    private long dueTimestamp;<br><br>    public Demo(long currentTimestamp, long dueTimestamp) {<br>        this.currentTimestamp = currentTimestamp;<br>        this.dueTimestamp = dueTimestamp;<br>    }<br><br>    &#47;**<br>     * 计算延迟天数<br>     *<br>     * @return<br>     *&#47;<br>    public long caculateDelayDays() {<br>        if (!isDelayDays()) {<br>            return 0;<br>        }<br>        long delayTime = this.currentTimestamp - this.dueTimestamp;<br>        long delayDays = delayTime &#47; 86400;<br>        return delayDays;<br>    }<br><br>    &#47;**<br>     * 是否延迟<br>     *<br>     * @return<br>     *&#47;<br>    public boolean isDelayDays() {<br>        if (this.dueTimestamp &gt;= this.currentTimestamp) {<br>            return false;<br>        }<br>        return true;<br>    }<br>}<br><br>测试:<br>    @Test<br>    public void caculateDelayDaysTest() {<br>        long currentTimestamp = System.currentTimeMillis();<br>        Demo demo = new Demo(System.currentTimeMillis(), currentTimestamp - 14 * 86400);<br>        assertEquals(14l, demo.caculateDelayDays());<br>    }","like_count":0},{"had_liked":false,"id":170432,"user_name":"Ken张云忠","can_delete":false,"product_type":"c1","uid":1134288,"ip_address":"","ucode":"D0BAC9FC17DE2B","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","comment_is_top":false,"comment_ctime":1578615063,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578615063","product_id":100039001,"comment_content":"1.实战案例中的 void fillTransactionId(String preAssignedId) 函数中包含一处静态函数调用：IdGenerator.generateTransactionId()，这是否会影响到代码的可测试性？在写单元测试的时候，我们是否需要 mock 这个函数？<br>如果generateTransactionId()依赖了外部服务,如redis&#47;mysql&#47;zookeeper等,就会影响代码的可测试性,在写单元测试时就需要mock这个函数;<br>如果generateTransactionId()没有依赖外部服务就不会影响代码的可测试性,写单元测试时也不需要mock这个函数.<br><br>2.依赖注入是提高代码可测试性的最有效的手段。所以，依赖注入，就是不要在类内部通过 new 的方式创建对象，而是要通过外部创建好之后传递给类使用。<br>那是不是所有的对象都不能在类内部创建呢？哪种类型的对象可以在类内部创建并且不影响代码的可测试性？你能举几个例子吗？<br>不是.<br>没有依赖外部服务的对象可以在类内部创建,并且不会影响代码的可测试性.<br>例如new Date()没有依赖外部服务,只是调用了本机操作系统的时间函数.","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473447,"discussion_content":"可以的 我后面可以考虑多写几篇加餐","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1572993697,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170206,"user_name":"一名小学生","can_delete":false,"product_type":"c1","uid":1137292,"ip_address":"","ucode":"5C73082E6B6370","user_header":"https://static001.geekbang.org/account/avatar/00/11/5a/8c/1fec5fa2.jpg","comment_is_top":false,"comment_ctime":1578550153,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1578550153","product_id":100039001,"comment_content":"一直搞不懂单元测试怎么写，于是就不喜欢写，跟着这节课敲了代码，学到了好多。感觉知道怎么去写，感觉自己一下变强了，争哥太强了，666","like_count":0,"discussions":[{"author":{"id":1145404,"avatar":"https://static001.geekbang.org/account/avatar/00/11/7a/3c/87e015f8.jpg","nickname":"堵车","note":"","ucode":"7BC1E50A4F8D3D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":128503,"discussion_content":"我学到了“可测试性”这个概念。懂得怎么用断言","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578645343,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170038,"user_name":"#HEAVEN","can_delete":false,"product_type":"c1","uid":1191155,"ip_address":"","ucode":"C14977F6D24E19","user_header":"https://static001.geekbang.org/account/avatar/00/12/2c/f3/bab761d0.jpg","comment_is_top":false,"comment_ctime":1578495488,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578495488","product_id":100039001,"comment_content":"你好，没有找到作者邮箱，想问一个问题；<br>作者在开发一个需求的时候是怎样的一个流程，设计做到那种程度？<br>比如说一般我会做1. 需求分析，列出哪些需求case； 2. 列出这些case需要开发哪些功能点；3. 主要涉及到哪些类，结构如何组织；4. 主要类的主要职责等；5. 开始code了；<br>在开发的过程中也会遇到一些问题，比如，有时候有些类的职责或者结构开始的设计不太合理，需要一些修改；这个时候我就在怀疑，是不是前期做的设计不够充分造成的。也看到一些书上会把类的属性、方法都设计出来，还有主要流程case的序列图；但是这样做耗时较多，很多时候项目日程不允许。<br>像问一下，作者在开发中设计阶段有哪些流程，做到什么程度？<br>留个邮箱方便交流就更好了","like_count":0},{"had_liked":false,"id":169997,"user_name":"一壶浊酒","can_delete":false,"product_type":"c1","uid":1145530,"ip_address":"","ucode":"5D90F8F8121BBE","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/ba/8545f2d7.jpg","comment_is_top":false,"comment_ctime":1578490574,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1578490574","product_id":100039001,"comment_content":"对于IdGenerator.generateTransactionId()，虽然是未决行为，个人认为只是生成一个id了话，并不会包含非常复杂的逻辑操作，应该就跟Math.abs()类似，不需要进行mock","like_count":0},{"had_liked":false,"id":169968,"user_name":"斐波那契","can_delete":false,"product_type":"c1","uid":1464006,"ip_address":"","ucode":"85E2EBC01392B1","user_header":"https://static001.geekbang.org/account/avatar/00/16/56/c6/0b449bc6.jpg","comment_is_top":false,"comment_ctime":1578485377,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578485377","product_id":100039001,"comment_content":"感觉那个createtimestamp那边 如果没有set方法应该可以用反射去修改这个属性<br><br>思考题1 可以不mock 因为执行idgenerator之前有逻辑判断的 只要传入进去的参数不满足条件就不会走 其次对于id开头添加t_这个逻辑跟id生成器没有关系 只要保证造出来到id没有t_开头就可以测试<br><br>思考题2 其实最近在写一个需求 我就用了内部类 也觉得并没有破坏测试性 我这个内部类主要是为了隐藏某个接口的实现 不想被调用者在使用外部类时滥用我的每一个接口实现方法 起到一个保护作用 对于测试性 完全可以通过不同的外部类参数来进行调整 其实对于内部类的可测试性来讲 只要外部类有足够的参数来控制内部类就可以 对于内部类调用第三方的情况 只要外部类有参数可以注入就可以用mock来修改内部类的实现","like_count":0},{"had_liked":false,"id":169855,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1578459458,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578459458","product_id":100039001,"comment_content":"1.栏主好像提过，要谈谈分层对于可测试性的影响，不知是不是我记错了，这篇没提到哈。<br><br>回答问题<br>1.交易id这东西，是全局唯一的。不该被mock，mock了不仅没用，反而可能会有其他问题（如果有引入唯一键检验相关机制的话，比如幂等啥的）。<br><br>2.值对象可以new，因为值对象不会有涉及改动自身属性的方法，也就是说它通常是不可变的，所以也没什么检验的意义。而实体领域模型不一定可以new，因为其方法会改变自身属性，而对这些属性变动，有时候我们需要校验。而贫血实体dto或do之类的，一般也可以new，因为它只承接属性，场景类似值对象，只需要关心方法返回的dto或vo的值即可，无需关心方法内部是new还是注入的（对于方法而言，除了类成员属性的注入，方法入参也算注入吧）。","like_count":0},{"had_liked":false,"id":169839,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1578454869,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578454869","product_id":100039001,"comment_content":"设计模式_29:<br><br>1. 我认为静态方法```IdGenerator.generateTransactionId()```不需要mock，因为它不会很耗时(如果实现比较正常)，也没有未决行为，除非对于id有特殊的要求，否则不需要mock。<br><br>2. 这道题我想不清楚，想看看王争老师和大家的看法。","like_count":0},{"had_liked":false,"id":169832,"user_name":"此鱼不得水","can_delete":false,"product_type":"c1","uid":1257453,"ip_address":"","ucode":"95268E823FB4D2","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/ed/a87bb8fa.jpg","comment_is_top":false,"comment_ctime":1578453731,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1578453731","product_id":100039001,"comment_content":"1. 未决行为 中提到的单测，可以把不确定的变量‘当前时间’提取出来作为入参","like_count":0,"discussions":[{"author":{"id":1055334,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1a/66/2d9db9ed.jpg","nickname":"苦行僧","note":"","ucode":"726024A9A9CF44","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":131907,"discussion_content":"怎么理解？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578874493,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169815,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1578451094,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1578451094","product_id":100039001,"comment_content":"课堂讨论:<br><br><br><br>Q1.实战案例中的 void fillTransactionId(String preAssignedId) 函数中包含一处静态函数调用：IdGenerator.generateTransactionId()，这是否会影响到代码的可测试性？在写单元测试的时候，我们是否需要 mock 这个函数？<br><br><br><br>Answer1: <br><br>理论上讲fill()方法由于内部静态方法的使用,及id生成的未决行为,影响可测试性.<br><br>解决方法是为fill()方法添加一个形参,generateId,如下:<br><br>void fillTransactionId(@Nullable String preAssignedId, @Nullable String generateId)<br><br>但这样做会影响封装性.fill()方法内部逻辑简单,对可测试性的影响是微不足道的.除非测试问题直指fill()方法,否则个人倾向于不做修改.<br><br><br><br>Q2.我们今天讲到，依赖注入是提高代码可测试性的最有效的手段。所以，依赖注入，就是不要在类内部通过 new 的方式创建对象，而是要通过外部创建好之后传递给类使用。那是不是所有的对象都不能在类内部创建呢？哪种类型的对象可以在类内部创建并且不影响代码的可测试性？你能举几个例子吗？<br><br><br><br>Answer2: 内部类或静态内部类, 局部类的对象可以在类内部通过new 的方式初始化.它们是外部类行为的一部分,仅为外部类自己使用,不影响测试性.<br><br><br><br>对于未决行为方法的改造:<br><br>before: <br><br><br><br>public class Demo { <br><br>public long caculateDelayDays(Date dueTime){<br><br> long currentTimestamp = System.currentTimeMillis();<br><br> if (dueTime.getTime() &gt;= currentTimestamp) { return 0; } <br><br>long delayTime = currentTimestamp - dueTime.getTime();<br><br> long delayDays = delayTime &#47; 86400; <br><br>return delayDays; <br><br>​    }<br><br>}<br><br><br><br>after:<br><br>public class Demo { <br><br>public long caculateDelayDays(Date dueTime, Date currentTime){<br><br>​     long currentTimestamp = currentTime.getTime();<br><br>​     if (dueTime.getTime() &gt;= currentTimestamp) { return 0; } <br><br>​     long delayTime = currentTimestamp - dueTime.getTime();<br><br>​     long delayDays = delayTime &#47; 86400; <br><br>​     return delayDays; <br><br>​    }<br><br>}","like_count":0},{"had_liked":false,"id":169805,"user_name":"Jackey","can_delete":false,"product_type":"c1","uid":1063751,"ip_address":"","ucode":"125DE81993FEDD","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/47/f6c772a1.jpg","comment_is_top":false,"comment_ctime":1578448850,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578448850","product_id":100039001,"comment_content":"ID生成方法只是生成一个字符串，个人认为可以不用测试","like_count":0},{"had_liked":false,"id":169799,"user_name":"liu_liu","can_delete":false,"product_type":"c1","uid":1019138,"ip_address":"","ucode":"24283806A07759","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/02/6a16058a.jpg","comment_is_top":false,"comment_ctime":1578447914,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578447914","product_id":100039001,"comment_content":"1. 生成的id 并不会对主体逻辑造成影响，无需mock，只需该 idGen 本身通过单元测试即可。<br>2. 如果未使用到依赖对象的功能，或者其功能很简单，又或者使用了也不会影响到当前被测函数逻辑，可以内部 new。","like_count":0},{"had_liked":false,"id":169794,"user_name":"成楠Peter","can_delete":false,"product_type":"c1","uid":1252977,"ip_address":"","ucode":"4D13E7368D8CF2","user_header":"https://static001.geekbang.org/account/avatar/00/13/1e/71/9dcbe6c4.jpg","comment_is_top":false,"comment_ctime":1578447737,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578447737","product_id":100039001,"comment_content":"这一节更偏向实战，写代码的方式，让我一下理解了依赖注入和反转依赖","like_count":0},{"had_liked":false,"id":169786,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1578446622,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1578446622","product_id":100039001,"comment_content":"1. 这个静态函数多少是有一些影响的，测试这个函数的时候，需要关注这个静态函数的逻辑，看它返回值，才能在测试的时候判断this.id是否满足期待值，比如这个静态函数返回值中不包含“t_”，那么单元测试的assert逻辑就不一样。在写单元测试时候，只要这个静态函数不是第三方的服务，也没有依赖第三方的服务，返回值的format固定，并且我们也不关心this.id的format，那么可以不mock它，反之，最好还是mock，这样测试的时候可以期待固定输入得到固定输出。<br>2. 贫血模型中的那些*o可以直接在里面new。","like_count":0,"discussions":[{"author":{"id":1743060,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er8xHGabhfnPnK7gN3hVJ0n3wia5qIaay7IOQaGJ4ia0kB1CKywjbJNeGjM7DKexk6TZl88f6um4pqw/132","nickname":"早早凡","note":"","ucode":"E70B0306637482","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305608,"discussion_content":"我也是安卓转java","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600015798,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169761,"user_name":"失火的夏天","can_delete":false,"product_type":"c1","uid":1241770,"ip_address":"","ucode":"10C6E66EB2A65F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","comment_is_top":false,"comment_ctime":1578443379,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"701658112627","product_id":100039001,"comment_content":"思考题1，该方法逻辑就是填充一个ID，基本都是内部实现的一个id生成器，可以不用重写。一定要重写也行，自己弄一个自增id实现就行了。<br>思考题2，提供方法的类不要new，也就是我们常说的service类，这个是要依赖注入的。提供属性的类，比如vo，bo，entity这些就可以new。","like_count":164},{"had_liked":false,"id":173308,"user_name":"楊_宵夜","can_delete":false,"product_type":"c1","uid":1019302,"ip_address":"","ucode":"7BA0CADC5F23BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/a6/22c37c91.jpg","comment_is_top":false,"comment_ctime":1579501200,"is_pvip":false,"replies":[{"id":"67739","content":"也是没办法的事情，理论上应该是private的。所以会有@VisibleForTesting这样的annotation","user_name":"作者回复","comment_id":173308,"uid":"1190123","ip_address":"","utype":1,"ctime":1580117345,"user_name_real":"王争"}],"discussion_count":8,"race_medal":0,"score":"302227211920","product_id":100039001,"comment_content":"争歌, 代码中isExpired()方法的修饰符是protected, 如果某些方法从设计原则来说应该设置为private的话, 那么这样的手动mock的方式是否就不适用了呢?<br>换个角度来提问: 为了维持可测试性, 在代码中加入过多protected的方法, 是否合理呢?","like_count":71,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482029,"discussion_content":"也是没办法的事情，理论上应该是private的。所以会有@VisibleForTesting这样的annotation","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1580117345,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1604722,"avatar":"https://static001.geekbang.org/account/avatar/00/18/7c/72/9bb072f2.jpg","nickname":"jesesun","note":"","ucode":"F5279F9043DDDA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":584587,"discussion_content":"针对protected方法破坏封装性的case，可以考虑下通过依赖注入或者工厂方法解决。具体操作：\n依赖注入方案：根据未决方法的根因是否通用划分两种场景。场景一、未决方法的根因比较通用（示例中的 System.currentTimestamp();），把根因抽取成独立的公共接口，当前类选择合适的接口实现作为默认值并可通过依赖注入按需替换默认值，单元测试时通过依赖注入替换当前类的默认值。场景二、未决方法的根因不通用，把根因抽取成当前类的成员接口，并由当前类的成员类提供默认实现，当前类选择这个成员类的实现作为默认值并可通过依赖注入按需替换默认值，单元测试时通过依赖注入替换当前类的默认值。\n工厂方法方案：把未决方法的根因抽取成接口，通过静态方法模式的工厂方法管理接口的实现（类似全局Map），当前类通过工厂方法获取接口的实现（如：CurrentTimeFactory.getInstance(InstanceType.Default)），单元测试时替换工厂方法中对应的接口实现（CurrentTimeFactory.setInstance(InstanceType.Default, new CurrentTimeMock())）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660957231,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":482029,"ip_address":"北京"},"score":584587,"extra":""}]},{"author":{"id":1004264,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/52/e8/92a2e66d.jpg","nickname":"第二少","note":"","ucode":"4A09D1E7589F67","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303346,"discussion_content":"protected限定的范围已经是比较克制的了，只能子类调用和重写，相比增加的可测试性带来的好处，代码中增加的protected方法带来的对封装性的破坏这种牺牲是值得的","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1599213620,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1166968,"avatar":"","nickname":"fisherhe","note":"","ucode":"7B5F692546279D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":240458,"discussion_content":"在某些情况下，私有方法只能通过反射来强行设值，有点破坏封装性。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587366001,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1311236,"avatar":"https://static001.geekbang.org/account/avatar/00/14/02/04/a678be45.jpg","nickname":"batiwant","note":"","ucode":"F873D815CBC801","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388041,"discussion_content":"easymock可以用define private public。 这样就可以测试类中的private函数了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628566526,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1609735,"avatar":"https://static001.geekbang.org/account/avatar/00/18/90/07/41d19261.jpg","nickname":"Nacol","note":"","ucode":"B645ECB9540B95","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308117,"discussion_content":"可以用powermock这种框架搞定","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600848843,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1455958,"avatar":"https://static001.geekbang.org/account/avatar/00/16/37/56/11068390.jpg","nickname":"倡印","note":"","ucode":"4F53AA5D017D89","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303792,"discussion_content":"其实我觉得可以设定一个公开的测试方法专门去调用私有的测试方法，这个公有的方法release 是没有的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599382411,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1019302,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8d/a6/22c37c91.jpg","nickname":"楊_宵夜","note":"","ucode":"7BA0CADC5F23BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1455958,"avatar":"https://static001.geekbang.org/account/avatar/00/16/37/56/11068390.jpg","nickname":"倡印","note":"","ucode":"4F53AA5D017D89","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304345,"discussion_content":"public 直接调 private，那private就没意义了。\n虽然不在release里面，但别人写代码时仍然是可以调你的private","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599550605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":303792,"ip_address":""},"score":304345,"extra":""}]}]},{"had_liked":false,"id":169774,"user_name":"安静的boy","can_delete":false,"product_type":"c1","uid":1196475,"ip_address":"","ucode":"F5F44B75228A85","user_header":"https://static001.geekbang.org/account/avatar/00/12/41/bb/21ce60d2.jpg","comment_is_top":false,"comment_ctime":1578445377,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"250686548545","product_id":100039001,"comment_content":"这节满满的干货👍👍👍","like_count":59},{"had_liked":false,"id":169785,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1578446537,"is_pvip":true,"discussion_count":7,"race_medal":0,"score":"156197269193","product_id":100039001,"comment_content":"参考争哥今天的代码写了例子中的测试（可运行）：<br>https:&#47;&#47;github.com&#47;gdhucoder&#47;Algorithms4&#47;tree&#47;master&#47;designpattern&#47;u29<br><br>今天学习到了高级的单元测试方法：<br>1、依赖外部单例：将单例封装<br>2、未决行为：例时间、随机数。将未决行为重新封装，测试时mock，使用匿名类。<br><br> 关于讨论1：需要mock的情况id会写入数据库的话，测试后需要恢复现场。曾经遇到过这么一个情况，id是通过一张表维护的，大于0，在代码中id的数据类型是Integer（遗留代码），由于测试时没有恢复现场，导致测试数据库中id增加过快，超过了代码中Integer的表示范围，而产生了意想不到的问题。","like_count":37,"discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":131121,"discussion_content":"哪里，别叫我大神了，这段时间在上学，三年没写也业务代码了。这篇是郑晔老师讲关于测试的：https://time.geekbang.org/column/article/79494，关于测试问题他还写了框架：https://github.com/dreamhead/moco 3k stars。看能否对你有帮助。另外你的问题最后如果解决了的话，希望能告诉我一下解决方法，谢谢！","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1578828147,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1092806,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ac/c6/30820fa2.jpg","nickname":"李阳","note":"","ucode":"22492F371F4C84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297648,"discussion_content":"这种测试用例一般用spring test就行了，测试完加上注解不提交事务。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597016466,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1325226,"avatar":"https://static001.geekbang.org/account/avatar/00/14/38/aa/5efa5ded.jpg","nickname":"_Sea","note":"","ucode":"8547A37BA766E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":130976,"discussion_content":"大神，请教一下；现在我们项目在做第三方支付的模块，也需要写单元测试，而且代码覆盖率要求90以上；有个问题就是在调用支付宝第三方接口的时候，写单元测试时很不好写，特别是异步回调验签的时候，逻辑分支多，需要自己照着支付宝的返回数据格式预置很多数据，类似这种调用第三方API支付与校验的有没有比较好的方法测试？ ps:我们使用的是Spring junit5","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578816196,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1610643,"avatar":"","nickname":"Geek_02ab4d","note":"","ucode":"2EC4198426A4A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":409990,"discussion_content":"public isExpere() -> protected?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635564810,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2115387,"avatar":"https://static001.geekbang.org/account/avatar/00/20/47/3b/70198ceb.jpg","nickname":"Aibo","note":"","ucode":"2CE3E77BD2D014","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325830,"discussion_content":"有数据库操作，不就是类似文章中对redis的依赖吗。可以重构去mock吧，或者就是一套功能按一个流程测试，先新增再修改，最后删除。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605440506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1003644,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/50/7c/9082fb04.jpg","nickname":"林","note":"","ucode":"727C1E5E21E126","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":156561,"discussion_content":"「高级的单元测试方法」的1、2，都是将相关逻辑封装起来，使用匿名类进行mock吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580379830,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1698258,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIx7FdRzUuQf4Fopr7DOXEHZyCFfH4GQViaqo7bymf1qaANcOvuEhHyTNwOOUFW7psxEeSQ5k9uXWw/132","nickname":"阿顺","note":"","ucode":"36F2AD6F980B11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":134923,"discussion_content":"beforeEach和afterEach派上用场了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579055372,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221883,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1590628368,"is_pvip":false,"replies":[{"id":"87067","content":"这个不叫高度耦合吧。不是说耦合很多就是高度耦合，也要看业务需求啊，确实要这么多数据，那必然要以来这么多服务。还有，为了前端获取数据简单，可以用facade模式，包裹一层接口。","user_name":"作者回复","comment_id":221883,"uid":"1190123","ip_address":"","utype":1,"ctime":1595207745,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"83195006992","product_id":100039001,"comment_content":"老师，下面这句话不是很理解，如果我的某个接口就是需要依赖很多服务才能把结果正确返回给前端，这时候怎么办？比如查询购物车，需要访问商品服务的商品信息，优惠服务的优惠信息，同时访问价格服务的价格信息等等，这个时候，高度耦合怎么去避免呢？<br><br><br><br>如果一个类职责很重，需要依赖十几个外部对象才能完成工作，代码高度耦合，那我们在编写单元测试的时候，可能需要 mock 这十几个依赖的对象。不管是从代码设计的角度来说，还是从编写单元测试的角度来说，这都是不合理的。","like_count":20,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496598,"discussion_content":"这个不叫高度耦合吧。不是说耦合很多就是高度耦合，也要看业务需求啊，确实要这么多数据，那必然要以来这么多服务。还有，为了前端获取数据简单，可以用facade模式，包裹一层接口。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595207745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169758,"user_name":"桂城老托尼","can_delete":false,"product_type":"c1","uid":1306032,"ip_address":"","ucode":"139E4B8EE88B79","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJcxSpNMqwqyicMvdOSr9ic0p1ABiauHnv7g7YQVSJuoHPoQbYDu3YzdpgmSAk2KricUBQ5yibWBWIq75w/132","comment_is_top":false,"comment_ctime":1578441893,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"61707984037","product_id":100039001,"comment_content":"感谢争哥分享<br>课后讨论1.id的生成逻辑有点没看懂，单纯从代码覆盖上看，fillTransactionId 未覆盖完全，需要mock下这个静态方法，当然也有其他分支逻辑可以覆盖。<br>id没有在execute方法中不是核心属性(mock方法的入参)，不影响execute的可测试性。 id的生成用静态方法真的好么？<br>2.有行为的对象不适合在类中new，尽量使用依赖注入，依赖接口编程，而不是具体的实现。 数据对象适合在类中new 比如各种model do vo info 。<br>一家之言欢迎讨论指正。","like_count":15,"discussions":[{"author":{"id":1132304,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/10/2d673601.jpg","nickname":"好饿早知道送外卖了","note":"","ucode":"AED22DB5BF8FC7","race_medal":2,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":167485,"discussion_content":"小白问个问题啊，为什么数据对象适合在类中new呢。如果测试的时候需要特定的数据？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581501985,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1306032,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJcxSpNMqwqyicMvdOSr9ic0p1ABiauHnv7g7YQVSJuoHPoQbYDu3YzdpgmSAk2KricUBQ5yibWBWIq75w/132","nickname":"桂城老托尼","note":"","ucode":"139E4B8EE88B79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1132304,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/10/2d673601.jpg","nickname":"好饿早知道送外卖了","note":"","ucode":"AED22DB5BF8FC7","race_medal":2,"user_type":1,"is_pvip":false},"discussion":{"id":168843,"discussion_content":"我的理解是数据对象对外没有行为，只是作为数据传输用途，不会对实现产生依赖。 ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581596723,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":167485,"ip_address":""},"score":168843,"extra":""}]}]},{"had_liked":false,"id":169917,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1578472448,"is_pvip":false,"replies":[{"id":"65939","content":"😁 感谢认可！","user_name":"作者回复","comment_id":169917,"uid":"1190123","ip_address":"","utype":1,"ctime":1578488789,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"53118080000","product_id":100039001,"comment_content":"看到一半，我就来评论，老师收下我的膝盖，太强了","like_count":13,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480770,"discussion_content":"😁 感谢认可！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578488789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1595863,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqk52ZrtBQ7q8DSZFfCzSdHZvDHMGjSaktUXkdWSL7sr7MFM6AicXZOnkibXkic3J5iaqN5s19RAY1suA/132","nickname":"Potar","note":"","ucode":"6983706C716CFE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342791,"discussion_content":"急性子吖","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610810907,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183919,"user_name":"Jessica","can_delete":false,"product_type":"c1","uid":1084877,"ip_address":"","ucode":"9FC7E9BD3FE9F1","user_header":"https://static001.geekbang.org/account/avatar/00/10/8d/cd/b6bdc1b2.jpg","comment_is_top":false,"comment_ctime":1583162302,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"40237867966","product_id":100039001,"comment_content":"public class Demo { <br>    public long caculateDelayDays(Date dueTime，long currentTimestamp) { <br>        if (dueTime.getTime() &gt;= currentTimestamp) { <br>            return 0; <br>        } <br>        long delayTime = currentTimestamp - dueTime.getTime(); <br>        long delayDays = delayTime &#47; 86400; return delayDays; <br>    }<br><br>    private long getCurrentTimestamp() {<br>        return System.currentTimeMillis(); <br>    }<br>}<br><br>mock掉getCurrentTimestamp（）, dueTime给定固定的时间，只检查逻辑是否符合预期","like_count":9,"discussions":[{"author":{"id":1323102,"avatar":"https://static001.geekbang.org/account/avatar/00/14/30/5e/c42bc33f.jpg","nickname":"Younger Ku","note":"","ucode":"D157DC38BDB515","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307796,"discussion_content":"getCurrentTimestamp不能用private修饰吧，按老师的做法应该用protected，同时加上VisibleForTesting注解。另外既然有了getCurrentTimestamp方法，是不是就可以不用传参currentTimestamp了，而是在caculateDelayDays方法中需要用到currentTimestamp的地方直接调用getCurrentTimestamp方法。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1600761490,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2526391,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/fcftgBsticCicEEkuzB0GTkHIocX62YVTSvnhR1c94sccj42lVaYXrmcZyhzUI3l9NcvuN1rXLhXt2eBrZZ0Tw7A/132","nickname":"idiot","note":"","ucode":"D7A6E980B530B4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541362,"discussion_content":"getCurrentTimestamp ok的，改的内部实现方法。改参数不合适，不应该为了可测试性改对外接口。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640341189,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2869991,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/ca/e7/454f7f0e.jpg","nickname":"BUG始终快我一步","note":"","ucode":"230981531A30E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539474,"discussion_content":"纯纯小小白  感觉那个demo 有重复的地方,好像和之前的DRY原则冲突 这个样子是不是好一点?  还有 正常项目中 三目用的多吗?\npublic long caculateDelayDays1(Date dueTime) {\n        long currentTimestamp = System.currentTimeMillis();\n        return currentTimestamp &gt; dueTime.getTime() ? (currentTimestamp - dueTime.getTime()) / 86400 : 0;\n    }\n个人理解 ,本身就是为了设定延迟时间,那么获取当前时间是不是本身就应该在测试的范围之内呢?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639726167,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173254,"user_name":"小伟","can_delete":false,"product_type":"c1","uid":1359701,"ip_address":"","ucode":"124953423491E2","user_header":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","comment_is_top":false,"comment_ctime":1579487383,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35939225751","product_id":100039001,"comment_content":"思考题：<br>1. 看IdGenerator怎么实现，如果要查数据库或分布式服务，那么会有影响，需要mock；如果是本地生产，不需要mock。<br>2. 个人观点，不要在方法里new对象，依赖都要以注入的方式获取。","like_count":9},{"had_liked":false,"id":169811,"user_name":"Jesse","can_delete":false,"product_type":"c1","uid":1368038,"ip_address":"","ucode":"727CA882B84DA0","user_header":"https://static001.geekbang.org/account/avatar/00/14/df/e6/bd1b3c0b.jpg","comment_is_top":false,"comment_ctime":1578450183,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"35938188551","product_id":100039001,"comment_content":"思考题1，该方法产生一个唯一的ID,我认为不需要mock。<br>思考题2，我觉得如果对象有行为，并且行为与外部系统交互或者执行的结果具有不确定性，就需要依赖注入来完成测试。如果对象的行为是可预测的并且唯一的，可以直接new。","like_count":9},{"had_liked":false,"id":169875,"user_name":"逍遥思","can_delete":false,"product_type":"c1","uid":1015512,"ip_address":"","ucode":"340F05C786730F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/d8/92a98fb6.jpg","comment_is_top":false,"comment_ctime":1578467085,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27348270861","product_id":100039001,"comment_content":"1. 不会影响可测试性，因为 generateTransactionId 并不需要依赖什么外部服务，所以也不需要 mock<br>2. 不是。不依赖外部服务的类就可以内部创建，比如 String","like_count":6},{"had_liked":false,"id":227552,"user_name":"Vincent.X","can_delete":false,"product_type":"c1","uid":1538604,"ip_address":"","ucode":"8A40B5B2F4B102","user_header":"https://static001.geekbang.org/account/avatar/00/17/7a/2c/54b48459.jpg","comment_is_top":false,"comment_ctime":1592406872,"is_pvip":false,"replies":[{"id":"83993","content":"只能@一下编辑了","user_name":"作者回复","comment_id":227552,"uid":"1190123","ip_address":"","utype":1,"ctime":1592525525,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"23067243352","product_id":100039001,"comment_content":"手机看代码有老是要拖动，有什么解决的办法吗？？","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498681,"discussion_content":"只能@一下编辑了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592525525,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169938,"user_name":"下雨天","can_delete":false,"product_type":"c1","uid":1008315,"ip_address":"","ucode":"816B3792ECC50A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/62/bb/323a3133.jpg","comment_is_top":false,"comment_ctime":1578477594,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18758346778","product_id":100039001,"comment_content":"问题回答：<br>1. IdGenerator.generateTransactionId()有未决行为逻辑，但不是说有未决行为就一定影响可测试性，前提是需要看未决行为是否有测试必要性，此处生成一个随机数(类似 System.currentTimeMillis())，测试意义不大！<br><br>2.贫血模型实体类","like_count":4},{"had_liked":false,"id":169800,"user_name":"美美","can_delete":false,"product_type":"c1","uid":1148422,"ip_address":"","ucode":"44CC95C45AF345","user_header":"https://static001.geekbang.org/account/avatar/00/11/86/06/72b01bb7.jpg","comment_is_top":false,"comment_ctime":1578447997,"is_pvip":false,"replies":[{"id":"65942","content":"可以借助springtest测试框架来做","user_name":"作者回复","comment_id":169800,"uid":"1190123","ip_address":"","utype":1,"ctime":1578488960,"user_name_real":"王争"}],"discussion_count":4,"race_medal":0,"score":"18758317181","product_id":100039001,"comment_content":"有多个通过spring注入的类时，应该怎么做测试呢？","like_count":4,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480724,"discussion_content":"可以借助springtest测试框架来做","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578488960,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":143015,"discussion_content":"mockito+jmockit，mock界的super star","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1579487662,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1103189,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d5/55/ce3f814f.jpg","nickname":"莴笋","note":"","ucode":"2B9650104285AD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":124852,"discussion_content":"用Mockito","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578453784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1109844,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ef/54/58a61a50.jpg","nickname":"룡걸이","note":"","ucode":"ACC366BD4E7385","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":124810,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578451577,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":256924,"user_name":"郑大钱","can_delete":false,"product_type":"c1","uid":1503067,"ip_address":"","ucode":"114CF48056880E","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/5b/ff28088f.jpg","comment_is_top":false,"comment_ctime":1603784929,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14488686817","product_id":100039001,"comment_content":"作为一个码农，职责是在有限时间里，完成尽可能多的、高可维护性、高扩展性的、高可靠性的代码。<br>这么多好代码评判标准里面，我认为可靠性是最不能妥协的。<br>时间可以商量，任务可以分工，维护性可以加班来搞，扩展性可以后期优化。唯有代码的可靠性，需要整个业务团队来承担它带来的影响。<br>郑大钱想挣更多钱<br>可以因为能写高质量的代码要到更高的工资<br>可以通过优化代码的可靠性来提升代码的质量<br>可以通过单元测试来提升代码的可靠性<br>单元测试覆盖率，是一个可以量化的指标，是一个可以集中资源优化的点，是一个挣大钱的好战略。<br>（好的战略 = 一个清晰的目标 + 可以集中资源优化的点 ——《好战略，坏战略》）","like_count":3,"discussions":[{"author":{"id":2061547,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/74/eb/791d0f5e.jpg","nickname":"拿了橘子跑哇","note":"","ucode":"D7A281AE06DDF3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":566465,"discussion_content":"朴实无华！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650697229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173362,"user_name":"相逢是缘","can_delete":false,"product_type":"c1","uid":1060730,"ip_address":"","ucode":"CB299F53A95654","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg","comment_is_top":false,"comment_ctime":1579511091,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14464412979","product_id":100039001,"comment_content":"打卡<br>1、什么是代码可测试性：<br>针对代码编写单元测试的难易程度。如果编写单元测试很难，意味着代码设计不够合理，代码的可测试性不好。<br><br>2、如何编写可测试性的代码<br>1、通过依赖注入，我们在编写单元测试的时候，可以通过 mock 的方法解依赖外部服务<br>2、依赖外部单例：将单例封装<br>3、未决行为：例时间、随机数。将未决行为重新封装，测试时mock。<br><br>3、常见的测试不友好的代码有下面这 5 种：<br>1、代码中包含未决行为逻辑<br>2、滥用可变全局变量<br>3、滥用静态方法<br>4、使用复杂的继承关系<br>5、高度耦合的代码","like_count":3},{"had_liked":false,"id":173241,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1579483991,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14464385879","product_id":100039001,"comment_content":"不依赖框架的类，都可以手动new，比如Person对象，可以内部new，而像Spring的Service、Repository、Controller这些依赖框架的，需要用到依赖注入","like_count":3},{"had_liked":false,"id":170342,"user_name":"达文西","can_delete":false,"product_type":"c1","uid":1398824,"ip_address":"","ucode":"01C1063F23D634","user_header":"https://static001.geekbang.org/account/avatar/00/15/58/28/c86340ca.jpg","comment_is_top":false,"comment_ctime":1578574692,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14463476580","product_id":100039001,"comment_content":"内容都是干货,不够看啊","like_count":3},{"had_liked":false,"id":169853,"user_name":"平风造雨","can_delete":false,"product_type":"c1","uid":1014349,"ip_address":"","ucode":"F9EE4704F31E22","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/4d/b0228a1a.jpg","comment_is_top":false,"comment_ctime":1578458702,"is_pvip":true,"discussion_count":3,"race_medal":0,"score":"14463360590","product_id":100039001,"comment_content":"&#47;&#47; 抽取了当前时间获取的逻辑，方便测试<br>    private long currentTimeMillis;<br>    private Date dueTime;<br>    public Demo(Date dueTime){<br>        this.dueTime = dueTime;<br>        this.currentTimeMillis = getCurrentTimeMillis();<br>    }<br><br>    protected long getCurrentTimeMillis(){<br>        return System.currentTimeMillis();<br>    }<br>    public long caculateDelayDays() {<br>        if(dueTime.getTime() &gt;= currentTimeMillis){<br>            return 0;<br>        }<br>        long delayTime = currentTimeMillis - dueTime.getTime();<br>        long delayDays = delayTime &#47; 86400_000;<br>        return delayDays;<br>    }<br>    @Test<br>    public void testCaculateDelayDays(){<br>        TimeZone timeZone = TimeZone.getTimeZone(&quot;Asia&#47;ShangHai&quot;);<br>        Calendar calendar = Calendar.getInstance(timeZone);<br>        calendar.clear();<br>        calendar.set(2020, Calendar.FEBRUARY,1,0,0,0);<br>        Date dueTime = calendar.getTime();<br>        Demo demo = new DemoClassOne(dueTime);<br>        Assert.assertEquals(demo.caculateDelayDays(), 0);<br>        calendar.clear();<br>        calendar.set(2019, Calendar.DECEMBER, 31, 0,0,0);<br>        dueTime = calendar.getTime();<br>        demo = new DemoClassOne(dueTime);<br>        Assert.assertEquals(demo.caculateDelayDays(), 1);<br>    }<br><br>    public static class DemoClassOne extends Demo {<br>        public DemoClassOne(Date dueTime) {<br>            super(dueTime);<br>        }<br>        @Override<br>        protected long getCurrentTimeMillis() {<br>            TimeZone timeZone = TimeZone.getTimeZone(&quot;Asia&#47;ShangHai&quot;);<br>            Calendar calendar = Calendar.getInstance(timeZone);<br>            calendar.clear();<br>            calendar.set(2020, Calendar.JANUARY,1,0,0,0);<br>            return calendar.getTimeInMillis();<br>        }<br>    }","like_count":3,"discussions":[{"author":{"id":1901146,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK28icgzo9R0rXE5s4nIjdme2VLRLbFtcaiaibaOEEFewnoIgco4sUXhibiabDvRbGN5NOZdcEBvFvytow/132","nickname":"phpCoder","note":"","ucode":"963C378BDBF49B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261991,"discussion_content":"我觉得这样是不是为了测试而设计了 感觉怪怪的🤨","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589030972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1714287,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/28/6f/e430eaaa.jpg","nickname":"平行线","note":"","ucode":"033F8BA2D1470E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1901146,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK28icgzo9R0rXE5s4nIjdme2VLRLbFtcaiaibaOEEFewnoIgco4sUXhibiabDvRbGN5NOZdcEBvFvytow/132","nickname":"phpCoder","note":"","ucode":"963C378BDBF49B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308635,"discussion_content":"我也感觉怪怪的，像是自己在骗自己一样，  争哥例子中的isExpired函数，为了单侧直接返回true, 总感觉哪里不对呢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601014608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":261991,"ip_address":""},"score":308635,"extra":""}]},{"author":{"id":1254656,"avatar":"https://static001.geekbang.org/account/avatar/00/13/25/00/3afbab43.jpg","nickname":"88591","note":"","ucode":"04CE3E46455185","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206682,"discussion_content":"我觉得可以简单点，用两入参（两个时间）就可以。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584426981,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":271493,"user_name":"Better me","can_delete":false,"product_type":"c1","uid":1261959,"ip_address":"","ucode":"CADF08D357489A","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","comment_is_top":false,"comment_ctime":1609665807,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10199600399","product_id":100039001,"comment_content":"思考题1，IdGenerator.generateTransactionId()是一个静态方法，根据老师文中所说的，如果只是类似 Math.abs() 这样的简单静态方法，并不会影响代码的可测试性，因为本身并不需要 mock。所以我们需要鉴别IdGenerator.generateTransactionId()本身是否有其他依赖，如果是依赖其他服务（数据库等）的全局发号器则有必要Mock<br><br>思考题2，依赖注入，就是不要在类内部通过 new 的方式创建对象，而是要通过外部创建好之后传递给类使用。根据面向接口而非实现的编程原则，当我们要做单元测试的类依赖了外部服务接口的具体实现时，可以由外部传入实现类并Mock相关函数返回值。而与具体行为无关的数据对象可通过new 的方式创建对象，即被测试类函数逻辑并不是强依赖外部类实现这种","like_count":2},{"had_liked":false,"id":183865,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1583149524,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10173084116","product_id":100039001,"comment_content":"思考题1不会有影响，因为这个id只是一个值而已，对逻辑判断，测试场景没有影响","like_count":2},{"had_liked":false,"id":183207,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1582972607,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10172907199","product_id":100039001,"comment_content":"回答一下提问2：<br>我认为对象生命周期都被类包含的时候，可以在类内部通过new构建，而且不影响测试。<br><br>譬如一个集合类，内置了一个List，这个List的活动范围仅限于这个集合类，任何方法都不会发布这个对象出去，那么这List的对象可以在集合初始化的时候通过new进行构造。","like_count":2},{"had_liked":false,"id":314234,"user_name":"慕言","can_delete":false,"product_type":"c1","uid":2731028,"ip_address":"","ucode":"4918FA682F3895","user_header":"https://static001.geekbang.org/account/avatar/00/29/ac/14/a8ff8fec.jpg","comment_is_top":false,"comment_ctime":1632907972,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5927875268","product_id":100039001,"comment_content":"我针对案例中4、5、6三个测试用例编写的测试代码：<br>public class TransactionTest {<br>    @Test<br>    public void testExecute_with_TransactionExecuted() throws InvalidTransactionException {<br>        Transaction t = new Transaction(null, 123L, 234L, 345L, &quot;567&quot;, (double)89) {<br>            @Override<br>            protected boolean isExecuted() {<br>                return true;<br>            }<br>        };<br>        WalletRpcService wallet = new WalletRpcService();<br>        t.setWalletRpcService(wallet);<br>        TransactionLock lock = new TransactionLock();<br>        t.setTransactionLock(lock);<br>        boolean result = t.execute();<br>        Assert.assertTrue(result);<br>    }<br><br>    @Test<br>    public void testExecute_with_TransactionMoveFailed() throws InvalidTransactionException {<br>        Transaction t = new Transaction(null, 123L, 234L, 345L, &quot;567&quot;, (double)89);<br>        WalletRpcService wallet = new WalletRpcService() {<br>            @Override<br>            public String moveMoney(String id, Long buyerId, Long sellerId, Double amount) {<br>                return null;<br>            }<br>        };<br>        t.setWalletRpcService(wallet);<br>        TransactionLock lock = new TransactionLock();<br>        t.setTransactionLock(lock);<br>        boolean result = t.execute();<br>        Assert.assertFalse(result);<br>        Assert.assertEquals(Status.FAILED, t.getStatus());<br>    }<br><br>    @Test<br>    public void testExecute_with_TransactionExecuting() throws InvalidTransactionException {<br>        Transaction t = new Transaction(null, 123L, 234L, 345L, &quot;567&quot;, (double)89);<br>        WalletRpcService wallet = new WalletRpcService();<br>        t.setWalletRpcService(wallet);<br>        TransactionLock lock = new TransactionLock() {<br>            @Override<br>            public boolean lock(String id) {<br>                return false;<br>            }<br>        };<br>        t.setTransactionLock(lock);<br>        boolean result = t.execute();<br>        Assert.assertFalse(result);<br>    }<br>}","like_count":1},{"had_liked":false,"id":270641,"user_name":"JRich","can_delete":false,"product_type":"c1","uid":1114901,"ip_address":"","ucode":"66AE9D61533960","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/15/293a185d.jpg","comment_is_top":false,"comment_ctime":1609203500,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5904170796","product_id":100039001,"comment_content":"如果依赖注入是用spring的autowire注解，没有setter方法，该怎么去用mock对象替换呢","like_count":1,"discussions":[{"author":{"id":1095136,"avatar":"https://static001.geekbang.org/account/avatar/00/10/b5/e0/fc3ac264.jpg","nickname":"stronger.","note":"","ucode":"AD0F2BE338824C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408808,"discussion_content":"spring建议通过构造器注入，而不是属性注入","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1635326562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2588697,"avatar":"https://static001.geekbang.org/account/avatar/00/27/80/19/ac06db0b.jpg","nickname":"New","note":"","ucode":"406DF65BD05FAA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372893,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620490470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184421,"user_name":"xk_","can_delete":false,"product_type":"c1","uid":1514305,"ip_address":"","ucode":"DFE1AC38EA78A7","user_header":"https://static001.geekbang.org/account/avatar/00/17/1b/41/dbb7d785.jpg","comment_is_top":false,"comment_ctime":1583311840,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5878279136","product_id":100039001,"comment_content":"我有用过mock框架，也写过很多复杂的单元测试。现在测试框架好强大，各种mock，静态方法，代码中注入自定义对象…<br>说一下我对思考题的看法：<br>1.生成id不用覆盖，因为没有测试的点。如果硬要测试的话要单独测试这个方法，不过要写生成这个方法的单元测试可能会非常复杂。越简单的，基础的方法越难测。<br>2.如果没有争哥说的那五种情况，其实在哪里创建对象都好测试，最难测的五种情况都在文章中了。","like_count":1},{"had_liked":false,"id":173126,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1579428727,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5874396023","product_id":100039001,"comment_content":"IdGenerator.generateTransactionId()本身就是产生随机数的，对测试流程不影响","like_count":1},{"had_liked":false,"id":171373,"user_name":"Walker Jiang","can_delete":false,"product_type":"c1","uid":1023818,"ip_address":"","ucode":"92AE855D428917","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9f/4a/f5b8c6b3.jpg","comment_is_top":false,"comment_ctime":1578911540,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5873878836","product_id":100039001,"comment_content":"收获很多，要是文章结尾有个完整代码就更好了，不然现在还得一点点去复制才能看到全貌。","like_count":1},{"had_liked":false,"id":170841,"user_name":"饭粒","can_delete":false,"product_type":"c1","uid":1153455,"ip_address":"","ucode":"4C3220B0D43997","user_header":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","comment_is_top":false,"comment_ctime":1578737956,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5873705252","product_id":100039001,"comment_content":"读完这篇感觉一下就认识了代码的可测试性。依赖注入提高代码的可测试性，那 spring 里推荐使用 setter 方法形式的 @autowired 注入 bean 更好哎。<br>然后我认为 IdGenerator.generateTransactionId() 不需要 mock，它的功能应该就是生成一个全局唯一的 id，对 Transaction   而言功能简单，不影响测试性，本身的实现逻辑不在 Transaction  测试。","like_count":1},{"had_liked":false,"id":170533,"user_name":"石仔","can_delete":false,"product_type":"c1","uid":1177921,"ip_address":"","ucode":"974E4604CE2213","user_header":"https://static001.geekbang.org/account/avatar/00/11/f9/41/411b1753.jpg","comment_is_top":false,"comment_ctime":1578627542,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5873594838","product_id":100039001,"comment_content":"继续优化Demo:<br>public class Demo {<br>    private long currentTimestamp;<br>    private long dueTimestamp;<br>    private long delayDays;<br><br>    public Demo(long currentTimestamp, long dueTimestamp) {<br>        this.currentTimestamp = currentTimestamp;<br>        this.dueTimestamp = dueTimestamp;<br>        this.delayDays = (this.currentTimestamp - this.dueTimestamp) &#47; 86400;<br>    }<br><br>    &#47;**<br>     * 计算延迟天数<br>     *<br>     * @return<br>     *&#47;<br>    public long caculateDelayDays() {<br>        if (!isDelayDays()) {<br>            return 0;<br>        }<br>        return delayDays;<br>    }<br><br>    &#47;**<br>     * 是否延迟<br>     *<br>     * @return<br>     *&#47;<br>    public boolean isDelayDays() {<br>        if (this.delayDays &lt;= 0) {<br>            return false;<br>        }<br>        return true;<br>    }<br>}","like_count":1},{"had_liked":false,"id":169988,"user_name":"再见孙悟空","can_delete":false,"product_type":"c1","uid":1025518,"ip_address":"","ucode":"57E12A2F9CD915","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a5/ee/6bbac848.jpg","comment_is_top":false,"comment_ctime":1578489306,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5873456602","product_id":100039001,"comment_content":"今天老师讲的为了更好的单元测试而进行的重构，原来工作中无形间已经用到了。在对接三方 api 时，有时候缺少必要的参数信息，我们只能模拟调通，这时候我们就写一个类继承原始类，重写原方法，返回自己需要的数据，不过还有很多做的不足，例如对于不确定数据的mock 没有抽成方法等，持续学习，老师棒！","like_count":1},{"had_liked":false,"id":169793,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1578447537,"is_pvip":false,"replies":[{"id":"65943","content":"”代码结构扁平化的极端结果“能举个例子吗？","user_name":"作者回复","comment_id":169793,"uid":"1190123","ip_address":"","utype":1,"ctime":1578489044,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"5873414833","product_id":100039001,"comment_content":"想到一个问题，代码结构扁平化的极端结果可能会造成依赖对象过多吗？这种情况mock不是依然难搞吗","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480722,"discussion_content":"”代码结构扁平化的极端结果“能举个例子吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578489044,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1444122,"avatar":"https://static001.geekbang.org/account/avatar/00/16/09/1a/e0f95684.jpg","nickname":"空空","note":"","ucode":"8F6EFE5A6F6F64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":173281,"discussion_content":"如果极端扁平，我的理解会出现fan-out 问题，所以组合和继承的使用还是要视场景而定","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581843917,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":337585,"user_name":"千锤百炼领悟之极限","can_delete":false,"product_type":"c1","uid":1744257,"ip_address":"","ucode":"224B5CF2101716","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9d/81/d748b7eb.jpg","comment_is_top":false,"comment_ctime":1646904126,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646904126","product_id":100039001,"comment_content":"重构之后的fillTransactionId函数，返回id不是更好吗，而不是在函数内部赋值给this.id<br><br>例如:<br>  public Transaction(String preAssignedId, Long buyerId, Long sellerId, Long productId, String orderId) {<br>    &#47;&#47;...<br>    this.id = fillTransactionId(preAssignId);<br>    &#47;&#47;...<br>  }<br>  <br>  protected void fillTransactionId(String preAssignedId) {<br>    if (preAssignedId != null &amp;&amp; !preAssignedId.isEmpty()) {<br>      id = preAssignedId;<br>    } else {<br>      id = IdGenerator.generateTransactionId();<br>    }<br>    if (!id.startWith(&quot;t_&quot;)) {<br>      id = &quot;t_&quot; + preAssignedId;<br>    }<br>    return id;<br>  }","like_count":0},{"had_liked":false,"id":330936,"user_name":"你好旅行者","can_delete":false,"product_type":"c1","uid":1154101,"ip_address":"","ucode":"5C72A428DC28F3","user_header":"https://static001.geekbang.org/account/avatar/00/11/9c/35/9dc79371.jpg","comment_is_top":false,"comment_ctime":1642312961,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642312961","product_id":100039001,"comment_content":"关于第二个问题，谜底就在谜面上，不影响代码可测试性的类就可以在类的内部创建。","like_count":0},{"had_liked":false,"id":324222,"user_name":"友","can_delete":false,"product_type":"c1","uid":2536820,"ip_address":"","ucode":"972A4333A8B101","user_header":"https://static001.geekbang.org/account/avatar/00/26/b5/74/cd80b9f4.jpg","comment_is_top":false,"comment_ctime":1638343339,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638343339","product_id":100039001,"comment_content":"关于测试 status的代码 可以想 time一样处理。测试交易中的代码 由于我用的是go  我会开一个协程去模拟","like_count":0},{"had_liked":false,"id":315307,"user_name":"charmsongo","can_delete":false,"product_type":"c1","uid":1609051,"ip_address":"","ucode":"4FBEE716E93A1A","user_header":"https://static001.geekbang.org/account/avatar/00/18/8d/5b/383a49e4.jpg","comment_is_top":false,"comment_ctime":1633824470,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633824470","product_id":100039001,"comment_content":"外部依赖注入可以提高代码的可测试性，尽量少用未决代码、全局变量、静态变量、复杂的集成、耦合度高的代码","like_count":0},{"had_liked":false,"id":303078,"user_name":"布拉姆","can_delete":false,"product_type":"c1","uid":1311125,"ip_address":"","ucode":"479FF27D73BCAD","user_header":"https://static001.geekbang.org/account/avatar/00/14/01/95/fd09e8a8.jpg","comment_is_top":false,"comment_ctime":1626579764,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626579764","product_id":100039001,"comment_content":"不依赖外部服务的类就可以内部创建，比如 String","like_count":1},{"had_liked":false,"id":297549,"user_name":"江南一笑","can_delete":false,"product_type":"c1","uid":2234620,"ip_address":"","ucode":"E38938A1178827","user_header":"https://static001.geekbang.org/account/avatar/00/22/18/fc/4f92ee4e.jpg","comment_is_top":false,"comment_ctime":1623619037,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623619037","product_id":100039001,"comment_content":"一个疑问：修改前，Transaction的调用者不需要知道 WalletRpcService， 就可以直接调用Transaction，更符合 least knowledge 原则。现在为了提高可测试性，调用者需要先创建 WalletRpcService 对象，再通过依赖注入的方式调用 Transaction对象。这样对 Transaction的调用者是否友好？","like_count":0},{"had_liked":false,"id":296919,"user_name":"编号","can_delete":false,"product_type":"c1","uid":1037836,"ip_address":"","ucode":"1633A363592A1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d6/0c/df0d5152.jpg","comment_is_top":false,"comment_ctime":1623224706,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623224706","product_id":100039001,"comment_content":"争哥，private static AtomicInteger position = new AtomicInteger(0)这种静态全局变量要怎么测试呢，或者代码要怎么重构啊","like_count":0},{"had_liked":false,"id":296539,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1623034440,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1623034440","product_id":100039001,"comment_content":"干货","like_count":0},{"had_liked":false,"id":292451,"user_name":"JKwar","can_delete":false,"product_type":"c1","uid":1047466,"ip_address":"","ucode":"B733CA24D5701F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/aa/01fedf6c.jpg","comment_is_top":false,"comment_ctime":1620827157,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1620827157","product_id":100039001,"comment_content":"思考题1：不会。void fillTransactionId(String preAssignedId) 函数本身就是一个id生成器，如果传入的id为空，就通过 IdGenerator.generateTransactionId() 生成一个id。<br>思考题2：不依赖外部服务的类，提供方法的类可以 new，比如说 Service 类就可以在内部创建并且不影响代码的可测试性","like_count":0},{"had_liked":false,"id":289060,"user_name":"偏执","can_delete":false,"product_type":"c1","uid":1304576,"ip_address":"","ucode":"B397172D654C92","user_header":"https://static001.geekbang.org/account/avatar/00/13/e8/00/f94bb1c5.jpg","comment_is_top":false,"comment_ctime":1618836600,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618836600","product_id":100039001,"comment_content":"有一个疑惑，静态方法mock难在哪里？ <br>1. Java里PowerMock提供了静态方法的mock方式。<br>2. Python里可以使用mock.patch(&#39;your.package.module.Classs.func&#39;)的方式mock<br>可以提供一个实例说明static方法的难处在哪里吗？<br>","like_count":0},{"had_liked":false,"id":288501,"user_name":"JoeyforJoy","can_delete":false,"product_type":"c1","uid":1466467,"ip_address":"","ucode":"5598501E71D35D","user_header":"https://static001.geekbang.org/account/avatar/00/16/60/63/d2c91e2b.jpg","comment_is_top":false,"comment_ctime":1618493728,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618493728","product_id":100039001,"comment_content":"依赖注入是提高代码可测试性的有效手段。具体例子可以参考mock的实现","like_count":0},{"had_liked":false,"id":287236,"user_name":"Spoon","can_delete":false,"product_type":"c1","uid":1959822,"ip_address":"","ucode":"2FF9193AD482C2","user_header":"https://static001.geekbang.org/account/avatar/00/1d/e7/8e/318cfde0.jpg","comment_is_top":false,"comment_ctime":1617850812,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617850812","product_id":100039001,"comment_content":"真的是收获满满","like_count":0},{"had_liked":false,"id":285872,"user_name":"Geek_86eac6","can_delete":false,"product_type":"c1","uid":1787022,"ip_address":"","ucode":"8C02E398CC6A35","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI4CBQHuLDWOdicOl1elTdSicqMyY1s5JDWXiaHsSk0VSWaVe0U6CTo701ZGz9h6MvibsAGKnvVq7xxFw/132","comment_is_top":false,"comment_ctime":1617061941,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617061941","product_id":100039001,"comment_content":"题目1，这段代码不影响整体逻辑，所以不需要mock","like_count":0},{"had_liked":false,"id":270989,"user_name":"隆隆.ago","can_delete":false,"product_type":"c1","uid":1710528,"ip_address":"","ucode":"9EFE43F0A2C6BB","user_header":"https://static001.geekbang.org/account/avatar/00/1a/19/c0/693b946f.jpg","comment_is_top":false,"comment_ctime":1609340050,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609340050","product_id":100039001,"comment_content":"1. ID生成器本身很简单，不需要mock。测试fillTransactionId功能已经很简单了，造一个id传进去或者一个空id传进去测试，不需要再mock生成ID。<br>2. 很确定而简单的，不依赖外部的服务可以new。提供特定属性的model这些可以new。比如封装各种ID的一个贫血数据类","like_count":0},{"had_liked":false,"id":266227,"user_name":"突围","can_delete":false,"product_type":"c1","uid":1090414,"ip_address":"","ucode":"03E865CC8A6F2A","user_header":"https://static001.geekbang.org/account/avatar/00/10/a3/6e/52580973.jpg","comment_is_top":false,"comment_ctime":1607246333,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607246333","product_id":100039001,"comment_content":"单元测试太难推了，我们公司项目单测覆盖率能到达30%就不错了","like_count":0},{"had_liked":false,"id":265912,"user_name":"狼行天下","can_delete":false,"product_type":"c1","uid":1053161,"ip_address":"","ucode":"A3F22B276B88B1","user_header":"https://static001.geekbang.org/account/avatar/00/10/11/e9/13f28df2.jpg","comment_is_top":false,"comment_ctime":1607067239,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607067239","product_id":100039001,"comment_content":"思考题1：看该方法是否有依赖其它组件，如果是本机生成算法，可以不用mock；<br>思考题2：model对象可以不用外部传入；","like_count":0},{"had_liked":false,"id":254938,"user_name":"erDuo","can_delete":false,"product_type":"c1","uid":1016135,"ip_address":"","ucode":"691E716E6D0E39","user_header":"https://static001.geekbang.org/account/avatar/00/0f/81/47/e5b206d9.jpg","comment_is_top":false,"comment_ctime":1603237897,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603237897","product_id":100039001,"comment_content":"大赞，马上回去重构","like_count":0},{"had_liked":false,"id":250607,"user_name":"一尾","can_delete":false,"product_type":"c1","uid":1517556,"ip_address":"","ucode":"67D404036231D1","user_header":"https://static001.geekbang.org/account/avatar/00/17/27/f4/a1ce6248.jpg","comment_is_top":false,"comment_ctime":1601169921,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601169921","product_id":100039001,"comment_content":"感谢，这节课都是干货","like_count":0},{"had_liked":false,"id":250013,"user_name":"David","can_delete":false,"product_type":"c1","uid":1021825,"ip_address":"","ucode":"22CBBC13FC97A9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/97/81/e1eaf621.jpg","comment_is_top":false,"comment_ctime":1600905491,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1600905491","product_id":100039001,"comment_content":"1. id生成逻辑简单 我认为不用mock<br>2. 注入优于new","like_count":0},{"had_liked":false,"id":249688,"user_name":"Younger Ku","can_delete":false,"product_type":"c1","uid":1323102,"ip_address":"","ucode":"D157DC38BDB515","user_header":"https://static001.geekbang.org/account/avatar/00/14/30/5e/c42bc33f.jpg","comment_is_top":false,"comment_ctime":1600762086,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600762086","product_id":100039001,"comment_content":"1、IdGenerator.generateTransactionId()只是一个生成交易ID的静态方法，如果需要依赖外部系统或者不可控组件就需要单独mock。如果仅仅是生成一个随机字符串则不需要mock。当然，如果交易ID有预设的生成规则，可能也需要单独对生成规则进行测试。<br>2、如果要用到的类中的方法不会产生未决行为、并且没有依赖外部系统及不可控组件，对单元测试没有影响，那么就可以直接new出来。","like_count":0},{"had_liked":false,"id":247316,"user_name":"JerryZhu","can_delete":false,"product_type":"c1","uid":1591223,"ip_address":"","ucode":"76850CD45786C1","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","comment_is_top":false,"comment_ctime":1599657634,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599657634","product_id":100039001,"comment_content":"真是写了6年的代码。。 很少写单元测试， 惭愧至极了","like_count":1},{"had_liked":false,"id":246758,"user_name":"宇天飞","can_delete":false,"product_type":"c1","uid":1126444,"ip_address":"","ucode":"3FB37D1E2DAA61","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/2c/06375913.jpg","comment_is_top":false,"comment_ctime":1599470858,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1599470858","product_id":100039001,"comment_content":"问题1：<br>1、不会影响。函数比较简单，很快返回，不会有太多依赖<br>问题2：<br>1、非业务逻辑上的对象可以新建，不影响业务逻辑走向的","like_count":0},{"had_liked":false,"id":245616,"user_name":"大雁小鱼","can_delete":false,"product_type":"c1","uid":1101017,"ip_address":"","ucode":"44090581E59FDA","user_header":"https://static001.geekbang.org/account/avatar/00/10/cc/d9/20d4f7c2.jpg","comment_is_top":false,"comment_ctime":1599009514,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599009514","product_id":100039001,"comment_content":"我：这段代码不太好写单元测试不好，需要重写。<br>别人：你有病吧，是你自己能力不行，不会写单元测试吧。<br>我：……","like_count":0},{"had_liked":false,"id":244580,"user_name":"蛀牙","can_delete":false,"product_type":"c1","uid":1153349,"ip_address":"","ucode":"F765A67DFEADFD","user_header":"","comment_is_top":false,"comment_ctime":1598585428,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598585428","product_id":100039001,"comment_content":"思考题1： 我觉得需要重写，因为在unit test里也需要验证id是否被正确的fill了，一个deterministic的id generator 会方便test验证","like_count":0},{"had_liked":false,"id":244192,"user_name":"Mew151","can_delete":false,"product_type":"c1","uid":1002201,"ip_address":"","ucode":"D4793F5874F345","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/d9/75dd7cf9.jpg","comment_is_top":false,"comment_ctime":1598423602,"is_pvip":false,"replies":[{"id":"90138","content":"你指的处理什么呢？","user_name":"作者回复","comment_id":244192,"uid":"1190123","ip_address":"","utype":1,"ctime":1598834236,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"1598423602","product_id":100039001,"comment_content":"有一个问题，如果测试方法A()中调用了本类的私有方法B()，这个时候该怎么处理呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504514,"discussion_content":"你指的处理什么呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598834236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":233946,"user_name":"可爱的饲养员","can_delete":false,"product_type":"c1","uid":1160213,"ip_address":"","ucode":"A5B6A4A4110E0C","user_header":"https://static001.geekbang.org/account/avatar/00/11/b4/15/2e6716d7.jpg","comment_is_top":false,"comment_ctime":1594526872,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594526872","product_id":100039001,"comment_content":"思考题1：看IdGenerator.generateTransactionId()的生成逻辑，分布式系统避免ID重复都会查库，如果这样的话就要mock。<br>思考题2：实现业务逻辑的要注入，做数据载体的POJO要new","like_count":0},{"had_liked":false,"id":232356,"user_name":"大方方","can_delete":false,"product_type":"c1","uid":1354013,"ip_address":"","ucode":"621AD8F1485753","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/6cyOoRd2dROgiblAJkW6RLhUyH1wwU0NNibIIuV930eQ9TiaNT41K61kBSVkvYoDYg7mJtuEoCQY1awBmV0WW6BFg/132","comment_is_top":false,"comment_ctime":1593964894,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593964894","product_id":100039001,"comment_content":"这节是真干货， 完整的把前面讲过的设计模式和单元测试理论在实践中正向激励循环展示出来了，而且确实学到了实用技巧，能够应用到自己的代码重构中，很实用，谢谢。","like_count":0},{"had_liked":false,"id":230650,"user_name":"克尔苏加德","can_delete":false,"product_type":"c1","uid":1459388,"ip_address":"","ucode":"E35A6DFA012F37","user_header":"https://static001.geekbang.org/account/avatar/00/16/44/bc/0bb265a7.jpg","comment_is_top":false,"comment_ctime":1593440276,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593440276","product_id":100039001,"comment_content":"受益良多","like_count":0},{"had_liked":false,"id":230599,"user_name":"YsnowLove","can_delete":false,"product_type":"c1","uid":1439301,"ip_address":"","ucode":"70433D98592481","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/rMgAbbKiasa1qR35ht0GEfwsHXbusPZAe9JFgicDgVRy8vQET2hypuDgwtHoPVU23RUoMdK7qA7gibMlTExpYibtbw/132","comment_is_top":false,"comment_ctime":1593426261,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593426261","product_id":100039001,"comment_content":"总感觉execute方法并发的时候出现多转钱的问题，分布式锁，锁住的是transactionId，而transactionId有可能是在execute方法生成的。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496959,"discussion_content":"https://github.com/wangzheng0822","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592527347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238185,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/a9/117fe480.jpg","nickname":"我的心里只有工作","note":"","ucode":"488DD6F9590EB8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291660,"discussion_content":"手机端不让复制粘贴？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594901795,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1113744,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fe/90/19ef108d.jpg","nickname":"techwro","note":"","ucode":"7AF2B319F0AE1B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278978,"discussion_content":"https://time.geekbang.org/column/article/80388","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591266833,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1045078,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f2/56/c39046c0.jpg","nickname":"Jie","note":"","ucode":"AB94041E548FEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":277139,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591005431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":276961,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590975281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":226077,"user_name":"benxiong","can_delete":false,"product_type":"c1","uid":1624574,"ip_address":"","ucode":"F6498059D439D9","user_header":"https://static001.geekbang.org/account/avatar/00/18/c9/fe/874b172b.jpg","comment_is_top":false,"comment_ctime":1591947212,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591947212","product_id":100039001,"comment_content":"public class Demo { <br>    public long caculateDelayDays(Date dueTime) { <br>        long currentTimestamp = System.currentTimeMillis(); <br>        long delayTime = currentTimestamp - dueTime.getTime();<br>        if ( isDelayed(delayTime) ) {<br>            return delayTime &#47; 86400;<br>        } else {<br>            return 0;<br>        }<br>    }<br>    <br>    public boolean isDelayed(long delayTime) {<br>         return delayTime &gt; 0 ? true : false;<br>    }<br>}","like_count":0},{"had_liked":false,"id":225309,"user_name":"花花大脸猫","can_delete":false,"product_type":"c1","uid":1117318,"ip_address":"","ucode":"8ABDB3F7F4FB0F","user_header":"https://static001.geekbang.org/account/avatar/00/11/0c/86/8e52afb8.jpg","comment_is_top":false,"comment_ctime":1591711704,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1591711704","product_id":100039001,"comment_content":"1.我认为不需要，其实就是生成个ID，业务不相关的<br>2.贫血型的自定义java pojo对象 ","like_count":0},{"had_liked":false,"id":223901,"user_name":"远方","can_delete":false,"product_type":"c1","uid":1064732,"ip_address":"","ucode":"244C74F9857196","user_header":"https://static001.geekbang.org/account/avatar/00/10/3f/1c/1e4dfbc9.jpg","comment_is_top":false,"comment_ctime":1591228687,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591228687","product_id":100039001,"comment_content":"慢慢干货，这个专栏实在是太值了","like_count":0},{"had_liked":false,"id":221424,"user_name":"技术骨干","can_delete":false,"product_type":"c1","uid":1098720,"ip_address":"","ucode":"8FCF8DE6D29201","user_header":"https://static001.geekbang.org/account/avatar/00/10/c3/e0/3db22579.jpg","comment_is_top":false,"comment_ctime":1590497209,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590497209","product_id":100039001,"comment_content":"干活满满，学不动了😭😭😭😭","like_count":0},{"had_liked":false,"id":220987,"user_name":"buggetout","can_delete":false,"product_type":"c1","uid":1880582,"ip_address":"","ucode":"63A948EF415FDD","user_header":"https://static001.geekbang.org/account/avatar/00/1c/b2/06/2086d76d.jpg","comment_is_top":false,"comment_ctime":1590373081,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590373081","product_id":100039001,"comment_content":"这个Transaction类是贫血模型吗？依赖了外部的service","like_count":0},{"had_liked":false,"id":220090,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1590152646,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590152646","product_id":100039001,"comment_content":"不在类内部实例化外部依赖，而是在类外部创建好对象传入构造函数或函数。<br>golang中数据和方法不允许分离，通过接口参数传入的实例化对象只能使用其方法不能直接使用对象的实体数据。<br>Java的spring用的是数据和方法分离，强依赖数据，方法依赖接口实现可扩展。","like_count":0},{"had_liked":false,"id":215256,"user_name":"刘同青","can_delete":false,"product_type":"c1","uid":1818343,"ip_address":"","ucode":"84B62DF8BC61FB","user_header":"","comment_is_top":false,"comment_ctime":1588942576,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1588942576","product_id":100039001,"comment_content":"答题<br><br>1.不需要。大家似乎都遗漏了一个关键点，单元测试只关注接口或者方法的定义，不要关注实现逻辑。void fillTransactionId(String preAssignedId) 的定义是填充一个id，如果pre不为空则填充pre，否则主动生成一个id来填充。所以对于它的测试，并不关注如何主动生成，而是关注能不能生成。至于生成的对不对，那是这个生成器的单元测试应该关注的。<br><br><br>2.和第一题一样，和接口功能定义无关的对象可以new，有关的那就可能是测试点了","like_count":0,"discussions":[{"author":{"id":1818343,"avatar":"","nickname":"刘同青","note":"","ucode":"84B62DF8BC61FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261148,"discussion_content":"补充一下:\n\n1.如果id生成依赖第三方组件，比如数据库或者rpc，那需要mock，否则运行不了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588942879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":210869,"user_name":"qpzm7903","can_delete":false,"product_type":"c1","uid":1138683,"ip_address":"","ucode":"C7C14962D34BE7","user_header":"https://static001.geekbang.org/account/avatar/00/11/5f/fb/af061ca7.jpg","comment_is_top":false,"comment_ctime":1587858200,"is_pvip":false,"replies":[{"id":"78763","content":"单元测试跟贫不贫血没关系吧","user_name":"作者回复","comment_id":210869,"uid":"1190123","ip_address":"","utype":1,"ctime":1588042521,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"1587858200","product_id":100039001,"comment_content":"请问贫血模式的mvc中的service怎么进行单元测试呢","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493135,"discussion_content":"单元测试跟贫不贫血没关系吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588042521,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208525,"user_name":"进击的前端er","can_delete":false,"product_type":"c1","uid":1506085,"ip_address":"","ucode":"9229B410F48B85","user_header":"https://static001.geekbang.org/account/avatar/00/16/fb/25/f6743e97.jpg","comment_is_top":false,"comment_ctime":1587375347,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587375347","product_id":100039001,"comment_content":"这节是真的看的爽啊！！","like_count":0},{"had_liked":false,"id":208390,"user_name":"三年过后","can_delete":false,"product_type":"c1","uid":1283157,"ip_address":"","ucode":"5E9106C5F11BED","user_header":"https://static001.geekbang.org/account/avatar/00/13/94/55/afc64956.jpg","comment_is_top":false,"comment_ctime":1587348848,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587348848","product_id":100039001,"comment_content":"思考题：<br>1、ID 发号器确保唯一即可。可以不用测试<br>2、充血模型的DDD不需要依赖注入","like_count":0},{"had_liked":false,"id":207616,"user_name":"lanco","can_delete":false,"product_type":"c1","uid":1188352,"ip_address":"","ucode":"C24A0A8716C78C","user_header":"https://static001.geekbang.org/account/avatar/00/12/22/00/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1587119727,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587119727","product_id":100039001,"comment_content":"如果你觉得这段代码的单元测试非常难写，那你需要考虑一下你的代码了","like_count":0},{"had_liked":false,"id":205984,"user_name":"改名不换人","can_delete":false,"product_type":"c1","uid":1118242,"ip_address":"","ucode":"7E25577829FA0F","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/22/910f705c.jpg","comment_is_top":false,"comment_ctime":1586767919,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586767919","product_id":100039001,"comment_content":"MVC三层结构，依赖数据库的那一层也可以使用Mock的方式来进行测试了，反而之前用过一种通过junit配置文件获取依赖关系来写单元测试的方式并不好，和数据库以及其他的组件耦合。有接口的依赖就实现接口，没有接口的依赖类就继承。<br>干货满满，学到了好多东西。","like_count":0},{"had_liked":false,"id":205226,"user_name":"肖臧","can_delete":false,"product_type":"c1","uid":1047733,"ip_address":"","ucode":"4FAC9FF54DD6A0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fc/b5/ac717737.jpg","comment_is_top":false,"comment_ctime":1586573554,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1586573554","product_id":100039001,"comment_content":"看到很多朋友把System.currentTimeMillis()封装在一个方法里，然后在测试方法里override这个方法，输出自己想要的值。我认为这种方法并不可取，caculateDelayDays方法对currentTimestamp是强依赖，整个方法的正确性，依赖于是否能获取currentTimestamp，所以我认为应该从入参上下手，先获取当前系统时间，然后按照测试需求，加减一定的变量得到dueTime","like_count":0,"discussions":[{"author":{"id":1047733,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fc/b5/ac717737.jpg","nickname":"肖臧","note":"","ucode":"4FAC9FF54DD6A0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295202,"discussion_content":"当然Override可以，我想表达的是怎么样做更好而已，条条大路通罗马，按你喜欢的方式来，实践会教育你我。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596117602,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1515149,"avatar":"https://static001.geekbang.org/account/avatar/00/17/1e/8d/5b242931.jpg","nickname":"Fish","note":"","ucode":"C20719F8B0F7C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295009,"discussion_content":"不太同意。感觉override 获取系统时间更好。因为获取系统时间本身很简单，测试目的是测试计算delay这个逻辑。\noverride获取系统时间时，可以在dueTime基础上加减，这样结果是确定的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596069559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203148,"user_name":"岁月","can_delete":false,"product_type":"c1","uid":1337598,"ip_address":"","ucode":"29A2A2BC3C4FE4","user_header":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","comment_is_top":false,"comment_ctime":1586144640,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1586144640","product_id":100039001,"comment_content":"只有我一个人看不懂这是什么意思嘛？<br><br>public void testExecute_with_TransactionIsExpired() {<br>  Long buyerId = 123L;<br>  Long sellerId = 234L;<br>  Long productId = 345L;<br>  Long orderId = 456L;<br>  Transction transaction = new Transaction(null, buyerId, sellerId, productId, orderId) {<br>    protected boolean isExpired() {<br>      return true;<br>    }<br>  };<br>  boolean actualResult = transaction.execute();<br>  assertFalse(actualResult);<br>  assertEquals(STATUS.EXPIRED, transaction.getStatus());<br>}<br><br>创建一个对象之后能直接重写某个方法？？？？？不需要创建一个新的类吗？我看很多编程语言都没这种功能吧。。。。","like_count":0,"discussions":[{"author":{"id":1735740,"avatar":"","nickname":"Geek_bb8d16","note":"","ucode":"964BD4DB3D9653","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":225632,"discussion_content":"这个是匿名类，比较特殊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586387749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":202603,"user_name":"墨鱼","can_delete":false,"product_type":"c1","uid":1022720,"ip_address":"","ucode":"8FB5E4DCB8A024","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/00/654be3f7.jpg","comment_is_top":false,"comment_ctime":1586014162,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586014162","product_id":100039001,"comment_content":"代码的可测试性：针对代码编写测试的难以程度。<br><br>编写可测试代码的方式：依赖注入 <br><br>测试不友好的代码：<br>1.代码中包含未决行为逻辑<br>2.滥用可变全局变量<br>3.滥用静态方法<br>4.复杂的继承关系<br>5.高度耦合的代码","like_count":0},{"had_liked":false,"id":200367,"user_name":"Geek_06c34d","can_delete":false,"product_type":"c1","uid":1593258,"ip_address":"","ucode":"C7910FAECFFE2F","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erf1o3QrluWme4LxFCickxtOTkGVQHMBOXo647FvEqwibBa9LfvX8F3EuvibFgE5XXFtpiaGicX73gMHcw/132","comment_is_top":false,"comment_ctime":1585577331,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585577331","product_id":100039001,"comment_content":"非常有启发性的思考","like_count":0},{"had_liked":false,"id":198179,"user_name":"Wizard","can_delete":false,"product_type":"c1","uid":1916084,"ip_address":"","ucode":"EEC2AC00BBED06","user_header":"https://static001.geekbang.org/account/avatar/00/1d/3c/b4/60e20977.jpg","comment_is_top":false,"comment_ctime":1585412753,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585412753","product_id":100039001,"comment_content":"在編寫單元測試的過程中，本身就是一個重構的過程。無法簡單被單元測試的類，也一定是一個不滿足ＳＯＬＩＤ，高內聚，低耦合的類。","like_count":0},{"had_liked":false,"id":196852,"user_name":"秋风画扇","can_delete":false,"product_type":"c1","uid":1132356,"ip_address":"","ucode":"5BCBC1422C51EC","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/44/964aa665.jpg","comment_is_top":false,"comment_ctime":1585318463,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585318463","product_id":100039001,"comment_content":"学到了，干活满满~以前想自己编写测试用例，最后因为难测试放弃了，看了今天的课程豁然开朗","like_count":0},{"had_liked":false,"id":189833,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1584574523,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584574523","product_id":100039001,"comment_content":"实战的例子太精彩了","like_count":1},{"had_liked":false,"id":186678,"user_name":"自古橘猫出胖子","can_delete":false,"product_type":"c1","uid":1344134,"ip_address":"","ucode":"C76F80D8C008B4","user_header":"https://static001.geekbang.org/account/avatar/00/14/82/86/712c1067.jpg","comment_is_top":false,"comment_ctime":1583900336,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583900336","product_id":100039001,"comment_content":"1.如果id没有业务逻辑，且生成id耗时不长。可以不mock。如果id生成依赖了外部服务或数据库，则需要mock<br>2.什么样的对象不能new，什么样的能new。边界外的对象需要注入，方便测试。边界内的是否就可以new？如果带有行为的对象都做成单例service注入，那ddd和充血模型应该如何设计呢？希望接下来的学习可以解决我的困惑。","like_count":0},{"had_liked":false,"id":185057,"user_name":"batman","can_delete":false,"product_type":"c1","uid":1266482,"ip_address":"","ucode":"73C30ACFC0D612","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/IIkdC2gohpcibib0AJvSdnJQefAuQYGlLySQOticThpF7Ck9WuDUQLJlgZ7ic13LIFnGBXXbMsSP3nZsbibBN98ZjGA/132","comment_is_top":false,"comment_ctime":1583474148,"is_pvip":true,"discussion_count":1,"race_medal":1,"score":"1583474148","product_id":100039001,"comment_content":"createTimestamp，是在构造函数初始化的当前系统时间，<br>executionInvokedTimestamp，是在execute执行的时候初始化的系统时间<br>怎么可能会存在14天过期的情况。<br><br>代码逻辑有问题，还是我没看懂代码？","like_count":0,"discussions":[{"author":{"id":1515149,"avatar":"https://static001.geekbang.org/account/avatar/00/17/1e/8d/5b242931.jpg","nickname":"Fish","note":"","ucode":"C20719F8B0F7C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295010,"discussion_content":"替换了isExpired函数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596069664,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184915,"user_name":"batman","can_delete":false,"product_type":"c1","uid":1266482,"ip_address":"","ucode":"73C30ACFC0D612","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/IIkdC2gohpcibib0AJvSdnJQefAuQYGlLySQOticThpF7Ck9WuDUQLJlgZ7ic13LIFnGBXXbMsSP3nZsbibBN98ZjGA/132","comment_is_top":false,"comment_ctime":1583452208,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1583452208","product_id":100039001,"comment_content":"this.status = STATUS.TO_BE_EXECUTD;<br>初始化对象的时候已经赋值了 ，而代码的35，42行的检查什么情况下会被执行？<br><br>希望老师能说明下哈","like_count":0},{"had_liked":false,"id":182815,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1582870009,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582870009","product_id":100039001,"comment_content":"1.从可测试性来说,这个方法只是一个自动生成id的方法,对于可测试性来说,并不影响,但是从实际生产的角度来说,这个方法是一个全局的自增id方法,多次测试可能会出现某些不可预料的问题,但是也可以因此发现某些问题,我不建议重写,当然重写也行,就是通过依赖注入的方式进行使用,然后注入我们自己编的mock<br>2.对于第二个问题,在常见的mvc三层框架中,上层代码会生成下层代码,供其使用,这就是类内部new的方式创建的","like_count":0},{"had_liked":false,"id":178478,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1581697166,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1581697166","product_id":100039001,"comment_content":"private 方法在Java进行单元测试的时候，可以通过反射获取","like_count":0,"discussions":[{"author":{"id":2588697,"avatar":"https://static001.geekbang.org/account/avatar/00/27/80/19/ac06db0b.jpg","nickname":"New","note":"","ucode":"406DF65BD05FAA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390494,"discussion_content":"使用@VisibleForTesting注解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629862387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":178088,"user_name":"小兵","can_delete":false,"product_type":"c1","uid":1261674,"ip_address":"","ucode":"AA3BA727C25179","user_header":"https://static001.geekbang.org/account/avatar/00/13/40/6a/ab1cf396.jpg","comment_is_top":false,"comment_ctime":1581584528,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581584528","product_id":100039001,"comment_content":"4,5,6的测试都可以通过执行两次execute方法来实现，第一遍改变状态，第二遍真正的测试。<br>另外一个感受，如果是由于依赖关系导致的难以测试，就需要考虑是不是紧耦合了。<br>如果不是，那么可能就不应该通过抽取单独的方法的方式来方便测试。因为抽取单独的方法也就相当于对外开放了修改权限了。像案例中的过期时间方法，protected修饰就可能有问题。","like_count":0},{"had_liked":false,"id":177727,"user_name":"Edward Lee","can_delete":false,"product_type":"c1","uid":1228518,"ip_address":"","ucode":"156223F1D7E94A","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/e6/7808520d.jpg","comment_is_top":false,"comment_ctime":1581482039,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581482039","product_id":100039001,"comment_content":"TransactionLock 通过适配器来提供可测试的代码实在太惊艳了<br><br>原来单元测试难度不在于怎么提高测试覆盖率而是改造已有的代码成可测试代码，在开发过程就要考虑代码的可测试性，如果在单元测试的时候再考虑重构的话工作量就比较大了<br><br>if (preAssignedId != null &amp;&amp; !preAssignedId.isEmpty()) {<br>  this.id = preAssignedId;<br>} else {<br>  this.id = IdGenerator.generateTransactionId();<br>}<br>if (!this.id.startWith(&quot;t_&quot;)) {<br>  this.id = &quot;t_&quot; + preAssignedId;<br>}<br><br>IdGenerator.generateTransactionId() 个人认为不需要 Mock 了，另外 this.id = &quot;t_&quot; + preAssignedId; 是不是有 bug 呢？是不是应该 this.id = &quot;t_&quot; + this.id; 才对呢？","like_count":0},{"had_liked":false,"id":177622,"user_name":"楊_宵夜","can_delete":false,"product_type":"c1","uid":1019302,"ip_address":"","ucode":"7BA0CADC5F23BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/a6/22c37c91.jpg","comment_is_top":false,"comment_ctime":1581435794,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581435794","product_id":100039001,"comment_content":"争哥, 又有两个问题:<br>if (status == STATUS.EXECUTED) ;<br>进行了double check, 但这句前面获取的是分布式锁;<br><br>1. 那这个double check主要意义何在呢? 或者是针对解决那种业务场景呢??<br>2. 虽然与设计模式无关, 但status这个变量是否应该设置为volatile??","like_count":0},{"had_liked":false,"id":177575,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1015754,"ip_address":"","ucode":"00DF2FEC58D2E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","comment_is_top":false,"comment_ctime":1581427301,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1581427301","product_id":100039001,"comment_content":"争哥，一直对于编写单元测试有一个疑问：如果要测试的代码涉及到数据库的操作，当测试用例跑完了后，如何对数据库进行后处理呢？对于在测试过程中产生的数据，也通过其测试用例来删除？抑或是，访问数据库的点不需要测试？？请争哥抽时间帮忙解惑！感谢了","like_count":0,"discussions":[{"author":{"id":1538604,"avatar":"https://static001.geekbang.org/account/avatar/00/17/7a/2c/54b48459.jpg","nickname":"Vincent.X","note":"","ucode":"8A40B5B2F4B102","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283959,"discussion_content":"所谓mock就是模拟。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592406985,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1087243,"avatar":"https://static001.geekbang.org/account/avatar/00/10/97/0b/a943bcb3.jpg","nickname":"zhou","note":"","ucode":"E1CE8575B3F106","race_medal":3,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":280302,"discussion_content":"需要依赖数据库、网络通信、文件系统等，那我们就需要将被测代码与外部系统解依赖，而这种解依赖的方法就叫作“mock”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591525033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175374,"user_name":"Corner","can_delete":false,"product_type":"c1","uid":1446316,"ip_address":"","ucode":"7862D593172536","user_header":"https://static001.geekbang.org/account/avatar/00/16/11/ac/9cc5e692.jpg","comment_is_top":false,"comment_ctime":1580698140,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580698140","product_id":100039001,"comment_content":"可不可以这么理解呢，如果静态方法依赖外部系统或者逻辑复杂，是不是最好重写为面向对象的实例方法呢？","like_count":0},{"had_liked":false,"id":174222,"user_name":"沈杰","can_delete":false,"product_type":"c1","uid":1230818,"ip_address":"","ucode":"20D1D820CAD60D","user_header":"https://static001.geekbang.org/account/avatar/00/12/c7/e2/27d00854.jpg","comment_is_top":false,"comment_ctime":1580094629,"is_pvip":true,"discussion_count":0,"race_medal":4,"score":"1580094629","product_id":100039001,"comment_content":"666，还是很实用，特别是重构代码可测试性部分很有启发","like_count":0},{"had_liked":false,"id":172782,"user_name":"satoshi","can_delete":false,"product_type":"c1","uid":1114872,"ip_address":"","ucode":"11508C95259E97","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLQcr5YD5xznNjMxltFI04NgpTWWicKD3QicBfshIEWtckXNYMicjdNfQu8w5hSTGicuxUg6sOI8yfoNw/132","comment_is_top":false,"comment_ctime":1579310750,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579310750","product_id":100039001,"comment_content":"豁然开朗...","like_count":0},{"had_liked":false,"id":171673,"user_name":"睁眼看世界","can_delete":false,"product_type":"c1","uid":1206388,"ip_address":"","ucode":"F94CF34BC5B2AC","user_header":"https://static001.geekbang.org/account/avatar/00/12/68/74/461b202d.jpg","comment_is_top":false,"comment_ctime":1578989534,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578989534","product_id":100039001,"comment_content":"有对象生命周期的需要依赖注入，基于接口而非实现；对于局部对象，如相关*VO对象可直接new，因为其是临时的。","like_count":0},{"had_liked":false,"id":171152,"user_name":"jaryoung","can_delete":false,"product_type":"c1","uid":1077406,"ip_address":"","ucode":"6E72D107DB7E51","user_header":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","comment_is_top":false,"comment_ctime":1578874629,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578874629","product_id":100039001,"comment_content":"思考1，无需实现，随机生成的ID不应该影响业务主流程，除非ID有业务含义就另当别论。<br>思考二，如果类本身是当前类的内部类？","like_count":0},{"had_liked":false,"id":170686,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1578665397,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1578665397","product_id":100039001,"comment_content":"争哥，想请教一个问题。我们在mock RedisDistributedLock的时候，将其封装成TransactionLock，这样原Transaction类中调用RedisDistributedLock的地方都改成了调用TransactionLock。<br>这样不就破坏了原有类的实现吗？如果这样的mock很多，最后忘记修改，会不会有问题？","like_count":0,"discussions":[{"author":{"id":1983911,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/45/a7/762a4a08.jpg","nickname":"冰封剑鞘","note":"","ucode":"D9F04A1AB3C8A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":274526,"discussion_content":"请温习一边“重构”的定义，不改变原有行为下使得代码更灵活，更易测试，所以是不存在测试后需要改回来的情况的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590590288,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170685,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1578665348,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578665348","product_id":100039001,"comment_content":"争哥，想请教一个问题。我们在mock RedisDistributedLock的时候，将其封装成TransactionLock，这样原Transaction类中调用RedisDistributedLock的地方都改成了调用TransactionLock。<br>这样不就破坏了原有类的实现吗？如果这样的mock很多，最后忘记修改，会不会有问题？","like_count":0},{"had_liked":false,"id":170625,"user_name":"L🚲🐱","can_delete":false,"product_type":"c1","uid":1577856,"ip_address":"","ucode":"08A012739614DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","comment_is_top":false,"comment_ctime":1578646035,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578646035","product_id":100039001,"comment_content":"关于思考题:  思考题 一 IdGenerator.generateTransactionId() 只是生成一个 id 生成器, 不需要mock 这个函数, 就生成一个随机数, 没多大测试意义.<br>思考题二 有实现方法的类应该用依赖注入减少依赖, entity bo vo 等bean 可以 new 不需要依赖注入","like_count":0},{"had_liked":false,"id":170619,"user_name":"堵车","can_delete":false,"product_type":"c1","uid":1145404,"ip_address":"","ucode":"7BC1E50A4F8D3D","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/3c/87e015f8.jpg","comment_is_top":false,"comment_ctime":1578645172,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578645172","product_id":100039001,"comment_content":"请问单元测试在什么时候做比较好？是一个模块写完再测试还是一个方法写完再测试？文中获取redis锁用静态方法，一行代码就搞定了，而且几乎所有的分布式锁都是这样的写法，用起来很方便，后期几乎不会变动。为了可测试性，每个业务都封装了一个lock,是不是过度解耦了。","like_count":0},{"had_liked":false,"id":170565,"user_name":"花儿少年","can_delete":false,"product_type":"c1","uid":1318540,"ip_address":"","ucode":"CFE4F64243673B","user_header":"https://static001.geekbang.org/account/avatar/00/14/1e/8c/450fe5cb.jpg","comment_is_top":false,"comment_ctime":1578633966,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578633966","product_id":100039001,"comment_content":"mock的通常是外部服务，id生成器如果是个外部服务那就需要mock，不过通常来说id生成不会影响业务逻辑。<br>什么时间可以new，需要取决于new的对象是否有外部依赖，有则需要注入，否则可以new","like_count":0},{"had_liked":false,"id":170531,"user_name":"石仔","can_delete":false,"product_type":"c1","uid":1177921,"ip_address":"","ucode":"974E4604CE2213","user_header":"https://static001.geekbang.org/account/avatar/00/11/f9/41/411b1753.jpg","comment_is_top":false,"comment_ctime":1578627244,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578627244","product_id":100039001,"comment_content":"[原则]是:不依赖网络,IO或者第三方服务的就可以不需要mock.<br>1.本实战案例 并没有要对TransactionId进行验证,所以只要它能正常生成就完成了它的任务不需要mock.<br>2.类内部通过 new 的方式创建对象,只要这个对象的创建不违反[原则]而且不需要在后续测试依赖到就可以放在内部new来创建.<br><br>3.未决行为Demo:<br><br>public class Demo {<br>    private long currentTimestamp;<br>    private long dueTimestamp;<br><br>    public Demo(long currentTimestamp, long dueTimestamp) {<br>        this.currentTimestamp = currentTimestamp;<br>        this.dueTimestamp = dueTimestamp;<br>    }<br><br>    &#47;**<br>     * 计算延迟天数<br>     *<br>     * @return<br>     *&#47;<br>    public long caculateDelayDays() {<br>        if (!isDelayDays()) {<br>            return 0;<br>        }<br>        long delayTime = this.currentTimestamp - this.dueTimestamp;<br>        long delayDays = delayTime &#47; 86400;<br>        return delayDays;<br>    }<br><br>    &#47;**<br>     * 是否延迟<br>     *<br>     * @return<br>     *&#47;<br>    public boolean isDelayDays() {<br>        if (this.dueTimestamp &gt;= this.currentTimestamp) {<br>            return false;<br>        }<br>        return true;<br>    }<br>}<br><br>测试:<br>    @Test<br>    public void caculateDelayDaysTest() {<br>        long currentTimestamp = System.currentTimeMillis();<br>        Demo demo = new Demo(System.currentTimeMillis(), currentTimestamp - 14 * 86400);<br>        assertEquals(14l, demo.caculateDelayDays());<br>    }","like_count":0},{"had_liked":false,"id":170432,"user_name":"Ken张云忠","can_delete":false,"product_type":"c1","uid":1134288,"ip_address":"","ucode":"D0BAC9FC17DE2B","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","comment_is_top":false,"comment_ctime":1578615063,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578615063","product_id":100039001,"comment_content":"1.实战案例中的 void fillTransactionId(String preAssignedId) 函数中包含一处静态函数调用：IdGenerator.generateTransactionId()，这是否会影响到代码的可测试性？在写单元测试的时候，我们是否需要 mock 这个函数？<br>如果generateTransactionId()依赖了外部服务,如redis&#47;mysql&#47;zookeeper等,就会影响代码的可测试性,在写单元测试时就需要mock这个函数;<br>如果generateTransactionId()没有依赖外部服务就不会影响代码的可测试性,写单元测试时也不需要mock这个函数.<br><br>2.依赖注入是提高代码可测试性的最有效的手段。所以，依赖注入，就是不要在类内部通过 new 的方式创建对象，而是要通过外部创建好之后传递给类使用。<br>那是不是所有的对象都不能在类内部创建呢？哪种类型的对象可以在类内部创建并且不影响代码的可测试性？你能举几个例子吗？<br>不是.<br>没有依赖外部服务的对象可以在类内部创建,并且不会影响代码的可测试性.<br>例如new Date()没有依赖外部服务,只是调用了本机操作系统的时间函数.","like_count":0},{"had_liked":false,"id":170206,"user_name":"一名小学生","can_delete":false,"product_type":"c1","uid":1137292,"ip_address":"","ucode":"5C73082E6B6370","user_header":"https://static001.geekbang.org/account/avatar/00/11/5a/8c/1fec5fa2.jpg","comment_is_top":false,"comment_ctime":1578550153,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1578550153","product_id":100039001,"comment_content":"一直搞不懂单元测试怎么写，于是就不喜欢写，跟着这节课敲了代码，学到了好多。感觉知道怎么去写，感觉自己一下变强了，争哥太强了，666","like_count":0,"discussions":[{"author":{"id":1145404,"avatar":"https://static001.geekbang.org/account/avatar/00/11/7a/3c/87e015f8.jpg","nickname":"堵车","note":"","ucode":"7BC1E50A4F8D3D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":128503,"discussion_content":"我学到了“可测试性”这个概念。懂得怎么用断言","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578645343,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170038,"user_name":"#HEAVEN","can_delete":false,"product_type":"c1","uid":1191155,"ip_address":"","ucode":"C14977F6D24E19","user_header":"https://static001.geekbang.org/account/avatar/00/12/2c/f3/bab761d0.jpg","comment_is_top":false,"comment_ctime":1578495488,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578495488","product_id":100039001,"comment_content":"你好，没有找到作者邮箱，想问一个问题；<br>作者在开发一个需求的时候是怎样的一个流程，设计做到那种程度？<br>比如说一般我会做1. 需求分析，列出哪些需求case； 2. 列出这些case需要开发哪些功能点；3. 主要涉及到哪些类，结构如何组织；4. 主要类的主要职责等；5. 开始code了；<br>在开发的过程中也会遇到一些问题，比如，有时候有些类的职责或者结构开始的设计不太合理，需要一些修改；这个时候我就在怀疑，是不是前期做的设计不够充分造成的。也看到一些书上会把类的属性、方法都设计出来，还有主要流程case的序列图；但是这样做耗时较多，很多时候项目日程不允许。<br>像问一下，作者在开发中设计阶段有哪些流程，做到什么程度？<br>留个邮箱方便交流就更好了","like_count":0},{"had_liked":false,"id":169997,"user_name":"一壶浊酒","can_delete":false,"product_type":"c1","uid":1145530,"ip_address":"","ucode":"5D90F8F8121BBE","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/ba/8545f2d7.jpg","comment_is_top":false,"comment_ctime":1578490574,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1578490574","product_id":100039001,"comment_content":"对于IdGenerator.generateTransactionId()，虽然是未决行为，个人认为只是生成一个id了话，并不会包含非常复杂的逻辑操作，应该就跟Math.abs()类似，不需要进行mock","like_count":0},{"had_liked":false,"id":169968,"user_name":"斐波那契","can_delete":false,"product_type":"c1","uid":1464006,"ip_address":"","ucode":"85E2EBC01392B1","user_header":"https://static001.geekbang.org/account/avatar/00/16/56/c6/0b449bc6.jpg","comment_is_top":false,"comment_ctime":1578485377,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578485377","product_id":100039001,"comment_content":"感觉那个createtimestamp那边 如果没有set方法应该可以用反射去修改这个属性<br><br>思考题1 可以不mock 因为执行idgenerator之前有逻辑判断的 只要传入进去的参数不满足条件就不会走 其次对于id开头添加t_这个逻辑跟id生成器没有关系 只要保证造出来到id没有t_开头就可以测试<br><br>思考题2 其实最近在写一个需求 我就用了内部类 也觉得并没有破坏测试性 我这个内部类主要是为了隐藏某个接口的实现 不想被调用者在使用外部类时滥用我的每一个接口实现方法 起到一个保护作用 对于测试性 完全可以通过不同的外部类参数来进行调整 其实对于内部类的可测试性来讲 只要外部类有足够的参数来控制内部类就可以 对于内部类调用第三方的情况 只要外部类有参数可以注入就可以用mock来修改内部类的实现","like_count":0},{"had_liked":false,"id":169855,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1578459458,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578459458","product_id":100039001,"comment_content":"1.栏主好像提过，要谈谈分层对于可测试性的影响，不知是不是我记错了，这篇没提到哈。<br><br>回答问题<br>1.交易id这东西，是全局唯一的。不该被mock，mock了不仅没用，反而可能会有其他问题（如果有引入唯一键检验相关机制的话，比如幂等啥的）。<br><br>2.值对象可以new，因为值对象不会有涉及改动自身属性的方法，也就是说它通常是不可变的，所以也没什么检验的意义。而实体领域模型不一定可以new，因为其方法会改变自身属性，而对这些属性变动，有时候我们需要校验。而贫血实体dto或do之类的，一般也可以new，因为它只承接属性，场景类似值对象，只需要关心方法返回的dto或vo的值即可，无需关心方法内部是new还是注入的（对于方法而言，除了类成员属性的注入，方法入参也算注入吧）。","like_count":0},{"had_liked":false,"id":169839,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1578454869,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578454869","product_id":100039001,"comment_content":"设计模式_29:<br><br>1. 我认为静态方法```IdGenerator.generateTransactionId()```不需要mock，因为它不会很耗时(如果实现比较正常)，也没有未决行为，除非对于id有特殊的要求，否则不需要mock。<br><br>2. 这道题我想不清楚，想看看王争老师和大家的看法。","like_count":0},{"had_liked":false,"id":169832,"user_name":"此鱼不得水","can_delete":false,"product_type":"c1","uid":1257453,"ip_address":"","ucode":"95268E823FB4D2","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/ed/a87bb8fa.jpg","comment_is_top":false,"comment_ctime":1578453731,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1578453731","product_id":100039001,"comment_content":"1. 未决行为 中提到的单测，可以把不确定的变量‘当前时间’提取出来作为入参","like_count":0,"discussions":[{"author":{"id":1055334,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1a/66/2d9db9ed.jpg","nickname":"苦行僧","note":"","ucode":"726024A9A9CF44","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":131907,"discussion_content":"怎么理解？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578874493,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169815,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1578451094,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1578451094","product_id":100039001,"comment_content":"课堂讨论:<br><br><br><br>Q1.实战案例中的 void fillTransactionId(String preAssignedId) 函数中包含一处静态函数调用：IdGenerator.generateTransactionId()，这是否会影响到代码的可测试性？在写单元测试的时候，我们是否需要 mock 这个函数？<br><br><br><br>Answer1: <br><br>理论上讲fill()方法由于内部静态方法的使用,及id生成的未决行为,影响可测试性.<br><br>解决方法是为fill()方法添加一个形参,generateId,如下:<br><br>void fillTransactionId(@Nullable String preAssignedId, @Nullable String generateId)<br><br>但这样做会影响封装性.fill()方法内部逻辑简单,对可测试性的影响是微不足道的.除非测试问题直指fill()方法,否则个人倾向于不做修改.<br><br><br><br>Q2.我们今天讲到，依赖注入是提高代码可测试性的最有效的手段。所以，依赖注入，就是不要在类内部通过 new 的方式创建对象，而是要通过外部创建好之后传递给类使用。那是不是所有的对象都不能在类内部创建呢？哪种类型的对象可以在类内部创建并且不影响代码的可测试性？你能举几个例子吗？<br><br><br><br>Answer2: 内部类或静态内部类, 局部类的对象可以在类内部通过new 的方式初始化.它们是外部类行为的一部分,仅为外部类自己使用,不影响测试性.<br><br><br><br>对于未决行为方法的改造:<br><br>before: <br><br><br><br>public class Demo { <br><br>public long caculateDelayDays(Date dueTime){<br><br> long currentTimestamp = System.currentTimeMillis();<br><br> if (dueTime.getTime() &gt;= currentTimestamp) { return 0; } <br><br>long delayTime = currentTimestamp - dueTime.getTime();<br><br> long delayDays = delayTime &#47; 86400; <br><br>return delayDays; <br><br>​    }<br><br>}<br><br><br><br>after:<br><br>public class Demo { <br><br>public long caculateDelayDays(Date dueTime, Date currentTime){<br><br>​     long currentTimestamp = currentTime.getTime();<br><br>​     if (dueTime.getTime() &gt;= currentTimestamp) { return 0; } <br><br>​     long delayTime = currentTimestamp - dueTime.getTime();<br><br>​     long delayDays = delayTime &#47; 86400; <br><br>​     return delayDays; <br><br>​    }<br><br>}","like_count":0,"discussions":[{"author":{"id":1484184,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","nickname":"djfhchdh","note":"","ucode":"E71D75328CE398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":125139,"discussion_content":"long currentTimestamp = System.currentTimeMillis();这个语句是未决行为，我觉得只要封装一个getCurrentTimestamp()方法就行了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578476657,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169805,"user_name":"Jackey","can_delete":false,"product_type":"c1","uid":1063751,"ip_address":"","ucode":"125DE81993FEDD","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/47/f6c772a1.jpg","comment_is_top":false,"comment_ctime":1578448850,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578448850","product_id":100039001,"comment_content":"ID生成方法只是生成一个字符串，个人认为可以不用测试","like_count":0},{"had_liked":false,"id":169799,"user_name":"liu_liu","can_delete":false,"product_type":"c1","uid":1019138,"ip_address":"","ucode":"24283806A07759","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/02/6a16058a.jpg","comment_is_top":false,"comment_ctime":1578447914,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578447914","product_id":100039001,"comment_content":"1. 生成的id 并不会对主体逻辑造成影响，无需mock，只需该 idGen 本身通过单元测试即可。<br>2. 如果未使用到依赖对象的功能，或者其功能很简单，又或者使用了也不会影响到当前被测函数逻辑，可以内部 new。","like_count":0},{"had_liked":false,"id":169794,"user_name":"成楠Peter","can_delete":false,"product_type":"c1","uid":1252977,"ip_address":"","ucode":"4D13E7368D8CF2","user_header":"https://static001.geekbang.org/account/avatar/00/13/1e/71/9dcbe6c4.jpg","comment_is_top":false,"comment_ctime":1578447737,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578447737","product_id":100039001,"comment_content":"这一节更偏向实战，写代码的方式，让我一下理解了依赖注入和反转依赖","like_count":0},{"had_liked":false,"id":169786,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1578446622,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1578446622","product_id":100039001,"comment_content":"1. 这个静态函数多少是有一些影响的，测试这个函数的时候，需要关注这个静态函数的逻辑，看它返回值，才能在测试的时候判断this.id是否满足期待值，比如这个静态函数返回值中不包含“t_”，那么单元测试的assert逻辑就不一样。在写单元测试时候，只要这个静态函数不是第三方的服务，也没有依赖第三方的服务，返回值的format固定，并且我们也不关心this.id的format，那么可以不mock它，反之，最好还是mock，这样测试的时候可以期待固定输入得到固定输出。<br>2. 贫血模型中的那些*o可以直接在里面new。","like_count":0}]}