{"id":476637,"title":"07 | 高阶函数：为什么说函数是Kotlin的“一等公民”？","content":"<p>你好，我是朱涛。</p><p>高阶函数在Kotlin里有着举足轻重的地位。<strong>它是Kotlin函数式编程的基石，是各种框架的关键元素。</strong>高阶函数掌握好了，我们理解协程的launch、async函数就会轻松一些，阅读协程的源代码也会不那么吃力；高阶函数理解透彻了，我们学习Jetpack Compose也会得心应手，在特定业务场景下，我们甚至可以用它来实现自己的DSL（Domain Specific Language）。</p><p>不过，如果你没有函数式编程的相关经验，在初次接触高阶函数的时候，很可能会被绕晕。因为它是一个全新的概念，你很难从经典的C/Java里找到同等的概念迁移过来（Java从1.8开始才引入相关概念）。然而，对于高阶函数这么重要的概念，Kotlin官方文档又惜字如金。</p><p>文档里只是突兀地介绍了高阶函数、函数类型、Lambda表达式的简单用法，接着就丢出一段复杂的代码案例，然后丢出一个更复杂的概念，“带接收者的函数类型”（Function Types With Receiver），接着又丢出了一段更复杂的代码案例。说实话，这真的让人难以理解。</p><p>所以今天这节课，我会采用Java和Kotlin对照的方式，来给你讲解Kotlin高阶函数的核心概念。并且我会通过一个实际案例，来帮助你理解其中最晦涩难懂的“带接收者的函数类型”，为你今后的Kotlin学习之路打下坚实的基础。</p><!-- [[[read_end]]] --><h2>Kotlin为什么要引入高阶函数？</h2><p>想要掌握好高阶函数，我们首先要知道，Kotlin为什么要引入这一全新的概念。这个问题，Kotlin官方并没有给出解释，但是我们很容易在它的使用上找到蛛丝马迹。</p><p>我们来看个实际的例子，这是Android中的View定义，这里我省略了大部分代码，主要是想带你来看看Kotlin高阶函数的一个典型使用场景。</p><blockquote>\n<p>补充：如果你不了解Android开发也没关系，Java Swing中也有类似的代码模式。如果两者你都不熟悉，借助我提供的注释，也不难理解。</p>\n</blockquote><pre><code class=\"language-java\">// View.java\n\n// 成员变量\nprivate OnClickListener mOnClickListener;\nprivate OnContextClickListener mOnContextClickListener;\n\n// 监听手指点击事件\npublic void setOnClickListener(OnClickListener l) {\n    mOnClickListener = l;\n}\n\n// 为传递这个点击事件，专门定义了一个接口\npublic interface OnClickListener {\n    void onClick(View v);\n}\n\n// 监听鼠标点击事件\npublic void setOnContextClickListener(OnContextClickListener l) {\n    getListenerInfo().mOnContextClickListener = l;\n}\n\n// 为传递这个鼠标点击事件，专门定义了一个接口\npublic interface OnContextClickListener {\n    boolean onContextClick(View v);\n}\n</code></pre><p>这段代码，其实是一个典型的“可以用高阶函数来优化”的例子。让我们来看看它都做了什么：</p><ul>\n<li>首先，为了设置点击事件的监听，代码里特地定义了一个OnClickListener接口；</li>\n<li>接着，为了设置鼠标点击事件的监听，又专门定义了一个OnContextClickListener接口。</li>\n</ul><p>乍一看，我们貌似是可以复用同一个接口就行了，对吧？但事实上，<strong>借助高阶函数，我们一个接口都不必定义</strong>。</p><p>当然了，上面的代码是Android团队十几年前用Java写的，在那个场景下，这么写代码是完全没问题的。可是这段代码在使用的时候，问题更大。比如，我们可以来看看如下所示的Android里设置点击监听的代码：</p><pre><code class=\"language-java\">// 设置手指点击事件\nimage.setOnClickListener(new View.OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        gotoPreview();\n    }\n});\n\n// 设置鼠标点击事件\nimage.setOnContextClickListener(new View.OnContextClickListener() {\n    @Override\n    public void onContextClick(View v) {\n        gotoPreview();\n    }\n});\n</code></pre><p>看完了这两段代码之后，你有没有觉得这样的代码会很啰嗦？因为，真正逻辑只有一行代码：gotoPreview()，而实际上我们却写了6行代码。</p><p><img src=\"https://static001.geekbang.org/resource/image/18/ac/1876d635751fd11662fbfcc3285a0eac.jpg?wh=1852x494\" alt=\"图片\"></p><p>如果我们将其中的核心逻辑提取出来，会发现这样才是最简单明了的：</p><pre><code class=\"language-plain\">//                      { gotoPreview() } 就是 Lambda\n//                             ↑\nimage.setOnClickListener({ gotoPreview() })\nimage.setOnContextClickListener({ gotoPreview() })\n</code></pre><p>那么，Kotlin语言的设计者是怎么做的呢？实际上他们是分成了两个部分：</p><ul>\n<li>用函数类型替代接口定义；</li>\n<li>用Lambda表达式作为函数参数。</li>\n</ul><p>这里我们再来看看与前面View.java的等价Kotlin代码：</p><pre><code class=\"language-plain\">//View.kt\n//                     (View) -&gt; Unit 就是「函数类型 」\n//                       ↑        ↑ \nvar mOnClickListener: ((View) -&gt; Unit)? = null\nvar mOnContextClickListener: ((View) -&gt; Unit)? = null\n\n// 高阶函数\nfun setOnClickListener(l: (View) -&gt; Unit) {\n    mOnClickListener = l;\n}\n\n// 高阶函数\nfun setOnContextClickListener(l: (View) -&gt; Unit) {\n    mOnContextClickListener = l;\n}\n</code></pre><p>那么通过对比，我们能看到，Kotlin中引入高阶函数会带来几个<strong>好处</strong>：一个是针对定义方，代码中减少了两个接口类的定义；另一个是对于调用方来说，代码也会更加简洁。这样一来，就大大减少了代码量，提高了代码可读性，并通过减少类的数量，提高了代码的性能。</p><p><img src=\"https://static001.geekbang.org/resource/image/a7/eb/a7yy974d95cd3938f0f36781afb425eb.jpg?wh=1531x699\" alt=\"图片\"></p><blockquote>\n<p>注：关于“inline”，我会在下节课中详细介绍。</p>\n</blockquote><p>通过上面的例子，我们已经清楚高阶函数存在的意义和价值了。不过，前面出现的一些新的概念我们还没来得及详细解释，比如，<strong>函数类型、Lambda，它们到底是什么呢？还有高阶函数的具体定义是什么呢？</strong></p><p>接下来，我会通过一个具体的代码案例，来给你一一解读与高阶函数关系密切的概念及使用定义，让你能进一步夯实函数式编程的基础知识。</p><h2>理解高阶函数的相关概念</h2><p>首先，我们来了解下什么是函数类型。</p><h3>函数类型</h3><p>顾名思义，函数类型（Function Type）就是<strong>函数的类型</strong>。如果你之前没有函数式编程的经验，刚接触这个概念的话也许会觉得奇怪：函数也有类型吗？</p><p>是的，既然变量可以有类型，函数也可以有。在Kotlin的世界里，<a href=\"https://kotlinlang.org/docs/lambdas.html\">函数是一等公民</a>。你可以将其理解为Kotlin里的VIP，普通人有的东西，VIP当然也有。比如，我们可以仔细看看下面的函数：</p><pre><code class=\"language-plain\">//         (Int,  Int) -&gt;Float 这就是 add 函数的类型\n//           ↑     ↑      ↑\nfun add(a: Int, b: Int): Float { return (a+b).toFloat() }\n</code></pre><p>请注意这里我给出代码注释，第二行注释里面的“↑”代表的是一种映射关系。其实，将第三行代码里的“Int Int Float”抽出来，就代表了该函数的类型。</p><p>我们可以用更精练的语言来描述函数类型的规律：<strong>将函数的“参数类型”和“返回值类型”抽象出来后，就得到了“函数类型”</strong>。(Int, Int) -&gt;Float就代表了参数类型是两个Int，返回值类型为Float的函数类型。</p><p>理解了函数类型以后，我们再来看<strong>函数的引用</strong>。普通的变量也有引用的概念，我们可以将一个变量赋值给另一个变量。而这一点，在函数上也是同样适用的，函数也有引用，并且也可以赋值给变量。</p><pre><code class=\"language-plain\">// 函数赋值给变量                    函数引用\n//    ↑                              ↑\nval function: (Int, Int) -&gt; Float = ::add\n</code></pre><h3>高阶函数</h3><p>好，接着我们再来看看高阶函数的具体定义。当然，前面解释了这么多，现在我们对高阶函数应该已经有了比较清晰的认识了，我们用Kotlin实现的View点击事件函数，它就是一个高阶函数。</p><p>而它明确的定义其实是这样的：<strong>高阶函数是将函数用作参数或返回值的函数。</strong></p><p>这句话有点绕，我们还是直接看例子吧。如果我们将Android里点击事件的监听用Kotlin来实现的话，它其实就是一个典型的高阶函数。</p><pre><code class=\"language-plain\">//                      函数作为参数的高阶函数\n//                              ↓\nfun setOnClickListener(l: (View) -&gt; Unit) { ... }\n</code></pre><p>换句话说，一个函数的参数或是返回值，它们当中有一个是函数的情况下，这个函数就是高阶函数。</p><h3>Lambda</h3><p>而前面我们还提到过，Kotlin语言的设计者是用Lambda表达式作为函数参数的，那么这里的Lambda，就可以理解为是<strong>函数的简写</strong>：</p><pre><code class=\"language-plain\">fun onClick(v: View): Unit { ... }\nsetOnClickListener(::onClick)\n\n// 用 Lambda 表达式来替代函数引用\nsetOnClickListener({v: View -&gt; ...})\n</code></pre><p>那么，如果你够细心的话，可能已经发现了一个问题：Android并没有提供View.java的Kotlin实现，那么为什么我们的Demo里面可以用Lambda来简化事件监听呢？</p><pre><code class=\"language-plain\">// 在实际开发中，我们经常使用这种简化方式\nsetOnClickListener({ gotoPreview() }\n</code></pre><p>原因是这样的，由于OnClickListener符合SAM转换的要求，因此编译器自动帮我们做了一层转换，让我们可以用Lambda表达式来简化我们的函数调用。</p><p>那么，SAM又是个什么鬼？</p><h3>SAM转换</h3><p>SAM是Single Abstract Method的缩写，意思就是只有一个抽象方法的类或者接口。但在Kotlin和Java 8里，<strong>SAM代表着只有一个抽象方法的接口</strong>。只要是符合SAM要求的接口，编译器就能进行SAM转换，也就是我们可以使用Lambda表达式，来简写接口类的参数。</p><p>注意，Java 8中的SAM有明确的名称，叫做<strong>函数式接口</strong>（FunctionalInterface）。FunctionalInterface的限制如下，缺一不可：</p><ul>\n<li>必须是接口，抽象类不行；</li>\n<li>该接口有且仅有一个抽象的方法，抽象方法个数必须是1，默认实现的方法可以有多个。</li>\n</ul><p>也就是说，对于View.java来说，它虽然是Java代码，但Kotlin编译器知道它的参数OnClickListener符合SAM转换的条件，所以会自动做以下转换。</p><p>转换前：</p><pre><code class=\"language-java\">public void setOnClickListener(OnClickListener l)\n</code></pre><p>转换后：</p><pre><code class=\"language-plain\">fun setOnClickListener(l: (View) -&gt; Unit)\n// 实际上是这样：\nfun setOnClickListener(l: ((View!) -&gt; Unit)?)\n</code></pre><p>其中，((View!) -&gt; Unit)?代表的是这个参数可能为空。</p><h2>Lambda表达式引发的8种写法</h2><p>当一个函数的参数是SAM的情况下，我们同样也可以使用Lambda作为参数。所以，<strong>我们既可以用匿名内部类的方式传参，也可以使用Lambda的方式传参</strong>。这两种方式在我们前面都已经提到过了。然而，在这两种写法的中间，还有6种“过渡状态”的写法。这对大部分初学者简直是噩梦：同样的代码，能有8种不同的写法，确实也挺懵的。</p><p>而要理解Lambda表达式的简写逻辑，其实很简单，那就是：<strong>多写</strong>。你也可以跟着我接下来的流程来一起写一写。</p><ul>\n<li>第1种写法</li>\n</ul><p>这是原始代码，它的本质是用 object 关键字定义了一个匿名内部类：</p><pre><code class=\"language-plain\">image.setOnClickListener(object: View.OnClickListener {\n    override fun onClick(v: View?) {\n        gotoPreview(v)\n    }\n})\n</code></pre><ul>\n<li>第2种写法</li>\n</ul><p>在这种情况下，object关键字可以被省略。这时候它在语法层面就不再是匿名内部类了，它更像是Lambda表达式了，因此它里面override的方法也要跟着删掉：</p><pre><code class=\"language-plain\">image.setOnClickListener(View.OnClickListener { v: View? -&gt;\n    gotoPreview(v)\n})\n</code></pre><p>上面的<code>View.OnClickListener</code>被称为SAM Constructor（SAM构造器），它是编译器为我们生成的。</p><ul>\n<li>第3种写法</li>\n</ul><p>由于Kotlin的Lambda表达式是不需要SAM Constructor的，所以它也可以被删掉：</p><pre><code class=\"language-plain\">image.setOnClickListener({ v: View? -&gt;\n    gotoPreview(v)\n})\n</code></pre><ul>\n<li>第4种写法</li>\n</ul><p>由于Kotlin支持类型推导，所以View可以被删掉：</p><pre><code class=\"language-plain\">image.setOnClickListener({ v -&gt;\n    gotoPreview(v)\n})\n</code></pre><ul>\n<li>第5种写法</li>\n</ul><p>当Kotlin Lambda表达式只有一个参数的时候，它可以被写成it：</p><pre><code class=\"language-plain\">image.setOnClickListener({ it -&gt;\n    gotoPreview(it)\n})\n</code></pre><ul>\n<li>第6种写法</li>\n</ul><p>Kotlin Lambda的it是可以被省略的：</p><pre><code class=\"language-plain\">image.setOnClickListener({\n    gotoPreview(it)\n})\n</code></pre><ul>\n<li>第7种写法</li>\n</ul><p>当Kotlin Lambda作为函数的最后一个参数时，Lambda可以被挪到外面：</p><pre><code class=\"language-plain\">image.setOnClickListener() {\n    gotoPreview(it)\n}\n</code></pre><ul>\n<li>第8种写法</li>\n</ul><p>当Kotlin只有一个Lambda作为函数参数时，()可以被省略：</p><pre><code class=\"language-plain\">image.setOnClickListener {\n    gotoPreview(it)\n}\n</code></pre><p>这里，我把这8种写法的演进过程以动图的形式展现了出来，让你对Lambda这几种写法的差异有一个更加直观的认识。</p><p><img src=\"https://static001.geekbang.org/resource/image/e4/bf/e441323968c0c061898257fd06db37bf.gif?wh=1080x608\" alt=\"图片\"></p><p>按照这个流程，在IDE里多写几遍，你自然就会理解了。一定要写，光看是记不住的。</p><p>好了，到这里，你就搞明白这些概念是什么意思了。下面我们来做一个小的总结，在后续的Kotlin学习当中，这些都是要铭记在心的。</p><ul>\n<li>将函数的参数类型和返回值类型抽象出来后，我们就得到了函数类型。比如<code>(View) -&gt; Unit</code> 就代表了参数类型是View，返回值类型为Unit的函数类型。</li>\n<li>如果一个函数的“参数”或者“返回值”的类型是函数类型，那这个函数就是高阶函数。很明显，我们刚刚就写了一个高阶函数，只是它比较简单而已。</li>\n<li>Lambda就是函数的一种简写。</li>\n</ul><p>然后，你也可以再通过一张图来回顾下函数类型、高阶函数以及Lambda表达式三者之间的关系：</p><p><img src=\"https://static001.geekbang.org/resource/image/ec/71/ecf85d05f6fdc5ea2d015a61d7e64771.png?wh=1920x914\" alt=\"图片\"></p><p>你也可以再回过头来看看官方文档提供的例子：</p><pre><code class=\"language-plain\">fun &lt;T, R&gt; Collection&lt;T&gt;.fold(\n    initial: R, \n    combine: (acc: R, nextElement: T) -&gt; R\n): R {\n    var accumulator: R = initial\n    for (element: T in this) {\n        accumulator = combine(accumulator, element)\n    }\n    return accumulator\n}\n</code></pre><p>你看到这个函数类型：(acc: R, nextElement: T) -&gt; R，是不是瞬间就懂了呢？这个函数接收了两个参数，第一个参数类型是R，第二个参数是T，函数的返回类型是R。</p><h2>难点：带接收者的函数类型</h2><p>那么现在，我们就把高阶函数这个知识点理解得有80%了。而在这节课一开始，我还提到，在Kotlin的函数类型这个知识点当中，还有一个特殊的概念，叫做<strong>带接收者的函数类型</strong>，它尤其晦涩难懂。</p><p>说实话，这个名字也对初学者不太友好，“带接收者的函数类型”，这里面的每一个字我都认识，可放到一块我就懵了。所以我们其实还是绕不开一个问题：为什么？</p><h3>为什么要引入带接收者的函数类型？</h3><p>这里，让我们先来看一下Kotlin的标准函数apply的使用场景。</p><p>不用 apply：</p><pre><code class=\"language-plain\">if (user != null) {\n    ...\n    username.text = user.name\n    website.text = user.blog\n    image.setOnClickListener { gotoImagePreviewActivity(user) }\n}\n</code></pre><p>使用apply：</p><pre><code class=\"language-plain\">user?.apply {\n    ...\n    username.text = name\n    website.text = blog\n    image.setOnClickListener { gotoImagePreviewActivity(this) }\n}\n</code></pre><p>请问这个apply方法应该怎么实现呢？</p><p>上面的写法其实是简化后的Lambda表达式，让我们来反推一下，看看它简化前是什么样的：</p><pre><code class=\"language-plain\">// apply 肯定是个函数，所以有 ()，只是被省略了\nuser?.apply() {\n    ...\n}\n\n// Lambda 肯定是在 () 里面\nuser?.apply({ ... })\n\n// 由于 gotoImagePreviewActivity(this) 里的 this 代表了 user\n// 所以 user 应该是 apply 函数的一个参数，而且参数名为：this\nuser?.apply({ this: User -&gt; ... })\n</code></pre><p>所以，现在问题非常明确了，apply其实是接收了一个Lambda表达式：<code>{ this: User -&gt; ... }</code>。那么现在，我们就尝试来实现这个apply方法：</p><pre><code class=\"language-plain\">fun User.apply(self: User, block: (self: User) -&gt; Unit): User{\n    block(self)\n    return this\n}\n\nuser?.apply(self = user) { self: User -&gt;\n            username.text = self.name\n            website.text = self.blog\n            image.setOnClickListener { gotoImagePreviewActivity(this) }\n}\n</code></pre><p>由于Kotlin里面的函数形参是不允许被命名为this的，因此我这里用的是self。另外，这里我们自己写出来的apply，仍然还要通过self.name这样的方式来访问成员变量，但Kotlin的语言设计者能做到这样：</p><pre><code class=\"language-plain\">//           改为this             改为this\n//               ↓                    ↓ \nfun User.apply(this: User, block: (this: User) -&gt; Unit): User{\n//    这里还要传参数\n//         ↓ \n    block(this)\n    return this\n}\n\nuser?.apply(this = user) { this: User -&gt;\n    ...\n//               this 可以省略\n//                   ↓ \n    username.text = this.name\n    website.text = blog\n    image.setOnClickListener { gotoImagePreviewActivity(this) }\n}\n</code></pre><p>从上面的例子能看到，我们反推的apply实现会比较繁琐：</p><ul>\n<li>需要我们传入this：user?.apply(this = user)。</li>\n<li>需要我们自己调用：block(this)。</li>\n</ul><p>因此，Kotlin就引入了带接收者的函数类型，可以简化apply的定义：</p><pre><code class=\"language-plain\">//              带接收者的函数类型\n//                     ↓  \nfun User.apply(block: User.() -&gt; Unit): User{\n//  不用再传this\n//       ↓ \n    block()\n    return this\n}\n\nuser?.apply { this: User -&gt;\n//               this 可以省略\n//                   ↓\n    username.text = this.name\n    website.text = this.blog\n    image.setOnClickListener { gotoImagePreviewActivity(this) }\n}\n</code></pre><p>现在，关键来了。上面的apply方法是不是看起来就像是在User里，增加了一个成员方法apply()？</p><pre><code class=\"language-plain\">class User() {\n    val name: String = \"\"\n    val blog: String = \"\"\n\n    fun apply() {\n        // 成员方法可以通过 this 访问成员变量\n        username.text = this.name\n        website.text = this.blog\n        image.setOnClickListener { gotoImagePreviewActivity(this) }\n    }\n}\n</code></pre><p>所以，从外表上看，带接收者的函数类型，就等价于成员方法。但<strong>从本质上讲，它仍是通过编译器注入this来实现的</strong>。</p><p>我们可以再通过一张图，来理解下什么是带接收者的函数类型：</p><p><img src=\"https://static001.geekbang.org/resource/image/9a/04/9acd54ac08d88c94ca52336a576b3304.png?wh=1890x1156\" alt=\"图片\"></p><p>看到这里，也许你会想起前面我们讲过的“扩展函数”。那么，带接收者的函数类型，是否也能代表扩展函数呢？</p><p>答案是肯定的。毕竟，<strong>从语法层面讲，扩展函数就相当于成员函数。</strong></p><h2>实战与思考</h2><p>在<a href=\"https://time.geekbang.org/column/article/475058\">第5讲</a>当中，我们实现了“单例的抽象类模板”，在课程的最后，我还给你留了一个思考题：</p><blockquote>\n<p>我们的抽象类模板BaseSingleton是否还有改进的空间？</p>\n</blockquote><p>这里，让我们先回顾一下BaseSingleton的代码：</p><pre><code class=\"language-plain\">                     \nabstract class BaseSingleton&lt;in P, out T&gt; {\n    @Volatile\n    private var instance: T? = null\n    //                       ①\n    //                       ↓\n    protected abstract fun creator(param: P): T\n\n    fun getInstance(param: P): T =\n        instance ?: synchronized(this) {\n            instance ?: creator(param).also { instance = it }\n    }\n}\n\nclass PersonManager private constructor(name: String) {\n    companion object : BaseSingleton&lt;String, PersonManager&gt;() {\n        override fun creator(param: String): PersonManager = PersonManager(param)\n    }\n}\n</code></pre><p>从上面的代码我们可以看到，BaseSingleton是单例抽象模板，而PersonManager则是实际的单例类。</p><p>在前面的<a href=\"https://time.geekbang.org/column/article/473349\">第2讲</a>里，我们就讨论过Person的isAdult应该是属性，而walk则应该是方法。那么现在，请看注释①，它是我们定义的一个抽象方法，名字叫做creator。这时候，相信你马上就能反应过来：creator应该定义成属性。</p><p>可是，<strong>如何才能将一个方法改成属性呢？</strong>答案当然就是刚学过的：<strong>高阶函数</strong>。</p><p>运用这节课学到的知识，我们很容易就能将creator改成一个类型为：<code>(P)-&gt;T</code>的属性，如下所示：</p><pre><code class=\"language-plain\">abstract class BaseSingleton&lt;in P, out T&gt; {\n    @Volatile\n    private var instance: T? = null\n    //               变化在这里，函数类型的属性\n    //                  ↓              ↓\n    protected abstract val creator: (P)-&gt; T\n\n    fun getInstance(param: P): T =\n        instance ?: synchronized(this) {\n            instance ?: creator(param).also { instance = it }\n    }\n}\n</code></pre><p>上面的代码中，我们将creator改成了一个抽象的属性，如果其他的单例类继承了BaseSingleton这个类，就必须实现这个creator属性。不过，这时候一个问题就出现了：<strong>PersonManager该怎么写呢？</strong></p><p>如果我们依葫芦画瓢，在实现creator的时候传入PersonManager的构造函数，会发现代码报错：类型不匹配。</p><pre><code class=\"language-plain\">class PersonManager private constructor(name: String) {\n    companion object : BaseSingleton&lt;String, PersonManager&gt;() {\n    //             报错，类型不匹配\n    //                  ↓ \n        override val creator = PersonManager(name)\n    }\n}\n</code></pre><p>这段代码报错的原因其实也很简单，creator的类型是一个(String)-&gt; PersonManager，而PersonManager构造函数这个表达式的值类型，是PersonManager类型。<strong>前者是函数类型，后者是普通对象类型</strong>。那么，如何才能正确实现creator这个函数类型的属性呢？</p><p>答案就是我们前面刚学的：<strong>函数引用</strong>！</p><pre><code class=\"language-plain\">class PersonManager private constructor(name: String) {\n    companion object : BaseSingleton&lt;String, PersonManager&gt;() {\n    //                             函数引用\n    //                                ↓ \n        override val creator = ::PersonManager\n    }\n}\n</code></pre><p>从上面的代码中可以看到，我们直接将PersonManager的构造函数，以函数引用的方式传给了creator这个属性，这样就成功地实现了这个函数类型的属性。</p><p>在这个案例里，我们将函数引用以及高阶函数应用到了单例抽象类模板当中，而在这个过程当中，我们也就能更加透彻地理解这两个特性的使用场景了。</p><p>这里我制作了一个代码的转换动图，帮你建立一个更加直观的认识。</p><p><img src=\"https://static001.geekbang.org/resource/image/49/5c/49b134d723c11c7d50762497b44afa5c.gif?wh=1080x608\" alt=\"图片\"></p><p>从这个动图里，我们可以清晰地看到某些元素的转移过程。比如泛型P、T，还有PersonManager的构造函数，这些都是代码中的关键元素。这些关键元素只是换了一种语法排列规则：<strong>从函数的语法变成了属性的语法，语法从复杂变得简洁，其中的关键元素并未丢失</strong>。</p><p>因此，这两种代码是完全等价的，但后者更加简洁易懂。</p><h2>小结</h2><p>到现在为止，咱们高阶函数部分的内容就进入尾声了。让我们再来做一次总结：</p><ul>\n<li><strong>为什么引入高阶函数？</strong>答：为了简化。</li>\n<li><strong>高阶函数是什么？</strong>答：函数作为参数or返回值。</li>\n<li><strong>函数类型是什么？</strong>答：函数的类型。</li>\n<li><strong>函数引用是什么？</strong>答：类比变量的引用。</li>\n<li><strong>Lambda是什么？</strong>答：可以简单理解为“函数的简写”（官方定义我们以后再讨论）。</li>\n<li><strong>带接收者的函数类型是什么？</strong>答：可以简单理解为“成员函数的类型”。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/45/3e/45e23ce48a64711943366fec784af23e.jpg?wh=1920x1171\" alt=\"图片\"></p><p>事实上，对于初学者来说，要一下子理解并掌握Kotlin“高阶函数”不是一件容易的事情。在掌握好这节课内容的基础上，我们可以尝试去读一些优秀的代码。</p><p>比如Kotlin官方的源代码<a href=\"https://github.com/JetBrains/kotlin/blob/1.5.30/libraries/stdlib/src/kotlin/util/Standard.kt\">StandardKt</a>，你可以去分析其中的with、let、also、takeIf、repeat、apply，来进一步加深对高阶函数的理解。还有就是<a href=\"https://github.com/JetBrains/kotlin/blob/1.5.30/libraries/stdlib/common/src/generated/_Collections.kt\">CollectionsKt</a>，你可以去分析其中的map、flatMap、fold、groupBy等操作符，从而对高阶函数的应用场景有一个更具体的认知。</p><p>另外，在<a href=\"https://time.geekbang.org/column/article/473349\">第</a><a href=\"https://time.geekbang.org/column/article/473349\">2讲</a>的时候，我们曾经提到过：理论上讲，Kotlin与Java是完全兼容的。那么问题来了，<strong>Kotlin引入全新的高阶函数，最终变成JVM字节码后是怎么执行呢？</strong>毕竟，JVM可不知道什么是高阶函数啊。</p><p>答案其实也很简单：<strong>匿名内部类</strong>。</p><p>而这样又引出了另一个问题：所以Kotlin弄了个这么高端的高阶函数，最终还是以匿名内部类的形式在运行呗？那它们两者的性能差不多？这不是多此一举吗？</p><p>答案当然是否定的，Kotlin高阶函数的性能，在极端情况下可以达到匿名内部类的100倍！具体是怎么回事儿呢？别着急，下节课讲“inline”时，我们就会来详细探讨。</p><h2>小作业</h2><p>请你去阅读一下Kotlin官方的标准函数库<a href=\"https://github.com/JetBrains/kotlin/blob/1.5.30/libraries/stdlib/src/kotlin/util/Standard.kt\">StandardKt的源代码</a>，尝试去解析其中任意一个高阶函数的原理和意义，并分享出来，我们一起探讨。</p><pre><code class=\"language-plain\">public inline fun &lt;R&gt; run(block: () -&gt; R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\npublic inline fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\npublic inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\npublic inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\npublic inline fun &lt;T&gt; T.also(block: (T) -&gt; Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n\npublic inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\npublic inline fun &lt;T&gt; T.takeIf(predicate: (T) -&gt; Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\npublic inline fun &lt;T&gt; T.takeUnless(predicate: (T) -&gt; Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\npublic inline fun repeat(times: Int, action: (Int) -&gt; Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n</code></pre><p>好了，这节课就到这里，如果觉得有收获，非常欢迎你把今天的内容分享给更多的朋友，咱们下节课再见。</p>","comments":[{"had_liked":false,"id":333652,"user_name":"没名儿","can_delete":false,"product_type":"c1","uid":1723397,"ip_address":"","ucode":"65B48705171730","user_header":"https://static001.geekbang.org/account/avatar/00/1a/4c/05/4fe55808.jpg","comment_is_top":false,"comment_ctime":1644459892,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"53184067444","product_id":100103401,"comment_content":"作者你好,提个意见,授课本来是一个循循渐进的事情,你这讲到最后,待接收者的函数类型,感觉直接垮了一个坑,各种概念都不清楚就直接拿来用了,我感觉十个人有九个都会掉坑里,本来感觉是一步一步的学习,这样一下就掉坑里了...希望这些跨度比较大的可以放到后面再讲....","like_count":13,"discussions":[{"author":{"id":2880329,"avatar":"","nickname":"Geek_c13afe","note":"","ucode":"CB6C00875813BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586138,"discussion_content":"到了这里，就看不懂了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1662001708,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"湖南"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550257,"discussion_content":"感谢这位同学的建议，以后我注意，你也不要轻易放弃哈~","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1644460644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2885387,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/07/0b/6cf80495.jpg","nickname":"小白 🇨🇳🚀","note":"","ucode":"F254DFEF93B775","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":553880,"discussion_content":"这个坑栽进去了QAQ ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1646124812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":550257,"ip_address":""},"score":553880,"extra":""},{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":2885387,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/07/0b/6cf80495.jpg","nickname":"小白 🇨🇳🚀","note":"","ucode":"F254DFEF93B775","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574073,"discussion_content":"我在后面的课程里也反复在用&#34;带接收者的函数类型&#34;，坚持看下去，后面还会有很多实际的用途。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1653819579,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":553880,"ip_address":""},"score":574073,"extra":""}]},{"author":{"id":2880329,"avatar":"","nickname":"Geek_c13afe","note":"","ucode":"CB6C00875813BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586143,"discussion_content":"老师，希望循序渐进讲解，这章看不懂呢。好多关键字是什么意思都看不懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662002023,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"湖南"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1191117,"avatar":"https://static001.geekbang.org/account/avatar/00/12/2c/cd/314156af.jpg","nickname":"天网_beta","note":"","ucode":"57F334F9AA8EAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580500,"discussion_content":"我暂时也不去理解了，光是那个T和P我就不理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658220025,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330232,"user_name":"小猪佩琪007","can_delete":false,"product_type":"c1","uid":1339771,"ip_address":"","ucode":"823E239A9B5496","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/7b/4b6079e6.jpg","comment_is_top":false,"comment_ctime":1641872892,"is_pvip":true,"replies":[{"id":"120381","content":"扛住哈！一遍看不懂就多看几遍，还有就是多写代码多调试。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641974778,"ip_address":"","comment_id":330232,"utype":1}],"discussion_count":4,"race_medal":0,"score":"44591545852","product_id":100103401,"comment_content":"遭了，是要掉队的感觉","like_count":11,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545486,"discussion_content":"扛住哈！一遍看不懂就多看几遍，还有就是多写代码多调试。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641974778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1339841,"avatar":"https://static001.geekbang.org/account/avatar/00/14/71/c1/cbc55e06.jpg","nickname":"白乾涛","note":"","ucode":"0C704B0B90C8D7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550880,"discussion_content":"你可以先不去管带接收者函数类型，去掉这一部门的话，这一章就讲了一个概念：可以使用函数作为参数或返回值。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1644767514,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2817839,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/ff/2f/eb03fccc.jpg","nickname":"maitian","note":"","ucode":"E974157AE36BAC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584886,"discussion_content":"哈哈哈 看来大家都忽然看不懂了~~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661182572,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2849755,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/7b/db/7cfa21ad.jpg","nickname":"droidYu","note":"","ucode":"154FEF1B561517","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557699,"discussion_content":"要掉队的感觉+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647936594,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346285,"user_name":"讲道理嘛","can_delete":false,"product_type":"c1","uid":1406882,"ip_address":"","ucode":"3AD4BD052D4413","user_header":"https://static001.geekbang.org/account/avatar/00/15/77/a2/7e9ae0b9.jpg","comment_is_top":false,"comment_ctime":1652982038,"is_pvip":false,"replies":[{"id":"126601","content":"没错，你的理解是对的。很赞~","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1653819290,"ip_address":"","comment_id":346285,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23127818518","product_id":100103401,"comment_content":"老师你好，关于带接收者的函数类型，我这样理解不知道对不对？<br>fun User.test1(block: (user: User) -&gt; Unit){}<br>fun User.test2(block: User.() -&gt; Unit){}<br><br>上面这两个高阶函数其实是等价的，只是在 lambda 表达式的使用时有区别。<br>前者的参数是 it，后者是 this(this 可以省略)","like_count":6,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574068,"discussion_content":"没错，你的理解是对的。很赞~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653819290,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338935,"user_name":"H.ZWei","can_delete":false,"product_type":"c1","uid":1329072,"ip_address":"","ucode":"48FFADE574C327","user_header":"https://static001.geekbang.org/account/avatar/00/14/47/b0/8c301d00.jpg","comment_is_top":false,"comment_ctime":1647818899,"is_pvip":false,"replies":[{"id":"124014","content":"这是个很不错的比喻，赞！","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1648030809,"ip_address":"","comment_id":338935,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14532720787","product_id":100103401,"comment_content":"带接收者的函数类型能不能理解成是这个类的扩展函数，只不过是一个匿名函数。","like_count":4,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557960,"discussion_content":"这是个很不错的比喻，赞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648030810,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330111,"user_name":"女孩子家家","can_delete":false,"product_type":"c1","uid":2883845,"ip_address":"","ucode":"F8EDCF8C01430D","user_header":"https://static001.geekbang.org/account/avatar/00/2c/01/05/b70b8ea1.jpg","comment_is_top":false,"comment_ctime":1641801257,"is_pvip":false,"replies":[{"id":"120310","content":"嗯，这也是高阶函数比较典型的应用场景。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641871301,"ip_address":"","comment_id":330111,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14526703145","product_id":100103401,"comment_content":"简化了页面跳转~<br>private const val FRIEND_ID = &quot;friendId&quot;<br><br>fun goto(mContext: Context, userId: Long) {<br>    mContext.goto&lt;ChatActivity&gt; {<br>\t\tputExtra(FRIEND_ID, userId)<br>    }<br>}<br><br>inline fun &lt;reified T&gt; Context.goto(block: Intent.() -&gt; Unit) {<br>    this.startActivity(intent&lt;T&gt;(this, block))<br>}<br><br>inline fun &lt;reified T&gt; intent(mContext: Context, block: Intent.() -&gt; Unit): Intent {<br>    val intent = Intent(mContext, T::class.java)<br>    intent.block()<br>    return intent<br>}","like_count":4,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545188,"discussion_content":"嗯，这也是高阶函数比较典型的应用场景。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641871301,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330438,"user_name":"20220106","can_delete":false,"product_type":"c1","uid":2884743,"ip_address":"","ucode":"DC9E91125B21C6","user_header":"","comment_is_top":false,"comment_ctime":1641977922,"is_pvip":false,"replies":[{"id":"120488","content":"这节课的内容确实比较绕，你也可以多看看文章里面的对比图，多体会一下。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1642042388,"ip_address":"","comment_id":330438,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5936945218","product_id":100103401,"comment_content":"apply和also这两个比较典型的，上下文对象作为【接收者】和作为【参数】，这两个的区别没太领会到","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545708,"discussion_content":"这节课的内容确实比较绕，你也可以多看看文章里面的对比图，多体会一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642042388,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2884743,"avatar":"","nickname":"20220106","note":"","ucode":"DC9E91125B21C6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545669,"discussion_content":"本质是一样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642037443,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360570,"user_name":"Geek_4f3885","can_delete":false,"product_type":"c1","uid":3204622,"ip_address":"广东","ucode":"6C740A77A657F7","user_header":"","comment_is_top":false,"comment_ctime":1666666749,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1666666749","product_id":100103401,"comment_content":"大佬，如果是多个参数的单例，有示例吗，单例那块没看懂","like_count":0},{"had_liked":false,"id":352438,"user_name":"zealyw","can_delete":false,"product_type":"c1","uid":1134188,"ip_address":"","ucode":"942F04E0C666CD","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/6c/dcf6e08d.jpg","comment_is_top":false,"comment_ctime":1658670814,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1658670814","product_id":100103401,"comment_content":"好像没有回答本章节的标题问题，为什么说函数是kotlin的一等公民呢","like_count":0,"discussions":[{"author":{"id":1342000,"avatar":"https://static001.geekbang.org/account/avatar/00/14/7a/30/23fc4089.jpg","nickname":"24隋心所欲","note":"","ucode":"1B8B2789F68C94","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591825,"discussion_content":"因为函数无处不在","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666845787,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"河北"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":348674,"user_name":"白菜","can_delete":false,"product_type":"c1","uid":1124092,"ip_address":"","ucode":"2F28541C9D8CF3","user_header":"https://static001.geekbang.org/account/avatar/00/11/26/fc/1c6bd0e4.jpg","comment_is_top":false,"comment_ctime":1655296877,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1655296877","product_id":100103401,"comment_content":"类似 setOnClickListener 的动图是怎么制作的？ 感觉很棒","like_count":0,"discussions":[{"author":{"id":1342000,"avatar":"https://static001.geekbang.org/account/avatar/00/14/7a/30/23fc4089.jpg","nickname":"24隋心所欲","note":"","ucode":"1B8B2789F68C94","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591826,"discussion_content":"作者前文说过，用PPT一帧一帧做出来的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666845827,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"河北"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2046527,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/3a/3f/51bdaec7.jpg","nickname":"十","note":"","ucode":"1036634F5FF96F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579950,"discussion_content":"ppt?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657783789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345621,"user_name":"没有昵称","can_delete":false,"product_type":"c1","uid":1123802,"ip_address":"","ucode":"4D19353A27F35D","user_header":"https://static001.geekbang.org/account/avatar/00/11/25/da/f8eb4742.jpg","comment_is_top":false,"comment_ctime":1652435276,"is_pvip":false,"replies":[{"id":"126604","content":"看看这个是不是你想要的。<br><br>```<br>fun handleTwoParameters(a: Int,b: Int):() -&gt;Int{<br>    fun tempPlusTwo() = plusTwo(a, b)<br>    return ::tempPlusTwo<br>}<br>val plusTwo:(Int,Int)-&gt;Int={x,y-&gt;x+y}<br><br>fun main() {<br>    val func = handleTwoParameters(1, 2)<br>    println(func()) &#47;&#47; 3<br>}<br>```","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1653820201,"ip_address":"","comment_id":345621,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1652435276","product_id":100103401,"comment_content":"fun handleTwoParameters(a: Int,b: Int):(Int,Int) -&gt;Int{<br>    return plusTwo<br>}<br>val plusTwo:(Int,Int)-&gt;Int={x,y-&gt;x+y}<br><br>各位大佬，如何把a和b的入参传给plusTwo使用","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574075,"discussion_content":"看看这个是不是你想要的。\n\n```\nfun handleTwoParameters(a: Int,b: Int):() -&gt;Int{\n    fun tempPlusTwo() = plusTwo(a, b)\n    return ::tempPlusTwo\n}\nval plusTwo:(Int,Int)-&gt;Int={x,y-&gt;x+y}\n\nfun main() {\n    val func = handleTwoParameters(1, 2)\n    println(func()) // 3\n}\n```","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653820201,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1123802,"avatar":"https://static001.geekbang.org/account/avatar/00/11/25/da/f8eb4742.jpg","nickname":"没有昵称","note":"","ucode":"4D19353A27F35D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572126,"discussion_content":"网上的博客在写把lambda表达式作为返回值得时候，原函数都是无参的方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652611179,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1123802,"avatar":"https://static001.geekbang.org/account/avatar/00/11/25/da/f8eb4742.jpg","nickname":"没有昵称","note":"","ucode":"4D19353A27F35D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572125,"discussion_content":"不是，我是想实现一下把lambda表达式作为返回值，同时可以把该函数的入参传给lambda表达式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652611065,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2327517,"avatar":"https://static001.geekbang.org/account/avatar/00/23/83/dd/e0f79039.jpg","nickname":"荒原","note":"","ucode":"E11C59C86AA82E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572088,"discussion_content":"fun handleTwoParameters(a: Int,b: Int): Int {\n    return plusTwo(a,b)\n}\nval plusTwo:(Int,Int)-&gt;Int={x,y-&gt;x+y}\n这样？，handleTwoParameters返回值要改变一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652596929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343860,"user_name":"Geek_518c5c","can_delete":false,"product_type":"c1","uid":1298230,"ip_address":"","ucode":"83B79CE18EF920","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqT3pba9RQEXAOHiaOMm3ibSicngJj3LAHaAQ9pa5N1I6A4RwNQ97LQeFAnLkQgaXBjHpW9xPYQVTaIA/132","comment_is_top":false,"comment_ctime":1651103641,"is_pvip":false,"replies":[{"id":"125632","content":"this指的是：user类的实例。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1651245277,"ip_address":"","comment_id":343860,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1651103641","product_id":100103401,"comment_content":"老师，<br>&#47;&#47;              带接收者的函数类型<br>&#47;&#47;                     ↓  <br>fun User.apply(block: User.() -&gt; Unit): User{    问1：User.()是什么意思 问2这一个行代表定义了一个User的扩展函数，对吗<br>&#47;&#47;  不用再传this  <br>&#47;&#47;       ↓ <br>    block()<br>    return this ------问3，这个this指向的是什么<br>}<br>","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568875,"discussion_content":"this指的是：user类的实例。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651245278,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343856,"user_name":"Geek_518c5c","can_delete":false,"product_type":"c1","uid":1298230,"ip_address":"","ucode":"83B79CE18EF920","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqT3pba9RQEXAOHiaOMm3ibSicngJj3LAHaAQ9pa5N1I6A4RwNQ97LQeFAnLkQgaXBjHpW9xPYQVTaIA/132","comment_is_top":false,"comment_ctime":1651100146,"is_pvip":false,"replies":[{"id":"125630","content":"代表：无参数","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1651245236,"ip_address":"","comment_id":343856,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1651100146","product_id":100103401,"comment_content":"<br>fun User.apply(block: User.() -&gt; Unit): User{   请教这里的 User.()中的（）代表什么意思。<br>","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568873,"discussion_content":"代表：无参数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651245236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":340976,"user_name":"张春亮","can_delete":false,"product_type":"c1","uid":1045303,"ip_address":"","ucode":"3921D2A256B2C9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f3/37/15baf151.jpg","comment_is_top":false,"comment_ctime":1649251190,"is_pvip":false,"replies":[{"id":"124719","content":"调用的时候才传参哈~","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1649434994,"ip_address":"","comment_id":340976,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1649251190","product_id":100103401,"comment_content":"&#47;&#47; 函数引用 <br>override val creator = ::PersonManager<br>函数引用中需要怎么去理解参数呢，因为并没有传参的地方","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560776,"discussion_content":"调用的时候才传参哈~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649434994,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":340713,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1649070641,"is_pvip":false,"replies":[{"id":"124601","content":"不错的笔记~","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1649134797,"ip_address":"","comment_id":340713,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1649070641","product_id":100103401,"comment_content":"顶级扩展函数编译成字节码，是 static 方法，参数多了一个 this<br><br>带接收者的函数类型编译成字节码，是一个匿名内部类，实现了 Functionx 接口，invoke 参数由编译器传入接收者实例；","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560036,"discussion_content":"不错的笔记~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649134797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338656,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1647649164,"is_pvip":false,"replies":[{"id":"124017","content":"很棒的答案！","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1648030918,"ip_address":"","comment_id":338656,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1647649164","product_id":100103401,"comment_content":"run：调用一个函数，作用仅仅限于构建lambda方便一点<br>带receiver的run：调用一个带receiver的函数，把this传给这个函数<br>with：用第一个参数调用第二个带receiver的函数，把this设定为第一个参数<br>apply：带receiver的函数高阶函数，参数为带receiver的函数，接受一个对象，把这个对象作为this传给参数并调用，返回this<br>also：和apply类似，但是参数是带一个参数的函数，接受对象传给参数，其余和apply一样<br>let：和apply类似，但是返回值不是this，而是函数的返回<br>takeIf：带receiver的函数高阶函数，参数是一个判断函数，结果判断结果为真就返回this，否者null<br>takeUnless：和take相反<br>repeat：参数为次数和函数，for循环执行函数<br>","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557963,"discussion_content":"很棒的答案！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648030918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338653,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1647647827,"is_pvip":false,"replies":[{"id":"124016","content":"很棒的解释！","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1648030870,"ip_address":"","comment_id":338653,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1647647827","product_id":100103401,"comment_content":"带接受者的函数，和C++的成员函数指针很像，限定了函数必须是类成员函数或者扩展函数。这带来了定义者和调用者两方面的变化:定义者可以方便的的引用类的公有成员和函数，调用者只能是类的成员函数或者扩展函数。apply函数是高阶函数，接受一个带接受者的函数，然后调用这个函数，并输出接受者对象。利用Lambda表达式,这个带接受者的函数在调用apply的地方构建出扩展函数，并传入apply，apply注入了this，调用函数和输出。如果没有带接受者的函数，函数就没法注入this和返回this，这对于apply这样的函数，就必须增加一个参数处理调用者，会繁琐很多。<br>","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557962,"discussion_content":"很棒的解释！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648030870,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336828,"user_name":"爱学习的小羊","can_delete":false,"product_type":"c1","uid":2883920,"ip_address":"","ucode":"9984EB84D7715B","user_header":"https://static001.geekbang.org/account/avatar/00/2c/01/50/c1556a25.jpg","comment_is_top":false,"comment_ctime":1646387050,"is_pvip":false,"replies":[{"id":"123153","content":"确实，但这终究是一种趋势了。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1646580998,"ip_address":"","comment_id":336828,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1646387050","product_id":100103401,"comment_content":"我怎么感觉这样代码事简洁了，但是对于不了解Lambda的人来说，阅读更费劲了","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554756,"discussion_content":"确实，但这终究是一种趋势了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646580998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336143,"user_name":"Omooo","can_delete":false,"product_type":"c1","uid":1138766,"ip_address":"","ucode":"FFADFDC72EC847","user_header":"https://static001.geekbang.org/account/avatar/00/11/60/4e/1c654d86.jpg","comment_is_top":false,"comment_ctime":1645952916,"is_pvip":false,"replies":[{"id":"122846","content":"有一个最简单的办法，就是将多个参数封装成一个数据类。这时候，在这里仍然只需要传一个参数。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1645967867,"ip_address":"","comment_id":336143,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1645952916","product_id":100103401,"comment_content":"老师想问一下，如果把 creator 定义成参数有多个的函数类型，该怎么去做呀？也没办法写成 <br>protected abstract val create: (vararg params: P) -&gt; T 呀？","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553567,"discussion_content":"有一个最简单的办法，就是将多个参数封装成一个数据类。这时候，在这里仍然只需要传一个参数。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645967867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":334153,"user_name":"白乾涛","can_delete":false,"product_type":"c1","uid":1339841,"ip_address":"","ucode":"0C704B0B90C8D7","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/c1/cbc55e06.jpg","comment_is_top":false,"comment_ctime":1644767417,"is_pvip":false,"replies":[{"id":"122094","content":"后面的课程有持续介绍这个概念，如果不是很明白，可以继续往后看哈。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1644851902,"ip_address":"","comment_id":334153,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1644767417","product_id":100103401,"comment_content":"感觉带接收者函数类型讲的太复杂了，单独抽出来放到后面某个章节讲更好一点。","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551020,"discussion_content":"后面的课程有持续介绍这个概念，如果不是很明白，可以继续往后看哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644851902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333642,"user_name":"没名儿","can_delete":false,"product_type":"c1","uid":1723397,"ip_address":"","ucode":"65B48705171730","user_header":"https://static001.geekbang.org/account/avatar/00/1a/4c/05/4fe55808.jpg","comment_is_top":false,"comment_ctime":1644458310,"is_pvip":false,"replies":[{"id":"121887","content":"带接收者的函数类型，这个概念在后面的课程里，我还会持续提到，现在没看懂没关系，后面还有机会加深印象哈~","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1644460760,"ip_address":"","comment_id":333642,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1644458310","product_id":100103401,"comment_content":"对于初学者,好多关键字,根本不知道,只能说理解概念吧,能看懂没天分还是放弃吧....","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550258,"discussion_content":"带接收者的函数类型，这个概念在后面的课程里，我还会持续提到，现在没看懂没关系，后面还有机会加深印象哈~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644460760,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331742,"user_name":"l-zesong","can_delete":false,"product_type":"c1","uid":2880199,"ip_address":"","ucode":"7BE93E5AAA3616","user_header":"https://static001.geekbang.org/account/avatar/00/2b/f2/c7/c5855ff3.jpg","comment_is_top":false,"comment_ctime":1642746539,"is_pvip":false,"replies":[{"id":"121176","content":"有点这个意思。不过，最根本的，还是将this注入到了Lambda当中。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1642755778,"ip_address":"","comment_id":331742,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1642746539","product_id":100103401,"comment_content":"带接收者函数类型，看完了，我感觉像是把扩展函数当做参数来传递，就是省了去写一个扩展函数？","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547579,"discussion_content":"有点这个意思。不过，最根本的，还是将this注入到了Lambda当中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642755778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331594,"user_name":"PoPlus","can_delete":false,"product_type":"c1","uid":1574765,"ip_address":"","ucode":"5F0927921317F2","user_header":"https://static001.geekbang.org/account/avatar/00/18/07/6d/4c1909be.jpg","comment_is_top":false,"comment_ctime":1642667081,"is_pvip":false,"replies":[{"id":"121180","content":"还可以作为返回值哈","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1642756982,"ip_address":"","comment_id":331594,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1642667081","product_id":100103401,"comment_content":"感觉高阶函数的作用就是能作为参数传递..","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547584,"discussion_content":"还可以作为返回值哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642756983,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331226,"user_name":"提醒圈圈去看书","can_delete":false,"product_type":"c1","uid":1329756,"ip_address":"","ucode":"86F5E3C4E2978A","user_header":"https://static001.geekbang.org/account/avatar/00/14/4a/5c/a786deb5.jpg","comment_is_top":false,"comment_ctime":1642491969,"is_pvip":false,"replies":[{"id":"121047","content":"你这样反推也是完全可以的，而且对于基础好的同学来说，可能会更直观一些。我在文章里的写法，是想照顾刚接触的同学。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1642557378,"ip_address":"","comment_id":331226,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1642491969","product_id":100103401,"comment_content":"老师，想要请教下，为什么user?.apply{}<br>为什么不能反推成<br>fun User.apply(block: (User) -&gt; Unit): User {<br>    block(this)<br>    return this<br>}呢","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547142,"discussion_content":"你这样反推也是完全可以的，而且对于基础好的同学来说，可能会更直观一些。我在文章里的写法，是想照顾刚接触的同学。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642557378,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330626,"user_name":"大顺子","can_delete":false,"product_type":"c1","uid":1236805,"ip_address":"","ucode":"E77E29439B6C71","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/45/e3dd6a83.jpg","comment_is_top":false,"comment_ctime":1642074176,"is_pvip":false,"replies":[{"id":"120607","content":"不错，讲的很详细，赞~","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1642133594,"ip_address":"","comment_id":330626,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1642074176","product_id":100103401,"comment_content":"1.第一个 run ，返回值为函数体最后一行，或指定 return 表达式<br>2.第二个 run ,在函数体中可以用 this 指代该对象，返回值为函数体最后一行，或指定 return 表达式<br>3.with 是将对象作为参数，在函数体中可以用 this 指代该对象，返回值为函数体最后一行，或指定 return 表达式<br>4.apply 在函数体内可以用 this 指代该对象，返回值为对象本身<br>5.also 在函数体内可以用 it 指代该对象,返回值为对象本身<br>6.let 在函数体内可以用 it 指代该对象,返回值为函数体最后一行，或指定 return 表达式<br>理解了上面那些，剩下的 takeIf 、takeUnless、repeat 就很好理解了。","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546033,"discussion_content":"不错，讲的很详细，赞~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642133594,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330421,"user_name":"zeki","can_delete":false,"product_type":"c1","uid":2732000,"ip_address":"","ucode":"BCFDED35064BE3","user_header":"https://static001.geekbang.org/account/avatar/00/29/af/e0/69a94af6.jpg","comment_is_top":false,"comment_ctime":1641973801,"is_pvip":false,"replies":[{"id":"120487","content":"这个问题很好，你的思考很有深度，我来说说我的看法吧。<br><br>你说的“根据具体值来推导出类型”，在我看来是一种“狭义的类型推导”，也就是“值推导出定义”，它也是Kotlin类型推导的典型代表。<br>比如：val i = 1<br><br>如你所说：<br>由于fun setOnClickListener(listener: ((View!) -&gt; Unit)?) ，listener的参数类型是确定的，因此Lambda的（：View）可以省略。那么，编译器如何能知道它是View类型的呢？还是根据((View!) -&gt; Unit)?)推导而来的。这在我看来是一种“广义的类型推导”，它的推导方向与你说的刚好相反，也就是“定义推导出值”。<br><br>另外，val test={x,y-&gt;x+y}，之所以是错误的，就是因为没有足够的信息让编译器来推导出Lambda的具体类型。<br><br>&#47;&#47; 值推导出定义类型，注意这里的var<br>var test = { x: Int, y: Int -&gt; x + y }<br>&#47;&#47; 定义推导出值类型，这里是重新赋值<br>test =  { x, y -&gt; x + y }<br><br>这么来看，&quot;定义推导值类型&quot;的情况在普通变量的场景下是站不住脚的，但在高阶函数的场景下，它还是有一定的意义。<br><br>当然，站在客观的角度上看，我也并不觉得你的说法有什么问题，我也更倾向于觉得我的表达不够严谨。<br><br>不过呢，文章的内容我就不去修改了，回头我找个加餐的机会，把我们讨论的内容分享出来，大家一起探讨（如果你不介意的话）。<br><br>总之，非常感谢你提出的这个问题，也期待以后你能分享更多的观点。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1642042264,"ip_address":"","comment_id":330421,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1641973801","product_id":100103401,"comment_content":"“第4种写法 由于 Kotlin 支持类型推导，所以 View 可以被删掉：”大佬您好，这句话是否不太准确？我的理解是：正常情况下，Kotlin的参数类型是不可以省略的，这里的View可以被删掉的原因不是因为“Kotlin 支持类型推导，所以 View可以被删掉”，而是因为如下代码所示：<br>fun setOnClickListener(l: ((View!) -&gt; Unit)?) <br>这个方法的参数变量 l 声明了函数类型为((View!) -&gt; Unit)?,所以Lambda的参数部分（：View）可以省略<br>就像<br>val test={x,y-&gt;x+y} 是错误的<br>而<br>val test:(Int,Int)-&gt;Int={x,y-&gt;x+y}是正确的一样<br>我理解的类型推导是“根据具体值来推导出类型”，而参数的值是不定的，所以参数的类型必须显式声明，返回值的类型是由参数的类型和值具体得出来的值,所以可以不需要显式声明,我这么想是否正确呢？","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545706,"discussion_content":"这个问题很好，你的思考很有深度，我来说说我的看法吧。\n\n你说的“根据具体值来推导出类型”，在我看来是一种“狭义的类型推导”，也就是“值推导出定义”，它也是Kotlin类型推导的典型代表。\n比如：val i = 1\n\n如你所说：\n由于fun setOnClickListener(listener: ((View!) -&gt; Unit)?) ，listener的参数类型是确定的，因此Lambda的（：View）可以省略。那么，编译器如何能知道它是View类型的呢？还是根据((View!) -&gt; Unit)?)推导而来的。这在我看来是一种“广义的类型推导”，它的推导方向与你说的刚好相反，也就是“定义推导出值”。\n\n另外，val test={x,y-&gt;x+y}，之所以是错误的，就是因为没有足够的信息让编译器来推导出Lambda的具体类型。\n\n// 值推导出定义类型，注意这里的var\nvar test = { x: Int, y: Int -&gt; x + y }\n// 定义推导出值类型，这里是重新赋值\ntest =  { x, y -&gt; x + y }\n\n这么来看，&#34;定义推导值类型&#34;的情况在普通变量的场景下是站不住脚的，但在高阶函数的场景下，它还是有一定的意义。\n\n当然，站在客观的角度上看，我也并不觉得你的说法有什么问题，我也更倾向于觉得我的表达不够严谨。\n\n不过呢，文章的内容我就不去修改了，回头我找个加餐的机会，把我们讨论的内容分享出来，大家一起探讨（如果你不介意的话）。\n\n总之，非常感谢你提出的这个问题，也期待以后你能分享更多的观点。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1642042265,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2732000,"avatar":"https://static001.geekbang.org/account/avatar/00/29/af/e0/69a94af6.jpg","nickname":"zeki","note":"","ucode":"BCFDED35064BE3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":545774,"discussion_content":"谢谢老师的耐心解答，非常感谢！(当然不介意)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642049436,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":545706,"ip_address":""},"score":545774,"extra":""}]}]},{"had_liked":false,"id":330321,"user_name":"better","can_delete":false,"product_type":"c1","uid":1169063,"ip_address":"","ucode":"AF1DB566EBB8A5","user_header":"https://static001.geekbang.org/account/avatar/00/11/d6/a7/ac23f5a6.jpg","comment_is_top":false,"comment_ctime":1641910236,"is_pvip":false,"replies":[{"id":"120379","content":"加油哈～","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641973986,"ip_address":"","comment_id":330321,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1641910236","product_id":100103401,"comment_content":"17年，我们内部组织培训kt，讲到这个 带接受者的函数类型，实在不好理解，大家晕乎乎滴。。。<br>看了老师的这个课，就很好理解啊，哎，自己太笨了，太笨了~~~。感谢分享~","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545483,"discussion_content":"加油哈～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641973986,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330170,"user_name":"A Lonely Cat","can_delete":false,"product_type":"c1","uid":2885349,"ip_address":"","ucode":"382EBFDD8E5115","user_header":"https://static001.geekbang.org/account/avatar/00/2c/06/e5/51ef9735.jpg","comment_is_top":false,"comment_ctime":1641827310,"is_pvip":false,"replies":[{"id":"120301","content":"这也是一个不错的例子。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641870880,"ip_address":"","comment_id":330170,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1641827310","product_id":100103401,"comment_content":"<br>import androidx.recyclerview.widget.RecyclerView<br><br>&#47;**<br> * Returns `true` if this adapter content is not empty.<br> *&#47;<br>inline fun &lt;reified VH : RecyclerView.ViewHolder&gt; RecyclerView.Adapter&lt;VH&gt;.isNotEmpty() =<br>    itemCount != 0<br><br>&#47;**<br> * Returns `true` if this adapter content is empty.<br> *&#47;<br>inline fun &lt;reified VH : RecyclerView.ViewHolder&gt; RecyclerView.Adapter&lt;VH&gt;.isEmpty() =<br>    itemCount == 0<br>","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545174,"discussion_content":"这也是一个不错的例子。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641870880,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330159,"user_name":"$Kotlin","can_delete":false,"product_type":"c1","uid":2148188,"ip_address":"","ucode":"098E9C8F60D865","user_header":"https://static001.geekbang.org/account/avatar/00/20/c7/5c/94cb3a1a.jpg","comment_is_top":false,"comment_ctime":1641821354,"is_pvip":false,"replies":[{"id":"120305","content":"一定要多练习，加油~","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641870947,"ip_address":"","comment_id":330159,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1641821354","product_id":100103401,"comment_content":"看了3遍，才感觉好像刚刚摸到了门槛。","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545180,"discussion_content":"一定要多练习，加油~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641870948,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330148,"user_name":"Will","can_delete":false,"product_type":"c1","uid":2722876,"ip_address":"","ucode":"8D07F51F9050E1","user_header":"https://static001.geekbang.org/account/avatar/00/29/8c/3c/bb79b9d7.jpg","comment_is_top":false,"comment_ctime":1641815575,"is_pvip":false,"replies":[{"id":"120307","content":"我会尽我最大的努力的。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641870975,"ip_address":"","comment_id":330148,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1641815575","product_id":100103401,"comment_content":"宁缺毋滥，但愿后面都是能将复杂问题说清晰的文章。","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545183,"discussion_content":"我会尽我最大的努力的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641870975,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330101,"user_name":"A Lonely Cat","can_delete":false,"product_type":"c1","uid":2885349,"ip_address":"","ucode":"382EBFDD8E5115","user_header":"https://static001.geekbang.org/account/avatar/00/2c/06/e5/51ef9735.jpg","comment_is_top":false,"comment_ctime":1641797722,"is_pvip":false,"replies":[{"id":"120312","content":"赞~","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641872178,"ip_address":"","comment_id":330101,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1641797722","product_id":100103401,"comment_content":"repeat <br>原理：给定的 Lambda（action） 表达式本质上是一个匿名类的单抽象方法，该扩展函数通过 for 循环调用。由于有 inline 关键字，所以在编译后该段代码的逻辑会复制到使用的地方，这样在性能上也能够得到满足。<br>意义：将给定的 Lambda（action） 表达式执行 times 次，简化 kotlin 中的 for 循环。","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545196,"discussion_content":"赞~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641872178,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}