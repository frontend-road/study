{"id":615345,"title":"11｜配置加载顺序：为什么你设置的超时时间不生效？","content":"<p>你好，我是何辉。今天我们探索Dubbo框架的第十道特色风味，配置加载顺序。</p><p>如何升级项目工程 pom 文件中某些 dependency 元素的版本号，想必你是轻车熟路了，一般情况下升级的版本都是向下兼容的，基本没问题，但如果跨越大版本升级，还是得多关注多验证一下，今天要解决的问题就是版本升级后出现的。</p><p>我们有这样一个敏感信息系统群，部分系统拓扑图如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/47/a6/472351157b114cfb04815f6db4d402a6.png?wh=1920x1054\" alt=\"图片\"></p><p>图中有提供方和消费方应用，都从 dubbo2 升级到了 dubbo3 版本，升级后放到测试环境验证了一圈都挺正常的，然而在发布日当晚，刚把系统发布到预发环境，就开始出现了一些消费方调用超时的现象，截取了一段异常日志：</p><pre><code class=\"language-java\">Caused by: org.apache.dubbo.remoting.TimeoutException: Waiting server-side response timeout by scan timer. start time: 2022-11-24 21:36:57.228, end time: 2022-11-24 21:36:58.246, client elapsed: 2 ms, server elapsed: 1016 ms, timeout: 1000 ms, request: Request [id=3, version=2.0.2, twoway=true, event=false, broken=false, data=RpcInvocation [methodName=decrypt, parameterTypes=[class java.lang.String], arguments=[Geek], attachments={path=com.hmilyylimh.cloud.facade.crypto.CryptoFacade, remote.application=dubbo-11-loadcfg-consumer, interface=com.hmilyylimh.cloud.facade.crypto.CryptoFacade, version=0.0.0, timeout=1000}]], channel: /192.168.100.183:49527 -&gt; /192.168.100.183:28110\n\tat org.apache.dubbo.remoting.exchange.support.DefaultFuture.doReceived(DefaultFuture.java:212)\n\tat org.apache.dubbo.remoting.exchange.support.DefaultFuture.received(DefaultFuture.java:176)\n\tat org.apache.dubbo.remoting.exchange.support.DefaultFuture$TimeoutCheckTask.notifyTimeout(DefaultFuture.java:295)\n\tat org.apache.dubbo.remoting.exchange.support.DefaultFuture$TimeoutCheckTask.lambda$run$0(DefaultFuture.java:282)\n\tat org.apache.dubbo.common.threadpool.ThreadlessExecutor$RunnableWrapper.run(ThreadlessExecutor.java:184)\n\tat org.apache.dubbo.common.threadpool.ThreadlessExecutor.waitAndDrain(ThreadlessExecutor.java:103)\n\tat org.apache.dubbo.rpc.AsyncRpcResult.get(AsyncRpcResult.java:193)\n\t... 29 more\n</code></pre><!-- [[[read_end]]] --><p>异常信息中竟然是 <code>timeout: 1000 ms</code>，简直不可思议，明明解密系统在暴露接口的时候指定了超时时间，为什么就没生效呢？</p><p>我们去扒一下提供方和消费方的代码，看看设置的超时时间：</p><pre><code class=\"language-java\">///////////////////////////////////////////////////\n// 提供方：应用配置类，用 Java 代码的编写方式代替了以前 XML 编写配置\n///////////////////////////////////////////////////\n@Configuration\npublic class LoadCfgProviderConfig {\n    // 提供者的应用服务名称\n    @Bean\n    public ApplicationConfig applicationConfig() {\n        return new ApplicationConfig(\"dubbo-11-loadcfg-provider\");\n    }\n    // 注册中心的地址，通过 address 填写的地址提供方就可以联系上 zk 服务\n    @Bean\n    public RegistryConfig registryConfig() {\n        return new RegistryConfig(\"zookeeper://127.0.0.1:2181\");\n    }\n    // 提供者需要暴露服务的协议，提供者需要暴露服务的端口\n    @Bean\n    public ProtocolConfig protocolConfig(){\n        return new ProtocolConfig(\"dubbo\", 28110);\n    }\n    // 提供者暴露接口的全路径为 com.hmilyylimh.cloud.facade.crypto.CryptoFacade 的服务过程\n    @Bean\n    public ServiceConfig&lt;CryptoFacade&gt; serviceConfigCryptoFacade(CryptoFacade cryptoFacade,\n                                                                ApplicationConfig applicationConfig,\n                                                                RegistryConfig registryConfig) {\n        // 创建服务发布的配置对象，类比于 &lt;dubbo:service/&gt; 标签的效果\n        ServiceConfig&lt;CryptoFacade&gt; serviceConfig = new ServiceConfig&lt;&gt;();\n        // 设置需要暴露接口的全路径，类比于 &lt;dubbo:service interface=\"com.hmilyylimh.cloud.facade.crypto.CryptoFacade\"&gt;&lt;/dubbo:service&gt; 标签中 interface 属性的效果\n        serviceConfig.setInterface(CryptoFacade.class);\n        // 设置需要暴露&lt;dubbo:service ref=\"cryptoFacade\"&gt;&lt;/dubbo:service&gt; 标签中 ref 属性的效果        \n        serviceConfig.setRef(cryptoFacade);\n        // 设置应用名称，类比于 &lt;dubbo:application name=\"dubbo-11-loadcfg-provider\"&gt;&lt;/dubbo:application&gt; 标签的效果\n        serviceConfig.setApplication(applicationConfig);\n        // 设置注&lt;dubbo:registry address=\"zookeeper://127.0.0.1:2181\"&gt;&lt;/dubbo:registry&gt; 标签的效果        \n        serviceConfig.setRegistry(registryConfig);\n        // 设置该 CryptoFacade 接口的默认超时时间为 5000 毫秒\n        serviceConfig.setTimeout(5000);\n        \n        // 专门指定 CryptoFacade 中的 decrypt 方法超时时间为 3000 毫秒\n        List&lt;MethodConfig&gt; methods = new ArrayList&lt;&gt;();\n        MethodConfig methodConfig = new MethodConfig();\n        methodConfig.setName(\"decrypt\");\n        methodConfig.setTimeout(3000);\n        methods.add(methodConfig);\n        serviceConfig.setMethods(methods);\n        \n        // 最终将 serviceConfig 对象导出服务（暴露服务过程）\n        serviceConfig.export();\n        return serviceConfig;\n    }\n}\n\n///////////////////////////////////////////////////\n// 提供方：加解密服务，目前只是实现了解密方法的实现逻辑\n///////////////////////////////////////////////////\n@Component\n@DubboService\npublic class CryptoFacadeImpl implements CryptoFacade {\n    @Override\n    public String decrypt(String encryptContent) {\n        // 睡眠 5000 毫秒，模拟解密耗时情况\n        TimeUtils.sleep(5 * 1000);\n        // 象征性的组装一下返回的明文结果\n        String result = String.format(\"密文为: %s, 解密后的明文为: %s\", encryptContent, \"PLAIN-\" + encryptContent);\n        // 顺便在提供方打印一下返回的结果\n        System.out.println(result);\n        return result;\n    }\n}\n\n///////////////////////////////////////////////////\n// 提供方：应用启动类\n///////////////////////////////////////////////////\n@EnableDubbo\n@SpringBootApplication\npublic class Dubbo11LoadcfgProviderApplication {\n    public static void main(String[] args) {\n        // 一行代码搞定 SpringBoot 应用的启动\n        SpringApplication.run(Dubbo11LoadcfgProviderApplication.class, args);\n        // 启动成功后，打印一下日志，方便肉眼可以直观的看到启动成功了\n        System.out.println(\"【【【【【【 Dubbo11LoadcfgProviderApplication 】】】】】】已启动.\");\n    }\n}\n\n///////////////////////////////////////////////////\n// 消费方：应用启动类\n///////////////////////////////////////////////////\n@ImportResource(\"classpath:dubbo-11-loadcfg-consumer.xml\")\n@SpringBootApplication\npublic class Dubbo11LoadcfgConsumerApplication {\n    public static void main(String[] args) {\n        // 一行代码搞定 SpringBoot 应用的启动\n        ConfigurableApplicationContext ctx =\n                SpringApplication.run(Dubbo11LoadcfgConsumerApplication.class, args);\n        // 启动成功后，打印一下日志，方便肉眼可以直观的看到启动成功了\n        System.out.println(\"【【【【【【 Dubbo11LoadcfgConsumerApplication 】】】】】】已启动.\");\n        // 然后模拟触发调用一下提供方的加解密服务\n        CryptoFacade cryptoFacade = ctx.getBean(CryptoFacade.class);\n        // 打印解密结果\n        System.out.println(cryptoFacade.decrypt(\"Geek\"));\n    }\n}\n\n///////////////////////////////////////////////////\n// 消费方：应用启动类的 @ImportResource 注解加载的\n// dubbo-11-loadcfg-consumer.xml 配置文件内容\n///////////////////////////////////////////////////\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:dubbo=\"http://dubbo.apache.org/schema/dubbo\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-4.3.xsd        http://dubbo.apache.org/schema/dubbo        http://dubbo.apache.org/schema/dubbo/dubbo.xsd\"&gt;\n    &lt;!-- 消费者的应用服务名称 --&gt;\n    &lt;dubbo:application name=\"dubbo-11-loadcfg-consumer\"&gt;&lt;/dubbo:application&gt;\n    &lt;!-- 注册中心的地址，通过 address 填写的地址提供方就可以联系上 zk 服务 --&gt;\n    &lt;dubbo:registry address=\"zookeeper://127.0.0.1:2181\"&gt;&lt;/dubbo:registry&gt;\n    &lt;!-- 引用加解密服务 --&gt;\n    &lt;dubbo:reference id=\"cryptoFacade\"\n            interface=\"com.hmilyylimh.cloud.facade.crypto.CryptoFacade\"&gt;&lt;/dubbo:reference&gt;\n&lt;/beans&gt;\n</code></pre><p>从提供方的暴露接口的代码来看，加解密服务的默认超时时间是 5000 毫秒（第37行），加解密服务中的解密方法设置的是 3000 毫秒（第43行），代码已经细化到方法级别来设置超时时间了，何况消费方也只是升级了 pom 文件的版本号，为什么发布到预发环境就超时了？太奇怪了。</p><p>这种现象，你会如何解决呢？</p><h2>Debug 调试</h2><p>现象摆在这了，在寻找解决方案之前，我们先来梳理下目前代码的现状，看看有没有突破口：</p><ul>\n<li>提供方和消费方都升级了 Dubbo 版本号。</li>\n<li>提供方为加解密服务明确指定了超时时间，消费方代码也没有指定超时时间。</li>\n<li>消费方和提供方都按照未升级之前的老样子进行调用。</li>\n</ul><p>到这里还是没有头绪，到底是提供方没有读取到3000毫秒？或是消费方没有获取到3000毫秒？还是消费方获取到了3000毫秒但不使用呢？</p><p>这里我教你一个小技巧，对于一些不知如何分析的问题，可以尽量尝试 Debug 调试一下，调试的过程，<strong>不但有助于你解决当下问题，还有助你更好地理解功能的调用流程。</strong></p><p>既然消费方发生了超时异常，那我们就从刚才这段超时异常开始吧。细看超时异常的调用堆栈：</p><pre><code class=\"language-java\">Caused by: org.apache.dubbo.remoting.TimeoutException: Waiting server-side response timeout by scan timer. start time: 2022-11-24 21:36:57.228, end time: 2022-11-24 21:36:58.246, client elapsed: 2 ms, server elapsed: 1016 ms, timeout: 1000 ms, request: Request [id=3, version=2.0.2, twoway=true, event=false, broken=false, data=RpcInvocation [methodName=decrypt, parameterTypes=[class java.lang.String], arguments=[Geek], attachments={path=com.hmilyylimh.cloud.facade.crypto.CryptoFacade, remote.application=dubbo-11-loadcfg-consumer, interface=com.hmilyylimh.cloud.facade.crypto.CryptoFacade, version=0.0.0, timeout=1000}]], channel: /192.168.100.183:49527 -&gt; /192.168.100.183:28110\n\tat org.apache.dubbo.remoting.exchange.support.DefaultFuture.doReceived(DefaultFuture.java:212)\n\tat org.apache.dubbo.remoting.exchange.support.DefaultFuture.received(DefaultFuture.java:176)\n\tat org.apache.dubbo.remoting.exchange.support.DefaultFuture$TimeoutCheckTask.notifyTimeout(DefaultFuture.java:295)\n\tat org.apache.dubbo.remoting.exchange.support.DefaultFuture$TimeoutCheckTask.lambda$run$0(DefaultFuture.java:282)\n\tat org.apache.dubbo.common.threadpool.ThreadlessExecutor$RunnableWrapper.run(ThreadlessExecutor.java:184)\n\tat org.apache.dubbo.common.threadpool.ThreadlessExecutor.waitAndDrain(ThreadlessExecutor.java:103)\n\tat org.apache.dubbo.rpc.AsyncRpcResult.get(AsyncRpcResult.java:193)\n\t... 29 more\n</code></pre><p>先是执行一个线程的 run 方法（RunnableWrapper.run），紧接着执行超时检测任务的通知超时方法（TimeoutCheckTask.notifyTimeout），最后执行了接收数据的核心方法（DefaultFuture.doReceived）。</p><p>乍一看，核心逻辑是在 DefaultFuture 中出现了异常，看到 Future 字样，相信你也想到了，在“<a href=\"https://time.geekbang.org/column/article/611392\">异步化实践</a>”中学过，Future 在获取结果时是支持传入超时时间的，那我们也来研究下 DefaultFuture 有没有超时参数。</p><p>看 DefaultFuture 的成员变量和一些方法的入参，在 DefaultFuture 的构造方法中发现了成员变量 timeout 的赋值逻辑：</p><pre><code class=\"language-java\">// DefaultFuture 构造方法\nprivate DefaultFuture(Channel channel, Request request, int timeout) {\n    // 向外发送数据的通道，比如可以是 NettyClient 操作 netty 来发送数据\n    this.channel = channel;\n    // 该对象包含发送至提供方的所有数据\n    this.request = request;\n    // 能够表示请求对象的唯一ID\n    this.id = request.getId();\n    // 接收构造方法中传入的 timeout 参数值\n    // 如果大于0则直接使用，否则直接从channel的url中获取\n    this.timeout = timeout &gt; 0 ? timeout : \n          channel.getUrl().getPositiveParameter(\"timeout\", 1000);\n    // 构建唯一ID与当前对象的关系，唯一ID与发送数据通道的关系\n    // put into waiting map.\n    FUTURES.put(id, this);\n    CHANNELS.put(id, channel);\n}\n</code></pre><p>构造方法支持 3 个参数的传入，其中一个就是 timeout 超时参数，如果 timeout 大于 0 ，直接使用，否则就从 channel 的 url 获取超时时间。</p><p>所以，接下来我们就要弄清楚 DefaultFuture 构造方法入参中的 timeout 是怎么计算出来的？</p><p>在刚刚找到的构造方法中，我们打上带条件的断点，来查看赋值 timeout 参数的源头在哪里：</p><p><img src=\"https://static001.geekbang.org/resource/image/cc/6e/ccd002cd86078ffa186e8424b909686e.jpg?wh=4191x1722\" alt=\"图片\"></p><p>接着 Debug 运行一下消费方，当来到断点的时候：</p><p><img src=\"https://static001.geekbang.org/resource/image/b9/3b/b9136e8c23b8b3c987087420eb92ae3b.png?wh=5334x1920\" alt=\"图片\"></p><p>找到图中断点所在的调用堆栈，一路向下点击查看 timeout 传参的源头：</p><p><img src=\"https://static001.geekbang.org/resource/image/71/b6/71e2a7c5de96691e705262798ba2f2b6.png?wh=5128x2777\" alt=\"图片\"></p><p>最终在 DubboInvoker 的 doInvoke 方法中，你会找到 timeout 参数的局部变量，看图中红框的位置，可以看到该局部变量的值是通过一个 calculateTimeout 方法计算得到的。</p><p>到目前为止，我们还没有找到可能造成超时异常问题的疑点，不过也别着急，毕竟计算 timeout 的源头在方法calculateTimeout里面，说明它还是挺关键的，我们不妨大致浏览下这个类的变量和方法，混个眼熟。</p><p>来看下 DubboInvoker 的成员变量和一些方法的入参，发现有个 Invoker 接口的集合 invokers 成员变量，而当前的 DubboInvoker 也是 Invoker 接口的子类，它们之间有什么关系呢？我们再来查看一下 invokers 内容：</p><p><img src=\"https://static001.geekbang.org/resource/image/2e/be/2ecacdaec2626ed58b06cb8d0f5f9bbe.jpg?wh=4680x1818\" alt=\"图片\"></p><p>奇怪的是，看红框可以发现当前 DubboInvoker 的 this 引用在 invokers 当中，而且 invokers 中的另外两个元素也是 DubboInvoker 类型的，我们根本看不出这3个元素有什么区别，难道 Dubbo 框架随机选择了 invokers 中的一个元素进行调用的么？</p><p>我们不妨继续展开 invokers 中的每个元素的成员变量：</p><p><img src=\"https://static001.geekbang.org/resource/image/3d/19/3d8ecc1534747e35bc543a5b39ab4119.jpg?wh=4464x2004\" alt=\"图片\"></p><p>可以很清楚地看到当前的 Invoker 引用，和其他几个引用中的 url 变量结构是不一样，为什么不一样呢？目前还是看不出什么端倪。</p><p>不过，可以发现 url 变量是从 DubboInvoker 的构造方法传入进来的，那我们继续在 DubboInvoker 的构造方法中打上条件断点，看看赋值 url 的源头到底是谁：</p><p><img src=\"https://static001.geekbang.org/resource/image/a1/be/a145868480de3d3fa9e4760d192ca4be.jpg?wh=1920x729\" alt=\"图片\"></p><p>再次 debug 运行一下消费方，关注调用堆栈，看看有什么不一样的地方：</p><p><img src=\"https://static001.geekbang.org/resource/image/0d/9f/0d9fd4935a62a7dd68e80b6395dccd9f.jpg?wh=5190x2415\" alt=\"图片\"></p><p>发现断点进入了多次，每次 invokers 都会增加一个，奇怪的是，有 1 次调用堆栈显示了 ServiceDiscoveryRegistryDirectory 这么一个类，这不就是 Dubbo 新版本的服务发现应用级订阅？而且当前 DubboInvoker 的 this 引用正好是这个服务发现的引用，难道 Dubbo 框架从 invokers 中选择了新版本的服务发现实例么？</p><h2>两个可疑点</h2><p>通过几次断点分析，我们从 DubboInvoker 中找到了两个引起 timeout 不能正确赋值的可疑点：</p><ol>\n<li>calculateTimeout 为什么没有得到正确的值？可以怎样得到正确的值呢？</li>\n<li>为什么使用的是新版本的服务发现类进行远程调用呢？</li>\n</ol><p>接下来，我们着重分析下这两个可疑点。</p><h3>可疑点一</h3><p>先分析可疑点一，首先要进入 calculateTimeout 方法看下具体逻辑，这里的逻辑比较深，不过没关系，我总结这个方法内部大致的代码调用流程，你可以参考：</p><p><img src=\"https://static001.geekbang.org/resource/image/86/27/865814e4cd1db440e6c9147a6e3yy627.png?wh=1920x840\" alt=\"图片\"></p><p>调用流程整体分为三大块，<strong>先取方法级别的参数，再取服务级别的参数，最后取实例级别的参数</strong>；在每一块的内部<strong>按照先取消费方，再提供方的顺序读取参数</strong>。</p><p>由于目前 Debug 运行时使用的 DubboInvoker 是新版本的服务发现实例，而且提供方加解密服务的 @DubboService 注解中没有配置任何超时时间，消费方的 XML 配置文件中也没有配置任何超时时间，这样一来，正好符合图中拿不到任何 timeout 参数值的现象，也就是说，拿到的是一个 null 。</p><p>如果你对这个结论抱着怀疑的态度，大可以放心去服务方加解密服务的 @DubboService 注解中修改下：</p><pre><code class=\"language-java\">@DubboService(timeout = 2800, methods = {@Method(\n        name = \"decrypt\",\n        timeout = 2400,\n        parameters = {\n                \"timeout\", \"2000\"\n        })}\n)\n</code></pre><p>在 @DubboService 注解中，为 decrypt 进行服务级别配置 timeout = 2800，方法级别配置 timeout = 2400，方法级别的参数配置 timeout = 2000。</p><p>最终，再启动提供方和消费方，你会看到消费方的超时异常日志中提示目前的超时时间 timeout = 2000。</p><pre><code class=\"language-java\">// 在提供方添加 timeout = 2800、timeout = 2400、timeout = 2000 里三个超时时间\n// 再次运行消费方后，看到的异常信息如下：\nCaused by: org.apache.dubbo.remoting.TimeoutException: Waiting server-side response timeout by scan timer. start time: 2022-11-25 23:20:46.834, end time: 2022-11-25 23:20:49.053, client elapsed: 1 ms, server elapsed: 2218 ms, timeout: 2200 ms, request: Request [id=3, version=2.0.2, twoway=true, event=false, broken=false, data=RpcInvocation [methodName=decrypt, parameterTypes=[class java.lang.String], arguments=[Geek], attachments={path=com.hmilyylimh.cloud.facade.crypto.CryptoFacade, remote.application=dubbo-11-loadcfg-consumer, interface=com.hmilyylimh.cloud.facade.crypto.CryptoFacade, version=0.0.0, timeout=2200}]], channel: /192.168.100.183:64923 -&gt; /192.168.100.183:28110\n\tat org.apache.dubbo.remoting.exchange.support.DefaultFuture.doReceived(DefaultFuture.java:212)\n\tat org.apache.dubbo.remoting.exchange.support.DefaultFuture.received(DefaultFuture.java:176)\n\tat org.apache.dubbo.remoting.exchange.support.DefaultFuture$TimeoutCheckTask.notifyTimeout(DefaultFuture.java:295)\n\tat org.apache.dubbo.remoting.exchange.support.DefaultFuture$TimeoutCheckTask.lambda$run$0(DefaultFuture.java:282)\n\tat org.apache.dubbo.common.threadpool.ThreadlessExecutor$RunnableWrapper.run(ThreadlessExecutor.java:184)\n\tat org.apache.dubbo.common.threadpool.ThreadlessExecutor.waitAndDrain(ThreadlessExecutor.java:103)\n\tat org.apache.dubbo.rpc.AsyncRpcResult.get(AsyncRpcResult.java:193)\n\t... 29 more\n</code></pre><p>对于这样的流程，回想你写代码配置服务级别或方法级别的参数时，有没有一种似曾相识的感觉，没错，都是遵循着“粒度越细，优先级越高”的方式来处理的。</p><p>严谨的你可能疑惑，@DubboService 中有三个地方（服务级别、方法级别、方法参数）可以添加超时时间，消费方 @DubboReference 注解也有三个地方可以配置，还有 dubbo.properties、启动命令-D参数这些地方都可以配置，那，<strong>到底该以谁的配置为准呢</strong>？</p><p>这个 calculateTimeout 计算超时时间的逻辑问题，其实 Dubbo 框架早就埋好了伏笔，在 Dubbo 3.0 开发手册 <a href=\"https://dubbo.apache.org/zh/docs3-v2/java-sdk/reference-manual/config/principle/#32-%E5%B1%9E%E6%80%A7%E8%A6%86%E7%9B%96\">Java -&gt; 参考手册 -&gt; 配置说明 -&gt; 配置工作原理 -&gt; 属性覆盖</a>为我们详细描述了不同层级配置之间的属性覆盖关系，不管是在消费方，还是在提供方，各自都按照这样的层级覆盖关系，然后在 calculateTimeout 方法中就能从消费方、提供方取到精准的超时时间。</p><p>在<a href=\"https://dubbo.apache.org/imgs/blog/configuration.jpg\">官网覆盖关系图</a>的基础之上，我们看看常用的配置写法，如图：</p><p><img src=\"https://static001.geekbang.org/resource/image/e4/1c/e47919148139eb4c4c17925yy808721c.png?wh=4716x2134\" alt=\"图片\"></p><p>主要有四个层级关系：</p><ul>\n<li>System Properties，最高优先级，我们一般会在启动命令中通过 JVM 的 -D 参数进行指定，图中通过 -D 参数从指定的磁盘路径加载配置，也可以从公共的 NAS 路径加载配置。</li>\n<li>Externalized Configuration，优先级次之，外部化配置，我们可以直接从统一的配置中心加载配置，图中就是从 Nacos 配置中心加载配置。</li>\n<li>API / XML / 注解，优先级再次降低，这三种应该是我们开发人员最熟悉不过的配置方式了。</li>\n<li>Local File，优先级最低，一般是项目中默认的一份基础配置，当什么都不配置的时候会读取。</li>\n</ul><p>看完四层覆盖关系，想必你已经知道如何解决超时不生效的问题了。</p><p>参考今天问题中的具体情况，因为升级了 Dubbo 版本，消费方自己没配置任何超时时间，提供方使用了 API 方式设置超时时间，但是消费方并不感知，反而消费方感知的是提供方 @DubboService 中配置的内容，那就意味着<strong>只要提供方有自己一套默认的超时时间，那消费方就会直接使用提供方的超时时间进行远程调用了</strong>。</p><p>所以，我们可以尝试在提供方的 resources 资源目录下新增一个 dubbo.properties 文件，配上默认的超时时间为 5000 毫秒：</p><pre><code class=\"language-java\"># 在提供方工程中的 resources/dubbo.properties 增加默认超时时间\ndubbo.provider.timeout=5000\n</code></pre><p>这样一来提供方就有了自己默认的一套超时时间了，消费方也不会走默认的 1000 毫秒超时逻辑了。</p><p>当然刚刚采用的是 Local File 优先级最低的方式进行配置的，你还可以通过其他三种方式进行配置，总之，哪种你使用起来最方便，又最适合你们目前项目的紧急诉求，配置哪种就行了。</p><h3>可疑点二</h3><p>虽然这个问题暂时解决了，但可疑点二我们还不知道原因，为什么使用的是新版本的服务发现类进行远程调用呢？</p><p>还记得我们在“<a href=\"https://time.geekbang.org/column/article/611355\">温故知新</a>”中在提供方和消费方中都提到过一个概念吗，应用级注册和接口级注册。提供方这边默认情况下，不但会进行应用级注册，还会进行接口级注册；而在消费方这边，有个智能决策的兼容过度方案，优先使用应用级注册信息。</p><p>所以，可疑点二这个问题，估计就是因为提供方走进了默认的注册服务策略，消费方那边又恰好采用的是智能决策策略，就变成使用新版本服务发现类进行远程调用了。</p><p>说到这，想必你已经想到如何应对了。我们可以在消费方设置只订阅接口级注册：</p><pre><code class=\"language-java\"># 在消费方工程中的 resources/dubbo.properties 增加只订阅接口级注册\ndubbo.application.service-discovery.migration=FORCE_INTERFACE\n</code></pre><p>也可以在提供方设置只进行接口级注册：</p><pre><code class=\"language-java\"># 在提供方工程中的 resources/dubbo.properties 增加只进行接口级注册\ndubbo.application.register-mode=interface\n</code></pre><p>这样一来，虽然升级到了 Dubbo3 版本，但其实还是走着 Dubbo2 旧的分支逻辑，这也侧面佐证了 Dubbo3 对 Dubbo2 的向下兼容友好特性。</p><h2>不同层级配置的适用场景</h2><p>从 Dubbo 框架的四层属性覆盖关系可以看出，一个简单的配置居然有如此之多的配置来源，那它们的应用场景有什么区别么？</p><p>System Properties，一般是固定不能被覆盖的参数，这些参数基本上不会变化，由运维人员按照公司的标准化 JVM 启动参数统一控制应用。</p><p>Externalized Configuration，一般是偏应用系统层面的公共参数，可以从公共的配置中心读取，这些参数很大程度上也不会经常变化，一旦遇到突发情况或想统一修改公共参数，可以在不改代码的情况下，通过重启或动态加载最新配置。</p><p>API / XML / 注解，这种属于开发层面比较个性化的配置方式了，主要是因为实际开发的项目中，不同的功能，需要根据实际情况合理配置不同的参数。</p><p>Local File，这种属于兜底级别了，如果其他层级都没有配置的话，至少还有个当前系统全局默认的兜底配置。</p><h2>总结</h2><p>今天，从系统跨越版本升级而引发的超时时间失效的问题开始，我们针对代码的三个现状，开启了 Debug 调试分析之旅，简单几步调试之后，找到了 timeout 无法获取预期值的源头，同时也发现了破解问题的两个关键可疑点：</p><ul>\n<li>从可疑点一中，仔细研读计算超时时间的方法，挖掘出了 Dubbo 配置的四层覆盖关系，最终我们巧妙利用不同层级的特性，解决了超时时间失效的问题。</li>\n<li>从可疑点二中，发现类名使用了新版本的服务发现类进行远程调用，联想到了应用级注册和接口级注册的因素，最终也找到了解决超时时间失效的方案。</li>\n</ul><p>消费方在发起远程调用时，超时时间的取值逻辑要记牢：</p><ul>\n<li>首先，整体分为三大块，分别为方法级别、服务级别、实例级别。</li>\n<li>然后，在每一块的内部，按照先消费方后提供方的的顺序进行取值。<br>\nDubbo 配置的四层覆盖关系，优先级从高到低依次为：System Properties、Externalized Configuration、API / XML / 注解、Local File。</li>\n</ul><p>最后如果提供方和消费方按照接口级注册使用，提供方指定注册模式（dubbo.application.register-mode）为接口级（interface），消费方服务发现迁移模式（dubbo.application.service-discovery.migration）为接口级（FORCE_INTERFACE）。</p><h3>思考题</h3><p>留个作业给你，在工作中，你会需要使用外部配置中心来存储配置，在 Nacos 中很可能会出现这样的报错场景：</p><p><img src=\"https://static001.geekbang.org/resource/image/79/8f/791ffd5a0532106f2f3fde33f137e48f.jpg?wh=1920x930\" alt=\"图片\"></p><p>再次新建一条记录，内容为 dataId = dubbo.properties，group = dubbo，添加完再点击提交就报错了，你知道这是为什么吗？</p><p>公司里面那么多应用系统，如果按照图中这样配置所有应用都使用同一份 dubbo.properties 属性内容，未免有点糟糕，该怎么遵循 Nacos 的规范正确填写 &lt;dubbo:config-center/&gt; 标签里面的内容呢？</p><p>欢迎在留言区分享你的思考和学习心得。我们下节课再见。</p><h3>10思考题参考</h3><p>上一期留了一个作业，TokenFilter、ConsumerSignFilter、ProviderAuthFilter 这三个过滤器是干什么用的，以及如何应用？</p><p>首先进入 TokenFilter 的源码底层看看：</p><pre><code class=\"language-java\">/**\n * Perform check whether given provider token is matching with remote token or not. If it does not match\n * it will not allow invoking remote method.\n *\n * @see Filter\n */\n@Activate(group = CommonConstants.PROVIDER, value = TOKEN_KEY)\npublic class TokenFilter implements Filter {\n    @Override\n    public Result invoke(Invoker&lt;?&gt; invoker, Invocation inv)\n            throws RpcException {\n        // 参数一：可以设置 token 参数\n        String token = invoker.getUrl().getParameter(\"token\");\n        // 如果设置有值，那么就直接和接收的 token 两两做比较\n        if (ConfigUtils.isNotEmpty(token)) {\n            Class&lt;?&gt; serviceType = invoker.getInterface();\n            Map&lt;String, Object&gt; attachments = inv.getObjectAttachments();            \n            // 从接收的参数中获取消费方发来的 token 值\n            String remoteToken = (attachments == null ? null : (String) attachments.get(\"token\"));\n            if (!token.equals(remoteToken)) {\n                // 如果比对不一致的话，则抛出异常\n                throw new RpcException(\"Invalid token! Forbid invoke remote service \" + serviceType + \" method \" + inv.getMethodName() +\n                        \"() from consumer \" + RpcContext.getServiceContext().getRemoteHost() + \" to provider \" +\n                        RpcContext.getServiceContext().getLocalHost()+ \", consumer incorrect token is \" + remoteToken);\n            }\n        }\n        return invoker.invoke(inv);\n    }\n}\n</code></pre><p>阅读 TokenFilter 源码，可以得出 2 点信息：</p><ol>\n<li>TokenFilter 只作用在提供方。</li>\n<li>提供方可以通过参数 token 来配置值，如果消费方没传 token，或者消费方传错了 token，最终都会导致提供方这边校验不通过，一旦不通过就会抛出异常。</li>\n</ol><p>不难看出，其实 TokenFilter 就是来做鉴定真假的，和我们之前写的 ProviderTokenFilter 思路非常相似。</p><p>然后进入 ConsumerSignFilter 的源码底层看看：</p><pre><code class=\"language-java\">@Activate(group = CommonConstants.CONSUMER, value = Constants.SERVICE_AUTH, order = -10000)\npublic class ConsumerSignFilter implements Filter {\n    private ApplicationModel applicationModel;\n    public ConsumerSignFilter(ApplicationModel applicationModel) {\n        this.applicationModel = applicationModel;\n    }\n    @Override\n    public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException {\n        URL url = invoker.getUrl();\n        // 参数一：可以设置 auth 参数，看看要不要开启认证功能\n        boolean shouldAuth = url.getParameter(\"auth\", false);\n        if (shouldAuth) {\n            // 如果开启了认证功能的话，那么就直接将请求参数进行加签\n            // 然后放到 invocation 中的 attachments 中，顺路传到提供方去\n            Authenticator authenticator = applicationModel.getExtensionLoader(Authenticator.class)\n              .getExtension(url.getParameter(\"authenticator\", \"accesskey\"));\n            // 通过 url 获取的默认扩展点进行加签操作\n            // 当然既然是从 url 获取的扩展点，那么就提供了自定义的扩展口子\n            authenticator.sign(invocation, url);\n        }\n        return invoker.invoke(invocation);\n    }\n}\n</code></pre><p>可以得出 3 点信息：</p><ol>\n<li>ConsumerSignFilter 只作用在消费方。</li>\n<li>有个 auth 参数来决定是否开启加签操作，如果开启了那就进行加签，并把加签后的值顺道传给提供方。</li>\n<li>加签的核心逻辑是可以扩展的，通过设置 authenticator = xxx 就可以实现自定义加签逻辑。</li>\n</ol><p>ConsumerSignFilter 就是来做加签操作的，和我们之前写的 ConsumerAddSignFilter 思路非常相似。</p><p>最后进入 ProviderAuthFilter 的源码底层看看：</p><pre><code class=\"language-java\">@Activate(group = CommonConstants.PROVIDER, order = -10000)\npublic class ProviderAuthFilter implements Filter {\n    private ApplicationModel applicationModel;\n    public ProviderAuthFilter(ApplicationModel applicationModel) {\n        this.applicationModel = applicationModel;\n    }\n    @Override\n    public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException {\n        URL url = invoker.getUrl();\n        // 参数一：可以设置 auth 参数，看看要不要开启认证功能\n        boolean shouldAuth = url.getParameter(\"auth\", false);\n        if (shouldAuth) {\n            // 如果开启了认证功能的话，那么就直接进行验签操作\n            Authenticator authenticator = applicationModel.getExtensionLoader(Authenticator.class)\n              .getExtension(url.getParameter(\"authenticator\", \"accesskey\"));\n            try {\n                // 通过 url 获取的默认扩展点进行验签操作\n                // 当然既然是从 url 获取的扩展点，那么就提供了自定义的扩展口子\n                authenticator.authenticate(invocation, url);\n            } catch (Exception e) {\n                return AsyncRpcResult.newDefaultAsyncResult(e, invocation);\n            }\n        }\n        return invoker.invoke(invocation);\n    }\n}\n</code></pre><p>可以得出 3 点信息：</p><ol>\n<li>ProviderAuthFilter 只作用在提供方。</li>\n<li>也有个 auth 参数来决定要不要开启验签操作，如果开启了那么进行验签，验签不通过的话则会直接抛出异常。</li>\n<li>验签核心逻辑也是可以支持扩展的，通过设置 authenticator = xxx 就可以实现自定义验签逻辑。</li>\n</ol><p>我们也不难得出，ConsumerSignFilter、ProviderAuthFilter 两个是成对存在的，前者负责加签，后者负责验签，和我们之前写的 ConsumerAddSignFilter、ProviderVerifySignFilter 思路也非常相似。</p>","neighbors":{"left":{"article_title":"10｜服务认证：被异构系统侵入调用了，怎么办？","id":615318},"right":{"article_title":"12｜源码框架：框架在源码层面如何体现分层？","id":615369}},"comments":[{"had_liked":false,"id":376090,"user_name":"javaxu","can_delete":false,"product_type":"c1","uid":1060506,"ip_address":"上海","ucode":"1B5C452681AEF8","user_header":"","comment_is_top":false,"comment_ctime":1686276960,"is_pvip":false,"replies":[{"id":138224,"content":"你好，javaxu：找寻通过 NacosService 拉取数据的核心关键口子，然后研究一番是怎么读取 nacos 配置的，相信你一下就能找到突破口的。","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1691889577,"ip_address":"广东","comment_id":376090,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312101,"comment_content":"想问下如何结合nacos 动态修改超时时间呢？","like_count":0,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":625560,"discussion_content":"你好，javaxu：找寻通过 NacosService 拉取数据的核心关键口子，然后研究一番是怎么读取 nacos 配置的，相信你一下就能找到突破口的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1691889577,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":375238,"user_name":"飞飞","can_delete":false,"product_type":"c1","uid":1118395,"ip_address":"北京","ucode":"31BEBE1325DE19","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/bb/1616a0aa.jpg","comment_is_top":false,"comment_ctime":1685099553,"is_pvip":false,"replies":[{"id":137077,"content":"你好，飞飞：服务端配置了我timeout 后，最后会被消费者订阅，这样对于消费者而言，就天然有了两套，一套啥消费者本身设置的，一套是提供方订阅回来的，把握消费方优先，颗粒度越小越优先原则就好啦～","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1685618783,"ip_address":"广东","comment_id":375238,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312101,"comment_content":"老师，比如客户端，服务端 都配置了 timeout 这个属性，那这个以哪个为准，能展开讲讲这类在客户端、服务端都配置了属性的覆盖规则吗？","like_count":0,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":619930,"discussion_content":"你好，飞飞：服务端配置了我timeout 后，最后会被消费者订阅，这样对于消费者而言，就天然有了两套，一套啥消费者本身设置的，一套是提供方订阅回来的，把握消费方优先，颗粒度越小越优先原则就好啦～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1685618783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370905,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"北京","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1679369101,"is_pvip":false,"replies":[{"id":135819,"content":"你好，张三丰：不是不识别 api 的配置，而是在新老版本兼容的情况下，其实在消费方是有 api 的 invoke 对象的，只是因为消费方的订阅策略，所以选择了注解上的配置。对于这种新老版本兼容的情况，一定要周全的将一些重要的配置，该默认的都显示的默认好，并且做好策略的精准对应，方能很好的进行过度。","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1680791907,"ip_address":"广东","comment_id":370905,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312101,"comment_content":"老师，下边这句话对意思就是dubbo3.0只能识别注解上的配置？ 不识别api的配置？\n\n\n参考今天问题中的具体情况，因为升级了 Dubbo 版本，消费方自己没配置任何超时时间，提供方使用了 API 方式设置超时时间，但是消费方并不感知，反而消费方感知的是提供方 @DubboService 中配置的内容。","like_count":0,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612589,"discussion_content":"你好，张三丰：不是不识别 api 的配置，而是在新老版本兼容的情况下，其实在消费方是有 api 的 invoke 对象的，只是因为消费方的订阅策略，所以选择了注解上的配置。对于这种新老版本兼容的情况，一定要周全的将一些重要的配置，该默认的都显示的默认好，并且做好策略的精准对应，方能很好的进行过度。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680791907,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370809,"user_name":"夏帆","can_delete":false,"product_type":"c1","uid":3033735,"ip_address":"广东","ucode":"D4C9DCD01E85AD","user_header":"https://static001.geekbang.org/account/avatar/00/2e/4a/87/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1679299622,"is_pvip":false,"replies":[{"id":135815,"content":"你好，夏帆：可以参考下【org.apache.dubbo.common.URL#getMethodParameter(java.lang.String, java.lang.String, int)】这个方法，然后想办法替换其中对应属性的值。","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1680789474,"ip_address":"广东","comment_id":370809,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312101,"comment_content":"想问一下作者，加入我希望在dubbo的扩展点filter里面去动态的修改当前请求服务的超时时间应该怎么做呢","like_count":0,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612576,"discussion_content":"你好，夏帆：可以参考下【org.apache.dubbo.common.URL#getMethodParameter(java.lang.String, java.lang.String, int)】这个方法，然后想办法替换其中对应属性的值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680789474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370325,"user_name":"徐有鱼","can_delete":false,"product_type":"c1","uid":1245588,"ip_address":"浙江","ucode":"256153BB4E58E8","user_header":"","comment_is_top":false,"comment_ctime":1678717245,"is_pvip":false,"replies":[{"id":135078,"content":"你好，徐有鱼：因为提供方要注册，假设当作一个很普通的提供方服务方，那么这个提供服务方有哪些参数设置的能力，是不是得告诉别人，这样别人才能根据参数因地制宜的做出相应的对策，所以这也就是为什么提供方的一些参数需要通过注册的方式向别人宣告提供方的能力限制范围。\n\n但是恰巧这个场景是因为有接口级消费、应用级消费，混在一起，造成了这样的现象。","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1678807936,"ip_address":"广东","comment_id":370325,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312101,"comment_content":"为什么提供方Local File方式的配置能被消费方拿到，而提供方API方式设置的超时时间消费方并不感知？优先级不也是API方式大于Local File方式吗？","like_count":0,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609088,"discussion_content":"你好，徐有鱼：因为提供方要注册，假设当作一个很普通的提供方服务方，那么这个提供服务方有哪些参数设置的能力，是不是得告诉别人，这样别人才能根据参数因地制宜的做出相应的对策，所以这也就是为什么提供方的一些参数需要通过注册的方式向别人宣告提供方的能力限制范围。\n\n但是恰巧这个场景是因为有接口级消费、应用级消费，混在一起，造成了这样的现象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678807936,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":369728,"user_name":"杨老师","can_delete":false,"product_type":"c1","uid":1734888,"ip_address":"北京","ucode":"669564E5A757E0","user_header":"","comment_is_top":false,"comment_ctime":1677843837,"is_pvip":false,"replies":[{"id":134833,"content":"你好，杨老师：我在文中有这样一段描述〖因为提供方走进了默认的注册服务策略，消费方那边又恰好采用的是智能决策策略，就变成使用新版本服务发现类进行远程调用了。〗\n\n对于消费方而言，提供方通过API形式、注解形式的数据其实都在消费方的invokers中，只不过消费方总是有使用订阅策略的，恰巧使用到了新版的策略。","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1678116394,"ip_address":"广东","comment_id":369728,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312101,"comment_content":"老师，消费方为什么感知不到提供方以 API 方式设置的超时时间，提供方将这些信息也写到注册中心了呀。\n\n希望老师帮忙解答下","like_count":0,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":607783,"discussion_content":"你好，杨老师：我在文中有这样一段描述〖因为提供方走进了默认的注册服务策略，消费方那边又恰好采用的是智能决策策略，就变成使用新版本服务发现类进行远程调用了。〗\n\n对于消费方而言，提供方通过API形式、注解形式的数据其实都在消费方的invokers中，只不过消费方总是有使用订阅策略的，恰巧使用到了新版的策略。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678116394,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368234,"user_name":"Geek_5a425f","can_delete":false,"product_type":"c1","uid":3523198,"ip_address":"北京","ucode":"B1EB3CA5030AF9","user_header":"","comment_is_top":false,"comment_ctime":1676024154,"is_pvip":false,"replies":[{"id":134290,"content":"你好，Geek_5a425f：你理解是对的，可以从 DefaultFuture 源码类的构造方法可以看出来的。","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1676624438,"ip_address":"广东","comment_id":368234,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312101,"comment_content":"如果双方都不配，那默认是使用消费方的默认超时时间1000ms，也就是case 中1S 超时。","like_count":0,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":605352,"discussion_content":"你好，Geek_5a425f：你理解是对的，可以从 DefaultFuture 源码类的构造方法可以看出来的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676624438,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368233,"user_name":"Geek_5a425f","can_delete":false,"product_type":"c1","uid":3523198,"ip_address":"北京","ucode":"B1EB3CA5030AF9","user_header":"","comment_is_top":false,"comment_ctime":1676023736,"is_pvip":false,"replies":[{"id":134291,"content":"你好，Geek_5a425f：所谓的粒度越细，比如一个类有N个方法，那么方法就比类的粒度越细。也可以理解为越精确的地方粒度就越细。","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1676624626,"ip_address":"广东","comment_id":368233,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312101,"comment_content":"『都是遵循着“粒度越细，优先级越高”的方式来处理的。』\n【先取方法级别的参数，再取服务级别的参数，最后取实例级别的参数】\n老是，我理解应该实例级别的参数优先级最高，这个理解有问题吗？","like_count":0,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":605381,"discussion_content":"你好，Geek_5a425f：所谓的粒度越细，比如一个类有N个方法，那么方法就比类的粒度越细。也可以理解为越精确的地方粒度就越细。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676624626,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":367076,"user_name":"阿昕","can_delete":false,"product_type":"c1","uid":1012906,"ip_address":"浙江","ucode":"F3AD093B68E074","user_header":"https://static001.geekbang.org/account/avatar/00/0f/74/aa/178a6797.jpg","comment_is_top":false,"comment_ctime":1674895057,"is_pvip":false,"replies":[{"id":133805,"content":"你好，阿昕：你理解的很到位，确实是的，同一个namespace下的group+dataId不能重复。","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1675148472,"ip_address":"广东","comment_id":367076,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312101,"comment_content":"思考题，nacos的配置级别依次为：namespace-&gt;data group-&gt;data id，同一个namespace下的group+dataId不能重复；dubbo的配置从namspace、group两个维度进行拆分，在使用上更符合服务配置的预期","like_count":0,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":601216,"discussion_content":"你好，阿昕：你理解的很到位，确实是的，同一个namespace下的group+dataId不能重复。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675148472,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366399,"user_name":"y","can_delete":false,"product_type":"c1","uid":1437320,"ip_address":"广东","ucode":"A05013A1615FF5","user_header":"https://static001.geekbang.org/account/avatar/00/15/ee/88/81ccde9a.jpg","comment_is_top":false,"comment_ctime":1673703210,"is_pvip":false,"replies":[{"id":133522,"content":"你好，y：消费方能感知到提供方API设置的参数，主要是提供方将这些信息写到了注册中心，消费方一旦订阅提供方的接口，然后就能感知提供方在API设置的这些参数了。如果想再找找感觉认识一下的话，可以留意后续的“第 25 章节，注册扩展”。","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1673831312,"ip_address":"湖南","comment_id":366399,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312101,"comment_content":"老师，消费方并不感知提供方以 API 方式设置的超时时间，这个是 dubbo 本身的限制么，对 dubbo 不是很熟悉。","like_count":0,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":599814,"discussion_content":"你好，y：消费方能感知到提供方API设置的参数，主要是提供方将这些信息写到了注册中心，消费方一旦订阅提供方的接口，然后就能感知提供方在API设置的这些参数了。如果想再找找感觉认识一下的话，可以留意后续的“第 25 章节，注册扩展”。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673831312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖南","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366133,"user_name":"熊悟空的凶","can_delete":false,"product_type":"c1","uid":1933459,"ip_address":"北京","ucode":"5FA9498BDA92C0","user_header":"https://static001.geekbang.org/account/avatar/00/1d/80/93/dde3d5f0.jpg","comment_is_top":false,"comment_ctime":1673418915,"is_pvip":false,"replies":[{"id":133428,"content":"你好，熊悟空的凶：你的思路方向是对的，有了这些大方向的思路，再去稍微验证一下，这样学起来就是高效的，自己理解的才是永恒的逻辑，不需要死记硬背。","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1673451905,"ip_address":"广东","comment_id":366133,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100312101,"comment_content":"先不管nacos，跟代码到config-center 里面，group、namespace、cluster  应该可以拿这些区分；\nnacos 也应该拿dataId,group等做了配置中心唯一性校验。导致重复的配置","like_count":0,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":599349,"discussion_content":"你好，熊悟空的凶：你的思路方向是对的，有了这些大方向的思路，再去稍微验证一下，这样学起来就是高效的，自己理解的才是永恒的逻辑，不需要死记硬背。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1673451905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}