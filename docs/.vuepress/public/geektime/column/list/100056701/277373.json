{"id":277373,"title":"10 | 第1～9讲课后思考题答案及常见问题答疑","content":"<p>你好，我是蒋德钧。</p><p>咱们的课程已经更新9讲了，这段时间，我收到了很多留言。很多同学都认真地回答了课后思考题，有些回答甚至可以说是标准答案。另外，还有很多同学针对Redis的基本原理和关键机制，提出了非常好的问题，值得好好讨论一下。</p><p>今天，我就和你聊一聊课后题答案，并且挑选一些典型问题，集中进行一次讲解，希望可以解决你的困惑。</p><h2>课后思考题答案</h2><h3><a href=\"https://time.geekbang.org/column/article/268262\">第1讲</a></h3><p><strong>问题：和跟Redis相比，SimpleKV还缺少什么？</strong></p><p>@曾轼麟、@Kaito 同学给出的答案都非常棒。他们从数据结构到功能扩展，从内存效率到事务性，从高可用集群再到高可扩展集群，对SimpleKV和Redis进行了详细的对比。而且，他们还从运维使用的角度进行了分析。我先分享一下两位同学的答案。</p><p>@曾轼麟同学：</p><blockquote>\n<ol>\n<li>数据结构：缺乏广泛的数据结构支持，比如支持范围查询的SkipList和Stream等数据结构。</li>\n<li>高可用：缺乏哨兵或者master-slave模式的高可用设计；</li>\n<li>横向扩展：缺乏集群和分片功能；</li>\n<li>内存安全性：缺乏内存过载时的key淘汰算法的支持；</li>\n<li>内存利用率：没有充分对数据结构进行优化，提高内存利用率，例如使用压缩性的数据结构；</li>\n<li>功能扩展：需要具备后续功能的拓展；</li>\n<li>不具备事务性：无法保证多个操作的原子性。</li>\n</ol>\n</blockquote><!-- [[[read_end]]] --><p>@Kaito同学：</p><blockquote>\n<p>SimpleKV所缺少的有：丰富的数据类型、支持数据压缩、过期机制、数据淘汰策略、主从复制、集群化、高可用集群等，另外，还可以增加统计模块、通知模块、调试模块、元数据查询等辅助功能。</p>\n</blockquote><p>我也给个答案总结。还记得我在<a href=\"https://time.geekbang.org/column/article/268247\">开篇词</a>讲过的“两大维度”“三大主线”吗？这里我们也可以借助这个框架进行分析，如下表所示。此外，在表格最后，我还从键值数据库开发和运维的辅助工具上，对SimpleKV和Redis做了对比。</p><p><img src=\"https://static001.geekbang.org/resource/image/67/36/67e77bea2568a4f0997c1853d9c60036.jpg?wh=2944*2045\" alt=\"\"></p><h3><a href=\"https://time.geekbang.org/column/article/268253\">第2讲</a></h3><p><strong>问题：整数数组和压缩列表作为底层数据结构的优势是什么？</strong></p><p>整数数组和压缩列表的设计，充分体现了Redis“又快又省”特点中的“省”，也就是节省内存空间。整数数组和压缩列表都是在内存中分配一块地址连续的空间，然后把集合中的元素一个接一个地放在这块空间内，非常紧凑。因为元素是挨个连续放置的，我们不用再通过额外的指针把元素串接起来，这就避免了额外指针带来的空间开销。</p><p>我画一张图，展示下这两个结构的内存布局。整数数组和压缩列表中的entry都是实际的集合元素，它们一个挨一个保存，非常节省内存空间。</p><p><img src=\"https://static001.geekbang.org/resource/image/2c/2a/2c57cc1c548a0733bd1bf09f397f342a.jpg?wh=2680*883\" alt=\"\"></p><p>Redis之所以采用不同的数据结构，其实是在性能和内存使用效率之间进行的平衡。</p><h3><a href=\"https://time.geekbang.org/column/article/270474\">第3讲</a></h3><p><strong>问题：Redis基本IO模型中还有哪些潜在的性能瓶颈？</strong></p><p>这个问题是希望你能进一步理解阻塞操作对Redis单线程性能的影响。在Redis基本IO模型中，主要是主线程在执行操作，任何耗时的操作，例如bigkey、全量返回等操作，都是潜在的性能瓶颈。</p><h3><a href=\"https://time.geekbang.org/column/article/271754\">第4讲</a></h3><p><strong>问题1：AOF重写过程中有没有其他潜在的阻塞风险？</strong></p><p>这里有两个风险。</p><p>风险一：Redis主线程fork创建bgrewriteaof子进程时，内核需要创建用于管理子进程的相关数据结构，这些数据结构在操作系统中通常叫作进程控制块（Process Control Block，简称为PCB）。内核要把主线程的PCB内容拷贝给子进程。这个创建和拷贝过程由内核执行，是会阻塞主线程的。而且，在拷贝过程中，子进程要拷贝父进程的页表，这个过程的耗时和Redis实例的内存大小有关。如果Redis实例内存大，页表就会大，fork执行时间就会长，这就会给主线程带来阻塞风险。</p><p>风险二：bgrewriteaof子进程会和主线程共享内存。当主线程收到新写或修改的操作时，主线程会申请新的内存空间，用来保存新写或修改的数据，如果操作的是bigkey，也就是数据量大的集合类型数据，那么，主线程会因为申请大空间而面临阻塞风险。因为操作系统在分配内存空间时，有查找和锁的开销，这就会导致阻塞。</p><p><strong>问题2：AOF 重写为什么不共享使用 AOF 本身的日志？</strong></p><p>如果都用AOF日志的话，主线程要写，bgrewriteaof子进程也要写，这两者会竞争文件系统的锁，这就会对Redis主线程的性能造成影响。</p><h3><a href=\"https://time.geekbang.org/column/article/271839\">第5讲</a></h3><p>问题：使用一个 2 核 CPU、4GB 内存、500GB 磁盘的云主机运行 Redis，Redis 数据库的数据量大小差不多是 2GB。当时 Redis主要以修改操作为主，写读比例差不多在 8:2 左右，也就是说，如果有 100 个请求，80 个请求执行的是修改操作。在这个场景下，用 RDB 做持久化有什么风险吗？</p><p>@Kaito同学的回答从内存资源和CPU资源两方面分析了风险，非常棒。我稍微做了些完善和精简，你可以参考一下。</p><p><strong>内存不足的风险</strong>：Redis fork一个bgsave子进程进行RDB写入，如果主线程再接收到写操作，就会采用写时复制。写时复制需要给写操作的数据分配新的内存空间。本问题中写的比例为80%，那么，在持久化过程中，为了保存80%写操作涉及的数据，写时复制机制会在实例内存中，为这些数据再分配新内存空间，分配的内存量相当于整个实例数据量的80%，大约是1.6GB，这样一来，整个系统内存的使用量就接近饱和了。此时，如果实例还有大量的新key写入或key修改，云主机内存很快就会被吃光。如果云主机开启了Swap机制，就会有一部分数据被换到磁盘上，当访问磁盘上的这部分数据时，性能会急剧下降。如果云主机没有开启Swap，会直接触发OOM，整个Redis实例会面临被系统kill掉的风险。</p><p><strong>主线程和子进程竞争使用CPU的风险</strong>：生成RDB的子进程需要CPU核运行，主线程本身也需要CPU核运行，而且，如果Redis还启用了后台线程，此时，主线程、子进程和后台线程都会竞争CPU资源。由于云主机只有2核CPU，这就会影响到主线程处理请求的速度。</p><h3><a href=\"https://time.geekbang.org/column/article/272852\">第6讲</a></h3><p><strong>问题：为什么主从库间的复制不使用 AOF？</strong></p><p>答案：有两个原因。</p><ol>\n<li>RDB文件是二进制文件，无论是要把RDB写入磁盘，还是要通过网络传输RDB，IO效率都比记录和传输AOF的高。</li>\n<li>在从库端进行恢复时，用RDB的恢复效率要高于用AOF。</li>\n</ol><h3><a href=\"https://time.geekbang.org/column/article/274483\">第7讲</a></h3><p><strong>问题1：在主从切换过程中，客户端能否正常地进行请求操作呢？</strong></p><p>主从集群一般是采用读写分离模式，当主库故障后，客户端仍然可以把读请求发送给从库，让从库服务。但是，对于写请求操作，客户端就无法执行了。</p><p><strong>问题2：如果想要应用程序不感知服务的中断，还需要哨兵或客户端再做些什么吗？</strong></p><p>一方面，客户端需要能缓存应用发送的写请求。只要不是同步写操作（Redis应用场景一般也没有同步写），写请求通常不会在应用程序的关键路径上，所以，客户端缓存写请求后，给应用程序返回一个确认就行。</p><p>另一方面，主从切换完成后，客户端要能和新主库重新建立连接，哨兵需要提供订阅频道，让客户端能够订阅到新主库的信息。同时，客户端也需要能主动和哨兵通信，询问新主库的信息。</p><h3><a href=\"https://time.geekbang.org/column/article/275337\">第8讲</a></h3><p><strong>问题1：5个哨兵实例的集群，quorum值设为2。在运行过程中，如果有3个哨兵实例都发生故障了，此时，Redis主库如果有故障，还能正确地判断主库“客观下线”吗？如果可以的话，还能进行主从库自动切换吗？</strong></p><p>因为判定主库“客观下线”的依据是，认为主库“主观下线”的哨兵个数要大于等于quorum值，现在还剩2个哨兵实例，个数正好等于quorum值，所以还能正常判断主库是否处于“客观下线”状态。如果一个哨兵想要执行主从切换，就要获到半数以上的哨兵投票赞成，也就是至少需要3个哨兵投票赞成。但是，现在只有2个哨兵了，所以就无法进行主从切换了。</p><p><strong>问题2：哨兵实例是不是越多越好呢？如果同时调大down-after-milliseconds值，对减少误判是不是也有好处？</strong></p><p>哨兵实例越多，误判率会越低，但是在判定主库下线和选举Leader时，实例需要拿到的赞成票数也越多，等待所有哨兵投完票的时间可能也会相应增加，主从库切换的时间也会变长，客户端容易堆积较多的请求操作，可能会导致客户端请求溢出，从而造成请求丢失。如果业务层对Redis的操作有响应时间要求，就可能会因为新主库一直没有选定，新操作无法执行而发生超时报警。</p><p>调大down-after-milliseconds后，可能会导致这样的情况：主库实际已经发生故障了，但是哨兵过了很长时间才判断出来，这就会影响到Redis对业务的可用性。</p><h3><a href=\"https://time.geekbang.org/column/article/276545\">第9讲</a></h3><p>问题：为什么Redis不直接用一个表，把键值对和实例的对应关系记录下来？</p><p>如果使用表记录键值对和实例的对应关系，一旦键值对和实例的对应关系发生了变化（例如实例有增减或者数据重新分布），就要修改表。如果是单线程操作表，那么所有操作都要串行执行，性能慢；如果是多线程操作表，就涉及到加锁开销。此外，如果数据量非常大，使用表记录键值对和实例的对应关系，需要的额外存储空间也会增加。</p><p>基于哈希槽计算时，虽然也要记录哈希槽和实例的对应关系，但是哈希槽的个数要比键值对的个数少很多，无论是修改哈希槽和实例的对应关系，还是使用额外空间存储哈希槽和实例的对应关系，都比直接记录键值对和实例的关系的开销小得多。</p><p>好了，这些问题你都回答上来了吗？如果你还有其他想法，也欢迎多多留言，跟我和其他同学进行交流讨论。</p><h2>典型问题讲解</h2><p>接下来，我再讲一些代表性问题，包括Redis  rehash的时机和执行机制，主线程、子进程和后台线程的联系和区别，写时复制的底层实现原理，以及replication buffer和repl_backlog_buffer的区别。</p><h3>问题1：rehash的触发时机和渐进式执行机制</h3><p>我发现，很多同学对Redis的哈希表数据结构都很感兴趣，尤其是哈希表的rehash操作，所以，我再集中回答两个问题。</p><p><strong>1.Redis什么时候做rehash？</strong></p><p>Redis会使用装载因子（load factor）来判断是否需要做rehash。装载因子的计算方式是，哈希表中所有entry的个数除以哈希表的哈希桶个数。Redis会根据装载因子的两种情况，来触发rehash操作：</p><ul>\n<li>装载因子≥1，同时，哈希表被允许进行rehash；</li>\n<li>装载因子≥5。</li>\n</ul><p>在第一种情况下，如果装载因子等于1，同时我们假设，所有键值对是平均分布在哈希表的各个桶中的，那么，此时，哈希表可以不用链式哈希，因为一个哈希桶正好保存了一个键值对。</p><p>但是，如果此时再有新的数据写入，哈希表就要使用链式哈希了，这会对查询性能产生影响。在进行RDB生成和AOF重写时，哈希表的rehash是被禁止的，这是为了避免对RDB和AOF重写造成影响。如果此时，Redis没有在生成RDB和重写AOF，那么，就可以进行rehash。否则的话，再有数据写入时，哈希表就要开始使用查询较慢的链式哈希了。</p><p>在第二种情况下，也就是装载因子大于等于5时，就表明当前保存的数据量已经远远大于哈希桶的个数，哈希桶里会有大量的链式哈希存在，性能会受到严重影响，此时，就立马开始做rehash。</p><p>刚刚说的是触发rehash的情况，如果装载因子小于1，或者装载因子大于1但是小于5，同时哈希表暂时不被允许进行rehash（例如，实例正在生成RDB或者重写AOF），此时，哈希表是不会进行rehash操作的。</p><p><strong>2.采用渐进式hash时，如果实例暂时没有收到新请求，是不是就不做rehash了？</strong></p><p>其实不是的。Redis会执行定时任务，定时任务中就包含了rehash操作。所谓的定时任务，就是按照一定频率（例如每100ms/次）执行的任务。</p><p>在rehash被触发后，即使没有收到新请求，Redis也会定时执行一次rehash操作，而且，每次执行时长不会超过1ms，以免对其他任务造成影响。</p><h3>问题2：主线程、子进程和后台线程的联系与区别</h3><p>我在课程中提到了主线程、主进程、子进程、子线程和后台线程这几个词，有些同学可能会有疑惑，我再帮你总结下它们的区别。</p><p>首先，我来解释一下进程和线程的区别。</p><p>从操作系统的角度来看，进程一般是指资源分配单元，例如一个进程拥有自己的堆、栈、虚存空间（页表）、文件描述符等；而线程一般是指CPU进行调度和执行的实体。</p><p>了解了进程和线程的区别后，我们再来看下什么是主进程和主线程。</p><p>如果一个进程启动后，没有再创建额外的线程，那么，这样的进程一般称为主进程或主线程。</p><p>举个例子，下面是我写的一个C程序片段，main函数会直接调用一个worker函数，函数worker就是执行一个for循环计算。下面这个程序运行后，它自己就是一个主进程，同时也是个主线程。</p><pre><code>int counter = 0;\nvoid *worker() {  \n   for (int i=0;i&lt;10;i++) {\n      counter++;\n   }  \n   return NULL;\n}\n\nint main(int argc, char *argv[]) {\n   worker();\n}\n</code></pre><p>和这段代码类似，Redis启动以后，本身就是一个进程，它会接收客户端发送的请求，并处理读写操作请求。而且，接收请求和处理请求操作是Redis的主要工作，Redis没有再依赖于其他线程，所以，我一般把完成这个主要工作的Redis进程，称为主进程或主线程。</p><p>在主线程中，我们还可以使用fork创建子进程，或是使用pthread_create创建线程。下面我先介绍下Redis中用fork创建的子进程有哪些。</p><ul>\n<li>创建RDB的后台子进程，同时由它负责在主从同步时传输RDB给从库；</li>\n<li>通过无盘复制方式传输RDB的子进程；</li>\n<li>bgrewriteaof子进程。</li>\n</ul><p>然后，我们再看下Redis使用的线程。从4.0版本开始，Redis也开始使用pthread_create创建线程，这些线程在创建后，一般会自行执行一些任务，例如执行异步删除任务。相对于完成主要工作的主线程来说，我们一般可以称这些线程为后台线程。关于Redis后台线程的具体执行机制，我会在第16讲具体介绍。</p><p>为了帮助你更好地理解，我画了一张图，展示了它们的区别。</p><p><img src=\"https://static001.geekbang.org/resource/image/c2/51/c2c5bd3a66921b1b0cc1d377dfabd451.jpg?wh=2210*1322\" alt=\"\"></p><h3>问题3：写时复制的底层实现机制</h3><p>Redis在使用RDB方式进行持久化时，会用到写时复制机制。我在第5节课讲写时复制的时候，着重介绍了写时复制的效果：bgsave子进程相当于复制了原始数据，而主线程仍然可以修改原来的数据。</p><p>今天，我再具体讲一讲写时复制的底层实现机制。</p><p>对Redis来说，主线程fork出bgsave子进程后，bgsave子进程实际是复制了主线程的页表。这些页表中，就保存了在执行bgsave命令时，主线程的所有数据块在内存中的物理地址。这样一来，bgsave子进程生成RDB时，就可以根据页表读取这些数据，再写入磁盘中。如果此时，主线程接收到了新写或修改操作，那么，主线程会使用写时复制机制。具体来说，写时复制就是指，主线程在有写操作时，才会把这个新写或修改后的数据写入到一个新的物理地址中，并修改自己的页表映射。</p><p>我来借助下图中的例子，具体展示一下写时复制的底层机制。</p><p>bgsave子进程复制主线程的页表以后，假如主线程需要修改虚页7里的数据，那么，主线程就需要新分配一个物理页（假设是物理页53），然后把修改后的虚页7里的数据写到物理页53上，而虚页7里原来的数据仍然保存在物理页33上。这个时候，虚页7到物理页33的映射关系，仍然保留在bgsave子进程中。所以，bgsave子进程可以无误地把虚页7的原始数据写入RDB文件。</p><p><img src=\"https://static001.geekbang.org/resource/image/cc/eb/cc98dc9f65a1079f3638158aacf81aeb.jpg?wh=2725*2005\" alt=\"\"></p><h3>问题4：replication buffer和repl_backlog_buffer的区别</h3><p>在进行主从复制时，Redis会使用replication buffer和repl_backlog_buffer，有些同学可能不太清楚它们的区别，我再解释下。</p><p>总的来说，replication buffer是主从库在进行全量复制时，主库上用于和从库连接的客户端的buffer，而repl_backlog_buffer是为了支持从库增量复制，主库上用于持续保存写操作的一块专用buffer。</p><p>Redis主从库在进行复制时，当主库要把全量复制期间的写操作命令发给从库时，主库会先创建一个客户端，用来连接从库，然后通过这个客户端，把写操作命令发给从库。在内存中，主库上的客户端就会对应一个buffer，这个buffer就被称为replication buffer。Redis通过client_buffer配置项来控制这个buffer的大小。主库会给每个从库建立一个客户端，所以replication buffer不是共享的，而是每个从库都有一个对应的客户端。</p><p>repl_backlog_buffer是一块专用buffer，在Redis服务器启动后，开始一直接收写操作命令，这是所有从库共享的。主库和从库会各自记录自己的复制进度，所以，不同的从库在进行恢复时，会把自己的复制进度（slave_repl_offset）发给主库，主库就可以和它独立同步。</p><p><img src=\"https://static001.geekbang.org/resource/image/7a/a8/7a1795yy4f6dc064f0d34ef1231203a8.jpg?wh=2109*1620\" alt=\"\"></p><p>好了，这节课就到这里。非常感谢你的仔细思考和提问，每个问题都很精彩，在看留言的过程中，我自己也受益匪浅。另外，我希望我们可以组建起一个Redis学习团，在接下来的课程中，欢迎你继续在留言区畅所欲言，我们一起进步，希望每个人都能成为Redis达人！</p>","neighbors":{"left":{"article_title":"09 | 切片集群：数据增多了，是该加内存还是加实例？","id":276545},"right":{"article_title":"11 | “万金油”的String，为什么不好用了？","id":279649}},"comments":[{"had_liked":false,"id":266054,"user_name":"赵茭茭","can_delete":false,"product_type":"c1","uid":2060978,"ip_address":"","ucode":"502C8A2B10C09B","user_header":"","comment_is_top":false,"comment_ctime":1607152245,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"521298195061","product_id":100056701,"comment_content":"前9讲 我一共学了 3遍 真的是每一次学习都理解不同 学的越来越深 真的是很棒的文章 比网上的博客强太多了 很系统","like_count":122,"discussions":[{"author":{"id":1481811,"avatar":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","nickname":"ub8","note":"","ucode":"0D937C3EAEB781","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384218,"discussion_content":"网上的博客你花钱了么\n","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1626429102,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1226968,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b8/d8/f81b5604.jpg","nickname":"hcyycb","note":"","ucode":"77FF6CA41F9E66","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539990,"discussion_content":"周末读完前10节。太过瘾了，脑瓜现在嗡嗡的——我要缓缓了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1639910863,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2109853,"avatar":"","nickname":"beifengzhishen001","note":"","ucode":"77D42B7DD9E754","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368999,"discussion_content":"我这应该是学的第3或第4遍了，之间各种原因没有坚持下去，这次终于阅读完了第10节课程，mark下","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1618900274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1210003,"avatar":"https://static001.geekbang.org/account/avatar/00/12/76/93/c78a132a.jpg","nickname":"果然如此","note":"","ucode":"C7543BD0A67505","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2109853,"avatar":"","nickname":"beifengzhishen001","note":"","ucode":"77D42B7DD9E754","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374581,"discussion_content":"我也是，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621255529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":368999,"ip_address":""},"score":374581,"extra":""}]},{"author":{"id":1621615,"avatar":"https://static001.geekbang.org/account/avatar/00/18/be/6f/425c6030.jpg","nickname":"$","note":"","ucode":"F294D6EFAB1224","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561578,"discussion_content":"同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649677900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":288284,"user_name":"Geek_8b8d3d","can_delete":false,"product_type":"c1","uid":1438422,"ip_address":"","ucode":"9E308F95A5F748","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/jgEicJMDKtww4iayMAw247KHwX2N4g5xoGrW5pjVsgJhpibFgs79uVibjOTVuo1ia17XHyHzlk4xvJSP2OCE0AD14xg/132","comment_is_top":false,"comment_ctime":1618392186,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"177712051322","product_id":100056701,"comment_content":"我觉得基础篇就够我去面试了","like_count":42,"discussions":[{"author":{"id":2649276,"avatar":"https://static001.geekbang.org/account/avatar/00/28/6c/bc/f751786b.jpg","nickname":"Leo","note":"","ucode":"CEBAD9CDCFC2A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556145,"discussion_content":"哈哈哈 确实","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1647230498,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1877862,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLu3MgZBAyyiavX2CMF2KRib791j3bBGiaQDzuQwBF2k6AKHANV2uTAAss2vVaeC7xcSYYD8vjmibRpTQ/132","nickname":"纵不朽","note":"","ucode":"DB2CA2C46B2EF1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573226,"discussion_content":"还不行，要处理缓存和数据库的数据一致性，缓存穿透击穿雪崩等一堆问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653278102,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1763933,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/ea/5d/ccb4c205.jpg","nickname":"绘世浮夸 つ","note":"","ucode":"6A3960195753BA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553724,"discussion_content":"me too","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646041091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1191877,"avatar":"https://static001.geekbang.org/account/avatar/00/12/2f/c5/55832856.jpg","nickname":"Edison Zhou","note":"","ucode":"DDD50EA2335CAC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550193,"discussion_content":"me too","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644412918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244200,"user_name":"zhou","can_delete":false,"product_type":"c1","uid":1065310,"ip_address":"","ucode":"E5D21F2A3359CB","user_header":"https://static001.geekbang.org/account/avatar/00/10/41/5e/9d2953a3.jpg","comment_is_top":false,"comment_ctime":1598427205,"is_pvip":false,"replies":[{"id":"89958","content":"理解的没错！","user_name":"作者回复","user_name_real":"蒋德钧","uid":"1609687","ctime":1598486697,"ip_address":"","comment_id":244200,"utype":1}],"discussion_count":6,"race_medal":0,"score":"130447446085","product_id":100056701,"comment_content":"感谢老师的答疑，明白了写时复制的底层原理。之前一直以为主进程有写操作时，fork 出来的子进程会复制一份物理内存数据过来，实际上只会复制一份页表，相对于内存数据，页表数据小很多。","like_count":31,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504518,"discussion_content":"理解的没错！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598486697,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1553508,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/eEpbEmZbQAelOXMh3yddO87Tn3hbTHd4OmFrQNMCpNibqOdg9oHg6Kxhpl81ciageUG95D6lr4Y2dQIF3Hsd9qJg/132","nickname":"跳跳熊","note":"","ucode":"72FE051AE2E118","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382354,"discussion_content":"复制的页表里面是虚拟页和物理页的映射关系？reids数据不是存储在内存中的吗  咋会在物理页上操作数据","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1625541707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1987040,"avatar":"","nickname":"走路顺拐","note":"","ucode":"82D19A53DCB14E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541837,"discussion_content":"写时复制，当有数据修改时，主线程是申请新的内存，是复制一页的数据吗？还是只肤质修改的数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640577783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2621412,"avatar":"https://static001.geekbang.org/account/avatar/00/27/ff/e4/927547a9.jpg","nickname":"无名无姓","note":"","ucode":"487BD5AA2CD305","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380913,"discussion_content":"这次终于理解了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624790174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1355831,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b0/37/d654fbac.jpg","nickname":"几近虚年","note":"","ucode":"28CD6486EED8E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362930,"discussion_content":"层主说的是 fork 的操作，此时子进程会复制虚拟页。你说的是写时复制，在修改时，主线程分配内存，会复制要修改的数据到新内存上，在新内存上做修改。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617075473,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1108924,"avatar":"https://static001.geekbang.org/account/avatar/00/10/eb/bc/6ccac4bb.jpg","nickname":"武文文武","note":"","ucode":"5288366646A15B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346963,"discussion_content":"按文中所述，我理解是主进程需要写数据时，会复制一页数据出来，然后再做修改","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612106930,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261586,"user_name":"袁东昊的电信手机","can_delete":false,"product_type":"c1","uid":2300724,"ip_address":"","ucode":"938393B2C47702","user_header":"","comment_is_top":false,"comment_ctime":1605432097,"is_pvip":false,"replies":[{"id":"98059","content":"Sentinel提供了分布式系统中选主问题的参考实现，具有一定的普适性，Sentinel的实现类似于Raft协议，所以研究下Sentinel也可以帮助我们理解Raft，Raft在分布式系统中还是很有用的。","user_name":"作者回复","user_name_real":"蒋德钧","uid":"1609687","ctime":1609114603,"ip_address":"","comment_id":261586,"utype":1}],"discussion_count":1,"race_medal":0,"score":"70324908833","product_id":100056701,"comment_content":"请问下老师：目前使用比较多的都是Redis Cluster模式，RedisCluster模式已经可以自己选主了，为什么还还这么多研究Redis Sentinel。","like_count":16,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509530,"discussion_content":"Sentinel提供了分布式系统中选主问题的参考实现，具有一定的普适性，Sentinel的实现类似于Raft协议，所以研究下Sentinel也可以帮助我们理解Raft，Raft在分布式系统中还是很有用的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1609114603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":258572,"user_name":"烫烫烫","can_delete":false,"product_type":"c1","uid":1386818,"ip_address":"","ucode":"C06018670DE76A","user_header":"https://static001.geekbang.org/account/avatar/00/15/29/42/43d4b1a8.jpg","comment_is_top":false,"comment_ctime":1604487537,"is_pvip":true,"discussion_count":5,"race_medal":0,"score":"40259193201","product_id":100056701,"comment_content":"关于rehash的触发时机，装载因子&gt;=1和&gt;=5是不是太大了？当装载因子接近1的时候，冲突概率已经很严重了吧。我记得大部分语言（Java&#47;C&#47;C#&#47;Go）的哈希表扩容时机，装载因子都小于1。有老师或哪位同学能帮我解惑吗？","like_count":10,"discussions":[{"author":{"id":2690797,"avatar":"https://static001.geekbang.org/account/avatar/00/29/0e/ed/3ff5d4bc.jpg","nickname":"小牧","note":"","ucode":"7AF236994B954E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391970,"discussion_content":"Redis里哈希对象的装载因子的定义和一般的哈希表的装载因子的定义不一样","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1630739153,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1758825,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d6/69/f59d4f6f.jpg","nickname":"Ryan","note":"","ucode":"387955FD53E98C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558465,"discussion_content":"我觉得Redis应该是为了节省空间，才设置比较大的装载因子，因为装载因子越大，空闲的哈希桶越少，虽然哈希冲突会变多（以时间换空间）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648312161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2021571,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/d8/c3/2738f3b5.jpg","nickname":"happy _day","note":"","ucode":"DAEAEB1C927B01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373997,"discussion_content":"个人理解:以java的hashmap为例，hashmap的转载因子指的是容量，而redis的rehash机制的装载因子是为了防止hash冲突太严重，导致查询响应慢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620963931,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1389314,"avatar":"https://static001.geekbang.org/account/avatar/00/15/33/02/83f47bf9.jpg","nickname":"流沙","note":"","ucode":"6153686D1C34B7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2021571,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/d8/c3/2738f3b5.jpg","nickname":"happy _day","note":"","ucode":"DAEAEB1C927B01","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383960,"discussion_content":"hashmap的装载因子也是为了避免hash冲突啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1626318315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":373997,"ip_address":""},"score":383960,"extra":""},{"author":{"id":1081299,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7f/d3/b5896293.jpg","nickname":"Realm","note":"","ucode":"30CBEBE619D1A2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1389314,"avatar":"https://static001.geekbang.org/account/avatar/00/15/33/02/83f47bf9.jpg","nickname":"流沙","note":"","ucode":"6153686D1C34B7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568479,"discussion_content":"hashmap冲突就是出bug了；redis的rehash为了搜索更快；一个是生死问题，一个是吃饱VS吃好的问题，应该不是一回事。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651149356,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":383960,"ip_address":""},"score":568479,"extra":""}]}]},{"had_liked":false,"id":292296,"user_name":"悟空聊架构","can_delete":false,"product_type":"c1","uid":1123163,"ip_address":"","ucode":"C2F482A0CF8AF1","user_header":"https://static001.geekbang.org/account/avatar/00/11/23/5b/983408b9.jpg","comment_is_top":false,"comment_ctime":1620776690,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"31685547762","product_id":100056701,"comment_content":"这个复盘总结得很棒，看完后建议回头再看下前面几篇。","like_count":8},{"had_liked":false,"id":247874,"user_name":"Geek_ee09b9","can_delete":false,"product_type":"c1","uid":2178788,"ip_address":"","ucode":"7B3B62190EA3E3","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/fyGStpP7R15BpL6fXiaCQk5dHtfbIkmpJ9QmgSibuwTQK6M1DibTxVttRFtztxdWiams0UOXM28GlQKmeNukRXLvBg/132","comment_is_top":false,"comment_ctime":1599899846,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23074736326","product_id":100056701,"comment_content":"学到这里,有点忘了再看一遍","like_count":6},{"had_liked":false,"id":244877,"user_name":"曾轼麟","can_delete":false,"product_type":"c1","uid":1451391,"ip_address":"","ucode":"D418371AC11270","user_header":"https://static001.geekbang.org/account/avatar/00/16/25/7f/473d5a77.jpg","comment_is_top":false,"comment_ctime":1598713273,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23073549753","product_id":100056701,"comment_content":"谢谢老师的解答和认可","like_count":6},{"had_liked":false,"id":244308,"user_name":"keaper","can_delete":false,"product_type":"c1","uid":1046338,"ip_address":"","ucode":"1718EAC00925ED","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/42/eb46c66a.jpg","comment_is_top":false,"comment_ctime":1598454889,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"23073291369","product_id":100056701,"comment_content":"关于“采用渐进式 hash 时，如果实例暂时没有收到新请求，是不是就不做 rehash 了？”这个问题<br>在阅读源码中注意到 在定时任务中会 对redis的 数据字典（保存每个键值对数据的dict结构）和过期字典（保存每个键值对过期时间的dict）这两个dict结构进行rehash，那么对于Hash数据类型所对应的dict结构（执行&quot;HSET&quot;命令创建的dict结构），是否也会有这种后台定时rehash的机制呢？<br>希望老师和各位同学能解答一下。","like_count":5,"discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301524,"discussion_content":"Hash类型不会定时做rehash，只有操作这个类型的key时，才判断是否需要rehash，如果符合条件，也做渐进式rehash。\n\ndb中的keys定时做rehash是因为在生成RDB和AOF重写时，会暂停做rehash，防止大量内存副本的拷贝。等生成RDB和AOF重写完成之后，在这段期间可能有新写入的key进来，导致db的哈希表负载不均匀，所以要定时检测做rehash。","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1598543974,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066411,"avatar":"https://static001.geekbang.org/account/avatar/00/10/45/ab/7dec2448.jpg","nickname":"我不用网名","note":"","ucode":"B1C921455BF44F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301502,"discussion_content":"没看到课代表的发言我很惶恐","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598541611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1066411,"avatar":"https://static001.geekbang.org/account/avatar/00/10/45/ab/7dec2448.jpg","nickname":"我不用网名","note":"","ucode":"B1C921455BF44F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301523,"discussion_content":"别惶恐啊，这节课都是课后答案，多轻松啊。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598543797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301502,"ip_address":""},"score":301523,"extra":""}]}]},{"had_liked":false,"id":245321,"user_name":"Yayu","can_delete":false,"product_type":"c1","uid":1058015,"ip_address":"","ucode":"5E7842458D8229","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/df/645f8087.jpg","comment_is_top":false,"comment_ctime":1598894912,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"18778764096","product_id":100056701,"comment_content":"请问老师，写时复制的实现机制这里，是不是少了一部分，子线程读取操作系统复制出来的“写”数据，写入到RDB 文件，否则更新的数据何时体现到RDB 文件中？","like_count":4,"discussions":[{"author":{"id":1672786,"avatar":"https://static001.geekbang.org/account/avatar/00/19/86/52/91c7d112.jpg","nickname":"Garen","note":"","ucode":"0608C88F83EF0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308407,"discussion_content":"RDB是某时刻的镜像，这个时刻后的操作，他才不管呢，等下次再说吧。所以会丢数据嘛。所以如果对数据安全性要求高，就要启动AOF。如果容不得一丝数据丢失，这时候你就不能用redis了。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1600941407,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1007294,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/be/9ea55f46.jpg","nickname":"feihui","note":"","ucode":"13F1D4A82BC650","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305604,"discussion_content":"RDB只是生成某一时刻的快照，之后的操作可以通过AOF回放","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1600014342,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336075,"user_name":"阮华","can_delete":false,"product_type":"c1","uid":2912941,"ip_address":"","ucode":"D0FDA030071C8F","user_header":"https://static001.geekbang.org/account/avatar/00/2c/72/ad/e22c4507.jpg","comment_is_top":false,"comment_ctime":1645882818,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"14530784706","product_id":100056701,"comment_content":"从5:30到现在9:36，一口气把这10课基础篇看完了，受益颇多，这一天学的比我前几年学的都深入。","like_count":4,"discussions":[{"author":{"id":3167302,"avatar":"","nickname":"Geek_eabafe","note":"","ucode":"4D94487320B33B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586646,"discussion_content":"看那么快的吗 能记住吗 我觉得我自己看的太慢了。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662395819,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330723,"user_name":"nwc","can_delete":false,"product_type":"c1","uid":2349067,"ip_address":"","ucode":"2FEDB3D6D5C12A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIXeicJJQk6sbWzIQfVRHoUIPkQYyXRFZ6V0O42ddCic9ypt0liciaPFwicicfpo5HJ3ibicNtL5wkXlcib5CQ/132","comment_is_top":false,"comment_ctime":1642132371,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"10232066963","product_id":100056701,"comment_content":"为什么进行RDB文件生成和AOF重写的时候不能进行rehash操作，原因还是不清楚。<br>RDB的生成和AOF重写都是fork出来子进程来进行的，而且都是对内存中的数据进行备份；<br>但是rehash只是对全局hash表进行操作，不太清楚rehash会对RDB的生成和AOF的重写造成什么影响，感觉肯定不是因为rehash的资源占用。","like_count":3,"discussions":[{"author":{"id":2012886,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/b6/d6/3b1fbf9b.jpg","nickname":"2018","note":"","ucode":"436D1F4CA63CB9","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572717,"discussion_content":"个人感觉是子进程fork出来以后, 由于写时复制 rehash 有可能会申请很多内存","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1652929283,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2928383,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/7w8MKicchnySibMn7Micfv7zos40Ty0Fe4AXQCaDMYtSAA6UgdicCt6pcaKu7lgTibgQgVx9t4NMnCgy4t5st74Z9EQ/132","nickname":"Geek_a78456","note":"","ucode":"27412D2C23E833","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586430,"discussion_content":"我说下个人的理解：redis中是存在两张全局hash表，一张表存储数据，另一张空闲表用于辅助扩容（和java中新生代的回收算法有点类似）。在源码中，大致的思路是rehash的时候会将另一张空闲表扩容，然后将数据移动到这一张表上，移动完成后，会释放掉原来那张hash表的内存，并且将指针指向新的hash表。这时候，如果进行AOF和RDB，那么它们指向的数据就会被释放掉，那么就会造成写入数据不完整。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662205913,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321733,"user_name":"书策稠浊","can_delete":false,"product_type":"c1","uid":1307497,"ip_address":"","ucode":"A29875CE15FDA3","user_header":"https://static001.geekbang.org/account/avatar/00/13/f3/69/7039d03f.jpg","comment_is_top":false,"comment_ctime":1637028379,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10226962971","product_id":100056701,"comment_content":"replication buffer是在初始化的时候，从库与主库同步数据，每个从库启动时间不一样，初始化的时间也不一样，复制期间的增量数据就不一样，所以每个客户端都有1个replication buffer。repl_backlog_buffer 是在运行过程中，从库因为网络等原因与主库断开连接，无法同步到最新数据，但是记录了自己同步到哪了，在从库恢复网络后告诉主库自己复制到哪了，主库就从哪里开始继续发送写命令给从库，由于位置是从库指定的，所以大家共用1个就好了，数据都在那里","like_count":2},{"had_liked":false,"id":244174,"user_name":"张小帆","can_delete":false,"product_type":"c1","uid":2111070,"ip_address":"","ucode":"FF71C3A1BA8430","user_header":"https://static001.geekbang.org/account/avatar/00/20/36/5e/c1d63d93.jpg","comment_is_top":false,"comment_ctime":1598418097,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10188352689","product_id":100056701,"comment_content":"感觉老师比自己思考的多很多 很棒","like_count":2},{"had_liked":false,"id":244167,"user_name":"yyl","can_delete":false,"product_type":"c1","uid":1170843,"ip_address":"","ucode":"1741DACDFCA9AF","user_header":"https://static001.geekbang.org/account/avatar/00/11/dd/9b/0bc44a78.jpg","comment_is_top":false,"comment_ctime":1598415405,"is_pvip":false,"replies":[{"id":"89959","content":"温故而知新，认真学习的好同学！","user_name":"作者回复","user_name_real":"蒋德钧","uid":"1609687","ctime":1598487005,"ip_address":"","comment_id":244167,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10188349997","product_id":100056701,"comment_content":"欢呼，有些地方自己理解的是正确的😎<br>晚上回去再核对一遍","like_count":2,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504506,"discussion_content":"温故而知新，认真学习的好同学！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598487005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":299379,"user_name":"Geek_a25096","can_delete":false,"product_type":"c1","uid":2046800,"ip_address":"","ucode":"E3400CCB95EB32","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erJ33eSC72BTHlwIPBdSFNFuXgX4FDibW0AuFuHqyXndpAqUZN7RDYAP4QTZHdG55q8weWYt3BkrrQ/132","comment_is_top":false,"comment_ctime":1624603461,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5919570757","product_id":100056701,"comment_content":"当把书看完之后再来看这个简直不要太完美，讲的非常好","like_count":1,"discussions":[{"author":{"id":2933797,"avatar":"","nickname":"Geek_8b0800","note":"","ucode":"09D9692B62A691","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554386,"discussion_content":"什么书","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1646361541,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1792714,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/5a/ca/4d5d23d1.jpg","nickname":"Im me","note":"","ucode":"FF7DEED4BB4C37","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555980,"discussion_content":"什么书？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647156528,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":292666,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1620915086,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5915882382","product_id":100056701,"comment_content":"老师，您好！<br><br>如果装载因子小于 1，或者装载因子大于 1 但是小于5，<br>在进行 RDB 生成和 AOF 重写时，哈希表的 rehash 是被禁止的，这是为了避免对 RDB 和 AOF 重写造成影响。<br><br>1.为什么 RDB 和 AOF 重写时，禁止 rehash，是为了避免主线程大量的 cow 么？<br><br>2. 那如果是这个原因，为什么装载因子大于等于 5 时却不受这限制，在 RDB AOF 重写时允许 rehash？此时元素冲突更多，rehash 时 cow 不是更费资源么？<br><br>谢谢老师！","like_count":1,"discussions":[{"author":{"id":1227840,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/40/2279cfb5.jpg","nickname":"大力水手Jerry","note":"","ucode":"E4A6C71E275DB5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375134,"discussion_content":"刚刚研究了这个问题，你的理解1是正确的。生成RDB（bgsave）和AOF rewrite（bgrewriteaof）都是通过fork新的进程实现，为提高效率都会采用COW技术。Rehash的本质是重写内存数据，因此在rehash时如果有运行的后台进程都会导致主线程产生大量的COW，消耗大量内存。源码中有一段注解“/* Perform hash tables rehashing if needed, but only if there are no  other processes saving the DB on disk. Otherwise rehashing is bad as will cause a lot of copy-on-write of memory pages. */”关于装载因子大于5时强制rehash的论述，网上有不少类似论述，但源码中没有找到。感觉现在的redis不会有让load_factor等于5的时候。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1621493829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":260834,"user_name":"出卖灵魂的教练Kerry","can_delete":false,"product_type":"c1","uid":1807943,"ip_address":"","ucode":"8C64517DA556FE","user_header":"https://static001.geekbang.org/account/avatar/00/1b/96/47/93838ff7.jpg","comment_is_top":false,"comment_ctime":1605141785,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5900109081","product_id":100056701,"comment_content":"老师关于操作系统方面的解答太棒了","like_count":1},{"had_liked":false,"id":247618,"user_name":"Y、先生","can_delete":false,"product_type":"c1","uid":1604447,"ip_address":"","ucode":"9D3BC6AF916BCA","user_header":"https://static001.geekbang.org/account/avatar/00/18/7b/5f/3400d01b.jpg","comment_is_top":false,"comment_ctime":1599779222,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5894746518","product_id":100056701,"comment_content":"写时复制 如何把变更的数据同步到子进程的","like_count":1,"discussions":[{"author":{"id":1073443,"avatar":"https://static001.geekbang.org/account/avatar/00/10/61/23/30d134cf.jpg","nickname":"Young","note":"","ucode":"075C0BBE20FD8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371738,"discussion_content":"COW不负责这个。  RDB完成全量复制，之后新增的通过增量复制完成（backlog_buffer）","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1619946189,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":350345,"user_name":"明","can_delete":false,"product_type":"c1","uid":1193778,"ip_address":"","ucode":"DDC5BE8883873B","user_header":"https://static001.geekbang.org/account/avatar/00/12/37/32/2703ee16.jpg","comment_is_top":false,"comment_ctime":1656837281,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1656837281","product_id":100056701,"comment_content":"老师好，第四讲说bgrewritaof 是一处拷贝两处日志，但风险二写共享内存，这是不是存在冲突","like_count":0},{"had_liked":false,"id":349635,"user_name":"Miss","can_delete":false,"product_type":"c1","uid":2088485,"ip_address":"","ucode":"B8B3014A933849","user_header":"https://static001.geekbang.org/account/avatar/00/1f/de/25/44662eb8.jpg","comment_is_top":false,"comment_ctime":1656168960,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1656168960","product_id":100056701,"comment_content":"实习一年不到的菜鸡，看完了前9讲，无论图还是讲解，着实牛！","like_count":0},{"had_liked":false,"id":347976,"user_name":"云中君","can_delete":false,"product_type":"c1","uid":1448032,"ip_address":"","ucode":"52FECFBFECBA40","user_header":"https://static001.geekbang.org/account/avatar/00/16/18/60/ecdb8ff9.jpg","comment_is_top":false,"comment_ctime":1654646415,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1654646415","product_id":100056701,"comment_content":"主从同步采用RDB的话，是全量还是增量方式？","like_count":0},{"had_liked":false,"id":343959,"user_name":"伊诺","can_delete":false,"product_type":"c1","uid":1281857,"ip_address":"","ucode":"709E038DD01C17","user_header":"https://static001.geekbang.org/account/avatar/00/13/8f/41/307555ff.jpg","comment_is_top":false,"comment_ctime":1651143636,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651143636","product_id":100056701,"comment_content":"间断，看完老师得课程，留言很精彩。但是我有个疑惑，课程里面得设计思想，看得时候领悟啦，过后就忘了，如何加强记忆？","like_count":0},{"had_liked":false,"id":343957,"user_name":"X","can_delete":false,"product_type":"c1","uid":2027258,"ip_address":"","ucode":"688D816A4931CA","user_header":"https://static001.geekbang.org/account/avatar/00/1e/ee/fa/31361552.jpg","comment_is_top":false,"comment_ctime":1651142901,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651142901","product_id":100056701,"comment_content":"写时复制讲得特别好","like_count":0},{"had_liked":false,"id":343615,"user_name":"Geek_9adefb","can_delete":false,"product_type":"c1","uid":2980933,"ip_address":"","ucode":"DE7D4E98F892AE","user_header":"","comment_is_top":false,"comment_ctime":1650955089,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650955089","product_id":100056701,"comment_content":"老师 bigkey 不光是指大的key吧  大的value是不是也叫big key","like_count":0},{"had_liked":false,"id":343614,"user_name":"Geek_9adefb","can_delete":false,"product_type":"c1","uid":2980933,"ip_address":"","ucode":"DE7D4E98F892AE","user_header":"","comment_is_top":false,"comment_ctime":1650955023,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650955023","product_id":100056701,"comment_content":"老师好：我理解aof在主从复制期间是没有用到的吧，主从复制期间先使用的是rdb，然后后面就直接通过长连接把增量数据给传过去了，好像没有aof的身影<br><br>aof是不是只是为了恢复单个实例上的数据用的，比如如果没有主从的时候，某个实例掉线了，可以使用rdb + aof对数据进行恢复。","like_count":0},{"had_liked":false,"id":339033,"user_name":"William Ning","can_delete":false,"product_type":"c1","uid":1592279,"ip_address":"","ucode":"4DB8D05E69E5F3","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","comment_is_top":false,"comment_ctime":1647867404,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1647867404","product_id":100056701,"comment_content":"还是没理解“replication buffer 和 repl_backlog_buffer 的区别”，需要回顾，认真思考～","like_count":0},{"had_liked":false,"id":337909,"user_name":"Im me","can_delete":false,"product_type":"c1","uid":1792714,"ip_address":"","ucode":"FF7DEED4BB4C37","user_header":"https://static001.geekbang.org/account/avatar/00/1b/5a/ca/4d5d23d1.jpg","comment_is_top":false,"comment_ctime":1647156493,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647156493","product_id":100056701,"comment_content":"老师，数组跟压缩列表看着差不多呀，压缩列表这数据结构是不是多余的？","like_count":0},{"had_liked":false,"id":332258,"user_name":"zzzzz","can_delete":false,"product_type":"c1","uid":1155586,"ip_address":"","ucode":"FB12EF8B8C3888","user_header":"https://static001.geekbang.org/account/avatar/00/11/a2/02/a44d512e.jpg","comment_is_top":false,"comment_ctime":1643119040,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643119040","product_id":100056701,"comment_content":"写时复制这个太妙了，谢谢老师","like_count":0},{"had_liked":false,"id":331402,"user_name":"小神david","can_delete":false,"product_type":"c1","uid":1206959,"ip_address":"","ucode":"F593F5ECEC58BA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epmAicDUiaUdtLhVwSs6fT0yx69ibWy6ia46ZD4vblGtyee8QFz71icKZJkzccAFG3zHnMngSz7WeGBtKw/132","comment_is_top":false,"comment_ctime":1642574939,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642574939","product_id":100056701,"comment_content":"非常系统的课程～ 赞👍","like_count":0},{"had_liked":false,"id":325434,"user_name":"树心","can_delete":false,"product_type":"c1","uid":1589523,"ip_address":"","ucode":"6C329F0FF798B9","user_header":"https://static001.geekbang.org/account/avatar/00/18/41/13/ab14ad25.jpg","comment_is_top":false,"comment_ctime":1638956492,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1638956492","product_id":100056701,"comment_content":"很棒的答疑！","like_count":0},{"had_liked":false,"id":319450,"user_name":"受超凡","can_delete":false,"product_type":"c1","uid":2678558,"ip_address":"","ucode":"A2A160D483BBB0","user_header":"","comment_is_top":false,"comment_ctime":1635818297,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635818297","product_id":100056701,"comment_content":"老师还有个问题想请教下，前面讲了好多数据结构，这些数据结构都是什么时候用呢？比如整数列表和压缩列表什么情况会用到，什么情况不用呢？这些都是redis底层自行判断的吧。","like_count":0},{"had_liked":false,"id":306442,"user_name":"tardis","can_delete":false,"product_type":"c1","uid":2309475,"ip_address":"","ucode":"F33411288D5E27","user_header":"https://static001.geekbang.org/account/avatar/00/23/3d/63/b4466457.jpg","comment_is_top":false,"comment_ctime":1628564070,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1628564070","product_id":100056701,"comment_content":"关于 replication buffer 和 repl_backlog_buffer 的区别这个问题的解答,感觉和前面讲的是有出入,网上查了资料感觉讲的也不对","like_count":0,"discussions":[{"author":{"id":2757673,"avatar":"","nickname":"伊甸","note":"","ucode":"E2BE2411619DBD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":409273,"discussion_content":"按照《redis设计与实现》的理解：replication buffer是指，完整重同步（全量复制）阶段 主服务器在生成rdb过程中，如果收到客户端的写命令，那么会把它存到replication buffer中，当从服务器收到rdb并恢复数据后，主服务器将replication buffer中的写命令发给从服务器，此时主从一致；之后进入命令传播阶段，在该阶段，主服务器会把客户端发来的写命令存到repl_backlog_buffer（固定长度的队列）中，同时发给从服务器；如果主从断线（这个过程中主也会把收到的写命令存到repl_backlog_buffer中，存满了就弹出队首的命令），当重连之后，从服务器会发送psync <offset><runid> 命令给主服务器，主根据runid是否与自身ruanid相同来判断从之前复制的是主自身的还是其他的主，若不等，执行完整重同步，若相等，则查看offset是否在repl_backlog_buffer中，如果在则将offset之后的命令都发给从服务器（增量复制），如果不在，说明断线时间太长，需要全量复制。\noffset：主服务器每给从服务器发送n字节的数据自身的offset值加n；同理，从服务器每收到n字节数据自身的offset值加n。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1635406933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1123146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/4a/c608bdf6.jpg","nickname":"三石","note":"","ucode":"734DCECABC3BEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389672,"discussion_content":"replication buffer可以看成主从同步数据的io缓冲区repl_backlog_buffer 可以看成一个环形日志文件","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629373392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":305473,"user_name":"酷酷的嵩","can_delete":false,"product_type":"c1","uid":1357315,"ip_address":"","ucode":"EF249E96F42491","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoVRER40LhyAhBK6YgPYibRzWARkc3efUquib4j9BPru4y8FfvXK2sBPbXej9314pZdfdcxb07RcjZw/132","comment_is_top":false,"comment_ctime":1627985274,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1627985274","product_id":100056701,"comment_content":"Redis的写时复制场景中，只会出现有父进程修改数据。抛开这种场景，如果子进程执行写的动作，虚页到物理页的关系是怎么修改的，是改父进程的还是子进程的？","like_count":0,"discussions":[{"author":{"id":1123146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/4a/c608bdf6.jpg","nickname":"三石","note":"","ucode":"734DCECABC3BEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389673,"discussion_content":"子进程唯一的任务就是读","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629373450,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300215,"user_name":"不知道","can_delete":false,"product_type":"c1","uid":2673958,"ip_address":"","ucode":"48F0593A3F407F","user_header":"https://static001.geekbang.org/account/avatar/00/28/cd/26/b451000e.jpg","comment_is_top":false,"comment_ctime":1625048829,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1625048829","product_id":100056701,"comment_content":"老师，当使用“主-从-从”模式时，是不是第三个以后的从节点的数据都会存在很大的不同步","like_count":0,"discussions":[{"author":{"id":1553508,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/eEpbEmZbQAelOXMh3yddO87Tn3hbTHd4OmFrQNMCpNibqOdg9oHg6Kxhpl81ciageUG95D6lr4Y2dQIF3Hsd9qJg/132","nickname":"跳跳熊","note":"","ucode":"72FE051AE2E118","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382356,"discussion_content":"应该存在2倍的时间延迟吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625541952,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":299677,"user_name":"无名无姓","can_delete":false,"product_type":"c1","uid":2621412,"ip_address":"","ucode":"487BD5AA2CD305","user_header":"https://static001.geekbang.org/account/avatar/00/27/ff/e4/927547a9.jpg","comment_is_top":false,"comment_ctime":1624790282,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1624790282","product_id":100056701,"comment_content":"老师您好，redis源码用什么写的，是否可以看源码加深下理解","like_count":0,"discussions":[{"author":{"id":2543127,"avatar":"https://static001.geekbang.org/account/avatar/00/26/ce/17/aec97321.jpg","nickname":"见崎千亦","note":"","ucode":"E419F9339B17AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387205,"discussion_content":"C语言","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628051804,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":299089,"user_name":"trymorewang","can_delete":false,"product_type":"c1","uid":1005713,"ip_address":"","ucode":"5804857F5B8B2E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/58/91/3a2822f0.jpg","comment_is_top":false,"comment_ctime":1624453803,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624453803","product_id":100056701,"comment_content":"钱没白花","like_count":0},{"had_liked":false,"id":284569,"user_name":"px","can_delete":false,"product_type":"c1","uid":1674091,"ip_address":"","ucode":"DC9B7B3AA660CC","user_header":"https://static001.geekbang.org/account/avatar/00/19/8b/6b/8ec6c4c9.jpg","comment_is_top":false,"comment_ctime":1616350029,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616350029","product_id":100056701,"comment_content":"想了解主从切换后，其他从和新主之间的增量同步","like_count":0},{"had_liked":false,"id":284432,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1616247071,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1616247071","product_id":100056701,"comment_content":"这一讲应该是对前面 9 讲一次很好的复习与回顾，其中一些课后题我也试着思考过，其中大部分都距离标准答案有一些距离。<br><br>其实我觉得这是一种很好的回顾方式，希望极客时间以后的专栏都能采取类似的方式，有课后思考题，有解答，当然还要有课代表。<br><br>课代表同学这次没有出现，让人感觉似乎少了点什么。","like_count":0},{"had_liked":false,"id":279386,"user_name":"听雨","can_delete":false,"product_type":"c1","uid":1254493,"ip_address":"","ucode":"252754F9FCFF0C","user_header":"https://static001.geekbang.org/account/avatar/00/13/24/5d/65e61dcb.jpg","comment_is_top":false,"comment_ctime":1613745732,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1613745732","product_id":100056701,"comment_content":"单机部署下还会有repl_backlog_buffer吗<br>","like_count":0,"discussions":[{"author":{"id":2104856,"avatar":"https://static001.geekbang.org/account/avatar/00/20/1e/18/9d1f1439.jpg","nickname":"liaomars","note":"","ucode":"4FCA97EE9FB57D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535104,"discussion_content":"这个是buffer是在主从模式下面才会创建的，所以单机单实例是没有的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638352280,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":269981,"user_name":"嚆同学","can_delete":false,"product_type":"c1","uid":1018329,"ip_address":"","ucode":"5F5BFE47B3302C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/89/d9/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1608867318,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608867318","product_id":100056701,"comment_content":"老师讲的很好，受益良多","like_count":0},{"had_liked":false,"id":269330,"user_name":"Dolly","can_delete":false,"product_type":"c1","uid":1513825,"ip_address":"","ucode":"CC74978F393055","user_header":"https://static001.geekbang.org/account/avatar/00/17/19/61/119cbde2.jpg","comment_is_top":false,"comment_ctime":1608614862,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608614862","product_id":100056701,"comment_content":"太强了。。前九讲有些忘记和疑惑的地方，这一节基本上都回忆起来了","like_count":0},{"had_liked":false,"id":260407,"user_name":"明月几时","can_delete":false,"product_type":"c1","uid":1675716,"ip_address":"","ucode":"E46C844EAB2CD0","user_header":"https://static001.geekbang.org/account/avatar/00/19/91/c4/bcdcda65.jpg","comment_is_top":false,"comment_ctime":1604999175,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1604999175","product_id":100056701,"comment_content":"整数数组和压缩列表的设计，充分体现了 Redis“又快又省”特点中的“省”，也就是节省内存空间。整数数组和压缩列表都是在内存中分配一块地址连续的空间，然后把集合中的元素一个接一个地放在这块空间内，非常紧凑。因为元素是挨个连续放置的，我们不用再通过额外的指针把元素串接起来，这就避免了额外指针带来的空间开销。","like_count":0},{"had_liked":false,"id":259007,"user_name":"好好学习","can_delete":false,"product_type":"c1","uid":1762191,"ip_address":"","ucode":"9D44D9530D9A1D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/e3/8f/77b5a753.jpg","comment_is_top":false,"comment_ctime":1604595199,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604595199","product_id":100056701,"comment_content":"棒棒棒","like_count":0},{"had_liked":false,"id":256909,"user_name":"闲敲棋子落灯花","can_delete":false,"product_type":"c1","uid":1305980,"ip_address":"","ucode":"64908160BFBCB9","user_header":"https://static001.geekbang.org/account/avatar/00/13/ed/7c/6cdd7190.jpg","comment_is_top":false,"comment_ctime":1603781200,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"1603781200","product_id":100056701,"comment_content":"老师您好，我有个问题没想通需请教您：我刚开始的想法也和本章下留言的@zhou 同学一样，以为fork 出来的子进程会复制一份物理内存数据过来（这和第5章的课后问题刚好对上 2G+（2G*80%）=3.6G），但是看到本章问题3中“实际上只会复制一份页表，相对于内存数据，页表数据小很多”   感觉和第5章的课后题冲突，所以不明白fork出来的子进程到底占用多少空间？如果页表数据小很多那么第5章的课后题应该远远小于1.6G才对。。。","like_count":0,"discussions":[{"author":{"id":2340727,"avatar":"","nickname":"Geek_17c6b0","note":"","ucode":"B9A28CE4126085","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330242,"discussion_content":"我也初学  感觉上应该是 写时复制时  \na.  fork出的子进程只复制原物理内存的页表  \nb.  主进程会将修改的内容    新写一份内存  80%的修改  对应的1.6GB内存","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1606549147,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1221628,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a3/fc/379387a4.jpg","nickname":"ly","note":"","ucode":"5E2B85252DABF3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367711,"discussion_content":"应该是如果rdb的操作足够慢，就会存在1.6g的多余分配","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1618447762,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1073443,"avatar":"https://static001.geekbang.org/account/avatar/00/10/61/23/30d134cf.jpg","nickname":"Young","note":"","ucode":"075C0BBE20FD8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371737,"discussion_content":"1.6G的内存是主进（线）程收到修改或新写操作，采用COW机制，新分配的内存数量（2x0.8=1.6），和子进程没有关系","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1619945833,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1346215,"avatar":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","nickname":"William","note":"","ucode":"55F5D9DEE485B1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347020,"discussion_content":"我理解的是80%频繁写入的最大变动阈值1.6G","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1612141981,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":252069,"user_name":"Joker","can_delete":false,"product_type":"c1","uid":1382003,"ip_address":"","ucode":"BD5B1AF491D60C","user_header":"https://static001.geekbang.org/account/avatar/00/15/16/73/c3aa4992.jpg","comment_is_top":false,"comment_ctime":1602086607,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1602086607","product_id":100056701,"comment_content":"老师，我想问个一直困惑我的问题，希望能解答。在ziplist结构中，如果移除头部的entry，是否都会产生连锁更新的效应？如果是这样的话，是不是意味着，list类型quicklist结构下，移除头部元素的时间复杂度不是O（1）呢？","like_count":0,"discussions":[{"author":{"id":1123146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/4a/c608bdf6.jpg","nickname":"三石","note":"","ucode":"734DCECABC3BEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389674,"discussion_content":"移除理论上不会导致连锁更新的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629373639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1977474,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/2c/82/98e2b82a.jpg","nickname":"Reborn 2.0","note":"","ucode":"BA506E7455D91C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":316114,"discussion_content":"后面的quickList是不是写错了啊? 我觉得应该是不是O(1), 但是元素少, 也没太消耗吧.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603361286,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":247303,"user_name":"wxj","can_delete":false,"product_type":"c1","uid":1487456,"ip_address":"","ucode":"B9BFE650BC4A39","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLzSRrK59sydq3k5uTE9SzPYShHo3PqGh8GTk3be0pHjS7eGTdw27cUyI0M4UEiaicoV2PJpiajWGTtQ/132","comment_is_top":false,"comment_ctime":1599653784,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1599653784","product_id":100056701,"comment_content":"请问老师新增从库进行全量复制时，主库新生成RDB。slave_repl_offset是从0开始，还是从repl_backlog_buffer与RDB最后一个数据相对应得位置开始呢？会不会影响后面哨兵的选举？","like_count":0,"discussions":[{"author":{"id":1123146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/4a/c608bdf6.jpg","nickname":"三石","note":"","ucode":"734DCECABC3BEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389675,"discussion_content":"主库开始rdb时刻的offset应该会带给需要全量同步的从库，从库的增量同步就从这个偏移量开始。哨兵选举仅限于哨兵内部吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629373778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245151,"user_name":"松果","can_delete":false,"product_type":"c1","uid":1274379,"ip_address":"","ucode":"22D872F0532BE6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erCXMLHlLs8TTRvw6BL13Zd0IGFeVZdicCsHnjJmM1FUC43sibcHIK0ViaIaOvOb5BVTlr3OTJNwaKzA/132","comment_is_top":false,"comment_ctime":1598846237,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598846237","product_id":100056701,"comment_content":"replication buffer 被写满，RDB全量复制还没有完成，会发成buffer覆盖吗？需要重新RDB操作吗？","like_count":0},{"had_liked":false,"id":244873,"user_name":"yyl","can_delete":false,"product_type":"c1","uid":1170843,"ip_address":"","ucode":"1741DACDFCA9AF","user_header":"https://static001.geekbang.org/account/avatar/00/11/dd/9b/0bc44a78.jpg","comment_is_top":false,"comment_ctime":1598712020,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1598712020","product_id":100056701,"comment_content":"replication buffer对应代码中的定义在哪里呢？","like_count":0,"discussions":[{"author":{"id":1073443,"avatar":"https://static001.geekbang.org/account/avatar/00/10/61/23/30d134cf.jpg","nickname":"Young","note":"","ucode":"075C0BBE20FD8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371743,"discussion_content":"我认为应该是server.h\ntypedef struct client｛\n    list *reply；\n｝","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619948520,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244871,"user_name":"yyl","can_delete":false,"product_type":"c1","uid":1170843,"ip_address":"","ucode":"1741DACDFCA9AF","user_header":"https://static001.geekbang.org/account/avatar/00/11/dd/9b/0bc44a78.jpg","comment_is_top":false,"comment_ctime":1598711320,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598711320","product_id":100056701,"comment_content":"server.h中，结构体redisServer的如下字段是 repl_backlog_buffer<br> char *repl_backlog;             &#47;* Replication backlog for partial syncs *&#47;","like_count":0},{"had_liked":false,"id":244510,"user_name":"Geek_e0ee48","can_delete":false,"product_type":"c1","uid":1904256,"ip_address":"","ucode":"11D10A0F5892AB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIgDicRj9LAvWSejVc6v34R6dR1yRHzqBgEpABeRwDvNcpoFW6zmiavwV5cP1fCKJiaQPiafP9E7Puqnw/132","comment_is_top":false,"comment_ctime":1598543648,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1598543648","product_id":100056701,"comment_content":"老师，您好：<br>关于写时复制还是有些疑问。比如说某一份数据a 刚开始的时候指针*a = 0x12345678,指针指向的值是1。那么：<br>1、fork出子进程了以后，两个进程中指针a的地址会是什么呢？都是指向同一份数据？<br> 2、 父进程写时复制分配了新的物理页，指针a的地址又是什么？会变吗？程序实际执行过程是什么样的，父进程中修改了a的地址以及其指向的值？<br>","like_count":0,"discussions":[{"author":{"id":1073443,"avatar":"https://static001.geekbang.org/account/avatar/00/10/61/23/30d134cf.jpg","nickname":"Young","note":"","ucode":"075C0BBE20FD8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371746,"discussion_content":"1. 首先你需要知道我们看到的指针都是进程内虚拟地址空间的虚拟地址，由于ASLR，不能保证即使同一份代码的两个进程实例里同一个变量是相同的地址。 所以在子进程中a的值（地址）不一定是0x12345678，但指向的值肯定是1，因为他们指向的物理内存是同一块。\n\n2. 主进程试图修改a指向的内容时，cow发生，a的值（地址）还是0x12345678，但是实际上他已经指向另外一块新的物理内存，指向的值不再是1，而是你修改的值。\n\n更多信息，可以参考经典《深入了解计算机系统》，虚拟内存章节。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619949728,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1106123,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKOASyV1lpdkW6It8WQltNGj9021PTibqOwRUTccaSUEM1GmQThOTIRp9Eu7XNZZFfGGNveLbUSw9Q/132","nickname":"tick","note":"","ucode":"D2C864306C06CB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319906,"discussion_content":" 写时复制指的是复制页表吧，和内存的数据没关系","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604189580,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244226,"user_name":"可怜大灰狼","can_delete":false,"product_type":"c1","uid":1928373,"ip_address":"","ucode":"6CA9D6D460B967","user_header":"https://static001.geekbang.org/account/avatar/00/1d/6c/b5/32374f93.jpg","comment_is_top":false,"comment_ctime":1598434472,"is_pvip":true,"discussion_count":3,"race_medal":0,"score":"1598434472","product_id":100056701,"comment_content":"问题：采用渐进式 hash 时，如果实例暂时没有收到新请求，是不是就不做 rehash 了？<br>翻了下代码dict.c&#47;dictRehashMilliseconds，发现每次都是先rehash100个槽，然后判断耗时有没有超过1ms。所以老师这句“每次执行时长不会超过 1ms”，准确来说应该是“尽量保证每次执行时间在1ms”。<br>附代码：<br>int dictRehashMilliseconds(dict *d, int ms) {<br>    long long start = timeInMilliseconds();<br>    int rehashes = 0;<br><br>    while(dictRehash(d,100)) {<br>        rehashes += 100;<br>        if (timeInMilliseconds()-start &gt; ms) break;<br>    }<br><br>    return rehashes;<br>}<br><br>有个问题：这种模式下，每次rehash100个槽。万一每个槽数据比较多，会不会对其他任务造成影响？还是估算过了rehash100个槽也不会有多少数据？","like_count":1,"discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301525,"discussion_content":"1、只是修改指针，速度会很快，不影响其他任务。\n\n2、访问时和定时检测reash，正常情况下，db下的哈希表分布相对是比较均匀的，所以rehash 100个槽理论来说不会出现数据过多的情况。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1598544300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1896933,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJZBe7lmwPf33yS7btnXuwv2bvfC7zfKibcZfPUQKTlbJgZeKY0wX70LUsej8EX14rYcCZ5Gk02YTQ/132","nickname":"aworker","note":"","ucode":"DCF95BC2087D35","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":371304,"discussion_content":"只是修改指针，也是需要修改100个hash槽中的每个entry的指针啊，量也可能很大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619710491,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301525,"ip_address":""},"score":371304,"extra":""}]},{"author":{"id":1020629,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/d5/699384a0.jpg","nickname":"yeek","note":"","ucode":"A1C71023113CB9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301519,"discussion_content":"修改指针 不移动实际数据 应该不影响","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598543287,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244177,"user_name":"小氘","can_delete":false,"product_type":"c1","uid":1622109,"ip_address":"","ucode":"DA55B9A02D9EE0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erPMtAfnQdpx1yOZQ2ic7icqUs3tvibEjUXQMUXKiaakyuIho6k6vmdl46nrdWjXIjPIRg9Pmco00tR5w/132","comment_is_top":false,"comment_ctime":1598418859,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598418859","product_id":100056701,"comment_content":"谢谢老师的答疑。","like_count":0},{"had_liked":false,"id":244155,"user_name":"黑山老妖","can_delete":false,"product_type":"c1","uid":1115958,"ip_address":"","ucode":"A1659F99C5BE1E","user_header":"https://static001.geekbang.org/account/avatar/00/11/07/36/d677e741.jpg","comment_is_top":false,"comment_ctime":1598412805,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598412805","product_id":100056701,"comment_content":"多谢老师的讲解<br>","like_count":0},{"had_liked":false,"id":244153,"user_name":"Lemon","can_delete":false,"product_type":"c1","uid":2136414,"ip_address":"","ucode":"E52BB361B69825","user_header":"https://static001.geekbang.org/account/avatar/00/20/99/5e/33481a74.jpg","comment_is_top":false,"comment_ctime":1598412686,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598412686","product_id":100056701,"comment_content":"感谢解答。","like_count":0},{"had_liked":false,"id":244132,"user_name":"Q","can_delete":false,"product_type":"c1","uid":1047423,"ip_address":"","ucode":"785546C617D3DF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/7f/746a6f5e.jpg","comment_is_top":false,"comment_ctime":1598407422,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598407422","product_id":100056701,"comment_content":"赞，获益良多！","like_count":0}]}