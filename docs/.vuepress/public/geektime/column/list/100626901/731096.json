{"id":731096,"title":"20｜生命周期：Rust如何做基本的生命周期符号标注？","content":"<p>你好，我是Mike，今天我们来了解一下Rust中的生命周期到底是什么。</p><p>你可能在互联网上的各种资料里早就见到过这个概念了，生命周期可以说是Rust语言里最难理解的概念之一，也是导致几乎所有人都觉得Rust很难，甚至很丑的原因。其实对于初学者来说，至少在开始的时候，它并不是必须掌握的，网上大量的资料并没有指明这一点，更加没有考虑到的是应该如何让初学者更加无痛地接受生命周期这个概念，而这也是我们这门课程尝试解决的问题。</p><p>下面让我们从一个示例说起，看看为什么生命周期的概念在Rust中是必要的。</p><h2>从URL解析说起</h2><p>URL协议类似下面这个样子，可以粗略地将一个URL分割成5部分，分别是 protocol、host、path、query、fragment。</p><p><img src=\"https://static001.geekbang.org/resource/image/af/yy/af56c3bbec82d825d566c43af83048yy.jpg?wh=1755x436\" alt=\"\"></p><p>现在我们拿到一个URL字符串，比如就是图片里的这个。</p><pre><code class=\"language-plain\">let s = \"https://rustcc.cn/article?id=019f9937#title\".to_string();\n</code></pre><p>现在要把它解析成Rust的结构体类型，按照我们已掌握的知识，先定义URL结构体模型，定义如下：</p><pre><code class=\"language-plain\">struct Url {\n    protocol: String,\n    host: String,\n    path: String,\n    query: String,\n    fragment: String,\n}\n</code></pre><!-- [[[read_end]]] --><p>没有问题，URL图示里的5大部分都已定义好了。解析出来大致就是这样一个效果。</p><pre><code class=\"language-plain\">let a_url = Url {\n    protocol: \"https\".to_string(),\n    host: \"rustcc.cn\".to_string(),\n    path: \"/article\".to_string(),\n    query: \"id=019f9937\".to_string(),\n    fragment: \"title\".to_string(),\n};\n</code></pre><p>这样完全没有问题，我们把一个字符串切割成5部分，转换成了一个结构体。不过这并不算一种高效的做法，在计算机系统里面，会做5次堆内存分配的操作。我们来看一下字符串转换成结构体之后栈和堆的示意图。</p><p><img src=\"https://static001.geekbang.org/resource/image/eb/70/ebf134bdc146ccf0de5cbf62ae032270.jpg?wh=1644x1152\" alt=\"\"></p><p>也就是说，我们把一个大的字符串，分成了5个小的字符串，并且每个小的字符串在堆里都单独分配了一块内存，原理上确实没问题，但从计算机科学来讲，5次堆内存的分配代价有点大。</p><p>那到底在性能上有什么问题呢？或者换句话问，有什么优化的方案呢？答案就是对于这种<strong>只读解析</strong>，也就是没有修改需求的场景，我们不需要为每一个碎片单独分配一个堆内存，只需要定义5个切片引用就可以了。</p><p>在Rust语言里，你可以这样去定义这个结构体。</p><pre><code class=\"language-plain\">struct Url {\n    protocol: &amp;str,\n    host: &amp;str,\n    path: &amp;str,\n    query: &amp;str,\n    fragment: &amp;str,\n}\n</code></pre><p>但是这样是没法通过编译的，需要加上一个东西，就是 <code>&lt;'a&gt;</code>。</p><pre><code class=\"language-plain\">struct Url&lt;'a&gt; {\n    protocol: &amp;'a str,\n    host: &amp;'a str,\n    path: &amp;'a str,\n    query: &amp;'a str,\n    fragment: &amp;'a str,\n}\n</code></pre><p>然后像这样来创建Url实例。</p><pre><code class=\"language-plain\">let a_url = Url {\n    protocol: &amp;s[..5],\n    host: &amp;s[8..17],\n    path: &amp;s[17..25],\n    query: &amp;s[26..37],\n    fragment: &amp;s[38..43],\n};\n</code></pre><p>然后，创建出来的内存结构是这样的：</p><p><img src=\"https://static001.geekbang.org/resource/image/27/62/278716989240e8f04ed4851e4ac07a62.jpg?wh=1644x1157\" alt=\"\"></p><p>有看到区别吗？新的方式 Url 实例 a_url 里的5个字段 protocol、host、path、query、fragment 都只是存的切片引用，指向原始字符串s的某一个片断，不再单独分配一块块内存碎片了。这样整个过程就少分配了5次堆内存，解析出来的结构体占用内存比较少，而且解析过程中的性能很高。</p><p>这个示例反映了Rust语言的一大特点，就是<strong>提供了最大的可能性</strong>，既可以简单粗暴侧重于易用性，先把东西做出效果，又可以用另外的方案从底层实现上做优化。<strong>这种优化在Rust语言就能完成，而不需要借助额外的语言或设施</strong>。</p><p>从这个示例，我们引出了这样一种符号 <code>'a</code>。</p><pre><code class=\"language-plain\">struct Url&lt;'a&gt; {\n    protocol: &amp;'a str,\n    host: &amp;'a str,\n    path: &amp;'a str,\n    query: &amp;'a str,\n    fragment: &amp;'a str,\n}\n</code></pre><p>它是什么呢？</p><h2>Rust中的生命周期</h2><p><code>'a</code> 这种符号是引用的生命周期符号，用来标识一个结构体里是否有对外部资源的引用，从而帮助Rust的借用检查器（Borrow Checker）对引用的有效性进行<strong>编译时</strong>分析。</p><p>和大部分语言一样，在Rust里，任何变量都有scope，一般由最里层的花括号所定义。比如：</p><pre><code class=\"language-plain\">fn foo() -&gt; {\n    let a = String::from(\"abc\");\n    //\n    {\n      let b = String::from(\"def\");\n    }\n}\n</code></pre><p>例子里，变量a的scope为从定义时开始，到第7行 <code>foo()</code> 函数的花括号结束。而变量b的scope为从定义时开始到第6行花括号结束。</p><p>但这个规则在Rust中只是针对所有权型变量的。对引用型变量来说，在Rust里有更严格的scope要求。</p><pre><code class=\"language-plain\">fn foo() -&gt; {\n    let a = String::from(\"abc\");\n    let a_ref = &amp;a;\n    println!(\"{}\", a_ref);\n    //\n}\n</code></pre><p>例子中，对于引用型变量 <code>a_ref</code> 来讲，由于它持有的是对所有权型变量a的引用，<code>a_ref</code> 实际的scope只是从第3行定义时开始到第4行最后一次使用时结束（这个规则我们在<a href=\"https://time.geekbang.org/column/article/720128\">第 3 讲</a>中已经验证过），到不了第6行的花括号。也就是说，Rust里的引用型变量的scope看起来总是要比对应的所有权型变量的scope要小。</p><p>这个很容易理解，因为所谓引用，就是必定有效的指针。<strong>必定有效的意思就是，只要这个引用型变量还在，那它所指向的那个目标对象就一定在</strong>。Rust中采用的是彻底的静态分析技术（相对于运行时检查），希望在编译期间能够清楚地计算出每个资源，还有指向这个资源的引用的有效存在区间。要准确，既不能多，也不能少，并且两个要匹配好。于是Rust引入了所有权的设计，来描述对资源的管理。这是一个根上的设计，它的引入不可避免地带来了一整套后续的机制。</p><ul>\n<li>借用与引用\n<ul>\n<li>不可变引用</li>\n<li>可变引用</li>\n</ul>\n</li>\n<li>引用的生命周期分析</li>\n</ul><p>所有权的生命周期scope的分析是比较简单的，用所在层次花括号规则就可以处理。难点在于引用的生命周期scope的分析，这个工作就是由Borrow Checker来做的。因为代码逻辑可能非常复杂，很难找到一种智能的方法可以通用地并且完全正确地处理所有代码中的引用。这非常困难，编程语言发展了几十年，其他语言要么如C这种放弃治疗，把这个问题全部交给程序员自己处理，要么像  Java 这种引入GC层，用GC来统一管理对资源的引用。</p><p>因此目前阶段Rust还需要我们程序员人为地为它提供一些信息标注，而 <code>'a</code> 就是这样一种信息标注机制。有可能后面随着AI的蓬勃发展，未来能出现可靠的方案，我们就不再需要手动添加这些标注信息了，但目前还是需要的。</p><p><strong><code>'a</code> 代表某一片代码区间，这片代码区间就是被这种符号标注的引用的有效存在区间。</strong></p><h3>结构体中的引用</h3><p>上面示例的结构体Url中，<code>&lt;'a&gt;</code> 是表示定义一个生命周期符号 <code>'a</code>，这个 <code>'a</code> 的名字可以任意取，比如取名 <code>'abc</code>、<code>'h</code>、<code>'helloworld</code> 等都是可以的。一般使用单小写字母表示，但是你如果看到单词形式的生命周期符号也不要惊讶。比如：</p><pre><code class=\"language-plain\">struct Url&lt;'helloworld&gt; {\n  protocol: &amp;'helloworld str,\n  // ...\n}\n</code></pre><p>定义好 <code>'a</code> 符号后，需要标注到目标的引用上面去，上述示例中，&amp;str的 &amp; 和 str 之间，加 <code>'a</code>，写成 <code>&amp;'a str</code>。这样就表示<strong>结构体Url依赖一个外部资源</strong>，具体来说，是其protocol字段依赖于一个外部的字符串。在上述示例中，Url的5个字段都依赖于同一个外部字符串资源，因此只需要一个生命周期参数 <code>'a</code> 就行了。如果是依赖于不同的字符串资源，可以分开写成不同的生命周期参数 <code>'a</code>、<code>'b</code> 等。比如：</p><pre><code class=\"language-plain\">struct Url&lt;'a, 'b, 'c&gt; {\n    protocol: &amp;'a str,\n    host: &amp;'a str,\n    path: &amp;'b str,\n    query: &amp;'b str,\n    fragment: &amp;'c str,\n}\n</code></pre><p>上面的定义中，Url定义了三个生命周期参数 <code>'a</code>、<code>'b</code>、<code>'c</code>。从这个定义我们能清晰地看出，Url类型<strong>可能</strong>依赖于3个外部字符串资源。</p><p>当在类型上添加了生命周期符号标注后，对它做impl的时候也需要带上这个参数了。</p><pre><code class=\"language-plain\">struct Url&lt;'a&gt; {\n&nbsp; &nbsp; protocol: &amp;'a str,\n&nbsp; &nbsp; host: &amp;'a str,\n&nbsp; &nbsp; path: &amp;'a str,\n&nbsp; &nbsp; query: &amp;'a str,\n&nbsp; &nbsp; fragment: &amp;'a str,\n}\n\nimpl&lt;'a&gt; Url&lt;'a&gt; {    // 这里\n&nbsp; &nbsp; fn play() {}\n}\n</code></pre><p>请注意上面代码里的第9行 impl 后定义的 <code>&lt;'a&gt;</code> 参数，你可以发现 <code>'a</code> 的地位好像与类型参数 T 类似。</p><p>生命周期符号 <code>'a</code> 具有传染性。比如，一个结构体用于构建另一个结构体字段的时候。</p><pre><code class=\"language-plain\">struct Url&lt;'a&gt; {\n    protocol: &amp;'a str,\n    // ...\n}\n\nstruct Request&lt;'a&gt; {\n    url: Url&lt;'a&gt;,\n    body: String,\n    // ...\n}\n</code></pre><p>上面示例里，Request结构体中包含一个Url结构体的实例，因为Url类型带生命周期参数 <code>'a</code>，因此Request中也<strong>不得不</strong>带上同一个生命周期参数 <code>'a</code>。这就是<strong>生命周期参数的传染性</strong>。</p><p>这样标识是有好处的，因为Url的实例依赖于外部所有权资源，那么顺推Request类型的实例也要依赖于那些外部所有权资源。如果不标识，当嵌套层次过多了之后，你很难用肉眼分析出一个结构体类型到底是不是<strong>自包含</strong>（self-contained，也就是由自己掌握涉及资源的所有权）的。</p><p>好在Rust的严格性，要求你必须依次一个不差地标识出来，这样就不会出现潜在的问题了。不过总的来说，生命周期符号 <code>'a</code> 主要还是帮助Rust编译器的，而不是给程序员看的。程序员的直观感觉是它非常丑陋而且带来语法噪音。</p><p>在目前的技术能力下，通过引入生命周期符号标注，Rust能实现精准地分析引用的有效期。</p><h3>函数返回值中的引用</h3><p>除了结构体中，在其他语言元素上也会出现引用的场景。一大场景就是函数返回值中带引用，我们看下面这个函数。</p><pre><code class=\"language-plain\">fn foo() -&gt; &amp;str {\n&nbsp; &nbsp; let s = String::from(\"abc\");\n&nbsp; &nbsp; &amp;s&nbsp; \n}\n</code></pre><p>我们想返回 <code>foo</code> 函数里的局部变量s的引用，可以吗？肯定是不可以的。所有权变量s在 <code>foo()</code> 函数执行完后就被回收了，返回对这个字符串资源的引用不就是悬挂指针了吗？编译提示如下：</p><pre><code class=\"language-plain\">error[E0515]: cannot return reference to local variable `s`\n&nbsp;--&gt; src/main.rs:3:5\n&nbsp; |\n3 |&nbsp; &nbsp; &nbsp;&amp;s&nbsp; \n&nbsp; |&nbsp; &nbsp; &nbsp;^^ returns a reference to data owned by the current function\n</code></pre><p>那么，一个函数中返回一个类型的引用，有几种可能的情况呢？只有两种，一种是返回对外部全局变量的引用；另一种是返回函数的引用参数所指向资源的引用。</p><p>我们先看第一种情况。</p><pre><code class=\"language-plain\">static ASTRING: &amp;'static str = \"abc\";\nfn foo() -&gt; &amp;str {\n&nbsp; &nbsp; ASTRING\n}\n</code></pre><p>这是可以的。但实际这样写的价值不大，没多大用。</p><p>第二种情况：</p><pre><code class=\"language-plain\">fn foo(a: &amp;str) -&gt; &amp;str {\n&nbsp; &nbsp; a\n}\n</code></pre><p>这也是可以的，但这种只有一个引用类型的参数传入，再返回回去，好像也没多大意思。如果有多个引用类型的参数传入呢？比如：</p><pre><code class=\"language-plain\">fn foo(a: &amp;str, b: &amp;str) -&gt; &amp;str {\n&nbsp; &nbsp; a\n}\n</code></pre><p>Rust编译器开始抱怨了。</p><pre><code class=\"language-plain\">error[E0106]: missing lifetime specifier\n&nbsp;--&gt; src/lib.rs:1:29\n&nbsp; |\n1 | fn foo(a: &amp;str, b: &amp;str) -&gt; &amp;str {\n&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;----&nbsp; &nbsp; &nbsp;----&nbsp; &nbsp; &nbsp;^ expected named lifetime parameter\n&nbsp; |\n&nbsp; = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `a` or `b`\nhelp: consider introducing a named lifetime parameter\n&nbsp; |\n1 | fn foo&lt;'a&gt;(a: &amp;'a str, b: &amp;'a str) -&gt; &amp;'a str {\n&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp;++++&nbsp; &nbsp; &nbsp;++&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++\n</code></pre><p>它抱怨说，你少写了一个生命周期参数，因为函数的返回类型中包含一个借用值，但是函数签名中没有说这个借用是来自a还是b。然后还给出了一个建议，在函数参数和返回类型上，都加上生命周期参数 <code>'a</code>，就是像下面这个样子。</p><pre><code class=\"language-plain\">fn foo&lt;'a&gt;(a: &amp;'a str, b: &amp;'a str) -&gt; &amp;'a str {\n&nbsp; &nbsp; a\n}\n</code></pre><p>类似于在结构体上定义生命周期参数，在函数签名中，如果要引入生命周期参数，也需要先定义，就是定义在函数名 <code>foo</code> 后的 <code>&lt;&gt;</code> 里。先定义，再使用。定义之后，在后面的引用上才能使用这个符号。</p><p>但是我们函数实现中明确写了返回a的，感觉Rust略笨。实际上到目前为止，Rust只会基于函数签名，也就是传入传出的类型进行分析，而不会去分析函数体的实现，也就是不会去分析函数中的实现逻辑。只要返回值的类型没有问题，它就不会抱怨。我们再看一个示例。</p><pre><code class=\"language-plain\">fn foo(i: u32, a: &amp;str, b: &amp;str) -&gt; &amp;str {\n&nbsp; &nbsp; if i == 1 {\n&nbsp; &nbsp; &nbsp; &nbsp; a\n&nbsp; &nbsp; } else {\n&nbsp; &nbsp; &nbsp; &nbsp; b\n&nbsp; &nbsp; }\n}\n// 也需要写成\nfn foo&lt;'a&gt;(i: u32, a: &amp;'a str, b: &amp;'a str) -&gt; &amp;'a str {\n&nbsp; &nbsp; if i == 1 {\n&nbsp; &nbsp; &nbsp; &nbsp; a\n&nbsp; &nbsp; } else {\n&nbsp; &nbsp; &nbsp; &nbsp; b\n&nbsp; &nbsp; }\n}\n</code></pre><p>这个示例中，到底返回a还是b，在编译期是没办法确定下来的，只能在运行的时候，由具体传入的 <code>i</code> 值来确定。不过，Rust分析的时候，不关心这个具体的逻辑，它只看函数签名中的引用之间，有没有可能会发生关联。</p><pre><code class=\"language-plain\">fn foo&lt;'a&gt;(a: &amp;'a str, b: &amp;'a str) -&gt; &amp;'a str {\n</code></pre><p>在foo函数签名中出现了4次 <code>'a</code> 符号，除去第一个是定义 <code>'a</code>，后面3次都是使用 <code>'a</code>。这后面三个不同位置的 <code>'a</code> 的意义到底是什么呢？</p><p>首先，foo函数的两个参数a、b，它是外部字符串资源的引用。它们所指向的字符串资源，有两种情况：</p><ol>\n<li>为同一个字符串资源；</li>\n<li>为两个不同的字符串资源。</li>\n</ol><p>第一种情况比较好理解，返回的引用仍然指向这个字符串资源，因此它们标注为同一个 <code>'a</code> 生命周期参数符号。</p><p>第二种情况稍微复杂一些。a和b指向的是不同的字符串资源，对应的资源我们标记为 Ra 和 Rb，Ra和Rb有各自的scope。a是Ra的引用，b是Rb的引用，我们强行在这两个不同资源的引用上标注相同的生命周期参数 <code>'a</code>，它一定是做了某种操作，提供一些额外的信息。</p><p>因为Ra和Rb的scope一般不一样，我们假设Rb资源先释放，Ra资源后释放。那我们首先要保证的是在 <code>foo()</code> 函数执行期间，Ra和Rb都存在。在a和b的类型上强制标识 <code>'a</code>，<strong>实际上是给 <code>'a</code> 取了一个比较小的代码区间</strong>，也就是到Rb的资源释放的那一行代码为止。</p><p>同时我们还把 <code>'a</code> 标注到返回类型上，就<strong>意味着将 <code>'a</code> 指代的生命周期区间施加到了返回的引用上</strong>。我们可以用下面这个示例来验证这个论断。</p><pre><code class=\"language-plain\">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {\n&nbsp; &nbsp; if x.len() &gt; y.len() {\n&nbsp; &nbsp; &nbsp; &nbsp; x\n&nbsp; &nbsp; } else {\n&nbsp; &nbsp; &nbsp; &nbsp; y\n&nbsp; &nbsp; }\n}\n\nfn main() {\n&nbsp; &nbsp; let s1 = String::from(\"long string is long\");\n&nbsp; &nbsp; let result;\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; let s2 = String::from(\"xyz\");\n&nbsp; &nbsp; &nbsp; &nbsp; result = longest(s1.as_str(), s2.as_str());\n&nbsp; &nbsp; }\n&nbsp; &nbsp; println!(\"The longest string is {}\", result);\n}\n</code></pre><p>编译会报错：</p><pre><code class=\"language-plain\">error[E0597]: `s2` does not live long enough\n&nbsp; --&gt; src/main.rs:14:39\n&nbsp; &nbsp;|\n13 |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;let s2 = String::from(\"xyz\");\n&nbsp; &nbsp;|&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-- binding `s2` declared here\n14 |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;result = longest(s1.as_str(), s2.as_str());\n&nbsp; &nbsp;|&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^^^^^^^^^^^ borrowed value does not live long enough\n15 |&nbsp; &nbsp; &nbsp;}\n&nbsp; &nbsp;|&nbsp; &nbsp; &nbsp;- `s2` dropped here while still borrowed\n16 |&nbsp; &nbsp; &nbsp;println!(\"The longest string is {}\", result);\n&nbsp; &nbsp;|&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ------ borrow later used here\n</code></pre><p>从我们肉眼分析来看，result变量最后取的是s1的引用，并没有借用s2，它应该是在main函数里一直有效的，就是第16行应该能打印出正确的值。但是编译却不通过，为什么呢？</p><p>就是因为<strong>Rust是按生命周期来分析借用的，而不是靠函数逻辑</strong>。在这个例子里，Rust会分析出来，<code>longest()</code> 函数返回值的生命周期 <code>'a</code>，是到代码第15行，也就是s2被回收的地方，前面我们说过，会在s1和s2两个资源的scope中取较小的那个区间。也就是说，result这个引用型变量的scope到第15行为止，所以在第16行就不能再使用它了。这个例子你可以仔细体会一下。</p><p>是不是有点反直觉？如果靠我们人眼去分析，这个例子应该是可以正常打印的。这也是Rust初学者常常疑惑而且崩溃的地方，不太好懂。你可以骂一下，Rust傻。确实傻，目前分析领域的技术还做不到完美解决这个问题，所以有点傻，我们只能希望在未来的版本迭代中逐渐增强Rust的推理能力。</p><h3>类型方法中的引用</h3><p>回顾前面的内容，类型的方法只是第一个参数为Self的所有权或引用类型的函数。因此上面分析的函数返回值里引用的细节也适用于类型的方法。</p><p>比较特别的是，如果返回的值是Self本身或本身一部分的引用，就不用手动写 <code>'a</code> 生命周期符号，Rust会自动帮我们在方法返回值引用的生命周期和Self的scope之间进行绑定，这是一条默认的规则。</p><pre><code class=\"language-plain\">struct A {\n&nbsp; &nbsp; foo: String,\n}\n\nimpl A {\n&nbsp; &nbsp; fn play(&amp;self, a: &amp;str, b: &amp;str) -&gt; &amp;str {\n&nbsp; &nbsp; &nbsp; &nbsp; &amp;self.foo\n&nbsp; &nbsp; }\n}\n</code></pre><p>我们稍稍改一下代码就没办法编译通过了。</p><pre><code class=\"language-plain\">struct A {\n&nbsp; &nbsp; foo: String,\n}\n\nimpl A {\n&nbsp; &nbsp; fn play(&amp;self, a: &amp;str, b: &amp;str) -&gt; &amp;str {\n&nbsp; &nbsp; &nbsp; &nbsp; a\n&nbsp; &nbsp; }\n}\n</code></pre><p>编译提示：</p><pre><code class=\"language-plain\">error: lifetime may not live long enough\n&nbsp;--&gt; src/lib.rs:8:9\n&nbsp; |\n7 |&nbsp; &nbsp; &nbsp;fn play(&amp;self, a: &amp;str, b: &amp;str) -&gt; &amp;str {\n&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;- let's call the lifetime of this reference `'1`\n&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|\n&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;let's call the lifetime of this reference `'2`\n8 |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;a\n&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^ method was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n&nbsp; |\nhelp: consider introducing a named lifetime parameter and update trait if needed\n&nbsp; |\n7 |&nbsp; &nbsp; &nbsp;fn play&lt;'a&gt;(&amp;'a self, a: &amp;'a str, b: &amp;str) -&gt; &amp;str {\n&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++++&nbsp; ++&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;++\n</code></pre><p>解释说，本来我们期望方法返回类型的生命周期为Self的生命周期，结果你给我返回了另一个资源的生命周期，我并不认识那个资源，所以需要你手动标注。并且给出了修改建议，我们按建议修改一下。</p><pre><code class=\"language-plain\">struct A {\n&nbsp; &nbsp; foo: String,\n}\n\nimpl A {\n&nbsp; &nbsp; fn play&lt;'a&gt;(&amp;'a self, a: &amp;'a str, b: &amp;str) -&gt; &amp;str {\n&nbsp; &nbsp; &nbsp; &nbsp; a\n&nbsp; &nbsp; }\n}\n</code></pre><p>这下就可以通过了。可以看到上面示例里的play方法在参数a、参数self和返回值之间进行了绑定。</p><h3>'static</h3><p>在所有的生命周期参数符号里有一个是特殊的，那就是 'static，它代表所有生命周期中最长的那一个，和程序存在的时间一样长。它表示被标注的引用所指向的资源在整个程序执行期间都是有效的。比如：</p><pre><code class=\"language-plain\">fn main() {\n    let s: &amp;'static str = \"I have a static lifetime.\";\n}\n</code></pre><p>上面这个示例应该很容易理解，因为字符串字面量是存储在静态数据区的，程序存在多久，它就存在多久，它对应的局部变量 s（&amp;'static str）的生命周期也就跟着可以持续到程序结束。</p><p>因此 'static 是所有生命周期符号中最长的一个。</p><h2>对生命周期的理解</h2><h3>为什么放在尖括号中？</h3><p>在前面的讲解中我们看到，生命周期参数是放在 <code>&lt;&gt;</code> 尖括号里的。回想一下之前的知识点，只有类型参数才会放在尖括号里，为什么生命周期参数也放在这里面呢？</p><p>如果用一句话解释，那就是因为<strong>生命周期参数跟类型参数一样，也是 generic parameter 的一种</strong>，所以放在尖括号里，它俩的地位相同。</p><p>我们的程序跑起来，哪些资源会在什么时间分配出来，哪些资源会在什么时间回收，其实是个运行期间的概念。也就是说，是个时间上的概念。但对计算机来讲，每一条指令的执行，是要花相对确定的时间长度的，所以就在要执行的CPU指令条数和执行时间段上产生了正比映射关系。这就让我们在代码的编译期间去分析运行期间变量的生存时间区间变成可能。这就是Rust能够做生命周期分析的原因。</p><p>当我们使用生命周期参数标注 <code>'a</code> 的时候，并不能知道它所代表的将要运行的准确时间区间，或者说代码区间。比如对于函数来说，有可能它只运行一次，也有可能运行多次，运行在不同次数的时候，同一个 <code>'a</code> 参数可能代表的代码区间是不一样的。举例如下：</p><pre><code class=\"language-plain\">fn foo&lt;'a&gt;(a: &amp;'a str, b: &amp;'a str) -&gt; &amp;'a str {\n&nbsp; &nbsp; a\n}\n\nfn main() {\n    {\n        let s1 = \"abc\".to_string();\n        let s2 = \"def\".to_string();\n        let s3 = foo(&amp;s1, &amp;s2);\n        println!(\"{}\", s3);\n    }\n    // ...\n    let s4 = \"ghk\".to_string();\n    let s5 = \"uvw\".to_string();\n    let s6 = foo(&amp;s4, &amp;s5);\n    println!(\"{}\", s6);\n}\n</code></pre><p>在上面示例中，<code>foo()</code> 函数被调用了两次。在第一次调用的时候，<code>'a</code> 代表的生命周期区间是到第11行的花括号截止。在第二次调用的时候，<code>'a</code> 代表的生命周期区间是到第17行的花括号截止。所以两次 <code>'a</code> 的值是不同的。这也是我们要把 <code>'a</code> 叫做生命周期参数的原因。</p><p><code>'a</code> 代表代码区间或时间区间，在编译的时候，通过分析才会确定下来。因此和类型参数类似，我们也要把这种生命周期参数放到尖括号里定义。<strong>类型参数是空间上的展开（分析），生命周期参数是时间上的展开（分析）</strong>。</p><h3>关于 <code>'a</code> 的语法噪音</h3><p>前面我们讲解了Rust引入生命周期分析和生命周期参数标注符号的必要性和原因。但是不管怎样，这样的符号如果大量出现在代码中，会让代码变得很丑，充满噪音。</p><p>确实是这样的。至于当初为什么选择 <code>'a</code> 这种符号而不是其他符号，这个就不得而知了。也有可能键盘上的符号都差不多用完了，所以好像也没有其他更好的符号可以选。</p><p>好在你去阅读Rust生态里的代码的时候，<code>'a</code> 符号出现的频率并不高。特别是在偏上层的业务代码中，我们几乎见不到 <code>'a</code> 符号。</p><h3>什么时候可能会写生命周期参数？</h3><p>什么时候会倾向于写生命周期参数呢？一般写底层库或对代码做极致性能优化的时候。</p><p>如果只是写上层的业务，我们基本不会有写生命周期参数符号的需求。Rust的一些机制比如智能指针，能保证我们在只持有自包含类型的情况下，也能得到非常高的性能。一般来说，写代码有三个阶段。</p><p>首先是先跑通，完成需求。Rust的起点较高，使用Rust写出来的代码不需要怎么优化，就能让你在大部分情况下赢在起跑线上。</p><p>第二阶段是，追求架构上的美感。当你完成第一阶段验证，并稳定运行后，你可能会追求更好的架构，更漂亮的代码。这个时候，你可以在Rust中的所有权三态理论、强大的类型系统、灵活的trait抽象能力的指导下重构你的项目。有聪明的Rust小助手在，你的重构之路会变得异常轻松。</p><p>第三个阶段才是当你在业务上真正遇到性能瓶颈的时候，再回过头来优化。Rust极高的上限和可容纳任何机制的能力，让你无需借助其他语言就能完成优化任务。你可以选择使用引用和生命周期分析，减少内存分配次数，从而提升性能。当然，性能优化是一项综合性的课题，Rust不能帮你解决所有问题。</p><h3>关于API的最佳实践</h3><p>在库的API设计上，Rust社区有一条共识：不要向外暴露生命周期参数。这样才能让API的使用更简单，并且不会把生命周期符号传染到上层。</p><p>一个反例就是std里Cow类型的设计，导致现在很少有人会优先选择使用Cow类型。</p><pre><code class=\"language-plain\">pub enum Cow&lt;'a, B&gt; {}\n</code></pre><p>你可以查阅<a href=\"https://doc.rust-lang.org/std/borrow/enum.Cow.html\">链接</a>了解更多内容。</p><h2>小结</h2><p>所有权、借用（引用）、生命周期，这三兄弟是Rust中的一套高度耦合的概念，它们共同承担起了Rust底层的脏活累活，彻底扫清了最困难的障碍——正确高效地管理内存资源，为Rust实现安全编程和高性能编程打下了最坚实的基础。</p><p>所有权贯穿了Rust语言的所有主要特性，对应地，如果你继续深入钻研下去，你会发现生命周期概念也会贯穿那些特性。但是另外一方面，初学Rust也会有两个典型的认知错误。</p><ol>\n<li>我得把生命周期彻底掌握，才算学会Rust。</li>\n<li>生命周期太难，我迈不过去只能放弃。</li>\n</ol><p>对这两种认知，我想说：即使你把生命周期掌握得很溜，也不代表你就能用好Rust。Rust是一门面向实用的语言，将Rust用好涉及大量的领域知识，这些都需要你花时间去学习。需要你有效地分配时间。前期初学的时候基本碰不到写生命周期符号的机会，理解到这节课所覆盖的内容就差不多了。所以你不要惧怕这个概念，用Rust来解决你的实际问题，不要害怕clone。</p><p>Rust牵涉面过于广泛，学习语言不是为了炫技，应该以实用为主，学以致用，边学边用。Rust没有天花板，这也意味着你的成长也不会有上限，加油吧！</p><p><img src=\"https://static001.geekbang.org/resource/image/84/d0/84bcee8370aca3dacaeac720f01af6d0.jpg?wh=2746x2517\" alt=\"\"></p><h2>思考题</h2><p>你能说一说生命周期符号 <code>'a</code> 放在 <code>&lt;&gt;</code> 中定义的原因和意义吗？欢迎你把自己的理解分享到评论区，如果你觉得有收获的话，也欢迎你把这节课的内容分享给需要的朋友，我们下节课再见！</p>","neighbors":{"left":{"article_title":"19｜Rust的宏体系：为自己的项目写一个简单的声明宏","id":731043},"right":{"article_title":"答疑课堂（一）｜第一章Rust基础篇思考题答案","id":732080}},"comments":[{"had_liked":false,"id":385153,"user_name":"buoge","can_delete":false,"product_type":"c1","uid":1018506,"ip_address":"北京","ucode":"646FC6717A09BF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/8a/7c1baa25.jpg","comment_is_top":false,"comment_ctime":1702211015,"is_pvip":false,"replies":[{"id":140394,"content":"yeah","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1702251929,"ip_address":"重庆","comment_id":385153,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"下周可以实战了，好开心😁","like_count":5,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633478,"discussion_content":"yeah","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702251929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386651,"user_name":"seven9t","can_delete":false,"product_type":"c1","uid":1979955,"ip_address":"广东","ucode":"B7CA7D62C56938","user_header":"https://static001.geekbang.org/account/avatar/00/1e/36/33/3411df0d.jpg","comment_is_top":false,"comment_ctime":1705290652,"is_pvip":false,"replies":[{"id":140977,"content":"你的建议不错。这段的意思其实是要说明指令序列的执行需要占用一段时间，以对应一段生命周期。具体描述上还可以优化一下，感谢🙏","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1705410996,"ip_address":"重庆","comment_id":386651,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"&quot;但对计算机来讲，每一条指令的执行，是要花相对确定的时间长度的，所以就在要执行的 CPU 指令条数和执行时间段上产生了正比映射关系。这就让我们在代码的编译期间去分析运行期间变量的生存时间区间变成可能。这就是 Rust 能够做生命周期分析的原因。&quot;  静态分析和指令执行时间应该没关系，建议调整","like_count":3,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635967,"discussion_content":"你的建议不错。这段的意思其实是要说明指令序列的执行需要占用一段时间，以对应一段生命周期。具体描述上还可以优化一下，感谢🙏","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705410996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384820,"user_name":"伯阳","can_delete":false,"product_type":"c1","uid":1596631,"ip_address":"北京","ucode":"DBDC8735AA54AD","user_header":"https://static001.geekbang.org/account/avatar/00/18/5c/d7/3b92bb0d.jpg","comment_is_top":false,"comment_ctime":1701636996,"is_pvip":false,"replies":[{"id":140315,"content":"对的","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1701740383,"ip_address":"重庆","comment_id":384820,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"Rust 牵涉面过于广泛，学习语言不是为了炫技，应该以实用为主，学以致用，边学边用。Rust 没有天花板，感觉学无止境，学习任何一项知识都是学以致用","like_count":3,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632985,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1701740383,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384935,"user_name":"eriklee","can_delete":false,"product_type":"c1","uid":2826132,"ip_address":"北京","ucode":"6F755DB7C29DD6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIyhbzdkFM64Npva5ZKf4IPwhy6rDAX0L77QNESbalnXhnGKibcTbwtSaNC0hO6z0icO8DYI9Nf4xwg/132","comment_is_top":false,"comment_ctime":1701827741,"is_pvip":false,"replies":[{"id":140379,"content":"对的对的，是这样滴","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1701919646,"ip_address":"重庆","comment_id":384935,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"rust编译器也在不断进化，实际上2021版就比2018版少了很多需要生命周期标注的场景，我相信随着rust编译器的进化，以后可能只有1%的场景需要用到生命周期标注","like_count":2,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633234,"discussion_content":"对的对的，是这样滴","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1701919646,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385016,"user_name":"cfanbo","can_delete":false,"product_type":"c1","uid":1043738,"ip_address":"澳大利亚","ucode":"39D8D71453E575","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/1a/269eb3d6.jpg","comment_is_top":false,"comment_ctime":1701935962,"is_pvip":false,"replies":[{"id":140381,"content":"对的。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1701958157,"ip_address":"重庆","comment_id":385016,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"在 “函数返回值中的引用” 这个示例中，是不是可以理解为 返回的值是s1, 但它的生命周期却是s2的生命周期，因此导致最后打印语句执行前, 由于 s2 生命周期原因被drop，而导致编译出错？","like_count":1,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633294,"discussion_content":"对的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1701958157,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384910,"user_name":"PEtFiSh","can_delete":false,"product_type":"c1","uid":1765926,"ip_address":"四川","ucode":"C4922398A92E05","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLO6XvxfFPMGcVSSX8uIZY2yib29qlyat178pU4QM3gIic5GXZ8PC0tzRiazP3FiajXbTj19SE4ZhV0gQ/132","comment_is_top":false,"comment_ctime":1701776355,"is_pvip":false,"replies":[{"id":140372,"content":"可以类似理解，不过‘a不是类型，准确术语叫 generic lifetime parameter ","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1701919278,"ip_address":"重庆","comment_id":384910,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"对于编译器来说，看到&lt;&gt;就是要干活的。&lt;&#39;a&gt;可以理解为一种特殊的类型参数，编译器看到&lt;&gt;里的&#39;a并不会对类型做展开，而是去检查并计算引用的生命周期。","like_count":1,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633227,"discussion_content":"可以类似理解，不过‘a不是类型，准确术语叫 generic lifetime parameter ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1701919278,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384873,"user_name":"Geek_e72251","can_delete":false,"product_type":"c1","uid":3733050,"ip_address":"广东","ucode":"894904DE2E6AC0","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/VF71Gcf2C2bjYPFCRv0TPfwhkJmT5WhtusltuaXQM0KMDibdallNFypqWV6v2FJ4bqNwzujiaF5LEDeia7JMZTTtw/132","comment_is_top":false,"comment_ctime":1701705278,"is_pvip":false,"replies":[{"id":140327,"content":"哈哈，这个课程之后我还会持续输出的，可以关注这方面的内容。rust领域太广泛了，值得研究一辈子","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1701745864,"ip_address":"","comment_id":384873,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"还没到实战就已经63%的进度了😭实战内容不会很少吧。希望能够有怎么debug的教学。","like_count":1,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633009,"discussion_content":"哈哈，这个课程之后我还会持续输出的，可以关注这方面的内容。rust领域太广泛了，值得研究一辈子","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1701745864,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384827,"user_name":"-","can_delete":false,"product_type":"c1","uid":1546505,"ip_address":"北京","ucode":"7B34258D346793","user_header":"https://static001.geekbang.org/account/avatar/00/17/99/09/29c46a7b.jpg","comment_is_top":false,"comment_ctime":1701652076,"is_pvip":false,"replies":[{"id":140317,"content":"自己动手做实验得来的知识，真棒👍","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1701740477,"ip_address":"重庆","comment_id":384827,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"struct A {\n    foo: String,\n}\n\nimpl A {\n    fn play&lt;&#39;a&gt;(&amp;&#39;a self, a: &amp;&#39;a str, b: &amp;str) -&gt; &amp;str {\n        a\n    }\n}\n返回a的时候只需要标注a参数，而返回b的时候只需要标准b参数，这里进一步说明了类型标注只关注传入传出","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632987,"discussion_content":"自己动手做实验得来的知识，真棒👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1701740477,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":389992,"user_name":"Calvin","can_delete":false,"product_type":"c1","uid":1603004,"ip_address":"广东","ucode":"0EEF5B207623B5","user_header":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","comment_is_top":false,"comment_ctime":1714044190,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"【函数返回值中的引用】一个函数中返回一个类型的引用的第一种可能的情况（返回对外部全局变量的引用）示例的 foo() 函数的返回值类型应该也需要一个生命周期参数标注：\nstatic ASTRING: &amp;&#39;static str = &quot;abc&quot;;\nfn foo() -&gt; &amp;&#39;static str {    &#47;&#47; 默认的全局 &#39;static\n    ASTRING\n}\n或：\nstatic ASTRING: &amp;&#39;static str = &quot;abc&quot;;\nfn foo&lt;&#39;a&gt;() -&gt; &amp;&#39;a str {    &#47;&#47; 自定义的 &#39;a\n    ASTRING\n}","like_count":0},{"had_liked":false,"id":384819,"user_name":"伯阳","can_delete":false,"product_type":"c1","uid":1596631,"ip_address":"北京","ucode":"DBDC8735AA54AD","user_header":"https://static001.geekbang.org/account/avatar/00/18/5c/d7/3b92bb0d.jpg","comment_is_top":false,"comment_ctime":1701636950,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"Rust 牵涉面过于广泛，学习语言不是为了炫技，应该以实用为主，学以致用，边学边用。Rust 没有天花板","like_count":0}]}