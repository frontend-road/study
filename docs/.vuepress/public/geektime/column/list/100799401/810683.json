{"id":810683,"title":"18｜读懂MySQL中的执行计划（上）","content":"<p>你好，我是俊达。</p><p>上一讲我介绍了数据库中最主要的几种访问路径，不同的访问路径，在执行性能上可能会存在巨大的差别。但是我们怎么知道某一个具体的SQL语句在执行时，采用了什么样的访问路径呢？这就涉及到SQL的执行计划了。执行计划描述了SQL语句的访问路径，通过执行计划，我们可以知道：</p><ul>\n<li>表上是否有可用的索引，SQL执行时是否使用了索引，使用了哪些索引？</li>\n<li>表连接的顺序是怎样的？</li>\n<li>使用了哪种表连接算法，是用了Nest Loop还是Hash Join？</li>\n<li>查询是否用到了临时表，是否进行了文件排序？</li>\n</ul><p>在MySQL中，我们使用Explain命令查看语句的执行计划。这一讲中我会使用四十多个演示SQL，来解释EXPLAIN输出信息的具体含义。至于为什么一个SQL使用了这个执行计划，而不是别的执行计划，我会在接下来的几讲中慢慢展开。</p><p>为了便于演示各种不同的执行计划，我使用了下面这些测试表和测试数据，你也可以在自己的环境中进行测试。</p><pre><code class=\"language-plain\">CREATE TABLE `digit` (\n  `a` tinyint NOT NULL,\n  PRIMARY KEY (`a`)\n) ENGINE=InnoDB;\n\ninsert into digit values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);\n\nCREATE VIEW numbers AS \nselect a.a*1000 + b.a*100 + c.a*10 + d.a as n \nfrom digit a, digit b, digit c, digit d;\n\n-- 本章中大部分案例都使用tab表\nCREATE TABLE `tab` (\n  `id` int NOT NULL AUTO_INCREMENT,\n  `a` int NOT NULL,\n  `b` int NOT NULL,\n  `c` int NOT NULL,\n  `padding` varchar(7000) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `idx_abc` (`a`,`b`,`c`)\n) ENGINE=InnoDB;\n\ninsert into tab (a,b,c,padding) \nselect n%3, n, n%100, rpad('x', 100, 'x')  \nfrom numbers where n &lt; 10000;\n\n-- t_merge主要用于演示index_merge的几种情况\ncreate table t_merge(\n    id int not null auto_increment, \n    a int not null,\n    b int not null,\n    c int not null,\n    d int not null,\n    padding varchar(4000),\n    primary key(id),\n    key idx_ad(a,d),\n    key idx_bd(b,d),\n    key idx_cd(c,d)\n) ENGINE=InnoDB;\n\ninsert into t_merge(a,b,c,d,padding)\nselect n % 3 + 1, n % 17 + 1, n % 19 + 1, n % 10 + 1, rpad('y', 100, 'y')\nfrom numbers\nwhere n between 1 and 3*17*19*10;\n</code></pre><!-- [[[read_end]]] --><h2>使用EXPLAIN命令</h2><p>使用EXPLAIN命令可以查看SELECT、INSERT、UPDATE、DELETE、REPLACE等语句的执行计划。EXPLAIN命令的基本语法如下：</p><pre><code class=\"language-plain\">explain [format=traditional|json|tree] SQL Statement\n</code></pre><p>FORMAT指定了执行计划的输出格式，不指定时，默认以表格形式输出执行计划。</p><pre><code class=\"language-plain\">mysql&gt; explain select * from tab;\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+\n| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+\n|  1 | SIMPLE      | tab   | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9755 |   100.00 | NULL  |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+\n</code></pre><p>FORMAT指定为TREE时，以树的形式显示执行计划，这种显示格式和Oracle执行计划的显示方式比较像。</p><p>下面这个测试SQL中，使用了NO_SEMIJOIN提示，阻止优化器将子查询改写成表连接。你可以试一下，将提示去掉后，会使用怎样的执行计划。</p><pre><code class=\"language-plain\">explain format=tree \nselect  /*+ NO_SEMIJOIN(@subq1)  */ * \nfrom tab a \nwhere id in ( \n    select /*+ QB_NAME(subq1) */ id from tab b \n)\n</code></pre><pre><code class=\"language-plain\">EXPLAIN: -&gt; Filter: &lt;in_optimizer&gt;(a.id,&lt;exists&gt;(select #2))&nbsp; (cost=1031.55 rows=9913)\n&nbsp; &nbsp; -&gt; Table scan on a&nbsp; (cost=1031.55 rows=9913)\n&nbsp; &nbsp; -&gt; Select #2 (subquery in condition; dependent)\n&nbsp; &nbsp; &nbsp; &nbsp; -&gt; Limit: 1 row(s)&nbsp; (cost=0.35 rows=1)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -&gt; Single-row covering index lookup on b using PRIMARY (id=&lt;cache&gt;(a.id))&nbsp; (cost=0.35 rows=1)\n</code></pre><p>FORMAT指定为JSON时，以JSON格式显示执行计划。JSON格式的执行计划中，可以看到一些成本的信息。</p><pre><code class=\"language-plain\">explain format=json \nselect  /*+ NO_SEMIJOIN(@subq1)  */ * \nfrom tab a \nwhere id in ( \n    select /*+ QB_NAME(subq1) */ id from tab b \n)\n\n{\n&nbsp; \"query_block\": {\n&nbsp; &nbsp; \"select_id\": 1,\n&nbsp; &nbsp; \"cost_info\": {\n&nbsp; &nbsp; &nbsp; \"query_cost\": \"1031.55\"\n&nbsp; &nbsp; },\n&nbsp; &nbsp; \"table\": {\n&nbsp; &nbsp; &nbsp; \"table_name\": \"a\",\n&nbsp; &nbsp; &nbsp; \"access_type\": \"ALL\",\n&nbsp; &nbsp; &nbsp; \"rows_examined_per_scan\": 9913,\n&nbsp; &nbsp; &nbsp; \"rows_produced_per_join\": 9913,\n&nbsp; &nbsp; &nbsp; \"filtered\": \"100.00\",\n&nbsp; &nbsp; &nbsp; \"cost_info\": {\n&nbsp; &nbsp; &nbsp; &nbsp; \"read_cost\": \"40.25\",\n&nbsp; &nbsp; &nbsp; &nbsp; \"eval_cost\": \"991.30\",\n&nbsp; &nbsp; &nbsp; &nbsp; \"prefix_cost\": \"1031.55\",\n&nbsp; &nbsp; &nbsp; &nbsp; \"data_read_per_join\": \"264M\"\n&nbsp; &nbsp; &nbsp; },\n&nbsp; &nbsp; &nbsp; \"used_columns\": [\n&nbsp; &nbsp; &nbsp; &nbsp; \"id\",\n&nbsp; &nbsp; &nbsp; &nbsp; \"a\",\n&nbsp; &nbsp; &nbsp; &nbsp; \"b\",\n&nbsp; &nbsp; &nbsp; &nbsp; \"c\",\n&nbsp; &nbsp; &nbsp; &nbsp; \"padding\"\n&nbsp; &nbsp; &nbsp; ],\n&nbsp; &nbsp; &nbsp; \"attached_condition\": \"&lt;in_optimizer&gt;(`rep`.`a`.`id`,&lt;exists&gt;(&lt;primary_index_lookup&gt;(&lt;cache&gt;(`rep`.`a`.`id`) in tab on PRIMARY)))\",\n&nbsp; &nbsp; &nbsp; \"attached_subqueries\": [\n&nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"dependent\": true,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"cacheable\": false,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"query_block\": {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"select_id\": 2,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"cost_info\": {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"query_cost\": \"0.35\"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"table\": {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"table_name\": \"b\",\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"access_type\": \"unique_subquery\",\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"possible_keys\": [\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"PRIMARY\"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ],\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"key\": \"PRIMARY\",\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"used_key_parts\": [\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"id\"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ],\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"key_length\": \"4\",\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"ref\": [\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"func\"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ],\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"rows_examined_per_scan\": 1,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"rows_produced_per_join\": 1,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"filtered\": \"100.00\",\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"using_index\": true,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"cost_info\": {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"read_cost\": \"0.25\",\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"eval_cost\": \"0.10\",\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"prefix_cost\": \"0.35\",\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"data_read_per_join\": \"27K\"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"used_columns\": [\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"id\"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ]\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; ]\n&nbsp; &nbsp; }\n&nbsp; }\n}\n</code></pre><h2>EXPLAIN输出详解</h2><p>接下来，我将以默认的表格输出形式为准，来进行介绍。在EXPLAIN的输出中，每一行表示一个查询单元。查询单元有几种情况：</p><ul>\n<li>关联查询中，每一个关联的表是一个查询单元；</li>\n<li>每个子查询都会对应一个查询单元；</li>\n<li>组成UNION语句的每个子句都会对应一个查询单元；</li>\n<li>每个派生表对应一个查询单元。</li>\n</ul><p>EXPLAIN的输出中包含以下字段：</p><p><img src=\"https://static001.geekbang.org/resource/image/10/cb/108b835cb05b6873ee6b2ae13abfbdcb.jpg?wh=1920x1274\" alt=\"图片\"></p><h3>ID</h3><p>ID为查询单元的编号。主查询（顶层查询）的ID为1。同一层级内，如果有表连接，则它们的查询单元ID一样。子查询的嵌套层级越深，ID越大。下面的例子中，有2个子查询，子查询2嵌套在子查询1中。</p><pre><code class=\"language-plain\">mysql&gt; explain \nselect  /*+ NO_SEMIJOIN(@subq1 )  */ * \nfrom tab ta, tab tx\nwhere ta.id in ( \n    select /*+ QB_NAME(subq1) NO_SEMIJOIN(@subq2) */ id from tab tb \n\t    where c in (select /*+ QB_NAME(subq2) */ c from tab tc)\n)\nand ta.id = tx.id\n\n+----+-------------+-------+--------+---------------+---------+---------+-----------+------+----------+--------------------------+\n| id | select_type | table | type&nbsp; &nbsp;| possible_keys | key&nbsp; &nbsp; &nbsp;| key_len | ref&nbsp; &nbsp; &nbsp; &nbsp;| rows | filtered | Extra&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\n+----+-------------+-------+--------+---------------+---------+---------+-----------+------+----------+--------------------------+\n|&nbsp; 1 | PRIMARY&nbsp; &nbsp; &nbsp;| ta&nbsp; &nbsp; | ALL&nbsp; &nbsp; | PRIMARY&nbsp; &nbsp; &nbsp; &nbsp;| NULL&nbsp; &nbsp; | NULL&nbsp; &nbsp; | NULL&nbsp; &nbsp; &nbsp; | 9913 |&nbsp; &nbsp;100.00 | Using where&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\n|&nbsp; 1 | PRIMARY&nbsp; &nbsp; &nbsp;| tx&nbsp; &nbsp; | eq_ref | PRIMARY&nbsp; &nbsp; &nbsp; &nbsp;| PRIMARY | 4&nbsp; &nbsp; &nbsp; &nbsp;| rep.ta.id |&nbsp; &nbsp; 1 |&nbsp; &nbsp;100.00 | NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|\n|&nbsp; 2 | SUBQUERY&nbsp; &nbsp; | tb&nbsp; &nbsp; | index&nbsp; | PRIMARY&nbsp; &nbsp; &nbsp; &nbsp;| idx_abc | 12&nbsp; &nbsp; &nbsp; | NULL&nbsp; &nbsp; &nbsp; | 9913 |&nbsp; &nbsp;100.00 | Using where; Using index |\n|&nbsp; 3 | SUBQUERY&nbsp; &nbsp; | tc&nbsp; &nbsp; | index&nbsp; | NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | idx_abc | 12&nbsp; &nbsp; &nbsp; | NULL&nbsp; &nbsp; &nbsp; | 9913 |&nbsp; &nbsp;100.00 | Using index&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\n+----+-------------+-------+--------+---------------+---------+---------+-----------+------+----------+--------------------------+\n</code></pre><p>查询中使用提示QB_NAME、NO_SEMIJOIN，是为了避免优化器使用半连接查询优化，因为使用半连接优化后，这个示例中的子查询就被优化掉了。ID为1的2个查询单元，按从上到下的顺序关联，驱动表为ta。这里Extra中没有额外的信息，说明使用了嵌套循环连接。</p><h3>SELECT_TYPE</h3><p>SELECT_TYPE为查询单元的类型，有以下几种可能的类型。</p><ul>\n<li>SIMPLE</li>\n</ul><p>如果语句没有使用UNION或子查询，那么SELECT_TYPE为SIMPLE。</p><ul>\n<li>PRIMARY</li>\n</ul><p>如果语句用到了子查询，那么最外层查询的select_type为PRIMARY，表示这是主语句。如果语句使用了UNION，则第一个查询单元的select_type为PRIMARY。</p><ul>\n<li>UNION</li>\n</ul><p>使用UNION或UNION ALL的查询中，第二个和后续查询的select_type为UNION</p><ul>\n<li>UNION RESULT</li>\n</ul><p>UNION RESULT表示UNION去重后的结果。下面这个例子中，ID为3的这一行就是ID为1和2这两个查询单元结果集Union之后得到的。</p><pre><code class=\"language-plain\">mysql&gt; explain select a from tab ta union select c from tab tb;\n+----+--------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n| id | select_type&nbsp; | table&nbsp; &nbsp; &nbsp; | type&nbsp; | possible_keys | key&nbsp; &nbsp; &nbsp;| key_len | ref&nbsp; | rows | filtered | Extra&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|\n+----+--------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n|&nbsp; 1 | PRIMARY&nbsp; &nbsp; &nbsp; | ta&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| index | NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | idx_abc | 12&nbsp; &nbsp; &nbsp; | NULL | 9913 |&nbsp; &nbsp;100.00 | Using index&nbsp; &nbsp; &nbsp;|\n|&nbsp; 2 | UNION&nbsp; &nbsp; &nbsp; &nbsp; | tb&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| index | NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | idx_abc | 12&nbsp; &nbsp; &nbsp; | NULL | 9913 |&nbsp; &nbsp;100.00 | Using index&nbsp; &nbsp; &nbsp;|\n|&nbsp; 3 | UNION RESULT | &lt;union1,2&gt; | ALL&nbsp; &nbsp;| NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | NULL&nbsp; &nbsp; | NULL&nbsp; &nbsp; | NULL | NULL |&nbsp; &nbsp; &nbsp;NULL | Using temporary |\n+----+--------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n</code></pre><ul>\n<li>DEPENDENT UNION</li>\n</ul><p>如果UNION子句位于子查询中，并且子查询依赖了外部查询中字段，则select_type为DEPENDENT UNION。</p><pre><code class=\"language-plain\">mysql&gt; explain select * from tab ta where id in (\n    select a from tab tb union select c from tab tc);\n\n\n+----+--------------------+------------+-------+---------------+---------+---------+------+------+----------+--------------------------+\n| id | select_type&nbsp; &nbsp; &nbsp; &nbsp; | table&nbsp; &nbsp; &nbsp; | type&nbsp; | possible_keys | key&nbsp; &nbsp; &nbsp;| key_len | ref&nbsp; | rows | filtered | Extra&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\n+----+--------------------+------------+-------+---------------+---------+---------+------+------+----------+--------------------------+\n|&nbsp; 1 | PRIMARY&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | ta&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| ALL&nbsp; &nbsp;| NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | NULL&nbsp; &nbsp; | NULL&nbsp; &nbsp; | NULL | 9913 |&nbsp; &nbsp;100.00 | Using where&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\n|&nbsp; 2 | DEPENDENT SUBQUERY | tb&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| ref&nbsp; &nbsp;| idx_abc&nbsp; &nbsp; &nbsp; &nbsp;| idx_abc | 4&nbsp; &nbsp; &nbsp; &nbsp;| func | 3304 |&nbsp; &nbsp;100.00 | Using index&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\n|&nbsp; 3 | DEPENDENT UNION&nbsp; &nbsp; | tc&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| index | NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | idx_abc | 12&nbsp; &nbsp; &nbsp; | NULL | 9913 |&nbsp; &nbsp; 10.00 | Using where; Using index |\n|&nbsp; 4 | UNION RESULT&nbsp; &nbsp; &nbsp; &nbsp;| &lt;union2,3&gt; | ALL&nbsp; &nbsp;| NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | NULL&nbsp; &nbsp; | NULL&nbsp; &nbsp; | NULL | NULL |&nbsp; &nbsp; &nbsp;NULL | Using temporary&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\n+----+--------------------+------------+-------+---------------+---------+---------+------+------+----------+--------------------------+\n</code></pre><ul>\n<li>UNCACHEABLE UNION</li>\n</ul><p>union查询出现在子查询中，并且union语句使用了非确定性函数（如rand）或使用了变量，那么union查询单元的select_type为UNCACHEABLE UNION。</p><pre><code class=\"language-plain\">mysql&gt; explain select distinct a from  (\n    select a from tab tb  \n    union all \n    select c from tab tc where c &gt; rand() \n) tx;\n\n\n+----+-------------------+------------+-------+---------------+---------+---------+------+-------+----------+--------------------------+\n| id | select_type&nbsp; &nbsp; &nbsp; &nbsp;| table&nbsp; &nbsp; &nbsp; | type&nbsp; | possible_keys | key&nbsp; &nbsp; &nbsp;| key_len | ref&nbsp; | rows&nbsp; | filtered | Extra&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\n+----+-------------------+------------+-------+---------------+---------+---------+------+-------+----------+--------------------------+\n|&nbsp; 1 | PRIMARY&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &lt;derived2&gt; | ALL&nbsp; &nbsp;| NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | NULL&nbsp; &nbsp; | NULL&nbsp; &nbsp; | NULL | 13217 |&nbsp; &nbsp;100.00 | Using temporary&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\n|&nbsp; 2 | DERIVED&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| tb&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| index | NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | idx_abc | 12&nbsp; &nbsp; &nbsp; | NULL |&nbsp; 9913 |&nbsp; &nbsp;100.00 | Using index&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\n|&nbsp; 3 | UNCACHEABLE UNION | tc&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| index | NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | idx_abc | 12&nbsp; &nbsp; &nbsp; | NULL |&nbsp; 9913 |&nbsp; &nbsp; 33.33 | Using where; Using index |\n+----+-------------------+------------+-------+---------------+---------+---------+------+-------+----------+--------------------------+\n</code></pre><pre><code class=\"language-plain\">mysql&gt; explain select * from tab where exists (\n    select avg(b) from tab  \n    union all \n    select b from tab where b &gt; rand()\n);\n\n\n+----+-------------------+-------+-------+---------------+---------+---------+------+------+----------+--------------------------+\n| id | select_type&nbsp; &nbsp; &nbsp; &nbsp;| table | type&nbsp; | possible_keys | key&nbsp; &nbsp; &nbsp;| key_len | ref&nbsp; | rows | filtered | Extra&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\n+----+-------------------+-------+-------+---------------+---------+---------+------+------+----------+--------------------------+\n|&nbsp; 1 | PRIMARY&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| tab&nbsp; &nbsp;| ALL&nbsp; &nbsp;| NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | NULL&nbsp; &nbsp; | NULL&nbsp; &nbsp; | NULL | 9913 |&nbsp; &nbsp;100.00 | Using where&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\n|&nbsp; 2 | SUBQUERY&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | tab&nbsp; &nbsp;| index | NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | idx_abc | 12&nbsp; &nbsp; &nbsp; | NULL | 9913 |&nbsp; &nbsp;100.00 | Using index&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\n|&nbsp; 3 | UNCACHEABLE UNION | tab&nbsp; &nbsp;| index | NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | idx_abc | 12&nbsp; &nbsp; &nbsp; | NULL | 9913 |&nbsp; &nbsp; 33.33 | Using where; Using index |\n+----+-------------------+-------+-------+---------------+---------+---------+------+------+----------+--------------------------+\n</code></pre><ul>\n<li>SUBQUERY</li>\n</ul><p>子查询可以出现在select列表中、where条件中，也可以出现在from列表中。出现在from列表中的子查询为派生表（DERIVED）。如果子查询不依赖主查询中的字段，则称为不相关子查询，select_type为SUBQUERY。SQL执行时，会缓存子查询的查询结果。下面的例子中，子查询中的SQL只需要执行1次，不需要每访问1行数据就重复执行1次子查询。</p><pre><code class=\"language-plain\">mysql&gt; explain select a, (select avg(b) from tab )  from tab t1;\n\n+----+-------------+-------+-------+---------------+---------+---------+------+-------+----------+-------------+\n| id | select_type | table | type&nbsp; | possible_keys | key&nbsp; &nbsp; &nbsp;| key_len | ref&nbsp; | rows&nbsp; | filtered | Extra&nbsp; &nbsp; &nbsp; &nbsp;|\n+----+-------------+-------+-------+---------------+---------+---------+------+-------+----------+-------------+\n|&nbsp; 1 | PRIMARY&nbsp; &nbsp; &nbsp;| t1&nbsp; &nbsp; | index | NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | idx_abc | 12&nbsp; &nbsp; &nbsp; | NULL | 10010 |&nbsp; &nbsp;100.00 | Using index |\n|&nbsp; 2 | SUBQUERY&nbsp; &nbsp; | tab&nbsp; &nbsp;| index | NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | idx_abc | 12&nbsp; &nbsp; &nbsp; | NULL | 10010 |&nbsp; &nbsp;100.00 | Using index |\n+----+-------------+-------+-------+---------------+---------+---------+------+-------+----------+-------------+\n</code></pre><p>使用EXPLAN ANALYZE命令，可以看到子查询只执行了1次（run only once）。</p><pre><code class=\"language-plain\">mysql&gt; explain analyze select a, (select avg(b) from tab )  from tab t1\\G\n*************************** 1. row ***************************\nEXPLAIN: \n-&gt; Covering index scan on t1 using idx_abc  (cost=1025 rows=10010) (actual time=0.108..2.54 rows=10000 loops=1)\n-&gt; Select #2 (subquery in projection; run only once)\n    -&gt; Aggregate: avg(tab.b)  (cost=2026 rows=1) (actual time=3.79..3.79 rows=1 loops=1)\n        -&gt; Covering index scan on tab using idx_abc  (cost=1025 rows=10010) (actual time=0.0235..2.61 rows=10000 loops=1)\n</code></pre><ul>\n<li>DEPENDENT SUBQUERY</li>\n</ul><p>子查询引用了主查询中的字段，则子查询称为相关子查询。MySQL中，相关子查询无法被缓存。对主查询中的每1行数据，都需要执行1次子查询。</p><pre><code class=\"language-plain\">mysql&gt; explain select a, (select avg(b) from tab where a=t1.a) from tab t1;\n\n+----+--------------------+-------+-------+---------------+---------+---------+----------+------+----------+-------------+\n| id | select_type&nbsp; &nbsp; &nbsp; &nbsp; | table | type&nbsp; | possible_keys | key&nbsp; &nbsp; &nbsp;| key_len | ref&nbsp; &nbsp; &nbsp; | rows | filtered | Extra&nbsp; &nbsp; &nbsp; &nbsp;|\n+----+--------------------+-------+-------+---------------+---------+---------+----------+------+----------+-------------+\n|&nbsp; 1 | PRIMARY&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | t1&nbsp; &nbsp; | index | NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | idx_abc | 12&nbsp; &nbsp; &nbsp; | NULL&nbsp; &nbsp; &nbsp;| 9913 |&nbsp; &nbsp;100.00 | Using index |\n|&nbsp; 2 | DEPENDENT SUBQUERY | tab&nbsp; &nbsp;| ref&nbsp; &nbsp;| idx_abc&nbsp; &nbsp; &nbsp; &nbsp;| idx_abc | 4&nbsp; &nbsp; &nbsp; &nbsp;| rep.t1.a | 3304 |&nbsp; &nbsp;100.00 | Using index |\n+----+--------------------+-------+-------+---------------+---------+---------+----------+------+----------+-------------+\n</code></pre><p>使用EXPLAN ANLYZE命令，可以看到子查询执行了10000次（loops=10000）。</p><pre><code class=\"language-plain\">mysql&gt; explain  analyze select a, (select avg(b) from tab where a=t1.a) from tab t1\\G\n*************************** 1. row ***************************\nEXPLAIN: \n-&gt; Covering index scan on t1 using idx_abc  (cost=1025 rows=10010) (actual time=0.0478..3.09 rows=10000 loops=1)\n-&gt; Select #2 (subquery in projection; dependent)\n    -&gt; Aggregate: avg(tab.b)  (cost=669 rows=1) (actual time=1.39..1.39 rows=1 loops=10000)\n        -&gt; Covering index lookup on tab using idx_abc (a=t1.a)  (cost=336 rows=3337) (actual time=0.023..1.03 rows=3333 loops=10000)\n\n1 row in set, 1 warning (13.94 sec)\n</code></pre><p>MariaDB中，相关子查询也可以cache，对于本例中的SQL，子查询依赖主查询中t1表的字段a，每次t1.a出现新值时，执行1次子查询，并缓存t1.a的值和查询结果。子查询执行的次数取决于关联的外部查询中字段的唯一值数量。</p><p>下面这个例子是在MariaDB 10.0的环境中执行得到的。explain extended的warning信息中，<code>&lt;expr_cache&gt;</code> 表示使用了子查询cache。</p><pre><code class=\"language-plain\">--这个例子在mariadb 10.0 中执行\nmysql&gt; explain extended select a, (select avg(b) from tab where a=t1.a) from tab t1;\n+------+--------------------+-------+-------+---------------+---------+---------+------------+------+----------+-------------+\n| id   | select_type        | table | type  | possible_keys | key     | key_len | ref        | rows | filtered | Extra       |\n+------+--------------------+-------+-------+---------------+---------+---------+------------+------+----------+-------------+\n|    1 | PRIMARY            | t1    | index | NULL          | idx_abc | 12      | NULL       | 9919 |   100.00 | Using index |\n|    2 | DEPENDENT SUBQUERY | tab   | ref   | idx_abc       | idx_abc | 4       | mysql.t1.a | 1668 |   100.00 | Using index |\n+------+--------------------+-------+-------+---------------+---------+---------+------------+------+----------+-------------+\n2 rows in set, 2 warnings (0.00 sec)\n\nmysql&gt; show warnings;\n+-------+------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Level | Code | Message                                                                                                                                                                                                                                                       |\n+-------+------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Note  | 1276 | Field or reference 'mysql.t1.a' of SELECT #2 was resolved in SELECT #1                                                                                                                                                                                        |\n| Note  | 1003 | /* select#1 */ select `mysql`.`t1`.`a` AS `a`,&lt;expr_cache&gt;&lt;`mysql`.`t1`.`a`&gt;((/* select#2 */ select avg(`mysql`.`tab`.`b`) from `mysql`.`tab` where `mysql`.`tab`.`a` = `mysql`.`t1`.`a`)) AS `(select avg(b) from tab where a=t1.a)` from `mysql`.`tab` `t1` |\n+-------+------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n</code></pre><ul>\n<li>DERIVED</li>\n</ul><p>子查询出现在主查询的FROM子句的位置时，select_type为DERIVED。</p><pre><code class=\"language-plain\">mysql&gt; explain select t1.* \n    from tab t1, (select a, avg(b) as avgb from tab group by a) t2  \n    where t1.a = t2.a;\n    \n+----+-------------+------------+-------+---------------+-------------+---------+----------+------+----------+-------------+\n| id | select_type | table&nbsp; &nbsp; &nbsp; | type&nbsp; | possible_keys | key&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| key_len | ref&nbsp; &nbsp; &nbsp; | rows | filtered | Extra&nbsp; &nbsp; &nbsp; &nbsp;|\n+----+-------------+------------+-------+---------------+-------------+---------+----------+------+----------+-------------+\n|&nbsp; 1 | PRIMARY&nbsp; &nbsp; &nbsp;| t1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| ALL&nbsp; &nbsp;| idx_abc&nbsp; &nbsp; &nbsp; &nbsp;| NULL&nbsp; &nbsp; &nbsp; &nbsp; | NULL&nbsp; &nbsp; | NULL&nbsp; &nbsp; &nbsp;| 9913 |&nbsp; &nbsp;100.00 | NULL&nbsp; &nbsp; &nbsp; &nbsp; |\n|&nbsp; 1 | PRIMARY&nbsp; &nbsp; &nbsp;| &lt;derived2&gt; | ref&nbsp; &nbsp;| &lt;auto_key0&gt;&nbsp; &nbsp;| &lt;auto_key0&gt; | 4&nbsp; &nbsp; &nbsp; &nbsp;| rep.t1.a |&nbsp; &nbsp;10 |&nbsp; &nbsp;100.00 | NULL&nbsp; &nbsp; &nbsp; &nbsp; |\n|&nbsp; 2 | DERIVED&nbsp; &nbsp; &nbsp;| tab&nbsp; &nbsp; &nbsp; &nbsp; | index | idx_abc&nbsp; &nbsp; &nbsp; &nbsp;| idx_abc&nbsp; &nbsp; &nbsp;| 12&nbsp; &nbsp; &nbsp; | NULL&nbsp; &nbsp; &nbsp;| 9913 |&nbsp; &nbsp;100.00 | Using index |\n+----+-------------+------------+-------+---------------+-------------+---------+----------+------+----------+-------------+\n</code></pre><ul>\n<li>DEPENDENT DERIVED</li>\n</ul><p>如果派生查询引用了主查询中的字段，则select_type为DEPENDENT DERIVED。</p><pre><code class=\"language-plain\">mysql&gt; explain select a, (select * from (select avg(b) as avgb from tab where a=t0.a) td) from tab t0;\n\n+----+--------------------+------------+-------+---------------+---------+---------+----------+------+----------+-------------+\n| id | select_type&nbsp; &nbsp; &nbsp; &nbsp; | table&nbsp; &nbsp; &nbsp; | type&nbsp; | possible_keys | key&nbsp; &nbsp; &nbsp;| key_len | ref&nbsp; &nbsp; &nbsp; | rows | filtered | Extra&nbsp; &nbsp; &nbsp; &nbsp;|\n+----+--------------------+------------+-------+---------------+---------+---------+----------+------+----------+-------------+\n|&nbsp; 1 | PRIMARY&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | t0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| index | NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | idx_abc | 12&nbsp; &nbsp; &nbsp; | NULL&nbsp; &nbsp; &nbsp;| 9913 |&nbsp; &nbsp;100.00 | Using index |\n|&nbsp; 2 | DEPENDENT SUBQUERY | &lt;derived3&gt; | ALL&nbsp; &nbsp;| NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | NULL&nbsp; &nbsp; | NULL&nbsp; &nbsp; | NULL&nbsp; &nbsp; &nbsp;|&nbsp; &nbsp; 2 |&nbsp; &nbsp;100.00 | NULL&nbsp; &nbsp; &nbsp; &nbsp; |\n|&nbsp; 3 | DEPENDENT DERIVED&nbsp; | tab&nbsp; &nbsp; &nbsp; &nbsp; | ref&nbsp; &nbsp;| idx_abc&nbsp; &nbsp; &nbsp; &nbsp;| idx_abc | 4&nbsp; &nbsp; &nbsp; &nbsp;| rep.t0.a | 3304 |&nbsp; &nbsp;100.00 | Using index |\n+----+--------------------+------------+-------+---------------+---------+---------+----------+------+----------+-------------+\n\n</code></pre><ul>\n<li>MATERIALIZED</li>\n</ul><p>子查询的结果先存储到临时表，查询的其他部分和生成的临时表再关联。</p><pre><code class=\"language-plain\">mysql&gt; explain select * from tab where a in( select b from tab);\n\n+----+--------------+-------------+--------+---------------------+---------------------+---------+-----------+------+----------+-------------+\n| id | select_type&nbsp; | table&nbsp; &nbsp; &nbsp; &nbsp;| type&nbsp; &nbsp;| possible_keys&nbsp; &nbsp; &nbsp; &nbsp;| key&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| key_len | ref&nbsp; &nbsp; &nbsp; &nbsp;| rows | filtered | Extra&nbsp; &nbsp; &nbsp; &nbsp;|\n+----+--------------+-------------+--------+---------------------+---------------------+---------+-----------+------+----------+-------------+\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; &nbsp;| tab&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| ALL&nbsp; &nbsp; | idx_abc&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | NULL&nbsp; &nbsp; | NULL&nbsp; &nbsp; &nbsp; | 9913 |&nbsp; &nbsp;100.00 | NULL&nbsp; &nbsp; &nbsp; &nbsp; |\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; &nbsp;| &lt;subquery2&gt; | eq_ref | &lt;auto_distinct_key&gt; | &lt;auto_distinct_key&gt; | 4&nbsp; &nbsp; &nbsp; &nbsp;| rep.tab.a |&nbsp; &nbsp; 1 |&nbsp; &nbsp;100.00 | NULL&nbsp; &nbsp; &nbsp; &nbsp; |\n|&nbsp; 2 | MATERIALIZED | tab&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| index&nbsp; | NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | idx_abc&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 12&nbsp; &nbsp; &nbsp; | NULL&nbsp; &nbsp; &nbsp; | 9913 |&nbsp; &nbsp;100.00 | Using index |\n+----+--------------+-------------+--------+---------------------+---------------------+---------+-----------+------+----------+-------------+\n</code></pre><ul>\n<li>UNCACHEABLE SUBQUERY</li>\n</ul><p>如果（不相关）子查询结果无法被缓存，则select_type为UNCACHEABLE SUBQUERY。</p><pre><code class=\"language-plain\">mysql&gt; explain select * from tab where b &gt; (select avg(b) from tab where b &gt; rand());\n\n+----+----------------------+-------+-------+---------------+---------+---------+------+------+----------+--------------------------+\n| id | select_type&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | table | type&nbsp; | possible_keys | key&nbsp; &nbsp; &nbsp;| key_len | ref&nbsp; | rows | filtered | Extra&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\n+----+----------------------+-------+-------+---------------+---------+---------+------+------+----------+--------------------------+\n|&nbsp; 1 | PRIMARY&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | tab&nbsp; &nbsp;| ALL&nbsp; &nbsp;| NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | NULL&nbsp; &nbsp; | NULL&nbsp; &nbsp; | NULL | 9913 |&nbsp; &nbsp;100.00 | Using where&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\n|&nbsp; 2 | UNCACHEABLE SUBQUERY | tab&nbsp; &nbsp;| index | NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | idx_abc | 12&nbsp; &nbsp; &nbsp; | NULL | 9913 |&nbsp; &nbsp; 33.33 | Using where; Using index |\n+----+----------------------+-------+-------+---------------+---------+---------+------+------+----------+--------------------------+\n</code></pre><p>导致子查询无法Cache的一些情况：子查询使用了结果不确定的函数（如rand），子查询使用了变量。</p><ul>\n<li>UNCACHEABLE UNION</li>\n</ul><pre><code class=\"language-plain\">mysql&gt; explain select distinct a from  (select a from tab tb  union all select c from tab tc where c &gt; rand() ) tx;\n\n+----+-------------------+------------+-------+---------------+---------+---------+------+-------+----------+--------------------------+\n| id | select_type&nbsp; &nbsp; &nbsp; &nbsp;| table&nbsp; &nbsp; &nbsp; | type&nbsp; | possible_keys | key&nbsp; &nbsp; &nbsp;| key_len | ref&nbsp; | rows&nbsp; | filtered | Extra&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\n+----+-------------------+------------+-------+---------------+---------+---------+------+-------+----------+--------------------------+\n|&nbsp; 1 | PRIMARY&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &lt;derived2&gt; | ALL&nbsp; &nbsp;| NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | NULL&nbsp; &nbsp; | NULL&nbsp; &nbsp; | NULL | 13346 |&nbsp; &nbsp;100.00 | Using temporary&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\n|&nbsp; 2 | DERIVED&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| tb&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| index | NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | idx_abc | 12&nbsp; &nbsp; &nbsp; | NULL | 10010 |&nbsp; &nbsp;100.00 | Using index&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\n|&nbsp; 3 | UNCACHEABLE UNION | tc&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| index | NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | idx_c&nbsp; &nbsp;| 4&nbsp; &nbsp; &nbsp; &nbsp;| NULL | 10010 |&nbsp; &nbsp; 33.33 | Using where; Using index |\n+----+-------------------+------------+-------+---------------+---------+---------+------+-------+----------+--------------------------+\n</code></pre><h3>TABLE</h3><p>TABLE这一列说明了一个查询单元的数据是从哪个表获取的。这里分几种情况。</p><ol>\n<li>table是一个真实存在的物理表，这里会显示为表的别名。</li>\n<li><code>&lt;derivedN&gt;</code>，说明是从派生表获取的数据，真实的数据来自ID为N的查询单元</li>\n<li><code>&lt;unionM,N&gt;</code>，说明是将ID为M和N的查询单元Union后得到的数据。</li>\n<li><code>&lt;subqueryN&gt;</code>，说明是ID为N的子查询物化后得到的数据。</li>\n</ol><p>这里的几种情况，在前面的例子中都出现过，你可以回头再看一下。</p><h3>TYPE</h3><p>TYPE列显示查询单元的访问路径，你可以根据TYPE列来判断查询单元是否使用了索引。</p><ul>\n<li>system</li>\n</ul><p>如果使用了MyISAM存储引擎，并且表中只有1行，则Type为system。</p><pre><code class=\"language-plain\">mysql&gt; create table t1_myisam(a int) engine=myisam;\nmysql&gt; insert into t1_myisam values(100);\n\nmysql&gt; explain select * from t1_myisam;\n+----+-------------+-----------+--------+---------------+------+---------+------+------+----------+-------+\n| id | select_type | table&nbsp; &nbsp; &nbsp;| type&nbsp; &nbsp;| possible_keys | key&nbsp; | key_len | ref&nbsp; | rows | filtered | Extra |\n+----+-------------+-----------+--------+---------------+------+---------+------+------+----------+-------+\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; | t1_myisam | system | NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | NULL | NULL&nbsp; &nbsp; | NULL |&nbsp; &nbsp; 1 |&nbsp; &nbsp;100.00 | NULL&nbsp; |\n+----+-------------+-----------+--------+---------------+------+---------+------+------+----------+-------+\n</code></pre><ul>\n<li>const</li>\n</ul><p>const表示查询最多返回1行记录。对主键或唯一索引的所有字段都使用常量等值匹配时，type为const。优化器会将type为const的查询单元直接替换为常量表。</p><pre><code class=\"language-plain\">mysql&gt; explain select * from tab where id = 10\\G\n+----+-------------+-------+-------+---------------+---------+---------+-------+------+----------+-------+\n| id | select_type | table | type&nbsp; | possible_keys | key&nbsp; &nbsp; &nbsp;| key_len | ref&nbsp; &nbsp;| rows | filtered | Extra |\n+----+-------------+-------+-------+---------------+---------+---------+-------+------+----------+-------+\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; | tab&nbsp; &nbsp;| const | PRIMARY&nbsp; &nbsp; &nbsp; &nbsp;| PRIMARY | 4&nbsp; &nbsp; &nbsp; &nbsp;| const |&nbsp; &nbsp; 1 |&nbsp; &nbsp;100.00 | NULL&nbsp; |\n+----+-------------+-------+-------+---------------+---------+---------+-------+------+----------+-------+\n</code></pre><ul>\n<li>eq_ref</li>\n</ul><p>使用主键或唯一索引等值匹配时，type为eq_ref。对于组合主键、组合唯一索引，索引中的每一个字段都需要以等值匹配时，type才为eq_ref。eq_ref访问路径每次最多只返回1行记录。eq_ref和const的区别在于，const使用常量匹配，而eq_ref中，匹配索引字段的值来自驱动表，不是固定的常量。</p><p>下面这个例子中，t2表id字段的匹配条件来自驱动表t1的字段a。</p><pre><code class=\"language-plain\">mysql&gt; explain select * from tab t1 , tab t2 where t1.a = t2.id;\n\n+----+-------------+-------+--------+---------------+---------+---------+----------+------+----------+-------+\n| id | select_type | table | type&nbsp; &nbsp;| possible_keys | key&nbsp; &nbsp; &nbsp;| key_len | ref&nbsp; &nbsp; &nbsp; | rows | filtered | Extra |\n+----+-------------+-------+--------+---------------+---------+---------+----------+------+----------+-------+\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; | t1&nbsp; &nbsp; | ALL&nbsp; &nbsp; | idx_abc&nbsp; &nbsp; &nbsp; &nbsp;| NULL&nbsp; &nbsp; | NULL&nbsp; &nbsp; | NULL&nbsp; &nbsp; &nbsp;| 9913 |&nbsp; &nbsp;100.00 | NULL&nbsp; |\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; | t2&nbsp; &nbsp; | eq_ref | PRIMARY&nbsp; &nbsp; &nbsp; &nbsp;| PRIMARY | 4&nbsp; &nbsp; &nbsp; &nbsp;| rep.t1.a |&nbsp; &nbsp; 1 |&nbsp; &nbsp;100.00 | NULL&nbsp; |\n+----+-------------+-------+--------+---------------+---------+---------+----------+------+----------+-------+\n</code></pre><ul>\n<li>ref</li>\n</ul><p>普通索引字段的等值匹配，或主键和唯一索引前缀字段上的等值匹配，类型为ref。对于ref类型的访问路径，执行计划输出中的key列显示了实际使用的索引，key_len显示使用的索引字段的长度，ref字段显示用于匹配的值。</p><pre><code class=\"language-plain\">mysql&gt; explain select * from tab where a=1;\n\n+----+-------------+-------+------+---------------+---------+---------+-------+------+----------+-------+\n| id | select_type | table | type | possible_keys | key&nbsp; &nbsp; &nbsp;| key_len | ref&nbsp; &nbsp;| rows | filtered | Extra |\n+----+-------------+-------+------+---------------+---------+---------+-------+------+----------+-------+\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; | tab&nbsp; &nbsp;| ref&nbsp; | idx_abc&nbsp; &nbsp; &nbsp; &nbsp;| idx_abc | 4&nbsp; &nbsp; &nbsp; &nbsp;| const | 3333 |&nbsp; &nbsp;100.00 | NULL&nbsp; |\n+----+-------------+-------+------+---------------+---------+---------+-------+------+----------+-------+\n\n\nmysql&gt; explain select * from tab t1, tab t2 where t1.a = t2.a;\n\n+----+-------------+-------+------+---------------+---------+---------+----------+------+----------+-------+\n| id | select_type | table | type | possible_keys | key&nbsp; &nbsp; &nbsp;| key_len | ref&nbsp; &nbsp; &nbsp; | rows | filtered | Extra |\n+----+-------------+-------+------+---------------+---------+---------+----------+------+----------+-------+\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; | t1&nbsp; &nbsp; | ALL&nbsp; | idx_abc&nbsp; &nbsp; &nbsp; &nbsp;| NULL&nbsp; &nbsp; | NULL&nbsp; &nbsp; | NULL&nbsp; &nbsp; &nbsp;| 9913 |&nbsp; &nbsp;100.00 | NULL&nbsp; |\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; | t2&nbsp; &nbsp; | ref&nbsp; | idx_abc&nbsp; &nbsp; &nbsp; &nbsp;| idx_abc | 4&nbsp; &nbsp; &nbsp; &nbsp;| rep.t1.a | 3304 |&nbsp; &nbsp;100.00 | NULL&nbsp; |\n+----+-------------+-------+------+---------------+---------+---------+----------+------+----------+-------+\n</code></pre><p>如果索引字段的条件使用了or或in，那么type就不再是ref了。</p><ul>\n<li>ref_or_null</li>\n</ul><p>ref_or_null和ref类似，只是额外加了字段为空的条件。对比下下面这两个语句，字段A有not null约束时，type为ref。</p><pre><code class=\"language-plain\">mysql&gt; create table tab3 like tab;\nmysql&gt; alter table tab3 modify a int;\nmysql&gt; insert into tab3 select * from tab;\n\nmysql&gt; explain select * from tab where a is null or a = 1;\n+----+-------------+-------+------+---------------+---------+---------+-------+------+----------+-------+\n| id | select_type | table | type | possible_keys | key&nbsp; &nbsp; &nbsp;| key_len | ref&nbsp; &nbsp;| rows | filtered | Extra |\n+----+-------------+-------+------+---------------+---------+---------+-------+------+----------+-------+\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; | tab&nbsp; &nbsp;| ref&nbsp; | idx_abc&nbsp; &nbsp; &nbsp; &nbsp;| idx_abc | 4&nbsp; &nbsp; &nbsp; &nbsp;| const | 3333 |&nbsp; &nbsp;100.00 | NULL&nbsp; |\n+----+-------------+-------+------+---------------+---------+---------+-------+------+----------+-------+\n\nmysql&gt; explain select * from tab3 where a is null or a = 1;\n+----+-------------+-------+-------------+---------------+---------+---------+-------+------+----------+-----------------------+\n| id | select_type | table | type&nbsp; &nbsp; &nbsp; &nbsp; | possible_keys | key&nbsp; &nbsp; &nbsp;| key_len | ref&nbsp; &nbsp;| rows | filtered | Extra&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|\n+----+-------------+-------+-------------+---------------+---------+---------+-------+------+----------+-----------------------+\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; | tab3&nbsp; | ref_or_null | idx_abc&nbsp; &nbsp; &nbsp; &nbsp;| idx_abc | 5&nbsp; &nbsp; &nbsp; &nbsp;| const | 3334 |&nbsp; &nbsp;100.00 | Using index condition |\n+----+-------------+-------+-------------+---------------+---------+---------+-------+------+----------+-----------------------+\n</code></pre><ul>\n<li>range</li>\n</ul><p>使用索引字段上的范围条件查询数据。范围条件包括 <code>&lt;, &lt;=, &gt;, &gt;=, BETWEEN</code> 等，索引字段使用OR或IN多个值时，类型也为range。对于range访问路径，执行计划中key列显示实际使用的索引名。key_len列显示使用到的索引字段的长度，ken_len取决于使用到的索引字段的数据类型、字段是否可以为空。rows字段显示优化器评估得到的需要在索引中访问的记录数量。</p><pre><code class=\"language-plain\">mysql&gt; explain select * from tab force index(idx_abc) where   a = 1 or a = 2;\n\n+----+-------------+-------+-------+---------------+---------+---------+------+------+----------+-----------------------+\n| id | select_type | table | type&nbsp; | possible_keys | key&nbsp; &nbsp; &nbsp;| key_len | ref&nbsp; | rows | filtered | Extra&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|\n+----+-------------+-------+-------+---------------+---------+---------+------+------+----------+-----------------------+\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; | tab&nbsp; &nbsp;| range | idx_abc&nbsp; &nbsp; &nbsp; &nbsp;| idx_abc | 4&nbsp; &nbsp; &nbsp; &nbsp;| NULL | 6666 |&nbsp; &nbsp;100.00 | Using index condition |\n+----+-------------+-------+-------+---------------+---------+---------+------+------+----------+-----------------------+\n\n\nmysql&gt; explain select * from tab where a = 1 and b between 100 and 200;\n+----+-------------+-------+-------+---------------+---------+---------+------+------+----------+-----------------------+\n| id | select_type | table | type&nbsp; | possible_keys | key&nbsp; &nbsp; &nbsp;| key_len | ref&nbsp; | rows | filtered | Extra&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|\n+----+-------------+-------+-------+---------------+---------+---------+------+------+----------+-----------------------+\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; | tab&nbsp; &nbsp;| range | idx_abc&nbsp; &nbsp; &nbsp; &nbsp;| idx_abc | 8&nbsp; &nbsp; &nbsp; &nbsp;| NULL |&nbsp; &nbsp;34 |&nbsp; &nbsp;100.00 | Using index condition |\n+----+-------------+-------+-------+---------------+---------+---------+------+------+----------+-----------------------+\n</code></pre><ul>\n<li>index_merge</li>\n</ul><p>index_merge会使用多个索引来查询数据，并将通过多个索引获取到的数据取并集或交集，得到最终的结果。执行计划输出中，key字段显示实际参与index_merge的索引。Extra列中的信息显示了实际的索引合并方法，包括sort_union, union和intersect。</p><p>如果在执行计划中看到index_merge访问路径，一般要考虑是否可以创建联合索引，将访问路径改成range或ref，或者将SQL改写为union查询。</p><pre><code class=\"language-plain\">mysql&gt; explain select * \n  from t_merge \n  where (b=1 and d=1) or (c=1 and d between 3 and 5);\n+----+-------------+---------+-------------+---------------+---------------+---------+------+------+----------+----------------------------------------------+\n| id | select_type | table&nbsp; &nbsp;| type&nbsp; &nbsp; &nbsp; &nbsp; | possible_keys | key&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| key_len | ref&nbsp; | rows | filtered | Extra&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\n+----+-------------+---------+-------------+---------------+---------------+---------+------+------+----------+----------------------------------------------+\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; | t_merge | index_merge | idx_bd,idx_cd | idx_bd,idx_cd | 8,8&nbsp; &nbsp; &nbsp;| NULL |&nbsp; 210 |&nbsp; &nbsp;100.00 | Using sort_union(idx_bd,idx_cd); Using where |\n+----+-------------+---------+-------------+---------------+---------------+---------+------+------+----------+----------------------------------------------+\n\nmysql&gt; explain select * from t_merge where a=1 and b=1 and d=1 and c=1;\n+----+-------------+---------+-------------+----------------------+----------------------+---------+------+------+----------+----------------------------------------------------+\n| id | select_type | table&nbsp; &nbsp;| type&nbsp; &nbsp; &nbsp; &nbsp; | possible_keys&nbsp; &nbsp; &nbsp; &nbsp; | key&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | key_len | ref&nbsp; | rows | filtered | Extra&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\n+----+-------------+---------+-------------+----------------------+----------------------+---------+------+------+----------+----------------------------------------------------+\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; | t_merge | index_merge | idx_ad,idx_bd,idx_cd | idx_cd,idx_bd,idx_ad | 8,8,8&nbsp; &nbsp;| NULL |&nbsp; &nbsp; 1 |&nbsp; &nbsp;100.00 | Using intersect(idx_cd,idx_bd,idx_ad); Using where |\n+----+-------------+---------+-------------+----------------------+----------------------+---------+------+------+----------+----------------------------------------------------+\n</code></pre><ul>\n<li>index_subquery</li>\n</ul><p>index_subquery是执行下面这种类型的子查询的一种方式：</p><pre><code class=\"language-plain\">where value in (select col from tab where ...)\n</code></pre><p>如果子查询中的表tab有合适的索引可以用来检索，则可以使用index_subquery执行路径，对主查询中的每1行记录，执行类似下面的SQL：</p><pre><code class=\"language-plain\">select * from tab where col = outer.value and ...\n</code></pre><pre><code class=\"language-plain\">mysql&gt; explain select /*+ NO_SEMIJOIN(@qb1) */ * from tab \n  where a = 1 \n  and  b between 100 and 200  \n  and c in (select /*+ QB_NAME(qb1) */  a from tab where b=1  );\n\n+----+--------------------+-------+----------------+---------------+---------+---------+------------+------+----------+------------------------------------+\n| id | select_type&nbsp; &nbsp; &nbsp; &nbsp; | table | type&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| possible_keys | key&nbsp; &nbsp; &nbsp;| key_len | ref&nbsp; &nbsp; &nbsp; &nbsp; | rows | filtered | Extra&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\n+----+--------------------+-------+----------------+---------------+---------+---------+------------+------+----------+------------------------------------+\n|&nbsp; 1 | PRIMARY&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | tab&nbsp; &nbsp;| range&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | idx_abc&nbsp; &nbsp; &nbsp; &nbsp;| idx_abc | 8&nbsp; &nbsp; &nbsp; &nbsp;| NULL&nbsp; &nbsp; &nbsp; &nbsp;|&nbsp; &nbsp;34 |&nbsp; &nbsp;100.00 | Using index condition; Using where |\n|&nbsp; 2 | DEPENDENT SUBQUERY | tab&nbsp; &nbsp;| index_subquery | idx_abc&nbsp; &nbsp; &nbsp; &nbsp;| idx_abc | 8&nbsp; &nbsp; &nbsp; &nbsp;| func,const |&nbsp; &nbsp; 1 |&nbsp; &nbsp;100.00 | Using index&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\n+----+--------------------+-------+----------------+---------------+---------+---------+------------+------+----------+------------------------------------+\n\nmysql&gt; show warnings\\G\n*************************** 1. row ***************************\n  Level: Note\n   Code: 1003\nMessage: /* select#1 */ select /*+ NO_SEMIJOIN(@`qb1`) */ \n    `rep`.`tab`.`id` AS `id`,`rep`.`tab`.`a` AS `a`,`rep`.`tab`.`b` AS `b`,`rep`.`tab`.`c` AS `c`,`rep`.`tab`.`padding` AS `padding` \nfrom `rep`.`tab` \nwhere ((`rep`.`tab`.`a` = 1) \nand (`rep`.`tab`.`b` between 100 and 200) \nand &lt;in_optimizer&gt;(`rep`.`tab`.`c`,&lt;exists&gt;(&lt;index_lookup&gt;(&lt;cache&gt;(`rep`.`tab`.`c`) in tab on idx_abc))))\n1 row in set (0.00 sec)\n</code></pre><ul>\n<li>unique_subquery</li>\n</ul><p>unique_subquery和index_subquery类似，区别在于type为unique_subquery时，子查询中的表使用主键或唯一索引来关联查询。</p><pre><code class=\"language-plain\">mysql&gt; explain select /*+ NO_SEMIJOIN(@qb1) */ * \n  from tab \n  where a=1 \n  and id in (select /*+ QB_NAME(qb1) */  id from tab);\n\n+----+--------------------+-------+-----------------+---------------+---------+---------+-------+------+----------+-------------+\n| id | select_type&nbsp; &nbsp; &nbsp; &nbsp; | table | type&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | possible_keys | key&nbsp; &nbsp; &nbsp;| key_len | ref&nbsp; &nbsp;| rows | filtered | Extra&nbsp; &nbsp; &nbsp; &nbsp;|\n+----+--------------------+-------+-----------------+---------------+---------+---------+-------+------+----------+-------------+\n|&nbsp; 1 | PRIMARY&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | tab&nbsp; &nbsp;| ref&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| idx_abc&nbsp; &nbsp; &nbsp; &nbsp;| idx_abc | 4&nbsp; &nbsp; &nbsp; &nbsp;| const | 3333 |&nbsp; &nbsp;100.00 | Using where |\n|&nbsp; 2 | DEPENDENT SUBQUERY | tab&nbsp; &nbsp;| unique_subquery | PRIMARY&nbsp; &nbsp; &nbsp; &nbsp;| PRIMARY | 4&nbsp; &nbsp; &nbsp; &nbsp;| func&nbsp; |&nbsp; &nbsp; 1 |&nbsp; &nbsp;100.00 | Using index |\n+----+--------------------+-------+-----------------+---------------+---------+---------+-------+------+----------+-------------+\n\n\nmysql&gt; show warnings\\G\n*************************** 1. row ***************************\n  Level: Note\n   Code: 1003\nMessage: /* select#1 */ select /*+ NO_SEMIJOIN(@`qb1`) */ \n    `rep`.`tab`.`id` AS `id`,`rep`.`tab`.`a` AS `a`,`rep`.`tab`.`b` AS `b`,`rep`.`tab`.`c` AS `c`,`rep`.`tab`.`padding` AS `padding` \n  from `rep`.`tab` \n  where ((`rep`.`tab`.`a` = 1) \n  and &lt;in_optimizer&gt;(`rep`.`tab`.`id`,&lt;exists&gt;(&lt;primary_index_lookup&gt;(&lt;cache&gt;(`rep`.`tab`.`id`) in tab on PRIMARY))))\n\n</code></pre><p>上面例子中NO_SEMIJOIN提示是为了阻止优化器使用半连接优化，因为使用半连接优化后，子查询被转换为半连接，就不会出现index_subquery和unique_subquery访问路径了。</p><ul>\n<li>index</li>\n</ul><p>index访问路径和ALL类似，主要区别是ALL访问路径需要访问表的每一行数据，而index访问路径是访问索引中的每一行数据。访问路径为index时，key_len字段显示的是所有索引字段的长度总和。一般type为index时，possible_keys总是NULL。</p><p>以下2种情况可以使用index访问路径：</p><p>情况1：语句使用了覆盖索引，但是又缺少索引字段的查询条件。这种情况下Extra列会显示Using index。</p><p>情况2：按索引的顺序读取表的记录，但是无法使用覆盖索引。这种情况下Extra列不显示Using index。</p><p>下面的2个例子分别展示了这两种情况。</p><pre><code class=\"language-plain\">mysql&gt; explain select a,b,c from tab force index(idx_abc) order by a,b,c;\n\n+----+-------------+-------+-------+---------------+---------+---------+------+------+----------+-------------+\n| id | select_type | table | type&nbsp; | possible_keys | key&nbsp; &nbsp; &nbsp;| key_len | ref&nbsp; | rows | filtered | Extra&nbsp; &nbsp; &nbsp; &nbsp;|\n+----+-------------+-------+-------+---------------+---------+---------+------+------+----------+-------------+\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; | tab&nbsp; &nbsp;| index | NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | idx_abc | 12&nbsp; &nbsp; &nbsp; | NULL | 9913 |&nbsp; &nbsp;100.00 | Using index |\n+----+-------------+-------+-------+---------------+---------+---------+------+------+----------+-------------+\n\nmysql&gt; explain select * from tab force index(idx_abc) order by a,b,c;\n\n+----+-------------+-------+-------+---------------+---------+---------+------+------+----------+-------+\n| id | select_type | table | type&nbsp; | possible_keys | key&nbsp; &nbsp; &nbsp;| key_len | ref&nbsp; | rows | filtered | Extra |\n+----+-------------+-------+-------+---------------+---------+---------+------+------+----------+-------+\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; | tab&nbsp; &nbsp;| index | NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | idx_abc | 12&nbsp; &nbsp; &nbsp; | NULL | 9913 |&nbsp; &nbsp;100.00 | NULL&nbsp; |\n+----+-------------+-------+-------+---------------+---------+---------+------+------+----------+-------+\n</code></pre><ul>\n<li>ALL</li>\n</ul><p>全表扫描，需要访问表中的每一行记录。出现ALL访问路径，可能是因为表上缺少合适的索引，或者是因为SQL语句的写法问题导致无法使用索引，也可能是因为查询中对表缺少合适的过滤条件，或者是索引字段的过滤性不好，需要根据查询语句的情况具体分析。</p><p>\\因字数限制，学习后面的内容请直接跳转到下一讲</p>","neighbors":{"left":{"article_title":"17｜SQL优化第一步：理解访问路径","id":809565},"right":{"article_title":"18｜读懂MySQL中的执行计划（下）","id":810868}},"comments":[{"had_liked":false,"id":396061,"user_name":"笙 鸢","can_delete":false,"product_type":"c1","uid":3951358,"ip_address":"上海","ucode":"477AF524212C6D","user_header":"https://static001.geekbang.org/account/avatar/00/3c/4a/fe/7b6bd101.jpg","comment_is_top":false,"comment_ctime":1732867646,"is_pvip":false,"replies":[{"id":143801,"content":"抱歉，这个是拼写错误。文档里修改过来了。感谢提醒😊","user_name":"作者回复","user_name_real":"编辑","uid":3898827,"ctime":1733110452,"ip_address":"浙江","comment_id":396061,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100799401,"comment_content":"老师，派生表的讲解处，好多DRIVED的写法，是不是写错了？？","like_count":0,"discussions":[{"author":{"id":3898827,"avatar":"https://static001.geekbang.org/account/avatar/00/3b/7d/cb/fa3dae58.jpg","nickname":"俊达","note":"","ucode":"F79BF9651AD086","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":654609,"discussion_content":"抱歉，这个是拼写错误。文档里修改过来了。感谢提醒😊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1733110452,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":395032,"user_name":"mw","can_delete":false,"product_type":"c1","uid":1672042,"ip_address":"上海","ucode":"0F8DC29949CDAE","user_header":"https://static001.geekbang.org/account/avatar/00/19/83/6a/6f04edbd.jpg","comment_is_top":false,"comment_ctime":1729145835,"is_pvip":false,"replies":[{"id":143451,"content":"问题1. 我的理解是，如果没有索引，是按全表的记录数来。如果用了索引访问（range、ref），按range或ref条件的扫描记录数来。可以开optimizer_trace，设计几个测试案例来验证下。\n\n问题2. 看执行计划。如果用了索引的range或ref，先按索引条件到索引中扫描，再判断下推的索引条件，然后再到server层判断剩余的条件。","user_name":"作者回复","user_name_real":"编辑","uid":3898827,"ctime":1729217561,"ip_address":"浙江","comment_id":395032,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100799401,"comment_content":"老师好，请教个问题：在选择驱动表的时候 需要过滤where 之后的所有条件之后以数据量小的作为驱动表。\n1、那要是where之后的条件没有索引或者无法使用索引的Cardinality进行估算过滤，那选择驱动表的时候就需要扫描全表过滤出符合where条件的数据，然后每个表比较符合的数据量大小，之后选出驱动表吗？ 还是说有其他的计算方法。\n2、如果where后面同时存在一个表的索引字段条件和非索引字段条件，需要索引字段过滤之后 再过滤非索引字段的条件吗？","like_count":0,"discussions":[{"author":{"id":3898827,"avatar":"https://static001.geekbang.org/account/avatar/00/3b/7d/cb/fa3dae58.jpg","nickname":"俊达","note":"","ucode":"F79BF9651AD086","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":652591,"discussion_content":"问题1. 我的理解是，如果没有索引，是按全表的记录数来。如果用了索引访问（range、ref），按range或ref条件的扫描记录数来。可以开optimizer_trace，设计几个测试案例来验证下。\n\n问题2. 看执行计划。如果用了索引的range或ref，先按索引条件到索引中扫描，再判断下推的索引条件，然后再到server层判断剩余的条件。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1729217561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":1,"child_discussions":[{"author":{"id":1672042,"avatar":"https://static001.geekbang.org/account/avatar/00/19/83/6a/6f04edbd.jpg","nickname":"mw","note":"","ucode":"0F8DC29949CDAE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":3898827,"avatar":"https://static001.geekbang.org/account/avatar/00/3b/7d/cb/fa3dae58.jpg","nickname":"俊达","note":"","ucode":"F79BF9651AD086","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":652616,"discussion_content":"好的 谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1729251796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":652591,"ip_address":"上海","group_id":0},"score":652616,"extra":""}]}]}]}