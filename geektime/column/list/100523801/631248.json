{"id":631248,"title":"15｜Formatting实战：如何构建一个数据流处理实例？","content":"<p>你好，我是卢誉声。</p><p>C++20为我们带来了重要的文本格式化标准库支持。通过Formatting库和formatter类型，我们可以实现高度灵活的文本格式化方案。那么，<strong>我们该如何在实际工程项目中使用它呢？</strong></p><p>日志输出在实际工程项目中是一个常见需求，无论是运行过程记录，还是错误记录与异常跟踪，都需要用到日志。</p><p>在这一讲中，我们会基于新标准实现一个日志库。你可以重点关注特化formatter类型的方法，实现高度灵活的标准化定制。</p><p>好，话不多说，我们就从架构设计开始，一步步实现这个日志库（课程配套代码可以从<a href=\"https://github.com/samblg/cpp20-plus-indepth\">这里</a>获取）。</p><h2>日志库架构设计</h2><p>事实上，实现一个足够灵活的日志库并不容易。在实际工程项目中，日志输出不仅需要支持自定义日志的输出格式，还需要支持不同的输出目标。比如，输出到控制台、文件，甚至是网络流或者数据库等。</p><p>Python和Java这类现代语言都有成熟的日志库与标准接口。C++ Formatting的正式提出，让我们能使用简洁的方式实现日志库。</p><p>同时，Python的logging模块设计比较优雅。因此，我们参照它的架构，设计了基于C++20的日志架构。</p><p><img src=\"https://static001.geekbang.org/resource/image/ec/0c/ec3a90b1d84e98d8b5a50ca5e752370c.jpg?wh=2698x749\" alt=\"\"></p><p>项目的模块图是后面这样。</p><p><img src=\"https://static001.geekbang.org/resource/image/03/2d/03d1f3c199a25521cfd8258dd62e7c2d.jpg?wh=1637x1334\" alt=\"\"><br>\n对照图片可以看到，logging模块是工程的核心，包含核心框架、handlers和formatters三个子模块。</p><!-- [[[read_end]]] --><p>其中，核心框架包括Level、Record、Formatter、Handler与Logger的定义。由于我们使用了模版，因此核心框架的声明实现都在头文件中。具体含义你可以参考后面这张表。</p><p><img src=\"https://static001.geekbang.org/resource/image/04/73/046a9b02dc550fd37b13503ef68fca73.jpg?wh=3374x1978\" alt=\"\"></p><p>由于我们关注的重点在于<strong>如何使用Formatting库</strong>和<strong>如何特化formatter类型</strong>。因此，对于核心框架的定义和实现，你可以参考完整的工程代码。</p><h2>日志格式化器模块</h2><p>从模块图中可以看出，我们在formatters模块中实现了三组不同的日志格式化器。我们来比较一下。</p><p>首先是CFormatter，它是C⻛格格式化的日志输出。实现较为简单，但是如果阅读了代码，你就发现这种实现方式难以避免类型和缓冲区安全问题。</p><p>StreamFormatter则是C++流⻛格的日志输出。基于C++流的实现相对于C的实现更加注重类型安全，并能完全避免缓冲区溢出。但是，这么做编码复杂，也会影响整体代码的可读性。</p><p>最后就是ModernFormatter，即C++20 format的日志输出。基于C++ Formatting库和特化formatter实现。</p><p>接下来，我们具体来看ModernFormatter。接口定义在include/logging/formatters/ModernFormatter.h中，代码是后面这样。</p><pre><code class=\"language-c++\">#pragma once\n&nbsp;\n#include &lt;string&gt;\n&nbsp;\nnamespace logging {\n&nbsp;&nbsp;&nbsp; class Record;\n&nbsp;\n&nbsp;&nbsp;&nbsp; namespace formatters::modern {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // formatRecord函数用于格式化日志记录对象\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string formatRecord(const logging::Record&amp; record);\n&nbsp;&nbsp;&nbsp; }\n}\n</code></pre><p>具体实现在src/logging/formatters/ModernFormatter.cpp中。</p><pre><code class=\"language-c++\">#include \"logging/formatters/ModernFormatter.h\"\n#include \"logging/Record.h\"\n&nbsp;\nnamespace logging::formatters::modern {\n&nbsp;&nbsp;&nbsp; // formatRecord：将Record对象格式化为字符串\n&nbsp;&nbsp;&nbsp; std::string formatRecord(const Record&amp; record) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::format(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \"{0:&lt;16}| [{1}] {2:%Y-%m-%d}T{2:%H:%M:%OS}Z - {3}\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record.name,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record.getLevelName(),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record.time,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record.message\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch (std::exception&amp; e) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; \"Error in format: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return \"\";\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp; }\n}\n</code></pre><p>这种方案具有三个优点。</p><p>第一，format内置对C++11的时间点对象的直接格式化。在C++20中，由于chrono提供了针对time_point类型的formatter。因此，相比其他的方案，这种方案对时间的格式化要简单清晰得多。</p><p>第二，format不需要像C方案那样提前分配缓冲区，因此可以避免缓冲区溢出。</p><p>第三，format可以自动根据函数参数类型，确定格式化的参数类型。它不需要完全根据格式化字符串判定参数类型，如果格式化字符串中的类型与实际参数类型不同，也能在运行时检查出来并抛出异常。我们在代码中捕获了相关异常，发生错误时，你可以根据具体需求来处理异常。</p><p>总之，采用C++ Formatting实现的文本格式化器非常简单。不过话说回来，格式化文本这件事本来就该如此轻松惬意，不是吗？</p><h2>日志记录器模块</h2><p>现在，我们来看另一个重点——日志记录器模块。日志记录器是提供给用户的接口，用户可以通过日志记录器提交日志。你可以先看看代码实现，再听我讲解。</p><pre><code class=\"language-c++\">#pragma once\n&nbsp;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;tuple&gt;\n#include &lt;memory&gt;\n#include \"logging/Level.h\"\n#include \"logging/Handler.h\"\n#include \"logging/handlers/DefaultHandler.h\"\n&nbsp;\nnamespace logging {\n&nbsp;&nbsp;&nbsp; // Logger类定义\n&nbsp;&nbsp;&nbsp; // Level是日志记录器的日志等级\n&nbsp;&nbsp;&nbsp; // HandlerTypes是所有注册的日志处理器，必须满足Handler约束\n&nbsp;&nbsp;&nbsp; // 通过requires要求每个Logger类必须注册至少一个日志处理器\n&nbsp;&nbsp;&nbsp; template &lt;Level loggerLevel, Handler... HandlerTypes&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; requires(sizeof...(HandlerTypes) &gt; 0)\n&nbsp;&nbsp;&nbsp; class Logger {\n&nbsp;&nbsp;&nbsp; public:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // HandlerCount：日志记录器数量，通过sizeof...获取模板参数中不定参数的数量\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static constexpr int32_t HandlerCount = sizeof...(HandlerTypes);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // LoggerLevel：Logger的日志等级\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static constexpr Level LoggerLevel = loggerLevel;\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 构造函数：name为日志记录器名称，attachedHandlers是需要注册到Logger对象中的日志处理器\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 由于日志处理器也不允许拷贝，只允许移动，所以这里采用的是元组的移动构造函数\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Logger(const std::string&amp; name, std::tuple&lt;HandlerTypes...&gt;&amp;&amp; attachedHandlers) :\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 调用std::forward转发右值引用\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _name(name), _attachedHandlers(std::forward&lt;std::tuple&lt;HandlerTypes...&gt;&gt;(attachedHandlers)) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 不允许拷贝\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Logger(const Logger&amp;) = delete;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 不允许赋值\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Logger&amp; operator=(const Logger&amp;) = delete;\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 移动构造函数：允许日志记录器对象之间移动\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Logger(Logger&amp;&amp; rhs) :\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _name(std::move(rhs._name)), _attachedHandlers(std::move(rhs._attachedHandlers)) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // log：通用日志输出接口\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 需要通过模板参数指定输出的日志等级\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 通过requires约束丢弃比日志记录器设定等级要低的日志\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 避免运行时通过if判断\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; template &lt;Level level&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; requires (level &gt; loggerLevel)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Logger&amp; log(const std::string&amp; message) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 通过requires约束提交等级为日志记录器设定等级及以上的日志\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; template &lt;Level level&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; requires (level &lt;= loggerLevel)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Logger&amp; log(const std::string&amp; message) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 构造Record对象\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Record record{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .name = _name,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .level = level,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .time = std::chrono::system_clock::now(),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .message = message,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 调用handleLog实际处理日志输出\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handleLog&lt;level, HandlerCount - 1&gt;(record);\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // handleLog：将日志记录提交给所有注册的日志处理器\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // messageLevel为提交的日志等级\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // handlerIndex为日志处理器的注册序号\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 通过requires约束当handlerIndex &gt; 0时会递归调用handleLog将消息同时提交给前一个日志处理器\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; template &lt;Level messageLevel, int32_t handlerIndex&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; requires (handlerIndex &gt; 0)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void handleLog(const Record&amp; record) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 递归调用handleLog将消息同时提交给前一个日志处理器\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handleLog&lt;messageLevel, handlerIndex - 1&gt;(record);\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 获取当前日志处理器并提交消息\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; handler = std::get&lt;handlerIndex&gt;(_attachedHandlers);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handler.emit&lt;messageLevel&gt;(record);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; template &lt;Level messageLevel, int32_t handlerIndex&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; requires (handlerIndex == 0)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void handleLog(const Record&amp; record) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 获取当前日志处理器并提交消息\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; handler = std::get&lt;handlerIndex&gt;(_attachedHandlers);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handler.emit&lt;messageLevel&gt;(record);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 提交严重错误信息（log的包装）\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Logger&amp; critical(const std::string&amp; message) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return log&lt;Level::Critical&gt;(message);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 提交一般错误信息（log的包装）\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Logger&amp; error(const std::string&amp; message) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return log&lt;Level::Error&gt;(message);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 提交警告信息（log的包装）\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Logger&amp; warning(const std::string&amp; message) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return log&lt;Level::Warning&gt;(message);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 提交普通信息（log的包装）\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Logger&amp; info(const std::string&amp; message) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return log&lt;Level::Info&gt;(message);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 提交调试信息（log的包装）\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Logger&amp; debug(const std::string&amp; message) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return log&lt;Level::Debug&gt;(message);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 提交程序跟踪信息（log的包装）\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Logger&amp; trace(const std::string&amp; message) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return log&lt;Level::Trace&gt;(message);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp; private:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 日志记录器名称\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string _name;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 注册的日志处理器，由于日志处理器的类型与数量不定，因此这里使用元组而非数组\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::tuple&lt;HandlerTypes...&gt; _attachedHandlers;\n&nbsp;&nbsp;&nbsp; };\n&nbsp;\n&nbsp;&nbsp;&nbsp; // 日志记录器生成工厂\n&nbsp;&nbsp;&nbsp; template &lt;Level level = Level::Warning&gt;\n&nbsp;&nbsp;&nbsp; class LoggerFactory {\n&nbsp;&nbsp;&nbsp; public:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 创建日志记录器，指定名称与处理器\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; template &lt;Handler... HandlerTypes&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static Logger&lt;level, HandlerTypes...&gt; createLogger(const std::string&amp; name, std::tuple&lt;HandlerTypes...&gt;&amp;&amp; attachedHandlers) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Logger&lt;level, HandlerTypes...&gt;(name, std::forward&lt;std::tuple&lt;HandlerTypes...&gt;&gt;(attachedHandlers));\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 创建日志记录器，指定名称，处理器采用默认处理器（DefaultHandler）\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; template &lt;Handler... HandlerTypes&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static Logger&lt;level, handlers::DefaultHandler&lt;level&gt;&gt; createLogger(const std::string&amp; name) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Logger&lt;level, handlers::DefaultHandler&lt;level&gt;&gt;(name, std::make_tuple(handlers::DefaultHandler&lt;level&gt;()));\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp; };\n}\n</code></pre><p>日志记录器Logger是一个模板类。与其他日志记录器不同，<strong>这里设计的日志框架，是一个“静态”框架</strong>，也就是日志输出的配置都必须在代码中编码，而非读取外部配置或运行时修改。</p><p>这么做的初衷在于，通过C++模板能力直接生成固化的代码，避免运行时进行逻辑判断——这样效率更高。因此，日志记录器的等级Level和需要注册到日志记录器的处理器类型，都需要通过模板参数注册到Logger中。</p><p>先来看一下构造函数。构造函数中包含两个参数。</p><ul>\n<li>name为日志记录器名称。</li>\n<li>attachedHandlers是需要注册到Logger对象中的日志处理器。</li>\n</ul><p>你可能已经注意到了，日志处理器的类型HandlerTypes是一个模板不定参数，唯一要求是每个参数都必须满足Handler约束的类型。这个concept表示合法的日志处理器，具体实现，我们会在接下来的“日志处理器模块”里讨论。</p><p>由于每个日志处理器的类型都不一样。因此，所有的日志处理器都按指定顺序存储在一个tuple中。由于日志处理器也不允许拷贝，只允许移动。所以，这里采用的是元组的移动构造函数，也可以确保较高的运行效率。</p><p>接着，看一下成员函数log，该函数是通用的日志输出接口，可以按照指定日志等级输出任意内容的日志。Logger的使用者需要调用该函数输出日志，该函数包含两个参数。</p><ul>\n<li>level：输出日志等级，通过模板参数传递。</li>\n<li>message：表示日志内容，通过函数参数传递。</li>\n</ul><p>为了在编译时就确定Logger是否应该接收这个日志，避免运行时的额外判断，我们将level特意定义成模板参数，并利用requires为log定义了两个重载版本，你可以参考这张表格。</p><p><img src=\"https://static001.geekbang.org/resource/image/d4/eb/d4d0e0fdca6e5486e4b005fdbd793aeb.jpg?wh=3267x1087\" alt=\"\"></p><p>接着，我们看一下成员函数handleLog的实现，该函数可以将日志提交给Logger中注册的所有日志处理器，包含3个参数。</p><ul>\n<li>messageLevel：消息日志等级，需要通过模板参数传递。</li>\n<li>handlerIndex：处理器在Logger中的注册序号，需要通过模板参数传递。</li>\n<li>record：提交给处理器的日志记录，需要通过函数参数传递。</li>\n</ul><p>由于handler的类型不一定相同。因此，我们无法通过循环将日志记录提交给所有的日志处理器，需要采用递归的方式。</p><p>在具体实现时，messageLevel和handlerIndex均为模板参数，handlerIndex从最后一个日志处理器开始（这解释了在成员函数log中，调用handleLog时传递的是HandlerCount - 1），最终递归调用到handlerIndex为0时终止。</p><p>由于Logger一般不会支持太多的输出目标（一般来说，也就是将日志输出到控制台，或者输出到文件），递归层数不会太深，因此为了在编译时生成确定的调用链条，为C++提供递归函数内联调用优化的可能性，我们将messageLevel和handlerIndex特意定义成模板参数，并利用requires为handleLog定义了两个重载版本，就像后面这样。</p><p><img src=\"https://static001.geekbang.org/resource/image/12/c5/12fc6598ae40170862d98b7f8caa4bc5.jpg?wh=3267x1087\" alt=\"\"></p><p>好，我们接着往下看代码。从94—121行，为不同日志等级定义了包装接口，便于Logger用户直接输出特定等级的日志，减少编码。</p><p>由于Logger必须要指定日志处理器，而且多个日志处理器类型不同，因此创建Logger对象时必须指明所有处理器的类型。</p><p>为此，我们定义了一个工厂类LoggerFactory，将日志等级作为类的模板参数，用户调用createLogger函数创建Logger对象时，编译器可以根据函数参数列表，自动推导HandlerTypes的具体类型，降低编程工作量。</p><h2>日志处理器模块</h2><p>最后，我们看一下日志处理器模块以及常见的日志输出处理实现。</p><h3>接口设计</h3><p>在logging/Handler.h中定义了和日志处理器有关的接口。</p><pre><code class=\"language-c++\">#pragma once\n&nbsp;\n#include \"logging/Formatter.h\"\n#include \"logging/Level.h\"\n#include \"logging/Record.h\"\n#include &lt;string&gt;\n#include &lt;memory&gt;\n#include &lt;type_traits&gt;\n#include &lt;concepts&gt;\n&nbsp;\nnamespace logging {\n&nbsp;&nbsp;&nbsp; // Handler Concept\n&nbsp;&nbsp;&nbsp; // 不强制所有Handler都继承BaseHandler，只需要满足特定的接口，因此定义Concept\n&nbsp;&nbsp;&nbsp; template &lt;class HandlerType&gt;\n&nbsp;&nbsp;&nbsp; concept Handler = requires (HandlerType handler, const Record &amp; record, Level level) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 要求有emit成员函数\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handler.emit;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 要求有format函数，可以将Record对象格式化为string类型的字符串\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { handler.format(record) } -&gt; std::same_as&lt;std::string&gt;;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 要求有移动构造函数，无拷贝构造函数\n&nbsp;&nbsp;&nbsp; }&amp;&amp; std::move_constructible&lt;HandlerType&gt; &amp;&amp; !std::copy_constructible&lt;HandlerType&gt;;\n&nbsp;\n&nbsp;&nbsp;&nbsp; // BaseHandler类定义\n&nbsp;&nbsp;&nbsp; // HandlerLevel是日志处理器的日志等级\n&nbsp;&nbsp;&nbsp; // 自己实现Handler时可以继承BaseHandler然后实现emit\n&nbsp;&nbsp;&nbsp; template &lt;Level HandlerLevel = Level::Warning&gt;\n&nbsp;&nbsp;&nbsp; class BaseHandler {\n&nbsp;&nbsp;&nbsp; public:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 构造函数：formatter为日志处理器的格式化器\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BaseHandler(Formatter formatter) : _formatter(formatter) {}\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 不允许拷贝\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BaseHandler(const BaseHandler&amp;) = delete;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 不允许赋值\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BaseHandler&amp; operator=(const BaseHandler&amp;) = delete;\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 移动构造函数：允许日志处理器对象之间移动\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BaseHandler(BaseHandler&amp;&amp; rhs) noexcept : _formatter(std::move(rhs._formatter)) {};\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 析构函数，考虑到会被继承，避免析构时发生资源泄露\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual ~BaseHandler() {}\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // getForamtter：获取formatter\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Formatter getForamtter() const {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return _formatter;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // setForamtter：修改formatter\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void setForamtter(Formatter formatter) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _formatter = formatter;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // format：调用格式化器将record转换成文本字符串\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string format(const Record&amp; record) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return _formatter(record);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp; private:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 日志处理器的格式化器\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Formatter _formatter;\n&nbsp;&nbsp;&nbsp; };\n}\n</code></pre><p>Handler是一个concept。出于性能考虑，我们并没有强制要求所有日志处理器都继承一个标准基类，然后通过标准基类调用实现。<strong>我们的做法是，定义一个concept来约束Handler的接口。</strong></p><p>日志处理器的约束包括：</p><ul>\n<li>提供emit接口用于提交日志记录。</li>\n<li>提供format函数，参数为日志记录对象，返回类型为std::string。</li>\n<li>提供移动构造函数。</li>\n<li>不可拷贝（禁用拷贝构造函数）。</li>\n</ul><p>BaseHandler是为其他日志处理器类提供的基类。虽然我们不强制所有的日志处理器继承一个标准基类，但还是提供了一个基类实现，这样可以降低具体实现的编码工作量。</p><h3>具体实现</h3><p>日志处理器具体怎么实现呢？我们以DefaultHandler为例看一看，DefaultHandler是默认日志处理器，负责将日志输出到标准输出流。</p><p>DefaultHandler 实现在logging/handlers/DefaultHandler.h中。</p><pre><code class=\"language-c++\">#pragma once\n&nbsp;\n#include \"logging/Handler.h\"\n&nbsp;\nnamespace logging::handlers {\n&nbsp;&nbsp;&nbsp; // 默认日志处理器\n&nbsp;&nbsp;&nbsp; template &lt;Level HandlerLevel = Level::Warning&gt;\n&nbsp;&nbsp;&nbsp; // 继承BaseHandler\n&nbsp;&nbsp;&nbsp; class DefaultHandler : public BaseHandler&lt;HandlerLevel&gt; {\n&nbsp;&nbsp;&nbsp; public:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 构造函数，需要指定格式化器，默认格式化器为defaultFormatter\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DefaultHandler(Formatter formatter = defaultFormatter) : BaseHandler&lt;HandlerLevel&gt;(formatter) {}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 禁止拷贝构造函数\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DefaultHandler(const DefaultHandler&amp;) = delete;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 定义移动构造函数\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DefaultHandler(const DefaultHandler&amp;&amp; rhs) noexcept : BaseHandler&lt;HandlerLevel&gt;(rhs.getForamtter()) {}\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // emit用于提交日志记录\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // emitLevel &gt; HandlerLevel的日志会被丢弃\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; template &lt;Level emitLevel&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; requires (emitLevel &gt; HandlerLevel)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void emit(const Record&amp; record) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // emitLevel &lt;= HandlerLevel的日志会被输出到标准输出流中\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; template &lt;Level emitLevel&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; requires (emitLevel &lt;= HandlerLevel)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void emit(const Record&amp; record) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 调用format将日志记录对象格式化成文本字符串\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; this-&gt;format(record) &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp; };\n}\n</code></pre><p>DefaultHandler按照日志处理器的concept定义了相关接口。需要注意的是，emit成员函数通过requires，将输出日志等级较低的日志记录直接丢弃了。因此，只有当满足要求的日志输出时，才会输出到标准输出流中——这和Logger的log函数丢弃日志的原理一样。</p><p>StreamHandler和FileHandler的实现与DefaultHandler类似，只不过是将日志输出到不同的目标，它们的分工你可以参考下表。</p><p>你可以通过课程配套代码，了解它们的具体实现细节。</p><p><img src=\"https://static001.geekbang.org/resource/image/3e/e0/3e84103b1f0c3b73f91b361fd7bc63e0.jpg?wh=2872x1220\" alt=\"\"></p><h2>总结</h2><p>在使用C++ Formatting库和formatter类型时，我们往往会利用模板和concept来消解运行时性能损耗，以实现更好的性能。</p><p>对于日志处理这样一个典型的应用场景来说，约束条件通常包含以下几点。</p><ul>\n<li>提供emit接口用于提交日志记录。</li>\n<li>提供format函数，参数为日志记录对象，返回类型为std::string。</li>\n<li>提供移动构造函数。</li>\n<li>不可拷贝（禁用拷贝构造函数）。</li>\n</ul><p>总的来说，运行时性能是我们首要考虑的问题。这是一种新的实践范式——在现代C++编程体系中，尽可能让计算发生在编译时，而非运行时。</p><h2>课后思考</h2><p>我们在<a href=\"https://time.geekbang.org/column/article/627909\">第11讲</a>中，编写了基于Ranges的工程，其中包含了一些控制台输出日志。请你尝试编译今天这一讲的代码，替换Ranges工程中的所有输出，包括控制台输出和日志。</p><p>欢迎分享你的问题以及日志库的改进意见。我们一同交流。下一讲见！</p>","comments":[{"had_liked":false,"id":386748,"user_name":"李云龙","can_delete":false,"product_type":"c1","uid":3201926,"ip_address":"北京","ucode":"785924B16BE788","user_header":"https://static001.geekbang.org/account/avatar/00/30/db/86/51ec4c41.jpg","comment_is_top":false,"comment_ctime":1705477370,"is_pvip":false,"replies":[{"id":141099,"content":"比心","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1706443319,"ip_address":"上海","comment_id":386748,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"不仅学到了format，还在老师的项目代码中学到了不同风格的时间处理","like_count":1,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636559,"discussion_content":"比心","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1706443319,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":2,"child_discussions":[{"author":{"id":3921999,"avatar":"","nickname":"Geek_16c67a","note":"","ucode":"6CDF76F8CC314D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":647506,"discussion_content":"这个课程是视频形式还是文字的形式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1720114257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":636559,"ip_address":"四川","group_id":0},"score":647506,"extra":""},{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":3921999,"avatar":"","nickname":"Geek_16c67a","note":"","ucode":"6CDF76F8CC314D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":647522,"discussion_content":"图文加音频形式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1720143407,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":647506,"ip_address":"北京","group_id":0},"score":647522,"extra":""}]}]},{"had_liked":false,"id":395638,"user_name":"三笑三引伏兵","can_delete":false,"product_type":"c1","uid":3784424,"ip_address":"江苏","ucode":"B96439B22B407E","user_header":"https://static001.geekbang.org/account/avatar/00/39/be/e8/878aa74f.jpg","comment_is_top":false,"comment_ctime":1731511748,"is_pvip":false,"replies":[{"id":143799,"content":"如果纯虚函数，就会产生运行时开销，如果用模板，就会可以实现编译时计算，确定调用哪个版本的handler，减少运行时开销。\n\n不过这里其实没有特别原因，可以在基类里声明，这点开销在绝大多数应用中可以忽略不计。","user_name":"作者回复","user_name_real":"作者","uid":1006976,"ctime":1733036229,"ip_address":"加拿大","comment_id":395638,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"我想问下为什么BaseHandler不声明一个emit的纯虚函数呢 因为开销吗","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":654588,"discussion_content":"如果纯虚函数，就会产生运行时开销，如果用模板，就会可以实现编译时计算，确定调用哪个版本的handler，减少运行时开销。\n\n不过这里其实没有特别原因，可以在基类里声明，这点开销在绝大多数应用中可以忽略不计。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1733036229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"加拿大","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3784424,"avatar":"https://static001.geekbang.org/account/avatar/00/39/be/e8/878aa74f.jpg","nickname":"三笑三引伏兵","note":"","ucode":"B96439B22B407E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":654820,"discussion_content":"好的好的 懂了 谢谢 我都不知道老师回了 没啥提醒😭","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1733538644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":369249,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1677290388,"is_pvip":false,"replies":[{"id":134888,"content":"理论上StreamHandler可以包含所有的流，包括标准输出&#47;错误流、文件输出流甚至字符串流。我们这里单独设计FileHandler的原因是，在实际项目中使用文件记录日志时，经常会涉及到日志文件大小控制、日志文件分割、自动归档等常见需求，这种情况下必须用单独的FileHandler（需要有更多的配置参数），不能直接使用StreamHandler。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1678249442,"ip_address":"上海","comment_id":369249,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"StreamHandler的“流”是否包含File？甚至包含标准输出流？\n我目前的理解是：标准输出流就是控制台；“流”一般包括文件输出流、网络输出流，好像没有别的了。","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608070,"discussion_content":"理论上StreamHandler可以包含所有的流，包括标准输出/错误流、文件输出流甚至字符串流。我们这里单独设计FileHandler的原因是，在实际项目中使用文件记录日志时，经常会涉及到日志文件大小控制、日志文件分割、自动归档等常见需求，这种情况下必须用单独的FileHandler（需要有更多的配置参数），不能直接使用StreamHandler。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678249443,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}