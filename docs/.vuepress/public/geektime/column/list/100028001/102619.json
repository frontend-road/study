{"id":102619,"title":"15 | 多线程调优（上）：哪些操作导致了上下文切换？","content":"<p>你好，我是刘超。</p><p>我们常说“实践是检验真理的唯一标准”，这句话不光在社会发展中可行，在技术学习中也同样适用。</p><p>记得我刚入职上家公司的时候，恰好赶上了一次抢购活动。这是系统重构上线后经历的第一次高并发考验，如期出现了大量超时报警，不过比我预料的要好一点，起码没有挂掉重启。</p><p>通过工具分析，我发现 cs（上下文切换每秒次数）指标已经接近了 60w ，平时的话最高5w。再通过日志分析，我发现了大量带有 wait() 的 Exception，由此初步怀疑是大量线程处理不及时导致的，进一步锁定问题是连接池大小设置不合理。后来我就模拟了生产环境配置，对连接数压测进行调节，降低最大线程数，最后系统的性能就上去了。</p><p>从实践中总结经验，我知道了<span class=\"orange\">在并发程序中，并不是启动更多的线程就能让程序最大限度地并发执行。</span>线程数量设置太小，会导致程序不能充分地利用系统资源；线程数量设置太大，又可能带来资源的过度竞争，导致上下文切换带来额外的系统开销。</p><p>你看，其实很多经验就是这么一点点积累的。那么今天，我就想和你分享下“上下文切换”的相关内容，希望也能让你有所收获。</p><h2>初识上下文切换</h2><p>我们首先得明白，上下文切换到底是什么。</p><p>其实在单个处理器的时期，操作系统就能处理多线程并发任务。处理器给每个线程分配 CPU 时间片（Time Slice），线程在分配获得的时间片内执行任务。</p><!-- [[[read_end]]] --><p>CPU 时间片是 CPU 分配给每个线程执行的时间段，一般为几十毫秒。在这么短的时间内线程互相切换，我们根本感觉不到，所以看上去就好像是同时进行的一样。</p><p><span class=\"orange\">时间片决定了一个线程可以连续占用处理器运行的时长。</span>当一个线程的时间片用完了，或者因自身原因被迫暂停运行了，这个时候，另外一个线程（可以是同一个线程或者其它进程的线程）就会被操作系统选中，来占用处理器。这种一个线程被暂停剥夺使用权，另外一个线程被选中开始或者继续运行的过程就叫做上下文切换（Context Switch）。</p><p>具体来说，一个线程被剥夺处理器的使用权而被暂停运行，就是“切出”；一个线程被选中占用处理器开始或者继续运行，就是“切入”。在这种切出切入的过程中，操作系统需要保存和恢复相应的进度信息，这个进度信息就是“上下文”了。</p><p>那上下文都包括哪些内容呢？具体来说，它包括了寄存器的存储内容以及程序计数器存储的指令内容。CPU 寄存器负责存储已经、正在和将要执行的任务，程序计数器负责存储CPU 正在执行的指令位置以及即将执行的下一条指令的位置。</p><p>在当前 CPU 数量远远不止一个的情况下，操作系统将 CPU 轮流分配给线程任务，此时的上下文切换就变得更加频繁了，并且存在跨 CPU 上下文切换，比起单核上下文切换，跨核切换更加昂贵。</p><h2>多线程上下文切换诱因</h2><p>在操作系统中，上下文切换的类型还可以分为进程间的上下文切换和线程间的上下文切换。而在多线程编程中，我们主要面对的就是线程间的上下文切换导致的性能问题，下面我们就重点看看究竟是什么原因导致了多线程的上下文切换。开始之前，先看下系统线程的生命周期状态。</p><p><img src=\"https://static001.geekbang.org/resource/image/14/7e/14dde8a9486799ad1aa13aa06003757e.jpg?wh=1646*622\" alt=\"\"></p><p>结合图示可知，线程主要有“新建”（NEW）、“就绪”（RUNNABLE）、“运行”（RUNNING）、“阻塞”（BLOCKED）、“死亡”（DEAD）五种状态。到了Java层面它们都被映射为了NEW、RUNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINADTED等6种状态。</p><p>在这个运行过程中，线程由RUNNABLE转为非RUNNABLE的过程就是线程上下文切换。</p><p>一个线程的状态由 RUNNING 转为 BLOCKED ，再由 BLOCKED 转为 RUNNABLE ，然后再被调度器选中执行，这就是一个上下文切换的过程。</p><p>当一个线程从 RUNNING 状态转为 BLOCKED 状态时，我们称为一个线程的暂停，线程暂停被切出之后，操作系统会保存相应的上下文，以便这个线程稍后再次进入 RUNNABLE 状态时能够在之前执行进度的基础上继续执行。</p><p>当一个线程从 BLOCKED 状态进入到 RUNNABLE 状态时，我们称为一个线程的唤醒，此时线程将获取上次保存的上下文继续完成执行。</p><p>通过线程的运行状态以及状态间的相互切换，我们可以了解到，多线程的上下文切换实际上就是由多线程两个运行状态的互相切换导致的。</p><p>那么在线程运行时，线程状态由 RUNNING 转为 BLOCKED 或者由 BLOCKED 转为 RUNNABLE，这又是什么诱发的呢？</p><p>我们可以分两种情况来分析<span class=\"orange\">，一种是程序本身触发的切换，这种我们称为自发性上下文切换，另一种是由系统或者虚拟机诱发的非自发性上下文切换。</span></p><p>自发性上下文切换指线程由 Java 程序调用导致切出，在多线程编程中，执行调用以下方法或关键字，常常就会引发自发性上下文切换。</p><ul>\n<li>sleep()</li>\n<li>wait()</li>\n<li>yield()</li>\n<li>join()</li>\n<li>park()</li>\n<li>synchronized</li>\n<li>lock</li>\n</ul><p>非自发性上下文切换指线程由于调度器的原因被迫切出。常见的有：线程被分配的时间片用完，虚拟机垃圾回收导致或者执行优先级的问题导致。</p><p>这里重点说下“<span class=\"orange\">虚拟机垃圾回收为什么会导致上下文切换</span>”。在 Java 虚拟机中，对象的内存都是由虚拟机中的堆分配的，在程序运行过程中，新的对象将不断被创建，如果旧的对象使用后不进行回收，堆内存将很快被耗尽。Java 虚拟机提供了一种回收机制，对创建后不再使用的对象进行回收，从而保证堆内存的可持续性分配。而这种垃圾回收机制的使用有可能会导致 stop-the-world 事件的发生，这其实就是一种线程暂停行为。</p><h2>发现上下文切换</h2><p>我们总说上下文切换会带来系统开销，那它带来的性能问题是不是真有这么糟糕呢？我们又该怎么去监测到上下文切换？上下文切换到底开销在哪些环节？接下来我将给出一段代码，来对比串联执行和并发执行的速度，然后一一解答这些问题。</p><pre><code>public class DemoApplication {\n       public static void main(String[] args) {\n              //运行多线程\n              MultiThreadTester test1 = new MultiThreadTester();\n              test1.Start();\n              //运行单线程\n              SerialTester test2 = new SerialTester();\n              test2.Start();\n       }\n       \n       \n       static class MultiThreadTester extends ThreadContextSwitchTester {\n              @Override\n              public void Start() {\n                     long start = System.currentTimeMillis();\n                     MyRunnable myRunnable1 = new MyRunnable();\n                     Thread[] threads = new Thread[4];\n                     //创建多个线程\n                     for (int i = 0; i &lt; 4; i++) {\n                           threads[i] = new Thread(myRunnable1);\n                           threads[i].start();\n                     }\n                     for (int i = 0; i &lt; 4; i++) {\n                           try {\n                                  //等待一起运行完\n                                  threads[i].join();\n                           } catch (InterruptedException e) {\n                                  // TODO Auto-generated catch block\n                                  e.printStackTrace();\n                           }\n                     }\n                     long end = System.currentTimeMillis();\n                     System.out.println(&quot;multi thread exce time: &quot; + (end - start) + &quot;s&quot;);\n                     System.out.println(&quot;counter: &quot; + counter);\n              }\n              // 创建一个实现Runnable的类\n              class MyRunnable implements Runnable {\n                     public void run() {\n                           while (counter &lt; 100000000) {\n                                  synchronized (this) {\n                                         if(counter &lt; 100000000) {\n                                                increaseCounter();\n                                         }\n                                         \n                                  }\n                           }\n                     }\n              }\n       }\n       \n      //创建一个单线程\n       static class SerialTester extends ThreadContextSwitchTester{\n              @Override\n              public void Start() {\n                     long start = System.currentTimeMillis();\n                     for (long i = 0; i &lt; count; i++) {\n                           increaseCounter();\n                     }\n                     long end = System.currentTimeMillis();\n                     System.out.println(&quot;serial exec time: &quot; + (end - start) + &quot;s&quot;);\n                     System.out.println(&quot;counter: &quot; + counter);\n              }\n       }\n\n       //父类\n       static abstract class ThreadContextSwitchTester {\n              public static final int count = 100000000;\n              public volatile int counter = 0;\n              public int getCount() {\n                     return this.counter;\n              }\n              public void increaseCounter() {\n                     \n                     this.counter += 1;\n              }\n              public abstract void Start();\n       }\n}\n</code></pre><p>执行之后，看一下两者的时间测试结果：</p><p><img src=\"https://static001.geekbang.org/resource/image/be/47/be3a4dbe5abbafc7121bae9ab46b1f47.jpg?wh=1546*198\" alt=\"\"></p><p><strong>通过数据对比我们可以看到：</strong>串联的执行速度比并发的执行速度要快。这就是因为线程的上下文切换导致了额外的开销，使用 Synchronized 锁关键字，导致了资源竞争，从而引起了上下文切换，但即使不使用 Synchronized 锁关键字，并发的执行速度也无法超越串联的执行速度，这是因为多线程同样存在着上下文切换。<span class=\"orange\">Redis、NodeJS的设计就很好地体现了单线程串行的优势。</span></p><p>在 Linux 系统下，可以使用 Linux 内核提供的 vmstat 命令，来监视 Java 程序运行过程中系统的上下文切换频率，cs如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/73/29/73c791c705eb056ef3c44fd2bf8ecd29.jpg?wh=1408*334\" alt=\"\"></p><p>如果是监视某个应用的上下文切换，就可以使用 pidstat命令监控指定进程的 Context Switch 上下文切换。</p><p><img src=\"https://static001.geekbang.org/resource/image/f5/f7/f5ecbf7c77a3ecffcc79d2854b3459f7.jpg?wh=1564*582\" alt=\"\"></p><p>由于 Windows 没有像 vmstat 这样的工具，在 Windows 下，我们可以使用 Process Explorer，来查看程序执行时，线程间上下文切换的次数。</p><p>至于系统开销具体发生在切换过程中的哪些具体环节，总结如下：</p><ul>\n<li>操作系统保存和恢复上下文；</li>\n<li>调度器进行线程调度；</li>\n<li>处理器高速缓存重新加载；</li>\n<li>上下文切换也可能导致整个高速缓存区被冲刷，从而带来时间开销。</li>\n</ul><h2>总结</h2><p>上下文切换就是一个工作的线程被另外一个线程暂停，另外一个线程占用了处理器开始执行任务的过程。系统和 Java 程序自发性以及非自发性的调用操作，就会导致上下文切换，从而带来系统开销。</p><p>线程越多，系统的运行速度不一定越快。那么我们平时在并发量比较大的情况下，<span class=\"orange\">什么时候用单线程，什么时候用多线程呢？</span></p><p>一般在单个逻辑比较简单，而且速度相对来非常快的情况下，我们可以使用单线程。例如，我们前面讲到的 Redis，从内存中快速读取值，不用考虑 I/O 瓶颈带来的阻塞问题。而在逻辑相对来说很复杂的场景，等待时间相对较长又或者是需要大量计算的场景，我建议使用多线程来提高系统的整体性能。例如，NIO 时期的文件读写操作、图像处理以及大数据分析等。</p><h2>思考题</h2><p>以上我们主要讨论的是多线程的上下文切换，前面我讲分类的时候还曾提到了进程间的上下文切换。那么你知道在多线程中使用Synchronized还会发生进程间的上下文切换吗？具体又会发生在哪些环节呢？</p><p>期待在留言区看到你的见解。也欢迎你点击“请朋友读”，把今天的内容分享给身边的朋友，邀请他一起讨论。</p><p></p>","comments":[{"had_liked":false,"id":107060,"user_name":"晓杰","can_delete":false,"product_type":"c1","uid":1441546,"ip_address":"","ucode":"1174C88EEBF8A6","user_header":"https://static001.geekbang.org/account/avatar/00/15/ff/0a/12faa44e.jpg","comment_is_top":false,"comment_ctime":1561449866,"is_pvip":false,"replies":[{"id":"38851","content":"对的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561519408,"ip_address":"","comment_id":107060,"utype":1}],"discussion_count":1,"race_medal":0,"score":"349453800842","product_id":100028001,"comment_content":"锁的竞争太激烈会导致锁升级为重量级锁，未抢到锁的线程会进入monitor，而monitor依赖于底层操作系统的mutex lock，获取锁时会发生用户态和内核态之间的切换，所以会发生进程间的上下文切换。","like_count":81,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455346,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561519408,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135024,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1568981037,"is_pvip":false,"replies":[{"id":"51867","content":"sleep不会释放锁资源，wait则会，但两者都会从running状态中走出，也就是不再占用CPU资源。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1569053268,"ip_address":"","comment_id":135024,"utype":1}],"discussion_count":1,"race_medal":0,"score":"147597869101","product_id":100028001,"comment_content":"老师，网上有个争议，sleep会不会释放cpu时间片？","like_count":34,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468003,"discussion_content":"sleep不会释放锁资源，wait则会，但两者都会从running状态中走出，也就是不再占用CPU资源。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569053268,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106174,"user_name":"李博","can_delete":false,"product_type":"c1","uid":1119919,"ip_address":"","ucode":"04C2DE916B84AB","user_header":"https://static001.geekbang.org/account/avatar/00/11/16/af/bada0f59.jpg","comment_is_top":false,"comment_ctime":1561195546,"is_pvip":false,"replies":[{"id":"38405","content":"进程上下文切换，是指用户态和内核态的来回切换。我们知道，如果一旦Synchronized锁资源竞争激烈，线程将会被阻塞，阻塞的线程将会从用户态调用内核态，尝试获取mutex，这个过程就是进程上下文切换。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561253420,"ip_address":"","comment_id":106174,"utype":1}],"discussion_count":3,"race_medal":0,"score":"113230345242","product_id":100028001,"comment_content":"如果Synchronized块中包含io操作或者大量的内存分配时，可能会导致进程IO等待或者内存不足。进一步会导致操作系统进行进程切换，等待系统资源满足时在切换到当前进程。 不知道理解的对不对？","like_count":26,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454989,"discussion_content":"进程上下文切换，是指用户态和内核态的来回切换。我们知道，如果一旦Synchronized锁资源竞争激烈，线程将会被阻塞，阻塞的线程将会从用户态调用内核态，尝试获取mutex，这个过程就是进程上下文切换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561253420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1080208,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7b/90/71d953d4.jpg","nickname":"CyurioAsk","note":"","ucode":"B084090400E485","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":535015,"discussion_content":"进程上下文切换是指用户态和内核态的来回切换？你确定？这个是两个概念好吧，特权模式切换不等于进程上下文切换。而是进程上下文切换、线程上下文切换的时候还伴有特权模式切换。这不误导人吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638331578,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":454989,"ip_address":""},"score":535015,"extra":""}]},{"author":{"id":1209313,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIbas4S4X5W15njMeoEPPSyBZRX37nrTXbMFFeHghXl4Slk6WXE7oq5yxoNnukYfcOQs00RAvUmEA/132","nickname":"Geek_5258f8","note":"","ucode":"4EC60AE0C23CBE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369149,"discussion_content":"内核与用户态切换叫模式切换，不是进程上下文吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618958350,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155544,"user_name":"内卷改变命运","can_delete":false,"product_type":"c1","uid":1282039,"ip_address":"","ucode":"928F29B8C1F60D","user_header":"https://static001.geekbang.org/account/avatar/00/13/8f/f7/9b59c019.jpg","comment_is_top":false,"comment_ctime":1574696501,"is_pvip":false,"replies":[{"id":"60140","content":"在linux操作系统中，进程的运行空间一般分为用户态和内核态，用户态空间一般是进程应用运行空间，而内核态空间一般是指应用需要调用系统资源，应用不能再用户态空间直接调用系统资源，需要通过内核态来系统系统资源。<br><br>所以进程在用户态和内核态两个直接相互切换，就称之为进程上下文切换。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1574941496,"ip_address":"","comment_id":155544,"utype":1}],"discussion_count":1,"race_medal":1,"score":"65999205941","product_id":100028001,"comment_content":"进程的上下文切换是指从一个进程切换到另一个进程运行。用户态到内核态为什么也属于进程上下文切换？从哪个进程切换到哪个进程了？","like_count":15,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475790,"discussion_content":"在linux操作系统中，进程的运行空间一般分为用户态和内核态，用户态空间一般是进程应用运行空间，而内核态空间一般是指应用需要调用系统资源，应用不能再用户态空间直接调用系统资源，需要通过内核态来系统系统资源。\n\n所以进程在用户态和内核态两个直接相互切换，就称之为进程上下文切换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574941496,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132197,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1568040384,"is_pvip":false,"replies":[{"id":"50704","content":"进程间的上下文切换因为是用户态和内核态之间的切换，需要消耗更多的资源，例如，寄存器中的内容切换出，缓存的刷新等，而线程间的上下文切换是用户态的线程切换，由于是同一个虚拟内存，消耗资源相对较少。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1568167760,"ip_address":"","comment_id":132197,"utype":1}],"discussion_count":1,"race_medal":0,"score":"53107647936","product_id":100028001,"comment_content":"课后思考及问题<br>本文核心观点<br>1：线程上下文切换指啥？<br>线程上下文切换指一个线程被暂停剥夺对CPU的使用权，另外一个线程被选中开始或者继续在CPU中运行的过程。<br>2：线程上文切换的问题？<br>上下文切换会导致额外的性能开销，因为一个线程正在CPU上执行需要停下来换另外一个线程来执行，需要做许多的事情。<br>3：上下文切换的性能开销花费在哪里啦？<br>操作系统保存和恢复上下文；<br>调度器进行线程调度；<br>处理器高速缓存重新加载；<br>上下文切换也可能导致整个高速缓存区被冲刷，从而带来时间开销。<br>4：上下文切换的分类？<br>上下文切换分为进程上下文切换和线程上下文切换，这是站在操作系统的层面来讲的，站在CPU的角度，它不知道什么进程、线程之类的东西，他只需要知道怎么取指令怎么执行就行啦！<br>5：上下文切换的发送场景？<br>上下文切换分为两种，一是自发上下文切换，另一个是非自己上下文切换。<br>6：啥是自发上下文切换？怎么触发？<br>自发性上下文切换指线程由 Java 程序调用导致切出，在多线程编程中，执行调用以下方法或关键字，常常就会引发自发性上下文切换。<br>sleep()<br>wait()<br>yield()<br>join()<br>park()<br>synchronized<br>lock<br>7：啥是非自发上下文切换？怎么触发？<br>非自发性上下文切换指线程由于调度器的原因被迫切出。常见的有：线程被分配的时间片用完，虚拟机垃圾回收导致或者执行优先级的问题导致。<br>8：在多线程中使用 Synchronized 会发生进程间的上下文切换，具体的发生环节如下(声明：答案我没想到，参考评论区老师的回答)？<br>当升级到重量级锁后，线程竞争锁资源，将会进入等待队列中，并在等待队列中不断尝试获取锁资源。每次去获取锁资源，都需要通过系统调底层操作系统申请获取Mutex Lock，这个过程就是一次用户态和内核态的切换。<br>有个疑问，老师具体没讲什么是进程的上下文切换？什么是线程的上下文切换？评论区中又特意强调进程间的上下文切换指用户态和内核态之间的切换。那线程间的切换指什么？线程一直在内核态空间中，只是切出了CPU是吗？","like_count":12,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466812,"discussion_content":"进程间的上下文切换因为是用户态和内核态之间的切换，需要消耗更多的资源，例如，寄存器中的内容切换出，缓存的刷新等，而线程间的上下文切换是用户态的线程切换，由于是同一个虚拟内存，消耗资源相对较少。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568167760,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106148,"user_name":"老杨同志","can_delete":false,"product_type":"c1","uid":1246199,"ip_address":"","ucode":"3F334F0CFD3DE6","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/f7/3a493bec.jpg","comment_is_top":false,"comment_ctime":1561189573,"is_pvip":false,"replies":[{"id":"38407","content":"理解正确~","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561253541,"ip_address":"","comment_id":106148,"utype":1}],"discussion_count":3,"race_medal":0,"score":"44510862533","product_id":100028001,"comment_content":"使用Synchronized获得锁失败，进入等待队列会发生上下文切换。如果竞争锁时锁是其他线程的偏向锁，需要降级，这是需要stop the world也会发生上下文切换","like_count":10,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454975,"discussion_content":"理解正确~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561253541,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1048661,"avatar":"https://static001.geekbang.org/account/avatar/00/10/00/55/3f0bc345.jpg","nickname":"Ghost","note":"","ucode":"CC6FD1D460ED10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":88793,"discussion_content":"是锁升级，不是降级，同步锁是不支持降级的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576731703,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1202881,"avatar":"https://static001.geekbang.org/account/avatar/00/12/5a/c1/6df65e0a.jpg","nickname":"190coder","note":"","ucode":"68111F5B32CCF7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":533881,"discussion_content":"是撤销偏向锁发生stw","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638006130,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135014,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1568978430,"is_pvip":false,"replies":[{"id":"51868","content":"Java应用进程里面执行的代码则是属于用户态，而系统内核代码执行则属于内核态，假设我们一个同步锁的执行，首先会在Java应用程序中执行，之后需要切换到系统内核中去获取mutex，在切换的时候，需要将原来用户态的执行指令与内核执行指令相互切换，此时CPU资源也会发生切出切入。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1569054044,"ip_address":"","comment_id":135014,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31633749502","product_id":100028001,"comment_content":"老师，可以讲下进程从用户态到内核态为什么就发生了上下问切换呢","like_count":7,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468000,"discussion_content":"Java应用进程里面执行的代码则是属于用户态，而系统内核代码执行则属于内核态，假设我们一个同步锁的执行，首先会在Java应用程序中执行，之后需要切换到系统内核中去获取mutex，在切换的时候，需要将原来用户态的执行指令与内核执行指令相互切换，此时CPU资源也会发生切出切入。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569054044,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106082,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1561167796,"is_pvip":false,"replies":[{"id":"38417","content":"我们可以调用yield，线程可以从runnning到runnable，我们可以手动编程试试，看看cs是不是增加了。<br><br>yield也会导致上下文切换的。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561254644,"ip_address":"","comment_id":106082,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27330971572","product_id":100028001,"comment_content":"老师好，请教一个问题：<br><br>1 非自发场景中，cpu time slice 用完后切换线程，此时被暂停线程是什么状态呢？runnable or blocked, 如果是runnable的话，是不是意味着从runnning到runnable也会导致上下文切换<br>","like_count":6,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454941,"discussion_content":"我们可以调用yield，线程可以从runnning到runnable，我们可以手动编程试试，看看cs是不是增加了。\n\nyield也会导致上下文切换的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561254644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154877,"user_name":"吴青","can_delete":false,"product_type":"c1","uid":1048965,"ip_address":"","ucode":"26DBF37AAF0000","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/85/a2279772.jpg","comment_is_top":false,"comment_ctime":1574585567,"is_pvip":false,"replies":[{"id":"59463","content":"这里指的是系统中线程的五个基本状态，waiting以及timed_waiting属于阻塞，这里的阻塞包括争用锁导致的阻塞blocked状态、调用wait(timeout)导致的timed_waiting状态以及调用wait()导致的waiting状态。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1574599153,"ip_address":"","comment_id":154877,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23049422047","product_id":100028001,"comment_content":"老师，你是不是把waiting和timed_waiting状态漏了","like_count":5,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475604,"discussion_content":"这里指的是系统中线程的五个基本状态，waiting以及timed_waiting属于阻塞，这里的阻塞包括争用锁导致的阻塞blocked状态、调用wait(timeout)导致的timed_waiting状态以及调用wait()导致的waiting状态。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574599153,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106114,"user_name":"欧星星","can_delete":false,"product_type":"c1","uid":1014347,"ip_address":"","ucode":"56365442E231A0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/4b/1a7b36ab.jpg","comment_is_top":false,"comment_ctime":1561179386,"is_pvip":false,"replies":[{"id":"38408","content":"Synchronized在轻量级锁之前，锁资源竞争产生的是线程上下文切换，一旦升级到重量级锁，就会产生进程上下文切换。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561253883,"ip_address":"","comment_id":106114,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23036015866","product_id":100028001,"comment_content":"使用Synchronized在锁获取的时候会发生CPU上下文切换，多线程本身也会有上下文切换，这样就会多一次切换，是这样吗？","like_count":5,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454957,"discussion_content":"Synchronized在轻量级锁之前，锁资源竞争产生的是线程上下文切换，一旦升级到重量级锁，就会产生进程上下文切换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561253883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106320,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1561264852,"is_pvip":false,"replies":[{"id":"38520","content":"CAS乐观锁只是一个原子操作，为CPU指令实现，所以操作速度非常快，Java是调用C语言中的函数执行CPU指令操作，不需要进入内核或者切换线程。<br><br>而lock竞争锁资源是基于用户态完成，所以竞争锁资源时不会发生进程上下文切换。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561343694,"ip_address":"","comment_id":106320,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18741134036","product_id":100028001,"comment_content":"老师好!看了大牛们的课后习题回答，大概意思就是偏斜锁，轻量级锁这种不涉及进程切换。然后并发严重膨胀为重量级锁了，发生blocked了或者调用wait(),join()方法释放锁资源，就会触发进程切换了。CAS这种乐观锁，不会触发进程上下文切换?LOCK呢?在调用pack()的时候会导致进程切换么?lock()方法直接获取到锁，没有发生寻找安全点的时候是不是就不会触发进程上下文切换了?<br>纯属瞎猜，希望老师解惑谢谢。","like_count":4,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455044,"discussion_content":"CAS乐观锁只是一个原子操作，为CPU指令实现，所以操作速度非常快，Java是调用C语言中的函数执行CPU指令操作，不需要进入内核或者切换线程。\n\n而lock竞争锁资源是基于用户态完成，所以竞争锁资源时不会发生进程上下文切换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561343694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106170,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1561193745,"is_pvip":false,"replies":[{"id":"38406","content":"进程上下文切换，是指用户态和内核态的来回切换。当Synchronized锁资源竞争激烈，线程将会被阻塞，阻塞的线程将会从用户态调用内核态，尝试获取mutex，这个过程是Synchronized锁产生的进程上下文切换。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561253469,"ip_address":"","comment_id":106170,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18741062929","product_id":100028001,"comment_content":"老师讲的上下文切换的确干货很多，思考题我觉得应该是使用synchronize导致单线程进行，且执行方法时间过长，当前进程时间片执行时间结束，导致cpu不得不进行进程间上下文切换。","like_count":4,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454986,"discussion_content":"进程上下文切换，是指用户态和内核态的来回切换。当Synchronized锁资源竞争激烈，线程将会被阻塞，阻塞的线程将会从用户态调用内核态，尝试获取mutex，这个过程是Synchronized锁产生的进程上下文切换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561253469,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144355,"user_name":"悟空WuKong","can_delete":false,"product_type":"c1","uid":1139455,"ip_address":"","ucode":"49AFD2B048C1BA","user_header":"https://static001.geekbang.org/account/avatar/00/11/62/ff/f71034e9.jpg","comment_is_top":false,"comment_ctime":1571902724,"is_pvip":false,"replies":[{"id":"55862","content":"对的，协程就是一个典型的例子，一个线程中通过任务调度执行不同的任务，没有发生线程间的上下文切换。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1572081366,"ip_address":"","comment_id":144355,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14456804612","product_id":100028001,"comment_content":"请问 线程池中 一个线程处理完一个任务之后会发生上下文切换吗？如果接下来的任务还是该线程处理，线程是不是一直在运行状态，是不是就不会发生上下文切换？","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471901,"discussion_content":"对的，协程就是一个典型的例子，一个线程中通过任务调度执行不同的任务，没有发生线程间的上下文切换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572081366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2051293,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","nickname":"Bumblebee","note":"","ucode":"B879C8A511D08D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571720,"discussion_content":"提个醒，线程池的实现一般都是生产消费模型","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652364362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106625,"user_name":"LW","can_delete":false,"product_type":"c1","uid":1325297,"ip_address":"","ucode":"89820332658E98","user_header":"https://static001.geekbang.org/account/avatar/00/14/38/f1/996a070d.jpg","comment_is_top":false,"comment_ctime":1561358039,"is_pvip":false,"replies":[{"id":"38835","content":"当升级到重量级锁后，线程竞争锁资源，将会进入等待队列中，并在等待队列中不断尝试获取锁资源。每次去获取锁资源，都需要通过系统调底层操作系统申请获取Mutex Lock，这个过程就是一次用户态和内核态的切换。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561515316,"ip_address":"","comment_id":106625,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14446259927","product_id":100028001,"comment_content":"看回复老师说锁升级到重量级锁，就会发生进程间切换，这个点能详细讲讲吗？","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455158,"discussion_content":"当升级到重量级锁后，线程竞争锁资源，将会进入等待队列中，并在等待队列中不断尝试获取锁资源。每次去获取锁资源，都需要通过系统调底层操作系统申请获取Mutex Lock，这个过程就是一次用户态和内核态的切换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561515316,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106078,"user_name":"ヾ(◍°∇°◍)ﾉﾞ","can_delete":false,"product_type":"c1","uid":1044175,"ip_address":"","ucode":"89545632BDA56E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJOBwR7MCVqwZbPA5RQ2mjUjd571jUXUcBCE7lY5vSMibWn8D5S4PzDZMaAhRPdnRBqYbVOBTJibhJg/132","comment_is_top":false,"comment_ctime":1561167250,"is_pvip":false,"replies":[{"id":"38418","content":"sleep和wait一样，都会进入阻塞状态，区别是sleep没有释放锁，而wait释放了锁。所以也是一次上下文切换。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561254796,"ip_address":"","comment_id":106078,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14446069138","product_id":100028001,"comment_content":"sleep引起上下文切换是指系统调用吗？用户态到内核态的切换。但是这时候线程会从running变成block吗？感觉这个线程没有让出控制吧，跟wait不一样的吧<br>","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454939,"discussion_content":"sleep和wait一样，都会进入阻塞状态，区别是sleep没有释放锁，而wait释放了锁。所以也是一次上下文切换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561254796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345548,"user_name":"Bumblebee","can_delete":false,"product_type":"c1","uid":2051293,"ip_address":"","ucode":"B879C8A511D08D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","comment_is_top":false,"comment_ctime":1652371952,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10242306544","product_id":100028001,"comment_content":"今日收获<br><br>①  在并发程序中并不是启用更多的线程就能让程序最大限度的并发执行；<br><br>②  线程从Running 变为其他状态就发生一次线程上下文的切换；<br><br>③  线程从Running 变为blocked我们称一个线程暂停，此时操作系统会保存该线程此时的上下文，以便线程再次进入Running 继续执行；<br><br>④  线程上下文切换分自发性的（调用sleep、wait、yield、join、park、synchronized、lock）与非自发性的（比如线程分配的cpu时间片到了、虚拟机回收垃圾发生stop  the  world等）；<br><br>⑤  进程上下文切换（用户态与内核态的转换）synchronized升级为重量级锁时，会触发进程上下文切换；<br><br>⑥  单线程（逻辑简单，处理速度较快）与多线程（逻辑复杂，等待时间长或是大量计算（注意做好线程池隔离））的使用场景；<br><br>⑦  监控上下文切换的工具（vmstat 命令，来监视 Java 程序运行过程中系统的上下文切换频率，cs ）、（如果是监视某个应用的上下文切换，就可以使用 pidstat 命令监控指定进程的 Context Switch 上下文切换。）<br><br>⑧ 上下文切换系统开销具体发生在切换过程中的哪些具体环节，总结如下：（操作系统保存和恢复上下文、调度器进行线程调度、处理器高速缓存重新加载、上下文切换也可能导致整个高速缓存区被冲刷，从而带来时间开销）；<br><br><br>总结<br>①  避免jvm频繁的full  gc  发生stop  the  world导致线程发生上下文切换；<br>②  对于竞争激烈的同步代码少用synchronized，因为竞争激励容易使synchronized升级到重量级锁从而导致进程上下文切换（用户态与内核态的转换）；<br>③  避免线程池线程过多导致竞争激烈（频繁上下文切换）<br>","like_count":2},{"had_liked":false,"id":106110,"user_name":"汤小高","can_delete":false,"product_type":"c1","uid":1555565,"ip_address":"","ucode":"D4AB7766273D52","user_header":"https://static001.geekbang.org/account/avatar/00/17/bc/6d/f6f0a442.jpg","comment_is_top":false,"comment_ctime":1561177063,"is_pvip":false,"replies":[{"id":"38414","content":"好的，后面我总结一份命令排查工具的使用报告给大家。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561254365,"ip_address":"","comment_id":106110,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10151111655","product_id":100028001,"comment_content":"老师能否提供一份全面的如何定位性能方面问题的工具或者命令了，比如操作系统层面的，也就是文章中提到的，或者JAVA工具层面的。能出一篇这种通过相关命令或者工具定位排查问题的案例最好不过了。","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454955,"discussion_content":"好的，后面我总结一份命令排查工具的使用报告给大家。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561254365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106079,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1561167252,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10151101844","product_id":100028001,"comment_content":"首先，如何决定多线程。这点核心的依据我认为是提高计算机资源使用率。将cpu执行耗时较长比如io操作，跟耗时较短比如纯逻辑计算的业务操作分解开。根据时间比例对应分配操作线程池的线程数。进而保障资源最大化利用，比如耗时较短的业务线程不会空闲。理论上多核的现在，并行逻辑都要比串行逻辑快（并行交集时间，既剩下的时间大于上下文切换和资源合并的时间开销）。其实我觉得还得引入业务价值做考虑，核心业务加大优化力度，边缘业务性能保持在容忍线以上就好，为核心业务让渡资源。最后是思考题。才疏学浅，隐式锁个人认为是为线程价格执行体准备的，不会影响到进程间的切换。但是多进程间用的也是同一台服务器的资源。所以必然也会有上下文切换，而这块都是非自发的。比如cpu时间分片呈现的进程间交替使用cpu，或则进程各自持有的虚拟内存页对实际物理内存的使用。至于文件操作，java发现文件资源被其他进程占用好像是直接报错的，所以没有进程间竞争。但输出设备，打印机音箱这些，它们有多进程轮流共用的现象，感觉起来也有点分片执行，优先调度之类的样子，应该也有竞争。个人认知半猜回复，还望老师指正。搬砖引玉。","like_count":2},{"had_liked":false,"id":106074,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1561166570,"is_pvip":false,"replies":[{"id":"38421","content":"这五个状态是指的系统的线程状态。如果说Java线程状态，我们可以分为new、runable、waiting、temed-wait、blocked、terminated。<br><br>这个分片时间我们无法调节，我们需要的是避免竞争过于激烈导致过多的上下文切换。线程池的线程调优这块，我们后面会有一讲专门讲到。<br><br>","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561255509,"ip_address":"","comment_id":106074,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10151101162","product_id":100028001,"comment_content":"老师好!我看Java源码里面线程状态是<br>1.new<br>2.runnable<br>3.wait<br>4.timed-wait<br>5.blocked<br>6.i..(完成)。<br>有次面试被问了这个，我一开始答就是网上说的new,runnable,running,wait,blocked,dead。然后面试官让我回去再看看。到底线程状态有几个，怎么划分啊。<br>大概一个分片多少时间比较合理啊，单核CPU设置多少线程比较合适?之前有个调用第三方的一次得发送4K请求，测试下来开50个线程的时候效果比较好16S完成。这个线程数和网上说的CPU核心数*(IO阻塞时间&#47;计算时间）出路挺大的。服务器我们用的单核服务器，Tomcat连接池，MySQL连接池这些都加上我感觉线程数很可能过100了。能讲讲具体调试的步骤和指标么。实战优化过程经验谢谢老师。","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454937,"discussion_content":"这五个状态是指的系统的线程状态。如果说Java线程状态，我们可以分为new、runable、waiting、temed-wait、blocked、terminated。\n\n这个分片时间我们无法调节，我们需要的是避免竞争过于激烈导致过多的上下文切换。线程池的线程调优这块，我们后面会有一讲专门讲到。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561255509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1108306,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e9/52/aa3be800.jpg","nickname":"Loubobooo","note":"","ucode":"7B2543A80EBDEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":151,"discussion_content":"通过Thread.State的源码可知，线程一共有6种状态，分别是 NEW(新建)、RUNNABLE(运行)、BLOCKED(阻塞)、TIMED_WAITING(定时等待)、WAITING(等待)、TERMINATED(终止、结束)，就是6种状态，如果不是建议面试官回家再看看","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1561191717,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135038,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1568985530,"is_pvip":false,"replies":[{"id":"51866","content":"如果执行任务耗时，多线程可以提高执行效率。Redis之所以快，是因为redis主要是操作内存，没有磁盘IO操作，读写都非常快，其次串行减少上下文切换带来的时间开销。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1569052752,"ip_address":"","comment_id":135038,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5863952826","product_id":100028001,"comment_content":"老师，按道理任务多时大部分情况下并发处理不应该比单线程快么？redis使用单线程不是因为串行快吧。","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468013,"discussion_content":"如果执行任务耗时，多线程可以提高执行效率。Redis之所以快，是因为redis主要是操作内存，没有磁盘IO操作，读写都非常快，其次串行减少上下文切换带来的时间开销。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569052752,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108476,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1561779713,"is_pvip":false,"replies":[{"id":"39363","content":"加载上下文一般是加载正在运行和将要运行的线程上下文。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561864915,"ip_address":"","comment_id":108476,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5856747009","product_id":100028001,"comment_content":"转入到runnable状态时就加载上下文了？不应该是running状态时么","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455996,"discussion_content":"加载上下文一般是加载正在运行和将要运行的线程上下文。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561864915,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106562,"user_name":"勿闻轩外香","can_delete":false,"product_type":"c1","uid":1116063,"ip_address":"","ucode":"D31BF163B7DFC0","user_header":"https://static001.geekbang.org/account/avatar/00/11/07/9f/31a32631.jpg","comment_is_top":false,"comment_ctime":1561345118,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5856312414","product_id":100028001,"comment_content":"干货满满😌","like_count":1},{"had_liked":false,"id":106152,"user_name":"nightmare","can_delete":false,"product_type":"c1","uid":1056314,"ip_address":"","ucode":"EF2E51C2122A86","user_header":"https://static001.geekbang.org/account/avatar/00/10/1e/3a/5b21c01c.jpg","comment_is_top":false,"comment_ctime":1561190469,"is_pvip":false,"replies":[{"id":"38409","content":"之前讲到的锁优化，以及后面要讲的优化线程池，这些都是一些上下文切换的案例。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561253959,"ip_address":"","comment_id":106152,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5856157765","product_id":100028001,"comment_content":"对于思考题，schronzid在激烈竞争的时候，有可能导致运行的进程里面的线程很快用完cpu时间片，而非自发的被切换，还有一种情况就是stop the  vvm虚拟机暂停，垃圾回收，那么只能其他进程更多的执行。关于文章的知识点最好带有案列，谢谢","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454978,"discussion_content":"之前讲到的锁优化，以及后面要讲的优化线程池，这些都是一些上下文切换的案例。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561253959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106083,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1561168290,"is_pvip":false,"replies":[{"id":"38416","content":"依然在内存中","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561254562,"ip_address":"","comment_id":106083,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5856135586","product_id":100028001,"comment_content":"老师好，有个问题线程切换的时候读到一半的数据会怎么处理啊，高速缓存中的，内存中的，等各个地方的数据。是换出保存，分配到时间片后再换回么?","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454942,"discussion_content":"依然在内存中","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561254562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106066,"user_name":"罗洲","can_delete":false,"product_type":"c1","uid":1263417,"ip_address":"","ucode":"68133E38A25C17","user_header":"https://static001.geekbang.org/account/avatar/00/13/47/39/0ce1aa62.jpg","comment_is_top":false,"comment_ctime":1561163729,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5856131025","product_id":100028001,"comment_content":"思考题:多线程会导致线程间的上下文切换，而使用同步锁会导致多线程之间串行化，会增加程序执行时间，而过长的执行时间可能导致分配给本进程的时间片不够用，从而发生进程间的上下文切换。","like_count":1},{"had_liked":false,"id":358449,"user_name":"LVM_23","can_delete":false,"product_type":"c1","uid":1039544,"ip_address":"广东","ucode":"5E54F9DB582E9F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/dc/b8/31c7e110.jpg","comment_is_top":false,"comment_ctime":1664330387,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664330387","product_id":100028001,"comment_content":"老师，并发和并行有什么区别？单个处理器也能并发，这个没理解好，感谢解惑","like_count":0},{"had_liked":false,"id":268065,"user_name":"曾泽浩","can_delete":false,"product_type":"c1","uid":1104601,"ip_address":"","ucode":"A7E5CF9E1571A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/da/d9/f051962f.jpg","comment_is_top":false,"comment_ctime":1608042371,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608042371","product_id":100028001,"comment_content":"老师，我想问下sleep()和wait()的区别？wait()会释放锁，sleep()不会释放锁，这把锁指的是什么锁？在调用wait()和sleep()之前，一定要获得锁吗？还有就是这个monitor，跟wait()和sleep()有什么联系吗？","like_count":0},{"had_liked":false,"id":244946,"user_name":"旅途","can_delete":false,"product_type":"c1","uid":1212902,"ip_address":"","ucode":"5022477E8E9441","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/e6/6cafed37.jpg","comment_is_top":false,"comment_ctime":1598759781,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598759781","product_id":100028001,"comment_content":"老师 多线程同步 是不是 竞争时一线程个获得了锁 而其他没获取到的线程 又从runnable编程blocked 以此往复 这样主要导致的上下文切换?","like_count":0},{"had_liked":false,"id":237667,"user_name":"贲佳振","can_delete":false,"product_type":"c1","uid":1122757,"ip_address":"","ucode":"57179F92B0FB31","user_header":"https://static001.geekbang.org/account/avatar/00/11/21/c5/1ebc0de6.jpg","comment_is_top":false,"comment_ctime":1595919898,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595919898","product_id":100028001,"comment_content":"https:&#47;&#47;pic1.zhimg.com&#47;v2-287f87ad5328f2aa5cd7fbd48dadcd8f_r.jpg?source=1940ef5c<br>此图片更准确的描述了线程状态机","like_count":0},{"had_liked":false,"id":237199,"user_name":"Gavin","can_delete":false,"product_type":"c1","uid":1616970,"ip_address":"","ucode":"A5735665E303FD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/2UXuSevhia94o9Eky4OfMuSictaldxcqpjGuvRCOcvjIIoVBAENLEZbv2lgwmwC8icK1ZrUcneNtiaeFBV8MT3uzNg/132","comment_is_top":false,"comment_ctime":1595734122,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595734122","product_id":100028001,"comment_content":"一次系统调用会发生2次cpu上下文切换，需要切换寄存器；进程上下文切换，需要切换虚拟内存、寄存器、内核栈；线程上下文切换，如果线程属于不同进程则和进程上下文一样，如果属于同一进程，则对比进程上下文切换，不需要切换虚拟内存。","like_count":0},{"had_liked":false,"id":236694,"user_name":"看风景人","can_delete":false,"product_type":"c1","uid":1621121,"ip_address":"","ucode":"2766B2F8377C37","user_header":"https://static001.geekbang.org/account/avatar/00/18/bc/81/c480323b.jpg","comment_is_top":false,"comment_ctime":1595504358,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1595504358","product_id":100028001,"comment_content":"非自发性上下文切换指线程由于调度器的原因被迫切出。常见的有：线程被分配的时间片用完，虚拟机垃圾回收导致或者执行优先级的问题导致。<br><br>执行优先级的问题的问题是指什么？","like_count":0},{"had_liked":false,"id":231191,"user_name":"郑济基","can_delete":false,"product_type":"c1","uid":1223068,"ip_address":"","ucode":"B6207C2C21015D","user_header":"https://static001.geekbang.org/account/avatar/00/12/a9/9c/40c2fa9a.jpg","comment_is_top":false,"comment_ctime":1593605385,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593605385","product_id":100028001,"comment_content":"老师，请教个场景。如果线程在执行rpc调用，这时候线程会被切出吗？是否会入到线程队列排队?线程还会占用线程池里的线程吗？如果在等待rpc返回的线程数已经比最大线程数大了，线程池还会继续创建线程来处理交易吗？","like_count":0},{"had_liked":false,"id":223733,"user_name":"白","can_delete":false,"product_type":"c1","uid":1159553,"ip_address":"","ucode":"F7A7BCFCDFDEF1","user_header":"https://static001.geekbang.org/account/avatar/00/11/b1/81/ae0277f1.jpg","comment_is_top":false,"comment_ctime":1591168176,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591168176","product_id":100028001,"comment_content":"老师，请教一下，我从数据库查询一个大的数据集合，程序中需要处理业务操作，使用多线程合适吗？线程数大小多少合适？","like_count":0},{"had_liked":false,"id":213349,"user_name":"GaGi","can_delete":false,"product_type":"c1","uid":1099053,"ip_address":"","ucode":"CC8D22E1DD8CA2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c5/2d/1eebfc3c.jpg","comment_is_top":false,"comment_ctime":1588391218,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588391218","product_id":100028001,"comment_content":"二刷；<br>之前一直对上下文比较模糊，这篇文字很清晰的说明上下文存的是寄存器的存储内容和程序计数器的指令，可以通俗理解为执行当前线程的执行到哪一步，等待线程重新分配cpu时间片时，就会从中断点开始","like_count":0},{"had_liked":false,"id":166220,"user_name":"阿杜","can_delete":false,"product_type":"c1","uid":1066705,"ip_address":"","ucode":"349D3572F5ABE7","user_header":"https://static001.geekbang.org/account/avatar/00/10/46/d1/a1ddf49f.jpg","comment_is_top":false,"comment_ctime":1577417848,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577417848","product_id":100028001,"comment_content":"1.什么是上下文切换：一个线程切出，另一个线程切入。包括寄存器存储的内容和程序计数器存储的指令<br>2.什么情况导致cs：线程的切换或进程的切换<br>3.怎么减少cs：合理设置线程数，不是越多越好，单线程够用就用单线程。","like_count":0},{"had_liked":false,"id":142157,"user_name":"yintianwen","can_delete":false,"product_type":"c1","uid":1629418,"ip_address":"","ucode":"B29E9AB9D2F3B0","user_header":"https://static001.geekbang.org/account/avatar/00/18/dc/ea/9115f9bc.jpg","comment_is_top":false,"comment_ctime":1571301300,"is_pvip":false,"replies":[{"id":"55140","content":"是的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1571472353,"ip_address":"","comment_id":142157,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571301300","product_id":100028001,"comment_content":"请问老师，用户态到内核态的切换，都属于进程间的上下文切换吗？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471009,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571472353,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135079,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1569001250,"is_pvip":false,"replies":[{"id":"51864","content":"不会影响缓存，影响到的是系统的性能","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1569051833,"ip_address":"","comment_id":135079,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569001250","product_id":100028001,"comment_content":"老师，线程上下文切换是如何影响缓存的？不是很理解","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468036,"discussion_content":"不会影响缓存，影响到的是系统的性能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569051833,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115622,"user_name":"K","can_delete":false,"product_type":"c1","uid":1118374,"ip_address":"","ucode":"69831D1EFC083C","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/a6/4d2c933e.jpg","comment_is_top":false,"comment_ctime":1563677269,"is_pvip":false,"replies":[{"id":"43069","content":"因为获取mutex是内核来完成的，这里的进程上下文切换是指用户态和内核态的切换。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564104012,"ip_address":"","comment_id":115622,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563677269","product_id":100028001,"comment_content":"老师好，我看了下面老师对于进程上下文切换的解答，“当Synchronized锁资源竞争激烈，线程将会被阻塞，阻塞的线程将会从用户态调用内核态，尝试获取mutex，这个过程是Synchronized锁产生的进程上下文切换。”有点疑问就是：1.为什么阻塞的线程会从用户态调用内核态呢？想不到原因和这个过程。2.获取mutex就是进程上下文切换了吗？还是没明白为什么获取mutex就算进程切换了。谢谢老师帮忙答疑。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459196,"discussion_content":"因为获取mutex是内核来完成的，这里的进程上下文切换是指用户态和内核态的切换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564104012,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":112897,"user_name":"张德","can_delete":false,"product_type":"c1","uid":1101929,"ip_address":"","ucode":"31FE63E8725EFC","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/69/5dbdc245.jpg","comment_is_top":false,"comment_ctime":1562838788,"is_pvip":false,"replies":[{"id":"41166","content":"synchronized (this)+if()判断保证了counter不会超过一个亿","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562901720,"ip_address":"","comment_id":112897,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562838788","product_id":100028001,"comment_content":"老师讲一下  counter在多线程的情况下会不会超过一亿次呢？？   是如何保证线程安全的","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457948,"discussion_content":"synchronized (this)+if()判断保证了counter不会超过一个亿","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562901720,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":112889,"user_name":"张德","can_delete":false,"product_type":"c1","uid":1101929,"ip_address":"","ucode":"31FE63E8725EFC","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/69/5dbdc245.jpg","comment_is_top":false,"comment_ctime":1562838046,"is_pvip":false,"replies":[{"id":"41161","content":"increaseCounter方法在这里是线程安全的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562901095,"ip_address":"","comment_id":112889,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562838046","product_id":100028001,"comment_content":"&#47;&#47; 创建一个实现 Runnable 的类<br>              class MyRunnable implements Runnable {<br>                     public void run() {<br>                           while (counter &lt; 100000000) {<br>                                  synchronized (this) {<br>                                         if(counter &lt; 100000000) {<br>                                                increaseCounter();<br>                                         }<br>                                         <br>                                  }<br>                           }<br>                     }<br>              }<br>老师多线程这个类  共同引用了counter这个变量  他是线程安全的吗？  increaseCounter();是线程安全的吗？？？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457943,"discussion_content":"increaseCounter方法在这里是线程安全的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562901095,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":112118,"user_name":"任鹏斌","can_delete":false,"product_type":"c1","uid":1104086,"ip_address":"","ucode":"34319B05EA6E74","user_header":"https://static001.geekbang.org/account/avatar/00/10/d8/d6/47da34bf.jpg","comment_is_top":false,"comment_ctime":1562671529,"is_pvip":false,"replies":[{"id":"41142","content":"对的，这里描述的是系统线程状态。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562895721,"ip_address":"","comment_id":112118,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562671529","product_id":100028001,"comment_content":"老师有个问题这里线程的状态是指操作系统线程吗？记得java线程没有running状态的，有点乱了","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457584,"discussion_content":"对的，这里描述的是系统线程状态。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562895721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109008,"user_name":"K先生","can_delete":false,"product_type":"c1","uid":1145942,"ip_address":"","ucode":"D9D3ED28943334","user_header":"https://static001.geekbang.org/account/avatar/00/11/7c/56/c743bc9a.jpg","comment_is_top":false,"comment_ctime":1561947483,"is_pvip":false,"replies":[{"id":"39619","content":"需要结合具体业务来看。一般单个服务持续28万次，有点高了。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562035021,"ip_address":"","comment_id":109008,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561947483","product_id":100028001,"comment_content":"老师好，生产环境线程上下文切换次数一般都是28万次正常吗？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456207,"discussion_content":"需要结合具体业务来看。一般单个服务持续28万次，有点高了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562035021,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106810,"user_name":"Lost In The Echo。","can_delete":false,"product_type":"c1","uid":1211954,"ip_address":"","ucode":"6EC7BF57DA3A15","user_header":"https://static001.geekbang.org/account/avatar/00/12/7e/32/e569f729.jpg","comment_is_top":false,"comment_ctime":1561388764,"is_pvip":false,"replies":[{"id":"38838","content":"可以引入第三方框架支持，目前原生java暂时没有支持协程。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561516642,"ip_address":"","comment_id":106810,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1561388764","product_id":100028001,"comment_content":"java能支持协成吗？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455230,"discussion_content":"可以引入第三方框架支持，目前原生java暂时没有支持协程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561516642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1441546,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ff/0a/12faa44e.jpg","nickname":"晓杰","note":"","ucode":"1174C88EEBF8A6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":322,"discussion_content":"暂时不支持吧，但是我觉得这是目标","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561448286,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106519,"user_name":"夏天39度","can_delete":false,"product_type":"c1","uid":1104979,"ip_address":"","ucode":"A929B422255547","user_header":"https://static001.geekbang.org/account/avatar/00/10/dc/53/ccb62ea0.jpg","comment_is_top":false,"comment_ctime":1561338849,"is_pvip":false,"replies":[{"id":"38815","content":"Synchronized由自旋后升级为重量级锁，在存在多个线程竞争的情况下会发生上下文切换。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561513632,"ip_address":"","comment_id":106519,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561338849","product_id":100028001,"comment_content":"Synchronized由自旋锁升级为重量级锁时会发生上下文切换，获取锁之后，cpu不会在释放锁之前切走，老师，我理解的对吗？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455120,"discussion_content":"Synchronized由自旋后升级为重量级锁，在存在多个线程竞争的情况下会发生上下文切换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561513632,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106099,"user_name":"Lsoul","can_delete":false,"product_type":"c1","uid":1127019,"ip_address":"","ucode":"AADB10136AEE67","user_header":"https://static001.geekbang.org/account/avatar/00/11/32/6b/85e3d900.jpg","comment_is_top":false,"comment_ctime":1561173638,"is_pvip":false,"replies":[{"id":"38415","content":"文章是建议使用多线程处理。我理解你的意思应该是降低多线程数量吧，这是对的。适当的线程数量来处理cpu密集型计算场景，可以充分利用CPU（线程服务都是多核多个CPU）。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561254507,"ip_address":"","comment_id":106099,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561173638","product_id":100028001,"comment_content":"老师您好，文中最后提及”而在逻辑相对来说很复杂的场景，等待时间相对较长又或者是需要大量计算的场景，我建议使用多线程来提高系统的整体性能。”等同于io密集处理与cpu密集运算，而个人所理解的是cpu密集运算通常要降低多线程处理，与上文相悖。是否我理解错误。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454950,"discussion_content":"文章是建议使用多线程处理。我理解你的意思应该是降低多线程数量吧，这是对的。适当的线程数量来处理cpu密集型计算场景，可以充分利用CPU（线程服务都是多核多个CPU）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561254507,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106077,"user_name":"mickle","can_delete":false,"product_type":"c1","uid":1201493,"ip_address":"","ucode":"1F89608B5E06C7","user_header":"https://static001.geekbang.org/account/avatar/00/12/55/55/19ec7b0e.jpg","comment_is_top":false,"comment_ctime":1561167175,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561167175","product_id":100028001,"comment_content":"讲到工具的时候可否也顺便提一下工具的用法及需要关注的重要指标","like_count":0},{"had_liked":false,"id":106056,"user_name":"我知道了嗯","can_delete":false,"product_type":"c1","uid":1138471,"ip_address":"","ucode":"9186EC1F32C490","user_header":"https://static001.geekbang.org/account/avatar/00/11/5f/27/a6873bc9.jpg","comment_is_top":false,"comment_ctime":1561160501,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561160501","product_id":100028001,"comment_content":"NIO时期的读写操作用多线程，老师能否提供下示例代码，让我理解下","like_count":0}]}