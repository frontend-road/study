{"id":88275,"title":"期中答疑 | name(){}与name: function() {}，两种写法有什么区别吗？","content":"<p>你好，我是winter。</p><p>随着专栏进度过半，我们专栏的评论区留言量也日渐上涨。除了大家的小作业和学习心得，我还看见很多同学们在学习过程中提出了不少问题。</p><p>这其实是一种很好的学习方式，通过问题，我们可以对这部分知识记得更为牢固。</p><p>所以，我鼓励你在阅读文章之外，多思考，多提问，把自己不懂的地方暴露出来，及时查缺补漏，这样可以更好地吸收知识。同时，你也可以通过回答别人的问题来检验自己对知识的掌握情况。</p><p>我们一起来看看，大家都提出什么问题。</p><hr></hr><p><strong>1.老师你好！我语义化标签用得很少，多数用到的是header、footer、 nav等语义化标签，想问老师section和div混合使用，会不会效果不好呢？</strong></p><p>答：不会效果不好的，因为本来就是这么用的。遇到不确定的情况，请千万不要乱用标签，用div和span就好。</p><p><strong>2.我一直看见闭包这个词，但是一直也没有弄清楚它是什么东西，老师可以简单概括一下什么是闭包吗？</strong></p><p>答：你可以这样理解，闭包其实就是函数，还是能访问外面变量的函数。</p><p><strong>3.“事实上，JavaScript 中的“类”仅仅是运行时对象的一个私有属性，而 JavaScript 中是无法自定义类型的。”</strong></p><ul>\n<li><strong>文中说“类”是私有属性，可以具体表现是什么，不是很能理解具体含义？</strong></li>\n</ul><!-- [[[read_end]]] --><p>答：私有属性当然是你无法访问的属性了，但是具体表现的话，还是有的，那就是Object.prorotype.toString.call(x) 的行为。</p><ul>\n<li><strong>无法自定义类型？请问如下编码是属于什么操作，应该怎么理解这个“类”？</strong></li>\n</ul><pre><code>function Person（）｛｝\nvar person = new Person（）；\n</code></pre><p>答：这个代码是定义类的操作，这里注意一下，你千万不要把类和类型的概念混淆。</p><p><strong>4.请教老师在对象中<code>name(){}</code> 等同于<code>name: function() {}</code> ，这两个写法有什么区别呢？</strong></p><p>答：这两个写法在使用上基本没什么区别。只有一点区别，就是函数的name属性不一样。可以看下这段代码：</p><pre><code class=\"language-JavaScript\">var o = {\n   myfunc(){}\n}\nconsole.log(o.myfunc.name)\n</code></pre><p>我们这里按照你的第一种方法定义了方法，然后输出它的name属性，我们看到name属性是\"myfunc\"。</p><p>值得一提的是，如果我们给你的第二种方法添加了名字，行为还是不一样，区别在于能否在函数内用名字递归，我们看看代码：</p><pre><code class=\"language-JavaScript\">var o2 = {\n    myfunc(){\n        consoe.log(myfunc); //error\n    }\n}\nvar o1 = {\n    myfunc: function myfunc(){\n        consoe.log(myfunc); //function myfunc\n    }\n}\no1.myfunc();\no2.myfunc();\n</code></pre><p>这段代码中，我们试着在用两种方式定义的方法中输出函数自身的名字变量，结果是不一样的。</p><p>不过现实中，我们几乎不会关心函数的name属性，所以不用太在意两种定义方式的区别。</p><p><strong>5.我对于JavaScript中Number安全整数有个疑问。</strong></p><p><strong>MDN中是（-(2^53-1)~(2^53-1)）, 犀牛书中是（-2^53~2^53）感觉都有道理。</strong></p><p><strong>JavaScript中采用IEEE754浮点数标准进行存储， 1个符号位，11位指数位， 52位尾数位。</strong></p><p><strong>按照分析，不考虑符号位，尾数位取值52个1就是表示的最大值了，不会有精度损失，此时指数位代表数值是52+1023=1075，此时即为(-(2^53-1)~(2^53-1))。</strong></p><p><strong>但是2^53这个值，存储的时候尾数是52个0， 指数位为53+1023=1076，这个值也是刚好没有精度损失的，这时表示的就是（-2^53~2^53）。</strong></p><p><strong>用Math.isSafeInteger()判断安全数范围和MDN中描述一样。</strong><strong>所以被问到这个的时候， 感觉两个都是有道理的吧！老师你说对吗？</strong></p><p>答：你分析得非常好，我觉得我都没啥可补充的了。这个地方JavaScript标准写得也非常模糊，我简单瞄了一下，似乎是用实验的方式来给出的安全数范围。考虑到犀牛书的时效性肯定不如MDN，应该是参考了某一版本旧引擎给出来的数据。</p><p>所以，这类行为我们还是以实测为准吧，我们不必纠结。</p><p><strong>6.老师您好，下面这个自己练习的例子希望您能帮解答：</strong></p><pre><code>console.log('sync1');\n\nsetTimeout(function () {\n    console.log('setTimeout1')\n}, 0);\n\nvar promise = new Promise(function (resolve, reject) {\n    setTimeout(function () {\n        console.log('setTimeoutPromise')\n    }, 0);\n    console.log('promise');\n    resolve();\n});\n\n\npromise.then(() =&gt; {\n    console.log('pro_then');\n    setTimeout(() =&gt; {\n        console.log('pro_timeout');\n    }, 0)\n})\n\nsetTimeout(function () {\n    console.log('last_setTimeout')\n}, 0);\nconsole.log('sync2');\n</code></pre><p>答：这个例子挺经典的，虽然我觉得这样设计面试题非常不合适，但是我们可以以它为例，学习一下分析异步的方法。</p><p>首先我们看第一遍同步执行，这是第一个宏任务。</p><p>第一个宏任务中，调用了三次setTimeout（Promise中的代码也是同步执行的），调用了一次resolve，打印了三次。</p><p>所以它产生了三个宏任务，一个微任务，两次打印。</p><p>那么，首先显示的就是 sync1、promise 和 sync2。这时，setTimeout1，setTimeoutPromise，last_setTimeout在宏任务队列中，pro_then在微任务队列中。</p><p>接下来，因为微任务队列没空，第一个宏任务没有结束，继续执行微任务队列，所以pro_then，被显示出来，然后又调用了一次setTimeout，所以pro_timeout进入宏任务队列，成为第5个宏任务。</p><p>然后，没有微任务了，执行第二个宏任务，所以接下来顺次执行宏任务，显示setTimeout1，setTimeoutPromise，last_setTimeout，pro_timeout。</p><p>最终显示顺序是这样的。</p><ul>\n<li><strong>宏任务1</strong>\n<ul>\n<li>微任务1\n<ul>\n<li>sync 1</li>\n<li>promise</li>\n<li>sync 2</li>\n</ul>\n</li>\n<li>微任务2\n<ul>\n<li>pro_then</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>宏任务2</strong>\n<ul>\n<li>setTimeout1</li>\n</ul>\n</li>\n<li><strong>宏任务3</strong>\n<ul>\n<li>setTimeoutPromise</li>\n</ul>\n</li>\n<li><strong>宏任务4</strong>\n<ul>\n<li>last_setTimeout</li>\n</ul>\n</li>\n<li><strong>宏任务5</strong>\n<ul>\n<li>pro_timeout</li>\n</ul>\n</li>\n</ul><p><strong>7.为什么 promise.then中的settimeout是最后打印的？不用管是宏任务依次执行吗？</strong></p><p>答：因为then是第一个宏任务中最后执行的微任务，所以它发起的宏任务是最后入队的，依次执行就是最后。</p><p><strong>8.怎么确定这个微任务属于一个宏任务呢，JavaScript主线程跑下来，遇到setTImeout会放到异步队列宏任务中，那下面的遇到的promise怎么判断出它是属于这个宏任务呢？</strong></p><p>答：resolve在哪个宏任务中调用，对应的then里的微任务就属于哪个宏任务。宏任务没有从异步队列中取出，中间所碰到的所有微任务都属于这个宏任务。</p><p><strong>9.为什么要设计微任务（micro task），我知道这样JavaScript引擎可以自主地执行任务，但这样的好处是什么？提高性能吗？</strong></p><p>答：不是，微任务是JavaScript引擎内部的一种机制，如果不设计微任务，那么JavaScript引擎中就完全没有异步了呀，所以必须要设计微任务。</p><p><strong>10.现在浏览器多数实现是从右往左匹配的，那么无法保证选择器在 DOM 树构建到当前节点时，已经可以准确判断当前节点是否被选中。现在浏览器又是怎么实现在生成DOM树，同时进行CSS属性计算？</strong></p><p>答：其实现代浏览器已经为<code>:empty</code>、<code>:last</code>等伪元素写了很多例外了，不过你说的从右往左匹配，左边的要么是当前节点的父元素，要么是前置元素，所以是可以保证准确判断的呀。</p><p><strong>11.请问老师，页面资源的预加载是不是可以用link标签实现，还有其他的方式吗？</strong></p><p>答：预加载的方法就多啦，还可以用JavaScript代码预加载，甚至用本地存储缓存。</p><p><strong>12.老师，我有一个疑问：“词法环境”和“词法作用域”这两个概念的区别是什么？希望你能帮我解惑。</strong></p><p>答：词法环境是运行时概念，词法作用域是语言概念，就是说，作用域指的是变量生效的那段代码，而词法环境是指运行起来之后，你这段代码访问的存储变量的内存块。</p><p><strong>13.想问一个问题：import 进来的引用为什么可以获取到最新的值，是类似于 getter 的机制吗?</strong></p><p>答：这个地方略微有些复杂，我们在运行时并没有讲import的运行时机制，这里涉及了一个叫做ImportEntry Record的机制，它比getter的实现更底层。</p><p>我想这个地方我们没有必要去深究模块的运行时机制，它很复杂而且并不是经常要用到。你如果想了解的话，可以查阅一下。</p><p><strong>14.请问老师，JavaScript 的call stack size是多少，这个size的单位是啥，是调用栈中函数的个数，还是一个存储单位，比如MB之类的。如果调用栈中就一个函数，这个函数的参数有100万个，浏览器端依然会溢出，看起来是存储单位，但是没得到验证。</strong></p><p>答：这个似乎并没有什么特别规定，我知道JSC里面这个东西是可以用C++代码来调整的，至于浏览器调用JavaScript引擎的时候会怎么做，还真不好说。</p><p>不过，从编码风格上建议，不要把这种事情用函数解决啦，真要干这样的事，数组可能都不合适了，请老老实实写ArrayBuffer吧。</p><p><strong>15.老师您好，我一直有一个困惑，浏览器的鼠标事件是怎么识别到的，是碰撞检测的吗？</strong></p><p>答：这个问题很不错，我后面在浏览器API的事件部分会详细讲，可以先简单说一下，这里的检测方式是从外到内，逐级分配给子元素，所以我们的事件会有捕获过程。</p><p><strong>16.有个问题，如果我javaScript代码改变了DOM树元素的位置，需要启动重新排版（位置改变的元素只会影响其他部分元素的位置，甚至不影响其他元素的位置。），这时会导致这棵DOM树的所有元素都需要重新排版、绘制和渲染吗？</strong></p><p>答：排版应该是会重新排的，但是如果有些元素的尺寸没有改变，那么它内部不需要重排，当然也就更不需要重新渲染了，但是绘制应该是要重绘的，目前来看，浏览器还没有那么智能。</p><p><strong>17.老师，我是12年左右踏进半只脚到前端领域的，后来考研就放弃了，觉得前端不够高深，和传统工程师来说觉得门槛低很多，甚至前期我都觉得自己不是个程序员。</strong></p><p><strong>直到研究生毕业，才又选择前端，这是三大框架风靡，我却有点迷惘，感觉和自己认知的前端不一样，直到现在工作了差不多两年，才悟出了点道道。</strong></p><p><strong>作为工程师，我始终觉得前端也应该熟练算法和数据结构、数据库这些所谓的后端知识，但是平时工作场景中用到又少，不知如何学习？</strong></p><p>答：算法和数据结构可不是什么后端知识呀，是所有程序员的基本技能。</p><p>算法主要是靠大量练习提高，数据结构可以一个一个学习，不要指望工作中用到恰巧就学了，毕竟学习要教学费而工作是领工资的，哪里会有这样的好事呢，所以还是自己多多练习呀。</p><p><strong>18.重学前端是夯实前端基础，那前端进阶方向在哪里?还是一定要修一门后端语言扩展服务端，希望老师可以指点迷津。</strong></p><p>答：我觉得任何编程相关岗位的进阶方式都是做出某某东西，而不是学会某某东西。我会在专栏课程的第四模块会讲到一些进阶可能的方向，你可以关注一下。</p><p><strong>19.我主业是后端，工作中也会带着做前端，自认还是能完美还原设计师的设计。但是现在感觉很多时候提前端就是vue等，而我还是在用jQuery，想请老师说说看，我是不是落伍了？</strong></p><p>答：落伍的问题不是你用什么框架，而是你在做什么东西，学什么东西。</p><p>框架不是赶时髦，追潮流，每个框架都有解决的问题，我觉得你该焦虑的不是你用的框架为什么这么老，而是你该知道这些新框架要解决什么问题，以及这些问题为什么在你的工作中不存在。</p><p><strong>最后，我们来看看我在JavaScript类型那一篇中给你留的实践问题。</strong></p><p><strong>如果我们不用原生的Number和parselnt，用JavaScript代码实践String到Number，该怎么做呢？</strong></p><p>答：其实这个问题我在后台没看到特别满意的答案，好像大家都很喜欢偷懒啊。</p><p>我这里给你留个例子，处理十进制整数。</p><pre><code>function atoi(a){\n    let chars = a.split(&quot;&quot;).map(e =&gt; e.charCodeAt(0) - &quot;0&quot;.charCodeAt(0));\n    let n = 0;\n    for(var char of chars) {\n        n *= 10;\n    \tn += char;\n    }\n    return n;\n}\natoi(&quot;1001&quot;)\n</code></pre><p>我比较期待大家有人能写出来带小数，甚至带科学计数法的代码，你可以尝试一下。</p><p>好了，今天的答疑环节就进行到这里，你也可以把自己想要解答的问题留言。</p><p></p>","comments":[{"had_liked":false,"id":82937,"user_name":"Geeker1992","can_delete":false,"product_type":"c1","uid":1003475,"ip_address":"","ucode":"459F3CEB0491A1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4f/d3/897fc6df.jpg","comment_is_top":false,"comment_ctime":1554352176,"is_pvip":false,"replies":[{"id":"30364","content":"对的","user_name":"作者回复","user_name_real":"winter","uid":"1268524","ctime":1554805154,"ip_address":"","comment_id":82937,"utype":1}],"discussion_count":1,"race_medal":0,"score":"169058076720","product_id":100023201,"comment_content":"我知道答案了。在 promise 出现之前，javascript 并没有异步，有异步的是宿主环境。","like_count":40,"discussions":[{"author":{"id":1268524,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5b/2c/12bfd3cd.jpg","nickname":"winter","note":"","ucode":"2B068EDEAFEB56","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445786,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554805154,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82574,"user_name":"Geeker1992","can_delete":false,"product_type":"c1","uid":1003475,"ip_address":"","ucode":"459F3CEB0491A1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4f/d3/897fc6df.jpg","comment_is_top":false,"comment_ctime":1554253313,"is_pvip":false,"replies":[{"id":"30368","content":"因为那是宿主的东西呀，不在JS引擎里","user_name":"作者回复","user_name_real":"winter","uid":"1268524","ctime":1554805405,"ip_address":"","comment_id":82574,"utype":1}],"discussion_count":1,"race_medal":0,"score":"40208958977","product_id":100023201,"comment_content":"老师，为什么说没有了微任务就没有了异步？不是还有 setTimeout 的吗？","like_count":10,"discussions":[{"author":{"id":1268524,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5b/2c/12bfd3cd.jpg","nickname":"winter","note":"","ucode":"2B068EDEAFEB56","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445645,"discussion_content":"因为那是宿主的东西呀，不在JS引擎里","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554805405,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81425,"user_name":"阿成","can_delete":false,"product_type":"c1","uid":1390032,"ip_address":"","ucode":"CEC3CD65FB9333","user_header":"https://static001.geekbang.org/account/avatar/00/15/35/d0/f2ac6d91.jpg","comment_is_top":false,"comment_ctime":1553912174,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31618683246","product_id":100023201,"comment_content":"&#47;**<br> * @param {string} str<br> *&#47;<br>function str2num (str) {<br>  const [m, e = &#39;&#39;] = str.split(&#39;e&#39;)<br>  const [i, f = &#39;&#39;] = m.split(&#39;.&#39;)<br>  let result = 0<br>  &#47;&#47; handle int<br>  let sign = 1<br>  for (let x of i) {<br>    if (x === &#39;+&#39;) {<br>      continue<br>    } else if (x === &#39;-&#39;) {<br>      sign *= -1<br>      continue<br>    } else {<br>      result *= 10<br>      result += c2n(x)<br>    }<br>  }<br><br>  &#47;&#47; handle fraction<br>  if (f) {<br>    result += str2num(f) &#47; (10 ** f.length)<br>  }<br><br>  &#47;&#47; handle exponent<br>  if (e) {<br>    let exponent<br>    let sign = 1<br>    if (e[0] === &#39;-&#39;) {<br>      sign = -1<br>      exponent = str2num(e.slice(1))<br>    } else if (e[0] === &#39;+&#39;) {<br>      exponent = str2num(e.slice(1))<br>    } else {<br>      exponent = str2num(e)<br>    }<br>    if (sign === -1) {<br>      result &#47;= 10 ** exponent<br>    } else {<br>      result *= 10 ** exponent<br>    }<br>  }<br><br>  &#47;&#47; handle sign<br>  result *= sign<br>  return result<br>}<br><br>function c2n (char) {<br>  const n = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9][char]<br>  if (n == null) throw new Error(`unknown char: &quot;${char}&quot;`)<br>  return n<br>}<br><br>function assert (input) {<br>  let output = str2num(input)<br>  let expect = Number(input)<br>  if (output !== expect) {<br>    throw new Error(`input ${input}, got ${output}, while expect ${expect}`)<br>  }<br>}<br><br>void function test () {<br>  assert(&#39;13.4e-7&#39;)<br>  assert(&#39;.4e+7&#39;)<br>  assert(&#39;-.2e+1&#39;)<br>  assert(&#39;+.6e+0&#39;)<br>  assert(&#39;0&#39;)<br>  assert(&#39;-0e-0&#39;)<br>  assert(&#39;0e0&#39;)<br>  assert(&#39;123&#39;)<br>  assert(&#39;2e1&#39;)<br>  assert(&#39;2e-0&#39;)<br>  assert(&#39;.1&#39;)<br>  console.log(&#39;All right.&#39;)<br>}()<br>","like_count":8},{"had_liked":false,"id":82609,"user_name":"自由之翼","can_delete":false,"product_type":"c1","uid":1379130,"ip_address":"","ucode":"49B21C675F211A","user_header":"https://static001.geekbang.org/account/avatar/00/15/0b/3a/26708d86.jpg","comment_is_top":false,"comment_ctime":1554258653,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10144193245","product_id":100023201,"comment_content":"一般都是缓存 数据 吧 ,个人感觉 缓存 js css 纯属没事儿找事儿.","like_count":3,"discussions":[{"author":{"id":1231077,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c8/e5/72166149.jpg","nickname":"Wal-le","note":"","ucode":"E5CC6447DAB7D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330246,"discussion_content":"可以提升下次的访问加载速度呀。不过如果不用浏览器缓存机制，自己去缓存的话，感觉是有一点没事找事。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606549832,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81961,"user_name":"Geek_c43534","can_delete":false,"product_type":"c1","uid":1380501,"ip_address":"","ucode":"3393CA616CC968","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKzwpgrdbZlSb30EaOZ37lDlBDjEjHMOpjbK1pPlY4hyFctE8GsicibUuyAB8pzx8F3Ne7Ymzkn2cSQ/132","comment_is_top":false,"comment_ctime":1554089299,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5849056595","product_id":100023201,"comment_content":"老师，jquery ajax 同步请求的原理是?目前用axios库，不支持同步请求，如果希望执行同步请求有什么解决办法？","like_count":2,"discussions":[{"author":{"id":2820671,"avatar":"","nickname":"require","note":"","ucode":"3AA3DCE0CD73E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538944,"discussion_content":"promise包一下，然后搭配async await","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639561428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1042089,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e6/a9/b459efb7.jpg","nickname":"如故","note":"","ucode":"F6895792309942","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342537,"discussion_content":"同步请求会使页面无法操作吧 如果请求时间很长 体验太差 可以用promise模拟啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610706704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81437,"user_name":"weineel","can_delete":false,"product_type":"c1","uid":1049741,"ip_address":"","ucode":"6DC6EF4F256A53","user_header":"https://static001.geekbang.org/account/avatar/00/10/04/8d/005c2ff3.jpg","comment_is_top":false,"comment_ctime":1553913846,"is_pvip":true,"discussion_count":2,"race_medal":2,"score":"5848881142","product_id":100023201,"comment_content":"老师您好，把JS代码缓存在 localStorage 中，从 localStorage 取出后怎么执行？ 如果缓存的是 css 呢？","like_count":2,"discussions":[{"author":{"id":1231077,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c8/e5/72166149.jpg","nickname":"Wal-le","note":"","ucode":"E5CC6447DAB7D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330247,"discussion_content":"js可以用eval，css不是很清楚。不过还是建议通过headers里的expires等来控制浏览器缓存。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606549941,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1446465,"avatar":"https://static001.geekbang.org/account/avatar/00/16/12/41/c877c1fd.jpg","nickname":"Yoonthe","note":"","ucode":"DAC9989358CB81","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":141358,"discussion_content":"直接把代码写入一个新script标签就好了，但是这个问题说明你没有把浏览器的页面加载逻辑好好融会贯通啊，💪","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579415415,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81435,"user_name":"阿成","can_delete":false,"product_type":"c1","uid":1390032,"ip_address":"","ucode":"CEC3CD65FB9333","user_header":"https://static001.geekbang.org/account/avatar/00/15/35/d0/f2ac6d91.jpg","comment_is_top":false,"comment_ctime":1553913573,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5848880869","product_id":100023201,"comment_content":"写的过程中遇到了个精度问题：<br>比如13.4e-7，一开始我的结果是0.0000013399999999999999，然后我把乘法改成了对应的除法，就可以了。这说明JS引擎对除法的处理不是简单的乘以相应的倒数，具体的机制不知道 winter 老师能不能给个解释。","like_count":1},{"had_liked":false,"id":216503,"user_name":"EmilyLucky","can_delete":false,"product_type":"c1","uid":1972343,"ip_address":"","ucode":"DBA5FE296CF473","user_header":"https://static001.geekbang.org/account/avatar/00/1e/18/77/d665f258.jpg","comment_is_top":false,"comment_ctime":1589272943,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589272943","product_id":100023201,"comment_content":"好像对异步任务的分类又多了一点理解。异步中任务分为宏任务和微任务，微任务是后来出现的，它其实是JS引擎内部的机制，而宏任务是宿主环境下的异步。老师，这么理解对吗？那么设计微任务的初衷仅仅就是为了让JS引擎内部有异步么？","like_count":1},{"had_liked":false,"id":181782,"user_name":"momo","can_delete":false,"product_type":"c1","uid":1711813,"ip_address":"","ucode":"EBC2C886E5A222","user_header":"https://static001.geekbang.org/account/avatar/00/1a/1e/c5/4e640126.jpg","comment_is_top":false,"comment_ctime":1582634038,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582634038","product_id":100023201,"comment_content":"那个函数使用，o.func()和a=o.func这俩，如果函数内部使用了this，还是会有差别的，不过，一般不会有人用a=o.func这种方式的吧…","like_count":0},{"had_liked":false,"id":177982,"user_name":"blueBean","can_delete":false,"product_type":"c1","uid":1816697,"ip_address":"","ucode":"6A68D2414BD904","user_header":"https://static001.geekbang.org/account/avatar/00/1b/b8/79/a4dbe9ee.jpg","comment_is_top":false,"comment_ctime":1581565681,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1581565681","product_id":100023201,"comment_content":"请问类和类型有什么区别呢","like_count":0,"discussions":[{"author":{"id":2820671,"avatar":"","nickname":"require","note":"","ucode":"3AA3DCE0CD73E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538945,"discussion_content":"应该是雷锋和雷峰塔的区别吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639561511,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104125,"user_name":"洛小贼","can_delete":false,"product_type":"c1","uid":1002422,"ip_address":"","ucode":"07CD2BDADEE05A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4b/b6/ec4301b5.jpg","comment_is_top":false,"comment_ctime":1560658711,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560658711","product_id":100023201,"comment_content":"请问第4个问题产生这种差异是否是因为o1用了闭包所以可以访问自己，o2没有用闭包所以不能访问它自身？","like_count":0},{"had_liked":false,"id":98221,"user_name":"哈哈","can_delete":false,"product_type":"c1","uid":1539619,"ip_address":"","ucode":"759FDB5F92B521","user_header":"","comment_is_top":false,"comment_ctime":1558936146,"is_pvip":false,"replies":[{"id":"58960","content":"你自己传参数了啊亲……参数和变量在同一环境里面的","user_name":"作者回复","user_name_real":"winter","uid":"1268524","ctime":1574227455,"ip_address":"","comment_id":98221,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1558936146","product_id":100023201,"comment_content":"function foo(a) {<br>    var a;<br>    return a;<br>}<br>function bar(a) {<br>    var a = &#39;bye&#39;;<br>    return a;<br>}<br>[foo(&#39;hello&#39;), bar(&#39;hello&#39;)]&#47;&#47;输出结果为：hello，bye<br>两个函数内部的 return a; 根据作用域链寻找都是返回函数作用域的 a 吧。<br>第二个输出我可以理解，可是第一个的输出结果是 hello ，<br>第一个函数的a 不是undefined 吗？","like_count":0,"discussions":[{"author":{"id":1268524,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5b/2c/12bfd3cd.jpg","nickname":"winter","note":"","ucode":"2B068EDEAFEB56","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451605,"discussion_content":"你自己传参数了啊亲……参数和变量在同一环境里面的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574227455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1622719,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c2/bf/8ea0cf63.jpg","nickname":"前端路上的小学生","note":"","ucode":"90A9B6DA3EF5F8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302929,"discussion_content":"函数内有个参数a，这一步做的事情就是在这个函数内声明一个变量，然后你又执行声明，其实做了一次无用功，所以你第一个函数内接收了hello，下面的操作不会覆盖啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599090679,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":86319,"user_name":"veath","can_delete":false,"product_type":"c1","uid":1382940,"ip_address":"","ucode":"30C91B055D6813","user_header":"https://static001.geekbang.org/account/avatar/00/15/1a/1c/2898f78f.jpg","comment_is_top":false,"comment_ctime":1555347781,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555347781","product_id":100023201,"comment_content":"请问下，link preload 解析执行时机和构建 CSSOM一样吗---html从上往下解析到link preload才会解析执行？还是说并行解析html 和preload","like_count":0},{"had_liked":false,"id":82146,"user_name":"xiaolu289","can_delete":false,"product_type":"c1","uid":1386541,"ip_address":"","ucode":"C0A1F710AE381C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/pic1ibj7XibmJrGmiaiceVVAUEVQ1g9bmxsicy2FaCOIffpYicflUs8iaULPmw5yopN7ltbjbI1TCF0OovC1alssX6cAaA/132","comment_is_top":false,"comment_ctime":1554130667,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554130667","product_id":100023201,"comment_content":"js如果取出来是字符串，目前我想到一个方案是用eval去执行，不过感觉直接用localstrage存储js代码这种操作可能会有安全问题，毕竟locastrage在浏览器是随便我怎么改都行的....<br>css的话，直接插一个style不就好了嘛....js其实也可以插一个script....所以具体什么场景采用什么方案，还得根据业务场景来决定<br><br>不知道我理解得是否正确..","like_count":1},{"had_liked":false,"id":82067,"user_name":"Daniel","can_delete":false,"product_type":"c1","uid":1160798,"ip_address":"","ucode":"7A98D9FA363968","user_header":"https://static001.geekbang.org/account/avatar/00/11/b6/5e/a7660b26.jpg","comment_is_top":false,"comment_ctime":1554113487,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554113487","product_id":100023201,"comment_content":"老师您好，请教你个问题。 link与script都可以引用js代码，这两者的区别是什么呢？","like_count":0},{"had_liked":false,"id":81414,"user_name":"杨学茂","can_delete":false,"product_type":"c1","uid":1377459,"ip_address":"","ucode":"C12DAA295CC945","user_header":"https://static001.geekbang.org/account/avatar/00/15/04/b3/3f0b69f9.jpg","comment_is_top":false,"comment_ctime":1553908191,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553908191","product_id":100023201,"comment_content":"请问：var,let 和 const 在 babel 中都会被编译为 var, 那怎么区分 const 是常量呢？","like_count":0},{"had_liked":false,"id":81410,"user_name":"Jy","can_delete":false,"product_type":"c1","uid":1027312,"ip_address":"","ucode":"B8D9382C1503E2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ac/f0/5d52d73e.jpg","comment_is_top":false,"comment_ctime":1553906938,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1553906938","product_id":100023201,"comment_content":"name()和name: function，本质上前面的是Method，后面是函数属性。<br>具体的差异不大，有个小栗子: 在name: function中使用super会报错，而name()不会。","like_count":1}]}