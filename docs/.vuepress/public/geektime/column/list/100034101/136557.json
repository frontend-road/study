{"id":136557,"title":"15 | 前端技术应用（二）：如何设计一个报表工具？","content":"<p>众所周知，很多软件都需要面向开发者甚至最终用户提供自定义功能，在<a href=\"https://time.geekbang.org/column/article/118016\">开篇词</a>里，我提到自己曾经做过工作流软件和电子表单软件，它们都需要提供自定义功能，报表软件也是其中的典型代表。</p><p>在每个应用系统中，我们对数据的处理大致会分成两类：一类是在线交易，叫做OLTP，比如在网上下订单；一类是在线分析，叫做OLAP，它是对应用中积累的数据进行进一步分析利用。而报表工具就是最简单，但也是最常用的数据分析和利用的工具。</p><p>本节课，我们就来分析一下，如果我们要做一个通用的报表工具，需要用到哪些编译技术，又该怎样去实现。</p><h2>报表工具所需要的编译技术</h2><p>如果要做一个报表软件，我们要想清楚软件面对的用户是谁。有一类报表工具面向的用户是程序员，那么这种软件可以暴露更多技术细节。比如，如果报表要从数据库获取数据，你可以写一个SQL语句作为数据源。</p><p>还有一类软件是给业务级的用户使用的，很多BI软件包都是这种类型。带有IT背景的顾问给用户做一些基础配置，然后用户就可以用这个软件包了。Excel可以看做是这种报表工具，IT人员建立Excel与数据库之间的连接，剩下的就是业务人员自己去操作了。</p><p>这些业务人员可以采用一个图形化的界面设计报表，对数据进行加工处理。我们来看看几个场景。</p><!-- [[[read_end]]] --><p><strong>第一个场景是计算字段。</strong>计算字段的意思是，原始数据里没有这个数据，我们需要基于原始数据，通过一个自定义的公式来把它计算出来。比如在某个CRM系统中保存着销售数据，我们有每个部门的总销售额，也有每个部门的人数，要想在报表中展示每个部门的人均销售额，这个时候就可以用到计算公式功能，计算公式如下：</p><pre><code>人均销售额=部门销售额/部门人数\n</code></pre><p>得到的结果如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/f6/b8/f6abaebc36fc515e8cf1dd7ec3b5cdb8.jpg?wh=1142*553\" alt=\"\"></p><p><strong>进一步，我们可以在计算字段中支持函数。</strong>比如我们可以把各个部门按照人均销售额排名次。这可以用一个函数来计算：</p><pre><code>=rank(人均销售额)\n</code></pre><p>rank就是排名次的意思，其他统计函数还包括：</p><ul>\n<li>min()，求最小值。</li>\n<li>max()，求最大值。</li>\n<li>avg()，求平均值。</li>\n<li>sum()，求和。</li>\n</ul><p>还有一些更有意思的函数，比如：</p><ul>\n<li>runningsum()，累计汇总值。</li>\n<li>runningavg()，累计平均值。</li>\n</ul><p>这些有意思的函数是什么意思呢？因为很多明细性的报表，都是逐行显示的，累计汇总值和累计平均值，就是累计到当前行的计算结果。当然了，我们还可以支持更多的函数，比如当前日期、当前页数等等。更有意思的是，上述字段也好、函数也好，都可以用来组合成计算字段的公式，比如：</p><pre><code>=部门销售额/sum(部门销售额)   //本部门的销售额在全部销售额的占比\n=max(部门销售额)-部门销售额   //本部门的销售额与最高部门的差距\n=max(部门销售额/部门人数)-部门销售额/部门人数   //本部门人均销售额与最高的那个部门的差\n=sum(部门销售额)/sum(人数)-部门销售额/部门人数  //本部门的人均销售额与全公司人均销售额的差\n</code></pre><p>怎么样，是不是越来越有意思了呢？现在你已经知道了在报表中会用到普通字段和各种各样的计算公式，那么，我们如何用这样的字段和公式来定义一张报表呢？</p><h2>如何设计报表</h2><p>假设我们的报表是一行一行地展现数据，也就是最简单的那种。那我们将报表的定义做成一个XML文件，可能是下面这样的，它定义了表格中每一列的标题和所采用字段或公式：</p><pre><code>&lt;playreport title=&quot;Report 1&quot;&gt;\n    &lt;section&gt;\n        &lt;column&gt;\n            &lt;title&gt;部门&lt;/title&gt;\n            &lt;field&gt;dept&lt;/field&gt;\n        &lt;/column&gt;\n        &lt;column&gt;\n            &lt;title&gt;人数&lt;/title&gt;\n            &lt;field&gt;num_person&lt;/field&gt;\n        &lt;/column&gt;\n        &lt;column&gt;\n            &lt;title&gt;销售额&lt;/title&gt;\n            &lt;field&gt;sales_amount&lt;/field&gt;\n        &lt;/column&gt;\n        &lt;column&gt;\n            &lt;title&gt;人均销售额&lt;/title&gt;\n            &lt;field&gt;sales_amount/num_person&lt;/field&gt;\n        &lt;/column&gt;\n    &lt;/section&gt;\n    &lt;datasource&gt;\n        &lt;connection&gt;数据库连接信息...&lt;/connection&gt;\n        &lt;sql&gt;select dept, num_person, sales_amount from sales&lt;/sql&gt;\n    &lt;/datasource&gt;\n&lt;/playreport&gt;\n</code></pre><p>这个报表定义文件还是蛮简单的，它主要表达的是数据逻辑，忽略了表现层的信息。如果我们想要优先表达表现层的信息，例如字体大小、界面布局等，可以采用HTML模板的方式来定义报表，其实就是在一个HTML中嵌入了公式，比如：</p><pre><code>&lt;html&gt;\n&lt;body&gt;\n    &lt;div class=&quot;report&quot; datasource=&quot;这里放入数据源信息&quot;&gt;\n        &lt;div class=&quot;table_header&quot;&gt;\n            &lt;div class=&quot;column_header&quot;&gt;部门&lt;/div&gt;\n            &lt;div class=&quot;column_header&quot;&gt;人数&lt;/div&gt;\n            &lt;div class=&quot;column_header&quot;&gt;销售额&lt;/div&gt;\n            &lt;div class=&quot;column_header&quot;&gt;人均销售额&lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;table_body&quot;&gt;\n            &lt;div class=&quot;field&quot;&gt;{=dept}&lt;/div&gt;\n            &lt;div class=&quot;field&quot;&gt;{=num_person}&lt;/div&gt;\n            &lt;div class=&quot;field&quot;&gt;{=sales_amount}&lt;/div&gt;\n            &lt;div class=&quot;field&quot;&gt;{=sales_amount/num_person}&lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>这样的HTML模板看上去是不是很熟悉？其实在很多语言里，比如PHP，都提供模板引擎功能，实现界面设计和应用代码的分离。这样一个模板，可以直接解释执行，或者先翻译成PHP或Java代码，然后再执行。只要运用我们学到的编译技术，这些都可以实现。</p><p>我想你应该会发现，这样的一个模板文件，其实就是一个特定领域语言，也就是我们常说的DSL。DSL可以屏蔽掉实现细节，让我们专注于领域问题，像上面这样的DSL，哪怕没有技术背景的工作人员，也可以迅速地编写出来。</p><p>而这个简单的报表，在报表设计界面上可能是下图这样的形式：</p><p><img src=\"https://static001.geekbang.org/resource/image/59/fe/59f1162ec7a1e76f0cb20457db34adfe.jpg?wh=1142*190\" alt=\"\"></p><p>分析完如何设计报表之后，接下来，我们看看如何定义报表所需要的公式规则。</p><h2>编写所需要的语法规则</h2><p>我们设计了PlayReport.g4规则文件，这里面的很多规则，是把PlayScript.g4里的规则拿过来改一改用的：</p><pre><code>bracedExpression\n    : '{' '=' expression '}'\n    ;\n\nexpression\n    : primary\n    | functionCall\n    | expression bop=('*'|'/'|'%') expression  \n    | expression bop=('+'|'-') expression \n    | expression bop=('&lt;=' | '&gt;=' | '&gt;' | '&lt;') expression\n    | expression bop=('==' | '!=') expression\n    | expression bop='&amp;&amp;' expression\n    | expression bop='||' expression\n    ;\n\nprimary\n    : '(' expression ')'\n    | literal\n    | IDENTIFIER\n    ;\n\nexpressionList\n    : expression (',' expression)*\n    ;\n\nfunctionCall\n    : IDENTIFIER '(' expressionList? ')'\n    ;\n\nliteral\n    : integerLiteral\n    | floatLiteral\n    | CHAR_LITERAL\n    | STRING_LITERAL\n    | BOOL_LITERAL\n    | NULL_LITERAL\n    ;\n\nintegerLiteral\n    : DECIMAL_LITERAL\n    | HEX_LITERAL\n    | OCT_LITERAL\n    | BINARY_LITERAL\n    ;\n\nfloatLiteral\n    : FLOAT_LITERAL\n    | HEX_FLOAT_LITERAL\n    ;\n</code></pre><p>这里面，其实就是用了表达式的语法，包括支持加减乘除等各种运算，用来书写公式。我们还特意支持functionCall功能，也就是能够调用函数。因为我们内部实现了很多内置函数，比如求最大值、平均值等，可以在公式里调用这些函数。</p><p>现在呢，我们已经做好了一个最简单的报表定义，接下来，就一起实现一个简单的报表引擎，这样就能实际生成报表了！</p><h2>实现一个简单的报表引擎</h2><p>报表引擎的工作，是要根据报表的定义和数据源中的数据，生成最后报表的呈现格式。具体来说，可以分为以下几步：</p><ul>\n<li><strong>解析报表的定义。</strong>我们首先要把报表定义形成Java对象。这里只是简单地生成了一个测试用的报表模板。</li>\n<li><strong>从数据源获取数据。</strong>我们设计了一个TabularData类，用来保存类似数据库表那样的数据。</li>\n<li><strong>实现一个FieldEvaluator类，能够在运行时对字段和公式进行计算。</strong>这个类是playscript中ASTEvaluator类的简化版。我们甚至连语义分析都简化了。数据类型信息作为S属性，在求值的同时自底向上地进行类型推导。当然，如果做的完善一点儿，我们还需要多做一点儿语义分析，比如公式里的字段是不是数据源中能够提供的？而这时需要用到报表数据的元数据。</li>\n<li><strong>渲染报表。</strong>我们要把上面几个功能组合在一起，对每一行、每一列求值，获得最后的报表输出。</li>\n</ul><p>主控程序我放在了下面，用一个示例报表模板和报表数据来生成报表：</p><pre><code>public static void main(String args[]) {\n    System.out.println(&quot;Play Report!&quot;);\n\n    PlayReport report = new PlayReport();\n\n    //打印报表1\n    String reportString = report.renderReport(ReportTemplate.sampleReport1(), TabularData.sampleData());\n    System.out.println(reportString);\n}\n</code></pre><p>renderReport方法用来渲染报表，它会调用解析器和报表数据的计算器：</p><pre><code>public String renderReport(ReportTemplate template, TabularData data){\n    StringBuffer sb = new StringBuffer();\n    \n    //输出表格头\n    for (String columnHeader: template.columnHeaders){\n        sb.append(columnHeader).append('\\t');\n    }\n    sb.append(&quot;\\n&quot;);\n\n    //编译报表的每个字段\n    List&lt;BracedExpressionContext&gt; fieldASTs = new LinkedList&lt;BracedExpressionContext&gt;();\n    for (String fieldExpr : template.fields){\n        //这里会调用解析器\n        BracedExpressionContext tree = parse(fieldExpr);\n        fieldASTs.add(tree);\n    }\n\n    //计算报表字段\n    FieldEvaluator evaluator = new FieldEvaluator(data);\n    List&lt;String&gt; fieldNames = new LinkedList&lt;String&gt;();\n    for (BracedExpressionContext fieldAST: fieldASTs){\n        String fieldName = fieldAST.expression().getText();\n        fieldNames.add(fieldName);\n        if (!data.hasField(fieldName)){\n            Object field = evaluator.visit(fieldAST);\n            data.setField(fieldName, field);\n        }\n    }\n\n    //显示每一行数据\n    for (int row = 0; row&lt; data.getNumRows(); row++){\n        for (String fieldName: fieldNames){\n            Object value = data.getFieldValue(fieldName, row);\n            sb.append(value).append(&quot;\\t&quot;);\n        }\n        sb.append(&quot;\\n&quot;);\n    }\n\n    return sb.toString();\n}\n</code></pre><p>程序的运行结果如下，它首先打印输出了每个公式的解析结果，然后输出报表：</p><pre><code>Play Report!\n(bracedExpression { = (expression (primary dept)) })\n(bracedExpression { = (expression (primary num_person)) })\n(bracedExpression { = (expression (primary sales_amount)) })\n(bracedExpression { = (expression (expression (primary sales_amount)) / (expression (primary num_person))) })\n部门      \t人数\t销售额\t人均销售额\n电话销售部\t10\t2345.0\t234.5\n现场销售部\t20\t5860.0\t293.0\n电子商务部\t15\t3045.0\t203.0\n渠道销售部\t20\t5500.0\t275.0\n微商销售部\t12\t3624.0\t302.0\n</code></pre><p>你可以看到，报表工具准确地得出了计算字段的数据。接下来，我再讲一讲报表数据计算的细节。</p><p>如果你看一看FieldEvaluator.java这个类，就会发现我实际上实现了一个简单的向量数据的计算器。在计算机科学里，向量是数据的有序列表，可以看做一个数组。相对应的，标量只是一个单独的数据。运用向量计算，我们在计算人均销售额的时候，会把“销售额”和“人数”作为两个向量，每个向量都有5个数据。把这两个向量相除，会得到第三个向量，就是“人均销售额”。这样就不需要为每行数据运行一次计算器，会提高性能，也会简化程序。</p><p>其实，这个向量计算器还能够把向量和标量做混合运算。因为我们的报表里有时候确实会用到标量，比如对销售额求最大值{=max(sales_amount)}，就是一个标量。而如果计算销售额与最大销售额的差距{=max(sales_amount)-sales_amount}，就是标量和向量的混合运算，返回结果是一个向量。</p><p>TabularData.java这个类是用来做报表数据的存储的。我简单地用了一个Map，把字段的名称对应到一个向量或标量上，其中字段的名称可以是公式：</p><p><img src=\"https://static001.geekbang.org/resource/image/8a/d0/8a8d4640fa0b9e4e5db147952bd33ad0.jpg?wh=1142*579\" alt=\"\"></p><p>在报表数据计算过程中，我们还做了一个优化。公式计算的中间结果会被存起来，如果下一个公式刚好用到这个数据，可以复用。比如，在计算rank(sales_amount/num_person)这个公式的时候，它会查一下括号中的sales_amount/num_person这个子公式的值是不是以前已经计算过，如果计算过，就复用，否则，就计算一下，并且把这个中间结果也存起来。</p><p>我们把这个报表再复杂化一点，形成下面一个报表模板。这个报表模板用到了好几个函数，包括排序、汇总值、累计汇总值和最大值，并通过公式定义出一些相对复杂的计算字段，包括最高销售额、销售额的差距、销售额排序、人均销售额排序、销售额累计汇总、部门销售额在总销售额中的占比，等等。</p><pre><code>public static ReportTemplate sampleReport2(){\n    ReportTemplate template = new ReportTemplate();\n\n    template.columnHeaders.add(&quot;部门&quot;);\n    template.columnHeaders.add(&quot;人数&quot;);\n    template.columnHeaders.add(&quot;销售额&quot;);\n    template.columnHeaders.add(&quot;最高额&quot;);\n    template.columnHeaders.add(&quot;差距&quot;);\n    template.columnHeaders.add(&quot;排序&quot;);\n    template.columnHeaders.add(&quot;人均&quot;);\n    template.columnHeaders.add(&quot;人均排序&quot;);\n    template.columnHeaders.add(&quot;累计汇总&quot;);\n    template.columnHeaders.add(&quot;占比%&quot;);\n\n    template.fields.add(&quot;{=dept}&quot;);\n    template.fields.add(&quot;{=num_person}&quot;);\n    template.fields.add(&quot;{=sales_amount}&quot;);\n    template.fields.add(&quot;{=max(sales_amount)}&quot;);\n    template.fields.add(&quot;{=max(sales_amount)-sales_amount}&quot;);\n    template.fields.add(&quot;{=rank(sales_amount)}&quot;);\n    template.fields.add(&quot;{=sales_amount/num_person}&quot;);\n    template.fields.add(&quot;{=rank(sales_amount/num_person)}&quot;);\n    template.fields.add(&quot;{=runningsum(sales_amount)}&quot;);\n    template.fields.add(&quot;{=sales_amount/sum(sales_amount)*100}&quot;);\n\n    return template;\n}\n</code></pre><p>最后输出的报表截屏如下，怎么样，现在看起来功能还是挺强的吧！</p><p><img src=\"https://static001.geekbang.org/resource/image/8f/1b/8f83b528da89e0620deea388086d321b.jpg?wh=1142*273\" alt=\"\"></p><p>当然了，这个程序只是拿很短的时间写的一个Demo，如果要变成一个成熟的产品，还要在很多地方做工作。比如：</p><ul>\n<li>可以把字段名称用中文显示，这样更便于非技术人员使用；</li>\n<li>除了支持行列报表，还要支持交叉表，用于统计分析；</li>\n<li>支持多维数据计算。</li>\n<li>……</li>\n</ul><p>在报表工具中，编译技术除了用来做字段的计算，还可以用于其他功能，比如条件格式。我们可以在人均销售额低于某个数值时，给这行显示成红色，其中的判断条件，也是一个公式。</p><p>甚至你还可以为报表工具添加自定义公式功能。我们给用户提供脚本功能，用户可以自己做一个函数，实现某个领域的一个专业功能。我十分建议你在这个示例程序的基础上进一步加工，看看能做否做出一些让自己惊喜的功能。</p><h2>课程小结</h2><p>本节课我们做了一个示例性的报表工具。你能在这个过程中看到，像报表工具这样的软件，如果有编译技术的支持，真的可以做得很灵活、很强大。你完全可以借鉴本节课的思路，去尝试做一下其他需要自定义功能的软件工具或产品。</p><p>与此同时，我们能看到编译技术可以跟某个应用领域结合在一起，内置在产品中，同时形成领域的DSL，比如报表的模板文件。这样，我们就相当于赋予了普通用户在某个领域内的编程能力，比如用户只需要编写一个报表模板，就可以生成报表了。了解这些内容之后，我来带你回顾一下，这个应用是怎么运用编译器前端技术的。</p><p>词法分析和语法分析都很简单，我们就是简单地用了表达式和函数调用的功能。而语义分析除了需要检查类型以外，还要检查所用到的字段和函数是否合法，这是另一种意义上的引用消解。而且这个例子中的运算的含义是向量运算，同样是加减乘除，每个操作都会处理一组数据，这也是一种语义上的区别。</p><p>我希望在学习了这两节课之后，你能对如何在某个应用领域应用编译技术有更直观的了解，甚至有了很多的启发。</p><h2>一课一思</h2><p>你在自己的工作领域中，是否发现有哪些需要用户自定义功能的需求？你又是怎么实现这些需求的？编译技术会不会在这些地方帮助到你？欢迎在留言区分享你的发现。</p><p>最后，感谢你的阅读，如果这篇文章让你有所收获，欢迎你将它分享给更多的朋友。</p><p>本节课的示例代码我放在文末，供你参考。</p><ul>\n<li>lab/report（报表项目示例代码） <a href=\"https://gitee.com/richard-gong/PlayWithCompiler/tree/master/lab/report\">码云</a>   <a href=\"https://github.com/RichardGong/PlayWithCompiler/tree/master/lab/report\">GitHub</a></li>\n<li>PlayReport.java（主程序入口）    <a href=\"https://gitee.com/richard-gong/PlayWithCompiler/blob/master/lab/report/src/main/report/PlayReport.java\">码云</a>   <a href=\"https://github.com/RichardGong/PlayWithCompiler/blob/master/lab/report/src/main/report/PlayReport.java\">GitHub</a></li>\n<li>FieldEvaluator.java（做报表计算的代码）   <a href=\"https://gitee.com/richard-gong/PlayWithCompiler/blob/master/lab/report/src/main/report/FieldEvaluator.java\">码云</a>   <a href=\"https://github.com/RichardGong/PlayWithCompiler/blob/master/lab/report/src/main/report/FieldEvaluator.java\">GitHub</a></li>\n<li>ReportTemplate.java（报表模板）  <a href=\"https://gitee.com/richard-gong/PlayWithCompiler/blob/master/lab/report/src/main/report/ReportTemplate.java\">码云</a>  <a href=\"https://github.com/RichardGong/PlayWithCompiler/blob/master/lab/report/src/main/report/ReportTemplate.java\">GitHub</a></li>\n<li>TabularData.java（报表数据） <a href=\"https://gitee.com/richard-gong/PlayWithCompiler/blob/master/lab/report/src/main/report/TabularData.java\">码云</a>  <a href=\"https://github.com/RichardGong/PlayWithCompiler/blob/master/lab/report/src/main/report/TabularData.java\">GitHub</a></li>\n</ul><p></p>","neighbors":{"left":{"article_title":"14 | 前端技术应用（一）：如何透明地支持数据库分库分表？","id":135954},"right":{"article_title":"16 | NFA和DFA：如何自己实现一个正则表达式工具？","id":137286}},"comments":[{"had_liked":false,"id":159657,"user_name":"风的呢喃，爱的絮语","can_delete":false,"product_type":"c1","uid":1185453,"ip_address":"","ucode":"DCB251D142250A","user_header":"https://static001.geekbang.org/account/avatar/00/12/16/ad/5dc61a31.jpg","comment_is_top":false,"comment_ctime":1575720480,"is_pvip":false,"replies":[{"id":"63394","content":"没错的。<br>通过图形化的界面，进行可视化的编程，实际上是目前发展比较快的一个领域。现在被叫做“低代码开发”或“零代码开发”。我曾经也在这方面做过工作。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1577438642,"ip_address":"","comment_id":159657,"utype":1}],"discussion_count":2,"race_medal":0,"score":"44525393440","product_id":100034101,"comment_content":"<br><br>这个也可以用来做代码自动生成吧，通过一个图形化的界面拖拖拽拽设置下值 自动生成符合文法的业务功能描述文件 解析这个文件生成程序代码","like_count":10,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477135,"discussion_content":"没错的。\n通过图形化的界面，进行可视化的编程，实际上是目前发展比较快的一个领域。现在被叫做“低代码开发”或“零代码开发”。我曾经也在这方面做过工作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577438642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1905024,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/11/80/73ff198e.jpg","nickname":"VictorLee","note":"","ucode":"FF7C211DA853CE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306358,"discussion_content":"lowcode，现在在web前端比较火","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600254905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134043,"user_name":"雲至","can_delete":false,"product_type":"c1","uid":1568487,"ip_address":"","ucode":"47E2D099322BB1","user_header":"https://static001.geekbang.org/account/avatar/00/17/ee/e7/4375e97c.jpg","comment_is_top":false,"comment_ctime":1568727907,"is_pvip":false,"replies":[{"id":"57677","content":"调用的主控逻辑在PlayReport.renderReport中。要编译报表模板中的每个字段（含公式），然后在渲染报表的时候，调用FieldEvaluator进行计算。<br>FieldEvaluator跟之前的计算器没什么差别，只不过进行的是向量（矢量）计算，一次计算一整列。都是解释执行AST。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1573434752,"ip_address":"","comment_id":134043,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10158662499","product_id":100034101,"comment_content":"老师   生成的解析器是怎么样调用的  能在详细说一下吗？","like_count":2,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467596,"discussion_content":"调用的主控逻辑在PlayReport.renderReport中。要编译报表模板中的每个字段（含公式），然后在渲染报表的时候，调用FieldEvaluator进行计算。\nFieldEvaluator跟之前的计算器没什么差别，只不过进行的是向量（矢量）计算，一次计算一整列。都是解释执行AST。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573434752,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221053,"user_name":"hhhh","can_delete":false,"product_type":"c1","uid":1256101,"ip_address":"","ucode":"9E87017424B382","user_header":"https://static001.geekbang.org/account/avatar/00/13/2a/a5/625c0a2e.jpg","comment_is_top":false,"comment_ctime":1590393348,"is_pvip":false,"replies":[{"id":"82309","content":"用户自定义规则。非常好。非常典型的场景。感谢分享！","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1591080341,"ip_address":"","comment_id":221053,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5885360644","product_id":100034101,"comment_content":"目前在做一个监控报警系统，用户可以自定义规则，例如 request_timeout &gt; 10s | cpu_usage &gt; 2, 需要用到简单的词法分析，语法分析，以及语义分析，从而执行对应的操作。","like_count":1,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496311,"discussion_content":"用户自定义规则。非常好。非常典型的场景。感谢分享！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591080341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207632,"user_name":"test","can_delete":false,"product_type":"c1","uid":1129610,"ip_address":"","ucode":"C57A175CBC6547","user_header":"https://static001.geekbang.org/account/avatar/00/11/3c/8a/900ca88a.jpg","comment_is_top":false,"comment_ctime":1587123591,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5882090887","product_id":100034101,"comment_content":"老师那拖拽可视化实现有什么框架吗，对前端也不懂，感觉有点迷茫，这种封装语义拖拽有什么开源推荐码","like_count":1},{"had_liked":false,"id":202136,"user_name":"test","can_delete":false,"product_type":"c1","uid":1129610,"ip_address":"","ucode":"C57A175CBC6547","user_header":"https://static001.geekbang.org/account/avatar/00/11/3c/8a/900ca88a.jpg","comment_is_top":false,"comment_ctime":1585907871,"is_pvip":false,"replies":[{"id":"76606","content":"这需要普通用户（非技术人员）可以使用的那种报表工具。有一些产品是针对这种场景的。<br>基本思路是：你要设计一个语义层，屏蔽底层的细节，让用户拖拽过来几个数据指标，就能实现查询。你可以用编译技术实现语义层与底层实现之间的翻译。<br>采用这个思路，你还可以实现低代码或无代码的编程工具，让不怎么懂技术的人也可以做编程。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1586511243,"ip_address":"","comment_id":202136,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5880875167","product_id":100034101,"comment_content":"最近也要学数据库，公司数据很多，客服，产品都要查数据，有什么思路可以让他们自己查的","like_count":1,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490512,"discussion_content":"这需要普通用户（非技术人员）可以使用的那种报表工具。有一些产品是针对这种场景的。\n基本思路是：你要设计一个语义层，屏蔽底层的细节，让用户拖拽过来几个数据指标，就能实现查询。你可以用编译技术实现语义层与底层实现之间的翻译。\n采用这个思路，你还可以实现低代码或无代码的编程工具，让不怎么懂技术的人也可以做编程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586511243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138619,"user_name":"码力不足","can_delete":false,"product_type":"c1","uid":1631005,"ip_address":"","ucode":"8319956D67F861","user_header":"https://wx.qlogo.cn/mmopen/vi_32/yoTG87qicuhbNacuWFF1MWxeCCA8bzWO9Tfk7CcM9Hl9o8e3PJp4qvXF250Y5gp5ibyR13xIbPia6qcicFv0PQINzA/132","comment_is_top":false,"comment_ctime":1570372210,"is_pvip":false,"replies":[{"id":"53814","content":"在lab&#47;report目录下。<br>https:&#47;&#47;github.com&#47;RichardGong&#47;PlayWithCompiler&#47;tree&#47;master&#47;lab&#47;report<br><br>我在文章末尾加一下链接！","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1570676311,"ip_address":"","comment_id":138619,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5865339506","product_id":100034101,"comment_content":"老师，这节课怎么没有提供相关的源代码？","like_count":1,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469597,"discussion_content":"在lab/report目录下。\nhttps://github.com/RichardGong/PlayWithCompiler/tree/master/lab/report\n\n我在文章末尾加一下链接！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570676311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360675,"user_name":"James Deng","can_delete":false,"product_type":"c1","uid":1109553,"ip_address":"广东","ucode":"7B63984F2C2C52","user_header":"https://static001.geekbang.org/account/avatar/00/10/ee/31/8a5cd41d.jpg","comment_is_top":false,"comment_ctime":1666749328,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1666749328","product_id":100034101,"comment_content":"老师，我们遇到用户自定义的场景实际还是研发把某些function定义并实现好，然后用户看着去用，但真正的自定义应该是用户自己定义并且实现该function的，这个就要开放用户去编码了？","like_count":0},{"had_liked":false,"id":306194,"user_name":"竟舟","can_delete":false,"product_type":"c1","uid":1617526,"ip_address":"","ucode":"0847C32A4A3E91","user_header":"https://static001.geekbang.org/account/avatar/00/18/ae/76/3fdd11f9.jpg","comment_is_top":false,"comment_ctime":1628428530,"is_pvip":true,"replies":[{"id":"111003","content":"啥情况？<br>从学习中获取乐趣就是了！","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1628644500,"ip_address":"","comment_id":306194,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1628428530","product_id":100034101,"comment_content":"有时候想和老师道个歉, 向自己道个歉, 从来没认清自己的现状.","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524660,"discussion_content":"啥情况？\n从学习中获取乐趣就是了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628644500,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300962,"user_name":"潜龙勿用","can_delete":false,"product_type":"c1","uid":2159460,"ip_address":"","ucode":"EEB8A6F3E4A1B8","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/dsZ5CFV7mCIKEn7YcVFJXksO201eeqsJXoT4EYNvcibAKNSWSQVZPbbRgPKraWqg6YnaaRlVoywic9MEsflicRDibQ/132","comment_is_top":false,"comment_ctime":1625470572,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1625470572","product_id":100034101,"comment_content":"数据权限也可以用编译技术来实现。数据权限可以表达成一个表达式，比如 city=广州。那么通过解析这个表达式，然后生成对应数据库的条件语句来实现数据权限。","like_count":0}]}