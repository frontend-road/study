{"id":69913,"title":"28 | 堆和堆排序：为什么说堆排序没有快速排序快？","content":"<p>我们今天讲另外一种特殊的树，“堆”（$Heap$）。堆这种数据结构的应用场景非常多，最经典的莫过于堆排序了。堆排序是一种原地的、时间复杂度为$O(n\\log n)$的排序算法。</p><p>前面我们学过快速排序，平均情况下，它的时间复杂度为$O(n\\log n)$。尽管这两种排序算法的时间复杂度都是$O(n\\log n)$，甚至堆排序比快速排序的时间复杂度还要稳定，但是，<strong><span class=\"orange\">在实际的软件开发中，快速排序的性能要比堆排序好，这是为什么呢？</span></strong></p><p>现在，你可能还无法回答，甚至对问题本身还有点疑惑。没关系，带着这个问题，我们来学习今天的内容。等你学完之后，或许就能回答出来了。</p><h2>如何理解“堆”？</h2><p>前面我们提到，堆是一种特殊的树。我们现在就来看看，什么样的树才是堆。我罗列了两点要求，只要满足这两点，它就是一个堆。</p><ul>\n<li>\n<p>堆是一个完全二叉树；</p>\n</li>\n<li>\n<p>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。</p>\n</li>\n</ul><p>我分别解释一下这两点。</p><p>第一点，堆必须是一个完全二叉树。还记得我们之前讲的完全二叉树的定义吗？完全二叉树要求，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。</p><!-- [[[read_end]]] --><p>第二点，堆中的每个节点的值必须大于等于（或者小于等于）其子树中每个节点的值。实际上，我们还可以换一种说法，堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值。这两种表述是等价的。</p><p>对于每个节点的值都大于等于子树中每个节点值的堆，我们叫做“大顶堆”。对于每个节点的值都小于等于子树中每个节点值的堆，我们叫做“小顶堆”。</p><p>定义解释清楚了，你来看看，下面这几个二叉树是不是堆？</p><p><img src=\"https://static001.geekbang.org/resource/image/4c/99/4c452a1ad3b2d152daa2727d06097099.jpg?wh=1142*779\" alt=\"\"></p><p>其中第$1$个和第$2$个是大顶堆，第$3$个是小顶堆，第$4$个不是堆。除此之外，从图中还可以看出来，对于同一组数据，我们可以构建多种不同形态的堆。</p><h2>如何实现一个堆？</h2><p>要实现一个堆，我们先要知道，<strong>堆都支持哪些操作</strong>以及<strong>如何存储一个堆</strong>。</p><p>我之前讲过，完全二叉树比较适合用数组来存储。用数组来存储完全二叉树是非常节省存储空间的。因为我们不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。</p><p>我画了一个用数组存储堆的例子，你可以先看下。</p><p><img src=\"https://static001.geekbang.org/resource/image/4d/1e/4d349f57947df6590a2dd1364c3b0b1e.jpg?wh=1142*540\" alt=\"\"></p><p>从图中我们可以看到，数组中下标为$i$的节点的左子节点，就是下标为$i*2$的节点，右子节点就是下标为$i*2+1$的节点，父节点就是下标为$\\frac{i}{2}$的节点。</p><p>知道了如何存储一个堆，那我们再来看看，堆上的操作有哪些呢？我罗列了几个非常核心的操作，分别是往堆中插入一个元素和删除堆顶元素。（如果没有特殊说明，我下面都是拿大顶堆来讲解）。</p><h3>1.往堆中插入一个元素</h3><p>往堆中插入一个元素后，我们需要继续满足堆的两个特性。</p><p>如果我们把新插入的元素放到堆的最后，你可以看我画的这个图，是不是不符合堆的特性了？于是，我们就需要进行调整，让其重新满足堆的特性，这个过程我们起了一个名字，就叫做<strong>堆化</strong>（heapify）。</p><p>堆化实际上有两种，从下往上和从上往下。这里我先讲<strong>从下往上</strong>的堆化方法。</p><p><img src=\"https://static001.geekbang.org/resource/image/e5/22/e578654f930002a140ebcf72b11eb722.jpg?wh=1142*609\" alt=\"\"></p><p>堆化非常简单，就是顺着节点所在的路径，向上或者向下，对比，然后交换。</p><p>我这里画了一张堆化的过程分解图。我们可以让新插入的节点与父节点对比大小。如果不满足子节点小于等于父节点的大小关系，我们就互换两个节点。一直重复这个过程，直到父子节点之间满足刚说的那种大小关系。</p><p><img src=\"https://static001.geekbang.org/resource/image/e3/0e/e3744661e038e4ae570316bc862b2c0e.jpg?wh=1142*776\" alt=\"\"></p><p>我将上面讲的往堆中插入数据的过程，翻译成了代码，你可以结合着一块看。</p><pre><code>public class Heap {\n  private int[] a; // 数组，从下标1开始存储数据\n  private int n;  // 堆可以存储的最大数据个数\n  private int count; // 堆中已经存储的数据个数\n\n  public Heap(int capacity) {\n    a = new int[capacity + 1];\n    n = capacity;\n    count = 0;\n  }\n\n  public void insert(int data) {\n    if (count &gt;= n) return; // 堆满了\n    ++count;\n    a[count] = data;\n    int i = count;\n    while (i/2 &gt; 0 &amp;&amp; a[i] &gt; a[i/2]) { // 自下往上堆化\n      swap(a, i, i/2); // swap()函数作用：交换下标为i和i/2的两个元素\n      i = i/2;\n    }\n  }\n }\n</code></pre><h3>2.删除堆顶元素</h3><p>从堆的定义的第二条中，任何节点的值都大于等于（或小于等于）子树节点的值，我们可以发现，堆顶元素存储的就是堆中数据的最大值或者最小值。</p><p>假设我们构造的是大顶堆，堆顶元素就是最大的元素。当我们删除堆顶元素之后，就需要把第二大的元素放到堆顶，那第二大元素肯定会出现在左右子节点中。然后我们再迭代地删除第二大节点，以此类推，直到叶子节点被删除。</p><p>这里我也画了一个分解图。不过这种方法有点问题，就是最后堆化出来的堆并不满足完全二叉树的特性。</p><p><img src=\"https://static001.geekbang.org/resource/image/59/81/5916121b08da6fc0636edf1fc24b5a81.jpg?wh=1142*867\" alt=\"\"></p><p>实际上，我们稍微改变一下思路，就可以解决这个问题。你看我画的下面这幅图。我们把最后一个节点放到堆顶，然后利用同样的父子节点对比方法。对于不满足父子节点大小关系的，互换两个节点，并且重复进行这个过程，直到父子节点之间满足大小关系为止。这就是<strong>从上往下的堆化方法</strong>。</p><p>因为我们移除的是数组中的最后一个元素，而在堆化的过程中，都是交换操作，不会出现数组中的“空洞”，所以这种方法堆化之后的结果，肯定满足完全二叉树的特性。</p><p><img src=\"https://static001.geekbang.org/resource/image/11/60/110d6f442e718f86d2a1d16095513260.jpg?wh=1142*856\" alt=\"\"></p><p>我把上面的删除过程同样也翻译成了代码，贴在这里，你可以结合着看。</p><pre><code>public void removeMax() {\n  if (count == 0) return -1; // 堆中没有数据\n  a[1] = a[count];\n  --count;\n  heapify(a, count, 1);\n}\n\nprivate void heapify(int[] a, int n, int i) { // 自上往下堆化\n  while (true) {\n    int maxPos = i;\n    if (i*2 &lt;= n &amp;&amp; a[i] &lt; a[i*2]) maxPos = i*2;\n    if (i*2+1 &lt;= n &amp;&amp; a[maxPos] &lt; a[i*2+1]) maxPos = i*2+1;\n    if (maxPos == i) break;\n    swap(a, i, maxPos);\n    i = maxPos;\n  }\n}\n</code></pre><p>我们知道，一个包含$n$个节点的完全二叉树，树的高度不会超过$\\log_{2}n$。堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是$O(\\log n)$。插入数据和删除堆顶元素的主要逻辑就是堆化，所以，往堆中插入一个元素和删除堆顶元素的时间复杂度都是$O(\\log n)$。</p><h2>如何基于堆实现排序？</h2><p>前面我们讲过好几种排序算法，我们再来回忆一下，有时间复杂度是$O(n^{2})$的冒泡排序、插入排序、选择排序，有时间复杂度是$O(n\\log n)$的归并排序、快速排序，还有线性排序。</p><p>这里我们借助于堆这种数据结构实现的排序算法，就叫做堆排序。这种排序方法的时间复杂度非常稳定，是$O(n\\log n)$，并且它还是原地排序算法。如此优秀，它是怎么做到的呢？</p><p>我们可以把堆排序的过程大致分解成两个大的步骤，<strong>建堆</strong>和<strong>排序</strong>。</p><h3>1.建堆</h3><p>我们首先将数组原地建成一个堆。所谓“原地”就是，不借助另一个数组，就在原数组上操作。建堆的过程，有两种思路。</p><p>第一种是借助我们前面讲的，在堆中插入一个元素的思路。尽管数组中包含$n$个数据，但是我们可以假设，起初堆中只包含一个数据，就是下标为$1$的数据。然后，我们调用前面讲的插入操作，将下标从$2$到$n$的数据依次插入到堆中。这样我们就将包含$n$个数据的数组，组织成了堆。</p><p>第二种实现思路，跟第一种截然相反，也是我这里要详细讲的。第一种建堆思路的处理过程是从前往后处理数组数据，并且每个数据插入堆中时，都是从下往上堆化。而第二种实现思路，是从后往前处理数组，并且每个数据都是从上往下堆化。</p><p>我举了一个例子，并且画了一个第二种实现思路的建堆分解步骤图，你可以看下。因为叶子节点往下堆化只能自己跟自己比较，所以我们直接从最后一个非叶子节点开始，依次堆化就行了。</p><p><img src=\"https://static001.geekbang.org/resource/image/50/1e/50c1e6bc6fe68378d0a66bdccfff441e.jpg?wh=1142*807\" alt=\"\"><img src=\"https://static001.geekbang.org/resource/image/aa/9d/aabb8d15b1b92d5e040895589c60419d.jpg?wh=1142*856\" alt=\"\"></p><p>对于程序员来说，看代码可能更好理解一些，所以，我将第二种实现思路翻译成了代码，你可以看下。</p><pre><code>private static void buildHeap(int[] a, int n) {\n  for (int i = n/2; i &gt;= 1; --i) {\n    heapify(a, n, i);\n  }\n}\n\nprivate static void heapify(int[] a, int n, int i) {\n  while (true) {\n    int maxPos = i;\n    if (i*2 &lt;= n &amp;&amp; a[i] &lt; a[i*2]) maxPos = i*2;\n    if (i*2+1 &lt;= n &amp;&amp; a[maxPos] &lt; a[i*2+1]) maxPos = i*2+1;\n    if (maxPos == i) break;\n    swap(a, i, maxPos);\n    i = maxPos;\n  }\n}\n</code></pre><p>你可能已经发现了，在这段代码中，我们对下标从$\\frac{n}{2}$ 开始到$1$的数据进行堆化，下标是$\\frac{n}{2}+1$到$n$的节点是叶子节点，我们不需要堆化。实际上，对于完全二叉树来说，下标从$\\frac{n}{2}+1$到$n$的节点都是叶子节点。</p><p>现在，我们来看，建堆操作的时间复杂度是多少呢？</p><p>每个节点堆化的时间复杂度是$O(\\log n)$，那$\\frac{n}{2}+1$个节点堆化的总时间复杂度是不是就是$O(n\\log n)$呢？这个答案虽然也没错，但是这个值还是不够精确。实际上，堆排序的建堆过程的时间复杂度是$O(n)$。我带你推导一下。</p><p>因为叶子节点不需要堆化，所以需要堆化的节点从倒数第二层开始。每个节点堆化的过程中，需要比较和交换的节点个数，跟这个节点的高度$k$成正比。</p><p>我把每一层的节点个数和对应的高度画了出来，你可以看看。我们只需要将每个节点的高度求和，得出的就是建堆的时间复杂度。</p><p><img src=\"https://static001.geekbang.org/resource/image/89/d5/899b9f1b40302c9bd5a7f77f042542d5.jpg?wh=1142*763\" alt=\"\"></p><p>我们将每个非叶子节点的高度求和，就是下面这个公式：</p><p><img src=\"https://static001.geekbang.org/resource/image/f7/09/f712f8a7baade44c39edde839cefcc09.jpg?wh=1142*197\" alt=\"\"></p><p>这个公式的求解稍微有点技巧，不过我们高中应该都学过：把公式左右都乘以$2$，就得到另一个公式$S2$。我们将$S2$错位对齐，并且用$S2$减去$S1$，可以得到$S$。</p><p><img src=\"https://static001.geekbang.org/resource/image/62/df/629328315decd96e349d8cb3940636df.jpg?wh=1142*515\" alt=\"\"></p><p>$S$的中间部分是一个等比数列，所以最后可以用等比数列的求和公式来计算，最终的结果就是下面图中画的这个样子。</p><p><img src=\"https://static001.geekbang.org/resource/image/46/36/46ca25edc69b556b967d2c62388b7436.jpg?wh=1142*204\" alt=\"\"></p><p>因为$h=\\log_{2}n$，代入公式$S$，就能得到$S=O(n)$，所以，建堆的时间复杂度就是$O(n)$。</p><h3>2.排序</h3><p>建堆结束之后，数组中的数据已经是按照大顶堆的特性来组织的。数组中的第一个元素就是堆顶，也就是最大的元素。我们把它跟最后一个元素交换，那最大元素就放到了下标为$n$的位置。</p><p>这个过程有点类似上面讲的“删除堆顶元素”的操作，当堆顶元素移除之后，我们把下标为$n$的元素放到堆顶，然后再通过堆化的方法，将剩下的$n-1$个元素重新构建成堆。堆化完成之后，我们再取堆顶的元素，放到下标是$n-1$的位置，一直重复这个过程，直到最后堆中只剩下标为$1$的一个元素，排序工作就完成了。</p><p><img src=\"https://static001.geekbang.org/resource/image/23/d1/23958f889ca48dbb8373f521708408d1.jpg?wh=1142*790\" alt=\"\"></p><p>堆排序的过程，我也翻译成了代码。结合着代码看，你理解起来应该会更加容易。</p><pre><code>// n表示数据的个数，数组a中的数据从下标1到n的位置。\npublic static void sort(int[] a, int n) {\n  buildHeap(a, n);\n  int k = n;\n  while (k &gt; 1) {\n    swap(a, 1, k);\n    --k;\n    heapify(a, k, 1);\n  }\n}\n</code></pre><p>现在，我们再来分析一下堆排序的时间复杂度、空间复杂度以及稳定性。</p><p>整个堆排序的过程，都只需要极个别临时存储空间，所以堆排序是原地排序算法。堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是$O(n)$，排序过程的时间复杂度是$O(n\\log n)$，所以，堆排序整体的时间复杂度是$O(n\\log n)$。</p><p>堆排序不是稳定的排序算法，因为在排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序。</p><p>今天的内容到此就讲完了。我这里要稍微解释一下，在前面的讲解以及代码中，我都假设，堆中的数据是从数组下标为1的位置开始存储。那如果从$0$开始存储，实际上处理思路是没有任何变化的，唯一变化的，可能就是，代码实现的时候，计算子节点和父节点的下标的公式改变了。</p><p>如果节点的下标是$i$，那左子节点的下标就是$2*i+1$，右子节点的下标就是$2*i+2$，父节点的下标就是$\\frac{i-1}{2}$。</p><h2>解答开篇</h2><p>现在我们来看开篇的问题，在实际开发中，为什么快速排序要比堆排序性能好？</p><p>我觉得主要有两方面的原因。</p><p><strong>第一点，堆排序数据访问的方式没有快速排序友好。</strong></p><p>对于快速排序来说，数据是顺序访问的。而对于堆排序来说，数据是跳着访问的。 比如，堆排序中，最重要的一个操作就是数据的堆化。比如下面这个例子，对堆顶节点进行堆化，会依次访问数组下标是$1，2，4，8$的元素，而不是像快速排序那样，局部顺序访问，所以，这样对CPU缓存是不友好的。</p><p><img src=\"https://static001.geekbang.org/resource/image/83/ce/838a38286dcace89ca63895b77ae8ece.jpg?wh=1142*438\" alt=\"\"></p><p><strong>第二点，对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。</strong></p><p>我们在讲排序的时候，提过两个概念，有序度和逆序度。对于基于比较的排序算法来说，整个排序过程就是由两个基本的操作组成的，比较和交换（或移动）。快速排序数据交换的次数不会比逆序度多。</p><p>但是堆排序的第一步是建堆，建堆的过程会打乱数据原有的相对先后顺序，导致原数据的有序度降低。比如，对于一组已经有序的数据来说，经过建堆之后，数据反而变得更无序了。</p><p><img src=\"https://static001.geekbang.org/resource/image/6e/bd/6e81fdde42ec3fd288d32eb866867fbd.jpg?wh=1142*573\" alt=\"\"></p><p>对于第二点，你可以自己做个试验看下。我们用一个记录交换次数的变量，在代码中，每次交换的时候，我们就对这个变量加一，排序完成之后，这个变量的值就是总的数据交换次数。这样你就能很直观地理解我刚刚说的，堆排序比快速排序交换次数多。</p><h2>内容小结</h2><p>今天我们讲了堆这种数据结构。堆是一种完全二叉树。它最大的特性是：每个节点的值都大于等于（或小于等于）其子树节点的值。因此，堆被分成了两类，大顶堆和小顶堆。</p><p>堆中比较重要的两个操作是插入一个数据和删除堆顶元素。这两个操作都要用到堆化。插入一个数据的时候，我们把新插入的数据放到数组的最后，然后从下往上堆化；删除堆顶数据的时候，我们把数组中的最后一个元素放到堆顶，然后从上往下堆化。这两个操作时间复杂度都是$O(\\log n)$。</p><p>除此之外，我们还讲了堆的一个经典应用，堆排序。堆排序包含两个过程，建堆和排序。我们将下标从$\\frac{n}{2}$到$1$的节点，依次进行从上到下的堆化操作，然后就可以将数组中的数据组织成堆这种数据结构。接下来，我们迭代地将堆顶的元素放到堆的末尾，并将堆的大小减一，然后再堆化，重复这个过程，直到堆中只剩下一个元素，整个数组中的数据就都有序排列了。</p><h2>课后思考</h2><ol>\n<li>\n<p>在讲堆排序建堆的时候，我说到，对于完全二叉树来说，下标从$\\frac{n}{2}+1$到$n$的都是叶子节点，这个结论是怎么推导出来的呢？</p>\n</li>\n<li>\n<p>我们今天讲了堆的一种经典应用，堆排序。关于堆，你还能想到它的其他应用吗？</p>\n</li>\n</ol><p>欢迎留言和我分享，我会第一时间给你反馈。</p>","comments":[{"had_liked":false,"id":43146,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1543191889,"is_pvip":false,"discussion_count":28,"race_medal":0,"score":"2243516120401","product_id":100017301,"comment_content":"## 第一题：<br><br>使用数组存储表示完全二叉树时，从数组下标为1开始存储数据，数组下标为i的节点，左子节点为2i, 右子节点为2i + 1.  这个结论很重要（可以用数学归纳法证明)，将此结论记为『原理1』，以下证明会用到这个原理。<br><br>为什么，对于完全二叉树来说，下标从n&#47;2 + 1 到 n的节点都是叶子节点？ 使用反证法证明即可：<br><br>如果下标为n&#47;2 + 1的节点不是叶子节点，即它存在子节点，按照『原理1』，它的左子节点为：2(n&#47;2  + 1)  = n + 2，大家明显可以看出，这个数字已经大于n + 1，超出了实现完全二叉树所用数组的大小（数组下标从1开始记录数据，对于n个节点来说，数组大小是n + 1），左子节点都已经超出了数组容量，更何况右子节点。以此类推，很容易得出：下标大于n&#47;2 + 1的节点肯定都是也叶子节点了，故而得出结论：对于完全二叉树来说，下标从n&#47;2 + 1 到 n的节点都是叶子节点<br><br>备注下：用数组存储表示完全二叉树时，也可以从下标为0开始，只是这样做的话，计算左子节点时，会多一次加法运算<br><br>--------------------------------------------------------<br>## 第二题：<br><br>堆的应用除了堆排以外，还有如下一些应用：<br>1. 从大数量级数据中筛选出top n 条数据； 比如：从几十亿条订单日志中筛选出金额靠前的1000条数据<br>2. 在一些场景中，会根据不同优先级来处理网络请求，此时也可以用到优先队列(用堆实现的数据结构)；比如：网络框架Volley就用了Java中PriorityBlockingQueue，当然它是线程安全的<br>3. 可以用堆来实现多路归并，从而实现有序，leetcode上也有相关的一题：Merge K Sorted Lists<br><br>暂时只能想到以上三种常见的应用场景，其它的，希望老师补充！","like_count":523,"discussions":[{"author":{"id":2139807,"avatar":"https://static001.geekbang.org/account/avatar/00/20/a6/9f/3c60fffd.jpg","nickname":"青阳","note":"","ucode":"3591D366BAB0B9","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373822,"discussion_content":"最后一个元素的下标是n,由一个元素的父节点下标是i/2，并且是完全二叉树，得最后一个非叶子结点为n/2","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1620887428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1380312,"avatar":"https://static001.geekbang.org/account/avatar/00/15/0f/d8/9286b272.jpg","nickname":"leetcode","note":"","ucode":"3B8C3668A0DE74","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285365,"discussion_content":"向大佬学习 ","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1592816134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1250807,"avatar":"https://static001.geekbang.org/account/avatar/00/13/15/f7/744720a2.jpg","nickname":"DriveMan_邱佳源","note":"","ucode":"A4C83BF07DEE7A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7953,"discussion_content":"每篇必留言呀你 兄die","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1567739347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1109666,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ee/a2/9107aa0e.jpg","nickname":"命硬。","note":"","ucode":"4F06D52E7CC951","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345965,"discussion_content":"反证法妙啊","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1611824957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1634260,"avatar":"https://static001.geekbang.org/account/avatar/00/18/ef/d4/292132f9.jpg","nickname":"fxlego","note":"","ucode":"32B09E5B542BBA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329658,"discussion_content":"堆数据是放内存，几十亿日志能放的下吗？ 用桶排序感觉也可以","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1606444568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1213078,"avatar":"https://static001.geekbang.org/account/avatar/00/12/82/96/aa795685.jpg","nickname":"mghio","note":"","ucode":"74883EDE4FD0DC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281858,"discussion_content":"大佬","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1591834644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1205697,"avatar":"https://static001.geekbang.org/account/avatar/00/12/65/c1/afcd981b.jpg","nickname":"程序员二师兄","note":"","ucode":"C9E3B5B3358BDF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1213078,"avatar":"https://static001.geekbang.org/account/avatar/00/12/82/96/aa795685.jpg","nickname":"mghio","note":"","ucode":"74883EDE4FD0DC","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":387875,"discussion_content":"大佬，评论区活捉一只","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1628483415,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":281858,"ip_address":""},"score":387875,"extra":""}]},{"author":{"id":1336475,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","nickname":"J.Smile","note":"","ucode":"C4D98DFDBF7584","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":254669,"discussion_content":"牛逼啊银银，并法包的也很清楚。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588339577,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1236079,"avatar":"https://static001.geekbang.org/account/avatar/00/12/dc/6f/5d86dbe9.jpg","nickname":"短迪大魔王","note":"","ucode":"37E8117E0495B8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":157788,"discussion_content":"反证法很妙啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1580519730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1563973,"avatar":"https://static001.geekbang.org/account/avatar/00/17/dd/45/dd79456e.jpg","nickname":"日拱一卒","note":"","ucode":"ED64819DA04EBA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46801,"discussion_content":"向高手学习","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573210948,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134861,"avatar":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","nickname":"James","note":"","ucode":"48B0F2A334D1C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":31807,"discussion_content":"大哥，你是真的强👍","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1570959620,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1577063,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/ib3Rzem884S5MOS96THy0gdiaickKianthQBANclQdrBBtTPkWZoCorLZ1AQjxW4aiaOtlWQjvIxuR9kXibqtM6VrY1Q/132","nickname":"Geek_ded26f","note":"","ucode":"7E4F0581550474","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587087,"discussion_content":"2022年再看大佬发言👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662780320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川"},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1547466,"avatar":"https://static001.geekbang.org/account/avatar/00/17/9c/ca/1b01098e.jpg","nickname":"Lee","note":"","ucode":"45CDD6604732AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369795,"discussion_content":"优秀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619159677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1751234,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/b8/c2/d1904d74.jpg","nickname":"酸辣土豆丝","note":"","ucode":"0E3E4AFB31E1E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297200,"discussion_content":"牛人，向大佬靠奇齐","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596806581,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1396126,"avatar":"https://static001.geekbang.org/account/avatar/00/15/4d/9e/04ec08bf.jpg","nickname":"SteelHuaSheng","note":"","ucode":"BC8127FC5207FC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215258,"discussion_content":"牛皮，点赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585309365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1455958,"avatar":"https://static001.geekbang.org/account/avatar/00/16/37/56/11068390.jpg","nickname":"倡印","note":"","ucode":"4F53AA5D017D89","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":142006,"discussion_content":"备注下：用数组存储表示完全二叉树时，也可以从下标为0开始，只是这样做的话，计算左子节点时，会多一次加法运算\n这里应该是\n备注下：用数组存储表示完全二叉树时，也可以从下标为0开始，只是这样做的话，计算“左右”子节点时，会多一次加法运算\n应该左右都有加1===》左：2*i+1 右：2*1+2 。i为父节点下标","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579445704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1008404,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","nickname":"Jerry银银","note":"","ucode":"80DA1172A2360A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1455958,"avatar":"https://static001.geekbang.org/account/avatar/00/16/37/56/11068390.jpg","nickname":"倡印","note":"","ucode":"4F53AA5D017D89","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":142492,"discussion_content":"右节点本来就要加的哦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579478734,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":142006,"ip_address":""},"score":142492,"extra":""},{"author":{"id":1617609,"avatar":"https://static001.geekbang.org/account/avatar/00/18/ae/c9/daf70d22.jpg","nickname":"谜底","note":"","ucode":"39A4A21B7C4CA0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1008404,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","nickname":"Jerry银银","note":"","ucode":"80DA1172A2360A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":183794,"discussion_content":"他应该说的是又多加了一次的意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582518357,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":142492,"ip_address":""},"score":183794,"extra":""}]},{"author":{"id":1522386,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/VarHGCe9OqeIexfD3cFPeMeicm1WwyDicSwfIUzhOPeQ9AcfFIzVec7TPNGREmjxGDLSH6oC8nz1k9AkvzClfOvQ/132","nickname":"Lengend","note":"","ucode":"0BD86B750E1CF3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":96418,"discussion_content":"向高人学习","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577064034,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1211898,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7d/fa/4d1ccf80.jpg","nickname":"天意","note":"","ucode":"69B032C229036B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":91133,"discussion_content":"第一题反证法有漏洞，虽然能够证明下标从n/2 + 1 到 n的节点都是叶子节点，但是如何证明下标为n/2的节点是不是叶子节点？也就是说n/2 + 1这个左边界如何确定的呢？这只是我的疑惑，望指正！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576812036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":6,"child_discussions":[{"author":{"id":1488631,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoAoDJJLy1iciaOxXNqwwnB8oV5TRyxNaI0FMRtjRK0QTsmo378OZYZRosOOqjrBhnomsDJQflpr0Fw/132","nickname":"Helr","note":"","ucode":"A24C99263E657B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1211898,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7d/fa/4d1ccf80.jpg","nickname":"天意","note":"","ucode":"69B032C229036B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":98367,"discussion_content":"n就是n/2的左子节点，所以n/2，并不是叶子节点。其实很简单，n是最后一个节点，那n的父节点n/2必定就是最后一个父节点了。那么自然n/2之后的节点都为叶子节点","likes_number":48,"is_delete":false,"is_hidden":false,"ctime":1577157803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":91133,"ip_address":""},"score":98367,"extra":""},{"author":{"id":1211898,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7d/fa/4d1ccf80.jpg","nickname":"天意","note":"","ucode":"69B032C229036B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1488631,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoAoDJJLy1iciaOxXNqwwnB8oV5TRyxNaI0FMRtjRK0QTsmo378OZYZRosOOqjrBhnomsDJQflpr0Fw/132","nickname":"Helr","note":"","ucode":"A24C99263E657B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":138567,"discussion_content":"妙啊！你这个证明比上面的反证法更有说服力，至少我是这么觉得的。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1579253489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":98367,"ip_address":""},"score":138567,"extra":""},{"author":{"id":1131083,"avatar":"https://static001.geekbang.org/account/avatar/00/11/42/4b/fa2dc54c.jpg","nickname":"LWP","note":"","ucode":"F3748E9E16CBB1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1488631,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoAoDJJLy1iciaOxXNqwwnB8oV5TRyxNaI0FMRtjRK0QTsmo378OZYZRosOOqjrBhnomsDJQflpr0Fw/132","nickname":"Helr","note":"","ucode":"A24C99263E657B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":191909,"discussion_content":"妙啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583045347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":98367,"ip_address":""},"score":191909,"extra":""}]},{"author":{"id":1397126,"avatar":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","nickname":"建强","note":"","ucode":"62B03D0E0C64EC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4768,"discussion_content":"高手，向你学习","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565709262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1339724,"avatar":"https://static001.geekbang.org/account/avatar/00/14/71/4c/2cefec07.jpg","nickname":"静水流深","note":"","ucode":"644F05EFBD2E7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":958,"discussion_content":"太牛逼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562207734,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":49496,"user_name":"Jessie","can_delete":false,"product_type":"c1","uid":1241378,"ip_address":"","ucode":"50FB29A445D371","user_header":"https://static001.geekbang.org/account/avatar/00/12/f1/22/d842d9c8.jpg","comment_is_top":false,"comment_ctime":1544698490,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"873423059578","product_id":100017301,"comment_content":"强烈建议，在进入课程的左侧，做一个目录，这样就不用每次都从最新的滑到最下面了。例如：目前是学到了第35课，已进入课堂，就是35课，假如我想看第一课，就得使劲滑。如果学到100课，那得滑老半天……所以强烈建议给左侧添加一个目录。可以连接到每一节课。！！！","like_count":203,"discussions":[{"author":{"id":1080985,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7e/99/c4302030.jpg","nickname":"Khirye","note":"","ucode":"6C54C126FA54B8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":235124,"discussion_content":"兄弟你可以安心的去了，这个功能后来开发出来了🐶","likes_number":36,"is_delete":false,"is_hidden":false,"ctime":1587021867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1380312,"avatar":"https://static001.geekbang.org/account/avatar/00/15/0f/d8/9286b272.jpg","nickname":"leetcode","note":"","ucode":"3B8C3668A0DE74","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1080985,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7e/99/c4302030.jpg","nickname":"Khirye","note":"","ucode":"6C54C126FA54B8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285366,"discussion_content":"啊哈哈哈哈哈  残忍简直 ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1592816184,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":235124,"ip_address":""},"score":285366,"extra":""},{"author":{"id":1702231,"avatar":"https://static001.geekbang.org/account/avatar/00/19/f9/57/a4f8fba2.jpg","nickname":"telnet","note":"","ucode":"3860B39D1FA81D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1080985,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7e/99/c4302030.jpg","nickname":"Khirye","note":"","ucode":"6C54C126FA54B8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326951,"discussion_content":"我很怀疑 这个功能是你加班做的。。。。������","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605707238,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":235124,"ip_address":""},"score":326951,"extra":""}]},{"author":{"id":1240321,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ed/01/997432f3.jpg","nickname":"喜笑延开","note":"","ucode":"DBF645D2129460","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217345,"discussion_content":"这个功能已经有了哈哈","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1585546413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1481811,"avatar":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","nickname":"ub8","note":"","ucode":"0D937C3EAEB781","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79133,"discussion_content":"这个B装的 100 分","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576060385,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1239630,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ea/4e/d5e464dd.jpg","nickname":"向卫明","note":"","ucode":"0D3A251F747B41","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6730,"discussion_content":"现在已经有这个功能了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567072449,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1069407,"avatar":"https://static001.geekbang.org/account/avatar/00/10/51/5f/abb7bfe3.jpg","nickname":"来来baby","note":"","ucode":"59EF2826EA2B28","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4180,"discussion_content":"我以为你出了个算法题呢，你能实现吗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1565189986,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1053676,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/ec/fd550ba2.jpg","nickname":"好好学习","note":"","ucode":"02791BFA143A65","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404976,"discussion_content":"手机app端还是没有目录","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634476886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":43271,"user_name":"WhoAmWe","can_delete":false,"product_type":"c1","uid":1133683,"ip_address":"","ucode":"642C04C0757CDF","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/73/778c7ae5.jpg","comment_is_top":false,"comment_ctime":1543202560,"is_pvip":false,"replies":[{"id":"15598","content":"👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543285212,"ip_address":"","comment_id":43271,"utype":1}],"discussion_count":6,"race_medal":0,"score":"504054376192","product_id":100017301,"comment_content":"应用:<br>1.topK<br>2.流里面的中值<br>3.流里面的中位数","like_count":117,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":430344,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543285212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1484831,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJw0VnT9fk33w0Kgic1udf85TmuzBhibIzic188HIlhJ5SLMnVuM8ia9GDpLTia5k2zy0EoXgCj9ibYzvZA/132","nickname":"tiga","note":"","ucode":"390769DADD80C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24252,"discussion_content":"但是中值和中位数是一个东西。为什么分开写？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1570071106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2694205,"avatar":"https://static001.geekbang.org/account/avatar/00/29/1c/3d/76465ee4.jpg","nickname":"摘星","note":"","ucode":"55D8CAFC938F91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1484831,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJw0VnT9fk33w0Kgic1udf85TmuzBhibIzic188HIlhJ5SLMnVuM8ia9GDpLTia5k2zy0EoXgCj9ibYzvZA/132","nickname":"tiga","note":"","ucode":"390769DADD80C3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404839,"discussion_content":"我也想知道","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634434794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":24252,"ip_address":""},"score":404839,"extra":""}]},{"author":{"id":1307269,"avatar":"https://static001.geekbang.org/account/avatar/00/13/f2/85/7d3ce959.jpg","nickname":"前人种树","note":"","ucode":"64D1B7F87B03E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305540,"discussion_content":"流指的是什么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599990514,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1213078,"avatar":"https://static001.geekbang.org/account/avatar/00/12/82/96/aa795685.jpg","nickname":"mghio","note":"","ucode":"74883EDE4FD0DC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1307269,"avatar":"https://static001.geekbang.org/account/avatar/00/13/f2/85/7d3ce959.jpg","nickname":"前人种树","note":"","ucode":"64D1B7F87B03E2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400517,"discussion_content":"好问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633308389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":305540,"ip_address":""},"score":400517,"extra":""}]},{"author":{"id":1484831,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJw0VnT9fk33w0Kgic1udf85TmuzBhibIzic188HIlhJ5SLMnVuM8ia9GDpLTia5k2zy0EoXgCj9ibYzvZA/132","nickname":"tiga","note":"","ucode":"390769DADD80C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24115,"discussion_content":"这个答案简洁又全面啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570008982,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":43716,"user_name":"冯选刚","can_delete":false,"product_type":"c1","uid":1018444,"ip_address":"","ucode":"A186F31A730F04","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/4c/d976b42c.jpg","comment_is_top":false,"comment_ctime":1543283610,"is_pvip":false,"discussion_count":17,"race_medal":0,"score":"362320536474","product_id":100017301,"comment_content":"不知道有没有人很容易看懂原理思路，就是不愿意看代码","like_count":84,"discussions":[{"author":{"id":1104937,"avatar":"https://static001.geekbang.org/account/avatar/00/10/dc/29/33d0d7ff.jpg","nickname":"scarlett","note":"","ucode":"F30414146C709F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334398,"discussion_content":"只看懂理论，自己动手写的时候才发现并没有真的懂。","likes_number":17,"is_delete":false,"is_hidden":false,"ctime":1607838287,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066380,"avatar":"https://static001.geekbang.org/account/avatar/00/10/45/8c/f3fa78f0.jpg","nickname":"韦","note":"","ucode":"97F369619A45C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":248551,"discussion_content":"就算能看懂实现代码，不练习，自己写的时候也完，或者说自己实现了，过一段时间不用，也是忘。。。","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1587879011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1243025,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f7/91/27401a3f.jpg","nickname":"kd叛逆","note":"","ucode":"F8870FBA8BB131","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1066380,"avatar":"https://static001.geekbang.org/account/avatar/00/10/45/8c/f3fa78f0.jpg","nickname":"韦","note":"","ucode":"97F369619A45C4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310375,"discussion_content":"是的，当时写了，过段时间就忘记了！有没有什么好办法解决这个痛点？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601806104,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":248551,"ip_address":""},"score":310375,"extra":""},{"author":{"id":2694205,"avatar":"https://static001.geekbang.org/account/avatar/00/29/1c/3d/76465ee4.jpg","nickname":"摘星","note":"","ucode":"55D8CAFC938F91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1243025,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f7/91/27401a3f.jpg","nickname":"kd叛逆","note":"","ucode":"F8870FBA8BB131","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404840,"discussion_content":"不停练习","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634434819,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":310375,"ip_address":""},"score":404840,"extra":""},{"author":{"id":2474580,"avatar":"https://static001.geekbang.org/account/avatar/00/25/c2/54/77dac43b.jpg","nickname":"UltramanTiga","note":"","ucode":"245D8768E5CCDD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1243025,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f7/91/27401a3f.jpg","nickname":"kd叛逆","note":"","ucode":"F8870FBA8BB131","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577641,"discussion_content":"用到的时候再复习会快一点就行了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656254255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":310375,"ip_address":""},"score":577641,"extra":""}]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":75838,"discussion_content":"咋说呢，算法有了思路，不一定能 代码实现，这是一个很重要的实操过程","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1575787388,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1243025,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f7/91/27401a3f.jpg","nickname":"kd叛逆","note":"","ucode":"F8870FBA8BB131","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310376,"discussion_content":"深有体会！！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601806152,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":75838,"ip_address":""},"score":310376,"extra":""}]},{"author":{"id":1243570,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f9/b2/2ed800b4.jpg","nickname":"社会你强哥","note":"","ucode":"325B9005588D9B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":195318,"discussion_content":"兄弟，代码是敲的，不是看的。等你敲不出来，看看你是否还有这种感受？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1583252457,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1000004,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/44/d3d67640.jpg","nickname":"Hills录","note":"","ucode":"779020947ACABA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42469,"discussion_content":"你自己实现的时候就愿意看了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1572676503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1018444,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/4c/d976b42c.jpg","nickname":"冯选刚","note":"","ucode":"A186F31A730F04","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1000004,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/44/d3d67640.jpg","nickname":"Hills录","note":"","ucode":"779020947ACABA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42548,"discussion_content":"🐷","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572694951,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":42469,"ip_address":""},"score":42548,"extra":""}]},{"author":{"id":1132312,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/18/293cd24d.jpg","nickname":"o0oi1i","note":"","ucode":"D1F6AD4AAEAFBE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260858,"discussion_content":"烧脑","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588908455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1504652,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f5/8c/82fb5890.jpg","nickname":"抱小星","note":"","ucode":"BA7B0DAFDA4AF5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":151916,"discussion_content":"代码是精华，能自己闭卷手写出代码，才算真正掌握一种算法。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1579917872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1189638,"avatar":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","nickname":"色即是空","note":"","ucode":"46B8975ED087B8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":12263,"discussion_content":"提醒我还是要看下代码，虽然理论容易理解","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568512375,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2449748,"avatar":"https://static001.geekbang.org/account/avatar/00/25/61/54/5bf767e7.jpg","nickname":"没有心的人","note":"","ucode":"F27D5894087B11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551384,"discussion_content":"代码还是要看的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645003876,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2708005,"avatar":"https://static001.geekbang.org/account/avatar/00/29/52/25/185763e4.jpg","nickname":"薇尔莉特","note":"","ucode":"1465A6F3005CA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386673,"discussion_content":"原理就是拿来运用在代码上的，能理解理论是一回事，能结合理论也看懂代码又是另一回事。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627718961,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1526355,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4a/53/063f9d17.jpg","nickname":"moonfox","note":"","ucode":"902BFF40EFA9FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362831,"discussion_content":"结合代码看的更通透","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617034726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1476588,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJayib1ZcRfOaoLsdsWZokiaO5tLAdC4uNAicQJRIVXrz9fIchib7QwXibnRrsJaoh5TUlia7faUf36g8Bw/132","nickname":"明月","note":"","ucode":"D3C649B954A519","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":82014,"discussion_content":"我刚好相反😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576309680,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":43571,"user_name":"insist","can_delete":false,"product_type":"c1","uid":1054536,"ip_address":"","ucode":"1EE2800A900BA7","user_header":"https://static001.geekbang.org/account/avatar/00/10/17/48/3ab39c86.jpg","comment_is_top":false,"comment_ctime":1543241219,"is_pvip":false,"replies":[{"id":"15589","content":"完全没关系的。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543284417,"ip_address":"","comment_id":43571,"utype":1}],"discussion_count":3,"race_medal":0,"score":"285011082755","product_id":100017301,"comment_content":"这种数据结构堆和java内存模型中的堆内存有什么关系呢？","like_count":66,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":430423,"discussion_content":"完全没关系的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1543284417,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1240490,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ed/aa/67fbccda.jpg","nickname":"soulful","note":"","ucode":"93105631E8106A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":279347,"discussion_content":"原来真没关系！解答了我的疑惑。我就是为了看js内存模型中的堆来的。发现没关系也挺开心的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591327784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1350662,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9c/06/f09b6248.jpg","nickname":"vate","note":"","ucode":"CF58A098791D06","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334665,"discussion_content":"哈哈哈哈哈哈哈,java内存堆","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607931912,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":43311,"user_name":"猫头鹰爱拿铁","can_delete":false,"product_type":"c1","uid":1105958,"ip_address":"","ucode":"24266B58968428","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/26/4942a09e.jpg","comment_is_top":false,"comment_ctime":1543211401,"is_pvip":true,"discussion_count":12,"race_medal":0,"score":"254946281865","product_id":100017301,"comment_content":"思考题1:堆是完全二叉树，求最后的非叶子节点即是求最大的叶子节点的父节点。最大的叶子节点下标为n，他的父节点为n&#47;2，这是最后一个非叶子节点，所以n&#47;2+1到n都是叶子节点。<br>思考题2:堆排序的应用-topk问题，例如求数据频率最高的k个数，建立k个数的最小顶堆，然后剩余数据和堆顶比较，如果比堆顶大则替换堆顶并重新调整最小顶堆。","like_count":60,"discussions":[{"author":{"id":1717444,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/34/c4/08d9f349.jpg","nickname":"元","note":"","ucode":"4576E15018EEA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":91340,"discussion_content":"第一题手动加精","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576828152,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2198755,"avatar":"https://static001.geekbang.org/account/avatar/00/21/8c/e3/b9e926f9.jpg","nickname":"面罩","note":"","ucode":"E85F2550D7C6D6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1717444,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/34/c4/08d9f349.jpg","nickname":"元","note":"","ucode":"4576E15018EEA3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392499,"discussion_content":"是的，解释的很到位","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631021019,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":91340,"ip_address":""},"score":392499,"extra":""}]},{"author":{"id":1583499,"avatar":"https://static001.geekbang.org/account/avatar/00/18/29/8b/3629c0f8.jpg","nickname":"游山行人","note":"","ucode":"E559BD0A3C6484","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":222340,"discussion_content":"咦最高频率不应该是大顶堆吗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586137178,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1532891,"avatar":"https://static001.geekbang.org/account/avatar/00/17/63/db/e562c15b.jpg","nickname":"依斯特","note":"","ucode":"40C7E079723DD5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1583499,"avatar":"https://static001.geekbang.org/account/avatar/00/18/29/8b/3629c0f8.jpg","nickname":"游山行人","note":"","ucode":"E559BD0A3C6484","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331376,"discussion_content":"如果是最大堆顶，那么就难以知道堆的最小值是哪一个叶子结点。如果是最小堆顶，那么堆的最小值一定在堆顶，每当有比堆顶大的元素加入堆，那么堆顶弹出，新元素加入堆，此时整个堆仍然是由最大的k个元素组成","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606837731,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":222340,"ip_address":""},"score":331376,"extra":""},{"author":{"id":1397872,"avatar":"https://static001.geekbang.org/account/avatar/00/15/54/70/bc8f1824.jpg","nickname":"哈哈","note":"","ucode":"BA32EA6844F201","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1532891,"avatar":"https://static001.geekbang.org/account/avatar/00/17/63/db/e562c15b.jpg","nickname":"依斯特","note":"","ucode":"40C7E079723DD5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345695,"discussion_content":"老师的文章不是说新元素插入是放在数组尾部吗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1611761396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":331376,"ip_address":""},"score":345695,"extra":""},{"author":{"id":2198755,"avatar":"https://static001.geekbang.org/account/avatar/00/21/8c/e3/b9e926f9.jpg","nickname":"面罩","note":"","ucode":"E85F2550D7C6D6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1397872,"avatar":"https://static001.geekbang.org/account/avatar/00/15/54/70/bc8f1824.jpg","nickname":"哈哈","note":"","ucode":"BA32EA6844F201","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392496,"discussion_content":"这个不算是往堆里面添加元素，而是用比堆更大的数替换堆顶元素，是替换！替换完毕，从上往下堆化，目的是保持堆顶元素为堆里面这 k 个元素的最小值。等后面所有的元素都处理完了，那么堆顶的元素就是第 k 大的元素。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1631020938,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":345695,"ip_address":""},"score":392496,"extra":""}]},{"author":{"id":1193468,"avatar":"https://static001.geekbang.org/account/avatar/00/12/35/fc/6d3e0035.jpg","nickname":"saber","note":"","ucode":"D02F8D129DB41C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5714,"discussion_content":"思考题 1 想的很简洁！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1566444235,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1193468,"avatar":"https://static001.geekbang.org/account/avatar/00/12/35/fc/6d3e0035.jpg","nickname":"saber","note":"","ucode":"D02F8D129DB41C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":75842,"discussion_content":"第一题回复 明显错误\n最后一个非叶子节点 和 最大的叶子节点 没有任何关系，不要想当然。。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575787942,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":5714,"ip_address":""},"score":75842,"extra":""},{"author":{"id":1993083,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/69/7b/27e63c55.jpg","nickname":"神的孩子在跳舞","note":"","ucode":"B99AC3DFFBEC72","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":276607,"discussion_content":"应该是最后一个叶节点","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590912870,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":75842,"ip_address":""},"score":276607,"extra":""},{"author":{"id":1939316,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/97/74/a933d664.jpg","nickname":"莜戏","note":"","ucode":"C3488A2BB44359","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343941,"discussion_content":"最大的叶子节点“下标”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611214459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":75842,"ip_address":""},"score":343941,"extra":""}]},{"author":{"id":1236781,"avatar":"https://static001.geekbang.org/account/avatar/00/12/df/2d/766c0947.jpg","nickname":"big Z","note":"","ucode":"54FEFD8DD1540F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":80942,"discussion_content":"((n-k)/2 + 1) + k/2 。\nk是去掉最后一层叶子节点的数量，先做加法交换再计算。\n先去掉最后一层叶子节点（即k），则叶子节点为(n-k)/2+1开始；\n加上k/2，最后一层的叶子节点会导致前面计算出来的叶子节点前面一部分（k/2）变为非叶子节点。\n先做加法交换再做计算是因为k可能是奇数，因此也可以这样：\n((n-k)/2 + 1) + k/2 + (k%2  == 1 ? 1 : 0)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576206007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":43235,"user_name":"无心拾贝","can_delete":false,"product_type":"c1","uid":1274394,"ip_address":"","ucode":"AE978F7E4B9C1D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/19KsZ5habYbIXVicKJB57au6311uHFPBy89rPicHTbBfFJA1TN2fcU4Hf0KSegRSSiaia2kxfvbDwAu5yb45NYyia0w/132","comment_is_top":false,"comment_ctime":1543198299,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"242061366875","product_id":100017301,"comment_content":"这TM估计是我唯一看的懂的数据结构与算法吧。 谢谢老师！ ","like_count":56,"discussions":[{"author":{"id":1112650,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fa/4a/8b4372a8.jpg","nickname":"阳.","note":"","ucode":"3D48CEA896FAE1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364243,"discussion_content":"听你这么一说，让原来并没看懂的我默默下定了一定要看懂的决心〔表情：尴尬了〕","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617419191,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1309592,"avatar":"https://static001.geekbang.org/account/avatar/00/13/fb/98/6f238b8e.jpg","nickname":"半个柚子","note":"","ucode":"CF5D1190D970A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":179825,"discussion_content":"数组和二分 不算数据结构与算法吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582255113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":70698,"user_name":"1024","can_delete":false,"product_type":"c1","uid":1086407,"ip_address":"","ucode":"DCC31F6EC54F43","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/c7/86352ccc.jpg","comment_is_top":false,"comment_ctime":1551166392,"is_pvip":false,"replies":[{"id":"25400","content":"👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551232481,"ip_address":"","comment_id":70698,"utype":1}],"discussion_count":8,"race_medal":0,"score":"143285087160","product_id":100017301,"comment_content":"思考题1证明<br>结论：对于完全二叉树来说，下标从(n&#47;2)+1到n都是叶子节点<br>证明：<br>假设堆有n个节点<br>假设满二叉树有h层 则满二叉树的总节点数  2^0+2^1...+2^(h-2)+2^(h-1)=(2^h)-1&gt; n n为h层完全二叉树节点数<br>堆为完全二叉树，相同高度，完全二叉树总结点数小于满二叉树节点数，即n&lt;(2^h)-1， 即(2^h)&gt;n+1 -----①<br>完全二叉树1到h-1层节点的数量总和： 2^0+2^1...+2^(h-2)=(2^(h-1))-1=(2^h)&#47;2 -1  -----②<br>如果数组的第0位也存储数据，由②可知，完全二叉树的第h层开始的节点的下标为i=(2^h)&#47;2 -1，由①，i&gt;((n+1)&#47;2)-1=(n&#47;2)+1<br>结论1：如果数组的第0位也存储数据，完全二叉树的节点下标至少开始于(n&#47;2)+1<br>如果数组的第0位不存储数据，则由②可知，完全二叉树的第h层开始的节点的下标为j=(2^h)&#47;2，由①，j&gt;(n+1)&#47;2=(n&#47;2)+2<br>结论2：如果数组的第0位不存储数据，完全二叉树的节点下标至少开始于(n&#47;2)+2<br>综上，堆（完全二叉树）的叶子节点的下标范围从(n&#47;2)+1到n-1或从(n&#47;2)+2到n，也即堆的叶子节点下标从(n&#47;2)+1到n<br>欢迎指正<br>--不为别的，就为成为更合格的自己","like_count":33,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440782,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551232481,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1127175,"avatar":"https://static001.geekbang.org/account/avatar/00/11/33/07/8f351609.jpg","nickname":"JustDoDT","note":"","ucode":"6AF0B80F00EAEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":23713,"discussion_content":"精炼一下\n2^h ≥ n+1 （证明参考最高赞1024同学的答案，满二叉树是完全二叉树的一个特例子集所以这里取＝）；\n最后一层开始于 2^h / 2 - 1 + 1 既最后一层第一个元素位置为2^h / 2 ；\n所以 最后一层第一个元素 ≥ n / 2 + 1/2；\n由于下标为整数 所以写成 ≥ n / 2 + 1；\n第0个位置不存元素，既列表下标和元素实际位置下标一一对应\n所以：思考题1得证","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1569860699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1498448,"avatar":"https://static001.geekbang.org/account/avatar/00/16/dd/50/8a4904c1.jpg","nickname":"绝艺","note":"","ucode":"E6AD129ABB2D79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":131823,"discussion_content":"请问为什么完全二叉树h-1层的节点就一定不是叶子节点？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578845548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2252211,"avatar":"https://static001.geekbang.org/account/avatar/00/22/5d/b3/aa2c17f0.jpg","nickname":"🔥 如初之光","note":"","ucode":"0FB2BA12D4B15A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":323065,"discussion_content":"想想你为什么干不过一楼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604881714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1512006,"avatar":"https://static001.geekbang.org/account/avatar/00/17/12/46/f361c795.jpg","nickname":"陈彬","note":"","ucode":"F7716B295D9613","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":12982,"discussion_content":"由①，i>((n+1)/2)-1=(n/2)+1  这个是错误的吧，((n+1)/2)-1=((n-1)/2)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568624231,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1086407,"avatar":"https://static001.geekbang.org/account/avatar/00/10/93/c7/86352ccc.jpg","nickname":"1024","note":"","ucode":"DCC31F6EC54F43","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1512006,"avatar":"https://static001.geekbang.org/account/avatar/00/17/12/46/f361c795.jpg","nickname":"陈彬","note":"","ucode":"F7716B295D9613","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":20278,"discussion_content":"这个地方确实写错了，多谢指正\n\n完全二叉树节点总数：n\n满二叉树h层节点总数：(2^h)-1\n有：n< (2^h)-1 即 2^h > n+1 ①\n完全二叉树h-1层节点总数：s = [2^(h-1)]-1 = [(2^h)/2] -1 \n由① s > [(n+1)/2]-1, 即 s > (n-1)/2\n完全二叉树非叶子节点个数大于(n-1)/2, 如果从数组的第1位开始存储，那么第一个叶子节点的下标为[(n-1)/2]+1=(n/2)+1/2, 所以结论：「下标从(n/2)+1到n 都是叶子节点」得到验证。同理，如果从第0位开始存储，第一个叶子节点的下标为(n/2)-1/2，(n/2)+1到n 都是叶子节点的结论同样也得到了验证","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1569297849,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":12982,"ip_address":""},"score":20278,"extra":""},{"author":{"id":2718869,"avatar":"https://static001.geekbang.org/account/avatar/00/29/7c/95/db224274.jpg","nickname":"Aurora.","note":"","ucode":"8A908805080E74","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1086407,"avatar":"https://static001.geekbang.org/account/avatar/00/10/93/c7/86352ccc.jpg","nickname":"1024","note":"","ucode":"DCC31F6EC54F43","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547729,"discussion_content":"完全二叉树的h层不满的话，h-1层也是存在叶子结点的吧，那你求得s怎么能代表非叶子结点总数呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642841551,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":20278,"ip_address":""},"score":547729,"extra":""}]},{"author":{"id":1193468,"avatar":"https://static001.geekbang.org/account/avatar/00/12/35/fc/6d3e0035.jpg","nickname":"saber","note":"","ucode":"D02F8D129DB41C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5715,"discussion_content":"我也是类似这么推导的，不过把范围去掉了，你可以在精确设置下倒数第二层，假设有 x 个节点有儿子节点，那么最后一层的叶子节点数量此时就是确定的（关于 x 的函数），然后非叶子节点同样是确定的个数，然后直接用总的节点数量 / 2 + 1 ，此时这个数就等于非叶子节点个数 + 1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566444466,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":43320,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1543212470,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"113212362166","product_id":100017301,"comment_content":"堆应该可以用于实现优先级队列。","like_count":26},{"had_liked":false,"id":44961,"user_name":"鲍勃","can_delete":false,"product_type":"c1","uid":1142312,"ip_address":"","ucode":"9B5E4A5B1A54E5","user_header":"https://static001.geekbang.org/account/avatar/00/11/6e/28/1e307312.jpg","comment_is_top":false,"comment_ctime":1543535432,"is_pvip":false,"replies":[{"id":"16029","content":"没关系 完全是两个东西","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543542681,"ip_address":"","comment_id":44961,"utype":1}],"discussion_count":2,"race_medal":0,"score":"78852946760","product_id":100017301,"comment_content":"linux内核内存中的堆和这个有关系吗？","like_count":18,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":430878,"discussion_content":"没关系 完全是两个东西","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543542681,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1113426,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fd/52/a138da39.jpg","nickname":"crazylle","note":"","ucode":"C336370E6E5A41","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352988,"discussion_content":"类似于java和javascript的关系","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614937958,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":43210,"user_name":"yaya","can_delete":false,"product_type":"c1","uid":1233856,"ip_address":"","ucode":"8C7FAC8F828BA4","user_header":"https://static001.geekbang.org/account/avatar/00/12/d3/c0/d38daa2d.jpg","comment_is_top":false,"comment_ctime":1543196239,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"57377771087","product_id":100017301,"comment_content":"最后一个结点的父节点是n&#47;2.这是最后一个非叶子结点所以，叶子结点是n&#47;2+1到n。<br>优先队列的实现用的就是堆","like_count":13},{"had_liked":false,"id":43250,"user_name":"Vinegar.","can_delete":false,"product_type":"c1","uid":1234957,"ip_address":"","ucode":"FEDBBAD54DB223","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/0d/bc1957cf.jpg","comment_is_top":false,"comment_ctime":1543200561,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"53082808113","product_id":100017301,"comment_content":"Java 中的 PriorityQueue 就是基于堆的数据结构的","like_count":12},{"had_liked":false,"id":49666,"user_name":".","can_delete":false,"product_type":"c1","uid":1194614,"ip_address":"","ucode":"2FBBAB303A4D5A","user_header":"https://static001.geekbang.org/account/avatar/00/12/3a/76/e9f18792.jpg","comment_is_top":false,"comment_ctime":1544751090,"is_pvip":false,"replies":[{"id":"17893","content":"嗯嗯 多谢指正","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1544753838,"ip_address":"","comment_id":49666,"utype":1}],"discussion_count":1,"race_medal":0,"score":"40199456754","product_id":100017301,"comment_content":"&quot;对堆顶节点进行堆化，会依次访问数组下标是 1，2，4，8&quot;。这里图画错了吧，数组下标2 (20)和数组下标3(21)的位置应该是弄反了。如果按原图对堆顶元素堆化的话顺序应该是1,3,6不应该是1,2,4,8<br>","like_count":9,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":432711,"discussion_content":"嗯嗯 多谢指正","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544753838,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":45160,"user_name":"李建轰","can_delete":false,"product_type":"c1","uid":1139732,"ip_address":"","ucode":"E5A68028AA29CD","user_header":"https://static001.geekbang.org/account/avatar/00/11/64/14/c696ff63.jpg","comment_is_top":false,"comment_ctime":1543552715,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"35903291083","product_id":100017301,"comment_content":"老师你好～<br>heapify方法好像有点问题？<br>假如第一个非叶子节点是5，左叶子节点是7，右叶子节点是6<br>然后入heapify方法的这段代码<br>```<br>while (true) {<br>    int maxPos = i;<br>    if (i*2 &lt;= n &amp;&amp; a[i] &lt; a[i*2]) maxPos = i*2;<br>    if (i*2+1 &lt;= n &amp;&amp; a[i] &lt; a[i*2+1]) maxPos = i*2+1<br>    if (maxPos == i) break;<br>    swap(a, i, maxPos);<br>    i = maxPos;<br>}<br>```<br>就会变成第一个非叶子节点是6，左叶子节点是7，右叶子节点是5，因为swap只会执行一次。<br>我觉得swap方法在前面两个if里面都得有，并且第二个if必须用if，不能用else if。<br>斗胆提问，请老师答疑～<br>","like_count":8,"discussions":[{"author":{"id":1042164,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/BDxD1k4ibAUPcljPLwgsnobjTfk2TxPTzCLps2uoGbD3HGIiaUF7XGLUnBArTyAySJzia0R6GRhroYwfyVwniaiaibzg/132","nickname":"灰灰灰","note":"","ucode":"519DB0429C4A80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2156,"discussion_content":"前面两个if条件里面应该分别是i*2 <= n &amp;&amp; a[maxPos] < a[i*2] 和i*2+1 <= n &amp;&amp; a[maxPos] < a[i*2+1]","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1563292439,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1351075,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a3/79fc9017.jpg","nickname":"minsky","note":"","ucode":"7296ECA064E89B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":80922,"discussion_content":"楼上的这个和作者的实现不同，建议看代码的时候看仔细一点。\n另外有些地方确实有些小问题，譬如从上至下堆化那里贴出的这个方法。\n\npublic void removeMax() {\n  if (count == 0) return -1; // 堆中没有数据 \n  a[1] = a[count]; --count;\n   heapify(a, count, 1);\n}\n\n明明是void方法，结果第一行判断就返回了-1...\n\n不过说明老师写代码思路是真的清晰啊，没有验证的代码也只是在主逻辑之外才有问题。\n","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1576204274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1458026,"avatar":"https://static001.geekbang.org/account/avatar/00/16/3f/6a/e68b9f23.jpg","nickname":"陈小狮","note":"","ucode":"7679BA5775DC9C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":262436,"discussion_content":"看了一下老师的代码没觉得有问题呀，老师的if比较里用的是a[maxPos]，第一个if判断完之后，假设左子节点比父节点大，暂时更新maxPos为左子节点，再判断第二个if，若右子节点的值>当前maxPos的值，更新maxPos为右子节点的索引。总的来说这两个if就是将左右两个子节点的最大的那个的索引赋值给maxPos，再进行swap操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589097517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":68404,"user_name":"『LHCY』","can_delete":false,"product_type":"c1","uid":1188449,"ip_address":"","ucode":"A8B5E0467B5F25","user_header":"https://static001.geekbang.org/account/avatar/00/12/22/61/bbfb2d4a.jpg","comment_is_top":false,"comment_ctime":1550496103,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"31615267175","product_id":100017301,"comment_content":"刚才面试遇到了这道题，不过没想起来","like_count":7,"discussions":[{"author":{"id":1324314,"avatar":"https://static001.geekbang.org/account/avatar/00/14/35/1a/9fa38dc9.jpg","nickname":"子瞻","note":"","ucode":"5C26FF10934534","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306356,"discussion_content":"啥问题呀？手写堆排序吗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600254584,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1782356,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/32/54/82c4fca9.jpg","nickname":"司徒","note":"","ucode":"4817C5DBA6564F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":120510,"discussion_content":"把问题说一下呀，大家一起学习一下\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578278872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1244341,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fc/b5/83fe873f.jpg","nickname":"uestc_dpz","note":"","ucode":"8906742B0EC520","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":115603,"discussion_content":"请教下具体啥问题？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578021766,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168000,"user_name":"注定非凡","can_delete":false,"product_type":"c1","uid":1113597,"ip_address":"","ucode":"80673056E131B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","comment_is_top":false,"comment_ctime":1577974030,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"27347777806","product_id":100017301,"comment_content":"一：如何理解“堆”<br>\t1，堆是一个完全二叉树；<br>\t\t完全二叉树要求除了最后一层，其他层的节点都是满的，最后一层的节点都靠左排列。<br>\t2，堆中每个节点都必须大于等于（或小于等于）其子树中每个节点的值。<br>\t\t堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值。<br>\t3，对于每个节点的值都大于等于子树中每个节点值的堆，叫作“大顶堆”。对于每个节点的值都小于等于子树中每个节点值的堆，叫“小顶堆”。<br><br>二：如何实现“堆”<br>\t要实现一个堆，要先知道堆都支持哪些操作，已及如何存储一个堆。<br>\t1，如何存储一个堆：<br>\t\t完全二叉树比较适合用数组来存储。用数组来存储完全二叉树是非常节省存储空间的。因为不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。<br>\t2，往堆中插入一个元素<br>\t\t往堆中插入一个元素后，需要继续满足堆的两个特性<br>\t\t（1）如果把新插入的元素放到堆的最后，则不符合堆的特性了，于是需要进行调整，让其重新满足堆的特性，这个过程叫做 堆化（heapify）<br>\t\t（2）堆化实际上有两种，从下往上和从上往下<br>\t\t（3）从下往上的堆化方法：<br>\t\t\t堆化非常简单，就是顺着节点所在的路径，向上或者向下，对比，然后交换。<br> <br>\t3，删除堆顶元素<br>\t\t（1）从堆的定义的第二条中，任何节点的值都大于等于（或小于等于）子树节点的值，则堆顶元素存储的就是堆中数据的最大值或最小值。<br>\t\t（2）假设是大顶堆，堆堆顶元素就是最大的元素，但删除堆顶元素之后，就需要把第二大元素放到堆顶，那第二大元素肯定会出现在左右子节点中。然后在迭代地删除第二大节点，以此类推，直到叶子节点被删除。<br><br>\t\t但这种方式会使堆化出来的堆不满足完全二叉树的特性<br>\t（3）可以把最后一个节点放到堆顶，然后利用同样的父子节点对比方法，对于不满足父子节点大小关系的，互换两个节点，并且重复进行这个过程，直到父子节点之间满足大小关系为止，这是从上往下的堆化方法。<br> <br>一个包含n个节点的完全二叉树，树的高度不会超过log2n。堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，即O(log n)。插入数据和删除堆顶元素的主要逻辑就是堆化，所以往堆中插入一个元素和删除堆顶元素的时间复杂度都是O(log n)。<br><br>三：如何基于堆实现排序<br>\t（1）排序方法有时间复杂度是O(n^2)的冒泡排序，插入排序，选择排序，有时间复杂度是O（nlogn）的归并排序，快速排序，线性排序。<br><br>\t（2）借助堆这种数据结构实现的排序算法就叫作堆排序，这种排序方法的时间复杂度非常稳定，是O(nlogn)，并且它还是原地排序算法。<br>\t\t堆排序的过程大致分解为两大步骤：建堆和排序<br>\t（3）建堆：<br>\t\t1，首先将数组原地建成一个堆。“原地”：是指不借助另一个数组，就在原地数组上操作。<br>\t\t2，建堆有两种思路：<br>\t\t\t第一种：在堆中插入一个元素的思路。<br>尽管数组中包含n个数据，但是可以假设起初堆中只包含一个数据，就是下标为1的数据。然后，调用插入方法，将将下标从2到n的数据依次插入到堆中，这样就将包含n个数据的数组，组织成了堆<br>\t\t\t第二种：是从后往前处理数组，并且每个数据都是从上往下堆化。<br>第二种和第一种思路截然相反，第一种建堆思路的处理过程是从前往后处理数据，并且每个数据插入堆中时，都是从下往上堆化。<br>对下标从n&#47;2开始到1的数据进行堆化，下标是n&#47;2 + 1到n的节点，是叶子节点，不需堆化<br>\t\t3，建堆的时间复杂度<br>\t\t每个节点堆化的时间复杂度是O(logn)，则n&#47;2+1个节点堆化的总时间复杂度是O(n)。<br>\t\t①：因为叶子节点不需要堆化，所以需要堆化的节点从倒数第二层开始。每个节点堆化的过程中，需要比较和交换的节点个数，跟这个节点高度k成正比。<br>\t（4）排序：<br>\t\t建堆结束后，数组中的数据已是按照大顶堆的特性来组织的。数组中的第一个元素就是堆顶，也就是最大的元素。<br>\t\t将它和最后一个元素交换，最大元素就放到了下标为n的位置<br>\t\t这个过程有点类似“删除堆顶元素”的操作，当堆顶元素移除后，把下标为n的元素放到堆顶，然后在通过堆化的方法，将剩下的n-1个元素重新构建成堆。堆化完成之后，在取堆顶元素，放到下标是n-1的位置，一直重复这个过程，直到最后堆中只剩下标为1的一个元素，排序工作就完成了。<br>\t<br>\t（5）时间，空间复杂度，以及稳定性分析<br>\t\t①：整个堆排序的过程，都只需要极个别临时存储空间，所以堆排序是原地排序算法。<br>\t\t②：堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是O(n)，排序过程的时间复杂度是O(nlogn),所以堆排序的时间复杂度是O(nlogn)<br>\t\t③：堆排序不是稳定的排序算法，可能改变值相等的数据原始相对顺序。<br>","like_count":7},{"had_liked":false,"id":48003,"user_name":"博予liutxer","can_delete":false,"product_type":"c1","uid":1290012,"ip_address":"","ucode":"6DC8C9493D1179","user_header":"https://static001.geekbang.org/account/avatar/00/13/af/1c/cca9209a.jpg","comment_is_top":false,"comment_ctime":1544317273,"is_pvip":false,"replies":[{"id":"17171","content":"时间复杂度比较稳定 有些排序函数会使用这种排序算法","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1544407141,"ip_address":"","comment_id":48003,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27314121049","product_id":100017301,"comment_content":"堆排序和快速排序相比实际开发中不如后者性能好，那堆排序在哪些场景比较有优势呢？","like_count":6,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431981,"discussion_content":"时间复杂度比较稳定 有些排序函数会使用这种排序算法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544407141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":149653,"user_name":"学个球","can_delete":false,"product_type":"c1","uid":1019725,"ip_address":"","ucode":"7343F3C0CA981D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8f/4d/65fb45e6.jpg","comment_is_top":false,"comment_ctime":1573304967,"is_pvip":false,"replies":[{"id":"57632","content":"因为交换完之后，只有那一个结点不符合堆的特性，需要处理，其他结点都满足堆的特性，所以只需要对这个结点进行heapify即可，不需要重新buildHeap","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1573424651,"ip_address":"","comment_id":149653,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23048141447","product_id":100017301,"comment_content":"本节的堆排序代码sort()方法，while循环体里，交换完堆尾和a[1]后，不应该是调用buildHeap()方法吗？文中的调用的是heapify(a, k, 1)，这个方法只是针对某个特定节点啊，没有操作整个堆。<br>望小争哥看一眼。","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473928,"discussion_content":"因为交换完之后，只有那一个结点不符合堆的特性，需要处理，其他结点都满足堆的特性，所以只需要对这个结点进行heapify即可，不需要重新buildHeap","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573424651,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":49774,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1544767740,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23019604220","product_id":100017301,"comment_content":"排序队------时间复杂度<br>堆满足两条：1、完全二叉树（可以很方便的使用数组存储），2、父节点大于或小于子节点-----<br>插入元素-先放入队尾，再进行堆化（heapify）<br>删除元素-从最后取一个元素放到删除元素位置，从上往下调整<br><br>快排比堆排性能好的原因有二：1、堆排序数据访问的方式有没有快速排序友好；<br>2、对于同样的数据，在排序的过程中堆排序算法的交换次数多于快速排序","like_count":5},{"had_liked":false,"id":49112,"user_name":"若星","can_delete":false,"product_type":"c1","uid":1247442,"ip_address":"","ucode":"D92DC0D777724E","user_header":"https://static001.geekbang.org/account/avatar/00/13/08/d2/83bdc5dd.jpg","comment_is_top":false,"comment_ctime":1544605893,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23019442373","product_id":100017301,"comment_content":"删除堆顶元素的代码第二行return -1。。","like_count":5},{"had_liked":false,"id":43224,"user_name":"fumeck.com🍋🌴summer sky","can_delete":false,"product_type":"c1","uid":1134567,"ip_address":"","ucode":"6349BF32257990","user_header":"https://static001.geekbang.org/account/avatar/00/11/4f/e7/7e51052a.jpg","comment_is_top":false,"comment_ctime":1543197650,"is_pvip":false,"replies":[{"id":"15600","content":"哈哈 弄混淆了  堆化是有两种方式：从上到下和从下到上，前面讲到了。我这里说的从下到上，是指的堆化操作本身。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543285464,"ip_address":"","comment_id":43224,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23018034130","product_id":100017301,"comment_content":"我们将下标从 n&#47;2 到 1的节点，依次进行从上到下的堆化操作<br>不是由下往上吗老师，最后一个才轮到根节点阿","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":430331,"discussion_content":"哈哈 弄混淆了  堆化是有两种方式：从上到下和从下到上，前面讲到了。我这里说的从下到上，是指的堆化操作本身。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543285464,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1042983,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/27/a3737d61.jpg","nickname":"Shanks-王冲","note":"","ucode":"C4B90A17850E20","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293848,"discussion_content":"#### 1.认清概念\n- 文章中“堆化实际上有两种，从下往上和从上往下。” -> bottom up(从下往上/自下往上堆化) 和 top-down(从上往下/自上往下堆化)；\n\n- 文章中“堆化非常简单，就是顺着节点所在的路径，**向上**或者**向下**，对比，然后交换。” -> siftUp(向上筛选 or 这句话中的“向上”) 或 siftDown(向下筛选 or 这句话中的“向下”)；\n\n- 插入操作：用子节点，和父节点比较，然后交换 —— 这是一次siftUp操作(堆化过程中最小执行单元)；继续向上，用新的子节点，和父节点比较，然后交换 —— 从下往上/自下往上堆化 —— 一次bottom up操作；\n\n- 删除堆顶元素：用父节点，和子节点比较，然后交换 —— 这是一次siftDown操作(堆化过程中最小执行单元)；继续向下，用新的父节点，和子节点比较，然后交换 —— 从上往下/自上往下堆化 —— 一次top-down操作；\n\n#### 2.发现规律\n- 插入操作 ~= bottom up =  n * siftUp；\n\n- 删除操作 ~= top-down =  n * siftDown；\n\n#### 3.解开谜团\n建堆，有两种思路 ——\n1. 第一种借助前面讲的，插入一个元素的思路。...依次插入元素，...，每个数据插入堆中时，从下往上堆化；“从下往上” -> 插入操作的bottom-up\n2. 第二种实现思路，...每个数据都是从上往下堆化；“从上往下” -> siftDown\n\nref: \n1. https://en.wikipedia.org/wiki/Heapsort\n2. 结合本文中的理解；","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595687771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76500,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1552620187,"is_pvip":false,"replies":[{"id":"28113","content":"第二种方法效率更高些。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1552874728,"ip_address":"","comment_id":76500,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18732489371","product_id":100017301,"comment_content":"建堆的过程采用方法1与方法2，在实际应用有区别吗？","like_count":4,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443330,"discussion_content":"第二种方法效率更高些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552874728,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57575,"user_name":"痛改前非","can_delete":false,"product_type":"c1","uid":1005412,"ip_address":"","ucode":"4509CB0BB892EE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/64/064dc124.jpg","comment_is_top":false,"comment_ctime":1546840227,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18726709411","product_id":100017301,"comment_content":"这一节课看了两遍，看得清清楚楚，明明白白😊","like_count":4},{"had_liked":false,"id":43176,"user_name":"P@tricK","can_delete":false,"product_type":"c1","uid":1233716,"ip_address":"","ucode":"293B2B3261A793","user_header":"https://static001.geekbang.org/account/avatar/00/12/d3/34/5dee4f70.jpg","comment_is_top":false,"comment_ctime":1543194437,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18723063621","product_id":100017301,"comment_content":"1. 因为完全二叉树最后一层的叶子节点是靠左的，所以，它的最后一个叶子就是数组的最后一个元素，其父节点编号为n&#47;2。<br><br>因此2&#47;n + 1到末尾都是叶子节点","like_count":4},{"had_liked":false,"id":206781,"user_name":"ZMH.","can_delete":false,"product_type":"c1","uid":1753115,"ip_address":"","ucode":"D45D6CEDFDF8F5","user_header":"https://static001.geekbang.org/account/avatar/00/1a/c0/1b/319baf9d.jpg","comment_is_top":false,"comment_ctime":1586934195,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"14471836083","product_id":100017301,"comment_content":"姜威同学呢,好久不见了","like_count":3,"discussions":[{"author":{"id":1939316,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/97/74/a933d664.jpg","nickname":"莜戏","note":"","ucode":"C3488A2BB44359","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381383,"discussion_content":"可能改名为 &#34;注定非凡&#34; 了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625035401,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1016276,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/81/d4/e92abeb4.jpg","nickname":"Jecy-8","note":"","ucode":"2AE1575B9E63A6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365730,"discussion_content":"哈哈哈哈哈😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617872286,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2318781,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/fKD3fHiaJajYHkBNnLBYb40ggEqA5lykW4jrqHvXtiap2rPmq8Cj7pj4nTU7BdqHTIzIRKRt5mylnucgwibOZ2Z9g/132","nickname":"cyan-mountain","note":"","ucode":"2797C0D846130C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339258,"discussion_content":"哈哈哈，蹲一个 姜威同学，大家想念你了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609581730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018620,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/fc/d1dd57dd.jpg","nickname":"ipofss","note":"","ucode":"DE3061C9259F9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":259836,"discussion_content":"我也等着看他的笔记呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588823364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85482,"user_name":"H.L.","can_delete":false,"product_type":"c1","uid":1207529,"ip_address":"","ucode":"125D13548A0CA5","user_header":"https://static001.geekbang.org/account/avatar/00/12/6c/e9/377a3b09.jpg","comment_is_top":false,"comment_ctime":1555073823,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14439975711","product_id":100017301,"comment_content":"第一题：Jerry银银到证明是不充分的，2&#47;n+1到n是叶子节点证明了，没证明1～2&#47;n不是叶子节点。<br>我想到一个思路：<br>step1: 满二叉树的情况，是符合的。用等比数列求和很容易证明最后一层是 2&#47;n+1到n<br>step2:在满二叉树到基础上，在下一层再添加若干个节点，添加完之后还要满足完全二叉树，这个也很容易证明","like_count":3},{"had_liked":false,"id":52764,"user_name":"qinggeouye","can_delete":false,"product_type":"c1","uid":1251536,"ip_address":"","ucode":"5B53EEDD7BEC9C","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/d0/49b06424.jpg","comment_is_top":false,"comment_ctime":1545507683,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14430409571","product_id":100017301,"comment_content":"重点：父节点和它的左右子节点比较大小关系，并交换。<br>对于某个节点：<br>从上往下堆化，时间复杂度和高度成正比<br>从下往上堆化，时间复杂度和深度成正比","like_count":3},{"had_liked":false,"id":49149,"user_name":"Jalyn","can_delete":false,"product_type":"c1","uid":1324026,"ip_address":"","ucode":"3878192B80FCC2","user_header":"https://static001.geekbang.org/account/avatar/00/14/33/fa/8a5167cd.jpg","comment_is_top":false,"comment_ctime":1544611202,"is_pvip":false,"replies":[{"id":"17730","content":"嗯嗯 是的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1544666183,"ip_address":"","comment_id":49149,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14429513090","product_id":100017301,"comment_content":"因为叶子节点往下堆化只能自己跟自己比较，所以我们直接从第一个非叶子节点开始，依次堆化就行了。<br>这边应该是最后一个非叶子节点吧？ <br>","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":432501,"discussion_content":"嗯嗯 是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544666183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143990,"user_name":"苦行僧","can_delete":false,"product_type":"c1","uid":1055334,"ip_address":"","ucode":"726024A9A9CF44","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/66/2d9db9ed.jpg","comment_is_top":false,"comment_ctime":1571821470,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10161756062","product_id":100017301,"comment_content":"堆不一定是完全二叉树, 只有二叉堆才是完全二叉树或近似完全二叉树.<br>https:&#47;&#47;zh.wikipedia.org&#47;wiki&#47;%E4%BA%8C%E5%8F%89%E5%A0%86<br>维基百科定义","like_count":2,"discussions":[{"author":{"id":2695483,"avatar":"https://static001.geekbang.org/account/avatar/00/29/21/3b/7f01e158.jpg","nickname":"陈志男","note":"","ucode":"4831554F6AC2C7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585293,"discussion_content":"国内外定义不一样 按着国内即可","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661471058,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":80506,"user_name":"小二黑","can_delete":false,"product_type":"c1","uid":1129293,"ip_address":"","ucode":"0ABA7FF670BD8C","user_header":"https://static001.geekbang.org/account/avatar/00/11/3b/4d/6523ab1c.jpg","comment_is_top":false,"comment_ctime":1553671944,"is_pvip":false,"replies":[{"id":"29372","content":"if判断是什么意思呢","user_name":"作者回复","user_name_real":"王争-公众号小争哥","uid":"1190123","ctime":1553736277,"ip_address":"","comment_id":80506,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10143606536","product_id":100017301,"comment_content":"老师，请问堆化自上而下，那段代码，节点和子节点比较大小，是用if判断的吗","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444885,"discussion_content":"if判断是什么意思呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553736277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":69535,"user_name":"krauser","can_delete":false,"product_type":"c1","uid":1219733,"ip_address":"","ucode":"13E5CB0ECF1613","user_header":"https://static001.geekbang.org/account/avatar/00/12/9c/95/edbb01ae.jpg","comment_is_top":false,"comment_ctime":1550761393,"is_pvip":false,"replies":[{"id":"24705","content":"实际上就是图的存储方式，可以是邻接表、邻接矩阵。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1550802220,"ip_address":"","comment_id":69535,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10140695985","product_id":100017301,"comment_content":"老师，我有个问题，一度关联人，二度关联人，这种查询是方便，但是他们的关系维护，就是图的建立怎么操作","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440159,"discussion_content":"实际上就是图的存储方式，可以是邻接表、邻接矩阵。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550802220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57086,"user_name":"痛改前非","can_delete":false,"product_type":"c1","uid":1005412,"ip_address":"","ucode":"4509CB0BB892EE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/64/064dc124.jpg","comment_is_top":false,"comment_ctime":1546618507,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10136553099","product_id":100017301,"comment_content":"老师，“我们将每个非叶子节点的高度求和，就是下面这个公式”，这个公式的末尾部分2^(h-1) * 1应该是不需要的吧，因为这个2^(h-1) * 1是最底层叶子节点的高度。","like_count":2,"discussions":[{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295164,"discussion_content":"错，这个是倒数第2层的高度，高度是从0开始算的，倒数第2层高度为1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596107483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":56988,"user_name":"惟新","can_delete":false,"product_type":"c1","uid":1037553,"ip_address":"","ucode":"93D07C4D97F7AD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d4/f1/c06aa702.jpg","comment_is_top":false,"comment_ctime":1546594110,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10136528702","product_id":100017301,"comment_content":"好久没看了，又开始重新看了。另外还在线画了思维导图。","like_count":2},{"had_liked":false,"id":55914,"user_name":"匆匆","can_delete":false,"product_type":"c1","uid":1333414,"ip_address":"","ucode":"4DB39C6CD5743B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/H8NxrljQXliccaT5fjdXJQYS3ou3Z9ykAuKw6EgicicEA9L4jQLz3h85P0odgDSaK0cA9oTyUKibbiagdNvnHuuV5mQ/132","comment_is_top":false,"comment_ctime":1546346275,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10136280867","product_id":100017301,"comment_content":"堆——一种特殊的树。<br><br>什么是堆：1、堆是一种完全二叉树；2、堆中每个节点的值都大于等于（或者小于等于）其子树中每个节点的值。所以对于根节点最大的堆我们叫“大顶堆”，反之叫“小顶堆”。<br><br>堆中插入元素：将元素插入到堆的最后。然后从下向上进行堆化（不断的与父节点比较然后交换）。<br><br>删除堆顶元素：将树的最后一个元素替换掉最大的节点（即根节点），然后从上往下进行堆化（不断的与子节点进行比较然后交换）。<br><br>我们知道树的高度不会超过logn，所以堆化是和树的高度成正比，即插入和删除的时间复杂度都是O(logn)。<br><br>如何基于堆实现排序？<br>首先，建堆：<br>1、第一种思路是起初堆中只含有一个元素，然后一个一个往堆里插入，插入一个堆化一个即可。<br>2、第二种思路是已经建好了堆（存在数组中），从数组中间下标开始到下标为0的顺序堆化（即从倒数第二层节点开始判断，每个节点与其子节点比较然后交换）。<br>然后，排序：<br>上一步的建堆完成后，数据已经是按照大顶堆（或小顶堆）特性组织的了，即顶部元素最大（或最小），接下来每次取树的堆顶元素和堆的最后一个元素交换，然后堆化，然后再取堆顶交换，再堆化，循环到堆中只剩最后一个元素，排序完成。<br><br>堆排序的时间复杂度度是稳定的O(nlogn)，且是原地排序算法。但是快排要比堆排序性能好，为什么？两点原因：<br>1、快排是局部顺序访问，堆排序是跳着访问，堆cpu缓存不友好。<br>2、同样的数据，堆排序的交换次数要更多 。","like_count":2},{"had_liked":false,"id":46998,"user_name":"arebya","can_delete":false,"product_type":"c1","uid":1142802,"ip_address":"","ucode":"074ECE8D6C1874","user_header":"https://static001.geekbang.org/account/avatar/00/11/70/12/aa74da82.jpg","comment_is_top":false,"comment_ctime":1544016345,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10133950937","product_id":100017301,"comment_content":"jdk里的PriorityQueue机制类似","like_count":2},{"had_liked":false,"id":46493,"user_name":"程序员大天地","can_delete":false,"product_type":"c1","uid":1249001,"ip_address":"","ucode":"7A21F15FEE2D5B","user_header":"https://static001.geekbang.org/account/avatar/00/13/0e/e9/98b6ea61.jpg","comment_is_top":false,"comment_ctime":1543930534,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10133865126","product_id":100017301,"comment_content":"讲得太清楚了，谢谢老师！","like_count":2},{"had_liked":false,"id":46105,"user_name":"Mr.M","can_delete":false,"product_type":"c1","uid":1243730,"ip_address":"","ucode":"C32AE0A9CD6EEF","user_header":"https://static001.geekbang.org/account/avatar/00/12/fa/52/4781da3f.jpg","comment_is_top":false,"comment_ctime":1543847392,"is_pvip":false,"replies":[{"id":"16526","content":"你可以根据图自己画下堆化的过程 是不是走过的路径就是下标为1 2 4 8的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543887735,"ip_address":"","comment_id":46105,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10133781984","product_id":100017301,"comment_content":"比如下面这个例子，对堆顶节点进行堆化，会依次访问数组下标是 1，2，4，8的元素，为什么是这种访问顺序？","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431336,"discussion_content":"你可以根据图自己画下堆化的过程 是不是走过的路径就是下标为1 2 4 8的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543887735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":44787,"user_name":"hot","can_delete":false,"product_type":"c1","uid":1237803,"ip_address":"","ucode":"567921754BE860","user_header":"https://static001.geekbang.org/account/avatar/00/12/e3/2b/c6de8f27.jpg","comment_is_top":false,"comment_ctime":1543492786,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10133427378","product_id":100017301,"comment_content":"每个节点堆化的过程中，需要比较和交换的节点个数，跟这个节点的高度 k 成正比？没看懂啊。<br><br><br><br>","like_count":2},{"had_liked":false,"id":44235,"user_name":"他在她城断了弦","can_delete":false,"product_type":"c1","uid":1242521,"ip_address":"","ucode":"3D91CA87B64C8B","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/99/454b17c1.jpg","comment_is_top":false,"comment_ctime":1543391247,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10133325839","product_id":100017301,"comment_content":"面向对象语言中的优先队列，如C++中的priority_queue就是用堆实现的","like_count":2},{"had_liked":false,"id":44104,"user_name":"William","can_delete":false,"product_type":"c1","uid":1241365,"ip_address":"","ucode":"4499F99B180102","user_header":"https://static001.geekbang.org/account/avatar/00/12/f1/15/8fcf8038.jpg","comment_is_top":false,"comment_ctime":1543369300,"is_pvip":true,"replies":[{"id":"15778","content":"没啥关系","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543404094,"ip_address":"","comment_id":44104,"utype":1}],"discussion_count":1,"race_medal":2,"score":"10133303892","product_id":100017301,"comment_content":"问个问题，堆内存和堆这种数据结构有联吗？一直比较疑惑为什么这么取名子","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":430629,"discussion_content":"没啥关系","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543404094,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":44037,"user_name":"醉比","can_delete":false,"product_type":"c1","uid":1248399,"ip_address":"","ucode":"79E65F62BE7809","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/8f/4ebd303a.jpg","comment_is_top":false,"comment_ctime":1543366075,"is_pvip":false,"replies":[{"id":"15710","content":"没看到啊","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543370271,"ip_address":"","comment_id":44037,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10133300667","product_id":100017301,"comment_content":"老师，removeMax的那个方法，为什么void方法会return -1呐，是写错了嘛","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":430607,"discussion_content":"没看到啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543370271,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1542987,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","nickname":"行则将至","note":"","ucode":"DB972F2DF059C4","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580805,"discussion_content":"我看着也是有问题。不过不重要，只是一个校验而已。看重点吧。😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658379883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":43756,"user_name":"benying","can_delete":false,"product_type":"c1","uid":1247522,"ip_address":"","ucode":"DEBAB485F381CC","user_header":"https://static001.geekbang.org/account/avatar/00/13/09/22/22c0c4fa.jpg","comment_is_top":false,"comment_ctime":1543288120,"is_pvip":true,"replies":[{"id":"15787","content":"王锦 有人夸你","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543404723,"ip_address":"","comment_id":43756,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10133222712","product_id":100017301,"comment_content":"再补一句，配图画的尤其好，O(∩_∩)O哈哈~","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":430484,"discussion_content":"王锦 有人夸你","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543404723,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":43282,"user_name":"虾米酥","can_delete":false,"product_type":"c1","uid":1096396,"ip_address":"","ucode":"311C8F6158A4CA","user_header":"https://static001.geekbang.org/account/avatar/00/10/ba/cc/afb168ce.jpg","comment_is_top":false,"comment_ctime":1543205333,"is_pvip":false,"replies":[{"id":"15596","content":"嗯嗯 已更正","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543285186,"ip_address":"","comment_id":43282,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10133139925","product_id":100017301,"comment_content":"建堆时间复杂度分析，是不是应该是s=s2-s1=-h……","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":430348,"discussion_content":"嗯嗯 已更正","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543285186,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253777,"user_name":"Fire","can_delete":false,"product_type":"c1","uid":2057513,"ip_address":"","ucode":"8D3E102E690443","user_header":"https://static001.geekbang.org/account/avatar/00/1f/65/29/8c0fe011.jpg","comment_is_top":false,"comment_ctime":1602865697,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"5897832993","product_id":100017301,"comment_content":"        建堆时，文中讲的是第二种方法，是采用递归树计算的时间复杂度。第一种方式也可以用递归树推算推断：S = 2^0 + 2^1 * 2 + 2^2 * 3 + ...... + 2^(h-1) * h。<br>计算得到时间复杂度为：n*log2​n - n +1，时间复杂度比第二中高。<br>        同理，文中没有讲建堆后排序过程的时间复杂度的推断过程。这个过程也可以使用递归树的方式。S = 2^0 + 2^1 * 2 + 2^2 * 3 + ...... + 2^(h-1) * h. 计算得到时间复杂度为：n*log2​n - n +1。","like_count":1},{"had_liked":false,"id":244730,"user_name":"对白","can_delete":false,"product_type":"c1","uid":1268797,"ip_address":"","ucode":"3183E5ADBC794B","user_header":"https://static001.geekbang.org/account/avatar/00/13/5c/3d/e8325811.jpg","comment_is_top":false,"comment_ctime":1598636269,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5893603565","product_id":100017301,"comment_content":"下标从0开始好理解，从1开始的话代码写起来还很复杂，需要在列表开头添加占位元素，显得很麻烦，而且从0开始存根节点还不浪费0这个存储位置，从1开始存根节点还浪费0这个存储位置， 综上，还是使用0来存储根节点比较好！","like_count":1},{"had_liked":false,"id":239892,"user_name":"whyly","can_delete":false,"product_type":"c1","uid":1798882,"ip_address":"","ucode":"D34D6B7164C982","user_header":"https://static001.geekbang.org/account/avatar/00/1b/72/e2/95b0543c.jpg","comment_is_top":false,"comment_ctime":1596685548,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5891652844","product_id":100017301,"comment_content":"老师，如果将数组从小到大排序，是不是可以构造小顶堆，每次堆顶元素就是最小的，不需要和后面的元素交换。","like_count":1},{"had_liked":false,"id":225834,"user_name":"Geek_69cfd7","can_delete":false,"product_type":"c1","uid":2007777,"ip_address":"","ucode":"BFC4B586FA65F7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/orTaVwTib3ribTl5wibBQPniclzNVJMXCDw4ic4P2Q3A6MBEyuqg5AY46o4SPmIKm8vgIqnUzzqbEhIfQRQBtY7q6JQ/132","comment_is_top":false,"comment_ctime":1591868866,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5886836162","product_id":100017301,"comment_content":"请问为啥建堆时大顶堆，排序要排成小顶堆","like_count":1},{"had_liked":false,"id":206424,"user_name":"(Kelen)","can_delete":false,"product_type":"c1","uid":1241185,"ip_address":"","ucode":"C8578DB62E3B2D","user_header":"https://static001.geekbang.org/account/avatar/00/12/f0/61/fedca2e9.jpg","comment_is_top":false,"comment_ctime":1586859068,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5881826364","product_id":100017301,"comment_content":"堆的代码从下标0开始，其实好理解一些","like_count":1},{"had_liked":false,"id":190921,"user_name":"王木杉","can_delete":false,"product_type":"c1","uid":1628501,"ip_address":"","ucode":"712288EE2A3F4B","user_header":"https://static001.geekbang.org/account/avatar/00/18/d9/55/bd65c4df.jpg","comment_is_top":false,"comment_ctime":1584709376,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879676672","product_id":100017301,"comment_content":"c++ priority_queue<br>https:&#47;&#47;en.cppreference.com&#47;w&#47;cpp&#47;container&#47;priority_queue<br>Go  heap<br>https:&#47;&#47;golang.google.cn&#47;pkg&#47;container&#47;heap&#47;","like_count":1},{"had_liked":false,"id":189613,"user_name":"问心","can_delete":false,"product_type":"c1","uid":1250775,"ip_address":"","ucode":"6808568D61CE36","user_header":"https://static001.geekbang.org/account/avatar/00/13/15/d7/96e77edd.jpg","comment_is_top":false,"comment_ctime":1584534327,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5879501623","product_id":100017301,"comment_content":"网络异步IO中的超时回调，很多是通过最小堆实现的","like_count":1},{"had_liked":false,"id":173375,"user_name":"Geek_b617bf","can_delete":false,"product_type":"c1","uid":1220552,"ip_address":"","ucode":"9BAFC3B184B1D2","user_header":"https://static001.geekbang.org/account/avatar/00/12/9f/c8/0318c83e.jpg","comment_is_top":false,"comment_ctime":1579514331,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5874481627","product_id":100017301,"comment_content":"计算堆化复杂度那里的错位相减法,瞬间回到高中时代哈哈","like_count":1},{"had_liked":false,"id":137813,"user_name":"JustDoDT","can_delete":false,"product_type":"c1","uid":1127175,"ip_address":"","ucode":"6AF0B80F00EAEF","user_header":"https://static001.geekbang.org/account/avatar/00/11/33/07/8f351609.jpg","comment_is_top":false,"comment_ctime":1569860726,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5864828022","product_id":100017301,"comment_content":"精炼一下<br>2^h ≥ n+1 （证明参考最高赞1024同学的答案，满二叉树是完全二叉树的一个特例子集所以这里取＝）；<br>最后一层开始于 2^h &#47; 2 - 1 + 1 既最后一层第一个元素位置为2^h &#47; 2 ；<br>所以 最后一层第一个元素 ≥ n &#47; 2 + 1&#47;2；<br>由于下标为整数 所以写成 ≥ n &#47; 2 + 1；<br>第0个位置不存元素，既列表下标和元素实际位置下标一一对应<br>所以：思考题1得证","like_count":1},{"had_liked":false,"id":115871,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1563760264,"is_pvip":false,"replies":[{"id":"42885","content":"1. 每个节点的高度并不一样，你要区别树和节点的高度。<br>2. 把节点从航往下堆化的过程，执行的操作频度跟节点的高度k成正比。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1564008789,"ip_address":"","comment_id":115871,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5858727560","product_id":100017301,"comment_content":"“因为叶子节点不需要堆化，所以需要堆化的节点从倒数第二层开始。每个节点堆化的过程中，需要比较和交换的节点个数，跟这个节点的高度k成正比。”<br>————————————————<br>节点高度不是h吗？而且成正比这个不是很明白什么意思？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459322,"discussion_content":"1. 每个节点的高度并不一样，你要区别树和节点的高度。\n2. 把节点从航往下堆化的过程，执行的操作频度跟节点的高度k成正比。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564008789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87879,"user_name":"Gavin黄炯鹏","can_delete":false,"product_type":"c1","uid":1347154,"ip_address":"","ucode":"853CDA740D5ABD","user_header":"https://static001.geekbang.org/account/avatar/00/14/8e/52/677d9d1a.jpg","comment_is_top":false,"comment_ctime":1555740500,"is_pvip":false,"replies":[{"id":"31649","content":"看文章中的分析","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1555804615,"ip_address":"","comment_id":87879,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5850707796","product_id":100017301,"comment_content":"建堆的时间复杂度是O(n)，排序可以看作是n个点的建堆，怎么时间复杂度算出来是O(nlogn)，而不是O(n2)呢？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447635,"discussion_content":"看文章中的分析","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555804615,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85728,"user_name":"Lucus","can_delete":false,"product_type":"c1","uid":1198800,"ip_address":"","ucode":"CE8EB70CB9D9F1","user_header":"https://static001.geekbang.org/account/avatar/00/12/4a/d0/d319c44a.jpg","comment_is_top":false,"comment_ctime":1555214649,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5850181945","product_id":100017301,"comment_content":"反证法，如果下标n&#47;2+1不是叶子结点那么它肯定有子结点，那么子结点下标最小也是n+2，超出了数组的长度","like_count":1},{"had_liked":false,"id":77452,"user_name":"乐凡","can_delete":false,"product_type":"c1","uid":1239260,"ip_address":"","ucode":"918C9997EB6537","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/dc/32e78f02.jpg","comment_is_top":false,"comment_ctime":1552928381,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5847895677","product_id":100017301,"comment_content":"1、根据二叉树的定义，若是特殊的满二叉树，这个简单，最后一层全是叶子节点，最后一层的第一个节点的下标为就为n&#47;2 + 1；若不是满二叉树，根据二叉树的定义，倒数第二层节点都存在。倒数第二层的第一个不存在子节点的下标为x，暂且叫A节点把，A节点左边节点的子节点的下标就是n，该子节点若是只有左子节点，则2x = n + 2,x = n &#47; 2 + 1;若该子节点存在右子节点，则2x = n + 1，x = n &#47; 2 + 1 &#47; 2;该计算在计算机中等价于x = n &#47; 2 + 1;","like_count":1},{"had_liked":false,"id":76486,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1552618472,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5847585768","product_id":100017301,"comment_content":"堆可以应用于优先队列的场景，动态的取出排在前面的数据。","like_count":1},{"had_liked":false,"id":70590,"user_name":"晓龙","can_delete":false,"product_type":"c1","uid":1004576,"ip_address":"","ucode":"78CDCEBD183D3A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/20/93c79f7c.jpg","comment_is_top":false,"comment_ctime":1551144448,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5846111744","product_id":100017301,"comment_content":"每一层比上一层多*2 ，最后一层的个数就是比之前的总数*2<br>","like_count":1},{"had_liked":false,"id":68265,"user_name":"泉","can_delete":false,"product_type":"c1","uid":1099760,"ip_address":"","ucode":"914709BE802A8D","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/f0/aa2e0749.jpg","comment_is_top":false,"comment_ctime":1550472247,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5845439543","product_id":100017301,"comment_content":"堆排序:建堆+排序。","like_count":1},{"had_liked":false,"id":67423,"user_name":"Thinking","can_delete":false,"product_type":"c1","uid":1155754,"ip_address":"","ucode":"1AAD6AE9F6B678","user_header":"https://static001.geekbang.org/account/avatar/00/11/a2/aa/bf65e8be.jpg","comment_is_top":false,"comment_ctime":1550143090,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5845110386","product_id":100017301,"comment_content":"很细致，期待老师更多干货和思考","like_count":1},{"had_liked":false,"id":64919,"user_name":"Geek_870a2b","can_delete":false,"product_type":"c1","uid":1396878,"ip_address":"","ucode":"E8DFCAE8572392","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/xpAsb3hl87UbMPCkYhgdvJue8Hj7CqHfEO9KtMp0MictkUicm2u1zcfK0CgIp3iaZG5r3dAluib7VtzIfPuiccQFx4g/132","comment_is_top":false,"comment_ctime":1548974911,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5843942207","product_id":100017301,"comment_content":"我还以为有视频呢","like_count":1},{"had_liked":false,"id":63197,"user_name":"曹宇","can_delete":false,"product_type":"c1","uid":1354271,"ip_address":"","ucode":"0CDF9B3806FB32","user_header":"https://static001.geekbang.org/account/avatar/00/14/aa/1f/38b1bb9e.jpg","comment_is_top":false,"comment_ctime":1548296878,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5843264174","product_id":100017301,"comment_content":"第一题:<br>可以使用反证法。<br><br>如果n&#47;2+1是非叶子结点，则其一定存在叶子结点，则其叶子结点下标为（n&#47;2+1)*2=n+2, 这与数组下标范围相矛盾，所以n&#47;2+1是叶子结点，同理可证下标n&#47;2+2 到n的结点也为叶子结点。<br><br>","like_count":1},{"had_liked":false,"id":62274,"user_name":"下完这场雨","can_delete":false,"product_type":"c1","uid":1259348,"ip_address":"","ucode":"4A60E1DE92C96B","user_header":"https://static001.geekbang.org/account/avatar/00/13/37/54/4e017958.jpg","comment_is_top":false,"comment_ctime":1547999258,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5842966554","product_id":100017301,"comment_content":"老师，github上能给个java版本的堆排序实现吗~~","like_count":1},{"had_liked":false,"id":61223,"user_name":"有朋自远方来","can_delete":false,"product_type":"c1","uid":1083600,"ip_address":"","ucode":"23A12829DEB119","user_header":"https://static001.geekbang.org/account/avatar/00/10/88/d0/6e75f766.jpg","comment_is_top":false,"comment_ctime":1547640464,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5842607760","product_id":100017301,"comment_content":"堆，为什么没有用量变实现？如果用数组实现，插入、删除的时候，整理内存，会不会出现整体移动的问题？","like_count":1},{"had_liked":false,"id":60556,"user_name":"kylexy_0817","can_delete":false,"product_type":"c1","uid":1068372,"ip_address":"","ucode":"392DD9DD5E4B6E","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/54/9c214885.jpg","comment_is_top":false,"comment_ctime":1547512219,"is_pvip":false,"replies":[{"id":"23151","content":"n&#47;2表示结果向下取整的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1549179356,"ip_address":"","comment_id":60556,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5842479515","product_id":100017301,"comment_content":"老师，你的文章我每篇都会仔细阅读，弄懂原理后再读一下一篇，所以目前才读到这篇。在这里有个地方卡住，n个节点，那下标为n&#47;2的节点，不就会出现下标不为整数的情况吗？望指教","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436537,"discussion_content":"n/2表示结果向下取整的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549179356,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":60383,"user_name":"M","can_delete":false,"product_type":"c1","uid":1238308,"ip_address":"","ucode":"DFEA2ECECFAA6E","user_header":"https://static001.geekbang.org/account/avatar/00/12/e5/24/753e7a29.jpg","comment_is_top":false,"comment_ctime":1547467039,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5842434335","product_id":100017301,"comment_content":"老师讲的很明白，看得懂","like_count":1},{"had_liked":false,"id":58058,"user_name":"Alexis何春光","can_delete":false,"product_type":"c1","uid":1181149,"ip_address":"","ucode":"614570FAE3B56A","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/dd/b201cf13.jpg","comment_is_top":false,"comment_ctime":1546974802,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5841942098","product_id":100017301,"comment_content":"排序过程中的时间复杂度可以细化为 log(1) + log(2) + ... + log(n-1) + log(n) = log(n!) = Θ(n·log(n))。不知道这个思路对不对呢？","like_count":1},{"had_liked":false,"id":56958,"user_name":"不似旧日","can_delete":false,"product_type":"c1","uid":1161271,"ip_address":"","ucode":"DF4C5E3AB9570C","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","comment_is_top":false,"comment_ctime":1546586839,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5841554135","product_id":100017301,"comment_content":"好难哦,我怕了<br>","like_count":1},{"had_liked":false,"id":52528,"user_name":"空白","can_delete":false,"product_type":"c1","uid":1084378,"ip_address":"","ucode":"1E1E05CF8A7B1B","user_header":"https://static001.geekbang.org/account/avatar/00/10/8b/da/c3c2a324.jpg","comment_is_top":false,"comment_ctime":1545405932,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5840373228","product_id":100017301,"comment_content":"红黑树那一节真是看的一头包","like_count":1,"discussions":[{"author":{"id":1717444,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/34/c4/08d9f349.jpg","nickname":"元","note":"","ucode":"4576E15018EEA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":91345,"discussion_content":"没必要深究，知道这么一回事就行了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576828713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1336430,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/6e/e5ecc1d2.jpg","nickname":"水手","note":"","ucode":"536BB54E1E3617","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6048,"discussion_content":"递归树也看不懂。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566637698,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":51922,"user_name":"张洋","can_delete":false,"product_type":"c1","uid":1182914,"ip_address":"","ucode":"549BE5DEEF8417","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/c2/bad34a50.jpg","comment_is_top":false,"comment_ctime":1545276436,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5840243732","product_id":100017301,"comment_content":"第一个问题<br>假设2&#47;n+1 的节点不是叶子节点，那么他的子节点为 n+2 n+3.查处数组的索引了。<br>求出最后一个叶子节点的父节点 为 n&#47;2","like_count":1},{"had_liked":false,"id":51657,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1545218737,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5840186033","product_id":100017301,"comment_content":"插入的时候 ，while (i&#47;2 &gt; 0 &amp;&amp; a[i] &gt; a[i&#47;2]) { <br><br><br>这个“i&#47;2＞0”是不是用来限制当前树的结点树要大于等于2？？？","like_count":1,"discussions":[{"author":{"id":1243913,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fb/09/76b72581.jpg","nickname":"橘子先森","note":"","ucode":"1B27D74B8915A1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":277376,"discussion_content":"限定是叶子节点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591029389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":49578,"user_name":"Fury Spirit","can_delete":false,"product_type":"c1","uid":1344739,"ip_address":"","ucode":"7C96DDAA68767B","user_header":"https://static001.geekbang.org/account/avatar/00/14/84/e3/468442f6.jpg","comment_is_top":false,"comment_ctime":1544719913,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5839687209","product_id":100017301,"comment_content":"第一题比较简单：找最后一个节点的父节点就行了,也就是 n&#47;2。<br>第二题：top k问题。","like_count":1},{"had_liked":false,"id":48478,"user_name":"李坤","can_delete":false,"product_type":"c1","uid":1316193,"ip_address":"","ucode":"D05334A45B2B7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/15/61/ebbf6a33.jpg","comment_is_top":false,"comment_ctime":1544450909,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5839418205","product_id":100017301,"comment_content":"因为对完全二叉树来说，第n个节点的父节点(编号n&#47;2)是最后一个非叶子节点。所以编号从n&#47;2 + 1到n的节点都是叶子节点。<br>这里要注意我们是说编号从n&#47;2 + 1到n的节点是叶子节点，但是它们并非都是最后一层的节点。","like_count":1},{"had_liked":false,"id":47367,"user_name":"Laughing_Lz","can_delete":false,"product_type":"c1","uid":1251342,"ip_address":"","ucode":"7A7445E96F2978","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/0e/39307052.jpg","comment_is_top":false,"comment_ctime":1544116024,"is_pvip":false,"replies":[{"id":"16922","content":"👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1544148405,"ip_address":"","comment_id":47367,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5839083320","product_id":100017301,"comment_content":"上午看 删除堆顶点的代码一直没看懂，这会一看，豁然开朗，哈哈","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431754,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544148405,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":46509,"user_name":"Mr.M","can_delete":false,"product_type":"c1","uid":1243730,"ip_address":"","ucode":"C32AE0A9CD6EEF","user_header":"https://static001.geekbang.org/account/avatar/00/12/fa/52/4781da3f.jpg","comment_is_top":false,"comment_ctime":1543931345,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5838898641","product_id":100017301,"comment_content":"前两个问题已经知道答案了，谢谢老师，我怎么感觉堆化的过程跟排序的很像啊","like_count":1,"discussions":[{"author":{"id":1115041,"avatar":"https://static001.geekbang.org/account/avatar/00/11/03/a1/e6a0f60b.jpg","nickname":"Sid","note":"","ucode":"0461B574B2736B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72650,"discussion_content":"感觉堆化跟冒泡排序有点儿异曲同工，堆化是每次把最值交换到堆顶，冒泡也是每次把最值交换到最后，这两种每一轮都是把未排序区间中的最值确定出来。堆化是沿着一个节点向上走了一棵子树的路径，复杂度是logn，冒泡是线性依次比较，复杂度是n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575511414,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":46079,"user_name":"Mr.M","can_delete":false,"product_type":"c1","uid":1243730,"ip_address":"","ucode":"C32AE0A9CD6EEF","user_header":"https://static001.geekbang.org/account/avatar/00/12/fa/52/4781da3f.jpg","comment_is_top":false,"comment_ctime":1543842621,"is_pvip":false,"replies":[{"id":"16527","content":"那不然 叶子节点能跟谁比较呢","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543887775,"ip_address":"","comment_id":46079,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5838809917","product_id":100017301,"comment_content":"为什么叶子节点往下堆化只能自己跟自己比较？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431329,"discussion_content":"那不然 叶子节点能跟谁比较呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543887775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":45692,"user_name":"ZX","can_delete":false,"product_type":"c1","uid":1235583,"ip_address":"","ucode":"0D2622FE6D1774","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/7f/8069035d.jpg","comment_is_top":false,"comment_ctime":1543752580,"is_pvip":false,"replies":[{"id":"16359","content":"思路正确","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543801789,"ip_address":"","comment_id":45692,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5838719876","product_id":100017301,"comment_content":"老师，好像文字还没提到堆删除任意值，我的想法是，找到删除的值，用最后一个元素替换，如果这个值大于要删除的值，则向上调整，否则向下调整，不知道这个思路是不是对的。<br>顺便说一下，我在GITHUB把学习的代码都敲了一次，感兴趣的可以看看噢。https:&#47;&#47;github.com&#47;zhanxu33&#47;Struct-Algorithm","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431159,"discussion_content":"思路正确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543801789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295234,"discussion_content":"原来是腾讯的大神","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596121988,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295230,"discussion_content":"最后一个元素的值肯定小于等于要删除的值，只会向下堆化，因为插入的时候的是有向上堆化的，数组是从小到大排列，btw看了你的代码你们js代码实现起来还真复杂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596121525,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":45592,"user_name":"高尔夫","can_delete":false,"product_type":"c1","uid":1137463,"ip_address":"","ucode":"FEE20AD4A57365","user_header":"https://static001.geekbang.org/account/avatar/00/11/5b/37/8cf84372.jpg","comment_is_top":false,"comment_ctime":1543716510,"is_pvip":false,"replies":[{"id":"16364","content":"不需要重复建堆的 后面排序的时候只需要堆化操作堆顶元素就可以了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543802423,"ip_address":"","comment_id":45592,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5838683806","product_id":100017301,"comment_content":"请问老师一个很初级的问题， 对于建堆后第二部的排序代码有点没看懂， 从图解过程来说，应该是每次从堆顶删除元素，也就是下标n和堆顶元素交换，然后剩下的n-1个元素重新建堆， 然后再得到堆顶的最大元素，这样循环到重新建的堆只剩下1个元素就结束。<br>但是代码里面的while语句里面只堆化，并没有重复调用建堆过程buildHeap方法了<br>&#47;&#47; n 表示数据的个数，数组 a 中的数据从下标 1 到 n 的位置。<br>  while (k &gt; 1) {<br>    swap(a, 1, k);<br>    --k;<br>    heapify(a, k, 1);<br>  }<br>是因为第一次调用buildHeap后整体已经是部分有序了吗？<br><br>","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431111,"discussion_content":"不需要重复建堆的 后面排序的时候只需要堆化操作堆顶元素就可以了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543802423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":44568,"user_name":"Infinite_gao","can_delete":false,"product_type":"c1","uid":1235607,"ip_address":"","ucode":"9FBFEDED8790A8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLsexaVCEecIhpPsOqHJkZFEnyTfOZ1Ot3lmSMfyIVkR5SerJibatj6mIHackokoIO4ELiaObhQ60rw/132","comment_is_top":false,"comment_ctime":1543458018,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5838425314","product_id":100017301,"comment_content":"删除堆顶元素的代码好像有问题。<br>1. 方法没有返回值，return -1;应该改成 return<br>2. count==1的情况，方法没有处理，应该判断<br>if count&lt;=1 then count=0;<br><br>欢迎交流","like_count":1},{"had_liked":false,"id":44424,"user_name":"一个慢慢爬行的普通人","can_delete":false,"product_type":"c1","uid":1193589,"ip_address":"","ucode":"D38C25E119BCD7","user_header":"https://static001.geekbang.org/account/avatar/00/12/36/75/e346e04e.jpg","comment_is_top":false,"comment_ctime":1543436095,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5838403391","product_id":100017301,"comment_content":"老师。我想问一个比较傻的问题，望谅解。像你在开篇解答里说的堆排序数据访问的方式没有快速排序友好这一点里，你提到了堆排序相比快排对cpu缓存更不友好，我在想因为堆排序它也是存储在连续内存空间的数组里，随机访问某个元素都是O（1），所以我想你说的这一点是不是相较来说的因为快排是局部连续访问。<br>","like_count":1,"discussions":[{"author":{"id":1178739,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fc/73/928dae34.jpg","nickname":"日光倾城","note":"","ucode":"35DBDDCE919AB5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74675,"discussion_content":"是这个道理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575651820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":44331,"user_name":"Alan","can_delete":false,"product_type":"c1","uid":1243563,"ip_address":"","ucode":"EF3B6A90054B34","user_header":"https://static001.geekbang.org/account/avatar/00/12/f9/ab/374fe105.jpg","comment_is_top":false,"comment_ctime":1543409620,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5838376916","product_id":100017301,"comment_content":"public void removeMax() {<br>  if (count == 0) return -1; &#47;&#47; 堆中没有数据<br>  a[1] = a[count];<br>  --count;<br>  heapify(a, count, 1);<br>}<br>------------------------------------<br>removeMax方法第一行，堆中没有数据的情况下return -1，但是函数声明中返回值是void","like_count":1},{"had_liked":false,"id":44263,"user_name":"Jeff","can_delete":false,"product_type":"c1","uid":1316265,"ip_address":"","ucode":"B5C07DA4877388","user_header":"https://static001.geekbang.org/account/avatar/00/14/15/a9/800757d8.jpg","comment_is_top":false,"comment_ctime":1543396203,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5838363499","product_id":100017301,"comment_content":"除了红黑树那一章节，其他基本能跟上节奏。感谢老师！会推荐给有需要的朋友。","like_count":1},{"had_liked":false,"id":44236,"user_name":"张瀚元","can_delete":false,"product_type":"c1","uid":1237388,"ip_address":"","ucode":"89B56F4EB82088","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/8c/02c2607c.jpg","comment_is_top":false,"comment_ctime":1543391548,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5838358844","product_id":100017301,"comment_content":"看不懂了","like_count":1},{"had_liked":false,"id":44029,"user_name":"🌀🐑hfy🐣","can_delete":false,"product_type":"c1","uid":1254367,"ip_address":"","ucode":"8A7E4BDC46CB35","user_header":"https://static001.geekbang.org/account/avatar/00/13/23/df/367f2c75.jpg","comment_is_top":false,"comment_ctime":1543365668,"is_pvip":false,"replies":[{"id":"15780","content":"可以去看链表那一节","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543404241,"ip_address":"","comment_id":44029,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5838332964","product_id":100017301,"comment_content":"老师，为什么堆排序是跳着访问元素所以对cpu不友好啊？可以再详细一点吗","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":430604,"discussion_content":"可以去看链表那一节","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543404241,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1753115,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/c0/1b/319baf9d.jpg","nickname":"ZMH.","note":"","ucode":"D45D6CEDFDF8F5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":235136,"discussion_content":"数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587022833,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":43907,"user_name":"🐱您的好友William🐱","can_delete":false,"product_type":"c1","uid":1215456,"ip_address":"","ucode":"427786DB178965","user_header":"https://static001.geekbang.org/account/avatar/00/12/8b/e0/9a79ddac.jpg","comment_is_top":false,"comment_ctime":1543321684,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5838288980","product_id":100017301,"comment_content":"正在学习reinforcement learning中的 prioritized experience replay，其中就是用一个堆（但是是满二叉）实现了按权重进行sampling。 ","like_count":1},{"had_liked":false,"id":43702,"user_name":"Ryoma","can_delete":false,"product_type":"c1","uid":1130590,"ip_address":"","ucode":"7F692369239692","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/5e/b8fada94.jpg","comment_is_top":false,"comment_ctime":1543282095,"is_pvip":true,"replies":[{"id":"15584","content":"嗯嗯，我改下，多谢指正。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543284338,"ip_address":"","comment_id":43702,"utype":1}],"discussion_count":1,"race_medal":2,"score":"5838249391","product_id":100017301,"comment_content":"删除栈顶元素 一节中最后一个节点是22，这样就不是一个堆了吧（不满足堆定义中的第二条）","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":430463,"discussion_content":"嗯嗯，我改下，多谢指正。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543284338,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":43688,"user_name":"偶尔大白","can_delete":false,"product_type":"c1","uid":1088224,"ip_address":"","ucode":"8A876A5A223148","user_header":"https://static001.geekbang.org/account/avatar/00/10/9a/e0/f386a0ef.jpg","comment_is_top":false,"comment_ctime":1543281026,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5838248322","product_id":100017301,"comment_content":"快速查找最快或者最小值，并且插入或者删除时间复杂度最优","like_count":1},{"had_liked":false,"id":43653,"user_name":"清歌","can_delete":false,"product_type":"c1","uid":1014496,"ip_address":"","ucode":"4545455E12F907","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/e0/3d5b28ef.jpg","comment_is_top":false,"comment_ctime":1543277591,"is_pvip":false,"replies":[{"id":"15586","content":"什么意思啊，没看懂你说的，是乱码了吗？","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543284373,"ip_address":"","comment_id":43653,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5838244887","product_id":100017301,"comment_content":"文章中为什么有那么多的$？还前后数字都有，这代表什么意思呢？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":430447,"discussion_content":"什么意思啊，没看懂你说的，是乱码了吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543284373,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358968,"user_name":"111","can_delete":false,"product_type":"c1","uid":3109487,"ip_address":"北京","ucode":"D6E8E83A118A3E","user_header":"https://static001.geekbang.org/account/avatar/00/2f/72/6f/44c10658.jpg","comment_is_top":false,"comment_ctime":1665106469,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665106469","product_id":100017301,"comment_content":"总结：<br>1. 大&#47;小顶堆概念，插入，删除，排序<br><br>","like_count":0},{"had_liked":false,"id":356425,"user_name":"蒋慕平","can_delete":false,"product_type":"c1","uid":2302901,"ip_address":"重庆","ucode":"57B8FF7F00C042","user_header":"https://static001.geekbang.org/account/avatar/00/23/23/b5/639a12ec.jpg","comment_is_top":false,"comment_ctime":1662294114,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662294114","product_id":100017301,"comment_content":"堆<br>- 完全二叉树<br>- 节点 大于或小于叶子节点,大头堆，小头堆<br>- i节点，i*2左叶子点i*2+1右叶子节点 父节点i&#47;2<br>- 堆化操作&#47;排序","like_count":0},{"had_liked":false,"id":355646,"user_name":"~patience","can_delete":false,"product_type":"c1","uid":1614285,"ip_address":"四川","ucode":"8D9BC78A241CEA","user_header":"https://static001.geekbang.org/account/avatar/00/18/a1/cd/bc74741c.jpg","comment_is_top":false,"comment_ctime":1661590295,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661590295","product_id":100017301,"comment_content":"那堆排序的时间复杂度最差是多少呢","like_count":0},{"had_liked":false,"id":352404,"user_name":"行则将至","can_delete":false,"product_type":"c1","uid":1542987,"ip_address":"","ucode":"DB972F2DF059C4","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","comment_is_top":false,"comment_ctime":1658648168,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1658648168","product_id":100017301,"comment_content":"https:&#47;&#47;github.com&#47;AK-qinwang&#47;hello-world&#47;tree&#47;master&#47;src&#47;main&#47;java&#47;heap<br>老师，我写了一个快排，一个堆排。<br>但是不管咋换元素，都是快排的比较次数多。帮看看代码是咋回事啊。<br>(堆排，我和你代码不一样的地方，就是堆排那里，为了空出数组的第一位来，我新创建了一个数组，然后进行了拷贝。)","like_count":0},{"had_liked":false,"id":342287,"user_name":"Hombio","can_delete":false,"product_type":"c1","uid":2044600,"ip_address":"","ucode":"E8268EE93892F7","user_header":"https://static001.geekbang.org/account/avatar/00/1f/32/b8/e640ae0e.jpg","comment_is_top":false,"comment_ctime":1650171948,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650171948","product_id":100017301,"comment_content":"为了方便推导，存储数据的数组索引从1开始，设某个节点的索引为k，左子节点为kleft，右子节点为kright，则有<br>```<br>kleft = 2 * k<br>kright = 2 * k + 1<br>```<br>设堆的节点树为n，最后一个叶子节点名为lln，索引为lli，其双亲节点为pn，索引为pi。<br><br>明显有(完全二叉树性质)：`lli = n`<br><br>如果lln为pn的左子节点，那么有`pi * 2 = n`，可得`pi = n&#47;2`<br><br>如果lln为pn的右子节点，那么有`pi * 2 + 1 = n`，可得`pi = (n-1)&#47;2`，此时n为奇数，由于计算机的整数除法运算会自动砍掉余数部分，所以有`(n-1)&#47;2 == n&#47;2`。<br><br>综上可得：`pi = n&#47;2`<br><br>由完全二叉树的性质可知，pn即为最后一个非叶子节点，在pn这一层从左到右，pn的下一个节点就是第一个叶子节点。<br><br>所以堆的最后一个非叶子节点的索引为：`n&#47;2`，第一个叶子节点的索引为`n&#47;2+1`","like_count":0},{"had_liked":false,"id":342164,"user_name":"本来是亚","can_delete":false,"product_type":"c1","uid":1073592,"ip_address":"","ucode":"14527E5BC3C2A8","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/b8/7b23f8cb.jpg","comment_is_top":false,"comment_ctime":1650077688,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1650077688","product_id":100017301,"comment_content":"对于第1题，堆中每个结点的左右结点下标分别是i*2，i*2+1，下标如果为n&#47;2，则其左节点下标恰好等于数组长度n，即存在子节点，下标如果大于等于n&#47;2+1，则其左结点的下标已经超过数组长度n，不存在子结点，为叶子结点；<br>对于第2题，topK就用到了堆","like_count":0},{"had_liked":false,"id":340012,"user_name":"Geek_d40030","can_delete":false,"product_type":"c1","uid":2029525,"ip_address":"","ucode":"91A94D7C8F3F71","user_header":"","comment_is_top":false,"comment_ctime":1648538616,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1648538616","product_id":100017301,"comment_content":"算法导论上有个问题就是为什么从后往前建堆而不是从前往后建堆，老师能回答一下吗？","like_count":0},{"had_liked":false,"id":338744,"user_name":"侯恩训","can_delete":false,"product_type":"c1","uid":1162376,"ip_address":"","ucode":"F4DC47EECA0F00","user_header":"https://static001.geekbang.org/account/avatar/00/11/bc/88/fbb6022e.jpg","comment_is_top":false,"comment_ctime":1647698498,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647698498","product_id":100017301,"comment_content":"堆定义：<br>1. 完全二叉树，节点比左右子节点都大（大顶堆）<br>2. 大顶堆 小顶堆 堆化","like_count":0},{"had_liked":false,"id":337770,"user_name":"Today","can_delete":false,"product_type":"c1","uid":1235000,"ip_address":"","ucode":"4FA397F0BD8C6E","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/38/41027bda.jpg","comment_is_top":false,"comment_ctime":1647052778,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647052778","product_id":100017301,"comment_content":"思考题：<br>1. 通过等比数列知道，满二叉树的最后一层叶子节点个数是（n&#47;2 + 1），完全二叉树最后一层也是，每多2个，（n&#47;2 + 1）也相应加1","like_count":0},{"had_liked":false,"id":337531,"user_name":"瀚","can_delete":false,"product_type":"c1","uid":1527939,"ip_address":"","ucode":"DEF8DBA46A7EE7","user_header":"https://static001.geekbang.org/account/avatar/00/17/50/83/75811700.jpg","comment_is_top":false,"comment_ctime":1646881461,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646881461","product_id":100017301,"comment_content":"堆的条件<br>1.完全二叉树<br>2.堆中的每一个节点都必须大于等于或者小于等于子节点的值<br>3.使用数组来表示堆(大顶堆)<br>\t1.数组下标中 i 的节点的 <br>\t\t左子节点为 i*2 所以 a[i] &gt; = a[i*2]<br>\t\t右子节点就是 i*2 + 1 所以 a[i] &gt; = a[i*2+1]<br>\t\t父节点为 i &#47; 2 所以 a[i] &lt;= a[i&#47;2]<br>\t\thttps:&#47;&#47;www.cs.usfca.edu&#47;~galles&#47;visualization&#47;HeapSort.html","like_count":0},{"had_liked":false,"id":335688,"user_name":"i_chase","can_delete":false,"product_type":"c1","uid":1795511,"ip_address":"","ucode":"09C41C863F4EA3","user_header":"https://static001.geekbang.org/account/avatar/00/1b/65/b7/058276dc.jpg","comment_is_top":false,"comment_ctime":1645628314,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1645628314","product_id":100017301,"comment_content":"关于堆排序会使数据有序度降低：<br>这个不对啊，一个从大到小的数组，逆序对应该是最多的。<br>建立最小堆以后，已经比较有序了，只有同一层节点之间有可能逆序。","like_count":0},{"had_liked":false,"id":330531,"user_name":"神经蛙","can_delete":false,"product_type":"c1","uid":2873959,"ip_address":"","ucode":"E0CE74B2363E10","user_header":"https://static001.geekbang.org/account/avatar/00/2b/da/67/e18b690e.jpg","comment_is_top":false,"comment_ctime":1642030505,"is_pvip":false,"discussion_count":0,"race_medal":2,"score":"1642030505","product_id":100017301,"comment_content":"堆的最后一个叶子节点的数组下标为 n，根据数组存储完全二叉树规则可知其父节点为数组下标为 n&#47;2 的节点，即为最后一个非叶子节点","like_count":0},{"had_liked":false,"id":329150,"user_name":"篂篂点点","can_delete":false,"product_type":"c1","uid":2644570,"ip_address":"","ucode":"475010AFAFA285","user_header":"https://static001.geekbang.org/account/avatar/00/28/5a/5a/29c8c4d6.jpg","comment_is_top":false,"comment_ctime":1641182838,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641182838","product_id":100017301,"comment_content":"什么是堆？<br>\t1.首先是完全二叉树<br>\t2.其次根节点大于（或小于）左右子节点，分别对应的大顶堆，小顶堆<br>\t<br>堆的存储方式：完全二叉树用数组存储最节省空间，所以堆用数组存储<br><br>堆支持的操作：<br>\t1.插入数据：插入到最后一个叶子节点，顺着节点的路径比较、交换（堆化）。<br>\t2.删除“堆顶”数据：删除的是最大元素或者最小的元素，这时可以把最后一个元素放到根节点，然后从上往下堆化。<br><br>插入和删除的时间复杂度：树的高度最大为log2N,堆化的过程就是顺着节点所在路径比较交换，所以时间复杂度是O(logn)<br><br>堆排序：<br>\t两个步骤：建堆和排序<br>\t建堆：1.从数组中最后一个非叶子节点的下标向前进行堆化。<br>\t\t  2.最后一个非叶子节点怎么得到？<br>\t\t\t  下标从1开始的数组中，最后一个非叶子节点的下标是多少？设n个树节点，最后一个叶子节点的下标是n，则父节点是n&#47;2。<br>\t\t\t  推出最后一个非叶子节点的下标是n&#47;2<br>\t\t  3.建堆的时间复杂度：O(n)，根据树高度h=log2N和等比数组求和公式推算出来。<br>\t排序：1.若是大顶堆，数组的第一个元素是最大的，将第一个元素和数组的最后一个元素替换。<br>\t\t  2.然后对下标1...n-1的元素进行堆化，重复1<br>\t\t  3.直至只剩下下标为1的元素，排序结束，数组已经升序排列<br>\t\t  排序的时间复杂度是：O(nlogn)<br>\t\t  注意：堆排序过程中，最后一个元素和第一个元素进行交换，所以是非稳定的排序算法<br>\t\t  <br>堆排序和快速排序性能:<br>\t1.堆排序数据访问顺序不如快速排序好，堆化时，依次访问数组下标的1,2,4,8，不像快速排序那样满足局部顺序访问，对cpu不友好。<br>\t2.同样的数据，在排序过程中，堆排序算法的数据交换次数多于快速排序<br>","like_count":0},{"had_liked":false,"id":326319,"user_name":"Wilson","can_delete":false,"product_type":"c1","uid":1007140,"ip_address":"","ucode":"3ADBE962C67B8D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/24/040855d3.jpg","comment_is_top":false,"comment_ctime":1639469936,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639469936","product_id":100017301,"comment_content":"堆排序有点不明白，然后自己梳理下：<br>堆排序分为两个步骤，初始化堆和排序<br>1、初始化堆，就初始化一个大顶堆或者一个小顶堆（如果是降序就是初始化大顶堆，如果是升序就是初始化小顶堆）<br>2、基于初始化的大顶堆或小顶堆排序（大顶堆和小顶堆目前还是无序）<br>不知道我这样理解是否正确。<br>","like_count":0},{"had_liked":false,"id":320875,"user_name":"仅此而已的坏蛋","can_delete":false,"product_type":"c1","uid":2760645,"ip_address":"","ucode":"90FC777D9025AE","user_header":"https://static001.geekbang.org/account/avatar/00/2a/1f/c5/7be3de23.jpg","comment_is_top":false,"comment_ctime":1636535856,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636535856","product_id":100017301,"comment_content":"删除过程代码是不是还要把最后一个元素所在位置置为0","like_count":0},{"had_liked":false,"id":318686,"user_name":"ShiYY","can_delete":false,"product_type":"c1","uid":1721473,"ip_address":"","ucode":"E03DC432A3AFB8","user_header":"https://static001.geekbang.org/account/avatar/00/1a/44/81/318eb4dd.jpg","comment_is_top":false,"comment_ctime":1635391649,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635391649","product_id":100017301,"comment_content":"每个节点堆化的时间复杂度是 O(logn)，那 2&#47;n​+1 个节点堆化的总时间复杂度是不是就是 O(nlogn) 呢？<br>这里为什么是2&#47;n+1个节点堆化? 应该是2&#47;n个节点堆化吧!?","like_count":0},{"had_liked":false,"id":313556,"user_name":"谷雨","can_delete":false,"product_type":"c1","uid":1458299,"ip_address":"","ucode":"562E1C2B96028C","user_header":"https://static001.geekbang.org/account/avatar/00/16/40/7b/0e6b02c2.jpg","comment_is_top":false,"comment_ctime":1632496492,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632496492","product_id":100017301,"comment_content":"若n&#47;2 + 1到n中有节点不是叶子节点，则n&#47;2 + 1肯定不是叶子节点，则其存在子节点: 2 * (n&#47;2 + 1) = n + 2，超过了节点个数；则n&#47;2 + 1肯定是叶子节点；<br>若n&#47;2 + 1之前还存在叶子节点，则n&#47;2肯定是叶子节点，则其不存在任意子节点：2 * n &#47; 2 = n；少于节点个数n；则n&#47;2肯定不是叶子节点<br>综上两条：n&#47;2 + 1 ~ n都是叶子节点","like_count":0},{"had_liked":false,"id":310116,"user_name":"三思伍","can_delete":false,"product_type":"c1","uid":2739730,"ip_address":"","ucode":"9E01445F60E374","user_header":"https://static001.geekbang.org/account/avatar/00/29/ce/12/24c33b47.jpg","comment_is_top":false,"comment_ctime":1630489349,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630489349","product_id":100017301,"comment_content":"思考题<br>1. 对于完全二叉树，设为k层，共n个节点。每一层节点数依次为2^0，2^1...2^(k-2)。则前k-1层共2^(k-1)-1个节点，总结点数n=(2^k)-1，即n&#47;2=2^(k-1)-1，刚好是前k-1层总节点数，故从n&#47;2+1开始，为叶子结点。<br>（上述错误，错误的令n=(2^k)-1，实际上该树不一定满）","like_count":0},{"had_liked":false,"id":309980,"user_name":"王帅霖","can_delete":false,"product_type":"c1","uid":2679921,"ip_address":"","ucode":"3BD745B1C39FE2","user_header":"https://static001.geekbang.org/account/avatar/00/28/e4/71/7c8d3086.jpg","comment_is_top":false,"comment_ctime":1630423028,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630423028","product_id":100017301,"comment_content":"老师，这个堆的数据结构有没有具体的应用啊？","like_count":0},{"had_liked":false,"id":308770,"user_name":"Juniper","can_delete":false,"product_type":"c1","uid":1174794,"ip_address":"","ucode":"1BC24554034BD3","user_header":"https://static001.geekbang.org/account/avatar/00/11/ed/0a/18201290.jpg","comment_is_top":false,"comment_ctime":1629792383,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629792383","product_id":100017301,"comment_content":"新增的时候，采用自下而上的堆化；删除的时候，先交换堆顶和末尾的元素，然后删除当前末尾元素，在执行自上而下的堆化（采用这种策略是为了避免数组空洞）；建堆就是将数组处理成堆，两种思路：一、从前往后，相当新增的思路，自下而上，子节点跟父节点对比 二、从后往前处理数组，直接从最后一个非叶子节点开始处理，父节点和自己的子节点对比","like_count":0},{"had_liked":false,"id":304958,"user_name":"Benson_Geek","can_delete":false,"product_type":"c1","uid":1519415,"ip_address":"","ucode":"D95B5C2BA09961","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/dr34H3hOMVsibL0XV1iaBWFiaTnYssX8sNjmJDpiaBUVv2X39nFzDjNpe288cKkZfH3P9sVRxZ1lzYZEcRR3vJNYtA/132","comment_is_top":false,"comment_ctime":1627717237,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627717237","product_id":100017301,"comment_content":"堆排序：<br>1. 一个数组长度为n，下标i从0开始，<br>则下标从0到n&#47;2 - 1 都是非叶子节点，n&#47;2到 n - 1都是叶子节点，<br>且从堆顶开始，下标为 2i + 1 左子节点， 2i + 2为右子节点。<br>2. 堆中最重要的两个操作是插入元素和删除堆顶元素。<br>(1) 插入元素时插入在堆尾，并至下而上进行堆化；<br>(2) 删除堆顶元素后，将堆尾元素放到堆顶，再至上而下进行堆化。<br><br>2. 堆排序过程包括建堆(堆化)和排序。<br>每次堆化后，讲堆顶元素跟队尾元素交换，剩下的n - 2个元素再进行堆化，重复此步骤到最后堆中只剩下一个元素即完成排序。<br>3. 堆顶最大最小的堆分别为大顶堆和小顶堆。<br>","like_count":0},{"had_liked":false,"id":302054,"user_name":"Janus Pen","can_delete":false,"product_type":"c1","uid":2667580,"ip_address":"","ucode":"70B3F972739278","user_header":"https://static001.geekbang.org/account/avatar/00/28/b4/3c/e4a08d98.jpg","comment_is_top":false,"comment_ctime":1626057118,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626057118","product_id":100017301,"comment_content":"王争老师，removeMax()函数中return了-1，这是错误还是java语法不一样","like_count":0},{"had_liked":false,"id":297876,"user_name":"海崖","can_delete":false,"product_type":"c1","uid":2552745,"ip_address":"","ucode":"9D42E0B0D30A56","user_header":"https://static001.geekbang.org/account/avatar/00/26/f3/a9/bb9d8450.jpg","comment_is_top":false,"comment_ctime":1623828921,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623828921","product_id":100017301,"comment_content":"叮~打卡","like_count":0},{"had_liked":false,"id":294475,"user_name":"等等 女皇","can_delete":false,"product_type":"c1","uid":1549661,"ip_address":"","ucode":"81423644144550","user_header":"https://static001.geekbang.org/account/avatar/00/17/a5/5d/22829a03.jpg","comment_is_top":false,"comment_ctime":1621956462,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621956462","product_id":100017301,"comment_content":"为什么建堆过程的时间复杂度是 O(n)，但是排序过程的时间复杂度却是是 O(nlogn)？<br><br>按照我的理解，建堆的过程迭代数组的时候，不是每次堆化操作都是logn，因为n是不断变化的，会因为结点层高不一样时间复杂度并不是每次都能达到logn，所以经过演算后是O(n)。<br><br>但是排序的过程也是同理的，随着堆顶元素不断从堆顶拿走，待堆化的数据不断减少，时间复杂度并不是每次都能达到logn，所以是不是排序的时间复杂度也是可以O(n) 呢？","like_count":0},{"had_liked":false,"id":291284,"user_name":"双木公子","can_delete":false,"product_type":"c1","uid":1116567,"ip_address":"","ucode":"751885864D3AB7","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/97/4314e2d8.jpg","comment_is_top":false,"comment_ctime":1620181787,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620181787","product_id":100017301,"comment_content":"https:&#47;&#47;blog.csdn.net&#47;BruceLee1314&#47;article&#47;details&#47;116419042?spm=1001.2014.3001.5501，本文的相关算法整理过程","like_count":0},{"had_liked":false,"id":289878,"user_name":"方圆","can_delete":false,"product_type":"c1","uid":2397608,"ip_address":"","ucode":"A23EEF00FC46E6","user_header":"https://static001.geekbang.org/account/avatar/00/24/95/a8/5f327596.jpg","comment_is_top":false,"comment_ctime":1619248561,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619248561","product_id":100017301,"comment_content":"学习堆排序结合图解更加清晰","like_count":0},{"had_liked":false,"id":288663,"user_name":"脱缰的野马","can_delete":false,"product_type":"c1","uid":1758076,"ip_address":"","ucode":"DFD3C6A105D58F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d3/7c/fbc374a4.jpg","comment_is_top":false,"comment_ctime":1618587654,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618587654","product_id":100017301,"comment_content":"老师我有个问题，heapify函数里的int maxPos = i;应该放到while循环外面吧？要不只比较了当前层数据","like_count":0},{"had_liked":false,"id":288048,"user_name":"帝江","can_delete":false,"product_type":"c1","uid":1590610,"ip_address":"","ucode":"93CBA4E4D05DA5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/B9vSOjMc2a86kYA8R5yDkVdFiaj2JeBZ1PuI9oUKhbnvuZwuibdUam6FTcGzDaiaFdk2GWJveUGhfCVpv4KaOdicoQ/132","comment_is_top":false,"comment_ctime":1618280917,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618280917","product_id":100017301,"comment_content":"从上往下排序的时候.往左还是往右依赖于什么确定?","like_count":0},{"had_liked":false,"id":283782,"user_name":"武怀璧","can_delete":false,"product_type":"c1","uid":1640273,"ip_address":"","ucode":"A40AC4E72AFAEF","user_header":"https://static001.geekbang.org/account/avatar/00/19/07/51/cc1e90ad.jpg","comment_is_top":false,"comment_ctime":1615925569,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615925569","product_id":100017301,"comment_content":"两个疑问<br>1、堆中插入一个元素如何使用自顶向下的堆化<br>2、删除堆中一个元素如何使用自底向上的堆化<br><br>还是说 插入只能自底向上、删除只能自顶向下","like_count":0},{"had_liked":false,"id":282462,"user_name":"KangShan","can_delete":false,"product_type":"c1","uid":1082000,"ip_address":"","ucode":"07497A7AC92238","user_header":"https://static001.geekbang.org/account/avatar/00/10/82/90/e4a08b0e.jpg","comment_is_top":false,"comment_ctime":1615262977,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615262977","product_id":100017301,"comment_content":"如果用极限的思想,很容易想到,一个堆就是一个完全二叉树,最后一层会占问题的一半.1 + 1&#47;2 + 1&#47;4 + ...这样一直加下去,其加到无穷的结果就是2.反过来,就是最后一层占一半.","like_count":0},{"had_liked":false,"id":280849,"user_name":"罗耀龙@坐忘","can_delete":false,"product_type":"c1","uid":1917663,"ip_address":"","ucode":"3CEA258DE7F3C7","user_header":"https://static001.geekbang.org/account/avatar/00/1d/42/df/a034455d.jpg","comment_is_top":false,"comment_ctime":1614422098,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1614422098","product_id":100017301,"comment_content":"茶艺师学编程<br><br>感觉这个堆排序，就像要整理衣柜，堆排序非要把衣服全扒出来重新放过","like_count":0},{"had_liked":false,"id":279533,"user_name":"Geek_f144c2","can_delete":false,"product_type":"c1","uid":2299542,"ip_address":"","ucode":"9CCFE862BB11BA","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/FSk6ksZtTSAEKgsDRdLDEHibEPyjIFU2IQbSQnUSZmKbFSZtFyDtRhw1PAwlw3mRYSfC93bI5c5p0Agr6yvNv0A/132","comment_is_top":false,"comment_ctime":1613812577,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613812577","product_id":100017301,"comment_content":"对于第二点，你可以自己做个试验看下. 怎么php试验","like_count":0},{"had_liked":false,"id":276515,"user_name":"慕高迪","can_delete":false,"product_type":"c1","uid":1448126,"ip_address":"","ucode":"EB1CB5EA4E3A90","user_header":"https://static001.geekbang.org/account/avatar/00/16/18/be/ad3127e0.jpg","comment_is_top":false,"comment_ctime":1611982029,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611982029","product_id":100017301,"comment_content":"总结：<br><br>1. 堆也是一棵树。只不过它满足以下两点：<br><br>1）是一棵完全二叉树<br><br>2）每一个节点都要比其左和右节点要大或小<br><br>如果每一个节点都比其左和右节点要大，称为大顶堆；反之则称为小顶堆<br><br>2. 堆的存储方式：由于堆是一棵完全二叉树，所以使用数组来存储是比较适合的<br><br>3. 堆化<br><br>堆化是一个过程。它可以让完全二叉树满足堆的第二个特点。堆化主要分为两种方式：自下而上进行堆化和自上而下进行堆化<br><br>我们以大顶堆为例说明下这个过程：<br><br>3.1）自下而上堆化的过程：从某个节点出发，不断的与父节点进行比较，如果比父节点大，就与父节点交换位置；重复执行这个过程，直到不大于父节点或没有父节点为止<br><br>3.2）自上而下堆化的过程：从某个节点出发，不断的与其左右节点进行比较，找出最大的节点，并与其交换位置；重复执行这个过程，直到当前节点比左右子节点都大或没有子节点为止<br><br>可以看出堆化的时间复杂度跟树高成正比，而完全二叉树的树高约为logN，所以堆化过程的时间复杂度为O(logN)。<br><br>3. 构建堆<br><br>构建堆的主要过程为：从最后一个非叶子节点开始，依次对于每一个非叶子节点进行自上而下的堆化过程。由于存储方式是数组，所以最后一个非叶子节点 = 数组内最后一个元素的位置  &#47; 2 （数组下标从1开始）。其余非叶子节点就是在最后一个非叶子节点之前的数组元素 。<br><br>所以构建堆的时间复杂度看上去为O(NlogN)，虽然没错，但是不够精准。实际上每一个节点的交换次数与其高度有关，而且只会涉及到 n&#47;2 个节点，如果将每一个节点的高度之和进行相加，就可以得出确切的时间复杂度为O(N)<br><br>4. 堆常见的操作：添加元素和删除堆顶元素<br><br>4.1) 添加元素很简单，只需要在数组尾直接插入元素即可。然后针对当前元素执行自下而上的堆化过程。向数组中插入元素的时间复杂度为O(1)。所以添加元素的时间复杂度为O(logN)<br><br>4.2) 删除堆顶元素也很简单，只需要将数组的最后一个元素交换到数组第一个元素的位置，并将数组内元素的长度减一（类似于在数据中删除了元素，但并没有真正清空元素），并针对堆顶元素进行自上而下的堆化过程。交换元素的时间复杂度为O(1)。所以删除堆顶元素的时间复杂度为O(logN)<br><br>5. 堆的应用：堆排序<br><br>堆排序可谓是堆最重要的应用。在进行堆排序之前首先要构建堆，堆构建好了之后，通过不断的删除堆顶元素的方式，从而让数据实现有序。<br><br>所以堆排序的时间复杂度为 max( O(N) + O(NlogN) ) = O(NlogN)。是一个原地排序，但并不是一个稳定的排序算法。<br><br>6. 堆排序和快速排序的时间复杂度都是O(NlogN)，而且堆排序还比快速排序的复杂度稳定，但为什么快速排序却比堆排序更加常用？<br><br>6.1）快速排序往往都是顺序访问数组内的元素，可以利用CPU缓存，加速这一访问过程。而堆排序的堆化过程往往都是跳着访问数组元素的，不能利用到这一优化。<br><br>6.2）堆排序在排序的过程中，交换的次数要比快速排序多。因为堆排序在建堆的过程中，会将数据原有的顺序打乱了，导致有序度降低。而快速排序的交换次数不会超过逆序度。","like_count":0},{"had_liked":false,"id":271452,"user_name":"cyan-mountain","can_delete":false,"product_type":"c1","uid":2318781,"ip_address":"","ucode":"2797C0D846130C","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/fKD3fHiaJajYHkBNnLBYb40ggEqA5lykW4jrqHvXtiap2rPmq8Cj7pj4nTU7BdqHTIzIRKRt5mylnucgwibOZ2Z9g/132","comment_is_top":false,"comment_ctime":1609646200,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609646200","product_id":100017301,"comment_content":"建堆时，老师着重讲解第二种方式是因为：<br>第一种方式精确的时间复杂度为(n-1)*O(logn)，因为对n-1个节点进行了堆化；<br>第二种方式精确的时间复杂度为(n&#47;2)*O(logn)，因为只对非叶子节点的n&#47;2个节点进行了堆化；<br><br>相比第一种方式，第二种从后往前处理数组，从上往下堆化，整整节省了近一半的时间，秒啊","like_count":0},{"had_liked":false,"id":263153,"user_name":"spencer","can_delete":false,"product_type":"c1","uid":1399304,"ip_address":"","ucode":"BBB22B77DCE987","user_header":"https://static001.geekbang.org/account/avatar/00/15/5a/08/467b3e34.jpg","comment_is_top":false,"comment_ctime":1606024344,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606024344","product_id":100017301,"comment_content":"我有一个问题，求海量数据里面的top K问题。如果是用堆的话，IO不是也会高么？一次性海量数据读不进内存，建完堆（假设堆有N个元素）以后每遍历过一轮，不是还是需要去磁盘IO读取新的N元素？","like_count":0},{"had_liked":false,"id":258299,"user_name":"拉布拉多","can_delete":false,"product_type":"c1","uid":1204353,"ip_address":"","ucode":"637A88D9F29F57","user_header":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","comment_is_top":false,"comment_ctime":1604374961,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604374961","product_id":100017301,"comment_content":"谢谢老师。老师的思路，很符合自己思考渐进的思路。比清华严魏敏的教材容易懂多了，以前看堆，只了解基本的。这次知道了所以然。","like_count":0},{"had_liked":false,"id":257115,"user_name":"超级蛋蛋饭","can_delete":false,"product_type":"c1","uid":1249616,"ip_address":"","ucode":"AD2BECE789B365","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/wiaQmkQdIh84RibSLrDkIA3HtibAR4IibpnP3VEmiaLzvpiaibXJQEb2LLUrCD4dM7DjvOFD65IbdZm2Mn68O71FxiaAow/132","comment_is_top":false,"comment_ctime":1603853462,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603853462","product_id":100017301,"comment_content":"思考题1：最后一个节点的下标为n，那么最后一个有子节点的节点的下标是n&#47;2。然后就不用我说了吧","like_count":0},{"had_liked":false,"id":252463,"user_name":"youyou.L","can_delete":false,"product_type":"c1","uid":1796438,"ip_address":"","ucode":"B3DB0D0700EEAC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/zlWt0lPDicdib5BTUbuwA3wLLUuejtZ5icGu3DHMBPd6PicXOdhZ3zYFts8VkXjjyQuxzUJas2w5OTmx3icWKiaZM1Vg/132","comment_is_top":false,"comment_ctime":1602312090,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602312090","product_id":100017301,"comment_content":"思考题：<br>除插入跟节点外，完全二叉树插入节点时叶子节点数和非叶子节点数变化有两种情况，<br>一种是插入的是左子树时，叶子节点数不变，非叶子节点数+1；另一种是插入的是右子树，非叶子节点数不变，叶子节点数+1；<br>在完全二叉树构建的过程，一开始叶子节点数为1，非叶子节点数为0，然后是先第一种情况，再第二种情况，接着轮询出现，所以叶子节点数与非叶子节点数的比较在于最后一个叶子节点是左子树还是右子树，当为左子树时，叶子节点数 = 非叶子节点数；当为右子数时，叶子节点数比非叶子节点数多1；<br>  当最后一个节点为左子树时，叶子节点数 = 非叶子节点数，为偶数个节点，所以叶子节点数为[n&#47;2+1,n]，当最后一个节点为右子树时，为奇数个节点，多的最后一个是叶子节点，所以[1,n&#47;2]是非叶子节点，[n&#47;2+1,n]是叶子节点；<br>综上，完全二叉树的叶子节点数在[n&#47;2+1,n]","like_count":0},{"had_liked":false,"id":251470,"user_name":"岁月如歌","can_delete":false,"product_type":"c1","uid":1114542,"ip_address":"","ucode":"29FA49EEDBFF92","user_header":"https://static001.geekbang.org/account/avatar/00/11/01/ae/f298ef27.jpg","comment_is_top":false,"comment_ctime":1601600771,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601600771","product_id":100017301,"comment_content":"最后一颗节点的父节点下标是n&#47;2，所以叶子节点就是从n&#47;2+1开始的","like_count":0},{"had_liked":false,"id":251314,"user_name":"fssq2011","can_delete":false,"product_type":"c1","uid":1045902,"ip_address":"","ucode":"0DC52113BCAEA9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/8e/feb62f95.jpg","comment_is_top":false,"comment_ctime":1601458870,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601458870","product_id":100017301,"comment_content":"&#47;&#47;根据作者代码整理的c++版本堆排序，其中swap(arr, 1, k-1);处，作者笔误错写成swap(arr, 1, k);了<br>void heapify(int arr[], int i, int len) {<br>\twhile (true) {<br>\t\tint maxpos = i;<br>\t\tif (2 * i-1 &lt; len &amp;&amp; arr[i] &lt; arr[2 * i-1]) {<br>\t\t\tmaxpos = 2 * i-1;<br>\t\t}<br>\t\tif (2 * i  &lt; len &amp;&amp; arr[maxpos] &lt; arr[2 * i ]) {<br>\t\t\tmaxpos = 2 * i;<br>\t\t}<br>\t\tif (maxpos == i) {<br>\t\t\tbreak;<br>\t\t}<br>\t\tswap(arr, maxpos, i);<br>\t\ti = maxpos;<br>\t}<br>}<br>void buildheap(int arr[], int len) {<br>\tfor (int i = len &#47; 2; i &gt; 0; --i) {<br>\t\theapify(arr, i, len);<br>\t}<br>}<br><br>void heapsort(int arr[], int len) {<br>\tbuildheap(arr, len);&#47;&#47;建堆<br>\tint k = len;<br>\twhile (k &gt; 0){<br>\t\tswap(arr, 1, k-1);<br>\t\t--k;<br>\t\theapify(arr, 1, k);<br>\t}<br><br>\tfor (int i = 0; i &lt; len; i++){<br>\t\tstd::cout &lt;&lt; arr[i] &lt;&lt; &quot;,&quot;;<br>\t}<br>\tstd::cout &lt;&lt; std::endl;<br>}","like_count":0},{"had_liked":false,"id":251072,"user_name":"上善若水","can_delete":false,"product_type":"c1","uid":1653332,"ip_address":"","ucode":"E3F15FB8576626","user_header":"https://static001.geekbang.org/account/avatar/00/19/3a/54/72402617.jpg","comment_is_top":false,"comment_ctime":1601356810,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1601356810","product_id":100017301,"comment_content":"堆是三维数据结构吗？","like_count":0},{"had_liked":false,"id":250693,"user_name":"随风","can_delete":false,"product_type":"c1","uid":1476862,"ip_address":"","ucode":"037CE3554D8AB9","user_header":"https://static001.geekbang.org/account/avatar/00/16/88/fe/c18a85fe.jpg","comment_is_top":false,"comment_ctime":1601197982,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601197982","product_id":100017301,"comment_content":"子节点 = 父节点*2和父节点* 2 + 1, 那父节点= 子节点&#47;2 和（子节点-1）&#47;2， 则最后一个父节点就是n&#47;2, 那n&#47;2之后的节点都是叶子节点.","like_count":0},{"had_liked":false,"id":250656,"user_name":"west","can_delete":false,"product_type":"c1","uid":2080899,"ip_address":"","ucode":"B42BF349E55900","user_header":"https://static001.geekbang.org/account/avatar/00/1f/c0/83/ca1c44d5.jpg","comment_is_top":false,"comment_ctime":1601187643,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601187643","product_id":100017301,"comment_content":"#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;algorithm&gt;<br>struct Heap {<br>  int size;<br>  int curr;<br>  bool (*compare)(int, int);<br>  int ele[0];<br>};<br><br>typedef Heap MaxHeap;<br>typedef Heap MinHeap;<br>void swin(Heap* h);<br>void sink(Heap* h);<br>Heap* resize(Heap* h, int size);<br>bool greater(int x, int y)<br>{<br>  return x &gt; y;<br>}<br>bool less(int x, int y)<br>{<br>  return x &lt; y;<br>}<br>MaxHeap* CreateMaxHeap(int n)<br>{<br>  MinHeap* h = (MinHeap*)malloc(sizeof(MinHeap) + 4*(n+1)); <br>  if (h) {<br>    h-&gt;size = n;<br>    h-&gt;curr = 0;<br>    h-&gt;compare = less;<br>  }<br>  return h;<br>}<br>MinHeap* CreateMinHeap(int n)<br>{<br>  MaxHeap* h = (MaxHeap*)malloc(sizeof(MaxHeap) + 4*(n+1)); <br>  if (h) {<br>    h-&gt;size = n;<br>    h-&gt;curr = 0;<br>    h-&gt;compare = greater;<br>  }<br>  return h;<br>}<br>Heap* Insert(Heap* h, int value)<br>{<br>  if (h-&gt;curr &gt;= h-&gt;size) {<br>    h = resize(h, h-&gt;size*2);<br>  }<br>  h-&gt;curr++;<br>  h-&gt;ele[h-&gt;curr] = value;<br>  swin(h);<br>  return h;<br>}<br>Heap* resize(Heap* h, int size)<br>{<br>  h-&gt;size = size;<br>  size++;<br>  h = (Heap*)realloc(h, sizeof(Heap) + (4*size));   <br>  return h;<br>}<br><br>&#47;&#47;上浮<br>void swin(Heap* h)<br>{<br>  int N = h-&gt;curr; <br>  int p = N&#47;2;<br>  while ( N &gt; 1 &amp;&amp; h-&gt;compare(h-&gt;ele[p], h-&gt;ele[N]) ) {<br>    std::swap(h-&gt;ele[p], h-&gt;ele[N]); <br>    N = p;<br>    p = N&#47;2;<br>  }<br>}<br><br>&#47;&#47;下沉<br>void sink(Heap* h)<br>{<br>  int N = h-&gt;curr; <br>  int pos = 1;<br>  int l = 2*pos;<br>  while (l &lt;= N) {<br>    int r = 2*pos + 1; <br>    if ( r &lt;= N &amp;&amp; h-&gt;compare(h-&gt;ele[l], h-&gt;ele[r]) ) {<br>      l = r;<br>    }<br>    if (h-&gt;compare(h-&gt;ele[l], h-&gt;ele[pos]))break;<br>    std::swap(h-&gt;ele[l], h-&gt;ele[pos]);<br>    pos = l;<br>    l = 2 * pos;<br>  }<br>}<br><br>int top(Heap* h)<br>{<br>  return h-&gt;curr &gt;= 1 ? h-&gt;ele[1] : INT_MIN;<br>}<br><br>bool pop(Heap* h)<br>{<br>  if (top(h) == INT_MIN) {<br>    return false;<br>  }<br>  std::swap(h-&gt;ele[h-&gt;curr], h-&gt;ele[1]);<br>  h-&gt;curr--;<br>  sink(h);<br>  return true;<br>}<br>void ReleaseHeap(Heap* h)<br>{<br>  h-&gt;size = 0;<br>  free(h);<br>}<br>int main()<br>{<br>  MaxHeap* h = CreateMaxHeap(10);<br>  for (int i=0; i &lt;= 100; i++) {<br>    h = Insert(h, i);<br>  }<br>  for (int i=0; i &lt;= 13; ++i) {<br>    printf(&quot;Max value: %d\\n&quot;, top(h));<br>    pop(h);<br>  }<br>  ReleaseHeap(h);<br>}","like_count":0},{"had_liked":false,"id":250416,"user_name":"jack","can_delete":false,"product_type":"c1","uid":1898292,"ip_address":"","ucode":"A2253AC8570C5E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/jibauP3icEFic4w56L2ddVghL7h2gGKhFdW8lBfE9rpwwRgzUKkLFY9wb4w70AXz7retME96a6EBRTA0LvSLn0ib8A/132","comment_is_top":false,"comment_ctime":1601079059,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1601079059","product_id":100017301,"comment_content":"对于第一个问题：对于节点个数为n的完全二叉树来说，若下标从n&#47;2+1到n的节点若不是叶子节点，则必有左子树并且左子树的下标从n+2到2n，而此与节点数为n矛盾，故下标从n&#47;2+1到n的节点必须是叶子节点。","like_count":0},{"had_liked":false,"id":248654,"user_name":"子瞻","can_delete":false,"product_type":"c1","uid":1324314,"ip_address":"","ucode":"5C26FF10934534","user_header":"https://static001.geekbang.org/account/avatar/00/14/35/1a/9fa38dc9.jpg","comment_is_top":false,"comment_ctime":1600254268,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600254268","product_id":100017301,"comment_content":"等比数列*等差数列:错位相减法","like_count":0},{"had_liked":false,"id":247075,"user_name":"吴贤龙","can_delete":false,"product_type":"c1","uid":1220566,"ip_address":"","ucode":"45085FE86D6030","user_header":"https://static001.geekbang.org/account/avatar/00/12/9f/d6/f66133b4.jpg","comment_is_top":false,"comment_ctime":1599577792,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599577792","product_id":100017301,"comment_content":"老师，真对堆这个结构，删除堆顶或者删除最后一个叶节点，很好好处理，那如果不是删除这两个节点，需求是删除其他节点呢？为了保持堆的完全二叉性，是不是就不适合用这个数据结构呢？","like_count":0},{"had_liked":false,"id":240676,"user_name":"赵","can_delete":false,"product_type":"c1","uid":1730160,"ip_address":"","ucode":"EAC4390FD95EF9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/O3Uf8dibBnKKzibgEhvvKs9vic0dBavSJzn79fZVtH0AxcUT09bvOAYvr2f7vecmwiao7BBGgE5p8lXHSoBMdmQuBw/132","comment_is_top":false,"comment_ctime":1597031534,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597031534","product_id":100017301,"comment_content":"对于叶子节点来说肯定是在最后一层和倒数第二层，最后一个节点的父节点肯定是最后一个不是叶子节点的，所以说父节点的下一个节点就是第一个开始的叶子节点，所以先求父节点（n&#47;2），再求第一个叶子节点（n&#47;2+1），可得结论   “完全二叉树的下标从（n&#47;2+1）到 n 的都是叶子节点”","like_count":0},{"had_liked":false,"id":237194,"user_name":"吴亦凡","can_delete":false,"product_type":"c1","uid":2019760,"ip_address":"","ucode":"A785AD9C98D657","user_header":"https://static001.geekbang.org/account/avatar/00/1e/d1/b0/f4e91c7b.jpg","comment_is_top":false,"comment_ctime":1595733493,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1595733493","product_id":100017301,"comment_content":"不理解为什么堆化了还要再排序？堆化本身就是一个带排序的功能吧？为什么在做堆排序的时候还要算上排序的时间复杂度？","like_count":0,"discussions":[{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295183,"discussion_content":"你看代码就知道了，因为建堆是对非叶子节点进行了堆化时间复杂度是o(n)，而排序是把每个节点放到堆顶又各堆化了一次时间复杂度是o(nlogn),总的时间复杂度就是o(nlogn)，btw你的名字很有性格","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596111315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":237149,"user_name":"Merry","can_delete":false,"product_type":"c1","uid":1024036,"ip_address":"","ucode":"E2A114E10814BA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a0/24/68c679c8.jpg","comment_is_top":false,"comment_ctime":1595689968,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595689968","product_id":100017301,"comment_content":"1.完全二叉树的顺序存储(即数组)下标范围1～n，完全二叉树符合一个特性：2*i&gt;=n时，序号为i的节点就是叶子节点。序号为n&#47;2的节点为最后一个分支节点，故序号为n&#47;2+1的节点为叶子节点","like_count":0},{"had_liked":false,"id":237137,"user_name":"Shanks-王冲","can_delete":false,"product_type":"c1","uid":1042983,"ip_address":"","ucode":"C4B90A17850E20","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ea/27/a3737d61.jpg","comment_is_top":false,"comment_ctime":1595688059,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595688059","product_id":100017301,"comment_content":"fumeck.com������������summer sk...：我们将下标从 n&#47;2 到 1的节点，依次进行从上到下的堆化操作<br>不是由下往上吗老师，最后一个才轮到根节点阿<br>争哥： 哈哈 弄混淆了 堆化是有两种方式：从上到下和从下到上，前面讲到了。我这里说的从下到上，是指的堆化操作本身。【 感觉这个回复很有意思，应该还有细节我没注意到，于是... 】<br><br>#### 1.认清概念<br>- 文章中“堆化实际上有两种，从下往上和从上往下。” -&gt; bottom up(从下往上&#47;自下往上堆化) 和 top-down(从上往下&#47;自上往下堆化)；<br><br>- 文章中“堆化非常简单，就是顺着节点所在的路径，**向上**或者**向下**，对比，然后交换。” -&gt; siftUp(向上筛选 or 这句话中的“向上”) 或 siftDown(向下筛选 or 这句话中的“向下”)；<br><br>- 插入操作：用子节点，和父节点比较，然后交换 —— 这是一次siftUp操作(堆化过程中最小执行单元)；继续向上，用新的子节点，和父节点比较，然后交换 —— 从下往上&#47;自下往上堆化 —— 一次bottom up操作；<br><br>- 删除堆顶元素：用父节点，和子节点比较，然后交换 —— 这是一次siftDown操作(堆化过程中最小执行单元)；继续向下，用新的父节点，和子节点比较，然后交换 —— 从上往下&#47;自上往下堆化 —— 一次top-down操作；<br><br>#### 2.发现规律<br>- 插入操作 ~= bottom up =  n * siftUp；<br><br>- 删除操作 ~= top-down =  n * siftDown；<br><br>#### 3.解开谜团<br>建堆，有两种思路 ——<br>1. 第一种借助前面讲的，插入一个元素的思路。...依次插入元素，...，每个数据插入堆中时，从下往上堆化；“从下往上” -&gt; 插入操作的bottom-up<br>2. 第二种实现思路，...每个数据都是从上往下堆化；“从上往下” -&gt; siftDown<br><br>ref: <br>1. https:&#47;&#47;en.wikipedia.org&#47;wiki&#47;Heapsort<br>2. 结合本文中的理解；","like_count":0},{"had_liked":false,"id":236127,"user_name":"极客学子","can_delete":false,"product_type":"c1","uid":1149510,"ip_address":"","ucode":"40051597564EB7","user_header":"https://static001.geekbang.org/account/avatar/00/11/8a/46/71747b18.jpg","comment_is_top":false,"comment_ctime":1595323056,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595323056","product_id":100017301,"comment_content":"1.最后一个叶子节点下标是n，那它的父节点下标就是 n &#47; 2,也就是最后一个拥有子节点的节点，那从它开始就都是叶子节点了，即下标 n &#47; 2 + 1 后的节点；<br>2.堆的经典应用有求 top 数，优先级队列","like_count":0},{"had_liked":false,"id":236062,"user_name":"🐬🐬🐬","can_delete":false,"product_type":"c1","uid":1155214,"ip_address":"","ucode":"6585F8B8ADC43E","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/8e/919dee01.jpg","comment_is_top":false,"comment_ctime":1595300710,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1595300710","product_id":100017301,"comment_content":"建堆第一种怎么看是从上往下建堆呢 第二种才是从下往上吧 有点疑惑","like_count":0,"discussions":[{"author":{"id":1155214,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a0/8e/919dee01.jpg","nickname":"🐬🐬🐬","note":"","ucode":"6585F8B8ADC43E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293194,"discussion_content":"知道了 这个是对每个插入的数据来说的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595473949,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235315,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1194572,"ip_address":"","ucode":"FBFAE23E8E48B7","user_header":"https://static001.geekbang.org/account/avatar/00/12/3a/4c/b6200773.jpg","comment_is_top":false,"comment_ctime":1594971848,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594971848","product_id":100017301,"comment_content":"数据从前往后处理时，说明前面部分已有序，新加入数据插入到有序数列，也就是说堆的上边是有序的，所以是从下到上堆化。从后往前处理数据时，也就是说数组的后边是有序的，堆的下面有序，所以要从上往下堆化(插入到有序数列)","like_count":0},{"had_liked":false,"id":233802,"user_name":"Geek_宋","can_delete":false,"product_type":"c1","uid":1735002,"ip_address":"","ucode":"B050CEE1BE9221","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/loOqiajRMDoBmMs8bLeIjfhwYN0DNf3ic7x92hw6mW5GWG3mVkw7ub52cqjvkVqt4Fq3fU0A2C7WcsS3icIlOd1fg/132","comment_is_top":false,"comment_ctime":1594456834,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594456834","product_id":100017301,"comment_content":"计算机专业毕业十年，终于搞懂了堆排序！😓","like_count":0},{"had_liked":false,"id":227505,"user_name":"Sean","can_delete":false,"product_type":"c1","uid":1490049,"ip_address":"","ucode":"9360D9FBB2F851","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJpJz0SORayxydkezyVfk4TvDcJjSahuMbvXPkCbvvjC4RLt6picrlp4rrxXm22TbRQrbC6ibl8zNSw/132","comment_is_top":false,"comment_ctime":1592394078,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1592394078","product_id":100017301,"comment_content":"数据库里的limit offset size","like_count":0},{"had_liked":false,"id":217809,"user_name":"亢（知行合一的路上）","can_delete":false,"product_type":"c1","uid":1347013,"ip_address":"","ucode":"958AF7C96EB9E8","user_header":"https://static001.geekbang.org/account/avatar/00/14/8d/c5/898b13b4.jpg","comment_is_top":false,"comment_ctime":1589617690,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589617690","product_id":100017301,"comment_content":"堆，部分有序，对于取 TopN 的场景就很适合，不要求完全有序。","like_count":0},{"had_liked":false,"id":217227,"user_name":"mqray","can_delete":false,"product_type":"c1","uid":1336634,"ip_address":"","ucode":"15664507AD7033","user_header":"https://static001.geekbang.org/account/avatar/00/14/65/3a/bc801fb2.jpg","comment_is_top":false,"comment_ctime":1589443656,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589443656","product_id":100017301,"comment_content":"def heapify(nums,n,i):<br>    &#39;&#39;&#39;<br><br>    :param nums: 传入的数组，这里堆(完全二叉树)的存储方式是数组<br>    :param n:数组的长度，用来界定 堆化过程是否有左右子树，以减少比较次数<br>    :param i:每次都是 将小树转变成小根堆，或大根堆<br>    :return:<br>    &#39;&#39;&#39;<br>    if i&gt;= n:<br>        return<br>    left,right = i*2+1,i*2+2#记录可能存在的左右子节点(下标从0开始)<br>    max_index = i#记录此时这个子树中的最大值<br>    if left &lt; n and nums[left] &gt; nums[max_index]:#如果左子元素大于此时的根节点，先记录最大值的位置<br>        max_index = left<br>    if right &lt; n and nums[right] &gt; nums[max_index]:#如果右子元素大于此时这颗小树的最大值，更新最大值<br>        max_index = right<br>    # 如果max_index==i ，说明此前就是大顶堆<br>    if max_index != i:#此前，这个小树不符合大根堆的情况，就交换原根节点和最大节点<br>        nums[max_index],nums[i] = nums[i],nums[max_index]<br>        #对于这颗小树，我们只是比较了最上层的三个元素，交换操作可能导致下层的子树不再符合大顶堆的要求，所以需要堆化<br>        heapify(nums,n,max_index)<br><br>def heap_sort(nums,n):<br>    &#39;&#39;&#39;<br><br>    :param nums: 数组元素<br>    :param n: 数组长度<br>    :return:<br>    &#39;&#39;&#39;<br>    for i in range(n&#47;&#47;2,-1,-1):<br>        heapify(nums,n,i)#创建堆<br>    #对前面一半的元素建堆之后并不能保证此时的数组是从小到大排列的，还需要进一步的操作<br>    #将栈顶元素与末尾元素交换，并移除此时的末尾元素[不再管理末尾元素]<br>    #由于元素交换，所以需要将此节点进行堆化<br>    for i in range(n-1,-1,-1):<br>        nums[i],nums[0] = nums[0],nums[i]#交换堆顶元素与最末尾元素<br>        heapify(nums,i,0)#对根部元素进行堆化,千万要注意这里传入的第二个参数要实时修改，改为i而不是n<br>    return nums","like_count":0},{"had_liked":false,"id":216424,"user_name":"Geek_ac7784","can_delete":false,"product_type":"c1","uid":1981613,"ip_address":"","ucode":"62F0E5E6D6F4BA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/8Dj4ugujXwY24G8pcpgDFGiciarXetG3ItQ4M9mSQMLyRdRRXEXXJVfib48mGUQAu87QcvImwyJIVJlEFeEguV44w/132","comment_is_top":false,"comment_ctime":1589256839,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589256839","product_id":100017301,"comment_content":"学习笔记：<br>堆:<br>1. 任意子树，根节点&gt;=或&lt;=子节点<br>2. 插入：放在末尾，自下向上堆化<br>3. 删除：堆顶与末尾交换，自上向下堆化<br>堆排序:<br>1. 建堆:除了叶子，左右子树自上向下堆化(n&#47;2往前)，复杂度O(n)<br>2.排序每次将堆顶元素删除，放在数组末尾<br>堆排序与快速排序比较:<br>+ 堆排序不是顺序访问<br>+ 建堆过程增加逆序度<br>所以堆排序比快速排序慢一些 <br>思考题：<br>1. 推导: 已知2n 2n+1分别是该节点的左右子节点。一定存在某点k使得2k或2k+1为堆的最后一个元素。那么。容易得到k之后的元素都是叶子结点。2k 或者2k+1为堆的末结点 n 。k = n&#47;2 向下取整，证毕<br>2. 优先队列。入队随意，出队只要最大或最小的。","like_count":0},{"had_liked":false,"id":215760,"user_name":"陈小狮","can_delete":false,"product_type":"c1","uid":1458026,"ip_address":"","ucode":"7679BA5775DC9C","user_header":"https://static001.geekbang.org/account/avatar/00/16/3f/6a/e68b9f23.jpg","comment_is_top":false,"comment_ctime":1589097740,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589097740","product_id":100017301,"comment_content":"老师，请教一下，堆这种结构好像对删除操作不是很友好，只能从堆顶删除。<br>若是要删除中间节点，只能遍历数据将要删除数据的后面元素往前搬移1位 再重新堆化数组吗？","like_count":0},{"had_liked":false,"id":215750,"user_name":"颇忒妥","can_delete":false,"product_type":"c1","uid":1026448,"ip_address":"","ucode":"AA86AD1049BC2E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a9/90/0c5ed3d9.jpg","comment_is_top":false,"comment_ctime":1589096162,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589096162","product_id":100017301,"comment_content":"堆排序就是不停：<br>1. 建个大顶堆，求得最大元素，放到屁股后面<br>2. 对其余元素重复第一步<br>直到没有元素为止","like_count":0},{"had_liked":false,"id":215165,"user_name":"        ","can_delete":false,"product_type":"c1","uid":1255918,"ip_address":"","ucode":"21028A49D81B06","user_header":"https://static001.geekbang.org/account/avatar/00/13/29/ee/fba11edf.jpg","comment_is_top":false,"comment_ctime":1588919442,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588919442","product_id":100017301,"comment_content":"给大家提一个思考题：使用链表结构实现一个优先队列，保证操作所需的时间还是对数级别，要怎么实现呢？","like_count":0},{"had_liked":false,"id":214238,"user_name":"Allan","can_delete":false,"product_type":"c1","uid":1310388,"ip_address":"","ucode":"8DA4DBECC2C45C","user_header":"https://static001.geekbang.org/account/avatar/00/13/fe/b4/295338e7.jpg","comment_is_top":false,"comment_ctime":1588682365,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588682365","product_id":100017301,"comment_content":"60天攻克算法打卡行动第23天<br><br><br><br>26 | 红黑树（下）：掌握这些技巧，你也可以实现一个红黑树<br><br>实现红黑树的思想<br>左旋：围绕某个节点左旋 右旋：围绕某个节点右旋<br>插入操作的平衡调整<br>插入的节点必须是红色，而且插入的位置是叶子节点。<br>需要两种特殊情况：1、插入节点的父节点是黑色我们什么都不做 2、如果插入节点是根节点，把它变成黑色<br>其他的操作情况我们都需要进行左旋或者右旋来调整树的平衡。我们正在处理的节点，我们叫做关注节点。<br><br><br>删除操作的平衡调整<br>删除的操作调整比较复杂，总归要记住红黑树的要求规则<br>对于左旋右旋没有搞明白？文章也没有介绍过怎么个旋转法。<br>针对删除操作，我们有两次调整，第一次是针对要删除的节点做初步调整，让调整后的红黑树继续满足第四条定义，“每个节点到可达叶子节点的路径都包含相同个数的黑色节点”。但是这个时候，第三条定义就不满足了，有可能会存在两个红色节点相邻的情况。第二次调整就是解决这个问题，让红黑树不存在相邻的红色节点。<br><br>通过本节对红黑树了解了一个大概，但还是需要自己再进一步更深的探究。<br><br>所有的叶子结点都是黑色的空节点，他们是有一个哨兵机制来实现的，为的就是节省空间。<br><br><br>学习内容 :堆和堆排序：为什么说堆排序没有快速排序快？（二）<br><br>掌握“堆”的基础概念和实现方法之后，结合“堆”排序的原理和特点，我们就能明白堆排序和快速排序之间的差异。<br>堆是一个完全二叉树；堆中的每个节点的值都必须大于等于（或者小于等于）其子树中每个节点的值。<br>大顶堆，小顶堆。<br><br>1.基于堆实现排序一：建堆<br><br>可以通过数组来存储堆，i&#47;2 是父节点，i*2是左子节点，，i*2 + 1是右子节点<br>在原数组操作不借别的空间，原地操作。<br>每个节点堆化的复杂度O（logn），堆排序建堆的过程时间复杂度O（n），非叶子节点不需要堆化，所以从倒数第二层开始 S1 = 1*h + 2^1*（h-1）+ 2^2 * (h-2) ... h^k * 1;<br>公式左右两边乘以2得到S2 ，用S2 - S1 得到\t= -h + 2 + 2^2 + 2^3 + ... + 2^h 除了 -h 后面的是等比公式，S = -h+(2^h -2)+2^h = 2^(h+1)-h-2<br>因为 h=log2​n，代入公式 S，就能得到 S=O(n)，所以，建堆的时间复杂度就是 O(n)。<br> <br><br>2.基于堆实现排序一：排序<br><br>建堆完成后就是大顶堆的结构，那么root就是最大的。那么我们依次按照删除的操作进行排序就可以完成堆的排序。<br><br>快速排序优于堆排序，一是索引顺序问题，二是比较次数问题","like_count":0},{"had_liked":false,"id":213608,"user_name":"默默","can_delete":false,"product_type":"c1","uid":1006635,"ip_address":"","ucode":"AF798B9D327F24","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/2b/8b771383.jpg","comment_is_top":false,"comment_ctime":1588490144,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588490144","product_id":100017301,"comment_content":"问题一：因为如果n&#47;2+1不是叶子结点，因为是完全二叉树，该结点的右儿子结点为2*(n&#47;2+1)，而总的结点个数为n。所以n&#47;2+1之后的结点必定是叶子结点<br>问题二：top K。","like_count":0},{"had_liked":false,"id":211337,"user_name":"沙","can_delete":false,"product_type":"c1","uid":1377412,"ip_address":"","ucode":"131A5114452DE5","user_header":"https://static001.geekbang.org/account/avatar/00/15/04/84/cb0a009b.jpg","comment_is_top":false,"comment_ctime":1587949981,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1587949981","product_id":100017301,"comment_content":"题目1，对于完全二叉树来说，父节点与子节点之间的位置关系是：下标为1的情况下，父节点位置为i，则对应的子节点的2*i和2*i+1，因此最后一个节点n为n&#47;2的子节点，大于n&#47;2的所有节点都没有了子节点","like_count":0},{"had_liked":false,"id":211232,"user_name":"黄金果","can_delete":false,"product_type":"c1","uid":1456586,"ip_address":"","ucode":"329811FF99F4B8","user_header":"https://static001.geekbang.org/account/avatar/00/16/39/ca/cdc58834.jpg","comment_is_top":false,"comment_ctime":1587918333,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587918333","product_id":100017301,"comment_content":"问题一: 最后一个节点的下标是N, N&#47;2对应的是最后一个父节点, 所以从N&#47;2+1 到 N 都是子节点","like_count":0},{"had_liked":false,"id":207794,"user_name":"王jojo","can_delete":false,"product_type":"c1","uid":1812840,"ip_address":"","ucode":"1ABE7FA2614F86","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/68/ec442a70.jpg","comment_is_top":false,"comment_ctime":1587181609,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587181609","product_id":100017301,"comment_content":"看的完全二叉树的百度百科<br>第一题: 可以根据公式进行推导，假设n0是度为0的结点总数（即叶子结点数），n1是度为1的结点总数，n2是度为2的结点总数，则 ：<br>①n= n0+n1+n2 （其中n为完全二叉树的结点总数）；又因为一个度为2的结点会有2个子结点，一个度为1的结点会有1个子结点，除根结点外其他结点都有父结点，<br>②n= 1+n1+2*n2(由完全二叉树定义可知,最多有一个度为0的节点) ；由①、②两式把n2消去得：n= 2*n0+n1-1，由于完全二叉树中度为1的结点数只有两种可能0或1，由此得到n0=n&#47;2 或 n0=(n+1)&#47;2。<br>简便来算，就是 n0=n&#47;2，其中n为奇数时（n1=0）向上取整；n为偶数时（n1=1）向下取整。可根据完全二叉树的结点总数计算出叶子结点数。","like_count":0},{"had_liked":false,"id":207601,"user_name":"笑","can_delete":false,"product_type":"c1","uid":1284647,"ip_address":"","ucode":"C91EAFAB88E5AC","user_header":"https://static001.geekbang.org/account/avatar/00/13/9a/27/4b81bce5.jpg","comment_is_top":false,"comment_ctime":1587116807,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587116807","product_id":100017301,"comment_content":"我感觉删除堆顶的操作有问题啊，比如那个大顶堆，27那个节点如果是20的话，移到堆顶后是不是比它的右子节点大了？是不是不可能存在这种情况？","like_count":0},{"had_liked":false,"id":206808,"user_name":"梅端","can_delete":false,"product_type":"c1","uid":1525335,"ip_address":"","ucode":"FEC08731457770","user_header":"https://static001.geekbang.org/account/avatar/00/17/46/57/fe38a6db.jpg","comment_is_top":false,"comment_ctime":1586939135,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586939135","product_id":100017301,"comment_content":"好在堆的实现和概念之前有过了解，这节课终于是可以完全听懂了，加油！！！","like_count":0},{"had_liked":false,"id":204524,"user_name":"靠人品去赢","can_delete":false,"product_type":"c1","uid":1301286,"ip_address":"","ucode":"7A20F9EBE847E1","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/26/54f2c164.jpg","comment_is_top":false,"comment_ctime":1586416735,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586416735","product_id":100017301,"comment_content":"老师这个堆介绍学习，要比我之前看的材料说得清楚多来，很多说到堆这一块，就是提一嘴的感觉不怎么深入。","like_count":0},{"had_liked":false,"id":202665,"user_name":"喻茂","can_delete":false,"product_type":"c1","uid":1318661,"ip_address":"","ucode":"C8BD8086A17365","user_header":"https://static001.geekbang.org/account/avatar/00/14/1f/05/8a06692e.jpg","comment_is_top":false,"comment_ctime":1586050301,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586050301","product_id":100017301,"comment_content":"$testArr = [5,6,7,8,1,2,16,13,15,9,27,21,33,22];<br>$heap = new Heap(100);<br>foreach ($testArr as $value) {<br>\t$heap-&gt;insert($value);<br>}<br>echo &quot;&lt;pre&gt;&quot;;<br>var_dump($heap-&gt;arr);<br><br><br>echo &quot;&lt;br&gt;------------------------&lt;br&gt;&quot;;<br>$heap-&gt;removeMax();<br>var_dump($heap-&gt;arr);<br><br>$testArr2 = [1=&gt;5,2=&gt;6,3=&gt;7,4=&gt;8,5=&gt;1,6=&gt;2,7=&gt;16,8=&gt;13,9=&gt;15,10=&gt;9,11=&gt;27,12=&gt;21,13=&gt;33,14=&gt;22];<br>$heap2 = new Heap(100);<br>$heap2-&gt;arr = $testArr2;<br>$heap2-&gt;count = 14;<br>echo &quot;&lt;br&gt;堆化前:&lt;br&gt;&quot;;<br><br>var_dump($heap2-&gt;arr);<br>$heap2-&gt;buildHeap();<br>echo &quot;&lt;br&gt;堆化后:&lt;br&gt;&quot;;<br><br>var_dump($heap2-&gt;arr);<br><br>echo &quot;&lt;br&gt;排序后:&lt;br&gt;&quot;;<br>$heap2-&gt;sort();<br>var_dump($heap2-&gt;arr);","like_count":0},{"had_liked":false,"id":202664,"user_name":"喻茂","can_delete":false,"product_type":"c1","uid":1318661,"ip_address":"","ucode":"C8BD8086A17365","user_header":"https://static001.geekbang.org/account/avatar/00/14/1f/05/8a06692e.jpg","comment_is_top":false,"comment_ctime":1586050289,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586050289","product_id":100017301,"comment_content":"class Heap {<br>\tpublic $arr; &#47;&#47; 数组保存堆数据<br>\tpublic $n; &#47;&#47; 堆可以存储的最大数据个数<br>\tpublic $count; &#47;&#47; 堆中已经存储元素个数<br>\t<br>\tpublic function __construct($capacity) {<br>\t\t$this-&gt;n = $capacity;<br>\t\t$this-&gt;count = 0;<br>\t}<br>\t<br>\t&#47;&#47; 删除堆顶元素<br>\tpublic function removeMax() {<br>\t\tif ($this-&gt;count == 0) {<br>\t\t\techo &quot;堆为空!&quot;;<br>\t\t\treturn false;<br>\t\t}<br>\t\t$this-&gt;arr[1] = $this-&gt;arr[$this-&gt;count];<br>\t\tunset($this-&gt;arr[$this-&gt;count]);<br>\t\t$this-&gt;count--;<br>\t\t$this-&gt;heapify(1);<br>\t}<br>\t<br>\t&#47;&#47; 数据已经存在了自上往下堆化<br>\tpublic function buildHeap() {<br>\t\tfor ($i=intval($this-&gt;count&#47;2);$i &gt;= 1;$i--) {<br>\t\t\t$this-&gt;heapify($i);<br>\t\t}<br>\t}<br>\t<br>\t&#47;&#47; 排序<br>\tpublic function sort() {<br>\t\t&#47;&#47; 建堆<br>\t\t$this-&gt;buildHeap();<br>\t\t$k = $this-&gt;count;<br>\t\twhile($k &gt; 1) {<br>\t\t\t$tmp = $this-&gt;arr[$k];<br>\t\t\t$this-&gt;arr[$k] = $this-&gt;arr[1];<br>\t\t\t$this-&gt;arr[1] = $tmp;<br>\t\t\t$k--;<br>\t\t\t&#47;&#47; 再次建堆<br>\t\t\t$this-&gt;heapify(1,$k);<br>\t\t}<br>\t}<br>\t&#47;&#47; 从上往下堆化<br>\tprivate function heapify($i,$k=0) {<br>\t\twhile (true) {<br>\t\t\t$maxPos=$i;<br>\t\t\t&#47;&#47; 和当前节点的左右子节点中大者交换<br>\t\t\tif (empty($k)) {<br>\t\t\t\tif ($i*2 &lt;= $this-&gt;count &amp;&amp; $this-&gt;arr[$i] &lt; $this-&gt;arr[$i*2]) {<br>\t\t\t\t\t$maxPos = $i*2;<br>\t\t\t\t}<br>\t\t\t<br>\t\t\t\tif (($i*2 + 1) &lt;= $this-&gt;count &amp;&amp; $this-&gt;arr[$maxPos] &lt; $this-&gt;arr[$i*2 + 1]) {<br>\t\t\t\t\t$maxPos = $i*2+1;<br>\t\t\t\t}<br>\t\t\t} else {<br>\t\t\t\tif ($i*2 &lt;= $k &amp;&amp; $this-&gt;arr[$i] &lt; $this-&gt;arr[$i*2]) {<br>\t\t\t\t\t$maxPos = $i*2;<br>\t\t\t\t}<br>\t\t\t<br>\t\t\t\tif (($i*2 + 1) &lt;= $k &amp;&amp; $this-&gt;arr[$maxPos] &lt; $this-&gt;arr[$i*2 + 1]) {<br>\t\t\t\t\t$maxPos = $i*2+1;<br>\t\t\t\t}<br>\t\t\t}<br>\t\t\t<br>\t\t\t<br>\t\t\tif ($maxPos == $i) {<br>\t\t\t\tbreak;<br>\t\t\t}<br>\t\t\t<br>\t\t\t&#47;&#47; 交换<br>\t\t\t$tmp = $this-&gt;arr[$maxPos];<br>\t\t\t$this-&gt;arr[$maxPos] = $this-&gt;arr[$i];<br>\t\t\t$this-&gt;arr[$i] = $tmp;<br>\t\t\t$i = $maxPos;<br>\t\t}<br>\t}<br>\t<br>\t&#47;&#47; 添加数据 自下往上堆化<br>\tpublic function insert($data) {<br>\t\tif ($this-&gt;count &gt;= $this-&gt;n) { &#47;&#47; 堆满<br>\t\t\techo &quot;堆满&lt;br&gt;&quot;;<br>\t\t}<br>\t\t<br>\t\t$this-&gt;count++;<br>\t\t$this-&gt;arr[$this-&gt;count] = $data;<br>\t\t$j = $this-&gt;count;<br>\t\t$i = intval($j &#47; 2);<br>\t\twhile ($i &gt; 0 &amp;&amp; $this-&gt;arr[$j] &gt; $this-&gt;arr[$i]) { &#47;&#47; 自下往上堆化<br>\t\t\t&#47;&#47; 交换<br>\t\t\t$tmp = $this-&gt;arr[$j];<br>\t\t\t$this-&gt;arr[$j] = $this-&gt;arr[$i];<br>\t\t\t$this-&gt;arr[$i] = $tmp;<br>\t\t\t$j = $i;<br>\t\t\t$i = intval($j &#47; 2);<br>\t\t}\t\t\t<br>\t}<br>}","like_count":0},{"had_liked":false,"id":201472,"user_name":"naku","can_delete":false,"product_type":"c1","uid":1528610,"ip_address":"","ucode":"B49EF5B5B38400","user_header":"https://static001.geekbang.org/account/avatar/00/17/53/22/cce9a2e5.jpg","comment_is_top":false,"comment_ctime":1585792467,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1585792467","product_id":100017301,"comment_content":"老师关于为什么堆排序没有快速排序快的描述我有下面这种写法，我是根据老师说的交换次数这个词的描述而得到的启发。<br>堆排序： 最差情况<br>\t建堆：lg1+lg2+...+lgn = lg(n!) 次数据交换<br>\t顶和尾的交换：n次<br>\t顶和尾交换后的调整lg(n)+lg(n-1)+...+lg1 = lg(n!)<br>\t**总计:**2*lg(n)+n<br><br>快速排序：最差情况<br>\t第一次: n次交换<br>\t第二次: n-2^0<br>\t第三次: n-2^1<br>\t第4次：n-2^2<br>\t........<br>\t第lgn次: n-2^(lgn)\t<br>**总计： **n*lgn-n<br><br>问题就是为啥我得到的快排的最差的情况也是n*lgn  我是哪里错了吗。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。 我记得之前说的会退化到n^2的啊， 但我也没觉得我哪里写的有问题，请老师指点下","like_count":0,"discussions":[{"author":{"id":1528610,"avatar":"https://static001.geekbang.org/account/avatar/00/17/53/22/cce9a2e5.jpg","nickname":"naku","note":"","ucode":"B49EF5B5B38400","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219712,"discussion_content":"又去看了前面的章节，知道了，2的平方哪里出问题了，不一定pivot刚好分成两个未排序区间，也可能是一个，如果全都没分成两个，那就是n,n-1,n-2…了，那最差的情况在n大的情况下应该比堆排序慢吧。不过之前有方法找到一个pivot来基本保证要找的pivot不在边缘位置，所以快排应该是最好的选择了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585797469,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":201454,"user_name":"naku","can_delete":false,"product_type":"c1","uid":1528610,"ip_address":"","ucode":"B49EF5B5B38400","user_header":"https://static001.geekbang.org/account/avatar/00/17/53/22/cce9a2e5.jpg","comment_is_top":false,"comment_ctime":1585790434,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1585790434","product_id":100017301,"comment_content":"1、我觉得完全二叉树不一定满足公式吧，比如1,2,3,4  4&#47;2+1=3  3不是最后一排的最后一个，得是满二叉树才可以吧<br>2、对还想到一个应用就是优先队列。","like_count":0,"discussions":[{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295189,"discussion_content":"你这种情况3是叶子节点啊，谁说叶子节点都在最后一层","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596113112,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200464,"user_name":"chris","can_delete":false,"product_type":"c1","uid":1109640,"ip_address":"","ucode":"6663E3E09457E3","user_header":"https://static001.geekbang.org/account/avatar/00/10/ee/88/a890b41e.jpg","comment_is_top":false,"comment_ctime":1585589175,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585589175","product_id":100017301,"comment_content":"还是要多看几遍！然后动手debug，不然还是容易忘！","like_count":0},{"had_liked":false,"id":199297,"user_name":"Wisdom","can_delete":false,"product_type":"c1","uid":1098980,"ip_address":"","ucode":"0787F954B66E93","user_header":"https://static001.geekbang.org/account/avatar/00/10/c4/e4/81ee2d8f.jpg","comment_is_top":false,"comment_ctime":1585486038,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585486038","product_id":100017301,"comment_content":"堆排序，在工作中还是很常用，特别是优先级队列","like_count":0},{"had_liked":false,"id":199187,"user_name":"zhimin","can_delete":false,"product_type":"c1","uid":1312130,"ip_address":"","ucode":"DF6DFBEF6FA297","user_header":"https://static001.geekbang.org/account/avatar/00/14/05/82/51cd0a50.jpg","comment_is_top":false,"comment_ctime":1585481751,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585481751","product_id":100017301,"comment_content":"第一题推导： 首先i节点的子节点是2i 和 2i+1 这是前提， 最后一个节点n的父节点就是n&#47;2,所以最后一个非叶子节点就是n&#47;2的了。 这样推导岂不更简单。 <br>应用： 应该是取第K大元素和取中位数。 ","like_count":0},{"had_liked":false,"id":197845,"user_name":"jinjun","can_delete":false,"product_type":"c1","uid":1546304,"ip_address":"","ucode":"E1141191B53D73","user_header":"https://static001.geekbang.org/account/avatar/00/17/98/40/30b0984a.jpg","comment_is_top":false,"comment_ctime":1585400472,"is_pvip":false,"discussion_count":0,"race_medal":2,"score":"1585400472","product_id":100017301,"comment_content":"```markdown<br>证明：假设堆有n个节点，n为h层完全二叉树节点数<br><br>- 完全二叉树1到h-1层节点的数量总和： 2^0+2^1...+2^{(h-2)}=(2^{(h-1)})-1=\\cfrac{(2^h)}{2}-1-----②<br><br>- 如果存储堆的数组下标从0开始，那么最后一个非叶子节点的下标就是\\cfrac{(2^h)}{2}-1，由于输的高度h=logn，即h^2 = n带进去算一哈就得到：最后一个非叶子节点的下标为\\cfrac{n}{2} - 1<br>- 如果存储堆的数组下标从1开始，那么最后一个非叶子节点的下标就是\\cfrac{(2^h)}{2}，由于h=logn，即h^2 = n带进去算一哈就得到：最后一个非叶子节点的下标为\\cfrac{n}{2}<br><br>证毕！<br>```","like_count":0},{"had_liked":false,"id":196746,"user_name":"SteelHuaSheng","can_delete":false,"product_type":"c1","uid":1396126,"ip_address":"","ucode":"BC8127FC5207FC","user_header":"https://static001.geekbang.org/account/avatar/00/15/4d/9e/04ec08bf.jpg","comment_is_top":false,"comment_ctime":1585309508,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585309508","product_id":100017301,"comment_content":"打卡，坚持，感觉越来越难了，看这篇花了2个多小时。(⊙o⊙)…还有救吗？","like_count":0},{"had_liked":false,"id":190736,"user_name":"小谢","can_delete":false,"product_type":"c1","uid":1879476,"ip_address":"","ucode":"82D54A61D2FDB9","user_header":"https://static001.geekbang.org/account/avatar/00/1c/ad/b4/e4dcd4d7.jpg","comment_is_top":false,"comment_ctime":1584688563,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584688563","product_id":100017301,"comment_content":"堆是什么:堆是一种满二叉树的结构，分为大顶堆和小顶堆，大顶堆满足结点大于等于它的子节点，小顶堆满足结点小于等于它的子节点<br>堆的操作：插入与删除(利用数组的下标随机访问还有公式的特点，要注意到了根节点的情况)<br>堆排序:建堆，排序","like_count":0},{"had_liked":false,"id":189765,"user_name":"长期规划","can_delete":false,"product_type":"c1","uid":1019332,"ip_address":"","ucode":"5EF65E9115834B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","comment_is_top":false,"comment_ctime":1584546802,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584546802","product_id":100017301,"comment_content":"好的名字让人容易理解，容易理解就容易记忆和使用。差的名字让人不知所云，还要费很长时间去理解，这跟变量的命名是一样的。“堆”这个名字起的实现太糟糕了","like_count":0},{"had_liked":false,"id":189761,"user_name":"长期规划","can_delete":false,"product_type":"c1","uid":1019332,"ip_address":"","ucode":"5EF65E9115834B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","comment_is_top":false,"comment_ctime":1584546678,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584546678","product_id":100017301,"comment_content":"读完篇幅文章，我感觉给一个东西起名字太重要了。就比如堆这个名字起的就很差，从名字上看，想不到它跟完全二叉树有什么关系，如果我是第一个提出这个概念的人，我会叫它完全二叉冒泡树。冒泡这个词来源于冒泡排序。这样，别人一看就明白它首先是一棵树，再次它的父节点比子节点大(或者小)。","like_count":0},{"had_liked":false,"id":189463,"user_name":"獨自去遠方","can_delete":false,"product_type":"c1","uid":1503941,"ip_address":"","ucode":"E246B33F397441","user_header":"https://static001.geekbang.org/account/avatar/00/16/f2/c5/2a441c27.jpg","comment_is_top":false,"comment_ctime":1584519335,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584519335","product_id":100017301,"comment_content":"堆排序<br>    快排为什么比堆排序好？<br>        数据访问方式不友好，不是顺序访问，对CPU缓存不友好<br>        交换次数更多<br>            建堆的过程打乱数据原有的顺序，降低数据有序度<br><br>    堆：<br>        堆是一个完全二叉树；<br>        堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值<br><br>        大顶推<br>        小顶推<br><br>    实现一个堆<br>        如何存储一个堆<br>            堆是一个完全二叉树，所以使用数组存储<br>        支持的操作（大顶堆）<br>            插入一个元素<br>                堆化：竖着节点所在路径向上对比，然后交换<br><br>            删除堆顶元素<br>                自下而上：下面往上面补充-&gt;可能会出现空洞，不满足完全二叉树<br>                自上而下：交互顶部元素和最后一个元素位置，然后开始自上而下的堆化<br>    堆排序<br>         O(nlogn)，原地排序算法<br>            不是稳定的排序算法<br><br>         步骤：<br>         1. 建堆<br>            思路一：<br>                假设起初堆里面只有一个元素，每次插入元素都是从下往上堆化<br>            思路二：<br>                从下往上 非叶子节点依次堆化<br>                建堆的时间复杂度是 O(n)<br>         2. 排序<br>            堆顶元素是最大元素<br>            将堆顶元素拿走，最后一个元素放到堆顶，进行堆化<br>            重复上面的步骤，直到堆内没有元素<br>            O(nlogn)<br>","like_count":0},{"had_liked":false,"id":187427,"user_name":"空白昵称","can_delete":false,"product_type":"c1","uid":1433815,"ip_address":"","ucode":"91F50CA25102AB","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/d7/744bd8c3.jpg","comment_is_top":false,"comment_ctime":1584107648,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584107648","product_id":100017301,"comment_content":"感觉这些算法在服务端大数据等开发中会应用的比较广泛一些，作为一个移动端开发者表示很少会用到这么多算法... 所以很多问题看似懂了，但是缺乏平台锻炼，未免有些担心学了就忘... ","like_count":0},{"had_liked":false,"id":183109,"user_name":"感动超人","can_delete":false,"product_type":"c1","uid":1245294,"ip_address":"","ucode":"DDBFE64A9DB28D","user_header":"https://static001.geekbang.org/account/avatar/00/13/00/6e/11362a1e.jpg","comment_is_top":false,"comment_ctime":1582954887,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582954887","product_id":100017301,"comment_content":"jerry银银的证明有点漏洞,他只证明了n&#47;2+1 是子节点 但是没有证明 n&#47;2 是父节点<br>另一种证明如下:<br>n为最后一个子节点,他的父节点是n&#47;2,所以 n&#47;2 是最后一个父节点<br>从 n&#47;2+1 到 n 全都是子节点","like_count":0},{"had_liked":false,"id":182043,"user_name":"czh","can_delete":false,"product_type":"c1","uid":1159078,"ip_address":"","ucode":"649FE5C9269D69","user_header":"https://static001.geekbang.org/account/avatar/00/11/af/a6/3f15ba2f.jpg","comment_is_top":false,"comment_ctime":1582699265,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582699265","product_id":100017301,"comment_content":"今日份复习：<br>1.复杂度是针对采用某一数据结构的某一算法中的某一操作的。数据结构、算法、操作都确定了才可以确定复杂度。LRU就是一个很好的例子。<br>2.基础结构只有两种：数组和链表。其余的都是这两种结构的改进或组合。沿着这条主线，能把所有的数据结构、算法串联起来。<br><br>堆、队列=》数组、链表都行<br>散列表=》数组<br>散列表+链表组合结构互补=》LRU中插入、删除、查找复杂度都是O（1）<br>排序树=》链表<br>堆=》完全二叉树采用数组<br><br>","like_count":0},{"had_liked":false,"id":181780,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1582633433,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582633433","product_id":100017301,"comment_content":"思考题 <br>1. 推导是不会了  但是通过画了个完全二叉树 来看确实是这个情况<br>2. 求第k大或者第k小的元素 还可以求中位数( 把数据分成两半 前面构建大顶堆  后面构建小顶堆 然后通过堆顶元素求中位数 )","like_count":0},{"had_liked":false,"id":180305,"user_name":"晴天","can_delete":false,"product_type":"c1","uid":1121142,"ip_address":"","ucode":"2FF5257193FC0A","user_header":"https://static001.geekbang.org/account/avatar/00/11/1b/76/e927da9f.jpg","comment_is_top":false,"comment_ctime":1582254294,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582254294","product_id":100017301,"comment_content":"public void removeMax() {  if (count == 0) return -1; &#47;&#47; 堆中没有数据  a[1] = a[count];  --count;  heapify(a, count, 1);}<br><br>这个 void  方法 return -1 是什么操作？贴到文章里的代码都不检查一下吗？这别说运行了，连编译都过不了吧。","like_count":0},{"had_liked":false,"id":175776,"user_name":"刘忽悠","can_delete":false,"product_type":"c1","uid":1252173,"ip_address":"","ucode":"095DE3A8D3F450","user_header":"https://static001.geekbang.org/account/avatar/00/13/1b/4d/2cc44d9a.jpg","comment_is_top":false,"comment_ctime":1580826500,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1580826500","product_id":100017301,"comment_content":"思路清晰，代码简介","like_count":0},{"had_liked":false,"id":172397,"user_name":"Simon","can_delete":false,"product_type":"c1","uid":1162286,"ip_address":"","ucode":"80146B97EB5CDE","user_header":"https://static001.geekbang.org/account/avatar/00/11/bc/2e/08079c3c.jpg","comment_is_top":false,"comment_ctime":1579169058,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579169058","product_id":100017301,"comment_content":"堆排序的第一步是建堆，建堆的过程会打乱数据原有的相对先后顺序，导致原数据的有序度降低。这个能严格证明吗","like_count":0},{"had_liked":false,"id":170778,"user_name":"会飞的鱼","can_delete":false,"product_type":"c1","uid":1257205,"ip_address":"","ucode":"BA3FC4E0BF7B39","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erloYzyia2hRy19E3aCtc0pf10MiaGmzEcXw8UZ3jC3LAibD8icWAFVCXGAlAic3mpjBUrHvyreyhAjIFw/132","comment_is_top":false,"comment_ctime":1578713672,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578713672","product_id":100017301,"comment_content":"n的大小需要小心，测试的时候是arr.length - 1，否则堆化时候会数组越界报错","like_count":0},{"had_liked":false,"id":169272,"user_name":"秀秀","can_delete":false,"product_type":"c1","uid":1145162,"ip_address":"","ucode":"9D4D327324570B","user_header":"https://static001.geekbang.org/account/avatar/00/11/79/4a/10348395.jpg","comment_is_top":false,"comment_ctime":1578303239,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578303239","product_id":100017301,"comment_content":"1. 完全二叉树最后一个节点n，无论是左节点还是右节点，n&#47;2 都是最后一个非叶子节点，那么从 n &#47; 2 + 1 ~ n 就都是叶子节点了","like_count":0},{"had_liked":false,"id":166657,"user_name":"ZM","can_delete":false,"product_type":"c1","uid":1239286,"ip_address":"","ucode":"E573AFDD2B3FCE","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/f6/e975b996.jpg","comment_is_top":false,"comment_ctime":1577537741,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1577537741","product_id":100017301,"comment_content":"小程序不支持数学公式，所有公式都看不到，太郁闷了","like_count":0,"discussions":[{"author":{"id":1000473,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/44/19/17fadc62.jpg","nickname":"郭蕾","note":"","ucode":"34F4C07D1C5FE8","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304858,"discussion_content":"用App或者web看\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599701118,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165084,"user_name":"SteveYang","can_delete":false,"product_type":"c1","uid":1754829,"ip_address":"","ucode":"C42BCA4F40A9EF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKCbnOvEatUN4ysE2cl6zJNoAJVXXuQVhicQ1jxh6Z2Towrmmc1I6PndaicuQQ0RyyJPyJQicv4tSib9Q/132","comment_is_top":false,"comment_ctime":1577157998,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577157998","product_id":100017301,"comment_content":"用反证法可以证明下标从n&#47;2+1到n都是叶子节点，假设n&#47;2+1存在子节点，根据完全二叉树特点，至少存在左子节点，坐标为2*(n&#47;2+1)=n+2超出了节点总数，故n&#47;2+1不存在子节点，同理下标n&#47;2+1到都不存在子节点。堆的其他应用有：topk","like_count":0},{"had_liked":false,"id":164942,"user_name":"zzh","can_delete":false,"product_type":"c1","uid":1174510,"ip_address":"","ucode":"0FC6BD729E5801","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJmcPTvjtSbhBNic4wb61Pj77nIHcLG64MnAXicsHBrMWvjCQPoiaHTtYmbnlVSkSWZEnN2QlicekqLhg/132","comment_is_top":false,"comment_ctime":1577114459,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577114459","product_id":100017301,"comment_content":"堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是 O(n)，排序过程的时间复杂度是 O(n\\log n)，所以，堆排序整体的时间复杂度是 O(n\\log n)。<br>这个时间复杂度  没有理解 哪位大佬指教下","like_count":0},{"had_liked":false,"id":164469,"user_name":"Geek_9314a4","can_delete":false,"product_type":"c1","uid":1703491,"ip_address":"","ucode":"5B82556BA95DCE","user_header":"https://static001.geekbang.org/account/avatar/00/19/fe/43/2483b90b.jpg","comment_is_top":false,"comment_ctime":1577002115,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577002115","product_id":100017301,"comment_content":"老师好，你用的是满二叉树来计算建堆的时间复杂度，但是堆是完全二叉树不一定是满二叉树啊，完全二叉树的话要怎么算建堆是O(n)的呢","like_count":0},{"had_liked":false,"id":164347,"user_name":"拓","can_delete":false,"product_type":"c1","uid":1010957,"ip_address":"","ucode":"AC1940ECC25436","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6d/0d/e3fa096f.jpg","comment_is_top":false,"comment_ctime":1576942286,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576942286","product_id":100017301,"comment_content":"文中提到 “建堆过程的时间复杂度是 O(n)，排序过程的时间复杂度是 O(nlogn)”， 为什么排序过程是O(nlogn)是怎么来的呢？我怎么觉得要这样子计算呢  log(n)+log(n-1)+... log(1) = log(n*(n-1)*..*1)=log(n!) 所以算法复杂度是O(log(n!)).","like_count":0},{"had_liked":false,"id":163865,"user_name":"港","can_delete":false,"product_type":"c1","uid":1122464,"ip_address":"","ucode":"35931FC6198180","user_header":"https://static001.geekbang.org/account/avatar/00/11/20/a0/1fca96c0.jpg","comment_is_top":false,"comment_ctime":1576813661,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576813661","product_id":100017301,"comment_content":"第一题：因为n是完全二叉树最下层最右节点，n&#47;2 是它的父节点，则n&#47;2+1就是没有子节点的节点，即叶子节点，所以n&#47;2+1到n是叶子节点<br>第二题：堆可以用来求前m个最大或最小的数","like_count":0},{"had_liked":false,"id":163093,"user_name":"克","can_delete":false,"product_type":"c1","uid":1069206,"ip_address":"","ucode":"6DDFBB05E0F4E9","user_header":"https://static001.geekbang.org/account/avatar/00/10/50/96/18612c89.jpg","comment_is_top":false,"comment_ctime":1576655540,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576655540","product_id":100017301,"comment_content":"第一题证明，设堆层数为L，分三种情况分析<br>- 如果只有1个节点，则叶子节点个数为1，满足下标计算公式。<br>- 如果堆是一个完美二叉树，则最后一层节点（也就是所有叶子节点）个数为2^{L-1}，又因为n=2^L-1，故2^{L-1} = \\frac {2^L}{2} = \\frac {n+1}{2}<br>- 如果不是完美二叉树，设最后一层叶子节点个数为K，则倒数第二层非叶子节点个数为\\frac K2向上取整，则倒数第二层叶子节点数为\\frac {n-K+1}{2}。<br>  - 当K为奇数时，n为偶数，总叶子节点数为K + \\frac {n-K+1}{2} - (\\frac {K-1}{2} +1) ，即\\frac {n+1}2<br>  - 当K为偶数时，总叶子节点数为K + \\frac {n-K+1}{2} - \\frac {K}{2} ，即\\frac {n+1}2<br><br>设下标从1开始，n结束，计算叶子节点开始下标为n-\\frac {n+1}{2} + 1，即<br>- 当n为偶数时\\frac {n+1}{2} = \\frac n2，所以叶子节点开始下标为\\frac n2+1<br>- 当n为奇数时n-\\frac {n+1}{2} + 1=\\frac {n-1}{2} + 1=\\frac n2+1","like_count":0},{"had_liked":false,"id":163016,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1576640171,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576640171","product_id":100017301,"comment_content":"快速排序和堆排序哪个更快不好比较，因为堆排序是保证nlog n的，而快排最差情况是n^2，也就是两者的快慢取决于输入。","like_count":0},{"had_liked":false,"id":162485,"user_name":"分清云淡","can_delete":false,"product_type":"c1","uid":1269873,"ip_address":"","ucode":"7045AE6BF72D31","user_header":"https://static001.geekbang.org/account/avatar/00/13/60/71/895ee6cf.jpg","comment_is_top":false,"comment_ctime":1576545016,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1576545016","product_id":100017301,"comment_content":"建堆的图解有个问题；倒数第二步，也就是堆顶 7 这个元素 为什么和右节点进行了交换？代码中和上一步 都是左节点优先的？","like_count":0,"discussions":[{"author":{"id":1269873,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/71/895ee6cf.jpg","nickname":"分清云淡","note":"","ucode":"7045AE6BF72D31","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":85418,"discussion_content":"恩 发现了 不是if else 是并列的if。没问题 看错了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576545397,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162194,"user_name":"Panda🐟","can_delete":false,"product_type":"c1","uid":1002401,"ip_address":"","ucode":"C6007A3192516A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4b/a1/c2719a5a.jpg","comment_is_top":false,"comment_ctime":1576474447,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576474447","product_id":100017301,"comment_content":"思考1：满二叉树的节点总数和高度的关系是 n = 1 + 2 + 4 + 8 +...+2^(k-1) + 2^k ; 其中 1 + 2 + 4 + 8 +...+2^(k-1)  =  2^k-1 = n&#47;2 是非叶子节点所以 n&#47;2+1 ~ n都是叶子节点；<br><br>完全二叉树相对与满二叉树只是减少了最下层的叶子节点","like_count":0},{"had_liked":false,"id":162056,"user_name":"梦想的优惠券","can_delete":false,"product_type":"c1","uid":1257418,"ip_address":"","ucode":"D3B44F6C618CA7","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/ca/cbce6e94.jpg","comment_is_top":false,"comment_ctime":1576457114,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1576457114","product_id":100017301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":157889,"user_name":"王木公","can_delete":false,"product_type":"c1","uid":1014550,"ip_address":"","ucode":"F049AEBFA0338D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7b/16/ca250e8c.jpg","comment_is_top":false,"comment_ctime":1575277894,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575277894","product_id":100017301,"comment_content":"对于排序部分，描述排序过程的两段文字稍微有些晦涩。<br>看图更容易懂，先交换（堆顶元素和最后一个未排好序的元素交换），再堆化。重复这两步","like_count":0},{"had_liked":false,"id":157031,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1015754,"ip_address":"","ucode":"00DF2FEC58D2E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","comment_is_top":false,"comment_ctime":1575015646,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575015646","product_id":100017301,"comment_content":"我的总结：<br>1. 磕磕绊绊总算是明白了<br>2. 如果需要熟练应用的话，需要下很大的功夫的<br>老师在刚开始的时候是不是也是这种感觉？求解惑，求鼓励，哈哈哈","like_count":0},{"had_liked":false,"id":156140,"user_name":"握不住手中沙","can_delete":false,"product_type":"c1","uid":1097132,"ip_address":"","ucode":"F194E47C4D42C9","user_header":"https://static001.geekbang.org/account/avatar/00/10/bd/ac/49494ed8.jpg","comment_is_top":false,"comment_ctime":1574823742,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574823742","product_id":100017301,"comment_content":"思考题：<br>2、应用：TopK问题，优先队列，流中的中位数问题","like_count":0},{"had_liked":false,"id":154645,"user_name":"Vettel","can_delete":false,"product_type":"c1","uid":1639787,"ip_address":"","ucode":"FB3E71DD1E8E7C","user_header":"https://static001.geekbang.org/account/avatar/00/19/05/6b/d9d6d68b.jpg","comment_is_top":false,"comment_ctime":1574499025,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574499025","product_id":100017301,"comment_content":"public void removeMax() {  if (count == 0) return -1; &#47;&#47; 堆中没有数据  a[1] = a[count];  --count;  heapify(a, count, 1);}   返回-1错啦","like_count":0},{"had_liked":false,"id":153928,"user_name":"贝克水母","can_delete":false,"product_type":"c1","uid":1425849,"ip_address":"","ucode":"8D431C5FC07521","user_header":"https://static001.geekbang.org/account/avatar/00/15/c1/b9/4bba336f.jpg","comment_is_top":false,"comment_ctime":1574333445,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574333445","product_id":100017301,"comment_content":"指出一个小错误，往堆中插入一个元素的图，第一张第二层的左子节点是17，下面的分解图变成了27。想要问一个问题，就是大顶堆不需要每层的最小值大于下一层的最大值吧","like_count":0},{"had_liked":false,"id":151889,"user_name":"三年过后","can_delete":false,"product_type":"c1","uid":1283157,"ip_address":"","ucode":"5E9106C5F11BED","user_header":"https://static001.geekbang.org/account/avatar/00/13/94/55/afc64956.jpg","comment_is_top":false,"comment_ctime":1573807042,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573807042","product_id":100017301,"comment_content":"对1000个相同数据排序，堆排序交换次数9577，时间2ms; 快排4186，时间1ms","like_count":0},{"had_liked":false,"id":151581,"user_name":"乾坤瞬间","can_delete":false,"product_type":"c1","uid":1683130,"ip_address":"","ucode":"15BDCF29CBF8EB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","comment_is_top":false,"comment_ctime":1573743725,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573743725","product_id":100017301,"comment_content":"老师，我想问下，堆排序的访问为什么对cpu缓存是不友好的？","like_count":0},{"had_liked":false,"id":149654,"user_name":"学个球","can_delete":false,"product_type":"c1","uid":1019725,"ip_address":"","ucode":"7343F3C0CA981D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8f/4d/65fb45e6.jpg","comment_is_top":false,"comment_ctime":1573305065,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573305065","product_id":100017301,"comment_content":"哈哈哈，我看错了，heapify直接作用到a[1]了，忽略上条留言。谢谢小争哥。","like_count":0},{"had_liked":false,"id":140419,"user_name":"Pyer","can_delete":false,"product_type":"c1","uid":1159237,"ip_address":"","ucode":"8287EFD2268211","user_header":"https://static001.geekbang.org/account/avatar/00/11/b0/45/f0a63850.jpg","comment_is_top":false,"comment_ctime":1570935972,"is_pvip":false,"replies":[{"id":"54529","content":"两者没任何关系，只是名字相同而已。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1571094526,"ip_address":"","comment_id":140419,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1570935972","product_id":100017301,"comment_content":"老师，想问下，这个堆和java里面每次创建对象放在heap堆里面，是一个概念么?","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470383,"discussion_content":"两者没任何关系，只是名字相同而已。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571094526,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140220,"user_name":"AllenGFLiu","can_delete":false,"product_type":"c1","uid":1221991,"ip_address":"","ucode":"90FA8A619A2629","user_header":"https://static001.geekbang.org/account/avatar/00/12/a5/67/bf286335.jpg","comment_is_top":false,"comment_ctime":1570852833,"is_pvip":false,"replies":[{"id":"54241","content":"none在java中不合法的 所以是9","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1570916610,"ip_address":"","comment_id":140220,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1570852833","product_id":100017301,"comment_content":"建堆时传入的数组下标为0的元素是空的，传入的原始数组例子中为[None, 7, 5, 19, 8, 4, 1, 20, 13, 16]，请问Java中这个数组的长度是多少，即n是9还是10？在python中是10，不知道Java是多少？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470305,"discussion_content":"none在java中不合法的 所以是9","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570916610,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138167,"user_name":"coldpark","can_delete":false,"product_type":"c1","uid":1058331,"ip_address":"","ucode":"D1B0F343B384F8","user_header":"https://static001.geekbang.org/account/avatar/00/10/26/1b/4caf36bd.jpg","comment_is_top":false,"comment_ctime":1570073783,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570073783","product_id":100017301,"comment_content":"最新的Chrome64位浏览器 77.0.3865.90版本看数学表达有问题（如：$\\frac{n}{2}+1$）能不能排查一下。","like_count":0},{"had_liked":false,"id":135651,"user_name":"Hwan","can_delete":false,"product_type":"c1","uid":1205627,"ip_address":"","ucode":"A728C6790511BD","user_header":"https://static001.geekbang.org/account/avatar/00/12/65/7b/66b9befd.jpg","comment_is_top":false,"comment_ctime":1569235299,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569235299","product_id":100017301,"comment_content":"关于n&#47;2+1到n的都为叶子节点可以使用反证法，第二问目前只知道是top K问题，还特意看了下适用于快排的第K大的问题","like_count":0},{"had_liked":false,"id":133313,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1568512820,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568512820","product_id":100017301,"comment_content":"是不是应该比较一下从前往后和从后往前堆化的区别！二者的复杂度一样吗？但从后往前的复杂度还推导了一下，第一种好像也一样，区别区别是什么？","like_count":0},{"had_liked":false,"id":132855,"user_name":"布衣小酱","can_delete":false,"product_type":"c1","uid":1427453,"ip_address":"","ucode":"46D4676C39E951","user_header":"https://static001.geekbang.org/account/avatar/00/15/c7/fd/b6dec088.jpg","comment_is_top":false,"comment_ctime":1568253607,"is_pvip":false,"replies":[{"id":"51241","content":"要一直堆化到叶子节点的呢","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1568591880,"ip_address":"","comment_id":132855,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568253607","product_id":100017301,"comment_content":"每个节点堆化的过程中，需要比较和交换的节点个数，跟这个节点的高度 <br>k<br>k<br> 成正比。。请问为什么与高度成正比呢？只需要比较其左右子节点就行了吧，因为从下往上堆化的。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467146,"discussion_content":"要一直堆化到叶子节点的呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568591880,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132744,"user_name":"静静聆听","can_delete":false,"product_type":"c1","uid":1263932,"ip_address":"","ucode":"0A8600CB928EFE","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/3c/5d54c510.jpg","comment_is_top":false,"comment_ctime":1568210529,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568210529","product_id":100017301,"comment_content":"看了那么多节了，就觉得老师的数学真的是好，我现在基本都是在写业务代码，看了老师的各种计算，自己完全没有思路，老师写出来一看就懂，上学时候学的数学公式都忘光了快","like_count":0},{"had_liked":false,"id":126859,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1566492965,"is_pvip":false,"replies":[{"id":"47238","content":"多看两遍，自己动手写写代码。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1566773455,"ip_address":"","comment_id":126859,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566492965","product_id":100017301,"comment_content":"看完就忘记了，怎么办？？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464207,"discussion_content":"多看两遍，自己动手写写代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566773455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126855,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1566491594,"is_pvip":false,"replies":[{"id":"47239","content":"自己写代码debug一下呢~~","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1566773487,"ip_address":"","comment_id":126855,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566491594","product_id":100017301,"comment_content":"第一种建堆思路应该是从后往前处理数组数据<br>第一种建堆思路才是从前往后处理数组数据吧<br><br>我是不是理解错了？算法我能懂；","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464205,"discussion_content":"自己写代码debug一下呢~~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566773487,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":125153,"user_name":"老白","can_delete":false,"product_type":"c1","uid":1397031,"ip_address":"","ucode":"39881175152D49","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/27/f0dd6f19.jpg","comment_is_top":false,"comment_ctime":1566101618,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1566101618","product_id":100017301,"comment_content":"堆排序交换可以用类似于插入排序的方式优化，但快排应该没办法用这种方法优化(该交换时必须真实的交换)，所以堆排序执行的指令数不一定比快排多，我觉着可能主要还是cpu缓存影响效率吧。","like_count":0},{"had_liked":false,"id":123597,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1565709104,"is_pvip":false,"replies":[{"id":"45697","content":"有点那个意思。不过你的例子也没必要用堆哈","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1565909639,"ip_address":"","comment_id":123597,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565709104","product_id":100017301,"comment_content":"思考题：<br>(1)下标为n的节点必是叶子结点，如果不是，则它的子结点下标必然大于n；<br>(2)下标为n&#47;2+1的节点也必是叶子结点，如果不是，则它的子结点下也必然大于n；<br>由此可知从下标为n&#47;2+1的节点开始，直至下标为n的节点，都是叶子结点，如果不是，则它们子结点下标必然大于n，超出完全二叉树的节点数。<br><br>关于堆的应用，经常见于体育比赛中，先是小组赛，再进行复赛，半决赛，最后进行总决赛，整个比赛的过程就是一个建堆的过程，处于堆顶的就是冠军。<br>不知道这样理解对不对，请老师指正。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462739,"discussion_content":"有点那个意思。不过你的例子也没必要用堆哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565909639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121494,"user_name":"Ender","can_delete":false,"product_type":"c1","uid":1354521,"ip_address":"","ucode":"FB33FCE576912D","user_header":"https://static001.geekbang.org/account/avatar/00/14/ab/19/23034ffa.jpg","comment_is_top":false,"comment_ctime":1565148456,"is_pvip":false,"replies":[{"id":"44725","content":"不是完全二叉树呀。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1565218689,"ip_address":"","comment_id":121494,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565148456","product_id":100017301,"comment_content":"图一中的第四棵树也是小顶堆啊，莫非我的理解还是不够？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461817,"discussion_content":"不是完全二叉树呀。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565218689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120494,"user_name":"酸葡萄","can_delete":false,"product_type":"c1","uid":1154146,"ip_address":"","ucode":"9D059C4FB327C0","user_header":"https://static001.geekbang.org/account/avatar/00/11/9c/62/f625b2bb.jpg","comment_is_top":false,"comment_ctime":1564912430,"is_pvip":false,"replies":[{"id":"44267","content":"不能这么理解。堆化的时间复杂度本身就是O（n），你再看下文章。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1564966673,"ip_address":"","comment_id":120494,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1564912430","product_id":100017301,"comment_content":"老师问个问题：<br>建堆的过程是：先把所有元素按输入顺序放入数组中，然后从下往上调整（堆化），时间复杂度为O（n），可不可以这么理解：第一步顺序插入n个元素，时间复杂度为O（n）,<br>第二步，堆化，堆化的时间复杂度为O（logn），两者相加所以最终的<br>时间复杂度为：O（n）","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461360,"discussion_content":"不能这么理解。堆化的时间复杂度本身就是O（n），你再看下文章。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564966673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115756,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1563719328,"is_pvip":false,"replies":[{"id":"42288","content":"你哪里不明白呢？能具体说下嘛？你觉得应该是多少呢？你问的太过笼统，我不怎么好回答啊","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1563746071,"ip_address":"","comment_id":115756,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563719328","product_id":100017301,"comment_content":"不是很明白，为什么建堆操作的时间复杂度是------(节点高度*当前层节点个数)的累加和。计算倒是很简单。老师能再简单指点下吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459273,"discussion_content":"你哪里不明白呢？能具体说下嘛？你觉得应该是多少呢？你问的太过笼统，我不怎么好回答啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563746071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114942,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1563436701,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563436701","product_id":100017301,"comment_content":"思考题1 叶子节点的左子节点将超过n来推出下标。<br>思考题2 最大最小堆可以合并使用来维护一个查找中数的数据结构。","like_count":0},{"had_liked":false,"id":113580,"user_name":"linqw","can_delete":false,"product_type":"c1","uid":1134138,"ip_address":"","ucode":"09DCFE98C54DD8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","comment_is_top":false,"comment_ctime":1563086470,"is_pvip":false,"replies":[{"id":"41400","content":"格式有点太乱了😂","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1563141117,"ip_address":"","comment_id":113580,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1563086470","product_id":100017301,"comment_content":"自己大致写下堆排序，老师帮忙看下哦。留言限制2000字，贴代码不是很方便<br>public class HeapSort {<br>    class Heap {<br>        private int count;<br>        private int[] content;<br>        Heap(int size) {content = new int[size];}<br>        boolean insertData(int data) {<br>            count++;<br>            if (count &gt;= content.length) {<br>                return Boolean.FALSE;<br>            }<br>            content[count] = data;heapifyDownToUp(content, count);return Boolean.TRUE;<br>        }<br>        boolean removeMax() {<br>            if (count == 0) {<br>                return Boolean.FALSE;<br>            }<br>            content[1] = content[count];count--;heapifyUpToDown(content, 1, count);return Boolean.TRUE;<br>        }<br>        int[] sort() {<br>            int k = count;<br>            while (true) {swap(content, 1, k);if (k == 1) {break;}k--;heapifyUpToDown(content, 1, k);}<br>            return content;<br>        }<br>    }<br>    public void sort(int[] content) {Heap heap = buildHeap(content);System.out.println(Arrays.toString(heap.sort()));}<br>    private Heap buildHeap(int[] content) {Heap heap = new Heap(content.length + 1);for (int data : content) {heap.insertData(data);}return heap;}<br>    private void heapifyUpToDown(int[] content, int index, int count) {<br>        while (true) {<br>            int maxIndex = index;if (2 * index &lt; count &amp;&amp; content[index] &lt; content[2 * index]) {maxIndex = 2 * index;}if ((2 * index + 1) &lt; count &amp;&amp; content[maxIndex] &lt; content[2 * index + 1]) {maxIndex = 2 * index + 1;}<br>            if (maxIndex == index) {break;}swap(content, maxIndex, index);index = maxIndex;<br>        }<br>    }<br>    private void swap(int[] content, int index, int swapIndex) {int temp = content[swapIndex];content[swapIndex] = content[index];content[index] = temp;}<br>    private void heapifyDownToUp(int[] content, int index) {<br>        boolean flag = true;<br>        while (flag) {flag = false;int parentIndex = index &#47; 2;if (index &gt; 1 &amp;&amp; content[parentIndex] &lt; content[index]) {flag = true;swap(content, parentIndex, index);index = parentIndex;}}<br>    }}","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458292,"discussion_content":"格式有点太乱了😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563141117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1109640,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ee/88/a890b41e.jpg","nickname":"chris","note":"","ucode":"6663E3E09457E3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217960,"discussion_content":"这格式看得眼花缭乱的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585589029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134138,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","nickname":"linqw","note":"","ucode":"09DCFE98C54DD8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2150,"discussion_content":"评论限制2000长度","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563284471,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":113443,"user_name":"linqw","can_delete":false,"product_type":"c1","uid":1134138,"ip_address":"","ucode":"09DCFE98C54DD8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","comment_is_top":false,"comment_ctime":1563011097,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563011097","product_id":100017301,"comment_content":"n&#47;2 + 1 到 n的节点都是叶子节点，因为每层（每层都排满，第一层除外）都是上面所有层的节点相加再加1，即中位数的节点就是最后一层的第一个节点，也是是否是叶子节点的分割位置","like_count":0},{"had_liked":false,"id":111411,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1562554308,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562554308","product_id":100017301,"comment_content":"堆常用操作：建堆（从上往下&amp;从下往上）；堆排序；向堆中插入一个元素；删除堆顶元素；从上往下堆化；从下往上堆化<br>时间复杂度（建堆）：o(logn)<br>时间复杂度（堆排序）：o(nlogn)<br>空间复杂度（堆排序）：o(1)<br>稳定性分析：不稳定<br>操作系统角度分析：堆排序的访问方式是跳着访问的，对CPU缓存不友好；<br>在操作系统中，堆经常作为优先队列的实现来解决线程调度中的优先级问题。<br>计算机网络角度分析：在服务器接收客户端请求时，通常会设置一个请求队列并根据优先级排序，以让服务器按优先级处理请求。<br>Java第三方库中的实践：尚未找到<br>与快速排序的对比：<br>相比快排，其对CPU缓存不够友好；<br>同样的数据，堆排序的数据交换次数要多于快速排序。<br>应用场景：TopK&amp;查找百分位数&amp;优先队列问题","like_count":0},{"had_liked":false,"id":108419,"user_name":"李","can_delete":false,"product_type":"c1","uid":1119312,"ip_address":"","ucode":"5C0FAA211F2E26","user_header":"https://static001.geekbang.org/account/avatar/00/11/14/50/c23cf47d.jpg","comment_is_top":false,"comment_ctime":1561767942,"is_pvip":true,"replies":[{"id":"39393","content":"堆不仅仅是完全二叉树，还有自己特有的特性","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1561937339,"ip_address":"","comment_id":108419,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561767942","product_id":100017301,"comment_content":"老师，既然是完全二叉树，为什么还要发明堆这个概念呢？有没有相关资料连接？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455965,"discussion_content":"堆不仅仅是完全二叉树，还有自己特有的特性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561937339,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106543,"user_name":"林峰峰","can_delete":false,"product_type":"c1","uid":1457609,"ip_address":"","ucode":"83C2093135BBB8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/3B5MoC4DfBt00nnVshEBFHHkNVgbcBrXsd3SxFicdN3XX5ILOe7GJxKvtJKCY53xNCuxSV8ABxNulbhkibm1lXIw/132","comment_is_top":false,"comment_ctime":1561341257,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561341257","product_id":100017301,"comment_content":"看过算法书，不过今天才清晰的懂了堆排序","like_count":0},{"had_liked":false,"id":103837,"user_name":"那样的月色","can_delete":false,"product_type":"c1","uid":1237353,"ip_address":"","ucode":"23B1298C465D2C","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/69/0db70c84.jpg","comment_is_top":false,"comment_ctime":1560526558,"is_pvip":false,"replies":[{"id":"37645","content":"你再仔细看下，应该没错的。黄色的意思是现在处理到了哪个节点。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1560641304,"ip_address":"","comment_id":103837,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560526558","product_id":100017301,"comment_content":"建堆的第一张图片里面的第二个堆图，应该小球8是黄色，而不是小球19是黄色","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454017,"discussion_content":"你再仔细看下，应该没错的。黄色的意思是现在处理到了哪个节点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560641304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":102226,"user_name":"北方易初","can_delete":false,"product_type":"c1","uid":1101234,"ip_address":"","ucode":"C57FDBD37F43E6","user_header":"https://static001.geekbang.org/account/avatar/00/10/cd/b2/807137b9.jpg","comment_is_top":false,"comment_ctime":1560164752,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560164752","product_id":100017301,"comment_content":"@李建轰<br>  ```<br>while (true) {<br>    int maxPos = i;<br>    if (i*2 &lt;= n &amp;&amp; a[i] &lt; a[i*2]) maxPos = i*2;<br>    if (i*2+1 &lt;= n &amp;&amp; a[i] &lt; a[i*2+1]) maxPos = i*2+1<br>    if (maxPos == i) break;<br>    swap(a, i, maxPos);<br>    i = maxPos;<br>}<br>```<br>第二个if:  if (i*2+1 &lt;= n &amp;&amp; a[i] &lt; a[i*2+1]) maxPos = i*2+1 ——&gt; if (i*2+1 &lt;= n &amp;&amp; a[i*2] &lt; a[i*2+1]) maxPos = i*2+1 &#47;&#47;如果右子节点没有超出堆的范围，且左节点小于右节点，则将maxPos变量指向右节点。","like_count":0},{"had_liked":false,"id":102160,"user_name":"꧁花间一壶酒꧂","can_delete":false,"product_type":"c1","uid":1542238,"ip_address":"","ucode":"71CBBCFC4A926E","user_header":"https://static001.geekbang.org/account/avatar/00/17/88/5e/e9a8417d.jpg","comment_is_top":false,"comment_ctime":1560155003,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560155003","product_id":100017301,"comment_content":"评论区都是一群大佬","like_count":0},{"had_liked":false,"id":99846,"user_name":"樂文💤","can_delete":false,"product_type":"c1","uid":1073694,"ip_address":"","ucode":"CE4A46397521FC","user_header":"https://static001.geekbang.org/account/avatar/00/10/62/1e/8054e6db.jpg","comment_is_top":false,"comment_ctime":1559321508,"is_pvip":false,"replies":[{"id":"36274","content":"21换成28的话，就不是遍历左子树了，而是右子树了。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1559612844,"ip_address":"","comment_id":99846,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559321508","product_id":100017301,"comment_content":"提问：去除堆顶的那里面第二个方法 将最后一项挪到第一位以后只需要去遍历左节点重新建堆吗？感觉不对啊，如果有节点的21换成28，那最后出来的结果是不对的，所以是不是遍历完左节点还需要遍历右节点呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452292,"discussion_content":"21换成28的话，就不是遍历左子树了，而是右子树了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559612844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94565,"user_name":"Shawn","can_delete":false,"product_type":"c1","uid":1014729,"ip_address":"","ucode":"B95D7B54465DE4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7b/c9/75c9002e.jpg","comment_is_top":false,"comment_ctime":1557842089,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557842089","product_id":100017301,"comment_content":"第一题：<br>前提：序号从1开始<br>N个节点的完全二叉树，最后一个叶子节点的序号为N，它的父节点的序号为N&#47;2，该父节点是最后一个非叶子节点，按层级遍历的话，它的下一个就是第一个叶子节点，即N&#47;2+1","like_count":0},{"had_liked":false,"id":91677,"user_name":"jacy","can_delete":false,"product_type":"c1","uid":1103456,"ip_address":"","ucode":"0022A8759DDCE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/60/f21b2164.jpg","comment_is_top":false,"comment_ctime":1557071416,"is_pvip":false,"replies":[{"id":"32764","content":"已经发现 在等后台更新zhong","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1557104225,"ip_address":"","comment_id":91677,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1557071416","product_id":100017301,"comment_content":"感觉删除的堆化函数有点问题，比如 大顶堆6,4,5,1 ，按此逻辑删除后是 4,1,5，已经不是大顶堆了，正确的结果应该是 5,4,1 才对","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448990,"discussion_content":"已经发现 在等后台更新zhong","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557104225,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91209,"user_name":"✨lemory","can_delete":false,"product_type":"c1","uid":1241204,"ip_address":"","ucode":"200F514EF97CC9","user_header":"https://static001.geekbang.org/account/avatar/00/12/f0/74/03a7443e.jpg","comment_is_top":false,"comment_ctime":1556929724,"is_pvip":false,"replies":[{"id":"32704","content":"是的 我改下","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1557017420,"ip_address":"","comment_id":91209,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556929724","product_id":100017301,"comment_content":"怎么觉得heapify这个函数写的有问题，只会走堆化左分支或右分支呢，比如1,4,6的堆，堆化之后会变成4,1,6，最大值不能到顶部？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448845,"discussion_content":"是的 我改下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557017420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91130,"user_name":"好好学习","can_delete":false,"product_type":"c1","uid":1258789,"ip_address":"","ucode":"63A002997462E3","user_header":"https://static001.geekbang.org/account/avatar/00/13/35/25/bab760a1.jpg","comment_is_top":false,"comment_ctime":1556874586,"is_pvip":false,"replies":[{"id":"32762","content":"已经发现了 在等编辑更新","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1557104185,"ip_address":"","comment_id":91130,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556874586","product_id":100017301,"comment_content":"删除代码有点问题，左右子节点都要比较大小","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448818,"discussion_content":"已经发现了 在等编辑更新","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557104185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90900,"user_name":"学学学","can_delete":false,"product_type":"c1","uid":1485366,"ip_address":"","ucode":"B279D802CDB0C4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/vicCM2yGWiadOiaL57kn4ufO1CJOvS5RXMX0tHKicgINOfVkRkZcENvSv69DicEQdfGTvswbBkSFhQyIeSkDU4OnIicQ/132","comment_is_top":false,"comment_ctime":1556718552,"is_pvip":false,"replies":[{"id":"32702","content":"好像是的，我改下","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1557017354,"ip_address":"","comment_id":90900,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1556718552","product_id":100017301,"comment_content":"建堆的代码写的有问题吧，我在vs上执行发现结果不对啊<br><br>private static void buildHeap(int[] a, int n) {<br>  for (int i = n&#47;2; i &gt;= 1; --i) {<br>    heapify(a, n, i);<br>  }<br>}<br><br>private static void heapify(int[] a, int n, int i) {<br>  while (true) {<br>    int maxPos = i;<br>    if (i*2 &lt;= n &amp;&amp; a[i] &lt; a[i*2]) maxPos = i*2;<br>    else if (i*2+1 &lt;= n &amp;&amp; a[maxPos] &lt; a[i*2+1]) maxPos = i*2+1;<br>    else if (maxPos == i) break;<br>    swap(a, i, maxPos);<br>    i = maxPos;<br>  }<br>}<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448714,"discussion_content":"好像是的，我改下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557017354,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1906773,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/18/55/3141c125.jpg","nickname":"Braeswood_Blvd","note":"","ucode":"5985430F78A11D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":257322,"discussion_content":"heapify里面swap之后，不需要加heapify(a,n,maxPos)嘛？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588558507,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":86490,"user_name":"渠梁","can_delete":false,"product_type":"c1","uid":1488038,"ip_address":"","ucode":"DC86BDEC63C9BC","user_header":"https://static001.geekbang.org/account/avatar/00/16/b4/a6/b6fa2562.jpg","comment_is_top":false,"comment_ctime":1555382480,"is_pvip":true,"replies":[{"id":"31225","content":"这个跟java语言本身有关了，自己研究下把。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1555469250,"ip_address":"","comment_id":86490,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555382480","product_id":100017301,"comment_content":"为什么java中创建对象放在堆中","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447037,"discussion_content":"这个跟java语言本身有关了，自己研究下把。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555469250,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85686,"user_name":"Tomcat","can_delete":false,"product_type":"c1","uid":1346364,"ip_address":"","ucode":"B270CEED693256","user_header":"https://static001.geekbang.org/account/avatar/00/14/8b/3c/0462eca7.jpg","comment_is_top":false,"comment_ctime":1555179460,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555179460","product_id":100017301,"comment_content":"这里的关键是要理解并掌握堆化这个概念。<br>我认为，堆化，翻译过来就是要建立一个符合要求的完全二叉树。这里的要求，其实也就是任何一个节点都要大于等于（小于等于）它的做右子树的值。理解了这两个关键的内容，这个堆的数据结构。算是入门了。","like_count":0},{"had_liked":false,"id":83553,"user_name":"康斯坦丁","can_delete":false,"product_type":"c1","uid":1368096,"ip_address":"","ucode":"C130E800E8D5C9","user_header":"https://static001.geekbang.org/account/avatar/00/14/e0/20/003190c1.jpg","comment_is_top":false,"comment_ctime":1554647139,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554647139","product_id":100017301,"comment_content":"1 因为n&#47;2+1的元素的左子节点是 n+2 ，是不存在的.<br>2 优先级队列","like_count":0},{"had_liked":false,"id":82430,"user_name":"锦","can_delete":false,"product_type":"c1","uid":1468298,"ip_address":"","ucode":"CB0EB4B68C468B","user_header":"https://static001.geekbang.org/account/avatar/00/16/67/8a/babd74dc.jpg","comment_is_top":false,"comment_ctime":1554209250,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554209250","product_id":100017301,"comment_content":"removeMax()函数中的第四行前应该插入a[count]=0;<br>要不然最后一个节点并没有删除<br><br>第一题：从数组中遍历元素的顺序是从堆顶到左子节点，再到右子节点，从上往下依次遍历的。目测下标n&#47;2 +1 到n都是子节点<br>","like_count":0},{"had_liked":false,"id":44748,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1543486250,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543486250","product_id":100017301,"comment_content":"堆的结构通过较为简单的方式时刻对外保持最大值和最小值，在维护的过程中也比一般的有序结构更加快捷，这种结构可以用于优先队列中。","like_count":0},{"had_liked":false,"id":44602,"user_name":"这么写的闫","can_delete":false,"product_type":"c1","uid":1246059,"ip_address":"","ucode":"95B0D1E1A094C8","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/6b/f31d4538.jpg","comment_is_top":false,"comment_ctime":1543462006,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543462006","product_id":100017301,"comment_content":"基于堆排序的 思路2相比思路1 有什么优势吗？<br>而且思路2建堆的图完全看不懂😂（代码看懂了）","like_count":0},{"had_liked":false,"id":44594,"user_name":"鹏程万里","can_delete":false,"product_type":"c1","uid":1114675,"ip_address":"","ucode":"5E23BBEC9E8209","user_header":"https://static001.geekbang.org/account/avatar/00/11/02/33/57678ea3.jpg","comment_is_top":false,"comment_ctime":1543461122,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543461122","product_id":100017301,"comment_content":"为什么建堆时间复杂度分析中，是n&#47;2 + 1个节点呢？为什么不是n&#47;2,第n&#47;2 + 1个不应该是叶子节点了吗","like_count":0},{"had_liked":false,"id":44523,"user_name":"鹏程万里","can_delete":false,"product_type":"c1","uid":1114675,"ip_address":"","ucode":"5E23BBEC9E8209","user_header":"https://static001.geekbang.org/account/avatar/00/11/02/33/57678ea3.jpg","comment_is_top":false,"comment_ctime":1543454827,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543454827","product_id":100017301,"comment_content":"老师，删除堆顶元素的那段讲解中，使用从下往上堆化的过程可能会出现不满足完全二叉树的情况。文中配的图片是不是把最后一行5和6互换下更好，这样堆化时，就会出现最后一层出现右子节点的情况。不然文中堆化后的结果还是符合完全二叉树定义的。我这样理解对吗？","like_count":0},{"had_liked":false,"id":43875,"user_name":"oatlmy","can_delete":false,"product_type":"c1","uid":1019438,"ip_address":"","ucode":"D5B0291801F902","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/2e/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1543316404,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1543316404","product_id":100017301,"comment_content":"老师，请问为什么评价算法性能是根据时间和空间复杂度，而不是别的参数？是因为计算机结构是冯诺依曼体系，除了输入输出设备和控制器，就剩下运算器和存储器了吗？","like_count":0,"discussions":[{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295242,"discussion_content":"阁下就是传说中的《计算机组成原理》？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596123706,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":43764,"user_name":"k","can_delete":false,"product_type":"c1","uid":1250383,"ip_address":"","ucode":"612C04D327D7BB","user_header":"https://static001.geekbang.org/account/avatar/00/13/14/4f/4d5efcf9.jpg","comment_is_top":false,"comment_ctime":1543290334,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543290334","product_id":100017301,"comment_content":"1. 对于完全二叉树来说 叶节点数量跟非叶节点数量一样 都是n&#47;2<br>2. heap是priority queue的一种实现","like_count":0},{"had_liked":false,"id":43755,"user_name":"benying","can_delete":false,"product_type":"c1","uid":1247522,"ip_address":"","ucode":"DEBAB485F381CC","user_header":"https://static001.geekbang.org/account/avatar/00/13/09/22/22c0c4fa.jpg","comment_is_top":false,"comment_ctime":1543288093,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1543288093","product_id":100017301,"comment_content":"写的浅显易懂，赞一个，谢谢","like_count":0},{"had_liked":false,"id":43731,"user_name":"Ryoma","can_delete":false,"product_type":"c1","uid":1130590,"ip_address":"","ucode":"7F692369239692","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/5e/b8fada94.jpg","comment_is_top":false,"comment_ctime":1543284940,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1543284940","product_id":100017301,"comment_content":"有朋友说看到$符，应该都是出现在公式附近，猜想是极客时间前端渲染(比如依赖渲染的文件未加载完成)的问题，一般刷新一下就好了","like_count":0},{"had_liked":false,"id":43548,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1543239410,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543239410","product_id":100017301,"comment_content":"对于完全二叉树来说，下标从n&#47;2 + 1 到 n的节点都是叶子节点？ <br><br>我的思路是：假设下标n&#47;2 + 1不是叶子节点，然后进行推导。我看了下其他同学的留言，学习了另外一种推导的思路：根据最大叶子节点推导其父节点;<br><br>i = 1, 则i是根节点；<br>i &gt; 1，其父节点为floor(i&#47;2);  <br>以上均满足：n&#47;2 + 1 到 n的节点都是叶子节点的结论。","like_count":0},{"had_liked":false,"id":43214,"user_name":"拉欧","can_delete":false,"product_type":"c1","uid":1206605,"ip_address":"","ucode":"40996A8093A95F","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/4d/81c44f45.jpg","comment_is_top":false,"comment_ctime":1543196375,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543196375","product_id":100017301,"comment_content":"Nsq延迟队列，内部就是维护了一个堆","like_count":0},{"had_liked":false,"id":43161,"user_name":"Sharry","can_delete":false,"product_type":"c1","uid":1239293,"ip_address":"","ucode":"045DDB864659F6","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/fd/035f4c94.jpg","comment_is_top":false,"comment_ctime":1543193853,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543193853","product_id":100017301,"comment_content":"堆还可以应用在构建索引优先队列上","like_count":0},{"had_liked":false,"id":43142,"user_name":"William﹏","can_delete":false,"product_type":"c1","uid":1239040,"ip_address":"","ucode":"62F29E5FFEA94C","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/00/30098cb7.jpg","comment_is_top":false,"comment_ctime":1543191688,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543191688","product_id":100017301,"comment_content":"Math Processing Error","like_count":0}]}