{"id":740895,"title":"第 16 章 服务集成(3)","content":"<h2 id=\"nav_point_252\">16.4　基于 Spring Cloud Gateway 实现微服务网关</h2>\n<p>不同的微服务各司其职，相对独立地对外提供服务，这在组织内部也许不是个大问题，但当外部需要访问内部的服务时，这就会带来很多不便，比如外部客户端不得不感知内部的服务细节，又比如至少需要知道如何找到所需的服务，还有一系列其他问题有待解决。为此，可以在边界上引入微服务网关。这一节就让我们来聊聊微服务网关，以及如何使用 Spring Cloud Gateway 来实现微服务网关。</p>\n<h3 id=\"nav_point_253\">16.4.1　什么是微服务网关</h3>\n<p>在具体了解微服务网关之前，先看看没有它的时候究竟会存在些什么问题。以客户端的视角作为切入点，会发现下面这些问题。</p>\n<ul>\n<li>客户端必须了解分散在不同微服务之间的各种领域和组织细节。</li>\n<li>客户端的接入点过于分散，不同的服务要么是不同的域名，要么直接暴露 IP，这就增加了潜在的安全风险。</li>\n<li>不同客户端对服务的粒度要求不同，服务太散会导致交互过于频繁。</li>\n<li>不同的服务也许会使用不同的认证方式和通信协议，不利于客户端的接入。</li>\n</ul>\n<p>服务端也有很多痛点需要解决，例如安全防护、身份认证、权限控制、审计日志、负载均衡 <span class=\"comment-number\">18</span>、容错降级、监控告警等。如果这些功能都让服务自己解决，那势必会消耗大量的人力物力，而他们本该将资源聚焦在业务上。</p>\n\n<p>出于上述种种原因，微服务网关应运而生，它为内部服务提供了一个统一的入口，同时还可以提供上述提到的服务端所需的一系列横向功能，解放业务团队的生产力。微服务网关通常是一个独立的组件，根据其定位，有的网关会保持业务无关性，仅提供通用能力，有的则会包含一部分简单的业务逻辑。但总体上，建议避免将业务逻辑渗透到网关中，从而减少相互之间的耦合度。</p><!-- [[[read_end]]] -->\n<ol>\n<li><p><strong>常见的微服务网关</strong></p>\n<p>既然微服务网关这个需求如此常见，这也就意味着一定已经有了不少优秀的开源网关，我们可以先来了解一下。</p>\n<ul>\n<li><p><strong>Nginx</strong></p>\n<p>Nginx 通常用作网站的负载均衡设施，所以它也理所应当可以用来做微服务网关。Nginx 本身就有很多插件，遇到特殊需求，还可以搭配 Lua 脚本来实现，这就慢慢延伸出了知名的 OpenResty 高性能 Web 平台。后来，在 OpenResty 基础之上诞生了 Kong 网关，它是一款灵活的轻量级云原生服务网关，面向去中心化架构，可以部署在混合云和多云环境中。Kong 可以通过插件实现对请求和响应的拦截，有点类似 AOP 或者过滤器，常用的插件包含身份认证插件、安全控制插件、流量控制插件、分析监控插件、日志应用插件、协议转换插件等。Kong 本身也提供了丰富的 API，可以通过 API 实现对集群的各种管理，而 Kong 集群的各种配置和数据则会记录在 PostgreSQL 或者 Cassandra 里，维护也很方便。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>Apache APISIX</strong></p>\n<p>Apache APISIX 是另一款基于 OpenResty 开发的微服务网关，兼具云原生、高性能、可扩展等诸多优点。APISIX 自带前端，可以方便地在界面上进行路由配置、负载均衡、限流和身份验证等各种操作。APISIX 与 Kong 在核心功能上不相上下，但在细节上似乎更胜一筹，例如，APISIX 在架构上是 Nginx 搭配 Etcd，可以实现配置变更的主动推送，而 Kong 是 Nginx 搭配数据库，需要主动轮询配置变更；Kong 的路由实现是遍历，而 APISIX 是基于基数树，相对更高效。而且，APISIX 是国人开发，对国内主流的一些软件和框架的支持更加友好，例如能够搭配阿里巴巴开源的 Tengine 一同使用，支持 Dubbo 协议代理。此外，作为 Apache 顶级项目，APISIX 也可谓自带光环。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>Zuul</strong></p>\n<p>对 Java 程序员来说，如果微服务网关是 Java 写的，那肯定会是加分项。Netflix 开源的 Zuul 就是一款由 Java 编写且经过大流量考验的微服务网关。而且它是 Spring Cloud 早期推荐的微服务网关，两者无缝整合，加之本身由 Netflix 出品，与 Eureka、Ribbon 和 Hystrix 的配合更是不在话下。在之前的各种场合，Spring Cloud 都会搭配 Zuul 来进行各种演示，在实践中也一样。Zuul 的核心是请求的过滤器，通过各种过滤器来实现身份认证、审计、监控、动态路由、负载均衡等功能。此外，因为 Netflix 是大量部署在 AWS 之上的，所以 Zuul 对 AWS 做了大量的优化，例如能够实现跨可用区访问，支持 AWS 的 ELB（Elastic Load Balancing）等。如果我们的系统是部署在 AWS 上的，那使用 Netflix 的全套设施无疑是个好选择。</p>\n<p>Zuul 1.<em>x</em> 用的是阻塞线程，到了 Zuul 2.<em>x</em>，对架构做了比较大的改动，基于 Netty 实现了异步非阻塞。可惜 Zuul 2.<em>x</em> 并不开源，所以现在它在 Spring Cloud 中的位置逐步被 Spring Cloud Gateawy 所取代。</p>\n</li>\n</ul>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>Spring Cloud Gateway 概述</strong></p>\n<p>由于 Zuul 2.<em>x</em> 的开发一直跳票，到后来索性宣布不再开源，而 Zuul 1.<em>x</em> 又是阻塞式的，长期看来并不符合大的发展趋势，因而 Spring 团队自己开发了一个微服务网关来代替 Zuul，这就是 Spring Cloud Gateway。</p>\n<p>Spring Cloud Gateway 是一款简单、高效的轻量级微服务网关，构建在 Spring 生态之上，用到了 Spring Framework 5、Spring Boot 2 和 Project Reactor 等项目。由于使用了 Spring WebFlux，Spring Cloud Gateway 实现了非阻塞通信，相比 Zuul 1.<em>x</em> 在性能上有很大的提升。</p>\n<p>与前文提到的微服务网关一样，Spring Cloud Gateway 也提供了不少微服务所需的公共能力，例如安全防护、监控、限流熔断等。这些能力都是由过滤器实现的，Spring Cloud Gateway 内置了大量实用的过滤器，它们全是 <code>GatewayFilter</code> 接口的实现，通过可配置的过滤器链（<code>GatewayFilterChain</code>）可以满足绝大部分日常需求。就算遇到了内置过滤器解决不了的问题，也可以直接动手实现自己的 <code>GatewayFilter</code>。当一个请求到达 Spring Cloud Gateway 服务器后，<code>RoutePredicateHandlerMapping</code> 会根据请求去查找对应的 <code>Route</code>（也就是路由配置），其中包含了路由 ID、目标 URI、<strong>断言</strong><span class=\"comment-number\">19</span>（predicate）以及过滤器。整体上来说，Spring Cloud Gateway 的配置非常灵活，在配置服务路由信息时有两种方式可供选择，第一种是完全在 <code>application.yml</code> 中进行配置 <span class=\"comment-number\">20</span>，第二种是使用 Java 配置类。我们在下文详细介绍路由配置时会分别演示这两种方式。</p>\n</li>\n</ol>\n\n\n<h3 id=\"nav_point_254\">16.4.2　Spring Cloud Gateway 的路由配置</h3>\n<p>Spring Cloud Gateway 并不是一个现成的独立服务，而是一个框架，我们需要自己构建一个 Spring Cloud 工程，配置好 <code>spring-cloud-dependencies</code>，像下面这样引入 <code>spring-cloud-starter-gateway</code> 依赖，随后就能在配置文件或者配置类中增加对应的路由规则了。如果还有服务注册与发现的需求，还可以加入对应的起步依赖，Spring Boot 会为我们完成自动配置。</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<p>接下来，让我们通过一个例子来具体看看应该如何进行 Spring Cloud Gateway 的路由配置。</p>\n<blockquote>\n<p><strong>需求描述</strong>　通常情况下，奶茶店系统的后端可被视为一个整体，而顾客在系统外部。因此在顾客访问二进制奶茶店时，最好能够屏蔽系统的内部细节，也就是把 BinaryTea 和 TeaMaker 作为一个整体，与 Customer 隔离开，增加一个独立的服务网关似乎是个不错的选择。</p>\n</blockquote>\n<ol>\n<li><p><strong>基础配置</strong></p>\n<p>Spring Cloud Gateway 作为一个网关，本质上就是接收请求，然后根据预先配置的路由规则对其进行匹配并加以处理，随后转发给后端具体的服务。因此，配置路由规则、用好内置的断言和过滤器基本就是配置的所有工作了。路由的配置以 <code>spring.cloud.gateway.routes</code> 为前缀，主要包含如下几块：</p>\n<ul>\n<li><code>id</code>，路由的编号；</li>\n<li><code>uri</code>，要转发的 URI，可以转给特定的后端 URI，也可以是个负载均衡的服务名；</li>\n<li><code>predicates</code>，要匹配的断言内容，可以是一条，也可以是多条；</li>\n<li><code>filters</code>，在请求转发给后端前需要经过的一个或多个过滤器。</li>\n</ul>\n<p>以转发 <code>/token</code> 请求为例，代码示例 16-20 演示了如何将 <code>/token</code> 请求转发给 <code>http://localhost:8080</code>，最后拼接的 URI 是 <code>http://localhost:8080/token</code>。<span class=\"comment-number\">21</span></p>\n<blockquote>\n<p><strong>代码示例 16-20</strong>　最简单的路径匹配路由</p>\n</blockquote>\n<pre class=\"code-rows\"><code>spring:\n  cloud:\n    gateway:\n      routes:\n        - id: token-route\n          uri: http://localhost:8080\n          predicates:\n            - Path=/token</code></pre>\n<p>断言的配置有两种形式：一种是上面看到的简短写法，断言名称 <code>Path</code> 后跟一个 <code>=</code>，后续内容是要传给断言的参数，用逗号 <code>,</code> 分隔；另一种方式是将断言完全展开，用 <code>name</code> 来指定断言，<code>args</code> 来提供参数（每个断言用到的参数不太一样，可以参考官方文档中的说明）。代码示例 16-21 就演示了如何用第二种方式设置 Path 断言，这里匹配 <code>/order/**</code> 的意思就是匹配以 <code>/order/</code> 开头的所有路径；同时还用了服务发现来配置 URI，可以看到其中的 URI 以 <code>lb://</code> 开头，后面跟的是服务名。<span class=\"comment-number\">22</span></p>\n<blockquote>\n<p><strong>代码示例 16-21</strong>　展开的断言配置</p>\n</blockquote>\n<pre class=\"code-rows\"><code>spring:\n  cloud:\n    gateway:\n      routes:\n        - id: order-route\n          uri: lb://binarytea\n          predicates:\n            - name: Path\n              args:\n                patterns: /order/**</code></pre>\n<p>完成了 <code>/token</code> 和 <code>/order</code> 的路由配置，还剩下 <code>/menu</code> 这个路径，这次我们换 Java 配置类的方式。在配置类中提供一个 <code>RouteLocator</code> 类型的 Bean，通过 <code>RouteLocatorBuilder</code> 来构造我们需要的 <code>RouteLocator</code>，每个路由都能用 <code>PredicateSpec</code> 来描述。代码示例 16-22 就配置了一个 <code>/menu/**</code> 的路由规则，把请求转发到 <code>lb://binarytea</code> 上。</p>\n<blockquote>\n<p><strong>代码示例 16-22</strong>　在 Java 配置类中设置路由规则</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootApplication\npublic class GatewayApplication {\n    // 省略其他代码\n    @Bean\n    public RouteLocator customRouteLocator(RouteLocatorBuilder builder)    {\n        return builder.routes()\n               .route(\"menu-route\", r -&gt; r.path(\"/menu/**\")\n               .uri(\"lb://binarytea\"))\n               .build();\n    }\n}</code></pre>\n<p>最后，要让我们的网关能顺利运行起来，还需要提供一些基础的配置，包括 Zookeeper 配置用来做服务发现与注册，Zipkin 与 Sleuth 的配置，以便能在 Zipkin 里看到实际的请求链路。大概的 YAML 配置会是下面这样的：</p>\n<pre class=\"code-rows\"><code>server.port: 8888\n\nspring:\n  application.name: gateway\n  config.zookeeper.connect-string: \"localhost:2181\"\n  zipkin.base-url: \"http://localhost:9411\"\n  sleuth.sampler.probability: 1.0\n\nmanagement:\n  endpoint.gateway.enabled: true\n  endpoints.web.exposure.include: \"*\"</code></pre>\n<p>为了让 Customer 能通过网关来访问 BinaryTea，而非直接通过服务发现找到目标，我们可以在 <code>application.properties</code> 中将 <code>binarytea.url</code> 改为 <code>http://gateway</code>，同时将 <code>OrderService</code> 上的 <code>@FeignClient</code> 注解里的 <code>name</code> 属性值也改成 <code>gateway</code>。这里的 <code>gateway</code> 就是进行服务注册与发现时网关用的名称。<span class=\"comment-number\">23</span></p>\n<pre class=\"code-rows\"><code>@FeignClient(contextId = \"orderService\", name = \"gateway\", path = \"/order\")\npublic interface OrderService {...}</code></pre>\n<p>现在以此运行 TeaMaker、BinaryTea、Gateway 和 Customer 就能看到实际的运行效果。通过 Zipkin 可以看到实际的请求链路，具体如图 16-9 所示。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00806.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 16-9　通过网关访问的链路图</strong></p>\n<p>对于网关，通常都会设置一个向后端请求的超时时间。在 Spring Cloud Gateway 中，与后端请求相关的 HTTP 配置都以 <code>spring.cloud.gateway.httpclient</code> 为前缀，对应的属性类是 <code>HttpClientProperties</code>。其中 <code>connect-timeout</code> 对应了连接超时，单位为毫秒；<code>response-timeout</code> 则是请求的应答超时，它的类型是 <code>Duration</code>，我们可以自己指定时间单位，默认是毫秒。大概的配置可以是像下面这样的：</p>\n<pre class=\"code-rows\"><code>spring:\n  cloud:\n    gateway:\n      httpclient:\n        connect-timeout: 1000\n        response-timeout: 3s</code></pre>\n<p>除了统一的超时配置，也可以针对每条不同的路由规则单独设置超时时间，这些配置属于路由的元数据，因此要配置在 <code>metadata</code> 里，元数据的属性定义在 <code>RouteMetadataUtils</code> 里，其实也就两个，使用时是这样的：</p>\n<pre class=\"code-rows\"><code>spring:\n  cloud:\n    gateway:\n      routes:\n        - id: token-route\n          uri: http://localhost:8080\n          predicates:\n            - Path=/token\n          metadata:\n            connect-timeout: 500\n            response-timeout: 500</code></pre>\n<p>在上面的例子中，我们已经看到了针对路径进行判断的 <code>Path</code> 断言。Spring Cloud Gateway 中内置了很多不同的路由断言，每种断言都接受不同的参数，表 16-8 罗列了其中的一些断言。路径的 URI 模板中可以添加变量，例如 <code>/binarytea/order/</code>，这里的变量会被保存在 <code>ServerWebExchange.getAttributes()</code> 里，用的键名是 <code>ServerWebExchangeUtils.URI_TEMPLATE_VARIABLES_ATTRIBUTE</code>，在过滤器里也能用到这些变量。</p>\n<p><strong>表 16-8　Spring Cloud Gateway 的一些常用路由断言</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>名称</th><th>作用</th><th>参数</th></tr><tr><td><code>Cookie</code></td><td>根据特定 Cookie 值进行正则匹配</td><td><code>name</code>，要匹配的 Cookie 名称；<code>regexp</code>，Cookie 的值要匹配的正则表达式</td></tr><tr><td><code>Header</code></td><td>根据特定 HTTP Header 值进行正则匹配</td><td><code>header</code>，要匹配的 Header 名称；<code>regexp</code>，HTTP 头的值要匹配的正则表达式</td></tr><tr><td><code>Host</code></td><td>根据请求的主机名进行匹配</td><td><code>patterns</code>，主机名列表，不同主机名之间用逗号分隔，主机名可以使用 ANT 风格</td></tr><tr><td><code>Method</code></td><td>根据 HTTP 方法进行匹配</td><td><code>methods</code>，HTTP 方法列表，不同方法之间用逗号分隔，例如 <code>GET,POST</code></td></tr><tr><td><code>Path</code></td><td>根据请求 URI 路径进行匹配</td><td><code>patterns</code>，路径模式列表，不同路径模式之间用逗号分隔；<code>matchTrailingSlash</code>，是否匹配结尾的 <code>/</code>，该参数可选，默认为 <code>true</code></td></tr><tr><td><code>Query</code></td><td>根据 QueryString 进行匹配</td><td><code>param</code>，要匹配的参数名；<code>regexp</code>，QueryString 要匹配的正则表达式，该参数可选</td></tr><tr><td><code>RemoteAddr</code></td><td>根据对端 IP 地址进行匹配</td><td><code>sources</code>，对端地址列表，形如 <code>192.168.0.1/16</code>，<code>/</code> 前面是地址，后面是子网掩码 <sup><b>24</b></sup></td></tr></table>\n\n<blockquote>\n<p><sup><b>24</b></sup>如果我们的网关在负载均衡后面，可能无法直接取得实际的对端地址。通常负载均衡会把真实地址放在 <code>X-ForwardedFor</code> 之类的 HTTP Header 里，Spring Cloud Gateway 自带一个 <code>RemoteAddressResolver</code> 地址解析器，可以在 Java 类配置路由断言时传入该解析器的实例，从 <code>X-Forwarded-For</code> 中获取地址。</p>\n</blockquote>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>常用过滤器</strong></p>\n<p>前面介绍过了匹配请求用的断言，接下来再来了解一下路由配置中的另一个重点，也就是过滤器。通过过滤器可以对请求和应答进行各种调整。Spring Cloud Gateway 内置了大量的过滤器，它们都是 <code>GatewayFilter</code> 接口的实现，有的专门处理 HTTP Header，有的专门处理请求中的参数，还有的专门处理路径……过滤器的配置方法与断言类似，区别只是它们配置在 <code>filters</code> 下。过滤器都是用 <code>=</code> 来分隔过滤器名称与参数，而参数之间用 <code>,</code> 分隔；也可以用完整配置的方式，<code>name</code> 配置过滤器名称，<code>args</code> 下配置各个参数对。</p>\n<p>下面的配置会保留请求中的 <code>Host</code>Header，使用的就是 <code>PreserveHostHeader</code> 过滤器。</p>\n<pre class=\"code-rows\"><code>spring:\n  cloud:\n    gateway:\n      routes:\n        - id: token-route\n          uri: http://localhost:8080\n          predicates:\n            - Path=/token\n          filters:\n            - PreserveHostHeader</code></pre>\n<p>内置过滤器中有很大一部分是处理 Header 的，表 16-9 中罗列的都是针对 Header 的过滤器。</p>\n<p><strong>表 16-9　部分针对 HTTP Header 的过滤器</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>过滤器名称</th><th>作用</th><th>参数</th></tr><tr><td><code>AddRequestHeader</code></td><td>向请求中添加 Header</td><td><code>name</code>，Header 名；<code>value</code>，对应的值</td></tr><tr><td><code>AddResponseHeader</code></td><td>向应答中添加 Header</td><td><code>name</code>，Header 名；<code>value</code>，对应的值</td></tr><tr><td><code>RemoveRequestHeader</code></td><td>从请求中删除 Header</td><td><code>name</code>，Header 名</td></tr><tr><td><code>RemoveResponseHeader</code></td><td>从应答中删除 Header</td><td><code>name</code>，Header 名</td></tr><tr><td><code>SetRequestHeader</code></td><td>替换请求中的 Header</td><td><code>name</code>，Header 名；<code>value</code>，对应的值</td></tr><tr><td><code>SetResponseHeader</code></td><td>替换应答中的 Header</td><td><code>name</code>，Header 名；<code>value</code>，对应的值</td></tr><tr><td><code>PreserveHostHeader</code></td><td>保留请求中的 <code>Host</code> Header</td><td></td></tr><tr><td><code>SetRequestHostHeader</code></td><td>替换请求中的 <code>Host</code> Header</td><td><code>host</code>，主机名</td></tr><tr><td><code>MapRequestHeader</code></td><td>将请求中的某个 Header 映射为另一个名字，如果原始 Header 不存在，没有任何影响；如果目标已存在，会附加上新值</td><td><code>fromHeader</code>，原始 Header 名；<code>toHeader</code>，目标 Header 名</td></tr><tr><td><code>SecureHeaders</code></td><td>向应答中添加一系列安全相关的 Header，可以通过 <code>spring.cloud.gateway.filter.secure-headers</code> 来调整要设置的 Header，具体内容可以参考 <code>SecureHeadersProperties</code> 类</td><td></td></tr><tr><td><code>DedupeResponseHeader</code></td><td>从应答中去除重复名称的 Header</td><td><code>name</code>，Header 名；<code>strategy</code>，去重的策略，默认值为 <code>RETAIN_FIRST</code>，即保留第一个，<code>RETAIN_LAST</code> 代表保留最后一个，<code>RETAIN_UNIQUE</code> 代表保留独立项</td></tr><tr><td><code>RewriteResponseHeader</code></td><td>根据正则匹配查找替换应答中的 Header</td><td><code>name</code>，Header 名；<code>regexp</code>，要匹配的正则表达式；<code>replacement</code>，要替换成的内容</td></tr></table>\n\n<p>除了 HTTP Header，Spring Cloud Gateway 中还有一些用来处理路径的过滤器，如表 16-10 所示。</p>\n<p><strong>表 16-10　部分针对路径的过滤器</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>过滤器名称</th><th>作用</th><th>参数</th></tr><tr><td><code>PrefixPath</code></td><td>在所有匹配的请求前增加一个路径前缀</td><td><code>prefix</code>，要添加的前缀</td></tr><tr><td><code>StripPrefix</code></td><td>将匹配请求的路径截去一部分</td><td><code>parts</code>，要截掉的数量，即用 <code>/</code> 分隔的段数，是个整数</td></tr><tr><td><code>RewritePath</code></td><td>根据正则匹配替换路径内容</td><td><code>regexp</code>，要匹配的正则表达式；<code>replacement</code>，要替换成的内容</td></tr><tr><td><code>SetPath</code></td><td>直接设置发送给下游的请求路径</td><td><code>template</code>，路径模板，用的就是 Spring 的 URI 模板</td></tr></table>\n\n<p>我们可以像下面这样用 <code>StripPrefix</code> 来处理路径，去除 <code>/binarytea/token</code> 中的 <code>/token</code>。</p>\n<pre class=\"code-rows\"><code>spring:\n  cloud:\n    gateway:\n      routes:\n        - id: new-token-route\n          uri: lb://binarytea\n          predicates:\n            - Path=/binarytea/token\n            - Method=POST\n          filters:\n            - StripPrefix=1</code></pre>\n<p>还有几个比较有用的过滤器，如表 16-11 所示。</p>\n<p><strong>表 16-11　其他一些有用的过滤器</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>过滤器名称</th><th>作用</th><th>参数</th></tr><tr><td><code>AddRequestParameter</code></td><td>增加请求参数</td><td><code>name</code>，要添加的参数名；<code>value</code>，参数对应的值</td></tr><tr><td><code>RemoveRequestParameter</code></td><td>移除请求参数</td><td><code>name</code>，要移除的参数名</td></tr><tr><td><code>SetStatus</code></td><td>控制请求应答的 HTTP 响应码</td><td><code>status</code>，要返回的响应码，既能接受 <code>HttpStatus</code> 中定义的枚举值，也可以用数字，也就是 <code>OK</code> 或者 <code>200</code> 都可以</td></tr><tr><td><code>RedirectTo</code></td><td>直接重定向请求</td><td><code>status</code>，传入 <code>3xx</code> 响应码；<code>url</code>，要重定向的目标 URL</td></tr><tr><td><code>CacheRequestBody</code></td><td>缓存请求体</td><td><code>bodyClass</code>，请求体对应的类型</td></tr></table>\n\n<p>过滤器不仅可以配置在单条路由规则上，还可以批量配置默认的过滤器，使用 <code>spring.cloud.gateway.default-filters</code> 可以轻松地为所有路由规则配置过滤器，比如下面这段配置会为所有路由加上 <code>SecureHeaders</code> 过滤器。</p>\n<pre class=\"code-rows\"><code>spring:\n  cloud:\n    gateway:\n      default-filters:\n        - SecureHeaders</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>服务容错保护</strong></p>\n<p>在 Spring Cloud Gateway 内置的过滤器中，还有一类特殊的过滤器，需要单独拿出来做一下介绍。在第 15 章里我们介绍了如何进行容错保护，在每个服务中通过引入 Resilience4j 等框架来实现基础的保护。其实，微服务网关可以统一为背后的服务提供断路、限流、重试等保护，后端服务如果没有非常强烈的特殊需要，完全可以将这些事托付给网关来处理。</p>\n<p>先来说说断路保护。Spring Cloud Gateway 默认支持 Spring Cloud CircuitBreaker 提供的断路器，在 15.3 节中我们已经介绍过它了。由于 Spring Cloud Gateway 是响应式的，因而我们要先在 pom.xml 中引入 <code>spring-cloud-starter-circuitbreaker-reactor-resilience4j</code> 依赖。</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-circuitbreaker-reactor-resilience4j&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<p><code>CircuitBreaker</code> 过滤器有三个参数，第一个 <code>name</code> 设置了断路器的名称，有了名字就可以像 15.2.2 节中那样为断路器配置各种参数；第二个参数是可选的 <code>fallbackUri</code>，用来设置断路后重定向的 URI，目前仅支持以 <code>forward:</code><span class=\"comment-number\">25</span> 为前缀的 URI，异常信息会被保存在 <code>ServerWebExchange</code> 的属性里，键名是 <code>ServerWebExchangeUtils.CIRCUITBREAKER_EXECUTION_EXCEPTION_ATTR</code>；第三个参数是可选的 <code>statusCodes</code>，这是一个 <code>HttpStatus</code> 列表，可以根据 HTTP 响应码来进行断路统计。在 <code>forward:</code> 跳转到 <code>fallbackUri</code> 时，可以通过 <code>FallbackHeaders</code> 过滤器在 HTTP Header 中传递异常相关的信息（如果有异常信息的话），Header 名可以用表 16-12 中的参数进行设置。</p>\n<p><strong>表 16-12　<code>FallbackHeaders</code> 可以传递的异常信息</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>参数</th><th>默认值</th><th>说明</th></tr><tr><td><code>executionExceptionTypeHeaderName</code></td><td><code>Execution-Exception-Type</code></td><td>异常类型</td></tr><tr><td><code>executionExceptionMessageHeaderName</code></td><td><code>Execution-Exception-Message</code></td><td>异常描述信息</td></tr><tr><td><code>rootCauseExceptionTypeHeaderName</code></td><td><code>Root-Cause-Exception-Type</code></td><td>根因异常类型</td></tr><tr><td><code>rootCauseExceptionMessageHeaderName</code></td><td><code>Root-Cause-Exception-Message</code></td><td>根因异常描述信息</td></tr></table>\n\n<p>我们以 <code>/menu/**</code> 的请求为例，在出现 <code>500 Internal Server Error</code> 时希望能够降级到一个特定的 <code>/fallback</code>URI 上，<code>menu-route</code> 的配置大概会是代码示例 16-23 这样的。</p>\n<blockquote>\n<p><strong>代码示例 16-23</strong>　包含熔断降级功能的菜单路由配置</p>\n</blockquote>\n<pre class=\"code-rows\"><code>spring:\n  cloud:\n    gateway:\n      routes:\n        - id: menu-route\n          uri: lb://binarytea\n          predicates:\n            - Path=/menu/**\n          filters:\n            - FallbackHeaders\n            - name: CircuitBreaker\n              args:\n                name: menu-cb\n                fallbackUri: forward:/fallback\n                statusCodes:\n                  - INTERNAL_SERVER_ERROR</code></pre>\n<p>我们需要在 Gateway 工程中添加一个 <code>/fallback</code> 的 WebFlux 控制器，如代码示例 16-24 所示，它直接返回一个 <code>{}</code>JSON 字符串，把所有的 HTTP Header 打印在日志里。</p>\n<blockquote>\n<p><strong>代码示例 16-24</strong>　<code>/fallback</code> 控制器</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@RestController\n@Slf4j\npublic class FallbackController {\n    @RequestMapping(\"/fallback\")\n    public Mono&lt;String&gt; fallback(ServerHttpRequest request) {\n        request.getHeaders().forEach((k, v) -&gt; log.info(\"Header [{}] : {}\",\n            k, v.stream().collect(Collectors.joining(\",\"))));\n        return Mono.just(\"{}\");\n    }\n}</code></pre>\n<p>假设我们稍微修改一下 BinaryTea 中 <code>/menu/</code> 的代码，会直接抛出一个 <code>RuntimeException</code>，在没有设置 <code>CircuitBreaker</code> 过滤器时，<code>curl</code> 命令访问的输出是这样的：</p>\n<pre class=\"code-rows\"><code>▸ curl -v http://localhost:8888/menu/1\n*   Trying ::1:8888...\n* Connected to localhost (::1) port 8888 (#0)\n&gt; GET /menu/1 HTTP/1.1\n&gt; Host: localhost:8888\n&gt; User-Agent: curl/7.77.0\n&gt; Accept: */*\n&gt;\n&lt; HTTP/1.1 500 Internal Server Error\n&lt; transfer-encoding: chunked\n省略很多HTTP Header……\n&lt; X-Permitted-Cross-Domain-Policies: none\n&lt;\n* Connection #0 to host localhost left intact\n{\"timestamp\":\"2021-12-28T15:14:45.994+00:00\",\"status\":500,\"error\":\"Internal Server Error\",\"path\":\"/menu/1\"}%</code></pre>\n<p>而按照代码示例 16-23 配置后，输出的效果则变成了返回 <code>200 OK</code>，说明我们的断路保护生效了。</p>\n<pre class=\"code-rows\"><code>▸ curl -v http://localhost:8888/menu/1\n*   Trying ::1:8888...\n* Connected to localhost (::1) port 8888 (#0)\n&gt; GET /menu/1 HTTP/1.1\n&gt; Host: localhost:8888\n&gt; User-Agent: curl/7.77.0\n&gt; Accept: */*\n&gt;\n&lt; HTTP/1.1 200 OK\n&lt; Content-Type: text/plain;charset=UTF-8\n&lt; Content-Length: 2\n&lt;\n* Connection #0 to host localhost left intact\n{}%</code></pre>\n<p>对于限流的场景，Spring Cloud Gateway 提供了 <code>RequestRateLimiter</code> 过滤器。它通过 <code>RateLimiter</code> 来判断当前请求是否可以通过，如果不能，则默认返回 <code>429 Too Many Requests</code> 响应码。我们可以用 <code>keyResolver</code> 参数传入 Bean ID，形式是 <code>#{@BeanID}</code>。这是一个 <code>KeyResolver</code> 的实现，告诉 <code>RequestRateLimiter</code> 如何从请求中解析出限流用的键名，默认会用 <code>PrincipalNameKeyResolver</code>，它将从 <code>ServerWebExchange</code> 里取得的 <code>Principal</code> 名称作为键名。如果取不到键名，默认会返回 <code>403 Forbidden</code> 拒绝当前请求，也可以通过调整 <code>spring.cloud.gateway.filter.request-rate-limiter.deny-empty-key=false</code> 和 <code>spring.cloud.gateway.filter.request-rate-limiter.empty-key-status-code=200</code> 改变默认设置。需要注意的是，这个过滤器必须使用完整配置的方式来配置，不支持简单方式配置。</p>\n<p>在现实场景中，集群限流的需求也很强烈，因此 <code>RequestRateLimiter</code> 还支持基于 Redis 的令牌桶算法，通过 Redis 在集群间共享令牌。对 Redis 的支持是由 <code>spring-boot-starter-data-redis-reactive</code> 来提供的，所以网关需要添加这个依赖。相关的参数如表 16-13 所示，不同的搭配能产生不同的限流效果。例如，只允许 1 秒处理 1 个请求可以设置 <code>replenishRate=1</code>、<code>burstCapacity=1</code> 和 <code>requestedTokens=1</code>，如果是 1 分钟处理 1 个请求，则是 <code>replenishRate=1</code>、<code>burstCapacity=60</code> 和 <code>requestedTokens=60</code>。</p>\n<p><strong>表 16-13　Redis 限流的参数</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>参数</th><th>默认值</th><th>说明</th></tr><tr><td><code>redis-rate-limiter.replenishRate</code></td><td></td><td>填充令牌桶的速率，也就是每秒放令牌的个数</td></tr><tr><td><code>redis-rate-limiter.burstCapacity</code></td><td></td><td>令牌桶的最大容量</td></tr><tr><td><code>redis-rate-limiter.requestedTokens</code></td><td><code>1</code></td><td>每次请求从令牌桶中取出的令牌数</td></tr></table>\n\n<p>假设我们希望对 <code>/menu</code> 下的请求进行全局限流，每 30 秒只能请求 1 次，可以像下面这样配置 Redis 限流。注意，由于 YAML 格式的原因，<code>keyResolver</code> 的值需要加引号。</p>\n<pre class=\"code-rows\"><code>spring:\n  redis:\n    host: localhost\n    port: 6379\n  cloud:\n    gateway:\n      routes:\n        - id: menu-route\n          uri: lb://binarytea\n          predicates:\n            - Path=/menu/**\n          filters:\n            - name: RequestRateLimiter\n              args:\n                keyResolver: \"#{@pathKeyResolver}\"\n                redis-rate-limiter.replenishRate: 1\n                redis-rate-limiter.burstCapacity: 30\n                redis-rate-limiter.requestedTokens: 30</code></pre>\n<p>为了针对路径进行限流，我们专门配置了一个 <code>pathKeyResolver</code> Bean，它的配置如代码示例 16-25 所示，此处直接从请求中取出路径作为键名。</p>\n<blockquote>\n<p><strong>代码示例 16-25</strong>　<code>GatewayApplication</code> 中的 <code>pathKeyResolver</code> 配置</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootApplication\npublic class GatewayApplication {\n    @Bean\n    public KeyResolver pathKeyResolver() {\n        return exchange -&gt; Mono.just(exchange.getRequest()\n               .getPath().toString());\n    }\n    // 省略其他代码\n}</code></pre>\n<p>用 curl 命令访问 <code>/menu/1</code>，可以观察一下应答的内容，其中包含了限流相关的信息。</p>\n<pre class=\"code-rows\"><code>▸ curl -v http://localhost:8888/menu/1\n*   Trying ::1:8888...\n* Connected to localhost (::1) port 8888 (#0)\n&gt; GET /menu/1 HTTP/1.1\n&gt; Host: localhost:8888\n&gt; User-Agent: curl/7.77.0\n&gt; Accept: */*\n&gt;\n&lt; HTTP/1.1 200 OK\n&lt; X-RateLimit-Remaining: 0\n&lt; X-RateLimit-Requested-Tokens: 30\n&lt; X-RateLimit-Burst-Capacity: 30\n&lt; X-RateLimit-Replenish-Rate: 1\n&lt; ETag: \"028ff1e8fd36bd1f2a847a91b06f668ee\"\n……\n{\"id\":1,\"name\":\"Java咖啡\",\"size\":\"MEDIUM\",\"price\":{\"amount\":12.00,\"currency\":\"CNY\"},\"createTime\":\n\"2022-01-02T11:53:56.868+00:00\",\"updateTime\":\"2022-01-02T11:53:56.868+00:00\"}%</code></pre>\n<p>在 30 秒内连续访问后，响应码会变为 <code>429 Too Many Requests</code>，也就是被限流了。</p>\n<pre class=\"code-rows\"><code>……\n&lt; HTTP/1.1 429 Too Many Requests\n&lt; X-RateLimit-Remaining: 3\n&lt; X-RateLimit-Requested-Tokens: 30\n&lt; X-RateLimit-Burst-Capacity: 30\n&lt; X-RateLimit-Replenish-Rate: 1\n……</code></pre>\n<p>在发生非正常响应时，通常可以让服务的上游自行处理。对于时间在可接受的范围内、下游又支持重试的情况，让网关发起重试也不失为一种好的选择。Spring Cloud Gateway 提供了 <code>Retry</code> 过滤器，可以精确地控制网关的重试动作。表 16-14 罗列了 <code>Retry</code> 过滤器的参数，通过这几个参数可以控制重试次数以及何时重试。</p>\n<p><strong>表 16-14　<code>Retry</code> 过滤器的参数</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>参数</th><th>默认值</th><th>说明</th></tr><tr><td><code>retries</code></td><td><code>3</code></td><td>重试次数</td></tr><tr><td><code>statuses</code></td><td></td><td>要重试的 HTTP 响应码列表，枚举是 <code>HttpStatus</code></td></tr><tr><td><code>methods</code></td><td><code>GET</code></td><td>要重试的 HTTP 方法列表，枚举是 <code>HttpMethod</code></td></tr><tr><td><code>series</code></td><td><code>5XX</code></td><td>要重试的 HTTP 响应码系列列表，枚举是 <code>HttpStatus.Series</code></td></tr><tr><td><code>exceptions</code></td><td><code>IOException</code> 与 <code>TimeoutException</code></td><td>要重试的异常列表</td></tr></table>\n\n<p>如果希望两次重试之间的时间间隔能呈指数级递增，可以配置 <code>backoff</code> 参数。这个参数默认是关闭的，下面有多个参数配合，表 16-15 是 <code>backoff</code> 中可以配置的参数。如果 <code>basedOnPreviousValue</code> 为 <code>true</code>，间隔时间是上次间隔时间 <code>* factor</code>；如果为 <code>false</code>，则为 <code>firstBackoff * (factor ^ n)</code>，<code>n</code> 为迭代数，间隔时间的计算方式可以参考 <code>Backoff.exponential()</code> 方法。</p>\n<p><strong>表 16-15　<code>backoff</code> 中包含的参数</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>参数</th><th>默认值</th><th>说明</th></tr><tr><td><code>firstBackoff</code></td><td><code>5ms</code></td><td>首次间隔时间</td></tr><tr><td><code>maxBackoff</code></td><td></td><td>最大的间隔时间，为空则没有上限</td></tr><tr><td><code>factor</code></td><td><code>2</code></td><td>指数级递增的因子</td></tr><tr><td><code>basedOnPreviousValue</code></td><td><code>true</code></td><td>是否基于上一次的间隔时间进行计算</td></tr></table>\n\n<p>下面针对 <code>/token</code> 这个路径的 <code>POST</code> 请求配置了一个重试策略：重试 5 次；间隔时间第 1 次为 10 毫秒，第 2 次为 20 毫秒，第 3 次为 40 毫秒，第 4 次为 50 毫秒，第 5 次为 50 毫秒，算上第一次正常请求，一共会有 6 次调用。</p>\n<pre class=\"code-rows\"><code>spring:\n  cloud:\n    gateway:\n      routes:\n        - id: token-route\n          uri: http://localhost:8080\n          predicates:\n            - Path=/token\n          filters:\n            - name: Retry\n              args:\n                retries: 5\n                methods: POST\n                series: CLIENT_ERROR\n                backoff:\n                  firstBackoff: 10ms\n                  maxBackoff: 50ms\n                  basedOnPreviousValue: false</code></pre>\n<p>这里为了方便演示，专门针对 <code>4XX</code> 的应答进行了重试配置。用下面的 curl 命令请求后，可以观察 BinaryTea 的日志，能看到有 6 次响应码是 <code>400</code> 的请求。</p>\n<pre class=\"code-rows\"><code>▸ curl -v -X POST -H \"Content-Type: application/json\" -d \"{}\" http://localhost:8888/token</code></pre>\n</li>\n</ol>\n\n\n\n\n<h2 id=\"nav_point_255\">16.5　小结</h2>\n<p>本章我们着重了解了一些与服务集成有关的知识，例如，在 REST 服务这种方式以外，还可以使用 Apache Dubbo 进行 RPC 通信，通过消息中心进行异步的消息通信。在复杂的微服务架构里，如何在 OpenZipkin 的帮助下了解服务的全貌。市面上几乎所有的服务链路治理工具都受到了 Dapper 论文的影响，Trace ID 和 Span ID 十分重要。最后我们还看了下 Spring Cloud Gateway。在 Spring Cloud 的早期版本中，微服务网关是 Zuul 1.<em>x</em>，但现在已经是以 Spring Cloud Gateway 为主了。作为一款简单易用的微服务网关，它很好地嵌入了 Spring 生态。</p>\n<blockquote>\n<p style=\"text-align: center\"><strong>二进制奶茶店项目开发小结</strong></p>\n<p>在本章中，针对二进制奶茶店的系统，我们尝试用 Dubbo RPC 服务来代替 REST 服务。对于下面两个更适合用异步通知的场景，还用 MQ 消息代替了 HTTP 服务：</p>\n<ul>\n<li>支付后通知调茶师开始制作订单；</li>\n<li>订单制作完毕通知前台。</li>\n</ul>\n<p>为了应对不断增长的复杂性，我们引入了 Spring Cloud Sleuth 来进行服务链路分析，帮助我们理解一个订单的处理链路。针对要对外提供服务的微服务，通常还会在服务的前面增加微服务网关，我们用 Spring Cloud Gateway 配置了一个最基础的网关。</p>\n<p>纵观整个二进制奶茶店的例子，它为我们演示了很多功能，包括但不限于：</p>\n<ul>\n<li>Spring Framework 与 Spring Boot 的基础使用方法；</li>\n<li>通过 JDBC 与 ORM 框架来操作数据库；</li>\n<li>Redis 的基础用法；</li>\n<li>基于 Spring MVC 的 Web 开发方法；</li>\n<li>发布与调用 RESTful 风格的 Web 服务；</li>\n<li>通过 Spring Security 保护 Web 服务；</li>\n<li>生产并消费基于消息中间件的消息；</li>\n<li>基于 Spring Cloud 实现服务注册与发现、服务配置与服务容错。</li>\n</ul>\n<p>这个例子相对简单，并不能直接放到生产中使用，但它已经足够用来说明框架与组件的使用方法了。</p>\n</blockquote>\n\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"第 16 章 服务集成(2)","id":740894},"right":{"article_title":"第五部分 附录","id":740896}},"comments":[]}