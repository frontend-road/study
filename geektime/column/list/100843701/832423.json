{"id":832423,"title":"03｜单机吞吐优化（一）：无需硬件升级也能提升吞吐","content":"<p>你好，我是徐逸。</p><p>通过前面的学习，我们了解了性能优化的流程和Golang性能优化工具。</p><p>这节课开始我将带你掌握工作中常见的性能优化技巧，这也是服务性能优化流程第四步——性能调优的基础。只有掌握了一定的技巧，当我们定位到瓶颈原因时，才能更快地想出性能优化方案，轻松应对常见的性能问题。</p><p>在介绍具体的优化技巧之前，先让我们想一想，当你需要提升单机吞吐时，你会怎么办呢？</p><p>我们通常的思路是定位到单机瓶颈资源。对于瓶颈资源有两种处理方法，一是增加资源，比如提升单机CPU、内存等资源的规格；二是减少单个请求对瓶颈资源的消耗，让相同的资源可以处理更多的请求。</p><p>在服务器数目比较多时，需要增加很多机器成本，所以我们今天就来看看不提升单机CPU和内存规格的前提下，有哪些常用的高性能技巧。因为在Golang里容器类型比较常用，所以后面课程里我们就把它作为研究对象。</p><h2>实验设计</h2><p>为了模拟线上的性能优化过程。我们先构造一个http服务。这个服务包含一个请求处理方法Handler。方法里有两个逻辑，一个是循环往切片append数据，另一个是用map类型构造一个集合。</p><p>接下来，我们就基于这个接口的性能优化过程，带你学习一些实用的高性能技巧。</p><!-- [[[read_end]]] --><pre><code class=\"language-go\">package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    _ \"net/http/pprof\"\n)\n\nfunc Handler(w http.ResponseWriter, r *http.Request) {\n    slices := getRawSlices()\n    getRawSet(slices)\n    // 设置响应头，这里设置Content-Type为text/plain，表示返回纯文本内容\n    w.Header().Set(\"Content-Type\", \"text/plain\")\n    // 向客户端写入响应内容\n    fmt.Fprintln(w, \"hh\")\n}\nfunc main() {\n    // 注册路由，当客户端访问根路径\"/\"时，会调用Handler函数进行处理\n    http.HandleFunc(\"/\", Handler)\n    err := http.ListenAndServe(\":8888\", nil)\n    if err != nil {\n        panic(err)\n    }\n}\n\n// getRawSlices 循环往切片append数据\nfunc getRawSlices() []int {\n    n := 10000\n    slices := make([]int, 0)\n    for i := 0; i &lt; n; i++ {\n        slices = append(slices, i)\n    }\n    return slices\n}\n\n// 构造集合\nfunc getRawSet(slices []int) map[int]bool {\n    set := make(map[int]bool, 0)\n    for _, item := range slices {\n        set[item] = true\n    }\n    return set\n}\n</code></pre><p>现在让我们用ab工具（Apache Bench）模拟线上用户，对这个http服务发起请求压测。</p><pre><code class=\"language-shell\">-n 请求数量 \n-c 并发数量\nab -n 30000 -c 2 http://127.0.0.1:8888/\n</code></pre><p>假如在ab工具压测的过程中，我们发现内存资源占用比较高，可以用<a href=\"https://time.geekbang.org/column/article/831211\">上节课</a>学习到的pprof工具，采集单机内存性能报告并生成下面的内存火焰图。</p><pre><code class=\"language-shell\">curl \"http://127.0.0.1:8888/debug/pprof/heap?seconds=30\" &gt; heap.pprof\n\ngo tool pprof -http :8889 heap.pprof\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/5f/1a/5f125ecec3f413f7959b6432dfb08c1a.jpg?wh=2902x628\" alt=\"\" title=\"图1 原始函数内存火焰图\"></p><p>从火焰图中我们可以看出来，在应用内部的处理逻辑，也就是Handler方法里，getRawSet函数是内存消耗最大的函数。接着，我们点击火焰图的最后一行进入getRawSet函数内部查看，可以看到下面的图，消耗内存资源的热点代码是map赋值这行代码。</p><p><img src=\"https://static001.geekbang.org/resource/image/06/30/0625f65ce35d116708e5754d26158a30.jpg?wh=1538x820\" alt=\"\" title=\"图2 内存分配热点代码\"></p><p>结合这行代码的上下文，可知这段代码逻辑的目的是用map构造一个集合。那这里面有没有什么优化空间呢？</p><p>我们可以从两个方向寻找答案：</p><ul>\n<li>\n<p>先考虑存入map的数据能不能尽量少。</p>\n</li>\n<li>\n<p>除了我们存入的数据之外，map赋值操作是如何实现的，里面是否存在耗内存的动作，有的话能否减少甚至规避掉？</p>\n</li>\n</ul><p>先让我们来看看第一个方向。</p><h2>空结构体：集合表示如何省内存？</h2><p>从集合的使用场景来看，我们要么判断一个key是不是在map中，要么获取map里面的所有key，而map里面的value值，在集合的使用场景中并不需要。那有没有办法消除map里面的value所占的内存空间呢？</p><p><strong>在 Go 语言里，提供了空结构体类型struct{}，而空结构体对象所占的空间大小为0</strong>。咱们可以写个小测试来看看：</p><pre><code class=\"language-go\">func TestSize(t *testing.T) {\n    fmt.Printf(\"struct {} size: %d byte\\n\", unsafe.Sizeof(struct{}{}))\n}\n</code></pre><p>运行这个测试函数，可以看到空结构体类型的确不占内存空间。</p><pre><code class=\"language-shell\">=== RUN   TestSize\nstruct {} size: 0 byte\n</code></pre><p>因此咱们可以把map的value类型，从bool类型改为空结构体类型，就像下面的代码一样。</p><pre><code class=\"language-go\">// value用空结构体类型\nfunc getEmptyStructSet(slices []int) map[int]struct{} {\n    set := make(map[int]struct{}, 0)\n    for _, item := range slices {\n        set[item] = struct{}{}\n    }\n    return set\n}\n</code></pre><p>那么使用空结构体类型，能给我们带来多大的性能提升呢？我们用 Benchmark 来测一测。Benchmark脚本如下所示：</p><pre><code class=\"language-go\">var slices []int\n\nfunc init() {\n    slices = getRawSlices()\n}\n\nfunc BenchmarkGetRawSet(b *testing.B) {\n    for n := 0; n &lt; b.N; n++ {\n        getRawSet(slices)\n    }\n}\n\nfunc BenchmarkGetEmptyStructSet(b *testing.B) {\n    for n := 0; n &lt; b.N; n++ {\n        getEmptyStructSet(slices)\n    }\n}\n</code></pre><p>测试结果出来了，我们可以看到<strong>value用空结构体类型，性能有了一定程度的提升</strong>。从内存消耗来看，value用bool类型，单次函数调用要427596字节内存，而用空结构体类型，每次函数调用只要389449字节内存，节约了 9% 左右的内存资源。</p><pre><code class=\"language-shell\">killianxu@KILLIANXU-MB0 3 % go test -bench='.' -benchmem -benchtime=10s\nwarning: GOPATH set to GOROOT (/usr/local/go) has no effect\ngoos: darwin\ngoarch: amd64\npkg: server-go/3\ncpu: Intel(R) Core(TM) i5-7360U CPU @ 2.30GHz\nBenchmarkGetRawSet-4               17214            608437 ns/op          427596 B/op        319 allocs/op\nBenchmarkGetEmptyStructSet-4       19430            563814 ns/op          389449 B/op        255 allocs/op\n</code></pre><p>现在让我们再看一下内存火焰图，看看经过空结构体类型的优化后，我们的代码是否还有优化空间。<br>\n<img src=\"https://static001.geekbang.org/resource/image/2a/yy/2ae951758abb784f769082bf168fc1yy.jpg?wh=2886x728\" alt=\"\" title=\"图3 空结构体优化后内存火焰图\"></p><p>从火焰图中我们可以看到，用空结构体优化后，构造集合的getEmptyStructSet函数，依然是最消耗内存的函数。</p><p>前面我提到可以从两个方向找答案，并且通过将value的类型，从bool改为空结构体，减少了存入map的数据大小。为了继续降低map的内存资源消耗，现在让我们从第二个方向——map赋值操作的方向找答案。</p><h2>指定容量：容器操作如何避免扩容迁移？</h2><p>在搞明白map赋值操作的逻辑之前，我们需要先了解map的数据结构。就像下面的图展示的一样，<strong>map底层其实是以数组+链表的数据结构存储key-value对的</strong>。为了描述方便，数组的每一个位置，通常我们称它为桶。</p><p><img src=\"https://static001.geekbang.org/resource/image/43/e8/4358fc1588d7ece96fb69b03547665e8.jpg?wh=1714x903\" alt=\"\" title=\"图4 map 内部数据结构\"></p><p>正常情况下，当往map中写入ket-value对时，Go底层会根据key做hash，定位到需要写入key-value对的桶，并插入桶对应的链表中。<br>\n<img src=\"https://static001.geekbang.org/resource/image/bb/2b/bbb0bf899974264b2505ae93441bca2b.jpg?wh=2584x884\" alt=\"\" title=\"图5 map 写入操作\"></p><p>但是当map里面写入的数据过多时，数组里面的桶链表会越来越长。而map的写入和读取，都需要遍历桶链表，因此过长的桶链表会影响map的读写性能。</p><p>为了缓解这种情况，在往map写入数据时，如果map中的数据量已经比较多了，Go底层还有个扩容迁徙的分支逻辑，这个扩容迁移的分支逻辑是怎么样的呢？</p><p>扩容迁移的逻辑分成2步，我们结合后面这张图来理解更直观一些。<br>\n<img src=\"https://static001.geekbang.org/resource/image/c5/28/c5ba996164c294003e7118ff83875a28.jpg?wh=2774x1978\" alt=\"\" title=\"图6 map 写入触发扩容迁移\"></p><p>首先<strong>申请更大的数组空间。</strong></p><p>然后将旧数组空间数据迁移到新数组空间。<strong>Go采取了渐进式hash的思想，每次往map写入数据时，会触发从旧数组空间往新数组空间迁移两个桶链表数据，从而避免一次迁移全量数据导致map写请求延时抖动，直到旧数组空间的所有桶链表迁移完为止。</strong></p><p>虽然通过扩容迁移，将原先在同一个桶链表里的数据，重新hash到新数组不同的桶链表中，可以减少桶链表长度，避免map读写性能大幅度裂化。但是扩容迁移属于消耗内存和CPU资源的操作，如果循环往map写入，可能会触发多次扩容迁移，消耗大量内存和CPU资源。</p><p>那有没有办法避免写入过程触发扩容迁移呢？</p><p>实际上，<strong>创建map的make函数提供了一个size参数。Go底层在创建map对象时，会根据传入的size参数申请数组空间。因此只要我们能提前知道map要存储的数据量，就能传入这个size参数，从而避免写入过程频繁扩容。</strong></p><p>就像下面的代码一样，由于我们的切片里没有重复数据，因此当我们用make函数构造map时，可以将切片长度作为size参数传入。</p><pre><code class=\"language-go\">// 提前指定容量\nfunc getCapacitySet(slices []int) map[int]struct{} {\n    set := make(map[int]struct{}, len(slices))\n    for _, item := range slices {\n        set[item] = struct{}{}\n    }\n    return set\n}\n</code></pre><p>那么构造map时，指定size的方式，又能给咱们带来多大的性能提升呢？咱们继续用Benchmark来测一测。</p><p>下面是Benchmark脚本：</p><pre><code class=\"language-go\">func BenchmarkGetEmptyStructSet(b *testing.B) {\n    for n := 0; n &lt; b.N; n++ {\n        getEmptyStructSet(slices)\n    }\n}\n\nfunc BenchmarkGetCapacitySet(b *testing.B) {\n    for n := 0; n &lt; b.N; n++ {\n        getCapacitySet(slices)\n    }\n}\n</code></pre><p>然后你会发现，<strong>指定map容量的方式，性能提升很明显。</strong>我们依然用数据说话。</p><pre><code class=\"language-shell\">killianxu@KILLIANXU-MB0 3 % go test -bench='.' -benchmem -benchtime=10s   \nwarning: GOPATH set to GOROOT (/usr/local/go) has no effect\ngoos: darwin\ngoarch: amd64\npkg: server-go/3\ncpu: Intel(R) Core(TM) i5-7360U CPU @ 2.30GHz\nBenchmarkGetEmptyStructSet-4       21218            563814 ns/op          389461 B/op        255 allocs/op\nBenchmarkGetCapacitySet-4          41742            287038 ns/op          182480 B/op         11 allocs/op\n</code></pre><ul>\n<li>从内存消耗来看，不指定map容量的方式，单次函数调用要389461字节内存，而指定容量的方式，每次函数调用只要182480字节内存，节约了 53% 左右的内存资源。</li>\n<li>从 CPU 资源消耗来看，不指定map容量的方式，单次函数调用要563814ns，而指定容量的方式只要287038ns，节约了 49% 左右的 CPU 资源。</li>\n</ul><p>现在让我们再看一下内存火焰图，看看我们的代码是否还有进一步优化空间。</p><p><img src=\"https://static001.geekbang.org/resource/image/b0/77/b0daf4f8a700d8010ea20feebda95277.jpg?wh=2908x558\" alt=\"\" title=\"图7 指定 map 容量优化后的火焰图\"></p><p>从内存火焰图中我们可以看出，除了已经优化后的集合构造函数getCapacitySet，现在最消耗内存的是切片生成函数getRawSlice。</p><p>现在我们从火焰图进入getRawSlice函数内部，就会看到下面的图，消耗内存资源的热点代码是切片append这行代码。<br>\n<img src=\"https://static001.geekbang.org/resource/image/7b/28/7b6bc457b5fff6afe4af0b4a654b9828.jpg?wh=1688x717\" alt=\"\" title=\"图8 getRawSlice 函数内部热点代码\"></p><p>结合这行代码的上下文，可以知道这段代码逻辑是在循环地往切片里面做append操作。那么我们自然会想到，可以去看看切片的append操作是如何实现的，这里面有没有啥优化空间呢？</p><p><strong>切片底层数据结构是用一个数组存储数据的</strong>，通常进行append操作时，会往数组末尾插入数据。</p><p><img src=\"https://static001.geekbang.org/resource/image/d7/7b/d7cdc766f5b62ab9e1b6efa14488f97b.jpg?wh=1165x654\" alt=\"\" title=\"图9 append 操作\"></p><p>但是当<strong>数组空间不够时，append操作会触发扩容迁移，申请更大的数组空间，并将旧数组数据拷贝到新数组，以便存放更多的数据</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/53/8b/53d702086c76a117e8a96fc907cb918b.jpg?wh=1552x886\" alt=\"\" title=\"图10 append 触发扩容\"></p><p>我们从扩容迁移的过程可以看出来，<strong>扩容迁移存在内存分配和数据拷贝操作，需要消耗内存和CPU资源</strong>。当循环做切片append操作时，可能会触发频繁扩容迁移，消耗大量的内存和CPU资源。</p><p>那切片append操作有没有办法避免扩容迁移呢？</p><p>实际上，和map一样，我们在创建切片对象时，也可以传入容量字段。就像下面的代码一样，这样切片就会一次性申请足够数组空间，从而避免后续写入过程发生扩容迁移。</p><pre><code class=\"language-go\">// getCapacitySlices 提前指定容量\nfunc getCapacitySlices() []int {\n    n := 10000\n    slices := make([]int, 0, n)\n    for i := 0; i &lt; n; i++ {\n        slices = append(slices, i)\n    }\n    return slices\n}\n</code></pre><p>切片创建时指定容量的方式，又能给咱们带来多大的性能提升呢？Benchmark脚本如下，我们再来测试一下。</p><pre><code class=\"language-go\">func BenchmarkGetRawSlices(b *testing.B) {\n    for n := 0; n &lt; b.N; n++ {\n        getRawSlices()\n    }\n}\n\nfunc BenchmarkGetCapacitySlices(b *testing.B) {\n    for n := 0; n &lt; b.N; n++ {\n        getCapacitySlices()\n    }\n}\n</code></pre><p><strong>果然，指定切片容量的方式，性能提升非常明显。</strong></p><pre><code class=\"language-shell\">killianxu@KILLIANXU-MB0 3 % go test -bench='.' -benchmem -benchtime=10s\nwarning: GOPATH set to GOROOT (/usr/local/go) has no effect\ngoos: darwin\ngoarch: amd64\npkg: server-go/3\ncpu: Intel(R) Core(TM) i5-7360U CPU @ 2.30GHz\nBenchmarkGetRawSlices-4           209412             55297 ns/op          357626 B/op         19 allocs/op\nBenchmarkGetCapacitySlices-4      844266             13318 ns/op           81920 B/op          1 allocs/op\n</code></pre><ul>\n<li>\n<p>从内存消耗来看，不指定切片容量的方式，单次函数调用要357626字节内存，而指定容量的方式，每次函数调用只要81920字节内存，节约了 77% 左右的内存资源。</p>\n</li>\n<li>\n<p>从 CPU 资源消耗来看，不指定切片容量的方式，单次函数调用要55297ns，而指定容量的方式，只要13318ns，节约了 76% 左右的 CPU 资源。</p>\n</li>\n</ul><p>让我们用火焰图再看看我们的函数是否还有优化空间。</p><p><img src=\"https://static001.geekbang.org/resource/image/93/7f/93c6521d7e75c892cd2239d86yy1287f.jpg?wh=2908x547\" alt=\"\" title=\"图11 指定容量优化后内存火焰图\"></p><p>从火焰图上我们可以看出来，经过前面几次的优化，应用内部最耗时的函数就只剩下已经优化过之后的getCapacitySet和getCapacitySlices函数，没有进一步优化的空间了。</p><h2>小结</h2><p>今天这节课，我以一段待优化的http服务接口为例，在逐步优化其对内存资源的消耗过程中，向你展示了能降低内存和CPU资源消耗的2个高性能容器类型的使用技巧。</p><ul>\n<li>\n<p>当用map构造集合时，我们可以将value类型设置为空结构体类型，<strong>空结构体类型不占用内存空间</strong>，这样就能帮我们降低内存资源消耗。</p>\n</li>\n<li>\n<p>当创建map和切片对象时，如果我们可以<strong>提前确定容器容量</strong>，就可以传入make函数中，从而<strong>避免往集合中添加数据时触发扩容迁移，达到降低内存和CPU资源消耗的目的</strong>。</p>\n</li>\n</ul><p>希望你好好体会这个从线上服务获取内存火焰图寻找瓶颈，再结合Go语言底层实现分析寻找更优方案的过程。在遇到内存和CPU瓶颈时，别忘了尝试运用这两个容器类型的使用技巧，帮你节约更多内存和CPU资源，提升单机吞吐。</p><h2>思考题</h2><p>对于容器类型，除了这节课讲到的2种高性能使用技巧，你还知道哪些高性能的使用技巧呢？</p><p>欢迎你把你的答案分享在评论区，也欢迎你把这节课的内容分享给需要的朋友，我们下节课再见！</p>","comments":[{"had_liked":false,"id":396382,"user_name":"陈卧虫","can_delete":false,"product_type":"c1","uid":1481979,"ip_address":"浙江","ucode":"44BB84712436AB","user_header":"https://static001.geekbang.org/account/avatar/00/16/9c/fb/7fe6df5b.jpg","comment_is_top":false,"comment_ctime":1734232303,"is_pvip":false,"replies":[{"id":143912,"content":"👍👍👍","user_name":"作者回复","user_name_real":"编辑","uid":1313417,"ctime":1734359033,"ip_address":"广东","comment_id":396382,"utype":1}],"discussion_count":1,"race_medal":5,"score":2,"product_id":100843701,"comment_content":"听完老师的课查了一下资料，总结一下，不足之处请老师指正，容器类型优化的其它技巧：\n1. 尽量避免频繁对 map 和 slice 的增删，这会触发底层结构重新分配\n2. 并发场景下 减少锁争用，比如使用并发安全的 sync.map 或者 通过分片技术将大 map 分为小 map \n3. 需要大量短生命周期容器对象时，通过 sync.pool 复用对象，减少频繁的内存重新分配\n4. 在多线程场景下，使用 sync.once 优化初始化操作，保证只执行一次\n5. 容器元素为 大对象 或者 复杂结构体，传递指针而不是值，这样可以减少拷贝的开销，特别是在作为函数参数时\n6. 对于结构体来说，按照字段的大小降序排列，可以降低内存对齐时的填充浪费","like_count":2,"discussions":[{"author":{"id":1313417,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0a/89/eb8c28a4.jpg","nickname":"徐逸","note":"","ucode":"DCFDEE08FD263A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":655195,"discussion_content":"👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1734359033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":396410,"user_name":"Geek_b9db3a","can_delete":false,"product_type":"c1","uid":2800436,"ip_address":"天津","ucode":"4E6E8809384E86","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM5urtPqOYes73XMicgz1JokicicckysAtasEjibbETF34uVRN4oSOUlPUSzibicMI2rwawbJe8bscvahPjA/132","comment_is_top":false,"comment_ctime":1734330655,"is_pvip":false,"replies":[{"id":143907,"content":"报错是解析文件失败了，一般是生成的文件有问题。可以看下curl &quot;http:&#47;&#47;127.0.0.1:8888&#47;debug&#47;pprof&#47;heap?seconds=30&quot; &gt; heap.pprof生成的过程有没有报什么错，比如Failed to connect之类的，导致文件内容存储的不是火焰图，而是报错的文本内容","user_name":"作者回复","user_name_real":"编辑","uid":1313417,"ctime":1734352029,"ip_address":"广东","comment_id":396410,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100843701,"comment_content":"curl &quot;http:&#47;&#47;127.0.0.1:8888&#47;debug&#47;pprof&#47;heap?seconds=30&quot; &gt; heap.pprof\ngo tool pprof -http :8889 heap.pprof\nheap.pprof: parsing profile: unrecognized profile format\nfailed to fetch any source profiles","like_count":0,"discussions":[{"author":{"id":1313417,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0a/89/eb8c28a4.jpg","nickname":"徐逸","note":"","ucode":"DCFDEE08FD263A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":655188,"discussion_content":"报错是解析文件失败了，一般是生成的文件有问题。可以看下curl &#34;http://127.0.0.1:8888/debug/pprof/heap?seconds=30&#34; &gt; heap.pprof生成的过程有没有报什么错，比如Failed to connect之类的，导致文件内容存储的不是火焰图，而是报错的文本内容","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1734352029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2882695,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/fc/87/d37106d5.jpg","nickname":"海梦","note":"","ucode":"DA2ADE2DED464D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":655362,"discussion_content":"我也有同样的报错，curl &#34;http://127.0.0.1:8888/debug/pprof/heap?seconds=30&#34; &gt; heap.pprof执行的时候没有任何内容，查看文件内容StatusCode: 200，应该没报错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1734684240,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":396397,"user_name":"快叫我小白","can_delete":false,"product_type":"c1","uid":3571201,"ip_address":"上海","ucode":"7CAD65E36601A2","user_header":"https://static001.geekbang.org/account/avatar/00/36/7e/01/1660e1e8.jpg","comment_is_top":false,"comment_ctime":1734278146,"is_pvip":false,"replies":[{"id":143916,"content":"1.benchmark是循环n次，输出的是平均每次函数调用分配的内存和分配次数\n2.用benchmark测试的目的，是为了对比同一个功能的函数，优化前后内存分配量是否有降低(这里面也包含了临时内存)。\n3.你的说法，看峰值是没有错的，但是峰值本身有很多就是GC来不及回收的临时对象占用的，降低单个请求函数里面的内存分配，可以降峰值。\n4.除了峰值之外，我们也可以降低堆内存分配，因为堆内存分配和GC回收，会消耗CPU资源，这就是为什么需要利用对象池(sync.Pool)做复用，而不是每次重新分配对象的原因。","user_name":"作者回复","user_name_real":"编辑","uid":1313417,"ctime":1734448773,"ip_address":"广东","comment_id":396397,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100843701,"comment_content":"我不确定我的理解是否正确，benchmark上内存消耗情况指的是从程序运行到结束分配过的内存总字节数，而不是程序运行过程中某一时刻的最大使用内存字节数。所以我们在做内存性能优化时追求的、并且衡量一个程序内存使用效率的好坏的指标都是前者？跟我一直的理解有点出入，我以为释放掉的内存会被垃圾回收，所以只要确保内存使用峰值不要过高就好了，😂如果我的理解有误希望老师能指正一下～","like_count":0,"discussions":[{"author":{"id":1313417,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0a/89/eb8c28a4.jpg","nickname":"徐逸","note":"","ucode":"DCFDEE08FD263A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":655235,"discussion_content":"1.benchmark是循环n次，输出的是平均每次函数调用分配的内存和分配次数\n2.用benchmark测试的目的，是为了对比同一个功能的函数，优化前后内存分配量是否有降低(这里面也包含了临时内存)。\n3.你的说法，看峰值是没有错的，但是峰值本身有很多就是GC来不及回收的临时对象占用的，降低单个请求函数里面的内存分配，可以降峰值。\n4.除了峰值之外，我们也可以降低堆内存分配，因为堆内存分配和GC回收，会消耗CPU资源，这就是为什么需要利用对象池(sync.Pool)做复用，而不是每次重新分配对象的原因。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1734448773,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":396370,"user_name":"lJ","can_delete":false,"product_type":"c1","uid":2562558,"ip_address":"江苏","ucode":"CC29D06A16FF93","user_header":"https://static001.geekbang.org/account/avatar/00/27/19/fe/d31344db.jpg","comment_is_top":false,"comment_ctime":1734146996,"is_pvip":false,"replies":[{"id":143894,"content":"👍👍👍，其实slice append内部，就是用倍数扩容的机制实现的。sync.Map的使用条件比较苛刻，在后面有一节专门会讲","user_name":"作者回复","user_name_real":"编辑","uid":1313417,"ctime":1734326937,"ip_address":"广东","comment_id":396370,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100843701,"comment_content":"对于slice，如果无法预估所有数据大小，可以通过每次扩展时成倍增加容量，减少频繁扩容带来的开销。\n在高并发场景下，如果需要对 map 进行频繁的多次读一次写操作，推荐使用 sync.Map。如果是多次读写情况，推荐使用concurrent-map。\nmap 的性能高度依赖于键的哈希分布，尽量选择能避免哈希冲突的键。\n对于任何容器类型，如果需要频繁创建和销毁对象，都会导致 GC 压力增加，可以使用 sync.Pool 实现对象的重用。","like_count":0,"discussions":[{"author":{"id":1313417,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0a/89/eb8c28a4.jpg","nickname":"徐逸","note":"","ucode":"DCFDEE08FD263A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":655147,"discussion_content":"👍👍👍，其实slice append内部，就是用倍数扩容的机制实现的。sync.Map的使用条件比较苛刻，在后面有一节专门会讲","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1734326937,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":1,"child_discussions":[{"author":{"id":2562558,"avatar":"https://static001.geekbang.org/account/avatar/00/27/19/fe/d31344db.jpg","nickname":"lJ","note":"","ucode":"CC29D06A16FF93","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1313417,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0a/89/eb8c28a4.jpg","nickname":"徐逸","note":"","ucode":"DCFDEE08FD263A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":655252,"discussion_content":"老师，翻倍扩容是有条件的，在容量小于 256 时，直接采用翻倍策略。超过 256 后，切片的容量按照约 1.25 倍逐步增长，实测发现也并不是严格按照1.25倍。https://github.com/golang/go/blob/95b433eed428afbb4ab32f0f2541774e939989c7/src/runtime/slice.go#L289","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1734502504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":655147,"ip_address":"江苏","group_id":0},"score":655252,"extra":""}]}]}]}