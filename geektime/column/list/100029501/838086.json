{"id":838086,"title":"加餐03｜SQL实战：保险场景的数据查询与优化","content":"<p>你好，我是陈博士，今天我们来探讨一下保险续保业务的数据分析与优化。</p><p>续保业务是保险公司持续稳定发展的重要组成部分。通过深入的数据查询和分析，我们可以评估客户的续保倾向，识别潜在的流失风险，并为后续的续保策略提供决策支持。</p><p></p><p>针对该场景，我整理了5张数据表以及对应的查询问题。针对这些查询问题，你可以了解到这些SQL该如何撰写。</p><h2><strong>数据表</strong></h2><ul>\n<li>客户信息表 customers</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/cd/45/cd58929f9e0c9b1cfcd4ca0812c0d245.jpg?wh=1790x1064\" alt=\"\"></p><ul>\n<li>保险产品表 insurance_products</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/a2/90/a2449943d03e3c430fbdcc275411a990.jpg?wh=1782x964\" alt=\"\"></p><ul>\n<li>保单表 policies</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/28/58/28eafe57eef59f8efa1334b018e25958.jpg?wh=1780x1184\" alt=\"\"></p><ul>\n<li>续保记录表 renewal_records</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/9b/f6/9b4247e0e84abd1267ff5e85yy908cf6.jpg?wh=1774x960\" alt=\"\"></p><p></p><ul>\n<li>续保提醒记录表 renewal_reminders</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/74/e4/74f440af660a378e6f15ac1f716a05e4.jpg?wh=1784x964\" alt=\"\"></p><h2><strong>问题设定</strong></h2><p>我从客户分析、产品分析、保单分析、续保分析、异常分析、提醒效果分析、交叉分析等维度设置了一些常见的查询问题。</p><h3><strong>1. 客户分析</strong></h3><ul>\n<li>查询购买保单数量最多的前10名客户及其保单数量</li>\n</ul><pre><code class=\"language-plain\">SELECT\n&nbsp;&nbsp;&nbsp;&nbsp;c.customer_id,\n&nbsp;&nbsp;&nbsp;&nbsp;c.name,\n&nbsp;&nbsp;&nbsp;&nbsp;c.phone,\n&nbsp;&nbsp;&nbsp;&nbsp;COUNT(p.policy_id) as policy_count\nFROM customers c\nJOIN policies p ON c.customer_id = p.customer_id\nGROUP BY c.customer_id, c.name, c.phone\nORDER BY policy_count DESC\nLIMIT 10;\n&nbsp;\n//&nbsp;说明：这里使用JOIN连接客户和保单表，GROUP BY按客户分组并统计保单数量\n</code></pre><!-- [[[read_end]]] --><ul>\n<li>统计每个年龄段的客户数量及平均保费</li>\n</ul><pre><code class=\"language-plain\">WITH customer_age AS (\n&nbsp; &nbsp; SELECT\n&nbsp; &nbsp; &nbsp; &nbsp; customer_id,\n&nbsp; &nbsp; &nbsp; &nbsp; FLOOR((YEAR(CURRENT_DATE) - YEAR(STR_TO_DATE(birth_date, '%Y-%m-%d')))/10)*10 as age_group\n&nbsp; &nbsp; FROM customers\n)\nSELECT\n&nbsp; &nbsp; ca.age_group as age_range,\n&nbsp; &nbsp; CONCAT(ca.age_group, '-', ca.age_group + 9) as age_range_display,\n&nbsp; &nbsp; COUNT(DISTINCT ca.customer_id) as customer_count,\n&nbsp; &nbsp; ROUND(AVG(p.premium_amount), 2) as avg_premium\nFROM customer_age ca\nJOIN policies p ON ca.customer_id = p.customer_id\nGROUP BY ca.age_group\nORDER BY ca.age_group;\n&nbsp;\n// 说明：WITH 关键字用于定义公用表表达式（Common Table Expressions，简称CTE），这是一种临时结果集，可以在查询中引用一次或多次。CTE 提高了查询的可读性和维护性，尤其是在复杂的查询中需要重复使用相同子查询的情况下。\n</code></pre><h3><strong>2. 产品分析</strong></h3><ul>\n<li>统计各类保险产品的销售份数和保费收入</li>\n</ul><pre><code class=\"language-plain\">SELECT\n&nbsp; &nbsp; ip.product_id,\n&nbsp; &nbsp; ip.product_name,\n&nbsp; &nbsp; ip.product_type,\n&nbsp; &nbsp; COUNT(p.policy_id) as sales_count,\n&nbsp; &nbsp; SUM(p.premium_amount) as total_premium\nFROM insurance_products ip\nLEFT JOIN policies p ON ip.product_id = p.product_id\nGROUP BY ip.product_id, ip.product_name, ip.product_type\nORDER BY total_premium DESC;\n&nbsp;\n// 说明：使用LEFT JOIN连接保险产品和保单表，确保包括所有保险产品，GROUP BY按产品分组统计销售份数和保费收入，ORDER BY按总保费降序排列。\n</code></pre><ul>\n<li>查询续保率最高的前5个产品</li>\n</ul><pre><code class=\"language-plain\">WITH renewal_stats AS (\n&nbsp; &nbsp; SELECT\n&nbsp; &nbsp; &nbsp; &nbsp; ip.product_id,\n&nbsp; &nbsp; &nbsp; &nbsp; ip.product_name,\n&nbsp; &nbsp; &nbsp; &nbsp; COUNT(DISTINCT p.policy_id) as total_policies,\n&nbsp; &nbsp; &nbsp; &nbsp; COUNT(DISTINCT CASE WHEN rr.renewal_status = '成功' THEN rr.renewal_id END) as successful_renewals\n&nbsp; &nbsp; FROM insurance_products ip\n&nbsp; &nbsp; JOIN policies p ON ip.product_id = p.product_id\n&nbsp; &nbsp; LEFT JOIN renewal_records rr ON p.policy_id = rr.policy_id\n&nbsp; &nbsp; GROUP BY ip.product_id, ip.product_name\n)\nSELECT\n&nbsp; &nbsp; product_id,\n&nbsp; &nbsp; product_name,\n&nbsp; &nbsp; total_policies,\n&nbsp; &nbsp; successful_renewals,\n&nbsp; &nbsp; ROUND(CAST(successful_renewals AS DECIMAL(10,2)) / NULLIF(total_policies, 0) * 100, 2) as renewal_rate\nFROM renewal_stats\nWHERE total_policies &gt; 0\nORDER BY renewal_rate DESC\nLIMIT 5;\n\n\n// 说明：CAST 和 NULLIF 是SQL中用于数据类型转换和条件表达式的两个函数。在这个查询中，它们一起用于确保续保率计算的准确性，并处理可能的除以零的异常。\n</code></pre><h3><strong>3. 保单分析</strong></h3><ul>\n<li>查询即将到期（30 天内）的保单清单</li>\n</ul><pre><code class=\"language-plain\">SELECT\n&nbsp; &nbsp; p.policy_id,\n&nbsp; &nbsp; p.policy_number,\n&nbsp; &nbsp; c.name as customer_name,\n&nbsp; &nbsp; c.phone,\n&nbsp; &nbsp; ip.product_name,\n&nbsp; &nbsp; p.end_date,\n&nbsp; &nbsp; p.premium_amount\nFROM policies p\nJOIN customers c ON p.customer_id = c.customer_id\nJOIN insurance_products ip ON p.product_id = ip.product_id\nWHERE p.status = '有效'\nAND STR_TO_DATE(p.end_date, '%Y-%m-%d')\n&nbsp; &nbsp; BETWEEN CURRENT_DATE AND DATE_ADD(CURRENT_DATE, INTERVAL 30 DAY)\nORDER BY p.end_date;\n&nbsp;\n// 说明：STR_TO_DATE、CURRENT_DATE 和 DATE_ADD 是SQL中用于日期处理的函数。在这个查询中用于筛选即将到期的保单。\n&nbsp;\nSTR_TO_DATE 函数用于将字符串按照指定的格式转换为日期类型。\n&nbsp;\nCURRENT_DATE 函数返回当前日期，不包含时间部分。它通常用于获取今天的日期，并且在不同的数据库系统中有类似的实现方式（例如，在MySQL中就是 CURRENT_DATE() 或 CURDATE()）。\n&nbsp;\nDATE_ADD 函数用于向日期添加一个时间间隔。\n</code></pre><ul>\n<li>分析保单状态分布</li>\n</ul><pre><code class=\"language-plain\">SELECT\n&nbsp; &nbsp; status,\n&nbsp; &nbsp; COUNT(*) as count,\n&nbsp; &nbsp; ROUND(CAST(COUNT(*) AS DECIMAL(10,2)) / SUM(COUNT(*)) OVER() * 100, 2) as percentage\nFROM policies\nGROUP BY status\nORDER BY count DESC;\n&nbsp;\n// 说明：使用GROUP BY按保单状态分组统计数量，通过窗口函数SUM OVER()计算总数，CAST转换数据类型并计算各状态的百分比，ORDER BY按数量降序排列。\n</code></pre><h3><strong>4. 续保分析</strong></h3><ul>\n<li>查询连续续保 3 次以上的客户</li>\n</ul><pre><code class=\"language-plain\">WITH consecutive_renewals AS (\n&nbsp; &nbsp; SELECT\n&nbsp; &nbsp; &nbsp; &nbsp; p.customer_id,\n&nbsp; &nbsp; &nbsp; &nbsp; COUNT(rr.renewal_id) as renewal_count\n&nbsp; &nbsp; FROM policies p\n&nbsp; &nbsp; JOIN renewal_records rr ON p.policy_id = rr.policy_id\n&nbsp; &nbsp; WHERE rr.renewal_status = '成功'\n&nbsp; &nbsp; GROUP BY p.customer_id\n&nbsp; &nbsp; HAVING COUNT(rr.renewal_id) &gt;= 3\n)\nSELECT\n&nbsp; &nbsp; c.customer_id,\n&nbsp; &nbsp; c.name,\n&nbsp; &nbsp; c.phone,\n&nbsp; &nbsp; cr.renewal_count\nFROM consecutive_renewals cr\nJOIN customers c ON cr.customer_id = c.customer_id\nORDER BY cr.renewal_count DESC;\n&nbsp;\n// 说明：这里使用CTE筛选出成功续保3次及以上的客户，通过GROUP BY和HAVING条件聚合续保记录，最后JOIN客户表获取详细信息并按续保次数排序。\n</code></pre><h3><strong>5. 异常分析</strong></h3><ul>\n<li>查询保费异常的保单（超过平均值 2 个标准差）</li>\n</ul><pre><code class=\"language-plain\">WITH premium_stats AS (\n&nbsp; &nbsp; SELECT\n&nbsp; &nbsp; &nbsp; &nbsp; AVG(premium_amount) as avg_premium,\n&nbsp; &nbsp; &nbsp; &nbsp; STDDEV(premium_amount) as stddev_premium\n&nbsp; &nbsp; FROM policies\n)\nSELECT\n&nbsp; &nbsp; p.policy_id,\n&nbsp; &nbsp; p.policy_number,\n&nbsp; &nbsp; c.name as customer_name,\n&nbsp; &nbsp; ip.product_name,\n&nbsp; &nbsp; p.premium_amount,\n&nbsp; &nbsp; ps.avg_premium,\n&nbsp; &nbsp; ps.stddev_premium\nFROM policies p\nJOIN customers c ON p.customer_id = c.customer_id\nJOIN insurance_products ip ON p.product_id = ip.product_id\nCROSS JOIN premium_stats ps\nWHERE p.premium_amount &gt; ps.avg_premium + (2 * ps.stddev_premium)\n&nbsp; &nbsp;OR p.premium_amount &lt; ps.avg_premium - (2 * ps.stddev_premium)\nORDER BY p.premium_amount DESC;\n&nbsp;\n// 说明：使用CTE计算保费的平均值和标准差，通过CROSS JOIN将统计结果应用到每条保单记录，筛选出保费超过平均值±2个标准差的异常保单。\n&nbsp;\nCROSS JOIN 是SQL中的一种连接类型，它返回两个表的笛卡尔积，即第一个表中的每一行与第二个表中的每一行组合。结果集中行的数量等于两个表行数的乘积。\n</code></pre><h3><strong>6. 提醒效果分析</strong></h3><ul>\n<li>统计不同提醒方式的效果（续保成功率）</li>\n</ul><pre><code class=\"language-plain\">WITH reminder_stats AS (\n&nbsp; &nbsp; SELECT\n&nbsp; &nbsp; &nbsp; &nbsp; rm.remind_method,\n&nbsp; &nbsp; &nbsp; &nbsp; COUNT(DISTINCT rm.policy_id) as total_reminders,\n&nbsp; &nbsp; &nbsp; &nbsp; COUNT(DISTINCT CASE WHEN rr.renewal_status = '成功' THEN rr.renewal_id END) as successful_renewals\n&nbsp; &nbsp; FROM renewal_reminders rm\n&nbsp; &nbsp; LEFT JOIN renewal_records rr ON rm.policy_id = rr.policy_id\n&nbsp; &nbsp; WHERE rm.remind_status = '成功'\n&nbsp; &nbsp; GROUP BY rm.remind_method\n)\nSELECT\n&nbsp; &nbsp; remind_method,\n&nbsp; &nbsp; total_reminders,\n&nbsp; &nbsp; successful_renewals,\n&nbsp; &nbsp; ROUND(CAST(successful_renewals AS DECIMAL(10,2)) / NULLIF(total_reminders, 0) * 100, 2) as success_rate\nFROM reminder_stats\nORDER BY success_rate DESC;\n&nbsp;\n// 说明：使用CTE统计每种提醒方式的总提醒数和成功续保数，通过GROUP BY分组，计算续保成功率并按成功率降序排列，确保分母不为零。\n</code></pre><ul>\n<li>分析提醒后一周内完成续保的比例</li>\n</ul><pre><code class=\"language-plain\">WITH reminder_conversion AS (\n&nbsp; &nbsp; SELECT\n&nbsp; &nbsp; &nbsp; &nbsp; COUNT(DISTINCT rr.renewal_id) as total_renewals,\n&nbsp; &nbsp; &nbsp; &nbsp; COUNT(DISTINCT CASE\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WHEN STR_TO_DATE(rr.renewal_date, '%Y-%m-%d') &lt;=\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DATE_ADD(STR_TO_DATE(rm.remind_time, '%Y-%m-%d %H:%i:%s'), INTERVAL 7 DAY)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AND rr.renewal_status = '成功'\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; THEN rr.renewal_id\n&nbsp; &nbsp; &nbsp; &nbsp; END) as converted_renewals\n&nbsp; &nbsp; FROM renewal_reminders rm\n&nbsp; &nbsp; LEFT JOIN renewal_records rr ON rm.policy_id = rr.policy_id\n&nbsp; &nbsp; WHERE rm.remind_status = '成功'\n)\nSELECT\n&nbsp; &nbsp; total_renewals,\n&nbsp; &nbsp; converted_renewals,\n&nbsp; &nbsp; ROUND(CAST(converted_renewals AS DECIMAL(10,2)) / NULLIF(total_renewals, 0) * 100, 2) as conversion_rate\nFROM reminder_conversion;\n&nbsp;\n// 说明：使用CTE统计提醒后一周内成功续保的数量，通过条件判断筛选符合条件的续保记录，计算转换率并确保分母不为零，最终输出总续保数、转换续保数及比率。\n</code></pre><h3><strong>7.&nbsp;交叉分析</strong></h3><ul>\n<li>分析客户年龄与产品选择的关系</li>\n</ul><pre><code class=\"language-plain\">WITH customer_age_group AS (\n&nbsp; &nbsp; SELECT\n&nbsp; &nbsp; &nbsp; &nbsp; customer_id,\n&nbsp; &nbsp; &nbsp; &nbsp; FLOOR((YEAR(CURRENT_DATE) - YEAR(STR_TO_DATE(birth_date, '%Y-%m-%d')))/10)*10 as age_group\n&nbsp; &nbsp; FROM customers\n)\nSELECT\n&nbsp; &nbsp; cag.age_group,\n&nbsp; &nbsp; CONCAT(cag.age_group, '-', cag.age_group + 9) as age_range,\n&nbsp; &nbsp; ip.product_type,\n&nbsp; &nbsp; COUNT(DISTINCT p.policy_id) as policy_count,\n&nbsp; &nbsp; ROUND(AVG(p.premium_amount), 2) as avg_premium\nFROM customer_age_group cag\nJOIN policies p ON cag.customer_id = p.customer_id\nJOIN insurance_products ip ON p.product_id = ip.product_id\nGROUP BY cag.age_group, ip.product_type\nORDER BY cag.age_group, policy_count DESC;\n&nbsp;\n// 说明：使用CTE计算客户年龄组，通过JOIN连接保单和产品表，按年龄组和产品类型分组统计保单数量及平均保费，ORDER BY按年龄组和保单数量排序展示结果。\n&nbsp;\nCONCAT(cag.age_group, '-', cag.age_group + 9) as age_range 这段代码使用了SQL的 CONCAT 函数来创建一个更具可读性的年龄范围字符串。\n</code></pre><p>如果你是保险行业的从业人员，这节课将对你非常有帮助。期待你的转发，我们下节课再见！</p>","comments":[]}