{"id":9788,"title":"第22讲 | AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？","content":"<p>在今天这一讲中，我来分析一下并发包内部的组成，一起来看看各种同步结构、线程池等，是基于什么原理来设计和实现的。</p><p>今天我要问你的问题是，<span class=\"orange\">AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？</span></p><h2>典型回答</h2><p>AtomicIntger是对int类型的一个封装，提供原子性的访问和更新操作，其原子性操作的实现是基于CAS（<a href=\"https://en.wikipedia.org/wiki/Compare-and-swap\">compare-and-swap</a>）技术。</p><p>所谓CAS，表征的是一系列操作的集合，获取当前数值，进行一些运算，利用CAS指令试图进行更新。如果当前数值未变，代表没有其他线程进行并发修改，则成功更新。否则，可能出现不同的选择，要么进行重试，要么就返回一个成功或者失败的结果。</p><p>从AtomicInteger的内部属性可以看出，它依赖于Unsafe提供的一些底层能力，进行底层操作；以volatile的value字段，记录数值，以保证可见性。</p><pre><code>private static final jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe();\nprivate static final long VALUE = U.objectFieldOffset(AtomicInteger.class, &quot;value&quot;);\nprivate volatile int value;\n</code></pre><p>具体的原子操作细节，可以参考任意一个原子更新方法，比如下面的getAndIncrement。</p><p>Unsafe会利用value字段的内存地址偏移，直接完成操作。</p><pre><code>public final int getAndIncrement() {\n    return U.getAndAddInt(this, VALUE, 1);\n}\n</code></pre><p>因为getAndIncrement需要返归数值，所以需要添加失败重试逻辑。</p><!-- [[[read_end]]] --><pre><code>public final int getAndAddInt(Object o, long offset, int delta) {\n    int v;\n    do {\n        v = getIntVolatile(o, offset);\n    } while (!weakCompareAndSetInt(o, offset, v, v + delta));\n    return v;\n}\n</code></pre><p>而类似compareAndSet这种返回boolean类型的函数，因为其返回值表现的就是成功与否，所以不需要重试。</p><pre><code>public final boolean compareAndSet(int expectedValue, int newValue)\n</code></pre><p>CAS是Java并发中所谓lock-free机制的基础。</p><h2>考点分析</h2><p>今天的问题有点偏向于Java并发机制的底层了，虽然我们在开发中未必会涉及CAS的实现层面，但是理解其机制，掌握如何在Java中运用该技术，还是十分有必要的，尤其是这也是个并发编程的面试热点。</p><p>有的同学反馈面试官会问CAS更加底层是如何实现的，这依赖于CPU提供的特定指令，具体根据体系结构的不同还存在着明显区别。比如，x86 CPU提供cmpxchg指令；而在精简指令集的体系架构中，则通常是靠一对儿指令（如“load and reserve”和“store conditional”）实现的，在大多数处理器上CAS都是个非常轻量级的操作，这也是其优势所在。</p><p>大部分情况下，掌握到这个程度也就够用了，我认为没有必要让每个Java工程师都去了解到指令级别，我们进行抽象、分工就是为了让不同层面的开发者在开发中，可以尽量屏蔽不相关的细节。</p><p>如果我作为面试官，很有可能深入考察这些方向：</p><ul>\n<li>\n<p>在什么场景下，可以采用CAS技术，调用Unsafe毕竟不是大多数场景的最好选择，有没有更加推荐的方式呢？毕竟我们掌握一个技术，cool不是目的，更不是为了应付面试，我们还是希望能在实际产品中有价值。</p>\n</li>\n<li>\n<p>对ReentrantLock、CyclicBarrier等并发结构底层的实现技术的理解。</p>\n</li>\n</ul><h2>知识扩展</h2><p>关于CAS的使用，你可以设想这样一个场景：在数据库产品中，为保证索引的一致性，一个常见的选择是，保证只有一个线程能够排他性地修改一个索引分区，如何在数据库抽象层面实现呢？</p><p>可以考虑为索引分区对象添加一个逻辑上的锁，例如，以当前独占的线程ID作为锁的数值，然后通过原子操作设置lock数值，来实现加锁和释放锁，伪代码如下：</p><pre><code>public class AtomicBTreePartition {\nprivate volatile long lock;\npublic void acquireLock(){}\npublic void releaseeLock(){}\n}\n</code></pre><p>那么在Java代码中，我们怎么实现锁操作呢？Unsafe似乎不是个好的选择，例如，我就注意到类似Cassandra等产品，因为Java 9中移除了Unsafe.moniterEnter()/moniterExit()，导致无法平滑升级到新的JDK版本。目前Java提供了两种公共API，可以实现这种CAS操作，比如使用java.util.concurrent.atomic.AtomicLongFieldUpdater，它是基于反射机制创建，我们需要保证类型和字段名称正确。</p><pre><code>private static final AtomicLongFieldUpdater&lt;AtomicBTreePartition&gt; lockFieldUpdater =\n        AtomicLongFieldUpdater.newUpdater(AtomicBTreePartition.class, &quot;lock&quot;);\n\nprivate void acquireLock(){\n    long t = Thread.currentThread().getId();\n    while (!lockFieldUpdater.compareAndSet(this, 0L, t)){\n        // 等待一会儿，数据库操作可能比较慢\n         …\n    }\n}\n</code></pre><p><a href=\"https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/atomic/package-summary.html\">Atomic包</a>提供了最常用的原子性数据类型，甚至是引用、数组等相关原子类型和更新操作工具，是很多线程安全程序的首选。</p><p>我在专栏第七讲中曾介绍使用原子数据类型和Atomic*FieldUpdater，创建更加紧凑的计数器实现，以替代AtomicLong。优化永远是针对特定需求、特定目的，我这里的侧重点是介绍可能的思路，具体还是要看需求。如果仅仅创建一两个对象，其实完全没有必要进行前面的优化，但是如果对象成千上万或者更多，就要考虑紧凑性的影响了。而atomic包提供的<a href=\"https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/atomic/LongAdder.html\">LongAdder</a>，在高度竞争环境下，可能就是比AtomicLong更佳的选择，尽管它的本质是空间换时间。</p><p>回归正题，如果是Java 9以后，我们完全可以采用另外一种方式实现，也就是Variable Handle API，这是源自于<a href=\"http://openjdk.java.net/jeps/193\">JEP 193</a>，提供了各种粒度的原子或者有序性的操作等。我将前面的代码修改为如下实现：</p><pre><code>private static final VarHandle HANDLE = MethodHandles.lookup().findStaticVarHandle\n        (AtomicBTreePartition.class, &quot;lock&quot;);\n\nprivate void acquireLock(){\n    long t = Thread.currentThread().getId();\n    while (!HANDLE.compareAndSet(this, 0L, t)){\n        // 等待一会儿，数据库操作可能比较慢\n        …\n    }\n}\n</code></pre><p>过程非常直观，首先，获取相应的变量句柄，然后直接调用其提供的CAS方法。</p><p>一般来说，我们进行的类似CAS操作，可以并且推荐使用Variable Handle API去实现，其提供了精细粒度的公共底层API。我这里强调公共，是因为其API不会像内部API那样，发生不可预测的修改，这一点提供了对于未来产品维护和升级的基础保障，坦白说，很多额外工作量，都是源于我们使用了Hack而非Solution的方式解决问题。</p><p>CAS也并不是没有副作用，试想，其常用的失败重试机制，隐含着一个假设，即竞争情况是短暂的。大多数应用场景中，确实大部分重试只会发生一次就获得了成功，但是总是有意外情况，所以在有需要的时候，还是要考虑限制自旋的次数，以免过度消耗CPU。</p><p>另外一个就是著名的<a href=\"https://en.wikipedia.org/wiki/ABA_problem\">ABA</a>问题，这是通常只在lock-free算法下暴露的问题。我前面说过CAS是在更新时比较前值，如果对方只是恰好相同，例如期间发生了 A -&gt; B -&gt; A的更新，仅仅判断数值是A，可能导致不合理的修改操作。针对这种情况，Java提供了AtomicStampedReference工具类，通过为引用建立类似版本号（stamp）的方式，来保证CAS的正确性，具体用法请参考这里的<a href=\"http://tutorials.jenkov.com/java-util-concurrent/atomicstampedreference.html\">介绍</a>。</p><p>前面介绍了CAS的场景与实现，幸运的是，大多数情况下，Java开发者并不需要直接利用CAS代码去实现线程安全容器等，更多是通过并发包等间接享受到lock-free机制在扩展性上的好处。</p><p>下面我来介绍一下AbstractQueuedSynchronizer（AQS），其是Java并发包中，实现各种同步结构和部分其他组成单元（如线程池中的Worker）的基础。</p><p>学习AQS，如果上来就去看它的一系列方法（下图所示），很有可能把自己看晕，这种似懂非懂的状态也没有太大的实践意义。</p><p><img src=\"https://static001.geekbang.org/resource/image/e3/36/e3b4b7fe5a94a88ca2feb04d734b9c36.png?wh=1062*424\" alt=\"\"></p><p>我建议的思路是，尽量简化一下，理解为什么需要AQS，如何使用AQS，<strong>至少</strong>要做什么，再进一步结合JDK源代码中的实践，理解AQS的原理与应用。</p><p><a href=\"https://en.wikipedia.org/wiki/Doug_Lea\">Doug Lea</a>曾经介绍过AQS的设计初衷。从原理上，一种同步结构往往是可以利用其他的结构实现的，例如我在专栏第19讲中提到过可以使用Semaphore实现互斥锁。但是，对某种同步结构的倾向，会导致复杂、晦涩的实现逻辑，所以，他选择了将基础的同步相关操作抽象在AbstractQueuedSynchronizer中，利用AQS为我们构建同步结构提供了范本。</p><p>AQS内部数据和方法，可以简单拆分为：</p><ul>\n<li>一个volatile的整数成员表征状态，同时提供了setState和getState方法</li>\n</ul><pre><code>private volatile int state;\n</code></pre><ul>\n<li>\n<p>一个先入先出（FIFO）的等待线程队列，以实现多线程间竞争和等待，这是AQS机制的核心之一。</p>\n</li>\n<li>\n<p>各种基于CAS的基础操作方法，以及各种期望具体同步结构去实现的acquire/release方法。</p>\n</li>\n</ul><p>利用AQS实现一个同步结构，至少要实现两个基本类型的方法，分别是acquire操作，获取资源的独占权；还有就是release操作，释放对某个资源的独占。</p><p>以ReentrantLock为例，它内部通过扩展AQS实现了Sync类型，以AQS的state来反映锁的持有情况。</p><pre><code>private final Sync sync;\nabstract static class Sync extends AbstractQueuedSynchronizer { …}\n</code></pre><p>下面是ReentrantLock对应acquire和release操作，如果是CountDownLatch则可以看作是await()/countDown()，具体实现也有区别。</p><pre><code>public void lock() {\n    sync.acquire(1);\n}\npublic void unlock() {\n    sync.release(1);\n}\n\n</code></pre><p>排除掉一些细节，整体地分析acquire方法逻辑，其直接实现是在AQS内部，调用了tryAcquire和acquireQueued，这是两个需要搞清楚的基本部分。</p><pre><code>public final void acquire(int arg) {\n    if (!tryAcquire(arg) &amp;&amp;\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n</code></pre><p>首先，我们来看看tryAcquire。在ReentrantLock中，tryAcquire逻辑实现在NonfairSync和FairSync中，分别提供了进一步的非公平或公平性方法，而AQS内部tryAcquire仅仅是个接近未实现的方法（直接抛异常），这是留个实现者自己定义的操作。</p><p>我们可以看到公平性在ReentrantLock构建时如何指定的，具体如下：</p><pre><code>public ReentrantLock() {\n        sync = new NonfairSync(); // 默认是非公平的\n    }\n    public ReentrantLock(boolean fair) {\n        sync = fair ? new FairSync() : new NonfairSync();\n    }\n\n</code></pre><p>以非公平的tryAcquire为例，其内部实现了如何配合状态与CAS获取锁，注意，对比公平版本的tryAcquire，它在锁无人占有时，并不检查是否有其他等待者，这里体现了非公平的语义。</p><pre><code>final boolean nonfairTryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();// 获取当前AQS内部状态量\n    if (c == 0) { // 0表示无人占有，则直接用CAS修改状态位，\n    \tif (compareAndSetState(0, acquires)) {// 不检查排队情况，直接争抢\n        \tsetExclusiveOwnerThread(current);  //并设置当前线程独占锁\n        \treturn true;\n    \t}\n    } else if (current == getExclusiveOwnerThread()) { //即使状态不是0，也可能当前线程是锁持有者，因为这是再入锁\n    \tint nextc = c + acquires;\n    \tif (nextc &lt; 0) // overflow\n        \tthrow new Error(&quot;Maximum lock count exceeded&quot;);\n    \tsetState(nextc);\n    \treturn true;\n\t}\n\treturn false;\n}\n</code></pre><p>接下来我再来分析acquireQueued，如果前面的tryAcquire失败，代表着锁争抢失败，进入排队竞争阶段。这里就是我们所说的，利用FIFO队列，实现线程间对锁的竞争的部分，算是是AQS的核心逻辑。</p><p>当前线程会被包装成为一个排他模式的节点（EXCLUSIVE），通过addWaiter方法添加到队列中。acquireQueued的逻辑，简要来说，就是如果当前节点的前面是头节点，则试图获取锁，一切顺利则成为新的头节点；否则，有必要则等待，具体处理逻辑请参考我添加的注释。</p><pre><code>final boolean acquireQueued(final Node node, int arg) {\n      boolean interrupted = false;\n      try {\n    \tfor (;;) {// 循环\n        \tfinal Node p = node.predecessor();// 获取前一个节点\n        \tif (p == head &amp;&amp; tryAcquire(arg)) { // 如果前一个节点是头结点，表示当前节点合适去tryAcquire\n            \tsetHead(node); // acquire成功，则设置新的头节点\n            \tp.next = null; // 将前面节点对当前节点的引用清空\n            \treturn interrupted;\n        \t}\n        \tif (shouldParkAfterFailedAcquire(p, node)) // 检查是否失败后需要park\n            \tinterrupted |= parkAndCheckInterrupt();\n    \t}\n       } catch (Throwable t) {\n    \tcancelAcquire(node);// 出现异常，取消\n    \tif (interrupted)\n        \t    selfInterrupt();\n    \tthrow t;\n      }\n}\n</code></pre><p>到这里线程试图获取锁的过程基本展现出来了，tryAcquire是按照特定场景需要开发者去实现的部分，而线程间竞争则是AQS通过Waiter队列与acquireQueued提供的，在release方法中，同样会对队列进行对应操作。</p><p>今天我介绍了Atomic数据类型的底层技术CAS，并通过实例演示了如何在产品代码中利用CAS，最后介绍了并发包的基础技术AQS，希望对你有所帮助。</p><h2>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？今天布置一个源码阅读作业，AQS中Node的waitStatus有什么作用？</p><p>请你在留言区写写你对这个问题的思考，我会选出经过认真思考的留言，送给你一份学习奖励礼券，欢迎你与我一起讨论。</p><p>你的朋友是不是也在准备面试呢？你可以“请朋友读”，把今天的题目分享给好友，或许你能帮到他。</p>","neighbors":{"left":{"article_title":"第21讲 | Java并发类库提供的线程池有哪几种？ 分别有什么特点？","id":9712},"right":{"article_title":"第23讲 | 请介绍类加载过程，什么是双亲委派模型？","id":9946}},"comments":[{"had_liked":false,"id":13762,"user_name":"xuanyuan","can_delete":false,"product_type":"c1","uid":1113737,"ip_address":"","ucode":"1EC79B9372868F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2icbib62icXtibTkThtyRksbuJLoTLMts7zook2S30MiaBtbz0f5JskwYicwqXkhpYfvCpuYkcvPTibEaQ/132","comment_is_top":false,"comment_ctime":1529975913,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"641480103017","product_id":100006701,"comment_content":"建议；<br><br>1. 希望能有推外内存的主题，范型部分希望能与cpp比较讲解。<br>2. 一些主题如果已经有公开的比较好的资料，可以提供链接，对重点强调即可。希望能看到更多公开资料所没有的信息，这也是老鸟们付费的初衷。<br>同意的点赞","like_count":149,"discussions":[{"author":{"id":1144504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/b8/e4cd7997.jpg","nickname":"KAGEMUSHA","note":"","ucode":"DFC05BE62A9C10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305386,"discussion_content":"全关注老鸟了，还搁那&#34;与cpp比较讲解&#34;、&#34;更多公开资料所没有的信息&#34;、&#34;蜻蜓点水&#34;呢？？学习不够深入的到这看得都放弃了劝退多少。有多少人是过了很久靠自学明白了之后再来重新来反复看好几遍才搞懂的？老鸟们想看虚拟机可以订阅隔壁当初和这个一起看讲的深入虚拟机专栏啊，不可能什么水平不同层次的需求都同时满足。反正这个专栏的课程能且也就也只能对得起自身几十块的价格了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1599904925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1115128,"avatar":"https://static001.geekbang.org/account/avatar/00/11/03/f8/f98df0a7.jpg","nickname":"vaccywen","note":"","ucode":"077FDB50831921","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":47600,"discussion_content":"和我的想法一样，但是估计不会讲这些，不然这本书的名字就该叫《JVM底层技术》","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1573378037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1680042,"avatar":"https://static001.geekbang.org/account/avatar/00/19/a2/aa/a6a64c32.jpg","nickname":"肉君","note":"","ucode":"F64D7625E0F6F5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":272631,"discussion_content":"这门课的风格就是蜻蜓点水、浅尝辄止，很多时候感觉作者就是只想抛砖引玉，更多时候觉得评论比正文精彩，然而后面章节的评论也越来越少。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590329614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2286307,"avatar":"","nickname":"Geek_a25586","note":"","ucode":"3C3E949B0E0243","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1680042,"avatar":"https://static001.geekbang.org/account/avatar/00/19/a2/aa/a6a64c32.jpg","nickname":"肉君","note":"","ucode":"F64D7625E0F6F5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":322086,"discussion_content":"痛点就是基础薄看完一脸懵基础够看完发现都是公开资料，又感觉没啥劲，定位不准，到底是给什么段位的人看的没找准。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1604672881,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":272631,"ip_address":""},"score":322086,"extra":""},{"author":{"id":1324314,"avatar":"https://static001.geekbang.org/account/avatar/00/14/35/1a/9fa38dc9.jpg","nickname":"子瞻","note":"","ucode":"5C26FF10934534","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2286307,"avatar":"","nickname":"Geek_a25586","note":"","ucode":"3C3E949B0E0243","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351428,"discussion_content":"同感","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614264423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":322086,"ip_address":""},"score":351428,"extra":""}]}]},{"had_liked":false,"id":19003,"user_name":"ipofss","can_delete":false,"product_type":"c1","uid":1018620,"ip_address":"","ucode":"DE3061C9259F9E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/fc/d1dd57dd.jpg","comment_is_top":false,"comment_ctime":1533638617,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"164742395865","product_id":100006701,"comment_content":"这一讲对于我来说，挺有难度的，还是基础比较薄弱，整体上没太听懂。老师对于Java的理解真是太深入了，等我以后技术精进了，再回来看看老师的36讲，应该会有新的认识。继续往下听吧，已经懂点的加深理解，没听过的就当是听了名字以后用到了再仔细研究","like_count":38,"discussions":[{"author":{"id":1144504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/b8/e4cd7997.jpg","nickname":"KAGEMUSHA","note":"","ucode":"DFC05BE62A9C10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305398,"discussion_content":"这个专栏就是讲的很晦涩比如这个文章里面的“我们怎么实现锁操作呢？......可以并且推荐使用 Variable Handle API 去实现..”那段理解起来很是费劲儿，要有一定程度上掌握相关内容才能明白咋回事。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1599909021,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2283781,"avatar":"https://static001.geekbang.org/account/avatar/00/22/d9/05/0d772dbf.jpg","nickname":"咦","note":"","ucode":"2E0D5A488489A4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551874,"discussion_content":"校招基础吧，差不多","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645160270,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1640349,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJgkiapuSqHlc6criaA8o4GtjCqiaREptvHcLcExFciaV1X2avib4EFoIq3SYA99nDgFERj8ZalgJjibzrA/132","nickname":"薛国治","note":"","ucode":"592627A673DDFA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327993,"discussion_content":"还是要有点基础的，然后给你串一下。我也是复习了很多其他的资料再来看的，感觉讲的不错...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606038046,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1144504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/b8/e4cd7997.jpg","nickname":"KAGEMUSHA","note":"","ucode":"DFC05BE62A9C10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305399,"discussion_content":"感觉像在猜谜语������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599909025,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":13771,"user_name":"I.am DZX","can_delete":false,"product_type":"c1","uid":1122095,"ip_address":"","ucode":"DBE2B7A50C423A","user_header":"https://static001.geekbang.org/account/avatar/00/11/1f/2f/e35d6a1d.jpg","comment_is_top":false,"comment_ctime":1529978166,"is_pvip":false,"replies":[{"id":"4649","content":"好","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1530117401,"ip_address":"","comment_id":13771,"utype":1}],"discussion_count":1,"race_medal":0,"score":"117494095158","product_id":100006701,"comment_content":"CANCELLED 1 因为超时或中断设置为此状态，标志节点不可用<br>SIGNAL -1 处于此状态的节点释放资源时会唤醒后面的节点<br>CONDITION -2 处于条件队列里，等待条件成立(signal signalall) 条件成立后会置入获取资源的队列里<br>PROPAGATE -3 共享模式下使用，头节点获取资源时将后面节点设置为此状态，如果头节点获取资源后还有足够的资源，则后面节点会尝试获取，这个状态主要是为了共享状态下队列里足够多的节点同时获取资源<br>0 初始状态","like_count":28,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419749,"discussion_content":"好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530117401,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":13818,"user_name":"Cui","can_delete":false,"product_type":"c1","uid":1106775,"ip_address":"","ucode":"169F6EEEEE7E5E","user_header":"https://static001.geekbang.org/account/avatar/00/10/e3/57/e5de0216.jpg","comment_is_top":false,"comment_ctime":1530000866,"is_pvip":false,"replies":[{"id":"4646","content":"Locksupport的实现据说速度快，我也没具体对比过；不过jdk9里，monitor相关操作也加快了，可以看看jep143","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1530116979,"ip_address":"","comment_id":13818,"utype":1}],"discussion_count":6,"race_medal":1,"score":"78839412194","product_id":100006701,"comment_content":"老师，看了AQS的实现原理后，我再回顾了您之前关于synchronized的文章，心中有些疑问：<br>1、synchronized在JVM中是会进行锁升级和降级的，并且是基于CAS来掌握竞争的情况，在竞争不多的情况下利用CAS的轻量级操作来减少开销。<br>2、而AQS也是基于CAS操作队列的，位于队列头的节点优先获得锁，其他的节点会被LockSupport.park()起来（这个好像依赖的是操作系统的互斥锁，应该也是个重量级操作）。<br>我觉得这两种方式都是基于CAS操作的，只是操作的对象不同（一个是Mark Word，一个是队列节点），当竞争较多时，还是不可避免地会使用到操作系统的互斥锁。然而，我再测试这两者的性能时，在无竞争的情况下，两者性能相当，但是，当竞争起来后，AQS的性能明显比synchronized要好（测试案例是8个线程并发对一个int递增，每个线程递增1000万次，AQS的耗时大概要少30%），这是为什么呢？","like_count":18,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419768,"discussion_content":"Locksupport的实现据说速度快，我也没具体对比过；不过jdk9里，monitor相关操作也加快了，可以看看jep143","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530116979,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2052476,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Qq6oLfOTgKzjiculoUDicdv7WoY1iabPfOTumibWeInVP2Mnod9XVPrNSClvIiaLbvtDlIjRnWUNaXcYwREGzlcaDog/132","nickname":"Geek_在下蟑螂王","note":"","ucode":"E1F5BBB5BC5962","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290929,"discussion_content":"噢？synchronized是基于cas的。😰😰😰😰😰😰","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594644759,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1442705,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/FmjAcibbIH7AH7Zwy5RZg6BMsjWTib8iaY6VhY7ibouZWWhpMX3RoJicgeiapUdK2iaSbatQYZFU3PdUPGjl5TqJnxTnQ/132","nickname":"蓝伽图","note":"","ucode":"F2FBCE654E95B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":274956,"discussion_content":"我认知的是锁只能升级，不能降级，偏向锁-> 轻量级锁 -> 重量级锁   还望指出锁降级的知识","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590636908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1442705,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/FmjAcibbIH7AH7Zwy5RZg6BMsjWTib8iaY6VhY7ibouZWWhpMX3RoJicgeiapUdK2iaSbatQYZFU3PdUPGjl5TqJnxTnQ/132","nickname":"蓝伽图","note":"","ucode":"F2FBCE654E95B4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385087,"discussion_content":"16讲有说到：锁降级确实是会发生的，当 JVM 进入安全点（SafePoint）的时候，会检查是否有闲置的 Monitor，然后试图进行降级","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626876449,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":274956,"ip_address":""},"score":385087,"extra":""}]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217735,"discussion_content":"cas的基础技术 unsafe是用户态直接使用特殊的cpu指令操作的，没有 synchronized重量级锁的用户态、内核态切换，所以 竞争出现时，会有明显差别。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585578484,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2029976,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f9/98/53740221.jpg","nickname":"齐大柱","note":"","ucode":"694BBCA988C1DE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292370,"discussion_content":"题主比较的是park操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595207397,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":217735,"ip_address":""},"score":292370,"extra":""}]}]},{"had_liked":false,"id":16042,"user_name":"OneThin","can_delete":false,"product_type":"c1","uid":1050458,"ip_address":"","ucode":"506989C201402F","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/5a/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1531751035,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"65956260475","product_id":100006701,"comment_content":"能否出一节讲一下unsafe，感觉这个才是最基础的。另外unsafe为什么叫unsafe呢","like_count":16,"discussions":[{"author":{"id":1040495,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e0/6f/c0a17a5b.jpg","nickname":"ShawDa","note":"","ucode":"DFA4242EB39A4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291628,"discussion_content":"Java魔法类：Unsafe应用解析（https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html）","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1594891850,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121459,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1c/b3/6d10ba4f.jpg","nickname":"Running Man","note":"","ucode":"4DD2F6AF71327E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":186600,"discussion_content":"因为这样你才觉得不安全所以不用了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582697391,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2052476,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Qq6oLfOTgKzjiculoUDicdv7WoY1iabPfOTumibWeInVP2Mnod9XVPrNSClvIiaLbvtDlIjRnWUNaXcYwREGzlcaDog/132","nickname":"Geek_在下蟑螂王","note":"","ucode":"E1F5BBB5BC5962","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336219,"discussion_content":"从名字吓住你别动里头的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608531740,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":13795,"user_name":"三口先生","can_delete":false,"product_type":"c1","uid":1117257,"ip_address":"","ucode":"8E8672321FE510","user_header":"https://static001.geekbang.org/account/avatar/00/11/0c/49/d71e939d.jpg","comment_is_top":false,"comment_ctime":1529984351,"is_pvip":false,"replies":[{"id":"4648","content":"不错","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1530117357,"ip_address":"","comment_id":13795,"utype":1}],"discussion_count":1,"race_medal":0,"score":"65954493791","product_id":100006701,"comment_content":"大于0取消状态，小于0有效状态，表示等待状态四种cancelled，signal，condition，propagate","like_count":15,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419758,"discussion_content":"不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530117357,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":279079,"user_name":"^_^","can_delete":false,"product_type":"c1","uid":2021212,"ip_address":"","ucode":"301EE75D170771","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/MdmRMTV2IwvQZF2IO0G0CFWbKxT9CIibmcdicS3J4SmrA4P1e36jCwyXZpia06ItwP4GibGnCrPJHicBbd5y9libTpiaA/132","comment_is_top":false,"comment_ctime":1613610465,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"31678381537","product_id":100006701,"comment_content":"要讲AQS的话，这点篇幅远远不够。推荐b站寒食君AQS的讲解，很详细。","like_count":8,"discussions":[{"author":{"id":1637626,"avatar":"https://static001.geekbang.org/account/avatar/00/18/fc/fa/4608b70a.jpg","nickname":"yven","note":"","ucode":"72CA71F9A44AE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578762,"discussion_content":"看过，表示不知道在讲些什么东西，流水账式的讲讲源码罢了，还一堆错误。个人推荐可以看看美团技术团队的那篇&lt;从ReentrantLock的实现看AQS的原理及应用&gt;","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1657000574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":14039,"user_name":"二木🐶","can_delete":false,"product_type":"c1","uid":1122361,"ip_address":"","ucode":"F2A88485ADBA6D","user_header":"https://static001.geekbang.org/account/avatar/00/11/20/39/3168c4ca.jpg","comment_is_top":false,"comment_ctime":1530149995,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"31594921067","product_id":100006701,"comment_content":"一直很好奇，为何CAS指令在发现内容未变的时候就能判断没有其他线程修改呢？可能被修改后的值与比较的值一样呀","like_count":7,"discussions":[{"author":{"id":2052476,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Qq6oLfOTgKzjiculoUDicdv7WoY1iabPfOTumibWeInVP2Mnod9XVPrNSClvIiaLbvtDlIjRnWUNaXcYwREGzlcaDog/132","nickname":"Geek_在下蟑螂王","note":"","ucode":"E1F5BBB5BC5962","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290930,"discussion_content":"你这不就是经典的aba问题么。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1594644826,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2289255,"avatar":"https://static001.geekbang.org/account/avatar/00/22/ee/67/e97fea7d.jpg","nickname":"[ThumbsUp]","note":"","ucode":"428818387DE5F7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325757,"discussion_content":"CAS指令并不能进行上述判断啊...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605426250,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1320592,"avatar":"https://static001.geekbang.org/account/avatar/00/14/26/90/f68608f3.jpg","nickname":"gwl","note":"","ucode":"24F334E9AC0313","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":168182,"discussion_content":"加了版本","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581559993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":14987,"user_name":"卡斯瓦德","can_delete":false,"product_type":"c1","uid":1011332,"ip_address":"","ucode":"E944E5BC507D5C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6e/84/45a909a6.jpg","comment_is_top":false,"comment_ctime":1530786249,"is_pvip":false,"replies":[{"id":"5076","content":"也许，这个我不知道具体原因，看上去while会比for多一个变量","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1530893692,"ip_address":"","comment_id":14987,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23005622729","product_id":100006701,"comment_content":"老师请教个问题，acquireQueued的源代码中，使用for（；；）做了个自旋锁吧，作者为什么不用while（true），这种方式呢，是因为开销不一样吗？","like_count":5,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420202,"discussion_content":"也许，这个我不知道具体原因，看上去while会比for多一个变量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530893692,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1075038,"avatar":"https://static001.geekbang.org/account/avatar/00/10/67/5e/e0323566.jpg","nickname":"oyt","note":"","ucode":"E1E4F27FB3535F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392800,"discussion_content":"java中没有区别，仅仅是编程习惯的问题，在java中二者生成的字节码是一样的。java源码中基本上是for(;;)的写法，个人猜测是大佬们都是会c或c++的，在这些语言的一些版本中for可能会比while true少一些指令，也可能仅仅是习惯了这种写法。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1631145060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79979,"user_name":"Geek_987169","can_delete":false,"product_type":"c1","uid":1180853,"ip_address":"","ucode":"4B2955A044805D","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/b5/8bc4790b.jpg","comment_is_top":false,"comment_ctime":1553587119,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14438489007","product_id":100006701,"comment_content":"老师，您说的&quot;更加紧凑&quot;，是什么意思？不太理解","like_count":3},{"had_liked":false,"id":14077,"user_name":"黄明恩","can_delete":false,"product_type":"c1","uid":1119409,"ip_address":"","ucode":"EF75C8BFA14D17","user_header":"https://static001.geekbang.org/account/avatar/00/11/14/b1/7d974f0a.jpg","comment_is_top":false,"comment_ctime":1530167885,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14415069773","product_id":100006701,"comment_content":"老师可否分析下Object.wait和notify的原理","like_count":3},{"had_liked":false,"id":13745,"user_name":"TonyEasy","can_delete":false,"product_type":"c1","uid":1115635,"ip_address":"","ucode":"CB455BA8915B64","user_header":"https://static001.geekbang.org/account/avatar/00/11/05/f3/4dd9e515.jpg","comment_is_top":false,"comment_ctime":1529974013,"is_pvip":false,"replies":[{"id":"4650","content":"大家基础不一样，以后被问到不生疏也好；关于路线，不知道你的兴趣和规划是什么，通常来说Java只是技能树中的一项，项目经验，领域知识，综合起来才能要到高价","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1530117818,"ip_address":"","comment_id":13745,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14414875901","product_id":100006701,"comment_content":"老师，说实话这一期的对我来说有点难度了，钦佩老师对知识理解的深入，请问老师可以指点下java学习的路线图吗，或者您分享下您自己的学习路线。","like_count":3,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419740,"discussion_content":"大家基础不一样，以后被问到不生疏也好；关于路线，不知道你的兴趣和规划是什么，通常来说Java只是技能树中的一项，项目经验，领域知识，综合起来才能要到高价","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530117818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170428,"user_name":"天王","can_delete":false,"product_type":"c1","uid":1239337,"ip_address":"","ucode":"C074B2F9A5F007","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/29/629d9bb0.jpg","comment_is_top":false,"comment_ctime":1578614165,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10168548757","product_id":100006701,"comment_content":"22 AutomicInteger原理是什么，cas原理，cas操作怎么应用 1 Automic提供了对int类型的原子操作和更新，操作基于cas原理，cas全称Compare and Swap， cas的原理是操作前试图获取当前值，在操作时，看值是否改变，如果未改变，代表没有其他线程同步修改，操作成功，已经改变，返回操作失败或者重试。有2个属性 jdk.internal.misc.Unsafe u＝idk.internal.misc.Unsafe.getUnsafe(); volatile int value;Long VALUE＝U.objectFiledOffset(AutomicInter.Class,&quot;value&quot;); Unsafe会利用value字段的内存地址偏移完成操作 2 cas底层实现 依赖于CPU底层提供的指令，java提供了2个公共api支持cas操作，long tid＝Thread.currenThread().getId(); AutomicFiledUpdator.compareAndSet(this,0l,tid);Automic包提供了很多原子处理类，是很多原子操作的选择，java.9以后提供了 Variable Hand Api， private static final VarHandle handle 首先获取句柄，再调用cas方法，推荐使用Variable Handle Api，后续维护有保障，3 AQS AbstractQueueSynchronized 是实现各种同步结构的基础","like_count":2},{"had_liked":false,"id":13769,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1529977647,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10119912239","product_id":100006701,"comment_content":"最近遇到配置tomcat连接池，导致cpu过高问题，最后发现配置连接池数过大导致上下文切换次数过多<br>，也就是线程池中任务数过少，空闲的线程过多，我想问为什么会导致上下文切换过多？","like_count":2},{"had_liked":false,"id":216350,"user_name":"Maxonor Love Muz 🎈","can_delete":false,"product_type":"c1","uid":1131284,"ip_address":"","ucode":"C4648DCEBB5581","user_header":"https://static001.geekbang.org/account/avatar/00/11/43/14/8e2b48fb.jpg","comment_is_top":false,"comment_ctime":1589245689,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5884212985","product_id":100006701,"comment_content":"老师把原理讲的差不多了，不过光看原理就以为自己会了，那是浅层次的理解。 有必要 把AQS源码走一遍","like_count":1},{"had_liked":false,"id":192703,"user_name":"护爽使者","can_delete":false,"product_type":"c1","uid":1275464,"ip_address":"","ucode":"12DC35DD74671C","user_header":"https://static001.geekbang.org/account/avatar/00/13/76/48/5ab89daa.jpg","comment_is_top":false,"comment_ctime":1584868953,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879836249","product_id":100006701,"comment_content":"cas  是乐观锁，while 循环","like_count":1},{"had_liked":false,"id":192197,"user_name":"今天","can_delete":false,"product_type":"c1","uid":1532354,"ip_address":"","ucode":"F8577A2BABCD1F","user_header":"https://static001.geekbang.org/account/avatar/00/17/61/c2/94c1d4c9.jpg","comment_is_top":false,"comment_ctime":1584842839,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879810135","product_id":100006701,"comment_content":"听起来还是很有难度的，我基础有点差","like_count":1},{"had_liked":false,"id":15291,"user_name":"七个猪","can_delete":false,"product_type":"c1","uid":1018003,"ip_address":"","ucode":"48F59BFA54D294","user_header":"https://static001.geekbang.org/account/avatar/00/0f/88/93/26076028.jpg","comment_is_top":false,"comment_ctime":1531096531,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5826063827","product_id":100006701,"comment_content":"CAS有部分实现是解决ABA问题，可以讲一下ABA问题是如何解决的，除了version外，还有没有其他的方式","like_count":1},{"had_liked":false,"id":14007,"user_name":"爱新觉罗老流氓","can_delete":false,"product_type":"c1","uid":1005661,"ip_address":"","ucode":"B13AC4DA358C15","user_header":"https://static001.geekbang.org/account/avatar/00/0f/58/5d/8de7f8dc.jpg","comment_is_top":false,"comment_ctime":1530114799,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5825082095","product_id":100006701,"comment_content":"ReentrantLock的非公平锁，其实只有一次非公平的机会！那一次就是在lock方法中，非公平锁的实现有if else分支，在if时就进行一次cas state，成功的线程去执行任务代码去了。那么失败的线程就会进入else逻辑，就是AQS#acquired，从这里开始非公平锁和公平锁就完全一样了，只是公平锁被欺负了一次，它的lock方法是直接调acquired方法。<br><br>为什么只有这一次呢？先看AQS#acquired，第一个逻辑是tryAcquired，公平锁和非公平锁实现略有区别。但记住，在这个时刻下，即使你看到公平锁trtAcquired实现中多一个hasQueuedPredecessors判断，无关紧要，重要的是这个时刻，还没有执行后面的addWaiter逻辑，根本没有入队，那么公平锁进入这个hasXXX方法，当然也是马上出来，执行后面的cas state，跟非公平锁没有不同...<br><br>如果，AQS#acquired的第一个tryAcquired失败了，都会进入acquiredQueued，此方法中有个强制的逻辑，就是无限for循环中的 final Node p = node.predecessors(); 在这个逻辑下，非平锁锁也要乖乖排队......<br><br>以上只是分析了lock方法，带超时的tryLock方法还没有具体看代码。如果我的lock分析有误，欢迎指出批评！","like_count":1,"discussions":[{"author":{"id":1118847,"avatar":"https://static001.geekbang.org/account/avatar/00/11/12/7f/bf020fea.jpg","nickname":"懒冬将至","note":"","ucode":"CE6E029EBC6CC6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":35416,"discussion_content":"在ReentrantLock内部acquired调用的tryAcquire方法也是不一样的啊，公平锁的tryAcquire会调用hasQueuedPredecessors()","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571277675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":13791,"user_name":"antipas","can_delete":false,"product_type":"c1","uid":1039798,"ip_address":"","ucode":"7F95F697D607C2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/dd/b6/fcf322a7.jpg","comment_is_top":false,"comment_ctime":1529983648,"is_pvip":false,"replies":[{"id":"4647","content":"这是两种方式，wait基于monitor；一般用并发库就不用Object.wait、notify之类了","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1530117120,"ip_address":"","comment_id":13791,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5824950944","product_id":100006701,"comment_content":"看AQS源码过程中产生了新问题，它对线程的挂起唤醒是通过locksupport实现的，那么它与wait&#47;notify又有何不同，使用场景有何不同。我的理解是使用 wait&#47;notify需要synchronized锁，而且wait需要条件触发","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419756,"discussion_content":"这是两种方式，wait基于monitor；一般用并发库就不用Object.wait、notify之类了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530117120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2059155,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/6b/93/bfda2d1c.jpg","nickname":"梦江","note":"","ucode":"B5FD2835863460","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307004,"discussion_content":"为什么unsafe不加volatile","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600448168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":310598,"user_name":"咦","can_delete":false,"product_type":"c1","uid":2283781,"ip_address":"","ucode":"2E0D5A488489A4","user_header":"https://static001.geekbang.org/account/avatar/00/22/d9/05/0d772dbf.jpg","comment_is_top":false,"comment_ctime":1630764998,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630764998","product_id":100006701,"comment_content":"建议CAS系列可以讲到操作系统实现原理，这样整体更加连贯一些","like_count":0},{"had_liked":false,"id":291438,"user_name":"啊良梓是我","can_delete":false,"product_type":"c1","uid":1655117,"ip_address":"","ucode":"E42FC1A60D331C","user_header":"https://static001.geekbang.org/account/avatar/00/19/41/4d/f6d6d13a.jpg","comment_is_top":false,"comment_ctime":1620288273,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1620288273","product_id":100006701,"comment_content":"我看了一下源码  好像acquireQueued(final Node node, int arg) 方法里面的循环递归条件好像是在shouldParkAfterFailedAcquire(p, node) 方法里面？","like_count":0},{"had_liked":false,"id":183154,"user_name":"终结者999号","can_delete":false,"product_type":"c1","uid":1055854,"ip_address":"","ucode":"33ADE61580B6DD","user_header":"https://static001.geekbang.org/account/avatar/00/10/1c/6e/6c5f5734.jpg","comment_is_top":false,"comment_ctime":1582962839,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1582962839","product_id":100006701,"comment_content":"从CAS到AQS，可以说AQS是靠大量CAS操作来进行的，以便完成各种同步需求。但是在自己产品中如何使用CAS更多是靠各种同步包中的同步容器？","like_count":0},{"had_liked":false,"id":155585,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1574716261,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574716261","product_id":100006701,"comment_content":"CAS适用的场景是多数修改都成功，少数不成功的修改靠增加CPU来轮询，也就是说只有CPU轮询付出的代价足够小才经济。","like_count":0},{"had_liked":false,"id":153556,"user_name":"prepared","can_delete":false,"product_type":"c1","uid":1194853,"ip_address":"","ucode":"00E54A5C7CDCBE","user_header":"https://static001.geekbang.org/account/avatar/00/12/3b/65/3a4fc8cf.jpg","comment_is_top":false,"comment_ctime":1574257942,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1574257942","product_id":100006701,"comment_content":"行尾注释不建议吧","like_count":0,"discussions":[{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385088,"discussion_content":"是的，第一：代码和注释混在一起了，注释是注释，代码是代码，应该分开\n第二：如果代码很长，后面再带注释，屏幕小，就需要左右滑动了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626877186,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141363,"user_name":"亮灯","can_delete":false,"product_type":"c1","uid":1053532,"ip_address":"","ucode":"C06505ED58A0E5","user_header":"","comment_is_top":false,"comment_ctime":1571145171,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1571145171","product_id":100006701,"comment_content":"老师，您好， shouldParkAfterFailedAcquire表示是否挂起当前线程，为什么要有这个判断？这个判断有什么用？","like_count":0},{"had_liked":false,"id":110044,"user_name":"流光","can_delete":false,"product_type":"c1","uid":1434612,"ip_address":"","ucode":"2B41D1B890018D","user_header":"https://static001.geekbang.org/account/avatar/00/15/e3/f4/ecb33aef.jpg","comment_is_top":false,"comment_ctime":1562158147,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1562158147","product_id":100006701,"comment_content":"老师,您的倒数第二个方法是非公平说的获取方法没问题,最后的acquireQueued()是公平锁的获取方法,前天面试就被面试官喷了","like_count":0,"discussions":[{"author":{"id":1079811,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7a/03/c9b43b21.jpg","nickname":"BewhY","note":"","ucode":"4BC26D47A79967","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":12856,"discussion_content":"那你们面试官的水准太低了，你直接说这是Oracle首席工程师跟我这样说的不就行了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568602980,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316834,"avatar":"https://static001.geekbang.org/account/avatar/00/14/17/e2/3df248b9.jpg","nickname":"zhs","note":"","ucode":"83F5BC121F6A91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320003,"discussion_content":"FairSync和NonfairSync都没重写acquire，AQS的acquire调用了tryAcquire和acquireQueued，怎么就成了acquireQueued是公平锁的呢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604224161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90721,"user_name":"Pine","can_delete":false,"product_type":"c1","uid":1132176,"ip_address":"","ucode":"EE78C1D27D9F6B","user_header":"https://static001.geekbang.org/account/avatar/00/11/46/90/a2b206e9.jpg","comment_is_top":false,"comment_ctime":1556616775,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556616775","product_id":100006701,"comment_content":"请教老师一个问题，基本类型前面加volatile，大概能明白什么意思。 可加在引用类型前面就不是很明白了？","like_count":0},{"had_liked":false,"id":90271,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1556463901,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556463901","product_id":100006701,"comment_content":"关于状态的其他童鞋已经说啦，  <br><br>AQS的Node中包含了 Thread和waitStatus，也就是链表中需要获取锁的线程吧～！","like_count":0},{"had_liked":false,"id":63709,"user_name":"ylw666","can_delete":false,"product_type":"c1","uid":1161301,"ip_address":"","ucode":"11BDAB1AF981B3","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/55/f982a2fb.jpg","comment_is_top":false,"comment_ctime":1548471651,"is_pvip":false,"replies":[{"id":"23342","content":"紧凑就是说内存使用效率，有些高性能应用会对此提出苛刻要求","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1549817721,"ip_address":"","comment_id":63709,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1548471651","product_id":100006701,"comment_content":"LongAdder这里，说要考虑紧凑性的影响，不清楚指的是哪方面的考虑","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437690,"discussion_content":"紧凑就是说内存使用效率，有些高性能应用会对此提出苛刻要求","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549817721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":39786,"user_name":"约书亚","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","comment_is_top":false,"comment_ctime":1542356814,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1542356814","product_id":100006701,"comment_content":"全局最看不懂的cancelAcquire方法没说...","like_count":0,"discussions":[{"author":{"id":2938089,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/V71ITElU4RwprR74pPXB6LhIMrfeAHuHjicZmS7smy2tibBSMoA9awaTe86wziatYzoy3qVOGs0DnSTy6ah5L6bKA/132","nickname":"四喜丸子","note":"","ucode":"33D46CC1B747BA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576588,"discussion_content":"+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655690859,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":28276,"user_name":"dal136","can_delete":false,"product_type":"c1","uid":1068814,"ip_address":"","ucode":"820EF448AAB49B","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/0e/00182147.jpg","comment_is_top":false,"comment_ctime":1538039514,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538039514","product_id":100006701,"comment_content":"waitStatus有5种状态：<br>SIGNAL，-1，需要unpark<br>CONDITION，-2,等待condition<br>PROPAGATE，-3, 共享模式中线程处于可运行状态<br>CANCELLED，1，取消<br>0，非以上任何状态","like_count":0}]}