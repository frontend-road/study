{"id":623274,"title":"01｜Modules（上）：C++模块化问题的前世今生","content":"<p>你好，我是卢誉声。</p><p>今天是第一讲，我们会从C++20中的核心特性变更——Modules模块开始，了解现代C++的编程范式、编程思想及现实问题解决方法上的革新。</p><p>我们都知道，无论是编写C还是C++程序，总少不了使用include头文件机制，这是C/C++编程中组织代码的最基本方式，用法简单、直接，而且符合直觉。但很多人不知道的是，其实include头文件机制不仅有坑，在编程过程中还会出现一些难以解决的两难问题。</p><p>接下来，我们就从这个“简单”机制开始探讨代码组织方式的门道，看看里面究竟存在哪些问题，语言设计者和广大语言使用者又是如何应对的，对这些问题的思考，将串联起我们关于C++代码组织方案的所有知识点，也终将引出我们的主角——Modules（课程配套代码点击<a href=\"https://github.com/samblg/cpp20-plus-indepth\">这里</a>获取）。</p><p>首先来看看整个故事的背景，include头文件机制，它的出现是为了什么？</p><h2>万物始于include</h2><p>作为C语言的超集，C++语言从设计之初就沿袭了C语言的include头文件机制，即通过包含头文件的方式来引用其他符号，包括类型定义、接口声明这样的代码，起到分离符号定义与具体实现的作用。</p><p>早期，能放在头文件中的符号比较有限，头文件设计是足以支撑系统设计的。但是为了提高运行时性能，开发者也会考虑将实现直接放在头文件中。</p><!-- [[[read_end]]] --><p>一开始这看起来似乎没什么，但随着软件技术的发展，C++从C++98过渡到现代C++之后，越来越多的特性可以被定义或声明在头文件中，头文件对现代软件开发的支持就显得捉襟见肘了。</p><p>首先，由于模板元编程的特性，模板类、模板函数及其实现，我们往往需要全部定义在头文件中。</p><p>我们还可以在头文件中定义编译时（compile-time）常量表达（constexpr）的变量和函数（constexpr函数也可以在运行时调用）。</p><p><img src=\"https://static001.geekbang.org/resource/image/5c/23/5c4552816bc53cdd81cef5bbc4521a23.jpg?wh=2279x1196\" alt=\"\"></p><p>另外，类型推导auto、inline函数与变量、宏也可以被定义在头文件中。</p><p>这样看来，头文件包罗万象实至名归，但伴随而来的是一系列问题。</p><p>第一个问题是<strong>模糊的模块划分</strong>。</p><p>传统的include头文件机制并没有提供清晰的模块划分能力，如果要在一份代码中使用来自不同目录的相同符号定义，编译器，在链接阶段没有足够的信息来区分这些相同符号定义的强弱关系，会出现符号覆盖或者链接错误的问题。</p><p>第二个问题是<strong>依赖符号导入顺序</strong>。</p><p>一个头文件可能会因为导入符号顺序的不同，影响到代码中包含的另一个语义，如宏定义就有可能会影响到导入符号的顺序。因此，在大规模C++项目中，有时候导入头文件的顺序都是有讲究的，我们往往不能控制所有的代码编写工作，而来自不同开发团队的头文件可能会互相影响，导致头文件难以组合。</p><p>第三个问题是<strong>编译效率低下</strong>。</p><p>C++语言由核心语言特性与库构成，那些可以定义在头文件中的特性（如类型推导auto、模板函数和模板类等）会对编译速度造成影响，而导入一个看似简单的STL库头文件，如sstream，在编译期展开后会达到数万行代码。include头文件会让这些计算、解析在编译阶段反复发生，进一步拖慢甚至拖垮编译效率。</p><p>第四个问题是<strong>命名空间污染</strong>。</p><p>初学C++的时候，我们常常会为了方便大量使用using namespace来简化后续代码的编写工作，如果在这些库中含有与程序中定义的全局实体同名的实体，或者不同库之间有同名的实体，在编译时会出现名字冲突。如果在头文件中使用了using namespace，甚至会导致所有直接或间接包含了该头文件的代码都受到影响，产生不可预计的后果。</p><p>所以，为了解决C++头文件中的符号隔离问题，简单的理解include头文件是远不够的，问题实在不少。接下来，让我们看看在传统C++编程中是如何解决模块化问题的，进而引出C++ Modules。</p><h2>传统C++模块化解决方案</h2><p>事实上，在C++20以前，即便是现代C++（C++11～C++17）也没有在模块化方面有什么实质性的突破，一直没有统一的抽象模块概念。</p><p>但开发者在这么多年的实践中确总结出了一套较为行之有效的经验，可以在一定程度上表示“模块”，以达到两大目的。</p><p>一个目的是划分业务逻辑代码，将大规模的代码划分为小规模的代码，通过层层划分和模块组织，让每个模块代码足够内聚，专注自身业务，最终提升代码的可维护性。</p><p>第二个目的是提升代码的复用性，我们可能会抽离出很多功能模块，供其他模块调用，C++的标准库正是这种“模块”的代表，最终可以减少系统中的重复代码，提升系统的稳定性和可维护性。<br>\n&nbsp;<br>\n既然C++没有提供标准的模块特性，那么传统项目中，我们会使用哪些基础设施来模拟模块呢？</p><p>结合实践经验，我们来看看几个常用特性，包括应对模块划分与符号复用的编译链接、头文件，应对符号隔离的命名空间。</p><h3>分别编译/链接/头文件</h3><p>刚才提到模块化的两个目的，业务逻辑划分、代码复用。为了实现这两个目的，我们首先会利用从C开始就支持的编译-链接两阶段的构建过程。</p><p>C++编译过程中最基础的概念就是“编译单元”，所以每个实现文件（通常以.cpp结尾）都是完全独立的编译单元。我们会先在“编译”这个阶段对每个编译单元进行独立编译，生成独立的目标文件，也就是将C++代码转换成二进制机器码，在这个过程中，每个目标文件中的函数在编译过程中会生成一个“符号”，而每个符号包含一个名称和函数代码的首地址。</p><p>假设我们想在编译单元A（简称A）中引用编译单元B（简称B）中的函数，只需要确保引用的函数同名即可。<br>\n<img src=\"https://static001.geekbang.org/resource/image/ec/24/ecd68450b0d933c3d48e31967f362e24.jpg?wh=2900x1109\" alt=\"\"></p><p>在A的编译过程中，如果引用的函数不存在，就会把函数的调用位置空出来，等到链接的时候，链接器会从其他的编译单元，比如B中，搜索编译时空出位置的函数符号。如果能找到，就将符号地址填入空出来的部分，如果找不到就会报出链接错误。</p><p>这个过程具体是怎么运作的呢？我们举个具体例子来看看，在B中定义了一个函数add，A中引用这个函数add。</p><p>a.cpp代码是这样的。</p><pre><code class=\"language-c++\">#include &lt;cstdint&gt;\n#include &lt;iostream&gt;\nextern int32_t add(int32_t a, int32_t b);\nint main() {\n&nbsp; int32_t sum = add(1, 2);\n&nbsp; std::cout &lt;&lt; \"sum: \" &lt;&lt; sum &lt;&lt; std::endl;\n&nbsp; return 0;\n}\n</code></pre><p>b.cpp代码是这样的。</p><pre><code class=\"language-c++\">#include &lt;cstdint&gt;\nint32_t add(int32_t a, int32_t b) {\n&nbsp; return a + b;\n}\n</code></pre><p>可以看到，A中其实也“声明”了一个函数add，只不过声明的时候加了一个extern修饰符，并没有函数定义。</p><p>这是因为在编译A的时候，编译器并不知道B的存在，我们需要通过这种方式“告知”编译器其实有这个函数add，只是在其他的编译单元中，准备等到链接时再使用。这样一来，虽然编译器没有找到这个函数的定义，但是会暂时“放过”它，在生成的函数调用机器码中会将这个符号的地址空出来，等到链接的时候再来填充。</p><p>如果你使用gcc编译这两个源代码文件，可以看到b.o中会生成一个名为add的符号，这个符号就是准备在链接过程中使用的。</p><p>好，编译完成，我们继续执行链接动作。</p><p>此时，链接器首先将编译生成的A和B的目标文件（a.o和b.o）组装在一起，然后开始“填坑”——填补在编译过程中空出来的符号调用的符号地址。编译器会从b.o的代码中寻找符号add，找到使用这个符号的地址，去填补a.o在编译过程中空出来的调用符号的地址。<br>\n<img src=\"https://static001.geekbang.org/resource/image/34/92/34ee0370b86c67120d3d02b4e80c3e92.jpg?wh=2900x1708\" alt=\"\"></p><p>链接完成后，所有二进制代码中预留的地址全部都要被修补，如果所有编译单元中都找不到这个符号，就会在链接阶段报错。最后，链接生成的二进制代码不允许出现空缺的调用地址。</p><p>Hmm，这种模式似乎可以解决业务逻辑划分问题，但有一个问题——现在，如果有一个新的编译单元C，C也希望使用B中定义的函数，那么我们也需要在C中重写一遍add函数的声明吗？</p><p>的确需要如此，因为编译器并不知道其他编译单元的定义。</p><p>不过，这会让我们引用其他编译单元的函数变得非常麻烦，而且更大的问题是，如果在引用符号的编译单元中写错了声明，只要符号一样，链接的时候也不会报错。怎么办呢？这个时候就要用头文件来解决这个问题了。</p><p>我们可以先定义一个头文件b.h。</p><pre><code class=\"language-c++\">#ifndef _MODULE_B_H\n#define _MODULE_B_H\n#include &lt;cstdint&gt;\nextern int32_t add(int32_t a, int32_t b);\n#endif //_MODULE_B_H\n</code></pre><p>接着修改a.cpp和b.cpp（其中b.cpp暂无变化），修改后代码是这样。</p><pre><code class=\"language-c++\">#include &lt;cstdint&gt;\n#include &lt;iostream&gt;\n#include \"b.h\"\nint main() {\n&nbsp; int32_t sum = add(1, 2);\n&nbsp; std::cout &lt;&lt; \"sum: \" &lt;&lt; sum &lt;&lt; std::endl;\n&nbsp; return 0;\n}\n</code></pre><p>接着编译并链接写好的代码，命令是这样。</p><pre><code class=\"language-c++\">g++ -o add a.cpp b.cpp -std=c++11\n</code></pre><p>以后B中增加了新的函数，只需在b.h中补充相应的声明即可。</p><p>这样在每个引用B的编译单元，都不用重复声明这个函数了，不过我们也需要知道这其实是通过“包含”头文件代码这种非常“低级”的技术方式实现的。而且这种方式可能还会产生一个问题，两个编译单元的符号可能会重复！也就是我们前面提到的“命名空间污染”。</p><p>比如我们在a.cpp中也定义一个add函数，然后进行编译、链接。</p><pre><code class=\"language-c++\">#include &lt;cstdint&gt;\n#include &lt;iostream&gt;\n#include \"b.h\"\n\nint32_t add(int32_t a, int32_t b) {\n&nbsp; return a + b;\n}\n\nint main() {\n&nbsp; int32_t sum = add(1, 2);\n&nbsp; std::cout &lt;&lt; \"sum: \" &lt;&lt; sum &lt;&lt; std::endl;\n\n&nbsp; return 0;\n}&nbsp;\n</code></pre><p>编译过程非常顺利。但是，在链接时，哦？出错了。</p><p><img src=\"https://static001.geekbang.org/resource/image/a9/3c/a9f033994ab9ea722e60634b3a37873c.jpg?wh=1920x167\" alt=\"图片\"></p><p>这是因为a.o中引用了add这个符号，但是b.o和a.o中都包含这个符号，就导致了冲突，因为链接器不知道a.o中想要使用的add到底是b.o中的还是a.o中的。</p><p>这就是所谓的符号隔离问题。那么一般应该如何解决呢？</p><p>在C和早期的C++中我们的解决方案非常简单粗暴，那就是添加前缀。比如我们在b.cpp中在所有定义的函数之前都添加前缀module_b_，在a.cpp中所有定义的函数之前都添加前缀module_a_。如果我们在a.cpp中希望引用的是b.cpp中的add，那么就调用module_b_add，否则调用module_a_add，这就非常简单地解决了问题。</p><p>但这种方式继续带来了两个问题。</p><p>第一个问题是代码冗长，尤其是在b.cpp中定义的时候，所有函数都需要添加前缀module_b_，会让所有的函数定义非常复杂。</p><p>第二个问题是，如果前缀也重复怎么办？毕竟两个编译单元的编写者是不知道对方使用什么前缀的，在技术上无法避免，只能通过不同编译单元的编写者提前约定好双方的前缀来解决。真是一个问题接着一个问题……</p><p>不过，在C++中符号隔离问题，也可以通过隐藏一个编译单元中的私有符号来解决，也就是不让其他编译单元“看到”这些符号。</p><p>这也能大量减少编译单元之间的符号冲突问题，毕竟可能出现，两个编译单元定义了同名，但只想在编译单元内部使用函数的情况，我们并不想给这些函数加上冗长的前缀。那这个时候，只需要使用static修饰符。比如我们可以在A和B中都定义static函数to_int，然后再编译链接，这样就不会出现符号冲突的问题。</p><h3>命名空间</h3><p>虽然在不同编译单元中，相同的符号会引发链接错误，不过在不同的代码组件中，我们是完全可以定义相同符号的，这其中可以包含符号常量、变量、函数、结构体、类、模板和对象等等。</p><p>但是，相同的符号并不意味着它们有相同的功能，而且随着C++工程越来越大，导入的库变多，这种命名冲突的可能性就越大。下图展示了不同编译单元、不同代码组件、namespace之间的关系和层次。<br>\n<img src=\"https://static001.geekbang.org/resource/image/34/df/346c29f1386059ec7b4cbfa184f572df.jpg?wh=3605x2091\" alt=\"\"></p><p>为了避免在C++编程过程中避免命名冲突，C++标准提供了关键字命名空间（namespace）的支持，可以更好地控制符号作用域。但通过namespace进行符号隔离，仍然存在局限性。</p><p>namespace可以通过命名空间避免符号名称冲突，但本身并不管理符号的可见性问题，不同namespace之间的符号可见性取决于编译单元的符号可见性，这让符号的管理变得非常复杂。另外不同编译器产生的namespace的符号修饰方式不同（毕竟这不是C++标准定义的内容），也就是ABI层面不同，会导致跨编译器的符号引用出现很大的问题。</p><h2>总结</h2><p>不知道你有没有发现，今天的思考其实是围绕一个核心问题展开的：为了隐藏代码实现细节，我们往往要使用哪些编程范式或技巧？</p><p><strong>方法一：通过include头文件来统一声明符号</strong></p><p>这种方法的优点是简单粗暴，简洁明了，一定程度上解决了同一组件内相同符号定义冲突的问题。但这种方法也有硬伤，它利用了头文件代码这种非常“低级”的技术方式实现，而且仍无法避免两个编译单元的重复符号的问题。</p><p><strong>方法二：添加前缀来避免符号冲突</strong></p><p>这种方法简单明了，可操作性强，基本可以解决符号冲突问题。但是会大幅降低代码可读性，还会让符号声明变得更长，而且当前缀也重复了，我们真的很难解决问题，难道全局替换前缀？因此这种方式仍然不能解决符号重复和可见性的问题。</p><p><strong>方法三：通过namespace避免符号冲突</strong></p><p>*namespace可以通过命名空间避免符号名称冲突。但是，它本身并不管理符号的可见性问题，不同namespace之间的符号可见性取决于编译单元的符号可见性，这让符号的管理变得非常复杂。而且namespace在不同编译器上的表现不同，在ABI层面无法实现兼容。</p><p>我们可以看出，include头文件机制没能跟上现代C++标准的演进，提供一套行之有效的进行代码组合、符号和功能复用的方案。那么，有没有什么办法来保证库的独立性、易用性，同时提高代码编译速度呢？</p><p>下一讲，Modules在现代C++中就要粉墨登场了，敬请期待。</p><h3>课后思考</h3><p>今天，我们研究了include头文件机制以及C++20前解决符号可见性问题的一些最佳实践。那么在C++ Modules出现以前，你是怎么解决符号隔离问题的？</p><p>欢迎把你碰到的情况与解决方法，与大家一起分享。我们一同交流。下一讲见！</p>","comments":[{"had_liked":false,"id":370681,"user_name":"糍粑不是饭","can_delete":false,"product_type":"c1","uid":1295664,"ip_address":"北京","ucode":"FCF9D03A1AC755","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/adf8X0vmoJN8EuJOpIs81VyVmib9zgxTeWheic1C3DKfFeFT0os67qbicsRFHUeMnz7nKQ25XHp2r7wlbX8KXfLDA/132","comment_is_top":false,"comment_ctime":1679103614,"is_pvip":false,"replies":[{"id":135292,"content":"Good point!\n正好在这里做个调研，大家是否对这个话题感兴趣呢？","user_name":"作者回复","user_name_real":"作者","uid":1006976,"ctime":1679306548,"ip_address":"上海","comment_id":370681,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"老师是否考虑再增加些CMake或者包管理相关的课程呢？😃","like_count":7,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609943,"discussion_content":"Good point!\n正好在这里做个调研，大家是否对这个话题感兴趣呢？","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1679306549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1295664,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/adf8X0vmoJN8EuJOpIs81VyVmib9zgxTeWheic1C3DKfFeFT0os67qbicsRFHUeMnz7nKQ25XHp2r7wlbX8KXfLDA/132","nickname":"糍粑不是饭","note":"","ucode":"FCF9D03A1AC755","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":610020,"discussion_content":"用C++就得用到CMake，避不开。相关资料少之又少，老师要是讲这个肯定会很受欢迎！","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1679355287,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":609943,"ip_address":"北京","group_id":0},"score":610020,"extra":""}]},{"author":{"id":1118806,"avatar":"https://static001.geekbang.org/account/avatar/00/11/12/56/4abadfc3.jpg","nickname":"LoveDr.kang","note":"","ucode":"BED888A788922C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":616777,"discussion_content":"+10086","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1683096722,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"陕西","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238921,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e7/89/207cc841.jpg","nickname":"HI","note":"","ucode":"C65218113883E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":613013,"discussion_content":"+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681091006,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366653,"user_name":"tanatang","can_delete":false,"product_type":"c1","uid":2349826,"ip_address":"四川","ucode":"7526705D25959A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/FhibmYQUzY7ibPac8Id5PwbibqCbvj5rWibeQhEyvYguc9pvPNUciaQydicrUjJKkhhp1s2AgfP7LRTZA8zqaa82yC8g/132","comment_is_top":false,"comment_ctime":1674019943,"is_pvip":false,"replies":[{"id":133592,"content":"OOP原教旨主义 👍","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1674026998,"ip_address":"江苏","comment_id":366653,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"写面向对象的C++，成员和函数都在设计在类中，禁止使用这种不属于任何类的全局函数， 全局变量。","like_count":5,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600126,"discussion_content":"OOP原教旨主义 👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674026998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366616,"user_name":"wilby","can_delete":false,"product_type":"c1","uid":1345031,"ip_address":"瑞典","ucode":"4296C04148B479","user_header":"https://static001.geekbang.org/account/avatar/00/14/86/07/aefa4e8b.jpg","comment_is_top":false,"comment_ctime":1673988633,"is_pvip":false,"replies":[{"id":133594,"content":"文中的意思并非说namespace导致符号管理变复杂。这里的意思是，诸如namespace这类语言特性可以解决符号冲突问题，并且可以在编译时给予友好的提示，但由于C++的编译链接分离机制，C++只为链接定义了一些指导性原则，链接中很多具体技术规范大多由ABI来定义，这就导致在不同编译器和不同体系结构下可能在链接时会遇到不同的问题，这才是C++符号管理复杂性的核心问题所在。而C++ Modules则是更完备的符号可见性管理语言特性，可以与namespace实现互补，而且在链接上也给出了更多的原则（虽然还是无法完全解决ABI问题），让符号管理更加易于理解，更接近现代编程语言，可以一定程度降低整体符号管理的复杂性。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1674027940,"ip_address":"江苏","comment_id":366616,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"为什么namespace让符号管理变得很复杂？老师好像就给了个结论，能展开讲讲么？","like_count":5,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600129,"discussion_content":"文中的意思并非说namespace导致符号管理变复杂。这里的意思是，诸如namespace这类语言特性可以解决符号冲突问题，并且可以在编译时给予友好的提示，但由于C++的编译链接分离机制，C++只为链接定义了一些指导性原则，链接中很多具体技术规范大多由ABI来定义，这就导致在不同编译器和不同体系结构下可能在链接时会遇到不同的问题，这才是C++符号管理复杂性的核心问题所在。而C++ Modules则是更完备的符号可见性管理语言特性，可以与namespace实现互补，而且在链接上也给出了更多的原则（虽然还是无法完全解决ABI问题），让符号管理更加易于理解，更接近现代编程语言，可以一定程度降低整体符号管理的复杂性。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1674027941,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1275357,"avatar":"https://static001.geekbang.org/account/avatar/00/13/75/dd/9ead6e69.jpg","nickname":"黄海峰","note":"","ucode":"E9340719BC96B2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":628521,"discussion_content":"意思是a单元这个编译器编，b单元另一个编译器，最后链接又用不同链接器？这样搞namespace才有链接问题？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1695427767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":600129,"ip_address":"广东","group_id":0},"score":628521,"extra":""}]}]},{"had_liked":false,"id":366617,"user_name":"Geek_7c0961","can_delete":false,"product_type":"c1","uid":2277181,"ip_address":"美国","ucode":"B1482E64FF9E4E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ8aLz0tWdsZuMiaNUAd0dicSD9M6A77seMGFdHgvsQwOzN8ztYPiaJSo53DcbjQWUQpw4pf4rI2f7vg/132","comment_is_top":false,"comment_ctime":1673997797,"is_pvip":true,"replies":[{"id":133595,"content":"比如以下代码\na.cpp:\n#include &lt;iostream&gt;\n\nstatic void print() {\n  std::cout &lt;&lt; &quot;Print in A&quot; &lt;&lt; std::endl;\n}\n\nvoid fa() {\n    print();\n}\n \nb.cpp:\n#include &lt;iostream&gt;\n\nstatic void print() {\n  std::cout &lt;&lt; &quot;Print in B&quot; &lt;&lt; std::endl;\n}\n\nvoid fb() {\n    print();\n}\n\nmain.cpp\n\nextern void fa();\nextern void fa();\n\nint main() {\n  fa();\n  fb();\n\n  return 0;\n}\n\n这里a.cpp和b.cpp两个编译单元都有print函数，但是函数使用了static修饰符，因此print函数仅对各自编译单元内部可见，所以链接时不会导致符号冲突问题。会正确输出：\nPrint in A\nPrint in B","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1674028420,"ip_address":"江苏","comment_id":366617,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"&quot;这也能大量减少编译单元之间的符号冲突问题，毕竟可能出现，两个编译单元定义了同名，但只想在编译单元内部使用函数的情况，我们并不想给这些函数加上冗长的前缀。那这个时候，只需要使用 static 修饰符。比如我们可以在 A 和 B 中都定义 static 函数 to_int，然后再编译链接，这样就不会出现符号冲突的问题。&quot; 这块儿能否给个具体的代码示例?","like_count":2,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600133,"discussion_content":"比如以下代码\na.cpp:\n#include &lt;iostream&gt;\n\nstatic void print() {\n  std::cout &lt;&lt; &#34;Print in A&#34; &lt;&lt; std::endl;\n}\n\nvoid fa() {\n    print();\n}\n \nb.cpp:\n#include &lt;iostream&gt;\n\nstatic void print() {\n  std::cout &lt;&lt; &#34;Print in B&#34; &lt;&lt; std::endl;\n}\n\nvoid fb() {\n    print();\n}\n\nmain.cpp\n\nextern void fa();\nextern void fa();\n\nint main() {\n  fa();\n  fb();\n\n  return 0;\n}\n\n这里a.cpp和b.cpp两个编译单元都有print函数，但是函数使用了static修饰符，因此print函数仅对各自编译单元内部可见，所以链接时不会导致符号冲突问题。会正确输出：\nPrint in A\nPrint in B","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674028420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2277181,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ8aLz0tWdsZuMiaNUAd0dicSD9M6A77seMGFdHgvsQwOzN8ztYPiaJSo53DcbjQWUQpw4pf4rI2f7vg/132","nickname":"Geek_7c0961","note":"","ucode":"B1482E64FF9E4E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":601035,"discussion_content":"谢谢，老师解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675000362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":600133,"ip_address":"美国","group_id":0},"score":601035,"extra":""}]},{"author":{"id":1047043,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fa/03/eba78e43.jpg","nickname":"风清扬","note":"","ucode":"651F1390B64953","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":606786,"discussion_content":"main.cpp中有个小错误 extern void fb(); ","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1677407082,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366879,"user_name":"小样","can_delete":false,"product_type":"c1","uid":1075443,"ip_address":"江西","ucode":"0D05E1D31150F1","user_header":"https://static001.geekbang.org/account/avatar/00/10/68/f3/22481a37.jpg","comment_is_top":false,"comment_ctime":1674524161,"is_pvip":false,"replies":[{"id":133862,"content":"是的，所以软件工程需要确定种种规范，就是为了尽量规避这些问题，但在实际的大项目中还是很难完全避免，尤其是要集成大量第三方库的时候会更加头痛。\n经验积累很重要，而且很值钱。记得总结出自己的一套实践方法。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1675349638,"ip_address":"江苏","comment_id":366879,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"太可怕了，以前没有想过这种问题。\n实际用到的代码规模并不是很大，一个人就能完全掌握各个模块，也就不会有冲突。现在来看传统上符号隔离和污染问题根本就没有在设计上解决过。软件工程规模大后必然有冲突问题。","like_count":1,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":601688,"discussion_content":"是的，所以软件工程需要确定种种规范，就是为了尽量规避这些问题，但在实际的大项目中还是很难完全避免，尤其是要集成大量第三方库的时候会更加头痛。\n经验积累很重要，而且很值钱。记得总结出自己的一套实践方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675349638,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366559,"user_name":"tang_ming_wu","can_delete":false,"product_type":"c1","uid":2566054,"ip_address":"广东","ucode":"98E5847CEF8B84","user_header":"https://static001.geekbang.org/account/avatar/00/27/27/a6/32e9479b.jpg","comment_is_top":false,"comment_ctime":1673925906,"is_pvip":false,"replies":[{"id":133574,"content":"不一定，C++并没有定义二进制函数地址填充的方式，这完全取决于操作系统与特定体系结构的ABI，有可能是相对地址，也有可能是绝对地址。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1673966919,"ip_address":"江苏","comment_id":366559,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"链接过程，函数地址填充，是不是都是相对地址？","like_count":1,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600062,"discussion_content":"不一定，C++并没有定义二进制函数地址填充的方式，这完全取决于操作系统与特定体系结构的ABI，有可能是相对地址，也有可能是绝对地址。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673966919,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366537,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1673916227,"is_pvip":false,"replies":[{"id":133557,"content":"A1：《动态规划面试宝典》\nA2：因为C++编译期支持针对函数调用的内联优化。\n将函数实现放到头文件中，编译期可以根据实际情况对函数调用进行优化，比如将函数调用替换成函数的实现代码，这样针对部分较短的函数可以抵消掉函数调用的性能损耗，这也就是为何明确标为inline的函数定义都一定要放在头文件中。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1673923343,"ip_address":"江苏","comment_id":366537,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"请教两个问题：\nQ1：第一个专栏是什么？\n\nQ2：实现放在头文件中为什么可以提高运行性能？\n文中有这样一句话“但是为了提高运行时性能，开发者也会考虑将实现直接放在头文件中。” 为什么？","like_count":1,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":599977,"discussion_content":"A1：《动态规划面试宝典》\nA2：因为C++编译期支持针对函数调用的内联优化。\n将函数实现放到头文件中，编译期可以根据实际情况对函数调用进行优化，比如将函数调用替换成函数的实现代码，这样针对部分较短的函数可以抵消掉函数调用的性能损耗，这也就是为何明确标为inline的函数定义都一定要放在头文件中。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1673923343,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":599969,"discussion_content":"第一个专栏《动态规划面试宝典》https://time.geekbang.org/column/intro/10006050","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673921188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386170,"user_name":"中山浪子","can_delete":false,"product_type":"c1","uid":1055296,"ip_address":"江苏","ucode":"25D0F8462473D3","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/40/f10493ef.jpg","comment_is_top":false,"comment_ctime":1704257334,"is_pvip":false,"replies":[{"id":140886,"content":"可以用binutils中的objdump&#47;nm查看符号，如果是Windows下生成的PE&#47;COFF格式的二进制文件，还可以用VC的dumpbin查看符号","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1704988777,"ip_address":"上海","comment_id":386170,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"“ b.o 中会生成一个名为 add 的符号”一般是用什么工具或者怎么查看生成的二进制中的符号？","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635631,"discussion_content":"可以用binutils中的objdump/nm查看符号，如果是Windows下生成的PE/COFF格式的二进制文件，还可以用VC的dumpbin查看符号","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704988777,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366734,"user_name":"不二","can_delete":false,"product_type":"c1","uid":2409976,"ip_address":"浙江","ucode":"DDB885462EB91B","user_header":"https://static001.geekbang.org/account/avatar/00/24/c5/f8/623a0375.jpg","comment_is_top":false,"comment_ctime":1674121581,"is_pvip":false,"replies":[{"id":133684,"content":"掌握C++的过去，才能更好的理解C++的未来。虽然这是C++编程语言复杂性的一个缩影，但是有助于大家理解现代C++。如果对这些旧有概念感兴趣，可以回顾一下这些概念。有任何问题也欢迎在评论区提出，我会跟你一起探讨。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1674470141,"ip_address":"江苏","comment_id":366734,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"历史挺好的，但是里面概念太多，解释不清楚感觉消化不了。","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600523,"discussion_content":"掌握C++的过去，才能更好的理解C++的未来。虽然这是C++编程语言复杂性的一个缩影，但是有助于大家理解现代C++。如果对这些旧有概念感兴趣，可以回顾一下这些概念。有任何问题也欢迎在评论区提出，我会跟你一起探讨。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674470141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}