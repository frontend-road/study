{"id":41717,"title":"28 | 条件变量sync.Cond （下）","content":"<p>你好，我是郝林，今天我继续分享条件变量sync.Cond的内容。我们紧接着上一篇的内容进行知识扩展。</p><h2>问题 1：条件变量的<code>Wait</code>方法做了什么？</h2><p>在了解了条件变量的使用方式之后，你可能会有这么几个疑问。</p><ol>\n<li>为什么先要锁定条件变量基于的互斥锁，才能调用它的<code>Wait</code>方法？</li>\n<li>为什么要用<code>for</code>语句来包裹调用其<code>Wait</code>方法的表达式，用<code>if</code>语句不行吗？</li>\n</ol><p>这些问题我在面试的时候也经常问。你需要对这个<code>Wait</code>方法的内部机制有所了解才能回答上来。</p><p>条件变量的<code>Wait</code>方法主要做了四件事。</p><ol>\n<li>把调用它的goroutine（也就是当前的goroutine）加入到当前条件变量的通知队列中。</li>\n<li>解锁当前的条件变量基于的那个互斥锁。</li>\n<li>让当前的goroutine处于等待状态，等到通知到来时再决定是否唤醒它。此时，这个goroutine就会阻塞在调用这个<code>Wait</code>方法的那行代码上。</li>\n<li>如果通知到来并且决定唤醒这个goroutine，那么就在唤醒它之后重新锁定当前条件变量基于的互斥锁。自此之后，当前的goroutine就会继续执行后面的代码了。</li>\n</ol><p>你现在知道我刚刚说的第一个疑问的答案了吗？</p><p>因为条件变量的<code>Wait</code>方法在阻塞当前的goroutine之前，会解锁它基于的互斥锁，所以在调用该<code>Wait</code>方法之前，我们必须先锁定那个互斥锁，否则在调用这个<code>Wait</code>方法时，就会引发一个不可恢复的panic。</p><!-- [[[read_end]]] --><p>为什么条件变量的<code>Wait</code>方法要这么做呢？你可以想象一下，如果<code>Wait</code>方法在互斥锁已经锁定的情况下，阻塞了当前的goroutine，那么又由谁来解锁呢？别的goroutine吗？</p><p>先不说这违背了互斥锁的重要使用原则，即：成对的锁定和解锁，就算别的goroutine可以来解锁，那万一解锁重复了怎么办？由此引发的panic可是无法恢复的。</p><p>如果当前的goroutine无法解锁，别的goroutine也都不来解锁，那么又由谁来进入临界区，并改变共享资源的状态呢？只要共享资源的状态不变，即使当前的goroutine因收到通知而被唤醒，也依然会再次执行这个<code>Wait</code>方法，并再次被阻塞。</p><p>所以说，如果条件变量的<code>Wait</code>方法不先解锁互斥锁的话，那么就只会造成两种后果：不是当前的程序因panic而崩溃，就是相关的goroutine全面阻塞。</p><p>再解释第二个疑问。很显然，<code>if</code>语句只会对共享资源的状态检查一次，而<code>for</code>语句却可以做多次检查，直到这个状态改变为止。那为什么要做多次检查呢？</p><p><strong>这主要是为了保险起见。如果一个goroutine因收到通知而被唤醒，但却发现共享资源的状态，依然不符合它的要求，那么就应该再次调用条件变量的<code>Wait</code>方法，并继续等待下次通知的到来。</strong></p><p>这种情况是很有可能发生的，具体如下面所示。</p><ol>\n<li>\n<p>有多个goroutine在等待共享资源的同一种状态。比如，它们都在等<code>mailbox</code>变量的值不为<code>0</code>的时候再把它的值变为<code>0</code>，这就相当于有多个人在等着我向信箱里放置情报。虽然等待的goroutine有多个，但每次成功的goroutine却只可能有一个。别忘了，条件变量的<code>Wait</code>方法会在当前的goroutine醒来后先重新锁定那个互斥锁。在成功的goroutine最终解锁互斥锁之后，其他的goroutine会先后进入临界区，但它们会发现共享资源的状态依然不是它们想要的。这个时候，<code>for</code>循环就很有必要了。</p>\n</li>\n<li>\n<p>共享资源可能有的状态不是两个，而是更多。比如，<code>mailbox</code>变量的可能值不只有<code>0</code>和<code>1</code>，还有<code>2</code>、<code>3</code>、<code>4</code>。这种情况下，由于状态在每次改变后的结果只可能有一个，所以，在设计合理的前提下，单一的结果一定不可能满足所有goroutine的条件。那些未被满足的goroutine显然还需要继续等待和检查。</p>\n</li>\n<li>\n<p>有一种可能，共享资源的状态只有两个，并且每种状态都只有一个goroutine在关注，就像我们在主问题当中实现的那个例子那样。不过，即使是这样，使用<code>for</code>语句仍然是有必要的。原因是，在一些多CPU核心的计算机系统中，即使没有收到条件变量的通知，调用其<code>Wait</code>方法的goroutine也是有可能被唤醒的。这是由计算机硬件层面决定的，即使是操作系统（比如Linux）本身提供的条件变量也会如此。</p>\n</li>\n</ol><p>综上所述，在包裹条件变量的<code>Wait</code>方法的时候，我们总是应该使用<code>for</code>语句。</p><p>好了，到这里，关于条件变量的<code>Wait</code>方法，我想你知道的应该已经足够多了。</p><h2>问题 2：条件变量的<code>Signal</code>方法和<code>Broadcast</code>方法有哪些异同？</h2><p>条件变量的<code>Signal</code>方法和<code>Broadcast</code>方法都是被用来发送通知的，不同的是，前者的通知只会唤醒一个因此而等待的goroutine，而后者的通知却会唤醒所有为此等待的goroutine。</p><p>条件变量的<code>Wait</code>方法总会把当前的goroutine添加到通知队列的队尾，而它的<code>Signal</code>方法总会从通知队列的队首开始，查找可被唤醒的goroutine。所以，因<code>Signal</code>方法的通知，而被唤醒的goroutine一般都是最早等待的那一个。</p><p>这两个方法的行为决定了它们的适用场景。如果你确定只有一个goroutine在等待通知，或者只需唤醒任意一个goroutine就可以满足要求，那么使用条件变量的<code>Signal</code>方法就好了。</p><p>否则，使用<code>Broadcast</code>方法总没错，只要你设置好各个goroutine所期望的共享资源状态就可以了。</p><p>此外，再次强调一下，与<code>Wait</code>方法不同，条件变量的<code>Signal</code>方法和<code>Broadcast</code>方法并不需要在互斥锁的保护下执行。恰恰相反，我们最好在解锁条件变量基于的那个互斥锁之后，再去调用它的这两个方法。这更有利于程序的运行效率。</p><p>最后，请注意，条件变量的通知具有即时性。也就是说，如果发送通知的时候没有goroutine为此等待，那么该通知就会被直接丢弃。在这之后才开始等待的goroutine只可能被后面的通知唤醒。</p><p>你可以打开demo62.go文件，并仔细观察它与demo61.go的不同。尤其是<code>lock</code>变量的类型，以及发送通知的方式。</p><h2>总结</h2><p>我们今天主要讲了条件变量，它是基于互斥锁的一种同步工具。在Go语言中，我们需要用<code>sync.NewCond</code>函数来初始化一个<code>sync.Cond</code>类型的条件变量。</p><p><code>sync.NewCond</code>函数需要一个<code>sync.Locker</code>类型的参数值。</p><p><code>*sync.Mutex</code>类型的值以及<code>*sync.RWMutex</code>类型的值都可以满足这个要求。另外，后者的<code>RLocker</code>方法可以返回这个值中的读锁，也同样可以作为<code>sync.NewCond</code>函数的参数值，如此就可以生成与读写锁中的读锁对应的条件变量了。</p><p>条件变量的<code>Wait</code>方法需要在它基于的互斥锁保护下执行，否则就会引发不可恢复的panic。此外，我们最好使用<code>for</code>语句来检查共享资源的状态，并包裹对条件变量的<code>Wait</code>方法的调用。</p><p>不要用<code>if</code>语句，因为它不能重复地执行“检查状态-等待通知-被唤醒”的这个流程。重复执行这个流程的原因是，一个“因为等待通知，而被阻塞”的goroutine，可能会在共享资源的状态不满足其要求的情况下被唤醒。</p><p>条件变量的<code>Signal</code>方法只会唤醒一个因等待通知而被阻塞的goroutine，而它的<code>Broadcast</code>方法却可以唤醒所有为此而等待的goroutine。后者比前者的适应场景要多得多。</p><p>这两个方法并不需要受到互斥锁的保护，我们也最好不要在解锁互斥锁之前调用它们。还有，条件变量的通知具有即时性。当通知被发送的时候，如果没有任何goroutine需要被唤醒，那么该通知就会立即失效。</p><h2>思考题</h2><p><code>sync.Cond</code>类型中的公开字段<code>L</code>是做什么用的？我们可以在使用条件变量的过程中改变这个字段的值吗？</p><p><a href=\"https://github.com/hyper0x/Golang_Puzzlers\">戳此查看Go语言专栏文章配套详细代码。</a></p>","neighbors":{"left":{"article_title":"27 | 条件变量sync.Cond （上）","id":41588},"right":{"article_title":"29 | 原子操作（上）","id":41908}},"comments":[{"had_liked":false,"id":104885,"user_name":"郝林","can_delete":false,"product_type":"c1","uid":1026643,"ip_address":"","ucode":"F66BA62BA56FFA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","comment_is_top":false,"comment_ctime":1560863678,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"173359555518","product_id":100013101,"comment_content":"对条件变量这个工具本身还有疑问的读者可以去看我写的《Go 并发编程实战》第二版。这本书从并发程序的基本概念讲起，用一定篇幅的图文内容详细地讲解了条件变量的用法，同时还有一个贯穿了互斥锁和条件变量的示例。由于这本书的版权在出版社那里，所以我不能把其中的内容搬到这里。<br><br>我在这里只对大家共同的疑问进行简要说明：<br><br>1. 条件变量适合保护那些可执行两个对立操作的共享资源。比如，一个既可读又可写的共享文件。又比如，既有生产者又有消费者的产品池。<br><br>2. 对于有着对立操作的共享资源（比如一个共享文件），我们通常需要基于同一个锁的两个条件变量（比如 rcond 和 wcond）分别保护读操作和写操作（比如 rcond 保护读，wcond 保护写）。而且，读操作和写操作都需要同时持有这两个条件变量。因为，读操作在操作完成后还要向 wcond 发通知；写操作在操作完成后还要向 rcond 发通知。如此一来，读写操作才能在较少的锁争用的情况下交替进行。<br><br>3. 对于同一个条件变量，我们在调用它的 Signal 方法和 Broadcast 方法的时候不应该处在其包含的那个锁的保护下。也就是说，我们应该先撤掉保护屏障，再向 Wait 方法的调用方发出通知。否则，Wait 方法的调用方就有可能会错过通知。这也是我更推荐使用 Broadcast 方法的原因。所有等待方都错过通知的概率要小很多。<br><br>4. 相对应的，我们在调用条件变量的 Wait 方法的时候，应该处在其中的锁的保护之下。因为有同一个锁保护，所以不可能有多个 goroutine 同时执行到这个 Wait 方法调用，也就不可能存在针对其中锁的重复解锁。<br><br>5. 再强调一下。对于同一个锁，多个 goroutine 对它重复锁定时只会有一个成功，其余的会阻塞；多个 goroutine 对它重复解锁时也只会有一个成功，但其余的会抛 panic。","like_count":40,"discussions":[{"author":{"id":1295596,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIBJYQ73yYqmiaU7Zg0BHPh9gpSglI79Dzcbob7I2tZOhTjbTTCw13KzVusYhLbKkukV9Ru5UfJMxQ/132","nickname":"Geek_2d276a","note":"","ucode":"866B39EBE71356","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":264501,"discussion_content":"对于第5点，应该加一个定语“对于同一个写锁或互斥锁”，因为对于读锁是可以多次加锁的。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1589330933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1186807,"avatar":"https://static001.geekbang.org/account/avatar/00/12/1b/f7/45e8b64a.jpg","nickname":"Fire","note":"","ucode":"4A2C50B77EDB2C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340639,"discussion_content":"看了共享内存和信号量配合的进程间通信方法，在大脑里混一混碰一碰，混乱之后才能清晰。第一遍看不懂看来是输入不够。哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610084926,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1496889,"avatar":"https://static001.geekbang.org/account/avatar/00/16/d7/39/6698b6a9.jpg","nickname":"Hector","note":"","ucode":"110CAF87ADDC01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":21154,"discussion_content":"三刷之后，豁然开朗。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569425054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98397,"user_name":"Geek_14c558","can_delete":false,"product_type":"c1","uid":1474702,"ip_address":"","ucode":"2E3BAE6F6D6CD7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI9X140JXPuaK4icMjjd7zJx8BObRv9MO4tuUeV9t9icm4PlZu6m8BFweOsdM8Qs5rTNT5zH0Xs240g/132","comment_is_top":false,"comment_ctime":1558978110,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"87458324030","product_id":100013101,"comment_content":"我理解是这样的。流程： 外部函数加锁 -&gt; 判断条件变量-&gt;wait内部解锁-&gt;阻塞等待信号-&gt;wait内部加锁-&gt; 修改条件变量-&gt; 外部解锁-&gt; 触发信号。 第一次加解锁是为了保证读条件变量时它不会被修改， wait解锁是为了条件变量能够被其他线程改变。wait内部再次加锁，是对条件变量的保护，因为外部要修改。 ","like_count":20,"discussions":[{"author":{"id":1496889,"avatar":"https://static001.geekbang.org/account/avatar/00/16/d7/39/6698b6a9.jpg","nickname":"Hector","note":"","ucode":"110CAF87ADDC01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":21155,"discussion_content":"感谢梳理，自己梳理一遍感觉通透多了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569425125,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117116,"user_name":"不记年","can_delete":false,"product_type":"c1","uid":1045945,"ip_address":"","ucode":"287E40C68356DC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/b9/888fe350.jpg","comment_is_top":false,"comment_ctime":1563971559,"is_pvip":false,"replies":[{"id":"42961","content":"不会，所以我才说应该优先用 broadcast。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1564020906,"ip_address":"","comment_id":117116,"utype":1}],"discussion_count":1,"race_medal":0,"score":"70283448295","product_id":100013101,"comment_content":"老师，我有一个疑问，对于cond来说，每次只唤醒一个goruntine，如果这么goruntine发现消息不是自己想要的就会从新阻塞在wait函数中，那么真正需要这个消息的goruntine还会被唤醒吗？","like_count":16,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459828,"discussion_content":"不会，所以我才说应该优先用 broadcast。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564020906,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32453,"user_name":"Laughing","can_delete":false,"product_type":"c1","uid":1002134,"ip_address":"","ucode":"F68F1E000CA800","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/96/99466a06.jpg","comment_is_top":false,"comment_ctime":1539576587,"is_pvip":false,"replies":[{"id":"11825","content":"动这个L之前一定要三思，谨慎些，想想是不是会影响到程序。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1539578197,"ip_address":"","comment_id":32453,"utype":1}],"discussion_count":1,"race_medal":0,"score":"53079184139","product_id":100013101,"comment_content":"L公开变量代表cond初始化时传递进来的锁，这个锁的状态是可以改变的，但会影响cond对互斥锁的控制。","like_count":12,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426777,"discussion_content":"动这个L之前一定要三思，谨慎些，想想是不是会影响到程序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539578197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33720,"user_name":"云学","can_delete":false,"product_type":"c1","uid":1027233,"ip_address":"","ucode":"366AE90BA06356","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ac/a1/43d83698.jpg","comment_is_top":false,"comment_ctime":1539862091,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"35899600459","product_id":100013101,"comment_content":"有个疑问，broadcast唤醒所有wait的goroutine，那他们被唤醒时需要去加锁(wait返回)，都能成功吗？","like_count":8,"discussions":[{"author":{"id":1071316,"avatar":"https://static001.geekbang.org/account/avatar/00/10/58/d4/c52f9f6d.jpg","nickname":"芝士老爹","note":"","ucode":"5F2935967574D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3831,"discussion_content":"同一时间，互斥锁只有一个能成功，读锁可以多个，没有打破锁的规则。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1564848112,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008348,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/dc/8876c73b.jpg","nickname":"moooofly","note":"","ucode":"4A20795C281B6F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":14683,"discussion_content":"应该理解成，会“一个一个”的成功，而不是“同时”成功；按照我的理解，虽然是“一个一个”的成功，但顺序依然是随机的，而不是按照FIFO的顺序","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568776805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34798,"user_name":"猫王者","can_delete":false,"product_type":"c1","uid":1248924,"ip_address":"","ucode":"224826F4BA8443","user_header":"https://static001.geekbang.org/account/avatar/00/13/0e/9c/cb9da823.jpg","comment_is_top":false,"comment_ctime":1540303956,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"23015140436","product_id":100013101,"comment_content":"“我们最好在解锁条件变量基于的那个互斥锁之后，再去调用它的这两个方法（signal和Broadcast）。这更有利于程序的运行效率”    这个应该如何理解？<br><br>我的理解是如果先调用signal方法，然后在unlock解锁，如果在这两个操作中间该线程失去cpu，或者我人为的在siganl和unlock之间调用time.Sleep();在另一个等待线程中即使该等待线程被前者所发出的signal唤醒，但是唤醒的时候同时会去进行lock操作，但是前者的线程中由于失去了cpu，并没有调用unlock，那么这次唤醒不是应该失败了吗，即使前者有得到了cpu去执行了unlcok，但是signal操作具有及时性，等待线程不是应该继续等待下一个signal吗，感觉最后会变成死锁啊<br><br>","like_count":5,"discussions":[{"author":{"id":1799937,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKSVGSo9leSm0vhtHgzIOL7uaJhOcaImuIzLIrVhXUNPmhd9HGIxs0nWIQm5RTCEjwJ6IuG3moOdQ/132","nickname":"Geek_f1933b","note":"","ucode":"9045A7ED2B2A69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":165499,"discussion_content":"应该不会死锁，两个goroutine都只使用的是同一把锁，不具备死锁的条件吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581298101,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1505155,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f7/83/7fa4bd45.jpg","nickname":"趣学车","note":"","ucode":"5279A6BF4C67A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1799937,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKSVGSo9leSm0vhtHgzIOL7uaJhOcaImuIzLIrVhXUNPmhd9HGIxs0nWIQm5RTCEjwJ6IuG3moOdQ/132","nickname":"Geek_f1933b","note":"","ucode":"9045A7ED2B2A69","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325142,"discussion_content":"A发送信号，然后被阻塞->B接收到信号被唤醒，尝试获取锁，由于A没有解锁，B这里会阻塞->A获得执行权后执行解锁操作->B获得执行权后加锁成功，继续执行。\n这里的B被唤醒后由于A没有解锁所以又被阻塞了， 这应该就是老师说的效率问题吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605244738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":165499,"ip_address":""},"score":325142,"extra":""}]}]},{"had_liked":false,"id":37934,"user_name":"打你","can_delete":false,"product_type":"c1","uid":1075199,"ip_address":"","ucode":"18403CA411C6C7","user_header":"https://static001.geekbang.org/account/avatar/00/10/67/ff/d4f31b87.jpg","comment_is_top":false,"comment_ctime":1541815609,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18721684793","product_id":100013101,"comment_content":"在看了一遍，清楚了","like_count":4},{"had_liked":false,"id":196675,"user_name":"Lywane","can_delete":false,"product_type":"c1","uid":1446512,"ip_address":"","ucode":"2B0027AA069CE9","user_header":"https://static001.geekbang.org/account/avatar/00/16/12/70/10faf04b.jpg","comment_is_top":false,"comment_ctime":1585301928,"is_pvip":false,"replies":[{"id":"74608","content":"首先还是要明确这个过程：sendCond.Wait() 会先解锁再阻塞当前的 goroutine，然后等到别的地方调用 sendCond.Signal() 后，这里的 sendCond.Wait() 会加锁并唤醒当前的 goroutine。<br><br>假设有多个 goroutine 都调用了 sendCond.Wait() 方法，如果它们所在的 goroutine 都因条件变量的通知而被唤醒，那么（由于锁的缘故）只有一个 goroutine （以下称“1号G”）能够率先再次检查 mailbox。<br><br>“1号G”发现 mailbox 的值已经不是 1 了，随即退出循环，并且又把 mailbox 的值设置成了 1。最后解锁，并给 recvCond 发通知。<br><br>由于“1号G”的解锁，“2号G”、“3号G”等等（其他调用了 sendCond.Wait() 方法的G）都会竞争这个锁。得到该锁控制权的某个G会再锁住这个锁，然后发现 mailbox 的值依然是 1，随即再次调用 sendCond.Wait() 方法，并继续等待这个条件变量的下一个通知。其他的G也是类似的。<br><br>这个场景和过程要想清楚。可以自己画几条平行线，然后模拟一下这个过程。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1585391789,"ip_address":"","comment_id":196675,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14470203816","product_id":100013101,"comment_content":"```<br>\tlock.Lock()<br>\tfor mailbox == 1 {<br>\t\tsendCond.Wait()<br>\t}<br>\tmailbox = 1<br>\tlock.Unlock()<br>\trecvCond.Signal()<br>```<br>只要共享资源的状态不变，即使当前的 goroutine 因收到通知而被唤醒，也依然会再次执行这个Wait方法，并再次被阻塞。<br><br>老师我对这句话有个疑问，假设Wait不解锁，直接阻塞了当前goroutine，那么当收到通知时，mailbox的值应该已经被改成0了，此时唤醒，应该不满足for循环条件了呀，为什么会再次执行Wait方法呢？<br><br>我思考的结论是：Wait解锁是为了让其他goroutine去修改mailbox的值，不知道这么理解对吗。","like_count":3,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489356,"discussion_content":"首先还是要明确这个过程：sendCond.Wait() 会先解锁再阻塞当前的 goroutine，然后等到别的地方调用 sendCond.Signal() 后，这里的 sendCond.Wait() 会加锁并唤醒当前的 goroutine。\n\n假设有多个 goroutine 都调用了 sendCond.Wait() 方法，如果它们所在的 goroutine 都因条件变量的通知而被唤醒，那么（由于锁的缘故）只有一个 goroutine （以下称“1号G”）能够率先再次检查 mailbox。\n\n“1号G”发现 mailbox 的值已经不是 1 了，随即退出循环，并且又把 mailbox 的值设置成了 1。最后解锁，并给 recvCond 发通知。\n\n由于“1号G”的解锁，“2号G”、“3号G”等等（其他调用了 sendCond.Wait() 方法的G）都会竞争这个锁。得到该锁控制权的某个G会再锁住这个锁，然后发现 mailbox 的值依然是 1，随即再次调用 sendCond.Wait() 方法，并继续等待这个条件变量的下一个通知。其他的G也是类似的。\n\n这个场景和过程要想清楚。可以自己画几条平行线，然后模拟一下这个过程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585391789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120117,"user_name":"樂文💤","can_delete":false,"product_type":"c1","uid":1073694,"ip_address":"","ucode":"CE4A46397521FC","user_header":"https://static001.geekbang.org/account/avatar/00/10/62/1e/8054e6db.jpg","comment_is_top":false,"comment_ctime":1564794906,"is_pvip":false,"replies":[{"id":"44116","content":"总是需要用 for 的，因为你没法保证收到信号之后那个状态就一定是你想要的。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1564807161,"ip_address":"","comment_id":120117,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10154729498","product_id":100013101,"comment_content":"所以如果用的signal方法只通知一个go routine的话 条件变量的判断方法改成if应该是没问题的 但如果是多个go routine 同时被唤醒就可能导致多个go routine 在不满足唤醒状态的时候被唤醒而导致处理错误，这时候就必须用for来不断地进行检测可以这么理解么","like_count":2,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461205,"discussion_content":"总是需要用 for 的，因为你没法保证收到信号之后那个状态就一定是你想要的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564807161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1073694,"avatar":"https://static001.geekbang.org/account/avatar/00/10/62/1e/8054e6db.jpg","nickname":"樂文💤","note":"","ucode":"CE4A46397521FC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3765,"discussion_content":"重新思考了一下我刚说的是不对的 如果要想if和for效果等同 除了是只唤醒一个线程以外还需要他们执行wait的条件是单一的 即只有0和1两种情况 因为如果别的线程在2的时候执行了signal 这时候也是不应该被唤醒的 需要一直用for去检测","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564795835,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1071316,"avatar":"https://static001.geekbang.org/account/avatar/00/10/58/d4/c52f9f6d.jpg","nickname":"芝士老爹","note":"","ucode":"5F2935967574D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1073694,"avatar":"https://static001.geekbang.org/account/avatar/00/10/62/1e/8054e6db.jpg","nickname":"樂文💤","note":"","ucode":"CE4A46397521FC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3838,"discussion_content":"文中说了有一种情况不是因为竟态条件改变而被唤醒，也就是不是被single或者broadcast唤醒，而是因为硬件或者操作系统的原因莫名被唤醒，这时候for可以帮助再次进去wait，避免一些错误。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564848696,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3765,"ip_address":""},"score":3838,"extra":""}]}]},{"had_liked":false,"id":49360,"user_name":"甦","can_delete":false,"product_type":"c1","uid":1283022,"ip_address":"","ucode":"9A4D52FDB3A93B","user_header":"https://static001.geekbang.org/account/avatar/00/13/93/ce/d4ac6fae.jpg","comment_is_top":false,"comment_ctime":1544670509,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10134605101","product_id":100013101,"comment_content":"源码问题问一下郝老师，cond wait方法里，多个协程走到c.L.Unlock()那一步不会出问题吗？ 只有一个协程可以unlock成功，其他协程重复unlock不就panic了吗？","like_count":2,"discussions":[{"author":{"id":1171471,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e0/0f/12e08ce9.jpg","nickname":"小奕","note":"","ucode":"5294DD5895D602","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319181,"discussion_content":"routine A 抢到l.Lock()权后，其他routine都阻塞在l.Lock()处。待routine A执行完c.L.Unlock()方法进入阻塞状态后，其他routine继续竞争l.Lock()权。新竞争到l.Lock()权的routine同样先l.Lock()再c.L.Unlock()，此时该锁处于Lock状态，故不会panic。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603957707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1198125,"avatar":"https://static001.geekbang.org/account/avatar/00/12/48/2d/7a3d42fb.jpg","nickname":"Alan","note":"","ucode":"9C66CBCFB3A109","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":126229,"discussion_content":"每个协程持有的是当前自己的lock,不是同一个,所谓的重复unlock只对同一个lock而言的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578497994,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37932,"user_name":"打你","can_delete":false,"product_type":"c1","uid":1075199,"ip_address":"","ucode":"18403CA411C6C7","user_header":"https://static001.geekbang.org/account/avatar/00/10/67/ff/d4f31b87.jpg","comment_is_top":false,"comment_ctime":1541815181,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"10131749773","product_id":100013101,"comment_content":"lock.Lock()<br>for mailbox == 1 {<br> sendCond.Wait()<br>}<br>mailbox = 1<br>lock.Unlock()<br>recvCond.Signal()<br>如果wait已经解锁lock.Lock()锁住的锁，后面lock.Unlock解锁是什么意思？不会panic。<br>条件变量这2篇看起来前后理解不到","like_count":2,"discussions":[{"author":{"id":1176461,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f3/8d/477ab4b7.jpg","nickname":"千手柱间","note":"","ucode":"9B51A734DF791C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":9462,"discussion_content":"我的理解是，wait的时候goroutine就阻塞了，代码就不往下走了。直到wait接到通知唤醒goroutine,而这个时候会重新加锁","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1568170699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1740409,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/8e/79/f9d5dd3a.jpg","nickname":"吕超","note":"","ucode":"B36883984BE16B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":190551,"discussion_content":"func (c *Cond) Wait() {\n\tc.checker.check()\n\tt := runtime_notifyListAdd(&amp;c.notify)\n\tc.L.Unlock()\n\truntime_notifyListWait(&amp;c.notify, t)\n\tc.L.Lock()\n}\n这个是cond.Wait的源码，再被notify之后，会重新锁上","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582958121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1198125,"avatar":"https://static001.geekbang.org/account/avatar/00/12/48/2d/7a3d42fb.jpg","nickname":"Alan","note":"","ucode":"9C66CBCFB3A109","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":126202,"discussion_content":"wait第四件事重新锁定，对应自己写的unlock","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578497772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":238718,"user_name":"手指饼干","can_delete":false,"product_type":"c1","uid":1048607,"ip_address":"","ucode":"1AC502D2B782F0","user_header":"","comment_is_top":false,"comment_ctime":1596271343,"is_pvip":false,"replies":[{"id":"88207","content":"首先要明确：<br><br>条件变量的这两个方法并不需要受到互斥锁的保护，我们也最好不要在解锁互斥锁之前调用它们。<br><br>其次：<br><br>等待方法对锁的操作主要是为了让多个等待方有秩序的行事。在真正等待前释放锁，是为了让其他的等待方也具有进入等待状态的条件。在唤醒之后再次试图持有锁，是为了让多个等待方串行地检查条件是否满足以及执行后续的操作。<br><br>所以，结论是：<br><br>发送方在发送通知的时候最好不要持有等待方操作的那个锁。而等待方，应该在等待的时候持有锁加以保护。<br><br>最后：<br><br>关于你的最后一个问题，如果 mutex 是等待方操作的那个锁，那么就有可能产生发送方与等待方的互斥问题。由于等待方会在真正等待之前释放锁，所以应该不会产生完全死锁的情况。但是，这种没必要的操作肯定会影响程序的效率。<br><br>如果 mutex 与等待方没关系，那就无所谓了。你可以根据“是否想串行化通知的发送操作”来决定是否加锁。不过这通常也没什么必要。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1596346997,"ip_address":"","comment_id":238718,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5891238639","product_id":100013101,"comment_content":"老师您好，关于发送通知是否需要在锁的保护下调用，还是有些疑问，以下想法请老师帮忙看看是否理解正确：<br>一个在等待通知的 goroutine 收到通知信号被唤醒，接下来执行的是条件变量 c.L.Lock() 操作，无论信号的发送方是否是在锁的保护下发送信号，该 goroutine 已经不是在等待通知的状态了，而是在尝试获取锁的状态，即使被阻塞，也是因为获取不到锁。区别只是，如果信号发送方在 Unlock() 之后发送信号，那么该 goroutine 被唤醒后获得锁可能会衔接得更好一点。<br>对于某些场景，比如说函数的开头两行代码就是<br>mutex.Lock() <br>defer mutex.Unlock()<br>这种情况是否可以允许通知在 Unlock() 之前调用","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502835,"discussion_content":"首先要明确：\n\n条件变量的这两个方法并不需要受到互斥锁的保护，我们也最好不要在解锁互斥锁之前调用它们。\n\n其次：\n\n等待方法对锁的操作主要是为了让多个等待方有秩序的行事。在真正等待前释放锁，是为了让其他的等待方也具有进入等待状态的条件。在唤醒之后再次试图持有锁，是为了让多个等待方串行地检查条件是否满足以及执行后续的操作。\n\n所以，结论是：\n\n发送方在发送通知的时候最好不要持有等待方操作的那个锁。而等待方，应该在等待的时候持有锁加以保护。\n\n最后：\n\n关于你的最后一个问题，如果 mutex 是等待方操作的那个锁，那么就有可能产生发送方与等待方的互斥问题。由于等待方会在真正等待之前释放锁，所以应该不会产生完全死锁的情况。但是，这种没必要的操作肯定会影响程序的效率。\n\n如果 mutex 与等待方没关系，那就无所谓了。你可以根据“是否想串行化通知的发送操作”来决定是否加锁。不过这通常也没什么必要。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596346997,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123082,"user_name":"Geek_a8be59","can_delete":false,"product_type":"c1","uid":1563985,"ip_address":"","ucode":"BEC0F57B51DC44","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKdiaUiaCYQe9tibemaNU5ya7RrU3MYcSGEIG7zF27u0ZDnZs5lYxPb7KPrAsj3bibM79QIOnPXAatfIw/132","comment_is_top":false,"comment_ctime":1565602339,"is_pvip":false,"replies":[{"id":"45480","content":"我记得在书里也说过类似的内容：条件变量常用于对共享资源的状态变化的监控和响应（由此可以实现状态机），同时也比较适合帮助多个线程协作操作同一个共享资源（这里的关键词是协作）。<br><br>条件变量有两种通知机制，这是互斥量没有的。互斥量只能保护共享资源（这里的关键词是保护），功能比较单一。所以条件变量在一些场景下会更高效。<br><br>你自己也说出了一些使用两个互斥锁来做的弊端。这些弊端其实就已经比较闹心了。一个是用两个锁对性能的影响，一个是两个锁如果配合不当就会造成局部的死锁。这还是多方协作操作同一个共享资源中最简单的情况。<br><br>再加上我前面说的那些，条件变量在此类场景下的优势已经非常明显了。注意它在Wait时还有原子级的操作呢。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1565794919,"ip_address":"","comment_id":123082,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5860569635","product_id":100013101,"comment_content":"老实您好，不太明白为什么一定要用条件变量呢。我看了 go并发编程第2版和你这边的做了对应，书上是已生成者消费者为例，我想的是用两个互斥量不行么？生成一个锁，消费一个锁，只是说可能会浪费在循环判断是否可生成，是否可消费中，还有可能因为某些不成功导致一直不能解锁的状况。  难不成条件变量主要就是优化上述问题的么？","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462529,"discussion_content":"我记得在书里也说过类似的内容：条件变量常用于对共享资源的状态变化的监控和响应（由此可以实现状态机），同时也比较适合帮助多个线程协作操作同一个共享资源（这里的关键词是协作）。\n\n条件变量有两种通知机制，这是互斥量没有的。互斥量只能保护共享资源（这里的关键词是保护），功能比较单一。所以条件变量在一些场景下会更高效。\n\n你自己也说出了一些使用两个互斥锁来做的弊端。这些弊端其实就已经比较闹心了。一个是用两个锁对性能的影响，一个是两个锁如果配合不当就会造成局部的死锁。这还是多方协作操作同一个共享资源中最简单的情况。\n\n再加上我前面说的那些，条件变量在此类场景下的优势已经非常明显了。注意它在Wait时还有原子级的操作呢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565794919,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81462,"user_name":"RegExp","can_delete":false,"product_type":"c1","uid":1126399,"ip_address":"","ucode":"8842E897CAC074","user_header":"https://static001.geekbang.org/account/avatar/00/11/2f/ff/e9ebafec.jpg","comment_is_top":false,"comment_ctime":1553918130,"is_pvip":false,"replies":[{"id":"29509","content":"原理上是这样，但是实践中最好不要这样混用同一个锁。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1553923115,"ip_address":"","comment_id":81462,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5848885426","product_id":100013101,"comment_content":"条件变量的Wait方法在阻塞当前的 goroutine之前，会解锁它基于的互斥锁，那是不是显示调用lock.Lock()的锁也被解锁了呢？<br><br>","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445209,"discussion_content":"原理上是这样，但是实践中最好不要这样混用同一个锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553923115,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":356401,"user_name":"黄仲辉","can_delete":false,"product_type":"c1","uid":1593521,"ip_address":"北京","ucode":"D7EB3C3ADD99DA","user_header":"https://static001.geekbang.org/account/avatar/00/18/50/b1/7b701518.jpg","comment_is_top":false,"comment_ctime":1662268110,"is_pvip":false,"replies":[{"id":"129766","content":"sync.Cond其实对应的是操作系统API中的条件变量。我记得Java也有条件变量这个东西吧。","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1662346013,"ip_address":"北京","comment_id":356401,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1662268110","product_id":100013101,"comment_content":"sync.crod 类比 java的 监视器锁","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586564,"discussion_content":"sync.Cond其实对应的是操作系统API中的条件变量。我记得Java也有条件变量这个东西吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662346013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336457,"user_name":"Geek_108cb5","can_delete":false,"product_type":"c1","uid":2355516,"ip_address":"","ucode":"47959B1E8926A5","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/KhQRc8hIxHHyPV3Og2Fc5qhN3zkWUnw31wkc7mcmGyxicD9Yrvhh7N5B3icqpgWZXfuWbysn7Lv6QMPIEmYPeC4w/132","comment_is_top":false,"comment_ctime":1646150198,"is_pvip":false,"replies":[{"id":"122994","content":"如果你用的是读写锁的话，读写锁中的读锁定操作之间是不互斥的。所以我估计是你这块的用法错了。","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1646217981,"ip_address":"","comment_id":336457,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1646150198","product_id":100013101,"comment_content":"试了一下把互斥锁改成读写锁， 中途会发生一个发送消息被两个接受者同时收到的场景， 导致最后发送者阻塞， 此时主线程的信道也阻塞了， 接受者协程执行完毕， 整体是死锁的情况。 那假如发送者和接收者都是无限循环， 而且多个接收者接收者接到同一份消息不会对业务有影响的情况下， 使用读写锁应该也是没有问题的？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554113,"discussion_content":"如果你用的是读写锁的话，读写锁中的读锁定操作之间是不互斥的。所以我估计是你这块的用法错了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646217981,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":335446,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1645521078,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1645521078","product_id":100013101,"comment_content":"条件变量就是解决并发中的同步问题，原理跟Java差不多。","like_count":0},{"had_liked":false,"id":321015,"user_name":"胡小涵","can_delete":false,"product_type":"c1","uid":2004538,"ip_address":"","ucode":"2E750C65EC282C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/96/3a/e06f8367.jpg","comment_is_top":false,"comment_ctime":1636619879,"is_pvip":false,"replies":[{"id":"116487","content":"因为核心需求不同。在你的例子只需要纯粹单向的生产-消费（这就是最简单的情况）。但在专栏的例子里，双方属于“秘密接触”，需要尽可能少的“露面”和“访问邮箱”。所以才需要互相通知。<br><br>需求决定代码。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1636627449,"ip_address":"","comment_id":321015,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1636619879","product_id":100013101,"comment_content":"func testCond() {<br>\tmu := sync.Mutex{}<br>\tcond := sync.NewCond(&amp;mu)<br>\ts := &quot;&quot;<br><br>\tgo func () {<br>\t\tfmt.Println(&quot;This is consumer&quot;)<br>\t\tfor {<br>\t\t\tmu.Lock()<br><br>\t\t\tfor len(s) == 0 {<br>\t\t\t\tcond.Wait()<br>\t\t\t}<br>\t\t\t&#47;&#47;time.Sleep(time.Second * 1)<br>\t\t\tfmt.Println(&quot;consumer, s:&quot;, s)<br>\t\t\ts = &quot;&quot;<br>\t\t\tmu.Unlock()<br>\t\t\tcond.Signal()<br>\t\t}<br>\t}()<br><br>\tgo func () {<br>\t\tfmt.Println(&quot;This is producer&quot;)<br>\t\tfor {<br>\t\t\tmu.Lock()<br>\t\t\tfor len(s) &gt; 0 {<br>\t\t\t\tcond.Wait()<br>\t\t\t}<br>\t\t\tfmt.Println(&quot;produce a string&quot;)<br>\t\t\ts = &quot;generate s resource&quot;<br>\t\t\tmu.Unlock()<br>\t\t\tcond.Signal()<br>\t\t}<br><br>\t}()<br><br>\ttime.Sleep(time.Second * 10)<br>}<br>==========================================<br>自己测的时候发现用一个Cond就可以满足生产者消费者的简单模型，谁能告诉我为什么例子一定要使用两个Cond？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530185,"discussion_content":"因为核心需求不同。在你的例子只需要纯粹单向的生产-消费（这就是最简单的情况）。但在专栏的例子里，双方属于“秘密接触”，需要尽可能少的“露面”和“访问邮箱”。所以才需要互相通知。\n\n需求决定代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636627449,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203751,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1586262595,"is_pvip":false,"replies":[{"id":"76917","content":"条件变量的特色是“协调”，而不是“互斥”。但是你也看到了，它是基于锁的。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1586747522,"ip_address":"","comment_id":203751,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1586262595","product_id":100013101,"comment_content":"看了你下面的留言 感觉条件变量主要是为了避免互斥锁或者读写锁 锁竞争条件","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490951,"discussion_content":"条件变量的特色是“协调”，而不是“互斥”。但是你也看到了，它是基于锁的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586747522,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203748,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1586262352,"is_pvip":false,"replies":[{"id":"76918","content":"因为在解锁之前发送通知没有什么意义。一般情况下，别的地方都阻塞着呢，谁又能妥善处理这种通知呢。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1586747682,"ip_address":"","comment_id":203748,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1586262352","product_id":100013101,"comment_content":"今天主要讲的go的同步 条件变量<br>总的来说我又去看了一下unix环境高级编程的条件变量感觉二者一样<br>这两个方法并不需要受到互斥锁的保护，我们也最好不要在解锁互斥锁之前调用它们<br>关于这个结论的我猜测是如果没有解锁 某个goroutine 还没解锁又被唤醒了 但是又不是它想要的共享状态 然后又加锁 又进入wait导致死锁？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490950,"discussion_content":"因为在解锁之前发送通知没有什么意义。一般情况下，别的地方都阻塞着呢，谁又能妥善处理这种通知呢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586747682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":197288,"user_name":"给力","can_delete":false,"product_type":"c1","uid":1113645,"ip_address":"","ucode":"646EE4AFC17224","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/2d/2c9177ca.jpg","comment_is_top":false,"comment_ctime":1585366823,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585366823","product_id":100013101,"comment_content":"sync.Cond类型中的公开字段L是做什么用的？我们可以在使用条件变量的过程中改变这个字段的值吗？<br>想要看他有什么用？就得看看他是什么？<br>这是个Locker，那么也是通过它来控制共享资源的并发访问。<br><br>在使用过程中能不能修改？<br>这个主要得看都哪些方法使用了，如何使用的。<br>func (c *Cond) Wait() {<br>\tc.checker.check()<br>\tt := runtime_notifyListAdd(&amp;c.notify)<br>\tc.L.Unlock()<br>\truntime_notifyListWait(&amp;c.notify, t)<br>\tc.L.Lock()<br>}<br>func (c *Cond) Signal() {<br>\tc.checker.check()<br>\truntime_notifyListNotifyOne(&amp;c.notify)<br>}<br>func (c *Cond) Broadcast() {<br>\tc.checker.check()<br>\truntime_notifyListNotifyAll(&amp;c.notify)<br>}<br><br>很显然在wait时使用了以及外部逻辑使用了。<br>随意更改这个值有可能引发panic<br>","like_count":0},{"had_liked":false,"id":197273,"user_name":"给力","can_delete":false,"product_type":"c1","uid":1113645,"ip_address":"","ucode":"646EE4AFC17224","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/2d/2c9177ca.jpg","comment_is_top":false,"comment_ctime":1585366294,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585366294","product_id":100013101,"comment_content":"总结一下就是：<br>条件变量要依赖锁<br>有三个方法：Wait、Signal、Broadcast<br><br>代码实例：<br>package mymutex<br><br>import (<br>\t&quot;fmt&quot;<br>\t&quot;sync&quot;<br>\t&quot;time&quot;<br>)<br><br>&#47;*<br>条件变量的作用？<br>\t条件变量并不是被用来保护临界区和共享资源的，它是用于协调想要访问共享资源的那些线程的。<br>\t当共享资源的状态发生变化时，它可以被用来通知被互斥锁阻塞的线程<br><br>条件变量怎样与互斥锁配合使用？<br>\t条件变量的初始化离不开互斥锁，并且它的方法有的也是基于互斥锁的。<br>\t条件变量提供的方法有三个：等待通知（wait）、单发通知（signal）和广播通知（broadcast）。<br>*&#47;<br><br>var mailbox uint8<br>var lock sync.RWMutex<br>var sendCond *sync.Cond = nil<br>var recvCond *sync.Cond = nil<br><br>var WG sync.WaitGroup<br><br>func init() {<br>\tfmt.Println(&quot;---------welcome mycond init----------&quot;)<br>\tsendCond = sync.NewCond(&amp;lock)<br>\trecvCond = sync.NewCond(lock.RLocker())<br>}<br><br>func SendFunc(num int) {<br>\tdefer WG.Done()<br><br>\tfor i:=0 ; i&lt;num ;i++ {<br>\t\tlock.Lock()<br>\t\tfmt.Println(&quot;mycond SendFunc lock...&quot;)<br>\t\tfor mailbox == 1 {<br>\t\t\tfmt.Println(&quot;mycond SendFunc wait...&quot;,num)<br>\t\t\tsendCond.Wait()<br>\t\t}<br>\t\tmailbox = 1<br>\t\tlock.Unlock()<br>\t\tfmt.Println(&quot;mycond SendFunc unlock...&quot;)<br>\t\trecvCond.Broadcast()<br>\t\t&#47;&#47;recvCond.Signal()<br>\t\tfmt.Println(&quot;mycond SendFunc recvCond Broadcast...&quot;)<br>\t}<br><br>}<br><br>func RecvFunc(goNum int) {<br>\tdefer WG.Done()<br>\tWG.Add(1)<br>\tlock.RLock()<br>\tfmt.Println(&quot;mycond RecvFunc lock...&quot;,goNum)<br>\tfor mailbox == 0 {<br>\t\tfmt.Println(&quot;mycond RecvFunc wait...&quot;,goNum)<br>\t\trecvCond.Wait()<br>\t}<br>\tmailbox = 0<br>\tlock.RUnlock()<br>\tfmt.Println(&quot;mycond RecvFunc unlock...&quot;,goNum)<br>\tsendCond.Signal()<br>\tfmt.Println(&quot;mycond RecvFunc sendCond Signal...&quot;,goNum)<br>}<br><br>func RecvFuncArr(arrLen int){<br>\tfor i:=0;i&lt;arrLen;i++{<br>\t\tgo RecvFunc(i)<br>\t}<br>}<br><br>func TestMyCond() {<br>\tconst num = 4<br>\tfmt.Println(&quot;---------mycond TestMyCond----------&quot;)<br>\tWG.Add(1)<br>\tRecvFuncArr(num)<br>\ttime.Sleep(500 * time.Millisecond)<br>\tgo SendFunc(num)<br>}<br><br>","like_count":0},{"had_liked":false,"id":196679,"user_name":"Lywane","can_delete":false,"product_type":"c1","uid":1446512,"ip_address":"","ucode":"2B0027AA069CE9","user_header":"https://static001.geekbang.org/account/avatar/00/16/12/70/10faf04b.jpg","comment_is_top":false,"comment_ctime":1585302293,"is_pvip":false,"replies":[{"id":"74609","content":"这里没有问题啊，等“不为0”就是“等着有新的情报”，“再把它的值变为0”就是“拿走情报”。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1585391992,"ip_address":"","comment_id":196679,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585302293","product_id":100013101,"comment_content":"它们都在等mailbox变量的值不为0的时候再把它的值变为0，这就相当于有多个人在等着我向信箱里放置情报。<br><br>老师这里不对吧，上一讲说的是`mailbox 代表信箱。0代表信箱是空的，1代表信箱是满的`。大家等着把mailbox设置为0，应该是都在等着拿信","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489357,"discussion_content":"这里没有问题啊，等“不为0”就是“等着有新的情报”，“再把它的值变为0”就是“拿走情报”。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585391992,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170064,"user_name":"Alan","can_delete":false,"product_type":"c1","uid":1198125,"ip_address":"","ucode":"9C66CBCFB3A109","user_header":"https://static001.geekbang.org/account/avatar/00/12/48/2d/7a3d42fb.jpg","comment_is_top":false,"comment_ctime":1578500559,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578500559","product_id":100013101,"comment_content":"demo61中的代码可以优化一下，去除发送者的defer语句和一行管道接收语句","like_count":0},{"had_liked":false,"id":160519,"user_name":"疯琴","can_delete":false,"product_type":"c1","uid":1099379,"ip_address":"","ucode":"82ACAA4A27753D","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/73/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1575968191,"is_pvip":false,"replies":[{"id":"61264","content":"先说第二点吧，真正的谁先谁后是在底层调度的。所以我们很难干涉。很可能你感觉是A先B后，到了实际调度的时候却是B先A后。另外，条件变量的行为规范就是如此。所以记住就好了。<br><br>关于第一个问题，我又看了一下示例代码。在 demo61.go中确实是为了演示用法的。因为那里只有单发单收，所以不会有问题。而在demo62.go中就全是基于互斥锁了，那里是单发多收的。你可以看一下文章中每一段对应的是哪一个源码文件。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1575975391,"ip_address":"","comment_id":160519,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1575968191","product_id":100013101,"comment_content":"wait的原理讲解很清晰。<br><br>请问老师两个问题：<br>1. 收信人也修改了mailbox，为什么不用写锁？我试了一下，如果把收信人分成两个goroutine，一个循环2次另一个循环3次，有可能两个收信人先后连续收了信，这样最后一步是发信人发信。recvCond.Signal()只唤醒一个收信人，为什么会有两个收信人先后连续收信呢？我把recvCond改成用写锁就恢复正常了。用写锁是为了演示一下获取写锁的方法么？<br>package main<br><br>import (<br>\t&quot;log&quot;<br>\t&quot;sync&quot;<br>\t&quot;time&quot;<br>)<br><br>func main() {<br>\tvar mailbox uint8<br>\tvar lock sync.RWMutex<br>\tsendCond := sync.NewCond(&amp;lock)<br>\trecvCond := sync.NewCond(lock.RLocker())<br><br>\tsign := make(chan struct{}, 3)<br>\tmax := 5<br><br>\t&#47;&#47; 发信<br>\tgo func(max int) {<br>\t\tdefer func() {<br>\t\t\tsign &lt;- struct{}{}<br>\t\t}()<br><br>\t\tfor i := 1; i &lt;= max; i++ {<br>\t\t\ttime.Sleep(time.Millisecond * 500)<br>\t\t\tlock.Lock()<br>\t\t\tfor mailbox == 1 {<br>\t\t\t\tsendCond.Wait()<br>\t\t\t}<br>\t\t\tlog.Printf(&quot;sender [%d]: the mail box is empty.&quot;, i)<br>\t\t\tmailbox = 1<br>\t\t\tlog.Printf(&quot;sender [%d]: the letter has been send.&quot;, i)<br>\t\t\tlock.Unlock()<br>\t\t\trecvCond.Signal()<br>\t\t}<br>\t}(max)<br><br>\t&#47;&#47; 收信<br>\tgo func(max int) {<br>\t\tdefer func() {<br>\t\t\tsign &lt;- struct{}{}<br>\t\t}()<br>\t\tfor j := 1; j &lt;= max; j++ {<br>\t\t\ttime.Sleep(time.Millisecond * 500)<br>\t\t\tlock.RLock()<br>\t\t\tfor mailbox == 0 {<br>\t\t\t\trecvCond.Wait()<br>\t\t\t}<br>\t\t\tlog.Printf(&quot;receiver [%d]: the mail box is full.&quot;, j)<br>\t\t\tmailbox = 0<br>\t\t\tlog.Printf(&quot;receiver [%d]: the letter has been received.&quot;, j)<br>\t\t\tlock.RUnlock()<br>\t\t\tsendCond.Signal()<br>\t\t}<br>\t}(2)<br><br>\t&#47;&#47; 收信<br>\tgo func(max int) {<br>\t\tdefer func() {<br>\t\t\tsign &lt;- struct{}{}<br>\t\t}()<br>\t\tfor j := 1; j &lt;= max; j++ {<br>\t\t\ttime.Sleep(time.Millisecond * 500)<br>\t\t\tlock.RLock()<br>\t\t\tfor mailbox == 0 {<br>\t\t\t\trecvCond.Wait()<br>\t\t\t}<br>\t\t\tlog.Printf(&quot;receiver [%d]: the mail box is full.&quot;, j)<br>\t\t\tmailbox = 0<br>\t\t\tlog.Printf(&quot;receiver [%d]: the letter has been received.&quot;, j)<br>\t\t\tlock.RUnlock()<br>\t\t\tsendCond.Signal()<br>\t\t}<br>\t}(3)<br><br>\t&lt;-sign<br>\t&lt;-sign<br>\t&lt;-sign<br><br>\tlog.Println(mailbox)<br>}<br>2. “当通知被发送的时候，如果没有任何 goroutine 需要被唤醒，那么该通知就会立即失效。”这一点我没有理解。我让收信人启动更晚一点，也就是发信人执行Signal()的时候收信人还没有Wait()，但是依然正常执行了。","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477399,"discussion_content":"先说第二点吧，真正的谁先谁后是在底层调度的。所以我们很难干涉。很可能你感觉是A先B后，到了实际调度的时候却是B先A后。另外，条件变量的行为规范就是如此。所以记住就好了。\n\n关于第一个问题，我又看了一下示例代码。在 demo61.go中确实是为了演示用法的。因为那里只有单发单收，所以不会有问题。而在demo62.go中就全是基于互斥锁了，那里是单发多收的。你可以看一下文章中每一段对应的是哪一个源码文件。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575975391,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155810,"user_name":"K_night","can_delete":false,"product_type":"c1","uid":1210679,"ip_address":"","ucode":"5A40239A1790DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/37/3316de0c.jpg","comment_is_top":false,"comment_ctime":1574759898,"is_pvip":false,"replies":[{"id":"59879","content":"你这样给我代码我没法判断啊。你都改了哪些地方？","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1574766879,"ip_address":"","comment_id":155810,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574759898","product_id":100013101,"comment_content":"send := func(id int, index int) {<br>\t\t&#47;&#47; defer func() {<br>\t\t&#47;&#47; \tsign &lt;- struct{}{}<br>\t\t&#47;&#47; }()<br>\t\tlock.Lock()<br>\t\twakeupNum := 0<br>\t\tlog.Printf(&quot;wait before wakeupNum: [%d]&quot;, wakeupNum)<br>\t\tfor msgbox == 1 {<br>\t\t\tfmt.Printf(&quot;wait before in for wakeupNum: [%d]&quot;, wakeupNum)<br>\t\t\t&#47;&#47; log.Printf(&quot;wait before in for wakeupNum: [%d]&quot;, wakeupNum)<br>\t\t\tsendCond.Wait()<br>\t\t\t&#47;&#47; log.Printf(&quot;other Broadcast&quot;)<br>\t\t\twakeupNum = 1<br>\t\t\tlog.Printf(&quot;wait after wakeupNum: [%d]&quot;, wakeupNum)<br>\t\t}<br>\t\tlog.Printf(&quot;sender: id:[%d] index:[%d] msgbox is empty&quot;, id, index)<br>\t\tlog.Printf(&quot;wakeupNum: [%d]&quot;, wakeupNum)<br>\t\tsendNum = wakeupNum<br>\t\tmsgbox = 1<br>\t\tlog.Printf(&quot;sender: id:[%d] index:[%d] mail has been send&quot;, id, index)<br>\t\tlock.Unlock()<br>\t\trecvCond.Broadcast()<br>\t}<br>for循环里面的代码被优化了吗。怎么没有执行呢。望老师解惑感谢","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475880,"discussion_content":"你这样给我代码我没法判断啊。你都改了哪些地方？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574766879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129987,"user_name":"xuery","can_delete":false,"product_type":"c1","uid":1027584,"ip_address":"","ucode":"F461B61BE06131","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/00/025f37e7.jpg","comment_is_top":false,"comment_ctime":1567347576,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1567347576","product_id":100013101,"comment_content":"和Java的Condition使用和原理基本一致","like_count":0},{"had_liked":false,"id":118538,"user_name":"党","can_delete":false,"product_type":"c1","uid":1071974,"ip_address":"","ucode":"EE531DB3EA124D","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/66/ad35bc68.jpg","comment_is_top":false,"comment_ctime":1564383252,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564383252","product_id":100013101,"comment_content":"看这函数的定义 找到了js的风格","like_count":0},{"had_liked":false,"id":117119,"user_name":"不记年","can_delete":false,"product_type":"c1","uid":1045945,"ip_address":"","ucode":"287E40C68356DC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/b9/888fe350.jpg","comment_is_top":false,"comment_ctime":1563971884,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563971884","product_id":100013101,"comment_content":"唤醒用的Signal方法","like_count":0},{"had_liked":false,"id":104807,"user_name":"大中华区低﻿端人口","can_delete":false,"product_type":"c1","uid":1065204,"ip_address":"","ucode":"6DFB6C8060E83E","user_header":"https://static001.geekbang.org/account/avatar/00/10/40/f4/3372aec6.jpg","comment_is_top":false,"comment_ctime":1560843601,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560843601","product_id":100013101,"comment_content":"还是在用for的第一点情况上懵逼","like_count":0},{"had_liked":false,"id":102688,"user_name":"糊李糊涂","can_delete":false,"product_type":"c1","uid":1197625,"ip_address":"","ucode":"E0F6064CBA32B1","user_header":"https://static001.geekbang.org/account/avatar/00/12/46/39/e545c885.jpg","comment_is_top":false,"comment_ctime":1560297309,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560297309","product_id":100013101,"comment_content":"看不懂，就结合例子再看一遍，就懂了","like_count":0},{"had_liked":false,"id":86074,"user_name":"🄽🄸🅇🅄🅂","can_delete":false,"product_type":"c1","uid":1000060,"ip_address":"","ucode":"853763C229A5AA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/7c/8ef14715.jpg","comment_is_top":false,"comment_ctime":1555308585,"is_pvip":false,"replies":[{"id":"30916","content":"你需要展示你的代码。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1555313598,"ip_address":"","comment_id":86074,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1555308585","product_id":100013101,"comment_content":"请教老师一个问题: <br>demo62.go中, 收信只是读数据, 可是为什么使用RLock()和RUnlock()就报错, 而必须要使用Lock()和Ulock()呢?","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446885,"discussion_content":"你需要展示你的代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555313598,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1603571,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKgNge1sNXIWCFeUOa53cU5Glfw24sjxibBxTiaTb45LmU9bRDlDgBib9goFZXmoKwXTOJ4JMvVHHbiaA/132","nickname":"潘林林","note":"","ucode":"31576141FE4A1D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411101,"discussion_content":"因为有多个消费者，每个消费者都需要消耗满max个消息，才能退出，不然就阻塞在wait那行，但是由于读读不互斥，导致了消费者少消费了，形成阻塞\n正常情况：\n生产者生产max个消息\n消费者1消费max个消息\n消费者2消费max个消息\n假设：\n生产1个消息，发送通知\n消费者1收到消息，率先完成操作，并设置mailbox=0，进入下一轮循环并wait\n消费者2收到消息，判断mailbox不是1，重新进入wait，还在当前循环\n此时 生产了一个消息，消费者1消费了一次消息，消费者2没有消费消息，剩余max-1个消息可发，消费者1需要消费max-1个，消费者2需要消费max个。\n很明显生产者可以生产的消息不够消费者2消费，这导致消费者2最后阻塞在wait里面，从而无法触发defer里面的写channel\n再来看主协程，需要消费3个channel消息才能退出否则一直阻塞，但是消费者2没有给channel生产消息，所有主协程和消费者2互相阻塞造成死锁了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635849810,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1157472,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a9/60/c4700e74.jpg","nickname":"ssikiki","note":"","ucode":"3C092E1C0C8753","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":255,"discussion_content":"不明白demo62为什么不用读写锁了， 求解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561362437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1157472,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a9/60/c4700e74.jpg","nickname":"ssikiki","note":"","ucode":"3C092E1C0C8753","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":254,"discussion_content":"demo62\nvar lock sync.Mutex -> var lock sync.RWMutex\nrecvCond := sync.NewCond(&amp;lock)  ->  recvCond := sync.NewCond(lock.RLocker())\n还有recv函数\nlock.Lock() -> lock.RLock()\nlock.Unlock() -> lock.RUnlock()\n\n最后报\nfatal error: all goroutines are asleep - deadlock!\n\ngoroutine 1 [chan receive]:\nmain.main()\n\t...src/puzzlers/article23/q3/demo62.go:84 +0x28e","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561362168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84299,"user_name":"🐻","can_delete":false,"product_type":"c1","uid":1043072,"ip_address":"","ucode":"534EDAD496A0E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ea/80/8759e4c1.jpg","comment_is_top":false,"comment_ctime":1554822176,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554822176","product_id":100013101,"comment_content":"@云学，看锁的类型吧。如果是读锁的话，都能够上锁成功。如果是互斥锁的话，只有一个能够上锁成功，其他的继续等待。","like_count":0},{"had_liked":false,"id":82746,"user_name":"Geek_7b1949","can_delete":false,"product_type":"c1","uid":1437057,"ip_address":"","ucode":"DC0B19ACEC5E7A","user_header":"","comment_is_top":false,"comment_ctime":1554295070,"is_pvip":false,"replies":[{"id":"29960","content":"我原话不是这么说的吧。我说的是不先加锁的话，调用基于此锁的条件变量的Wait方法时会引发不可恢复的panic。因为Wait方法会先解锁，而解锁还没锁住的锁就会引发panic。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1554346847,"ip_address":"","comment_id":82746,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554295070","product_id":100013101,"comment_content":"关于第一个问题，有个疑问，文中说，如果不先加锁，wait方法中解锁，很容易造成wait方法对加锁的锁重复加锁从而造成goroutine阻塞，但是在wait方法调用之前，不是同样也会造成这个问题吗，也有可能在还没有走到wait的时候造成goroutine的阻塞呀，求解答","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445708,"discussion_content":"我原话不是这么说的吧。我说的是不先加锁的话，调用基于此锁的条件变量的Wait方法时会引发不可恢复的panic。因为Wait方法会先解锁，而解锁还没锁住的锁就会引发panic。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554346847,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":63300,"user_name":"虢國技醬","can_delete":false,"product_type":"c1","uid":1056807,"ip_address":"","ucode":"5A192262AA037E","user_header":"https://static001.geekbang.org/account/avatar/00/10/20/27/a6932fbe.jpg","comment_is_top":false,"comment_ctime":1548319474,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548319474","product_id":100013101,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":62585,"user_name":"奋斗","can_delete":false,"product_type":"c1","uid":1365112,"ip_address":"","ucode":"6AC3BD90617F13","user_header":"https://static001.geekbang.org/account/avatar/00/14/d4/78/53d93c43.jpg","comment_is_top":false,"comment_ctime":1548117598,"is_pvip":true,"replies":[{"id":"25242","content":"对，两两对应。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1551180989,"ip_address":"","comment_id":62585,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1548117598","product_id":100013101,"comment_content":"Java的notify和notifyall?","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437267,"discussion_content":"对，两两对应。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551180989,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":51998,"user_name":"再见小飞侠","can_delete":false,"product_type":"c1","uid":1170151,"ip_address":"","ucode":"33DFE28B8E6ACE","user_header":"https://static001.geekbang.org/account/avatar/00/11/da/e7/6feaa540.jpg","comment_is_top":false,"comment_ctime":1545291496,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545291496","product_id":100013101,"comment_content":"@云学<br>有个疑问，broadcast唤醒所有wait的goroutine，那他们被唤醒时需要去加锁(wait返回)，都能成功吗？<br><br>*sync.Mutex类型的值以及*sync.RWMutex类型的值都可以满足这个要求。<br><br>送信的例子中使用了RWMutex，回想RLock()读锁的特性：<br>(1)多个读操作可以同时进行。因此被唤醒时如果都是获取读锁的请求，他们都是可以成功返回的。<br>(2)但如果是WLock()写锁的情况，就会有等待最久的那个能完成获取锁的需求。<br><br><br>","like_count":0},{"had_liked":false,"id":40061,"user_name":"jacke","can_delete":false,"product_type":"c1","uid":1161209,"ip_address":"","ucode":"05F355E1FF88C5","user_header":"https://static001.geekbang.org/account/avatar/00/11/b7/f9/a8f26b10.jpg","comment_is_top":false,"comment_ctime":1542460015,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542460015","product_id":100013101,"comment_content":"老师，试了下、signal和broadcast唤醒放在解锁前不会死锁，为什么？解释下、留言里面有2个是同样疑问的","like_count":0},{"had_liked":false,"id":39110,"user_name":"Leon📷","can_delete":false,"product_type":"c1","uid":1219496,"ip_address":"","ucode":"B9BBD1EFAAE5A2","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/a8/6a391c66.jpg","comment_is_top":false,"comment_ctime":1542189555,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1542189555","product_id":100013101,"comment_content":"老师，我比较疑惑的是多个协程争夺资源，mutex 和RWmutex通过lock和unlock都可以做到同步，为什么一定要用条件变量，编写的这么复杂","like_count":0,"discussions":[{"author":{"id":1417824,"avatar":"https://static001.geekbang.org/account/avatar/00/15/a2/60/f3939ab4.jpg","nickname":"哈哼","note":"","ucode":"C1108406573D49","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":12430,"discussion_content":"不是为力同步，不是为了线程安全，是为了等你需要的条件满足。这和同步是两个场景","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1568529379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37950,"user_name":"heha37","can_delete":false,"product_type":"c1","uid":1008962,"ip_address":"","ucode":"13C180307574A6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/65/42/76eb78bd.jpg","comment_is_top":false,"comment_ctime":1541822523,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1541822523","product_id":100013101,"comment_content":"老师，mailbox使用原子操作是不是就不用for循环去检查了。","like_count":0,"discussions":[{"author":{"id":1073694,"avatar":"https://static001.geekbang.org/account/avatar/00/10/62/1e/8054e6db.jpg","nickname":"樂文💤","note":"","ucode":"CE4A46397521FC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3763,"discussion_content":"我的感觉是如果用signal唤醒 只唤醒一个线程的话 是可以用if的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564795028,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32711,"user_name":"卒迹","can_delete":false,"product_type":"c1","uid":1202095,"ip_address":"","ucode":"FAE1AA6038402C","user_header":"https://static001.geekbang.org/account/avatar/00/12/57/af/0b39cab7.jpg","comment_is_top":false,"comment_ctime":1539674764,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539674764","product_id":100013101,"comment_content":"老师问个问题：<br>demo62.go中<br>\t&#47;&#47; sendCond 代表专用于发信的条件变量。<br>\tsendCond := sync.NewCond(&amp;lock)<br>\t&#47;&#47; recvCond 代表专用于收信的条件变量。<br>\trecvCond := sync.NewCond(&amp;lock)<br>sendCond和recvCond拿到的条件变量都是一样的，那么可不可以只要一个公共的条件变量commCond来代替前面两个条件变量呢","like_count":0},{"had_liked":false,"id":32710,"user_name":"卒迹","can_delete":false,"product_type":"c1","uid":1202095,"ip_address":"","ucode":"FAE1AA6038402C","user_header":"https://static001.geekbang.org/account/avatar/00/12/57/af/0b39cab7.jpg","comment_is_top":false,"comment_ctime":1539674330,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1539674330","product_id":100013101,"comment_content":"老师问个问题：<br>var lock sync.RWMutex<br>sendCond := sync.NewCond(&amp;lock) <br>recvCond := sync.NewCond(lock.RLocker())<br>我想问的是<br>1 sendCond获取的是读锁还是写锁，还是两者都包含？<br>2 recvCond获取的是读锁还是写锁？","like_count":0,"discussions":[{"author":{"id":1603571,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKgNge1sNXIWCFeUOa53cU5Glfw24sjxibBxTiaTb45LmU9bRDlDgBib9goFZXmoKwXTOJ4JMvVHHbiaA/132","nickname":"潘林林","note":"","ucode":"31576141FE4A1D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411374,"discussion_content":"1.拿到的是静态类型为Locker类型的写锁，但是动态类型是RWMutex，动态值是RWMutex的默认值，可以通过类型断言获取到RWMutex的内容 l,_ := interface{}(sendCond.L).(*sync.RWMutex)\n2.读锁 而且不可被转化为sync.RWMutex \nlock.RLocker()返回的是rlocker的引用类型，rlocker是RWMutex的类型声明，要想把recvCond里面的锁转换成RWMutex类型 就需要先进行断言转换成rlocker，再强制转换成RWMutex，但是rlocker包内私有变量，外部转换不了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635909795,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1193874,"avatar":"https://static001.geekbang.org/account/avatar/00/12/37/92/961ba560.jpg","nickname":"授人以🐟，不如授人以渔","note":"","ucode":"BD53829E924B66","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372601,"discussion_content":"sendCond 拿到的是读写锁，在这个语义里面应该是更加偏向于具有写锁的特征；recvCond 拿到的是读锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620390531,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32431,"user_name":"cygnus","can_delete":false,"product_type":"c1","uid":1120452,"ip_address":"","ucode":"C60A86E3084754","user_header":"https://static001.geekbang.org/account/avatar/00/11/18/c4/e55fdc1c.jpg","comment_is_top":false,"comment_ctime":1539571133,"is_pvip":false,"replies":[{"id":"11824","content":"没错。改动他要跟谨慎。最好不要改，以防万一。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1539578131,"ip_address":"","comment_id":32431,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539571133","product_id":100013101,"comment_content":"思考题：sync.Cond类型中的公开字段L是用来保存NewCond方法传递进来的互斥锁的，这个锁是条件变量自己控制的，所以我们不能在使用过程中改变这个字段的值，否则可能会导致panic或死锁<br>","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426770,"discussion_content":"没错。改动他要跟谨慎。最好不要改，以防万一。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539578131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32429,"user_name":"Askerlve","can_delete":false,"product_type":"c1","uid":1178535,"ip_address":"","ucode":"BF29F9A8674507","user_header":"https://static001.geekbang.org/account/avatar/00/11/fb/a7/12c90699.jpg","comment_is_top":false,"comment_ctime":1539569300,"is_pvip":false,"replies":[{"id":"11823","content":"我稍后去看看哈，谢谢。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1539577597,"ip_address":"","comment_id":32429,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539569300","product_id":100013101,"comment_content":"老师总结中句子:&quot;sync.Mutex类型的值以及*sync.RWMutex类型的值&quot;sync.Mutex是不是少个&quot;*&quot;哇?","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426769,"discussion_content":"我稍后去看看哈，谢谢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539577597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}