{"id":603371,"title":"25 | 行为型：模版、策略和状态模式有什么区别？","content":"<p>你好，我是石川。</p><p>今天我们来说说设计模式中剩下的几种行为型模式。我个人觉得剩下这六种模式可以大致分为两类，一类是偏向“策略模型”的设计模式，这里包含了策略、状态和模版这三种模式。另外一大类是偏向“数据传递”的设计模式，这里就包含了中介、命令和职责链这几种模式。这些类别的模式，有什么共同和不同呢？我们先从它们各自的思想和实现来看看。</p><h2>策略模型类的行为模式</h2><p>首先，我们来看看策略、状态和模版这三种偏向“策略模型”的设计模式吧。</p><h3>策略模式</h3><p>先说策略模式（strategy），它的核心思想是<strong>在运行时基于场景选择策略</strong>。</p><p>我们可以举一个例子，我们的汽车轮胎适配就算是一种策略模式，比如在冰天雪地的西伯利亚，可以选择冬季轮胎；如果是平时用的买菜车，就选择普通轮胎；如果是去草原狂奔，就换上越野轮胎。</p><p><img src=\"https://static001.geekbang.org/resource/image/38/a0/3845e956583205f53257yy2d5e13f9a0.png?wh=1840x802\" alt=\"图片\"></p><p>下面，我们可以通过一个红绿灯程序来看一下这一概念的实现。在这个例子中，我们可以看到 交通控制（TrafficControl）就决定了运行时环境的上下文，它可以通过转换（ turn ）这个方法来切换不同的策略。红绿灯（TrafficLight）是一个抽象类的策略，它可以根据环境需要，延伸出具体类的策略。</p><pre><code class=\"language-javascript\">// encapsulation\nclass TrafficControl {\n&nbsp; turn(trafficlight) {\n&nbsp; &nbsp; return trafficlight.trafficcolor();\n&nbsp; }\n}\n\nclass TrafficLight {\n&nbsp; trafficcolor() {\n&nbsp; &nbsp; return this.colorDesc;\n&nbsp; }\n}\n\n// strategy 1\nclass RedLight extends TrafficLight {\n&nbsp; constructor() {\n&nbsp; &nbsp; super();\n&nbsp; &nbsp; this.colorDesc = \"Stop\";\n&nbsp; }\n}\n\n// strategy 2\nclass YellowLight extends TrafficLight {\n&nbsp; constructor() {\n&nbsp; &nbsp; super();\n&nbsp; &nbsp; this.colorDesc = \"Wait\";\n&nbsp; }\n}\n\n// strategy 3\nclass GreenLight extends TrafficLight {\n&nbsp; constructor() {\n&nbsp; &nbsp; super();\n&nbsp; &nbsp; this.colorDesc = \"Go\";\n&nbsp; }\n}\n\n// usage\nvar trafficControl = new TrafficControl();\n\nconsole.log(trafficControl.turn(new RedLight())); // Stop\nconsole.log(trafficControl.turn(new YellowLight())); // Wait\nconsole.log(trafficControl.turn(new GreenLight())); // Go\n</code></pre><!-- [[[read_end]]] --><h3>状态模式</h3><p>下面我们再来看看状态模式（state），它的核心概念是<strong>根据运行时状态的不同，切换不同的策略</strong>。所以我们可以说它是策略模式的一个延伸。</p><p>这里，我们可以拿酒店预定举个例子，比如我们都有在一些文旅类门户网站上预定酒店的经验。在预定的时候，通常有几种不同的状态，比如当我们下单支付前，订单状态可能是“未确认”，这时我们可以确认或删除，但是因为还没有预定成功，所以没有取消的选项。但是当我们已确认并完成支付，就没有再次确认或删除的动作了，这时，我们只能选择取消。再然后，一般很多酒店都规定只能在入住前24小时选择取消，而如果在临近入住的24小时之内，那么在这个区间内连取消的按钮可能都失效了。这时，我们只能选择入住或和客服沟通取消。这就是状态模式，也就是说程序依据不同运行时状态，做不同的策略反应。</p><p><img src=\"https://static001.geekbang.org/resource/image/f5/e9/f50e29919e11b1e765cb906e12fa6ee9.png?wh=1898x768\" alt=\"图片\"></p><p>同样，我们可以通过讲策略模式时的红绿灯案例做一些改造，加入状态 state，看看会发生什么。这里，我们可以看到每次当我们执行turn在做切换的时候，随着状态在红、黄、绿三种状态之间循环更新，红绿灯的指示也跟着更新。</p><pre><code class=\"language-javascript\">class TrafficControl {\n&nbsp; constructor() {\n&nbsp; &nbsp; this.states = [new GreenLight(), new RedLight(), new YellowLight()];\n&nbsp; &nbsp; this.current = this.states[0];\n&nbsp; }\n&nbsp; turn() {\n&nbsp; &nbsp; const totalStates = this.states.length;\n&nbsp; &nbsp; let currentIndex = this.states.findIndex(light =&gt; light === this.current);\n&nbsp; &nbsp; if (currentIndex + 1 &lt; totalStates) this.current = this.states[currentIndex + 1];\n&nbsp; &nbsp; else this.current = this.states[0];\n&nbsp; }\n&nbsp; desc() {\n&nbsp; &nbsp; return this.current.desc();\n&nbsp; }\n}\n\nclass TrafficLight {\n&nbsp; constructor(light) {\n&nbsp; &nbsp; this.light = light;\n&nbsp; }\n}\n\nclass RedLight extends TrafficLight {\n&nbsp; constructor() {\n&nbsp; &nbsp; super('red');\n&nbsp; }\n&nbsp; desc() {\n&nbsp; &nbsp; return 'Stop';\n&nbsp; }\n}\n\nclass YellowLight extends TrafficLight {\n&nbsp; constructor() {\n&nbsp; &nbsp; super('yellow');\n&nbsp; }\n&nbsp; desc() {\n&nbsp; &nbsp; return 'Wait';\n&nbsp; }\n}\n\nclass GreenLight extends TrafficLight {\n\tconstructor() {\n\t\tsuper('green');\n\t}\n\tdesc() {\n\t\treturn 'Go';\n\t}\n}\n\n// usage\nvar trafficControl = new TrafficControl();\nconsole.log(trafficControl.desc()); // 'Go'\ntrafficControl.turn();\nconsole.log(trafficControl.desc()); // 'Stop'\ntrafficControl.turn();\nconsole.log(trafficControl.desc()); // 'Wait'\n</code></pre><h3>模版模式</h3><p>最后，我们再来看看模版模式（template）。它的核心思想是在<strong>一个方法中定义一个业务逻辑模版，并将某些步骤推迟到子类中实现</strong>。所以它和策略模式有些类似。</p><p><img src=\"https://static001.geekbang.org/resource/image/4c/b4/4cec0c21c85ef26e140f3f60e0c8a3b4.png?wh=1724x884\" alt=\"图片\"></p><p>下面我们可以看一个实现的例子。在这个例子里，我们看到员工employee里的工作work就是一个模版，它里面的任务tasks是延迟到开发developer和设计designer两个子类中去实现的。这就是一个简单的模版模式的设计实现。</p><pre><code class=\"language-javascript\">class Employee {\n\tconstructor(name, salary) {\n\tthis.name = name;\n\tthis.salary = salary;\n\t}\n\twork() {\n\t\treturn `${this.name}负责${this.tasks()}`;\n\t}\n\tgetPaid() {\n\t\treturn `${this.name}薪资是${this.salary}`;\n\t}\n}\n\nclass Developer extends Employee {\n\tconstructor(name, salary) {\n\t\tsuper(name, salary);\n\t}\n\t// 细节由子类实现\n\ttasks() {\n\t\treturn '写代码';\n\t}\n}\n\nclass Designer extends Employee {\n\tconstructor(name, salary) {\n\t\tsuper(name, salary);\n\t}\n\t// 细节由子类实现\n\ttasks() {\n\t\treturn '做设计';\n\t}\n}\n\n// usage\nvar dev = new Developer('张三', 10000);\nconsole.log(dev.getPaid()); // '张三薪资是10000'\nconsole.log(dev.work()); // '张三负责写代码'\nvar designer = new Designer('李四', 11000);\nconsole.log(designer.getPaid()); // '李四薪资是11000'\nconsole.log(designer.work()); // '李四负责做设计'\n</code></pre><p>这里我先做个阶段性小结，从上面的例子中，我们可以看出，无论是策略、状态还是模版模式，它们都是基于某种“策略模型”来实现的。比如策略模式中的策略是基于上行文来切换；在状态模式中是根据状态来做切换；而最后在模版模式的例子中，某些策略模版在父类中定义，有些则在子类中实现。</p><h2>信息传递类的行为模式</h2><h3>中介模式</h3><p>中介者（mediator）模式的核心是<strong>使组件可以通过一个中心点相互交互</strong>。现实生活中，航空地面塔台就是一个例子，我们不可能让飞机之间交谈，而是通过地面控制台协调。地面塔台人员需要确保所有飞机都接收到安全飞行所需的信息，而不会撞到其他飞机。</p><p><img src=\"https://static001.geekbang.org/resource/image/be/c3/be0d7d818e8222b9caf19yyb7aff12c3.png?wh=1568x860\" alt=\"图片\"></p><p>我们还是通过一段代码，来看看这种模式的实现。塔台（TrafficTower）有着接收每架飞机坐标和获取某架飞机坐标方法。同时，飞机会登记自己的坐标和获取其它飞机的坐标。这些信息都是统一由塔台（TrafficTower）来管理的。</p><pre><code class=\"language-javascript\">class TrafficTower {\n&nbsp; #airplanes;\n&nbsp; constructor() {\n&nbsp; &nbsp; this.#airplanes = [];\n&nbsp; }\n\n&nbsp; register(airplane) {\n&nbsp; &nbsp; this.#airplanes.push(airplane);\n&nbsp; &nbsp; airplane.register(this);\n&nbsp; }\n\n&nbsp; requestCoordinates(airplane) {\n&nbsp; &nbsp; return this.#airplanes.filter(plane =&gt; airplane !== plane).map(plane =&gt; plane.coordinates);\n&nbsp; }\n}\n\nclass Airplane {\n&nbsp; constructor(coordinates) {\n&nbsp; &nbsp; this.coordinates = coordinates;\n&nbsp; &nbsp; this.trafficTower = null;\n&nbsp; }\n\n&nbsp; register(trafficTower) {\n&nbsp; &nbsp; this.trafficTower = trafficTower;\n&nbsp; }\n\n&nbsp; requestCoordinates() {\n&nbsp; &nbsp; if (this.trafficTower) return this.trafficTower.requestCoordinates(this);\n&nbsp; &nbsp; return null;\n&nbsp; }\n}\n\n// usage\nvar tower = new TrafficTower();\n\nvar airplanes = [new Airplane(10), new Airplane(20), new Airplane(30)];\nairplanes.forEach(airplane =&gt; {\n&nbsp; tower.register(airplane);\n});\n\nconsole.log(airplanes.map(airplane =&gt; airplane.requestCoordinates()))&nbsp;\n// [[20, 30], [10, 30], [10, 20]]\n</code></pre><h3>命令模式</h3><p>说完中介模式，我们再来看看命令模式，命令模式（command）允许我们<strong>将命令和发起命令操作的对象分离，</strong>这么做的好处是对于处理具有特定生命周期或者列队执行的命令，它会给我们更多的控制权。并且它还提供了将方法调用作为传参的能力，这样做的好处是可以让方法按需执行。</p><p><img src=\"https://static001.geekbang.org/resource/image/b9/0b/b90a7148e544424f0257bebe2c798b0b.png?wh=1374x558\" alt=\"图片\"></p><p>下面我们可以看看这种模式的样例。事务管理者OperationManager 接到了执行任务，会根据不同的命令，如启动行动（StartOperationCommand）、追踪行动状态（TrackOperationCommand）及取消行动CancelOperationCommand 等来执行。</p><pre><code class=\"language-javascript\">class OperationManager {\n&nbsp; constructor() {\n&nbsp; &nbsp; this.operations = [];\n&nbsp; }\n\n&nbsp; execute(command, ...args) {\n&nbsp; &nbsp; return command.execute(this.operations, ...args);\n&nbsp; }\n}\n\nclass Command {\n&nbsp; constructor(execute) {\n&nbsp; &nbsp; this.execute = execute;\n&nbsp; }\n}\n\nfunction StartOperationCommand(operation, id) {\n&nbsp; return new Command(operations =&gt; {\n&nbsp; &nbsp; operations.push(id);\n&nbsp; &nbsp; console.log(`你成功的启动了${operation}行动，代号${id}`);\n&nbsp; });\n}\n\nfunction CancelOperationCommand(id) {\n&nbsp; return new Command(operations =&gt; {\n&nbsp; &nbsp; operations = operations.filter(operation =&gt; operation.id !== id);\n&nbsp; &nbsp; console.log(`你取消了行动代号${id}`);\n&nbsp; });\n}\n\nfunction TrackOperationCommand(id) {\n&nbsp; return new Command(() =&gt;\n&nbsp; &nbsp; console.log(`你的行动代号${id}，目前正在执行中`)\n&nbsp; );\n}\n\nvar manager = new OperationManager();\n\nmanager.execute(new StartOperationCommand(\"猎豹\", \"318\"));\n// 返回：你成功的启动了猎豹行动，代号318\nmanager.execute(new TrackOperationCommand(\"318\"));\n// 返回：你的行动代号318，目前正在执行中\nmanager.execute(new CancelOperationCommand(\"318\"));\n// 返回：你取消了行动代号318\n</code></pre><p>命令模式可以在许多不同的情况下使用，特别是在创建重交互的UI上，比如编辑器里撤消的操作，因为它可以让UI对象和行为操作做到高度解耦。这种模式也可以用来代替回调函数，这也是因为它更支持模块化地将行为操作在对象之间传递。</p><h3>职责链模式</h3><p>最后，再来看下职责链模式，职责链模式（chain of responsibility）核心是<strong>将请求的发送者和接收者解耦</strong>。它的实现是通过一个对象链，链中的每个对象都可以处理请求或将其传递给下一个对象。其实在我们前面讲享元时，就提到过事件捕获和冒泡，JavaScript 内部就是用这个方式来处理事件捕获和冒泡的。同样在享元例子中，我们也提到过，jQuery 是通过职责链每次返回一个对象来做到的链接式调用。</p><p><img src=\"https://static001.geekbang.org/resource/image/3f/60/3f380690908991c6cdc61a70eec08960.png?wh=1800x576\" alt=\"图片\"></p><p>那么这种职责链是如何实现的呢？其实它的实现并不复杂，通过下面的例子我们可以看一下。你也可以很容易实现一个简化版的链式累加。我们通过累加（CumulativeSum）中的加法（add）可以循环上一个对象的结果和参数相加后的结果，作为返回值传给下一个方法。</p><pre><code class=\"language-javascript\">class CumulativeSum {\n&nbsp; constructor(intialValue = 0) {\n&nbsp; &nbsp; this.sum = intialValue;\n&nbsp; }\n\n&nbsp; add(value) {\n&nbsp; &nbsp; this.sum += value;\n&nbsp; &nbsp; return this;\n&nbsp; }\n}\n\n// usage\nvar sum = new CumulativeSum();\nconsole.log(sum.add(10).add(2).add(50).sum); // 62\n</code></pre><p>通过上面的三种模式的例子，我们都可以看到数据在不同对象中的传递。中介模式中，我们需要在网状的环境中，信息对多个对象中通过中介进行传输；命令模式中，我们看到了信息在对象和对象之间的传输；而最后，在职责链的模式中，我们又看到了信息在一个流水线中的传输。因此我说它们是偏向“数据传递”的设计模式。</p><h2>总结</h2><p>今天，我带你看了几种不同的行为型设计模式。到现在为止，我们所有的经典模式就都讲完了。</p><p>这一讲我们看的这些模式除了在JavaScript中会用到以外，在多数其它语言中也都适用，所以算是比较脱离语言本身的几种“普世”模式了。在之后的一讲中，我们会再次看几种在JavaScript中特有的一些设计模式。</p><h2>思考题</h2><p>如果你用过 Redux 的话，应该用过它的<a href=\"https://github.com/reduxjs/redux-devtools\">开发者工具</a>中的时间旅行式调试，它可以将应用程序的状态向前、向后或移动到任意时间点。你知道这个功能的实现用到了今天学到的哪（些）种行为型设计模式吗?</p><p>欢迎在留言区分享你的答案、交流学习心得或者提出问题，如果觉得有收获，也欢迎你把今天的内容分享给更多的朋友。我们下期再见！</p>","comments":[{"had_liked":false,"id":392014,"user_name":"Geek_5b4adc","can_delete":false,"product_type":"c1","uid":3913657,"ip_address":"广西","ucode":"DA49E85DA6AC72","user_header":"","comment_is_top":false,"comment_ctime":1719719956,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100122101,"comment_content":"策略模式倾向于策略和策略之间是独立的，由调用者选择；而状态模式可以叫状态机模式，倾向于状态和状态之间可以互相有条件的转换，模式隐含了转化关系。","like_count":0},{"had_liked":false,"id":365623,"user_name":"度衡","can_delete":false,"product_type":"c1","uid":1132308,"ip_address":"北京","ucode":"91EC65D452F481","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/14/2a08a0c8.jpg","comment_is_top":false,"comment_ctime":1672830633,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100122101,"comment_content":"策略模式，运行时基于场景选择不同的策略。对于redux调试而言，不同的数据状态相当于场景，而ui显示则相当于策略。","like_count":0}]}