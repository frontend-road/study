{"id":85241,"title":"06 | 用“等待-通知”机制优化循环等待","content":"<p>由上一篇文章你应该已经知道，在<strong>破坏占用且等待条件</strong>的时候，如果转出账本和转入账本不满足同时在文件架上这个条件，就用死循环的方式来循环等待，核心代码如下：</p><pre><code>// 一次性申请转出账户和转入账户，直到成功\nwhile(!actr.apply(this, target))\n  ；\n</code></pre><p>如果apply()操作耗时非常短，而且并发冲突量也不大时，这个方案还挺不错的，因为这种场景下，循环上几次或者几十次就能一次性获取转出账户和转入账户了。但是如果apply()操作耗时长，或者并发冲突量大的时候，循环等待这种方案就不适用了，因为在这种场景下，可能要循环上万次才能获取到锁，太消耗CPU了。</p><p>其实在这种场景下，最好的方案应该是：如果线程要求的条件（转出账本和转入账本同在文件架上）不满足，则线程阻塞自己，进入<strong>等待</strong>状态；当线程要求的条件（转出账本和转入账本同在文件架上）满足后，<strong>通知</strong>等待的线程重新执行。其中，使用线程阻塞的方式就能避免循环等待消耗CPU的问题。</p><p>那Java语言是否支持这种<strong>等待-通知机制</strong>呢？答案是：一定支持（毕竟占据排行榜第一那么久）。下面我们就来看看Java语言是如何支持<strong>等待-通知机制</strong>的。</p><h2>完美的就医流程</h2><p>在介绍Java语言如何支持等待-通知机制之前，我们先看一个现实世界里面的就医流程，因为它有着完善的等待-通知机制，所以对比就医流程，我们就能更好地理解和应用并发编程中的等待-通知机制。</p><!-- [[[read_end]]] --><p>就医流程基本上是这样：</p><ol>\n<li>患者先去挂号，然后到就诊门口分诊，等待叫号；</li>\n<li>当叫到自己的号时，患者就可以找大夫就诊了；</li>\n<li>就诊过程中，大夫可能会让患者去做检查，同时叫下一位患者；</li>\n<li>当患者做完检查后，拿检测报告重新分诊，等待叫号；</li>\n<li>当大夫再次叫到自己的号时，患者再去找大夫就诊。</li>\n</ol><p>或许你已经发现了，这个有着完美等待-通知机制的就医流程，不仅能够保证同一时刻大夫只为一个患者服务，而且还能够保证大夫和患者的效率。与此同时你可能也会有疑问，“这个就医流程很复杂呀，我们前面描述的等待-通知机制相较而言是不是太简单了？”那这个复杂度是否是必须的呢？这个是必须的，我们不能忽视等待-通知机制中的一些细节。</p><p>下面我们来对比看一下前面都忽视了哪些细节。</p><ol>\n<li>患者到就诊门口分诊，类似于线程要去获取互斥锁；当患者被叫到时，类似线程已经获取到锁了。</li>\n<li>大夫让患者去做检查（缺乏检测报告不能诊断病因），类似于线程要求的条件没有满足。</li>\n<li>患者去做检查，类似于线程进入等待状态；然后<strong>大夫叫下一个患者，这个步骤我们在前面的等待-通知机制中忽视了，这个步骤对应到程序里，本质是线程释放持有的互斥锁</strong>。</li>\n<li>患者做完检查，类似于线程要求的条件已经满足；<strong>患者拿检测报告重新分诊，类似于线程需要重新获取互斥锁，这个步骤我们在前面的等待-通知机制中也忽视了</strong>。</li>\n</ol><p>所以加上这些至关重要的细节，综合一下，就可以得出<strong>一个完整的等待-通知机制：线程首先获取互斥锁，当线程要求的条件不满足时，释放互斥锁，进入等待状态；当要求的条件满足时，通知等待的线程，重新获取互斥锁</strong>。</p><h2>用synchronized实现等待-通知机制</h2><p>在Java语言里，等待-通知机制可以有多种实现方式，比如Java语言内置的synchronized配合wait()、notify()、notifyAll()这三个方法就能轻松实现。</p><p>如何用synchronized实现互斥锁，你应该已经很熟悉了。在下面这个图里，左边有一个等待队列，同一时刻，只允许一个线程进入synchronized保护的临界区（这个临界区可以看作大夫的诊室），当有一个线程进入临界区后，其他线程就只能进入图中左边的等待队列里等待（相当于患者分诊等待）。<strong>这个等待队列和互斥锁是一对一的关系，每个互斥锁都有自己独立的等待队列。</strong></p><p><img src=\"https://static001.geekbang.org/resource/image/c6/d0/c6640129fde927be8882ca90981613d0.png?wh=1142*654\" alt=\"\"></p><center><span class=\"reference\">wait()操作工作原理图</span></center><p>在并发程序中，当一个线程进入临界区后，由于某些条件不满足，需要进入等待状态，Java对象的wait()方法就能够满足这种需求。如上图所示，当调用wait()方法后，当前线程就会被阻塞，并且进入到右边的等待队列中，<strong>这个等待队列也是互斥锁的等待队列</strong>。 线程在进入等待队列的同时，<strong>会释放持有的互斥锁</strong>，线程释放锁后，其他线程就有机会获得锁，并进入临界区了。</p><p>那线程要求的条件满足时，该怎么通知这个等待的线程呢？很简单，就是Java对象的notify()和notifyAll()方法。我在下面这个图里为你大致描述了这个过程，当条件满足时调用notify()，会通知等待队列（<strong>互斥锁的等待队列</strong>）中的线程，告诉它<strong>条件曾经满足过</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/1b/8c/1b3e999c300166a84f2e8cc7a4b8f78c.png?wh=1142*720\" alt=\"\"></p><center><span class=\"reference\">notify()操作工作原理图</span></center><p>为什么说是曾经满足过呢？因为<strong>notify()只能保证在通知时间点，条件是满足的</strong>。而被通知线程的<strong>执行时间点和通知的时间点</strong>基本上不会重合，所以当线程执行的时候，很可能条件已经不满足了（保不齐有其他线程插队）。这一点你需要格外注意。</p><p>除此之外，还有一个需要注意的点，被通知的线程要想重新执行，仍然需要获取到互斥锁（因为曾经获取的锁在调用wait()时已经释放了）。</p><p>上面我们一直强调wait()、notify()、notifyAll()方法操作的等待队列是互斥锁的等待队列，所以如果synchronized锁定的是this，那么对应的一定是this.wait()、this.notify()、this.notifyAll()；如果synchronized锁定的是target，那么对应的一定是target.wait()、target.notify()、target.notifyAll() 。而且wait()、notify()、notifyAll()这三个方法能够被调用的前提是已经获取了相应的互斥锁，所以我们会发现wait()、notify()、notifyAll()都是在synchronized{}内部被调用的。如果在synchronized{}外部调用，或者锁定的this，而用target.wait()调用的话，JVM会抛出一个运行时异常：<code>java.lang.IllegalMonitorStateException</code>。</p><h2>小试牛刀：一个更好地资源分配器</h2><p>等待-通知机制的基本原理搞清楚后，我们就来看看它如何解决一次性申请转出账户和转入账户的问题吧。在这个等待-通知机制中，我们需要考虑以下四个要素。</p><ol>\n<li>互斥锁：上一篇文章我们提到Allocator需要是单例的，所以我们可以用this作为互斥锁。</li>\n<li>线程要求的条件：转出账户和转入账户都没有被分配过。</li>\n<li>何时等待：线程要求的条件不满足就等待。</li>\n<li>何时通知：当有线程释放账户时就通知。</li>\n</ol><p>将上面几个问题考虑清楚，可以快速完成下面的代码。需要注意的是我们使用了：</p><pre><code>  while(条件不满足) {\n    wait();\n  }\n</code></pre><p>利用这种范式可以解决上面提到的<strong>条件曾经满足过</strong>这个问题。因为当wait()返回时，有可能条件已经发生变化了，曾经条件满足，但是现在已经不满足了，所以要重新检验条件是否满足。范式，意味着是经典做法，所以没有特殊理由不要尝试换个写法。后面在介绍“管程”的时候，我会详细介绍这个经典做法的前世今生。</p><pre><code>class Allocator {\n  private List&lt;Object&gt; als;\n  // 一次性申请所有资源\n  synchronized void apply(\n    Object from, Object to){\n    // 经典写法\n    while(als.contains(from) ||\n         als.contains(to)){\n      try{\n        wait();\n      }catch(Exception e){\n      }   \n    } \n    als.add(from);\n    als.add(to);  \n  }\n  // 归还资源\n  synchronized void free(\n    Object from, Object to){\n    als.remove(from);\n    als.remove(to);\n    notifyAll();\n  }\n}\n</code></pre><h2>尽量使用notifyAll()</h2><p>在上面的代码中，我用的是notifyAll()来实现通知机制，为什么不使用notify()呢？这二者是有区别的，<strong>notify()是会随机地通知等待队列中的一个线程，而notifyAll()会通知等待队列中的所有线程</strong>。从感觉上来讲，应该是notify()更好一些，因为即便通知所有线程，也只有一个线程能够进入临界区。但那所谓的感觉往往都蕴藏着风险，实际上使用notify()也很有风险，它的风险在于可能导致某些线程永远不会被通知到。</p><p>假设我们有资源A、B、C、D，线程1申请到了AB，线程2申请到了CD，此时线程3申请AB，会进入等待队列（AB分配给线程1，线程3要求的条件不满足），线程4申请CD也会进入等待队列。我们再假设之后线程1归还了资源AB，如果使用notify()来通知等待队列中的线程，有可能被通知的是线程4，但线程4申请的是CD，所以此时线程4还是会继续等待，而真正该唤醒的线程3就再也没有机会被唤醒了。</p><p>所以除非经过深思熟虑，否则尽量使用notifyAll()。</p><h2>总结</h2><p>等待-通知机制是一种非常普遍的线程间协作的方式。工作中经常看到有同学使用轮询的方式来等待某个状态，其实很多情况下都可以用今天我们介绍的等待-通知机制来优化。Java语言内置的synchronized配合wait()、notify()、notifyAll()这三个方法可以快速实现这种机制，但是它们的使用看上去还是有点复杂，所以你需要认真理解等待队列和wait()、notify()、notifyAll()的关系。最好用现实世界做个类比，这样有助于你的理解。</p><p>Java语言的这种实现，背后的理论模型其实是管程，这个很重要，不过你不用担心，后面会有专门的一章来介绍管程。现在你只需要能够熟练使用就可以了。</p><h2>课后思考</h2><p>很多面试都会问到，wait()方法和sleep()方法都能让当前线程挂起一段时间，那它们的区别是什么？现在你也试着回答一下吧。</p><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p><p></p>","comments":[{"had_liked":false,"id":74955,"user_name":"姜戈","can_delete":false,"product_type":"c1","uid":1058972,"ip_address":"","ucode":"45C4BE93C8E4CC","user_header":"https://static001.geekbang.org/account/avatar/00/10/28/9c/73e76b19.jpg","comment_is_top":false,"comment_ctime":1552321747,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"1650819763411","product_id":100023901,"comment_content":"wait与sleep区别在于：<br>1. wait会释放所有锁而sleep不会释放锁资源.<br>2. wait只能在同步方法和同步块中使用，而sleep任何地方都可以.<br>3. wait无需捕捉异常，而sleep需要.<br><br>两者相同点：都会让渡CPU执行时间，等待再次调度！","like_count":385,"discussions":[{"author":{"id":1023750,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9f/06/287d77dd.jpg","nickname":"承香墨影","note":"","ucode":"4D6A4D6E1ED29F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":25070,"discussion_content":"wait也需要捕获异常","likes_number":30,"is_delete":false,"is_hidden":false,"ctime":1570411796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1339724,"avatar":"https://static001.geekbang.org/account/avatar/00/14/71/4c/2cefec07.jpg","nickname":"静水流深","note":"","ucode":"644F05EFBD2E7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5268,"discussion_content":"     * @param      timeout   the maximum time to wait in milliseconds.\n     * @throws  IllegalArgumentException      if the value of timeout is\n     *               negative.\n     * @throws  IllegalMonitorStateException  if the current thread is not\n     *               the owner of the object&#39;s monitor.\n     * @throws  InterruptedException if any thread interrupted the\n     *             current thread before or while the current thread\n     *             was waiting for a notification.  The <i>interrupted\n     *             status</i> of the current thread is cleared when\n     *             this exception is thrown.\n     * @see        java.lang.Object#notify()\n     * @see        java.lang.Object#notifyAll()\n     */\n    public final native void wait(long timeout) throws InterruptedException;","likes_number":17,"is_delete":false,"is_hidden":false,"ctime":1566124899,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1070581,"avatar":"https://static001.geekbang.org/account/avatar/00/10/55/f5/8d1588bd.jpg","nickname":"xfun","note":"","ucode":"A9A08E9EA6E13B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219792,"discussion_content":"wait是被锁对象的方法，sleep是Thread对象的方法。感觉两个没有可比性，就不是一类东西。","likes_number":12,"is_delete":false,"is_hidden":false,"ctime":1585809253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018706,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/52/6659dc1b.jpg","nickname":"黑米","note":"","ucode":"E7DBEA7867862A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391125,"discussion_content":"“wait无需捕捉异常，而sleep需要”这个谬论是哪里抄来的？我竟然看到很多人这样说。。。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1630306642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1222174,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a6/1e/09033d53.jpg","nickname":"我不懂技术","note":"","ucode":"BCED5E23C6FA20","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387943,"discussion_content":"wait我记得也要捕捉异常吧","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1628504478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1810156,"avatar":"","nickname":"poordickey","note":"","ucode":"2A436EC813AF97","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335687,"discussion_content":"另外两个线程接下来触发执行的方式也不同，一个是notify通知，一个是时间到了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1608273795,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75036,"user_name":"crazypokerk","can_delete":false,"product_type":"c1","uid":1158383,"ip_address":"","ucode":"9AAD5D9726E503","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/ef/494f56c3.jpg","comment_is_top":false,"comment_ctime":1552351875,"is_pvip":false,"replies":[{"id":"27480","content":"👍<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552397266,"ip_address":"","comment_id":75036,"utype":1}],"discussion_count":7,"race_medal":0,"score":"1019459601027","product_id":100023901,"comment_content":"wait()方法与sleep()方法的不同之处在于，wait()方法会释放对象的“锁标志”。当调用某一对象的wait()方法后，会使当前线程暂停执行，并将当前线程放入对象等待池中，直到调用了notify()方法后，将从对象等待池中移出任意一个线程并放入锁标志等待池中，只有锁标志等待池中的线程可以获取锁标志，它们随时准备争夺锁的拥有权。当调用了某个对象的notifyAll()方法，会将对象等待池中的所有线程都移动到该对象的锁标志等待池。<br>sleep()方法需要指定等待的时间，它可以让当前正在执行的线程在指定的时间内暂停执行，进入阻塞状态，该方法既可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让低优先级的线程得到执行机会。但是sleep()方法不会释放“锁标志”，也就是说如果有synchronized同步块，其他线程仍然不能访问共享数据。","like_count":237,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442785,"discussion_content":"👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552397266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1649057,"avatar":"https://static001.geekbang.org/account/avatar/00/19/29/a1/41607383.jpg","nickname":"hello","note":"","ucode":"4F42DAA5DB5C38","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375027,"discussion_content":"评论中的“对象等待池”应该就是文中提到的“互斥锁等待队列&#34;，那评论中的&#34;锁标志等待池&#34; 在文中是不是没体现出来呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621438680,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1649057,"avatar":"https://static001.geekbang.org/account/avatar/00/19/29/a1/41607383.jpg","nickname":"hello","note":"","ucode":"4F42DAA5DB5C38","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":379545,"discussion_content":"对象等待池在左边，锁标志等待池（调用过wait()方法的）在右边\n看老师的第一张图 wait()指向的箭头在右边\n第二张图notify()指向的也是右边","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623945933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":375027,"ip_address":""},"score":379545,"extra":""}]},{"author":{"id":1322636,"avatar":"https://static001.geekbang.org/account/avatar/00/14/2e/8c/b261e15a.jpg","nickname":"张滔","note":"","ucode":"87ABAFF0E861E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347257,"discussion_content":"锁标志等待池和从未获得过锁而进入的等待队列是否是同一个地方？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612184088,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1322636,"avatar":"https://static001.geekbang.org/account/avatar/00/14/2e/8c/b261e15a.jpg","nickname":"张滔","note":"","ucode":"87ABAFF0E861E0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358471,"discussion_content":"我理解的应该是尝试获取锁但是失败了的线程会进入锁标志池而不是从未获得过锁的线程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615987536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":347257,"ip_address":""},"score":358471,"extra":""},{"author":{"id":1107153,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e4/d1/002f9955.jpg","nickname":"小马哥","note":"","ucode":"376833AC2A1589","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1322636,"avatar":"https://static001.geekbang.org/account/avatar/00/14/2e/8c/b261e15a.jpg","nickname":"张滔","note":"","ucode":"87ABAFF0E861E0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371230,"discussion_content":"一个是就绪队列，一个是等待队列，如果notify唤醒了，就从等待队列移入就绪队列","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1619689639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":347257,"ip_address":""},"score":371230,"extra":""}]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292739,"discussion_content":"wait可以被唤醒；sleep只能等待，或者中断","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595320894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74976,"user_name":"Home","can_delete":false,"product_type":"c1","uid":1032373,"ip_address":"","ucode":"AAE2C3E539CA96","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c0/b5/bd64c1ac.jpg","comment_is_top":false,"comment_ctime":1552345879,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"735991753495","product_id":100023901,"comment_content":"补充一下姜戈同学回答；1 sleep是Thread的方法，而wait是Object类的方法；2：sleep方法调用的时候必须指定时间","like_count":171},{"had_liked":false,"id":75440,"user_name":"wang","can_delete":false,"product_type":"c1","uid":1161200,"ip_address":"","ucode":"5D569805C6A923","user_header":"https://static001.geekbang.org/account/avatar/00/11/b7/f0/a570f68a.jpg","comment_is_top":false,"comment_ctime":1552398092,"is_pvip":false,"replies":[{"id":"27584","content":"高手高手，让我写也这不这样好👍👍👍👍👍<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552448007,"ip_address":"","comment_id":75440,"utype":1}],"discussion_count":18,"race_medal":0,"score":"521243440908","product_id":100023901,"comment_content":"public class MyLock {<br>&#47;&#47; 测试转账的main方法<br>public static void main(String[] args) throws InterruptedException {<br>    Account src = new Account(10000);<br>    Account target = new Account(10000);<br>    CountDownLatch countDownLatch = new CountDownLatch(9999);<br>    for (int i = 0; i &lt; 9999; i++) {<br>        new Thread(()-&gt;{<br>            src.transactionToTarget(1,target);<br>        countDownLatch.countDown();<br>        }).start();<br>    }<br>    countDownLatch.await();<br>    System.out.println(&quot;src=&quot;+src.getBanalce() );<br>    System.out.println(&quot;target=&quot;+target.getBanalce() );<br>}<br>static class Account{ &#47;&#47;账户类<br>    public Account(Integer banalce) {<br>        this.banalce = banalce;<br>    }<br>    private Integer banalce;<br>    public void transactionToTarget(Integer money,Account target){&#47;&#47;转账方法<br>        Allocator.getInstance().apply(this,target);<br>        this.banalce -= money;<br>        target.setBanalce(target.getBanalce()+money);<br>        Allocator.getInstance().release(this,target);<br>    }<br>    public  Integer getBanalce() {<br>        return banalce;<br>    }<br>    public void setBanalce(Integer banalce) {<br>        this.banalce = banalce;<br>    }<br>}<br>static class Allocator { &#47;&#47;单例锁类<br>    private Allocator(){}<br>    private List&lt;Account&gt; locks = new ArrayList&lt;&gt;();<br>    public  synchronized void apply(Account src,Account tag){<br>        while (locks.contains(src)||locks.contains(tag)) {<br>            try {<br>                this.wait();<br>            } catch (InterruptedException e) {<br>            }<br>        }<br>        locks.add(src);<br>        locks.add(tag);<br>    }<br>    public synchronized void release(Account src,Account tag){<br>        locks.remove(src);<br>        locks.remove(tag);<br>        this.notifyAll();<br>    }<br>    public static  Allocator getInstance(){<br>        return AllocatorSingle.install;<br>    }<br>    static class AllocatorSingle{<br>        public static Allocator install = new Allocator();<br>    }<br>}<br>}","like_count":121,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442895,"discussion_content":"高手高手，让我写也这不这样好👍👍👍👍👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552448007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1178008,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f9/98/95b13446.jpg","nickname":"Jimbol","note":"","ucode":"8D9190B3B3E08B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8314,"discussion_content":"厉害厉害，提一点优化意见：把allocator 里的List 换成Set ","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1567914966,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1533266,"avatar":"https://static001.geekbang.org/account/avatar/00/17/65/52/07c09c7f.jpg","nickname":"josancpp","note":"","ucode":"0CDC39B3E716A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":274973,"discussion_content":"transactionToTarget最好加上锁。\n虽然，transactionToTarget不会出现两个线程同时操作共享变量balance\n但是，还是会存在两个线程可以同时操作balance  。 transactionToTarget+setBlance\n","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1590639818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181486,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/2e/878d3c92.jpg","nickname":"木木","note":"","ucode":"E82C58AF2604ED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":266394,"discussion_content":"transactionToTarget 使用 try-finally来加锁和解锁会好一点。以防万一","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1589508516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1023101,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9c/7d/774e07f9.jpg","nickname":"study的程序员","note":"","ucode":"E5AE9037D24429","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386841,"discussion_content":"锁粒度太大了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627832071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2410092,"avatar":"https://static001.geekbang.org/account/avatar/00/24/c6/6c/a400175a.jpg","nickname":"FARO_Z","note":"","ucode":"B33BCC36C2A74E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1023101,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9c/7d/774e07f9.jpg","nickname":"study的程序员","note":"","ucode":"E5AE9037D24429","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540757,"discussion_content":"啊这，粒度还能更小吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640151116,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":386841,"ip_address":""},"score":540757,"extra":""}]},{"author":{"id":1810156,"avatar":"","nickname":"poordickey","note":"","ucode":"2A436EC813AF97","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335689,"discussion_content":"为什么用静态类，静态类的锁对象不是class吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608274302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2963287,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/dv9TS6icbzBEz8D6vXLrkSmER4TLRt6z2FKjo8b4XjibKydf7NWcwX4Fzf5XquGs88P25ApMBTWlcmGxibKzHuwtg/132","nickname":"Geek_837deb","note":"","ucode":"7F3462B4BE1DC5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1810156,"avatar":"","nickname":"poordickey","note":"","ucode":"2A436EC813AF97","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560497,"discussion_content":"单列 静态类，会在jvm 容器初始化的时候加载进去，每次使用的就是加载在容器的这个，也就是同一个对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649346712,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":335689,"ip_address":""},"score":560497,"extra":""}]},{"author":{"id":1213878,"avatar":"","nickname":"everyok22","note":"","ucode":"3A3304CCDC5C5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72834,"discussion_content":"transactionToTarget 不用加锁吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575534064,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1018552,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/b8/97d30803.jpg","nickname":"布拉格的鱼","note":"","ucode":"95145A236D6033","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1213878,"avatar":"","nickname":"everyok22","note":"","ucode":"3A3304CCDC5C5C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":82022,"discussion_content":"确实不用","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576311316,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":72834,"ip_address":""},"score":82022,"extra":""},{"author":{"id":1591405,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqqtFTbZcJcKq4icuCF8I3VoLMK3W8sx9askp6vrnY3DLtghI7svXpMIchn44ySY24ic4l8ADWFibLJA/132","nickname":"jack","note":"","ucode":"5EE763FEA7D755","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1018552,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/b8/97d30803.jpg","nickname":"布拉格的鱼","note":"","ucode":"95145A236D6033","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":270762,"discussion_content":"能解释一下不大佬","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590049399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":82022,"ip_address":""},"score":270762,"extra":""},{"author":{"id":1277081,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7c/99/4dac6ce6.jpg","nickname":"lakeslove","note":"","ucode":"65E14D29D3C981","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1591405,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqqtFTbZcJcKq4icuCF8I3VoLMK3W8sx9askp6vrnY3DLtghI7svXpMIchn44ySY24ic4l8ADWFibLJA/132","nickname":"jack","note":"","ucode":"5EE763FEA7D755","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318235,"discussion_content":"如果只执行这个方法的话，相当于开始用了lock，结尾用了unlock，多个线程执行的对象重合时，只能逐一等待执行。\n\n但是后面还有个set方法，应该把set方法改为private，或者把set方法和transactionToTarget方法都加锁。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1603685422,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":270762,"ip_address":""},"score":318235,"extra":""}]},{"author":{"id":1437158,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ed/e6/75a32708.jpg","nickname":"日拱一兵","note":"","ucode":"D6386E5CD7C061","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5382,"discussion_content":"countdown 最好在finally里面，以防万一 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566216254,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1018552,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/b8/97d30803.jpg","nickname":"布拉格的鱼","note":"","ucode":"95145A236D6033","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1437158,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ed/e6/75a32708.jpg","nickname":"日拱一兵","note":"","ucode":"D6386E5CD7C061","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":82024,"discussion_content":"`Allocator.getInstance().release(this,target);` 也应该放在 finally 里吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576311392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":5382,"ip_address":""},"score":82024,"extra":""}]},{"author":{"id":1451515,"avatar":"","nickname":"RookieLi","note":"","ucode":"10DDD196BB50E9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2644,"discussion_content":"这段代码是有问题的吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563816328,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1112183,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f8/77/a6d34ca5.jpg","nickname":"jackie","note":"","ucode":"01A4B7839CFABD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1451515,"avatar":"","nickname":"RookieLi","note":"","ucode":"10DDD196BB50E9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":33189,"discussion_content":"apply方法里while循环条件是不是缺个！ ？!locks.contains(src)||!locks.contains(tag)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571106819,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2644,"ip_address":""},"score":33189,"extra":""}]},{"author":{"id":1179759,"avatar":"https://static001.geekbang.org/account/avatar/00/12/00/6f/f0c0841d.jpg","nickname":"小吴同学","note":"","ucode":"29F8C0575E32AD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2186,"discussion_content":"发现一个问题，如果我把account 中 balance 改成int后，即使不使用allocator 也没有并发问题。 这是什么原因呢 ? 麻烦老师解释一下","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1563345810,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1025003,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a3/eb/d26459ae.jpg","nickname":"时光勿念","note":"","ucode":"72C8EC5A62C700","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1179759,"avatar":"https://static001.geekbang.org/account/avatar/00/12/00/6f/f0c0841d.jpg","nickname":"小吴同学","note":"","ucode":"29F8C0575E32AD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4130,"discussion_content":"我把相关变量全换成int类型，不使用allocator，没有你说的情况，每次执行结果都不一样，你把数写大点试试","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565157339,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2186,"ip_address":""},"score":4130,"extra":""}]}]},{"had_liked":false,"id":75935,"user_name":"虎虎❤️","can_delete":false,"product_type":"c1","uid":1086535,"ip_address":"","ucode":"157F261E80291A","user_header":"https://static001.geekbang.org/account/avatar/00/10/94/47/75875257.jpg","comment_is_top":false,"comment_ctime":1552493820,"is_pvip":false,"replies":[{"id":"27684","content":"不是一个队列<br>只唤醒右侧的队列<br>wait之后<br><br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552524241,"ip_address":"","comment_id":75935,"utype":1}],"discussion_count":18,"race_medal":0,"score":"435344190716","product_id":100023901,"comment_content":"困惑<br>1. 对于从来没有获得过互斥锁的线程 所在的等待队列 和 因为wait() 释放锁而进入了等待队列，是否是同一个等待队列？也就是图中左侧和右侧的是否为同一个队列？<br>2. notifyAll() 会发通知给等待队列中所有的线程吗？包括那些从未获得过互斥锁的线程吗？<br>3. 因为wait()被阻塞，而又因为notify()重新被唤醒后，代码是接着在wait()之后执行，还是重新执行 apply 方法？","like_count":101,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443096,"discussion_content":"不是一个队列\n只唤醒右侧的队列\nwait之后\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552524241,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1585829,"avatar":"https://static001.geekbang.org/account/avatar/00/18/32/a5/9868cd56.jpg","nickname":"southday","note":"","ucode":"4A8FB63D35F6E1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2057,"discussion_content":"可以看一下：\n1）Java 的锁池（Entry Set）和等待池（Wait Set）：https://www.cnblogs.com/tiancai/p/9371655.html\n\n2）Thread Synchronization - Monitors：https://www.artima.com/insidejvm/ed2/threadsynch.html","likes_number":15,"is_delete":false,"is_hidden":false,"ctime":1563212289,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1258455,"avatar":"https://static001.geekbang.org/account/avatar/00/13/33/d7/739e2f6d.jpg","nickname":"Utah","note":"","ucode":"AD5EEFE68706A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1585829,"avatar":"https://static001.geekbang.org/account/avatar/00/18/32/a5/9868cd56.jpg","nickname":"southday","note":"","ucode":"4A8FB63D35F6E1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367943,"discussion_content":"好文章","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1618499530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2057,"ip_address":""},"score":367943,"extra":""}]},{"author":{"id":1572264,"avatar":"","nickname":"Sundayge","note":"","ucode":"6A125D700CBDAB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":47081,"discussion_content":"线程获得锁之后，调用wait方法之后处于同步队列中，被唤醒时才到等待队列中重新争抢锁资源","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1573268990,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1572264,"avatar":"","nickname":"Sundayge","note":"","ucode":"6A125D700CBDAB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":47083,"discussion_content":"把右边那个等待队列叫做同步队列会好理解点","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1573269085,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1596987,"avatar":"https://static001.geekbang.org/account/avatar/00/18/5e/3b/845fb641.jpg","nickname":"jhren","note":"","ucode":"60F7CCEA1E2C88","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306283,"discussion_content":"收到NOTIFY后是不是右边的挪到左边？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1600239423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1107305,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e5/69/719ec5d0.jpg","nickname":"Jian","note":"","ucode":"17ED4919F22DEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1596987,"avatar":"https://static001.geekbang.org/account/avatar/00/18/5e/3b/845fb641.jpg","nickname":"jhren","note":"","ucode":"60F7CCEA1E2C88","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383700,"discussion_content":"是的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1626193358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":306283,"ip_address":""},"score":383700,"extra":""},{"author":{"id":2799796,"avatar":"","nickname":"Geek_887177","note":"","ucode":"110451CF569C80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1596987,"avatar":"https://static001.geekbang.org/account/avatar/00/18/5e/3b/845fb641.jpg","nickname":"jhren","note":"","ucode":"60F7CCEA1E2C88","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560464,"discussion_content":"没必要挪，还增加开销。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649337954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":306283,"ip_address":""},"score":560464,"extra":""}]},{"author":{"id":2028953,"avatar":"","nickname":"Geek3340","note":"","ucode":"C64D302CD53513","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290008,"discussion_content":"notifyAll以后右边等待的队列是重新去竞争获取锁是吧？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594300765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1542037,"avatar":"https://static001.geekbang.org/account/avatar/00/17/87/95/cba0a896.jpg","nickname":"卢","note":"","ucode":"B6A9F41AEE348C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2028953,"avatar":"","nickname":"Geek3340","note":"","ucode":"C64D302CD53513","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292240,"discussion_content":"应该是的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595151892,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":290008,"ip_address":""},"score":292240,"extra":""},{"author":{"id":1131027,"avatar":"https://static001.geekbang.org/account/avatar/00/11/42/13/860e176a.jpg","nickname":"外国肉夹馍","note":"","ucode":"00BADDCFEA92B8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2028953,"avatar":"","nickname":"Geek3340","note":"","ucode":"C64D302CD53513","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337670,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609036086,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":290008,"ip_address":""},"score":337670,"extra":""}]},{"author":{"id":1061466,"avatar":"https://static001.geekbang.org/account/avatar/00/10/32/5a/347570e6.jpg","nickname":"极客er","note":"","ucode":"43A30683884E2E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":252297,"discussion_content":"假设我们有资源 A、B、C、D，线程 1 申请到了 AB，线程 2 申请到了 CD，此时线程 3 申请 AB，会进入等待队列（AB 分配给线程 1，线程 3 要求的条件不满足），线程 4 申请 CD 也会进入等待队列。我们再假设之后线程 1 归还了资源 AB，如果使用 notify() 来通知等待队列中的线程，有可能被通知的是线程 4，但线程 4 申请的是 CD，所以此时线程 4 还是会继续等待，而真正该唤醒的线程 3 就再也没有机会被唤醒了\n这个例子：线程1释放了AB后，为什么申请CD的线程会被唤醒？不是说只会唤醒一个资源中的等待线程吗？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588150712,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1178280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fa/a8/d6e7e22b.jpg","nickname":"哈哈哈","note":"","ucode":"488ACA1405C93A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1061466,"avatar":"https://static001.geekbang.org/account/avatar/00/10/32/5a/347570e6.jpg","nickname":"极客er","note":"","ucode":"43A30683884E2E","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":292040,"discussion_content":"感觉不会唤醒等待CD的线程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595059811,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":252297,"ip_address":""},"score":292040,"extra":""},{"author":{"id":2110152,"avatar":"https://static001.geekbang.org/account/avatar/00/20/32/c8/0d14d2ed.jpg","nickname":"🍡🍡🍡","note":"","ucode":"E00595FF677DB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1061466,"avatar":"https://static001.geekbang.org/account/avatar/00/10/32/5a/347570e6.jpg","nickname":"极客er","note":"","ucode":"43A30683884E2E","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":297088,"discussion_content":"notif（） 随机唤醒一个。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596771030,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":252297,"ip_address":""},"score":297088,"extra":""},{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1061466,"avatar":"https://static001.geekbang.org/account/avatar/00/10/32/5a/347570e6.jpg","nickname":"极客er","note":"","ucode":"43A30683884E2E","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":358482,"discussion_content":"线程1、2、3、4申请的AB、CD资源都是同一把锁的情况下就有可能","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1615988632,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":252297,"ip_address":""},"score":358482,"extra":""}]},{"author":{"id":1987202,"avatar":"","nickname":"Geek_783cc7","note":"","ucode":"C43F76B1978FA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":405689,"discussion_content":"问出了我的心声","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634622815,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1494177,"avatar":"https://static001.geekbang.org/account/avatar/00/16/cc/a1/16d488fc.jpg","nickname":"阿国","note":"","ucode":"2801861BB1C115","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346826,"discussion_content":"打卡","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612073787,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1443117,"avatar":"","nickname":"witluo","note":"","ucode":"3D9608C3DDDD95","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301827,"discussion_content":"问的问题都是好多人会遇到的疑惑，这些问题有助于大家更快的吸收理解等待机制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598673526,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75507,"user_name":"蜡笔","can_delete":false,"product_type":"c1","uid":1137414,"ip_address":"","ucode":"D56FE84F952BDD","user_header":"https://static001.geekbang.org/account/avatar/00/11/5b/06/17d03d9b.jpg","comment_is_top":false,"comment_ctime":1552405354,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"263545410410","product_id":100023901,"comment_content":"老师你不用在文章中贴出所有代码嘛，只贴出核心代码，然后把整个例子放在github上，文末的时候给出github的链接，水平基础一般的就可以去上面下载下来跑一跑调试加深印象理解，这样可以不老师😂","like_count":60,"discussions":[{"author":{"id":2059571,"avatar":"","nickname":"Geek_2f3efa","note":"","ucode":"A5F2BB67C94E60","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290760,"discussion_content":"不好","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594601257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1926057,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/63/a9/abed781e.jpg","nickname":"李維道","note":"","ucode":"9A16ECAB2522E3","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556749,"discussion_content":"我也觉得并不好, 我发现以前学不会就是因為很多老师用各种 sleep 或是一些奇怪的操作来模拟真实的操作, 但是模仿的非常拙劣","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647498968,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018706,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/52/6659dc1b.jpg","nickname":"黑米","note":"","ucode":"E7DBEA7867862A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391124,"discussion_content":"你自己搞个工程从头学到到尾的代码片段拼起来就好了，锻炼下自己的动手能力，不要都是拿来主义。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630306595,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2144474,"avatar":"https://static001.geekbang.org/account/avatar/00/20/b8/da/42284f64.jpg","nickname":"张知信","note":"","ucode":"7C896BB3214B3D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326808,"discussion_content":"想法很不错，但是实际操作却不可行。其实很多代码只能以类似伪代码方式呈现，然后配上文字去表达那个意思，实际如果真要跑的话大概率是什么也看不出来的。个人的方法是在纸上手抄代码（喜欢这个感觉），抄完就相当于认真阅读了一遍，然后在结合老师的文字理解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605681286,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76601,"user_name":"kaizhi","can_delete":false,"product_type":"c1","uid":1257663,"ip_address":"","ucode":"EBD8CDA27DC521","user_header":"https://static001.geekbang.org/account/avatar/00/13/30/bf/c635b6b1.jpg","comment_is_top":false,"comment_ctime":1552639654,"is_pvip":false,"replies":[{"id":"27939","content":"感谢你这么懂我😂<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552651619,"ip_address":"","comment_id":76601,"utype":1}],"discussion_count":2,"race_medal":0,"score":"237775840934","product_id":100023901,"comment_content":"感觉老师讲解的节奏非常好，能把并发讲解的这么浅显易懂绝非一日之功。老师在用一种由浅入深，逐层深入的方法来讲解java并发的这些知识点，而不是一股脑的把所有的知识点都罗列出来，有助于我们的吸收，也能引发我们的进一步思考，譬如这节的wait方法，就是在改进上一节的while循环等待（上一节的while在评论区就引发了各路高手的强烈不满，哈哈），这样有助于我们理解当年java的开发者在设计wait方法时的出发点在哪里，另外也让我们理解了为什么wait，notify，notifyAll这些方法会作为Object类的方法。用现实生活做类比这一点也很赞，之前有艺术来源于生活而又高于生活，现在可以说技术来源于生活而又高于生活了，哈哈~","like_count":55,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443372,"discussion_content":"感谢你这么懂我😂\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552651619,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1414266,"avatar":"https://static001.geekbang.org/account/avatar/00/15/94/7a/4e0cbe9c.jpg","nickname":"鲨鱼辣子椒ღ","note":"","ucode":"CBD0777327EA93","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":356032,"discussion_content":"你不是托？\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1615519227,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75336,"user_name":"我是卖报小行家","can_delete":false,"product_type":"c1","uid":1303013,"ip_address":"","ucode":"43530EA291B66D","user_header":"https://static001.geekbang.org/account/avatar/00/13/e1/e5/815d4271.jpg","comment_is_top":false,"comment_ctime":1552381127,"is_pvip":false,"replies":[{"id":"27476","content":"全面👍<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552396577,"ip_address":"","comment_id":75336,"utype":1}],"discussion_count":1,"race_medal":0,"score":"229185647815","product_id":100023901,"comment_content":"wait和sleep区别<br>1：wait释放资源，sleep不释放资源<br>2：wait需要被唤醒，sleep不需要<br>3：wait需要获取到监视器，否则抛异常，sleep不需要<br>4：wait是object顶级父类的方法，sleep则是Thread的方法","like_count":53,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442867,"discussion_content":"全面👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552396577,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":251186,"user_name":"单小灰","can_delete":false,"product_type":"c1","uid":1067354,"ip_address":"","ucode":"59C4523FF1B5DB","user_header":"https://static001.geekbang.org/account/avatar/00/10/49/5a/67b5f0b1.jpg","comment_is_top":false,"comment_ctime":1601392850,"is_pvip":false,"replies":[{"id":"91856","content":"我跟你说，你简直太有才了！这是我见过的最清晰的描述！","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1601426801,"ip_address":"","comment_id":251186,"utype":1}],"discussion_count":5,"race_medal":0,"score":"151925248210","product_id":100023901,"comment_content":"老师notify和notifyAll那块的区别，我相信有很多人和我一样有疑惑，在经过细想之后我终于搞明白了，这里简单举个例子来说明老师的意思：有两个顾客要买水果，但同时只能有一个人进店里买（也就是只有有抢到锁的人才能进去买水果），顾客A想要买橘子，顾客B想要买苹果，但是目前店里什么都没有，那么A和B都在while循环里面调wait方法进行阻塞等待（这时候锁已经释放），然后店员C去进货进了苹果，然后开始通知大家可以来买水果了（也就是调用锁的notify方法），这里notify方法随机唤醒一个顾客，假设唤醒了顾客B，顾客B拿到锁之后发现要的橘子还是没有（对应while循环的条件还是没满足）又调了wait进行阻塞等待，结果这样就导致明明有苹果，但是A还是等在死那。但如果是notifyAll方法的话，那么就同时通知A和B（唤醒A和B），这时两个顾客竞争锁，假设拿到锁的还是B，他发现没有橘子于是接着wait释放锁，这时候A就能拿到B释放的锁，然后就可以买到想要的苹果了，这样就不会出现上面发生的死等现象。","like_count":35,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506408,"discussion_content":"我跟你说，你简直太有才了！这是我见过的最清晰的描述！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601426801,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1358045,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b8/dd/37726c34.jpg","nickname":"小马哥","note":"","ucode":"B2C0FF38F8C9BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367490,"discussion_content":"楼主前面说错了，是A要买苹果，B要买橘子；结果C弄来了苹果，随机notify告诉了B来货了，B发现不是橘子又默默回去等待了，并且没吭气没告诉A现在店里来的货是苹果，A啥也不知道，也默默等着，于是as time goes by","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1618374099,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2385496,"avatar":"https://static001.geekbang.org/account/avatar/00/24/66/58/0b81b449.jpg","nickname":"拾信","note":"","ucode":"2D9C7166E51B6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582692,"discussion_content":"notifyAll相当于让所有的线程都去看看自己符不符合条件，当然，符合的可能有多个，先抢到的优先，notify相当于每次都从一堆线程里挑一个，被挑选的那个可能永远都不满足条件。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659601286,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358498,"discussion_content":"秀儿","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615989918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1256923,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKkeBKshjwVKcpVTs1kGkPibsD5j8odoY6oHrMU1EHqDVjHoLLqzknOd8Q0aWxTDCJjvK1NJIX5Ncg/132","nickname":"Summer","note":"","ucode":"6E51D5574C1EFD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":356494,"discussion_content":"优秀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615611312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76368,"user_name":"aksonic","can_delete":false,"product_type":"c1","uid":1003633,"ip_address":"","ucode":"B6F3348F6714DB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/50/71/e8229703.jpg","comment_is_top":false,"comment_ctime":1552578979,"is_pvip":false,"replies":[{"id":"27887","content":"你这个建议挺好，在管程里面，会重新讲这俩队列。现在就知道有俩等待队列就可以了<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552623888,"ip_address":"","comment_id":76368,"utype":1}],"discussion_count":5,"race_medal":0,"score":"117516695971","product_id":100023901,"comment_content":"老师，我昨天问了你问题后，带着疑问又去学习了下，是不是文章中的左边和右边的两个队列应该改一改名字，不应该都叫等待队列，这样对新手很容易产生误解。如果左边的叫做同步队列，右边的叫做等待队列可能更好。左边的队列是用来争夺锁的，右边的队列是等待队列，是必须被notify的，当被notify之后，就会被放入左边的队列去争夺锁。老师，你觉得呢？","like_count":27,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443277,"discussion_content":"你这个建议挺好，在管程里面，会重新讲这俩队列。现在就知道有俩等待队列就可以了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552623888,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1494177,"avatar":"https://static001.geekbang.org/account/avatar/00/16/cc/a1/16d488fc.jpg","nickname":"阿国","note":"","ucode":"2801861BB1C115","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346827,"discussion_content":"打卡","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612073922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1133545,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJQyCFqdkJB97EXF7VVO1n0nRZUmxfWwDicJMmupDdDia7VnPkLSJicFyEe28eUtZamH9uprtBJ4Ojjw/132","nickname":"qhj","note":"","ucode":"A9A9370BB2EE0E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303474,"discussion_content":"建议太棒了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599277132,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1812970,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a9/ea/5bfce6c5.jpg","nickname":"mgs2002","note":"","ucode":"F5931108BD509B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":186953,"discussion_content":"不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582722220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1501496,"avatar":"","nickname":"ysl","note":"","ucode":"06398A1F9149EB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":22559,"discussion_content":"首先非常同意对于图的澄清，我觉得挺好，👈是等待互斥锁队列，👉是等待通知队列；一个疑问：右边队列中的线程被唤醒后，是不是重新加入到左边的同步队列中等待互斥锁？如果是这样，那么老师的图画的就容易引起误解了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569652024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75417,"user_name":"老杨同志","can_delete":false,"product_type":"c1","uid":1246199,"ip_address":"","ucode":"3F334F0CFD3DE6","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/f7/3a493bec.jpg","comment_is_top":false,"comment_ctime":1552394564,"is_pvip":false,"replies":[{"id":"27477","content":"👍<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552396639,"ip_address":"","comment_id":75417,"utype":1}],"discussion_count":1,"race_medal":0,"score":"113221544260","product_id":100023901,"comment_content":"点赞@姜戈 补充一下：wait与sleep区别在于：<br>1. wait会释放所有锁而sleep不会释放锁资源.<br>2. wait只能在同步方法和同步块中使用，而sleep任何地方都可以.<br>3. wait无需捕捉异常，而sleep需要.（都抛出InterruptedException ，wait也需要捕获异常）<br>4. wait()无参数需要唤醒，线程状态WAITING；wait(1000L);到时间自己醒过来或者到时间之前被其他线程唤醒，状态和sleep都是TIME_WAITING<br>两者相同点：都会让渡CPU执行时间，等待再次调度！","like_count":26,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442885,"discussion_content":"👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552396639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75179,"user_name":"郑晨Cc","can_delete":false,"product_type":"c1","uid":1324942,"ip_address":"","ucode":"57146E444D6329","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/8e/cf0b4575.jpg","comment_is_top":false,"comment_ctime":1552360616,"is_pvip":false,"replies":[{"id":"27490","content":"都是this这一把锁: synchronized void apply(){}<br>所以是一个等待队列<br><br>就是500个线程，也是同一个等待队列，因为锁的都是this<br><br>队列一定是存在的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552400776,"ip_address":"","comment_id":75179,"utype":1}],"discussion_count":8,"race_medal":0,"score":"96041641128","product_id":100023901,"comment_content":"王老师 ABCD 那个例子真没看懂 线程1释放锁为啥会通知线程4？1和3才是互斥的啊 2和4互斥 按我的理解 3和4 不应该是在同一个等待队列里啊 因为不是通一把锁（准确来时不是同样的两把锁）<br>就着这个例子 我还有个关互斥锁的等待队列的问题 假设还是资源ABCD 线程5 获取AB 线程6获取CD 线程7试图获取AB 线程8试图获取BC 线程9试图获取CD 那线程 7，8，9 到底是不是在一个等待队列里面，<br>JVM在实现 wait notify机制是时候到底存不存在真实的队列？","like_count":22,"discussions":[{"author":{"id":1180998,"avatar":"https://static001.geekbang.org/account/avatar/00/12/05/46/c769e2d9.jpg","nickname":"镏金糖豆","note":"","ucode":"6BA54592FDD9D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2838,"discussion_content":"abcd的位置我也有个疑问，既然是都在等待队列等待，线程3为什么永远没有机会了呢。线程124任一个释放资源都有可能唤醒线程3啊。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1563963102,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2694205,"avatar":"https://static001.geekbang.org/account/avatar/00/29/1c/3d/76465ee4.jpg","nickname":"摘星","note":"","ucode":"55D8CAFC938F91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1180998,"avatar":"https://static001.geekbang.org/account/avatar/00/12/05/46/c769e2d9.jpg","nickname":"镏金糖豆","note":"","ucode":"6BA54592FDD9D4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555861,"discussion_content":"老师是假设呀 不排除极端情况 一直notify一个线程的话 那就寄了 或者说 当有10w个线程 用notify的话 那你觉得每个都能唤醒的话 概率是远小于 1/10w 的！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647087054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2838,"ip_address":""},"score":555861,"extra":""}]},{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442814,"discussion_content":"都是this这一把锁: synchronized void apply(){}\n所以是一个等待队列\n\n就是500个线程，也是同一个等待队列，因为锁的都是this\n\n队列一定是存在的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1552400776,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2054237,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/58/5d/bb5f1ec5.jpg","nickname":"n的n次方","note":"","ucode":"4053B5444222FC","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369928,"discussion_content":"老师，锁的不是一个资源，为啥用同一把锁呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619201130,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1507813,"avatar":"","nickname":"武塘","note":"","ucode":"4F898F7615C39E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4742,"discussion_content":"锁this那就只竞争this 这一个资源，哪来的ABCD","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565697737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1179533,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ff/8d/8601f035.jpg","nickname":"淞淞同学","note":"","ucode":"529A326B898008","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1507813,"avatar":"","nickname":"武塘","note":"","ucode":"4F898F7615C39E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":85953,"discussion_content":"锁对象是this，资源是ABCD啊...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576584329,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4742,"ip_address":""},"score":85953,"extra":""}]},{"author":{"id":1178869,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fc/f5/2634fbb2.jpg","nickname":"刘垚","note":"","ucode":"308A705AE6EBFF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3379,"discussion_content":"如果锁多个资源，使用notifyall更佳。\n如果只锁一个资源，那使用notify更佳。\n我是这样理解的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564448431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1225224,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","nickname":"尔冬橙","note":"","ucode":"0B013A49BC18DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1979,"discussion_content":"这就是Account是必须是单例的原因？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563159211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75011,"user_name":"andywang","can_delete":false,"product_type":"c1","uid":1441581,"ip_address":"","ucode":"585092411083A6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKsHXJofxYo78CRv2h9BXic2qnnttQqxNicPYAibx721MuRa3NQeDVpzPJmMG1pGClpEfqHIwDxIeepg/132","comment_is_top":false,"comment_ctime":1552350764,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"91746663980","product_id":100023901,"comment_content":"应该是!als.contains(from) || !als.contains(to)才wait()吧","like_count":21,"discussions":[{"author":{"id":1441569,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ff/21/8815d2e5.jpg","nickname":"亮子","note":"","ucode":"DF37D5E0714D02","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385396,"discussion_content":"只要包含就说明有线程在执行了，所以不用取反","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1627026537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1136415,"avatar":"https://static001.geekbang.org/account/avatar/00/11/57/1f/23647dcb.jpg","nickname":"焱","note":"","ucode":"9EB006496401AC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367657,"discussion_content":"多线程情况下，如果当前线程检查到实例的属性als已经包含了其中一个资源，说明已经有其他线程拿到了部分资源，当前线程拿不到全部的资源，只能等待","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618413838,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1466840,"avatar":"https://static001.geekbang.org/account/avatar/00/16/61/d8/3bc19bff.jpg","nickname":"恋在那时","note":"","ucode":"7F026B4B708C7D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4231,"discussion_content":"你想如果其他的线程里集合里已经有了src或者target，肯定要等待啊，所以是包含的时候等待没有问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565244143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1613123,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9d/43/bf628743.jpg","nickname":"Cyber","note":"","ucode":"A7842494F57D0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1466840,"avatar":"https://static001.geekbang.org/account/avatar/00/16/61/d8/3bc19bff.jpg","nickname":"恋在那时","note":"","ucode":"7F026B4B708C7D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307155,"discussion_content":"while(als.contains(from) || als.contains(to) ）在java中这样写确实是有问题的， || 在java里面前面的表达式值为true，后面的不会判断直接返回true，也就是说只要管理员拿到了from就需要等待；当管理员同时拿到from和to时就会有问题啊；可以改为while(als.size()  == 1) ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600517820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4231,"ip_address":""},"score":307155,"extra":""},{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1613123,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9d/43/bf628743.jpg","nickname":"Cyber","note":"","ucode":"A7842494F57D0C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358493,"discussion_content":"没问题，als只要拿到from或者to任意一个说明其他线程在使用，就需要等待，当als既拿不到from也拿不到to的时候说明没有线程在使用from和to此时才算资源获取成功可以进行转账","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615989574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":307155,"ip_address":""},"score":358493,"extra":""},{"author":{"id":1170811,"avatar":"https://static001.geekbang.org/account/avatar/00/11/dd/7b/c1efb1d9.jpg","nickname":"胡永","note":"","ucode":"931DA91D191FEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1613123,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9d/43/bf628743.jpg","nickname":"Cyber","note":"","ucode":"A7842494F57D0C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371033,"discussion_content":"while(als.size() == 1)这个不行的，有bug，size==2的时候咋办？应该while(als.size() >= 1)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619616979,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":307155,"ip_address":""},"score":371033,"extra":""}]},{"author":{"id":1174199,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ea/b7/1a18a39d.jpg","nickname":"5-刘新波(Arvin)","note":"","ucode":"DBD135D2587A93","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4187,"discussion_content":"&amp;&amp; 都不包含才wait吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565201815,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1793425,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/5d/91/9b6fb4ad.jpg","nickname":"daiwf","note":"","ucode":"2C78451F5488BD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1174199,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ea/b7/1a18a39d.jpg","nickname":"5-刘新波(Arvin)","note":"","ucode":"DBD135D2587A93","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":112841,"discussion_content":"都不包含就证明当前from和to都没有被管理员拿走。反而不用wait。如果有一个包含就证明有其他线程拿走了这个对象。就要等待了。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1577884955,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4187,"ip_address":""},"score":112841,"extra":""}]}]},{"had_liked":false,"id":76252,"user_name":"lau","can_delete":false,"product_type":"c1","uid":1174230,"ip_address":"","ucode":"4EC054B801F1E1","user_header":"https://static001.geekbang.org/account/avatar/00/11/ea/d6/1f98594e.jpg","comment_is_top":false,"comment_ctime":1552557529,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"65977066969","product_id":100023901,"comment_content":"看评论也能学到很多干货","like_count":15},{"had_liked":false,"id":75304,"user_name":"陈志凯","can_delete":false,"product_type":"c1","uid":1099594,"ip_address":"","ucode":"C154E8FE848152","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/4a/1c5627ef.jpg","comment_is_top":false,"comment_ctime":1552376208,"is_pvip":false,"replies":[{"id":"27471","content":"对于水平高的，完整的代码没必要。对于水平低的，完整的代码只能增加惰性。我就很讨厌粘贴一些无关的代码😃","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552394371,"ip_address":"","comment_id":75304,"utype":1}],"discussion_count":2,"race_medal":0,"score":"57386951056","product_id":100023901,"comment_content":"强烈建议老师每个章节配上完整的demo，包括模拟多线程多个客户操作的代码，这样看效果才是最佳的，我们自己也能根据代码实际好好观察！","like_count":13,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442855,"discussion_content":"对于水平高的，完整的代码没必要。对于水平低的，完整的代码只能增加惰性。我就很讨厌粘贴一些无关的代码😃","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552394371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005200,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/56/90/be01bb8d.jpg","nickname":"Asanz","note":"","ucode":"430AB7ED59EE3F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2390,"discussion_content":"老师是懒癌晚期了😂","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1563532219,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74971,"user_name":"邋遢的流浪剑客","can_delete":false,"product_type":"c1","uid":1260881,"ip_address":"","ucode":"32AF6F9070506D","user_header":"https://static001.geekbang.org/account/avatar/00/13/3d/51/9723276c.jpg","comment_is_top":false,"comment_ctime":1552332624,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"57386907472","product_id":100023901,"comment_content":"wait会释放当前占有的锁，sleep不会释放锁","like_count":13},{"had_liked":false,"id":75424,"user_name":"San D Ji","can_delete":false,"product_type":"c1","uid":1441745,"ip_address":"","ucode":"138C9CCC38DC4C","user_header":"https://static001.geekbang.org/account/avatar/00/15/ff/d1/238d9da3.jpg","comment_is_top":false,"comment_ctime":1552395971,"is_pvip":false,"replies":[{"id":"27478","content":"比如你要做个数据库连接池，做个httpclient，做个rpc框架，用批处理处理上千万数据，一个简单的crud真的用不上<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552396843,"ip_address":"","comment_id":75424,"utype":1}],"discussion_count":1,"race_medal":0,"score":"53092003523","product_id":100023901,"comment_content":"学习这几章以后，我一直有一个问题，Javaweb端在什么样的业务场景下需要多线程的技术实现？<br>一直以为Javaweb端都是接收到一个请求服务器端开启一条线程独立作业，完了之后就返回一个应答。<br>不知道老师能否回答一下我的疑问？","like_count":12,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442886,"discussion_content":"比如你要做个数据库连接池，做个httpclient，做个rpc框架，用批处理处理上千万数据，一个简单的crud真的用不上\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552396843,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75763,"user_name":"陈志凯","can_delete":false,"product_type":"c1","uid":1099594,"ip_address":"","ucode":"C154E8FE848152","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/4a/1c5627ef.jpg","comment_is_top":false,"comment_ctime":1552465866,"is_pvip":false,"replies":[{"id":"27643","content":"如果只是这个例子就不需要了，<br>送你俩字！优秀！！！！！","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552479958,"ip_address":"","comment_id":75763,"utype":1}],"discussion_count":2,"race_medal":0,"score":"48797106122","product_id":100023901,"comment_content":"public class Allocator {<br>\tprivate final List&lt;Account&gt; als=new LinkedList&lt;Account&gt;();<br>\t&#47;&#47; 一次性申请所有资源<br>\tpublic synchronized void apply(Account from, Account to) {<br>\t\t&#47;&#47; 经典写法<br>\t\twhile (als.contains(from) || als.contains(to)) {<br>\t\t\ttry {<br>\t\t\t\tSystem.out.println(&quot;等待用户 -&gt; &quot;+from.getId()+&quot;_&quot;+to.getId());<br>\t\t\t\twait();<br>\t\t\t} catch (Exception e) {<br>\t\t\t\t&#47;&#47;notify + notifyAll 不会来这里<br>\t\t\t\tSystem.out.println(&quot;异常用户 -&gt; &quot;+from.getId()+&quot;_&quot;+to.getId());<br>\t\t\t\te.printStackTrace();<br>\t\t\t}<br>\t\t}<br>\t\tals.add(from);<br>\t\tals.add(to);<br>\t}<br>\t&#47;&#47; 归还资源<br>\tpublic synchronized void free(Account from, Account to) {<br>\t\tSystem.out.println(&quot;唤醒用户 -&gt; &quot;+from.getId()+&quot;_&quot;+to.getId());<br>\t\tals.remove(from);<br>\t\tals.remove(to);<br>\t\tnotifyAll();<br>\t}<br>}<br><br>public class Account {<br>\t&#47;&#47; actr 应该为单例<br>\tprivate final Allocator actr;<br>\t&#47;&#47;唯一账号<br>\tprivate final long id;<br>\t&#47;&#47;余额<br>\tprivate int balance;<br>\tpublic Account(Allocator actr,long id,int balance){<br>\t\tthis.actr=actr;<br>\t\tthis.id=id;<br>\t\tthis.balance=balance;<br>\t}<br>\t&#47;&#47; 转账<br>\tpublic void transfer(Account target, int amt) {<br>\t\t&#47;&#47; 一次性申请转出账户和转入账户，直到成功<br>\t\tactr.apply(this, target);<br>\t\ttry {<br>\t\t\t&#47;&#47;TODO 有了资源管理器，这里的synchronized锁就不需要了吧？！<br>\t\t\t\t\tif (this.balance &gt; amt) {<br>\t\t\t\t\t\tthis.balance -= amt;<br>\t\t\t\t\t\ttarget.balance += amt;<br>\t\t\t\t\t}<br>\t\t\t\t\t&#47;&#47;模拟数据库操作时间<br>\t\t\t\t\ttry {<br>\t\t\t\t\t\tThread.sleep(new Random().nextInt(2000));<br>\t\t\t\t\t} catch (InterruptedException e) {<br>\t\t\t\t\t\te.printStackTrace();<br>\t\t\t\t\t}<br>\t\t} finally {<br>\t\t\tactr.free(this, target);<br>\t\t}<br>\t}<br>\t@Override<br>\tpublic int hashCode() {<br>\t\tfinal int prime = 31;<br>\t\tint result = 1;<br>\t\tresult = prime * result + (int) (id ^ (id &gt;&gt;&gt; 32));<br>\t\treturn result;<br>\t}<br>\t&#47;**<br>\t * 用于判断两个用户是否一致<br>\t *&#47;<br>\t@Override<br>\tpublic boolean equals(Object obj) {<br>\t\tif (this == obj)<br>\t\t\treturn true;<br>\t\tif (obj == null)<br>\t\t\treturn false;<br>\t\tif (getClass() != obj.getClass())<br>\t\t\treturn false;<br>\t\tAccount other = (Account) obj;<br>\t\tif (id != other.id)<br>\t\t\treturn false;<br>\t\treturn true;<br>\t}<br>\tpublic long getId() {<br>\t\treturn id;<br>\t}<br>}<br>老师，以上代码是我补的，有个疑问，以上有了Allocator管理器（见TODO部分），transfer方法的this跟target都不再需要加synchronized锁了吧？！","like_count":11,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443022,"discussion_content":"如果只是这个例子就不需要了，\n送你俩字！优秀！！！！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552479958,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1533266,"avatar":"https://static001.geekbang.org/account/avatar/00/17/65/52/07c09c7f.jpg","nickname":"josancpp","note":"","ucode":"0CDC39B3E716A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":274976,"discussion_content":"关键看这个balance共享变量会不会变两个线程同时操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590640250,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75366,"user_name":"约书亚","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","comment_is_top":false,"comment_ctime":1552383645,"is_pvip":false,"replies":[{"id":"27492","content":"你是对的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552401058,"ip_address":"","comment_id":75366,"utype":1}],"discussion_count":1,"race_medal":0,"score":"44502056605","product_id":100023901,"comment_content":"置顶回答是不是有问题，wait一样需要捕获InterruptedException异常呀？","like_count":10,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442873,"discussion_content":"你是对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552401058,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75246,"user_name":"^_^","can_delete":false,"product_type":"c1","uid":1088001,"ip_address":"","ucode":"EE5DAC03CFC2EE","user_header":"https://static001.geekbang.org/account/avatar/00/10/9a/01/1489f98d.jpg","comment_is_top":false,"comment_ctime":1552369644,"is_pvip":false,"replies":[{"id":"27467","content":"我确认了一下，应该是对的<br>只要有一个，就说明曾经被分配过<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552393358,"ip_address":"","comment_id":75246,"utype":1}],"discussion_count":3,"race_medal":0,"score":"40207075308","product_id":100023901,"comment_content":"老师，while(als.contains(from) || als.contains(to)) 这句对吗","like_count":9,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442836,"discussion_content":"我确认了一下，应该是对的\n只要有一个，就说明曾经被分配过\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552393358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1047837,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fd/1d/76bec892.jpg","nickname":"梅侯","note":"","ucode":"60445908BDD82C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1398,"discussion_content":"根据前文提到的while(条件不满足) { wait(); }\n这是不应该是这样才对吗？while(!(als.contains(from) &amp;&amp;als.contains(to))) \n满足的条件是同时有拥有from和to然后再取反，可是我用代码运行了一下这样会死锁呀，可以解答一下吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562598364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1540162,"avatar":"https://static001.geekbang.org/account/avatar/00/17/80/42/4f2ec593.jpg","nickname":"timetraveler","note":"","ucode":"543CE2E26631CA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1047837,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fd/1d/76bec892.jpg","nickname":"梅侯","note":"","ucode":"60445908BDD82C","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":3816,"discussion_content":"建议你再好好想想～ als 表示被占用的对象，如果als里有from 或 to，表示对象已被别的线程占用，当前线程wait，没毛病的","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1564840340,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":1398,"ip_address":""},"score":3816,"extra":""}]}]},{"had_liked":false,"id":75140,"user_name":"高源","can_delete":false,"product_type":"c1","uid":1048887,"ip_address":"","ucode":"751B41FD38EF7D","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/37/12e4c9c9.jpg","comment_is_top":false,"comment_ctime":1552357987,"is_pvip":false,"replies":[{"id":"27394","content":"大家水平不一样，有些高水平的可能只想看到核心的代码，我怕贴多了，有人说浪费流量。自己补上剩余代码也是个不错的提高机会吧😂","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552362835,"ip_address":"","comment_id":75140,"utype":1}],"discussion_count":2,"race_medal":0,"score":"40207063651","product_id":100023901,"comment_content":"老师最好讲解每一章的时候配合完整的例子源代码，这样再加调试源代码，印象更深刻了","like_count":9,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442805,"discussion_content":"大家水平不一样，有些高水平的可能只想看到核心的代码，我怕贴多了，有人说浪费流量。自己补上剩余代码也是个不错的提高机会吧😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552362835,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2963434,"avatar":"","nickname":"Geek_94fa0e","note":"","ucode":"15BC7D4E130E80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560388,"discussion_content":"怎么可能还有弱智觉得浪费流量呢?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649309937,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79136,"user_name":"亮","can_delete":false,"product_type":"c1","uid":1214463,"ip_address":"","ucode":"BE7C4C4AE0479B","user_header":"https://static001.geekbang.org/account/avatar/00/12/87/ff/d7722f90.jpg","comment_is_top":false,"comment_ctime":1553368013,"is_pvip":false,"replies":[{"id":"28854","content":"一个notify对应一个wait，浪费一个wait，自然有一个永远失去机会<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553388110,"ip_address":"","comment_id":79136,"utype":1}],"discussion_count":5,"race_medal":0,"score":"35913106381","product_id":100023901,"comment_content":"3怎么可能永远通知不到呢？就算4通知到了不满足条件等待，2走完还是会通知3或者4，就算通知到4了还是会点用notify方法","like_count":8,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444368,"discussion_content":"一个notify对应一个wait，浪费一个wait，自然有一个永远失去机会\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553388110,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1361746,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c7/52/c5adf218.jpg","nickname":"喜欢地球的阿培同学","note":"","ucode":"5F97037585F857","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":91438,"discussion_content":"我也有同样的疑问，即使没有通知3，而是通知4, 4的条件没有满足，继续等待，但是2执行结束后会调用notify(),这个时候会随机选择3 或 4，但是3 或 4结束后也会调用notify()，所以如果只有线程1,2,3,4，那么他们4个最后都会执行完的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576833866,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1600585,"avatar":"https://static001.geekbang.org/account/avatar/00/18/6c/49/fdb9e442.jpg","nickname":"梁","note":"","ucode":"2F474FE490D424","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":563875,"discussion_content":"同意你的观点，这例子举的有问题吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650100674,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1415666,"avatar":"https://static001.geekbang.org/account/avatar/00/15/99/f2/36e102e6.jpg","nickname":"爆米花","note":"","ucode":"4F8BC766DBC4CD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544060,"discussion_content":"确实例子举的有点问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641391766,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2618910,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/f6YBFBbXurWa9NJr42Z3Hfic223qsEVpAghY0W7DU2cRUicmKvg1QHsjPGRBP90wjV1yAGC8dzerRJcwribB0ibVlQ/132","nickname":"Geek_95323e","note":"","ucode":"92EFD57A73C726","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373891,"discussion_content":"我觉得你说的没问题 作者很多问题下面都是这种话,却没有正面回应过","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620908055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75033,"user_name":"狂战俄洛伊","can_delete":false,"product_type":"c1","uid":1213269,"ip_address":"","ucode":"F6EACA321E6180","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJUzv6S9wroydkGP6m3OsQ8QuI4jAibv21tNkm7KVGPffJibj8Y29yIdKl4qkDGd3iaGJCSGVarfxoibQ/132","comment_is_top":false,"comment_ctime":1552351786,"is_pvip":false,"replies":[{"id":"27479","content":"有用，例如别让程序跑的太快","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552397024,"ip_address":"","comment_id":75033,"utype":1}],"discussion_count":2,"race_medal":0,"score":"35912090154","product_id":100023901,"comment_content":"Sleep是睡一段时间就自己起来了，wait的话得等到别人叫醒他。个人感觉sleep除了增加程序运行时间以外，没别的意义呀","like_count":8,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442784,"discussion_content":"有用，例如别让程序跑的太快","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552397024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1154281,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9c/e9/5ba8b1a3.jpg","nickname":"郭新鹏","note":"","ucode":"F9D76691B335FC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":533016,"discussion_content":"例如洗数据的时候，一般都会加sleep。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637756295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78595,"user_name":"阿里巴巴骊骅","can_delete":false,"product_type":"c1","uid":1042492,"ip_address":"","ucode":"FDA3C20D9E622A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e8/3c/e8c80390.jpg","comment_is_top":false,"comment_ctime":1553180777,"is_pvip":false,"replies":[{"id":"28669","content":"code1；<br>if (条件不满足)<br>  wait()<br>code2；<br><br>当调用wait()时，阻塞。被唤醒时，就直接执行code2了，没机会重新判断。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553264269,"ip_address":"","comment_id":78595,"utype":1}],"discussion_count":2,"race_medal":0,"score":"31617951849","product_id":100023901,"comment_content":"while方式为啥说是经典范式呢？换成if判断不可以么？","like_count":8,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444155,"discussion_content":"code1；\nif (条件不满足)\n  wait()\ncode2；\n\n当调用wait()时，阻塞。被唤醒时，就直接执行code2了，没机会重新判断。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1553264269,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1198112,"avatar":"https://static001.geekbang.org/account/avatar/00/12/48/20/f1898740.jpg","nickname":"凹凸","note":"","ucode":"D6F0EBDC8F2588","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":412031,"discussion_content":"不可以，因为被唤醒后要去检查条件在重新得到锁的时刻条件是否还成立","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636049947,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":88522,"user_name":"the geek","can_delete":false,"product_type":"c1","uid":1506723,"ip_address":"","ucode":"71DECBC814A539","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLz3icr3mGs5ib8FbSPQZ2ic3ib90mHkd1btQrmGacZjJxfYXrerIdaTxglKyCicFzLcEAb6deC2cWjE5Q/132","comment_is_top":false,"comment_ctime":1555935287,"is_pvip":false,"replies":[{"id":"31763","content":"假设一开始有10个线程争抢一个资源，其中9个都处于wait状态，只有一个运行，只要这个运行的线程运行结束了，那他会随机通知一个线程，结果这个线程发现自己条件还不成熟，于是继续wait。那你觉得10这个等待的还有机会被唤醒吗？至于被唤醒的为什么会等待，你需要自己琢磨一下文中的例子，为什么例子中是等待两个条件。<br>这些东西都是专家们搞出来的，不会错的，如果想不通，就换个角度。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555946011,"ip_address":"","comment_id":88522,"utype":1}],"discussion_count":5,"race_medal":0,"score":"27325739063","product_id":100023901,"comment_content":"我举个更简单的例子证明，notify不丢失。假设一开始有10个线程争抢一个资源，其中9个都处于wait状态，只有一个运行，只要这个运行的线程运行结束了，那他会随机通知一个线程，然后就会像链式一样的接连通知，直至全部运行完成。","like_count":6,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447818,"discussion_content":"假设一开始有10个线程争抢一个资源，其中9个都处于wait状态，只有一个运行，只要这个运行的线程运行结束了，那他会随机通知一个线程，结果这个线程发现自己条件还不成熟，于是继续wait。那你觉得10这个等待的还有机会被唤醒吗？至于被唤醒的为什么会等待，你需要自己琢磨一下文中的例子，为什么例子中是等待两个条件。\n这些东西都是专家们搞出来的，不会错的，如果想不通，就换个角度。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555946011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1475528,"avatar":"https://static001.geekbang.org/account/avatar/00/16/83/c8/5ce842f6.jpg","nickname":"maybe","note":"","ucode":"93D160F617E750","race_medal":4,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307045,"discussion_content":"public class NotifyTest {\npublic static void main(String[] args) {\n\tfor (var i = 0; i < 100; i++) {\n\t\ttest(i);\n\t}\n}\nprivate final static boolean NOTIFY_ALL = false;\nprivate static void test(int i) {\n\tSystem.out.println(i + &#34;th&#34;);\n\tvar q = new Q<String>();\n\tvar p1 = new Thread(() -> q.enQ(&#34;hello&#34;));\n\tvar p2 = new Thread(() -> q.enQ(&#34;world&#34;));\n\tvar c1 = new Thread(() -> q.deQ());\n\tvar c2 = new Thread(() -> q.deQ());\n\tc1.start();\n\tc2.start();\n\ttry {\n\t\tThread.sleep(100);\n\t} catch (InterruptedException e) {\n\t\te.printStackTrace();\n\t}\n\tp1.start();\n\tp2.start();\n\ttry {\n\t\tp1.join();\n\t\tp2.join();\n\t\tc1.join();\n\t\tc2.join();\n\t} catch (InterruptedException e) {\n\t\te.printStackTrace();\n\t}\n}\nstatic class Q<T> {\n\tprivate volatile List<T> LIST = new ArrayList<T>(1);\n\tpublic synchronized void enQ(T obj) {\n\t\twhile (!LIST.isEmpty()) {\n\t\t\ttry {\n\t\t\t\twait();\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\tLIST.add(obj);\n\t\tSystem.out.println(Thread.currentThread().getName() + &#34;enQ success :&#34; + obj);\n\t\tif (NOTIFY_ALL) {\n\t\t\tnotifyAll();\n\t\t} else {\n\t\t\tnotify();\n\t\t}\n\t}\n\tpublic synchronized void deQ() {\n\t\twhile (LIST.isEmpty()) {\n\t\t\ttry {\n\t\t\t\twait();\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\tvar obj = LIST.remove(0);\n\t\tSystem.out.println(Thread.currentThread().getName() + &#34;deQ success :&#34; + obj);\n\n\t\tif (NOTIFY_ALL) {\n\t\t\tnotifyAll();\n\t\t} else {\n\t\t\tnotify();\n\t\t}\n\t}\n}\n}\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600481036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1942714,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKfdTR27z4sNOFoYMpQEhzJEblbGqibesKHYWgz9X9xZ3nzOL3EBOzkmWs4CqWMVf2IxXPCMlWx1gQ/132","nickname":"堃","note":"","ucode":"80B75B0347206A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303657,"discussion_content":"感觉我不懂的地方在于这个“结果这个线程发现自己条件还不成熟&#34;, 有什么情况下可能导致条件不成熟呢？例子里面的AB, CD资源最终都会被释放，线程2释放CD后唤醒的3或者4都可以继续执行，AB, CD 都可以使用了，3可以唤醒4， 4也是可以唤醒3","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599324152,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1942714,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKfdTR27z4sNOFoYMpQEhzJEblbGqibesKHYWgz9X9xZ3nzOL3EBOzkmWs4CqWMVf2IxXPCMlWx1gQ/132","nickname":"堃","note":"","ucode":"80B75B0347206A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303653,"discussion_content":"感觉老师解释的这个“条件还不成熟”只有可能是外部因素导致的（需要资源E），或者说执行完的线程所释放的资源对被唤醒的线程是不可用的或者被唤醒前这个资源又被其他线程（非这个锁队列的线程）占用了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599323922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1250907,"avatar":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","nickname":"Monday","note":"","ucode":"77B9BACC783598","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278478,"discussion_content":"唤醒的线程t1继续wait，表明t1的资源被其他的线程（设为t2）抢占了。t2执行完后，会释放锁，并再次notify，这时t1又迎来了新的机会","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591191597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124470,"user_name":"ixonya","can_delete":false,"product_type":"c1","uid":1071883,"ip_address":"","ucode":"1CE0897B39AD18","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epaibTssLXqSXryibVuFoMyicg64o3IqFaobS9J7TibqUpRQ45lVj2nbRQpfLQicW6W81zwYM19X1VIk8A/132","comment_is_top":false,"comment_ctime":1565901761,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18745770945","product_id":100023901,"comment_content":"假设我们有资源 A、B、C、D，线程 1 申请到了 AB，线程 2 申请到了 CD，此时线程 3 申请 AB，会进入等待队列（AB 分配给线程 1，线程 3 要求的条件不满足），线程 4 申请 CD 也会进入等待队列。我们再假设之后线程 1 归还了资源 AB，如果使用 notify() 来通知等待队列中的线程，有可能被通知的是线程 4，但线程 4 申请的是 CD，所以此时线程 4 还是会继续等待，而真正该唤醒的线程 3 就再也没有机会被唤醒了。<br><br>----<br><br>这里还是有点没太明白。线程 1 和 2 拥有资源正在运行，运行完后会陆续释放资源并 notify。假设  1  先完成，唤醒了 4，4 一看不行又 wait 了。之后 2 执行完成释放资源，此时所有资源均可用，因此无论 2 notify 谁，被唤醒的线程总能运行。以此类推，设有  n 个线程同时运行，在最坏的情况下，前 n-1 个线程执行完的 notify 都浪费了也没事，因为最后一个线程 notify 时一定会是“所有资源均可用”的局面，因此也就一定能成功唤醒线程。","like_count":4,"discussions":[{"author":{"id":2576933,"avatar":"https://static001.geekbang.org/account/avatar/00/27/52/25/5498f763.jpg","nickname":"小灰狼🇨🇳","note":"","ucode":"71A0EA1FE755CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374052,"discussion_content":"notify随机唤醒，您说是最后一个线程notify时一定会。。。并发时，要是有很多一直转账请求时，随机又不能保证一定","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620981762,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121097,"user_name":"张天屹","can_delete":false,"product_type":"c1","uid":1477612,"ip_address":"","ucode":"8BD6BD6DCF0F4F","user_header":"https://static001.geekbang.org/account/avatar/00/16/8b/ec/dc03f5ad.jpg","comment_is_top":false,"comment_ctime":1565057777,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18744926961","product_id":100023901,"comment_content":"热评第一的@ 姜戈 同学提到的第三点：wait无需捕获异常而sleep需要捕获异常我觉得是有误的。<br>wait() sleep() 都会让线程进入一种休眠或者阻塞的失去cpu的状态。这个时候它们都可以通过别的线程调用其interrupte方法让他们的线程从休眠状态中中断。而由于这是一个checkedException，他们两个方法都是需要捕获的，这恰恰是他们的共同点之一。","like_count":4,"discussions":[{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358510,"discussion_content":"是他们通知别的线程去中断休眠状态还是别的线程去中断？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615990560,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82435,"user_name":"郭瑞娟","can_delete":false,"product_type":"c1","uid":1299117,"ip_address":"","ucode":"BBCFC69965124A","user_header":"https://static001.geekbang.org/account/avatar/00/13/d2/ad/53517f01.jpg","comment_is_top":false,"comment_ctime":1554211310,"is_pvip":false,"replies":[{"id":"29856","content":"因为不对应了，所以就死等下去了，有借有还才行，还错了人就出问题了<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554215899,"ip_address":"","comment_id":82435,"utype":1}],"discussion_count":5,"race_medal":0,"score":"18734080494","product_id":100023901,"comment_content":"之前老师答复问题时，提到wait和notify是一一对应的，如果浪费了一个notify，就必然有一个wait永远没机会被唤醒。这句话怎么理解呢？<br>例子里面 假设之后线程 1 归还了资源 AB，使用 notify() 来通知等待队列中的线程4 申请的是 CD，程 4 还是会继续等待，此时会执行wait()吗？如果执行了，wait和notify还是一一对应的呀。如果没有执行，线程4会怎么执行呢？我看了几次文章了，还是没有理解此处，请老师帮忙，谢谢。<br>","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445588,"discussion_content":"因为不对应了，所以就死等下去了，有借有还才行，还错了人就出问题了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554215899,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1198112,"avatar":"https://static001.geekbang.org/account/avatar/00/12/48/20/f1898740.jpg","nickname":"凹凸","note":"","ucode":"D6F0EBDC8F2588","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":412032,"discussion_content":"只会释放锁并不会调用notify","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1636050161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2308075,"avatar":"","nickname":"Geek_89e362","note":"","ucode":"E596C2CFE1CFAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326482,"discussion_content":"使用notify()方法容易产生线程“饥饿”。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605605813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1290428,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK2uagtiaicloiaKweyY6Sic8b9sJ2ibNaichSyibLCvRqkmnjACjyNCjellmSx6lbb0OBDCeAH8WNoyMomg/132","nickname":"有情有义","note":"","ucode":"B200B466A90B07","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":229681,"discussion_content":"对这个问题 好几个同学都提出来了 但是老师的好几次回答感觉还是太抽象  根本没有解答大家的疑惑啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586682358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1250262,"avatar":"https://static001.geekbang.org/account/avatar/00/13/13/d6/0cf21fe8.jpg","nickname":"Skylar","note":"","ucode":"9E8D1697BEE884","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6401,"discussion_content":"同样疑惑，感觉这个例子怎么看wait和notify调用的次数都会一样阿。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566885574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76154,"user_name":"陈华","can_delete":false,"product_type":"c1","uid":1082730,"ip_address":"","ucode":"3AF9E8EB39E507","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtS26SJpSF7JLu9pusGsy1Qln0NdQg1eV2YKOJxpX2QXaBuuyXMqZY3fm0rhzKwsqN5aa6CVNOQQ/132","comment_is_top":false,"comment_ctime":1552537916,"is_pvip":false,"replies":[{"id":"27804","content":"分布式情况下，要用分布式锁。可以用zk,redis,db来实现<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552567367,"ip_address":"","comment_id":76154,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18732407100","product_id":100023901,"comment_content":"老师扩张一下，如果程序 部署了好几份。 保证不了 Allocator 的单例性。<br>转账这个操作该怎么多线程呢？ 只能依靠数据库了吗？，","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443200,"discussion_content":"分布式情况下，要用分布式锁。可以用zk,redis,db来实现\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552567367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74983,"user_name":"张学磊","can_delete":false,"product_type":"c1","uid":1250029,"ip_address":"","ucode":"F545F384A6F1E1","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eotSSnZic41tGkbflx0ogIg3ia6g2muFY1hCgosL2t3icZm7I8Ax1hcv1jNgr6vrZ53dpBuGhaoc6DKg/132","comment_is_top":false,"comment_ctime":1552347666,"is_pvip":false,"replies":[{"id":"27463","content":"就喜欢你这样的读者了<br>😃","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552393064,"ip_address":"","comment_id":74983,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18732216850","product_id":100023901,"comment_content":"非常棒的课程，通俗易懂！","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442766,"discussion_content":"就喜欢你这样的读者了\n😃","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552393064,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74954,"user_name":"Pwhxbdk","can_delete":false,"product_type":"c1","uid":1333742,"ip_address":"","ucode":"64634AAF8F2CFD","user_header":"https://static001.geekbang.org/account/avatar/00/14/59/ee/92b7c27c.jpg","comment_is_top":false,"comment_ctime":1552321127,"is_pvip":false,"replies":[{"id":"27347","content":"看场景，并发量大的时候长时间拿不到锁会浪费cpu，并发量小的时候效率高","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552350458,"ip_address":"","comment_id":74954,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18732190311","product_id":100023901,"comment_content":"老师 那自旋锁是不是效率更高？","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442756,"discussion_content":"看场景，并发量大的时候长时间拿不到锁会浪费cpu，并发量小的时候效率高","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552350458,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250593,"user_name":"Chen Eric","can_delete":false,"product_type":"c1","uid":1667150,"ip_address":"","ucode":"1DDF695B96D51F","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/4e/683acfbc.jpg","comment_is_top":false,"comment_ctime":1601165804,"is_pvip":false,"replies":[{"id":"92928","content":"相当恰当������","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1603193865,"ip_address":"","comment_id":250593,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14486067692","product_id":100023901,"comment_content":"对于老师说的A，B，C, D的例子，我这里有一个例子，不知道是否恰当：<br>       假设现在有一个基于生产消费模型的例子，生产者需要资源A, B都在才能完成产品AB，消费者则必须在产品AB生成时才能被消费。假设开始时产品AB尚未完成，此时消费者都进入wait队列。生产者开始生产，假设生产者producer1已经获得资源(AB或者其中一个)，生产者procedure2尝试获得资源时，发现资源已被获取，因此procedure2进入到wait队列。producer1生产AB完毕之后，使用notify打算唤醒消费者线程。但是notify是随机唤醒，因此此时可能将producer2唤醒。producer2唤醒之后，发现产品AB还没被消费，因此此时producer2进入wait队列，这时候procedure2和消费线程将无法被唤醒。<br>       当我们使用notifyAll()时，它将唤醒所有的wait队列线程争夺锁，假如线程不满足条件再次进入wait时，其他唤醒的wait队列的线程仍旧会去争夺锁。","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506238,"discussion_content":"相当恰当������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603193865,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82552,"user_name":"刘鹏","can_delete":false,"product_type":"c1","uid":1230417,"ip_address":"","ucode":"44F3D4DB3F5678","user_header":"https://static001.geekbang.org/account/avatar/00/12/c6/51/e39b5828.jpg","comment_is_top":false,"comment_ctime":1554251259,"is_pvip":false,"replies":[{"id":"29894","content":"1.没有公平性保证<br>2.在哪里跌倒只能在哪里爬起来，单线程wait的下一条语句是什么就执行什么","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554293054,"ip_address":"","comment_id":82552,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14439153147","product_id":100023901,"comment_content":"老师，我有几个问题。<br>1,调用wait的线程，释放对象锁进入右侧队列，当调用notify唤醒的时候和左侧队列中的线程竞争锁是公平的吗？<br>2，wait的线程唤醒后是从wait的呢行代码执行吗？","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445633,"discussion_content":"1.没有公平性保证\n2.在哪里跌倒只能在哪里爬起来，单线程wait的下一条语句是什么就执行什么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554293054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379582,"discussion_content":"wait(）放在syschronized里面，syschronized是非公平锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623995940,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75895,"user_name":"aksonic","can_delete":false,"product_type":"c1","uid":1003633,"ip_address":"","ucode":"B6F3348F6714DB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/50/71/e8229703.jpg","comment_is_top":false,"comment_ctime":1552488960,"is_pvip":false,"replies":[{"id":"27690","content":"两个队列，左边一个，右边一个。500线程也是这两个。后面讲管程还会系统的讲。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552524737,"ip_address":"","comment_id":75895,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14437390848","product_id":100023901,"comment_content":"老师，对于郑晨Cc的问题，我和他想法一样，我也觉得不太对。<br>根据老师的回答是this这一把锁: synchronized void apply(){}<br>所以是一个等待队列，就是500个线程，也是同一个等待队列，因为锁的都是this，这个我可以理解，但是如果都是一把锁，为什么会有文章中的线程 1 申请到了 AB，线程 2 申请到了 CD？线程2不是应该会被线程1阻塞吗？线程2直接进入this锁的等待队列才对。。。望老师可以详细分析下，这里没有看懂。<br>","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443080,"discussion_content":"两个队列，左边一个，右边一个。500线程也是这两个。后面讲管程还会系统的讲。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552524737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75578,"user_name":"JStFs","can_delete":false,"product_type":"c1","uid":1241121,"ip_address":"","ucode":"636E85653555DD","user_header":"https://static001.geekbang.org/account/avatar/00/12/f0/21/7168f973.jpg","comment_is_top":false,"comment_ctime":1552437374,"is_pvip":false,"replies":[{"id":"27627","content":"你把转账的执行时间想的长一点，比如一年，再想想<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552476620,"ip_address":"","comment_id":75578,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14437339262","product_id":100023901,"comment_content":"王老师：<br><br>我记得账本Allocator是单例吧？如果是的话，apply（）方法不存在线程1抢到A和B，线程2同时又抢到了C和D吧？","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442951,"discussion_content":"你把转账的执行时间想的长一点，比如一年，再想想\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552476620,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75519,"user_name":"Smile","can_delete":false,"product_type":"c1","uid":1125189,"ip_address":"","ucode":"0617032294DC43","user_header":"https://static001.geekbang.org/account/avatar/00/11/2b/45/e8f64725.jpg","comment_is_top":false,"comment_ctime":1552407052,"is_pvip":false,"replies":[{"id":"27645","content":"并发艺术侧重讲实现，正好互补。感谢盛赞啊😄<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552480278,"ip_address":"","comment_id":75519,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14437308940","product_id":100023901,"comment_content":"看到评论里面说while的地方，当包含其中一个的话就表明已经被分配过,当前线程无法获取两个资源，就需要等待其他线程释放掉资源，自己才可以获取到。望老师指正，第一次跟着看下来，结合并发艺术一起看，老师讲课很新颖，赞一个👍","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442925,"discussion_content":"并发艺术侧重讲实现，正好互补。感谢盛赞啊😄\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552480278,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75504,"user_name":"helloWorld","can_delete":false,"product_type":"c1","uid":1137301,"ip_address":"","ucode":"5436F2A13DECC6","user_header":"https://static001.geekbang.org/account/avatar/00/11/5a/95/866bccb7.jpg","comment_is_top":false,"comment_ctime":1552405158,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14437307046","product_id":100023901,"comment_content":"看到很多同学说把代码贴出来，但是代码贴在文中占篇幅，而且不是每位同学都需要，建议老师考虑一下有些老师的做法，把Demo放在github上，然后在文中给出链接，供需要的同学学习","like_count":3},{"had_liked":false,"id":75476,"user_name":"walkingonair","can_delete":false,"product_type":"c1","uid":1444748,"ip_address":"","ucode":"0C8BEE064ABF8B","user_header":"https://static001.geekbang.org/account/avatar/00/16/0b/8c/db1ee0a2.jpg","comment_is_top":false,"comment_ctime":1552402710,"is_pvip":false,"replies":[{"id":"27602","content":"这个专栏还是聚焦让大家会写并发程序，水平高的可以去看并发包里锁的实现。后面介绍管程会更全面一些<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552453879,"ip_address":"","comment_id":75476,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14437304598","product_id":100023901,"comment_content":"这篇写的挺好，把等待和通知比较抽象的东西通过现实案例通俗易懂地讲解出来。不过，要是能讲讲除了同步关键字之外的实现就好了，给思路也行😊","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442908,"discussion_content":"这个专栏还是聚焦让大家会写并发程序，水平高的可以去看并发包里锁的实现。后面介绍管程会更全面一些\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552453879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115540,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1563614835,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10153549427","product_id":100023901,"comment_content":"---总结---<br>1. 每个互斥锁都有自己独立的等待队列。<br>2. wait和notify必然出现在sychronized块中，其操作的等待队列也是与互斥锁所对应的等待队列。<br>3. notify只能保证在通知时间点条件是满足的，即我们需要有wait的best practice:while(!condition){wait();}<br>4. 对于等待-通知机制的几个要素：互斥锁；何时等待；何时通知","like_count":2},{"had_liked":false,"id":88521,"user_name":"the geek","can_delete":false,"product_type":"c1","uid":1506723,"ip_address":"","ucode":"71DECBC814A539","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLz3icr3mGs5ib8FbSPQZ2ic3ib90mHkd1btQrmGacZjJxfYXrerIdaTxglKyCicFzLcEAb6deC2cWjE5Q/132","comment_is_top":false,"comment_ctime":1555935027,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10145869619","product_id":100023901,"comment_content":"我仔细思考了一下老师举得线程1\\2\\3\\4争夺A\\B\\C\\D的例子，如果使用notify的话，是不会出现线程3永远无法唤醒的情况的，因为这里其实是一个链式结构，notify不会丢失的。我举个例子<br>1. 线程1和2获得AB\\CD资源运行，线程3和4wait<br>2.线程1notify线程4，结果是线程2运行，线程3和4wait<br>3.线程2运行完notify线程3，线程3运行，线程4wait<br>4.线程3运行完notify线程4，线程4运行。全部运行完成<br>","like_count":2},{"had_liked":false,"id":87761,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1555685040,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10145619632","product_id":100023901,"comment_content":"哈哈哈，看了 @wang 的评论代码，好熟悉的感觉。去年的某个项目，也是使用 countdownlatch 来协调线程之间的交互。当时的需求：必须等待这一批次的所有线程完成后，才能启动下一批次的线程。<br>不过，这段代码，apply 成功后，还是需要给 src 和 target 上锁，同时 Account 类的 3 个方法，get&#47;set&#47;transaction 都要用 synchronized 修饰，否则还是存在线程安全问题。<br><br>----------<br><br>@郑晨Cc童鞋应该是将 Allocator 的锁，和对象资源的锁混淆了。老师在文章提到了等待-通知要考虑的 4 个要素：<br>1. 锁谁，Allocator<br>2. 要什么资源，ABCD<br>3. 什么时候等待<br>4. 什么时候唤醒<br><br>是由资源分配者 Allocator 来统一分配资源 A&#47;B&#47;C&#47;D，能不能申请资源成功，锁的是 Allocator，apply 成功返回，说明 A&#47;B&#47;C&#47;D 资源都被当前线程拿到了，后面就可以拿着这些资源去进行业务处理了。不过还是要考虑资源对象 A&#47;B&#47;C&#47;D 共享变量的线程安全问题。<br><br>如有理解有误，还望老师指正，谢谢！","like_count":2},{"had_liked":false,"id":82031,"user_name":"云里雾花","can_delete":false,"product_type":"c1","uid":1232383,"ip_address":"","ucode":"98D8E75D1B2B39","user_header":"https://static001.geekbang.org/account/avatar/00/12/cd/ff/b7690816.jpg","comment_is_top":false,"comment_ctime":1554106646,"is_pvip":false,"replies":[{"id":"29707","content":"wait和notify是一一对应的，如果浪费了一个notify，就必然有一个wait永远没机会被唤醒<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554129149,"ip_address":"","comment_id":82031,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10144041238","product_id":100023901,"comment_content":"老师你好，我想问的是，在尽量使用notifyAll()这里，例子里面线程3，对“再也没有机会被唤醒”的原因是因为线程太多导致一直随机不到该线程，还是其他原因，我没有搞懂，请老师提点。","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445436,"discussion_content":"wait和notify是一一对应的，如果浪费了一个notify，就必然有一个wait永远没机会被唤醒\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554129149,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78657,"user_name":"WP","can_delete":false,"product_type":"c1","uid":1105956,"ip_address":"","ucode":"4A24C6CAA70220","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/24/4529f2a4.jpg","comment_is_top":false,"comment_ctime":1553212433,"is_pvip":false,"replies":[{"id":"28679","content":"synchronized声明的锁对象与其内部调用wait和notify对象必须一个对象","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553268312,"ip_address":"","comment_id":78657,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10143147025","product_id":100023901,"comment_content":"此处的锁对象是this，我们利用条件控制假定A和B同时满足与否引入wait和notify 机制实现等待通知机制以替代循环等待机制，所以队列跟锁有关，一个锁一个队列，不论多少线程，只要synchronized处锁隐式还是显示声明的锁是这些线程需要争抢的，那么就在同一个线程等待队列中？还是说与wait和notify的对象有关？比如this.notify this.wait说明其等待队列与this有关，另外在synchronized声明的锁对象与其内部调用wait和notify对象是否必须一个对象呢","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444182,"discussion_content":"synchronized声明的锁对象与其内部调用wait和notify对象必须一个对象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553268312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78252,"user_name":"shangyu","can_delete":false,"product_type":"c1","uid":1011389,"ip_address":"","ucode":"13A26E53508D75","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6e/bd/b83ad32d.jpg","comment_is_top":false,"comment_ctime":1553104967,"is_pvip":true,"replies":[{"id":"28686","content":"保证互斥性，不允许两个线程同时进入管程","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553268939,"ip_address":"","comment_id":78252,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10143039559","product_id":100023901,"comment_content":"请问老师 为什么wait和notify必须要在获得锁的情况下才能调用呢","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444020,"discussion_content":"保证互斥性，不允许两个线程同时进入管程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553268939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76354,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1552576066,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10142510658","product_id":100023901,"comment_content":"看完老师的文章再看评论，感觉学习到了更多东西！","like_count":2},{"had_liked":false,"id":75648,"user_name":"木刻","can_delete":false,"product_type":"c1","uid":1157430,"ip_address":"","ucode":"0A3226FEE3983B","user_header":"https://static001.geekbang.org/account/avatar/00/11/a9/36/972f7abf.jpg","comment_is_top":false,"comment_ctime":1552443905,"is_pvip":false,"replies":[{"id":"27626","content":"如果还用这么简单的例子，多low啊<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552476355,"ip_address":"","comment_id":75648,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10142378497","product_id":100023901,"comment_content":"我猜老师讲Lock的时候会把例子中的wait和notify换成Condition的await和signal😊","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442974,"discussion_content":"如果还用这么简单的例子，多low啊\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552476355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1602505,"avatar":"https://static001.geekbang.org/account/avatar/00/18/73/c9/721c0827.jpg","nickname":"mlx","note":"","ucode":"DFE9604B6639E8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":203710,"discussion_content":"😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584069488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75451,"user_name":"苏籍","can_delete":false,"product_type":"c1","uid":1396252,"ip_address":"","ucode":"4FA289E084B789","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erYNBIwAj3KdIXaXbeMBUjTMz31zAToHIJSdo7oQk8bfsibwViaLobVQ8miatwBlC5spLS9kVCzHMjUA/132","comment_is_top":false,"comment_ctime":1552399681,"is_pvip":false,"replies":[{"id":"27598","content":"不可以，有可能这个线程点背，一直一直都满足不了条件","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552453136,"ip_address":"","comment_id":75451,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10142334273","product_id":100023901,"comment_content":"你好老师，为什么用While呢，if不就可以吗 ","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442899,"discussion_content":"不可以，有可能这个线程点背，一直一直都满足不了条件","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552453136,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75418,"user_name":"老王","can_delete":false,"product_type":"c1","uid":1236457,"ip_address":"","ucode":"79B81C8F6179CB","user_header":"https://static001.geekbang.org/account/avatar/00/12/dd/e9/c939283c.jpg","comment_is_top":false,"comment_ctime":1552394804,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10142329396","product_id":100023901,"comment_content":"一开始也是觉得while条件写反了，后来理解了。Allocator 是管理员分配者，而不是申请者","like_count":2},{"had_liked":false,"id":75157,"user_name":"龙猫","can_delete":false,"product_type":"c1","uid":1112490,"ip_address":"","ucode":"FD726CC969EF9C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/aa/3e80212e.jpg","comment_is_top":false,"comment_ctime":1552359289,"is_pvip":false,"replies":[{"id":"27396","content":"简单讲就是，为每一个请求分配一个独立的线程，网络处理支持bio和nio，servlet支持同步和异步，建议找本书专门看看","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552363633,"ip_address":"","comment_id":75157,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10142293881","product_id":100023901,"comment_content":"tomcat处理请求是如何处理并发问题的","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442808,"discussion_content":"简单讲就是，为每一个请求分配一个独立的线程，网络处理支持bio和nio，servlet支持同步和异步，建议找本书专门看看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552363633,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1228393,"avatar":"https://static001.geekbang.org/account/avatar/00/12/be/69/5404e5a3.jpg","nickname":"momo","note":"","ucode":"3B2CB1EC9BC601","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":359999,"discussion_content":"ThreadL:cal 关联http链接吗？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616337816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75023,"user_name":"王智","can_delete":false,"product_type":"c1","uid":1079657,"ip_address":"","ucode":"0335277F255F7A","user_header":"https://static001.geekbang.org/account/avatar/00/10/79/69/5960a2af.jpg","comment_is_top":false,"comment_ctime":1552351343,"is_pvip":false,"replies":[{"id":"27474","content":"这个一定是别人家的大学<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552396331,"ip_address":"","comment_id":75023,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10142285935","product_id":100023901,"comment_content":"wait会主动释放锁,sleep不会;<br><br>wait()中指定毫秒值,时间到了需要使用notify()&#47;notifyAll()唤醒; sleep()中指定毫秒值是睡眠一定时间自动唤醒.<br><br>大学操作系统学的,不知道记得对不对!!!<br>","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442780,"discussion_content":"这个一定是别人家的大学\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552396331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188176,"avatar":"https://static001.geekbang.org/account/avatar/00/12/21/50/265671fd.jpg","nickname":"LGY001","note":"","ucode":"29CA0F9501D3EC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":31276,"discussion_content":"操作系统老师说这个锅我不背","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570892825,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217992,"user_name":"witluo","can_delete":false,"product_type":"c1","uid":1443117,"ip_address":"","ucode":"3D9608C3DDDD95","user_header":"","comment_is_top":false,"comment_ctime":1589688443,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5884655739","product_id":100023901,"comment_content":"讲的通俗易懂，精彩","like_count":1},{"had_liked":false,"id":205604,"user_name":"有情有义","can_delete":false,"product_type":"c1","uid":1290428,"ip_address":"","ucode":"B200B466A90B07","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK2uagtiaicloiaKweyY6Sic8b9sJ2ibNaichSyibLCvRqkmnjACjyNCjellmSx6lbb0OBDCeAH8WNoyMomg/132","comment_is_top":false,"comment_ctime":1586682615,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5881649911","product_id":100023901,"comment_content":"<br><br><br><br><br>老师好 对于@请叫我紫皮书的问题<br> “假设我们有资源 A、B、C、D，线程 1 申请到了 AB，线程 2 申请到了 CD，此时线程 3 申请 AB，会进入等待队列（AB 分配给线程 1，线程 3 要求的条件不满足），线程 4 申请 CD 也会进入等待队列。我们再假设之后线程 1 归还了资源 AB，如果使用 notify() 来通知等待队列中的线程，有可能被通知的是线程 4，但线程 4 申请的是 CD，所以此时线程 4 还是会继续等待，而真正该唤醒的线程 3 就再也没有机会被唤醒了。” 老师，这里线程3是不是应该还有机会唤醒，比如线程2在notify的时候唤醒了线程3，我理解这样是可以的，请指正<br>作者回复: 有机会，那样线程4就没机会了。一个萝卜一个坑，有个坑被浪费了，总有一个萝卜找不到坑。<br>老师您的回答 还是感觉太抽象了啊  我还是不太能理解啊  如果是唤醒了线程3  这时候线程1和2都执行了  等线程3执行结束释放时候 不也会调用notify吗 这时候 只剩下线程4了 那就一定会唤醒线程4了啊  怎么您就说线程4就没机会了呢?????? 还望老师能具体的解答下啊","like_count":1,"discussions":[{"author":{"id":1475528,"avatar":"https://static001.geekbang.org/account/avatar/00/16/83/c8/5ce842f6.jpg","nickname":"maybe","note":"","ucode":"93D160F617E750","race_medal":4,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307049,"discussion_content":"    /**\n     * 这种情况下使用 notify 会出现有线程永远唤醒不了的情况。\n     * 1. 初始状态：4个线程可以抢锁 \n     *          锁池：consumer-1 consumer-2 provider-1 provider-2\n     *          等待池：empty\n     * \n     * 2. consumer-1 和 consumer-2 先抢到锁，此时queue为空，都wait了，进入等待池 \n     *          锁池：provider-1 provider-2\n     *          等待池：consumer-1 consumer-2\n     *          \n     * 3. provider-1 抢到锁，此时queue为空，add成功，执行notify通知等待池中一个线程进入锁池，假设consumer-1醒了\n     *          锁池：provider-2 consumer-1\n     *          等待池：consumer-2\n     * \n     * 4. provider-2 抢到锁，此时queue不是空（满了），provider-2需要wait，进入等待池 \n     *          锁池：consumer-1\n     *          等待池：consumer-2 provider-2\n     *       \n     * 5. consumer-1 必然抢到锁，此时queue不是空，remove成功，执行notify通知等待池中一个线程进入锁池，假设consumer-2醒了\n     *          锁池：consumer-2\n     *          等待池：provider-2\n     *          \n     * 6. consumer-2 必然抢到锁，此时queue为空，consumer-2需要wait\n     *          锁池：empty\n     *          等待池：consumer-2 provider-2\n     *          \n     * 然后锁池为empty了，没有线程能够得到锁，consumer-2 provider-2 一直睡到死\n     */","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600481352,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1475528,"avatar":"https://static001.geekbang.org/account/avatar/00/16/83/c8/5ce842f6.jpg","nickname":"maybe","note":"","ucode":"93D160F617E750","race_medal":4,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307048,"discussion_content":"    /**\n     * 这种情况下使用 notify 会出现有线程永远唤醒不了的情况。\n     * 1. 初始状态：4个线程可以抢锁 \n     *          锁池：consumer-1 consumer-2 provider-1 provider-2\n     *          等待池：empty\n     * \n     * 2. consumer-1 和 consumer-2 先抢到锁，此时queue为空，都wait了，进入等待池 \n     *          锁池：provider-1 provider-2\n     *          等待池：consumer-1 consumer-2\n     *          \n     * 3. provider-1 抢到锁，此时queue为空，add成功，执行notify通知等待池中一个线程进入锁池，假设consumer-1醒了\n     *          锁池：provider-2 consumer-1\n     *          等待池：consumer-2\n     * \n     * 4. provider-2 抢到锁，此时queue不是空（满了），provider-2需要wait，进入等待池 \n     *          锁池：consumer-1\n     *          等待池：consumer-2 provider-2\n     *       \n     * 5. consumer-1 必然抢到锁，此时queue不是空，remove成功，执行notify通知等待池中一个线程进入锁池，假设consumer-2醒了\n     *          锁池：consumer-2\n     *          等待池：provider-2\n     *          \n     * 6. consumer-2 必然抢到锁，此时queue为空，consumer-2需要wait\n     *          锁池：empty\n     *          等待池：consumer-2 provider-2\n     *          \n     * 然后锁池为empty了，没有线程能够得到锁，consumer-2 provider-2 一直睡到死\n     */","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600481344,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2618910,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/f6YBFBbXurWa9NJr42Z3Hfic223qsEVpAghY0W7DU2cRUicmKvg1QHsjPGRBP90wjV1yAGC8dzerRJcwribB0ibVlQ/132","nickname":"Geek_95323e","note":"","ucode":"92EFD57A73C726","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1475528,"avatar":"https://static001.geekbang.org/account/avatar/00/16/83/c8/5ce842f6.jpg","nickname":"maybe","note":"","ucode":"93D160F617E750","race_medal":4,"user_type":1,"is_pvip":false},"discussion":{"id":373893,"discussion_content":"可是对于文中的这种情况呢?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620908631,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":307048,"ip_address":""},"score":373893,"extra":""}]}]},{"had_liked":false,"id":160645,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1575992857,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5870960153","product_id":100023901,"comment_content":"厉害了，优化版的循环get","like_count":1},{"had_liked":false,"id":139689,"user_name":"skyline","can_delete":false,"product_type":"c1","uid":1002938,"ip_address":"","ucode":"4E73F9049751F6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/ba/83e6dcbf.jpg","comment_is_top":false,"comment_ctime":1570706329,"is_pvip":false,"replies":[{"id":"54021","content":"你又贡献了一点力量😄","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1570765911,"ip_address":"","comment_id":139689,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5865673625","product_id":100023901,"comment_content":"看评论比看正文花时间系列🤔","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470060,"discussion_content":"你又贡献了一点力量😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570765911,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133949,"user_name":"月半先生","can_delete":false,"product_type":"c1","uid":1440914,"ip_address":"","ucode":"0379FF659C36EA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTICgD2F3MDn1U6UHquN5kqNN05l3emRkZgOqJ6lib7dlg1Loia5mDbV8qbBVYXOo2oZicYuuhdSEC6Tg/132","comment_is_top":false,"comment_ctime":1568704309,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5863671605","product_id":100023901,"comment_content":"1.wait是Object类中的方法 sleep是Thread类中的方法<br>2.wait会释放锁 sleep不会释放锁<br>3.sleep需要指定时间","like_count":1},{"had_liked":false,"id":131084,"user_name":"ly","can_delete":false,"product_type":"c1","uid":1221628,"ip_address":"","ucode":"5E2B85252DABF3","user_header":"https://static001.geekbang.org/account/avatar/00/12/a3/fc/379387a4.jpg","comment_is_top":false,"comment_ctime":1567641866,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5862609162","product_id":100023901,"comment_content":"有个小疑惑，调用wait后线程A进入右侧的队列，当其他现程调用notify后进行唤醒，这里的唤醒是将这个线程A移动到左侧队列还是说并不移动，只是给这个线程A仅仅打个标示，标示它可以去竞争锁资源了？","like_count":1},{"had_liked":false,"id":125215,"user_name":"静水流深","can_delete":false,"product_type":"c1","uid":1339724,"ip_address":"","ucode":"644F05EFBD2E7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/4c/2cefec07.jpg","comment_is_top":false,"comment_ctime":1566121042,"is_pvip":false,"replies":[{"id":"50597","content":"感谢支持😄","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1568085281,"ip_address":"","comment_id":125215,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5861088338","product_id":100023901,"comment_content":"看过了那么多Java并发编程的文章，老师的专栏是最让我有兴趣学习的。谢谢。","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463481,"discussion_content":"感谢支持😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568085281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":113846,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1563172690,"is_pvip":false,"replies":[{"id":"41575","content":"也可以这么理解，不过这里的资源不限于是这些","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1563234620,"ip_address":"","comment_id":113846,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5858139986","product_id":100023901,"comment_content":"老师，你说的ABCD是不是可以理解为除了转账还有其他操作，存款取款等","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458407,"discussion_content":"也可以这么理解，不过这里的资源不限于是这些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563234620,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108031,"user_name":"马哲富","can_delete":false,"product_type":"c1","uid":1107917,"ip_address":"","ucode":"D6BDDFE3CC07ED","user_header":"https://static001.geekbang.org/account/avatar/00/10/e7/cd/08088f14.jpg","comment_is_top":false,"comment_ctime":1561649775,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5856617071","product_id":100023901,"comment_content":"我真的是一直看不明白为什么while的条件是（als.contains(from) || als.contains(to))，这样如果als里同时包含from和to的话岂不是也要等待？哪位同学能回答一下？","like_count":1,"discussions":[{"author":{"id":1481384,"avatar":"https://static001.geekbang.org/account/avatar/00/16/9a/a8/ed0ea046.jpg","nickname":"萌萌哒的鸡蛋饼.","note":"","ucode":"5E0E3F55F326A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6287,"discussion_content":"因为als里面存储的是已经申请掉的锁！所以但凡from和to无论哪一个包含在内，说明要申请的两个资源就不满足一次性申请条件。不知道这样解释理解了吗？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1566823238,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1007182,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/4e/85502e98.jpg","nickname":"balance","note":"","ucode":"324D909BBE69DE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":12668,"discussion_content":"als中有说明被别人拿走了，有一个拿走了你就得等","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568559938,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1449812,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erxAjBHiaJUyZqk8JWz1RHAY196YYlZj5HGGUric3pXYIOotzgRViauYxbz49Qt3TToFYW4YiapOIvQFg/132","nickname":"cpp","note":"","ucode":"85B13736CA43BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":10361,"discussion_content":"主要是因为锁对象是单例，无论哪个线程进来都需要去拿这个list中的资源，只不过代码中没写单理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568287200,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106270,"user_name":"斐波那契","can_delete":false,"product_type":"c1","uid":1464006,"ip_address":"","ucode":"85E2EBC01392B1","user_header":"https://static001.geekbang.org/account/avatar/00/16/56/c6/0b449bc6.jpg","comment_is_top":false,"comment_ctime":1561244823,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5856212119","product_id":100023901,"comment_content":"wait方法会释放当前的锁，就像文章中提到的 但是sleep不会释放当前的锁 但是需要try catch来抓住打断异常","like_count":1,"discussions":[{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379591,"discussion_content":"wait() 需要被try catch包围，以便发生异常中断也可以使wait等待的线程唤醒。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624002756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89775,"user_name":"劉小强","can_delete":false,"product_type":"c1","uid":1178474,"ip_address":"","ucode":"07FC2F0CDED869","user_header":"https://static001.geekbang.org/account/avatar/00/11/fb/6a/be4956a3.jpg","comment_is_top":false,"comment_ctime":1556261804,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5851229100","product_id":100023901,"comment_content":" &#47;&#47; 经典写法<br>    while(als.contains(from) ||<br>         als.contains(to)){<br>      try{<br>        wait();<br>      }catch(Exception e){<br>      }   <br>    }<br><br>为什么这么写 如果同时满足from和to 也进行等待么？","like_count":1},{"had_liked":false,"id":87235,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1555551660,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5850518956","product_id":100023901,"comment_content":"这就是生产者-消费者模式吧","like_count":1},{"had_liked":false,"id":86029,"user_name":"乐凡","can_delete":false,"product_type":"c1","uid":1239260,"ip_address":"","ucode":"918C9997EB6537","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/dc/32e78f02.jpg","comment_is_top":false,"comment_ctime":1555303493,"is_pvip":false,"replies":[{"id":"31151","content":"一个萝卜一个坑，浪费了一个坑，总会有一个萝卜找不到位置。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555412994,"ip_address":"","comment_id":86029,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5850270789","product_id":100023901,"comment_content":"老师，对于notify()唤醒线程比较的例子，线程1释放AB后， 通知了线程4，此时的情况是，线程1释放掉了AB资源，线程2持有CD资源，线程3申请AB进入等待队列，线程4申请CD处于进入队列，最后结果您说线程3再也没有机会被唤醒了，可以如果线程2释放了CD资源，但是通知的是线程3，此时资源AB是在之前就被线程1释放的，那么线程3被通知了，而且资源AB存在，不是应该被唤醒吗？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446881,"discussion_content":"一个萝卜一个坑，浪费了一个坑，总会有一个萝卜找不到位置。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555412994,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85071,"user_name":"肖邦的学徒","can_delete":false,"product_type":"c1","uid":1159128,"ip_address":"","ucode":"1DB95CD3E10F33","user_header":"https://static001.geekbang.org/account/avatar/00/11/af/d8/0f85fc8f.jpg","comment_is_top":false,"comment_ctime":1554971004,"is_pvip":false,"replies":[{"id":"30506","content":"浪费总比错误强多了，没有正确性，其他的都没意义","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554984147,"ip_address":"","comment_id":85071,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5849938300","product_id":100023901,"comment_content":"评论里面老师说notifyall和wait是成对<br>如果有好多持有1，2或是2，4的锁释放掉之后，被申请2，3的线程抢到了，但是他们条件不满足，<br>通知机会被浪费了 ，后面不是有好多wait没法获得通知吗","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446546,"discussion_content":"浪费总比错误强多了，没有正确性，其他的都没意义","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554984147,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82720,"user_name":"Vincent","can_delete":false,"product_type":"c1","uid":1135159,"ip_address":"","ucode":"CD8B84A57A6A0C","user_header":"https://static001.geekbang.org/account/avatar/00/11/52/37/13b4c8aa.jpg","comment_is_top":false,"comment_ctime":1554284615,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5849251911","product_id":100023901,"comment_content":"重点区分下那个方法是Object类提供的，那个方法是Thread提供的。","like_count":1},{"had_liked":false,"id":77143,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1552869958,"is_pvip":false,"replies":[{"id":"28131","content":"包含说明曾经被分配过<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552881239,"ip_address":"","comment_id":77143,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847837254","product_id":100023901,"comment_content":"为什么while的判断条件是这样的, while(als.contains(from) || als.contains(to)) , 不应该是不包含吗?<br>","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443602,"discussion_content":"包含说明曾经被分配过\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552881239,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77142,"user_name":"JGOS","can_delete":false,"product_type":"c1","uid":1237592,"ip_address":"","ucode":"46A905A169408F","user_header":"https://static001.geekbang.org/account/avatar/00/12/e2/58/2468a5e9.jpg","comment_is_top":false,"comment_ctime":1552869921,"is_pvip":false,"replies":[{"id":"28125","content":"可以有，按照营业厅分啊<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552880040,"ip_address":"","comment_id":77142,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847837217","product_id":100023901,"comment_content":"老师，这个账本管理员的锁粒度好像有点粗，所有的账本都由这一个人来管，应该有更细粒度的实现方式吧","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443601,"discussion_content":"可以有，按照营业厅分啊\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552880040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76490,"user_name":"南北少卿","can_delete":false,"product_type":"c1","uid":1018958,"ip_address":"","ucode":"DFCC59F2BBD8CE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/4e/b81969fa.jpg","comment_is_top":false,"comment_ctime":1552618966,"is_pvip":false,"replies":[{"id":"27934","content":"没问题，只要有一个存在，就说明曾经被分配过<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552650961,"ip_address":"","comment_id":76490,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847586262","product_id":100023901,"comment_content":"while(als.contains(from) || als.contains(to))这个判断条件是不是有点问题？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443327,"discussion_content":"没问题，只要有一个存在，就说明曾经被分配过\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552650961,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75882,"user_name":"aksonic","can_delete":false,"product_type":"c1","uid":1003633,"ip_address":"","ucode":"B6F3348F6714DB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/50/71/e8229703.jpg","comment_is_top":false,"comment_ctime":1552487415,"is_pvip":false,"replies":[{"id":"27731","content":"1.是<br>2.不是，会进入图里右边的队列<br>3.有通知机制，但不是notify<br>后面讲管程会再详细讲<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552536416,"ip_address":"","comment_id":75882,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847454711","product_id":100023901,"comment_content":"老师请问，如果有线程A，线程B，线程C，同时想进入synchronized（this）代码块<br>1. 如果只有线程C进入了，线程A和线程B是不是都进入了this锁的等待队列？<br>2. 如果线程C进入后，又调用了wait();， 则是不是线程C不但释放了锁，也进入了this锁的等待队列？<br>3.  如果线程C进入后，又调用了wait(); 则是不是有一个隐含操作是notify了线程B或者线程C，否则他们两个如何从等待队列中出来，重新争夺锁呢？<br>对于这个完整的流程希望老师可以帮忙解答，谢谢","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443073,"discussion_content":"1.是\n2.不是，会进入图里右边的队列\n3.有通知机制，但不是notify\n后面讲管程会再详细讲\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552536416,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75701,"user_name":"我劝你善良","can_delete":false,"product_type":"c1","uid":1447802,"ip_address":"","ucode":"99ACEDE16B19D3","user_header":"https://static001.geekbang.org/account/avatar/00/16/17/7a/ab9bb6df.jpg","comment_is_top":false,"comment_ctime":1552452684,"is_pvip":false,"replies":[{"id":"27646","content":"他们都需要重新竞争锁，所以需要每次都notifyall，要不然就有线程可能永远醒不了了<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552480546,"ip_address":"","comment_id":75701,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847419980","product_id":100023901,"comment_content":"老师，假设我们有资源 A、B、C、D，线程 1 申请到了 AB，线程2申请CD的这个例子，线程3，4分别请求锁定AB，CD从而等待的话。线程1归还了AB，那么使用notify来通知等待中线程的话，是随机通知3，4中的任意一个，有可能3永远通知不到对吧？那么notifyAll来通知的话，我理解的是同时通知等待中的3，4吗？然后3，4再去竞争他们需要的锁资源，是等待队列中的所有线程3，4都会被唤醒，他们都会去争取他们需要的锁资源吗？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442987,"discussion_content":"他们都需要重新竞争锁，所以需要每次都notifyall，要不然就有线程可能永远醒不了了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552480546,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75190,"user_name":"WolvesLeader","can_delete":false,"product_type":"c1","uid":1103839,"ip_address":"","ucode":"33610E19CA2E96","user_header":"https://static001.geekbang.org/account/avatar/00/10/d7/df/fc0a6709.jpg","comment_is_top":false,"comment_ctime":1552361598,"is_pvip":false,"replies":[{"id":"27469","content":"cpu执行权怎么理解？<br>去操作系统里查看线程状态就可以了，线程都阻塞了，没法验证，也可以看线程的cpu使用率<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552393853,"ip_address":"","comment_id":75190,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847328894","product_id":100023901,"comment_content":"网上一般说2方面区别 <br>1.锁的释放还是不释放<br>2.cpu执行权，我的困惑是一直没办法验证对cpu执行权的影响，为了这个问题也看过jvm的源码，没看出啥道道来，老师有啥demo或者其他的方式能看出2方法对执行权的影响吗？谢谢谢谢","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442817,"discussion_content":"cpu执行权怎么理解？\n去操作系统里查看线程状态就可以了，线程都阻塞了，没法验证，也可以看线程的cpu使用率\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552393853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75105,"user_name":"___","can_delete":false,"product_type":"c1","uid":1229519,"ip_address":"","ucode":"B0BA5A1413798C","user_header":"https://static001.geekbang.org/account/avatar/00/12/c2/cf/573a0fdc.jpg","comment_is_top":false,"comment_ctime":1552355610,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5847322906","product_id":100023901,"comment_content":"wait会释放锁资源，sleep不会释放<br>wait可以通过notify，notifyAll来通知唤醒","like_count":1},{"had_liked":false,"id":75095,"user_name":"Lrwin","can_delete":false,"product_type":"c1","uid":1180503,"ip_address":"","ucode":"5E394E36419C56","user_header":"https://static001.geekbang.org/account/avatar/00/12/03/57/31595f22.jpg","comment_is_top":false,"comment_ctime":1552355119,"is_pvip":false,"replies":[{"id":"27460","content":"1.不能<br>2.是<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552392463,"ip_address":"","comment_id":75095,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847322415","product_id":100023901,"comment_content":"有两个队列:等待获取锁的队列(简称A队列)和调用wait 方法的队列(简称B队列)<br><br>问题1.调用notify 后，一定是B队列的线程可以获取锁吗？<br>问题2:在synchronized 代码块中，如果notify 后边还有代码，是执行后面所有的代码才释放锁吗？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442797,"discussion_content":"1.不能\n2.是\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552392463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74999,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1552349651,"is_pvip":false,"replies":[{"id":"27453","content":"java里看不到<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552389960,"ip_address":"","comment_id":74999,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847316947","product_id":100023901,"comment_content":"老师，怎么查看synchronized(A.class)阻塞后进入的等待队列？  就是，等待队列，对应的现实代码，在哪里能看到啊？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442772,"discussion_content":"java里看不到\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552389960,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74998,"user_name":"渔夫","can_delete":false,"product_type":"c1","uid":1019289,"ip_address":"","ucode":"6BF08FD8923E45","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/99/f886543d.jpg","comment_is_top":false,"comment_ctime":1552349492,"is_pvip":false,"replies":[{"id":"27455","content":"比较全面的说法是有三个条件，后面介绍管程的时候会说明这个问题。不过你说的这个最关键！👍<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552390116,"ip_address":"","comment_id":74998,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847316788","product_id":100023901,"comment_content":"如果所有线程的等待条件都是一样的话，就可以使用 notify 来进行通知，对吗？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442771,"discussion_content":"比较全面的说法是有三个条件，后面介绍管程的时候会说明这个问题。不过你说的这个最关键！👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552390116,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74979,"user_name":"峰","can_delete":false,"product_type":"c1","uid":1056019,"ip_address":"","ucode":"C53CB64E8E7D19","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg","comment_is_top":false,"comment_ctime":1552347204,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5847314500","product_id":100023901,"comment_content":"wait会释放当前调用对象的锁，这也就意味着调用之前的持有这把锁,否着会抛出异常。<br>wait是object方法，sleep是Thread的静态方法。","like_count":1},{"had_liked":false,"id":359101,"user_name":"自在飞","can_delete":false,"product_type":"c1","uid":1167825,"ip_address":"北京","ucode":"A2712148DA06E0","user_header":"https://static001.geekbang.org/account/avatar/00/11/d1/d1/62f74aa7.jpg","comment_is_top":false,"comment_ctime":1665237941,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665237941","product_id":100023901,"comment_content":"老师 你好，有个问题没想明白，请您指教下哈：<br><br>如果【等待条件】并非一个而是多个的时候，此时就算使用notifyAll()也有可能导致【某些本该被唤醒的线程得不到唤醒】的机会吧？","like_count":0},{"had_liked":false,"id":359094,"user_name":"自在飞","can_delete":false,"product_type":"c1","uid":1167825,"ip_address":"北京","ucode":"A2712148DA06E0","user_header":"https://static001.geekbang.org/account/avatar/00/11/d1/d1/62f74aa7.jpg","comment_is_top":false,"comment_ctime":1665230517,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665230517","product_id":100023901,"comment_content":"老师 您好，请问下 图中画的那两个等待队列怎么理解？他们有什么区别吗？","like_count":0},{"had_liked":false,"id":357017,"user_name":"在路上","can_delete":false,"product_type":"c1","uid":1476245,"ip_address":"重庆","ucode":"2668A965FA79F2","user_header":"https://static001.geekbang.org/account/avatar/00/16/86/95/b9d960d9.jpg","comment_is_top":false,"comment_ctime":1662863942,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662863942","product_id":100023901,"comment_content":"wait会主动释放锁，sleep不会释放锁<br>用四个线程执行转账业务，在get方法里分别使用sleep和wait并在后面跟上一条打印语句，观察得到。在我当前线程后面进入get方法的线程在我执行完sleep之后不会打印任何输出语句，但是当我执行完wait方法后打印语句语句就执行了<br>public synchronized void get(Object from, Object to) {<br>        while (list.contains(from) || list.contains(to)) {<br>            try {<br>                Thread.sleep(1000);<br>                System.out.println(&quot;我是seleep，我不释放锁&quot;);<br>                wait();<br>                System.out.println(&quot;hello,我把锁释放了&quot;);<br>            } catch (InterruptedException e) {<br>                throw new RuntimeException(e);<br>            }<br>        }<br>        list.add(from);<br>        list.add(to);<br>    }","like_count":0},{"had_liked":false,"id":354210,"user_name":"Geek_e009ee","can_delete":false,"product_type":"c1","uid":3014916,"ip_address":"福建","ucode":"EB5DB9A8D6DBA2","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqKiaa7OE3FelFiaUmFCiaMUTn1kG3UrR3ZuzTOl5bSGDTjThn3ujFQgcbeZBPump30Jfzb4EEZeUhaQ/132","comment_is_top":false,"comment_ctime":1660188709,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660188709","product_id":100023901,"comment_content":"wait与sleep的区别在于<br>1.wait在线程挂起的时候，会释放锁资源。而sleep不会<br>2.wait如果没有设置参数的话，需要notify才能被唤醒，而sleep不需要<br>3.wait只能在同步代码块中才能运行，而sleep全局都可以运行<br>4.sleep需要捕获异常，而wait不需要","like_count":0},{"had_liked":false,"id":352664,"user_name":"高玉华","can_delete":false,"product_type":"c1","uid":2950398,"ip_address":"","ucode":"6E6C221C8ABF63","user_header":"","comment_is_top":false,"comment_ctime":1658845968,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658845968","product_id":100023901,"comment_content":"synchronized (obj) { obj.wait()} 怎么理解原子性？","like_count":0},{"had_liked":false,"id":345742,"user_name":"学习学个屁","can_delete":false,"product_type":"c1","uid":1049017,"ip_address":"","ucode":"DF2D61E6FB2FCE","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","comment_is_top":false,"comment_ctime":1652541376,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652541376","product_id":100023901,"comment_content":"wait() ： 释放资源，不会占用cpu资源，一定需要一个Lock对象调用<br> sleep() ： 不会释放，会占用cpu资源，需要捕获异常，不需要lock对象调用。是属于线程对象。","like_count":0},{"had_liked":false,"id":343735,"user_name":"宋计洋","can_delete":false,"product_type":"c1","uid":2076251,"ip_address":"","ucode":"9A34E8F71C6CBD","user_header":"https://static001.geekbang.org/account/avatar/00/1f/ae/5b/4bd42286.jpg","comment_is_top":false,"comment_ctime":1651029393,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651029393","product_id":100023901,"comment_content":"我感觉老师带着问题去解释为什么用synchronized, wait, notify,notifyAll，一下就明白这三个方法的作用，之前都是死记硬背那些线程的状态，用哪个方法从什么状态到什么状态，完全不理解","like_count":0},{"had_liked":false,"id":335903,"user_name":"正宗老菜鸟","can_delete":false,"product_type":"c1","uid":1926177,"ip_address":"","ucode":"F54623D3A2DC5C","user_header":"https://static001.geekbang.org/account/avatar/00/1d/64/21/9e743711.jpg","comment_is_top":false,"comment_ctime":1645763410,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645763410","product_id":100023901,"comment_content":"简直不要太强了，环环相扣，把每一个晦涩难懂的原理都用生活中的例子具体化表示出来，想不懂都难啊。","like_count":0},{"had_liked":false,"id":335441,"user_name":"陈某某","can_delete":false,"product_type":"c1","uid":1670520,"ip_address":"","ucode":"1153BAF44936FB","user_header":"https://static001.geekbang.org/account/avatar/00/19/7d/78/c638dc56.jpg","comment_is_top":false,"comment_ctime":1645519639,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1645519639","product_id":100023901,"comment_content":" &#47;&#47; 转账<br>    void transfer(Account target, int amt)  {<br>        allocator.apply(this, target);<br>        if (this.balance &gt; amt) {<br>            this.balance -= amt;<br>            target.balance += amt;<br>        }<br>        allocator.free(this,target);<br><br><br>    }<br><br>    public static void main(String[] args) throws InterruptedException {<br>        Account a1 = new Account(1);<br>        Account a2 = new Account(2);<br><br>        Thread th1 = new Thread(() -&gt; {<br>            try {<br>                a1.transfer(a2, 99);<br>            } catch (InterruptedException e) {<br>                e.printStackTrace();<br>            }<br><br>        });<br><br>        Thread th2 = new Thread(() -&gt; {<br>            try {<br>                a2.transfer(a1, 1);<br>            } catch (InterruptedException e) {<br>                e.printStackTrace();<br>            }<br>        });<br><br>        th1.start();<br>        th2.start();<br><br>        th1.join();<br>        th2.join();<br><br>        System.out.println(&quot;a1 =&quot; + a1.balance);<br>        System.out.println(&quot;a2 =&quot; + a2.balance);<br>}","like_count":0},{"had_liked":false,"id":335165,"user_name":"枫林血舞","can_delete":false,"product_type":"c1","uid":2809867,"ip_address":"","ucode":"EE7F6DA78D21EA","user_header":"https://static001.geekbang.org/account/avatar/00/2a/e0/0b/6f667b2c.jpg","comment_is_top":false,"comment_ctime":1645368639,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1645368639","product_id":100023901,"comment_content":"1、wait()派生自类Object()，所有的对象都有该方法；sleep()是Thread类，并且标注为static + native。<br>2、wait()方法会释放锁，当前线程由running状态进入阻塞状态，并进入阻塞队列；而sleep()不会释放锁，当sleep的时间到了后，后续操作继续。<br>3、wait()方法需要和notify()&#47;notifyAll()配合使用，被唤醒后，线程由阻塞队列进入同步队列，等待持有锁；sleep()到点就可以继续，无需配合。","like_count":0},{"had_liked":false,"id":331674,"user_name":"Geek_039a5c","can_delete":false,"product_type":"c1","uid":1651848,"ip_address":"","ucode":"08F4FA864D4B65","user_header":"","comment_is_top":false,"comment_ctime":1642698225,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1642698225","product_id":100023901,"comment_content":"老师您好。 我想问个问题。  Allocator 这个类是不是要是单例模式才行？ 这里锁的是this。 如果是有多个Allocator实例的话，每个人都维护一个als。这样 并不是线程安全吧？<br>&#47;&#47; 一次性申请所有资源<br>  synchronized void apply(<br>    Object from, Object to){<br>    &#47;&#47; 经典写法<br>    while(als.contains(from) ||<br>         als.contains(to)){<br>      try{<br>        wait();<br>      }catch(Exception e){<br>      }   <br>    } <br>    als.add(from);<br>    als.add(to);  <br>  }","like_count":0},{"had_liked":false,"id":327946,"user_name":"李小红","can_delete":false,"product_type":"c1","uid":1132163,"ip_address":"","ucode":"7776F5B29B8423","user_header":"https://static001.geekbang.org/account/avatar/00/11/46/83/76f6ec67.jpg","comment_is_top":false,"comment_ctime":1640414255,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640414255","product_id":100023901,"comment_content":"如果锁的是class，那么怎么吊用wait和notify","like_count":0},{"had_liked":false,"id":319329,"user_name":"Geek_7a9e2c","can_delete":false,"product_type":"c1","uid":1265132,"ip_address":"","ucode":"00DC77B9C85EE3","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er78PmxPDq4a3vNuvvX10fiaBC4FZ7XXuOX1nMjhCIqiaHWfpjfd5CDoVVB0GRGveChNmkSmuy7smxQ/132","comment_is_top":false,"comment_ctime":1635747810,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635747810","product_id":100023901,"comment_content":"sleep只是单纯的让渡时间片，不会释放锁资源；wait同时会释放锁资源","like_count":0},{"had_liked":false,"id":316357,"user_name":"Donkey","can_delete":false,"product_type":"c1","uid":2753834,"ip_address":"","ucode":"3DB4DFF6D99035","user_header":"https://static001.geekbang.org/account/avatar/00/2a/05/2a/cfbcb0b2.jpg","comment_is_top":false,"comment_ctime":1634285805,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634285805","product_id":100023901,"comment_content":"看不太明白的可以看看线程生命周期","like_count":0},{"had_liked":false,"id":315005,"user_name":"官宝儿","can_delete":false,"product_type":"c1","uid":2110827,"ip_address":"","ucode":"03B4312475A984","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI5eicXFWltiaF9ibsEh2nNC80OYoHibhhE0X1hPHZ5KuAtY4Yxp5dQ4LsciaDxUHFBPlJM7kgQwkspzsQ/132","comment_is_top":false,"comment_ctime":1633655311,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633655311","product_id":100023901,"comment_content":"sleep线程是不是不会被notify notifyAll唤醒，它只是到点了自动唤醒，wait是除非notify 否则一直阻塞","like_count":0},{"had_liked":false,"id":314117,"user_name":"菜波","can_delete":false,"product_type":"c1","uid":2032894,"ip_address":"","ucode":"DA7DED66709FA2","user_header":"https://static001.geekbang.org/account/avatar/00/1f/04/fe/60db4684.jpg","comment_is_top":false,"comment_ctime":1632846545,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632846545","product_id":100023901,"comment_content":"如果使用 notify() 来通知等待队列中的线程，有可能被通知的是线程 4，但线程 4 申请的是 CD，所以此时线程 4 还是会继续等待，而真正该唤醒的线程 3 就再也没有机会被唤醒了。<br>======<br>老师，归还AB的线程nofity()是唤起了4，这说明AB上的notify()是不能定向唤起持有该锁资源的3的<br>我想问下，1.java为什么不将等待资源和等待队列1:1对应呢？比如将1，3放入1个AB的等待队列，2，4放入CD的等待队列。当AB有归还时，只需要检查AB的的等待队列，这样做效率应该更高<br>2.如果归还AB的线程nofity()是唤起了4，那3也可能会被其他的归还唤起吧？","like_count":0},{"had_liked":false,"id":307731,"user_name":"Geek_067762","can_delete":false,"product_type":"c1","uid":2311005,"ip_address":"","ucode":"B3C3CFD1C05283","user_header":"","comment_is_top":false,"comment_ctime":1629216723,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629216723","product_id":100023901,"comment_content":"public class MyLock {<br><br>    public static void main(String[] args) throws InterruptedException {<br>        Acount acount = new Acount(10000);<br>        Acount acount2 = new Acount(10000);<br>        CountDownLatch countDownLatch = new CountDownLatch(9999);<br>        for (int i = 0; i &lt; 9999; i++) {<br>            new Thread(() -&gt; {<br>                acount.transformTo(1, acount2);<br>                countDownLatch.countDown();<br>            }).start();<br>        }<br>        countDownLatch.await();<br>        System.out.println(acount.money);<br>        System.out.println(acount2.money);<br><br>    }<br><br><br>    static class Acount {<br>        private int money;<br><br>        public Acount(int money) {<br>            this.money = money;<br>        }<br><br>        public void transformTo(int money, Acount to) {<br>            this.money -= money;<br>            to.transFromIn(money);<br>        }<br><br>        public void transFromIn(int money) {<br>            this.money += money;<br>        }<br>    }<br>}<br><br>我还没加锁，我的执行打印结果为什么总是   1，19999   不能浮现出线程不安全","like_count":0},{"had_liked":false,"id":301226,"user_name":"小乙哥","can_delete":false,"product_type":"c1","uid":1063308,"ip_address":"","ucode":"C77E79BEA0C325","user_header":"https://static001.geekbang.org/account/avatar/00/10/39/8c/089525aa.jpg","comment_is_top":false,"comment_ctime":1625581469,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625581469","product_id":100023901,"comment_content":"有个体会，每节讲得内容一定要写一下代码，精华都在细节当中。然后一点一点去思考其中的内容，再加上老师的讲解，理解会深一点。第一次看只是看看内容，回头发现都忘了，就是这个原因","like_count":0},{"had_liked":false,"id":298867,"user_name":"X中倪","can_delete":false,"product_type":"c1","uid":1418862,"ip_address":"","ucode":"F28FAFF2FEDD1A","user_header":"https://static001.geekbang.org/account/avatar/00/15/a6/6e/21907ff9.jpg","comment_is_top":false,"comment_ctime":1624350430,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624350430","product_id":100023901,"comment_content":"notify和notifyall的区别<br><br>notify  是通知当前锁定条件变量。进行抢占cpu资源。如果没有就绪等待队列为空的情况、就不作为。<br><br>notifyall 是通知所有的线程进行抢占cpu资源。<br><br>notify：好比Java组长 ，我现在发出通知 ，你们有啥问题 需要来找我解决 （仅仅是Java相关的，有问题的Java程序员找组长解决问题 ，没有问题 就干其他事情）<br><br>notifyall：好比cto ，我现在有空闲了 ，你们有什么问题需要来找我解决（前端、后端、运维 、产品 等都来抢占这个 坑位）<br>“前提条件就是 这些等待条件变量的线程必须在就绪队列里面”<br><br>现实开发工程中：可以说很难去把控锁定的资源 ，到底该用哪一个通知。 ","like_count":0},{"had_liked":false,"id":291302,"user_name":"第四单元","can_delete":false,"product_type":"c1","uid":1747184,"ip_address":"","ucode":"3ED9D553E1DE17","user_header":"https://static001.geekbang.org/account/avatar/00/1a/a8/f0/529f15e9.jpg","comment_is_top":false,"comment_ctime":1620195922,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620195922","product_id":100023901,"comment_content":"wait和sleep的区别：<br>1.如果在sync块中调用，sleep不会释放锁，wait会释放锁<br>2.sleep是Thread类的方法，它在任何地方都可以调用。wait是Object的方法，只有在获取到sync锁时才能调用被锁对象的wait方法。<br>3.sleep方法到达指定时间后转入runable状态，可继续执行。wait可以被notify、notifyAll唤醒，或到达指定时间后唤醒。但唤醒后还要继续申请锁，申请成功后才能继续在wait调用的下一句执行。<br>4.调用sleep后线程进入blocked状态，调用wait后进入waiting状态。","like_count":0},{"had_liked":false,"id":289729,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1619156929,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619156929","product_id":100023901,"comment_content":"#### wait()和sleep()的区别<br><br>- wait()的父类是Object；sleep()的父类是Thread<br>- wait()会释放锁；sleep()不会释放锁<br>- wait()需要notify()去唤醒；sleep()不需要唤醒，等待一段时间就自动唤醒<br>- wait()需要在synchronized{}内部使用；sleep()不需要","like_count":0},{"had_liked":false,"id":288827,"user_name":"张滔","can_delete":false,"product_type":"c1","uid":1322636,"ip_address":"","ucode":"87ABAFF0E861E0","user_header":"https://static001.geekbang.org/account/avatar/00/14/2e/8c/b261e15a.jpg","comment_is_top":false,"comment_ctime":1618718267,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618718267","product_id":100023901,"comment_content":"从我的测试显示，synchronized的入口等待队列是一个LIFO的队列。","like_count":0},{"had_liked":false,"id":287415,"user_name":"RoccoLee","can_delete":false,"product_type":"c1","uid":2508667,"ip_address":"","ucode":"C55AD67FF8C2D7","user_header":"https://static001.geekbang.org/account/avatar/00/26/47/7b/c5ec018c.jpg","comment_is_top":false,"comment_ctime":1617937210,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1617937210","product_id":100023901,"comment_content":"课后思考：sleep方法阻塞线程，不释放锁；wait方法阻塞线程，会释放锁","like_count":0},{"had_liked":false,"id":277828,"user_name":"山海","can_delete":false,"product_type":"c1","uid":1702117,"ip_address":"","ucode":"77FA9967E58FA3","user_header":"https://static001.geekbang.org/account/avatar/00/19/f8/e5/119d5c15.jpg","comment_is_top":false,"comment_ctime":1612609382,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1612609382","product_id":100023901,"comment_content":"假设我们有资源 A、B、C、D，线程 1 申请到了 AB，线程 2 申请到了 CD，此时线程 3 申请 AB，会进入等待队列（AB 分配给线程 1，线程 3 要求的条件不满足），线程 4 申请 CD 也会进入等待队列。我们再假设之后线程 1 归还了资源 AB，如果使用 notify() 来通知等待队列中的线程，有可能被通知的是线程 4，但线程 4 申请的是 CD，所以此时线程 4 还是会继续等待，而真正该唤醒的线程 3 就再也没有机会被唤醒了<br>-----------<br>老师，我对这段话适用notify()风险问题理解不是很透彻，虽然线程AB执行完毕之后，同志对是线程4，但是一旦线程2执行结束后，在进行notify后， 也很有可能再次通知到线程3，所以这里应该是没有问题对，不知道我对理解对不对","like_count":0},{"had_liked":false,"id":276943,"user_name":"张滔","can_delete":false,"product_type":"c1","uid":1322636,"ip_address":"","ucode":"87ABAFF0E861E0","user_header":"https://static001.geekbang.org/account/avatar/00/14/2e/8c/b261e15a.jpg","comment_is_top":false,"comment_ctime":1612186518,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612186518","product_id":100023901,"comment_content":"为什么notifyAll之后只有一个线程被执行了？     <br>        Object a = new Object();<br>        Object b = new Object();<br>        Object c = new Object();<br><br>        Allocator allocator = new Allocator();<br><br>        Thread t1 = new Thread(new Runnable() {<br>            @Override<br>            public void run() {<br>                allocator.apply(a,b);<br>                try {<br>                    Thread.sleep(30000);<br>                } catch (InterruptedException e) {<br>                    e.printStackTrace();<br>                }<br><br>                allocator.free(a,b);<br>            }<br>        });<br>        t1.start();<br><br>        Thread.sleep(1000);<br><br>        Thread t2 = new Thread(new Runnable() {<br>            @Override<br>            public void run() {<br>                allocator.apply(a,b);<br>                System.out.println(Thread.currentThread().getName());<br>            }<br>        });<br>        t2.start();<br><br>        Thread.sleep(1000);<br><br>        Thread t3 = new Thread(new Runnable() {<br>            @Override<br>            public void run() {<br>                allocator.apply(a,b);<br>                System.out.println(Thread.currentThread().getName());<br>            }<br>        });<br>        t3.start();","like_count":0},{"had_liked":false,"id":276934,"user_name":"张滔","can_delete":false,"product_type":"c1","uid":1322636,"ip_address":"","ucode":"87ABAFF0E861E0","user_header":"https://static001.geekbang.org/account/avatar/00/14/2e/8c/b261e15a.jpg","comment_is_top":false,"comment_ctime":1612183510,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612183510","product_id":100023901,"comment_content":"两个问题：<br>1、被notifyAll或notify之后的线程是会进入左侧等待队列中吗？<br>2、被notifyAll之后的这些线程的执行是有顺序的还是随机的？左侧等待队列中的线程获取互斥锁是随机的还是有顺序的？","like_count":0},{"had_liked":false,"id":264134,"user_name":"@Dimples","can_delete":false,"product_type":"c1","uid":1520936,"ip_address":"","ucode":"91951FBFEB9B64","user_header":"https://static001.geekbang.org/account/avatar/00/17/35/28/c729d3ae.jpg","comment_is_top":false,"comment_ctime":1606359905,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606359905","product_id":100023901,"comment_content":"既然是用了等待队列，那synchronized不就成了公平锁了吗，每次都在队头拿线程","like_count":0},{"had_liked":false,"id":261136,"user_name":"Geek_c75d82","can_delete":false,"product_type":"c1","uid":2286012,"ip_address":"","ucode":"81202A016FC5D2","user_header":"","comment_is_top":false,"comment_ctime":1605227052,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605227052","product_id":100023901,"comment_content":"wait可以被唤醒，sleep只能一直等","like_count":0},{"had_liked":false,"id":259974,"user_name":"xzy","can_delete":false,"product_type":"c1","uid":1002095,"ip_address":"","ucode":"1A44368083A19E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/6f/e36b3908.jpg","comment_is_top":false,"comment_ctime":1604901809,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604901809","product_id":100023901,"comment_content":"wait和sleep的区别<br>- wait 需要写在sychronized代码块内，sleep不需要<br>- wait 会释放锁，sleep不会<br>- wait 需要其他线程调用notify方法唤醒","like_count":0},{"had_liked":false,"id":256588,"user_name":"lakeslove","can_delete":false,"product_type":"c1","uid":1277081,"ip_address":"","ucode":"65E14D29D3C981","user_header":"https://static001.geekbang.org/account/avatar/00/13/7c/99/4dac6ce6.jpg","comment_is_top":false,"comment_ctime":1603684622,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1603684622","product_id":100023901,"comment_content":"使用notify时，文中说，真正该唤醒的线程 3 就再也没有机会被唤醒了。<br>但是如果每个线程都是先执行apply()，再执行free(),那么每个线程都应该能被唤醒啊，<br>是我的推理哪里出问题了吗？<br>推理如下：<br><br>等线程2执行完了apply，释放了CD的锁，<br>如果线程2还没执行free时，线程4开始执行apply，那么线程4执行到wait继续等待，此时线程2执行了free，可能通知线程3，也可能通知线程4，反正就是线程3和4，总有一个没被通知到，但是被通知的总会执行free，进而通知剩下的那个进程，所以所有线程都会执行，没问题。<br>如果线程2已经执行了free，线程4开始执行apply，那么线程4执行apply到wait不会等待，线程4执行完apply后继续执行free，此时会通知唯一剩下的线程3，，所以所有线程都会执行，也没问题。<br><br>所以问题到底在哪？","like_count":0,"discussions":[{"author":{"id":2618910,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/f6YBFBbXurWa9NJr42Z3Hfic223qsEVpAghY0W7DU2cRUicmKvg1QHsjPGRBP90wjV1yAGC8dzerRJcwribB0ibVlQ/132","nickname":"Geek_95323e","note":"","ucode":"92EFD57A73C726","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373894,"discussion_content":"没问题,别想了 例子有问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620908769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":255952,"user_name":"bidinggong","can_delete":false,"product_type":"c1","uid":1898806,"ip_address":"","ucode":"789A1FBA8408F3","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f9/36/f44b633e.jpg","comment_is_top":false,"comment_ctime":1603465354,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1603465354","product_id":100023901,"comment_content":"线程协作方式在很多情况下都可以用等待 - 通知机制来优化。Java 语言内置的 synchronized 配合 wait()、notify()、notifyAll() 这三个方法可以快速实现这种机制","like_count":0},{"had_liked":false,"id":245576,"user_name":"罗樱罂","can_delete":false,"product_type":"c1","uid":2045997,"ip_address":"","ucode":"9072E79E625ED1","user_header":"https://static001.geekbang.org/account/avatar/00/1f/38/2d/f3c6493e.jpg","comment_is_top":false,"comment_ctime":1598988959,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598988959","product_id":100023901,"comment_content":"老师，请问一下aqs的核心是不是就是state， 同步队列，等待队列三个？然后线程主要在同步对了和等待队列中来回切换？我在其他网站上查了很多相关资料。有些都是队列两三句话就改名字了。。。还有说 阻塞队列，不知道是不是等待队列？","like_count":0},{"had_liked":false,"id":242673,"user_name":"fightingD","can_delete":false,"product_type":"c1","uid":1443637,"ip_address":"","ucode":"AD2876CED5D5AC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKwViav94kcF50CxA0Jw7icicxociaVzut97iacy3b2ciacFqXuFWdiakVq304YcI8pt4HT5A1Yvp8EkYCpw/132","comment_is_top":false,"comment_ctime":1597807489,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597807489","product_id":100023901,"comment_content":"wait()会释放获取的锁，sleep()并不会释放锁","like_count":0},{"had_liked":false,"id":242291,"user_name":"William","can_delete":false,"product_type":"c1","uid":1346215,"ip_address":"","ucode":"55F5D9DEE485B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","comment_is_top":false,"comment_ctime":1597661302,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1597661302","product_id":100023901,"comment_content":"个人感觉：这3可能会被唤醒， 但是条件是不符合的， 所以是有机会唤醒，而没机会执行了。<br><br><br><br>假设我们有资源 A、B、C、D，线程 1 申请到了 AB，线程 2 申请到了 CD，此时线程 3 申请 AB，会进入等待队列（AB 分配给线程 1，线程 3 要求的条件不满足），线程 4 申请 CD 也会进入等待队列。我们再假设之后线程 1 归还了资源 AB，如果使用 notify() 来通知等待队列中的线程，有可能被通知的是线程 4，但线程 4 申请的是 CD，所以此时线程 4 还是会继续等待，而真正该唤醒的线程 3 就再也没有机会被唤醒了。<br><br><br>","like_count":0},{"had_liked":false,"id":241917,"user_name":"prepared","can_delete":false,"product_type":"c1","uid":1194853,"ip_address":"","ucode":"00E54A5C7CDCBE","user_header":"https://static001.geekbang.org/account/avatar/00/12/3b/65/3a4fc8cf.jpg","comment_is_top":false,"comment_ctime":1597500076,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597500076","product_id":100023901,"comment_content":"wait需要通知，才会重新启动；<br>sleep是睡眠一段时间，自动重新启动","like_count":0},{"had_liked":false,"id":222094,"user_name":"古夜","can_delete":false,"product_type":"c1","uid":1341612,"ip_address":"","ucode":"0A82D3CFCEDF07","user_header":"https://static001.geekbang.org/account/avatar/00/14/78/ac/e5e6e7f3.jpg","comment_is_top":false,"comment_ctime":1590676063,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590676063","product_id":100023901,"comment_content":"那线程要求的条件满足时，该怎么通知这个等待的线程呢？<br>这里的线程要求写错了吧，应该是临界区要求吧","like_count":0},{"had_liked":false,"id":216860,"user_name":"UniqueDirt","can_delete":false,"product_type":"c1","uid":2001375,"ip_address":"","ucode":"1E5555EE495733","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJkDobVTaXD0oWouJBHQQSvnicJnzfZ7cSKmZeV20svZ7uWKGkibnL8xXiaOPRPYP7IibVIWPaCBDhjMw/132","comment_is_top":false,"comment_ctime":1589355991,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589355991","product_id":100023901,"comment_content":"notifyAll()唤醒的顺序应该是从后至前的， 例如线程T1 在1这个时间点wait, T2在2这个时间点wait，T3在3这个时间点wait，时间1 早于 时间2 早于时间3；那么调用notify之后唤醒的顺序应该是T3&gt;T2&gt;T1;因为while的存在，此次各线程wait的时间点顺序（除真正唤醒的线程之外）发生了调换，从而保证了每个线程都是有机会真正唤醒的，且在时间上更为合理，避免了notify随机唤醒的不公平机制","like_count":0},{"had_liked":false,"id":213880,"user_name":"sky","can_delete":false,"product_type":"c1","uid":1008071,"ip_address":"","ucode":"9FE5F43055D3AB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/61/c7/b64ac05e.jpg","comment_is_top":false,"comment_ctime":1588583250,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588583250","product_id":100023901,"comment_content":"wait() 操作工作原理图 里的 左边队列  和右边队列是同一个队列么? 还是2个不同的队列<br>1:如果是同一个队列为什么要分左边右边?<br>2:如果是2个队列,上面写了 这个等待队列和互斥锁是一对一的关系，每个互斥锁都有自己独立的等待队列<br>而这里用的是同一个互斥锁 this,求解答","like_count":0},{"had_liked":false,"id":209684,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1587600893,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587600893","product_id":100023901,"comment_content":"两者的作用不一样，wait是需要临界资源，避免死锁会释放锁。而sleep作用是阻塞自身线程，并不是缺少临界资源，而是让出cpu让其他非同一把锁的线程有机会执行。","like_count":0},{"had_liked":false,"id":209257,"user_name":"bin.chen","can_delete":false,"product_type":"c1","uid":1135604,"ip_address":"","ucode":"5BA49358AB8A1A","user_header":"https://static001.geekbang.org/account/avatar/00/11/53/f4/e277325d.jpg","comment_is_top":false,"comment_ctime":1587525308,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587525308","product_id":100023901,"comment_content":"wait和sleep从本质区别来说:等待的时候是否可以让别人使用共享资源的问题<br>转账问题从上节的while循到等待通知机制转换只是优化了在转账过程中其他线程没有必要再去一直尝试获取锁操作资源，从而节省了一直尝试获取锁带来的过渡cpu消耗和性能","like_count":0},{"had_liked":false,"id":206010,"user_name":"Eric W.Liu","can_delete":false,"product_type":"c1","uid":1960096,"ip_address":"","ucode":"8B394A3C1448BA","user_header":"https://static001.geekbang.org/account/avatar/00/1d/e8/a0/14de6984.jpg","comment_is_top":false,"comment_ctime":1586772852,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586772852","product_id":100023901,"comment_content":"wait方法会实去monitor的所有权，而sleep不会失去monitor的所有权","like_count":0},{"had_liked":false,"id":205606,"user_name":"你存在～我脑海里","can_delete":false,"product_type":"c1","uid":1786377,"ip_address":"","ucode":"3E06D047764062","user_header":"https://static001.geekbang.org/account/avatar/00/1b/42/09/8cfa5a76.jpg","comment_is_top":false,"comment_ctime":1586683079,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586683079","product_id":100023901,"comment_content":"wait、sleep区别：<br>1.wait释放锁，其他线程可以继续争夺锁；sleep不释放锁，只是休眠一段时间，其他线程仍然在等待队列中<br>2.synchronize和wait、notify&#47;notifyAll相当于用于实现等待、通知机制固定的黄金搭档。效果同lock.newCondition，不过condition可以实现特定资源通知，比其更加强大。<br>3.wait、notify&#47;notifyAll方法时Object中的方法，所有对象都可以使用（在synchronize修饰代码段中），sleep是Thread类的方法，用于指定线程休眠一段时间（睡一会）。","like_count":0},{"had_liked":false,"id":205578,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1586677592,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586677592","product_id":100023901,"comment_content":"wait() ：锁等待，会释放锁，释放资源，其他线程可重新获取锁<br>sleep()：锁等待，不会释放锁，占用资源，其他线程继续等待","like_count":0},{"had_liked":false,"id":203800,"user_name":"Josey","can_delete":false,"product_type":"c1","uid":1813086,"ip_address":"","ucode":"BA461C259CC64B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/aa/5e/9be28107.jpg","comment_is_top":false,"comment_ctime":1586268279,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586268279","product_id":100023901,"comment_content":"老师你上面的例子，调用notifyAll()方法线程3一定可以获取到锁吗？是所有等待队列中的线程3和4获取到锁的机制相等，还是只有需要AB条件的线程3会获取到锁？","like_count":0},{"had_liked":false,"id":201598,"user_name":"xfun","can_delete":false,"product_type":"c1","uid":1070581,"ip_address":"","ucode":"A9A08E9EA6E13B","user_header":"https://static001.geekbang.org/account/avatar/00/10/55/f5/8d1588bd.jpg","comment_is_top":false,"comment_ctime":1585810046,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585810046","product_id":100023901,"comment_content":"第一个等待队列的状态是“同步阻塞”，第二个等待队列状态是“等待阻塞”。临界区调用wait()后，线程进入等待阻塞状态，直到notify() 和 notifyAll()被调用后，线程进入“同步阻塞”状态。也就是说，notify() 和 notifyAll()后线程是就绪状态的，跟其他线程一样，需要再次抢占对象锁，才能进入临界区。","like_count":0},{"had_liked":false,"id":198826,"user_name":"Geek_c22199","can_delete":false,"product_type":"c1","uid":1441876,"ip_address":"","ucode":"1CE5B65513E360","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2vn8hyjICTCletGs0omz28lhriaZKX2XX9icYzAEon2IEoRnlXqyOia2bEPP0j7T6xexTnr77JJic8w/132","comment_is_top":false,"comment_ctime":1585469785,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585469785","product_id":100023901,"comment_content":"感觉有点不完美，不如按一定顺序加锁","like_count":0},{"had_liked":false,"id":192587,"user_name":"Zain Zhu","can_delete":false,"product_type":"c1","uid":1125986,"ip_address":"","ucode":"5402E6FF76333A","user_header":"https://static001.geekbang.org/account/avatar/00/11/2e/62/ea49480e.jpg","comment_is_top":false,"comment_ctime":1584862182,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584862182","product_id":100023901,"comment_content":"老师用现实世界的问题做类比这点很适合我这样的低智商理解","like_count":0},{"had_liked":false,"id":191311,"user_name":"zhangchao","can_delete":false,"product_type":"c1","uid":1508339,"ip_address":"","ucode":"E665D153A85DE0","user_header":"https://static001.geekbang.org/account/avatar/00/17/03/f3/0bd094ad.jpg","comment_is_top":false,"comment_ctime":1584762352,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584762352","product_id":100023901,"comment_content":"老师讲的太好了","like_count":0},{"had_liked":false,"id":189639,"user_name":"Mr.wang","can_delete":false,"product_type":"c1","uid":1224805,"ip_address":"","ucode":"86F341A5316BBC","user_header":"https://static001.geekbang.org/account/avatar/00/12/b0/65/90387745.jpg","comment_is_top":false,"comment_ctime":1584537320,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1584537320","product_id":100023901,"comment_content":"wait是object的等待方法，而sleep是线程的等待方法，两个方法的含义相同，但是使用方式却大大不同。<br>sleep只是休眠线程，不会释放线程，会让线程停留在原地等候，而wait则会释放线程，让任务进入到等待队列，等到其他的线程去唤醒它。","like_count":0},{"had_liked":false,"id":187302,"user_name":"阮少","can_delete":false,"product_type":"c1","uid":1740204,"ip_address":"","ucode":"2F007C96CB60F9","user_header":"https://static001.geekbang.org/account/avatar/00/1a/8d/ac/8a428bd8.jpg","comment_is_top":false,"comment_ctime":1584079692,"is_pvip":false,"replies":[{"id":"72699","content":"👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1584356663,"ip_address":"","comment_id":187302,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1584079692","product_id":100023901,"comment_content":"补充一点，wait方法可以释放锁，而notifyAll或notify 方法是不释放锁的。所以执行通知方法时，如果当前同步代码块没有走完的话，wait后面的方法是继续等待的","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487067,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584356663,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187247,"user_name":"mlx","can_delete":false,"product_type":"c1","uid":1602505,"ip_address":"","ucode":"DFE9604B6639E8","user_header":"https://static001.geekbang.org/account/avatar/00/18/73/c9/721c0827.jpg","comment_is_top":false,"comment_ctime":1584069214,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584069214","product_id":100023901,"comment_content":"由于个人在实际工作中对于并发编程的实际经验少，而对于并发编程的学习与理解又不是太好。看了这个专题后感觉老是讲的真的是好，通俗易懂！！！","like_count":0},{"had_liked":false,"id":186254,"user_name":"厉害了我的国","can_delete":false,"product_type":"c1","uid":1052191,"ip_address":"","ucode":"CD0A54A1B998AA","user_header":"https://static001.geekbang.org/account/avatar/00/10/0e/1f/d0472177.jpg","comment_is_top":false,"comment_ctime":1583808757,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583808757","product_id":100023901,"comment_content":"调用sleep()会让当前线程睡眠一段时间后继续执行，如果占有锁不会释放。调用wait()会立刻释放锁，什么时候醒不确定，要等notify()通知","like_count":0},{"had_liked":false,"id":185737,"user_name":"Daiver","can_delete":false,"product_type":"c1","uid":1466447,"ip_address":"","ucode":"9B1A03AFBC79BC","user_header":"https://static001.geekbang.org/account/avatar/00/16/60/4f/db0e62b3.jpg","comment_is_top":false,"comment_ctime":1583673086,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583673086","product_id":100023901,"comment_content":"wait会释放锁，sleep不会。","like_count":0},{"had_liked":false,"id":179819,"user_name":"Geek_bb89c3","can_delete":false,"product_type":"c1","uid":1331828,"ip_address":"","ucode":"0F97B5B0F2DDD6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/IZKGetBZDuMEa2VwwtesTELvLORIyV749ItgfAqNPv30n4zEv71wuGNr1aNVIVltG0icvH53DHDuqPuzNpiauWAg/132","comment_is_top":false,"comment_ctime":1582104521,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582104521","product_id":100023901,"comment_content":"while(als.contains(from) || als.contains(to))<br>{<br>      try{<br>          wait(); <br>            }catch(Exception e){ }<br> }<br>这段代码有一些奇怪的地方是。如果als中包含任何一个资源。这个时候就需要等待。<br>这里和如果添加不成立，就等待。命名这里是成立的为什么还需要等待呢？<br>这里需要站在多线程的角度来思考这个问题。als中的对象是其他的线程在使用这个对象。<br>如果当前线程想要获取到两个锁的时候，必须是当前线程将这两个对象添加进去的才行。<br>同时也说明，这各个对象正在被其他的对象使用当中。","like_count":0},{"had_liked":false,"id":179807,"user_name":"Geek_bb89c3","can_delete":false,"product_type":"c1","uid":1331828,"ip_address":"","ucode":"0F97B5B0F2DDD6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/IZKGetBZDuMEa2VwwtesTELvLORIyV749ItgfAqNPv30n4zEv71wuGNr1aNVIVltG0icvH53DHDuqPuzNpiauWAg/132","comment_is_top":false,"comment_ctime":1582102825,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582102825","product_id":100023901,"comment_content":"Thread.sleep()表示当前线程阻塞一段时间。然后重新等待调度。这个当中是会持有锁的。<br>object.wait（）方法表示在临界区代码不满足条件。释放锁，然后添加到object的wait队列中。然后等待object.notify方法唤醒这个队列重新去争锁。","like_count":0},{"had_liked":false,"id":170105,"user_name":"万事屋","can_delete":false,"product_type":"c1","uid":1105854,"ip_address":"","ucode":"57C08B85373B0D","user_header":"https://static001.geekbang.org/account/avatar/00/10/df/be/c6f8953f.jpg","comment_is_top":false,"comment_ctime":1578532354,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578532354","product_id":100023901,"comment_content":"老师，看看这篇文章，他说notifyall不会唤醒全部<br>https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;zAYN95p0YvGhhlcW4xCqhw","like_count":0},{"had_liked":false,"id":169716,"user_name":"jason","can_delete":false,"product_type":"c1","uid":1167872,"ip_address":"","ucode":"3329F08BAF307E","user_header":"https://static001.geekbang.org/account/avatar/00/11/d2/00/9a247b1e.jpg","comment_is_top":false,"comment_ctime":1578410800,"is_pvip":false,"replies":[{"id":"67026","content":"总结的很到位👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1579316213,"ip_address":"","comment_id":169716,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578410800","product_id":100023901,"comment_content":"老师，文中说到了使用notify()的风险。我觉得这个风险的原因在于，处于同一等待队列的所有线程，它们进入等待队列时的条件是不同的。<br><br>如果所有线程都是因为不满足同一个条件而进入等待队列，那么就可以使用notify()，单独通知一个线程。使用notify()的好处是，使尽量少的线程被调度到同步队列，这样就减少了锁竞争，减少了同步队列的线程上下文切换次数，从而提高性能。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480688,"discussion_content":"总结的很到位👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579316213,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158515,"user_name":"TTY","can_delete":false,"product_type":"c1","uid":1206935,"ip_address":"","ucode":"D097636D322215","user_header":"https://static001.geekbang.org/account/avatar/00/12/6a/97/9422bf31.jpg","comment_is_top":false,"comment_ctime":1575391336,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575391336","product_id":100023901,"comment_content":"这里说一下关于while(als.contains(from) || als.contains(to))我的理解，我也是看了好久，翻了好多遍评论才看懂。<br><br>首先有两点大家需要明白：<br>1. Allocator对象actr只有一个，因为是单例，多个线程操作的是同一个actr。<br>2. actr是资源分配者，而不是资源请求者。<br><br>假如有一个线程调用actr.apply(this, target)。<br>1. 如果apply()成员函数返回的话，说明actr对象将from和this都添加进了als中。下一步将是对this和target加锁，进行业务处理，最后调用actr.free(this, target)；<br>2. 如果apply()成员函数阻塞的话，说明als中包含from或者this或者两者，即while条件成立。这说明什么？说明此时已经有另外一个线程调用了actr.apply(this, target)且返回了，但还未调用actr.free(this, target)将this和target从als中移除，所以第一个线程需要阻塞等待，因为此时als中的this或者target并不是第一个线程添加进als中的。<br><br>这里说一种特殊情况，仅供加深理解，毕竟应该没人会这么写：<br>如果一个线程连续两次调用actr.apply(this, target)，在两次调用actr.apply(this, target)语句之间没有调用actr.free(this, target)，那么该线程将永久阻塞，在这之后，其他调用了actr.apply(this, target)的所有线程也将永久阻塞。还是要注意这里actr是单例，只有一个，所有线程共享这一个actr对象。<br><br>如果有讲的不对的地方，麻烦指正。","like_count":0},{"had_liked":false,"id":152376,"user_name":"。","can_delete":false,"product_type":"c1","uid":1337641,"ip_address":"","ucode":"2012A6830EAEE0","user_header":"https://static001.geekbang.org/account/avatar/00/14/69/29/dfe2988e.jpg","comment_is_top":false,"comment_ctime":1573985983,"is_pvip":false,"replies":[{"id":"67117","content":"一旦有权利执行，就一定持有当前锁","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1579438354,"ip_address":"","comment_id":152376,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573985983","product_id":100023901,"comment_content":"老师我有一个问题<br>通过notifyAll唤醒的右侧等待队列中的线程，是继续在wait()方法后执行的，那他是否持有当前锁呢？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474795,"discussion_content":"一旦有权利执行，就一定持有当前锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579438354,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":149993,"user_name":"朕爱吾妃","can_delete":false,"product_type":"c1","uid":1733692,"ip_address":"","ucode":"B10EB69934F9E2","user_header":"https://static001.geekbang.org/account/avatar/00/1a/74/3c/da79d2a1.jpg","comment_is_top":false,"comment_ctime":1573442559,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573442559","product_id":100023901,"comment_content":"wait与sleep的区别：<br>1. wait方法是Object类中的方法，而sleep是Thread类里的方法<br>2. wait方法会主动释放锁资源，而sleep方法则是让线程睡眠，但不会释放锁资源<br>3. wait方法可以指定什么时候释放资源，而sleep不能指定，只能默默等待<br>4. wait方法必须在获取锁资源后才能使用，而sleep则不需要","like_count":0},{"had_liked":false,"id":149542,"user_name":"Sundayge","can_delete":false,"product_type":"c1","uid":1572264,"ip_address":"","ucode":"6A125D700CBDAB","user_header":"","comment_is_top":false,"comment_ctime":1573269620,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573269620","product_id":100023901,"comment_content":"我觉得线程的阻塞和等待状态描述的不太清晰，当10个线程争抢同一把锁的时候，只有一个线程获取到锁，那么其他的9个线程处于阻塞状态。<br>当同步代码块中调用了wait方法的时候，线程会放到同步队列中(也就是文章中说的右边的等待队列，我觉得还是区分下好，不然全叫等待队列大家都晕了)，此时线程处于等待状态(这个状态叫等待我觉得更好，因为此时的线程连获取锁的权利都没有)，当线程被唤醒时则再次取争抢锁。","like_count":0},{"had_liked":false,"id":147538,"user_name":"考休","can_delete":false,"product_type":"c1","uid":1053955,"ip_address":"","ucode":"968DFC00D6D0CF","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/03/c0fe1dbf.jpg","comment_is_top":false,"comment_ctime":1572868818,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572868818","product_id":100023901,"comment_content":"敲黑板！<br>Java并发编程中的wait()、notify()、notifyAll()三个方法执行主体都是被锁定的对象！千万不要搞混了！","like_count":0},{"had_liked":false,"id":146030,"user_name":"Garwen","can_delete":false,"product_type":"c1","uid":1045062,"ip_address":"","ucode":"C76346E1734AB8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f2/46/09c457eb.jpg","comment_is_top":false,"comment_ctime":1572422014,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572422014","product_id":100023901,"comment_content":"老师，在allocator这个例子中，当我们调用了notifyall之后，应该是唤醒了图中右侧的等待队列中的线程，然后从sychronized中退出，释放了锁，那是不是意味着，图中右侧的等待队列中的线程其实是比左侧从未获取过锁的线程在时间上会提前获取到锁执行呢。","like_count":0},{"had_liked":false,"id":144928,"user_name":"请叫我紫皮书","can_delete":false,"product_type":"c1","uid":1203288,"ip_address":"","ucode":"29F98AB3A5D98E","user_header":"https://static001.geekbang.org/account/avatar/00/12/5c/58/590d0a43.jpg","comment_is_top":false,"comment_ctime":1572097713,"is_pvip":false,"replies":[{"id":"56147","content":"有机会，那样线程4就没机会了。一个萝卜一个坑，有个坑被浪费了，总有一个萝卜找不到坑。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1572310211,"ip_address":"","comment_id":144928,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572097713","product_id":100023901,"comment_content":"“假设我们有资源 A、B、C、D，线程 1 申请到了 AB，线程 2 申请到了 CD，此时线程 3 申请 AB，会进入等待队列（AB 分配给线程 1，线程 3 要求的条件不满足），线程 4 申请 CD 也会进入等待队列。我们再假设之后线程 1 归还了资源 AB，如果使用 notify() 来通知等待队列中的线程，有可能被通知的是线程 4，但线程 4 申请的是 CD，所以此时线程 4 还是会继续等待，而真正该唤醒的线程 3 就再也没有机会被唤醒了。” 老师，这里线程3是不是应该还有机会唤醒，比如线程2在notify的时候唤醒了线程3，我理解这样是可以的，请指正","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472169,"discussion_content":"有机会，那样线程4就没机会了。一个萝卜一个坑，有个坑被浪费了，总有一个萝卜找不到坑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572310211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144912,"user_name":"耀明","can_delete":false,"product_type":"c1","uid":1446437,"ip_address":"","ucode":"99D03E4547EB70","user_header":"https://static001.geekbang.org/account/avatar/00/16/12/25/f9cdf7e9.jpg","comment_is_top":false,"comment_ctime":1572090941,"is_pvip":false,"replies":[{"id":"55882","content":"介绍管程的时候，会讲到这个问题","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1572098156,"ip_address":"","comment_id":144912,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572090941","product_id":100023901,"comment_content":"&#47;&#47; 归还资源  synchronized void free(    Object from, Object to){      notifyAll();  ...... }<br>老师 请问执行了notifyAll()后会立刻通知其它阻塞的线程吗，假如notifyAll();后面还有执行的代码怎么办，这时候还未释放锁","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472162,"discussion_content":"介绍管程的时候，会讲到这个问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572098156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144177,"user_name":"无言的约定","can_delete":false,"product_type":"c1","uid":1128953,"ip_address":"","ucode":"5E8046EB6B7956","user_header":"https://static001.geekbang.org/account/avatar/00/11/39/f9/acfb9a48.jpg","comment_is_top":false,"comment_ctime":1571876109,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571876109","product_id":100023901,"comment_content":"ABCD那个例子中，线程3和线程4是在图中左侧的等待队列还是右侧的等待队列呢？这两个等待队列有什么区别？","like_count":0},{"had_liked":false,"id":142234,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1571317321,"is_pvip":false,"replies":[{"id":"54906","content":"没有😂","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1571360515,"ip_address":"","comment_id":142234,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1571317321","product_id":100023901,"comment_content":"感觉老师的文章是不是改过，跟第一次看感觉有点不一样，感觉补充了些内容。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471039,"discussion_content":"没有😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571360515,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141775,"user_name":"这得从我捡到一个鼠标垫开始说起","can_delete":false,"product_type":"c1","uid":1272321,"ip_address":"","ucode":"2FF4347B4E7A9B","user_header":"https://static001.geekbang.org/account/avatar/00/13/6a/01/d9cb531d.jpg","comment_is_top":false,"comment_ctime":1571223136,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1571223136","product_id":100023901,"comment_content":"为什么wait和notify是Object的方法而不是Thread的方法","like_count":0},{"had_liked":false,"id":141681,"user_name":"Geek_be4cec","can_delete":false,"product_type":"c1","uid":1581294,"ip_address":"","ucode":"C87642D655EAC3","user_header":"","comment_is_top":false,"comment_ctime":1571210404,"is_pvip":false,"replies":[{"id":"54746","content":"一直循环","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1571227354,"ip_address":"","comment_id":141681,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571210404","product_id":100023901,"comment_content":"老师，例子中的下句代码<br>while(als.contains(from)||als. als.contains(to)){<br>      wait();<br>}<br>while条件满足时，会不会一直循环执行wait，还是执行一次？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470843,"discussion_content":"一直循环","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571227354,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140366,"user_name":"LGY001","can_delete":false,"product_type":"c1","uid":1188176,"ip_address":"","ucode":"29CA0F9501D3EC","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/50/265671fd.jpg","comment_is_top":false,"comment_ctime":1570893579,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570893579","product_id":100023901,"comment_content":"对于资源分配问题我是这样理解的：<br>线程对共享资源进行操作时，首先需要获取一个锁对象lock，获取锁对象之后才能够进行相关的执行逻辑，线程1获取到了锁对象，但是执行相关任务的逻辑需要满足一定的条件，而这时不满足，会导致该线程执行lock.wait()方法（即加入到条件变量的等待队列之中），同时释放锁对象lock,线程2紧接着获取锁对象，在执行的过程之中，同样发现不满足相关条件，执行lock.wait()方法（加入到条件变量的等待队列之中，此时条件变量的等待队列队列中有两个阻塞的队列），线程3获取锁对象，执行了相关操作，可能使条件变量满足，从而执行notify()方法，notify()方法会随机唤醒条件变量等待队列中的一个线程，可能正好唤醒的不是已经满足条件的线程1而是线程2，而线程2在执行时，发现仍然不满足重新加入条件变量的等待队列。这就会导致线程1饿死，无法被唤醒的情况出现。","like_count":0},{"had_liked":false,"id":140365,"user_name":"LGY001","can_delete":false,"product_type":"c1","uid":1188176,"ip_address":"","ucode":"29CA0F9501D3EC","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/50/265671fd.jpg","comment_is_top":false,"comment_ctime":1570892372,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570892372","product_id":100023901,"comment_content":"wait和sleep方法比较：<br>相同点：<br>- 线程执行wait方法和sleep方法都会阻塞当前线程<br>- 线程执行wait方法和sleep阻塞的过程之中都能感受到中断信号，会抛出InterruptedException.<br>不同点：<br>- wait&#47;notify、notifyAll方法必须在synchronized关键字修饰的同步方法或者同步代码块中执行，而sleep方法不需要，（这是因为wait系列方法是线程间同步机制的保证，需要一定的顺序性，若是没有synchronized修饰，可能会发生线程在执行wait方法之前发生了切换，导致notify方法先于wait方法执行，从而导致原来的线程陷入死锁或者不能唤醒的情况。除此之外，wait系列方法操作的对象须是synchronized锁对象，否则会抛出IllegalMonitorStateException）<br>- wait方法会释放锁对象，该线程可能在一段时候后被唤醒，也可能被饿死；而sleep方法并不会释放锁对象，在一定的时间（确定的）后该线程会继续执行。<br>- wait方法属于Object类的方法，而sleep方法属于Thread类的方法。wait系列方法操作的对象是锁对象，而一个线程之中可能有多个锁对象<br>","like_count":0},{"had_liked":false,"id":137885,"user_name":"245864982","can_delete":false,"product_type":"c1","uid":1238485,"ip_address":"","ucode":"AC47075A95B759","user_header":"https://static001.geekbang.org/account/avatar/00/12/e5/d5/680402fd.jpg","comment_is_top":false,"comment_ctime":1569904732,"is_pvip":false,"replies":[{"id":"53013","content":"👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1569928446,"ip_address":"","comment_id":137885,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569904732","product_id":100023901,"comment_content":"sleep不会释放锁资源，只是让出cpu。wait会释放锁资源。<br>sleep到了设置的时间之后自动唤醒。wait需要notify唤醒。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469294,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569928446,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135154,"user_name":"吟游雪人","can_delete":false,"product_type":"c1","uid":1063805,"ip_address":"","ucode":"C432C9577B420C","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/7d/6376926b.jpg","comment_is_top":false,"comment_ctime":1569046136,"is_pvip":false,"replies":[{"id":"53725","content":"继续执行","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1570624506,"ip_address":"","comment_id":135154,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569046136","product_id":100023901,"comment_content":"排队等待条件变量满足后，线程恢复执行是继续wait方法往下执行，还是重新走一遍while判断？<br>也就是打印重新判断，还是继续执行？<br>\t\twhile (true){<br>\t\t\tSystem.out.println(&quot;重新判断&quot;);<br>\t\t\ttry{<br>\t\t\t\twait();<br>\t\t\t\tSystem.out.println(&quot;继续执行&quot;);<br>\t\t\t}catch(Exception e){<br>\t\t\t}<br>\t\t}","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468070,"discussion_content":"继续执行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570624506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133121,"user_name":"码农Kevin亮","can_delete":false,"product_type":"c1","uid":1116630,"ip_address":"","ucode":"D34562461CA0A1","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/d6/5f366427.jpg","comment_is_top":false,"comment_ctime":1568366778,"is_pvip":false,"replies":[{"id":"51018","content":"竞争不激烈用自旋，反之对性能影响很大，所以不能无限自旋","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1568439488,"ip_address":"","comment_id":133121,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568366778","product_id":100023901,"comment_content":"请问老师，在无锁实现时不也常常用到死循环自旋等待么？老师这里说的等待-通知优化场景在无锁算法中好像也不常见哦","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467259,"discussion_content":"竞争不激烈用自旋，反之对性能影响很大，所以不能无限自旋","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568439488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123793,"user_name":"liian2019","can_delete":false,"product_type":"c1","uid":1503741,"ip_address":"","ucode":"22F639944F0EA0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epvjpicXzEv02d9ztRzIWIicbejyFTTtRA5K6oYmdicq9HQgGfRn3DLytTHQ6CHspb0TibqFkMibhBXj2g/132","comment_is_top":false,"comment_ctime":1565762607,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1565762607","product_id":100023901,"comment_content":"用while的话 不还是死循环嘛 只不过还了一个地方 [捂脸]","like_count":0},{"had_liked":false,"id":122761,"user_name":"凌尘","can_delete":false,"product_type":"c1","uid":1487541,"ip_address":"","ucode":"972B8CEF3C9C20","user_header":"https://static001.geekbang.org/account/avatar/00/16/b2/b5/b1b42785.jpg","comment_is_top":false,"comment_ctime":1565514809,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565514809","product_id":100023901,"comment_content":"老师，我有个问题就是你那个一把锁锁多个资源的例子（下面有人提问过，但我还是没有理解），你说用notify可能线程不能被唤醒，这个场景我想不出来。能附上个代码吗，伪代码就行😁","like_count":0},{"had_liked":false,"id":118820,"user_name":"刘垚","can_delete":false,"product_type":"c1","uid":1178869,"ip_address":"","ucode":"308A705AE6EBFF","user_header":"https://static001.geekbang.org/account/avatar/00/11/fc/f5/2634fbb2.jpg","comment_is_top":false,"comment_ctime":1564449818,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564449818","product_id":100023901,"comment_content":"王老师，那个ABCD的例子，是因为锁了多个资源，所以要使用notifyall。<br>如果只锁了一个资源，那使用notify是不是更好呢？","like_count":0},{"had_liked":false,"id":114904,"user_name":"朱培权","can_delete":false,"product_type":"c1","uid":1022348,"ip_address":"","ucode":"0586FB9B37132D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/8c/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1563429869,"is_pvip":true,"replies":[{"id":"53907","content":"一次性讲很多不容易让人消化","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1570710350,"ip_address":"","comment_id":114904,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563429869","product_id":100023901,"comment_content":"notify() 操作工作原理图<br>synchronize （） {<br>    if (条件满足) {<br><br>    }<br>}<br><br>这个 if 是不是应该改为 while","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458877,"discussion_content":"一次性讲很多不容易让人消化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570710350,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114767,"user_name":"朱培权","can_delete":false,"product_type":"c1","uid":1022348,"ip_address":"","ucode":"0586FB9B37132D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/8c/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1563381154,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1563381154","product_id":100023901,"comment_content":"困惑: 对于 一个 synchronized 方法，A 线程可以抢到锁执行， B 线程没有抢到锁被阻塞 ， 当 A 执行完成之后， 如何 唤醒 B 线程执行 ？<br>","like_count":0},{"had_liked":false,"id":113629,"user_name":"赵小洛","can_delete":false,"product_type":"c1","uid":1592232,"ip_address":"","ucode":"A326C12B1A1ABA","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/a8/14b8a860.jpg","comment_is_top":false,"comment_ctime":1563098395,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563098395","product_id":100023901,"comment_content":"当有的 线程 不满足获取锁的 条件时被wait  阻塞了这个 阻塞的队列 是 jvm 在管理吗？<br><br>还有 就是  之前的写法 while 死循环 一直的去判断 条件 是否满足。多线程情况下导致很多线程无序的去竞争资源。等待唤醒机制 就使得 线程竞争资源相对变的有序。","like_count":0},{"had_liked":false,"id":113597,"user_name":"xiyuesmiling","can_delete":false,"product_type":"c1","uid":1221692,"ip_address":"","ucode":"2E5AD30B1470D5","user_header":"https://static001.geekbang.org/account/avatar/00/12/a4/3c/121e7f9f.jpg","comment_is_top":false,"comment_ctime":1563090874,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563090874","product_id":100023901,"comment_content":"但是notify 和 notifyAll的 不应该是每个资源对应的锁里等待的线程吗？","like_count":0},{"had_liked":false,"id":113583,"user_name":"赵小洛","can_delete":false,"product_type":"c1","uid":1592232,"ip_address":"","ucode":"A326C12B1A1ABA","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/a8/14b8a860.jpg","comment_is_top":false,"comment_ctime":1563087343,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563087343","product_id":100023901,"comment_content":"wait方法需要 唤醒.<br><br>sleep方法是阻塞线程 ","like_count":0},{"had_liked":false,"id":112172,"user_name":"以梦为马","can_delete":false,"product_type":"c1","uid":1225455,"ip_address":"","ucode":"9995FC3FD620C6","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/ef/d969bf72.jpg","comment_is_top":false,"comment_ctime":1562677856,"is_pvip":false,"replies":[{"id":"40810","content":"后面管程那章会详细介绍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1562712147,"ip_address":"","comment_id":112172,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562677856","product_id":100023901,"comment_content":"老师您好，有个问题需要请教： notify操作图中有两个队列 一个是获取锁时线程等待的队列，一个是线程被唤醒所在的队列，那如何理解文中提到的”这个等待队列和互斥锁是一对一的关系，每个互斥锁都有自己独立的等待队列","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457608,"discussion_content":"后面管程那章会详细介绍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562712147,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":110069,"user_name":"党","can_delete":false,"product_type":"c1","uid":1071974,"ip_address":"","ucode":"EE531DB3EA124D","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/66/ad35bc68.jpg","comment_is_top":false,"comment_ctime":1562165856,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562165856","product_id":100023901,"comment_content":"wait  能被 notify 唤醒 sleep 只能靠时间唤醒了","like_count":0},{"had_liked":false,"id":108339,"user_name":"八百","can_delete":false,"product_type":"c1","uid":1253530,"ip_address":"","ucode":"79F1F79ADF5A00","user_header":"https://static001.geekbang.org/account/avatar/00/13/20/9a/3b1c65fd.jpg","comment_is_top":false,"comment_ctime":1561722596,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561722596","product_id":100023901,"comment_content":"在wait讠前加个notify方法在等待的线程多的场景下是不是比notifyAll好点？","like_count":0},{"had_liked":false,"id":108110,"user_name":"Xiao","can_delete":false,"product_type":"c1","uid":1179212,"ip_address":"","ucode":"71FFCCEEDE09E1","user_header":"https://static001.geekbang.org/account/avatar/00/11/fe/4c/46eb517a.jpg","comment_is_top":false,"comment_ctime":1561683302,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1561683302","product_id":100023901,"comment_content":"可以看下JVM源码，monitorenter和monitorexit还有wait和notif以及notifyall那部分的源码还是很好理解的！","like_count":0},{"had_liked":false,"id":106362,"user_name":"柠檬C","can_delete":false,"product_type":"c1","uid":1181505,"ip_address":"","ucode":"BC0EE704D952A4","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/41/2d477385.jpg","comment_is_top":false,"comment_ctime":1561279832,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561279832","product_id":100023901,"comment_content":"wait会释放互斥锁，sleep不会释放锁","like_count":0},{"had_liked":false,"id":104694,"user_name":"2102","can_delete":false,"product_type":"c1","uid":1070298,"ip_address":"","ucode":"A67068F2A3157E","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/da/e2e5ddf7.jpg","comment_is_top":false,"comment_ctime":1560819073,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560819073","product_id":100023901,"comment_content":"队列是先进先出的，同步块中notify为何不是通知在等待队列的第一个线程？当随机通知到队列中的第5个线程，是否前4个都会出队列？","like_count":0},{"had_liked":false,"id":103740,"user_name":"mark","can_delete":false,"product_type":"c1","uid":1566124,"ip_address":"","ucode":"59EE6EED0F06DD","user_header":"https://static001.geekbang.org/account/avatar/00/17/e5/ac/6c87d5ee.jpg","comment_is_top":false,"comment_ctime":1560500948,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560500948","product_id":100023901,"comment_content":"wait之后不一定被唤醒,sleep之后还会继续执行。","like_count":0},{"had_liked":false,"id":103674,"user_name":"王藝明","can_delete":false,"product_type":"c1","uid":1546333,"ip_address":"","ucode":"374D68B8D3FAFC","user_header":"https://static001.geekbang.org/account/avatar/00/17/98/5d/8e91b338.jpg","comment_is_top":false,"comment_ctime":1560486365,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560486365","product_id":100023901,"comment_content":"很多都说wait不用捕获异常，但是我看wait和sleep一样也抛出中断异常呀？","like_count":0},{"had_liked":false,"id":103046,"user_name":"狒狒","can_delete":false,"product_type":"c1","uid":1242295,"ip_address":"","ucode":"10A320ECEBF074","user_header":"https://static001.geekbang.org/account/avatar/00/12/f4/b7/5c775af5.jpg","comment_is_top":false,"comment_ctime":1560355160,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560355160","product_id":100023901,"comment_content":"文章开头说apply()函数耗时较短，并发量低时，以死循环的方式等待所带来的消耗还能接受，当apply()耗时较长，或者说并发量比较大的时候,可能循环上千万次才能获取到锁，这里apply()耗时较长这种场景理解的不是很清楚，当apply()耗时较长时循环次数不是会相对少一些吗，举个特别的例子，如果循环中是sleep()，为什么要反而要循环上千万次才能获取到锁呢，希望老师或者热心同学帮助解答一下","like_count":0},{"had_liked":false,"id":101136,"user_name":"魏斌斌","can_delete":false,"product_type":"c1","uid":1142239,"ip_address":"","ucode":"E443EB0504CA37","user_header":"https://static001.geekbang.org/account/avatar/00/11/6d/df/dd536ff5.jpg","comment_is_top":false,"comment_ctime":1559724643,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559724643","product_id":100023901,"comment_content":"大家是来复习并发编程的吗？感觉都很厉害啊。","like_count":0},{"had_liked":false,"id":100777,"user_name":"我是智障","can_delete":false,"product_type":"c1","uid":1016594,"ip_address":"","ucode":"ED9D959423E024","user_header":"https://static001.geekbang.org/account/avatar/00/0f/83/12/4ba82798.jpg","comment_is_top":false,"comment_ctime":1559636999,"is_pvip":false,"replies":[{"id":"36790","content":"参数可以不同","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1560129177,"ip_address":"","comment_id":100777,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559636999","product_id":100023901,"comment_content":"ABCD 那个是怎么回事，在同一个方法 apply() 里面，不同的线程怎么还申请不同的资源呢？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452674,"discussion_content":"参数可以不同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560129177,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98069,"user_name":"王大开","can_delete":false,"product_type":"c1","uid":1302824,"ip_address":"","ucode":"CF82EE8F2F9977","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKU20MSfzNgQt4TjEYTUI2IkLj3wBjFP6FeCicXluM1qf0kXCHgbXH6NeIouFXYzjNlzUxGbcO5kaQ/132","comment_is_top":false,"comment_ctime":1558888935,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558888935","product_id":100023901,"comment_content":"起10000个线程？","like_count":0},{"had_liked":false,"id":97247,"user_name":"Nick","can_delete":false,"product_type":"c1","uid":1507000,"ip_address":"","ucode":"192C47B2CF1426","user_header":"https://static001.geekbang.org/account/avatar/00/16/fe/b8/24a6e0cb.jpg","comment_is_top":false,"comment_ctime":1558619620,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558619620","product_id":100023901,"comment_content":"@wang 你的程序结果没问题吗？","like_count":0},{"had_liked":false,"id":94934,"user_name":"阿辉","can_delete":false,"product_type":"c1","uid":1266788,"ip_address":"","ucode":"A7EF42A10E2599","user_header":"https://static001.geekbang.org/account/avatar/00/13/54/64/8f3d000a.jpg","comment_is_top":false,"comment_ctime":1557925819,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557925819","product_id":100023901,"comment_content":"wang 的那个例子里面应该是notify 而不是notifyAll","like_count":0},{"had_liked":false,"id":94450,"user_name":"倚梦流","can_delete":false,"product_type":"c1","uid":1435045,"ip_address":"","ucode":"7CB442D629534B","user_header":"https://static001.geekbang.org/account/avatar/00/15/e5/a5/fae40ac3.jpg","comment_is_top":false,"comment_ctime":1557815349,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557815349","product_id":100023901,"comment_content":"请问老师，现在的这个apply方法好像还是只能串行化地请求转出转入账号啊。使用单例就是为了保证“中心化的账本管理中心”只有一个，所以这时候不管是锁this，还是锁class对象，效果都是一样的。那有什么方法可以改进，使得能并行请求账号吗？","like_count":0},{"had_liked":false,"id":89101,"user_name":"炎炎","can_delete":false,"product_type":"c1","uid":1143280,"ip_address":"","ucode":"D7F93624E014FC","user_header":"https://static001.geekbang.org/account/avatar/00/11/71/f0/be872719.jpg","comment_is_top":false,"comment_ctime":1556076884,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556076884","product_id":100023901,"comment_content":"老师讲得很棒！","like_count":0},{"had_liked":false,"id":88872,"user_name":"考休","can_delete":false,"product_type":"c1","uid":1053955,"ip_address":"","ucode":"968DFC00D6D0CF","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/03/c0fe1dbf.jpg","comment_is_top":false,"comment_ctime":1556017931,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556017931","product_id":100023901,"comment_content":"线程从阻塞队列中被唤醒，是从头开始重新执行吗？","like_count":0},{"had_liked":false,"id":88523,"user_name":"the geek","can_delete":false,"product_type":"c1","uid":1506723,"ip_address":"","ucode":"71DECBC814A539","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLz3icr3mGs5ib8FbSPQZ2ic3ib90mHkd1btQrmGacZjJxfYXrerIdaTxglKyCicFzLcEAb6deC2cWjE5Q/132","comment_is_top":false,"comment_ctime":1555935523,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555935523","product_id":100023901,"comment_content":"再换个角度，假设用notify()，出现了通知丢失，那么最终的情况一定是，倒数第二个线程运行结束了，并且没有通知到等待队列中的唯一的线程，我想知道，notify()方法会出现最后一个线程无法通知的情况吗？如果不会，那最后一个线程也一定会执行完毕。","like_count":0},{"had_liked":false,"id":88169,"user_name":"彻头撤尾","can_delete":false,"product_type":"c1","uid":1421174,"ip_address":"","ucode":"7B120836359858","user_header":"https://static001.geekbang.org/account/avatar/00/15/af/76/feaffdea.jpg","comment_is_top":false,"comment_ctime":1555866040,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555866040","product_id":100023901,"comment_content":"案例中 有两类锁 第一类 就是Allocator实例(账本管理者) ,保证能同时提供转出账户和转入账户时通知所有转帐的业务窗口来取账本(至于是不是业务窗口需要的账户就不管了--对应的唤醒机会浪费)并且当业务窗口来取账本时发现需要的账本其中任意一本正在被其他业务窗口占用时让该业务窗口回去等通知(wait()),这里的集合则是记录着被拿走的账户账本,用来记录哪些账本是借出状态.<br>另一类锁就是转出账户和转入账户对应的实例了,这个是为了保证在进行转账过程中,避免查询操作查询到错误结果(类似数据库中的脏读).<br>至于有的同学说的,Allocator是单例的不可能出现 线程1持有AB,线程2持有CD的情况,正是由于Allocator是单例的,所以才需要被所有线程共享,单例保证的是所有线程竞争的是同一份资源,但是Allocator实例所对象锁的却是这份资源中的其中两个,其他线程获取其他线程并不冲突,因为只要执行完apply()或者free()单例所对象都会释放,其他线程(业务窗口)可以有机会拿到集合里没有的(还没借出)其他资源(账户账本);<br>个人理解,希望能有点帮助,如有错误,烦请指正.","like_count":0},{"had_liked":false,"id":88144,"user_name":"xuery","can_delete":false,"product_type":"c1","uid":1027584,"ip_address":"","ucode":"F461B61BE06131","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/00/025f37e7.jpg","comment_is_top":false,"comment_ctime":1555858247,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1555858247","product_id":100023901,"comment_content":"文中已经说了，wait的时候，线程会释放锁，对于范式while(条件不满足时){wait();}, 某个线程条件不满足时执行wait()并释放锁，只能等待其他线程notify&#47;notifyAll唤醒，唤醒之后要重新获得锁且条件满足时才会往下执行。<br>sleep则只是休眠一段时间，不释放锁","like_count":0},{"had_liked":false,"id":88034,"user_name":"覃钰栋","can_delete":false,"product_type":"c1","uid":1251835,"ip_address":"","ucode":"19080C463658EF","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/oiboHpgukqib2ASXeU0H7W1ibgRMqyrNE5KaWicicPEDy0ia8YdoneZAtvW0EFIiaqZJp2OS4dnweOgXaJ5EjJicicEqic5A/132","comment_is_top":false,"comment_ctime":1555821055,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555821055","product_id":100023901,"comment_content":"wait()释放CPU,释放锁；sleep只释放CPU，不释放锁","like_count":0},{"had_liked":false,"id":84366,"user_name":"Mr.Panda","can_delete":false,"product_type":"c1","uid":1238864,"ip_address":"","ucode":"655A3013B5E849","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/50/d476ed6c.jpg","comment_is_top":false,"comment_ctime":1554855393,"is_pvip":false,"replies":[{"id":"30456","content":"可以看和08管程那一篇结合着看","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554904125,"ip_address":"","comment_id":84366,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554855393","product_id":100023901,"comment_content":"老师您好，我刚提的问题是不是这样解答就对了：<br>答：两个等待队列是不同的，这里涉及两个等待队列概念。<br>#锁对象的锁标志等待队列<br>进入的线程：1.执行互斥锁导致阻塞的线程， 2.被notify,notifyAll唤醒的线程<br>唤醒条件：锁对象标志已清除，即该锁对象未被其他线程加锁(或其他线程临界区执行完毕自动释放锁)<br>唤醒后执行特征：竞争给锁对象加锁标志，未加锁成功的线程再次回到该等待队列<br>#锁对象等待队列<br>进入的线程： 临界区中主动执行锁对象的wait()方法的线程<br>唤醒条件：其他线程执行了锁对象的notify,notifyAll方法<br>唤醒后执行特征：被唤醒的线程会进入锁对象的锁标志等待队列","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446334,"discussion_content":"可以看和08管程那一篇结合着看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554904125,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84349,"user_name":"Mr.Panda","can_delete":false,"product_type":"c1","uid":1238864,"ip_address":"","ucode":"655A3013B5E849","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/50/d476ed6c.jpg","comment_is_top":false,"comment_ctime":1554853689,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554853689","product_id":100023901,"comment_content":"老师您好，请指导几个问题：<br>1. 两个等待队列有区别吗？<br>1.1上文提到的左边等待队列由于互斥锁synchronized导致线程阻塞所聚集的概念，需要临界区执行完毕，自动释放锁，该队列中的线程才会全部唤醒去竞争给锁对象加锁。<br>1.2 上文提到的右边等待队列是由于获取锁的执行线程，条件不满足时主动调用wait释放互斥锁且自身进入阻塞所聚集的概念，需要调用对应锁对象的notify,notifyAll才会唤醒该等待队列中的线程去竞争锁。<br>也就是说若没调用notify,notifyAll 那么这个阻塞队列中的线程永远不会被唤醒？<br>","like_count":0},{"had_liked":false,"id":82072,"user_name":"虎爷","can_delete":false,"product_type":"c1","uid":1024907,"ip_address":"","ucode":"42E8339F183055","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a3/8b/e7389cf5.jpg","comment_is_top":false,"comment_ctime":1554113946,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1554113946","product_id":100023901,"comment_content":"wait是进入临界区等待，也就是this object&#39;s monitor.<br>sleep是线程的方法，它的功能，等一会，sleep方法不会导致自己（thread）丢掉互斥锁的拥有权。","like_count":0},{"had_liked":false,"id":80638,"user_name":"timgise","can_delete":false,"product_type":"c1","uid":1083979,"ip_address":"","ucode":"0F4567495A471F","user_header":"https://static001.geekbang.org/account/avatar/00/10/8a/4b/9863a07b.jpg","comment_is_top":false,"comment_ctime":1553691986,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553691986","product_id":100023901,"comment_content":"&#47;&#47;sleep<br>synchronized(LOCK) {<br>    TimeUnit.SECONDS.sleep(3); &#47;&#47;LOCK持有锁<br>}<br>&#47;&#47;wait<br>synchronized(LOCK){<br>    LOCK.wait(); &#47;&#47;LOCK已不持有锁<br>}<br><br><br>","like_count":0},{"had_liked":false,"id":79313,"user_name":"苍茫大地","can_delete":false,"product_type":"c1","uid":1010515,"ip_address":"","ucode":"7EA9DF22931ABB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/53/a102d6a5.jpg","comment_is_top":false,"comment_ctime":1553433739,"is_pvip":false,"replies":[{"id":"28925","content":"没权利争取，完全被动的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553436089,"ip_address":"","comment_id":79313,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553433739","product_id":100023901,"comment_content":"记住两个队列，并且右边的队列在被唤醒后会移到左边的队列，在讲管程的时候我们也要把这个具体的弄懂。不过，在notifyall的时候，线程是如何争取自己被唤醒的呢，这里面有没有什么机制","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444446,"discussion_content":"没权利争取，完全被动的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553436089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78321,"user_name":"antz","can_delete":false,"product_type":"c1","uid":1005589,"ip_address":"","ucode":"BDFDED6D7F0BD2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/58/15/56f4e62a.jpg","comment_is_top":false,"comment_ctime":1553130427,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553130427","product_id":100023901,"comment_content":"@郑晨Cc：针对你的疑惑，我觉得可以参考下每个对象都有个monitorobject来理解，它里面有waitset队列，执行wait后，线程就会放进去，notify后，会去重新争抢锁，抢到锁后monitorobject对象里有currentthread字段存储当前线程id，然后还要明白一个事，线程互斥应该是对同一个锁定资源争抢，所以肯定是同一个对象，就是同一个monitorobject","like_count":0},{"had_liked":false,"id":77836,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1553006394,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1553006394","product_id":100023901,"comment_content":"是不是可以从相同和不同点来猜测一下设计目标？sleep只是让当前线程让出当前CPU资源，并且指定时间内不参与CPU资源的抢夺，雨露均沾，让其他线程也有机会得到执行。而wait是等待-通知机制中的一个不可或缺的环节，只是wait的一个功能表现是当前线程让出CPU，所以来一直拿来和sleep做对比。","like_count":0},{"had_liked":false,"id":77584,"user_name":"你只是看起来很努力","can_delete":false,"product_type":"c1","uid":1449173,"ip_address":"","ucode":"F9340A560D347C","user_header":"https://static001.geekbang.org/account/avatar/00/16/1c/d5/248a9c38.jpg","comment_is_top":false,"comment_ctime":1552965601,"is_pvip":false,"replies":[{"id":"28335","content":"没问题<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552969575,"ip_address":"","comment_id":77584,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552965601","product_id":100023901,"comment_content":"线程执行wait()方法后，会释放其占有的所有资源，而且不会自动唤醒，必须通过notify()或notifyAll()方法才能被唤醒再次进入就绪队列。<br>执行sleep()方法，会使线程让出cpu的执行权，给其它线程执行的机会，不管其它线程的优先级高低，但不释放锁。<br>老师，那么两个线程访问一组共享资源的时候，在同步代码块里执行sleep()是没有意义的，因为你只是让出了cpu，没有释放锁，另一个线程还是不能执行，这么理解有问题吗?","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443787,"discussion_content":"没问题\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552969575,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76790,"user_name":"再见，孙悟空","can_delete":false,"product_type":"c1","uid":1116757,"ip_address":"","ucode":"955C94D694D929","user_header":"https://static001.geekbang.org/account/avatar/00/11/0a/55/a1c8954d.jpg","comment_is_top":false,"comment_ctime":1552708558,"is_pvip":false,"replies":[{"id":"28024","content":"已经有同学在评论区给了，你可以参考一下","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552729772,"ip_address":"","comment_id":76790,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552708558","product_id":100023901,"comment_content":"强烈要求老师给个github链接，能有完整的代码参考，想本地自己运行一下。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443447,"discussion_content":"已经有同学在评论区给了，你可以参考一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552729772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76698,"user_name":"残风","can_delete":false,"product_type":"c1","uid":1182951,"ip_address":"","ucode":"E563FB9516CB9A","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/e7/863f5eef.jpg","comment_is_top":false,"comment_ctime":1552683720,"is_pvip":false,"replies":[{"id":"27980","content":"这个在管程那一章详细介绍<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552702424,"ip_address":"","comment_id":76698,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552683720","product_id":100023901,"comment_content":"左边的是enter~set右边的才是wait~set，enter~set管理的是等待当前对象锁资源的线程，而wait~set管理的是调用了wait方法的线程","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443412,"discussion_content":"这个在管程那一章详细介绍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552702424,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76365,"user_name":"道","can_delete":false,"product_type":"c1","uid":1324160,"ip_address":"","ucode":"851A0AD751D317","user_header":"https://static001.geekbang.org/account/avatar/00/14/34/80/30e9ae41.jpg","comment_is_top":false,"comment_ctime":1552578663,"is_pvip":false,"replies":[{"id":"27886","content":"可能这个几率不行，必须是一定能唤醒。要不3就死在那里了<br><br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552623758,"ip_address":"","comment_id":76365,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552578663","product_id":100023901,"comment_content":"notify有风险，notifyall就能保证没有风险吗。结果是都唤醒了一个线程。该例子中如果用notifyall也有可能唤醒线程4<br><br>既然锁的是this，线程2是持有cd资源的，那么线程2释放资源时调notify是可能唤醒线程3的。<br>限于水平，感觉这一段没明白","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443275,"discussion_content":"可能这个几率不行，必须是一定能唤醒。要不3就死在那里了\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552623758,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75950,"user_name":"李皮皮皮皮皮","can_delete":false,"product_type":"c1","uid":1200281,"ip_address":"","ucode":"3BF1DEE4A12359","user_header":"https://static001.geekbang.org/account/avatar/00/12/50/99/44378317.jpg","comment_is_top":false,"comment_ctime":1552496609,"is_pvip":false,"replies":[{"id":"27680","content":"是这样<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552523858,"ip_address":"","comment_id":75950,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552496609","product_id":100023901,"comment_content":"那就是说notify和notifyAll不会阻塞咯，就是通知完其他线程，该线程继续执行。是这样没错吧😄","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443100,"discussion_content":"是这样\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552523858,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75644,"user_name":"Aiome","can_delete":false,"product_type":"c1","uid":1306394,"ip_address":"","ucode":"5D3A810C0FF56B","user_header":"","comment_is_top":false,"comment_ctime":1552443044,"is_pvip":false,"replies":[{"id":"27640","content":"notify之后，从b到a，什么时候唤醒，要看sync锁什么时候释放<br>这个while和上一章没关系<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552479639,"ip_address":"","comment_id":75644,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552443044","product_id":100023901,"comment_content":"老师，有点问题望解答<br>1.wait notify notifyall  都是对sync 锁的等待队列操作这个对接叫A，wait操作会把线程放到wait等待队列B。<br>那么当B队列的线程什么时候会被唤醒呢？当B队列的线程数被唤醒重新获取sync锁失败了，那这个线程回到A队列还是B队列呢？<br><br>2.这种等待通知的模式，是不是为了解决上一章while循环资源的情况，但是这个模式只是把while方到了管理员的代码里，是我对while（）｛wait（）｝这个写法有误解吗？<br><br>水平低，希望老师能给解答，谢谢🙏","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442972,"discussion_content":"notify之后，从b到a，什么时候唤醒，要看sync锁什么时候释放\n这个while和上一章没关系\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552479639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75461,"user_name":"独立自主","can_delete":false,"product_type":"c1","uid":1371039,"ip_address":"","ucode":"11213FDC994385","user_header":"https://static001.geekbang.org/account/avatar/00/14/eb/9f/125ed81c.jpg","comment_is_top":false,"comment_ctime":1552400867,"is_pvip":false,"replies":[{"id":"27629","content":"还是没看明白😂<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552478216,"ip_address":"","comment_id":75461,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1552400867","product_id":100023901,"comment_content":"老师，一个线程在访问临界区资源时，拿到资源A却那不到资源B，可能资源B在临界区根本不存在，这就在调用wait（）方法的时候，放弃互斥锁，把线程放到阻塞队列中，然后当某个线程调用notify（）方法时，这个线程始终都会在阻塞队列中。这种情况该怎么处理呢？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442901,"discussion_content":"还是没看明白😂\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552478216,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1309759,"avatar":"https://static001.geekbang.org/account/avatar/00/13/fc/3f/7e95156a.jpg","nickname":"啊勇","note":"","ucode":"CB403DD04F920A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":267,"discussion_content":"修改成notifyAll()方法不就可以了吗？因为notify()只会随机通知一个，你的这个线程有可能通知不到，因为是随机通知的其中一个。修改成notifyAll()方法，就会把阻塞队列里面所有阻塞的线程移到竞争锁的队列里去。个人理解！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561373824,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1361746,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c7/52/c5adf218.jpg","nickname":"喜欢地球的阿培同学","note":"","ucode":"5F97037585F857","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1309759,"avatar":"https://static001.geekbang.org/account/avatar/00/13/fc/3f/7e95156a.jpg","nickname":"啊勇","note":"","ucode":"CB403DD04F920A","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":91480,"discussion_content":"修改成notifyAll()方法，就会把阻塞队列里面所有阻塞的线程移到竞争锁的队列里去。 这句话醍醐灌顶！！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576835888,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":267,"ip_address":""},"score":91480,"extra":""}]}]},{"had_liked":false,"id":75455,"user_name":"独立自主","can_delete":false,"product_type":"c1","uid":1371039,"ip_address":"","ucode":"11213FDC994385","user_header":"https://static001.geekbang.org/account/avatar/00/14/eb/9f/125ed81c.jpg","comment_is_top":false,"comment_ctime":1552400195,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552400195","product_id":100023901,"comment_content":"老师，当一个线程访问临界区的时候，查询资源的时候，只拿到转出账号却拿不到转入账号（资源）。然后这个线程一直在阻塞队列。这种情况该如何处理呢？","like_count":0},{"had_liked":false,"id":75432,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1552397058,"is_pvip":false,"replies":[{"id":"27596","content":"是的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552452972,"ip_address":"","comment_id":75432,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552397058","product_id":100023901,"comment_content":"等待队列 代码里看不到 那就是在JVM里面了吧？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442889,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552452972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75327,"user_name":"李","can_delete":false,"product_type":"c1","uid":1119312,"ip_address":"","ucode":"5C0FAA211F2E26","user_header":"https://static001.geekbang.org/account/avatar/00/11/14/50/c23cf47d.jpg","comment_is_top":false,"comment_ctime":1552379296,"is_pvip":true,"replies":[{"id":"27452","content":"只要有一个包含，就是曾经被分配过，也就是条件不满足<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552389885,"ip_address":"","comment_id":75327,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552379296","product_id":100023901,"comment_content":"代码里，两个包含是不是写反了？？条件不满足才等待，那应该是不包含吧","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442864,"discussion_content":"只要有一个包含，就是曾经被分配过，也就是条件不满足\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552389885,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75275,"user_name":"何方妖孽","can_delete":false,"product_type":"c1","uid":1445608,"ip_address":"","ucode":"98B74EE791206B","user_header":"https://static001.geekbang.org/account/avatar/00/16/0e/e8/5d2c3e08.jpg","comment_is_top":false,"comment_ctime":1552372206,"is_pvip":false,"replies":[{"id":"27470","content":"应该是对的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552393906,"ip_address":"","comment_id":75275,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552372206","product_id":100023901,"comment_content":"例子里的wait()上边的条件不对吧？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442844,"discussion_content":"应该是对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552393906,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75259,"user_name":"墨名次","can_delete":false,"product_type":"c1","uid":1330267,"ip_address":"","ucode":"926EDC57291C09","user_header":"https://static001.geekbang.org/account/avatar/00/14/4c/5b/5499d6e6.jpg","comment_is_top":false,"comment_ctime":1552371262,"is_pvip":false,"replies":[{"id":"27475","content":"经常被大家忽视的是，锁会不会释放。原来大家都这么忽悠用户😂<br><br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552396497,"ip_address":"","comment_id":75259,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552371262","product_id":100023901,"comment_content":"wait()是等待，sleep()是休眠，等待在不确定的某个时间点完成，休眠必须在设定好的时间点完成。wait()跟老师讲的就医流程相似，sleep()则跟我们相似，要定闹钟，每天早上准时8点起床上班。它们的应用场景也不一样，wait()用来解决等待执行任务，提高效率；sleep()用来解决延迟执行任务，wait()适用于老师所讲的并发编程，而sleep()在UI编程中比较常用，用来忽悠用户，比如：扫描一个盘里面所有文件的进度条(1%,2%...90%,100%)或“请稍后...”之类的提示。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442840,"discussion_content":"经常被大家忽视的是，锁会不会释放。原来大家都这么忽悠用户😂\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552396497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75220,"user_name":"李皮皮皮皮皮","can_delete":false,"product_type":"c1","uid":1200281,"ip_address":"","ucode":"3BF1DEE4A12359","user_header":"https://static001.geekbang.org/account/avatar/00/12/50/99/44378317.jpg","comment_is_top":false,"comment_ctime":1552366389,"is_pvip":false,"replies":[{"id":"27465","content":"不会，同步代码块执行完才会释放<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552393161,"ip_address":"","comment_id":75220,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552366389","product_id":100023901,"comment_content":"notify和notifyAll是在同步方法或同步代码块中被调用的，那么调用这两个方法应该会释放锁吧？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442826,"discussion_content":"不会，同步代码块执行完才会释放\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552393161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75214,"user_name":"0bug","can_delete":false,"product_type":"c1","uid":1050335,"ip_address":"","ucode":"CADCC882F31784","user_header":"https://static001.geekbang.org/account/avatar/00/10/06/df/60126ff3.jpg","comment_is_top":false,"comment_ctime":1552365452,"is_pvip":false,"replies":[{"id":"27459","content":"不是先进先出，数据结构啥样的我也没深究过<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552390662,"ip_address":"","comment_id":75214,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552365452","product_id":100023901,"comment_content":"老师您好，有个问题请教一下，文章中说的，调用wait()后，线程会进入等待队列，这个等待队列的数据结构是什么样的？应该不是标准的先进先出队列吧？ ","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442824,"discussion_content":"不是先进先出，数据结构啥样的我也没深究过\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552390662,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75086,"user_name":"李广","can_delete":false,"product_type":"c1","uid":1336612,"ip_address":"","ucode":"AEBFC69D7B8026","user_header":"https://static001.geekbang.org/account/avatar/00/14/65/24/b975a485.jpg","comment_is_top":false,"comment_ctime":1552354742,"is_pvip":false,"replies":[{"id":"27458","content":"多个wait共享一个，synch锁是另外一个。这个会在管程里面重新讲<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552390399,"ip_address":"","comment_id":75086,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552354742","product_id":100023901,"comment_content":"老师，请问synchronized和里面的wait共用同一个等待队列吗，一个synchronized里有多个wait他们也共用同一个等待队列吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442795,"discussion_content":"多个wait共享一个，synch锁是另外一个。这个会在管程里面重新讲\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552390399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75084,"user_name":"yang","can_delete":false,"product_type":"c1","uid":1226705,"ip_address":"","ucode":"9FE1D02DF0F103","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJupkAwlMPemsyBhOT2BWJPnyicAqQhH731C7uV5fXjz9DicxO0eySia1JLqeMXAkQlFZZ41uXsw1I7g/132","comment_is_top":false,"comment_ctime":1552354734,"is_pvip":false,"replies":[{"id":"27457","content":"他们锁的都是this这个对象，所以等待队列是一个<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552390273,"ip_address":"","comment_id":75084,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552354734","product_id":100023901,"comment_content":"线程3和4在同一个等待队列？他们申请的资源都不一样，应该也不是一个锁吧","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442794,"discussion_content":"他们锁的都是this这个对象，所以等待队列是一个\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552390273,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75048,"user_name":"0bug","can_delete":false,"product_type":"c1","uid":1050335,"ip_address":"","ucode":"CADCC882F31784","user_header":"https://static001.geekbang.org/account/avatar/00/10/06/df/60126ff3.jpg","comment_is_top":false,"comment_ctime":1552352343,"is_pvip":false,"replies":[{"id":"27393","content":"可以去掉了<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552362593,"ip_address":"","comment_id":75048,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552352343","product_id":100023901,"comment_content":"&#47;&#47; 一次性申请转出账户和转入账户，直到成功<br>while(!actr.apply(this, target))<br>  ；<br>这段代码的while可以去掉了吧？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442788,"discussion_content":"可以去掉了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552362593,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75043,"user_name":"张先生丶","can_delete":false,"product_type":"c1","uid":1138723,"ip_address":"","ucode":"D8AE94C76318D7","user_header":"https://static001.geekbang.org/account/avatar/00/11/60/23/efd87e29.jpg","comment_is_top":false,"comment_ctime":1552352120,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552352120","product_id":100023901,"comment_content":"1、wait释放持有的锁，sleep不会<br>2、sleep设置挂起时间，wait如果不调用notify或者notifyall，一直挂起<br>3、wait是Object方法，sleep是Thread方法","like_count":0},{"had_liked":false,"id":75040,"user_name":"哲民","can_delete":false,"product_type":"c1","uid":1031059,"ip_address":"","ucode":"CADC8EAB0B641A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKfkFogCZmVEmm2qRQR6j48TIzicEd4daaRcU4YgibORiaBSYaEPnW8Ke4KibpsU0MsaISZ6UAM1uTbmA/132","comment_is_top":false,"comment_ctime":1552351939,"is_pvip":false,"replies":[{"id":"27461","content":"貌似没听说有分布式的管程","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552392821,"ip_address":"","comment_id":75040,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552351939","product_id":100023901,"comment_content":"分布式系统中对应wait和notify有哪些方式呢？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442786,"discussion_content":"貌似没听说有分布式的管程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552392821,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75019,"user_name":"往事随风，顺其自然","can_delete":false,"product_type":"c1","uid":1235692,"ip_address":"","ucode":"F266EC6B143E38","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/ec/779c1a78.jpg","comment_is_top":false,"comment_ctime":1552351237,"is_pvip":false,"replies":[{"id":"27454","content":"只要包含一个就说明被分配过","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552390009,"ip_address":"","comment_id":75019,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552351237","product_id":100023901,"comment_content":"while 条件中不是与操作？怎么是或运算","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442779,"discussion_content":"只要包含一个就说明被分配过","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552390009,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74985,"user_name":"乐溪溪520","can_delete":false,"product_type":"c1","uid":1168975,"ip_address":"","ucode":"99FBCEC0083E06","user_header":"https://static001.geekbang.org/account/avatar/00/11/d6/4f/008f9d6a.jpg","comment_is_top":false,"comment_ctime":1552348096,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552348096","product_id":100023901,"comment_content":"wait让线程挂起的时候，会释放自己持有的锁资源，而sleep还会继续持有锁资源。","like_count":0}]}