{"id":466896,"title":"23 | 弹窗：如何设计一个弹窗组件？","content":"<p>你好，我是大圣。</p><p>上一讲我们剖析了表单组件的实现模式，相信学完之后，你已经掌握了表单类型组件设计的细节，表单组件的主要功能就是在页面上获取用户的输入。</p><p>不过，用户在交互完成之后，还需要知道交互的结果状态，这就需要我们提供专门用来反馈操作状态的组件。这类组件根据反馈的级别不同，也分成了很多种类型，比如全屏灰色遮罩、居中显示的对话框Dialog，在交互按钮侧面显示、用来做简单提示的tooltip，以及右上角显示信息的通知组件Notification等，这类组件的交互体验你都可以在<a href=\"https://e3.shengxinjing.cn/#\">Element3官网</a>感受。</p><p>今天的代码也会用Element3的Dialog组件和Notification进行举例，在动手写代码实现之前，我们先从这个弹窗组件的需求开始说起。</p><h2>组件需求分析</h2><p>我们先来设计一下要做的组件，通过这部分内容，还可以帮你继续加深一下对单元测试Jest框架的使用熟练度。我建议你在设计一个新的组件的时候，也试试采用这种方式，先把组件所有的功能都罗列出来，分析清楚需求再具体实现，这样能够让你后面的工作事半功倍。</p><p>首先无论是对话框Dialog，还是消息弹窗Notification，它们都由一个弹窗的标题，以及具体的弹窗的内容组成的。我们希望弹窗有一个关闭的按钮，点击之后就可以关闭弹窗，弹窗关闭之后还可以设置回调函数。</p><!-- [[[read_end]]] --><p>下面这段代码演示了dialog组件的使用方法，通过title显示标题，通过slot显示文本内容和交互按钮，而通过v-model就能控制显示状态。</p><pre><code class=\"language-typescript\">&lt;el-dialog\n  title=\"提示\"\n  :visible.sync=\"dialogVisible\"\n  width=\"30%\"\n  v-model:visible=\"dialogVisible\"\n&gt;\n  &lt;span&gt;这是一段信息&lt;/span&gt;\n  &lt;template #footer&gt;\n    &lt;span class=\"dialog-footer\"&gt;\n      &lt;el-button @click=\"dialogVisible = false\"&gt;取 消&lt;/el-button&gt;\n      &lt;el-button type=\"primary\" @click=\"dialogVisible = false\"&gt;确 定&lt;/el-button&gt;\n    &lt;/span&gt;\n  &lt;/template&gt;\n&lt;/el-dialog&gt;\n</code></pre><p>这类组件实现起来和表单类组件区别不是特别大，我们首先需要做的就是<strong>控制好组件的数据传递</strong>，并且使用Teleport渲染到页面顶层的body标签。</p><p>像Dialog和Notification类的组件，我们只是单纯想显示一个提示或者报错信息，过几秒就删除，如果在每个组件内部都需要写一个&lt;Dialog v-if&gt;，并且使用v-if绑定变量的方式控制显示就会显得很冗余。</p><p>所以，这里就要用到一种调用Vue组件的新方式：我们可以使用JavaScript的API动态地创建和渲染Vue的组件。具体如何实现呢？我们以Notification组件为例一起看一下。</p><p>下面的代码是Element3的Notification演示代码。组件内部只有两个button，我们不需要书写额外的组件标签，只需要在&lt;script setup&gt;中使用Notification.success\b函数，就会在页面动态创建Notification组件，并且显示在页面右上角。</p><pre><code class=\"language-xml\">&lt;template&gt;\n  &lt;el-button plain @click=\"open1\"&gt; 成功 &lt;/el-button&gt;\n  &lt;el-button plain @click=\"open2\"&gt; 警告 &lt;/el-button&gt;\n&lt;/template&gt;\n&lt;script setup&gt;\n  import { Notification } from 'element3'\n\n  function open1() {\n    Notification.success({\n      title: '成功',\n      message: '这是一条成功的提示消息',\n      type: 'success'\n    })\n  }\n  function open2() {\n    Notification.warning({\n      title: '警告',\n      message: '这是一条警告的提示消息',\n      type: 'warning'\n    })\n  }\n\n\n&lt;/script&gt;\n</code></pre><h2>弹窗组件实现</h2><p>分析完需求之后，我们借助单元测试的方法来实现这个弹窗组件（单元测试的内容如果记不清了，你可以回顾<a href=\"https://time.geekbang.org/column/article/464098\">第20讲</a>）。</p><p>我们依次来分析Notification的代码，相比于写Demo逻辑的代码，这次我们体验一下实际的组件和演示组件的区别。我们来到element3下面的src/components/Notification/notifucation.vue代码中，下面的代码构成了组件的主体框架，我们不去直接写组件的逻辑，而是先从测试代码来梳理组件的功能。</p><pre><code class=\"language-xml\">&lt;template&gt;\n  &lt;div class=\"el-nofication\"&gt;\n    &lt;slot /&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n\n&lt;/script&gt;\n\n&lt;style lang=\"scss\"&gt;\n@import '../styles/mixin';\n\n&lt;/style&gt;\n</code></pre><p>结合下面的代码可以看到，我们进入到了内部文件Notification.spec.js中。下面的测试代码中，我们期待Notification组件能够渲染el-notification\b样式类，并且内部能够通过属性title渲染标题；message属性用来渲染消息主体；position用来渲染组件的位置，让我们的弹窗组件可以显示在浏览器四个角。</p><pre><code class=\"language-xml\">import Notification from \"./Notification.vue\"\nimport { mount } from \"@vue/test-utils\"\n\ndescribe(\"Notification\", () =&gt; { \n  \n  it('渲染标题title', () =&gt; {\n    const title = 'this is a title'\n    const wrapper = mount(Notification, {\n      props: {\n        title\n      }\n    })\n    expect(wrapper.get('.el-notification__title').text()).toContain(title)\n  })\n\n  it('信息message渲染', () =&gt; {\n    const message = 'this is a message'\n    const wrapper = mount(Notification, {\n      props: {\n        message\n      }\n    })\n    expect(wrapper.get('.el-notification__content').text()).toContain(message)\n  })\n\n  it('位置渲染', () =&gt; {\n    const position = 'bottom-right'\n    const wrapper = mount(Notification, {\n      props: {\n        position\n      }\n    })\n    expect(wrapper.find('.el-notification').classes()).toContain('right')\n    expect(wrapper.vm.verticalProperty).toBe('bottom')\n    expect(wrapper.find('.el-notification').element.style.bottom).toBe('0px')\n  })\n\n  it('位置偏移', () =&gt; {\n    const verticalOffset = 50\n    const wrapper = mount(Notification, {\n      props: {\n        verticalOffset\n      }\n    })\n    expect(wrapper.vm.verticalProperty).toBe('top')\n    expect(wrapper.find('.el-notification').element.style.top).toBe(\n      `${verticalOffset}px`\n    )\n  })\n\n})\n\n</code></pre><p>这时候毫无疑问，测试窗口会报错。我们需要进入notificatin.vue中实现代码逻辑。<br>\n下面的代码中，我们在代码中接收title、message和position，使用notification__title和notification__message渲染标题和消息。</p><pre><code class=\"language-xml\">&lt;template&gt;\n  &lt;div class=\"el-notification\" :style=\"positionStyle\" @click=\"onClickHandler\"&gt;\n    &lt;div class=\"el-notification__title\"&gt;\n      {{ title }}\n    &lt;/div&gt;\n\n    &lt;div class=\"el-notification__message\"&gt;\n      {{ message }}\n    &lt;/div&gt;\n\n    &lt;button\n      v-if=\"showClose\"\n      class=\"el-notification__close-button\"\n      @click=\"onCloseHandler\"\n    &gt;&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script setup&gt;\nconst instance = getCurrentInstance()\nconst visible = ref(true)\nconst verticalOffsetVal = ref(props.verticalOffset)\n\nconst typeClass = computed(() =&gt; {\n  return props.type ? `el-icon-${props.type}` : ''\n})\n\nconst horizontalClass = computed(() =&gt; {\n  return props.position.endsWith('right') ? 'right' : 'left'\n})\n\nconst verticalProperty = computed(() =&gt; {\n  return props.position.startsWith('top') ? 'top' : 'bottom'\n})\n\nconst positionStyle = computed(() =&gt; {\n  return {\n    [verticalProperty.value]: `${verticalOffsetVal.value}px`\n  }\n})\n&lt;/script&gt;\n\n&lt;style lang=\"scss\"&gt;\n.el-notification {\n  position: fixed;\n  right: 10px;\n  top: 50px;\n  width: 330px;\n  padding: 14px 26px 14px 13px;\n  border-radius: 8px;\n  border: 1px solid #ebeef5;\n  background-color: #fff;\n  box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);\n  overflow: hidden;\n}\n&lt;/style&gt;\n</code></pre><p>然后我们新增测试代码，设置弹窗是否显示关闭按钮以及关闭弹窗之后的回调函数。我们希望点击关闭按钮之后，就能够正确执行传入的onClose函数。</p><pre><code class=\"language-javascript\">it('set the showClose ', () =&gt; {\n    const showClose = true\n    const wrapper = mount(Notification, {\n      props: {\n        showClose\n      }\n    })\n    expect(wrapper.find('.el-notification__closeBtn').exists()).toBe(true)\n    expect(wrapper.find('.el-icon-close').exists()).toBe(true)\n  })\n\n  it('点击关闭按钮', async () =&gt; {\n    const showClose = true\n    const wrapper = mount(Notification, {\n      props: {\n        showClose\n      }\n    })\n    const closeBtn = wrapper.get('.el-notification__closeBtn')\n    await closeBtn.trigger('click')\n    expect(wrapper.get('.el-notification').isVisible()).toBe(false)\n  })\n\n  it('持续时间之后自动管理', async () =&gt; {\n    jest.useFakeTimers()\n\n    const wrapper = mount(Notification, {\n      props: {\n        duration: 1000\n      }\n    })\n    jest.runTimersToTime(1000)\n    await flushPromises()\n    expect(wrapper.get('.el-notification').isVisible()).toBe(false)\n     })\n</code></pre><p>到这里，Notification组件测试的主体逻辑就实现完毕了，我们拥有了一个能够显示在右上角的组件，具体效果你可以参考后面这张截图。</p><p><img src=\"https://static001.geekbang.org/resource/image/aa/04/aa1506d30d0b4d641aa7175c2a4a5004.jpg?wh=1920x972\" alt=\"图片\"></p><p>进行到这里，距离完成整体设计我们还差两个步骤。</p><p>首先，弹窗类的组件都需要直接渲染在body标签下面，弹窗类组件由于布局都是绝对定位，如果在组件内部渲染，组件的css属性（比如Transform）会影响弹窗组件的渲染样式，为了避免这种问题重复出现，弹窗组件Dialog、Notification都需要渲染在body内部。</p><p>Dialog组件可以直接使用Vue3自带的Teleport，很方便地渲染到body之上。在下面的代码中, 我们用teleport组件把dialog组件包裹之后，通过to属性把dialog渲染到body标签内部。</p><pre><code class=\"language-javascript\">  &lt;teleport\n    :disabled=\"!appendToBody\"\n    to=\"body\"\n  &gt;\n    &lt;div class=\"el-dialog\"&gt;\n      &lt;div class=\"el-dialog__content\"&gt;\n        &lt;slot /&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/teleport&gt;\n</code></pre><p>这时我们使用浏览器调试窗口，就可以看到Dialog标签已经从当前组件移动到了body标签内部，如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/d9/61/d9199199590871f811309f4c78963761.jpg?wh=1920x902\" alt=\"图片\"></p><p>但是Notification组件并不会在当前组件以组件的形式直接调用，我们需要像Element3一样，能够使用js函数动态创建Notification组件，<strong>给Vue的组件提供Javascript的动态渲染方法，这是弹窗类组件的特殊需求</strong>。</p><h2>组件渲染优化</h2><p>我们先把测试代码写好，具体如下。代码中分别测试函数创建组件，以及不同配置和样式的通知组件。</p><pre><code class=\"language-xml\">it('函数会创建组件', () =&gt; {\n  const instanceProxy = Notification('foo')\n  expect(instanceProxy.close).toBeTruthy()\n})\n\nit('默认配置 ', () =&gt; {\n  const instanceProxy = Notification('foo')\n\n  expect(instanceProxy.$props.position).toBe('top-right')\n  expect(instanceProxy.$props.message).toBe('foo')\n  expect(instanceProxy.$props.duration).toBe(4500)\n  expect(instanceProxy.$props.verticalOffset).toBe(16)\n})\ntest('字符串信息', () =&gt; {\n  const instanceProxy = Notification.info('foo')\n\n  expect(instanceProxy.$props.type).toBe('info')\n  expect(instanceProxy.$props.message).toBe('foo')\n})\ntest('成功信息', () =&gt; {\n  const instanceProxy = Notification.success('foo')\n\n  expect(instanceProxy.$props.type).toBe('success')\n  expect(instanceProxy.$props.message).toBe('foo')\n})\n</code></pre><p>现在测试写完后还是会报错，因为现在Notification函数还没有定义，我们要能通过Notification函数动态地创建Vue的组件，而不是在template中使用组件。</p><p>在<a href=\"https://time.geekbang.org/column/article/444283\">JSX那一讲</a>中我们讲过，template的本质就是使用h函数创建虚拟Dom，如果我们自己想动态创建组件时，使用相同的方式即可。</p><p>在下面的代码中我们使用Notification函数去执行createComponent函数，使用h函数动态创建组件，实现了动态组件的创建。</p><pre><code class=\"language-javascript\">function createComponent(Component, props, children) {\n  const vnode = h(Component, { ...props, ref: MOUNT_COMPONENT_REF }, children)\n  const container = document.createElement('div')\n  vnode[COMPONENT_CONTAINER_SYMBOL] = container\n  render(vnode, container)\n  return vnode.component\n}\nexport function Notification(options) {\n  return createNotification(mergeProps(options))\n}\n\nfunction createNotification(options) {\n  const instance = createNotificationByOpts(options)\n  setZIndex(instance)\n  addToBody(instance)\n  return instance.proxy\n}\n</code></pre><p>创建组件后，由于Notification组件同时可能会出现多个弹窗，所以我们需要使用数组来管理通知组件的每一个实例，每一个弹窗的实例都存储在数组中进行管理。</p><p>下面的代码里，我演示了怎样用数组管理弹窗的实例。Notification函数最终会暴露给用户使用，在Notification函数内部我们通过createComponent函数创建渲染的容器，然后通过createNotification创建弹窗组件的实例，并且维护在instanceList中。</p><pre><code class=\"language-javascript\">const instanceList = []\nfunction createNotification(options) {\n  ...\n  addInstance(instance)\n  return instance.proxy\n}  \nfunction addInstance(instance) {\n  instanceList.push(instance)\n}\n;['success', 'warning', 'info', 'error'].forEach((type) =&gt; {\n  Notification[type] = (options) =&gt; {\n    if (typeof options === 'string' || isVNode(options)) {\n      options = {\n        message: options\n      }\n    }\n    options.type = type\n    return Notification(options)\n  }\n})\n\n// 有了instanceList， 可以很方便的关闭所有信息弹窗\nNotification.closeAll = () =&gt; {\n  instanceList.forEach((instance) =&gt; {\n    instance.proxy.close()\n    removeInstance(instance)\n  })\n}\n</code></pre><p>最后，我带你简单回顾下我们都做了什么。在正式动手实现弹窗组件前，我们分析了弹窗类组件的风格。弹窗类组件主要负责用户交互的反馈。根据显示的级别不同，它可以划分成不同的种类：既有覆盖全屏的弹窗Dialog，也有负责提示消息的Notification。</p><p>这些组件除了负责渲染传递的数据和方法之外，还需要能够脱离当前组件进行渲染，<strong>防止当前组件的css样式影响布局</strong>。因此Notification组件需要渲染到body标签内部，而Vue提供了Teleport组件来完成这个任务，我们通过Teleport组件就能把内部的组件渲染到指定的dom标签。</p><p>之后，我们需要给组件提供JavaScript调用的方法。我们可以使用Notification()\b的方式动态创建组件，利用createNotification即可动态创建Vue组件的实例。</p><p>对于弹窗组件来说可以这样操作：首先通过createNotification函数创建弹窗的实例，并且给每个弹窗设置好唯一的id属性，然后存储在数组中进行管理。接着，我们通过对createNotification函数返回值的管理，即可实现弹窗动态的渲染、更新和删除功能。</p><h2>总结</h2><p>正文里已经详细讲解和演示了弹窗组件的设计，所以今天的总结我想变个花样，再给你说说TDD的事儿。</p><p>很多同学会觉得写测试代码要花一定成本，有畏难心理，觉得自己不太会写测试，这些“假想”给我们造成了“TDD很难实施”的错觉。实际上入门TDD并没有这么难。按照我的实践经验来看，先学会怎么写测试，再学习怎么重构，基本上就可以入门写TDD了。</p><p>就拿我们这讲的实践来说，我们再次应用了<strong>测试驱动开发</strong>这个方式来实现弹窗组件，把整体需求拆分成一个个子任务，逐个击破。根据设计的需求写好测试代码之后，测试代码就会检查我们的业务逻辑有没有实现，指导我们做相应的修改。</p><p>咱们的实践过程抽象出来，一共包括四个步骤：写测试 -&gt; 运行测试(报错) -&gt; 写代码让测试通过 -&gt; 重构的方式。这样的开发模式，今后你在设计组件库时也可以借鉴，不但有助于提高代码的质量和可维护性，还能让代码有比较高的代码测试覆盖率。</p><h2>思考题</h2><p>最后留一个思考题，现在我们设计的Notification组件的message只能支持文本消息，如果想支持传入其他组件，应该如何实现？</p><p>欢迎你在评论去分享你的答案，也欢迎你把这一讲的内容分享给你的同事和朋友们，我们下一讲再见。</p>","neighbors":{"left":{"article_title":"22｜表单：如何设计一个表单组件？","id":465677},"right":{"article_title":"24｜树：如何设计一个树形组件？","id":468036}},"comments":[]}