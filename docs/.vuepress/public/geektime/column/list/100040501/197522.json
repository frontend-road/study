{"id":197522,"title":"加餐 | 部分课后思考题答案合集","content":"<p>你好，我是吴咏炜。这一讲我为你整理了本专栏部分课后思考题的答案，给你作为参考。</p><h2><a href=\"https://time.geekbang.org/column/article/169263\">第 2 讲</a></h2><p><strong>你觉得智能指针应该满足什么样的线程安全性？</strong></p><p>答：（不是真正的回答，只是描述一下标准中的智能指针的线程安全性。）</p><ol>\n<li>多个不同线程同时访问不同的智能指针（不管是否指向同一个对象）是安全的。</li>\n<li>多个不同线程同时读取同一个智能指针是安全的。</li>\n<li>多个不同线程在同一个智能指针上执行原子操作（<code>atomic_load</code> 等）是安全的。</li>\n<li>多个不同线程根据同一个智能指针创建新的智能指针（增加引用计数）是安全的。</li>\n<li>只会有一个线程最后会（在引用计数表示已经无引用时）调用删除函数去销毁存储的对象。</li>\n</ol><p>其他操作潜在是不安全的，特别是在不同的线程对同一个智能指针执行 <code>reset</code> 等修改操作。</p><h2><a href=\"https://time.geekbang.org/column/article/169268\">第 3 讲</a></h2><p><strong>为什么 <code>smart_ptr::operator=</code> 对左值和右值都有效，而且不需要对等号两边是否引用同一对象进行判断？</strong></p><p>答：我们使用值类型而非引用类型作为形参，这样实参永远会被移动（右值的情况）或复制（左值的情况），不可能和 <code>*this</code> 引用同一个对象。</p><h2><a href=\"https://time.geekbang.org/column/article/173167\">第 4 讲</a></h2><p><strong>为什么 <code>stack</code>（或 <code>queue</code>）的 <code>pop</code> 函数返回类型为 <code>void</code>，而不是直接返回容器的 <code>top</code>（或 <code>front</code>）成员？</strong></p><p>答：这是 C++98 里、还没有移动语义时的设计。如果 <code>pop</code> 返回元素，而元素拷贝时发生异常的话，那这个元素就丢失了。因而容器设计成有分离的 <code>top</code>（或 <code>front</code>）和 <code>pop</code> 成员函数，分别执行访问和弹出的操作。</p><!-- [[[read_end]]] --><p>有一种可能的设计是把接口改成 <code>void pop(T&)</code>，这增加了 <code>T</code> 必须支持默认构造和赋值的要求，在单线程为主的年代没有明显的好处，反而带来了对 <code>T</code> 的额外要求。</p><h2><a href=\"https://time.geekbang.org/column/article/174434\">第 5 讲</a></h2><p><strong>为什么大部分容器都提供了 <code>begin</code>、<code>end</code> 等方法？</strong></p><p>答：容器提供了 <code>begin</code> 和 <code>end</code> 方法，就意味着是可以迭代（遍历）的。大部分容器都可以从头到尾遍历，因而也就需要提供这两个方法。</p><p><strong>为什么容器没有继承一个公用的基类？</strong></p><p>答：C++ 不是面向对象的语言，尤其在标准容器的设计上主要使用值语义，使用公共基类完全没有用处。</p><h2><a href=\"https://time.geekbang.org/column/article/176842\">第 7 讲</a></h2><p><strong>目前这个输入行迭代器的行为，在什么情况下可能导致意料之外的后果？</strong></p><p>答：</p><pre><code class=\"language-c++\">#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include \"istream_line_reader.h\"\n\nusing namespace std;\n\nint main()\n{\n  ifstream ifs{\"test.cpp\"};\n  istream_line_reader reader{ifs};\n  auto begin = reader.begin();\n  for (auto it = reader.begin();\n    it != reader.end(); ++it) {\n    cout &lt;&lt; *it &lt;&lt; '\\n';\n  }\n}\n</code></pre><p>以上代码，因为 begin 多调用了一次，输出就少了一行……</p><p><strong>请尝试一下改进这个输入行迭代器，看看能不能消除这种意外。如果可以，该怎么做？如果不可以，为什么？</strong></p><p>答：很困难。比如，文件如果为空的话，从迭代器的行为角度，<code>begin()</code> 应该等于 <code>end()</code>——不预先读取一次的话，就无法获知这个结果。这样的改造总体看起来很不值，因此一般都不会选择这样做。</p><h2><a href=\"https://time.geekbang.org/column/article/178940\">第 10 讲</a></h2><p><strong>这讲里我们没有深入讨论赋值；请你思考一下，如果例子里改成赋值，会有什么样的变化？</strong></p><p>答：返回对象部分的讨论没有变化。对象的移动赋值操作应当实现成无异常，以确保数据不会丢失。</p><p>返回值优化在赋值情况下会失效。更一般的情况下，除非需要持续更新某个变量，比如在 <code>vector</code> 尾部追加数据，尽量对变量进行一次性赋值、不后续修改。这样的代码更容易推理，更不容易在后续修改中出错，也更能让编译器做（返回值）优化。</p><h2><a href=\"https://time.geekbang.org/column/article/179357\">第 11 讲</a></h2><p><strong>为什么说 UTF-32 处理会比较简单？</strong></p><p>答：UTF-32 下，一个字符就是一个基本的处理单位，一般不会出现一个字符跨多个处理单位的情况（UTF-8 和 UTF-16 下会发生）。</p><p><strong>你知道什么情况下 UTF-32 也并不那么简单吗？</strong></p><p>答：Unicode 下有所谓的修饰字符，用来修饰前一个字符。按 Unicode 的处理规则，这些字符应该和基本字符一起处理（如断行之类）。所以 UTF-32 下也不可以在任意单位处粗暴断开处理。</p><p><strong>哪种 UTF 编码方式空间存储效率比较高？</strong></p><p>答：视存储的内容而定。</p><p>比如，如果内容以 ASCII 为主（如源代码），那 UTF-8 效率最高。如果内容以一般的中文文本为主，那 UTF-16 效率最高。</p><h2><a href=\"https://time.geekbang.org/column/article/179363\">第 12 讲</a></h2><p><strong>为什么并非所有的语言都支持这些不同的多态方式？</strong></p><p>答：排除设计缺陷的情况，语言支持哪些多态方式，基本上取决于语言本身在类型方面的特性。</p><p>以 Python 为例，它是动态类型的语言。所以它不会有真正的静态多态。但和静态类型的面向对象语言（如 Java）不同，它的运行期多态不需要继承。没有参数化多态初看是个缺陷，但由于 Python 的动态参数系统允许默认参数和可变参数，并没有什么参数化多态能做得到而 Python 做不到的事。</p><h2><a href=\"https://time.geekbang.org/column/article/185189\">第 17 讲</a></h2><p><strong>想一想，你如何可以实现一个惰性的过滤器？</strong></p><p>答：</p><pre><code class=\"language-c++\">#include &lt;iterator&gt;\n\nusing namespace std;\n\ntemplate &lt;typename I, typename F&gt;\nclass filter_view {\npublic:\n  class iterator {\n  public:\n    typedef ptrdiff_t\n      difference_type;\n    typedef\n      typename iterator_traits&lt;\n        I&gt;::value_type value_type;\n    typedef\n      typename iterator_traits&lt;\n        I&gt;::pointer pointer;\n    typedef\n      typename iterator_traits&lt;\n        I&gt;::reference reference;\n    typedef forward_iterator_tag\n      iterator_category;\n\n    iterator(I current, I end, F cond)\n      : current_(current)\n      , end_(end)\n      , cond_(cond)\n    {\n      if (current_ != end_ &amp;&amp;\n          !cond_(*current_)) {\n        ++*this;\n      }\n    }\n    iterator&amp; operator++()\n    {\n      while (current_ != end_) {\n        ++current_;\n        if (cond_(*current_)) {\n          break;\n        }\n      }\n      return *this;\n    }\n    iterator operator++(int)\n    {\n      auto temp = *this;\n      ++*this;\n      return temp;\n    }\n    reference operator*() const\n    {\n      return *current_;\n    }\n    pointer operator-&gt;() const\n    {\n      return &amp;*current_;\n    }\n\n    bool operator==(const iterator&amp; rhs)\n    {\n      return current_ == rhs.current_;\n    }\n    bool operator!=(const iterator&amp; rhs)\n    {\n      return !operator==(rhs);\n    }\n\n  private:\n    I current_;\n    I end_;\n    F cond_;\n  };\n  filter_view(I begin, I end,\n              F cond)\n    : begin_(begin)\n    , end_(end)\n    , cond_(cond)\n  {}\n  iterator begin() const\n  {\n    return iterator(begin_, end_, cond_);\n  }\n  iterator end() const\n  {\n    return iterator(end_, end_, cond_);\n  }\n\nprivate:\n  I begin_;\n  I end_;\n  F cond_;\n};\n</code></pre><h2><a href=\"https://time.geekbang.org/column/article/185899\">第 18 讲</a></h2><p><strong>我展示了 <code>compose</code> 带一个或更多参数的情况。你觉得 <code>compose</code> 不带任何参数该如何定义？它有意义吗？</strong></p><p>答：</p><pre><code class=\"language-c++\">inline auto compose()\n{\n    return [](auto&amp;&amp; x) -&gt; decltype(auto)\n    {\n        return std::forward&lt;decltype(x)&gt;(x);\n    };\n}\n</code></pre><p>这个函数把参数原封不动地传回。它的意义相当于加法里的 0，乘法里的 1。</p><p>在普通的加法里，你可能不太需要 0；但在一个做加法的地方，如果别人想告诉你不要做任何操作，传给你一个 0 是最简单的做法。</p><p><strong>有没有可能不用 <code>index_sequence</code> 来初始化 <code>bit_count</code>？如果行，应该如何实现？</strong></p><p>答：可以，但这里有个小陷阱，目前 constexpr 要求在构造时直接初始化对象的内容。</p><pre><code class=\"language-c++\">template &lt;size_t N&gt;\nstruct bit_count_t {\n  constexpr bit_count_t()\n  {\n    for (auto i = 0U; i &lt; N; ++i) {\n      count[i] = count_bits(i);\n    }\n  }\n  unsigned char count[N]{};\n};\n\nconstexpr bit_count_t&lt;256&gt;\n  bit_count;\n</code></pre><p>也可以考虑改用 <code>std::array</code>：</p><pre><code class=\"language-c++\">std::array&lt;char, N&gt; count{};\n</code></pre><p>使用 <code>std::array</code> 的话，我们可以考虑不再需要 <code>bit_count_t</code> 结构，因为可以让 <code>get_bit_count</code> 直接返回一个 <code>std::array&lt;char, 256&gt;</code>（返回 <code>char [256]</code> 则不可行）。</p><p>到了 C++20，允许 constexpr 对象里存在平凡默认构造的成员之后，就可以去掉数组声明后的那个看似多余的初始化器 <code>{}</code> 了——但你仍需在后面初始化所有的成员。</p><p><strong>作为一个挑战，你能自行实现出 <code>make_integer_sequence</code> 吗？</strong></p><p>答 1：</p><pre><code class=\"language-c++\">template &lt;class T, T... Ints&gt;\nstruct integer_sequence {};\n\ntemplate &lt;class T&gt;\nstruct integer_sequence_ns {\n  template &lt;T N, T... Ints&gt;\n  struct integer_sequence_helper {\n    using type =\n      typename integer_sequence_helper&lt;\n        N - 1, N - 1,\n        Ints...&gt;::type;\n  };\n\n  template &lt;T... Ints&gt;\n  struct integer_sequence_helper&lt;\n    0, Ints...&gt; {\n    using type =\n      integer_sequence&lt;T, Ints...&gt;;\n  };\n};\n\ntemplate &lt;class T, T N&gt;\nusing make_integer_sequence =\n  typename integer_sequence_ns&lt;T&gt;::\n    template integer_sequence_helper&lt;\n      N&gt;::type;\n</code></pre><p>如果一开始写成 <code>template &lt;class T, T N, T... Ints&gt; struct integer_sequence_helper</code> 的话，就会遇到错误“non-type template argument specializes a template parameter with dependent type ‘T’”（非类型的模板实参特化了一个使用依赖类型的‘T’的模板形参）。这是目前的 C++ 标准所不允许的写法，改写成嵌套类形式可以绕过这个问题。</p><p>答 2：</p><pre><code class=\"language-c++\">template &lt;class T, T... Ints&gt;\nstruct integer_sequence {};\n\ntemplate &lt;class T, T N, T... Is&gt;\nauto make_integer_sequence_impl()\n{\n  if constexpr (N == 0) {\n    return integer_sequence&lt;\n      T, Is...&gt;();\n  } else {\n    return make_integer_sequence_impl&lt;\n      T, N - 1, N - 1, Is...&gt;();\n  }\n}\n\ntemplate &lt;class T, T N&gt;\nusing make_integer_sequence =\n  decltype(\n    make_integer_sequence_impl&lt;\n      T, N&gt;());\n</code></pre><p>这又是一个 <code>constexpr</code> 能简化表达的例子。</p><h2><a href=\"https://time.geekbang.org/column/article/186689\">第 19 讲</a></h2><p><strong>并发编程中哪些情况下会发生死锁？</strong></p><p>答：多个线程里，如果没有或不能事先约定访问顺序，同时进行可阻塞的资源访问，访问顺序可以形成一个环，就会引发死锁。</p><p>可阻塞的资源访问可能包括（但不限于）：</p><ul>\n<li>互斥量上的 <code>lock</code> 调用</li>\n<li>条件变量上的 <code>wait</code> 调用</li>\n<li>对线程的 <code>join</code> 调用</li>\n<li>对 <code>future</code> 的 <code>get</code> 调用</li>\n</ul><h2><a href=\"https://time.geekbang.org/column/article/193523\">第 27 讲</a></h2><p><strong>你觉得 C++ REST SDK 的接口好用吗？如果好用，原因是什么？如果不好用，你有什么样的改进意见？</strong></p><p>答：举几个可能的改进点。</p><p>C++ REST SDK 的 <code>uri::decode</code> 接口设计有不少问题：</p><ul>\n<li>最严重的，不能对 query string 的等号左边的部分进行 <code>decode</code>；只能先 <code>split_query</code> 再 <code>decode</code>，此时等号左边已经在 <code>map</code> 里，不能修改——要修改需要建一个新的 <code>map</code>。</li>\n<li>目前的实现对“+”不能重新还原成空格。</li>\n</ul><p>换个说法，目前的接口能正确处理“/search?q=query%20string”这样的请求，但不能正确处理“/search?%71=query+string”这样的请求。</p><p>应当有一个 <code>split_query_and_decode</code> 接口，同时执行分割和解码。</p><p>另外，<code>json</code> 的接口也还是不够好用，最主要是没有使用初始化列表的构造。构造复杂的 JSON 结构有点啰嗦了。</p><p><code>fstream::open_ostream</code> 缺省行为跟 <code>std::ofstream</code> 不一样应该是个 bug。应当要么修正接口（接口缺省参数里带上 <code>trunc</code>），要么修正实现（跟 <code>std::ofstream</code> 一样把 <code>out</code> 当成 <code>out|trunc</code>）。</p><h2><a href=\"https://time.geekbang.org/column/article/194005\">第 28 讲</a></h2><p><strong>“概念”可以为开发具体带来哪些好处？反过来，负面的影响又可能会是什么？</strong></p><p>答：对于代码严谨、具有形式化思维的人，“概念”是个福音，它不仅可以大量消除 SFINAE 的使用，还能以较为精确和形式化的形式在代码里写出对类型的要求，使得代码变得清晰、易读。</p><p>但反过来说，“概念”比鸭子类型更严格。在代码加上概念约束后，相关代码很可能需要修改才能满足概念的要求，即使之前在实际使用中可能已经完全没有问题。从迭代器的角度，实际使用中最小功能集是构造、可复制、<code>*</code>、前置 <code>++</code>、与 sentinel 类型对象的 <code>!=</code>（单一形式）。而为了满足迭代器概念，则要额外确保满足以下各点：</p><ul>\n<li>可默认初始化</li>\n<li>在 iterator 类型和 sentinel 类型之间，需要定义完整的四个 <code>==</code> 和 <code>!=</code> 运算符</li>\n<li>定义迭代器的标准内部类型，如 <code>difference_type</code> 等</li>\n</ul><p>以上就是今天的全部内容了，希望能对你有所帮助！如果你有更多问题，还是请你在留言区中提出，我会一一解答。</p>","comments":[{"had_liked":false,"id":177922,"user_name":"晚风·和煦","can_delete":false,"product_type":"c1","uid":1236047,"ip_address":"","ucode":"0B1DB8F437A4B2","user_header":"","comment_is_top":false,"comment_ctime":1581533033,"is_pvip":false,"replies":[{"id":69116,"content":"实现？不太明白你的意思了。私有只是编译时的访问控制，不是运行时的。而C完全没有编译时的访问控制的机制。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1581607987,"ip_address":"","comment_id":177922,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，c语言可以通过哪些方式实现c++中的私有成员呢？谢谢老师😃😃😃","like_count":1},{"had_liked":false,"id":177886,"user_name":"幻境之桥","can_delete":false,"product_type":"c1","uid":1061517,"ip_address":"","ucode":"F9F4DD94CB554E","user_header":"https://static001.geekbang.org/account/avatar/00/10/32/8d/91cd624b.jpg","comment_is_top":false,"comment_ctime":1581521783,"is_pvip":false,"replies":[{"id":69117,"content":"问题是“哪种 UTF 编码方式空间存储效率比较高”。GBK 不能支持很多其他语言，不在考虑范围内。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1581608596,"ip_address":"","comment_id":177886,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"&quot;如果内容以一般的中文文本为主，那 UTF-16 效率最高。&quot;\n这是为什么呢？中文不应该是 GBK更省空间吗？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483596,"discussion_content":"实现？不太明白你的意思了。私有只是编译时的访问控制，不是运行时的。而C完全没有编译时的访问控制的机制。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581607987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1762459,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/e4/9b/fcb4b8b7.jpg","nickname":"李义盛","note":"","ucode":"2C79848BCF545D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":168489,"discussion_content":"用c++不好嘛，何苦为难自己。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581584674,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1236047,"avatar":"","nickname":"晚风·和煦","note":"","ucode":"0B1DB8F437A4B2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1762459,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/e4/9b/fcb4b8b7.jpg","nickname":"李义盛","note":"","ucode":"2C79848BCF545D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":168508,"discussion_content":"面试官心里会骂我的😥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581586096,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":168489,"ip_address":"","group_id":0},"score":168508,"extra":""}]}]},{"had_liked":false,"id":324537,"user_name":"Peter","can_delete":false,"product_type":"c1","uid":2425556,"ip_address":"","ucode":"5E57A0FE948966","user_header":"https://static001.geekbang.org/account/avatar/00/25/02/d4/1e0bb504.jpg","comment_is_top":false,"comment_ctime":1638494646,"is_pvip":false,"replies":[{"id":117796,"content":"pop 返回元素，指的是 pop 同时具有返回第一个元素和将其弹出两个功能。丢失了，“返回元素”这个功能不就出问题了么？\n\n","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1638535495,"ip_address":"","comment_id":324537,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"如果 pop 返回元素，而元素拷贝时发生异常的话，那这个元素就丢失了。因而容器设计成有分离的 top（或 front）和 pop 成员函数，分别执行访问和弹出的操作。～老师，想问下这个拷贝是指将POP返回的值给其他元素的时候吗？但是POP本来就是弹出元素，丢失应该也没关系的吧，有点不是很理解","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483583,"discussion_content":"问题是“哪种 UTF 编码方式空间存储效率比较高”。GBK 不能支持很多其他语言，不在考虑范围内。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581608596,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1762459,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/e4/9b/fcb4b8b7.jpg","nickname":"李义盛","note":"","ucode":"2C79848BCF545D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":169349,"discussion_content":"GBK不能跨平台，容易乱码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581606988,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":285385,"user_name":"吴咏炜","can_delete":false,"product_type":"c1","uid":1645639,"ip_address":"","ucode":"8C24C10AEC779F","user_header":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","comment_is_top":false,"comment_ctime":1616767262,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"第 18 讲第 2 题有一个 C++14&#47;17 里也能接受的解，就是要先初始化数组，然后再改写其中的内容。\n\n把文中的 bit_count_t 定义改成下面的形式即可（加上“{}”）：\n\ntemplate &lt;size_t N&gt;\nstruct bit_count_t {\n  constexpr bit_count_t()\n  {\n    for (auto i = 0U; i &lt; N; ++i) {\n      count[i] = count_bits(i);\n    }\n  }\n  unsigned char count[N]{};\n};\n\n“unsigned char count[N]{};”也可以考虑改用 std::array：\n\nstd::array&lt;char, N&gt; count{};\n\n使用 std::array 的话，我们可以考虑不再需要 bit_count_t 结构，因为可以让 get_bit_count 直接返回一个 std::array&lt;char, 256&gt;（返回 char [256] 则不可行）。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535757,"discussion_content":"pop 返回元素，指的是 pop 同时具有返回第一个元素和将其弹出两个功能。丢失了，“返回元素”这个功能不就出问题了么？\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638535495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177922,"user_name":"晚风·和煦","can_delete":false,"product_type":"c1","uid":1236047,"ip_address":"","ucode":"0B1DB8F437A4B2","user_header":"","comment_is_top":false,"comment_ctime":1581533033,"is_pvip":false,"replies":[{"id":69116,"content":"实现？不太明白你的意思了。私有只是编译时的访问控制，不是运行时的。而C完全没有编译时的访问控制的机制。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1581607987,"ip_address":"","comment_id":177922,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，c语言可以通过哪些方式实现c++中的私有成员呢？谢谢老师😃😃😃","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483596,"discussion_content":"实现？不太明白你的意思了。私有只是编译时的访问控制，不是运行时的。而C完全没有编译时的访问控制的机制。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581607987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1762459,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/e4/9b/fcb4b8b7.jpg","nickname":"李义盛","note":"","ucode":"2C79848BCF545D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":168489,"discussion_content":"用c++不好嘛，何苦为难自己。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581584674,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1236047,"avatar":"","nickname":"晚风·和煦","note":"","ucode":"0B1DB8F437A4B2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1762459,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/e4/9b/fcb4b8b7.jpg","nickname":"李义盛","note":"","ucode":"2C79848BCF545D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":168508,"discussion_content":"面试官心里会骂我的😥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581586096,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":168489,"ip_address":"","group_id":0},"score":168508,"extra":""}]}]},{"had_liked":false,"id":177886,"user_name":"幻境之桥","can_delete":false,"product_type":"c1","uid":1061517,"ip_address":"","ucode":"F9F4DD94CB554E","user_header":"https://static001.geekbang.org/account/avatar/00/10/32/8d/91cd624b.jpg","comment_is_top":false,"comment_ctime":1581521783,"is_pvip":false,"replies":[{"id":69117,"content":"问题是“哪种 UTF 编码方式空间存储效率比较高”。GBK 不能支持很多其他语言，不在考虑范围内。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1581608596,"ip_address":"","comment_id":177886,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"&quot;如果内容以一般的中文文本为主，那 UTF-16 效率最高。&quot;\n这是为什么呢？中文不应该是 GBK更省空间吗？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483583,"discussion_content":"问题是“哪种 UTF 编码方式空间存储效率比较高”。GBK 不能支持很多其他语言，不在考虑范围内。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581608596,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1762459,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/e4/9b/fcb4b8b7.jpg","nickname":"李义盛","note":"","ucode":"2C79848BCF545D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":169349,"discussion_content":"GBK不能跨平台，容易乱码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581606988,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324537,"user_name":"Peter","can_delete":false,"product_type":"c1","uid":2425556,"ip_address":"","ucode":"5E57A0FE948966","user_header":"https://static001.geekbang.org/account/avatar/00/25/02/d4/1e0bb504.jpg","comment_is_top":false,"comment_ctime":1638494646,"is_pvip":false,"replies":[{"id":117796,"content":"pop 返回元素，指的是 pop 同时具有返回第一个元素和将其弹出两个功能。丢失了，“返回元素”这个功能不就出问题了么？\n\n","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1638535495,"ip_address":"","comment_id":324537,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"如果 pop 返回元素，而元素拷贝时发生异常的话，那这个元素就丢失了。因而容器设计成有分离的 top（或 front）和 pop 成员函数，分别执行访问和弹出的操作。～老师，想问下这个拷贝是指将POP返回的值给其他元素的时候吗？但是POP本来就是弹出元素，丢失应该也没关系的吧，有点不是很理解","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535757,"discussion_content":"pop 返回元素，指的是 pop 同时具有返回第一个元素和将其弹出两个功能。丢失了，“返回元素”这个功能不就出问题了么？\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638535495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":285385,"user_name":"吴咏炜","can_delete":false,"product_type":"c1","uid":1645639,"ip_address":"","ucode":"8C24C10AEC779F","user_header":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","comment_is_top":false,"comment_ctime":1616767262,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"第 18 讲第 2 题有一个 C++14&#47;17 里也能接受的解，就是要先初始化数组，然后再改写其中的内容。\n\n把文中的 bit_count_t 定义改成下面的形式即可（加上“{}”）：\n\ntemplate &lt;size_t N&gt;\nstruct bit_count_t {\n  constexpr bit_count_t()\n  {\n    for (auto i = 0U; i &lt; N; ++i) {\n      count[i] = count_bits(i);\n    }\n  }\n  unsigned char count[N]{};\n};\n\n“unsigned char count[N]{};”也可以考虑改用 std::array：\n\nstd::array&lt;char, N&gt; count{};\n\n使用 std::array 的话，我们可以考虑不再需要 bit_count_t 结构，因为可以让 get_bit_count 直接返回一个 std::array&lt;char, 256&gt;（返回 char [256] 则不可行）。","like_count":0}]}