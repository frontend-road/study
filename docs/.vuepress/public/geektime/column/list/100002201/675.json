{"id":675,"title":"11 | 程序中的错误处理：错误返回码和异常捕捉","content":"<p>你好，我是陈皓，网名左耳朵耗子。</p><p>今天，我们来讨论一下程序中的错误处理。也许你会觉得这个事没什么意思，处理错误的代码并不难写。但你想过没有，要把错误处理写好，并不是件容易的事情。另外，任何一个稳定的程序中都会有大量的代码在处理错误，所以说，处理错误是程序中一件比较重要的事情。这里，我会用两节课来系统地讲一下错误处理的各种方式和相关实践。</p><h1>传统的错误检查</h1><p>首先，我们知道，处理错误最直接的方式是通过错误码，这也是传统的方式，在过程式语言中通常都是用这样的方式处理错误的。比如C语言，基本上来说，其通过函数的返回值标识是否有错，然后通过全局的<code>errno</code>变量并配合一个 <code>errstr</code> 的数组来告诉你为什么出错。</p><p>为什么是这样的设计？道理很简单，除了可以共用一些错误，更重要的是这其实是一种妥协。比如：<code>read()</code>, <code>write()</code>, <code>open()</code> 这些函数的返回值其实是返回有业务逻辑的值。也就是说，这些函数的返回值有两种语义，一种是成功的值，比如 <code>open()</code> 返回的文件句柄指针 <code>FILE*</code> ，或是错误 <code>NULL</code>。这样会导致调用者并不知道是什么原因出错了，需要去检查 <code>errno</code> 来获得出错的原因，从而可以正确地处理错误。</p><p>一般而言，这样的错误处理方式在大多数情况下是没什么问题的。但是也有例外的情况，我们来看一下下面这个C语言的函数：</p><!-- [[[read_end]]] --><pre><code>int atoi(const char *str)\n</code></pre><p>这个函数是把一个字符串转成整型。但是问题来了，如果一个要传的字符串是非法的（不是数字的格式），如\"ABC\"或者整型溢出了，那么这个函数应该返回什么呢？出错返回，返回什么数都不合理，因为这会和正常的结果混淆在一起。比如，返回 <code>0</code>，那么会和正常的对 “0” 字符的返回值完全混淆在一起。这样就无法判断出错的情况。你可能会说，是不是要检查一下 <code>errno</code>，按道理说应该是要去检查的，但是，我们在C99的规格说明书中可以看到这样的描述：</p><blockquote>\n<p>7.20.1</p>\n<p>The functions atof, atoi, atol, and atoll need not affect the value of the integer expression errno on an error. If the value of the result cannot be represented, the behavior is undeﬁned.</p>\n</blockquote><p>像<code>atoi()</code>, <code>atof()</code>, <code>atol()</code> 或是 <code>atoll()</code> 这样的函数是不会设置 <code>errno</code>的，而且，还说了，如果结果无法计算的话，行为是<code>undefined</code>。所以，后来，libc又给出了一个新的函数<code>strtol()</code>，这个函数在出错时会设置全局变量<code>errno</code> ：</p><pre><code>long strtol(const char *restrict str, char **restrict endptr, int base);\n</code></pre><p>于是，我们就可以这样使用：</p><pre><code>long val = strtol(in_str, &amp;endptr, 10);  //10的意思是10进制\n\n//如果无法转换\nif (endptr == str) {\n    fprintf(stderr, &quot;No digits were found\\n&quot;);\n    exit(EXIT_FAILURE);\n}\n\n//如果整型溢出了\nif ((errno == ERANGE &amp;&amp; (val == LONG_MAX || val == LONG_MIN)) {\n    fprintf(stderr, &quot;ERROR: number out of range for LONG\\n&quot;);\n    exit(EXIT_FAILURE);\n }\n\n//如果是其它错误\nif (errno != 0 &amp;&amp; val == 0) {\n    perror(&quot;strtol&quot;);\n    exit(EXIT_FAILURE);\n}\n\n</code></pre><p>虽然，<code>strtol()</code> 函数解决了 <code>atoi()</code> 函数的问题，但是我们还是能感觉到不是很舒服和自然。</p><p>因为，这种用 <code>返回值</code> + <code>errno</code> 的错误检查方式会有一些问题：</p><ul>\n<li>程序员一不小心就会忘记返回值的检查，从而造成代码的Bug；</li>\n<li>函数接口非常不纯洁，正常值和错误值混淆在一起，导致语义有问题。</li>\n</ul><p>所以，后来，有一些类库就开始区分这样的事情。比如，Windows的系统调用开始使用 <code>HRESULT</code> 的返回来统一错误的返回值，这样可以明确函数调用时的返回值是成功还是错误。但这样一来，函数的input和output只能通过函数的参数来完成，于是出现了所谓的 <code>入参</code> 和 <code>出参</code> 这样的区别。</p><p>然而，这又使得函数接入中参数的语义变得复杂，一些参数是入参，一些参数是出参，函数接口变得复杂了一些。而且，依然没有解决函数的成功或失败可以被人为忽略的问题。</p><h1>多返回值</h1><p>于是，有一些语言通过多返回值来解决这个问题，比如Go语言。Go语言的很多函数都会返回 <code>result, err</code> 两个值，于是：</p><ul>\n<li>\n<p>参数上基本上就是入参，而返回接口把结果和错误分离，这样使得函数的接口语义清晰；</p>\n</li>\n<li>\n<p>而且，Go语言中的错误参数如果要忽略，需要显式地忽略，用 <code>_</code> 这样的变量来忽略；</p>\n</li>\n<li>\n<p>另外，因为返回的 <code>error</code> 是个接口（其中只有一个方法 <code>Error()</code>，返回一个 <code>string</code> ），所以你可以扩展自定义的错误处理。</p>\n</li>\n</ul><p>比如下面这个JSON语法的错误：</p><pre><code>type SyntaxError struct {\n    msg    string // description of error\n    Offset int64  // error occurred after reading Offset bytes\n}\n\nfunc (e *SyntaxError) Error() string { return e.msg }\n</code></pre><p>在使用上会是这个样子：</p><pre><code>if err := dec.Decode(&amp;val); err != nil {\n    if serr, ok := err.(*json.SyntaxError); ok {\n        line, col := findLine(f, serr.Offset)\n        return fmt.Errorf(&quot;%s:%d:%d: %v&quot;, f.Name(), line, col, err)\n    }\n    return err\n}\n</code></pre><p>上面这个示例来自Go的官方文档 《<a href=\"https://blog.golang.org/error-handling-and-go\">Error Handling and Go</a>》，如果你有时间，可以点进去链接细看。</p><p>多说一句，如果一个函数返回了多个不同类型的 <code>error</code>，你也可以使用下面这样的方式：</p><pre><code>if err != nil {\n\tswitch err.(type) {\n\t\tcase *json.SyntaxError:\n\t\t\t...\n\t\tcase *ZeroDivisionError:\n\t\t\t...\n\t\tcase *NullPointerError:\n\t\t\t...\n\t\tdefault:\n\t\t\t...\n\t}\n}\n</code></pre><p>但即便像Go这样的语言能让错误处理语义更清楚，而且还有可扩展性，也有其问题。如果写过一段时间的Go语言，你就会明白其中的痛苦—— <code>if err != nil</code> 这样的语句简直是写到吐，只能在IDE中定义一个自动写这段代码的快捷键……而且，正常的逻辑代码会被大量的错误处理打得比较凌乱。</p><h1>资源清理</h1><p>程序出错时需要对已分配的一些资源做清理，在传统的玩法下，每一步的错误都要去清理前面已分配好的资源。于是就出现了 <code>goto fail</code> 这样的错误处理模式。如下所示：</p><pre><code class=\"language-c\">#define FREE(p) if(p) { \\\n                    free(p); \\\n                    p = NULL; \\\n                 }\nmain()\n{\n\tchar *fname=NULL, *lname=NULL, *mname=NULL;\n\tfname = ( char* ) calloc ( 20, sizeof(char) );\n\tif ( fname == NULL ){\n\t    goto fail;\n\t}\n\tlname = ( char* ) calloc ( 20, sizeof(char) );\n\tif ( lname == NULL ){\n\t    goto fail;\n\t}\n\tmname = ( char* ) calloc ( 20, sizeof(char) );\n\tif ( mname == NULL ){\n\t    goto fail;\n\t}\n    \n\t......\n \n    \nfail:\n\tFREE(fname);\n\tFREE(lname);\n\tFREE(mname);\n\tReportError(ERR_NO_MEMORY);\n} \n</code></pre><p>这样的处理方式虽然可以，但是会有潜在的问题。最主要的一个问题就是你不能在中间的代码中有 <code>return</code> 语句，因为你需要清理资源。在维护这样的代码时需要格外小心，因为一不注意就会导致代码有资源泄漏的问题。</p><p>于是，C++的RAII（Resource Acquisition Is Initialization）机制使用面向对象的特性可以容易地处理这个事情。RAII其实使用C++类的机制，在构造函数中分配资源，在析构函数中释放资源。下面看个例子。</p><p>我们先看一个不好的示例：</p><pre><code class=\"language-c++\">std::mutex m;\n \nvoid bad() \n{\n    m.lock();                    // 请求互斥\n    f();                         // 若f()抛异常，则互斥绝不被释放\n    if(!everything_ok()) return; // 提早返回，互斥绝不被释放\n    m.unlock();                  // 若bad()抵达此语句，互斥才被释放\n}\n</code></pre><p>上面这个例子，在函数的第三条语句提前返回了，直接导致 <code>m.unlock()</code> 没有被调用，这样会引起死锁问题。我们来看一下用RAII的方式是怎样解决这个问题的。</p><pre><code class=\"language-c++\">//首先，先声明一个RAII类，注意其中的构造函数和析构函数\nclass LockGuard {\npublic:\n\tLockGuard(std::mutex &amp;m):_m(m) { m.lock(); }\n\t~LockGuard() { m. unlock(); }\nprivate:\n\tstd::mutex&amp; _m;\n}\n\n\n//然后，我们来看一下，怎样使用的\nvoid good()\n{\n\tLockGuard lg(m); \t\t\t    // RAII类：构造时，互斥量请求加锁\n\tf();                             // 若f()抛异常，则释放互斥\n\tif(!everything_ok()) return;     // 提早返回，LockGuard析构时，互斥量被释放\n}                                    // 若good()正常返回，则释放互斥\n</code></pre><p>在Go语言中，使用<code>defer</code>关键字也可以做到这样的效果。参看下面的示例：</p><pre><code class=\"language-go\">func Close(c io.Closer) {\n\terr := c.Close()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\nfunc main() {\n\tr, err := Open(\"a\")\n\tif err != nil {\n\t\tlog.Fatalf(\"error opening 'a'\\n\")\n\t}\n\tdefer Close(r) // 使用defer关键字在函数退出时关闭文件。\n\n\tr, err = Open(\"b\")\n\tif err != nil {\n\t\tlog.Fatalf(\"error opening 'b'\\n\")\n\t}\n\tdefer Close(r) // 使用defer关键字在函数退出时关闭文件。\n}\n</code></pre><p>不知道从上面这三个例子来看，不同语言的错误处理，你自己更喜欢哪个呢？就代码的易读和干净而言，我更喜欢C++的RAII模式，然后是Go的defer模式，最后才是C语言的goto fail模式。</p><h1>异常捕捉处理</h1><p>上面，我们讲了错误检查和程序出错后对资源的清理这两个事。能把这个事做得比较好的其实是 <code>try - catch - finally</code> 这个编程模式。</p><pre><code>try {\n\t... // 正常的业务代码\n} catch (Exception1 e) {\n\t... // 处理异常 Exception1 的代码\n} catch (Exception2 e) {\n\t... // 处理异常 Exception2 的代码\n} finally {\n\t... // 资源清理的代码\n}\n</code></pre><p>把正常的代码、错误处理的代码、资源清理的代码分门别类，看上去非常干净。</p><p>有一些人明确表示不喜欢 <code>try - catch</code> 这种错误处理方式，比如著名的 软件工程师<a href=\"https://www.joelonsoftware.com/2005/05/11/making-wrong-code-look-wrong/\">Joel Spolsky</a>。</p><p>但是，我想说一下，<code>try - catch - finally</code> 这样的异常处理方式有如下一些好处。</p><ul>\n<li>\n<p>函数接口在input（参数）和output（返回值）以及错误处理的语义是比较清楚的。</p>\n</li>\n<li>\n<p>正常逻辑的代码可以与错误处理和资源清理的代码分开，提高了代码的可读性。</p>\n</li>\n<li>\n<p>异常不能被忽略（如果要忽略也需要catch住，这是显式忽略）。</p>\n</li>\n<li>\n<p>在面向对象的语言中（如Java），异常是个对象，所以，可以实现多态式的catch。</p>\n</li>\n</ul><p>与状态返回码相比，异常捕捉有一个显著的好处是，函数可以嵌套调用，或是链式调用，比如<code>int x = add(a, div(b,c));</code> 或 <code>Pizza p = PizzaBuilder().SetSize(sz) .SetPrice(p)...;</code>。</p><p>当然，你可能会觉得异常捕捉对程序的性能是有影响的，这句话也对也不对。原因是这样的。</p><ul>\n<li>\n<p>异常捕捉的确是对性能有影响的，那是因为一旦异常被抛出，函数也就跟着return了。而程序在执行时需要处理函数栈的上下文，这会导致性能变得很慢，尤其是函数栈比较深的时候。</p>\n</li>\n<li>\n<p>但从另一方面来说，异常的抛出基本上表明程序的错误。程序在绝大多数情况下，应该是在没有异常的情况下运行的，所以，有异常的情况应该是少数的情况，不会影响正常处理的性能问题。</p>\n</li>\n</ul><p>总体而言，我还是觉得 <code>try - catch - finally</code> 这样的方式是很不错的。而且这个方式比返回错误码在诸多方面都更好。</p><p>但是，<code>try - catch - finally</code> 有个致命的问题，那就是在异步运行的世界里的问题。try语句块里的函数运行在另外一个线程中，其中抛出的异常无法在调用者的这个线程中被捕捉。这个问题就比较大了。</p><h1>错误返回码 vs 异常捕捉</h1><p>是返回错误状态，还是用异常捕捉的方式处理错误，可能是一个很容易引发争论的问题。有人说，对于一些偏底层的错误，比如：空指针、内存不足等，可以使用返回错误状态码的方式，而对于一些上层的业务逻辑方面的错误，可以使用异常捕捉。这么说有一定道理，因为偏底层的函数可能用得更多一些。但是我并不这么认为。</p><p><strong>前面也比较过两者的优缺点，总体而言，似乎异常捕捉的优势更多一些。但是，我觉得应该从场景上来讨论这个事才是正确的姿势</strong>。</p><p>要讨论场景，我们需要先把要处理的错误分好类别，这样有利于简化问题。</p><p>因为，错误其实是很多的，不同的错误需要有不同的处理方式。但错误处理是有一些通用规则的。为了讲清楚这个事，我们需要把错误来分个类。我个人觉得错误可以分为三个大类。</p><ul>\n<li>\n<p><strong>资源的错误</strong>。当我们的代码去请求一些资源时导致的错误，比如打开一个没有权限的文件，写文件时出现的写错误，发送文件到网络端发现网络故障的错误，等等。<strong>这一类错误属于程序运行环境的问题。对于这类错误，有的我们可以处理，有的我们则无法处理。比如，内存耗尽、栈溢出或是一些程序运行时关键性资源不能满足等等这些情况，我们只能停止运行，甚至退出整个程序。</strong></p>\n</li>\n<li>\n<p><strong>程序的错误</strong>。比如：空指针、非法参数等。<strong>这类是我们自己程序的错误，我们要记录下来，写入日志，最好触发监控系统报警</strong>。</p>\n</li>\n<li>\n<p><strong>用户的错误</strong>。比如：Bad Request、Bad Format等这类由用户不合法输入带来的错误。<strong>这类错误基本上是在用户的API层上出现的问题</strong>。比如，解析一个XML或JSON文件，或是用户输入的字段不合法之类的。</p>\n<p><strong>对于这类问题，我们需要向用户端报错，让用户自己处理修正他们的输入或操作。然后，我们正常执行，但是需要做统计，统计相应的错误率，这样有利于我们改善软件或是侦测是否有恶意的用户请求。</strong></p>\n</li>\n</ul><p>我们可以看到，这三类错误中，有些是我们希望杜绝发生的，比如程序的Bug，有些则是我们杜绝不了的，比如用户的输入。而对于程序运行环境中的一些错误，则是我们希望可以恢复的。也就是说，我们希望可以通过重试或是妥协的方式来解决这些环境的问题，比如重建网络连接，重新打开一个新的文件。</p><p>所以，是不是我们可以这样来在逻辑上分类：</p><ul>\n<li>对于我们并不期望会发生的事，我们可以使用异常捕捉；</li>\n<li>对于我们觉得可能会发生的事，使用返回码。</li>\n</ul><p>比如，如果你的函数参数传入的对象不应该是一个null对象，那么，一旦传入null对象后，函数就可以抛异常，因为我们并不期望总是会发生这样的事。</p><p>而对于一个需要检查用户输入信息是否正确的事，比如：电子邮箱的格式，我们用返回码可能会好一些。所以，对于上面三种错误的类型来说，程序中的错误，可能用异常捕捉会比较合适；用户的错误，用返回码比较合适；而资源类的错误，要分情况，是用异常捕捉还是用返回值，要看这事是不应该出现的，还是经常出现的。</p><p>当然，这只是一个大致的实践原则，并不代表所有的事都需要符合这个原则。</p><p>除了用错误的分类来判断用返回码还是用异常捕捉之外，我们还要从程序设计的角度来考虑哪种情况下使用异常捕捉更好，哪种情况下使用返回码更好。</p><p>因为异常捕捉在编程上的好处比函数返回值好很多，所以很多使用异常捕捉的代码会更易读也更健壮一些。而返回码容易被忽略，所以，使用返回码的代码需要做好测试才能得到更好的软件质量。</p><p>不过，我们也要知道，在某些情况下，你只能使用其中的一个，比如：</p><ul>\n<li>\n<p>在C++重载操作符的情况下，你就很难使用错误返回码，只能抛异常；</p>\n</li>\n<li>\n<p>异常捕捉只能在同步的情况下使用，在异步模式下，抛异常这事就不行了，需要通过检查子进程退出码或是回调函数来解决；</p>\n</li>\n<li>\n<p>在分布式的情况下，调用远程服务只能看错误返回码，比如HTTP的返回码。</p>\n</li>\n</ul><p>所以，在大多数情况下，我们会混用这两种报错的方式，有时候，我们还会把异常转成错误码（比如HTTP的RESTful API），也会把错误码转成异常（比如对系统调用的错误）。</p><p>总之，“报错的类型”和 “错误处理”是紧密相关的，错误处理方法多种多样，而且会在不同的层面上处理错误。有些底层错误就需要自己处理掉（比如：底层模块会自动重建网络连接），而有一些错误需要更上层的业务逻辑来处理（比如：重建网络连接不成功后只能让上层业务来处理怎么办？降级使用本地缓存还是直接报错给用户？）。</p><p>所以，不同的错误类型再加上不同的错误处理会导致我们代码组织层面上的不同，从而会让我们使用不同的方式。也就是说，<strong>使用错误码还是异常捕捉主要还是看我们的错误处理流程以及代码组织怎么写会更清楚</strong>。</p><p>通过学习今天的内容，你是不是已经对如何处理程序中的错误，以及在不同情况下怎样选择错误处理方法，有了一定的认知和理解呢？然而，这些知识和经验仅在同步编程世界中适用。因为在异步编程世界里，被调用的函数是被放到另外一个线程里运行的，所以本文中的两位主角，不管是错误返回码，还是异常捕捉，都难以发挥其威力。</p><p>那么异步编程世界中是如何做错误处理的呢？我们将在下节课中讨论。同时，还会给你讲讲我在实战中总结出来的错误处理最佳实践。</p>","neighbors":{"left":{"article_title":"10 | 如何成为一个大家愿意追随的Leader？","id":297},"right":{"article_title":"12 | 程序中的错误处理：异步编程以及我的最佳实践","id":693}},"comments":[{"had_liked":false,"id":411,"user_name":"精卫鸟","can_delete":false,"product_type":"c1","uid":1000001,"ip_address":"","ucode":"0AC0E3AE9759A6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/41/75cb08b6.jpg","comment_is_top":false,"comment_ctime":1510020998,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"598510475142","product_id":100002201,"comment_content":"隐式异常也不要显示的忽略吧，至少记录一条日志，不然会造成异常黑洞。之前帮同事找一个线上小概率问题，所有的日志和异常检测都抓不到，最后对全部进程一起strace，才发现是他catch了异常，啥都没做就return了...<br><br>我们后来揍了丫的","like_count":140,"discussions":[{"author":{"id":1140080,"avatar":"https://static001.geekbang.org/account/avatar/00/11/65/70/7e137498.jpg","nickname":"FOCUS","note":"","ucode":"DFE3078B632026","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559426,"discussion_content":"不要显示的忽略？意思是 不要在 catch 设置为空代码？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648758595,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2556212,"avatar":"https://static001.geekbang.org/account/avatar/00/27/01/34/08d06025.jpg","nickname":"有梦想的咸鱼呀","note":"","ucode":"E494AD9C6630C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555595,"discussion_content":"枪毙1小时","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646984973,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2336828,"avatar":"https://static001.geekbang.org/account/avatar/00/23/a8/3c/b86ee246.jpg","nickname":"7+1","note":"","ucode":"83E44B0713874A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411819,"discussion_content":"哈哈哈，我之前也这么干过，把异常catch住，就没做任何处理了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636011587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1517775,"avatar":"https://static001.geekbang.org/account/avatar/00/17/28/cf/7d4d09e0.jpg","nickname":"小虎","note":"","ucode":"604E218F18FD44","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24651,"discussion_content":"？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570221958,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1282813,"avatar":"https://static001.geekbang.org/account/avatar/00/13/92/fd/6b0e58fe.jpg","nickname":"文刂 氵共 超","note":"","ucode":"C2CE1512D23012","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1517775,"avatar":"https://static001.geekbang.org/account/avatar/00/17/28/cf/7d4d09e0.jpg","nickname":"小虎","note":"","ucode":"604E218F18FD44","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":133945,"discussion_content":"？？？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579002565,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":24651,"ip_address":""},"score":133945,"extra":""}]}]},{"had_liked":false,"id":657,"user_name":"左耳朵","can_delete":false,"product_type":"c1","uid":1001269,"ip_address":"","ucode":"8A4741D677702E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/47/35/89726f5f.jpg","comment_is_top":false,"comment_ctime":1511236369,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"203374699281","product_id":100002201,"comment_content":"@ stone扎西华丹，是我给极客时间出难题了，我的好些文章里有好多代码，有的会有好些图片，有的会有好些数学公式，这类文章不但都非常难配上语音，而且可能在手机端的排版都会很有问题，难为极客时间的编辑、产品和技术了，这个还望能理解了（后面的文章这样的事你会看到很多）","like_count":48,"discussions":[{"author":{"id":1360712,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c3/48/3a739da6.jpg","nickname":"天草二十六","note":"","ucode":"3165EE3007527B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":221884,"discussion_content":"难题，音频改视频就好些了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586075391,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":410,"user_name":"majun","can_delete":false,"product_type":"c1","uid":1010924,"ip_address":"","ucode":"0F629302A12CC3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6c/ec/dcd555be.jpg","comment_is_top":false,"comment_ctime":1510019660,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"151833875020","product_id":100002201,"comment_content":"期望听您对进程、线程、多进程、多线程的讲解，谢谢！","like_count":36},{"had_liked":false,"id":408,"user_name":"xfly","can_delete":false,"product_type":"c1","uid":1003641,"ip_address":"","ucode":"0844882393360D","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM4JMC0xCTtze8l3hPTAqCoTSoVOQ0ozHycibiaUv1ojIbhl0NqBnC4amVIKrbcDZyYR0Ciba3z7EYMZA/132","comment_is_top":false,"comment_ctime":1510018599,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"65934528039","product_id":100002201,"comment_content":"对于上面三种错误的种类来说，程序中的错误，可能用异常捕捉会比较合适；用户的错误，用返回码比较合适；而资源类的错误，要分情况，是用异常捕捉还是用返回值，要看这事是不应该出现的，还是经常出现的。<br>—\u0000—<br>这三种分类和处置方式比较赞同。<br>但实际在多人协作项目，或大型项目中多方技术人员要在这个层面理解达成一致不是那么容易的事情。如果依赖于解决架构负债，架构升级来优化，驱动力又似乎不足。","like_count":15,"discussions":[{"author":{"id":1140080,"avatar":"https://static001.geekbang.org/account/avatar/00/11/65/70/7e137498.jpg","nickname":"FOCUS","note":"","ucode":"DFE3078B632026","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559427,"discussion_content":"你们都是如何处理的呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648758668,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177162,"user_name":"大石头","can_delete":false,"product_type":"c1","uid":1076077,"ip_address":"","ucode":"B8C8BB45616D94","user_header":"https://static001.geekbang.org/account/avatar/00/10/6b/6d/65e3b779.jpg","comment_is_top":false,"comment_ctime":1581306656,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"61710848800","product_id":100002201,"comment_content":"“错误处理”真的是一个在实践中既简单又不简单的事情。说他简单呢，是因为，每个人在学写代码的时候都会学到一些错误处理的方法：<br><br>* 检查一个系统提供给你的错误码，这种我只在 C Bash里碰到过<br>* 返回码，各种语言都可以<br>* 多返回值 go python 都可以<br>* try catch finally  最具代表性的Java<br><br>不论哪种处理方法，其实学习的时候都不会觉得很难理解，讲解这类问题的章节也比较短。说这事不简单是因为放到实践中问题就多了：<br><br>* 资源回收。这个问题是在C语言里必须妥善处理的问题，到了C++，有了对象其实已经有了很好的解决<br>* 返回码是否可忽略。只要你是可以忽略的，那么人类的本性就会by default的把它忽略，不管你是系统的错误码，还是那种函数直接返回的错误码。这种在 Java 里解决的比较好，你不能隐式忽略exception的存在。<br>* 错误返回码 vs 异常捕捉 到底用哪个？<br><br>最后这个问题确实有争议，博主的首先观点是**“不希望发生的用异常捕捉，可能会发生的用返回码”**。但我站在业务中工程实践的角度来说有些不一样的理解。“不希望发生的事”，有的是你能处理的了的，有的是你处理不了的。对于你能处理的了的，你（不管用什么方式）能检测到并应加以处理就可以了，对于你处理不了的，你除了抛异常似乎也没什么办法了；“可能发生的”也分你能处理的了的，和你处理不了的。比如说，你自己维护了一个函数，你的调用者给你发了一串注入攻击参数（这个算可能发生的）。假如你出处理不了，那么结果可能是攻击者成功骗过你拿到了那想要的返回数据，也可能是你的程序被搞挂（你抛了异常）；当然，你也可能这个攻击你能够识别，那么处理方法是你要告知调用者参数错误，你可以用返回码也可以用异常，这个事情可以取决于很多因素，比如：<br><br>* 调用者的代码是你自己维护的，你想追求代码的可读性好，愿意用异常<br>* 你封装的函数其实是一个微服务，别人是通过HTTP来调用你的，那你只能跟调用者定义一套返回码了<br>* 调用者其实是UI界面的操作者，那么其实 返回码 和 异常 可以都没有，但你却要给一个UI错误提示<br><br>所以，基于以上的讨论，个人观点是， 对于你处理不了的，抛异常就好了；如果是你能处理的异常，那么要看这个异常的下游要交给谁：<br><br>* 交给代码处理的，可以用异常，也可以用错误码，取决于团队文化<br>* 交给微服务的，只能用错误码。如果是RPC的话，可以用异常，但是调用者要能识别你抛出的异常就要经常更新异常的定义，这个在实践中很低效<br>* 交给用户处理的，要讲的是用户体验好。用户看不见的log你打了就可以了","like_count":15,"discussions":[{"author":{"id":1116159,"avatar":"https://static001.geekbang.org/account/avatar/00/11/07/ff/b3fe9903.jpg","nickname":"lisimmy","note":"","ucode":"288507E785B433","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580176,"discussion_content":"讲技术，不要太绝对，xxx是好的实践，并非只能怎样怎样……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657955583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1140080,"avatar":"https://static001.geekbang.org/account/avatar/00/11/65/70/7e137498.jpg","nickname":"FOCUS","note":"","ucode":"DFE3078B632026","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559428,"discussion_content":"太强了吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648759005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":4505,"user_name":"yun","can_delete":false,"product_type":"c1","uid":1054906,"ip_address":"","ucode":"3727BF0E566A76","user_header":"https://static001.geekbang.org/account/avatar/00/10/18/ba/fb86482f.jpg","comment_is_top":false,"comment_ctime":1522156998,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"40176862662","product_id":100002201,"comment_content":"&gt;异常捕捉的确是对性能有影响的，那是因为一旦异常被抛出，函数也就跟着 return 了。而程序在执行需要处理函数栈上的上下文，这会导致性能变得很慢，尤其是函数栈比较深的时候<br><br>异常抛出和不抛出，函数栈的深度应该差不多吧？函数栈的上下文会有啥不同？","like_count":9,"discussions":[{"author":{"id":1022282,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/99/4a/bdf26d5c.jpg","nickname":"石头汤","note":"","ucode":"45E4578E54F585","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302069,"discussion_content":"抛异常的时候，需要读取线程调用桟，也就是上下文，这个是阻塞的，调用桟越深，需读取的数据就越多，所以越耗时。并不是说抛异常会导致调用栈变深","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1598779265,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2002555,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/8e/7b/701c741f.jpg","nickname":"难得自然萌","note":"","ucode":"73C86B48236104","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302727,"discussion_content":"抛出异常应该会导致程序回滚调用栈一直到最先到达的catch点","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599014665,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50049,"user_name":"LEI","can_delete":false,"product_type":"c1","uid":1117944,"ip_address":"","ucode":"EFA18B0804160F","user_header":"https://static001.geekbang.org/account/avatar/00/11/0e/f8/309dcba5.jpg","comment_is_top":false,"comment_ctime":1544850714,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"23019687194","product_id":100002201,"comment_content":"不是java的示例哦，java没有指针一说，看是能看明白意思，示例看着有点感觉自己门外汉，像是自己在学英语，然后讲解的人用另一门类似的语言在解释英语的意思一样，买课程只看了目录，作者简介写了骨灰级程序员，我以为是自己熟悉的java的讲解呢，因为自己是个半路出家的程序员，所以对c还是不太了解，今天只是选了这篇学习，不知道其他的文章是不是也都是C代码做示例讲解的哦，如果都是C的话，学起来就别扭了","like_count":5,"discussions":[{"author":{"id":1978495,"avatar":"","nickname":"吴燕君","note":"","ucode":"00FD7FAF69223A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282797,"discussion_content":"C/C++，go语言吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592095363,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37194,"user_name":"徐超军","can_delete":false,"product_type":"c1","uid":1103035,"ip_address":"","ucode":"80F0A590E9D4A9","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/bb/1deafcbf.jpg","comment_is_top":false,"comment_ctime":1541480226,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23016316706","product_id":100002201,"comment_content":"我们大不部分都是定义自己的异常处理类，然后各种异常都定义好错误码，返回给调用者，这样很清晰的就知道什么问题了","like_count":5},{"had_liked":false,"id":61649,"user_name":"阿仁🇨🇳","can_delete":false,"product_type":"c1","uid":1372075,"ip_address":"","ucode":"5B6D03774C8B7D","user_header":"https://static001.geekbang.org/account/avatar/00/14/ef/ab/b1bf664c.jpg","comment_is_top":false,"comment_ctime":1547758573,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18727627757","product_id":100002201,"comment_content":"我是个零基础学员，我表示可以看完一遍，但是啥懂不懂 目前就知道以后遇到类似错误纠正的事，那我就再来这里重新查看，寻找答案。哈哈，这算是收获吗？","like_count":4},{"had_liked":false,"id":412,"user_name":"皮特尔","can_delete":false,"product_type":"c1","uid":1017161,"ip_address":"","ucode":"313862C91DD325","user_header":"https://static001.geekbang.org/account/avatar/00/0f/85/49/585c69c4.jpg","comment_is_top":false,"comment_ctime":1510021168,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"18689890352","product_id":100002201,"comment_content":"赞！迫不及待要看下一篇了。","like_count":4},{"had_liked":false,"id":39317,"user_name":"呆呆","can_delete":false,"product_type":"c1","uid":1277056,"ip_address":"","ucode":"70F67B85C8C0BA","user_header":"https://static001.geekbang.org/account/avatar/00/13/7c/80/825fd9c0.jpg","comment_is_top":false,"comment_ctime":1542247369,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14427149257","product_id":100002201,"comment_content":"错误码、异常处理都是在不同场景下的结果，同步可直接获得，异步不能","like_count":3},{"had_liked":false,"id":490,"user_name":"stone扎西华丹","can_delete":false,"product_type":"c1","uid":1007731,"ip_address":"","ucode":"9BA86AED328B21","user_header":"https://static001.geekbang.org/account/avatar/00/0f/60/73/deb6a944.jpg","comment_is_top":false,"comment_ctime":1510569475,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14395471363","product_id":100002201,"comment_content":"货不对板，我们订的时候，看到的可是一个音频产品。","like_count":3,"discussions":[{"author":{"id":1640930,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/MOdHDtqwCDfU2sicYMNh7BhcqWxrn9ROzsqCANwkqq0icKAATiaibEKwxib1kCc7tuBia5TCZq28sZicQc9Uwh7IM68Dg/132","nickname":"Geek_c8b9ac","note":"","ucode":"90AB8AD4894D66","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7285,"discussion_content":"应该是考量到这单元代码偏多，并不适合只靠听的，学习效果不佳，所以才以文字为主吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567473962,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":413,"user_name":"郎哲","can_delete":false,"product_type":"c1","uid":1007926,"ip_address":"","ucode":"EE2F5F061E2F7A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/61/36/343a8ef8.jpg","comment_is_top":false,"comment_ctime":1510026591,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14394928479","product_id":100002201,"comment_content":"不用的语言不同的方式处理错误。Elang 虽有catch，几乎用不到，直接返回值。假设传进来的一定正确，霸道一点不正确请修改正确再传，错误非常容易定位用了catch反而多余隐藏bug，勿隐藏应今早发现今早解决。Go 返回error嵌套多了确实蛋疼不得多写好多if，Java 离了try catch 活不下去。","like_count":3},{"had_liked":false,"id":82967,"user_name":"卫什么","can_delete":false,"product_type":"c1","uid":1112217,"ip_address":"","ucode":"CC4FC09FF4F340","user_header":"https://static001.geekbang.org/account/avatar/00/10/f8/99/b9978b44.jpg","comment_is_top":false,"comment_ctime":1554361180,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10144295772","product_id":100002201,"comment_content":"1. 通常而言，我们对于在程序中，自己可以预计到自己不期望出现的问题，而且能在问题出现后有替代解决方案的时候，我们就用异常。 <br>比如当我们处理图片时，我们希望图片的处理是成功的，但是不希望图片处理是失败的。当出现失败时，我们直接在程序中指定重新处理图片的程序，再次运行。<br><br>2. 对于无法修复，无法提供解决方案的问题， 应该使用错误码。 比如用户输入信息的处理，无法修复网络资源的失败","like_count":2},{"had_liked":false,"id":24498,"user_name":"meijing0114","can_delete":false,"product_type":"c1","uid":1012416,"ip_address":"","ucode":"B349D33E2F3ECC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/72/c0/b09911a0.jpg","comment_is_top":false,"comment_ctime":1537084393,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10127018985","product_id":100002201,"comment_content":"请问所谓对于异常的多态性的catch是指什么呢？是指代码catch Exception对象，实际抛出的可能是ioexception这类吗？","like_count":2},{"had_liked":false,"id":409,"user_name":"李帅龙","can_delete":false,"product_type":"c1","uid":1006199,"ip_address":"","ucode":"4D5B2E8D3ED070","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5a/77/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1510019083,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10099953675","product_id":100002201,"comment_content":"还有一种rust的方式","like_count":2},{"had_liked":false,"id":404,"user_name":"琚致远","can_delete":false,"product_type":"c1","uid":1003012,"ip_address":"","ucode":"F4AA06D5C2AE03","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/04/68eb84d0.jpg","comment_is_top":false,"comment_ctime":1510012846,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10099947438","product_id":100002201,"comment_content":"早上好～","like_count":2},{"had_liked":false,"id":298776,"user_name":"chenssy","can_delete":false,"product_type":"c1","uid":1074196,"ip_address":"","ucode":"CB5AF27229E2D1","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/14/c980c239.jpg","comment_is_top":false,"comment_ctime":1624324558,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5919291854","product_id":100002201,"comment_content":"作为 Java 程序员我一直都不是很赞同利用返回码来处理程序异常，比如0000是成功，0001是***异常，0002是***异常，这样实在是太难控制了，而且项目是多人维护，如果某天有个小伙伴返回了另外一种编码，而你又忘记处理了，那不是很尴尬。 <br>我还是很赞同将异常分为楼主将异常分为三种：事实上我们项目组也在这样做。对于检验类的异常，我们区分更加细致，比如该异常是否需要打印日志？因为我们系统里面所有的error级别日志都会告警，所以会尽量控制系统里面的错误日志输出。","like_count":1},{"had_liked":false,"id":224857,"user_name":"罗杰.菲の樂","can_delete":false,"product_type":"c1","uid":2016408,"ip_address":"","ucode":"63590706846EEA","user_header":"https://static001.geekbang.org/account/avatar/00/1e/c4/98/9c7a1a23.jpg","comment_is_top":false,"comment_ctime":1591577737,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5886545033","product_id":100002201,"comment_content":"文中提到的在异步编程世界里，被调用的函数是被放到另外一个线程里运行的，所以本文中的两位主角，不管是错误返回码，还是异常捕捉，都难以发挥其威力。<br><br>笔者认为C#的 async await pattern 就解决了异常抛出和捕获的问题，可以直接使用try catch，不知我的想法是否正确？","like_count":1},{"had_liked":false,"id":212678,"user_name":"null.shaw","can_delete":false,"product_type":"c1","uid":1606503,"ip_address":"","ucode":"2CA3AD0A0F85A3","user_header":"https://static001.geekbang.org/account/avatar/00/18/83/67/ca364a3c.jpg","comment_is_top":false,"comment_ctime":1588173782,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5883141078","product_id":100002201,"comment_content":"《代码大全2》里有部分是专门讲这个的，很详细。","like_count":1},{"had_liked":false,"id":211372,"user_name":"free","can_delete":false,"product_type":"c1","uid":1082823,"ip_address":"","ucode":"9B65E5131438D0","user_header":"https://static001.geekbang.org/account/avatar/00/10/85/c7/5347b551.jpg","comment_is_top":false,"comment_ctime":1587953891,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5882921187","product_id":100002201,"comment_content":"C# await异步函数可以捕获其中的异常","like_count":1,"discussions":[{"author":{"id":1503506,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f1/12/7dac30d6.jpg","nickname":"你为啥那么牛","note":"","ucode":"1ABC604A54A8F6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293844,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595686487,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72221,"user_name":"恋空","can_delete":false,"product_type":"c1","uid":1237876,"ip_address":"","ucode":"F2B66D75B113FB","user_header":"https://static001.geekbang.org/account/avatar/00/12/e3/74/34917b7d.jpg","comment_is_top":false,"comment_ctime":1551536707,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5846504003","product_id":100002201,"comment_content":"strtol()函数处理错误的那段代码没看懂是什么意思，能仔细说说吗","like_count":1,"discussions":[{"author":{"id":1017031,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/c7/d72792de.jpg","nickname":"清平","note":"","ucode":"DB609A12CCF8C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38978,"discussion_content":"\nlong strtol(const char *restrict str, char **restrict endptr, int base);\n\n第一个参数str 是传入的参数，第二个参数endptr是指针的指针，既是入参也是出参，用作error message的返回。这么做是因为c语言不支持多个参数返回，所以作者又举了go语言的例子。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1571874548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1237876,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e3/74/34917b7d.jpg","nickname":"恋空","note":"","ucode":"F2B66D75B113FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1017031,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/c7/d72792de.jpg","nickname":"清平","note":"","ucode":"DB609A12CCF8C3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":153019,"discussion_content":"好的，谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580015588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":38978,"ip_address":""},"score":153019,"extra":""}]}]},{"had_liked":false,"id":64051,"user_name":"夏","can_delete":false,"product_type":"c1","uid":1158156,"ip_address":"","ucode":"2DE213960503A8","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/0c/f3e37765.jpg","comment_is_top":false,"comment_ctime":1548649474,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"5843616770","product_id":100002201,"comment_content":"这些代码例子错漏百出","like_count":1,"discussions":[{"author":{"id":1017031,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/c7/d72792de.jpg","nickname":"清平","note":"","ucode":"DB609A12CCF8C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38971,"discussion_content":"这位朋友的答复，感觉可以作为一种只返回errorcode，没返回errormsg的例子。而且还没有error code list可以查","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1571873839,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1449415,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/gd55TKgxuTe29tRP8ZeGLc2njDG1m5N7JQ7swKNevMCiaYaUGu8yicUL2Jw8oOMan6yBAicGQtc2HEeHssWLeQn9Q/132","nickname":"小鲸鱼","note":"","ucode":"C94B4AF9988892","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2232,"discussion_content":"哪里错了？能指出来吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563375179,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29555,"user_name":"weiguozhihui","can_delete":false,"product_type":"c1","uid":1052132,"ip_address":"","ucode":"D59087307CFC91","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/CibnyMEyuo4aKCjEzq3t8CRLbiatiaNCmSsTGlhdHaMseBibB2CK2Dyu4TSa7AVREseibicWUnSicp78kWP2gb66u7ajw/132","comment_is_top":false,"comment_ctime":1538438558,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5833405854","product_id":100002201,"comment_content":"抛出异常之所以比较慢，有一部分的原因：异常也是一个对象，当产生一个异常时，需要生成一个异常对象（这个生成的异常对象肯定不是存放在栈上，应该可能是存放在堆上），并且将这个异常对象层层往上传递。并且在异常的产生与传递过程中至少需要一次拷贝构造，所以抛出异常要比返回错误码要低效一些。","like_count":1},{"had_liked":false,"id":17275,"user_name":"krugle","can_delete":false,"product_type":"c1","uid":1045770,"ip_address":"","ucode":"60A7D9189C01BE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/0a/077b9922.jpg","comment_is_top":false,"comment_ctime":1532533459,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5827500755","product_id":100002201,"comment_content":"之前网上查这方面的资料，这次在这里看到，太实用了","like_count":1},{"had_liked":false,"id":13155,"user_name":"周孟","can_delete":false,"product_type":"c1","uid":1062026,"ip_address":"","ucode":"2DD1B5199F1BC1","user_header":"https://static001.geekbang.org/account/avatar/00/10/34/8a/08a79d38.jpg","comment_is_top":false,"comment_ctime":1529413370,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5824380666","product_id":100002201,"comment_content":"对于返回错误码的方式是否定义结构体或是类同时包含错误码和错误消息会更好一些，特别是一些业务验证或输入问题上","like_count":1},{"had_liked":false,"id":3762,"user_name":"Wilson_qqs","can_delete":false,"product_type":"c1","uid":1044241,"ip_address":"","ucode":"53169919DD5A84","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ef/11/dd71f70f.jpg","comment_is_top":false,"comment_ctime":1520517939,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5815485235","product_id":100002201,"comment_content":"赞👍","like_count":1},{"had_liked":false,"id":346879,"user_name":"panhf","can_delete":false,"product_type":"c1","uid":2835968,"ip_address":"","ucode":"DBA98290E17503","user_header":"https://static001.geekbang.org/account/avatar/00/2b/46/00/686bb0c4.jpg","comment_is_top":false,"comment_ctime":1653490344,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653490344","product_id":100002201,"comment_content":"但是，try - catch - finally 有个致命的问题，那就是在异步运行的世界里的问题。try 语句块里的函数运行在另外一个线程中，其中抛出的异常无法在调用者的这个线程中被捕捉。这个问题就比较大了。<br>方便详细讲解下实例嘛<br>","like_count":0},{"had_liked":false,"id":340334,"user_name":"FOCUS","can_delete":false,"product_type":"c1","uid":1140080,"ip_address":"","ucode":"DFE3078B632026","user_header":"https://static001.geekbang.org/account/avatar/00/11/65/70/7e137498.jpg","comment_is_top":false,"comment_ctime":1648759435,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648759435","product_id":100002201,"comment_content":"需要再次重读","like_count":0},{"had_liked":false,"id":308880,"user_name":"闻人","can_delete":false,"product_type":"c1","uid":1102584,"ip_address":"","ucode":"E4970C0D944243","user_header":"https://static001.geekbang.org/account/avatar/00/10/d2/f8/d5006178.jpg","comment_is_top":false,"comment_ctime":1629852295,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1629852295","product_id":100002201,"comment_content":"学习小结：错误类型主要有三类：程序错误，用户错误，资源错误。错误处理有两类：响应码和抛异常。如何选择结合具体场景比较合适！<br>思考：原觉得try-catch-finaily 不那么优雅，原来还有一层 正常执行-异常处理-资源清理的模式，瞬间高大上","like_count":0},{"had_liked":false,"id":300484,"user_name":"Geek_216fd5","can_delete":false,"product_type":"c1","uid":1602049,"ip_address":"","ucode":"EA6804E9E974B3","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLb5UK2u6RyS48ia8H2lUSlUyQEaBiclDlqpbQUWqTWeuf3Djl3ruHRN3U37GXYuWAfAW5d1xkm6F7w/132","comment_is_top":false,"comment_ctime":1625193849,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625193849","product_id":100002201,"comment_content":"if (endptr == str) {    fprintf(stderr, &quot;No digits were found\\n&quot;);    exit(EXIT_FAILURE);}<br><br>这里，str 是在哪儿定义的 ？ 难道是 in_str ?","like_count":0},{"had_liked":false,"id":277212,"user_name":"充值一万","can_delete":false,"product_type":"c1","uid":1519086,"ip_address":"","ucode":"1B4B3AEFA9C8C2","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epRK5v3IkvSfjicKNKlRLE2nTQUowhMvQkwWWWUSESat8EBbcPvMk4aAjZHGcsE5DCibES9WicHcC9Qw/132","comment_is_top":false,"comment_ctime":1612317378,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612317378","product_id":100002201,"comment_content":"golang的错误处理，是在严格要求编程者仔细处理每个步骤中可能的异常，虽然满屏if err，但我发现程序的健壮性有极大提升。","like_count":0},{"had_liked":false,"id":260835,"user_name":"Bug? Feature!","can_delete":false,"product_type":"c1","uid":1164531,"ip_address":"","ucode":"F8FA8A0094FBA0","user_header":"https://static001.geekbang.org/account/avatar/00/11/c4/f3/92f654f1.jpg","comment_is_top":false,"comment_ctime":1605142201,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605142201","product_id":100002201,"comment_content":"在同步编程世界里，使用错误码还是异常捕捉呢？<br>主要还是看我们的错误处理流程以及代码组织怎么写会更清楚。","like_count":0},{"had_liked":false,"id":246900,"user_name":"bigzuo","can_delete":false,"product_type":"c1","uid":1224554,"ip_address":"","ucode":"448C258D31A8A6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/RQdib68D7dsoFlYXOweiaPqLrcyn2jD6DCGnz8nc2VFmhmX0bpGTeSrVM5M9Qs7ibIInAmt5MeLcpcNja5YjyZCIg/132","comment_is_top":false,"comment_ctime":1599527021,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599527021","product_id":100002201,"comment_content":"我的想法：需要自己解决或者处理的，就抛出具体异常信息，方便清楚问题原因，进行对应解决。别人不需要关注异常详情，只需要关注异常原因或结果的，直接用返回码更合适。","like_count":0},{"had_liked":false,"id":246039,"user_name":"DayDayUp","can_delete":false,"product_type":"c1","uid":1610552,"ip_address":"","ucode":"9C53659518AB74","user_header":"https://static001.geekbang.org/account/avatar/00/18/93/38/71615300.jpg","comment_is_top":false,"comment_ctime":1599141070,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1599141070","product_id":100002201,"comment_content":"刚接触到GO语言时，在夸其语言简单易学的同时，发现几乎所有的函数都有err的判断，因此这样错误处理的太多了，就麻木了，有的时候我就直接用_来接返回的错误码，鸵鸟式的逃避，感觉为什么没有一种标准来衡量这些错误处理方法，量化一下，自己估计就不会这么迷茫了。","like_count":0},{"had_liked":false,"id":237133,"user_name":"你为啥那么牛","can_delete":false,"product_type":"c1","uid":1503506,"ip_address":"","ucode":"1ABC604A54A8F6","user_header":"https://static001.geekbang.org/account/avatar/00/16/f1/12/7dac30d6.jpg","comment_is_top":false,"comment_ctime":1595686997,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595686997","product_id":100002201,"comment_content":"我一般直接在最顶层try...catch...。<br>返回状态码0或1，表示失败或正确。描述性文字message。<br>而我的同事，会在各个层，随机异常捕获，大部分情况，不会反悔错误信息，直接返回null。<br>😀😀😀我也很无奈，说了几遍也不听。","like_count":0},{"had_liked":false,"id":227729,"user_name":"陈狄","can_delete":false,"product_type":"c1","uid":2011954,"ip_address":"","ucode":"456F00EB2EB43D","user_header":"https://static001.geekbang.org/account/avatar/00/1e/b3/32/0ee78a1a.jpg","comment_is_top":false,"comment_ctime":1592466271,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592466271","product_id":100002201,"comment_content":"C++primer中对 对象的定义：对象是指一块能存储数据并具有某种类型的内存空间一个对象a，它有值和地址&amp;a，运行程序时，计算机会为该对象分配存储空间，来存储该对象的值，我们通过该对象的地址，来访问存储空间中的值指针p也是对象，它同样有地址&amp;p和存储的值p，只不过，p存储的数据类型是数据的地址。如果我们要以p中存储的数据为地址，来访问对象的值，则要在p前加解引用操作符&quot;*&quot;,即*p。","like_count":0},{"had_liked":false,"id":211274,"user_name":"simonren","can_delete":false,"product_type":"c1","uid":1974906,"ip_address":"","ucode":"DFB59C705310C2","user_header":"","comment_is_top":false,"comment_ctime":1587944754,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587944754","product_id":100002201,"comment_content":"传统的错误检查，处理错误最直接的方式是通过错误码，这也是传统的方式，在过程式语言中通常都是用这样的方式处理错误的。比如 Go 语言通过多返回值来解决这个问题，Go 语言的很多函数都会返回 result, err 两个值。<br>错误返回码 vs 异常捕捉<br>资源的错误。当我们的代码去请求一些资源时导致的错误，比如打开一个没有权限的文件，写文件时出现的写错误，发送文件到网络端发现网络故障的错误，等等。这一类错误属于程序运行环境的问题。对于这类错误，有的我们可以处理，有的我们则无法处理。比如，内存耗尽、栈溢出或是一些程序运行时关键性资源不能满足等等这些情况，我们只能停止运行，甚至退出整个程序。<br>程序的错误。比如：空指针、非法参数等。这类是我们自己程序的错误，我们要记录下来，写入日志，最好触发监控系统报警。<br>用户的错误。比如：Bad Request、Bad Format 等这类由用户不合法输入带来的错误。这类错误基本上是在用户的 API 层上出现的问题。比如，解析一个 XML 或 JSON 文件，或是用户输入的字段不合法之类的。对于这类问题，我们需要向用户端报错，让用户自己处理修正他们的输入或操作。然后，我们正常执行，但是需要做统计，统计相应的错误率，这样有利于我们改善软件或是侦测是否有恶意的用户请求。<br>对于我们并不期望会发生的事，我们可以使用异常捕捉；对于我们觉得可能会发生的事，使用返回码。","like_count":0},{"had_liked":false,"id":211013,"user_name":"Geek_CK2020","can_delete":false,"product_type":"c1","uid":1961826,"ip_address":"","ucode":"5DF4BE058F5A58","user_header":"https://static001.geekbang.org/account/avatar/00/1d/ef/62/87d9ef62.jpg","comment_is_top":false,"comment_ctime":1587881335,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587881335","product_id":100002201,"comment_content":"深入浅出的原则性建议。我也更喜欢try，catch，finally的模式","like_count":0},{"had_liked":false,"id":210924,"user_name":"林","can_delete":false,"product_type":"c1","uid":1128807,"ip_address":"","ucode":"B6317F70D3D31D","user_header":"https://static001.geekbang.org/account/avatar/00/11/39/67/e1ef109a.jpg","comment_is_top":false,"comment_ctime":1587865887,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1587865887","product_id":100002201,"comment_content":"最后的解决方案和我平时工作用到的一样，对于一些不希望发生的错误用异常捕获，用户的错误操作返回错误码并加提示信息提示用户正确的使用系统","like_count":0},{"had_liked":false,"id":210920,"user_name":"浮生醉","can_delete":false,"product_type":"c1","uid":1783354,"ip_address":"","ucode":"7549E41BD65511","user_header":"https://static001.geekbang.org/account/avatar/00/1b/36/3a/335db90a.jpg","comment_is_top":false,"comment_ctime":1587865333,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587865333","product_id":100002201,"comment_content":"很早之前学习的时候被告诉try..catch会影响程序性能，不让try...catch大段代码，其实只是担心大段代码里有过深的调用把，如果没有的话，其实try...catch一行和多行没什么区别","like_count":0},{"had_liked":false,"id":210628,"user_name":"小人物大希望","can_delete":false,"product_type":"c1","uid":1945605,"ip_address":"","ucode":"8EF313AA26D4B8","user_header":"https://static001.geekbang.org/account/avatar/00/1d/b0/05/c9da834e.jpg","comment_is_top":false,"comment_ctime":1587799437,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1587799437","product_id":100002201,"comment_content":"对于Go语言来说，就可以考虑：<br>对于不期望发生的错误，直接panic然后由上层recover。<br>对于可能发生的错误，用err != nil判断","like_count":0},{"had_liked":false,"id":210622,"user_name":"蓝猫","can_delete":false,"product_type":"c1","uid":1128676,"ip_address":"","ucode":"A2E11FF854013C","user_header":"https://static001.geekbang.org/account/avatar/00/11/38/e4/17ffa30b.jpg","comment_is_top":false,"comment_ctime":1587797391,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587797391","product_id":100002201,"comment_content":"Java开发过程中有时出现很多的异常处理代码，真正业务处理代码很少的情况（特别调用反射方法时），有什么好的处理方法","like_count":0},{"had_liked":false,"id":210393,"user_name":"Geek_7b1383","can_delete":false,"product_type":"c1","uid":1310716,"ip_address":"","ucode":"A2F03709F77122","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLndPicaib35sSOgGib8iafFBq8B0hoBO3Bfp3QViblYQ669lRFjPD1RSX2rDibmElID00l5oWokhuZBJnw/132","comment_is_top":false,"comment_ctime":1587736012,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587736012","product_id":100002201,"comment_content":"三种错误的类型：<br>程序中的错误，可能用异常捕捉会比较合适；<br>用户的错误，用返回码比较合适；<br>资源类的错误，要分情况，是用异常捕捉还是用返回值，要看这事是不应该出现的，还是经常出现的。","like_count":0},{"had_liked":false,"id":209700,"user_name":"lubiaook","can_delete":false,"product_type":"c1","uid":1368040,"ip_address":"","ucode":"C59CD6E7DAD729","user_header":"https://static001.geekbang.org/account/avatar/00/14/df/e8/359adede.jpg","comment_is_top":false,"comment_ctime":1587602663,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587602663","product_id":100002201,"comment_content":"平常写程序 一般是异常分两种，一类是业务逻辑的异常(可预见性的) ，一类是不可预见性的异常","like_count":0},{"had_liked":false,"id":209600,"user_name":"James杠杠","can_delete":false,"product_type":"c1","uid":1110465,"ip_address":"","ucode":"E35777C58ED71C","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/XyW2GWxlmUXpgIzVqiabLD7G30ooOT2icflb7vTcFVjLKJskfYYp5Z0ehAJG9cmDGt3XpNSUu8NjbJVj2SSneZOw/132","comment_is_top":false,"comment_ctime":1587569961,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587569961","product_id":100002201,"comment_content":"对于底层的错误码不清晰或者没有返回报错情况，上层业务直接原样返回给用户的话，体验不好，目前经常遇到这种情况，并且各个底层之间的错误返回码没有一个统一的规范，导致各个端之间的解析处理时，出现各种混乱模糊现象","like_count":0},{"had_liked":false,"id":209302,"user_name":"style_月月","can_delete":false,"product_type":"c1","uid":1329116,"ip_address":"","ucode":"59489E1BDB0090","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/BJjGmy4ooNjeURBDhVeJ7EslNbyVd6jNricALVsx1QriczD2EXddKLkXxLQK02nExosCJdyfvicVcZwfpDk64iazmQ/132","comment_is_top":false,"comment_ctime":1587532035,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587532035","product_id":100002201,"comment_content":"异常及错误一般的处理方式是可预见的通过返回码，不可预见的通过直接返回error","like_count":0},{"had_liked":false,"id":184448,"user_name":"hex","can_delete":false,"product_type":"c1","uid":1757301,"ip_address":"","ucode":"B983D40DCD159F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d0/75/3e034f71.jpg","comment_is_top":false,"comment_ctime":1583317528,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583317528","product_id":100002201,"comment_content":"我是一个java程序员,我工作中的做法是一般在业务层将错误向上抛,对于可以预见的错误会给用户固定的提示或者自己做一些处理,其他就在controller中做try,catch处理并向用户返回相应的错误信息,在后台打印日志,记录错误入库.只有一些未知的处理会在业务层进行try,catch,比如发送短信,做推送.这种做法不知道是否合适","like_count":0},{"had_liked":false,"id":183925,"user_name":"亢（知行合一的路上）","can_delete":false,"product_type":"c1","uid":1347013,"ip_address":"","ucode":"958AF7C96EB9E8","user_header":"https://static001.geekbang.org/account/avatar/00/14/8d/c5/898b13b4.jpg","comment_is_top":false,"comment_ctime":1583162890,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583162890","product_id":100002201,"comment_content":"异常处理，从最初做开发的时候就用到，到现在也没什么长进，为什么呢？<br><br>异常处理在开发中是必需的，算是很基础的东西，但我为什么就总结不出来呢？<br><br>1. 好奇心不足，满足工作需要就 ok 了，没有进一步钻研；（现在好点了）<br>2. 对自己要求太低，工作的质量自己满意吗？还能如何提升？<br>3. 平时总结的太少，学的东西都是迷迷糊糊，没有系统。<br><br>陈老师一直强调基础的重要性，现在越来越认同了，赶紧补课中。<br>","like_count":1},{"had_liked":false,"id":182875,"user_name":"o0oi1i","can_delete":false,"product_type":"c1","uid":1132312,"ip_address":"","ucode":"D1F6AD4AAEAFBE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/18/293cd24d.jpg","comment_is_top":false,"comment_ctime":1582881231,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582881231","product_id":100002201,"comment_content":"打卡11","like_count":0},{"had_liked":false,"id":169892,"user_name":"DavidZ","can_delete":false,"product_type":"c1","uid":1802522,"ip_address":"","ucode":"8793EE7B5A19D9","user_header":"https://static001.geekbang.org/account/avatar/00/1b/81/1a/77c13ae1.jpg","comment_is_top":false,"comment_ctime":1578468737,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578468737","product_id":100002201,"comment_content":"有感触啊","like_count":0},{"had_liked":false,"id":143690,"user_name":"字霸杯","can_delete":false,"product_type":"c1","uid":1196816,"ip_address":"","ucode":"01CE6BD9BC4BB3","user_header":"https://static001.geekbang.org/account/avatar/00/12/43/10/f520c0db.jpg","comment_is_top":false,"comment_ctime":1571756364,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571756364","product_id":100002201,"comment_content":"干货满满～","like_count":0},{"had_liked":false,"id":129381,"user_name":"安排","can_delete":false,"product_type":"c1","uid":1260026,"ip_address":"","ucode":"F78CFA9624CAEF","user_header":"https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg","comment_is_top":false,"comment_ctime":1567123423,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567123423","product_id":100002201,"comment_content":"Linux的errno不是全局的吧","like_count":0},{"had_liked":false,"id":106750,"user_name":"Vance","can_delete":false,"product_type":"c1","uid":1174028,"ip_address":"","ucode":"D9659824312D87","user_header":"https://static001.geekbang.org/account/avatar/00/11/ea/0c/d79ae60d.jpg","comment_is_top":false,"comment_ctime":1561382985,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561382985","product_id":100002201,"comment_content":"因为在异步编程世界里，被调用的函数是被放到另外一个线程里运行的，所以本文中的两位主角，不管是错误返回码，还是异常捕捉，都难以发挥其威力。","like_count":0}]}