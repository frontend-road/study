{"id":13601,"title":"06 | 程序实体的那些事儿 （下）","content":"<p>在上一篇文章，我们一直都在围绕着可重名变量，也就是不同代码块中的重名变量，进行了讨论。</p><p>还记得吗？最后我强调，如果可重名变量的类型不同，那么就需要引起我们的特别关注了，它们之间可能会存在“屏蔽”的现象。</p><p>必要时，我们需要严格地检查它们的类型，但是怎样检查呢？咱们现在就说。</p><p><strong>我今天的问题是：怎样判断一个变量的类型？</strong></p><p>我们依然以在上一篇文章中展示过的demo11.go为基础。</p><pre><code>package main\n\nimport &quot;fmt&quot;\n\nvar container = []string{&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;}\n\nfunc main() {\n\tcontainer := map[int]string{0: &quot;zero&quot;, 1: &quot;one&quot;, 2: &quot;two&quot;}\n\tfmt.Printf(&quot;The element is %q.\\n&quot;, container[1])\n}\n</code></pre><p>那么，怎样在打印其中元素之前，正确判断变量<code>container</code>的类型？</p><h2>典型回答</h2><p>答案是使用“类型断言”表达式。具体怎么写呢？</p><pre><code>value, ok := interface{}(container).([]string)\n</code></pre><p>这里有一条赋值语句。在赋值符号的右边，是一个类型断言表达式。</p><p>它包括了用来把<code>container</code>变量的值转换为空接口值的<code>interface{}(container)</code>。</p><p>以及一个用于判断前者的类型是否为切片类型 <code>[]string</code>  的 <code>.([]string)</code>。</p><p>这个表达式的结果可以被赋给两个变量，在这里由<code>value</code>和<code>ok</code>代表。变量<code>ok</code>是布尔（bool）类型的，它将代表类型判断的结果，<code>true</code>或<code>false</code>。</p><p>如果是<code>true</code>，那么被判断的值将会被自动转换为<code>[]string</code>类型的值，并赋给变量<code>value</code>，否则<code>value</code>将被赋予<code>nil</code>（即“空”）。</p><!-- [[[read_end]]] --><p>顺便提一下，这里的<code>ok</code>也可以没有。也就是说，类型断言表达式的结果，可以只被赋给一个变量，在这里是<code>value</code>。</p><p>但是这样的话，当判断为否时就会引发异常。</p><p>这种异常在Go语言中被叫做<code>panic</code>，我把它翻译为运行时恐慌。因为它是一种在Go程序运行期间才会被抛出的异常，而“恐慌”二字是英文Panic的中文直译。</p><p>除非显式地“恢复”这种“恐慌”，否则它会使Go程序崩溃并停止。所以，在一般情况下，我们还是应该使用带<code>ok</code>变量的写法。</p><h2>问题解析</h2><p>正式说明一下，类型断言表达式的语法形式是<code>x.(T)</code>。其中的<code>x</code>代表要被判断类型的值。这个值当下的类型必须是接口类型的，不过具体是哪个接口类型其实是无所谓的。</p><p>所以，当这里的<code>container</code>变量类型不是任何的接口类型时，我们就需要先把它转成某个接口类型的值。</p><p>如果<code>container</code>是某个接口类型的，那么这个类型断言表达式就可以是<code>container.([]string)</code>。这样看是不是清晰一些了？</p><p>在Go语言中，<code>interface{}</code>代表空接口，任何类型都是它的实现类型。我在下个模块，会再讲接口及其实现类型的问题。现在你只要知道，任何类型的值都可以很方便地被转换成空接口的值就行了。</p><p>这里的具体语法是<code>interface{}(x)</code>，例如前面展示的<code>interface{}(container)</code>。</p><p>你可能会对这里的<code>{}</code>产生疑惑，为什么在关键字<code>interface</code>的右边还要加上这个东西？</p><p><span class=\"orange\">请记住，一对不包裹任何东西的花括号，除了可以代表空的代码块之外，还可以用于表示不包含任何内容的数据结构（或者说数据类型）。</span></p><p>比如你今后肯定会遇到的<code>struct{}</code>，它就代表了不包含任何字段和方法的、空的结构体类型。</p><p>而空接口<code>interface{}</code>则代表了不包含任何方法定义的、空的接口类型。</p><p>当然了，对于一些集合类的数据类型来说，<code>{}</code>还可以用来表示其值不包含任何元素，比如空的切片值<code>[]string{}</code>，以及空的字典值<code>map[int]string{}</code>。</p><p><img src=\"https://static001.geekbang.org/resource/image/b5/15/b5f16bf3ad8f416fb151aed8df47a515.png?wh=1122*460\" alt=\"\"></p><p>（类型断言表达式）</p><p>我们再向答案的最右边看。圆括号中<code>[]string</code>是一个类型字面量。所谓类型字面量，就是用来表示数据类型本身的若干个字符。</p><p>比如，<code>string</code>是表示字符串类型的字面量，<code>uint8</code>是表示8位无符号整数类型的字面量。</p><p>再复杂一些的就是我们刚才提到的<code>[]string</code>，用来表示元素类型为<code>string</code>的切片类型，以及<code>map[int]string</code>，用来表示键类型为<code>int</code>、值类型为<code>string</code>的字典类型。</p><p>还有更复杂的结构体类型字面量、接口类型字面量，等等。这些描述起来占用篇幅较多，我在后面再说吧。</p><p>针对当前的这个问题，我写了demo12.go。它是demo11.go的修改版。我在其中分别使用了两种方式来实施类型断言，一种用的是我上面讲到的方式，另一种用的是我们还没讨论过的<code>switch</code>语句，先供你参考。</p><p>可以看到，当前问题的答案可以只有一行代码。你可能会想，这一行代码解释起来也太复杂了吧？</p><p><strong>千万不要为此烦恼，这其中很大一部分都是一些基本语法和概念，你只要记住它们就好了。但这也正是我要告诉你的，一小段代码可以隐藏很多细节。面试官可以由此延伸到几个方向继续提问。这有点儿像泼墨，可以迅速由点及面。</strong></p><h2>知识扩展</h2><p><strong>问题1. 你认为类型转换规则中有哪些值得注意的地方？</strong></p><p>类型转换表达式的基本写法我已经在前面展示过了。它的语法形式是<code>T(x)</code>。</p><p>其中的<code>x</code>可以是一个变量，也可以是一个代表值的字面量（比如<code>1.23</code>和<code>struct{}{}</code>），还可以是一个表达式。</p><p>注意，如果是表达式，那么该表达式的结果只能是一个值，而不能是多个值。在这个上下文中，<code>x</code>可以被叫做源值，它的类型就是源类型，而那个<code>T</code>代表的类型就是目标类型。</p><p>如果从源类型到目标类型的转换是不合法的，那么就会引发一个编译错误。那怎样才算合法？具体的规则可参见Go语言规范中的<a href=\"https://golang.google.cn/ref/spec#Conversions\">转换</a>部分。</p><p>我们在这里要关心的，并不是那些Go语言编译器可以检测出的问题。恰恰相反，那些在编程语言层面很难检测的东西才是我们应该关注的。</p><p><strong>很多初学者所说的陷阱（或者说坑），大都源于他们需要了解但却不了解的那些知识和技巧。因此，在这些规则中，我想抛出三个我认为很常用并且非常值得注意的知识点，提前帮你标出一些“陷阱”。</strong></p><p><strong>首先，对于整数类型值、整数常量之间的类型转换，原则上只要源值在目标类型的可表示范围内就是合法的。</strong></p><p>比如，之所以<code>uint8(255)</code>可以把无类型的常量<code>255</code>转换为<code>uint8</code>类型的值，是因为<code>255</code>在[0, 255]的范围内。</p><p>但需要特别注意的是，源整数类型的可表示范围较大，而目标类型的可表示范围较小的情况，比如把值的类型从<code>int16</code>转换为<code>int8</code>。请看下面这段代码：</p><pre><code>var srcInt = int16(-255)\ndstInt := int8(srcInt)\n</code></pre><p>变量<code>srcInt</code>的值是<code>int16</code>类型的<code>-255</code>，而变量<code>dstInt</code>的值是由前者转换而来的，类型是<code>int8</code>。<code>int16</code>类型的可表示范围可比<code>int8</code>类型大了不少。问题是，<code>dstInt</code>的值是多少？</p><p>首先你要知道，整数在Go语言以及计算机中都是以补码的形式存储的。这主要是为了简化计算机对整数的运算过程。（负数的）补码其实就是原码各位求反再加1。</p><p>比如，<code>int16</code>类型的值<code>-255</code>的补码是<code>1111111100000001</code>。如果我们把该值转换为<code>int8</code>类型的值，那么Go语言会把在较高位置（或者说最左边位置）上的8位二进制数直接截掉，从而得到<code>00000001</code>。</p><p>又由于其最左边一位是<code>0</code>，表示它是个正整数，以及正整数的补码就等于其原码，所以<code>dstInt</code>的值就是<code>1</code>。</p><p>一定要记住，当整数值的类型的有效范围由宽变窄时，只需在补码形式下截掉一定数量的高位二进制数即可。</p><p>类似的快刀斩乱麻规则还有：当把一个浮点数类型的值转换为整数类型值时，前者的小数部分会被全部截掉。</p><p><strong>第二，虽然直接把一个整数值转换为一个<code>string</code>类型的值是可行的，但值得关注的是，被转换的整数值应该可以代表一个有效的Unicode代码点，否则转换的结果将会是<code>\"�\"</code>（仅由高亮的问号组成的字符串值）。</strong></p><p>字符<code>'�'</code>的Unicode代码点是<code>U+FFFD</code>。它是Unicode标准中定义的Replacement Character，专用于替换那些未知的、不被认可的以及无法展示的字符。</p><p>我肯定不会去问“哪个整数值转换后会得到哪个字符串”，这太变态了！但是我会写下：</p><pre><code>string(-1)\n</code></pre><p>并询问会得到什么？这可是完全不同的问题啊。由于<code>-1</code>肯定无法代表一个有效的Unicode代码点，所以得到的总会是<code>\"�\"</code>。在实际工作中，我们在排查问题时可能会遇到<code>�</code>，你需要知道这可能是由于什么引起的。</p><p><strong>第三个知识点是关于<code>string</code>类型与各种切片类型之间的互转的。</strong></p><p>你先要理解的是，一个值在从<code>string</code>类型向<code>[]byte</code>类型转换时代表着以UTF-8编码的字符串会被拆分成零散、独立的字节。</p><p>除了与ASCII编码兼容的那部分字符集，以UTF-8编码的某个单一字节是无法代表一个字符的。</p><pre><code>string([]byte{'\\xe4', '\\xbd', '\\xa0', '\\xe5', '\\xa5', '\\xbd'}) // 你好\n</code></pre><p>比如，UTF-8编码的三个字节<code>\\xe4</code>、<code>\\xbd</code>和<code>\\xa0</code>合在一起才能代表字符<code>'你'</code>，而<code>\\xe5</code>、<code>\\xa5</code>和<code>\\xbd</code>合在一起才能代表字符<code>'好'</code>。</p><p>其次，一个值在从<code>string</code>类型向<code>[]rune</code>类型转换时代表着字符串会被拆分成一个个Unicode字符。</p><pre><code>string([]rune{'\\u4F60', '\\u597D'}) // 你好\n</code></pre><p>当你真正理解了Unicode标准及其字符集和编码方案之后，上面这些内容就会显得很容易了。什么是Unicode标准？我会首先推荐你去它的<a href=\"http://www.unicode.org\">官方网站</a>一探究竟。</p><p><strong>问题2. 什么是别名类型？什么是潜在类型？</strong></p><p>我们可以用关键字<code>type</code>声明自定义的各种类型。当然了，这些类型必须在Go语言基本类型和高级类型的范畴之内。在它们当中，有一种被叫做“别名类型”的类型。我们可以像下面这样声明它：</p><pre><code>type MyString = string\n</code></pre><p>这条声明语句表示，<code>MyString</code>是<code>string</code>类型的别名类型。顾名思义，别名类型与其源类型的区别恐怕只是在名称上，它们是完全相同的。</p><p>源类型与别名类型是一对概念，是两个对立的称呼。别名类型主要是为了代码重构而存在的。更详细的信息可参见Go语言官方的文档<a href=\"https://golang.org/design/18130-type-alias\">Proposal: Type Aliases</a>。</p><p>Go语言内建的基本类型中就存在两个别名类型。<code>byte</code>是<code>uint8</code>的别名类型，而<code>rune</code>是<code>int32</code>的别名类型。</p><p>一定要注意，如果我这样声明：</p><pre><code>type MyString2 string // 注意，这里没有等号。\n</code></pre><p><code>MyString2</code>和<code>string</code>就是两个不同的类型了。这里的<code>MyString2</code>是一个新的类型，不同于其他任何类型。</p><p>这种方式也可以被叫做对类型的再定义。我们刚刚把<code>string</code>类型再定义成了另外一个类型<code>MyString2</code>。</p><p><img src=\"https://static001.geekbang.org/resource/image/4f/f2/4f113b74b564ad3b4b4877abca7b6bf2.png?wh=891*737\" alt=\"\"><br>\n（别名类型、类型再定义与潜在类型）</p><p>对于这里的类型再定义来说，<code>string</code>可以被称为<code>MyString2</code>的潜在类型。潜在类型的含义是，某个类型在本质上是哪个类型。</p><p>潜在类型相同的不同类型的值之间是可以进行类型转换的。因此，<code>MyString2</code>类型的值与<code>string</code>类型的值可以使用类型转换表达式进行互转。</p><p>但对于集合类的类型<code>[]MyString2</code>与<code>[]string</code>来说这样做却是不合法的，因为<code>[]MyString2</code>与<code>[]string</code>的潜在类型不同，分别是<code>[]MyString2</code>和<code>[]string</code>。另外，即使两个不同类型的潜在类型相同，它们的值之间也不能进行判等或比较，它们的变量之间也不能赋值。</p><h2>总结</h2><p>在本篇文章中，我们聚焦于类型。Go语言中的每个变量都是有类型的，我们可以使用类型断言表达式判断变量是哪个类型的。</p><p>正确使用该表达式需要一些小技巧，比如总是应该把结果赋给两个变量。另外还要保证被判断的变量是接口类型的，这可能会用到类型转换表达式。</p><p>我们在使用类型转换表达式对变量的类型进行转换的时候，会受到一套规则的严格约束。</p><p>我们必须关注这套规则中的一些细节，尤其是那些Go语言命令不会帮你检查的细节，否则就会踩进所谓的“陷阱”中。</p><p>此外，你还应该搞清楚别名类型声明与类型再定义之间的区别，以及由此带来的它们的值在类型转换、判等、比较和赋值操作方面的不同。</p><h2>思考题</h2><p>本篇文章的思考题有两个。</p><ol>\n<li>除了上述提及的那些，你还认为类型转换规则中有哪些值得注意的地方？</li>\n<li>你能具体说说别名类型在代码重构过程中可以起到哪些作用吗？</li>\n</ol><p>这些问题的答案都在文中提到的官方文档之中。</p><p><a href=\"https://github.com/hyper0x/Golang_Puzzlers\">戳此查看Go语言专栏文章配套详细代码。</a></p>","comments":[{"had_liked":false,"id":55140,"user_name":"思想的宇屋","can_delete":false,"product_type":"c1","uid":1200265,"ip_address":"","ucode":"2625878D4B078E","user_header":"https://static001.geekbang.org/account/avatar/00/12/50/89/28c62020.jpg","comment_is_top":true,"comment_ctime":1546051501,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"9.2233720942354002e+18","product_id":100013101,"comment_content":"真棒，这篇涉及到了自学go的gopher比较难涉及到的计算机基础和细节 如补码，类型转换异常时的“❓”","like_count":14},{"had_liked":false,"id":21387,"user_name":"pines","can_delete":false,"product_type":"c1","uid":1200708,"ip_address":"","ucode":"7B925605B36B4E","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/44/de7f2b98.jpg","comment_is_top":false,"comment_ctime":1535069948,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"478276439804","product_id":100013101,"comment_content":"正数的补码等于原码，负数的补码才是反码＋1","like_count":112},{"had_liked":false,"id":31255,"user_name":"陈悬高","can_delete":false,"product_type":"c1","uid":1065981,"ip_address":"","ucode":"457213A8351202","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/fd/908706cc.jpg","comment_is_top":false,"comment_ctime":1539137445,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"169042861989","product_id":100013101,"comment_content":"对于大型的代码库来说，能够重构其整体结构是非常重要的，包括修改某些 API 所属的包。大型重构应该支持一个过渡期：从旧位置和新位置获得的 API 都应该是可用的，而且可以混合使用这些 API 的引用。Go 已经为常量、函数或变量的重构提供了可行的机制，但是并不支持类型。类型别名提供了一种机制，它可以使得 oldpkg.OldType 和 newpkg.NewType 是相同的，并且引用旧名称的代码与引用新名称的代码可以互相操作。<br><br>考虑将一个类型从一个包移动到另一个包中的情况，比如从 oldpkg.OldType 到 newpkg.NewType。可以在包 oldpkg 中指定一个新类型的别名 type OldType = newpkg.NewType，这样以前的代码都无需修改。","like_count":40},{"had_liked":false,"id":21364,"user_name":"咖啡色的羊驼","can_delete":false,"product_type":"c1","uid":1112900,"ip_address":"","ucode":"84E288A5665A3A","user_header":"https://static001.geekbang.org/account/avatar/00/10/fb/44/8b2600fd.jpg","comment_is_top":false,"comment_ctime":1535041148,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"130384060028","product_id":100013101,"comment_content":"最开始写go时候也在string上遇到过一个小坑。<br><br>由于是之前是phper，习惯性认为go中len(&quot;我&quot;)应该等于1，后面发现这个遇到字符串时候代表字节数。","like_count":30,"discussions":[{"author":{"id":1336951,"avatar":"https://static001.geekbang.org/account/avatar/00/14/66/77/194ba21d.jpg","nickname":"lzh","note":"","ucode":"C3D83DF4230109","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":356593,"discussion_content":"刚刚问了php，它不承认有你这个用户","likes_number":13,"is_delete":false,"is_hidden":false,"ctime":1615635093,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1318484,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1e/54/7646a440.jpg","nickname":"陈中开","note":"","ucode":"84AF53D5F2E9D8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":141732,"discussion_content":"php里面的strlen(&#34;我&#34;)也是3","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1579439612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2383535,"avatar":"https://static001.geekbang.org/account/avatar/00/24/5e/af/477fd5f6.jpg","nickname":"Grocker_Go","note":"","ucode":"445E5481CAEB4E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347871,"discussion_content":"mb_strlen(&#34;我&#34;) = 1","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1612346977,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1429336,"avatar":"https://static001.geekbang.org/account/avatar/00/15/cf/58/dabb0f73.jpg","nickname":"Super Ollie","note":"","ucode":"4F30DE41673C97","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281999,"discussion_content":"张口就来？","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1591859194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1748964,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/af/e4/cbfb57af.jpg","nickname":"star","note":"","ucode":"CFA2987EB62579","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311338,"discussion_content":"你确定写的是PHP 不是Python，貌似len是python的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602312322,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1237327,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e1/4f/00476b4c.jpg","nickname":"Remember九离","note":"","ucode":"97EE6E6344689F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":255194,"discussion_content":".....你成功吸引了我的注意","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588385636,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1435733,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e8/55/92f82281.jpg","nickname":"MClink","note":"","ucode":"F479190923355C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352083,"discussion_content":"得看是啥字符集啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614597306,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95329,"user_name":"胖子（李杰）","can_delete":false,"product_type":"c1","uid":1487089,"ip_address":"","ucode":"20477037FF2DC6","user_header":"https://static001.geekbang.org/account/avatar/00/16/b0/f1/e6c3ddd4.jpg","comment_is_top":false,"comment_ctime":1558019986,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"70277496722","product_id":100013101,"comment_content":"php 里面的strlen(&#39;你&#39;) 也不是1<br>mb_strlen(&#39;你&#39;) 才是 1","like_count":17,"discussions":[{"author":{"id":1067323,"avatar":"https://static001.geekbang.org/account/avatar/00/10/49/3b/5a66e755.jpg","nickname":"librabin","note":"","ucode":"AA810CAD2CC19E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390061,"discussion_content":"哈哈哈，是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629629361,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21486,"user_name":"李皮皮皮皮皮","can_delete":false,"product_type":"c1","uid":1200281,"ip_address":"","ucode":"3BF1DEE4A12359","user_header":"https://static001.geekbang.org/account/avatar/00/12/50/99/44378317.jpg","comment_is_top":false,"comment_ctime":1535111631,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"57369686479","product_id":100013101,"comment_content":"1.通过类型断言获取变量实际类型value，ok=x.(T)，ok表示是否是正确的类型，value是成功转换后的值，但返回值形式不建议使用，可能会导致panic<br>2.go不同类型直接不能相互赋值，不存在隐式类型转换，必须显式强转<br>3.type newType = oldType定义类型别名，type newType oldType定义新类型","like_count":13},{"had_liked":false,"id":31468,"user_name":"🄽🄸🅇🅄🅂","can_delete":false,"product_type":"c1","uid":1000060,"ip_address":"","ucode":"853763C229A5AA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/7c/8ef14715.jpg","comment_is_top":false,"comment_ctime":1539190866,"is_pvip":false,"replies":[{"id":"11821","content":"尽量做到能让大多数人满意：）","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1539577323,"ip_address":"","comment_id":31468,"utype":1}],"discussion_count":1,"race_medal":0,"score":"53078798418","product_id":100013101,"comment_content":"这节课，是从开始学习该专栏以来，最有价值的一节，没有之一！<br>希望剩下的课程，都能像这节课这样有价值！","like_count":12,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426355,"discussion_content":"尽量做到能让大多数人满意：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539577323,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77978,"user_name":"BitInit","can_delete":false,"product_type":"c1","uid":1007271,"ip_address":"","ucode":"BDDDA0F51B1EFB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/a7/8dc374e2.jpg","comment_is_top":false,"comment_ctime":1553048240,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"40207753904","product_id":100013101,"comment_content":"对于var str string = &quot;hello 你好&quot;，使用len(str)结果是12，因为len(str)显示的string底层字节大小。如果需要str的大小，方法一是len([]rune(str))，将string转为rune切片，方法二是utf8.RuneCountInString(str)。对string进行range遍历时，是以unicode编码遍历的。","like_count":10,"discussions":[{"author":{"id":1843847,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/22/87/915891bb.jpg","nickname":"辜聪林","note":"","ucode":"A9EBB39E82DE96","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387911,"discussion_content":"但是有些字符不能使用一个rune表示，这种情况下使用utf8遍历得到的len也不准确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628495798,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2661590,"avatar":"https://static001.geekbang.org/account/avatar/00/28/9c/d6/6cd283be.jpg","nickname":"jfxy","note":"","ucode":"64AE9465F08FD4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1843847,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/22/87/915891bb.jpg","nickname":"辜聪林","note":"","ucode":"A9EBB39E82DE96","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573676,"discussion_content":"啥字符不能用4个字节表示？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653578470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":387911,"ip_address":""},"score":573676,"extra":""}]}]},{"had_liked":false,"id":21435,"user_name":"hello peter","can_delete":false,"product_type":"c1","uid":1201338,"ip_address":"","ucode":"4839DC4442CB0E","user_header":"https://static001.geekbang.org/account/avatar/00/12/54/ba/8721e403.jpg","comment_is_top":false,"comment_ctime":1535079642,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"23009916122","product_id":100013101,"comment_content":"@咖啡色的羊驼 我也是phper，php中strlen(&#39;我&#39;)的结果应该是3，和go一样，你这习惯应该是js的吧","like_count":5,"discussions":[{"author":{"id":1521568,"avatar":"https://static001.geekbang.org/account/avatar/00/17/37/a0/032d0828.jpg","nickname":"上杉夏香","note":"","ucode":"9FDDE0979BCC8C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362980,"discussion_content":"或者python","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617083761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018209,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/89/61/e989ee5c.jpg","nickname":"houseme","note":"","ucode":"888294955B1731","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":106642,"discussion_content":"应该用的是mb_开头的吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577541375,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296949,"user_name":"mkii","can_delete":false,"product_type":"c1","uid":1674466,"ip_address":"","ucode":"534914EC7EA304","user_header":"https://static001.geekbang.org/account/avatar/00/19/8c/e2/48f4e4fa.jpg","comment_is_top":false,"comment_ctime":1623236465,"is_pvip":false,"replies":[{"id":"107904","content":"首先需要明确，结构体类型 A 中的字段 B（为了区分，以下称为 b 吧）的类型是一个“指针类型”，即 *B 。而结构体类型 B 携带了一个“指针方法” Print 。这里的“指针类型”和“指针方法”是关键。<br><br>即便 a 的字段 b 是 nil，但是 b 本身的“方法集合一直存在”（即类型 *B 的方法集合），只不过它的值为 nil 罢了。<br><br>正是由于 a 中的字段 b 的“方法集合一直存在”，因此a.b.Print() 这条链路才能走通。又由于类型 B 的方法 Print 的接收者类型为 *B ，所以在该方法执行的时候才不需要为了求接收者 b 的值而进行取值操作（即从 *B 到 B 的转换）。你可以想象一下，若 B 有另外一个方法 func (b B) Show() ，那么执行 a.b.Show() 会怎样。<br><br>你可以再写一些代码，如：<br><br>var b1 *B = nil<br>switch interface{}(b1).(type) {<br>case C:<br>\tfmt.Println(&quot;C&quot;)<br>default:<br>\tfmt.Println(&quot;?&quot;)<br>}<br><br>执行这段代码会打印出“C”。那你觉得为什么Go编译器能够知道 interface{}(b1) 的类型是 C 呢？它就是根据 b1 的方法集合来判断的啊。<br><br>无论 b 和 b1 的值是什么，只要它们有类型，它们的方法集合就是固定的。它们的“方法集合一直存在”！<br><br>","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1623313115,"ip_address":"","comment_id":296949,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18803105649","product_id":100013101,"comment_content":"type A struct {<br>   B *B<br>}<br><br>func (a *A) Print() {<br>   a.B.Print()<br>}<br><br>type B struct {<br>   str string<br>}<br><br>func (b *B) Print() {<br>   &#47;&#47;if b.str == &quot;&quot;{<br>      fmt.Println(&quot;1234&quot;)<br>   &#47;&#47;}else{<br>   &#47;&#47; fmt.Println(&quot;str is:&quot;,b.str)<br>   &#47;&#47;}<br>}<br><br>func TestAPrint(t *testing.T)  {<br>   a := &amp;A{nil}<br>   a.Print()<br>}<br>老师，为什么print函数这里不会Panic呀？","like_count":5,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521658,"discussion_content":"首先需要明确，结构体类型 A 中的字段 B（为了区分，以下称为 b 吧）的类型是一个“指针类型”，即 *B 。而结构体类型 B 携带了一个“指针方法” Print 。这里的“指针类型”和“指针方法”是关键。\n\n即便 a 的字段 b 是 nil，但是 b 本身的“方法集合一直存在”（即类型 *B 的方法集合），只不过它的值为 nil 罢了。\n\n正是由于 a 中的字段 b 的“方法集合一直存在”，因此a.b.Print() 这条链路才能走通。又由于类型 B 的方法 Print 的接收者类型为 *B ，所以在该方法执行的时候才不需要为了求接收者 b 的值而进行取值操作（即从 *B 到 B 的转换）。你可以想象一下，若 B 有另外一个方法 func (b B) Show() ，那么执行 a.b.Show() 会怎样。\n\n你可以再写一些代码，如：\n\nvar b1 *B = nil\nswitch interface{}(b1).(type) {\ncase C:\n\tfmt.Println(&amp;quot;C&amp;quot;)\ndefault:\n\tfmt.Println(&amp;quot;?&amp;quot;)\n}\n\n执行这段代码会打印出“C”。那你觉得为什么Go编译器能够知道 interface{}(b1) 的类型是 C 呢？它就是根据 b1 的方法集合来判断的啊。\n\n无论 b 和 b1 的值是什么，只要它们有类型，它们的方法集合就是固定的。它们的“方法集合一直存在”！\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623313115,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169314,"user_name":"沐夜星光","can_delete":false,"product_type":"c1","uid":1447220,"ip_address":"","ucode":"22F699E237B179","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLia2EwyyEVs3tWRnMlqaAG7R7HvlW4vGvxthKsicgsCEeXO1qL7mMy6GAzgdkSKcH3c70Qa2hY3JLw/132","comment_is_top":false,"comment_ctime":1578313727,"is_pvip":false,"replies":[{"id":"65676","content":"两者都是为了隔离变化。<br><br>别名类型“另起炉灶”的只是名字，主要是向上层应用隐藏下层类型的真实名称。这样一来，下层类型体系在重构的时候就可以换名字了（不会影响到上层代码）。<br><br>类型再定义更彻底一些。主要是为了另外构建一个与潜在类型有所关联（有一定的互操作性）但又不同的类型。基于这个新类型，我们可以构建另外一套操作或者类型体系，而不用去改动潜在类型（或者说潜在类型所在的体系）。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1578323246,"ip_address":"","comment_id":169314,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18758182911","product_id":100013101,"comment_content":"既然有了别名类型，为什么还要再搞个别名再定义，两者的应用场景有什么区别？","like_count":4,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480503,"discussion_content":"两者都是为了隔离变化。\n\n别名类型“另起炉灶”的只是名字，主要是向上层应用隐藏下层类型的真实名称。这样一来，下层类型体系在重构的时候就可以换名字了（不会影响到上层代码）。\n\n类型再定义更彻底一些。主要是为了另外构建一个与潜在类型有所关联（有一定的互操作性）但又不同的类型。基于这个新类型，我们可以构建另外一套操作或者类型体系，而不用去改动潜在类型（或者说潜在类型所在的体系）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578323246,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1566635,"avatar":"https://static001.geekbang.org/account/avatar/00/17/e7/ab/8383ca5b.jpg","nickname":"刻刻","note":"","ucode":"AD7FA37FA99EBC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350336,"discussion_content":"应用场景应该就是重构或者后期维护的时候，正常的开发很少会用到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613813836,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21378,"user_name":"我来也","can_delete":false,"product_type":"c1","uid":1205253,"ip_address":"","ucode":"773D6104F56767","user_header":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","comment_is_top":false,"comment_ctime":1535068242,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18714937426","product_id":100013101,"comment_content":"类型转换感觉跟c差不多。<br>类型别名，我知道的三处优点：1.名字可以取的更通俗易懂；2:需要修改数据类型时，只用改定义的那一处地方；3:可以很方便的添加特有方法，以实现某些接口。","like_count":4},{"had_liked":false,"id":204096,"user_name":"扩散性百万咸面包","can_delete":false,"product_type":"c1","uid":1905171,"ip_address":"","ucode":"6D703D51553B42","user_header":"https://static001.geekbang.org/account/avatar/00/1d/12/13/e103a6e3.jpg","comment_is_top":false,"comment_ctime":1586331754,"is_pvip":false,"replies":[{"id":"76913","content":"对， struct{} 是空结构体类型，struct{}{} 是对它的实例化。其实这种实例化总会返回相同的值。你可以把 struct{}   视为单例类型。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1586746010,"ip_address":"","comment_id":204096,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14471233642","product_id":100013101,"comment_content":"其中的x可以是一个变量，也可以是一个代表值的字面量（比如1.23和struct{}{}），还可以是一个表达式。<br><br>struct{}{} 的意思是声明一个空结构然后立刻初始化？","like_count":3,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491077,"discussion_content":"对， struct{} 是空结构体类型，struct{}{} 是对它的实例化。其实这种实例化总会返回相同的值。你可以把 struct{}   视为单例类型。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586746010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183772,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1583132228,"is_pvip":false,"replies":[{"id":"71244","content":"“类型别名”和“类型重定义”其实属于在Go语言的发展过程中相继出现的两个类似产物。但鉴于它们在功能上还是有明显差别的，所以理解起来也算容易。<br><br>“潜在类型”其实更多的是在语言词法分析方面起作用。从程序开发的角度讲，它几乎只与类型转换相关。“潜在类型”是Go语言规范中的死规定，所以记下来就好了。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1583230057,"ip_address":"","comment_id":183772,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14468034116","product_id":100013101,"comment_content":"一门新的技术的产生或者语言新特性的产生总是为了解决一些现有的比较棘手的问题<br>所以我在想 类型别名和 类型重定义及潜在类型 为什么会同时存在？<br>然后提到潜在类型 那么语言自带的类型 比如string是否有潜在类型 如果有是否就是它本身？","like_count":3,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485775,"discussion_content":"“类型别名”和“类型重定义”其实属于在Go语言的发展过程中相继出现的两个类似产物。但鉴于它们在功能上还是有明显差别的，所以理解起来也算容易。\n\n“潜在类型”其实更多的是在语言词法分析方面起作用。从程序开发的角度讲，它几乎只与类型转换相关。“潜在类型”是Go语言规范中的死规定，所以记下来就好了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583230057,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93437,"user_name":"Hector","can_delete":false,"product_type":"c1","uid":1496889,"ip_address":"","ucode":"110CAF87ADDC01","user_header":"https://static001.geekbang.org/account/avatar/00/16/d7/39/6698b6a9.jpg","comment_is_top":false,"comment_ctime":1557470784,"is_pvip":false,"replies":[{"id":"33417","content":"我在文章里说了：“潜在类型相同的不同类型的值之间是可以进行类型转换的”。这属于语法规则。<br><br>它们虽然代表着不同的类型，但本质上是同源的。也就是说，它们的底层结构是相同的。在这样情况下，在类型转换时值会被复制，即两个值会在不同的内存地址上。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1557496504,"ip_address":"","comment_id":93437,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14442372672","product_id":100013101,"comment_content":"string可以被称为MyString2的潜在类型，那他们的区别到底在哪里呢？底层时做的复制动作，但是指针存放的地址不同吗","like_count":3,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449633,"discussion_content":"我在文章里说了：“潜在类型相同的不同类型的值之间是可以进行类型转换的”。这属于语法规则。\n\n它们虽然代表着不同的类型，但本质上是同源的。也就是说，它们的底层结构是相同的。在这样情况下，在类型转换时值会被复制，即两个值会在不同的内存地址上。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557496504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57267,"user_name":"勇敢的心","can_delete":false,"product_type":"c1","uid":1198639,"ip_address":"","ucode":"43678591F1A558","user_header":"https://static001.geekbang.org/account/avatar/00/12/4a/2f/42aa48d7.jpg","comment_is_top":false,"comment_ctime":1546702018,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14431603906","product_id":100013101,"comment_content":"要成为kubernetes玩家，必须好好学习go语言！","like_count":4,"discussions":[{"author":{"id":1636058,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/ibL1llXU2FdfxKhobQZGSbiciaDJLSnibqs1XGrkkmuBKAwmTgGVeibvQicmBJU0p8ia2UkPqIYrRIb90iavcibmlVv1gXw/132","nickname":"ggo","note":"","ucode":"85AC4D763BF09A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336859,"discussion_content":"有道理!","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608717829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":23188,"user_name":"田佳伟","can_delete":false,"product_type":"c1","uid":1034087,"ip_address":"","ucode":"D31C9799F383D2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c7/67/0077314b.jpg","comment_is_top":false,"comment_ctime":1536196444,"is_pvip":false,"replies":[{"id":"8398","content":"正数的补码等于其自身。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1536215715,"ip_address":"","comment_id":23188,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14421098332","product_id":100013101,"comment_content":"首先你要知道，整数在 Go 语言以及计算机中都是以补码的形式存储的<br><br>这句话应该是：首先你要知道，负数在 Go 语言以及计算机中都是以补码的形式存储的  吧😄","like_count":3,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423457,"discussion_content":"正数的补码等于其自身。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1536215715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":293184,"user_name":"极客—月","can_delete":false,"product_type":"c1","uid":1318468,"ip_address":"","ucode":"EE12EEBF242B1D","user_header":"","comment_is_top":false,"comment_ctime":1621257841,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"10211192433","product_id":100013101,"comment_content":"怎样判断变量类型 =&gt; 类型断言<br><br>格式：value, ok := x.(T)<br><br>其中T是判断类型，x是要判断类型的值【x必须是接口类型】。<br><br>ok是类型判断的结果，如果ok是true，则value就是x转换为T类型的值。<br><br>如果ok是false，value会被赋值为nil。<br><br>当写成value := x.(T)时，即省去ok，若转换不成功则会报panic<br><br><br><br>{}在Go中可表示：<br><br>1. 空代码块<br>2. 不包含任何内容的数据类型，如：struct{}，interface{}<br>3. 不包含任何元素的集合类型，如: []string{}，map[int]string{}<br><br><br><br>类型字面量：表示数据类型本身的若干个字符，如[]string表示string的切片类型，map[int]string表示key为int类型，value为string类型的字典类型。<br><br><br><br>类型转换的三个小坑：<br><br>一、对于整数类型值、整数常量之间的类型转换，只要源值在目标类型的可表示范围内就是合法的。<br><br>需注意的是：<br><br>1. 当整数值的类型的有效范围由宽变窄时，只需在补码形式下截掉一定数量的高位二进制数即可<br><br>2. 当把一个浮点数类型的值转换为整数类型值时，前者的小数部分会被全部截掉<br><br>【这里涉及原码反码补码的知识，可以自己算下int16位的-255转成int8会是多少】<br><br><br><br>二、整数值转换为string类型可行，但需注意被转换的整数值应该可以代表一个有效的 Unicode 代码点<br><br>比如：string(-1) 得到字符&#39;�&#39;，字符&#39;�&#39;是 Unicode 标准中专用于替换未知的以及无法展示的字符<br><br>因为-1无法代表一个有效的 Unicode代码点<br><br><br><br>三、 关于string类型与各种切片类型之间的互转：<br><br>1. 值从string类型向[]byte类型转换时代表以 UTF-8 编码的字符串会被拆分成零散、独立的字节。例如中文会被拆分为三个字节<br>2. 值从string类型向[]rune类型转换时代表字符串会被拆分成一个个 Unicode 字符<br><br><br><br>别名类型：type MyString = string<br><br>类型再定义：type Mystring2 string 【string可称为MyString2的潜在类型】<br><br>【上面俩的差别就在于多了个&quot;=&quot;】<br><br>潜在类型相同的不同类型的值之间可互相转换，但不能赋值、比较<br><br>集合类型[]MyString2与[]string则不能互转【string是MyString2的潜在类型，但[]MyString2的潜在类型是[]MyString2，而[]string的潜在类型是[]string】<br><br>","like_count":3},{"had_liked":false,"id":223353,"user_name":"LubinLew","can_delete":false,"product_type":"c1","uid":1995285,"ip_address":"","ucode":"F30A4933C021BA","user_header":"https://static001.geekbang.org/account/avatar/00/1e/72/15/a8b97a39.jpg","comment_is_top":false,"comment_ctime":1591070006,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10181004598","product_id":100013101,"comment_content":"类型定义这部分有点太抽象了，这个文章中用华氏和摄氏的例子非常棒，虽然华氏和摄氏的潜在类型相同，但是他们之间进行直接比较是没有意义的。<br>https:&#47;&#47;www.jianshu.com&#47;p&#47;a02cf41c0520","like_count":2},{"had_liked":false,"id":107979,"user_name":"NoTryNoSuccess","can_delete":false,"product_type":"c1","uid":1372735,"ip_address":"","ucode":"89EE8B4CEECC1F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKOM6tVLSiciaQeQst0g3iboWO74ibicicVAia9qno0X6cf65pEKLgdKkUdcpCWpjAB5e6semrFrruiaGQWhg/132","comment_is_top":false,"comment_ctime":1561643020,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"10151577612","product_id":100013101,"comment_content":"container := map[int]string{0: &quot;zero&quot;, 1: &quot;one&quot;, 2: &quot;two&quot;}<br>value, _ := interface{}(container).(int)<br>其实这样也不会报错呀，且value为0并不为nil，其中int也可以为其他任何与目标类型map不一致的类型。","like_count":2,"discussions":[{"author":{"id":2858915,"avatar":"","nickname":"Geek_1621b6","note":"","ucode":"55DFE13F04D336","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535717,"discussion_content":"下划线也是变量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638523529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2407370,"avatar":"https://static001.geekbang.org/account/avatar/00/24/bb/ca/1a29decb.jpg","nickname":"悠悠空谷","note":"","ucode":"9C1852AD89F0CB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345973,"discussion_content":"你这语法都是错的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611826038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1027274,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ac/ca/fc35a685.jpg","nickname":"栗芳凯","note":"","ucode":"28D2A084918332","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":69089,"discussion_content":"value := interface{}(container).(int)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575259559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21396,"user_name":"@XP","can_delete":false,"product_type":"c1","uid":1136671,"ip_address":"","ucode":"D8D93A044F989C","user_header":"https://static001.geekbang.org/account/avatar/00/11/58/1f/9dc4d475.jpg","comment_is_top":false,"comment_ctime":1535071246,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10125005838","product_id":100013101,"comment_content":"1.接口之间的类型转换有时只有运行错误，不会有编译错误   <br>2. 类型别名和原类型完全一样，可以随意命名，增加代码可读性;  拓展外部访问权限，原来的变宽<br>不知道理解的对不对","like_count":2},{"had_liked":false,"id":21393,"user_name":"小小笑儿","can_delete":false,"product_type":"c1","uid":1040354,"ip_address":"","ucode":"CA63CC50DC2091","user_header":"https://static001.geekbang.org/account/avatar/00/0f/df/e2/823a04b4.jpg","comment_is_top":false,"comment_ctime":1535071027,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10125005619","product_id":100013101,"comment_content":"好像golang已经支持名字不同但包含的字段相同的struct直接赋值？别名类型在代码重构中非常有用，例如以前使用的是p.T这个类型，重构过程中需要把它移到p1.T1，这时只需要在p包中定义type T=p1.T1，这样基本之前使用p.T的代码都不用修改。","like_count":2},{"had_liked":false,"id":258781,"user_name":"趣学车","can_delete":false,"product_type":"c1","uid":1505155,"ip_address":"","ucode":"5279A6BF4C67A3","user_header":"https://static001.geekbang.org/account/avatar/00/16/f7/83/7fa4bd45.jpg","comment_is_top":false,"comment_ctime":1604555709,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5899523005","product_id":100013101,"comment_content":"别名类型可以让类型更加语义化， 如byte实际上是uint8的别名， 但是使用uint8的语义看上去像是一个无符号的8位bit, 而使用byte更能表示“字节”这个意思， 其根本上1个字节也是8个bit<br>类型重定义可以扩展现有的类型而不影响现有的类型","like_count":1},{"had_liked":false,"id":145340,"user_name":"风一般的梦幻","can_delete":false,"product_type":"c1","uid":1556304,"ip_address":"","ucode":"7E95425ECF3B89","user_header":"https://static001.geekbang.org/account/avatar/00/17/bf/50/3b370cd5.jpg","comment_is_top":false,"comment_ctime":1572254544,"is_pvip":false,"replies":[{"id":"56183","content":"对的，我跟编辑说一下，谢谢。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1572320576,"ip_address":"","comment_id":145340,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5867221840","product_id":100013101,"comment_content":"这一行：&quot;其中的x可以是一个变量，也可以是一个代表值的字面量（比如1.23和struct{}），还可以是一个表达式。&quot; 中的struct{}是否应改为struct{}{}?<br>","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472346,"discussion_content":"对的，我跟编辑说一下，谢谢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572320576,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77939,"user_name":"Leon Wong","can_delete":false,"product_type":"c1","uid":1073650,"ip_address":"","ucode":"B49B327367CF9E","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/f2/ca989d6f.jpg","comment_is_top":false,"comment_ctime":1553043848,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5848011144","product_id":100013101,"comment_content":"这一篇很精彩，思路清晰","like_count":1},{"had_liked":false,"id":26830,"user_name":"杨煌","can_delete":false,"product_type":"c1","uid":1197357,"ip_address":"","ucode":"97AE54BFD36108","user_header":"https://static001.geekbang.org/account/avatar/00/12/45/2d/779c1f03.jpg","comment_is_top":false,"comment_ctime":1537758865,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5832726161","product_id":100013101,"comment_content":"正数的补码和原码相同，负数的补码为原码取反加一。👍","like_count":1},{"had_liked":false,"id":25127,"user_name":"影子传说","can_delete":false,"product_type":"c1","uid":1031636,"ip_address":"","ucode":"371B72BB5CCB5E","user_header":"","comment_is_top":false,"comment_ctime":1537249961,"is_pvip":false,"replies":[{"id":"9371","content":"没有什么好处，是编码时需要注意和尽量避免的。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1537443237,"ip_address":"","comment_id":25127,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5832217257","product_id":100013101,"comment_content":"类型再定义有什么好处？","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424195,"discussion_content":"没有什么好处，是编码时需要注意和尽量避免的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537443237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008348,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/dc/8876c73b.jpg","nickname":"moooofly","note":"","ucode":"4A20795C281B6F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84061,"discussion_content":"不是为了扩展类型支持的方法才进行再定义的么？这不算好处么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576484712,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":22095,"user_name":"hb","can_delete":false,"product_type":"c1","uid":1139064,"ip_address":"","ucode":"788700127D3635","user_header":"https://static001.geekbang.org/account/avatar/00/11/61/78/84e3433a.jpg","comment_is_top":false,"comment_ctime":1535498922,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5830466218","product_id":100013101,"comment_content":"受益匪浅","like_count":1},{"had_liked":false,"id":349281,"user_name":"Geek_783504","can_delete":false,"product_type":"c1","uid":2743789,"ip_address":"","ucode":"549D3F0549743C","user_header":"https://static001.geekbang.org/account/avatar/00/29/dd/ed/f6c5432b.jpg","comment_is_top":false,"comment_ctime":1655864376,"is_pvip":true,"replies":[{"id":"127192","content":"第二问，其实使用别名类型是更方便的，因为它其实与原类型是同一类型。类型再定义的话，需要具体情况具体分析。如果就是想与原类型区别开，那么也是可以的，但要是类型的再定义影响到了接口、函数等向包外暴露的程序实体，那么就破坏了向后兼容性，这时就要认真评估了。","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1655955633,"ip_address":"","comment_id":349281,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1655864376","product_id":100013101,"comment_content":"第一问：<br>1.数值边界问题，如浮点数，边界值<br>2.string的unicode编码<br>第二问：<br>1.当需要对一部分数据进行类型修改时，使用类型再定义时更加的方便，避免大量的修改","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577177,"discussion_content":"第二问，其实使用别名类型是更方便的，因为它其实与原类型是同一类型。类型再定义的话，需要具体情况具体分析。如果就是想与原类型区别开，那么也是可以的，但要是类型的再定义影响到了接口、函数等向包外暴露的程序实体，那么就破坏了向后兼容性，这时就要认真评估了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655955633,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344404,"user_name":"会飞的猪","can_delete":false,"product_type":"c1","uid":1320510,"ip_address":"","ucode":"9B1C9715CBDA5B","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/3e/110ce115.jpg","comment_is_top":false,"comment_ctime":1651509722,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1651509722","product_id":100013101,"comment_content":"早点看到这个那天就不用通宵了","like_count":0},{"had_liked":false,"id":318181,"user_name":"taurustiger","can_delete":false,"product_type":"c1","uid":1013797,"ip_address":"","ucode":"AD04A081B8DCFD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/25/fd68ad02.jpg","comment_is_top":false,"comment_ctime":1635174569,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635174569","product_id":100013101,"comment_content":"interface{}代表空接口，任何类型都是它的实现类型","like_count":0},{"had_liked":false,"id":312517,"user_name":"自由","can_delete":false,"product_type":"c1","uid":2576960,"ip_address":"","ucode":"4E3B53D29D86CA","user_header":"https://static001.geekbang.org/account/avatar/00/27/52/40/db9b0eb2.jpg","comment_is_top":false,"comment_ctime":1631847720,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631847720","product_id":100013101,"comment_content":"类型别名的存在，是 渐进式代码修复(Gradual code repair) 的关键，什么是渐进式代码修复？举一个🌰，重构。重构代码，我们当然希望重构后的好处，能够适用于所有代码，但是，重构的好处与代价是成正比的，往往一次重构会伴随着大量的修改，随着代码量越来越大，一次完成所有修改变得不可行。修复需要逐步完成。<br><br>假如现在，我移动了 xxxpkg.buff 到 xxxpkg.byte 下，或许只是移动了两个文件，但是带来的是需要修改 N 个引用的文件，这样的修复，比实际的移动多了 N倍，随着代码量的增长，可能是更多倍。<br><br>在代码量少时，我们可以一次性完成所有的修复，这样的修复被称为原子代码修复(atomic code repair)，它的概念很简单，就是在一次提交中，更新所有的因为重构带来的问题修复，但是概念的简单会被实际的复杂性抵消，一次提交可能非常大，大的提交很难去一次性修复，出现问题也很难去溯源，最重要的是，可能会与其他同学的工作产生冲突，例如某个同学，在工作时，使用了旧的 API，合并代码时，并不会产生冲突，而我的提交错过了它的引用。<br><br>因此，我们需要一个过渡期，这个过渡期就是为了逐步替换，也就是渐进式代码修复，将旧的引用，逐步替换，同时将旧的换为新的，这就是渐进式代码修复，它的缺点是比原子代码修复的工作量更大，但是它更容易提交、审查，并且保证了，没有人引用后再删除旧的类型别名。<br><br>总结一下，类型别名，在特定情况下，帮助代码逐步修复。<br><br>demo: https:&#47;&#47;go.googlesource.com&#47;go&#47;+&#47;d3a412a5abf1ee8815b2e70a18ee092154af7672<br>参考链接： Russ Cox 的论文 《Codebase Refactoring (with help from Go)》https:&#47;&#47;talks.golang.org&#47;2016&#47;refactor.article","like_count":0},{"had_liked":false,"id":290844,"user_name":"新文","can_delete":false,"product_type":"c1","uid":1670150,"ip_address":"","ucode":"AFE81097214247","user_header":"https://static001.geekbang.org/account/avatar/00/19/7c/06/fcd1b0c5.jpg","comment_is_top":false,"comment_ctime":1619777501,"is_pvip":true,"replies":[{"id":"105497","content":"这是一个以考题为中心的专栏。而考题又是围绕着Go语言能核心知识点来出的。你可以把这理解成一种多层次的形状结构。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1620142498,"ip_address":"","comment_id":290844,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1619777501","product_id":100013101,"comment_content":"为什么读的时候是跳跃的？听着很难受。我买过的专栏只有这个是这样子的","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519299,"discussion_content":"这是一个以考题为中心的专栏。而考题又是围绕着Go语言能核心知识点来出的。你可以把这理解成一种多层次的形状结构。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620142498,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":286958,"user_name":"胡小涵","can_delete":false,"product_type":"c1","uid":2004538,"ip_address":"","ucode":"2E750C65EC282C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/96/3a/e06f8367.jpg","comment_is_top":false,"comment_ctime":1617701780,"is_pvip":false,"replies":[{"id":"104243","content":"你所理解的“非空接口”的定义是什么？","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1617774989,"ip_address":"","comment_id":286958,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1617701780","product_id":100013101,"comment_content":"那请问golang中是否存在“非空接口”？ 如果存在的话该怎么理解？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518145,"discussion_content":"你所理解的“非空接口”的定义是什么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617774989,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235368,"user_name":"Onyanga","can_delete":false,"product_type":"c1","uid":1272825,"ip_address":"","ucode":"DF4D22F0D51881","user_header":"https://static001.geekbang.org/account/avatar/00/13/6b/f9/da3ee7a8.jpg","comment_is_top":false,"comment_ctime":1594985101,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594985101","product_id":100013101,"comment_content":"类型别名在重构中的作用？<br><br>1. 命名冲突<br>2. 跨包迁移类型：在原类型所在包中，设置原类型为新类型的别名，这样所有使用原类型的地方自动替换为新类型，无需代码改动。<br>3. 大写导出","like_count":0},{"had_liked":false,"id":83368,"user_name":"赵梓旗","can_delete":false,"product_type":"c1","uid":1103470,"ip_address":"","ucode":"CD5BAA271BBDCE","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/6e/7f6a70bc.jpg","comment_is_top":false,"comment_ctime":1554545869,"is_pvip":false,"replies":[{"id":"30253","content":"你可以参看一下，Go语言规范：https:&#47;&#47;golang.google.cn&#47;ref&#47;spec#Types ，这才是根本。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1554691617,"ip_address":"","comment_id":83368,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554545869","product_id":100013101,"comment_content":"您好，我有一个疑问，我认为文中提到的<br>[]MyString2 的潜在类型应该是它本身 []Mystring2<br>同理，[]string 的潜在类型应该也是它本身 []string<br>所以二者潜在类型不同，不能进行类型转换<br><br>参考 https:&#47;&#47;go101.org&#47;article&#47;type-system-overview.html 中 「Concept: Underlying Types」小节的内容","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445994,"discussion_content":"你可以参看一下，Go语言规范：https://golang.google.cn/ref/spec#Types ，这才是根本。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554691617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71895,"user_name":"HunterYuan","can_delete":false,"product_type":"c1","uid":1015256,"ip_address":"","ucode":"F8900C33D29AA7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/d8/d7c77764.jpg","comment_is_top":false,"comment_ctime":1551477078,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551477078","product_id":100013101,"comment_content":"计算机是以源码存储，补码计算的才对","like_count":0},{"had_liked":false,"id":68394,"user_name":"漠映残夕","can_delete":false,"product_type":"c1","uid":1201985,"ip_address":"","ucode":"AAE763C91146AB","user_header":"https://static001.geekbang.org/account/avatar/00/12/57/41/22e85c6c.jpg","comment_is_top":false,"comment_ctime":1550493449,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550493449","product_id":100013101,"comment_content":"作为从php过来的，查包含中文的字符串长度，应该用mb_strlen($str,&#39;utf-8&#39;)。","like_count":0},{"had_liked":false,"id":65439,"user_name":"🐻","can_delete":false,"product_type":"c1","uid":1043072,"ip_address":"","ucode":"534EDAD496A0E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ea/80/8759e4c1.jpg","comment_is_top":false,"comment_ctime":1549357352,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549357352","product_id":100013101,"comment_content":"![](https:&#47;&#47;passage-1253400711.cos-website.ap-beijing.myqcloud.com&#47;2019-02-05-090059.png)<br><br>不知道评论能不能发图片。<br><br>https:&#47;&#47;gist.github.com&#47;bwangelme&#47;708fd84b29d47a7a8644832ce621d53d#unicode-%E5%B1%95%E7%A4%BA<br><br>这是原文地址，由于写了一些代码，发在 Gist 上了。","like_count":0},{"had_liked":false,"id":65300,"user_name":"Geek_1ed70f","can_delete":false,"product_type":"c1","uid":1394112,"ip_address":"","ucode":"B9A1928A6967B1","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erNhKGpqicibpQO3tYvl9vwiatvBzn27ut9y5lZ8hPgofPCFC24HX3ko7LW5mNWJficgJncBCGKpGL2jw/132","comment_is_top":false,"comment_ctime":1549219759,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549219759","product_id":100013101,"comment_content":"简单又深,既然老实说讲的都是核心,那就该一个不落下都吸收,平时以为这些东西 工作上用不上就过了..","like_count":0},{"had_liked":false,"id":43589,"user_name":"王正","can_delete":false,"product_type":"c1","uid":1137746,"ip_address":"","ucode":"13C2C70463DB31","user_header":"https://static001.geekbang.org/account/avatar/00/11/5c/52/5d037701.jpg","comment_is_top":false,"comment_ctime":1543243110,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1543243110","product_id":100013101,"comment_content":"别名声明为其他地方声明的对象（类型、函数等）引入了替代名称。<br>（1）简化了分割包，因为客户端可以增量更新，这对于大规模重构至关重要。<br>（2）还促进多包组件，其中顶级包作为组件的公共API提供引用组件内部包的别名。<br>（3）对于Google PB的“import public”特性的Go实现非常重要。<br>（4）还提供了“点导入”的更细粒度和更明确的替代方法。<br>3、4不太理解","like_count":0},{"had_liked":false,"id":32856,"user_name":"肖恩","can_delete":false,"product_type":"c1","uid":1242463,"ip_address":"","ucode":"78F91260284C21","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/5f/01b82ba1.jpg","comment_is_top":false,"comment_ctime":1539704429,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539704429","product_id":100013101,"comment_content":"Mystring2的潜在类型是string,所以Mystring2和string的值可以进行互转,那么[]Mystring2 的潜在类型是[]string，是不是也就可以和[]string互转了吗","like_count":0},{"had_liked":false,"id":32247,"user_name":"danny","can_delete":false,"product_type":"c1","uid":1260541,"ip_address":"","ucode":"D165B63779D1D7","user_header":"https://static001.geekbang.org/account/avatar/00/13/3b/fd/2bddb352.jpg","comment_is_top":false,"comment_ctime":1539496852,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539496852","product_id":100013101,"comment_content":"类型别名，和我曾经用过的ABAP语法是一样的，感觉是借鉴了ABAP语言","like_count":0},{"had_liked":false,"id":29224,"user_name":"Meow💰","can_delete":false,"product_type":"c1","uid":1199283,"ip_address":"","ucode":"131652CE581CCD","user_header":"https://static001.geekbang.org/account/avatar/00/12/4c/b3/ee3a5471.jpg","comment_is_top":false,"comment_ctime":1538293064,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538293064","product_id":100013101,"comment_content":"byte是uint8的别名类型，而rune是int32的别名类型。","like_count":0}]}