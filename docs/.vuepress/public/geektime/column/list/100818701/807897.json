{"id":807897,"title":"02｜做好准备：写一个基础软件需要掌握哪些Rust知识点？","content":"<blockquote>\n<p><span class=\"reference\">本课程为精品小课，不标配音频</span></p>\n</blockquote><p>你好，我是文强。</p><p>从这节课开始，我们正式进入实践落地阶段。为了能让你更好地理解本课程后续的内容，我会先带你了解写一个分布式基础软件所需要用到的 Rust 关键知识点。</p><blockquote>\n<p><span class=\"reference\">Tips：这节课只是起到一个“引导点明”的作用，不会详细展开讲解各个知识点。建议你先根据上节课推荐的资料把 Rust 的相关知识点都过一遍，再来看这节课的内容，会更好理解。</span></p>\n</blockquote><p>接下来，我整理了一个常用的 Rust 知识点集合（这个信息来源于多份学习资料，我只是做了一下总结）。你可以根据表格来看一下自己对 Rust 的掌握程度，然后查缺补漏。</p><p><img src=\"https://static001.geekbang.org/resource/image/1y/f3/1yy72588146f7e15f1502afab537caf3.jpg?wh=1560x1502\" alt=\"\"></p><p>基于上面的表格，接下来我们重点讲一下在编码过程中最常用到且在理解上有一定挑战的几个知识点。</p><ol>\n<li>包管理工具：Cargo</li>\n<li>生命周期和所有权</li>\n<li>泛型和Trait</li>\n<li>智能指针</li>\n<li>并发编程和Tokio</li>\n<li>测试用例</li>\n</ol><h2>包管理工具：Cargo</h2><p>无论是哪份学习资料，都会告诉你 Cargo 的重要性。在我看来 Cargo 是 Rust 的核心竞争力之一，是学习 Rust 必须完整掌握的知识点。想要学好 Cargo 看这份资料即可<a href=\"https://course.rs/cargo/intro.html\">《Cargo 使用指南》</a>。</p><p>在 Cargo 里面重点关注以下三个命令，掌握后基本就入门了。</p><p><img src=\"https://static001.geekbang.org/resource/image/71/3c/7178116bc586b5b82374bef833cdb63c.jpeg?wh=1892x533\" alt=\"图片\"><br>\n使用示例如下：</p><pre><code class=\"language-plain\"># 用 cargo build 根据 release 标准将项目打包成一个可执行的二进制文件\ncargo build --release： \n\n\n# 运行名为 mqtt-broker 的这个模块里面的测试用例\ncargo test --package mqtt-broker\n\n\n# 执行 cmd 包中名字为 placement-center 的 bin 的 main 函数，并给这个main函数传递conf参数\ncargo run --package cmd --bin placement-center -- --conf=config/placement-center.toml\n</code></pre><!-- [[[read_end]]] --><p>接下来通过真实项目中的两个 cargo.toml 来看一下如何编写 cargo 文件。</p><ul>\n<li>文件1</li>\n</ul><pre><code class=\"language-plain\">[workspace]\nmembers = [\n    \"src/mqtt-broker\"\n]\n\n\nresolver = \"2\"\n\n\n[workspace.package]\nversion = \"0.0.1\"\nedition = \"2021\"\nlicense = \"Apache-2.0\"\n\n\n[workspace.dependencies]\nserde = { version = \"1.0\", features = [\"derive\"] }\n\n\n## workspaces members\nmqtt-broker = { path = \"src/mqtt-broker\" }\n</code></pre><ul>\n<li>文件2</li>\n</ul><pre><code class=\"language-plain\">[package]\nname = \"cmd\"\nversion.workspace = true\nedition.workspace = true\nlicense.workspace = true\ndefault-run = \"robustmq\"\n\n\n[[bin]]\nname = \"mqtt-server\"\npath = \"src/mqtt-server/server.rs\"\n\n\n[dependencies]\nserde.workspace = true\n</code></pre><p>上面这两个文件，第一个文件是项目根目录的 cargo.toml，用处是导入依赖、组织管理子项目。第二个是子项目的cargo.toml，它是一个可执行的package，依赖父项目workspace的管理。文件内出现了以下四个知识点：</p><ol>\n<li>\n<p>Cargo 中 <a href=\"https://course.rs/cargo/reference/workspaces.html\">Workspace</a> 的使用。包括根项目中 workspace 的使用，子项目基于 workspace 特性管理依赖、版本信息等。</p>\n</li>\n<li>\n<p>Cargo&nbsp;<a href=\"https://course.rs/cargo/reference/manifest.html\">package 的定义</a>（包括命名、版本、license）。</p>\n</li>\n<li>\n<p>Cargo 中基于 <a href=\"https://crates.io/\">crates.io</a> 方式<a href=\"https://course.rs/cargo/reference/specify-deps.html\">引入依赖包</a>。</p>\n</li>\n<li>\n<p><a href=\"https://course.rs/cargo/reference/cargo-target.html#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AF%B9%E8%B1%A1binaries\">Cargo package bin</a> 的用法。</p>\n</li>\n</ol><p>这里就不详细展开说明每个细节了，如果你看不懂上面的语法，就完整看一下<a href=\"https://course.rs/cargo/intro.html\">《Cargo 使用指南》</a>。如果你能看懂上面两个文件，说明你对 Cargo 的理解就差不多了。接下来就是在实际项目中使用 Cargo 的 build、run、test 命令看一下效果了。</p><p>接下来，来看看 Rust 的生命周期和所有权。</p><h2>生命周期和所有权</h2><p>可以说 Rust 这个语言的核心就是<strong>生命周期</strong>和<strong>所有权</strong>了。基本所有的语法点都是围绕这两个点来组织的。写好 Rust 代码的关键就是把这两个点理解透。这两个特性有关的知识点太多，我主要讲一下我们在实际编码中，主要会涉及的5个重点。</p><ol>\n<li><strong>变量的可变性和不可变性</strong>。意思是 Rust 在定义变量的时候就需要指明它是否能够被修改，来看下面这个代码示例。</li>\n</ol><pre><code class=\"language-plain\">let x = 1; # 变量 x 不能被修改\nlet mut y = 1  # 变量 y 能被修改\n</code></pre><p>上面代码中的 mut 关键字就是表示，这个变量能不能被修改，默认情况下变量是不能被修改的。所以在实际编码过程中，你会看到很多这样的代码写法：</p><pre><code class=\"language-plain\">pub struct ClientKeepAlive {\n    stop_send: broadcast::Sender&lt;bool&gt;，\n}\n\n\nimpl ClientKeepAlive {\n    pub async fn start_heartbeat_check(&amp;mut self) {\n        loop {\n            let mut stop_rx = self.stop_send.subscribe();\n            select! {\n                val = stop_rx.recv() =&gt;{\n                    ......\n                }\n            }\n        }\n    }\n}\n</code></pre><p>上面代码的核心是：&amp;mut self 的使用，表明可以通过 mut self 来获取对象的可变属性，并修改它。而如果不需要修改，则改为 &amp;self 即可。了解更多可以看<a href=\"https://course.rs/basic/variable.html#%E5%8F%98%E9%87%8F%E5%8F%AF%E5%8F%98%E6%80%A7\">《变量绑定与解构》</a>这个资料。</p><blockquote>\n<p><span class=\"reference\">Tips:  变量可变/不可变的特性是 Rust 安全性的一个重要来源。默认情况下变量都是不可变的，只有手动定义了mut 后，数据才能被修改。这样可以保证数据不会在某些地方被莫名修改，从而保证了数据的安全。</span></p>\n</blockquote><p>对于变量的可变性，再推荐一个在日常开发中会大量使用到的开发库<a href=\"https://crates.io/crates/dashmap\">《DashMap》</a>。它是HashMap 的替代品，我们在日常开发中会大量用 HashMap 来存储数据。此时就会大量用到类似 <strong>Arc&lt;RwLock&lt;HashMap&lt;String,String&gt;&gt;&gt;</strong> 的语法，这个用法很繁琐，性能也很低。此时可以使用DashMap来替代这个语法的使用。</p><ol start=\"2\">\n<li><strong>变量的所有权和借用</strong>。Rust 语言能够没有GC（垃圾回收），其所有权特性的设计功不可没。关于 Rust 为什么可以没有 GC，你可以看<a href=\"https://course.rs/basic/ownership/index.html\">《所有权和借用》</a>和<a href=\"https://course.rs/advance/smart-pointer/drop.html\">《Drop 释放资源》</a>这两份资料来理解。</li>\n</ol><p>在实际编码中，所有权和借用特性主要体现在 clone() 和 &amp; 两个语法的使用。来看个例子：</p><pre><code class=\"language-plain\">pub fn is_system_topic1(topic_name: String) -&gt; bool {\n    return true;\n}\n\n\npub fn is_system_topic2(topic_name: &amp;String) -&gt; bool {\n    return true;\n}\n\n\nlet topic_name = \"test\".to_string();\nis_system_topic1(topic_name.clone());\nis_system_topic1(topic_name.clone());\nis_system_topic2(&amp;topic_name);\nis_system_topic2(&amp;topic_name);\n</code></pre><p>上面定义了 is_system_topic1 和 is_system_topic2 两个方法，传递参数分别是 String和 String的引用。is_system_topic1 是把 topic_name 的所有权转移到函数中，is_system_topic2 传递了一个topic_name的引用到函数中，没有转移函数的所有权。</p><p>所以在编码中，你会大量用 <strong>clone</strong> <strong>和 &amp;（引用）</strong>语法。那在编码中，什么时候用什么语法呢？来看它们在编码层面的主要区别。</p><ul>\n<li>\n<p><strong>传递引用</strong>：在多线程的环境下或者使用对象（struct）时，因为生命周期的限制，就会产生很复杂的问题，会大大增加编码的复杂度（这点会在后面的实践中展开讲，让你体会更深）。一些情况下可能还需要引入“生命周期约束”的特性。此时就需要用到所有权的转移，或者通过引入智能指针 Arc 来实现一个变量有多个所有者。</p>\n</li>\n<li>\n<p><strong>所有权转移</strong>：这个是最简单的用法，在每次参数传递时，都创建变量的副本，当数据较大时，会比较消耗性能。从语法上看会大量类似 xx.clone() 语法，不太友好。</p>\n</li>\n</ul><p>所以在实践中： <strong>建议默认优先使用引用，需要<strong><strong>在</strong></strong>多线程间传递数据的时候再使用clone()</strong>。</p><ol start=\"3\">\n<li><strong>静态/全局变量</strong>：在实际编码中会大量用到静态和全局变量。而在生命周期和所有权的机制中，静态和全局变量的使用就变得比较复杂。相关资料可以看<a href=\"https://course.rs/advance/lifetime/static.html\">《静态变量》</a>、<a href=\"https://course.rs/advance/global-variable.html\">《全局变量》</a>这两个文档。从学习的角度，只要会用就可以，底层的原理主要还是围绕生命周期来展开。来看个具体使用的例子：</li>\n</ol><pre><code class=\"language-plain\"># 通过static 定义一个静态变量\nstatic CONNECTION_ID_BUILD: AtomicU64 = AtomicU64::new(1);\n\n\n# 通过 const 定义一个静态常量\npub const REQUEST_RESPONSE_PREFIX_NAME: &amp;str = \"/sys/request_response/\";\n</code></pre><p>再推荐一个定义静态变量经常会用到的库<a href=\"https://crates.io/crates/lazy_static\">《库 lazy_static》</a>，因为静态变量是在编译期初始化的，因此无法使用函数调用进行赋值，而lazy_static允许我们在运行期初始化静态变量。</p><pre><code class=\"language-plain\"># 通过lazy_static 动态定义静态变量\nlazy_static! {\n    static ref BROKER_PACKET_NUM: IntGaugeVec = register_int_gauge_vec!(\n        \"broker_packet_num\",\n        \"broker packet num\",\n        &amp;[\n            METRICS_KEY_MODULE_NAME,\n            METRICS_KEY_PROTOCOL_NAME,\n            METRICS_KEY_TYPE_NAME,\n        ]\n    )\n}\n</code></pre><ol start=\"4\">\n<li>\n<p><strong>生命周期约束</strong>：生命周期约束是一个用得比较少，但是需要重点学习的特性。因为在某些情况下，只能用它来解决问题。详细资料可以看这个文档<a href=\"https://course.rs/advance/lifetime/advance.html\">《生命周期约束》</a>。在实际编码中，生命周期约束主要用在标注引用的生命周期。<strong>从实践的角度，建议能不用生命周期约束就不用，一般需要用到生命周期约束的地方都会有替换方案</strong>。</p>\n</li>\n<li>\n<p><a href=\"https://course.rs/advance/lifetime/intro.html\">《生命周期》</a>和<a href=\"https://course.rs/basic/lifetime.html\">《认识生命周期》</a>：这两章可以放最后看，讲得比较晦涩，编码上用得少，不过加深对生命周期的理解有好处，建议你稍微看一下。</p>\n</li>\n</ol><p>接下来，来看一下泛型和 Trait。在实际业务场景中，我们会频繁遇到需要使用泛型和Trait的场景。</p><h2>泛型和 Trait</h2><p>关于泛型和 Trait，你主要看这两个资料：<a href=\"https://course.rs/basic/trait/generic.html\">《泛型》</a>和<a href=\"https://course.rs/basic/trait/trait.html\">《特征 Trait》</a>。看完这两篇基本就入门了。需要重点关注以下知识点：</p><ol>\n<li>\n<p><strong>泛型</strong>：泛型的定义，泛型的约束，泛型如何进行参数传递。</p>\n</li>\n<li>\n<p><strong>特征</strong>：特征定义，特征的实现，特征约束，特征对象，以及特征对象如何在多线程传递。</p>\n</li>\n</ol><p>接下来通过两个例子，看一下在实际编码中，会怎么用这两个知识点。<strong>只要你能完全理解这两段代码想表达的意思，那你对于泛型和</strong> <strong>Trait 的了解基本就没问题了</strong>。</p><ul>\n<li>泛型</li>\n</ul><pre><code class=\"language-plain\">#[async_trait]\npub trait StorageAdapter {\n    // Streaming storage model: Append data in a Shard dimension, returning a unique self-incrementing ID for the Shard dimension\n    async fn stream_write(\n        &amp;self,\n        shard_name: String,\n        data: Vec&lt;Record&gt;,\n    ) -&gt; Result&lt;Vec&lt;usize&gt;, RobustMQError&gt;;\n\n\n}\n\n\npub struct MessageStorage&lt;T&gt; {\n    storage_adapter: Arc&lt;T&gt;,\n}\n\n\nimpl&lt;T&gt; MessageStorage&lt;T&gt;\nwhere\n    T: StorageAdapter + Send + Sync + 'static,\n{\n    pub fn new(storage_adapter: Arc&lt;T&gt;) -&gt; Self {\n        return MessageStorage { storage_adapter };\n    }\n\n\n    // Save the data for the Topic dimension\n    pub async fn append_topic_message(\n        &amp;self,\n        topic_id: String,\n        record: Vec&lt;Record&gt;,\n    ) -&gt; Result&lt;Vec&lt;usize&gt;, RobustMQError&gt; {\n        let shard_name = topic_id;\n        match self.storage_adapter.stream_write(shard_name, record).await {\n            Ok(id) =&gt; {\n                return Ok(id);\n            }\n            Err(e) =&gt; {\n                return Err(e);\n            }\n        }\n    }\n\n\n</code></pre><p>上面这段代码定义了名为 StorageAdapter 的 Trait，然后定义名为 MessageStorage 的对象，MessageStorage 包含一个变量 storage_adapter 是一个泛型。这段代码的重点是对变量storage_adapter的泛型约束：where T: StorageAdapter + Send + Sync + 'static。表示这是一个泛型，这个泛型需要满足 StorageAdapter + Send + Sync + 'static 四个约束。</p><p>然后在 MessageStorage 的方法中，append_topic_message 使用泛型约束StorageAdapter的方法 stream_write。</p><ul>\n<li>Trait</li>\n</ul><pre><code class=\"language-plain\">#[async_trait]\npub trait AuthStorageAdapter {\n    async fn read_all_user(&amp;self) -&gt; Result&lt;DashMap&lt;String, MQTTUser&gt;, RobustMQError&gt;;\n}\n\n\npub struct AuthDriver {\n    driver: Arc&lt;dyn AuthStorageAdapter + Send + 'static + Sync&gt;,\n}\n\n\nimpl AuthDriver {\n    pub fn new(cache_manager: Arc&lt;CacheManager&gt;, client_poll: Arc&lt;ClientPool&gt;) -&gt; AuthDriver {\n        let driver = match build_driver() {\n            Ok(driver) =&gt; driver,\n            Err(e) =&gt; {\n                panic!(\"{}\", e.to_string());\n            }\n        };\n        return AuthDriver {\n            driver: driver,\n        };\n    }\n\n\n    pub async fn read_all_user(&amp;self) -&gt; Result&lt;DashMap&lt;String, MQTTUser&gt;, RobustMQError&gt; {\n        return self.driver.read_all_user().await;\n    }\n}\n</code></pre><p>上面这段代码在上节课就出现过，其定义了名为AuthStorageAdapter的Trait和名为AuthDriver的 Struct，通过build_driver方法构建Trait的不同实现，通过Arc&lt;dyn AuthStorageAdapter + Send + 'static + Sync&gt; 实现变量在不同线程间的传递。</p><p>接下来我们来看看Rust中的智能指针。</p><h2>智能指针</h2><p>只要写 Rust 代码，智能指针基本就是最常用的特性之一，你如果没用到，那就说明你的项目不是一个真正的生产项目。要了解智能指针的详细信息，看这个资料<a href=\"https://course.rs/advance/smart-pointer/intro.html\">《智能指针》</a>即可。</p><p>Rust 中包含了丰富的智能指针，包括 Box、Rc/Arc、Cell/RefCell、Drop、Deref 等等。在实际编码中，我们最常用的是 Box、Rc/Arc、Cell/RefCell 三类，来看下它们各自的作用。</p><ul>\n<li><strong>Box</strong></li>\n</ul><p>智能指针 Box 的核心功能是允许<strong>将一个值分配到堆上，然后返回一个指针指向堆上的数据</strong>。从实际作用上来看，主要有以下3个使用场景：</p><ol>\n<li>\n<p>将数据分配在堆上，比如在数据较大时，不想在转移所有权时进行数据拷贝。</p>\n</li>\n<li>\n<p>类型的长度在编译期无法确定，但是在变量定义时又需要知道类型的长度时。</p>\n</li>\n<li>\n<p>特征对象，用于说明对象实现了一个特征，而不是某个特定的类型。</p>\n</li>\n</ol><p>上面第 1 点，直接将数据固定在堆上听起来很抽象，有啥用呢？举个例子。</p><p>在消息队列中，服务端 Server 需要大量接收客户端数据进行处理和保存。当数据很大时（比如 10MB），在数据转移所有权过程中，需要大量拷贝数据，此时数据太大，拷贝就需要消耗大量性能。</p><p>正常情况下，我们可以通过下面的结构体 RequestPackage 来传递数据，客户端的数据放在 packet 属性里面。</p><pre><code class=\"language-plain\">#[derive(Clone, Debug)]\npub struct RequestPackage {\n    pub connection_id: u64,\n    pub addr: SocketAddr,\n    pub packet: MQTTPacket,\n}\n</code></pre><p>如果 packet 太大，则会严重影响性能。此时可以把代码改为：</p><pre><code class=\"language-plain\">#[derive(Clone, Debug)]\npub struct RequestPackage {\n    pub connection_id: u64,\n    pub addr: SocketAddr,\n    pub packet: Box&lt;MQTTPacket&gt;,\n}\n</code></pre><p>改完后，packet 只是一个Box指针，不包含实际的数据体，所以在转移所有权拷贝数据过程中，拷贝的是引用指针数据，此时就可以避免在转移所有权过程中因数据太大而带来的性能问题。</p><p>2和3属于一个类型，属于 Box<dyn> 的用法，本质上来看，也是将数据固定在堆上，返回一个引用。这个资料可以参考<a href=\"https://course.rs/basic/trait/trait-object.html\">《特征对象》</a>。</dyn></p><ul>\n<li><strong>Rc/Arc</strong></li>\n</ul><p>解决Rust中一个值在同一时刻只能有一个所有者的问题，即<strong>允许一个值在同一时刻拥有多个所有者</strong>。如果你对 Rust 的所有权机制有足够了解，则很容易理解这句话的意思。如果不理解，可以看一下前面提到的《生命周期和所有权》部分。</p><p>从实际编码中，Rc 用得相对比较少，基本用的都是 Arc。因为 <strong>Rc 用于单线程，Arc 用于多线程</strong>。而在实际业务中，基本都是多线程编程。所以你需要重点了解 Arc 的用法，主要参考这份资料<a href=\"https://course.rs/advance/smart-pointer/rc-arc.html\">《Rc 与 Arc 实现 1vN 所有权机制》</a>。</p><p>下面来看一段 Arc 经典使用案例的代码。</p><pre><code class=\"language-plain\">pub struct MqttBroker {\n    subscribe_manager: Arc&lt;SubscribeManager&gt;,\n    connection_manager: Arc&lt;ConnectionManager&gt;,\n}\n\n\nimpl MqttBroker\n{\n    pub fn new(\n        client_poll: Arc&lt;ClientPool&gt;,\n        cache_manager: Arc&lt;CacheManager&gt;,\n    ) -&gt; Self {\n        let subscribe_manager = Arc::new(SubscribeManager::new(\n            cache_manager.clone(),\n            client_poll.clone(),\n        ));\n\n\n        let connection_manager = Arc::new(ConnectionManager::new(cache_manager.clone()));\n        return MqttBroker {\n            subscribe_manager,\n            connection_manager,\n        };\n    }\n}\n\n\n</code></pre><p>这段代码的意思是，我们定义两个 subscribe_manager 和 connection_manager 分别来管理消息队列的订阅和连接数据。在实际场景中，这两个数据都需要在不同的线程中被操作（比如读取和写入）。此时如果不用智能指针 Arc，则 SubscribeManager 和 ConnectionManager 这两个 struct 是不能在多线程共享的。</p><p>简单来说就是：<strong>如果一个数据要在多线程间共享，就必须使用 Arc</strong>。</p><ul>\n<li><strong>Cell/RefCell</strong></li>\n</ul><p>通过学习所有权的部分，我们知道在 Rust 的定义中：<strong>一个变量同时只能拥有一个可变引用或多个不可变引用，不能既拥有一个可变引用，又拥有多个不可变应用</strong>。在实际编码中，这个语法会给我们带来很大的限制，导致我们无法实现某些功能或大大增加实现成本。</p><blockquote>\n<p><span class=\"reference\">Tips：提醒一下，不要一开始就用 Rust 去写 LeeCode 的数据结构算法，会写到怀疑人生。其中一个很大原因就是上面这个限制。</span></p>\n</blockquote><p>所以 Rust 提供了智能指针 Cell/RefCell 来绕过这个限制，即：<strong>通过 Cell/RefCell 可以在拥有不可变引用的同时修改目标数据</strong>。简单来说就是，<strong>变量可以在拥有不可变引用的同时拥有可变引用</strong>。</p><p>在看到这个语法时，我的第一反应是，这不是绕过了 Rust 的安全机制吗？一个变量可以同时读和写，会降低 Rust 的安全性吧。如果你也这样想，就表示你对 Rust 的所有权和安全性的理解是不错的。</p><p>是的，就是会有这个问题。那为什么还有这个语法呢？</p><p>主要原因是，编译器不可能做到尽善尽美，太死的限制会导致我们编码遇到很大的问题（在我看来，限制太多是导致 Rust 学习曲线陡峭的主要原因之一）。而当你对自己代码很有信心时，你就可以通过 Cell 和 RefCell 来绕过所有权的限制。所以<strong>用这个语法后你需要自己保证数据的安全性。</strong></p><p>因此这个语法在实际业务类编码当中用得比较少，反而在一些基础库中是一个常见用法。在我们要实现某些很基础功能的时候，你应该就会用到它。对它有兴趣，你可以看<a href=\"https://course.rs/advance/smart-pointer/cell-refcell.html\">《Cell 与 RefCell 内部可变性》</a>，再去看看这个库<a href=\"https://crates.io/crates/dashmap\">《DashMap》</a>的源码。</p><p>接下来我们来看看并发编程和 Tokio。</p><h2>异步编程和 Tokio</h2><p>在任何语言中，并发编程都是语言的核心，在 Rust 中也是一样的。从学习资料的角度，建议你先看<a href=\"https://course.rs/advance/async/intro.html\">《async/await 异步编程》</a>，然后再看这两个资料<a href=\"https://docs.rs/tokio/latest/tokio/\">《Tokio 官网》</a>和<a href=\"https://rust-book.junmajinlong.com/ch100/00.html\">《Rust 异步编程和 Tokio 框架》</a>，基本就对 Rust 异步编程有个大概的了解了。这三份资料大部分在讲异步编程的底层原理，目的是帮助你更好地理解 Rust 异步编程，这部分反复看到能理解就可以。</p><p>从实际编码的角度，使用方式很简单，主要就是对 async、await、tokio 的使用。从功能上看，这三者的关系是：<strong>async 定义异步代码块，然后在</strong> <strong>Tokio（Runtime）里面调用代码块的 .await 方法，运行这个异步任务</strong>。</p><p>接下来来看一段实际的业务代码。</p><pre><code class=\"language-plain\">let runtime = create_runtime(\n      \"storage-engine-server-runtime\",\n      conf.system.runtime_worker_threads,\n);\n\n\npub async fn report_heartbeat(client_poll: Arc&lt;ClientPool&gt;, stop_send: broadcast::Sender&lt;bool&gt;) {\n    loop {\n        let mut stop_recv = stop_send.subscribe();\n        select! {\n            val = stop_recv.recv() =&gt;{\n                match val{\n                    Ok(flag) =&gt; {\n                        if flag {\n                            debug(format!(\"Heartbeat reporting thread exited successfully\"));\n                            break;\n                        }\n                    }\n                    Err(_) =&gt; {}\n                }\n            }\n            _ = report(client_poll.clone()) =&gt; {\n\n\n            }\n        }\n    }\n}\n\n\nruntime.spawn(async move {\n    report_heartbeat(client_poll, stop_send).await;\n});\n</code></pre><p>在上面的代码中：</p><ol>\n<li>\n<p>通过 create_runtime 创建一个 Tokio Runtime。</p>\n</li>\n<li>\n<p>通过 async 定义一个名为 report_heartbeat 的异步运行的函数。这个函数的功能是定时上报心跳。</p>\n</li>\n<li>\n<p>将report_heartbeat函数放在 Runtime 里面运行，Runtime 里面再通过.await 方法驱动异步任务运行。</p>\n</li>\n</ol><p>这段代码是经典的Rust 异步编程的实现，其他的实现基本都是这段代码的变种。<strong>在实际编码中，你还需要重点理解一下</strong> <strong>Rust 闭包的用法，经常<strong><strong>会</strong></strong>用到</strong>。具体可以看这个资料<a href=\"https://course.rs/advance/functional-programing/closure.html\">《闭包 Closure》</a>。</p><p>在上面的例子中，异步任务是运行在 Tokio Runtime 中的。接下来通过一张图，来理解一下 Tokio 是什么，以及 Rust 异步编程（async/await）和 Tokio 的关系。</p><p><img src=\"https://static001.geekbang.org/resource/image/8f/b1/8fe01bb275e53ff51539aed8b03545b1.jpeg?wh=1920x1080\" alt=\"图片\"></p><p>如上图所示，Tokio（Runtime）是 Rust 异步编程的一种实现。在 Rust 中，官方是没有提供给异步任务运行的地方（也就是 Runtime），是依赖社区提供的 Runtime，比较主流的实现有 Tikio、async-std 等等。<strong>随着社区的发展，<strong><strong>T</strong></strong>ikio 是实现最好</strong><strong>、</strong><strong>性能最高的一个，逐步成为了唯一的选择</strong>。</p><p>Tokio 是一个生态，Runtime只是它的一部分。它还包含下面这些生态库（详细信息看 <a href=\"https://tokio.rs/\">Tokio 官网</a>）：</p><ul>\n<li>\n<p><strong>Hyper</strong>：支持 HTTP 1 和 2 协议的 HTTP 客户端和服务器库。</p>\n</li>\n<li>\n<p><strong>Tonic</strong>：gRPC 客户端和服务器库。</p>\n</li>\n<li>\n<p><strong>Tower</strong>：用于构建可靠客户端和服务器的模块化组件，包括重试、负载平衡、过滤、请求限制功能等。</p>\n</li>\n<li>\n<p><strong>Mio</strong>：操作系统事件 I/O API 之上的最小可移植 API。</p>\n</li>\n<li>\n<p><strong>Tracing</strong>：对应用程序和库的统一洞察，提供结构化、基于事件的数据收集和记录。</p>\n</li>\n<li>\n<p><strong>Bytes</strong>：网络应用程序的核心是操作字节流，Bytes 提供了一组丰富的实用程序来操作字节数组。</p>\n</li>\n</ul><p>从编码常用功能的角度，Tokio 还实现了异步版本的 <a href=\"https://rust-book.junmajinlong.com/ch100/05_task_communication.html\">channel</a>、<a href=\"https://rust-book.junmajinlong.com/ch100/06_task_state_sync.html\">Mutex</a><a href=\"https://rust-book.junmajinlong.com/ch100/06_task_state_sync.html\">、</a><a href=\"https://rust-book.junmajinlong.com/ch100/06_task_state_sync.html\">RwLock</a><a href=\"https://rust-book.junmajinlong.com/ch100/06_task_state_sync.html\">、</a><a href=\"https://rust-book.junmajinlong.com/ch100/06_task_state_sync.html\">Notify</a><a href=\"https://rust-book.junmajinlong.com/ch100/06_task_state_sync.html\">、</a><a href=\"https://rust-book.junmajinlong.com/ch100/06_task_state_sync.html\">Barrier</a><a href=\"https://rust-book.junmajinlong.com/ch100/06_task_state_sync.html\">、</a><a href=\"https://rust-book.junmajinlong.com/ch100/06_task_state_sync.html\">Semaphore</a> 等实现，来提供线程间的数据通信以及状态同步、协调等等。其中 channel 和 lock 在编码过程中会大量用到，这块需要重点学习。</p><p>从学习 Tokio 的角度看，你首先要理解它的 Runtime 实现，然后再根据自己的需要了解对应的生态库，然后在编码中领会 Tokio 各种 channel 和 lock 等的使用。</p><p>最后，放一张 Tokio 内核运行原理的架构图。你可以结合上面推荐的资料来理解它，这里就不展开了。</p><p><img src=\"https://static001.geekbang.org/resource/image/45/65/453c62fcd20a982cfdc34dc4e174b665.jpeg?wh=1920x1080\" alt=\"图片\"></p><p>最后，再来看看测试用例。</p><h2>测试用例</h2><p>Rust 的测试用例从语法上看比较简单，主要关注 assert_eq! 和 assert! 两个语法，就不展开讲了，详细资料可以参考这个文档<a href=\"https://course.rs/test/intro.html\">《自动化测试》</a>。测试用例的核心操作是通过 assert 来判断数据是否符合预期，比如：</p><pre><code class=\"language-plain\">assert_eq!(res.len(), 2); # 判断res 的长度是否等于 2，等于 2 就成功，不等于 2 就失败\nassert!(!res.is_none()); # 判断 res 是否为 none\n</code></pre><p>在实际场景中，<strong>写测试用例关注的主要不是语法，而是如何写一个好的测试用例来验证我们的代码逻辑是没问题的。</strong>那怎么写呢？来看个实际的例子。</p><pre><code class=\"language-plain\">#[cfg(test)]\nmod tests {\n    use std::sync::Arc;\n    use crate::storage::mqtt::topic::MQTTTopicStorage;\n    use crate::storage::rocksdb::RocksDBEngine;\n    use common_base::config::placement_center::PlacementCenterConfig;\n    use metadata_struct::mqtt::topic::MQTTTopic;\n\n\n    #[tokio::test]\n    async fn topic_storage_test() {\n        let mut config = PlacementCenterConfig::default();\n        config.data_path = \"/tmp/tmp_test\".to_string();\n        config.data_path = \"/tmp/tmp_test\".to_string();\n        let rs = Arc::new(RocksDBEngine::new(&amp;config));\n        let topic_storage = MQTTTopicStorage::new(rs);\n        let cluster_name = \"test_cluster\".to_string();\n        let topic_name = \"loboxu\".to_string();\n        \n        # 1. 保存数据\n        let topic = MQTTTopic {\n            topic_id: \"xxx\".to_string(),\n            topic_name: topic_name.clone(),\n            retain_message: None,\n            retain_message_expired_at: None,\n        };\n        \n        topic_storage\n            .save(&amp;cluster_name, &amp;topic_name, topic)\n            .unwrap();\n\n\n        \n        # 2. 保存数据\n        let topic_name = \"lobo1\".to_string();\n        let topic = MQTTTopic {\n            topic_id: \"xxx\".to_string(),\n            topic_name: topic_name.clone(),\n            retain_message: None,\n            retain_message_expired_at: None,\n        };\n        topic_storage\n            .save(&amp;cluster_name, &amp;topic_name, topic)\n            .unwrap();\n\n\n        # 3. 判断是否写入两条数据\n        let res = topic_storage.list(&amp;cluster_name).unwrap();\n        assert_eq!(res.len(), 2);\n\n\n        let res = topic_storage\n            .get(&amp;cluster_name, &amp;\"lobo1\".to_string())\n            .unwrap();\n        assert!(!res.is_none());\n\n\n        # 4. 删除一条数据\n        let name = \"lobo1\".to_string();\n        topic_storage.delete(&amp;cluster_name, &amp;name).unwrap();\n\n\n        # 5. 判断数据是否存在\n        let res = topic_storage\n            .get(&amp;cluster_name, &amp;\"lobo1\".to_string())\n            .unwrap();\n        assert!(res.is_none());\n    }\n}\n</code></pre><p>这是一个很典型的测试用例。其功能是：判断 MQTTTopicStorage 这个对象中的数据增删改查的代码行为是否符合预期。在代码中，第 1 和 2 步，保存了两行数据，第3 步判断是否成功写入两条数据，第4步删除数据，第5步判断数据是否删除成功。通过这五个步骤，完成了逻辑验证的闭环。</p><p>这段代码的核心是通过不同的 assert 操作来验证逻辑的闭环。而这也是我们写测试用例的目标。所以我们在写测试用例的时候，重要的是<strong>逻辑闭环，即能够通过获取各个操作的结果，来判断行为是否符合预期</strong>。</p><p>关于在实际业务中，如何通过集成测试来保证代码质量，我们后面再详细展开讲。</p><h2>总结</h2><p>这节课我们挑了几个在写分布式应用过程中需要重点了解的知识点来展开讲。内容相对比较精简，但都给了对应的资料地址，当你对知识点有疑惑时，应该跳转到对应的资料去看。只要能看透，基本就能掌握相关知识点。</p><p>不过要想用 Rust 真正写一个工业应用，你还得把课程开头的《Rust 知识点集合》100% 掌握才行。Rust 是一门学习成本较高的语言，就是需要你反复地去学习和体会各个语法和特性。</p><h2>思考题</h2><p>你觉得我们的《Rust 知识点集合》还缺少哪些内容呢？</p><p>欢迎补充，如果今天的课程对你有所帮助，也欢迎你转发给有需要的同学，我们下节课再见！</p>","neighbors":{"left":{"article_title":"01｜以终为始：手写开源消息队列最终成果展示","id":807569},"right":{"article_title":"03｜正式开工：如何组织、编译、打包复杂的Rust项目？","id":808932}},"comments":[]}