{"id":777720,"title":"16｜表达式类型及其基本性质","content":"","comments":[{"had_liked":false,"id":390948,"user_name":"Jack Q","can_delete":false,"product_type":"c3","uid":1160078,"ip_address":"广东","ucode":"A7DBC311884FFA","user_header":"https://static001.geekbang.org/account/avatar/00/11/b3/8e/1c564eb2.jpg","comment_is_top":false,"comment_ctime":1716822824,"is_pvip":false,"replies":[{"id":142185,"content":"Q1-1：其实并不是所有的keyof都会惰性，也并不是所有的表现出来“结果未求值”的情况都是惰性。这个问题涉及到TypeScript如何显式或表示结果。在这一点上，第25讲还会有一个review，到时候你再看看。但简单的来说，就是惰性求值是存在的，但“并不总是”字面结果所表现出来的那样。\n\nQ1-2：keyof F的结果是never，是因为keyof一个联合，结果会是各分量的keyof的交叉（keyof U1 &amp; .. &amp; keyof Un）。你提了一个在第19讲才会讲的知识点。不过第17讲也略有提及，你可以先看看。:)\n\nQ2：这个就离了大谱了^^. 这个问题在第18讲末尾专门提了出来，但是也是在第19才详细分析的。这个分析花了不小的篇幅……所以……这里很难讲清楚呵。建议你等到下周……\n\n所以，你看哈，我们这个课程吧，就是讲得细，啥都会讲到。之所以要讲到29讲之后才会说体操什么的，就是因为现在讲的这些基础知识点比较多，真是又碎又多。但是呢，一个知识点讲不明白，后面就是一坨东西说不清楚。——关键是吧，TypeScript的官方资料在这些问题上又没个章法，没个明确概念，所以很多时候大家都是靠猜的（真的呵，你要看TS在git上的issues就知道，很多时候大家都是在猜结果呵）。至于本课程呢，当“表达式类型”这个概念提出来之后，其实很多东西就能解释了。而官方资料……其实没这个概念。顺道说，惰性求值这个概念也没有官方的解释，官方资料只提了延迟（Deferred）这种现象……而且还没给解释。\n\n我还是慢慢讲着吧。","user_name":"作者回复","user_name_real":"作者","uid":1521669,"ctime":1716962019,"ip_address":"江苏","comment_id":390948,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100761001,"comment_content":"&#47;&#47; 作业1:六种表达式语法\n\nconst booleanVar = true;\nconst numberVar = 1;\nconst objectVar = { a: 1, b: &#39;2&#39;, c: false, d: [&#39;list&#39;], f: { g: null  } };\ninterface A {\n  a: string,\n  b: number,\n  c: boolean,\n}\ntype B = string[]; &#47;&#47; Array&lt;string&gt;\ntype C = [1, &#39;number&#39;, true]; &#47;&#47; tunple\ntype D = {\n  d: string,\n  e: number,\n  f: true[]\n};\ntype F = A | B; &#47;&#47; Unions\ntype G = A &amp; B; &#47;&#47; Intersections\ntype G1 = { g: string; h: null } &amp; { i: boolean; j: number }; &#47;&#47; Intersections\nenum H {\n  l,\n  m\n}\nenum I {\n  m = &#39;3&#39;,\n  n = &#39;4&#39;\n}\n&#47;&#47; typeof\ntype bvT = typeof booleanVar;\ntype nvT = typeof numberVar;\ntype ovT = typeof objectVar;\n&#47;&#47; T[key]\ntype AP = A[&#39;a&#39;]; &#47;&#47; string\ntype BP = B[number]; &#47;&#47; string\ntype CN = C[number]; &#47;&#47; 1 | &#39;number&#39; | true\ntype C0 = C[0]; &#47;&#47; 1\n&#47;&#47; keyof T （T 会被立即求值）\ntype AK = keyof A; &#47;&#47; 惰性求值，其表达式类型等同于 &quot;a&quot;|&quot;b&quot;|&quot;c&quot;\ntype BK = keyof C; &#47;&#47; 惰性求值, 其表达式类型等同于 keyof Array\nlet e: BK = 0;&#47;&#47; correct\ne = 1; &#47;&#47; correct\ne = &#39;toString&#39;;&#47;&#47; correct\ne = &#39;includes&#39;;&#47;&#47; correct\ne = &#39;a&#39;; &#47;&#47; wrong\n&#47;&#47; 疑问：AK \\ BK \\ GK 出现惰性求值的现象，但是  FK 和 GK1 却出现了 立即求值。为什么会出现这种情况呢？ typeof F 为什么会是 never，语意上如何解释？\ntype FK = keyof F; &#47;&#47; never\ntype GK = keyof G; &#47;&#47; 惰性求值(keyof A | keyof B)，其表达式类型等同于 &quot;a&quot;|&quot;b&quot;|&quot;c&quot;|&quot;d&quot;|&quot;e&quot;|&quot;f&quot;\ntype G1K = keyof G1; &#47;&#47; &quot;g&quot; | &quot;h&quot; | &quot;i&quot; | &quot;j&quot;\n&#47;&#47; A &amp; B \ntype AAB = A &amp; B;&#47;&#47; 惰性求值\nlet f:AAB = Object.assign({\n  a: &#39;1&#39;,\n  b: 1,\n  c: true\n}, [&#39;0&#39;]);\ntype AAD  = A &amp; D;&#47;&#47; 惰性求值\nlet g: AAD = {\n  a: &#39;1&#39;,\n  b: 1,\n  c: true,\n  d: &#39;2&#39;,\n  e: 2,\n  f: [true]\n}\ntype HAI = H &amp; I;&#47;&#47; never\n&#47;&#47; A | B \ntype AOB = A | B; &#47;&#47;惰性求值\nlet k: AOB = {\n  a: &#39;1&#39;,\n  b: 1,\n  c: true,\n};\nk = [&#39;1&#39;];\ntype BOC = B | C; &#47;&#47;惰性求值\nlet l: BOC = [&#39;1&#39;];\nl = [1, &quot;number&quot;, true];\ntype HOI = H | I; &#47;&#47;惰性求值\n&#47;&#47; 疑问: 枚举的联合语法是上允许的, 语意上要怎么解释呢？ 其类型值最终到底是什么? \nlet m: HOI = H;&#47;&#47; wrong\nm = I;&#47;&#47; wrong\nm = {\n  ...H,\n  ...I\n} &#47;&#47; wrong\n} &#47;&#47; wrong\n&#47;&#47; (第一部分)","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645890,"discussion_content":"Q1-1：其实并不是所有的keyof都会惰性，也并不是所有的表现出来“结果未求值”的情况都是惰性。这个问题涉及到TypeScript如何显式或表示结果。在这一点上，第25讲还会有一个review，到时候你再看看。但简单的来说，就是惰性求值是存在的，但“并不总是”字面结果所表现出来的那样。\n\nQ1-2：keyof F的结果是never，是因为keyof一个联合，结果会是各分量的keyof的交叉（keyof U1 & .. & keyof Un）。你提了一个在第19讲才会讲的知识点。不过第17讲也略有提及，你可以先看看。:)\n\nQ2：这个就离了大谱了^^. 这个问题在第18讲末尾专门提了出来，但是也是在第19才详细分析的。这个分析花了不小的篇幅……所以……这里很难讲清楚呵。建议你等到下周……\n\n所以，你看哈，我们这个课程吧，就是讲得细，啥都会讲到。之所以要讲到29讲之后才会说体操什么的，就是因为现在讲的这些基础知识点比较多，真是又碎又多。但是呢，一个知识点讲不明白，后面就是一坨东西说不清楚。——关键是吧，TypeScript的官方资料在这些问题上又没个章法，没个明确概念，所以很多时候大家都是靠猜的（真的呵，你要看TS在git上的issues就知道，很多时候大家都是在猜结果呵）。至于本课程呢，当“表达式类型”这个概念提出来之后，其实很多东西就能解释了。而官方资料……其实没这个概念。顺道说，惰性求值这个概念也没有官方的解释，官方资料只提了延迟（Deferred）这种现象……而且还没给解释。\n\n我还是慢慢讲着吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1716962020,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":393327,"user_name":"Geek_aeb936","can_delete":false,"product_type":"c3","uid":3887128,"ip_address":"日本","ucode":"863338D4895F25","user_header":"","comment_is_top":false,"comment_ctime":1723519796,"is_pvip":false,"replies":[{"id":142846,"content":"keyof T2的结果是&quot;a&quot;|&quot;b&quot;，是字符串的联合。使用Omit&lt;&gt;取字符串（字面量或string）的键时，会取它对应的包装类，也就是String的keyof。所以\n```\nTrans&lt;keyof T2&gt;\n   === Trans&lt;&quot;a&quot; | &quot;b&quot;&gt;\n   === Omit&lt;&quot;a&quot; | &quot;b&quot;, never&gt;\n   === Omit&lt;String | String, never&gt;\n   === Omit&lt;String, never&gt;\n   === {\n\n    readonly [x: number]: string;\n    [Symbol.iterator]: () =&gt; StringIterator&lt;string&gt;;\n    。。。\n```\n所以就看到了你说的这个X1。\n\n再多说一点，在Omit&lt;T&gt;的内部是通过Pick&lt;T&gt;来实现的，并且进一步地通过映射keyof T的所有成员来列取T并筛选。由于传入Omit&lt;&gt;的T是&#39;a&#39;这个字面量字符串，所以最终传递到keyof T进行成员列举时，实际上是取的keyof &#39;a&#39;。——而keyof取一个字面量字符串类型（或string类型）时，实际上操作的是对应的keyof String。关于keyof的这个特性，在19讲中会讲到。\n\n这才是Omit&lt;&#39;a&#39;&gt; === Omit&lt;String&gt;的原因。","user_name":"作者回复","user_name_real":"编辑","uid":1521669,"ctime":1723563614,"ip_address":"江苏","comment_id":393327,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100761001,"comment_content":"type Trans&lt;T&gt; = Omit&lt;T, never&gt;; \n\ninterface T1 {\n    a: string;\n}\n\ninterface T2 {\n    a: string;\n    b: number;\n}\n\ntype X1 = Trans&lt;keyof T2&gt;;\ntype X2 = T1 &amp; T2;\ntype X3 = Trans&lt;T1 &amp; T2&gt;;\n\n&#47;&#47; https:&#47;&#47;github.com&#47;aimingoo&#47;jike2&#47;blob&#47;e6b5dc6972f43a290e23ac02527ac8c80c664e4e&#47;src&#47;16&#47;t.ts\n\n老师好 回顾这个例子 还是不明白为什么X1得类型是：\n\n```typescript\ntype X1 = {\n    readonly [x: number]: string;\n    [Symbol.iterator]: () =&gt; StringIterator&lt;string&gt;;\n    toString: () =&gt; string;\n    charAt: (pos: number) =&gt; string;\n    charCodeAt: (index: number) =&gt; number;\n    concat: (...strings: string[]) =&gt; string;\n    ... 43 more ...;\n    at: (index: number) =&gt; string | undefined;\n}\n```","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":649549,"discussion_content":"keyof T2的结果是&#34;a&#34;|&#34;b&#34;，是字符串的联合。使用Omit&lt;&gt;取字符串（字面量或string）的键时，会取它对应的包装类，也就是String的keyof。所以\n```\nTrans&lt;keyof T2&gt;\n   === Trans&lt;&#34;a&#34; | &#34;b&#34;&gt;\n   === Omit&lt;&#34;a&#34; | &#34;b&#34;, never&gt;\n   === Omit&lt;String | String, never&gt;\n   === Omit&lt;String, never&gt;\n   === {\n\n    readonly [x: number]: string;\n    [Symbol.iterator]: () =&gt; StringIterator&lt;string&gt;;\n    。。。\n```\n所以就看到了你说的这个X1。\n\n再多说一点，在Omit&lt;T&gt;的内部是通过Pick&lt;T&gt;来实现的，并且进一步地通过映射keyof T的所有成员来列取T并筛选。由于传入Omit&lt;&gt;的T是&#39;a&#39;这个字面量字符串，所以最终传递到keyof T进行成员列举时，实际上是取的keyof &#39;a&#39;。——而keyof取一个字面量字符串类型（或string类型）时，实际上操作的是对应的keyof String。关于keyof的这个特性，在19讲中会讲到。\n\n这才是Omit&lt;&#39;a&#39;&gt; === Omit&lt;String&gt;的原因。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1723563614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":390949,"user_name":"Jack Q","can_delete":false,"product_type":"c3","uid":1160078,"ip_address":"广东","ucode":"A7DBC311884FFA","user_header":"https://static001.geekbang.org/account/avatar/00/11/b3/8e/1c564eb2.jpg","comment_is_top":false,"comment_ctime":1716822856,"is_pvip":false,"replies":[{"id":142184,"content":"在 IsNeverArrayExtendsAnyArray 里面，[]可不是NeverArray，而是Tuple。","user_name":"作者回复","user_name_real":"编辑","uid":1521669,"ctime":1716957042,"ip_address":"江苏","comment_id":390949,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100761001,"comment_content":"&#47;&#47; A extends B\ntype UNKS = &#39;1&#39; | &#39;2&#39; | &#39;3&#39; | &#39;aa&#39;;\ntype UNK = &#39;1&#39; | &#39;2&#39; | &#39;3&#39;;\n\ntype KEYS = UNK extends UNKS ? UNK : never; &#47;&#47; UNK\n\ntype IsNeverArrayExtendsAnyArray = [] extends any[] ? true : false;\n\ntype MyPick&lt;T, K extends keyof T&gt; = {\n  [Key in keyof T &amp; K]: T[Key]\n}\n\n&#47;&#47; 作业2:单类型与表达式类型有什么不同\n\n&#47;&#47; 单类型可以是视作没有操作符的表达式类型, 所以最主要的不同点就是 有没有 操作符\n\n&#47;&#47; (第二部分)","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645884,"discussion_content":"在 IsNeverArrayExtendsAnyArray 里面，[]可不是NeverArray，而是Tuple。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1716957043,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]}]}