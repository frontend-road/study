{"id":640990,"title":"04｜增强IoC容器：如何让我们的Spring支持注解？","content":"<p>你好，我是郭屹。</p><p>上节课我们通过一系列的操作使XML使配置文件生效，然后实现了Spring中Bean的构造器注入与setter注入，通过引入“早期毛胚Bean”的概念解决了循环依赖的问题，我们还为容器增加了Spring中的一个核心方法refresh()，作为整个容器启动的入口。现在我们的容器已经初具模型了，那如何让它变得更强大，从种子长成一株幼苗呢？</p><p>这节课我们就来实现一个增强版的IoC容器，支持通过注解的方式进行依赖注入。注解是我们在编程中常用的技术，可以减少配置文件的内容，便于管理的同时还能提高开发效率。所以这节课我们将<strong>实现Autowired注解，并用这个方式进行依赖注入</strong>。</p><h2>目录结构</h2><p>我们手写MiniSpring的目的是更好地学习Spring。因此，我们会时不时回头来整理整个项目的目录结构，和Spring保持一致。</p><p>现在我们先参考Spring框架的结构，来调整我们的项目结构，在beans目录下新增factory目录，factory目录中则新增xml、support、config与annotation四个目录。</p><pre><code class=\"language-java\">├── beans\n│&nbsp; &nbsp;└── factory\n│&nbsp; &nbsp; &nbsp; &nbsp;├── xml\n│&nbsp; &nbsp; &nbsp; &nbsp;└── support\n│&nbsp; &nbsp; &nbsp; &nbsp;└── config\n│&nbsp; &nbsp; &nbsp; &nbsp;└── annotation\n</code></pre><!-- [[[read_end]]] --><p>接下来将之前所写的类文件移动至新增目录下，你可以看一下移动后的结构。</p><pre><code class=\"language-java\">factory —— BeanFactory.java\nfactory.xml —— XmlBeanDefinitionReader.java\nfactory.support —— DefaultSingletonBeanRegistry.java、\nBeanDefinitionRegistry.java、SimpleBeanFactory.java\nfactory.config —— SingletonBeanRegistry.java、ConstructorArgumentValues.java、\nConstructorArgumentValue.java、BeanDefinition.java\n\n// 注：\n// ConstructorArgumentValues由ArgumentValues改名而来\n// ConstructorArgumentValue由ArgumentValue改名而来\n</code></pre><p>熟悉了这个项目结构后，你再回头去看Spring框架的结构，会发现它们是一样的，不光目录一样，文件名也是一样的，类中的主要方法名和属性名也是一样的。我这么做的目的是便于你之后自己继续学习。</p><h2>注解支持</h2><p>如果你用过Spring的话，对Autowired注解想必不陌生，这也是常用的依赖注入的方式，在需要注入的对象上增加@Autowired注解就可以了，你可以参考下面这个例子。</p><pre><code class=\"language-java\">public class Test {\n  @Autowired\n  private TestAutowired testAutowired;\n}\n</code></pre><p>这种方式的好处在于，不再需要显式地在XML配置文件中使用ref属性，指定需要依赖的对象，直接在代码中加上这个注解，就能起到同样的依赖注入效果。但是你要知道，计算机运行程序是机械式的，并没有魔法，加的这一行注解不会自我解释，必须有另一个程序去解释它，否则注解就变成了注释。</p><p>那么，问题就来了，<strong>我们要在哪一段程序、哪个时机去解释这个注解呢？</strong></p><p>简单分析一下，这个注解是作用在一个实例变量上的，为了生效，我们首先必须创建好这个对象，也就是在createBean时机之后。</p><p>回顾前面几节课的内容，我们通过一个refresh()方法包装了整个Bean的创建过程，我们能看到在创建Bean实例之后，要进行初始化工作，refresh()方法内预留了postProcessBeforeInitialization、init-method与postProcessAfterInitialization的位置，根据它们的名称也能看出是在初始化前、中、后分别对Bean进行处理。这里就是很好的时机。</p><p>接下来我们一起看看这些功能是如何实现的。</p><p>在这个预留的位置，我们可以考虑调用一个Bean处理器Processor，由处理器来解释注解。我们首先来定义BeanPostProcessor，它内部的两个方法分别用于Bean初始化之前和之后。</p><ol>\n<li>Bean初始化之前</li>\n</ol><pre><code class=\"language-java\">public interface BeanPostProcessor {\n    Object postProcessBeforeInitialization(Object bean, String beanName) throws \nBeansException;\n}\n</code></pre><ol start=\"2\">\n<li>Bean初始化之后</li>\n</ol><pre><code class=\"language-java\">public interface BeanPostProcessor {\n&nbsp; &nbsp; Object postProcessAfterInitialization(Object bean, String beanName) throws&nbsp;\nBeansException;\n}\n</code></pre><p>接下来我们定义Autowired注解，很简单，你可以参考一下。</p><pre><code class=\"language-java\">@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Autowired {\n}\n</code></pre><p>根据这个定义可以知道，Autowired修饰成员变量（属性），并且在运行时生效。</p><p>为了实现@Autowired这个注解，我们很自然地会想到，利用反射获取所有标注了Autowired注解的成员变量，把它初始化成一个Bean，然后注入属性。结合前面我们定义的BeanPostProcessor接口，我们来定义Autowired的处理类AutowiredAnnotationBeanPostProcessor。</p><pre><code class=\"language-java\">public class AutowiredAnnotationBeanPostProcessor implements BeanPostProcessor {\n&nbsp; &nbsp; private AutowireCapableBeanFactory beanFactory;\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; @Override\n&nbsp; &nbsp; public Object postProcessBeforeInitialization(Object bean, String beanName)&nbsp;\nthrows BeansException {\n&nbsp; &nbsp; &nbsp; &nbsp; Object result = bean;\n&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Class&lt;?&gt; clazz = bean.getClass();\n&nbsp; &nbsp; &nbsp; &nbsp; Field[] fields = clazz.getDeclaredFields();\n&nbsp; &nbsp; &nbsp; &nbsp; if(fields!=null){\n            //对每一个属性进行判断，如果带有@Autowired注解则进行处理\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for(Field field : fields){\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; boolean isAutowired =&nbsp;\nfield.isAnnotationPresent(Autowired.class);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(isAutowired){\n                    //根据属性名查找同名的bean\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String fieldName = field.getName();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object autowiredObj =&nbsp;\nthis.getBeanFactory().getBean(fieldName);\n                    //设置属性值，完成注入\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; field.setAccessible(true);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; field.set(bean, autowiredObj);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(\"autowire \" + fieldName + \" for bean&nbsp;\n\" + beanName);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } \n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; return result;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; @Override\n&nbsp; &nbsp; public Object postProcessAfterInitialization(Object bean, String beanName)&nbsp;\nthrows BeansException {\n&nbsp; &nbsp; &nbsp; &nbsp; return null;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; public AutowireCapableBeanFactory getBeanFactory() {\n&nbsp; &nbsp; &nbsp; &nbsp; return beanFactory;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; public void setBeanFactory(AutowireCapableBeanFactory beanFactory) {\n&nbsp; &nbsp; &nbsp; &nbsp; this.beanFactory = beanFactory;\n&nbsp; &nbsp; }\n}\n\n</code></pre><p>其实，核心代码就只有几行。</p><pre><code class=\"language-java\">boolean isAutowired = field.isAnnotationPresent(Autowired.class);\nif(isAutowired){\n&nbsp; &nbsp; String fieldName = field.getName();\n    Object autowiredObj =&nbsp; this.getBeanFactory().getBean(fieldName);\n&nbsp; &nbsp; field.setAccessible(true);\n&nbsp; &nbsp; field.set(bean, autowiredObj);\n</code></pre><p>判断类里面的每一个属性是不是带有Autowired注解，如果有，就根据属性名获取Bean。从这里我们可以看出，属性名字很关键，我们就是靠它来获取和创建的Bean。有了Bean之后，我们通过反射设置属性值，完成依赖注入。</p><h2>新的BeanFactory</h2><p>在这里我们引入了AutowireCapableBeanFactory，这个BeanFactory就是专为Autowired注入的Bean准备的。</p><p>在此之前我们已经定义了BeanFactory接口，以及一个SimpleBeanFactory的实现类。现在我们又需要引入另外一个BeanFactory——<strong>AutowireCapableBeanFactory</strong>。基于代码复用、解耦的原则，我们可以对通用部分代码进行抽象，抽象出一个AbstractBeanFactory类。</p><p>目前，我们可以把refresh()、getBean()、registerBeanDefinition()等方法提取到抽象类，因为我们提供了默认实现，确保这些方法即使不再被其他BeanFactory实现也能正常生效。改动比较大，所以这里我贴出完整的类代码，下面就是AbstractBeanFactory的完整实现。</p><pre><code class=\"language-java\">public abstract class AbstractBeanFactory extends DefaultSingletonBeanRegistry&nbsp;\nimplements BeanFactory, BeanDefinitionRegistry {\n&nbsp; &nbsp; private Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new&nbsp;\nConcurrentHashMap&lt;&gt;(256);\n&nbsp; &nbsp; private List&lt;String&gt; beanDefinitionNames = new ArrayList&lt;&gt;();\n&nbsp; &nbsp; private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;&gt;(16);\n&nbsp; &nbsp; public AbstractBeanFactory() {\n&nbsp; &nbsp; }\n&nbsp; &nbsp; public void refresh() {\n&nbsp; &nbsp; &nbsp; &nbsp; for (String beanName : beanDefinitionNames) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; getBean(beanName);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } \n&nbsp; &nbsp; &nbsp;   } \n&nbsp; &nbsp; }\n&nbsp; &nbsp; @Override\n&nbsp; &nbsp; public Object getBean(String beanName) throws BeansException {\n        //先尝试直接从容器中获取bean实例\n    &nbsp; &nbsp; Object singleton = this.getSingleton(beanName);\n&nbsp; &nbsp; &nbsp; &nbsp; if (singleton == null) {\n            //如果没有实例，则尝试从毛胚实例中获取\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; singleton = this.earlySingletonObjects.get(beanName);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (singleton == null) {\n                //如果连毛胚都没有，则创建bean实例并注册\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(\"get bean null -------------- \" + beanName);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BeanDefinition beanDefinition = beanDefinitionMap.get(beanName);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; singleton = createBean(beanDefinition);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.registerBean(beanName, singleton);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 进行beanpostprocessor处理\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // step 1: postProcessBeforeInitialization\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; applyBeanPostProcessorBeforeInitialization(singleton, beanName);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // step 2: init-method\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (beanDefinition.getInitMethodName() != null &amp;&amp;&nbsp;\n!beanDefinition.equals(\"\")) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invokeInitMethod(beanDefinition, singleton);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // step 3: postProcessAfterInitialization\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; applyBeanPostProcessorAfterInitialization(singleton, beanName);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n\n&nbsp; &nbsp; &nbsp; &nbsp; return singleton;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; private void invokeInitMethod(BeanDefinition beanDefinition, Object obj) {\n&nbsp; &nbsp; &nbsp; &nbsp; Class&lt;?&gt; clz = beanDefinition.getClass();\n&nbsp; &nbsp; &nbsp; &nbsp; Method method = null;\n&nbsp; &nbsp; &nbsp; &nbsp; try {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; method = clz.getMethod(beanDefinition.getInitMethodName());\n&nbsp; &nbsp; &nbsp; &nbsp; } \n&nbsp; &nbsp; &nbsp; &nbsp; try {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; method.invoke(obj);\n&nbsp; &nbsp; &nbsp; &nbsp; } \n&nbsp; &nbsp; }\n&nbsp; &nbsp; @Override\n&nbsp; &nbsp; public Boolean containsBean(String name) {\n&nbsp; &nbsp; &nbsp; &nbsp; return containsSingleton(name);\n&nbsp; &nbsp; }\n&nbsp; &nbsp;public void registerBean(String beanName, Object obj) {\n&nbsp; &nbsp; &nbsp; &nbsp; this.registerSingleton(beanName, obj);\n&nbsp; &nbsp; }\n&nbsp; &nbsp; @Override\n&nbsp; &nbsp; public void registerBeanDefinition(String name, BeanDefinition&nbsp;\nbeanDefinition) {\n&nbsp; &nbsp; &nbsp; &nbsp; this.beanDefinitionMap.put(name, beanDefinition);\n&nbsp; &nbsp; &nbsp; &nbsp; this.beanDefinitionNames.add(name);\n&nbsp; &nbsp; &nbsp; &nbsp; if (!beanDefinition.isLazyInit()) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; getBean(name);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } \n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n&nbsp; &nbsp; @Override\n&nbsp; &nbsp; public void removeBeanDefinition(String name) {\n&nbsp; &nbsp; &nbsp; &nbsp; this.beanDefinitionMap.remove(name);\n&nbsp; &nbsp; &nbsp; &nbsp; this.beanDefinitionNames.remove(name);\n&nbsp; &nbsp; &nbsp; &nbsp; this.removeSingleton(name);\n&nbsp; &nbsp; }\n&nbsp; &nbsp; @Override\n&nbsp; &nbsp; public BeanDefinition getBeanDefinition(String name) {\n&nbsp; &nbsp; &nbsp; &nbsp; return this.beanDefinitionMap.get(name);\n&nbsp; &nbsp; }\n&nbsp; &nbsp; @Override\n&nbsp; &nbsp; public boolean containsBeanDefinition(String name) {\n&nbsp; &nbsp; &nbsp; &nbsp; return this.beanDefinitionMap.containsKey(name);\n&nbsp; &nbsp; }\n&nbsp; &nbsp; @Override\n&nbsp; &nbsp; public boolean isSingleton(String name) {\n&nbsp; &nbsp; &nbsp; &nbsp; return this.beanDefinitionMap.get(name).isSingleton();\n&nbsp; &nbsp; }\n&nbsp; &nbsp; @Override\n&nbsp; &nbsp; public boolean isPrototype(String name) {\n&nbsp; &nbsp; &nbsp; &nbsp; return this.beanDefinitionMap.get(name).isPrototype();\n&nbsp; &nbsp; }\n&nbsp; &nbsp; @Override\n&nbsp; &nbsp; public Class&lt;?&gt; getType(String name) {\n&nbsp; &nbsp; &nbsp; &nbsp; return this.beanDefinitionMap.get(name).getClass();\n&nbsp; &nbsp; }\n&nbsp; &nbsp; private Object createBean(BeanDefinition beanDefinition) {\n&nbsp; &nbsp; &nbsp; &nbsp; Class&lt;?&gt; clz = null;\n        //创建毛胚bean实例\n&nbsp; &nbsp; &nbsp; &nbsp; Object obj = doCreateBean(beanDefinition);\n        //存放到毛胚实例缓存中\n&nbsp; &nbsp; &nbsp; &nbsp; this.earlySingletonObjects.put(beanDefinition.getId(), obj);\n&nbsp; &nbsp; &nbsp; &nbsp; try {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clz = Class.forName(beanDefinition.getClassName());\n&nbsp; &nbsp; &nbsp; &nbsp; } \n        //完善bean，主要是处理属性\n&nbsp; &nbsp; &nbsp; &nbsp; populateBean(beanDefinition, clz, obj);\n&nbsp; &nbsp; &nbsp; &nbsp; return obj;\n&nbsp; &nbsp; }\n    //doCreateBean创建毛胚实例，仅仅调用构造方法，没有进行属性处理\n&nbsp; &nbsp; private Object doCreateBean(BeanDefinition beanDefinition) {\n&nbsp; &nbsp; &nbsp; &nbsp; Class&lt;?&gt; clz = null;\n&nbsp; &nbsp; &nbsp; &nbsp; Object obj = null;\n&nbsp; &nbsp; &nbsp; &nbsp; Constructor&lt;?&gt; con = null;\n&nbsp; &nbsp; &nbsp; &nbsp; try {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clz = Class.forName(beanDefinition.getClassName());\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // handle constructor\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ConstructorArgumentValues constructorArgumentValues =&nbsp;\nbeanDefinition.getConstructorArgumentValues();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!constructorArgumentValues.isEmpty()) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Class&lt;?&gt;[] paramTypes = new Class&lt;?&gt;\n[constructorArgumentValues.getArgumentCount()];\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object[] paramValues = new&nbsp;\nObject[constructorArgumentValues.getArgumentCount()];\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt;&nbsp;\nconstructorArgumentValues.getArgumentCount(); i++) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ConstructorArgumentValue constructorArgumentValue =&nbsp;\nconstructorArgumentValues.getIndexedArgumentValue(i);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (\"String\".equals(constructorArgumentValue.getType()) ||&nbsp;\n\"java.lang.String\".equals(constructorArgumentValue.getType())) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramTypes[i] = String.class;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramValues[i] = constructorArgumentValue.getValue();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else if&nbsp;\n(\"Integer\".equals(constructorArgumentValue.getType()) ||&nbsp;\n\"java.lang.Integer\".equals(constructorArgumentValue.getType())) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramTypes[i] = Integer.class;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramValues[i] = Integer.valueOf((String)&nbsp;\nconstructorArgumentValue.getValue());\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else if (\"int\".equals(constructorArgumentValue.getType()))&nbsp;\n{\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramTypes[i] = int.class;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramValues[i] = Integer.valueOf((String)&nbsp;\nconstructorArgumentValue.getValue());\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramTypes[i] = String.class;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramValues[i] = constructorArgumentValue.getValue();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; con = clz.getConstructor(paramTypes);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; obj = con.newInstance(paramValues);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } \n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; } \n&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(beanDefinition.getId() + \" bean created. \" +&nbsp;\nbeanDefinition.getClassName() + \" : \" + obj.toString());\n&nbsp; &nbsp; &nbsp; &nbsp; return obj;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; private void populateBean(BeanDefinition beanDefinition, Class&lt;?&gt; clz,&nbsp;\nObject obj) {\n&nbsp; &nbsp; &nbsp; &nbsp; handleProperties(beanDefinition, clz, obj);\n&nbsp; &nbsp; }\n&nbsp; &nbsp; private void handleProperties(BeanDefinition beanDefinition, Class&lt;?&gt; clz,&nbsp;\nObject obj) {\n&nbsp; &nbsp; &nbsp; &nbsp; // handle properties\n&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(\"handle properties for bean : \" +&nbsp;\nbeanDefinition.getId());\n&nbsp; &nbsp; &nbsp; &nbsp; PropertyValues propertyValues = beanDefinition.getPropertyValues();\n        //如果有属性\n&nbsp; &nbsp; &nbsp; &nbsp; if (!propertyValues.isEmpty()) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; propertyValues.size(); i++) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PropertyValue propertyValue =&nbsp;\npropertyValues.getPropertyValueList().get(i);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String pType = propertyValue.getType();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String pName = propertyValue.getName();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object pValue = propertyValue.getValue();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; boolean isRef = propertyValue.getIsRef();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Class&lt;?&gt;[] paramTypes = new Class&lt;?&gt;[1];\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object[] paramValues = new Object[1];\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!isRef) { //如果不是ref，只是普通属性\n                    //对每一个属性，分数据类型分别处理\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (\"String\".equals(pType) ||&nbsp;\n\"java.lang.String\".equals(pType)) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramTypes[0] = String.class;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else if (\"Integer\".equals(pType) ||&nbsp;\n\"java.lang.Integer\".equals(pType)) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramTypes[i] = Integer.class;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else if (\"int\".equals(pType)) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramTypes[i] = int.class;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramTypes[i] = String.class;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramValues[0] = pValue;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {//is ref, create the dependent beans\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramTypes[0] = Class.forName(pType);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } \n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try {//再次调用getBean创建ref的bean实例\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramValues[0] = getBean((String) pValue);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n                //按照setXxxx规范查找setter方法，调用setter方法设置属性\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String methodName = \"set\" + pName.substring(0, 1).toUpperCase()&nbsp;\n+ pName.substring(1);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Method method = null;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; method = clz.getMethod(methodName, paramTypes);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } \n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; method.invoke(obj, paramValues);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } \n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n&nbsp; &nbsp; abstract public Object applyBeanPostProcessorBeforeInitialization(Object&nbsp;\nexistingBean, String beanName) throws BeansException;\n&nbsp; &nbsp; abstract public Object applyBeanPostProcessorAfterInitialization(Object&nbsp;\nexistingBean, String beanName) throws BeansException;\n}\n</code></pre><p>上面的代码较长，但仔细一看可以发现绝大多数是我们原本已经实现的方法，只是移动到了AbstractBeanFactory这个抽象类之中。最关键的代码是getBean()中的这一段。</p><pre><code class=\"language-java\">BeanDefinition beanDefinition = beanDefinitionMap.get(beanName);\nsingleton = createBean(beanDefinition);\nthis.registerBean(beanName, singleton);\n\n// beanpostprocessor\n// step 1: postProcessBeforeInitialization\napplyBeanPostProcessorBeforeInitialization(singleton, beanName);\n// step 2: init-method\nif (beanDefinition.getInitMethodName() != null &amp;&amp;&nbsp;\n!beanDefinition.equals(\"\")) {\n&nbsp; &nbsp; invokeInitMethod(beanDefinition, singleton);\n}\n// step 3: postProcessAfterInitialization\napplyBeanPostProcessorAfterInitialization(singleton, beanName);\n</code></pre><p>先获取Bean的定义，然后创建Bean实例，再进行Bean的后处理并初始化。在这个抽象类里，我们需要关注两个核心的改动。</p><ol>\n<li>定义了抽象方法applyBeanPostProcessorBeforeInitialization与applyBeanPostProcessorAfterInitialization，由名字可以看出，分别是在Bean处理类初始化之前和之后执行的方法。这两个方法交给具体的继承类去实现。</li>\n<li>在getBean()方法中，在以前预留的位置，实现了对Bean初始化前、初始化和初始化后的处理。</li>\n</ol><pre><code class=\"language-java\">  // step 1: postProcessBeforeInitialization\n  applyBeanPostProcessorBeforeInitialization(singleton, beanName);\n  // step 2: init-method\n  if (beanDefinition.getInitMethodName() != null &amp;&amp; !beanDefinition.equals(\"\")) {\n      invokeInitMethod(beanDefinition, singleton);\n  }\n  // step 3: postProcessAfterInitialization\n  applyBeanPostProcessorAfterInitialization(singleton, beanName);\n</code></pre><p>现在已经抽象出了一个AbstractBeanFactory，接下来我们看看具体的AutowireCapableBeanFactory是如何实现的。</p><pre><code class=\"language-java\">public class AutowireCapableBeanFactory extends AbstractBeanFactory{\n&nbsp; &nbsp; private final List&lt;AutowiredAnnotationBeanPostProcessor&gt; beanPostProcessors =&nbsp;\nnew ArrayList&lt;&gt;();\n&nbsp; &nbsp; public void addBeanPostProcessor(AutowiredAnnotationBeanPostProcessor&nbsp;\nbeanPostProcessor) {\n&nbsp; &nbsp; &nbsp; &nbsp; this.beanPostProcessors.remove(beanPostProcessor);\n&nbsp; &nbsp; &nbsp; &nbsp; this.beanPostProcessors.add(beanPostProcessor);\n&nbsp; &nbsp; }\n&nbsp; &nbsp; public int getBeanPostProcessorCount() {\n&nbsp; &nbsp; &nbsp; &nbsp; return this.beanPostProcessors.size();\n&nbsp; &nbsp; }\n&nbsp; &nbsp; public List&lt;AutowiredAnnotationBeanPostProcessor&gt; getBeanPostProcessors() {\n&nbsp; &nbsp; &nbsp; &nbsp; return this.beanPostProcessors;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; public Object applyBeanPostProcessorsBeforeInitialization(Object&nbsp;\nexistingBean, String beanName) throws BeansException {\n&nbsp; &nbsp; &nbsp; &nbsp; Object result = existingBean;\n&nbsp; &nbsp; &nbsp; &nbsp; for (AutowiredAnnotationBeanPostProcessor beanProcessor :&nbsp;\ngetBeanPostProcessors()) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; beanProcessor.setBeanFactory(this);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = beanProcessor.postProcessBeforeInitialization(result,&nbsp;\nbeanName);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (result == null) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return result;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; return result;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; public Object applyBeanPostProcessorsAfterInitialization(Object existingBean,&nbsp;\nString beanName) throws BeansException {\n&nbsp; &nbsp; &nbsp; &nbsp; Object result = existingBean;\n&nbsp; &nbsp; &nbsp; &nbsp; for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = beanProcessor.postProcessAfterInitialization(result,&nbsp;\nbeanName);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (result == null) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return result;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; return result;\n&nbsp; &nbsp; }\n}\n</code></pre><p>从代码里也可以看出，它实现起来并不复杂，用一个列表beanPostProcessors记录所有的Bean处理器，这样可以按照需求注册若干个不同用途的处理器，然后调用处理器。</p><pre><code class=\"language-java\">for (AutowiredAnnotationBeanPostProcessor beanProcessor :&nbsp;\ngetBeanPostProcessors()) {\n &nbsp; &nbsp;beanProcessor.setBeanFactory(this);\n &nbsp; &nbsp;result = beanProcessor.postProcessBeforeInitialization(result,&nbsp;\nbeanName);\n}\n</code></pre><p>代码一目了然，就是对每个Bean处理器，调用方法postProcessBeforeInitialization。<br>\n最后则是调整ClassPathXmlApplicationContext，引入的成员变量由SimpleBeanFactory改为新建的AutowireCapableBeanFactory，并在构造函数里增加上下文刷新逻辑。</p><pre><code class=\"language-java\">public ClassPathXmlApplicationContext(String fileName, boolean isRefresh) {\n&nbsp; &nbsp; &nbsp; &nbsp; Resource resource = new ClassPathXmlResource(fileName);\n&nbsp; &nbsp; &nbsp; &nbsp; AutowireCapableBeanFactory beanFactory = new&nbsp;\nAutowireCapableBeanFactory();\n&nbsp; &nbsp; &nbsp; &nbsp; XmlBeanDefinitionReader reader = new&nbsp;\nXmlBeanDefinitionReader(beanFactory);\n&nbsp; &nbsp; &nbsp; &nbsp; reader.loadBeanDefinitions(resource);\n&nbsp; &nbsp; &nbsp; &nbsp; this.beanFactory = beanFactory;\n&nbsp; &nbsp; &nbsp; &nbsp; if (isRefresh) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; refresh();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } \n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; public List&lt;BeanFactoryPostProcessor&gt; getBeanFactoryPostProcessors() {\n&nbsp; &nbsp; &nbsp; &nbsp; return this.beanFactoryPostProcessors;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; public void addBeanFactoryPostProcessor(BeanFactoryPostProcessor&nbsp;\npostProcessor) {\n&nbsp; &nbsp; &nbsp; &nbsp; this.beanFactoryPostProcessors.add(postProcessor);\n&nbsp; &nbsp; }\n&nbsp; &nbsp; public void refresh() throws BeansException, IllegalStateException {\n&nbsp; &nbsp; &nbsp; &nbsp; // Register bean processors that intercept bean creation.\n&nbsp; &nbsp; &nbsp; &nbsp; registerBeanPostProcessors(this.beanFactory);\n&nbsp; &nbsp; &nbsp; &nbsp; // Initialize other special beans in specific context subclasses.\n&nbsp; &nbsp; &nbsp; &nbsp; onRefresh();\n&nbsp; &nbsp; }\n&nbsp; &nbsp; private void registerBeanPostProcessors(AutowireCapableBeanFactory&nbsp;\nbeanFactory) {\n&nbsp; &nbsp; &nbsp; &nbsp; beanFactory.addBeanPostProcessor(new&nbsp;\nAutowiredAnnotationBeanPostProcessor());\n&nbsp; &nbsp; }\n&nbsp; &nbsp; private void onRefresh() {\n&nbsp; &nbsp; &nbsp; &nbsp; this.beanFactory.refresh();\n&nbsp; &nbsp; }\n</code></pre><p>新的refresh()方法，会先注册BeanPostProcessor，这样BeanFactory里就有解释注解的处理器了，然后在getBean()的过程中使用它。</p><p>最后，我们来回顾一下完整的过程。</p><ol>\n<li>启动ClassPathXmlApplicationContext容器，执行refresh()。</li>\n<li>在refresh执行过程中，调用registerBeanPostProcessors()，往BeanFactory里注册Bean处理器，如AutowiredAnnotationBeanPostProcessor。</li>\n<li>执行onRefresh()， 执行AbstractBeanFactory的refresh()方法。</li>\n<li>AbstractBeanFactory的refresh()获取所有Bean的定义，执行getBean()创建Bean实例。</li>\n<li>getBean()创建完Bean实例后，调用Bean处理器并初始化。</li>\n</ol><pre><code class=\"language-plain\">applyBeanPostProcessorBeforeInitialization(singleton, beanName);\ninvokeInitMethod(beanDefinition, singleton);\napplyBeanPostProcessorAfterInitialization(singleton, beanName);\n</code></pre><ol start=\"6\">\n<li>applyBeanPostProcessorBeforeInitialization由具体的BeanFactory，如AutowireCapableBeanFactory，来实现，这个实现也很简单，就是对BeanFactory里已经注册好的所有Bean处理器调用相关方法。</li>\n</ol><pre><code class=\"language-plain\">beanProcessor.postProcessBeforeInitialization(result,&nbsp;beanName);\nbeanProcessor.postProcessAfterInitialization(result,&nbsp;beanName);\n</code></pre><ol start=\"7\">\n<li>我们事先准备好的AutowiredAnnotationBeanPostProcessor方法里面会解释Bean中的Autowired注解。</li>\n</ol><h2>测试注解</h2><p>到这里，支持注解的工作就完成了，接下来就是测试Autowired注解了。在这里我们做两个改动。</p><ol>\n<li>在测试类中增加Autowired注解。</li>\n</ol><pre><code class=\"language-java\">package com.minis.test;\nimport com.minis.beans.factory.annotation.Autowired;\npublic class BaseService {\n&nbsp; &nbsp; @Autowired\n&nbsp; &nbsp; private BaseBaseService bbs;\n&nbsp; &nbsp; public BaseBaseService getBbs() {\n&nbsp; &nbsp; &nbsp; &nbsp; return bbs;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; public void setBbs(BaseBaseService bbs) {\n&nbsp; &nbsp; &nbsp; &nbsp; this.bbs = bbs;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; public BaseService() {\n&nbsp; &nbsp; }\n&nbsp; &nbsp; public void sayHello() {\n&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(\"Base Service says Hello\");\n&nbsp; &nbsp; &nbsp; &nbsp; bbs.sayHello();\n&nbsp; &nbsp; }\n}\n</code></pre><ol start=\"2\">\n<li>注释XML配置文件中关于循环依赖的配置。</li>\n</ol><pre><code class=\"language-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n&lt;beans&gt;\n&nbsp; &nbsp; &lt;bean id=\"bbs\" class=\"com.minis.test.BaseBaseService\"&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;property type=\"com.minis.test.AServiceImpl\" name=\"as\" ref=\"aservice\" /&gt;\n&nbsp; &nbsp; &lt;/bean&gt;\n&nbsp; &nbsp; &lt;bean id=\"aservice\" class=\"com.minis.test.AServiceImpl\"&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;constructor-arg type=\"String\" name=\"name\" value=\"abc\"/&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;constructor-arg type=\"int\" name=\"level\" value=\"3\"/&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;property type=\"String\" name=\"property1\" value=\"Someone says\"/&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;property type=\"String\" name=\"property2\" value=\"Hello World!\"/&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;property type=\"com.minis.test.BaseService\" name=\"ref1\"&nbsp;\nref=\"baseservice\"/&gt;\n&nbsp; &nbsp; &lt;/bean&gt;\n&nbsp; &nbsp; &lt;bean id=\"baseservice\" class=\"com.minis.test.BaseService\"&gt;\n&lt;!--&nbsp; &nbsp; &nbsp; &nbsp; &lt;property type=\"com.minis.test.BaseBaseService\" name=\"bbs\"&nbsp;\nref=\"basebaseservice\" /&gt;--&gt;\n&nbsp; &nbsp; &lt;/bean&gt;\n&lt;/beans&gt;\n</code></pre><h2>小结</h2><p>这节课我们丰富了原来的框架，支持了注解，让它更有模有样了。</p><p>注解是现代最受程序员欢迎的特性，我们通过Autowired这个注解实现了Bean的注入，这样程序员不用再在XML配置文件中手动配置property，而是在类中声明property的时候直接加上注解即可，框架使用的机制是名称匹配，这也是Spring所支持的一种匹配方式。</p><p>接着我们提取了BeanFactory接口，定义了一个抽象的AbstractBeanFactory。通过这个抽象类，将Bean工厂需要做的事情的框架搭建出来，然后在具体实现类中完善细节。这种程序结构称为interface-abstract class-class（接口抽象类），是一种做框架时常用的设计模式。</p><p><img src=\"https://static001.geekbang.org/resource/image/14/38/141ec0beb22e6525cb3fe484be337638.jpg?wh=3569x2229\" alt=\"\"></p><p>我们自己手写MiniSpring，不仅仅是要学习一个功能如何实现，还要学习大师的做法，模仿他们的代码和设计，练习得多了就能像专业程序员一样地写代码了。</p><p>完整源代码参见 <a href=\"https://github.com/YaleGuo/minis\">https://github.com/YaleGuo/minis</a></p><h2>课后题</h2><p>学完这节课，我也给你留一道思考题。我们实现了Autowired注解，在现有框架中能否支持多个注解？欢迎你在留言区与我交流讨论，也欢迎你把这节课分享给需要的朋友。我们下节课见！</p><h2></h2>","comments":[{"had_liked":false,"id":371307,"user_name":"一念之间","can_delete":false,"product_type":"c1","uid":3577203,"ip_address":"上海","ucode":"B58CDEA1424B1C","user_header":"https://static001.geekbang.org/account/avatar/00/36/95/73/1978ddde.jpg","comment_is_top":false,"comment_ctime":1679763316,"is_pvip":false,"replies":[{"id":135498,"content":"post的字面含义是“什么什么之后”，这里是指create bean之后，用postProcessor进行修饰。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679915957,"ip_address":"澳大利亚","comment_id":371307,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"有一个简单的问题 为什么处理器要叫做PostProcessor呢？ 这里的post到底是对于什么动作而言的呢？","like_count":4,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":611064,"discussion_content":"post的字面含义是“什么什么之后”，这里是指create bean之后，用postProcessor进行修饰。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679915957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371272,"user_name":"三太子","can_delete":false,"product_type":"c1","uid":2407092,"ip_address":"重庆","ucode":"2FDF74608F3D03","user_header":"https://static001.geekbang.org/account/avatar/00/24/ba/b4/281eb9d0.jpg","comment_is_top":false,"comment_ctime":1679729189,"is_pvip":false,"replies":[{"id":135462,"content":"赞","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679894013,"ip_address":"澳大利亚","comment_id":371272,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"https:&#47;&#47;github.com&#47;yx-Yaoxaing&#47;minispring&#47;wiki&#47;%E5%85%B3%E4%BA%8Emini-spring\n自己写的代码提到github上  每日打卡！ 遇到的基础问题 都写在了wiki","like_count":4,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":610986,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679894013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370901,"user_name":"睿智的仓鼠","can_delete":false,"product_type":"c1","uid":2781305,"ip_address":"湖北","ucode":"914D56E47B01F2","user_header":"https://static001.geekbang.org/account/avatar/00/2a/70/79/bb591140.jpg","comment_is_top":false,"comment_ctime":1679366683,"is_pvip":false,"replies":[{"id":135321,"content":"赞！","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679395513,"ip_address":"澳大利亚","comment_id":370901,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"通过这节课真的是感受到Spring设计的巧妙之处了，我目前的理解是，解耦分为两种：设计上的解耦、实现类上的解耦。通过抽取AbstractBeanFactory，把BeanPostProcessor的设计与BeanFactory本身解耦，AutowireCapableBeanFactory再通过定义BeanPostProcessor接口类型的属性，向外提供属性设置的方法，做到了和BeanPostProcessor实现类的解耦，最后在ClassPathXmlApplicationContext中统一注册BeanPostProcessor，再抽取成一个启动方法，非常优雅。AbstractBeanFactory的“接口抽象类”思想也很巧妙。这些思想在学Spring源码时早已听说，当时只觉得这样设计是灵活的，但不知道具体灵活在何处，通过自己手写实现下来真的是越来越清晰了，实属好课！","like_count":4,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":610114,"discussion_content":"赞！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1679395513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":375193,"user_name":"Geek_7jwpfc","can_delete":false,"product_type":"c1","uid":1318633,"ip_address":"湖南","ucode":"CBCEA76E9EF33B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJhxtIyXX4icMNAq5zEvchKYS3q7fwZXA3h7yV80iaibCRXniaLW95OnPC8PM2h5Ja5ibpkJ1VJowicqKZA/132","comment_is_top":false,"comment_ctime":1685050737,"is_pvip":false,"replies":[{"id":136950,"content":"1.你看别的问题回复，这个问题讨论过了。\n2.是的。因为这是简版，主要为了说明原理。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1685175444,"ip_address":"澳大利亚","comment_id":375193,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"老师：\n1. Autowire注入对象B，此时B的beanDefinnition还没有加载进来,会报错！设置lazy = ture 也不行，只能把if( !beanDefinition.isLazyInit() )注释掉, 还有其它方法吗！\n2.AutowiredAnnotationBeanPostProcessor#postProcessBeforeInitialization()方法：\n                    String fieldName = field.getName();\n                    Object autowiredObj = this.getBeanFactory().getBean(fieldName);\n这段代码，类的属性字段名要和xml配置的beanId相同，否则找不到！\n\n","like_count":3,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":619490,"discussion_content":"1.你看别的问题回复，这个问题讨论过了。\n2.是的。因为这是简版，主要为了说明原理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1685175444,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1318633,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJhxtIyXX4icMNAq5zEvchKYS3q7fwZXA3h7yV80iaibCRXniaLW95OnPC8PM2h5Ja5ibpkJ1VJowicqKZA/132","nickname":"Geek_7jwpfc","note":"","ucode":"CBCEA76E9EF33B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":619518,"discussion_content":"好的，谢谢回复","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1685207968,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":619490,"ip_address":"湖南","group_id":0},"score":619518,"extra":""}]}]},{"had_liked":false,"id":372705,"user_name":"杨松","can_delete":false,"product_type":"c1","uid":1512517,"ip_address":"辽宁","ucode":"FB3C73BC44C94D","user_header":"https://static001.geekbang.org/account/avatar/00/17/14/45/adf079ae.jpg","comment_is_top":false,"comment_ctime":1681457418,"is_pvip":false,"replies":[{"id":136027,"content":"这个不是功能实现的问题，是时序规定的事情。第一步处理是根据配置的构造函数进行实例化，第二步是根据配置的properties给属性赋值，然后才到了后期修饰，而Spring统一用了一个beanpostprocessor机制来处理。三步一遍遍做完的。学习框架，功能实现不是最主要的，而是结构和时序，光说功能，不要框架也一样的。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1681476565,"ip_address":"澳大利亚","comment_id":372705,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"老师，请教下关于AutowiredAnnotationBeanPostProcessor的时机问题，为什么不是在处理属性handleProperties的位置，这个方法正好是设置bean实例的属性啊，我一直没弄懂为啥不放在这里？","like_count":3,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":613724,"discussion_content":"这个不是功能实现的问题，是时序规定的事情。第一步处理是根据配置的构造函数进行实例化，第二步是根据配置的properties给属性赋值，然后才到了后期修饰，而Spring统一用了一个beanpostprocessor机制来处理。三步一遍遍做完的。学习框架，功能实现不是最主要的，而是结构和时序，光说功能，不要框架也一样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681476565,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2653715,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKib3vNM6TPT1umvR3TictnLurJPKuQq4iblH5upgBB3kHL9hoN3Pgh3MaR2rjz6fWgMiaDpicd8R5wsAQ/132","nickname":"陈阳","note":"","ucode":"C8E676C967D23A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634795,"discussion_content":"可以这么理解， beanPostProcessor的设计 可以用来实现Autowired字段的注入， 但不仅仅只是用来做属性的注入","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1703953707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1318633,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJhxtIyXX4icMNAq5zEvchKYS3q7fwZXA3h7yV80iaibCRXniaLW95OnPC8PM2h5Ja5ibpkJ1VJowicqKZA/132","nickname":"Geek_7jwpfc","note":"","ucode":"CBCEA76E9EF33B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":618901,"discussion_content":"如果不是这个意思，希望老师再费心解释下，我相信大家和我也有同样的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1684698013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"湖南","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1318633,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJhxtIyXX4icMNAq5zEvchKYS3q7fwZXA3h7yV80iaibCRXniaLW95OnPC8PM2h5Ja5ibpkJ1VJowicqKZA/132","nickname":"Geek_7jwpfc","note":"","ucode":"CBCEA76E9EF33B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":618900,"discussion_content":"老师，我也是同样的问题，还是没有明白，仔细揣摩了您的意思，您看是不是这样！\n单独从生命周期上讲，第一步，构造函数实例化； 第二步，根据xml配置给properties属性复制，也就是handlePropertie()方法；第三步，处理注解，beanpostprocessor()注入属性！\n其实注解注入属性的方式，也可以放在handlePropertie()中，只不过spring是通过beanpostprocessor来处理注解的，是这个意思吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1684697939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"湖南","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370974,"user_name":"马儿","can_delete":false,"product_type":"c1","uid":2247080,"ip_address":"四川","ucode":"542E23D7B6AB01","user_header":"","comment_is_top":false,"comment_ctime":1679415695,"is_pvip":false,"replies":[{"id":135324,"content":"对的对的。这里没有用上，只是写了一个占位在这里，说明从时序上这儿可以进行对beanfactory的后期处理。这是当时留给学生的扩展练习。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679441412,"ip_address":"澳大利亚","comment_id":370974,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"ClassPathXmlApplicationContext增加了一个BeanFactoryPostProcessor属性，本文中没有给出定义，看了GitHub源码把这个类拷贝出来。这个类的作用是什么呢？是像对BeanPostProcessor一样对BeanFactory进行特殊处理的吗？","like_count":3,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":610172,"discussion_content":"对的对的。这里没有用上，只是写了一个占位在这里，说明从时序上这儿可以进行对beanfactory的后期处理。这是当时留给学生的扩展练习。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679441412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":375603,"user_name":"爪哇夜未眠","can_delete":false,"product_type":"c1","uid":1006025,"ip_address":"北京","ucode":"BBEB80EB670770","user_header":"https://static001.geekbang.org/account/avatar/00/0f/59/c9/f44cb7f3.jpg","comment_is_top":false,"comment_ctime":1685709630,"is_pvip":false,"replies":[{"id":137097,"content":"谢谢！","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1685770088,"ip_address":"澳大利亚","comment_id":375603,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"文章里的代码，AbstractBeanFactory.doCreateBean()方法里，if (!constructorArgumentValues.isEmpty()) 后面少了一个else，里面是无参构造方法创建对象\nelse {\n    obj = clz.newInstance();\n}","like_count":2,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":620049,"discussion_content":"谢谢！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1685770088,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3643650,"avatar":"https://static001.geekbang.org/account/avatar/00/37/99/02/791d0f5e.jpg","nickname":"要叫秀妍呀","note":"","ucode":"2DA13868386ACE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":627421,"discussion_content":"确实，加了判空是为了避免出现 new Class&lt;?&gt;[0] 的情况。但是如果构造参数为空，就需要调用无参构造来创建实例了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1694138138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"陕西","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370873,"user_name":"陈小远","can_delete":false,"product_type":"c1","uid":2393550,"ip_address":"四川","ucode":"8C348A5FA8F539","user_header":"https://static001.geekbang.org/account/avatar/00/24/85/ce/df1c7a91.jpg","comment_is_top":false,"comment_ctime":1679326461,"is_pvip":false,"replies":[{"id":135317,"content":"Github上的分支跟讲稿差不多对应的，但是不是完全一一对应上的，这是历史原因，几年前就放到Github上了，但是讲稿为了篇幅的规定又略微有些调整。你看的这部分是在ioc4中。每个分支里有一个docs&#47;readme.txt文件，是当时边写的时候边手工做的记录。\n你很用心，希望能跟下来，对自己大有益处的。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679370461,"ip_address":"澳大利亚","comment_id":370873,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"跟到第四节了，单纯看文章逻辑来说还能理解一些实现，但是结合github上的源码（对照的是ioc4分支，不知道是否找对），发现源码和文章逻辑叙述的时候同一个类贴的代码实现是不一样的，导致对照学习的时候产生混乱。比如源码中AutowireCapableBeanFactory是直接实现的BeanFactory，但在文章的表述中是继承的AbstractBeanFactory，由此就在此节无法对照源码和文章表述自我参照着来完成注解的功能。看了四节后说说自己的一些看法或观点：\n1、源码在github上，因为不是整个分支全克隆下来学习，单独的点击查看某个类的代码比较慢，影响学习效率，如果码云上有学习地址可能会好很多；\n2、文章代码和源码不一致的问题不知道是跳跃太大还是个人没找对位置，很多人可能会渐渐的迷乱从而无法继续跟进学习；\n3、源码相对于文章来说跳跃性比较大，如果正文中没法完全交代清楚，建议在源码的readme文件尽可能详细的给出一些突然出现的类的说明和设计意图\n\n总的来说，通过老师的引导，再结合Spring的源码，还是有那么点感觉的，不过今天这节课实在没跟下来，可能还需要多花点时间自己琢磨琢磨","like_count":2,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":610062,"discussion_content":"Github上的分支跟讲稿差不多对应的，但是不是完全一一对应上的，这是历史原因，几年前就放到Github上了，但是讲稿为了篇幅的规定又略微有些调整。你看的这部分是在ioc4中。每个分支里有一个docs/readme.txt文件，是当时边写的时候边手工做的记录。\n你很用心，希望能跟下来，对自己大有益处的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679370461,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1190060,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/ac/37a2a265.jpg","nickname":"弱水穿云天","note":"","ucode":"80DC528A23ED7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":615968,"discussion_content":"可以整个clone啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1682518938,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3568080,"avatar":"https://static001.geekbang.org/account/avatar/00/36/71/d0/2ccddb0c.jpg","nickname":"心中有花","note":"","ucode":"8A353032245B96","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":610056,"discussion_content":"+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679369749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"湖北","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":372847,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1015222,"ip_address":"陕西","ucode":"27EB4A725CE14E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/b6/abdebdeb.jpg","comment_is_top":false,"comment_ctime":1681720371,"is_pvip":false,"replies":[{"id":136216,"content":"对。演变过程中会丢掉一些东西。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1681734089,"ip_address":"澳大利亚","comment_id":372847,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"想请教一下老师，那现在是不是SimpleBeanFactory完全没用了？","like_count":1,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":614260,"discussion_content":"对。演变过程中会丢掉一些东西。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681734089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371039,"user_name":"风轻扬","can_delete":false,"product_type":"c1","uid":1542987,"ip_address":"北京","ucode":"DB972F2DF059C4","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/15ab499a.jpg","comment_is_top":false,"comment_ctime":1679476979,"is_pvip":false,"replies":[{"id":135349,"content":"1，是不想重复\n2，文稿中的代码不全，编辑当时建议只列关键代码。你要上Github找不同的分支，下载完整代码。\n3，我用的是obj.getClass()。 init方法是业务类定义的初始化方法，名字在XML文件中配置。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679482876,"ip_address":"澳大利亚","comment_id":371039,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"老师，有几个问题请教一下。\n1、AutowireCapableBeanFactory类中的addBeanPostProcessor为什么要先remove再add呢？\n2、代码里出现异常的时候，老师都是只写一个try，这貌似不行吧，我是java8，这是高版本jdk的新特性吗？\n3、AutowireCapableBeanFactory类中的invokeInitMethod方法，您的代码逻辑中，获取Class对象用的是BeanDefinition.getClass()，我理解，应该用Class.forName(BeanDefinition.getClassName())，init方法应该是我们业务类上定义的init方法吧？","like_count":1,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":610262,"discussion_content":"1，是不想重复\n2，文稿中的代码不全，编辑当时建议只列关键代码。你要上Github找不同的分支，下载完整代码。\n3，我用的是obj.getClass()。 init方法是业务类定义的初始化方法，名字在XML文件中配置。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679482876,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":1787254,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eriaiaLnWYicicmvkbfDhiaEuEBWNMptBMsGLtmibaaT0ZX896OdmaV4QvaoicVXmWw7HnEJEXXgjicDMlGEA/132","nickname":"crazy_feng","note":"","ucode":"51AE97CA49605F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":611607,"discussion_content":"老师，对于三，你应该看错了，init方法是bean的init，所以要获取对应bean的class","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1680186508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":610262,"ip_address":"浙江","group_id":0},"score":611607,"extra":""},{"author":{"id":2108194,"avatar":"https://static001.geekbang.org/account/avatar/00/20/2b/22/79d183db.jpg","nickname":"H·H","note":"","ucode":"113E95BA6B6F51","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":628584,"discussion_content":"对于1，我看并没有实现响应的equals方法，比较的也就是地址，所以意思就是如果之前存在了一个processor A，那么我再添加A，就是先移除再添加。保证只有1个A","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1695556987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":610262,"ip_address":"江苏","group_id":0},"score":628584,"extra":""}]}]},{"had_liked":false,"id":372618,"user_name":"杨松","can_delete":false,"product_type":"c1","uid":1512517,"ip_address":"辽宁","ucode":"FB3C73BC44C94D","user_header":"https://static001.geekbang.org/account/avatar/00/17/14/45/adf079ae.jpg","comment_is_top":false,"comment_ctime":1681353351,"is_pvip":false,"replies":[{"id":136009,"content":"原则都是一样的，物以类聚，紧密的一堆类放一起。但是具体划分又因人而异。我是按照Spring框架来的。MiniSpring最后的结构跟Spring一样，这样继续学习Spring就自然而然了。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1681382691,"ip_address":"澳大利亚","comment_id":372618,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"老师请教下，包factory.support和包factory.config划分上有什么依据，不太明白为什么这么划分","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":613539,"discussion_content":"原则都是一样的，物以类聚，紧密的一堆类放一起。但是具体划分又因人而异。我是按照Spring框架来的。MiniSpring最后的结构跟Spring一样，这样继续学习Spring就自然而然了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681382691,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371919,"user_name":"啊良梓是我","can_delete":false,"product_type":"c1","uid":1655117,"ip_address":"广东","ucode":"E42FC1A60D331C","user_header":"https://static001.geekbang.org/account/avatar/00/19/41/4d/f6d6d13a.jpg","comment_is_top":false,"comment_ctime":1680520377,"is_pvip":false,"replies":[{"id":135703,"content":"说得太对了，用心了。这个代码有你说的这个问题。原因是minispring是为学习spring框架的原理而构建的，主要体现内部结构。这个地方是线下课时给学生扩展练习用的。这个地方， 为鲁棒性，要先把全部definition加载完，再getbean。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1680558635,"ip_address":"澳大利亚","comment_id":371919,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"```\n@Override public void registerBeanDefinition(String name, BeanDefinition beanDefinition) { this.beanDefinitionMap.put(name, beanDefinition); this.beanDefinitionNames.add(name); if (!beanDefinition.isLazyInit()) { try { getBean(name); } } }\n\n```\n这里我有个问题，就是这个如果在设置BeanDefinition的时候，执行getBean方法，但是如果Bean里面注入了第三方Bean，这时候，有可能这个第三方Bean的BeanDefinition还没有实例化的，很明显不能循环注入Bean的啊？这个应该怎么处理的呢？延迟等待？或者说主动去遍历Resource接口获取资源，当也拿不到的时候，直接报编译器异常？","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612173,"discussion_content":"说得太对了，用心了。这个代码有你说的这个问题。原因是minispring是为学习spring框架的原理而构建的，主要体现内部结构。这个地方是线下课时给学生扩展练习用的。这个地方， 为鲁棒性，要先把全部definition加载完，再getbean。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680558635,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3574989,"avatar":"https://static001.geekbang.org/account/avatar/00/36/8c/cd/e9cc0f3d.jpg","nickname":"Xavier","note":"","ucode":"D6DE84507C8507","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":619717,"discussion_content":"我也发现有这个问题，我想能不能在XmlBeanDefinitionReader这个类中创建一个List每次loadBeanDefinitions方法调用完之后不调用registerBeanDefinition方法，而是直接存储在List里面。在loadBeanDefinitions方法结束之前遍历这个List依次取出元素调用registerBeanDefinition方法。（感觉想法有点粗暴）","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1685452589,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"湖南","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":3663510,"avatar":"https://static001.geekbang.org/account/avatar/00/37/e6/96/e7f430c1.jpg","nickname":"十画生","note":"","ucode":"B3BE789D774F86","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":3574989,"avatar":"https://static001.geekbang.org/account/avatar/00/36/8c/cd/e9cc0f3d.jpg","nickname":"Xavier","note":"","ucode":"D6DE84507C8507","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":622447,"discussion_content":"将懒加载判断放在BeanFactory的refresh方法里可以解决这个问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1688288449,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":619717,"ip_address":"中国香港","group_id":0},"score":622447,"extra":""}]}]},{"had_liked":false,"id":371720,"user_name":"追梦","can_delete":false,"product_type":"c1","uid":2883656,"ip_address":"广东","ucode":"E14C909DDE2603","user_header":"https://static001.geekbang.org/account/avatar/00/2c/00/48/55932a4c.jpg","comment_is_top":false,"comment_ctime":1680231695,"is_pvip":false,"replies":[{"id":135621,"content":"我这么处理只是为了简单。Spring框架本身还可以按照Type来注入。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1680263207,"ip_address":"澳大利亚","comment_id":371720,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"老师好，您说在beans.xml配置的bean别名和被@Autowire修饰的属性名必须一样，但是我觉得这样不够完整，我使用了@Autowire自然是希望所有该类型都被注入无论其属性名是什么，我想记录一个属性值映射signleton的hashMap对象来存储，老师觉得这个思路怎么样？或者老师有什么其他看法嘛对于文件中bean的别名和属性名必须相同","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":611710,"discussion_content":"我这么处理只是为了简单。Spring框架本身还可以按照Type来注入。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680263207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371565,"user_name":"努力呼吸","can_delete":false,"product_type":"c1","uid":1718303,"ip_address":"广东","ucode":"52941DD7A01BBA","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKDfO7wKibzpw4YsoqLRCHUKxX4rYRUh7m7RCdOwzWVaN9QLlhcU5ho3w2Qcpib1O69YPj65ib07xQBQ/132","comment_is_top":false,"comment_ctime":1680071294,"is_pvip":false,"replies":[{"id":135581,"content":"beanDefinitionNames应该加上。 earlySingletonObject是纯粹内部使用的，使用的时候都是放在synchronized代码块中的，你可以看一下Spring框架本身的源代码。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1680088147,"ip_address":"澳大利亚","comment_id":371565,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"老师，为什么beanDefinitionMap是线程安全的容器；beanDefinitionNames和earlySingletonObject不需要呢？","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":611441,"discussion_content":"beanDefinitionNames应该加上。 earlySingletonObject是纯粹内部使用的，使用的时候都是放在synchronized代码块中的，你可以看一下Spring框架本身的源代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680088148,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371532,"user_name":"梦某人","can_delete":false,"product_type":"c1","uid":3228991,"ip_address":"日本","ucode":"D9F14B15AC2A12","user_header":"https://static001.geekbang.org/account/avatar/00/31/45/3f/e4fc2781.jpg","comment_is_top":false,"comment_ctime":1680021231,"is_pvip":false,"replies":[{"id":135582,"content":"1，这里是不可以不要返回值的。但是到了FactoryBean的实现的时候，需要。\n2，AbstractFactory主要的目的是抽取一个模板，让别的beanFactory来继承。\n3，这个refresh是留下的一个口子，用来扩展练习的。要解决你说的问题，我觉得是要先将beandefinition完全加载完之后再 getbean。\n\n另外，文稿的代码时不全的，只是主要的部分。完整代码，还是要看Github上的，有不同分支。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1680088509,"ip_address":"澳大利亚","comment_id":371532,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"个人实现地址如下：https:&#47;&#47;github.com&#47;DDreame&#47;myMiniSpring\n欢迎其他同学参考以及 Star，根据 Commit history 查看我根据课程内容分割的实现过程。\n提问1: applyBeanPostProcessorAfterInitialization 方法在 AbstractFactory 中存在了返回值，有什么存在的必要性，但是， obj 作为一个引用对象，需要返回吗？ 在 AbstractFactory 中也并没有使用到其返回值。（另外方法如果直接为 void 依然有效，我已经测试过。）\n提问2: AbstractFactory 这个似乎过于单例了？ 可能是因为 mini 实现的原因？ 因为目前的 AbstractFactory 基本等于修改了 SimpleSingletonFactory。\n提问3: 关于 Factory 的 Refres 问题，当我在 ClassPathXmlApplicationContent 的 refresh() 方法中，在 注册前后处理器之前进行了 Refresh, 就会导致 Autowired 无法成功注入，这是因为实例已经建立好了吗？ 那如果想修复这个问题，老师能否提供一定的思路？比如，在 getBean 的时候做一遍属性检查吗？（当然有可能是我个人实现的问题）\n由于没看源码，是按照老师给出的代码和讲解实现的，所以可能存在一定理解偏差，希望老师指正一下。\n\n关于课后题：\n可以实现，这部分在 Processor 部分进行了解耦合，只要实现相关注解的 Processor，并在 Context 中进行加载，即可。","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":611442,"discussion_content":"1，这里是不可以不要返回值的。但是到了FactoryBean的实现的时候，需要。\n2，AbstractFactory主要的目的是抽取一个模板，让别的beanFactory来继承。\n3，这个refresh是留下的一个口子，用来扩展练习的。要解决你说的问题，我觉得是要先将beandefinition完全加载完之后再 getbean。\n\n另外，文稿的代码时不全的，只是主要的部分。完整代码，还是要看Github上的，有不同分支。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680088509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1787254,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eriaiaLnWYicicmvkbfDhiaEuEBWNMptBMsGLtmibaaT0ZX896OdmaV4QvaoicVXmWw7HnEJEXXgjicDMlGEA/132","nickname":"crazy_feng","note":"","ucode":"51AE97CA49605F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":611605,"discussion_content":"对于问题三，如果你是说onRefresh()方法在注册前后处理器之前执行的话，AutowiredCapableBeanFactory里的list属性就为空，就不会走真正的前置处理流程(属性注入）。等bean创建好的时候，因为是单例的，直接取了注解未生效的那个bean","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680185886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371067,"user_name":"Geek_320730","can_delete":false,"product_type":"c1","uid":3035552,"ip_address":"北京","ucode":"CF7E6C8E91D2C4","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/XWv3mvIFORNgRk9wF8QLb9aXfh1Uz1hADtUmlFwQJVxIzhBf8HWc4QqU7iaTzj8wB5p5QJLRAvlQNrOqXtrg1Og/132","comment_is_top":false,"comment_ctime":1679500499,"is_pvip":false,"replies":[{"id":135390,"content":"你看得仔细，赞！\n1，我再检查一下啊，看看哪里出错了，怎么不一致了。\n2，你说的对。代码是原理性的，能正常运行，不是工业级的。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679568953,"ip_address":"澳大利亚","comment_id":371067,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"1.invokeInitMethod(BeanDefinition bd, Object obj) 中 master分支是用的obj.getObject(),ioc4分支中是bd.getObject(),应该是obj.getObject()\n2.循环调用postProcessBeforeInitialization或postProcessAfterInitialization那一块,好像是返回的bean为null的时候，中断这个循环调用，返回上次调用结果？是不是应该在调用之前先用另一个变量暂存一下，返回值为null的时候，return变量？按代码逻辑会return null，这样的话，后续应该会空指针异常吧。。。","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":610459,"discussion_content":"你看得仔细，赞！\n1，我再检查一下啊，看看哪里出错了，怎么不一致了。\n2，你说的对。代码是原理性的，能正常运行，不是工业级的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679568953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371047,"user_name":"聪聪不匆匆","can_delete":false,"product_type":"c1","uid":1360095,"ip_address":"上海","ucode":"86CD1D2D85B8CA","user_header":"https://static001.geekbang.org/account/avatar/00/14/c0/df/d52e7244.jpg","comment_is_top":false,"comment_ctime":1679481183,"is_pvip":false,"replies":[{"id":135389,"content":"感谢指出问题，这是历史原因造成的。后面我来调整。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679568806,"ip_address":"澳大利亚","comment_id":371047,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"第四节github上面ioc4 branch分支代码 和 文档中相差还是较大的。比如DefaultListableBeanFactory 类文档中并没有提到。再比如ClassPathXmlApplicationContext类中构造函数使用的是AutowireCapableBeanFactory类，但是在github中确是DefaultListableBeanFactory类，这个类怎么来的、什么用处、怎么演进的并没有地方提现到。诸如此类，github中在本次分支中多出来了很多类都在文档中未曾提到。","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":610458,"discussion_content":"感谢指出问题，这是历史原因造成的。后面我来调整。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679568806,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371041,"user_name":"风轻扬","can_delete":false,"product_type":"c1","uid":1542987,"ip_address":"北京","ucode":"DB972F2DF059C4","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/15ab499a.jpg","comment_is_top":false,"comment_ctime":1679477693,"is_pvip":false,"replies":[{"id":135350,"content":"感谢。希望你学下来收获大，这也是我带学生的初衷。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679482959,"ip_address":"澳大利亚","comment_id":371041,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"刚学了这么几节课，感觉就收获很大，代码手敲一遍，体会更深。有一个体会是：Spring的代码都是低耦合的，感觉低耦合的优势就是复用性强，扩展性强。扩展性方面，业务逻辑千变万化，Spring不能想到所有的业务情况，所以它就搞抽象，定标准。业务方可以根据自己的实际情况来实现标准，从而完成自己的个性化需求。这个思想很重要，工作中要注意用起来\n之前也经常看Spring源码，但因为Spring源码太庞大了，只能先基于一个点看，这就导致无法从整体上了解Spring的运行机制。这门课正好就是从整体理解Spring。把之前学习的点串起来，不错。好课一枚，赞!","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":610263,"discussion_content":"感谢。希望你学下来收获大，这也是我带学生的初衷。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679482959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371002,"user_name":"Unknown","can_delete":false,"product_type":"c1","uid":1736715,"ip_address":"福建","ucode":"E43137A064CAD8","user_header":"https://static001.geekbang.org/account/avatar/00/1a/80/0b/7ae52ac0.jpg","comment_is_top":false,"comment_ctime":1679454941,"is_pvip":false,"replies":[{"id":135346,"content":"Spring支持byType和byName，MiniSpring写的时候选择了一种作为示例，byType是作为学生扩展练习的。测试用例你自己试一下，这些配置可能讲课过程中改去改来过，你试一下能运行就行。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679481743,"ip_address":"澳大利亚","comment_id":371002,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"与spring的autowired byType注入不同，老师实现的autowired是根据beanName注入，所以AbstractBeanFactory里面的两个缓存Map key为小写类名。\n测试用例那边是不是有点问题 不应该直接用bbs 应该是用basebaseservice 这样才能创建的到吧\n","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":610256,"discussion_content":"Spring支持byType和byName，MiniSpring写的时候选择了一种作为示例，byType是作为学生扩展练习的。测试用例你自己试一下，这些配置可能讲课过程中改去改来过，你试一下能运行就行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679481743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370937,"user_name":"C.","can_delete":false,"product_type":"c1","uid":1444698,"ip_address":"江苏","ucode":"5AE269220EFD73","user_header":"https://static001.geekbang.org/account/avatar/00/16/0b/5a/453ad411.jpg","comment_is_top":false,"comment_ctime":1679389832,"is_pvip":false,"replies":[{"id":135322,"content":"你的思考很好，动脑筋了。这是当时写了一个架子，让学生知道可以支持这样的属性，当时留给学生当扩展作业的。主要是弄清楚内部结构知晓原理，莫纠结于某一个点。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679395623,"ip_address":"澳大利亚","comment_id":370937,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"我有个疑问，就是为什么BeanDefinition的lazyInit都设置为true，默认懒加载，Spring中不都是默认false吗？","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":610115,"discussion_content":"你的思考很好，动脑筋了。这是当时写了一个架子，让学生知道可以支持这样的属性，当时留给学生当扩展作业的。主要是弄清楚内部结构知晓原理，莫纠结于某一个点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679395624,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370929,"user_name":"C.","can_delete":false,"product_type":"c1","uid":1444698,"ip_address":"江苏","ucode":"5AE269220EFD73","user_header":"https://static001.geekbang.org/account/avatar/00/16/0b/5a/453ad411.jpg","comment_is_top":false,"comment_ctime":1679385569,"is_pvip":false,"replies":[{"id":135319,"content":"是的是的，你发现了，赞！这是当时写了一个架子，留给学生当扩展作业的。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679395411,"ip_address":"澳大利亚","comment_id":370929,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100536701,"comment_content":"BeanDefinition这个类的懒加载lazyInit从ioc3版本开始变成了true,之前的false会导致导致AbstractBeanFactory这个类里    \npublic void registerBeanDefinition(String name, BeanDefinition beanDefinition) {\n        this.beanDefinitionMap.put(name, beanDefinition);\n        this.beanDefinitionNames.add(name);\n        if (!beanDefinition.isLazyInit()) {\n            try {\n                getBean(name);\n            } catch (BeansException e) {\n                e.printStackTrace();\n            }\n        }\n    }\ngetBean执行，导致beanDefinitionMap中bean的定义信息没加载完，导致的找不到bean的定义信息导致的No bean.","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":610112,"discussion_content":"是的是的，你发现了，赞！这是当时写了一个架子，留给学生当扩展作业的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679395411,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1360095,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c0/df/d52e7244.jpg","nickname":"聪聪不匆匆","note":"","ucode":"86CD1D2D85B8CA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":610254,"discussion_content":"是的这个地方，我也找了好几个小时，一步一步debug,后来发现是lazyInit的问题。有些坑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679481258,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370922,"user_name":"心中有花","can_delete":false,"product_type":"c1","uid":3568080,"ip_address":"湖北","ucode":"8A353032245B96","user_header":"https://static001.geekbang.org/account/avatar/00/36/71/d0/2ccddb0c.jpg","comment_is_top":false,"comment_ctime":1679381756,"is_pvip":false,"replies":[{"id":135320,"content":"用心了。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679395471,"ip_address":"澳大利亚","comment_id":370922,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100536701,"comment_content":"记录自己写错的点，只用了一个List&lt;String&gt; beanName,这个list，不需要在添加registerSingleton  singletons.put的时候再添加一遍，不然就会报错，继续加油，争取成功上岸","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":610113,"discussion_content":"用心了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679395472,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370852,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"山西","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1679318453,"is_pvip":false,"replies":[{"id":135313,"content":"会自动扩展的，你去看一下JDK说明，有一个loadFactor，默认位0.75的时候就扩容。\n还有类型匹配，并且这是Spring默认的匹配方式。我这里是简化版本，只是实现了一种简单的名称匹配。\n不会有两个Factory，Factory会构建成一个体系,有继承关系,最后会到DefaultListableBeanFactory。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679369957,"ip_address":"澳大利亚","comment_id":370852,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100536701,"comment_content":"请教老师几个问题：\nQ1：AbstractBeanFactory中，\nearlySingletonObjects = new HashMap&lt;&gt;(16);，\n如果16不够用，会自动扩展吗？印象中好像不会；如果不会，会发生什么？\nQ2：除了名称匹配，还有什么匹配方法？\nQ3：会存在两个BeanFactory吗？一个是AutowireCapableBeanFactory，保存有注解的，另外一个保存没有注解的。","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":610058,"discussion_content":"会自动扩展的，你去看一下JDK说明，有一个loadFactor，默认位0.75的时候就扩容。\n还有类型匹配，并且这是Spring默认的匹配方式。我这里是简化版本，只是实现了一种简单的名称匹配。\n不会有两个Factory，Factory会构建成一个体系,有继承关系,最后会到DefaultListableBeanFactory。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679369957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2781305,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/70/79/bb591140.jpg","nickname":"睿智的仓鼠","note":"","ucode":"914D56E47B01F2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":610049,"discussion_content":"1、HashMap初始化时指定容量是推荐的代码规范，它的初始容量默认就是16，是有扩容机制的\n2、还有按类型匹配。Spring中的@Autowired是先按类型匹配，如果匹配到多个再按照属性名作为beanId的方式匹配，也就是目前老师的实现方式\n3、实现@Autowired功能只需要开头的那一小段代码，这节课大部分的工作都是在解耦BeanFactory和BeanPostProcessor，所以BeanFactory的扩展性目前还是极高的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679366102,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"湖北","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370821,"user_name":"心中有花","can_delete":false,"product_type":"c1","uid":3568080,"ip_address":"湖北","ucode":"8A353032245B96","user_header":"https://static001.geekbang.org/account/avatar/00/36/71/d0/2ccddb0c.jpg","comment_is_top":false,"comment_ctime":1679304037,"is_pvip":false,"replies":[{"id":135298,"content":"XML文件中要配置这个bean，名字必须跟Autowired注解的那个名字一样","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679310031,"ip_address":"澳大利亚","comment_id":370821,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100536701,"comment_content":"老师想问下，被@Autowire修饰的类，它的name是什么时候放入AutowireCapableBeanFactory beanFactory; 的 ，我get不到，麻烦老师解答下 感谢","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609954,"discussion_content":"XML文件中要配置这个bean，名字必须跟Autowired注解的那个名字一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679310031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1542987,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/15ab499a.jpg","nickname":"风轻扬","note":"","ucode":"DB972F2DF059C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":610242,"discussion_content":"你在AutowiredBeanPostProcessor类中，获取Field的时候，会获取类中的字段。然后根据字段名称去容器中查询，容器中的bean都来自于xml的定义，所以类中用Autowired修饰的字段名一定要和xml中对应上，否则就会获取不到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679476297,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370818,"user_name":"心中有花","can_delete":false,"product_type":"c1","uid":3568080,"ip_address":"湖北","ucode":"8A353032245B96","user_header":"https://static001.geekbang.org/account/avatar/00/36/71/d0/2ccddb0c.jpg","comment_is_top":false,"comment_ctime":1679303829,"is_pvip":false,"replies":[{"id":135297,"content":"Spring默认是byType，支持几种方式。我这里为了简便，只选择了byName这种方式。MiniSpring的目的是解析原理，不是真写一个Spring出来。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679309944,"ip_address":"澳大利亚","comment_id":370818,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100536701,"comment_content":"@Autowire 不是byType注入的吗？","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609953,"discussion_content":"Spring默认是byType，支持几种方式。我这里为了简便，只选择了byName这种方式。MiniSpring的目的是解析原理，不是真写一个Spring出来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679309944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":377938,"user_name":"十画生","can_delete":false,"product_type":"c1","uid":3663510,"ip_address":"","ucode":"B3BE789D774F86","user_header":"https://static001.geekbang.org/account/avatar/00/37/e6/96/e7f430c1.jpg","comment_is_top":false,"comment_ctime":1689581520,"is_pvip":false,"replies":null,"discussion_count":2,"race_medal":0,"score":4,"product_id":100536701,"comment_content":"老师，现阶段代码是不是没有解决autowired装配属性的循环依赖问题啊\n","like_count":1,"discussions":[{"author":{"id":3866578,"avatar":"https://static001.geekbang.org/account/avatar/00/3a/ff/d2/c1f5334d.jpg","nickname":"dirtychill","note":"","ucode":"4D3172C60E522A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":644979,"discussion_content":"ref版的注入解决过了，可以参考下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1715673729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1141923,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6c/a3/7d60e2a0.jpg","nickname":"1184507801","note":"","ucode":"930E2F79C5582A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":642002,"discussion_content":"BeanDefinition 里面的延迟初始化 lazyInit设置成了true","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1713199501,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":391985,"user_name":"edward","can_delete":false,"product_type":"c1","uid":1604798,"ip_address":"湖南","ucode":"09F7A5B8D2E7BD","user_header":"","comment_is_top":false,"comment_ctime":1719587277,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100536701,"comment_content":"此外，handleProperties方法中的Class clz, Object obj 这2个参数的信息是不是冗余了？毕竟clz=obj.getClass()。","like_count":0},{"had_liked":false,"id":391984,"user_name":"edward","can_delete":false,"product_type":"c1","uid":1604798,"ip_address":"湖南","ucode":"09F7A5B8D2E7BD","user_header":"","comment_is_top":false,"comment_ctime":1719586810,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100536701,"comment_content":"老师，为什么要有populateBean这个方法呢，直接用handleProperties方法不就好了吗？","like_count":0},{"had_liked":false,"id":389834,"user_name":"且将新火试新茶～","can_delete":false,"product_type":"c1","uid":1547839,"ip_address":"北京","ucode":"F8FD956CF07B14","user_header":"https://static001.geekbang.org/account/avatar/00/17/9e/3f/00109670.jpg","comment_is_top":false,"comment_ctime":1713595468,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100536701,"comment_content":"打卡：https:&#47;&#47;github.com&#47;sugar-orange666&#47;MiniSpring","like_count":0},{"had_liked":false,"id":380776,"user_name":"要叫秀妍呀","can_delete":false,"product_type":"c1","uid":3643650,"ip_address":"陕西","ucode":"2DA13868386ACE","user_header":"https://static001.geekbang.org/account/avatar/00/37/99/02/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1694139214,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100536701,"comment_content":"老师好，在 AbstractBeanFactory 类中，handleProperties 方法中，分类型处理时没有把属性的 value 转换成对应的类型，这点是错误的吧。会导致后续在执行 setter 方法时，例如原本是一个 int 类型，传入的却是 String 类型， 这样的错误。\n\n测试过程如下：\n在 AServiceImpl 类中添加一个 private int age; 属性，在 beans.xml 文件中添加 &lt;property type=&quot;int&quot; name=&quot;age&quot; value=&quot;22&quot; &#47;&gt; 的标签。执行代码后，会报错 违法的参数(貌似是这个 IllegalMethodArgument) 的异常 \n\n解决办法就是 handleProperties() 方法中添加把 String 类型转换成对应类型的代码，例如 int 类型中 paramValues[0]=Integer.valueOf((String) pValue);\n","like_count":0}]}