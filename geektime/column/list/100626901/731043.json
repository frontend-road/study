{"id":731043,"title":"19｜Rust的宏体系：为自己的项目写一个简单的声明宏","content":"<p>你好，我是Mike，今天我们一起来学习Rust语言中有关宏的知识。</p><p>宏是一套预处理设施。它的输入是代码本身，对代码进行变换然后输出新的代码。一般来说，输出的新代码必须是合法的当前语言的代码，用来喂给当前语言的编译器进行编译。</p><p>宏不是一门语言的必备选项，Java、Go等语言就没有宏，而C、CPP、Rust等语言有宏，而且它们的宏工作方式不一样。</p><p>在Rust语言中，宏也属于语言的外围功能，用来增强Rust语言的核心功能，让Rust语言变得更方便好用。宏不属于Rust语言的核心，但这并不是说宏在Rust中不重要。其实在Rust代码中，宏随处可见，掌握宏的原理和用法，有助于我们编写更高效的Rust代码。</p><p>在Rust中，宏的解析和执行是在Rust代码的编译阶段之前。你可以理解成，在Rust代码编译之前有一个宏展开的过程，这个过程的输出结果就是完整版的Rust代码，然后Rust编译器再来编译这个输出的代码。</p><h2>Rust语言中的宏</h2><p>当前版本的Rust中有两大类宏：声明宏（declarative macro）和过程宏（procedure macro），而过程宏又细分成三种：派生宏、属性宏和函数宏。</p><p>下面我们分别介绍一下它们。</p><!-- [[[read_end]]] --><h3>声明宏</h3><p>声明宏是用 <code>macro_rules!</code> 定义的宏，我们常见的 <code>println!()</code>、<code>vec![]</code> 都是这种宏。比如 <code>vec![]</code> 是按类似下面这种方式定义的：</p><pre><code class=\"language-plain\">#[macro_export]\nmacro_rules! vec {\n    ( $( $x:expr ),* ) =&gt; {\n        {\n            let mut temp_vec = Vec::new();\n            $(\n                temp_vec.push($x);\n            )*\n            temp_vec\n        }\n    };\n}\n</code></pre><p><span class=\"reference\">注：代码来自官方 The Book，这是一个演示版的定义，实际的 <code>vec!</code> 的定义比这个要复杂得多。</span></p><p>这是什么代码？完全看不懂，不是正常的Rust代码吧？是的，为了对Rust代码本身进行操作，需要重新定义一套语法形式，而这种语法形式，只在 <code>macro_rules!</code> 里有效。</p><p>宏整体上来说，使用了一种<strong>代码匹配 + 生成机制</strong>来生成新的代码。上面代码里的 <code>$()</code> 用来匹配代码条目。<code>$x:expr</code> 表示匹配的是一个表达式，匹配后的条目用 <code>$x</code> 代替。<code>*</code> 表示前面这个模式可以重复0次或者1次以上，这个模式就是 <code>$( $x:expr ),</code>，注意 <code>$()</code> 后面有个<code>，</code>号，这个逗号也是这个模式中的一部分，在匹配的时候是一个可选项，有就匹配，遇到最后一个匹配项的时候，就忽略它。<code>=&gt;</code> 前面是起匹配作用的部分，<code>=&gt;</code> 后面是生成代码的部分。</p><p>在生成代码的部分中，<code>$()</code> 号和 <code>=&gt;</code> 前面那个 <code>$()</code> 的作用差不多，就是表明被包起来的这块代码是可重复的。紧跟的 <code>*</code> 表示这个代码块可以重复0次到多次。具体次数等于 <code>=&gt;</code> 号前面的 <code>*</code> 号所代表的次数，两个一致。下面我们创建一个拥有三个整数元素的Vec。</p><pre><code class=\"language-plain\">let v = vec![1,2,3];\n</code></pre><p>代码展开后实际就是：</p><pre><code class=\"language-plain\">{\n    let mut temp_vec = Vec::new();\n    temp_vec.push(1);\n    temp_vec.push(2);\n    temp_vec.push(3);\n    temp_vec\n}\n</code></pre><p>你可以看到，<code>temp_vec.push();</code> 重复了3次，这是因为 <code>1,2,3</code> 匹配 <code>$x: expr</code>，匹配了3次，分别匹配出 1、2、3 三个整数。然后就生成了三行 <code>temp_vec.push();</code>。</p><p>你可能会问，<code>vec![]</code> 这对中括号哪里去了？其实在Rust中，你用 ()、[]、{} 都可以，比如：</p><pre><code class=\"language-plain\">let a = vec!(0, 1, 2);\nlet b = vec![0, 1, 2];\nlet c = vec! { 0, 1, 2 };\n</code></pre><p>不过也确实存在一些习惯性的表述，比如对于Vec这种列表，用 [] 显得更地道，其他语言也多用 []，这样能够和程序员的习惯保持一致。对于类函数式的调用，使用 () 更地道。对于构建结构体之类的宏或者存在大段代码输入的情况，用 {} 更合适。</p><p>现在你是不是能读懂一点了？</p><p>上面代码里的expr表示要匹配的item是个表达式。常见的匹配方式有7种。</p><ul>\n<li>expr：匹配表达式</li>\n<li>ty：匹配类型</li>\n<li>stmt：匹配语句</li>\n<li>item：匹配一个item</li>\n<li>ident：匹配一个标识符</li>\n<li>path：匹配一个path</li>\n<li>tt：匹配一个token tree</li>\n</ul><p>完整的说明，你可以看我给出的参考<a href=\"https://doc.rust-lang.org/stable/reference/macros-by-example.html\">链接</a>。</p><p>常见的重复符号有3个。</p><ul>\n<li><code>*</code> 表示重复0到多次。</li>\n<li><code>+</code> 表示重复1到多次。</li>\n<li><code>?</code> 表示重复0次或1次。</li>\n</ul><p>利用刚刚学到的知识，我们可以自己动手写一个声明宏。</p><h3>自己动手写一个声明宏</h3><p><strong>目标：</strong>实现一个加法宏 <code>add!(1,2)</code>，输出结果 3。</p><p>你可以看一下示例代码。</p><pre><code class=\"language-plain\">macro_rules! add {\n&nbsp; &nbsp; // 第一个分支，匹配两个元素的加法\n&nbsp; &nbsp; ($a:expr, $b:expr)=&gt;{\n&nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $a+$b\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; };\n&nbsp; &nbsp; // 第二个分支：当只有一个元素时，也应该处理，这是边界情况\n&nbsp; &nbsp; ($a:expr)=&gt;{\n&nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $a\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n}\n\nfn main(){\n&nbsp; &nbsp; let x=0;\n&nbsp; &nbsp; let sum = add!(1,2);&nbsp; // 调用宏\n&nbsp; &nbsp; let sum = add!(x);\n}\n</code></pre><p>通过示例我们可以看到，声明宏里面可以写多个匹配分支，Rust会根据匹配到的模式自动选择适配的分支进行套用。</p><p>我们可以用 <code>cargo expand</code> 来展开这个代码。</p><p><img src=\"https://static001.geekbang.org/resource/image/4b/e8/4bc66a9c6a378c89cd119e0acc189ee8.png?wh=2879x1643\" alt=\"\"></p><p>展开后实际是下面这个样子。</p><pre><code class=\"language-plain\">#![feature(prelude_import)]\n#[prelude_import]\nuse std::prelude::rust_2021::*;\n#[macro_use]\nextern crate std;\nmacro_rules! add {\n    ($a : expr, $b : expr) =&gt;\n    {\n        {\n            $a + $b\n            // 第一个分支，匹配两个元素的加法\n        }\n    } ; ($a : expr) =&gt;\n    {\n        {\n            $a\n            // 第二个分支：当只有一个元素时，也应该处理，这是边界情况\n        }\n    }\n}\nfn main() {\n    let x = 0;\n    let sum = { 1 + 2 }; // 调用宏\n    let sum = { x };\n}\n</code></pre><p>请你仔细对比展开前后的代码，好好理解一下。不过，仅仅是两个元素的相加，写个宏好像多此一举了。下面我们把它扩展到多个数字的加法。</p><pre><code class=\"language-plain\">macro_rules! add {\n&nbsp; &nbsp; ( $($a:expr),* ) =&gt; {\n&nbsp; &nbsp; &nbsp; &nbsp;{&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 开头要有个0，处理没有任何参数传入的情况\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 重复的块\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$( + $a )*\n&nbsp; &nbsp; &nbsp; &nbsp;}\n&nbsp; &nbsp; }\n}\n\nfn main(){\n&nbsp; &nbsp; let sum = add!();\n&nbsp; &nbsp; let sum = add!(1,2,3,4);\n}\n</code></pre><p>你可以看一下它展开后的样子。</p><pre><code class=\"language-plain\">#![feature(prelude_import)]\n#[prelude_import]\nuse std::prelude::rust_2021::*;\n#[macro_use]\nextern crate std;\nmacro_rules! add {\n    ($($a : expr), *) =&gt;\n    {\n        {\n            0 $(+ $a) *\n            // 开头要有个0，处理没有任何参数传入的情况\n            // 重复的块\n        }\n    }\n}\nfn main() { let sum = { 0 }; let sum = { 0 + 1 + 2 + 3 + 4 }; }\n</code></pre><p>可以看到，经过简单的改造，我们的 <code>add!()</code> 宏现在能处理无限多的相加项了。如果有时间，你可以进一步考虑如何处理总和溢出的问题。</p><p>我们可以先从这种简单的宏入手，边写边展开看效果，实现一个声明宏并不难。</p><h3>macro_export</h3><p>在一个模块中写好声明宏后，想要提供给其他模块使用的话，你得使用 <code>#[macro_export]</code> 导出，比如：</p><pre><code class=\"language-plain\">mod inner {\n    super::m!();\n    crate::m!();\n}\nmod toexport {\n    #[macro_export]    // 请注意这一句，把m!()导出到当前crate root下了\n    macro_rules! m {\n        () =&gt; {};\n    }\n}\nfn foo() {\n    self::m!();  // main函数在当前crate根下，可这样调用m!()\n    m!();        // 直接调用也是可以的\n}\n</code></pre><p><code>#[macro_export]</code> 可以把你定义的宏导出到当前 crate 根下，这样在 crate 里可以用 <code>crate::macro_name!</code> 访问（例子里的第3行 <code>crate::m!()</code>），在其他crate中可以使用 <code>use crate_name::macro_name</code> 导入。比如，我们假设上面代码里crate的名字是 mycrate，在另一个程序里可以这样导入这个宏。</p><pre><code class=\"language-plain\">use mycrate::m;\n\nfn bar() {\n    m!();\n}\n</code></pre><h3>macro_use</h3><p>前面我们使用了 <code>use mycrate::m</code> 这种精确的路径来导入 mycrate 中的 <code>m!()</code> 宏。如果一个crate里的宏比较多，我们想一次性全部导入，可以使用 <code>#[macro_use]</code> 属性，一次导入一个crate中所有已导出的宏，像下面这种写法：</p><pre><code class=\"language-plain\">#[macro_use] extern crate rocket;\n</code></pre><p>不过这种写法算是Rust早期的遗留写法了，更推荐的还是用到哪个宏就引入哪个宏。有些代码库中还会有这种写法出现，你看到了需要知道是什么意思。</p><h3>认识过程宏之派生宏</h3><p>常见的结构体上的derive标注，就是派生宏。比如我们<a href=\"https://time.geekbang.org/column/article/729009?utm_campaign=geektime_search&utm_content=geektime_search&utm_medium=geektime_search&utm_source=geektime_search&utm_term=geektime_search\">上一节课</a>讲到的 thiserror 提供的 Error 派生宏。</p><pre><code class=\"language-plain\">use thiserror::Error;\n\n#[derive(Error, Debug)]  // 派生宏\npub enum DataStoreError {\n    #[error(\"data store disconnected\")]  // 属性宏\n    Disconnect(#[from] io::Error),       // 属性宏\n    #[error(\"the data for key `{0}` is not available\")]  // 属性宏\n    Redaction(String),\n    #[error(\"invalid header (expected {expected:?}, found {found:?})\")]  // 属性宏\n    InvalidHeader {\n        expected: String,\n        found: String,\n    },\n    #[error(\"unknown data store error\")]   // 属性宏\n    Unknown,\n}\n</code></pre><p>上面示例中的 Debug 和 Error 就是派生宏。Debug 宏由std提供，Error由thiserror crate 提供。使用的时候，我们先使用use将宏导入到当前crate的scope。然后在 <code>#[derive()]</code> 中使用它。</p><pre><code class=\"language-plain\">#[derive(Error, Debug)]\n</code></pre><p>它会作用在下面紧跟着的 enum DataStoreError 这个类型上面，对这个类型进行某种代码变换操作。最后的实现效果就是帮助我们实现了 <code>std::error::Error</code> 这个trait，以及对应的 Debug、Display 等trait。在我们看来，写上这一句话，就好像Rust自动帮我们完成了那些实现，给我们省了很多力气。</p><p>想看它到底在 enum DataStoreError 类型上施加了哪些魔法，只需要运行 <code>cargo expand</code> 展开它就可以了。你可以自己动手做一下实验。</p><p>在这个enum DataStoreError里的变体上，我们还可以看到另外两个宏 <code>#[error()]</code> 和 <code>#[from]</code>，它们不是派生宏，而是过程宏中的属性宏。</p><h3>认识过程宏之属性宏</h3><p>Rust编译器提供了一些属性（Attributes），属性是施加在模块、crate或item上的元数据。这些元数据可用于很多地方。</p><ul>\n<li>代码条件编译；</li>\n<li>设置 crate 名字，版本号和类型（是二进制程序还是库）；</li>\n<li>禁止代码提示；</li>\n<li>开启编译器特性（宏、全局导入等）；</li>\n<li>链接到外部库；</li>\n<li>标记函数为单元测试；</li>\n<li>标记函数为性能评测的一部分；</li>\n<li>属性宏；</li>\n<li>……</li>\n</ul><p>要把属性施加到整个crate，语法是在crate入口，比如在 lib.rs 或 main.rs 的第一行写上 <code>#![crate_attribute]</code>。</p><p>如果只想把属性施加到某个模块或者item上，就把 <code>!</code> 去掉。</p><pre><code class=\"language-plain\">#[item_attribute]\n</code></pre><p>属性上面还可以携带参数，可以写成下面几种形式：</p><ul>\n<li><code>#[attribute = \"value\"]</code></li>\n<li><code>#[attribute(key = \"value\")]</code></li>\n<li><code>#[attribute(value)]</code></li>\n</ul><p>我们来看一下具体的例子。</p><pre><code class=\"language-plain\">// 声明这个 crate 为 lib，是全局性的属性\n#![crate_type = \"lib\"]\n\n// 声明下面这个函数为单元测试函数，这个属性只作用在test_foo()函数上\n#[test]\nfn test_foo() {\n    /* ... */\n}\n\n// 条件编译属性，这块深入下去细节非常多\n#[cfg(target_os = \"linux\")]\nmod bar {\n    /* ... */\n}\n\n// 正常来说，Rust中的类型名需要是Int8T这种写法，下面这个示例让编译器不要发警告\n#[allow(non_camel_case_types)]\ntype int8_t = i8;\n\n// 作用在整个函数内部，对未使用的变量不要报警\nfn some_unused_variables() {\n  #![allow(unused_variables)]\n\n  let x = ();\n  let y = ();\n  let z = ();\n}\n</code></pre><p>如果你开始写原型代码的时候，经常出现变量或函数未使用的情况，Rust编译器会提示一堆，有时看着心烦，你可以在crate入口文件头写上两行内容。</p><pre><code class=\"language-plain\">#![allow(unused_variables)]\n#![allow(dead_code)]\n\nfn foo() {\n    let a = 10;\n    let b = 20;\n}\n</code></pre><p>它会压制Rust编译器，让Rust编译器“放放水”。你可以试着把前面两行注释掉，看看Rust编译器会提示什么。但是对于一个严肃的项目来说，应该尽可能地消除这些“未使用”的警告，所以项目写到一定程度，就要把这种全局属性去掉。</p><p>Rust中有非常丰富的属性，它们给Rust编译器提供了非常强大的配置能力。要掌握它们，需要花费大量的时间，你可以看一下 <a href=\"https://doc.rust-lang.org/reference/attributes.html#attributes\">Attributes</a> 相关资料。这也印证了Rust的适用面极其广泛。即使一个熟练的程序员，也没必要掌握全部，只需要了解其中的常见属性就可以。然后在遇到一些具体的场景时，再深入研究那些配置。</p><p>而如果我们要定义自己的“属性”，就需要通过属性宏来实现。这属于偏高级而且用得比较少的内容，需要的时候再去学习也来得及。具体的实现可以参考我给出的链接。</p><ul>\n<li><a href=\"https://earthly.dev/blog/rust-macros/\">https://earthly.dev/blog/rust-macros/</a></li>\n<li><a href=\"https://doc.rust-lang.org/beta/reference/procedural-macros.html\">https://doc.rust-lang.org/beta/reference/procedural-macros.html</a></li>\n</ul><p>比如著名的Web开发框架Rocket，就使用属性宏来配置URL mapping。</p><pre><code class=\"language-plain\">#[macro_use] extern crate rocket;\n\n#[get(\"/&lt;name&gt;/&lt;age&gt;\")]      // 属性宏\nfn hello(name: &amp;str, age: u8) -&gt; String {\n    format!(\"Hello, {} year old named {}!\", age, name)\n}\n\n#[launch]      // 属性宏\nfn rocket() -&gt; _ {\n    rocket::build().mount(\"/hello\", routes![hello])\n}\n</code></pre><p>可以看到，有了属性宏的加持，Rust代码在结构上变得相当紧凑而有美感，跟Java的Spring框架有点相似了。</p><h3>认识过程宏之函数宏</h3><p>在某些特定的情况下，函数宏能更好地表达业务需求，比如写SQL语句。我们在Rust中撰写SQL语句，必须符合Rust的语法，因此，一般使用字符串来构造和传递SQL语句，比如：</p><pre><code class=\"language-plain\">fn foo() {\n    let sql = \"select title, content from article where id='1111111';\";\n}\n</code></pre><p>其实就不是那么方便，还容易出错。如果用函数宏来实现的话，可以做到如下效果：</p><pre><code class=\"language-plain\">// 这是伪代码\nuse sql_macros::sqlbuilder;\n\nfn foo() {\n    sqlbuilder!(select title, content from article where id='1111111';);\n}\n</code></pre><p>这样写，就好像在一个在SQL编辑器里面写SQL语句一样，非常自然，而不是把SQL语句写成字符串的形式了。也就是说，可以在Rust代码中写非Rust语法的代码，有没有感觉很神奇。当你想自己造一个DSL（领域特定语言 Domain Specific Language ）时，函数宏就可以派上用场了。</p><p>函数宏是过程宏的一种，也使用过程宏的方式来实现，相关信息可参考我给出的<a href=\"https://veykril.github.io/tlborm/proc-macros/methodical/function-like.html\">链接</a>。目前社区中关于过程宏完整而细致的教程并不多，后面我会出一系列这方面的专题教程。</p><h2>宏的应用</h2><p>综上，我们可以看到，利用宏可以做到以下几方面的事情。</p><ol>\n<li>减少重复代码。如果有大量的样板代码，可以使用声明宏或派生宏让代码变得更简洁、紧凑。</li>\n<li>为类型添加额外能力。这是派生宏和属性宏的强大威力。</li>\n<li>创建DSL。可以自己创建一种新的语言，利用Rust编译器在Rust中编译运行，而不需要你自己再去写一个单独的编译器或解释器了。</li>\n<li>变换代码实现任意自定义目标。本质上来说，宏就是对代码的变换，并且是在真正的编译阶段之前完成的，因此你可以用宏实现任意天马行空的想法。</li>\n</ol><h2>小结</h2><p><img src=\"https://static001.geekbang.org/resource/image/10/03/10317a770528e280a4176d0fbd877c03.jpg?wh=1712x952\" alt=\"\"></p><p>宏在Rust里无处不在，我们学习的第一步是要认识它们，知道它们的作用，熟悉常见宏的意义和用法。然后要初步掌握写简单的声明宏的写法，这样能有效地提升你精简业务代码的能力。但同时也要注意，使用宏不能过度，宏的缺点是比较难调试，IDE对它的支持可能也不完美。滥用宏会导致代码难以理解。</p><p>过程宏的能力非常强，书写的难度也比较大，我们目前不需要掌握它的写法。当你遇到一个过程宏的时候，你可以先查阅文档，知道它的作用，做到会用。等遇到需要的场景的时候，再去深入钻研。</p><p>这节课我们还提到了一个用来展开宏代码的工具cargo expand，经常使用它，对你学习宏会有很大帮助。</p><h2>思考题</h2><p>学完这节课的内容，你可以查阅一下相关资料，说一说 <code>allow</code>、<code>warn</code>、<code>deny</code>、<code>forbid</code> 几个属性的意义和用法。欢迎你把查阅到的内容分享到评论区，如果觉得有收获的话，也欢迎你把这节课的内容分享给其他朋友，我们下节课再见！</p>","comments":[{"had_liked":false,"id":384738,"user_name":"Noya","can_delete":false,"product_type":"c1","uid":1519230,"ip_address":"浙江","ucode":"52EEB72E80BAF8","user_header":"https://static001.geekbang.org/account/avatar/00/17/2e/7e/a15b477c.jpg","comment_is_top":false,"comment_ctime":1701417519,"is_pvip":false,"replies":[{"id":140306,"content":"对的","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1701523499,"ip_address":"重庆","comment_id":384738,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"allow、warn、deny、forbid: 编译器的警告级别","like_count":3,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632884,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1701523499,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384709,"user_name":"Distance","can_delete":false,"product_type":"c1","uid":1109780,"ip_address":"北京","ucode":"B30FAFE1F64D3D","user_header":"https://static001.geekbang.org/account/avatar/00/10/ef/14/83867b58.jpg","comment_is_top":false,"comment_ctime":1701362324,"is_pvip":false,"replies":[{"id":140310,"content":"非常细心！👍。第二个分支后面也可以加分号的。分号的作用用来间隔多个分支。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1701556755,"ip_address":"重庆","comment_id":384709,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"macro_rules! add {\n    &#47;&#47; 第一个分支，匹配两个元素的加法\n    ($a:expr, $b:expr)=&gt;{\n        {\n            $a+$b\n        }\n    };\n    &#47;&#47; 第二个分支：当只有一个元素时，也应该处理，这是边界情况\n    ($a:expr)=&gt;{\n        {\n            $a\n        }\n    }\n}\n\n为什么第二个分支匹配不需要分号呢？ 我看第一个示例只有单个匹配也是分号结尾的","like_count":3,"discussions":[{"author":{"id":1519230,"avatar":"https://static001.geekbang.org/account/avatar/00/17/2e/7e/a15b477c.jpg","nickname":"Noya","note":"","ucode":"52EEB72E80BAF8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632836,"discussion_content":"我尝试了一下, 如果有多个分支匹配, 除了最后一个可加可不加, 其他都要加; 如果只有一个分支, 那就可加可不加","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1701413852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632892,"discussion_content":"非常细心！👍。第二个分支后面也可以加分号的。分号的作用用来间隔多个分支。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1701556755,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":387373,"user_name":"奕","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"广东","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1707105310,"is_pvip":false,"replies":[{"id":141250,"content":"play.rust-lang.org","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1708627446,"ip_address":"加拿大","comment_id":387373,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"cargo expand 宏展开这个网站地址是什么啊","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":637561,"discussion_content":"play.rust-lang.org","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1708627446,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"加拿大","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2918708,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/89/34/cd862ef6.jpg","nickname":"Vincent_Li","note":"","ucode":"7E020B698650D7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":646193,"discussion_content":"搜了下. cargo install cargo-expand 可以安装为本地命令 , 参考 https://docs.rs/crate/cargo-expand/0.1.3/source/README.md","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1717515174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1203049,"avatar":"https://static001.geekbang.org/account/avatar/00/12/5b/69/7ace1ddb.jpg","nickname":"独钓寒江","note":"","ucode":"2C81906FD88C8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":643388,"discussion_content":"之前同有此问，仔细看了一下，猜大概是这个网站，觉得在原文加一句补充说明比较好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1714277059,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384773,"user_name":"Taozi","can_delete":false,"product_type":"c1","uid":1021926,"ip_address":"上海","ucode":"DD6567A31B3E33","user_header":"","comment_is_top":false,"comment_ctime":1701503670,"is_pvip":false,"replies":[{"id":140308,"content":"对的👍","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1701523536,"ip_address":"重庆","comment_id":384773,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"过程宏本质上是编译器的扩展插件","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632886,"discussion_content":"对的👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1701523536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384711,"user_name":"伯阳","can_delete":false,"product_type":"c1","uid":1596631,"ip_address":"北京","ucode":"DBDC8735AA54AD","user_header":"https://static001.geekbang.org/account/avatar/00/18/5c/d7/3b92bb0d.jpg","comment_is_top":false,"comment_ctime":1701381064,"is_pvip":false,"replies":[{"id":140309,"content":"属性宏和注解有点像","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1701523560,"ip_address":"重庆","comment_id":384711,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"感觉和注解有点像","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632887,"discussion_content":"属性宏和注解有点像","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1701523560,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":389987,"user_name":"Calvin","can_delete":false,"product_type":"c1","uid":1603004,"ip_address":"广东","ucode":"0EEF5B207623B5","user_header":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","comment_is_top":false,"comment_ctime":1714038700,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"macro_export 的示例代码中的 inner 模块的宏调用代码有点问题，需要在函数或方法中：\nmod inner {\n    super::m!();\n    crate::m!();\n}\n应该类似于：\nmod inner {\n    pub fn foo() {\n        super::m!();\n        crate::m!();\n    }\n}","like_count":0}]}