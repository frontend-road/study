{"id":73834,"title":"06 | 递归（下）：分而治之，从归并排序到MapReduce","content":"<p>你好，我是黄申。</p><p>上一节，我解释了如何使用递归，来处理迭代法中比较复杂的数值计算。说到这里，你可能会问了，有些迭代法并不是简单的数值计算，而要通过迭代的过程进行一定的操作，过程更加复杂，需要考虑很多中间数据的匹配或者保存。例如我们之前介绍的用二分查找进行数据匹配，或者我们今天将要介绍的归并排序中的数据排序等等。那么，这种情况下，还可以用递归吗？具体又该如何来实现呢？</p><p>我们可以先分析一下，这些看似很复杂的问题，是否可以简化为某些更小的、更简单的子问题来解决，这是一般思路。如果可以，那就意味着我们仍然可以使用递归的核心思想，将复杂的问题逐步简化成最基本的情况来求解。因此，今天我会从归并排序开始，延伸到多台机器的并行处理，详细讲讲递归思想在“分而治之”这个领域的应用。</p><h2>归并排序中的分治思想</h2><p>首先，我们来看，如何使用递归编程解决数字的排序问题。</p><p>对一堆杂乱无序的数字，按照从小到大或者从大到小的规则进行排序，这是计算机领域非常经典，也非常流行的问题。小到Excel电子表格，大到搜索引擎，都需要对一堆数字进行排序。因此，计算机领域的前辈们研究排序问题已经很多年了，也提出了许多优秀的算法，比如归并排序、快速排序、堆排序等等。其中，归并排序和快速排序都很好地体现了分治的思想，今天我来说说其中之一的<strong>归并排序</strong>（merge sort）。</p><!-- [[[read_end]]] --><p>很明显，归并排序算法的核心就是“归并”，也就是把两个有序的数列合并起来，形成一个更大的有序数列。</p><p>假设我们需要按照从小到大的顺序，合并两个有序数列A和B。这里我们需要开辟一个新的存储空间C，用于保存合并后的结果。</p><p>我们首先比较两个数列的第一个数，如果A数列的第一个数小于B数列的第一个数，那么就先取出A数列的第一个数放入C，并把这个数从A数列里删除。如果是B的第一个数更小，那么就先取出B数列的第一个数放入C，并把它从B数列里删除。</p><p>以此类推，直到A和B里所有的数都被取出来并放入C。如果到某一步，A或B数列为空，那直接将另一个数列的数据依次取出放入C就可以了。这种操作，可以保证两个有序的数列A和B合并到C之后，C数列仍然是有序的。</p><p>为了你能更好地理解，我举个例子说明一下，这是合并有序数组{1, 2, 5, 8}和{3, 4, 6}的过程。</p><p><img src=\"https://static001.geekbang.org/resource/image/3c/49/3c27ae183127b1a9fa3aa2ac10538149.jpg?wh=1142*856\" alt=\"\"></p><p>为了保证得到有序的C数列，我们必须保证参与合并的A和B也是有序的。可是，等待排序的数组一开始都是乱序的，如果无法保证这点，那归并又有什么意义呢？</p><p>还记得上一篇说的递归吗？这里我们就可以利用递归的思想，把问题不断简化，也就是把数列不断简化，一直简化到只剩1个数。1个数本身就是有序的，对吧？</p><p>好了，现在剩下的疑惑就是，每一次如何简化问题呢？最简单的想法是，我们将长度为n的数列，每次简化为长度为n-1的数列，直至长度为1。不过，这样的处理没有并行性，要进行n-1次的归并操作，效率就会很低。</p><p><img src=\"https://static001.geekbang.org/resource/image/4d/6e/4dd0cfbf5827c9d075483c9499a66a6e.jpg?wh=1142*762\" alt=\"\"></p><p>所以，我们可以在归并排序中引入了<strong>分而治之</strong>（Divide and Conquer）的思想。<strong>分而治之，我们通常简称为分治。它的思想就是，将一个复杂的问题，分解成两个甚至多个规模相同或类似的子问题，然后对这些子问题再进一步细分，直到最后的子问题变得很简单，很容易就能被求解出来，这样这个复杂的问题就求解出来了</strong>。</p><p>归并排序通过分治的思想，把长度为n的数列，每次简化为两个长度为n/2的数列。这更有利于计算机的并行处理，只需要log<sub>2</sub>n次归并。</p><p><img src=\"https://static001.geekbang.org/resource/image/23/ab/2395178b639c3314a427dd658ae924ab.jpg?wh=1142*668\" alt=\"\"></p><p>我们把归并和分治的思想结合起来，这其实就是归并排序算法。这种算法每次把数列进行二等分，直到唯一的数字，也就是最基本的有序数列。然后从这些最基本的有序数列开始，两两合并有序的数列，直到所有的数字都参与了归并排序。</p><p>我用一个包含0～9这10个数字的数组，给你详细讲解一下归并排序的过程。</p><ul>\n<li>\n<p>假设初始的数组为{7, 6, 2, 4, 1, 9, 3, 8, 0, 5}，我们要对它进行从小到大的排序。</p>\n</li>\n<li>\n<p>第一次分解后，变成两个数组{7, 6, 2, 4, 1}和{9, 3, 8, 0, 5}。</p>\n</li>\n<li>\n<p>然后，我们将{7, 6, 2, 4, 1}分解为{7, 6}和{2, 4, 1}，将{9, 3, 8, 0, 5}分解为{9, 3}和{8, 0, 5}。</p>\n</li>\n<li>\n<p>如果细分后的组仍然多于一个数字，我们就重复上述分解的步骤，直到每个组只包含一个数字。到这里，这些其实都是递归的嵌套调用过程。</p>\n</li>\n<li>\n<p>然后，我们要开始进行合并了。我们可以将{4, 1}分解为{4}和{1}。现在无法再细分了，我们开始合并。在合并的过程中进行排序，所以合并的结果为{1,4}。合并后的结果将返回当前函数的调用者，这就是函数返回的过程。</p>\n</li>\n<li>\n<p>重复上述合并的过程，直到完成整个数组的排序，得到{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}。</p>\n</li>\n</ul><p>为了方便你的理解，我画了张图，给你解释整个归并排序的过程。</p><p><img src=\"https://static001.geekbang.org/resource/image/53/c5/53f4f60370f04796685f913f22e8c8c5.jpg?wh=1142*856\" alt=\"\"></p><p>说到这里，我想问你，这个归并排序、分治和递归到底是什么关系呢？用一句话简单地说就是，<strong>归并排序使用了分治的思想，而这个过程需要使用递归来实现。</strong></p><p>归并排序算法用分治的思想把数列不断地简化，直到每个数列仅剩下一个单独的数，然后再使用归并逐步合并有序的数列，从而达到将整个数列进行排序的目的。而这个归并排序，正好可以使用递归的方式来实现。为什么这么说？首先，我们来看看这张图，分治的过程是不是和递归的过程一致呢？</p><p><img src=\"https://static001.geekbang.org/resource/image/29/a8/2945ead8def203f95053852c5dbd57a8.jpg?wh=1142*693\" alt=\"\"></p><p>分治的过程可以通过递归来表达，因此，归并排序最直观的实现方式就是递归。所以，我们从递归的步骤出发，来看归并排序如何实现。</p><p>我们假设n=k-1的时候，我们已经对较小的两组数进行了排序。那我们只要在n=k的时候，将这两组数合并起来，并且保证合并后的数组仍然是有序的就行了。</p><p>所以，在递归的每次嵌套调用中，代码都将一组数分解成更小的两组，然后将这两个小组的排序交给下一次的嵌套调用。而本次调用只需要关心，如何将排好序的两个小组进行合并。</p><p>在初始状态，也就是n=1的时候，对于排序的案例而言，只包含单个数字的分组。由于分组里只有一个数字，所以它已经是排好序的了，之后就可以开始递归调用的返回阶段。我这里画了张图，便于你的理解。</p><p><img src=\"https://static001.geekbang.org/resource/image/54/12/5410fb301ffce57355ad7ef074e8fd12.jpg?wh=1142*856\" alt=\"\"></p><p>你现在应该已经明白了归并排序的基本过程，最难的已经过去了，编写代码实现就不难了。我这里给出示范性代码，你可以参考看看。</p><pre><code>import java.util.Arrays;\n\npublic class Lesson6_1 {\n\t\n\t/**\n    * @Description:\t使用函数的递归（嵌套）调用，实现归并排序（从小到大）\n    * @param to_sort-等待排序的数组\n    * @return int[]-排序后的数组\n    */\n\t\n\tpublic static int[] merge_sort(int[] to_sort) {\n\t\t\n\t\tif (to_sort == null) return new int[0];\n\t\t\n\t\t// 如果分解到只剩一个数，返回该数\n\t\tif (to_sort.length == 1) return to_sort;\n\t\t\n\t\t// 将数组分解成左右两半\n\t\tint mid = to_sort.length / 2;\n\t\tint[] left = Arrays.copyOfRange(to_sort, 0, mid);\n\t\tint[] right = Arrays.copyOfRange(to_sort, mid, to_sort.length);\n\t\t\n\t\t// 嵌套调用，对两半分别进行排序\n\t\tleft = merge_sort(left);\n\t\tright = merge_sort(right);\n\t\t\n\t\t// 合并排序后的两半\n\t\tint[] merged = merge(left, right);\n\t\t\n\t\treturn merged;\n\t\t\n\t}\n   \n\n}\n</code></pre><p>这里要注意一下，在归并的步骤中，由于递归的调用确保了被合并的两个较小的数组是有序的，所以我们无需比较组内的数字，只需要比较组间的数字就行了。</p><p>这个合并过程具体的实现代码是这样的：</p><pre><code>/**\n    * @Description: 合并两个已经排序完毕的数组（从小到大）\n    * @param a-第一个数组，b-第二个数组\n    * @return int[]-合并后的数组\n    */\n    \n    public static int[] merge(int[] a, int[] b) {\n     \n     if (a == null)  a = new int[0];\n     if (b == null) b = new int[0];\n     \n     int[] merged_one = new int[a.length + b.length];\n     \n     int mi = 0, ai = 0, bi = 0;\n     \n     // 轮流从两个数组中取出较小的值，放入合并后的数组中\n     while (ai &lt; a.length &amp;&amp; bi &lt; b.length) {\n      \n      if (a[ai] &lt;= b[bi]) {\n       merged_one[mi] = a[ai];\n       ai ++;\n      } else {\n       merged_one[mi] = b[bi];\n       bi ++;\n      }\n      \n      mi ++;\n      \n     }\n     \n     // 将某个数组内剩余的数字放入合并后的数组中\n     if (ai &lt; a.length) {\n      for (int i = ai; i &lt; a.length; i++) {\n       merged_one[mi] = a[i];\n       mi ++;\n      }\n     } else {\n      for (int i = bi; i &lt; b.length; i++) {\n       merged_one[mi] = b[i];\n       mi ++;\n      }\n     }\n     \n     return merged_one;\n     \n    }\n</code></pre><p>上述两段代码的结合，就是归并排序的递归实现。你可以用这段代码进行测试：</p><pre><code>public static void main(String[] args) {\n  \n  int[] to_sort = {3434, 3356, 67, 12334, 878667, 387};\n  int[] sorted = Lesson6_1.merge_sort(to_sort);\n  \n  for (int i = 0; i &lt; sorted.length; i++) {\n   System.out.println(sorted[i]);\n  }\n }\n</code></pre><h2>分布式系统中的分治思想</h2><p>聊到这里，你应该已经了解归并排序算法是如何运作的了，也对分而治之的思想有了认识。不过，分而治之更有趣的应用其实是在分布式系统中。</p><p>例如，当需要排序的数组很大（比如达到1024GB的时候），我们没法把这些数据都塞入一台普通机器的内存里。该怎么办呢？有一个办法，我们可以把这个超级大的数据集，分解为多个更小的数据集（比如16GB或者更小），然后分配到多台机器，让它们并行地处理。</p><p>等所有机器处理完后，中央服务器再进行结果的合并。由于多个小任务间不会相互干扰，可以同时处理，这样会大大增加处理的速度，减少等待时间。</p><p>在单台机器上实现归并排序的时候，我们只需要在递归函数内，实现数据分组以及合并就行了。而在多个机器之间分配数据的时候，递归函数内除了分组及合并，还要负责把数据分发到某台机器上。</p><p><img src=\"https://static001.geekbang.org/resource/image/78/31/78eefc6b61bad62f257f2b5e4972f031.jpg?wh=1142*711\" alt=\"\"></p><p>在这个框架图中，你应该可以看到，分布式集群中的数据切分和合并，同单台机器上归并排序的过程是一样的，因此也是使用了分治的思想。从理论的角度来看，上面这个图很容易理解。不过在实际运用中，有个地方需要注意一下。</p><p>上图中的父结点，例如机器1、2、3，它们都没有被分配排序的工作，只是在子结点的排序完成后进行有序数组的合并，因此集群的性能没有得到充分利用。那么，另一种可能的数据切分方式是，每台机器拿出一半的数据给另一台机器处理，而自己来完成剩下一半的数据。</p><p><img src=\"https://static001.geekbang.org/resource/image/1d/58/1d278b81c4bd3b6bc522f34cbe298c58.jpg?wh=1142*511\" alt=\"\"></p><p>如果分治的时候，只进行一次问题切分，那么上述层级型的分布式架构就可以转化为类似MapReduce的架构。我画出了MapReduce的主要步骤，你可以看看，这里面有哪些步骤体现了分治的思想？</p><p><img src=\"https://static001.geekbang.org/resource/image/08/5a/08155dd375f7b049424a6686bcb6475a.jpg?wh=1068*800\" alt=\"\"></p><p>这里面主要有三个步骤用到了分治的思想。</p><h3>1. 数据分割和映射</h3><p>分割是指将数据源进行切分，并将分片发送到Mapper上。映射是指Mapper根据应用的需求，将内容按照键-值的匹配，存储到哈希结构中。这两个步骤将大的数据集合切分为更小的数据集，降低了每台机器节点的负载，因此和分治中的问题分解类似。不过，MapReduce采用了哈希映射来分配数据，而普通的分治或递归不一定需要。</p><h3>2.归约</h3><p>归约是指接受到的一组键值配对，如果是键内容相同的配对，就将它们的值归并。这和本机的递归调用后返回结果的过程类似。不过，由于哈希映射的关系，MapReduce还需要洗牌的步骤，也就是将键-值的配对不断地发给对应的Reducer进行归约。普通的分治或递归不一定需要洗牌的步骤。</p><h3>3.合并</h3><p>为了提升洗牌阶段的效率，可以选择减少发送到归约阶段的键-值配对。具体做法是在数据映射和洗牌之间，加入合并的过程，在每个Mapper节点上先进行一次本地的归约。然后只将合并的结果发送到洗牌和归约阶段。这和本机的递归调用后返回结果的过程类似。</p><p>说了这么多，你现在对分治应该有比较深入的理解了。实际上，分治主要就是用在将复杂问题转化为若干个规模相当的小问题上。分治思想通常包括问题的细分和结果的合并，正好对应于递归编程的函数嵌套调用和函数结果的返回。细分后的问题交给嵌套调用的函数去解决，而结果合并之后交由函数进行返回。所以，分治问题适合使用递归来实现。同时，分治的思想也可以帮助我们设计分布式系统和并行计算，细分后的问题交给不同的机器来处理，而其中的某些机器专门负责收集来自不同机器的处理结果，完成结果的合并。</p><h2>小结</h2><p>这两节我们学习了递归法。递归采用了和数学归纳法类似的思想，但是它用的是逆向递推，化繁为简，把复杂的问题逐步简化。再加上分治原理，我们就可以更有效地把问题细分，进行并行化的处理。</p><p>而计算机编程中的函数嵌套调用，正好对应了数学中递归的逆向递推，所以你只要弄明白了数学递推式，就能非常容易的写出对应的递归编码。这是为什么递归在编程领域有着非常广泛的应用。不过，需要注意的是，递归编程在没有开始返回结果之前，保存了大量的中间结果，所以比较消耗系统资源。这也是一般的编程语言都会限制递归的深度（也就是嵌套的次数）的原因。</p><p><img src=\"https://static001.geekbang.org/resource/image/09/fe/0908dbae238006c1b8bafb09f9839bfe.jpg?wh=1242*1709\" alt=\"\"></p><h2>思考题</h2><p>你有没有想过，在归并排序的时候，为什么每次都将原有的数组分解为两组，而不是更多组呢？如果分为更多组，是否可行？</p><p><span class=\"orange\">欢迎在留言区交作业，并写下你今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</span></p>","neighbors":{"left":{"article_title":"05 | 递归（上）：泛化数学归纳，如何将复杂问题简单化？","id":73511},"right":{"article_title":"07 | 排列：如何让计算机学会“田忌赛马”？","id":75129}},"comments":[{"had_liked":false,"id":52350,"user_name":"Healtheon","can_delete":false,"product_type":"c1","uid":1206751,"ip_address":"","ucode":"B564B1FC4456E8","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/df/2dca1305.jpg","comment_is_top":false,"comment_ctime":1545365321,"is_pvip":false,"replies":[{"id":"19039","content":"很好的回答👍","user_name":"作者回复","user_name_real":"Sean","uid":"1275061","ctime":1545374061,"ip_address":"","comment_id":52350,"utype":1}],"discussion_count":5,"race_medal":0,"score":"735984772937","product_id":100021201,"comment_content":"老师讲的是最经典的2路归并排序算法，时间复杂度是O(NlogN)。如果将数组分解成更多组（假设分成K组），是K路归并排序算法，当然是可以的，比如K=3时，是3路归并排序，依次类推。3路归并排序是经典的归并排序（路归并排序）的变体，通过递归树方法计算等式T(n)= 3T(n&#47;3)+ O(n)可以得到3路归并排序的时间复杂度为O(NlogN)，其中logN以3为底（不方便打出，只能这样描述）。尽管3路合并排序与2路相比，时间复杂度看起来比较少，但实际上花费的时间会变得更高，因为合并功能中的比较次数会增加。类似的问题还有二分查找比三分查找更受欢迎。","like_count":172,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433842,"discussion_content":"很好的回答👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545374061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1649594,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK66wjYZxVSnSJ33hbBCzSgHXsyQia8JrvJvibeH6Fcficu1lx83K0gzc3lpcxYllqH9ficibqanqKWGrA/132","nickname":"Geek_b5876e","note":"","ucode":"DE272DE44DCF03","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":315353,"discussion_content":"本质上n路归并和2路归并没有差别，n叉树与2叉树也没有区别。不过递归实现的话，n路归并相对于2路来说，递归的深度会更小一些。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603265903,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1127175,"avatar":"https://static001.geekbang.org/account/avatar/00/11/33/07/8f351609.jpg","nickname":"JustDoDT","note":"","ucode":"6AF0B80F00EAEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":167728,"discussion_content":"高手","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581518504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1519230,"avatar":"https://static001.geekbang.org/account/avatar/00/17/2e/7e/acc47ee1.jpg","nickname":"OUO","note":"","ucode":"52EEB72E80BAF8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":129871,"discussion_content":"回答的很好,点赞!\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578743103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1082785,"avatar":"https://static001.geekbang.org/account/avatar/00/10/85/a1/2442332c.jpg","nickname":"郭俊杰","note":"","ucode":"D328E5738A4413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":104600,"discussion_content":"回答的很好，给个赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577442812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":52186,"user_name":"大悲","can_delete":false,"product_type":"c1","uid":1341085,"ip_address":"","ucode":"3A7865964B0159","user_header":"https://static001.geekbang.org/account/avatar/00/14/76/9d/bfcdbdda.jpg","comment_is_top":false,"comment_ctime":1545344309,"is_pvip":false,"replies":[{"id":"19043","content":"用堆取最小值，思路不错","user_name":"作者回复","user_name_real":"Sean","uid":"1275061","ctime":1545374399,"ip_address":"","comment_id":52186,"utype":1}],"discussion_count":2,"race_medal":0,"score":"138984297781","product_id":100021201,"comment_content":"思考题：<br>如果不是分为两组，而是多组是可行的，但是处理起来比较麻烦。虽然分组的时候，能够更快完成，但是在合并的时候需要同时比较多组中的数据，取最小的一个。当分组数量比较大的时候，在合并的时候，为了考虑效率，需要维护一个堆来取最小值。假设分为N组，分组的时间复杂度是logn(N为底), 合并的时候时间复杂度为nlogN，总的时间复杂度不变，还是nlogn。不知道理解对不对，请老师指教！","like_count":32,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433772,"discussion_content":"用堆取最小值，思路不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545374399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1250922,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIzGGthScz54sECZJKX3lgyjCATkgrvSt5N3eOsYB34jibCr3SkAX88QaZ5IVmME9Ec7VdkQGwRSPw/132","nickname":"哈哈哈","note":"","ucode":"8AC20A1C9C7DF8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303316,"discussion_content":"感觉是n*logN*logn","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599211029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":53182,"user_name":"swortect","can_delete":false,"product_type":"c1","uid":1288071,"ip_address":"","ucode":"A8C294E590C1B6","user_header":"https://static001.geekbang.org/account/avatar/00/13/a7/87/4f2fa359.jpg","comment_is_top":false,"comment_ctime":1545614291,"is_pvip":false,"replies":[{"id":"19277","content":"这里我有个细节没说清楚，如果数组是有序的，每次只需要从磁盘，有序的取出一部分到内存进行合并","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1545618307,"ip_address":"","comment_id":53182,"utype":1}],"discussion_count":3,"race_medal":0,"score":"104624829395","product_id":100021201,"comment_content":"老师，如果要排序的数组很大，两个最大的子节点排好序之后，交给最终的机器做最后的排序依然是一堆数据放在一个机器上","like_count":24,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434058,"discussion_content":"这里我有个细节没说清楚，如果数组是有序的，每次只需要从磁盘，有序的取出一部分到内存进行合并","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545618307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1449990,"avatar":"https://static001.geekbang.org/account/avatar/00/16/20/06/6ca43f2d.jpg","nickname":"厚积薄发","note":"","ucode":"FDF273091C66B7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":359247,"discussion_content":"我想到一个，每台机器各自排序好后，每次只取最小的一位来参与比较，直接追加到一个bigFile。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616150007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1565302,"avatar":"https://static001.geekbang.org/account/avatar/00/17/e2/76/c4e85199.jpg","nickname":"傻傻滴","note":"","ucode":"EAB11F3418714F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327623,"discussion_content":"外排就是这个思路","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605876091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":52258,"user_name":"指间砂的宿命","can_delete":false,"product_type":"c1","uid":1338245,"ip_address":"","ucode":"DFAE22BF3BD415","user_header":"https://static001.geekbang.org/account/avatar/00/14/6b/85/be43d09f.jpg","comment_is_top":false,"comment_ctime":1545355344,"is_pvip":false,"replies":[{"id":"19044","content":"是的 有读者说可以用堆来取多个组的最小值，虽然可行，但确实比较复杂","user_name":"作者回复","user_name_real":"Sean","uid":"1275061","ctime":1545374457,"ip_address":"","comment_id":52258,"utype":1}],"discussion_count":1,"race_medal":0,"score":"53084962896","product_id":100021201,"comment_content":"分成超过两个组的更多组是可行的，不过这样在递归调用时一个是有可能产生更多的中间状态数据，再一个在合并阶段，需要比较更多个分组的数据，实际上在最小粒度的时候，比较大小的就是两个数字，即便上层分成多个组，在合并的最底层依旧是从两两之间比较合并的，感觉分成多组的并没有啥优势，还带来了比较处理的复杂性","like_count":12,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433808,"discussion_content":"是的 有读者说可以用堆来取多个组的最小值，虽然可行，但确实比较复杂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545374457,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":56864,"user_name":"永旭","can_delete":false,"product_type":"c1","uid":1068819,"ip_address":"","ucode":"C9C74BE32C8F46","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/13/5197f8d2.jpg","comment_is_top":false,"comment_ctime":1546570777,"is_pvip":false,"replies":[{"id":"20587","content":"在这个例子里不会出现，不过在实际工作中，这个函数可能被其他代码调用，为了保险起见，加一个最基本的非法检测","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1546649334,"ip_address":"","comment_id":56864,"utype":1}],"discussion_count":1,"race_medal":0,"score":"40201276441","product_id":100021201,"comment_content":"老师,你好<br>归并排序代码中有非空判断代码<br>if (a == null) a = new int[0];<br>if (to_sort == null) return to_sort;<br>什么情况下会出现数组是null??<br>","like_count":9,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435286,"discussion_content":"在这个例子里不会出现，不过在实际工作中，这个函数可能被其他代码调用，为了保险起见，加一个最基本的非法检测","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546649334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":52508,"user_name":"逐风随想","can_delete":false,"product_type":"c1","uid":1286435,"ip_address":"","ucode":"A91C191EE82FCA","user_header":"https://static001.geekbang.org/account/avatar/00/13/a1/23/2b527dc4.jpg","comment_is_top":false,"comment_ctime":1545401369,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"40200107033","product_id":100021201,"comment_content":"上学只上到初二，已经十几年没学习数学了。自从做了3年程序员，一碰到数学问题就头痛。","like_count":9,"discussions":[{"author":{"id":1008348,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/dc/8876c73b.jpg","nickname":"moooofly","note":"","ucode":"4A20795C281B6F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591047,"discussion_content":"我才上到小学5年级，头痛的不行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666244309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":54960,"user_name":"会飞的猪","can_delete":false,"product_type":"c1","uid":1340194,"ip_address":"","ucode":"05EB9BF31F603D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIEONynt1pibq4AInxllIgSz3zJrB4tiabJwibYAohfcGTvScicboZkM03Wgic4dA4H1obcyAm9nbGR4pA/132","comment_is_top":false,"comment_ctime":1545988933,"is_pvip":false,"replies":[{"id":"20069","content":"作为初学者，写得很不错👍","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1546213071,"ip_address":"","comment_id":54960,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35905727301","product_id":100021201,"comment_content":"python实现代码：<br>def mergeSort(list):<br>    if(len(list)==0):<br>        return 0<br>    if(len(list)==1):<br>        return list[0]<br>    else:<br>        listHalfLen=int(len(list)&#47;2)<br>        left=mergeSort(list[0:listHalfLen])<br>        right=mergeSort(list[listHalfLen:])<br>        data=merge(left,right)<br>        return data<br><br>def merge(left,right):<br>    mid=[]<br>    ai=0<br>    bi=0<br>    if(isinstance(left,int)):<br>        leftLen=1<br>        left=[left]<br>    else:<br>        leftLen=len(left)<br>    if(isinstance(right,int)):<br>        rightLen=1<br>        right=[right]<br>    else:<br>        rightLen = len(right)<br>    while(ai &lt; leftLen and bi &lt; rightLen):<br>        if(left[ai]&lt;right[bi]):<br>            mid.append(left[ai])<br>            ai+=1<br>        else:<br>            mid.append(right[bi])<br>            bi+=1<br>    if(ai&lt; leftLen):<br>        newleft=left[ai:]<br>        for i in newleft:<br>            mid.append(i)<br>    else:<br>        newright = right[bi:]<br>        for i in newright:<br>            mid.append(i)<br>    return mid<br>list=[3,8,5,9,7,1,10]<br>mergeSort(list)<br>刚学python，希望大家多多指教","like_count":8,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434630,"discussion_content":"作为初学者，写得很不错👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546213071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57786,"user_name":"Joe","can_delete":false,"product_type":"c1","uid":1337998,"ip_address":"","ucode":"EC76699640B7BF","user_header":"https://static001.geekbang.org/account/avatar/00/14/6a/8e/7b6ea886.jpg","comment_is_top":false,"comment_ctime":1546910835,"is_pvip":false,"replies":[{"id":"20812","content":"是的👍","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1546913130,"ip_address":"","comment_id":57786,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31611681907","product_id":100021201,"comment_content":"分成多组归并，主要是合并比较会比较麻烦，会在合并时增加复杂度。比如比较2个数大小，只需要1次，而比较3个数大小，最多需要3次。","like_count":7,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435760,"discussion_content":"是的👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546913130,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57313,"user_name":"子非","can_delete":false,"product_type":"c1","uid":1161190,"ip_address":"","ucode":"795787FD64B035","user_header":"https://static001.geekbang.org/account/avatar/00/11/b7/e6/83bdccda.jpg","comment_is_top":false,"comment_ctime":1546744162,"is_pvip":false,"replies":[{"id":"20728","content":"是的 需要转换成循环 或者栈的数据结构","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1546827928,"ip_address":"","comment_id":57313,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27316547938","product_id":100021201,"comment_content":"递归层次太多了，堆栈会溢出","like_count":6,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435520,"discussion_content":"是的 需要转换成循环 或者栈的数据结构","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546827928,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105937,"user_name":"刘明","can_delete":false,"product_type":"c1","uid":1113614,"ip_address":"","ucode":"95BE75871C675F","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/0e/e40ce6ea.jpg","comment_is_top":false,"comment_ctime":1561107580,"is_pvip":false,"replies":[{"id":"38395","content":"很好的比较","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1561247031,"ip_address":"","comment_id":105937,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23035944060","product_id":100021201,"comment_content":"和快排对比，虽然时间复杂度都是nlogN，但是归并排序的空间复杂度是O(n)，快排则是原地排序。不过归并排序是稳定排序，快排则不是，两种各有优势。","like_count":5,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454879,"discussion_content":"很好的比较","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561247031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1344356,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJLgibqHsl97Onskia6nuRwiazQO8QO4WOrTxf5fue2iay2U0b7kUzYXBn0OwctDeLpiaVHiacPmU5QSCUw/132","nickname":"Geek_e91ff8","note":"","ucode":"F97DA5818751AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":67834,"discussion_content":"终于有人说到了空间复杂度，其实我有点不明白，不稳定排序有什么问题，老师求解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575181552,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99842,"user_name":"叶嘉祺","can_delete":false,"product_type":"c1","uid":1524893,"ip_address":"","ucode":"20BDDF12BD835B","user_header":"https://static001.geekbang.org/account/avatar/00/17/44/9d/9673a0f8.jpg","comment_is_top":false,"comment_ctime":1559320363,"is_pvip":false,"replies":[{"id":"35919","content":"第一次看到读者证明二分法是最优的，赞一个。至于归并排序应该是类似的，唯一不同的是，归并的合并过程也有一个复杂度要计算，而不是像比较大小那样O(1)","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1559408644,"ip_address":"","comment_id":99842,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23034156843","product_id":100021201,"comment_content":"可以用数学方法证明二分归并排序是最优的应该。二分查找是可以证明的。<br><br>二分法我是这样证明的: https:&#47;&#47;ghostbody.github.io&#47;posts&#47;algorithmn&#47;prove-binary-search-is-better&#47;<br><br>对于归并排序我还在思考利用主定理进行证明。<br><br>老师可以一起看下怎么证？","like_count":5,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452289,"discussion_content":"第一次看到读者证明二分法是最优的，赞一个。至于归并排序应该是类似的，唯一不同的是，归并的合并过程也有一个复杂度要计算，而不是像比较大小那样O(1)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559408644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":68662,"user_name":"有品味的混球","can_delete":false,"product_type":"c1","uid":1041616,"ip_address":"","ucode":"C69D823A9DF5E5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e4/d0/ed066d6a.jpg","comment_is_top":false,"comment_ctime":1550569889,"is_pvip":false,"replies":[{"id":"24418","content":"这个概念涉及了比较多分布式系统的设计，我可以在后面加餐内容放入一些，或者是放到实战篇内容补上","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1550598455,"ip_address":"","comment_id":68662,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23025406369","product_id":100021201,"comment_content":"MapReduce 分割，映射，洗牌，归约这几个步骤没有具体的例子，就感觉不是很明白，希望这几个步骤还是用文章前半部分的排序的例子来分别举例","like_count":5,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439789,"discussion_content":"这个概念涉及了比较多分布式系统的设计，我可以在后面加餐内容放入一些，或者是放到实战篇内容补上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550598455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1529929,"avatar":"","nickname":"起风了001","note":"","ucode":"8DCDBA40B8CC9F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371107,"discussion_content":"是的, 一般是后台的才用这个框架, 做前台的, 没用的都不知道是什么功能什么作用, 肯定是看不懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619657276,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":55132,"user_name":"代码世界没有爱情","can_delete":false,"product_type":"c1","uid":1345493,"ip_address":"","ucode":"3AB6EE5E0B6773","user_header":"","comment_is_top":false,"comment_ctime":1546050174,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23020886654","product_id":100021201,"comment_content":"# 切分<br>def split_list(temp_list):<br>    if not isinstance(temp_list, list):<br>        raise TypeError<br>    else:<br>        if not temp_list:<br>            raise ValueError<br>        else:<br>            length = len(temp_list)<br>            if length == 1:<br>                return temp_list<br>            import math<br>            left = math.ceil(length &#47; 2)<br>            del math<br>            left_list = split_list(temp_list[:left])<br>            right_list = split_list(temp_list[left:])<br>            return merger_list(left_list, right_list)<br><br><br># 归并<br>def merger_list(left, right):<br>    result = []<br>    while True:<br><br>        if left and right:<br>            left_0 = left[0]<br>            right_0 = right[0]<br>            if left_0 &gt; right_0:<br>                min_num = right.pop(0)<br>            else:<br>                min_num = left.pop(0)<br>            result.append(min_num)<br>        elif left:<br>            result.append(left.pop(0))<br><br>        elif right:<br>            result.append(right.pop(0))<br>        else:<br>            break<br>    return result<br><br><br>print(split_list([3, 1, 2, 7, 4, 6, 9, 9, 10, 11, 4, 5]))","like_count":5},{"had_liked":false,"id":53421,"user_name":"Mr.J","can_delete":false,"product_type":"c1","uid":1267172,"ip_address":"","ucode":"372D8C614F6C3D","user_header":"https://static001.geekbang.org/account/avatar/00/13/55/e4/7061abd5.jpg","comment_is_top":false,"comment_ctime":1545640798,"is_pvip":false,"replies":[{"id":"19407","content":"这是个好的想法，我觉得和实际数据的分布有关，不同的分布可以找到不同的平衡点，不过本身要测算数据的分布可能更耗时间。如果事先知道了数据的特点，应该是可以结合不同的排序来优化","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1545666630,"ip_address":"","comment_id":53421,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18725509982","product_id":100021201,"comment_content":"老师您好，归并这种，比如数组排序无限的对半分开，这样会不会性能反而不如对半分开到一定程度，剩下的用别的排序算法，应该有一个平衡点吧","like_count":4,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434134,"discussion_content":"这是个好的想法，我觉得和实际数据的分布有关，不同的分布可以找到不同的平衡点，不过本身要测算数据的分布可能更耗时间。如果事先知道了数据的特点，应该是可以结合不同的排序来优化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545666630,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":198238,"user_name":"罗耀龙@坐忘","can_delete":false,"product_type":"c1","uid":1917663,"ip_address":"","ucode":"3CEA258DE7F3C7","user_header":"https://static001.geekbang.org/account/avatar/00/1d/42/df/a034455d.jpg","comment_is_top":false,"comment_ctime":1585424837,"is_pvip":true,"replies":[{"id":"75047","content":"很好的比喻","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1585629726,"ip_address":"","comment_id":198238,"utype":1}],"discussion_count":1,"race_medal":5,"score":"14470326725","product_id":100021201,"comment_content":"茶艺师学编程<br><br><br>递归的“分而治之”的思想，其实在社会中能找到相应的例子。<br><br><br>往古老的说，在工业革命之前，西方世界的社会结构就符合递归的“分而治之”：最顶端是国王，下一层是各个贵族，贵族下面是骑士（日本是武士）。国王只管他下面的贵族，贵族的骑士他是不管的；同样的，贵族只管他下面的骑士，骑士下面的人他是不管的。就是所谓“仆人的仆人不是自己的仆人。”<br><br><br>就今天而言，很多单位的组织结构，其实也是这样“分而治之”。一个国家的总理管着各个省长，省长管着市长，市长管着县长——每一级组织都是上一级组织的缩小版，而且在管理上，不提倡越级管理。<br><br><br>当然，能把递归玩的炉火纯青的，还得属于各位程序员大神。<br><br><br>关于思考题，在归并排序的时候为什么每次都将原有的数组分解成两组，而不是更多组？如果分为更多组，是否可行？<br><br><br>那是因为，“两两比较”才是排序的最小步骤，如果分更多的组，会增加运算过程中的不确定性，甚至无法使用递归思想来实现。<br><br>","like_count":3,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489671,"discussion_content":"很好的比喻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585629726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":58309,"user_name":"Ricky","can_delete":false,"product_type":"c1","uid":1238256,"ip_address":"","ucode":"0B29C730CAD29C","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/f0/82281239.jpg","comment_is_top":false,"comment_ctime":1547033858,"is_pvip":false,"replies":[{"id":"21440","content":"实现的思路很清晰，还用到了位移操作👌","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1547405894,"ip_address":"","comment_id":58309,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14431935746","product_id":100021201,"comment_content":"&#47;*<br> * 采用分而治之思想实现数组排序, 递归为其实现技巧<br> *&#47;<br>#include &lt;iostream&gt;<br><br>using namespace std;<br><br>void merge(int *array, int low, int mid, int high) {<br>    &#47;&#47; left: low ~ mid, right: mid+1 ~ high<br>    int size = high - low + 1;<br>    int *tmp = new int[size];<br>    int i = low, j = mid+1, k = 0;<br>    while (i &lt;= mid &amp;&amp; j &lt;= high) {<br>        if (array[i] &lt;= array[j]) {<br>            tmp[k++] = array[i++];<br>        } else {<br>            tmp[k++] = array[j++];<br>        }<br>    }<br><br>    &#47;&#47; the rest elements<br>    while (i &lt;= mid) {<br>        tmp[k++] = array[i++];<br>    }<br>    while (j &lt;= high) {<br>        tmp[k++] = array[j++];<br>    }<br><br>    &#47;&#47; copy the elements to original array<br>    for (k = 0; k &lt; size; ++k) {<br>        array[k+low] = tmp[k];<br>    }<br>}<br><br>void _mergeSort(int *array, int low, int high) {<br>    if (low &gt;= high) return;<br>    int mid = low + ((high-low) &gt;&gt; 1);<br>    _mergeSort(array, low, mid);<br>    _mergeSort(array, mid+1, high);<br>    merge(array, low, mid, high);<br>}<br><br>void mergeSort(int *array, int size) {<br>    cout &lt;&lt; &quot;*****************before**************&quot; &lt;&lt; endl;<br>    for (int i = 0; i &lt; size; ++i) {<br>        cout &lt;&lt; array[i] &lt;&lt; &quot; &quot;;<br>    }<br>    cout &lt;&lt; endl;<br>    _mergeSort(array, 0, size-1);<br>    cout &lt;&lt; &quot;*****************after**************&quot; &lt;&lt; endl;<br>    for (int i = 0; i &lt; size; ++i) {<br>        cout &lt;&lt; array[i] &lt;&lt; &quot; &quot;;<br>    }<br>    cout &lt;&lt; endl;<br>}<br><br>int main() {<br><br>    int array[] = {2, 3, 5, 1, 4, 9, 7, 6, 10};<br>    mergeSort(array, 9);<br><br>    return 0;<br>}<br>*****************before**************<br>2 3 5 1 4 9 7 6 10<br>*****************after**************<br>1 2 3 4 5 6 7 9 10<br>","like_count":3,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436003,"discussion_content":"实现的思路很清晰，还用到了位移操作👌","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547405894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200038,"user_name":"Geek_2426","can_delete":false,"product_type":"c1","uid":1848324,"ip_address":"","ucode":"6909FB989D75FF","user_header":"https://static001.geekbang.org/account/avatar/00/1c/34/04/57e42586.jpg","comment_is_top":false,"comment_ctime":1585535715,"is_pvip":false,"replies":[{"id":"75039","content":"加油，循序渐进总有收获","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1585628963,"ip_address":"","comment_id":200038,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10175470307","product_id":100021201,"comment_content":"学到了，学到了，数学好难，又爱又恨","like_count":2,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489927,"discussion_content":"加油，循序渐进总有收获","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585628963,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":195163,"user_name":"拉普达","can_delete":false,"product_type":"c1","uid":1930686,"ip_address":"","ucode":"0E524C0D99B2A0","user_header":"https://static001.geekbang.org/account/avatar/00/1d/75/be/6f3ab95e.jpg","comment_is_top":false,"comment_ctime":1585142784,"is_pvip":false,"replies":[{"id":"74505","content":"是的","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1585350991,"ip_address":"","comment_id":195163,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5880110080","product_id":100021201,"comment_content":"二分是最优的。两个数一次比较就能确定序关系。3个数需要3次，4个需要5次。N个数的情况，需要k次（2＾k≥N!）。分得越多，merge效率越低。只有N=2，merge的过程效率最高。","like_count":1,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488993,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585350991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165317,"user_name":"cwtxz","can_delete":false,"product_type":"c1","uid":1778151,"ip_address":"","ucode":"4F35AEDB8F5D5D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/BAuQlia9Dc07m3icOkibIqu2lhbnLD6cjgCNE8FSzG5Aj4cd26eRgspicTsWvA7WK1ftlQBD34PYRucZRXML5FA27A/132","comment_is_top":false,"comment_ctime":1577199697,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5872166993","product_id":100021201,"comment_content":"每当有想不明白的数学问题的时候。我就会停下来，去研读哲学，之所以如此，是因为哲学能够让人以辩证的思维去思考问题，这样能够从侧面去辅助我思考数学问题。哲学，说白了，就是要让人懂得思考，就是给人们提供正确的思维方法，提高你的思维能力，使你面临任何场合，你都能够为自己找到一条出路，而不是感到茫然。研读了哲学，你能学会更好地思考，哲学看似玄虚，实则是在潜移默化地提高你的综合素质，给你的学习生活指明了目标和方向，让你明白自己是为何而战。所以，今天 我遇到了数学的学习瓶颈，我选择用哲学思维来帮助我思考，加油。","like_count":1},{"had_liked":false,"id":67040,"user_name":"杰之7","can_delete":false,"product_type":"c1","uid":1297232,"ip_address":"","ucode":"F7DA2E21085332","user_header":"https://static001.geekbang.org/account/avatar/00/13/cb/50/66d0bd7f.jpg","comment_is_top":false,"comment_ctime":1550060030,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5845027326","product_id":100021201,"comment_content":" 通过这一节的阅读学习，对归并排序算法有了理解。本质上就是二步，先分后和。而分开的过程中使用的分治的思想，实现分开中用递归的方法来实现。合并把函数结果返回。<br><br>在大数据领域中，HDFS和MapReduce中都使用了这种分治的思想，把数据集划分给不同的机器，每台机器把数据分成许多块，Yarn调用程序让MR处理对应的数据，达到对海量数据的处理。<br><br>目前需要做的就是理解之后花些时间实践，这样在原理的基础上更好的去理解。","like_count":1},{"had_liked":false,"id":58710,"user_name":"méng","can_delete":false,"product_type":"c1","uid":1338665,"ip_address":"","ucode":"44DAD63C738E9F","user_header":"https://static001.geekbang.org/account/avatar/00/14/6d/29/ae69a30f.jpg","comment_is_top":false,"comment_ctime":1547180647,"is_pvip":false,"replies":[{"id":"21442","content":"逻辑上很清晰","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1547406060,"ip_address":"","comment_id":58710,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5842147943","product_id":100021201,"comment_content":"js 写的代码<br><br><br>function guibingorder(arr) {<br><br>if (arr.length &gt; 1) {<br>var leftarr = [];<br>var rightarr = [];<br>var splitindex = Math.floor(arr.length &#47; 2);<br>leftarr = arr.slice(0, splitindex);<br>rightarr = arr.slice(splitindex, arr.length);<br><br>leftarr = arguments.callee(leftarr);<br>rightarr = arguments.callee(rightarr);<br><br>var result = [];<br>while (Math.max(leftarr.length, rightarr.length) &gt; 0) {<br>&#47;&#47;右边遍历完了 或者 左边比右边的小，则 从左边取出来<br>if (rightarr.length == 0 || leftarr[0] &lt; rightarr[0]) {<br>result.push(leftarr[0]);<br>leftarr.splice(0, 1);<br>} else {<br>result.push(rightarr[0]);<br>rightarr.splice(0, 1);<br>}<br>}<br><br>return result;<br>}<br>return arr;<br>}","like_count":1,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436184,"discussion_content":"逻辑上很清晰","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547406060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1622899,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c3/73/1c8bf894.jpg","nickname":"ricarduuu","note":"","ucode":"F663CF156764C0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53424,"discussion_content":"不行的 爆栈了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574167399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":55816,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1546315271,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5841282567","product_id":100021201,"comment_content":"思考题：一分为二，是为了处理起来简单，这样也就有了更好的通用性；当然，分成很多也是可行的，但是在数学上，它们是等价的。这个问题类似于在算法领域只研究二叉树","like_count":1},{"had_liked":false,"id":55133,"user_name":"代码世界没有爱情","can_delete":false,"product_type":"c1","uid":1345493,"ip_address":"","ucode":"3AB6EE5E0B6773","user_header":"","comment_is_top":false,"comment_ctime":1546050192,"is_pvip":false,"replies":[{"id":"20065","content":"Python的实现 不错","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1546210952,"ip_address":"","comment_id":55133,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5841017488","product_id":100021201,"comment_content":"# python实现<br># 切分<br>def split_list(temp_list):<br>    if not isinstance(temp_list, list):<br>        raise TypeError<br>    else:<br>        if not temp_list:<br>            raise ValueError<br>        else:<br>            length = len(temp_list)<br>            if length == 1:<br>                return temp_list<br>            import math<br>            left = math.ceil(length &#47; 2)<br>            del math<br>            left_list = split_list(temp_list[:left])<br>            right_list = split_list(temp_list[left:])<br>            return merger_list(left_list, right_list)<br><br><br># 归并<br>def merger_list(left, right):<br>    result = []<br>    while True:<br><br>        if left and right:<br>            left_0 = left[0]<br>            right_0 = right[0]<br>            if left_0 &gt; right_0:<br>                min_num = right.pop(0)<br>            else:<br>                min_num = left.pop(0)<br>            result.append(min_num)<br>        elif left:<br>            result.append(left.pop(0))<br><br>        elif right:<br>            result.append(right.pop(0))<br>        else:<br>            break<br>    return result<br><br><br>print(split_list([3, 1, 2, 7, 4, 6, 9, 9, 10, 11, 4, 5]))","like_count":1,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434682,"discussion_content":"Python的实现 不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546210952,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":53091,"user_name":"changchen","can_delete":false,"product_type":"c1","uid":1338212,"ip_address":"","ucode":"B1A7AFEA879C4A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLI6ibAJRoCG6gLxsmvmSl3vuuPicfrQD9tdvib64LocIhUXYpaveJEaHjgqKgAzpz0VHpy3MAbozz5g/132","comment_is_top":false,"comment_ctime":1545582083,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5840549379","product_id":100021201,"comment_content":"哈哈 这个问题我记得当初公司宿舍聊过，分组多的话单从复杂度计算上是降低了，舍友（做硬件安全的）告诉我说是因为计算机是二级制的，底层处理上实际上多分组是效率低的。至今不明白其中的缘由，希望老师指点^^","like_count":1,"discussions":[{"author":{"id":1435060,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e5/b4/b664e721.jpg","nickname":"Alice","note":"","ucode":"C1AFB9DC57A4BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326499,"discussion_content":"二进制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605607120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":52789,"user_name":"茴香根","can_delete":false,"product_type":"c1","uid":1316111,"ip_address":"","ucode":"B91C00B72077F1","user_header":"https://static001.geekbang.org/account/avatar/00/14/15/0f/954be2db.jpg","comment_is_top":false,"comment_ctime":1545529790,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5840497086","product_id":100021201,"comment_content":"思考题，假设分成k组，是可行，但是k组之间的合并问题同样可以用归并的思想再去分解解决。除非k这个数字对特殊的问题有明显的解决优势，不然不建议分成k组。还是分成2组解决比较简单。","like_count":1},{"had_liked":false,"id":52645,"user_name":"我心留","can_delete":false,"product_type":"c1","uid":1338206,"ip_address":"","ucode":"09901B29C5613F","user_header":"https://static001.geekbang.org/account/avatar/00/14/6b/5e/b76e7a79.jpg","comment_is_top":false,"comment_ctime":1545465453,"is_pvip":false,"replies":[{"id":"19173","content":"是的，排序体现在将两个有序数组合并","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1545498522,"ip_address":"","comment_id":52645,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5840432749","product_id":100021201,"comment_content":"老师，我觉得排序的功能应该体现在合并的那块函数中吧，所以第二个函数的功能应该是排序并合并两个数组吧，第一个函数只体现了分解的功能，所以嵌套调用时，只是对两半进行分解，而不是排序。我这样理解对吗，老师？","like_count":1,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433935,"discussion_content":"是的，排序体现在将两个有序数组合并","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545498522,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":52425,"user_name":"文刂 氵共 超","can_delete":false,"product_type":"c1","uid":1282813,"ip_address":"","ucode":"C2CE1512D23012","user_header":"https://static001.geekbang.org/account/avatar/00/13/92/fd/6b0e58fe.jpg","comment_is_top":false,"comment_ctime":1545380137,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5840347433","product_id":100021201,"comment_content":"C++实现归并排序<br>#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br><br>using namespace std;<br><br>&#47;&#47; 拷贝数组函数<br>&#47;&#47; 将数组SourceData的第BeginIndex个元素~第EndIndex个元素拷贝到另一个数组中，并返回<br>template &lt;class T&gt;<br>vector&lt;T&gt; CopyVectorData(vector&lt;T&gt; &amp;SourceData, int BeginIndex, int EndIndex)<br>{<br>\tvector&lt;T&gt; tempVec;<br>\t<br>\tfor (int i = BeginIndex; i &lt;= EndIndex; ++i)<br>\t{<br>\t\ttempVec.push_back(SourceData[i]);<br>\t}<br>\treturn tempVec;<br>}<br><br>&#47;&#47; 合并函数<br>&#47;&#47; 将两个数组中的元素按照从小到大的形式放到另一个数组中，并返回<br>template &lt;class T&gt;<br>vector&lt;T&gt; Merge(vector&lt;T&gt; &amp;LeftData, vector&lt;T&gt; &amp;RightData)<br>{<br>\tsize_t leftIndex = 0;<br>\tsize_t rightIndex = 0;<br>\tvector&lt;T&gt; resultData;<br><br>\twhile( (leftIndex &lt; LeftData.size()) &amp;&amp; (rightIndex &lt; RightData.size()))<br>\t{<br>\t\tif ( LeftData[leftIndex] &lt;= RightData[rightIndex])<br>\t\t{<br>\t\t\tresultData.push_back(LeftData[leftIndex]);<br>\t\t\t++leftIndex;<br>\t\t}<br>\t\telse<br>\t\t{<br>\t\t\tresultData.push_back(RightData[rightIndex]);<br>\t\t\t++rightIndex;<br>\t\t}<br>\t}<br>\t<br>\twhile(leftIndex &lt; LeftData.size())<br>\t{<br>\t\tresultData.push_back(LeftData[leftIndex]);<br>\t\t++leftIndex;<br>\t}<br>\twhile(rightIndex &lt; RightData.size())<br>\t{<br>\t\tresultData.push_back(RightData[rightIndex]);<br>\t\t++rightIndex;<br>\t}<br>\treturn resultData;<br>}<br><br>&#47;&#47; 归并排序 算法<br>template &lt;class T&gt;<br>vector&lt;T&gt; MergeSort(vector&lt;T&gt; &amp;SortData)<br>{<br>\tif (SortData.size() == 1)<br>\t{<br>\t\treturn SortData;<br>\t}<br>\tvector&lt;T&gt; leftData = CopyVectorData(SortData, 0, SortData.size()&#47;2 - 1);<br>\tvector&lt;T&gt; rightData = CopyVectorData(SortData, SortData.size()&#47;2, SortData.size()-1);<br><br>\tvector&lt;T&gt; resultData = Merge(MergeSort(leftData), MergeSort(rightData));<br><br>\treturn resultData;<br>}<br><br>int _tmain(int argc, _TCHAR* argv[])<br>{<br>\tint ia[] = {12, 20, 5, 10, 34, 49, 33, 88, 42, 12};\t<br>\tvector&lt;int&gt; Select(ia, ia+10);<br><br>\tvector&lt;int&gt; Result = MergeSort(Select);<br><br>\tsystem(&quot;pause&quot;);<br>\treturn 0;<br>}<br>","like_count":1},{"had_liked":false,"id":52408,"user_name":"晓嘿","can_delete":false,"product_type":"c1","uid":1341930,"ip_address":"","ucode":"4B52EF7B9A1394","user_header":"https://static001.geekbang.org/account/avatar/00/14/79/ea/8fe22e74.jpg","comment_is_top":false,"comment_ctime":1545377457,"is_pvip":false,"replies":[{"id":"19144","content":"如果把归并的过程看成一棵树，log2n是指的树的高度，你这里计算的是树的结点数量","user_name":"作者回复","user_name_real":"Sean","uid":"1275061","ctime":1545408359,"ip_address":"","comment_id":52408,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5840344753","product_id":100021201,"comment_content":"老师<br>“归并排序通过分治的思想，把长度为 n 的数列，每次简化为两个...只需要 log2n 次归并。”<br>这句话，需要的归并次数是我算着是: 简化的组数：1,2^1,2^2..2^k。归并的时候，应该合并2^0+2^1+2^2+..+2^(k-1)次，也就是2^k-1次。我这么想对吗，老师。<br><br>","like_count":1,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433862,"discussion_content":"如果把归并的过程看成一棵树，log2n是指的树的高度，你这里计算的是树的结点数量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545408359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":52333,"user_name":"Y K","can_delete":false,"product_type":"c1","uid":1128018,"ip_address":"","ucode":"9E2898770271EF","user_header":"https://static001.geekbang.org/account/avatar/00/11/36/52/216e5a30.jpg","comment_is_top":false,"comment_ctime":1545363688,"is_pvip":false,"replies":[{"id":"19040","content":"是的","user_name":"作者回复","user_name_real":"Sean","uid":"1275061","ctime":1545374085,"ip_address":"","comment_id":52333,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5840330984","product_id":100021201,"comment_content":"JDK自带的Arrays.sort(T[] a, Comparator&lt;? super T&gt; c)底层采用的就是归并排序，归并排序相对于快排而言是一种稳定的排序。","like_count":1,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433836,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545374085,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":52299,"user_name":"风轨","can_delete":false,"product_type":"c1","uid":1185844,"ip_address":"","ucode":"7B8A5233B61EB0","user_header":"https://static001.geekbang.org/account/avatar/00/12/18/34/c082419c.jpg","comment_is_top":false,"comment_ctime":1545360265,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5840327561","product_id":100021201,"comment_content":"我的理解，归并排序主要是内存装不下所有数据的时候才用。比如：<br>1. 数据库排序，内存装不下就分多次排序放到磁盘上，再归并；<br>2. 大数据计算框架，一台机器无法对所有数据排序，每台机器各自排序，再归并；<br><br>但是，内存中排序不会直接用归并排序，毕竟每分一次就要复制一次数据。<br><br>思考题：<br>分解的时候可以分解成N份（N &gt; 2），使得每一份数据为一个合适的体积，从而减少拆分次数。<br>但是，合并的时候一定是两两合并的。<br>对分成N组的有序数组进行合并，使用两两合并的时间复杂度是O(lb(N)n)，而对N组数据同时合并时间复杂度是O(Nn)，其中n是总体数据规模。<br>比如说，对分成4组的4个数字{[1],[2],[3],[4]}进行合并，<br>同时对4组进行合并：<br>比较3次后：{[1],[2],[3],[4]} （第一个集合表示合并后的集合）<br>再比较2次后：{[1,2],[3],[4]}<br>再比较1次后：{[1,2,3,4]}<br>总共比较：6次；<br>使用两两合并：<br>比较2次后：{[1,2],[3,4]}<br>再比较2次：{[1,2,3,4]}<br>总共比较：4次；<br>","like_count":1},{"had_liked":false,"id":52296,"user_name":"道可","can_delete":false,"product_type":"c1","uid":1240858,"ip_address":"","ucode":"4AB4EFDFFF95A0","user_header":"https://static001.geekbang.org/account/avatar/00/12/ef/1a/e7ebdfa8.jpg","comment_is_top":false,"comment_ctime":1545359772,"is_pvip":false,"replies":[{"id":"19042","content":"我用的eclipse，不过贴到文章中的代码，格式可能稍有不同","user_name":"作者回复","user_name_real":"Sean","uid":"1275061","ctime":1545374188,"ip_address":"","comment_id":52296,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5840327068","product_id":100021201,"comment_content":"请问老师用的是什么IDE","like_count":1,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433824,"discussion_content":"我用的eclipse，不过贴到文章中的代码，格式可能稍有不同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545374188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360790,"user_name":"ACHL","can_delete":false,"product_type":"c1","uid":3168900,"ip_address":"广西","ucode":"5ACE8F786BD5D1","user_header":"https://static001.geekbang.org/account/avatar/00/30/5a/84/2d9a6785.jpg","comment_is_top":false,"comment_ctime":1666856786,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1666856786","product_id":100021201,"comment_content":"贴一个自己写的归并...<br>&#47;*<br>descrption:<br>Based on the idea of &quot;Divide-and-Conquer&quot;，The program implements merge sorting<br><br>A test sample such as<br>input data:<br>input:<br>6<br>10<br>4 6 2 1 8 3 5 9 10 7<br>10<br>10 9 8 7 6 5 4 3 2 1<br>5<br>1 1 1 1 1<br>5<br>1 1 2 2 2<br>6 <br>2 2 3 1 1 3<br>6<br>3 3 2 2 1 1<br><br>output:<br>1 2 3 4 5 6 7 8 9 10<br>1 2 3 4 5 6 7 8 9 10<br>1 1 1 1 1<br>1 1 2 2 2<br>1 1 2 2 3 3<br>1 1 2 2 3 3<br>*&#47;<br>#include&lt;bits&#47;stdc++.h&gt;<br>using namespace std;<br>#define MAX (int)1e4<br><br>int aidx, bidx, cidx, tidx, size, casenum;<br>int c[MAX];<br>int t[MAX];<br><br>void initial() {<br>\taidx = 0, bidx = 0, cidx = 0;<br>\tprintf(&quot;please input a number as the size of input array\\n&quot;);<br>\tcin &gt;&gt; size;<br>\tprintf(&quot;please input %d number for array, and Numbers are separated by spaces\\n&quot;, size);<br>\tfor (int i = 0; i &lt; size; i++) {<br>\t\tcin &gt;&gt; c[i];<br>\t}<br>}<br><br>void merge(int l, int r, int mid) {<br>\tint cnta = 0, cntb = 0;<br>\tint asize = mid - l + 1, bsize = r - mid;<br>\taidx = l, bidx = mid + 1, tidx = l; <br>\twhile (cnta &lt; asize || cntb &lt; bsize) {<br>\t\tif (cnta &gt;= asize) {<br>\t    for (int i = bidx; i &lt;= r; i++) {<br>\t    \tt[tidx++] = c[i];<br>\t    \tcntb++;<br>\t    }\t<br>\t  } else if(cntb &gt;= bsize) {<br>\t  \tfor (int i = aidx; i &lt;= mid; i++) {<br>\t  \t\tt[tidx++] = c[i];<br>\t  \t\tcnta++;<br>\t  \t} <br>\t  } else {<br>\t  \tif (c[aidx] &gt; c[bidx]) {<br>\t  \t    t[tidx++] = c[bidx++];<br>\t  \t    cntb++;<br>\t  \t} else {<br>\t  \t\tt[tidx++] = c[aidx++];<br>\t  \t\tcnta++;<br>\t  \t} <br>\t  } <br>\t}<br>\tfor (int i = l; i &lt;= r; i++) {<br>\t\tc[i] = t[i];<br>\t}<br>}<br><br>void mergesort(int l, int r) {<br>\tif (l &gt;= r) {<br>\t\treturn ;<br>\t}<br>\tint mid = (l + r) &#47; 2;<br>\tmergesort(l, mid);<br>\tmergesort(mid + 1, r);<br>\tmerge(l, r, mid);<br>}<br><br>void show(int size) {<br>\tcout &lt;&lt; &quot;Array c contains:&quot; &lt;&lt; endl;<br>\tfor (int i = 0; i &lt; size; i++) {<br>\t\tcout &lt;&lt; c[i] &lt;&lt; &quot; &quot;;<br>\t}<br>\tcout &lt;&lt; endl;<br>    cout &lt;&lt; &quot;finished&quot; &lt;&lt; endl;<br>}<br><br>signed main (void) {<br>\tprintf(&quot;please input a number as the casenum\\n&quot;);<br>\tcin &gt;&gt; casenum;<br>\tfor (int i = 1; i &lt;= casenum; i++) {<br>\tinitial();<br>\tmergesort(0, size - 1);<br>\tshow(size);<br>\t}<br>\treturn 0;<br>}","like_count":0},{"had_liked":false,"id":352862,"user_name":"013923","can_delete":false,"product_type":"c1","uid":3035193,"ip_address":"陕西","ucode":"1214DAADBCA848","user_header":"","comment_is_top":false,"comment_ctime":1658988257,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658988257","product_id":100021201,"comment_content":"学习了，谢谢！","like_count":0},{"had_liked":false,"id":352853,"user_name":"013923","can_delete":false,"product_type":"c1","uid":3035193,"ip_address":"北京","ucode":"1214DAADBCA848","user_header":"","comment_is_top":false,"comment_ctime":1658983037,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658983037","product_id":100021201,"comment_content":"学习了！","like_count":0},{"had_liked":false,"id":352815,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1320487,"ip_address":"美国","ucode":"96BAFAA147341F","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","comment_is_top":false,"comment_ctime":1658967242,"is_pvip":false,"replies":[{"id":"129189","content":"这是个很好的一点","user_name":"作者回复","user_name_real":"编辑","uid":"1275061","ctime":1661057412,"ip_address":"美国","comment_id":352815,"utype":1}],"discussion_count":1,"race_medal":2,"score":"1658967242","product_id":100021201,"comment_content":"N&#47;2 可以优化为移位，N&#47;3 可能会有点麻烦","like_count":0,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584714,"discussion_content":"这是个很好的一点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661057412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"美国"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":317375,"user_name":"cv0cv0","can_delete":false,"product_type":"c1","uid":1360093,"ip_address":"","ucode":"93FF9277F03FD0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLEIsgI4ub1VOKWtVOfouAzSqx8Yt8ibQEsAnwNJsJHmuJzzpQqG79HullvYwpic8hgiclgON2GwXSjw/132","comment_is_top":false,"comment_ctime":1634778803,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634778803","product_id":100021201,"comment_content":"图片看起来像是手画的。","like_count":0},{"had_liked":false,"id":304459,"user_name":"南北","can_delete":false,"product_type":"c1","uid":2407719,"ip_address":"","ucode":"34288BDEF9D74D","user_header":"https://static001.geekbang.org/account/avatar/00/24/bd/27/3f349c83.jpg","comment_is_top":false,"comment_ctime":1627435575,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627435575","product_id":100021201,"comment_content":"可以分成更多的组，当组多了以后，如果多组同时归并，实现会比较复杂，可两两归并，然后再归并，直到归并为一个数组。<br><br>顺这思路，推向极端。对于长度为n的数组，分成n组，每相邻的两组进行归并，然后再进行第二轮，直到归并为一个数组，完成排序。","like_count":0},{"had_liked":false,"id":292958,"user_name":"HeRui","can_delete":false,"product_type":"c1","uid":1395092,"ip_address":"","ucode":"4B736D2FD8FB54","user_header":"https://static001.geekbang.org/account/avatar/00/15/49/94/55e70da0.jpg","comment_is_top":false,"comment_ctime":1621097798,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621097798","product_id":100021201,"comment_content":"这种写法内存占用会达到n*log2N，下面这种虽然也会开辟这么多空间，但merge函数结速会释放，最大不会占用这么多，最多2N<br><br>void merge(int a[],int l,int r,int mid)<br>{<br>  int aux[r-l+1],i,j,k;<br>  <br>  for(k=l;k&lt;=r;k++)<br>  aux[k-l]=a[k];<br>  <br>  i=l;<br>  j=mid+1;<br>  for(k=l;k&lt;=r;k++)<br>  {<br>  \tif(i&gt;mid)<br>  \t{<br>  \t\ta[k]=aux[j-l];<br>  \t\tj++;<br>\t  }<br>\telse if(j&gt;r)<br>\t{<br>\t\ta[k]=aux[i-l];<br>\t\ti++;<br>\t  }<br>\telse if(aux[i-l]&gt;aux[j-l])<br>\t{<br>\t\ta[k]=aux[j-l];<br>\t\tj++;<br>\t\t}<br>\telse<br>\t{<br>\t\ta[k]=aux[i-l];<br>\t\ti++;<br>\t\t\t}<br>\t  }\t<br>}<br> <br>void merge_sort(int a[],int l,int r)<br>{<br>    if(l&gt;=r)<br>\treturn ;<br>\tint mid=(l+r)&#47;2;<br>\tmerge_sort(a,l,mid);<br>\tmerge_sort(a,mid+1,r);<br>\tmerge(a,l,r,mid);\t<br>}<br> <br> <br>void mergesort(int a[],int l,int r)<br>{<br>\tmerge_sort(a,l,r-1);<br>}","like_count":0},{"had_liked":false,"id":284277,"user_name":"厚积薄发","can_delete":false,"product_type":"c1","uid":1449990,"ip_address":"","ucode":"FDF273091C66B7","user_header":"https://static001.geekbang.org/account/avatar/00/16/20/06/6ca43f2d.jpg","comment_is_top":false,"comment_ctime":1616147522,"is_pvip":false,"replies":[{"id":"103570","content":"太棒了，很高兴对你有价值","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1616791664,"ip_address":"","comment_id":284277,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1616147522","product_id":100021201,"comment_content":"谢谢老师，一直看那些算法云里雾里的，看了您的长篇引导，已经可以根据理解自己写出归并排序了","like_count":0,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517295,"discussion_content":"太棒了，很高兴对你有价值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616791664,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":265173,"user_name":"凹凸鸿","can_delete":false,"product_type":"c1","uid":1915334,"ip_address":"","ucode":"A458BAEBF314B2","user_header":"https://static001.geekbang.org/account/avatar/00/1d/39/c6/1e12f271.jpg","comment_is_top":false,"comment_ctime":1606804879,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606804879","product_id":100021201,"comment_content":"```php<br>function merge_sort($arr){<br>    $len = count($arr);<br>    if($len&lt;=1){<br>        return $arr;<br>    }<br>    $half = ($len&gt;&gt;1)+($len &amp; 1);<br>    $arr2d = array_chunk($arr,$half);<br>    $left = merge_sort($arr2d[0]);<br>    $right = merge_sort($arr2d[1]);<br>    while(count($left) &amp;&amp; count($right)){<br>        if($left[0] &lt; $right[0]){<br>            $reg[] = array_shift($left);<br>        }else{<br>            $reg[] = array_shift($right);<br>        }<br>    }<br>    return array_merge($reg,$left,$right);<br><br>}<br>```","like_count":0},{"had_liked":false,"id":265162,"user_name":"凹凸鸿","can_delete":false,"product_type":"c1","uid":1915334,"ip_address":"","ucode":"A458BAEBF314B2","user_header":"https://static001.geekbang.org/account/avatar/00/1d/39/c6/1e12f271.jpg","comment_is_top":false,"comment_ctime":1606800243,"is_pvip":false,"replies":[{"id":"96646","content":"这里和前文提到的数学归纳法类似，简单的理解，n表示第n次的处理，k表示一个特定的数字，当然这个数次是可以变化的。例如，在n=3的时候，处理的情况是如何如何，那么在n=2的时候，就会有怎样相应的变化等等","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1607145091,"ip_address":"","comment_id":265162,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1606800243","product_id":100021201,"comment_content":"我们假设 n=k-1 的时候，我们已经对较小的两组数进行了排序。那我们只要在 n=k 的时候，将这两组数合并起来，并且保证合并后的数组仍然是有序的就行了<br><br>这里不解啊，为什么之前的文章和这里都用假设n=k-1，然后又n=k，n代表什么，k又代表什么？？？？老师能展开讲讲吗","like_count":0,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510822,"discussion_content":"这里和前文提到的数学归纳法类似，简单的理解，n表示第n次的处理，k表示一个特定的数字，当然这个数次是可以变化的。例如，在n=3的时候，处理的情况是如何如何，那么在n=2的时候，就会有怎样相应的变化等等","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607145091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248788,"user_name":"小北","can_delete":false,"product_type":"c1","uid":1101976,"ip_address":"","ucode":"4DAC260AC75B71","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/98/9779cf40.jpg","comment_is_top":false,"comment_ctime":1600310219,"is_pvip":true,"replies":[{"id":"92027","content":"通常递归对于编程人员来说比较容易理解，但是可能更耗性能（取决于编译器）。如果能转为非递归的解法，或者使用堆栈，可以提升性能","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1601772267,"ip_address":"","comment_id":248788,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1600310219","product_id":100021201,"comment_content":"老师，请教一个问题。针对嵌套深的递归。是不是都需要转化为非递归堆栈实现递归？我看很多数据结构算法的源码都是才用的非递归方式模拟递归，请问哪一种方式的应用多一些？","like_count":0,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505741,"discussion_content":"通常递归对于编程人员来说比较容易理解，但是可能更耗性能（取决于编译器）。如果能转为非递归的解法，或者使用堆栈，可以提升性能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601772267,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225242,"user_name":"王志荣","can_delete":false,"product_type":"c1","uid":1399823,"ip_address":"","ucode":"87948F552D7050","user_header":"https://static001.geekbang.org/account/avatar/00/15/5c/0f/549e1041.jpg","comment_is_top":false,"comment_ctime":1591691001,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591691001","product_id":100021201,"comment_content":"scala实现：<br>object TestMath {<br>  var i = 0<br>  def main(args: Array[String]): Unit = {<br>    println(TestMergeSort(Array(5, 3, 6, 4, 23, 52, 2, 1, 9, 7)).mkString(&quot;,&quot;))<br>    println(i)<br>  }<br><br>  def TestMergeSort(array: Array[Int]): Array[Int] = {<br>    if (array.size == 1) {<br>      array<br>    } else {<br>      val mid: Int = array.size &#47; 2<br>      var left: Array[Int] = array.slice(0, mid)<br>      var right: Array[Int] = array.slice(mid, array.size)<br>      left = TestMergeSort(left)<br>      right = TestMergeSort(right)<br>      sort(left, right)<br>    }<br><br>  }<br><br>  def sort(left: Array[Int], right: Array[Int]): Array[Int] = {<br>    val result = new ArrayBuffer[Int]<br>    var l, r: Int = 0<br>    while (l &lt; left.size &amp;&amp; r &lt; right.size) {<br>      i += 1<br>      if (left(l) &gt;= right(r)) {<br>        result += right(r)<br>        r += 1<br>      } else {<br>        result += left(l)<br>        l += 1<br>      }<br>    }<br>    if (l &lt; left.size) result.appendAll(left.slice(l, left.size))<br>    if (r &lt; right.size) result.appendAll(right.slice(r, right.size))<br>    println(&quot;result:&quot; + result.mkString(&quot;,&quot;))<br>    result.toArray<br>  }<br>}","like_count":0},{"had_liked":false,"id":221232,"user_name":"peace","can_delete":false,"product_type":"c1","uid":2006148,"ip_address":"","ucode":"8629F9BFDC253E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erWrGjD40JI6WTIaSLfZ9icTyuuLEpPwCicr3Fv2icy8mibHBj5icMpIGxp9UD8rLIQib1RLpXIrwKaQxOA/132","comment_is_top":false,"comment_ctime":1590453236,"is_pvip":false,"replies":[{"id":"81771","content":"是的👍","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1590616244,"ip_address":"","comment_id":221232,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590453236","product_id":100021201,"comment_content":"多路归并在辅导书上有出现过，这一节开始的那两个有序数组合并的过程让我明白了归并中合并这一步的原理，懂得了就算是只有两个只包含一个元素的数组合并，也是执行上述过程","like_count":0,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496391,"discussion_content":"是的👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590616244,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":191704,"user_name":"乐达","can_delete":false,"product_type":"c1","uid":1223158,"ip_address":"","ucode":"4A1CCA0633DB45","user_header":"https://static001.geekbang.org/account/avatar/00/12/a9/f6/1cdb3d52.jpg","comment_is_top":false,"comment_ctime":1584791138,"is_pvip":false,"replies":[{"id":"75070","content":"是的","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1585632269,"ip_address":"","comment_id":191704,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1584791138","product_id":100021201,"comment_content":"分成更多组是可以的。但是在合并的时候会更复杂。","like_count":0,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488232,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585632269,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187308,"user_name":"喻茂","can_delete":false,"product_type":"c1","uid":1318661,"ip_address":"","ucode":"C8BD8086A17365","user_header":"https://static001.geekbang.org/account/avatar/00/14/1f/05/8a06692e.jpg","comment_is_top":false,"comment_ctime":1584080732,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584080732","product_id":100021201,"comment_content":"php示例<br>&lt;?php<br><br>function merge_sort($to_sort) {<br>\tif(empty($to_sort) || !is_array($to_sort)) {<br>\t\treturn [];<br>\t}<br>\tif (count($to_sort) == 1) { &#47;&#47; 无法再细分<br>\t\treturn $to_sort;<br>\t}<br>\t<br>\t$mid = intval(count($to_sort) &#47; 2); <br>\t$leftArr = array_slice($to_sort,0,$mid) ;<br>\t$rightArr = array_slice($to_sort,$mid);<br>\t$leftArr = merge_sort($leftArr);<br>\t$rightArr = merge_sort($rightArr);<br>\t<br>\t$mergeArr = merge($leftArr,$rightArr);<br>\treturn $mergeArr;<br>\t<br>}<br><br>function merge($leftArr,$rightArr) {<br>\t<br>\tif (empty($leftArr) || !is_array($leftArr)) {<br>\t\t$leftArr = [];<br>\t}<br>\tif (empty($rightArr) || !is_array($rightArr)) {<br>\t\t$rightArr = [];<br>\t}<br>\t$mergeArr = [];<br>\t$leftArrCount = count($leftArr);<br>\t$rightArrCount = count($rightArr);<br>\t<br>\t$ai = 0;$bi = 0;<br>\twhile ($ai &lt; $leftArrCount &amp;&amp; $bi &lt; $rightArrCount) {<br>\t\tif ($leftArr[$ai] &lt;= $rightArr[$bi]) {<br>\t\t\t$mergeArr[] = $leftArr[$ai];<br>\t\t\t$ai++;<br>\t\t} else {<br>\t\t\t$mergeArr[] = $rightArr[$bi];<br>\t\t\t$bi++;<br>\t\t}<br>\t}<br>\t<br>\tif ($ai &lt; $leftArrCount) { &#47;&#47; 右边数组遍历完，直接把左边数据未遍历的值追加到后面<br>\t\tfor(;$ai&lt;$leftArrCount;$ai++) {<br>\t\t\t$mergeArr[] = $leftArr[$ai];<br>\t\t}<br>\t} else {<br>\t\tfor(;$bi&lt;$rightArrCount;$bi++) {<br>\t\t\t$mergeArr[] = $rightArr[$bi];<br>\t\t}<br>\t}<br>\treturn $mergeArr;<br>}<br><br>$to_sort = [3434, 3356, 67, 12334, 878667, 387];<br>$to_sort = merge_sort($to_sort);<br>print_R($to_sort);","like_count":0},{"had_liked":false,"id":181100,"user_name":"爬行的蜗牛","can_delete":false,"product_type":"c1","uid":1033956,"ip_address":"","ucode":"6623B62DE63CE9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/QD6bf8hkS5dHrabdW7M7Oo9An1Oo3QSxqoySJMDh7GTraxFRX77VZ2HZ13x3R4EVYddIGXicRRDAc7V9z5cLDlA/132","comment_is_top":false,"comment_ctime":1582474917,"is_pvip":false,"replies":[{"id":"71547","content":"是的，还是有额外的开销","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1583555202,"ip_address":"","comment_id":181100,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1582474917","product_id":100021201,"comment_content":"如果分成n组，那么合并结果的时候就要合并n组结果，那么又产生了一个新的排序问题，所以觉得不太可取。","like_count":0,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484914,"discussion_content":"是的，还是有额外的开销","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583555202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174097,"user_name":"Me.Gao","can_delete":false,"product_type":"c1","uid":1815189,"ip_address":"","ucode":"CA7696DAB95212","user_header":"https://static001.geekbang.org/account/avatar/00/1b/b2/95/349aef32.jpg","comment_is_top":false,"comment_ctime":1579961260,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579961260","product_id":100021201,"comment_content":"python 版本:<br><br>def mergeSort(sortList):<br>    &quot;&quot;&quot;使用函数的递归（嵌套）调用，实现归并排序（从小到大）<br>    <br>    sortList: list that is needed to sort<br>    return: sorted list<br>    &quot;&quot;&quot;<br>    if (len(sortList) == 0):<br>        return<br>    elif (len(sortList) == 1):<br>        return sortList<br>    else:<br>        div = int(len(sortList) &#47; 2)<br>        #use recursion to find the ordered two list<br>        left = mergeSort(sortList[0:div])<br>        right = mergeSort(sortList[div:])<br>        #merge the two ordered list<br>        result = []<br>        li = 0<br>        ri = 0<br>        #put the smaller result into the new list<br>        while(li &lt; len(left) and ri &lt; len(right)):<br>            if (left[li] &lt;= right[ri]):<br>                result += [left[li]]<br>                li += 1<br>            else:<br>                result += [right[ri]]<br>                ri += 1<br>        #when one of the list completes, add the remaining items of another list to the result<br>        if li &lt; len(left):<br>            result += left[li:]<br>        else:<br>            result += right[ri:]<br>        return result","like_count":0},{"had_liked":false,"id":166761,"user_name":"王加武","can_delete":false,"product_type":"c1","uid":1665471,"ip_address":"","ucode":"DDCFE578C6C428","user_header":"https://static001.geekbang.org/account/avatar/00/19/69/bf/50a824a4.jpg","comment_is_top":false,"comment_ctime":1577589472,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577589472","product_id":100021201,"comment_content":"public class MegerSort {<br>    public static void main(String[] args) {<br>        int[] arr = {7, 6, 2, 4, 1, 9, 3, 8, 0, 5};<br>        int[] temp = new int[arr.length];<br>        megerSort(arr, 0, arr.length - 1, temp);<br><br>        System.out.println(&quot;归并后的结果：&quot; + Arrays.toString(arr));<br><br>    }<br><br>    &#47;**<br>     * @param arr   原有的数组<br>     * @param left  最左边的索引<br>     * @param right 最右边的索引<br>     * @param temp  额外的数组<br>     * @deprecated 拆分的过程<br>     *&#47;<br>    public static void megerSort(int[] arr, int left, int right, int[] temp) {<br>        if (left &lt; right) {<br>            &#47;&#47;中间索引<br>            int mid = (left + right) &#47; 2;<br>            &#47;&#47;向左边递归进行分解<br>            megerSort(arr, left, mid, temp);<br>            &#47;&#47;向右边递归进行分解<br>            megerSort(arr, mid + 1, right, temp);<br>            &#47;&#47;合并<br>            meger(arr, left, mid, right, temp);<br>        }<br><br><br>    }<br><br>    &#47;**<br>     * @param arr   原有的数组<br>     * @param left  左边索引<br>     * @param mid   中间索引<br>     * @param right 右边索引<br>     * @deprecated 合并的过程<br>     *&#47;<br>    public static void meger(int[] arr, int left, int mid, int right, int[] temp) {<br>        &#47;&#47;左边有序序列的索引<br>        int i = left;<br>        &#47;&#47;右边有序序列的索引<br>        int j = mid + 1;<br>        &#47;&#47;temp数组的起始位置<br>        int t = 0;<br><br><br>        &#47;**<br>         * 1、先把左右两边的数据按照顺序有序的存放到temp数组中<br>         * 直到有一边完成<br>         *&#47;<br>        while (i &lt;= mid &amp;&amp; j &lt;= right) {<br>            if (arr[i] &lt;= arr[j]) {<br>                temp[t] = arr[i];<br>                t++;<br>                i++;<br>            } else {<br>                temp[t] = arr[j];<br>                t++;<br>                j++;<br>            }<br><br>        }<br>        &#47;&#47;说明左边有剩余的数据<br>        while (i &lt;= mid) {<br>            temp[t] = arr[i];<br>            t++;<br>            i++;<br>        }<br><br>        &#47;&#47;说明右边还有剩余的数据<br>        while (j &lt;= right) {<br>            temp[t] = arr[j];<br>            t++;<br>            j++;<br><br>        }<br>        t = 0;<br>        int tempLeft = left;<br>        while (tempLeft &lt;= right) {<br>            arr[tempLeft] = temp[t];<br>            t++;<br>            tempLeft++;<br>        }<br>    }<br>}<br>","like_count":0},{"had_liked":false,"id":154023,"user_name":"学习学个屁","can_delete":false,"product_type":"c1","uid":1049017,"ip_address":"","ucode":"DF2D61E6FB2FCE","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","comment_is_top":false,"comment_ctime":1574349481,"is_pvip":false,"replies":[{"id":"59297","content":"是的","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1574444754,"ip_address":"","comment_id":154023,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574349481","product_id":100021201,"comment_content":"分为两个组，查询效率应该比分成多个组查询效率高。<br>分为多组的话，三组之间需要两两比较，所花费的时间比两组对比时间要多。","like_count":0,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475354,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574444754,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150230,"user_name":"Vincent🌫","can_delete":false,"product_type":"c1","uid":1150764,"ip_address":"","ucode":"F7DAF7942417A7","user_header":"https://static001.geekbang.org/account/avatar/00/11/8f/2c/5c267d3e.jpg","comment_is_top":false,"comment_ctime":1573482274,"is_pvip":false,"replies":[{"id":"57948","content":"是的👍","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1573584698,"ip_address":"","comment_id":150230,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573482274","product_id":100021201,"comment_content":"无论多少分组，最后都是两两比较，使用递归其实也是等于分了n-1组了，所以分2组好理解","like_count":0,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474099,"discussion_content":"是的👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573584698,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":149007,"user_name":"顾骨","can_delete":false,"product_type":"c1","uid":1131165,"ip_address":"","ucode":"3F6BA592AB7723","user_header":"https://static001.geekbang.org/account/avatar/00/11/42/9d/c36b7ef7.jpg","comment_is_top":false,"comment_ctime":1573126565,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1573126565","product_id":100021201,"comment_content":"&#47;&#47; merge merge two slice<br>&#47;&#47; notice: first and two must be ordered<br>func merge(first, two []int) []int {<br>\tvar newList []int<br>\tfor {<br>\t\t&#47;&#47; two is empty<br>\t\tif 0 == len(two) {<br>\t\t\treturn append(newList, first...)<br>\t\t}<br><br>\t\t&#47;&#47; first is empty<br>\t\tif 0 == len(first) {<br>\t\t\treturn append(newList, two...)<br>\t\t}<br><br>\t\t&#47;&#47; first[0] is less, remove first[0] from first slice<br>\t\tif first[0] &lt; two[0] {<br>\t\t\tnewList = append(newList, first[0])<br>\t\t\tfirst = first[1:]<br>\t\t} else { &#47;&#47; two[0] is less, remove two[0] from two slice<br>\t\t\tnewList = append(newList, two[0])<br>\t\t\ttwo = two[1:]<br>\t\t}<br>\t}<br>}<br><br>func MergeSort(original []int) []int {<br>\tif 0 == len(original) {<br>\t\treturn nil<br>\t}<br><br>\t&#47;&#47; if only one in original, return the slice<br>\tif 1 == len(original) {<br>\t\treturn original<br>\t}<br><br>\tlength := len(original)<br>\tleft := MergeSort(original[0 : length&#47;2])<br>\tright := MergeSort(original[length&#47;2:])<br>\treturn merge(left, right)<br>}<br><br>func main(){<br>  in := []int{7, 6, 2, 4, 1, 9, 3, 8, 0, 5}<br>  out := MergeSort(in)<br>  fmt.Println(out) &#47;&#47;output: [0 1 2 3 4 5 6 7 8 9]<br>}","like_count":0},{"had_liked":false,"id":139019,"user_name":"Yang","can_delete":false,"product_type":"c1","uid":1186879,"ip_address":"","ucode":"6335082702CF34","user_header":"https://static001.geekbang.org/account/avatar/00/12/1c/3f/eabd0cb1.jpg","comment_is_top":false,"comment_ctime":1570527517,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570527517","product_id":100021201,"comment_content":"分成更多的组当然可行，不过计算机是二进制的，所以常用的也是分成两组。","like_count":0},{"had_liked":false,"id":138210,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1570098303,"is_pvip":false,"replies":[{"id":"53208","content":"是的👍","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1570212890,"ip_address":"","comment_id":138210,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1570098303","product_id":100021201,"comment_content":"分为多组合并后，可能会带来以下问题：<br>(1)程序更复杂，当其中的一组被合并后，剩下的那几组还是要继续合并的过程，而分为两组时，当其中一组合并后，剩下的那一组只需要直接并入结果集即可；<br>(2)分为多组合并后，如果仍采用递归算法，则会增加递归的次数，增加系统的开销。","like_count":0,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469437,"discussion_content":"是的👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570212890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134939,"user_name":"战五渣","can_delete":false,"product_type":"c1","uid":1473533,"ip_address":"","ucode":"DA5791E6408647","user_header":"https://static001.geekbang.org/account/avatar/00/16/7b/fd/fae6fcab.jpg","comment_is_top":false,"comment_ctime":1568959877,"is_pvip":false,"replies":[{"id":"51933","content":"基本上是对的，这也许是为什么计算机领域中很多都是二分，比如二叉树，二进制","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1569183161,"ip_address":"","comment_id":134939,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568959877","product_id":100021201,"comment_content":"分解为多组理论上是可行的，但是这种方式会增大对内存和CPU的占用，在实际中使用不是很合理，个人理解不太懂","like_count":0,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467967,"discussion_content":"基本上是对的，这也许是为什么计算机领域中很多都是二分，比如二叉树，二进制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569183161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127056,"user_name":"王兴强","can_delete":false,"product_type":"c1","uid":1249679,"ip_address":"","ucode":"3E3E71496BABCF","user_header":"https://static001.geekbang.org/account/avatar/00/13/11/8f/70ea4196.jpg","comment_is_top":false,"comment_ctime":1566546180,"is_pvip":false,"replies":[{"id":"47038","content":"对","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1566571493,"ip_address":"","comment_id":127056,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566546180","product_id":100021201,"comment_content":"老师，多次debug后发现，在合并两个排完序的数组方法中，最后将b数组加入到新的合并数组中，只对新数组下标变量进行了mi++，还应该对b数组进行下标bi++，我用的java语言，测试后程序正常了。","like_count":0,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464298,"discussion_content":"对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566571493,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127044,"user_name":"王兴强","can_delete":false,"product_type":"c1","uid":1249679,"ip_address":"","ucode":"3E3E71496BABCF","user_header":"https://static001.geekbang.org/account/avatar/00/13/11/8f/70ea4196.jpg","comment_is_top":false,"comment_ctime":1566543467,"is_pvip":false,"replies":[{"id":"47040","content":"你使用的测试数据是67，387，3356，3434，12334，878667？","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1566571792,"ip_address":"","comment_id":127044,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566543467","product_id":100021201,"comment_content":"老师，我用你讲解中的代码写了一遍，排序的数组用的也是例子中的，我得到结果：67<br>387<br>3356<br>3434<br>12334<br>12334<br>出现了两个第二大的数，最大的数878667没有排出来，检查了几遍代码，和你的一摸一样，是哪里出了问题。","like_count":0,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464292,"discussion_content":"你使用的测试数据是67，387，3356，3434，12334，878667？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566571792,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124235,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1565839145,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565839145","product_id":100021201,"comment_content":"归并排序分成多个组也是可行的，只是代码复杂一些并且复杂度是一样的，实际上没有太多意义。但是如果多个组对应多台机器，分成多个组就是一个有意义的解法。","like_count":0},{"had_liked":false,"id":114157,"user_name":"Lazy","can_delete":false,"product_type":"c1","uid":1338228,"ip_address":"","ucode":"1283F9EFA57F3D","user_header":"https://static001.geekbang.org/account/avatar/00/14/6b/74/8c8d60bd.jpg","comment_is_top":false,"comment_ctime":1563244182,"is_pvip":false,"replies":[{"id":"41737","content":"感谢支持👍","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1563295747,"ip_address":"","comment_id":114157,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563244182","product_id":100021201,"comment_content":"老师讲的好厉害，要是最开始能看到这么精辟的讲解，我会喜欢上编程的。(#^.^#)","like_count":0,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458533,"discussion_content":"感谢支持👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563295747,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106615,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1561357140,"is_pvip":false,"replies":[{"id":"38636","content":"很好的点，这里的map reduce不像word count，并不能减少内存的消耗量，所以只能并行CPU的使用量","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1561419556,"ip_address":"","comment_id":106615,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561357140","product_id":100021201,"comment_content":"这个归并排序分治思想有点问题，机器1<br>内存不足以合并这么多数据吧","like_count":0,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455154,"discussion_content":"很好的点，这里的map reduce不像word count，并不能减少内存的消耗量，所以只能并行CPU的使用量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561419556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105036,"user_name":"风","can_delete":false,"product_type":"c1","uid":1444483,"ip_address":"","ucode":"E1CE0825AAF805","user_header":"https://static001.geekbang.org/account/avatar/00/16/0a/83/f916f903.jpg","comment_is_top":false,"comment_ctime":1560907718,"is_pvip":false,"replies":[{"id":"38398","content":"很认真的实现了多个作业，赞一个","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1561247135,"ip_address":"","comment_id":105036,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560907718","product_id":100021201,"comment_content":"2路归并排序  C语言  递归实现<br><br>&#47;&#47;记录项的定义<br>typedef struct record_type {<br>\tint key;   &#47;&#47;assume keyword is int<br>\tint data;  &#47;&#47;can be any type<br>} RecordType;<br><br><br>#define  MAX_NBR  100  &#47;&#47;必须比待排序元素的个数多<br><br>void Merge(RecordType r[], int start, int m, int n)<br>{<br>\tint idx1, idx2, idx;<br>\tint end1, end2;<br>\tRecordType data[MAX_NBR];<br><br>\tidx1 = start;<br>\tend1 = idx1 + m - 1;<br>\tidx2 = start + m;<br>\tend2 = idx2 + (n - m) - 1;<br>\tidx = 0;<br><br>\twhile (idx1&lt;=end1 &amp;&amp; idx2&lt;=end2)<br>\t{<br>\t\tif (r[idx1].key &lt;= r[idx2].key)<br>\t\t{<br>\t\t\tdata[idx] = r[idx1];<br>\t\t\tidx++; idx1++;<br>\t\t}<br>\t\telse<br>\t\t{<br>\t\t\tdata[idx] = r[idx2];<br>\t\t\tidx++; idx2++;<br>\t\t}<br>\t}<br>\tif (idx1 &gt; end1)<br>\t{<br>\t\twhile (idx2 &lt;= end2)<br>\t\t\tdata[idx++] = r[idx2++];<br>\t}<br>\telse if (idx2 &gt; end2)<br>\t{<br>\t\twhile (idx1 &lt;= end1)<br>\t\t\tdata[idx++] = r[idx1++];<br>\t}<br><br>\tidx = 0;<br>\twhile (idx &lt; n)<br>\t{<br>\t\tr[start + idx] = data[idx];<br>\t\tidx++;<br>\t}<br>}<br><br>void MergeSort(RecordType r[], int start, int n)<br>{<br>\tif (n &gt; 1)<br>\t{<br>\t\tMergeSort(r, start, n &#47; 2);<br>\t\tMergeSort(r, start + n &#47; 2, n - n &#47; 2);<br>\t\tMerge(r, start, n&#47;2, n);<br>\t}<br>}","like_count":0,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454531,"discussion_content":"很认真的实现了多个作业，赞一个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561247135,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103350,"user_name":"杨钒","can_delete":false,"product_type":"c1","uid":1012990,"ip_address":"","ucode":"751710CDFE75A4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/74/fe/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1560418323,"is_pvip":false,"replies":[{"id":"37444","content":"你是指合并两个已经排序好的数组，并保持合并后的数组仍然有序？如果是这样，在a和b两个数组都尚存数据的时候，需要比较两者的大小，然后决定从哪个数组里取数。","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1560443582,"ip_address":"","comment_id":103350,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560418323","product_id":100021201,"comment_content":"将某个数组中的数据放到合并后的数组中可以这么写 <br>    while(ai&lt;a.length){<br>            merged_one[mi++] = a[ai++];<br>        }<br>        while (bi &lt; b.length) {<br>           merged[mi++] = b[bi++];<br>        }","like_count":0,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453840,"discussion_content":"你是指合并两个已经排序好的数组，并保持合并后的数组仍然有序？如果是这样，在a和b两个数组都尚存数据的时候，需要比较两者的大小，然后决定从哪个数组里取数。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560443582,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97914,"user_name":"lkj","can_delete":false,"product_type":"c1","uid":1515939,"ip_address":"","ucode":"E6FE96407AF620","user_header":"https://static001.geekbang.org/account/avatar/00/17/21/a3/06291d0c.jpg","comment_is_top":false,"comment_ctime":1558838820,"is_pvip":false,"replies":[{"id":"35071","content":"代码写得很清楚","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1558892586,"ip_address":"","comment_id":97914,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1558838820","product_id":100021201,"comment_content":"打印一下分割 和 合并的过程 看起来清楚一点了<br>def merger(left, right):<br>\tprint(&quot;L: &quot;, left, &quot;R: &quot;, right)<br><br>\tif not left: left = [0]<br>\tif not right: right = [0]<br><br>\tmin_len = len(left)<br>\tmax_len = len(right)<br><br>\tmin_len = max_len if min_len &gt; max_len else min_len # 取最小的列表长度<br><br>\tmerge_list = []<br><br>\tl_idx = 0<br>\tr_idx = 0<br>\twhile (l_idx &lt; min_len and r_idx &lt; max_len):<br>\t\tif left[l_idx] &lt; right[r_idx]:<br>\t\t\tmerge_list.append(left[l_idx])<br>\t\t\tl_idx += 1<br>\t\telse:<br>\t\t\tmerge_list.append(right[r_idx])<br>\t\t\tr_idx += 1<br><br><br>\tif l_idx &lt; len(left):<br>\t\tfor i in range(l_idx, len(left)):<br>\t\t\tmerge_list.append(left[i])<br><br>\telse:<br>\t\tfor i in range(r_idx, len(right)):<br>\t\t\tmerge_list.append(right[i])<br><br>\tprint(&quot;M: &quot;, merge_list, end=&quot;\\n\\n&quot;)<br>\treturn merge_list<br><br><br><br>def merge_sort(num_list):<br>\tif not num_list: return [0];<br>\tif len(num_list) == 1:<br>\t\treturn num_list<br>\telse:<br>\t\tmiddle = len(num_list) &#47;&#47; 2<br>\t\tleft = merge_sort(num_list[:middle])<br>\t\tright = merge_sort(num_list[middle:])<br><br>\t\tmerged = merger(left, right)<br><br>\t\treturn merged<br><br><br>if __name__ == &quot;__main__&quot;:<br>\tl = [7, 6, 2, 4, 1, 9, 3, 8, 0, 5]<br>\tl2 = [3434, 3356, 67, 12334, 878667, 387]<br>\tprint(merge_sort(l))<br>\tprint(merge_sort(l2))<br>","like_count":0,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451470,"discussion_content":"代码写得很清楚","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558892586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90453,"user_name":"西贝","can_delete":false,"product_type":"c1","uid":1434920,"ip_address":"","ucode":"A1BB177284794E","user_header":"https://static001.geekbang.org/account/avatar/00/15/e5/28/16df113c.jpg","comment_is_top":false,"comment_ctime":1556523162,"is_pvip":false,"replies":[{"id":"32418","content":"你好，请问你说的问题具体是指什么？","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1556556271,"ip_address":"","comment_id":90453,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556523162","product_id":100021201,"comment_content":"int[] right = Arrays.copyOfRange(to_sort, mid, to_sort.length);<br>这个t_sort.length没有问题吗？<br>没有写过java的人，表示有疑问","like_count":0,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448532,"discussion_content":"你好，请问你说的问题具体是指什么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556556271,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87461,"user_name":"傲娇的小宝","can_delete":false,"product_type":"c1","uid":1493922,"ip_address":"","ucode":"C079B19BCC1B7C","user_header":"https://static001.geekbang.org/account/avatar/00/16/cb/a2/5e7c557e.jpg","comment_is_top":false,"comment_ctime":1555599109,"is_pvip":false,"replies":[{"id":"31449","content":"主要是比较的本质决定的，在单个任务中多个比较还是需要转化为两两比较来解决。当然，多台机器并行有可能同时进行多次比较","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1555606006,"ip_address":"","comment_id":87461,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555599109","product_id":100021201,"comment_content":"数学不好，个人感觉是可以分成更多组，但是因为中间有个比较的过程，分更多组后会加大比较的复杂度，而且消耗更多的资源用于状态的保存。","like_count":0,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447462,"discussion_content":"主要是比较的本质决定的，在单个任务中多个比较还是需要转化为两两比较来解决。当然，多台机器并行有可能同时进行多次比较","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555606006,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":80994,"user_name":"是我","can_delete":false,"product_type":"c1","uid":1297235,"ip_address":"","ucode":"0AC816A2FBD4F4","user_header":"https://static001.geekbang.org/account/avatar/00/13/cb/53/262a8ce2.jpg","comment_is_top":false,"comment_ctime":1553771231,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553771231","product_id":100021201,"comment_content":"留言区三分法不错","like_count":0},{"had_liked":false,"id":79293,"user_name":"jt","can_delete":false,"product_type":"c1","uid":1470991,"ip_address":"","ucode":"A3E2CAE00CE10A","user_header":"https://static001.geekbang.org/account/avatar/00/16/72/0f/f05b06d0.jpg","comment_is_top":false,"comment_ctime":1553425940,"is_pvip":false,"replies":[{"id":"28933","content":"你考虑的很周到，一种更高效的递归实现方式是，每次递归的时候，尽量避免重新分配新的数据，而是使用原有数据空间。<br><br>另外一种方法是使用堆栈，自己实现递归调用，但是通常逻辑稍微复杂一点。<br><br>如果能够把递归转成迭代的实现，那系统性能是可以得到提升的，不过从人的思维方式来看，有时没有那么直观。<br><br>我觉得对于一个新的问题，可以先从递归的方式开始，把思路理清，然后再转成迭代的实现，提升效率","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1553452506,"ip_address":"","comment_id":79293,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553425940","product_id":100021201,"comment_content":"黄老师，在实际应用中，分治的算法是否会经常配合递归的实现方式？<br>如果说本身就是处理大规模数据的时候适用，那么反复的递归调用带来的内存的负担是不是太大了。是否用常规的迭代法更常用一点？","like_count":0,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444435,"discussion_content":"你考虑的很周到，一种更高效的递归实现方式是，每次递归的时候，尽量避免重新分配新的数据，而是使用原有数据空间。\n\n另外一种方法是使用堆栈，自己实现递归调用，但是通常逻辑稍微复杂一点。\n\n如果能够把递归转成迭代的实现，那系统性能是可以得到提升的，不过从人的思维方式来看，有时没有那么直观。\n\n我觉得对于一个新的问题，可以先从递归的方式开始，把思路理清，然后再转成迭代的实现，提升效率","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553452506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75346,"user_name":"绍光","can_delete":false,"product_type":"c1","uid":1098460,"ip_address":"","ucode":"21DEDB1D5EFB9E","user_header":"https://static001.geekbang.org/account/avatar/00/10/c2/dc/89ca7174.jpg","comment_is_top":false,"comment_ctime":1552381735,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552381735","product_id":100021201,"comment_content":"分成两组可以在归并的时候只进行一次比较，其实分成多组也是可以的可以进行多路进行归并。","like_count":0},{"had_liked":false,"id":71717,"user_name":"depp","can_delete":false,"product_type":"c1","uid":1051975,"ip_address":"","ucode":"6EA98DE99CFCCE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIqWaVic6yGdicbtBFeAOuX28nRUyhaJrv5Tq5mrm4zM2DBOIZnO68bU4aYaoQxervC8F8kSxLdGGDg/132","comment_is_top":false,"comment_ctime":1551420039,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551420039","product_id":100021201,"comment_content":"# encoding: utf-8<br><br>def merge_sort(l=[]):<br>\tlist_size = len(l)<br><br>\tif list_size == 0:<br>\t\treturn<br><br>\tif list_size == 1:<br>\t\treturn l<br><br>\tif list_size &gt;= 2:<br>\t\tleft = merge_sort(l[0:(len(l) &#47;&#47; 2)])<br>\t\tright = merge_sort(l[(len(l) &#47;&#47; 2):])<br>\t\treturn merge(left, right)<br><br><br>def merge(left=[], right=[]):<br>\tfor index in range(len(left)):<br>\t\tif left[index] &gt; right[-1]:<br>\t\t\tright.append(left[index])<br>\t\telse:<br>\t\t\tfor i in range(len(right)):<br>\t\t\t\tif left[index] &lt; right[i]:<br>\t\t\t\t\tright.insert(i, left[index])<br>\t\t\t\t\tbreak<br>\treturn right<br><br><br>if __name__ == &#39;__main__&#39;:<br>\tprint(merge_sort([7,1,4,5,0,8,6,9,3,2, -10]))<br>\t\t\t\t<br><br><br><br><br>\t\t<br><br><br><br><br>","like_count":0},{"had_liked":false,"id":68620,"user_name":"飞猫🐈","can_delete":false,"product_type":"c1","uid":1340962,"ip_address":"","ucode":"8655165EF823D1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIWia36ia0QonoQcntmG8F4S07kicSaxf3ZibPvs7NiaM8Fhd08UK9XVOcQCwyXHDFl3xB3MCYacROYuow/132","comment_is_top":false,"comment_ctime":1550559570,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550559570","product_id":100021201,"comment_content":"swift 4.0的实现方式<br>func merge_sort(to_sort:Array&lt;Int&gt;)-&gt;Array&lt;Int&gt;{<br>    if to_sort.isEmpty {<br>        return Array&lt;Int&gt;();<br>    }<br>    &#47;&#47;如果分解到只剩一个数，返回该数<br>    if to_sort.count == 1 {<br>        return to_sort;<br>    }<br>    &#47;&#47;将数组分解成左右两半<br>    let midIndex = to_sort.count&#47;2;<br>    var left:Array&lt;Int&gt; = Array(to_sort[..&lt;midIndex]);<br>    var right:Array&lt;Int&gt; = Array(to_sort[midIndex...]);<br>    <br>    print(&quot;left = \\(left)&quot;);<br>    print(&quot;right =\\(right)&quot;);<br>    <br>    &#47;&#47;嵌套调用，对两半分别进行排序<br>    left = merge_sort(to_sort: Array(left));<br>    right = merge_sort(to_sort: Array(right));<br>    <br>    &#47;&#47;合并排序后的两半<br>    return merge(a: left, b: right);<br>}<br><br>func merge(a:Array&lt;Int&gt;,b:Array&lt;Int&gt;)-&gt;Array&lt;Int&gt;{<br>    <br>    var la = a;<br>    var rb = b;<br>    if a.isEmpty {<br>        la = Array&lt;Int&gt;();<br>    }<br>    if b.isEmpty {<br>        rb = Array&lt;Int&gt;();<br>    }<br>    var res:Array&lt;Int&gt; = Array&lt;Int&gt;();<br>    <br>    var mi:Int = 0,ai:Int = 0,bi:Int = 0;<br>    &#47;&#47;轮流从两个数组中取最小的值，放入合并后的数组中<br>    while (ai&lt;a.count &amp;&amp; bi&lt;b.count) {<br>        print(&quot;la = \\(la)&quot;);<br>        print(&quot;rb = \\(rb)&quot;);<br>        if la[ai] &lt;= rb[bi] {<br>            res.append(la[ai]);<br>            ai = ai+1;<br>        }else{<br>            res.append(rb[bi]);<br>            bi=bi+1;<br>        }<br>        mi=mi+1;<br>    }<br>    print(&quot;测试情况&quot;)<br>    &#47;&#47;将某个数组内剩余的数字放入合并后的数组中<br>    if ai&lt;la.count {<br>        res.append(contentsOf: Array(la[ai...]));<br>    }<br>    if bi&lt;rb.count {<br>        res.append(contentsOf: Array(rb[bi...]));<br>    }<br>    return res;<br>}<br><br>var ndsort = [32,41,5,3,56,20,17];<br>print(ndsort);<br>var sorted = merge_sort(to_sort: ndsort);<br>print(&quot;最终排序后的结果 = \\(sorted)&quot;);","like_count":0},{"had_liked":false,"id":64083,"user_name":"悬炫","can_delete":false,"product_type":"c1","uid":1159974,"ip_address":"","ucode":"28BA6B2169256B","user_header":"https://static001.geekbang.org/account/avatar/00/11/b3/26/cc28a05a.jpg","comment_is_top":false,"comment_ctime":1548663319,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548663319","product_id":100021201,"comment_content":"JavaScript实现<br>&#47;**<br> *<br> * @description 归并排序<br> * @param {array} arr1 <br> * @param {array} arr2<br> * @returns<br> *&#47;<br>function guibing(arr1, arr2) {<br>\tlet list = [];<br>\twhile (true) {<br>\t\tconst element1 = arr1[0];<br>\t\tconst element2 = arr2[0];<br>\t\tif (element1 &amp;&amp; element2) {<br>\t\t\tif (element1 &lt; element2) {<br>\t\t\t\tlist.push(element1);<br>\t\t\t\tarr1.shift();<br>\t\t\t} else {<br>\t\t\t\tlist.push(element2);<br>\t\t\t\tarr2.shift();<br>\t\t\t}<br>\t\t} else {<br>\t\t\tif (element1) {<br>\t\t\t\treturn list.concat(arr1);<br>\t\t\t} else {<br>\t\t\t\treturn list.concat(arr2);<br>\t\t\t}<br>\t\t}<br>\t}<br>}<br>&#47;**<br> *<br> *<br> * @param {array} arr<br> * @returns<br> *&#47;<br>function fenzhiguibing(arr) {<br>\tif (arr.length === 1) {<br>\t\treturn arr;<br>\t} else {<br>\t\tlet num = Math.trunc(arr.length &#47; 2);<br>\t\tlet arr1 = fenzhiguibing(arr.slice(0, num));<br>\t\tlet arr2 = fenzhiguibing(arr.slice(num));<br>\t\treturn guibing(arr1, arr2);<br>\t}<br>}<br>var arr=[2,8,5,7,6,1,3,4,9]<br>fenzhiguibing(arr);","like_count":0},{"had_liked":false,"id":57856,"user_name":"microsnow","can_delete":false,"product_type":"c1","uid":1121444,"ip_address":"","ucode":"3C24EE8D64E5E5","user_header":"https://static001.geekbang.org/account/avatar/00/11/1c/a4/3a7a0213.jpg","comment_is_top":false,"comment_ctime":1546930419,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546930419","product_id":100021201,"comment_content":"&#47;**<br> * 归并排序-php版<br> *&#47;<br>class Lession6_1 <br>{<br>    public function __construct()<br>    {<br>        $to_sort = [3434, 3357, 67, 1234, 878667, 387];<br>        $sorted = $this-&gt;merge_sort($to_sort);<br>        for($i = 1; $i &lt; count($sorted); $i++) {<br>            echo $sorted[$i];<br>            echo &quot;\\n&quot;;<br>        }<br>    }<br><br>    &#47;**<br>     * 使函数的递归（嵌套）调用，实现归并排序（从小大到）<br>     * @param  array $to_sort  等待排序的数组<br>     * @return array           排序后的数组<br>     *&#47;<br>    public function merge_sort($to_sort)<br>    {<br>        if (empty($to_sort)) {<br>            return 0;<br>        }<br>        &#47;&#47; 如果分解到只剩一个数，返回该数<br>        if (count($to_sort) == 1) {<br>            return $to_sort;<br>        }<br>        &#47;&#47; 将数组分解成两半<br>        $mid = intval(count($to_sort)&#47;2);<br>        $left = array_slice($to_sort, 0, $mid);<br>        $right = array_slice($to_sort, $mid);<br><br>        &#47;&#47; 嵌套调用，对两半分别进行排序<br>        $left = $this-&gt;merge_sort($left);<br>        $right = $this-&gt;merge_sort($right);<br><br>        return $this-&gt;merge($left, $right);<br>    }<br><br>    &#47;**<br>     * 合并两个已经排序完毕的数组（从小到大）<br>     * @param  array $a 第一个数组<br>     * @param  array $b 第二个数组<br>     * @return array    合并后的数组<br>     *&#47;<br>    public function merge($a = [], $b = [])<br>    {<br>        $a_length = count($a);<br>        $b_length = count($b);<br>        $merged_one = [];<br>        $mi = $ai = $bi = 0;<br>        &#47;&#47; 轮流从两个数组中取出较小的值，放入合并后的数组中<br>        while($ai &lt; $a_length &amp;&amp; $bi &lt; $b_length) {<br>            if ($a[$ai] &lt;= $b[$bi]) {<br>                $merged_one[$mi] = $a[$ai];<br>                $ai++;<br>            } else {<br>                $merged_one[$mi] = $b[$bi];<br>                $bi++;<br>            }<br>            $mi++;<br>        }<br>        &#47;&#47; 将某个数组内剩余的数字放入合并后的数组中<br>        if ($ai &lt; $a_length) {<br>            for($i = $ai; $i &lt; $a_length; $i++) {<br>                $merged_one[$mi] = $a[$i];<br>                $mi++;<br>            }<br>        }<br>        if ($bi &lt; $b_length) {<br>            for($i = $bi; $i &lt; $b_length; $i++) {<br>                $merged_one[$mi] = $b[$bi];<br>                $mi++;<br>            }<br>        }<br><br>        return $merged_one;<br>    }<br>}","like_count":0},{"had_liked":false,"id":56161,"user_name":"西北偏北","can_delete":false,"product_type":"c1","uid":1043160,"ip_address":"","ucode":"64BD69C84EE6A1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erdpKbFgRLnicjsr6qkrPVKZcFrG3aS2V51HhjFP6Mh2CYcjWric9ud1Qiclo8A49ia3eZ1NhibDib0AOCg/132","comment_is_top":false,"comment_ctime":1546398876,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546398876","product_id":100021201,"comment_content":"归并排序的思想：<br>\t假设升序排列<br>\t通过将一个无序的数组，不断的二分，直到最后成为单个的数字。<br>\t单个的数字是有序的集合。对于两个有序的集合合并思想为：<br>\t创建一个新的大集合，分别从两个有序小集合中取出一个数比较大小，将较小的数从其原始集合中移除，并将其加入新的集合。<br>\t两个集合中的某个一为空，可以将不为空的直接加入大集合。<br><br>归并排序的时间复杂度为：n(logn)","like_count":0},{"had_liked":false,"id":54453,"user_name":"Oli张帆","can_delete":false,"product_type":"c1","uid":1338098,"ip_address":"","ucode":"6E60A370C3C14A","user_header":"https://static001.geekbang.org/account/avatar/00/14/6a/f2/db90fa96.jpg","comment_is_top":false,"comment_ctime":1545873718,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545873718","product_id":100021201,"comment_content":"提供一个SWIFT实现归并排序的例子：<br><br>func merge(a: [Int], b: [Int]) -&gt; [Int] {<br>    if a.count &lt;= 0 {<br>        return b<br>    }<br>    if b.count &lt;= 0 {<br>        return a<br>    }<br>    var mi = 0<br>    var ai = 0<br>    var bi = 0<br>    var mergedOne = a + b<br>    while ai &lt; a.count &amp;&amp; bi &lt; b.count {<br>        if a[ai] &lt;= b[bi] {<br>            mergedOne[mi] = a[ai]<br>            ai += 1<br>        } else {<br>            mergedOne[mi] = b[bi]<br>            bi += 1<br>        }<br>        mi += 1<br>    }<br>    if ai &lt; a.count {<br>        for i in ai..&lt;a.count {<br>            mergedOne[mi] = a[i]<br>            mi += 1<br>        }<br>    } else {<br>        for i in bi..&lt;b.count {<br>            mergedOne[mi] = b[i]<br>            mi += 1<br>        }<br>    }<br>    return mergedOne<br>}<br><br>func mergeSort(toSort: [Int]) -&gt; [Int] {<br>    if toSort.count &lt;= 1 {<br>        return toSort<br>    }<br>    let mid = Int(floor(Double(toSort.count) &#47; 2))<br>    let left = Array(toSort[0..&lt;mid])<br>    let right = Array(toSort[mid..&lt;toSort.count])<br>    let leftSorted = mergeSort(toSort: left)<br>    let rightSorted = mergeSort(toSort: right)<br>    let merged = merge(a: leftSorted, b: rightSorted)<br>    return merged<br>}<br><br>let l = mergeSort(toSort: [34,1,2,9,2,1,3])","like_count":0},{"had_liked":false,"id":53000,"user_name":"朱月俊","can_delete":false,"product_type":"c1","uid":1017707,"ip_address":"","ucode":"4DA0728B862FBD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/6b/0b6cd39a.jpg","comment_is_top":false,"comment_ctime":1545567687,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545567687","product_id":100021201,"comment_content":"多路归并，直接整一个优先队列即可。","like_count":0},{"had_liked":false,"id":52666,"user_name":"梅坊帝卿","can_delete":false,"product_type":"c1","uid":1240270,"ip_address":"","ucode":"702F019BA3356C","user_header":"","comment_is_top":false,"comment_ctime":1545470045,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545470045","product_id":100021201,"comment_content":"自己总结下看前面留言的收获，归并排序是稳定排序，所以在一些库函数的使用上，有稳定的要求，不选择快排（不稳定）。对于大数据，内存放不下，分出去总要回来，回来内存还是不够，这时候可以每次读一部分，比如128g数据，4g内存，每次读分好的64g中的1g，做完再继续读取。所以归并也可用在磁盘排序。mapreduce可以将工作量分发出去，分布式并行的思路。","like_count":0},{"had_liked":false,"id":52169,"user_name":"NullPointer","can_delete":false,"product_type":"c1","uid":1179184,"ip_address":"","ucode":"83B7DA926A0411","user_header":"https://static001.geekbang.org/account/avatar/00/11/fe/30/c9b568c3.jpg","comment_is_top":false,"comment_ctime":1545322801,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545322801","product_id":100021201,"comment_content":"老师更新这么快哈。我才把上个课后题做完。","like_count":0}]}