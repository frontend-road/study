{"id":166635,"title":"15 | 边界：微服务的各种边界在架构演进中的作用？","content":"<p>你好，我是欧创新。</p><p>前几讲我们已经介绍过了，在用DDD进行微服务设计时，我们可以通过事件风暴来确定领域模型边界，划定微服务边界，定义业务和系统运行边界，从而保证微服务的单一职责和随需而变的架构演进能力。</p><p>那重点落到边界的时候，总结一下就是，<span class=\"orange\">微服务的设计要涉及到逻辑边界、物理边界和代码边界等等。</span></p><p>那么这些边界在微服务架构演进中到底起到什么样的作用？我们又该如何理解这些边界呢？这就是我们今天重点要解决的问题。</p><h2>演进式架构</h2><p>在微服务设计和实施的过程中，很多人认为：“将单体拆分成多少个微服务，是微服务的设计重点。”可事实真的是这样吗？其实并非如此！</p><p>Martin <a href=\"http://www.baidu.com/link?url=YyTvvp3mcbbqbI5LH2o8zWknPkc42pT_71P2crD_LZ7nXMjI9dYbKmcHADU15M5zCZvQjqvj9P7NR6QKHTJzpq2-c6LwhMCz50sZMvmdlPu\">Fowler</a> 在提出微服务时，他提到了微服务的一个重要特征——演进式架构。那什么是演进式架构呢？演进式架构就是以支持增量的、非破坏的变更作为第一原则，同时支持在应用程序结构层面的多维度变化。</p><p>那如何判断微服务设计是否合理呢？其实很简单，只需要看它是否满足这样的情形就可以了：随着业务的发展或需求的变更，在不断重新拆分或者组合成新的微服务的过程中，不会大幅增加软件开发和维护的成本，并且这个架构演进的过程是非常轻松、简单的。</p><p><span class=\"orange\">这也是微服务设计的重点，就是看微服务设计是否能够支持架构长期、轻松的演进。</span></p><!-- [[[read_end]]] --><p>那用DDD方法设计的微服务，不仅可以通过限界上下文和聚合实现微服务内外的解耦，同时也可以很容易地实现业务功能积木式模块的重组和更新，从而实现架构演进。</p><h2>微服务还是小单体？</h2><p>有些项目团队在将集中式单体应用拆分为微服务时，首先进行的往往不是建立领域模型，而只是按照业务功能将原来单体应用的一个软件包拆分成多个所谓的“微服务”软件包，而这些“微服务”内的代码仍然是集中式三层架构的模式，“微服务”内的代码高度耦合，逻辑边界不清晰，这里我们暂且称它为“小单体微服务”。</p><p>下面这张图也很好地展示了这个过程。</p><p><img src=\"https://static001.geekbang.org/resource/image/cc/eb/cc697f4e8eef2629a660d247c8a1eceb.jpg?wh=1242*624\" alt=\"\"></p><p>而随着新需求的提出和业务的发展，这些小单体微服务会慢慢膨胀起来。当有一天你发现这些膨胀了的微服务，有一部分业务功能需要拆分出去，或者部分功能需要与其它微服务进行重组时，你会发现原来这些看似清晰的微服务，不知不觉已经摇身一变，变成了臃肿油腻的大单体了，而这个大单体内的代码依然是高度耦合且边界不清的。</p><p>“辛辛苦苦好多年，一夜回到解放前啊！”这个时候你就需要一遍又一遍地重复着从大单体向单体微服务重构的过程。想想，这个代价是不是有点高了呢？</p><p>其实这个问题已经很明显了，那就是边界。</p><p>这种单体式微服务只定义了一个维度的边界，也就是微服务之间的物理边界，本质上还是单体架构模式。微服务设计时要考虑的不仅仅只有这一个边界，别忘了还要定义好微服务内的逻辑边界和代码边界，这样才能得到你想要的结果。</p><p>那现在你知道了，我们一定要避免将微服务设计为小单体微服务，那具体该如何避免呢？清晰的边界人人想要，可该如何保证呢？DDD已然给出了答案。</p><h2>微服务边界的作用</h2><p>你应该还记得DDD设计方法里的限界上下文和聚合吧？它们就是用来定义领域模型和微服务边界的。</p><p>我们再来回顾一下DDD的设计过程。</p><p>在事件风暴中，我们会梳理出业务过程中的用户操作、事件以及外部依赖关系等，根据这些要素梳理出实体等领域对象。根据实体对象之间的业务关联性，将业务紧密相关的多个实体进行组合形成聚合，聚合之间是第一层边界。根据业务及语义边界等因素将一个或者多个聚合划定在一个限界上下文内，形成领域模型，限界上下文之间的边界是第二层边界。</p><p>为了方便理解，我们将这些边界分为：<strong>逻辑边界、物理边界和代码边界</strong>。</p><p><strong>逻辑边界</strong>主要定义同一业务领域或应用内紧密关联的对象所组成的不同聚类的组合之间的边界。事件风暴对不同实体对象进行关联和聚类分析后，会产生多个聚合和限界上下文，它们一起组成这个领域的领域模型。微服务内聚合之间的边界就是逻辑边界。一般来说微服务会有一个以上的聚合，在开发过程中不同聚合的代码隔离在不同的聚合代码目录中。</p><p>逻辑边界在微服务设计和架构演进中具有非常重要的意义！</p><p>微服务的架构演进并不是随心所欲的，需要遵循一定的规则，这个规则就是逻辑边界。微服务架构演进时，在业务端以聚合为单位进行业务能力的重组，在微服务端以聚合的代码目录为单位进行微服务代码的重组。由于按照DDD方法设计的微服务逻辑边界清晰，业务高内聚，聚合之间代码松耦合，因此在领域模型和微服务代码重构时，我们就不需要花费太多的时间和精力了。</p><p>现在我们来看一个微服务实例，在下面这张图中，我们可以看到微服务里包含了两个聚合的业务逻辑，两个聚合分别内聚了各自不同的业务能力，聚合内的代码分别归到了不同的聚合目录下。</p><p>那随着业务的快速发展，如果某一个微服务遇到了高性能挑战，需要将部分业务能力独立出去，我们就可以以聚合为单位，将聚合代码拆分独立为一个新的微服务，这样就可以很容易地实现微服务的拆分。</p><p><img src=\"https://static001.geekbang.org/resource/image/88/3d/88d709569367264d368b08a7d9658c3d.png?wh=857*666\" alt=\"\"></p><p>另外，我们也可以对多个微服务内有相似功能的聚合进行功能和代码重组，组合为新的聚合和微服务，独立为通用微服务。现在你是不是有点做中台的感觉呢？</p><p><strong>物理边界</strong>主要从部署和运行的视角来定义微服务之间的边界。不同微服务部署位置和运行环境是相互物理隔离的，分别运行在不同的进程中。这种边界就是微服务之间的物理边界。</p><p><strong>代码边界</strong>主要用于微服务内的不同职能代码之间的隔离。微服务开发过程中会根据代码模型建立相应的代码目录，实现不同功能代码的隔离。由于领域模型与代码模型的映射关系，代码边界直接体现出业务边界。代码边界可以控制代码重组的影响范围，避免业务和服务之间的相互影响。微服务如果需要进行功能重组，只需要以聚合代码为单位进行重组就可以了。</p><h2>正确理解微服务的边界</h2><p>从上述内容中，我们知道了，按照DDD设计出来的逻辑边界和代码边界，让微服务架构演进变得不那么费劲了。</p><p>微服务的拆分可以参考领域模型，也可以参考聚合，因为聚合是可以拆分为微服务的最小单位的。但实施过程是否一定要做到逻辑边界与物理边界一致性呢？也就是说聚合是否也一定要设计成微服务呢？答案是不一定的，这里就涉及到微服务过度拆分的问题了。</p><p>微服务的过度拆分会使软件维护成本上升，比如：集成成本、发布成本、运维成本以及监控和定位问题的成本等。在项目建设初期，如果你不具备较强的微服务管理能力，那就不宜将微服务拆分过细。当我们具备一定的能力以后，且微服务内部的逻辑和代码边界也很清晰，你就可以随时根据需要，拆分出新的微服务，实现微服务的架构演进了。</p><p>当然，还要记住一点，微服务内聚合之间的服务调用和数据依赖需要符合高内聚松耦合的设计原则和开发规范，否则你也不能很快完成微服务的架构演进。</p><h2>总结</h2><p>今天我们主要讨论了微服务架构设计中的各种边界在架构演进中的作用。</p><p><strong>逻辑边界：</strong>微服务内聚合之间的边界是逻辑边界。它是一个虚拟的边界，强调业务的内聚，可根据需要变成物理边界，也就是说聚合也可以独立为微服务。</p><p><strong>物理边界：</strong>微服务之间的边界是物理边界。它强调微服务部署和运行的隔离，关注微服务的服务调用、容错和运行等。</p><p><strong>代码边界：</strong>不同层或者聚合之间代码目录的边界是代码边界。它强调的是代码之间的隔离，方便架构演进时代码的重组。</p><p>通过以上边界，我们可以让业务能力高内聚、代码松耦合，且清晰的边界，可以快速实现微服务代码的拆分和组合，轻松实现微服务架构演进。但有一点一定要格外注意，边界清晰的微服务，不是大单体向小单体的演进。</p><h2>思考题</h2><p>分享一下你们公司目前采用了什么样的方法来实现微服务的架构演进？和DDD设计方法相比，有何区别，你觉得哪种方式更好呢？可结合业务场景进行分析。</p><p>期待你的分享，你可以在留言区中畅所欲言，我们一同交流！</p><p></p>","comments":[{"had_liked":false,"id":221887,"user_name":"清涧飞鸟","can_delete":false,"product_type":"c1","uid":1706683,"ip_address":"","ucode":"15F3B5FD4D7822","user_header":"https://static001.geekbang.org/account/avatar/00/1a/0a/bb/2f3b6af3.jpg","comment_is_top":false,"comment_ctime":1590628852,"is_pvip":false,"replies":[{"id":"81826","content":"在DDD中如果领域很大的话，内部由小到大的顺序大概是这样的：值对象-》实体-》聚合（最小业务功能单元，如果非常必要可以拆分为微服务）-》限界上下文（一般作为拆分为微服务的依据，包含一到多个聚合）-》子域（包含一到多个限界上下文）-》领域（包含支撑子域、核心子域或通用子域等一到多个子域）。<br>在有些情况下，一个子域可能就是一个限界上下文，一个限界上下文可能只包含一个聚合。一般来说，在一个限界上下内来构建领域模型，一个领域模型可以设计出一个微服务。<br>服务的从低向上关系是这样的：实体方法-》领域服务-》应用服务-》Facade接口。<br>不知道是否清楚了？","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1590650117,"ip_address":"","comment_id":221887,"utype":1}],"discussion_count":4,"race_medal":0,"score":"181979255284","product_id":100037301,"comment_content":"老师，这节课程看了好几次了，但是对于几个概念还是有点朦胧，您帮我判断下以下我的几个说法：<br>1）一个聚合可以看作为子域<br>2）一个限界上下文可以作为子域<br>3）聚合是最小的边界<br>4）限界上下文内可以包含一个或多个聚合<br>5）领域模型是一个子域、一个限界上下文、一个聚合？？或者都可以，只要可独立为微服务的就可以叫一个领域模型.","like_count":43,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496600,"discussion_content":"在DDD中如果领域很大的话，内部由小到大的顺序大概是这样的：值对象-》实体-》聚合（最小业务功能单元，如果非常必要可以拆分为微服务）-》限界上下文（一般作为拆分为微服务的依据，包含一到多个聚合）-》子域（包含一到多个限界上下文）-》领域（包含支撑子域、核心子域或通用子域等一到多个子域）。\n在有些情况下，一个子域可能就是一个限界上下文，一个限界上下文可能只包含一个聚合。一般来说，在一个限界上下内来构建领域模型，一个领域模型可以设计出一个微服务。\n服务的从低向上关系是这样的：实体方法-》领域服务-》应用服务-》Facade接口。\n不知道是否清楚了？","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1590650117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1444583,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erS45sT36oSCibh8YMF9aD0IKltrdCoEicqUeEzbC2Hlr4UiahibfLvpib3LauzQxv6X3vyfCvrgz0m3dg/132","nickname":"jeeker","note":"","ucode":"1E78795E7DF8E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":591885,"discussion_content":"老师，聚合有没有方法？我的理解是应用服务调领域服务，领域服务调聚合的方法，聚合调实体的方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666915994,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":496600,"ip_address":"福建"},"score":591885,"extra":""}]},{"author":{"id":2043294,"avatar":"","nickname":"0084","note":"","ucode":"EC5085EEEB1E12","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302251,"discussion_content":"精简","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598859872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1706683,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/0a/bb/2f3b6af3.jpg","nickname":"清涧飞鸟","note":"","ucode":"15F3B5FD4D7822","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275067,"discussion_content":"清楚了，感谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590657701,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152487,"user_name":"密码123456","can_delete":false,"product_type":"c1","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1574035029,"is_pvip":false,"replies":[{"id":"58598","content":"在没有用DDD之前，我们也是这么干的^_^。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574039796,"ip_address":"","comment_id":152487,"utype":1}],"discussion_count":4,"race_medal":0,"score":"83178413653","product_id":100037301,"comment_content":"之前2个月前，要做微服务，当时不了解是啥，就感觉好厉害。然后按照业务划分。最后做成的结果，就像文中说的。大单体变成小单体。，高度耦合。做的自己都快看不下去了。","like_count":20,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474830,"discussion_content":"在没有用DDD之前，我们也是这么干的^_^。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574039796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1096652,"avatar":"https://static001.geekbang.org/account/avatar/00/10/bb/cc/fac12364.jpg","nickname":"xxx","note":"","ucode":"E79CEA70430449","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385626,"discussion_content":"有本国外的讲微服务的书，里面说他们接手过一个微服务的项目，但是耦合很严重，迭代成本还是很大，于是他们先把这些微服务合成一个大单体服务，再重新用DDD拆成新的微服务……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627184194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1529298,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/iacfiaRC2Vze9eEaVibAFkngm4nmA0DwoibC3kHj6pCOQ87VDa955kK3kavnrDnibmfeIFd4G6Ab2fDkNrbUapL8ibAQ/132","nickname":"你的美","note":"","ucode":"71B97BDBA3CDC3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54098,"discussion_content":"密码123456，那现在呢改好了吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574258877,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1215152,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoOGZ6lbHiboIZMN9USbeutnmCWBahVLtSlKlIENKvrZQCUQzpzeZQOxTntIkBUeDk6qZUPdqmfKrQ/132","nickname":"宝宝太喜欢极客时间了","note":"","ucode":"9CDB679C257612","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52738,"discussion_content":"同感同感","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574082117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215441,"user_name":"开心小毛","can_delete":false,"product_type":"c1","uid":1023762,"ip_address":"","ucode":"9D57A2773759F3","user_header":"","comment_is_top":false,"comment_ctime":1588992824,"is_pvip":false,"replies":[{"id":"80278","content":"看看这段话能不能解答你的问题。<br>聚合中实体和值对象等DO对象的创建和持久化是聚合必不可少的操作。为了保证聚合内数据在修改时符合聚合业务规则要求，聚合内实体和值对象在创建和持久化时，需要遵循聚合统一的业务规则。<br>对于实体和值对象比较多和依赖关系复杂的聚合，在DO对象创建时，需要确保聚合根和它依赖的对象实例同时被创建。如果将这项工作全部交由聚合根来实现，聚合根构造函数的逻辑将会非常复杂，聚合根也无法聚焦于自身的领域逻辑。<br>为了让聚合根专注于表达领域模型，我们尽量将这些比较通用的，与领域模型业务逻辑无关的工作，从聚合根中剥离。将它们放到工厂（Factory）中实现，通过工厂封装聚合内复杂对象的创建过程，完成聚合根、实体和值对象等DO对象的创建。这样也可以隐藏聚合内DO对象的创建过程，避免暴露聚合的内部结构。<br>聚合内DO对象创建的初始化数据来源于PO对象，PO对象是仓储从基础层获得的。在工厂服务中完成DO对象构建和从PO到DO对象的数据转换，完成DO对象的数据初始化。<br>除了构建DO对象，在将DO对象持久化时，还会有从DO对象到PO对象的转换，这类通用的持久化对象的转换操作，也可以放在工厂实现。<br>但并不是所有聚合对象的构造都需要用工厂来实现。如果聚合内领域对象简单，构造过程也并不复杂，你仍然可以用聚合根构造函数，完成聚合所有依赖对象的构建和数据初始化。<br>","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1589424683,"ip_address":"","comment_id":215441,"utype":1}],"discussion_count":3,"race_medal":0,"score":"53128600376","product_id":100037301,"comment_content":"请问老师，为什么再给出的例子中会出现某某工厂类（leaveFactory）呢？<br>是用来从数据库中读取并创建leave实体的么？如果是的话，为何不在leaveDomainService类中加一个GetLeave方法呢，不知leaveFactory有何必要。<br>是用来从数据库中插入并返回新建leave实体的么？我一直是通过DTO中的ID是否为零来判断是否为新建实体的，不知leaveFactory有何必要。<br>谢谢老师解惑。","like_count":13,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494439,"discussion_content":"看看这段话能不能解答你的问题。\n聚合中实体和值对象等DO对象的创建和持久化是聚合必不可少的操作。为了保证聚合内数据在修改时符合聚合业务规则要求，聚合内实体和值对象在创建和持久化时，需要遵循聚合统一的业务规则。\n对于实体和值对象比较多和依赖关系复杂的聚合，在DO对象创建时，需要确保聚合根和它依赖的对象实例同时被创建。如果将这项工作全部交由聚合根来实现，聚合根构造函数的逻辑将会非常复杂，聚合根也无法聚焦于自身的领域逻辑。\n为了让聚合根专注于表达领域模型，我们尽量将这些比较通用的，与领域模型业务逻辑无关的工作，从聚合根中剥离。将它们放到工厂（Factory）中实现，通过工厂封装聚合内复杂对象的创建过程，完成聚合根、实体和值对象等DO对象的创建。这样也可以隐藏聚合内DO对象的创建过程，避免暴露聚合的内部结构。\n聚合内DO对象创建的初始化数据来源于PO对象，PO对象是仓储从基础层获得的。在工厂服务中完成DO对象构建和从PO到DO对象的数据转换，完成DO对象的数据初始化。\n除了构建DO对象，在将DO对象持久化时，还会有从DO对象到PO对象的转换，这类通用的持久化对象的转换操作，也可以放在工厂实现。\n但并不是所有聚合对象的构造都需要用工厂来实现。如果聚合内领域对象简单，构造过程也并不复杂，你仍然可以用聚合根构造函数，完成聚合所有依赖对象的构建和数据初始化。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589424683,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1731543,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/6b/d7/8872624a.jpg","nickname":"xmeng","note":"","ucode":"C0CA2182BA3B4B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":353132,"discussion_content":"对于老师的回答 表示同意，后续要关注工程方法里面是如何优雅实现数据库调用和封装的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615020339,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1796332,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/68/ec/eb0ebbb6.jpg","nickname":"日月星辰","note":"","ucode":"4E9F48153B2D8B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278024,"discussion_content":"那domainService是干嘛的，它不就是对聚合的整合和编排吗，不可以在它里面进行聚合的整理和持久化吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591144960,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":201340,"user_name":"秦伟","can_delete":false,"product_type":"c1","uid":1931692,"ip_address":"","ucode":"D47C1F57500FE1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/VjomKNzfFiaIttqYMxbjAWTG7NL7P2UqC5fbSvg0JW80SLnoR2oH1G4U2eibmxbR4wPpoqZdDnjC8GqgShDOBRzA/132","comment_is_top":false,"comment_ctime":1585753270,"is_pvip":false,"replies":[{"id":"75376","content":"可以的，一步一步来。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1585797899,"ip_address":"","comment_id":201340,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35945491638","product_id":100037301,"comment_content":"老师，我们正在做组件化，公司架构师说只对核心领域用ddd设计，其他的还是安三成架构开发，这样可以吗？","like_count":8,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490305,"discussion_content":"可以的，一步一步来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585797899,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164575,"user_name":"alex","can_delete":false,"product_type":"c1","uid":1707959,"ip_address":"","ucode":"990D1092DE3E86","user_header":"https://static001.geekbang.org/account/avatar/00/1a/0f/b7/9f3edf9f.jpg","comment_is_top":false,"comment_ctime":1577030253,"is_pvip":false,"replies":[{"id":"62546","content":"感觉你这种方案也没法解决数据一致性的问题。一般来说产生数据一致性的主要原因在数据库，也就是说一个写成功，另一个写失败。虽然JAR包和业务执行逻辑在一起了，但是由于数据库是分开的，在数据库层面还是无法保证数据的一致性的，所以虽然它们在一个jar包中，应该还是需要采用分布式事务的。<br>我们没有遇到过你说的场景，但是这个场景应该在电商里面是非常常见的，比如查询商品数量，商品售出后，更新商品库存数据。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1577062866,"ip_address":"","comment_id":164575,"utype":1}],"discussion_count":10,"race_medal":0,"score":"14461932141","product_id":100037301,"comment_content":"欧总，你好，我在拆分微服务时遇到一个好纠结的问题，例如三个微服务，分别是入库微服务，出库微服务，库存微服务，而库存微服务主要提供两种能力，一是：查询库存，二是：更新库存数据，而入库服务与出库服务都会在自己的业务逻辑内调用库存服务的“查询库存”和“更新库存”方法，为了避开分布式事务的场景，我们现在用的方案是在入库，出库的操作时，通过接口形式调用库存服务的“查询库存”接口方法，但当要在入库或出库操作步骤中要更新库存数据时，我们为了保证入库操作与库存更新在同一个事务内执行，达到事务一致性，我们通过引用库存服务对应的jar包形式，在入库和出库的服务代码中调用库存服务模块的“更新库存”的service方法来实现的，请问对于这种场景，你们有没有遇到，如果有，那你们是如何处理的？请指教，谢谢。","like_count":3,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478820,"discussion_content":"感觉你这种方案也没法解决数据一致性的问题。一般来说产生数据一致性的主要原因在数据库，也就是说一个写成功，另一个写失败。虽然JAR包和业务执行逻辑在一起了，但是由于数据库是分开的，在数据库层面还是无法保证数据的一致性的，所以虽然它们在一个jar包中，应该还是需要采用分布式事务的。\n我们没有遇到过你说的场景，但是这个场景应该在电商里面是非常常见的，比如查询商品数量，商品售出后，更新商品库存数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577062866,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1206034,"avatar":"https://static001.geekbang.org/account/avatar/00/12/67/12/5c6eb568.jpg","nickname":"Tom.G","note":"","ucode":"7929B45C1A51F8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211392,"discussion_content":"考虑库存要求强一致性，如果把入库、出库、库存三个微服务合并成库存微服务，表也设计在同一数据库中，就可以避免分布式事务问题了","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1584846693,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1089345,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9f/41/82306dfe.jpg","nickname":"包子","note":"","ucode":"6CC4EBB8CD3924","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":133331,"discussion_content":"微服务的拆分本来就会带来分布式事务问题吧。为什么要回避呢","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1578961777,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1180810,"avatar":"https://static001.geekbang.org/account/avatar/00/12/04/8a/ff94bd60.jpg","nickname":"涛涛","note":"","ucode":"747C4B1F20A2D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289581,"discussion_content":"出库入库的主要操作对象就是库存表，你们服务拆的太细了。解决：1分布式事务（强一致）2mq异步（最终一致）","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594137866,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1293551,"avatar":"https://static001.geekbang.org/account/avatar/00/13/bc/ef/98550b85.jpg","nickname":"云彩＆草原","note":"","ucode":"6AEA686202F1CC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1180810,"avatar":"https://static001.geekbang.org/account/avatar/00/12/04/8a/ff94bd60.jpg","nickname":"涛涛","note":"","ucode":"747C4B1F20A2D3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581552,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658830319,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":289581,"ip_address":""},"score":581552,"extra":""}]},{"author":{"id":1501234,"avatar":"","nickname":"Geek_88604f","note":"","ucode":"33DD1318E53814","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":187160,"discussion_content":"入库和出库都是独立运行的。你这种方式是无法保证事务的。要么库存服务单线程，要么加锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582726991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1707959,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/0f/b7/9f3edf9f.jpg","nickname":"alex","note":"","ucode":"990D1092DE3E86","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":97947,"discussion_content":"欧总，是这样的，如果入库和库存服务都是操作同一个DB，那么在如下这个场景中是可以实现同一事务的：在入库微服务中有一个service方法，先保存入库单操作记录到入库单表，再调用库存jar包中的service方法更新库存表的状态，但这样做感觉违背了把库存微服务独立出来的意义，但其它场景中如果要查询库存的，是可以通过库存微服务提供的查询库存服务接口实现。所以对要用到库存更新操作的场景，为了保证在同一事务，大多只能通过引用库存服务的jar包来实现，这里有解决方法吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577116393,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1039695,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/dd/4f/77b290e2.jpg","nickname":"zbx","note":"","ucode":"5EA4B24DEF2724","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1707959,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/0f/b7/9f3edf9f.jpg","nickname":"alex","note":"","ucode":"990D1092DE3E86","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":238685,"discussion_content":"那你库存微服务只是个查询服务","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587225125,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":97947,"ip_address":""},"score":238685,"extra":""},{"author":{"id":1199467,"avatar":"https://static001.geekbang.org/account/avatar/00/12/4d/6b/79642a53.jpg","nickname":"邹培俊","note":"","ucode":"54B1AAE6BDAB33","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1707959,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/0f/b7/9f3edf9f.jpg","nickname":"alex","note":"","ucode":"990D1092DE3E86","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":270866,"discussion_content":"问题解决了吗？这个是不是可以参考前面提到的领域事件。当入库写入数据库成功后，发布成功事件。库存服务定义入库领域事件。进行库存的数据更新啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590065682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":97947,"ip_address":""},"score":270866,"extra":""},{"author":{"id":1292669,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIaaDFHiag4sFcO7JUn028Mtk1YvFpibIibLzcTE7Qak0icJklMpqh7k5dSK27dibicMuNgYMozgaibeYppA/132","nickname":"Bball","note":"","ucode":"E483CAFE50CB99","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1707959,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/0f/b7/9f3edf9f.jpg","nickname":"alex","note":"","ucode":"990D1092DE3E86","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542629,"discussion_content":"感觉引入jar依赖太强了，还不如直接走http或者mq","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640822005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":97947,"ip_address":""},"score":542629,"extra":""}]}]},{"had_liked":false,"id":154255,"user_name":"Eric","can_delete":false,"product_type":"c1","uid":1001947,"ip_address":"","ucode":"1813E7F86A17E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/db/1d669080.jpg","comment_is_top":false,"comment_ctime":1574398212,"is_pvip":true,"replies":[{"id":"59199","content":"应用层与领域层之间是DO。<br>微服务之间用DTO比较合适。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574400337,"ip_address":"","comment_id":154255,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10164332804","product_id":100037301,"comment_content":"在同一个微服务内的应用层使用领域层的服务时，数据传递建议使用哪种类型的对象呢？是用DTO还是DO？<br><br>如果因为性能问题，讲应用层对领域服务的调用从微服务内调用改为跨微服务调用（例如RESTful或者RPC），那么调用接口传递数据是否使用DTO比较合适？","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475418,"discussion_content":"应用层与领域层之间是DO。\n微服务之间用DTO比较合适。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574400337,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261737,"user_name":"玉宸道君","can_delete":false,"product_type":"c1","uid":1963734,"ip_address":"","ucode":"5C3774505530EC","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIbFFwlKCGmZRVMbjiaUs4wp3PUf4jIzibU7IDTvUVcQTbFQ1WyA0MF5iaMeHInHSLfFqVhflyeUuVhQ/132","comment_is_top":false,"comment_ctime":1605509726,"is_pvip":false,"replies":[{"id":"95260","content":"从单体到微服务肯定是有代价的，需要有相关的设计方法论指导，规范和降低服务设计、开发和集成的复杂度，还有诸如分布式架构下的一些设计理念也是需要掌握的。比如如何通过数据冗余，比如值对象，避免跨微服务的数据访问，如果通过领域事件驱动的方式实现聚合和微服务之间的解耦等等。<br>如果单体应用完全可以满足业务要求，也可以不转成微服务。但是目前由于基础环境的变化，比如云计算，微服务比单体应用有更强的适应能力，更容易上云，生态也更齐全，所以从单体到微服务是未来的趋势，这就需要掌握一套好的设计方法。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1605758097,"ip_address":"","comment_id":261737,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5900477022","product_id":100037301,"comment_content":"我刚刚加入的一个公司，现在拆分的微服务代码结构就是“小单体微服务”。并且其中多个服务的业务都有评论、点赞这些操作，于是他们把评论、点赞单独抽取到了一个微服务中去了。我觉得这样的拆分方式是把自己的业务给拆分出去了，这样的微服务不是业务高内聚的。打个比方，这样拆分的微服务，就像一个只有自己身体的躯干部分的人，手、脚不在自己身上，做事情的时候还需要临时去找手、脚。接口内部微服务间调用变多了，对接口的可靠、性能都造成影响。<br><br>不知道老师对我说的情况有什么看法呢？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509589,"discussion_content":"从单体到微服务肯定是有代价的，需要有相关的设计方法论指导，规范和降低服务设计、开发和集成的复杂度，还有诸如分布式架构下的一些设计理念也是需要掌握的。比如如何通过数据冗余，比如值对象，避免跨微服务的数据访问，如果通过领域事件驱动的方式实现聚合和微服务之间的解耦等等。\n如果单体应用完全可以满足业务要求，也可以不转成微服务。但是目前由于基础环境的变化，比如云计算，微服务比单体应用有更强的适应能力，更容易上云，生态也更齐全，所以从单体到微服务是未来的趋势，这就需要掌握一套好的设计方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605758097,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1849475,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIJyNMqG7AeC0ibzW6K4nb3jS7uHgFUBLQUibwtIA0k28zQAddbzmnD9jKpGObwVNeDiaQbeQtKCIFbA/132","nickname":"BigMountain","note":"","ucode":"2715621F6C6155","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413085,"discussion_content":"我理解这就是通用域的功能。   ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636379908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245186,"user_name":"0084","can_delete":false,"product_type":"c1","uid":2043294,"ip_address":"","ucode":"EC5085EEEB1E12","user_header":"","comment_is_top":false,"comment_ctime":1598859699,"is_pvip":false,"replies":[{"id":"90664","content":"这种情况应该很常见。在没有接触到DDD之前，很多企业可能还是在按照三层架构模式进行微服务设计。在理解了DDD的核心设计思想后，你会理解ddd的方法在微服务设计中还是很有前瞻性的。架构设计中“高内聚，低耦合”强调了很多年，这个原则基本会一直延续下去。DDD虽然早于微服务很多年出现，其根本目的就是为了“高内聚和低耦合”和实现架构轻松演进。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1599467416,"ip_address":"","comment_id":245186,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5893826995","product_id":100037301,"comment_content":"有些项目团队在将集中式单体应用拆分为微服务时，首先进行的往往不是建立领域模型，而只是按照业务功能将原来单体应用的一个软件包拆分成多个所谓的“微服务”软件包，而这些“微服务”内的代码仍然是集中式三层架构的模式，“微服务”内的代码高度耦合，逻辑边界不清晰，这里我们暂且称它为“小单体微服务”<br><br>我们公司2017年中开始用SpringCloud全家桶搞微服务，目前的现状和老师讲的小单体微服务一摸一样，每个微服务中的代码还是按照传统三层架构设计。比如有客户系统、影响系统、消息系统、支付系统、账务系统等","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504809,"discussion_content":"这种情况应该很常见。在没有接触到DDD之前，很多企业可能还是在按照三层架构模式进行微服务设计。在理解了DDD的核心设计思想后，你会理解ddd的方法在微服务设计中还是很有前瞻性的。架构设计中“高内聚，低耦合”强调了很多年，这个原则基本会一直延续下去。DDD虽然早于微服务很多年出现，其根本目的就是为了“高内聚和低耦合”和实现架构轻松演进。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599467416,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1435845,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e8/c5/8bdb0bba.jpg","nickname":"DarKnight","note":"","ucode":"B04AFD03768827","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329718,"discussion_content":"请问下这种“小单体微服务”的架构模式是否逐渐展现了一些问题呢？例如会不会在演进迭代过程中对不同微服务业务进行重组或者重划分的时候，发现代码耦合严重的问题？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606449861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225709,"user_name":"王海林","can_delete":false,"product_type":"c1","uid":2020668,"ip_address":"","ucode":"2874379A675E2A","user_header":"https://static001.geekbang.org/account/avatar/00/1e/d5/3c/7688c830.jpg","comment_is_top":false,"comment_ctime":1591838155,"is_pvip":false,"replies":[{"id":"84661","content":"是的，要保持逻辑边界的清晰，就必须保证聚合之间的松耦合。松耦合有两个问题要避免：一是不同聚合的领域服务之间不要直接调用；二是不同聚合之间的DO实体或持久化实体之间不要产生表级关联，这样在从逻辑边界变成物理边界过程中就不需要进行太多的解耦的操作了。<br>如何结合聚合之间的服务调用呢？<br>聚合之间的领域服务调用可以上升到应用层，通过应用服务来组合和编排不同聚合之间领域服务，实现不同聚合之间的服务协同。在应用服务组合编排不同聚合的领域服务时，要尽量避免在不同聚合的服务调用时的对象传参方式，因为这样也会产生聚合之间的对象耦合。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1592986175,"ip_address":"","comment_id":225709,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5886805451","product_id":100037301,"comment_content":"老师，能进一步说说，逻辑边界与微服务API设计的原则吗？感觉这似乎是结构优雅与否的关键。","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497957,"discussion_content":"是的，要保持逻辑边界的清晰，就必须保证聚合之间的松耦合。松耦合有两个问题要避免：一是不同聚合的领域服务之间不要直接调用；二是不同聚合之间的DO实体或持久化实体之间不要产生表级关联，这样在从逻辑边界变成物理边界过程中就不需要进行太多的解耦的操作了。\n如何结合聚合之间的服务调用呢？\n聚合之间的领域服务调用可以上升到应用层，通过应用服务来组合和编排不同聚合之间领域服务，实现不同聚合之间的服务协同。在应用服务组合编排不同聚合的领域服务时，要尽量避免在不同聚合的服务调用时的对象传参方式，因为这样也会产生聚合之间的对象耦合。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592986175,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1947806,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/b8/9e/958ff12c.jpg","nickname":"Vae、腾少","note":"","ucode":"CE4306FE441A7D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369066,"discussion_content":"在应用服务组合编排不同聚合的领域服务时，要尽量避免在不同聚合的服务调用时的对象传参方式，因为这样也会产生聚合之间的对象耦合。\n这句话怎么理解呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618918700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208111,"user_name":"妙手空空","can_delete":false,"product_type":"c1","uid":1107573,"ip_address":"","ucode":"D295481D9BDA75","user_header":"https://static001.geekbang.org/account/avatar/00/10/e6/75/86c2a008.jpg","comment_is_top":false,"comment_ctime":1587279650,"is_pvip":false,"replies":[{"id":"77700","content":"理论上可以，但不建议聚合之间的领域服务直接调用，主要是为了聚合之间的解耦。你可以将这种聚合之间的调用，上升到应用层，通过应用服务来进行编排和调用。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1587296876,"ip_address":"","comment_id":208111,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5882246946","product_id":100037301,"comment_content":"领域服务之间能互相调用吗？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492343,"discussion_content":"理论上可以，但不建议聚合之间的领域服务直接调用，主要是为了聚合之间的解耦。你可以将这种聚合之间的调用，上升到应用层，通过应用服务来进行编排和调用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587296876,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152502,"user_name":"William.加","can_delete":false,"product_type":"c1","uid":1211450,"ip_address":"","ucode":"300FFC09DEE243","user_header":"https://static001.geekbang.org/account/avatar/00/12/7c/3a/5140a8b9.jpg","comment_is_top":false,"comment_ctime":1574037600,"is_pvip":false,"replies":[{"id":"58595","content":"如果还是原来的架构模式，不做解耦的话，应该还是小单体模式。我也是找了好久才找到了DDD这个方法，不知道还有没有其它更好的方法。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574039632,"ip_address":"","comment_id":152502,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5869004896","product_id":100037301,"comment_content":"老师，是不是不通过DDD拆分的微服务基本就是大单体到小单体的拆分？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474838,"discussion_content":"如果还是原来的架构模式，不做解耦的话，应该还是小单体模式。我也是找了好久才找到了DDD这个方法，不知道还有没有其它更好的方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574039632,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1179184,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fe/30/c9b568c3.jpg","nickname":"NullPointer","note":"","ucode":"83B7DA926A0411","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":165762,"discussion_content":"前面有说ddd只是产品经理， 如果你找个更牛的产品经理也是可以不要ddd的（在微服务拆分过程中，ddd的解耦思想得到了很大的应用，这也是现阶段ddd这个古老的思想重新焕发了新春的重要原因）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581323293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351667,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1658067964,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1658067964","product_id":100037301,"comment_content":"3界：逻辑，物理，代码边界<br>逻辑边界是聚合为单位，是一个业务纬度，如支付账号聚合，支付收付款聚合。<br>物理则是实际服务运行的物理情况，<br>支付中当量不大业务初期，可以一个微服务。<br>代码边界则是聚合的代码体现，用代码模块隔离不同聚合，后续重组可以修改小，演进架构。<br>边界很重要","like_count":0},{"had_liked":false,"id":327242,"user_name":"徐李","can_delete":false,"product_type":"c1","uid":1213325,"ip_address":"","ucode":"41550F6CA1E112","user_header":"https://static001.geekbang.org/account/avatar/00/12/83/8d/03cac826.jpg","comment_is_top":false,"comment_ctime":1640004130,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1640004130","product_id":100037301,"comment_content":"我们现在的微服务拆分主要是分着业务走，业务不一样就独立处理，业务相关的代码就放在一个微服务，有时候这个微服务业务很大，实际上就是一个单体了，然后再这个单体中再拆分出微服务，再拆分出微服务。与DDD相比较，可能DDD强调的是，就算在一个微服务中，他的包命名结构，也能保证拆分服务时候，或者代码重组的时候，简单可行。","like_count":0},{"had_liked":false,"id":315287,"user_name":"俯瞰风景.","can_delete":false,"product_type":"c1","uid":1044166,"ip_address":"","ucode":"A6DB68B7B84AEE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/c6/bebcbcf0.jpg","comment_is_top":false,"comment_ctime":1633786388,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633786388","product_id":100037301,"comment_content":"微服务架构的核心在于实现演进式架构，即随着业务的增长和需求的变化，能够支持架构长期、轻松的演进。<br><br>而实现这个目标的关键在于对于服务的拆分和服务内部实现的“高内聚低耦合”，对于微服务架构来说，聚合是可以拆分为微服务的最小单位，所以聚合和聚合之间的逻辑边界要清晰。以便于之后需要把一个聚合单独拆分为一个微服务时能够轻松实现。","like_count":0},{"had_liked":false,"id":314006,"user_name":"Rootrl","can_delete":false,"product_type":"c1","uid":1035390,"ip_address":"","ucode":"50FE3BBA92D417","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cc/7e/0d050964.jpg","comment_is_top":false,"comment_ctime":1632798585,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1632798585","product_id":100037301,"comment_content":"这个工程目录对应的是一个微服务对吧？到时候整体打包发布对吧？那么问题来了，这每个微服务应该是不同团队负责的，那么这些工程之间会用到公共的代码怎么办呢？比如Infrastructrue里面的utils，比如具体的DateUtil","like_count":0,"discussions":[{"author":{"id":1683548,"avatar":"https://static001.geekbang.org/account/avatar/00/19/b0/5c/b85b0748.jpg","nickname":"他们都叫我雷哥","note":"","ucode":"C24F920C28A93D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575936,"discussion_content":"我理解基础设施层存放的工具类是本服务使用到的。如果服务间共用的工具类可以用单独的服务以jar包形式引入","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655196679,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":310767,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1630898018,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630898018","product_id":100037301,"comment_content":"DDD梳理流程：<br>①先梳理出实体，再根据业务联系紧密的实体形成聚合，再根据业务及语义边界等因素将多个聚合划定在一个限界上下文(领域模型)。<br>②聚合之间的边界是逻辑边界，也就是逻辑隔离。<br>③逻辑边界之间的聚合不一定非得拆非单独的微服务，防止过度设计。<br>","like_count":0},{"had_liked":false,"id":310701,"user_name":"王智洋","can_delete":false,"product_type":"c1","uid":1666517,"ip_address":"","ucode":"B38934EA504663","user_header":"https://static001.geekbang.org/account/avatar/00/19/6d/d5/81e72368.jpg","comment_is_top":false,"comment_ctime":1630848519,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630848519","product_id":100037301,"comment_content":"老师 实体方法必须要用领域服务封装吗？   <br>如果我在应用服务层把实体构建出来了  直接调实体方法可以吗？<br><br>实体构建这里有个困惑点。 <br>如果构建实体的指令在领域层的话  有时候接口层传进来的参数对象需要传进领域层  耦合有点高<br>","like_count":0},{"had_liked":false,"id":302444,"user_name":"How2Go","can_delete":false,"product_type":"c1","uid":1151796,"ip_address":"","ucode":"A2242F1C832D36","user_header":"https://static001.geekbang.org/account/avatar/00/11/93/34/5e5b958e.jpg","comment_is_top":false,"comment_ctime":1626226118,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626226118","product_id":100037301,"comment_content":"聚合是逻辑边界，可以作为微服务拆分的最小单位。那么是不是就说明，不同的聚合间，数据是隔离的？ 简单来说，不同的聚合，对底层数据库表的依赖也是隔离的，不应该出现两个聚合，都访问一个表的情况？","like_count":0},{"had_liked":false,"id":302044,"user_name":"独孤九剑","can_delete":false,"product_type":"c1","uid":2230909,"ip_address":"","ucode":"6C1253E2B8C1D4","user_header":"https://static001.geekbang.org/account/avatar/00/22/0a/7d/ac715471.jpg","comment_is_top":false,"comment_ctime":1626053413,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626053413","product_id":100037301,"comment_content":"逻辑边界+物理边界+代码边界=&gt;高内聚&amp;低耦合架构","like_count":0},{"had_liked":false,"id":241029,"user_name":"美美","can_delete":false,"product_type":"c1","uid":1148422,"ip_address":"","ucode":"44CC95C45AF345","user_header":"https://static001.geekbang.org/account/avatar/00/11/86/06/72b01bb7.jpg","comment_is_top":false,"comment_ctime":1597155681,"is_pvip":false,"replies":[{"id":"89368","content":"很好啊，多保持交流。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1597626608,"ip_address":"","comment_id":241029,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1597155681","product_id":100037301,"comment_content":"我们公司目前就用的DDD，所以才能接触到DDD，哈哈","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503624,"discussion_content":"很好啊，多保持交流。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597626608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":233032,"user_name":"jun","can_delete":false,"product_type":"c1","uid":1899314,"ip_address":"","ucode":"3A9633CA1FE72E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/LalJD9ruYQI5zVM1GOCe4PjunIbbeeMiacFHC4TAj0DBVeialKt3vRCLs9dxn1vYXvfp8pgcyaeEQkh1nde1JoBQ/132","comment_is_top":false,"comment_ctime":1594197995,"is_pvip":false,"replies":[{"id":"86041","content":"挺好，迈出去就好，一点一点演进，结合公司情况选择合适的方法和技术体系。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1594262268,"ip_address":"","comment_id":233032,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1594197995","product_id":100037301,"comment_content":"我们现在还使用的是单体架构。想调整成为微服务模式，因为业务的发展导致系统已臃肿不堪，准备实际尝试尝试；","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500859,"discussion_content":"挺好，迈出去就好，一点一点演进，结合公司情况选择合适的方法和技术体系。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594262268,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":228422,"user_name":"李剑洪","can_delete":false,"product_type":"c1","uid":1348199,"ip_address":"","ucode":"F185531DBF9C4E","user_header":"https://static001.geekbang.org/account/avatar/00/14/92/67/a8c5cacf.jpg","comment_is_top":false,"comment_ctime":1592665563,"is_pvip":true,"replies":[{"id":"84656","content":"如果领域模型与数据模型之间的差异不大的话，为了降低对象转换带来的性能损失，在设计的时候，也可以考虑尽量减少对象之间的转换。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1592985623,"ip_address":"","comment_id":228422,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1592665563","product_id":100037301,"comment_content":"对于PO对象转DO实体，在有些情况下，PO对象将比较复杂，能不能直接让DO对象继承PO对象？或者持有PO对象的引用？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499029,"discussion_content":"如果领域模型与数据模型之间的差异不大的话，为了降低对象转换带来的性能损失，在设计的时候，也可以考虑尽量减少对象之间的转换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592985623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":191371,"user_name":"峰","can_delete":false,"product_type":"c1","uid":1390326,"ip_address":"","ucode":"527BB65559F0B0","user_header":"https://static001.geekbang.org/account/avatar/00/15/36/f6/d65b7302.jpg","comment_is_top":false,"comment_ctime":1584767118,"is_pvip":false,"replies":[{"id":"73376","content":"在一个工程里面，打包以后就是一个微服务。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1584769970,"ip_address":"","comment_id":191371,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1584767118","product_id":100037301,"comment_content":"图中代码模型实际中应该分成不同工程吧，只是为了演示而用目录体现的吗","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488161,"discussion_content":"在一个工程里面，打包以后就是一个微服务。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584769970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153510,"user_name":"张迪","can_delete":false,"product_type":"c1","uid":1104835,"ip_address":"","ucode":"6A5D44999A0FEA","user_header":"https://static001.geekbang.org/account/avatar/00/10/db/c3/e11adfe8.jpg","comment_is_top":false,"comment_ctime":1574250456,"is_pvip":false,"replies":[{"id":"59000","content":"应用层也可以拆的。但是应用层的服务如果跨聚合组合，先需要解耦，从微服务内调用改成跨微服务调用。然后将聚合封装出来的应用服务拆分。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574258725,"ip_address":"","comment_id":153510,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574250456","product_id":100037301,"comment_content":"那随着业务的快速发展，如果某一个微服务遇到了高性能挑战，需要将部分业务能力独立出去，我们就可以以聚合为单位，将聚合代码拆分独立为一个新的微服务。<br>领域层拆了，应用层怎么拆成两个？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475193,"discussion_content":"应用层也可以拆的。但是应用层的服务如果跨聚合组合，先需要解耦，从微服务内调用改成跨微服务调用。然后将聚合封装出来的应用服务拆分。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574258725,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152639,"user_name":"skyhackvip","can_delete":false,"product_type":"c1","uid":1083561,"ip_address":"","ucode":"05C7784736C97A","user_header":"https://static001.geekbang.org/account/avatar/00/10/88/a9/789fc9b0.jpg","comment_is_top":false,"comment_ctime":1574055105,"is_pvip":false,"replies":[{"id":"58668","content":"消息总线比较常见，这个专栏里就不讲了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574072952,"ip_address":"","comment_id":152639,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574055105","product_id":100037301,"comment_content":"消息总线是连接各位服务的关键吗？还是直接http或rpc就行？消息总线该如何设计呢？老师会讲讲这部分吗","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474882,"discussion_content":"消息总线比较常见，这个专栏里就不讲了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574072952,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}