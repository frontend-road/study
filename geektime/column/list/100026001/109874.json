{"id":109874,"title":"39 | MESI协议：如何让多核CPU的高速缓存保持一致？","content":"<p>你平时用的电脑，应该都是多核的CPU。多核CPU有很多好处，其中最重要的一个就是，它使得我们在不能提升CPU的主频之后，找到了另一种提升CPU吞吐率的办法。</p><p>不知道上一讲的内容你还记得多少？上一节，我们讲到，多核CPU里的每一个CPU核，都有独立的属于自己的L1 Cache和L2 Cache。多个CPU之间，只是共用L3 Cache和主内存。</p><p>我们说，CPU Cache解决的是内存访问速度和CPU的速度差距太大的问题。而多核CPU提供的是，在主频难以提升的时候，通过增加CPU核心来提升CPU的吞吐率的办法。我们把多核和CPU Cache两者一结合，就给我们带来了一个新的挑战。因为CPU的每个核各有各的缓存，互相之间的操作又是各自独立的，就会带来<a href=\"https://en.wikipedia.org/wiki/Cache_coherence\"><strong>缓存一致性</strong></a>（Cache Coherence）的问题。</p><p><img src=\"https://static001.geekbang.org/resource/image/07/41/0723f72f3016fede96b545e2898c0541.jpeg?wh=1546*1126\" alt=\"\"></p><h2>缓存一致性问题</h2><p>那什么是缓存一致性呢？我们拿一个有两个核心的CPU，来看一下。你可以看这里这张图，我们结合图来说。</p><p><img src=\"https://static001.geekbang.org/resource/image/a6/da/a6146ddd5c78f2cbc1af56b0ee3292da.jpeg?wh=2236*1066\" alt=\"\"></p><p>在这两个CPU核心里，1号核心要写一个数据到内存里。这个怎么理解呢？我拿一个例子来给你解释。</p><p>比方说，iPhone降价了，我们要把iPhone最新的价格更新到内存里。为了性能问题，它采用了上一讲我们说的写回策略，先把数据写入到L2 Cache里面，然后把Cache Block标记成脏的。这个时候，数据其实并没有被同步到L3 Cache或者主内存里。1号核心希望在这个Cache Block要被交换出去的时候，数据才写入到主内存里。</p><!-- [[[read_end]]] --><p>如果我们的CPU只有1号核心这一个CPU核，那这其实是没有问题的。不过，我们旁边还有一个2号核心呢！这个时候，2号核心尝试从内存里面去读取iPhone的价格，结果读到的是一个错误的价格。这是因为，iPhone的价格刚刚被1号核心更新过。但是这个更新的信息，只出现在1号核心的L2 Cache里，而没有出现在2号核心的L2 Cache或者主内存里面。<strong>这个问题，就是所谓的缓存一致性问题，1号核心和2号核心的缓存，在这个时候是不一致的。</strong></p><p>为了解决这个缓存不一致的问题，我们就需要有一种机制，来同步两个不同核心里面的缓存数据。那这样的机制需要满足什么条件呢？我觉得能够做到下面两点就是合理的。</p><p>第一点叫<strong>写传播</strong>（Write Propagation）。写传播是说，在一个CPU核心里，我们的Cache数据更新，必须能够传播到其他的对应节点的Cache Line里。</p><p>第二点叫<strong>事务的串行化</strong>（Transaction Serialization），事务串行化是说，我们在一个CPU核心里面的读取和写入，在其他的节点看起来，顺序是一样的。</p><p>第一点写传播很容易理解。既然我们数据写完了，自然要同步到其他CPU核的Cache里。但是第二点事务的串行化，可能没那么好理解，我这里仔细解释一下。</p><p>我们还拿刚才修改iPhone的价格来解释。这一次，我们找一个有4个核心的CPU。1号核心呢，先把iPhone的价格改成了5000块。差不多在同一个时间，2号核心把iPhone的价格改成了6000块。这里两个修改，都会传播到3号核心和4号核心。</p><p><img src=\"https://static001.geekbang.org/resource/image/fe/6c/fe0c449e71800c5ad2e4b84af0d6e46c.jpeg?wh=2236*2686\" alt=\"\"></p><p>然而这里有个问题，3号核心先收到了2号核心的写传播，再收到1号核心的写传播。所以3号核心看到的iPhone价格是先变成了6000块，再变成了5000块。而4号核心呢，是反过来的，先看到变成了5000块，再变成6000块。虽然写传播是做到了，但是各个Cache里面的数据，是不一致的。</p><p>事实上，我们需要的是，从1号到4号核心，都能看到相同顺序的数据变化。比如说，都是先变成了5000块，再变成了6000块。这样，我们才能称之为实现了事务的串行化。</p><p>事务的串行化，不仅仅是缓存一致性中所必须的。比如，我们平时所用到的系统当中，最需要保障事务串行化的就是数据库。多个不同的连接去访问数据库的时候，我们必须保障事务的串行化，做不到事务的串行化的数据库，根本没法作为可靠的商业数据库来使用。</p><p>而在CPU Cache里做到事务串行化，需要做到两点，第一点是一个CPU核心对于数据的操作，需要同步通信给到其他CPU核心。第二点是，如果两个CPU核心里有同一个数据的Cache，那么对于这个Cache数据的更新，需要有一个“锁”的概念。只有拿到了对应Cache Block的“锁”之后，才能进行对应的数据更新。接下来，我们就看看实现了这两个机制的MESI协议。</p><h2>总线嗅探机制和MESI协议</h2><p>要解决缓存一致性问题，首先要解决的是多个CPU核心之间的数据传播问题。最常见的一种解决方案呢，叫作<strong>总线嗅探</strong>（Bus Snooping）。这个名字听起来，你多半会很陌生，但是其实特很好理解。</p><p>这个策略，本质上就是把所有的读写请求都通过总线（Bus）广播给所有的CPU核心，然后让各个核心去“嗅探”这些请求，再根据本地的情况进行响应。</p><p>总线本身就是一个特别适合广播进行数据传输的机制，所以总线嗅探这个办法也是我们日常使用的Intel CPU进行缓存一致性处理的解决方案。关于总线这个知识点，我们会放在后面的I/O部分更深入地进行讲解，这里你只需要了解就可以了。</p><p>基于总线嗅探机制，其实还可以分成很多种不同的缓存一致性协议。不过其中最常用的，就是今天我们要讲的MESI协议。和很多现代的CPU技术一样，MESI协议也是在Pentium时代，被引入到Intel CPU中的。</p><p>MESI协议，是一种叫作<strong>写失效</strong>（Write Invalidate）的协议。在写失效协议里，只有一个CPU核心负责写入数据，其他的核心，只是同步读取到这个写入。在这个CPU核心写入Cache之后，它会去广播一个“失效”请求告诉所有其他的CPU核心。其他的CPU核心，只是去判断自己是否也有一个“失效”版本的Cache Block，然后把这个也标记成失效的就好了。</p><p>相对于写失效协议，还有一种叫作<strong>写广播</strong>（Write Broadcast）的协议。在那个协议里，一个写入请求广播到所有的CPU核心，同时更新各个核心里的Cache。</p><p>写广播在实现上自然很简单，但是写广播需要占用更多的总线带宽。写失效只需要告诉其他的CPU核心，哪一个内存地址的缓存失效了，但是写广播还需要把对应的数据传输给其他CPU核心。</p><p><img src=\"https://static001.geekbang.org/resource/image/4e/59/4ed6d05049cbbc8603346f617206cd59.jpeg?wh=1762*3526\" alt=\"\"></p><p>MESI协议的由来呢，来自于我们对Cache Line的四个不同的标记，分别是：</p><ul>\n<li>M：代表已修改（Modified）</li>\n<li>E：代表独占（Exclusive）</li>\n<li>S：代表共享（Shared）</li>\n<li>I：代表已失效（Invalidated）</li>\n</ul><p>我们先来看看“已修改”和“已失效”，这两个状态比较容易理解。所谓的“已修改”，就是我们上一讲所说的“脏”的Cache Block。Cache Block里面的内容我们已经更新过了，但是还没有写回到主内存里面。而所谓的“已失效“，自然是这个Cache Block里面的数据已经失效了，我们不可以相信这个Cache Block里面的数据。</p><p>然后，我们再来看“独占”和“共享”这两个状态。这就是MESI协议的精华所在了。无论是独占状态还是共享状态，缓存里面的数据都是“干净”的。这个“干净”，自然对应的是前面所说的“脏”的，也就是说，这个时候，Cache Block里面的数据和主内存里面的数据是一致的。</p><p>那么“独占”和“共享”这两个状态的差别在哪里呢？这个差别就在于，在独占状态下，对应的Cache Line只加载到了当前CPU核所拥有的Cache里。其他的CPU核，并没有加载对应的数据到自己的Cache里。这个时候，如果要向独占的Cache Block写入数据，我们可以自由地写入数据，而不需要告知其他CPU核。</p><p>在独占状态下的数据，如果收到了一个来自于总线的读取对应缓存的请求，它就会变成共享状态。这个共享状态是因为，这个时候，另外一个CPU核心，也把对应的Cache Block，从内存里面加载到了自己的Cache里来。</p><p>而在共享状态下，因为同样的数据在多个CPU核心的Cache里都有。所以，当我们想要更新Cache里面的数据的时候，不能直接修改，而是要先向所有的其他CPU核心广播一个请求，要求先把其他CPU核心里面的Cache，都变成无效的状态，然后再更新当前Cache里面的数据。这个广播操作，一般叫作RFO（Request For Ownership），也就是获取当前对应Cache Block数据的所有权。</p><p>有没有觉得这个操作有点儿像我们在多线程里面用到的读写锁。在共享状态下，大家都可以并行去读对应的数据。但是如果要写，我们就需要通过一个锁，获取当前写入位置的所有权。</p><p>整个MESI的状态，可以用一个有限状态机来表示它的状态流转。需要注意的是，对于不同状态触发的事件操作，可能来自于当前CPU核心，也可能来自总线里其他CPU核心广播出来的信号。我把对应的状态机流转图放在了下面，你可以对照着<a href=\"https://zh.wikipedia.org/wiki/MESI%E5%8D%8F%E8%AE%AE\">Wikipedia里面MESI的内容</a>，仔细研读一下。</p><p><img src=\"https://static001.geekbang.org/resource/image/fa/d1/fa98835c78c879ab69fd1f29193e54d1.jpeg?wh=2296*2068\" alt=\"\"></p><center><a href=\"https://commons.wikimedia.org/wiki/File:Diagrama_MESI.GIF\">图片来源</a></center><h2>总结延伸</h2><p>好了，关于CPU Cache的内容，我们介绍到这里就结束了。我们来总结一下。这一节，我们其实就讲了两块儿内容，一个是缓存一致性，另一个是MESI协议。</p><p>想要实现缓存一致性，关键是要满足两点。第一个是写传播，也就是在一个CPU核心写入的内容，需要传播到其他CPU核心里。更重要的是第二点，保障事务的串行化，才能保障我们的数据是真正一致的，我们的程序在各个不同的核心上运行的结果也是一致的。这个特性不仅在CPU的缓存层面很重要，在数据库层面更加重要。</p><p>之后，我介绍了基于总线嗅探机制的MESI协议。MESI协议是一种基于写失效的缓存一致性协议。写失效的协议的好处是，我们不需要在总线上传输数据内容，而只需要传输操作信号和地址信号就好了，不会那么占总线带宽。</p><p>MESI协议，是已修改、独占、共享以及已失效这四个缩写的合称。独占和共享状态，就好像我们在多线程应用开发里面的读写锁机制，确保了我们的缓存一致性。而整个MESI的状态变更，则是根据来自自己CPU核心的请求，以及来自其他CPU核心通过总线传输过来的操作信号和地址信息，进行状态流转的一个有限状态机。</p><h2>推荐阅读</h2><p>大部分计算机组成或者体系结构的教科书都没有提到缓存一致性问题。不过，最近有一本国人写的计算机底层原理的书，《大话计算机》，里面的6.9章节比较详细地讲解了多核CPU的访问存储数据的一致性问题，很值得仔细读一读。</p><h2>课后思考</h2><p>今天我们所讲的MESI缓存一致性协议，其实是对于MSI缓存一致性协议的一个优化。你可以通过搜索引擎研究一下，什么是MSI协议，以及MESI相对于MSI协议，究竟做了哪些优化？</p><p>欢迎把你研究的结果写在留言区和大家分享。如果有收获，也欢迎你把这篇文章分享给你的朋友，和他一起学习和进步。</p><p></p>","comments":[{"had_liked":false,"id":117693,"user_name":"炎发灼眼","can_delete":false,"product_type":"c1","uid":1425953,"ip_address":"","ucode":"7D195057C8E94C","user_header":"https://static001.geekbang.org/account/avatar/00/15/c2/21/a8ef82ac.jpg","comment_is_top":false,"comment_ctime":1564112742,"is_pvip":false,"discussion_count":20,"race_medal":0,"score":"194837641062","product_id":100026001,"comment_content":"老师，有个问题，如果说一个核心更新了数据，广播失效操作和地址，其他核心的缓存被更新为失效，那更新数据的那个核心什么时候把数据再次写入内存呢，按照上一讲，在下次更新数据的时候才会写入，那如果在这个之间，别的核心需要用到这部分数据，看到失效，还是从内存读，这不是还是读不到最新的数据么。","like_count":45,"discussions":[{"author":{"id":1122034,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1e/f2/453d5f88.jpg","nickname":"seker","note":"","ucode":"9B705F91355873","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296325,"discussion_content":"   &#34;那如果在这个之间，别的核心需要用到这部分数据，看到失效，还是从内存读，这不是还是读不到最新的数据么。&#34;\n\n   假设CPU A的Cache Line被标记为M，CPU B的Cache Line被标记为I。\n   此时CPU B需要读取这部分数据，由于Cache Line被标记为I，因此不满足读请求，便通过总线进行广播。\n   这个时候CPU A收到来自总线读(remote read)的请求，其Cache Line状态由M->S，并将数据更新进内存。\n   由于内存中数据已更新为最新，因此CPU B可以将内存中的数据加载到Cache Line中，以满足本地的读请求(local read)，并将Cache Line状态由I->S\n\n   上面说到，CPU B的Cache Line由I->S，那为什么不是I->E呢？\n   因为此时CPU A和CPU B两个Cache Lin中的数据是一致的，即两份一模一样的数据，不存在谁的数据是独一份的，因此不是I->E，而是I->S。","likes_number":66,"is_delete":false,"is_hidden":false,"ctime":1596511224,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1210035,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqdsd8qbkOFkcKQO0EZzg3p7yEw6cGl47zJzGl12jHQgMUnKpMWib0ZnibRH4LZPYqhfkWH0oYt31mQ/132","nickname":"雷雷","note":"","ucode":"648204DABB1AD5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1122034,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1e/f2/453d5f88.jpg","nickname":"seker","note":"","ucode":"9B705F91355873","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":586160,"discussion_content":"上面说到，CPU B的Cache Line由I-&gt;S，那为什么不是I-&gt;E呢？\n   因为此时CPU A和CPU B两个Cache Lin中的数据是一致的，即两份一模一样的数据，不存在谁的数据是独一份的，因此不是I-&gt;E，而是I-&gt;S。\n-----------\n这里解释不够好，因该说是CPU B的不能确定此Cache line的数据其他Cpu有没有，所以只能够I-&gt;S","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662012665,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":296325,"ip_address":"北京"},"score":586160,"extra":""}]},{"author":{"id":1645302,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1a/f6/19e67bea.jpg","nickname":"モブ","note":"","ucode":"01BE64E20DEF7C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":256503,"discussion_content":"别的CPU要读这个BLOCK数据的话，由于当前处于无效态，会向总线发送总线读的命令，其他CPU看到了会检查自己有没有有效的数据，如果有某个CPU有，那么就转为共享态，并接受那个CPU发来的数据，如果没有，则从内存中取得，并且转为独享态。\n别的CPU要写这个BLOCK数据的话，由于当前处于无效态，会向总线发送总线写的命令，转为修改态，其他CPU看到了会检查自己有没有有效的数据，如果有某个CPU有，那么，并接受那个CPU发来的数据，如果没有，则从内存中取得，最后把修改写入缓存。\n\n建议看看wiki的说明","likes_number":19,"is_delete":false,"is_hidden":false,"ctime":1588488347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1340457,"avatar":"","nickname":"茶余饭后","note":"","ucode":"754E921BF07C93","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8553,"discussion_content":"明白了，其实在CPU B要读取数据的时候，CPU A就会把自己为M状态的数据同步到主内存，然后置为E，文中也说了，E状态的缓存和主内存是一样的。\n\n关键是并不是只有下一次读取脏缓存块的时候才同步到主内存，而是其他CPU 请求这个数据的时候它也会同步","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1568016711,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111222,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f4/b6/ae7dc1e2.jpg","nickname":"余垚澈","note":"","ucode":"A451487F69451F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5385,"discussion_content":"我记得是其他cpu要读取数据的时候会触发修改了数据的cpu把修改了的数据页写回主存","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1566217183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1310798,"avatar":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","nickname":"吴小智","note":"","ucode":"C7C9F58B5C9F7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41360,"discussion_content":"是个好问题。那为什么还需要 volatile 关键字呢？","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1572407505,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121593,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/39/1be8b56c.jpg","nickname":"snzhaoch","note":"","ucode":"033111124D15DC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7267,"discussion_content":"看到一篇不错的文章 https://blog.csdn.net/muxiqingyang/article/details/6615199","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1567441651,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1260141,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3a/6d/910b2445.jpg","nickname":"Wheat","note":"","ucode":"7D99EA149B6DE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343935,"discussion_content":"其他CPU核心不会先从内存读数据，而是先通过总线发出“总线读”，对于改Cache的当前CPU来说，“总线读”也是上一讲的“读请求”","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1611213796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1405020,"avatar":"https://static001.geekbang.org/account/avatar/00/15/70/5c/ebb274eb.jpg","nickname":"板栗饼","note":"","ucode":"2DA25B053D7721","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263555,"discussion_content":"理解下来，修改过的CPU核心从总线获取到其他核心的read命令时，也会将修改过的数据写回内存，这样其他失效核心从内存读取到的就是最新的数据了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589211445,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645302,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1a/f6/19e67bea.jpg","nickname":"モブ","note":"","ucode":"01BE64E20DEF7C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":256509,"discussion_content":"补充一下，按照Wiki的说明，在有修改态想其他状态转换时候会回写内存","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588489143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1795371,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/65/2b/446ef7b6.jpg","nickname":"许先森","note":"","ucode":"1F42D4A6B5C6AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":141377,"discussion_content":"你的问题：“如果说一个核心更新了数据，广播失效操作和地址，其他核心的缓存被更新为失效，那更新数据的那个核心什么时候把数据再次写入内存呢”\n答：一个核心更新了数据，那么变成M状态；根据文中最后的图可以看出，当有读取请求，即总线发出读信号，此时从M变成了S，当然可以被别的核心读取了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1579417000,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1243901,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fa/fd/ec24cba7.jpg","nickname":"fcb的鱼","note":"","ucode":"88667EBF09CEC0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1795371,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/65/2b/446ef7b6.jpg","nickname":"许先森","note":"","ucode":"1F42D4A6B5C6AF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":162645,"discussion_content":"每个核心只能读取自己的数据吧，这个数据什么时候刷新到了内存的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581000596,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":141377,"ip_address":""},"score":162645,"extra":""},{"author":{"id":1145624,"avatar":"https://static001.geekbang.org/account/avatar/00/11/7b/18/6e44e6e0.jpg","nickname":"恺撒之剑","note":"","ucode":"18F55D253647E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1243901,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fa/fd/ec24cba7.jpg","nickname":"fcb的鱼","note":"","ucode":"88667EBF09CEC0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":203315,"discussion_content":"比如核心B需要取缓存数据且状态为I，此时核心A为M状态，则强制更新A的数据到内存，核心B再从内存里取最新的数据。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1584022745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":162645,"ip_address":""},"score":203315,"extra":""}]},{"author":{"id":1621793,"avatar":"https://static001.geekbang.org/account/avatar/00/18/bf/21/44eb3aee.jpg","nickname":"Hou","note":"","ucode":"92BF011EF961B4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":31778,"discussion_content":"修改了就会立即同步到内存，由于其他核心对应的Cache line已经失效所以其他核心要用时会去内存中读取","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1570955475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1243901,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fa/fd/ec24cba7.jpg","nickname":"fcb的鱼","note":"","ucode":"88667EBF09CEC0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1621793,"avatar":"https://static001.geekbang.org/account/avatar/00/18/bf/21/44eb3aee.jpg","nickname":"Hou","note":"","ucode":"92BF011EF961B4","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":162634,"discussion_content":"上一讲里边并不是立即同步到内存的，而是在下次更新的时候才会同步到内存的吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581000211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":31778,"ip_address":""},"score":162634,"extra":""},{"author":{"id":1645302,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1a/f6/19e67bea.jpg","nickname":"モブ","note":"","ucode":"01BE64E20DEF7C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1243901,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fa/fd/ec24cba7.jpg","nickname":"fcb的鱼","note":"","ucode":"88667EBF09CEC0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":256514,"discussion_content":"当处于Modify状态下，收到总线读的指令，将状态转为Shared，同时将缓存内容发送给指令发送方，并且写回内存。 收到总线写的指令，将状态转为Invalid，同时将缓冲内容发送给指令发送方，并且写回内存。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588489303,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":162634,"ip_address":""},"score":256514,"extra":""}]},{"author":{"id":1145624,"avatar":"https://static001.geekbang.org/account/avatar/00/11/7b/18/6e44e6e0.jpg","nickname":"恺撒之剑","note":"","ucode":"18F55D253647E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":203306,"discussion_content":"渣哥，突然看到你的留言🤗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584022249,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1362838,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqZbpP8Of9zVbZnPDMnXnZH2Zft5F1Ip8ybicIY9BhSlaO37TCbYtCq89IO8iasXowia9PrPRLibdEQ1g/132","nickname":"Dashing","note":"","ucode":"07E3F934782BCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4477,"discussion_content":"手残，接上。及L2里的cache标记为失效。在别的核心要查的时候，看到自己的cache失效，会把L3的新数据重新加载，就没有问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565452016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1362838,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqZbpP8Of9zVbZnPDMnXnZH2Zft5F1Ip8ybicIY9BhSlaO37TCbYtCq89IO8iasXowia9PrPRLibdEQ1g/132","nickname":"Dashing","note":"","ucode":"07E3F934782BCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4476,"discussion_content":"感觉是这样的。由于这个数据在L1 里，所以肯定在L2及L3cache里。一个写操作，会把自己L1及L2标记为M，同时也会把L3里的数据修改。然后把别的核心的L1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565451911,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1362838,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqZbpP8Of9zVbZnPDMnXnZH2Zft5F1Ip8ybicIY9BhSlaO37TCbYtCq89IO8iasXowia9PrPRLibdEQ1g/132","nickname":"Dashing","note":"","ucode":"07E3F934782BCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4475,"discussion_content":"我也在想这个问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565450292,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":116795,"user_name":"林三杠","can_delete":false,"product_type":"c1","uid":1012832,"ip_address":"","ucode":"E667F986D07DC6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/74/60/0403b575.jpg","comment_is_top":false,"comment_ctime":1563927438,"is_pvip":true,"discussion_count":3,"race_medal":0,"score":"108938109838","product_id":100026001,"comment_content":"涉及到数据一致性的问题，cpu层，单机多线程内存层，分布式系统多台机器层，处理办法都差不多，原理是相通的","like_count":25,"discussions":[{"author":{"id":1441830,"avatar":"https://static001.geekbang.org/account/avatar/00/16/00/26/a80010f0.jpg","nickname":"JL","note":"","ucode":"07BD8069AE2CBD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":240062,"discussion_content":"最近看陈皓的博客，他多次在文章里强调这些基础的重要性，搞明白 吃透了，有时候就能举一反三，触类旁通。系统设计里很多想法就可以借鉴CPU OS里面的知识和想法。","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1587328071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1855112,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIYj6Zv3ibicLebxo7lsPMEwpBynHkYp8pLc3FcltUfmOBSRxpmicEwIAgP9OvSKnGGdaxwsZ7yiciaSsQ/132","nickname":"冯磊","note":"","ucode":"4FFB8B984269FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375725,"discussion_content":"哪里有博客，能发下地址吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621832238,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1245468,"avatar":"https://static001.geekbang.org/account/avatar/00/13/01/1c/d638d46e.jpg","nickname":"宋世通","note":"","ucode":"C7AA3F0E6930F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1855112,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIYj6Zv3ibicLebxo7lsPMEwpBynHkYp8pLc3FcltUfmOBSRxpmicEwIAgP9OvSKnGGdaxwsZ7yiciaSsQ/132","nickname":"冯磊","note":"","ucode":"4FFB8B984269FB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558940,"discussion_content":"酷壳https://coolshell.cn/","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648524555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":375725,"ip_address":""},"score":558940,"extra":""}]}]},{"had_liked":false,"id":168866,"user_name":"山间竹","can_delete":false,"product_type":"c1","uid":1696212,"ip_address":"","ucode":"FA7F16EF01D659","user_header":"https://static001.geekbang.org/account/avatar/00/19/e1/d4/1b5ac51e.jpg","comment_is_top":false,"comment_ctime":1578205772,"is_pvip":false,"replies":[{"id":"68105","content":"山间竹同学，<br><br>是的，JVM本质上是个抽象的“计算机硬件”，所以volatile对于JVM维护语义是有意义的，","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1580635663,"ip_address":"","comment_id":168866,"utype":1}],"discussion_count":5,"race_medal":0,"score":"74592649804","product_id":100026001,"comment_content":"既然有了MESI协议，是不是就不需要volatile的可见性语义了？当然不是，还有三个问题：<br><br>并不是所有的硬件架构都提供了相同的一致性保证，JVM需要volatile统一语义（就算是MESI，也只解决CPU缓存层面的问题，没有涉及其他层面）。<br>可见性问题不仅仅局限于CPU缓存内，JVM自己维护的内存模型中也有可见性问题。使用volatile做标记，可以解决JVM层面的可见性问题。<br>如果不考虑真·重排序，MESI确实解决了CPU缓存层面的可见性问题；然而，真·重排序也会导致可见性问题。","like_count":17,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480358,"discussion_content":"山间竹同学，\n\n是的，JVM本质上是个抽象的“计算机硬件”，所以volatile对于JVM维护语义是有意义的，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580635663,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1299763,"avatar":"https://static001.geekbang.org/account/avatar/00/13/d5/33/d79fae5c.jpg","nickname":"Hommin","note":"","ucode":"C020CA5DE785DB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":201757,"discussion_content":"为了提升效率，会将代码重新排序。比如：a=a+1;b=b+1;a=a+1;就会重新排序，这样排序后的代码执行起来效率更高，但会导致可见性问题。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583834814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1246450,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/11gKZk9TQkeQ1QqtibtFib9P9gsqUUHIzyw2sVFZoxy4de2LG2uHibI1LpptCg8rhbYicvbgSs9uATgzoAvJdXso1A/132","nickname":"蒋珊珊","note":"","ucode":"015BF8EC4B64B7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":182545,"discussion_content":"请问下真重排序是什么场景？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582433599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1434066,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e1/d2/42ad2c87.jpg","nickname":"今夜秋风和","note":"","ucode":"453C8197FFC81D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1246450,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/11gKZk9TQkeQ1QqtibtFib9P9gsqUUHIzyw2sVFZoxy4de2LG2uHibI1LpptCg8rhbYicvbgSs9uATgzoAvJdXso1A/132","nickname":"蒋珊珊","note":"","ucode":"015BF8EC4B64B7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342388,"discussion_content":"编译器为了提高效率，将一些前后没有关系的指令放在一起，便于利用流水线并行的特性，重排序编译器层面，cpu层面都会对指令进行操作，目的还是提高指令的执行效率","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1610671294,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":182545,"ip_address":""},"score":342388,"extra":""}]},{"author":{"id":1177602,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f8/02/a02d127d.jpg","nickname":"Treasure","note":"","ucode":"4211ECEB347C3D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310253,"discussion_content":"啥叫真 排序啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601713583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119335,"user_name":"bro.","can_delete":false,"product_type":"c1","uid":1124948,"ip_address":"","ucode":"D65283CD869804","user_header":"https://static001.geekbang.org/account/avatar/00/11/2a/54/c9990105.jpg","comment_is_top":false,"comment_ctime":1564564375,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"74579008407","product_id":100026001,"comment_content":"Java中volatile变量修饰的共享变量在进行写操作时候会多出一行汇编**<br>    ```<br>    0x01a3de1d:movb $0×0，0×1104800（%esi）;0x01a3de24:lock addl $0×0,(%esp);<br>    ```<br>lock前缀的指令在多核处理器下会:<br>        1. 将当前处理器缓存行的数据写回到系统内存<br>        2. 这个写回内存的操作会使其他CPU里缓存了改内存地址的数据无效<br>多处理器总线嗅探:<br>        1. 为了提高处理速度,处理器不直接和内存进行通信,而是先将系统内存的数据读到内部缓存后在进行操作,但**写回操作**不知道这个更改何时回写到内存<br>        2. 但是对变量使用volatile进行写操作时,JVM就会向处理器发送一条lock前缀的指令,将这个变量所在的缓存行的数据写回到系统内存<br>        3. 在多处理器中,为了保证各个处理器的缓存一致性,每个处理器通过嗅探在总线上传播的数据来检查自己的缓存值是不是过期了,如果处理器发现自己缓存行对应的内存地址被修改,就会将当前处理器的缓存行设置为无效状态,就相当于**写回时发现状态标识为0失效**,当这个处理器对数据进行修改操作时,会重新从系统内存中读取数据到CPU缓存中","like_count":17,"discussions":[{"author":{"id":1291193,"avatar":"https://static001.geekbang.org/account/avatar/00/13/b3/b9/15bc110a.jpg","nickname":"Geek_8def05","note":"","ucode":"5C8110716CE483","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":354380,"discussion_content":"通过插入lock指令 从而实现内存屏障 达到了避免指令重排序的同时 达到了缓存一致性的效果","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615283769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":116981,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1563950971,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"65988460411","product_id":100026001,"comment_content":"MSI 缓存一致性协议没有E这个状态，也就是没有独享的状态。<br>如果块尚未被装入缓存(处于“I”状态)，则在装入该块之前，必须先要保证该地址的数据不会在其他缓存的缓存块中处于“M”状态。如果另一个缓存中有处于“M”状态的块，则它必须将数据写回后备存储，并回到“S”状态。<br>MESI 多了E状态（独享状态），如果当前写入的是E，则可直接写入，提高了性能。","like_count":15},{"had_liked":false,"id":183826,"user_name":"。。。","can_delete":false,"product_type":"c1","uid":1267092,"ip_address":"","ucode":"F4D90A500B66D3","user_header":"https://static001.geekbang.org/account/avatar/00/13/55/94/cefb8a05.jpg","comment_is_top":false,"comment_ctime":1583141632,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31647912704","product_id":100026001,"comment_content":"老师我想问下：mesi默认一直运行的， 还是说加了lock才会采用锁总线或者msei协议","like_count":7},{"had_liked":false,"id":225928,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":false,"comment_ctime":1591893687,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"18771762871","product_id":100026001,"comment_content":"MESI 协议对于“锁”的实现是机制是RFO（Request For Ownership），也就是获取当前对应 Cache Block 数据的所有权吗？ 如果是的话，多核cpu下，同时RFO会发生死锁呀，还有你RFO结束后，还没有执行完指令去更新缓存行，但是别的cpu又发起RFO了，此时感觉还是不安全的呀？是不是我理解的不对？期望老师和大神帮忙解答下，🙏","like_count":4,"discussions":[{"author":{"id":1303914,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e5/6a/3c618346.jpg","nickname":"二桃杀三士","note":"","ucode":"5D7CAB540B0DF3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350230,"discussion_content":"会总线裁决选一个 cpu 执行的。\nhttps://zhuanlan.zhihu.com/p/24146167\nhttps://yemablog.com/posts/cache-locking\nhttps://yemablog.com/posts/cache-locking-2","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1613756223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143651,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1571752289,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"18751621473","product_id":100026001,"comment_content":"我编译了volatile相关的代码，在Win10 64位下，将java代码转换成字节码，再转换成机器码，发现是由lock cmpxchg两个指令实现的。 ","like_count":4,"discussions":[{"author":{"id":1100717,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eq65BWyJb39rq0Qgx1fnELVSZGGuLY6oBmYcmFj2Oqy9iauAWfbqO5U63I22Uo1POrrTp7tFWXibxvg/132","nickname":"zyl","note":"","ucode":"2F872341AC8D7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":249920,"discussion_content":"Cas也是使用这个指令来保证原子写","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587975233,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1100717,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eq65BWyJb39rq0Qgx1fnELVSZGGuLY6oBmYcmFj2Oqy9iauAWfbqO5U63I22Uo1POrrTp7tFWXibxvg/132","nickname":"zyl","note":"","ucode":"2F872341AC8D7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":249919,"discussion_content":"这个是不是为了保证32位虚拟机 long和double的赋值原子性操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587975198,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176245,"user_name":"fcb的鱼","can_delete":false,"product_type":"c1","uid":1243901,"ip_address":"","ucode":"88667EBF09CEC0","user_header":"https://static001.geekbang.org/account/avatar/00/12/fa/fd/ec24cba7.jpg","comment_is_top":false,"comment_ctime":1581000284,"is_pvip":false,"replies":[{"id":"68637","content":"fcb的鱼同学，<br><br>你好，这个是由“协议”来保证的。也就是其他CPU，在收到特定的广播消息，必须做什么样的特定操作。<br>只要“协议”是正确的，其他CPU操作之后的特定结果就会一致。那么，这个协议就是我们这里的MESI协议，你可以对照着下面的状态流转图看一下。<br><br>如果你问的是CPU在硬件层面，是否一个操作必定执行成功（好比你让程序算 1+1 = 2 是不是会算错），那这个是要在硬件的电路层面来保证的。在一个分层的软硬件体系下，这个不是MESI协议需要考虑的时间。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1581221336,"ip_address":"","comment_id":176245,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14465902172","product_id":100026001,"comment_content":"老师好，问下：在多核cpu里边,某个cpu更新了数据，再去广播其他cpu。怎么保证其他cpu一定是操作成功的呢？","like_count":3,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483064,"discussion_content":"fcb的鱼同学，\n\n你好，这个是由“协议”来保证的。也就是其他CPU，在收到特定的广播消息，必须做什么样的特定操作。\n只要“协议”是正确的，其他CPU操作之后的特定结果就会一致。那么，这个协议就是我们这里的MESI协议，你可以对照着下面的状态流转图看一下。\n\n如果你问的是CPU在硬件层面，是否一个操作必定执行成功（好比你让程序算 1+1 = 2 是不是会算错），那这个是要在硬件的电路层面来保证的。在一个分层的软硬件体系下，这个不是MESI协议需要考虑的时间。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581221336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":282217,"user_name":"慎独明强","can_delete":false,"product_type":"c1","uid":1965699,"ip_address":"","ucode":"DC2F7F2C0C8F60","user_header":"https://static001.geekbang.org/account/avatar/00/1d/fe/83/df562574.jpg","comment_is_top":false,"comment_ctime":1615163053,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10205097645","product_id":100026001,"comment_content":"对于MESI协议，当对一个值进行修改时，会需要通过总线广播给其他核，这个时候是需要进行等待其他核响应，这里会有性能的差异吧。记得看过一些资料，有通过写寄存器和无效队列来进行优化，但是优化又会出现可见性和有序问题。最后底层是通过内存屏障来解决加入写寄存器和无效队列的可见性和有序性问题，希望老师能讲下这块","like_count":2},{"had_liked":false,"id":264765,"user_name":"LearnAndTry","can_delete":false,"product_type":"c1","uid":1512860,"ip_address":"","ucode":"0ECF4398C870DC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Rr8ABLicfgJHZ3xs3bXNjHdicwVN0zBiaFtIEXw4D1licedSuia3zicxJC4lqtrNwPmCeAW5UR2Ugia0dNfcvtXYnpOwQ/132","comment_is_top":false,"comment_ctime":1606638321,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10196572913","product_id":100026001,"comment_content":"看到了另一篇讲的不错的文章https:&#47;&#47;blog.csdn.net&#47;reliveIT&#47;article&#47;details&#47;50450136","like_count":2},{"had_liked":false,"id":126430,"user_name":"活的潇洒","can_delete":false,"product_type":"c1","uid":1238830,"ip_address":"","ucode":"666C30CA894754","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/2e/1522a7d6.jpg","comment_is_top":false,"comment_ctime":1566386314,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10156320906","product_id":100026001,"comment_content":"1、有人成功，有人普通，到底是什么原因导致的？<br><br>我们想成功，我们个人的水平必须是足够高的<br><br>2、那么我们的水平高来源于哪里？<br><br>来源于我们获得的知识，生活中每一天工作、上班、路上、回家获取的信息<br><br>day39 笔记：https:&#47;&#47;www.cnblogs.com&#47;luoahong&#47;p&#47;11358997.html","like_count":2},{"had_liked":false,"id":117349,"user_name":"W.jyao","can_delete":false,"product_type":"c1","uid":1422582,"ip_address":"","ucode":"C57B3A78B6A795","user_header":"https://static001.geekbang.org/account/avatar/00/15/b4/f6/735673f7.jpg","comment_is_top":false,"comment_ctime":1564027825,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"10153962417","product_id":100026001,"comment_content":"没明白，其他cpu收到写失效之后把自己的cache置位失效状态，然后还做其他什么处理吗？","like_count":2,"discussions":[{"author":{"id":1340457,"avatar":"","nickname":"茶余饭后","note":"","ucode":"754E921BF07C93","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8529,"discussion_content":"同样疑惑，在一个cpu核心写入之后，数据并没有及时同步到主内存，其他核心中接收到失效信息后，还不是同样需要这个写入核心广播新数据到其他核心吗，这跟写广播有什么区别","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568015041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1965699,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/fe/83/df562574.jpg","nickname":"慎独明强","note":"","ucode":"DC2F7F2C0C8F60","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":353361,"discussion_content":"有区别啊，当读取到数据为失效状态，那么就必须通过总线重新读取其他核或主内存的最新值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615163156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1396945,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epaH1gHotWQukHnF2QtT2oK9hGvyLfSaKSzuC9XKH5aSWZj2KNrxYGJeNeVzIeAibzypibsmeicppGvA/132","nickname":"魂斗罗丶","note":"","ucode":"6BEA5CD3CCC2B7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304993,"discussion_content":"https://www.pianshen.com/article/5195985188/ 这个看一下会帮助理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599734659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295950,"user_name":"thomas","can_delete":false,"product_type":"c1","uid":1016777,"ip_address":"","ucode":"9AB945308F1B50","user_header":"https://static001.geekbang.org/account/avatar/00/0f/83/c9/5d03981a.jpg","comment_is_top":false,"comment_ctime":1622681491,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5917648787","product_id":100026001,"comment_content":"MESI的状态是在cache blockd的哪里做标识？ 是否是脏数据，是通过有效位来标识的吗？","like_count":1},{"had_liked":false,"id":279405,"user_name":"二桃杀三士","can_delete":false,"product_type":"c1","uid":1303914,"ip_address":"","ucode":"5D7CAB540B0DF3","user_header":"https://static001.geekbang.org/account/avatar/00/13/e5/6a/3c618346.jpg","comment_is_top":false,"comment_ctime":1613753240,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5908720536","product_id":100026001,"comment_content":"老师你好，有个疑问。<br>修改数据之前：<br>    RFO 的目的是要先获得要修改的 cache block 的所有权，那就要先发出无效化指令来无效化其他核对应的这个 cache line，其他核再发出无效化确认。<br><br>修改数据之后：写失效协议要去广播一个“失效”请求告诉所有其他的 CPU 核心。其他的 CPU 核心，只是去判断自己是否也有一个“失效”版本的 Cache Block，然后把这个也标记成失效的就好了。<br><br><br>疑问 1：修改数据之前已经无效化其他核的 cache 了，当前 CPU 已经获得所有权了，为什么修改数据之后还要再次无效化其他核呢？岂不是多此一举了。     <br><br>当前 CPU 的这个 cache 状态是 M&#47;E 都不需要发出无效化指令，说明当前 CPU 已经拥有了相应数据的所有权，直接修改就完事了；当前 CPU cache 状态为 S 才需要无效化其他核对应的 cache 并接收无效化确认指令。<br><br><br>疑问 2：难道写失效协议是应用在 CPU 获取 cache 所有权时发出的无效化指令吗？但和文中描述的又有差异，写失效就是使用在修改数据之后发出的，而获取 cache 所有权却是在修改数据之前发生的。<br><br><br>疑问 3：《Java 并发编程的艺术》P9 上说<br><br>“在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一 致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。”<br><br>这里又说明了修改数据之后，回写到主存，处理器嗅探到了总线上传播的数据，就会无效化其 cache。这里的无效化又是否与写失效协议相关？为什么这里又来一次无效化呢？按我的理解，获得 cache 所有权的时候一次无效化就足够了的。不是很明白。","like_count":1,"discussions":[{"author":{"id":1303914,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e5/6a/3c618346.jpg","nickname":"二桃杀三士","note":"","ucode":"5D7CAB540B0DF3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350886,"discussion_content":"明白了，写了篇文章。https://juejin.cn/post/6932347103214518286/","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1614064704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1628434,"avatar":"https://static001.geekbang.org/account/avatar/00/18/d9/12/71db1407.jpg","nickname":"L","note":"","ucode":"A5CB3F1B4975BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541047,"discussion_content":"chayan","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640241489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167703,"user_name":"劳码识途","can_delete":false,"product_type":"c1","uid":1598564,"ip_address":"","ucode":"7AEF4D9407F097","user_header":"https://static001.geekbang.org/account/avatar/00/18/64/64/865c1eb4.jpg","comment_is_top":false,"comment_ctime":1577899148,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5872866444","product_id":100026001,"comment_content":"我了解mesif和moesi多一些，但是大体思想都是在进行源头cc流量的过滤，有一个问题我一直没有想明白，如果存在两个核心上两个s态的缓存行同时被进行了写操作，这时候会出现数据丢失吗？","like_count":1,"discussions":[{"author":{"id":2413071,"avatar":"https://static001.geekbang.org/account/avatar/00/24/d2/0f/8f14c85b.jpg","nickname":"红薯板栗","note":"","ucode":"236BE91291A575","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351097,"discussion_content":"文中提到，只有一个cpu写，其他CPU接收写传播。写的时候通过加锁获取所有cache的操作权。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614153183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1512462,"avatar":"https://static001.geekbang.org/account/avatar/00/17/14/0e/87d15656.jpg","nickname":"随心","note":"","ucode":"ADB430EA88DB75","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220202,"discussion_content":"我也想问这个问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585840319,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163301,"user_name":"Geek_103f3f","can_delete":false,"product_type":"c1","uid":1724657,"ip_address":"","ucode":"BD4E0A2606B11F","user_header":"","comment_is_top":false,"comment_ctime":1576681954,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5871649250","product_id":100026001,"comment_content":"比编译原理课程那老师讲的好多了","like_count":1},{"had_liked":false,"id":359210,"user_name":"k","can_delete":false,"product_type":"c1","uid":1445369,"ip_address":"广东","ucode":"6F28CFC722C3C9","user_header":"https://static001.geekbang.org/account/avatar/00/16/0d/f9/af581a47.jpg","comment_is_top":false,"comment_ctime":1665326520,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1665326520","product_id":100026001,"comment_content":"mesi和msi协议  e独占状态  不同于s共享状态需要在更新时通知其他核心，节省了写入效率","like_count":0},{"had_liked":false,"id":356839,"user_name":"天天有吃的","can_delete":false,"product_type":"c1","uid":1604355,"ip_address":"中国香港","ucode":"6267FE8E68DEE5","user_header":"https://static001.geekbang.org/account/avatar/00/18/7b/03/03583011.jpg","comment_is_top":false,"comment_ctime":1662628543,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662628543","product_id":100026001,"comment_content":"请问一下，Cache line和Cache Block有什么区别呢？","like_count":0},{"had_liked":false,"id":353731,"user_name":"浮石沉木","can_delete":false,"product_type":"c1","uid":2223167,"ip_address":"北京","ucode":"D585768321B84A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/mQddXC7nRiaKHTwdficicTB3bH0q5ic5UoSab51Omic7eyLBz0SNcvbLpQnNib7zP1yJFm7xxx4ia81iahfibRVnbTwHmhw/132","comment_is_top":false,"comment_ctime":1659705005,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1659705005","product_id":100026001,"comment_content":"这一章的评论是我点赞最多的。","like_count":0},{"had_liked":false,"id":347589,"user_name":"范超","can_delete":false,"product_type":"c1","uid":1035926,"ip_address":"","ucode":"A90F9490111A8B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ce/96/a0132d15.jpg","comment_is_top":false,"comment_ctime":1654176463,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1654176463","product_id":100026001,"comment_content":"老师，这一讲的Cache Block和Cache Line是同一个东西吗","like_count":0},{"had_liked":false,"id":345377,"user_name":"红豆成香","can_delete":false,"product_type":"c1","uid":1488601,"ip_address":"","ucode":"FB8FBB639B4BA6","user_header":"https://static001.geekbang.org/account/avatar/00/16/b6/d9/4d8a4d4c.jpg","comment_is_top":false,"comment_ctime":1652240825,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652240825","product_id":100026001,"comment_content":"MESI和MESA有联系吗","like_count":0},{"had_liked":false,"id":343685,"user_name":"小杰","can_delete":false,"product_type":"c1","uid":2853200,"ip_address":"","ucode":"BBDF8E9F348F65","user_header":"https://static001.geekbang.org/account/avatar/00/2b/89/50/aee9fdab.jpg","comment_is_top":false,"comment_ctime":1650981382,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650981382","product_id":100026001,"comment_content":"mesi相比msi新增了e状态，也就是Exclusive独占状态，可以让我们放心大胆的去读，不需要去share共享。","like_count":0},{"had_liked":false,"id":337884,"user_name":"毛路安","can_delete":false,"product_type":"c1","uid":2916063,"ip_address":"","ucode":"714DAEE9CD7EBB","user_header":"https://static001.geekbang.org/account/avatar/00/2c/7e/df/7017943a.jpg","comment_is_top":false,"comment_ctime":1647127893,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1647127893","product_id":100026001,"comment_content":"广播失效地址在前，写入数据修改内容在后","like_count":0},{"had_liked":false,"id":307880,"user_name":"惘 闻","can_delete":false,"product_type":"c1","uid":1181650,"ip_address":"","ucode":"C5909F034BF072","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","comment_is_top":false,"comment_ctime":1629291642,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629291642","product_id":100026001,"comment_content":"如果首先一个cpu先独占了一个块缓存数据，然后此cpu更新了自己缓存中的这一块数据。接着其他cpu读取这块数据，从内存中获取。这时候第一个cpu中的这块缓存数据，和新的cpu从内存里获取到的这块数据就不一致了。为什么没有人问这个问题？是我想偏了吗？","like_count":0},{"had_liked":false,"id":287600,"user_name":"Geek_4d47be","can_delete":false,"product_type":"c1","uid":2089204,"ip_address":"","ucode":"91AFAA0D0737E4","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eq54QLgdbJEmyTADB5TC3K00AaUW0ZO7ZqlSc7ia6licyyLE93UY7V4icvSabTcicibib5jHaWlcmewUm8w/132","comment_is_top":false,"comment_ctime":1618045755,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618045755","product_id":100026001,"comment_content":"当我们想要更新 Cache 里面的数据的时候，不能直接修改，而是要先向所有的其他 CPU 核心广播一个请求，要求先把其他 CPU 核心里面的 Cache，都变成无效的状态，然后再更新当前 Cache 里面的数据。<br><br>这里有一个缓存一致性的问题，如果CPU2要读这个数据，然后发现是无效的，然后去内存中取出数据，之后CPU2才更新数据，并写入内存，那么数据还是会不一致。<br>请问这里是怎么解决这个问题的？","like_count":0},{"had_liked":false,"id":281749,"user_name":"唐江","can_delete":false,"product_type":"c1","uid":1878120,"ip_address":"","ucode":"867C9808CF7760","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJpJXWFP3dNle88WnTkRTsEQkPJmOhepibiaTfhEtMRrbdg5EAWm4EzurA61oKxvCK2ZjMmy1QvmChw/132","comment_is_top":false,"comment_ctime":1614868918,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614868918","product_id":100026001,"comment_content":"通过总线向其他CPU通知缓存变化了，这个通知本身操作是哪个CPU完成的，还是总线不依靠CPU自己独立完成的？","like_count":0},{"had_liked":false,"id":281364,"user_name":"Zhayhp","can_delete":false,"product_type":"c1","uid":1903048,"ip_address":"","ucode":"979EFC13502C65","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/uiamnl5EFFhfUeZS0DnfIrVaBT7W2waRVbVysQIeEeW3uwgSqu1WUFSpbeGjibmNuic8KdGibqQ9mCqunaibB0hpibvw/132","comment_is_top":false,"comment_ctime":1614705348,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1614705348","product_id":100026001,"comment_content":"会出现多个 cpu 同时对一个相同的 cache 写数据的问题吗， 是如何处理的。","like_count":0},{"had_liked":false,"id":275744,"user_name":"Geek_a327d3","can_delete":false,"product_type":"c1","uid":1965806,"ip_address":"","ucode":"C77267A8FDF2E8","user_header":"","comment_is_top":false,"comment_ctime":1611656952,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611656952","product_id":100026001,"comment_content":"徐老师您好，我这里有个疑问，MESI协议本身是CPU实现的，还是说由操作系统来实现？我的理解就是CPU只是提供了一些指令，然后由操作系统进行编程实现的。像是我们一个Java程序写一个volatile变量是JVM调用操作系统的MESI协议来保证可见性的吗？","like_count":0},{"had_liked":false,"id":259280,"user_name":"小炭","can_delete":false,"product_type":"c1","uid":1109544,"ip_address":"","ucode":"E20E3958CAF06C","user_header":"https://static001.geekbang.org/account/avatar/00/10/ee/28/c04a0c83.jpg","comment_is_top":false,"comment_ctime":1604670304,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1604670304","product_id":100026001,"comment_content":"在看《Java并发编程实战》这门课的时候介绍到了并发编程的可见性问题，回过头来再看这篇文章加深理解。","like_count":0},{"had_liked":false,"id":256132,"user_name":"风","can_delete":false,"product_type":"c1","uid":1077538,"ip_address":"","ucode":"104638BF19B048","user_header":"https://static001.geekbang.org/account/avatar/00/10/71/22/b8c596b6.jpg","comment_is_top":false,"comment_ctime":1603534209,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603534209","product_id":100026001,"comment_content":"MESI 协议，是已修改、独占、共享以及已失效这四个缩写的合称。独占和共享状态，就好像我们在多线程应用开发里面的读写锁机制，确保了我们的缓存一致性。而整个 MESI 的状态变更，则是根据来自自己 CPU 核心的请求，以及来自其他 CPU 核心通过总线传输过来的操作信号和地址信息，进行状态流转的一个有限状态机。","like_count":0},{"had_liked":false,"id":252466,"user_name":"ApueUnp","can_delete":false,"product_type":"c1","uid":1568204,"ip_address":"","ucode":"90BD35963CE8DA","user_header":"https://static001.geekbang.org/account/avatar/00/17/ed/cc/183a90c9.jpg","comment_is_top":false,"comment_ctime":1602312918,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602312918","product_id":100026001,"comment_content":"老师，状态机中，已修改M 通过 总线读，为什么会发出读写信号？ 此时应该只是写入内存吧","like_count":0},{"had_liked":false,"id":251992,"user_name":"晓冰","can_delete":false,"product_type":"c1","uid":1139231,"ip_address":"","ucode":"E0117E14E6BB8C","user_header":"https://static001.geekbang.org/account/avatar/00/11/62/1f/cd1cbdb1.jpg","comment_is_top":false,"comment_ctime":1602044739,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602044739","product_id":100026001,"comment_content":"老师 学到这里有个疑问 既然MESI协议已经保证了多核CPU 之间缓存的一致性问题，那么我们平时使用多线程 修改同一个变量的值的时候 还是会出现数据不一致问题，多线程技术也是利用了多核CPU，请问他们之间是什么联系？","like_count":0},{"had_liked":false,"id":247944,"user_name":"马永真","can_delete":false,"product_type":"c1","uid":1778063,"ip_address":"","ucode":"C506319AE8234C","user_header":"https://static001.geekbang.org/account/avatar/00/1b/21/8f/a13e625f.jpg","comment_is_top":false,"comment_ctime":1599926652,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599926652","product_id":100026001,"comment_content":"写失效和写广播的两张图，看起来有一些问题。其中写失效中cache line之间的数据flushpot，包含了cache line中所有的数据，当然也包含了数据内容。所以写失效中，总线上的数据是仍然存在数据内容的，只不过和写广播中的区别是这些数据并不一定会被所有的其他cache所响应(只有本地有对应数据内容的cache才会响应)","like_count":0},{"had_liked":false,"id":239314,"user_name":"弋轰","can_delete":false,"product_type":"c1","uid":1443961,"ip_address":"","ucode":"C91DC862C248F0","user_header":"https://static001.geekbang.org/account/avatar/00/16/08/79/770c7d85.jpg","comment_is_top":false,"comment_ctime":1596502933,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1596502933","product_id":100026001,"comment_content":"文中Cache Line和Cache Block是一个东西么？","like_count":0,"discussions":[{"author":{"id":1810189,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/ZHw73tgCqGKhvticUWGRz4icgicu4hFWfKtacoFJeItH7maNuNUmjnEgDTJvOibwUWgGV0p6guNPibMVWDV4BUmEmlA/132","nickname":"Ethan","note":"","ucode":"75F613D58909DB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301288,"discussion_content":"Cache Line包括那些标记位，比如组标记、有效为等。Cache Block单单表示数据块","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598484167,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":237015,"user_name":"放下","can_delete":false,"product_type":"c1","uid":1397434,"ip_address":"","ucode":"1AD911B1E23BDB","user_header":"https://static001.geekbang.org/account/avatar/00/15/52/ba/412b05c1.jpg","comment_is_top":false,"comment_ctime":1595653536,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595653536","product_id":100026001,"comment_content":"mesi协议和内存屏障是什么关系","like_count":0},{"had_liked":false,"id":234777,"user_name":"nero","can_delete":false,"product_type":"c1","uid":1078793,"ip_address":"","ucode":"038100ACA14B29","user_header":"https://static001.geekbang.org/account/avatar/00/10/76/09/cf7513c8.jpg","comment_is_top":false,"comment_ctime":1594792678,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"1594792678","product_id":100026001,"comment_content":"脑补MESI协议，当多个cpu同时缓存了同一个缓存行，缓存行内有一个volatile变量A。此时，该缓存行的状态是S(共享态)，cpu1和cpu2同时对A进行更改操作，假设c1完成了计算任务，将变量A通过bus进行了写失效。此时c2已经完成了计算任务。但是发现变量A已经失效了。c2的计算会怎么办？是重新计算还是丢失呢 ？","like_count":0,"discussions":[{"author":{"id":1303914,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e5/6a/3c618346.jpg","nickname":"二桃杀三士","note":"","ucode":"5D7CAB540B0DF3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351210,"discussion_content":"CPU 不会重新计算的，准备写 cache 的时候发现是 I 状态，就会发送 Read Invalidate 消息获取最新值及所有权，然后再将旧值覆盖到 cache 中。可以看下这篇文章： https://juejin.cn/post/6932347103214518286/ 和 https://www.zhihu.com/question/329746124\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614177780,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1402167,"avatar":"https://static001.geekbang.org/account/avatar/00/15/65/37/abc7a5bf.jpg","nickname":"wgg9696","note":"","ucode":"B59488988122F2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293610,"discussion_content":"老师说过 同一行保证有锁 就像写锁 先拿到的cpu1会执行 cpu2会阻塞等待吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595596643,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":234776,"user_name":"nero","can_delete":false,"product_type":"c1","uid":1078793,"ip_address":"","ucode":"038100ACA14B29","user_header":"https://static001.geekbang.org/account/avatar/00/10/76/09/cf7513c8.jpg","comment_is_top":false,"comment_ctime":1594792305,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1594792305","product_id":100026001,"comment_content":"有一点不是很理解，请问老师。在mesi协议里更多的强调的是cpu cache里面的数据状态变化、写失效或写传播等策略来保证一致性。这没有问题<br>但有一点疑问，对于任意程序指令，在cpu内部都是在实时运行的。如何保证最小粒度的指令互斥和串行呢，假设一个累加程序，被多个cpu同时执行。已经运算过的值，在写回主存之前，被通知失效了，那此时的这个计算程序会丢失吗 ？ ","like_count":0},{"had_liked":false,"id":234465,"user_name":"A君","can_delete":false,"product_type":"c1","uid":1940105,"ip_address":"","ucode":"FE96F089C2312C","user_header":"https://static001.geekbang.org/account/avatar/00/1d/9a/89/babe8b52.jpg","comment_is_top":false,"comment_ctime":1594696291,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1594696291","product_id":100026001,"comment_content":"MESI机制解决了各cpu的缓存一致性问题。cpu在发出写回指令前需要先通过总线广播一个失效指令将其他cpu的共享缓存块标记为失效，再写入本地数据，然后标记为已修改。当本地缓存没命中时，先将已修改的数据写回内存，再从内存中读新地址的数据，并将该缓存块标记为独占或共享。","like_count":0},{"had_liked":false,"id":207531,"user_name":"JamesPxy","can_delete":false,"product_type":"c1","uid":1320179,"ip_address":"","ucode":"558D707463589D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q2LT8JFWSghiaVbMMOkOkLnuibEqG2YOyEdCA5icEZH3Qpd9pL23mpzic9tWwyiciaBicE4YPMVnITOodulwG2SS75r2w/132","comment_is_top":false,"comment_ctime":1587103079,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1587103079","product_id":100026001,"comment_content":"现代化的系统使用的MSI协议的变种以减少保持缓存一致性所需要的通信量。MESI协议增加了一个Exclusive（独占）状态，以减少对于只存在于一个高速缓存的块的写操作造成的通信。MOSI协议增加了一个Owned（持有）状态，以减少对于被其他缓存读取过的高速缓存的块的写回操作造成的通信。MOESI协议同时做了这两件事情。","like_count":0},{"had_liked":false,"id":198196,"user_name":"o_O","can_delete":false,"product_type":"c1","uid":1257283,"ip_address":"","ucode":"7C469AE3DA323B","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/43/e24212bb.jpg","comment_is_top":false,"comment_ctime":1585413553,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585413553","product_id":100026001,"comment_content":"同不明白设置成失效状态后干了什么？失效后拿到数据从哪里拿，内存数据又不准确，到其他cache怎么拿","like_count":0},{"had_liked":false,"id":156144,"user_name":"casper","can_delete":false,"product_type":"c1","uid":1024988,"ip_address":"","ucode":"3347EB65FEAF37","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a3/dc/ae65d100.jpg","comment_is_top":false,"comment_ctime":1574824254,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574824254","product_id":100026001,"comment_content":"原文中这一段有一点疑问。<br>【那么“独占”和“共享”这两个状态的差别在哪里呢？这个差别就在于，在独占状态下，对应的 Cache Line 只加载到了当前 CPU 核所拥有的 Cache 里。其他的 CPU 核，并没有加载对应的数据到自己的 Cache 里。这个时候，如果要向独占的 Cache Block 写入数据，我们可以自由地写入数据，而不需要告知其他 CPU 核。】<br>如果CPU A是在独占状态下使用某数据X，这时CPA更新了CacheBlock中的数据X为X1，而并不用通知其他CPU核。并且，CPU A的CacheBlock此时是脏的，但是根据上一讲写回的原理，X1并没有写回内存。<br>这时CPU B中的指令也要用到X的，CPU B势必会从内存读取到其Cache Block，而CPU B使用的值就是X，和 CPU A使用中X1不就不一致了吗？","like_count":0},{"had_liked":false,"id":152852,"user_name":"追风筝的人","can_delete":false,"product_type":"c1","uid":1488020,"ip_address":"","ucode":"2993D60F94C396","user_header":"https://static001.geekbang.org/account/avatar/00/16/b4/94/2796de72.jpg","comment_is_top":false,"comment_ctime":1574089228,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574089228","product_id":100026001,"comment_content":"MESI 协议，是已修改、独占、共享以及已失效这四个缩写的合称。独占和共享状态，就好像我们在多线程应用开发里面的读写锁机制，确保了我们的缓存一致性。","like_count":0},{"had_liked":false,"id":145963,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1572408192,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572408192","product_id":100026001,"comment_content":"请问下老师，总线嗅探的话，各CPU会在每个指令周期中安排一次嗅探吗？","like_count":0},{"had_liked":false,"id":143652,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1571752386,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571752386","product_id":100026001,"comment_content":"老师这种讲课方式，真赞。每节只讲少量知识点，后面的知识点将前面的知识点作为基础，并解决前面提出的疑问。","like_count":0},{"had_liked":false,"id":124266,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1565847677,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565847677","product_id":100026001,"comment_content":"关于更新的数据什么时候写回内存的问题，看那个状态图，应该是总线发出读或者写请求的时候，这个数据就会写回，然后进去共享或者失效状态。","like_count":0},{"had_liked":false,"id":118976,"user_name":"靠人品去赢","can_delete":false,"product_type":"c1","uid":1301286,"ip_address":"","ucode":"7A20F9EBE847E1","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/26/54f2c164.jpg","comment_is_top":false,"comment_ctime":1564478240,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564478240","product_id":100026001,"comment_content":"其实想知道，那种一个主板插两个CPU那种服务器主板，他是怎么搞得？L3缓存会打通吗，还是就是两台电脑共用一个主板而已。","like_count":0},{"had_liked":false,"id":117495,"user_name":"逍遥法外","can_delete":false,"product_type":"c1","uid":1103533,"ip_address":"","ucode":"75458730192696","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/ad/52df3832.jpg","comment_is_top":false,"comment_ctime":1564059734,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1564059734","product_id":100026001,"comment_content":"老师你好，关于MESI，有一个疑问：MESI协议是不是只能保证缓存的最终一致？不然为什么java会有volatile?","like_count":0,"discussions":[{"author":{"id":1696212,"avatar":"https://static001.geekbang.org/account/avatar/00/19/e1/d4/1b5ac51e.jpg","nickname":"山间竹","note":"","ucode":"FA7F16EF01D659","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":118978,"discussion_content":"既然有了MESI协议，是不是就不需要volatile的可见性语义了？当然不是，还有三个问题：\n\n并不是所有的硬件架构都提供了相同的一致性保证，JVM需要volatile统一语义（就算是MESI，也只解决CPU缓存层面的问题，没有涉及其他层面）。\n可见性问题不仅仅局限于CPU缓存内，JVM自己维护的内存模型中也有可见性问题。使用volatile做标记，可以解决JVM层面的可见性问题。\n如果不考虑真·重排序，MESI确实解决了CPU缓存层面的可见性问题；然而，真·重排序也会导致可见性问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578205931,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1621793,"avatar":"https://static001.geekbang.org/account/avatar/00/18/bf/21/44eb3aee.jpg","nickname":"Hou","note":"","ucode":"92BF011EF961B4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":31774,"discussion_content":"volatile是插入内存屏障使CPU不对写操作优化（写缓冲和失效队列），MESI协议只要诗句被修改了就会立即同步回主内存，不是保证最终的一致性的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570955374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117329,"user_name":"ezra.xu","can_delete":false,"product_type":"c1","uid":1014005,"ip_address":"","ucode":"6C3E11889BC6AB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/f5/ae200a94.jpg","comment_is_top":false,"comment_ctime":1564024854,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1564024854","product_id":100026001,"comment_content":"L1,2,3 cache，以及主存都是公用的一个虚拟地址空间吗？感觉可以把cache里的地址和主存地址串起来用，每次读写都是唯一的地址值，这样是不是就可以避免缓存失效？","like_count":0,"discussions":[{"author":{"id":1014800,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7c/10/165cb374.jpg","nickname":"Scott","note":"","ucode":"7E57FDCB5E5D49","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8010,"discussion_content":"cache里面一般都是物理地址，不同进程虚拟地址背后对应的物理地址可能是一样的，放cache很浪费","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567756119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1350677,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9c/15/719f1f44.jpg","nickname":"等风来","note":"","ucode":"5B7FF74A51F534","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7260,"discussion_content":"缓存的出现本就是为了提升性能而考虑的， 如果使用虚拟地址，那么地址的转换的数据的读取将大大降低性能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567437412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117125,"user_name":"一塌糊涂","can_delete":false,"product_type":"c1","uid":1106566,"ip_address":"","ucode":"B55DAEFB98D83C","user_header":"https://static001.geekbang.org/account/avatar/00/10/e2/86/90041355.jpg","comment_is_top":false,"comment_ctime":1563973154,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563973154","product_id":100026001,"comment_content":"老师问个问题，锁总线，锁缓存中中的锁缓存的概念，锁缓存用了mesi协议，cpu还做其他的了吗？还是单纯只靠缓存一致性，来锁缓存，","like_count":0},{"had_liked":false,"id":117118,"user_name":"一塌糊涂","can_delete":false,"product_type":"c1","uid":1106566,"ip_address":"","ucode":"B55DAEFB98D83C","user_header":"https://static001.geekbang.org/account/avatar/00/10/e2/86/90041355.jpg","comment_is_top":false,"comment_ctime":1563971793,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563971793","product_id":100026001,"comment_content":"通俗易懂，找了很多书，缓存讲的最好的。缓存一致性，内存一致性也讲讲吧，","like_count":0},{"had_liked":false,"id":116807,"user_name":"xindoo","can_delete":false,"product_type":"c1","uid":1101718,"ip_address":"","ucode":"AEAF3208E644BC","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/96/251c0cee.jpg","comment_is_top":false,"comment_ctime":1563928715,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1563928715","product_id":100026001,"comment_content":"cpu，多线程，分布式系统解决一致性问题的方法还是很类似的","like_count":0},{"had_liked":false,"id":116773,"user_name":"悟","can_delete":false,"product_type":"c1","uid":1085006,"ip_address":"","ucode":"9F56AD21CCC7E1","user_header":"https://static001.geekbang.org/account/avatar/00/10/8e/4e/985caf6b.jpg","comment_is_top":false,"comment_ctime":1563925162,"is_pvip":false,"discussion_count":1,"race_medal":2,"score":"1563925162","product_id":100026001,"comment_content":"第二次看到MESI协议，老师写的简单易懂","like_count":0,"discussions":[{"author":{"id":1027596,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ae/0c/f39f847a.jpg","nickname":"D","note":"","ucode":"5BB4D16FE39BFF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2769,"discussion_content":"文字和图不匹配，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563929409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}