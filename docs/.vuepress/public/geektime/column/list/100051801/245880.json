{"id":245880,"title":"15 | 序列化：简单通用的数据交换格式有哪些？","content":"<p>你好，我是Chrono。</p><p>在前面的三个单元里，我们学习了C++的语言特性和标准库，算是把C++的编程范式、生命周期、核心特性、标准库的内容整体过了一遍。从今天起，我们的学习之旅又将开启一个新的篇章。</p><p>C++语言和标准库很强大，功能灵活，组件繁多，但也只能说是构建软件这座大厦的基石。想要仅凭它们去“包打天下”，不能说是绝对不可行，但至少是“吃力难讨好”。</p><p>还是那句老话：“不要重复发明轮子。”（Reinventing the wheel）虽然很多C++程序员都热衷于此，但我觉得对于你我这样的“凡人”，还是要珍惜自己的时间和精力，把有限的资源投入到能有更多产出的事情上。</p><p>所以，接下来的这几节课，我会介绍一些第三方工具，精选出序列化/反序列化、网络通信、脚本语言混合编程和性能分析这四类工具，弥补标准库的不足，节约你的开发成本，让你的工作更有效率。</p><p>今天，我先来说一下序列化和反序列化。这两个功能在软件开发中经常遇到，你可能很熟悉了，所以我只简单解释一下。</p><p>序列化，就是把内存里“活的对象”转换成静止的字节序列，便于存储和网络传输；而反序列化则是反向操作，从静止的字节序列重新构建出内存里可用的对象。</p><p>我借用《三体》里的内容，打一个形象的比喻：序列化就是“三体人”的脱水，变成干纤维，在乱纪元方便存储运输；反序列化就是“三体人”的浸泡，在恒纪元由干纤维再恢复成活生生的人。（即使没读过《三体》，也是很好理解的吧？）</p><!-- [[[read_end]]] --><p>接下来，我就和你介绍三种既简单又高效的数据交换格式：JSON、MessagePack和ProtoBuffer，看看在C++里怎么对数据做序列化和反序列化。</p><h2>JSON</h2><p>JSON是一种轻量级的数据交换格式，采用纯文本表示，所以是“human readable”，阅读和修改都很方便。</p><p>由于JSON起源于“最流行的脚本语言”JavaScript，所以它也随之得到了广泛的应用，在Web开发领域几乎已经成为了事实上的标准，而且还渗透到了其他的领域。比如很多数据库就支持直接存储JSON数据，还有很多应用服务使用JSON作为配置接口。</p><p>在<a href=\"https://www.json.org/json-zh.html\">JSON的官方网站</a>上，你可以找到大量的C++实现，不过用起来都差不多。因为JSON本身就是个KV结构，很容易映射到类似map的关联数组操作方式。</p><p>如果不是特别在意性能的话，选个你自己喜欢的就好。否则，你就要做一下测试，看哪一个更适合你的应用场景。</p><p>不过我觉得，JSON格式注重的是方便易用，在性能上没有太大的优势，所以<strong>一般选择JSON来交换数据，通常都不会太在意性能（不然肯定会改换其他格式了），还是自己用着顺手最重要</strong>。</p><p>下面就来说说我的个人推荐：“<a href=\"https://github.com/nlohmann/json\">JSON for Modern C++</a>”这个库。</p><p>JSON for Modern C++可能不是最小最快的JSON解析工具，但功能足够完善，而且使用方便，仅需要包含一个头文件“json.hpp”，没有外部依赖，也不需要额外的安装、编译、链接工作，适合快速上手开发。</p><p>JSON for Modern C++可以用“git clone”下载源码，或者更简单一点，直接用wget获取头文件就行：</p><pre><code>git clone git@github.com:nlohmann/json.git    # git clone\nwget https://github.com/nlohmann/json/releases/download/v3.7.3/json.hpp  # wget \n</code></pre><p>JSON for Modern C++使用一个json类来表示JSON数据，为了避免说的时候弄混，我给这个类起了个别名json_t：</p><pre><code>using json_t = nlohmann::json;\n</code></pre><p>json_t的序列化功能很简单，和标准容器map一样，用关联数组的“[]”来添加任意数据。</p><p>你不需要特别指定数据的类型，它会自动推导出恰当的类型。比如，连续多个“[]”就是嵌套对象，array、vector或者花括号形式的初始化列表就是JSON数组，map或者是花括号形式的pair就是JSON对象，非常自然：</p><pre><code>json_t j;                                   // JSON对象\n\nj[&quot;age&quot;] = 23;                              // &quot;age&quot;:23\nj[&quot;name&quot;] = &quot;spiderman&quot;;                    // &quot;name&quot;:&quot;spiderman&quot;\nj[&quot;gear&quot;][&quot;suits&quot;] = &quot;2099&quot;;                // &quot;gear&quot;:{&quot;suits&quot;:&quot;2099&quot;}\nj[&quot;jobs&quot;] = {&quot;superhero&quot;};                  // &quot;jobs&quot;:[&quot;superhero&quot;]  \n\nvector&lt;int&gt; v = {1,2,3};                   // vector容器\nj[&quot;numbers&quot;] = v;                          // &quot;numbers&quot;:[1,2,3]\n\nmap&lt;string, int&gt; m =                       // map容器\n    {{&quot;one&quot;,1}, {&quot;two&quot;, 2}};               // 初始化列表 \nj[&quot;kv&quot;] = m;                               // &quot;kv&quot;:{&quot;one&quot;:1,&quot;two&quot;:2}\n</code></pre><p>添加完之后，用成员函数dump()就可以序列化，得到它的JSON文本形式。默认的格式是紧凑输出，没有缩进，如果想要更容易阅读的话，可以加上指示缩进的参数：</p><pre><code>cout &lt;&lt; j.dump() &lt;&lt; endl;         // 序列化，无缩进\ncout &lt;&lt; j.dump(2) &lt;&lt; endl;        // 序列化，有缩进，2个空格\n</code></pre><p>json_t的反序列化功能同样也很简单，只要调用静态成员函数parse()就行，直接得到JSON对象，而且可以用auto自动推导类型：</p><pre><code>string str = R&quot;({                // JSON文本，原始字符串\n    &quot;name&quot;: &quot;peter&quot;,\n    &quot;age&quot; : 23,\n    &quot;married&quot; : true\n})&quot;;\n\nauto j = json_t::parse(str);    // 从字符串反序列化\nassert(j[&quot;age&quot;] == 23);        // 验证序列化是否正确\nassert(j[&quot;name&quot;] == &quot;peter&quot;);\n</code></pre><p>json_t使用异常来处理解析时可能发生的错误，如果你不能保证JSON数据的完整性，就要使用try-catch来保护代码，防止错误数据导致程序崩溃：</p><pre><code>auto txt = &quot;bad:data&quot;s;        // 不是正确的JSON数据\n\ntry                             // try保护代码\n{\n    auto j = json_t::parse(txt);// 从字符串反序列化\n}\ncatch(std::exception&amp; e)        // 捕获异常\n{\n    cout &lt;&lt; e.what() &lt;&lt; endl;\n}\n</code></pre><p>对于通常的应用来说，掌握了基本的序列化和反序列化就够用了，不过JSON for Modern C++里还有很多高级用法，比如SAX、BSON、自定义类型转换等。如果你需要这些功能，可以去看<a href=\"https://github.com/nlohmann/json\">它的文档</a>，里面写得都很详细。</p><h2>MessagePack</h2><p>说完JSON，再来说另外第二种格式：MessagePack。</p><p>它也是一种轻量级的数据交换格式，与JSON的不同之处在于它不是纯文本，而是二进制。所以MessagePack就比JSON更小巧，处理起来更快，不过也就没有JSON那么直观、易读、好修改了。</p><p>由于二进制这个特点，MessagePack也得到了广泛的应用，著名的有Redis、Pinterest。</p><p>MessagePack支持几乎所有的编程语言，你可以在<a href=\"https://msgpack.org/\">官网</a>上找到它的C++实现。</p><p>我常用的是官方库msgpack-c，可以用apt-get直接安装。</p><pre><code>apt-get install libmsgpack-dev\n</code></pre><p>但这种安装方式有个问题，可能发行方仓库里的是老版本（像Ubuntu 16.04就是0.57），缺失很多功能，所以最好是从<a href=\"https://github.com/msgpack/msgpack-c\">GitHub</a>上下载最新版，编译时手动指定包含路径：</p><pre><code>git clone git@github.com:msgpack/msgpack-c.git\n\ng++ msgpack.cpp -std=c++14 -I../common/include -o a.out\n</code></pre><p>和JSON for Modern C++一样，msgpack-c也是仅头文件的库（head only），只要包含一个头文件“msgpack.hpp”就行了，不需要额外的编译链接选项（C版本需要用“-lmsgpackc”链接）。</p><p>但MessagePack的设计理念和JSON是完全不同的，它没有定义JSON那样的数据结构，而是比较底层，只能对基本类型和标准容器序列化/反序列化，需要你自己去组织、整理要序列化的数据。</p><p>我拿vector容器来举个例子，调用pack()函数序列化为MessagePack格式：</p><pre><code>vector&lt;int&gt; v = {1,2,3,4,5};              // vector容器\n\nmsgpack::sbuffer sbuf;                    // 输出缓冲区\nmsgpack::pack(sbuf, v);                   // 序列化\n</code></pre><p>从代码里你可以看到，它的用法不像JSON那么简单直观，<strong>必须同时传递序列化的输出目标和被序列化的对象</strong>。</p><p>输出目标sbuffer是个简单的缓冲区，你可以把它理解成是对字符串数组的封装，和<code>vector&lt;char&gt;</code>很像，也可以用data()和size()方法获取内部的数据和长度。</p><pre><code>cout &lt;&lt; sbuf.size() &lt;&lt; endl;            // 查看序列化后数据的长度\n</code></pre><p>除了sbuffer，你还可以选择另外的zbuffer、fbuffer。它们是压缩输出和文件输出，和sbuffer只是格式不同，用法是相同的，所以后面我就都用sbuffer来举例说明。</p><p>MessagePack反序列化的时候略微麻烦一些，要用到函数unpack()和两个核心类：object_handle和object。</p><p>函数unpack()反序列化数据，得到的是一个object_handle，再调用get()，就是object：</p><pre><code>auto handle = msgpack::unpack(          // 反序列化\n            sbuf.data(), sbuf.size());  // 输入二进制数据\nauto obj = handle.get();                // 得到反序列化对象\n</code></pre><p>这个object是MessagePack对数据的封装，相当于JSON for Modern C++的JSON对象，但你不能直接使用，必须知道数据的原始类型，才能转换还原：</p><pre><code>vector&lt;int&gt; v2;                       // vector容器\nobj.convert(v2);                      // 转换反序列化的数据\n\nassert(std::equal(                    // 算法比较两个容器\n      begin(v), end(v), begin(v2)));\n</code></pre><p>因为MessagePack不能直接打包复杂数据，所以用起来就比JSON麻烦一些，你必须自己把数据逐个序列化，连在一起才行。</p><p>好在MessagePack又提供了一个packer类，可以实现串联的序列化操作，简化代码：</p><pre><code>msgpack::sbuffer sbuf;                         // 输出缓冲区\nmsgpack::packer&lt;decltype(sbuf)&gt; packer(sbuf);  // 专门的序列化对象\n\npacker.pack(10).pack(&quot;monado&quot;s)                // 连续序列化多个数据\n      .pack(vector&lt;int&gt;{1,2,3});\n</code></pre><p>对于多个对象连续序列化后的数据，反序列化的时候可以用一个偏移量（offset）参数来同样连续操作：</p><pre><code>for(decltype(sbuf.size()) offset = 0;          // 初始偏移量是0\n    offset != sbuf.size();){                   // 直至反序列化结束\n\n    auto handle = msgpack::unpack(            // 反序列化\n            sbuf.data(), sbuf.size(), offset);  // 输入二进制数据和偏移量\n    auto obj = handle.get();                  // 得到反序列化对象\n}\n</code></pre><p>但这样还是比较麻烦，能不能像JSON那样，直接对类型序列化和反序列化呢？</p><p>MessagePack为此提供了一个特别的宏：MSGPACK_DEFINE，把它放进你的类定义里，就可以像标准类型一样被MessagePack处理。</p><p>下面定义了一个简单的Book类：</p><pre><code>class Book final                       // 自定义类\n{\npublic:\n    int         id;\n    string      title;\n    set&lt;string&gt; tags;\npublic:\n    MSGPACK_DEFINE(id, title, tags);   // 实现序列化功能的宏\n};\n</code></pre><p>它可以直接用于pack()和unpack()，基本上和JSON差不多了：</p><pre><code>Book book1 = {1, &quot;1984&quot;, {&quot;a&quot;,&quot;b&quot;}};  // 自定义类\n\nmsgpack::sbuffer sbuf;                    // 输出缓冲区\nmsgpack::pack(sbuf, book1);              // 序列化\n\nauto obj = msgpack::unpack(              // 反序列化\n      sbuf.data(), sbuf.size()).get();   // 得到反序列化对象\n\nBook book2;\nobj.convert(book2);                      // 转换反序列化的数据\n\nassert(book2.id == book1.id);\nassert(book2.tags.size() == 2);\ncout &lt;&lt; book2.title &lt;&lt; endl;\n</code></pre><p>使用MessagePack的时候，你也要注意数据不完整的问题，必须要用try-catch来保护代码，捕获异常：</p><pre><code>auto txt = &quot;&quot;s;                      // 空数据\ntry                                  // try保护代码\n{\n    auto handle = msgpack::unpack(   // 反序列化\n        txt.data(), txt.size());\n}\ncatch(std::exception&amp; e)            // 捕获异常\n{\n    cout &lt;&lt; e.what() &lt;&lt; endl;\n}\n</code></pre><h2>ProtoBuffer</h2><p>第三个要说的库就是著名的<a href=\"https://github.com/protocolbuffers/protobuf\">ProtoBuffer</a>，通常简称为PB，由Google出品。</p><p>PB也是一种二进制的数据格式，但毕竟是工业级产品，所以没有JSON和MessagePack那么“轻”，相关的东西比较多，要安装一个预处理器和开发库，编译时还要链接动态库（-lprotobuf）：</p><pre><code>apt-get install protobuf-compiler\napt-get install libprotobuf-dev\n\ng++ protobuf.cpp -std=c++14 -lprotobuf -o a.out\n</code></pre><p><strong>PB的另一个特点是数据有“模式”（schema）</strong>，必须要先写一个IDL（Interface Description Language）文件，在里面定义好数据结构，只有预先定义了的数据结构，才能被序列化和反序列化。</p><p>这个特点既有好处也有坏处：一方面，接口就是清晰明确的规范文档，沟通交流简单无歧义；而另一方面，就是缺乏灵活性，改接口会导致一连串的操作，有点繁琐。</p><p>下面是一个简单的PB定义：</p><pre><code>syntax = &quot;proto2&quot;;                    // 使用第2版\n\npackage sample;                        // 定义名字空间\n\nmessage Vendor                        // 定义消息\n{\n    required uint32     id      = 1;  // required表示必须字段\n    required string     name    = 2;  // 有int32/string等基本类型\n    required bool       valid   = 3;  // 需要指定字段的序号，序列化时用\n    optional string     tel     = 4;  // optional字段可以没有\n}\n</code></pre><p>有了接口定义文件，需要再用protoc工具生成对应的C++源码，然后把源码文件加入自己的项目中，就可以使用了：</p><pre><code>protoc --cpp_out=. sample.proto       // 生成C++代码\n</code></pre><p>由于PB相关的资料实在太多了，这里我就只简单说一下重要的接口：</p><ul>\n<li>字段名会生成对应的has/set函数，检查是否存在和设置值；</li>\n<li>IsInitialized()检查数据是否完整（required字段必须有值）；</li>\n<li>DebugString()输出数据的可读字符串描述；</li>\n<li>ByteSize()返回序列化数据的长度；</li>\n<li>SerializeToString()从对象序列化到字符串；</li>\n<li>ParseFromString()从字符串反序列化到对象；</li>\n<li>SerializeToArray()/ParseFromArray()序列化的目标是字节数组。</li>\n</ul><p>下面的代码示范了PB的用法：</p><pre><code>using vendor_t = sample::Vendor;        // 类型别名\n\nvendor_t v;                             // 声明一个PB对象\nassert(!v.IsInitialized());            // required等字段未初始化\n\nv.set_id(1);                            // 设置每个字段的值    \nv.set_name(&quot;sony&quot;);\nv.set_valid(true);\n\nassert(v.IsInitialized());             // required等字段都设置了，数据完整\nassert(v.has_id() &amp;&amp; v.id() == 1); \nassert(v.has_name() &amp;&amp; v.name() == &quot;sony&quot;);\nassert(v.has_valid() &amp;&amp; v.valid());\n\ncout &lt;&lt; v.DebugString() &lt;&lt; endl;       // 输出调试字符串\n\nstring enc;\nv.SerializeToString(&amp;enc);              // 序列化到字符串 \n\nvendor_t v2; \nassert(!v2.IsInitialized());\nv2.ParseFromString(enc);               // 反序列化\n</code></pre><p>虽然业界很多大厂都在使用PB，但我觉得它真不能算是最好的，IDL定义和接口都太死板生硬，还只能用最基本的数据类型，不支持标准容器，在现代C++里显得“不太合群”，用起来有点别扭。</p><p>不过它后面有Google“撑腰”，而且最近几年又有gRPC“助拳”，所以很多时候也不得不用。</p><p>PB的另一个缺点是官方支持的编程语言太少，通用性较差，最常用的proto2只有C++、Java和Python。后来的proto3增加了对Go、Ruby等的支持，但仍然不能和JSON、MessagePack相比。</p><h2>小结</h2><p>好了，今天我讲了三种数据交换格式：JSON、MessagePack和ProtoBuffer。</p><p>这三种数据格式各有特色，在很多领域都得到了广泛的应用，我来简单小结一下：</p><ol>\n<li>JSON是纯文本，容易阅读，方便编辑，适用性最广；</li>\n<li>MessagePack是二进制，小巧高效，在开源界接受程度比较高；</li>\n<li>ProtoBuffer是工业级的数据格式，注重安全和性能，多用在大公司的商业产品里。</li>\n</ol><p>有很多开源库支持这些数据格式，官方的、民间的都有，你应该选择适合自己的高质量库，必要的时候可以做些测试。</p><p>再补充一点，除了今天说的这三种，你还可以尝试其他的数据格式，比较知名的有Avro、Thrift，虽然它们有点冷门，但也有自己的独到之处（比如，天生支持RPC、可选择多种序列化格式和传输方式）。</p><h2>课下作业</h2><p>最后是课下作业时间，给你留两个思考题：</p><ol>\n<li>为什么要有序列化和反序列化，直接memcpy内存数据行不行呢？</li>\n<li>你最常用的是哪种数据格式？它有什么优缺点？</li>\n</ol><p>欢迎你在留言区写下你的思考和答案，如果觉得今天的内容对你有所帮助，也欢迎分享给你的朋友。我们下节课见。</p><p><img src=\"https://static001.geekbang.org/resource/image/a3/f1/a39719e615f1124d60b5b9ca51b88cf1.png?wh=2000*3396\" alt=\"\"></p>","comments":[{"had_liked":false,"id":225148,"user_name":"被讨厌的勇气","can_delete":false,"product_type":"c1","uid":1547913,"ip_address":"","ucode":"AE3B3CA27D91A2","user_header":"https://static001.geekbang.org/account/avatar/00/17/9e/89/6e9c05d6.jpg","comment_is_top":false,"comment_ctime":1591667207,"is_pvip":false,"replies":[{"id":"82875","content":"说的很对。","user_name":"作者回复","comment_id":225148,"uid":"1181974","ip_address":"","utype":1,"ctime":1591668031,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"130440686087","product_id":100051801,"comment_content":"直接memcpy,同一种语言不同机器，或者不同语言可能存在兼容问题(变量内存存储布局、编码可能不同)，而Json是一种标准，由Json库处理编码问题(比如大小端)，且不同语言间统一，对头不？","like_count":31,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497753,"discussion_content":"说的很对。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591668031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":226104,"user_name":"蓝配鸡","can_delete":false,"product_type":"c1","uid":1348738,"ip_address":"","ucode":"C79A7CA8885B7C","user_header":"https://static001.geekbang.org/account/avatar/00/14/94/82/d0a417ba.jpg","comment_is_top":false,"comment_ctime":1591952031,"is_pvip":false,"replies":[{"id":"83320","content":"我觉得可以小范围推广一下，以后没准会流行起来，笑。","user_name":"作者回复","comment_id":226104,"uid":"1181974","ip_address":"","utype":1,"ctime":1592003990,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"44541624991","product_id":100051801,"comment_content":"序列化&#47;反序列化命名就用 “脱水&#47;浸泡”， 会不会被打死- -","like_count":10,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498107,"discussion_content":"我觉得可以小范围推广一下，以后没准会流行起来，笑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592003990,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225405,"user_name":"java2c++","can_delete":false,"product_type":"c1","uid":1460660,"ip_address":"","ucode":"C4F8C3D7B1A910","user_header":"","comment_is_top":false,"comment_ctime":1591751491,"is_pvip":false,"replies":[{"id":"83036","content":"很好的经验分享，json主要是对人友好，用来做人机接口很合适。","user_name":"作者回复","comment_id":225405,"uid":"1181974","ip_address":"","utype":1,"ctime":1591755926,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"40246457155","product_id":100051801,"comment_content":"问题2:和redis交互一般使用json，主要原因是可读性强，有问题时直接登录到redis控制台可以查看json内容，不过序列化需要的时间成本空间成本都是最高，如果追求性能就需要选择其他的了。<br>现在一些网络框架（rpc框架）都支持多种序列化的方式了，msgpack，thift跨语言支持的比较好，性能也不错我工作中相对用的多一些","like_count":10,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497840,"discussion_content":"很好的经验分享，json主要是对人友好，用来做人机接口很合适。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591755926,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229691,"user_name":"风","can_delete":false,"product_type":"c1","uid":1444483,"ip_address":"","ucode":"E1CE0825AAF805","user_header":"https://static001.geekbang.org/account/avatar/00/16/0a/83/f916f903.jpg","comment_is_top":false,"comment_ctime":1593099627,"is_pvip":false,"replies":[{"id":"84758","content":"对，json是字符串的文本形式，数字也表示成了文本，不需要考虑大小端问题。","user_name":"作者回复","comment_id":229691,"uid":"1181974","ip_address":"","utype":1,"ctime":1593127358,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"27362903403","product_id":100051801,"comment_content":"json不存在大小端，字节序的问题吧，反正就是一个字符串。messagepack这种二进制格式的东西，才要考虑大小端。","like_count":7,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499594,"discussion_content":"对，json是字符串的文本形式，数字也表示成了文本，不需要考虑大小端问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593127358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225924,"user_name":"hy","can_delete":false,"product_type":"c1","uid":1580046,"ip_address":"","ucode":"7D492373043C96","user_header":"https://static001.geekbang.org/account/avatar/00/18/1c/0e/f2954d1c.jpg","comment_is_top":false,"comment_ctime":1591891009,"is_pvip":false,"replies":[{"id":"83248","content":"pb好像确实有限制，我记得好像是64mb还是512mb，不是很确定。<br><br>这也是很合理的考虑，如果有超大对象，是不是要反思一下设计的问题，为什么会有这么大的对象，能否优化。","user_name":"作者回复","comment_id":225924,"uid":"1181974","ip_address":"","utype":1,"ctime":1591924266,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"23066727489","product_id":100051801,"comment_content":"pb有2G内存限制问题，如果对象过大会不行","like_count":6,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498046,"discussion_content":"pb好像确实有限制，我记得好像是64mb还是512mb，不是很确定。\n\n这也是很合理的考虑，如果有超大对象，是不是要反思一下设计的问题，为什么会有这么大的对象，能否优化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591924266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225401,"user_name":"java2c++","can_delete":false,"product_type":"c1","uid":1460660,"ip_address":"","ucode":"C4F8C3D7B1A910","user_header":"","comment_is_top":false,"comment_ctime":1591751036,"is_pvip":false,"replies":[{"id":"83038","content":"这是序列化和反序列化的目的，但还没有说到根本上，如果单纯的memcpy，也是可以转换成字节流的。<br><br>可以参考其他同学的留言。","user_name":"作者回复","comment_id":225401,"uid":"1181974","ip_address":"","utype":1,"ctime":1591756065,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"14476652924","product_id":100051801,"comment_content":"问题1:针对跨服务间的调用，涉及到网络传输，需要使用到字节流进行传输，序列化就是发送方将数据对象转化成字节流的过程，反序列就是接收方将字节流转化成数据对象的逆过程","like_count":3,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497836,"discussion_content":"这是序列化和反序列化的目的，但还没有说到根本上，如果单纯的memcpy，也是可以转换成字节流的。\n\n可以参考其他同学的留言。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591756065,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229688,"user_name":"Why not.","can_delete":false,"product_type":"c1","uid":1788706,"ip_address":"","ucode":"2588F0411F6F34","user_header":"https://static001.geekbang.org/account/avatar/00/1b/4b/22/10df9727.jpg","comment_is_top":false,"comment_ctime":1593099003,"is_pvip":false,"replies":[{"id":"84759","content":"jsoncpp比较老了，不是那么“现代”，但用起来也还可以。","user_name":"作者回复","comment_id":229688,"uid":"1181974","ip_address":"","utype":1,"ctime":1593127395,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"10183033595","product_id":100051801,"comment_content":"jsoncpp 也挺好用的 不知道老师怎么看","like_count":3,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499593,"discussion_content":"jsoncpp比较老了，不是那么“现代”，但用起来也还可以。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593127395,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225244,"user_name":"EncodedStar","can_delete":false,"product_type":"c1","uid":1504234,"ip_address":"","ucode":"03958CA7DDD6AE","user_header":"https://static001.geekbang.org/account/avatar/00/16/f3/ea/2b2adda5.jpg","comment_is_top":false,"comment_ctime":1591692506,"is_pvip":false,"replies":[{"id":"82991","content":"<br>1.序列化不是简单的memcpy，有点类似按照特定的规则去编码解码，屏蔽了硬件体系架构、语言的差异，是一种通用的格式。<br><br>2.json我觉得还行吧，用转义符那是没办法，C的老问题了。pb确实操作起来很麻烦，累。","user_name":"作者回复","comment_id":225244,"uid":"1181974","ip_address":"","utype":1,"ctime":1591751308,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"10181627098","product_id":100051801,"comment_content":"序列化和反序列化 可以按用户自定义的方式去读取吧，底层应该也是用类似memcpy这样的操作去处理里，只不过是又封装了一次统一接口方便我们使用，老师，我可以这么理解吗？？<br>常用json 和 pb ，感觉就是json对C++不是很友好，很多时候有\\转义符困扰，pb就是每次比较麻烦，改了协议之后还的生成一下对应文件","like_count":3,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497783,"discussion_content":"\n1.序列化不是简单的memcpy，有点类似按照特定的规则去编码解码，屏蔽了硬件体系架构、语言的差异，是一种通用的格式。\n\n2.json我觉得还行吧，用转义符那是没办法，C的老问题了。pb确实操作起来很麻烦，累。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591751308,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312213,"user_name":"于小咸","can_delete":false,"product_type":"c1","uid":1640946,"ip_address":"","ucode":"833D5E92016430","user_header":"https://static001.geekbang.org/account/avatar/00/19/09/f2/6ed195f4.jpg","comment_is_top":false,"comment_ctime":1631685735,"is_pvip":false,"replies":[{"id":"113133","content":"说的非常好。","user_name":"作者回复","comment_id":312213,"uid":"1181974","ip_address":"","utype":1,"ctime":1631701172,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"5926653031","product_id":100051801,"comment_content":"除了兼容不同语言外，序列化还有一个重要的作用是数据保存和网络传输，我们很难保证不同平台上内存里存的数据是一样的。<br><br>此外，对于包含指针的数据结构，我们是没法简单的memcpy，这会带来浅拷贝类似的问题。","like_count":2,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526898,"discussion_content":"说的非常好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631701172,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":226056,"user_name":"do it","can_delete":false,"product_type":"c1","uid":1309911,"ip_address":"","ucode":"E0753912E8F2AF","user_header":"https://static001.geekbang.org/account/avatar/00/13/fc/d7/b102034a.jpg","comment_is_top":false,"comment_ctime":1591938805,"is_pvip":false,"replies":[{"id":"83263","content":"说的挺好，常用的序列化也就是这几种了","user_name":"作者回复","comment_id":226056,"uid":"1181974","ip_address":"","utype":1,"ctime":1591941852,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"5886906101","product_id":100051801,"comment_content":"1、为什么要有序列化和反序列化，直接 memcpy 内存数据行不行呢？<br>  字节序问题；序列号反序列化可数据压缩(不确定😁)<br>2、你最常用的是哪种数据格式？它有什么优缺点？<br>  工作中使用json多一点，有时使用pb。<br>pb:压缩效率算优点吧。改变结构需重新生成proto文件、proto怎么难阅读算不足之处","like_count":2,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498093,"discussion_content":"说的挺好，常用的序列化也就是这几种了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591941852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338335,"user_name":"孙新","can_delete":false,"product_type":"c1","uid":2875594,"ip_address":"","ucode":"A80038A479B943","user_header":"https://static001.geekbang.org/account/avatar/00/2b/e0/ca/adfaa551.jpg","comment_is_top":false,"comment_ctime":1647430619,"is_pvip":true,"replies":[{"id":"123726","content":"boost.json好像效率也不错，具体怎么样还是要自己做测试。","user_name":"作者回复","comment_id":338335,"uid":"1181974","ip_address":"","utype":1,"ctime":1647562339,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1647430619","product_id":100051801,"comment_content":"我们json用的boost做的编解码，不知道横向对比效率是个什么程度。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556867,"discussion_content":"boost.json好像效率也不错，具体怎么样还是要自己做测试。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647562339,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296486,"user_name":"Stephen","can_delete":false,"product_type":"c1","uid":1165201,"ip_address":"","ucode":"0D49223E6CB7B1","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ7mAt63VrbLZPHpeZxSc4IlBYswQSnaAB5wGePaGFDehgiaNfIxI1SJ5yIHIlmVk8hsw0RaoaSCPA/132","comment_is_top":false,"comment_ctime":1622995507,"is_pvip":false,"replies":[{"id":"107644","content":"序列化是把内存里数据做编码，而持久化是把内存里的数据存储到硬盘等介质上长期保存，两者有一点联系，但不完全相同。","user_name":"作者回复","comment_id":296486,"uid":"1181974","ip_address":"","utype":1,"ctime":1623027719,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"1622995507","product_id":100051801,"comment_content":"差点把序列化和持久化弄混了，差点答成memcpy是内存操作，不能持久化为文件。我知道json是可以持久化的，不知道另外两种可不可以。<br>","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521456,"discussion_content":"序列化是把内存里数据做编码，而持久化是把内存里的数据存储到硬盘等介质上长期保存，两者有一点联系，但不完全相同。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623027719,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":267497,"user_name":"严腾","can_delete":false,"product_type":"c1","uid":1627876,"ip_address":"","ucode":"3BEA0636A15D69","user_header":"https://static001.geekbang.org/account/avatar/00/18/d6/e4/fee14bd8.jpg","comment_is_top":false,"comment_ctime":1607771094,"is_pvip":false,"replies":[{"id":"97254","content":"这个时候就不行了，把类结构重新设计一下吧。","user_name":"作者回复","comment_id":267497,"uid":"1181974","ip_address":"","utype":1,"ctime":1607915630,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"1607771094","product_id":100051801,"comment_content":"message pack使用 MSGPACK_DEFINE 来处理自定义类，如果自定义类中有第三方库的成员变量，这时候该如何处理？<br>","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511658,"discussion_content":"这个时候就不行了，把类结构重新设计一下吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607915630,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":266026,"user_name":"Patrick","can_delete":false,"product_type":"c1","uid":1103919,"ip_address":"","ucode":"A49803CD6EB2C6","user_header":"https://static001.geekbang.org/account/avatar/00/10/d8/2f/43601694.jpg","comment_is_top":false,"comment_ctime":1607135752,"is_pvip":false,"replies":[{"id":"96740","content":"我试了一下，确实如此，比较奇怪。<br><br>解决的办法也很简单，把原来的一条语句改成两条，先得到handle，再得到obj就可以了。<br><br>GitHub上的源码已经修改。<br><br>    auto handle = msgpack::unpack(sbuf.data(), sbuf.size());<br>    auto obj = handle.get();<br>","user_name":"作者回复","comment_id":266026,"uid":"1181974","ip_address":"","utype":1,"ctime":1607304893,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"1607135752","product_id":100051801,"comment_content":"老师，您好；代码中的示例，关于msgpack.cpp，我遇见奇怪的问题，单独运行主函数的case3方法会出现std::bad_cast错误，意思是反序列化未能cast，但是如何case1()或者case2()与case3()一起运行，则就没有这问题了，我安装了最新的msgpack库，使用其中的msgpack.hpp，依旧不行。我不得其解，是什么原因造成的。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511126,"discussion_content":"我试了一下，确实如此，比较奇怪。\n\n解决的办法也很简单，把原来的一条语句改成两条，先得到handle，再得到obj就可以了。\n\nGitHub上的源码已经修改。\n\n    auto handle = msgpack::unpack(sbuf.data(), sbuf.size());\n    auto obj = handle.get();\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607304893,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250229,"user_name":"Sudouble","can_delete":false,"product_type":"c1","uid":1365574,"ip_address":"","ucode":"B369B09DAF8D20","user_header":"https://static001.geekbang.org/account/avatar/00/14/d6/46/5eb5261b.jpg","comment_is_top":false,"comment_ctime":1600999619,"is_pvip":true,"replies":[{"id":"91662","content":"说的很对。","user_name":"作者回复","comment_id":250229,"uid":"1181974","ip_address":"","utype":1,"ctime":1601011709,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"1600999619","product_id":100051801,"comment_content":"问题1的，不同机器，大小端，字节的对齐不一样，还原时会产生不一致的问题","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506157,"discussion_content":"说的很对。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601011709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236638,"user_name":"锦鲤","can_delete":false,"product_type":"c1","uid":1343717,"ip_address":"","ucode":"B9F1495E39F00A","user_header":"https://static001.geekbang.org/account/avatar/00/14/80/e5/251d89b5.jpg","comment_is_top":false,"comment_ctime":1595487502,"is_pvip":false,"replies":[{"id":"87433","content":"对gRPC了解不多，它自己就带C++支持吧，应该不需要其他框架支持了。","user_name":"作者回复","comment_id":236638,"uid":"1181974","ip_address":"","utype":1,"ctime":1595488174,"user_name_real":"罗剑锋"}],"discussion_count":2,"race_medal":0,"score":"1595487502","product_id":100051801,"comment_content":"C++服务端的gRPC框架有什么可以推荐的吗？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502156,"discussion_content":"对gRPC了解不多，它自己就带C++支持吧，应该不需要其他框架支持了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595488174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1355601,"avatar":"https://static001.geekbang.org/account/avatar/00/14/af/51/536f0747.jpg","nickname":"浔_Sendoh","note":"","ucode":"03DD5AD83D4DA6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293462,"discussion_content":"Tars 也不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595551225,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236154,"user_name":"海漩涡","can_delete":false,"product_type":"c1","uid":1426798,"ip_address":"","ucode":"4963172386B1A7","user_header":"https://static001.geekbang.org/account/avatar/00/15/c5/6e/604ec5d4.jpg","comment_is_top":false,"comment_ctime":1595330628,"is_pvip":false,"replies":[{"id":"87295","content":"嗯，Makefile是其他同学添加的，我没有写Makefile，可以直接用源码注释里的g++命令行编译，或者参考其他目录的Makefile自己写。","user_name":"作者回复","comment_id":236154,"uid":"1181974","ip_address":"","utype":1,"ctime":1595379275,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"1595330628","product_id":100051801,"comment_content":"section4里没有Makefile啊","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501963,"discussion_content":"嗯，Makefile是其他同学添加的，我没有写Makefile，可以直接用源码注释里的g++命令行编译，或者参考其他目录的Makefile自己写。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595379275,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":227979,"user_name":"群书","can_delete":false,"product_type":"c1","uid":1437036,"ip_address":"","ucode":"BA9EE71D2D818A","user_header":"https://static001.geekbang.org/account/avatar/00/15/ed/6c/6fb35017.jpg","comment_is_top":false,"comment_ctime":1592531799,"is_pvip":true,"replies":[{"id":"84051","content":"字节序问题确实是在网络传输时的一个比较头疼的问题，但对于序列化来说，不一定非要转换成网络序，只要两边用一致的约定即可。<br><br>pb内部具体怎么做的要看它的源码了，但作为用户我们并不需要关心实现的细节。","user_name":"作者回复","comment_id":227979,"uid":"1181974","ip_address":"","utype":1,"ctime":1592534503,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"1592531799","product_id":100051801,"comment_content":"做网络开发时 要将多字节数值型数据转换为网络字节序列兼容不同架构的机器，protobuf也有字节序列转化的过程吗","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498870,"discussion_content":"字节序问题确实是在网络传输时的一个比较头疼的问题，但对于序列化来说，不一定非要转换成网络序，只要两边用一致的约定即可。\n\npb内部具体怎么做的要看它的源码了，但作为用户我们并不需要关心实现的细节。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592534503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":226698,"user_name":"屈肖东","can_delete":false,"product_type":"c1","uid":1995346,"ip_address":"","ucode":"A6E2250A3CFEA5","user_header":"https://static001.geekbang.org/account/avatar/00/1e/72/52/8e81daf1.jpg","comment_is_top":false,"comment_ctime":1592187094,"is_pvip":false,"replies":[{"id":"83499","content":"这种做法就是最基本的序列化和反序列化了，但在数据大小、处理效率、易用性上肯定就没有json、msgpack等好。<br><br>","user_name":"作者回复","comment_id":226698,"uid":"1181974","ip_address":"","utype":1,"ctime":1592198694,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"1592187094","product_id":100051801,"comment_content":"有个问题，如果我把所有的要发送的数据类型，都转成字符数组，例如，int通过hton转为网络字节序，再转为4字节的字符数组，其他的也用类似的处理。在接收端，用相反的操作处理，再解出来，是不是也可以实现上面的这种功能。因为字符数组在网络中传递应该是不会因为编程语言和平台的区别而出现差别的。我不清楚我的这种处理跟序列化和反序列化的操作最终产生的效果有什么区别。仅仅是在通用行上的差别还是有其他更深刻的区别。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498337,"discussion_content":"这种做法就是最基本的序列化和反序列化了，但在数据大小、处理效率、易用性上肯定就没有json、msgpack等好。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592198694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":226016,"user_name":"wonderNick","can_delete":false,"product_type":"c1","uid":1146813,"ip_address":"","ucode":"855ABB9B4B2404","user_header":"https://static001.geekbang.org/account/avatar/00/11/7f/bd/6ba7d5a5.jpg","comment_is_top":false,"comment_ctime":1591928946,"is_pvip":false,"replies":[{"id":"83258","content":"是的，正如我在小贴士里说的，我不是太喜欢rapidjson的风格，而用json性能不是我的考虑范围。<br><br>json的C++库很多，按自己的需求来，选合适自己的。","user_name":"作者回复","comment_id":226016,"uid":"1181974","ip_address":"","utype":1,"ctime":1591930623,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"1591928946","product_id":100051801,"comment_content":"老师，您认为 rapidjson 和 json for modern C++ 两者的优劣势有哪些呢？<br>我们项目现在用的 rapidjson ，性能很好，但是易用性比 json for modern C++ 差一点。 正像   json for modern C++ 的名字一样，更现代一些，看起来有些像移动端的序列化工具（比如IOS的 handyjson）","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498080,"discussion_content":"是的，正如我在小贴士里说的，我不是太喜欢rapidjson的风格，而用json性能不是我的考虑范围。\n\njson的C++库很多，按自己的需求来，选合适自己的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591930623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225945,"user_name":"九三","can_delete":false,"product_type":"c1","uid":1454691,"ip_address":"","ucode":"7D093ED7273CBE","user_header":"https://static001.geekbang.org/account/avatar/00/16/32/63/fa24f92e.jpg","comment_is_top":false,"comment_ctime":1591917060,"is_pvip":false,"replies":[{"id":"83247","content":"这个要看官方文档了，也许有非官方的支持，毕竟pb非常流行。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591924133,"ip_address":"","comment_id":225945,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591917060","product_id":100051801,"comment_content":"objtibec是不是也可以用pb","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498052,"discussion_content":"这个要看官方文档了，也许有非官方的支持，毕竟pb非常流行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591924133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225342,"user_name":"浑浑噩噩cium","can_delete":false,"product_type":"c1","uid":1617939,"ip_address":"","ucode":"358C0BCFF62B40","user_header":"https://static001.geekbang.org/account/avatar/00/18/b0/13/5cb3459c.jpg","comment_is_top":false,"comment_ctime":1591718708,"is_pvip":false,"replies":[{"id":"82989","content":"csv的格式太简单，不适合有复杂结构的数据。而xml太笨重，我个人觉得现在用得比较少了。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591751162,"ip_address":"","comment_id":225342,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591718708","product_id":100051801,"comment_content":"还有csv，xml也用的比较多","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497812,"discussion_content":"csv的格式太简单，不适合有复杂结构的数据。而xml太笨重，我个人觉得现在用得比较少了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591751162,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225201,"user_name":"范闲","can_delete":false,"product_type":"c1","uid":1073125,"ip_address":"","ucode":"F21FD7DF6BA53C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","comment_is_top":false,"comment_ctime":1591682421,"is_pvip":false,"replies":[{"id":"82927","content":"用协议来理解序列化和反序列化也是个不错的角度，只是这个协议只规定了数据的格式，不涉及传输方式。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591691461,"ip_address":"","comment_id":225201,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591682421","product_id":100051801,"comment_content":"序列化和反序列化实际是通信内容的一个标准协议，有点像JVM，不区分平台只要同一套协议就可以互相通信","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497773,"discussion_content":"用协议来理解序列化和反序列化也是个不错的角度，只是这个协议只规定了数据的格式，不涉及传输方式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591691461,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225153,"user_name":"Confidant.","can_delete":false,"product_type":"c1","uid":1660039,"ip_address":"","ucode":"6E137F863906B0","user_header":"https://static001.geekbang.org/account/avatar/00/19/54/87/3b1f9de4.jpg","comment_is_top":false,"comment_ctime":1591667983,"is_pvip":false,"replies":[{"id":"82882","content":"中文没有特别权威的资料，网上的可以随便看，要学还是要看官方的。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591671547,"ip_address":"","comment_id":225153,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591667983","product_id":100051801,"comment_content":"老师能推荐点pb的资料吗，最好是中文的","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497756,"discussion_content":"中文没有特别权威的资料，网上的可以随便看，要学还是要看官方的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591671547,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225106,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1591659785,"is_pvip":false,"replies":[{"id":"82867","content":"大概的意思是对的，可以再多深入思考一下，是否还有更多的作用。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591664499,"ip_address":"","comment_id":225106,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591659785","product_id":100051801,"comment_content":"#1 感觉序列化&#47;反序列化要做的事是，把原有的一堆有实际意义的字节变的更小，更紧凑，又有点加密解密的感觉。memcpy貌似没有完成这两个任务。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497734,"discussion_content":"大概的意思是对的，可以再多深入思考一下，是否还有更多的作用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591664499,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225105,"user_name":"木瓜777","can_delete":false,"product_type":"c1","uid":1512537,"ip_address":"","ucode":"FC52A499AF6374","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/aFAYPyw7ywC1xE9h1qibnTBwtWn2ClJqlicy5cMomhZVaruMyqSq76wMkS279mUaGhrLGwWo9ZnW0WCWfmMovlXw/132","comment_is_top":false,"comment_ctime":1591659777,"is_pvip":false,"replies":[{"id":"82868","content":"这个还是要做个实际的测试吧，而且还跟数据类型、大小有关。<br><br>一般认为，msgpack比较轻巧，适合中小型项目，而pb强在它有很多外围的支持。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591664594,"ip_address":"","comment_id":225105,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591659777","product_id":100051801,"comment_content":"json,pb都使用过！目前项目中后端 我们自己手动序列化json为二进制，然后前端按字节解析，这样虽然比较自由，但比较繁琐！  pb是有作者说的那些问题，需要预定义结构！<br>我想问下，就序列化效率，还有 传输字节大小而言，messagepack、pb哪种更好？谢谢","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497733,"discussion_content":"这个还是要做个实际的测试吧，而且还跟数据类型、大小有关。\n\n一般认为，msgpack比较轻巧，适合中小型项目，而pb强在它有很多外围的支持。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591664594,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225096,"user_name":"lckfa李钊","can_delete":false,"product_type":"c1","uid":1356899,"ip_address":"","ucode":"AD13D205104AA6","user_header":"https://static001.geekbang.org/account/avatar/00/14/b4/63/84960032.jpg","comment_is_top":false,"comment_ctime":1591655322,"is_pvip":false,"replies":[{"id":"82869","content":"<br>1.我以前也用过thrift，在grpc出来之前，它的确是一个很好的选择。<br><br>2.说的好，这里面的关键就是两边可能对数据的理解不一致，最常见的就是大小端问题。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591664677,"ip_address":"","comment_id":225096,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591655322","product_id":100051801,"comment_content":"除了json，其他的两种倒是还没用过，另外，用的多的是Apache的Thrift库，用起来感觉和ProtoBuffer差不多；序列化是数据交换时打包的一种方式，在数据量比较大，而且需要和其他语言打交道时使用，本地序列化，发送，接收方接收后，反序列化，读取一气呵成。<br>如果直接copy内存做数据交换，接收方对数据的解析没有标准，而且容易出错。<br>","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497728,"discussion_content":"\n1.我以前也用过thrift，在grpc出来之前，它的确是一个很好的选择。\n\n2.说的好，这里面的关键就是两边可能对数据的理解不一致，最常见的就是大小端问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591664677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}