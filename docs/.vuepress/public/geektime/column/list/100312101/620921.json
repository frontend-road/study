{"id":620921,"title":"16｜Compiler编译：神乎其神的编译你是否有过胆怯？","content":"<p>你好，我是何辉。首先祝你新年快乐。</p><p>今天是我们深入研究Dubbo源码的第五篇，Compiler 编译。</p><p>在“<a href=\"https://time.geekbang.org/column/article/613319\">点点直连</a>”中，我们实现了一套万能管控平台来修复数据，其中就有通过市场上的 Groovy 插件编译 Java 源代码来生成类信息。</p><p>而上一讲“<a href=\"https://time.geekbang.org/column/article/620918\">Wrapper 机制</a>”中，在实现自定义代理的时候，我们也使用了 JavaCompiler 来编译源代码，只不过编译的时候，借助了磁盘上的 class 文件才得以生成类信息。</p><p>掌握了这两种动态编译方式，相信你在动态编译这块已经有了一定的基础，如果你还是觉得有点胆怯，今天我们上点难度，再学习 2 种 Compiler 方式，帮助你在底层框架开发层面拥有更强大的技术支撑。</p><h2>Javassist 编译</h2><p>还是以上一讲的自定义代理为例。这张图你应该还有印象，我们尝试通过添加一层代理的方式，把各种 if…else 的硬编码逻辑转变为动态生成：</p><p><img src=\"https://static001.geekbang.org/resource/image/b9/fa/b91da4e352be6f6246763e738f5356fa.jpg?wh=5052x1791\" alt=\"图片\"></p><p>在实现自定义代理的过程中，我们采用的是最纯粹的字符串拼接的方式，拼接出了动态的源代码，虽然实用，但是写起来也费劲。</p><p>有没有通过 set 或 get 操作就能实现创建类的简单方式，来改造图中的代理实现过程呢？</p><p>我们在脑内检索一番，平常都是直接将编写好的代码交给 Javac 编译器去编译的，现在要通过某种工具简单的进行 set 或 get 动态创建一个类，怎么办呢，突然灵光一闪，在上一讲“Wrapper 机制的原理”代码流程中，我们看到了一段 makeClass 的样例代码，难道 Dubbo 已经有了类似的先进操作么？</p><!-- [[[read_end]]] --><p>不管真假，我们先去验证看看，找到了相应的代码：</p><pre><code class=\"language-java\">// org.apache.dubbo.common.bytecode.ClassGenerator#toClass(java.lang.Class&lt;?&gt;, java.lang.ClassLoader, java.security.ProtectionDomain)\npublic Class&lt;?&gt; toClass(Class&lt;?&gt; neighborClass, ClassLoader loader, ProtectionDomain pd) {\n    if (mCtc != null) {\n        mCtc.detach();\n    }\n    // 自增长类名尾巴序列号，类似 $Proxy_01.class&nbsp;这种 JDK 代理名称的 01 数字\n    long id = CLASS_NAME_COUNTER.getAndIncrement();\n    try {\n        // 从 ClassPool 中获取 mSuperClass 类的类型\n        // 我们一般还可以用 mPool 来看看任意类路径对应的 CtClass 类型对象是什么\n        // 比如可以通过 mPool.get(\"java.lang.String\") 看看 String 的 CtClass 类型对象是什么\n        // 之所以要这么做，主要是为了迎合这样的API语法而操作的\n        CtClass ctcs = mSuperClass == null ? null : mPool.get(mSuperClass);\n        if (mClassName == null) {\n            mClassName = (mSuperClass == null || javassist.Modifier.isPublic(ctcs.getModifiers())\n                    ? ClassGenerator.class.getName() : mSuperClass + \"$sc\") + id;\n        }\n        // 通过 ClassPool 来创建一个叫 mClassName 名字的类\n        mCtc = mPool.makeClass(mClassName);\n        if (mSuperClass != null) {\n            // 然后设置一下 mCtc 这个新创建类的父类为 ctcs\n            mCtc.setSuperclass(ctcs);\n        }\n        // 为 mCtc 新建类添加一个实现的接口\n        mCtc.addInterface(mPool.get(DC.class.getName())); // add dynamic class tag.\n        if (mInterfaces != null) {\n            for (String cl : mInterfaces) {\n                mCtc.addInterface(mPool.get(cl));\n            }\n        }\n        // 为 mCtc 新建类添加一些字段\n        if (mFields != null) {\n            for (String code : mFields) {\n                mCtc.addField(CtField.make(code, mCtc));\n            }\n        }\n        // 为 mCtc 新建类添加一些方法\n        if (mMethods != null) {\n            for (String code : mMethods) {\n                if (code.charAt(0) == ':') {\n                    mCtc.addMethod(CtNewMethod.copy(getCtMethod(mCopyMethods.get(code.substring(1))),\n                            code.substring(1, code.indexOf('(')), mCtc, null));\n                } else {\n                    mCtc.addMethod(CtNewMethod.make(code, mCtc));\n                }\n            }\n        }\n        // 为 mCtc 新建类添加一些构造方法\n        if (mDefaultConstructor) {\n            mCtc.addConstructor(CtNewConstructor.defaultConstructor(mCtc));\n        }\n        if (mConstructors != null) {\n            for (String code : mConstructors) {\n                if (code.charAt(0) == ':') {\n                    mCtc.addConstructor(CtNewConstructor\n                            .copy(getCtConstructor(mCopyConstructors.get(code.substring(1))), mCtc, null));\n                } else {\n                    String[] sn = mCtc.getSimpleName().split(\"\\\\$+\"); // inner class name include $.\n                    mCtc.addConstructor(\n                            CtNewConstructor.make(code.replaceFirst(SIMPLE_NAME_TAG, sn[sn.length - 1]), mCtc));\n                }\n            }\n        }\n        // 将 mCtc 新创建的类转成 Class 对象\n        try {\n            return mPool.toClass(mCtc, neighborClass, loader, pd);\n        } catch (Throwable t) {\n            if (!(t instanceof CannotCompileException)) {\n                return mPool.toClass(mCtc, loader, pd);\n            }\n            throw t;\n        }\n    } catch (RuntimeException e) {\n        throw e;\n    } catch (NotFoundException | CannotCompileException e) {\n        throw new RuntimeException(e.getMessage(), e);\n    }\n}\n</code></pre><p>凭着印象从代码中找到了一些特别有趣的 API，比如 setSuperclass 设置父类属性、addInterface 添加实现类属性、addField 添加字段、addMethod 添加方法、addConstructor 添加构造方法等等。刚刚还在寻思，有没有一种简单的赋值操作的方式来创建类，结果就发现了意外收获，从名字上看，感觉这些 API 都和类创建有关，好像都能用上。</p><p>我们继续深挖，发现<strong>这些 API 都是属于 Javassist 插件中的</strong>，这就难怪了，既然该插件能提供这样的 API 来创建类，如果不将这些类最终编译成为 Class 类信息，未免也有点做事做半截的感觉。</p><p>不过这只是我们从源码层面的推测，到底有没有这个效果呢，还是要确认一下。至于如何确认，我给个小小的建议，如果你在源码中发现一些比较感兴趣的插件，可以去官方网站大致了解一下，也许疑惑和推测也就烟消云散了。</p><p>我们进入 <a href=\"http://www.javassist.org/\">Javassist 的官网</a>会看到这段英文解释：</p><blockquote>\n<p>Javassist (Java Programming Assistant) makes Java bytecode manipulation simple. It is a class library for editing bytecodes in Java; it enables Java programs to define a new class at runtime and to modify a class file when the JVM loads it. Unlike other similar bytecode editors, Javassist provides two levels of API: source level and bytecode level. If the users use the source-level API, they can edit a class file without knowledge of the specifications of the Java bytecode. The whole API is designed with only the vocabulary of the Java language. You can even specify inserted bytecode in the form of source text;<strong>Javassist compiles it on the fly</strong>. On the other hand, the bytecode-level API allows the users to directly edit a class file as other editors.</p>\n</blockquote><p>大致含义就是，Javassist 让用 Java 编辑字节码变为一件非常简单的事情，众多开发人员可以在不懂字节码规范的情况下，针对字节码文件进行编辑修改，改完之后 Javassist 可以实时编译它。</p><p>这下验证了我们刚才对源码的猜想。是不是很兴奋又接触到了新技术，别着急，我们还是先看<a href=\"http://www.javassist.org/tutorial/tutorial.html\">官网关于 API 介绍的教程</a>。</p><p>基本了解如何使用之后，上一讲的代码模板，我们可以用 Javassist 实现一遍，代码如下：</p><pre><code class=\"language-java\">///////////////////////////////////////////////////\n// 采用 Javassist&nbsp;的 API 来动态创建代码模板\n///////////////////////////////////////////////////\npublic class JavassistProxyUtils {\n    private static final AtomicInteger INC = new AtomicInteger();\n    public static Object newProxyInstance(Object sourceTarget) throws Exception{\n        // ClassPool：Class对象的容器\n        ClassPool pool = ClassPool.getDefault();\n        \n        // 通过ClassPool生成一个public类\n        Class&lt;?&gt; targetClazz = sourceTarget.getClass().getInterfaces()[0];\n        String proxyClassName = \"$\" + targetClazz.getSimpleName() + \"CustomInvoker_\" + INC.incrementAndGet();\n        CtClass ctClass = pool.makeClass(proxyClassName);\n        ctClass.setSuperclass(pool.get(\"com.hmilyylimh.cloud.compiler.custom.CustomInvoker\"));\n        \n        // 添加方法  public Object invokeMethod(Object instance, String mtdName, Class&lt;?&gt;[] types, Object[] args) throws NoSuchMethodException { {...}\n        CtClass returnType = pool.get(\"java.lang.Object\");\n        CtMethod newMethod=new CtMethod(\n                returnType,\n                \"invokeMethod\",\n                new CtClass[]{ returnType, pool.get(\"java.lang.String\"), pool.get(\"java.lang.Class[]\"), pool.get(\"java.lang.Object[]\") },\n                ctClass);\n        newMethod.setModifiers(Modifier.PUBLIC);\n        newMethod.setBody(buildBody(targetClazz).toString());\n        ctClass.addMethod(newMethod);\n        \n        // 生成 class 类\n        Class&lt;?&gt; clazz = ctClass.toClass();\n        \n        // 将 class 文件写到 target 目录下，方便调试查看\n        String filePath = JavassistProxyUtils.class.getResource(\"/\").getPath()\n                + JavassistProxyUtils.class.getPackage().toString().substring(\"package \".length()).replaceAll(\"\\\\.\", \"/\");\n        ctClass.writeFile(filePath);\n        \n        // 反射实例化创建对象\n        return clazz.newInstance();\n    }\n    // 构建方法的内容字符串\n    private static StringBuilder buildBody(Class&lt;?&gt; targetClazz) {\n        StringBuilder sb = new StringBuilder(\"{\\n\");\n        for (Method method : targetClazz.getDeclaredMethods()) {\n            String methodName = method.getName();\n            Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();\n            // if (\"sayHello\".equals(mtdName)) {\n            String ifHead = \"if (\\\"\" + methodName + \"\\\".equals($2)) {\\n\";\n            // return ((DemoFacade) instance).sayHello(String.valueOf(args[0]));\n            String ifContent = null;\n            // 这里有 bug ，姑且就入参就传一个入参对象吧\n            if(parameterTypes.length != 0){\n                ifContent = \"return ((\" + targetClazz.getName() + \") $1).\" + methodName + \"(\" + String.class.getName() + \".valueOf($4[0]));\\n\";\n            } else {\n                ifContent = \"return ((\" + targetClazz.getName() + \") $1).\" + methodName + \"();\\n\";\n            }\n            // }\n            String ifTail = \"}\\n\";\n            sb.append(ifHead).append(ifContent).append(ifTail);\n        }\n        // throw new NoSuchMethodException(\"Method [\" + mtdName + \"] not found.\");\n        String invokeMethodTailContent = \"throw new \" + org.apache.dubbo.common.bytecode.NoSuchMethodException.class.getName() + \"(\\\"Method [\\\" + $2 + \\\"] not found.\\\");\\n}\\n\";\n        sb.append(invokeMethodTailContent);\n        return sb;\n    }\n}\n</code></pre><p>可以发现确实比拼接字符串简单多了，而且 API 使用起来也比较清晰明了，完全按照平常的专业术语命名规范，马上就能找到对应的 API，根本不需要花很多准备工作。</p><p>改造代码需要注意 3 点。</p><ol>\n<li>在获取各种类对应的 CtClass 类型对象时，可以通过从 ClassPool 的 get 方法中传入类路径得到。</li>\n<li>在对方法的入参字段名进行逻辑处理时，<a href=\"http://www.javassist.org/tutorial/tutorial2.html#intro\">就得替换成 $ 占位符</a>，方法中的 this 引用，用 <span dollar=\"\">$</span>0 表示，方法中的第一个参数用 <span dollar=\"\">$</span>1 表示，第二个参数用 <span dollar=\"\">$</span>2 表示，以此类推。</li>\n<li>若要重写的父类的方法，是否设置 @Override 属性不太重要，但是千万别为了重写而拿父类的 CtMethod 属性一顿乱改。</li>\n</ol><p>用新方案编译源代码后，我们验证一下结果，编写测试验证代码。</p><pre><code class=\"language-java\">public static void main(String[] args) throws Exception {\n    // 创建源对象（即被代理对象）\n    DemoFacadeImpl demoFacade = new DemoFacadeImpl();\n    // 生成自定义的代理类\n    CustomInvoker invoker = (CustomInvoker) JavassistProxyUtils.newProxyInstance(demoFacade);\n    // 调用代理类的方法\n    invoker.invokeMethod(demoFacade, \"sayHello\", new Class[]{String.class}, new Object[]{\"Geek\"});\n}\n</code></pre><p>如预期所料，正常打印出了结果，没想到一句简短的 CtClass.toClass() 方法就帮我们快速编译代码并转成 Class 对象信息了，非常简单实用。</p><h2>ASM 编译</h2><p>现在你有没有觉得信心大增，原来操作字节码这么简单，Javassist 简直是神器，有了它的存在，我想你再去理解那些 Java Agent 技术知识点，会发现在编译的世界修改字节码已经是小菜一碟了。</p><p>不过做技术我们讲究精益求精，既然 Javassist 这么好用，为什么公司的大佬还在用 ASM 进行操作呢？</p><p>其实，ASM 是一款侧重于性能的字节码插件，属于一种轻量级的高性能字节码插件，但同时实现的难度系数也会变大。这么讲你也许会好奇了，能有多难？</p><p>我们还是举例来看，例子是把敏感字段加密存储到数据库。</p><p><img src=\"https://static001.geekbang.org/resource/image/5b/27/5bf85393a03bc7dff684c6ce5fb35f27.jpg?wh=1920x1047\" alt=\"图片\"></p><pre><code class=\"language-java\">public class UserBean {\n    private String name;\n    public UserBean(String name) { this.name = name; }\n    public String getName() { return name; }\n    public void setName(String name) { this.name = name; }\n    @Override\n    public String toString() { return \"UserBean{name='\" + name + '\\'' + '}'; }\n}\n</code></pre><p>上层业务有一个对象，创建对象后，需要给对象的 setName 方法进行赋值。</p><p>如果想要给传入的 name 字段进行加密，一般我们会这么做。</p><pre><code class=\"language-java\">// 先创建一个对象\nUserBean userBean = new UserBean();\n// 将即将赋值的 Geek 先加密，然后设置到 userBean 对象中\nuserBean.setName(AESUtils.encrypt(\"Geek\"));\n// 最后将 userBean 插入到数据库中\nuserDao.insertData(userBean);\n</code></pre><p>把传入 setName 的值先进行加密处理，然后把加密后的值放到 userBean 对象中，在入库时，就能把密文写到数据库了。</p><p>但是这样就显得很累赘，今天这个字段需要加密，明天那个字段需要加密，那就没完没了，于是有人就想到了，可以将加密的这段操作内嵌到代理对象中，比如这样：</p><p><img src=\"https://static001.geekbang.org/resource/image/1e/64/1ef8c1e6337e3ea59129cb585597ac64.jpg?wh=1920x1091\" alt=\"图片\"></p><p>在上层业务中，该怎么赋值还是继续怎么赋值，不用感知加密的操作，所有加密的逻辑全部内嵌到代理对象中。当然，如果这么做，就得设计一个代码模板，借助自定义代理的经验，想必你也有了设计思路：</p><pre><code class=\"language-java\">///////////////////////////////////////////////////\n// 代码模板，将 UserBean 变成了 UserBeanHandler 代理对象，并且实现一个自己定义的 Handler 接口\n///////////////////////////////////////////////////\npublic class UserBeanHandler implements Handler&lt;UserBean&gt; {\n    @Override\n    public void addBefore(UserBean u) {\n        if (u.getName() != null &amp;&amp; u.getName().length() &gt; 0) {\n            // 我这里仅仅只是告诉大家我针对了 name 的这个字段做了处理，\n            // 以后大家应用到实际项目中的话，可以在这里将我们的 name 字段进行加密处理\n            u.setName(\"#BEFORE#\" + u.getName());\n        }\n    }\n}\n\n///////////////////////////////////////////////////\n// 配合代码模板设计出来的一个接口\n///////////////////////////////////////////////////\npublic interface Handler&lt;T&gt; {\n    public void addBefore(T t);\n}\n</code></pre><p>代码模板的思路也很简单，主要注意 2 点。</p><ul>\n<li>设计一个对象的代理类，暴露一个 addBefore 方法来将字段进行加密操作。</li>\n<li>代理类为了迎合具备一个 addBefore 方法，就得设计出一个接口，避免 Java 类单继承无法扩展的瓶颈。</li>\n</ul><p>代码模板是定义好了，可是操作字节码的时候，去哪里弄到该 UserBeanHandler 的字节码呢？</p><p>其实 IDEA 工具已经为你预留了一个查看字节码的入口。</p><p><img src=\"https://static001.geekbang.org/resource/image/c4/02/c4bf3ac60d620638a7351139e8d39e02.png?wh=1920x1290\" alt=\"图片\"></p><p>选中代码模板后，展开顶部的 View 菜单，选中 Show Bytecode 看到该类对应的字节码。</p><pre><code class=\"language-java\">// class version 50.0 (50)\n// access flags 0x21\n// signature Ljava/lang/Object;Lcom/hmilyylimh/cloud/compiler/asm/Handler&lt;Lcom/hmilyylimh/cloud/compiler/asm/UserBean;&gt;;\n// declaration: com/hmilyylimh/cloud/compiler/asm/UserBeanHandler implements com.hmilyylimh.cloud.compiler.asm.Handler&lt;com.hmilyylimh.cloud.compiler.asm.UserBean&gt;\npublic class com/hmilyylimh/cloud/compiler/asm/UserBeanHandler extends Ljava/lang/Object; implements com/hmilyylimh/cloud/compiler/asm/Handler {\n\n&nbsp; // compiled from: UserBeanHandler.java\n\n&nbsp; // access flags 0x1\n&nbsp; public &lt;init&gt;()V\n&nbsp; &nbsp; ALOAD 0\n&nbsp; &nbsp; INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n&nbsp; &nbsp; RETURN\n&nbsp; &nbsp; MAXSTACK = 1\n&nbsp; &nbsp; MAXLOCALS = 1\n\n&nbsp; // access flags 0x1\n&nbsp; public addBefore(Lcom/hmilyylimh/cloud/compiler/asm/UserBean;)V\n&nbsp; &nbsp; ALOAD 1\n&nbsp; &nbsp; INVOKEVIRTUAL com/hmilyylimh/cloud/compiler/asm/UserBean.getName ()Ljava/lang/String;\n&nbsp; &nbsp; IFNULL L0\n&nbsp; &nbsp; ALOAD 1\n&nbsp; &nbsp; INVOKEVIRTUAL com/hmilyylimh/cloud/compiler/asm/UserBean.getName ()Ljava/lang/String;\n&nbsp; &nbsp; INVOKEVIRTUAL java/lang/String.length ()I\n&nbsp; &nbsp; IFLE L0\n&nbsp; &nbsp; ALOAD 1\n&nbsp; &nbsp; NEW java/lang/StringBuilder\n&nbsp; &nbsp; DUP\n&nbsp; &nbsp; INVOKESPECIAL java/lang/StringBuilder.&lt;init&gt; ()V\n&nbsp; &nbsp; LDC \"#BEFORE#\"\n&nbsp; &nbsp; INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder;\n&nbsp; &nbsp; ALOAD 1\n&nbsp; &nbsp; INVOKEVIRTUAL com/hmilyylimh/cloud/compiler/asm/UserBean.getName ()Ljava/lang/String;\n&nbsp; &nbsp; INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder;\n&nbsp; &nbsp; INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;\n&nbsp; &nbsp; INVOKEVIRTUAL com/hmilyylimh/cloud/compiler/asm/UserBean.setName (Ljava/lang/String;)V\n&nbsp; &nbsp;L0\n&nbsp; &nbsp;FRAME SAME\n&nbsp; &nbsp; RETURN\n&nbsp; &nbsp; MAXSTACK = 3\n&nbsp; &nbsp; MAXLOCALS = 2\n\n&nbsp; // access flags 0x1041\n&nbsp; public synthetic bridge addBefore(Ljava/lang/Object;)V\n&nbsp; &nbsp; ALOAD 0\n&nbsp; &nbsp; ALOAD 1\n&nbsp; &nbsp; CHECKCAST com/hmilyylimh/cloud/compiler/asm/UserBean\n&nbsp; &nbsp; INVOKEVIRTUAL com/hmilyylimh/cloud/compiler/asm/UserBeanHandler.addBefore (Lcom/hmilyylimh/cloud/compiler/asm/UserBean;)V\n&nbsp; &nbsp; RETURN\n&nbsp; &nbsp; MAXSTACK = 2\n&nbsp; &nbsp; MAXLOCALS = 2\n}\n</code></pre><p>看到一大片密密麻麻的字节码指令，想必你已经头都大了，不过别慌，这个问题在 <a href=\"https://asm.ow2.io/developer-guide.html\">ASM 的官网指引</a> 中也解答了，我们只需要按部就班把字节码指令翻译成为 Java 代码就可以了。</p><p>好吧，既然官网都这么贴心了，那就勉强当一回工具人，我们按照官网的指示，依葫芦画瓢把代码模板翻译出来。</p><p>经过一番漫长的翻译之后，我们终于写出了自己看看都觉得头皮发麻的长篇大论的代码，关键位置我都加注释了。</p><pre><code class=\"language-java\">///////////////////////////////////////////////////\n// ASM 字节码操作的代理工具类\n///////////////////////////////////////////////////\npublic class AsmProxyUtils implements Opcodes {\n    /**\n     * &lt;h2&gt;创建代理对象。&lt;/h2&gt;\n     *\n     * @param originClass：样例：UserBean.class\n     * @return\n     */\n    public static Object newProxyInstance(Class originClass) throws Exception{\n        String newClzNameSuffix = \"Handler\";\n        byte[] classBytes = generateByteCode(originClass, newClzNameSuffix);\n        \n        // 可以想办法将 classBytes 存储为一个文件\n        String filePath = AsmProxyUtils.class.getResource(\"/\").getPath()\n                + AsmProxyUtils.class.getPackage().toString().substring(\"package \".length()).replaceAll(\"\\\\.\", \"/\");\n        FileOutputStream fileOutputStream = new FileOutputStream(new File(filePath,\n                originClass.getSimpleName() + newClzNameSuffix + \".class\"));\n        fileOutputStream.write(classBytes);\n        fileOutputStream.close();\n        \n        // 还得把 classBytes 加载到 JVM 内存中去\n        ClassLoader loader = Thread.currentThread().getContextClassLoader();\n        Class&lt;?&gt; loaderClass = Class.forName(\"java.lang.ClassLoader\");\n        Method defineClassMethod = loaderClass.getDeclaredMethod(\"defineClass\",\n                String.class,\n                byte[].class,\n                int.class,\n                int.class);\n        defineClassMethod.setAccessible(true);\n        Object respObject = defineClassMethod.invoke(loader, new Object[]{\n                originClass.getName() + newClzNameSuffix,\n                classBytes,\n                0,\n                classBytes.length\n        });\n        \n        // 实例化对象\n        return ((Class)respObject).newInstance();\n    }\n    /**\n     * &lt;h2&gt;生成字节码的核心。&lt;/h2&gt;&lt;br/&gt;\n     *\n     * &lt;li&gt;&lt;h2&gt;注意：接下来的重点就是如何用asm来动态产生一个 UserBeanHandler 类。&lt;/h2&gt;&lt;/li&gt;\n     *\n     * @param originClass：样例：UserBean.class\n     * @param newClzNameSuffix： 样例：Handler\n     * @return\n     */\n    private static byte[] generateByteCode(Class originClass, String newClzNameSuffix) {\n        String newClassSimpleNameAndSuffix = originClass.getSimpleName() + newClzNameSuffix + \".java\";\n        /**********************************************************************/\n        // 利用 ASM 编写创建类文件头的相关信息\n        /**********************************************************************/\n        ClassWriter classWriter = new ClassWriter(0);\n        /////////////////////////////////////////////////////////\n        // class version 50.0 (50)\n        // access flags 0x21\n        // signature Ljava/lang/Object;Lcom/hmilyylimh/cloud/compiler/asm/Handler&lt;Lcom/hmilyylimh/cloud/compiler/asm/UserBean;&gt;;\n        // declaration: com/hmilyylimh/cloud/compiler/asm/UserBeanHandler implements com.hmilyylimh.cloud.compiler.asm.UserBean&lt;com.hmilyylimh.cloud.compiler.asm.UserBean&gt;\n        // public class com/hmilyylimh/cloud/compiler/asm/UserBeanHandler extends Ljava/lang/Object; implements com/hmilyylimh/cloud/compiler/asm/Handler {\n        /////////////////////////////////////////////////////////\n        classWriter.visit(\n                V1_6,\n                ACC_PUBLIC + ACC_SUPER,\n                Type.getInternalName(originClass) + newClzNameSuffix,\n                Type.getDescriptor(Object.class)+Type.getDescriptor(Handler.class).replace(\";\",\"\")+\"&lt;\"+Type.getDescriptor(originClass)+\"&gt;;\",\n                Type.getDescriptor(Object.class),\n                new String[]{ Type.getInternalName(Handler.class) }\n        );\n        /////////////////////////////////////////////////////////\n        // UserBeanHandler.java\n        /////////////////////////////////////////////////////////\n        classWriter.visitSource(newClassSimpleNameAndSuffix, null);\n        /**********************************************************************/\n        // 创建构造方法\n        /**********************************************************************/\n        /////////////////////////////////////////////////////////\n        // compiled from: UserBeanHandler.java\n        // access flags 0x1\n        // public &lt;init&gt;()V\n        /////////////////////////////////////////////////////////\n        MethodVisitor initMethodVisitor = classWriter.visitMethod(\n                ACC_PUBLIC,\n                \"&lt;init&gt;\",\n                \"()V\",\n                null,\n                null\n        );\n        initMethodVisitor.visitCode();\n        /////////////////////////////////////////////////////////\n        // ALOAD 0\n        // INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n        // RETURN\n        /////////////////////////////////////////////////////////\n        initMethodVisitor.visitVarInsn(ALOAD, 0);\n        initMethodVisitor.visitMethodInsn(INVOKESPECIAL,\n                Type.getInternalName(Object.class),\n                \"&lt;init&gt;\",\n                \"()V\"\n                );\n        initMethodVisitor.visitInsn(RETURN);\n        /////////////////////////////////////////////////////////\n        // MAXSTACK = 1\n        // MAXLOCALS = 1\n        /////////////////////////////////////////////////////////\n        initMethodVisitor.visitMaxs(1, 1);\n        initMethodVisitor.visitEnd();\n\n        /**********************************************************************/\n        // 创建 addBefore 方法\n        /**********************************************************************/\n        /////////////////////////////////////////////////////////\n        // access flags 0x1\n        // public addBefore(Lcom/hmilyylimh/cloud/compiler/asm/UserBean;)V\n        /////////////////////////////////////////////////////////\n        MethodVisitor addBeforeMethodVisitor = classWriter.visitMethod(\n                ACC_PUBLIC,\n                \"addBefore\",\n                \"(\" + Type.getDescriptor(originClass) + \")V\",\n                null,\n                null\n        );\n        addBeforeMethodVisitor.visitCode();\n        /////////////////////////////////////////////////////////\n        // ALOAD 1\n        // INVOKEVIRTUAL com/hmilyylimh/cloud/compiler/asm/UserBean.getName ()Ljava/lang/String;\n        /////////////////////////////////////////////////////////\n        addBeforeMethodVisitor.visitVarInsn(ALOAD, 1);\n        addBeforeMethodVisitor.visitMethodInsn(INVOKEVIRTUAL,\n                Type.getInternalName(originClass),\n                \"getName\",\n                \"()\" + Type.getDescriptor(String.class));\n        /////////////////////////////////////////////////////////\n        // IFNULL L0\n        // ALOAD 1\n        // INVOKEVIRTUAL com/hmilyylimh/cloud/compiler/asm/UserBean.getName ()Ljava/lang/String;\n        // INVOKEVIRTUAL java/lang/String.length ()I\n        // IFLE L0\n        /////////////////////////////////////////////////////////\n        Label L0 = new Label();\n        addBeforeMethodVisitor.visitJumpInsn(IFNULL, L0);\n        addBeforeMethodVisitor.visitVarInsn(ALOAD, 1);\n        addBeforeMethodVisitor.visitMethodInsn(INVOKEVIRTUAL,\n                Type.getInternalName(originClass),\n                \"getName\",\n                \"()\" + Type.getDescriptor(String.class));\n        addBeforeMethodVisitor.visitMethodInsn(INVOKEVIRTUAL,\n                Type.getInternalName(String.class),\n                \"length\",\n                \"()I\");\n        addBeforeMethodVisitor.visitJumpInsn(IFLE, L0);\n        /**********************************************************************/\n        // 接下来要干的事情就是：u.setName(\"#BEFORE#\" + u.getName());\n        /**********************************************************************/\n        /////////////////////////////////////////////////////////\n        // ALOAD 1\n        // NEW java/lang/StringBuilder\n        // DUP\n        /////////////////////////////////////////////////////////\n        addBeforeMethodVisitor.visitVarInsn(ALOAD, 1);\n        addBeforeMethodVisitor.visitTypeInsn(NEW, Type.getInternalName(StringBuilder.class));\n        addBeforeMethodVisitor.visitInsn(DUP);\n        /////////////////////////////////////////////////////////\n        // INVOKESPECIAL java/lang/StringBuilder.&lt;init&gt; ()V\n        // LDC \"#BEFORE#\"\n        // INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder;\n        /////////////////////////////////////////////////////////\n        addBeforeMethodVisitor.visitMethodInsn(INVOKESPECIAL,\n                Type.getInternalName(StringBuilder.class),\n                \"&lt;init&gt;\",\n                \"()V\");\n        addBeforeMethodVisitor.visitLdcInsn(\"#BEFORE#\");\n        addBeforeMethodVisitor.visitMethodInsn(INVOKEVIRTUAL,\n                Type.getInternalName(StringBuilder.class),\n                \"append\",\n                \"(\"+ Type.getDescriptor(String.class) + \")\" + Type.getDescriptor(StringBuilder.class));\n        /////////////////////////////////////////////////////////\n        // ALOAD 1\n        // INVOKEVIRTUAL com/hmilyylimh/cloud/compiler/asm/UserBean.getName ()Ljava/lang/String;\n        // INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder;\n        // NVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;\n        // INVOKEVIRTUAL com/hmilyylimh/cloud/compiler/asm/UserBean.setName (Ljava/lang/String;)V\n        /////////////////////////////////////////////////////////\n        addBeforeMethodVisitor.visitVarInsn(ALOAD, 1);\n        addBeforeMethodVisitor.visitMethodInsn(INVOKEVIRTUAL,\n                Type.getInternalName(originClass),\n                \"getName\",\n                \"()\" + Type.getDescriptor(String.class));\n        addBeforeMethodVisitor.visitMethodInsn(INVOKEVIRTUAL,\n                Type.getInternalName(StringBuilder.class),\n                \"append\",\n                \"(\"+ Type.getDescriptor(String.class) + \")\" + Type.getDescriptor(StringBuilder.class));\n        addBeforeMethodVisitor.visitMethodInsn(INVOKEVIRTUAL,\n                Type.getInternalName(StringBuilder.class),\n                \"toString\",\n                \"()\" + Type.getDescriptor(String.class));\n        addBeforeMethodVisitor.visitMethodInsn(INVOKEVIRTUAL,\n                Type.getInternalName(originClass),\n                \"setName\",\n                \"(\" + Type.getDescriptor(String.class)+\")V\");\n        /////////////////////////////////////////////////////////\n        // L0\n        // FRAME SAME\n        // RETURN\n        /////////////////////////////////////////////////////////\n        addBeforeMethodVisitor.visitLabel(L0);\n        addBeforeMethodVisitor.visitFrame(F_SAME, 0, null, 0, null);\n        addBeforeMethodVisitor.visitInsn(RETURN);\n        /////////////////////////////////////////////////////////\n        // LMAXSTACK = 3\n        // MAXLOCALS = 2\n        /////////////////////////////////////////////////////////\n        addBeforeMethodVisitor.visitMaxs(3, 2);\n        addBeforeMethodVisitor.visitEnd();\n        /**********************************************************************/\n        // 创建桥接 addBefore 方法\n        /**********************************************************************/\n        /////////////////////////////////////////////////////////\n        // access flags 0x1041\n        // public synthetic bridge addBefore(Ljava/lang/Object;)V\n        /////////////////////////////////////////////////////////\n        MethodVisitor bridgeAddBeforeMethodVisitor = classWriter.visitMethod(ACC_PUBLIC + ACC_SYNTHETIC + ACC_BRIDGE,\n                \"addBefore\",\n                \"(\" + Type.getDescriptor(Object.class) + \")V\",\n                null,\n                null\n        );\n        bridgeAddBeforeMethodVisitor.visitCode();\n        /////////////////////////////////////////////////////////\n        // ALOAD 0\n        // ALOAD 1\n        /////////////////////////////////////////////////////////\n        bridgeAddBeforeMethodVisitor.visitVarInsn(ALOAD, 0);\n        bridgeAddBeforeMethodVisitor.visitVarInsn(ALOAD, 1);\n        /////////////////////////////////////////////////////////\n        // CHECKCAST com/hmilyylimh/cloud/compiler/asm/UserBean\n        // INVOKEVIRTUAL com/hmilyylimh/cloud/compiler/asm/UserBeanHandler.addBefore (Lcom/hmilyylimh/cloud/compiler/asm/UserBean;)V\n        // RETURN\n        /////////////////////////////////////////////////////////\n        bridgeAddBeforeMethodVisitor.visitTypeInsn(CHECKCAST, Type.getInternalName(originClass));\n        bridgeAddBeforeMethodVisitor.visitMethodInsn(INVOKEVIRTUAL,\n                Type.getInternalName(originClass) + newClzNameSuffix,\n                \"addBefore\",\n                \"(\" + Type.getDescriptor(originClass) + \")V\");\n        bridgeAddBeforeMethodVisitor.visitInsn(RETURN);\n        /////////////////////////////////////////////////////////\n        // MAXSTACK = 2\n        // MAXLOCALS = 2\n        /////////////////////////////////////////////////////////\n        bridgeAddBeforeMethodVisitor.visitMaxs(2, 2);\n        bridgeAddBeforeMethodVisitor.visitEnd();\n        /**********************************************************************/\n        // 创建结束\n        /**********************************************************************/\n        classWriter.visitEnd();\n        return classWriter.toByteArray();\n    }\n}\n</code></pre><p>写的过程有些卡壳，难度系数也不低，我们有 3 个小点要注意。</p><ul>\n<li>有些字节码指令不知道如何使用 ASM API，比如 INVOKESPECIAL 不知道怎么调用 API，你可以网络检索一下“<strong>MethodVisitor INVOKESPECIAL</strong>”关键字，就能轻松找到与之对应的 API 了。</li>\n<li>重点关注调用 API 各参数的位置，千万别放错了，否则问题排查起来比较费时间。</li>\n<li>生成的字节码文件直接保存到文件中，然后利用 ClassLoader.defineClass 方法，把字节码交给 JVM 虚拟机直接变成一个 Class 类型实例。</li>\n</ul><p>在写的时候，你一定要沉下心慢慢转换，一步都不能错，否则时间浪费了还得不到有效的成果。</p><p>写好之后，你一定非常兴奋，我们还是先写个测试代码验证一下：</p><pre><code class=\"language-java\">public static void main(String[] args) throws Exception {\n    UserBean userBean = new UserBean(\"Geek\");\n    // 从 mybatis 的拦截器里面拿到了准备更新 db 的数据对象，然后创建代理对象\n    Handler handler = (Handler) AsmProxyUtils.newProxyInstance(userBean.getClass());\n    // 关键的一步，在 mybatis 中模拟将入参对象进行加密操作\n    handler.addBefore(userBean);\n    // 这里为了观察效果，先打印一下 userBean 的内容看看\n    System.out.println(userBean);\n    \n    // 接下来，假设有执行 db 的操作，那就直接将密文入库了\n    \n    // db 操作完成之后，还得将 userBean 的密文变成明文，这里应该还有 addAfter 解密操作\n}\n</code></pre><p>打印输出的内容为：</p><pre><code class=\"language-java\">打印一下加密内容: UserBean{name='#BEFORE#Geek'}\n</code></pre><p>结果如预期所料，把入参的数据成功加密了，我们终于可以喘口气了，不过辛苦是值得的，学到了大量的底层 ASM 操控字节码的知识，也见识到了底层功能的强大威力。</p><h2>Compiler 编译方式的适用场景</h2><p>今天我们见识到 Javassist 和 ASM 的强大威力，之前也用过JavaCompiler和Groovy 插件，这么多款工具可以编译生成类信息，有哪些适用场景呢？</p><ul>\n<li>JavaCompiler：是 JDK 提供的一个工具包，我们熟知的 Javac 编译器其实就是 JavaCompiler 的实现，不过JDK 的版本迭代速度快，变化大，我们升级 JDK 的时候，本来在低版本 JDK 能正常编译的功能，跑到高版本就失效了。</li>\n<li>Groovy：属于第三方插件，功能很多很强大，几乎是开发小白的首选框架，不需要考虑过多 API 和字节码指令，会构建源代码字符串，交给 Groovy 插件后就能拿到类信息，拿起来就可以直接使用，但同时也是比较重量级的插件。</li>\n<li>Javassist：封装了各种API来创建类，相对于稍微偏底层的风格，可以动态针对已有类的字节码，调用相关的 API 直接增删改查，非常灵活，只要熟练使用 API 就可以达到很高的境界。</li>\n<li>ASM：是一个通用的字节码操作的框架，属于非常底层的插件了，操作该插件的技术难度相当高，需要对字节码指令有一定的了解，但它体现出来的性能却是最高的，并且插件本身就是定位为一款轻量级的高性能字节码插件。</li>\n</ul><p>有了众多动态编译方式的法宝，从简单到复杂，从重量级到轻量级，你都学会了，相信再遇到一堆神乎其神的Compiler 编译方式，内心也不会胆怯了。</p><p>不过工具多了，有同学可能就有选择困难症，这里我也讲下个人的选择标准。</p><p>如果需要开发一些底层插件，我倾向使用 Javassist 或者 ASM。使用 Javassist 是因为用API 简单而且方便后人维护，使用 ASM 是在一些高度频繁调用的场景出于对性能的极致追求。如果开发应用系统的业务功能，对性能没有太强的追求，而且便于加载和卸载，我倾向使用 Groovy 这款插件。</p><h2>总结</h2><p>今天，我们接着上一讲刚学会的自定义代理案例，在不使用 Wrapper 已有机制的能力下，自己尝试使用简单的 API 操作来创建代理类，见识到了 Javassist 的强大之处，有一套非常齐全的 API 来创建代理类并实时编译成类信息。</p><p>使用 Javassist 编译的三大基本步骤。</p><ul>\n<li>首先，设计一个代码模板。</li>\n<li>然后，使用 Javassist 的相关 API，通过 ClassPool.makeClass 得到一个操控类的 CtClass 对象，然后针对 CtClass 进行 addField 添加字段、addMethod 添加方法、addConstructor 添加构造方法等等。</li>\n<li>最后，调用 CtClass.toClass 方法并编译得到一个类信息，有了类信息，就可以实例化对象处理业务逻辑了。</li>\n</ul><p>然后借助把敏感字段加密存储到数据库的案例，我们研究了大佬常用的 ASM 开发底层框架，尝试先将代码模板变成字节码指令，然后按照 ASM 的规范，将字节码指令一个个翻译成为 ASM 对应的方法，最终通过 ClassLoader.defineClass 将字节码变成了类信息。</p><p>也总结下使用 ASM 编译的四大基本步骤。</p><ul>\n<li>首先，还是设计一个代码模板。</li>\n<li>其次，通过 IDEA 的协助得到代码模板的字节码指令内容。</li>\n<li>然后，使用 Asm 的相关 API 依次将字节码指令翻译为 Asm 对应的语法，比如创建 ClassWriter 相当于创建了一个类，继续调用  ClassWriter.visitMethod 方法相当于创建了一个方法等等，对于生僻的字节码指令实在找不到对应的官方文档的话，可以通过“<strong>MethodVisitor + 字节码指令</strong>”来快速查找对应的 Asm API。</li>\n<li>最后，调用 ClassWriter.toByteArray 得到字节码的字节数组，传递到 ClassLoader.defineClass 交给 JVM 虚拟机得出一个 Class 类信息。</li>\n</ul><p>总的来说，无论使用哪种方式进行动态编译，不管是出于对性能的极致追求，还是出于对项目具体业务功能的通用处理，只要适合自身业务，且不会带来沉重性能开销，都是一种好方式。只有合适的才是最好的。</p><h3>思考题</h3><p>留个作业给你，前面讲到 Javassist 动态编译时，其实里面也支持直接将编写的源代码编译成类信息，你可以试着从 Dubbo 的 org.apache.dubbo.common.compiler.Compiler 接口研究一番，看看能不能找到现成的方法来编译源代码？</p><p>期待看到你的思考，如果你对今天的内容还有什么困惑，欢迎在留言区提问，我会第一时间回复。我们下一讲见。</p><h3>参考资料</h3><p>考虑到 ASM 比较难，我之前也录制了<a href=\"https://www.ixigua.com/7023388128421511710?id=7023365492664599072\">ASM实操一步步教学视频</a>，你可以学习。</p><h3>15 思考题参考</h3><p>上一期留了个作业，总结下 java.lang.Class#getDeclaredMethod 方法的调用流程，以及排查下存在哪些耗时和占用内存的地方。</p><p>既然要研究方法的调用流程，那最简单的方式就是直接去看代码。</p><pre><code class=\"language-java\">// java.lang.Class#getDeclaredMethod\npublic Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)\n    throws NoSuchMethodException, SecurityException {\n    // 检查方法的权限\n    checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);\n    // 从该类中的所有方法列表中找到一个匹配方法名称和方法参数的方法对象\n    // 并且返回的 method 对象是一个克隆拷贝出来的对象\n    Method method = searchMethods(privateGetDeclaredMethods(false), name, parameterTypes);\n    if (method == null) {\n        throw new NoSuchMethodException(getName() + \".\" + name + argumentTypesToString(parameterTypes));\n    }\n    return method;\n}\n                  ↓\n// 从缓存或者通过 native 调用从 JVM 中获取该 Class 中声明的方法列表集合\nprivate Method[] privateGetDeclaredMethods(boolean publicOnly) {\n    checkInitted();\n    Method[] res;\n    // 从缓存中获取该 Class 中声明的方法列表集合\n    ReflectionData&lt;T&gt; rd = reflectionData();\n    if (rd != null) {\n        res = publicOnly ? rd.declaredPublicMethods : rd.declaredMethods;\n        if (res != null) return res;\n    }\n    // No cached value available; request value from VM\n    // 从 JVM 中获取该 Class 中声明的方法列表集合\n    // getDeclaredMethods0 尾巴上是个数字0，一般是 native 方法\n    // 而 native 调用产生的消耗一般可以达到 java 调用的 10 倍以上\n    res = Reflection.filterMethods(this, getDeclaredMethods0(publicOnly));\n    if (rd != null) {\n        if (publicOnly) {\n            rd.declaredPublicMethods = res;\n        } else {\n            rd.declaredMethods = res;\n        }\n    }\n    return res;\n}\n                  ↓\n// 从缓存中获取方法列表对象\nprivate ReflectionData&lt;T&gt; reflectionData() {\n    SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData = this.reflectionData;\n    int classRedefinedCount = this.classRedefinedCount;\n    ReflectionData&lt;T&gt; rd;\n    if (useCaches &amp;&amp;\n        reflectionData != null &amp;&amp;\n        (rd = reflectionData.get()) != null &amp;&amp;\n        rd.redefinedCount == classRedefinedCount) {\n        return rd;\n    }\n    // else no SoftReference or cleared SoftReference or stale ReflectionData\n    // -&gt; create and replace new instance\n    return newReflectionData(reflectionData, classRedefinedCount);\n}\n                  ↓\n// 存方法列表的反射对象类\n// 从该类中发现含有大量的字段集合、方法集合、构造方法集合等等\n// 存储太多太多的重要数据，缓存占据的容量大小也是一个问题因素                  \nprivate static class ReflectionData&lt;T&gt; {\n    volatile Field[] declaredFields;\n    volatile Field[] publicFields;\n    volatile Method[] declaredMethods;\n    volatile Method[] publicMethods;\n    volatile Constructor&lt;T&gt;[] declaredConstructors;\n    volatile Constructor&lt;T&gt;[] publicConstructors;\n    // Intermediate results for getFields and getMethods\n    volatile Field[] declaredPublicFields;\n    volatile Method[] declaredPublicMethods;\n    volatile Class&lt;?&gt;[] interfaces;\n    // Value of classRedefinedCount when we created this ReflectionData instance\n    final int redefinedCount;\n    ReflectionData(int redefinedCount) {\n        this.redefinedCount = redefinedCount;\n    }\n}\n                  ↓\n// 从声明的方法列表集合中，检索出一个匹配方法名称和方法参数的 method 对象                  \nprivate static Method searchMethods(Method[] methods,\n                                    String name,\n                                    Class&lt;?&gt;[] parameterTypes)\n{\n    Method res = null;\n    String internedName = name.intern();\n    for (int i = 0; i &lt; methods.length; i++) {\n        Method m = methods[i];\n        if (m.getName() == internedName\n            &amp;&amp; arrayContentsEq(parameterTypes, m.getParameterTypes())\n            &amp;&amp; (res == null\n                || res.getReturnType().isAssignableFrom(m.getReturnType())))\n            res = m;\n    }\n    // 重点看这里，如果找到了一个匹配的 Method 的话\n    // 则重新 copy 一份新对象返回，且新对象的 root 属性都会指向原来的 Method 对象\n    // 也就意味着大量调用的话，又会产生大量的对象，是不可忽视的一个重要环节\n    return (res == null ? res : getReflectionFactory().copyMethod(res));\n}\n</code></pre><p>代码看下来，总结起来，获取方法的流程主要有三步。</p><ul>\n<li>第一步，检查方法权限。</li>\n<li>第二步，从 Class 对象的所有方法列表中查找匹配的 Method 对象。</li>\n<li>第三步，返回 Method 对象的克隆对象。</li>\n</ul><p>第二步每次都是 O(n) 时间复杂度的检索，并且缓存中的 ReflectionData 内容实在是太多了，占据了大量的内存开销。</p><p>第三步每次都是返回一个克隆对象，而 Method 对象本身就有很多东西，每次都拷贝出一个新对象，又是吃内存的操作。</p><p>一个简简单单的直接调用，换做反射后，即使不谈内存占用，就光凭代码量的行数，就相当于调用了很多字节码指令，虽然字节码指令执行很快，但是蚊子腿也是肉，时间上也有数十倍甚至百倍的耗时增长开销。</p><p>有时候，虽然 Java 反射性能会存在一定损耗开销，但并不是告诉我们不能使用 Java 反射，其实，我们应该根据程序设计来按需考量设计。</p><p>如果你只是根据某些条件或配置文件来使用 Java 反射创建对象，然后就做其它操作（如数据库查询等），那 Java 反射损耗的那点性能可以忽略不计。</p><p>但如果你在连续循环中通过反射不断创建大量对象，这样的操作就得好好斟酌了，看看是不是可以不用反射的机制实现，避免大量耗时和内存的开销。</p>","neighbors":{"left":{"article_title":"15｜Wrapper机制：Wrapper是怎么降低调用开销的？","id":620918},"right":{"article_title":"17｜Adaptive适配：Dubbo的Adaptive特殊在哪里？","id":620941}},"comments":[{"had_liked":false,"id":378666,"user_name":"王建新","can_delete":false,"product_type":"c1","uid":1934802,"ip_address":"北京","ucode":"E3151DDC0EEF0D","user_header":"https://static001.geekbang.org/account/avatar/00/1d/85/d2/045c63fb.jpg","comment_is_top":false,"comment_ctime":1690554748,"is_pvip":false,"replies":[{"id":138226,"content":"你好，王建新：别心急，认真仔细的深入看几遍，其中的原理相信你会体会到的。","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1691889757,"ip_address":"广东","comment_id":378666,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312101,"comment_content":"上一节和这一节讲的完全不搭边呀，最主要的核心关联没说上，ASM语法代码写了那么多看那干啥。。。","like_count":0,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":625562,"discussion_content":"你好，王建新：别心急，认真仔细的深入看几遍，其中的原理相信你会体会到的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1691889757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366931,"user_name":"王轲","can_delete":false,"product_type":"c1","uid":1444126,"ip_address":"美国","ucode":"65065BFFC409F5","user_header":"https://static001.geekbang.org/account/avatar/00/16/09/1e/fc5144ff.jpg","comment_is_top":false,"comment_ctime":1674626001,"is_pvip":false,"replies":[{"id":133705,"content":"你好，王轲：是滴，显示有误，非常感谢～\n\n正确的是这样的：\n\n在对方法的入参字段名进行逻辑处理时，就得替换成 $ 占位符，方法中的 this 引用，用 $0 表示，方法中的第一个参数用 $1 表示，第二个参数用 $2 表示，以此类推。","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1674687808,"ip_address":"湖南","comment_id":366931,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312101,"comment_content":"`...用 0表示，方法中的第一个参数用1 表示...` 这里看起来显示有误，应该是`...用 $0表示，方法中的第一个参数用$1 表示...`","like_count":0,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600650,"discussion_content":"你好，王轲：是滴，显示有误，非常感谢～\n\n正确的是这样的：\n\n在对方法的入参字段名进行逻辑处理时，就得替换成 $ 占位符，方法中的 this 引用，用 $0 表示，方法中的第一个参数用 $1 表示，第二个参数用 $2 表示，以此类推。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674687808,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖南","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366900,"user_name":"斯瓦辛武Roy","can_delete":false,"product_type":"c1","uid":2087578,"ip_address":"江苏","ucode":"0A6AE232481B86","user_header":"https://static001.geekbang.org/account/avatar/00/1f/da/9a/ed524797.jpg","comment_is_top":false,"comment_ctime":1674559821,"is_pvip":false,"replies":[{"id":133810,"content":"你好，斯瓦辛武Roy：我这边按照你所描述的方式，验证了一下，都是正常的，我这边我说下我的操作步骤，你尝试按照我的步骤试试：\n\n1. 启动提供方成功后，打开命令窗口，输入命令：telnet 127.0.0.1 28045\n2. 输入完命令后，直接回车，然后你会看到“dubbo&gt;”这样的内容显示。\n3. 然后在“dubbo&gt;”后面继续追加 trace 命令，比如：dubbo&gt;trace com.hmilyylimh.cloud.facade.demo.DemoFacade\n4. 在第 3 步骤的命令输入完后，紧接着再次回车\n5. 运行消费方来调用 DemoFacade 接口，然后就能在命令窗口看到 trace 命令跟踪的结果了。","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1675150111,"ip_address":"广东","comment_id":366900,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312101,"comment_content":"老师春节好，请教个问题，再看官方文档的时候https:&#47;&#47;cn.dubbo.apache.org&#47;zh&#47;docsv2.7&#47;user&#47;references&#47;telnet&#47;\n用了这个命令trace XxxService: 跟踪 1 次服务任意方法的调用情况\n我调用自己本地的dubbo服务，但这个命令没有反应，请教一下老师这个是什么原因","like_count":0,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":601223,"discussion_content":"你好，斯瓦辛武Roy：我这边按照你所描述的方式，验证了一下，都是正常的，我这边我说下我的操作步骤，你尝试按照我的步骤试试：\n\n1. 启动提供方成功后，打开命令窗口，输入命令：telnet 127.0.0.1 28045\n2. 输入完命令后，直接回车，然后你会看到“dubbo&gt;”这样的内容显示。\n3. 然后在“dubbo&gt;”后面继续追加 trace 命令，比如：dubbo&gt;trace com.hmilyylimh.cloud.facade.demo.DemoFacade\n4. 在第 3 步骤的命令输入完后，紧接着再次回车\n5. 运行消费方来调用 DemoFacade 接口，然后就能在命令窗口看到 trace 命令跟踪的结果了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675150111,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366847,"user_name":"熊悟空的凶","can_delete":false,"product_type":"c1","uid":1933459,"ip_address":"北京","ucode":"5FA9498BDA92C0","user_header":"https://static001.geekbang.org/account/avatar/00/1d/80/93/dde3d5f0.jpg","comment_is_top":false,"comment_ctime":1674449107,"is_pvip":false,"replies":[{"id":133689,"content":"你好，熊悟空的凶：兔年吉祥，在过年的闹市中还能静心学习，让我想起了我刚工作的那几年，每年过年的晚上都在挑灯奋战努力写代码学习。你还是很棒的，闹市中能静下心来的学习你，将来一定是钱兔无量，为你加油喝彩，点赞～","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1674484074,"ip_address":"湖南","comment_id":366847,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312101,"comment_content":"老师，新年好","like_count":0,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600540,"discussion_content":"你好，熊悟空的凶：兔年吉祥，在过年的闹市中还能静心学习，让我想起了我刚工作的那几年，每年过年的晚上都在挑灯奋战努力写代码学习。你还是很棒的，闹市中能静下心来的学习你，将来一定是钱兔无量，为你加油喝彩，点赞～","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1674484074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖南","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}