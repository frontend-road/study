{"id":64233,"title":"18 | 散列表（上）：Word文档中的单词拼写检查功能是如何实现的？","content":"<p>Word这种文本编辑器你平时应该经常用吧，那你有没有留意过它的拼写检查功能呢？一旦我们在Word里输入一个错误的英文单词，它就会用标红的方式提示“拼写错误”。<strong><span class=\"orange\">Word的这个单词拼写检查功能，虽然很小但却非常实用。你有没有想过，这个功能是如何实现的呢？</span></strong></p><p>其实啊，一点儿都不难。只要你学完今天的内容，<strong>散列表</strong>（Hash Table）。你就能像微软Office的工程师一样，轻松实现这个功能。</p><h2>散列思想</h2><p>散列表的英文叫“Hash Table”，我们平时也叫它“哈希表”或者“Hash表”，你一定也经常听过它，我在前面的文章里，也不止一次提到过，但是你是不是真的理解这种数据结构呢？</p><p><strong>散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。</strong></p><p>我用一个例子来解释一下。假如我们有89名选手参加学校运动会。为了方便记录成绩，每个选手胸前都会贴上自己的参赛号码。这89名选手的编号依次是1到89。现在我们希望编程实现这样一个功能，通过编号快速找到对应的选手信息。你会怎么做呢？</p><p>我们可以把这89名选手的信息放在数组里。编号为1的选手，我们放到数组中下标为1的位置；编号为2的选手，我们放到数组中下标为2的位置。以此类推，编号为k的选手放到数组中下标为k的位置。</p><!-- [[[read_end]]] --><p>因为参赛编号跟数组下标一一对应，当我们需要查询参赛编号为x的选手的时候，我们只需要将下标为x的数组元素取出来就可以了，时间复杂度就是O(1)。这样按照编号查找选手信息，效率是不是很高？</p><p>实际上，这个例子已经用到了散列的思想。在这个例子里，参赛编号是自然数，并且与数组的下标形成一一映射，所以利用数组支持根据下标随机访问的时候，时间复杂度是O(1)这一特性，就可以实现快速查找编号对应的选手信息。</p><p>你可能要说了，这个例子中蕴含的散列思想还不够明显，那我来改造一下这个例子。</p><p>假设校长说，参赛编号不能设置得这么简单，要加上年级、班级这些更详细的信息，所以我们把编号的规则稍微修改了一下，用6位数字来表示。比如051167，其中，前两位05表示年级，中间两位11表示班级，最后两位还是原来的编号1到89。这个时候我们该如何存储选手信息，才能够支持通过编号来快速查找选手信息呢？</p><p>思路还是跟前面类似。尽管我们不能直接把编号作为数组下标，但我们可以截取参赛编号的后两位作为数组下标，来存取选手信息数据。当通过参赛编号查询选手信息的时候，我们用同样的方法，取参赛编号的后两位，作为数组下标，来读取数组中的数据。</p><p>这就是典型的散列思想。其中，参赛选手的编号我们叫做<strong>键</strong>（key）或者<strong>关键字</strong>。我们用它来标识一个选手。我们把参赛编号转化为数组下标的映射方法就叫作<strong>散列函数</strong>（或“Hash函数”“哈希函数”），而散列函数计算得到的值就叫作<strong>散列值</strong>（或“Hash值”“哈希值”）。</p><p><img src=\"https://static001.geekbang.org/resource/image/92/73/92c89a57e21f49d2f14f4424343a2773.jpg?wh=1142*744\" alt=\"\"></p><p>通过这个例子，我们可以总结出这样的规律：散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是O(1)的特性。我们通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。</p><h2>散列函数</h2><p>从上面的例子我们可以看到，散列函数在散列表中起着非常关键的作用。现在我们就来学习下散列函数。</p><p>散列函数，顾名思义，它是一个函数。我们可以把它定义成<strong>hash(key)</strong>，其中key表示元素的键值，hash(key)的值表示经过散列函数计算得到的散列值。</p><p>那第一个例子中，编号就是数组下标，所以hash(key)就等于key。改造后的例子，写成散列函数稍微有点复杂。我用伪代码将它写成函数就是下面这样：</p><pre><code>int hash(String key) {\n  // 获取后两位字符\n  string lastTwoChars = key.substr(length-2, length);\n  // 将后两位字符转换为整数\n  int hashValue = convert lastTwoChas to int-type;\n  return hashValue;\n}\n</code></pre><p>刚刚举的学校运动会的例子，散列函数比较简单，也比较容易想到。但是，如果参赛选手的编号是随机生成的6位数字，又或者用的是a到z之间的字符串，<strong>该如何构造散列函数呢？<strong>我总结了三点</strong>散列函数<strong><strong>设计的</strong></strong>基本要求</strong>：</p><ol>\n<li>\n<p>散列函数计算得到的散列值是一个非负整数；</p>\n</li>\n<li>\n<p>如果key1 = key2，那hash(key1) == hash(key2)；</p>\n</li>\n<li>\n<p>如果key1 ≠ key2，那hash(key1) ≠ hash(key2)。</p>\n</li>\n</ol><p>我来解释一下这三点。其中，第一点理解起来应该没有任何问题。因为数组下标是从0开始的，所以散列函数生成的散列值也要是非负整数。第二点也很好理解。相同的key，经过散列函数得到的散列值也应该是相同的。</p><p>第三点理解起来可能会有问题，我着重说一下。这个要求看起来合情合理，但是在真实的情况下，要想找到一个不同的key对应的散列值都不一样的散列函数，几乎是不可能的。即便像业界著名的<a href=\"https://zh.wikipedia.org/wiki/MD5\">MD5</a>、<a href=\"https://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F\">SHA</a>、<a href=\"https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%92%B0%E5%86%97%E9%A4%98%E6%A0%A1%E9%A9%97\">CRC</a>等哈希算法，也无法完全避免这种<strong>散列冲突</strong>。而且，因为数组的存储空间有限，也会加大散列冲突的概率。</p><p>所以我们几乎无法找到一个完美的无冲突的散列函数，即便能找到，付出的时间成本、计算成本也是很大的，所以针对散列冲突问题，我们需要通过其他途径来解决。</p><h2>散列冲突</h2><p>再好的散列函数也无法避免散列冲突。那究竟该如何解决散列冲突问题呢？我们常用的散列冲突解决方法有两类，开放寻址法（open addressing）和链表法（chaining）。</p><h3>1.开放寻址法</h3><p>开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。那如何重新探测新的位置呢？我先讲一个比较简单的探测方法，<strong>线性探测</strong>（Linear Probing）。</p><p>当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。</p><p>我说的可能比较抽象，我举一个例子具体给你说明一下。这里面黄色的色块表示空闲位置，橙色的色块表示已经存储了数据。</p><p><img src=\"https://static001.geekbang.org/resource/image/5c/d5/5c31a3127cbc00f0c63409bbe1fbd0d5.jpg?wh=1142*530\" alt=\"\"></p><p>从图中可以看出，散列表的大小为10，在元素x插入散列表之前，已经6个元素插入到散列表中。x经过Hash算法之后，被散列到位置下标为7的位置，但是这个位置已经有数据了，所以就产生了冲突。于是我们就顺序地往后一个一个找，看有没有空闲的位置，遍历到尾部都没有找到空闲的位置，于是我们再从表头开始找，直到找到空闲位置2，于是将其插入到这个位置。</p><p>在散列表中查找元素的过程有点儿类似插入过程。我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在散列表中。</p><p><img src=\"https://static001.geekbang.org/resource/image/91/ff/9126b0d33476777e7371b96e676e90ff.jpg?wh=1142*1522\" alt=\"\"></p><p>散列表跟数组一样，不仅支持插入、查找操作，还支持删除操作。对于使用线性探测法解决冲突的散列表，删除操作稍微有些特别。我们不能单纯地把要删除的元素设置为空。这是为什么呢？</p><p>还记得我们刚讲的查找操作吗？在查找的时候，一旦我们通过线性探测方法，找到一个空闲位置，我们就可以认定散列表中不存在这个数据。但是，如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。本来存在的数据，会被认定为不存在。这个问题如何解决呢？</p><p>我们可以将删除的元素，特殊标记为deleted。当线性探测查找的时候，遇到标记为deleted的空间，并不是停下来，而是继续往下探测。</p><p><img src=\"https://static001.geekbang.org/resource/image/fe/1d/fe7482ba09670cbe05a9dfe4dd49bd1d.jpg?wh=1142*641\" alt=\"\"></p><p>你可能已经发现了，线性探测法其实存在很大问题。当散列表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久。极端情况下，我们可能需要探测整个散列表，所以最坏情况下的时间复杂度为O(n)。同理，在删除和查找时，也有可能会线性探测整张散列表，才能找到要查找或者删除的数据。</p><p>对于开放寻址冲突解决方法，除了线性探测方法之外，还有另外两种比较经典的探测方法，<strong>二次探测</strong>（Quadratic probing）和<strong>双重散列</strong>（Double hashing）。</p><p>所谓二次探测，跟线性探测很像，线性探测每次探测的步长是1，那它探测的下标序列就是hash(key)+0，hash(key)+1，hash(key)+2……而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是hash(key)+0，hash(key)+1<sup>2</sup>，hash(key)+2<sup>2</sup>……</p><p>所谓双重散列，意思就是不仅要使用一个散列函数。我们使用一组散列函数hash1(key)，hash2(key)，hash3(key)……我们先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。</p><p>不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用<strong>装载因子</strong>（load factor）来表示空位的多少。</p><p>装载因子的计算公式是：</p><pre><code>散列表的装载因子=填入表中的元素个数/散列表的长度\n</code></pre><p>装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。</p><h3>2.链表法</h3><p>链表法是一种更加常用的散列冲突解决办法，相比开放寻址法，它要简单很多。我们来看这个图，在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。</p><p><img src=\"https://static001.geekbang.org/resource/image/a4/7f/a4b77d593e4cb76acb2b0689294ec17f.jpg?wh=1142*640\" alt=\"\"></p><p>当插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入的时间复杂度是O(1)。当查找、删除一个元素时，我们同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除。那查找或删除操作的时间复杂度是多少呢？</p><p>实际上，这两个操作的时间复杂度跟链表的长度k成正比，也就是O(k)。对于散列比较均匀的散列函数来说，理论上讲，k=n/m，其中n表示散列中数据的个数，m表示散列表中“槽”的个数。</p><h2>解答开篇</h2><p>有了前面这些基本知识储备，我们来看一下开篇的思考题：Word文档中单词拼写检查功能是如何实现的？</p><p>常用的英文单词有20万个左右，假设单词的平均长度是10个字母，平均一个单词占用10个字节的内存空间，那20万英文单词大约占2MB的存储空间，就算放大10倍也就是20MB。对于现在的计算机来说，这个大小完全可以放在内存里面。所以我们可以用散列表来存储整个英文单词词典。</p><p>当用户输入某个英文单词时，我们拿用户输入的单词去散列表中查找。如果查到，则说明拼写正确；如果没有查到，则说明拼写可能有误，给予提示。借助散列表这种数据结构，我们就可以轻松实现快速判断是否存在拼写错误。</p><h2>内容小结</h2><p>今天我讲了一些比较基础、比较偏理论的散列表知识，包括散列表的由来、散列函数、散列冲突的解决方法。</p><p>散列表来源于数组，它借助散列函数对数组这种数据结构进行扩展，利用的是数组支持按照下标随机访问元素的特性。散列表两个核心问题是<strong>散列函数设计</strong>和<strong>散列冲突解决</strong>。散列冲突有两种常用的解决方法，开放寻址法和链表法。散列函数设计的好坏决定了散列冲突的概率，也就决定散列表的性能。</p><p>针对散列函数和散列冲突，今天我只讲了一些基础的概念、方法，下一节我会更贴近实战、更加深入探讨这两个问题。</p><h2>课后思考</h2><ol>\n<li>\n<p>假设我们有10万条URL访问日志，如何按照访问次数给URL排序？</p>\n</li>\n<li>\n<p>有两个字符串数组，每个数组大约有10万条字符串，如何快速找出两个数组中相同的字符串？</p>\n</li>\n</ol><p>欢迎留言和我分享，我会第一时间给你反馈。</p>","comments":[{"had_liked":false,"id":36146,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1540954888,"is_pvip":false,"replies":[{"id":"12896","content":"👍 这条留言可以顶上去了 其他同学都看看吧","user_name":"作者回复","comment_id":36146,"uid":"1190123","ip_address":"","utype":1,"ctime":1541037156,"user_name_real":"gg"}],"discussion_count":118,"race_medal":0,"score":"6890668497672","product_id":100017301,"comment_content":"<br>1. 假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？<br><br>遍历 10 万条数据，以 URL 为 key，访问次数为 value，存入散列表，同时记录下访问次数的最大值 K，时间复杂度 O(N)。<br><br>如果 K 不是很大，可以使用桶排序，时间复杂度 O(N)。如果 K 非常大（比如大于 10 万），就使用快速排序，复杂度 O(NlogN)。<br><br>2. 有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？<br><br>以第一个字符串数组构建散列表，key 为字符串，value 为出现次数。再遍历第二个字符串数组，以字符串为 key 在散列表中查找，如果 value 大于零，说明存在相同字符串。时间复杂度 O(N)。","like_count":1605,"discussions":[{"author":{"id":1744888,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/9f/f8/d851a100.jpg","nickname":"世界以痛吻我，我却报之以歌","note":"","ucode":"04B06339A815E9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":274333,"discussion_content":"第二个问题没必要value存出现次数吧，只要随便存一个数，比如1，在遍历第二个数组的时候，只要能取到值不就表示有相同的字符串吗。","likes_number":15,"is_delete":false,"is_hidden":false,"ctime":1590569438,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1358312,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b9/e8/0b3cf295.jpg","nickname":"HaiSky","note":"","ucode":"ECE7C263142432","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1744888,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/9f/f8/d851a100.jpg","nickname":"世界以痛吻我，我却报之以歌","note":"","ucode":"04B06339A815E9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284197,"discussion_content":"我也是这么想的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1592470141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":274333,"ip_address":""},"score":284197,"extra":""},{"author":{"id":1268797,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5c/3d/e8325811.jpg","nickname":"对白","note":"","ucode":"3183E5ADBC794B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1744888,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/9f/f8/d851a100.jpg","nickname":"世界以痛吻我，我却报之以歌","note":"","ucode":"04B06339A815E9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294983,"discussion_content":"也可以存成True","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596050914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":274333,"ip_address":""},"score":294983,"extra":""},{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1744888,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/9f/f8/d851a100.jpg","nickname":"世界以痛吻我，我却报之以歌","note":"","ucode":"04B06339A815E9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351580,"discussion_content":"是可以,记得刷过一个leecode这样的题目","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1614334286,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":274333,"ip_address":""},"score":351580,"extra":""}]},{"author":{"id":1598220,"avatar":"https://static001.geekbang.org/account/avatar/00/18/63/0c/e99e6c4c.jpg","nickname":"阿辉","note":"","ucode":"22BD08E12DCB0D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51189,"discussion_content":"感觉这两道题的解法完美符合MapReduce的思路，map过程统计次数，reduce排序","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1573822185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1236079,"avatar":"https://static001.geekbang.org/account/avatar/00/12/dc/6f/5d86dbe9.jpg","nickname":"短迪大魔王","note":"","ucode":"37E8117E0495B8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1598220,"avatar":"https://static001.geekbang.org/account/avatar/00/18/63/0c/e99e6c4c.jpg","nickname":"阿辉","note":"","ucode":"22BD08E12DCB0D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":138575,"discussion_content":"我一开始就想到了mr","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579254051,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":51189,"ip_address":""},"score":138575,"extra":""},{"author":{"id":1243570,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f9/b2/2ed800b4.jpg","nickname":"社会你强哥","note":"","ucode":"325B9005588D9B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1598220,"avatar":"https://static001.geekbang.org/account/avatar/00/18/63/0c/e99e6c4c.jpg","nickname":"阿辉","note":"","ucode":"22BD08E12DCB0D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":157298,"discussion_content":"不明觉厉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580466381,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":51189,"ip_address":""},"score":157298,"extra":""},{"author":{"id":1798068,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/6f/b4/d465acef.jpg","nickname":"啊噗！","note":"","ucode":"C911E772E1E800","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1236079,"avatar":"https://static001.geekbang.org/account/avatar/00/12/dc/6f/5d86dbe9.jpg","nickname":"短迪大魔王","note":"","ucode":"37E8117E0495B8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":161305,"discussion_content":"第二题怎么用mr呀？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580886047,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":138575,"ip_address":""},"score":161305,"extra":""}]},{"author":{"id":1013841,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","nickname":"Smallfly","note":"","ucode":"D388D5E0249A69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7070,"discussion_content":"转眼这条留言都快一年了。第一个答案的确不是很严谨，应该向评论区@小耿说的，记录访问次数的最值，看差值如果小于一定范围，再使用桶排序。\n\n以下是 JS 代码：\n\nconst BUCKETS_SIZE = 100; // 使用桶排序的界限\n\nfunction sortURLsByAccessCount(urls) {\n  const n = urls.length;\n  let maxCount = 0;\n  let minCount = 0;\n  const dict = {};\n  for (let i = 0; i < n; ++i) {\n    const url = urls[i];\n    const urlCount = dict[url] || 0;\n    dict[url] = urlCount + 1;\n    // 记录最大值 \n    if (dict[url] > maxCount) {\n      maxCount = dict[url];\n    }\n    // 记录最小值\n    if (dict[url] < minCount) {\n      minCount = dict[url];\n    }\n  }\n\n  // 如果差值小于 BUCKETS_SIZE 使用桶排序，否者使用快速排序\n  if (maxCount - minCount < BUCKETS_SIZE) {\n    return bucketSort(dict, minCount);\n  } else {\n    // 快排实现这里就不贴了\n    return quickSort(dict);\n  }\n}\n\nfunction bucketSort(dict, min) {\n  // 分配桶内存\n  const buckets = new Array(BUCKETS_SIZE);\n  for (const url in dict) {\n    const count = dict[url];\n    // 记录访问次数与最小值的偏移作为存储下标\n    const index = count - min;\n    buckets[index] = url;\n  }\n\n  // 记录排序后的结果\n  let result = [];\n  buckets.map((url, index) => {\n    // 初始化长度为 index+min 的数组，即 url 出现的次数\n    const urls = new Array(index + min);\n    // 数组元素全部用 url 填充\n    urls.fill(url);\n    // 存储结果\n    result = result.concat(urls);\n  });\n  return result;\n}\n\n// Test\nconst urls = [\n  &#34;https://www.souche.com&#34;,\n  &#34;https://www.souche.com&#34;,\n  &#34;https://www.souche.com&#34;,\n  &#34;https://www.taobao.com&#34;,\n  &#34;https://www.taobao.com&#34;,\n  &#34;https://www.baidu.com&#34;,\n];\nconst sortedURLs = sortURLsByAccessCount(urls);\n\nconsole.log(sortedURLs);\n/** 输出结果:\n[ &#39;https://www.baidu.com&#39;,\n  &#39;https://www.taobao.com&#39;,\n  &#39;https://www.taobao.com&#39;,\n  &#39;https://www.souche.com&#39;,\n  &#39;https://www.souche.com&#39;,\n  &#39;https://www.souche.com&#39; ] \n */","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1567335839,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":6,"child_discussions":[{"author":{"id":1377467,"avatar":"https://static001.geekbang.org/account/avatar/00/15/04/bb/5e5c37c1.jpg","nickname":"Angus","note":"","ucode":"7CC3BA1550FB5B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1013841,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","nickname":"Smallfly","note":"","ucode":"D388D5E0249A69","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":19830,"discussion_content":"你的minCount应该一直都是0，因为你的初始值是0。所以你的差值范围还是最大值K，想法严谨了，写法并没有严谨。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1569229926,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7070,"ip_address":""},"score":19830,"extra":""},{"author":{"id":1013841,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","nickname":"Smallfly","note":"","ucode":"D388D5E0249A69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1377467,"avatar":"https://static001.geekbang.org/account/avatar/00/15/04/bb/5e5c37c1.jpg","nickname":"Angus","note":"","ucode":"7CC3BA1550FB5B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":19859,"discussion_content":"minCount 初始值应该为整型最大值，谢谢指出。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1569231575,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":19830,"ip_address":""},"score":19859,"extra":""},{"author":{"id":1372328,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f0/a8/df689349.jpg","nickname":"package","note":"","ucode":"A0FF0B21D18DCF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1013841,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","nickname":"Smallfly","note":"","ucode":"D388D5E0249A69","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74040,"discussion_content":"minCount整型最大值貌似也没用吧，会一直为1吧？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575625693,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":19859,"ip_address":""},"score":74040,"extra":""}]},{"author":{"id":1153707,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9a/ab/fd201314.jpg","nickname":"小耿","note":"","ucode":"1C8B66C738D33B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6882,"discussion_content":"不应该单纯看K吧，应该同时记下访问次数的最大值和最小值，如果差值不大，就可以用桶排序。","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1567153192,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1013841,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","nickname":"Smallfly","note":"","ucode":"D388D5E0249A69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1153707,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9a/ab/fd201314.jpg","nickname":"小耿","note":"","ucode":"1C8B66C738D33B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7068,"discussion_content":"有道理。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567335200,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":6882,"ip_address":""},"score":7068,"extra":""},{"author":{"id":1058638,"avatar":"https://static001.geekbang.org/account/avatar/00/10/27/4e/080cb3a0.jpg","nickname":"CodingWith","note":"","ucode":"F9E463F5823332","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1153707,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9a/ab/fd201314.jpg","nickname":"小耿","note":"","ucode":"1C8B66C738D33B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":148332,"discussion_content":"请教一下，要校验min， max的差值的不是计数排序么？你们的意思是计数排序是桶排序的一种吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579698278,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":6882,"ip_address":""},"score":148332,"extra":""},{"author":{"id":1058638,"avatar":"https://static001.geekbang.org/account/avatar/00/10/27/4e/080cb3a0.jpg","nickname":"CodingWith","note":"","ucode":"F9E463F5823332","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1153707,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9a/ab/fd201314.jpg","nickname":"小耿","note":"","ucode":"1C8B66C738D33B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":148335,"discussion_content":"桶排序要预防的大部分元素都分到一个桶中， 但是判断min 和 max差的大小 好像并不能达到这个目的吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579698398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":6882,"ip_address":""},"score":148335,"extra":""}]},{"author":{"id":1018724,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/64/d8bf2f6f.jpg","nickname":"旻言","note":"","ucode":"563E6A83A50EC9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376712,"discussion_content":"第一题中总共才10w，k肯定不会大于10w额……","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1622289270,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1061991,"avatar":"https://static001.geekbang.org/account/avatar/00/10/34/67/06a7f9be.jpg","nickname":"while (1)等;","note":"","ucode":"BAEC7258D65B69","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1018724,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/64/d8bf2f6f.jpg","nickname":"旻言","note":"","ucode":"563E6A83A50EC9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390871,"discussion_content":"10万是url数量，每个url访问次数没说，有可能一个url被访问1万次，k就是一个很大的数了","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1630112955,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":376712,"ip_address":""},"score":390871,"extra":""}]},{"author":{"id":1167233,"avatar":"https://static001.geekbang.org/account/avatar/00/11/cf/81/96f656ef.jpg","nickname":"杨逸林","note":"","ucode":"4BF3CF3E2F1AC7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331554,"discussion_content":"第二个不就是 LeetCode 第一题吗，比较优的解，两次完整遍历数组，第一次变成 HashMap，第二次调用 get 方法","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1606898687,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1999009,"avatar":"","nickname":"Geek_26bca7","note":"","ucode":"D96F154BF614A4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1167233,"avatar":"https://static001.geekbang.org/account/avatar/00/11/cf/81/96f656ef.jpg","nickname":"杨逸林","note":"","ucode":"4BF3CF3E2F1AC7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350313,"discussion_content":"哪道题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613810092,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":331554,"ip_address":""},"score":350313,"extra":""},{"author":{"id":2407468,"avatar":"https://static001.geekbang.org/account/avatar/00/24/bc/2c/c33c99af.jpg","nickname":"Simon","note":"","ucode":"43DBC39401BF38","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1999009,"avatar":"","nickname":"Geek_26bca7","note":"","ucode":"D96F154BF614A4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":354636,"discussion_content":"两数之和","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615305896,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":350313,"ip_address":""},"score":354636,"extra":""}]},{"author":{"id":2055017,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/5b/69/477a9071.jpg","nickname":"璟","note":"","ucode":"EA244A298C262B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298135,"discussion_content":"第一题，十万条URL数据不大，完全可以全存储。把url和对应访问次数封装为一个类，重新定义Comparable，直接排序就可以了。 第二题用HashSet存第一组数组中的字符串，然后遍历第二组的字符串依次判断即可。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1597201811,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1611067,"avatar":"https://static001.geekbang.org/account/avatar/00/18/95/3b/c61d0f8b.jpg","nickname":"mythhsy","note":"","ucode":"CE32BE3CD41D84","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2055017,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/5b/69/477a9071.jpg","nickname":"璟","note":"","ucode":"EA244A298C262B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545987,"discussion_content":"对,没必要用哈希映射,直接用哈希集合就行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642122999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":298135,"ip_address":""},"score":545987,"extra":""}]},{"author":{"id":2089249,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/e1/21/500b6030.jpg","nickname":"jack-wei","note":"","ucode":"70E4971DCA9E9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350837,"discussion_content":"第一题，value不能只保存访问次数吧？url经过hash之后，如何判断冲突？一般不都是取出url和散列表里面保存的url做对比吗，如果url不相同但是hash值相同就代表冲突了","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1614048586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":2053825,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/56/c1/76d3e44a.jpg","nickname":"Scevola","note":"","ucode":"433A633884914C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2089249,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/e1/21/500b6030.jpg","nickname":"jack-wei","note":"","ucode":"70E4971DCA9E9D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352703,"discussion_content":"hash转换key的结果只是个位置索引，实际存的还是k-v。个人理解","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1614823277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":350837,"ip_address":""},"score":352703,"extra":""},{"author":{"id":2335540,"avatar":"","nickname":"Geek_alogrithm","note":"","ucode":"482245F585FEA6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2053825,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/56/c1/76d3e44a.jpg","nickname":"Scevola","note":"","ucode":"433A633884914C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358735,"discussion_content":"支持，第二问的答案也有瑕疵，没考虑散列冲突","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1616039458,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":352703,"ip_address":""},"score":358735,"extra":""},{"author":{"id":2372063,"avatar":"https://static001.geekbang.org/account/avatar/00/24/31/df/2988f356.jpg","nickname":"better~","note":"","ucode":"A8243C5D4F935D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2335540,"avatar":"","nickname":"Geek_alogrithm","note":"","ucode":"482245F585FEA6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376978,"discussion_content":"散列冲突和这个没有关系，散列冲突后存储的仍然是entrySet，所以第二问的答案是正确的。个人意见～比如hashMap","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1622447389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":358735,"ip_address":""},"score":376978,"extra":""}]},{"author":{"id":1060526,"avatar":"https://static001.geekbang.org/account/avatar/00/10/2e/ae/f4275434.jpg","nickname":"犄角旮旯","note":"","ucode":"746D5CD645FE59","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269987,"discussion_content":"用hash值做bitMap可能更适合, 时间复杂度一样, 空间复杂度降低很多","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1589971245,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1591223,"avatar":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","nickname":"JerryZhu","note":"","ucode":"76850CD45786C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301833,"discussion_content":"第一个没错，  第二题，其实就用 Set思想就可以了，  第一个String数组 放到 set中(其实就是个散列表， key 是 String,   value 无所谓)   然后 拿散列表和 第二个String数组中元素比较 有就存在 没有就不存在","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1598674278,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2874237,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/db/7d/a3510ae3.jpg","nickname":"凯林","note":"","ucode":"20A1024A7ECE17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1591223,"avatar":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","nickname":"JerryZhu","note":"","ucode":"76850CD45786C1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573487,"discussion_content":"有没有可能，hashSet底层就是用hashMap实现的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653464331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301833,"ip_address":""},"score":573487,"extra":""}]},{"author":{"id":1812840,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a9/68/ec442a70.jpg","nickname":"王jojo","note":"","ucode":"1ABE7FA2614F86","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":228788,"discussion_content":"第一题里, 评论里都在说冲突呢?这里面没有需要解决的冲突吧?最后的这个桶排序和快排的分情况点赞","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1586576609,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1042685,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e8/fd/abb7bfe3.jpg","nickname":"Langzi233","note":"","ucode":"5A21AC08FC089B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1812840,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a9/68/ec442a70.jpg","nickname":"王jojo","note":"","ucode":"1ABE7FA2614F86","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":249620,"discussion_content":"利用开放寻址法，就算有冲突也会存在求组中的另一个地方。后续的排序是对数组元素进行的，所以只要不用链表法，都可以解决啦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587949449,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":228788,"ip_address":""},"score":249620,"extra":""}]},{"author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":165925,"discussion_content":"数据库的hash join就是这么实现的","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1581341462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1514905,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJF2gTFBleTUJK4BNqia5Ov2yiatpmLiclxibMFmCwXvIUMicL52ajftUxlQS0SIXldUk2n9BiaOczdaqFQ/132","nickname":"frame_0224","note":"","ucode":"7692DF4EA3607A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3616,"discussion_content":"URL按照访问次数排序之后，key和value不就对应不起来了，那还怎么用？","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1564641663,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":7,"child_discussions":[{"author":{"id":1189290,"avatar":"https://static001.geekbang.org/account/avatar/00/12/25/aa/ced0170d.jpg","nickname":"杨宝强","note":"","ucode":"B2352D7EA24F31","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1514905,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJF2gTFBleTUJK4BNqia5Ov2yiatpmLiclxibMFmCwXvIUMicL52ajftUxlQS0SIXldUk2n9BiaOczdaqFQ/132","nickname":"frame_0224","note":"","ucode":"7692DF4EA3607A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":20811,"discussion_content":"有道理哦 同求解","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1569379346,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3616,"ip_address":""},"score":20811,"extra":""},{"author":{"id":1215892,"avatar":"https://static001.geekbang.org/account/avatar/00/12/8d/94/150dfe78.jpg","nickname":"GGL","note":"","ucode":"AED10B8248D1E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1514905,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJF2gTFBleTUJK4BNqia5Ov2yiatpmLiclxibMFmCwXvIUMicL52ajftUxlQS0SIXldUk2n9BiaOczdaqFQ/132","nickname":"frame_0224","note":"","ucode":"7692DF4EA3607A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24633,"discussion_content":"URL 按照访问次数排序之后，value 可以存储对象数据（包括 key 和访问次数等），随后对所有的 value 依据访问次数进行排序，排好序之后 URL 也就排好序了；第一步目的是拿到访问次数和数据范围，第二步根据数据范围采用合适的排序算法；不要局限于 value 只是单一的访问次数；","likes_number":18,"is_delete":false,"is_hidden":false,"ctime":1570201456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3616,"ip_address":""},"score":24633,"extra":""},{"author":{"id":1219403,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9b/4b/cf25fe6d.jpg","nickname":"soufal","note":"","ucode":"89C940FBE18DFF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1215892,"avatar":"https://static001.geekbang.org/account/avatar/00/12/8d/94/150dfe78.jpg","nickname":"GGL","note":"","ucode":"AED10B8248D1E7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":61109,"discussion_content":"很有启发！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574773249,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":24633,"ip_address":""},"score":61109,"extra":""}]},{"author":{"id":1284647,"avatar":"https://static001.geekbang.org/account/avatar/00/13/9a/27/4b81bce5.jpg","nickname":"笑","note":"","ucode":"C91EAFAB88E5AC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":323408,"discussion_content":"思路非常好！","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1604930258,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1042685,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e8/fd/abb7bfe3.jpg","nickname":"Langzi233","note":"","ucode":"5A21AC08FC089B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":249634,"discussion_content":"我觉得，考虑到后面是对数组元素进行排序，那么冲突的用开放寻址法不就能把冲突的字符串分别存储于数组中不同的位置嘛，这样后续的排序就不用考虑前面利用哈希表统计次数时是否存在冲突了。结合起来思考问题，开放寻址法优于链表法","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1587949778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1613665,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9f/61/c46b42f4.jpg","nickname":"talkyoung","note":"","ucode":"8D231FA9004B64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1042685,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e8/fd/abb7bfe3.jpg","nickname":"Langzi233","note":"","ucode":"5A21AC08FC089B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":264071,"discussion_content":"好想法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589286338,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":249634,"ip_address":""},"score":264071,"extra":""},{"author":{"id":1303327,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e3/1f/bfea2679.jpg","nickname":"宋超","note":"","ucode":"ECA6126F076AB0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1042685,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e8/fd/abb7bfe3.jpg","nickname":"Langzi233","note":"","ucode":"5A21AC08FC089B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293218,"discussion_content":"你好，能否说的再详细一些，谢谢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595484062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":249634,"ip_address":""},"score":293218,"extra":""}]},{"author":{"id":1154935,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9f/77/3a8fb89f.jpg","nickname":"活水","note":"","ucode":"8A93734B62AF04","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73888,"discussion_content":"一旦有冲突这个方法就不对了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1575605370,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1069206,"avatar":"https://static001.geekbang.org/account/avatar/00/10/50/96/18612c89.jpg","nickname":"克","note":"","ucode":"6DDFBB05E0F4E9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1154935,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9f/77/3a8fb89f.jpg","nickname":"活水","note":"","ucode":"8A93734B62AF04","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77881,"discussion_content":"有冲突也可以啊，大哥，链表干嘛使的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575950728,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":73888,"ip_address":""},"score":77881,"extra":""},{"author":{"id":1775559,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/17/c7/e62643a3.jpg","nickname":"Geek_thefuture","note":"","ucode":"7100A3B76D20F0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1069206,"avatar":"https://static001.geekbang.org/account/avatar/00/10/50/96/18612c89.jpg","nickname":"克","note":"","ucode":"6DDFBB05E0F4E9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":107758,"discussion_content":"它的散列表里面只储存了出现次数value，而缺少了原本字符串和后来的字符串的比较，一旦有冲突，也就是说散列函数没有那么完美，使得不同的字符串有着同样的散列值，就会误判value + 1了，所以应该像microsoft里的揭发一样才对，value为字符串本身，如果散列值相同则进行再比较","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1577604669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":77881,"ip_address":""},"score":107758,"extra":""},{"author":{"id":1013841,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","nickname":"Smallfly","note":"","ucode":"D388D5E0249A69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1154935,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9f/77/3a8fb89f.jpg","nickname":"活水","note":"","ucode":"8A93734B62AF04","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":169635,"discussion_content":"我们使用现成的散列表是不用自己考虑冲突的。默认就认为复杂度O(1)。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1581638356,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":73888,"ip_address":""},"score":169635,"extra":""}]},{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":45336,"discussion_content":"第一题保存最大值是为了确定数据量的量级，从而确定使用桶排序或者快速排序？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1573024635,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1644104,"avatar":"https://static001.geekbang.org/account/avatar/00/19/16/48/09493874.jpg","nickname":"茶没喝完","note":"","ucode":"D72D88C42A1258","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78424,"discussion_content":"我觉得应该最大值应该是10万个url中，不相同的url有多少个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575989497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":45336,"ip_address":""},"score":78424,"extra":""}]},{"author":{"id":1478430,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKuEkja2Eib1cXFMh7kXbzFl2RQNea4CHrkXVRH98m7lzJWKIictyFdCWxvCNrlr8qjW5E4QBibpdGZQ/132","nickname":"lovingstranger","note":"","ucode":"5590AA5A7C3D4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2867,"discussion_content":"大神，能不能给个你写的10w条URL访问日志，按照访问次数给URL排序的代码呀，给个注释吧，你在留言区提供的思路我表示看的有点吃力，好难受额，谢谢啦","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1563982333,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1013841,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","nickname":"Smallfly","note":"","ucode":"D388D5E0249A69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1478430,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKuEkja2Eib1cXFMh7kXbzFl2RQNea4CHrkXVRH98m7lzJWKIictyFdCWxvCNrlr8qjW5E4QBibpdGZQ/132","nickname":"lovingstranger","note":"","ucode":"5590AA5A7C3D4F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7071,"discussion_content":"看我的另一条评论。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567335887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2867,"ip_address":""},"score":7071,"extra":""}]},{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427761,"discussion_content":"👍 这条留言可以顶上去了 其他同学都看看吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1541037156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":3,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2750312,"avatar":"https://static001.geekbang.org/account/avatar/00/29/f7/68/e3b1553a.jpg","nickname":"Wei鸿","note":"","ucode":"8015E5D852436C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":402275,"discussion_content":"请问一下，\n假设第一步在拿到访问次数和数据范围的时候，存在hash冲突的情况。也就是某两个不同的url的hashkey是一样的，如果value只存次数的话，是不是就解决不了hash冲突的问题呢？谢谢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1633851786,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2372063,"avatar":"https://static001.geekbang.org/account/avatar/00/24/31/df/2988f356.jpg","nickname":"better~","note":"","ucode":"A8243C5D4F935D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376979,"discussion_content":"对第一问中的快排解法有点疑惑，因为存在散列表中，想要获取到每一个频率次数需要先get(key),好像是不能直接用的，这样的话如何用快排呢？我记得快排一般都是基于数组使用的，数组是可以根据index直接获取到元素的，但是这里好像不行啊，必须get才行","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1622448210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1624355,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c9/23/76511858.jpg","nickname":"洛奇","note":"","ucode":"662B4005721119","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2372063,"avatar":"https://static001.geekbang.org/account/avatar/00/24/31/df/2988f356.jpg","nickname":"better~","note":"","ucode":"A8243C5D4F935D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385436,"discussion_content":"行的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627041171,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":376979,"ip_address":""},"score":385436,"extra":""},{"author":{"id":2694205,"avatar":"https://static001.geekbang.org/account/avatar/00/29/1c/3d/76465ee4.jpg","nickname":"摘星","note":"","ucode":"55D8CAFC938F91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1624355,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c9/23/76511858.jpg","nickname":"洛奇","note":"","ucode":"662B4005721119","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391220,"discussion_content":"咋行 请赐教","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630335680,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":385436,"ip_address":""},"score":391220,"extra":""},{"author":{"id":1624355,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c9/23/76511858.jpg","nickname":"洛奇","note":"","ucode":"662B4005721119","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2694205,"avatar":"https://static001.geekbang.org/account/avatar/00/29/1c/3d/76465ee4.jpg","nickname":"摘星","note":"","ucode":"55D8CAFC938F91","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392205,"discussion_content":"忘了，不好意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630902551,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":391220,"ip_address":""},"score":392205,"extra":""}]},{"author":{"id":1397201,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI7IxtBQbciclaJc5CcN5dz4Fia0r6XGCTEP3j02pprZYYQCNTtny1geWzn4uRULfCeaXkcFacS5V7Q/132","nickname":"StringTek","note":"","ucode":"BC65D8522FAAA4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":262244,"discussion_content":"请问第一题存入hash表的意义是什么","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589057139,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1632195,"avatar":"https://static001.geekbang.org/account/avatar/00/18/e7/c3/f7066fd1.jpg","nickname":"yw","note":"","ucode":"F937C47767822B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1397201,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI7IxtBQbciclaJc5CcN5dz4Fia0r6XGCTEP3j02pprZYYQCNTtny1geWzn4uRULfCeaXkcFacS5V7Q/132","nickname":"StringTek","note":"","ucode":"BC65D8522FAAA4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":265654,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589424185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":262244,"ip_address":""},"score":265654,"extra":""},{"author":{"id":1993083,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/69/7b/27e63c55.jpg","nickname":"神的孩子在跳舞","note":"","ucode":"B99AC3DFFBEC72","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1397201,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI7IxtBQbciclaJc5CcN5dz4Fia0r6XGCTEP3j02pprZYYQCNTtny1geWzn4uRULfCeaXkcFacS5V7Q/132","nickname":"StringTek","note":"","ucode":"BC65D8522FAAA4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269772,"discussion_content":"我觉得是为了方便统计URL的数量。因为hash(url)得到的是数组的下标，如果url相同，数组下标也相同，对应的value加一就好了。没有hash转化的话，就是直接对比url是否相同了，url本身就很复杂，一一比较很浪费时间","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1589948767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":262244,"ip_address":""},"score":269772,"extra":""},{"author":{"id":1640368,"avatar":"https://static001.geekbang.org/account/avatar/00/19/07/b0/4b9d0916.jpg","nickname":"范旭东","note":"","ucode":"06E8FF4BEBAA09","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1397201,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI7IxtBQbciclaJc5CcN5dz4Fia0r6XGCTEP3j02pprZYYQCNTtny1geWzn4uRULfCeaXkcFacS5V7Q/132","nickname":"StringTek","note":"","ucode":"BC65D8522FAAA4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":273962,"discussion_content":"我理解是为了桶排序。假设访问最大次数m，分m个桶，遍历url求hash访问次数，把当前url存到对应下标的桶里，遍历完后取出来就是顺序的url。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590508914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":262244,"ip_address":""},"score":273962,"extra":""}]},{"author":{"id":1433178,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJMzj0MHiaXBdDFp4E16qhu6PZlu6xkJRWgaoJXOeqMDDLqM4vcvUbnVLiactTypZkYibOg7okwm2TAQ/132","nickname":"Geek_921929","note":"","ucode":"26BF6978F040BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217848,"discussion_content":"相同访问次数的url也能适用？bucket[index]那里不会覆盖吗？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585582021,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1030639,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqWKj6kxC4ib8ia9tTz0CKvQYcjK6Maf5s1TVpMwtLs7ELkM3spzkbsnaMhoLqO1zkZqiaHFCX5ibibSYQ/132","nickname":"geekcat","note":"","ucode":"8CC3800E76176B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548403,"discussion_content":"https://blog.csdn.net/v_july_v/article/details/7382693 当然如果你看到了这条评论并进入了这篇博客，那么恭喜你","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643184774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1276652,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7a/ec/19104a37.jpg","nickname":"李强","note":"","ucode":"EE1F99E12D212E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":410235,"discussion_content":"第二题是否应该考虑哈希冲突","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635641320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1877862,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLu3MgZBAyyiavX2CMF2KRib791j3bBGiaQDzuQwBF2k6AKHANV2uTAAss2vVaeC7xcSYYD8vjmibRpTQ/132","nickname":"纵不朽","note":"","ucode":"DB2CA2C46B2EF1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362080,"discussion_content":"谁能告诉我为什么K小采用桶排序，K大用桶排序不是更好吗，每个桶里的东西更少","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616844133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2529210,"avatar":"https://static001.geekbang.org/account/avatar/00/26/97/ba/08d51165.jpg","nickname":"Thunder","note":"","ucode":"CA920DCDA93BCF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1877862,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLu3MgZBAyyiavX2CMF2KRib791j3bBGiaQDzuQwBF2k6AKHANV2uTAAss2vVaeC7xcSYYD8vjmibRpTQ/132","nickname":"纵不朽","note":"","ucode":"DB2CA2C46B2EF1","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":366808,"discussion_content":"k越大桶越多，举个极端的例子假如k的最大值为一亿，那你需要一亿个桶，数据一共才十万条，分布明显是不均匀的，你再去用桶排序。。。gg，会造成大量资源浪费","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1618195636,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":362080,"ip_address":""},"score":366808,"extra":""},{"author":{"id":1624355,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c9/23/76511858.jpg","nickname":"洛奇","note":"","ucode":"662B4005721119","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2529210,"avatar":"https://static001.geekbang.org/account/avatar/00/26/97/ba/08d51165.jpg","nickname":"Thunder","note":"","ucode":"CA920DCDA93BCF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385437,"discussion_content":"桶是区间吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627041242,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":366808,"ip_address":""},"score":385437,"extra":""}]},{"author":{"id":1476490,"avatar":"https://static001.geekbang.org/account/avatar/00/16/87/8a/07ab933c.jpg","nickname":"璀璨星空","note":"","ucode":"CE6324C4261A52","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337902,"discussion_content":"这2个问题在实际开发中用得很多","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609121190,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1669343,"avatar":"https://static001.geekbang.org/account/avatar/00/19/78/df/424bdc4a.jpg","nickname":"于途","note":"","ucode":"70300C6CCCEAF1","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324178,"discussion_content":"10万条URL访问日志，假设1条日志占用1KB，那么10万条大约为100MB，完全可以读取到内存中处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605065910,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":317623,"discussion_content":"用key做字符串，数组10万*url字符串128B=12.8MB大小的数组？堆可以一次性申请这么大的数组吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603584291,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2121286,"avatar":"https://static001.geekbang.org/account/avatar/00/20/5e/46/fbb0c3d0.jpg","nickname":"Tidas","note":"","ucode":"2983BFA909F929","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303789,"discussion_content":"如果存在hash冲突，这种怎么解决，岂不是两个不同的URL计算总的次数，这样结果是不是就错了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599381907,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1796438,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/zlWt0lPDicdib5BTUbuwA3wLLUuejtZ5icGu3DHMBPd6PicXOdhZ3zYFts8VkXjjyQuxzUJas2w5OTmx3icWKiaZM1Vg/132","nickname":"youyou.L","note":"","ucode":"B3DB0D0700EEAC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2121286,"avatar":"https://static001.geekbang.org/account/avatar/00/20/5e/46/fbb0c3d0.jpg","nickname":"Tidas","note":"","ucode":"2983BFA909F929","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308596,"discussion_content":"hash冲突用链表，比较key值就行了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601001068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":303789,"ip_address":""},"score":308596,"extra":""},{"author":{"id":1515149,"avatar":"https://static001.geekbang.org/account/avatar/00/17/1e/8d/5b242931.jpg","nickname":"Fish","note":"","ucode":"C20719F8B0F7C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2121286,"avatar":"https://static001.geekbang.org/account/avatar/00/20/5e/46/fbb0c3d0.jpg","nickname":"Tidas","note":"","ucode":"2983BFA909F929","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318740,"discussion_content":"value为结构体，保存url何访问次数","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1603840795,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":303789,"ip_address":""},"score":318740,"extra":""},{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1515149,"avatar":"https://static001.geekbang.org/account/avatar/00/17/1e/8d/5b242931.jpg","nickname":"Fish","note":"","ucode":"C20719F8B0F7C8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351578,"discussion_content":"value就是访问次数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614334232,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":318740,"ip_address":""},"score":351578,"extra":""}]},{"author":{"id":1049017,"avatar":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","nickname":"学习学个屁","note":"","ucode":"DF2D61E6FB2FCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302071,"discussion_content":"我也是这么想的,不过第一题key数量哪儿 没考虑全,桶排序和快排,优秀啊,还是考虑问题不够全面...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598779470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1930296,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/74/38/93e4694a.jpg","nickname":"L-伟彪","note":"","ucode":"9A21FD80FD7A93","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":264197,"discussion_content":"我以为是次数作为key，url作为value ，存入数组，发生key冲突就用链表法，这样相当于排好序了吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589293802,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1703256,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fd/58/1af629c7.jpg","nickname":"请叫我和尚","note":"","ucode":"33A8A1CDA103F9","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":1930296,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/74/38/93e4694a.jpg","nickname":"L-伟彪","note":"","ucode":"9A21FD80FD7A93","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":280042,"discussion_content":"如果次数当key，那这个key根据什么来计算","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591459435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":264197,"ip_address":""},"score":280042,"extra":""},{"author":{"id":1609114,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8d/9a/61db513f.jpg","nickname":"赵源😈","note":"","ucode":"3D438CC59126F2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1930296,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/74/38/93e4694a.jpg","nickname":"L-伟彪","note":"","ucode":"9A21FD80FD7A93","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":313036,"discussion_content":"url为value的话，就不是数值了啊？怎么去映射数组下标？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602919134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":264197,"ip_address":""},"score":313036,"extra":""},{"author":{"id":1172090,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e2/7a/38a27e47.jpg","nickname":"蓦然回首","note":"","ucode":"B17658DCFE6402","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1930296,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/74/38/93e4694a.jpg","nickname":"L-伟彪","note":"","ucode":"9A21FD80FD7A93","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334165,"discussion_content":"感觉通过散列链表法也可以实现，统计出每个url的次数，然后用相同次数的以次数作为下标，一次放进对应下标的数组不就行了？这里根本就不需要什么桶排序，快速排序之类的，构建完散列表，依次从下标0对应的值非空的下标遍历完整个数组就行了！10万条记录，就算浪费一些数组空间，也不会浪费多少。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607757379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":264197,"ip_address":""},"score":334165,"extra":""}]},{"author":{"id":1844270,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJrZb9pm07aiciaNalQ0gRgMub2In4RQHYSd7VI2gvsTQMC1wSsYfcxxCYCeBmrs6Vic7GRf9jtNRqyA/132","nickname":"壮壮.java","note":"","ucode":"755C8C8A823B70","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261028,"discussion_content":"完美，第一题桶的value应该用链表；","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588931323,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015172,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7d/84/abb7bfe3.jpg","nickname":"air","note":"","ucode":"57945C96248587","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":237453,"discussion_content":"第二题不用存次数，直接存字符串不也行么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587142659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1005824,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/00/6d14972a.jpg","nickname":"Arthur.Li","note":"","ucode":"EC2436A5136C13","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1015172,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7d/84/abb7bfe3.jpg","nickname":"air","note":"","ucode":"57945C96248587","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":251429,"discussion_content":"可以，但是占内存，其实直接一个1就行了，主要用于第二个数组遍历判断都没有","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588084246,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":237453,"ip_address":""},"score":251429,"extra":""},{"author":{"id":1215892,"avatar":"https://static001.geekbang.org/account/avatar/00/12/8d/94/150dfe78.jpg","nickname":"GGL","note":"","ucode":"AED10B8248D1E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1015172,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7d/84/abb7bfe3.jpg","nickname":"air","note":"","ucode":"57945C96248587","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260392,"discussion_content":"不考虑哈希冲突吗？不同的字符串也存在哈希值一样的情况","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588862597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":237453,"ip_address":""},"score":260392,"extra":""},{"author":{"id":1703256,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fd/58/1af629c7.jpg","nickname":"请叫我和尚","note":"","ucode":"33A8A1CDA103F9","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":1215892,"avatar":"https://static001.geekbang.org/account/avatar/00/12/8d/94/150dfe78.jpg","nickname":"GGL","note":"","ucode":"AED10B8248D1E7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":280043,"discussion_content":"个人觉得这个就需要考虑散列函数的设计了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591459480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":260392,"ip_address":""},"score":280043,"extra":""}]},{"author":{"id":1284647,"avatar":"https://static001.geekbang.org/account/avatar/00/13/9a/27/4b81bce5.jpg","nickname":"笑","note":"","ucode":"C91EAFAB88E5AC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":230528,"discussion_content":"太优秀了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586750598,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1812840,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a9/68/ec442a70.jpg","nickname":"王jojo","note":"","ucode":"1ABE7FA2614F86","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":228801,"discussion_content":"第二题问下,如果A中有n个字符a, B中没有a,按照这个算法的话,a就成了A和B中都含有的相同字符串了,感觉不太符合我理解的题意","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586578097,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1013841,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","nickname":"Smallfly","note":"","ucode":"D388D5E0249A69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1812840,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a9/68/ec442a70.jpg","nickname":"王jojo","note":"","ucode":"1ABE7FA2614F86","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":229021,"discussion_content":"B 中没有 a 就无法知道在 A 构成的散列表中有没有a 了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586603205,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":228801,"ip_address":""},"score":229021,"extra":""},{"author":{"id":1515149,"avatar":"https://static001.geekbang.org/account/avatar/00/17/1e/8d/5b242931.jpg","nickname":"Fish","note":"","ucode":"C20719F8B0F7C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1812840,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a9/68/ec442a70.jpg","nickname":"王jojo","note":"","ucode":"1ABE7FA2614F86","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318741,"discussion_content":"先进行AB长度比较。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603841442,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":228801,"ip_address":""},"score":318741,"extra":""}]},{"author":{"id":1853517,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/48/4d/993204ff.jpg","nickname":"Steven.Tudou_yang","note":"","ucode":"1B1C4418A0BFB2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":228060,"discussion_content":"冲突了就用链表法去解决吧！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586524488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1042685,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e8/fd/abb7bfe3.jpg","nickname":"Langzi233","note":"","ucode":"5A21AC08FC089B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1853517,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/48/4d/993204ff.jpg","nickname":"Steven.Tudou_yang","note":"","ucode":"1B1C4418A0BFB2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":249625,"discussion_content":"这里不能用链表法，因为后续排序可以用桶排序或者快排，是对数组中的元素进行排序，用链表法两个不同键值的字符串存储在同一个数组下标处，会徒增排序难度","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587949554,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":228060,"ip_address":""},"score":249625,"extra":""}]},{"author":{"id":1324863,"avatar":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","nickname":"KK","note":"","ucode":"FFC31A3FE3A285","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":226110,"discussion_content":"这里的哈希函数是多少？怎么感觉没看懂呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586421521,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1451434,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/YT6icqxsxKMN7LEvpTHQdzXjgKM1zc76toTxOmykPkqY5kDJVyOPwM531DibhCN63g1wu8r1Kw5225d74RUibgdJA/132","nickname":"sunshine","note":"","ucode":"F400B2791D0642","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74900,"discussion_content":"这种解法只考虑无冲突的情况，如果出现冲突，时间复杂度为o(n2)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575703109,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":45332,"discussion_content":"第一题保存最大值是为了确定分区点吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573024409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1664806,"avatar":"https://static001.geekbang.org/account/avatar/00/19/67/26/12ef1cdf.jpg","nickname":"A(๑°3°๑)DreamH","note":"","ucode":"CF2B712FCFF165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":43218,"discussion_content":"第一题，如果两个url访问次数相同，buckets数组里存的url会被覆盖","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572863801,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1664806,"avatar":"https://static001.geekbang.org/account/avatar/00/19/67/26/12ef1cdf.jpg","nickname":"A(๑°3°๑)DreamH","note":"","ucode":"CF2B712FCFF165","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":45333,"discussion_content":"文中有解决冲突后的方案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573024556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":43218,"ip_address":""},"score":45333,"extra":""},{"author":{"id":1437292,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ee/6c/246fa0d1.jpg","nickname":"Mr.差不多","note":"","ucode":"946555FCAE710B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1664806,"avatar":"https://static001.geekbang.org/account/avatar/00/19/67/26/12ef1cdf.jpg","nickname":"A(๑°3°๑)DreamH","note":"","ucode":"CF2B712FCFF165","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56682,"discussion_content":"以url为key，两个不同的url很少有相同的hash值，就算有的话也可以使用链表来解决冲突，即将冲突的url作为一个节点加到链头或链尾","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574507760,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":43218,"ip_address":""},"score":56682,"extra":""},{"author":{"id":1798068,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/6f/b4/d465acef.jpg","nickname":"啊噗！","note":"","ucode":"C911E772E1E800","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":161315,"discussion_content":"这个跟冲突没关系把？value存的是访问次数 不是散列值 你们好像把散列值和value搞混了 如果说两个url计算出来的散列值相同 那才是冲突 访问次数相同又没关系 只是value存储的对象而已","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1580887805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":45333,"ip_address":""},"score":161315,"extra":""}]},{"author":{"id":1116673,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0a/01/3bd45e1e.jpg","nickname":"leesir","note":"","ucode":"D720A0966666D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4216,"discussion_content":"第一点看不太懂，第二点还需要考虑散列冲突","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565231205,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1013841,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","nickname":"Smallfly","note":"","ucode":"D388D5E0249A69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1116673,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0a/01/3bd45e1e.jpg","nickname":"leesir","note":"","ucode":"D720A0966666D9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7072,"discussion_content":"如果使用现成的散列表，自己不用考虑冲突问题。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1567335932,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4216,"ip_address":""},"score":7072,"extra":""}]},{"author":{"id":1438102,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f1/96/9571fa3d.jpg","nickname":"青青子衿","note":"","ucode":"4A388A3BA70C29","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3509,"discussion_content":"是不是应该有个前提，即不会发生散列冲突？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564543019,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36110,"user_name":"姜威","can_delete":false,"product_type":"c1","uid":1244051,"ip_address":"","ucode":"C58EB9A5AD634D","user_header":"https://static001.geekbang.org/account/avatar/00/12/fb/93/f19a5364.jpg","comment_is_top":false,"comment_ctime":1540946382,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"409562839502","product_id":100017301,"comment_content":"总结：<br>一、散列表的由来？<br>1.散列表来源于数组，它借助散列函数对数组这种数据结构进行扩展，利用的是数组支持按照下标随机访问元素的特性。<br>2.需要存储在散列表中的数据我们称为键，将键转化为数组下标的方法称为散列函数，散列函数的计算结果称为散列值。<br>3.将数据存储在散列值对应的数组下标位置。<br>二、如何设计散列函数？<br>总结3点设计散列函数的基本要求<br>1.散列函数计算得到的散列值是一个非负整数。<br>2.若key1=key2，则hash(key1)=hash(key2)<br>3.若key≠key2，则hash(key1)≠hash(key2)<br>正是由于第3点要求，所以产生了几乎无法避免的散列冲突问题。<br>三、散列冲突的解放方法？<br>1.常用的散列冲突解决方法有2类：开放寻址法（open addressing）和链表法（chaining）<br>2.开放寻址法<br>①核心思想：如果出现散列冲突，就重新探测一个空闲位置，将其插入。<br>②线性探测法（Linear Probing）：<br>插入数据：当我们往散列表中插入数据时，如果某个数据经过散列函数之后，存储的位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。<br>查找数据：我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素是否相等，若相等，则说明就是我们要查找的元素；否则，就顺序往后依次查找。如果遍历到数组的空闲位置还未找到，就说明要查找的元素并没有在散列表中。<br>删除数据：为了不让查找算法失效，可以将删除的元素特殊标记为deleted，当线性探测查找的时候，遇到标记为deleted的空间，并不是停下来，而是继续往下探测。<br>结论：最坏时间复杂度为O(n)<br>③二次探测（Quadratic probing）：线性探测每次探测的步长为1，即在数组中一个一个探测，而二次探测的步长变为原来的平方。<br>④双重散列（Double hashing）：使用一组散列函数，直到找到空闲位置为止。<br>⑤线性探测法的性能描述：<br>用“装载因子”来表示空位多少，公式：散列表装载因子=填入表中的个数&#47;散列表的长度。<br>装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。<br>3.链表法（更常用）<br>插入数据：当插入的时候，我们需要通过散列函数计算出对应的散列槽位，将其插入到对应的链表中即可，所以插入的时间复杂度为O(1)。<br>查找或删除数据：当查找、删除一个元素时，通过散列函数计算对应的槽，然后遍历链表查找或删除。对于散列比较均匀的散列函数，链表的节点个数k=n&#47;m，其中n表示散列表中数据的个数，m表示散列表中槽的个数，所以是时间复杂度为O(k)。<br>四、思考<br>1.Word文档中单词拼写检查功能是如何实现的？<br>字符串占用内存大小为8字节，20万单词占用内存大小不超过20MB，所以用散列表存储20万英文词典单词，然后对每个编辑进文档的单词进行查找，若未找到，则提示拼写错误。<br>2.假设我们有10万条URL访问日志，如何按照访问次数给URL排序？<br>字符串占用内存大小为8字节，10万条URL访问日志占用内存不超过10MB，通过散列表统计url访问次数，然后用TreeMap存储散列表的元素值（作为key）和数组下标值（作为value）<br>3.有两个字符串数组，每个数组大约有10万条字符串，如何快速找出两个数组中相同的字符串？<br>分别将2个数组的字符串通过散列函数映射到散列表，散列表中的元素值为次数。注意，先存储的数组中的相同元素值不进行次数累加。最后，统计散列表中元素值大于等于2的散列值对应的字符串就是两个数组中相同的字符串。","like_count":95,"discussions":[{"author":{"id":1041217,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e3/41/abb7bfe3.jpg","nickname":"CozyThinker","note":"","ucode":"996D8B8C993C5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":104,"discussion_content":"思考2有问题吧\n一条URL为什么大小为8字节，URL长度不一定，如果很长可能是50字节","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1561103808,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1201998,"avatar":"https://static001.geekbang.org/account/avatar/00/12/57/4e/302bfe22.jpg","nickname":"啊波次的额佛哥～","note":"","ucode":"6F31255207CB17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584646,"discussion_content":"一般查找元素的需求都是已知key，不知道value，处理hash冲突还需要比较value，这个有点不大理解，貌似这种查询没啥意义呢。key value都知道为什么还要查找，哈哈，感觉平常认知不符~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660988001,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1533999,"avatar":"https://static001.geekbang.org/account/avatar/00/17/68/2f/fb25a9ef.jpg","nickname":"sunflower","note":"","ucode":"E1E494D59F88C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332991,"discussion_content":"hp~~~~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607410726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1380312,"avatar":"https://static001.geekbang.org/account/avatar/00/15/0f/d8/9286b272.jpg","nickname":"leetcode","note":"","ucode":"3B8C3668A0DE74","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":265920,"discussion_content":"课代表\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589455524,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36104,"user_name":"醉比","can_delete":false,"product_type":"c1","uid":1248399,"ip_address":"","ucode":"79E65F62BE7809","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/8f/4ebd303a.jpg","comment_is_top":false,"comment_ctime":1540945018,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"263533950074","product_id":100017301,"comment_content":"看到链表那一块感觉是hashmap的实现原理呀","like_count":60,"discussions":[{"author":{"id":2895981,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/30/6d/a678c9a2.jpg","nickname":"Return to zero","note":"","ucode":"074C9B1B4CBF18","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571826,"discussion_content":"其实可以具体点：\n例如：\nHashMap用的就是链表法解决；\nThreadLocal用的就是开放寻址法解决。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1652425037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1246451,"avatar":"https://static001.geekbang.org/account/avatar/00/13/04/f3/a3ff8a58.jpg","nickname":"roseduan","note":"","ucode":"5BB69BB9D329EC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330340,"discussion_content":"原理是这个，但实际的实现还是挺复杂的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1606572977,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1591230,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/25d7qAwOPAw5E5pBepSxkAnN2icCgum3BYBURmOHADDg45Iricq8QhtONoFQ4lqVMziavh4ZRialqrQtzwk5iakNI2A/132","nickname":"天涯","note":"","ucode":"6D6AB6FE6092B8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351443,"discussion_content":"而且hashmap还引入了装载因子来降低哈希冲突的概率。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1614267112,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1593957,"avatar":"https://static001.geekbang.org/account/avatar/00/18/52/65/320eccb3.jpg","nickname":"王斯拉","note":"","ucode":"D00DD3CE432189","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":248512,"discussion_content":"本来就是，只不过你看jdk8以后加入了红黑树= - ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587878006,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1035744,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cd/e0/c85bb948.jpg","nickname":"朱雯","note":"","ucode":"064C45FBF6B51F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300138,"discussion_content":"我也想到了hashmap的实现，只是好像jdk后面的版本变了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597946361,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36087,"user_name":"五岳寻仙","can_delete":false,"product_type":"c1","uid":1247467,"ip_address":"","ucode":"88A46A4E1832CE","user_header":"https://static001.geekbang.org/account/avatar/00/13/08/eb/594e9e6c.jpg","comment_is_top":false,"comment_ctime":1540942764,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"263533947820","product_id":100017301,"comment_content":"今天学习了散列表的原理，以及两种解决hash冲突的方法：开放地址法和链表法。<br>课后思考题第一题，我觉得可以用hash表的链表法解决。访问次数作为slot，访问次数相同的URL放入同一个slot所对应的一条链表中，这样只需要扫一遍所有的URL就排好序了，时间复杂度为O(n)<br>第二题跟老师讲的word拼写检查有点像，我觉得可以将一个字符串数组做成hash表，然后扫描另一个字符串数组，就能找到重复的字符串。制作和扫描hash表的算法复杂度都是O(n)","like_count":61,"discussions":[{"author":{"id":1069407,"avatar":"https://static001.geekbang.org/account/avatar/00/10/51/5f/abb7bfe3.jpg","nickname":"来来baby","note":"","ucode":"59EF2826EA2B28","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6973,"discussion_content":"你的槽的访问次数怎么获取到呢","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1567236803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1133055,"avatar":"https://static001.geekbang.org/account/avatar/00/11/49/ff/34a47dca.jpg","nickname":"4567890","note":"","ucode":"23BC97FD1DADF0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":216416,"discussion_content":"那你整个的过程是怎么样的？\n是只读取一遍所有的URL吗？\n那么，随着读取到新的URL -A ，就把之前的URL-A 从3次那个后面的拉链中取下来，然后再把URL-A挂到4次的slot后面？\n\n那么，你读取到一次URL-A之后，如果快速的找到之前的URL-A是多少次呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585447758,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1389668,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/dz0A1T9kFHR5IohqbetbuibY0giaRlnrggfbJZiaQxogTVS7P5hALhpuSDWYPuiarqnvVyCWs6RXYtC0HLgkicsKicBA/132","nickname":"麦","note":"","ucode":"3C2205E5676416","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1133055,"avatar":"https://static001.geekbang.org/account/avatar/00/11/49/ff/34a47dca.jpg","nickname":"4567890","note":"","ucode":"23BC97FD1DADF0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":323880,"discussion_content":"感觉可以 再新建一个hash表，url为key 次数为value. 每扫到一次则删除次数对应的槽里该url，并且value+1 最后得到的次数为key的表 里的url是有序的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605013232,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":216416,"ip_address":""},"score":323880,"extra":""}]},{"author":{"id":1318394,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1d/fa/b81c89c3.jpg","nickname":"isobelar","note":"","ucode":"58CE4061984B43","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":249985,"discussion_content":"能否反过来，散列表的KEY统计url访问次数，VALUE表示具有相同访问次数的url数组。按照排序后的KEY输出对应数组中的url地址值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587982068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1686410,"avatar":"https://static001.geekbang.org/account/avatar/00/19/bb/8a/d33d9d3f.jpg","nickname":"小菠萝🍍","note":"","ucode":"DA814203C6C062","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":202435,"discussion_content":"如果用访问次数作Slot如何将hash后的下标对应上访问次数呢？使用URL或者访问次数进行hash后的下标都没法保证它对应着数组中的访问次数吧？个人理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583917870,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1299543,"avatar":"https://static001.geekbang.org/account/avatar/00/13/d4/57/b0a11ae5.jpg","nickname":"华仔","note":"","ucode":"F794510431C343","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1686410,"avatar":"https://static001.geekbang.org/account/avatar/00/19/bb/8a/d33d9d3f.jpg","nickname":"小菠萝🍍","note":"","ucode":"DA814203C6C062","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":205762,"discussion_content":"可以的，这里可能不是一个完全意义上的hash表，可以先判断出所有访问值的最大值，然后创建一个长度为这个最大值的数组，这样，任何hash值下面的链表里的url的访问次数都会等于数组下标，也就是保证没有碰撞。但是仍然会用到链表在一个下表存储多条数据，原因是同一个key（访问次数）对应着多个url，不是严格意义上的hash table。但是算法我感觉没有问题，唯一可能的问题是如果某条url访问次数奇高，导致该算法效率降低。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1584339890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":202435,"ip_address":""},"score":205762,"extra":""}]}]},{"had_liked":false,"id":37948,"user_name":"追风者","can_delete":false,"product_type":"c1","uid":1055092,"ip_address":"","ucode":"879BC372A6B605","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIjUDIRQ0gRiciax3Wo78c5rVjuWDiaw4ibcCiby8xiaMXJh5ibjU5242vfCGOK4ehibe1IKyxex2A4IX4XSA/132","comment_is_top":false,"comment_ctime":1541821738,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"186225415466","product_id":100017301,"comment_content":"关于100万URL排序问题？<br>我看了半天置顶的回答，没太明白。<br>url为key，出现次数count为value。数组的下标为hash(key)得到的值，保存的内容为count。<br>排序阶段根据count排序，不是只是改变count的位置么，对应的地址没有改变啊。<br>如果说散列表是链表法的形式，难道排序的时候也会改变链表的头指针地址？那再要查找对应url的访问次数不就不行了。","like_count":43,"discussions":[{"author":{"id":1141173,"avatar":"https://static001.geekbang.org/account/avatar/00/11/69/b5/1e1731cc.jpg","nickname":"zs阿帅","note":"","ucode":"07A54AE7F1CAFF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":135244,"discussion_content":"哈希表中存的是一个整体，包括url和cout","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1579079713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1737805,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/84/4d/84371716.jpg","nickname":"何雷","note":"","ucode":"FA9BCE7DD9C8C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":58547,"discussion_content":"排序的时候，虽然比较的是count值，但是交换的是key","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1574680549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2416813,"avatar":"","nickname":"Geek_143a2b","note":"","ucode":"56D67C2C4BEEAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342853,"discussion_content":"遍历一遍map,得到所有key的list, 每次比较key对应的value，移动key,最后得到有序的key","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1610853082,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2654225,"avatar":"","nickname":"Geek_6923ae","note":"","ucode":"9D906E2DA64250","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2416813,"avatar":"","nickname":"Geek_143a2b","note":"","ucode":"56D67C2C4BEEAF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378553,"discussion_content":"666, 懂了，我终于懂了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623286182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":342853,"ip_address":""},"score":378553,"extra":""},{"author":{"id":1144627,"avatar":"https://static001.geekbang.org/account/avatar/00/11/77/33/121176bb.jpg","nickname":"东","note":"","ucode":"CEE6AC611E351B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2416813,"avatar":"","nickname":"Geek_143a2b","note":"","ucode":"56D67C2C4BEEAF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380569,"discussion_content":"那hash后的key 不就对应不上数组的位置了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624585662,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":342853,"ip_address":""},"score":380569,"extra":""}]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":71859,"discussion_content":"别太纠结value的涵义，可以是url的相关信息的集合体，比如bean","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1575462468,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1716067,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/2f/63/7a048d46.jpg","nickname":"梨子苹果","note":"","ucode":"3666813FEE31D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70941,"discussion_content":"其实就是找重复次数最多的字符串","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1575383644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36151,"user_name":"leo","can_delete":false,"product_type":"c1","uid":1107385,"ip_address":"","ucode":"0A3D3508398328","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLhicDSmL4vicPF4mF9g5icORERwDSqZv5Guk0TyhiacuBsiaVxCdktI6oCrKzcycwFlpyL6Q1nDbvJZzA/132","comment_is_top":false,"comment_ctime":1540956244,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"169044680788","product_id":100017301,"comment_content":"Redis的字典是使用链式法来解决散列冲突的，并且使用了渐进式rehash的方式来进行哈希表的弹性扩容（https:&#47;&#47;cloud.tencent.com&#47;developer&#47;article&#47;1353754，请大家斧正）。<br>两道思考题使用哈希表都可以解决，第二道题也可以对字符串数组进行排序后使用双指针判断，但字符串的比较成本较高，如果是整数类型更加适用。另外，哈希表比较经典的应用还有bitmap和布隆过滤器，其中布隆过滤器也可以用于文本判重，但是有一定的误判概率，可以根据场景使用。","like_count":39,"discussions":[{"author":{"id":1293907,"avatar":"https://static001.geekbang.org/account/avatar/00/13/be/53/eda4b622.jpg","nickname":"Smile @ Life","note":"","ucode":"320EDAD5A8BE56","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289739,"discussion_content":"go语言看的好难受","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594197046,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36092,"user_name":"黄金的太阳","can_delete":false,"product_type":"c1","uid":1105079,"ip_address":"","ucode":"9D7F2397124AB9","user_header":"https://static001.geekbang.org/account/avatar/00/10/dc/b7/e59c22f0.jpg","comment_is_top":false,"comment_ctime":1540943471,"is_pvip":false,"replies":[{"id":"12824","content":"相同散列值 但是key不同的 可以再对比key","user_name":"作者回复","comment_id":36092,"uid":"1190123","ip_address":"","utype":1,"ctime":1540949547,"user_name_real":"gg"}],"discussion_count":13,"race_medal":0,"score":"169044668015","product_id":100017301,"comment_content":"请教老师，当我在查找元素时候，在相同散列值的链表中遍历如何区分哪个是我要找的元素？毕竟查找时查询条件只包含KEY的信息吧","like_count":39,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427748,"discussion_content":"相同散列值 但是key不同的 可以再对比key","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540949547,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":71862,"discussion_content":"算出的index相同，则为了区分key，value 也可以存放key的相关信息！","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1575462616,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1607649,"avatar":"https://static001.geekbang.org/account/avatar/00/18/87/e1/7620e1b9.jpg","nickname":"小小光头","note":"","ucode":"D897582E93A6AA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42387,"discussion_content":"存入的元素应该是包含了key和value的信息的，是一个键值对","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1572663246,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1014550,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/16/ca250e8c.jpg","nickname":"王木公","note":"","ucode":"F049AEBFA0338D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41827,"discussion_content":"此处的key就是元素本身，不同的key产生了相同的散列值，再比较该散列值对应的散列表中对应的元素值是否和我们要找的元素即key相等","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1572514884,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1240710,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ee/86/9f47c0dc.jpg","nickname":"落","note":"","ucode":"EA306D36D818BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206510,"discussion_content":"HashMap","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584410072,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1448864,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1b/a0/7c7d1b4a.jpg","nickname":"徐帅","note":"","ucode":"BDF904280E2330","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41782,"discussion_content":"同问，通过老师回复已经解决","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572503632,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1235365,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d9/a5/5acd0cb1.jpg","nickname":"Ki","note":"","ucode":"D7A4514DD42C1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6981,"discussion_content":"同问，这个开放寻址的查询过程没想明白。既然下标已经是散列后的值，如何再去比较key？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567240674,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1235365,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d9/a5/5acd0cb1.jpg","nickname":"Ki","note":"","ucode":"D7A4514DD42C1A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":146259,"discussion_content":"传参的时候除了传散列后的值还可以加个参数为原始key","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579605566,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":6981,"ip_address":""},"score":146259,"extra":""}]},{"author":{"id":1253052,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1e/bc/6839e3ca.jpg","nickname":"叶鹏","note":"","ucode":"209A8B210C340B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6892,"discussion_content":"key是不同的，但是通过散列函数算出来的散列值是相同的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567156081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1375821,"avatar":"https://static001.geekbang.org/account/avatar/00/14/fe/4d/e5c33794.jpg","nickname":"慧慧","note":"","ucode":"C1CDB9BF4564C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6668,"discussion_content":"同问，开放寻址也存在此问题，散列冲突存的时候没有与key对应，取的时候，如何区分呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567043879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1583499,"avatar":"https://static001.geekbang.org/account/avatar/00/18/29/8b/3629c0f8.jpg","nickname":"游山行人","note":"","ucode":"E559BD0A3C6484","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1375821,"avatar":"https://static001.geekbang.org/account/avatar/00/14/fe/4d/e5c33794.jpg","nickname":"慧慧","note":"","ucode":"C1CDB9BF4564C7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219264,"discussion_content":"存储的时候加入key值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585748800,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":6668,"ip_address":""},"score":219264,"extra":""}]},{"author":{"id":1241328,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f0/f0/21411503.jpg","nickname":"钱程锦","note":"","ucode":"293CEF7D8ED762","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6546,"discussion_content":"key只作为条件输入后，变成散列值就是一样的了，找到多个元素后，怎么知道这个元素对应的key呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566964332,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1798068,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/6f/b4/d465acef.jpg","nickname":"啊噗！","note":"","ucode":"C911E772E1E800","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1241328,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f0/f0/21411503.jpg","nickname":"钱程锦","note":"","ucode":"293CEF7D8ED762","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":161325,"discussion_content":"value 存储key+value","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1580889199,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":6546,"ip_address":""},"score":161325,"extra":""}]}]},{"had_liked":false,"id":40618,"user_name":"王荣慧","can_delete":false,"product_type":"c1","uid":1255948,"ip_address":"","ucode":"54566879CEB0C5","user_header":"https://static001.geekbang.org/account/avatar/00/13/2a/0c/b9eafe83.jpg","comment_is_top":false,"comment_ctime":1542636724,"is_pvip":false,"replies":[{"id":"14660","content":"表述的不准确 我的意思是散列表中存储对象 对象包含key和附属字段 根据key构建散列表 查询的时候也是根据key  但是同一个散列值可能对应多个key 在查询的时候不能仅仅通过key的散列值 还要对比key","user_name":"作者回复","comment_id":40618,"uid":"1190123","ip_address":"","utype":1,"ctime":1542678482,"user_name_real":"gg"}],"discussion_count":4,"race_medal":0,"score":"147571524788","product_id":100017301,"comment_content":"有个疑问，如果在冲突的位置的下一个空闲位置存储数据，文中提到，根据key算出的位置存储的值和要查询的数据进行对比，确定是否是要查询的数据，如果我已经知道了要查询的数据，应该就不用查询了吧，这个地方不大理解。","like_count":34,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429571,"discussion_content":"表述的不准确 我的意思是散列表中存储对象 对象包含key和附属字段 根据key构建散列表 查询的时候也是根据key  但是同一个散列值可能对应多个key 在查询的时候不能仅仅通过key的散列值 还要对比key","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542678482,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1058015,"avatar":"https://static001.geekbang.org/account/avatar/00/10/24/df/645f8087.jpg","nickname":"Yayu","note":"","ucode":"5E7842458D8229","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":208574,"discussion_content":"同样的疑惑，看了这个回复才搞明白。正文中的表达太具迷惑性了，建议老师重构之。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1584549061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1235365,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d9/a5/5acd0cb1.jpg","nickname":"Ki","note":"","ucode":"D7A4514DD42C1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6982,"discussion_content":"这个解答才看明白。。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567240837,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1231172,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c9/44/099cfaf8.jpg","nickname":"丶汉特先森","note":"","ucode":"F262375A556760","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269355,"discussion_content":"和我的疑问一样，猜测应该是数组里本身存了key，不然我都知道值了还对比值干嘛","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589898056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36939,"user_name":"这么写的闫","can_delete":false,"product_type":"c1","uid":1246059,"ip_address":"","ucode":"95B0D1E1A094C8","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/6b/f31d4538.jpg","comment_is_top":false,"comment_ctime":1541397882,"is_pvip":false,"replies":[{"id":"13257","content":"再全量对比 因为散列表中存储的不仅仅是哈希值 还有全量的数据信息","user_name":"作者回复","comment_id":36939,"uid":"1190123","ip_address":"","utype":1,"ctime":1541468217,"user_name_real":"gg"}],"discussion_count":3,"race_medal":0,"score":"126095449466","product_id":100017301,"comment_content":"当散列冲突，表中存储了多个相同散列值时，查询数据怎么确定查询到的是我想要的那个？<br>这一点很疑惑，求指点","like_count":29,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428092,"discussion_content":"再全量对比 因为散列表中存储的不仅仅是哈希值 还有全量的数据信息","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541468217,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351581,"discussion_content":"就是链表O(n)遍历","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614334445,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1692886,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKx6EdicYYuYK62r5aphMtYw6HskzPhbI3xRicxWticwKMhaO3Z63OYmr55FcjvNRClg93yhQ1U2BQXw/132","nickname":"chuck","note":"","ucode":"2229324EB1CD8B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327763,"discussion_content":"同一散列值后面接的是一个链表，链表么，在C中就是结构体，里面想存什么就存些什么。每个链表的结点可以放入key和value值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605941487,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36129,"user_name":"他城之途","can_delete":false,"product_type":"c1","uid":1241716,"ip_address":"","ucode":"EC5659F234120C","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/74/36a86f4b.jpg","comment_is_top":false,"comment_ctime":1540950248,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"100325198056","product_id":100017301,"comment_content":"关于课后习题，基于某种语言的sdk实现起来可能比较容易，显然老师问的是思想，下面是我的理解，望老师和大家指正。<br>习题1，先分组累加次数再排序: 遍历10万数据，通过hash把相同url分组到同一个bucket下，如果bucket已存在，则取出已有次数+当前次数后再set进去，遍历完了整体再排序。<br>习题2，显然不是循环嵌套循环，那样时间复杂度不可接受。应该分别独立遍历两个数组，通过hash把相同的字符串扔到同一个bucket, 完了之后统计bucket长度＞1的就行了。","like_count":23,"discussions":[{"author":{"id":1732780,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","nickname":"面向百度编程","note":"","ucode":"8FE04A019D71D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":204593,"discussion_content":"遍历完整体，我想知道你是如何排序的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584194477,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1461687,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLoxyegHarElcAbXdl9FaOMXcOibOOEgWgFMiakL2q7guxcqMqkUQBib1zldFS56hr61Y8zhlO3Rs8Hg/132","nickname":"Geek__f5e47e0e2519","note":"","ucode":"FE1EBAF59233CA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40729,"discussion_content":"第二个回答中，如果数组有重复的字符串就会出bug","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572262590,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1019568,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8e/b0/ef201991.jpg","nickname":"CcczzZ","note":"","ucode":"5F46DA5053D2BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1461687,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLoxyegHarElcAbXdl9FaOMXcOibOOEgWgFMiakL2q7guxcqMqkUQBib1zldFS56hr61Y8zhlO3Rs8Hg/132","nickname":"Geek__f5e47e0e2519","note":"","ucode":"FE1EBAF59233CA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":249749,"discussion_content":"统计第一个数组的时候，重复的字符串只记录一次就行。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1587959094,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":40729,"ip_address":""},"score":249749,"extra":""}]}]},{"had_liked":false,"id":124644,"user_name":"小先生","can_delete":false,"product_type":"c1","uid":1055214,"ip_address":"","ucode":"E5F2052E0323C0","user_header":"https://static001.geekbang.org/account/avatar/00/10/19/ee/e395a35e.jpg","comment_is_top":false,"comment_ctime":1565936181,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"87465282101","product_id":100017301,"comment_content":"在查找的时候，一旦我们通过线性探测方法，找到一个空闲位置，我们就可以认定散列表中不存在这个数据。但是，如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。本来存在的数据，会被认定为不存在。这个问题如何解决呢？<br><br>有好多同学不明白这段话的意思。<br><br>我举个例子看看能不能帮助大家理解。<br><br>比如哈希表中的 0 1 2 三个位置分别存储了 3 个数据，然后我删除了 1 位置上的数据。<br>这时候，我拿着数据 a 来进行查找了，根据散列函数计算出散列值在 0 这个位置。但是我把数据 a 和 0 位置上存储的数据比对后，发现不一致，就会前往下一个位置继续查找。然而 1 位置上已经被删除，按照规则来说，就可以断定哈希表中不能查找到我的数据。<br><br>可如果 2 位置上恰好是我要的数据呢？这样子就会有问题。如果加了 delete 标记就不会出现这个问题啦","like_count":20,"discussions":[{"author":{"id":1509790,"avatar":"https://static001.geekbang.org/account/avatar/00/17/09/9e/24b58986.jpg","nickname":"黑瞳","note":"","ucode":"0A48B19BAE5337","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297184,"discussion_content":"懂了懂了，谢谢老哥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596799439,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1352726,"avatar":"https://static001.geekbang.org/account/avatar/00/14/a4/16/6463e374.jpg","nickname":"jack","note":"","ucode":"5260F7D2219542","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":272219,"discussion_content":"手动点赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590252145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1148142,"avatar":"https://static001.geekbang.org/account/avatar/00/11/84/ee/3a364ccd.jpg","nickname":"滇西之王","note":"","ucode":"B1EBFFAE3AECEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":258300,"discussion_content":"解惑了，ths","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588676071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1256762,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2d/3a/ffa02c6d.jpg","nickname":"HeGuang","note":"","ucode":"2B938BCB4B82FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54957,"discussion_content":"点燃一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574329626,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36119,"user_name":"万里晴空","can_delete":false,"product_type":"c1","uid":1102030,"ip_address":"","ucode":"D189F67E82BAB4","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/ce/42018f4f.jpg","comment_is_top":false,"comment_ctime":1540947217,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"65965456657","product_id":100017301,"comment_content":"可以写代码进行分析讲解不，这样更能感受到","like_count":15},{"had_liked":false,"id":36254,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1540998078,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"57375572926","product_id":100017301,"comment_content":"思考题1：<br>1、先计算出每个URL访问次数<br>    思路最好是使用Java的HashMap&lt;String,Integer&gt;这个结果，key为URL，value为访问次数； 每次put之前先get一把，若不存在value为1，若存在value=value+1。若直接用hash(URL)获取散列值做为数组下标，如若出现哈希冲突，会使得URL的访问次数统计不正确，当然可以使用链表法来解决冲突，也就是Java中HashMap一样解决方法。<br>2、再通过桶排序进行排序（使用访问次数做为桶编号）<br>思考题2：<br>假设两个数组为A和B，快速查找相同字符串的思路如下<br>1）遍历A并将元素存入散列表HA中<br>2）遍历B中每个元素并在散列表HA进行查找，查找得到表示相同元素<br><br>谢谢！","like_count":13},{"had_liked":false,"id":115702,"user_name":"之城","can_delete":false,"product_type":"c1","uid":1252519,"ip_address":"","ucode":"12451253E366A2","user_header":"https://static001.geekbang.org/account/avatar/00/13/1c/a7/6a837523.jpg","comment_is_top":false,"comment_ctime":1563701419,"is_pvip":false,"replies":[{"id":"42290","content":"通过取模的方式，限定在了0~n范围内","user_name":"作者回复","comment_id":115702,"uid":"1190123","ip_address":"","utype":1,"ctime":1563746188,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"44513374379","product_id":100017301,"comment_content":"既然说散列表使用了数组的随机访问的优势，那么它如何保证hash函数计算后的hash值集中地位于内存中的一块连续区域，而不是七零八落散落在内存各处呢？对，我问的就是散列函数是怎么回事。😄","like_count":10,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459240,"discussion_content":"通过取模的方式，限定在了0~n范围内","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563746188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36198,"user_name":"吴彪","can_delete":false,"product_type":"c1","uid":1238385,"ip_address":"","ucode":"04EF499564D438","user_header":"https://static001.geekbang.org/account/avatar/00/12/e5/71/cc94469a.jpg","comment_is_top":false,"comment_ctime":1540973440,"is_pvip":false,"replies":[{"id":"12891","content":"我们还要把散列值转化为数组下标的 单纯散列值是没法直接拿来当下标的","user_name":"作者回复","comment_id":36198,"uid":"1190123","ip_address":"","utype":1,"ctime":1541036508,"user_name_real":"gg"}],"discussion_count":2,"race_medal":0,"score":"44490646400","product_id":100017301,"comment_content":"为什么数组的存储空间有限，也会加大散列冲突的概率呢？hash函数得出来的散列值相同的概率应该是很低的，比如git hash-object，几乎不可能有碰撞，为啥在散列表里碰撞的可能性就这么大","like_count":10,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427778,"discussion_content":"我们还要把散列值转化为数组下标的 单纯散列值是没法直接拿来当下标的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541036508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1238965,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e7/b5/c08b71e1.jpg","nickname":"述为","note":"","ucode":"E62AEC705AEDC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":545528,"discussion_content":"原来是这样。。。我想了好久散列值那么多怎么确定数组下标，难道不是初始化的时候就要确定了数组的大小和下标，原来还要转一次。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641986294,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":427778,"ip_address":""},"score":545528,"extra":""}]}]},{"had_liked":false,"id":55883,"user_name":"HelloBug","can_delete":false,"product_type":"c1","uid":1249598,"ip_address":"","ucode":"E61A4AD5C2F724","user_header":"https://static001.geekbang.org/account/avatar/00/13/11/3e/925aa996.jpg","comment_is_top":false,"comment_ctime":1546338569,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"40201044233","product_id":100017301,"comment_content":"假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？<br>1.访问次数作为key，URL和访问次数作为存储对象，存在散列表中。解决冲突的方法使用链表法，相当于实现了对URL根据访问次数进行了分组。<br>2.将信息存储在散列表中的过程中，构造数组，数组元素是访问次数。在存入散列表的过程中，如果出现散列冲突，就不将该次数放入到数组中。<br>3.使用快速排序对数组进行排序。排序后的数组相当于是排序后的URL，即利用次数可以索引到该访问次数对应的URL。","like_count":9,"discussions":[{"author":{"id":1069407,"avatar":"https://static001.geekbang.org/account/avatar/00/10/51/5f/abb7bfe3.jpg","nickname":"来来baby","note":"","ucode":"59EF2826EA2B28","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6975,"discussion_content":"第一步的访问次数如何得到的呢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567237642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36747,"user_name":"肖小强","can_delete":false,"product_type":"c1","uid":1245065,"ip_address":"","ucode":"A929A8D1DAD3C4","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/89/32e3f682.jpg","comment_is_top":false,"comment_ctime":1541304414,"is_pvip":false,"replies":[{"id":"13091","content":"value并不是hash函数的值。更好的表述应该是声明一个count字段","user_name":"作者回复","comment_id":36747,"uid":"1190123","ip_address":"","utype":1,"ctime":1541383024,"user_name_real":"gg"}],"discussion_count":2,"race_medal":0,"score":"40196010078","product_id":100017301,"comment_content":"老师，关于置顶的那个回答有些疑问。<br>比如第一题的解答说到“url为key，出现次数为value”<br>我的疑问是，hash(key)=VALUE，这个VALUE经过处理后不应该是一个随机的数组的下标吗？然后把出现次数value存入到这个位置中并不断更新。我对上面那句话的理解是hash(url)=value，所以为什么可以把出现次数作为value，value不应该是一个随机值吗？还是这个value本来就不是那个VALUE？","like_count":9,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427997,"discussion_content":"value并不是hash函数的值。更好的表述应该是声明一个count字段","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541383024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1583499,"avatar":"https://static001.geekbang.org/account/avatar/00/18/29/8b/3629c0f8.jpg","nickname":"游山行人","note":"","ucode":"E559BD0A3C6484","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219307,"discussion_content":"hash(key)是计算桶的位置，而value是桶里面存储的内容","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585750369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36572,"user_name":"唐朝农民","can_delete":false,"product_type":"c1","uid":1133947,"ip_address":"","ucode":"6F8F43C6652225","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIaOAxRlZjFkGfRBn420LuAcyWkMrpq5iafGdqthX5icJPjql0ibZOAdafaqbfvw4ZpVzDmsaYglVXDw/132","comment_is_top":false,"comment_ctime":1541154491,"is_pvip":false,"replies":[{"id":"13116","content":"马上就要讲了 别急","user_name":"作者回复","comment_id":36572,"uid":"1190123","ip_address":"","utype":1,"ctime":1541384089,"user_name_real":"gg"}],"discussion_count":1,"race_medal":0,"score":"31605925563","product_id":100017301,"comment_content":"Word 单词验证 是不是用 Trie 树更好，大神讲讲这个数据结构，尤其是编码这块","like_count":7,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427916,"discussion_content":"马上就要讲了 别急","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541384089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135611,"user_name":"Angus","can_delete":false,"product_type":"c1","uid":1377467,"ip_address":"","ucode":"7CC3BA1550FB5B","user_header":"https://static001.geekbang.org/account/avatar/00/15/04/bb/5e5c37c1.jpg","comment_is_top":false,"comment_ctime":1569228063,"is_pvip":false,"replies":[{"id":"52766","content":"因为散列表中槽的个数一般都小于要放入的数据的个数，根据鸽巢原理，总会有冲突的情况。","user_name":"作者回复","comment_id":135611,"uid":"1190123","ip_address":"","utype":1,"ctime":1569710473,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"27339031839","product_id":100017301,"comment_content":"没有理解为什么散列冲突产生的具体原因是什么，所以后面讲到为何空闲位置减少发生散列冲突的几率就增加了，这块有点疑惑。","like_count":6,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468270,"discussion_content":"因为散列表中槽的个数一般都小于要放入的数据的个数，根据鸽巢原理，总会有冲突的情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569710473,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1058015,"avatar":"https://static001.geekbang.org/account/avatar/00/10/24/df/645f8087.jpg","nickname":"Yayu","note":"","ucode":"5E7842458D8229","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":208594,"discussion_content":"对于新人，这个问题和答案，意义重大。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584550417,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122324,"user_name":"Hxd","can_delete":false,"product_type":"c1","uid":1357303,"ip_address":"","ucode":"B8B04AA5738CC9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKg3ia2DDFuGLZRtHw6to43icxKyia1eHbxTUh1CY1dSuTp5WmQN01A1aLAia1lkaR8EAkXD4h76n8Bog/132","comment_is_top":false,"comment_ctime":1565338814,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27335142590","product_id":100017301,"comment_content":"总听到有人说，哈希表就是数组+链表，今天看了课程才觉得这种说法不对。准确的来说，哈希表本身不包含链表，链表只是哈希表解决冲突的一种方式。如果解决哈希冲突的方式是开放定址法，那么就没有链表了。","like_count":6},{"had_liked":false,"id":36261,"user_name":"Ionizing","can_delete":false,"product_type":"c1","uid":1281956,"ip_address":"","ucode":"6AC8DA87E93EE7","user_header":"","comment_is_top":false,"comment_ctime":1541003041,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"27310806817","product_id":100017301,"comment_content":"个人的疑问：<br>1. 关于开放空间的散列冲突：既然存在散列冲突问题，插入时可以通过分配新的 key 来插入存在散列冲突的元素，那么在访问时又是如何解决散列冲突的呢？比如有两个键值对 {key1: val1}, {key2: val2} 它们的 key 在生成时是冲突的，key2 经过重新分配，现在访问 {key2: val2} 时应该如何通过hash函数得到正确的 key2 呢？假如删除 {key1: val1}，现在要访问 {key2: val2} ，那么执行 hash(string) 后得到的 key1 并不存在，应该怎么实现对 {key2: val2} 的正确访问呢？","like_count":6,"discussions":[{"author":{"id":2032840,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/04/c8/3c7af100.jpg","nickname":"Javatar","note":"","ucode":"E216645CDF632C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288319,"discussion_content":"线性探测的删除不是真的删除，只是标记了一下为删除状态。所以线性探测就有很多弊端，维护起来太麻烦。所以工业级的hash数据结构的实现，都是用链表解决哈希碰撞的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593707362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1325309,"avatar":"https://static001.geekbang.org/account/avatar/00/14/38/fd/14b6f0cf.jpg","nickname":"叫我小小诗","note":"","ucode":"535A328D57838B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":251858,"discussion_content":"第一个线性探测不就说了，通过散列函数找到的值不对的时候，就依次往后查找嘛。第二个问题也说了，删除的做标记，查到是空的且有标记，就继续按线性探测查下去。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588122700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":42517,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1542963990,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"23017800470","product_id":100017301,"comment_content":"在查找的时候，一旦我们通过线性探测方法，找到一个空闲位置，我们就可以认定散列表中不存在这个数据。但是，如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。本来存在的数据，会被认定为不存在。这个问题如何解决呢？<br><br>这句话不理解，这不正是删除的效果么。。。设置为空，下次查找的时候当然不在了啊，已经删除了啊。。。","like_count":5,"discussions":[{"author":{"id":1204442,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/da/00189b80.jpg","nickname":"Yan1","note":"","ucode":"286B59FDC55A44","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":80719,"discussion_content":"首先明确一点，散列冲突是不同的key，散列值相同。\n\n这不符合设计要求。要求是不同的key，散列值也要不同。散列值可以简单理解为位置，这个位置记录的数据是key数据(比如编号)或者带有key数据的对象(比如有编号的人)。\n\n举个例子，接力赛跑，班级分别是1班和11班，每个班级都有四个人甲乙丙丁，陆续进入赛道。\n\n假设班级为key，散列函数是取班级数的个位数。那么1班的散列值是1，11班的散列值也是1，不同key，相同散列值，将出现散列冲突，需要解决。\n\n当然冲突不是凭空出现，是在具体的过程中出现。\n首先1班，甲1入场，key为1班，散列值为1，进去第一赛道做接力跑第一号棒。接着1班，乙1入场，key为1班，散列值为1，key值相同，散列值相同，没问题，同班同学，自己人嘛，也进入第一赛道，做接力跑第二号棒。\n\n接着，注意，，，11班的甲11入场，key值为11班，散列值为1，key值不同，散列值相同，散列冲突，第一赛道已经被1班占领，按照线性探测规则，进入第二赛道，则散列冲突解决，新的散列值为2--即第2赛道\n\n注意，，，假设此时，1班甲1和乙1离开赛道去上厕所。赛道上空了。与此同时，11班的乙11也开始入场，key值为11班，散列值为1，首先进入第一赛道，发现第一赛道空无一人，以为没问题。。。。\n\n表面上看没问题，实际上，乙11的正确位置是进入第二赛道，与同班的甲11汇合。那为什么会进入第一赛道呢？之前甲11遇到的散列冲突，乙11为什么没遇到？\n\n实际上，当第一赛道上1班的甲1和乙1离开赛道，不可以真正清空赛道，应该做个删除标记，也标记着，这个赛道被1班先承包了。如果后面有11班的带着相同的散列值过来，告诉他，依旧是散列冲突，继续去找下一个赛道。\n\n这么处理的本质上，依旧是在保证相同key值，得到相同的散列值。这样1班得到的散列值是1，11班得到的散列值1，在解决散列冲突后新的散列值是2。\n\n如果1班，11班入场顺序调换过来可不可以？当然可以。无非是11班进入第一赛道，1班解决散列冲突后得到新的散列值2，进入第二赛道。一样的思路原理。\n\n做删除标记，记录了曾经发生的冲突，以后进场的人，依旧遵循着相同的规则。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1576169701,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1346309,"avatar":"https://static001.geekbang.org/account/avatar/00/14/8b/05/3315b855.jpg","nickname":"Neuject","note":"","ucode":"4DCFF6CDC4186E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5611,"discussion_content":"前提：冲突情况下，数据放到找到的第一个空闲位置\n过程：当在这个填入数据的格子前的某个格子的数据被删除，这个位置数据为空，但是你要找的数据还在这个格子后面的某个位置\n结果：如果被删除的那个数字直接被删掉了，那么当函数计算到空的这个位置时，由于他也有相同的前提，所以会认为下一个冲突的数据会填到这个位置，之前的数据被认为在之前格子里已经填充过了，也就说已经找过了。所以这时候没有找真正的数据就返回了，判定为不存在。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1566376090,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1055214,"avatar":"https://static001.geekbang.org/account/avatar/00/10/19/ee/e395a35e.jpg","nickname":"小先生","note":"","ucode":"E5F2052E0323C0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5085,"discussion_content":"请问有弄明白老师的意思吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565934523,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36480,"user_name":"ALAN","can_delete":false,"product_type":"c1","uid":1240164,"ip_address":"","ucode":"70E3B1C730E63F","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/64/7403c694.jpg","comment_is_top":false,"comment_ctime":1541124710,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"23015961190","product_id":100017301,"comment_content":"老师，有个问题请教下。开放寻址法查询的时候，碰到散列表为空的位置后，就不继续往后找了吗？这样设计不合理吧，因为存储的时候，存数据的散列表的位置是随机的，空的位置后面也许存了数据呢？如果是继续找的话，那为什么删除数据后，要进行特殊标记，这样标记也没意义啊，反正碰到空的位置，还是会继续找，这样标不标记都无所谓啊？","like_count":5,"discussions":[{"author":{"id":1747184,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/a8/f0/529f15e9.jpg","nickname":"第四单元","note":"","ucode":"3ED9D553E1DE17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":91612,"discussion_content":"如果元素存在，那一定在第一个空位置之前呀。因为put时遇到冲突的时候就是放到后面遇到的第一个空位置的。所以查询的时候遇到了空位置，就说明元素不存在了，没有再继续找的必要了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576842146,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1759112,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d7/88/d459fc12.jpg","nickname":"拼命吃草","note":"","ucode":"2A717B61F757A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79031,"discussion_content":"如果继续找的话，那什么时候停止呢？如果是遍历完了所有值再停止，那就不需要这个hash表了，时间复杂度也变成了O(n)。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576048222,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166531,"user_name":"曙光","can_delete":false,"product_type":"c1","uid":1476450,"ip_address":"","ucode":"04D65BF7F19845","user_header":"https://static001.geekbang.org/account/avatar/00/16/87/62/f99b5b05.jpg","comment_is_top":false,"comment_ctime":1577470788,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18757339972","product_id":100017301,"comment_content":"思考题一：<br>1 10W条URL，采用链表法，URL转换为散列值，值是对象，其中包含URL和访问次数；<br>2 每次插入值时，如果冲突会比对URL是否相等，相等访问次数+1，再用max和min和插入值的访问次数比较，共比较20W次找到max和min<br>3 根据最小最大区间值，选择桶排序，计数排序和快排<br><br>思考题二：<br>1 采用链表法，将字符串数组A，每个数组元素，装入散列表；<br>2 拿数组B中的数组元素，依此散列，如果散列表有值，再比较两个字符是否相等<br>","like_count":4},{"had_liked":false,"id":85320,"user_name":"Gavin黄炯鹏","can_delete":false,"product_type":"c1","uid":1347154,"ip_address":"","ucode":"853CDA740D5ABD","user_header":"https://static001.geekbang.org/account/avatar/00/14/8e/52/677d9d1a.jpg","comment_is_top":false,"comment_ctime":1555036378,"is_pvip":false,"replies":[{"id":"31011","content":"比如：你希望在一堆订单order中快速地根据id来查询订单数据，你可以把订单组织成散列表结构。散列表中存储订单的id和指向订单本身的地址。<br><br>你去查询的时候，也是按照id来查询的。只不过在散列表中，会先将id映射成hash值。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1555380576,"ip_address":"","comment_id":85320,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14439938266","product_id":100017301,"comment_content":"开放寻址法查找那里，我希望通过key得到y的值，我都不知道y是多少，只有key，所以与y比较的究竟是什么？","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446627,"discussion_content":"比如：你希望在一堆订单order中快速地根据id来查询订单数据，你可以把订单组织成散列表结构。散列表中存储订单的id和指向订单本身的地址。\n\n你去查询的时候，也是按照id来查询的。只不过在散列表中，会先将id映射成hash值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555380576,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82749,"user_name":"Mr.Xiao","can_delete":false,"product_type":"c1","uid":1247530,"ip_address":"","ucode":"958E0B0DABADE8","user_header":"https://static001.geekbang.org/account/avatar/00/13/09/2a/dc7844f8.jpg","comment_is_top":false,"comment_ctime":1554297031,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14439198919","product_id":100017301,"comment_content":"我也有着相同的问题，只能通过key值来查找一个数据，如果散列冲突了，查找到的数据是否准确？看了评论区老师的解释，疑惑仍然没有消除，我举个例子:<br>我存储两个数据(key1,obj1)和(key2,obj2)，但是通过散列函数得到的散列值相同，也就是散列冲突，这时候我想要获取key2，怎样能够获取到准确的数据(obj2)，这里还有一个前提obj中不包括key的属性，","like_count":3,"discussions":[{"author":{"id":1744888,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/9f/f8/d851a100.jpg","nickname":"世界以痛吻我，我却报之以歌","note":"","ucode":"04B06339A815E9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":274345,"discussion_content":"obj中肯定是要包括key的值的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590571526,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50224,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1544927932,"is_pvip":false,"replies":[{"id":"18573","content":"存的时候走过的路经 跟查的时候是一样的 不会漏掉的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545186193,"ip_address":"","comment_id":50224,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14429829820","product_id":100017301,"comment_content":"老师   二次探测      步长增长的太快了  遍历的时候岂不是会经常的漏掉要查找的元素？","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":432918,"discussion_content":"存的时候走过的路经 跟查的时候是一样的 不会漏掉的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545186193,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2108347,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJNpx0kOlv2XJf9lytPvvEyu6dTQKQ750X5BonHpo4DiaEicz8q3mD6XBIwpEzoSu7JOghpric9e0trg/132","nickname":"Geek_5c55e9","note":"","ucode":"B3746DEB50C56C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301482,"discussion_content":"存的时候和查的时候走过的路径是一样的，查的时候是从这个位置开始一直按照二次探测去探测直到数组走完吗，如果没有查到该key的话","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598535843,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36137,"user_name":"yaya","can_delete":false,"product_type":"c1","uid":1233856,"ip_address":"","ucode":"8C7FAC8F828BA4","user_header":"https://static001.geekbang.org/account/avatar/00/12/d3/c0/d38daa2d.jpg","comment_is_top":false,"comment_ctime":1540952102,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"14425853990","product_id":100017301,"comment_content":"第一题，利用次数作为键值，冲突用链表解决，时间复杂度o(n)<br>第二题，将第一个字符串数组中的字符串，hash到各个区域，然后将第二个数组中的字符串利用同样的hash值处理，冲突遍历对应链表，时间复杂度o(n).","like_count":3,"discussions":[{"author":{"id":2449748,"avatar":"https://static001.geekbang.org/account/avatar/00/25/61/54/5bf767e7.jpg","nickname":"没有心的人","note":"","ucode":"F27D5894087B11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543991,"discussion_content":"给定的数据应该只有URL，没有次数信息。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641374889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1194572,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3a/4c/b6200773.jpg","nickname":"一步","note":"","ucode":"FBFAE23E8E48B7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6126,"discussion_content":"我也这么想的，置顶的答案不知道在说啥。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566717110,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1798068,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/6f/b4/d465acef.jpg","nickname":"啊噗！","note":"","ucode":"C911E772E1E800","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1194572,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3a/4c/b6200773.jpg","nickname":"一步","note":"","ucode":"FBFAE23E8E48B7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":161329,"discussion_content":"第一题 要先遍历一遍统计url出现的次数之后 才能排序 不然你怎么直接用次数作为键值构建散列表 统计一遍 和 排序 要两个时间复制度去计算\n第二题同理 先构建散列表就要一个On 然后再查找一遍On","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580889669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":6126,"ip_address":""},"score":161329,"extra":""}]}]},{"had_liked":false,"id":215532,"user_name":"不二","can_delete":false,"product_type":"c1","uid":1246021,"ip_address":"","ucode":"76CAE080147D3F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIV4RIDWghGYNUtIThk011jWyLyg1vkpiauU8CEczI4unOiasnPcQ6uaFicZUuYTIOl0soVgsE0j4gGA/132","comment_is_top":false,"comment_ctime":1589011883,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10178946475","product_id":100017301,"comment_content":"go实现第一个问题的<br>func main() {<br>\tm := make(map[string]int)<br>\tm[&quot;ming&quot;] = 3<br>\tm[&quot;dong&quot;] = 4<br>\tm[&quot;xiao&quot;] = 5<br>\tm[&quot;hua&quot;] = 1<br>\tm[&quot;da&quot;] = 2<br>\tm[&quot;suosuo&quot;] = 6<br>\tstrs := []string{&quot;ming&quot;, &quot;dong&quot;, &quot;xiao&quot;, &quot;hua&quot;, &quot;da&quot;,&quot;suosuo&quot;}<br>\tquickSort(strs, 0, len(strs)-1, m)<br>}<br><br>func quickSort(strs []string, start, end int, m map[string]int) {<br>\tif start &lt; end {<br>\t\ti, j := start, end<br>\t\tkey := m[strs[(start+end)&gt;&gt;1]]<br>\t\tfor i &lt;= j {<br>\t\t\tfor m[strs[i]] &lt; key {<br>\t\t\t\ti ++<br>\t\t\t}<br>\t\t\tfor m[strs[j]] &gt; key {<br>\t\t\t\tj --<br>\t\t\t}<br>\t\t\tif i &lt;= j {<br>\t\t\t\tstrs[i], strs[j] = strs[j], strs[i]<br>\t\t\t\ti++<br>\t\t\t\tj--<br>\t\t\t}<br>\t\t}<br>\t\tif start &lt; j {<br>\t\t\tquickSort(strs, start, j, m)<br>\t\t}<br><br>\t\tif i &lt; end {<br>\t\t\tquickSort(strs, i, end, m)<br>\t\t}<br>\t}<br>}","like_count":2,"discussions":[{"author":{"id":1921336,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/51/38/d445b92b.jpg","nickname":"南松十三","note":"","ucode":"3AB945E1666312","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":265592,"discussion_content":"厉害👍 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589419378,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":102717,"user_name":"ILoveKindness","can_delete":false,"product_type":"c1","uid":1559444,"ip_address":"","ucode":"A6210B034AAC62","user_header":"https://static001.geekbang.org/account/avatar/00/17/cb/94/eedbace3.jpg","comment_is_top":false,"comment_ctime":1560299328,"is_pvip":false,"replies":[{"id":"37277","content":"你说的是思考题吗？把散列表中的数据输出到数组，再排序的。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1560382386,"ip_address":"","comment_id":102717,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10150233920","product_id":100017301,"comment_content":"老师您好，我不是很理解如何对散列表进行排序，如果散列表中的顺序发生改变，不就无法根据key找到相应的数据了嘛，请求老师解答","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453544,"discussion_content":"你说的是思考题吗？把散列表中的数据输出到数组，再排序的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560382386,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":42540,"user_name":"进阶的码农","can_delete":false,"product_type":"c1","uid":1017821,"ip_address":"","ucode":"D8991282640334","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/dd/4f53f95d.jpg","comment_is_top":false,"comment_ctime":1542967734,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10132902326","product_id":100017301,"comment_content":"置顶的回答，我感觉时间复杂度O(n)是不是不对，请作者解答下 ,10万url数据插入确实是O(n),但是不只是插入啊，还需要查询key如果存在 value++，插入是O(1)没毛病但是每次查询都是O(K)啊，希望争哥把每次留的思考题抽时间找个文章给下答案","like_count":2,"discussions":[{"author":{"id":1397631,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKVUskibDnhMt5MCIJ8227HWkeg2wEEyewps8GuWhWaY5fy7Ya56bu2ktMlxdla3K29Wqia9efCkWaQ/132","nickname":"衬衫的价格是19美元","note":"","ucode":"655F925451F772","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310647,"discussion_content":"文中说了， k=n/m，其中 n 表示散列中数据的个数，m 表示散列表中“槽”的个数，对于10万条数据来说，完全可以申请10万个槽，使得理论k=1, 实际使用中，数据量不大时，只要你申请的空间够大，冲突的概率是很低的，也就是k是很接近于1的值，完全可以忽略","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601969263,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37982,"user_name":"樱桃子77","can_delete":false,"product_type":"c1","uid":1260146,"ip_address":"","ucode":"676894101A6652","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJicwphCoQ0S1DaibWNarUJq3DrGOeADY02AreVbKCLkm0PWJmZR0f1rMrrXDRzOwLCmIQbqeibQ4uHQ/132","comment_is_top":false,"comment_ctime":1541839630,"is_pvip":false,"replies":[{"id":"13716","content":"散列表存对象 对象包含url和访问次数。url为key 访问次数是一个附属数据字段","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541987366,"ip_address":"","comment_id":37982,"utype":1}],"discussion_count":1,"race_medal":2,"score":"10131774222","product_id":100017301,"comment_content":"请教第一个问题：如果用访问次数为key， URＬ为value 并记下最大访问次数K 然后遍历哈希表就行了。这样行吗？","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428545,"discussion_content":"散列表存对象 对象包含url和访问次数。url为key 访问次数是一个附属数据字段","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541987366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37344,"user_name":"马小平","can_delete":false,"product_type":"c1","uid":1139457,"ip_address":"","ucode":"31B6F88F04B918","user_header":"https://static001.geekbang.org/account/avatar/00/11/63/01/cc4d66ea.jpg","comment_is_top":false,"comment_ctime":1541553416,"is_pvip":true,"replies":[{"id":"13455","content":"散列表中存储的每个数据单元包含两部分 key和卫星数据 也就是一个对象中的其他字段。<br><br>你的问题我没太看懂 你能举个例子吗","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541642035,"ip_address":"","comment_id":37344,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10131488008","product_id":100017301,"comment_content":"请教老师，当我在查找元素时候，在相同散列值的链表中遍历如何区分哪个是我要找的元素？毕竟查找时查询条件只包含KEY的信息吧<br><br>这个问题我看您回答过了今天，但是我还是没懂怎么对比Key ","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428299,"discussion_content":"散列表中存储的每个数据单元包含两部分 key和卫星数据 也就是一个对象中的其他字段。\n\n你的问题我没太看懂 你能举个例子吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541642035,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1729853,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/65/3d/afc2e163.jpg","nickname":"西谷","note":"","ucode":"0378211B2359E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70269,"discussion_content":"比如说运动会赛跑的例子，原来的参赛号是key，截取后的参赛号就是hash(key)，是数组下标。而一些其他的数据比如说参赛成绩、运动员姓名是作为卫星数据存储在散列表中的。\n那我们如果要查询运动员成绩的话怎么查？是通过key计算得到散列值，然后拿散列值找到数组下标（key也要保证相同），来获取到数组中所存储的对，其中包含成绩，是这样吗？\n而且这样的话其实数组下标哈希值其实并不是我们所需要的值，而我们平常根据key所需要查的value不是称为哈希值的嘛。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575340238,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":242013,"user_name":"犀利鬼","can_delete":false,"product_type":"c1","uid":1600746,"ip_address":"","ucode":"E02388EC88D4ED","user_header":"https://static001.geekbang.org/account/avatar/00/18/6c/ea/65cfa066.jpg","comment_is_top":false,"comment_ctime":1597561363,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5892528659","product_id":100017301,"comment_content":"看了下排在第一的评论里面关于第一个问题的解法，感觉桶排序的意义不大，因为区间出来之后，数组下标对应的url自然就是该url的顺序，除非你想根据url的长短或者大小再去排一次序，第一个问题自己也写了一个，空间复杂度有点高O(N)，时间复杂度是O(N)。<br>    public class UrlSort<br>    {<br>        Dictionary&lt;string, int&gt; dictionary = new Dictionary&lt;string, int&gt;();<br><br>        int MAX_LENGTH = 100000;<br><br>        public UrlArray[] Sort(string[] urls)<br>        {<br>            for (int i = 0; i &lt; urls.Length; i++)<br>            {<br>                if (dictionary.ContainsKey(urls[i]))<br>                {<br>                    dictionary[urls[i]]++;<br>                }<br>                else<br>                {<br>                    dictionary.TryAdd(urls[i], 1);<br>                }<br>            }<br>            return SortUrl(dictionary);<br>        }<br>        private UrlArray[] SortUrl(Dictionary&lt;string, int&gt; dic)<br>        {<br>            UrlArray[] arrays = new UrlArray[MAX_LENGTH];<br>            int count = 0;<br>            int index = 0;<br><br>            &#47;&#47;将value值 直接当成数组下标 进行插入<br>            foreach (var item in dic)<br>            {<br>                if (arrays[item.Value] == null)<br>                {<br>                    arrays[item.Value] = new UrlArray();<br>                    count++;<br>                }<br>                arrays[item.Value].Urls.Add(item.Key,item.Value);<br>            }<br><br>            UrlArray[] sortUrl = new UrlArray[count];<br>            &#47;&#47;初始化数组<br>            for (int i = 0; i &lt; sortUrl.Length; i++)<br>            {<br>                sortUrl[i] = new UrlArray();<br>            }<br><br>            foreach (var item in arrays)<br>            {<br>                if (item != null)<br>                {<br>                    sortUrl[index].Urls = item.Urls;<br>                    index++;<br>                }<br>            }<br>            return sortUrl;<br>        }<br>    }<br><br>    public class UrlArray<br>    {<br>        public Dictionary&lt;string, int&gt; Urls = new Dictionary&lt;string, int&gt;();<br>    }","like_count":1},{"had_liked":false,"id":222458,"user_name":"TheStarBoys","can_delete":false,"product_type":"c1","uid":2009311,"ip_address":"","ucode":"9A6D70482F9212","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/SiciaNKibn60SjA50TsTEtO09DoRA57UozylHmKckZXkJmNiaShSC0BIP6TdZC6cAphuEzmuxMHWwvpYN8P7kKb8eA/132","comment_is_top":false,"comment_ctime":1590810592,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5885777888","product_id":100017301,"comment_content":"直接附上Go代码，求指正。<br><br>&#47;&#47; 时间复杂度：O(N+K+NlogN)，N为logs长度，K为哈希表大小，K取决于logs中不同url的个数<br>&#47;&#47; 空间复杂度：O(2K) -&gt; O(K)<br>&#47;&#47; 排序后为访问次数的降序，即访问次数高的在左侧<br>func sortUrlAccessData(logs []string) []string {<br>\t&#47;&#47; 根据日志，通过哈希表获取访问次数<br>\t&#47;&#47; 时间复杂度：O(N)<br>\t&#47;&#47; 空间复杂度：O(K)<br>\ttable := make(map[string]int)<br>\tfor _, url := range logs {<br>\t\ttable[url]++<br>\t}<br><br>\t&#47;&#47; 将哈希表中的数据取出保存到数组中<br>\t&#47;&#47; 时间复杂度：O(K)<br>\t&#47;&#47; 空间复杂度：O(K)<br>\tstrs := []string{}<br>\tfor url := range table {<br>\t\tstrs = append(strs, url)<br>\t}<br><br>\t&#47;&#47; 根据哈希表中的访问次数，对数组排序<br>\t&#47;&#47; 底层是快排<br>\t&#47;&#47; 时间复杂度：O(NlogN)<br>\t&#47;&#47; 空间复杂度：O(1)<br>\tsort.Slice(strs, func(i, j int) bool {<br>\t\tif table[strs[i]] &gt; table[strs[j]] {<br>\t\t\treturn true<br>\t\t}<br>\t\treturn false<br>\t})<br><br>\treturn strs<br>}<br><br>&#47;&#47; 找到两个数组中相同的字符串<br>&#47;&#47; 考虑同一个数组中可能自己就有重复的字符串，所以需要分别维护一个散列表<br>&#47;&#47; 由于两个字符串数组大小几乎相等，可以同时进行遍历，优化时间复杂度<br>&#47;&#47; 时间复杂度：O(max(N, M)) 其中 N 是 strs1 的长度，M 是 strs2 的长度<br>&#47;&#47; 空间复杂度：O(N + M + K) 其中 K 是相同字符串个数<br>func findSameString(strs1, strs2 []string) []string {<br>\tvar res []string<br><br>\ttable1, table2 := make(map[string]bool), make(map[string]bool)<br>\tfor i, j := 0, 0; i &lt; len(strs1) || j &lt; len(strs2); i, j = i+1, j+1 {<br>\t\tif i &lt; len(strs1) {<br>\t\t\tif !table1[strs1[i]] {<br>\t\t\t\ttable1[strs1[i]] = true<br>\t\t\t\tif table1[strs1[i]] == table2[strs1[i]] {<br>\t\t\t\t\tres = append(res, strs1[i])<br>\t\t\t\t}<br>\t\t\t}<br>\t\t}<br>\t\tif j &lt; len(strs2) {<br>\t\t\tif !table2[strs2[j]] {<br>\t\t\t\ttable2[strs2[j]] = true<br>\t\t\t\tif table1[strs2[j]] == table2[strs2[j]] {<br>\t\t\t\t\tres = append(res, strs2[j])<br>\t\t\t\t}<br>\t\t\t}<br>\t\t}<br>\t}<br><br>\treturn res<br>}","like_count":1},{"had_liked":false,"id":211552,"user_name":"isobelar","can_delete":false,"product_type":"c1","uid":1318394,"ip_address":"","ucode":"58CE4061984B43","user_header":"https://static001.geekbang.org/account/avatar/00/14/1d/fa/b81c89c3.jpg","comment_is_top":false,"comment_ctime":1587981958,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5882949254","product_id":100017301,"comment_content":"下面是我自己的一些课后思考题的解决方案，欢迎你指正！<br>1.Word文档中单词拼写检查功能：<br>我觉得这里Trie比HashMap更好，因为时间空间复杂度都更高。<br>2.假设我们有10万条URL访问日志，如何按照访问次数给URL排序？<br>通过散列表的KEY统计url访问次数，VALUE表示具有相同访问次数的url数组。按照排序后的KEY输出对应数组中的url地址值。<br>3.有两个字符串数组，每个数组大约有10万条字符串，如何快速找出两个数组中相同的字符串？<br>分别将2个数组的字符串通过散列函数映射到散列表，散列表中的元素值为次数。最后，分别比较两个散列表中KEY相同的最小元素值之和得到相同的字符串个数。","like_count":1,"discussions":[{"author":{"id":1318394,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1d/fa/b81c89c3.jpg","nickname":"isobelar","note":"","ucode":"58CE4061984B43","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":250940,"discussion_content":"第一条笔误写错了，应该是Trie的时间空间复杂度都更低。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588051682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":201056,"user_name":"蜗牛","can_delete":false,"product_type":"c1","uid":1086220,"ip_address":"","ucode":"01CC18F12E556D","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/0c/0a6a0d5e.jpg","comment_is_top":false,"comment_ctime":1585710158,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880677454","product_id":100017301,"comment_content":"<br>1. 用散列表，key为url，value为访问次数，然后再排序<br>2. 思想同第1题，遍历A数组，放入hash中，然后遍历B数据，如果再hash中没有找到数据则不相同","like_count":1},{"had_liked":false,"id":196384,"user_name":"zapup","can_delete":false,"product_type":"c1","uid":1397351,"ip_address":"","ucode":"388D6BB5D7B137","user_header":"https://static001.geekbang.org/account/avatar/00/15/52/67/fcba0967.jpg","comment_is_top":false,"comment_ctime":1585277554,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880244850","product_id":100017301,"comment_content":"10万URL访问日志，根据访问次数排序<br>1. 扫描日志，散列表 urlFreqMap (url, freq)<br>2. 扫描散列表 urlFreqMap ，再构建散列表 freqUrlsMap (freq, List&lt;String&gt;) (List 保持原URL顺序)<br>3. 根据散列表 freqUrlsMap 的 key 构建频次数组 int[] arr<br>4. 对频次数组 arr 排序<br>5. 结合排序结果与 freqUrlsMap 输出结果","like_count":1},{"had_liked":false,"id":175154,"user_name":"发霉的宅大人","can_delete":false,"product_type":"c1","uid":1738243,"ip_address":"","ucode":"6757E30FE5E48D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/03/95004954.jpg","comment_is_top":false,"comment_ctime":1580573925,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5875541221","product_id":100017301,"comment_content":"如果出现了散列冲突，我再次查找的时候如何确定第一个找到的不是我想要找的那个呢？","like_count":1},{"had_liked":false,"id":161308,"user_name":"Jun","can_delete":false,"product_type":"c1","uid":1120678,"ip_address":"","ucode":"0FAB76D99153ED","user_header":"https://static001.geekbang.org/account/avatar/00/11/19/a6/7ae63d7e.jpg","comment_is_top":false,"comment_ctime":1576172962,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5871140258","product_id":100017301,"comment_content":"为什么word不用字典树？对于英文单词着呢量级，散列表可以支持了，而且比字典树简单？","like_count":1},{"had_liked":false,"id":160155,"user_name":"逍遥思","can_delete":false,"product_type":"c1","uid":1015512,"ip_address":"","ucode":"340F05C786730F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/d8/92a98fb6.jpg","comment_is_top":false,"comment_ctime":1575881803,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5870849099","product_id":100017301,"comment_content":"1. 使用字典（一个完善了的散列表），遍历日志，每遇到一条URL就查找是否在字典里，如果在，就把count加1，如果不在，就放到字典里，并将count置1，最后按照count值对URL进行排序<br>2. 先遍历一遍第一个数组，得到一个字典，然后遍历第二个数组，如果元素在字典里，就做个标记，结束之后筛选出字典里所有有标记的元素，即对应相同的字符串","like_count":1},{"had_liked":false,"id":158158,"user_name":"西谷","can_delete":false,"product_type":"c1","uid":1729853,"ip_address":"","ucode":"0378211B2359E7","user_header":"https://static001.geekbang.org/account/avatar/00/1a/65/3d/afc2e163.jpg","comment_is_top":false,"comment_ctime":1575340200,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5870307496","product_id":100017301,"comment_content":"比如说运动会赛跑的例子，原来的参赛号是key，截取后的参赛号就是hash(key)，是数组下标。而一些其他的数据比如说参赛成绩、运动员姓名是作为卫星数据存储在散列表中的。<br>那我们如果要查询运动员成绩的话怎么查？是通过key计算得到散列值，然后拿散列值找到数组下标（key也要保证相同），来获取到数组中所存储的对，其中包含成绩，是这样吗？<br>而且这样的话其实数组下标哈希值其实并不是我们所需要的值，而我们平常根据key所需要查的value不是称为哈希值的嘛。","like_count":1,"discussions":[{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295380,"discussion_content":"不是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596180241,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141671,"user_name":"小喵喵","can_delete":false,"product_type":"c1","uid":1062444,"ip_address":"","ucode":"FDBBB2A59DB8B6","user_header":"https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg","comment_is_top":false,"comment_ctime":1571209815,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5866177111","product_id":100017301,"comment_content":"老师，我有两个疑问：<br>1.当多个散列函数时，比如fun1,fun2,fun3，插入的时候先根据fun1来计算hash值，如果冲突就根据fun2来计算，以此类推，直到有计算得到空闲位置为止。这个是插入过程。如果查找是不是不准呢？<br>比如查找一个数是根据fun1就能计算得到。但是这个查找的值是根据fun3来插入的。<br>2.是不是链表法比开发寻址法高效，使用频率远远高于开发寻址法呢？<br><br>","like_count":1},{"had_liked":false,"id":116970,"user_name":"linus","can_delete":false,"product_type":"c1","uid":1246600,"ip_address":"","ucode":"910606671D1706","user_header":"https://static001.geekbang.org/account/avatar/00/13/05/88/0a1f1b1d.jpg","comment_is_top":false,"comment_ctime":1563948841,"is_pvip":false,"replies":[{"id":"42896","content":"用到。只是标记这个地方是原来存了数据，但是被删除了。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1564009615,"ip_address":"","comment_id":116970,"utype":1}],"discussion_count":5,"race_medal":0,"score":"5858916137","product_id":100017301,"comment_content":"能详细讲解下为什么要有deleted标识吗？删都删了，加个deleted标识，这个坑以后就不用了吗？文中的表述方式实在没看懂","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459758,"discussion_content":"用到。只是标记这个地方是原来存了数据，但是被删除了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564009615,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1058015,"avatar":"https://static001.geekbang.org/account/avatar/00/10/24/df/645f8087.jpg","nickname":"Yayu","note":"","ucode":"5E7842458D8229","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":208598,"discussion_content":"标识值『delete』只是为了解决线性探测模式下『查询』的问题，而你提到的“这个字段难道不用了吗？”我的理解，如果你『插入』完全可以插入到『delete』位置，不影响复用，不会浪费空间。但确实麻烦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584550737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1127115,"avatar":"https://static001.geekbang.org/account/avatar/00/11/32/cb/cece03fc.jpg","nickname":"GeekYa","note":"","ucode":"4B30219E8E7A97","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46032,"discussion_content":"结合文中示意图可以更好的理解- -!","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573113206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1127115,"avatar":"https://static001.geekbang.org/account/avatar/00/11/32/cb/cece03fc.jpg","nickname":"GeekYa","note":"","ucode":"4B30219E8E7A97","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46030,"discussion_content":"老师的描述有点不够清晰……这里对老师的描述进行补充，看看是否能理解：在查找的时候，一旦我们通过线性探测方法，找到一个空闲位置，我们就可以认定散列表中不存在这个数据，如果单纯地把要删除的元素设置为空，如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。本来存在(这个空闲位置后面)的数据，会(因为这个空闲位置,阻断了往后找数据的操作,所以要找的数据)被认定为不存在。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573113016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1127115,"avatar":"https://static001.geekbang.org/account/avatar/00/11/32/cb/cece03fc.jpg","nickname":"GeekYa","note":"","ucode":"4B30219E8E7A97","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295381,"discussion_content":"你这个解释是我目前看来最清晰没有歧义的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596180387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":46030,"ip_address":""},"score":295381,"extra":""}]}]},{"had_liked":false,"id":111720,"user_name":"Dong","can_delete":false,"product_type":"c1","uid":1228202,"ip_address":"","ucode":"B467D06C2CD7E5","user_header":"https://static001.geekbang.org/account/avatar/00/12/bd/aa/f53a6800.jpg","comment_is_top":false,"comment_ctime":1562589933,"is_pvip":false,"replies":[{"id":"40675","content":"具体的计算过程是这样子的：<br>先通过hash函数，计算得到hash值，这个值对应槽的下标，槽上有拉链表，再通过链表顺序查找要找的元素。<br><br>这几个过程都可以看做常量时间复杂度（如果链表长度很短的情况下，查找元素的时间复杂度可以粗略的记录做O(1)。）","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1562631623,"ip_address":"","comment_id":111720,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5857557229","product_id":100017301,"comment_content":"采用链地址法的哈希表的平均时间复杂度是O(1)吗？如果是，那是怎么算的呀。","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457425,"discussion_content":"具体的计算过程是这样子的：\n先通过hash函数，计算得到hash值，这个值对应槽的下标，槽上有拉链表，再通过链表顺序查找要找的元素。\n\n这几个过程都可以看做常量时间复杂度（如果链表长度很短的情况下，查找元素的时间复杂度可以粗略的记录做O(1)。）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562631623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":88577,"user_name":"right-chen","can_delete":false,"product_type":"c1","uid":1435172,"ip_address":"","ucode":"E0E940E80E7A2D","user_header":"https://static001.geekbang.org/account/avatar/00/15/e6/24/30806a88.jpg","comment_is_top":false,"comment_ctime":1555945885,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5850913181","product_id":100017301,"comment_content":"思考一：遍历10w个url地址，通过哈希函数对每一个url生成一个哈希值，并保存在一个数组中，如果已经存在则url记录+1，之前不存在则设置为1。这样生成了一个数组，记录着url和访问次数。再通过桶排序，计算出访问次数的url顺序。","like_count":1},{"had_liked":false,"id":82454,"user_name":"pefami","can_delete":false,"product_type":"c1","uid":1472644,"ip_address":"","ucode":"684153BB8BA7E0","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/FiaxAZEdIq4SJNBSYXWeo4sKVTDSdFY81xvLtrzldzcFuaZenzD0lVuVHQWBwfp9kQPMaaAz3k1UkDqCyb8tqgg/132","comment_is_top":false,"comment_ctime":1554216533,"is_pvip":false,"replies":[{"id":"30236","content":"是的 要保存key","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1554680023,"ip_address":"","comment_id":82454,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5849183829","product_id":100017301,"comment_content":"“我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素是否相等，若相等，则说明就是我们要查找的元素”<br>你好，这里是怎么去判断两个元素是相等的呢，查找一般我们是通过Key去找值，如果Key1!=Key2,而Hash(Key1)=Hash(Key2),是不是需要在散列值的位置同时保存Key和Value呢，不能只存储Value值<br>","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445597,"discussion_content":"是的 要保存key","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554680023,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78795,"user_name":"悦仙子的小跟班","can_delete":false,"product_type":"c1","uid":1240892,"ip_address":"","ucode":"844FA62A596157","user_header":"https://static001.geekbang.org/account/avatar/00/12/ef/3c/83859355.jpg","comment_is_top":false,"comment_ctime":1553241557,"is_pvip":false,"replies":[{"id":"28969","content":"对比一下散列前的要查找的数据 跟 散列表中存储的数据","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1553477676,"ip_address":"","comment_id":78795,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5848208853","product_id":100017301,"comment_content":"有个地方有个疑问，原文描述是：我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素是否相等，若相等，则说明就是我们要查找的元素；否则，就顺序往后依次查找。如果遍历到数组的空闲位置还未找到，就说明要查找的元素并没有在散列表中。<br>其中 比较数组中下标为散列值的元素和要查找的元素是否相等，这个是怎么做到的呢？我不就是要找这个值吗？我怎么会知道这个值的呢？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444231,"discussion_content":"对比一下散列前的要查找的数据 跟 散列表中存储的数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553477676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1299437,"avatar":"https://static001.geekbang.org/account/avatar/00/13/d3/ed/8d5420ad.jpg","nickname":"LSJ","note":"","ucode":"3CF8A457AC6BA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1192,"discussion_content":"老师 您说的散列前要查找的数据 是key本身吗 然后散列表中除了保存value还要保存key","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562386633,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":66081,"user_name":"晓杉","can_delete":false,"product_type":"c1","uid":1209336,"ip_address":"","ucode":"19E634BB61A165","user_header":"https://static001.geekbang.org/account/avatar/00/12/73/f8/dbd2fa50.jpg","comment_is_top":false,"comment_ctime":1549872929,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5844840225","product_id":100017301,"comment_content":"老师，按我的理解，对于开放寻址法实现的散列表，其不论是用什么方式来解决散列冲突，删除的时候都需要标记delete，而不是直接置空，以便程序继续往下查找。<br>因为查找keyn是依赖于前边与hash(keyn)相同的hash值key的，因此不能将key所对应的位置直接置空，否则会误认为不存在改hash(keyn)","like_count":1},{"had_liked":false,"id":54726,"user_name":"左瞳","can_delete":false,"product_type":"c1","uid":1206589,"ip_address":"","ucode":"B262A3E99C8605","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/3d/3cfb9b87.jpg","comment_is_top":false,"comment_ctime":1545957483,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5840924779","product_id":100017301,"comment_content":"是否置顶的答案就是最佳答案了，我平常代码都是这样来实现的，我还想看看有没有更快的实现方式","like_count":1},{"had_liked":false,"id":54660,"user_name":"陈光","can_delete":false,"product_type":"c1","uid":1007685,"ip_address":"","ucode":"48FD5FBD0F6319","user_header":"https://static001.geekbang.org/account/avatar/00/0f/60/45/c6302327.jpg","comment_is_top":false,"comment_ctime":1545925085,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5840892381","product_id":100017301,"comment_content":"老师你好，看了置顶留言后有个疑问。第一个问题为什么要先存入散列表再进行排序？如果只是为了获取最大访问次数然后决定排序方法，可以只是单纯进行遍历，然后直接排序就可以了啊，为什么要先存入散列表再进行排序？","like_count":1,"discussions":[{"author":{"id":1095136,"avatar":"https://static001.geekbang.org/account/avatar/00/10/b5/e0/fc3ac264.jpg","nickname":"stronger.","note":"","ucode":"AD0F2BE338824C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388530,"discussion_content":"遍历的时候，你怎么知道当前 url 之前是否出现过呢，也就是怎么进行计数呢？所以需要 hash 来进行存储，O(1)的时间复杂度就可以知道当前url是否出现过，并且出现过几次然后+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628823538,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50883,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1545060403,"is_pvip":false,"replies":[{"id":"18325","content":"不 标记为deleted之后就空出来了 新数据可以覆盖它","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545097387,"ip_address":"","comment_id":50883,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5840027699","product_id":100017301,"comment_content":"老师您好，有个问题，就是关于散列冲突里面，讲到删除元素，则标记为deleted，那么这个删除的空间是否一直没空出来？这样不就导致，整个数组的本来要删除的数据，没有真正让出空间，导致有效数据很小，垃圾数据很多，这样怎么解决？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433157,"discussion_content":"不 标记为deleted之后就空出来了 新数据可以覆盖它","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545097387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37147,"user_name":"卡卡","can_delete":false,"product_type":"c1","uid":1064855,"ip_address":"","ucode":"E696CC0386FA27","user_header":"https://static001.geekbang.org/account/avatar/00/10/3f/97/8d7a6460.jpg","comment_is_top":false,"comment_ctime":1541468146,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5836435442","product_id":100017301,"comment_content":"线性探测，是当发现key的散列数据出现冲突时，就用下一个空闲位置，这样是不是就会把其他数据对应的散列值下标的位置给占用了，导致当需要查找其他数据，就会出现找到错误的数据。如果这种冲突越来越多，整个数组就会不可用了？","like_count":1},{"had_liked":false,"id":36148,"user_name":"上善若水（德水）","can_delete":false,"product_type":"c1","uid":1069694,"ip_address":"","ucode":"05ED2C7D2BB125","user_header":"https://static001.geekbang.org/account/avatar/00/10/52/7e/b5b59ae4.jpg","comment_is_top":false,"comment_ctime":1540955458,"is_pvip":true,"replies":[{"id":"12895","content":"后面会讲trie树 支持auto suggestion<br><br>还会再比较一下的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541037085,"ip_address":"","comment_id":36148,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5835922754","product_id":100017301,"comment_content":"word估计不太会用这种存储来检查，因为他还要给建议autosuggestion?<br><br>散列冲突后，这种存储后，查找的时候如何知道要查找的位置就一定是我要找的那个？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427762,"discussion_content":"后面会讲trie树 支持auto suggestion\n\n还会再比较一下的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541037085,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36121,"user_name":"拉欧","can_delete":false,"product_type":"c1","uid":1206605,"ip_address":"","ucode":"40996A8093A95F","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/4d/81c44f45.jpg","comment_is_top":false,"comment_ctime":1540947644,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5835914940","product_id":100017301,"comment_content":"第二条很简单，把其中一个数组做成key为字符串的hashtable，然后第二个数组循环遍历就OK了；第一个问题，key为访问次数，value为URL，相同key的URL做成链表","like_count":1},{"had_liked":false,"id":358871,"user_name":"111","can_delete":false,"product_type":"c1","uid":3109487,"ip_address":"北京","ucode":"D6E8E83A118A3E","user_header":"https://static001.geekbang.org/account/avatar/00/2f/72/6f/44c10658.jpg","comment_is_top":false,"comment_ctime":1664955163,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664955163","product_id":100017301,"comment_content":"总结：<br>1. 散列表是通过hash函数将k值转换成数组下标需要：转换完为非负整数。。。<br>2. hash碰撞可以用开放寻址和链表法进行处理<br><br>1. 通过key-value对url进行计数<br>2. 先遍历第一组url储存入散列表，第二组遍历时如果对应下标有内容，就表示是有重复","like_count":0},{"had_liked":false,"id":358213,"user_name":"Geek_sz","can_delete":false,"product_type":"c1","uid":2449060,"ip_address":"广东","ucode":"72E86D7D6554CF","user_header":"https://static001.geekbang.org/account/avatar/00/25/5e/a4/d48b8298.jpg","comment_is_top":false,"comment_ctime":1664072281,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664072281","product_id":100017301,"comment_content":"记流水账的评论放出来干你妈？","like_count":0},{"had_liked":false,"id":357216,"user_name":"Geek_009666","can_delete":false,"product_type":"c1","uid":2955648,"ip_address":"福建","ucode":"86DD98FE808E0A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJQ8AP2ZQCmzKSwhhDvlWa2d37V1KQ5Qib89uNJkYhRddI2YENUhJpuGPwl4oht7KD52plkgLo8QdQ/132","comment_is_top":false,"comment_ctime":1663071323,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663071323","product_id":100017301,"comment_content":"老师好，英文单词有 20 万个单词这个例子，具体采用哪个HASH函数，字符串hash？","like_count":0},{"had_liked":false,"id":355774,"user_name":"蒋慕平","can_delete":false,"product_type":"c1","uid":2302901,"ip_address":"重庆","ucode":"57B8FF7F00C042","user_header":"https://static001.geekbang.org/account/avatar/00/23/23/b5/639a12ec.jpg","comment_is_top":false,"comment_ctime":1661742495,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661742495","product_id":100017301,"comment_content":"hash table<br>1. 是数组的扩展<br>2. 散列函数<br>- 散列函数计算得到的散列值是一个非负整数。数组下标<br>- 如果key1 = key2 ,那hash(key1) == hash(key2)<br>- 如果key1 !=key2,那么hash(key1) != hash(key2),<br>完美这条规则才能出现。一般都有hash值相同的问题，hash冲突<br>3. hash冲突<br>- 开放寻址法-线性方式(ThreadLocal,采用开放寻址法。1.循环寻址 2.又不能删除操作，只能覆盖，不然影响hash冲突时后续寻址)<br>- 二次探测 hash(key)+0 ,hash(key) + 12<br>- 双重散列,多个散列函数<br>- 空闲不多，hash冲突概率会大大提高。装载因子=填入表的个数&#47;列表的长度<br>链表法-慢-红黑树","like_count":0},{"had_liked":false,"id":353584,"user_name":"Allan","can_delete":false,"product_type":"c1","uid":1310388,"ip_address":"北京","ucode":"8DA4DBECC2C45C","user_header":"https://static001.geekbang.org/account/avatar/00/13/fe/b4/295338e7.jpg","comment_is_top":false,"comment_ctime":1659582362,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1659582362","product_id":100017301,"comment_content":"课后题：<br>1、 思路：key=url，value=count，通过统计count大小进行排序<br>2、思路：hash思想，字符串作为key进行hash存储，先对第一个字符串数组进行for遍历，然后初始化key的value都为0，然后对第二个字符串数组for遍历，如果遇到相同的key则进行0+1=1，最后value等于1的则说明是两个字符串都有。<br><br>不考虑排序部分时间复杂度O(n)。","like_count":0},{"had_liked":false,"id":347057,"user_name":"我爱夜来香","can_delete":false,"product_type":"c1","uid":2609930,"ip_address":"","ucode":"10761E677EF05F","user_header":"https://static001.geekbang.org/account/avatar/00/27/d3/0a/92640aae.jpg","comment_is_top":false,"comment_ctime":1653648748,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653648748","product_id":100017301,"comment_content":"老师,有个问题不解,hash(key1) = hash(key2),这个算哈希冲突;那假如hash(key)没有相同的,但是数组长度有限,取模后会有hash(key)不同的放到数组的同一个位置,这个也算哈希冲突吗?","like_count":0},{"had_liked":false,"id":345378,"user_name":"知行","can_delete":false,"product_type":"c1","uid":1802022,"ip_address":"","ucode":"5AC8CBCC0AD48B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/7f/26/c5127e9a.jpg","comment_is_top":false,"comment_ctime":1652241113,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1652241113","product_id":100017301,"comment_content":"1、第一题<br>1）使用散列表存储url，key是url，hash(key) 相同的放入同一个槽位，使用链表法解决hash冲突，链表上的每个节点存储url和次数，数据插入时，hash(key) 放入同一个位置的key相同的链表上且次数+1,key不同就放入链表的下一个节点，外部使用一个变量来记录整个散列表存储的url最大次数k，根据k来选择使用哪个排序算法，时间复杂度：根据选择排序算法，快排：O(nlogn) 桶排序：O(n),空间复杂度散列表的空间：O(n)<br>2、第二题<br>使用散列表存储第一个数组的字符串，key：字符串，链表法解决hash冲突，链表的节点存储一个存在的标记：1和对应的key<br>遍历第二个字符串数组，用字符串去第一个数组的散列表查询是否存在，存在获取当前数组下标的字符串放入另外一个新的数组","like_count":0},{"had_liked":false,"id":341034,"user_name":"Geek_064e72","can_delete":false,"product_type":"c1","uid":2900973,"ip_address":"","ucode":"D627BACE46C37C","user_header":"","comment_is_top":false,"comment_ctime":1649304631,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1649304631","product_id":100017301,"comment_content":"所以，到底拼写检查是怎么实现的？为什么不说？懂链式反应了，就会制造原子弹了？","like_count":0},{"had_liked":false,"id":340359,"user_name":"歌者","can_delete":false,"product_type":"c1","uid":2662690,"ip_address":"","ucode":"AC27207D8273AB","user_header":"https://static001.geekbang.org/account/avatar/00/28/a1/22/c21f8c42.jpg","comment_is_top":false,"comment_ctime":1648780178,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648780178","product_id":100017301,"comment_content":"第二题 对第一个字符串数组进行hash映射，当出现冲突时，直接抛弃重复的这个元素。然后使用第二个进行hash(hash到上一个表中)，记录下所有导致冲突的字符串，就是重复的字符串。时间复杂度为o(n)","like_count":0},{"had_liked":false,"id":340358,"user_name":"歌者","can_delete":false,"product_type":"c1","uid":2662690,"ip_address":"","ucode":"AC27207D8273AB","user_header":"https://static001.geekbang.org/account/avatar/00/28/a1/22/c21f8c42.jpg","comment_is_top":false,"comment_ctime":1648779526,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648779526","product_id":100017301,"comment_content":"第一题可以用两个hash表来解决，首先以url为key，通过hash函数映射到hash表中，value就是访问次数times,然后每冲突一次，就增加一次该url的次数times，处理完10万条数据以后，就统计到了每个不同url的次数，同时在过程中记录下最大的次数k,然后可以以times为key，使用key","like_count":0},{"had_liked":false,"id":336929,"user_name":"Today","can_delete":false,"product_type":"c1","uid":1235000,"ip_address":"","ucode":"4FA397F0BD8C6E","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/38/41027bda.jpg","comment_is_top":false,"comment_ctime":1646475529,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646475529","product_id":100017301,"comment_content":"本节学习到了：<br><br>1. 通过散列函数可以将 key 存放在数组中“计算”的下标位置，从而实现按 key 读取复杂度是 O(1)<br>2. 散列函数高效但是会计算冲突，有开放性寻找和链式法，一般会配合装载因子来进行拓容判断<br><br>注意项就是因为哈希函数的第二点要求，所以哈希表中不能存储同 key 不同 value 的数据<br>思考题：<br><br>1. URL 可以借助哈希表 key 唯一的特性把对应 value 次数不断累加，最后再取出进行快排。比较器就设置为按 value 比较。<br>2. 也是用 key 唯一的特性进行判重","like_count":0},{"had_liked":false,"id":336772,"user_name":"Diego","can_delete":false,"product_type":"c1","uid":2559349,"ip_address":"","ucode":"3B2F05FEB2D8CF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKSyGkBwG4wwX0icYz21Y4dLeEiawpHaicRvRlXZXz7iaBXoib4vYVreoBEQ6WGRdYDI5jDeTJibohZFchw/132","comment_is_top":false,"comment_ctime":1646361551,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646361551","product_id":100017301,"comment_content":"老师您好，有一点我不太理解，如果用散列表储存英语单词，那对应的key和value分别是什么呢？","like_count":0},{"had_liked":false,"id":330930,"user_name":"敏","can_delete":false,"product_type":"c1","uid":1608307,"ip_address":"","ucode":"04EAA039553B98","user_header":"https://static001.geekbang.org/account/avatar/00/18/8a/73/e67f5eb8.jpg","comment_is_top":false,"comment_ctime":1642305400,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642305400","product_id":100017301,"comment_content":"“插入数据是，这个位置已经有数据了，所以就产生了冲突。于是我们就顺序地往后一个一个找，看有没有空闲的位置，”，那么查找时散列函数计算出的位置发现值对不上，也得往下一个一个的找","like_count":0},{"had_liked":false,"id":326314,"user_name":"水月","can_delete":false,"product_type":"c1","uid":2344034,"ip_address":"","ucode":"78FC68615016DB","user_header":"https://static001.geekbang.org/account/avatar/00/23/c4/62/269aae3f.jpg","comment_is_top":false,"comment_ctime":1639467951,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639467951","product_id":100017301,"comment_content":"算哈希值的函数是不是应该是个非常极致追求运算的写法，要不然按O(n)执行函数也够可怕的","like_count":0},{"had_liked":false,"id":311713,"user_name":"T------T","can_delete":false,"product_type":"c1","uid":2270365,"ip_address":"","ucode":"AC68D88893FAD7","user_header":"https://static001.geekbang.org/account/avatar/00/22/a4/9d/95900f70.jpg","comment_is_top":false,"comment_ctime":1631420717,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1631420717","product_id":100017301,"comment_content":"有个问题不太理解。<br>线性探测法，当运行一段时间后，散列表中没有数据的位置都被标记为delete了。那么查询一个没有的数据是不是就要遍历整个散列表了？","like_count":0},{"had_liked":false,"id":311712,"user_name":"T------T","can_delete":false,"product_type":"c1","uid":2270365,"ip_address":"","ucode":"AC68D88893FAD7","user_header":"https://static001.geekbang.org/account/avatar/00/22/a4/9d/95900f70.jpg","comment_is_top":false,"comment_ctime":1631420575,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1631420575","product_id":100017301,"comment_content":"有个问题不太理解。","like_count":0},{"had_liked":false,"id":311644,"user_name":"Geek_3a5591","can_delete":false,"product_type":"c1","uid":1189727,"ip_address":"","ucode":"1E47569D818F95","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/5f/f9573d8b.jpg","comment_is_top":false,"comment_ctime":1631358866,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631358866","product_id":100017301,"comment_content":"比较的是key，如果不同key散列后值相同，那么查找的时候应该是通过比较key是不是我要的那个，比较元素我还以为是比较value","like_count":0},{"had_liked":false,"id":311643,"user_name":"Geek_3a5591","can_delete":false,"product_type":"c1","uid":1189727,"ip_address":"","ucode":"1E47569D818F95","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/5f/f9573d8b.jpg","comment_is_top":false,"comment_ctime":1631358555,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631358555","product_id":100017301,"comment_content":"有个疑问，就是开放寻址发的散列表怎么通过key找到value，看完文章感觉好像只能已知key，value然后去判断在不在散列表里面？","like_count":0},{"had_liked":false,"id":308452,"user_name":"匿名用户","can_delete":false,"product_type":"c1","uid":2665412,"ip_address":"","ucode":"54ED93D18F9802","user_header":"https://static001.geekbang.org/account/avatar/00/28/ab/c4/49dfb810.jpg","comment_is_top":false,"comment_ctime":1629625318,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629625318","product_id":100017301,"comment_content":"单词检查的散列方案真是暴力啊","like_count":0},{"had_liked":false,"id":306135,"user_name":"William Ning","can_delete":false,"product_type":"c1","uid":1592279,"ip_address":"","ucode":"4DB8D05E69E5F3","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","comment_is_top":false,"comment_ctime":1628399153,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1628399153","product_id":100017301,"comment_content":"老师，同学们好。<br>关于总结了三点散列函数设计的基本要求：散列函数计算得到的散列值是一个非负整数；<br>这第一点，有些不明白，比如MD5的输出结果并不是非负整数？<br>还有其他的哈希算法，也是如此。<br>这怎么解释？","like_count":0},{"had_liked":false,"id":305739,"user_name":"1979104101ng","can_delete":false,"product_type":"c1","uid":2138770,"ip_address":"","ucode":"95204E6CBA81D6","user_header":"https://static001.geekbang.org/account/avatar/00/20/a2/92/6bbcb80b.jpg","comment_is_top":false,"comment_ctime":1628146582,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628146582","product_id":100017301,"comment_content":"参考精选留言的思路，这么写第二题是否可行呢？<br>let str1 = [&quot;ab&quot;, &quot;cs&quot;, &quot;jk&quot;, &quot;mn&quot;, &quot;op&quot;, &quot;sd&quot;, &quot;ty&quot;, &quot;wqe&quot;, &quot;qwv&quot;, &quot;fg&quot;];<br>let str2 = [&quot;ty&quot;, &quot;wer&quot;, &quot;wer&quot;, &quot;saf&quot;, &quot;gh&quot;, &quot;sdf&quot;, &quot;sd&quot;, &quot;zeq&quot;, &quot;pp&quot;, &quot;dsf&quot;];<br>function hash(str) {<br>\t&#47;&#47; ab 映射为 0001 cs 映射为 0218<br>\tlet res = str[0].charCodeAt(0) - 97;<br>\tfor (let i = 1; i &lt; str.length; i++) {<br>\t\tres *= 100;<br>\t\tres += str[i].charCodeAt(0) - 97;<br>\t}<br>\treturn res;<br>}<br>function makeHashMap(map, str) {<br>\tlet hashMap = map;<br>\tfor (let i = 0; i &lt; str.length; i++) {<br>\t\tif (hashMap.indexOf(hash(str[i])) &lt; 0) {<br>\t\t\thashMap.push(hash(str[i]))<br>\t\t}<br>\t}<br>\treturn hashMap;<br>}<br>let hashMap = makeHashMap([], str1);<br>for (let i = 0; i &lt; str2.length; i++) {<br>\tconst value = hash(str2[i]);<br>\tif (hashMap.indexOf(value) &gt; -1) {<br>\t\tconsole.log(str2[i]);<br>\t}<br>}","like_count":0},{"had_liked":false,"id":297878,"user_name":"牧凉","can_delete":false,"product_type":"c1","uid":1238166,"ip_address":"","ucode":"1F57A16E37C668","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/96/a5d775e9.jpg","comment_is_top":false,"comment_ctime":1623829873,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623829873","product_id":100017301,"comment_content":"老师，我想问一下链表法里那个散列表数组里面的元素存的是不是它对应的那条链表的头结点？","like_count":0},{"had_liked":false,"id":297673,"user_name":"海崖","can_delete":false,"product_type":"c1","uid":2552745,"ip_address":"","ucode":"9D42E0B0D30A56","user_header":"https://static001.geekbang.org/account/avatar/00/26/f3/a9/bb9d8450.jpg","comment_is_top":false,"comment_ctime":1623725154,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623725154","product_id":100017301,"comment_content":"叮~打卡","like_count":0},{"had_liked":false,"id":297576,"user_name":"Geek_bde666","can_delete":false,"product_type":"c1","uid":2639350,"ip_address":"","ucode":"8431CD816F8C59","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/jA2I5icKYCQtfEMnwAqcJUaY86jFQKsKAFmtIV4rIStCDEMKnQ2Lib9XUj8NAktkTTWoxFUmtYWLxQCfSNScaYkg/132","comment_is_top":false,"comment_ctime":1623646782,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623646782","product_id":100017301,"comment_content":"为什么要用散列表呢？直接使用对象存储不就好了。时间复杂度也是o1","like_count":0},{"had_liked":false,"id":292814,"user_name":"厦门黄猫编程","can_delete":false,"product_type":"c1","uid":2555585,"ip_address":"","ucode":"23CE12B1E4B201","user_header":"https://static001.geekbang.org/account/avatar/00/26/fe/c1/dd018fc4.jpg","comment_is_top":false,"comment_ctime":1620989147,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620989147","product_id":100017301,"comment_content":"当用户输入某个英文单词时，我们拿用户输入的单词去散列表中查找。如果查到，则说明拼写正确；如果没有查到，则说明拼写可能有误，给予提示。借助散列表这种数据结构，我们就可以轻松实现快速判断是否存在拼写错误。<br>这个算法用bf暴力？应该不是吧。把单词转为数学再看看是否相等？","like_count":0},{"had_liked":false,"id":292462,"user_name":"WZ","can_delete":false,"product_type":"c1","uid":1310099,"ip_address":"","ucode":"43B5BB6924A33F","user_header":"https://static001.geekbang.org/account/avatar/00/13/fd/93/9a3a3e83.jpg","comment_is_top":false,"comment_ctime":1620830446,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620830446","product_id":100017301,"comment_content":"老师，我有一个问题不太明白，对于链表法，如果两个key的hash值一样，那么查找时，会定位到同一个链表，链表中保存的数据是key-val还是仅仅保存val呢？如果只保存了val，那么怎么确定这两个key的值是哪一个呢？","like_count":0},{"had_liked":false,"id":291966,"user_name":"ฅSlekฅ","can_delete":false,"product_type":"c1","uid":2436755,"ip_address":"","ucode":"B732C672B3D301","user_header":"https://static001.geekbang.org/account/avatar/00/25/2e/93/81e3e4ca.jpg","comment_is_top":false,"comment_ctime":1620628441,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620628441","product_id":100017301,"comment_content":"可以将10万条访问日志存入散列表，其中key为URL，value初始值为0。 当第一条HashCode(URL)存入散列表，再有相同的HashCode(URL)存入会产生散列冲突。此时，再比较key是否相同。如果key相同，则是同一个URL，将相应的value++；如果key不相同，则存入链表下一个位置。 可以在外部将最大值K给记录下来。插入完成以后，就可以取得当前URL的出现次数的范围即0-K。 根据K的大小选取相应的算法。如果K值不大，可以采用桶排序。如果K值很大，可采用快排。 为什么使用散列表进行存储： 散列表存储完成以后，已经对URL完成了去重操作，同时拿到了最大次数K，根据K选择合适的排序算法。 时间复杂度分析： 10万条URL存入散列表，时间复杂度为O(n)。 桶排序，时间复杂度为O(n)。 快排，时间复杂度为O(nlogn)。","like_count":0},{"had_liked":false,"id":290313,"user_name":"Laughing","can_delete":false,"product_type":"c1","uid":1002134,"ip_address":"","ucode":"F68F1E000CA800","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/96/99466a06.jpg","comment_is_top":false,"comment_ctime":1619493776,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619493776","product_id":100017301,"comment_content":"1. 可以根据URL规定散列函数，然后在散列槽位对应都创建一个数组，只要散列到该位置都依次放入数组中，最后根据散列槽位对应数组的长度进行排序，从大到小依次读出各个数组的数据即可；<br>2. 首先还是确定散列函数，对其中一个数组进行散列，然后循环另外一个数组通过散列函数去对应的位置查找是否有该字符串。","like_count":0},{"had_liked":false,"id":288382,"user_name":"我的大好时光","can_delete":false,"product_type":"c1","uid":1455038,"ip_address":"","ucode":"7ABD0ABBA19633","user_header":"https://static001.geekbang.org/account/avatar/00/16/33/be/1525566f.jpg","comment_is_top":false,"comment_ctime":1618449890,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618449890","product_id":100017301,"comment_content":"那到底什么是散列表呢？不是很明白","like_count":0},{"had_liked":false,"id":286248,"user_name":"吃鱼","can_delete":false,"product_type":"c1","uid":2005742,"ip_address":"","ucode":"CB7AC741E0E4B7","user_header":"https://static001.geekbang.org/account/avatar/00/1e/9a/ee/f996f864.jpg","comment_is_top":false,"comment_ctime":1617208420,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617208420","product_id":100017301,"comment_content":"写了一下开放地址探测的散列表，发现装载因子的计算方式应该是底层数组中添加过的总元素数除以数组容量，因为即使是被删除的元素，也会影响添加删除查询的性能，所以不能以现存元素数来计算。","like_count":0},{"had_liked":false,"id":282577,"user_name":"极客老王","can_delete":false,"product_type":"c1","uid":1002213,"ip_address":"","ucode":"BDC2FFDC12BCFE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/e5/2d4f6067.jpg","comment_is_top":false,"comment_ctime":1615306860,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615306860","product_id":100017301,"comment_content":"总结<br>概念：散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表<br>解决散列冲突的2种常用方法：开放寻址法（open addressing）和链表法（chaining）。<br>其中，开放寻址有包括线性探测、二次探测和双重探测<br>线性探测的插入：当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。<br>线性探测的查找：我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在散列表中。<br>线性探测的删除：我们可以将删除的元素，特殊标记为 deleted。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测<br>二次探测：而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 hash(key)+0，hash(key)+12，hash(key)+22……<br>双重散列；意思就是不仅要使用一个散列函数。我们使用一组散列函数 hash1(key)，hash2(key)，hash3(key)……我们先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。<br><br>","like_count":0},{"had_liked":false,"id":280614,"user_name":"天涯","can_delete":false,"product_type":"c1","uid":1591230,"ip_address":"","ucode":"6D6AB6FE6092B8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/25d7qAwOPAw5E5pBepSxkAnN2icCgum3BYBURmOHADDg45Iricq8QhtONoFQ4lqVMziavh4ZRialqrQtzwk5iakNI2A/132","comment_is_top":false,"comment_ctime":1614267018,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614267018","product_id":100017301,"comment_content":"如果使用开放寻址法解决散列冲突，那么散列表的结构和数组的结构区别就只是多了一步哈希函数计算?","like_count":0},{"had_liked":false,"id":277321,"user_name":"xxx","can_delete":false,"product_type":"c1","uid":1356978,"ip_address":"","ucode":"E78B1F15BC10F7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIcLjatV3GHdibZXCTIgL1X2A7jpByIeLH3Zyia8KXdT4JRcicmVSgq5ekRHCFCFenMqicsAwaWYibHkTw/132","comment_is_top":false,"comment_ctime":1612358440,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612358440","product_id":100017301,"comment_content":"现在终于知道散列表是什么了。散列表借助散列函数和数组支持下标随机访问的特性，达到快速存储和查询键值对的效果。散列函数是将键值key映射为下标值，存储value值。","like_count":0},{"had_liked":false,"id":271677,"user_name":"慕高迪","can_delete":false,"product_type":"c1","uid":1448126,"ip_address":"","ucode":"EB1CB5EA4E3A90","user_header":"https://static001.geekbang.org/account/avatar/00/16/18/be/ad3127e0.jpg","comment_is_top":false,"comment_ctime":1609753875,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609753875","product_id":100017301,"comment_content":"总结：<br><br>散列表是基于数组的一种扩展结构，它依赖数组的随机访问特性。如果我们想把数据正确的填充散列表中，此时就需要一个散列函数，将输入的数据经过散列函数后生成一个散列值，这个散列值一般为数组的下标。<br>当进行数据查找时，也需要使用到该散列函数。<br><br>1. 散列函数<br><br>这个散列函数的选择一般需要满足如下三个要求：<br><br>(1) 相同的key，经过散列函数后，生成的散列值是相等的。<br>(2) 不用的key，经过散列函数后，生成的散列值要尽可能不相等。<br>(3) 散列函数计算出来的散列值必须是一个非负整数。因为数组的下标是从0开始的。<br><br>2. 哈希碰撞<br><br>当不同的key，经过散列函数后，生成相同的散列值时，此时就会发生哈希碰撞。一般出现哈希碰撞时，我们有两种解决办法：开放寻址法和链表法。<br><br>2.1 开放寻址法<br><br>开放寻址法的核心在于：当发生哈希碰撞时，就去寻找其他空闲的位置来存放。最简单的开发寻址法是线性寻址，假设在第k个位置发生碰撞后，它会继续寻址，查看第k+1的位置是否空闲，如果不空闲就继续查看k+2的位置，当寻址到数组的最后一个元素时，会从数组头开始继续寻址，直到找到空闲位置为止。<br>最坏情况下，需要寻址整个数组，此时的时间复杂度就会变为：O(N) 。当然还有一些其他的开发寻址法，例如：二次寻址和再散列。 二次寻址方式类似于 hash(key) + 1^2 .. hash(key) + 2^2 这样的寻址位置来查找空间空间。而再散列是经过一系列的散列函数计算散列值，直到找到空闲位置为止。<br><br>开放寻址法的查找和插入类似，进过散列函数后，得出散列值，然后判断数组中对应位置元素是否和key相等，如果相等则返回，如果不相等，则以线性寻址或二次寻址的方式进行查找，直到碰见相等的元素或寻址的位置为空时返回。如果查找到元素后，需要删除元素，不能进行简单的清空，而要标记删除，以免影响后续寻址的查找操作（查找碰见空就会返回，如果此时把元素删除，当寻址到它的时候发现没有元素了就返回了，影响了它后续元素的寻址，结果就是明明存在，返回的结果却是不存在）<br><br><br>2.2 链表法<br><br>链表法比较简单。发生碰撞时，对于碰撞的元素直接使用链表存储在数组的元素中。时间复杂度为O(1)。当查找时，直接遍历链表即可，假设链表的元素为K，则时间复杂度为O(K) ; 当删除元素时，时间复杂度也为O(K) 。<br><br><br>3. 复杂度分析：<br><br>3.1 添加操作时间复杂度<br><br>3.1.1 当不存在哈希碰撞时，添加的时间复杂度为O(1)<br>3.1.2 当存在哈希碰撞时，采用开放寻址法解决碰撞问题，以线性寻址为例。最好情况下的时间复杂度为O(1)；最坏情况下的时间复杂度为O(N)；<br>3.1.3 当存在哈希碰撞时，采用链表法解决碰撞问题，时间复杂度为O(1)<br><br>3.2 查找操作时间复杂度<br><br>3.2.1 当不存在哈希碰撞时，查找的时间复杂度为O(1)<br>3.2.2 当存在哈希碰撞时，采用开放寻址法解决碰撞问题，以线性寻址为例。最好情况下的时间复杂度为O(1)；最坏情况下的时间复杂度为O(N)；<br>3.2.3 当存在哈希碰撞时，采用链表法解决碰撞问题，时间复杂度为O(K）。 K为链表中元素的个数<br><br><br>3.3 删除操作时间复杂度<br><br>3.3.1 当不存在哈希碰撞时，删除的时间复杂度为O(1)<br>3.3.2 当存在哈希碰撞时，采用开放寻址法解决碰撞问题，以线性寻址为例。最好情况下的时间复杂度为O(1)；最坏情况下的时间复杂度为O(N)；<br>3.3.3 当存在哈希碰撞时，采用链表法解决碰撞问题，时间复杂度为O(K）。 K为链表中元素的个数<br><br>4.减少哈希碰撞的方法<br><br>通过引入一个变量：填充因子， 填充因子 = 填充到表中的元素个数 &#47; 散列表的长度 。 当填充因子超过某个阈值时，就对整个数组进行扩容，并对旧元素重新经过散列函数迁移到新的数组中","like_count":0},{"had_liked":false,"id":270919,"user_name":"Spring4J","can_delete":false,"product_type":"c1","uid":1645430,"ip_address":"","ucode":"06F056085A2564","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiauonyMORA2s43W7mogGDH4WYjW0gBJtYmUa9icTB6aMPGqibicEKlLoQmLKLWEctwHzthbTZkKR20w/132","comment_is_top":false,"comment_ctime":1609317860,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609317860","product_id":100017301,"comment_content":"请教个问题呗：<br>1、关键字-&gt;哈希值，使用哈希函数，哈希值可能重复；<br>2、哈希值-&gt;数组下标，使用取模运算，数组下标可能重复；<br>那么，哈希冲突到底指的是1还是2呢？","like_count":0},{"had_liked":false,"id":270209,"user_name":"李吉玉","can_delete":false,"product_type":"c1","uid":1973965,"ip_address":"","ucode":"5BA744B972B5EA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIh0pqaia3PpSks7ib6OBORStk9EMuibQSVWmXtwpQHQOcdibmh4VJzrpcvxOuCyG45I0puNHUulVENRQ/132","comment_is_top":false,"comment_ctime":1608988118,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608988118","product_id":100017301,"comment_content":"1、假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？<br>答案：定义一个map，循环遍历这10万个URL，map的key为url，value为访问次数，遍历完成之后，再遍历map，进行排序<br><br>2、有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？<br>答案：定义一个map，遍历第一个字符串数组，放入map中，key为字符串，value为1；然后遍历第二个数组，如果在map中存在，就存在，在map中不存在，就不存在<br>","like_count":0},{"had_liked":false,"id":270207,"user_name":"李吉玉","can_delete":false,"product_type":"c1","uid":1973965,"ip_address":"","ucode":"5BA744B972B5EA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIh0pqaia3PpSks7ib6OBORStk9EMuibQSVWmXtwpQHQOcdibmh4VJzrpcvxOuCyG45I0puNHUulVENRQ/132","comment_is_top":false,"comment_ctime":1608987954,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608987954","product_id":100017301,"comment_content":"假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？","like_count":0},{"had_liked":false,"id":266147,"user_name":"Fy","can_delete":false,"product_type":"c1","uid":2213304,"ip_address":"","ucode":"4F4C0617A79083","user_header":"https://static001.geekbang.org/account/avatar/00/21/c5/b8/481d8a64.jpg","comment_is_top":false,"comment_ctime":1607201960,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607201960","product_id":100017301,"comment_content":"1，第一题 建立一个新的 node class 对应一个url。里面存url，和该url出现的次数。存放在tree set里面，根据出现次数做comparator<br>2，先把两个数组各自排序，然后双指针遍历。类似于两个sorted list，A(i) &lt;B(j) then i++","like_count":0},{"had_liked":false,"id":265725,"user_name":"王玉彬","can_delete":false,"product_type":"c1","uid":2346455,"ip_address":"","ucode":"8DA1ADB9B4026C","user_header":"https://static001.geekbang.org/account/avatar/00/23/cd/d7/c932f32a.jpg","comment_is_top":false,"comment_ctime":1606994491,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606994491","product_id":100017301,"comment_content":"1. 根据10万条url，以url为key建立散列表，值全部设置为0，每检索到一个url访问日志，相应位置加1.<br>2. 将第一个数组放入hash map中，遍历第二个字符串数组，并检测是否存储于hash map中。","like_count":0},{"had_liked":false,"id":264139,"user_name":"爬坡的蚂蚁","can_delete":false,"product_type":"c1","uid":1463578,"ip_address":"","ucode":"FBA950CDCE6723","user_header":"https://static001.geekbang.org/account/avatar/00/16/55/1a/c5f033a0.jpg","comment_is_top":false,"comment_ctime":1606360639,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606360639","product_id":100017301,"comment_content":"置顶的留言第一题的解看得有点糊涂，我是用OC语言开发，按我的理解应该是这样的：<br><br>1.假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？<br>首先遍历10万条日志，以URL为Key，以次数为Value存入字典（键值对存储），然后用一个散列表，Value为散列表下标，用链表法存储Key，这样就得到了一个按访问次数排序的URL散列表。","like_count":0},{"had_liked":false,"id":263768,"user_name":"Untitled","can_delete":false,"product_type":"c1","uid":1039464,"ip_address":"","ucode":"8DD6ABA3E81A2E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/dc/68/006ba72c.jpg","comment_is_top":false,"comment_ctime":1606264786,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1606264786","product_id":100017301,"comment_content":"散列的背后是一个数组，那说明一开始就分配了一个确定大小的数据块？图片里面的每个小框，存储的是key对应的全量吗，也就是value值？","like_count":0},{"had_liked":false,"id":262231,"user_name":"730","can_delete":false,"product_type":"c1","uid":1365906,"ip_address":"","ucode":"9B977D81555597","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIxWnibG6QTEPGPGibOrafbWlEbkaCq1BpamrTibSIra00bcAzFLztpIZINtgILdWWOv9Ph5Ed0fvRibw/132","comment_is_top":false,"comment_ctime":1605669316,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605669316","product_id":100017301,"comment_content":"1.先把url放进哈希表，然后存在+1，最后按value排序<br>2.第一个数组存hash表","like_count":0},{"had_liked":false,"id":257334,"user_name":"杨","can_delete":false,"product_type":"c1","uid":1971269,"ip_address":"","ucode":"7EFEFE285975C6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/oltLEqTrmHm2aJP99BK6tHu5h7hp4aj08wR5Wt6H31iadFduDAVvjYKmhQ2nvGbLV3lkVdiat2GRasgWXoJeTibUg/132","comment_is_top":false,"comment_ctime":1603940500,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603940500","product_id":100017301,"comment_content":"2. 有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？<br>可以使用一次遍历 双map 相互判断，而不需要做两次遍历","like_count":0},{"had_liked":false,"id":254244,"user_name":"生命贵在运动","can_delete":false,"product_type":"c1","uid":1287701,"ip_address":"","ucode":"947C5858D5352C","user_header":"https://static001.geekbang.org/account/avatar/00/13/a6/15/c21506a0.jpg","comment_is_top":false,"comment_ctime":1603090492,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603090492","product_id":100017301,"comment_content":"关键还得刷题","like_count":0},{"had_liked":false,"id":248571,"user_name":"jack","can_delete":false,"product_type":"c1","uid":1898292,"ip_address":"","ucode":"A2253AC8570C5E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/jibauP3icEFic4w56L2ddVghL7h2gGKhFdW8lBfE9rpwwRgzUKkLFY9wb4w70AXz7retME96a6EBRTA0LvSLn0ib8A/132","comment_is_top":false,"comment_ctime":1600226253,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1600226253","product_id":100017301,"comment_content":"1.假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？<br>获取URL的访问次数：遍历10万条URL，以URL为key，访问次数为value构建散列表（快速获取每个URL的访问次数），时间复杂度O(n)；若URL的种类数不大为K，基于散列表中的访问次数进行计数排序，时间复杂度为O(K)；若散列表的URL的种类数较大，基于散列表中的访问次数进行快速排序，时间复杂度为O(nlogn)。<br><br>2.有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？<br>以其中一个字符串数组来构建散列表a，字符串为key，value为1（a[hash(key)]=1）；遍历第二个字符串数组，以字符串为key进行散列查找（计算a[hash(string)]==1？)，若找到则返回相同的字符串。","like_count":0},{"had_liked":false,"id":239893,"user_name":"joker","can_delete":false,"product_type":"c1","uid":2007345,"ip_address":"","ucode":"59040A9BE79CF5","user_header":"https://static001.geekbang.org/account/avatar/00/1e/a1/31/a0a33553.jpg","comment_is_top":false,"comment_ctime":1596685952,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596685952","product_id":100017301,"comment_content":"笔记<br>开放寻址法：<br>散列表查找的最终目的是使用key值找到value, 冲突发生以后，复数个key值会被散列函数映射成同一个数组下标，此时如何判断要查找的value在哪里呢？<br>解决方法时数组里面同时存储Key和value信息，用下标找到信息后，再比对Key是否相同，不相同继续往下遍历寻找","like_count":0},{"had_liked":false,"id":238065,"user_name":"对白","can_delete":false,"product_type":"c1","uid":1268797,"ip_address":"","ucode":"3183E5ADBC794B","user_header":"https://static001.geekbang.org/account/avatar/00/13/5c/3d/e8325811.jpg","comment_is_top":false,"comment_ctime":1596053864,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596053864","product_id":100017301,"comment_content":"第一题有两种实现方法：1、mapreduce：map端统计每个key对应的value次数和reduce端按照value对key排序；2、散列表：将url作为key存储在散列表中，value对应url的次数，统计散列表中value的最大值和最小值，确定差值是否满足桶排序的要求，若满足则对散列表中的url进行排序，若不满足则用快排。","like_count":0},{"had_liked":false,"id":237629,"user_name":"Jenchih","can_delete":false,"product_type":"c1","uid":1426211,"ip_address":"","ucode":"0B363C30F1A83C","user_header":"https://static001.geekbang.org/account/avatar/00/15/c3/23/888ef9c5.jpg","comment_is_top":false,"comment_ctime":1595905374,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595905374","product_id":100017301,"comment_content":"链表法查询的时候，散列函数不是算出具体的链表，可是链表里面很多值，到底去链表中的哪个元素呢？","like_count":0},{"had_liked":false,"id":237627,"user_name":"Jenchih","can_delete":false,"product_type":"c1","uid":1426211,"ip_address":"","ucode":"0B363C30F1A83C","user_header":"https://static001.geekbang.org/account/avatar/00/15/c3/23/888ef9c5.jpg","comment_is_top":false,"comment_ctime":1595905079,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595905079","product_id":100017301,"comment_content":"用链表法的话，数据会插入到对应的链表里面，查询的时候，也是通过散列函数计算出对应哪个链表的哪个指针吗？","like_count":0},{"had_liked":false,"id":232847,"user_name":"航","can_delete":false,"product_type":"c1","uid":2050135,"ip_address":"","ucode":"FFAE304D6D4AD6","user_header":"https://static001.geekbang.org/account/avatar/00/1f/48/57/f81acea8.jpg","comment_is_top":false,"comment_ctime":1594129944,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594129944","product_id":100017301,"comment_content":"关于那个Word 文档中单词拼写检查功能是如何实现的？我提出我的想法希望有人能验证一下我对不对。。。<br>(我的猜想，如果hash函数要做key（单词）和hash值一一对应的话，可能需要的数组会变得很大很大，因为hash函数根据单词计算哈希值，然而单词可以很长很长。。。, 就像手机号11位那么长，但很多都是空号，不必要为所有的手机都留一个空间)<br><br>我认为应该可能只取前四位（如果不足四位0补齐）来生成hash值存储这些单词应该就可以了。（所以说散列冲突在所难免）。<br><br>我说的对吗？）","like_count":0},{"had_liked":false,"id":232132,"user_name":"一一","can_delete":false,"product_type":"c1","uid":1492286,"ip_address":"","ucode":"B4E5F0370ACA2E","user_header":"https://static001.geekbang.org/account/avatar/00/16/c5/3e/2bb7edc9.jpg","comment_is_top":false,"comment_ctime":1593865075,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593865075","product_id":100017301,"comment_content":"我学Java的时候， 一直觉得HashMap是一个很神奇的数据结构。读过jdk的源代码，也知道这种实现的好处。今天大神给我们讲了一下“hash的故事”， 感觉对这种数据结构的认知又提升了一个档次。","like_count":0},{"had_liked":false,"id":231062,"user_name":"极客学子","can_delete":false,"product_type":"c1","uid":1149510,"ip_address":"","ucode":"40051597564EB7","user_header":"https://static001.geekbang.org/account/avatar/00/11/8a/46/71747b18.jpg","comment_is_top":false,"comment_ctime":1593572936,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593572936","product_id":100017301,"comment_content":"1.使用数组存储URL，然后通过散列表记录URL的访问次数，key为URL，value为访问次数，然后对URL数组进行排序，排序的时候比较的话要冲散列表取出访问次数进行比较。<br>2.先遍历一个字符串数组存储到散列表中，然后遍历另外一个数组的每个元素，并判断该元素是否存在散列表中，存在则证明是两个数组中相同的字符串，遍历完数组即可找到所有的相同字符串。","like_count":0},{"had_liked":false,"id":225959,"user_name":"Altruiste","can_delete":false,"product_type":"c1","uid":1620970,"ip_address":"","ucode":"356E45A8D8BF5E","user_header":"https://static001.geekbang.org/account/avatar/00/18/bb/ea/816b89fa.jpg","comment_is_top":false,"comment_ctime":1591919773,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591919773","product_id":100017301,"comment_content":"对于哈希表的key存储我有一个疑问，在哈希表中，对于key的存储，是同时存储key的值和它的hash值吗？不然的话，实际发生了哈希冲突的时候hash 表应该无法判定这个key是否是已有的key还是新的但是hash冲突的key","like_count":0},{"had_liked":false,"id":223342,"user_name":"ɴɪᴋᴇʀ","can_delete":false,"product_type":"c1","uid":1616622,"ip_address":"","ucode":"DB7D92CBB5FD15","user_header":"https://static001.geekbang.org/account/avatar/00/18/aa/ee/15c328ca.jpg","comment_is_top":false,"comment_ctime":1591067384,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591067384","product_id":100017301,"comment_content":"求问，散列表是基于数组实现的，那二次探测法探测步长是指数形式增长，会不会使散列表占用非常大的内存空间","like_count":0},{"had_liked":false,"id":222813,"user_name":"areadrom","can_delete":false,"product_type":"c1","uid":1252081,"ip_address":"","ucode":"A54CE71DB34CC8","user_header":"https://static001.geekbang.org/account/avatar/00/13/1a/f1/ce6af893.jpg","comment_is_top":false,"comment_ctime":1590917077,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590917077","product_id":100017301,"comment_content":"-- “如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在散列表中。”<br>关于元素的查找，这里我始终是没有想明白，为什么遍历大盘数组中空闲的位置还没找到，就说明要找的元素不在其中？假如遇到第一个空闲的位置没有，但是分布在第二个空闲位置之后呢，存在这种可能不？可能问的毕竟傻，但是真的没懂","like_count":0},{"had_liked":false,"id":219285,"user_name":"王瑞强","can_delete":false,"product_type":"c1","uid":1829090,"ip_address":"","ucode":"DEE4EB5E23433F","user_header":"https://static001.geekbang.org/account/avatar/00/1b/e8/e2/2bcaef68.jpg","comment_is_top":false,"comment_ctime":1589983385,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589983385","product_id":100017301,"comment_content":"针对第一题，首先想到的是请求次数做为key，url做为value存入hash表，然后循环输出即可。后来浏览了置顶的回答，觉得自己考虑的不周全，1：日志中url的访问次数有可能相差很大，假如一个url的访问次数到达千万或者更大，这样底层数组的长度会很大，严重浪费空间。2：没有考虑多个算法结合使用，很多通用的算法都是多个算法结合使用的。再此记录一下，提醒自己。","like_count":0},{"had_liked":false,"id":217762,"user_name":"许明","can_delete":false,"product_type":"c1","uid":1104038,"ip_address":"","ucode":"35974034E26F2A","user_header":"https://static001.geekbang.org/account/avatar/00/10/d8/a6/f939bf32.jpg","comment_is_top":false,"comment_ctime":1589606248,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589606248","product_id":100017301,"comment_content":"散列表在用链表法的时候，就是 数组+单链表，这样理解没问题吧","like_count":0},{"had_liked":false,"id":217136,"user_name":"yw","can_delete":false,"product_type":"c1","uid":1632195,"ip_address":"","ucode":"F937C47767822B","user_header":"https://static001.geekbang.org/account/avatar/00/18/e7/c3/f7066fd1.jpg","comment_is_top":false,"comment_ctime":1589424529,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589424529","product_id":100017301,"comment_content":"第一题感觉和hash的关系不大，定义个url,访问次数count的对象用list存储，然后以访问次数count为关键字进行排序就好了，还有种方法直接存入数据库表，表字段是url和count,然后安count字段进行排序也可以","like_count":0},{"had_liked":false,"id":215005,"user_name":"Geraint","can_delete":false,"product_type":"c1","uid":1233926,"ip_address":"","ucode":"ED183FCE273A7A","user_header":"https://static001.geekbang.org/account/avatar/00/12/d4/06/6b103521.jpg","comment_is_top":false,"comment_ctime":1588866836,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588866836","product_id":100017301,"comment_content":"1. 假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？<br>    先统计，再排序。<br>     用散列表 key 为 url ，次数为 value，循环统计。<br>     统计后按照二分法排序。<br><br><br>2. 有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？<br>    翻一个散列表，循环数组1 放入散列表。<br>    循环第二个数组，在散列表中查找。<br><br>看了下点赞最高的回答，少考虑了时间复杂度。学习了。","like_count":0},{"had_liked":false,"id":214788,"user_name":"Geek_ac7784","can_delete":false,"product_type":"c1","uid":1981613,"ip_address":"","ucode":"62F0E5E6D6F4BA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/8Dj4ugujXwY24G8pcpgDFGiciarXetG3ItQ4M9mSQMLyRdRRXEXXJVfib48mGUQAu87QcvImwyJIVJlEFeEguV44w/132","comment_is_top":false,"comment_ctime":1588819469,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588819469","product_id":100017301,"comment_content":"学习笔记:<br>1. 散列表之前学过，本节课复习了基本概念，和一些细节的补充<br>2. 散列表的存储其实还是数组。有三个概念，key，哈希函数、哈希值。key通过哈希函数获得哈希值，哈希值就是对象在数组中的下标。<br>3. 哈希函数很重要，他要尽可能的防止冲撞，均匀的将key散列到数组中。常见的哈希函数有MD5，SSA，CRC。但即使这样的，也不会有冲撞。<br>4. 冲撞解决：<br>    开放寻址法：就是获取哈希值后，如果当前空间冲撞，则通过线性+n或者二次+n2的手段，重新寻找空闲空间，将对象插入。寻找时，如果哈希值不是要找的，则按照之前的探测方式，向后探测，如果遇到空位(伏笔)，还没找到，则没找到。删除时有个坑，你不能直接删除而是标记为 deleted。因为你要删除的是先插入的数据。这样会在后插入的数据之前留下空位，导致查找时找不到。二次散列法:同理，但没有删除标记这个坑了（自己的思考）。时间复杂度好的情况是O(1)坏的情况是O(n）。<br>    2. 链表法：所谓的数组不再存储数据，而是存储一个链表的头结点，通过散列值，将数据插入到散列值对应的链表中。时间复杂度插入是O(1),查找要看链表长度。若均匀散列，O(m&#47;n)。m是数据量，n是数组长度，m&#47;n就是链表平均长度。<br>4. 所有单词全部存起来惨2MB，乘10也就20MB，感觉电脑太强了。常用汉字3500个一个2B,才共计7KB空间。字体存储的是每一个字的画法。看了一套字体的大小不到40KB<br>思考题:<br>url放在哈希表，并保存一个访问数的子对象。遍历整个url日志，放在哈希表中，访问次数加1，没遇到一次+1。然后按照访问次数作为关键字排序。对应c++中的map<br>将其中一个数组放在哈希表中。遍历第二个数组，依次在哈希表中寻找就行了。对应c++中的set","like_count":0},{"had_liked":false,"id":213504,"user_name":"星星","can_delete":false,"product_type":"c1","uid":1202481,"ip_address":"","ucode":"868E88A96313AE","user_header":"https://static001.geekbang.org/account/avatar/00/12/59/31/3820fbb7.jpg","comment_is_top":false,"comment_ctime":1588435109,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588435109","product_id":100017301,"comment_content":"2. 把数组 A 放入 hashtable 在遍历数组看是否存在 key 复杂度为 O(n)","like_count":0},{"had_liked":false,"id":212690,"user_name":"你在不远的未来","can_delete":false,"product_type":"c1","uid":1318404,"ip_address":"","ucode":"5B34C8BD03B71A","user_header":"https://static001.geekbang.org/account/avatar/00/14/1e/04/f902047e.jpg","comment_is_top":false,"comment_ctime":1588176731,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588176731","product_id":100017301,"comment_content":"问&gt; 假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？<br>解&gt; 针对url设计hash函数，hash函数生成hash表， hash表中单元素表包含：count值和URL值。对url遍历10w次生成最终hash表，对hash表进行快排，生成最终URL PV排名。<br><br>问&gt; 有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？<br>答&gt; 设数组a、b，遍历a以数组元素为key生成hash表。再以相同hash函数遍历数组b，如存在则标记hash位置，输出带有标记的hash表元素即可。","like_count":0},{"had_liked":false,"id":212245,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1588078371,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1588078371","product_id":100017301,"comment_content":"单词拼写检查功能比较容易实现，但是推荐修改预测就比较困难了，不光是拼写问题，还得猜前后的意思，类似于输入法的联想功能。<br><br>先说两个课后思考题。<br><br>第一个，如果有 10 条 URL 访问记录，那么就采用散列表的形式，对每条 URL 做 Hash，然后在对应 Value 字段存储访问次数。如果是第一次访问，就在 Hash 表里面增加一条记录；如果是第二次访问，就将访问次数，也就是 Value 字段，加一。<br><br>最后，再按照 Value 字段排序即可。<br><br>第二道题目，每个数组 10 条字符串，同样对字符串做哈希，如果 Hash 函数设计的足够好，那么就不会有太多的冲突，假设第一个数组读完之后，Hash 表中有 10 万条记录，然后再遍历第二个数组，用同样的 Hash 函数，就可以找到相同的字符串。<br><br>如果不是在散列表的章节，那么第二道思考题可能更容易想到分别对字符串数组排序，然后再比较的思路。<br><br>对于散列表来说，合适的哈希映射函数，应该是一个关键。<br><br>看了一遍作者在 GitHub 上给出的 Java 实现，其实留言里面的很多问题，都可以从代码中找答案。<br><br>我觉的比较难以理解的地方其实是在于，将 Entry&lt;key, value&gt; 中的 key 做哈希之后，形成一个存储的索引（如果是数组的话就是下标，代码里面是链表，所以我就称其为索引），然后根据这个索引去查找、插入或者删除散列表中的项。<br><br>而找到索引之后，需要对 key 进行比对，如果相等，那么就是找到了所要找的散列表项。","like_count":0},{"had_liked":false,"id":212039,"user_name":"Allan","can_delete":false,"product_type":"c1","uid":1310388,"ip_address":"","ucode":"8DA4DBECC2C45C","user_header":"https://static001.geekbang.org/account/avatar/00/13/fe/b4/295338e7.jpg","comment_is_top":false,"comment_ctime":1588050591,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588050591","product_id":100017301,"comment_content":"60天攻克算法打卡行动第15天<br><br>散列表的核心问题是散列函数设计和散列冲突解决。掌握相关基础概念和方法，就能轻松实现文本编辑器中的拼写检查功能。<br><br>1.如何理解散列思想？<br>哈希表;散列表是由数组扩展过来。散列函数：把key与value的映射起来<br>2.有哪些散列函数？<br>散列函数顾名思义就是一个函数。<br>-&gt;散列函数计算得到的散列值是一个非负整数<br>-&gt;如果 key1 = key2，hash(key1) = = hash(key2)<br>-&gt;如果 key1 != key2, hash(key1) != hash(key2)<br>3.散列冲突的解决方法是什么？<br>-&gt;开放寻址法<br>冲突了就往下找，直到找到一个空闲的位置然后插入；删除的时候不是直接删除而是表示deleted，如果检测到是deleted那么接着往下找直到找到的不是deleted位置。二次探测：和线性探测很像，线性探测是 hash（key）+0 ，hash（key）+1 这样一步一步的探测，而二次探测是 平方级别 hash（key） + 0^2 ,hash(key)+ 1^2,hash(key) + 2^2.....;双重散列：使用一组散列函数，第一个散列函数计算得到存储位置已经被占用，再用第二个以此类推，直到找到空闲的存储位置。装载因子：空闲槽位，表示空位的多少。 散列表的装载因子 = 填入表中的元素个数 &#47; 散列表的长度 ，装载因子越少，说明空闲位置越少，冲突越多，散列表的性能会下降。<br>-&gt;链表法<br>更加常用，更简单相比较。每个相同的元素对应的一个槽位，一个槽位对应一条链表。插入时候，通过计算函数得到槽位，然后将值插入到链表中即可。插入的时间复杂度O（1），删除一个元素时候对应的删除链表的结点。查询，删除跟链表的长度成正比O（k），而 k = n &#47;m ，散列中数据的个数，m表示散列表中的 “槽” 的个数。<br><br>课后题：<br>1、10w条url 我们通过计算hash 得到值以后对散列表的个数累加。也就是存个字典，key 是url，value是访问次数。最后通过对value 按照又大到小排序就实现了url 的排序。<br>2、散列表存储两个数组，hash 得到对应每个字符串的位置。最后遍历散列表找到里面的value是哪个就可以。","like_count":0},{"had_liked":false,"id":211671,"user_name":"默默","can_delete":false,"product_type":"c1","uid":1006635,"ip_address":"","ucode":"AF798B9D327F24","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/2b/8b771383.jpg","comment_is_top":false,"comment_ctime":1587993807,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587993807","product_id":100017301,"comment_content":"问题一：将URL作为key，存入散列表中，value为URL出现的次数，记录最大访问数K。再对hash表按value值排序，当K值比较小时，可以用桶排序，时间复杂度为O(n)，当K值比较大时，用快排，时间复杂度为O(nlogn).<br>问题二：将第一组的字符串为key放入Hash表中，遍历第二组字符串的key，如果能在hash表中找到相应的key，则说明两组字符串中存在相同的字符串，否则不存在。","like_count":0},{"had_liked":false,"id":210511,"user_name":"亢（知行合一的路上）","can_delete":false,"product_type":"c1","uid":1347013,"ip_address":"","ucode":"958AF7C96EB9E8","user_header":"https://static001.geekbang.org/account/avatar/00/14/8d/c5/898b13b4.jpg","comment_is_top":false,"comment_ctime":1587781265,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587781265","product_id":100017301,"comment_content":"    * 散列表用的是数组支持按照下标随机访问的特性，是数组的一种扩展。没有数组，就没有散列表。<br>        * 这算是微创新吗？基于已有进行改造，支持更多的功能，妙！<br>    * 避免散列冲突的成本太高了，计算量大、存储空间大，总成本很高，优化到一定程度，再继续优化，相对收益就不合算了，就可能要辅助其他的方法来解决，时间和空间复杂度都要控制住。有点像大禹治水，不是堵住，而是疏导。<br>","like_count":0},{"had_liked":false,"id":209629,"user_name":"黄金果","can_delete":false,"product_type":"c1","uid":1456586,"ip_address":"","ucode":"329811FF99F4B8","user_header":"https://static001.geekbang.org/account/avatar/00/16/39/ca/cdc58834.jpg","comment_is_top":false,"comment_ctime":1587571584,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587571584","product_id":100017301,"comment_content":"&quot;在散列表中查找元素的过程有点儿类似插入过程。我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在散列表中。 &quot;  这个是否意味着我既需要直到key, 也需要直到value, 才能判断是否找到正确的值么? 难道查询不是只通过key找value么, 不知道这段话怎么理解","like_count":0},{"had_liked":false,"id":205529,"user_name":"KID","can_delete":false,"product_type":"c1","uid":1867938,"ip_address":"","ucode":"EE80B7CA7CC2A2","user_header":"https://static001.geekbang.org/account/avatar/00/1c/80/a2/96dcd1fa.jpg","comment_is_top":false,"comment_ctime":1586664866,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586664866","product_id":100017301,"comment_content":"1、散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。<br>2、将目标数据转换成散列表的key的映射方法称为“散列函数”<br>3、散列函数计算出的值（key）称为“散列值”<br><br>散列函数设计要求<br>1、散列函数计算得到的散列值是一个非负整数；<br>2、如果 key1 = key2，那 hash(key1) == hash(key2)<br>3、如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。<br><br>解决散列冲突<br>一、开放寻址法<br>1、线性探测：如果出现冲突，重新探测空闲位置<br>2、二次探测：相比线性探测，探测步长变成原来的“二次方”<br>3、双重散列：使用一组散列函数，直到找到空闲位置<br>装载因子：表示空位的多少<br>二、链表法<br>1、每个槽都有对应一条链表，散列值相同的元素放在同槽位的链表中。时间复杂度跟链表长度k成正比，k=n&#47;m，其中 n 表示散列中数据的个数，m 表示散列表中“槽”的个数。","like_count":0},{"had_liked":false,"id":205258,"user_name":"王jojo","can_delete":false,"product_type":"c1","uid":1812840,"ip_address":"","ucode":"1ABE7FA2614F86","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/68/ec442a70.jpg","comment_is_top":false,"comment_ctime":1586577974,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586577974","product_id":100017301,"comment_content":"关于课后的第二题, 如果A中有多个字符a, B中没有字符a.按照推荐的算法,这个时候的a算是两个数组中相同的字符串么?","like_count":0},{"had_liked":false,"id":204555,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1586421179,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1586421179","product_id":100017301,"comment_content":"关于思考题：都是hash(key) = key的情况吗？","like_count":0},{"had_liked":false,"id":202942,"user_name":"孙思强","can_delete":false,"product_type":"c1","uid":1813790,"ip_address":"","ucode":"6E3F01DDFC1310","user_header":"https://static001.geekbang.org/account/avatar/00/1b/ad/1e/aeb8d6f3.jpg","comment_is_top":false,"comment_ctime":1586090273,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586090273","product_id":100017301,"comment_content":"对其中10万条数据进行hash算法求去哈希值并且以hash值为key存入hash表中，如果hash只想同的两个字符串在进行字符串比较，相同不插入，不同重新计算hash值，可以用开放寻址等等，表遍历完之后对第二个数据进行遍历计算hash值，如果之前的hash表中存在就取出值进行比较，相同则输出。遍历完之后就输出了全部的相同字符串，时间复杂度on，空间复杂度on。望指正","like_count":0},{"had_liked":false,"id":194201,"user_name":"凉人。","can_delete":false,"product_type":"c1","uid":1659177,"ip_address":"","ucode":"4DB16004A62015","user_header":"https://static001.geekbang.org/account/avatar/00/19/51/29/24739c58.jpg","comment_is_top":false,"comment_ctime":1585037221,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585037221","product_id":100017301,"comment_content":"1 看了各位大佬的解答，想讲下自己的拙见，如果用URL做Key，如果做hash那么我们就可能会产生hash冲突，那么记录的最大值，就是不太准确的。。 ","like_count":0},{"had_liked":false,"id":190342,"user_name":"SteelHuaSheng","can_delete":false,"product_type":"c1","uid":1396126,"ip_address":"","ucode":"BC8127FC5207FC","user_header":"https://static001.geekbang.org/account/avatar/00/15/4d/9e/04ec08bf.jpg","comment_is_top":false,"comment_ctime":1584630824,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584630824","product_id":100017301,"comment_content":"来历：散列表其实就是数组的一种扩展，由数组演化而来。散列表用的是数组支持按照下标随机访问数据的特性。<br>自身特点：散列函数设计很重要、无法避免散列冲突<br>适合解决的问题：快速查找类的？<br>实际应用场景：未知。。<br><br>散列思想<br>----①参赛选手的编号叫作键（key）或者关键字<br>----②把参赛编号转化为数组下标的映射方法就叫作散列函数（或“Hash 函数”、“哈希函数”）<br>----③而散列函数计算得到的值就叫作散列值（或“Hash 值”、“哈希值”、“键值”）&#47;&#47; 数组下标<br>散列表用的就是数组支持下标随机访问时间复杂度O(1)的特性。<br>我们通过散列函数把元素的键值（哈希值）映射为下标，然后将数据存储在数组中对应下标的位置。<br>当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。<br>","like_count":0},{"had_liked":false,"id":190119,"user_name":"小谢","can_delete":false,"product_type":"c1","uid":1879476,"ip_address":"","ucode":"82D54A61D2FDB9","user_header":"https://static001.geekbang.org/account/avatar/00/1c/ad/b4/e4dcd4d7.jpg","comment_is_top":false,"comment_ctime":1584604272,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584604272","product_id":100017301,"comment_content":"1.散列表的由来:数组的一种拓展<br>2.散列表的定义:散列函数设计和散列冲突的解决方法<br>3.散列冲突的解决方法(1)开放寻址法:线性探测、二次探测(二次方)、双重散列(2)链表法<br>4.key——&gt;hash(key)——&gt;散列值——&gt;数组下标——&gt;存储数据","like_count":0},{"had_liked":false,"id":189094,"user_name":"chenzesam","can_delete":false,"product_type":"c1","uid":1045011,"ip_address":"","ucode":"34E76BB9C7618D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f2/13/3ee5a9b4.jpg","comment_is_top":false,"comment_ctime":1584455196,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584455196","product_id":100017301,"comment_content":"学到了😁","like_count":0},{"had_liked":false,"id":188398,"user_name":"谭方敏","can_delete":false,"product_type":"c1","uid":1710960,"ip_address":"","ucode":"728DC7ECB7C902","user_header":"https://static001.geekbang.org/account/avatar/00/1a/1b/70/547042ee.jpg","comment_is_top":false,"comment_ctime":1584349398,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584349398","product_id":100017301,"comment_content":"散列思想：<br>散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。<br>散列的概念，键&#47;关键字，散列函数，散列值。<br>散列函数：<br>hash(key)，其中key表示元素的键值，hash(key)的值表示经过散列函数计算得到的散列值。<br>该如何构造散列函数呢？我总结了三点散列函数设计的基本要求：<br>1）散列函数计算得到的散列值是一个非负整数;<br>2）如果key1 = key2，那hash(key1) == hash(key2)。<br>3）如果key1不等于key2，那hash(key1) 不等于hash（key2）。<br><br>解决散列冲突的办法有开放地址法（open addressing）和链表法（chaining）。<br>开放地址法<br>线性探测：当我们往散列表中插入数据时，如果某个数据经过散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。<br><br>线性探测法其实存在很大问题，当散列表插入的数据越来越多时，散列冲突发生的可能性会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久。<br><br>除了线性探测之外，还有二次探测和双重散列两种做法。<br><br>二次探测：类似于线性探测，线性探测每次探测长度为1，探测的下标序列就是hash(key)+0，hash(key)+1，hash(key)+2，而二次探测的步长就变成了原来的二次方，也就是hash(key)+0^2，hash(key)+1^2，hash(key)+2^2。<br><br>双重散列，意思就是不仅要使用一个散列函数。我们使用一组散列函数hash1(key)，hash2(key)，hash3(key)。。。。我们先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。<br><br>散列表的装载因子=填入表中的元素个数&#47;散列表的长度<br>装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。<br><br>链表法<br>在散列表中，每个桶(bucket)或者槽(slot)会对应一条链表，所有散列值相同的元素我们都放到相同槽对应的链表中。<br><br>对于散列比较均匀的散列函数来说，理论上讲，链表长度k=n&#47;m，其中n表示散列中数据的个数，m表示散列表中槽的个数。<br><br>10万条URL访问日志，建立以url为key，访问次数为value的散列表，之后通过url找到对应的访问次数进行排序。<br><br>可以针对两个10万字符数组建立散列表。key为字符串. value为出现次数，之后用一个数组的元素去匹配。。。。<br><br><br>","like_count":0},{"had_liked":false,"id":187615,"user_name":"不知","can_delete":false,"product_type":"c1","uid":1803488,"ip_address":"","ucode":"A2ECBFE43ACDAB","user_header":"https://static001.geekbang.org/account/avatar/00/1b/84/e0/cdb6de57.jpg","comment_is_top":false,"comment_ctime":1584172423,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584172423","product_id":100017301,"comment_content":"散列函数<br>散列冲突:开放寻址,链表法<br>","like_count":0},{"had_liked":false,"id":187614,"user_name":"不知","can_delete":false,"product_type":"c1","uid":1803488,"ip_address":"","ucode":"A2ECBFE43ACDAB","user_header":"https://static001.geekbang.org/account/avatar/00/1b/84/e0/cdb6de57.jpg","comment_is_top":false,"comment_ctime":1584172334,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584172334","product_id":100017301,"comment_content":"关于:英文单词有 20 万个左右，假设单词的平均长度是 10 个字母，平均一个单词占用 10 个字节的内存空间，那 20 万英文单词大约占 2MB 的存储空间计算 10*20w=200w个字节, 1mb字节=1024*1024约等于100w字节","like_count":0},{"had_liked":false,"id":186758,"user_name":"小菠萝🍍","can_delete":false,"product_type":"c1","uid":1686410,"ip_address":"","ucode":"DA814203C6C062","user_header":"https://static001.geekbang.org/account/avatar/00/19/bb/8a/d33d9d3f.jpg","comment_is_top":false,"comment_ctime":1583918160,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583918160","product_id":100017301,"comment_content":"第一题：先将URL作为Key，访问次数作为Value存入Hash表中，插入操作的时间复杂度为O(n)，然后根据URL取出访问次数Value进行排序；<br>第二题：将其中一个字符串数组映射到哈希表中，Key为字符串，Value可以指定为任意类型；然后遍历另外的数组，查找哈希表是否存在这个Key，如果存在即为相同的字符串","like_count":0},{"had_liked":false,"id":185115,"user_name":"hex","can_delete":false,"product_type":"c1","uid":1757301,"ip_address":"","ucode":"B983D40DCD159F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d0/75/3e034f71.jpg","comment_is_top":false,"comment_ctime":1583487557,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583487557","product_id":100017301,"comment_content":"终于有一节可以理解的了,前面的因为之前没有接触过看的晕乎乎的,原来散列表就是hash算法,hashmap的实现原理和扩容以及负载因子和老师讲的类似.","like_count":0},{"had_liked":false,"id":183890,"user_name":"起而行","can_delete":false,"product_type":"c1","uid":1131399,"ip_address":"","ucode":"4F116B0B740776","user_header":"https://static001.geekbang.org/account/avatar/00/11/43/87/7604d7a4.jpg","comment_is_top":false,"comment_ctime":1583155656,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1583155656","product_id":100017301,"comment_content":"1.将URL的内容作为key,用拉链法建立哈希表，然后利用每遇到相同的URL就插入链表，最后统计链表长度，然后排序。<br>2.用散列表存储第一个字符串数组的每个字符串，key是字符串内容，value也是字符串内容。在散列表中查找第二个字符串数组的每个元素，如果遇到相同，则在散列表中删除，建立栈，入栈<br>最后打印栈","like_count":0},{"had_liked":false,"id":180158,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1582202121,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582202121","product_id":100017301,"comment_content":"思考题1 10万条url 就算每个url100个字节 那么总共也才1M放到内存中足够 然后通过访问次数做hash值 或者放入数组 即可<br>思考题2  两个数组同时遍历 把字符串做成一个hash值 比如a数组的字符串产生的hash值 记录在a_hash当中 b数组中的字符串产生的hash值 记录在b_hash表中 每遍历一个元素 分别产生出一个hash值 先直接比较是否相同 如果是 则返回 如果不是再去对方的hash表中进行查询即可 时间复杂度O(1)","like_count":0},{"had_liked":false,"id":175368,"user_name":"程序员大天地","can_delete":false,"product_type":"c1","uid":1249001,"ip_address":"","ucode":"7A21F15FEE2D5B","user_header":"https://static001.geekbang.org/account/avatar/00/13/0e/e9/98b6ea61.jpg","comment_is_top":false,"comment_ctime":1580694831,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1580694831","product_id":100017301,"comment_content":"我有个疑问想问下，一般我们存好散列表后都是为了方便查询，用key查询相应的value，如果两个不同的key1和key2是冲突的，那么他们查到的value那不是一样的吗？","like_count":0,"discussions":[{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295387,"discussion_content":"不是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596180973,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174304,"user_name":"Geek_94adb8","can_delete":false,"product_type":"c1","uid":1638187,"ip_address":"","ucode":"B142F473E1A0B3","user_header":"","comment_is_top":false,"comment_ctime":1580130433,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580130433","product_id":100017301,"comment_content":"还记得我们刚讲的查找操作吗？在查找的时候，一旦我们通过线性探测方法，找到一个空闲位置，我们就可以认定散列表中不存在这个数据。但是，如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。本来存在的数据，会被认定为不存在。这个问题如何解决呢？<br>这一段有问题表述有问题吧！","like_count":0},{"had_liked":false,"id":173177,"user_name":"pikachu122","can_delete":false,"product_type":"c1","uid":1689365,"ip_address":"","ucode":"43FE4DBC872FFA","user_header":"https://static001.geekbang.org/account/avatar/00/19/c7/15/24bf166a.jpg","comment_is_top":false,"comment_ctime":1579447839,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579447839","product_id":100017301,"comment_content":"总结：<br>1、散列表又称为哈希表，是数组的扩展，由数组演化而来。我们用键（key，也称关键字）来标识一个数据，使用散列函数将键映射为数组下标，散列函数计算得到的值叫做散列值（也称哈希值）。<br>2、散列函数是将元素的键值转化为散列值，也就是对应数组元素下标的一个函数。散列函数的设计有三点基本要求：（1）散列值是一个非负整数（2）相同键值计算得到的散列值相同（3）不同键值计算的散列值不同。<br>3、但是实际上，第（3）点难以实现，再好的散列函数也无法完全避免散列冲突。如何解决散列冲突是另一个重要的问题。常见的解决方法有（1）开放寻址法和（2）链表法。<br>4、开放寻址法是当出现冲突时就重新找一个空的位置。如何找新的位置：（1）线性探测。逐个往下寻找，当出现空位时就把数据放在空位。（2）二次探测：步长为线性探测的二次方，从hash(key)开始依次前进1、4、9...个位置查找。（3）双重散列：使用多个散列函数，第一个散列函数冲突时使用第二个散列函数，以此类推。但开放寻址的三种方式都会导致三列表数据越来越多时冲突的可能性越来越大，极端情况下查找的时间复杂度会退化为O(n)。我们用装载因子标识空位多少。装载因子=表中元素个数&#47;散列表长度。一般我们会保证散列表的装载因子在特定值以下。<br>5、链表法就是将数组的每个下标（槽位）对应一条链表。将所有散列值相同的元素放到同一个槽位的链表中。只要通过散列函数找到槽位，再遍历对应链表搜索即可。插入的时间复杂度为O(1)，删除和查找的时间复杂度与链表长度有关，对于散列均匀的函数，为O(n&#47;m)，n为数据个数，m为槽的个数。","like_count":0},{"had_liked":false,"id":169255,"user_name":"Geek_thefuture","can_delete":false,"product_type":"c1","uid":1775559,"ip_address":"","ucode":"7100A3B76D20F0","user_header":"https://static001.geekbang.org/account/avatar/00/1b/17/c7/e62643a3.jpg","comment_is_top":false,"comment_ctime":1578301594,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578301594","product_id":100017301,"comment_content":"我很想问为啥不直接把访问次数作为hash值，这样不就直接排好序了吗。。","like_count":0},{"had_liked":false,"id":168667,"user_name":"杰瑞的Jerry","can_delete":false,"product_type":"c1","uid":1690017,"ip_address":"","ucode":"5FBF22B528B721","user_header":"https://static001.geekbang.org/account/avatar/00/19/c9/a1/24c2e54e.jpg","comment_is_top":false,"comment_ctime":1578134693,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1578134693","product_id":100017301,"comment_content":"学完本节打卡：<br><br>散列表，英文叫“Hash Table”，也叫做“哈希表”或者“Hash表”。<br>散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实是一种数组的扩展。通过散列函数把元素的键值（key）映射为下标，然后将数据存储在数组中对应下标的位置。<br><br>三点散列函数的设计要求：<br>1）散列函数计算得到的散列值是一个非负整数。<br>2）如果key1=key2，则hash（key1）=hash（key2）<br>3）如果key1≠key2，则hash（key1）≠hash（key2）<br>其中第三条比较难满足，会造成散列冲突。<br><br>解决散列冲突两种方法：开放寻址法和链表法。<br>开放寻址法：如果出现了散列冲突，就重新找一个空闲位置将其插入。<br>装载因子load factor：散列表的装载因子=填入表中的元素个数&#47;散列表的长度<br>链表法：每个桶bucket或者槽slot会对应一个链表","like_count":0},{"had_liked":false,"id":168516,"user_name":"小夏","can_delete":false,"product_type":"c1","uid":1110755,"ip_address":"","ucode":"D87444ADC28C6A","user_header":"https://static001.geekbang.org/account/avatar/00/10/f2/e3/c1a88a64.jpg","comment_is_top":false,"comment_ctime":1578102904,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578102904","product_id":100017301,"comment_content":"看了一下答案，跟我的想法差不多，但是的确没想到第一题最后排序的问题如何解决。10万数据量级的话，应该就是直接考虑快排而不是其他的排序算法了。<br>","like_count":0},{"had_liked":false,"id":168177,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1194572,"ip_address":"","ucode":"FBFAE23E8E48B7","user_header":"https://static001.geekbang.org/account/avatar/00/12/3a/4c/b6200773.jpg","comment_is_top":false,"comment_ctime":1578026496,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578026496","product_id":100017301,"comment_content":"hash(key)得到的离散值即数组下标，所以数组里会有空。那好的哈希函数就是尽量让数组填满且冲突少，所以好多哈希的最后一步计算都是对数组长度取余。🧐","like_count":0},{"had_liked":false,"id":167811,"user_name":"杨松","can_delete":false,"product_type":"c1","uid":1512517,"ip_address":"","ucode":"FB3C73BC44C94D","user_header":"https://static001.geekbang.org/account/avatar/00/17/14/45/adf079ae.jpg","comment_is_top":false,"comment_ctime":1577939340,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1577939340","product_id":100017301,"comment_content":"请教老师一个问题：文中的例子中 y通过散列函数后找到数组中对应下标为7位置，假如该位置为空闲位置，那么直接把y存储在该位置，也就是相当于把key(其实就是y)存到这个位置，我想问value是怎么存放的呢","like_count":0,"discussions":[{"author":{"id":1317847,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1b/d7/868d26ce.jpg","nickname":"songhyunmin","note":"","ucode":"D5A98668CD8532","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":357841,"discussion_content":"存的不是key，是value。key是被映射的位置结点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615879692,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1512517,"avatar":"https://static001.geekbang.org/account/avatar/00/17/14/45/adf079ae.jpg","nickname":"杨松","note":"","ucode":"FB3C73BC44C94D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1317847,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1b/d7/868d26ce.jpg","nickname":"songhyunmin","note":"","ucode":"D5A98668CD8532","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358186,"discussion_content":"哈哈，理解了，感谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615943768,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":357841,"ip_address":""},"score":358186,"extra":""}]}]},{"had_liked":false,"id":166141,"user_name":"shawguo","can_delete":false,"product_type":"c1","uid":1124753,"ip_address":"","ucode":"67AEDBDAFE3F47","user_header":"https://static001.geekbang.org/account/avatar/00/11/29/91/9813a63b.jpg","comment_is_top":false,"comment_ctime":1577408738,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577408738","product_id":100017301,"comment_content":"但是，如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。本来存在的数据，会被认定为不存在。这个问题如何解决呢？我们可以将删除的元素，特殊标记为 deleted。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测。<br>-----------------------------------------------------------------------------<br>没有理解这点？ 能否再解释下？","like_count":0},{"had_liked":false,"id":165603,"user_name":"菜头","can_delete":false,"product_type":"c1","uid":1456964,"ip_address":"","ucode":"C5E95519F9EA21","user_header":"https://static001.geekbang.org/account/avatar/00/16/3b/44/dd534c9b.jpg","comment_is_top":false,"comment_ctime":1577267233,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1577267233","product_id":100017301,"comment_content":"请问老师 我们一般如何保证散列表中有一定比例的空闲槽位？","like_count":0,"discussions":[{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295388,"discussion_content":"load factor","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596181055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163993,"user_name":"第四单元","can_delete":false,"product_type":"c1","uid":1747184,"ip_address":"","ucode":"3ED9D553E1DE17","user_header":"https://static001.geekbang.org/account/avatar/00/1a/a8/f0/529f15e9.jpg","comment_is_top":false,"comment_ctime":1576841889,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576841889","product_id":100017301,"comment_content":"请问老师，双重探测，如果所有的散列函数都没有找到空闲位置怎么把？","like_count":0},{"had_liked":false,"id":162898,"user_name":"注定非凡","can_delete":false,"product_type":"c1","uid":1113597,"ip_address":"","ucode":"80673056E131B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","comment_is_top":false,"comment_ctime":1576630031,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576630031","product_id":100017301,"comment_content":"1，word文档实现单词拼写检查，依托的就是散列表实现的。<br><br>2，散列表用的是数组，支持按照下标随机访问数据的特征。所以散列表其实是数组的一种扩展，由数组演化而来。可以说，没有数组，就没有散列表。<br><br>3，可以将比赛中选手的编号叫做关键字或键（key）。<br>把参赛编号转化为数组下标的映射方法叫作散列函数。散列函数计算得到的值就叫做散列值<br>\t<br>4，散列表用的是数组，支持按照下标随机访问，时间复杂度是O(1)。<br>1通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。<br>当按照键值查询元素时，用同样的散列函数将键值转化数组下标，从对应下标的位置取数据。<br><br>5，散列函数：<br>\t\t①：散列函数，就是一个函数，可定义为：hash(key)，key表示元素的键值，hash(key)的值表示经过散列函数计算得到的散列值。<br>\t\t②：构造散列函数的三点基本要求：<br>\t\t\t\tA：散列函数计算得到的散列值都是一个非负整数；<br>\t\t\t\tB：如果key1=key2，则hash(key1) == hash(key2)；<br>\t\t\t\tC：如果key1 &lt;&gt; key2 则hash(key1) != hash(key2)<br><br>\t\t③：第三点的要求看起来合情合理，但是真实的情况是：要想找到一个不同key对应的散列值都不一样的散列函数，几乎是不可能的。即使是业界有名的MD5，SHA，CRC等哈希算法，也无法完全避免这种散列冲突。并且数值的存储空间有限，也会加大散列冲突的概率。<br>\t\t<br>6，散列冲突：<br>\t①：解决散列冲突常用的方法：开放寻址法（open addressing）和链表法（chaining）。<br>\t<br>\t②：开放寻址法：<br>\t\t核心思想是，如果出现了hash冲突，就重新探测一个空闲位置，将其插入。<br>\t\t\tA：重新探测新的位置的方法有：线性探测（Liner Probing）。<br>》当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，就从当期位置开始，依次往后查找，看是否空闲位置，直到找到为止。<br><br>》在散列表中查找元素的过程有点类似插入过程。通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。若相等，则说明就是要找的元素；否则就顺序往后依次查找。如果遍历到数组中空闲位置，还没找到，就说明要查找的元素并没有在散列表中。<br>\t\t\t\t<br>》散列表和数组相同，不仅支持插入，查找，还支持删除。但对于使用线性探测法解决冲突的散列表，删除操作稍微有些特别。不能单纯地把要删除的元素置为空<br><br>》通过线性探测方法，找到一个空闲位置，可认定散列表中不存在这个数据。如果将这个空闲位置删除了，就会导致这个算法失效。本存在的数据，会被认为不存在。<br><br>》所以将删除的元素，标记为deleted。当线性探测查找的时候，遇到标记为deleted空间，不停下来，继续往下探测。<br><br>》线性探测法存在很大问题，当散列表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久。<br><br>B：二次探测（Quadratic probing）和双重散列（Double hashing）<br>》所谓二次探测，跟线性探测很像，但他的探测下标序列是hash(key)+0，hash（key）+1^2，hash(key)+2^2……<br>》所谓双重散列，使用一组散列函数，先用第一个散列函数，如果计算的位置被占用，就在使用第二个散列函数，依次类推，知道找打空闲的存储位置。<br>》装载因子：当散列表中空闲位置不多时，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，会尽可能保证散列表中有一定比例的空闲槽位。用装载因子来表示空位多少。<br>计算公式：散列表的装载因子 = 填入表中的元素个数 &#47; 散列表的长度<br>装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。<br><br>\t③链表法<br>\t\t链表法是一种更加常用的散列冲突解决办法，相比开发寻址法，他要简单很多。<br>》在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。<br>》当插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入对应链表中即可，所以插入的时间复杂度是O(1)。<br>》当查找，删除一个元素时，同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除。时间复杂度跟链表的长度k成正比，也就是O(k)。对于散列的比较均匀的散列函数来说，理论上讲，k=n&#47;m，其中n表示散列中数据的个数，m表示散列表中“槽”的个数。<br>","like_count":0},{"had_liked":false,"id":161307,"user_name":"Jun","can_delete":false,"product_type":"c1","uid":1120678,"ip_address":"","ucode":"0FAB76D99153ED","user_header":"https://static001.geekbang.org/account/avatar/00/11/19/a6/7ae63d7e.jpg","comment_is_top":false,"comment_ctime":1576172811,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576172811","product_id":100017301,"comment_content":"思考题：<br>1. 用散列表对url访问计数，然后按值排序<br>2. 将一个数组的字符串写入散列表，另一个数组遍历并查询散列表","like_count":0},{"had_liked":false,"id":161083,"user_name":"SteveYang","can_delete":false,"product_type":"c1","uid":1754829,"ip_address":"","ucode":"C42BCA4F40A9EF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKCbnOvEatUN4ysE2cl6zJNoAJVXXuQVhicQ1jxh6Z2Towrmmc1I6PndaicuQQ0RyyJPyJQicv4tSib9Q/132","comment_is_top":false,"comment_ctime":1576115994,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576115994","product_id":100017301,"comment_content":"1.url访问次数排序：先分组再排序，用url计算key，访问次数为value，存入散列表，然后进行排序。<br>2.找出两个字符串数组相等的字符串：用字符串计算key，出现次数作为value，遍历其中一个数组存入散列表，遍历另外一个数组，取散列表判断是否存在。","like_count":0},{"had_liked":false,"id":161080,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1576115596,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576115596","product_id":100017301,"comment_content":"散列表是数组的推广，键值不再局限于范围小于总数的整数，可以是任意整数和其他类型，可以快速根据key找到对应的元素，删除也很方便，实现的关键在于在引入了哈希函数，建立了存储下标和key之间映射关系，key的范围远大于下标取值范围。哈希函数没有反函数，因为下标不能唯一映射于key。所以必须引入冲突解决机制。常用的有开放地址法和链表法。开放地址法把存储区域看成是映射函数值为起点的数组，遇到冲突的时候依次查找，这样删除的时候必须区分是没有数据还是删掉的两种情况，因为后者处理提供数据外，还起到了链接前后值的作用。链表法比较简单，用一个链表处理所有冲突，得到链表头是常数复杂度，链表内线性复杂度。","like_count":0},{"had_liked":false,"id":161060,"user_name":"大海","can_delete":false,"product_type":"c1","uid":1001446,"ip_address":"","ucode":"20913D0265971B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/47/e6/67b0b711.jpg","comment_is_top":false,"comment_ctime":1576111569,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576111569","product_id":100017301,"comment_content":"寻找相同字符串<br>构建散列表，字符串为key。然后遍历第二个数组，判断字符串是否在散列表中。","like_count":0},{"had_liked":false,"id":160404,"user_name":"港","can_delete":false,"product_type":"c1","uid":1122464,"ip_address":"","ucode":"35931FC6198180","user_header":"https://static001.geekbang.org/account/avatar/00/11/20/a0/1fca96c0.jpg","comment_is_top":false,"comment_ctime":1575945369,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575945369","product_id":100017301,"comment_content":"1. 通过哈希表统计每个URL的访问次数，之后使用快速排序或者归并排序对URL按访问次序排序<br>2. 对字符串数组A的字符串建立哈希表，然后使用同样的哈希函数对字符串数组中的字符串进行哈希，寻找hash表中是否存在。","like_count":0},{"had_liked":false,"id":159966,"user_name":"梦想的优惠券","can_delete":false,"product_type":"c1","uid":1257418,"ip_address":"","ucode":"D3B44F6C618CA7","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/ca/cbce6e94.jpg","comment_is_top":false,"comment_ctime":1575852456,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1575852456","product_id":100017301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":158960,"user_name":"渴望做梦","can_delete":false,"product_type":"c1","uid":1398219,"ip_address":"","ucode":"9EB47530A69C91","user_header":"https://static001.geekbang.org/account/avatar/00/15/55/cb/1efe460a.jpg","comment_is_top":false,"comment_ctime":1575507230,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575507230","product_id":100017301,"comment_content":"老师，js里面有对象这种类型，也可以通过key去实现随机访问，比如像这样：<br>const obj＝{<br>    key1：1,<br>    key2：2<br>}<br>我可以通过obj[key1]访问到值1<br>这种对象类型是怎么实现的呢，难道底层也是通过散列表实现的吗？","like_count":0},{"had_liked":false,"id":157005,"user_name":"minsky","can_delete":false,"product_type":"c1","uid":1351075,"ip_address":"","ucode":"7296ECA064E89B","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/a3/79fc9017.jpg","comment_is_top":false,"comment_ctime":1575011672,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1575011672","product_id":100017301,"comment_content":"有一个疑问，如果hash冲突采用开放寻址法，那么在获取元素的时候怎么知道第几次寻址得到的元素才是目标元素？","like_count":0,"discussions":[{"author":{"id":1351075,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a3/79fc9017.jpg","nickname":"minsky","note":"","ucode":"7296ECA064E89B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":83944,"discussion_content":"原来开放寻址法每个槽位都存储着一个节点，节点包含元素的值以及下一个节点的位置，所以获取元素时会从首节点类似链表逐个遍历当元素值相同才认为找到了。这种解决hash冲突的方法规定了每个槽位只能存一个元素，如果加载因子比较大，那么每次读取时都可能要做较长的遍历。因此适合加载因子小的场合","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576475082,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154273,"user_name":"握不住手中沙","can_delete":false,"product_type":"c1","uid":1097132,"ip_address":"","ucode":"F194E47C4D42C9","user_header":"https://static001.geekbang.org/account/avatar/00/10/bd/ac/49494ed8.jpg","comment_is_top":false,"comment_ctime":1574401604,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574401604","product_id":100017301,"comment_content":"思考题：<br>1、遍历十万条数据，用Hash表用来记录URL访问次数，URL为Key，访问次数为Value，然后根据访问次数进行一次排序即可（快排）<br>2、遍历其中任一数组，将数组中的字符串用Hash表记录下来，字符串为Key，出现次数为Value，然后再遍历另外一个数组中的字符串，通过字符串在Hash表中取值，判断是否存在该字符串的记录","like_count":0},{"had_liked":false,"id":153865,"user_name":"Sun Fei","can_delete":false,"product_type":"c1","uid":1032631,"ip_address":"","ucode":"092EC0992050BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c1/b7/57f153f6.jpg","comment_is_top":false,"comment_ctime":1574322140,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574322140","product_id":100017301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":149828,"user_name":"王加武","can_delete":false,"product_type":"c1","uid":1665471,"ip_address":"","ucode":"DDCFE578C6C428","user_header":"https://static001.geekbang.org/account/avatar/00/19/69/bf/50a824a4.jpg","comment_is_top":false,"comment_ctime":1573396327,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573396327","product_id":100017301,"comment_content":"1，如何给10万条URL排序？<br>我的思路是这样的——<br>借助散列表，既然散列表可以通过关键字key来查找相应的信息，那么我们就把URL作为key存放到散列表中，然后把访问的次数count依次排序（可以使用快速排序），从大到小（从大到小的排序方便查找，提高性能，因为第一个就是），这里把key存放在数组中，把访问次数存放在链表中，这样即可！<br>","like_count":0},{"had_liked":false,"id":149383,"user_name":"Geek_89ef2a","can_delete":false,"product_type":"c1","uid":1693410,"ip_address":"","ucode":"82CD3E925B4D9A","user_header":"","comment_is_top":false,"comment_ctime":1573205762,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573205762","product_id":100017301,"comment_content":"&lt;如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。本来存在的数据，会被认定为不存在&gt;<br><br>对这句话的理解：首先,(空闲位置是我们后来删除的)，说明在查找之前这个空闲位置是有数据的。其次，只要是通过线性探测查找的方法(如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在散列表中)这种规律，那么如果要查找的值正好在这个空闲位置的后面，就会导致不再往后面查找，所以会有(导致原来的查找算法失效,本来存在的数据，会被认定为不存在)。","like_count":0},{"had_liked":false,"id":148921,"user_name":"追梦","can_delete":false,"product_type":"c1","uid":1183831,"ip_address":"","ucode":"54C6E76E8FE033","user_header":"https://static001.geekbang.org/account/avatar/00/12/10/57/1adfd4f7.jpg","comment_is_top":false,"comment_ctime":1573109297,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573109297","product_id":100017301,"comment_content":"老师，还是不太明白，hash值冲突的怎么进行删除和查询，我拿着key值去删除，不同的key对应的一样的hash值，即使存在链表中，但我怎么知道我到底应该删除哪一个呢","like_count":0},{"had_liked":false,"id":147694,"user_name":"企鹅","can_delete":false,"product_type":"c1","uid":1498369,"ip_address":"","ucode":"AE29B98E5B4497","user_header":"https://static001.geekbang.org/account/avatar/00/16/dd/01/803f3750.jpg","comment_is_top":false,"comment_ctime":1572879528,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572879528","product_id":100017301,"comment_content":"散列表是基于数组，文中提到的都是关键字的散列值的存储，那关键字对应的值是怎么存储的？","like_count":0},{"had_liked":false,"id":146401,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1572513929,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572513929","product_id":100017301,"comment_content":"课后第一题的意思是否是有10万条记录，一条记录表示访问一次？按这个思路：<br>首先遍历10万条记录，按照url为key，value是访问次数（每次遇到相同url，次数累加1）存入Hash表。遍历完，则hash表中是各个url和对应的访问次数。然后获取key列表和value列表，如果访问次数的范围不大，按照桶排序或计数排序对value进行排序，排序时，同步移动key。最终得到url按value排序的有序集合。","like_count":0},{"had_liked":false,"id":145793,"user_name":"Mr.Fu","can_delete":false,"product_type":"c1","uid":1613254,"ip_address":"","ucode":"F1E4304C5CDE52","user_header":"https://static001.geekbang.org/account/avatar/00/18/9d/c6/a72db706.jpg","comment_is_top":false,"comment_ctime":1572366878,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572366878","product_id":100017301,"comment_content":"一散列表基本信息:核心是散列函数设计和散列冲突解决。<br>散列表利用的是数组支持按照下标随机访问元素(时间复杂度是 O(1))的特性，通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当按照键值查询元素时，用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。<br><br>散列函数设计的三点要求：<br>①散列函数计算得到的散列值是一个非负整数；<br>②如果 key1 = key2，那 hash(key1) == hash(key2)；<br>③如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)，此时可能发生散列冲突。<br>常用的散列冲突解决方法：开放寻址法和链表法<br>①开放寻址法<br>(1)线性探测法：<br>[1]线性探测之查找：通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置(非delteed)，还没有找到，就说明要查找的元素并没有在散列表中。<br>[2]线性探测之插入：当往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。<br>[3]线性探测之删除：查找时找到一个空闲位置认定散列表中不存在 于 空闲位置是后来删除得到的 相冲突，所以将删除的元素，特殊标记为 deleted。<br><br>(2)二次探测法：线性探测每次探测的步长是 1，那它探测的下标序列就是 hash(key)+0，hash(key)+1，hash(key)+2……而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 hash(key)+0，hash(key)+1^2，hash(key)+2^2……<br>(3)双重散列法：不仅要使用一个散列函数。使用一组散列函数 hash1(key)，hash2(key)，hash3(key)……先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置<br>(4)装载因子：当散列表中空闲位置不多的时候，散列冲突的概率就会增加，为了保证散列表中有一定比例的空闲槽位，用装载因子来表示空位的多少。装载因子=填入表中的元素个数&#47;散列表的长度。装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。<br>②链表法:在散列表中，每个“桶”或者“槽”会对应一条链表，所有散列值相同的元素都放到相同槽位对应的链表中。<br><br>(1)链表法之插入：只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入的时间复杂度是 O(1)<br>(2)链表法之查找和删除：当查找或删除一个元素时，同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除；时间复杂度跟链表的长度 k 成正比，即 O(k)。对于散列比较均匀的散列函数来说，理论上讲，k=n&#47;m，其中 n 表示散列中数据的个数，m 表示散列表中“槽”的个数。<br><br>N.例子<br>Word中拼写检查的实现：常用的英文单词有 20 万个左右，假设单词的平均长度是 10 个字母，平均一个单词占用 10 个字节的内存空间，那 20 万英文单词大约占 2MB 的存储空间，就算放大 10 倍也就是 20MB，这个大小可以放在内存里面。所以可以用散列表来存储整个英文单词词典。当用户输入某个英文单词时，拿用户输入的单词去散列表中查找。如果查到，则说明拼写正确；如果没有查到，则说明拼写可能有误，给予提示。<br>假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序：遍历 10 万条数据，以 URL 为 key，访问次数为 value，存入散列表，同时记录下访问次数的最大值 K，时间复杂度 O(n)。如果 K 不是很大，可以使用桶排序，时间复杂度 O(n)。如果 K 非常大（比如大于 10 万），就使用快速排序，复杂度 O(nlogn)。<br>有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串：以第一个字符串数组构建散列表，key 为字符串，value 为出现次数。再遍历第二个字符串数组，以字符串为 key 在散列表中查找，如果 value 大于零，说明存在相同字符串。时间复杂度 O(n)。","like_count":0},{"had_liked":false,"id":145451,"user_name":"momo","can_delete":false,"product_type":"c1","uid":1711813,"ip_address":"","ucode":"EBC2C886E5A222","user_header":"https://static001.geekbang.org/account/avatar/00/1a/1e/c5/4e640126.jpg","comment_is_top":false,"comment_ctime":1572274889,"is_pvip":false,"replies":[{"id":"56122","content":"嗯嗯 多谢提醒","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1572301594,"ip_address":"","comment_id":145451,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572274889","product_id":100017301,"comment_content":"那啥，写n的幂次，不妨加个尖角符号，看的更清楚","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472405,"discussion_content":"嗯嗯 多谢提醒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572301594,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143547,"user_name":"学个球","can_delete":false,"product_type":"c1","uid":1019725,"ip_address":"","ucode":"7343F3C0CA981D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8f/4d/65fb45e6.jpg","comment_is_top":false,"comment_ctime":1571729601,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571729601","product_id":100017301,"comment_content":"对于装载因子的公式有一些疑惑<br>    对于使用了链表法的散列表，公式中“填入散列表中的元素”的个数包括拉出去的链表中的元素吗？还是指数组下标中被占用的元素个数？<br>    望解答，谢谢。","like_count":0},{"had_liked":false,"id":142891,"user_name":"小喵喵","can_delete":false,"product_type":"c1","uid":1062444,"ip_address":"","ucode":"FDBBB2A59DB8B6","user_header":"https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg","comment_is_top":false,"comment_ctime":1571576963,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571576963","product_id":100017301,"comment_content":"散列表的装载因子 = 填入表中的元素个数 &#47; 散列表的长度，这个计算公司是如何能算出装载因子大于1的case呢？请老师举例说明一下。谢谢。<br>","like_count":0},{"had_liked":false,"id":134722,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1568903978,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568903978","product_id":100017301,"comment_content":"1 遍历url数据集，存储到散列表，其中key是hash(url)，开链法，链表中存储对应url出现的次数。然后根据出现次数对url进行快排<br>2 遍历数组1，将字符串存入散列表。然后遍历数组2，判断是否在散列表中，如果在，说明字符串在数组1和数组2中同时存在","like_count":0},{"had_liked":false,"id":134711,"user_name":"huangzehao","can_delete":false,"product_type":"c1","uid":1386934,"ip_address":"","ucode":"8A6530D82B48E3","user_header":"https://wx.qlogo.cn/mmopen/vi_32/jqDSNBHmPbPGayjtXrm9iciccSKbfg6g8oMgXc147jib4HjoUK1RINorZYfBuiaQBibqJIrQRVG77PKGS0dW5PVAAicw/132","comment_is_top":false,"comment_ctime":1568900271,"is_pvip":false,"replies":[{"id":"51692","content":"查找的时候拿散列表中的数据跟要查找的数据对比的，如果相同就是要查找的数据","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1568933878,"ip_address":"","comment_id":134711,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568900271","product_id":100017301,"comment_content":"老师，你好，有个问题想请教一下你：<br><br>双重散列可以通过多个散列函数hash1(key)，hash2(key)，hash3(key)……可以获取到空闲的存储位置并插入数据，但是查找数据要如何查找呢？如何判断是通过哪个hash函数找到目标数据是否存在呢？假设我是通过hash3函数插入数据的，但是我查找的时候是依据hash1(key)，hash2(key)，hash3(key)…… 里面的哪个函数为准呢？<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467872,"discussion_content":"查找的时候拿散列表中的数据跟要查找的数据对比的，如果相同就是要查找的数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568933878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133650,"user_name":"Hwan","can_delete":false,"product_type":"c1","uid":1205627,"ip_address":"","ucode":"A728C6790511BD","user_header":"https://static001.geekbang.org/account/avatar/00/12/65/7b/66b9befd.jpg","comment_is_top":false,"comment_ctime":1568628209,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568628209","product_id":100017301,"comment_content":"1. 10万条数据，可以先遍历一遍，以url为key, 访问次数为value, 存进一个hash表里面，这样就可以避免了字符串的比较了，然后再按照访问次数排序，具体可以采用快排或者桶排序之类的；<br>2.遍历其中一个一个数组，然后存在hash表，然后再遍历另外一个，遍历过程中去hash表里面判断是否存在，最后返回在hash表中存在的所有字符串","like_count":0},{"had_liked":false,"id":129203,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1567062403,"is_pvip":false,"replies":[{"id":"48484","content":"你说的释放是什么含义呢？标记为deleted之后，可以再被其他数据占用的。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1567378022,"ip_address":"","comment_id":129203,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1567062403","product_id":100017301,"comment_content":"开放地址法在删除元素的时候标记deleted，如果一直不释放这个deleted空间是不是很浪费内存啊<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465329,"discussion_content":"你说的释放是什么含义呢？标记为deleted之后，可以再被其他数据占用的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567378022,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1127115,"avatar":"https://static001.geekbang.org/account/avatar/00/11/32/cb/cece03fc.jpg","nickname":"GeekYa","note":"","ucode":"4B30219E8E7A97","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46033,"discussion_content":"结合文中示意图可以更好的理解- -!","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573113215,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1127115,"avatar":"https://static001.geekbang.org/account/avatar/00/11/32/cb/cece03fc.jpg","nickname":"GeekYa","note":"","ucode":"4B30219E8E7A97","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46031,"discussion_content":"老师的描述有点不够清晰……这里对老师的描述进行补充，看看是否能理解：在查找的时候，一旦我们通过线性探测方法，找到一个空闲位置，我们就可以认定散列表中不存在这个数据，如果单纯地把要删除的元素设置为空，如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。本来存在(这个空闲位置后面)的数据，会(因为这个空闲位置,阻断了往后找数据的操作,所以要找的数据)被认定为不存在。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573113062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128837,"user_name":"恒","can_delete":false,"product_type":"c1","uid":1225966,"ip_address":"","ucode":"68F64BF1460D8C","user_header":"https://static001.geekbang.org/account/avatar/00/12/b4/ee/c3ff8615.jpg","comment_is_top":false,"comment_ctime":1566971796,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566971796","product_id":100017301,"comment_content":"更正下，在些经典教材中，二次探测的步长是：1², -1²,  2², -2²...","like_count":0},{"had_liked":false,"id":124905,"user_name":"启炜","can_delete":false,"product_type":"c1","uid":1606147,"ip_address":"","ucode":"0C3DAE062F8D56","user_header":"https://static001.geekbang.org/account/avatar/00/18/82/03/adfccf66.jpg","comment_is_top":false,"comment_ctime":1566012614,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566012614","product_id":100017301,"comment_content":"文中讲到【线性探测】的删除操作不能直接置空，需要做特殊标记【deleted】，感觉【二次探测】和【双重散列】都是这样的，删除的时候不能直接置空，需要做特殊标记【deleted】，这样看来，其实整个【开放寻址法】都是这样的。","like_count":0},{"had_liked":false,"id":124638,"user_name":"小先生","can_delete":false,"product_type":"c1","uid":1055214,"ip_address":"","ucode":"E5F2052E0323C0","user_header":"https://static001.geekbang.org/account/avatar/00/10/19/ee/e395a35e.jpg","comment_is_top":false,"comment_ctime":1565934564,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565934564","product_id":100017301,"comment_content":"在查找的时候，一旦我们通过线性探测方法，找到一个空闲位置，我们就可以认定散列表中不存在这个数据。但是，如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。本来存在的数据，会被认定为不存在。这个问题如何解决呢？<br><br>删除了这个元素之后，不就应该找不到吗？请问这段话想要表达的意思是什么？","like_count":0},{"had_liked":false,"id":121989,"user_name":"渭河","can_delete":false,"product_type":"c1","uid":1376031,"ip_address":"","ucode":"8983C4DFAED2A6","user_header":"https://static001.geekbang.org/account/avatar/00/14/ff/1f/4f927519.jpg","comment_is_top":false,"comment_ctime":1565265350,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565265350","product_id":100017301,"comment_content":"github js 实现的散列表 有bug hash.put(&#39;3&#39;, &#39;3&#39;); hash.put(&#39;cd&#39;, &#39;cd&#39;); 后者会覆盖前者","like_count":0},{"had_liked":false,"id":121177,"user_name":"孙旗","can_delete":false,"product_type":"c1","uid":1554968,"ip_address":"","ucode":"DCED9A616139BE","user_header":"https://static001.geekbang.org/account/avatar/00/17/ba/18/0990c1d9.jpg","comment_is_top":false,"comment_ctime":1565071275,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565071275","product_id":100017301,"comment_content":"关于找到相同字符串的问题，其实很像数据库中的join问题，而现在join操作通常通过hash join 或者merge join完成。hash join就是建立哈希表，很多人在留言中提到了类似想法，而merge join就是利用一种类似merge sort的手段来完成join，将两个表按照条件合并成一个。merge join一点很明显的优势是join完成后的结果自然的sort了，可以为之后的操作提供更好的起始条件。merge join在内存访问和运算上可以并行，有效利用硬件性能，在数据量大的数据库上用的很多。","like_count":0},{"had_liked":false,"id":117970,"user_name":"被过去推开","can_delete":false,"product_type":"c1","uid":1276690,"ip_address":"","ucode":"8B4F34FE93FD5B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Cib5umA0W17N9pichI08pnrXAExdbyh7AVzH4nEhD6KN3FXuELk4LJJuqUPPD7xmIy9nq5Hjbgnzic7sVZG5BKiaUQ/132","comment_is_top":false,"comment_ctime":1564200649,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564200649","product_id":100017301,"comment_content":"最近处理的一个业务问题和思考题类似，给出一批订单编号，去MySQL数据库查出数据，返回列表A。将这批订单编号变为一个散列表hashMap&lt;String,Object&gt;，键为订单编号，然后遍历列表A过程中，通过订单编号取出散列表的值，如果没有数据，说明这条订单编号在数据库中不存在。时间复杂度是O(1)。","like_count":0},{"had_liked":false,"id":117727,"user_name":"山头","can_delete":false,"product_type":"c1","uid":1610142,"ip_address":"","ucode":"9CD45A7966F37E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/1R7lHGBvwPTVfb3BAQrPX3AhsYWnXyicbUJUYDgWagWxMGTnsNFvKibzeJ8v7fF2vJLQGf2EY9dV07rnn5Mhv9Uw/132","comment_is_top":false,"comment_ctime":1564120131,"is_pvip":false,"replies":[{"id":"43282","content":"下标就是散列值。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1564266228,"ip_address":"","comment_id":117727,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1564120131","product_id":100017301,"comment_content":"散列函数中的数组下标和散列值有啥区别呢","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460097,"discussion_content":"下标就是散列值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564266228,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117722,"user_name":"山头","can_delete":false,"product_type":"c1","uid":1610142,"ip_address":"","ucode":"9CD45A7966F37E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/1R7lHGBvwPTVfb3BAQrPX3AhsYWnXyicbUJUYDgWagWxMGTnsNFvKibzeJ8v7fF2vJLQGf2EY9dV07rnn5Mhv9Uw/132","comment_is_top":false,"comment_ctime":1564119369,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564119369","product_id":100017301,"comment_content":"其中，参赛选手的编号我们叫作键（key）或者关键字。我们用它来标识一个选手。我们把参赛编号转化为数组下标的映射方法就叫作散列函数（或“Hash 函数”“哈希函数”），而散列函数计算得到的值就叫作散列值（或“Hash 值”“哈希值”）。","like_count":0},{"had_liked":false,"id":117502,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1564062971,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564062971","product_id":100017301,"comment_content":"学习了，很不错。","like_count":0},{"had_liked":false,"id":113971,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1563196303,"is_pvip":false,"replies":[{"id":"41572","content":"跟查找同样的方法来遍历，直到某个位置存储的元素为空。还有要提醒一下就是，散列表中还要存储原值的。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1563233978,"ip_address":"","comment_id":113971,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1563196303","product_id":100017301,"comment_content":"老师，二次探测和双重探测由于可能由于散列冲突的原因，在经过多次探测才找到了空闲位置插入数据，那么想删除刚才这个数据，要怎么根据二次探测和双重探测来确定位置呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458460,"discussion_content":"跟查找同样的方法来遍历，直到某个位置存储的元素为空。还有要提醒一下就是，散列表中还要存储原值的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563233978,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295394,"discussion_content":"找到一个位置数据为空并且没有删除标记才证明找不到,数据为空但有删除标记就继续向后查找","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596181439,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":112400,"user_name":"🍀吴昊","can_delete":false,"product_type":"c1","uid":1181559,"ip_address":"","ucode":"5A0447E0B9240D","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/77/bff4af27.jpg","comment_is_top":false,"comment_ctime":1562728940,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562728940","product_id":100017301,"comment_content":"开放寻址法删除元素解决办法很浪费空间，可以参考ThreadLocalMap中实现。将元素节点情况，并查找后续节点冲突的节点，替换之","like_count":0},{"had_liked":false,"id":107363,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1561518999,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561518999","product_id":100017301,"comment_content":"散列表是数组的一种扩展，其利用数组支持按下标以o(1)时间复杂度随机访问的特性，存储时通过散列函数将元素的键值映射为下标，再把数据存储在数组中对应下标的位置并存储，而访问时利用相同的散列函数做同样的操作找到下标位置并取出<br>散列冲突的解决方案：<br><br>1. 开放寻址法（线性探测法 &amp; 二次探测 &amp; 双重散列）<br>2. 链表法","like_count":0},{"had_liked":false,"id":106730,"user_name":"Hanan","can_delete":false,"product_type":"c1","uid":1529060,"ip_address":"","ucode":"A2DE97818F5E02","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLcKGqKcJNW6yLbqOwutsMJH67usyOlHyCX2pSgTQbQS4jndGbvbBsCVqM8n5Un1iasWouqMjUKL0Q/132","comment_is_top":false,"comment_ctime":1561380145,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561380145","product_id":100017301,"comment_content":"课后思考题1 对应leetcode里面的451. 根据字符出现频率排序","like_count":0},{"had_liked":false,"id":104827,"user_name":"苦行僧","can_delete":false,"product_type":"c1","uid":1055334,"ip_address":"","ucode":"726024A9A9CF44","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/66/2d9db9ed.jpg","comment_is_top":false,"comment_ctime":1560849101,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560849101","product_id":100017301,"comment_content":"哈希冲突即是值冲突","like_count":0},{"had_liked":false,"id":102416,"user_name":"William","can_delete":false,"product_type":"c1","uid":1346215,"ip_address":"","ucode":"55F5D9DEE485B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","comment_is_top":false,"comment_ctime":1560217804,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1560217804","product_id":100017301,"comment_content":"key -value . <br>查找value ,  不仅仅只有hash(key),还要判断key是否相同. <br>hashmap内部也是这么判断的.所以虽然是hash(key) 相同了, 但是还有key这个作为条件,来寻找value.","like_count":0},{"had_liked":false,"id":102414,"user_name":"William","can_delete":false,"product_type":"c1","uid":1346215,"ip_address":"","ucode":"55F5D9DEE485B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","comment_is_top":false,"comment_ctime":1560217658,"is_pvip":true,"replies":[{"id":"37271","content":"两次hash都计算一下key，一个是key1，一个是key2，拿这两个key都去查一下","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1560382050,"ip_address":"","comment_id":102414,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560217658","product_id":100017301,"comment_content":"同问:<br>1. 关于开放空间的散列冲突：既然存在散列冲突问题，插入时可以通过分配新的 key 来插入存在散列冲突的元素，那么在访问时又是如何解决散列冲突的呢？比如有两个键值对 {key1: val1}, {key2: val2} 它们的 key 在生成时是冲突的，key2 经过重新分配，现在访问 {key2: val2} 时应该如何通过hash函数得到正确的 key2 呢？假如删除 {key1: val1}，现在要访问 {key2: val2} ，那么执行 hash(string) 后得到的 key1 并不存在，应该怎么实现对 {key2: val2} 的正确访问呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453411,"discussion_content":"两次hash都计算一下key，一个是key1，一个是key2，拿这两个key都去查一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560382050,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101519,"user_name":"goodxwp","can_delete":false,"product_type":"c1","uid":1245398,"ip_address":"","ucode":"B705DAC523B2ED","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKDY9bVLK3oyLmF6X2OnUZAzwSNVpS7XPxOQg84XJdvhr6SfvPe5uhYvzSf8ycIokfiapAJ8lvPxHA/132","comment_is_top":false,"comment_ctime":1559836891,"is_pvip":false,"replies":[{"id":"36773","content":"hash函数的设计，我们没有深入的讲，只讲了大概的理论。<br>hash函数计算出来的下标并不一定是连续的呢","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1560122301,"ip_address":"","comment_id":101519,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559836891","product_id":100017301,"comment_content":"请教下老师，文中的英文单词例子，原理都比较简单，但是请问这个例子的hash函数怎么设计呢？你在文中计算内存的时候，默认是hash函数计算出来的数组下标是连续的，求教怎么做到连续","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452995,"discussion_content":"hash函数的设计，我们没有深入的讲，只讲了大概的理论。\nhash函数计算出来的下标并不一定是连续的呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560122301,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":100065,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1559433090,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559433090","product_id":100017301,"comment_content":"对于思考题1<br>散列函数为访问次数的顺序，<br>我们以访问次数为key，URL为value，以链式存储解决冲突；<br>数据放入数据的过程就已经排序完成，时间复杂度为O（n）","like_count":0},{"had_liked":false,"id":98031,"user_name":"咸鱼与果汁","can_delete":false,"product_type":"c1","uid":1283861,"ip_address":"","ucode":"F79383599ACB02","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoRyUPicEMqGsbsMicHPuvwM8nibfgK8Yt0AibAGUmnic7rLF4zUZ4dBj4ialYz54fOD6sURKwuJIWBNjhg/132","comment_is_top":false,"comment_ctime":1558878634,"is_pvip":false,"replies":[{"id":"35213","content":"这个要具体来看了。可以不扩容，再进行三次探测","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1559007041,"ip_address":"","comment_id":98031,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1558878634","product_id":100017301,"comment_content":"请问如果二次探测也冲突了，但是当前装载因子还没超过设定值会怎么做，会扩容吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451525,"discussion_content":"这个要具体来看了。可以不扩容，再进行三次探测","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559007041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97486,"user_name":"请叫我红领巾","can_delete":false,"product_type":"c1","uid":1126586,"ip_address":"","ucode":"98447BCD9E251E","user_header":"","comment_is_top":false,"comment_ctime":1558682915,"is_pvip":false,"replies":[{"id":"35209","content":"可以多机处理的。把数据分散到多台机器上。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1559006421,"ip_address":"","comment_id":97486,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1558682915","product_id":100017301,"comment_content":"假如十万条不能同时在内存中处理，能有什么好办法吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451295,"discussion_content":"可以多机处理的。把数据分散到多台机器上。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559006421,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92854,"user_name":"刘冬","can_delete":false,"product_type":"c1","uid":1401797,"ip_address":"","ucode":"982676C96C0EB4","user_header":"https://static001.geekbang.org/account/avatar/00/15/63/c5/a85ade71.jpg","comment_is_top":false,"comment_ctime":1557352781,"is_pvip":false,"replies":[{"id":"33864","content":"这里要将hashmap中的数据重新copy到数组中，然后再排序。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1557882367,"ip_address":"","comment_id":92854,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557352781","product_id":100017301,"comment_content":"对于置顶的方案，有个小问题： 对hashmap的value做排序，完成后，怎么对应得到排序的Key？<br><br>1. 假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？<br><br>遍历 10 万条数据，以 URL 为 key，访问次数为 value，存入散列表，同时记录下访问次数的最大值 K，时间复杂度 O(N)。<br><br>如果 K 不是很大，可以使用桶排序，时间复杂度 O(N)。如果 K 非常大（比如大于 10 万），就使用快速排序，复杂度 O(NlogN)。<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449401,"discussion_content":"这里要将hashmap中的数据重新copy到数组中，然后再排序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557882367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92476,"user_name":"宝求cross","can_delete":false,"product_type":"c1","uid":1237611,"ip_address":"","ucode":"345DEFCB591C33","user_header":"https://static001.geekbang.org/account/avatar/00/12/e2/6b/0608a33d.jpg","comment_is_top":false,"comment_ctime":1557279702,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557279702","product_id":100017301,"comment_content":"老师你好, 我对线性探测法（Linear Probing)<br>的查找数据有个疑问. 文中提到我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素是否相等......, 一般情况不是应该我只有一个key, 然后通过hash函数得到数组下标, 然后在数组中得到元素值, 如果我都已经知道了要查找的元素是什么了,为什么还要在数组中通过下标查找散列值的元素呢??","like_count":0},{"had_liked":false,"id":92287,"user_name":"阿默","can_delete":false,"product_type":"c1","uid":1139029,"ip_address":"","ucode":"2B78B221571C18","user_header":"https://static001.geekbang.org/account/avatar/00/11/61/55/f6f3e8b0.jpg","comment_is_top":false,"comment_ctime":1557221347,"is_pvip":false,"replies":[{"id":"33069","content":"再线性探测。。。一直探测到找到value相同的那个元素","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1557279951,"ip_address":"","comment_id":92287,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557221347","product_id":100017301,"comment_content":"在使用线性探测时，如果要查找与key对应的value（value值不知道或者难以查找），但是散列表中经过散列得到的下标对应的存储位置已经被别的value占用，该如何处理呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449206,"discussion_content":"再线性探测。。。一直探测到找到value相同的那个元素","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557279951,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91239,"user_name":"苍茫","can_delete":false,"product_type":"c1","uid":1299149,"ip_address":"","ucode":"CED8598307BEAE","user_header":"https://static001.geekbang.org/account/avatar/00/13/d2/cd/6fb14677.jpg","comment_is_top":false,"comment_ctime":1556943071,"is_pvip":false,"replies":[{"id":"33066","content":"不管冲突还是不冲突，都会存储散列表到实际对象数据的地址的。详细的解释，你可以看下面这篇文章：<br>https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;PdvdZoa-SGk_Ojkv2pC2tQ","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1557279618,"ip_address":"","comment_id":91239,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556943071","product_id":100017301,"comment_content":"王老师，有个问题我一直我不明白，你上面说的链表法解决散列冲突，其实在java中hashMap也是这么解决冲突的，但是我想问一下，在取值的时候，如果key是有冲突的，怎么在链表中取得相对应的value呢？难道在hash运算的时候对产生冲突的key会存储value所在的桶的索引吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448854,"discussion_content":"不管冲突还是不冲突，都会存储散列表到实际对象数据的地址的。详细的解释，你可以看下面这篇文章：\nhttps://mp.weixin.qq.com/s/PdvdZoa-SGk_Ojkv2pC2tQ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557279618,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90576,"user_name":"毛瑞文","can_delete":false,"product_type":"c1","uid":1073645,"ip_address":"","ucode":"0202323421F6C6","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/ed/d59e5ea1.jpg","comment_is_top":false,"comment_ctime":1556583543,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556583543","product_id":100017301,"comment_content":"构建散列的时候就直接拿到次数大于1的值，用另外的集合存储。直接拿出来了","like_count":0},{"had_liked":false,"id":87864,"user_name":"Han","can_delete":false,"product_type":"c1","uid":1450610,"ip_address":"","ucode":"9EACABB8599A14","user_header":"https://static001.geekbang.org/account/avatar/00/16/22/72/bebffb62.jpg","comment_is_top":false,"comment_ctime":1555735981,"is_pvip":false,"replies":[{"id":"31652","content":"value就是x","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1555804957,"ip_address":"","comment_id":87864,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555735981","product_id":100017301,"comment_content":"老师，我有个问题。散列表应该是用来存储key—&gt;value这种数据结构吧？对于第一个存储x的例子，既然对x求了hash，那x应该是key。同时把x存储在数组中。那value是什么？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447629,"discussion_content":"value就是x","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555804957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":86803,"user_name":"赵强强","can_delete":false,"product_type":"c1","uid":1073596,"ip_address":"","ucode":"1B8AE07484C69A","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/bc/88a905a5.jpg","comment_is_top":false,"comment_ctime":1555462632,"is_pvip":false,"replies":[{"id":"31220","content":"应该是前者，求的是平均数，而不是最大值或者最小值","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1555468932,"ip_address":"","comment_id":86803,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555462632","product_id":100017301,"comment_content":"王老师，您好，有一个装载因子的疑问想请教。以链表法解决冲突的散列表为例，比如槽位有10个，其中有1个槽位链表包含10个元素，其余9个槽位为空，此时的装载因子是1（10&#47;10）还是0.1（1&#47;10）？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447181,"discussion_content":"应该是前者，求的是平均数，而不是最大值或者最小值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555468932,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84571,"user_name":"立冬","can_delete":false,"product_type":"c1","uid":1467313,"ip_address":"","ucode":"287FA88D933FD5","user_header":"https://static001.geekbang.org/account/avatar/00/16/63/b1/a6103703.jpg","comment_is_top":false,"comment_ctime":1554877773,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554877773","product_id":100017301,"comment_content":" 课后题1用散列表放url 重复加一 完成后 排序<br>2第一个数组用散列表存放数据,完成后 遍历第二个数组 根据hash寻找是否有匹配的值<br>感想: 散列表方便查找","like_count":0},{"had_liked":false,"id":83685,"user_name":"Lucus","can_delete":false,"product_type":"c1","uid":1198800,"ip_address":"","ucode":"CE8EB70CB9D9F1","user_header":"https://static001.geekbang.org/account/avatar/00/12/4a/d0/d319c44a.jpg","comment_is_top":false,"comment_ctime":1554699596,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554699596","product_id":100017301,"comment_content":"10万条url分别做三列表的key，如果只有一条value是1，否则value相加。最后根据value排序。<br>先把第一个数组遍历后存散列表，遍历第二个数组找到散列表中字符串存在的value输出。","like_count":0},{"had_liked":false,"id":83630,"user_name":"拉风猪肉佬","can_delete":false,"product_type":"c1","uid":1484054,"ip_address":"","ucode":"6BE691A9584210","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/16/09d0f013.jpg","comment_is_top":false,"comment_ctime":1554686718,"is_pvip":false,"replies":[{"id":"31228","content":"我们一般都是对散列函数的值取个模，作为最终的散列值。比如这里就对10去模，最终结果肯定就在0~9之间了。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1555469445,"ip_address":"","comment_id":83630,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554686718","product_id":100017301,"comment_content":"散列函数是把key值映射为对应存储位置的数组下标。 那么假设申请数组a[10]作为存储（不考虑扩容）, 那么是不是意味着该散列函数映射后的散列值必须在【0，9】范围之间？如果是的话，该散列函数与通常的摘要函数是同一性质函数吗？如果是的话，摘要后的值并不是一个有校的数组下标啊？还望老师帮忙捋一捋这块","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446104,"discussion_content":"我们一般都是对散列函数的值取个模，作为最终的散列值。比如这里就对10去模，最终结果肯定就在0~9之间了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555469445,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83149,"user_name":"唐荣轩","can_delete":false,"product_type":"c1","uid":1268732,"ip_address":"","ucode":"D225DC43E94D23","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ8a5dg6aBRohA4bQ5KcHdDt6nCnrk0PiarfnVZ3zsgrBbjayAG1bhuAEfyZaNpplnXYDytZlWpfkA/132","comment_is_top":false,"comment_ctime":1554440465,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554440465","product_id":100017301,"comment_content":"没人说php底层是基于hashtable？","like_count":0},{"had_liked":false,"id":82743,"user_name":"EverySeptember","can_delete":false,"product_type":"c1","uid":1218696,"ip_address":"","ucode":"D790EBF6768BBC","user_header":"https://static001.geekbang.org/account/avatar/00/12/98/88/a3dc67f6.jpg","comment_is_top":false,"comment_ctime":1554294609,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554294609","product_id":100017301,"comment_content":"我有一个问题，如果我在初始化一个哈希表时，第一个元素的哈希值就是10000，那我岂不是要初始化一个容量上万的数组？","like_count":0},{"had_liked":false,"id":79544,"user_name":"挠头侠","can_delete":false,"product_type":"c1","uid":1150474,"ip_address":"","ucode":"F96966832E2252","user_header":"https://static001.geekbang.org/account/avatar/00/11/8e/0a/31ec5392.jpg","comment_is_top":false,"comment_ctime":1553506282,"is_pvip":false,"replies":[{"id":"29249","content":"你用key来查找的，用key来比较","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1553649154,"ip_address":"","comment_id":79544,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553506282","product_id":100017301,"comment_content":"老师  文中线性探测部分中写到  &quot;我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素&quot;。<br><br>您说&quot;比较数组中下标为散列值的元素和要查找的元素&quot;<br><br>可是我们现在只知道散列值，在散列冲突的情况下，如何能知道我们要查询的元素是什么呀，这个元素是如何获取得到？<br><br>希望老师解惑，谢谢。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444535,"discussion_content":"你用key来查找的，用key来比较","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553649154,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78900,"user_name":"NLand","can_delete":false,"product_type":"c1","uid":1172759,"ip_address":"","ucode":"07F7AE58EC68C3","user_header":"https://static001.geekbang.org/account/avatar/00/11/e5/17/084dc246.jpg","comment_is_top":false,"comment_ctime":1553272773,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553272773","product_id":100017301,"comment_content":"课后问题都没有答案的呀！留言第一题还是不懂。。","like_count":0},{"had_liked":false,"id":78752,"user_name":"邓超🏊","can_delete":false,"product_type":"c1","uid":1396550,"ip_address":"","ucode":"A1E04704368B60","user_header":"https://static001.geekbang.org/account/avatar/00/15/4f/46/85332f6e.jpg","comment_is_top":false,"comment_ctime":1553230417,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553230417","product_id":100017301,"comment_content":"老师，Python的list结构，是不是天生适合实现散列表，而且，还可以替代链表法。","like_count":0},{"had_liked":false,"id":77611,"user_name":"哈哈","can_delete":false,"product_type":"c1","uid":1397872,"ip_address":"","ucode":"BA32EA6844F201","user_header":"https://static001.geekbang.org/account/avatar/00/15/54/70/bc8f1824.jpg","comment_is_top":false,"comment_ctime":1552972188,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552972188","product_id":100017301,"comment_content":"我有个疑问，下面这句话。如果要比较下标散列值和要查找的元素？理论上来说我们在使用的时候多数不都是不知道要查找的值吗？下面这句话我不是很理解。我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素","like_count":0},{"had_liked":false,"id":77059,"user_name":"康斯坦丁","can_delete":false,"product_type":"c1","uid":1368096,"ip_address":"","ucode":"C130E800E8D5C9","user_header":"https://static001.geekbang.org/account/avatar/00/14/e0/20/003190c1.jpg","comment_is_top":false,"comment_ctime":1552821988,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552821988","product_id":100017301,"comment_content":"1 10 万条url 访问日志，如何按访问次数 给url排序?<br>\t散列表存放: url-&gt;访问次数，然后用访问次数进行排序.<br>2 2个字符串数组 ，每个数组有10万条字符串， 如何快速找出相同的字符串?<br>\thash函数,  字符串hash 成非负整数.   迭代一个数组， 找到另外一个数组对应下标是否有值","like_count":0},{"had_liked":false,"id":76536,"user_name":"Robert","can_delete":false,"product_type":"c1","uid":1057914,"ip_address":"","ucode":"594538993C02ED","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/7a/6ee10cc8.jpg","comment_is_top":false,"comment_ctime":1552629545,"is_pvip":false,"replies":[{"id":"28118","content":"要查找的数据本来就没有？这句话怎么理解呢？","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1552875536,"ip_address":"","comment_id":76536,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552629545","product_id":100017301,"comment_content":"请问冲突后使用开放寻址法解决，后面查找怎么能根据key查找到对应的数据？文章里说查找后和数据进行比较看是否一致，但是我就是要查找数据，本来就没有啊，怎么比较？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443345,"discussion_content":"要查找的数据本来就没有？这句话怎么理解呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552875536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75952,"user_name":"Robert","can_delete":false,"product_type":"c1","uid":1057914,"ip_address":"","ucode":"594538993C02ED","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/7a/6ee10cc8.jpg","comment_is_top":false,"comment_ctime":1552496869,"is_pvip":false,"replies":[{"id":"27867","content":"数据你可以理解为编程语言中的对象。我们拿对象中的某个字段，当做key，来构建散列表。存入的是对象，查找的时候是根据key来查找对象。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1552615589,"ip_address":"","comment_id":75952,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552496869","product_id":100017301,"comment_content":"我还是有个问题没搞懂，key通过散列函数得到散列值，散列值作为数组下标，将数据存入数组，那么存入的数据到底是什么？而查找时查找的又是什么数据？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443102,"discussion_content":"数据你可以理解为编程语言中的对象。我们拿对象中的某个字段，当做key，来构建散列表。存入的是对象，查找的时候是根据key来查找对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552615589,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73581,"user_name":"万象","can_delete":false,"product_type":"c1","uid":1222046,"ip_address":"","ucode":"E81A16870C211E","user_header":"https://static001.geekbang.org/account/avatar/00/12/a5/9e/e78e11d7.jpg","comment_is_top":false,"comment_ctime":1551930538,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551930538","product_id":100017301,"comment_content":"所以，需要一个删除标记，即使key1删除了，遇到标记还是会向下查找，最坏的情况就是都是删除标记，还没找到，或者在最后一个","like_count":0},{"had_liked":false,"id":73580,"user_name":"万象","can_delete":false,"product_type":"c1","uid":1222046,"ip_address":"","ucode":"E81A16870C211E","user_header":"https://static001.geekbang.org/account/avatar/00/12/a5/9e/e78e11d7.jpg","comment_is_top":false,"comment_ctime":1551930298,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551930298","product_id":100017301,"comment_content":"hash是随机的，插入的时候，如果当前被占用，查找到下一个空闲的地方插入，插入位置之前的都需要保留标记，会出现需要遍历N次的情况，但如果下次在hash这个位置的时候，只需要找到后边第一空位或者有删除标记的位置，一般来说我们访问的频率是平均的，所以不会每次都查找N个","like_count":0},{"had_liked":false,"id":73338,"user_name":"qdnjqfch","can_delete":false,"product_type":"c1","uid":1435144,"ip_address":"","ucode":"DD3E5FD94CFDE9","user_header":"https://static001.geekbang.org/account/avatar/00/15/e6/08/87a6f32b.jpg","comment_is_top":false,"comment_ctime":1551863155,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551863155","product_id":100017301,"comment_content":"第一个问题使用map结构也挺好","like_count":0},{"had_liked":false,"id":72408,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1551613513,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551613513","product_id":100017301,"comment_content":"1.url为key，访问次数为value，遍历一遍就好了，然后对hash表数组进行排序就OK了<br>2.把一个数组转为hash表，循环宁一个数组，是否相等，判断相等就行了","like_count":0},{"had_liked":false,"id":68578,"user_name":"恐龙虾了个皮了个姜哩个哩个啷","can_delete":false,"product_type":"c1","uid":1237435,"ip_address":"","ucode":"5AFDDF65BE461F","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/bb/cbeae2fa.jpg","comment_is_top":false,"comment_ctime":1550547588,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550547588","product_id":100017301,"comment_content":"第二道思考题，我觉得题目没有说数组中的字符串是否重复，所以对于顶置的答案，我觉得应该稍微修改一下，以第一个数组构建散列表，初始化value为0，然后遍历第二个数组，value大于0的为重复数组","like_count":0},{"had_liked":false,"id":68177,"user_name":"晓龙","can_delete":false,"product_type":"c1","uid":1004576,"ip_address":"","ucode":"78CDCEBD183D3A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/20/93c79f7c.jpg","comment_is_top":false,"comment_ctime":1550453935,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550453935","product_id":100017301,"comment_content":"1.按照URL访问次数建立hashmap<br>2.将两个数组合并到一个hashmap中；用之前讲到的基数排序","like_count":0},{"had_liked":false,"id":67956,"user_name":"阿星","can_delete":false,"product_type":"c1","uid":1195215,"ip_address":"","ucode":"6AFD288E9022C5","user_header":"https://static001.geekbang.org/account/avatar/00/12/3c/cf/fa5c5123.jpg","comment_is_top":false,"comment_ctime":1550364506,"is_pvip":false,"replies":[{"id":"25200","content":"可以这么理解的！","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551148016,"ip_address":"","comment_id":67956,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1550364506","product_id":100017301,"comment_content":"散列冲突-链表法，在散列表中，每个桶后者槽会对应一条链表，散列值相同的元素会放在相同槽位对应的链表中，，也就是说每个槽位是不存储数据的，是这样的吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439441,"discussion_content":"可以这么理解的！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551148016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":67621,"user_name":"双十一的面包","can_delete":false,"product_type":"c1","uid":1395193,"ip_address":"","ucode":"8914DCDC191C8F","user_header":"https://static001.geekbang.org/account/avatar/00/15/49/f9/1abbe5c9.jpg","comment_is_top":false,"comment_ctime":1550212088,"is_pvip":false,"replies":[{"id":"25408","content":"这个可以看后面的动态规划那一节课，会有讲到。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551232929,"ip_address":"","comment_id":67621,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1550212088","product_id":100017301,"comment_content":"请教老师，之前说到word拼写散列表找不到会给与提示，但是我记得似乎提示会给出相近的一些单词(好久不用word，也许不是这的功能)，这个又是该怎么实现？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439283,"discussion_content":"这个可以看后面的动态规划那一节课，会有讲到。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551232929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":66224,"user_name":"前端西瓜哥","can_delete":false,"product_type":"c1","uid":1248576,"ip_address":"","ucode":"150130C34CD1C1","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/40/f70e5653.jpg","comment_is_top":false,"comment_ctime":1549893500,"is_pvip":false,"replies":[{"id":"25405","content":"占据了的话，可以再跳。实在不行，可以再线性探测。一般都是柔和各种策略来做的。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551232716,"ip_address":"","comment_id":66224,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1549893500","product_id":100017301,"comment_content":"二次探测跳跃比较大，万一刚好跳的位置都被占据了，怎么办？我的解决思路是扩容，对吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438752,"discussion_content":"占据了的话，可以再跳。实在不行，可以再线性探测。一般都是柔和各种策略来做的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551232716,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":63585,"user_name":"且听疯吟","can_delete":false,"product_type":"c1","uid":1159459,"ip_address":"","ucode":"B010B16E5465F4","user_header":"https://static001.geekbang.org/account/avatar/00/11/b1/23/5df1f341.jpg","comment_is_top":false,"comment_ctime":1548408230,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548408230","product_id":100017301,"comment_content":"问题1:  hash统计出每个url的访问次数，然后再按照次数对url进行排序即可。<br>问题2：第一个数组组成一个hash token，对第二个数组中的每个元素进行hash取值即可。<br>```<br>class Solution{<br>   static bool cmp(pair&lt;string,int&gt; &amp;a,pair&lt;string,int&gt; &amp;b){<br>        return a.second &gt; b.second;<br>   }<br><br>   vector&lt;string&gt; sortUrl(vector&lt;string&gt; &amp;url){<br>     unordered_map&lt;string,int&gt; url_map;<br>     vector&lt;pair&lt;string,int&gt;&gt; url_cnt;<br>     vector&lt;string&gt; ans;<br><br>     for(auto e: url){<br>        url_map[e]++;<br>     }<br><br>     for(auto e: url_map){<br>        url_cnt.push_back(e);<br>     }<br>     sort(url_cnt.begin(),url_cnt.end(),cmp);<br>     for(auto e: url_cnt){<br>        ans.push_back(e.first());<br>     }<br><br>     return ans;<br>   }<br>}<br><br>class Solution{<br>    vector&lt;string&gt; compareString(vector&lt;string&gt; &amp;s1,vector&lt;string&gt; &amp;s2){<br>      map&lt;string,int&gt; str_map;<br>      vector&lt;string&gt; ans;<br><br>      for(auto e: s1){<br>         str_map[e]++;<br>      }<br><br>      for(auto e: s2){<br>         if(s1.find(e)!=s1.end()){<br>           ans.push_back(e);<br>         }<br>      }<br>      <br>      return ans;<br>   }<br>}<br>```","like_count":0},{"had_liked":false,"id":61973,"user_name":"BUG君","can_delete":false,"product_type":"c1","uid":1143211,"ip_address":"","ucode":"B7513F37026E5F","user_header":"https://static001.geekbang.org/account/avatar/00/11/71/ab/b19a1ba2.jpg","comment_is_top":false,"comment_ctime":1547869199,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547869199","product_id":100017301,"comment_content":"12<br><br>请教老师，当我在查找元素时候，在相同散列值的链表中遍历如何区分哪个是我要找的元素？毕竟查找时查询条件只包含KEY的信息吧<br><br>老师说可以对比key来实现，相同的散列值对应的链表中不是只存储的value值吗？？难道也把key存进去了？？","like_count":0},{"had_liked":false,"id":61530,"user_name":"泉","can_delete":false,"product_type":"c1","uid":1099760,"ip_address":"","ucode":"914709BE802A8D","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/f0/aa2e0749.jpg","comment_is_top":false,"comment_ctime":1547714797,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1547714797","product_id":100017301,"comment_content":"散列冲突:线性检测，双重检测。","like_count":0},{"had_liked":false,"id":61351,"user_name":"杰少","can_delete":false,"product_type":"c1","uid":1254940,"ip_address":"","ucode":"B44D3FC33854A5","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/1c/9c162798.jpg","comment_is_top":false,"comment_ctime":1547685182,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547685182","product_id":100017301,"comment_content":"因为数组下标是从 0 开始的，所以散列函数生成的散列值也要是非负整数。<br><br>这句话不太理解，散列值是存储在数据中的值，跟下标无关，为什么要求非负呢？如果key是这么要求，倒是可以理解！","like_count":0},{"had_liked":false,"id":60618,"user_name":"睡痴儿😑","can_delete":false,"product_type":"c1","uid":1187204,"ip_address":"","ucode":"750EF858EF2042","user_header":"https://static001.geekbang.org/account/avatar/00/12/1d/84/d0ec0064.jpg","comment_is_top":false,"comment_ctime":1547519559,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547519559","product_id":100017301,"comment_content":"如果有10w条URL数据，我可以先将日期转化为一个数字。例如2019-01-15可以转化为20190115。之后按照这个日期插入到一个散列表中。","like_count":0},{"had_liked":false,"id":57736,"user_name":"花子翁","can_delete":false,"product_type":"c1","uid":1073674,"ip_address":"","ucode":"A687441DC6894F","user_header":"https://static001.geekbang.org/account/avatar/00/10/62/0a/26d00cb9.jpg","comment_is_top":false,"comment_ctime":1546877949,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546877949","product_id":100017301,"comment_content":"按照作者说的逻辑，通过散列表查找元素：通过散列函数把键值变为散列值，通过数组下标去找，如果找到的话，就是要找的值。但是对有散列冲突时，好像是不行的吧","like_count":0},{"had_liked":false,"id":56442,"user_name":"CathyLin","can_delete":false,"product_type":"c1","uid":1240546,"ip_address":"","ucode":"F7CDFF5E1A235F","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/e2/0e1c6c5a.jpg","comment_is_top":false,"comment_ctime":1546443982,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546443982","product_id":100017301,"comment_content":"思考题：<br>1. 有 10w 条 URL 访问日志，那么我们可以先创建一个散列表，然后将 URL 的访问日志作为 key，它们的出现次数作为 hash 值，遍历一遍所有的 URL 访问日志所需的时间复杂度为 O(n)。最后可以利用 sort 函数按照访问次数来对 URL 进行排序，复杂度为 O(nlogn)。<br><br>2. 首先只遍历一个数组，然后利用 hash table 把这个数组中的所有出现过的字符串都标记为 1。然后再去遍历另一个数组，如果另一个数组中的 string 它当前的 hash 值也为 1 的话，说明当前这个 string 在两个数组中都出现过了，那么这个就是当前两个数组的相同字符串。","like_count":0},{"had_liked":false,"id":54588,"user_name":"w 🍍","can_delete":false,"product_type":"c1","uid":1228290,"ip_address":"","ucode":"F2386C971EC58B","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/02/43202976.jpg","comment_is_top":false,"comment_ctime":1545907096,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545907096","product_id":100017301,"comment_content":"&quot;假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？&quot;<br>如果用url做key的话，应该不能排序？","like_count":0},{"had_liked":false,"id":52571,"user_name":"郑佳宇","can_delete":false,"product_type":"c1","uid":1239639,"ip_address":"","ucode":"538EE8AA8EA375","user_header":"https://static001.geekbang.org/account/avatar/00/12/ea/57/5d4bc563.jpg","comment_is_top":false,"comment_ctime":1545442417,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545442417","product_id":100017301,"comment_content":"散列表中存储的是一个完整的单词？如果要做到写一个字母就检测一次，要怎么做？","like_count":0},{"had_liked":false,"id":51646,"user_name":"aguan(^･ｪ･^)","can_delete":false,"product_type":"c1","uid":1107177,"ip_address":"","ucode":"04833EF2D18E1A","user_header":"https://static001.geekbang.org/account/avatar/00/10/e4/e9/0dd3829f.jpg","comment_is_top":false,"comment_ctime":1545216353,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545216353","product_id":100017301,"comment_content":"王铮老师and各位同学，晚上好~<br>对于在文中提到：开放寻址法的散列表，个人认为这种散列表在插入和查找时都很不方便，心中有个疑问：这类散列表有用吗？在实际应用中什么场景会用到开放寻址散列表呢？","like_count":0},{"had_liked":false,"id":50899,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1545062644,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545062644","product_id":100017301,"comment_content":"思考题：<br>若不局限于算法，<br>1.第一个10万条url日志，统计次数，再排序，可以使用数据库操作。<br>把10万条日志存入数据库中，然后一条sql语句搞定。<br>select url,count(1) as countnum from log<br>group by url<br>order by countnum;<br>2.分别将两组字符串存入两个表a,b，然后使用left join进行关联查询。","like_count":0},{"had_liked":false,"id":50731,"user_name":"匆匆","can_delete":false,"product_type":"c1","uid":1333414,"ip_address":"","ucode":"4DB39C6CD5743B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/H8NxrljQXliccaT5fjdXJQYS3ou3Z9ykAuKw6EgicicEA9L4jQLz3h85P0odgDSaK0cA9oTyUKibbiagdNvnHuuV5mQ/132","comment_is_top":false,"comment_ctime":1545036349,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545036349","product_id":100017301,"comment_content":"哈希表&#47;散列表<br><br>散列表是数组的一种拓展。用到的是数组支持的按照下标随机访问数据的特性。<br><br>原理：利用哈希函数将key值映射到数组下标，然后就可以通过key值直接取用(或者存储）相对应的数组的信息了。所以哈希表中的一个关键就是哈希函数，关键就在于如何构建哈希函数。<br><br>构造哈希函数的基本要求：3点（自己回忆）如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。这点事几乎不可能达到的，这就是哈希冲突。<br><br>哈希冲突解决方法有两种：1、开放寻址法。（包括线性探测【当哈希函数计算出的位置的值已有值时就时冲突了，此时就顺序向下查找空位置，知道找到空位置时放入数据就可以】、二次探测、双重探测）不管哪种探测方法，当散列表中的空闲位置不多的时候，冲突的机会就会大大增加。2、链表法（更常用）。每个槽（桶）对应一个链表，每次只需要根据哈希函数计算出的槽位，将值插入导对应链表后面即可。<br><br>核心：散列函数设计和散列冲突解决。","like_count":0},{"had_liked":false,"id":50728,"user_name":"匆匆","can_delete":false,"product_type":"c1","uid":1333414,"ip_address":"","ucode":"4DB39C6CD5743B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/H8NxrljQXliccaT5fjdXJQYS3ou3Z9ykAuKw6EgicicEA9L4jQLz3h85P0odgDSaK0cA9oTyUKibbiagdNvnHuuV5mQ/132","comment_is_top":false,"comment_ctime":1545036121,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545036121","product_id":100017301,"comment_content":"哈希表&#47;散列表<br><br>散列表是数组的一种拓展。用到的是数组支持的按照下标随机访问数据的特性。<br><br>原理：利用哈希函数将key值映射到数组下标，然后就可以通过key值直接取用(或者存储）相对应的数组的信息了。所以哈希表中的一个关键就是哈希函数，关键就在于如何构建哈希函数。<br><br>构造哈希函数的基本要求：3点（自己回忆）如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。这点事几乎不可能达到的，这就是哈希冲突。<br><br>哈希冲突解决方法有两种：1、开放寻址法。（包括线性探测【当哈希函数计算出的位置的值已有值时就时冲突了，此时就顺序向下查找空位置，知道找到空位置时放入数据就可以】、二次探测、双重探测）不管哪种探测方法，当散列表中的空闲位置不多的时候，冲突的机会就会大大增加。2、链表法（更常用）。每个槽（桶）对应一个链表，每次只需要根据哈希函数计算出的槽位，将值插入导对应链表后面即可。<br><br>核心：散列函数设计和散列冲突解决。","like_count":0},{"had_liked":false,"id":49580,"user_name":"大悲","can_delete":false,"product_type":"c1","uid":1341085,"ip_address":"","ucode":"3A7865964B0159","user_header":"https://static001.geekbang.org/account/avatar/00/14/76/9d/bfcdbdda.jpg","comment_is_top":false,"comment_ctime":1544720476,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544720476","product_id":100017301,"comment_content":"请问，散列表是通过数组实现的，那么数组的大小是这么确定的呢？如果是动态的可扩容的，那么散列函数又是如何可以生成可以访问到扩容之后地址的key的呢？","like_count":0},{"had_liked":false,"id":48995,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1544586403,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544586403","product_id":100017301,"comment_content":"散列表就是数组的扩展<br><br>通过散列函数，将键值映射为下标<br>键值------散列值<br>散列冲突------开放寻址，线性探测，二次探测，重新散列；链表法<br><br>装载因子  <br><br>问答：1、先统计，再排序；2、创建hash表，查询hash值，","like_count":0},{"had_liked":false,"id":48875,"user_name":"墨禾","can_delete":false,"product_type":"c1","uid":1216590,"ip_address":"","ucode":"81BA44231AABE8","user_header":"https://static001.geekbang.org/account/avatar/00/12/90/4e/efaea936.jpg","comment_is_top":false,"comment_ctime":1544575273,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544575273","product_id":100017301,"comment_content":"是不是应该假设10万条字符串没有重复，或者在构建hash table之前先给字符串去重？","like_count":0},{"had_liked":false,"id":47401,"user_name":"敲键盘的人","can_delete":false,"product_type":"c1","uid":1232210,"ip_address":"","ucode":"59AFFFE9DA5B4E","user_header":"https://static001.geekbang.org/account/avatar/00/12/cd/52/a2478536.jpg","comment_is_top":false,"comment_ctime":1544142186,"is_pvip":false,"replies":[{"id":"16921","content":"开多大 就要根据数据有多少来了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1544148353,"ip_address":"","comment_id":47401,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1544142186","product_id":100017301,"comment_content":"数组一般开多大的呢？如果哈希函数设计的不好 可能会出现数组中空位太多导致空间浪费是吗","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431759,"discussion_content":"开多大 就要根据数据有多少来了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544148353,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":47358,"user_name":"y1nored","can_delete":false,"product_type":"c1","uid":1233959,"ip_address":"","ucode":"D92BD845F5B673","user_header":"https://static001.geekbang.org/account/avatar/00/12/d4/27/6f68c4cd.jpg","comment_is_top":false,"comment_ctime":1544113716,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544113716","product_id":100017301,"comment_content":"置顶留言，字符串如何在空间复杂度为O（1）构建散列表？","like_count":0},{"had_liked":false,"id":47146,"user_name":"15040107907","can_delete":false,"product_type":"c1","uid":1064997,"ip_address":"","ucode":"0D35668079F92A","user_header":"https://static001.geekbang.org/account/avatar/00/10/40/25/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1544063460,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544063460","product_id":100017301,"comment_content":"不理解评论里的首条，一共10万url 怎么可能k大于10万？ ","like_count":0},{"had_liked":false,"id":45908,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1543816476,"is_pvip":false,"replies":[{"id":"16539","content":"可以用的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543888681,"ip_address":"","comment_id":45908,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1543816476","product_id":100017301,"comment_content":"Word文档中的拼写检查功能，应该也可以用Trie这种数据结构实现吧？为什么不用呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431264,"discussion_content":"可以用的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543888681,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":45746,"user_name":"^O^","can_delete":false,"product_type":"c1","uid":1273594,"ip_address":"","ucode":"3A2699ADEE38A1","user_header":"https://static001.geekbang.org/account/avatar/00/13/6e/fa/c23cb574.jpg","comment_is_top":false,"comment_ctime":1543766207,"is_pvip":false,"replies":[{"id":"16355","content":"一篇文章配一到两个实例 多了 文章就会写很长。你自己百度研究下吧","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543801584,"ip_address":"","comment_id":45746,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1543766207","product_id":100017301,"comment_content":"老师能不能多讲点实例，为什么总感觉读懂了。却不知道怎么用","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431188,"discussion_content":"一篇文章配一到两个实例 多了 文章就会写很长。你自己百度研究下吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543801584,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":45563,"user_name":"Fff","can_delete":false,"product_type":"c1","uid":1041744,"ip_address":"","ucode":"2D1E13AF02449C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e5/50/29af37cf.jpg","comment_is_top":false,"comment_ctime":1543676437,"is_pvip":false,"replies":[{"id":"16367","content":"可以把这个哈希值再跟数组的大小取模 这样不管多大的哈希值 就都落在数组内了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543802669,"ip_address":"","comment_id":45563,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1543676437","product_id":100017301,"comment_content":"用hash后的值作为数组下标的话，如果hash之后的值分布非常不均匀，比如1，和10个1w以上的数，那分配数组空间的时候岂不是存在很大的空洞？这一点一直没想明白，像md5这么大的值能用来做数组下标？<br>希望老师解答下","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431097,"discussion_content":"可以把这个哈希值再跟数组的大小取模 这样不管多大的哈希值 就都落在数组内了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543802669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":43262,"user_name":"园园","can_delete":false,"product_type":"c1","uid":1257028,"ip_address":"","ucode":"2A34FD1FC31042","user_header":"https://static001.geekbang.org/account/avatar/00/13/2e/44/b6f5b1fd.jpg","comment_is_top":false,"comment_ctime":1543201607,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543201607","product_id":100017301,"comment_content":"双重散列要能写得更详细一些就好了。","like_count":0},{"had_liked":false,"id":41477,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1542789997,"is_pvip":false,"replies":[{"id":"14971","content":"应该也可以 不过汉字要复杂点 汉字处理的应该是词 而不是单个的字","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542852313,"ip_address":"","comment_id":41477,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542789997","product_id":100017301,"comment_content":"那汉字的拼写检查也是通过这种类似的方式嘛？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429815,"discussion_content":"应该也可以 不过汉字要复杂点 汉字处理的应该是词 而不是单个的字","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542852313,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":40966,"user_name":"张瀚元","can_delete":false,"product_type":"c1","uid":1237388,"ip_address":"","ucode":"89B56F4EB82088","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/8c/02c2607c.jpg","comment_is_top":false,"comment_ctime":1542704864,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542704864","product_id":100017301,"comment_content":"散列冲突怎么产生的感觉没讲清楚","like_count":0},{"had_liked":false,"id":40361,"user_name":"steventang","can_delete":false,"product_type":"c1","uid":1251638,"ip_address":"","ucode":"E3D89FDFC3499D","user_header":"https://static001.geekbang.org/account/avatar/00/13/19/36/95246ba9.jpg","comment_is_top":false,"comment_ctime":1542603084,"is_pvip":false,"replies":[{"id":"14675","content":"你说的没错 要另外开辟空间来p","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542679034,"ip_address":"","comment_id":40361,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542603084","product_id":100017301,"comment_content":"老师，置顶的回答用hash表来统计各url的出现次数，那对于hash冲突的url处理貌似并没有具体说明。<br>如果采用链表解决冲突，那么排序是不是要另外开辟空间来排？如何排？不知道我理解的对不对，烦请老师有空解答。谢谢。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429495,"discussion_content":"你说的没错 要另外开辟空间来p","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542679034,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":39166,"user_name":"H+","can_delete":false,"product_type":"c1","uid":1235602,"ip_address":"","ucode":"FBAAE3BD6A5769","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/92/8826f642.jpg","comment_is_top":false,"comment_ctime":1542201939,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542201939","product_id":100017301,"comment_content":"二次探测如何保证能探测到空闲的位置呢？双重散列的方式如何进行查找和删除操作呢，不是不知道到底是用了哪个散列方法嘛？是不是如果值不对就换下一个散列方法，直到用完所有的散列方法？","like_count":0},{"had_liked":false,"id":38991,"user_name":"Alexis何春光","can_delete":false,"product_type":"c1","uid":1181149,"ip_address":"","ucode":"614570FAE3B56A","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/dd/b201cf13.jpg","comment_is_top":false,"comment_ctime":1542167661,"is_pvip":false,"replies":[{"id":"14123","content":"后面会讲的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542280764,"ip_address":"","comment_id":38991,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542167661","product_id":100017301,"comment_content":"问题是word找不到之后如何给建议呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428875,"discussion_content":"后面会讲的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542280764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":38705,"user_name":"luffy","can_delete":false,"product_type":"c1","uid":1244950,"ip_address":"","ucode":"702034E116A99F","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/16/b0ab9a73.jpg","comment_is_top":false,"comment_ctime":1542111063,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542111063","product_id":100017301,"comment_content":"如果是4个字符串数组呢？","like_count":0},{"had_liked":false,"id":38553,"user_name":"冯选刚","can_delete":false,"product_type":"c1","uid":1018444,"ip_address":"","ucode":"A186F31A730F04","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/4c/d976b42c.jpg","comment_is_top":false,"comment_ctime":1542074474,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542074474","product_id":100017301,"comment_content":"又学到了编程语言中一些对象的储存原理。","like_count":0},{"had_liked":false,"id":38220,"user_name":"追风者","can_delete":false,"product_type":"c1","uid":1055092,"ip_address":"","ucode":"879BC372A6B605","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIjUDIRQ0gRiciax3Wo78c5rVjuWDiaw4ibcCiby8xiaMXJh5ibjU5242vfCGOK4ehibe1IKyxex2A4IX4XSA/132","comment_is_top":false,"comment_ctime":1541991543,"is_pvip":false,"replies":[{"id":"13810","content":"再把散列表的数据放到数组中 然后再排序","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542074046,"ip_address":"","comment_id":38220,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1541991543","product_id":100017301,"comment_content":"网上看了一下，哈希表是不可以直接进行排序的。<br>如果是链式法的哈希表的话，每个槽位存储的应该是链表的头结点，链表中的结点是对象，这个对象是{url,访问次数count}。<br>至于怎么排序，暂时还没想到，希望老师解答。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428645,"discussion_content":"再把散列表的数据放到数组中 然后再排序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542074046,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":38217,"user_name":"量子纠结","can_delete":false,"product_type":"c1","uid":1026857,"ip_address":"","ucode":"564D9BADCD5C34","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ab/29/53afdb24.jpg","comment_is_top":false,"comment_ctime":1541991096,"is_pvip":false,"replies":[{"id":"13809","content":"不会的 一个位置只可能存储一个数据  同一个key找到两个值？那除非是真的存储了两个key相同的数据","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542073990,"ip_address":"","comment_id":38217,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1541991096","product_id":100017301,"comment_content":"老师，请问一下，在数据插入过程中，当经过散列函数后映射到具体的数组下标对应已经有值了，那么按照寻址法找到新的下标插入后，那么在查询的时候会不会出现同一个key找到两个值？求解答，感谢！！！<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428644,"discussion_content":"不会的 一个位置只可能存储一个数据  同一个key找到两个值？那除非是真的存储了两个key相同的数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542073990,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37980,"user_name":"！null","can_delete":false,"product_type":"c1","uid":1242483,"ip_address":"","ucode":"4E5B7922980397","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/73/f7d3a996.jpg","comment_is_top":false,"comment_ctime":1541838608,"is_pvip":false,"replies":[{"id":"13717","content":"这是最基础的数据 不可能什么都不存吧","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541987415,"ip_address":"","comment_id":37980,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1541838608","product_id":100017301,"comment_content":"由于哈希冲突，所以散列表中的数据结构都要有key么？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428543,"discussion_content":"这是最基础的数据 不可能什么都不存吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541987415,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37727,"user_name":"pyhhou","can_delete":false,"product_type":"c1","uid":1256496,"ip_address":"","ucode":"31EF8D50CF91A5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ibZVAmmdAibBeVpUjzwId8ibgRzNk7fkuR5pgVicB5mFSjjmt2eNadlykVLKCyGA0GxGffbhqLsHnhDRgyzxcKUhjg/132","comment_is_top":false,"comment_ctime":1541715299,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541715299","product_id":100017301,"comment_content":"思考题的第一问，<br>把URL放入一个Key-Value pair的散列结构中，key用来存放URL，value用来存放这个URL出现的个数，当把10万个URL访问记录遍历完后其实该散列存储的size是k，k &lt;= n(10万)，k是指unique的URL的个数，所以利用快排根据value排序，排序的时间复杂度是O(klgk)，这里把k和n区分出来，正常情况下 k &lt;&lt; n<br><br>思考题第二问，<br>最简单的思路就是直接把一个字符串数组里面的字符串统统扔进散列结构，然后遍历另一个字符串数组进行匹配，选出散列中存在的那些字符串。但是这里延伸出来一个有意思的问题<br>          一个字符串数组中的字符串是否相互重复？<br>                如果不重复，那么之前提到的方案不需要改变，完全适用。如果有重复，那么问题来了，同样的字符串是不是都需要找出来，例如 <br>         String[] str1 = [&quot;aaa&quot;, &quot;aaa&quot;, &quot;bbb&quot;];<br>         String[] str2 = [&quot;aaa&quot;, &quot;aaa&quot;, &quot;ccc&quot;];<br>这里最后的输出结果是[&quot;aaa&quot;]还是[&quot;aaa&quot;, &quot;aaa&quot;] ，如果是前者，普通的单一key的散列结构完全可以用来存储最后的答案，如果是后者，我们可能还需要记录字符串出现的个数，那么考虑用之前第一问提到的key-value pair的散列结构进行最后的答案存储与记录","like_count":0},{"had_liked":false,"id":37589,"user_name":"无名","can_delete":false,"product_type":"c1","uid":1110113,"ip_address":"","ucode":"2D2E877CF97138","user_header":"https://static001.geekbang.org/account/avatar/00/10/f0/61/68462a07.jpg","comment_is_top":false,"comment_ctime":1541645439,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541645439","product_id":100017301,"comment_content":"假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？<br>假如访问次数范围为0-N，我们建立容量为N的数组，然后以访问次数为hash key，即数组下标，数组存放的内容为相同次数的URL集合。<br>","like_count":0},{"had_liked":false,"id":37588,"user_name":"木槿花开","can_delete":false,"product_type":"c1","uid":1068781,"ip_address":"","ucode":"7DD06CDB91A8ED","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/ed/e99fc0f9.jpg","comment_is_top":false,"comment_ctime":1541645279,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541645279","product_id":100017301,"comment_content":"这两个问题的代码能同步到git 上吗？","like_count":0},{"had_liked":false,"id":37587,"user_name":"无名","can_delete":false,"product_type":"c1","uid":1110113,"ip_address":"","ucode":"2D2E877CF97138","user_header":"https://static001.geekbang.org/account/avatar/00/10/f0/61/68462a07.jpg","comment_is_top":false,"comment_ctime":1541645066,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541645066","product_id":100017301,"comment_content":"英文单词的hash算法应该呢？","like_count":0},{"had_liked":false,"id":37452,"user_name":"Ahikaka","can_delete":false,"product_type":"c1","uid":1045146,"ip_address":"","ucode":"B3A678567E40A9","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/vhOPEib27xAuTycN0eQekLzsCe9zwcTTcrOb98cIfpgibgcweZBDN38tIicABibuZBwah9jnGVr02H2Zjuue1fLfEQ/132","comment_is_top":false,"comment_ctime":1541593579,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541593579","product_id":100017301,"comment_content":"高明！用链表解决哈希冲突，太高明了。收益了，一直不知道哈希是如何解决冲突了，原来如此。","like_count":0},{"had_liked":false,"id":37066,"user_name":"qinggeouye","can_delete":false,"product_type":"c1","uid":1251536,"ip_address":"","ucode":"5B53EEDD7BEC9C","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/d0/49b06424.jpg","comment_is_top":false,"comment_ctime":1541437679,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541437679","product_id":100017301,"comment_content":"结合本节内容和留言区的思路：<br><br>1、假设有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？<br><br>将 URL 作为 key，对每一条 URL 取散列值 hash(key)，散列值相同则对应元素值加 1，存入散列表 。并设置一个变量 K，记录最大的元素值即最大次数 K 。<br><br>K 不大，K 个桶，计数排序。<br><br>K 很大，快速排序。<br><br>2、有两个字符串数组，每个数组有大约 10 万条字符串，如何快速找出两个数组中相同的字符串？<br><br>对第一个字符串数组构建一个散列表，以字符串作为 key，散列值 hash(key) 相同的，对应元素值加 1 （字符串出现的次数），并存入散列表。<br><br>对第二个字符串数组中的每个字符串 key ，取其 hash(key) 在第一个散列表中查找。如果找到，则该字符串就是相同的字符串，对应的元素值为出现的次数。<br><br>","like_count":0},{"had_liked":false,"id":36988,"user_name":"oldman","can_delete":false,"product_type":"c1","uid":1133711,"ip_address":"","ucode":"6BACE2832B4429","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/8f/a90b3969.jpg","comment_is_top":false,"comment_ctime":1541412850,"is_pvip":false,"replies":[{"id":"13254","content":"可以存储对象的 不一定非是单个的值呀","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541468039,"ip_address":"","comment_id":36988,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1541412850","product_id":100017301,"comment_content":"请教个问题，这个数组里面的index是你散列算法之后的值，value是你的key值，那么你真正的value值存储在哪里呢，还是说我理解的有问题，请老师答疑。谢谢。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428113,"discussion_content":"可以存储对象的 不一定非是单个的值呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541468039,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36782,"user_name":"狼的诱惑","can_delete":false,"product_type":"c1","uid":1257043,"ip_address":"","ucode":"AE89DFC5963C42","user_header":"https://static001.geekbang.org/account/avatar/00/13/2e/53/bf62683f.jpg","comment_is_top":false,"comment_ctime":1541325065,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541325065","product_id":100017301,"comment_content":"以下是一楼的回复，我这边有两个疑问？前提是同一数组中没有重复数据，二是遍历数时如果出现散列冲突是不是就不能简单这么做了。保存字符串原文和出现次数，出现冲突是否需要对比一下字符串是否一致，一致再累加值。<br>以下是一楼回复的:<br>2. 有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？<br><br>以第一个字符串数组构建散列表，key 为字符串，value 为出现次数。再遍历第二个字符串数组，以字符串为 key 在散列表中查找，如果 value 大于零，说明存在相同字符串。时间复杂度 O(N)","like_count":0},{"had_liked":false,"id":36626,"user_name":"asdf100","can_delete":false,"product_type":"c1","uid":1043738,"ip_address":"","ucode":"39D8D71453E575","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/1a/ce7f7d54.jpg","comment_is_top":false,"comment_ctime":1541205285,"is_pvip":false,"replies":[{"id":"13112","content":"曹位是固定的 不过还可以扩容 下节课会讲到","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541383867,"ip_address":"","comment_id":36626,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1541205285","product_id":100017301,"comment_content":"散列表的长度是固定的吗，说是类似数组，数组的内存是连续的。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427941,"discussion_content":"曹位是固定的 不过还可以扩容 下节课会讲到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541383867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36571,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1541153747,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541153747","product_id":100017301,"comment_content":"好熟悉的感觉，这不就是五笔打字时，敲完了字根码，查找候选词的技术方案么...<br>哈哈哈哈，我猜的","like_count":0},{"had_liked":false,"id":36537,"user_name":"良辰美景","can_delete":false,"product_type":"c1","uid":1074803,"ip_address":"","ucode":"B36E6955A2872D","user_header":"https://static001.geekbang.org/account/avatar/00/10/66/73/fd1e37a2.jpg","comment_is_top":false,"comment_ctime":1541144432,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541144432","product_id":100017301,"comment_content":"假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？<br>1:按访问次数一个个往平衡二叉树里扔， 然后通过中序遍历就是一个有序的列表了<br><br>","like_count":0},{"had_liked":false,"id":36534,"user_name":"BD","can_delete":false,"product_type":"c1","uid":1228560,"ip_address":"","ucode":"A95CF8C3EDC228","user_header":"https://static001.geekbang.org/account/avatar/00/12/bf/10/b7974690.jpg","comment_is_top":false,"comment_ctime":1541143738,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541143738","product_id":100017301,"comment_content":"关于Smallfly同学的第二题答案，如果字符串数组2在散列表里查找时，如果出现不同字符串的散列值相同的情况不就不准确了吗？我觉得应该再找到相同散列值的时候还要比较下字符串的值吧<br>","like_count":0},{"had_liked":false,"id":36463,"user_name":"莫问流年","can_delete":false,"product_type":"c1","uid":1249663,"ip_address":"","ucode":"23140E031AED4B","user_header":"https://static001.geekbang.org/account/avatar/00/13/11/7f/80d56c1c.jpg","comment_is_top":false,"comment_ctime":1541121075,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541121075","product_id":100017301,"comment_content":"解决散列冲突的方法主要有开放寻址法和链表法。其中开放寻址法又分为线性探测法、二次探测法和多重散列法。","like_count":0},{"had_liked":false,"id":36396,"user_name":"嘿嘿啊","can_delete":false,"product_type":"c1","uid":1248655,"ip_address":"","ucode":"6CCD7A0AF000A0","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/8f/a0232945.jpg","comment_is_top":false,"comment_ctime":1541079874,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541079874","product_id":100017301,"comment_content":"就Smallfly同学的回答发表一下不同意见：<br>第二题应该是将第一个字符串数组存到散列表中，同样key为字符串，value应该是初始化为0的吧。然后遍历第二个字符串数组的时候，用字符串在表中查找相同的key，有得话就将表中的value置1，表示两个数组都存在该字符串（或者如果只是找出相同字符串的话，就直接输出该字符串）。","like_count":0},{"had_liked":false,"id":36366,"user_name":"勤劳的小胖子-libo","can_delete":false,"product_type":"c1","uid":1158344,"ip_address":"","ucode":"5BB20CD5A56568","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/c8/4b1c0d40.jpg","comment_is_top":false,"comment_ctime":1541060287,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541060287","product_id":100017301,"comment_content":"好奇有个问题：<br>一开始说：我们可以总结出这样的规律：散列表用的就是数组支持按照下标随机.访问的时候，时间复杂度是 O(1) 的特性。<br>后面面对冲突，使用链表来解决：“那查找或删除操作的时间复杂度是多少呢？实际上，这两个操作的时.间复杂度跟链表的长度 k 成正比，也就是 O(k)。对于散列.比较均匀的散列函数来说，理论上讲，k=n&#47;m”。<br><br>查找就是访问的吧？那到底时间复杂度是O(1)还是O(k)? <br>可不可以理解，数据少的时候为O(1)，后来越来越多变成O(k)?","like_count":0},{"had_liked":false,"id":36335,"user_name":"Kermit Sun","can_delete":false,"product_type":"c1","uid":1245430,"ip_address":"","ucode":"9B0560FB228629","user_header":"https://static001.geekbang.org/account/avatar/00/13/00/f6/f6cf138c.jpg","comment_is_top":false,"comment_ctime":1541042533,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541042533","product_id":100017301,"comment_content":"习题1：定义hash1方法，key(url),value(访问次数);定义hash2方法，key(访问次数),value([url1,url2]);<br>扫描10w数据，按照hash1方法储存后，再循环hash1得到的内存空间，按照hash2方法保存，之后循环hash2获得根据访问次数有序的url集合。<br>习题2：解法1：对其中较少的数组进行hash保存，以字符串内容当做key，value可以是一个共用的指针或句柄或者基本类型的值；之后循环较多的数组，已hash方式获取，如果该地址有值，则是重复字符串；<br>解法2：对两个数组进行排序，之后按照类似快排的比对方式进行比对；","like_count":0},{"had_liked":false,"id":36305,"user_name":"樂文💤","can_delete":false,"product_type":"c1","uid":1073694,"ip_address":"","ucode":"CE4A46397521FC","user_header":"https://static001.geekbang.org/account/avatar/00/10/62/1e/8054e6db.jpg","comment_is_top":false,"comment_ctime":1541034017,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541034017","product_id":100017301,"comment_content":"所以js中的对象底层也是用数组实现的么？","like_count":0},{"had_liked":false,"id":36227,"user_name":"cc","can_delete":false,"product_type":"c1","uid":1239833,"ip_address":"","ucode":"AA1B8EA613E3A9","user_header":"https://static001.geekbang.org/account/avatar/00/12/eb/19/19e706a5.jpg","comment_is_top":false,"comment_ctime":1540987359,"is_pvip":false,"replies":[{"id":"12889","content":"想复杂了 一个散列表统计次数 然后再排序一下就ok了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541036367,"ip_address":"","comment_id":36227,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540987359","product_id":100017301,"comment_content":"思考题1应该需要两个散列表吧，一个key是url，val是次数。另一个key是次数，val是url","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427791,"discussion_content":"想复杂了 一个散列表统计次数 然后再排序一下就ok了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541036367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36217,"user_name":"巫木灵","can_delete":false,"product_type":"c1","uid":1252631,"ip_address":"","ucode":"891D576EC7D37D","user_header":"https://static001.geekbang.org/account/avatar/00/13/1d/17/72b69214.jpg","comment_is_top":false,"comment_ctime":1540982624,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540982624","product_id":100017301,"comment_content":"第一题用访问次数做bucket，第二题没有一个很好的思路，如果数组小的话，第一想法是动态规划，数组太大了，想用今天学的hash表，没有一个很好的想法。看了一下评论，感觉还是没有一个比较有说服力的思路。","like_count":0},{"had_liked":false,"id":36204,"user_name":"咖啡巧克力丶","can_delete":false,"product_type":"c1","uid":1241940,"ip_address":"","ucode":"C205E66058859B","user_header":"https://static001.geekbang.org/account/avatar/00/12/f3/54/bcad6e64.jpg","comment_is_top":false,"comment_ctime":1540976298,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540976298","product_id":100017301,"comment_content":"1.先使用URL作为key，遍历10万条数据，有散列冲突就值+1，再根据值做一个快排。<br>2.第一个数组，用字符串当key，遍历10条数据，有冲突就放弃，不添加在表中。第二个数组遍历时，只讲有冲突的值+1，不在表内的，就放弃。最后散列表内值大于1的为重复字符串。","like_count":0},{"had_liked":false,"id":36196,"user_name":"Jeson","can_delete":false,"product_type":"c1","uid":1258168,"ip_address":"","ucode":"A75A8BF2EBD9CD","user_header":"https://static001.geekbang.org/account/avatar/00/13/32/b8/6a80fb00.jpg","comment_is_top":false,"comment_ctime":1540972989,"is_pvip":true,"replies":[{"id":"12892","content":"数组中存的是运动员的全量信息 并不仅仅是成绩的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541036614,"ip_address":"","comment_id":36196,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540972989","product_id":100017301,"comment_content":"问个问题，以记录运动员成绩为例，运动员A的hash值为x，则在x位置上记录A的成绩。当运动员B的hash值也为x时，如何判断x上的成绩是否为B的？您说可以在相同hash值时对比key，那么当前B的key为B，但是A的key在哪？如何对比？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427776,"discussion_content":"数组中存的是运动员的全量信息 并不仅仅是成绩的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541036614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36191,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1540971968,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540971968","product_id":100017301,"comment_content":"思考题:<br>1. 用访问次数做为hash表的散列值 对应的url作为val 用链表存储<br>2.  同时遍历两个数组 首先比较两个数组元素是否相等 如果相等找到了相同元素 如果没有找到 则数组1的元素和数组2的元素分别作为hash2 hash1 两个hash表的原因避免 数组中的元素找到本数组中相同的值 的散列值进行查找 如果没有找到则分别把数组1的元素值 作为hash1的key 数组2的元素值作为has2的key","like_count":0},{"had_liked":false,"id":36180,"user_name":"ALAN","can_delete":false,"product_type":"c1","uid":1240164,"ip_address":"","ucode":"70E3B1C730E63F","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/64/7403c694.jpg","comment_is_top":false,"comment_ctime":1540965766,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540965766","product_id":100017301,"comment_content":"思考题1：用一个hash函数对url进行映射，映射后得到散列值，将散列值和url映射起来，统计相同的散列值的个数，即为相同的url个数，对不同的散列值的个数进行快速排序，排序好后获取散列值对应的url，即可得到按url访问次数排序的结果<br>思考题2：对第一个字符串数组每个字符串进行hash散列函数插入。操作完后，对第二个字符串数组遍历，用相同的hash散列函数进行查找，查找元素的键值对应的散列值，若找到则为两个数组中相同的字符串。","like_count":0},{"had_liked":false,"id":36177,"user_name":"猫头鹰爱拿铁","can_delete":false,"product_type":"c1","uid":1105958,"ip_address":"","ucode":"24266B58968428","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/26/4942a09e.jpg","comment_is_top":false,"comment_ctime":1540964925,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1540964925","product_id":100017301,"comment_content":"第一题：首先遍历10万条url，获取最大的访问次数max和最小访问次数min，然后得到count=max-min，这个count是桶的数量，桶是Node[count],每个桶由链表组成，然后再遍历一次url，根据访问次数放到桶里，最后遍历一次桶和桶里的链表即完成排序。时间复杂度为o(n)。<br>第二题：首先将第一个字符串数组放入hashmap或者hashtable，然后遍历第二个数组，看看hashmap中有没有相同的元素即可。时间复杂度为o(n)","like_count":0},{"had_liked":false,"id":36152,"user_name":"qjwang","can_delete":false,"product_type":"c1","uid":1252564,"ip_address":"","ucode":"602E7BC174C82A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKHKQ5A6dv3zMoRmOOJq7a3K7W1UM3cLjsDLGoSZUdrRQG2PibIPdRibMAu4EbbF9SfKYmFAYcdflYA/132","comment_is_top":false,"comment_ctime":1540956494,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540956494","product_id":100017301,"comment_content":"typedef struct Node<br>{<br>    int data;<br>    Node *next;<br>}NODE;<br><br>typedef struct Strack<br>{<br>    Node *pTop;<br>    Node *pBottom;<br>}STRACK;<br><br>Strack *init_strack()<br>{<br>    Strack *ps = (STRACK *)malloc(sizeof(STRACK));<br>    Node *test ;&#47;&#47;= (NODE*)malloc(sizeof(NODE));<br><br>    Node *pNew = (Node*)malloc(sizeof(Node));<br>    if(pNew == NULL)<br>    {<br>        cout &lt;&lt; &quot;pTop malloc fail &quot; &lt;&lt; endl;<br>    }<br>    else<br>    {<br>        pNew-&gt;data  = 1;<br>        pNew-&gt;next = NULL;<br>        test = pNew;<br>        ps-&gt;pBottom = pNew;<br>        ps-&gt;pTop = pNew;<br>    }<br><br>    cout &lt;&lt; &quot;test-&gt;data:&quot; &lt;&lt; test-&gt;data &lt;&lt; endl;<br>    cout &lt;&lt; &quot;ps-&gt;data:&quot; &lt;&lt; ps-&gt;pTop-&gt;data &lt;&lt; endl;<br>    return ps;<br>}<br><br>我想问下ps这个结构体指针和test这个结构体指针的区别，为什么ps一定要malloc，test没有malloc也没有问题。指针什么时候需要malloc？","like_count":0},{"had_liked":false,"id":36149,"user_name":"雨天","can_delete":false,"product_type":"c1","uid":1056406,"ip_address":"","ucode":"FD9FB404ECA463","user_header":"https://static001.geekbang.org/account/avatar/00/10/1e/96/3162d51f.jpg","comment_is_top":false,"comment_ctime":1540955662,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540955662","product_id":100017301,"comment_content":"思考题:<br>1:以访问次数为key,url为值[url用数组存储];<br>2:将字符串数组转成Hash表存储,遍历其中一个Hash表;在O(n)内找出全部的重复字符串.","like_count":0},{"had_liked":false,"id":36131,"user_name":"帝都De雾霾","can_delete":false,"product_type":"c1","uid":1019007,"ip_address":"","ucode":"0B2C1221DAD95B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/7f/15ee94da.jpg","comment_is_top":false,"comment_ctime":1540950368,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540950368","product_id":100017301,"comment_content":"思考题1：使用 URL 地址作为 key，出现次数作为 value，做第一次的遍历插入；然后再使用快速排序对出现次数排序<br>思考题2：通过散列函数依次对两个数字的中的字符串进行散列化，散列结果一样的即相同的字符串","like_count":0},{"had_liked":false,"id":36124,"user_name":"柠檬C","can_delete":false,"product_type":"c1","uid":1181505,"ip_address":"","ucode":"BC0EE704D952A4","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/41/2d477385.jpg","comment_is_top":false,"comment_ctime":1540949574,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540949574","product_id":100017301,"comment_content":"基于java，第一题可以用treemap指定一个对Map.Entry的比较器，先把所有url和对应的次数读入treemap，再用treemal的Entry构造一个数组集合，对集合用指定的比较器排序，时间复杂度取决于排序，一般是o(nlogn)，空间复杂度on<br>第二题用hashset读入第一个数组，对第二个数组遍历","like_count":0},{"had_liked":false,"id":36111,"user_name":"隆","can_delete":false,"product_type":"c1","uid":1234257,"ip_address":"","ucode":"283CD389C29124","user_header":"https://static001.geekbang.org/account/avatar/00/12/d5/51/a041cd29.jpg","comment_is_top":false,"comment_ctime":1540946451,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540946451","product_id":100017301,"comment_content":"链表法实现的就是hash map, 散列冲突也叫hash 碰撞","like_count":0}]}