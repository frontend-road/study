{"id":497868,"title":"加餐五 | 深入理解协程基础元素","content":"<p>你好，我是朱涛。</p><p>在上一讲当中，我们深入研究了Kotlin挂起函数的原理，实际更多的是在了解协程的“基础层”。而接下来，我们将会开始研究协程启动的原理，探索协程的“中间层”。</p><p>在<a href=\"https://time.geekbang.org/column/article/495862\">第26讲</a>里，我曾提到过，Kotlin的协程框架其实就是协程基础元素组合出来的框架。如果我们想要弄懂Kotlin协程，首先就要将它的“基础层”理解透彻。</p><p>所以今天，我还是决定来一次加餐，带你系统深入地认识一下Kotlin协程当中的基础元素。等你对协程的基础层有了深入认识以后，下节课研究协程启动原理就会轻松一些了。</p><h2>协程基础元素</h2><p>通过第26讲我们现在已经知道，Kotlin协程的基础元素大致有这些：Continuation、SafeContinuation、CoroutineContext、CombinedContext、CancellationException、intrinsics。</p><p><img src=\"https://static001.geekbang.org/resource/image/c6/ae/c65bbb36321c7683ea6d17155d2ee2ae.jpg?wh=2000x1125\" alt=\"\"></p><p>其中的CoroutineContext、CancellationException我都已经介绍过了，另外的CombinedContext，其实就是CoroutineContext的一个实现类，而SafeContinuation则是Continuation的实现类。</p><!-- [[[read_end]]] --><p>所以，在整个协程基础元素当中，我们最需要关心的，其实就是<strong>Continuation和intrinsics</strong>。</p><p>在intrinsics里，有一个重要的高阶函数suspendCoroutineUninterceptedOrReturn{}，我们后面会讲到它。至于Continuation，虽然我们在前面已经介绍过它是什么，但还没有系统了解过它的用法，所以接下来，我们就先系统了解一下Continuation的两种用法。</p><h2>Continuation到底该怎么用？</h2><p>实际上，在<a href=\"https://time.geekbang.org/column/article/488985\">第18讲</a>里，我们就已经学过Continuation的其中一种用法了：</p><pre><code>// 代码段1\n\nsuspend fun &lt;T : Any&gt; KtCall&lt;T&gt;.await(): T =\n    suspendCancellableCoroutine { continuation -&gt;\n        val call = call(object : Callback&lt;T&gt; {\n            override fun onSuccess(data: T) {\n                // 注意这里\n                continuation.resume(data)\n            }\n\n\n            override fun onFail(throwable: Throwable) {\n                // 注意这里\n                continuation.resumeWithException(throwable)\n            }\n        })\n\n        continuation.invokeOnCancellation {\n            println(&quot;Call cancelled!&quot;)\n            call.cancel()\n        }\n    }\n</code></pre><p>当我们想要实现挂起函数的时候，可以使用suspendCoroutine{}、suspendCancellableCoroutine{}这两个高阶函数，在它们的Lambda当中，我们可以使用它暴露出来的continuation对象，把程序的执行结果或异常传到外部去。</p><p><strong>这种方式，往往是用于实现挂起函数内部逻辑的。</strong></p><p>比如说，我们可以用suspendCoroutine{}写一个更加简单的例子：</p><pre><code>// 代码段2\n\nfun main() = runBlocking {\n    val result = getLengthSuspend(&quot;Kotlin&quot;)\n    println(result)\n}\n\nsuspend fun getLengthSuspend(text: String): Int = suspendCoroutine { continuation-&gt;\n    thread {\n        // 模拟耗时\n        Thread.sleep(1000L)\n        continuation.resume(text.length)\n    }\n}\n\n/*\n输出结果：\n等待1秒\n6\n*/\n</code></pre><p>以上代码里，我们是使用suspendCoroutine{}实现了挂起函数，然后在它的内部，我们使用continuation.resume()的方式，传出了挂起函数的返回值。</p><p>可能你会觉得奇怪，为什么以continuation.resume()这样异步的方式传出结果以后，挂起函数就能接收到结果呢？其实，当我们把main()函数当中的调用逻辑改一下，这一切就会清晰明了。</p><pre><code>// 代码段3\n\n// 变化在这里\nfun main()  {\n    val func = ::getLengthSuspend as (String, Continuation&lt;Int&gt;) -&gt; Any?\n\n    func(&quot;Kotlin&quot;, object: Continuation&lt;Int&gt;{\n        override val context: CoroutineContext\n            get() = EmptyCoroutineContext\n\n        override fun resumeWith(result: Result&lt;Int&gt;) {\n            println(result.getOrNull())\n        }\n    })\n\n    // 防止程序提前结束\n    Thread.sleep(2000L)\n}\n\nsuspend fun getLengthSuspend(text: String): Int = suspendCoroutine { continuation-&gt;\n    thread {\n        // 模拟耗时\n        Thread.sleep(1000L)\n        continuation.resume(text.length)\n    }\n}\n/*\n输出结果：\n等待1秒\n6\n*/\n</code></pre><p>可以看到，在这段代码里，我们借助上节课的知识，把getLengthSuspend()这个函数强转成了带有Continuation的函数类型，然后通过匿名内部类的方式，创建了一个Continuation对象传了进去。最终，程序的执行结果和代码段2是一致的。</p><p>你还记得我在<a href=\"https://time.geekbang.org/column/article/487085\">第15讲</a>提到过的观点吗？</p><blockquote>\n<p>挂起函数的本质，就是Callback!</p>\n</blockquote><p>那么现在，就让我们把Continuation改为Callback，看看代码会变成什么样子。</p><pre><code>// 代码段4\n\n// 变化在这里\nfun main()  {\n    func(&quot;Kotlin&quot;, object: Callback&lt;Int&gt;{\n        override fun resume(result: Int) {\n            println(result)\n        }\n    })\n\n    // 防止程序提前结束\n    Thread.sleep(2000L)\n}\n\nfun func(text: String, callback: Callback&lt;Int&gt;) {\n    thread {\n        // 模拟耗时\n        Thread.sleep(1000L)\n        callback.resume(text.length)\n    }\n}\n\ninterface Callback&lt;T&gt; {\n    fun resume(value: T)\n}\n\n/*\n输出结果：\n等待1秒\n6\n*/\n</code></pre><p>可见，当我们把Continuation改成Callback以后，整个代码就变成了我们曾经最熟悉的异步回调代码了。调用方，可以使用匿名内部类创建Callback用于接收异步结果；异步函数内部，使用callback.resume()将结果传出去。</p><p>综上所述，Kotlin协程当中的Continuation，作用其实就相当于Callback，它既可以用于<strong>实现挂起函数</strong>，往挂起函数的外部传递结果；也可以用于<strong>调用挂起函数</strong>，我们可以创建Continuation的匿名内部类，来接收挂起函数传递出来的结果。</p><p>所以在这里，我们也就可以轻松回答上节课的思考题了：</p><blockquote>\n<p>我们都知道挂起函数是Kotlin协程里才有的概念，请问，Java代码中可以调用Kotlin的挂起函数吗？比如，下面这个函数，我们可以在Java当中调用吗？</p>\n</blockquote><pre><code>// 代码段5\n\n// 需要在Java中调用的Kotlin挂起函数\nobject SuspendFromJavaExample {\n    // 在Java当中如何调用这个方法？\n    suspend fun getUserInfo(id: Long):String {\n        delay(1000L)\n        return &quot;Kotlin&quot;\n    }\n}\n</code></pre><p>答案当然是肯定的，Java当中调用挂起函数的方式，其实跟前面的代码段3是一样的：</p><pre><code>// 代码段6\n\npublic static void main(String[] args) throws InterruptedException {\n    SuspendFromJavaExample.INSTANCE.getUserInfo(100L, new Continuation&lt;String&gt;() {\n        @NotNull\n        @Override\n        public CoroutineContext getContext() {\n            return EmptyCoroutineContext.INSTANCE;\n        }\n\n        @Override\n        public void resumeWith(@NotNull Object o) {\n            System.out.println(o+&quot;&quot;);\n        }\n    });\n\n    // 防止程序提前结束\n    Thread.sleep(2000L);\n}\n\n/*\n输出结果\nKotlin\n*/\n</code></pre><p>在上面的代码中，我们只是把代码段3的思想应用到了Java代码中而已，唯一需要<strong>注意</strong>的，就是：在Java当中访问Kotlin的object单例，是需要加上INSTANCE后缀的。这一点，我们在<a href=\"https://time.geekbang.org/column/article/475058\">第5讲</a>当中就已经了解过。</p><p>看到这里，可以发现，我们在实现挂起函数逻辑的时候，总是离不开<strong>suspendCoroutine{}、suspendCancellableCoroutine{}</strong>。其实，这两个高阶函数也是Kotlin协程的基础元素，让我们来进一步认识这两个高阶函数。</p><h2>suspendCoroutineUninterceptedOrReturn</h2><p>实际上，suspendCoroutine{}、suspendCancellableCoroutine{}这两个高阶函数的实现原理是类似的，所以这里我们就主要解释下suspendCoroutine{}。</p><p>如果你去看suspendCoroutine{}的源代码，会发现它其实也在<a href=\"https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/coroutines/Continuation.kt\">Continuation.kt</a>这个文件当中。</p><pre><code>// 代码段7\n\npublic interface Continuation&lt;in T&gt; {\n    public val context: CoroutineContext    \n    public fun resumeWith(result: Result&lt;T&gt;)\n}\n\npublic suspend inline fun &lt;T&gt; suspendCoroutine(crossinline block: (Continuation&lt;T&gt;) -&gt; Unit): T {\n\n    // 注意这里\n    return suspendCoroutineUninterceptedOrReturn { c: Continuation&lt;T&gt; -&gt;\n        val safe = SafeContinuation(c.intercepted())\n        block(safe)\n        safe.getOrThrow()\n    }\n}\n</code></pre><p>在上面的代码中，我们第一眼就能看到一个名字特别长的高阶函数suspendCoroutineUninterceptedOrReturn{}。它其实就是实现suspendCoroutine{}的关键。除了它之外，其他部分的代码都很好理解：</p><ul>\n<li>SafeContinuation(c.intercepted())这行代码的作用，就是把原本的Continuation包裹一遍。</li>\n<li>block(safe)这行代码，其实就是在调用Lambda当中的逻辑。</li>\n<li>safe.getOrThrow()，就是在取出block(safe)的运行结果，我们在上节课也提到过，Continuation当中是可以存储result的。这个Result可能是正确的结果，也可能是异常。</li>\n</ul><p>下面我们重点来看看suspendCoroutineUninterceptedOrReturn{}这个高阶函数的作用。如果你去看它的源代码，那你看到的大概率会是这样的：</p><pre><code>// 代码段8\n\npublic suspend inline fun &lt;T&gt; suspendCoroutineUninterceptedOrReturn(crossinline block: (Continuation&lt;T&gt;) -&gt; Any?): T {\n    contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }\n    throw NotImplementedError(&quot;Implementation of suspendCoroutineUninterceptedOrReturn is intrinsic&quot;)\n}\n</code></pre><p>大部分人看到这样的代码可能都会觉得奇怪：<strong>为什么这个高阶函数的源代码会是抛出异常呢？</strong></p><p>在前面的加餐二“表达式思维”里，我其实有做过说明，如果你还有印象的话，应该就能理解这样的代码也是符合函数返回值的规范的。不过，如果它总是抛异常的话，我们用suspendCoroutine{}写代码的时候，为什么不会产生崩溃呢？这个异常信息里的提示内容又是什么意思？</p><blockquote>\n<p>“Implementation of suspendCoroutineUninterceptedOrReturn is intrinsic.”</p>\n</blockquote><p>实际上，理解这句话的关键在于“intrinsic”这个单词，它有“固有”“本质”的意思，不过在上面这句话的语境下，这里的intrinsic其实是指编译器领域的一个术语，我们可以把它理解为“内建”。因此，上面我们看到的异常提示信息的意思就是：suspendCoroutineUninterceptedOrReturn是一个编译器内建函数，<strong>它是由Kotlin编译器来实现的</strong>。</p><p>为了不偏离这节课的主题，这里我们就不去深究Kotlin编译器当中的逻辑了，感兴趣的话你可以自行研究这个<a href=\"https://github.com/JetBrains/kotlin/blob/1.6.0/compiler/backend/src/org/jetbrains/kotlin/codegen/coroutines/coroutineCodegenUtil.kt\">链接</a>。接下来，我们可以换一个角度，写一些Demo代码，通过运行调试来看看这个内建函数的功能和作用。</p><p>让我们先来看看suspendCoroutineUninterceptedOrReturn这个高阶函数的参数，它会接收一个Lambda，类型是<code>(Continuation&lt;T&gt;) -&gt; Any?</code>，经过上节课的学习，你是否觉得这个类型有些眼熟呢？这里的“Any?”类型，其实就能代表当前这个挂起函数是否真正挂起。</p><p>因此，我们可以写出下面这样的代码：</p><pre><code>// 代码段9\n\nfun main() = runBlocking {\n    val result = testNoSuspendCoroutine()\n    println(result)\n}\n\nprivate suspend fun testNoSuspendCoroutine() = suspendCoroutineUninterceptedOrReturn&lt;String&gt; {\n        continuation -&gt;\n    return@suspendCoroutineUninterceptedOrReturn &quot;Hello!&quot;\n}\n\n/*\n输出结果：\nHello!\n*/\n</code></pre><p>在这段代码中，我们直接使用suspendCoroutineUninterceptedOrReturn实现了挂起函数，并且，在它的Lambda当中，我们并没有调用continuation.resume()，而是直接返回了结果“Hello!”。根据程序的运行结果，我们可以看到，在挂起函数的外部确实也可以接收到这个结果。</p><p>那么这时候，如果我们把上面的代码反编译一下，会看到类似这样的代码：</p><pre><code>    // 代码段10\n\n    private static final Object testNoSuspendCoroutine(Continuation $completion) {\n      int var2 = false;\n      if (&quot;Hello!&quot; == IntrinsicsKt.getCOROUTINE_SUSPENDED()) {\n         DebugProbesKt.probeCoroutineSuspended($completion);\n      }\n    \n      return &quot;Hello!&quot;;\n    }\n</code></pre><p>所以，从反编译的结果来看，testNoSuspendCoroutine()这个函数其实就是一个<strong>伪挂起函数</strong>，它的内部并不会真正挂起。这样，当我们从外部调用这个函数的时候，这个函数会立即返回结果“Hello!”。</p><p>而这时候，我们可以再写一个真正的挂起函数：</p><pre><code>// 代码段11\n\nfun main() = runBlocking {\n    val result = testSuspendCoroutine()\n    println(result)\n}\n\nprivate suspend fun testSuspendCoroutine() = suspendCoroutineUninterceptedOrReturn&lt;String&gt; {\n    continuation -&gt;\n    thread {\n        Thread.sleep(1000L)\n        continuation.resume(&quot;Hello!&quot;)\n\n\n    }\n    return@suspendCoroutineUninterceptedOrReturn kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED\n}\n\n/*\n输出结果：\n等待1秒\nHello!\n*/\n</code></pre><p>这一次，我们并没有使用return返回结果，而是使用了continuation.resume()。通过程序运行结果，我们可以看到挂起函数的外部也能接收到这个结果。然后我们也再来反编译一下，看看它对应的Java代码：</p><pre><code>// 代码段12\n\nprivate static final Object testSuspendCoroutine(Continuation $completion) {\n    int var2 = false;\n    // 1\n    ThreadsKt.thread$default(false, false, (ClassLoader)null, (String)null, 0, (Function0)(new CoroutineBasicElementsKt$testSuspendCoroutine$2$1($completion)), 31, (Object)null);\n    // 2\n    Object var10000 = IntrinsicsKt.getCOROUTINE_SUSPENDED();\n    if (var10000 == IntrinsicsKt.getCOROUTINE_SUSPENDED()) {\n     DebugProbesKt.probeCoroutineSuspended($completion);\n    }\n    // 3\n    return var10000;\n}\n\nfinal class CoroutineBasicElementsKt$testSuspendCoroutine$2$1 extends Lambda implements Function0 {\n\n   final Continuation $it;\n\n   public Object invoke() {\n      this.invoke();\n      return Unit.INSTANCE;\n   }\n\n   public final void invoke() {\n      // 4\n      Thread.sleep(1000L);\n      Continuation var1 = this.$it;\n      String var2 = &quot;Hello!&quot;;\n      Companion var3 = Result.Companion;\n      var1.resumeWith(Result.constructor-impl(var2));\n   }\n\n   CoroutineBasicElementsKt$testSuspendCoroutine$2$1(Continuation var1) {\n      super(0);\n      this.$it = var1;\n   }\n}\n</code></pre><p>以上代码中一共有4个注释，我们一个个看：</p><ul>\n<li>注释1、4，创建了一个新的线程，执行了thread{}当中的代码。</li>\n<li>注释2，将var10000赋值为COROUTINE_SUSPENDED这个挂起标志位。</li>\n<li>注释3，返回挂起标志位，代表testSuspendCoroutine()这个函数会真正挂起。</li>\n</ul><p>所以，这两个例子其实也从侧面证明了我们在上节课当中的结论：</p><blockquote>\n<p>由于 suspend 修饰的函数，既可能返回 CoroutineSingletons.COROUTINE_SUSPENDED，也可能返回实际结果，甚至可能返回 null，为了适配所有的可能性，CPS转换后的函数返回值类型就只能是Any?了。</p>\n</blockquote><p>那么现在，我们也就可以总结出<strong>suspendCoroutineUninterceptedOrReturn{}这个高阶函数的作用</strong>了：它可以将挂起函数当中的Continuation以参数的形式暴露出来，在它的Lambda当中，我们可以直接返回结果，这时候它就是一个“伪挂起函数”；或者，我们也可以返回COROUTINE_SUSPENDED这个挂起标志位，然后使用continuation.resume()传递结果。</p><p>相应的，suspendCoroutine{}、suspendCancellableCoroutine{}这两个高阶函数，只是对它的一种封装而已。</p><h2>小结</h2><p>这节课，我们学习了Kotlin协程当中与挂起函数密切相关的两个基础元素，Continuation、suspendCoroutine{}。</p><p>Continuation是整个协程当中最重要的基础元素，我们可以将其看做是一个Callback。它主要有两个使用场景，一种是在实现挂起函数的时候，用于传递挂起函数的执行结果；另一种是在调用挂起函数的时候，以匿名内部类的方式，用于接收挂起函数的执行结果。借助这种思路，我们也完全可以在Java当中调用挂起函数。</p><p>当我们想要实现挂起函数的时候，我们往往需要使用suspendCoroutine{}、suspendCancellableCoroutine{}这两个高阶函数。它们两个都是对suspendCoroutineUninterceptedOrReturn{}的封装，这个高阶函数的作用其实就是暴露挂起函数的Continuation对象。在它的Lambda当中，我们既可以直接返回执行结果，也可以返回COROUTINE_SUSPENDED这个挂起标志位，然后使用continuation.resume()传递结果。</p><h2>思考题</h2><p>你觉得，suspendCoroutine{}、suspendCancellableCoroutine{}这两个高阶函数，它对比suspendCoroutineUninterceptedOrReturn{}的优势在哪里？Kotlin官方为什么要进行这样的封装呢？</p><p>欢迎在留言区分享你的答案，也欢迎你把今天的内容分享给更多的朋友。</p>","comments":[{"had_liked":false,"id":339413,"user_name":"Allen","can_delete":false,"product_type":"c1","uid":1127306,"ip_address":"","ucode":"3F69DAC14260DC","user_header":"https://static001.geekbang.org/account/avatar/00/11/33/8a/f7a3d5e6.jpg","comment_is_top":false,"comment_ctime":1648087321,"is_pvip":false,"replies":[{"id":"124298","content":"很棒的答案！","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1648521359,"ip_address":"","comment_id":339413,"utype":1}],"discussion_count":1,"race_medal":0,"score":"44597760281","product_id":100103401,"comment_content":"关于思考题的思考：<br><br>suspendCoroutine{} 或者 suspendCancellableCoroutine{} 在使用的时候，只需要知道 Continuation 接口，而接口中只有一个函数 resumeWith，相对让人比较容易和 Callback 回调关联起来，所以，使用这两个函数的成本较小，不需要对 coroutine 协程的原理有太多的理解。<br><br>而 suspendCoroutineUninterceptedOrReturn{} 函数除了需要关心 Continuation 接口外，还需要关心对应的返回值，而这个返回值中有几种状态，每种状态代表什么意思，其实在对 coroutine 原理不太清楚的情况下，是完全不知道怎么调用的。<br><br>总的来说，suspendCoroutineUninterceptedOrReturn{} 使用的学习成本要高很多。","like_count":11,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558907,"discussion_content":"很棒的答案！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648521359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339511,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1648160158,"is_pvip":false,"replies":[{"id":"124291","content":"是的，这也是它们的一大差异。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1648521123,"ip_address":"","comment_id":339511,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14533062046","product_id":100103401,"comment_content":"suspendCoroutine 用了SafeContinuation，里面有原子读和一些状态判断，应该是处理多线程和重复resume的问题。","like_count":4,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558899,"discussion_content":"是的，这也是它们的一大差异。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648521123,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341613,"user_name":"ACE_Killer09","can_delete":false,"product_type":"c1","uid":1618019,"ip_address":"","ucode":"4ED9D2A521A237","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqQVYE1EfqibdyNsnjFibHW4jee0Q3qMMeRhqqVQUn5Ix9fFl3Zfzf0xpdrGypxHUmBCyiczfyEaPoWA/132","comment_is_top":false,"comment_ctime":1649735267,"is_pvip":false,"replies":[{"id":"124965","content":"很棒的答案~<br><br>resume resumeWith resumeWithException 的原理都是 resumewith()，它们的区别主要是值的区别。当然，它传入的值的类型，也会影响协程的后续执行流程，比如说，如果是传入了异常信息，那么协程内部就要处理相关的异常逻辑了。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1649953232,"ip_address":"","comment_id":341613,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5944702563","product_id":100103401,"comment_content":"对于 代码段 10 和 11 suspendCoroutineUninterceptedOrReturn 必须要考虑返回值，如果return的不是COROUTINE_SUSPENDED，就不是一个真正的挂起函数。而如果是使用 suspendCoroutine suspendCancellableCoroutine，就不用考虑返回值，他们一定是挂起的，只要最后通过Continuation 返回值即可。<br><br>另外  Continuation中 resume resumeWith resumeWithException 的原理都是 resumewith 这三个具体应用场景除了传入值区别 还有 其他区别吗？","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":563246,"discussion_content":"很棒的答案~\n\nresume resumeWith resumeWithException 的原理都是 resumewith()，它们的区别主要是值的区别。当然，它传入的值的类型，也会影响协程的后续执行流程，比如说，如果是传入了异常信息，那么协程内部就要处理相关的异常逻辑了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649953232,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339990,"user_name":"杨小妞","can_delete":false,"product_type":"c1","uid":1657434,"ip_address":"","ucode":"DF5AE317301023","user_header":"https://static001.geekbang.org/account/avatar/00/19/4a/5a/14eb7973.jpg","comment_is_top":false,"comment_ctime":1648526496,"is_pvip":false,"replies":[{"id":"124486","content":"27讲当中的状态机只是没有体现出resumeWith而已，实际上，挂起函数可以通过两种方式返回，可能是resumeWith，也可能是直接return返回。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1648814942,"ip_address":"","comment_id":339990,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5943493792","product_id":100103401,"comment_content":"Continuation 的resumeWith函数只有在，回调函数转挂起函数或者java调用挂起函数的时候才发挥作用吗？<br>在挂起函数执行挂起函数的状态机里面，好像没看到resumeWith的影子","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559560,"discussion_content":"27讲当中的状态机只是没有体现出resumeWith而已，实际上，挂起函数可以通过两种方式返回，可能是resumeWith，也可能是直接return返回。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648814942,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339290,"user_name":"辉哥","can_delete":false,"product_type":"c1","uid":1236983,"ip_address":"","ucode":"21A65F4EE6CD04","user_header":"","comment_is_top":false,"comment_ctime":1648023858,"is_pvip":false,"replies":[{"id":"124293","content":"很棒的答案。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1648521153,"ip_address":"","comment_id":339290,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5942991154","product_id":100103401,"comment_content":"suspendCoroutine{}能保证suspendCoroutine的挂起点（也就是传入lambda的continuation参数）只会被resume一次.因为实际上传入的continuation为SafeContinuation,多次调用会抛异常,可以规范用户的使用","like_count":2,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558902,"discussion_content":"很棒的答案。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648521153,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":350681,"user_name":"Emmm","can_delete":false,"product_type":"c1","uid":2883853,"ip_address":"","ucode":"D0F82DD41E5CF0","user_header":"https://static001.geekbang.org/account/avatar/00/2c/01/0d/94f46a96.jpg","comment_is_top":false,"comment_ctime":1657092079,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1657092079","product_id":100103401,"comment_content":"suspendCoroutine可以理解为会阻塞外层协程吧，这样就可以实现同步得到耗时任务回调出来的结果，然后进行后续的操作，这样的话看外层协程作用域的代码就是顺序同步执行","like_count":0},{"had_liked":false,"id":342423,"user_name":"ZircoN","can_delete":false,"product_type":"c1","uid":1033848,"ip_address":"","ucode":"E665DF0DBB7381","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c6/78/9b1e4b15.jpg","comment_is_top":false,"comment_ctime":1650255564,"is_pvip":false,"replies":[{"id":"125110","content":"如果你去源码里看“kotlin.coroutines.intrinsics.Intrinsics.kt”当中的suspendCoroutineUninterceptedOrReturn()，就可以找到引用了。不要去找IntrinsicsJvm.kt里面的，因为它只是JVM层的具体实现。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1650296568,"ip_address":"","comment_id":342423,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1650255564","product_id":100103401,"comment_content":"suspendCoroutineUninterceptedOrReturn 这个方法在IDE里为啥没法引用到？","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":564694,"discussion_content":"如果你去源码里看“kotlin.coroutines.intrinsics.Intrinsics.kt”当中的suspendCoroutineUninterceptedOrReturn()，就可以找到引用了。不要去找IntrinsicsJvm.kt里面的，因为它只是JVM层的具体实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650296569,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}