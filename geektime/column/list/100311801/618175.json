{"id":618175,"title":"11｜代码实现（中）：怎样创建领域对象、实现领域逻辑？","content":"<p>你好，我是钟敬。今天咱们继续撸代码。</p><p><a href=\"https://time.geekbang.org/column/article/617473\">上节课</a>我们解决了层间依赖的问题，今天我们讨论几个更深入的问题。</p><p>第一，在面向过程的程序里，领域逻辑一般是写在<strong>应用服务</strong>里的，那么，DDD有什么不同的思路呢？为了解决这个问题，我们需要掌握DDD的领域服务模式和表意接口模式。</p><p>第二，过去我们常常在应用服务里面直接 “New” 出领域对象，如果创建领域对象的逻辑比较复杂，那要怎么办呢？对于这个问题，我们需要了解DDD的工厂模式。</p><p>另外，尽管我们已经介绍了分层架构和模块模式，但实现的时候，你可能还会有一些困惑，我们也会在这节课里一并解决。后面代码比较多，建议你一边看文稿，一边听我说。</p><h2>“表意接口”（Intention-Revealing Interfaces）模式</h2><p>“添加组织”这个功能的领域逻辑主要体现在各种校验规则上，咱们先粗略地看看应用服务的代码的结构，暂时不需要细看每个校验的具体逻辑。</p><pre><code class=\"language-java\">package chapter11.unjuanable.application.orgmng;\n// imports...\n\n@Service\npublic class OrgService {\n    private final UserRepository userRepository;\n    private final TenantRepository tenantRepository;\n    private final OrgTypeRepositoryJdbc orgTypeRepository;\n    private final OrgRepository orgRepository;\n    private final EmpRepository empRepository;\n\n    @Autowired\n    public OrgService(UserRepository userRepository\n            , TenantRepository tenantRepository\n            , OrgRepository orgRepository\n            , EmpRepository empRepository\n            , OrgTypeRepositoryJdbc orgTypeRepository) {\n\n        //为注入的 Repository 赋值...\n    }\n\n    // \"添加组织\"功能的入口\n    public OrgDto addOrg(OrgDto request, Long userId) { \n        validate(request);\n        Org org = buildOrg(request, userId);\n        org = orgRepository.save(org);\n        return buildOrgDto(org);\n    }\n\n    private OrgDto buildOrgDto(Org org) {\n       //将领域对象转成DTO...\n    }\n\n    private Org buildOrg(OrgDto request, Long userId) {\n       //将DTO转成领域对象...\n    }\n\n    //主要的领域逻辑在这个方法\n    private void validate(OrgDto request) {\n        final var tenant = request.getTenant();\n\n        // 租户必须有效\n        if (!tenantRepository.existsByIdAndStatus(tenant, TenantStatus.EFFECTIVE)) {\n            throw new BusinessException(\"id为'\" + tenant \n                          + \"'的租户不是有效租户！\");\n        }\n\n        // 组织类别不能为空\n        if (isBlank(request.getOrgType())) {\n            throw new BusinessException(\"组织类别不能为空！\");\n        }\n\n        // 企业是在创建租户的时候创建好的，因此不能单独创建企业\n        if (\"ENTP\".equals(request.getOrgType())) {\n            throw new BusinessException(\"企业是在创建租户的时候创建好的，因此不能单独创建企业!\");\n        }\n\n        // 组织类别必须有效\n        if (!orgTypeRepository.existsByCodeAndStatus(tenant, request.getOrgType(), OrgTypeStatus.EFFECTIVE)) {\n            throw new BusinessException(\"'\" + request.getOrgType() \n                          + \"'不是有效的组织类别代码！\");\n        }\n\n\n        // 上级组织应该是有效组织\n        Org superior = orgRepository.findByIdAndStatus(tenant\n                        , request.getSuperior(), OrgStatus.EFFECTIVE)\n                .orElseThrow(() -&gt;\n                        new BusinessException(\"'\" + request.getSuperior() \n                                + \"' 不是有效的组织 id !\"));\n\n\n        // 取上级组织的组织类别\n        OrgType superiorOrgType = orgTypeRepository.findByCodeAndStatus(tenant\n                        , superior.getOrgType()\n                        , OrgTypeStatus.EFFECTIVE)\n                .orElseThrow(() -&gt;\n                        new DirtyDataException(\"id 为 '\" \n                            + request.getSuperior()\n                            + \"' 的组织的组织类型代码 '\" \n                            + superior.getOrgType() + \"' 无效!\"));\n          \n        // 开发组的上级只能是开发中心                  \n        if (\"DEVGRP\".equals(request.getOrgType()) &amp;&amp; !\"DEVCENT\".equals(superiorOrgType.getCode())) {\n            throw new BusinessException(\"开发组的上级(id = '\" \n                + request.getSuperior() + \"')不是开发中心！\");\n        }\n\n        // 开发中心和直属部门的上级只能是企业\n        if ((\"DEVCENT\".equals(request.getOrgType()) || \"DIRDEP\".equals(request.getOrgType()))\n                &amp;&amp; !\"ENTP\".equals(superiorOrgType.getCode())) {\n            throw new BusinessException(\"开发中心或直属部门的上级(id = '\" \n                          + request.getSuperior() + \"')不是企业！\");\n        }\n\n\n        // 组织负责人可以空缺，如果有的话，的必须是一个在职员工（含试用期）\n        if (request.getLeader() != null\n                &amp;&amp; !empRepository.existsByIdAndStatus(tenant, request.getLeader()\n                , EmpStatus.REGULAR, EmpStatus.PROBATION)) {\n            throw new BusinessException(\"组织负责人(id='\" \n                      + request.getLeader() + \"')不是在职员工！\");\n        }\n\n        // 组织必须有名称\n        if (isBlank(request.getName())) {\n            throw new BusinessException(\"组织没有名称！\");\n        }\n\n        // 同一个组织下的下级组织不能重名\n        if (orgRepository.existsBySuperiorAndName(tenant, request.getSuperior(), request.getName())) {\n            throw new BusinessException(\"同一上级下已经有名为'\" \n                + request.getName() + \"'的组织存在！\");\n        }\n    }\n\n}\n</code></pre><!-- [[[read_end]]] --><p>浏览了一下这个代码后，你会不会在直觉上已经觉得有什么不妥了呢？</p><p>先说说我的看法。首先，第39行开始的 validate() 这个用于校验的方法有80行，太长了。从“重构”角度，这是一种“坏味道”，叫做<strong>过长的函数</strong>。</p><p>“坏味道”（smell）是Martin Fowler在《重构》一书中提出的说法，指的是一眼就能看出来的，烂代码的征兆。当然，由于只是征兆，也说不定再多看几眼发现并没有问题。</p><p>一般来说，函数一旦太长，就会不容易维护和测试。那么多长合适呢？业界并没有统一的说法。我个人的建议是，一般不要超过十行，最多不超过二十行。</p><p>你可能还注意到，为了补救由于方法太长导致的不容易理解的问题，程序里特意加了注释，说明实现的是哪条业务规则。</p><p>其实，最好的代码应该是本身写得足够清晰，以至于不需要注释；中等的代码是不太清晰，但是有注释，也能看懂；最差的代码是不但不清晰，还没有注释。我们的程序属于中等。在《重构》中，<strong>注释</strong>也算是一种坏味道，暴露了可能存在的代码不清晰问题。</p><p><strong>我们可以通过抽取函数这个重构手法，同时解决这两个坏味道。</strong>也就是说，把每一段校验逻辑抽成单独的方法。抽取之后是下面这样：</p><pre><code class=\"language-plain\">@Service\npublic class OrgService {\n    // 声明用到的 Repository...\n\n    @Autowired\n    public OrgService(UserRepository userRepository\n            , TenantRepository tenantRepository\n            , OrgRepository orgRepository\n            , EmpRepository empRepository\n            , OrgTypeRepositoryJdbc orgTypeRepository) {\n\n         //为注入的 Repository 赋值...\n    }\n\n    public OrgDto addOrg(OrgDto request, Long userId) {\n        validate(request);\n        Org org = buildOrg(request, userId);     \n        org = orgRepository.save(org);        \n        return buildOrgDto(org);\n    }\n    \n    private OrgDto buildOrgDto(Org org) {\n       //将领域对象转成DTO...\n    }\n\n    private Org buildOrg(OrgDto request, Long userId) {\n       //将DTO转成领域对象...\n    }\n   \n    //把各业务规则抽成了方法\n    private void validate(OrgDto request) {\n\n        final Long tenant = request.getTenant();\n\n        tenantShouldValid(tenant);\n       \n        leaderShouldBeEffective(tenant, request.getLeader());\n\n        //为了避免这个方法太长，把一些规则进一步分了组\n        verifyOrgType(tenant, request.getOrgType());\n        validateSuperior(tenant, request.getSuperior(), request.getOrgType());\n        verifyOrgName(tenant, request.getName(), request.getSuperior());\n    }\n\n    // 租户必须有效\n    private void tenantShouldValid(Long tenant) {\n        //...\n    }\n\n    // 组织负责人可以空缺，如果有的话，的必须是一个在职员工（含试用期）\n    private void leaderShouldBeEffective(Long tenant, Long leader) {\n        //...\n    }\n    \n    //校验组织类别的规则分组\n    private void verifyOrgType(Long tenant, String orgType) {\n        orgTypeShouldNotEmpty(orgType);\n        orgTypeShouldBeValid(tenant, orgType);\n        shouldNotCreateEntpAlone(orgType);\n    }\n\n    // 组织类别不能为空\n    private void orgTypeShouldNotEmpty(String orgType) {\n        //...\n    }\n    \n    // 组织类别必须有效\n    private void orgTypeShouldBeValid(Long tenant, String orgType) {\n        //...\n    }\n    \n    // 企业是在创建租户的时候创建好的，因此不能单独创建企业\n    private void shouldNotCreateEntpAlone(String orgType) {\n        //...\n    }\n\n\n    //校验上级组织的规则分组\n    private void validateSuperior(Long tenant, Long superior, String orgType) {\n        Org superiorOrg = superiorShouldEffective(tenant, superior);\n        OrgType superiorOrgType = findSuperiorOrgType(tenant, superior, superiorOrg);\n        superiorOfDevGroupMustDevCenter(superior, orgType\n                                        , superiorOrgType);\n        SuperiorOfDevCenterAndDirectDeptMustEntp(superior, orgType\n                                        , superiorOrgType);\n    }\n\n    // 上级组织应该是有效\n    private Org superiorShouldEffective(Long tenant, Long superior) {\n        //...\n    }\n\n    private OrgType findSuperiorOrgType(Long tenant, Long superior, Org superiorOrg) {\n        //...\n    }\n    \n    // 开发中心和直属部门的上级只能是企业\n    private void SuperiorOfDevCenterAndDirectDeptMustEntp(Long superior, String orgType, OrgType superiorOrgType) {\n        //...\n    }\n    \n    // 开发组的上级只能是开发中心\n    private void superiorOfDevGroupMustDevCenter(Long superior, String orgType, OrgType superiorOrgType) {\n        //...\n    }\n\n    // 校验组织名称的规则分组\n    private void verifyOrgName(Long tenant, String name, Long superior) {\n        orgNameShouldNotEmpty(name);\n        nameShouldNotDuplicatedInSameSuperior(tenant, superior, name);\n    }\n    \n    // 组织必须有名称\n    private void orgNameShouldNotEmpty(String name) {\n        //...\n    }\n\n    // 同一个上级下的组织不能重名\n    private void nameShouldNotDuplicatedInSameSuperior(Long tenant, Long superior, String name) {\n        //...\n    }\n}\n</code></pre><p>你看，我们不但把每个规则都抽成了独立的方法，而且每个方法都按含义进行了命名。比如说“租户必须有效”这个规则的方法名就是 “tenantShouldValid”。DDD强调，每个类和方法的命名都应该尽量直观地反映领域知识，与统一语言保持一致。这种做法也是DDD的一个模式，叫做 “Intention-Revealing Interfaces”，可以译作<strong>表意接口</strong>。我们一定要意识到，初学者往往不重视命名，越是高手，越重视命名。</p><p>有了<strong>表意接口</strong>，如果是英语国家的程序员，就不需要加注释了。上面的程序里仍然有注释，是考虑到多数中国人读中文更快。这是实践中的妥协，不是命名不好造成的。</p><p>由于规则比较多，即使把每个规则都抽出来，validate方法还是有点长，所以我们又为其中一些规则分了组。</p><h2>“领域服务”（Domain Service）模式</h2><p>抽取了<strong>表意接口</strong>，我们再考虑下一个问题：实现校验规则的那些方法，放对地方了吗？</p><p>业务规则是领域知识，按照DDD的思路，应该放在<strong>领域层</strong>才对，而现在却在<strong>应用层</strong>。为了解决这个问题，我们创建一个叫OrgValidator的类，也就是<strong>组织校验器</strong>，把规则都放到这个类里面，通过一个统一的validate() 方法来调用。然后，把OrgValidator放到领域层。程序结构变成下面这样：<br>\n<img src=\"https://static001.geekbang.org/resource/image/1d/56/1d6094f0ecf16f6aaed471758312f156.jpg?wh=2900x2018\" alt=\"\"></p><p>为了避免OrgValidator过于庞大，我们又进一步拆成几个小的 Validator，通过依赖注入，注入到 OrgValidator 中。现在，OrgService 变成下面的样子：</p><pre><code class=\"language-java\">package chapter11.unjuanable.application.orgmng;\n// imports...\n\n@Service\npublic class OrgService {\n    private final OrgValidator validator;  //代替了原来多个 Repository\n    private final OrgRepository orgRepository;\n\n    @Autowired\n    public OrgService(OrgValidator validator\n              , OrgRepository orgRepository) {\n        // 为依赖注入赋值...\n    }\n\n    public OrgDto addOrg(OrgDto request，Long userId) {\n        validator.validate(request); // 代替原来的 validate() 方法调用\n        Org org = buildOrg(request, userId);\n        org = orgRepository.save(org);\n        return buildOrgDto(org);\n    }\n\n    private OrgDto buildOrgDto(Org org) {\n       //将领域对象转成DTO...\n    }\n\n    private Org buildOrg(OrgDto request, Long userId) {\n       //将DTO转成领域对象...\n    }\n</code></pre><p>现在整个类比原来小多了，依赖注入的组件数量也比原来少了三个。再看一下OrgValidator的样子：</p><pre><code class=\"language-java\">package chapter11.unjuanable.domain.orgmng; //位于领域层\n// imports...\n\n@Component\npublic class OrgValidator {\n    //依赖更小的 Validator，也就是更小的规则分组\n    private final CommonValidator commonValidator;\n    private final OrgTypeValidator orgTypeValidator;\n    private final SuperiorValidator superiorValidator;\n    private final OrgNameValidator orgNameValidator;\n    private final OrgLeaderValidator orgLeaderValidator;\n\n    @Autowired\n    public OrgValidator(CommonValidator commonValidator\n            , OrgTypeValidator orgTypeValidator\n            , SuperiorValidator superiorValidator\n            , OrgNameValidator orgNameValidator\n            , OrgLeaderValidator) {\n        // 为依赖注入的组件赋值...\n    }\n\n    public void validate(OrgDto request) {\n        final Long tenant = request.getTenant();\n\n        commonValidator.tenantShouldValid(tenant);\n        orgLeaderValidator.verfy(tenant, request.getLeader;\n        orgTypeValidator.verify(tenant, request.getOrgType());\n        superiorValidator.verify(tenant, request.getSuperior()\n                              , request.getOrgType());\n        orgNameValidator.verify(tenant, request.getName()\n                              , request.getSuperior());\n    }\n}\n</code></pre><p>之所以要把业务规则移动到领域层，本质原因是业务规则属于“领域逻辑”，表达了领域知识。相应地，一般把应用层的逻辑称为“应用逻辑”。看到这儿，你可能会问，领域逻辑和应用逻辑的区别到底是什么呢？</p><p>首先要承认，这两者有时候确实有些模糊地带。不过还是有一个总的思路：<strong>如果一个逻辑需要和领域专家讨论才能确认的，就是领域逻辑；如果领域专家根本不感兴趣的，多半就是应用逻辑。</strong></p><p>比如说，Validator中的各种校验规则，都是与领域专家澄清的，所以属于领域逻辑。而 OrgService里，怎么进行DTO和领域对象之间的转换，怎么把数据保存到数据库，都是领域专家不关心的，因此属于应用逻辑。</p><p>这里的各种 Validator也是DDD中的一个模式，叫做<strong>领域服务</strong>（domain service）。这个模式的思路是这样的：按照面向对象的做法，领域逻辑本来最好放到领域对象中去，不过有些逻辑又不适合放到领域对象，这时，干脆放到一些只有方法，没有状态的类里面。给这些类取个名字，就叫<strong>领域服务</strong>吧。</p><p>在我们现在的例子里，校验规则没有放到领域对象的原因有两个：</p><p>1.为了保持领域对象与数据库的解偶，我们希望领域对象不要访问数据库，而有些校验规则要访问数据库；</p><p>2.我们目前采用的还是偏过程的方式。</p><p>还有一点要提一下，我发现一些小伙伴喜欢统一用XxxDomainSerivce的方式给领域服务命名，这似乎有些拘泥了。我建议最好按照含义来命名，比如这里就用了XxxValidator的名字。</p><h2>“工厂”（Factory）模式</h2><p>处理完业务规则，我们再来聊一下DDD建议的创建领域对象的方法。</p><p>DDD认为，领域对象的创建逻辑也是领域层的一部分。如果创建领域对象的逻辑比较简单，可以直接用对象的构造器来实现。但是如果比较复杂，就应该把创建逻辑放到一个专门的机制里，来保证领域对象的简洁和聚焦。</p><p>这里说的专门机制可以是一个方法或者一个类，可以有很多种实现方式。不论具体方式是什么，在 DDD里统称为<strong>工厂</strong>（Factory）模式。准确地说，工厂其实是用来创建<strong>聚合</strong>的，由于我们在迭代二才会讲到聚合模式，所以这里先粗略地认为工厂是创建对象的。工厂和前面说的仓库这两个模式，其实是一种隐喻（metaphor）：<strong>用工厂来创造产品，然后存到仓库</strong>。</p><p>所谓创建逻辑复杂，包括两方面：一是规则复杂，二是结构复杂。DDD认为用于校验的领域逻辑也属于创建过程的一部分，因此我们目前的例子主要是规则复杂。等到后面我们创建复杂<strong>聚合</strong>的时候，可能会遇到结构复杂的问题。</p><p>现在我们创建一个叫做OrgFactory的类，里面只有一个build() 方法，用来创建Org对象。代码是下面的样子：</p><pre><code class=\"language-java\">package chapter11.unjuanable.domain.orgmng; //工厂在领域层\n//imports...\n\n@Component\npublic class OrgFactory {\n    private final OrgValidator validator;\n\n    @Autowired\n    public OrgFactory(OrgValidator validator) {\n        this.validator = validator;\n    }\n\n    public Org build(OrgDto request, Long userId) {\n        validator.validate(request);\n        return buildOrg(request, userId);\n    }\n\n    private Org buildOrg(OrgDto request, Long userId) {\n        //DTO转换成领域对象\n    }\n}\n</code></pre><p>相应的，OrgService修改成这个样子：</p><pre><code class=\"language-java\">package chapter11.unjuanable.application.orgmng;\n//imports...\n\n@Service\npublic class OrgService {\n    //现在只需要注入工厂和仓库了\n    private final OrgFactory orgFactory;\n    private final OrgRepository orgRepository;\n\n    @Autowired\n    public OrgService(OrgFactory orgFactory\n            , OrgRepository orgRepository) {\n        //依赖注入赋值...\n    }\n\n    public OrgDto addOrg(OrgDto request, Long userId) {\n        //包含校验逻辑在内的创建逻辑都委托给了工厂\n        Org org = orgFactory.build(request, userId);\n       \n        org = orgRepository.save(org);\n        return buildOrgDto(org);\n    }\n\n    private static OrgDto buildOrgDto(Org org) {\n        //领域对象转换成DTO...\n    }\n    \n    //原来DTO转领域对象的逻辑也移到了工厂\n}\n</code></pre><p>到现在为止，好像还不错。不过你可能已经注意到，OrgFactory的build() 方法的参数类型是 OrgDto，而这个DTO是在应用层定义的，也就是领域层依赖了应用层，又一次破坏了层间依赖原则。</p><p>咱们来探讨几种可能的解决方案。</p><p><strong>第一种方案是把OrgDto的定义直接从应用层移动到领域层。</strong>这虽然解决了依赖问题，但 OrgDto是领域对象的“门面”，应该留在应用层，所以这种方案不可取。</p><p><strong>第二种方案是把DTO拆开，用基本类型来调用build() 方法。</strong>用于创建 Org 的基本类型参数其实一共有6个，所以可以像下面这样定义build()方法：</p><pre><code class=\"language-plain\">public Org build(Long tenant, Long superior, String orgType\n    , Long leader, private String name, Long userId) \n</code></pre><p>不过，太长的参数列表本身就是一种坏味道，容易出错而且不好理解。所以我建议只在参数不大于三个的时候采用这种方式。</p><p><strong>第三种方案是把上述6个参数再捏成一个DTO，在领域层中定义，专门作为工厂参数。</strong>这种方案没有大毛病，但显得有些繁琐。</p><p><strong>第四种方案是我们所建议的，就是采用Builder模式。</strong>下面我们就来看看Builder模式是怎么实现的。</p><p>我们会编写OrgBuilder代替刚才的OrgFactory， 写出来是这个样子：</p><pre><code class=\"language-plain\">package chapter11.unjuanable.domain.orgmng;\n// import...\n\npublic class OrgBuilder {\n    //用到的 validator\n    private final CommonValidator commonValidator;\n    private final OrgTypeValidator orgTypeValidator;\n    private final SuperiorValidator superiorValidator;\n    private final OrgNameValidator orgNameValidator;\n    private final OrgLeaderValidator orgLeaderValidator;\n\n    //用这些属性保存创建对象用到的参数\n    private Long tenantId;\n    private Long superiorId;\n    private String orgTypeCode;\n    private Long leaderId;\n    private String name;\n    private Long createdBy;\n\n    public OrgBuilder(CommonValidator commonValidator\n            , OrgTypeValidator orgTypeValidator\n            , SuperiorValidator superiorValidator\n            , OrgNameValidator orgNameValidator\n            , OrgLeaderValidator orgLeaderValidator) {\n        //注入各个 Validator... \n    }\n\n    // 为builder 的 tenant 属性赋值，然后返回自己，以便实现链式调用\n    public OrgBuilder tenantId(Long tenantId) {\n        this.tenantId = tenantId;\n        return this;\n    }\n    // 其他5个属性赋值与 tenantId 类似 ...\n    \n    public Org build() {\n        validate();\n\n        Org org = new Org();\n        org.setOrgTypeCode(this.orgTypeCode);\n        org.setLeaderId(this.leaderIc);\n        org.setName(this.name);\n        org.setSuperiorId(this.superiorId);\n        org.setTenantId(this.tenantId);\n        org.setCreatedBy(this.createdBy);\n        org.setCreatedAt(LocalDateTime.now());\n\n        return org;\n    }\n\n    private void validate() {\n        commonValidator.tenantShouldValid(tenantId);\n        orgTypeValidator.verify(tenantId, orgTypeCode);\n        superiorValidator.verify(tenantId, superiorId, orgTypeCode);\n        orgLeaderValidator.verify(tenantId, leaderId);\n        orgNameValidator.verify(tenantId, name, superiorId);\n    }\n}\n</code></pre><p>Builder其实也是<strong>工厂模式</strong>的一种实现方式，所以放在领域层。Builder接收到各个需要的参数值，保存到自己的属性中。在创建Org前先进行校验，然后真正创建。由于Builder起到了将各组校验规则组织起来的作用，所以原来的OrgValidator就不需要了。</p><p>由于OrgBuilder有可变属性，因此不能按单例注入到OrgService，所以我又写了一个单例的 OrgBuilderFactory负责创建OrgBuilder。代码比较简单，是下面的样子：</p><pre><code class=\"language-plain\">package chapter11.unjuanable.domain.orgmng;\n// imports...\n\n@Component\npublic class OrgBuilderFactory {\n    private final CommonValidator commonValidator;\n    private final OrgTypeValidator orgTypeValidator;\n    private final SuperiorValidator superiorValidator;\n    private final OrgNameValidator orgNameValidator;\n    private final OrgLeaderValidator orgLeaderValidator;\n\n    @Autowired\n    public OrgBuilderFactory(CommonValidator commonValidator\n            , OrgTypeValidator orgTypeValidator\n            , SuperiorValidator superiorValidator\n            , OrgNameValidator orgNameValidator\n            , OrgLeaderValidator orgLeaderValidator) {\n            //注入各个 Validator...\n    }\n    //每次调用都创建一个新的 OrgBuilder\n    public OrgBuilder create() {\n        return new OrgBuilder(commonValidator\n                , orgTypeValidator\n                , superiorValidator\n                , orgNameValidator\n                , orgLeaderValidator);\n    }\n}\n</code></pre><p>当然你也可以用Spring中prototype的方式来注入OrgBuilder，这样就不用自己写OrgBuilderFactory了。</p><p>下面再看看OrgService里怎样使用OrgBuilder：</p><pre><code class=\"language-plain\">package chapter11.unjuanable.application.orgmng;\n// imports...\n\n@Service\npublic class OrgService {\n    private final OrgBuilderFactory orgBuilderFactory;\n    private final OrgRepository orgRepository;\n\n    @Autowired\n    public OrgService(OrgBuilderFactory orgBuilderFactory\n            , OrgRepository orgRepository) {\n        //为依赖注入的属性赋值...\n    }\n\n    public OrgDto addOrg(OrgDto request) {\n        OrgBuilder builder = orgBuilderFactory.create();\n        //修改的部分在这里\n        Org org = builder.tenantId(request.getTenantId())\n                .orgTypeCode(request.getOrgTypeCode())\n                .leaderId(request.getLeaderId())\n                .superiorId(request.getSuperiorId())\n                .name(request.getName())\n                .createdBy(userid)\n                .build();\n\n        org = orgRepository.save(org);\n        return buildOrgDto(org);\n    }\n\n    private static OrgDto buildOrgDto(Org org) {\n        // 领域对象转换为DTO...\n    }\n}\n</code></pre><p>我们可以看到，比起<strong>方案二</strong>里，为工厂的build() 方法传递多个参数的方式，Builder的好处是无论参数有多少，含义都很明确，而且传递参数的顺序是任意的，不会因为参数顺序而出错。</p><h2>模块划分的“打横”与“打竖”</h2><p>现在来看一看领域层变成什么样了：<br>\n<img src=\"https://static001.geekbang.org/resource/image/2b/b2/2bb4b195318ee35d7b4e75b20290f2b2.jpg?wh=2900x2018\" alt=\"\"></p><p>经过咱们刚才一顿操作，组织管理（orgmng）这个模块下的类已经比较多了。尽管《重构》一书中没有明确说，但是一个包下有太多的类，也是一种常见的坏味道。那么多少算“多”呢，也没有明确的标准，不过根据心理学的认知负载理论，我建议，一个包里的类和子包的数量加在一起，最好不要超过9个。</p><p>那么怎么分子包呢？你可能注意到了这些类里，有些是实体，有些是仓库，有些是工厂，有些是领域服务，所以很多小伙伴会这么分：<br>\n<img src=\"https://static001.geekbang.org/resource/image/00/01/00a6b41bc349be1fe3cfbaf0c2d22b01.jpg?wh=2900x2018\" alt=\"\"></p><p>我们分了entity、repository、factory和domainservice几个子包，然后把各个类移进去。看起来也挺清晰的吧？这里，我们采用了<strong>搬移类</strong>这种重构手法。</p><p>那么，有没有其他选择呢？让我们看一种不同的分法：<br>\n<img src=\"https://static001.geekbang.org/resource/image/91/ac/9169f8de9b681fa689ecb77f59ab41ac.jpg?wh=2900x2018\" alt=\"\"></p><p>这里，我在组织管理（orgmng）包为每个实体分了一个子包，然后把与每个实体相关的类移了进去。</p><p>咱们细品一下，这两种方法的区别在哪里？</p><p>第一种方法是按照<strong>类的“性质”</strong>来分的。OrgRepository和EmpRepository在性质上都属于 Repository，所以把它们放在同一个包，至于它们之间有没有调用关系，并不重要。</p><p>第二种是按照<strong>耦合关系</strong>来分。OrgRepository中方法的参数用到了Org类，说明这两个类型之间有耦合关系，所以把它们放在同一个包，尽管它们的性质不一样，一个是实体，一个是仓库。</p><p>这两种方式没有绝对的对错，需要进行权衡。比如说，分层架构其实就是按性质来分的。<strong>应用层</strong>的<strong>应用服务</strong>，之所以在同一个包里面，并不是因为他们之间有耦合关系，而是因为他们都是领域对象的“门面”。</p><p>事实上，<strong>一个应用服务和调用它的控制器以及被它调用的领域对象之间才具有耦合性</strong>。分层架构把本来耦合的几个对象拆到了不同的包。之所以我们在分层架构中采用按性质分包的方式，是因为，将领域逻辑与其非领域逻辑分离，以及将技术相关和无关两部分分离，这两个“关注点分离”的好处实在太大，大过了破坏“松耦合高内聚”原则的代价。</p><p><strong>但是另一方面，在每个层次内部，我比较建议尽量按照耦合性分包</strong>。这是由于排除上述两个“关注点分离”以后，“松耦合高内聚”的好处就体现出来了。如果把按层次划分叫做“打横”分，把按耦合性划分叫做“打竖”分，咱们目前采取的是就是“先横后竖”的分法。</p><p>不过你可能又发现，上面org包下有9个类，似乎多了一点，不便理解，所以我们还可以再分一下。一种可行的办法是把validator单独分成一个包，像下面这样：<br>\n<img src=\"https://static001.geekbang.org/resource/image/d0/04/d09a45e85901474190fafa9918ae4904.jpg?wh=2900x2018\" alt=\"\"></p><p>各个validator之间未必有什么耦合关系，所以这里又是“打横”分了。在实际项目中，你可以参考上面的思路，作出自己的权衡。</p><h2>总结</h2><p>好，今天的内容先讲到这里，我们来总结一下。</p><p>这节课，主要讲的是领域逻辑的实现和领域对象的创建，此外还进一步探讨了程序里模块的划分问题。</p><p>对于实现领域逻辑的方法，我们应该用能够表达领域知识的词汇进行命名，这就是DDD的<strong>表意接口</strong>（Intention-Revealing Interfaces）模式。违反了表意接口模式，常常会出现<strong>过长的函数</strong>和<strong>注释</strong>这两个坏味道，我们可以通过<strong>抽取函数</strong>这个重构手法进行了解决。</p><p>领域逻辑应该放在领域层，不属于领域逻辑的代码逻辑通常称为“应用逻辑”。“应用逻辑”和“领域逻辑”的本质区别在于是否蕴含着领域专家关心的领域知识。我们应该首先考虑把领域逻辑放在领域对象里。但那些不适合放到领域对象的逻辑，可以放在<strong>领域服务</strong>。</p><p>对于复杂领域对象的创建，可以采用DDD的<strong>工厂（Factory）模式</strong>。这个模式有多种实现方式，对于参数较少的情况，可以直接用参数调用工厂，参数较多时，则可以采用Builder模式。</p><p>最后，程序里模块的划分方式，有按性质分和按耦合分两种，通俗地说就是“打横”分和“打竖”分，我们建议采用“先横后竖”的方法。</p><h2>思考题</h2><p>1.如果实现某个业务规则的代码只有一行，还值得抽成单独的方法吗？</p><p>2.我们在实现Validator的时候，并没有用到Java中的“接口”，但为什么这个模式还叫<strong>表意接口</strong>呢？</p><p>好，今天的课程结束了，有什么问题欢迎在评论区留言，下节课，我们继续聊聊“封装”的问题，并从另一个角度理解一下应用服务和领域服务的区别。</p>","comments":[{"had_liked":false,"id":365466,"user_name":"赵晏龙","can_delete":false,"product_type":"c1","uid":2673605,"ip_address":"广东","ucode":"F15730BCA97EE0","user_header":"https://static001.geekbang.org/account/avatar/00/28/cb/c5/c1d7ca5e.jpg","comment_is_top":false,"comment_ctime":1672624416,"is_pvip":false,"replies":[{"id":133125,"content":"全中👍🏻","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1672633294,"ip_address":"广东","comment_id":365466,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"1你问我值不值？我当然说值！代码即文档\n2表意接口的接口只是个概念，不是编程语言中的interface。","like_count":19,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598153,"discussion_content":"全中👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672633294,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365231,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1015222,"ip_address":"广东","ucode":"27EB4A725CE14E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/b6/abdebdeb.jpg","comment_is_top":false,"comment_ctime":1672287236,"is_pvip":false,"replies":[{"id":133041,"content":"两个问题都回答得很到位 👍🏻\n隐喻实际上就是初中学修辞时学的“暗喻”或“打比方”，以便容易理解概念。比如说把多台计算机连起来，这个概念不好理解，但“网”这个词自古就有，那么说成计算机网络就好理解了。计算机连起来，和原来的渔网，蜘蛛网等本来没关系，这里是用“网”来打比方。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1672294275,"ip_address":"广东","comment_id":365231,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"问题1.值得\n从代码维护的角度说，抽方法可以用方法名来表意\n从代码设计上说，方法也是一种抽象，应该依赖抽象而不是实现\n问题2.这里的接口指的是抽象，不是编程语言里的语言特性，应该跟语言无关\n\n关于隐喻，想请教老师，到底什么是隐喻呢？看徐老师的业务建模，他也提到为系统找到一个简洁的隐喻来解决问题之类的，不是很懂，老师可否再解释解释","like_count":8,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":597875,"discussion_content":"两个问题都回答得很到位 👍🏻\n隐喻实际上就是初中学修辞时学的“暗喻”或“打比方”，以便容易理解概念。比如说把多台计算机连起来，这个概念不好理解，但“网”这个词自古就有，那么说成计算机网络就好理解了。计算机连起来，和原来的渔网，蜘蛛网等本来没关系，这里是用“网”来打比方。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1672294275,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":378057,"user_name":"瀚海","can_delete":false,"product_type":"c1","uid":2062203,"ip_address":"上海","ucode":"E64C22F3F6D285","user_header":"https://static001.geekbang.org/account/avatar/00/1f/77/7b/338c4617.jpg","comment_is_top":false,"comment_ctime":1689696160,"is_pvip":false,"replies":[{"id":138091,"content":"factory主要不是为了层间依赖，而是为了把复杂的创建逻辑抽出来。课程里也给了另一种方法：assembler.","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1691070495,"ip_address":"广东","comment_id":378057,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"感觉为了DTO类不破坏层间依赖关系，而引入builder、factory实在过于重了         ","like_count":4,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":624932,"discussion_content":"factory主要不是为了层间依赖，而是为了把复杂的创建逻辑抽出来。课程里也给了另一种方法：assembler.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1691070495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365262,"user_name":"虚竹","can_delete":false,"product_type":"c1","uid":1691109,"ip_address":"广东","ucode":"8D8C96C793724E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJIocn8OMjfSGqyeSJEV3ID2rquLR0S6xo0ibdNYQgzicib6L6VlqWjhgxOqD2iaicX1KhbWXWCsmBTskA/132","comment_is_top":false,"comment_ctime":1672303187,"is_pvip":false,"replies":[{"id":133061,"content":"这样也是一种可行的选择。下节课还会有另一种方法，稍微牺牲一些封装性","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1672365391,"ip_address":"广东","comment_id":365262,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"builder模式用起来还是过于繁琐，因为实际业务参数可能很多，我们更可能选择将DTO对象定义下沉，通过内层包或者类名后缀知道它是用于应用层的","like_count":4,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":597935,"discussion_content":"这样也是一种可行的选择。下节课还会有另一种方法，稍微牺牲一些封装性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672365391,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1263932,"avatar":"https://static001.geekbang.org/account/avatar/00/13/49/3c/5d54c510.jpg","nickname":"skull","note":"","ucode":"0A8600CB928EFE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":620599,"discussion_content":"DTO下沉也不好，就在应用层加一个assembler或者converter包","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1686305920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2673605,"avatar":"https://static001.geekbang.org/account/avatar/00/28/cb/c5/c1d7ca5e.jpg","nickname":"赵晏龙","note":"","ucode":"F15730BCA97EE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598145,"discussion_content":"同感这个模式有点杀鸡用牛刀了，实际可能还要根据情况有选择的用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672624485,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"湖南","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":367648,"user_name":"Ice","can_delete":false,"product_type":"c1","uid":1082095,"ip_address":"四川","ucode":"B2C0AD8F970981","user_header":"https://static001.geekbang.org/account/avatar/00/10/82/ef/0badf9dc.jpg","comment_is_top":false,"comment_ctime":1675401917,"is_pvip":false,"replies":[{"id":133955,"content":"也是一种可行的思路，不过这样可能导致DTO为了满足各个层面的传输要求而变得复杂，要慎重一点。最好不要让领域层依赖这个意义上的DTO。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1675642980,"ip_address":"广东","comment_id":367648,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"DTO是否可以放到common中作为支撑层被各层引用？","like_count":2,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":602050,"discussion_content":"也是一种可行的思路，不过这样可能导致DTO为了满足各个层面的传输要求而变得复杂，要慎重一点。最好不要让领域层依赖这个意义上的DTO。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675642980,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366075,"user_name":"老狗","can_delete":false,"product_type":"c1","uid":1540332,"ip_address":"广东","ucode":"80927B4D31CFCE","user_header":"https://static001.geekbang.org/account/avatar/00/17/80/ec/b6149cbf.jpg","comment_is_top":false,"comment_ctime":1673360020,"is_pvip":false,"replies":[{"id":133385,"content":"哈哈，说得对","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1673408465,"ip_address":"广东","comment_id":366075,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"最可怕的是有注释但是注释说的跟代码不是一回事","like_count":2,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":599222,"discussion_content":"哈哈，说得对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673408465,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365268,"user_name":"KOK体育手机APP苹果","can_delete":false,"product_type":"c1","uid":1784904,"ip_address":"广东","ucode":"161DED169FA957","user_header":"https://static001.geekbang.org/account/avatar/00/1b/3c/48/cae1fd01.jpg","comment_is_top":false,"comment_ctime":1672304644,"is_pvip":false,"replies":[{"id":133063,"content":"会，但没这么快","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1672365757,"ip_address":"广东","comment_id":365268,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"老师，课程中涉及到的代码，会开源出来放在github上吗？","like_count":2,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":597937,"discussion_content":"会，但没这么快","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672365758,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":1107146,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e4/ca/55d59c29.jpg","nickname":"ladybug","note":"","ucode":"BD5D485E5CC527","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":609785,"discussion_content":"啥时候有源码呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679210801,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":597937,"ip_address":"北京","group_id":0},"score":609785,"extra":""},{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":1107146,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e4/ca/55d59c29.jpg","nickname":"ladybug","note":"","ucode":"BD5D485E5CC527","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609905,"discussion_content":"https://github.com/zhongjinggz/geekdemo 目前放出了迭代1的，后面的正在逐渐补充","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679293241,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":609785,"ip_address":"北京","group_id":0},"score":609905,"extra":""}]}]},{"had_liked":false,"id":366462,"user_name":"6点无痛早起学习的和尚","can_delete":false,"product_type":"c1","uid":1703256,"ip_address":"北京","ucode":"33A8A1CDA103F9","user_header":"https://static001.geekbang.org/account/avatar/00/19/fd/58/1af629c7.jpg","comment_is_top":false,"comment_ctime":1673833790,"is_pvip":false,"replies":[{"id":133668,"content":"3.原则是一个类不要太大，要关注点分离，至于怎么分，可以斟酌，你可以看看有没有其他方案\n4.首先，DTO和实体不一样，DTO只传数据，不应该有业务规则。至于是否放在实体，原则是优先考虑放在实体，不行的话再放领域服务。之所以我们现在放在领域服务，是因为我们约定了实体不访问数据库，而这些逻辑要访问数据库。如果约定实体也可以访问数据库，那么有些逻辑放在实体也可以\n5.是的，要权衡。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1674449902,"ip_address":"广东","comment_id":366462,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"一些问题：\n3. 这里的校验规则是否又分的太多类了，是否直接用一个类里封装校验规则即可\n4. 为什么不把校验规则放到相应的 Dto 实体类里去，而去单独去抽离一个“领域服务”模式\n5. 用复杂的 Builder 模式去创建领域对象，有点太复杂了，实际项目中，应该不会采用这种方式，为了完全依赖关系去牺牲代码编码性，这个实际上需要权衡。","like_count":1,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600494,"discussion_content":"3.原则是一个类不要太大，要关注点分离，至于怎么分，可以斟酌，你可以看看有没有其他方案\n4.首先，DTO和实体不一样，DTO只传数据，不应该有业务规则。至于是否放在实体，原则是优先考虑放在实体，不行的话再放领域服务。之所以我们现在放在领域服务，是因为我们约定了实体不访问数据库，而这些逻辑要访问数据库。如果约定实体也可以访问数据库，那么有些逻辑放在实体也可以\n5.是的，要权衡。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1674449902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365901,"user_name":"张逃逃","can_delete":false,"product_type":"c1","uid":1435550,"ip_address":"广东","ucode":"DBF3A573CDF7DB","user_header":"https://static001.geekbang.org/account/avatar/00/15/e7/9e/5853da22.jpg","comment_is_top":false,"comment_ctime":1673187038,"is_pvip":false,"replies":[{"id":133298,"content":"作为适配器的Repository应该单纯一点，就是数据访问，其他什么都不做。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1673238926,"ip_address":"广东","comment_id":365901,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"有个疑问请教老师，为什么不把Validator的逻辑封装到Repository？","like_count":1,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598957,"discussion_content":"作为适配器的Repository应该单纯一点，就是数据访问，其他什么都不做。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673238926,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1588683,"avatar":"https://static001.geekbang.org/account/avatar/00/18/3d/cb/791d0f5e.jpg","nickname":"猴哥","note":"","ucode":"63A1BFDF13D85D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":649640,"discussion_content":"Validator属于领域逻辑，所以不适合Repository","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1723687591,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365323,"user_name":"曦","can_delete":false,"product_type":"c1","uid":1611688,"ip_address":"广东","ucode":"C07F7FB786BECF","user_header":"https://static001.geekbang.org/account/avatar/00/18/97/a8/2a7b537f.jpg","comment_is_top":false,"comment_ctime":1672369697,"is_pvip":false,"replies":[{"id":133250,"content":"你实际上问了两个层面的问题，一个是同一个上下文中，跨聚合的领域逻辑；另一个是跨上下文的领域逻辑。\n\n关于跨聚合的逻辑，直接在领域服务中实现就可以了。如果您觉得这样做有问题，请举一个具体的例子来谈。\n\n关于跨上下文的领域逻辑，可以引入上下文映射和防腐层来解决。这个问题咱们在第三迭代，讲限界上下文的时候再谈。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1673059071,"ip_address":"广东","comment_id":365323,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"过去，单纯的以为领域服务就是XxxDomainService，然后在这个类中封闭很多方法。看了老师的解释，恍然大悟。但是，在实践的过程中，有一些业务规则，是需要通过不同的上下文或者聚合交互验证实现的，所以这些规则很难抽象到独立的、具体的某一个领域服务中，于是，一些原本属于领域层的知识在应用层进行了组合，这使得应用层又特别的臃肿且破坏了分层也只能边界，这种情况，老师要如何解决？或者类似的解决方案？","like_count":1,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598759,"discussion_content":"你实际上问了两个层面的问题，一个是同一个上下文中，跨聚合的领域逻辑；另一个是跨上下文的领域逻辑。\n\n关于跨聚合的逻辑，直接在领域服务中实现就可以了。如果您觉得这样做有问题，请举一个具体的例子来谈。\n\n关于跨上下文的领域逻辑，可以引入上下文映射和防腐层来解决。这个问题咱们在第三迭代，讲限界上下文的时候再谈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673059071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":1033630,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c5/9e/d6fce09c.jpg","nickname":"暴走的🐌","note":"","ucode":"804381D877E53C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":626210,"discussion_content":"跨聚合用领域服务，领域服务就没法收归在聚合根里，代码不知道放哪里了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1692645831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":598759,"ip_address":"江苏","group_id":0},"score":626210,"extra":""},{"author":{"id":1033630,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c5/9e/d6fce09c.jpg","nickname":"暴走的🐌","note":"","ucode":"804381D877E53C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":626211,"discussion_content":"还有一点聚合之间调用总觉得怪怪的，虽然符合六边形架构，但同层调用很容易出现循环依赖","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1692647084,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":598759,"ip_address":"江苏","group_id":0},"score":626211,"extra":""}]}]},{"had_liked":false,"id":392318,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"广东","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/d1ab239e.jpg","comment_is_top":false,"comment_ctime":1720593608,"is_pvip":false,"replies":[{"id":143661,"content":"目前是可以的。不过聚合根的setter放开通常也没问题。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1731485201,"ip_address":"广东","comment_id":392318,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"老师，咨询下，这里OrgBuilder和Org既然在同一个包下，为什么setName这个Org方法还需要使用public呢？包级权限是不是更合适？","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":653858,"discussion_content":"目前是可以的。不过聚合根的setter放开通常也没问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1731485201,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":390607,"user_name":"Geek_ac7a29","can_delete":false,"product_type":"c1","uid":1055922,"ip_address":"江苏","ucode":"EB54F322A9B25B","user_header":"https://static001.geekbang.org/account/avatar/00/10/1c/b2/1fe3dcc8.jpg","comment_is_top":false,"comment_ctime":1715759577,"is_pvip":false,"replies":[{"id":143675,"content":"你说得对，这个地方有问题。我这几天会把新的代码放到github ,到时你再看一下。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1731548012,"ip_address":"广东","comment_id":390607,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"老师，领域层OrgValidator引用应用层的orgDTO的是不是有问题？","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":653896,"discussion_content":"你说得对，这个地方有问题。我这几天会把新的代码放到github ,到时你再看一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1731548013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":389306,"user_name":"掂过碌蔗","can_delete":false,"product_type":"c1","uid":2275516,"ip_address":"广东","ucode":"6D9080A2B225AE","user_header":"https://static001.geekbang.org/account/avatar/00/22/b8/bc/5f4c9cb2.jpg","comment_is_top":false,"comment_ctime":1712070417,"is_pvip":false,"replies":[{"id":141722,"content":"共同进步","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1712833638,"ip_address":"广东","comment_id":389306,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"写的太好了，很多问题都是写代码真实遇到的问题。之前一直以为只有我有这个困惑。","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":641633,"discussion_content":"共同进步","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1712833638,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":387354,"user_name":"雷欧","can_delete":false,"product_type":"c1","uid":3791507,"ip_address":"浙江","ucode":"C3B2752243432C","user_header":"https://static001.geekbang.org/account/avatar/00/39/da/93/51ef18f6.jpg","comment_is_top":false,"comment_ctime":1707044604,"is_pvip":false,"replies":[{"id":141221,"content":"使用构造器注入是Spring推荐 的最佳实践。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1708162111,"ip_address":"广东","comment_id":387354,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"private final CommonValidator commonValidator; 为什么要用final修饰，然后再用@Autowired通过构造器注入\n\n直接\n@Autowired\nprivate final CommonValidator commonValidator不行么","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":637238,"discussion_content":"使用构造器注入是Spring推荐 的最佳实践。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1708162111,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":381258,"user_name":"末日，成欢","can_delete":false,"product_type":"c1","uid":1812201,"ip_address":"陕西","ucode":"BBAEBB9C93558A","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLm8skz4F7FGGBTXWUMia6qVEc00BddeXapicv5FkAx62GmOnUNEcE4scSR60AmappQoNdIQhccKsBA/132","comment_is_top":false,"comment_ctime":1694929187,"is_pvip":false,"replies":[{"id":138950,"content":"1.书里写的服务和本文中的领域服务是一个东西吗？\n【答】书里的服务包含“领域服务”“应用服务”“基础设施服务”三种\n2.有些操作从本质上讲是一些活动或动作，而不是事物, 故这些操作从概念上讲不属于任何对象。\n那么在本文中,添加组织中,校验组织的这个操作,从本质上不应该属于组织这个领域对象吗？还是因为它牵扯到了很多领域对象, 故将其放到领域服务中了？\n【答】把这些逻辑写在领域对象里面的话，可能造成领域对象无谓的复杂，所以把逻辑剥离出来。\n如果强行将这个操作要放到领域对象中的话, 是不是组织对象必须存在租户和上级组织的引用是吗？\n【答】是\n3.我的理解是领域服务和工厂模式甚至是可以互相取代的,领域模式如果已经把所有的校验逻辑都做完了, 就单单进行转化, 哪怕参数过多,一个一个赋值也可以不用工厂模式把？\n那对于我的理解来说, 工厂模式创建领域对象, 业务规则复杂的时候, 我放到领域服务中,只有当结构复杂的时候,我在用工厂是不是也可行？\n【答】可行","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1695268664,"ip_address":"广东","comment_id":381258,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"老师,对领域服务也存在一些困惑, 看了下书,感觉有点迷惑\n1.书里写的服务和本文中的领域服务是一个东西吗？\n2.有些操作从本质上讲是一些活动或动作，而不是事物, 故这些操作从概念上讲不属于任何对象。\n那么在本文中,添加组织中,校验组织的这个操作,从本质上不应该属于组织这个领域对象吗？还是因为它牵扯到了很多领域对象, 故将其放到领域服务中了？\n如果强行将这个操作要放到领域对象中的话, 是不是组织对象必须存在租户和上级组织的引用是吗？\n3.我的理解是领域服务和工厂模式甚至是可以互相取代的,领域模式如果已经把所有的校验逻辑都做完了, 就单单进行转化, 哪怕参数过多,一个一个赋值也可以不用工厂模式把？\n那对于我的理解来说, 工厂模式创建领域对象, 业务规则复杂的时候, 我放到领域服务中,只有当结构复杂的时候,我在用工厂是不是也可行？","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":628384,"discussion_content":"1.书里写的服务和本文中的领域服务是一个东西吗？\n【答】书里的服务包含“领域服务”“应用服务”“基础设施服务”三种\n2.有些操作从本质上讲是一些活动或动作，而不是事物, 故这些操作从概念上讲不属于任何对象。\n那么在本文中,添加组织中,校验组织的这个操作,从本质上不应该属于组织这个领域对象吗？还是因为它牵扯到了很多领域对象, 故将其放到领域服务中了？\n【答】把这些逻辑写在领域对象里面的话，可能造成领域对象无谓的复杂，所以把逻辑剥离出来。\n如果强行将这个操作要放到领域对象中的话, 是不是组织对象必须存在租户和上级组织的引用是吗？\n【答】是\n3.我的理解是领域服务和工厂模式甚至是可以互相取代的,领域模式如果已经把所有的校验逻辑都做完了, 就单单进行转化, 哪怕参数过多,一个一个赋值也可以不用工厂模式把？\n那对于我的理解来说, 工厂模式创建领域对象, 业务规则复杂的时候, 我放到领域服务中,只有当结构复杂的时候,我在用工厂是不是也可行？\n【答】可行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1695268664,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":381256,"user_name":"末日，成欢","can_delete":false,"product_type":"c1","uid":1812201,"ip_address":"陕西","ucode":"BBAEBB9C93558A","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLm8skz4F7FGGBTXWUMia6qVEc00BddeXapicv5FkAx62GmOnUNEcE4scSR60AmappQoNdIQhccKsBA/132","comment_is_top":false,"comment_ctime":1694927089,"is_pvip":false,"replies":[{"id":138948,"content":"1. 如果说我仅仅只有校验1-2个业务逻辑, 并且领域对象中没有这些所需的关联对象时,我也要搞一个工厂模型吗？\n是不是像上文那样直接放到领域服务就行了？\n【答】可以放在领域服务，不过如果一个领域服务的职责是创建对象的话，那么其实就是一个工厂了。\n2.假设我现在有一个这样的场景, 发送短信的场景, 类比文中的添加添加组织。\n它也存在需要很多校验,才能创建一个领域对象。比如说敏感词校验、黑名单的校验逻辑,模板校验逻辑等\n现在一个困惑的是, 我看老师没有在领域模型图里画工厂, 而我这个图里如果不画, 其他的一些领域对象孤孤单单,没有任何关联。\nhttps:&#47;&#47;www.processon.com&#47;view&#47;link&#47;65068631464f0d50af3d6f7f\n是我理解的哪里有问题吗？\n【答】1）之所以领域模型里没有画工厂，是因为工厂不是业务概念，也就是说，业务专家不会和我们谈“工厂”这个概念。2）孤孤单单本身不是问题，只要正确反映了业务概念 3）如果建模再深入一点，可以见一个“校验规则”实体，它有很多子类，比如“敏感词校验”“黑名单校验”等，然后这些字类就可以和那几个“孤单”的对象有“依赖”关系了。\n3.如果我这个发送短信的场景,不仅存在一些逻辑校验,还要调用基础设施层完成真正的发送后,才能Build这个领域对象,\n这种情况, 还能用工厂模式吗？ 是这样的逻辑吗---领域层调基础设施层后,在继续领域层没有处理完毕的操作？\n【答】我倾向于这样做：用一个App Service 中的方法（“发短信”方法），在这个方法里先做调用基础设施等工作，然后再调用工厂创建对象（如果需要的话），最后保存对象。\n\n","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1695267744,"ip_address":"广东","comment_id":381256,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"老师,对工厂模式有点困惑,老师看下我理解的是否正确\n工厂模式, 是负责创建领域对象的。\n比如说对象的关联很多,结构复杂;\n也比如说创建这个对象需要有很多校验逻辑通过,规则复杂\n1. 如果说我仅仅只有校验1-2个业务逻辑, 并且领域对象中没有这些所需的关联对象时,我也要搞一个工厂模型吗？\n是不是像上文那样直接放到领域服务就行了？\n2.假设我现在有一个这样的场景, 发送短信的场景, 类比文中的添加添加组织。\n它也存在需要很多校验,才能创建一个领域对象。比如说敏感词校验、黑名单的校验逻辑,模板校验逻辑等\n现在一个困惑的是, 我看老师没有在领域模型图里画工厂, 而我这个图里如果不画, 其他的一些领域对象孤孤单单,没有任何关联。\nhttps:&#47;&#47;www.processon.com&#47;view&#47;link&#47;65068631464f0d50af3d6f7f\n是我理解的哪里有问题吗？\n3.如果我这个发送短信的场景,不仅存在一些逻辑校验,还要调用基础设施层完成真正的发送后,才能Build这个领域对象,\n这种情况, 还能用工厂模式吗？ 是这样的逻辑吗---领域层调基础设施层后,在继续领域层没有处理完毕的操作？","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":628382,"discussion_content":"1. 如果说我仅仅只有校验1-2个业务逻辑, 并且领域对象中没有这些所需的关联对象时,我也要搞一个工厂模型吗？\n是不是像上文那样直接放到领域服务就行了？\n【答】可以放在领域服务，不过如果一个领域服务的职责是创建对象的话，那么其实就是一个工厂了。\n2.假设我现在有一个这样的场景, 发送短信的场景, 类比文中的添加添加组织。\n它也存在需要很多校验,才能创建一个领域对象。比如说敏感词校验、黑名单的校验逻辑,模板校验逻辑等\n现在一个困惑的是, 我看老师没有在领域模型图里画工厂, 而我这个图里如果不画, 其他的一些领域对象孤孤单单,没有任何关联。\nhttps://www.processon.com/view/link/65068631464f0d50af3d6f7f\n是我理解的哪里有问题吗？\n【答】1）之所以领域模型里没有画工厂，是因为工厂不是业务概念，也就是说，业务专家不会和我们谈“工厂”这个概念。2）孤孤单单本身不是问题，只要正确反映了业务概念 3）如果建模再深入一点，可以见一个“校验规则”实体，它有很多子类，比如“敏感词校验”“黑名单校验”等，然后这些字类就可以和那几个“孤单”的对象有“依赖”关系了。\n3.如果我这个发送短信的场景,不仅存在一些逻辑校验,还要调用基础设施层完成真正的发送后,才能Build这个领域对象,\n这种情况, 还能用工厂模式吗？ 是这样的逻辑吗---领域层调基础设施层后,在继续领域层没有处理完毕的操作？\n【答】我倾向于这样做：用一个App Service 中的方法（“发短信”方法），在这个方法里先做调用基础设施等工作，然后再调用工厂创建对象（如果需要的话），最后保存对象。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1695267745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":377119,"user_name":"Geek_b3405e","can_delete":false,"product_type":"c1","uid":3662837,"ip_address":"北京","ucode":"4C890A1C2FA69A","user_header":"","comment_is_top":false,"comment_ctime":1687942861,"is_pvip":false,"replies":[{"id":137717,"content":"可以用策略模式","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1689498805,"ip_address":"","comment_id":377119,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"请问老师，比如业务中基于同一字段不同场景下值的不同，会有不同的校验规则，这种怎么处理呢，使用SPI机制？同样 还涉及到了不同属性值填充的问题。","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":623446,"discussion_content":"可以用策略模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1689498805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":376217,"user_name":"无问","can_delete":false,"product_type":"c1","uid":1546586,"ip_address":"上海","ucode":"F841A16374CC84","user_header":"https://static001.geekbang.org/account/avatar/00/17/99/5a/32f3df3c.jpg","comment_is_top":false,"comment_ctime":1686554111,"is_pvip":false,"replies":[{"id":137252,"content":"看性能是否成为可见的瓶颈。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1686837938,"ip_address":"广东","comment_id":376217,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"有个问题想问下 封装的比较多的情况下 访问数据库的次数就会变多吧 这种性能跟代码简洁度上又是怎么权衡的呢","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":621130,"discussion_content":"看性能是否成为可见的瓶颈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1686837938,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":372101,"user_name":"Hesher","can_delete":false,"product_type":"c1","uid":1026832,"ip_address":"北京","ucode":"99AB8B1704CB7E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ab/10/b812ff3e.jpg","comment_is_top":false,"comment_ctime":1680736285,"is_pvip":false,"replies":[{"id":135798,"content":"1）关于可变属性：比如某个AaaController里注入了 bbbService，你会发现，这个AaaController的bbbService属性在注入以后，就不会再变了，这实际上就是一个不可变属性。所以，Spring注入的时候，使用的是单例方式（也是默认方式），也就是多个线程可以共享。假如有可变属性，那么多线程共享会造成线程不安全。\n2）lombok@builder 也可以，不过要注意两点：第一，lombok默认的builder中没有业务逻辑，所以要想办法自己插入业务逻辑；第二，课程里的逻辑要访问数据库，用lombok的话，意味着领域对象要和数据库耦合了。\n3）org是实体，不需要依赖注入，所以可变是没有问题的。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1680742257,"ip_address":"广东","comment_id":372101,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"由于 OrgBuilder 有可变属性，因此不能按单例注入到 OrgService，所以我又写了一个单例的 OrgBuilderFactory 负责创建 OrgBuilder。\n\n请问下老师这句话怎么理解，比如可见属性是什么？按单例注入又有什么问题？现实中估计大家都会在factory中直接用lombok的@build实现去创建org了吧。我还纠结一个点，org是不是不应该有setter，这样才不可变。","like_count":1,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612490,"discussion_content":"1）关于可变属性：比如某个AaaController里注入了 bbbService，你会发现，这个AaaController的bbbService属性在注入以后，就不会再变了，这实际上就是一个不可变属性。所以，Spring注入的时候，使用的是单例方式（也是默认方式），也就是多个线程可以共享。假如有可变属性，那么多线程共享会造成线程不安全。\n2）lombok@builder 也可以，不过要注意两点：第一，lombok默认的builder中没有业务逻辑，所以要想办法自己插入业务逻辑；第二，课程里的逻辑要访问数据库，用lombok的话，意味着领域对象要和数据库耦合了。\n3）org是实体，不需要依赖注入，所以可变是没有问题的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680742257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370777,"user_name":"。","can_delete":false,"product_type":"c1","uid":1723580,"ip_address":"江西","ucode":"BFEF2648FE8A85","user_header":"https://static001.geekbang.org/account/avatar/00/1a/4c/bc/d9ef313e.jpg","comment_is_top":false,"comment_ctime":1679259871,"is_pvip":false,"replies":[{"id":135295,"content":"共同学习:)","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1679309002,"ip_address":"广东","comment_id":370777,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"值得读三遍的文章，向老师致敬","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609949,"discussion_content":"共同学习:)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679309002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370039,"user_name":"别天神","can_delete":false,"product_type":"c1","uid":1107606,"ip_address":"上海","ucode":"42A08D6EF5C59A","user_header":"https://static001.geekbang.org/account/avatar/00/10/e6/96/eb143e46.jpg","comment_is_top":false,"comment_ctime":1678291096,"is_pvip":false,"replies":[{"id":134942,"content":"您觉得领域服务使用Spring依赖注入，有什么问题呢？","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1678507251,"ip_address":"广东","comment_id":370039,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100311801,"comment_content":"领域层（这里是领域服务）依赖spring的依赖注入值得商榷吧？是否有更好的方式","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608545,"discussion_content":"您觉得领域服务使用Spring依赖注入，有什么问题呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678507251,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1959822,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/e7/8e/318cfde0.jpg","nickname":"Spoon","note":"","ucode":"2FF9193AD482C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":637352,"discussion_content":"我觉得没有问题，依赖注入不一定是Spring，也可是别的，依赖注入是为了减少耦合","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1708401159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":369780,"user_name":"Fredo","can_delete":false,"product_type":"c1","uid":1438470,"ip_address":"广东","ucode":"681D6692617DAB","user_header":"https://static001.geekbang.org/account/avatar/00/15/f3/06/8da1bf0c.jpg","comment_is_top":false,"comment_ctime":1677927391,"is_pvip":false,"replies":[{"id":135149,"content":"OrgTypeValidator并不是孤立地校验“组织类型”本身，而是校验“组织”的“组织类型”的规则，比如说“组织的组织类型不能为空”。所以放在Org包下是没问题的。不过看来“OrgTypeValidator”的命名可能会造成误解，这个命名让我再想想。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1678972001,"ip_address":"广东","comment_id":369780,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100311801,"comment_content":"OrgTypeValidator 这个类是不是应该放在 orgtype 包下面，还是统一在 org.validator 包下面？或者在 orgtype 下面再建一个 validator 包？","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609398,"discussion_content":"OrgTypeValidator并不是孤立地校验“组织类型”本身，而是校验“组织”的“组织类型”的规则，比如说“组织的组织类型不能为空”。所以放在Org包下是没问题的。不过看来“OrgTypeValidator”的命名可能会造成误解，这个命名让我再想想。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678972001,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368687,"user_name":"java小霸王","can_delete":false,"product_type":"c1","uid":1168540,"ip_address":"广东","ucode":"7094BCD9F25E1E","user_header":"https://static001.geekbang.org/account/avatar/00/11/d4/9c/030e80d3.jpg","comment_is_top":false,"comment_ctime":1676565311,"is_pvip":false,"replies":[{"id":135088,"content":"我想这个问题准确的提法是限界上下文之间怎么协作。在第二迭代里面关于限界上下文的几节里面讲","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1678843330,"ip_address":"广东","comment_id":368687,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100311801,"comment_content":"Domain之间怎么协作呢，现在过程式都是应用层service 调用service ","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609116,"discussion_content":"我想这个问题准确的提法是限界上下文之间怎么协作。在第二迭代里面关于限界上下文的几节里面讲","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678843330,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368118,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"北京","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1675913298,"is_pvip":true,"replies":[{"id":135183,"content":"看您写的内容，越来越有感觉了。2个思考题回答都不错。\nUserRepository 在 usermng 下。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1678976610,"ip_address":"广东","comment_id":368118,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100311801,"comment_content":"看代码有点好奇， UserRepository 放在哪里？persistence.orgmng 还是 persistence.usermng ? \n\n如果使用 myBatis 之类的代码映射工具，是不是就可以没有 DTO，或者是工具帮助生成了 DTO？\n\nBusinessException 和 DirtyDataException 暂时放在了 common&#47;framework 下面。\n\n手抄了一遍代码，好长。\n\n代码可以参考 https:&#47;&#47;github.com&#47;escray&#47;geektime&#47;tree&#47;master&#47;DDD-hand-in-hand\n\n表意接口 intention-revealig interface 和 领域服务 Domain Service 这两个模式看上去很不错，似乎可以为代码重构提供一定的方向感。\n\n将规则区分为领域逻辑和应用逻辑也很有帮助，比如在想定编辑的过程中，模型本身具有的固有属性和行为规则（专家感兴趣）应该属于领域逻辑，而如何存储、转换、展示之类的（专家不感兴趣）应该属于应用逻辑。\n\n对于思考题，\n\n1. 即使只有一行代码的业务规则，我觉的也可以抽成单独的方法，一方面有利于之后的代码修改，另一方面提高代码的可读性\n2. 表意接口 intention-revealing interfaces 并不是特指接口，而是说代码的合作方式。其实如果把几个 validator 的实现抽取出共同接口，似乎更好一些。","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609445,"discussion_content":"看您写的内容，越来越有感觉了。2个思考题回答都不错。\nUserRepository 在 usermng 下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678976610,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1158156,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ac/0c/f3e37765.jpg","nickname":"夏","note":"","ucode":"2DE213960503A8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":622083,"discussion_content":"方案三和方案四不是一样吗，方案四一样的繁琐，而且容易漏参数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1687913229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366938,"user_name":"Johar","can_delete":false,"product_type":"c1","uid":1101969,"ip_address":"重庆","ucode":"834136A6F64CDC","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/91/89123507.jpg","comment_is_top":false,"comment_ctime":1674635630,"is_pvip":false,"replies":[{"id":135211,"content":"非常好","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1678983576,"ip_address":"广东","comment_id":366938,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100311801,"comment_content":"1. 如果实现某个业务规则的代码只有一行，还值得抽成单独的方法吗？\n值得，破窗效应，若前面没有把代码做好区分，后面其他同事开发时也就放在应用层，逻辑都糅杂在一起。\n2. 我们在实现 Validator 的时候，并没有用到 Java 中的“接口”，但为什么这个模式还叫表意接口呢？\n表意接口中接口不是Java中的interface，其意重点还是表意，以前在一个技术领导也是十分在意命名，现在也是越来越能感受到命名的重要性。","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609499,"discussion_content":"非常好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678983576,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366698,"user_name":"Jaising","can_delete":false,"product_type":"c1","uid":1037630,"ip_address":"浙江","ucode":"F68830B7B90F96","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d5/3e/7f3a9c2b.jpg","comment_is_top":false,"comment_ctime":1674090916,"is_pvip":false,"replies":[{"id":134792,"content":"很棒！","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1677937024,"ip_address":"广东","comment_id":366698,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100311801,"comment_content":"继续两千字笔记第五篇《Show Me Code——领域驱动设计中的代码实现》：\n面向多种编程范式更适合于当今企业级软件应用开发，结合领域驱动设计提供的诸多最佳实践模式，代码实现质量也能有所保障，通过事件风暴、领域建模、数据库设计、分层架构和代码实现完成了领域驱动设计的最小闭环。\nhttps:&#47;&#47;juejin.cn&#47;post&#47;7190016520045953083","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":607552,"discussion_content":"很棒！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1677937024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365894,"user_name":"leesper","can_delete":false,"product_type":"c1","uid":1351104,"ip_address":"广东","ucode":"CC76320571BECA","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/c0/cb5341ec.jpg","comment_is_top":false,"comment_ctime":1673185283,"is_pvip":false,"replies":[{"id":133293,"content":"回答得很到位👍🏻","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1673230835,"ip_address":"广东","comment_id":365894,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100311801,"comment_content":"思考题\n1. 值得，函数本身就是一种最基础的抽象，只要能增加代码可读性，哪怕只有一行也值得抽取；\n2. 这里的“表意接口”重在表意，接口则是抽象泛指的概念，不是Java中接口的意思","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598935,"discussion_content":"回答得很到位👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673230835,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365583,"user_name":"邓西","can_delete":false,"product_type":"c1","uid":2977417,"ip_address":"广东","ucode":"DC84CD4CDF4021","user_header":"","comment_is_top":false,"comment_ctime":1672798440,"is_pvip":false,"replies":[{"id":133247,"content":"两道思考题回答得都很到位。\n\n关于DTO作为参数的问题，估计你的建议是都采用DTO是吧？这样也可以。其实是一个衡问题，参数较少时不采用DTO，程序会更简洁一些，但也可能造成您说的一些问题。根据大家的偏好和实际场景，在本团队建立共同的约定就可以了。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1673058307,"ip_address":"广东","comment_id":365583,"utype":1}],"discussion_count":3,"race_medal":0,"score":4,"product_id":100311801,"comment_content":"关于文中问题：“OrgFactory 的 build() 方法的参数类型是 OrgDto，而这个 DTO 是在应用层定义的，也就是领域层依赖了应用层，又一次破坏了层间依赖原则。”的解决方案二：参数三个以内就将对象拆解成参数列表，这样没有扩展性吧？会演化成既修改方法又修改接口，也和模块间解耦的目标背离了。\n\n关于层次间与层内的“先横后竖”的划分，工作中遇到的许多项目虽然没引入DDD，但这个划分原则貌似是通用的，实操的经验也很符合“先横后竖”，甚至作为一个先验知识了。\n\n思考题：\n1.值得，按功能拆分单独方法，提高可读性，保留扩展性；\n2.广义的接口概念，并非java中狭义的interface。","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598756,"discussion_content":"两道思考题回答得都很到位。\n\n关于DTO作为参数的问题，估计你的建议是都采用DTO是吧？这样也可以。其实是一个衡问题，参数较少时不采用DTO，程序会更简洁一些，但也可能造成您说的一些问题。根据大家的偏好和实际场景，在本团队建立共同的约定就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673058307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1710974,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/1b/7e/e04c4950.jpg","nickname":"RunITR","note":"","ucode":"3C6DF462F5486E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":647392,"discussion_content":"DTO 定义在应用层，Factory定义在domain层，为什么domain能用dto作为入参，编译就会出错啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1719976580,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":598756,"ip_address":"广东","group_id":0},"score":647392,"extra":""}]},{"author":{"id":2977417,"avatar":"","nickname":"邓西","note":"","ucode":"DC84CD4CDF4021","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598927,"discussion_content":"谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673228625,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365456,"user_name":"╭(╯ε╰)╮","can_delete":false,"product_type":"c1","uid":1440349,"ip_address":"广东","ucode":"4CB5FAEEE8CC5D","user_header":"https://static001.geekbang.org/account/avatar/00/15/fa/5d/735fdc76.jpg","comment_is_top":false,"comment_ctime":1672581215,"is_pvip":false,"replies":[{"id":133261,"content":"估计语言的开发，还是有一些我们想象不到的复杂性和关注点。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1673090355,"ip_address":"广东","comment_id":365456,"utype":1}],"discussion_count":5,"race_medal":0,"score":4,"product_id":100311801,"comment_content":"java语言的啰嗦真不是吹牛吹出来的，老师随手一个重构就膨胀成了这个规模。\n\nddd概念出来这么久了，我跟好奇有没有什么语言天然对ddd就很亲和。\n总感觉是在用落后的工具用蹩脚的方法实现一个先进的理念（打个比方有点像java8以前用匿名内部类来模仿函数式编程风格写出来的四不像）。\n难道大神们觉得这很合理吗，或者我的感知跟正常人产生了什么偏差。\n\n世界上时不时就会出来一门新语言，但语言开发者都是针对技术上改进，比如增加函数式的支持，增加增加协程，更先进的并发支持等。好像还没听说过谁谁谁为了更好的建模，开发一门语言天然就是为了ddd而生，比如说，代码里没有class，有的是domain。\n\npublic domain Org ｛\n    \n｝","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598792,"discussion_content":"估计语言的开发，还是有一些我们想象不到的复杂性和关注点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673090355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1588683,"avatar":"https://static001.geekbang.org/account/avatar/00/18/3d/cb/791d0f5e.jpg","nickname":"猴哥","note":"","ucode":"63A1BFDF13D85D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":649647,"discussion_content":"public domain Org ｛\n    \n｝\n和\npublic class Org ｛\n    \n｝\n实际上毫无区别哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1723695564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2062203,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/77/7b/338c4617.jpg","nickname":"瀚海","note":"","ucode":"E64C22F3F6D285","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":623634,"discussion_content":"个人认为   代码类的膨胀，不能抱怨为java语言的繁琐    这种膨胀是为了以后扩展容易  当然代码是在不断迭代中膨胀的，不可能一开始就为了扩展，一下子引入这么多类    ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1689696403,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1177832,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f8/e8/bbd1b66d.jpg","nickname":"🏄🏻米兰的大铁匠🎤🎈","note":"","ucode":"704DB6905F96D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":619530,"discussion_content":"为了扩展性，就这一点就值得去打理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1685245851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"天津","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1887261,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/cc/1d/3c0272a1.jpg","nickname":"abc🙂","note":"","ucode":"FCF2B9091D161B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598535,"discussion_content":"Java确实繁琐，groovy  kotlin都很简洁，但是主要还是时间，时间给了java巨大的群体和生态，这些不容易割舍，跟DDD并无关系，你可以选择你喜欢的。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672892066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"福建","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":377071,"user_name":"夏","can_delete":false,"product_type":"c1","uid":1158156,"ip_address":"广东","ucode":"2DE213960503A8","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/0c/f3e37765.jpg","comment_is_top":false,"comment_ctime":1687914298,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100311801,"comment_content":"方案三和方案四不是一样吗，方案四一样的繁琐，而且容易漏参数","like_count":2},{"had_liked":false,"id":368476,"user_name":"支离书","can_delete":false,"product_type":"c1","uid":1026921,"ip_address":"北京","ucode":"AD2570AC5EF7BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ab/69/5f1f0d1c.jpg","comment_is_top":false,"comment_ctime":1676368510,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100311801,"comment_content":"在没有介绍工厂模式前，OrgValidator类挪到domain层，他的validate方法参数是OrgDto，就已经导致领域层依赖应用层了。\n\n感觉因DTO导致的依赖问题解决起来有些费劲了，但严格限制依赖关系也确实能带来好处。","like_count":0},{"had_liked":false,"id":368026,"user_name":"py","can_delete":false,"product_type":"c1","uid":1496577,"ip_address":"上海","ucode":"2372522D715419","user_header":"https://static001.geekbang.org/account/avatar/00/16/d6/01/2448b4a9.jpg","comment_is_top":false,"comment_ctime":1675827931,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100311801,"comment_content":"1. 看后续的发展，如果业务本身也就一行代码，而不是后面还有更丰富的代码，那么没必要增加复杂度\n2. 不知道，你定义的","like_count":0},{"had_liked":false,"id":365554,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"浙江","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1672755960,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100311801,"comment_content":"之前只知道通过 @Builder 注解使用 Builder 模式，验证逻辑还要单独调用，没有封装在 Builder 中，使用时只感觉比 set 方法少了 set 前缀更简洁，没看出其他优点。\n这节课看到 validate() 封装在 Builder 中，感觉这样可以降低调用者的认知负载（无需关心 validate 相关逻辑），这样写挺好！\n这个模板很好用：BuilderFactory -&gt; create() -&gt; Builder -&gt; build() -&gt; 最终对象","like_count":0}]}