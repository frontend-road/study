{"id":621471,"title":"23｜运营物料的后台管理：如何全栈化实现列表分页的功能？","content":"<p>你好，我是杨文坚。</p><p>物料功能维度，主要功能链路是物料资源管理和物料信息管理。上节课我们学习了如何管理物料产物，主要是静态资源的管理，我们把Vue.js组件编译成多种JavaScript模块化格式，然后把多个格式的JavaScript文件和CSS文件，存放到CDN服务或者私有NPM站点管理。</p><p>那今天我们就进入物料信息管理，也就是物料的数据管理，因为功能链路都集中在后台层面，我们会围绕“运营物料的后台管理”来学习。</p><p>按照之前实现用户功能的套路，我们先做功能逻辑设计，再做技术方案设计，最后实现代码。那么如何设计物料管理的功能逻辑呢？</p><h2>如何设计物料管理的功能逻辑？</h2><p>先梳理一下物料管理的整个功能链路需要哪些“功能点”。</p><p>按照课程运营搭建平台的设计，我们基于“按需开发”的原则，先实现核心够用的功能，后续根据实际情况再按需扩展。所以，物料管理的最基本功能，我分成了四个基础功能点。</p><ul>\n<li>物料注册</li>\n<li>物料编辑</li>\n<li>物料列表管理</li>\n<li>物料快照列表管理</li>\n</ul><p>物料管理，首先要有数据才能管理。所以，物料管理<strong>第一个功能点就是“物料注册”，也就是创造物料数据</strong>。</p><p>物料注册，就是根据CDN已经存在的物料产物，把名称和版本号等基础信息进行注册登记，方便后续搭建页面的时候使用。功能链路图就像这样：</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/09/84/092a57b56cbeb256eec8153fcacd6a84.jpg?wh=4000x2250\" alt=\"\"></p><p>注册物料的功能逻辑有三个步骤点。</p><ul>\n<li>第一步，用户输入物料名称和版本号等信息，提交给服务端。</li>\n<li>第二步，服务端对物料名称和版本进行判断处理。</li>\n<li>第三步，服务端返回结果，浏览器显示结果。</li>\n</ul><p>在第二步中，服务端要根据物料名称，查询物料是否已经被注册，然后根据物料名称，查找远程CDN是否存在对应物料产物。如果存在物料产物，就判断CDN是否存在对应的版本产物，如果注册成功，就记录首次物料快照数据。</p><p>接下来看第二个功能点<strong>“物料编辑”的功能逻辑设计。</strong></p><p><img src=\"https://static001.geekbang.org/resource/image/80/f7/80yyb4cc09b7e480a74c44f286f03af7.jpg?wh=4000x2250\" alt=\"\"></p><p>我把物料编辑功能逻辑分成四步。</p><ul>\n<li>第一步，用户进入的物料编辑页面，渲染物料当前完整数据。</li>\n<li>第二步，用户在当前数据上编辑修改后，提交新版本号给服务端。</li>\n<li>第三步，服务端对物料新版本进行校验。</li>\n<li>第四步，浏览器处理对应的返回结果。</li>\n</ul><p>其中最重要是第三步，服务端要先查询物料是否已经存在数据库，判断是否可以进行编辑。然后再查询CDN是否存在对应的版本产物，再判断新版本号是否高于旧版本号。如果这些判断逻辑通过且成功修改物料数据，就记录编辑物料快照数据。</p><p>“物料注册”和“物料编辑”的功能有了，就等于有了数据积累，那么数据积累后如何显示呢？</p><p>我们基本靠列表进行显示处理，所以接下来的基本功能就是“物料列表管理”和“物料快照列表管理”。这两个的功能逻辑十分类似，我们一起分析，其中，主要的功能逻辑就是<strong>列表显示数据和分页的页码选择操作。</strong></p><p><img src=\"https://static001.geekbang.org/resource/image/2c/65/2c479cc3074883151bd88b6807b0f665.jpg?wh=4000x2250\" alt=\"\"></p><p>分页列表具体的功能逻辑有三步。</p><ul>\n<li>第一步，进入列表页面时，默认渲染第一页的列表数据。</li>\n<li>第二步，渲染分页的页码选择器。</li>\n<li>第三步，点击页码选择器的按钮，渲染对应页码的列表数据。</li>\n</ul><p>比较重要的是第二、三步，第二步要根据当前页码、每页数据和数据总量，来换算和渲染分页选择器，并且提供点击操作事件。第三步，点击页码后，要触发新的列表数据请求，然后重新渲染列表，重新计算页码选择器的内容。</p><p>物料后台管理功能的逻辑设计我们就做好了，按照实现套路，接下来就是技术方案的设计了。</p><h2>如何设计物料管理的技术方案？</h2><p>技术方案都是基于功能逻辑的设计来定制的。</p><h3>物料注册的技术方案</h3><p>根据上面功能逻辑的设计描述，我先画出物料注册的技术方案图。</p><p><img src=\"https://static001.geekbang.org/resource/image/c9/c3/c9acb05b2e0927098a3f03c98a12cec3.jpg?wh=4000x2250\" alt=\"\"></p><p>物料注册操作的技术方案分成四步。</p><p><strong>第一步，前端提交“待注册”的物料名称和物料版本号。</strong>这里的物料名称，就是物料对应的Vue.js组件名称，是托管在CDN或私有NPM站点上的物料产物。在课程的代码案例中，我把物料静态资源放在mock-cdn子项目中。</p><p>在浏览器里，前端用动态表单的方式，来实现物料注册的页面交互功能。这里用动态表单，也能方便后续注册信息扩展。表单处理好数据后，就以表单形式发起POST请求给服务端。</p><p><strong>第二步，服务端接收HTTP请求。</strong>这里会在路由层Router先做统一的用户登录态校验，如果不存在登录态就拦截，直接返回失败信息。如果存在登录态，就进入控制层Controller进入服务端其它操作逻辑。</p><p><strong>第三步，服务端处理物料注册数据。</strong>这一步中，控制层Controller解析出当前用户信息，解析出HTTP表单中的物料信息。然后，进入业务层Service中处理数据。</p><p>业务层里，先用物料名称查询在数据库里是否存在已注册物料，接着用物料名称查询目前CDN服务，或者私有NPM站点上物料的所有版本号。如果版本号都为空，就是证明物料不存在，如果所有版本号存在，就判断当前注册版本是否存在。</p><p>如果物料和版本都存在，就进行注册操作，写入数据到物料信息表里，同时，再写一份数据到物料快照表里，记录一次物料操作变更。最后，封装对应结果返回。</p><p><strong>第四步，浏览器处理HTTP响应结果。</strong>如果物料注册成功，就跳转到物料列表页面。如果物料注册失败，就提示失败原因。</p><p>完整的物料注册流程技术方案，我们就梳理好了，有些人会觉得注册信息太少，就只有物料名称和版本号？</p><p>其实，功能实现是“由简到难”一步步来，目前的技术方案中，我们前端用动态表单，服务端做好登录态和关键数据的校验，整个物料注册链路走通，前后端结合，把核心能力实现好，就方便我们后面做详细信息的扩展操作了。</p><h3>物料编辑的技术方案</h3><p>接下来设计物料编辑流程的技术方案。我画了一张图：</p><p><img src=\"https://static001.geekbang.org/resource/image/ae/09/aece743fb9e941da8287a59a2a682809.jpg?wh=4000x2250\" alt=\"\"></p><p>物料编辑比物料注册复杂一些，因为涉及数据的来回请求操作，具体的技术方案分成六个步骤。</p><p>第一步，渲染编辑物料页面。物料编辑页面的URL，携带了物料的uuid数据，通过uuid发起GET请求到服务端，查找详细的物料数据。</p><p>第二步，服务端接收请求，查询物料信息。服务端接收到HTTP请求，进行登录态校验，校验成功后才能进行下一个操作环节。下一个环节的操作，就是去查询数据库物料信息表，根据uuid查找物料信息。最后，返回物料信息给前端。</p><p>第三步，渲染待编辑的完整信息。如果前端拿到完整物料信息，就填充到动态表单，渲染完整的表单信息，方便给用户进行编辑，否则提示对应失败原因。</p><p>第四步，提交“已编辑”的物料信息，用表单格式发起POST请求，发送给服务端。</p><p><strong>第五步，服务端接收HTTP请求，并处理已编辑信息。</strong>这一步比较关键，要分成多个环节。</p><p>首先，路由层进行登录态校验，校验成功后才能进行解析HTTP表单，把“已编辑”的物料信息提出来进行数据处理。然后，用物料名称查询在数据库里是否为已注册物料，如果是则进入下一环节校验。最后，校验新版本是否大于旧版版本号，同时判断编辑后的新版本，是否存在CDN静态资源，如果存在就进行更新物料信息数据，同时记录物料新数据到物料快照表里，记录一次物料操作变更。</p><p>第六步，浏览器处理HTTP响应结果，如果物料编辑成功，就跳转到物料列表页面。如果物料编辑失败，就提示失败原因。</p><p>物料注册和编辑的技术方案，我们就设计好了。从物料注册到编辑，你有没有觉得技术实现逻辑越来越繁琐复杂了？别心急，你可以先消化一下，打好基础，我们最后一个列表管理的技术方案设计会更复杂一点。</p><h3>列表管理的技术方案</h3><p>物料列表和物料快照列表的技术方案，我们统一用一套技术方案。</p><p><img src=\"https://static001.geekbang.org/resource/image/bf/4f/bf77a135e6480ba29yy93b41e8b0a74f.jpg?wh=4000x2363\" alt=\"\"></p><p>列表分页查询的技术方案，分成三步。</p><p>第一步，首次进入列表页的默认分页渲染。这个时候，浏览器会发起第一页列表数据的请求，请求中携带的参数有首页页码、每页数量。</p><p>第二步，服务接收到分页列表的请求数据后，首先要在路由层做用户登录态的校验。然后，根据每页“列表数据量”和“选择页码”进行换算，变成SQL查询的数据“查询起始位置”和“查询个数”，来处理数据库分页查询。</p><p>查询到数据后，进行部分数据的操作和脱敏，最后返回响应给浏览器。</p><p>第三步，前端接收到分页查询后的数据，把数据进行列表渲染和分页选择器渲染。</p><p>物料管理的四个基本功能，技术方案我们就设计好了，其中很多技术点，在用户注册和登录那节课（<a href=\"https://time.geekbang.org/column/article/619215\">第21讲</a>），你已经掌握如何实现了，接下来我们就重点看看“列表分页功能”如何实现。</p><h2>如何实现物料列表分页功能？</h2><p>列表分页功能，分成前端和服务端两部分。</p><h3>前端实现部分</h3><p>前端实现部分主要有两个渲染模块，“渲染列表”和“渲染页码选择器”。其中“渲染列表”非常简单，直接基于Vue.js的v-for语法，把数据进行循环渲染出来。“页码选择器”比较复杂，我们看效果图。</p><p><img src=\"https://static001.geekbang.org/resource/image/2b/d6/2b45fbfb3efc33939be51b3f5efa2bd6.jpg?wh=4000x2250\" alt=\"\"><img src=\"https://static001.geekbang.org/resource/image/30/f6/307f9a7fc1bc7yy8771d5e4a87167bf6.jpg?wh=4000x2250\" alt=\"\"></p><p>从图中可以看出，实现页码选择器需要三个数据，“列表数据量”“选中页码”和“数据总量”。我们可以基于“列表数据量”和“数据总量”计算得出“页数总量”，也就是页码的总数。</p><p>知道了页码的“页数总量”，我们就可以知道哪些页码是可以使用的。这个时候，结合当前的“选中页码”进行判断，按需计算出可以显示的页码数据就行了。具体实现方法你可以参考代码。</p><pre><code class=\"language-typescript\">interface PageItem {\n  num: number;\n  text: string;\n  active: boolean;\n  disabled: boolean;\n}\n\nfunction parsePagination(params: {\n  size: number;\n  total: number;\n  pageNum: number;\n}) {\n  const { size, total, pageNum } = params;\n  const pageItemList: PageItem[] = [];\n  const pageCount = Math.ceil(total / size);\n  const pageStartNum: number = Math.max(1, pageNum - 2);\n  const pageEndNum: number = Math.min(pageCount, pageNum + 2);\n\n  for (let i = pageStartNum; i &lt;= pageEndNum; i++) {\n    pageItemList.push({\n      num: i,\n      text: `${i}`,\n      active: i === pageNum,\n      disabled: false\n    });\n  }\n  pageItemList.unshift({\n    num: pageNum - 1,\n    text: '上一页',\n    active: false,\n    disabled: pageNum - 1 &lt; pageStartNum\n  });\n  pageItemList.push({\n    num: pageNum + 1,\n    text: '下一页',\n    active: false,\n    disabled: pageNum + 1 &gt; pageEndNum\n  });\n  return pageItemList;\n}\n</code></pre><p>通过这个方法，我们可以基于“列表数据量”“选中页码”和“数据总量”，换算出可以显示的页码内容，接下来渲染页码，就可以得到页码选择器。</p><p>对应的完整功能逻辑的Vue.js 3.x代码。</p><pre><code class=\"language-xml\">&lt;template&gt;\n  &lt;div class=\"pagination\"&gt;\n    &lt;div class=\"page-list\"&gt;\n      &lt;span\n        class=\"page-item\"\n        :class=\"{ active: item.active, disabled: item.disabled }\"\n        v-for=\"(item, index) in state.pageItemList\"\n        :key=\"index\"\n        @click=\"onClickPageItem(item)\"\n        :data-page-num=\"item.num\"\n      &gt;\n        {{ item.text }}\n      &lt;/span&gt;\n    &lt;/div&gt;\n    &lt;span class=\"page-info\"&gt;\n      ( 共{{ state.pageCount }}页， 共{{ props.totalDataCount }}条数据 )\n    &lt;/span&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script lang=\"ts\" setup&gt;\nimport { reactive, onMounted, watch } from 'vue';\n\ninterface PageItem {\n  num: number;\n  text: string;\n  active: boolean;\n  disabled: boolean;\n}\n\nconst props = defineProps&lt;{\n  pageNum: number;\n  pageSize: number;\n  totalDataCount: number;\n}&gt;();\n\nconst emits = defineEmits&lt;{\n  (event: 'changePage', e: { pageNum: number }): void;\n}&gt;();\n\nconst state = reactive&lt;{\n  pageItemList: PageItem[];\n  pageCount: number;\n}&gt;({\n  pageItemList: [],\n  pageCount: 0\n});\n\n// 挂载时候进行页码计算和渲染\nonMounted(() =&gt; {\n  updatePagination({\n    size: props.pageSize,\n    pageNum: props.pageNum,\n    total: props.totalDataCount\n  });\n});\n\nwatch(\n  [() =&gt; props.pageSize, () =&gt; props.pageNum, () =&gt; props.totalDataCount],\n  ([pageSize, pageNum, totalDataCount]) =&gt; {\n    // 监听数据变化时候，进行页码重新计算和渲染\n    updatePagination({\n      size: pageSize,\n      pageNum: pageNum,\n      total: totalDataCount\n    });\n  }\n);\n\n// 点击页码的事件\nconst onClickPageItem = (item: PageItem) =&gt; {\n  if (item.active || item.disabled) {\n    return;\n  }\n  updatePagination({\n    size: props.pageSize,\n    pageNum: item.num,\n    total: props.totalDataCount\n  });\n  emits('changePage', { pageNum: item.num });\n};\n\n// 页码数据的统一更新方法\nfunction updatePagination(params: {\n  size: number;\n  pageNum: number;\n  total: number;\n}) {\n  const { total, size } = params;\n  const pageItemList = parsePagination(params);\n  state.pageItemList = pageItemList;\n  state.pageCount = Math.ceil(total / size);\n}\n\n// 页码的计算方法\nfunction parsePagination(params: {\n  size: number;\n  total: number;\n  pageNum: number;\n}) {\n  const { size, total, pageNum } = params;\n  const pageItemList: PageItem[] = [];\n  const pageCount = Math.ceil(total / size);\n  const pageStartNum: number = Math.max(1, pageNum - 2);\n  const pageEndNum: number = Math.min(pageCount, pageNum + 2);\n\n  for (let i = pageStartNum; i &lt;= pageEndNum; i++) {\n    pageItemList.push({\n      num: i,\n      text: `${i}`,\n      active: i === pageNum,\n      disabled: false\n    });\n  }\n  pageItemList.unshift({\n    num: pageNum - 1,\n    text: '上一页',\n    active: false,\n    disabled: pageNum - 1 &lt; pageStartNum\n  });\n  pageItemList.push({\n    num: pageNum + 1,\n    text: '下一页',\n    active: false,\n    disabled: pageNum + 1 &gt; pageEndNum\n  });\n  return pageItemList;\n}\n&lt;/script&gt;\n</code></pre><p>页码选择器最终实现效果看图。</p><p><img src=\"https://static001.geekbang.org/resource/image/ce/e5/ceefe0fc687e1a634e1e6141bce471e5.png?wh=1592x598\" alt=\"图片\"></p><p><img src=\"https://static001.geekbang.org/resource/image/d4/02/d4b486db9f03217f8979f3e404353302.png?wh=1506x850\" alt=\"图片\"></p><p>更多分页页码选择器的详细代码，你可以看课程的代码案例。</p><h3>服务端实现部分</h3><p>接下来就是服务端部分的实现，我也画了张图。</p><p><img src=\"https://static001.geekbang.org/resource/image/fd/yy/fd941ea63a917f2a31c58e9105ee82yy.jpg?wh=4000x2363\" alt=\"\"></p><p><strong>服务端的实现核心，就是查询数据库的SQL语句的实现</strong>。</p><p>前端发起分页查询请求，把“列表数据量”和“选择页码”传给服务端。在服务端中，根据每页“列表数据量”和“选择页码”进行换算，变成SQL查询的数据“查询起始位置”和“查询个数”，来处理数据库分页查询。</p><p>还记得前端部分中，“页码选择器”用到“数据总量”吗？其实也是通过SQL来查询数据库得来的：</p><pre><code class=\"language-sql\">SELECT COUNT(*) AS total FROM table_xxxx；\n</code></pre><p>到这里，前端部分和服务端部分实现就完成了。</p><h2>总结</h2><p>今天我们围绕运营物料的后台管理，实现了物料的数据的“增加”“修改”和“查询”能力，这是我们的课程项目首次完整的一次数据管理操作。</p><p>不知道你有没有发现？我们实现了数据的“增改查”，但没有“删除”。这一点之前也提到过，因为实际企业项目不会真的删除数据库信息，都是“假删除”或者“软删除”，以后碰到类似的全栈场景，要注意这个知识点。</p><p>分析了物料管理的功能，我们重点学习了在全栈项目中，如何从前端到服务端，全栈化地实现列表分页的功能，这也是企业工作中，常见的功能需求点。可以分为两个部分来实现。</p><ul>\n<li>前端部分，核心是实现“页码选择器”，设计实现的重点就是多种分页数据的计算和显示。</li>\n<li>服务端部分，核心是MySQL数据库分页查询SQL语句的实现，重点是要理清分页查询的“起始数据位置”和“查询数据量”。</li>\n</ul><h2>思考题</h2><p>在今天的技术方案设计中，物料组件版本号只能升级不能降级，这是为什么呢？</p><p>欢迎在留言区分享你的思考，如果对今天的内容有疑问也欢迎留言，下一讲见。</p><h3><a href=\"https://github.com/FE-star/vue3-course/tree/main/chapter/23\">完整的代码在这里</a></h3>","comments":[{"had_liked":false,"id":394558,"user_name":"ifelse","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"浙江","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1727149491,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":3,"score":2,"product_id":100311101,"comment_content":"学习打卡","like_count":1}]}