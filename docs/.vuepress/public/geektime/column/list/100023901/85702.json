{"id":85702,"title":"07 | 安全性、活跃性以及性能问题","content":"<p>通过前面六篇文章，我们开启了一个简单的并发旅程，相信现在你对并发编程需要注意的问题已经有了更深入的理解，这是一个很大的进步，正所谓只有发现问题，才能解决问题。但是前面六篇文章的知识点可能还是有点分散，所以是时候将其总结一下了。</p><p>并发编程中我们需要注意的问题有很多，很庆幸前人已经帮我们总结过了，主要有三个方面，分别是：<strong>安全性问题、活跃性问题和性能问题</strong>。下面我就来一一介绍这些问题。</p><h2>安全性问题</h2><p>相信你一定听说过类似这样的描述：这个方法不是线程安全的，这个类不是线程安全的，等等。</p><p>那什么是线程安全呢？其实本质上就是正确性，而正确性的含义就是<strong>程序按照我们期望的执行</strong>，不要让我们感到意外。在<a href=\"https://time.geekbang.org/column/article/83682\">第一篇《可见性、原子性和有序性问题：并发编程Bug的源头》</a>中，我们已经见识过很多诡异的Bug，都是出乎我们预料的，它们都没有按照我们<strong>期望</strong>的执行。</p><p>那如何才能写出线程安全的程序呢？<a href=\"https://time.geekbang.org/column/article/83682\">第一篇文章</a>中已经介绍了并发Bug的三个主要源头：原子性问题、可见性问题和有序性问题。也就是说，理论上线程安全的程序，就要避免出现原子性问题、可见性问题和有序性问题。</p><p>那是不是所有的代码都需要认真分析一遍是否存在这三个问题呢？当然不是，其实只有一种情况需要：<strong>存在共享数据并且该数据会发生变化，通俗地讲就是有多个线程会同时读写同一数据</strong>。那如果能够做到不共享数据或者数据状态不发生变化，不就能够保证线程的安全性了嘛。有不少技术方案都是基于这个理论的，例如线程本地存储（Thread Local Storage，TLS）、不变模式等等，后面我会详细介绍相关的技术方案是如何在Java语言中实现的。</p><!-- [[[read_end]]] --><p>但是，现实生活中，<strong>必须共享会发生变化的数据</strong>，这样的应用场景还是很多的。</p><p>当多个线程同时访问同一数据，并且至少有一个线程会写这个数据的时候，如果我们不采取防护措施，那么就会导致并发Bug，对此还有一个专业的术语，叫做<strong>数据竞争</strong>（Data Race）。比如，前面<a href=\"https://time.geekbang.org/column/article/83682\">第一篇文章</a>里有个add10K()的方法，当多个线程调用时候就会发生<strong>数据竞争</strong>，如下所示。</p><pre><code>public class Test {\n  private long count = 0;\n  void add10K() {\n    int idx = 0;\n    while(idx++ &lt; 10000) {\n      count += 1;\n    }\n  }\n}\n</code></pre><p>那是不是在访问数据的地方，我们加个锁保护一下就能解决所有的并发问题了呢？显然没有这么简单。例如，对于上面示例，我们稍作修改，增加两个被 synchronized 修饰的get()和set()方法， add10K()方法里面通过get()和set()方法来访问value变量，修改后的代码如下所示。对于修改后的代码，所有访问共享变量value的地方，我们都增加了互斥锁，此时是不存在数据竞争的。但很显然修改后的add10K()方法并不是线程安全的。</p><pre><code>public class Test {\n  private long count = 0;\n  synchronized long get(){\n    return count；\n  }\n  synchronized void set(long v){\n    count = v;\n  } \n  void add10K() {\n    int idx = 0;\n    while(idx++ &lt; 10000) {\n      set(get()+1)      \n    }\n  }\n}\n</code></pre><p>假设count=0，当两个线程同时执行get()方法时，get()方法会返回相同的值0，两个线程执行get()+1操作，结果都是1，之后两个线程再将结果1写入了内存。你本来期望的是2，而结果却是1。</p><p>这种问题，有个官方的称呼，叫<strong>竞态条件</strong>（Race Condition）。所谓<strong>竞态条件，指的是程序的执行结果依赖线程执行的顺序</strong>。例如上面的例子，如果两个线程完全同时执行，那么结果是1；如果两个线程是前后执行，那么结果就是2。在并发环境里，线程的执行顺序是不确定的，如果程序存在竞态条件问题，那就意味着程序执行的结果是不确定的，而执行结果不确定这可是个大Bug。</p><p>下面再结合一个例子来说明下<strong>竞态条件</strong>，就是前面文章中提到的转账操作。转账操作里面有个判断条件——转出金额不能大于账户余额，但在并发环境里面，如果不加控制，当多个线程同时对一个账号执行转出操作时，就有可能出现超额转出问题。假设账户A有余额200，线程1和线程2都要从账户A转出150，在下面的代码里，有可能线程1和线程2同时执行到第6行，这样线程1和线程2都会发现转出金额150小于账户余额200，于是就会发生超额转出的情况。</p><pre><code>class Account {\n  private int balance;\n  // 转账\n  void transfer(\n      Account target, int amt){\n    if (this.balance &gt; amt) {\n      this.balance -= amt;\n      target.balance += amt;\n    }\n  } \n}\n</code></pre><p>所以你也可以按照下面这样来理解<strong>竞态条件</strong>。在并发场景中，程序的执行依赖于某个状态变量，也就是类似于下面这样：</p><pre><code>if (状态变量 满足 执行条件) {\n  执行操作\n}\n</code></pre><p>当某个线程发现状态变量满足执行条件后，开始执行操作；可是就在这个线程执行操作的时候，其他线程同时修改了状态变量，导致状态变量不满足执行条件了。当然很多场景下，这个条件不是显式的，例如前面addOne的例子中，set(get()+1)这个复合操作，其实就隐式依赖get()的结果。</p><p>那面对数据竞争和竞态条件问题，又该如何保证线程的安全性呢？其实这两类问题，都可以用<strong>互斥</strong>这个技术方案，而实现<strong>互斥</strong>的方案有很多，CPU提供了相关的互斥指令，操作系统、编程语言也会提供相关的API。从逻辑上来看，我们可以统一归为：<strong>锁</strong>。前面几章我们也粗略地介绍了如何使用锁，相信你已经胸中有丘壑了，这里就不再赘述了，你可以结合前面的文章温故知新。</p><h2>活跃性问题</h2><p>所谓活跃性问题，指的是某个操作无法执行下去。我们常见的“死锁”就是一种典型的活跃性问题，当然<strong>除了死锁外，还有两种情况，分别是“活锁”和“饥饿”</strong>。</p><p>通过前面的学习你已经知道，发生“死锁”后线程会互相等待，而且会一直等待下去，在技术上的表现形式是线程永久地“阻塞”了。</p><p>但<strong>有时线程虽然没有发生阻塞，但仍然会存在执行不下去的情况，这就是所谓的“活锁”</strong>。可以类比现实世界里的例子，路人甲从左手边出门，路人乙从右手边进门，两人为了不相撞，互相谦让，路人甲让路走右手边，路人乙也让路走左手边，结果是两人又相撞了。这种情况，基本上谦让几次就解决了，因为人会交流啊。可是如果这种情况发生在编程世界了，就有可能会一直没完没了地“谦让”下去，成为没有发生阻塞但依然执行不下去的“活锁”。</p><p>解决“<strong>活锁</strong>”的方案很简单，谦让时，尝试等待一个随机的时间就可以了。例如上面的那个例子，路人甲走左手边发现前面有人，并不是立刻换到右手边，而是等待一个随机的时间后，再换到右手边；同样，路人乙也不是立刻切换路线，也是等待一个随机的时间再切换。由于路人甲和路人乙等待的时间是随机的，所以同时相撞后再次相撞的概率就很低了。“等待一个随机时间”的方案虽然很简单，却非常有效，Raft这样知名的分布式一致性算法中也用到了它。</p><p>那“<strong>饥饿</strong>”该怎么去理解呢？<strong>所谓“饥饿”指的是线程因无法访问所需资源而无法执行下去的情况</strong>。“不患寡，而患不均”，如果线程优先级“不均”，在CPU繁忙的情况下，优先级低的线程得到执行的机会很小，就可能发生线程“饥饿”；持有锁的线程，如果执行的时间过长，也可能导致“饥饿”问题。</p><p>解决“<strong>饥饿</strong>”问题的方案很简单，有三种方案：一是保证资源充足，二是公平地分配资源，三就是避免持有锁的线程长时间执行。这三个方案中，方案一和方案三的适用场景比较有限，因为很多场景下，资源的稀缺性是没办法解决的，持有锁的线程执行的时间也很难缩短。倒是方案二的适用场景相对来说更多一些。</p><p>那如何公平地分配资源呢？在并发编程里，主要是使用公平锁。所谓公平锁，是一种先来后到的方案，线程的等待是有顺序的，排在等待队列前面的线程会优先获得资源。</p><h2>性能问题</h2><p>使用“锁”要非常小心，但是如果小心过度，也可能出“性能问题”。“锁”的过度使用可能导致串行化的范围过大，这样就不能够发挥多线程的优势了，而我们之所以使用多线程搞并发程序，为的就是提升性能。</p><p>所以我们要尽量减少串行，那串行对性能的影响是怎么样的呢？假设串行百分比是5%，我们用多核多线程相比单核单线程能提速多少呢？</p><p>有个阿姆达尔（Amdahl）定律，代表了处理器并行运算之后效率提升的能力，它正好可以解决这个问题，具体公式如下：</p><center>$S=\\frac{1}{(1-p)+\\frac{p}{n}}$</center><p>公式里的n可以理解为CPU的核数，p可以理解为并行百分比，那（1-p）就是串行百分比了，也就是我们假设的5%。我们再假设CPU的核数（也就是n）无穷大，那加速比S的极限就是20。也就是说，如果我们的串行率是5%，那么我们无论采用什么技术，最高也就只能提高20倍的性能。</p><p>所以使用锁的时候一定要关注对性能的影响。 那怎么才能避免锁带来的性能问题呢？这个问题很复杂，<strong>Java SDK并发包里之所以有那么多东西，有很大一部分原因就是要提升在某个特定领域的性能</strong>。</p><p>不过从方案层面，我们可以这样来解决这个问题。</p><p>第一，既然使用锁会带来性能问题，那最好的方案自然就是使用无锁的算法和数据结构了。在这方面有很多相关的技术，例如线程本地存储(Thread Local Storage, TLS)、写入时复制(Copy-on-write)、乐观锁等；Java并发包里面的原子类也是一种无锁的数据结构；Disruptor则是一个无锁的内存队列，性能都非常好……</p><p>第二，减少锁持有的时间。互斥锁本质上是将并行的程序串行化，所以要增加并行度，一定要减少持有锁的时间。这个方案具体的实现技术也有很多，例如使用细粒度的锁，一个典型的例子就是Java并发包里的ConcurrentHashMap，它使用了所谓分段锁的技术（这个技术后面我们会详细介绍）；还可以使用读写锁，也就是读是无锁的，只有写的时候才会互斥。</p><p>性能方面的度量指标有很多，我觉得有三个指标非常重要，就是：吞吐量、延迟和并发量。</p><ol>\n<li>吞吐量：指的是单位时间内能处理的请求数量。吞吐量越高，说明性能越好。</li>\n<li>延迟：指的是从发出请求到收到响应的时间。延迟越小，说明性能越好。</li>\n<li>并发量：指的是能同时处理的请求数量，一般来说随着并发量的增加、延迟也会增加。所以延迟这个指标，一般都会是基于并发量来说的。例如并发量是1000的时候，延迟是50毫秒。</li>\n</ol><h2>总结</h2><p>并发编程是一个复杂的技术领域，微观上涉及到原子性问题、可见性问题和有序性问题，宏观则表现为安全性、活跃性以及性能问题。</p><p>我们在设计并发程序的时候，主要是从宏观出发，也就是要重点关注它的安全性、活跃性以及性能。安全性方面要注意数据竞争和竞态条件，活跃性方面需要注意死锁、活锁、饥饿等问题，性能方面我们虽然介绍了两个方案，但是遇到具体问题，你还是要具体分析，根据特定的场景选择合适的数据结构和算法。</p><p>要解决问题，首先要把问题分析清楚。同样，要写好并发程序，首先要了解并发程序相关的问题，经过这7章的内容，相信你一定对并发程序相关的问题有了深入的理解，同时对并发程序也一定心存敬畏，因为一不小心就出问题了。不过这恰恰也是一个很好的开始，因为你已经学会了分析并发问题，然后解决并发问题也就不远了。</p><h2>课后思考</h2><p>Java语言提供的Vector是一个线程安全的容器，有同学写了下面的代码，你看看是否存在并发问题呢？</p><pre><code>void addIfNotExist(Vector v, \n    Object o){\n  if(!v.contains(o)) {\n    v.add(o);\n  }\n}\n</code></pre><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p><p></p>","neighbors":{"left":{"article_title":"06 | 用“等待-通知”机制优化循环等待","id":85241},"right":{"article_title":"08 | 管程：并发编程的万能钥匙","id":86089}},"comments":[{"had_liked":false,"id":75972,"user_name":"峰","can_delete":false,"product_type":"c1","uid":1056019,"ip_address":"","ucode":"C53CB64E8E7D19","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg","comment_is_top":false,"comment_ctime":1552518319,"is_pvip":true,"replies":[{"id":"27776","content":"👍<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552561346,"ip_address":"","comment_id":75972,"utype":1}],"discussion_count":5,"race_medal":0,"score":"774646631599","product_id":100023901,"comment_content":"vector是线程安全，指的是它方法单独执行的时候没有并发正确性问题，并不代表把它的操作组合在一起问木有，而这个程序显然有老师讲的竞态条件问题。","like_count":181,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443113,"discussion_content":"👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552561346,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1133702,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4c/86/3be94807.jpg","nickname":"angel😇txy🤓","note":"","ucode":"C0AEE0D8BAF7ED","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5663,"discussion_content":"老师很狡猾，想偷换概念引导大家","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1566424420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1128491,"avatar":"https://static001.geekbang.org/account/avatar/00/11/38/2b/9db9406b.jpg","nickname":"星夜","note":"","ucode":"3B46C09D994CEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332015,"discussion_content":"两个方法的调用显然不具有原子性","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1607045779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066046,"avatar":"https://static001.geekbang.org/account/avatar/00/10/44/3e/493e73fa.jpg","nickname":"灰太狼","note":"","ucode":"C17DD5D5ED9DC5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":208864,"discussion_content":"说的对，《Java并发实战》书里面特意强调的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1584585292,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1109776,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ef/10/201c6d44.jpg","nickname":"Jason Ma","note":"","ucode":"E28F94948EE085","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330091,"discussion_content":"学习了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1606529844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81269,"user_name":"kaixiao7","can_delete":false,"product_type":"c1","uid":1242577,"ip_address":"","ucode":"505EC4AFB5E656","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/d1/cc6f82eb.jpg","comment_is_top":false,"comment_ctime":1553845774,"is_pvip":false,"replies":[{"id":"29489","content":"你可以这么理解：临界区都是串行的，非临界区都是并行的，用单线程执行临界区的时间&#47;用单线程执行(临界区+非临界区)的时间就是串行百分比","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553906430,"ip_address":"","comment_id":81269,"utype":1}],"discussion_count":3,"race_medal":0,"score":"547014692366","product_id":100023901,"comment_content":"老师，串行百分比一般怎么得出来呢（依据是什么）?","like_count":127,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445135,"discussion_content":"你可以这么理解：临界区都是串行的，非临界区都是并行的，用单线程执行临界区的时间/用单线程执行(临界区+非临界区)的时间就是串行百分比","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1553906430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1648334,"avatar":"https://static001.geekbang.org/account/avatar/00/19/26/ce/acb6c140.jpg","nickname":"祉幻","note":"","ucode":"ABE19FE8A6A15E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571305,"discussion_content":"插眼：计算串行百分比\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652172149,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1493907,"avatar":"https://static001.geekbang.org/account/avatar/00/16/cb/93/4adea49a.jpg","nickname":"努力努力再努力","note":"","ucode":"0C6EEA28FCE8C7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":564494,"discussion_content":"mark 串行百分比计算","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650256816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76072,"user_name":"飘呀飘的小叶子","can_delete":false,"product_type":"c1","uid":1398591,"ip_address":"","ucode":"D662116E38B212","user_header":"https://static001.geekbang.org/account/avatar/00/15/57/3f/0009a20f.jpg","comment_is_top":false,"comment_ctime":1552528073,"is_pvip":false,"replies":[{"id":"27813","content":"👍<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552570348,"ip_address":"","comment_id":76072,"utype":1}],"discussion_count":5,"race_medal":0,"score":"319380107977","product_id":100023901,"comment_content":"Vector实现线程安全是通过给主要的写方法加了synchronized，类似contains这样的读方法并没有synchronized，该题的问题就出在不是线程安全的contains方法，两个线程如果同时执行到if(!v.contains(o)) 是可以都通过的，这时就会执行两次add方法，重复添加。也就是老师说的竞态条件。","like_count":75,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443165,"discussion_content":"👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552570348,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1284938,"avatar":"https://static001.geekbang.org/account/avatar/00/13/9b/4a/6faf0428.jpg","nickname":"sdyin","note":"","ucode":"7DA6F50117410E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42052,"discussion_content":"就算contains方法加锁了也会有问题 , 第一个线程去判断是否满足 , 满足通过，刚准备add，cup切换线程执行，第二个线程也去判断也满足，然后一个add了，另外一个也跟着add了，要保证判断和执行是一个原子操作","likes_number":21,"is_delete":false,"is_hidden":false,"ctime":1572577041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1606690,"avatar":"https://static001.geekbang.org/account/avatar/00/18/84/22/3a740773.jpg","nickname":"毛郴哲","note":"","ucode":"55A067B2AE89A4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5620,"discussion_content":"contains方法是没有加synchronized，但是contains方法中return indexOf()，indexOf()这个方法是加了synchronized的，所以我认为你的说法有问题","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1566386702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1277081,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7c/99/4dac6ce6.jpg","nickname":"lakeslove","note":"","ucode":"65E14D29D3C981","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1606690,"avatar":"https://static001.geekbang.org/account/avatar/00/18/84/22/3a740773.jpg","nickname":"毛郴哲","note":"","ucode":"55A067B2AE89A4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318274,"discussion_content":"是啊，所以老师给他一个������到底是什么意思啊。。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603694312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":5620,"ip_address":""},"score":318274,"extra":""}]},{"author":{"id":1184678,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJDgV2qia6eAL7Fb4egX3odViclRRwOlkfCBrjhU9lLeib90KGkIDjdddSibNVs47N90L36Brgnr6ppiag/132","nickname":"ddww","note":"","ucode":"2871112FC9B3F7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383147,"discussion_content":"contains没有加synchronized，但是contains调的是indexOf方法，该方法加了synchronized。这相当于contanins加了synchronized。这个问题和contanins加没加synchronized，没有关系。老师的题，相当于两个操作，属于原子性问题，竞态条件。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625927986,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76248,"user_name":"虎虎❤️","can_delete":false,"product_type":"c1","uid":1086535,"ip_address":"","ucode":"157F261E80291A","user_header":"https://static001.geekbang.org/account/avatar/00/10/94/47/75875257.jpg","comment_is_top":false,"comment_ctime":1552556806,"is_pvip":false,"replies":[{"id":"27831","content":"能看懂说明基本功很扎实啊。你的建议我会考虑的。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552574206,"ip_address":"","comment_id":76248,"utype":1}],"discussion_count":1,"race_medal":0,"score":"302200267526","product_id":100023901,"comment_content":"老师讲的太好了。我没有并发的编程经验，但是可以看懂每一篇文章，也可以正确回答每节课后的习题。我觉得这次跟对了人，觉得很有希望跟着老师学好并发。<br><br>但是，这样跟着学完课程就能学好并发编程吗？老师可以给些建议吗？除了跟着课程，我还需要做些什么来巩固战果？老师能不能给加餐一篇学习方法，谢谢！<br><br>本节课总结：<br>安全性：<br>数据竞争： 多个线程同时访问一个数据，并且至少有一个线程会写这个数据。<br>竞态条件： 程序的执行结果依赖程序执行的顺序。<br>也可以按照以下的方式理解竞态条件： 程序的执行依赖于某个状态变量，在判断满足条件的时候执行，但是在执行时其他变量同时修改了状态变量。<br>if (状态变量 满足 执行条件) {<br>  执行操作<br>}<br>问题： 数据竞争一定会导致程序存在竞态条件吗？有没有什么相关性？<br><br>活跃性：<br>死锁：破坏造成死锁的条件，1,使用等待-通知机制的Allocator; 2主动释放占有的资源；3,按顺序获取资源。<br>活锁：虽然没有发生阻塞，但仍会存在执行不下去的情况。我感觉像进入了某种怪圈。解决办法，等待随机的时间，例如Raft算法中重新选举leader。<br>饥饿：我想到了没有引入时间片概念时，cpu处理作业。如果遇到长作业，会导致短作业饥饿。如果优先处理短作业，则会饿死长作业。长作业就可以类比持有锁的时间过长，而时间片可以让cpu资源公平地分配给各个作业。当然，如果有无穷多的cpu，就可以让每个作业得以执行，就不存在饥饿了。<br><br>性能：<br>核心就是在保证安全性和活跃性的前提下，根据实际情况，尽量降低锁的粒度。即尽量减少持有锁的时间。JDK的并发包里，有很多特定场景针对并发性能的设计。还有很多无锁化的设计，例如MVCC，TLS，COW等，可以根据不同的场景选用不同的数据结构或设计。<br><br>最后，在程序设计时，要从宏观出发，也就是关注安全性，活跃性和性能。遇到问题的时候，可以从微观去分析，让看似诡异的bug无所遁形。","like_count":70,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443229,"discussion_content":"能看懂说明基本功很扎实啊。你的建议我会考虑的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552574206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82768,"user_name":"寒铁","can_delete":false,"product_type":"c1","uid":1400954,"ip_address":"","ucode":"55D5A06E55005B","user_header":"https://static001.geekbang.org/account/avatar/00/15/60/7a/9d8eb53b.jpg","comment_is_top":false,"comment_ctime":1554303042,"is_pvip":false,"replies":[{"id":"29928","content":"👍<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554338103,"ip_address":"","comment_id":82768,"utype":1}],"discussion_count":1,"race_medal":0,"score":"134698289218","product_id":100023901,"comment_content":"add10K() 如果用synchronized修饰 应该就没有问题了吧？ get和set是synchronized不能保证调用get和set之间的没有其他线程进入get和set，所以这是导致出错的根本原因。","like_count":31,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445716,"discussion_content":"👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554338103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76063,"user_name":"Nevermore","can_delete":false,"product_type":"c1","uid":1228011,"ip_address":"","ucode":"06EBD2E6A9B436","user_header":"https://static001.geekbang.org/account/avatar/00/12/bc/eb/c22ef3a5.jpg","comment_is_top":false,"comment_ctime":1552527258,"is_pvip":false,"replies":[{"id":"27798","content":"👍<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552567133,"ip_address":"","comment_id":76063,"utype":1}],"discussion_count":3,"race_medal":0,"score":"134696513434","product_id":100023901,"comment_content":"编写并发程序的初衷是为了提升性能，但在追求性能的同时由于多线程操作共享资源而出现了安全性问题，所以才用到了锁技术，一旦用到了锁技术就会出现了死锁，活锁等活跃性问题，而且不恰当的使用锁，导致了串行百分比的增加，由此又产生了性能问题，所以这就是并发程序与锁的因果关系。","like_count":31,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443158,"discussion_content":"👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552567133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1493907,"avatar":"https://static001.geekbang.org/account/avatar/00/16/cb/93/4adea49a.jpg","nickname":"努力努力再努力","note":"","ucode":"0C6EEA28FCE8C7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":564495,"discussion_content":"很不错的总结。 \n\n为了性能 —— 导致不安全，产生可见性 原子性 有序性问题\n\n为了安全 —— 使用锁技术，导致死锁 活锁 饥饿\n\n为了锁技术 —— 导致性能问题，串行化，通过公式计算时间百分比，减少锁持有的时间","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650257031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2715554,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLBHy0D2KUZwOGHRG8qloicx2V4E4mImsPIiavPfr12BZB6QyUlHNdmOohC3EbsgnM2QNBeoqu82Grw/132","nickname":"皮卡卡","note":"","ucode":"52B3F234550E7F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546708,"discussion_content":"这个理解不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642397421,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75982,"user_name":"一道阳光","can_delete":false,"product_type":"c1","uid":1239557,"ip_address":"","ucode":"F35207CCCEC6E2","user_header":"https://static001.geekbang.org/account/avatar/00/12/ea/05/c0d8014d.jpg","comment_is_top":false,"comment_ctime":1552520328,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"108926702728","product_id":100023901,"comment_content":"contains和add之间不是原子操作，有可能重复添加。","like_count":25,"discussions":[{"author":{"id":1341612,"avatar":"https://static001.geekbang.org/account/avatar/00/14/78/ac/e5e6e7f3.jpg","nickname":"古夜","note":"","ucode":"0A82D3CFCEDF07","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275035,"discussion_content":"所以解决办法就是给这个方法添加sync吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590651148,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1018706,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/52/6659dc1b.jpg","nickname":"黑米","note":"","ucode":"E7DBEA7867862A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1341612,"avatar":"https://static001.geekbang.org/account/avatar/00/14/78/ac/e5e6e7f3.jpg","nickname":"古夜","note":"","ucode":"0A82D3CFCEDF07","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391134,"discussion_content":"也可以在想要原子性的代码加个锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630310696,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":275035,"ip_address":""},"score":391134,"extra":""}]}]},{"had_liked":false,"id":76005,"user_name":"亮亮","can_delete":false,"product_type":"c1","uid":1438471,"ip_address":"","ucode":"F0A735E6A5D12B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eq4MOA39w9A55icXsf5Q2NSSTQP0dkEtfAG1uDlSzqu3m4YIXTcQT1Zy3cyj6CGKr3eHjbkwiberCMQ/132","comment_is_top":false,"comment_ctime":1552523402,"is_pvip":false,"replies":[{"id":"27838","content":"对的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552581314,"ip_address":"","comment_id":76005,"utype":1}],"discussion_count":3,"race_medal":0,"score":"96041803914","product_id":100023901,"comment_content":"void addIfNotExist(Vector v, <br>    Object o){<br>synchronized(v) {<br>  if(!v.contains(o)) {<br>    v.add(o);<br>  }<br>}<br>}<br>这样不知道对不对","like_count":22,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443129,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552581314,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1341612,"avatar":"https://static001.geekbang.org/account/avatar/00/14/78/ac/e5e6e7f3.jpg","nickname":"古夜","note":"","ucode":"0A82D3CFCEDF07","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275038,"discussion_content":"这样其实和在void方法上加 sync没有区别吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590651237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2100403,"avatar":"https://static001.geekbang.org/account/avatar/00/20/0c/b3/7e13920b.jpg","nickname":"🎓Dream-seeker","note":"","ucode":"3C8477DE9DD766","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1341612,"avatar":"https://static001.geekbang.org/account/avatar/00/14/78/ac/e5e6e7f3.jpg","nickname":"古夜","note":"","ucode":"0A82D3CFCEDF07","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556807,"discussion_content":"持有的锁和锁的的资源不一样，楼主锁的是vector，因为add方法是对vector这个对象加锁","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1647521072,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":275038,"ip_address":""},"score":556807,"extra":""}]}]},{"had_liked":false,"id":76542,"user_name":"易水南风","can_delete":false,"product_type":"c1","uid":1123818,"ip_address":"","ucode":"A2A0F18228A5D0","user_header":"https://static001.geekbang.org/account/avatar/00/11/25/ea/ec869117.jpg","comment_is_top":false,"comment_ctime":1552630516,"is_pvip":false,"replies":[{"id":"27943","content":"同时执行，指的是同时被调用。被锁串行后，还是有问题","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552651825,"ip_address":"","comment_id":76542,"utype":1}],"discussion_count":10,"race_medal":0,"score":"91746943732","product_id":100023901,"comment_content":"add10k的例子不明白，因为两个方法都已经加上锁了，同一个test对象应该不可能两个线程同时执行吧？","like_count":21,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443346,"discussion_content":"同时执行，指的是同时被调用。被锁串行后，还是有问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552651825,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1150234,"avatar":"https://static001.geekbang.org/account/avatar/00/11/8d/1a/ecacb992.jpg","nickname":"文哲","note":"","ucode":"62DBD7CA1E7726","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298451,"discussion_content":"我也觉得这个地方有问题，第三课用 synchronized 关键字限制 get set，那时候说：“管程，就是我们这里的 synchronized（至于为什么叫管程，我们后面介绍），我们知道 synchronized 修饰的临界区是互斥的，也就是说同一时刻只有一个线程执行临界区的代码”、“按照这个规则，如果多个线程同时执行 addOne() 方法，可见性是可以保证的，也就说如果有 1000 个线程执行 addOne() 方法，最终结果一定是 value 的值增加了 1000”，怎么这个时候，可见性保证不了了吗？这不是前后矛盾吗？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1597302363,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1137353,"avatar":"https://static001.geekbang.org/account/avatar/00/11/5a/c9/933ee0a8.jpg","nickname":"冉野","note":"","ucode":"2CAEA424996876","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5570,"discussion_content":"我也是很纠结这个问题 都已经上锁了 怎么还会有两个线程同时执行get方法。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1566357944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1197964,"avatar":"https://static001.geekbang.org/account/avatar/00/12/47/8c/9708a8c5.jpg","nickname":"XIII","note":"","ucode":"14ACE12BF06D64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1137353,"avatar":"https://static001.geekbang.org/account/avatar/00/11/5a/c9/933ee0a8.jpg","nickname":"冉野","note":"","ucode":"2CAEA424996876","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6624,"discussion_content":"get 执行是一前一后，但是这两都在 set 执行前，所以 get 到的值都一样。","likes_number":14,"is_delete":false,"is_hidden":false,"ctime":1567001543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":5570,"ip_address":""},"score":6624,"extra":""},{"author":{"id":1018620,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/fc/d1dd57dd.jpg","nickname":"ipofss","note":"","ucode":"DE3061C9259F9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1197964,"avatar":"https://static001.geekbang.org/account/avatar/00/12/47/8c/9708a8c5.jpg","nickname":"XIII","note":"","ucode":"14ACE12BF06D64","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":21329,"discussion_content":"这位老哥解释到位，同时执行到get，但在set之前，get分别获取到值是一样的，然后同时竞争set，后面的set把前面的替换了","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1569468571,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":6624,"ip_address":""},"score":21329,"extra":""},{"author":{"id":1131470,"avatar":"https://static001.geekbang.org/account/avatar/00/11/43/ce/a3734a6c.jpg","nickname":"杨过","note":"","ucode":"B12249055A8417","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1018620,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/fc/d1dd57dd.jpg","nickname":"ipofss","note":"","ucode":"DE3061C9259F9E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":112419,"discussion_content":"但是set确实是只有一个线程，这样在set之前，get也就不可能有两个线程了吧？因为get在set里面啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577860621,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":21329,"ip_address":""},"score":112419,"extra":""}]},{"author":{"id":1489957,"avatar":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","nickname":"tt","note":"","ucode":"7753B79AD5A9AC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299457,"discussion_content":"是不是因为原子性问题导致结果不正确。\n\n这里结论的正确性依赖于:\n\n1、在get获取锁时，set还没有获取锁。\n\n2、线程一执行完运算，释放锁，结果还没有写入内存时休眠，此时线程2获取set的锁，也执行完毕。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597708917,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2768260,"avatar":"","nickname":"Geek_f0c13c","note":"","ucode":"662EDB3B61AF26","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542485,"discussion_content":"如果是执行顺序是get get set set那就会有问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640764890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1150234,"avatar":"https://static001.geekbang.org/account/avatar/00/11/8d/1a/ecacb992.jpg","nickname":"文哲","note":"","ucode":"62DBD7CA1E7726","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298489,"discussion_content":"看 XIII 老哥 应该说的之后有点理解了，get 执行是一前一后，但是这两都在 set 执行前，所以 get 到的值都一样。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597309920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76006,"user_name":"hanmshashou","can_delete":false,"product_type":"c1","uid":1147615,"ip_address":"","ucode":"3424FFBEDE6138","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/B5KGe7PEWv1m0ZdUSRBLaX65brD5Iice8ze7xpFDJIzOTQSN2JqCkCYwOnTMW5ApNCyicCAs8t48DUuX5t66VHBQ/132","comment_is_top":false,"comment_ctime":1552523478,"is_pvip":false,"replies":[{"id":"27836","content":"是这样，高手！","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552581092,"ip_address":"","comment_id":76006,"utype":1}],"discussion_count":2,"race_medal":0,"score":"65977032918","product_id":100023901,"comment_content":"ConcurrentHashMap 1.8后没有分段锁 syn + cas","like_count":15,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443130,"discussion_content":"是这样，高手！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552581092,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2963434,"avatar":"","nickname":"Geek_94fa0e","note":"","ucode":"15BC7D4E130E80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560433,"discussion_content":"这个 cas 是啥啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649327244,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75979,"user_name":"探索无止境","can_delete":false,"product_type":"c1","uid":1044178,"ip_address":"","ucode":"91D2A9907DFA79","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/d2/7024431c.jpg","comment_is_top":false,"comment_ctime":1552519561,"is_pvip":false,"replies":[{"id":"27826","content":"对于一台webserver，吞吐量一般指的是server每秒钟能处理多少请求；并发量指的是有多少个客户端同时访问。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552573693,"ip_address":"","comment_id":75979,"utype":1}],"discussion_count":3,"race_medal":0,"score":"65977029001","product_id":100023901,"comment_content":"吞吐量和并发量从文中描述的概念上来看，总觉得很像，具体该怎么区分？期待指点！","like_count":16,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443117,"discussion_content":"对于一台webserver，吞吐量一般指的是server每秒钟能处理多少请求；并发量指的是有多少个客户端同时访问。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552573693,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1796406,"avatar":"","nickname":"有所谓无所谓","note":"","ucode":"928FE981B71A07","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":255752,"discussion_content":"吞吐量感觉像消费速度（服务端消费者）、并发量感觉像生产速度（客户端生产者）","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588426774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1904718,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/10/4e/b14f8d43.jpg","nickname":"哒糖","note":"","ucode":"027D06643CE48A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1796406,"avatar":"","nickname":"有所谓无所谓","note":"","ucode":"928FE981B71A07","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369174,"discussion_content":"不太恰当吧，生产是一个个生产，但是并发是同时进行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618967654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":255752,"ip_address":""},"score":369174,"extra":""}]}]},{"had_liked":false,"id":76826,"user_name":"iron_man","can_delete":false,"product_type":"c1","uid":1099883,"ip_address":"","ucode":"C0053A59442910","user_header":"https://static001.geekbang.org/account/avatar/00/10/c8/6b/0f3876ef.jpg","comment_is_top":false,"comment_ctime":1552721319,"is_pvip":false,"replies":[{"id":"28017","content":"总结的对。就是同时放弃，然后又重试竞争，最后死循环在里面了。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552729056,"ip_address":"","comment_id":76826,"utype":1}],"discussion_count":4,"race_medal":0,"score":"53092328871","product_id":100023901,"comment_content":"关于活锁，看了老师举的例子还是不太明白。<br>死锁是多个线程互相持有彼此需要的资源，形成依赖循环。<br>活锁是多个线程类似死锁的情况下，同时释放掉自己已经获取的资源，然后同时获取另外一种资源，又形成依赖循环，导致都不能执行下去？不知道总结的对不对，老师可否点评一下？","like_count":12,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443458,"discussion_content":"总结的对。就是同时放弃，然后又重试竞争，最后死循环在里面了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552729056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1123043,"avatar":"https://static001.geekbang.org/account/avatar/00/11/22/e3/510b69f9.jpg","nickname":"benny","note":"","ucode":"E2F30AF0C808D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":107479,"discussion_content":"有活锁的实例代码就好了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577583556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2046055,"avatar":"","nickname":"杜总","note":"","ucode":"C6600875A265E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286174,"discussion_content":"有活锁的实例代码就好了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593079705,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135604,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/f4/e277325d.jpg","nickname":"bin.chen","note":"","ucode":"5BA49358AB8A1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":249747,"discussion_content":"这就跟平时走在路上对面遇到一个人，大家互相谦让，结果导致最后大家一直来来回回","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587958866,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":80418,"user_name":"0928","can_delete":false,"product_type":"c1","uid":1240990,"ip_address":"","ucode":"03221745CF8141","user_header":"https://static001.geekbang.org/account/avatar/00/12/ef/9e/78420b67.jpg","comment_is_top":false,"comment_ctime":1553658431,"is_pvip":false,"replies":[{"id":"29359","content":"写一个文件只需要一个线程就够了。<br>你可以用生产者-消费者模式试一下。<br>可以创建64个线程，每个线程负责16个文件，<br>同时创建64个阻塞队列，64个线程消费这76个阻塞队列，<br> 电话号码%1024 % 64 进入目标阻塞队列。<br><br>其余的就是优化一下写文件的效率了<br><br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553700088,"ip_address":"","comment_id":80418,"utype":1}],"discussion_count":4,"race_medal":0,"score":"48798298687","product_id":100023901,"comment_content":"老师我在补充一下我之前的提问：<br>流程是，服务器上存了2000万个电话号码相关的数据，要做的是把这批号码从服务器上请求下来写入到本地的文件中，为了将数据打散到多个文件中，这里通过 电话号码%1024 得到的余数来确定这个号码需要存入到哪个文件中取，比如13888888888 % 1024 =56，那么这个号码会被存入到 56.txt的文件中，写入时是一行一个号码。<br>为了效率这里使用了多线程来请求数据并将请求下来的数据写入到文件，也就是每个线程包含向服务器请求数据，然后在将数据写入到电话号码对1024取余的那个文件中去，如果这么做目前会有一个隐患，多线程时如果 电话号码%1024 后定位的是同一个文件，那么就会出现多线程同时写这个文件的操作，一定程度上会造成最终结果错误。","like_count":11,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444856,"discussion_content":"写一个文件只需要一个线程就够了。\n你可以用生产者-消费者模式试一下。\n可以创建64个线程，每个线程负责16个文件，\n同时创建64个阻塞队列，64个线程消费这76个阻塞队列，\n 电话号码%1024 % 64 进入目标阻塞队列。\n\n其余的就是优化一下写文件的效率了\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553700088,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2014196,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTICpYDicqYOnUicMGJVcVyg32UwXiaSlBtVU2V2UC4dts1ddsCC2HPMYYmcbhe8QS2QR02DcXezLZ24Q/132","nickname":"Qoney","note":"","ucode":"A3EB4F1EA02531","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":273048,"discussion_content":"老师，你的回答 没太懂，意思64个线程去服务器拉数据，在开辟一个写线程 到队列里面拉数据写到文件？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590400211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1147331,"avatar":"","nickname":"geoxs","note":"","ucode":"1B377DB0A58F89","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2014196,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTICpYDicqYOnUicMGJVcVyg32UwXiaSlBtVU2V2UC4dts1ddsCC2HPMYYmcbhe8QS2QR02DcXezLZ24Q/132","nickname":"Qoney","note":"","ucode":"A3EB4F1EA02531","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293323,"discussion_content":"读写分离，每个文件专门有一个队列保存要写的电话号，也专门有一个线程从这个队列拿数据往里写。读取是另外的线程，一个就足够，读取电话后分发到64个队列就行了。也就是需要一个读线程，64个写线程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595504206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":273048,"ip_address":""},"score":293323,"extra":""},{"author":{"id":1463740,"avatar":"https://static001.geekbang.org/account/avatar/00/16/55/bc/fad0090b.jpg","nickname":"Yeyw","note":"","ucode":"C9D20DB91C3BE5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1147331,"avatar":"","nickname":"geoxs","note":"","ucode":"1B377DB0A58F89","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374053,"discussion_content":"76个阻塞队列是什么意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620981829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":293323,"ip_address":""},"score":374053,"extra":""}]}]},{"had_liked":false,"id":76309,"user_name":"Demter","can_delete":false,"product_type":"c1","uid":1158439,"ip_address":"","ucode":"BE3B6F726916CE","user_header":"https://static001.geekbang.org/account/avatar/00/11/ad/27/5556ae50.jpg","comment_is_top":false,"comment_ctime":1552570160,"is_pvip":false,"replies":[{"id":"27824","content":"同时访问，被串行化后，一先一后，结果两个线程都得到1","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552573486,"ip_address":"","comment_id":76309,"utype":1}],"discussion_count":2,"race_medal":0,"score":"48797210416","product_id":100023901,"comment_content":"老师说两个线程同时访问get()，所以可能返回1.但是两个线程不可能同时访问get(),get（）上面有互斥锁啊，所以这个不是很懂啊","like_count":11,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443249,"discussion_content":"同时访问，被串行化后，一先一后，结果两个线程都得到1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552573486,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1532964,"avatar":"https://static001.geekbang.org/account/avatar/00/17/64/24/a8d84050.jpg","nickname":"黄呈龙","note":"","ucode":"227C836ED4F8DD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6858,"discussion_content":"哦，是这个意思\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567145362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91771,"user_name":"师志强","can_delete":false,"product_type":"c1","uid":1104267,"ip_address":"","ucode":"9D30EE3BFEDB8A","user_header":"https://static001.geekbang.org/account/avatar/00/10/d9/8b/76c27279.jpg","comment_is_top":false,"comment_ctime":1557105888,"is_pvip":false,"replies":[{"id":"34442","content":"对的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558359207,"ip_address":"","comment_id":91771,"utype":1}],"discussion_count":4,"race_medal":0,"score":"35916844256","product_id":100023901,"comment_content":"add10k问题很多不明白，会问get有锁，怎么会同时执行。get虽然有锁，只能保证多个线程不能同一时刻执行。但是出现不安全的可能是线程a调用get后线程b调用get,这时两个get返回的值是一样的。然后都加一后再分别set.这样两个线程就出现并发问题了。问题在于同时执行get，而在于get和set是两个方法，这两个方法组合不是原子的，就可能两个方法中间的时间也有其它线程分别调用，出现并发问题。不知道这样解释对不对？","like_count":8,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449024,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558359207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1638187,"avatar":"","nickname":"Geek_94adb8","note":"","ucode":"B142F473E1A0B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":204247,"discussion_content":"get和set不是用得同一个锁吗？线程a调用get,线程b能够调用get肯定是线程a调用set完之后才能释放锁啊，这时候的值肯定变了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584148140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1740204,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/8d/ac/8a428bd8.jpg","nickname":"阮少","note":"","ucode":"2F007C96CB60F9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1638187,"avatar":"","nickname":"Geek_94adb8","note":"","ucode":"B142F473E1A0B3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":204372,"discussion_content":"线程a调用完之后get之后就会释放锁，不是a调用完get和set之后才释放锁","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1584164662,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":204247,"ip_address":""},"score":204372,"extra":""}]},{"author":{"id":1141923,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6c/a3/7d60e2a0.jpg","nickname":"1184507801","note":"","ucode":"930E2F79C5582A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538240,"discussion_content":"原来如此","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639378557,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76002,"user_name":"ken","can_delete":false,"product_type":"c1","uid":1048245,"ip_address":"","ucode":"A43E42B541624D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fe/b5/df0f658f.jpg","comment_is_top":false,"comment_ctime":1552523184,"is_pvip":false,"replies":[{"id":"27837","content":"方法上加还不行","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552581276,"ip_address":"","comment_id":76002,"utype":1}],"discussion_count":3,"race_medal":0,"score":"31617294256","product_id":100023901,"comment_content":"实例不是线程安全的，Vector容器虽然是安全的单这个安全的原子性范围紧紧是每个成员方法。当需要调用多个方法来完成一个操作时Vector容器的原子性就适用了需要收到控制原子性，可以通过在方法上加synchronize保证安全性原子性。","like_count":7,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443127,"discussion_content":"方法上加还不行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552581276,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1437158,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ed/e6/75a32708.jpg","nickname":"日拱一兵","note":"","ucode":"D6386E5CD7C061","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":191900,"discussion_content":"方法上加肯定不行，在方法上加sync，是锁定的this，但是参数vector并没有锁，也就是用自家锁锁了别人家的大门，另一个线程是完全有可能在其他方法上修改vector变量的","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1583044608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1048245,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fe/b5/df0f658f.jpg","nickname":"ken","note":"","ucode":"A43E42B541624D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":313742,"discussion_content":" 谢谢，理解了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603086022,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":116101,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1563786183,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27333589959","product_id":100023901,"comment_content":"---总结---<br>1. 并发编程的三大问题：安全性问题；活跃性问题；性能问题<br>2. 安全性问题的源头：原子性；可见性；有序性<br>3. 安全性问题出现的根本原因：数据竞争（多个线程读写共享数据）；竞态条件（程序的执行结果依赖线程执行的顺序）<br>4. 活跃性问题的三种情况：死锁；活锁；饥饿<br>5. 性能问题的衡量：阿姆达尔定律<br>6. 性能问题的几种思路：无锁方案（TLS、COW、乐观锁）；减少锁粒度","like_count":6},{"had_liked":false,"id":76046,"user_name":"ack","can_delete":false,"product_type":"c1","uid":1440912,"ip_address":"","ucode":"69CA1233EEA8E2","user_header":"https://static001.geekbang.org/account/avatar/00/15/fc/90/c9df0459.jpg","comment_is_top":false,"comment_ctime":1552526003,"is_pvip":false,"replies":[{"id":"27814","content":"方法上加锁，我觉得也不行，原因是这个方法不是vector的方法","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552570695,"ip_address":"","comment_id":76046,"utype":1}],"discussion_count":2,"race_medal":0,"score":"27322329779","product_id":100023901,"comment_content":"<br><br>如果查看下vector的源码，就会发现vector实现线程安全只是每个方法都加了synchronized关键字。而下面方法中add和contains操作是复合操作。<br>如果要保证这个方法是原子操作，应该在这个方法上加锁。<br>void addIfNotExist(Vector v, <br>    Object o){<br>  if(!v.contains(o)) {&#47;&#47;进行这个判断同时可能执行了add操作<br>    v.add(o);<br>  }<br>}<br><br>","like_count":6,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443148,"discussion_content":"方法上加锁，我觉得也不行，原因是这个方法不是vector的方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552570695,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121459,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1c/b3/6d10ba4f.jpg","nickname":"Running Man","note":"","ucode":"4DD2F6AF71327E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":130997,"discussion_content":"要在这里锁v就可以了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578818039,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77649,"user_name":"你只是看起来很努力","can_delete":false,"product_type":"c1","uid":1449173,"ip_address":"","ucode":"F9340A560D347C","user_header":"https://static001.geekbang.org/account/avatar/00/16/1c/d5/248a9c38.jpg","comment_is_top":false,"comment_ctime":1552978050,"is_pvip":false,"replies":[{"id":"28452","content":"vector的地址不会变，只是个指针而已<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553043123,"ip_address":"","comment_id":77649,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23027814530","product_id":100023901,"comment_content":"void addIfNotExist(Vector v,<br>    Object o){<br>synchronized(v) {<br>  if(!v.contains(o)) {<br>    v.add(o);<br>  }<br>}<br>}<br>老师关于亮亮这个改动我有个问题：如果两个线程读到的是一个满的vector，那么线程1先加锁执行，这时候会进行扩容，vector的地址就改变了，线程2再来执行的时候，它之前读取到的vector地址是已经释放掉的，那么程序不会出问题吗？","like_count":5,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443807,"discussion_content":"vector的地址不会变，只是个指针而已\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553043123,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1702117,"avatar":"https://static001.geekbang.org/account/avatar/00/19/f8/e5/119d5c15.jpg","nickname":"山海","note":"","ucode":"77FA9967E58FA3","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348607,"discussion_content":"这里我理解的Vector只是一个对象指针，这里我理解这位同学的意思，想的是数组扩容重拷贝重分配内存问题， 我觉得扩容只会对对象内部对那个数组进行重分配， 本质这个对象对指针还是指着这个对象。 而这个对象对内容数组可就不是一个内容数组了。 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612665710,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95692,"user_name":"Anthony","can_delete":false,"product_type":"c1","uid":1056955,"ip_address":"","ucode":"B0BF17E3EE35E2","user_header":"https://static001.geekbang.org/account/avatar/00/10/20/bb/f8b40882.jpg","comment_is_top":false,"comment_ctime":1558143845,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18738013029","product_id":100023901,"comment_content":"「临界区串行，非临界区并行」 ，就很好理解，set（get（）） 符合操作时在并发场景下的安全性问题了。","like_count":4},{"had_liked":false,"id":77101,"user_name":"风起时","can_delete":false,"product_type":"c1","uid":1125840,"ip_address":"","ucode":"41E3E457F1E970","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/d0/1fe7144e.jpg","comment_is_top":false,"comment_ctime":1552833766,"is_pvip":false,"replies":[{"id":"28133","content":"指的是方法被同时调用，不是先拿set的锁，是先拿get的锁。先计算参数，后调用方法","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552881567,"ip_address":"","comment_id":77101,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18732702950","product_id":100023901,"comment_content":"add10K例子中，set,get都是同一把锁，而且执行规则是set方法拿到锁之后，get方法再次获取该锁，不存在两个线程同时执行get方法啊，请老师解答下","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443579,"discussion_content":"指的是方法被同时调用，不是先拿set的锁，是先拿get的锁。先计算参数，后调用方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552881567,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76901,"user_name":"王玉坤","can_delete":false,"product_type":"c1","uid":1444914,"ip_address":"","ucode":"C18A61E31D47CA","user_header":"https://static001.geekbang.org/account/avatar/00/16/0c/32/a032d3c2.jpg","comment_is_top":false,"comment_ctime":1552744716,"is_pvip":false,"replies":[{"id":"28076","content":"两个线程同时执行set(1){count=1}，即便有同步，写到内存里的值也是1","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552791490,"ip_address":"","comment_id":76901,"utype":1}],"discussion_count":4,"race_medal":0,"score":"18732613900","product_id":100023901,"comment_content":"老师，add10K()那块不是很懂，就算两个线程get()方法都读到0，他们在s调set()方法时因为是同步方法，总会一前一后的，根据hapens-before原则，前面修改的值应该对后面可见，为什么这个地方会出错呢？","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443493,"discussion_content":"两个线程同时执行set(1){count=1}，即便有同步，写到内存里的值也是1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552791490,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1638187,"avatar":"","nickname":"Geek_94adb8","note":"","ucode":"B142F473E1A0B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":204249,"discussion_content":"这个老师的例子有问题，自己都不能自圆其说","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584148224,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3010442,"avatar":"","nickname":"Geek_cc7bf3","note":"","ucode":"3BB263DBEC04E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574576,"discussion_content":"同步方法，但是B线程已经拿到0了，后面再加1得到1然后再set就是1。happens before 必须要给add10k方法加锁才能实现该规则","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654156665,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2046055,"avatar":"","nickname":"杜总","note":"","ucode":"C6600875A265E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286177,"discussion_content":"不是原子性操作，本质是内存可见性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593079903,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81759,"user_name":"侯大虎","can_delete":false,"product_type":"c1","uid":1345219,"ip_address":"","ucode":"6450C75089FDB2","user_header":"","comment_is_top":false,"comment_ctime":1554027254,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14438929142","product_id":100023901,"comment_content":"思考题的存在 竞态条件问题，ve虽然是线程安全，但是由于外部的方法不是线程安全，会导致: 线程A,B同时进入if，线程A获得了ve的锁，然后Add后 B线程开始执行，发现没有包含，继续Add。     两个线程不满足hb原则，所以B,A都看不到对方的Add，导致if都成立。","like_count":3},{"had_liked":false,"id":76627,"user_name":"段少","can_delete":false,"product_type":"c1","uid":1445377,"ip_address":"","ucode":"C66CD6D67C1EF0","user_header":"https://static001.geekbang.org/account/avatar/00/16/0e/01/06115fa4.jpg","comment_is_top":false,"comment_ctime":1552649369,"is_pvip":false,"replies":[{"id":"27950","content":"如果只有这一个方法可以，vector有可能在别的地方使用，锁v就会更好一些","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552653362,"ip_address":"","comment_id":76627,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14437551257","product_id":100023901,"comment_content":"方法上加sync为什么不行，老师，求解！","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443382,"discussion_content":"如果只有这一个方法可以，vector有可能在别的地方使用，锁v就会更好一些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552653362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76442,"user_name":"果然如此","can_delete":false,"product_type":"c1","uid":1210003,"ip_address":"","ucode":"C7543BD0A67505","user_header":"https://static001.geekbang.org/account/avatar/00/12/76/93/c78a132a.jpg","comment_is_top":false,"comment_ctime":1552612774,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14437514662","product_id":100023901,"comment_content":"问题是非线程安全的。<br>线程锁从两个方面考虑，一是颗粒度，二是被锁的对象。<br> 假设把锁加在addIfNotExist方法上虽然颗粒度达到了，但是多线程被锁的对象可能不是同一个，所以还要调整锁定的对象。","like_count":3},{"had_liked":false,"id":76038,"user_name":"奔跑的蜗牛","can_delete":false,"product_type":"c1","uid":1450471,"ip_address":"","ucode":"8CA7452569B349","user_header":"https://static001.geekbang.org/account/avatar/00/16/21/e7/70c4c399.jpg","comment_is_top":false,"comment_ctime":1552525497,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10142460089","product_id":100023901,"comment_content":"contains()和add()存在原子性问题，两个线程，其中线程一先于线程二判断后于线程二插入，线程二后于线程一判断先于线程一插入。就会造成数据重复！","like_count":2},{"had_liked":false,"id":75957,"user_name":"捞鱼的搬砖奇","can_delete":false,"product_type":"c1","uid":1021539,"ip_address":"","ucode":"2FD194C4DA26E5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/96/63/7eb32c9b.jpg","comment_is_top":false,"comment_ctime":1552497658,"is_pvip":false,"replies":[{"id":"27775","content":"👍<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552561311,"ip_address":"","comment_id":75957,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10142432250","product_id":100023901,"comment_content":"另外想到SpringFrameWork中各种模板类都是线程安全的，模板类访问数据不同的持久化技术要绑定不同的会话资源，这些资源本身不是线程安全的。多线程环境下使用synchronized会降低并发,正是使用了ThreadLocal决绝了不用线程同步情况下解决了线程安全的问题。","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443104,"discussion_content":"👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552561311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75953,"user_name":"姜戈","can_delete":false,"product_type":"c1","uid":1058972,"ip_address":"","ucode":"45C4BE93C8E4CC","user_header":"https://static001.geekbang.org/account/avatar/00/10/28/9c/73e76b19.jpg","comment_is_top":false,"comment_ctime":1552496937,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10142431529","product_id":100023901,"comment_content":"Vector的contains操作与add操作缺乏原子性，存在判定不包含此对象时，同时重复加入同一对象的可能！","like_count":2},{"had_liked":false,"id":282846,"user_name":"张申傲","can_delete":false,"product_type":"c1","uid":1182372,"ip_address":"","ucode":"22D46BC529BA8A","user_header":"https://static001.geekbang.org/account/avatar/00/12/0a/a4/828a431f.jpg","comment_is_top":false,"comment_ctime":1615437439,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"5910404735","product_id":100023901,"comment_content":"活锁：用东北话解释，就是“向住了”","like_count":1},{"had_liked":false,"id":229960,"user_name":"颇忒妥","can_delete":false,"product_type":"c1","uid":1026448,"ip_address":"","ucode":"AA86AD1049BC2E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a9/90/0c5ed3d9.jpg","comment_is_top":false,"comment_ctime":1593227242,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5888194538","product_id":100023901,"comment_content":"课后问题用的用法就是经典的check-then-act 用法，也是经典的线程不安全","like_count":1},{"had_liked":false,"id":209277,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1587528046,"is_pvip":false,"replies":[{"id":"78696","content":"我觉得对","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1588033285,"ip_address":"","comment_id":209277,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5882495342","product_id":100023901,"comment_content":"刚才又看了下Vector的源码，所有方法都被sy修饰，对于这行代码if(!v.contains(o)) {<br>多个线程进来对于contains是互斥的，串行的，但是这个方法的临界区也仅仅是contains内了，因此多个线程串行执行完都不没包含o元素，同时都到了v.add(o);方法，而add临界区也是仅仅在add内部的，再串行的两次添加，就会有数据问题了。<br><br>解决思路：把contains和add两个方法放入一个临界区即可<br><br>老师，不知道这样理解对不对","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492755,"discussion_content":"我觉得对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588033285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134392,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1568817656,"is_pvip":true,"replies":[{"id":"51526","content":"👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1568848791,"ip_address":"","comment_id":134392,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5863784952","product_id":100023901,"comment_content":"看了下Vector的代码，其中的contains和add都有synchronized修饰，也就是单独执行两个语句是线程安全的，但是组合两种之间，并没有对共同操作的数据做锁处理，所以可能会出现其他线程对资源做了处理，会发生各种意想不到的问题，也就是说这段代码不是线程安全的","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467727,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568848791,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121322,"user_name":"绅士","can_delete":false,"product_type":"c1","uid":1583859,"ip_address":"","ucode":"5B58E5A958F489","user_header":"https://static001.geekbang.org/account/avatar/00/18/2a/f3/b9607a15.jpg","comment_is_top":false,"comment_ctime":1565099894,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5860067190","product_id":100023901,"comment_content":"不知道现在评论老师能不能注意到：关于add10()的理解是这样的，第一个线程拿到了count等于1，还没执行set操作的时候，第二个线程拿到了count等于1，这两个线程都将count等于写入到各自的寄存器里面，这时候发生了任务切换，因为不是原子的，所以会导致最后写到内存的count等于1而不是想要的2","like_count":1},{"had_liked":false,"id":112198,"user_name":"西  流","can_delete":false,"product_type":"c1","uid":1388546,"ip_address":"","ucode":"0E9BB51AEC2515","user_header":"https://static001.geekbang.org/account/avatar/00/15/30/02/fd0d4849.jpg","comment_is_top":false,"comment_ctime":1562682554,"is_pvip":false,"replies":[{"id":"40814","content":"盛赞了😄","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1562712234,"ip_address":"","comment_id":112198,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5857649850","product_id":100023901,"comment_content":"言简意赅，字字珠玑🌝","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457616,"discussion_content":"盛赞了😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562712234,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":102121,"user_name":"Linus","can_delete":false,"product_type":"c1","uid":1442019,"ip_address":"","ucode":"70344590ACCA15","user_header":"https://static001.geekbang.org/account/avatar/00/16/00/e3/586bbf98.jpg","comment_is_top":false,"comment_ctime":1560141477,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5855108773","product_id":100023901,"comment_content":"<br><br>void addIfNotExist(Vector v, <br>    Object o){<br>  if(!v.contains(o)) {<br>    v.add(o);<br>  }<br>}<br><br>当!v.contains(o)执行完以后释放锁，进入了if里面，但是还没有执行到add方法，假如此时让出了CPU,同时另外一个线程也执行!v.contains(o) ,这个时候也会进入if,   就会造成一个数据增加了两遍，出现竞态条件","like_count":1},{"had_liked":false,"id":78335,"user_name":"aguan(^･ｪ･^)","can_delete":false,"product_type":"c1","uid":1107177,"ip_address":"","ucode":"04833EF2D18E1A","user_header":"https://static001.geekbang.org/account/avatar/00/10/e4/e9/0dd3829f.jpg","comment_is_top":false,"comment_ctime":1553131494,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5848098790","product_id":100023901,"comment_content":"不是线程安全的，因为cotain方法和add方法不是连续执行的，当线程1执行完contain方法后，释放锁🔒，然后线程2执行contain方法，接着执行add方法，最后线程1才执行add方法，线程2的执行结果就会被覆盖了","like_count":1},{"had_liked":false,"id":77321,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1552906294,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5847873590","product_id":100023901,"comment_content":"有安全问题，因为可能都能进4行，然后都add进去了，本来添加一个然后添加了两个","like_count":1},{"had_liked":false,"id":77007,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1552802411,"is_pvip":true,"replies":[{"id":"28086","content":"执行count=1，压根就没有读操作，哪里来的可见性问题？","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552806170,"ip_address":"","comment_id":77007,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847769707","product_id":100023901,"comment_content":"老师这里说被串行化还是1，是不是可见性问题？先执行的线程的count最新值并没有对后一个执行的可见啊","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443538,"discussion_content":"执行count=1，压根就没有读操作，哪里来的可见性问题？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552806170,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76407,"user_name":"不靠谱的琴谱","can_delete":false,"product_type":"c1","uid":1243964,"ip_address":"","ucode":"D388EDFD6E5F8C","user_header":"https://static001.geekbang.org/account/avatar/00/12/fb/3c/e92d40f6.jpg","comment_is_top":false,"comment_ctime":1552603235,"is_pvip":false,"replies":[{"id":"27881","content":"我觉得锁v会更好<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552622884,"ip_address":"","comment_id":76407,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5847570531","product_id":100023901,"comment_content":"void addIfNotExist(Vector v, <br>    Object o){<br>sync（o）{<br>  if(!v.contains(o)) {<br>    v.add(o);<br>  }<br>}<br>}<br>思考题会有一个文中提到的竞态问题，虽然vector是线程安全的集合。然后这里如果保证添加同一个对象的原子性可不可以像我上面这样使用添加的对象当锁，降低锁的粒度<br>","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443293,"discussion_content":"我觉得锁v会更好\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552622884,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1232334,"avatar":"","nickname":"13761642169","note":"","ucode":"68137695FC2120","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24806,"discussion_content":"同意，这里锁住O,不能保证 V 的不变性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570267607,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76272,"user_name":"空知","can_delete":false,"product_type":"c1","uid":1013283,"ip_address":"","ucode":"C448E98238DD36","user_header":"https://static001.geekbang.org/account/avatar/00/0f/76/23/31e5e984.jpg","comment_is_top":false,"comment_ctime":1552562902,"is_pvip":false,"replies":[{"id":"27812","content":"也有这个可能<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552570096,"ip_address":"","comment_id":76272,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847530198","product_id":100023901,"comment_content":"<br>老师， 转账这个例子如果不加措施，因为可见性，两个线程彼此看不见对方，初始值都&gt;150 然后都减150变成50，或者因为任务切换 切换到另一个线程减了150也是50<br>会存在一个线程减到50，另一个线程从50开始减嘛？也就是一个减操作结束后刷到内存，另一个做减法的时候又从内存读值","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443236,"discussion_content":"也有这个可能\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552570096,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76064,"user_name":"我是卖报小行家","can_delete":false,"product_type":"c1","uid":1303013,"ip_address":"","ucode":"43530EA291B66D","user_header":"https://static001.geekbang.org/account/avatar/00/13/e1/e5/815d4271.jpg","comment_is_top":false,"comment_ctime":1552527264,"is_pvip":false,"replies":[{"id":"27779","content":"不会介绍，推荐你看看并发编程的艺术，那里面讲了很多这个<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552564691,"ip_address":"","comment_id":76064,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847494560","product_id":100023901,"comment_content":"不知道老师后序会不会介绍synchronized，lock，AQS一些底层原理，面试经常问道","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443159,"discussion_content":"不会介绍，推荐你看看并发编程的艺术，那里面讲了很多这个\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552564691,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76060,"user_name":"Nevermore","can_delete":false,"product_type":"c1","uid":1228011,"ip_address":"","ucode":"06EBD2E6A9B436","user_header":"https://static001.geekbang.org/account/avatar/00/12/bc/eb/c22ef3a5.jpg","comment_is_top":false,"comment_ctime":1552526951,"is_pvip":false,"replies":[{"id":"27829","content":"高速上车多了，为啥车就慢了呢<br>单线程执行，不能并行处理的时间 &#47; 总时间 = 串行百分比","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552573918,"ip_address":"","comment_id":76060,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847494247","product_id":100023901,"comment_content":"1.为什么并发量增加延迟就会增加？<br>2.串行的百分比是怎么算出来？<br><br><br>","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443156,"discussion_content":"高速上车多了，为啥车就慢了呢\n单线程执行，不能并行处理的时间 / 总时间 = 串行百分比","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552573918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":357953,"user_name":"在路上","can_delete":false,"product_type":"c1","uid":1476245,"ip_address":"重庆","ucode":"2668A965FA79F2","user_header":"https://static001.geekbang.org/account/avatar/00/16/86/95/b9d960d9.jpg","comment_is_top":false,"comment_ctime":1663771390,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663771390","product_id":100023901,"comment_content":"不是线程安全的，容器是线程安全的，它里面的方法都是互斥的，假设多个线程传入的都是同一个vector，在进入contains方法时，只会有一个线程进入，但是判断不是线程安全的，会存在多个线程先后持有同一个对象进行contains判断，但是此时没有一个线程执行add方法，就会导致多个相同的数据重复往容器中添加","like_count":0},{"had_liked":false,"id":348089,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1654735416,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654735416","product_id":100023901,"comment_content":"思考题中：首先题目描述中没有指明 多个线程调用addIfNotExist传入的Vector对象是否是同一个。<br>如果是不同的对象，则每个线程调用时，不存在竞态条件，因为Vector内部方法的synchronized是加在<br>普通方法，而不是static方法，所以锁的是this对象，各个线程互不干涉。<br>如果传入的Vector对象是同一个，虽然Vector的add方法和contains方法，都有加synchronized关键字<br>但是这里是分两个操作步骤，add依赖contains，如果两个线程先后走完contains判断方法（但还都未添加），此时都发现满足，最后又先后执行add操作（因为又锁，所以又先后顺序）结果就是集合出现两个对象。不符合我们预期。<br>这里的关键在于：我们将两个原子操作组合，存在依赖，其整体效果则有原子性问题。","like_count":0},{"had_liked":false,"id":345745,"user_name":"学习学个屁","can_delete":false,"product_type":"c1","uid":1049017,"ip_address":"","ucode":"DF2D61E6FB2FCE","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","comment_is_top":false,"comment_ctime":1652542675,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652542675","product_id":100023901,"comment_content":"根据源码，add方法有sync锁 contains没有，这儿会有问题，可能会存在重复的添加。","like_count":0},{"had_liked":false,"id":324294,"user_name":"凯文小猪","can_delete":false,"product_type":"c1","uid":1980201,"ip_address":"","ucode":"36D8AD0229547F","user_header":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","comment_is_top":false,"comment_ctime":1638362502,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638362502","product_id":100023901,"comment_content":"如果锁粗化 那么是线程安全的 。反之两个原子操作组合不具备线程安全。","like_count":0},{"had_liked":false,"id":323195,"user_name":"郭新鹏","can_delete":false,"product_type":"c1","uid":1154281,"ip_address":"","ucode":"F9D76691B335FC","user_header":"https://static001.geekbang.org/account/avatar/00/11/9c/e9/5ba8b1a3.jpg","comment_is_top":false,"comment_ctime":1637758877,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637758877","product_id":100023901,"comment_content":"安全性：加锁<br>活跃性：死锁（锁整体，获取不到锁则释放锁资源，按照顺序加锁）、饥饿（公平锁）、活锁（随机等待）<br>性能：QPS+耗时","like_count":0},{"had_liked":false,"id":323194,"user_name":"郭新鹏","can_delete":false,"product_type":"c1","uid":1154281,"ip_address":"","ucode":"F9D76691B335FC","user_header":"https://static001.geekbang.org/account/avatar/00/11/9c/e9/5ba8b1a3.jpg","comment_is_top":false,"comment_ctime":1637758408,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637758408","product_id":100023901,"comment_content":"不安全的<br><br>f(!v.contains(o)) { v.contains 不是串行的，所以线程A和线程B都会判断成功<br>v.add(o);  这里线程A和线程B都会一次","like_count":0},{"had_liked":false,"id":320966,"user_name":"Geek_178867","can_delete":false,"product_type":"c1","uid":1570138,"ip_address":"","ucode":"1201C559DF6DA9","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/j5clGGhnC727qj0UDKFBmUMtXljvQvkuUmqia1xJGsiaCJOZqbQ7Agv0bicq2hATmRaOfAnltjEgXsy8QMWVrcjeg/132","comment_is_top":false,"comment_ctime":1636599769,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636599769","product_id":100023901,"comment_content":"if(!v.contains(o)){<br>  synchronized(class){<br>    if(!v.contains(o)){<br>      v.add(o);<br>    }<br>  }<br>}<br>","like_count":0},{"had_liked":false,"id":309901,"user_name":"小宏","can_delete":false,"product_type":"c1","uid":1343456,"ip_address":"","ucode":"08B34C89368649","user_header":"https://static001.geekbang.org/account/avatar/00/14/7f/e0/b77e176e.jpg","comment_is_top":false,"comment_ctime":1630388693,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630388693","product_id":100023901,"comment_content":"整个不是原子操作，无法保证线程安全","like_count":0},{"had_liked":false,"id":307423,"user_name":"听风有信","can_delete":false,"product_type":"c1","uid":2683430,"ip_address":"","ucode":"2CCB467114FF5C","user_header":"https://static001.geekbang.org/account/avatar/00/28/f2/26/a8ac6b42.jpg","comment_is_top":false,"comment_ctime":1629096996,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1629096996","product_id":100023901,"comment_content":"方法组合是线程不安全的，因为不是一直持有锁，有中断","like_count":0},{"had_liked":false,"id":306719,"user_name":"Lowic","can_delete":false,"product_type":"c1","uid":2172704,"ip_address":"","ucode":"8D9E3D7C503FC0","user_header":"https://static001.geekbang.org/account/avatar/00/21/27/20/8147351d.jpg","comment_is_top":false,"comment_ctime":1628680266,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628680266","product_id":100023901,"comment_content":"老师，死锁和线程饥饿有什么区别呢？好像都是获取不到资源？","like_count":0},{"had_liked":false,"id":304826,"user_name":"六维","can_delete":false,"product_type":"c1","uid":1022887,"ip_address":"","ucode":"EB1C15AC06A8DF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/a7/440aff07.jpg","comment_is_top":false,"comment_ctime":1627632622,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627632622","product_id":100023901,"comment_content":"存在并发问题，因为因为对v的操作不是原子的","like_count":0},{"had_liked":false,"id":301555,"user_name":"南天","can_delete":false,"product_type":"c1","uid":1796693,"ip_address":"","ucode":"DA26E76BC95F1B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ4QCWqGgMN4kp615f0Dlb8Ty61iaeOfMia7dyOic5mcgiarxGv8pyra1dibiajXicDLibxqsyM6uNabia4ckw/132","comment_is_top":false,"comment_ctime":1625737511,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625737511","product_id":100023901,"comment_content":"竞态条件，是不是可以换另一种理解，就是整体流程需不需要确保原子性来衡量？","like_count":0},{"had_liked":false,"id":301405,"user_name":"小乙哥","can_delete":false,"product_type":"c1","uid":1063308,"ip_address":"","ucode":"C77E79BEA0C325","user_header":"https://static001.geekbang.org/account/avatar/00/10/39/8c/089525aa.jpg","comment_is_top":false,"comment_ctime":1625664435,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625664435","product_id":100023901,"comment_content":"https:&#47;&#47;stackoverflow.com&#47;questions&#47;1036364&#47;good-example-of-livelock&#47;8863671?r=SearchResults#<br>找一个活锁的例子，并且解决活锁的问题<br><br>double random = Math.random();<br>if (spouse.isHungry() &amp;&amp; random &gt; 0.5) {<br>    System.out.printf(<br>            &quot;%s: You eat first my darling %s!%n&quot;,<br>            name, spouse.getName());<br>    spoon.setOwner(spouse);<br>    continue;<br>}","like_count":0},{"had_liked":false,"id":287418,"user_name":"RoccoLee","can_delete":false,"product_type":"c1","uid":2508667,"ip_address":"","ucode":"C55AD67FF8C2D7","user_header":"https://static001.geekbang.org/account/avatar/00/26/47/7b/c5ec018c.jpg","comment_is_top":false,"comment_ctime":1617938249,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1617938249","product_id":100023901,"comment_content":"课后思考：addIfNotExist方法不是同步方法，所以多个线程可能同时执行了if(!v.contains(o))，出现了数据竞争，导致v添加了2次o。这不是线程安全的方法","like_count":0},{"had_liked":false,"id":269623,"user_name":"俯瞰风景.","can_delete":false,"product_type":"c1","uid":1044166,"ip_address":"","ucode":"A6DB68B7B84AEE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/c6/bebcbcf0.jpg","comment_is_top":false,"comment_ctime":1608718614,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608718614","product_id":100023901,"comment_content":"set(get()+1) 这样理解？<br>线程A拿到this互斥锁，得到count = 0;然后释放锁;<br>线程B拿到this互斥锁，得到count = 0;然后释放锁;<br>线程A拿到到this互斥锁，执行set();然后释放锁；<br>线程B拿到到this互斥锁，执行set();然后释放锁；<br>最后的结果是线程AB执行完后，得到count=1的值是错误的。因为线程AB通过get()拿到的count值很可能是没有来得及set()的，本质上是set(get() )  的组合不是原子性操作。","like_count":0},{"had_liked":false,"id":261271,"user_name":"Geek_c75d82","can_delete":false,"product_type":"c1","uid":2286012,"ip_address":"","ucode":"81202A016FC5D2","user_header":"","comment_is_top":false,"comment_ctime":1605254990,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605254990","product_id":100023901,"comment_content":"添加的时候，会竞争锁资源，判断的时候，会存在2个线程同时判断为空，添加的时候，有一个添加成功了，另一个等待第一个添加成功，也添加成功了","like_count":0},{"had_liked":false,"id":259981,"user_name":"xzy","can_delete":false,"product_type":"c1","uid":1002095,"ip_address":"","ucode":"1A44368083A19E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/6f/e36b3908.jpg","comment_is_top":false,"comment_ctime":1604903044,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604903044","product_id":100023901,"comment_content":"## 什么是线程安全？<br><br>“当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的”   <br>                                   --Brian Goetz<br><br>Brian Goetz描述的线程安全，在现实情况下是很难实现的，一般情况下在其他限制条件不变的情况下，对“这个对象的单次调用”可以获得正确的结果，那么就认为他是线程安全的。对“这个对象的单次调用”的线程安全，我们叫做“相对线程安全”，java并发集合中的类，大部分都是“相对线程安全的”，例如Vector、HashTable、Collections的synchronizedCollection()方法包装的集合等。","like_count":0},{"had_liked":false,"id":255953,"user_name":"bidinggong","can_delete":false,"product_type":"c1","uid":1898806,"ip_address":"","ucode":"789A1FBA8408F3","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f9/36/f44b633e.jpg","comment_is_top":false,"comment_ctime":1603465457,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1603465457","product_id":100023901,"comment_content":"并发编程中我们需要注意的问题有很多，但主要有三个方面，分别是：安全性问题、活跃性问题和性能问题。","like_count":0},{"had_liked":false,"id":254445,"user_name":"嗨喽","can_delete":false,"product_type":"c1","uid":1162527,"ip_address":"","ucode":"E13573559A50D4","user_header":"https://static001.geekbang.org/account/avatar/00/11/bd/1f/e9fbc712.jpg","comment_is_top":false,"comment_ctime":1603116931,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603116931","product_id":100023901,"comment_content":"注意，synchronized可是不保证原子性的","like_count":0},{"had_liked":false,"id":249286,"user_name":"maybe","can_delete":false,"product_type":"c1","uid":1475528,"ip_address":"","ucode":"93D160F617E750","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/c8/5ce842f6.jpg","comment_is_top":false,"comment_ctime":1600569208,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1600569208","product_id":100023901,"comment_content":"vector的方法本事可以保证线程安全，但是组合操作并非原子操作，会有并发问题，可以通过锁定vector进行处理","like_count":0},{"had_liked":false,"id":247514,"user_name":"西门吹牛","can_delete":false,"product_type":"c1","uid":1508990,"ip_address":"","ucode":"E5D3624DDE1E83","user_header":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","comment_is_top":false,"comment_ctime":1599730558,"is_pvip":false,"replies":[{"id":"90998","content":"������������","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1599888757,"ip_address":"","comment_id":247514,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1599730558","product_id":100023901,"comment_content":"Raft 选主算法：<br>Raft 算法巧妙地使用随机选举超时时间的方法，把超时时间都分散开来，在大多数情况下只有一个服务器节点先发起选举，而不是同时发起选举，这样就能减少因选票瓜分导致选举失败的情况。在Raft 算法中：<br>1. 跟随者等待领导者心跳信息超时的时间间隔，是随机的；<br>2. 如果候选人在一个随机时间间隔内，没有赢得过半票数，选举无效，然后候选人发起新一轮的选举，也就是说，等待选举超时的时间间隔，是随机的。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505423,"discussion_content":"������������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599888757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":242774,"user_name":"fightingD","can_delete":false,"product_type":"c1","uid":1443637,"ip_address":"","ucode":"AD2876CED5D5AC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKwViav94kcF50CxA0Jw7icicxociaVzut97iacy3b2ciacFqXuFWdiakVq304YcI8pt4HT5A1Yvp8EkYCpw/132","comment_is_top":false,"comment_ctime":1597837690,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597837690","product_id":100023901,"comment_content":"Vector 容器是安全的，但是这个操作if(!v.contains(o)){} 是线程不安全的，存在竞态条件。","like_count":0},{"had_liked":false,"id":241949,"user_name":"何领","can_delete":false,"product_type":"c1","uid":1240298,"ip_address":"","ucode":"F0F2B11CF5C9FA","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/ea/c33e5a3d.jpg","comment_is_top":false,"comment_ctime":1597514740,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597514740","product_id":100023901,"comment_content":"刚看完《深入理解Java虚拟机》的并发篇，这个可以用先行发生原则来分析（就是老师说的happens-before），不过书里的规则多几条。","like_count":0},{"had_liked":false,"id":232406,"user_name":"小李讲源码","can_delete":false,"product_type":"c1","uid":1107484,"ip_address":"","ucode":"2573037D7C82C8","user_header":"https://static001.geekbang.org/account/avatar/00/10/e6/1c/9d3744ee.jpg","comment_is_top":false,"comment_ctime":1593996491,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1593996491","product_id":100023901,"comment_content":"不是遇到并发的时候就一定要synchronized，要考虑到安全性，活跃性和性能这三个方面。因为有各种各样不同的问题和场景，所以对于并发有各种工具。<br><br>大致分为无锁方式和加锁方式。","like_count":0},{"had_liked":false,"id":227577,"user_name":"李志伟","can_delete":false,"product_type":"c1","uid":1181443,"ip_address":"","ucode":"925A6CA13EF7F9","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/03/0c824ab2.jpg","comment_is_top":false,"comment_ctime":1592435846,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592435846","product_id":100023901,"comment_content":"问题中的v是局部变量，只有在传进来的v是同一个vector时才会有线程安全问题吧<br>","like_count":0},{"had_liked":false,"id":224870,"user_name":"行道有德","can_delete":false,"product_type":"c1","uid":1495977,"ip_address":"","ucode":"92B2A5A6E8E7C3","user_header":"https://static001.geekbang.org/account/avatar/00/16/d3/a9/36e59707.jpg","comment_is_top":false,"comment_ctime":1591580575,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591580575","product_id":100023901,"comment_content":"截止到现在，看了7篇文章，每篇都做了笔记，真心感觉老师讲的好，真的很通透！继续，坚持，整个课程值得反复揣摩学习！","like_count":0},{"had_liked":false,"id":223630,"user_name":"olivia-byte","can_delete":false,"product_type":"c1","uid":1273891,"ip_address":"","ucode":"D54B3833995923","user_header":"https://static001.geekbang.org/account/avatar/00/13/70/23/92d188aa.jpg","comment_is_top":false,"comment_ctime":1591146351,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591146351","product_id":100023901,"comment_content":"所谓公平锁，是一种先来后到的方案，线程的等待是有顺序的，排在等待队列前面的线程会优先获得资源。这里说的先来后到不理解，不是先来先处理吗","like_count":0},{"had_liked":false,"id":213383,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1588399917,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588399917","product_id":100023901,"comment_content":"这章就是知识地图啊，讲的真是很好的<br>并发编程需要关注: 安全性，活跃性，性能问题<br>安全性则需要关注可见性，原子性，有序性。涉及happens-before等知识点<br>活跃性又有死锁 活锁  饥饿等知识，对应又能继续扩展<br>性能问题，是锁引入的，解决方案就是不用锁，或者减少锁的持有时间，ThreadLocal,concurrenthashmap,cow等相关优化点，而java并发包提供的多种加锁方式就是针对某方面的优化。<br>这章太棒了。","like_count":0},{"had_liked":false,"id":211411,"user_name":"bin.chen","can_delete":false,"product_type":"c1","uid":1135604,"ip_address":"","ucode":"5BA49358AB8A1A","user_header":"https://static001.geekbang.org/account/avatar/00/11/53/f4/e277325d.jpg","comment_is_top":false,"comment_ctime":1587959218,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587959218","product_id":100023901,"comment_content":"安全性问题，活跃性问题和性能问题应该是我们在设计并发时应该去考量的标准，真正遇到bug的时候再从原子性 可见性 顺序性三个方便去具体分析问题 一内一外，相辅相成","like_count":0},{"had_liked":false,"id":211329,"user_name":"Lee","can_delete":false,"product_type":"c1","uid":1923267,"ip_address":"","ucode":"FFCE9DE42920E2","user_header":"","comment_is_top":false,"comment_ctime":1587949257,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587949257","product_id":100023901,"comment_content":"透过现象看本质，文中竞态条件引发的安全问题，不要被sync或锁迷惑，本质就是两个原子操作组合变成非原子操作，然后由于可见性问题导致错误","like_count":0},{"had_liked":false,"id":209987,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1587646819,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587646819","product_id":100023901,"comment_content":"原子操作是互斥的，但是原子操作组合在一起就不一定是互斥的了。<br>题目是一个竞态条件的问题，下一步的执行依赖于上一步的执行，虽然contains和add都是原子的，但是组合在一起就不是原子的了。就会存在安全性问题了。<br>记录下，原子性，有序性，可见性问题。安全性，活跃性，性能<br>微观和宏观观察程序","like_count":0},{"had_liked":false,"id":209265,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1587526210,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587526210","product_id":100023901,"comment_content":"思考题：<br>虽然vector是线程安全的，但是多个线程下if(!v.contains(o))也是能同时满足这个条件，都包含对象o的，所以，多个线程都会进行add操作，就会有并发问题","like_count":0},{"had_liked":false,"id":203836,"user_name":"女巫在寒江","can_delete":false,"product_type":"c1","uid":1013180,"ip_address":"","ucode":"B3707072224C1C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/bc/664bbdf7.jpg","comment_is_top":false,"comment_ctime":1586271574,"is_pvip":true,"replies":[{"id":"76519","content":"👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1586476085,"ip_address":"","comment_id":203836,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1586271574","product_id":100023901,"comment_content":"不是线程安全的，contain和add是两步，不是原子操作，有可能两个线程读到的都是contain为false，后边都调用了add","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490974,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586476085,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":201647,"user_name":"Geek_882944","can_delete":false,"product_type":"c1","uid":1942520,"ip_address":"","ucode":"A030341A7D8A60","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLIn0pBz30EAVMBibhOCgicS0w9Sic34hSpCm6qDhmuMEFGGOBGhEys68j4icXUR7apclBSLiaSsgHn9gA/132","comment_is_top":false,"comment_ctime":1585816272,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585816272","product_id":100023901,"comment_content":"当并发发生在第三行的判断的竞态条件都符合，就会出现Vector出现重复元素","like_count":0},{"had_liked":false,"id":195491,"user_name":"Albert","can_delete":false,"product_type":"c1","uid":1021859,"ip_address":"","ucode":"ED823BD8D23468","user_header":"https://static001.geekbang.org/account/avatar/00/0f/97/a3/659e9844.jpg","comment_is_top":false,"comment_ctime":1585191290,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585191290","product_id":100023901,"comment_content":"两个线程同时访问第3行代码，假设vector中都是没有变量，然后，两个线程继续往下执行，将会同时执行添加操作。<br><br>同时执行添加操作，导致vector 实际存放的内容更预期的不一致。<br><br>这同样是线程不安全的表现。这是两个线程同时执行相同操作导致的，即是两个线程的执行顺序导致的问题。","like_count":0},{"had_liked":false,"id":191379,"user_name":"zhangchao","can_delete":false,"product_type":"c1","uid":1508339,"ip_address":"","ucode":"E665D153A85DE0","user_header":"https://static001.geekbang.org/account/avatar/00/17/03/f3/0bd094ad.jpg","comment_is_top":false,"comment_ctime":1584768494,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584768494","product_id":100023901,"comment_content":"并发量指的是有多少个客户端同时访问。<br>请问这里的“同时”是什么意思呢？","like_count":0},{"had_liked":false,"id":189665,"user_name":"Mr.wang","can_delete":false,"product_type":"c1","uid":1224805,"ip_address":"","ucode":"86F341A5316BBC","user_header":"https://static001.geekbang.org/account/avatar/00/12/b0/65/90387745.jpg","comment_is_top":false,"comment_ctime":1584539523,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1584539523","product_id":100023901,"comment_content":"王老师上面的那个问题，我觉得是存在并发问题，一个线程在判断是否存在后，还没有来得及插入；这个时候紧接着另外一个线程访问进来，同样判断是否存在，由于前面的线程还没有插入，所以判断为true，进入到插入方法中。这个问题就是前面老师讲到的线程之间竞争问题，从而引发在并发条件下的线程安全问题。","like_count":0},{"had_liked":false,"id":189084,"user_name":"torres","can_delete":false,"product_type":"c1","uid":1108761,"ip_address":"","ucode":"34DABCFC7B74EA","user_header":"https://static001.geekbang.org/account/avatar/00/10/eb/19/76b0b98c.jpg","comment_is_top":false,"comment_ctime":1584454641,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584454641","product_id":100023901,"comment_content":"受益匪浅","like_count":0},{"had_liked":false,"id":187501,"user_name":"Geek_94adb8","can_delete":false,"product_type":"c1","uid":1638187,"ip_address":"","ucode":"B142F473E1A0B3","user_header":"","comment_is_top":false,"comment_ctime":1584148549,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584148549","product_id":100023901,"comment_content":"关于所谓”竞态条件，指的是程序的执行结果依赖线程执行的顺序。例如上面的例子，如果两个线程完全同时执行，那么结果是 1；如果两个线程是前后执行，那么结果就是 2。在并发环境里，线程的执行顺序是不确定的，如果程序存在竞态条件问题，那就意味着程序执行的结果是不确定的，而执行结果不确定这可是个大 Bug。“<br>竞态条件只是线程安全问题的表现，线程安全不就是因为线程执行顺序不是我们所期望的那个顺序执行吗？没必要再把这个当成一个新的问题来解释，“那面对数据竞争和竞态条件问题，又该如何保证线程的安全性呢？其实这两类问题，都可以用互斥这个技术方案，而实现互斥的方案有很多”线程安全问题和竞态条件我觉得是一类问题，所以，不需要当成两类问题，尽信书不如无书，还是得需要自己思考...","like_count":0},{"had_liked":false,"id":184161,"user_name":"Airsaid","can_delete":false,"product_type":"c1","uid":1115302,"ip_address":"","ucode":"5B90BC0044F376","user_header":"https://static001.geekbang.org/account/avatar/00/11/04/a6/18c4f73c.jpg","comment_is_top":false,"comment_ctime":1583240778,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583240778","product_id":100023901,"comment_content":"活锁的发生除了多个协作线程都对彼此进行响应但却让对方都无法继续执行外，还有可能写了过度的恢复代码导致错误后不断重试。","like_count":0},{"had_liked":false,"id":179826,"user_name":"Geek_bb89c3","can_delete":false,"product_type":"c1","uid":1331828,"ip_address":"","ucode":"0F97B5B0F2DDD6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/IZKGetBZDuMEa2VwwtesTELvLORIyV749ItgfAqNPv30n4zEv71wuGNr1aNVIVltG0icvH53DHDuqPuzNpiauWAg/132","comment_is_top":false,"comment_ctime":1582105720,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582105720","product_id":100023901,"comment_content":"安全性是指程序按照期望的状态执行了。很多时候程序的正确性与否和多线程执行顺序有关。<br>活跃性：是指某些线程或者操作能否按时的执行下去。死锁，活锁，饥饿。这三种操作是整个系统中的关键。<br>性能：性能是吞吐量，并发量，延迟。<br>","like_count":0},{"had_liked":false,"id":176703,"user_name":"终结者999号","can_delete":false,"product_type":"c1","uid":1055854,"ip_address":"","ucode":"33ADE61580B6DD","user_header":"https://static001.geekbang.org/account/avatar/00/10/1c/6e/6c5f5734.jpg","comment_is_top":false,"comment_ctime":1581144483,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1581144483","product_id":100023901,"comment_content":"老师好，我仔细看了一下大家的评论和您的文章，课后思考题中是因为不能保证两个线程同时执行contains方法时都通过后程序没有影响，我看后面您回复说对v加锁，那么为什么不能对整个方法加锁呢？这样就能保证只有一个线程执行这个方法了？","like_count":0},{"had_liked":false,"id":175714,"user_name":"慌张而黑糖","can_delete":false,"product_type":"c1","uid":1638878,"ip_address":"","ucode":"B4416885A301C8","user_header":"https://static001.geekbang.org/account/avatar/00/19/01/de/bf524817.jpg","comment_is_top":false,"comment_ctime":1580805579,"is_pvip":false,"replies":[{"id":"68300","content":"你查一下可重入锁相关的知识吧","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1580820953,"ip_address":"","comment_id":175714,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1580805579","product_id":100023901,"comment_content":"老师有个疑问，get()和set()方法不应该是互斥的吗，在set()方法里调用get()方法，感觉会出现死锁呀，刚接触没多久，不知是不是我理解错了，希望老师解答一下，十分感谢🙏","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482866,"discussion_content":"你查一下可重入锁相关的知识吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580820953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1638878,"avatar":"https://static001.geekbang.org/account/avatar/00/19/01/de/bf524817.jpg","nickname":"慌张而黑糖","note":"","ucode":"B4416885A301C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":160574,"discussion_content":"知道了，看到老师其他回答了解了是先执行的get方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580817263,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":171700,"user_name":"慌张而黑糖","can_delete":false,"product_type":"c1","uid":1638878,"ip_address":"","ucode":"B4416885A301C8","user_header":"https://static001.geekbang.org/account/avatar/00/19/01/de/bf524817.jpg","comment_is_top":false,"comment_ctime":1578993182,"is_pvip":false,"replies":[{"id":"66608","content":"正确","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1579013753,"ip_address":"","comment_id":171700,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1578993182","product_id":100023901,"comment_content":"个人理解:两个线程A，B同时调用v.contains(o)，由于vector是线程安全的，所以只有一个线程拿到了锁，假设线程A拿到了锁，判断以后进入if语句，线程A释放锁，另一个线程B拿到了锁，经过判断也进入if语句(这时线程A还没有执行add方法)，这样两个线程都执行了add方法，所以错误，不知理解是否正确。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481474,"discussion_content":"正确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579013753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134495,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4f/9f/08b9eadf.jpg","nickname":"见贤思齐","note":"","ucode":"A5F586D8205745","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":134867,"discussion_content":"contains方法没有加锁，进入contains里面不需要拿到锁吧，所以if内部谁都能进入","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579052985,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1638878,"avatar":"https://static001.geekbang.org/account/avatar/00/19/01/de/bf524817.jpg","nickname":"慌张而黑糖","note":"","ucode":"B4416885A301C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1134495,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4f/9f/08b9eadf.jpg","nickname":"见贤思齐","note":"","ucode":"A5F586D8205745","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":135012,"discussion_content":"对的对的，contains方法没有锁，记错了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579060133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":134867,"ip_address":""},"score":135012,"extra":""}]}]},{"had_liked":false,"id":167562,"user_name":"杨过","can_delete":false,"product_type":"c1","uid":1131470,"ip_address":"","ucode":"B12249055A8417","user_header":"https://static001.geekbang.org/account/avatar/00/11/43/ce/a3734a6c.jpg","comment_is_top":false,"comment_ctime":1577860797,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1577860797","product_id":100023901,"comment_content":"add10k那里有问题吧？get在set里面，一个线程在set完成之前，get完成之后，不会有另一个线程再来set，也就不能再get啊？注意执行add10k是先调用的set","like_count":0,"discussions":[{"author":{"id":1740204,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/8d/ac/8a428bd8.jpg","nickname":"阮少","note":"","ucode":"2F007C96CB60F9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":204376,"discussion_content":"最好的实践就是拿着代码去跑一边就知道是否存在线程安全问题了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584165727,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161527,"user_name":"Eleven","can_delete":false,"product_type":"c1","uid":1168452,"ip_address":"","ucode":"FB4A0C8CA732BE","user_header":"https://static001.geekbang.org/account/avatar/00/11/d4/44/0ec958f4.jpg","comment_is_top":false,"comment_ctime":1576224005,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576224005","product_id":100023901,"comment_content":"根据静态条件规则，如果v.contains(o)同时执行怎不能保证线程安全问题。","like_count":0},{"had_liked":false,"id":160478,"user_name":"玄戈","can_delete":false,"product_type":"c1","uid":1541994,"ip_address":"","ucode":"6A01496D915EEB","user_header":"https://static001.geekbang.org/account/avatar/00/17/87/6a/173e2dd1.jpg","comment_is_top":false,"comment_ctime":1575958891,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575958891","product_id":100023901,"comment_content":"concurrentHashmap已经不是分段锁了吧","like_count":0},{"had_liked":false,"id":159841,"user_name":"dingsai88","can_delete":false,"product_type":"c1","uid":1029484,"ip_address":"","ucode":"A725428A983ADC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b5/6c/617c0193.jpg","comment_is_top":false,"comment_ctime":1575808310,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575808310","product_id":100023901,"comment_content":"单个操作都是线程安全的，但是组合操作不具有原子性，所以非线程安全","like_count":0},{"had_liked":false,"id":152995,"user_name":"梅云霞","can_delete":false,"product_type":"c1","uid":1400992,"ip_address":"","ucode":"01C8F85B59A202","user_header":"https://static001.geekbang.org/account/avatar/00/15/60/a0/dc0bf77c.jpg","comment_is_top":false,"comment_ctime":1574136340,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574136340","product_id":100023901,"comment_content":"<br>public class Test {<br>  private long count = 0;<br>  synchronized long get(){<br>    return count；<br>  }<br>  synchronized void set(long v){<br>    count = v;<br>  } <br>  void add10K() {<br>    int idx = 0;<br>    while(idx++ &lt; 10000) {<br>      set(get()+1)      <br>    }<br>  }<br>}<br>这个会同时执行get()方法吗？get方法上不是加锁了吗","like_count":0},{"had_liked":false,"id":150039,"user_name":"朕爱吾妃","can_delete":false,"product_type":"c1","uid":1733692,"ip_address":"","ucode":"B10EB69934F9E2","user_header":"https://static001.geekbang.org/account/avatar/00/1a/74/3c/da79d2a1.jpg","comment_is_top":false,"comment_ctime":1573451993,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573451993","product_id":100023901,"comment_content":"思考题答：<br>假设线程A和线程B同时进行addIfNotExist方法，线程A执行完v.contains(o)后，并没有执行add方法，然后线程B就执行了v.contains(o)同时条件也满足add操作，就会发生线程安全问题，所以，单步是原子性的，组合起来就不是原子性了","like_count":0},{"had_liked":false,"id":137986,"user_name":"245864982","can_delete":false,"product_type":"c1","uid":1238485,"ip_address":"","ucode":"AC47075A95B759","user_header":"https://static001.geekbang.org/account/avatar/00/12/e5/d5/680402fd.jpg","comment_is_top":false,"comment_ctime":1569953483,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569953483","product_id":100023901,"comment_content":"vector对象里面的方法是线性安全的。但是这个vector  v对象本身是存在资源竞争。会有并发安全问题。需要对这个对象v加锁。","like_count":0},{"had_liked":false,"id":137516,"user_name":"小氘","can_delete":false,"product_type":"c1","uid":1622109,"ip_address":"","ucode":"DA55B9A02D9EE0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erPMtAfnQdpx1yOZQ2ic7icqUs3tvibEjUXQMUXKiaakyuIho6k6vmdl46nrdWjXIjPIRg9Pmco00tR5w/132","comment_is_top":false,"comment_ctime":1569758965,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569758965","product_id":100023901,"comment_content":"课后思考：存在并发问题，第三行代码判断v中有没有包含o就是本文说的竞态条件，即程序的执行依赖于某个状态的变化。假设当线程A判断完满足条件，此时线程B成功执行第四行代码往v中添加o，然后线程A再次添加o成功，我们本来希望集合v中没有重复的对象，可事与愿违。","like_count":0},{"had_liked":false,"id":130456,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1567469682,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567469682","product_id":100023901,"comment_content":"不满足原子性，contains执行完之后，可能会释放锁，这个可能其他线程就可能操作vector。可以利用concurrentHashMap的putIfAbsent解决","like_count":0},{"had_liked":false,"id":130084,"user_name":"Demter","can_delete":false,"product_type":"c1","uid":1158439,"ip_address":"","ucode":"BE3B6F726916CE","user_header":"https://static001.geekbang.org/account/avatar/00/11/ad/27/5556ae50.jpg","comment_is_top":false,"comment_ctime":1567384897,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567384897","product_id":100023901,"comment_content":"如果把set(get()+1)中get()+1的逻辑放在set()方法体里面是不是就不存在并发问题了？","like_count":0},{"had_liked":false,"id":117941,"user_name":"胡家鹏","can_delete":false,"product_type":"c1","uid":1109940,"ip_address":"","ucode":"1636F84062948B","user_header":"https://static001.geekbang.org/account/avatar/00/10/ef/b4/61fb4dba.jpg","comment_is_top":false,"comment_ctime":1564196325,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1564196325","product_id":100023901,"comment_content":"我觉得问题不在get,set，这两个方法加锁了，是线程安全的，不安全是在add10k。类似最后的问题，vector是安全的，不安全的是外面不加锁调用。","like_count":0},{"had_liked":false,"id":113660,"user_name":"赵小洛","can_delete":false,"product_type":"c1","uid":1592232,"ip_address":"","ucode":"A326C12B1A1ABA","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/a8/14b8a860.jpg","comment_is_top":false,"comment_ctime":1563107378,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563107378","product_id":100023901,"comment_content":"会存在 并发问题，Vector 是线程安全的 容器，但是组合使用 并不一定是线程安全的。","like_count":0},{"had_liked":false,"id":108713,"user_name":"普通熊猫 ଘ(੭ˊ꒳​ˋ)੭✧","can_delete":false,"product_type":"c1","uid":1196531,"ip_address":"","ucode":"7FEF9C72B4801B","user_header":"https://static001.geekbang.org/account/avatar/00/12/41/f3/8bca4aba.jpg","comment_is_top":false,"comment_ctime":1561863038,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1561863038","product_id":100023901,"comment_content":"单独的数据读只可用于展示，不可用于回写<br><br>如果想读出数据并修改后回写数据源的话，要求读与写在一个原子操作中完成，我称之为read on write<br><br>因此，vector那个例子肯定存在竞态条件","like_count":0},{"had_liked":false,"id":108309,"user_name":"马哲富","can_delete":false,"product_type":"c1","uid":1107917,"ip_address":"","ucode":"D6BDDFE3CC07ED","user_header":"https://static001.geekbang.org/account/avatar/00/10/e7/cd/08088f14.jpg","comment_is_top":false,"comment_ctime":1561715923,"is_pvip":false,"replies":[{"id":"39257","content":"看11章能不能解决你的问题吧，如果还解决不了，就看操作系统原理相关内容","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1561719747,"ip_address":"","comment_id":108309,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561715923","product_id":100023901,"comment_content":"许老师您好！<br>    我想问一下：既然没有共享变量就没有并发问题，那么问题中的Vector也不是共享变量，理应也没有并发问题才是啊？如果像其他同学说的一样有并发问题，那么是不是参数也是另一种共享变量呢？不知道我的理解哪儿不对？还请指教","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455914,"discussion_content":"看11章能不能解决你的问题吧，如果还解决不了，就看操作系统原理相关内容","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561719747,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108036,"user_name":"z.l","can_delete":false,"product_type":"c1","uid":1181055,"ip_address":"","ucode":"805CC5784D3F76","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/7f/d35ab9a1.jpg","comment_is_top":false,"comment_ctime":1561651397,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561651397","product_id":100023901,"comment_content":"挑个刺，java的CopyOnWriteList在执行add()方法时是加锁的","like_count":0},{"had_liked":false,"id":108035,"user_name":"z.l","can_delete":false,"product_type":"c1","uid":1181055,"ip_address":"","ucode":"805CC5784D3F76","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/7f/d35ab9a1.jpg","comment_is_top":false,"comment_ctime":1561651079,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561651079","product_id":100023901,"comment_content":"这种写法错误，因为产生了静态条件。类似的很多人用ConcurrentHashMap时，经常<br>if(!map.containsKey(&quot;xxx&quot;)) {<br>   map.put(&quot;xxx&quot;,xxx);<br>}<br>这种也是不对的，破坏了线程安全","like_count":0},{"had_liked":false,"id":103169,"user_name":"Adam","can_delete":false,"product_type":"c1","uid":1517838,"ip_address":"","ucode":"965DCD693E752B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK36t2flfxhzKygfLfdIHbK99M9D9w3v3bwAHUibJSFAs1ibswf7hbhkqL321k5SUjfiaWkkHeRBlibNA/132","comment_is_top":false,"comment_ctime":1560389825,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560389825","product_id":100023901,"comment_content":"count用volatile修饰 应该可以保证同时访问被串行化后 前一个线程结果对后一个线程可见吧","like_count":0},{"had_liked":false,"id":98592,"user_name":"“B仔！","can_delete":false,"product_type":"c1","uid":1126560,"ip_address":"","ucode":"208BB8A051C879","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/a0/09ec0f21.jpg","comment_is_top":false,"comment_ctime":1559036081,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559036081","product_id":100023901,"comment_content":"做安卓的，平时很少处理并发的知识，作为拓展知识深入学习，但是老师的文章是最通俗，系统化，而且还是递进式的引导的总结。是目前看到最好的文章。感谢","like_count":0},{"had_liked":false,"id":95432,"user_name":"而立斋","can_delete":false,"product_type":"c1","uid":1087258,"ip_address":"","ucode":"5FED6E9E148195","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/1a/389eab84.jpg","comment_is_top":false,"comment_ctime":1558056008,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558056008","product_id":100023901,"comment_content":"安全性问题：数据竞争，竞态数据，解决方案互斥锁<br>活跃性问题：死锁、活锁、饥饿<br>性能问题：锁的代价（JDK并发包、无锁、细粒度锁）、吞吐量、延迟、并发量","like_count":0},{"had_liked":false,"id":92238,"user_name":"盛权_vinc","can_delete":false,"product_type":"c1","uid":1459845,"ip_address":"","ucode":"4688DD06587CE2","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/LPnuO9GleKEwso2rSbibmbEwn49hnGl9qTQDBv2xLOOWOflQsc9oVEEuZgNBt7TrqRKvk8CX7Tc8iakhEicBCCfFg/132","comment_is_top":false,"comment_ctime":1557209830,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557209830","product_id":100023901,"comment_content":"老师，那3给度量标准的描述，吞吐量和并发量怎么感觉说的一个意思，没明白，能再解析一下吗。","like_count":0},{"had_liked":false,"id":92082,"user_name":"码农Kevin亮","can_delete":false,"product_type":"c1","uid":1116630,"ip_address":"","ucode":"D34562461CA0A1","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/d6/5f366427.jpg","comment_is_top":false,"comment_ctime":1557187066,"is_pvip":false,"replies":[{"id":"34438","content":"我觉得应该没有这么智能的工具，主要靠设计阶段把并发问题限定住，这样就能集中精力搞测试了","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558358877,"ip_address":"","comment_id":92082,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1557187066","product_id":100023901,"comment_content":"请教老师，对于程序的安全性问题，一般是怎么验证会比较好？也就是说，除了用肉眼分析代码外，有没有一些工具可以更直观地测试出来？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449139,"discussion_content":"我觉得应该没有这么智能的工具，主要靠设计阶段把并发问题限定住，这样就能集中精力搞测试了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558358877,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1179312,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fe/b0/260f41f0.jpg","nickname":"loris","note":"","ucode":"00842745CF4B31","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":123303,"discussion_content":"有个Java官方的并发测试工具叫 jcstress 楼主可以看看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578399576,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91296,"user_name":"松花皮蛋me","can_delete":false,"product_type":"c1","uid":1000054,"ip_address":"","ucode":"B0846CEEF6B0D1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/76/256bbd43.jpg","comment_is_top":false,"comment_ctime":1556967401,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556967401","product_id":100023901,"comment_content":"二刷中。组合后可能会出现条件曾经满足的情况","like_count":0},{"had_liked":false,"id":90377,"user_name":"劉小强","can_delete":false,"product_type":"c1","uid":1178474,"ip_address":"","ucode":"07FC2F0CDED869","user_header":"https://static001.geekbang.org/account/avatar/00/11/fb/6a/be4956a3.jpg","comment_is_top":false,"comment_ctime":1556503241,"is_pvip":false,"replies":[{"id":"32400","content":"可以，你可以看看锁重入相关的知识","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556519352,"ip_address":"","comment_id":90377,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556503241","product_id":100023901,"comment_content":"一个线程调用set的时候还要调用get方法，set锁没有释放 可以调用到get方法么？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448498,"discussion_content":"可以，你可以看看锁重入相关的知识","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556519352,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89830,"user_name":"xiaoming","can_delete":false,"product_type":"c1","uid":1444765,"ip_address":"","ucode":"242B4C52B2B865","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/e6TFib156x0VEiaWPkwpgAqgqJ8P07WpHPicRTWqnBIAW6br6yoXDA6kCdAlWBBjlqFtlyyhM4rPzUhlF8IdMPhZQ/132","comment_is_top":false,"comment_ctime":1556276281,"is_pvip":false,"replies":[{"id":"32362","content":"是这样的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556499880,"ip_address":"","comment_id":89830,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556276281","product_id":100023901,"comment_content":"void add10K() {<br>    int idx = 0;<br>    while(idx++ &lt; 10000) {<br>      set(get()+1)      <br>    }<br>  }  线程A,B 同时调用add10K, A线程先获取锁执行get()操作, 执行完成之后可能线程B获取了锁去执行get()，2个线程get 的值都是0, 锁是同一把锁,但是操作不是具备原子性,  老师 ,这样理解对吗？<br><br>","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448278,"discussion_content":"是这样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556499880,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89435,"user_name":"rm -rf&#47;*","can_delete":false,"product_type":"c1","uid":1388034,"ip_address":"","ucode":"D5A997682B6F7E","user_header":"https://static001.geekbang.org/account/avatar/00/15/2e/02/07ae4c9e.jpg","comment_is_top":false,"comment_ctime":1556173878,"is_pvip":false,"replies":[{"id":"32013","content":"没有了<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556193968,"ip_address":"","comment_id":89435,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556173878","product_id":100023901,"comment_content":"老师，ConcurrentHashMap在1.8后不是没有分段锁了么，<br>","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448131,"discussion_content":"没有了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556193968,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89074,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1556071885,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1556071885","product_id":100023901,"comment_content":"让路的例子形象生动。","like_count":0},{"had_liked":false,"id":88161,"user_name":"xuery","can_delete":false,"product_type":"c1","uid":1027584,"ip_address":"","ucode":"F461B61BE06131","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/00/025f37e7.jpg","comment_is_top":false,"comment_ctime":1555861416,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1555861416","product_id":100023901,"comment_content":"存在并发问题。两个线程A，B同时执行addIfNotExist方法，当同时执行到if的v.contains方法时，只有一个线程会获得v锁，假设为A线程，A获得锁之后if发现不包含o，则开始执行if里面的add方法，但是在执行之前也要获取锁v, 这时候锁v被线程B执行if里面的contains方法获取到了，发现也不包含o，则也执行add，这样会导致同一个对象o被两次放入了Vector。<br>解决方法：在addIfNotExist函数之前加上synchronized关键字","like_count":0},{"had_liked":false,"id":84079,"user_name":"Mr.Wood","can_delete":false,"product_type":"c1","uid":1482206,"ip_address":"","ucode":"348E13CFCEDC3D","user_header":"https://static001.geekbang.org/account/avatar/00/16/9d/de/1b946a63.jpg","comment_is_top":false,"comment_ctime":1554778956,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554778956","product_id":100023901,"comment_content":"if(!v.contains(o)) { <br>    v.add(o)<br>}<br>线程安全只是单纯的contain()，或者add()方法是原子操作，这里两个操作分开进行而没有枷锁，显然不满足原子性","like_count":0},{"had_liked":false,"id":84005,"user_name":"刘鹏","can_delete":false,"product_type":"c1","uid":1230417,"ip_address":"","ucode":"44F3D4DB3F5678","user_header":"https://static001.geekbang.org/account/avatar/00/12/c6/51/e39b5828.jpg","comment_is_top":false,"comment_ctime":1554768854,"is_pvip":false,"replies":[{"id":"30305","content":"不是，是同一个对象存在竞态条件<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554770170,"ip_address":"","comment_id":84005,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554768854","product_id":100023901,"comment_content":"老师第一个例子，结果为1的原因是不是 synchronized修饰的是普通的get&#47;set方法，不同对象可以存在竞态条件","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446214,"discussion_content":"不是，是同一个对象存在竞态条件\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554770170,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82166,"user_name":"Chuan","can_delete":false,"product_type":"c1","uid":1438352,"ip_address":"","ucode":"FACEC5DAC36A7A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI4akcIyIOXB2OqibTe7FF90hwsBicxkjdicUNTMorGeIictdr3OoMxhc20yznmZWwAvQVThKPFWgOyMw/132","comment_is_top":false,"comment_ctime":1554132982,"is_pvip":false,"replies":[{"id":"29803","content":"set不需要读，所以t2的set会覆盖t1的set","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554177421,"ip_address":"","comment_id":82166,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554132982","product_id":100023901,"comment_content":"老师，请教下add10k()处，为什么count加上volatile依然不安全。<br><br>我的理解这个地方应该是CPU缓存导致的问题。如果两个线程同时执行get和set，那么串行化后的顺序可能就是“T1.get-&gt;T2.get-&gt;T1.set-&gt;T2.set”，如果增加了volatile，那么无论时T1或者T2做了set操作，新值都会刷到内存，此外另一个线程的CPU缓存会失效，需要从新读取内存值进行操作。<br>所以这样看来，加了volatile应该是可以解决安全问题的吧？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445495,"discussion_content":"set不需要读，所以t2的set会覆盖t1的set","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554177421,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":80950,"user_name":"张天屹","can_delete":false,"product_type":"c1","uid":1477612,"ip_address":"","ucode":"8BD6BD6DCF0F4F","user_header":"https://static001.geekbang.org/account/avatar/00/16/8b/ec/dc03f5ad.jpg","comment_is_top":false,"comment_ctime":1553762791,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553762791","product_id":100023901,"comment_content":"其实所谓的线程安全隐含的条件是当前粒度。<br>比如vector的读写方法在方法粒度都是安全的，是原子操作，不会在方法中发生线程切换。但是组合起来是用的时候可能在中间发生线程切换，造成不一致。<br>再比如上面的add10K,也是一样的，这个方法不是临界区，可能在get,set之间发生线程切换造成不一致。<br>最后前面提到的count++也是一个道理，cpu指令是线程安全的，但是对于自增语句粒度并不是。","like_count":0},{"had_liked":false,"id":79674,"user_name":"苍茫大地","can_delete":false,"product_type":"c1","uid":1010515,"ip_address":"","ucode":"7EA9DF22931ABB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/53/a102d6a5.jpg","comment_is_top":false,"comment_ctime":1553519141,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553519141","product_id":100023901,"comment_content":"Concurrenthashmap1.8后的实现是不是比分段锁好，具体怎么来看待呢，优缺点是什么，使用场景又有什么说法呢","like_count":0},{"had_liked":false,"id":79516,"user_name":"红衣闪闪亮晶晶","can_delete":false,"product_type":"c1","uid":1442879,"ip_address":"","ucode":"34DE6E9D94CA18","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIZTw0bzR4licHwZW59AoJNzwN0oANiaYUWdTfmib9nfhMw6ubxEMDibwAeOWXkiad4FoALb5TOGTstYVw/132","comment_is_top":false,"comment_ctime":1553503975,"is_pvip":false,"replies":[{"id":"28999","content":"没看明白你的方案是什么😂<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553515683,"ip_address":"","comment_id":79516,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553503975","product_id":100023901,"comment_content":"不知道我现在留言还会不会被回答。。<br>add10k的例子中如果我直接锁掉里面的变量dx是不是就可以保证它的安全了？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444525,"discussion_content":"没看明白你的方案是什么😂\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553515683,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79480,"user_name":"0928","can_delete":false,"product_type":"c1","uid":1240990,"ip_address":"","ucode":"03221745CF8141","user_header":"https://static001.geekbang.org/account/avatar/00/12/ef/9e/78420b67.jpg","comment_is_top":false,"comment_ctime":1553494645,"is_pvip":false,"replies":[{"id":"29000","content":"没明白不固定什么意思，貌似可以每十个文件分配一个线程<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553516074,"ip_address":"","comment_id":79480,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553494645","product_id":100023901,"comment_content":"老师咨询个问题，场景大概是从无服务请求数据，然后一条数据一行分别写到1000个文件中，数据量大概有2000万左右，通过数据算出文件的索引值，然后把这条数据按照索引写到对应的数据中，为了提高效率这里我使用了多线程来处理，但是有一个隐患是在多线程的情况下，请求先来的数据具体需要写入那个文件是不固定的，如果请求下来的数据是需要写入同一个文件的那么怎么设计锁呢？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444511,"discussion_content":"没明白不固定什么意思，貌似可以每十个文件分配一个线程\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553516074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79190,"user_name":"linqw","can_delete":false,"product_type":"c1","uid":1134138,"ip_address":"","ucode":"09DCFE98C54DD8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","comment_is_top":false,"comment_ctime":1553397900,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553397900","product_id":100023901,"comment_content":"课后思考题：vector中的contains没有加锁，会导致两个线程同时执行通过条件判断，这也是竞态条件问题，条件判断依赖执行结果<br>","like_count":0},{"had_liked":false,"id":78658,"user_name":"之外^Excepts","can_delete":false,"product_type":"c1","uid":1035331,"ip_address":"","ucode":"FD2284F65DB22F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cc/43/59a9b4ae.jpg","comment_is_top":false,"comment_ctime":1553213051,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553213051","product_id":100023901,"comment_content":"优秀，老讲地得要多听好几遍细细品味才能悟地更深刻。vector的问题是本来要写一个原子的方法。但锁粒度细了，导致方法本身并未原子化。与开篇get，set加sync是一个道理","like_count":0},{"had_liked":false,"id":77979,"user_name":"黄海峰","can_delete":false,"product_type":"c1","uid":1275357,"ip_address":"","ucode":"E9340719BC96B2","user_header":"https://static001.geekbang.org/account/avatar/00/13/75/dd/9ead6e69.jpg","comment_is_top":false,"comment_ctime":1553048410,"is_pvip":false,"replies":[{"id":"28486","content":"这个公平锁也搞不定<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553081533,"ip_address":"","comment_id":77979,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553048410","product_id":100023901,"comment_content":"公平锁后面还会详细介绍吗？文中并没有讲明白先来后到怎么就解决了饥饿问题，如果先到的占用锁很长时间还不是一样导致后面线程饿死？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443921,"discussion_content":"这个公平锁也搞不定\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553081533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77807,"user_name":"飞翔的花狸猫","can_delete":false,"product_type":"c1","uid":1143473,"ip_address":"","ucode":"F3BA6126E02059","user_header":"https://static001.geekbang.org/account/avatar/00/11/72/b1/a8b272ef.jpg","comment_is_top":false,"comment_ctime":1553002042,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553002042","product_id":100023901,"comment_content":"虽然 Vector 的 add 方法是用 syncronized 来保证线程安全的，但是addIfNotExist 方法中 if(!v.contains(o)) 是竞态条件，所以 addIfNotExist 不能保证线程安全；<br>举例：线程 A、B 同时执行 addIfNotExist 方法，执行  if(!v.contains(o)) 时，两个线程执行的结果都是 true，虽然在执行 vector 时，会依次执行 add，但是最终结果中会有两个 o，不满足方法初始的定义","like_count":0},{"had_liked":false,"id":77078,"user_name":"G","can_delete":false,"product_type":"c1","uid":1206873,"ip_address":"","ucode":"35A3A0CD1FF675","user_header":"https://static001.geekbang.org/account/avatar/00/12/6a/59/ba3cad16.jpg","comment_is_top":false,"comment_ctime":1552830500,"is_pvip":false,"replies":[{"id":"28100","content":"竟态条件的定义还是挺宽泛的，并发if只是其中之一。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552836678,"ip_address":"","comment_id":77078,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552830500","product_id":100023901,"comment_content":"add10k我觉得是原子性问题，它并没有条件判断，它是对cpu执行指令的误解。而竟态条件高并发程序中，同时执行条件判断，导致后续写操作执行多次而引起的代码bug","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443573,"discussion_content":"竟态条件的定义还是挺宽泛的，并发if只是其中之一。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552836678,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76982,"user_name":"龙猫","can_delete":false,"product_type":"c1","uid":1112490,"ip_address":"","ucode":"FD726CC969EF9C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/aa/3e80212e.jpg","comment_is_top":false,"comment_ctime":1552793717,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552793717","product_id":100023901,"comment_content":"存在竞态条件问题","like_count":0},{"had_liked":false,"id":76894,"user_name":"sakura","can_delete":false,"product_type":"c1","uid":1449550,"ip_address":"","ucode":"D382C3325F2F59","user_header":"https://static001.geekbang.org/account/avatar/00/16/1e/4e/56a0b904.jpg","comment_is_top":false,"comment_ctime":1552741112,"is_pvip":false,"replies":[{"id":"28080","content":"存在","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552791887,"ip_address":"","comment_id":76894,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552741112","product_id":100023901,"comment_content":"老师add10k那里 如果将count修饰为volatile（避免CPU缓存问题）还会存在不安全吗 ？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443491,"discussion_content":"存在","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552791887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76512,"user_name":"而立斋","can_delete":false,"product_type":"c1","uid":1087258,"ip_address":"","ucode":"5FED6E9E148195","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/1a/389eab84.jpg","comment_is_top":false,"comment_ctime":1552621523,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552621523","product_id":100023901,"comment_content":"ReentrantLock，通常翻译为再入锁，是 Java 5 提供的锁实现，它的语义和 synchronized 基本相同。再入锁通过代码直接调用 lock() 方法获取，代码书写也更加灵活。与此同时，ReentrantLock 提供了很多实用的方法，能够实现很多 synchronized 无法做到的细节控制，比如可以控制 fairness，也就是公平性，或者利用定义条件等。","like_count":0},{"had_liked":false,"id":76420,"user_name":"约书亚","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","comment_is_top":false,"comment_ctime":1552609361,"is_pvip":false,"replies":[{"id":"27882","content":"最终是调用操作系统api，java里线程的调度用的是操作系统的线程调度，每一个java线程都对应一个操作系统线程<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552623021,"ip_address":"","comment_id":76420,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552609361","product_id":100023901,"comment_content":"老师，高级语言中使用互斥锁，无论是java中的同步块，还是locksupport，其底层阻塞一个线程的机制是什么呢？是操作系统提供的api嘛？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443298,"discussion_content":"最终是调用操作系统api，java里线程的调度用的是操作系统的线程调度，每一个java线程都对应一个操作系统线程\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552623021,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76381,"user_name":"邋遢的流浪剑客","can_delete":false,"product_type":"c1","uid":1260881,"ip_address":"","ucode":"32AF6F9070506D","user_header":"https://static001.geekbang.org/account/avatar/00/13/3d/51/9723276c.jpg","comment_is_top":false,"comment_ctime":1552580553,"is_pvip":false,"replies":[{"id":"27891","content":"线程本地缓存，没这个东西，和cpu缓存有关，你可以再复习一下前面讲的<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552624186,"ip_address":"","comment_id":76381,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552580553","product_id":100023901,"comment_content":"问一下老师add10k方法不安全是不是和线程的本地缓冲区有关，这个地方不太理解","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443281,"discussion_content":"线程本地缓存，没这个东西，和cpu缓存有关，你可以再复习一下前面讲的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552624186,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76347,"user_name":"谢谢","can_delete":false,"product_type":"c1","uid":1451379,"ip_address":"","ucode":"13A046A7B9C518","user_header":"https://static001.geekbang.org/account/avatar/00/16/25/73/cbbbaef1.jpg","comment_is_top":false,"comment_ctime":1552574519,"is_pvip":false,"replies":[{"id":"27888","content":"直接锁住v就可以了，把if和add原子化<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552624069,"ip_address":"","comment_id":76347,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552574519","product_id":100023901,"comment_content":"课后思考题是会出现并发问题，vector的线程安全指的是本身方法加了同步锁来保证线程安全，题中分了两步执行，那么就有可能出现两个线程同时进入if分支。这个让人联想到老师您讲单例那个例子的public方法，不知道能否在if分支后加把类锁，再加一次if判断，然后再add？只是不知道此处add操作细化到CPU指令后，会不会出现像单例模式中的线程切换问题，即对象未add成功便被认为是已经add进去了，烦请老师解答。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443267,"discussion_content":"直接锁住v就可以了，把if和add原子化\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552624069,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76310,"user_name":"橘子","can_delete":false,"product_type":"c1","uid":1368522,"ip_address":"","ucode":"EDF6145878F897","user_header":"https://static001.geekbang.org/account/avatar/00/14/e1/ca/d8b0835f.jpg","comment_is_top":false,"comment_ctime":1552570250,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552570250","product_id":100023901,"comment_content":"竞态条件","like_count":0},{"had_liked":false,"id":76297,"user_name":"老杨同志","can_delete":false,"product_type":"c1","uid":1246199,"ip_address":"","ucode":"3F334F0CFD3DE6","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/f7/3a493bec.jpg","comment_is_top":false,"comment_ctime":1552568724,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552568724","product_id":100023901,"comment_content":"课后思考题线程不安全。<br>crazypokerk同学说这两个方法没有加synchronized，有点不准确。他们调用的方法都加了synchronized","like_count":0},{"had_liked":false,"id":76291,"user_name":"木卫六","can_delete":false,"product_type":"c1","uid":1199495,"ip_address":"","ucode":"D113DF578C5BF5","user_header":"https://static001.geekbang.org/account/avatar/00/12/4d/87/57236a2d.jpg","comment_is_top":false,"comment_ctime":1552568211,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1552568211","product_id":100023901,"comment_content":"这个和set(get()+1)是同样的问题，单独每个方法都是安全的，但是两步在一起就有data race问题了","like_count":0},{"had_liked":false,"id":76250,"user_name":"___","can_delete":false,"product_type":"c1","uid":1229519,"ip_address":"","ucode":"B0BA5A1413798C","user_header":"https://static001.geekbang.org/account/avatar/00/12/c2/cf/573a0fdc.jpg","comment_is_top":false,"comment_ctime":1552557372,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552557372","product_id":100023901,"comment_content":"vector是线程安全，但在addIfNotExist中线程1判断了o对象不再vector容器中，还没有add的情况下，线程2也判断了o对象不在vector容器中，这样就会导致重复添加","like_count":0},{"had_liked":false,"id":76238,"user_name":"空空空空","can_delete":false,"product_type":"c1","uid":1082938,"ip_address":"","ucode":"A1A50E16E02803","user_header":"https://static001.geekbang.org/account/avatar/00/10/86/3a/76dbbd0e.jpg","comment_is_top":false,"comment_ctime":1552555333,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552555333","product_id":100023901,"comment_content":"可能两个线程同事进入if中，导致重复添加值","like_count":0},{"had_liked":false,"id":76217,"user_name":"Ying","can_delete":false,"product_type":"c1","uid":1307466,"ip_address":"","ucode":"FAE36C852765F2","user_header":"https://static001.geekbang.org/account/avatar/00/13/f3/4a/4874b350.jpg","comment_is_top":false,"comment_ctime":1552552366,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552552366","product_id":100023901,"comment_content":"受保护资源 如果有关联关系   锁要覆盖所有的 这里并没有","like_count":0},{"had_liked":false,"id":76199,"user_name":"机遇号","can_delete":false,"product_type":"c1","uid":1105053,"ip_address":"","ucode":"A2940DE77BCAEA","user_header":"https://static001.geekbang.org/account/avatar/00/10/dc/9d/e20b37d7.jpg","comment_is_top":false,"comment_ctime":1552548275,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552548275","product_id":100023901,"comment_content":"学习中","like_count":0},{"had_liked":false,"id":76193,"user_name":"10buns","can_delete":false,"product_type":"c1","uid":1016554,"ip_address":"","ucode":"56E51AC21C8189","user_header":"https://static001.geekbang.org/account/avatar/00/0f/82/ea/d054c133.jpg","comment_is_top":false,"comment_ctime":1552547476,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552547476","product_id":100023901,"comment_content":"思考题的addIfNotExist方法不是原子操作","like_count":0},{"had_liked":false,"id":76191,"user_name":"乐凡","can_delete":false,"product_type":"c1","uid":1239260,"ip_address":"","ucode":"918C9997EB6537","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/dc/32e78f02.jpg","comment_is_top":false,"comment_ctime":1552547261,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552547261","product_id":100023901,"comment_content":"有并发问题，contains()方法和add方法不是原子性的，当满足contains条件后，在执行add之前，可能有其他线程对V进行修改，修改后contains可能不满足了，但V还是执行了add()方法，这个问题就是王老师讲的竞态条件问题","like_count":0},{"had_liked":false,"id":76164,"user_name":"Halohoop","can_delete":false,"product_type":"c1","uid":1108517,"ip_address":"","ucode":"623C5E6AF7BCE0","user_header":"https://static001.geekbang.org/account/avatar/00/10/ea/25/75be8cdf.jpg","comment_is_top":false,"comment_ctime":1552540913,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552540913","product_id":100023901,"comment_content":"有并发问题，可以简单理解为虽然同一个时间add和contains是互斥的，但是两条线程中的if代码块没做处理就不是互斥的了。","like_count":0},{"had_liked":false,"id":76162,"user_name":"笨拙的自由","can_delete":false,"product_type":"c1","uid":1309452,"ip_address":"","ucode":"BEDD613DEDD8ED","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLRwauvbuyKfib8Qm3NBNU908zhKS0WPnvTEN4EJYSJyKwMuSHTWgXqP5WrSexgQAhLSiblydA24EMg/132","comment_is_top":false,"comment_ctime":1552540510,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552540510","product_id":100023901,"comment_content":"这个组合操作不是原子性的,需要在外层加锁控制","like_count":0},{"had_liked":false,"id":76117,"user_name":"那就这样吧","can_delete":false,"product_type":"c1","uid":1327343,"ip_address":"","ucode":"A1315C5EAF2917","user_header":"https://static001.geekbang.org/account/avatar/00/14/40/ef/52bbadb9.jpg","comment_is_top":false,"comment_ctime":1552532633,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552532633","product_id":100023901,"comment_content":"会存在并发问题，因为contains和add方法并不是串行的，虽然indexOf（）和 add()方法都加了锁。<br>假设两个线程A和B都执行到if判断，当A获得indexOf（）方法锁时，判断完后释放锁，如果此时B获得indexOf()方法锁并执行在A执行方法Add之前执行，就会重复add","like_count":0},{"had_liked":false,"id":76089,"user_name":"西行寺咕哒子","can_delete":false,"product_type":"c1","uid":1441988,"ip_address":"","ucode":"CAE570245BA299","user_header":"https://static001.geekbang.org/account/avatar/00/16/00/c4/634c1e10.jpg","comment_is_top":false,"comment_ctime":1552529934,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552529934","product_id":100023901,"comment_content":"存在的，虽然contains中调用的indexOf方法 和 add都加了锁 但是 a线程判断完contains 肯能还没有来得及add 就被人家其他线程判断了，其他线程也可以继续执行add，导致重复添加。","like_count":0},{"had_liked":false,"id":76082,"user_name":"影子传说","can_delete":false,"product_type":"c1","uid":1031636,"ip_address":"","ucode":"371B72BB5CCB5E","user_header":"","comment_is_top":false,"comment_ctime":1552528979,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552528979","product_id":100023901,"comment_content":"是有并发安全问题的，如一个线程在判断完<br>！v.contain(o),之后挂起，另一个线程接着判断这个条件并顺利执行后会出现重复add的情况","like_count":0},{"had_liked":false,"id":76079,"user_name":"君哥聊技术","can_delete":false,"product_type":"c1","uid":1325816,"ip_address":"","ucode":"2C9A22BCE4C79E","user_header":"https://static001.geekbang.org/account/avatar/00/14/3a/f8/c1a939e7.jpg","comment_is_top":false,"comment_ctime":1552528494,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552528494","product_id":100023901,"comment_content":"如果2个线程同时读取到contains是false，就会先后调用add方法，所以存在并发问题","like_count":0},{"had_liked":false,"id":76070,"user_name":"谢特","can_delete":false,"product_type":"c1","uid":1248684,"ip_address":"","ucode":"9C30DBFECFE649","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/ac/09678490.jpg","comment_is_top":false,"comment_ctime":1552527962,"is_pvip":false,"replies":[{"id":"27830","content":"单线程执行，不能并行处理的时间 &#47; 总时间 = 串行百分比","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552573938,"ip_address":"","comment_id":76070,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552527962","product_id":100023901,"comment_content":"串行百分比指的是","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443164,"discussion_content":"单线程执行，不能并行处理的时间 / 总时间 = 串行百分比","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552573938,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76058,"user_name":"小黄","can_delete":false,"product_type":"c1","uid":1049839,"ip_address":"","ucode":"519BF8191D3A6B","user_header":"https://static001.geekbang.org/account/avatar/00/10/04/ef/fea0fdbd.jpg","comment_is_top":false,"comment_ctime":1552526851,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552526851","product_id":100023901,"comment_content":"自己也总结下，分析并发问题，先定位是安全问题，还是性能问题。结合并发问题的三个根本原因，找到数据竞争或条件竞争位置进一步分析（死锁、饥饿）；如果是性能问题，根据性能的三个指标调优抑或考虑该不该使用并发","like_count":0},{"had_liked":false,"id":76043,"user_name":"wilburJiang","can_delete":false,"product_type":"c1","uid":1107836,"ip_address":"","ucode":"F83D474D692C06","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI5uDOruARAmFZr49ic2nib3ibj1TSBUKydMH2H3XHUniaR0FHeNVkOI9dfndxtJIOOrY2w5nhrHjX3UQ/132","comment_is_top":false,"comment_ctime":1552525744,"is_pvip":true,"replies":[{"id":"27828","content":"单线程执行，不能并行处理的时间 &#47; 总时间 = 串行百分比","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552573841,"ip_address":"","comment_id":76043,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1552525744","product_id":100023901,"comment_content":"请问老师，串行百分比如何确定呢","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443146,"discussion_content":"单线程执行，不能并行处理的时间 / 总时间 = 串行百分比","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552573841,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76014,"user_name":"新世界","can_delete":false,"product_type":"c1","uid":1079495,"ip_address":"","ucode":"4473DC1505F158","user_header":"https://static001.geekbang.org/account/avatar/00/10/78/c7/083a3a0b.jpg","comment_is_top":false,"comment_ctime":1552524012,"is_pvip":false,"replies":[{"id":"27827","content":"contains调用的indexOf加synchronized了。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552573795,"ip_address":"","comment_id":76014,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552524012","product_id":100023901,"comment_content":"vector的contain等读相关的操作是没有加synchronized的，这个竞态条件非线程安全","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443133,"discussion_content":"contains调用的indexOf加synchronized了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552573795,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76012,"user_name":"Rayjun","can_delete":false,"product_type":"c1","uid":1002514,"ip_address":"","ucode":"61A3D1A3D03569","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4c/12/f0c145d4.jpg","comment_is_top":false,"comment_ctime":1552523809,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1552523809","product_id":100023901,"comment_content":"存在并发问题，vector 本身的线程安全并不能保证这 contains 和 add 的两个操作是线程安全的","like_count":0},{"had_liked":false,"id":76001,"user_name":"冰激凌的眼泪","can_delete":false,"product_type":"c1","uid":1087945,"ip_address":"","ucode":"5DCB974667E93A","user_header":"https://static001.geekbang.org/account/avatar/00/10/99/c9/a7c77746.jpg","comment_is_top":false,"comment_ctime":1552522879,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552522879","product_id":100023901,"comment_content":"忘了哪里说的，check和set操作，是个典型的需要原子操作来保证线程安全的操作组合","like_count":0},{"had_liked":false,"id":75985,"user_name":"轻歌赋","can_delete":false,"product_type":"c1","uid":1251574,"ip_address":"","ucode":"22F62446208805","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/f6/2ff7bc7a.jpg","comment_is_top":false,"comment_ctime":1552521597,"is_pvip":false,"replies":[{"id":"27825","content":"单线程执行，不能并行处理的时间 &#47; 总时间 = 串行百分比","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552573561,"ip_address":"","comment_id":75985,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552521597","product_id":100023901,"comment_content":"存在线程安全问题，因为判断和add是分别线程安全的但是两个操作并不是原子的，会出现判断后被抢占CPU的情况。<br>请问老师，如何计算串行百分比呢？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443120,"discussion_content":"单线程执行，不能并行处理的时间 / 总时间 = 串行百分比","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552573561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75980,"user_name":"IamNigel","can_delete":false,"product_type":"c1","uid":1435709,"ip_address":"","ucode":"388064ADD5A38C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJS0jwYKhjm1pRfCu5X6U0VyVS4ibgdhoAkEyV7FNdIMlXoibCyticb0kGYfDUibGcNrHtmkd8SWJekAA/132","comment_is_top":false,"comment_ctime":1552519929,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552519929","product_id":100023901,"comment_content":"vector对象是共享的话会有并发问题","like_count":0},{"had_liked":false,"id":75976,"user_name":"gyl-coder","can_delete":false,"product_type":"c1","uid":1161050,"ip_address":"","ucode":"133C1086DC16CD","user_header":"https://static001.geekbang.org/account/avatar/00/11/b7/5a/91b115e1.jpg","comment_is_top":false,"comment_ctime":1552518779,"is_pvip":false,"replies":[{"id":"27682","content":"多谢多谢！是个bug","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552523942,"ip_address":"","comment_id":75976,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552518779","product_id":100023901,"comment_content":"第二个代码样例中的get方法应该返回的是count吧  return long——&gt; return count","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443115,"discussion_content":"多谢多谢！是个bug","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552523942,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75970,"user_name":"探索无止境","can_delete":false,"product_type":"c1","uid":1044178,"ip_address":"","ucode":"91D2A9907DFA79","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/d2/7024431c.jpg","comment_is_top":false,"comment_ctime":1552517901,"is_pvip":false,"replies":[{"id":"27683","content":"后面有一章专门讲<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552524028,"ip_address":"","comment_id":75970,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552517901","product_id":100023901,"comment_content":"老师你好，多核CPU最多开启多少个线程是比较合适的？比如4核的CPU，这里面有什么分析的依据吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443112,"discussion_content":"后面有一章专门讲\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552524028,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75954,"user_name":"捞鱼的搬砖奇","can_delete":false,"product_type":"c1","uid":1021539,"ip_address":"","ucode":"2FD194C4DA26E5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/96/63/7eb32c9b.jpg","comment_is_top":false,"comment_ctime":1552497256,"is_pvip":false,"replies":[{"id":"27774","content":"是的<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552561260,"ip_address":"","comment_id":75954,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552497256","product_id":100023901,"comment_content":"自己思考了下，当对象可以表示某个状态，且这些状态可能会被修改，这样才有并发问题。如果对象带有状态，但只是只读，就不会有并发安全带问题。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443103,"discussion_content":"是的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552561260,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75948,"user_name":"李皮皮皮皮皮","can_delete":false,"product_type":"c1","uid":1200281,"ip_address":"","ucode":"3BF1DEE4A12359","user_header":"https://static001.geekbang.org/account/avatar/00/12/50/99/44378317.jpg","comment_is_top":false,"comment_ctime":1552496415,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552496415","product_id":100023901,"comment_content":"课后思考题：有并发问题，两个线程同时执行到第3行的判断，这时容器无元素o，判断通过。元素o会被添加两次😢","like_count":0},{"had_liked":false,"id":75944,"user_name":"西西弗与卡夫卡","can_delete":false,"product_type":"c1","uid":1001710,"ip_address":"","ucode":"B4C27B8335B76A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/ee/872ad07e.jpg","comment_is_top":false,"comment_ctime":1552495539,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1552495539","product_id":100023901,"comment_content":"有并发问题。两个线程先后判断出!contains某个值后，会先后都add该值。要synchronized整个addIfNotExist方法才行","like_count":0}]}