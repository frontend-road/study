{"id":638954,"title":"13｜线索二叉树：如何线索化二叉树以提升访问速度？","content":"<p>你好，我是王健伟。</p><p>今天我要和你分享的主题是“线索二叉树”。</p><p>和传统二叉树相比，线索二叉树可以进一步提高访问二叉树节点的速度，从而提高访问二叉树的效率，当然，“线索”这个概念的引入也意味着要对原来的二叉树实现代码做出相应的修改。</p><p>那么，什么是线索？要怎么把传统二叉树转变为线索二叉树？带着这些问题，我们先从线索二叉树的概念开始说起，进而探讨如何对二叉树进行线索化，以及在线索二叉树上的操作问题。</p><h2><strong>线索二叉树的基本概念</strong></h2><p>我们先来看一个简单的二叉树链式存储。</p><p><img src=\"https://static001.geekbang.org/resource/image/d3/dc/d31cbyy3811c780b94ab573643ed46dc.jpg?wh=2284x852\" alt=\"\" title=\"图 1  二叉树链式存储方式的结构示意图\"></p><p>在图 1 所示二叉树的链式存储中，每个二叉树节点<span class=\"reference\">（BinaryTreeNode）</span>都包含两个指针域，分别是左子节点指针<span class=\"reference\">（leftChild）</span>和右子节点指针<span class=\"reference\">（rightChild）</span>。但一个二叉树中往往某些节点并没有左孩子或者右孩子，尤其是叶子节点，根本就不存在左孩子和右孩子。</p><p>这张图里一共有8个节点，除了根节点外，<strong>都会有一根来自其他节点的指针指向该节点自身</strong>。仔细数下来，对于8个节点的2叉树，虽然一共有16个指针域，但实际使用了的只有7个。</p><p>总结一下，就是如果一个二叉树有n个节点，因为一个节点结构包含两个指针域，所以一共有2n个指针域，但是，其中只使用了n-1个指针域指向二叉树的各个子节点。</p><!-- [[[read_end]]] --><p>我们可以算一下，一共有2n个指针域，只使用了n-1个指针域，那么有多少个指针域没有使用呢？</p><p>2n-（n-1）=n+1</p><p>这n+1个指针域就这样白白浪费了。所以，为了物尽其用，我们可以用这n+1个指针域记录一些有用的信息。</p><p>那要记录什么，又要怎么记录呢？</p><p><img src=\"https://static001.geekbang.org/resource/image/29/e7/291f73ca5877f2ddd2ace94f66216ee7.jpg?wh=2284x736\" alt=\"\" title=\"图 2 中序遍历访问的二叉树节点顺序\"></p><p>图 2 所示的这棵二叉树中序遍历<span class=\"reference\">（前序、后序遍历也同样道理）</span>的顺序为 DGBHEACF。</p><p>在这个序列中，除 D 和 F 节点外，其他节点都有且只有一个直接前趋和一个直接后继。比如 B 的前趋是 G，B 的后继是 H，而 D 节点没有前趋，F 节点没有后继。</p><p>问题来了，在存储起一棵二叉树后，我们可以<strong>通过节点E的左孩子指针迅速找到节点H，但并没有办法通过节点E迅速找到其在中序遍历序列中的后继节点A。</strong></p><p>也就是说，只能通过节点的左右孩子指针找到该节点的左右孩子，但没有办法直接得到某个节点在某个遍历序列中的前趋或者后继节点，这种前趋或者后继节点的信息只能在遍历的过程中<strong>动态得到。</strong></p><p>不过，既然节点E没有右孩子，那么节点E的右孩子指针可以用来记录后继节点A，也就是指向A。这样就可以通过节点E迅速找到节点A了。</p><p><img src=\"https://static001.geekbang.org/resource/image/cc/0d/cc030aca71cf1c81bc81f5eea51a650d.jpg?wh=2284x749\" alt=\"\" title=\"图 3  按照中序遍历序列对一棵二叉树进行线索化，其中虚线表示的是线索\"></p><p>举个例子。在图 3 中：</p><ul>\n<li>G 节点的左右子节点指针都没有被使用，因此可以用左节点指针指向 G 节点在中序遍历序列中的前趋节点 D，右节点指针指向 G 节点在中序遍历中的后继节点 B。</li>\n<li>D 节点的左子节点指针没有被使用，因此可以用于指向 D 节点在中序遍历序列中的前趋节点，但因为在中序遍历序列中 D 没有前趋节点，因此该指针只能指向 nullptr。</li>\n<li>H 节点的左节点指针指向前趋节点 B，右节点指针指向后继节点 E。</li>\n<li>E 节点的右指针指向后继节点 A。</li>\n<li>F 节点的左节点指针指向前趋节点 C，右节点指针指向后继节点，但因为 F 节点没有后继节点，所以该指针只能指向 nullptr。</li>\n<li>C 节点的左节点指针指向前趋节点 A。</li>\n</ul><p>总结一下，这些<strong>指向前趋节点和后继节点的指针<strong><strong>就叫做</strong></strong>线索</strong>。由节点的左孩子指针充当指向前趋节点的线索，由节点的右孩子指针充当指向后继节点的线索。</p><p>我们把加上了线索的二叉树称为<strong>线索二叉树</strong>。对二叉树进行某种序列的遍历使其成为一棵线索二叉树的过程称为二叉树的<strong>线索化</strong>。</p><p>线索二叉树对于节点的插入、删除、查找前趋后继等都会变得更加方便，<strong>解决了存储空间的浪费问题，也解决了前趋和后继节点的记录问题</strong><strong>，</strong>这就是建立这些线索的意义。</p><p>当然，线索二叉树也分为<strong>前序、中序、后序</strong>线索二叉树，而且，因为二叉树还可以层序遍历，因此也存在层序线索二叉树。话说回来，前序线索二叉树是以前序遍历序列为依据对二叉树进行线索化，而中序、后序线索二叉树当然是分别以中序、后序遍历序列为依据对二叉树进行线索化。</p><h2><strong>如何对二叉树进行线索化</strong></h2><p>要编写线索二叉树的实现代码，得先看一看线索二叉树中每个节点的结构是什么样的。我们先回顾一下以往二叉树链式存储时树中的每个节点的定义。</p><pre><code class=\"language-plain\">//树中每个节点的定义\ntemplate &lt;typename T&gt; //T 代表数据元素的类型\nstruct BinaryTreeNode\n{\n    T &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//数据域，存放数据元素\n    BinaryTreeNode* leftChild, &nbsp;&nbsp;//左子节点指针\n                  * rightChild;  //右子节点指针\n};\n</code></pre><p>而在线索二叉树中，左子节点指针和右子节点指针指向的可能是前趋和后继节点，这就需要为 BinaryTreeNode 结构增加两个标志变量，用于标记指针保存的是左、右子节点还是前趋、后继节点，下面是修改后的 BinaryTreeNode 结构。</p><pre><code class=\"language-plain\">//树中每个节点的定义\ntemplate &lt;typename T&gt; //T 代表数据元素的类型\nstruct BinaryTreeNode\n{\n    T &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//数据域，存放数据元素\n    BinaryTreeNode* leftChild, &nbsp;&nbsp;//左子节点指针\n&nbsp;&nbsp;&nbsp;&nbsp;              * rightChild;  //右子节点指针\n    int8_t &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leftTag, &nbsp;&nbsp;  &nbsp;&nbsp;//左标志 = 0 表示 leftChild 指向的是左子节点，=1 表示 leftChild 指向的是前趋节点（线索）\n                  rightTag; &nbsp;   &nbsp;//右标志 = 0 表示 rightChild 指向的是右子节点，=1 表示 rightChild 指向的是后继节点（线索）\n};\n</code></pre><p>我们通常将二叉树存储结构称为<strong>二叉链表</strong>，而在这里，把这种修改后的、适用于线索二叉树的存储结构称为<strong>线索链表</strong>。想一想，对于图 3 所示的线索二叉树对应的链式存储方式结构示意图应该怎么画呢？</p><p><img src=\"https://static001.geekbang.org/resource/image/d1/81/d1c8917c42b355201951fdb16a0ce781.jpg?wh=2744x889\" alt=\"\"></p><p>结果如图 4 所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/30/18/30cb2ea0db98f2c0d0a96a73cf7e3318.jpg?wh=2284x966\" alt=\"\" title=\"图 4  中序遍历的线索二叉树对应的链式存储方式结构示意图\"></p><p>图中，0表示指向的是左/右子节点，1表示指向的是前趋/后继节点。</p><p>二叉树的线索化过程针对的是二叉树节点的空指针，也就是我们之前说过的“n+1”个没有左孩子或者右孩子的指针。</p><p>换句话说，在线索化一棵二叉树的过程中，我们并没有把所有节点的前趋和后继节点都记录下来，只是利用了 n+1 个空指针域进行前趋和后继节点的记录。</p><p>那么，对于没有记录其前趋和后继的节点，就要通过一些其他方法寻找其前趋和后继了。</p><h3>用中序遍历序列线索化二叉树</h3><p>我们先耐下心来理解一下线索二叉树的定义和实现代码。</p><pre><code class=\"language-plain\">//线索二叉树的定义\ntemplate &lt;typename T&gt;\nclass ThreadBinaryTree\n{\npublic:\n\tThreadBinaryTree();&nbsp; //构造函数\t\t\n\t~ThreadBinaryTree(); //析构函数\npublic:\n\t//利用扩展二叉树的前序遍历序列来创建一棵二叉树\n\tvoid CreateBTreeAccordPT(char* pstr);\nprivate:\n\t//利用扩展二叉树的前序遍历序列创建二叉树的递归函数\n\tvoid CreateBTreeAccordPTRecu(BinaryTreeNode&lt;T&gt;*&amp; tnode, char*&amp; pstr);//参数为引用类型，确保递归调用中对参数的改变会影响到调用者\npublic:\n\t//在二叉树中根据中序遍历序列创建线索\n\tvoid CreateThreadInBTreeAccordIO();\nprivate:\n\tvoid CreateThreadInBTreeAccordIO(BinaryTreeNode&lt;T&gt;*&amp; tnode, BinaryTreeNode&lt;T&gt;*&amp; pre);//参数为引用类型\nprivate:\n\tvoid ReleaseNode(BinaryTreeNode&lt;T&gt;* pnode);\nprivate:\n\tBinaryTreeNode&lt;T&gt;* root; //树根指针\t\n};\n\n//构造函数\ntemplate&lt;class T&gt;\nThreadBinaryTree&lt;T&gt;::ThreadBinaryTree()\n{\n\troot = nullptr;\n}\n\t\n//析构函数\ntemplate&lt;class T&gt;\nThreadBinaryTree&lt;T&gt;::~ThreadBinaryTree()\n{\n\tReleaseNode(root);\n};\n\t\n//释放二叉树节点\ntemplate&lt;class T&gt;\nvoid ThreadBinaryTree&lt;T&gt;::ReleaseNode(BinaryTreeNode&lt;T&gt;* pnode)\n{\n\tif (pnode != nullptr)\n\t{\n\t\tif(pnode-&gt;leftTag == 0)\n\t\t\tReleaseNode(pnode-&gt;leftChild); //只有真的需要delete的节点，才会递归调用ReleaseNode\n\t\tif (pnode-&gt;rightTag == 0)\n\t\t\tReleaseNode(pnode-&gt;rightChild); //只有真的需要delete的节点，才会递归调用ReleaseNode\n\t}\t\n\tdelete pnode;\n}\n\t\n//利用扩展二叉树的前序遍历序列来创建一棵二叉树\ntemplate&lt;class T&gt;\nvoid ThreadBinaryTree&lt;T&gt;::CreateBTreeAccordPT(char* pstr)\n{\n\tCreateBTreeAccordPTRecu(root, pstr);\n}\n\n//利用扩展二叉树的前序遍历序列创建二叉树的递归函数\ntemplate&lt;class T&gt;\nvoid ThreadBinaryTree&lt;T&gt;::CreateBTreeAccordPTRecu(BinaryTreeNode&lt;T&gt;*&amp; tnode, char*&amp; pstr)\n{\n\tif (*pstr == '#')\n\t{\n\t\ttnode = nullptr;\n\t}\n\telse\n\t{\n\t\ttnode = new BinaryTreeNode&lt;T&gt;; //创建根节点\n\t\ttnode-&gt;leftTag = tnode-&gt;rightTag = 0; //标志先给0\n\t\ttnode-&gt;data = *pstr;\n\t\tCreateBTreeAccordPTRecu(tnode-&gt;leftChild, ++pstr); //创建左子树\n\t\tCreateBTreeAccordPTRecu(tnode-&gt;rightChild, ++pstr);//创建右子树\n\t}\n}\n\t\n//在二叉树中根据中序遍历序列创建线索\ntemplate&lt;class T&gt;\nvoid ThreadBinaryTree&lt;T&gt;::CreateThreadInBTreeAccordIO()\n{\n\tBinaryTreeNode&lt;T&gt;* pre = nullptr;  //记录当前所指向的节点的前趋节点（刚开始的节点没有前趋，所以设置为nullptr）\n\t\t\n\tCreateThreadInBTreeAccordIO(root, pre);\n\t\t\n\t//注意处理最后一个节点的右孩子，因为这个右孩子还没处理\n\tpre-&gt;rightChild = nullptr; //这里之所以直接给nullptr，是因为中序遍历访问顺序是左根右，所以最后一个节点不可能有右孩子，否则最后一个访问的节点就会是他的右孩子。其实就算不执行这句，pre-&gt;rightChild也已经是等于nullptr的了。 \n\tpre-&gt;rightTag = 1; //线索化\n}\n\t\ntemplate&lt;class T&gt;\nvoid ThreadBinaryTree&lt;T&gt;::CreateThreadInBTreeAccordIO(BinaryTreeNode&lt;T&gt;*&amp; tnode, BinaryTreeNode&lt;T&gt;*&amp; pre)\n{\n\tif (tnode == nullptr)\n\t\treturn;\n\t\t\n\t//中序遍历序列（左根右），递归顺序非常类似于中序遍历\t\t\n\tCreateThreadInBTreeAccordIO(tnode-&gt;leftChild, pre);\n\t\t\n\tif (tnode-&gt;leftChild == nullptr) //找空闲的指针域进行线索化\n\t{\n\t\ttnode-&gt;leftTag = 1; //线索\n\t\ttnode-&gt;leftChild = pre;  //如果leftChild ==nullptr，说明该节点没有前趋节点\n\t}\n\t\t\n\t//这个前趋节点的后继节点肯定是当前这个节点tnode \n\tif (pre != nullptr &amp;&amp; pre-&gt;rightChild == nullptr)\n\t{\n\t\tpre-&gt;rightTag = 1; //线索\n\t\tpre-&gt;rightChild = tnode;\n\t}\n\tpre = tnode; //前趋节点指针指向当前节点\n\t\n\tCreateThreadInBTreeAccordIO(tnode-&gt;rightChild, pre);\n}\n</code></pre><p>依据这些代码，我们就可以创建线索二叉树了。创建线索二叉树可以分成两个步骤。</p><ol>\n<li><strong>用任何方法创建二叉树</strong>。这里将采用前面使用过的利用扩展二叉树的前序遍历序列创建图 3 所示的二叉树。</li>\n</ol><p><img src=\"https://static001.geekbang.org/resource/image/cc/0d/cc030aca71cf1c81bc81f5eea51a650d.jpg?wh=2284x749\" alt=\"\" title=\"图3回顾  按照中序遍历序列对一棵二叉树进行线索化，其中虚线表示的是线索\"></p><ol start=\"2\">\n<li>将该二叉树按照中序<span class=\"reference\">（也可以是前序、后序）</span>遍历序列<strong>创建线索</strong>，这会用到 CreateThreadInBTreeAccordIO 成员函数。</li>\n</ol><p>在 main 主函数，加入下面的代码来创建并按中序遍历线索化一棵二叉树。</p><pre><code class=\"language-plain\">ThreadBinaryTree&lt;int&gt; mythreadtree;\nmythreadtree.CreateBTreeAccordPT((char*)\"ABD#G##EH###C#F##\"); &nbsp;//利用扩展二叉树的前序遍历序列创建二叉树\n//对二叉树进行线索化(根据中序遍历序列创建线索)\nmythreadtree.CreateThreadInBTreeAccordIO();\n</code></pre><p>从上面的代码不难看到，根据中序遍历序列线索化二叉树的过程其实与中序遍历的过程非常类似，只不过是在遍历的过程中进行线索化而已。</p><h3>用前序遍历序列线索化二叉树</h3><p>前面的代码演示了在二叉树中根据中序遍历序列线索化二叉树。那么如果根据前序遍历序列线索化二叉树代码应该是什么样的呢？</p><p>可以参照上述的 CreateThreadInBTreeAccordIO 成员函数来书写名字叫做 CreateThreadInBTreeAccordPO 的新成员函数来实现，参考下面的代码。</p><pre><code class=\"language-plain\">//在二叉树中根据前序遍历序列创建线索\ntemplate&lt;class T&gt;\nvoid ThreadBinaryTree&lt;T&gt;::CreateThreadInBTreeAccordPO()\n{\n\tBinaryTreeNode&lt;T&gt;* pre = nullptr;\n\tCreateThreadInBTreeAccordPO(root, pre);\t\t\n\tpre-&gt;rightChild = nullptr;\n\tpre-&gt;rightTag = 1;\n}\ntemplate&lt;class T&gt;\nvoid ThreadBinaryTree&lt;T&gt;::CreateThreadInBTreeAccordPO(BinaryTreeNode&lt;T&gt;*&amp; tnode, BinaryTreeNode&lt;T&gt;*&amp; pre)\n{\n\tif (tnode == nullptr)\n\t\treturn;\n\t\n\t//前遍历序列（根左右），递归顺序非常类似于前序遍历\n\tif (tnode-&gt;leftChild == nullptr) //找空闲的指针域进行线索化\n\t{\n\t\ttnode-&gt;leftTag = 1; //线索\n\t\ttnode-&gt;leftChild = pre;&nbsp; //如果leftChild ==nullptr，说明该节点没有前趋节点\n\t}\n\t\t\n\t//这个前趋节点的后继节点肯定是当前这个节点tnode&nbsp;\n\tif (pre != nullptr &amp;&amp; pre-&gt;rightChild == nullptr)\n\t{\n\t\tpre-&gt;rightTag = 1; //线索\n\t\tpre-&gt;rightChild = tnode;\n\t}\n\tpre = tnode; //前趋节点指针指向当前节点\n\t\n\tif(tnode-&gt;leftTag == 0) //当leftChild是真正的子节点而不是线索化后的前趋节点时\n\t\tCreateThreadInBTreeAccordPO(tnode-&gt;leftChild, pre);\n\n\tif (tnode-&gt;rightTag == 0) //当rightChild是真正的子节点而不是线索化后的后继趋节点时\n\t\tCreateThreadInBTreeAccordPO(tnode-&gt;rightChild, pre);\n\t}\n</code></pre><p>前序遍历序列化线索二叉树代码与中序遍历序列线索化二叉树的代码有一些非常不同的地方。</p><p>因为前序遍历访问节点的顺序是“根、左、右”，所以在处理根的时候，很可能已经线索化了根节点的 leftChild 和 rightChild 指针。</p><p>那么我们在对左右子节点进行递归调用CreateThreadInBTreeAccordPO 时，就一定要判断这些子节点指针指向的是否为真正的子节点，而不是线索化后的前趋或者后继节点。否则就可能写出错误的实现代码导致程序执行产生异常。</p><p>main 主函数中，可以把下面的代码行：</p><pre><code class=\"language-plain\">mythreadtree.CreateThreadInBTreeAccordIO();\t\n</code></pre><p>修改为：</p><pre><code class=\"language-plain\">mythreadtree.CreateThreadInBTreeAccordPO();\n</code></pre><p>以根据前序遍历序列线索化二叉树，测试完成后记得修改回如下代码行以免对后序测试产生影响。</p><pre><code class=\"language-plain\">mythreadtree.CreateThreadInBTreeAccordIO();\n</code></pre><h2><strong>在线索二叉树上进行的操作</strong></h2><p>二叉树线索化之后，因为左右子节点指针保存的数据发生了改变，所以，许多针对原有二叉树进行操作的代码也必须做出相应的改变。</p><p>我们将通常会进行的操作分为4类：找第一个和最后一个节点，找某个节点的前趋和后继节点，对线索二叉树进行遍历，以及查找线索二叉树的节点。</p><h3>操作1：找线索二叉树的第一个和最后一个节点</h3><p>由于线索二叉树也分前序、中序和后序，因此找的第一个和最后一个节点肯定指的是相应顺序的节点。比如，如果线索二叉树是用中序遍历序列来线索化的，那么找的第一个和最后一个节点肯定指的是该二叉树进行中序遍历时的第一个和最后一个节点。</p><p>以中序遍历序列线索化的二叉树为例看看代码的书写，在 ThreadBinaryTree 类模板的定义中，增加GetFirst_IO()和GetLast_IO()成员函数(<a href=\"https://gitee.com/jianw_wang/geektime_cpp_dsa/blob/master/15%EF%BD%9C%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E5%A6%82%E4%BD%95%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BB%A5%E6%8F%90%E5%8D%87%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6%EF%BC%9F/MyProject.cpp\">参见课件</a>)即可。</p><h3>操作2：找线索二叉树中某个节点的前趋和后继节点</h3><p>以<strong>中序遍历</strong>序列线索化的二叉树为例看代码的书写，在 ThreadBinaryTree 类模板的定义中，可以增加GetNextPoint_IO()和GetPriorPoint_IO()成员函数(<a href=\"https://gitee.com/jianw_wang/geektime_cpp_dsa/blob/master/15%EF%BD%9C%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E5%A6%82%E4%BD%95%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BB%A5%E6%8F%90%E5%8D%87%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6%EF%BC%9F/MyProject.cpp\">参见课件</a>)。</p><p>至于<strong>前序遍历</strong>序列线索化的二叉树找前趋和后继节点，我们增加GetNextPoint_PO()和GetPriorPoint_PO()成员函数(<a href=\"https://gitee.com/jianw_wang/geektime_cpp_dsa/blob/master/15%EF%BD%9C%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E5%A6%82%E4%BD%95%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BB%A5%E6%8F%90%E5%8D%87%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6%EF%BC%9F/MyProject.cpp\">参见课件</a>)即可。</p><h3>操作3：对线索二叉树进行遍历</h3><p>要注意的是，传统二叉树遍历的相关代码<span class=\"reference\">（递归遍历）</span>并不适用于线索二叉树，因为递归遍历时只遍历真正的孩子节点。所以，我们要对这些遍历代码做出一定的修改。</p><p>先来看一下传统递归遍历的代码。</p><pre><code class=\"language-plain\">//传统中序递归遍历来遍历线索二叉树：\t\t\nvoid inOrder_Org()\n{\n\tinOrder_Org(root);\n}\nvoid inOrder_Org(BinaryTreeNode&lt;T&gt;* tNode)&nbsp; //中序遍历二叉树\n{\n\tif (tNode != nullptr) //若二叉树非空\n\t{\n\t\t//左根右顺序\n\t\tif(tNode-&gt;leftTag == 0) //是真正的左孩子\n\t\t\tinOrder_Org(tNode-&gt;leftChild);&nbsp; //递归方式中序遍历左子树\n\t\t\n\t\tcout &lt;&lt; (char)tNode-&gt;data &lt;&lt; \" \"; //输出节点的数据域的值\n\t\t\t\n\t\tif (tNode-&gt;rightTag == 0) //是真正的右孩子\n\t\t\tinOrder_Org(tNode-&gt;rightChild); //递归方式中序遍历右子树\n\t}\n\t}\n</code></pre><p>我们以中序遍历序列线索化的二叉树为例，所进行的遍历也要求是中序遍历。线索化后的二叉树的遍历方式与以往二叉树的遍历方式不同，必须要充分利用这些线索来增加遍历的效率。</p><p>具体的操作方式可以参考如下代码。</p><pre><code class=\"language-plain\">//中序遍历按照“中序遍历序列线索化的二叉树”线索二叉树\nvoid inOrder_IO()\n{\n\tinOrder_IO(root);\n}\nvoid inOrder_IO(BinaryTreeNode&lt;T&gt;* tNode)\n{\n\tBinaryTreeNode&lt;T&gt;* tmpNode = GetFirst_IO(tNode);\n\twhile (tmpNode != nullptr)&nbsp; //从第一个节点开始一直找后继即可\n\t{\n\t\tcout &lt;&lt; (char)tmpNode-&gt;data &lt;&lt; \" \"; //输出节点的数据域的值\n\t\ttmpNode = GetNextPoint_IO(tmpNode);\n\t}\n\t}\n</code></pre><p>思考一下，如果进行中序逆向遍历是不是也可以做到了呢？这就需要用到 GetLast_IO 和 GetPriorPoint_IO。参考如下代码。</p><pre><code class=\"language-plain\">//逆向中序遍历按照“中序遍历序列线索化的二叉树”线索二叉树\nvoid revInOrder_IO()\n{\n\trevInOrder_IO(root);\n}\nvoid revInOrder_IO(BinaryTreeNode&lt;T&gt;* tNode)\n{\n\tBinaryTreeNode&lt;T&gt;* tmpNode = GetLast_IO(tNode);\n\twhile (tmpNode != nullptr)&nbsp; //从第一个节点开始一直找后继即可\n\t{\n\t\tcout &lt;&lt; (char)tmpNode-&gt;data &lt;&lt; \" \"; //输出节点的数据域的值\n\t\ttmpNode = GetPriorPoint_IO(tmpNode);\n\t}\n\t}\n</code></pre><p>通过代码可以看到，只要能成功找到前趋和后继节点，进行遍历是一件很容易的事。你也可以在 main 主函数中加入如下代码进行测试。</p><pre><code class=\"language-plain\">mythreadtree.inOrder_Org(); //传统中序递归遍历\ncout &lt;&lt; endl;\t\nmythreadtree.inOrder_IO();\ncout &lt;&lt; endl;\nmythreadtree.revInOrder_IO();\ncout &lt;&lt; endl;\n</code></pre><h3>操作4：对线索二叉树的节点进行查找</h3><p>这里用中序遍历序列线索化的二叉树为例来讲解。参考如下代码。</p><pre><code class=\"language-plain\">//中序遍历序列线索化的二叉树查找某个节点(假设二叉树的节点各不相同)\nBinaryTreeNode&lt;T&gt;* SearchElem_IO(const T&amp; e)\n{\n\treturn SearchElem_IO(root, e);\n}\nBinaryTreeNode&lt;T&gt;* SearchElem_IO(BinaryTreeNode&lt;T&gt;* tNode, const T&amp; e)\n{\n\tif (tNode == nullptr)\n\t\treturn nullptr;\n\tif (tNode-&gt;data == e)&nbsp; //从根开始找\n\t\treturn tNode;\n\t\t\n\t//这里的代码取自于&nbsp; 中序遍历按照“中序遍历序列线索化的二叉树”线索二叉树inOrder_IO()的代码\n\tBinaryTreeNode&lt;T&gt;* tmpNode = GetFirst_IO(tNode);\n\twhile (tmpNode != nullptr)&nbsp; //从第一个节点开始一直找后继即可\n\t{\t\t\t\t\n\t\tif (tmpNode-&gt;data == e)\n\t\t\treturn tmpNode;\n\t\ttmpNode = GetNextPoint_IO(tmpNode);\n\t}\n\treturn nullptr;\n\t}\n</code></pre><p>可以在 main 主函数中加入下面的代码进行测试。</p><pre><code class=\"language-plain\">int val = 'B';\nBinaryTreeNode&lt;int&gt;* p = mythreadtree.SearchElem_IO(val);\nif (p != nullptr)\n{\n\tcout &lt;&lt; \"找到了值为\" &lt;&lt; (char)val &lt;&lt; \"的节点\" &lt;&lt; endl;\n\t\n\t//顺便找下后继和前趋节点\n\tBinaryTreeNode&lt;int&gt;* nx = mythreadtree.GetNextPoint_IO(p);\n\tif(nx != nullptr)\n\t\tcout &lt;&lt; \"后继节点值为\" &lt;&lt; (char)nx-&gt;data &lt;&lt; \"。\" &lt;&lt; endl;\n\t\t\n\tBinaryTreeNode&lt;int&gt;* pr = mythreadtree.GetPriorPoint_IO(p);\n\tif(pr != nullptr)\n\t\tcout &lt;&lt; \"前趋节点值为\" &lt;&lt; (char)pr-&gt;data &lt;&lt; \"。\" &lt;&lt; endl;\n\t\n}\nelse\n\tcout &lt;&lt; \"没找到值为\" &lt;&lt; (char)val &lt;&lt; \"的节点\" &lt;&lt; endl;\n</code></pre><p>执行结果为：<br>\n<img src=\"https://static001.geekbang.org/resource/image/95/96/95879a42c71db44906318167291a1896.png?wh=2450x338\" alt=\"\"></p><p>思考一下，对于“前序遍历序列线索化的二叉树”和“后序遍历序列线索化的二叉树”，能通过上述代码进行一定的改造来查找节点吗？</p><p>前序遍历序列线索化的二叉树是可以的。因为前序遍历序列线索化的二叉树的第一个节点就是根节点，而且可以通过 GetNextPoint_PO 成员函数不断找到后继节点。参考如下代码。</p><pre><code class=\"language-plain\">//前序遍历序列线索化的二叉树查找某个节点(假设二叉树的节点各不相同)\nBinaryTreeNode&lt;T&gt;* SearchElem_PO(const T&amp; e)\n{\n\treturn SearchElem_PO(root, e);\n}\nBinaryTreeNode&lt;T&gt;* SearchElem_PO(BinaryTreeNode&lt;T&gt;* tNode, const T&amp; e)\n{\n\tif (tNode == nullptr)\n\t\treturn nullptr;\t\t\t\n\t\n\tBinaryTreeNode&lt;T&gt;* tmpNode = root; //根就是第一个节点\n\twhile (tmpNode != nullptr)&nbsp; //从第一个节点开始一直找后继即可\n\t{\n\t\tif (tmpNode-&gt;data == e)\n\t\t\treturn tmpNode;\n\t\ttmpNode = GetNextPoint_PO(tmpNode);\n\t}\n\treturn nullptr;\n}\n</code></pre><p>后序遍历序列线索化的二叉树也是可以的，虽然这种二叉树找后继节点不行，但是找前趋节点是可以的，通过GetPriorPoint_POSTO成员函数，而且，最后一个节点就是根节点。从最后一个节点向前找即可。参考下面的代码。</p><pre><code class=\"language-plain\">//后序遍历序列线索化的二叉树查找某个节点(假设二叉树的节点各不相同)\nBinaryTreeNode&lt;T&gt;* SearchElem_POSTO(const T&amp; e)\n{\n\treturn SearchElem_POSTO(root, e);\n}\nBinaryTreeNode&lt;T&gt;* SearchElem_POSTO(BinaryTreeNode&lt;T&gt;* tNode, const T&amp; e)\n{\n\tif (tNode == nullptr)\n\t\treturn nullptr;\n\t\n\tBinaryTreeNode&lt;T&gt;* tmpNode = root; //根就是最后一个节点\n\twhile (tmpNode != nullptr)&nbsp; //从最后一个节点开始一直找前趋即可\n\t{\n\t\tif (tmpNode-&gt;data == e)\n\t\t\treturn tmpNode;\n\t\ttmpNode = GetPriorPoint_POSTO(tmpNode);\n\t}\n\treturn nullptr;\n\t}\n</code></pre><h2><strong>小结</strong></h2><p>这节课，我讲解了线索二叉树的相关内容，包括线索二叉树的基本概念、二叉树的线索化、线索二叉树的操作3个子话题。</p><p>线索二叉树存在的意义，就是充分利用线索，尽量简化二叉树的操作，更方便地找一个节点的前趋和后继节点，从而为更快捷地遍历整个二叉树创造条件。</p><p>线索二叉树，其实就是加上了线索的二叉树，而线索，也就是指向前趋或后继节点的指针。</p><p>我们可以通过给没有被使用到的二叉树节点的指针域，保存这个节点的前趋或后继节点的指针信息，实现二叉树的线索化。</p><p>在线索化二叉树的过程中，首先要注意的是必须是空闲的指针域才能被线索化，在线索化的过程中，不但要标记该指针域是被线索化过的，还要确保该指针域正确地指向其前趋或后继节点。</p><p>最后提醒一下，这节课我们所有实现的代码都以能够理解为主，无需死记硬背。</p><h2><strong>归纳思考</strong></h2><ol>\n<li>\n<p>前面通过代码已经实现了用<strong>中序</strong>遍历序列线索化二叉树和用<strong>前序</strong>遍历序列线索化二叉树。你是否可以仿照前面的代码自己试着写一下如何用<strong>后序</strong>遍历序列线索化二叉树呢？</p>\n</li>\n<li>\n<p>参考前面的代码，尝试写出代码完成对<strong>后序</strong>遍历序列线索化的二叉树找前趋和后继节点。</p>\n</li>\n<li>\n<p>参考前面的代码，对“前序遍历序列线索化的二叉树”进行前序遍历，对“后序遍历序列线索化的二叉树”进行后序遍历，看是否能做到。</p>\n</li>\n</ol><p>这里给予一些提示：</p><ul>\n<li>对“前序遍历序列线索化的二叉树”，因为找当前节点的后继节点是没问题的，所以对这种二叉树进行前序遍历是可以的。但因为找当前节点的前趋节点是无法做到的，因此进行前序逆向遍历是不行的。</li>\n<li>对“后序遍历序列线索化的二叉树”，因为找当前节点的前趋节点是没问题的，所以对这种二叉树进行逆向后序遍历是可以的。但因为找当前节点的后继节点是无法做到的，因此进行后序遍历是不行的。</li>\n</ul><p>欢迎留言与我分享你的问题，我会尽我所能尽快反馈。如果你觉得有所收获，也欢迎你分享给同事或者朋友，我们一起进步。</p>","comments":[{"had_liked":false,"id":387321,"user_name":"阿阳","can_delete":false,"product_type":"c1","uid":1165817,"ip_address":"江苏","ucode":"20A35FB86B1C5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/c9/f9/39492855.jpg","comment_is_top":false,"comment_ctime":1706970422,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100524201,"comment_content":"老师好，文章结尾有这样的提示：\n对“前序遍历序列线索化的二叉树”，但因为找当前节点的前趋节点是无法做到的，因此进行前序逆向遍历是不行的。\n为啥不能找到当前结点的前驱结点？我看源码上有GetPriorPoint_PO()方法，用来找前驱结点的。代码是作为作业完成的。前面的“操作 2：找线索二叉树中某个节点的前趋和后继节点”这一小节，还明确说了能实现这种方法。\n请问老师，这种应该如何理解？","like_count":0},{"had_liked":false,"id":387320,"user_name":"阿阳","can_delete":false,"product_type":"c1","uid":1165817,"ip_address":"江苏","ucode":"20A35FB86B1C5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/c9/f9/39492855.jpg","comment_is_top":false,"comment_ctime":1706969860,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100524201,"comment_content":"中序遍历线索化的二叉树，遍历的实现思路是，找到第一个结点、最后一个结点，在这两个操作的基础上，才能找到当前结点的后继结点和前驱结点，通过不断地向前或者向后，实现正向中序遍历和逆向中序遍历。能想出这种数据结构的科学家，真是让人叹为观止。\n看到后面才知道，前续遍历线索化二叉树和后续遍历线索化二叉树，都有其局限性。\n这一节课信息量太大了，看了两天，对树的递归遍历理解加深了许多。","like_count":0}]}