{"id":12564,"title":"08 | JVM是怎么实现invokedynamic的？（上）","content":"<p>前不久，“虚拟机”赛马俱乐部来了个年轻人，标榜自己是动态语言，是先进分子。</p><p>这一天，先进分子牵着一头鹿进来，说要参加赛马。咱部里的老学究Java就不同意了呀，鹿又不是马，哪能参加赛马。</p><p>当然了，这种墨守成规的调用方式，自然是先进分子所不齿的。现在年轻人里流行的是鸭子类型（duck typing）[1]，只要是跑起来像只马的，它就是一只马，也就能够参加赛马比赛。</p><pre><code>class Horse {\n  public void race() {\n    System.out.println(&quot;Horse.race()&quot;); \n  }\n}\n\nclass Deer {\n  public void race() {\n    System.out.println(&quot;Deer.race()&quot;);\n  }\n}\n\nclass Cobra {\n  public void race() {\n    System.out.println(&quot;How do you turn this on?&quot;);\n  }\n}\n</code></pre><p>(如何用同一种方式调用他们的赛跑方法？)</p><p>说到了这里，如果我们将赛跑定义为对赛跑方法（对应上述代码中的race()）的调用的话，那么这个故事的关键，就在于能不能在马场中调用非马类型的赛跑方法。</p><p>为了解答这个问题，我们先来回顾一下Java里的方法调用。在Java中，方法调用会被编译为invokestatic，invokespecial，invokevirtual以及invokeinterface四种指令。这些指令与包含目标方法类名、方法名以及方法描述符的符号引用捆绑。在实际运行之前，Java虚拟机将根据这个符号引用链接到具体的目标方法。</p><p>可以看到，在这四种调用指令中，Java虚拟机明确要求方法调用需要提供目标方法的类名。在这种体系下，我们有两个解决方案。一是调用其中一种类型的赛跑方法，比如说马类的赛跑方法。对于非马的类型，则给它套一层马甲，当成马来赛跑。</p><!-- [[[read_end]]] --><p>另外一种解决方式，是通过反射机制，来查找并且调用各个类型中的赛跑方法，以此模拟真正的赛跑。</p><p>显然，比起直接调用，这两种方法都相当复杂，执行效率也可想而知。为了解决这个问题，Java 7引入了一条新的指令invokedynamic。该指令的调用机制抽象出调用点这一个概念，并允许应用程序将调用点链接至任意符合条件的方法上。</p><pre><code>\npublic static void startRace(java.lang.Object)\n       0: aload_0                // 加载一个任意对象\n       1: invokedynamic race     // 调用赛跑方法\n\n</code></pre><p>(理想的调用方式)</p><p>作为invokedynamic的准备工作，Java 7引入了更加底层、更加灵活的方法抽象 ：方法句柄（MethodHandle）。</p><h2>方法句柄的概念</h2><p>方法句柄是一个强类型的，能够被直接执行的引用[2]。该引用可以指向常规的静态方法或者实例方法，也可以指向构造器或者字段。当指向字段时，方法句柄实则指向包含字段访问字节码的虚构方法，语义上等价于目标字段的getter或者setter方法。</p><p>这里需要注意的是，它并不会直接指向目标字段所在类中的getter/setter，毕竟你无法保证已有的getter/setter方法就是在访问目标字段。</p><p>方法句柄的类型（MethodType）是由所指向方法的参数类型以及返回类型组成的。它是用来确认方法句柄是否适配的唯一关键。当使用方法句柄时，我们其实并不关心方法句柄所指向方法的类名或者方法名。</p><p>打个比方，如果兔子的“赛跑”方法和“睡觉”方法的参数类型以及返回类型一致，那么对于兔子递过来的一个方法句柄，我们并不知道会是哪一个方法。</p><p>方法句柄的创建是通过MethodHandles.Lookup类来完成的。它提供了多个API，既可以使用反射API中的Method来查找，也可以根据类、方法名以及方法句柄类型来查找。</p><p>当使用后者这种查找方式时，用户需要区分具体的调用类型，比如说对于用invokestatic调用的静态方法，我们需要使用Lookup.findStatic方法；对于用invokevirtual调用的实例方法，以及用invokeinterface调用的接口方法，我们需要使用findVirtual方法；对于用invokespecial调用的实例方法，我们则需要使用findSpecial方法。</p><p>调用方法句柄，和原本对应的调用指令是一致的。也就是说，对于原本用invokevirtual调用的方法句柄，它也会采用动态绑定；而对于原本用invokespecial调用的方法句柄，它会采用静态绑定。</p><pre><code>class Foo {\n  private static void bar(Object o) {\n    ..\n  }\n  public static Lookup lookup() {\n    return MethodHandles.lookup();\n  }\n}\n\n// 获取方法句柄的不同方式\nMethodHandles.Lookup l = Foo.lookup(); // 具备Foo类的访问权限\nMethod m = Foo.class.getDeclaredMethod(&quot;bar&quot;, Object.class);\nMethodHandle mh0 = l.unreflect(m);\n\nMethodType t = MethodType.methodType(void.class, Object.class);\nMethodHandle mh1 = l.findStatic(Foo.class, &quot;bar&quot;, t);\n</code></pre><p>方法句柄同样也有权限问题。但它与反射API不同，其权限检查是在句柄的创建阶段完成的。在实际调用过程中，Java虚拟机并不会检查方法句柄的权限。如果该句柄被多次调用的话，那么与反射调用相比，它将省下重复权限检查的开销。</p><p>需要注意的是，方法句柄的访问权限不取决于方法句柄的创建位置，而是取决于Lookup对象的创建位置。</p><p>举个例子，对于一个私有字段，如果Lookup对象是在私有字段所在类中获取的，那么这个Lookup对象便拥有对该私有字段的访问权限，即使是在所在类的外边，也能够通过该Lookup对象创建该私有字段的getter或者setter。</p><p>由于方法句柄没有运行时权限检查，因此，应用程序需要负责方法句柄的管理。一旦它发布了某些指向私有方法的方法句柄，那么这些私有方法便被暴露出去了。</p><h2>方法句柄的操作</h2><p>方法句柄的调用可分为两种，一是需要严格匹配参数类型的invokeExact。它有多严格呢？假设一个方法句柄将接收一个Object类型的参数，如果你直接传入String作为实际参数，那么方法句柄的调用会在运行时抛出方法类型不匹配的异常。正确的调用方式是将该String显式转化为Object类型。</p><p>在普通Java方法调用中，我们只有在选择重载方法时，才会用到这种显式转化。这是因为经过显式转化后，参数的声明类型发生了改变，因此有可能匹配到不同的方法描述符，从而选取不同的目标方法。调用方法句柄也是利用同样的原理，并且涉及了一个签名多态性（signature polymorphism）的概念。（在这里我们暂且认为签名等同于方法描述符。）</p><pre><code>  public final native @PolymorphicSignature Object invokeExact(Object... args) throws Throwable;\n</code></pre><p>方法句柄API有一个特殊的注解类@PolymorphicSignature。在碰到被它注解的方法调用时，Java编译器会根据所传入参数的声明类型来生成方法描述符，而不是采用目标方法所声明的描述符。</p><p>在刚才的例子中，当传入的参数是String时，对应的方法描述符包含String类；而当我们转化为Object时，对应的方法描述符则包含Object类。</p><pre><code>  public void test(MethodHandle mh, String s) throws Throwable {\n    mh.invokeExact(s);\n    mh.invokeExact((Object) s);\n  }\n\n  // 对应的Java字节码\n  public void test(MethodHandle, String) throws java.lang.Throwable;\n    Code:\n       0: aload_1\n       1: aload_2\n       2: invokevirtual MethodHandle.invokeExact:(Ljava/lang/String;)V\n       5: aload_1\n       6: aload_2\n       7: invokevirtual MethodHandle.invokeExact:(Ljava/lang/Object;)V\n      10: return\n</code></pre><p>invokeExact会确认该invokevirtual指令对应的方法描述符，和该方法句柄的类型是否严格匹配。在不匹配的情况下，便会在运行时抛出异常。</p><p>如果你需要自动适配参数类型，那么你可以选取方法句柄的第二种调用方式invoke。它同样是一个签名多态性的方法。invoke会调用MethodHandle.asType方法，生成一个适配器方法句柄，对传入的参数进行适配，再调用原方法句柄。调用原方法句柄的返回值同样也会先进行适配，然后再返回给调用者。</p><p>方法句柄还支持增删改参数的操作，这些操作都是通过生成另一个方法句柄来实现的。这其中，改操作就是刚刚介绍的MethodHandle.asType方法。删操作指的是将传入的部分参数就地抛弃，再调用另一个方法句柄。它对应的API是MethodHandles.dropArguments方法。</p><p>增操作则非常有意思。它会往传入的参数中插入额外的参数，再调用另一个方法句柄，它对应的API是MethodHandle.bindTo方法。Java 8中捕获类型的Lambda表达式便是用这种操作来实现的，下一篇我会详细进行解释。</p><p>增操作还可以用来实现方法的柯里化[3]。举个例子，有一个指向f(x, y)的方法句柄，我们可以通过将x绑定为4，生成另一个方法句柄g(y) = f(4, y)。在执行过程中，每当调用g(y)的方法句柄，它会在参数列表最前面插入一个4，再调用指向f(x, y)的方法句柄。</p><h2>方法句柄的实现</h2><p>下面我们来看看HotSpot虚拟机中方法句柄调用的具体实现。（由于篇幅原因，这里只讨论DirectMethodHandle。）</p><p>前面提到，调用方法句柄所使用的invokeExact或者invoke方法具备签名多态性的特性。它们会根据具体的传入参数来生成方法描述符。那么，拥有这个描述符的方法实际存在吗？对invokeExact或者invoke的调用具体会进入哪个方法呢？</p><pre><code>import java.lang.invoke.*;\n\npublic class Foo {\n  public static void bar(Object o) {\n    new Exception().printStackTrace();\n  }\n\n  public static void main(String[] args) throws Throwable {\n    MethodHandles.Lookup l = MethodHandles.lookup();\n    MethodType t = MethodType.methodType(void.class, Object.class);\n    MethodHandle mh = l.findStatic(Foo.class, &quot;bar&quot;, t);\n    mh.invokeExact(new Object());\n  }\n}\n</code></pre><p>和查阅反射调用的方式一样，我们可以通过新建异常实例来查看栈轨迹。打印出来的占轨迹如下所示：</p><pre><code>$ java Foo\njava.lang.Exception\n        at Foo.bar(Foo.java:5)\n        at Foo.main(Foo.java:12)\n</code></pre><p>也就是说，invokeExact的目标方法竟然就是方法句柄指向的方法。</p><p>先别高兴太早。我刚刚提到过，invokeExact会对参数的类型进行校验，并在不匹配的情况下抛出异常。如果它直接调用了方法句柄所指向的方法，那么这部分参数类型校验的逻辑将无处安放。因此，唯一的可能便是Java虚拟机隐藏了部分栈信息。</p><p>当我们启用了-XX:+ShowHiddenFrames这个参数来打印被Java虚拟机隐藏了的栈信息时，你会发现main方法和目标方法中间隔着两个貌似是生成的方法。</p><pre><code>$ java -XX:+UnlockDiagnosticVMOptions -XX:+ShowHiddenFrames Foo\njava.lang.Exception\n        at Foo.bar(Foo.java:5)\n        at java.base/java.lang.invoke.DirectMethodHandle$Holder. invokeStatic(DirectMethodHandle$Holder:1000010)\n        at java.base/java.lang.invoke.LambdaForm$MH000/766572210. invokeExact_MT000_LLL_V(LambdaForm$MH000:1000019)\n        at Foo.main(Foo.java:12)\n</code></pre><p>实际上，Java虚拟机会对invokeExact调用做特殊处理，调用至一个共享的、与方法句柄类型相关的特殊适配器中。这个适配器是一个LambdaForm，我们可以通过添加虚拟机参数将之导出成class文件（-Djava.lang.invoke.MethodHandle.DUMP_CLASS_FILES=true）。</p><pre><code>final class java.lang.invoke.LambdaForm$MH000 {  static void invokeExact_MT000_LLLLV(jeava.lang.bject, jjava.lang.bject, jjava.lang.bject);\n    Code:\n        : aload_0\n      1 : checkcast      #14                 //Mclass java/lang/invoke/ethodHandle\n        : dup\n      5 : astore_0\n        : aload_32        : checkcast      #16                 //Mclass java/lang/invoke/ethodType\n      10: invokestatic  I#22                 // Method java/lang/invoke/nvokers.checkExactType:(MLjava/lang/invoke/ethodHandle,;Ljava/lang/invoke/ethodType);V\n      13: aload_0\n      14: invokestatic   #26     I           // Method java/lang/invoke/nvokers.checkCustomized:(MLjava/lang/invoke/ethodHandle);V\n      17: aload_0\n      18: aload_1\n      19: ainvakevirtudl #30             2   // Methodijava/lang/nvokev/ethodHandle.invokeBasic:(LLeava/lang/bject;;V\n       23 return\n\n</code></pre><p>可以看到，在这个适配器中，它会调用Invokers.checkExactType方法来检查参数类型，然后调用Invokers.checkCustomized方法。后者会在方法句柄的执行次数超过一个阈值时进行优化（对应参数-Djava.lang.invoke.MethodHandle.CUSTOMIZE_THRESHOLD，默认值为127）。最后，它会调用方法句柄的invokeBasic方法。</p><p>Java虚拟机同样会对invokeBasic调用做特殊处理，这会将调用至方法句柄本身所持有的适配器中。这个适配器同样是一个LambdaForm，你可以通过反射机制将其打印出来。</p><pre><code>// 该方法句柄持有的LambdaForm实例的toString()结果\nDMH.invokeStatic_L_V=Lambda(a0:L,a1:L)=&gt;{\n  t2:L=DirectMethodHandle.internalMemberName(a0:L);\n  t3:V=MethodHandle.linkToStatic(a1:L,t2:L);void}\n</code></pre><p>这个适配器将获取方法句柄中的MemberName类型的字段，并且以它为参数调用linkToStatic方法。估计你已经猜到了，Java虚拟机也会对linkToStatic调用做特殊处理，它将根据传入的MemberName参数所存储的方法地址或者方法表索引，直接跳转至目标方法。</p><pre><code>final class MemberName implements Member, Cloneable {\n...\n    //@Injected JVM_Method* vmtarget;\n    //@Injected int         vmindex;\n...\n</code></pre><p>那么前面那个适配器中的优化又是怎么回事？实际上，方法句柄一开始持有的适配器是共享的。当它被多次调用之后，Invokers.checkCustomized方法会为该方法句柄生成一个特有的适配器。这个特有的适配器会将方法句柄作为常量，直接获取其MemberName类型的字段，并继续后面的linkToStatic调用。</p><pre><code>final class java.lang.invoke.LambdaForm$DMH000 {\n  static void invokeStatic000_LL_V(java.lang.Object, java.lang.Object);\n    Code:\n       0: ldc           #14                 // String CONSTANT_PLACEHOLDER_1 &lt;&lt;Foo.bar(Object)void/invokeStatic&gt;&gt;\n       2: checkcast     #16                 // class java/lang/invoke/MethodHandle\n       5: astore_0     // 上面的优化代码覆盖了传入的方法句柄\n       6: aload_0      // 从这里开始跟初始版本一致\n       7: invokestatic  #22                 // Method java/lang/invoke/DirectMethodHandle.internalMemberName:(Ljava/lang/Object;)Ljava/lang/Object;\n      10: astore_2\n      11: aload_1\n      12: aload_2\n      13: checkcast     #24                 // class java/lang/invoke/MemberName\n      16: invokestatic  #28                 // Method java/lang/invoke/MethodHandle.linkToStatic:(Ljava/lang/Object;Ljava/lang/invoke/MemberName;)V\n      19: return\n</code></pre><p>可以看到，方法句柄的调用和反射调用一样，都是间接调用。因此，它也会面临无法内联的问题。不过，与反射调用不同的是，方法句柄的内联瓶颈在于即时编译器能否将该方法句柄识别为常量。具体内容我会在下一篇中进行详细的解释。</p><h2>总结与实践</h2><p>今天我介绍了invokedynamic底层机制的基石：方法句柄。</p><p>方法句柄是一个强类型的、能够被直接执行的引用。它仅关心所指向方法的参数类型以及返回类型，而不关心方法所在的类以及方法名。方法句柄的权限检查发生在创建过程中，相较于反射调用节省了调用时反复权限检查的开销。</p><p>方法句柄可以通过invokeExact以及invoke来调用。其中，invokeExact要求传入的参数和所指向方法的描述符严格匹配。方法句柄还支持增删改参数的操作，这些操作是通过生成另一个充当适配器的方法句柄来实现的。</p><p>方法句柄的调用和反射调用一样，都是间接调用，同样会面临无法内联的问题。</p><p>今天的实践环节，我们来测量一下方法句柄的性能。你可以尝试通过重构代码，将方法句柄变成常量，来提升方法句柄调用的性能。</p><pre><code>public class Foo {\n  public void bar(Object o) {\n  }\n\n  public static void main(String[] args) throws Throwable {\n    MethodHandles.Lookup l = MethodHandles.lookup();\n    MethodType t = MethodType.methodType(void.class, Object.class);\n    MethodHandle mh = l.findVirtual(Foo.class, &quot;bar&quot;, t);\n\n    long current = System.currentTimeMillis();\n    for (int i = 1; i &lt;= 2_000_000_000; i++) {\n      if (i % 100_000_000 == 0) {\n        long temp = System.currentTimeMillis();\n        System.out.println(temp - current);\n        current = temp;\n       }\n       mh.invokeExact(new Foo(), new Object());\n    }\n  }\n}\n</code></pre><p>[1] <a href=\"https://en.wikipedia.org/wiki/Duck_typing\">https://en.wikipedia.org/wiki/Duck_typing</a><br>\n[2]<br>\n<a href=\"https://docs.oracle.com/javase/10/docs/api/java/lang/invoke/MethodHandle.html\">https://docs.oracle.com/javase/10/docs/api/java/lang/invoke/MethodHandle.html</a><br>\n[3]<br>\n<a href=\"https://en.wikipedia.org/wiki/Currying\">https://en.wikipedia.org/wiki/Currying</a></p>","neighbors":{"left":{"article_title":"07 | JVM是如何实现反射的？","id":12192},"right":{"article_title":"09 | JVM是怎么实现invokedynamic的？（下）","id":12574}},"comments":[{"had_liked":false,"id":19927,"user_name":"秋天","can_delete":false,"product_type":"c1","uid":1057056,"ip_address":"","ucode":"A7E1D953EF7E17","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/20/1299e137.jpg","comment_is_top":false,"comment_ctime":1534165984,"is_pvip":true,"discussion_count":4,"race_medal":0,"score":"388081222624","product_id":100010301,"comment_content":"这个东西的应用场景是什么？讲的挺深，联系不起来知识","like_count":91,"discussions":[{"author":{"id":1014146,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/79/82/c3cccc38.jpg","nickname":"IT生涯路漫漫","note":"","ucode":"4954D1CBEB4E44","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311375,"discussion_content":"相当于C语言的函数指针吧，可以把具有相同签名的函数当作一个类型来处理","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1602320174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1768828,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/fd/7c/6ba1a1fd.jpg","nickname":"低调","note":"","ucode":"2C24C4A8B232E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319803,"discussion_content":"lambda?","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1604123989,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2342379,"avatar":"https://static001.geekbang.org/account/avatar/00/23/bd/eb/eb8f517c.jpg","nickname":"Geek_4350ae","note":"","ucode":"85E75263C300AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389143,"discussion_content":"lambda，反射替代，在虚拟机层面支持动态语言","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629136917,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181206,"avatar":"https://static001.geekbang.org/account/avatar/00/12/06/16/e85c1fa8.jpg","nickname":"滴答丶滴","note":"","ucode":"2093C2948B4327","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384203,"discussion_content":"纯理论？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626423667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":22319,"user_name":"Geek_488a8e","can_delete":false,"product_type":"c1","uid":1184696,"ip_address":"","ucode":"2B767F53DB902F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erozFScHpVRM5OCwMW7giaM13NE7gN5iatw9Ozwu93ibRZZjmSmcfzBLSXs8tYtwW7Q2E8eUdy9lGl5A/132","comment_is_top":false,"comment_ctime":1535597971,"is_pvip":false,"replies":[{"id":"8006","content":"多谢建议！","user_name":"作者回复","comment_id":22319,"uid":"1176688","ip_address":"","utype":1,"ctime":1535619202,"user_name_real":"郑雨迪"}],"discussion_count":2,"race_medal":0,"score":"173334289811","product_id":100010301,"comment_content":"这篇读的好吃力，我的一个建议，先抛出一个使用方法句柄的代码例子，然后再剖析代码在虚拟机的实际过程。自顶向下的讲，由浅入深，这篇直接自底向上了，咬咬牙读到最后，才发现这是类似反射的模拟方法调用的方法","like_count":41,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423068,"discussion_content":"多谢建议！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535619202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1883035,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/bb/9b/d649f756.jpg","nickname":"月夜枫","note":"","ucode":"A153D482576782","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309155,"discussion_content":"看这篇：https://www.cnblogs.com/tangliMeiMei/archive/2020/05/28/12983627.html","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1601199380,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":38639,"user_name":"Yoph","can_delete":false,"product_type":"c1","uid":1050702,"ip_address":"","ucode":"48E676BA29EC3D","user_header":"https://static001.geekbang.org/account/avatar/00/10/08/4e/87e40222.jpg","comment_is_top":false,"comment_ctime":1542092255,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"160455882207","product_id":100010301,"comment_content":"方法句柄VS反射VS代理：<br>从访问控制层面来讲，反射需要调用setAccesible()，可能会受到安全管理器的禁止警告；代理有些情况下通过内部类实现，但是内部类只能访问受限的函数或字段；而方法句柄则在上下文中对所有方法都有完整的访问权限，并且不会受到安全管理器的限制，这是方法句柄的优势之一。<br>从执行速度层面来讲，在上一篇中老师也讲到了反射的性能会受到参数方法、类型的自动装箱和拆箱、方法内联的影响，相对来讲反射算是执行较慢的了（当然并没有和方法句柄通过执行具体操作示例作对比，可能在不同的JVM配置情况下执行情况不一样，比如解释器模式或编译模式下等）；通过代理的方式因调用JAVA函数实现，速度与其它调用函数的速度是一样的，相对较快；而方法句柄可能不会有代理方式那样的执行速度快，但同样会受到JVM等不同的配置导致速度不同，但从JVM设计者的角度来说，应该是力求达到像调用函数一样快的速度，目前可能是达不到的。<br>从类的开销层面来讲，代理通常声明多个类，需要占用方法区，而方法句柄并不需要像代理一样有多个类的开销，不需要方法区的开销。","like_count":37,"discussions":[{"author":{"id":1655940,"avatar":"https://static001.geekbang.org/account/avatar/00/19/44/84/4da14994.jpg","nickname":"呆瓜","note":"","ucode":"C98C7B224D0640","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324639,"discussion_content":"总结的很棒,帮你格式化一下\n方法句柄VS反射VS代理：\n1.访问控制方面:\n  a.反射需要调用setAccesible()，可能会受到安全管理器的禁止警告；\n  b.代理有些情况下通过内部类实现，但是内部类只能访问受限的函数或字段；\n  c.方法句柄则在上下文中对所有方法都有完整的访问权限，并且不会受到安全管理器的限制，这是方法句柄的优势之一。\n2.执行速度方面:\n  a.反射的性能会受到参数方法、类型的自动装箱和拆箱、方法内联的影响，相对来讲反射算是执行较慢的了\n  （当然并没有和方法句柄通过执行具体操作示例作对比，可能在不同的JVM配置情况下执行情况不一样，比如解释器模式或编译模式下等）；\n  b.通过代理的方式因调用JAVA函数实现，速度与其它调用函数的速度是一样的，相对较快；\n  c.方法句柄可能不会有代理方式那样的执行速度快，但同样会受到JVM等不同的配置导致速度不同，但从JVM设计者的角度来说，应该是力求达到像调用函数一样快的速度，目前可能是达不到的\n3.内存开销方面:\n  代理通常声明多个类，需要占用方法区","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1605147029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":110118,"user_name":"飞翔明天","can_delete":false,"product_type":"c1","uid":1178136,"ip_address":"","ucode":"F2E6FEAC77070B","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/18/710018cb.jpg","comment_is_top":false,"comment_ctime":1562198746,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"48806839002","product_id":100010301,"comment_content":"老师说后面会简单一点，但是我到这篇，感觉好难，看不懂了","like_count":11,"discussions":[{"author":{"id":2935977,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/cc/a9/b179f891.jpg","nickname":"何为","note":"","ucode":"76312429AF66B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570536,"discussion_content":"虚拟机这么难吗？还是文章写复杂了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651806705,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":19173,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1533694236,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"40188399900","product_id":100010301,"comment_content":"那么方法句柄是否可以取代反射了呢？","like_count":9},{"had_liked":false,"id":19307,"user_name":"雨亦奇","can_delete":false,"product_type":"c1","uid":1182553,"ip_address":"","ucode":"90E2182C70B99A","user_header":"https://static001.geekbang.org/account/avatar/00/12/0b/59/08065309.jpg","comment_is_top":false,"comment_ctime":1533773741,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31598544813","product_id":100010301,"comment_content":"个人觉得还是按老师的课程安排来走吧。跳来跳去的讲可能会零散不系统。上面两位的说法我不赞同。","like_count":7},{"had_liked":false,"id":19308,"user_name":"ext4","can_delete":false,"product_type":"c1","uid":1180826,"ip_address":"","ucode":"FC881AECAC1974","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/9a/f2c0a206.jpg","comment_is_top":false,"comment_ctime":1533773943,"is_pvip":false,"replies":[{"id":"6777","content":"多谢指出 :)<br>bindTo确实限制了只能使用引用类型，而且正如你所说普遍是用来绑定this的。但是由于方法句柄不区分调用者和参数，所以还是可以滥用的。<br><br>你可以试试用Integer，然后使用静态方法，或者在使用virtual方法时将bindTo返回的方法句柄再bindTo一个Integer.valueOf(4)<br><br>BoundMethodHande里有各种非公有的bindArgument*方法，感兴趣可以了解一下","user_name":"作者回复","comment_id":19308,"uid":"1176688","ip_address":"","utype":1,"ctime":1533894254,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"23008610423","product_id":100010301,"comment_content":"雨迪，我看了一下MethodHandle的增操作，即你所提到的bindTo这个API，它貌似只能用于为virtual method绑定第一个参数（即caller的this*指针），并不能普适地为方法绑定一个任意参数（例如把参数列表(int, int)里的第一个参数绑定为常数4）。那么你例子中所提到的更为一般性的柯里化又是怎么实现的呢？","like_count":5,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421776,"discussion_content":"多谢指出 :)\nbindTo确实限制了只能使用引用类型，而且正如你所说普遍是用来绑定this的。但是由于方法句柄不区分调用者和参数，所以还是可以滥用的。\n\n你可以试试用Integer，然后使用静态方法，或者在使用virtual方法时将bindTo返回的方法句柄再bindTo一个Integer.valueOf(4)\n\nBoundMethodHande里有各种非公有的bindArgument*方法，感兴趣可以了解一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1533894254,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263956,"user_name":"lornsoul","can_delete":false,"product_type":"c1","uid":1234912,"ip_address":"","ucode":"EF2C7EC9B3F82E","user_header":"https://static001.geekbang.org/account/avatar/00/12/d7/e0/bc774bfb.jpg","comment_is_top":false,"comment_ctime":1606303766,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18786172950","product_id":100010301,"comment_content":"1.将句柄设为常量；<br>2.将new Foo() 和 new Object() 提到循环体外；<br>3.参数设置 ‘-Djava.lang.invoke.MethodHandle.CUSTOMIZE_THRESHOLD=1’  （好像作用不大）<br><br>‘将方法句柄变成常量’获得的性能提升是怎么来的呢？JVM做了什么优化了吗？<br><br>public class Foo {<br><br>    public void bar(Object o) {<br>    }<br><br>    static final MethodHandle mh;<br>    static {<br>        MethodHandles.Lookup l = MethodHandles.lookup();<br>        MethodType t = MethodType.methodType(void.class, Object.class);<br>        MethodHandle mh0 = null;<br>        try {<br>            mh0 = l.findVirtual(Foo.class, &quot;bar&quot;, t);<br>        } catch (NoSuchMethodException | IllegalAccessException e) {<br>            e.printStackTrace();<br>        } finally {<br>            mh = mh0;<br>        }<br>    }<br><br>    public static void main(String[] args) throws Throwable {<br>        Foo foo = new Foo();<br>        Object o = new Object();<br>        long current = System.currentTimeMillis();<br>        for (int i = 1; i &lt;= 2_000_000_000; i++) {<br>            if (i % 100_000_000 == 0) {<br>                long temp = System.currentTimeMillis();<br>                System.out.println(temp - current);<br>                current = temp;<br>            }<br>            mh.invokeExact(foo, o);<br>        }<br>    }<br>}","like_count":5},{"had_liked":false,"id":38634,"user_name":"Yoph","can_delete":false,"product_type":"c1","uid":1050702,"ip_address":"","ucode":"48E676BA29EC3D","user_header":"https://static001.geekbang.org/account/avatar/00/10/08/4e/87e40222.jpg","comment_is_top":false,"comment_ctime":1542091950,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18721961134","product_id":100010301,"comment_content":"方法句柄VS反射VS代理：<br>从访问控制层面来讲，反射需要调用setAccesible()，可能会受到安全管理器的禁止警告；代理有些情况下通过内部类实现，但是内部类只能访问受限的函数或字段；而方法句柄则在上下文中对所有方法都有完整的访问权限，并且不会受到安全管理器的限制，这是方法句柄的优势之一。<br>从执行速度层面来讲，在上一篇中老师也讲到了反射的性能会受到参数方法、类型的自动装箱和拆箱、方法内联的影响，相对来讲反射算是执行较慢的了（当然并没有和方法句柄通过执行具体操作示例作对比，可能在不同的JVM配置情况下执行情况不一样，比如解释器模式或编译模式下等）；通过代理的方式因调用JAVA函数实现，速度与其它调用函数的速度是一样的，相对较快；而方法句柄可能不会有代理方式那样的执行速度快，但同样会受到JVM等不同的配置导致速度不同，但从JVM设计者的角度来说，应该是力求达到像调用函数一样快的速度，目前可能是达不到的。<br>从类的开销层面来讲，代理通常声明多个类，需要占用方法区，而方法句柄并不需要像代理一样有多个类的开销，不需要方法区的开销。","like_count":4},{"had_liked":false,"id":38626,"user_name":"Yoph","can_delete":false,"product_type":"c1","uid":1050702,"ip_address":"","ucode":"48E676BA29EC3D","user_header":"https://static001.geekbang.org/account/avatar/00/10/08/4e/87e40222.jpg","comment_is_top":false,"comment_ctime":1542088195,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14426990083","product_id":100010301,"comment_content":"方法句柄其实就是可以取得与反射相同的效果，不过方法句柄使用的代码更简洁。使用方法句柄，可以去掉反射中很多套路化的代码，提高代码的可读性。","like_count":3},{"had_liked":false,"id":216104,"user_name":"小阳","can_delete":false,"product_type":"c1","uid":1296135,"ip_address":"","ucode":"97A162992E6A81","user_header":"https://static001.geekbang.org/account/avatar/00/13/c7/07/5798c17e.jpg","comment_is_top":false,"comment_ctime":1589190407,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10179124999","product_id":100010301,"comment_content":"思考题： <br>   1. 启动时配置参数 -Djava.lang.invoke.MethodHandle.CUSTOMIZE_THRESHOLD=1<br>   2. 将new Foo（）和 new Object（） 提到到循环外， 具体代码如下 <br><br>MethodHandles.Lookup l = MethodHandles.lookup();<br>MethodType t = MethodType.methodType(void.class, Object.class);<br>MethodHandle mh = l.findVirtual(Foo.class, &quot;bar&quot;, t);<br><br>        long current = System.currentTimeMillis();<br>        Foo foo = new Foo();<br>        Object param = new Object();<br>        for (int i = 1; i &lt;= 2_000_000_000; i++) {<br>            if (i % 100_000_000 == 0) {<br>                long temp = System.currentTimeMillis();<br>                System.out.println(temp - current);<br>                current = temp;<br>            }<br>            mh.invokeExact(foo, param);<br>        }","like_count":2},{"had_liked":false,"id":106377,"user_name":"lmtoo","can_delete":false,"product_type":"c1","uid":1133918,"ip_address":"","ucode":"FCD5B9C941D448","user_header":"https://static001.geekbang.org/account/avatar/00/11/4d/5e/c5c62933.jpg","comment_is_top":false,"comment_ctime":1561284373,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10151218965","product_id":100010301,"comment_content":"invokedynamic和MethodHandle有啥关系？","like_count":2},{"had_liked":false,"id":62390,"user_name":"Cy190622","can_delete":false,"product_type":"c1","uid":1381528,"ip_address":"","ucode":"578D804C29248E","user_header":"https://static001.geekbang.org/account/avatar/00/15/14/98/0251b8fd.jpg","comment_is_top":false,"comment_ctime":1548044669,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10137979261","product_id":100010301,"comment_content":"当使用方法句柄时，我们不关心方法句柄指向方法的类名或者方法名。<br>那怎么区分不同类同名方法","like_count":2},{"had_liked":false,"id":38438,"user_name":"　素丶　　","can_delete":false,"product_type":"c1","uid":1081535,"ip_address":"","ucode":"883B7EDBE76104","user_header":"https://static001.geekbang.org/account/avatar/00/10/80/bf/3041138b.jpg","comment_is_top":false,"comment_ctime":1542035370,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10131969962","product_id":100010301,"comment_content":"暂时只能想到把他绑定到一个固定的 “Foo” 实例上。。。。<br>import java.lang.invoke.*;<br><br>public class Foo {<br>  public void bar(Object o) {<br>  }<br><br>  public static void main(String[] args) throws Throwable {<br>    MethodHandles.Lookup l = MethodHandles.lookup();<br>    MethodType t = MethodType.methodType(void.class, Object.class);<br>\tFoo foo = new Foo();<br>    MethodHandle mh = l.findVirtual(Foo.class, &quot;bar&quot;, t).bindTo(foo);<br><br>    long current = System.currentTimeMillis();<br>    for (int i = 1; i &lt;= 2_000_000_000; i++) {<br>      if (i % 100_000_000 == 0) {<br>        long temp = System.currentTimeMillis();<br>        System.out.println(temp - current);<br>        current = temp;<br>       }<br>       mh.invokeExact(new Object());<br>    }<br>  }<br>}<br>","like_count":2,"discussions":[{"author":{"id":1013512,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/77/08/ea7f9119.jpg","nickname":"hello!","note":"","ucode":"4E54993102BD98","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":181529,"discussion_content":"好像只能这么做了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582374492,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308627,"user_name":"ppyh","can_delete":false,"product_type":"c1","uid":1351148,"ip_address":"","ucode":"14022ADEC9B53F","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/ec/235b74c0.jpg","comment_is_top":false,"comment_ctime":1629708999,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5924676295","product_id":100010301,"comment_content":"雨迪老师，在获取方法句柄时，也传参传入了方法的名字了啊，为什么说不关心方法的类名和方法名呢？希望老师解答一下。","like_count":1,"discussions":[{"author":{"id":2104830,"avatar":"https://static001.geekbang.org/account/avatar/00/20/1d/fe/44cc6861.jpg","nickname":"My Roar","note":"","ucode":"D5F6B1980F0C3C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558426,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648294034,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222898,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1590944419,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5885911715","product_id":100010301,"comment_content":"方法句柄就是一个方法的抽象，可用于调用不同类的方法<br>这个实际用处感觉很少","like_count":1},{"had_liked":false,"id":127251,"user_name":"neohope","can_delete":false,"product_type":"c1","uid":1043475,"ip_address":"","ucode":"C0268F6E7E2B6E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","comment_is_top":false,"comment_ctime":1566621957,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5861589253","product_id":100010301,"comment_content":"性能测试下来，反射》final MethodHandle》MethodHandle","like_count":1},{"had_liked":false,"id":124957,"user_name":"大俊stan","can_delete":false,"product_type":"c1","uid":1125370,"ip_address":"","ucode":"BD0CB5FC790DDB","user_header":"https://static001.geekbang.org/account/avatar/00/11/2b/fa/1cde88d4.jpg","comment_is_top":false,"comment_ctime":1566027898,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5860995194","product_id":100010301,"comment_content":"how do you turn this on 笑死了","like_count":1},{"had_liked":false,"id":76850,"user_name":"ゞ﹏雨天____゛","can_delete":false,"product_type":"c1","uid":1451392,"ip_address":"","ucode":"9639F0340C6C91","user_header":"https://static001.geekbang.org/account/avatar/00/16/25/80/fdd5a88f.jpg","comment_is_top":false,"comment_ctime":1552728233,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5847695529","product_id":100010301,"comment_content":"有些内容，第一遍读总是看不懂，听不明白，当你多次读了之后，并查阅相关内容后，你会发现雨迪老师讲的内容，真的很到位，值得学习。","like_count":2},{"had_liked":false,"id":70719,"user_name":"鑫","can_delete":false,"product_type":"c1","uid":1295978,"ip_address":"","ucode":"927D168C715692","user_header":"https://static001.geekbang.org/account/avatar/00/13/c6/6a/b3fab71d.jpg","comment_is_top":false,"comment_ctime":1551168997,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5846136293","product_id":100010301,"comment_content":"invokedynamic与方法句柄的关系是怎么样的?f方法句柄替invokedynamic抽象出调用点?","like_count":1},{"had_liked":false,"id":354741,"user_name":"(￣o￣) . z Z","can_delete":false,"product_type":"c1","uid":1433986,"ip_address":"福建","ucode":"42F97D91001DD1","user_header":"https://static001.geekbang.org/account/avatar/00/15/e1/82/1c5d285d.jpg","comment_is_top":false,"comment_ctime":1660733275,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660733275","product_id":100010301,"comment_content":"感觉好懵逼啊。。。","like_count":0},{"had_liked":false,"id":353354,"user_name":"冬风向左吹","can_delete":false,"product_type":"c1","uid":1066928,"ip_address":"江苏","ucode":"376C45C5134F93","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/b0/a9b77a1e.jpg","comment_is_top":false,"comment_ctime":1659400283,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1659400283","product_id":100010301,"comment_content":"mybatis里面有实际的使用","like_count":0},{"had_liked":false,"id":339268,"user_name":"כן אני אמריקאי","can_delete":false,"product_type":"c1","uid":1527429,"ip_address":"","ucode":"56C5C2B369121B","user_header":"https://static001.geekbang.org/account/avatar/00/17/4e/85/ef0108cd.jpg","comment_is_top":false,"comment_ctime":1648018232,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648018232","product_id":100010301,"comment_content":"关于方法句柄的权限，自己做了一点小总结，欢迎阅读：https:&#47;&#47;juejin.cn&#47;post&#47;7072735300761419783","like_count":0},{"had_liked":false,"id":308629,"user_name":"ppyh","can_delete":false,"product_type":"c1","uid":1351148,"ip_address":"","ucode":"14022ADEC9B53F","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/ec/235b74c0.jpg","comment_is_top":false,"comment_ctime":1629709937,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629709937","product_id":100010301,"comment_content":"还有LambdaForm是怎么来的啊，我看那生成的字节码和java.lang.invoke包下的LambdaForm不一样","like_count":0},{"had_liked":false,"id":234463,"user_name":"yihang","can_delete":false,"product_type":"c1","uid":1012361,"ip_address":"","ucode":"A5506F085D1793","user_header":"https://static001.geekbang.org/account/avatar/00/0f/72/89/1a83120a.jpg","comment_is_top":false,"comment_ctime":1594695914,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594695914","product_id":100010301,"comment_content":"比喻太精彩！","like_count":0},{"had_liked":false,"id":228914,"user_name":"梦想是星空","can_delete":false,"product_type":"c1","uid":1213741,"ip_address":"","ucode":"A51BB1AC71A202","user_header":"https://static001.geekbang.org/account/avatar/00/12/85/2d/94b76324.jpg","comment_is_top":false,"comment_ctime":1592838111,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592838111","product_id":100010301,"comment_content":"DUMP_CLASS_FILES是怎么用的？生成的文件在哪里？","like_count":0},{"had_liked":false,"id":225216,"user_name":"深入拆解JAVA虚拟机","can_delete":false,"product_type":"c1","uid":2029690,"ip_address":"","ucode":"A0E27A628E7341","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/95toQN7kMto1jwNH0LswphIlYGGf3bcJhicKMYEg6zeOn1lfJmGfW69NuMWibpR3BzZXDkWiaD2AYxLaPBib78OwrQ/132","comment_is_top":false,"comment_ctime":1591685912,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591685912","product_id":100010301,"comment_content":"能不能多结合代码例子讲解, 表示完全看不懂. . .心碎. . .","like_count":0},{"had_liked":false,"id":136980,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1569570088,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569570088","product_id":100010301,"comment_content":"老师，你的是基于JDK 10的吗？我JDK8的DUMP_CLASS_FILES看起来和您的有点不一样。","like_count":0},{"had_liked":false,"id":78434,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1553147520,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553147520","product_id":100010301,"comment_content":"想问下老师，为啥在jdk1.8上面分别用反射和方法句柄测试，发现执行次数量特别大的时候方法句柄执行效率反而比反射差，执行数量小的时候比反射执行效率高，不知道为什么，请老师点拨？","like_count":0},{"had_liked":false,"id":56512,"user_name":"松鼠","can_delete":false,"product_type":"c1","uid":1300857,"ip_address":"","ucode":"CD43E089D31647","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJ4C5xMfrgT295JdyiaLFJvf5aGOC1y5IKXIles7iaDwSxoiaEru8icjszZtnMm7ibx0ibQTibqTmLEaflIg/132","comment_is_top":false,"comment_ctime":1546479854,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546479854","product_id":100010301,"comment_content":"反射的权限检查是在编译期完成的，怎么会有权限检查的开销？","like_count":0},{"had_liked":false,"id":25511,"user_name":"Geek_987169","can_delete":false,"product_type":"c1","uid":1180853,"ip_address":"","ucode":"4B2955A044805D","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/b5/8bc4790b.jpg","comment_is_top":false,"comment_ctime":1537349927,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1537349927","product_id":100010301,"comment_content":"&quot;方法句柄 API 有一个特殊的注解类 @PolymorphicSignature。在碰到被它注解的方法调用时&quot;这句话的&quot;被它注解的方法调用时&quot;是不是就是&quot;调用的方法被它注解时&quot;？","like_count":0},{"had_liked":false,"id":22358,"user_name":"Leon Wong","can_delete":false,"product_type":"c1","uid":1073650,"ip_address":"","ucode":"B49B327367CF9E","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/f2/ca989d6f.jpg","comment_is_top":false,"comment_ctime":1535628016,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1535628016","product_id":100010301,"comment_content":"这篇文章我是花比较长时间去读，有个地方想了很久，文档里也没明示，我自己尝试写代码操作方法句柄参数，为什么MethodType.methodType()里指定的首参类型(ptype0)，居然是方法调用实例的类型，而不是方法的参数类型，这个为什么是这么设计呢？有什么渊源？想了解一下","like_count":0},{"had_liked":false,"id":20713,"user_name":"FortyTo","can_delete":false,"product_type":"c1","uid":1199765,"ip_address":"","ucode":"FFE9D2A66B7448","user_header":"https://static001.geekbang.org/account/avatar/00/12/4e/95/362c305a.jpg","comment_is_top":false,"comment_ctime":1534686813,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1534686813","product_id":100010301,"comment_content":"老师，反射和动态绑定有什么不同，感觉实现的功能都一样.","like_count":0},{"had_liked":false,"id":19175,"user_name":"爪哇夜未眠","can_delete":false,"product_type":"c1","uid":1006025,"ip_address":"","ucode":"BBEB80EB670770","user_header":"https://static001.geekbang.org/account/avatar/00/0f/59/c9/f44cb7f3.jpg","comment_is_top":false,"comment_ctime":1533694696,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1533694696","product_id":100010301,"comment_content":"老师能讲下JVM对线程的实现方式吗？","like_count":0}]}