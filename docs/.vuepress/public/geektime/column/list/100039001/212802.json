{"id":212802,"title":"59 | 模板模式（下）：模板模式与Callback回调函数有何区别和联系？","content":"<p>上一节课中，我们学习了模板模式的原理、实现和应用。它常用在框架开发中，通过提供功能扩展点，让框架用户在不修改框架源码的情况下，基于扩展点定制化框架的功能。除此之外，模板模式还可以起到代码复用的作用。</p><p>复用和扩展是模板模式的两大作用，实际上，还有另外一个技术概念，也能起到跟模板模式相同的作用，那就是<strong>回调</strong>（Callback）。今天我们今天就来看一下，回调的原理、实现和应用，以及它跟模板模式的区别和联系。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>回调的原理解析</h2><p>相对于普通的函数调用来说，回调是一种双向调用关系。A类事先注册某个函数F到B类，A类在调用B类的P函数的时候，B类反过来调用A类注册给它的F函数。这里的F函数就是“回调函数”。A调用B，B反过来又调用A，这种调用机制就叫作“回调”。</p><p>A类如何将回调函数传递给B类呢？不同的编程语言，有不同的实现方法。C语言可以使用函数指针，Java则需要使用包裹了回调函数的类对象，我们简称为回调对象。这里我用Java语言举例说明一下。代码如下所示：</p><pre><code>public interface ICallback {\n  void methodToCallback();\n}\n\npublic class BClass {\n  public void process(ICallback callback) {\n    //...\n    callback.methodToCallback();\n    //...\n  }\n}\n\npublic class AClass {\n  public static void main(String[] args) {\n    BClass b = new BClass();\n    b.process(new ICallback() { //回调对象\n      @Override\n      public void methodToCallback() {\n        System.out.println(&quot;Call back me.&quot;);\n      }\n    });\n  }\n}\n</code></pre><p>上面就是Java语言中回调的典型代码实现。从代码实现中，我们可以看出，回调跟模板模式一样，也具有复用和扩展的功能。除了回调函数之外，BClass类的process()函数中的逻辑都可以复用。如果ICallback、BClass类是框架代码，AClass是使用框架的客户端代码，我们可以通过ICallback定制process()函数，也就是说，框架因此具有了扩展的能力。</p><!-- [[[read_end]]] --><p>实际上，回调不仅可以应用在代码设计上，在更高层次的架构设计上也比较常用。比如，通过三方支付系统来实现支付功能，用户在发起支付请求之后，一般不会一直阻塞到支付结果返回，而是注册回调接口（类似回调函数，一般是一个回调用的URL）给三方支付系统，等三方支付系统执行完成之后，将结果通过回调接口返回给用户。</p><p>回调可以分为同步回调和异步回调（或者延迟回调）。同步回调指在函数返回之前执行回调函数；异步回调指的是在函数返回之后执行回调函数。上面的代码实际上是同步回调的实现方式，在process()函数返回之前，执行完回调函数methodToCallback()。而上面支付的例子是异步回调的实现方式，发起支付之后不需要等待回调接口被调用就直接返回。从应用场景上来看，同步回调看起来更像模板模式，异步回调看起来更像观察者模式。</p><h2>应用举例一：JdbcTemplate</h2><p>Spring提供了很多Template类，比如，JdbcTemplate、RedisTemplate、RestTemplate。尽管都叫作xxxTemplate，但它们并非基于模板模式来实现的，而是基于回调来实现的，确切地说应该是同步回调。而同步回调从应用场景上很像模板模式，所以，在命名上，这些类使用Template（模板）这个单词作为后缀。</p><p>这些Template类的设计思路都很相近，所以，我们只拿其中的JdbcTemplate来举例分析一下。对于其他Template类，你可以阅读源码自行分析。</p><p>在前面的章节中，我们也多次提到，Java提供了JDBC类库来封装不同类型的数据库操作。不过，直接使用JDBC来编写操作数据库的代码，还是有点复杂的。比如，下面这段是使用JDBC来查询用户信息的代码。</p><pre><code>public class JdbcDemo {\n  public User queryUser(long id) {\n    Connection conn = null;\n    Statement stmt = null;\n    try {\n      //1.加载驱动\n      Class.forName(&quot;com.mysql.jdbc.Driver&quot;);\n      conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/demo&quot;, &quot;xzg&quot;, &quot;xzg&quot;);\n\n      //2.创建statement类对象，用来执行SQL语句\n      stmt = conn.createStatement();\n\n      //3.ResultSet类，用来存放获取的结果集\n      String sql = &quot;select * from user where id=&quot; + id;\n      ResultSet resultSet = stmt.executeQuery(sql);\n\n      String eid = null, ename = null, price = null;\n\n      while (resultSet.next()) {\n        User user = new User();\n        user.setId(resultSet.getLong(&quot;id&quot;));\n        user.setName(resultSet.getString(&quot;name&quot;));\n        user.setTelephone(resultSet.getString(&quot;telephone&quot;));\n        return user;\n      }\n    } catch (ClassNotFoundException e) {\n      // TODO: log...\n    } catch (SQLException e) {\n      // TODO: log...\n    } finally {\n      if (conn != null)\n        try {\n          conn.close();\n        } catch (SQLException e) {\n          // TODO: log...\n        }\n      if (stmt != null)\n        try {\n          stmt.close();\n        } catch (SQLException e) {\n          // TODO: log...\n        }\n    }\n    return null;\n  }\n\n}\n</code></pre><p>queryUser()函数包含很多流程性质的代码，跟业务无关，比如，加载驱动、创建数据库连接、创建statement、关闭连接、关闭statement、处理异常。针对不同的SQL执行请求，这些流程性质的代码是相同的、可以复用的，我们不需要每次都重新敲一遍。</p><p>针对这个问题，Spring提供了JdbcTemplate，对JDBC进一步封装，来简化数据库编程。使用JdbcTemplate查询用户信息，我们只需要编写跟这个业务有关的代码，其中包括，查询用户的SQL语句、查询结果与User对象之间的映射关系。其他流程性质的代码都封装在了JdbcTemplate类中，不需要我们每次都重新编写。我用JdbcTemplate重写了上面的例子，代码简单了很多，如下所示：</p><pre><code>public class JdbcTemplateDemo {\n  private JdbcTemplate jdbcTemplate;\n\n  public User queryUser(long id) {\n    String sql = &quot;select * from user where id=&quot;+id;\n    return jdbcTemplate.query(sql, new UserRowMapper()).get(0);\n  }\n\n  class UserRowMapper implements RowMapper&lt;User&gt; {\n    public User mapRow(ResultSet rs, int rowNum) throws SQLException {\n      User user = new User();\n      user.setId(rs.getLong(&quot;id&quot;));\n      user.setName(rs.getString(&quot;name&quot;));\n      user.setTelephone(rs.getString(&quot;telephone&quot;));\n      return user;\n    }\n  }\n}\n</code></pre><p>那JdbcTemplate底层具体是如何实现的呢？我们来看一下它的源码。因为JdbcTemplate代码比较多，我只摘抄了部分相关代码，贴到了下面。其中，JdbcTemplate通过回调的机制，将不变的执行流程抽离出来，放到模板方法execute()中，将可变的部分设计成回调StatementCallback，由用户来定制。query()函数是对execute()函数的二次封装，让接口用起来更加方便。</p><pre><code>@Override\npublic &lt;T&gt; List&lt;T&gt; query(String sql, RowMapper&lt;T&gt; rowMapper) throws DataAccessException {\n return query(sql, new RowMapperResultSetExtractor&lt;T&gt;(rowMapper));\n}\n\n@Override\npublic &lt;T&gt; T query(final String sql, final ResultSetExtractor&lt;T&gt; rse) throws DataAccessException {\n Assert.notNull(sql, &quot;SQL must not be null&quot;);\n Assert.notNull(rse, &quot;ResultSetExtractor must not be null&quot;);\n if (logger.isDebugEnabled()) {\n  logger.debug(&quot;Executing SQL query [&quot; + sql + &quot;]&quot;);\n }\n\n class QueryStatementCallback implements StatementCallback&lt;T&gt;, SqlProvider {\n  @Override\n  public T doInStatement(Statement stmt) throws SQLException {\n   ResultSet rs = null;\n   try {\n    rs = stmt.executeQuery(sql);\n    ResultSet rsToUse = rs;\n    if (nativeJdbcExtractor != null) {\n     rsToUse = nativeJdbcExtractor.getNativeResultSet(rs);\n    }\n    return rse.extractData(rsToUse);\n   }\n   finally {\n    JdbcUtils.closeResultSet(rs);\n   }\n  }\n  @Override\n  public String getSql() {\n   return sql;\n  }\n }\n\n return execute(new QueryStatementCallback());\n}\n\n@Override\npublic &lt;T&gt; T execute(StatementCallback&lt;T&gt; action) throws DataAccessException {\n Assert.notNull(action, &quot;Callback object must not be null&quot;);\n\n Connection con = DataSourceUtils.getConnection(getDataSource());\n Statement stmt = null;\n try {\n  Connection conToUse = con;\n  if (this.nativeJdbcExtractor != null &amp;&amp;\n    this.nativeJdbcExtractor.isNativeConnectionNecessaryForNativeStatements()) {\n   conToUse = this.nativeJdbcExtractor.getNativeConnection(con);\n  }\n  stmt = conToUse.createStatement();\n  applyStatementSettings(stmt);\n  Statement stmtToUse = stmt;\n  if (this.nativeJdbcExtractor != null) {\n   stmtToUse = this.nativeJdbcExtractor.getNativeStatement(stmt);\n  }\n  T result = action.doInStatement(stmtToUse);\n  handleWarnings(stmt);\n  return result;\n }\n catch (SQLException ex) {\n  // Release Connection early, to avoid potential connection pool deadlock\n  // in the case when the exception translator hasn't been initialized yet.\n  JdbcUtils.closeStatement(stmt);\n  stmt = null;\n  DataSourceUtils.releaseConnection(con, getDataSource());\n  con = null;\n  throw getExceptionTranslator().translate(&quot;StatementCallback&quot;, getSql(action), ex);\n }\n finally {\n  JdbcUtils.closeStatement(stmt);\n  DataSourceUtils.releaseConnection(con, getDataSource());\n }\n}\n</code></pre><h2>应用举例二：setClickListener(）</h2><p>在客户端开发中，我们经常给控件注册事件监听器，比如下面这段代码，就是在Android应用开发中，给Button控件的点击事件注册监听器。</p><pre><code>Button button = (Button)findViewById(R.id.button);\nbutton.setOnClickListener(new OnClickListener() {\n  @Override\n  public void onClick(View v) {\n    System.out.println(&quot;I am clicked.&quot;);\n  }\n});\n</code></pre><p>从代码结构上来看，事件监听器很像回调，即传递一个包含回调函数（onClick()）的对象给另一个函数。从应用场景上来看，它又很像观察者模式，即事先注册观察者（OnClickListener），当用户点击按钮的时候，发送点击事件给观察者，并且执行相应的onClick()函数。</p><p>我们前面讲到，回调分为同步回调和异步回调。这里的回调算是异步回调，我们往setOnClickListener()函数中注册好回调函数之后，并不需要等待回调函数执行。这也印证了我们前面讲的，异步回调比较像观察者模式。</p><h2>应用举例三：addShutdownHook()</h2><p>Hook可以翻译成“钩子”，那它跟Callback有什么区别呢？</p><p>网上有人认为Hook就是Callback，两者说的是一回事儿，只是表达不同而已。而有人觉得Hook是Callback的一种应用。Callback更侧重语法机制的描述，Hook更加侧重应用场景的描述。我个人比较认可后面一种说法。不过，这个也不重要，我们只需要见了代码能认识，遇到场景会用就可以了。</p><p>Hook比较经典的应用场景是Tomcat和JVM的shutdown hook。接下来，我们拿JVM来举例说明一下。JVM提供了Runtime.addShutdownHook(Thread hook)方法，可以注册一个JVM关闭的Hook。当应用程序关闭的时候，JVM会自动调用Hook代码。代码示例如下所示：</p><pre><code>public class ShutdownHookDemo {\n\n  private static class ShutdownHook extends Thread {\n    public void run() {\n      System.out.println(&quot;I am called during shutting down.&quot;);\n    }\n  }\n\n  public static void main(String[] args) {\n    Runtime.getRuntime().addShutdownHook(new ShutdownHook());\n  }\n\n}\n</code></pre><p>我们再来看addShutdownHook()的代码实现，如下所示。这里我只给出了部分相关代码。</p><pre><code>public class Runtime {\n  public void addShutdownHook(Thread hook) {\n    SecurityManager sm = System.getSecurityManager();\n    if (sm != null) {\n      sm.checkPermission(new RuntimePermission(&quot;shutdownHooks&quot;));\n    }\n    ApplicationShutdownHooks.add(hook);\n  }\n}\n\nclass ApplicationShutdownHooks {\n    /* The set of registered hooks */\n    private static IdentityHashMap&lt;Thread, Thread&gt; hooks;\n    static {\n            hooks = new IdentityHashMap&lt;&gt;();\n        } catch (IllegalStateException e) {\n            hooks = null;\n        }\n    }\n\n    static synchronized void add(Thread hook) {\n        if(hooks == null)\n            throw new IllegalStateException(&quot;Shutdown in progress&quot;);\n\n        if (hook.isAlive())\n            throw new IllegalArgumentException(&quot;Hook already running&quot;);\n\n        if (hooks.containsKey(hook))\n            throw new IllegalArgumentException(&quot;Hook previously registered&quot;);\n\n        hooks.put(hook, hook);\n    }\n\n    static void runHooks() {\n        Collection&lt;Thread&gt; threads;\n        synchronized(ApplicationShutdownHooks.class) {\n            threads = hooks.keySet();\n            hooks = null;\n        }\n\n        for (Thread hook : threads) {\n            hook.start();\n        }\n        for (Thread hook : threads) {\n            while (true) {\n                try {\n                    hook.join();\n                    break;\n                } catch (InterruptedException ignored) {\n                }\n            }\n        }\n    }\n}\n</code></pre><p>从代码中我们可以发现，有关Hook的逻辑都被封装到ApplicationShutdownHooks类中了。当应用程序关闭的时候，JVM会调用这个类的runHooks()方法，创建多个线程，并发地执行多个Hook。我们在注册完Hook之后，并不需要等待Hook执行完成，所以，这也算是一种异步回调。</p><h2>模板模式 VS 回调</h2><p>回调的原理、实现和应用到此就都讲完了。接下来，我们从应用场景和代码实现两个角度，来对比一下模板模式和回调。</p><p>从应用场景上来看\b，同步回调跟模板模式几乎一致。它们都是在一个大的算法骨架中，自由替换其中的某个步骤，起到代码复用和扩展的目的。而异步回调跟模板模式有较大差别，更像是观察者模式。</p><p>从代码实现上来看，回调和模板模式完全不同。回调基于组合关系来实现，把一个对象传递给另一个对象，是一种对象之间的关系；模板模式基于继承关系来实现，子类重写父类的抽象方法，是一种类之间的关系。</p><p>前面我们也讲到，组合优于继承。实际上，这里也不例外。在代码实现上，回调相对于模板模式会更加灵活，主要体现在下面几点。</p><ul>\n<li>像Java这种只支持单继承的语言，基于模板模式编写的子类，已经继承了一个父类，不再具有继承的能力。</li>\n<li>回调可以使用匿名类来创建回调对象，可以不用事先定义类；而模板模式针对不同的实现都要定义不同的子类。</li>\n<li>如果某个类中定义了多个模板方法，每个方法都有对应的抽象方法，那即便我们只用到其中的一个模板方法，子类也必须实现所有的抽象方法。而回调就更加灵活，我们只需要往用到的模板方法中注入回调对象即可。</li>\n</ul><p>还记得上一节课的课堂讨论题目吗？看到这里，相信你应该有了答案了吧？</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>今天，我们重点介绍了回调。它跟模板模式具有相同的作用：代码复用和扩展。在一些框架、类库、组件等的设计中经常会用到。</p><p>相对于普通的函数调用，回调是一种双向调用关系。A类事先注册某个函数F到B类，A类在调用B类的P函数的时候，B类反过来调用A类注册给它的F函数。这里的F函数就是“回调函数”。A调用B，B反过来又调用A，这种调用机制就叫作“回调”。</p><p>回调可以细分为同步回调和异步回调。从应用场景上来看，同步回调看起来更像模板模式，异步回调看起来更像观察者模式。回调跟模板模式的区别，更多的是在代码实现上，而非应用场景上。回调基于组合关系来实现，模板模式基于继承关系来实现，回调比模板模式更加灵活。</p><h2>课堂讨论</h2><p>对于Callback和Hook的区别，你有什么不同的理解吗？在你熟悉的编程语言中，有没有提供相应的语法概念？是叫Callback，还是Hook呢？</p><p>欢迎留言和我分享你的想法。如果有收获，欢迎你把这篇文章分享给你的朋友。</p>","neighbors":{"left":{"article_title":"58 | 模板模式（上）：剖析模板模式在JDK、Servlet、JUnit等中的应用","id":212049},"right":{"article_title":"60 | 策略模式（上）：如何避免冗长的if-else/switch分支判断代码？","id":214014}},"comments":[{"had_liked":false,"id":189179,"user_name":"吴小智","can_delete":false,"product_type":"c1","uid":1310798,"ip_address":"","ucode":"C7C9F58B5C9F7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","comment_is_top":false,"comment_ctime":1584464740,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"396721455972","product_id":100039001,"comment_content":"模板方法和回调应用场景是一致的，都是定义好算法骨架，并对外开放扩展点，符合开闭原则；两者的却别是代码的实现上不同，模板方法是通过继承来实现，是自己调用自己；回调是类之间的组合。","like_count":93,"discussions":[{"author":{"id":2063037,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","nickname":"西电","note":"","ucode":"95BD4CE9D93018","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294756,"discussion_content":"用c语言的话，使用回调只需要一个类就行了。传函数指针","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595989509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":189937,"user_name":"L!en6o","can_delete":false,"product_type":"c1","uid":1054472,"ip_address":"","ucode":"E0931CB8998260","user_header":"https://static001.geekbang.org/account/avatar/00/10/17/08/566fb246.jpg","comment_is_top":false,"comment_ctime":1584583976,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"272167523624","product_id":100039001,"comment_content":"曾经重构代码对这模板模式和callback就很疑惑。个人觉得callback更加灵活，适合算法逻辑较少的场景，实现一两个方法很舒服。比如Guava 的Futures.addCallback 回调 onSuccess onFailure方法。而模板模式适合更加复杂的场景，并且子类可以复用父类提供的方法，根据场景判断是否需要重写更加方便。","like_count":64,"discussions":[{"author":{"id":1743060,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er8xHGabhfnPnK7gN3hVJ0n3wia5qIaay7IOQaGJ4ia0kB1CKywjbJNeGjM7DKexk6TZl88f6um4pqw/132","nickname":"早早凡","note":"","ucode":"E70B0306637482","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307944,"discussion_content":"生命周期一堆的方法,使用模板方法设计模式.","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1600790478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1218403,"avatar":"https://static001.geekbang.org/account/avatar/00/12/97/63/d2e24ed2.jpg","nickname":"一只酸奶牛","note":"","ucode":"10E2BE972D4E0F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1743060,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er8xHGabhfnPnK7gN3hVJ0n3wia5qIaay7IOQaGJ4ia0kB1CKywjbJNeGjM7DKexk6TZl88f6um4pqw/132","nickname":"早早凡","note":"","ucode":"E70B0306637482","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538376,"discussion_content":"是个场景","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639401538,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":307944,"ip_address":""},"score":538376,"extra":""}]},{"author":{"id":2719989,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJFPECFrx6sL90QB3SVeKjMOZibic4Wp09qcH4G8hK9uuGomGU8ElTrOprs7KuMVUUYRcP4fjze8o2w/132","nickname":"黄钰宸","note":"","ucode":"A79A37F1DC6040","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538063,"discussion_content":"说的非常好，有个关键的点确实是一个本质的区别：模板基于继承实现子类可以复用父类的方法；而callback基于类在组合关系实现，callback类无法获取到模板类中定义的方法；","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1639319178,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":189211,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1584488615,"is_pvip":false,"discussion_count":2,"race_medal":1,"score":"203447951527","product_id":100039001,"comment_content":"callback和hook不是一个层面的东西，callback是程序设计方面的一种技术手段，是编程语言成面的东西，hook是通过这种技术手段实现的功能扩展点，其基本原理就是callback。比如windows api中提供的各种事件通知机制，其本身是windows开放给用户可以扩展自己想要的功能的扩展点，而实现这些功能的手段是callback。<br>只要编程语言支持传递函数作为参数，都可以支持callback设计，比如c，golang，javascript，python等。另外一些框架中提供的功能扩展点我们称之为hook，比如vue在其实例生命周期中提供的各种hook函数。","like_count":47,"discussions":[{"author":{"id":1311125,"avatar":"https://static001.geekbang.org/account/avatar/00/14/01/95/fd09e8a8.jpg","nickname":"布拉姆","note":"","ucode":"479FF27D73BCAD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393301,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631347170,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1598564,"avatar":"https://static001.geekbang.org/account/avatar/00/18/64/64/865c1eb4.jpg","nickname":"劳码识途","note":"","ucode":"7AEF4D9407F097","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310232,"discussion_content":"感觉在理！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601699033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":232247,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1593934719,"is_pvip":true,"discussion_count":5,"race_medal":0,"score":"156212757375","product_id":100039001,"comment_content":"模板方法就是定义一个流程，每个流程结点可变的就是一个抽象spi，由不同实现去现。<br>解决的是一个复用与扩展问题。复用的是这个流程本身以及某些结点可以是默认实现。扩展的是有些结点是可以有不同实现的场景。<br>回调是一种交互方式，由调用者告诉被调用者：你做完后还要做一个事情，这个事情是什么。然后被调用者做完后就可以做这个指定的事情。回调倒不用强制和模板方法概念合在一起。","like_count":37,"discussions":[{"author":{"id":1153301,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK3fLmHRZU8qSBDUUAhgRHuGgXiaggMVbIwJIXlBEImPNYbuwNlHzlOA7sR8zcj4Q5OZVWcGDo6sGw/132","nickname":"ori","note":"","ucode":"1F2961EE046DE1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340615,"discussion_content":"赞同，模板更加关注一系列步骤组合成一个固定流程。回调更加关注指定扩展的一个或多个步骤。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1610078123,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1875922,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/9f/d2/54578161.jpg","nickname":"菲茨杰拉德","note":"","ucode":"4EB29359F39862","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542223,"discussion_content":"剑22","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640685290,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1590960,"avatar":"https://static001.geekbang.org/account/avatar/00/18/46/b0/4f45e06e.jpg","nickname":"天雨流芳","note":"","ucode":"81657BA9C900FE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318762,"discussion_content":"赞同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603846610,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2019109,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/cf/25/8c91fd43.jpg","nickname":"Chord","note":"","ucode":"6E248DA470FACC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298686,"discussion_content":"同意，感觉这就是俩东西","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597378123,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2063037,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","nickname":"西电","note":"","ucode":"95BD4CE9D93018","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294759,"discussion_content":"赞同，从使用目的上区分。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595990010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":189904,"user_name":"柠檬C","can_delete":false,"product_type":"c1","uid":1181505,"ip_address":"","ucode":"BC0EE704D952A4","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/41/2d477385.jpg","comment_is_top":false,"comment_ctime":1584581359,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"74599025391","product_id":100039001,"comment_content":"个人看法：模板模式关注点还是在类与对象上，通过继承与多态实现算法的扩展<br>回调关注点在方法上，虽然在java语言中不得不以匿名内部类的形式出现，但本质是将方法当做参数一样传递，有点函数式编程的意思了","like_count":17,"discussions":[{"author":{"id":1006864,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/10/0acf7cbc.jpg","nickname":"Ryan-Hou","note":"","ucode":"5B703C1E1596A5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260935,"discussion_content":"Java 为了支持方法作为参数又引入了 lambda 表达式，比匿名内部类看起来干净多了，虽然也是基于接口的语法糖","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1588914789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1244950,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ff/16/b0ab9a73.jpg","nickname":"luffy","note":"","ucode":"702034E116A99F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351474,"discussion_content":"我总是抓不住核心，用另一种语言实现就给尬住了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614301845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":189237,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1584492314,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"40239197978","product_id":100039001,"comment_content":"callback应该偏语言层面，hook偏业务层面，二者一个是概念，一个是具体的落地方式。","like_count":9,"discussions":[{"author":{"id":1376242,"avatar":"","nickname":"秀秀","note":"","ucode":"4601FF39F8FE6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332711,"discussion_content":"七月？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607322960,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1200704,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","nickname":"pedro","note":"","ucode":"F40C839DDFD599","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1376242,"avatar":"","nickname":"秀秀","note":"","ucode":"4601FF39F8FE6A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332745,"discussion_content":"啥意思？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607329779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":332711,"ip_address":""},"score":332745,"extra":""}]}]},{"had_liked":false,"id":244898,"user_name":"写代码的","can_delete":false,"product_type":"c1","uid":2085090,"ip_address":"","ucode":"F58186409A3D65","user_header":"https://static001.geekbang.org/account/avatar/00/1f/d0/e2/1d00c079.jpg","comment_is_top":false,"comment_ctime":1598731915,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"27368535691","product_id":100039001,"comment_content":"虽然模板模式和回调很像，甚至和可以互相替换，但是为了让它们的功能和名称更契合，我觉得按照这样原则来使用这两种方法是不是会更好些：如果预留的扩展点必须实现，因为这些扩展点包含和这个类本身相关的关键功能性代码，不实现的话这个类就是个半成品，无法使用，那么使用模板模式，因为模板模式使用的抽象类可以在与语言层面强制这些扩展点必须被实现；如果预留的扩展点可以不实现，或者这些扩展点的实现逻辑甚至可以和这个类完全无关，那么就使用回调,，回调使用的组合关系恰好可以让类和扩展点的实现进行解耦，比如按钮上的事件回调，回调中的逻辑和按钮这个类本身的功能并没有什么关系，甚至回调可以传 null。","like_count":6},{"had_liked":false,"id":193940,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1585000990,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"27354804766","product_id":100039001,"comment_content":"什么是“回调 ”？A注册一个函数到B，B执行某个函数时，会调用A注册的这个函数。<br>我见过的应用一般完全结束（关闭，收尾等）时用hook，其他情况用callback或者on...listener。这种区别更多是语意上的，不是实现上的。","like_count":6,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477278,"discussion_content":"可以的，我就是用的不可逆的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575895594,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1877862,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLu3MgZBAyyiavX2CMF2KRib791j3bBGiaQDzuQwBF2k6AKHANV2uTAAss2vVaeC7xcSYYD8vjmibRpTQ/132","nickname":"纵不朽","note":"","ucode":"DB2CA2C46B2EF1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":541091,"discussion_content":"刚好发生哈希碰撞，这种咱不考虑了是不？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640251628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":477278,"ip_address":""},"score":541091,"extra":""}]},{"author":{"id":1322366,"avatar":"https://static001.geekbang.org/account/avatar/00/14/2d/7e/335a9b9d.jpg","nickname":"🐝null","note":"","ucode":"16F5E4965F8D5D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":313249,"discussion_content":"token最好是可逆的，这样不用查询数据库或缓存就可以获取userid和过期时间等信息，可以参考一下JWT的方案，Java也有第三方jar实现了JWT算法","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1603011828,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2772190,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/4c/de/d8b8d9ca.jpg","nickname":"花花世界besos","note":"","ucode":"D574DA13F741DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":396655,"discussion_content":"我喜欢用迷惑的方法，我传时间戳，但我不用时间戳，或者改造时间戳加密。哈哈哈哈","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1632471229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383993,"discussion_content":"那就是 一个io成本 or  一个计算成本 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626330730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":189846,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1274787,"ip_address":"","ucode":"C233DF1D224EC1","user_header":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","comment_is_top":false,"comment_ctime":1584576873,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"23059413353","product_id":100039001,"comment_content":"swift和OC的闭包也属于回调","like_count":5,"discussions":[{"author":{"id":1586169,"avatar":"https://static001.geekbang.org/account/avatar/00/18/33/f9/658f5bd2.jpg","nickname":"torchlight","note":"","ucode":"1E05FD0360BEF3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380155,"discussion_content":"向大佬学习","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624360842,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1586169,"avatar":"https://static001.geekbang.org/account/avatar/00/18/33/f9/658f5bd2.jpg","nickname":"torchlight","note":"","ucode":"1E05FD0360BEF3","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":380215,"discussion_content":"加油💪","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624375396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":380155,"ip_address":""},"score":380215,"extra":""}]},{"author":{"id":1099525,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c7/05/19c5c255.jpg","nickname":"微末凡尘","note":"","ucode":"25EDFD0914D0F4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288188,"discussion_content":"真的厉害啊，大佬，很好奇大佬以前是做什么的呢，为什么30岁还去考研究生呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593673780,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1099525,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c7/05/19c5c255.jpg","nickname":"微末凡尘","note":"","ucode":"25EDFD0914D0F4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288193,"discussion_content":"以前是学石油的，现在搞it了🤣","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1593674951,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":288188,"ip_address":""},"score":288193,"extra":""},{"author":{"id":1300285,"avatar":"https://static001.geekbang.org/account/avatar/00/13/d7/3d/a076faf1.jpg","nickname":"蜗牛","note":"","ucode":"A99C9C890F95E4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":313790,"discussion_content":"看了 大佬的github 真的厉害，向您学习","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603092573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":288193,"ip_address":""},"score":313790,"extra":""}]},{"author":{"id":1235937,"avatar":"https://static001.geekbang.org/account/avatar/00/12/db/e1/526653ab.jpg","nickname":"秋雨无痕","note":"","ucode":"8BBF69A208B342","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":191951,"discussion_content":"厉害啊，必须关注啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583048775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1235937,"avatar":"https://static001.geekbang.org/account/avatar/00/12/db/e1/526653ab.jpg","nickname":"秋雨无痕","note":"","ucode":"8BBF69A208B342","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":191998,"discussion_content":"哪里，一起学习！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583053295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":191951,"ip_address":""},"score":191998,"extra":""}]},{"author":{"id":1328354,"avatar":"https://static001.geekbang.org/account/avatar/00/14/44/e2/763526e9.jpg","nickname":"程晓擘","note":"","ucode":"96986D5AE2B96C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":75073,"discussion_content":"看了你的github，佩服呀，我也要加油喽。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575721337,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1328354,"avatar":"https://static001.geekbang.org/account/avatar/00/14/44/e2/763526e9.jpg","nickname":"程晓擘","note":"","ucode":"96986D5AE2B96C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":75081,"discussion_content":"我比较笨的那种，每天多commit","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575721841,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":75073,"ip_address":""},"score":75081,"extra":""},{"author":{"id":1328354,"avatar":"https://static001.geekbang.org/account/avatar/00/14/44/e2/763526e9.jpg","nickname":"程晓擘","note":"","ucode":"96986D5AE2B96C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":75683,"discussion_content":"谦虚啦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575767490,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":75081,"ip_address":""},"score":75683,"extra":""}]},{"author":{"id":1048887,"avatar":"https://static001.geekbang.org/account/avatar/00/10/01/37/12e4c9c9.jpg","nickname":"高源","note":"","ucode":"751B41FD38EF7D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73078,"discussion_content":"请教一下你算法怎么学的，动态规划我理解不上去，想问问你怎么理解明白的，能够灵活运用，理论知道但是自己动手就不知道怎么做了列不出状态转移方程啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575552113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1048887,"avatar":"https://static001.geekbang.org/account/avatar/00/10/01/37/12e4c9c9.jpg","nickname":"高源","note":"","ucode":"751B41FD38EF7D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73291,"discussion_content":"真是谬赞了😂。我研究生的课题方向就是智能规划，被这个课题搞的几度想退学，好在老师善解人意。我30岁转专业考计算机的研究生，还tm是全日制的，压力有多大？又遇到这么一个研究方向，除了硬着头皮整，就剩退学一条路了。问我咋学，全靠心理建设，咬着牙坚持呗。科研水平不渐长，英文阅读能力与日俱增。我都能整下去，你肯定没问题！加油！","likes_number":37,"is_delete":false,"is_hidden":false,"ctime":1575557089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":73078,"ip_address":""},"score":73291,"extra":""},{"author":{"id":1732780,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","nickname":"面向百度编程","note":"","ucode":"8FE04A019D71D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":217382,"discussion_content":"你给了我考研的信心，谢谢哥，30岁都还有考研的想法，很佩服","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585551625,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":73291,"ip_address":""},"score":217382,"extra":""},{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1732780,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","nickname":"面向百度编程","note":"","ucode":"8FE04A019D71D1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217403,"discussion_content":"加油！你可以的！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585554806,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":217382,"ip_address":""},"score":217403,"extra":""}]},{"author":{"id":1443663,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIang00R9vkklnkFCLhzRysNfocr0sLnCdoZwOT3UkulAPefk5BDvd0PfIeQSODSQg1DjKWUmJOaA/132","nickname":"陈迎春","note":"","ucode":"2870BA6D6E5B1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72924,"discussion_content":"请教大佬一个问题，如何定义一个存储接口，实现类即可以是数据库，也可以是文本？比较通用的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575543454,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1443663,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIang00R9vkklnkFCLhzRysNfocr0sLnCdoZwOT3UkulAPefk5BDvd0PfIeQSODSQg1DjKWUmJOaA/132","nickname":"陈迎春","note":"","ucode":"2870BA6D6E5B1E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73234,"discussion_content":"举个例子吧，例如定义一个\nprivate CustomerRepository repository;\n\nCustomerRepository 可以继承或是实现 MySql repository, MangoDB repository 或 File repository 等等，每个repository 实现对应的CURD操作。\n\n这样想使用什么存储方式，就让CustomerRepository继承什么父类或者接口，你看怎么样？\n\n这里参考了Spring access data的部分。附上链接：https://spring.io/guides/gs/accessing-data-mongodb/","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575555937,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":72924,"ip_address":""},"score":73234,"extra":""},{"author":{"id":1443663,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIang00R9vkklnkFCLhzRysNfocr0sLnCdoZwOT3UkulAPefk5BDvd0PfIeQSODSQg1DjKWUmJOaA/132","nickname":"陈迎春","note":"","ucode":"2870BA6D6E5B1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":73766,"discussion_content":"首先非常感谢大佬的回复，你的意思我大致是能理解的，但是其中有一个稍微细节一点的东西，不是很明白，比如FileRespository类，是文本操作，不是CURD操作，接口如何设计才能保证统一性呢？\n\n我用代码示例如下：\n\n目前做法是（python代码）\nclass DataStorageInterface:\n    &#34;&#34;&#34;\n    数据存储接口类，各种不同的存储类实现该接口，并且实现接口方法write, read\n    &#34;&#34;&#34;\n    def write(self, data):\n        pass\n\n    def read(self, data):\n        pass\n\n\nclass SqliteStorage(DataStorageInterface):\n    &#34;&#34;&#34;\n    sqlite存储类,实现DataStorageInterface \n    &#34;&#34;&#34;\n    def write(self, sql_cmd):\n        执行sql cmd，将数据插入数据库\n\n\n    def read(self, sql_cmd):\n        执行sql cmd，读取数据\n\nclass TxtStorage(DataStorageInterface):\n    &#34;&#34;&#34;\n    文本存储类，这里就感觉文本存储类，实现write read方法，就不是很合适\n    &#34;&#34;&#34;\n    def write(self, data):\n       这里cmd其实应该是数据\n\n\n    def read(self, data):\n\n\nSqliteStorage 是可以执行CURD操作的，如果定义其他数据库类（MangoDbStorage），那么应用代码基本不需要修改任何代码，我觉的这种情况习下DataStorageInterface接口类设计应该也是合适的;\n\n但是，如果存储类编程了文本存储类，那么这个接口定义的就感觉不太合适，因为文本存储根本就不是CURD操作，我的问题是，有没有办法让设计的接口类，更加通用，就算由数据库存储方式，换成了其他存储方式，也不需要修改应用代码?\n   ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575595298,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":73234,"ip_address":""},"score":73766,"extra":""},{"author":{"id":1685995,"avatar":"https://static001.geekbang.org/account/avatar/00/19/b9/eb/6bdab896.jpg","nickname":"Murrre","note":"","ucode":"49644059B512BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1443663,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIang00R9vkklnkFCLhzRysNfocr0sLnCdoZwOT3UkulAPefk5BDvd0PfIeQSODSQg1DjKWUmJOaA/132","nickname":"陈迎春","note":"","ucode":"2870BA6D6E5B1E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73863,"discussion_content":"统一传入数据，数据库的实现就拼装sql，运行，文件的实现就是直接执行输入输出流。不要把参数定义为sql_cmd..不知道能不能解答你的疑问。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575603350,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":73766,"ip_address":""},"score":73863,"extra":""}]}]},{"had_liked":false,"id":189772,"user_name":"前端西瓜哥","can_delete":false,"product_type":"c1","uid":1248576,"ip_address":"","ucode":"150130C34CD1C1","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/40/f70e5653.jpg","comment_is_top":false,"comment_ctime":1584547833,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23059384313","product_id":100039001,"comment_content":"Callback 是在一个方法的执行中，调用嵌入的其他方法的机制，能很好地起到代码复用和框架扩展的作用。在 JavaScript 中，因为函数可以直接作为另一个函数的参数，所以能经常看到回调函数的身影，比如定时器 setTimeout(callback, delay)、Ajax 请求成功或失败对应的回调函数等。不过如果滥用回调的话，会在某些场景下会因为嵌套过多导致回调地狱。<br><br>Hook 本质上也是回调，但它往往和一些场景性的行为绑定在一起。在浏览器环境中，我们可以通过 img.onload = func1 来让图片在加载完后执行函数 func1，某种意义上算是一种 Hook。此外在 js 的 vue 框架中，也提供了组件生命周期的 Hook，比如 beforeDestory 钩子函数会在组件即将被销毁前执行，常用于销毁一些当前组件才会用到的定时器。","like_count":5},{"had_liked":false,"id":189223,"user_name":"黄林晴","can_delete":false,"product_type":"c1","uid":1362631,"ip_address":"","ucode":"B15C38AECDA88F","user_header":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","comment_is_top":false,"comment_ctime":1584490343,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"23059326823","product_id":100039001,"comment_content":"打卡<br>回调接口如果定义了多个方法，不也需要全部实现吗<br><br>课后思考:<br>android 中有个hook 概念，多用于反射修改源码机制，进行插件化相关的开发","like_count":5,"discussions":[{"author":{"id":1132661,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","nickname":"乘坐Tornado的线程魔法师","note":"","ucode":"C4C9915866E769","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":75576,"discussion_content":"求瞻仰大佬代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575733953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1740368,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKhr1LrBZQTnn5PgyuHUtia6j6tiahZyk44BWeB5LQIqMgTDBdibGKVVopbJWbz83ZWvyVPz9fBl69rw/132","nickname":"Geek_b6e449","note":"","ucode":"8296078ED23637","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1132661,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","nickname":"乘坐Tornado的线程魔法师","note":"","ucode":"C4C9915866E769","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286658,"discussion_content":"微信的文档写的很清楚的 自己业务可以做参考的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1593256209,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":75576,"ip_address":""},"score":286658,"extra":""}]},{"author":{"id":1253287,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1f/a7/d379ca4f.jpg","nickname":"jon","note":"","ucode":"5768A34E292CAA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":71587,"discussion_content":"代码分享一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575435561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1740368,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKhr1LrBZQTnn5PgyuHUtia6j6tiahZyk44BWeB5LQIqMgTDBdibGKVVopbJWbz83ZWvyVPz9fBl69rw/132","nickname":"Geek_b6e449","note":"","ucode":"8296078ED23637","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1253287,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1f/a7/d379ca4f.jpg","nickname":"jon","note":"","ucode":"5768A34E292CAA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286659,"discussion_content":"微信的文档写的很清楚的 自己业务可以做参考的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593256214,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":71587,"ip_address":""},"score":286659,"extra":""}]}]},{"had_liked":false,"id":225036,"user_name":"肖臧","can_delete":false,"product_type":"c1","uid":1047733,"ip_address":"","ucode":"4FAC9FF54DD6A0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fc/b5/ac717737.jpg","comment_is_top":false,"comment_ctime":1591622683,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14476524571","product_id":100039001,"comment_content":"补充一下ResultSetExtractor类的extractData方法会回调RowMapper类的mapRow方法，在这里把ResultSet转成Entity实例，下面是具体的代码：<br>public List&lt;T&gt; extractData(ResultSet rs) throws SQLException {<br>\tList&lt;T&gt; results = (this.rowsExpected &gt; 0 ? new ArrayList&lt;&gt;(this.rowsExpected) : new ArrayList&lt;&gt;());<br>\tint rowNum = 0;<br>\twhile (rs.next()) {<br>\t\tresults.add(this.rowMapper.mapRow(rs, rowNum++));<br>\t}<br>\treturn results;<br>}","like_count":3},{"had_liked":false,"id":201622,"user_name":"kingcall","can_delete":false,"product_type":"c1","uid":1056982,"ip_address":"","ucode":"508884DC684B5B","user_header":"https://static001.geekbang.org/account/avatar/00/10/20/d6/b9513db0.jpg","comment_is_top":false,"comment_ctime":1585813299,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14470715187","product_id":100039001,"comment_content":" 模板方法的扩展是子类的实现，复用是父类的已有代码；而回调扩展是调用者传进来的调用对象，复用是被调用者的方法","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476805,"discussion_content":"你说得很好，多谢指出啊，确实没必要搞个接口，ApiRequest的设计也依赖了具体的url实现，所以也不是很通用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575898125,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1650785,"avatar":"https://static001.geekbang.org/account/avatar/00/19/30/61/50e24e09.jpg","nickname":"煜","note":"","ucode":"3C5A9A55A65FC9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":202469,"discussion_content":"说说我对设计成接口的一个想法，设计成接口还有另外一个作用，就是封装实现细节，只提供调用接口和详细的注释给其他系统去调用，让调用者不需要去深入了解代码。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1583922198,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1004264,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/52/e8/92a2e66d.jpg","nickname":"第二少","note":"","ucode":"4A09D1E7589F67","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302086,"discussion_content":"从业务功能上来说，确实没必要设计成接口；但从调用api的方式上来说，接口鉴权可以做成一个独立的微服务，由需要鉴权的其他微服务调用，通常采用rpc方式，这时候调用方需要依赖的就只是一个鉴权服务的接口，不需要依赖具体实现，因此鉴权服务就有必要设计成接口加默认实现类了，更进一步，以后实现代码修改了，只要接口不变，，调用方代码也不需要修改","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1598783430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1182372,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0a/a4/828a431f.jpg","nickname":"张申傲","note":"","ucode":"22D46BC529BA8A","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340814,"discussion_content":"可以抽象一个 RequestAddr 接口，UrlAddr 和 TargetServiceAddr 分别是针对 api 和 rpc 的请求地址的实现类","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1610166282,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2536820,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b5/74/cd80b9f4.jpg","nickname":"友","note":"","ucode":"972A4333A8B101","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":533874,"discussion_content":"赞同楼上 将Apirequest 也变成一个接口","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638003183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":195259,"user_name":"Richie","can_delete":false,"product_type":"c1","uid":1019588,"ip_address":"","ucode":"12314EF0347693","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/c4/8d1150f3.jpg","comment_is_top":false,"comment_ctime":1585150741,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14470052629","product_id":100039001,"comment_content":"Hook机制和观察者模式都是基于Callback来实现的，这两者又有什么区别呢？<br>是否可以理解为：<br>* Hook一般是同步阻塞回调，是对原应用、框架流程的干预和扩展；<br>* 观察者模式一般是异步非阻塞回调，主要实现的语义是当某个事件发生时，我可以做一些其他事情，比如发送通知、比如对事件源做一些额外的处理；<br>* Hook常用在框架层面，属于固定流程上一定会发生的；<br>* Event Listener则比较常用在具体应用中，事件是可能发生也可能不发生，而且不确定什么时候会发生的；","like_count":3},{"had_liked":false,"id":189788,"user_name":"iLeGeND","can_delete":false,"product_type":"c1","uid":1055475,"ip_address":"","ucode":"4055A628A6E97C","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/f3/41d5ba7d.jpg","comment_is_top":false,"comment_ctime":1584549892,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14469451780","product_id":100039001,"comment_content":"回调函数是不是只能在同一个jvm下的 程序之间才能实现","like_count":3,"discussions":[{"author":{"id":1718694,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/39/a6/4fdd8b98.jpg","nickname":"黄桷垭C罗","note":"","ucode":"6B43B766C5A5EB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571195,"discussion_content":"不同的JVM可以用HTTP，RPC啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652107717,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":189193,"user_name":"大头","can_delete":false,"product_type":"c1","uid":1315367,"ip_address":"","ucode":"C1FB2C8A0FB0C0","user_header":"https://static001.geekbang.org/account/avatar/00/14/12/27/32746bbf.jpg","comment_is_top":false,"comment_ctime":1584480752,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"14469382640","product_id":100039001,"comment_content":"java8支持参数传递，以及lambda的使用，也是对回掉的简化","like_count":3,"discussions":[{"author":{"id":1702886,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fb/e6/1b9edb91.jpg","nickname":"练习生","note":"","ucode":"60203A2AA0EA36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360349,"discussion_content":"方法引用 也可以简化callback的实现","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1616422033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248577,"user_name":"gevin","can_delete":false,"product_type":"c1","uid":1005862,"ip_address":"","ucode":"B5AD68F1884A1F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/59/26/1015d573.jpg","comment_is_top":false,"comment_ctime":1600227864,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10190162456","product_id":100039001,"comment_content":"前面问老师一个在开发中，对模版模式和回调的使用如何取舍的问题。我自己思考如下：<br><br>1. 如果我们的业务场景是针对老师文中所说的“业务算法”，那两种方式都可以，如果回调不是太复杂，不会导致整个业务逻辑的混乱，那么回调可能是更优雅的一种方案<br>2. 有时我们面向的业务本身，可能就是一种模板，比如定义一种业务流程，具体实现是对这种模板的个性化，或者我们对场景是对一种工业加工工艺的数字化实现，这些场景，可以直接套用模版模式的逻辑，回调不能直观体现业务逻辑，就不用考虑了。","like_count":2},{"had_liked":false,"id":189666,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1018370,"ip_address":"","ucode":"7A488CC6FE15E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","comment_is_top":false,"comment_ctime":1584539536,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10174474128","product_id":100039001,"comment_content":"打卡 今日学习回调函数，收获如下: 回调是一种A调用B，B又回来调用A的一种机制。它有两种方式：同步回调和异步回调。它的功能与模版模式类似都是复用与扩展。回调采用的是组合方式，更加灵活。而模版模式采用的是继承，有单继承的局限，如果继承层次过深，后期不便于维护。自己在写JavaScript时，常常使用回调这种方式来完成需求，通过今日的学习，进一步加深了对回调机制的理解。","like_count":2},{"had_liked":false,"id":189344,"user_name":"Eden Ma","can_delete":false,"product_type":"c1","uid":1457408,"ip_address":"","ucode":"755312F0D154F9","user_header":"https://static001.geekbang.org/account/avatar/00/16/3d/00/7daa7403.jpg","comment_is_top":false,"comment_ctime":1584503098,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10174437690","product_id":100039001,"comment_content":"CO中hook主要作用是AOP中插入其它的方法实现.Callback则一般指Block和通过协议在委托模式中传递数据等.","like_count":2},{"had_liked":false,"id":189319,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1584499882,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10174434474","product_id":100039001,"comment_content":"打卡 Java和Kotlin中都是callback<br>Callback优于Template之处在于组合优于继承.<br>Callback的缺点是嵌套回调导致的回调地狱(Callback Hell)","like_count":2,"discussions":[{"author":{"id":1194009,"avatar":"https://static001.geekbang.org/account/avatar/00/12/38/19/c8d72c61.jpg","nickname":"木白","note":"","ucode":"BEC459430B293C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":223469,"discussion_content":"之前做了一个和这篇文章几乎一样的功能，翻了下代码，就叫ApiSecurityUtil，然后里面全是静态方法。。。确实该反省一下了，用面向对象语言干面向过程的勾当","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1586227744,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1101774,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cf/ce/9261eae7.jpg","nickname":"arvin","note":"","ucode":"1A008122D9E34C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":71651,"discussion_content":"我是一般这样过程式的做，然后再拆。因为过程式开发更快，我可以更快的验证业务逻辑，然后就是 “拆-提取方法”。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1575444541,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2446024,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/GA9AqKGEdib009iaPw3FSluiaeibCXmen7yFIKicZB8qqEtczZJF2WmwBJ738eExnxDmPREIGjqc4BFVXiamyhuCZASw/132","nickname":"一缕阳光","note":"","ucode":"CA89C1B7CB16C0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585389,"discussion_content":"但是我快啊，leader喜欢，老板喜欢，同事觉得我开发速度飞快，觉得我牛逼！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1661505329,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1218223,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/af/2039a26b.jpg","nickname":"invzhi","note":"","ucode":"60749CB1BA434D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":276852,"discussion_content":"过于真实了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590941174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1233193,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","nickname":"DFighting","note":"","ucode":"F3BA2426FF8582","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":132117,"discussion_content":"现在要我写估计也是这个编码思路，脑袋里对面向过程设计都形成了一种固话的思维了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578882414,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1518793,"avatar":"https://static001.geekbang.org/account/avatar/00/17/2c/c9/462afe28.jpg","nickname":"小白","note":"","ucode":"11FC209D9ED65F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590987,"discussion_content":"点醒我了😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666198665,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1792698,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/5a/ba/596d6ae3.jpg","nickname":"MENGXIANGING","note":"","ucode":"B51414E230D6A1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580423,"discussion_content":"跟我想的一模一样，太真实了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658156143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1098720,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c3/e0/3db22579.jpg","nickname":"技术骨干","note":"","ucode":"8FCF8DE6D29201","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544871,"discussion_content":"学习了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641741374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2064266,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/vkqibkINia6dxVOv5zia2zbkmQbrJUsQw8vDfiauib2DfyvJQ4PDUC7M8p4vqFiaQj70yYwIO8JlHFA450KPmgpsXlsw/132","nickname":"Geek_bing","note":"","ucode":"4000A30EDAF71C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389215,"discussion_content":"+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629181279,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2550743,"avatar":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","nickname":"if...else...","note":"","ucode":"D0565908C99695","race_medal":4,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377515,"discussion_content":"哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622691296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1300306,"avatar":"https://static001.geekbang.org/account/avatar/00/13/d7/52/69a63216.jpg","nickname":"一头牛逼的粉红豹","note":"","ucode":"A6282FD67B2BB6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347205,"discussion_content":"真实","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612173135,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2347137,"avatar":"https://static001.geekbang.org/account/avatar/00/23/d0/81/d5c8e46e.jpg","nickname":"snake","note":"","ucode":"47BFFE4D048156","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336183,"discussion_content":"+1.。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608522289,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1533352,"avatar":"https://static001.geekbang.org/account/avatar/00/17/65/a8/6431f8b0.jpg","nickname":"Kang","note":"","ucode":"6FD3642D6455AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304552,"discussion_content":"太真实了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599613127,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1274787,"avatar":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","nickname":"Michael","note":"","ucode":"C233DF1D224EC1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78325,"discussion_content":"我和你是一个套路","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575987804,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1161271,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","nickname":"不似旧日","note":"","ucode":"DF4C5E3AB9570C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":71543,"discussion_content":"如果是我不会拆那么细，生产token的功能可能会封装一个tokenutl类","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575431865,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347610,"user_name":"Geek_7e0e83","can_delete":false,"product_type":"c1","uid":2142423,"ip_address":"","ucode":"554DEE2AAAE33C","user_header":"","comment_is_top":false,"comment_ctime":1654223980,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5949191276","product_id":100039001,"comment_content":"1.学习了这一节课，对于前一节课的答案有了新的回答。也就是对于有多个模板方法和需要实现的Method的类，我们可以重构为回调函数的形式。模板方法的入参是回调的接口，然后根据调用方的情况。选择自己要调用的模板方法，传入对应的回调接口的实现类即可完成。灵活，不需要实现其他的不使用的Method。<br><br>2.hook的函数一点像是异步的回调。不会阻塞原本的流程执行，算是回调的一种特殊情况吧。callback的话，就像文章中说的有同步回调和异步回调两种。hook是callback的一种表现形式。<br><br>我印象中git的版本控制软件中有提供hook的函数，供开发者可以再代码提交的时候加入hook事件，实现想要的需求，比如触发一下监控，记录提交日志、执行自定义的commit message的语法规范检查等。","like_count":1},{"had_liked":false,"id":327944,"user_name":"meng","can_delete":false,"product_type":"c1","uid":2808920,"ip_address":"","ucode":"FBB45FCDD3C6FF","user_header":"https://static001.geekbang.org/account/avatar/00/2a/dc/58/81824956.jpg","comment_is_top":false,"comment_ctime":1640413692,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5935380988","product_id":100039001,"comment_content":"java只能单继承，但是可以多实现接口，jdk1.8之后接口中提供了default方法，是否也可以用作模板方法模式","like_count":1},{"had_liked":false,"id":193618,"user_name":"石仔","can_delete":false,"product_type":"c1","uid":1177921,"ip_address":"","ucode":"974E4604CE2213","user_header":"https://static001.geekbang.org/account/avatar/00/11/f9/41/411b1753.jpg","comment_is_top":false,"comment_ctime":1584934398,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879901694","product_id":100039001,"comment_content":"从来没有把模板模式和回调模式拿来比较.只停留在语法技术层面没有从场景和功能方面考虑和比较.","like_count":1},{"had_liked":false,"id":190364,"user_name":"Rain","can_delete":false,"product_type":"c1","uid":1238221,"ip_address":"","ucode":"6A270D922A3B9D","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","comment_is_top":false,"comment_ctime":1584632714,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879600010","product_id":100039001,"comment_content":"对于callback 和 hook 的提供意图来说，提供callback 的时候是希望在callback里面完成主要的工作。hook的目的则在于扩展。前者的提供者通常没我在默认实现，非常希望callback 完成具体任务，而hook是基本已经实现了大部分功能，如果需要特殊操作，那就在hook里面做。","like_count":1},{"had_liked":false,"id":190041,"user_name":"L🚲🐱","can_delete":false,"product_type":"c1","uid":1577856,"ip_address":"","ucode":"08A012739614DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","comment_is_top":false,"comment_ctime":1584597170,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879564466","product_id":100039001,"comment_content":"模板方法和回调应用场景一致, 两者的区别是代码实现上不一样, 模板方法是通过 继承来实现, 是自己调用自己, 回调是通过组合来实现, 是类之间的组合. java 中有 Callback的概念","like_count":1},{"had_liked":false,"id":190017,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1584593618,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879560914","product_id":100039001,"comment_content":"1.callback是一个语法机制的命名，hook是一个应用场景的命名。但我认为两者换下语义更强。hook描述语法机制，指的就是添加钩子方法这么一种语法机制。callback描述应用场景，特指调用方需要被调用方回调自己的这种场景，这属于钩子方法的应用。大白话就是，我在用callback语法机制时，时常是做一些任务编排的事，跟回调这个语义并不贴切，让我觉得很别扭。<br><br>2.java的jdbc其实操作数据库也有callback语法的应用。但现在都是用的orm框架，估摸也都忘了吧，不过也确实没有记忆的必要就是了。","like_count":1},{"had_liked":false,"id":189808,"user_name":"花郎世纪","can_delete":false,"product_type":"c1","uid":1800886,"ip_address":"","ucode":"301DF9B6375E08","user_header":"https://static001.geekbang.org/account/avatar/00/1b/7a/b6/f54bbfaa.jpg","comment_is_top":false,"comment_ctime":1584558000,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879525296","product_id":100039001,"comment_content":"深度学习pytorch框架，提供hook去获取特征层数据","like_count":1},{"had_liked":false,"id":189647,"user_name":"丁乐洪","can_delete":false,"product_type":"c1","uid":1264392,"ip_address":"","ucode":"549CE57AB20B49","user_header":"https://static001.geekbang.org/account/avatar/00/13/4b/08/52954cd7.jpg","comment_is_top":false,"comment_ctime":1584538087,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879505383","product_id":100039001,"comment_content":"模板类 与 模板模式 有啥关系，感觉干的是同类活","like_count":1},{"had_liked":false,"id":189616,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1584534586,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879501882","product_id":100039001,"comment_content":"对于Java中的Callback,常见的还是异步回调,注册一个函数之后,无需等待返回了,可以进行下一步的工作,仿佛就是种下了一个种子,等待开花结果<br>对于Hook,则像是一种具体的实现手段,而且常见于AOP的代理之中","like_count":1},{"had_liked":false,"id":189605,"user_name":"徐旭","can_delete":false,"product_type":"c1","uid":1814806,"ip_address":"","ucode":"1D3091D15373E5","user_header":"https://static001.geekbang.org/account/avatar/00/1b/b1/16/dd11930c.jpg","comment_is_top":false,"comment_ctime":1584533727,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5879501023","product_id":100039001,"comment_content":"hook也是钩子吧，好像也可以用在上层直接调底层native层","like_count":1,"discussions":[{"author":{"id":2096683,"avatar":"","nickname":"Geek_151295","note":"","ucode":"970A611ECFB457","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575816,"discussion_content":"优秀。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655122323,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1586169,"avatar":"https://static001.geekbang.org/account/avatar/00/18/33/f9/658f5bd2.jpg","nickname":"torchlight","note":"","ucode":"1E05FD0360BEF3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380154,"discussion_content":"看了大佬的学习时长，真的佩服～！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624360563,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":189442,"user_name":"Geek_41d472","can_delete":false,"product_type":"c1","uid":1247965,"ip_address":"","ucode":"DEC2B6329460CF","user_header":"https://static001.geekbang.org/account/avatar/00/13/0a/dd/88fa7b52.jpg","comment_is_top":false,"comment_ctime":1584516460,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879483756","product_id":100039001,"comment_content":"打卡打卡.....滴,学生卡","like_count":1},{"had_liked":false,"id":189429,"user_name":"dongdong","can_delete":false,"product_type":"c1","uid":1638746,"ip_address":"","ucode":"157F0218819C48","user_header":"https://static001.geekbang.org/account/avatar/00/19/01/5a/20632099.jpg","comment_is_top":false,"comment_ctime":1584515210,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879482506","product_id":100039001,"comment_content":"行为模式什么时候更新","like_count":1},{"had_liked":false,"id":189428,"user_name":"毫无根据的沉溺于美妙的幻想","can_delete":false,"product_type":"c1","uid":1456188,"ip_address":"","ucode":"CE318147D99E3D","user_header":"https://static001.geekbang.org/account/avatar/00/16/38/3c/77738aa4.jpg","comment_is_top":false,"comment_ctime":1584515193,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5879482489","product_id":100039001,"comment_content":"回调算是代理模式吗？","like_count":1,"discussions":[{"author":{"id":1181055,"avatar":"https://static001.geekbang.org/account/avatar/00/12/05/7f/d35ab9a1.jpg","nickname":"z.l","note":"","ucode":"805CC5784D3F76","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":91445,"discussion_content":"服务端也有可能是其他服务的客户端啊","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1576834160,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1168960,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d6/40/e1a51ac1.jpg","nickname":"Washington","note":"","ucode":"00F5F36416147D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294994,"discussion_content":"同意，我们做的就只是微服务端的功能。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596060337,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1498641,"avatar":"https://static001.geekbang.org/account/avatar/00/16/de/11/72f96304.jpg","nickname":"M.O(∩_∩)O","note":"","ucode":"B245C2BA20DDA8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":81020,"discussion_content":"作为组件，客户端统一调用处理url ，算法一致，这样比较好吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576213140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1631655,"avatar":"https://static001.geekbang.org/account/avatar/00/18/e5/a7/bf2ca8fc.jpg","nickname":"kyle","note":"","ucode":"53F0E544933798","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79763,"discussion_content":"请老师回答。 按照这样的设计，这个类库是同时分发到客户端和服务端的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576110458,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1397298,"avatar":"https://static001.geekbang.org/account/avatar/00/15/52/32/bb570f48.jpg","nickname":"向往的生活","note":"","ucode":"0E8DB45357820F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1631655,"avatar":"https://static001.geekbang.org/account/avatar/00/18/e5/a7/bf2ca8fc.jpg","nickname":"kyle","note":"","ucode":"53F0E544933798","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287875,"discussion_content":"我也有同样的疑惑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593576137,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":79763,"ip_address":""},"score":287875,"extra":""}]},{"author":{"id":1748647,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/ae/a7/8132305c.jpg","nickname":"曲线J","note":"","ucode":"3E43041EB57A5D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332552,"discussion_content":"可能是不同服务之间的相互调用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607258934,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238993,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e7/d1/9d1c283b.jpg","nickname":"randomx","note":"","ucode":"FC93786244932F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297775,"discussion_content":"我也在疑惑，而且第一点还要接受账号密码作为参数，这不是不安全的吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597053518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1246707,"avatar":"https://static001.geekbang.org/account/avatar/00/13/05/f3/5488276f.jpg","nickname":"心雨鑫晴","note":"","ucode":"37A42C19B98F1D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1238993,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e7/d1/9d1c283b.jpg","nickname":"randomx","note":"","ucode":"FC93786244932F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304153,"discussion_content":"在客户端，是需要用到appId，以及密码来进行摘要信息(也就是token)生成的，使用的都是MD5类似的摘要信息算法。而密码是不会像appId这些一样明文传输的。所以密码是安全的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599482122,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":297775,"ip_address":""},"score":304153,"extra":""}]},{"author":{"id":1528931,"avatar":"https://static001.geekbang.org/account/avatar/00/17/54/63/3a3f7d4c.jpg","nickname":"Giraffe","note":"","ucode":"2F272FFD6CD0CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":186658,"discussion_content":"你们说的有道理，貌似直接暴露参数就可以了，这个ApiRequest有点增加调用方负担了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582703615,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1342184,"avatar":"https://static001.geekbang.org/account/avatar/00/14/7a/e8/0930b207.jpg","nickname":"文文小杰","note":"","ucode":"1D38ED443007AD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77874,"discussion_content":"我也有同样的疑惑，为什么还需要关注URL呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575950417,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1397298,"avatar":"https://static001.geekbang.org/account/avatar/00/15/52/32/bb570f48.jpg","nickname":"向往的生活","note":"","ucode":"0E8DB45357820F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1342184,"avatar":"https://static001.geekbang.org/account/avatar/00/14/7a/e8/0930b207.jpg","nickname":"文文小杰","note":"","ucode":"1D38ED443007AD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287876,"discussion_content":"我也有同样的疑惑呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593576160,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":77874,"ip_address":""},"score":287876,"extra":""},{"author":{"id":2206073,"avatar":"","nickname":"大虫灬过大江","note":"","ucode":"FBF248F35A35B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1397298,"avatar":"https://static001.geekbang.org/account/avatar/00/15/52/32/bb570f48.jpg","nickname":"向往的生活","note":"","ucode":"0E8DB45357820F","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":348994,"discussion_content":"应该是因为token的加密不可逆, 后端没办法直接从token中解析出东西, 只能根据URL APPID TIMESTAMP 自己用同样的加密算法, 生成token, 在对比2各token是否一致","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1612836613,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":287876,"ip_address":""},"score":348994,"extra":""}]}]},{"had_liked":false,"id":189267,"user_name":"峰","can_delete":false,"product_type":"c1","uid":1056019,"ip_address":"","ucode":"C53CB64E8E7D19","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg","comment_is_top":false,"comment_ctime":1584494549,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5879461845","product_id":100039001,"comment_content":"同步回调更像是行为参数化，有点函数式编程的意思。","like_count":1},{"had_liked":false,"id":359558,"user_name":"、BQ","can_delete":false,"product_type":"c1","uid":1132203,"ip_address":"浙江","ucode":"7CAFE074F7C536","user_header":"https://static001.geekbang.org/account/avatar/00/11/46/ab/bae17033.jpg","comment_is_top":false,"comment_ctime":1665644702,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665644702","product_id":100039001,"comment_content":"回调从目的和实现上我认为更类似于观察者模式。<br>目的都是在关注类执行完关注动作后会有一个通知。<br>实现上都是先向关注类注册一个指定类的实现(观察者模式通常是实现类实例，回调通常是匿名内部类或者 Lambda表达式)，再在关注动作完成后会调用此实现；<br>只是回调的注册和关注动作是同一个方法，观察者模式的注册和关注动作是不同方法。","like_count":0},{"had_liked":false,"id":359556,"user_name":"、BQ","can_delete":false,"product_type":"c1","uid":1132203,"ip_address":"浙江","ucode":"7CAFE074F7C536","user_header":"https://static001.geekbang.org/account/avatar/00/11/46/ab/bae17033.jpg","comment_is_top":false,"comment_ctime":1665643975,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665643975","product_id":100039001,"comment_content":"回调从目的和代码套路上我认为更类似于观察者模式<br>目的都是在关注类执行完某个操作后，有一个通知；<br>代码套路上都是注册一个指定类的实现类实例(回调通常是匿名内部类或是 Lambda 表达式)；<br>只是回调的注册和关注方法是同一个，而观察者模式的注册和关注方法是分离的。","like_count":0},{"had_liked":false,"id":351167,"user_name":"谁都会变","can_delete":false,"product_type":"c1","uid":1195017,"ip_address":"","ucode":"9965748F7EBB57","user_header":"https://static001.geekbang.org/account/avatar/00/12/3c/09/b7f0eac6.jpg","comment_is_top":false,"comment_ctime":1657588517,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1657588517","product_id":100039001,"comment_content":"<br>我觉得回调方法的方式，主要给调用者提供实现方法地方，并且不需要额外的继承关系，其次也是对功能的归属划分。","like_count":0},{"had_liked":false,"id":348250,"user_name":"寒光","can_delete":false,"product_type":"c1","uid":1206187,"ip_address":"","ucode":"061BE413595F21","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/ab/fcf0cec4.jpg","comment_is_top":false,"comment_ctime":1654874879,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654874879","product_id":100039001,"comment_content":"把回调、观察者模式和模板方法模式一起对比讲解，真的很赞👍自Java8引入函数式编程后，可以不用自定义回调接口了，直接使用类库提供的即可，再配合lambda表达式，代码非常顺滑。","like_count":0},{"had_liked":false,"id":343106,"user_name":"Lost In The Echo。","can_delete":false,"product_type":"c1","uid":1211954,"ip_address":"","ucode":"6EC7BF57DA3A15","user_header":"https://static001.geekbang.org/account/avatar/00/12/7e/32/e569f729.jpg","comment_is_top":false,"comment_ctime":1650628482,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650628482","product_id":100039001,"comment_content":"模板执行时可以传入回掉发挥更大的作用","like_count":0},{"had_liked":false,"id":324381,"user_name":"Z宇锤锤","can_delete":false,"product_type":"c1","uid":2188142,"ip_address":"","ucode":"7DB36E986A7A51","user_header":"https://static001.geekbang.org/account/avatar/00/21/63/6e/6b971571.jpg","comment_is_top":false,"comment_ctime":1638409840,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1638409840","product_id":100039001,"comment_content":"回调函数就是将自己需要的行为注册到别人那里。自己调用别人的时候，别人就会调用自己注册过去的函数。如果没有回调，这种东西应该怎么实现？","like_count":0,"discussions":[{"author":{"id":1206229,"avatar":"https://static001.geekbang.org/account/avatar/00/12/67/d5/1b26b725.jpg","nickname":"Gopher","note":"","ucode":"3C1F9012BB486D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300916,"discussion_content":"没有说一定不能超过50行的，只是影响阅读体验。做到面向对象，就等于把指指责划分清楚，自然代码就少了，具体到方法就在分在抽象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598319138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324368,"user_name":"Z宇锤锤","can_delete":false,"product_type":"c1","uid":2188142,"ip_address":"","ucode":"7DB36E986A7A51","user_header":"https://static001.geekbang.org/account/avatar/00/21/63/6e/6b971571.jpg","comment_is_top":false,"comment_ctime":1638407209,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1638407209","product_id":100039001,"comment_content":"模板方式和回调方式结合使用。执行逻辑使用回调函数拼装起来。","like_count":0},{"had_liked":false,"id":320505,"user_name":"朱刚","can_delete":false,"product_type":"c1","uid":1080311,"ip_address":"","ucode":"74FD5C1E5C05C4","user_header":"https://static001.geekbang.org/account/avatar/00/10/7b/f7/21fb7574.jpg","comment_is_top":false,"comment_ctime":1636356667,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636356667","product_id":100039001,"comment_content":"回调是不是特殊的观察者模式应用？ 一对多的模式，变成了一对一","like_count":0},{"had_liked":false,"id":318710,"user_name":"千锤百炼领悟之极限","can_delete":false,"product_type":"c1","uid":1744257,"ip_address":"","ucode":"224B5CF2101716","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9d/81/d748b7eb.jpg","comment_is_top":false,"comment_ctime":1635399159,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635399159","product_id":100039001,"comment_content":"hook是一种实现场景，callback更像是一种语法。","like_count":0},{"had_liked":false,"id":318501,"user_name":"sean","can_delete":false,"product_type":"c1","uid":2703237,"ip_address":"","ucode":"B517C6A09A4F07","user_header":"","comment_is_top":false,"comment_ctime":1635316102,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1635316102","product_id":100039001,"comment_content":"模版和回调区别不是太大，但是模版大多都是被动调用的,回调则都是事件驱动的，而且要把回调函数给传进去，会增加复杂度。","like_count":0},{"had_liked":false,"id":317917,"user_name":"Geek_32cca0","can_delete":false,"product_type":"c1","uid":2743957,"ip_address":"","ucode":"A24204F2C0485E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJF8vUICSb6yEleDjtsTe8OrwqmpaoxlicHB7NutCwMMs5ZvsQrguEJ3VL0x5I85jS6xlbrWcMdWKA/132","comment_is_top":false,"comment_ctime":1635052630,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635052630","product_id":100039001,"comment_content":"模版方法和回调都是预留扩展点的一种方式，但是回调更灵活。","like_count":0},{"had_liked":false,"id":314717,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1633344887,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1633344887","product_id":100039001,"comment_content":"回调从应用场景上讲：一定是应用方定制一个逻辑，这个逻辑需要被调用方完成后执行，所以这个扩展是由调用方来决定的。<br>而模板方法模式的扩展是由各自子类决定的。<br>如果是不同系统，那就用回调会更合适也更符合逻辑。","like_count":0},{"had_liked":false,"id":303416,"user_name":"Geek_设计模式之美","can_delete":false,"product_type":"c1","uid":2690172,"ip_address":"","ucode":"59263416E65594","user_header":"","comment_is_top":false,"comment_ctime":1626778587,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626778587","product_id":100039001,"comment_content":"问下 怎么使用 回调 来 优化模板模式呢?  不会...","like_count":0},{"had_liked":false,"id":303105,"user_name":"ZX","can_delete":false,"product_type":"c1","uid":1235583,"ip_address":"","ucode":"0D2622FE6D1774","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/7f/8069035d.jpg","comment_is_top":false,"comment_ctime":1626594078,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626594078","product_id":100039001,"comment_content":"个人感觉，模版模式需要子类重写的方法要做的功能比较固定，但是callback就不限，应用场景不同吧。hook是在某个特定的时机触发，然后比较像观察者模式，不会影响到主流程本身。","like_count":0},{"had_liked":false,"id":301844,"user_name":"AnChen","can_delete":false,"product_type":"c1","uid":1945351,"ip_address":"","ucode":"15DD4CD8DBF97A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK5OShV75tc9yo0E2DEu1vUvdwp2kVSFu2cDaffsJ71Z7zS89HYDbCrqkakTCLXfcNP4HvQkQRkQA/132","comment_is_top":false,"comment_ctime":1625908270,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1625908270","product_id":100039001,"comment_content":"这里还是针对上节课的课后题有一丝疑问，真的采用callback替代模板方法后，会发现模板的内容在callback里面会重复编写，所以其实感觉也算完美","like_count":0},{"had_liked":false,"id":298905,"user_name":"Lee","can_delete":false,"product_type":"c1","uid":1144462,"ip_address":"","ucode":"314D7BCB5C7C24","user_header":"https://static001.geekbang.org/account/avatar/00/11/76/8e/cf43b065.jpg","comment_is_top":false,"comment_ctime":1624364664,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624364664","product_id":100039001,"comment_content":"回调为什么没有被定义为一种设计模式呢？","like_count":0},{"had_liked":false,"id":297757,"user_name":"qlmmys","can_delete":false,"product_type":"c1","uid":1558222,"ip_address":"","ucode":"B9C6B37FF80F06","user_header":"https://static001.geekbang.org/account/avatar/00/17/c6/ce/c1376d80.jpg","comment_is_top":false,"comment_ctime":1623763338,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623763338","product_id":100039001,"comment_content":"我感觉所谓的回调，更像是模板+策略的组合模式。比如文中BClass#process(ICallback callback)的方法实现为模板模式，而ICallback，更像是一个策略接口，可以让使用者实现不同的策略","like_count":0},{"had_liked":false,"id":296377,"user_name":"百川","can_delete":false,"product_type":"c1","uid":2015066,"ip_address":"","ucode":"BCC9D224C09CD6","user_header":"https://static001.geekbang.org/account/avatar/00/1e/bf/5a/824a5e46.jpg","comment_is_top":false,"comment_ctime":1622947718,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622947718","product_id":100039001,"comment_content":"回调的同步和异步不是线程上的异步吧？是时间上的不同步","like_count":0},{"had_liked":false,"id":282142,"user_name":"Asura","can_delete":false,"product_type":"c1","uid":1259901,"ip_address":"","ucode":"985499F24FB49A","user_header":"https://static001.geekbang.org/account/avatar/00/13/39/7d/cafbd583.jpg","comment_is_top":false,"comment_ctime":1615106367,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615106367","product_id":100039001,"comment_content":"当延迟的行为比较容易归类或者场景较少时，使用经典的模版模式比较合适<br>当延迟的行为无法预测或者场景很多时，只能由使用者(client)确认时，callback比较合适<br><br>当然，我们可以直接定义两个接口方法，一个提供callback，一个由子类实现。实现几个常用的子类算法。","like_count":0},{"had_liked":false,"id":280254,"user_name":"Geek_199356","can_delete":false,"product_type":"c1","uid":2443102,"ip_address":"","ucode":"1681490C838F0D","user_header":"","comment_is_top":false,"comment_ctime":1614143958,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614143958","product_id":100039001,"comment_content":"iptables就是在netfilter中预设五个hook从而实现规则的下发，所以一般hook强调的是设计方法而callback是具体实现","like_count":0},{"had_liked":false,"id":279398,"user_name":"王小日","can_delete":false,"product_type":"c1","uid":1121242,"ip_address":"","ucode":"565B09B6FC53C7","user_header":"https://static001.geekbang.org/account/avatar/00/11/1b/da/e782b2b6.jpg","comment_is_top":false,"comment_ctime":1613749910,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613749910","product_id":100039001,"comment_content":"虽然说是回调模式优于模板模式，但是针对不同的调用方来说，需要在传递回调对象之前确定回调对象的实现类，不得不说又是这种模式的副作用。","like_count":0},{"had_liked":false,"id":271603,"user_name":"那风在极客","can_delete":false,"product_type":"c1","uid":1026502,"ip_address":"","ucode":"132B9263006BB9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a9/c6/30b29c22.jpg","comment_is_top":false,"comment_ctime":1609729180,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609729180","product_id":100039001,"comment_content":"Callback 是一种 Hook, Hook 可以是 Callback，也可以是模版方法中那些需要实现的（抽象）方法。Callback 是作为参数传递的，Hook 则不必是参数，可以是属性，是子类方法。","like_count":0},{"had_liked":false,"id":270512,"user_name":"David","can_delete":false,"product_type":"c1","uid":1021825,"ip_address":"","ucode":"22CBBC13FC97A9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/97/81/e1eaf621.jpg","comment_is_top":false,"comment_ctime":1609148436,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1609148436","product_id":100039001,"comment_content":"callback 和hook 都是事先定义好约定 特定条件下触发","like_count":0},{"had_liked":false,"id":269633,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1608721313,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608721313","product_id":100039001,"comment_content":"模版方法相当于系统内部逻辑耦合，对外提供可扩展属性，而回调的场景，是系统与系统之间的调用。系统间解耦","like_count":0},{"had_liked":false,"id":267953,"user_name":"sta","can_delete":false,"product_type":"c1","uid":1032755,"ip_address":"","ucode":"D840070850EA5B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c2/33/ccbf2045.jpg","comment_is_top":false,"comment_ctime":1608006331,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608006331","product_id":100039001,"comment_content":"我也觉得回调是一种技术手段，它的本质就是通过组合调用其他对象的方法，说白了就是组合的应用方式，只不过回调是侧重于回调方法的使用，所以才叫做回调，本质其实应该叫组合调用。<br><br>观察者模式本质就是一个方法中有多个回调，就是有多个组合调用。不过我们叫它观察者模式就是侧重于它有一个被观察者，多个观察者，且观察者是统一在被观察者的某个流程点统一执行的。<br><br>而模板模式我觉得本质就是继承机制，不过我们叫它模板模式就是侧重于它的流程固定（代码复用）和可扩展","like_count":0},{"had_liked":false,"id":257539,"user_name":"anyway","can_delete":false,"product_type":"c1","uid":1125781,"ip_address":"","ucode":"F51A3B14AF3120","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/95/a62dd74d.jpg","comment_is_top":false,"comment_ctime":1604023576,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604023576","product_id":100039001,"comment_content":"回调函数更加灵活，模板更加通用","like_count":0},{"had_liked":false,"id":252669,"user_name":"大方方","can_delete":false,"product_type":"c1","uid":1354013,"ip_address":"","ucode":"621AD8F1485753","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/6cyOoRd2dROgiblAJkW6RLhUyH1wwU0NNibIIuV930eQ9TiaNT41K61kBSVkvYoDYg7mJtuEoCQY1awBmV0WW6BFg/132","comment_is_top":false,"comment_ctime":1602428606,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602428606","product_id":100039001,"comment_content":"自从学会callback后 一直都觉得很灵活方便，但是从没有从设计模式的角度来归类看待这个功能。另外 开篇在解释回调的概念时，个人也是觉得简洁明朗，学习编程初期 这个回调概念真是花了些力气去理解，很多中文教程例子都是越绕越晕。","like_count":0},{"had_liked":false,"id":245269,"user_name":"龙猫","can_delete":false,"product_type":"c1","uid":1112490,"ip_address":"","ucode":"FD726CC969EF9C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/aa/3e80212e.jpg","comment_is_top":false,"comment_ctime":1598881381,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598881381","product_id":100039001,"comment_content":"jquery中的回调函数多","like_count":0},{"had_liked":false,"id":243960,"user_name":"Java垒墙工程师","can_delete":false,"product_type":"c1","uid":1937062,"ip_address":"","ucode":"E76AE44A9C76AE","user_header":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","comment_is_top":false,"comment_ctime":1598340588,"is_pvip":false,"replies":[{"id":"90139","content":"有点，不过权衡利弊吧，没有绝对的完美。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1598834280,"ip_address":"","comment_id":243960,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1598340588","product_id":100039001,"comment_content":"回调的方式是不是打乱了系统调用的层次？相互依赖，依赖关系变得复杂","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502293,"discussion_content":"isExpired()只用来判断是否过期，match()用来判断是否错误","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596112185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241340,"user_name":"Next","can_delete":false,"product_type":"c1","uid":1748213,"ip_address":"","ucode":"D5ADDF248A9504","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ac/f5/2f97e279.jpg","comment_is_top":false,"comment_ctime":1597253155,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597253155","product_id":100039001,"comment_content":"回调与模板比较：<br>\t- 相同目的的不同实现，回调基于组合，模板基于继承<br>\t- 适用场景：<br>\t\t○ 回调可以使用匿名类来创建回调对象，适用于有无限实现的子类；<br>\t\t○ 模板模式针对不同的实现都要预定义不同的子类，适用于逻辑骨架中有多个维度变化的子实现<br>        - 同步回调比较像模板，异步回调比较像观察者","like_count":0},{"had_liked":false,"id":236848,"user_name":"Obed","can_delete":false,"product_type":"c1","uid":1399904,"ip_address":"","ucode":"8717488DD14AB4","user_header":"https://static001.geekbang.org/account/avatar/00/15/5c/60/3754399d.jpg","comment_is_top":false,"comment_ctime":1595562594,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595562594","product_id":100039001,"comment_content":"回调看起来有点像策略模式啊 我们自己实现的逻辑就是一个算法,可以灵活地替换策略","like_count":0},{"had_liked":false,"id":232884,"user_name":"maybe","can_delete":false,"product_type":"c1","uid":1475528,"ip_address":"","ucode":"93D160F617E750","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/c8/5ce842f6.jpg","comment_is_top":false,"comment_ctime":1594139041,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1594139041","product_id":100039001,"comment_content":"回调和模版模式都可以达到复用和扩展的目的。同步回调和模版模式相似，异步回调更像观察者模式。按照组合优于继承的设计思想，回调方式更加灵活。","like_count":0},{"had_liked":false,"id":231659,"user_name":"向往的生活","can_delete":false,"product_type":"c1","uid":1397298,"ip_address":"","ucode":"0E8DB45357820F","user_header":"https://static001.geekbang.org/account/avatar/00/15/52/32/bb570f48.jpg","comment_is_top":false,"comment_ctime":1593743866,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1593743866","product_id":100039001,"comment_content":"怎么回调函数没执行呀","like_count":0},{"had_liked":false,"id":228315,"user_name":"cloudzqy","can_delete":false,"product_type":"c1","uid":1421828,"ip_address":"","ucode":"6C54F0E949A87B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epByENqgJ0MGdCYU13rMD7RQdHolkR79clla6oe3QO0kjIjwZqOnkjrZ9DV1Fe9lWSPswgTQ7H2pw/132","comment_is_top":false,"comment_ctime":1592640151,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592640151","product_id":100039001,"comment_content":"前端react的Component继承，也是一种典型的模板模式了，让用户自己去实现render。","like_count":0},{"had_liked":false,"id":226790,"user_name":"蹦哒","can_delete":false,"product_type":"c1","uid":1458931,"ip_address":"","ucode":"56591A657DE7C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epcs6PibsP9vEXv4EibUw3bhQPUK04zRTOvfrvF08TwM67xPb1LBh2uRENHQwo2VqYfC5GhJmM7icxHA/132","comment_is_top":false,"comment_ctime":1592205274,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592205274","product_id":100039001,"comment_content":"据我所知，JavaScript一般是叫Callback，在OC中，对于系统框架的扩展一般叫hook，业务的扩展叫Callback","like_count":0},{"had_liked":false,"id":225038,"user_name":"肖臧","can_delete":false,"product_type":"c1","uid":1047733,"ip_address":"","ucode":"4FAC9FF54DD6A0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fc/b5/ac717737.jpg","comment_is_top":false,"comment_ctime":1591622938,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591622938","product_id":100039001,"comment_content":"“我们在注册完 Hook 之后，并不需要等待 Hook 执行完成，所以，这也算是一种异步回调”这句话会引起歧义吧，子线程调用了join方法，主线程须等子线程执行完毕后，才能继续。","like_count":0},{"had_liked":false,"id":218169,"user_name":"fly","can_delete":false,"product_type":"c1","uid":1025992,"ip_address":"","ucode":"D1F6938C9CE15D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a7/c8/5608cbdb.jpg","comment_is_top":false,"comment_ctime":1589727300,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589727300","product_id":100039001,"comment_content":"回调函数跟命令模式的实现好像","like_count":0},{"had_liked":false,"id":211478,"user_name":"佐西玛","can_delete":false,"product_type":"c1","uid":1090743,"ip_address":"","ucode":"73AAED82340E2B","user_header":"https://static001.geekbang.org/account/avatar/00/10/a4/b7/e0d88365.jpg","comment_is_top":false,"comment_ctime":1587970359,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587970359","product_id":100039001,"comment_content":"1、<br>1.1 callback和hook相同点：作用是相同的，都是定义好骨架，将某些方法推迟到子类中去执行，与模板模式的作用是一样的。<br>1.2 callback和hook的不同点：实现不同，callback是通过继承实现的，hook是通过组合实现的。<br>通过继承实现：以AClass和BClass为例：B.process方法提供了算法骨架，A在调用B.process时，继承ICallBack去实现了methodToCallBack方法，将特定的方法延迟到了A里执行。<br>通过组合实现：以addShutDownHooks为例：在ApplicationShutdownHooks的组合hooks里添加一个特定的hook,在里该类的runHooks里去执行hook。<br>2、我们有一个定时执行的方法，就使用了回调。","like_count":0},{"had_liked":false,"id":210771,"user_name":"茶没喝完","can_delete":false,"product_type":"c1","uid":1644104,"ip_address":"","ucode":"D72D88C42A1258","user_header":"https://static001.geekbang.org/account/avatar/00/19/16/48/09493874.jpg","comment_is_top":false,"comment_ctime":1587823624,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587823624","product_id":100039001,"comment_content":"讲的真好，收获很大！！！","like_count":0},{"had_liked":false,"id":205611,"user_name":"番茄炒西红柿","can_delete":false,"product_type":"c1","uid":1690242,"ip_address":"","ucode":"13F47BABAB2110","user_header":"https://static001.geekbang.org/account/avatar/00/19/ca/82/85f6a1a2.jpg","comment_is_top":false,"comment_ctime":1586683960,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586683960","product_id":100039001,"comment_content":"貌似有吐槽java对callback的支持不好，容易写成回调地狱，想到回调其实我最先想到是函数编程","like_count":0},{"had_liked":false,"id":202252,"user_name":"谷雨","can_delete":false,"product_type":"c1","uid":1225827,"ip_address":"","ucode":"E8566AD0E2A521","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKkkZBpiaOo4dGUuOXnRusBwcYCcwPTU8Pn41zbKh9py4Nwcf1rtc8A6yH5AtVVbkv8iaoS6hFgKevg/132","comment_is_top":false,"comment_ctime":1585936797,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585936797","product_id":100039001,"comment_content":"答题：<br>对于前端而言，所有的代码执行，都跑在 EventLoop 上，事件驱动循环执行。Callback 对我们而言，是异步调用后，处理异步处理结果的入口。而 hook，在前端这边，十分普遍用到的是生命周期钩子，如创建时、数据变更后、销毁前。","like_count":0},{"had_liked":false,"id":201209,"user_name":"pines","can_delete":false,"product_type":"c1","uid":1200708,"ip_address":"","ucode":"7B925605B36B4E","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/44/de7f2b98.jpg","comment_is_top":false,"comment_ctime":1585733171,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585733171","product_id":100039001,"comment_content":"我比较困扰的一个问题是装饰器与Hook，两个的作用都是扩展一段代码的功能（抽离与业务无关的代码）。例如打印http请求的req与res 用两种方式都可以做。我理解装饰器是一种设计模式，Hook是一种应用场景，只不过在我上面提的例子中 可以使用装饰器实现这种Hook功能罢了，希望大家和老师能解答一下。","like_count":0},{"had_liked":false,"id":198861,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1585470701,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585470701","product_id":100039001,"comment_content":"设计模式_59:<br># 作业<br>Android开发里，hook与callback非常不同。hook可以用来改变默认的执行流程，比如很多国内的插件化框架就是使用hook来绕过Android系统的检测(Android默认不允许运行时修改执行代码) ，从而具备插件化(运行时动态更新)能力的。<br><br># 感想<br>对于一个业务和流程，不同的人认知是不同的，就像今天的callback和hook，就像第一次看别人代码的痛苦。。。","like_count":0},{"had_liked":false,"id":198635,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1585461042,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585461042","product_id":100039001,"comment_content":"一语惊醒梦中人<br>","like_count":0},{"had_liked":false,"id":196585,"user_name":"eason2017","can_delete":false,"product_type":"c1","uid":1009422,"ip_address":"","ucode":"E070BA624FA490","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/0e/c77ad9b1.jpg","comment_is_top":false,"comment_ctime":1585295058,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585295058","product_id":100039001,"comment_content":"javascript里包含了回调叫callback，小程序开发也类似。","like_count":0},{"had_liked":false,"id":195177,"user_name":"斐波那契","can_delete":false,"product_type":"c1","uid":1464006,"ip_address":"","ucode":"85E2EBC01392B1","user_header":"https://static001.geekbang.org/account/avatar/00/16/56/c6/0b449bc6.jpg","comment_is_top":false,"comment_ctime":1585144143,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585144143","product_id":100039001,"comment_content":"callback这个词最早是在js里接触到的 在java里接触到类似的是闭包 然后在开发中 就算使用到“回调”也一般不使用callback这个词 只有唯一一次看到使用某种“回调”叫hook的项目 那个时候才接触到hook 所有对于我而言 callback更偏向于一种思想 一种编程范式 而hook就是某种特定语言对回调的一种实现","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477126,"discussion_content":"多谢建议，你说的没错，ApiRequest确实还是依赖了url","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575896622,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1047733,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fc/b5/ac717737.jpg","nickname":"肖臧","note":"","ucode":"4FAC9FF54DD6A0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":205184,"discussion_content":"所以搞个泛型应该更合适","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584276720,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":194464,"user_name":"Asura","can_delete":false,"product_type":"c1","uid":1259901,"ip_address":"","ucode":"985499F24FB49A","user_header":"https://static001.geekbang.org/account/avatar/00/13/39/7d/cafbd583.jpg","comment_is_top":false,"comment_ctime":1585060838,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585060838","product_id":100039001,"comment_content":"关于同步和异步，本质上是要看是不是两个不同的线程。只有多线程才会有异步，网络回调从整体上看也是两个线程，所以是异步。","like_count":0},{"had_liked":false,"id":194240,"user_name":"空白昵称","can_delete":false,"product_type":"c1","uid":1433815,"ip_address":"","ucode":"91F50CA25102AB","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/d7/744bd8c3.jpg","comment_is_top":false,"comment_ctime":1585040258,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585040258","product_id":100039001,"comment_content":"回调简化：如java8中的lamba 表达式。swift中的closure。目前感觉使用hook命名的较少，只记得很早之前做过一个后台记录系统键盘操作的代码，用到了hook，觉得更偏向于应用吧","like_count":0},{"had_liked":false,"id":194134,"user_name":"明翼","can_delete":false,"product_type":"c1","uid":1068361,"ip_address":"","ucode":"E77F86BEB3D5C1","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/49/28e73b9c.jpg","comment_is_top":false,"comment_ctime":1585029435,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585029435","product_id":100039001,"comment_content":"我在写c代码的时候也用回调进行封装，公用了部分函数，具体实现通过查表的方式回调不同的协议处理方法，真的不错。","like_count":0},{"had_liked":false,"id":193948,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1585005512,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585005512","product_id":100039001,"comment_content":"我在自己的主备选举组件中也是使用的回调机制，偏向于callback吧。有时候在程序异常退出的时候，使用hook钩子函数去处理产生dump等情况。在我看来两者基本差不多。","like_count":0},{"had_liked":false,"id":193055,"user_name":"LiuHu","can_delete":false,"product_type":"c1","uid":1039768,"ip_address":"","ucode":"284E2025C554BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/dd/98/883c42b4.jpg","comment_is_top":false,"comment_ctime":1584883225,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584883225","product_id":100039001,"comment_content":"函数是一等公民作为参数传递给框架类，就是客户端将一段代码传递给框架类执行。<br>文中的示例代码，ICallback 接口可以用Runable接口替代，使用Java8 函数式编程可以改造成：<br>public class BClass {<br>        public void process(Runnable processor) {<br>            &#47;&#47; ...<br>            processor.run();<br>            &#47;&#47; ...<br>        }<br>    }<br>    public class AClass {<br>        public static void main(String[] args) {<br>            BClass b = new BClass();<br>            b.process(() -&gt; System.out.println(&quot;Call back me&quot;));<br>        }<br>    }<br>","like_count":0},{"had_liked":false,"id":192028,"user_name":"Geek_3b1096","can_delete":false,"product_type":"c1","uid":1549364,"ip_address":"","ucode":"A6BD92B79B3632","user_header":"","comment_is_top":false,"comment_ctime":1584817152,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584817152","product_id":100039001,"comment_content":"js是Callback","like_count":0}]}