{"id":417384,"title":"10｜生命周期：你创建的值究竟能活多久？","content":"<p>你好，我是陈天。</p><p>之前提到过，在任何语言里，栈上的值都有自己的生命周期，它和帧的生命周期一致，而 Rust，进一步明确这个概念，并且为堆上的内存也引入了生命周期。</p><p>我们知道，在其它语言中，堆内存的生命周期是不确定的，或者是未定义的。因此，要么开发者手工维护，要么语言在运行时做额外的检查。而在 Rust 中，除非显式地做 Box::leak() / Box::into_raw() / ManualDrop 等动作，<strong>一般来说，堆内存的生命周期，会默认和其栈内存的生命周期绑定在一起</strong>。</p><p>所以在这种默认情况下，在每个函数的作用域中，编译器就可以对比值和其引用的生命周期，来确保“引用的生命周期不超出值的生命周期”。</p><p>那你有没有想过，Rust 编译器是如何做到这一点的呢？</p><h2>值的生命周期</h2><p>在进一步讨论之前，我们先给值可能的生命周期下个定义。</p><p>如果一个值的生命周期<strong>贯穿整个进程的生命周期</strong>，那么我们就称这种生命周期为<strong>静态生命周期</strong>。</p><p>当值拥有静态生命周期，其引用也具有静态生命周期。我们在表述这种引用的时候，可以用 <code>'static</code> 来表示。比如： <code>&amp;'static str</code>  代表这是一个具有静态生命周期的字符串引用。</p><p>一般来说，全局变量、静态变量、字符串字面量（string literal）等，都拥有静态生命周期。我们上文中提到的堆内存，如果使用了 <code>Box::leak</code> 后，也具有静态生命周期。</p><!-- [[[read_end]]] --><p>如果一个值是<strong>在某个作用域中定义的</strong>，也就是说它被创建在栈上或者堆上，那么其<strong>生命周期是动态的</strong>。</p><p>当这个值的作用域结束时，值的生命周期也随之结束。对于动态生命周期，我们约定用 <code>'a</code> 、<code>'b</code> 或者  <code>'hello</code> 这样的小写字符或者字符串来表述。 <code>'</code> 后面具体是什么名字不重要，它代表某一段动态的生命周期，其中， <code>&amp;'a str</code> 和 <code>&amp;'b str</code> 表示这两个字符串引用的生命周期可能不一致。</p><p>我们通过图总结一下：<br>\n<img src=\"https://static001.geekbang.org/resource/image/8f/7d/8fdc22d8ef77ecfab5d317f169a0827d.jpg?wh=2312x1394\" alt=\"\"></p><ul>\n<li>分配在堆和栈上的内存有其各自的作用域，它们的生命周期是动态的。</li>\n<li>全局变量、静态变量、字符串字面量、代码等内容，在编译时，会被编译到可执行文件中的 BSS/Data/RoData/Text 段，然后在加载时，装入内存。因而，它们的生命周期和进程的生命周期一致，所以是静态的。</li>\n<li>所以，函数指针的生命周期也是静态的，因为函数在 Text 段中，只要进程活着，其内存一直存在。</li>\n</ul><p>明白了这些基本概念后，我们来看对于值和引用，编译器是如何识别其生命周期的。</p><h2>编译器如何识别生命周期</h2><p>我们先从两个最基本最简单的例子开始。</p><p>左图的<a href=\"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=59e63cc46902389788bc3183e03351b9\">例1 </a>，x 引用了在内层作用域中创建出来的变量 y。由于，变量从开始定义到其作用域结束的这段时间，是它的生命周期，所以 x 的生命周期 'a 大于 y 的生命周期 'b，当 x 引用 y 时，编译器报错。</p><p>右图<a href=\"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=aa0282076b5beece953aab685d175430\">例 2</a> 中，y 和 x 处在同一个作用域下， x 引用了 y，我们可以看到 x 的生命周期 'a 和 y 的生命周期 'b 几乎同时结束，或者说 'a 小于等于 'b，所以，x 引用 y 是可行的。</p><p><img src=\"https://static001.geekbang.org/resource/image/77/ee/77e63343dceb8ddb87460e482db1c9ee.jpg?wh=4231x1431\" alt=\"\"></p><p>这两个小例子很好理解，我们再看个稍微复杂一些的。</p><p>示例代码在 main() 函数里创建了两个 String，然后将其传入 max() 函数比较大小。max() 函数接受两个字符串引用，返回其中较大的那个字符串的引用（<a href=\"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=4a4267725a2c0ed1e58318352ed1774b\">示例代码</a>）：</p><pre><code class=\"language-rust\">fn main() {\n    let s1 = String::from(\"Lindsey\");\n    let s2 = String::from(\"Rosie\");\n\n    let result = max(&amp;s1, &amp;s2);\n\n    println!(\"bigger one: {}\", result);\n}\n\nfn max(s1: &amp;str, s2: &amp;str) -&gt; &amp;str {\n    if s1 &gt; s2 {\n        s1\n    } else {\n        s2\n    }\n}\n</code></pre><p>这段代码是无法编译通过的，它会报错 “missing lifetime specifier” ，也就是说，<strong>编译器在编译 max() 函数时，无法判断 s1、s2 和返回值的生命周期</strong>。</p><p>你是不是很疑惑，站在我们开发者的角度，这个代码理解起来非常直观，在 main() 函数里 s1 和 s2 两个值生命周期一致，它们的引用传给 max() 函数之后，无论谁的被返回，生命周期都不会超过 s1 或 s2。所以这应该是一段正确的代码啊？</p><p>为什么编译器报错了，不允许它编译通过呢？我们把这段代码稍微扩展一下，你就能明白编译器的困惑了。</p><p>在刚才的示例代码中，我们创建一个新的函数 get_max()，它接受一个字符串引用，然后和 “Cynthia” 这个字符串字面量比较大小。之前我们提到，<strong>字符串字面量的生命周期是静态的，而 s1 是动态的，它们的生命周期显然不一致</strong>（<a href=\"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=7b265ea1b5358cf8a60b0d94e5c1131f\">代码</a>）：</p><pre><code class=\"language-rust\">fn main() {\n    let s1 = String::from(\"Lindsey\");\n    let s2 = String::from(\"Rosie\");\n\n    let result = max(&amp;s1, &amp;s2);\n\n    println!(\"bigger one: {}\", result);\n\n    let result = get_max(&amp;s1);\n    println!(\"bigger one: {}\", result);\n}\n\nfn get_max(s1: &amp;str) -&gt; &amp;str {\n    max(s1, \"Cynthia\")\n}\n\nfn max(s1: &amp;str, s2: &amp;str) -&gt; &amp;str {\n    if s1 &gt; s2 {\n        s1\n    } else {\n        s2\n    }\n}\n</code></pre><p>当出现了多个参数，它们的生命周期可能不一致时，返回值的生命周期就不好确定了。编译器在编译某个函数时，并不知道这个函数将来有谁调用、怎么调用，所以，<strong>函数本身携带的信息，就是编译器在编译时使用的全部信息</strong>。</p><p>根据这一点，我们再看示例代码，在编译 max() 函数时，参数 s1 和 s2 的生命周期是什么关系、返回值和参数的生命周期又有什么关系，编译器是无法确定的。</p><p>此时，就需要我们在函数签名中提供生命周期的信息，也就是生命周期标注（lifetime specifier）。在生命周期标注时，使用的参数叫生命周期参数（lifetime parameter）。通过生命周期标注，我们告诉编译器这些引用间生命周期的约束。</p><p>生命周期参数的描述方式和泛型参数一致，不过只使用小写字母。这里，两个入参 s1、 s2，以及返回值都用  <code>'a</code> 来约束。<strong>生命周期参数，描述的是参数和参数之间、参数和返回值之间的关系，并不改变原有的生命周期</strong>。</p><p>在我们添加了生命周期参数后，s1 和 s2 的生命周期只要大于等于（outlive） <code>'a</code>，就符合参数的约束，而返回值的生命周期同理，也需要大于等于  <code>'a</code> 。</p><p>在你运行上述示例代码的时候，编译器已经提示你，可以这么修改 max() 函数：</p><pre><code class=\"language-rust\">fn max&lt;'a&gt;(s1: &amp;'a str, s2: &amp;'a str) -&gt; &amp;'a str {\n    if s1 &gt; s2 {\n        s1\n    } else {\n        s2\n    }\n}\n</code></pre><p>当 main() 函数调用 max() 函数时，s1 和 s2 有相同的生命周期 <code>'a</code> ，所以它满足  <code>(s1: &amp;'a str, s2: &amp;'a str)</code> 的约束。当 get_max() 函数调用 max() 时，“Cynthia” 是静态生命周期，它大于 s1 的生命周期<code>'a</code> ，所以它也可以满足 max() 的约束需求。</p><h2>你的引用需要额外标注吗</h2><p>学到这里，你可能会有困惑了：为什么我之前写的代码，很多函数的参数或者返回值都使用了引用，编译器却没有提示我要额外标注生命周期呢？</p><p>这是因为编译器希望尽可能减轻开发者的负担，其实所有使用了引用的函数，都需要生命周期的标注，只不过编译器会自动做这件事，省却了开发者的麻烦。</p><p>比如这个例子，first() 函数接受一个字符串引用，找到其中的第一个单词并返回（<a href=\"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=bc4cbb73469c683dc3fee03c44eb8e65\">代码</a>）：</p><pre><code class=\"language-rust\">fn main() {\n    let s1 = \"Hello world\";\n\n    println!(\"first word of s1: {}\", first(&amp;s1));\n}\n\nfn first(s: &amp;str) -&gt; &amp;str {\n    let trimmed = s.trim();\n    match trimmed.find(' ') {\n        None =&gt; \"\",\n        Some(pos) =&gt; &amp;trimmed[..pos],\n    }\n}\n</code></pre><p>虽然我们没有做任何生命周期的标注，但编译器会通过一些简单的规则为函数自动添加标注：</p><ol>\n<li>所有引用类型的参数都有独立的生命周期  <code>'a</code> 、<code>'b</code> 等。</li>\n<li>如果只有一个引用型输入，它的生命周期会赋给所有输出。</li>\n<li>如果有多个引用类型的参数，其中一个是 self，那么它的生命周期会赋给所有输出。</li>\n</ol><p>规则 3 适用于 trait 或者自定义数据类型，我们先放在一边，以后遇到会再详细讲的。例子中的 first() 函数通过规则 1 和 2，可以得到一个带生命周期的版本（<a href=\"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=5886937147cd5485533185415451431b\">代码</a>）：</p><pre><code class=\"language-rust\">fn first&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {\n    let trimmed = s.trim();\n    match trimmed.find(' ') {\n        None =&gt; \"\",\n        Some(pos) =&gt; &amp;trimmed[..pos],\n    }\n}\n</code></pre><p>你可以看到，所有引用都能正常标注，没有冲突。那么对比之前返回较大字符串的示例代码（<a href=\"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=4a4267725a2c0ed1e58318352ed1774b\">示例代码</a>）， max() 函数为什么编译器无法处理呢？</p><p>按照规则 1， 我们可以对max() 函数的参数 s1 和 s2 分别标注<code>'a</code> 和<code>'b</code> ，但是<strong>返回值如何标注？是 <code>'a</code> 还是<code>'b</code> 呢？这里的冲突，编译器无能为力</strong>。</p><pre><code class=\"language-rust\">fn max&lt;'a, 'b&gt;(s1: &amp;'a str, s2: &amp;'b str) -&gt; &amp;'??? str\n</code></pre><p>所以，只有我们明白了代码逻辑，才能正确标注参数和返回值的约束关系，顺利编译通过。</p><h3>引用标注小练习</h3><p>好，Rust的生命周期这个知识点我们就讲完了，接下来我们来尝试写一个字符串分割函数strtok()，即时练习一下，如何加引用标注。</p><p>相信有过 C/C++ 经验的开发者都接触过这个strtok()函数，它会把字符串按照分隔符（delimiter）切出一个 token 并返回，然后将传入的字符串引用指向后续的 token。</p><p>用 Rust 实现并不困难，由于传入的 s 需要可变的引用，所以它是一个指向字符串引用的可变引用  <code>&amp;mut &amp;str</code>（<a href=\"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=bdf78a5b2573da5791040c05ff0e8c42\">练习代码</a>）：</p><pre><code class=\"language-rust\">pub fn strtok(s: &amp;mut &amp;str, delimiter: char) -&gt; &amp;str {\n    if let Some(i) = s.find(delimiter) {\n        let prefix = &amp;s[..i];\n        // 由于 delimiter 可以是 utf8，所以我们需要获得其 utf8 长度，\n        // 直接使用 len 返回的是字节长度，会有问题\n        let suffix = &amp;s[(i + delimiter.len_utf8())..];\n        *s = suffix;\n        prefix\n    } else { // 如果没找到，返回整个字符串，把原字符串指针 s 指向空串\n        let prefix = *s;\n        *s = \"\";\n        prefix\n    }\n}\n\nfn main() {\n    let s = \"hello world\".to_owned();\n    let mut s1 = s.as_str();\n    let hello = strtok(&amp;mut s1, ' ');\n    println!(\"hello is: {}, s1: {}, s: {}\", hello, s1, s);\n}\n</code></pre><p>当我们尝试运行这段代码时，会遇到生命周期相关的编译错误。类似刚才讲的示例代码，是因为按照编译器的规则， <code>&amp;mut &amp;str</code> 添加生命周期后变成  <code>&amp;'b mut &amp;'a str</code>，这将导致返回的  <code>'&amp;str</code> 无法选择一个合适的生命周期。</p><p>要解决这个问题，我们首先要思考一下：返回值和谁的生命周期有关？是指向字符串引用的可变引用 &amp;mut ，还是字符串引用 &amp;str 本身？</p><p>显然是后者。所以，我们可以为 strtok 添加生命周期标注：</p><pre><code class=\"language-rust\">pub fn strtok&lt;'b, 'a&gt;(s: &amp;'b mut &amp;'a str, delimiter: char) -&gt; &amp;'a str {...}\n</code></pre><p>因为返回值的生命周期跟字符串引用有关，我们只为这部分的约束添加标注就可以了，剩下的标注交给编译器自动添加，所以代码也可以简化成如下这样，让编译器将其扩展成上面的形式：</p><pre><code class=\"language-rust\">pub fn strtok&lt;'a&gt;(s: &amp;mut &amp;'a str, delimiter: char) -&gt; &amp;'a str {...}\n</code></pre><p>最终，正常工作的代码如下（<a href=\"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=543082912a7b0c3f7a8c458bb7a45bb8\">练习代码_改</a>），可以通过编译：</p><pre><code class=\"language-rust\">pub fn strtok&lt;'a&gt;(s: &amp;mut &amp;'a str, delimiter: char) -&gt; &amp;'a str {\n    if let Some(i) = s.find(delimiter) {\n        let prefix = &amp;s[..i];\n        let suffix = &amp;s[(i + delimiter.len_utf8())..];\n        *s = suffix;\n        prefix\n    } else {\n        let prefix = *s;\n        *s = \"\";\n        prefix\n    }\n}\n\nfn main() {\n    let s = \"hello world\".to_owned();\n    let mut s1 = s.as_str();\n    let hello = strtok(&amp;mut s1, ' ');\n    println!(\"hello is: {}, s1: {}, s: {}\", hello, s1, s);\n}\n</code></pre><p>为了帮助你更好地理解这个函数的生命周期关系，我将每个堆上和栈上变量的关系画了个图供你参考。</p><p><img src=\"https://static001.geekbang.org/resource/image/97/83/97a6byy90566585499eabf4feda14783.jpg?wh=4151x2997\" alt=\"\"></p><p>这里跟你分享一个小技巧：如果你觉得某段代码理解或者分析起来很困难，也可以画类似的图，从最基础的数据在堆和栈上的关系开始想，就很容易厘清脉络。</p><p>在处理生命周期时，编译器会根据一定规则自动添加生命周期的标注。然而，当自动标注产生冲突时，需要我们手工标注。</p><p><strong>生命周期标注的目的是，在参数和返回值之间建立联系或者约束</strong>。调用函数时，传入的参数的生命周期需要大于等于（outlive）标注的生命周期。</p><p>当每个函数都添加好生命周期标注后，编译器，就可以从函数调用的上下文中分析出，在传参时，引用的生命周期，是否和函数签名中要求的生命周期匹配。如果不匹配，就违背了“引用的生命周期不能超出值的生命周期”，编译器就会报错。</p><p>如果你搞懂了函数的生命周期标注，那么数据结构的生命周期标注也是类似。比如下面的例子，Employee 的 name 和 title 是两个字符串引用，Employee 的生命周期不能大于它们，否则会访问失效的内存，因而我们需要妥善标注：</p><pre><code class=\"language-rust\">struct Employee&lt;'a, 'b&gt; {\n  name: &amp;'a str,\n  title: &amp;'b str,\n  age: u8,\n}\n</code></pre><p>使用数据结构时，数据结构自身的生命周期，需要小于等于其内部字段的所有引用的生命周期。</p><h2>小结</h2><p>今天我们介绍了静态生命周期和动态生命周期的概念，以及编译器如何识别值和引用的生命周期。<br>\n<img src=\"https://static001.geekbang.org/resource/image/8f/7d/8fdc22d8ef77ecfab5d317f169a0827d.jpg?wh=2312x1394\" alt=\"\"><br>\n根据所有权规则，值的生命周期可以确认，它可以一直存活到所有者离开作用域；而引用的生命周期不能超过值的生命周期。在同一个作用域下，这是显而易见的。然而，<strong>当发生函数调用时，编译器需要通过函数的签名来确定，参数和返回值之间生命周期的约束</strong>。</p><p>大多数情况下，编译器可以通过上下文中的规则，自动添加生命周期的约束。如果无法自动添加，则需要开发者手工来添加约束。一般，我们只需要确定好返回值和哪个参数的生命周期相关就可以了。而对于数据结构，当内部有引用时，我们需要为引用标注生命周期。</p><h2>思考题</h2><ol>\n<li>如果我们把 strtok() 函数的签名写成这样，会发生什么问题？为什么它会发生这个问题？你可以试着编译一下看看。</li>\n</ol><pre><code class=\"language-rust\">pub fn strtok&lt;'a&gt;(s: &amp;'a mut &amp;str, delimiter: char) -&gt; &amp;'a str {...}\n</code></pre><ol start=\"2\">\n<li>回顾<a href=\"https://time.geekbang.org/column/article/414478\">第 6 讲SQL查询工具</a>的代码，现在，看看你是不是对代码中的生命周期标注有了更深理解？</li>\n</ol><p>感谢你的收听，你已经打卡 Rust 学习10次啦！</p><p>如果你觉得有收获，也欢迎你分享给你身边的朋友，邀他一起讨论。坚持学习，我们下节课见。</p><h2>参考资料</h2><ol>\n<li>栈上的内存不必特意释放，顶多是编译时编译器不再允许该变量被访问。因为栈上的内存会随着栈帧的结束而结束。如果你有点模糊，可以再看看<a href=\"https://time.geekbang.org/column/article/408409\">前置知识</a>，温习一下栈和堆。</li>\n<li>Rust 的 I/O 安全性目前是 “almost safety”，为什么不是完全安全，感兴趣的同学可以看这个 <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/3128-io-safety.md\">RFC</a>。</li>\n<li>更多<a href=\"https://doc.rust-lang.org/std/boxed/struct.Box.html#method.leak\">关于 Box::leak 的信息</a>。</li>\n<li><a href=\"https://doc.rust-lang.org/src/alloc/sync.rs.html#303-312\">ArcInner 的结构</a>。</li>\n<li>Rust 的生命周期管理一直在进化，进化方向是在常见的场景下，尽量避免因为生命周期的处理，代码不得不换成不那么容易阅读的写作方式。比如下面的代码：</li>\n</ol><pre><code class=\"language-rust\">use std::collections::HashMap;\n\nfn main() {\n    let mut map = HashMap::new();\n    map.insert(\"hello\", \"world\");\n    let key = \"hello1\";\n\n    // 按照之前的说法，这段代码无法编译通过，因为同一个 scope 下不能有两个可变引用\n    // 但因为 RFC2094 non-lexical lifetimes，Rust 编译器可以处理这个场景，\n    // 因为当 None 时，map.get_mut() 的引用实际已经结束\n    match map.get_mut(key) /* &lt;----- 可变引用的生命周期一直持续到 match 结果 */ {\n        Some(v) =&gt; do_something(v),\n        None =&gt; {\n            map.insert(key, \"tyr\"); // &lt;--- 这里又获得了一个可变引用\n        }\n    }\n}\n\nfn do_something(_v: &amp;mut &amp;str) {\n    todo!()\n}\n</code></pre><p>如果你对此感兴趣，想了解更多，可以参看：<a href=\"https://rust-lang.github.io/rfcs/2094-nll.html\">RFC2094 - Non-lexical lifetimes</a>。我们在平时写代码时，可以就像这段代码这样先按照正常的方式去写，如果编译器抱怨，再分析引用的生命周期，换个写法。此外，随时保持你的 Rust 版本是最新的，也有助于让你的代码总是可以使用最简单的方式撰写。</p>","comments":[{"had_liked":false,"id":312048,"user_name":"记事本","can_delete":false,"product_type":"c1","uid":1401568,"ip_address":"","ucode":"FA942636EE0CC8","user_header":"https://static001.geekbang.org/account/avatar/00/15/62/e0/d2ff52da.jpg","comment_is_top":true,"comment_ctime":1631606209,"is_pvip":false,"replies":[{"id":"113089","content":"&amp;str 不是静态区域内存的指针。&amp;str 是一个字符串切片，一个带有长度的胖指针，指向字符串实际的位置。它可以指向 &quot;hello world&quot;，此时指针指到了 RODATA&#47;STRING section 里 &quot;hello&quot; 的地址，它的生命周期是 &#39;static；也可以指向 &quot;hello world&quot;.to_string()，此时指针指向了这个字符串的堆地址，生命周期是 &#39;a。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631635573,"ip_address":"","comment_id":312048,"utype":1}],"discussion_count":1,"race_medal":0,"score":"9.2233721157958001e+18","product_id":100085301,"comment_content":"&amp;str 是静态区域内存的一个指针<br>String 是把字符分配在堆上，但是也可以通过as_str以指针形式返回，就是&amp;str类型了，数据类型相同，分配的区域不同，生命周期不同,这样说法对吗？","like_count":19,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526841,"discussion_content":"&amp;amp;str 不是静态区域内存的指针。&amp;amp;str 是一个字符串切片，一个带有长度的胖指针，指向字符串实际的位置。它可以指向 &amp;quot;hello world&amp;quot;，此时指针指到了 RODATA/STRING section 里 &amp;quot;hello&amp;quot; 的地址，它的生命周期是 &amp;#39;static；也可以指向 &amp;quot;hello world&amp;quot;.to_string()，此时指针指向了这个字符串的堆地址，生命周期是 &amp;#39;a。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1631635573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":315926,"user_name":"dotfiles","can_delete":false,"product_type":"c1","uid":1217723,"ip_address":"","ucode":"F915599EC2F6E5","user_header":"https://static001.geekbang.org/account/avatar/00/12/94/bb/1c8384a0.jpg","comment_is_top":false,"comment_ctime":1634049631,"is_pvip":false,"replies":[{"id":"115284","content":"👍","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1635132473,"ip_address":"","comment_id":315926,"utype":1}],"discussion_count":2,"race_medal":0,"score":"66058559071","product_id":100085301,"comment_content":"1. &amp;str是一个在栈上分配的胖指针,而且实现了copy trait<br>```<br>let a = &quot;hello&quot;;<br>let b = a;<br>println!(&quot;a: {}, b: {}&quot;, a, b);<br>println!(&quot;&amp;a: {:p}, &amp;b: {:p}&quot;, &amp;a, &amp;b); <br>```<br>输出如下:<br>```<br>a: hello, b: hello<br>&amp;a: 0x7ffe7f4f3788, &amp;b: 0x7ffe7f4f3798<br>```<br>首先,a赋给b之后,a依然可以读取.因此没有转移所有权,进一步地,a其实是str的一个不可变引用.str的不可变引用允许有多份.这些不可变引用需要满足其生命周期小于str即可.<br>然后,&amp;a和&amp;b之间在64位系统上,相差16个字节.刚好是一个ptr和一个size的大小.<br><br>2. 思考题一<br>直接运行代码,在编译器的提示下,就会添加标注如下:<br>```<br>pub fn strtok&lt;&#39;a&gt;(s: &amp;&#39;a mut &amp;str, delimiter: char) -&gt; &amp;&#39;a str {...}<br>```<br>再运行,就会提示s1,同时存在可变和不可变引用. 一开始没想明白,原来是s1的可变引用的周期和返回值绑定了.在hello使用结束前,编译器认为s1的可变引用一直存在.<br>那么根据这个理解,其实这样标注也可以.只要把打印拆开就行了.<br>```<br>fn main() {<br>    ...<br>    println!(&quot;hello is: {}, s: {}&quot;, hello, s);<br>    println!(&quot;s1: {}&quot;, s1);<br>}<br>```<br>运行一下,果然可以通过.<br><br>3. 对于生命周期检查的一点思考<br>在含有引用的函数调用中,编译器会尝试根据规则进行补齐,如果无法自动补齐,就会要求开发者进行标注.<br>开发者标注的生命周期会在两个地方生效,一是函数的实现中,会去校验标注的正确性, 另一个是在函数的调用点也会根据函数声明中的标注,对入参和返回值进行检查.<br>那么函数声明中的生命周期标注,其实就是同时约束实现方和调用方的约定.在标注的约束关系中,如果检查发现调用方和实现方都满足约束,则编译通过.","like_count":16,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528205,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635132473,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1202697,"avatar":"https://static001.geekbang.org/account/avatar/00/12/5a/09/afa3e112.jpg","nickname":"清风徐来","note":"","ucode":"2AAA5B8DE30DF9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547198,"discussion_content":"&amp;str 实现了Copy Trait，从文档中什么位置可以看到，找了半天没找到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642577294,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311812,"user_name":"Marvichov","can_delete":false,"product_type":"c1","uid":1111835,"ip_address":"","ucode":"7482099415C41C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f7/1b/db7a0edc.jpg","comment_is_top":false,"comment_ctime":1631487765,"is_pvip":false,"replies":[{"id":"113024","content":"1. 好问题。还是要从生命周期中参数和返回值的关系来看，因为现在我们把对字符串的可变引用的生命周期和返回值的生命周期关联起来了，hello 得到了 strtok 的返回值，所以从编译器看来，&amp;mut s1 的生命周期并没有结束，所以发生了 &amp;mut 和 &amp; 同时存在的局面。<br>2. 👍<br>3. 赞<br>4. 我觉得这是个翻译风格问题，从字面意思上看生命期更好，但大家最惯用的说法已经约定俗称，而且不光 Rust，其它语言在谈到 lifetime 时也是如此（比如 react），所以生命周期更好。它起码比福尔摩斯的译名要好吧 lol。<br>5. 不会。生命周期在单体化之前就会被处理掉。它更多以编译器的错误呈现出来。对编译器来说，只要满足约束，更长的生命周期的变量也可以通过编译（比如 &amp;&#39;static str 至于 &amp;&#39;a str）。如果生命周期做单体化，下面的代码就可以编译，然而不行：<br><br>```rust<br>trait Print {<br>    fn print(self);<br>}<br><br>&#47;&#47; 生命周期无法像泛型那样有多个实现<br>&#47;&#47; impl&lt;&#39;a&gt; Print for &amp;&#39;a str {<br>&#47;&#47;     fn print(self) {<br>&#47;&#47;         println!(&quot;Arbitrary str: {}&quot;, self);<br>&#47;&#47;     }<br>&#47;&#47; }<br><br>impl Print for &amp;&#39;static str {<br>    fn print(self) {<br>        println!(&quot;&#39;static str: {}&quot;, self);<br>    }<br>}<br><br>&#47;&#47; 也无法单体化<br>fn print_str&lt;&#39;a&gt;(s: &amp;&#39;a str) {<br>    s.print()<br>}<br><br>fn main() {<br>    let s = &quot;hello, world!&quot;;<br>    s.print();<br>    print_str(s);<br>}<br>```<br>playground: https:&#47;&#47;play.rust-lang.org&#47;?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=b767ef1a9d9e265252c1ad29d31176b0","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631545156,"ip_address":"","comment_id":311812,"utype":1}],"discussion_count":3,"race_medal":0,"score":"53171095317","product_id":100085301,"comment_content":"<br>1. 入参 s: &amp;&#39;a mut &amp;str 变成了 &amp;&#39;a mut &amp;&#39;a str; 因为outer ref must outlive inter ref; 相当于把mutable borrow的lifetime extend成了&amp;str的lifetime;  很奇怪, 就算如此, 入参`s` 在函数call结束之后就end its life; 为啥还能extend it life到函数invocation后呢? 希望老师解答一下<br><br>```<br>17 | let hello = strtok(&amp;mut s1, &#39; &#39;);<br>   | ------- mutable borrow occurs here<br>18 | println!(&quot;hello is: {}, s1: {}, s: {}&quot;, hello, s1, s);<br>   | -----------------------------------------------^^-----<br>   | | |<br>   | | immutable borrow occurs here<br>```<br><br>https:&#47;&#47;doc.rust-lang.org&#47;nomicon&#47;lifetime-elision.html; <br>```<br>pub fn strtok&lt;&#39;a&gt;(s: &amp;&#39;a mut &amp;str, delimiter: char) -&gt; &amp;&#39;a str {<br>```<br>本以为output param会被elide; 看来有显示标注, 编译器不会自动elide<br><br>2. 在实践中慢慢有所领悟: https:&#47;&#47;doc.rust-lang.org&#47;book&#47;ch10-03-lifetime-syntax.html#lifetime-annotations-in-function-signatures<br>&gt; One lifetime annotation by itself doesn’t have much meaning, because the annotations are meant to tell Rust how generic lifetime parameters of multiple references relate to each other. <br><br>3. 死灵书比the book讲得好: https:&#47;&#47;doc.rust-lang.org&#47;nomicon&#47;lifetimes.html; 从编译器的角度去minimize the scope of a borrow能更好理解lifetime<br><br><br>4. 以前看到有人评论, 说lifetime翻译成生命**周**期很误导大家: 死了就死了, 不会周而复始地复活; 更好的翻译是生命期. 我表示赞同; 不知老师如何看?<br><br>5. lifetime是泛型的一部分; 对不同的&#39;a, 是不是strtok&lt;&#39;a&gt;都要生成不同的单体化呢? 编译生成后的代码, 还有&#39;a的信息吗?","like_count":13,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526752,"discussion_content":"1. 好问题。还是要从生命周期中参数和返回值的关系来看，因为现在我们把对字符串的可变引用的生命周期和返回值的生命周期关联起来了，hello 得到了 strtok 的返回值，所以从编译器看来，&amp;amp;mut s1 的生命周期并没有结束，所以发生了 &amp;amp;mut 和 &amp;amp; 同时存在的局面。\n2. 👍\n3. 赞\n4. 我觉得这是个翻译风格问题，从字面意思上看生命期更好，但大家最惯用的说法已经约定俗称，而且不光 Rust，其它语言在谈到 lifetime 时也是如此（比如 react），所以生命周期更好。它起码比福尔摩斯的译名要好吧 lol。\n5. 不会。生命周期在单体化之前就会被处理掉。它更多以编译器的错误呈现出来。对编译器来说，只要满足约束，更长的生命周期的变量也可以通过编译（比如 &amp;amp;&amp;#39;static str 至于 &amp;amp;&amp;#39;a str）。如果生命周期做单体化，下面的代码就可以编译，然而不行：\n\n```rust\ntrait Print {\n    fn print(self);\n}\n\n// 生命周期无法像泛型那样有多个实现\n// impl&amp;lt;&amp;#39;a&amp;gt; Print for &amp;amp;&amp;#39;a str {\n//     fn print(self) {\n//         println!(&amp;quot;Arbitrary str: {}&amp;quot;, self);\n//     }\n// }\n\nimpl Print for &amp;amp;&amp;#39;static str {\n    fn print(self) {\n        println!(&amp;quot;&amp;#39;static str: {}&amp;quot;, self);\n    }\n}\n\n// 也无法单体化\nfn print_str&amp;lt;&amp;#39;a&amp;gt;(s: &amp;amp;&amp;#39;a str) {\n    s.print()\n}\n\nfn main() {\n    let s = &amp;quot;hello, world!&amp;quot;;\n    s.print();\n    print_str(s);\n}\n```\nplayground: https://play.rust-lang.org/?version=stable&amp;amp;mode=debug&amp;amp;edition=2018&amp;amp;gist=b767ef1a9d9e265252c1ad29d31176b0","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631545156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111835,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f7/1b/db7a0edc.jpg","nickname":"Marvichov","note":"","ucode":"7482099415C41C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393771,"discussion_content":"感觉最好的办法就是看, 不同的生命周期context下, 有没有生成多份 print_str的代码; 然而, 目前我还不知道怎么做 T_T","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631590355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111835,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f7/1b/db7a0edc.jpg","nickname":"Marvichov","note":"","ucode":"7482099415C41C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393767,"discussion_content":"感谢老师解答!\n\n> hello 得到了 strtok 的返回值，所以从编译器看来，&amp;mut s1 的生命周期并没有结束，所以发生了 &amp;mut 和 &amp; 同时存在的局面。\n\n相当于把**人为**延长了入参的周期? 相当于在strtok之外加了个tmp?\n\n```\nfn main() {\n    let s = &#34;hello world&#34;.to_owned();\n    let mut s1 = s.as_str();\n    let tmp = &amp;mut s1; // 人为延长\n    let hello = strtok(tmp, &#39; &#39;);\n    println!(&#34;hello is: {}, s1: {}, s: {}&#34;, hello, s1, s);\n}\n```\n\n5. 老师的那个有点像cpp里面的specialization.\n\n回家又想了一想, 改动了一下代码, 对&#39;a加个bound就能编译了\n\n```\n// 请问: 这算单体化成功了吗?\nfn print_str<&#39;a>(s: &amp;&#39;a str) where &#39;a: &#39;static {\n    s.print()\n}\n```\n\nhttps://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=e2b842e42dcd8648994f9072cb836838","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631589777,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311901,"user_name":"亚伦碎语","can_delete":false,"product_type":"c1","uid":1014505,"ip_address":"","ucode":"F32E5E1B63CC90","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/e9/da5c0203.jpg","comment_is_top":false,"comment_ctime":1631526413,"is_pvip":false,"replies":[{"id":"113018","content":"👍","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631543023,"ip_address":"","comment_id":311901,"utype":1}],"discussion_count":1,"race_medal":0,"score":"40286232077","product_id":100085301,"comment_content":"会发生所有权的冲突，不满足一个值可以有唯一一个活跃的可变引用。可变引用（写）和只读引用（读）是互斥的关系。 <br>原因是因为让  s1的mut引用和只读引用有一样的scope，就会违反上述的规则，&amp;mut &amp;&#39;a str则是s1的可变引用的scope只在strtok内。所以不违法上边的规则","like_count":10,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526787,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631543023,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321283,"user_name":"Ignis","can_delete":false,"product_type":"c1","uid":2837051,"ip_address":"","ucode":"94A55C81E2F86C","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEL7ibAFViaJqhTRquzLKhS0SebmHON4RKeaL9I9R9wKHWt6ehcu0QtN8icvmPicU8wvDYIZiaaxqGWSxlw/132","comment_is_top":false,"comment_ctime":1636736698,"is_pvip":false,"replies":[{"id":"118933","content":"对","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1639853812,"ip_address":"","comment_id":321283,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18816605882","product_id":100085301,"comment_content":"按照本节的解释，编译器会给每一个引用参数都生成lifetime标记，那么strtok这个例子里面，如果我们标记了一部分，编译器是不是会自动把省略的标记补上，也就是这样：<br><br>pub fn strtok&lt;&#39;a&gt;(s: &amp;mut &amp;&#39;a str, delimiter: char) -&gt; &amp;&#39;a str<br>==&gt;<br>pub fn strtok&lt;&#39;a, &#39;b&gt;(s: &amp;&#39;b mut &amp;&#39;a str, delimiter: char) -&gt; &amp;&#39;a str<br><br>按照这个思路，如果我们把标记改为：<br>pub fn strtok&lt;&#39;a&gt;(s: &amp;&#39;a mut &amp;str, delimiter: char) -&gt; &amp;&#39;a str<br>编译器会处理成：<br>pub fn strtok&lt;&#39;a, &#39;b&gt;(s: &amp;&#39;a mut &amp;&#39;b str, delimiter: char) -&gt; &amp;&#39;a str<br><br>这种情况下s1的生命周期被s参数传递到返回值到hello，所以编译器会提示s1有可变引用。<br><br>不知道这么理解对不对<br>","like_count":5,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539894,"discussion_content":"对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639853812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314523,"user_name":"Geek_1b11b3","can_delete":false,"product_type":"c1","uid":2768844,"ip_address":"","ucode":"6D3AD8EAD46DC4","user_header":"","comment_is_top":false,"comment_ctime":1633173165,"is_pvip":false,"replies":[{"id":"113969","content":"一个引用一个生命周期","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1633320109,"ip_address":"","comment_id":314523,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18813042349","product_id":100085301,"comment_content":"陈老师你好：<br> ”&amp;mut &amp;str 添加生命周期后变成  &amp;&#39;b mut &amp;&#39;a str“，为什么编译器会自动标注成这样？不是一个参数一个生命周期吗？","like_count":5,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527709,"discussion_content":"一个引用一个生命周期","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633320109,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312206,"user_name":"Arthur","can_delete":false,"product_type":"c1","uid":1784009,"ip_address":"","ucode":"1C064405490769","user_header":"https://static001.geekbang.org/account/avatar/00/1b/38/c9/63ea8fe6.jpg","comment_is_top":false,"comment_ctime":1631682830,"is_pvip":true,"replies":[{"id":"113167","content":"1. 正确！<br>2. 好问题，理论上可以，但编译器目前没有做这样的事情，主要是代码可读性的担忧。可以看：https:&#47;&#47;github.com&#47;rust-lang&#47;rfcs&#47;blob&#47;master&#47;text&#47;0141-lifetime-elision.md#lifetime-elision-in-structs。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631759693,"ip_address":"","comment_id":312206,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18811552014","product_id":100085301,"comment_content":"1. <br>- 生命周期标注为`pub fn strtok&lt;&#39;a&gt;(s: &amp;&#39;a mut &amp;str, delimiter: char) -&gt; &amp;&#39;a str `<br>- 错误信息为<br>```<br>error[E0502]: cannot borrow `s1` as immutable because it is also borrowed as mutable<br>  --&gt; src&#47;main.rs:18:52<br>   |<br>17 |     let hello = strtok(&amp;mut s1, &#39; &#39;);<br>   |                        ------- mutable borrow occurs here<br>18 |     println!(&quot;hello is: {}, s1: {}, s: {}&quot;, hello, s1, s);<br>   |     -----------------------------------------------^^-----<br>   |     |                                              |<br>   |     |                                              immutable borrow occurs here<br>   |     mutable borrow later used here<br><br>error: aborting due to previous error<br>```<br>- 原因是，在这样手工标注生命周期以后，可变引用s1的声明周期就和返回值hello一样了，都存活于main函数作用域中。但是同时s1在main函数的作用域中，在18行又作为只读引用在println！中使用。违背规则：在一个作用域内，活跃的可变引用（写）和只读引用（读）是互斥的，不能同时存在。因此编译器会报错。<br><br>2. 在06讲中，<br>```rust<br>struct UrlFetcher&lt;&#39;a&gt;(pub(crate) &amp;&#39;a str);<br>```<br>这个struct只有一个成员，为什么也需要手动标注生命周期呢？编译器不能像为只有一个引用参数的函数那样自动生成生命周期的标记吗？","like_count":5,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526895,"discussion_content":"1. 正确！\n2. 好问题，理论上可以，但编译器目前没有做这样的事情，主要是代码可读性的担忧。可以看：https://github.com/rust-lang/rfcs/blob/master/text/0141-lifetime-elision.md#lifetime-elision-in-structs。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1631759693,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311923,"user_name":"周烨","can_delete":false,"product_type":"c1","uid":1355560,"ip_address":"","ucode":"6DAE79E4966CEF","user_header":"https://static001.geekbang.org/account/avatar/00/14/af/28/cc69ea4b.jpg","comment_is_top":false,"comment_ctime":1631531403,"is_pvip":false,"replies":[{"id":"113017","content":"对！<br><br>的确，在不是特别理解 &amp;mut &amp;str 在内存中的意义时容易出错，我们需要知道它是一个指向字符串引用的可变指针。这样，返回值和谁产生约束就一目了然了。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631543004,"ip_address":"","comment_id":311923,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10221465995","product_id":100085301,"comment_content":"1. 错误是 cannot borrow `s1` as immutable because it is also borrowed as mutable。感觉应该是这样写，就变成了可变借用&amp;mut的生命周期和返回值hello的生命周期一样了，所以这个引用的生命周期在函数结束后仍没有结束，所以产生了作用域冲突。我之前加生命周期的时候第一直觉也是加在这个地方，感觉真的很容易出错。","like_count":3,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526800,"discussion_content":"对！\n\n的确，在不是特别理解 &amp;amp;mut &amp;amp;str 在内存中的意义时容易出错，我们需要知道它是一个指向字符串引用的可变指针。这样，返回值和谁产生约束就一目了然了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631543004,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1037669,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d5/65/1c9f1530.jpg","nickname":"NorthWind","note":"","ucode":"459ADF3B0945E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576229,"discussion_content":"二级指针","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655362697,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1403021,"avatar":"https://static001.geekbang.org/account/avatar/00/15/68/8d/55c14209.jpg","nickname":"麓湖","note":"","ucode":"9FDBA9928B7E20","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393697,"discussion_content":"生命周期参数，描述的是参数和参数之间、参数和返回值之间的关系，并不改变原有的生命周期。 看起来&amp;&#39;a mut &amp;str改变了&amp;mut s1的生命周期了，这是为什么呢\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631548669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311810,"user_name":"CR","can_delete":false,"product_type":"c1","uid":2186767,"ip_address":"","ucode":"CE78F51366077F","user_header":"https://static001.geekbang.org/account/avatar/00/21/5e/0f/1a204ef7.jpg","comment_is_top":false,"comment_ctime":1631486832,"is_pvip":false,"replies":[{"id":"112986","content":"👍","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631514534,"ip_address":"","comment_id":311810,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10221421424","product_id":100085301,"comment_content":"想成为今天第一个打卡的男孩 LOL🤣","like_count":2,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526750,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631514534,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332563,"user_name":"朽木","can_delete":false,"product_type":"c1","uid":1063200,"ip_address":"","ucode":"0374F0DD04AAE9","user_header":"https://static001.geekbang.org/account/avatar/00/10/39/20/508ad0bd.jpg","comment_is_top":false,"comment_ctime":1643342677,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5938309973","product_id":100085301,"comment_content":"struct 的字段为什么需要标注生命周期呢？<br>函数需要标注是因为输出和输入的引用关系不确定，需要人为标注，可 struct 和它字段的依赖关系是确定的，struct 当然依赖每个字段，字段的声明周期不得小于 struct 本身，这不需要标注也知道吧？为何还需要标注呢？","like_count":1},{"had_liked":false,"id":326890,"user_name":"人世间","can_delete":false,"product_type":"c1","uid":1060729,"ip_address":"","ucode":"9957BE83041C27","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/79/7ea1c622.jpg","comment_is_top":false,"comment_ctime":1639734247,"is_pvip":false,"replies":[{"id":"118941","content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1639855056,"ip_address":"","comment_id":326890,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5934701543","product_id":100085301,"comment_content":"对于 &amp;mut &amp;&#39;a str, 我理解类似下面的过程：<br><br>```<br>fn main() {<br>    let s = &quot;hello world&quot;.to_owned();<br>    let mut s1 = s.as_str();<br>    let hello: &amp;str;<br>    {<br>        let ss = &amp;mut s1;<br>        hello = &amp;ss[..];  &#47;&#47; hello 的 lifetime 与 s1 一致, s1 的可变借用 ss 只存在 花括号的作用域内<br>    }<br>    println!(&quot;s1={:?}&quot;, s1);<br>    println!(&quot;hello={:?}&quot;, hello);<br>}<br>```<br><br>对于 &amp;&#39;a mut &amp;str ：<br><br>```<br>fn main() {<br>    let s = &quot;hello world&quot;.to_owned();<br>    let mut s1 = s.as_str();<br>    let hello: &amp;mut &amp;str;<br>    {<br>        let ss = &amp;mut s1;<br>        hello = ss;  &#47;&#47;  s1 可变引用 ss 绑定到 hello 中了<br>    }<br>    println!(&quot;s1={:?}&quot;, s1);         &#47;&#47; s1 不可变借用<br>    println!(&quot;hello={:?}&quot;, hello);   &#47;&#47; 活跃的 s1 的可变借用<br>    &#47;&#47; println!(&quot;s1={:?}&quot;, s1);      &#47;&#47; 调换 打印 s1，不报错 ，s1 的活跃的可变借用在 s1 的不可变借用之间。<br>}<br><br>```","like_count":2,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539904,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639855056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314620,"user_name":"pk","can_delete":false,"product_type":"c1","uid":1008808,"ip_address":"","ucode":"6A768EFD23EFC4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/64/a8/ad627315.jpg","comment_is_top":false,"comment_ctime":1633263009,"is_pvip":true,"replies":[{"id":"113966","content":"这样并不理想。因为 strtok 并不想改变原有的字符串，只是改变指向这个字符串的可变引用。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1633319845,"ip_address":"","comment_id":314620,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5928230305","product_id":100085301,"comment_content":"strtok 可以使用 &amp;mut str 做第一个参数而不是 &amp;mut &amp;str 吗？fn strtok(s: &amp;mut str, delimiter: char) -&gt; &amp;str","like_count":2,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527740,"discussion_content":"这样并不理想。因为 strtok 并不想改变原有的字符串，只是改变指向这个字符串的可变引用。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1633319845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313688,"user_name":"Roy Liang","can_delete":false,"product_type":"c1","uid":1098898,"ip_address":"","ucode":"1DF5FC831A35DA","user_header":"https://static001.geekbang.org/account/avatar/00/10/c4/92/338b5609.jpg","comment_is_top":false,"comment_ctime":1632621598,"is_pvip":false,"replies":[{"id":"113730","content":"👍","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632797553,"ip_address":"","comment_id":313688,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5927588894","product_id":100085301,"comment_content":"从前面文章学会match代替if会更简洁，谢谢老师<br>```rust<br>fn max&lt;&#39;a&gt;(s1: &amp;&#39;a str, s2: &amp;&#39;a str) -&gt; &amp;&#39;a str {<br>    match s1 &gt; s2 { <br>        true =&gt; s1,<br>        false =&gt; s2,<br>    }<br>}<br>```","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527439,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632797553,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1390032,"avatar":"https://static001.geekbang.org/account/avatar/00/15/35/d0/f2ac6d91.jpg","nickname":"阿成","note":"","ucode":"CEC3CD65FB9333","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":409199,"discussion_content":"if s1 > s2 { s1 } else { s2 }\n我感觉这样更简洁呢……","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1635391202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312842,"user_name":"老裴","can_delete":false,"product_type":"c1","uid":1253872,"ip_address":"","ucode":"18932DC556A719","user_header":"https://static001.geekbang.org/account/avatar/00/13/21/f0/51c493cc.jpg","comment_is_top":false,"comment_ctime":1632052700,"is_pvip":false,"replies":[{"id":"113370","content":"&#39;a 代表的是一个泛化的生命周期，表示我支持任何长度的生命周期。比如：<br><br>fn max&lt;&#39;a, &#39;b: &#39;a&gt;(s1: &amp;&#39;a str, s2: &amp;&#39;b str) -&gt; &amp;&#39;a str {}<br><br>表明 &#39;a 和 &#39;b 可能是不同的生命周期，&#39;b 生命周期大于等于 &#39;a。返回值需要满足 &#39;a 的生命周期。整个函数相当于在说，给定两个参数，返回值的生命周期要大于这两个参数中小的那个。<br><br>所以函数参数的生命周期是一种约束，而不是一个具体的值。它本身就可以随着传入的生命周期而自适应，只要它们满足约束就可以。你可以好好理解一下下面的代码：<br><br>```rust<br>fn max&lt;&#39;a, &#39;b: &#39;a&gt;(s1: &amp;&#39;a str, s2: &amp;&#39;b str) -&gt; &amp;&#39;a str {<br>    s1<br>}<br><br>fn main() {<br>    let s1 = String::from(&quot;hello&quot;);<br>    let s2 = String::from(&quot;world&quot;);<br>    &#47;&#47; 静态<br>    let s3 = &quot;hello&quot;;<br>    let s4 = &quot;world&quot;;<br>    max(&amp;s1, &amp;s2);<br>    max(&amp;s1, s3);<br>    max(s3, s4);<br>    max(&amp;s1, s3);<br>    <br>    &#47;&#47; 这里 s3 是 &#39;static，s1 是 &#39;b，s3 传入后会降级成 &#39;a，它依旧满足 &#39;b: &#39;a 的约束<br>    max(s3, &amp;s1);<br>}<br>```<br><br>playground: https:&#47;&#47;play.rust-lang.org&#47;?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=0080b95b36db1674b5d4d4c29793b1ab","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632155252,"ip_address":"","comment_id":312842,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5927019996","product_id":100085301,"comment_content":"用其他语言写函数也会遇到生命周期的事，比如某某引用已经失效还是未初始化什么，标出来就清楚了，但是有没这种情况，某个函数的参数生命周期是变化的，可能是&lt;&#39;a,&#39;a&gt;也可能是&lt;&#39;a,&#39;b&gt;,这样的话函数要实现2遍吗","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527135,"discussion_content":"&amp;#39;a 代表的是一个泛化的生命周期，表示我支持任何长度的生命周期。比如：\n\nfn max&amp;lt;&amp;#39;a, &amp;#39;b: &amp;#39;a&amp;gt;(s1: &amp;amp;&amp;#39;a str, s2: &amp;amp;&amp;#39;b str) -&amp;gt; &amp;amp;&amp;#39;a str {}\n\n表明 &amp;#39;a 和 &amp;#39;b 可能是不同的生命周期，&amp;#39;b 生命周期大于等于 &amp;#39;a。返回值需要满足 &amp;#39;a 的生命周期。整个函数相当于在说，给定两个参数，返回值的生命周期要大于这两个参数中小的那个。\n\n所以函数参数的生命周期是一种约束，而不是一个具体的值。它本身就可以随着传入的生命周期而自适应，只要它们满足约束就可以。你可以好好理解一下下面的代码：\n\n```rust\nfn max&amp;lt;&amp;#39;a, &amp;#39;b: &amp;#39;a&amp;gt;(s1: &amp;amp;&amp;#39;a str, s2: &amp;amp;&amp;#39;b str) -&amp;gt; &amp;amp;&amp;#39;a str {\n    s1\n}\n\nfn main() {\n    let s1 = String::from(&amp;quot;hello&amp;quot;);\n    let s2 = String::from(&amp;quot;world&amp;quot;);\n    // 静态\n    let s3 = &amp;quot;hello&amp;quot;;\n    let s4 = &amp;quot;world&amp;quot;;\n    max(&amp;amp;s1, &amp;amp;s2);\n    max(&amp;amp;s1, s3);\n    max(s3, s4);\n    max(&amp;amp;s1, s3);\n    \n    // 这里 s3 是 &amp;#39;static，s1 是 &amp;#39;b，s3 传入后会降级成 &amp;#39;a，它依旧满足 &amp;#39;b: &amp;#39;a 的约束\n    max(s3, &amp;amp;s1);\n}\n```\n\nplayground: https://play.rust-lang.org/?version=stable&amp;amp;mode=debug&amp;amp;edition=2018&amp;amp;gist=0080b95b36db1674b5d4d4c29793b1ab","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632155252,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312462,"user_name":"核桃","can_delete":false,"product_type":"c1","uid":1385204,"ip_address":"","ucode":"7AB05270CBCCCB","user_header":"https://static001.geekbang.org/account/avatar/00/15/22/f4/9fd6f8f0.jpg","comment_is_top":false,"comment_ctime":1631808097,"is_pvip":false,"replies":[{"id":"113220","content":"对于 1，你可以再看看我文中画的图，好好感受一下 &amp;mut &amp;str 表示什么。&amp;str 是一个字符串切片，&amp;mut &amp;str 是指向这个字符串切片的一个可变的引用。所以我们的问题是：返回值的生命周期究竟应该是和字符串切片有关？还是跟对这个字符串切片的可变引用有关？","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631844588,"ip_address":"","comment_id":312462,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5926775393","product_id":100085301,"comment_content":"老师你好，这里有一些小疑惑没有搞懂。<br>1.&amp;mut &amp;str 添加生命周期后变成  &amp;&#39;b mut &amp;&#39;a str，这将导致返回的  &#39;&amp;str 无法选择一个合适的生命周期。<br>   这句话里面,为什么mut前面还会需要标注生命周期的，这不是变量吧，因为在我故个人理解中，这是一个关键词和符号,为什么会需要生命周期标记？<br>   <br>2. <br>pub fn strtok&lt;&#39;b, &#39;a&gt;(s: &amp;&#39;b mut &amp;&#39;a str, delimiter: char) -&gt; &amp;&#39;a str {...}<br>   这个里面，首先&lt;&gt;中的表示什么意思？ 然后这里最后的 -&gt; &amp;&#39;a str表示返回值的生命周期是&#39;a，和入参的str相同吗？<br> 噢，刚刚手快弄错了一条留言，没有写完，请忽略，多谢了","like_count":2,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526971,"discussion_content":"对于 1，你可以再看看我文中画的图，好好感受一下 &amp;amp;mut &amp;amp;str 表示什么。&amp;amp;str 是一个字符串切片，&amp;amp;mut &amp;amp;str 是指向这个字符串切片的一个可变的引用。所以我们的问题是：返回值的生命周期究竟应该是和字符串切片有关？还是跟对这个字符串切片的可变引用有关？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631844588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311844,"user_name":"芥末小龙","can_delete":false,"product_type":"c1","uid":1176417,"ip_address":"","ucode":"387D01880867AC","user_header":"https://static001.geekbang.org/account/avatar/00/11/f3/61/8f7fca5b.jpg","comment_is_top":false,"comment_ctime":1631502557,"is_pvip":false,"replies":[{"id":"112984","content":"当 Rust 编译器不能标注生命周期需要开发者进行标注时，一定是编译器无法从已知的逻辑中找到参数和返回值之间的关系。所以我们要说明这种关系。<br><br>我们可以说 s1, s2 生命周期一致，返回值和他们的一致。这是我文中代码的表述。<br><br>也可以说 s1, s2 生命周期不一致，我们返回值的生命周期是比较小的那个。这是这段代码的表述。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631514372,"ip_address":"","comment_id":311844,"utype":1}],"discussion_count":7,"race_medal":0,"score":"5926469853","product_id":100085301,"comment_content":"陈老师您好！<br>fn max&lt;&#39;a,&#39;b:&#39;a&gt;(s1:&amp;&#39;a str, s2:&amp;&#39;b str) -&gt;&amp;&#39;a str {<br>    if s1 &gt; s2 {<br>        s1<br>    } else {<br>        s2<br>    }<br>}<br>我记得汉东老师的课中讲过，max这样也能编译过去 但是没有明白啥意思。您能详细的说一下吗？","like_count":2,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526769,"discussion_content":"当 Rust 编译器不能标注生命周期需要开发者进行标注时，一定是编译器无法从已知的逻辑中找到参数和返回值之间的关系。所以我们要说明这种关系。\n\n我们可以说 s1, s2 生命周期一致，返回值和他们的一致。这是我文中代码的表述。\n\n也可以说 s1, s2 生命周期不一致，我们返回值的生命周期是比较小的那个。这是这段代码的表述。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631514372,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":2755534,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/0b/ce/f0c520d1.jpg","nickname":"鹅帮逮","note":"","ucode":"A6DB1BEFDA5D9A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":532810,"discussion_content":"老师，请问这里a&#39;不应该是生命周期较大的吗？为什么不是返回b&#39;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637713108,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":526769,"ip_address":""},"score":532810,"extra":"{\"user_type\":1}"},{"author":{"id":2660581,"avatar":"https://static001.geekbang.org/account/avatar/00/28/98/e5/a716040e.jpg","nickname":"...zzZ","note":"","ucode":"953A50D833CA58","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2755534,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/0b/ce/f0c520d1.jpg","nickname":"鹅帮逮","note":"","ucode":"A6DB1BEFDA5D9A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550083,"discussion_content":"&#39;b: &#39;a表示为:  &#39;b长于&#39;a。参考知乎大神：https://www.zhihu.com/question/435470652","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1644378124,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":532810,"ip_address":""},"score":550083,"extra":""}]},{"author":{"id":2741015,"avatar":"https://static001.geekbang.org/account/avatar/00/29/d3/17/22c36063.jpg","nickname":"f","note":"","ucode":"D37A8E76DB782C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393630,"discussion_content":"我的理解是，函数参数的生命周期是为了函数返回值而提供的，或者说，是要保证函数参数都还活着的时候才能去使用返回值(显然是以短命的参数为基准的)，否则返回值有可能就引用了已经死掉的参数。\n再另一方面，函数的参数和返回值的生命周期谁长谁短，是编译器根据调用函数时的环境来判断的，不是根据函数本身来判断，所以书中都说生命周期只是用来标注，而不影响实际的生存周期的长短。\n\n比如：下面这段代码是没错的。\n```rust\n// 从函数本身，无从判断s1 s2和返回值谁活的久\n// 但将他们全部标为&#39;a，给编译器提了个醒：\n// s1、s2谁长谁短都可以，但必须在它们都活着的时候才能使用返回值\n// 如果编译器发现调用函数的地方(环境)，出现了某个参数已经死了，但还在\n// 使用返回值的情况，编译器就会报错\nfn max<&#39;a>(s1: &amp;&#39;a str, s2: &amp;&#39;a str) -> &amp;&#39;a str {\n  if s1 > s2 {\n    s1\n  } else {\n    s2\n  }\n}\nfn main() {\n  let s1 = &#34;hello&#34;.to_string();\n  let res;\n  {\n    let s2 = &#34;world&#34;.to_string();\n    res = max(&amp;s1, &amp;s2);\n    println!(&#34;res is: {}&#34;, res);\n  }  // 参数s2死了，但后面不再使用返回值了，因此编译通过\n}\n```\n但如果把println那行移到大括号外面，就会报错：\n```rust\n  {\n    let s2 = &#34;world&#34;.to_string();\n    res = max(&amp;s1, &amp;s2);\n  }  // 参数s2死了，但后面还在使用返回值，因此编译报错\n    println!(&#34;res is: {}&#34;, res);\n```\n同理，如果是`fn max<&#39;a,&#39;b:&#39;a>(s1:&amp;&#39;a str, s2:&amp;&#39;b str) ->&amp;&#39;a str`，编译器根据`&#39;b: &#39;a`的提示去判断，在函数调用的时候，参数s2的生命周期应当要比s1更长。也就是说，在使用函数返回值的过程中，只要s2还活着，s1必须也活着，否则编译器就会发现本该活更久的s2比s1还死得早，然后就报错。\n\n但是，基本目标仍然是保证返回值的有效性，还在使用返回值的时候，引用型参数都得活着，不再使用返回值的时候，无论参数的生命周期是如何标注的，参数谁先死谁后死都无所谓，标注只是个给编译器的提醒。\n\n个人理解，也许不对，如果不对，请指出。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1631523536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":2741015,"avatar":"https://static001.geekbang.org/account/avatar/00/29/d3/17/22c36063.jpg","nickname":"f","note":"","ucode":"D37A8E76DB782C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393671,"discussion_content":"非常正确！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631541492,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":393630,"ip_address":""},"score":393671,"extra":""},{"author":{"id":1390032,"avatar":"https://static001.geekbang.org/account/avatar/00/15/35/d0/f2ac6d91.jpg","nickname":"阿成","note":"","ucode":"CEC3CD65FB9333","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2741015,"avatar":"https://static001.geekbang.org/account/avatar/00/29/d3/17/22c36063.jpg","nickname":"f","note":"","ucode":"D37A8E76DB782C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":409205,"discussion_content":"“只要s2还活着，s1必须也活着” 这里写反了吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635391765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":393630,"ip_address":""},"score":409205,"extra":""}]},{"author":{"id":1078927,"avatar":"","nickname":"linuxfish","note":"","ucode":"557F21A1CC7EAD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":399456,"discussion_content":"提供一个信息，&#39;long: &#39;short is read &#34;&#39;long outlives &#39;short&#34;. 这个语法在官方文档中并未提到，只在RFC中有提及\n\n参考：https://stackoverflow.com/questions/30768063/does-a-b-a-mean-that-the-lifetime-b-must-outlive-the-lifetime-a","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632970708,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":348740,"user_name":"NorthWind","can_delete":false,"product_type":"c1","uid":1037669,"ip_address":"","ucode":"459ADF3B0945E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d5/65/1c9f1530.jpg","comment_is_top":false,"comment_ctime":1655362113,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655362113","product_id":100085301,"comment_content":"let mut map = HashMap::new(); map.insert(&quot;hello&quot;, &quot;world&quot;); let key = &quot;hello1&quot;; 这里的 &quot;hello&quot; 和 &quot;world&quot; 是静态生命周期么？","like_count":0},{"had_liked":false,"id":345479,"user_name":"太南喬 Serendipity!","can_delete":false,"product_type":"c1","uid":2648083,"ip_address":"","ucode":"F1DA88F7E8B2F3","user_header":"https://static001.geekbang.org/account/avatar/00/28/68/13/452e9331.jpg","comment_is_top":false,"comment_ctime":1652320444,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1652320444","product_id":100085301,"comment_content":"請教下為啥 delimiter 不需要標註生命週期？<br>舉例來說我把 strtok 的簽名改成<br>pub fn strtok&lt;&#39;a, &#39;c&gt;(s: &amp;mut &amp;&#39;a str, delimiter: &#39;c char) <br>然後編譯器就不高興了","like_count":0,"discussions":[{"author":{"id":1062808,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIf1t1D3ictrpgeFuIukNLUdicibnibk7GCO4KAv63ffNYbZPPibeTkhcKPpV7XCYpmaGGKsDKN2Miaephg/132","nickname":"脑洞太大补不上","note":"","ucode":"ABB5BA9AE6D50A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583451,"discussion_content":"delimiter 是个 char 类型啊，它的生命周期就是从 strtok 函数调用开始到结束。函数传参的时候这个 char 的值是复制到 strtok 的调用栈上的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1660122689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2399151,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM4HYljRtQ3ZRtTW2RMEiaeTkMnh1RNGU4ECeQBqeAX9l2g2d5hggwOp7aEiachXqB93FXZia0icoFUqMA/132","nickname":"Geek_703667","note":"","ucode":"61C9355CE91C08","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572811,"discussion_content":"「通过生命周期标注，我们告诉编译器这些*引用*间生命周期的约束。」delimiter不是一个引用，对于编译器来说，它的生命周期是确定的，就是在函数结束的时候结束。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1652968605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343169,"user_name":"绝世珍奇","can_delete":false,"product_type":"c1","uid":2975176,"ip_address":"","ucode":"0140AC5A80C0E6","user_header":"https://static001.geekbang.org/account/avatar/00/2d/65/c8/c7ebcf38.jpg","comment_is_top":false,"comment_ctime":1650688406,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650688406","product_id":100085301,"comment_content":"老师，请教一个问题： https:&#47;&#47;play.rust-lang.org&#47;?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=6027ba5bae514e563ff257100bedfd23<br><br>在不修改Scheme, Filter 等实现的情况下，Policy 需要怎样改呢。<br><br>对rust的生命周期了解不够深，试了多种方式都不行","like_count":0},{"had_liked":false,"id":342377,"user_name":"GE","can_delete":false,"product_type":"c1","uid":2773127,"ip_address":"","ucode":"A916BA2792FC0F","user_header":"https://static001.geekbang.org/account/avatar/00/2a/50/87/a6637d48.jpg","comment_is_top":false,"comment_ctime":1650223009,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650223009","product_id":100085301,"comment_content":"1. 将&amp;mut标记为&#39;a之后 只要返回值hello没有出作用域 &amp;mut就会存在 因为会有“同时”存在mutable ref &amp; immutable ref的情况 如果只是为了绕开检查 可以稍加修改<br>```<br>fn main() {<br>    let s = &quot;hello world&quot;.to_owned();<br>    let mut s1 = s.as_str();<br>    {<br>        let hello = strtok(&amp;mut s1, &#39; &#39;);<br>        println!(&quot;hello is: {}&quot;, hello);<br>    }<br>    println!(&quot;s1: {}, s: {}&quot;, s1, s);<br>}<br>```","like_count":0},{"had_liked":false,"id":336575,"user_name":"xiaojunzhou","can_delete":false,"product_type":"c1","uid":1276024,"ip_address":"","ucode":"C155FA9BB89318","user_header":"https://static001.geekbang.org/account/avatar/00/13/78/78/681a3e06.jpg","comment_is_top":false,"comment_ctime":1646220616,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1646220616","product_id":100085301,"comment_content":"思考题 1<br>出现了以下问题：<br>error[E0502]: cannot borrow `s1` as immutable because it is also borrowed as mutable<br>  --&gt; src&#47;main.rs:91:52<br>   |<br>90 |     let hello = strtok(&amp;mut s1, &#39; &#39;);<br>   |                        ------- mutable borrow occurs here<br>91 |     println!(&quot;hello is: {}, s1: {}, s: {}&quot;, hello, s1, s);<br>   |     -----------------------------------------------^^----<br>   |     |                                              |<br>   |     |                                              immutable borrow occurs here<br>   |     mutable borrow later used here<br>看起来是一个作用域同时出现可变引用和不可变引用","like_count":0},{"had_liked":false,"id":334482,"user_name":"许三多","can_delete":false,"product_type":"c1","uid":1108269,"ip_address":"","ucode":"A9BECD56EEBD2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/e9/2d/dfa58b90.jpg","comment_is_top":false,"comment_ctime":1644974759,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1644974759","product_id":100085301,"comment_content":"let s = &quot;Hello world&quot;.to_owned();<br>let mut s1 = s.as_str(); &#47;&#47; ------ 这地方s1是个值啊<br>let hello = strtok(&amp;mut s1, &#39; &#39;); &#47;&#47; ----- 这地方入参是个可变引用<br>println!(&quot;Hello is {}, s1: {}, s: {}&quot;, hello, s1, s); &#47;&#47; ----- hello保持了s1的可变引用的生命周期，但s1不是个值吗，怎么就成了不可变引用？？<br><br>谁能解答一下。<br><br><br>","like_count":0,"discussions":[{"author":{"id":2905523,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIDqHQQByGiaXcAk94MdDn3ftupZLXyR6bAKibxOzMxy5h3uBwZ7QiaCiaIfbCMK0cIQfGNax8iawoiaQAg/132","nickname":"nuan","note":"","ucode":"55FF98EB85404D","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555606,"discussion_content":"pub fn as_str(&amp;self) -&gt; &amp;str","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1646990308,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2056396,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKyJPx4r7mYedM4545Dw4tscPLBQoB7zUbf0RD0sfMyAlZgS1m05u953BYukYBvTHUZnUe7E8Ou8w/132","nickname":"Griffenliu","note":"","ucode":"0A5BFC80B3C0A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579101,"discussion_content":"s1的类型是&amp;str","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657175794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2399151,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM4HYljRtQ3ZRtTW2RMEiaeTkMnh1RNGU4ECeQBqeAX9l2g2d5hggwOp7aEiachXqB93FXZia0icoFUqMA/132","nickname":"Geek_703667","note":"","ucode":"61C9355CE91C08","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572814,"discussion_content":"print宏会借用s1. 宏展开（cargo expand）后，会发现println语句变成类似于\n```rust\n        ::std::io::_print(::core::fmt::Arguments::new_v1(\n            &amp;[&#34;&#34;, &#34;\\n&#34;],\n            &amp;[::core::fmt::ArgumentV1::new_display(&amp;s)],\n        ));\n```\n的东西","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652971324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331662,"user_name":"王彦霖","can_delete":false,"product_type":"c1","uid":2868952,"ip_address":"","ucode":"F9BFDD0C3657AB","user_header":"https://static001.geekbang.org/account/avatar/00/2b/c6/d8/672f1838.jpg","comment_is_top":false,"comment_ctime":1642691185,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1642691185","product_id":100085301,"comment_content":"fn main() {<br>let s = &quot;hello world&quot;.to_owned(); <br>let mut s1 = s.as_str(); <br>let hello = strtok(&amp;mut s1, &#39; &#39;); <br>println!(&quot;hello is: {}, s1: {}, s: {}&quot;, hello, s1, s);}<br>老师，这里这两个mut我不是很理解，s1已经是mut了，为什么传入参数还需要再标识一边mut呢？<br>麻烦老师给我讲解一下，谢谢","like_count":0},{"had_liked":false,"id":319130,"user_name":"三叶虫tlb","can_delete":false,"product_type":"c1","uid":1010499,"ip_address":"","ucode":"A8236974932E6E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/43/b6bcab56.jpg","comment_is_top":false,"comment_ctime":1635602811,"is_pvip":false,"replies":[{"id":"116393","content":"因为 Rust 编译器要保证代码的正确性，防止一个函数意外得到悬空指针。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1636556744,"ip_address":"","comment_id":319130,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1635602811","product_id":100085301,"comment_content":"没看明白：“missing lifetime specifier” ，也就是说，编译器在编译 max() 函数时，无法判断 s1、s2 和返回值的生命周期。<br>为什么要判断 s1、s2 和返回值的生命周期？<br><br>fn main() {<br>    let s1 = String::from(&quot;Lindsey&quot;);<br>    let s2 = String::from(&quot;Rosie&quot;);<br><br>    let result = max(&amp;s1, &amp;s2);<br><br>    println!(&quot;bigger one: {}&quot;, result);<br>}<br><br>fn max(s1: &amp;str, s2: &amp;str) -&gt; &amp;str {<br>    if s1 &gt; s2 {<br>        s1<br>    } else {<br>        s2<br>    }<br>}","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529511,"discussion_content":"因为 Rust 编译器要保证代码的正确性，防止一个函数意外得到悬空指针。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636556744,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":318128,"user_name":"彭亚伦","can_delete":false,"product_type":"c1","uid":2425378,"ip_address":"","ucode":"77A32C73A23F72","user_header":"https://static001.geekbang.org/account/avatar/00/25/02/22/19585900.jpg","comment_is_top":false,"comment_ctime":1635157585,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1635157585","product_id":100085301,"comment_content":"最后一段, 面向编译器编程语言实锤了~  :)","like_count":0},{"had_liked":false,"id":314959,"user_name":"睡醒头发总是翘着🚀","can_delete":false,"product_type":"c1","uid":1624221,"ip_address":"","ucode":"A9EDD9E4F5CB6F","user_header":"https://static001.geekbang.org/account/avatar/00/18/c8/9d/d2dafa92.jpg","comment_is_top":false,"comment_ctime":1633612044,"is_pvip":false,"replies":[{"id":"114166","content":"使用引用的目的就是为了避免额外的分配和复制。所以使用引用而不是 clone 可以提升性能。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1633813265,"ip_address":"","comment_id":314959,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1633612044","product_id":100085301,"comment_content":"把各个变量的地址打印出来看到 “hello world” 始终都没有变化，也没有创建新的堆空间来存储分割后的字符串，变化的都只是指针所指向的位置，通过这种方式是为了有更高效的性能吗？<br><br>s:0x7ffeef108800 s value:0x7fae8f405cc0<br>mut s1:0x7ffeef108818 mut s1 value: 0x7fae8f405cc0<br>s:0x7ffeef108450 s value: 0x7ffeef108818<br>prefix:0x7ffeef108478 prefix value: 0x7fae8f405cc0<br>suffix:0x7ffeef108490 suffix value: 0x7fae8f405cc6<br>hello:0x7ffeef108908 hello value: 0x7fae8f405cc0<br>s:0x7ffeef108800 s value:0x7fae8f405cc0<br>mut s1:0x7ffeef108818 mut s1 value: 0x7fae8f405cc6<br>hello is: hello, s1: world, s: hello world","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527839,"discussion_content":"使用引用的目的就是为了避免额外的分配和复制。所以使用引用而不是 clone 可以提升性能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633813265,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312152,"user_name":"记事本","can_delete":false,"product_type":"c1","uid":1401568,"ip_address":"","ucode":"FA942636EE0CC8","user_header":"https://static001.geekbang.org/account/avatar/00/15/62/e0/d2ff52da.jpg","comment_is_top":false,"comment_ctime":1631667254,"is_pvip":false,"replies":[{"id":"113127","content":"不用加 return。这里没有提前返回， if {} else {} 是一个完整的表达式","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631671280,"ip_address":"","comment_id":312152,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1631667254","product_id":100085301,"comment_content":"<br>fn max&lt;&#39;a&gt;(s1: &amp;&#39;a str, s2: &amp;&#39;a str) -&gt; &amp;&#39;a str {<br>    if s1 &gt; s2 {<br>   return     s1<br>    } else {<br>        s2<br>    }<br>}<br><br><br>s1 变量提前返回的话，需要加return","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526882,"discussion_content":"不用加 return。这里没有提前返回， if {} else {} 是一个完整的表达式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631671280,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312140,"user_name":"springXu","can_delete":false,"product_type":"c1","uid":2064750,"ip_address":"","ucode":"F5DB0B963C894F","user_header":"","comment_is_top":false,"comment_ctime":1631644437,"is_pvip":true,"replies":[{"id":"113124","content":"没有。你可以把所有函数接口里没有标注的引用当做 &#39;a 标注，方法里没有标注的引用看成 &amp;&#39;a self，返回值也是 &amp;&#39;a。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631671015,"ip_address":"","comment_id":312140,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1631644437","product_id":100085301,"comment_content":"这是因为编译器希望尽可能减轻开发者的负担，其实所有使用了引用的函数，都需要生命周期的标注，只不过编译器会自动做这件事，省却了开发者的麻烦。 <br><br>这个编译器会自动添加标注，有没有什么插件或者方法这个自动能变成显式的添加？","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526875,"discussion_content":"没有。你可以把所有函数接口里没有标注的引用当做 &amp;#39;a 标注，方法里没有标注的引用看成 &amp;amp;&amp;#39;a self，返回值也是 &amp;amp;&amp;#39;a。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631671015,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312130,"user_name":"Tyler","can_delete":false,"product_type":"c1","uid":1209108,"ip_address":"","ucode":"6C94C462D69EC6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL8Rzicd8f8GlIiaLQ6bYKPdhFJ3tvXw96rMicPv4s2rXEanYKjKdEewjCUAnwfJiaN53WyexhYLu1bbQ/132","comment_is_top":false,"comment_ctime":1631632368,"is_pvip":false,"replies":[{"id":"113125","content":"1. &lt;&#39;a&gt; 类似于一个泛型参数，它是说这个函数有几个类型参数。比如：<br><br>```rust<br>fn process&lt;&#39;a, &#39;b, T1, T1&gt;(s1: &amp;&#39;a T1, s2: &amp;&#39;b T2) {...}<br>```<br><br>这个函数有两个生命周期参数 &#39;a&#47;&#39;b，两个类型参数 T1&#47;T2。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631671219,"ip_address":"","comment_id":312130,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1631632368","product_id":100085301,"comment_content":"1、生命周期标注一个疑问，文中说生命周期标注是表明，参数与参数之前，参数与返回值 之间的关系，那么函数名与参数列表中间那个 &lt;&#39;a&gt; 就是下面代码中第一个&lt;&#39;a&gt; 即: strtok&lt;&#39;a&gt; 是代表的什么？ 有什么作用？ 与参数的标注，返回值的标注有什么关系？<br><br>```rust<br>pub fn strtok&lt;&#39;a&gt;(s: &amp;mut &amp;&#39;a str, delimiter: char) -&gt; &amp;&#39;a str {}  <br>```<br><br>2、思考题1:  编译会报s1 可变借用和不可变借用同时存在。 由于标注在&amp;&#39;a mut 这就约束了返回值的生命周期等于或小于要比&amp;&#39;a mut生命周期，这就导致了可变引用的存在。而正确标注在&amp;mut &amp;&#39;a str, 这就约束返回值的生命周期等于或小&amp;str的生命周期，此时可变引用的生命周期在函数结束后就会结束，在println!变量的是不可变引用，就不会有冲突了。 不知道这样理解对不对。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526873,"discussion_content":"1. &amp;lt;&amp;#39;a&amp;gt; 类似于一个泛型参数，它是说这个函数有几个类型参数。比如：\n\n```rust\nfn process&amp;lt;&amp;#39;a, &amp;#39;b, T1, T1&amp;gt;(s1: &amp;amp;&amp;#39;a T1, s2: &amp;amp;&amp;#39;b T2) {...}\n```\n\n这个函数有两个生命周期参数 &amp;#39;a/&amp;#39;b，两个类型参数 T1/T2。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1631671219,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312039,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1320487,"ip_address":"","ucode":"96BAFAA147341F","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","comment_is_top":false,"comment_ctime":1631601072,"is_pvip":false,"replies":[{"id":"113090","content":"在没有 NLL 之前，是错误的。NLL 优化了这类问题。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631635613,"ip_address":"","comment_id":312039,"utype":1}],"discussion_count":1,"race_medal":2,"score":"1631601072","product_id":100085301,"comment_content":"参考资料 5 有点疑惑了，RFC2094 - Non-lexical lifetimes 里面展示说在 None arm 里面执行 map.insert 是错误的","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526838,"discussion_content":"在没有 NLL 之前，是错误的。NLL 优化了这类问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631635613,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312031,"user_name":"有铭","can_delete":false,"product_type":"c1","uid":1046302,"ip_address":"","ucode":"2C7CB36CA5C04C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/3XbCueYYVWTiclv8T5tFpwiblOxLphvSZxL4ujMdqVMibZnOiaFK2C5nKRGv407iaAsrI0CDICYVQJtiaITzkjfjbvrQ/132","comment_is_top":false,"comment_ctime":1631599191,"is_pvip":false,"replies":[{"id":"113073","content":"可以，你可以用任何你觉得容易明白的小写字母甚至单词，比如 &#39;hello。就跟泛型的 T 一样，你也可以不用 Vec&lt;T&gt;，用 Vec&lt;MyGenericType&gt;。它就是一个名称。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631601820,"ip_address":"","comment_id":312031,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1631599191","product_id":100085301,"comment_content":"看了几遍，还是未能理解，生命周期参数中的这个 a 啊 b 啊，是怎么来的，一定要从a开始吗？我标两个b上去行不行，有个例子里是一个a和一个b，那变成一个b和一个c行吗？","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526834,"discussion_content":"可以，你可以用任何你觉得容易明白的小写字母甚至单词，比如 &amp;#39;hello。就跟泛型的 T 一样，你也可以不用 Vec&amp;lt;T&amp;gt;，用 Vec&amp;lt;MyGenericType&amp;gt;。它就是一个名称。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631601820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2056396,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKyJPx4r7mYedM4545Dw4tscPLBQoB7zUbf0RD0sfMyAlZgS1m05u953BYukYBvTHUZnUe7E8Ou8w/132","nickname":"Griffenliu","note":"","ucode":"0A5BFC80B3C0A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394623,"discussion_content":"我个人觉得吧,生命周期参数是用来标注函数里面参数和返回值的生命周期哪些是一样的,哪些是不同的,至于它们到底活多久,根据实际代码编译器自动推导的吧.满足规则就让你通过,不满足就让你修改.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631958637,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311863,"user_name":"码生笔谈","can_delete":false,"product_type":"c1","uid":1229329,"ip_address":"","ucode":"EBAD30BEE4E17D","user_header":"https://static001.geekbang.org/account/avatar/00/12/c2/11/323358ed.jpg","comment_is_top":false,"comment_ctime":1631514510,"is_pvip":false,"replies":[{"id":"113010","content":"恩学习非常细致呀，棒👍之前有个同学也反馈了这个问题，已经修改过来啦","user_name":"编辑回复","user_name_real":"叶如芊","uid":"2547771","ctime":1631519961,"ip_address":"","comment_id":311863,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1631514510","product_id":100085301,"comment_content":"老师这句话可能笔误了：“Employee 的生命周期不能小于它们”，<br>应该是”Employee 的生命周期需要小于它们“吧，因为文中的下一句话说的是：<br>“使用数据结构时，数据结构自身的生命周期，需要小于等于其内部字段的所有引用的生命周期。”","like_count":0,"discussions":[{"author":{"id":2547771,"avatar":"https://static001.geekbang.org/account/avatar/00/26/e0/3b/8ec916b2.jpg","nickname":"多少","note":"","ucode":"0A6EF7AA6E4BB7","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526776,"discussion_content":"恩学习非常细致呀，棒👍之前有个同学也反馈了这个问题，已经修改过来啦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631519961,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]}]}