{"id":191642,"title":"36 | 实战二（上）：程序出错该返回啥？NULL、异常、错误码、空对象？","content":"<p>我们可以把函数的运行结果分为两类。一类是预期的结果，也就是函数在正常情况下输出的结果。一类是非预期的结果，也就是函数在异常（或叫出错）情况下输出的结果。比如，在上一节课中，获取本机名的函数，在正常情况下，函数返回字符串格式的本机名；在异常情况下，获取本机名失败，函数返回UnknownHostException异常对象。</p><p>在正常情况下，函数返回数据的类型非常明确，但是，在异常情况下，函数返回的数据类型却非常灵活，有多种选择。除了刚刚提到的类似UnknownHostException这样的异常对象之外，函数在异常情况下还可以返回错误码、NULL值、特殊值（比如-1）、空对象（比如空字符串、空集合）等。</p><p>每一种异常返回数据类型，都有各自的特点和适用场景。但有的时候，在异常情况下，函数到底该返回什么样的数据类型，并不那么容易判断。比如，上节课中，在本机名获取失败的时候，ID生成器的generate()函数应该返回什么呢？是异常？空字符？还是NULL值？又或者是其他特殊值（比如null-15293834874-fd3A9KBn，null表示本机名未获取到）呢？</p><p>函数是代码的一个非常重要的编写单元，而函数的异常处理，又是我们在编写函数的时候，时刻都要考虑的。所以，今天我们就聊一聊，如何设计函数在异常情况下的返回数据类型。</p><!-- [[[read_end]]] --><p>话不多说，让我们正式开始今天的学习吧！</p><h2>从上节课的ID生成器代码讲起</h2><p>上两节课中，我们把一份非常简单的ID生成器的代码，从“能用”重构成了“好用”。最终给出的代码看似已经很完美了，但是如果我们再用心推敲一下，代码中关于出错处理的方式，还有进一步优化的空间，值得我们拿出来再讨论一下。</p><p>为了方便你查看，我将上节课的代码拷贝到了这里。</p><pre><code>public class RandomIdGenerator implements IdGenerator {\n  private static final Logger logger = LoggerFactory.getLogger(RandomIdGenerator.class);\n\n  @Override\n  public String generate() {\n    String substrOfHostName = getLastFiledOfHostName();\n    long currentTimeMillis = System.currentTimeMillis();\n    String randomString = generateRandomAlphameric(8);\n    String id = String.format(&quot;%s-%d-%s&quot;,\n            substrOfHostName, currentTimeMillis, randomString);\n    return id;\n  }\n\n  private String getLastFiledOfHostName() {\n    String substrOfHostName = null;\n    try {\n      String hostName = InetAddress.getLocalHost().getHostName();\n      substrOfHostName = getLastSubstrSplittedByDot(hostName);\n    } catch (UnknownHostException e) {\n      logger.warn(&quot;Failed to get the host name.&quot;, e);\n    }\n    return substrOfHostName;\n  }\n\n  @VisibleForTesting\n  protected String getLastSubstrSplittedByDot(String hostName) {\n    String[] tokens = hostName.split(&quot;\\\\.&quot;);\n    String substrOfHostName = tokens[tokens.length - 1];\n    return substrOfHostName;\n  }\n\n  @VisibleForTesting\n  protected String generateRandomAlphameric(int length) {\n    char[] randomChars = new char[length];\n    int count = 0;\n    Random random = new Random();\n    while (count &lt; length) {\n      int maxAscii = 'z';\n      int randomAscii = random.nextInt(maxAscii);\n      boolean isDigit= randomAscii &gt;= '0' &amp;&amp; randomAscii &lt;= '9';\n      boolean isUppercase= randomAscii &gt;= 'A' &amp;&amp; randomAscii &lt;= 'Z';\n      boolean isLowercase= randomAscii &gt;= 'a' &amp;&amp; randomAscii &lt;= 'z';\n      if (isDigit|| isUppercase || isLowercase) {\n        randomChars[count] = (char) (randomAscii);\n        ++count;\n      }\n    }\n    return new String(randomChars);\n  }\n}\n</code></pre><p>这段代码中有四个函数。针对这四个函数的出错处理方式，我总结出下面这样几个问题。</p><ul>\n<li>对于generate()函数，如果本机名获取失败，函数返回什么？这样的返回值是否合理？</li>\n<li>对于getLastFiledOfHostName()函数，是否应该将UnknownHostException异常在函数内部吞掉（try-catch并打印日志）？还是应该将异常继续往上抛出？如果往上抛出的话，是直接把UnknownHostException异常原封不动地抛出，还是封装成新的异常抛出？</li>\n<li>对于getLastSubstrSplittedByDot(String hostName)函数，如果hostName为NULL或者是空字符串，这个函数应该返回什么？</li>\n<li>对于generateRandomAlphameric(int length)函数，如果length小于0或者等于0，这个函数应该返回什么？</li>\n</ul><p>对于上面这几个问题，你可以试着思考下，我先不做解答。等我们学完本节课的理论内容之后，我们下一节课再一块来分析。这一节我们重点讲解一些理论方面的知识。</p><h2>函数出错应该返回啥？</h2><p>关于函数出错返回数据类型，我总结了4种情况，它们分别是：错误码、NULL值、空对象、异常对象。接下来，我们就一一来看它们的用法以及适用场景。</p><h3>1.返回错误码</h3><p>C语言中没有异常这样的语法机制，因此，返回错误码便是最常用的出错处理方式。而在Java、Python等比较新的编程语言中，大部分情况下，我们都用异常来处理函数出错的情况，极少会用到错误码。</p><p>在C语言中，错误码的返回方式有两种：一种是直接占用函数的返回值，函数正常执行的返回值放到出参中；另一种是将错误码定义为全局变量，在函数执行出错时，函数调用者通过这个全局变量来获取错误码。针对这两种方式，我举个例子来进一步解释。具体代码如下所示：</p><pre><code>// 错误码的返回方式一：pathname/flags/mode为入参；fd为出参，存储打开的文件句柄。\nint open(const char *pathname, int flags, mode_t mode, int* fd) {\n  if (/*文件不存在*/) {\n    return EEXIST;\n  }\n  \n  if (/*没有访问权限*/) {\n    return EACCESS;\n  }\n  \n  if (/*打开文件成功*/) {\n    return SUCCESS; // C语言中的宏定义：#define SUCCESS 0\n  }\n  // ...\n}\n//使用举例\nint fd;\nint result = open(“c:\\test.txt”, O_RDWR, S_IRWXU|S_IRWXG|S_IRWXO, &amp;fd);\nif (result == SUCCESS) {\n  // 取出fd使用\n} else if (result == EEXIST) {\n  //...\n} else if (result == EACESS) {\n  //...\n}\n\n// 错误码的返回方式二：函数返回打开的文件句柄，错误码放到errno中。\nint errno; // 线程安全的全局变量\nint open(const char *pathname, int flags, mode_t mode）{\n  if (/*文件不存在*/) {\n    errno = EEXIST;\n    return -1;\n  }\n  \n  if (/*没有访问权限*/) {\n    errno = EACCESS;\n    return -1;\n  }\n  \n  // ...\n}\n// 使用举例\nint hFile = open(“c:\\test.txt”, O_RDWR, S_IRWXU|S_IRWXG|S_IRWXO);\nif (-1 == hFile) {\n  printf(&quot;Failed to open file, error no: %d.\\n&quot;, errno);\n  if (errno == EEXIST ) {\n    // ...        \n  } else if(errno == EACCESS) {\n    // ...    \n  }\n  // ...\n}\n</code></pre><p>实际上，如果你熟悉的编程语言中有异常这种语法机制，那就尽量不要使用错误码。异常相对于错误码，有诸多方面的优势，比如可以携带更多的错误信息（exception中可以有message、stack trace等信息）等。关于异常，我们待会还会非常详细地讲解。</p><h3>2.返回NULL值</h3><p>在多数编程语言中，我们用NULL来表示“不存在”这种语义。不过，网上很多人不建议函数返回NULL值，认为这是一种不好的设计思路，主要的理由有以下两个。</p><ul>\n<li>如果某个函数有可能返回NULL值，我们在使用它的时候，忘记了做NULL值判断，就有可能会抛出<strong>空指针异常</strong>（Null Pointer Exception，缩写为NPE）。</li>\n<li>如果我们定义了很多返回值可能为NULL的函数，那代码中就会充斥着大量的NULL值判断逻辑，一方面写起来比较繁琐，另一方面它们跟正常的业务逻辑耦合在一起，会影响代码的可读性。</li>\n</ul><p>我举个例子解释一下，具体代码如下所示：</p><pre><code>public class UserService {\n  private UserRepo userRepo; // 依赖注入\n  \n  public User getUser(String telephone) {\n    // 如果用户不存在，则返回null\n    return null;\n  }\n}\n\n// 使用函数getUser()\nUser user = userService.getUser(&quot;18917718965&quot;);\nif (user != null) { // 做NULL值判断，否则有可能会报NPE\n  String email = user.getEmail();\n  if (email != null) { // 做NULL值判断，否则有可能会报NPE\n    String escapedEmail = email.replaceAll(&quot;@&quot;, &quot;#&quot;);\n  }\n}\n</code></pre><p>那我们是否可以用异常来替代NULL值，在查找用户不存在的时候，让函数抛出UserNotFoundException异常呢？</p><p>我个人觉得，尽管返回NULL值有诸多弊端，但对于以get、find、select、search、query等单词开头的查找函数来说，数据不存在，并非一种异常情况，这是一种正常行为。所以，返回代表不存在语义的NULL值比返回异常更加合理。</p><p>不过，话说回来，刚刚讲的这个理由，也并不是特别有说服力。对于查找数据不存在的情况，函数到底是该用NULL值还是异常，有一个比较重要的参考标准是，看项目中的其他类似查找函数都是如何定义的，只要整个项目遵从统一的约定即可。如果项目从零开始开发，并没有统一约定和可以参考的代码，那你选择两者中的任何一种都可以。你只需要在函数定义的地方注释清楚，让调用者清晰地知道数据不存在的时候会返回什么就可以了。</p><p>再补充说明一点，对于查找函数来说，除了返回数据对象之外，有的还会返回下标位置，比如Java中的indexOf()函数，用来实现在某个字符串中查找另一个子串第一次出现的位置。函数的返回值类型为基本类型int。这个时候，我们就无法用NULL值来表示不存在的情况了。对于这种情况，我们有两种处理思路，一种是返回NotFoundException，一种是返回一个特殊值，比如-1。不过，显然-1更加合理，理由也是同样的，也就是说“没有查找到”是一种正常而非异常的行为。</p><h3>3.返回空对象</h3><p>刚刚我们讲到，返回NULL值有各种弊端。应对这个问题有一个比较经典的策略，那就是应用空对象设计模式（Null Object Design Pattern）。关于这个设计模式，我们在后面章节会详细讲，现在就不展开来讲解了。不过，我们今天来讲两种比较简单、比较特殊的空对象，那就是<strong>空字符串</strong>和<strong>空集合</strong>。</p><p>当函数返回的数据是字符串类型或者集合类型的时候，我们可以用空字符串或空集合替代NULL值，来表示不存在的情况。这样，我们在使用函数的时候，就可以不用做NULL值判断。我举个例子来解释下。具体代码如下所示：</p><pre><code>// 使用空集合替代NULL\npublic class UserService {\n  private UserRepo userRepo; // 依赖注入\n  \n  public List&lt;User&gt; getUsers(String telephonePrefix) {\n   // 没有查找到数据\n    return Collections.emptyList();\n  }\n}\n// getUsers使用示例\nList&lt;User&gt; users = userService.getUsers(&quot;189&quot;);\nfor (User user : users) { //这里不需要做NULL值判断\n  // ...\n}\n\n// 使用空字符串替代NULL\npublic String retrieveUppercaseLetters(String text) {\n  // 如果text中没有大写字母，返回空字符串，而非NULL值\n  return &quot;&quot;;\n}\n// retrieveUppercaseLetters()使用举例\nString uppercaseLetters = retrieveUppercaseLetters(&quot;wangzheng&quot;);\nint length = uppercaseLetters.length();// 不需要做NULL值判断 \nSystem.out.println(&quot;Contains &quot; + length + &quot; upper case letters.&quot;);\n</code></pre><h3>4.抛出异常对象</h3><p>尽管前面讲了很多函数出错的返回数据类型，但是，最常用的函数出错处理方式就是抛出异常。异常可以携带更多的错误信息，比如函数调用栈信息。除此之外，异常可以将正常逻辑和异常逻辑的处理分离开来，这样代码的可读性就会更好。</p><p>不同的编程语言的异常语法稍有不同。像C++和大部分的动态语言（Python、Ruby、JavaScript等）都只定义了一种异常类型：运行时异常（Runtime Exception）。而像Java，除了运行时异常外，还定义了另外一种异常类型：编译时异常（Compile Exception）。</p><p>对于运行时异常，我们在编写代码的时候，可以不用主动去try-catch，编译器在编译代码的时候，并不会检查代码是否有对运行时异常做了处理。相反，对于编译时异常，我们在编写代码的时候，需要主动去try-catch或者在函数定义中声明，否则编译就会报错。所以，运行时异常也叫作非受检异常（Unchecked Exception），编译时异常也叫作受检异常（Checked Exception）。</p><p>如果你熟悉的编程语言中，只定义了一种异常类型，那用起来反倒比较简单。如果你熟悉的编程语言中（比如Java），定义了两种异常类型，那在异常出现的时候，我们应该选择抛出哪种异常类型呢？是受检异常还是非受检异常？</p><p>对于代码bug（比如数组越界）以及不可恢复异常（比如数据库连接失败），即便我们捕获了，也做不了太多事情，所以，我们倾向于使用非受检异常。对于可恢复异常、业务异常，比如提现金额大于余额的异常，我们更倾向于使用受检异常，明确告知调用者需要捕获处理。</p><p>我举一个例子解释一下，代码如下所示。当Redis的地址（参数address）没有设置的时候，我们直接使用默认的地址（比如本地地址和默认端口）；当Redis的地址格式不正确的时候，我们希望程序能fail-fast，也就是说，把这种情况当成不可恢复的异常，直接抛出运行时异常，将程序终止掉。</p><pre><code>// address格式：&quot;192.131.2.33:7896&quot;\npublic void parseRedisAddress(String address) {\n  this.host = RedisConfig.DEFAULT_HOST;\n  this.port = RedisConfig.DEFAULT_PORT;\n  \n  if (StringUtils.isBlank(address)) {\n    return;\n  }\n\n  String[] ipAndPort = address.split(&quot;:&quot;);\n  if (ipAndPort.length != 2) {\n    throw new RuntimeException(&quot;...&quot;);\n  }\n  \n  this.host = ipAndPort[0];\n  // parseInt()解析失败会抛出NumberFormatException运行时异常\n  this.port = Integer.parseInt(ipAndPort[1]);\n}\n</code></pre><p>实际上，Java支持的受检异常一直被人诟病，很多人主张所有的异常情况都应该使用非受检异常。支持这种观点的理由主要有以下三个。</p><ul>\n<li>受检异常需要显式地在函数定义中声明。如果函数会抛出很多受检异常，那函数的定义就会非常冗长，这就会影响代码的可读性，使用起来也不方便。</li>\n<li>编译器强制我们必须显示地捕获所有的受检异常，代码实现会比较繁琐。而非受检异常正好相反，我们不需要在定义中显示声明，并且是否需要捕获处理，也可以自由决定。</li>\n<li>受检异常的使用违反开闭原则。如果我们给某个函数新增一个受检异常，这个函数所在的函数调用链上的所有位于其之上的函数都需要做相应的代码修改，直到调用链中的某个函数将这个新增的异常try-catch处理掉为止。而新增非受检异常可以不改动调用链上的代码。我们可以灵活地选择在某个函数中集中处理，比如在Spring中的AOP切面中集中处理异常。</li>\n</ul><p>不过，非受检异常也有弊端，它的优点其实也正是它的缺点。从刚刚的表述中，我们可以看出，非受检异常使用起来更加灵活，怎么处理的主动权这里就交给了程序员。我们前面也讲到，过于灵活会带来不可控，非受检异常不需要显式地在函数定义中声明，那我们在使用函数的时候，就需要查看代码才能知道具体会抛出哪些异常。非受检异常不需要强制捕获处理，那程序员就有可能漏掉一些本应该捕获处理的异常。</p><p>对于应该用受检异常还是非受检异常，网上的争论有很多，但并没有一个非常强有力的理由能够说明一个就一定比另一个更好。所以，我们只需要根据团队的开发习惯，在同一个项目中，制定统一的异常处理规范即可。</p><p><strong>刚刚我们讲了两种异常类型，现在我们再来讲下，如何处理函数抛出的异常？</strong>总结一下，一般有下面三种处理方法。</p><ul>\n<li>直接吞掉。具体的代码示例如下所示：</li>\n</ul><pre><code>public void func1() throws Exception1 {\n  // ...\n}\n\npublic void func2() {\n  //...\n  try {\n    func1();\n  } catch(Exception1 e) {\n    log.warn(&quot;...&quot;, e); //吐掉：try-catch打印日志\n  }\n  //...\n}\n</code></pre><ul>\n<li>原封不动地re-throw。具体的代码示例如下所示：</li>\n</ul><pre><code>public void func1() throws Exception1 {\n  // ...\n}\n\n\npublic void func2() throws Exception1 {//原封不动的re-throw Exception1\n  //...\n  func1();\n  //...\n}\n</code></pre><ul>\n<li>包装成新的异常re-throw。具体的代码示例如下所示：</li>\n</ul><pre><code>public void func1() throws Exception1 {\n  // ...\n}\n\n\npublic void func2() throws Exception2 {\n  //...\n  try {\n    func1();\n  } catch(Exception1 e) {\n   throw new Exception2(&quot;...&quot;, e); // wrap成新的Exception2然后re-throw\n  }\n  //...\n}\n</code></pre><p>当我们面对函数抛出异常的时候，应该选择上面的哪种处理方式呢？我总结了下面三个参考原则：</p><ul>\n<li>如果func1()抛出的异常是可以恢复，且func2()的调用方并不关心此异常，我们完全可以在func2()内将func1()抛出的异常吞掉；</li>\n<li>如果func1()抛出的异常对func2()的调用方来说，也是可以理解的、关心的 ，并且在业务概念上有一定的相关性，我们可以选择直接将func1抛出的异常re-throw；</li>\n<li>如果func1()抛出的异常太底层，对func2()的调用方来说，缺乏背景去理解、且业务概念上无关，我们可以将它重新包装成调用方可以理解的新异常，然后re-throw。</li>\n</ul><p>总之，是否往上继续抛出，要看上层代码是否关心这个异常。关心就将它抛出，否则就直接吞掉。是否需要包装成新的异常抛出，看上层代码是否能理解这个异常、是否业务相关。如果能理解、业务相关就可以直接抛出，否则就封装成新的异常抛出。关于这部分理论知识，我们在下一节课中，会结合ID生成器的代码来进一步讲解。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要掌握的重点内容。</p><p>对于函数出错返回数据类型，我总结了4种情况，它们分别是：错误码、NULL值、空对象、异常对象。</p><p><strong>1.返回错误码</strong></p><p>C语言没有异常这样的语法机制，返回错误码便是最常用的出错处理方式。而Java、Python等比较新的编程语言中，大部分情况下，我们都用异常来处理函数出错的情况，极少会用到错误码。</p><p><strong>2.返回NULL值</strong></p><p>在多数编程语言中，我们用NULL来表示“不存在”这种语义。对于查找函数来说，数据不存在并非一种异常情况，是一种正常行为，所以返回表示不存在语义的NULL值比返回异常更加合理。</p><p><strong>3.返回空对象</strong></p><p>返回NULL值有各种弊端，对此有一个比较经典的应对策略，那就是应用空对象设计模式。当函数返回的数据是字符串类型或者集合类型的时候，我们可以用空字符串或空集合替代NULL值，来表示不存在的情况。这样，我们在使用函数的时候，就可以不用做NULL值判断。</p><p><strong>4.抛出异常对象</strong></p><p>尽管前面讲了很多函数出错的返回数据类型，但是，最常用的函数出错处理方式是抛出异常。异常有两种类型：受检异常和非受检异常。</p><p>对于应该用受检异常还是非受检异常，网上的争论有很多，但也并没有一个非常强有力的理由，说明一个就一定比另一个更好。所以，我们只需要根据团队的开发习惯，在同一个项目中，制定统一的异常处理规范即可。</p><p>对于函数抛出的异常，我们有三种处理方法：直接吞掉、直接往上抛出、包裹成新的异常抛出。这一部分我们留在下一节课中结合实战进一步讲解。</p><h2>课堂讨论</h2><p>结合我们今天学的理论知识，试着回答一下在文章开头针对RandomIdGenerator提到的四个问题。</p><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>","neighbors":{"left":{"article_title":"35 | 实战一（下）：手把手带你将ID生成器代码从“能用”重构为“好用”","id":191621},"right":{"article_title":"37 | 实战二（下）：重构ID生成器项目中各函数的异常处理代码","id":191647}},"comments":[{"had_liked":false,"id":173964,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1579835415,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"452551401495","product_id":100039001,"comment_content":"回答问题<br>1.抛出异常，因为服务器获取不到host是一种异常情况，并且打印的异常日志不能是warm,而是err，因为该异常不会自动回复。<br><br>2.往上抛，原封不动。应该在api统一出口处处理异常，这样异常代码会比较聚合（个人习惯）。该异常描述已经很准确，且处理异常依旧在genId接口中，所以上层函数可以认识该异常，所以原封不动。（而统一出口函数，则可以抛自定义异常，以收敛api使用方的考虑范围）。<br><br>3.抛出异常，null值裁剪名称是一种异常情况。或则说，对于裁剪名称这个函数，入参不能为null。<br><br>4.返回空字符串。小于等于0说明不需要带随机后缀，这也是一个正常的业务场景。返回空字符串是为了方便调用方不用做null判断。<br><br><br>分歧：<br>1.get,find,select等dao层操作，返回null是正常业务情况，表示数据不存在。但在其应用层，数据不存在可能意味着有脏数据，数据缺失等情况，属于异常情况，需要抛出异常。所以同样是get方法，持久层返回null，业务层返回可能是异常。<br><br>2.异常流开销大，在对响应时间要求很严格的场景。放弃合理的异常处理，采用不合理的特殊返回值的方式也是合理的。所以合理的运用异常流在java也是一个选择项。在可读和性能我们需要权衡，而这两玩意经常是相驳的。<br><br>最后：<br>祝栏主和同学们新年快乐！","like_count":106},{"had_liked":false,"id":174091,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1579959355,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"91774272571","product_id":100039001,"comment_content":"1、不抛。返回null-123123784378-aldjf780。从功能上讲，函数是生成logtraceid，用于给记录加id，便于查找日志。返回null不影响定位问题，同时程序不会蹦。<br>2、上抛，到generate中处理。<br>3、返回空串<br>4、返回空串","like_count":22,"discussions":[{"author":{"id":1220273,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9e/b1/758f2fe7.jpg","nickname":"香","note":"","ucode":"121D6CECECEEC3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340518,"discussion_content":"我个人是比较支持这一点，因为即使是返回了带null的id，但只要它能够达到我们的业务目的，我觉得就是ok，技术本身还是服务于业务，所以我也认为不抛，因为当前我们用此id的目的仅仅是用于定位同一个请求的log.\n当然，如果后续我们需要在日志里加入某些需要追踪的信息，而这些信息跟节点是强相关的，那么这时就需要抛出。\n总的来说，就是看业务需求。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1610022779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179517,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1582019220,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"74596463252","product_id":100039001,"comment_content":"Go语言函数返回的时候分正确值、错误值，比较简单","like_count":18},{"had_liked":false,"id":174238,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1580105087,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"27349908863","product_id":100039001,"comment_content":"对于今天课堂留的作业，我采用了统一的思路—能用异常解决的都用异常解决。<br><br>1.对于 generate() 函数，如果本机名获取失败，函数返回什么？这样的返回值是否合理？<br>答：抛出异常，这是一个无法恢复的情况，打断正常的处理流程并进入异常逻辑处理模块<br><br>2. 对于 getLastFiledOfHostName() 函数，是否应该将 UnknownHostException 异常在函数内部吞掉（try-catch 并打印日志）？还是应该将异常继续往上抛出？如果往上抛出的话，是直接把 UnknownHostException 异常原封不动地抛出，还是封装成新的异常抛出？<br>答：不应该内部吞掉，应该抛出到上层做统一的异常处理，这里是个单一的模块，不需要再封装<br><br>3. 对于 getLastSubstrSplittedByDot(String hostName) 函数，如果 hostName 为 NULL 或者是空字符串，这个函数应该返回什么？<br>答：抛出异常，异常消息是—hostName为NULL或空字符串<br><br>4. 对于 generateRandomAlphameric(int length) 函数，如果 length 小于 0 或者等于 0，这个函数应该返回什么？<br>答：抛出异常，异常消息是—参数不合法","like_count":7},{"had_liked":false,"id":173948,"user_name":"sunnywhy","can_delete":false,"product_type":"c1","uid":1513427,"ip_address":"","ucode":"061F4DED04738A","user_header":"https://static001.geekbang.org/account/avatar/00/17/17/d3/936f4599.jpg","comment_is_top":false,"comment_ctime":1579816344,"is_pvip":true,"replies":[{"id":"67716","content":"可以，Java8的语法，因为有些朋友不熟悉java语言，所以高级语法我就没讲了","user_name":"作者回复","comment_id":173948,"uid":"1190123","ip_address":"","utype":1,"ctime":1580112293,"user_name_real":"王争"}],"discussion_count":4,"race_medal":0,"score":"23054652824","product_id":100039001,"comment_content":"第二种返回Null的情况，可以使用Optional吗","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482252,"discussion_content":"可以，Java8的语法，因为有些朋友不熟悉java语言，所以高级语法我就没讲了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580112293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2536820,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b5/74/cd80b9f4.jpg","nickname":"友","note":"","ucode":"972A4333A8B101","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":535639,"discussion_content":"争哥2021年还回复了啊 牛逼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638501411,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":482252,"ip_address":""},"score":535639,"extra":""}]},{"author":{"id":1510988,"avatar":"https://static001.geekbang.org/account/avatar/00/17/0e/4c/1bb6a727.jpg","nickname":"한 양","note":"","ucode":"D76D688ABA0F5E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":353714,"discussion_content":"必然可以呀，看过一些重构的书，还有effective java，都推荐用Optional代替null","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615194638,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134288,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","nickname":"Ken张云忠","note":"","ucode":"D0BAC9FC17DE2B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":163146,"discussion_content":"这是对null对象和值对象的结果做的进一步封装吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581053049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240807,"user_name":"Promise°","can_delete":false,"product_type":"c1","uid":1139384,"ip_address":"","ucode":"0BFDBDAD852D6D","user_header":"https://static001.geekbang.org/account/avatar/00/11/62/b8/bb9657c6.jpg","comment_is_top":false,"comment_ctime":1597071864,"is_pvip":false,"replies":[{"id":"89223","content":"bo对象","user_name":"作者回复","comment_id":240807,"uid":"1190123","ip_address":"","utype":1,"ctime":1597411771,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"18776941048","product_id":100039001,"comment_content":"大家好,第一次发言。有个疑问:各位在Service层返回的是对象还是Result接口","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503567,"discussion_content":"bo对象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597411771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":258492,"user_name":"郑大钱","can_delete":false,"product_type":"c1","uid":1503067,"ip_address":"","ucode":"114CF48056880E","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/5b/ff28088f.jpg","comment_is_top":false,"comment_ctime":1604460519,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14489362407","product_id":100039001,"comment_content":"异常，这对我来说是一个多么陌生的概念。<br>OC中的try catch不能捕获UncaughtException，而内存溢出、野指针等大部分异常都是UncaughtException，而可以捕获的异常基本都是我们可以预防的，所以OC中的异常处理很鸡肋，也因此异常处理对我来说是真空的。异常信息依赖于**Error指针参数。<br>转写dart代码后，发现异常处理居然是一种流程控制语句，抛出异常会影响后续代码的执行。异常流程是一个很优雅的错误处理方案，用上了就停不下来。","like_count":3,"discussions":[{"author":{"id":2806043,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLBFkSq1oiaEMRjtyyv4ZpCI0OuaSsqs04ODm0OkZF6QhsAh3SvqhxibS2n7PLAVZE3QRSn5Hic0DyXg/132","nickname":"ddh","note":"","ucode":"8E852375365F16","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542808,"discussion_content":"大钱","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640849602,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253743,"user_name":"exception","can_delete":false,"product_type":"c1","uid":1180979,"ip_address":"","ucode":"F35ACB5B921353","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/33/c33c0e8a.jpg","comment_is_top":false,"comment_ctime":1602849850,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14487751738","product_id":100039001,"comment_content":"关于函数返回值的问题，之前写代码也纠结过，思考过，目前我在项目中使用如下：<br>定义返回值Result(success, value, errCode, errMessage)和异常同时使用。<br>正常的业务逻辑，都使用Result进行返回，业务逻辑中出现失败的情况，通过错误码进行定义。像文中提到的查询成功但是没有数据的情况，那就是Result的success为true，但是value为空。<br>异常适用于处理非业务逻辑情况，如远程RPC调用失败，网络超时，空指针，等情况才使用异常往外抛。<br>对于受检异常和非受检异常，各自各有优劣吧，不能说谁完全就能代替谁，只要用的得当，都有他的价值，没必要太极端。","like_count":3},{"had_liked":false,"id":247391,"user_name":"大雁小鱼","can_delete":false,"product_type":"c1","uid":1101017,"ip_address":"","ucode":"44090581E59FDA","user_header":"https://static001.geekbang.org/account/avatar/00/10/cc/d9/20d4f7c2.jpg","comment_is_top":false,"comment_ctime":1599699097,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"14484600985","product_id":100039001,"comment_content":"我的领导告诉我，代码稳定是第一位的，如果线上代码没有出错，即便代码写得很烂，都是不允许去修改的，一个标点一个符号都不能修改，更别说小步重构了。所以可以理解为什么有的公司代码永远都是4、5年前的样子，不去动它了。","like_count":4},{"had_liked":false,"id":174030,"user_name":"微思","can_delete":false,"product_type":"c1","uid":1004349,"ip_address":"","ucode":"853C48AA183A7B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/53/3d/1189e48a.jpg","comment_is_top":false,"comment_ctime":1579889417,"is_pvip":true,"replies":[{"id":"67713","content":"新年快乐~","user_name":"作者回复","comment_id":174030,"uid":"1190123","ip_address":"","utype":1,"ctime":1580106729,"user_name_real":"王争"}],"discussion_count":1,"race_medal":4,"score":"14464791305","product_id":100039001,"comment_content":"Happy new year！<br>鼠年大吉🎊🎈🎉🍾️🎆🧧","like_count":3},{"had_liked":false,"id":176409,"user_name":"Ken张云忠","can_delete":false,"product_type":"c1","uid":1134288,"ip_address":"","ucode":"D0BAC9FC17DE2B","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","comment_is_top":false,"comment_ctime":1581052535,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10170987127","product_id":100039001,"comment_content":"对于 generate() 函数，如果本机名获取失败，函数返回什么？这样的返回值是否合理？<br>返回null-时间戳-8位随机数字字母符号的字符串.<br>这样返回合理.因为业务允许一定概率的id重复,并且时间戳-8位随机的数字字母重叠的概率本身就很低,所以代码可以满足业务继续执行,至于最终要不要继续执行可以由上层业务程序控制.<br><br>对于 getLastFiledOfHostName() 函数，是否应该将 UnknownHostException 异常在函数内部吞掉（try-catch 并打印日志）？还是应该将异常继续往上抛出？如果往上抛出的话，是直接把 UnknownHostException 异常原封不动地抛出，还是封装成新的异常抛出？<br>不应该内部吞掉异常,应该直接把异常原封不动地抛出.因为当前是非业务工具类,异常处理该要交由业务程序来处理.<br><br>对于 getLastSubstrSplittedByDot(String hostName) 函数，如果 hostName 为 NULL 或者是空字符串，这个函数应该返回什么？<br>hostName为NULL会抛出空指针异常,这时该要抛出异常由业务程序来处理;hostName为空字符串属于正常业务可以返回空字符串.<br><br>对于 generateRandomAlphameric(int length) 函数，如果 length 小于 0 或者等于 0，这个函数应该返回什么？<br>length小于0时会抛出异常,这时也该要抛出异常由业务程序处理;length等于0时也是正常业务可以返回空字符串.","like_count":2},{"had_liked":false,"id":174013,"user_name":"平风造雨","can_delete":false,"product_type":"c1","uid":1014349,"ip_address":"","ucode":"F9EE4704F31E22","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/4d/b0228a1a.jpg","comment_is_top":false,"comment_ctime":1579876194,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10169810786","product_id":100039001,"comment_content":"不能恢复的异常应该抛出，能处理能恢复的可以吞掉，但是吞掉的异常要有办法在日志或者其它办法看到异常的原因，便于后续排查问题。异常是否要重新定义异常并抛出，不能一概而论，某些情况下，异常的值和类型本身就是接口约定中的一部分，特别是unchecked异常。","like_count":2},{"had_liked":false,"id":225133,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1591665011,"is_pvip":false,"replies":[{"id":"86784","content":"受检异常能明确告知用户处理啊，不是说了吗？😂 如果用户不处理受检异常，代码编译不通过的。","user_name":"作者回复","comment_id":225133,"uid":"1190123","ip_address":"","utype":1,"ctime":1594903606,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"5886632307","product_id":100039001,"comment_content":"这句话不太理解，即便是可恢复的异常依然是向上抛更合理，比如提现金额大于余额就应该告知用户啊。实在想不明白受检查异常的用武之地在哪？<br><br><br>对于代码 bug（比如数组越界）以及不可恢复异常（比如数据库连接失败），即便我们捕获了，也做不了太多事情，所以，我们倾向于使用非受检异常。对于可恢复异常、业务异常，比如提现金额大于余额的异常，我们更倾向于使用受检异常，明确告知调用者需要捕获处理。","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497747,"discussion_content":"受检异常能明确告知用户处理啊，不是说了吗？😂 如果用户不处理受检异常，代码编译不通过的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594903606,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176391,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1581047570,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5876014866","product_id":100039001,"comment_content":"设计模式_36:<br># 作业<br>  1. 返回了null，不合理<br>  2. 直接re-throw<br>  3. 应该返回NULL值<br>  4. 抛出一个自定义的异常<br><br># 感想<br>  异常这种机制的设计，是为了更好地处理真实的异常情况，要合理地使用，不要为了怕麻烦就乱用，制造出一个个排查问题的灾难。","like_count":1},{"had_liked":false,"id":175377,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1580699358,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5875666654","product_id":100039001,"comment_content":"看业务需求吧，如果是唯一性可以返回一个特殊值。如果后续需要通过id获取主机编号等，就要抛异常","like_count":1},{"had_liked":false,"id":173962,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1579834237,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5874801533","product_id":100039001,"comment_content":"从团队的实践来看，异常统一只靠人为约定是比较难实行的，团队成员理解不一样，实际写代码时候各种原因不按约定来。通过插件，或者IDE自动监测的手段会比较好，比如sonar。","like_count":2},{"had_liked":false,"id":173950,"user_name":"阳光","can_delete":false,"product_type":"c1","uid":1151183,"ip_address":"","ucode":"2AE92E2AD77E6F","user_header":"https://static001.geekbang.org/account/avatar/00/11/90/cf/91ec2918.jpg","comment_is_top":false,"comment_ctime":1579819732,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5874787028","product_id":100039001,"comment_content":"打卡","like_count":1},{"had_liked":false,"id":344846,"user_name":"云海过客","can_delete":false,"product_type":"c1","uid":1895698,"ip_address":"","ucode":"11E2890BEDA00D","user_header":"https://static001.geekbang.org/account/avatar/00/1c/ed/12/fd8155f5.jpg","comment_is_top":false,"comment_ctime":1651822440,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651822440","product_id":100039001,"comment_content":"错误码<br>null<br>空值 例如 空串 0 空集合<br>异常 受检异常，非受检异常<br>","like_count":0},{"had_liked":false,"id":337885,"user_name":"i-neojos","can_delete":false,"product_type":"c1","uid":1702997,"ip_address":"","ucode":"1808C25269948A","user_header":"https://static001.geekbang.org/account/avatar/00/19/fc/55/e03bb6db.jpg","comment_is_top":false,"comment_ctime":1647129989,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647129989","product_id":100039001,"comment_content":"代码风格统一最重要","like_count":0},{"had_liked":false,"id":324565,"user_name":"友","can_delete":false,"product_type":"c1","uid":2536820,"ip_address":"","ucode":"972A4333A8B101","user_header":"https://static001.geekbang.org/account/avatar/00/26/b5/74/cd80b9f4.jpg","comment_is_top":false,"comment_ctime":1638501801,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638501801","product_id":100039001,"comment_content":"返回null 不太影响 目前没有更好的策略替换 空hostname  如果随意替换其他东西会造成迷惑<br>捕获住，打印error 日志 然后往上返回一个空字符串<br>空字符<br>空字符","like_count":0},{"had_liked":false,"id":321116,"user_name":"大头","can_delete":false,"product_type":"c1","uid":1011656,"ip_address":"","ucode":"491583C0980A26","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6f/c8/4183a146.jpg","comment_is_top":false,"comment_ctime":1636683594,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636683594","product_id":100039001,"comment_content":"学习了","like_count":0},{"had_liked":false,"id":320233,"user_name":"多学多看多记","can_delete":false,"product_type":"c1","uid":2276155,"ip_address":"","ucode":"0670C833007510","user_header":"https://static001.geekbang.org/account/avatar/00/22/bb/3b/6e020a32.jpg","comment_is_top":false,"comment_ctime":1636165740,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636165740","product_id":100039001,"comment_content":"回答问题：<br>2. getLastFiledOfHostName函数是最底层的函数，出现错误应该返回对应error，由上层函数决定是否处理。<br>3. getLastSubstrSplittedByDot函数相当于中间函数，要做好对入参异常值的处理，当hostName为null时返回空字符串<br>4. generateRandomAlphameric等同于getLastSubstrSplittedByDot函数，返回空字符串<br>1. generate最为最顶层的函数，同时又是非业务代码，不需要关心底层逻辑，开箱即用，有错误也不要上抛，返回默认的错误值即可。内部打好日志，方便以后debug<br>","like_count":0},{"had_liked":false,"id":317483,"user_name":"charmsongo","can_delete":false,"product_type":"c1","uid":1609051,"ip_address":"","ucode":"4FBEE716E93A1A","user_header":"https://static001.geekbang.org/account/avatar/00/18/8d/5b/383a49e4.jpg","comment_is_top":false,"comment_ctime":1634811210,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634811210","product_id":100039001,"comment_content":"1、返回错误码<br>2、返回 NULL 值。但是需要每次对NULL做处理<br>3、返回空对象。可以避免每次都做空处理<br>4、抛出异常对象<br>\t上游方法直接吞掉。异常可以恢复，且不关心，可以直接吞掉<br>\t上游直接向上抛。可以理解，且业务有相关性，可以 继续向上抛<br>\t上游包装成新的异常抛出。异常太底层，缺乏背景理解且业务不相关，包装后向上抛","like_count":0},{"had_liked":false,"id":313554,"user_name":"左耳朵东","can_delete":false,"product_type":"c1","uid":1160678,"ip_address":"","ucode":"60134ACF12BB52","user_header":"https://static001.geekbang.org/account/avatar/00/11/b5/e6/c67f12bd.jpg","comment_is_top":false,"comment_ctime":1632494896,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632494896","product_id":100039001,"comment_content":"还是没理解受检异常，如何识别出受检异常? 在函数定义后面加了 throw xxxException 的就是受检异常吗？","like_count":0},{"had_liked":false,"id":295867,"user_name":"Ricky Gu","can_delete":false,"product_type":"c1","uid":1345636,"ip_address":"","ucode":"EDCD7D7DA60E38","user_header":"https://static001.geekbang.org/account/avatar/00/14/88/64/39501fbe.jpg","comment_is_top":false,"comment_ctime":1622623744,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622623744","product_id":100039001,"comment_content":"最终异常要么吞掉，要么程序崩掉","like_count":0},{"had_liked":false,"id":277792,"user_name":"猴精鸭","can_delete":false,"product_type":"c1","uid":1514660,"ip_address":"","ucode":"7513DC4138E031","user_header":"https://static001.geekbang.org/account/avatar/00/17/1c/a4/202dde43.jpg","comment_is_top":false,"comment_ctime":1612589317,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1612589317","product_id":100039001,"comment_content":"我觉得go的思路就很好，统一使用错误处理，结合多返回值得特性，比较好用。如果是可恢复的错误就选择内部处理或者返回错误，错误中可带有错误码，错误信息和堆栈信息，如果认为这样的错误是不可恢复的直接panic，让程序退出","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473881,"discussion_content":"具体发出来讲讲 不常用的你们都常用在哪里 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573257138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1218960,"avatar":"https://static001.geekbang.org/account/avatar/00/12/99/90/ca2a8632.jpg","nickname":"村长","note":"","ucode":"AB8B2B79387D11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":47015,"discussion_content":"再包括不同的primitive type可以用flyweight模式一次性解决 不需要每次都重新create","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573258686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1218960,"avatar":"https://static001.geekbang.org/account/avatar/00/12/99/90/ca2a8632.jpg","nickname":"村长","note":"","ucode":"AB8B2B79387D11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":47010,"discussion_content":"代码分析里不同的expression或者statement需要不同的visitor来manipulate 这种multiple dispatch应该很常见啊\n当需要处理一个expression又不想改变原来的expression的时候用prototype模式来decouple\n用facade模式把不同transform按顺序封装起来统一执行\n等等等等","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573258429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":269089,"user_name":"Geek_c33872","can_delete":false,"product_type":"c1","uid":2373582,"ip_address":"","ucode":"865BB78FD12390","user_header":"","comment_is_top":false,"comment_ctime":1608520107,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608520107","product_id":100039001,"comment_content":"对于 getLastSubstrSplittedByDot 和 generateRandomAlphameric 方法，既然声明为 protected 且使用也只局限在类内部，我想应该不需要额外增加异常处理代码，而是在调用时遵守设计规范。也就是说 generate 方法保证永远不会传递无效的参数给 generateRandomAlphameric 方法。","like_count":0},{"had_liked":false,"id":264977,"user_name":"春山","can_delete":false,"product_type":"c1","uid":1578956,"ip_address":"","ucode":"435980BA26DF3D","user_header":"https://static001.geekbang.org/account/avatar/00/18/17/cc/e33bef77.jpg","comment_is_top":false,"comment_ctime":1606726388,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1606726388","product_id":100039001,"comment_content":"* 错误码、null值、特殊值(-1)、空对象(空字符串、空集合)<br>* 错误码<br>* NULL值<br>  * 表示不存在的语义，<br>  * 可以返回null，不强制返回空对象，注释说明什么情况下会返回null值，做到项目的统一<br>  * 没有查找到是一种正常而非异常的行为<br>  * 编程契约，明确责任，防止NPE是调用者的责任?<br>  * Optional<br><br>* 空对象<br>  * 不用做null值判断了<br><br>* 抛出异常对象<br>  * 异常可以将正常逻辑和异常逻辑的处理分离开来，不要使用异常做流程控制、条件控制<br>  * 区分稳定代码和非稳定代码，不要大段的trycatch<br>  * 非受检异常，比如数组越界，数据库连接超时，捕获也做不了太多的事情，倾向于使用<br>  * 受检异常，可恢复的异常，业务异常，比如提现金额大于余额的异常，明确告知调用者需要捕获处理。<br><br>* java的非受检异常VS受检异常，受检异常被人诟病<br>* 异常的处理方式<br>  * 吞掉<br>    * 异常是可以恢复的，且调用者并不关心此异常，就可以吞掉<br>  * 直接抛出<br>    * 调用者是可以理解的、关心的、在业务上有一定的相关性，可以直接抛出<br>  * 包装后抛出<br>    * 当前异常太底层、调用者缺乏背景去理解、且业务概念上无关，可以重新包装成调用者可以理解的新异常，然后re-throw<br><br>* 契约<br>  * 更负责的方式，是否抛出，看上层是否关心这个异常，是否包装抛出新异常，看上层能不能理解这个异常，是不是业务相关的。<br>  * 不太负责人的方式，如果不确定关心不关心、能不能理解，就先抛给上层？","like_count":0},{"had_liked":false,"id":252494,"user_name":"RedDevil","can_delete":false,"product_type":"c1","uid":1131128,"ip_address":"","ucode":"F8F5DC209BB3B9","user_header":"https://static001.geekbang.org/account/avatar/00/11/42/78/7ba89c75.jpg","comment_is_top":false,"comment_ctime":1602318886,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602318886","product_id":100039001,"comment_content":"感谢争哥手把手教我们写代码","like_count":0},{"had_liked":false,"id":232544,"user_name":"冬渐暖","can_delete":false,"product_type":"c1","uid":1586800,"ip_address":"","ucode":"907E41AAE9A36C","user_header":"https://static001.geekbang.org/account/avatar/00/18/36/70/00122b24.jpg","comment_is_top":false,"comment_ctime":1594031918,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594031918","product_id":100039001,"comment_content":"比如你的操作参数有问题 就要抛异常(即说的错误码)<br>throw new BusinessException(MessageCode.PARAM_EMPTY);<br><br>比如你的不影响主流程  就生吞异常，但是要打印日志(比如下单的时候，获取手机号码发送推送失败了，就不要影响下单主流程)，影响就要继续往外抛(比如在手动事务的时候，调用这个方法没插到数据，你就要在catch抛，告诉外层的人有异常)。<br><br>比如你什么都没拿到 但是鸭皮要求给个数组 你就只能返回个空list","like_count":0},{"had_liked":false,"id":223790,"user_name":"未来小娃","can_delete":false,"product_type":"c1","uid":1047329,"ip_address":"","ucode":"477D166EBB6B70","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/21/d017438c.jpg","comment_is_top":false,"comment_ctime":1591181725,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1591181725","product_id":100039001,"comment_content":"【设计模式笔记36】2020603<br>函数出错应该返回啥，这个依据具体场景具体分析。首先需要确定现在代码返回啥并且思考是否合理。是否合理有大概的标准，总体上会返回以下值：异常、错误码、null对象。如果抛出异常调用方需要手动处理，这包括业务异常和非业务异常，如果是业务异常依据内部标准确定返回错误码或者异常，统一即可。如果是系统异常调用方就需要选择继续处理还是往上抛。对于查询等服务代码，没查到返回null或者抛异常都可以，上下游选择统一的约定即可。还有一类场景实在使用guava cache时遇到的，如果返回null会抛出InvalidCacheException，这种因为使用时没注意到就会抛给上层代码，如果没处理就会影响其他代码执行，所以约定统一的标准很重要","like_count":0},{"had_liked":false,"id":221755,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1590585169,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590585169","product_id":100039001,"comment_content":"先判断异常，再使用函数返回值。无异常情况下如何表示nil值？<br>原则是减少使用者判断空指针，大量判断集合和字符串是否为nil，可读性不好，函数可以返回空集合、空字符串、特殊值。<br><br>返回异常的三种方式：<br>1.自己吃掉异常：无需调用者知道。可恢复业务，异常时可以继续执行。<br>2.原样抛出异常；让调用者决定如何处理。可恢复业务，调用者关注和理解异常。<br>3.包装后抛出：异常太底层，调用者不理解，包装成调用者理解的异常。","like_count":0},{"had_liked":false,"id":221751,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1590582850,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590582850","product_id":100039001,"comment_content":"不要返回null，因为要使用函数返回值时要判断null值，代码可读性不好，返回空集合和变量类型的默认值。","like_count":0},{"had_liked":false,"id":218383,"user_name":"炫炫","can_delete":false,"product_type":"c1","uid":1358609,"ip_address":"","ucode":"FDC7A0C6E08B02","user_header":"https://static001.geekbang.org/account/avatar/00/14/bb/11/7069b8eb.jpg","comment_is_top":false,"comment_ctime":1589793236,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589793236","product_id":100039001,"comment_content":"往上抛，原封不动","like_count":0},{"had_liked":false,"id":207547,"user_name":"新的起点，新的开始^_^","can_delete":false,"product_type":"c1","uid":1262068,"ip_address":"","ucode":"9C0810F472AC93","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/f4/5df17eff.jpg","comment_is_top":false,"comment_ctime":1587105658,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587105658","product_id":100039001,"comment_content":"争哥，我有个比较疑惑的问题，不过和当前的栏目主题没关系。<br>项目是个微服务A,B,C三个项目分别部署<br>问题：pojo类，枚举类，工具类<br>疑惑：<br>做法一：这三个类写到一个D项目，打包到maven中然后让A,B,C依赖这个项目，但是这样耦合太强，单独把A项目拎出来的话，就得将D项目也拿出来。<br>做法二：哪个项目需要，就写到哪个项目中去，造成粘贴复制，代码无法复用，User类既在A中也在B中(其实有想过B中使用map或者json来处理)<br>请问下争哥有什么好的建议吗<br><br><br>","like_count":0},{"had_liked":false,"id":205674,"user_name":"William Ning","can_delete":false,"product_type":"c1","uid":1592279,"ip_address":"","ucode":"4DB8D05E69E5F3","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","comment_is_top":false,"comment_ctime":1586699985,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1586699985","product_id":100039001,"comment_content":"这个确实是一直不明白应该如何处理, 继续阅读, 思考总结.","like_count":0},{"had_liked":false,"id":187335,"user_name":"空白昵称","can_delete":false,"product_type":"c1","uid":1433815,"ip_address":"","ucode":"91F50CA25102AB","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/d7/744bd8c3.jpg","comment_is_top":false,"comment_ctime":1584086522,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584086522","product_id":100039001,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":186670,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1583899476,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583899476","product_id":100039001,"comment_content":"1. 我认为应该返回空串，<br>2.我认为应该封装成新的异常向上抛出，从而更具体的表现出现的问题。<br>3. 我认为应该抛出异常。因为得到了一个预期之外的参数。要告诉调用方，参数存在问题。<br>4. 同上。参数存在的问题，应该告知调用方。","like_count":0},{"had_liked":false,"id":185398,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1583574297,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1583574297","product_id":100039001,"comment_content":"<br>1.对于 generate() 函数，如果本机名获取失败，函数返回什么？这样的返回值是否合理？<br>答：应该直接抛出异常，主动告知调用者<br><br>2.对于 getLastFiledOfHostName() 函数，是否应该将 UnknownHostException 异常在函数内部吞掉（try-catch 并打印日志）？还是应该将异常继续往上抛出？如果往上抛出的话，是直接把 UnknownHostException 异常原封不动地抛出，还是封装成新的异常抛出？<br>答：应该原封不动的抛出异常，方便调用者快速定位异常点。并且同时记录日志<br><br>3.对于 getLastSubstrSplittedByDot(String hostName) 函数，如果 hostName 为 NULL 或者是空字符串，这个函数应该返回什么？<br>答：抛出异常<br><br>4.对于 generateRandomAlphameric(int length) 函数，如果 length 小于 0 或者等于 0，这个函数应该返回什么？<br>答：抛出异常<br><br><br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473826,"discussion_content":"抱歉 这个模式在后端开发中确实不常用 我主要是做后端开发 js的东西不怎么了解 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573253968,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184982,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1583462116,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583462116","product_id":100039001,"comment_content":"思考题：<br>1.对于 generate() 函数，如果本机名获取失败，函数返回什么？这样的返回值是否合理？<br>答：返回异常，合理<br><br>2.对于 getLastFiledOfHostName() 函数，是否应该将 UnknownHostException 异常在函数内部吞掉（try-catch 并打印日志）？还是应该将异常继续往上抛出？如果往上抛出的话，是直接把 UnknownHostException 异常原封不动地抛出，还是封装成新的异常抛出？<br>答：继续往上抛，原封不动抛出<br><br><br>3.对于 getLastSubstrSplittedByDot(String hostName) 函数，如果 hostName 为 NULL 或者是空字符串，这个函数应该返回什么？<br>答：null，因为本身就没有主机信息，因此返回null比较合理。<br><br><br><br>4.对于 generateRandomAlphameric(int length) 函数，如果 length 小于 0 或者等于 0，这个函数应该返回什么？<br>答：返回字符串","like_count":0,"discussions":[{"author":{"id":1434857,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e4/e9/1ab7a3be.jpg","nickname":"Gandalf","note":"","ucode":"969B80B7128FA7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":48966,"discussion_content":"怎么操作?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573541434,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184321,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1583289941,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583289941","product_id":100039001,"comment_content":"我们如何针对上面的四个函数,在出错的时候返回什么异常信息呢<br>对于第一个generate,我认为应该抛出一个自定义的异常,让顶层的异常处理器可以捕获这个异常,并且手动定义异常的信息<br>对于第二个函数,则是将异常原封不断的直接抛出,方便上层generate()函数的补货,因为获取不到hostName并不是正确的<br>对于第三个函数,则是返回空字符串,虽然是一个私有的方法,但是这个实现类如果接下来实现的新的接口,而要复用这个方法的话,这个函数的逻辑可能有所改变,返回一个&quot;&quot;相对稳妥<br>第四个函数,则直接返回空字符串即可,这符合这个函数的定义","like_count":0},{"had_liked":false,"id":183510,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1583055540,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583055540","product_id":100039001,"comment_content":"一段好代码的标准真高啊！","like_count":0},{"had_liked":false,"id":182185,"user_name":"请叫我和尚","can_delete":false,"product_type":"c1","uid":1703256,"ip_address":"","ucode":"33A8A1CDA103F9","user_header":"https://static001.geekbang.org/account/avatar/00/19/fd/58/1af629c7.jpg","comment_is_top":false,"comment_ctime":1582726762,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1582726762","product_id":100039001,"comment_content":"1. 看上层对于这个host是否必须这种格式，如果必须就抛出异常，不必须就正常返回<br>2. 抛给上层，因为这个对于上层有关系，直接抛不包装，异常unknownHost非常明确<br>3. 看业务对于substrOfHostName是不是必须要求这种格式，如果必须那就抛异常，不必须返回空字符串<br>4. 返回空字符串，说明就是不需要后缀","like_count":0},{"had_liked":false,"id":178886,"user_name":"独舟泛海","can_delete":false,"product_type":"c1","uid":1238514,"ip_address":"","ucode":"E35C8CEFAF062D","user_header":"https://static001.geekbang.org/account/avatar/00/12/e5/f2/21ea4d37.jpg","comment_is_top":false,"comment_ctime":1581845673,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581845673","product_id":100039001,"comment_content":"1.不应该抛出异常，直接返回null-时间戳-随机数，不能因为这个影响业务代码流程<br>2.原封不动向上抛，上游需要感知<br>3.&quot;&quot;<br>4.参数错误异常","like_count":0},{"had_liked":false,"id":178379,"user_name":"氧气🌙 🐟 🌺","can_delete":false,"product_type":"c1","uid":1591015,"ip_address":"","ucode":"8E23C210A9F09E","user_header":"https://static001.geekbang.org/account/avatar/00/18/46/e7/e20279ea.jpg","comment_is_top":false,"comment_ctime":1581673918,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581673918","product_id":100039001,"comment_content":"1 返回异常<br>2 封装成新的异常抛出<br>3 抛出异常<br>4 抛出异常","like_count":0},{"had_liked":false,"id":177794,"user_name":"我行我素","can_delete":false,"product_type":"c1","uid":1224678,"ip_address":"","ucode":"4C69542FAB0671","user_header":"https://static001.geekbang.org/account/avatar/00/12/af/e6/9c77acff.jpg","comment_is_top":false,"comment_ctime":1581501878,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581501878","product_id":100039001,"comment_content":"麻烦想请问下，文中说的：受检查异常是编译时异常，非受检查异常是运行时期异常；后面文中又说：数组角标越界和数据库连接失败是属于非受检查异常，取款金额大于余额是受检查异常；但是在程序尚未运行的时候只有数组角标越界和取款金额大于余额也无从得知，是否是取款金额大于余额和数组角标越界是非受检查异常(运行中不行就报错)，数据库连接失败是受检查异常(运行时连接不上直接停止程序)","like_count":0},{"had_liked":false,"id":175652,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1580790602,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580790602","product_id":100039001,"comment_content":"第一问generate()函数出错 要返回值 那应该返回-1表示一个异常的值<br>第二问应该向上抛出 毕竟调用函数还需要关心他的返回值<br>第三问 空字符串<br>第四问 返回-1表示一个异常值","like_count":0},{"had_liked":false,"id":175290,"user_name":"弹簧人","can_delete":false,"product_type":"c1","uid":1697679,"ip_address":"","ucode":"BCB4A6FC76EA17","user_header":"https://static001.geekbang.org/account/avatar/00/19/e7/8f/56387f77.jpg","comment_is_top":false,"comment_ctime":1580644377,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580644377","product_id":100039001,"comment_content":"func1() 抛出的异常是可以恢复。争哥，这个不是很明白。可恢复是指，func1中自己try catch吞掉，然后后续通过查看错误日志，手动恢复这个错误吗","like_count":0},{"had_liked":false,"id":175211,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1580616763,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1580616763","product_id":100039001,"comment_content":"这节课堪称经典!!!😭","like_count":0},{"had_liked":false,"id":174416,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1580201033,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580201033","product_id":100039001,"comment_content":"课堂讨论:<br><br><br><br>1. 对于 generate() 函数，如果本机名获取失败，函数返回什么？这样的返回值是否合理？<br><br>   本机名获取失败时函数将返回null,是不合理的.除非特殊说明,否则上层调用者可能忽视null的存在,从而引发npe.<br><br>   <br><br>2. 对于 getLastFiledOfHostName() 函数，是否应该将 UnknownHostException 异常在函数内部吞掉（try-catch 并打印日志）？还是应该将异常继续往上抛出？如果往上抛出的话，是直接把 UnknownHostException 异常原封不动地抛出，还是封装成新的异常抛出？<br><br>   ​    首先,本人极端不愿使用Checked-Exception.异常在函数内部吞掉是不好的行为,因为发生异常时,上层调用者并不知道.除非经过妥善的处理,否则会影响业务的正常执行.<br><br>   ​    如果在使用CE的情况下,是一定要向上抛出的.视情况是否包装成新的异常:原始异常准确达意,调用者很容易理解就可以直接抛出,原始异常有歧义或可能导致调用者困惑,就应该封装成新的异常.<br><br>   <br><br>3. 对于 getLastSubstrSplittedByDot(String hostName) 函数，如果 hostName 为 NULL 或者是空字符串，这个函数应该返回什么？<br><br>   先贴原始代码<br><br>​        @VisibleForTesting <br><br>​\t\tprotected String getLastSubstrSplittedByDot(String hostName) {<br><br>​\t\t    String[] tokens = hostName.split(&quot;\\\\.&quot;); <br><br>​            String substrOfHostName = tokens[tokens.length - 1]; <br><br>​            return substrOfHostName;<br><br>​     }<br><br>​        原始情况下,会因为hostName为null产生的npe导致程序运行crash.可以为此函数添加一个用于校验      hostName合法的isHostNameValid()函数,在hostName非法时抛出运行时异常(Runtime-Exception),或在非法时返回代表非法的常量值.<br><br><br><br>4. 对于 generateRandomAlphameric(int length) 函数，如果 length 小于 0 或者等于 0，这个函数应该返回什么？<br><br>​        应该抛出运行时异常或返回代表非法的常量值.","like_count":0},{"had_liked":false,"id":174300,"user_name":"啦啦啦","can_delete":false,"product_type":"c1","uid":1131687,"ip_address":"","ucode":"6B12EC90A62525","user_header":"https://static001.geekbang.org/account/avatar/00/11/44/a7/171c1e86.jpg","comment_is_top":false,"comment_ctime":1580128306,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580128306","product_id":100039001,"comment_content":"武汉加油","like_count":0},{"had_liked":false,"id":174282,"user_name":"逍遥思","can_delete":false,"product_type":"c1","uid":1015512,"ip_address":"","ucode":"340F05C786730F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/d8/92a98fb6.jpg","comment_is_top":false,"comment_ctime":1580119839,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580119839","product_id":100039001,"comment_content":"1. 返回”null-1577456311467-3nR3Do45”，不够合理，但勉强能接受<br>2. 应该吞掉，因为 generate() 并不关心 getLastFiledOfHostName() 抛出的异常<br>3. 返回 null<br>4. 返回空字符串<br><br>思考是为了下节课吸收更多！","like_count":0},{"had_liked":false,"id":174123,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1580011530,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1580011530","product_id":100039001,"comment_content":"做一个SZ程序员，不做MS程序员！跟进！","like_count":0},{"had_liked":false,"id":174082,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1018370,"ip_address":"","ucode":"7A488CC6FE15E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","comment_is_top":false,"comment_ctime":1579956177,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579956177","product_id":100039001,"comment_content":"返回错误码这种情况，在写RPC接口，返回时经常用到。在刚开始开发工作时，我常用的函数出错返回类型是返回NULL值和抛出异常对象。后面逐接触到对于集合，如果无数据返回空集合这种方法。学习Java8后，为了避免NPE，可以使用Optional类来处理。听过某人说对于调用别人写的函数返回集合类型的数据，最好自己先判断NULL，再处理。如果是自己写返回集合数据的接口，若无数据，返回空集合，不要返回NULL，不要指望别人帮你处理好NULL的情况。以前对于函数出错时，怎么处理异常，一直没有一个很好的理解，自己常用的做法就是往上抛出。","like_count":0},{"had_liked":false,"id":174065,"user_name":"L🚲🐱","can_delete":false,"product_type":"c1","uid":1577856,"ip_address":"","ucode":"08A012739614DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","comment_is_top":false,"comment_ctime":1579939424,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579939424","product_id":100039001,"comment_content":"1. 对于 generate() 函数，如果本机名获取失败，函数返回什么？这样的返回值是否合理？: 抛出异常, 因为获取失败是一个异常情况, 所以需要返回异常<br>2. 对于 getLastFiledOfHostName() 函数，是否应该将 UnknownHostException 异常在函数内部吞掉（try-catch 并打印日志）？还是应该将异常继续往上抛出？如果往上抛出的话，是直接把 UnknownHostException 异常原封不动地抛出，还是封装成新的异常抛出？: 继续原封不动的往上抛出, 可以在 Controller 层统一处理, 这样子异常的代码会比较统一的处理, 该异常的描述已经很明确了, 可以通过类名知道这个异常是什么.<br>3. 对于 getLastSubstrSplittedByDot(String hostName) 函数，如果 hostName 为 NULL 或者是空字符串，这个函数应该返回什么？: hostName 为空是一种异常, 应该抛出异常, 因为入参 hostName 不能为空<br>4. 对于 generateRandomAlphameric(int length) 函数，如果 length 小于 0 或者等于 0，这个函数应该返回什么？: 按照项目组统一规定来, 个人习惯返回 空字符串, 这么返回是方便调用方不用做非空判断","like_count":0},{"had_liked":false,"id":174016,"user_name":"前端西瓜哥","can_delete":false,"product_type":"c1","uid":1248576,"ip_address":"","ucode":"150130C34CD1C1","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/40/f70e5653.jpg","comment_is_top":false,"comment_ctime":1579880345,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579880345","product_id":100039001,"comment_content":"个人见解。<br><br>1. 获取本机名失败可以返回一个默认值，比如 &quot;unknown&quot;。因为 Id 只要随机就行，hostName其实不是很重要。不过可以考虑发送一个提醒，告知开发者运行环境有无法获取本机名的问题。<br>2. 建议吞掉。因为这个问题并不严重，没有必要停止程序。如果要往上抛出，原封不动地抛出，因为这个抛出错误原因很容易理解，不需要进一步包装。<br>3. 返回空字符吧。进行 NULL 判断可读性不好。<br>4. 感觉抛出错误比较好，因为这个算是开发者不细心了，让开发者知道错误，然后进行修改。如果不抛出错误，可以考虑返回空字符数组。","like_count":0},{"had_liked":false,"id":174003,"user_name":"ちよくん","can_delete":false,"product_type":"c1","uid":1398577,"ip_address":"","ucode":"B71E9B16E4408F","user_header":"https://static001.geekbang.org/account/avatar/00/15/57/31/6772744d.jpg","comment_is_top":false,"comment_ctime":1579864137,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579864137","product_id":100039001,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":173998,"user_name":"JamesPxy","can_delete":false,"product_type":"c1","uid":1320179,"ip_address":"","ucode":"558D707463589D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q2LT8JFWSghiaVbMMOkOkLnuibEqG2YOyEdCA5icEZH3Qpd9pL23mpzic9tWwyiciaBicE4YPMVnITOodulwG2SS75r2w/132","comment_is_top":false,"comment_ctime":1579858462,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1579858462","product_id":100039001,"comment_content":"新年快乐，开心实战！","like_count":0},{"had_liked":false,"id":173997,"user_name":"相逢是缘","can_delete":false,"product_type":"c1","uid":1060730,"ip_address":"","ucode":"CB299F53A95654","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg","comment_is_top":false,"comment_ctime":1579857772,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579857772","product_id":100039001,"comment_content":"打卡<br>函数出错应该返回？\t<br>1）返回错误码（C语言，其他的语音可能抛出异常）<br>2）返回NULL<br>（对于“没有查找到”，返回null更为合理）<br>3）返回空对象（不用做NULL值判断）<br>4）抛出异常值对象<br>对于函数抛出的异常，我们有三种处理方法：直接吞掉、直接往上抛出、包裹成新的异常抛出。对于是否将异常继续向上抛，需要看上层代码是否关心这个异常。如果上层代码不能理解这个异常、和业务不相关，需要把异常重新封装，向上层业务抛出新的异常。","like_count":0},{"had_liked":false,"id":173986,"user_name":"皮卡皮卡","can_delete":false,"product_type":"c1","uid":1216284,"ip_address":"","ucode":"D440EEC7301C76","user_header":"https://static001.geekbang.org/account/avatar/00/12/8f/1c/1c728388.jpg","comment_is_top":false,"comment_ctime":1579849150,"is_pvip":true,"replies":[{"id":"67715","content":"嗯嗯 收到 我改下","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1580112217,"ip_address":"","comment_id":173986,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1579849150","product_id":100039001,"comment_content":"返回空对象章节中，return Collectiosn.emptyList();出现拼写错误，应该是Collections.emptyList();","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473627,"discussion_content":"后面有讲到的 别急","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573257635,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173963,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1579834261,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579834261","product_id":100039001,"comment_content":"1. 获取不到本机名，抛出异常<br>2. 往上跑，可以包装为新的异常<br>3. 返回null值<br>4. 返回空对象","like_count":0},{"had_liked":false,"id":173954,"user_name":"黄林晴","can_delete":false,"product_type":"c1","uid":1362631,"ip_address":"","ucode":"B15C38AECDA88F","user_header":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","comment_is_top":false,"comment_ctime":1579826584,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579826584","product_id":100039001,"comment_content":"打卡✔<br>新年快乐","like_count":0},{"had_liked":false,"id":173964,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1579835415,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"452551401495","product_id":100039001,"comment_content":"回答问题<br>1.抛出异常，因为服务器获取不到host是一种异常情况，并且打印的异常日志不能是warm,而是err，因为该异常不会自动回复。<br><br>2.往上抛，原封不动。应该在api统一出口处处理异常，这样异常代码会比较聚合（个人习惯）。该异常描述已经很准确，且处理异常依旧在genId接口中，所以上层函数可以认识该异常，所以原封不动。（而统一出口函数，则可以抛自定义异常，以收敛api使用方的考虑范围）。<br><br>3.抛出异常，null值裁剪名称是一种异常情况。或则说，对于裁剪名称这个函数，入参不能为null。<br><br>4.返回空字符串。小于等于0说明不需要带随机后缀，这也是一个正常的业务场景。返回空字符串是为了方便调用方不用做null判断。<br><br><br>分歧：<br>1.get,find,select等dao层操作，返回null是正常业务情况，表示数据不存在。但在其应用层，数据不存在可能意味着有脏数据，数据缺失等情况，属于异常情况，需要抛出异常。所以同样是get方法，持久层返回null，业务层返回可能是异常。<br><br>2.异常流开销大，在对响应时间要求很严格的场景。放弃合理的异常处理，采用不合理的特殊返回值的方式也是合理的。所以合理的运用异常流在java也是一个选择项。在可读和性能我们需要权衡，而这两玩意经常是相驳的。<br><br>最后：<br>祝栏主和同学们新年快乐！","like_count":106},{"had_liked":false,"id":174091,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1579959355,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"91774272571","product_id":100039001,"comment_content":"1、不抛。返回null-123123784378-aldjf780。从功能上讲，函数是生成logtraceid，用于给记录加id，便于查找日志。返回null不影响定位问题，同时程序不会蹦。<br>2、上抛，到generate中处理。<br>3、返回空串<br>4、返回空串","like_count":22,"discussions":[{"author":{"id":1220273,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9e/b1/758f2fe7.jpg","nickname":"香","note":"","ucode":"121D6CECECEEC3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340518,"discussion_content":"我个人是比较支持这一点，因为即使是返回了带null的id，但只要它能够达到我们的业务目的，我觉得就是ok，技术本身还是服务于业务，所以我也认为不抛，因为当前我们用此id的目的仅仅是用于定位同一个请求的log.\n当然，如果后续我们需要在日志里加入某些需要追踪的信息，而这些信息跟节点是强相关的，那么这时就需要抛出。\n总的来说，就是看业务需求。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1610022779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179517,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1582019220,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"74596463252","product_id":100039001,"comment_content":"Go语言函数返回的时候分正确值、错误值，比较简单","like_count":18},{"had_liked":false,"id":174238,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1580105087,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"27349908863","product_id":100039001,"comment_content":"对于今天课堂留的作业，我采用了统一的思路—能用异常解决的都用异常解决。<br><br>1.对于 generate() 函数，如果本机名获取失败，函数返回什么？这样的返回值是否合理？<br>答：抛出异常，这是一个无法恢复的情况，打断正常的处理流程并进入异常逻辑处理模块<br><br>2. 对于 getLastFiledOfHostName() 函数，是否应该将 UnknownHostException 异常在函数内部吞掉（try-catch 并打印日志）？还是应该将异常继续往上抛出？如果往上抛出的话，是直接把 UnknownHostException 异常原封不动地抛出，还是封装成新的异常抛出？<br>答：不应该内部吞掉，应该抛出到上层做统一的异常处理，这里是个单一的模块，不需要再封装<br><br>3. 对于 getLastSubstrSplittedByDot(String hostName) 函数，如果 hostName 为 NULL 或者是空字符串，这个函数应该返回什么？<br>答：抛出异常，异常消息是—hostName为NULL或空字符串<br><br>4. 对于 generateRandomAlphameric(int length) 函数，如果 length 小于 0 或者等于 0，这个函数应该返回什么？<br>答：抛出异常，异常消息是—参数不合法","like_count":7},{"had_liked":false,"id":173948,"user_name":"sunnywhy","can_delete":false,"product_type":"c1","uid":1513427,"ip_address":"","ucode":"061F4DED04738A","user_header":"https://static001.geekbang.org/account/avatar/00/17/17/d3/936f4599.jpg","comment_is_top":false,"comment_ctime":1579816344,"is_pvip":true,"replies":[{"id":"67716","content":"可以，Java8的语法，因为有些朋友不熟悉java语言，所以高级语法我就没讲了","user_name":"作者回复","comment_id":173948,"uid":"1190123","ip_address":"","utype":1,"ctime":1580112293,"user_name_real":"王争"}],"discussion_count":4,"race_medal":0,"score":"23054652824","product_id":100039001,"comment_content":"第二种返回Null的情况，可以使用Optional吗","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482252,"discussion_content":"可以，Java8的语法，因为有些朋友不熟悉java语言，所以高级语法我就没讲了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580112293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2536820,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b5/74/cd80b9f4.jpg","nickname":"友","note":"","ucode":"972A4333A8B101","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":535639,"discussion_content":"争哥2021年还回复了啊 牛逼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638501411,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":482252,"ip_address":""},"score":535639,"extra":""}]},{"author":{"id":1510988,"avatar":"https://static001.geekbang.org/account/avatar/00/17/0e/4c/1bb6a727.jpg","nickname":"한 양","note":"","ucode":"D76D688ABA0F5E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":353714,"discussion_content":"必然可以呀，看过一些重构的书，还有effective java，都推荐用Optional代替null","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615194638,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134288,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","nickname":"Ken张云忠","note":"","ucode":"D0BAC9FC17DE2B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":163146,"discussion_content":"这是对null对象和值对象的结果做的进一步封装吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581053049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240807,"user_name":"Promise°","can_delete":false,"product_type":"c1","uid":1139384,"ip_address":"","ucode":"0BFDBDAD852D6D","user_header":"https://static001.geekbang.org/account/avatar/00/11/62/b8/bb9657c6.jpg","comment_is_top":false,"comment_ctime":1597071864,"is_pvip":false,"replies":[{"id":"89223","content":"bo对象","user_name":"作者回复","comment_id":240807,"uid":"1190123","ip_address":"","utype":1,"ctime":1597411771,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"18776941048","product_id":100039001,"comment_content":"大家好,第一次发言。有个疑问:各位在Service层返回的是对象还是Result接口","like_count":5},{"had_liked":false,"id":258492,"user_name":"郑大钱","can_delete":false,"product_type":"c1","uid":1503067,"ip_address":"","ucode":"114CF48056880E","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/5b/ff28088f.jpg","comment_is_top":false,"comment_ctime":1604460519,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14489362407","product_id":100039001,"comment_content":"异常，这对我来说是一个多么陌生的概念。<br>OC中的try catch不能捕获UncaughtException，而内存溢出、野指针等大部分异常都是UncaughtException，而可以捕获的异常基本都是我们可以预防的，所以OC中的异常处理很鸡肋，也因此异常处理对我来说是真空的。异常信息依赖于**Error指针参数。<br>转写dart代码后，发现异常处理居然是一种流程控制语句，抛出异常会影响后续代码的执行。异常流程是一个很优雅的错误处理方案，用上了就停不下来。","like_count":3,"discussions":[{"author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385244,"discussion_content":"我一直 觉得比 git commit 有啥意义? 不就是自己的代码提交么, 又不是自己的代码惊天地泣鬼神,有空就写 想起来了 就 push,想不起来了 就本地commit , 所以感觉这个 gitcommitpush 没啥意思.","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1626953166,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2662969,"avatar":"https://static001.geekbang.org/account/avatar/00/28/a2/39/3ee6f996.jpg","nickname":"You","note":"","ucode":"ACBDB82E9B39C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388553,"discussion_content":"人家也没有说要比，是你自己觉得人家在比，单纯对待的态度不一样罢了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1628833407,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":385244,"ip_address":""},"score":388553,"extra":""}]},{"author":{"id":1589894,"avatar":"https://static001.geekbang.org/account/avatar/00/18/42/86/6b2e81ba.jpg","nickname":"Vicent🍀","note":"","ucode":"70AEA72A0B6F0E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":178921,"discussion_content":"加油","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582204124,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253743,"user_name":"exception","can_delete":false,"product_type":"c1","uid":1180979,"ip_address":"","ucode":"F35ACB5B921353","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/33/c33c0e8a.jpg","comment_is_top":false,"comment_ctime":1602849850,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14487751738","product_id":100039001,"comment_content":"关于函数返回值的问题，之前写代码也纠结过，思考过，目前我在项目中使用如下：<br>定义返回值Result(success, value, errCode, errMessage)和异常同时使用。<br>正常的业务逻辑，都使用Result进行返回，业务逻辑中出现失败的情况，通过错误码进行定义。像文中提到的查询成功但是没有数据的情况，那就是Result的success为true，但是value为空。<br>异常适用于处理非业务逻辑情况，如远程RPC调用失败，网络超时，空指针，等情况才使用异常往外抛。<br>对于受检异常和非受检异常，各自各有优劣吧，不能说谁完全就能代替谁，只要用的得当，都有他的价值，没必要太极端。","like_count":3},{"had_liked":false,"id":247391,"user_name":"大雁小鱼","can_delete":false,"product_type":"c1","uid":1101017,"ip_address":"","ucode":"44090581E59FDA","user_header":"https://static001.geekbang.org/account/avatar/00/10/cc/d9/20d4f7c2.jpg","comment_is_top":false,"comment_ctime":1599699097,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"14484600985","product_id":100039001,"comment_content":"我的领导告诉我，代码稳定是第一位的，如果线上代码没有出错，即便代码写得很烂，都是不允许去修改的，一个标点一个符号都不能修改，更别说小步重构了。所以可以理解为什么有的公司代码永远都是4、5年前的样子，不去动它了。","like_count":4,"discussions":[{"author":{"id":1733170,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/x9U78tCoyfhWnFTr6f1AhH4c6ibOFtO6bYjoIM3ByCplx0lUU4wZSms5gic2Wxm7icfia1g8OJSgvqXKHQNPWAaHJQ/132","nickname":"Holland","note":"","ucode":"DE5EF4E8D8D573","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387529,"discussion_content":"老哥都看了哪些课程啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628235265,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2349444,"avatar":"https://static001.geekbang.org/account/avatar/00/23/d9/84/95f8f739.jpg","nickname":"兔兔de反击","note":"","ucode":"6E5C36C2B4D7FE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379551,"discussion_content":"学习","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623973585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1494177,"avatar":"https://static001.geekbang.org/account/avatar/00/16/cc/a1/16d488fc.jpg","nickname":"阿国","note":"","ucode":"2801861BB1C115","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378406,"discussion_content":"优秀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623210452,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1040798,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e1/9e/109f6105.jpg","nickname":"涤生","note":"","ucode":"C3DBA6ED47804B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360371,"discussion_content":"学习","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616424149,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174030,"user_name":"微思","can_delete":false,"product_type":"c1","uid":1004349,"ip_address":"","ucode":"853C48AA183A7B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/53/3d/1189e48a.jpg","comment_is_top":false,"comment_ctime":1579889417,"is_pvip":true,"replies":[{"id":"67713","content":"新年快乐~","user_name":"作者回复","comment_id":174030,"uid":"1190123","ip_address":"","utype":1,"ctime":1580106729,"user_name_real":"王争"}],"discussion_count":1,"race_medal":4,"score":"14464791305","product_id":100039001,"comment_content":"Happy new year！<br>鼠年大吉🎊🎈🎉🍾️🎆🧧","like_count":3,"discussions":[{"author":{"id":2205922,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/YfKHToNzxPh1QfHfetELtKs7nZAgs2QKAaY61a7XCFgAGNqelGukWibSDGXBiaibr2LnFXreUoxncoXLGbFlo4DUQ/132","nickname":"曾国祥","note":"","ucode":"33FE5435746712","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318852,"discussion_content":"老哥，完成的如何了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603867257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1254656,"avatar":"https://static001.geekbang.org/account/avatar/00/13/25/00/3afbab43.jpg","nickname":"88591","note":"","ucode":"04CE3E46455185","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212108,"discussion_content":"加油","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584935654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1077406,"avatar":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","nickname":"jaryoung","note":"","ucode":"6E72D107DB7E51","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":203014,"discussion_content":"去年 我跟你一样定了这个目标，回来放弃了，每一年，出来工作后，重心放在某一点上，例如把spring，ioc di aop，mvc等管理研究透彻。尝试自己仿造Spring手写一些框架 例如mvc ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583983601,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176409,"user_name":"Ken张云忠","can_delete":false,"product_type":"c1","uid":1134288,"ip_address":"","ucode":"D0BAC9FC17DE2B","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","comment_is_top":false,"comment_ctime":1581052535,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10170987127","product_id":100039001,"comment_content":"对于 generate() 函数，如果本机名获取失败，函数返回什么？这样的返回值是否合理？<br>返回null-时间戳-8位随机数字字母符号的字符串.<br>这样返回合理.因为业务允许一定概率的id重复,并且时间戳-8位随机的数字字母重叠的概率本身就很低,所以代码可以满足业务继续执行,至于最终要不要继续执行可以由上层业务程序控制.<br><br>对于 getLastFiledOfHostName() 函数，是否应该将 UnknownHostException 异常在函数内部吞掉（try-catch 并打印日志）？还是应该将异常继续往上抛出？如果往上抛出的话，是直接把 UnknownHostException 异常原封不动地抛出，还是封装成新的异常抛出？<br>不应该内部吞掉异常,应该直接把异常原封不动地抛出.因为当前是非业务工具类,异常处理该要交由业务程序来处理.<br><br>对于 getLastSubstrSplittedByDot(String hostName) 函数，如果 hostName 为 NULL 或者是空字符串，这个函数应该返回什么？<br>hostName为NULL会抛出空指针异常,这时该要抛出异常由业务程序来处理;hostName为空字符串属于正常业务可以返回空字符串.<br><br>对于 generateRandomAlphameric(int length) 函数，如果 length 小于 0 或者等于 0，这个函数应该返回什么？<br>length小于0时会抛出异常,这时也该要抛出异常由业务程序处理;length等于0时也是正常业务可以返回空字符串.","like_count":2},{"had_liked":false,"id":174013,"user_name":"平风造雨","can_delete":false,"product_type":"c1","uid":1014349,"ip_address":"","ucode":"F9EE4704F31E22","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/4d/b0228a1a.jpg","comment_is_top":false,"comment_ctime":1579876194,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10169810786","product_id":100039001,"comment_content":"不能恢复的异常应该抛出，能处理能恢复的可以吞掉，但是吞掉的异常要有办法在日志或者其它办法看到异常的原因，便于后续排查问题。异常是否要重新定义异常并抛出，不能一概而论，某些情况下，异常的值和类型本身就是接口约定中的一部分，特别是unchecked异常。","like_count":2},{"had_liked":false,"id":225133,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1591665011,"is_pvip":false,"replies":[{"id":"86784","content":"受检异常能明确告知用户处理啊，不是说了吗？😂 如果用户不处理受检异常，代码编译不通过的。","user_name":"作者回复","comment_id":225133,"uid":"1190123","ip_address":"","utype":1,"ctime":1594903606,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"5886632307","product_id":100039001,"comment_content":"这句话不太理解，即便是可恢复的异常依然是向上抛更合理，比如提现金额大于余额就应该告知用户啊。实在想不明白受检查异常的用武之地在哪？<br><br><br>对于代码 bug（比如数组越界）以及不可恢复异常（比如数据库连接失败），即便我们捕获了，也做不了太多事情，所以，我们倾向于使用非受检异常。对于可恢复异常、业务异常，比如提现金额大于余额的异常，我们更倾向于使用受检异常，明确告知调用者需要捕获处理。","like_count":1,"discussions":[{"author":{"id":1239557,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ea/05/c0d8014d.jpg","nickname":"一道阳光","note":"","ucode":"F35207CCCEC6E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":194719,"discussion_content":"可以，输出倒逼输入","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583240260,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176391,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1581047570,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5876014866","product_id":100039001,"comment_content":"设计模式_36:<br># 作业<br>  1. 返回了null，不合理<br>  2. 直接re-throw<br>  3. 应该返回NULL值<br>  4. 抛出一个自定义的异常<br><br># 感想<br>  异常这种机制的设计，是为了更好地处理真实的异常情况，要合理地使用，不要为了怕麻烦就乱用，制造出一个个排查问题的灾难。","like_count":1},{"had_liked":false,"id":175377,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1580699358,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5875666654","product_id":100039001,"comment_content":"看业务需求吧，如果是唯一性可以返回一个特殊值。如果后续需要通过id获取主机编号等，就要抛异常","like_count":1},{"had_liked":false,"id":173962,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1579834237,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5874801533","product_id":100039001,"comment_content":"从团队的实践来看，异常统一只靠人为约定是比较难实行的，团队成员理解不一样，实际写代码时候各种原因不按约定来。通过插件，或者IDE自动监测的手段会比较好，比如sonar。","like_count":2},{"had_liked":false,"id":173950,"user_name":"阳光","can_delete":false,"product_type":"c1","uid":1151183,"ip_address":"","ucode":"2AE92E2AD77E6F","user_header":"https://static001.geekbang.org/account/avatar/00/11/90/cf/91ec2918.jpg","comment_is_top":false,"comment_ctime":1579819732,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5874787028","product_id":100039001,"comment_content":"打卡","like_count":1},{"had_liked":false,"id":344846,"user_name":"云海过客","can_delete":false,"product_type":"c1","uid":1895698,"ip_address":"","ucode":"11E2890BEDA00D","user_header":"https://static001.geekbang.org/account/avatar/00/1c/ed/12/fd8155f5.jpg","comment_is_top":false,"comment_ctime":1651822440,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651822440","product_id":100039001,"comment_content":"错误码<br>null<br>空值 例如 空串 0 空集合<br>异常 受检异常，非受检异常<br>","like_count":0},{"had_liked":false,"id":337885,"user_name":"i-neojos","can_delete":false,"product_type":"c1","uid":1702997,"ip_address":"","ucode":"1808C25269948A","user_header":"https://static001.geekbang.org/account/avatar/00/19/fc/55/e03bb6db.jpg","comment_is_top":false,"comment_ctime":1647129989,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647129989","product_id":100039001,"comment_content":"代码风格统一最重要","like_count":0},{"had_liked":false,"id":324565,"user_name":"友","can_delete":false,"product_type":"c1","uid":2536820,"ip_address":"","ucode":"972A4333A8B101","user_header":"https://static001.geekbang.org/account/avatar/00/26/b5/74/cd80b9f4.jpg","comment_is_top":false,"comment_ctime":1638501801,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638501801","product_id":100039001,"comment_content":"返回null 不太影响 目前没有更好的策略替换 空hostname  如果随意替换其他东西会造成迷惑<br>捕获住，打印error 日志 然后往上返回一个空字符串<br>空字符<br>空字符","like_count":0,"discussions":[{"author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"一步","note":"","ucode":"73CEA468CE70C3","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":153256,"discussion_content":"是啊，每天在家就是 吃饭，睡觉，学习","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580040557,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1540988,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKZ16iaIia0029oI1Qh5NicibpbTiaBAaCOPYXoLplKHr6uQ2rSVxPZanBvpMcL2NuhwKQYCFnaHP5tedQ/132","nickname":"FIGNT","note":"","ucode":"D9DB185AE9E67C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":152084,"discussion_content":"还能去哪","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579938644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321116,"user_name":"大头","can_delete":false,"product_type":"c1","uid":1011656,"ip_address":"","ucode":"491583C0980A26","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6f/c8/4183a146.jpg","comment_is_top":false,"comment_ctime":1636683594,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636683594","product_id":100039001,"comment_content":"学习了","like_count":0},{"had_liked":false,"id":320233,"user_name":"多学多看多记","can_delete":false,"product_type":"c1","uid":2276155,"ip_address":"","ucode":"0670C833007510","user_header":"https://static001.geekbang.org/account/avatar/00/22/bb/3b/6e020a32.jpg","comment_is_top":false,"comment_ctime":1636165740,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636165740","product_id":100039001,"comment_content":"回答问题：<br>2. getLastFiledOfHostName函数是最底层的函数，出现错误应该返回对应error，由上层函数决定是否处理。<br>3. getLastSubstrSplittedByDot函数相当于中间函数，要做好对入参异常值的处理，当hostName为null时返回空字符串<br>4. generateRandomAlphameric等同于getLastSubstrSplittedByDot函数，返回空字符串<br>1. generate最为最顶层的函数，同时又是非业务代码，不需要关心底层逻辑，开箱即用，有错误也不要上抛，返回默认的错误值即可。内部打好日志，方便以后debug<br>","like_count":0},{"had_liked":false,"id":317483,"user_name":"charmsongo","can_delete":false,"product_type":"c1","uid":1609051,"ip_address":"","ucode":"4FBEE716E93A1A","user_header":"https://static001.geekbang.org/account/avatar/00/18/8d/5b/383a49e4.jpg","comment_is_top":false,"comment_ctime":1634811210,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634811210","product_id":100039001,"comment_content":"1、返回错误码<br>2、返回 NULL 值。但是需要每次对NULL做处理<br>3、返回空对象。可以避免每次都做空处理<br>4、抛出异常对象<br>\t上游方法直接吞掉。异常可以恢复，且不关心，可以直接吞掉<br>\t上游直接向上抛。可以理解，且业务有相关性，可以 继续向上抛<br>\t上游包装成新的异常抛出。异常太底层，缺乏背景理解且业务不相关，包装后向上抛","like_count":0},{"had_liked":false,"id":313554,"user_name":"左耳朵东","can_delete":false,"product_type":"c1","uid":1160678,"ip_address":"","ucode":"60134ACF12BB52","user_header":"https://static001.geekbang.org/account/avatar/00/11/b5/e6/c67f12bd.jpg","comment_is_top":false,"comment_ctime":1632494896,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632494896","product_id":100039001,"comment_content":"还是没理解受检异常，如何识别出受检异常? 在函数定义后面加了 throw xxxException 的就是受检异常吗？","like_count":0},{"had_liked":false,"id":295867,"user_name":"Ricky Gu","can_delete":false,"product_type":"c1","uid":1345636,"ip_address":"","ucode":"EDCD7D7DA60E38","user_header":"https://static001.geekbang.org/account/avatar/00/14/88/64/39501fbe.jpg","comment_is_top":false,"comment_ctime":1622623744,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622623744","product_id":100039001,"comment_content":"最终异常要么吞掉，要么程序崩掉","like_count":0},{"had_liked":false,"id":277792,"user_name":"猴精鸭","can_delete":false,"product_type":"c1","uid":1514660,"ip_address":"","ucode":"7513DC4138E031","user_header":"https://static001.geekbang.org/account/avatar/00/17/1c/a4/202dde43.jpg","comment_is_top":false,"comment_ctime":1612589317,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1612589317","product_id":100039001,"comment_content":"我觉得go的思路就很好，统一使用错误处理，结合多返回值得特性，比较好用。如果是可恢复的错误就选择内部处理或者返回错误，错误中可带有错误码，错误信息和堆栈信息，如果认为这样的错误是不可恢复的直接panic，让程序退出","like_count":0,"discussions":[{"author":{"id":1608383,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8a/bf/3f7c45c9.jpg","nickname":"X_L～","note":"","ucode":"6BD8C24750F86B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382966,"discussion_content":"其实都一样 整体看过去就是 现代编程语言 异常处理的一条发展历程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625812312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":269089,"user_name":"Geek_c33872","can_delete":false,"product_type":"c1","uid":2373582,"ip_address":"","ucode":"865BB78FD12390","user_header":"","comment_is_top":false,"comment_ctime":1608520107,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608520107","product_id":100039001,"comment_content":"对于 getLastSubstrSplittedByDot 和 generateRandomAlphameric 方法，既然声明为 protected 且使用也只局限在类内部，我想应该不需要额外增加异常处理代码，而是在调用时遵守设计规范。也就是说 generate 方法保证永远不会传递无效的参数给 generateRandomAlphameric 方法。","like_count":0},{"had_liked":false,"id":264977,"user_name":"春山","can_delete":false,"product_type":"c1","uid":1578956,"ip_address":"","ucode":"435980BA26DF3D","user_header":"https://static001.geekbang.org/account/avatar/00/18/17/cc/e33bef77.jpg","comment_is_top":false,"comment_ctime":1606726388,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1606726388","product_id":100039001,"comment_content":"* 错误码、null值、特殊值(-1)、空对象(空字符串、空集合)<br>* 错误码<br>* NULL值<br>  * 表示不存在的语义，<br>  * 可以返回null，不强制返回空对象，注释说明什么情况下会返回null值，做到项目的统一<br>  * 没有查找到是一种正常而非异常的行为<br>  * 编程契约，明确责任，防止NPE是调用者的责任?<br>  * Optional<br><br>* 空对象<br>  * 不用做null值判断了<br><br>* 抛出异常对象<br>  * 异常可以将正常逻辑和异常逻辑的处理分离开来，不要使用异常做流程控制、条件控制<br>  * 区分稳定代码和非稳定代码，不要大段的trycatch<br>  * 非受检异常，比如数组越界，数据库连接超时，捕获也做不了太多的事情，倾向于使用<br>  * 受检异常，可恢复的异常，业务异常，比如提现金额大于余额的异常，明确告知调用者需要捕获处理。<br><br>* java的非受检异常VS受检异常，受检异常被人诟病<br>* 异常的处理方式<br>  * 吞掉<br>    * 异常是可以恢复的，且调用者并不关心此异常，就可以吞掉<br>  * 直接抛出<br>    * 调用者是可以理解的、关心的、在业务上有一定的相关性，可以直接抛出<br>  * 包装后抛出<br>    * 当前异常太底层、调用者缺乏背景去理解、且业务概念上无关，可以重新包装成调用者可以理解的新异常，然后re-throw<br><br>* 契约<br>  * 更负责的方式，是否抛出，看上层是否关心这个异常，是否包装抛出新异常，看上层能不能理解这个异常，是不是业务相关的。<br>  * 不太负责人的方式，如果不确定关心不关心、能不能理解，就先抛给上层？","like_count":0},{"had_liked":false,"id":252494,"user_name":"RedDevil","can_delete":false,"product_type":"c1","uid":1131128,"ip_address":"","ucode":"F8F5DC209BB3B9","user_header":"https://static001.geekbang.org/account/avatar/00/11/42/78/7ba89c75.jpg","comment_is_top":false,"comment_ctime":1602318886,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602318886","product_id":100039001,"comment_content":"感谢争哥手把手教我们写代码","like_count":0},{"had_liked":false,"id":232544,"user_name":"冬渐暖","can_delete":false,"product_type":"c1","uid":1586800,"ip_address":"","ucode":"907E41AAE9A36C","user_header":"https://static001.geekbang.org/account/avatar/00/18/36/70/00122b24.jpg","comment_is_top":false,"comment_ctime":1594031918,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594031918","product_id":100039001,"comment_content":"比如你的操作参数有问题 就要抛异常(即说的错误码)<br>throw new BusinessException(MessageCode.PARAM_EMPTY);<br><br>比如你的不影响主流程  就生吞异常，但是要打印日志(比如下单的时候，获取手机号码发送推送失败了，就不要影响下单主流程)，影响就要继续往外抛(比如在手动事务的时候，调用这个方法没插到数据，你就要在catch抛，告诉外层的人有异常)。<br><br>比如你什么都没拿到 但是鸭皮要求给个数组 你就只能返回个空list","like_count":0},{"had_liked":false,"id":223790,"user_name":"未来小娃","can_delete":false,"product_type":"c1","uid":1047329,"ip_address":"","ucode":"477D166EBB6B70","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/21/d017438c.jpg","comment_is_top":false,"comment_ctime":1591181725,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1591181725","product_id":100039001,"comment_content":"【设计模式笔记36】2020603<br>函数出错应该返回啥，这个依据具体场景具体分析。首先需要确定现在代码返回啥并且思考是否合理。是否合理有大概的标准，总体上会返回以下值：异常、错误码、null对象。如果抛出异常调用方需要手动处理，这包括业务异常和非业务异常，如果是业务异常依据内部标准确定返回错误码或者异常，统一即可。如果是系统异常调用方就需要选择继续处理还是往上抛。对于查询等服务代码，没查到返回null或者抛异常都可以，上下游选择统一的约定即可。还有一类场景实在使用guava cache时遇到的，如果返回null会抛出InvalidCacheException，这种因为使用时没注意到就会抛给上层代码，如果没处理就会影响其他代码执行，所以约定统一的标准很重要","like_count":0},{"had_liked":false,"id":221755,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1590585169,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590585169","product_id":100039001,"comment_content":"先判断异常，再使用函数返回值。无异常情况下如何表示nil值？<br>原则是减少使用者判断空指针，大量判断集合和字符串是否为nil，可读性不好，函数可以返回空集合、空字符串、特殊值。<br><br>返回异常的三种方式：<br>1.自己吃掉异常：无需调用者知道。可恢复业务，异常时可以继续执行。<br>2.原样抛出异常；让调用者决定如何处理。可恢复业务，调用者关注和理解异常。<br>3.包装后抛出：异常太底层，调用者不理解，包装成调用者理解的异常。","like_count":0},{"had_liked":false,"id":221751,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1590582850,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590582850","product_id":100039001,"comment_content":"不要返回null，因为要使用函数返回值时要判断null值，代码可读性不好，返回空集合和变量类型的默认值。","like_count":0},{"had_liked":false,"id":218383,"user_name":"炫炫","can_delete":false,"product_type":"c1","uid":1358609,"ip_address":"","ucode":"FDC7A0C6E08B02","user_header":"https://static001.geekbang.org/account/avatar/00/14/bb/11/7069b8eb.jpg","comment_is_top":false,"comment_ctime":1589793236,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589793236","product_id":100039001,"comment_content":"往上抛，原封不动","like_count":0},{"had_liked":false,"id":207547,"user_name":"新的起点，新的开始^_^","can_delete":false,"product_type":"c1","uid":1262068,"ip_address":"","ucode":"9C0810F472AC93","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/f4/5df17eff.jpg","comment_is_top":false,"comment_ctime":1587105658,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587105658","product_id":100039001,"comment_content":"争哥，我有个比较疑惑的问题，不过和当前的栏目主题没关系。<br>项目是个微服务A,B,C三个项目分别部署<br>问题：pojo类，枚举类，工具类<br>疑惑：<br>做法一：这三个类写到一个D项目，打包到maven中然后让A,B,C依赖这个项目，但是这样耦合太强，单独把A项目拎出来的话，就得将D项目也拿出来。<br>做法二：哪个项目需要，就写到哪个项目中去，造成粘贴复制，代码无法复用，User类既在A中也在B中(其实有想过B中使用map或者json来处理)<br>请问下争哥有什么好的建议吗<br><br><br>","like_count":0},{"had_liked":false,"id":205674,"user_name":"William Ning","can_delete":false,"product_type":"c1","uid":1592279,"ip_address":"","ucode":"4DB8D05E69E5F3","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","comment_is_top":false,"comment_ctime":1586699985,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1586699985","product_id":100039001,"comment_content":"这个确实是一直不明白应该如何处理, 继续阅读, 思考总结.","like_count":0},{"had_liked":false,"id":187335,"user_name":"空白昵称","can_delete":false,"product_type":"c1","uid":1433815,"ip_address":"","ucode":"91F50CA25102AB","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/d7/744bd8c3.jpg","comment_is_top":false,"comment_ctime":1584086522,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584086522","product_id":100039001,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":186670,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1583899476,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583899476","product_id":100039001,"comment_content":"1. 我认为应该返回空串，<br>2.我认为应该封装成新的异常向上抛出，从而更具体的表现出现的问题。<br>3. 我认为应该抛出异常。因为得到了一个预期之外的参数。要告诉调用方，参数存在问题。<br>4. 同上。参数存在的问题，应该告知调用方。","like_count":0},{"had_liked":false,"id":185398,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1583574297,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1583574297","product_id":100039001,"comment_content":"<br>1.对于 generate() 函数，如果本机名获取失败，函数返回什么？这样的返回值是否合理？<br>答：应该直接抛出异常，主动告知调用者<br><br>2.对于 getLastFiledOfHostName() 函数，是否应该将 UnknownHostException 异常在函数内部吞掉（try-catch 并打印日志）？还是应该将异常继续往上抛出？如果往上抛出的话，是直接把 UnknownHostException 异常原封不动地抛出，还是封装成新的异常抛出？<br>答：应该原封不动的抛出异常，方便调用者快速定位异常点。并且同时记录日志<br><br>3.对于 getLastSubstrSplittedByDot(String hostName) 函数，如果 hostName 为 NULL 或者是空字符串，这个函数应该返回什么？<br>答：抛出异常<br><br>4.对于 generateRandomAlphameric(int length) 函数，如果 length 小于 0 或者等于 0，这个函数应该返回什么？<br>答：抛出异常<br><br><br>","like_count":0},{"had_liked":false,"id":184982,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1583462116,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583462116","product_id":100039001,"comment_content":"思考题：<br>1.对于 generate() 函数，如果本机名获取失败，函数返回什么？这样的返回值是否合理？<br>答：返回异常，合理<br><br>2.对于 getLastFiledOfHostName() 函数，是否应该将 UnknownHostException 异常在函数内部吞掉（try-catch 并打印日志）？还是应该将异常继续往上抛出？如果往上抛出的话，是直接把 UnknownHostException 异常原封不动地抛出，还是封装成新的异常抛出？<br>答：继续往上抛，原封不动抛出<br><br><br>3.对于 getLastSubstrSplittedByDot(String hostName) 函数，如果 hostName 为 NULL 或者是空字符串，这个函数应该返回什么？<br>答：null，因为本身就没有主机信息，因此返回null比较合理。<br><br><br><br>4.对于 generateRandomAlphameric(int length) 函数，如果 length 小于 0 或者等于 0，这个函数应该返回什么？<br>答：返回字符串","like_count":0,"discussions":[{"author":{"id":1540988,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKZ16iaIia0029oI1Qh5NicibpbTiaBAaCOPYXoLplKHr6uQ2rSVxPZanBvpMcL2NuhwKQYCFnaHP5tedQ/132","nickname":"FIGNT","note":"","ucode":"D9DB185AE9E67C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":152090,"discussion_content":"新年学习计划\n1、完成争哥所有专栏，如果还有第三个专栏的话一起算进来\n2、学习公司报的即刻时间课程（这个任务就很重）\n3、完成这节课的任务\n4、深入学习kafka,原理和源码\n5、持续重构代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579939092,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184321,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1583289941,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583289941","product_id":100039001,"comment_content":"我们如何针对上面的四个函数,在出错的时候返回什么异常信息呢<br>对于第一个generate,我认为应该抛出一个自定义的异常,让顶层的异常处理器可以捕获这个异常,并且手动定义异常的信息<br>对于第二个函数,则是将异常原封不断的直接抛出,方便上层generate()函数的补货,因为获取不到hostName并不是正确的<br>对于第三个函数,则是返回空字符串,虽然是一个私有的方法,但是这个实现类如果接下来实现的新的接口,而要复用这个方法的话,这个函数的逻辑可能有所改变,返回一个&quot;&quot;相对稳妥<br>第四个函数,则直接返回空字符串即可,这符合这个函数的定义","like_count":0},{"had_liked":false,"id":183510,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1583055540,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583055540","product_id":100039001,"comment_content":"一段好代码的标准真高啊！","like_count":0},{"had_liked":false,"id":182185,"user_name":"请叫我和尚","can_delete":false,"product_type":"c1","uid":1703256,"ip_address":"","ucode":"33A8A1CDA103F9","user_header":"https://static001.geekbang.org/account/avatar/00/19/fd/58/1af629c7.jpg","comment_is_top":false,"comment_ctime":1582726762,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1582726762","product_id":100039001,"comment_content":"1. 看上层对于这个host是否必须这种格式，如果必须就抛出异常，不必须就正常返回<br>2. 抛给上层，因为这个对于上层有关系，直接抛不包装，异常unknownHost非常明确<br>3. 看业务对于substrOfHostName是不是必须要求这种格式，如果必须那就抛异常，不必须返回空字符串<br>4. 返回空字符串，说明就是不需要后缀","like_count":0},{"had_liked":false,"id":178886,"user_name":"独舟泛海","can_delete":false,"product_type":"c1","uid":1238514,"ip_address":"","ucode":"E35C8CEFAF062D","user_header":"https://static001.geekbang.org/account/avatar/00/12/e5/f2/21ea4d37.jpg","comment_is_top":false,"comment_ctime":1581845673,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581845673","product_id":100039001,"comment_content":"1.不应该抛出异常，直接返回null-时间戳-随机数，不能因为这个影响业务代码流程<br>2.原封不动向上抛，上游需要感知<br>3.&quot;&quot;<br>4.参数错误异常","like_count":0},{"had_liked":false,"id":178379,"user_name":"氧气🌙 🐟 🌺","can_delete":false,"product_type":"c1","uid":1591015,"ip_address":"","ucode":"8E23C210A9F09E","user_header":"https://static001.geekbang.org/account/avatar/00/18/46/e7/e20279ea.jpg","comment_is_top":false,"comment_ctime":1581673918,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581673918","product_id":100039001,"comment_content":"1 返回异常<br>2 封装成新的异常抛出<br>3 抛出异常<br>4 抛出异常","like_count":0},{"had_liked":false,"id":177794,"user_name":"我行我素","can_delete":false,"product_type":"c1","uid":1224678,"ip_address":"","ucode":"4C69542FAB0671","user_header":"https://static001.geekbang.org/account/avatar/00/12/af/e6/9c77acff.jpg","comment_is_top":false,"comment_ctime":1581501878,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581501878","product_id":100039001,"comment_content":"麻烦想请问下，文中说的：受检查异常是编译时异常，非受检查异常是运行时期异常；后面文中又说：数组角标越界和数据库连接失败是属于非受检查异常，取款金额大于余额是受检查异常；但是在程序尚未运行的时候只有数组角标越界和取款金额大于余额也无从得知，是否是取款金额大于余额和数组角标越界是非受检查异常(运行中不行就报错)，数据库连接失败是受检查异常(运行时连接不上直接停止程序)","like_count":0},{"had_liked":false,"id":175652,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1580790602,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580790602","product_id":100039001,"comment_content":"第一问generate()函数出错 要返回值 那应该返回-1表示一个异常的值<br>第二问应该向上抛出 毕竟调用函数还需要关心他的返回值<br>第三问 空字符串<br>第四问 返回-1表示一个异常值","like_count":0},{"had_liked":false,"id":175290,"user_name":"弹簧人","can_delete":false,"product_type":"c1","uid":1697679,"ip_address":"","ucode":"BCB4A6FC76EA17","user_header":"https://static001.geekbang.org/account/avatar/00/19/e7/8f/56387f77.jpg","comment_is_top":false,"comment_ctime":1580644377,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580644377","product_id":100039001,"comment_content":"func1() 抛出的异常是可以恢复。争哥，这个不是很明白。可恢复是指，func1中自己try catch吞掉，然后后续通过查看错误日志，手动恢复这个错误吗","like_count":0},{"had_liked":false,"id":175211,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1580616763,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1580616763","product_id":100039001,"comment_content":"这节课堪称经典!!!😭","like_count":0},{"had_liked":false,"id":174416,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1580201033,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580201033","product_id":100039001,"comment_content":"课堂讨论:<br><br><br><br>1. 对于 generate() 函数，如果本机名获取失败，函数返回什么？这样的返回值是否合理？<br><br>   本机名获取失败时函数将返回null,是不合理的.除非特殊说明,否则上层调用者可能忽视null的存在,从而引发npe.<br><br>   <br><br>2. 对于 getLastFiledOfHostName() 函数，是否应该将 UnknownHostException 异常在函数内部吞掉（try-catch 并打印日志）？还是应该将异常继续往上抛出？如果往上抛出的话，是直接把 UnknownHostException 异常原封不动地抛出，还是封装成新的异常抛出？<br><br>   ​    首先,本人极端不愿使用Checked-Exception.异常在函数内部吞掉是不好的行为,因为发生异常时,上层调用者并不知道.除非经过妥善的处理,否则会影响业务的正常执行.<br><br>   ​    如果在使用CE的情况下,是一定要向上抛出的.视情况是否包装成新的异常:原始异常准确达意,调用者很容易理解就可以直接抛出,原始异常有歧义或可能导致调用者困惑,就应该封装成新的异常.<br><br>   <br><br>3. 对于 getLastSubstrSplittedByDot(String hostName) 函数，如果 hostName 为 NULL 或者是空字符串，这个函数应该返回什么？<br><br>   先贴原始代码<br><br>​        @VisibleForTesting <br><br>​\t\tprotected String getLastSubstrSplittedByDot(String hostName) {<br><br>​\t\t    String[] tokens = hostName.split(&quot;\\\\.&quot;); <br><br>​            String substrOfHostName = tokens[tokens.length - 1]; <br><br>​            return substrOfHostName;<br><br>​     }<br><br>​        原始情况下,会因为hostName为null产生的npe导致程序运行crash.可以为此函数添加一个用于校验      hostName合法的isHostNameValid()函数,在hostName非法时抛出运行时异常(Runtime-Exception),或在非法时返回代表非法的常量值.<br><br><br><br>4. 对于 generateRandomAlphameric(int length) 函数，如果 length 小于 0 或者等于 0，这个函数应该返回什么？<br><br>​        应该抛出运行时异常或返回代表非法的常量值.","like_count":0},{"had_liked":false,"id":174300,"user_name":"啦啦啦","can_delete":false,"product_type":"c1","uid":1131687,"ip_address":"","ucode":"6B12EC90A62525","user_header":"https://static001.geekbang.org/account/avatar/00/11/44/a7/171c1e86.jpg","comment_is_top":false,"comment_ctime":1580128306,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580128306","product_id":100039001,"comment_content":"武汉加油","like_count":0},{"had_liked":false,"id":174282,"user_name":"逍遥思","can_delete":false,"product_type":"c1","uid":1015512,"ip_address":"","ucode":"340F05C786730F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/d8/92a98fb6.jpg","comment_is_top":false,"comment_ctime":1580119839,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580119839","product_id":100039001,"comment_content":"1. 返回”null-1577456311467-3nR3Do45”，不够合理，但勉强能接受<br>2. 应该吞掉，因为 generate() 并不关心 getLastFiledOfHostName() 抛出的异常<br>3. 返回 null<br>4. 返回空字符串<br><br>思考是为了下节课吸收更多！","like_count":0},{"had_liked":false,"id":174123,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1580011530,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1580011530","product_id":100039001,"comment_content":"做一个SZ程序员，不做MS程序员！跟进！","like_count":0},{"had_liked":false,"id":174082,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1018370,"ip_address":"","ucode":"7A488CC6FE15E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","comment_is_top":false,"comment_ctime":1579956177,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579956177","product_id":100039001,"comment_content":"返回错误码这种情况，在写RPC接口，返回时经常用到。在刚开始开发工作时，我常用的函数出错返回类型是返回NULL值和抛出异常对象。后面逐接触到对于集合，如果无数据返回空集合这种方法。学习Java8后，为了避免NPE，可以使用Optional类来处理。听过某人说对于调用别人写的函数返回集合类型的数据，最好自己先判断NULL，再处理。如果是自己写返回集合数据的接口，若无数据，返回空集合，不要返回NULL，不要指望别人帮你处理好NULL的情况。以前对于函数出错时，怎么处理异常，一直没有一个很好的理解，自己常用的做法就是往上抛出。","like_count":0},{"had_liked":false,"id":174065,"user_name":"L🚲🐱","can_delete":false,"product_type":"c1","uid":1577856,"ip_address":"","ucode":"08A012739614DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","comment_is_top":false,"comment_ctime":1579939424,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579939424","product_id":100039001,"comment_content":"1. 对于 generate() 函数，如果本机名获取失败，函数返回什么？这样的返回值是否合理？: 抛出异常, 因为获取失败是一个异常情况, 所以需要返回异常<br>2. 对于 getLastFiledOfHostName() 函数，是否应该将 UnknownHostException 异常在函数内部吞掉（try-catch 并打印日志）？还是应该将异常继续往上抛出？如果往上抛出的话，是直接把 UnknownHostException 异常原封不动地抛出，还是封装成新的异常抛出？: 继续原封不动的往上抛出, 可以在 Controller 层统一处理, 这样子异常的代码会比较统一的处理, 该异常的描述已经很明确了, 可以通过类名知道这个异常是什么.<br>3. 对于 getLastSubstrSplittedByDot(String hostName) 函数，如果 hostName 为 NULL 或者是空字符串，这个函数应该返回什么？: hostName 为空是一种异常, 应该抛出异常, 因为入参 hostName 不能为空<br>4. 对于 generateRandomAlphameric(int length) 函数，如果 length 小于 0 或者等于 0，这个函数应该返回什么？: 按照项目组统一规定来, 个人习惯返回 空字符串, 这么返回是方便调用方不用做非空判断","like_count":0},{"had_liked":false,"id":174016,"user_name":"前端西瓜哥","can_delete":false,"product_type":"c1","uid":1248576,"ip_address":"","ucode":"150130C34CD1C1","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/40/f70e5653.jpg","comment_is_top":false,"comment_ctime":1579880345,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579880345","product_id":100039001,"comment_content":"个人见解。<br><br>1. 获取本机名失败可以返回一个默认值，比如 &quot;unknown&quot;。因为 Id 只要随机就行，hostName其实不是很重要。不过可以考虑发送一个提醒，告知开发者运行环境有无法获取本机名的问题。<br>2. 建议吞掉。因为这个问题并不严重，没有必要停止程序。如果要往上抛出，原封不动地抛出，因为这个抛出错误原因很容易理解，不需要进一步包装。<br>3. 返回空字符吧。进行 NULL 判断可读性不好。<br>4. 感觉抛出错误比较好，因为这个算是开发者不细心了，让开发者知道错误，然后进行修改。如果不抛出错误，可以考虑返回空字符数组。","like_count":0},{"had_liked":false,"id":174003,"user_name":"ちよくん","can_delete":false,"product_type":"c1","uid":1398577,"ip_address":"","ucode":"B71E9B16E4408F","user_header":"https://static001.geekbang.org/account/avatar/00/15/57/31/6772744d.jpg","comment_is_top":false,"comment_ctime":1579864137,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579864137","product_id":100039001,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":173998,"user_name":"JamesPxy","can_delete":false,"product_type":"c1","uid":1320179,"ip_address":"","ucode":"558D707463589D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q2LT8JFWSghiaVbMMOkOkLnuibEqG2YOyEdCA5icEZH3Qpd9pL23mpzic9tWwyiciaBicE4YPMVnITOodulwG2SS75r2w/132","comment_is_top":false,"comment_ctime":1579858462,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1579858462","product_id":100039001,"comment_content":"新年快乐，开心实战！","like_count":0},{"had_liked":false,"id":173997,"user_name":"相逢是缘","can_delete":false,"product_type":"c1","uid":1060730,"ip_address":"","ucode":"CB299F53A95654","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg","comment_is_top":false,"comment_ctime":1579857772,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579857772","product_id":100039001,"comment_content":"打卡<br>函数出错应该返回？\t<br>1）返回错误码（C语言，其他的语音可能抛出异常）<br>2）返回NULL<br>（对于“没有查找到”，返回null更为合理）<br>3）返回空对象（不用做NULL值判断）<br>4）抛出异常值对象<br>对于函数抛出的异常，我们有三种处理方法：直接吞掉、直接往上抛出、包裹成新的异常抛出。对于是否将异常继续向上抛，需要看上层代码是否关心这个异常。如果上层代码不能理解这个异常、和业务不相关，需要把异常重新封装，向上层业务抛出新的异常。","like_count":0},{"had_liked":false,"id":173986,"user_name":"皮卡皮卡","can_delete":false,"product_type":"c1","uid":1216284,"ip_address":"","ucode":"D440EEC7301C76","user_header":"https://static001.geekbang.org/account/avatar/00/12/8f/1c/1c728388.jpg","comment_is_top":false,"comment_ctime":1579849150,"is_pvip":true,"replies":[{"id":"67715","content":"嗯嗯 收到 我改下","user_name":"作者回复","comment_id":173986,"uid":"1190123","ip_address":"","utype":1,"ctime":1580112217,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"1579849150","product_id":100039001,"comment_content":"返回空对象章节中，return Collectiosn.emptyList();出现拼写错误，应该是Collections.emptyList();","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482267,"discussion_content":"嗯嗯 收到 我改下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580112217,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173963,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1579834261,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579834261","product_id":100039001,"comment_content":"1. 获取不到本机名，抛出异常<br>2. 往上跑，可以包装为新的异常<br>3. 返回null值<br>4. 返回空对象","like_count":0},{"had_liked":false,"id":173954,"user_name":"黄林晴","can_delete":false,"product_type":"c1","uid":1362631,"ip_address":"","ucode":"B15C38AECDA88F","user_header":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","comment_is_top":false,"comment_ctime":1579826584,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579826584","product_id":100039001,"comment_content":"打卡✔<br>新年快乐","like_count":0}]}