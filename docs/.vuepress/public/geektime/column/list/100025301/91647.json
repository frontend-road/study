{"id":91647,"title":"05 | 分布式系统（下）：架构师不得不知的三大指标","content":"<p>你好，我是蔡元楠。</p><p>上一讲中，我们学习了如何用服务等级协议（SLA）来评估我们设计的分布式系统，并了解了几个常见的SLA指标。</p><p>今天我们继续来探索分布式系统的另外几个重要基础概念。</p><h2>可扩展性</h2><p>还是从我们为什么需要分布式系统讲起。原因是我们要面对的数据量越来越大，从GB到TB再到现在的PB级，单机无法胜任这样的工作。</p><p>工作中也常有这样的场景，随着业务变得越来越复杂，之前设计的系统无法处理日渐增长的负载。这时，我们就需要增加系统的容量。</p><p>分布式系统的核心就是可扩展性（Scalability）。</p><p>最基本而且最流行的增加系统容量的模型有两种: 水平扩展（Horizontal Scaling）和垂直扩展（Vertical Scaling）。</p><p>所谓水平扩展，就是指在现有的系统中增加新的机器节点。</p><p><img src=\"https://static001.geekbang.org/resource/image/2f/4b/2fed13c9e11ae3c72d1b0b66809c3f4b.jpg?wh=1142*640\" alt=\"\"></p><p>垂直扩展就是在不改变系统中机器数量的情况下，“升级”现有机器的性能，比如增加机器的内存。</p><p><img src=\"https://static001.geekbang.org/resource/image/75/01/75ca153b40ff6db8b424399cb7d3a601.jpg?wh=1142*640\" alt=\"\"></p><p>举个例子，假设你现在负责一批木材采伐的操作。你有3辆卡车，每辆车一次可以运25根木材。那么1小时最多可以运3辆卡车 * 25根木材 * 1小时=75根木材／小时。</p><p>如果要使这个系统的负荷量增加一倍，用水平扩展的办法，我们可以将卡车的数量增加到6辆；用垂直扩展的办法，我们可以使每辆卡车的运输量增加一倍，或者使每辆卡车的速度增加一倍。</p><!-- [[[read_end]]] --><p>你是不是已经发现了，水平扩展的适用范围更广，操作起来更简单，并且会提升系统的可用性（Availability）。</p><p>如果你的系统部署在AWS或者其他主流的云服务上，你只需要点几个按钮，就可以在现有的机器集群中增加一个新的节点。</p><p>但是，无节制地增加机器数量也会带来一些问题，比如机器的管理、调度、通信会变得更加复杂，出错的可能性会更高，更难保证数据的一致性等等。</p><p>与之相反，垂直扩展并没有让整个系统变得更加复杂，控制系统的代码也不需要做任何调整，但是它受到的限制比较多。多数情况下，单个机器的性能提升是有限的。而且受制于摩尔定律，提高机器的性能往往比购买新的机器更加昂贵。</p><p>所以在工作中，我们要对这两种模式进行取舍，要具体情况具体分析。</p><p>同样地，在大数据的时代，数据增长速度越来越快，数据规模越来越大，对数据存储系统的扩展性要求也越来越高。</p><p>传统的关系型数据库因为表与表之间的数据有关联，经常要进行Join操作，所有数据要存放在单机系统中，很难支持水平扩展。而NoSQL型的数据库天生支持水平扩展，所以这类存储系统的应用越来越广，如BigTable、MongoDB和Redis等。</p><h2>一致性</h2><p>可用性对于任何分布式系统都很重要。一般来说，构成分布式系统的机器节点的可用性要低于系统的可用性。</p><p>举个例子，如果我们想要构建一个可用性99.999%的分布式系统（每年约5分钟的宕机时间），但是我们使用的单台机器节点的可用性是99.9%（每年约8个小时的宕机时间）。那么想要达到我们的目标，最简单的办法就是增加系统中机器节点的数量。这样即使有部分机器宕机了，其他的机器还在持续工作，所以整个系统的可用性就提高了。</p><p>这种情况下，我们要思考一个问题：如何保证系统中不同的机器节点在同一时间，接收到和输出的数据是一致的呢？这时就要引入一致性（Consistency）的概念。</p><p>回到之前的例子，要保证分布式系统内的机器节点有相同的信息，就需要机器之间定期同步。</p><p>然而，发送信息也会有失败的可能，比如信息丢失或者有的节点正好宕机而无法接收。因此，一致性在高可用性的系统里是非常核心的概念。</p><p>接下来，我会给你介绍几个在工程中常用的一致性模型，分别是：强一致性（Strong Consistency），弱一致性（Weak Consistency），最终一致性（Eventual Consistency）。</p><ul>\n<li>强一致性：系统中的某个数据被成功更新后，后续任何对该数据的读取操作都将得到更新后的值。所以在任意时刻，同一系统所有节点中的数据是一样的。</li>\n<li>弱一致性：系统中的某个数据被更新后，后续对该数据的读取操作可能得到更新后的值，也可能是更改前的值。但经过“不一致时间窗口”这段时间后，后续对该数据的读取都是更新后的值。</li>\n<li>最终一致性：是弱一致性的特殊形式。存储系统保证，在没有新的更新的条件下，最终所有的访问都是最后更新的值。</li>\n</ul><p>上面这三点我描述得比较正式，但其实都不难理解。这里，我进一步给你做个说明。</p><p>在强一致性系统中，只要某个数据的值有更新，这个数据的副本都要进行同步，以保证这个更新被传播到所有备份数据库中。在这个同步进程结束之后，才允许服务器来读取这个数据。</p><p>所以，强一致性一般会牺牲一部分延迟性，而且对于全局时钟的要求很高。举个例子，Google Cloud的Cloud Spanner就是一款具备强一致性的全球分布式企业级数据库服务。</p><p>在最终一致性系统中，我们无需等到数据更新被所有节点同步就可以读取。尽管不同的进程读同一数据可能会读到不同的结果，但是最终所有的更新会被按时间顺序同步到所有节点。所以，最终一致性系统支持异步读取，它的延迟比较小。比如亚马逊云服务的DynamoDB就支持最终一致的数据读取。</p><p>除了以上三个，分布式系统理论中还有很多别的一致性模型，如顺序一致性（Sequential Consistency），因果一致性（Casual Consistency）等，如果你感兴趣的话，可以自己查资料了解一下。</p><p>在实际应用系统中，强一致性是很难实现的，应用最广的是最终一致性。我们一起来看两个例子。</p><p>很多人认为银行间转账应该是强一致的。但是你仔细分析一下就会发现，事实并非如此。</p><p>举个例子，小王给小张转账1000元，小王的账户扣除了1000，此时小张并不一定立刻就收到1000元。这里可能会存在一个不一致的时间窗口：小王的钱扣除了1000元，小张还没收到1000元的时候。</p><p>另外一个例子，在12306网站买票的功能，也不是强一致的。</p><p><img src=\"https://static001.geekbang.org/resource/image/73/c5/735f1868884bb30afd2e9b1009c398c5.jpg?wh=1125*555\" alt=\"\"></p><p>如果你在12306上发现一趟列车还剩余10张车票，你发起请求订了一张票，系统给你返回的可能是“正在排队，剩余10张票，现在有15人在购买”。</p><p>这时，你可能就需要去查询未完成订单，因为系统并没有给你及时返回订票成功或失败的结果。如果有人退了一张票，这张票也不会立即返回到票池中。这里明显也存在不一致的时间窗口。</p><p>但是，最终10张票只会卖给10个人，不可能卖给11个人，这就是最终一致性所谓的“最终所有数据都会同步”。</p><p>讲到这里，你对分布式系统的扩展性和一致性就很清楚了吧？接下来再给你介绍一个重要概念。</p><h2>持久性</h2><p>数据持久性（Data Durability）意味着数据一旦被成功存储就可以一直继续使用，即使系统中的节点下线、宕机或数据损坏也是如此。</p><p>不同的分布式数据库拥有不同级别的持久性。有些系统支持机器/节点级别的持久性，有些做到了集群级别，而有些系统压根没有持久性。</p><p>想要提高持久性，数据复制是较为通用的做法。因为把同一份数据存储在不同的节点上，即使有节点无法连接，数据仍然可以被访问。</p><p>在分布式数据处理系统中，还有一个持久性概念是消息持久性。什么意思呢？在分布式系统中，节点之间需要经常相互发送消息去同步以保证一致性。对于重要的系统而言，常常不允许任何消息的丢失。</p><p>分布式系统中的消息通讯通常由分布式消息服务完成，比如RabbitMQ、Kafka。这些消息服务能支持（或配置后支持）不同级别的消息送达可靠性。消息持久性包含两个方面：</p><ol>\n<li>当消息服务的节点发生了错误，已经发送的消息仍然会在错误解决之后被处理；</li>\n<li>如果一个消息队列声明了持久性，那么即使队列在消息发送之后掉线，仍然会在重新上线之后收到这条消息。</li>\n</ol><h2>小结</h2><p>在这一讲中，我们探讨了分布式处理系统的三个重要指标：扩展性，一致性和持久性。</p><p>结合前边提到的延迟性、可用性以及准确性，我们不难发现，这些设计分布式系统所要考虑的量化指标存在一定程度上的冲突。不可能有一个分布式处理系统在不牺牲某一指标的前提下，让每一个指标都达到最好。</p><p>作为优秀的系统架构师，我们一定要学会具体情况具体分析，找到最适合自己系统的指标，适当做出取舍。但是这一点说起来容易做起来难，到底该怎么取舍呢？你可以先思考一下这个问题，下一讲中我会结合CAP定理和你进一步讨论。</p><h2>思考题</h2><p>对于微信朋友圈的评论功能，你觉得哪种一致性模型更适用？为什么？</p><p>欢迎你把答案写在留言区，与我和其他同学一起讨论。如果你觉得有所收获，也欢迎把文章分享给你的朋友。</p><p></p>","neighbors":{"left":{"article_title":"04 | 分布式系统（上）：学会用服务等级协议SLA来评估你的系统","id":91166},"right":{"article_title":"06 | 如何区分批处理还是流处理？","id":92638}},"comments":[{"had_liked":false,"id":89667,"user_name":"JohnT3e","can_delete":false,"product_type":"c1","uid":1063982,"ip_address":"","ucode":"CF4AAAC933529C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLdWHFCr66TzHS2CpCkiaRaDIk3tU5sKPry16Q7ic0mZZdy8LOCYc38wOmyv5RZico7icBVeaPX8X2jcw/132","comment_is_top":false,"comment_ctime":1556242028,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"212009639532","product_id":100025301,"comment_content":"微信朋友圈评论主要由评论和后续回复组成：<br>首先，对于评论，评论内容对评论者而言应该要保证读写一致性（read-your-writes consistency），即评论一旦发出，那么对于该评论者无论在手机、网页还是其它城市应该都能看到其之前写的评论。而对于朋友圈可见的其它人来说，只要保证最终一致性（eventual consistency）就可以了（可能有时间要求），不同人的评论读取顺序无需和真实发生的顺序保持一致；<br>其次，对于评论的后续回复。回复内容对于回复者而言应该要保证读写一致性（read-your-writes consistency），而其它朋友圈可见的人一样，评论和回复内容应该按顺序被读取到，即需要保证一致前缀读（Consisten Prefix Reads）","like_count":50,"discussions":[{"author":{"id":2194077,"avatar":"https://static001.geekbang.org/account/avatar/00/21/7a/9d/3cf16f3f.jpg","nickname":"超级绿兔子.高清复刻版","note":"","ucode":"19397CA1989969","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326251,"discussion_content":"评论和后续回复的关系应该算因果一致性吧","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1605572065,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1013147,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/75/9b/611e74ab.jpg","nickname":"技术修行者","note":"","ucode":"28CA41A1214D6B","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":322270,"discussion_content":"标准答案呀👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604715993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89709,"user_name":"3SKarl","can_delete":false,"product_type":"c1","uid":1505108,"ip_address":"","ucode":"9CBD1D3FE5BB49","user_header":"https://static001.geekbang.org/account/avatar/00/16/f7/54/138b51a1.jpg","comment_is_top":false,"comment_ctime":1556247589,"is_pvip":false,"replies":[{"id":"33013","content":"你好，这是个很棒的问题。简而言之，弱一致性是个很宽泛的概念，它是区别于强一致性而定义的。广义上讲，任何不是强一致的，而又有某种同步性的分布式系统，我们都可以说它是弱一致的。而最终一致性是弱一致性的一个特例，而且是最常被各种分布式系统用到的一个特例。其他的比如因果一致性、FIFO一致性等都可以看作是弱一致性的特例，不同弱一致性只是对数据不同步的容忍程度不同，但是经过一段时间，所有节点的数据都要求要一致。<br><br>学习时也没必要抠字眼，重要的是理解它们的区别。这部分知识是为了后边讲CAP理论服务的，实际的工作中不会像考试考概念题一样让你背写这些一致性的定义。<br><br>如果你还有疑问，欢迎继续留言。<br><br>","user_name":"作者回复","user_name_real":"Xinyue Li","uid":"1502409","ctime":1557226822,"ip_address":"","comment_id":89709,"utype":1}],"discussion_count":1,"race_medal":0,"score":"164765004837","product_id":100025301,"comment_content":"老师，我不太明白弱一致性和最终一致性的区别在哪里，文章对弱一致性提到<br>“经过不一致时间窗口这段时间后，后续对该数据的读取都是更新后的值”<br>这句描述的不就是最终一致性么<br><br>是不是说弱一致性允许数据始终不一致，而要求最终结果一致的弱一执性叫做最终一致性<br>","like_count":39,"discussions":[{"author":{"id":1502409,"avatar":"https://static001.geekbang.org/account/avatar/00/16/ec/c9/45bfcba3.jpg","nickname":"Xinyue Li","note":"","ucode":"0CB92610C8B9FC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448231,"discussion_content":"你好，这是个很棒的问题。简而言之，弱一致性是个很宽泛的概念，它是区别于强一致性而定义的。广义上讲，任何不是强一致的，而又有某种同步性的分布式系统，我们都可以说它是弱一致的。而最终一致性是弱一致性的一个特例，而且是最常被各种分布式系统用到的一个特例。其他的比如因果一致性、FIFO一致性等都可以看作是弱一致性的特例，不同弱一致性只是对数据不同步的容忍程度不同，但是经过一段时间，所有节点的数据都要求要一致。\n\n学习时也没必要抠字眼，重要的是理解它们的区别。这部分知识是为了后边讲CAP理论服务的，实际的工作中不会像考试考概念题一样让你背写这些一致性的定义。\n\n如果你还有疑问，欢迎继续留言。\n\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1557226822,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89648,"user_name":"leeon","can_delete":false,"product_type":"c1","uid":1083723,"ip_address":"","ucode":"74C23558036552","user_header":"https://static001.geekbang.org/account/avatar/00/10/89/4b/56d290f5.jpg","comment_is_top":false,"comment_ctime":1556240180,"is_pvip":false,"replies":[{"id":"33014","content":"你的想法很好，但是有的场景下最终一致性还不够。试想这个场景，A发布了一张图片，B问他这是哪里，然后C回答B这里是北京。这个例子中，C的评论一定要在B之后，因为他俩有逻辑上的因果关系。所以微信朋友圈的评论要满足这样的因果一致性。因果一致性也是弱一致性的一个特例，感兴趣的话可以去多搜索点资料来学习～","user_name":"作者回复","user_name_real":"Xinyue Li","uid":"1502409","ctime":1557227172,"ip_address":"","comment_id":89648,"utype":1}],"discussion_count":3,"race_medal":0,"score":"83160618804","product_id":100025301,"comment_content":"朋友圈保证最终一致性即可，消息发布后，先保证“端”是可见的，等待网络请求后会确认最终有无发布成功，成功后最终其他人的timeline会收到","like_count":20,"discussions":[{"author":{"id":1502409,"avatar":"https://static001.geekbang.org/account/avatar/00/16/ec/c9/45bfcba3.jpg","nickname":"Xinyue Li","note":"","ucode":"0CB92610C8B9FC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448212,"discussion_content":"你的想法很好，但是有的场景下最终一致性还不够。试想这个场景，A发布了一张图片，B问他这是哪里，然后C回答B这里是北京。这个例子中，C的评论一定要在B之后，因为他俩有逻辑上的因果关系。所以微信朋友圈的评论要满足这样的因果一致性。因果一致性也是弱一致性的一个特例，感兴趣的话可以去多搜索点资料来学习～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557227172,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1013147,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/75/9b/611e74ab.jpg","nickname":"技术修行者","note":"","ucode":"28CA41A1214D6B","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":322261,"discussion_content":"老师举的这个例子，为什么是因果一致性？不应该是顺序一致性吗？按照回复消息的先后顺序进行处理。\n我可能有点儿小咬文嚼字了，我同意在这里单纯的最终一致性是不够的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604715135,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1535926,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ6Qpib06NaI4cIf8VFMFYfa8bVve4uxab1qytsXZoRbCBWgK1cyRt7PZRQHicC9X8PPLy1kibwLZ35Q/132","nickname":"Geek_40bb5c","note":"","ucode":"BE55312BD7D21E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1013147,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/75/9b/611e74ab.jpg","nickname":"技术修行者","note":"","ucode":"28CA41A1214D6B","race_medal":1,"user_type":1,"is_pvip":true},"discussion":{"id":567432,"discussion_content":"因果一致性是顺序一致性放宽的结果，如果这里边还有一个D评论，但没有人回复他。那么系统只需要保证C一定在B之后。而D无论在B前，Ｂ后，C前，C后均可。因果一致性只保证有因果关系的事件之间的发生顺序，顺序一致性需要确保所以事件的发生顺序","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1650905867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":322261,"ip_address":""},"score":567432,"extra":""}]}]},{"had_liked":false,"id":90725,"user_name":"hua168","can_delete":false,"product_type":"c1","uid":1065255,"ip_address":"","ucode":"CFF9A7E86EBA48","user_header":"https://static001.geekbang.org/account/avatar/00/10/41/27/3ff1a1d6.jpg","comment_is_top":false,"comment_ctime":1556617445,"is_pvip":false,"replies":[{"id":"32989","content":"谢谢你的提问！强一致性并没有误差可言的，强一致性简单地说指的就是如果更新一条数据，那所有用户读取数据的时候必须都看到这条更新了的数据。<br><br>在这里我也分享一个自己的面试经历。其实这个问题恰好我当年在面试Bloomberg的时候面到过，是一道系统设计题。问的大概是在设计他们家股票信息系统的时候，数据的更新写入量太大，用户也需要读取最新的股票资讯，该如何设计这套系统。最后和它家的tech lead讨论发现，原来他们的股票系统显示的延迟范围是1分钟左右，因为应用场景上普通股民并不会需要实时关心每秒钟股票价格的动态，更多的是关心大盘走势。而金融巨头在操作股票的时候更多只关心特定的几只股票，所以这些股票的价格通常对于他们来说会更新快一点。<br><br>所以说金融股票大厅上的数据应该不会是强一致性的，延时误差也应该没有你想象的那么少。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557214596,"ip_address":"","comment_id":90725,"utype":1}],"discussion_count":3,"race_medal":0,"score":"48801257701","product_id":100025301,"comment_content":"老师我想问一下，所谓的强一致性，它允许的误差是多少范围？<br>比如金融股票大厅显示屏数据，应该是强一致性的吧，全球显示误差不会超过0.2s吧？<br>这样强一致性怎达到？网络传输，路由处理都不止了，更何况还有网络延迟","like_count":12,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448629,"discussion_content":"谢谢你的提问！强一致性并没有误差可言的，强一致性简单地说指的就是如果更新一条数据，那所有用户读取数据的时候必须都看到这条更新了的数据。\n\n在这里我也分享一个自己的面试经历。其实这个问题恰好我当年在面试Bloomberg的时候面到过，是一道系统设计题。问的大概是在设计他们家股票信息系统的时候，数据的更新写入量太大，用户也需要读取最新的股票资讯，该如何设计这套系统。最后和它家的tech lead讨论发现，原来他们的股票系统显示的延迟范围是1分钟左右，因为应用场景上普通股民并不会需要实时关心每秒钟股票价格的动态，更多的是关心大盘走势。而金融巨头在操作股票的时候更多只关心特定的几只股票，所以这些股票的价格通常对于他们来说会更新快一点。\n\n所以说金融股票大厅上的数据应该不会是强一致性的，延时误差也应该没有你想象的那么少。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557214596,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1013147,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/75/9b/611e74ab.jpg","nickname":"技术修行者","note":"","ucode":"28CA41A1214D6B","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":322262,"discussion_content":"在这种场景下，对于量化交易系统的设计是不是一个挑战呀？量化交易应该对价格信息的实时性要求比普通股民高多了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604715303,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1145157,"avatar":"https://static001.geekbang.org/account/avatar/00/11/79/45/05a88185.jpg","nickname":"住羽光","note":"","ucode":"11E48DEB421D9C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3152,"discussion_content":"实际的需求，跟事实上的理解，有时候会有差异。受教了~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564228994,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91763,"user_name":"Flash","can_delete":false,"product_type":"c1","uid":1236163,"ip_address":"","ucode":"E285075C9E0B02","user_header":"https://static001.geekbang.org/account/avatar/00/12/dc/c3/e4ba51d5.jpg","comment_is_top":false,"comment_ctime":1557105136,"is_pvip":false,"replies":[{"id":"32983","content":"谢谢你的提问！没错，这里的持久性指的就是消息队列在接收到发送者发送的消息后，只要没有收到接收者的回应，就会一直尝试发送消息给接收者，直到收到回应为止。所以接收者下线了再上线仍是能收到消息队列发送的消息。当然中间如果超过了消息保留期限或者一定的重发次数也会消息队列也会停止发送。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557212844,"ip_address":"","comment_id":91763,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27326908912","product_id":100025301,"comment_content":"老师，消息队列的持久性第二点不是太能理解，意思是说消息发送者发完消息后，接收者下线了，然后接收者上线仍能收到吗？","like_count":7,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449021,"discussion_content":"谢谢你的提问！没错，这里的持久性指的就是消息队列在接收到发送者发送的消息后，只要没有收到接收者的回应，就会一直尝试发送消息给接收者，直到收到回应为止。所以接收者下线了再上线仍是能收到消息队列发送的消息。当然中间如果超过了消息保留期限或者一定的重发次数也会消息队列也会停止发送。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557212844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90028,"user_name":"涵","can_delete":false,"product_type":"c1","uid":1502742,"ip_address":"","ucode":"BB8575DB13F1E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/ee/16/742956ac.jpg","comment_is_top":false,"comment_ctime":1556373472,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23031209952","product_id":100025301,"comment_content":"对于微信朋友圈的评论功能我想最终一致性，保护因果一致性的特征就够了。从需求角度，微信朋友圈是一种社交工具，不具有critical的特性，数据一致的实效性要求不高。每个独立评论的先后顺序也不那么重要。重要的是对于某一条评论的评论必须显示在派生这条评论的原始评论之后，否则用户读起来会很混乱。从最低成本满足需求的角度，因此最终一致性加上因果一致性特征即可。","like_count":6},{"had_liked":false,"id":89713,"user_name":"hallo128","can_delete":false,"product_type":"c1","uid":1212044,"ip_address":"","ucode":"3921D6E11CFCB1","user_header":"https://static001.geekbang.org/account/avatar/00/12/7e/8c/f029535a.jpg","comment_is_top":false,"comment_ctime":1556248468,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18736117652","product_id":100025301,"comment_content":"恩~其实我好像没有听懂~介绍了几个概念的定义，但还是不理解它们之间的联系和差别。","like_count":4},{"had_liked":false,"id":89603,"user_name":"陈建斌红了..","can_delete":false,"product_type":"c1","uid":1073301,"ip_address":"","ucode":"575F04D041C2C8","user_header":"https://static001.geekbang.org/account/avatar/00/10/60/95/08571d0b.jpg","comment_is_top":false,"comment_ctime":1556234390,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18736103574","product_id":100025301,"comment_content":"ap模型，先保证评论的人自己能看见，再保证被评论的人和别人能看见。","like_count":4},{"had_liked":false,"id":90277,"user_name":"挖矿的小戈","can_delete":false,"product_type":"c1","uid":1503917,"ip_address":"","ucode":"2078A85139BD5D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/9chAb6SjxFiapSeicsAsGqzziaNlhX9d5aEt8Z0gUNsZJ9dICaDHqAypGvjv4Bx3PryHnj7OFnOXFOp7Ik21CVXEA/132","comment_is_top":false,"comment_ctime":1556465106,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14441366994","product_id":100025301,"comment_content":"朋友圈采用最终一致性+因果一致性就好，只要保证评论及其派生评论是有序的，以保证其逻辑、语义上面不会出现混乱，场景对延时性要求不高；另外，有注意到手机端的微信和PC端的微信，会出现数据不一致的情况（特别是微信公众号订阅的文章，PC端少些文章）","like_count":3},{"had_liked":false,"id":89838,"user_name":"Codelife","can_delete":false,"product_type":"c1","uid":1041421,"ip_address":"","ucode":"10458683978083","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLhMtBwGqqmyhxp5uaDTvvp18iaalQj8qHv6u8rv1FQXGozfl3alPvdPHpEsTWwFPFVOoP6EeKT4bw/132","comment_is_top":false,"comment_ctime":1556280448,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14441182336","product_id":100025301,"comment_content":"以前曾经考虑过微信朋友圈这个一致性问题，最初认为是顺序一致性，仔细一想，如果是顺序一致性，成本太高，也没必要，对于微信朋友圈的评论来说，只有互为好友的人才能看到，评论也是互为好友的人，如果A发了朋友圈，所有人对A的评论，只有A才能完全看到，同时，B对A如果进行了评论，C对B的评论进行了评论，那么，对于A,B,C来说，C的评论肯定在B之后，只要保证互相能看到的评论一致即可，所以应该是因果一致性，至于如何的，暂时还没考虑","like_count":3},{"had_liked":false,"id":89613,"user_name":"明翼","can_delete":false,"product_type":"c1","uid":1068361,"ip_address":"","ucode":"E77F86BEB3D5C1","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/49/28e73b9c.jpg","comment_is_top":false,"comment_ctime":1556237074,"is_pvip":false,"replies":[{"id":"33015","content":"很棒的总结。<br><br>对于思考题的答案，建议你再读读别的读者得留言，有的留言思考很深入～","user_name":"作者回复","user_name_real":"Xinyue Li","uid":"1502409","ctime":1557227515,"ip_address":"","comment_id":89613,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14441138962","product_id":100025301,"comment_content":"笔记总结：扩展性包括水平和垂直，水平扩展是增加水平类似的机器打群架方式，垂直扩展是现有的每个人提升实力，提升整体实力；一致性，集群上的数据为了保证高可用性显然要存在不同机器上存多份，这就存在不同机器数量同步问题，要求同步造成才可以进行读写的就是最终一致性，中间准许有个不一致时间窗的就是弱一致性，时间窗更长但是最终会统一的就是最终一致性，比如发微博场景，还讲了数据持久性，消息的持久性，一般类似kafka之类消息总线系统可以配置各种持久性要求，比如要求所有主和副本都同步，要求只要发给主即可，有的发送不需要确认。<br><br>关于问题：朋友圈属于最终一致性，信息推送晚一会不是特别重要，所以最终一致性满足要求","like_count":3,"discussions":[{"author":{"id":1502409,"avatar":"https://static001.geekbang.org/account/avatar/00/16/ec/c9/45bfcba3.jpg","nickname":"Xinyue Li","note":"","ucode":"0CB92610C8B9FC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448195,"discussion_content":"很棒的总结。\n\n对于思考题的答案，建议你再读读别的读者得留言，有的留言思考很深入～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557227515,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89634,"user_name":"Trane","can_delete":false,"product_type":"c1","uid":1014797,"ip_address":"","ucode":"368EC653624579","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7c/0d/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1556238571,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10146173163","product_id":100025301,"comment_content":"弱一致性，场景可以容忍一定时间的延迟。","like_count":2},{"had_liked":false,"id":103201,"user_name":"西北偏北","can_delete":false,"product_type":"c1","uid":1043160,"ip_address":"","ucode":"64BD69C84EE6A1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erdpKbFgRLnicjsr6qkrPVKZcFrG3aS2V51HhjFP6Mh2CYcjWric9ud1Qiclo8A49ia3eZ1NhibDib0AOCg/132","comment_is_top":false,"comment_ctime":1560395798,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5855363094","product_id":100025301,"comment_content":"为了提高系统的吞吐量，我们需要水平扩展。<br>水平扩展后，消息，数据在集群中的传输，需要可靠的一致性保证。由于是分布式，无法保证像单机一样的强一致，只能保证最终一致性<br><br>分布式集群中，可能涉及通过通信沟通，去保证最终一致性，但通信可能会丢失。要么通过算法去保证，即便通信丢失，集群也能协商出一个一致的结果，比如paxos和raft算法。要么通过可靠的消息中间件来保证消息的可靠传达和消费。","like_count":1},{"had_liked":false,"id":93078,"user_name":"roaming","can_delete":false,"product_type":"c1","uid":1039232,"ip_address":"","ucode":"2736679690AB81","user_header":"https://static001.geekbang.org/account/avatar/00/0f/db/80/6b7629d7.jpg","comment_is_top":false,"comment_ctime":1557392756,"is_pvip":false,"replies":[{"id":"33257","content":"谢谢你的留言！是的呢，在第九讲里面所讲到的线性一致性（Linearizability）其实也和Java Memory Model有关。如果在Java中修改的变量是volatile的话就会有这种线性一致性。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557449114,"ip_address":"","comment_id":93078,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5852360052","product_id":100025301,"comment_content":"看老师评论里说需要最终一致性和因果一致性，感觉这个因果一致性和Java内存模型里的happens-before好像","like_count":1,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449482,"discussion_content":"谢谢你的留言！是的呢，在第九讲里面所讲到的线性一致性（Linearizability）其实也和Java Memory Model有关。如果在Java中修改的变量是volatile的话就会有这种线性一致性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557449114,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90929,"user_name":"Geek_b04b12","can_delete":false,"product_type":"c1","uid":1112139,"ip_address":"","ucode":"F8705A21FCDF09","user_header":"https://static001.geekbang.org/account/avatar/00/10/f8/4b/5ae62b10.jpg","comment_is_top":false,"comment_ctime":1556729847,"is_pvip":false,"replies":[{"id":"32988","content":"谢谢你的留言！有同感，其实当你学识更广之后会发现计算机中很多方向都是相辅相成的，并不会说某一块知识是相对独立起来的。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557213632,"ip_address":"","comment_id":90929,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5851697143","product_id":100025301,"comment_content":"这一节课，怎么让我想起了阿里李云华＜从零到架构师＞中提到的CAP理论，这大规模数据和架构师之间的知识看来是想通的着呀","like_count":1,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448729,"discussion_content":"谢谢你的留言！有同感，其实当你学识更广之后会发现计算机中很多方向都是相辅相成的，并不会说某一块知识是相对独立起来的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557213632,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89858,"user_name":"欢喜","can_delete":false,"product_type":"c1","uid":1258673,"ip_address":"","ucode":"9938757B82B8BA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/V71wNP3XFiaNS7lVfluMkB01qia60dXN0lo8kibqBIlumXbZP7bQagdVS7YSs4YU4fqasMzdBdKrPjlVlTIdzztng/132","comment_is_top":false,"comment_ctime":1556286456,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5851253752","product_id":100025301,"comment_content":"因果一致性。比如说A评论了，然后B评论了A的评论，只要保证A的评论在B对于A的评论之前就行了。","like_count":1},{"had_liked":false,"id":89801,"user_name":"孙稚昊","can_delete":false,"product_type":"c1","uid":1010660,"ip_address":"","ucode":"44283BA4A577B6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/e4/afacba1c.jpg","comment_is_top":false,"comment_ctime":1556268229,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5851235525","product_id":100025301,"comment_content":"我觉得微信朋友圈只要最终一致就够了，没有对更新延迟那么高的要求","like_count":1},{"had_liked":false,"id":89776,"user_name":"有铭","can_delete":false,"product_type":"c1","uid":1046302,"ip_address":"","ucode":"2C7CB36CA5C04C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/3XbCueYYVWTiclv8T5tFpwiblOxLphvSZxL4ujMdqVMibZnOiaFK2C5nKRGv407iaAsrI0CDICYVQJtiaITzkjfjbvrQ/132","comment_is_top":false,"comment_ctime":1556261918,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5851229214","product_id":100025301,"comment_content":"我想请教老师，有些业务，不用关系数据库的话，如果处理分析需求(OLAP)?就我所知连google这样的公司某些时候还是必须用join来完成一些数据分析。比如下面这类需求，分布式系统里，用户表和订单表在不同的库里。请查出所有20-30岁用户的订单，并按照一定的规则进行数据统计。而20-30岁的用户数量可能非常庞大，十几万之多，这类的需求。非关系型的数据库，或者分布式系统如何做统计？统计现在才是大部分公司实施分布式数据处理的困难点，相反事务倒不是那么重要了，互联网企业的需求对强一致性要求没那么高","like_count":1},{"had_liked":false,"id":89637,"user_name":"aof","can_delete":false,"product_type":"c1","uid":1062864,"ip_address":"","ucode":"5815D63C4926BC","user_header":"https://static001.geekbang.org/account/avatar/00/10/37/d0/26975fba.jpg","comment_is_top":false,"comment_ctime":1556238912,"is_pvip":false,"replies":[{"id":"33070","content":"谢谢你的提问！Broker在Kafka的系统里可以看作是不同消息队列的容器。而消息队列中消息的持久性指的是一般broker都会将消息replicate到不同的节点上，这时候消息才能够被consumer接收。而如果consumer没有acknowledge接收到消息的话，消息队列会一直尝试发送给consumer。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557280694,"ip_address":"","comment_id":89637,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5851206208","product_id":100025301,"comment_content":"消息队列声明持久性的意思就是，比如kafka即可以作为消息队列，同时又可以将消息持久化到broker节点上？","like_count":1,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448205,"discussion_content":"谢谢你的提问！Broker在Kafka的系统里可以看作是不同消息队列的容器。而消息队列中消息的持久性指的是一般broker都会将消息replicate到不同的节点上，这时候消息才能够被consumer接收。而如果consumer没有acknowledge接收到消息的话，消息队列会一直尝试发送给consumer。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557280694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":268018,"user_name":"非同凡想","can_delete":false,"product_type":"c1","uid":1934969,"ip_address":"","ucode":"713FD449A49D5A","user_header":"https://static001.geekbang.org/account/avatar/00/1d/86/79/066a062a.jpg","comment_is_top":false,"comment_ctime":1608032113,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608032113","product_id":100025301,"comment_content":"微信朋友圈采用最终一致性，好友谁先看到都可以；<br>评论列表需要因果一致性，B评论A的朋友圈，C评论B的留言，存在因果关系。","like_count":0},{"had_liked":false,"id":187981,"user_name":"爬行的蜗牛","can_delete":false,"product_type":"c1","uid":1033956,"ip_address":"","ucode":"6623B62DE63CE9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/QD6bf8hkS5dHrabdW7M7Oo9An1Oo3QSxqoySJMDh7GTraxFRX77VZ2HZ13x3R4EVYddIGXicRRDAc7V9z5cLDlA/132","comment_is_top":false,"comment_ctime":1584287238,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584287238","product_id":100025301,"comment_content":"朋友圈应该用最终一致性就好，我感觉这个和mysql主从同步有点类似:1.强同步，从节点写入数据成功后再返回客户端信息2.半同步，从节点收到主节点的消息后(并未写入）就返回客户端结果.3.异步","like_count":0},{"had_liked":false,"id":187772,"user_name":"Eden2020","can_delete":false,"product_type":"c1","uid":1899158,"ip_address":"","ucode":"0DEE62F2335237","user_header":"https://static001.geekbang.org/account/avatar/00/1c/fa/96/4a7b7505.jpg","comment_is_top":false,"comment_ctime":1584238526,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584238526","product_id":100025301,"comment_content":"最终一致性就可以了，强一致性性能会有影响，而且会阻塞并发读，有服务延迟，每个读者可能看到的不一样，但是最后还是按时间顺序看到一致的评论视图。","like_count":0},{"had_liked":false,"id":103423,"user_name":"倪必荣","can_delete":false,"product_type":"c1","uid":1046496,"ip_address":"","ucode":"34F707BB9DDDC9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/e0/34290aa4.jpg","comment_is_top":false,"comment_ctime":1560431479,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560431479","product_id":100025301,"comment_content":"思考题的评论系统，最终一致性比较合适，强一致的高延迟会非常影响用户评论的兴致","like_count":0},{"had_liked":false,"id":90970,"user_name":"果果几号","can_delete":false,"product_type":"c1","uid":1215041,"ip_address":"","ucode":"A8F101C962D4C8","user_header":"https://static001.geekbang.org/account/avatar/00/12/8a/41/7019ce3a.jpg","comment_is_top":false,"comment_ctime":1556763818,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556763818","product_id":100025301,"comment_content":"对于想深入学习分布式系统，有什么学习资料推荐的吗？","like_count":0},{"had_liked":false,"id":90572,"user_name":"Mac Kwan","can_delete":false,"product_type":"c1","uid":1001958,"ip_address":"","ucode":"FC80EBC9CD37A8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/e6/4f00fe55.jpg","comment_is_top":false,"comment_ctime":1556583160,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556583160","product_id":100025301,"comment_content":"微信朋友圈的评论功能应该是采取弱一致性的方案。朋友圈评论是相互为好友的人才能可见的。发表一条评论时，会先在手机本地添加一条自己的评论记录，然后再采取异步的方式将这条评论推送到微信服务器。再由微信服务器根据好友关系，推送到各个好友的手机记录中去。之间是存在延时的。而且当新的好友关系（增加或删除）成立后，还会异步通知双方朋友圈数据同步。最终实现这个评论列表相互查看的一致","like_count":0},{"had_liked":false,"id":90438,"user_name":"公共号","can_delete":false,"product_type":"c1","uid":1318914,"ip_address":"","ucode":"4759B517D4CD5E","user_header":"https://static001.geekbang.org/account/avatar/00/14/20/02/df2bfda9.jpg","comment_is_top":false,"comment_ctime":1556520234,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556520234","product_id":100025301,"comment_content":"对于评论者与被评论者 来说 ，评论要强一致性，对第三者来说，弱一致性即可； 因为朋友圈的评论比较私密性，同时朋友之间的沟通若消息丢失会有严重的体验问题","like_count":0},{"had_liked":false,"id":90240,"user_name":"Hessin","can_delete":false,"product_type":"c1","uid":1503893,"ip_address":"","ucode":"0B038B74EA9273","user_header":"https://static001.geekbang.org/account/avatar/00/16/f2/95/2d4944df.jpg","comment_is_top":false,"comment_ctime":1556456999,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556456999","product_id":100025301,"comment_content":"说下我粗浅的理解:弱一致性指定是不一致时间窗口已知，固定不一致时间窗口，或者可以给出不一致时间窗口范围。最终一致性说的是不一致时间窗口不定。","like_count":0},{"had_liked":false,"id":89856,"user_name":"Codelife","can_delete":false,"product_type":"c1","uid":1041421,"ip_address":"","ucode":"10458683978083","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLhMtBwGqqmyhxp5uaDTvvp18iaalQj8qHv6u8rv1FQXGozfl3alPvdPHpEsTWwFPFVOoP6EeKT4bw/132","comment_is_top":false,"comment_ctime":1556284330,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556284330","product_id":100025301,"comment_content":"关于弱一致性和最终一致性的区别,我的理解是：弱一致性不保证读取时候数据一致，最终一致性是在超过时间窗口之后一定保证一致","like_count":0},{"had_liked":false,"id":89834,"user_name":"珅剑","can_delete":false,"product_type":"c1","uid":1504220,"ip_address":"","ucode":"4290D5C140F80F","user_header":"https://static001.geekbang.org/account/avatar/00/16/f3/dc/80b0cd23.jpg","comment_is_top":false,"comment_ctime":1556278237,"is_pvip":false,"replies":[{"id":"33016","content":"谢谢你的回复！问的问题很棒！<br><br>对于最终一致性的理解，应该是你说的后者。<br><br>正如我在另一个回复中提到的，弱一致性是一个比较宽泛的概念，它是区别于强一致性的，包括各种不同容忍度的模型，比如因果一致性等都算它的特例。","user_name":"作者回复","user_name_real":"Xinyue Li","uid":"1502409","ctime":1557227909,"ip_address":"","comment_id":89834,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556278237","product_id":100025301,"comment_content":"同问弱一致性和最终一致性的区别，最终一致性在弱一致性的基础上特殊在哪儿？<br>另外，最终一致性是保证每一次更新都会最终被同步还是只需要在没有新的更新时保证最后一条更新被同步？","like_count":0,"discussions":[{"author":{"id":1502409,"avatar":"https://static001.geekbang.org/account/avatar/00/16/ec/c9/45bfcba3.jpg","nickname":"Xinyue Li","note":"","ucode":"0CB92610C8B9FC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448281,"discussion_content":"谢谢你的回复！问的问题很棒！\n\n对于最终一致性的理解，应该是你说的后者。\n\n正如我在另一个回复中提到的，弱一致性是一个比较宽泛的概念，它是区别于强一致性的，包括各种不同容忍度的模型，比如因果一致性等都算它的特例。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557227909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89829,"user_name":"智超","can_delete":false,"product_type":"c1","uid":1109769,"ip_address":"","ucode":"1C28A46FDD7FA2","user_header":"https://static001.geekbang.org/account/avatar/00/10/ef/09/209cb7ff.jpg","comment_is_top":false,"comment_ctime":1556276190,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556276190","product_id":100025301,"comment_content":"分布式系统的核心就是可扩展性（Scalability）。这个应该是伸缩性更合适","like_count":0},{"had_liked":false,"id":89784,"user_name":"sxpujs","can_delete":false,"product_type":"c1","uid":1503861,"ip_address":"","ucode":"F81931EC883D7C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/yYzf0yonEqKny7dHlvLibc7OrQJ6HszX3VP1fciaMD3hITFySbayL9vULch5hvicoqGA2EBzcPicss2ciaB7ibodgQ6w/132","comment_is_top":false,"comment_ctime":1556263750,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556263750","product_id":100025301,"comment_content":"弱一致性和最终一致性的区别是什么？老师能讲得再详细些吗？","like_count":0},{"had_liked":false,"id":89738,"user_name":":)","can_delete":false,"product_type":"c1","uid":1239198,"ip_address":"","ucode":"23D505949442B6","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/9e/6550a051.jpg","comment_is_top":false,"comment_ctime":1556253148,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556253148","product_id":100025301,"comment_content":"最终一致性。用户会关心回复的留言被他人看到，但是不会非常非常在意这个留言什么时候被他人看到，，，所以最终一致性就够了","like_count":0},{"had_liked":false,"id":89678,"user_name":"happiness","can_delete":false,"product_type":"c1","uid":1026587,"ip_address":"","ucode":"C5F25D57C7A1DC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/aa/1b/b43c8519.jpg","comment_is_top":false,"comment_ctime":1556243174,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556243174","product_id":100025301,"comment_content":"我认为这里的数据一致性模型应该是两个，一个是关于db和缓存间的数据一致性问题，这里可以采用最终一致性模型。另外一个是从查看朋友圈的用户角度来看，如果使用的是分布式缓存，数据模型应该也是最终一致性的。一个用户提交了新的评论，因为数据同步等原因，其他用户并不能一定同时能查看到最近的评论。","like_count":0}]}