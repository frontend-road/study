{"id":200786,"title":"47 | 原型模式：如何最快速地clone一个HashMap散列表？","content":"<p>对于创建型模式，前面我们已经讲了单例模式、工厂模式、建造者模式，今天我们来讲最后一个：原型模式。</p><p>对于熟悉JavaScript语言的前端程序员来说，原型模式是一种比较常用的开发模式。这是因为，有别于Java、C++等基于类的面向对象编程语言，JavaScript是一种基于原型的面向对象编程语言。即便JavaScript现在也引入了类的概念，但它也只是基于原型的语法糖而已。不过，如果你熟悉的是Java、C++等这些编程语言，那在实际的开发中，就很少用到原型模式了。</p><p>今天的讲解跟具体某一语言的语法机制无关，而是通过一个clone散列表的例子带你搞清楚：原型模式的应用场景，以及它的两种实现方式：深拷贝和浅拷贝。虽然原型模式的原理和代码实现非常简单，但今天举的例子还是稍微有点复杂的，你要跟上我的思路，多动脑思考一下。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>原型模式的原理与应用</h2><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作<strong>原型设计模式</strong>（Prototype Design Pattern），简称<strong>原型模式</strong>。</p><!-- [[[read_end]]] --><p><strong>那何为“对象的创建成本比较大”？</strong></p><p>实际上，创建对象包含的申请内存、给成员变量赋值这一过程，本身并不会花费太多时间，或者说对于大部分业务系统来说，这点时间完全是可以忽略的。应用一个复杂的模式，只得到一点点的性能提升，这就是所谓的过度设计，得不偿失。</p><p>但是，如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需要从RPC、网络、数据库、文件系统等非常慢速的IO中读取，这种情况下，我们就可以利用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执行这些耗时的操作。</p><p><strong>这么说还是比较理论，接下来，我们通过一个例子来解释一下刚刚这段话。</strong></p><p>假设数据库中存储了大约10万条“搜索关键词”信息，每条信息包含关键词、关键词被搜索的次数、信息最近被更新的时间等。系统A在启动的时候会加载这份数据到内存中，用于处理某些其他的业务需求。为了方便快速地查找某个关键词对应的信息，我们给关键词建立一个散列表索引。</p><p>如果你熟悉的是Java语言，可以直接使用语言中提供的HashMap容器来实现。其中，HashMap的key为搜索关键词，value为关键词详细信息（比如搜索次数）。我们只需要将数据从数据库中读取出来，放入HashMap就可以了。</p><p>不过，我们还有另外一个系统B，专门用来分析搜索日志，定期（比如间隔10分钟）批量地更新数据库中的数据，并且标记为新的数据版本。比如，在下面的示例图中，我们对v2版本的数据进行更新，得到v3版本的数据。这里我们假设只有更新和新添关键词，没有删除关键词的行为。</p><p><img src=\"https://static001.geekbang.org/resource/image/05/0e/05233c28ddda51b81dfd946ffdef640e.jpg?wh=2446*1240\" alt=\"\"></p><p>为了保证系统A中数据的实时性（不一定非常实时，但数据也不能太旧），系统A需要定期根据数据库中的数据，更新内存中的索引和数据。</p><p>我们该如何实现这个需求呢？</p><p>实际上，也不难。我们只需要在系统A中，记录当前数据的版本Va对应的更新时间Ta，从数据库中捞出更新时间大于Ta的所有搜索关键词，也就是找出Va版本与最新版本数据的“差集”，然后针对差集中的每个关键词进行处理。如果它已经在散列表中存在了，我们就更新相应的搜索次数、更新时间等信息；如果它在散列表中不存在，我们就将它插入到散列表中。</p><p>按照这个设计思路，我给出的示例代码如下所示：</p><pre><code>public class Demo {\n  private ConcurrentHashMap&lt;String, SearchWord&gt; currentKeywords = new ConcurrentHashMap&lt;&gt;();\n  private long lastUpdateTime = -1;\n\n  public void refresh() {\n    // 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到currentKeywords中\n    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);\n    long maxNewUpdatedTime = lastUpdateTime;\n    for (SearchWord searchWord : toBeUpdatedSearchWords) {\n      if (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) {\n        maxNewUpdatedTime = searchWord.getLastUpdateTime();\n      }\n      if (currentKeywords.containsKey(searchWord.getKeyword())) {\n        currentKeywords.replace(searchWord.getKeyword(), searchWord);\n      } else {\n        currentKeywords.put(searchWord.getKeyword(), searchWord);\n      }\n    }\n\n    lastUpdateTime = maxNewUpdatedTime;\n  }\n\n  private List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) {\n    // TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据\n    return null;\n  }\n}\n</code></pre><p>不过，现在，我们有一个特殊的要求：任何时刻，系统A中的所有数据都必须是同一个版本的，要么都是版本a，要么都是版本b，不能有的是版本a，有的是版本b。那刚刚的更新方式就不能满足这个要求了。除此之外，我们还要求：在更新内存数据的时候，系统A不能处于不可用状态，也就是不能停机更新数据。</p><p>那我们该如何实现现在这个需求呢？</p><p>实际上，也不难。我们把正在使用的数据的版本定义为“服务版本”，当我们要更新内存中的数据的时候，我们并不是直接在服务版本（假设是版本a数据）上更新，而是重新创建另一个版本数据（假设是版本b数据），等新的版本数据建好之后，再一次性地将服务版本从版本a切换到版本b。这样既保证了数据一直可用，又避免了中间状态的存在。</p><p>按照这个设计思路，我给出的示例代码如下所示：</p><pre><code>public class Demo {\n  private HashMap&lt;String, SearchWord&gt; currentKeywords=new HashMap&lt;&gt;();\n\n  public void refresh() {\n    HashMap&lt;String, SearchWord&gt; newKeywords = new LinkedHashMap&lt;&gt;();\n\n    // 从数据库中取出所有的数据，放入到newKeywords中\n    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords();\n    for (SearchWord searchWord : toBeUpdatedSearchWords) {\n      newKeywords.put(searchWord.getKeyword(), searchWord);\n    }\n\n    currentKeywords = newKeywords;\n  }\n\n  private List&lt;SearchWord&gt; getSearchWords() {\n    // TODO: 从数据库中取出所有的数据\n    return null;\n  }\n}\n</code></pre><p>不过，在上面的代码实现中，newKeywords构建的成本比较高。我们需要将这10万条数据从数据库中读出，然后计算哈希值，构建newKeywords。这个过程显然是比较耗时。为了提高效率，原型模式就派上用场了。</p><p>我们拷贝currentKeywords数据到newKeywords中，然后从数据库中只捞出新增或者有更新的关键词，更新到newKeywords中。而相对于10万条数据来说，每次新增或者更新的关键词个数是比较少的，所以，这种策略大大提高了数据更新的效率。</p><p>按照这个设计思路，我给出的示例代码如下所示：</p><pre><code>public class Demo {\n  private HashMap&lt;String, SearchWord&gt; currentKeywords=new HashMap&lt;&gt;();\n  private long lastUpdateTime = -1;\n\n  public void refresh() {\n    // 原型模式就这么简单，拷贝已有对象的数据，更新少量差值\n    HashMap&lt;String, SearchWord&gt; newKeywords = (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();\n\n    // 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中\n    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);\n    long maxNewUpdatedTime = lastUpdateTime;\n    for (SearchWord searchWord : toBeUpdatedSearchWords) {\n      if (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) {\n        maxNewUpdatedTime = searchWord.getLastUpdateTime();\n      }\n      if (newKeywords.containsKey(searchWord.getKeyword())) {\n        SearchWord oldSearchWord = newKeywords.get(searchWord.getKeyword());\n        oldSearchWord.setCount(searchWord.getCount());\n        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());\n      } else {\n        newKeywords.put(searchWord.getKeyword(), searchWord);\n      }\n    }\n\n    lastUpdateTime = maxNewUpdatedTime;\n    currentKeywords = newKeywords;\n  }\n\n  private List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) {\n    // TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据\n    return null;\n  }\n}\n</code></pre><p>这里我们利用了Java中的clone()语法来复制一个对象。如果你熟悉的语言没有这个语法，那把数据从currentKeywords中一个个取出来，然后再重新计算哈希值，放入到newKeywords中也是可以接受的。毕竟，最耗时的还是从数据库中取数据的操作。相对于数据库的IO操作来说，内存操作和CPU计算的耗时都是可以忽略的。</p><p>不过，不知道你有没有发现，实际上，刚刚的代码实现是有问题的。要弄明白到底有什么问题，我们需要先了解另外两个概念：深拷贝（Deep Copy）和浅拷贝（Shallow Copy）。</p><h2>原型模式的实现方式：深拷贝和浅拷贝</h2><p>我们来看，在内存中，用散列表组织的搜索关键词信息是如何存储的。我画了一张示意图，大致结构如下所示。从图中我们可以发现，散列表索引中，每个结点存储的key是搜索关键词，value是SearchWord对象的内存地址。SearchWord对象本身存储在散列表之外的内存空间中。</p><p><img src=\"https://static001.geekbang.org/resource/image/f5/d2/f5ba85952b27a569687e2d44352216d2.jpg?wh=2258*1784\" alt=\"\"></p><p>浅拷贝和深拷贝的区别在于，浅拷贝只会复制图中的索引（散列表），不会复制数据（SearchWord对象）本身。相反，深拷贝不仅仅会复制索引，还会复制数据本身。浅拷贝得到的对象（newKeywords）跟原始对象（currentKeywords）共享数据（SearchWord对象），而深拷贝得到的是一份完完全全独立的对象。具体的对比如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/74/82/74bceb7a0736957daaa4abeba6826182.jpg?wh=4580*1784\" alt=\"\"></p><p><img src=\"https://static001.geekbang.org/resource/image/b9/1b/b978d054ab3183b9e0ae461e6abac81b.jpg?wh=5198*1784\" alt=\"\"></p><p>在Java语言中，Object类的clone()方法执行的就是我们刚刚说的浅拷贝。它只会拷贝对象中的基本数据类型的数据（比如，int、long），以及引用对象（SearchWord）的内存地址，不会递归地拷贝引用对象本身。</p><p>在上面的代码中，我们通过调用HashMap上的clone()浅拷贝方法来实现原型模式。当我们通过newKeywords更新SearchWord对象的时候（比如，更新“设计模式”这个搜索关键词的访问次数），newKeywords和currentKeywords因为指向相同的一组SearchWord对象，就会导致currentKeywords中指向的SearchWord，有的是老版本的，有的是新版本的，就没法满足我们之前的需求：currentKeywords中的数据在任何时刻都是同一个版本的，不存在介于老版本与新版本之间的中间状态。</p><p>现在，我们又该如何来解决这个问题呢？</p><p>我们可以将浅拷贝替换为深拷贝。newKeywords不仅仅复制currentKeywords的索引，还把SearchWord对象也复制一份出来，这样newKeywords和currentKeywords就指向不同的SearchWord对象，也就不存在更新newKeywords的数据会导致currentKeywords的数据也被更新的问题了。</p><p>那如何实现深拷贝呢？总结一下的话，有下面两种方法。</p><p>第一种方法：递归拷贝对象、对象的引用对象以及引用对象的引用对象……直到要拷贝的对象只包含基本数据类型数据，没有引用对象为止。根据这个思路对之前的代码进行重构。重构之后的代码如下所示：</p><pre><code>public class Demo {\n  private HashMap&lt;String, SearchWord&gt; currentKeywords=new HashMap&lt;&gt;();\n  private long lastUpdateTime = -1;\n\n  public void refresh() {\n    // Deep copy\n    HashMap&lt;String, SearchWord&gt; newKeywords = new HashMap&lt;&gt;();\n    for (HashMap.Entry&lt;String, SearchWord&gt; e : currentKeywords.entrySet()) {\n      SearchWord searchWord = e.getValue();\n      SearchWord newSearchWord = new SearchWord(\n              searchWord.getKeyword(), searchWord.getCount(), searchWord.getLastUpdateTime());\n      newKeywords.put(e.getKey(), newSearchWord);\n    }\n\n    // 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中\n    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);\n    long maxNewUpdatedTime = lastUpdateTime;\n    for (SearchWord searchWord : toBeUpdatedSearchWords) {\n      if (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) {\n        maxNewUpdatedTime = searchWord.getLastUpdateTime();\n      }\n      if (newKeywords.containsKey(searchWord.getKeyword())) {\n        SearchWord oldSearchWord = newKeywords.get(searchWord.getKeyword());\n        oldSearchWord.setCount(searchWord.getCount());\n        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());\n      } else {\n        newKeywords.put(searchWord.getKeyword(), searchWord);\n      }\n    }\n\n    lastUpdateTime = maxNewUpdatedTime;\n    currentKeywords = newKeywords;\n  }\n\n  private List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) {\n    // TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据\n    return null;\n  }\n\n}\n</code></pre><p>第二种方法：先将对象序列化，然后再反序列化成新的对象。具体的示例代码如下所示：</p><pre><code>public Object deepCopy(Object object) {\n  ByteArrayOutputStream bo = new ByteArrayOutputStream();\n  ObjectOutputStream oo = new ObjectOutputStream(bo);\n  oo.writeObject(object);\n  \n  ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());\n  ObjectInputStream oi = new ObjectInputStream(bi);\n  \n  return oi.readObject();\n}\n</code></pre><p>刚刚的两种实现方法，不管采用哪种，深拷贝都要比浅拷贝耗时、耗内存空间。针对我们这个应用场景，有没有更快、更省内存的实现方式呢？</p><p>我们可以先采用浅拷贝的方式创建newKeywords。对于需要更新的SearchWord对象，我们再使用深度拷贝的方式创建一份新的对象，替换newKeywords中的老对象。毕竟需要更新的数据是很少的。这种方式即利用了浅拷贝节省时间、空间的优点，又能保证currentKeywords中的中数据都是老版本的数据。具体的代码实现如下所示。这也是标题中讲到的，在我们这个应用场景下，最快速clone散列表的方式。</p><pre><code>public class Demo {\n  private HashMap&lt;String, SearchWord&gt; currentKeywords=new HashMap&lt;&gt;();\n  private long lastUpdateTime = -1;\n\n  public void refresh() {\n    // Shallow copy\n    HashMap&lt;String, SearchWord&gt; newKeywords = (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();\n\n    // 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中\n    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);\n    long maxNewUpdatedTime = lastUpdateTime;\n    for (SearchWord searchWord : toBeUpdatedSearchWords) {\n      if (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) {\n        maxNewUpdatedTime = searchWord.getLastUpdateTime();\n      }\n      if (newKeywords.containsKey(searchWord.getKeyword())) {\n        newKeywords.remove(searchWord.getKeyword());\n      }\n      newKeywords.put(searchWord.getKeyword(), searchWord);\n    }\n\n    lastUpdateTime = maxNewUpdatedTime;\n    currentKeywords = newKeywords;\n  }\n\n  private List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) {\n    // TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据\n    return null;\n  }\n}\n</code></pre><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p><strong>1.什么是原型模式？</strong></p><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式，来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式，简称原型模式。</p><p><strong>2.原型模式的两种实现方法</strong></p><p>原型模式有两种实现方法，深拷贝和浅拷贝。浅拷贝只会复制对象中基本数据类型数据和引用对象的内存地址，不会递归地复制引用对象，以及引用对象的引用对象……而深拷贝得到的是一份完完全全独立的对象。所以，深拷贝比起浅拷贝来说，更加耗时，更加耗内存空间。</p><p>如果要拷贝的对象是不可变对象，浅拷贝共享不可变对象是没问题的，但对于可变对象来说，浅拷贝得到的对象和原始对象会共享部分数据，就有可能出现数据被修改的风险，也就变得复杂多了。除非像我们今天实战中举的那个例子，需要从数据库中加载10万条数据并构建散列表索引，操作非常耗时，这种情况下比较推荐使用浅拷贝，否则，没有充分的理由，不要为了一点点的性能提升而使用浅拷贝。</p><h2>课堂讨论</h2><ol>\n<li>在今天的应用场景中，如果不仅往数据库中添加和更新关键词，还删除关键词，这种情况下，又该如何实现呢？</li>\n<li>在<a href=\"https://time.geekbang.org/column/article/164907\">第7讲</a>中，为了让ShoppingCart的getItems()方法返回不可变对象，我们如下来实现代码。当时，我们指出这样的实现思路还是有点问题。因为当调用者通过ShoppingCart的getItems()获取到items之后，我们还是可以修改容器中每个对象（ShoppingCartItem）的数据。学完本节课之后，现在你有没有解决方法了呢？</li>\n</ol><pre><code>public class ShoppingCart {\n  // ...省略其他代码...\n  public List&lt;ShoppingCartItem&gt; getItems() {\n    return Collections.unmodifiableList(this.items);\n  }\n}\n\n// Testing Code in main method:\nShoppingCart cart = new ShoppingCart();\nList&lt;ShoppingCartItem&gt; items = cart.getItems();\nitems.clear();//try to modify the list\n// Exception in thread &quot;main&quot; java.lang.UnsupportedOperationExceptio \n\nShoppingCart cart = new ShoppingCart();\ncart.add(new ShoppingCartItem(...));\nList&lt;ShoppingCartItem&gt; items = cart.getItems();\nShoppingCartItem item = items.get(0);\nitem.setPrice(19.0); // 这里修改了item的价格属性\n</code></pre><p>欢迎留言和我分享你的疑惑和见解，如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>","neighbors":{"left":{"article_title":"46 | 建造者模式：详解构造函数、set方法、建造者模式三种对象创建方式","id":199674},"right":{"article_title":"48 | 代理模式：代理在RPC、缓存、监控等场景中的应用","id":201823}},"comments":[{"had_liked":false,"id":179785,"user_name":"L🚲🐱","can_delete":false,"product_type":"c1","uid":1577856,"ip_address":"","ucode":"08A012739614DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","comment_is_top":false,"comment_ctime":1582098677,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"358064384245","product_id":100039001,"comment_content":"问题 1: 逻辑删除即可<br>问题 2:  返回深拷贝对象","like_count":84,"discussions":[{"author":{"id":1609051,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8d/5b/383a49e4.jpg","nickname":"charmsongo","note":"","ucode":"4FBEE716E93A1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413382,"discussion_content":"精辟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636460824,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362707,"discussion_content":"文字越少, 答案越对, 厉害","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617015106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":210344,"user_name":"静静聆听","can_delete":false,"product_type":"c1","uid":1263932,"ip_address":"","ucode":"0A8600CB928EFE","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/3c/5d54c510.jpg","comment_is_top":false,"comment_ctime":1587724258,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"207746154466","product_id":100039001,"comment_content":"原型模式，最为常用经典就是BeanUtils","like_count":49},{"had_liked":false,"id":179880,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1582117083,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"78891528411","product_id":100039001,"comment_content":"问题1:<br>方法一：新旧的数据取交集，可以删除旧map中的删除关键字，之后的逻辑就和文章中一样了。<br>方法二：逻辑删除，当map的size中已删除占比过高时，resize map。<br><br>争哥说：这里我们利用了 Java 中的 clone() 语法来复制一个对象。如果你熟悉的语言没有这个语法，那把数据从 currentKeywords 中一个个取出来，然后再重新计算哈希值，放入到 newKeywords 中也是可以接受的。<br><br>Java HashMap的clone方法就把数据取出来，计算hash值，在放回去的。clone方法中，调用了putMapEntries方法，其中有一关键的一行，克隆重新计算了hash值：<br>putVal(hash(key), key, value, false, evict); <br><br>文章中的深复制：为什么SearchWord不重写clone方法呢？<br>@Override<br>protected Object clone() throws CloneNotSupportedException {<br>  SearchWord newWord = new SearchWord(this.keyWord, this.times, this.tmstamp);<br>  return newWord;<br>}<br>","like_count":18,"discussions":[{"author":{"id":1368522,"avatar":"https://static001.geekbang.org/account/avatar/00/14/e1/ca/d8b0835f.jpg","nickname":"橘子","note":"","ucode":"EDF6145878F897","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":180436,"discussion_content":"他的意思应该是这个对象可能里面又有对象呢，那么可能无止境的去重写。还有在已有的代码前提这应该最少修改的。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1582294717,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066102,"avatar":"https://static001.geekbang.org/account/avatar/00/10/44/76/a86cfd2a.jpg","nickname":"Akira","note":"","ucode":"A0BFD54A95012D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551809,"discussion_content":"重写这个clone就会把没有变化的数据也复制一份。没有达到浅拷贝+深拷贝的性能提升目的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645145303,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211018,"user_name":"新的起点，新的开始^_^","can_delete":false,"product_type":"c1","uid":1262068,"ip_address":"","ucode":"9C0810F472AC93","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/f4/5df17eff.jpg","comment_is_top":false,"comment_ctime":1587882237,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"66012391677","product_id":100039001,"comment_content":"我有个问题，最后一种方式使用copy()的浅拷贝+对象替换可以提高效率。但是copy()之后，数据库中更没有发生变化的数据其实newKeywords中指向的还是之前的对象引用啊，不是一个新的对象，那这个结果不久和需求冲突了吗？需求是：任何时刻，系统 A 中的所有数据都必须是同一个版本的。举个例子，比如说我修改了一个newKeywords中value对应的SearchWord对象的某个属性，那么响应的，currentKeywords中肯定也会发生变化，因为SearchWord地址值时一样的，这个就不是刚开始讲的深拷贝得到的是一份完完全全独立的对象，它不是独立的，只有数据库中被更新过的数据是独立的，因为执行了map.remove()和map.put()","like_count":15,"discussions":[{"author":{"id":1236320,"avatar":"https://static001.geekbang.org/account/avatar/00/12/dd/60/a6a4f79a.jpg","nickname":"笨鸟","note":"","ucode":"68029ADA76AA5A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334876,"discussion_content":"map.remove()是操作的拷贝出来的数据,只是移除掉拷贝出来数据的引用,所以不影响原数据,但是你获取到map.get(key)的数据,再修改,就是修改的原数据,仔细看一下讲拷贝那的图","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1608016130,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1398577,"avatar":"https://static001.geekbang.org/account/avatar/00/15/57/31/6772744d.jpg","nickname":"ちよくん","note":"","ucode":"B71E9B16E4408F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":314898,"discussion_content":"包含删除，不包含添加，不管包含不包含，更新的都添加进去了，最后统一赋值给当前map","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603206924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1712955,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/OYQh8KlUgMx0sZ35felqqRlboXkcOFib0qGgRHuvFCNIMzxRzxN8SjZpwtDuS0PGV0L0Pneiak7yzcd043f2efbg/132","nickname":"Geek_78eadb","note":"","ucode":"843C6C380D28FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298859,"discussion_content":"你在幻想一个不存在的需求：“客户想修改数据”","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597448528,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066102,"avatar":"https://static001.geekbang.org/account/avatar/00/10/44/76/a86cfd2a.jpg","nickname":"Akira","note":"","ucode":"A0BFD54A95012D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551807,"discussion_content":"需求说的同一版本指的是：correntKeyWord的数据在任一时刻要么是过期的内存的数据，要么是最新从数据库载入的数据\n没有变化的内存过期数据和数据库的数据是一样的。不用深拷贝。用内存已经存在的就可以。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645145189,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2664232,"avatar":"","nickname":"追梦XRer","note":"","ucode":"E04762C9DF6926","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389912,"discussion_content":"对象替换使用remove先移出 再put一个new出来的新对象 这个与原来map中的被克隆对象不一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629503939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1153301,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK3fLmHRZU8qSBDUUAhgRHuGgXiaggMVbIwJIXlBEImPNYbuwNlHzlOA7sR8zcj4Q5OZVWcGDo6sGw/132","nickname":"ori","note":"","ucode":"1F2961EE046DE1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306377,"discussion_content":"我想了一下，感觉作者说的版本应该不是说数据库中的 v2、v3 版本，应该指的是 map 从一个状态跳往下一个状态，中间不要单独切换数据，而是统一替换。\n不然这个同一个版本在数据库没有版本字段的情况下，只是说内存中的值和数据库一致的话，浅拷贝之前的代码就已经满足了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600259492,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2085090,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/d0/e2/1d00c079.jpg","nickname":"写代码的","note":"","ucode":"F58186409A3D65","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300533,"discussion_content":"没太理解你的意思，既然没发生变化的数据用的才是引用，你后面的例子又假设让它的数据改变了，这不矛盾了吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598160543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180303,"user_name":"岁月","can_delete":false,"product_type":"c1","uid":1337598,"ip_address":"","ucode":"29A2A2BC3C4FE4","user_header":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","comment_is_top":false,"comment_ctime":1582253753,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"66006763193","product_id":100039001,"comment_content":"课堂讨论题<br>关键字如果支持删除, 最简单高效的方法就是在数据表里加一个delete bool类型的字段, 占用空间不多, 但是很方便程序识别最近更新的数据里面, 有哪条是需要删除的. 不过这样会带来一个问题, 就是插入新关键字的时候, 要先检查一下是否存在同名的关键字, 有的话要把delete字段修改为false, 所以还需要对关键字建立索引, 这样可以高效查找出是否存在同名关键字","like_count":16},{"had_liked":false,"id":181237,"user_name":"不似旧日","can_delete":false,"product_type":"c1","uid":1161271,"ip_address":"","ucode":"DF4C5E3AB9570C","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","comment_is_top":false,"comment_ctime":1582523639,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"48827163895","product_id":100039001,"comment_content":"既然说在Java中不常用那我就不看了，以后有时间再学。","like_count":11,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503269,"discussion_content":"������ 你说的没错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597412065,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203961,"user_name":"安静","can_delete":false,"product_type":"c1","uid":1212634,"ip_address":"","ucode":"7C4DB6D81A48EB","user_header":"https://static001.geekbang.org/account/avatar/00/12/80/da/9c0c458c.jpg","comment_is_top":false,"comment_ctime":1586312582,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"44535985542","product_id":100039001,"comment_content":"老师，就是java分层架构中各层的对象，比如VO，BO，PO之间的互相转换，使用的就是原型模式，而做业务开发每天都要与这些打交道。","like_count":11},{"had_liked":false,"id":179893,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1582118920,"is_pvip":false,"discussion_count":12,"race_medal":0,"score":"40236824584","product_id":100039001,"comment_content":"让我想到了linux下面fork，其实内核也是拷贝了一份数据。Java里面的copyonwrite是不是也是这种深拷贝原理呢？","like_count":9,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502599,"discussion_content":"嗯嗯 你的表述更准确些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596109659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134574,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4f/ee/bd08cfab.jpg","nickname":"一魄","note":"","ucode":"71541125D4AA5A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384694,"discussion_content":"专栏都完结了，老师还能答复，👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626702057,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134574,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4f/ee/bd08cfab.jpg","nickname":"一魄","note":"","ucode":"71541125D4AA5A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384693,"discussion_content":"专栏都完结了，老师还能答复，👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626702038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179704,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1582081194,"is_pvip":false,"discussion_count":3,"race_medal":1,"score":"27351884970","product_id":100039001,"comment_content":"1. 考虑到删除关键词，那么最好数据库使用软删除，这样可以知道哪些关键词是被删除的，那么拿到这些被删除的关键词就可以在clone出来的newKeywords基础上，直接remove掉已经删除的哪些关键词就可以了。反之如果不是使用的软删除，那么就不好使用原型模式，需要获取新版本全量数据，然后和旧版本数据一一比对，看哪些数据是被删除的了。<br>2. 代码如下，将原来的items deep clone一份，这样就切断了与原来items的联系。<br>  public class ShoppingCart { <br>    &#47;&#47; ...省略其他代码... <br>    public List&lt;ShoppingCartItem&gt; getItems() {<br>      List&lt;ShoppingCartItem&gt; tmpShoppingCartItems = new ArrayList&lt;&gt;();<br>      tmpShoppingCartItems.addAll(this.items);<br>      return Collections.unmodifiableList(tmpShoppingCartItems); <br>    }<br>  }","like_count":6,"discussions":[{"author":{"id":2731028,"avatar":"https://static001.geekbang.org/account/avatar/00/29/ac/14/a8ff8fec.jpg","nickname":"慕言","note":"","ucode":"4918FA682F3895","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572633,"discussion_content":"你这样重新创建一个ArrayList就是深拷贝了？里面的item不需要拷贝的？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1652879039,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289773,"discussion_content":"已经返回深拷贝了为什么还要用unmodifiableList包装一下？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594210048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1021539,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/96/63/7eb32c9b.jpg","nickname":"捞鱼的搬砖奇","note":"","ucode":"2FD194C4DA26E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312157,"discussion_content":"这是两件事吧。unmodifiableList() 是为了让返回的结果不可变","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602598253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":289773,"ip_address":""},"score":312157,"extra":""}]}]},{"had_liked":false,"id":203081,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1586137596,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"23060974076","product_id":100039001,"comment_content":"看了几遍才明白第一次的浅拷贝问题在哪，在遍历的时候就已经替换了其中一些旧对象；而最后浅拷贝和深拷贝结合的方式，是先把浅拷贝得到的索引（引用）删除，然后再添加新的对象到浅拷贝中，最后在遍历结束后一并替换原型。","like_count":5,"discussions":[{"author":{"id":1370125,"avatar":"https://static001.geekbang.org/account/avatar/00/14/e8/0d/6d303d18.jpg","nickname":"无双BaOY_WHA","note":"","ucode":"41F282C31D256C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281547,"discussion_content":"学过C++就好理解浅拷贝会产生的问题了。浅拷贝只是B拷贝了A的内存地址，这样A和B共享一块内存里的数据；深拷贝是B重新申请一份内存空间（拷贝了A对应的内存里存储的数据），用的是新的内存地址。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591762530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2122539,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","nickname":"阿骨打","note":"","ucode":"35EADA5550162A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306257,"discussion_content":"第一次 浅拷贝， SearchWord被共用了，造成部分的元素是 高版本，部分没遍历到的是低版本","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600230814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262015,"user_name":"冬瓜蔡","can_delete":false,"product_type":"c1","uid":1117673,"ip_address":"","ucode":"2F04A446D28201","user_header":"https://static001.geekbang.org/account/avatar/00/11/0d/e9/2f02a383.jpg","comment_is_top":false,"comment_ctime":1605605757,"is_pvip":false,"replies":[{"id":"96125","content":"������","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606701127,"ip_address":"","comment_id":262015,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14490507645","product_id":100039001,"comment_content":"日常开发中常用的是spring提供的对象之间拷贝的方法： BeanUtils.copyProperties<br>1、如果是基础类型，则没有问题。<br>2、如果要拷贝对象里面有小对象，且小对象的全限定名不一样，则拷贝结束后，该对象为null；<br>public class Person {<br>    private Photo photo;<br>}<br>3、如果要拷贝对象里面有集合，集合里面存放的是小对象，则会由于泛型的存在，可以拷贝成功，但是这个拷贝的对象是错误的，会在后续使用过程中产生问题<br>public class Person {<br>    private List&lt;Photo&gt; photo;<br>}<br><br>本质上BeanUtils.copyProperties是浅拷贝，在使用过程中需要对嵌套对象或者集合进行额外处理","like_count":4,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509687,"discussion_content":"������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606701127,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1225224,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","nickname":"尔冬橙","note":"","ucode":"0B013A49BC18DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":575044,"discussion_content":"问号是啥意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654569127,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":509687,"ip_address":""},"score":575044,"extra":""}]}]},{"had_liked":false,"id":186936,"user_name":"夕林语","can_delete":false,"product_type":"c1","uid":1264180,"ip_address":"","ucode":"B57681D0C73E1B","user_header":"https://static001.geekbang.org/account/avatar/00/13/4a/34/1faac99b.jpg","comment_is_top":false,"comment_ctime":1583975842,"is_pvip":false,"discussion_count":3,"race_medal":2,"score":"14468877730","product_id":100039001,"comment_content":"数据库中加载 10 万条数据并构建散列表索引，操作非常耗时，比较推荐使用浅拷贝，否则，没有充分的理由，不要为了一点点的性能提升而使用浅拷贝。这里表述有问题吧，最后应该是深拷贝吧。两个浅拷贝比较怎么都别扭","like_count":3},{"had_liked":false,"id":180537,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1582327449,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"14467229337","product_id":100039001,"comment_content":"我在实际工作中就用到了类似的代码，这就是一个关键词识别模块，第一次在学习专栏中看到如此契合生产的代码，很赞👍<br><br>问题1: 数据库中新增一个字段标识逻辑删除<br>问题2:深拷贝出去，不过为啥我外部需要一个深拷贝的对象呢，还没理解","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492364,"discussion_content":"新版本的可以！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594785934,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248771,"user_name":"ちよくん","can_delete":false,"product_type":"c1","uid":1398577,"ip_address":"","ucode":"B71E9B16E4408F","user_header":"https://static001.geekbang.org/account/avatar/00/15/57/31/6772744d.jpg","comment_is_top":false,"comment_ctime":1600307372,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10190241964","product_id":100039001,"comment_content":"if (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) {<br>        maxNewUpdatedTime = searchWord.getLastUpdateTime();<br>      }<br>这段逻辑没看懂起什么作用？和下面的额代码没什么链接","like_count":2,"discussions":[{"author":{"id":1577210,"avatar":"https://static001.geekbang.org/account/avatar/00/18/10/fa/d977627e.jpg","nickname":"刘大人","note":"","ucode":"F66AE613E80398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345568,"discussion_content":"循环时找出最大时间戳，跳出循环后，再把时间戳 赋值给变量，方便下一个获取数据","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1611743184,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":247004,"user_name":"小情绪","can_delete":false,"product_type":"c1","uid":1020311,"ip_address":"","ucode":"92D8081DB8DB45","user_header":"https://static001.geekbang.org/account/avatar/00/0f/91/97/3762ca10.jpg","comment_is_top":false,"comment_ctime":1599555463,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10189490055","product_id":100039001,"comment_content":"copy-on-write","like_count":3},{"had_liked":false,"id":179697,"user_name":"唐龙","can_delete":false,"product_type":"c1","uid":1471657,"ip_address":"","ucode":"87A10AE04F2037","user_header":"https://static001.geekbang.org/account/avatar/00/16/74/a9/5eb3ebc6.jpg","comment_is_top":false,"comment_ctime":1582080211,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10172014803","product_id":100039001,"comment_content":"之前听说，可能你在不经意间已经用过一些设计模式了，今天终于有这种感觉了，确实对原型模式有过一些简单应用。","like_count":2},{"had_liked":false,"id":179955,"user_name":"平风造雨","can_delete":false,"product_type":"c1","uid":1014349,"ip_address":"","ucode":"F9EE4704F31E22","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/4d/b0228a1a.jpg","comment_is_top":false,"comment_ctime":1582126574,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"5877093870","product_id":100039001,"comment_content":"1. 两个Map比较下key找到差集<br>2. 可以返回深复制的购物车结构，或者干脆分成两个方法，一个返回深复制的结构，一个返回当前结构，区分使用场景。","like_count":1,"discussions":[{"author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":178406,"discussion_content":"取差集不行吧，newKeyWords中只是从之前的map复制过来的，删除的都不知道是哪个，除非你重新再去数据库捞一遍数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582161541,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179656,"user_name":"Summer  空城","can_delete":false,"product_type":"c1","uid":1337146,"ip_address":"","ucode":"6BDBB70FB6F709","user_header":"https://static001.geekbang.org/account/avatar/00/14/67/3a/0dd9ea02.jpg","comment_is_top":false,"comment_ctime":1582072754,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"5877040050","product_id":100039001,"comment_content":"1，删除key对于clone的对象而言，不会影响之前的对象，所以实现应该不需要变化吧<br>2，return new ArrayList&lt;&gt;(this.items);","like_count":1,"discussions":[{"author":{"id":2220738,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cEGxbibA5qcxV9RfNoWgYuqQ66cLVFkd3nHic1tPhErkKb3saicmgSjJLic0P9aXQ8B867jicib5hSickozRy6xCYuWfQ/132","nickname":"Geek_9dce75","note":"","ucode":"47B9535423000B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328854,"discussion_content":"value删除了影响了，最好是deepclone   第二个问题也是，把getitems里面的内容全部deepclone一下，保证collection里面的item元素也是一份不可变对象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606262013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":357349,"user_name":"简单猫","can_delete":false,"product_type":"c1","uid":1866485,"ip_address":"江西","ucode":"EA027D4C344E25","user_header":"https://static001.geekbang.org/account/avatar/00/1c/7a/f5/54a5084b.jpg","comment_is_top":false,"comment_ctime":1663170510,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663170510","product_id":100039001,"comment_content":"原型模式: 游戏中 <br>角色进入战斗场面后，状态信息 ，有一部分是deep拷贝，有一部分浅拷贝。<br>战斗结束后并不影响人物真实属性。除了血量和蓝","like_count":0},{"had_liked":false,"id":344709,"user_name":"Geek_7e0e83","can_delete":false,"product_type":"c1","uid":2142423,"ip_address":"","ucode":"554DEE2AAAE33C","user_header":"","comment_is_top":false,"comment_ctime":1651733618,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651733618","product_id":100039001,"comment_content":"1.如果数据库可以设计成逻辑删除，那每次进行数据同步的时候，就查看一下逻辑删除的字段是否是删除的状态，如果是就将内存中的hashMap对象进行逻辑删除。如果数据库只支持物理删除，就在对应删除的业务动作上监听，发生了删除关键词的操作就更新对应的hashMap。还有一种方式就是使用cancal，编写监听表删除的语句，执行对应的操作。<br><br>2.返回一个深拷贝的对象，getItems方法我们将整个list进行深拷贝 然后返回","like_count":0},{"had_liked":false,"id":338362,"user_name":"Senble","can_delete":false,"product_type":"c1","uid":1330328,"ip_address":"","ucode":"98A8DC9FF625FD","user_header":"https://static001.geekbang.org/account/avatar/00/14/4c/98/2e916c7e.jpg","comment_is_top":false,"comment_ctime":1647438114,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647438114","product_id":100039001,"comment_content":"问题1：逻辑删除。系统B在更新数据库时不是真实删除数据，而是修改状态，标记被删除。等到A读取数据库的时候，将此部分数据过滤出来，然后更新内存内容即可。","like_count":0},{"had_liked":false,"id":337044,"user_name":"it to learn","can_delete":false,"product_type":"c1","uid":2407402,"ip_address":"","ucode":"B1D3316042BEAD","user_header":"https://static001.geekbang.org/account/avatar/00/24/bb/ea/160e4c38.jpg","comment_is_top":false,"comment_ctime":1646564693,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646564693","product_id":100039001,"comment_content":"1个快速克隆散列表的例子，既讲明白原型模式的基本要点，又体会到了需求变化和或实现发现问题后的代码迭代，老师真是用心了，点个赞！","like_count":0},{"had_liked":false,"id":332808,"user_name":"数学汤家凤","can_delete":false,"product_type":"c1","uid":2029485,"ip_address":"","ucode":"DE84E777C384AD","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f7/ad/4fd4d867.jpg","comment_is_top":false,"comment_ctime":1643661531,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1643661531","product_id":100039001,"comment_content":"这也能成为设计模式？不就实现了一个深度拷贝吗？","like_count":0},{"had_liked":false,"id":331024,"user_name":"theory18","can_delete":false,"product_type":"c1","uid":1339502,"ip_address":"","ucode":"F3C96051F563F8","user_header":"https://static001.geekbang.org/account/avatar/00/14/70/6e/8f9d9fe9.jpg","comment_is_top":false,"comment_ctime":1642383210,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642383210","product_id":100039001,"comment_content":"写时复制cow","like_count":0},{"had_liked":false,"id":320703,"user_name":"charmsongo","can_delete":false,"product_type":"c1","uid":1609051,"ip_address":"","ucode":"4FBEE716E93A1A","user_header":"https://static001.geekbang.org/account/avatar/00/18/8d/5b/383a49e4.jpg","comment_is_top":false,"comment_ctime":1636461352,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636461352","product_id":100039001,"comment_content":"总结<br>1、原型模式的原理与应用<br>\t基于原型来创建对象的方式就叫作原型设计模式（Prototype Design Pattern），简称原型模式。<br>\t最耗时的还是从数据库中取数据的操作。相对于数据库的 IO 操作来说，内存操作和 CPU 计算的耗时都是可以忽略的。<br>2、原型模式的实现方式：深拷贝和浅拷贝<br>\t浅拷贝和深拷贝的区别在于，浅拷贝只会复制索引），不会复制数据。相反，深拷贝不仅仅会复制索引，还会复制数据本身。<br>\t第一种方法：递归拷贝对象<br>\t第二种方法：序列化，再反序列化<br>","like_count":0},{"had_liked":false,"id":320577,"user_name":"静✨","can_delete":false,"product_type":"c1","uid":1658413,"ip_address":"","ucode":"1B33229C206339","user_header":"https://static001.geekbang.org/account/avatar/00/19/4e/2d/06d3f9f5.jpg","comment_is_top":false,"comment_ctime":1636384867,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636384867","product_id":100039001,"comment_content":"想到线程的fork…","like_count":0},{"had_liked":false,"id":319543,"user_name":"Dale","can_delete":false,"product_type":"c1","uid":1242602,"ip_address":"","ucode":"AD19A33FE5EEDF","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/ea/5f046856.jpg","comment_is_top":false,"comment_ctime":1635845521,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635845521","product_id":100039001,"comment_content":"跟 JS 里的“原型”差别还是有点大","like_count":0},{"had_liked":false,"id":314389,"user_name":"bigSheller","can_delete":false,"product_type":"c1","uid":2654280,"ip_address":"","ucode":"BFE786598F174D","user_header":"https://static001.geekbang.org/account/avatar/00/28/80/48/7e93bfab.jpg","comment_is_top":false,"comment_ctime":1632994260,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632994260","product_id":100039001,"comment_content":"问题1：map维护一个版本，当get的对象版本小于当前版本，去检查数据库是否存在。检查完后更新map和版本。这样避免了一次性全量查询数据库去更新","like_count":0},{"had_liked":false,"id":311302,"user_name":"Jiantao","can_delete":false,"product_type":"c1","uid":1163504,"ip_address":"","ucode":"444580EC5EF109","user_header":"https://static001.geekbang.org/account/avatar/00/11/c0/f0/1aabc056.jpg","comment_is_top":false,"comment_ctime":1631162982,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631162982","product_id":100039001,"comment_content":"课堂讨论1: 逻辑删除，不更改数据库中数据。<br>课堂讨论2: 使用深拷贝，复制 items 数据。","like_count":0},{"had_liked":false,"id":308322,"user_name":"Jerry","can_delete":false,"product_type":"c1","uid":2716807,"ip_address":"","ucode":"B110E4FC69DC45","user_header":"https://static001.geekbang.org/account/avatar/00/29/74/87/45531d8b.jpg","comment_is_top":false,"comment_ctime":1629534193,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629534193","product_id":100039001,"comment_content":"这篇没怎么看懂","like_count":0},{"had_liked":false,"id":306555,"user_name":"Geek_Candice","can_delete":false,"product_type":"c1","uid":2475056,"ip_address":"","ucode":"0F2CBCF624F905","user_header":"https://static001.geekbang.org/account/avatar/00/25/c4/30/711b03e5.jpg","comment_is_top":false,"comment_ctime":1628606492,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628606492","product_id":100039001,"comment_content":"通俗易懂的讲，写入时复制技术就是不同进程在访问同一资源的时候，只有更新操作，才会去复制一份新的数据并更新替换，否则都是访问同一个资源。<br>1.优点<br>对于一些读多写少的数据，写入时复制的做法就很不错，例如配置、黑名单、物流地址等变化非常少的数据，这是一种无锁的实现。可以帮我们实现程序更高的并发。<br><br>CopyOnWriteArrayList 并发安全且性能比 Vector 好。Vector 是增删改查方法都加了synchronized 来保证同步，但是每个方法执行的时候都要去获得锁，性能就会大大下降，而 CopyOnWriteArrayList 只是在增删改上加锁，但是读不加锁，在读方面的性能就好于 Vector。<br><br>2.缺点<br>数据一致性问题。这种实现只是保证数据的最终一致性，在添加到拷贝数据而还没进行替换的时候，读到的仍然是旧数据。<br><br>内存占用问题。如果对象比较大，频繁地进行替换会消耗内存，从而引发 Java 的 GC 问题，这个时候，我们应该考虑其他的容器，例如 ConcurrentHashMap。","like_count":0},{"had_liked":false,"id":296790,"user_name":"JKwar","can_delete":false,"product_type":"c1","uid":1047466,"ip_address":"","ucode":"B733CA24D5701F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/aa/01fedf6c.jpg","comment_is_top":false,"comment_ctime":1623161407,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1623161407","product_id":100039001,"comment_content":"课堂讨论1:逻辑删除，不更改数据库中数据。<br>课堂讨论2: 使用深拷贝，复制 items 数据。","like_count":0},{"had_liked":false,"id":291676,"user_name":"Gandalf","can_delete":false,"product_type":"c1","uid":1267039,"ip_address":"","ucode":"3881987167B713","user_header":"https://static001.geekbang.org/account/avatar/00/13/55/5f/5dc667c3.jpg","comment_is_top":false,"comment_ctime":1620428815,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1620428815","product_id":100039001,"comment_content":"问题1：增加version版本号逻辑删除<br>问题2：return new Arraylist&lt;&gt;(this.items);","like_count":0,"discussions":[{"author":{"id":2731028,"avatar":"https://static001.geekbang.org/account/avatar/00/29/ac/14/a8ff8fec.jpg","nickname":"慕言","note":"","ucode":"4918FA682F3895","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572635,"discussion_content":"问题2这样做还是无法解决问题，因为这样写是浅拷贝","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652879356,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":287041,"user_name":"俺能学个啥","can_delete":false,"product_type":"c1","uid":1026742,"ip_address":"","ucode":"30740C5B58774C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/aa/b6/46a5bbf3.jpg","comment_is_top":false,"comment_ctime":1617757253,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617757253","product_id":100039001,"comment_content":"我理解删除可以用一个字段标识删除，这样统一多一次判断，删除就remove","like_count":0},{"had_liked":false,"id":283686,"user_name":"Yeyw","can_delete":false,"product_type":"c1","uid":1463740,"ip_address":"","ucode":"C9D20DB91C3BE5","user_header":"https://static001.geekbang.org/account/avatar/00/16/55/bc/fad0090b.jpg","comment_is_top":false,"comment_ctime":1615885001,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615885001","product_id":100039001,"comment_content":"1. 当前版本的 进行更新修改删除，仅在内存做，增加相应字段，等刷新的时候再同步到数据库，但是有个问题，宕机数据都没了。<br>2. 深拷贝就完事了","like_count":0},{"had_liked":false,"id":269776,"user_name":"cw","can_delete":false,"product_type":"c1","uid":1264296,"ip_address":"","ucode":"82A6B50462F9F9","user_header":"https://static001.geekbang.org/account/avatar/00/13/4a/a8/b7e36dd2.jpg","comment_is_top":false,"comment_ctime":1608782332,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608782332","product_id":100039001,"comment_content":"原型模式 本质上是为了解决大量对象copy时所带来的的性能影响 ","like_count":0},{"had_liked":false,"id":268421,"user_name":"郑大钱","can_delete":false,"product_type":"c1","uid":1503067,"ip_address":"","ucode":"114CF48056880E","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/5b/ff28088f.jpg","comment_is_top":false,"comment_ctime":1608190621,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608190621","product_id":100039001,"comment_content":"原型模式就是用已有的对象，通过复制的方式创建一个新的的对象。这种模式针对的是对象初始化很复杂或资源消耗特别大的情况。<br>早期在网上看到一种设计模式，就想用它来重构代码，结果没有什么优化效果。还自欺欺人的说代码变整洁了，其实只是代码变熟悉了，感动的只有我自己。<br>用序列化的方式实现深拷贝，是我完全没有想到的过方式，mark！","like_count":0},{"had_liked":false,"id":265255,"user_name":"阿骨打","can_delete":false,"product_type":"c1","uid":2122539,"ip_address":"","ucode":"35EADA5550162A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","comment_is_top":false,"comment_ctime":1606830830,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606830830","product_id":100039001,"comment_content":"我又看了下hashmap的clone()， 不知道我理解的对不<br>clone（）时，生成了新的node[ ]，并且把原来的node[]中的node全部拿出来，创建了新的Node<br>每个新node(oldKey,oldValue, next:null ),也就是说 并不是每个node都是 引用地址，<br>只有新node中的key-value用的是 老数据引用地址，而 next 非常关键，是新做的，<br>所以hashmap clone() 之后，新增 删除 都不会影响到老的map","like_count":0},{"had_liked":false,"id":260979,"user_name":"间接性失忆患者","can_delete":false,"product_type":"c1","uid":2143290,"ip_address":"","ucode":"73593933070CB9","user_header":"https://static001.geekbang.org/account/avatar/00/20/b4/3a/53b27094.jpg","comment_is_top":false,"comment_ctime":1605166122,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1605166122","product_id":100039001,"comment_content":"有个疑问：<br>  if (newKeyWords.containsKey(searchWord.keyWord)) {<br>                &#47;&#47;删除浅拷贝中的索引<br>                newKeyWords.remove(searchWord.keyWord);<br>            }<br>这一步是不是可以不需要？ <br> newKeyWords.put(searchWord.keyWord, searchWord);<br>后面放入实例，实际上已经将地址覆盖了吧","like_count":0,"discussions":[{"author":{"id":2731028,"avatar":"https://static001.geekbang.org/account/avatar/00/29/ac/14/a8ff8fec.jpg","nickname":"慕言","note":"","ucode":"4918FA682F3895","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572636,"discussion_content":"我也觉得可以不用写remove这句","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652879402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":254151,"user_name":"时光守护者-基兰","can_delete":false,"product_type":"c1","uid":1554995,"ip_address":"","ucode":"F0B0887B1979D2","user_header":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","comment_is_top":false,"comment_ctime":1603072073,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603072073","product_id":100039001,"comment_content":"刚才理解的有问题，不会影响版本一致","like_count":0},{"had_liked":false,"id":254139,"user_name":"时光守护者-基兰","can_delete":false,"product_type":"c1","uid":1554995,"ip_address":"","ucode":"F0B0887B1979D2","user_header":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","comment_is_top":false,"comment_ctime":1603071006,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603071006","product_id":100039001,"comment_content":"浅拷贝方式当newKeywords中的需要更新的SearchWord对象没有替换完，currentKeywords中的数据也会存在版本不一致吧？","like_count":0},{"had_liked":false,"id":244617,"user_name":"飞翔","can_delete":false,"product_type":"c1","uid":1065986,"ip_address":"","ucode":"3D3D10273BED18","user_header":"https://static001.geekbang.org/account/avatar/00/10/44/02/5c8e4b81.jpg","comment_is_top":false,"comment_ctime":1598596483,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1598596483","product_id":100039001,"comment_content":"1  数据库添加一个字段 is_deleted 标识是否删除，获取大于上次更新时间后所有变更对象，查看字段来查看是否是被删除的对象<br>2 完全复制整个item对象，这样外部可更改item的价格，但是不影响shoppingcar 本身的计价","like_count":0},{"had_liked":false,"id":243920,"user_name":"卢治东","can_delete":false,"product_type":"c1","uid":1879151,"ip_address":"","ucode":"6A003597749EA0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJQicDg3XUa0r3foqfOiaegicaGtGAPbt81sYkzNibLic8Dtp1f51f1zDg7fhTyJZZIzXBiafC50Flb6nkA/132","comment_is_top":false,"comment_ctime":1598326884,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1598326884","product_id":100039001,"comment_content":"最后这个demo的remove有必要吗？<br>public class Demo {<br>  private HashMap&lt;String, SearchWord&gt; currentKeywords=new HashMap&lt;&gt;();<br>  private long lastUpdateTime = -1;<br><br>  public void refresh() {<br>    &#47;&#47; Shallow copy<br>    HashMap&lt;String, SearchWord&gt; newKeywords = (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();<br><br>    &#47;&#47; 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中<br>    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);<br>    long maxNewUpdatedTime = lastUpdateTime;<br>    for (SearchWord searchWord : toBeUpdatedSearchWords) {<br>      if (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) {<br>        maxNewUpdatedTime = searchWord.getLastUpdateTime();<br>      }<br>      if (newKeywords.containsKey(searchWord.getKeyword())) {<br>        newKeywords.remove(searchWord.getKeyword());<br>      }<br>      newKeywords.put(searchWord.getKeyword(), searchWord);<br>    }<br><br>    lastUpdateTime = maxNewUpdatedTime;<br>    currentKeywords = newKeywords;<br>  }<br><br>  private List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) {<br>    &#47;&#47; TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据<br>    return null;<br>  }<br>}","like_count":0,"discussions":[{"author":{"id":1577580,"avatar":"https://static001.geekbang.org/account/avatar/00/18/12/6c/61a598e9.jpg","nickname":"苏暮沉觞","note":"","ucode":"532B816D4EF47B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":128257,"discussion_content":"构造参数里面用this，是为了声明是给类中的属性赋值，在老师的构造器代码中，这个this不写也可以。在一个类的方法体中，一般是不会主动声明this的，除非传入参数中存在同样的参数名或者方法体中创建了同名的局部变量，这时候才会特意使用this。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578623793,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":232701,"user_name":"改名不换人","can_delete":false,"product_type":"c1","uid":1118242,"ip_address":"","ucode":"7E25577829FA0F","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/22/910f705c.jpg","comment_is_top":false,"comment_ctime":1594092748,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594092748","product_id":100039001,"comment_content":"1 数据库中的数据 增加逻辑删除状态<br>2 getItems得到的对象通过深拷贝方式，返回拷贝后的新对象，这样即使对items的list中元素的修改也不会影响到原有的集合中的items","like_count":0},{"had_liked":false,"id":232212,"user_name":"南北少卿","can_delete":false,"product_type":"c1","uid":1018958,"ip_address":"","ucode":"DFCC59F2BBD8CE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/4e/b81969fa.jpg","comment_is_top":false,"comment_ctime":1593921933,"is_pvip":false,"replies":[{"id":"85754","content":"你联系一下上下文看下，都有讲到的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1593994347,"ip_address":"","comment_id":232212,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1593921933","product_id":100039001,"comment_content":"如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同） ...<br>这句话没有想明白","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476711,"discussion_content":"那个异常可以是自定义的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575424785,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1714156,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/27/ec/9f6e999d.jpg","nickname":"言","note":"","ucode":"483EE23D2EA2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":71493,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575425386,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":232193,"user_name":"唯她命","can_delete":false,"product_type":"c1","uid":1240398,"ip_address":"","ucode":"8F687E8D306840","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/4e/ef406442.jpg","comment_is_top":false,"comment_ctime":1593916116,"is_pvip":false,"replies":[{"id":"86252","content":"lastUpdateTime  maxNewUpdatedTime   searchWord.getLastUpdateTime()三者的关系你理一理","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1594388087,"ip_address":"","comment_id":232193,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1593916116","product_id":100039001,"comment_content":"<br>public class Demo {<br>  private ConcurrentHashMap&lt;String, SearchWord&gt; currentKeywords = new ConcurrentHashMap&lt;&gt;();<br>  private long lastUpdateTime = -1;<br><br>  public void refresh() {<br>    &#47;&#47; 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到currentKeywords中<br>    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);<br>    long maxNewUpdatedTime = lastUpdateTime;<br>    for (SearchWord searchWord : toBeUpdatedSearchWords) {<br>      if (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) {<br>        maxNewUpdatedTime = searchWord.getLastUpdateTime();<br>      }<br>}<br><br>代码有问题啊，   List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);<br>toBeUpdatedSearchWords里的数据是改过的数据，时间都大于lastUpdateTime<br>那为啥下面还要searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime？？？？<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500554,"discussion_content":"lastUpdateTime  maxNewUpdatedTime   searchWord.getLastUpdateTime()三者的关系你理一理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594388087,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289781,"discussion_content":"因为要用打擂法去寻找并更新maxNewUpdatedTime","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594211010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229791,"user_name":"maybe","can_delete":false,"product_type":"c1","uid":1475528,"ip_address":"","ucode":"93D160F617E750","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/c8/5ce842f6.jpg","comment_is_top":false,"comment_ctime":1593146327,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1593146327","product_id":100039001,"comment_content":"第一个问题：数据库里做一个删除标记，根据删除标记删除相应的key<br>第二个问题：返回深度拷贝对象，你爱咋改咋改，不影响原来的","like_count":0},{"had_liked":false,"id":227145,"user_name":"李德政","can_delete":false,"product_type":"c1","uid":1023885,"ip_address":"","ucode":"3AC49F5671485C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9f/8d/d725d32c.jpg","comment_is_top":false,"comment_ctime":1592298008,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592298008","product_id":100039001,"comment_content":"再一次感受到计算机原理都是想通的：<br>1. 老师举的例子中，使用的原型模式思想，和Linux 的CopyonWrite一模一样。联想到Redis的RDS备份时，就是采用的这种思路<br>2. 在Python里面有一个copy模块，copy模块有copy函数，也有deepcopy函数，其中copy用来浅拷贝，deepcopy是用来实现深拷贝。","like_count":0},{"had_liked":false,"id":222310,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1590743192,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590743192","product_id":100039001,"comment_content":"深拷贝的总结：<br>1 递归拷贝数据<br>2 使用序列化+反序列化<br>3优化： 可以先采用浅拷贝的方式创建 newKeywords。对于需要更新的 SearchWord 对象，我们再使用深度拷贝的方式创建一份新的对象，替换 newKeywords 中的老对象。毕竟需要更新的数据是很少的。这种方式即利用了浅拷贝节省时间、空间的优点，又能保证 currentKeywords 中的中数据都是老版本的数据。","like_count":0},{"had_liked":false,"id":221504,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1590510601,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590510601","product_id":100039001,"comment_content":"原型模式在对象实体更新的时候用的比较多，这样可以避免一个一个比较字段哪些字段的值变化了","like_count":0},{"had_liked":false,"id":220838,"user_name":"简单猫","can_delete":false,"product_type":"c1","uid":1866485,"ip_address":"","ucode":"EA027D4C344E25","user_header":"https://static001.geekbang.org/account/avatar/00/1c/7a/f5/54a5084b.jpg","comment_is_top":false,"comment_ctime":1590328504,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590328504","product_id":100039001,"comment_content":"一：searchword 对象中加入状态字段 modify表示发生了修改的 del表示要输出的，设定一个阈值(或任务空闲) 把这些有状态变更的一次更新到库中。<br>二：原型模式 深拷贝一分对象 即可。原型永远不会被修改，调用get的时候再深次拷贝 只要不修改原型 新拷贝的对象都一样 从而实现了不修改的目标。例如 游戏中的状态信息，退出战队就恢复原始状态 就能用这个模式实现","like_count":0},{"had_liked":false,"id":212530,"user_name":"悠游","can_delete":false,"product_type":"c1","uid":1222834,"ip_address":"","ucode":"4FDDDDF29AE3F0","user_header":"https://static001.geekbang.org/account/avatar/00/12/a8/b2/998448ca.jpg","comment_is_top":false,"comment_ctime":1588142549,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588142549","product_id":100039001,"comment_content":"想起了以前的一个项目，由于原始大对象需要缓存下来，因此使用深拷贝进行对象复制，通过Gson序列化再反序列化，因此非常消耗CPU，线上专门堆了好几台服务器，今天学了才发现可以使用原型模式直接复制对象内存，不禁流下了悔恨的泪水....","like_count":0},{"had_liked":false,"id":212221,"user_name":"zhengyu.nie","can_delete":false,"product_type":"c1","uid":1541669,"ip_address":"","ucode":"FFE0377D323E46","user_header":"https://static001.geekbang.org/account/avatar/00/17/86/25/25ded6c3.jpg","comment_is_top":false,"comment_ctime":1588076310,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1588076310","product_id":100039001,"comment_content":"Collections.unmodifiableList换成com.google.guava.ImmutableList#copyOf","like_count":0},{"had_liked":false,"id":207089,"user_name":"慢动作","can_delete":false,"product_type":"c1","uid":1133945,"ip_address":"","ucode":"62C944F4A4D8AC","user_header":"https://static001.geekbang.org/account/avatar/00/11/4d/79/803537db.jpg","comment_is_top":false,"comment_ctime":1587005121,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1587005121","product_id":100039001,"comment_content":"数据库如果是逻辑删除，只要从新map移除就好；如果是物理删除，查询增量怎么做？","like_count":0,"discussions":[{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289783,"discussion_content":"两个嵌套循环取差集","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594211224,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206061,"user_name":"墨鱼","can_delete":false,"product_type":"c1","uid":1022720,"ip_address":"","ucode":"8FB5E4DCB8A024","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/00/654be3f7.jpg","comment_is_top":false,"comment_ctime":1586782526,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586782526","product_id":100039001,"comment_content":"浅拷贝是只给新创建的变量一个引用，深拷贝是既给引用也给数据。<br><br><br>前端实现浅拷贝的方法：<br><br>1.object.assign 方法<br>2.= 赋值<br><br>前端深拷贝的方法：<br><br>1.递归拷贝所有层级的属性<br>2.JSON 序列化和反序列化<br>3.Reflect 犯法<br>4.slice方法实现数组的深拷贝<br>5.concat 实现数组的深拷贝","like_count":0},{"had_liked":false,"id":203321,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1586171796,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1586171796","product_id":100039001,"comment_content":"感觉这就是一门语言的语法特性而已，为什么也提炼出一种模式呢。","like_count":0},{"had_liked":false,"id":202224,"user_name":"秋风画扇","can_delete":false,"product_type":"c1","uid":1132356,"ip_address":"","ucode":"5BCBC1422C51EC","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/44/964aa665.jpg","comment_is_top":false,"comment_ctime":1585926526,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585926526","product_id":100039001,"comment_content":"1.更新的关键要知道更新谁？删除的对象从数据库查不出来，就没法办进行更新，这里采取逻辑删除既可。实际生产环境也应该只能逻辑删除，这符合生产的要求<br><br>2.Collections.unmodifiableList方法返回的对象只能保证list本身不变，但不能保证内部引用类型的对象不被修改，这里只需要实现深拷贝把内容也拷贝一份，让返回的list“私有”这些对象既可","like_count":0},{"had_liked":false,"id":202156,"user_name":"小小代码","can_delete":false,"product_type":"c1","uid":1290642,"ip_address":"","ucode":"F3D4E2C23FC9BD","user_header":"https://static001.geekbang.org/account/avatar/00/13/b1/92/f3dabcb1.jpg","comment_is_top":false,"comment_ctime":1585911802,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585911802","product_id":100039001,"comment_content":"问题2的解决方法，遍历深拷贝<br>public List&lt;ShoppingCartItem&gt; getItems() {<br>    List&lt;ShoppingCartItem&gt; newItems = new ArrayList&lt;&gt;(this.items.size);<br>    for(ShoppingCartItem oldItem: this.items) {<br>    \tnewItems.add(new ShoppingCartItem(oldItem));<br>    }<br>\treturn Collections.unmodifiableList(newItems); <br>}","like_count":0},{"had_liked":false,"id":201416,"user_name":"DullBird","can_delete":false,"product_type":"c1","uid":1110494,"ip_address":"","ucode":"80E2FD5F9687CB","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/de/3ebcbb3f.jpg","comment_is_top":false,"comment_ctime":1585786345,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585786345","product_id":100039001,"comment_content":"1.逻辑删除，带来的问题就是查询需要加逻辑值deleted=false。<br>2.深拷贝一个对象","like_count":0},{"had_liked":false,"id":201306,"user_name":"布凡","can_delete":false,"product_type":"c1","uid":1202465,"ip_address":"","ucode":"346FCD332F8BFA","user_header":"https://static001.geekbang.org/account/avatar/00/12/59/21/d2efde18.jpg","comment_is_top":false,"comment_ctime":1585748282,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1585748282","product_id":100039001,"comment_content":"请教：有人可以帮忙解答一下吗？currentKeywords.replace(searchWord.getKeyword(), searchWord); 中的searchWord.getKeyword()是什么用法，SearchWord这个对象是java中特有的？","like_count":0,"discussions":[{"author":{"id":1314724,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0f/a4/0b49469f.jpg","nickname":"木子00","note":"","ucode":"8F78CA722EB29B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278827,"discussion_content":"是没有写出SearchWord类，意思懂就行了。（SearchWord不是jdk中的类）","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591239114,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1202465,"avatar":"https://static001.geekbang.org/account/avatar/00/12/59/21/d2efde18.jpg","nickname":"布凡","note":"","ucode":"346FCD332F8BFA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1314724,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0f/a4/0b49469f.jpg","nickname":"木子00","note":"","ucode":"8F78CA722EB29B","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":278996,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591270530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":278827,"ip_address":""},"score":278996,"extra":""}]}]},{"had_liked":false,"id":196053,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1585232635,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1585232635","product_id":100039001,"comment_content":"map为什么要remove() 呢？直接put，替换原有对象不就好了么？","like_count":0,"discussions":[{"author":{"id":1087243,"avatar":"https://static001.geekbang.org/account/avatar/00/10/97/0b/a943bcb3.jpg","nickname":"zhou","note":"","ucode":"E1CE8575B3F106","race_medal":3,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297837,"discussion_content":"有点道理 代码确实感觉可以这样优化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597070175,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187470,"user_name":"ssrsdzry","can_delete":false,"product_type":"c1","uid":1241576,"ip_address":"","ucode":"89BCFA6A1997E5","user_header":"https://static001.geekbang.org/account/avatar/00/12/f1/e8/d2e88567.jpg","comment_is_top":false,"comment_ctime":1584118085,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584118085","product_id":100039001,"comment_content":"第一个问题应该要看是否允许加字段标记删除。允许的话和更改的逻辑相似。如果不允许，那整行数据都删除掉了，只能全扫描数据库中的主键，然后和map中的数据比较。<br><br>第二个问题大家都说是返回深拷贝，这个是可以。不过我好奇工作中真的这么写代码吗？因为很返回一个list之类的时候还是很多的。感觉都是靠编程习惯，就是不去更改输入，要更改也是自己copy一份新的对象。这个自己也不是很熟，确实是需要向有经验的学习一下。希望大家多说说实际经验。","like_count":0},{"had_liked":false,"id":187340,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1584087624,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584087624","product_id":100039001,"comment_content":"题目2用深拷贝也是可以，但是数据也可以修改；因此考虑使用建造模式Build，对象不提供set方法，只提供get方法，通过build构造出Item，外界无法修改item","like_count":0},{"had_liked":false,"id":187332,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1584085318,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584085318","product_id":100039001,"comment_content":"看了一下java8的hashmap的clone的源代码，发现老师发的hashmap的浅拷贝图画错了吧，代码里没有复制Node引用，而是创建新的Node,并复制原Node上的Key和Value引用地址。<br> public Object clone() {<br>        HashMap&lt;K,V&gt; result;<br>        try {<br>            result = (HashMap&lt;K,V&gt;)super.clone();<br>        } catch (CloneNotSupportedException e) {<br>            &#47;&#47; this shouldn&#39;t happen, since we are Cloneable<br>            throw new InternalError(e);<br>        }<br>        result.reinitialize();<br>        result.putMapEntries(this, false);<br>        return result;<br>    }<br><br><br> final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) {<br>        int s = m.size();<br>        if (s &gt; 0) {<br>            if (table == null) { &#47;&#47; pre-size<br>                float ft = ((float)s &#47; loadFactor) + 1.0F;<br>                int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?<br>                         (int)ft : MAXIMUM_CAPACITY);<br>                if (t &gt; threshold)<br>                    threshold = tableSizeFor(t);<br>            }<br>            else if (s &gt; threshold)<br>                resize();<br>            for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) {<br>                K key = e.getKey();<br>                V value = e.getValue();<br>                putVal(hash(key), key, value, false, evict);<br>            }<br>        }<br>    }","like_count":0},{"had_liked":false,"id":186224,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1583804683,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583804683","product_id":100039001,"comment_content":"1.对于删除来说,我们需要保证版本一直,还要保证一定效率的时候,如果按照之前的实现,我们就必须进行反查找,也就是获取到所有数据库中的数据,然后利用我们现有的Map去比对数据库中,查看哪些已经不再存在了,这样效率极其的低下,所以建议是在数据库中加入一个del_flag的字段,来表示逻辑删除,并利用逻辑删除来进行相关的更新操作<br>2.对于2,能不能返回一个流对象,让调用者去反序列化,或者进行第一种方式的递归拷贝,获取新的对象","like_count":0},{"had_liked":false,"id":185334,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1583563618,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583563618","product_id":100039001,"comment_content":"基于原型对象拷贝获得对象，称为原型模式。","like_count":0},{"had_liked":false,"id":183318,"user_name":"SKY","can_delete":false,"product_type":"c1","uid":1083870,"ip_address":"","ucode":"10C3CB831974AE","user_header":"https://static001.geekbang.org/account/avatar/00/10/89/de/7bf4c3a3.jpg","comment_is_top":false,"comment_ctime":1582993337,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"1582993337","product_id":100039001,"comment_content":"没动最后一个方法的newKeywords.remove(searchWord.getKeyword());newKeywords是通过currentKeywords.clone()浅拷贝出来的，对newKeywords使用remove方法难道不会影响currentKeywords？","like_count":0},{"had_liked":false,"id":181549,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1582557665,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582557665","product_id":100039001,"comment_content":"第一问从我的工作经验来看 抛开设计模式 程序一启动加载数据看中的内容，如果有删除和更新或者新增直接操作内存 再5秒钟或者10秒钟等等进行存盘<br>第二问 采用深拷贝，避免共享同一个对象的问题","like_count":0},{"had_liked":false,"id":181083,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1582471844,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1582471844","product_id":100039001,"comment_content":"<br>课堂讨论:<br><br>1. 在今天的应用场景中，如果不仅往数据库中添加和更新关键词，还删除关键词，这种情况下，又该如何实现呢？<br><br>   方式一: 首先使用shallow copy得到一份旧的Map的copy, 然后从db读取新的Map. 对新旧两份Map取交集.<br><br>   这里着重说下取交集的方式: 使用Iterator遍历旧Map的copy的key, 如果新Map中不包含该key,则删除.<br><br>   <br><br>   方式二: 直接使用deep copy, 简单粗暴不讲道理.<br><br>   <br><br>2. 在第 7 讲中，为了让 ShoppingCart 的 getItems() 方法返回不可变对象，我们如下来实现代码。当时，我们指出这样的实现思路还是有点问题。因为当调用者通过 ShoppingCart 的 getItems() 获取到 items 之后，我们还是可以修改容器中每个对象（ShoppingCartItem）的数据。学完本节课之后，现在你有没有解决方法了呢？<br><br>   getItems()使用deep copy返回items的视图.","like_count":0,"discussions":[{"author":{"id":1358045,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b8/dd/37726c34.jpg","nickname":"小马哥","note":"","ucode":"B2C0FF38F8C9BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386518,"discussion_content":"is-a是抽取相同的东西到父类, 自下而上;\nhas-a是按照接口定义, 必须在子类或者实现中实现约定的行为, 自上而下;\n前者要求共同点抽取, 后者要求必须满足.仅此而已, 体会一下抽象类和接口的存在意义, 而不用扣字面意思.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627625504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1577580,"avatar":"https://static001.geekbang.org/account/avatar/00/18/12/6c/61a598e9.jpg","nickname":"苏暮沉觞","note":"","ucode":"532B816D4EF47B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":128260,"discussion_content":"我的理解是is a主要针对属性的继承，has a 代表着功能的声明。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578624263,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180957,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1582449252,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582449252","product_id":100039001,"comment_content":"设计模式_47:<br># 作业 <br>1. 取交集<br>2. 返回一个必要数据深拷贝的集合<br>","like_count":0},{"had_liked":false,"id":180838,"user_name":"乾坤瞬间","can_delete":false,"product_type":"c1","uid":1683130,"ip_address":"","ucode":"15BDCF29CBF8EB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","comment_is_top":false,"comment_ctime":1582426378,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582426378","product_id":100039001,"comment_content":"1，使用墓碑标记，删除a系统中的数据，并补job进行数据的删除<br>2，诋递归遍历进行深度copy","like_count":0},{"had_liked":false,"id":179932,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1018370,"ip_address":"","ucode":"7A488CC6FE15E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","comment_is_top":false,"comment_ctime":1582123204,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582123204","product_id":100039001,"comment_content":"原型模式是一种从“拷贝”的角度来创建对象的方式，以实现节省时间的目的。原型模式有两种实现方式：浅拷贝与深拷贝。理解其应用场景：对象创建成本大，同一个类不同对象之间差别不大。","like_count":0},{"had_liked":false,"id":179929,"user_name":"我来也","can_delete":false,"product_type":"c1","uid":1205253,"ip_address":"","ucode":"773D6104F56767","user_header":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","comment_is_top":false,"comment_ctime":1582123034,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582123034","product_id":100039001,"comment_content":"思考题2:<br>即使是深拷贝，也是可以修改的，只是修改的不是原数据而已。<br><br>我对java语法不熟，不知道可否递归的使用  Collections.unmodifiableList 类似的方式，构建一个新的深拷贝对象。然后再返回这个对象的不可修改副本。<br><br>这样这个对象从里到外都是不可修改的属性了。","like_count":0},{"had_liked":false,"id":179772,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1582095883,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582095883","product_id":100039001,"comment_content":"原来拷贝可以这样操作！佩服小争哥算法与数据结构用的6！","like_count":0},{"had_liked":false,"id":179747,"user_name":"，","can_delete":false,"product_type":"c1","uid":1701867,"ip_address":"","ucode":"A5543C8DFEB198","user_header":"https://static001.geekbang.org/account/avatar/00/19/f7/eb/e7127bb8.jpg","comment_is_top":false,"comment_ctime":1582090136,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1582090136","product_id":100039001,"comment_content":"问题1:<br>1.设置标记位,&quot;使用中&quot;,&quot;弃用&quot;,&quot;已删除&quot;等,检查到标记为&quot;弃用&quot;的数据时,删除map里的数据同时修改标记位为&quot;已删除&quot;,扫描数据库里更新的数据时增加检索条件&quot;使用中&quot;<br>2.每次数据库都全量扫描,拿到标记位为&quot;使用中&quot;的数据,直接替换map<br>3.删除数据时同时删除数据库和map里的数据<br>  个人认为方法1和方法3都很合适,方法二对数据库IO操作量比较大,不太适合<br>问题2:<br>返回深克隆对象即可","like_count":0},{"had_liked":false,"id":179744,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1582088813,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582088813","product_id":100039001,"comment_content":"1.逻辑删除的话，代码都不用改。物理删除的话，我觉得在删除时联动清除map的缓存可行（单进程，分布式就得引入一个外部存储，告知所有节点删除某个缓存）。<br><br><br>2.根据业务场景，采用cow写时复制。提供只读的列表返回和写时的复制列表的返回两个方法。","like_count":0},{"had_liked":false,"id":179719,"user_name":"webmin","can_delete":false,"product_type":"c1","uid":1047014,"ip_address":"","ucode":"98B0CA882454E8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/e6/47742988.jpg","comment_is_top":false,"comment_ctime":1582083475,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1582083475","product_id":100039001,"comment_content":"问题一：<br>       for (SearchWord searchWord : toBeUpdatedSearchWords) {<br>        ...<br>        }<br>        Set&lt;String&gt; toBeUpdatedKeys = new HashSet&lt;&gt;();<br>        toBeUpdatedSearchWords.forEach((k) -&gt; toBeUpdatedKeys.add(k.getKeyword()));<br>        List&lt;String&gt; removeList = newKeywords.keySet().stream().filter((key) -&gt; !toBeUpdatedKeys.contains(key)).collect(Collectors.toList());<br>        removeList.forEach(newKeywords::remove);<br>问题二：<br>返回不可变对象，方法有两个<br>方法1：语言自带或第三方库的不可变对象机制，如：Java可以使用第三方库Guava的不可变集合；<br>方法2：返回一个深拷贝对象；","like_count":0,"discussions":[{"author":{"id":1577580,"avatar":"https://static001.geekbang.org/account/avatar/00/18/12/6c/61a598e9.jpg","nickname":"苏暮沉觞","note":"","ucode":"532B816D4EF47B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":128262,"discussion_content":"《Java8 实战》中的观点是为了在我们给接口添加方法时，不会给之前继承的类造成影响（例如你继承了第三方的某个接口，提供第三方接口的人在修改对应的接口时，肯定是希望他修改以后对你没有影响）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578624494,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179670,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1582075757,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582075757","product_id":100039001,"comment_content":"1.用一个标记位表示被删除<br>2.返回一个深拷贝对象","like_count":0},{"had_liked":false,"id":179668,"user_name":"Panmax","can_delete":false,"product_type":"c1","uid":1004871,"ip_address":"","ucode":"9D65E3B84C5519","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/47/d217c45f.jpg","comment_is_top":false,"comment_ctime":1582075316,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1582075316","product_id":100039001,"comment_content":"文章中的最后一种方案：「先采用浅拷贝的方式创建 newKeywords。对于需要更新的 SearchWord 对象，再使用深度拷贝的方式创建一份新的对象，替换 newKeywords 中的老对象。」<br><br>是不是可以理解为是一种 Copy On Write 的优化策略","like_count":0,"discussions":[{"author":{"id":1577580,"avatar":"https://static001.geekbang.org/account/avatar/00/18/12/6c/61a598e9.jpg","nickname":"苏暮沉觞","note":"","ucode":"532B816D4EF47B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":128266,"discussion_content":"要给一个旧的接口添加方法是很麻烦的事，因为其他实现该接口必须实现新增的接口。如果是发布给其他人用的接口，那这对有些用户来说就是个灾难。而且接口中只能添加方法签名，不能想抽象类一样提供部分方法的实现，因此引入了默认方法。可以看一下《Java8 实战》中专门将默认方法的那一章。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578624642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1153455,"avatar":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","nickname":"饭粒","note":"","ucode":"4C3220B0D43997","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1577580,"avatar":"https://static001.geekbang.org/account/avatar/00/18/12/6c/61a598e9.jpg","nickname":"苏暮沉觞","note":"","ucode":"532B816D4EF47B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":129341,"discussion_content":"感谢🙏","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578674174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":128266,"ip_address":""},"score":129341,"extra":""}]}]},{"had_liked":false,"id":179667,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1582075272,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582075272","product_id":100039001,"comment_content":"想到了linux进程的克隆，c++的拷贝构造函数都是一种原型模式的使用","like_count":0,"discussions":[{"author":{"id":1577580,"avatar":"https://static001.geekbang.org/account/avatar/00/18/12/6c/61a598e9.jpg","nickname":"苏暮沉觞","note":"","ucode":"532B816D4EF47B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":128268,"discussion_content":"被protected 修饰的构造函数只允许可以被子类，或同package下类使用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578624731,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179631,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1582042225,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582042225","product_id":100039001,"comment_content":"沙发","like_count":0}]}