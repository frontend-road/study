{"id":295812,"title":"25 | 缓存异常（上）：如何解决缓存和数据库的数据不一致问题？","content":"<p>你好，我是蒋德钧。</p><p>在实际应用Redis缓存时，我们经常会遇到一些异常问题，概括来说有4个方面：缓存中的数据和数据库中的不一致；缓存雪崩；缓存击穿和缓存穿透。</p><p>只要我们使用Redis缓存，就必然会面对缓存和数据库间的一致性保证问题，这也算是Redis缓存应用中的“必答题”了。最重要的是，如果数据不一致，那么业务应用从缓存中读取的数据就不是最新数据，这会导致严重的错误。比如说，我们把电商商品的库存信息缓存在Redis中，如果库存信息不对，那么业务层下单操作就可能出错，这当然是不能接受的。所以，这节课我就重点和你聊聊这个问题。关于缓存雪崩、穿透和击穿等问题，我会在下一节课向你介绍。</p><p>接下来，我们就来看看，缓存和数据库之间的数据不一致是怎么引起的。</p><h2>缓存和数据库的数据不一致是如何发生的？</h2><p>首先，我们得清楚“数据的一致性”具体是啥意思。其实，这里的“一致性”包含了两种情况：</p><ul>\n<li>缓存中有数据，那么，缓存的数据值需要和数据库中的值相同；</li>\n<li>缓存中本身没有数据，那么，数据库中的值必须是最新值。</li>\n</ul><p>不符合这两种情况的，就属于缓存和数据库的数据不一致问题了。不过，当缓存的读写模式不同时，缓存数据不一致的发生情况不一样，我们的应对方法也会有所不同，所以，我们先按照缓存读写模式，来分别了解下不同模式下的缓存不一致情况。我在<a href=\"https://time.geekbang.org/column/article/293929\">第23讲</a>中讲过，根据是否接收写请求，我们可以把缓存分成读写缓存和只读缓存。</p><!-- [[[read_end]]] --><p>对于读写缓存来说，如果要对数据进行增删改，就需要在缓存中进行，同时还要根据采取的写回策略，决定是否同步写回到数据库中。</p><ul>\n<li>同步直写策略：写缓存时，也同步写数据库，缓存和数据库中的数据一致；</li>\n<li>异步写回策略：写缓存时不同步写数据库，等到数据从缓存中淘汰时，再写回数据库。使用这种策略时，如果数据还没有写回数据库，缓存就发生了故障，那么，此时，数据库就没有最新的数据了。</li>\n</ul><p>所以，对于读写缓存来说，要想保证缓存和数据库中的数据一致，就要采用同步直写策略。不过，需要注意的是，如果采用这种策略，就需要同时更新缓存和数据库。所以，我们要在业务应用中使用事务机制，来保证缓存和数据库的更新具有原子性，也就是说，两者要不一起更新，要不都不更新，返回错误信息，进行重试。否则，我们就无法实现同步直写。</p><p>当然，在有些场景下，我们对数据一致性的要求可能不是那么高，比如说缓存的是电商商品的非关键属性或者短视频的创建或修改时间等，那么，我们可以使用异步写回策略。</p><p>下面我们再来说说只读缓存。对于只读缓存来说，如果有数据新增，会直接写入数据库；而有数据删改时，就需要把只读缓存中的数据标记为无效。这样一来，应用后续再访问这些增删改的数据时，因为缓存中没有相应的数据，就会发生缓存缺失。此时，应用再从数据库中把数据读入缓存，这样后续再访问数据时，就能够直接从缓存中读取了。</p><p>接下来，我以Tomcat向MySQL中写入和删改数据为例，来给你解释一下，数据的增删改操作具体是如何进行的，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/15/dc/15ae0147459ecc46436f35a0f3e5yydc.jpg?wh=3000*1337\" alt=\"\"></p><p>从图中可以看到，Tomcat上运行的应用，无论是新增（Insert操作）、修改（Update操作）、还是删除（Delete操作）数据X，都会直接在数据库中增改删。当然，如果应用执行的是修改或删除操作，还会删除缓存的数据X。</p><p>那么，这个过程中会不会出现数据不一致的情况呢？考虑到新增数据和删改数据的情况不一样，所以我们分开来看。</p><p><strong>1.新增数据</strong></p><p>如果是新增数据，数据会直接写到数据库中，不用对缓存做任何操作，此时，缓存中本身就没有新增数据，而数据库中是最新值，这种情况符合我们刚刚所说的一致性的第2种情况，所以，此时，缓存和数据库的数据是一致的。</p><p><strong>2.删改数据</strong></p><p>如果发生删改操作，应用既要更新数据库，也要在缓存中删除数据。这两个操作如果无法保证原子性，也就是说，要不都完成，要不都没完成，此时，就会出现数据不一致问题了。这个问题比较复杂，我们来分析一下。</p><p>我们假设应用先删除缓存，再更新数据库，如果缓存删除成功，但是数据库更新失败，那么，应用再访问数据时，缓存中没有数据，就会发生缓存缺失。然后，应用再访问数据库，但是数据库中的值为旧值，应用就访问到旧值了。</p><p>我来举个例子说明一下，可以先看看下面的图片。</p><p><img src=\"https://static001.geekbang.org/resource/image/b3/ae/b305a6355c9da145e4d1f86d23f4f0ae.jpg?wh=3000*1524\" alt=\"\"></p><p>应用要把数据X的值从10更新为3，先在Redis缓存中删除了X的缓存值，但是更新数据库却失败了。如果此时有其他并发的请求访问X，会发现Redis中缓存缺失，紧接着，请求就会访问数据库，读到的却是旧值10。</p><p>你可能会问，如果我们先更新数据库，再删除缓存中的值，是不是就可以解决这个问题呢？我们再来分析下。</p><p>如果应用先完成了数据库的更新，但是，在删除缓存时失败了，那么，数据库中的值是新值，而缓存中的是旧值，这肯定是不一致的。这个时候，如果有其他的并发请求来访问数据，按照正常的缓存访问流程，就会先在缓存中查询，但此时，就会读到旧值了。</p><p>我还是借助一个例子来说明一下。</p><p><img src=\"https://static001.geekbang.org/resource/image/76/77/767b4b2b1bafffd9a4b6368f05930a77.jpg?wh=3000*1546\" alt=\"\"></p><p>应用要把数据X的值从10更新为3，先成功更新了数据库，然后在Redis缓存中删除X的缓存，但是这个操作却失败了，这个时候，数据库中X的新值为3，Redis中的X的缓存值为10，这肯定是不一致的。如果刚好此时有其他客户端也发送请求访问X，会先在Redis中查询，该客户端会发现缓存命中，但是读到的却是旧值10。</p><p>好了，到这里，我们可以看到，在更新数据库和删除缓存值的过程中，无论这两个操作的执行顺序谁先谁后，只要有一个操作失败了，就会导致客户端读取到旧值。我画了下面这张表，总结了刚刚所说的这两种情况。</p><p><img src=\"https://static001.geekbang.org/resource/image/2c/ac/2c376b536aff9d14d8606499f401cdac.jpg?wh=2719*893\" alt=\"\"></p><p>问题发生的原因我们知道了，那该怎么解决呢？</p><h2>如何解决数据不一致问题？</h2><p>首先，我给你介绍一种方法：重试机制。</p><p>具体来说，可以把要删除的缓存值或者是要更新的数据库值暂存到消息队列中（例如使用Kafka消息队列）。当应用没有能够成功地删除缓存值或者是更新数据库值时，可以从消息队列中重新读取这些值，然后再次进行删除或更新。</p><p>如果能够成功地删除或更新，我们就要把这些值从消息队列中去除，以免重复操作，此时，我们也可以保证数据库和缓存的数据一致了。否则的话，我们还需要再次进行重试。如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。</p><p>下图显示了先更新数据库，再删除缓存值时，如果缓存删除失败，再次重试后删除成功的情况，你可以看下。</p><p><img src=\"https://static001.geekbang.org/resource/image/74/ab/74a66b9ce185d7c5b53986fc522dfcab.jpg?wh=3000*1840\" alt=\"\"></p><p>刚刚说的是在更新数据库和删除缓存值的过程中，其中一个操作失败的情况，实际上，即使这两个操作第一次执行时都没有失败，当有大量并发请求时，应用还是有可能读到不一致的数据。</p><p>同样，我们按照不同的删除和更新顺序，分成两种情况来看。在这两种情况下，我们的解决方法也有所不同。</p><p><strong>情况一：先删除缓存，再更新数据库。</strong></p><p>假设线程A删除缓存值后，还没有来得及更新数据库（比如说有网络延迟），线程B就开始读取数据了，那么这个时候，线程B会发现缓存缺失，就只能去数据库读取。这会带来两个问题：</p><ol>\n<li>线程B读取到了旧值；</li>\n<li>线程B是在缓存缺失的情况下读取的数据库，所以，它还会把旧值写入缓存，这可能会导致其他线程从缓存中读到旧值。</li>\n</ol><p>等到线程B从数据库读取完数据、更新了缓存后，线程A才开始更新数据库，此时，缓存中的数据是旧值，而数据库中的是最新值，两者就不一致了。</p><p>我用一张表来汇总下这种情况。</p><p><img src=\"https://static001.geekbang.org/resource/image/85/12/857c2b5449d9a04de6fe93yy1e355c12.jpg?wh=2937*1348\" alt=\"\"></p><p>这该怎么办呢？我来给你提供一种解决方案。</p><p><strong>在线程A更新完数据库值以后，我们可以让它先sleep一小段时间，再进行一次缓存删除操作。</strong></p><p>之所以要加上sleep的这段时间，就是为了让线程B能够先从数据库读取数据，再把缺失的数据写入缓存，然后，线程A再进行删除。所以，线程A sleep的时间，就需要大于线程B读取数据再写入缓存的时间。这个时间怎么确定呢？建议你在业务程序运行的时候，统计下线程读数据和写缓存的操作时间，以此为基础来进行估算。</p><p>这样一来，其它线程读取数据时，会发现缓存缺失，所以会从数据库中读取最新值。因为这个方案会在第一次删除缓存值后，延迟一段时间再次进行删除，所以我们也把它叫做“延迟双删”。</p><p>下面的这段伪代码就是“延迟双删”方案的示例，你可以看下。</p><pre><code>redis.delKey(X)\ndb.update(X)\nThread.sleep(N)\nredis.delKey(X)\n</code></pre><p><strong>情况二：先更新数据库值，再删除缓存值。</strong></p><p>如果线程A删除了数据库中的值，但还没来得及删除缓存值，线程B就开始读取数据了，那么此时，线程B查询缓存时，发现缓存命中，就会直接从缓存中读取旧值。不过，在这种情况下，如果其他线程并发读缓存的请求不多，那么，就不会有很多请求读取到旧值。而且，线程A一般也会很快删除缓存值，这样一来，其他线程再次读取时，就会发生缓存缺失，进而从数据库中读取最新值。所以，这种情况对业务的影响较小。</p><p>我再画一张表，带你总结下先更新数据库、再删除缓存值的情况。</p><p><img src=\"https://static001.geekbang.org/resource/image/a1/0b/a1c66ee114yyc9f37f2a35f21b46010b.jpg?wh=2907*958\" alt=\"\"></p><p>好了，到这里，我们了解到了，缓存和数据库的数据不一致一般是由两个原因导致的，我给你提供了相应的解决方案。</p><ul>\n<li>删除缓存值或更新数据库失败而导致数据不一致，你可以使用重试机制确保删除或更新操作成功。</li>\n<li>在删除缓存值、更新数据库的这两步操作中，有其他线程的并发读操作，导致其他线程读取到旧值，应对方案是延迟双删。</li>\n</ul><h2>小结</h2><p>在这节课，我们学习了在使用Redis缓存时，最常遇见的一个问题，也就是缓存和数据库不一致的问题。针对这个问题，我们可以分成读写缓存和只读缓存两种情况进行分析。</p><p>对于读写缓存来说，如果我们采用同步写回策略，那么可以保证缓存和数据库中的数据一致。只读缓存的情况比较复杂，我总结了一张表，以便于你更加清晰地了解数据不一致的问题原因、现象和应对方案。</p><p><img src=\"https://static001.geekbang.org/resource/image/11/6f/11ae5e620c63de76448bc658fe6a496f.jpg?wh=2889*1355\" alt=\"\"></p><p>希望你能把我总结的这张表格放入到你的学习笔记中，时不时复习一下。</p><p>最后，我还想再多说几句。在大多数业务场景下，我们会把Redis作为只读缓存使用。针对只读缓存来说，我们既可以先删除缓存值再更新数据库，也可以先更新数据库再删除缓存。我的建议是，优先使用先更新数据库再删除缓存的方法，原因主要有两个：</p><ol>\n<li>先删除缓存值再更新数据库，有可能导致请求因缓存缺失而访问数据库，给数据库带来压力；</li>\n<li>如果业务应用中读取数据库和写缓存的时间不好估算，那么，延迟双删中的等待时间就不好设置。</li>\n</ol><p>不过，当使用先更新数据库再删除缓存时，也有个地方需要注意，如果业务层要求必须读取一致的数据，那么，我们就需要在更新数据库时，先在Redis缓存客户端暂存并发读请求，等数据库更新完、缓存值删除后，再读取数据，从而保证数据一致性。</p><h2>每课一问</h2><p>按照惯例，我给你提个小问题。这节课，我提到，在只读缓存中进行数据的删改操作时，需要在缓存中删除相应的缓存值。我想请你思考一下，如果在这个过程中，我们不是删除缓存值，而是直接更新缓存的值，你觉得和删除缓存值相比，有什么好处和不足吗？</p><p>欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得今天的内容对你有所帮助，也欢迎你分享给你的朋友或同事。我们下节课见。</p>","comments":[{"had_liked":false,"id":253126,"user_name":"Kaito","can_delete":false,"product_type":"c1","uid":1020042,"ip_address":"","ucode":"79775FA35A95F2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","comment_is_top":false,"comment_ctime":1602605274,"is_pvip":true,"discussion_count":41,"race_medal":0,"score":"1341632401626","product_id":100056701,"comment_content":"数据在删改操作时，如果不是删除缓存值，而是直接更新缓存的值，你觉得和删除缓存值相比，有什么好处和不足？<br><br>这种情况相当于把Redis当做读写缓存使用，删改操作同时操作数据库和缓存。<br><br>1、先更新数据库，再更新缓存：如果更新数据库成功，但缓存更新失败，此时数据库中是最新值，但缓存中是旧值，后续的读请求会直接命中缓存，得到的是旧值。<br><br>2、先更新缓存，再更新数据库：如果更新缓存成功，但数据库更新失败，此时缓存中是最新值，数据库中是旧值，后续读请求会直接命中缓存，但得到的是最新值，短期对业务影响不大。但是，一旦缓存过期或者满容后被淘汰，读请求就会从数据库中重新加载旧值到缓存中，之后的读请求会从缓存中得到旧值，对业务产生影响。<br><br>同样地，针对这种其中一个操作可能失败的情况，也可以使用重试机制解决，把第二步操作放入到消息队列中，消费者从消息队列取出消息，再更新缓存或数据库，成功后把消息从消息队列删除，否则进行重试，以此达到数据库和缓存的最终一致。<br><br>以上是没有并发请求的情况。如果存在并发读写，也会产生不一致，分为以下4种场景。<br><br>1、先更新数据库，再更新缓存，写+读并发：线程A先更新数据库，之后线程B读取数据，此时线程B会命中缓存，读取到旧值，之后线程A更新缓存成功，后续的读请求会命中缓存得到最新值。这种场景下，线程A未更新完缓存之前，在这期间的读请求会短暂读到旧值，对业务短暂影响。<br><br>2、先更新缓存，再更新数据库，写+读并发：线程A先更新缓存成功，之后线程B读取数据，此时线程B命中缓存，读取到最新值后返回，之后线程A更新数据库成功。这种场景下，虽然线程A还未更新完数据库，数据库会与缓存存在短暂不一致，但在这之前进来的读请求都能直接命中缓存，获取到最新值，所以对业务没影响。<br><br>3、先更新数据库，再更新缓存，写+写并发：线程A和线程B同时更新同一条数据，更新数据库的顺序是先A后B，但更新缓存时顺序是先B后A，这会导致数据库和缓存的不一致。<br><br>4、先更新缓存，再更新数据库，写+写并发：与场景3类似，线程A和线程B同时更新同一条数据，更新缓存的顺序是先A后B，但是更新数据库的顺序是先B后A，这也会导致数据库和缓存的不一致。<br><br>场景1和2对业务影响较小，场景3和4会造成数据库和缓存不一致，影响较大。也就是说，在读写缓存模式下，写+读并发对业务的影响较小，而写+写并发时，会造成数据库和缓存的不一致。<br><br>针对场景3和4的解决方案是，对于写请求，需要配合分布式锁使用。写请求进来时，针对同一个资源的修改操作，先加分布式锁，这样同一时间只允许一个线程去更新数据库和缓存，没有拿到锁的线程把操作放入到队列中，延时处理。用这种方式保证多个线程操作同一资源的顺序性，以此保证一致性。<br><br>综上，使用读写缓存同时操作数据库和缓存时，因为其中一个操作失败导致不一致的问题，同样可以通过消息队列重试来解决。而在并发的场景下，读+写并发对业务没有影响或者影响较小，而写+写并发时需要配合分布式锁的使用，才能保证缓存和数据库的一致性。<br><br>另外，读写缓存模式由于会同时更新数据库和缓存，优点是，缓存中一直会有数据，如果更新操作后会立即再次访问，可以直接命中缓存，能够降低读请求对于数据库的压力（没有了只读缓存的删除缓存导致缓存缺失和再加载的过程）。缺点是，如果更新后的数据，之后很少再被访问到，会导致缓存中保留的不是最热的数据，缓存利用率不高（只读缓存中保留的都是热数据），所以读写缓存比较适合用于读写相当的业务场景。","like_count":313,"discussions":[{"author":{"id":1275690,"avatar":"https://static001.geekbang.org/account/avatar/00/13/77/2a/244d98aa.jpg","nickname":"cp★钊","note":"","ucode":"6B86D4D538BDF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332543,"discussion_content":"补充个情况。业务上不直接更新缓存，有可能是因为缓存是用的一个string存了一个序列化的数据，这样想更新表中一个字段的时候，得先读出所有字段的数据，再序列号后更新。多了一步操作，业务代码麻烦先，要考虑的异常场景也多些，没有删除缓存这种方式方便。","likes_number":19,"is_delete":false,"is_hidden":false,"ctime":1607255209,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394467,"discussion_content":"看了大家在评论区的疑问，结合这节课，我专门写了一篇「缓存和数据库一致性」的文章，基本覆盖了大家的疑问，大家可以看看：《缓存和数据库一致性问题，看这篇就够了》https://mp.weixin.qq.com/s/4W7vmICGx6a_WX701zxgPQ","likes_number":16,"is_delete":false,"is_hidden":false,"ctime":1631890717,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1675882,"avatar":"https://static001.geekbang.org/account/avatar/00/19/92/6a/dd37a054.jpg","nickname":"张y .","note":"","ucode":"85918469492F4C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":411528,"discussion_content":"太强了，这个总结","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1635945844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":394467,"ip_address":""},"score":411528,"extra":""},{"author":{"id":2870609,"avatar":"","nickname":"Geek_81fd93","note":"","ucode":"010A1ACF8E7F40","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":541283,"discussion_content":"写得太好了 ，受益匪浅","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1640317642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":394467,"ip_address":""},"score":541283,"extra":""},{"author":{"id":2911084,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/6b/6c/3e80afaf.jpg","nickname":"HappyHasson","note":"","ucode":"B84CC43E349CFA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":555759,"discussion_content":"太强","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647060815,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":394467,"ip_address":""},"score":555759,"extra":""}]},{"author":{"id":1566642,"avatar":"https://static001.geekbang.org/account/avatar/00/17/e7/b2/4cb8356a.jpg","nickname":"小甲鱼","note":"","ucode":"DDF8A3A4976681","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352338,"discussion_content":"我感觉先删除数据库后删除缓存的主要原因在与，操作数据库较慢，如果先删除缓存后删除数据库的话，如果并发请求，会直接打到数据库，会压垮数据库。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1614689765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1640978,"avatar":"https://static001.geekbang.org/account/avatar/00/19/0a/12/f8b988b8.jpg","nickname":"Kyle(","note":"","ucode":"0C14C4C086CAA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1566642,"avatar":"https://static001.geekbang.org/account/avatar/00/17/e7/b2/4cb8356a.jpg","nickname":"小甲鱼","note":"","ucode":"DDF8A3A4976681","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374965,"discussion_content":"这就是穿透了，应该可以用分布式锁","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1621422357,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":352338,"ip_address":""},"score":374965,"extra":""},{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1566642,"avatar":"https://static001.geekbang.org/account/avatar/00/17/e7/b2/4cb8356a.jpg","nickname":"小甲鱼","note":"","ucode":"DDF8A3A4976681","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385783,"discussion_content":"个人感觉在有读写的时候，先阻塞住，读写完成之后再把请求放过来，只不过会牺牲一点性能。但是就像CAP一样，没办法三者兼顾，必须做出一些损失，最终还是要看业务的容忍的程度","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1627271853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":352338,"ip_address":""},"score":385783,"extra":""}]},{"author":{"id":1331268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/50/44/99e4f560.jpg","nickname":"寻梦·阳溪","note":"","ucode":"CB056C8638E86C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":322305,"discussion_content":"只读缓存，先更新数据库、再删除缓存， 数据库更新成功后，\n1、尚未删除缓存、有并发读请求，并发请求从缓存中读到旧值，这里不能称之为旧值吧， 数据库操作与缓存的删除放置在同一个事务中，数据库操作完成后，缓存尚未执行删除，那么数据库的事务也尚未提交， 从事务隔离来说，数据库设置为read commited，并发线程本就不应该脏读到新值；\n2、尚未删除缓存、且后续缓存删除失败， 此时回滚数据库","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1604722364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1331268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/50/44/99e4f560.jpg","nickname":"寻梦·阳溪","note":"","ucode":"CB056C8638E86C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335328,"discussion_content":"。。。主要是考虑并发。A线程先DB 后删除 redis。B线程 在A线程先DB前读取到旧值，A线程先DB，然后删除redis，之后B线程执行 缓存回写操作。。。写入了旧值。  我竟然复制了上边的答案 哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608168674,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":322305,"ip_address":""},"score":335328,"extra":""},{"author":{"id":1331268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/50/44/99e4f560.jpg","nickname":"寻梦·阳溪","note":"","ucode":"CB056C8638E86C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336466,"discussion_content":"你说的这个是【竞态条件】，原子性的范畴，这个场景需要原子性来保证呀。 无论先操作redis还是先操作数据库，这个场景都需要采用其他手段如分布式锁来保证并发的正确性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608604763,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":335328,"ip_address":""},"score":336466,"extra":""},{"author":{"id":1277041,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7c/71/ecfde294.jpg","nickname":"钛合金猪头","note":"","ucode":"5919ACDA6739E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1331268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/50/44/99e4f560.jpg","nickname":"寻梦·阳溪","note":"","ucode":"CB056C8638E86C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":398113,"discussion_content":"不能放到同一个事务中，放到同一个事务中的话，其实还是先删redis，再更新 mysql 了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1632738267,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":322305,"ip_address":""},"score":398113,"extra":""}]},{"author":{"id":1122284,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1f/ec/d611ce6c.jpg","nickname":"Alex","note":"","ucode":"92BD46245FB5B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318576,"discussion_content":"3和4为啥更新数据库的顺序和更新缓存的顺序不一样","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1603784850,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1122284,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1f/ec/d611ce6c.jpg","nickname":"Alex","note":"","ucode":"92BD46245FB5B6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318588,"discussion_content":"因为2个线程并行，无法确定先后顺序。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1603788239,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":318576,"ip_address":""},"score":318588,"extra":""},{"author":{"id":1241380,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f1/24/d15cf6af.jpg","nickname":"英宁","note":"","ucode":"C6CB1C4FFCADC7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":323860,"discussion_content":"更新操作不在线程中进行，引入消息队列异步更新（查询最新数据，非线程中的数据）会不会更好一些，同时解决了数据不一致的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605010883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":318588,"ip_address":""},"score":323860,"extra":""},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1241380,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f1/24/d15cf6af.jpg","nickname":"英宁","note":"","ucode":"C6CB1C4FFCADC7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335333,"discussion_content":"不会  你引入mq更新，那有个问题，你业务查询代码如何写？ 是不是还是 查询缓存，命中返回，没有命中查询db  然后回写缓存？  如果放mq  并消费 写入这个阶段一定会有并发问题的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608169533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":323860,"ip_address":""},"score":335333,"extra":""}]},{"author":{"id":2419770,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ec/3a/75bc138d.jpg","nickname":"Saitama","note":"","ucode":"94735DA32C22B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364089,"discussion_content":"单线程放入消息队列失败了了？不还是不能保证最终一致","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1617362424,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1667353,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIcgKLQZibvbXn3kMdLdRsHcmeqNur4AAMGCmHEb9C4uGNQg7dLon7RVGAibeFKgoVfjrpSCIJRISxg/132","nickname":"lztby","note":"","ucode":"8D223B7BFA772A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2419770,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ec/3a/75bc138d.jpg","nickname":"Saitama","note":"","ucode":"94735DA32C22B1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371621,"discussion_content":"消息队列肯定有机制保证这会成功啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619876432,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":364089,"ip_address":""},"score":371621,"extra":""}]},{"author":{"id":2387358,"avatar":"https://static001.geekbang.org/account/avatar/00/24/6d/9e/6a82a5ea.jpg","nickname":"good boby","note":"","ucode":"1471E2E499412C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373245,"discussion_content":"1、先更新数据库，再更新缓存：如果更新数据库成功，但缓存更新失败，此时数据库中是最新值，但缓存中是旧值，后续的读请求会直接命中缓存，得到的是旧值。\n\n如果是删除操作，删除操作失败同样后续读请求命中缓存，得到的也是旧值。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1620659768,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1781893,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/30/85/14c2f16c.jpg","nickname":"石小","note":"","ucode":"4258C686F289A6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326307,"discussion_content":"课代表好，给缓存做持久化，更新数据时只更新到缓存，之后由专门的进城进行刷到数据库；读取数据时也是从缓存读，读不到再从数据库读。这种方式有什么问题吗？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605577618,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":2308075,"avatar":"","nickname":"Geek_89e362","note":"","ucode":"E596C2CFE1CFAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1781893,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/30/85/14c2f16c.jpg","nickname":"石小","note":"","ucode":"4258C686F289A6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348613,"discussion_content":"我说一下自己的看法，这样只更新缓存，就需要使用 always 模式的AOF持久化，如果数据量比较多地话 AOF 会出现频繁的重写会影响Redis整体性能。可以反过来只更新 数据库，有专门的调度 读取数据库日志文件，更新缓存。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1612666571,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":326307,"ip_address":""},"score":348613,"extra":""},{"author":{"id":1389314,"avatar":"https://static001.geekbang.org/account/avatar/00/15/33/02/83f47bf9.jpg","nickname":"流沙","note":"","ucode":"6153686D1C34B7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1781893,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/30/85/14c2f16c.jpg","nickname":"石小","note":"","ucode":"4258C686F289A6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384566,"discussion_content":"这不就是mysql的刷脏页吗，感觉没什么问题，可能就是持久化对性能的影响吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626665507,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":326307,"ip_address":""},"score":384566,"extra":""},{"author":{"id":1194858,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3b/6a/80d9c545.jpg","nickname":"RD","note":"","ucode":"E3947B6E1681AD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1781893,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/30/85/14c2f16c.jpg","nickname":"石小","note":"","ucode":"4258C686F289A6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589565,"discussion_content":"问题对于 redis 这种旁路缓存，你只能自己同时操作 redis 和数据库。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665129763,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":326307,"ip_address":"北京"},"score":589565,"extra":""}]},{"author":{"id":1977474,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/2c/82/98e2b82a.jpg","nickname":"Reborn 2.0","note":"","ucode":"BA506E7455D91C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326013,"discussion_content":"不用第二种延迟双删, 直接用先DB后删redis不就好了, 延迟双删还要麻烦一点, 感觉延迟双删相对于先DB后redis没有什么优点啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605499688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1977474,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/2c/82/98e2b82a.jpg","nickname":"Reborn 2.0","note":"","ucode":"BA506E7455D91C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335327,"discussion_content":"主要是考虑并发。A线程先DB 后删除 redis。B线程 在A线程先DB前读取到旧值，A线程先DB，然后删除redis，之后B线程执行 缓存回写操作。。。写入了旧值。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1608168632,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":326013,"ip_address":""},"score":335327,"extra":""},{"author":{"id":2566445,"avatar":"https://static001.geekbang.org/account/avatar/00/27/29/2d/39637017.jpg","nickname":"烟火","note":"","ucode":"2CE0BBFD5E6AC6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385297,"discussion_content":"这里线程B肯定会先读缓存的吧，缓存都没删，怎么会先读数据库，在更新缓存呢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1626971119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":335327,"ip_address":""},"score":385297,"extra":""}]},{"author":{"id":1253384,"avatar":"https://static001.geekbang.org/account/avatar/00/13/20/08/bc06bc69.jpg","nickname":"Dovelol","note":"","ucode":"9B5DDF7720F307","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312692,"discussion_content":"想问下，没有拿到锁的线程把操作放到队列中，那请求的response怎么处理呢？直接返回么，如果当下就要知道返回结果的情况呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602771810,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1253384,"avatar":"https://static001.geekbang.org/account/avatar/00/13/20/08/bc06bc69.jpg","nickname":"Dovelol","note":"","ucode":"9B5DDF7720F307","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312713,"discussion_content":"如果是关键路径，用户必须知道结果，拿不到锁请求直接返回错误，直接告知用户稍后重试。\n\n如果是非关键路径，例如是消费队列里的数据，可以放入延迟队列处理。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1602776079,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":312692,"ip_address":""},"score":312713,"extra":""}]},{"author":{"id":1194858,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3b/6a/80d9c545.jpg","nickname":"RD","note":"","ucode":"E3947B6E1681AD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589573,"discussion_content":"我还找到了你的 blog 哈哈哈，http://kaito-kidd.com/2021/09/08/how-to-keep-cache-and-consistency-of-db","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665133439,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1415619,"avatar":"https://static001.geekbang.org/account/avatar/00/15/99/c3/e4f408d4.jpg","nickname":"陌兮","note":"","ucode":"00CE47CAECD5CD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553620,"discussion_content":"深夜mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645987943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2105175,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/40ab8h1zbSUZmzxARyicDuXECYwtQNDd9jxAbys5LMnVLJMmibTCHd1icrRZMnMSvTJ27UdITA0439hAaVIxcOkGQ/132","nickname":"Geek_72b9a7","note":"","ucode":"4C26B79F9F15A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390529,"discussion_content":"主要看业务是强一致性还是最终一致性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629877245,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2063920,"avatar":"","nickname":"Geek_7bb784","note":"","ucode":"5DF4B955A266F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376835,"discussion_content":"双写模式下，update数据库是有返回值的，update redis的操作可以放到update数据库返回之后进行，通过数据库的行锁避免修改数据库是线程A，B；修改redis是线程B，A的情况。\n\n类似于一种原子操作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622369793,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1284672,"avatar":"https://static001.geekbang.org/account/avatar/00/13/9a/40/b746dc09.jpg","nickname":"twogozi","note":"","ucode":"C272B0745EF514","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2063920,"avatar":"","nickname":"Geek_7bb784","note":"","ucode":"5DF4B955A266F3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390107,"discussion_content":"如何保障执行时许？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629674574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":376835,"ip_address":""},"score":390107,"extra":""}]},{"author":{"id":1094478,"avatar":"https://static001.geekbang.org/account/avatar/00/10/b3/4e/5f22b09d.jpg","nickname":"marker","note":"","ucode":"DDBF1CD83665C4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338304,"discussion_content":"个人认为应该在应用层做个队列处理，请求更新串行化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609236056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1170843,"avatar":"https://static001.geekbang.org/account/avatar/00/11/dd/9b/0bc44a78.jpg","nickname":"yyl","note":"","ucode":"1741DACDFCA9AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327948,"discussion_content":"总结非常详细","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606024122,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1119593,"avatar":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","nickname":"南山","note":"","ucode":"94656FE4A6C378","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":313032,"discussion_content":"引入消息队列是不是还要考虑消息发送，消费失败的各种场景？比如缓存更新或者数据库更新与发送消息不具备事务性，原子性没法保证","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602915507,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1119593,"avatar":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","nickname":"南山","note":"","ucode":"94656FE4A6C378","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":313034,"discussion_content":"严格来说是需要的。但是我们面对的大部分场景，只需要保证最终一致性即可。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1602916139,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":313032,"ip_address":""},"score":313034,"extra":""},{"author":{"id":2419770,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ec/3a/75bc138d.jpg","nickname":"Saitama","note":"","ucode":"94735DA32C22B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1119593,"avatar":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","nickname":"南山","note":"","ucode":"94656FE4A6C378","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":364090,"discussion_content":"那假如消息队列入队失败，岂不是不但增加了系统的复杂性，而且还是不能解决一致性问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617362692,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":313032,"ip_address":""},"score":364090,"extra":""},{"author":{"id":1693927,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIg8jibDUq1QVY6Kjabg6kc66QfjibibNCKwbEPCBq6ejQzg5WDhIv9Nyv9icfJ5W98CFMDYaoITibD7kQ/132","nickname":"Geek_018298","note":"","ucode":"02FE1726627515","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2419770,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ec/3a/75bc138d.jpg","nickname":"Saitama","note":"","ucode":"94735DA32C22B1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536966,"discussion_content":"要使用事务消息，redis更新成功，发送事务消息，异步消费消息更新数据库","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638924528,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":364090,"ip_address":""},"score":536966,"extra":""}]},{"author":{"id":1530379,"avatar":"https://static001.geekbang.org/account/avatar/00/17/5a/0b/ff309add.jpg","nickname":"Franklin","note":"","ucode":"E4580C46DB00EE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312667,"discussion_content":"������思路清晰","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602763997,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257422,"user_name":"Alex_QY","can_delete":false,"product_type":"c1","uid":1095988,"ip_address":"","ucode":"8535FD6D163539","user_header":"https://static001.geekbang.org/account/avatar/00/10/b9/34/f1bdcbd0.jpg","comment_is_top":false,"comment_ctime":1603966240,"is_pvip":false,"discussion_count":28,"race_medal":0,"score":"448280565024","product_id":100056701,"comment_content":"延时双删根本解决不了一致性问题，高迸发场景线程A根本不知道线程B，线程C的执行开始和结束的时间。<br>所以sleep跟没sleep没啥区别。。。<br>感觉唯一的办法就是要让整个事务方法由并行变成串行。<br>感觉串行呢？要么借助分布式锁，要么借助MYSQL本身的update独占锁","like_count":105,"discussions":[{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377555,"discussion_content":"首先这个sleep时间根本就无法精确 而且代码里塞一个sleep本身就是个雷","likes_number":20,"is_delete":false,"is_hidden":false,"ctime":1622708223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1192724,"avatar":"https://static001.geekbang.org/account/avatar/00/12/33/14/78104f1f.jpg","nickname":"Just Do IT","note":"","ucode":"1EAD92510FA7BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349687,"discussion_content":"是的  这个sleep方案实在难以接受","likes_number":17,"is_delete":false,"is_hidden":false,"ctime":1613458060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2730307,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKagLyKbgMsyM4aaJ2JOum7wcq5mCXvrbfYBOUnNE4JJxWmJeNyxCXrAZIarJiaYicYR369EorYFtibA/132","nickname":"Geek_53aa12","note":"","ucode":"F1B3BDAA39AF52","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413615,"discussion_content":"看到“延迟双删”这个方案，瞬间对整个课程失去了兴趣。感觉作者做这个课程太不上心，像是在网上随便复制粘贴的。","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1636527595,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2873299,"avatar":"","nickname":"nuptxiaoli","note":"","ucode":"EF2962A390DC55","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2730307,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKagLyKbgMsyM4aaJ2JOum7wcq5mCXvrbfYBOUnNE4JJxWmJeNyxCXrAZIarJiaYicYR369EorYFtibA/132","nickname":"Geek_53aa12","note":"","ucode":"F1B3BDAA39AF52","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546017,"discussion_content":"我是想看看作者有什么高深的方法才买这个课程的，结果竟然还是“延迟双删”这个方案。。。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1642130285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":413615,"ip_address":""},"score":546017,"extra":""}]},{"author":{"id":2542376,"avatar":"https://static001.geekbang.org/account/avatar/00/26/cb/28/21a8a29e.jpg","nickname":"夏天","note":"","ucode":"5F224DDAC94DFF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370134,"discussion_content":"正解。由于 sql 不同或者 db 压力很可能导致更新时间不同。sleep 只能降低概率。只能说没见过这么用的。如果你的系统不是异步，sleep 就坑了。大家多思考吧！","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1619308449,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2106663,"avatar":"https://static001.geekbang.org/account/avatar/00/20/25/27/0076d304.jpg","nickname":"帽子狗","note":"","ucode":"51596F366AF068","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384642,"discussion_content":"不一定是sleep啦，比如我们之前就有专门弄了个延时任务队列去解决。更新完数据库把这个记个任务丢到队列里去执行了，而且第一次删除失败的概率已经低于1%了，第二次删除基本能解决全部删除失败问题。 尽管可以弄个任务重试加阈值，但没必要，两次删不掉我认了。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1626685478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1120703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/19/bf/415023b5.jpg","nickname":"璩雷","note":"","ucode":"BBAC0933BB7C92","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2106663,"avatar":"https://static001.geekbang.org/account/avatar/00/20/25/27/0076d304.jpg","nickname":"帽子狗","note":"","ucode":"51596F366AF068","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385250,"discussion_content":"笑死我了，哈哈，最起码三次才认啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626955220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":384642,"ip_address":""},"score":385250,"extra":""},{"author":{"id":2889981,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/18/fd/ccc7b563.jpg","nickname":"Vegeta","note":"","ucode":"1AE2D9337A728C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2106663,"avatar":"https://static001.geekbang.org/account/avatar/00/20/25/27/0076d304.jpg","nickname":"帽子狗","note":"","ucode":"51596F366AF068","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561327,"discussion_content":"可以考虑依托MySQL的事务机制实现一个分布式锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649601171,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":384642,"ip_address":""},"score":561327,"extra":""},{"author":{"id":1811277,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a3/4d/59390ba9.jpg","nickname":"排骨","note":"","ucode":"A413CF46211E1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2106663,"avatar":"https://static001.geekbang.org/account/avatar/00/20/25/27/0076d304.jpg","nickname":"帽子狗","note":"","ucode":"51596F366AF068","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585548,"discussion_content":"是的，可以放到一个延迟队列里，还是没办法，只能认了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661676391,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":384642,"ip_address":"广东"},"score":585548,"extra":""}]},{"author":{"id":2194764,"avatar":"","nickname":"K菌无惨","note":"","ucode":"97A532D588FD49","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345103,"discussion_content":"感觉sleep的作用就是来确保其他线程在进行读操作读到旧值而写入到缓存中的数据肯定能被删除,所以延迟双删除的时延是需要根据具体的读操作时延而设定","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1611657242,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1592279,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","nickname":"William Ning","note":"","ucode":"4DB8D05E69E5F3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":563430,"discussion_content":"个人见解：\n要想实现强一致性，本质就在于控制并发操作顺序，简单说，就是one by one, 只有上一个通过，下一个才能开始。 但是性能可就打折了，基本上很多事，都是一个trade-off。\n\n另外，至于看到一个自己不认同的事物/做法，就拒绝/否定了这个事物的所有，我想这也并不是一个明智的选择～","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1649993326,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2455904,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Njcq6khFKlIJwGhzc3hjibOJhqUrVBe8x3oBPaS25LvBoIqHxqtdNUaMib1O8WicHKibYon5UhgWY5Z6Rib710FX72A/132","nickname":"Geek_58686b","note":"","ucode":"8CA7843C094487","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365745,"discussion_content":"本身双写一致性的问题就不可能百分百完美解决。只能做到精益求精，的确我对，延迟双删也很不赞同。。。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1617874116,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1179298,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fe/a2/5252a278.jpg","nickname":"对方正在输入。。。","note":"","ucode":"7B0DEB4D9B43D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":395840,"discussion_content":"赞同，有线程b就有线程c更有线程d","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1632359062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2883490,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/ff/a2/56e24200.jpg","nickname":"J 杰~","note":"","ucode":"7202987553A19D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568092,"discussion_content":"没有方案能百分百确保一致的，总会不一致的情况，但基于队列重试这种方案对业务影响来说是最小的，起码最终一致，能保证不要长时间不一致就好了。对于一致性要求高的业务，只能通过其他机制来保障了，或者压根不要用redis。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1651064699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1344535,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqOn7k48KXia5rf0eXpzv2EGtqGibz3eNb8QnL8X72uia0g1rBwzXef4dV2JEdz3r4bu9GC1FLIeic4UA/132","nickname":"Lee","note":"","ucode":"6B8D59A0B1A1A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545834,"discussion_content":"讨论一下：作者说的应该不是绝对保证，只是一个可选方案吧。试想一下，如果再复杂一点，读请求和写请求间隔并发着来，你更无法保证后面的读请求能读到最新值，sleep()更没任何意义，个人想到一种理论上的方案不知道是否可行，对于并写发性不是特别高的场景","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1642062685,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1035612,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cd/5c/e09eac13.jpg","nickname":"刘強","note":"","ucode":"B2E41BB894A727","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545126,"discussion_content":"讲技术方案，脱离了具体场景，很容易造成误解。而这恰恰是最重要的，作者可能用这个方法解决了问题，但读者看了一头雾水，唉，报喜不报忧，误人啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1641857422,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2308075,"avatar":"","nickname":"Geek_89e362","note":"","ucode":"E596C2CFE1CFAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348616,"discussion_content":"没有 “银弹”技术，技术方法是要跟具体业务相结合的，sleep 是否合适，要根据你的具体业务场景有关，比如说 写多读少的场景下这种还是可以的，如果子读的并发量很高的情况，sleep 也许就不合适了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1612666868,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1178443,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fb/4b/16cf99c3.jpg","nickname":"张绍云","note":"","ucode":"12CCBA2C5588B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346470,"discussion_content":"同意 and 高并发场景 使用sleep是是不理智的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1611969976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1768852,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/fd/94/8704d2b0.jpg","nickname":"spoofer","note":"","ucode":"6723F64ACC3F27","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346321,"discussion_content":"还是要看你的业务场景和业务对这种不一致性的可接受程度~！！最苛刻就是你说的串行了。毕竟多个服务间交互无法突破时空的限制~","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1611906727,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1320487,"avatar":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","nickname":"罗杰","note":"","ucode":"96BAFAA147341F","race_medal":2,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578224,"discussion_content":"这个延迟双删基本上解决不了问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656587774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2105175,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/40ab8h1zbSUZmzxARyicDuXECYwtQNDd9jxAbys5LMnVLJMmibTCHd1icrRZMnMSvTJ27UdITA0439hAaVIxcOkGQ/132","nickname":"Geek_72b9a7","note":"","ucode":"4C26B79F9F15A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390528,"discussion_content":"当消息不自动ack时，如果更新db/redis失败了，消息是不会丢失的，重回队列后可再次读取处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629877018,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1344431,"avatar":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","nickname":"马以","note":"","ucode":"3FEA06CA14DE28","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368979,"discussion_content":"这个应该就是能达到最终一致性吧，在第二次删除之前并发线程还是读到的是旧数据，业务场景允许的情况下可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618894357,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2101537,"avatar":"https://static001.geekbang.org/account/avatar/00/20/11/21/8f81b64f.jpg","nickname":"LS。","note":"","ucode":"5EB25806DDB4F5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361615,"discussion_content":"赞同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616719057,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1336951,"avatar":"https://static001.geekbang.org/account/avatar/00/14/66/77/194ba21d.jpg","nickname":"lzh","note":"","ucode":"C3D83DF4230109","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":359498,"discussion_content":"高并发场景还是有双删的必要的，线程A删完缓存，更新完数据库前，其他线程会读到旧数据并放入缓存，如果没有双删，旧数据会一直在缓存中。不过在更新完数据库后和第二次删除缓存前，确实有一小段缓存和数据库不一致的时间","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616210379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":2563368,"avatar":"https://static001.geekbang.org/account/avatar/00/27/1d/28/b4ea7ed7.jpg","nickname":"往事随风","note":"","ucode":"509EE132D433D6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1336951,"avatar":"https://static001.geekbang.org/account/avatar/00/14/66/77/194ba21d.jpg","nickname":"lzh","note":"","ucode":"C3D83DF4230109","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374833,"discussion_content":"延迟第二次删也会失败，所以这个问题依旧没解决","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1621385961,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":359498,"ip_address":""},"score":374833,"extra":""},{"author":{"id":1336951,"avatar":"https://static001.geekbang.org/account/avatar/00/14/66/77/194ba21d.jpg","nickname":"lzh","note":"","ucode":"C3D83DF4230109","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2563368,"avatar":"https://static001.geekbang.org/account/avatar/00/27/1d/28/b4ea7ed7.jpg","nickname":"往事随风","note":"","ucode":"509EE132D433D6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375476,"discussion_content":"第二次删除失败可以重试几次，还不行就应该返回错误了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1621677495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":374833,"ip_address":""},"score":375476,"extra":""},{"author":{"id":1014665,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/89/34f2cbcc.jpg","nickname":"杨宇","note":"","ucode":"EB74DF6E269F03","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1336951,"avatar":"https://static001.geekbang.org/account/avatar/00/14/66/77/194ba21d.jpg","nickname":"lzh","note":"","ucode":"C3D83DF4230109","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388347,"discussion_content":"还不如先写DB后删缓存","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1628728711,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":359498,"ip_address":""},"score":388347,"extra":""}]}]},{"had_liked":false,"id":253798,"user_name":"ctang","can_delete":false,"product_type":"c1","uid":1344735,"ip_address":"","ucode":"A0CA5B6BEEAD59","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/sYNQia23F7iaBKzdnO0CkYQIsOd8jARUqAFpAD9TE7esu2LGCCMpwmRlicSW5AT6GUTHQxVqMN6wia1HpR3ldf1zzw/132","comment_is_top":false,"comment_ctime":1602900071,"is_pvip":false,"discussion_count":16,"race_medal":0,"score":"139041853543","product_id":100056701,"comment_content":"先删除缓存后更新数据库，数据库更新失败了，何来的旧值。只读缓存不是以数据库为准吗？","like_count":33,"discussions":[{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340099,"discussion_content":"楼主是对的 ,db层事务都回滚了, 写redis压根不会被执行,业务层也能感知到请求失败 , 此时其他线程读到的值是准确的","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1609902738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1228852,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c0/34/0574bb44.jpg","nickname":"最初的印象","note":"","ucode":"4DD68307FA274E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371842,"discussion_content":"老师讲错了！","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1620014298,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1939179,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/96/eb/bd1b344f.jpg","nickname":"用户6109996491","note":"","ucode":"BDB4FFA1661DC7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1228852,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c0/34/0574bb44.jpg","nickname":"最初的印象","note":"","ucode":"4DD68307FA274E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":395749,"discussion_content":"假如现在缓存和数据库的值都是10，线程A先删除缓存10，然后去更改数据库值将10改为3，但是修改的过程失败了(也就是数据库的值依然是10，也是没有毛病的)，然后现在线程B来访问时，先去缓存获取，但是缓存已经被线程A删除了，那么此时，线程B要走数据库进行访问。本来线程A要把10改为3的，但是失败了，所以数据库的值依然是10，因为线程A请求修改失败了啊，那么10就是旧值。我是这么理解的。你说哪来的旧值？除非线程A修改成功才没有旧值，但这里是失败的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632326774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":371842,"ip_address":""},"score":395749,"extra":""}]},{"author":{"id":2542376,"avatar":"https://static001.geekbang.org/account/avatar/00/26/cb/28/21a8a29e.jpg","nickname":"夏天","note":"","ucode":"5F224DDAC94DFF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370131,"discussion_content":"正确，明显老师错了。数据库更新失败，再次访问怎么能算旧值呢？比如扣库存失败，再次访问数据库库存还是最新值。充其量需要额外缓存一次。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1619307411,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1939179,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/96/eb/bd1b344f.jpg","nickname":"用户6109996491","note":"","ucode":"BDB4FFA1661DC7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2542376,"avatar":"https://static001.geekbang.org/account/avatar/00/26/cb/28/21a8a29e.jpg","nickname":"夏天","note":"","ucode":"5F224DDAC94DFF","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":395750,"discussion_content":"假如现在缓存和数据库的值都是10，线程A先删除缓存10，然后去更改数据库值将10改为3，但是修改的过程失败了(也就是数据库的值依然是10，也是没有毛病的)，然后现在线程B来访问时，先去缓存获取，但是缓存已经被线程A删除了，那么此时，线程B要走数据库进行访问。本来线程A要把10改为3的，但是失败了，所以数据库的值依然是10，因为线程A请求修改失败了啊，那么10就是旧值。我是这么理解的。你说哪来的旧值？除非线程A修改成功才没有旧值，但这里是失败的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632326790,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":370131,"ip_address":""},"score":395750,"extra":""}]},{"author":{"id":2047980,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/3f/ec/00904faa.jpg","nickname":"连长","note":"","ucode":"555BD3DE57887F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338550,"discussion_content":"数据库的值是旧值","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1609311109,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1617421,"avatar":"https://static001.geekbang.org/account/avatar/00/18/ae/0d/3e89877b.jpg","nickname":"Phil","note":"","ucode":"CBD45271013B2A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2047980,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/3f/ec/00904faa.jpg","nickname":"连长","note":"","ucode":"555BD3DE57887F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339027,"discussion_content":"没有新值何来旧值","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1609480049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":338550,"ip_address":""},"score":339027,"extra":""},{"author":{"id":1109527,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ee/17/32183260.jpg","nickname":"逍遥魔君","note":"","ucode":"6EDD906634D7CB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1617421,"avatar":"https://static001.geekbang.org/account/avatar/00/18/ae/0d/3e89877b.jpg","nickname":"Phil","note":"","ucode":"CBD45271013B2A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368938,"discussion_content":"逻辑辩论","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1618885438,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":339027,"ip_address":""},"score":368938,"extra":""},{"author":{"id":1939179,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/96/eb/bd1b344f.jpg","nickname":"用户6109996491","note":"","ucode":"BDB4FFA1661DC7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1617421,"avatar":"https://static001.geekbang.org/account/avatar/00/18/ae/0d/3e89877b.jpg","nickname":"Phil","note":"","ucode":"CBD45271013B2A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":395748,"discussion_content":"假如现在缓存和数据库的值都是10，线程A先删除缓存10，然后去更改数据库值将10改为3，但是修改的过程失败了(也就是数据库的值依然是10，也是没有毛病的)，然后现在线程B来访问时，先去缓存获取，但是缓存已经被线程A删除了，那么此时，线程B要走数据库进行访问。本来线程A要把10改为3的，但是失败了，所以数据库的值依然是10，因为线程A请求修改失败了啊，那么10就是旧值。我是这么理解的。你说哪来的旧值？除非线程A修改成功才没有旧值，但这里是失败的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632326749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":339027,"ip_address":""},"score":395748,"extra":""}]},{"author":{"id":1046562,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f8/22/a59136c2.jpg","nickname":"Linton","note":"","ucode":"7918113F03FD44","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379005,"discussion_content":"老师讲的意思应该是: 更新数据时, 先删缓存再更新数据库. 结果, 更新数据库操作失败.\neg.  db的旧值10, 新值3.  先删缓存再更新数据库. 结果. 更新数据库失败, 数据库还是10. 客户端读缓存读不到, 去读数据库读到旧值10. ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623585404,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1263977,"avatar":"https://static001.geekbang.org/account/avatar/00/13/49/69/c0fcf4e8.jpg","nickname":"def","note":"","ucode":"39BDBEA0560C13","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365769,"discussion_content":"我也是这个看法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617879098,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1234200,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d5/18/7f3b1af2.jpg","nickname":"头晕的小骚年","note":"","ucode":"EDA4B89BAA33F1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":359978,"discussion_content":"如果另一条线程B在线程A删缓存后，更新数据库前来读数据库，那么缓存中的存放的值就是数据库旧值，而且如果数据库不更新且缓存没有设置失效时间，那将一直是旧值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616335604,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1531599,"avatar":"https://static001.geekbang.org/account/avatar/00/17/5e/cf/961ceed9.jpg","nickname":"恒恒","note":"","ucode":"7FDFBA81416AC7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343975,"discussion_content":"是的，这里说的不明不白的，只可能缓存缺失，整个请求都失败了，哪来的旧值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611222767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1939179,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/96/eb/bd1b344f.jpg","nickname":"用户6109996491","note":"","ucode":"BDB4FFA1661DC7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1531599,"avatar":"https://static001.geekbang.org/account/avatar/00/17/5e/cf/961ceed9.jpg","nickname":"恒恒","note":"","ucode":"7FDFBA81416AC7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":395747,"discussion_content":"假如现在缓存和数据库的值都是10，线程A先删除缓存10，然后去更改数据库值将10改为3，但是修改的过程失败了(也就是数据库的值依然是10，也是没有毛病的)，然后现在线程B来访问时，先去缓存获取，但是缓存已经被线程A删除了，那么此时，线程B要走数据库进行访问。本来线程A要把10改为3的，但是失败了，所以数据库的值依然是10，因为线程A请求修改失败了啊，那么10就是旧值。我是这么理解的。你说哪来的旧值？除非线程A修改成功才没有旧值，但这里是失败的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632326731,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":343975,"ip_address":""},"score":395747,"extra":""}]},{"author":{"id":2034717,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/ZOjPic948JaOXhbUwZcBqGibPYtu6QA5BuA9qdQHE6xBaGuER5BAfdVGDyeenvhuXAb8069w1fA8p5iblALtmk6hA/132","nickname":"Geek_f5a46e","note":"","ucode":"C6618A64653E5A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331260,"discussion_content":"问题是不是所有请求都可以由客户端触发重试。例如分布式系统，不同服务同时删除。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606817288,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1336009,"avatar":"https://static001.geekbang.org/account/avatar/00/14/62/c9/7da27891.jpg","nickname":"DKSky","note":"","ucode":"69371A81033949","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":313048,"discussion_content":"是的，这种情况客户端应该认为这是一次失败的请求，会进行重试","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602924644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":276951,"user_name":"约书亚","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","comment_is_top":false,"comment_ctime":1612189278,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"100396437086","product_id":100056701,"comment_content":"完全没必要双删，双删比起先DB后删Redis，无非就是防止删除Redis操作失败。但高并发下依旧可能在第一次删期间混进来读操作。<br>还有基于消息队列的方案，凭啥Redis操作能会失败，DB操作会失败，消息队列就不会了呢？就算能用事务消息，难道不怕旧值覆盖新值的情况发生么？<br>对于课后题，这种被称为直接缓存，除了大家说的分布式锁方案保证并发下的正确，还可以考虑基于lua实现cas，有一定性能下降但大多数场景都还能接受。","like_count":23,"discussions":[{"author":{"id":2549097,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoib6BjEV4KPEaIdlLEfoVFRCxCSlL2XaIVDiaakvjhWEibibym323ZeHXAY46JMO3nSHmjiaWtAY47eww/132","nickname":"dobby","note":"","ucode":"9C1992C4DD28F5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390293,"discussion_content":"现在的最终一致性都是重度依赖mq的，常规手段都是利用mq也不叫什么误人子弟。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1629766689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1024294,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","nickname":"null","note":"","ucode":"F9039EFED6B55D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376646,"discussion_content":"点赞只为这一句：消息队列就不会了呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1622253462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1228852,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c0/34/0574bb44.jpg","nickname":"最初的印象","note":"","ucode":"4DD68307FA274E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371843,"discussion_content":"是啊，引入消息队列还要考虑消息丢失，消息是否重复消费得一些列问题。也不知道这老师是怎么想的，误人子弟啊！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620014493,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1113737,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2icbib62icXtibTkThtyRksbuJLoTLMts7zook2S30MiaBtbz0f5JskwYicwqXkhpYfvCpuYkcvPTibEaQ/132","nickname":"xuanyuan","note":"","ucode":"1EC79B9372868F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1228852,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c0/34/0574bb44.jpg","nickname":"最初的印象","note":"","ucode":"4DD68307FA274E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373279,"discussion_content":"这不是误人子弟，只是方案的复杂度问题，要获得强一致性的代价罢了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1620688879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":371843,"ip_address":""},"score":373279,"extra":""},{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1228852,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c0/34/0574bb44.jpg","nickname":"最初的印象","note":"","ucode":"4DD68307FA274E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375026,"discussion_content":"张口就来？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621438664,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":371843,"ip_address":""},"score":375026,"extra":""},{"author":{"id":1593786,"avatar":"https://static001.geekbang.org/account/avatar/00/18/51/ba/5971383c.jpg","nickname":"Listeneesin","note":"","ucode":"C08BCF9BC5EDC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1228852,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c0/34/0574bb44.jpg","nickname":"最初的印象","note":"","ucode":"4DD68307FA274E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376019,"discussion_content":"多引入一个中间件确实会增加系统的复杂度，消息队列不像缓存，做好消息保序和零丢失方案，确实可以保证数据的最终一致性。不借助消息队列异步，那只能通过类似与tcc等分布式事务来解决二者操作的事务性问题","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1621929032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":371843,"ip_address":""},"score":376019,"extra":""}]}]},{"had_liked":false,"id":261708,"user_name":"Reborn 2.0","can_delete":false,"product_type":"c1","uid":1977474,"ip_address":"","ucode":"BA506E7455D91C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/2c/82/98e2b82a.jpg","comment_is_top":false,"comment_ctime":1605499644,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"40260205308","product_id":100056701,"comment_content":"不用第二种延迟双删, 直接用先DB后删redis不就好了, 延迟双删还要麻烦一点, 感觉没有什么优点啊","like_count":9,"discussions":[{"author":{"id":2804690,"avatar":"","nickname":"呵呵哒","note":"","ucode":"C08AA79F71D193","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404628,"discussion_content":"数据库读写分离的情况，延迟双删还有有意义的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1634364822,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1684122,"avatar":"","nickname":"Geek_4acf29","note":"","ucode":"C3C453557D052A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330837,"discussion_content":"DB删了后，程序出了问题导致没有更新Redis，另一个线程查询时就会查到没有删除的Redis值，延迟双删要配合读操作时检查到Redis的key值不存在就读数据库并将内容写进Redis","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606718794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1477612,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8b/ec/dc03f5ad.jpg","nickname":"张天屹","note":"","ucode":"8BD6BD6DCF0F4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1684122,"avatar":"","nickname":"Geek_4acf29","note":"","ucode":"C3C453557D052A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343238,"discussion_content":"我觉得Reborn 2.0说的是有道理的，你说的是失败的维度，可以通过MQ重试保证最终一致性。按照你的前提，延迟双删也可能在最后一次删除的时候失败（还多了一个风险，先于脏读线程执行空删除）。我也认为在不考虑操作失败的前提下，似乎先DB后redis更好","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1610971658,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":330837,"ip_address":""},"score":343238,"extra":""}]}]},{"had_liked":false,"id":254620,"user_name":"范闲","can_delete":false,"product_type":"c1","uid":1073125,"ip_address":"","ucode":"F21FD7DF6BA53C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","comment_is_top":false,"comment_ctime":1603158721,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31667929793","product_id":100056701,"comment_content":"更新步骤:<br>1.先更新缓存，再更新数据库<br>2.先更新数据库，再更新缓存<br><br>并发:<br>1.读+写<br>2.写+写<br>3.读+读<br>在并发情况下，3是肯定没有影响的。1和2肯定会对数据一致性有影响。这个时候可以利用分布式锁来处理。同一时刻一个key只有一把锁持有。","like_count":7},{"had_liked":false,"id":254170,"user_name":"不诉离殇","can_delete":false,"product_type":"c1","uid":1239350,"ip_address":"","ucode":"4F7BB1220ECED7","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/36/f62471c5.jpg","comment_is_top":false,"comment_ctime":1603076224,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"31667847296","product_id":100056701,"comment_content":"老师分析问题的思路很赞，但是我对于结论有一个很大的疑问，按照分析思路 ，既然对于读写缓存同步写回策略可以采用（分布式）事务来保证原子性，那么只读缓存的更新数据库和删除缓存的操作为什么不能采用事务来保证原子性？二者的思路差异在哪里？","like_count":7,"discussions":[{"author":{"id":2314145,"avatar":"https://static001.geekbang.org/account/avatar/00/23/4f/a1/6addd029.jpg","nickname":"Y娃","note":"","ucode":"E6056EBBB15509","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332803,"discussion_content":"同感，感觉原因就是保障原子性会导致性能下降很多，所以在某些不是特别重要的场景下，允许一小部分的数据出错","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1607342783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1809802,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/8a/a2d34896.jpg","nickname":"一元(wx:abley1874)","note":"","ucode":"5E7A33642FC767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558546,"discussion_content":"分布式锁本来就是一种解决方案，但并不适用于所有的场景，它虽然能够保证绝对的一致性，但是性能相对较差，而且维护一套分布式锁，相当复杂的。而采用删除缓存，性能更好，实现更简单，也能保证最终一致性，在很多一致性要求不那么高的场景下是是非常推荐的解决方案。\n\n类似于悲观锁和乐观锁的实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648374006,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2194764,"avatar":"","nickname":"K菌无惨","note":"","ucode":"97A532D588FD49","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345092,"discussion_content":"应该是要保证原子性的性能损耗太高了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611656129,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2110772,"avatar":"","nickname":"dfuru","note":"","ucode":"0222FADA093D95","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318290,"discussion_content":"也有此困惑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603698607,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253585,"user_name":"williamcai","can_delete":false,"product_type":"c1","uid":1158294,"ip_address":"","ucode":"B158F52C2D39BC","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/96/46b13896.jpg","comment_is_top":false,"comment_ctime":1602807341,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"27372611117","product_id":100056701,"comment_content":"老师你好，用事务保证数据库和redis一致，不可行呀<br>","like_count":6,"discussions":[{"author":{"id":1675882,"avatar":"https://static001.geekbang.org/account/avatar/00/19/92/6a/dd37a054.jpg","nickname":"张y .","note":"","ucode":"85918469492F4C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411505,"discussion_content":"是的，不可行，后续出异常，Redis没法回滚。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1635942693,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1046714,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","nickname":"约书亚","note":"","ucode":"81EA27ADD9EC1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347286,"discussion_content":"最终一致性的方案，不怕用旧值覆盖了新值么？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1612187887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2946110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VqX3Te4cje43vIWjbSJkQ6roYPD9XxkgvCutQNZu9icBYYSdLXiczbSVzXdSr53DmT8Y2OsSYmY8oib6KCRelFcPg/132","nickname":"Geek_506131","note":"","ucode":"16141124693437","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1046714,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","nickname":"约书亚","note":"","ucode":"81EA27ADD9EC1A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573670,"discussion_content":"兄弟你后面找到好的解决方案了吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653575585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":347286,"ip_address":""},"score":573670,"extra":""}]},{"author":{"id":1436839,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ec/a7/7d44c655.jpg","nickname":"snailshen","note":"","ucode":"C4875C476649B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":323577,"discussion_content":"通过mq最终一致性吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1604970537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2253496,"avatar":"","nickname":"Geek_3d87cb","note":"","ucode":"F09334D60C3BC8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":314738,"discussion_content":"得考虑分布式事务了,或者rocketmq的事务消息达到最终一致性","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603191604,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1508662,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqic8BwOdWJDVBy2H7X7N77ha6mm2kkJOaBqqcSBfphhTYv16KKuhBicN08pAxYmShTJYKMMwrDs6iaw/132","nickname":"Geek_51cc93","note":"","ucode":"DB1588A47E8B32","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":313078,"discussion_content":"对啊。 我也是这个疑问。    怎么保证啊？？？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602928520,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1239350,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e9/36/f62471c5.jpg","nickname":"不诉离殇","note":"","ucode":"4F7BB1220ECED7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1508662,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqic8BwOdWJDVBy2H7X7N77ha6mm2kkJOaBqqcSBfphhTYv16KKuhBicN08pAxYmShTJYKMMwrDs6iaw/132","nickname":"Geek_51cc93","note":"","ucode":"DB1588A47E8B32","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":313615,"discussion_content":"可以考虑分布式事务，2pc ，tcc等方案 但是都很复杂 特别是考虑并发的情况下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603076280,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":313078,"ip_address":""},"score":313615,"extra":""}]}]},{"had_liked":false,"id":253136,"user_name":"与路同飞","can_delete":false,"product_type":"c1","uid":1138821,"ip_address":"","ucode":"2985F1440A1962","user_header":"https://static001.geekbang.org/account/avatar/00/11/60/85/f72f1d94.jpg","comment_is_top":false,"comment_ctime":1602629687,"is_pvip":true,"discussion_count":10,"race_medal":0,"score":"27372433463","product_id":100056701,"comment_content":"如果业务层要求必须读取一致的数据，那么，我们就需要在更新数据库时，先在 Redis 缓存客户端暂存并发读请求，等数据库更新完，再读取数据，从而保证数据一致性。这个redis客户端暂存并发读请求咋弄","like_count":6,"discussions":[{"author":{"id":1065272,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/38/4f89095b.jpg","nickname":"写点啥呢","note":"","ucode":"C19032CF1C41BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312233,"discussion_content":"我觉得redis不支持rollback，如果业务有强一致性要求，对这样的数据不应该使用缓存","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1602636504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2049478,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/45/c6/ba5176a6.jpg","nickname":"从不卖萌","note":"","ucode":"E9B7B1C8FAFE0B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1065272,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/38/4f89095b.jpg","nickname":"写点啥呢","note":"","ucode":"C19032CF1C41BA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352169,"discussion_content":"是的，如果要求强一致，我也赞成不使用缓存，不然还是会出现不一致的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614614669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":312233,"ip_address":""},"score":352169,"extra":""}]},{"author":{"id":2308075,"avatar":"","nickname":"Geek_89e362","note":"","ucode":"E596C2CFE1CFAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348619,"discussion_content":"这个可以采用分布式锁的方式，或者使用 读写锁的思想，当存在写的时候进行加锁，那么后续的请求(读/写)，都进行阻塞。 但是这样会丢失一部分吞吐量。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1612667440,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1489957,"avatar":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","nickname":"tt","note":"","ucode":"7753B79AD5A9AC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312223,"discussion_content":"是不是就是加一个并发控制用的锁？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602634175,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":6,"child_discussions":[{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1489957,"avatar":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","nickname":"tt","note":"","ucode":"7753B79AD5A9AC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340102,"discussion_content":"可以采用write through方式将数据操作全部代理到redis缓存组件,这时更新数据库可以采用异步化,保证最终一致性即可 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609902938,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":312223,"ip_address":""},"score":340102,"extra":""},{"author":{"id":1489957,"avatar":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","nickname":"tt","note":"","ucode":"7753B79AD5A9AC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340764,"discussion_content":"write through是依靠lua脚本么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610123239,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":340102,"ip_address":""},"score":340764,"extra":""},{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1489957,"avatar":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","nickname":"tt","note":"","ucode":"7753B79AD5A9AC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340787,"discussion_content":"不是，write through是一种缓存策略（我也不知道咋翻译比较好😂），你可以看看酷壳上的缓存文章","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610159281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":340764,"ip_address":""},"score":340787,"extra":""}]}]},{"had_liked":false,"id":345044,"user_name":"Sancho","can_delete":false,"product_type":"c1","uid":1436391,"ip_address":"","ucode":"78849913082622","user_header":"https://static001.geekbang.org/account/avatar/00/15/ea/e7/9ce305ec.jpg","comment_is_top":false,"comment_ctime":1651978190,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"14536880078","product_id":100056701,"comment_content":"我和大家一样觉得“延时双删”方案不行。<br><br>在极客时间另一位老师傅的课学到一个方案，总结下来是这样的：<br><br>1.读操作时，先读缓存，缓存Miss，读DB。此时用SETNX写缓存，只有缓存中还没有时再会成功，操作缓存的优先级比较低；<br>2.写操作时，先删除缓存，再写DB成功，最后用SET写缓存；<br>3.订阅DB变更，用DB最终数据，SETEX操作刷新缓存。","like_count":3,"discussions":[{"author":{"id":1296635,"avatar":"https://static001.geekbang.org/account/avatar/00/13/c8/fb/1e282c37.jpg","nickname":"Jungggle","note":"","ucode":"CEF098BDED51BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586522,"discussion_content":"第2点先删不靠谱，靠谱的是第3点但是架子复杂了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662299963,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2012886,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/b6/d6/3b1fbf9b.jpg","nickname":"2018","note":"","ucode":"436D1F4CA63CB9","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573565,"discussion_content":"我觉得这个可以，可以发一下原链接么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653494002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1436391,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ea/e7/9ce305ec.jpg","nickname":"Sancho","note":"","ucode":"78849913082622","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2012886,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/b6/d6/3b1fbf9b.jpg","nickname":"2018","note":"","ucode":"436D1F4CA63CB9","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":573611,"discussion_content":"Go进阶训练营，毛剑大佬讲到的方法，我的课程过期点不开了，没有链接","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653545513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":573565,"ip_address":""},"score":573611,"extra":""}]}]},{"had_liked":false,"id":338288,"user_name":"wjunt928","can_delete":false,"product_type":"c1","uid":1682629,"ip_address":"","ucode":"E5EA59DED92233","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/iaIGmLFt6eQkoHmpgL9COich1HAC6JwBvg6FQph62wjsYlm3Es6v2m2u8T2rWkNpHiamRkw0Lnv5j7d7WeTKf1zqw/132","comment_is_top":false,"comment_ctime":1647407124,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"14532309012","product_id":100056701,"comment_content":"看了一堆评论，其实会发现讨论的时候，说着说着大家关于一致性的概念理解就发生变化了；<br>有时说的一致性指的是强一致性，有时说的一致性又是最终一致性，所以大家互觉得对方有问题；<br>(1)只要缓存和数据库更新有先后，就一定达不到强一致性(达到数据库和缓存在同一瞬间都更新的效果)；<br>(2)即便使用最终一致性，也有方法实现：<br>a.尽量降低出现长时间才能达到最终一致性的概率；<br>b.尽量减少达到最终一致性的时间；<br><br>所以才会有人认为延迟双删解决不了一致性，因为这个一致性指的是强一致性；<br>而老师专栏说延迟双删可以保证一致性，也仅仅是指&quot;减少数据库和缓存达到最终一致的时间&quot;；","like_count":4,"discussions":[{"author":{"id":2061045,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/72/f5/35f2f763.jpg","nickname":"路小鹿","note":"","ucode":"331F70041CE8DC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574795,"discussion_content":"反对。我们认为延迟双删解决不了一致性，并不是指强一致性。即使是最终一致性，延迟双删也解决不了。如果第二个线程读到数据库的旧数据后，由于网络原因，延迟了很久才去写缓存，这个“很久”超过了 sleep 时间，那此时数据将永远不一致。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1654347089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2943639,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/ea/97/a06ca54d.jpg","nickname":"欢乐每一天","note":"","ucode":"C63A4C3B4108F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2061045,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/72/f5/35f2f763.jpg","nickname":"路小鹿","note":"","ucode":"331F70041CE8DC","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":575666,"discussion_content":"赞同。双删+sleep的方案我觉得是最low的方案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655014793,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":574795,"ip_address":""},"score":575666,"extra":""}]}]},{"had_liked":false,"id":291849,"user_name":"何磊","can_delete":false,"product_type":"c1","uid":1047604,"ip_address":"","ucode":"78934C3ED4A342","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fc/34/c733b116.jpg","comment_is_top":false,"comment_ctime":1620550030,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14505451918","product_id":100056701,"comment_content":"双删太过于了。互联网场景基本用先更新db，再删除redis，基本可以保证数据的一致性。<br>理论上也存在并发导致的不一致问题，但是概率极低。至今我都没有遇到过","like_count":3,"discussions":[{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532625,"discussion_content":"redis删除操作基本就是网络开销而已,确实概率极低,Facebook有篇论文提到了这个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637656734,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253952,"user_name":"liudu_ec","can_delete":false,"product_type":"c1","uid":2041994,"ip_address":"","ucode":"E299071BD1DFA8","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJiaeTzf4V8ib4xKcYjWEIflBSqkjbpkscoaedppgnBAD9ZAibjYSz0DNSJQw8icz7xljEgbNQ5hrzPAA/132","comment_is_top":false,"comment_ctime":1602988724,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"14487890612","product_id":100056701,"comment_content":"蒋老师，问个问题，我现在是用缓存失效+ binlog 订阅更新缓存的，日常使用场景中，查询请求先查缓存，如果没有 就查数据库，数据库没有就会构建一条空缓存来保护数据库，<br>还有一种场景是使用pipeline批量查询缓存，如果存在某个key不存在的情况，应该怎么优雅处理？","like_count":3,"discussions":[{"author":{"id":1180810,"avatar":"https://static001.geekbang.org/account/avatar/00/12/04/8a/ff94bd60.jpg","nickname":"涛涛","note":"","ucode":"747C4B1F20A2D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532440,"discussion_content":"发送一个mq消息去异步修复一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637596425,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":277434,"user_name":"Mine","can_delete":false,"product_type":"c1","uid":1253597,"ip_address":"","ucode":"85C3A3117FD9CB","user_header":"https://static001.geekbang.org/account/avatar/00/13/20/dd/82d8eff2.jpg","comment_is_top":false,"comment_ctime":1612410960,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10202345552","product_id":100056701,"comment_content":"给缓存设置过期时间，即使更新完数据库数据之后，删除缓存失败，缓存在过期时间到了失效之后重新拉取最新的数据保证最终的一致性。","like_count":2},{"had_liked":false,"id":261913,"user_name":"石小","can_delete":false,"product_type":"c1","uid":1781893,"ip_address":"","ucode":"4258C686F289A6","user_header":"https://static001.geekbang.org/account/avatar/00/1b/30/85/14c2f16c.jpg","comment_is_top":false,"comment_ctime":1605577596,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10195512188","product_id":100056701,"comment_content":"老师好，给缓存做持久化，更新数据时只更新到缓存，之后由专门的进城进行刷到数据库；读取数据时也是从缓存读，读不到再从数据库读。这种方式有什么问题吗？","like_count":2},{"had_liked":false,"id":253785,"user_name":"慎独明强","can_delete":false,"product_type":"c1","uid":1965699,"ip_address":"","ucode":"DC2F7F2C0C8F60","user_header":"https://static001.geekbang.org/account/avatar/00/1d/fe/83/df562574.jpg","comment_is_top":false,"comment_ctime":1602895127,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10192829719","product_id":100056701,"comment_content":"总结一下:1.先删除缓存再更新或删除数据库，如果删除数据库失败，其他线程读取到数据库的旧值，我觉得不应该叫旧值，都没有更新成功，数据库事务应该要回滚，这次业务应该算失败。对业务没有影响。     2.先删除缓存再更新数据库的并发场景，需要延迟双删。延迟这个时间不好控制，也会出现早删除，也会造成数据不一致。  3.先更新数据库，再删除缓存，需要保持原子性，可以采用队列来保持最终一致性。  4.先更新数据库，后删除缓存，会出现并发读，数据库已经更新但缓存更新，可以采用将读写操作写到队列，队列来保证操作的有序性，需要考虑性能。  5.对于有并发读写请求，有两个思路，分布式锁来限制并发。或者采用redis读写，mysql只做备份，保持最终一致性。这需要考虑redis的高可用。","like_count":2},{"had_liked":false,"id":311555,"user_name":"ub8","can_delete":false,"product_type":"c1","uid":1481811,"ip_address":"","ucode":"0D937C3EAEB781","user_header":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","comment_is_top":false,"comment_ctime":1631282229,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5926249525","product_id":100056701,"comment_content":"延迟双删我擦笑死我了这个方案","like_count":1,"discussions":[{"author":{"id":1449940,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1f/d4/87759d78.jpg","nickname":"提桶男孩","note":"","ucode":"3F21C8BCFE2C8E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572722,"discussion_content":"所以朋友你用了什么方式？业务上碰到的是什么问题？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652931036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":290392,"user_name":"吃饭睡觉打酱油","can_delete":false,"product_type":"c1","uid":1071668,"ip_address":"","ucode":"95EC98C2B5045B","user_header":"https://static001.geekbang.org/account/avatar/00/10/5a/34/4cbadca6.jpg","comment_is_top":false,"comment_ctime":1619523673,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5914490969","product_id":100056701,"comment_content":"先更新数据库，再删除缓存这种，如果是缓存正好过期，来了一个读请求已经读到数据了，但是还没写入缓存，此时再来个并发更新数据库的操作，我们的写入缓存操作又在删除缓存之后，那最终，缓存的数据不就是旧数据了么？","like_count":1,"discussions":[{"author":{"id":2721944,"avatar":"","nickname":"zhu_zhu","note":"","ucode":"ABBCC7F05AFA5B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":398143,"discussion_content":"这就是为什么要延迟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632743973,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1014665,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/89/34f2cbcc.jpg","nickname":"杨宇","note":"","ucode":"EB74DF6E269F03","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388349,"discussion_content":"双删的第二次删除，也存在这个问题吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628729313,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":285841,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1617028624,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"5911995920","product_id":100056701,"comment_content":"我觉得专栏先定义了缓存数据一致性，这个是很有必要的，一种是缓存中有数据，且和数据库中一样；一种是缓存中没数据，数据库中是最新值。<br><br>在学习专栏之前，感觉只读缓存的数据一致性要好于读写缓存，而两种缓存模式如果想要保持一致性的话，都需要采用原子性的事务处理。<br><br>但是按照专栏的说法，其实是说读写缓存的同步写回策略可以保证缓存和数据库中的数据一致。<br><br>其实缓存一致性问题和其他的分布式一致性问题从本质上来看似乎是一样的。<br><br>对于课后题，只读缓存数据删改操作，如果在缓存中不是删除，而是更新，那么首先更新应该比删除慢，而且更新之后的数据其实不一定会在短时间内用得到。可能有个别的业务场景，比较适合缓存更新，但是更普遍的应该还是缓存删除。","like_count":1},{"had_liked":false,"id":277151,"user_name":"Geek_1e8830","can_delete":false,"product_type":"c1","uid":1506574,"ip_address":"","ucode":"CD84A5AAAE6872","user_header":"","comment_is_top":false,"comment_ctime":1612276693,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5907243989","product_id":100056701,"comment_content":"先删除缓存，在更新数据库失败，然后读取到旧值这不应该是正常的吗？既然数据库都更新失败了，那理所当然接下来获取到的肯定是旧值赛，没问题个人觉得这里。","like_count":1},{"had_liked":false,"id":263607,"user_name":"Henry","can_delete":false,"product_type":"c1","uid":1929375,"ip_address":"","ucode":"7C554C97935443","user_header":"https://static001.geekbang.org/account/avatar/00/1d/70/9f/741cd6a4.jpg","comment_is_top":false,"comment_ctime":1606196455,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5901163751","product_id":100056701,"comment_content":"好处：查询能立马命中缓存，请求不会打到数据库。<br>不足：假设请求1,2 分别更新，请求1 数据库将a改为b，请求2数据库将b改为c，请求2更新缓存，请求1更新缓存，造成数据不一致。","like_count":1},{"had_liked":false,"id":257685,"user_name":"曾轼麟","can_delete":false,"product_type":"c1","uid":1451391,"ip_address":"","ucode":"D418371AC11270","user_header":"https://static001.geekbang.org/account/avatar/00/16/25/7f/473d5a77.jpg","comment_is_top":false,"comment_ctime":1604056821,"is_pvip":false,"replies":[{"id":"98035","content":"是的，如果短时间内有频繁访问造成了过高的访问次数，这些数据也容易被滞留在缓存中，LFU会衰减访问次数，避免这些数据造成缓存污染。","user_name":"作者回复","user_name_real":"蒋德钧","uid":"1609687","ctime":1609111634,"ip_address":"","comment_id":257685,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5899024117","product_id":100056701,"comment_content":"老是Redis的LFU是做了优化的，访问次数会随着时间而递减，在updateLFU() -&gt;LFUDecrAndReturn()里面","like_count":1,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508414,"discussion_content":"是的，如果短时间内有频繁访问造成了过高的访问次数，这些数据也容易被滞留在缓存中，LFU会衰减访问次数，避免这些数据造成缓存污染。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609111634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253308,"user_name":"Dovelol","can_delete":false,"product_type":"c1","uid":1253384,"ip_address":"","ucode":"9B5DDF7720F307","user_header":"https://static001.geekbang.org/account/avatar/00/13/20/08/bc06bc69.jpg","comment_is_top":false,"comment_ctime":1602680258,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5897647554","product_id":100056701,"comment_content":"“应用要把数据 X 的值从 10 更新为 3，先在 Redis 缓存中删除了 X 的缓存值，但是更新数据库却失败了。如果此时有其他并发的请求访问 X，会发现 Redis 中缓存缺失，紧接着，请求就会访问数据库，读到的却是旧值 10”。老师好，这一段更新数据库失败说明数据库的值就是10，缓存删除了再从数据库读到的值就是10，这个怎么能说是旧值呢？这个流程就相当于是缓存被删了，数据库没修改那对数据一致性没有印象吧？","like_count":1},{"had_liked":false,"id":253162,"user_name":"那时刻","can_delete":false,"product_type":"c1","uid":1150927,"ip_address":"","ucode":"B0D150856C3A4A","user_header":"https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg","comment_is_top":false,"comment_ctime":1602639021,"is_pvip":false,"discussion_count":2,"race_medal":1,"score":"5897606317","product_id":100056701,"comment_content":"请问老师，在采用基于消息队列的重试机制来解决数据不一致问题时，在数据删除或更新，我们就要把这些值从消息队列中去除。如果数据已经成功的删除或者更新，但是在从消息队列删除过程失败，导致已经处理的消息依然在消息队列中，这种情况怎么处理呢？<br><br>我目前想到的是通过增加消息版本号来实现幂等操作。不知道有木有其它方法？","like_count":1,"discussions":[{"author":{"id":1477612,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8b/ec/dc03f5ad.jpg","nickname":"张天屹","note":"","ucode":"8BD6BD6DCF0F4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343243,"discussion_content":"消息队列现在一般采用的ACK机制，消费端回传一个ACK回去，MQ收到以后删除数据。但是网络可以假设不稳定，极端情况下ACK丢失，所以在消费端要想保证不重复，就要做幂等处理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610972232,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2253496,"avatar":"","nickname":"Geek_3d87cb","note":"","ucode":"F09334D60C3BC8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":314741,"discussion_content":"消息队列一般都是保证最少一条消息,有可能会出现消息重复问题,需要保证业务幂等","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603191716,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359328,"user_name":"Geek_d3fa34","can_delete":false,"product_type":"c1","uid":3195465,"ip_address":"广东","ucode":"892F598974E7AC","user_header":"","comment_is_top":false,"comment_ctime":1665448312,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665448312","product_id":100056701,"comment_content":"删改操作DB，读直接读缓存。 DB和缓存间用一个监听数据变更同步程序会好一点？","like_count":0},{"had_liked":false,"id":358051,"user_name":"Mr小公熊","can_delete":false,"product_type":"c1","uid":1624497,"ip_address":"卢森堡","ucode":"D3A170E3DA03F7","user_header":"https://static001.geekbang.org/account/avatar/00/18/c9/b1/ef6e5707.jpg","comment_is_top":false,"comment_ctime":1663849036,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663849036","product_id":100056701,"comment_content":"中科院？","like_count":0},{"had_liked":false,"id":341936,"user_name":"阿昕","can_delete":false,"product_type":"c1","uid":1012906,"ip_address":"","ucode":"F3AD093B68E074","user_header":"https://static001.geekbang.org/account/avatar/00/0f/74/aa/178a6797.jpg","comment_is_top":false,"comment_ctime":1649924864,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1649924864","product_id":100056701,"comment_content":"更新缓存在逻辑上更复杂一些，包括需要处理数据序列化的，本质上没有解决数据不一致的问题","like_count":0},{"had_liked":false,"id":340422,"user_name":"鲁桂林","can_delete":false,"product_type":"c1","uid":2682971,"ip_address":"","ucode":"96442F21D37C0F","user_header":"","comment_is_top":false,"comment_ctime":1648807105,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1648807105","product_id":100056701,"comment_content":"看完以后的感受就是 一致性问题并没有解决。另外，感觉延迟双删，并解决不了问题 感觉还不如先更新数据库，在删除缓存，代价更小一些","like_count":0},{"had_liked":false,"id":340174,"user_name":"粉红猪","can_delete":false,"product_type":"c1","uid":1652099,"ip_address":"","ucode":"355C1B87D3D0DE","user_header":"https://static001.geekbang.org/account/avatar/00/19/35/83/f2d7beac.jpg","comment_is_top":false,"comment_ctime":1648643498,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648643498","product_id":100056701,"comment_content":"这章我思考了很久，也看了一些其他的博客，稍稍的总结了下自己的思考，不知道对不对，还请蒋老师和各位大佬帮忙过过眼：<br>1.对于缓存的一致性要求要分开来看，如果一致性要求不那么高或者说并发较低，使用经典的旁路缓存模式即可完成一致性的要求，因为不一致的时间其实很短，很快它们就会被更新得一致。<br><br>2.但如果是要求强一致性，并且又处于高并发场景下，那么经典的旁路缓存模式中出现的较短的不一致的时间窗口就会被放大得很严重，会有较多请求的不一致，那么此时就需要由分布式锁来协调。我们可以对【读DB至更新缓存之间】、【写DB至删缓存之间】两个区间上分布式锁来使他们保持一致。<br><br>3.而同步写回时也通过加锁来处理，其实可以归类到2里面去。<br><br>4.异步写回的话，实际上这个时候Redis是作为数据库来用了，因此本身不能要求消息的强一致性，只能通过消息队列来达到最终一致性。","like_count":0},{"had_liked":false,"id":339961,"user_name":"张潇赟","can_delete":false,"product_type":"c1","uid":1132192,"ip_address":"","ucode":"1A45B57F9E0723","user_header":"https://static001.geekbang.org/account/avatar/00/11/46/a0/aa6d4ecd.jpg","comment_is_top":false,"comment_ctime":1648514119,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648514119","product_id":100056701,"comment_content":"个人观点，先操作缓存在操作数据库的流程。有先天缺陷，即使做了双删的策略也无法完全保证数据的一致性。为什么不采用先操作数据库在才做缓存的方案呢，这个方案肯定是可以得到最终一致的。","like_count":0},{"had_liked":false,"id":339504,"user_name":"家乐","can_delete":false,"product_type":"c1","uid":1301941,"ip_address":"","ucode":"94F8720B59F221","user_header":"https://wx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJia90ErsTQtNDNeyTWNwWjicERicXj72b4xgbvru2IkUdrLxrgJb5lCrTaiaW2iaX3mOYiaV8vYo3voWlg/132","comment_is_top":false,"comment_ctime":1648137125,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648137125","product_id":100056701,"comment_content":"又来温故一遍。说下题外话，即客买了很多课程学习，印象最深最好的是分布式数据库的王磊老师，MySQL的林晓彬老师，还有redis的蒋德钧老师。牛人最缺的品质就是谦逊。但这三位老师恰恰具备了。没有对比就没有伤害。","like_count":0},{"had_liked":false,"id":336935,"user_name":"Geek_64de3f","can_delete":false,"product_type":"c1","uid":1477505,"ip_address":"","ucode":"541835544BE692","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM4wTiaiadFDXTwFLM0eWE8ptbkRNxRxfIiccY4O3SGKecibOuqsrwShs3UPED7T9PgBwqH8Uaf5E99KBA/132","comment_is_top":false,"comment_ctime":1646479545,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1646479545","product_id":100056701,"comment_content":"「缓存中本身没有数据，那么，数据库中的值必须是最新值。」这里没懂，数据库里的值难道不是一直都是最新的？","like_count":0},{"had_liked":false,"id":332473,"user_name":"高杰","can_delete":false,"product_type":"c1","uid":2308772,"ip_address":"","ucode":"5C36D7B97B8459","user_header":"","comment_is_top":false,"comment_ctime":1643269296,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643269296","product_id":100056701,"comment_content":"看到评论里有很多疑问，我想先说一句，大家别忘了使用redis的目标是为了提高应用性能。<br>读缓存：是为了高并发读，在写数据时完全可以使用分布式事务保证redis和数据库的原子性，个人觉得这一步应该优先选择“先更新数据库+删除缓存+重试”，如果数据要求严格，再加上分布式事务来保证原子性。<br>读写缓存：这是读和写都要求高并发，如果采用同步直写策略，则失去了redis高并发写的意义。这就好比mysql主从复制一样，使用异步复制来达到高性能。<br>选择一个合适自己业务的方法，往往高性能和数据强一致性是矛盾的。。。。。","like_count":0},{"had_liked":false,"id":331569,"user_name":"Cxy","can_delete":false,"product_type":"c1","uid":1222478,"ip_address":"","ucode":"B90B914ABD1164","user_header":"https://static001.geekbang.org/account/avatar/00/12/a7/4e/aa9c0f43.jpg","comment_is_top":false,"comment_ctime":1642658726,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1642658726","product_id":100056701,"comment_content":"您好，疑问1 ： 读写缓存 -同步直写您给的方案是：采用事务保障一致性？那么如何做到？<br>         疑问2: 只读缓存-更新数据库与删除redis 为什么不能使用事务？","like_count":0},{"had_liked":false,"id":330594,"user_name":"Lee","can_delete":false,"product_type":"c1","uid":1344535,"ip_address":"","ucode":"6B8D59A0B1A1A9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqOn7k48KXia5rf0eXpzv2EGtqGibz3eNb8QnL8X72uia0g1rBwzXef4dV2JEdz3r4bu9GC1FLIeic4UA/132","comment_is_top":false,"comment_ctime":1642062227,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642062227","product_id":100056701,"comment_content":"有一个很基本的问题，读缓存和读写缓存，是站在客户端的角度说的，从数据库的角度，缓存一直都是可读写。另外，站在从库的角度，主从复制，从库也是可读写，是这样吧？","like_count":0},{"had_liked":false,"id":328208,"user_name":"树心","can_delete":false,"product_type":"c1","uid":1589523,"ip_address":"","ucode":"6C329F0FF798B9","user_header":"https://static001.geekbang.org/account/avatar/00/18/41/13/ab14ad25.jpg","comment_is_top":false,"comment_ctime":1640605744,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1640605744","product_id":100056701,"comment_content":"看了katio课代表的回答，如果对问题一头雾水可以分情况讨论","like_count":0},{"had_liked":false,"id":328206,"user_name":"树心","can_delete":false,"product_type":"c1","uid":1589523,"ip_address":"","ucode":"6C329F0FF798B9","user_header":"https://static001.geekbang.org/account/avatar/00/18/41/13/ab14ad25.jpg","comment_is_top":false,"comment_ctime":1640605347,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1640605347","product_id":100056701,"comment_content":"延迟双删有用吗？生产环境会用吗？感觉有点怪","like_count":0},{"had_liked":false,"id":327433,"user_name":"迷","can_delete":false,"product_type":"c1","uid":1294716,"ip_address":"","ucode":"F280A7D44470F9","user_header":"https://static001.geekbang.org/account/avatar/00/13/c1/7c/63f60a17.jpg","comment_is_top":false,"comment_ctime":1640134973,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640134973","product_id":100056701,"comment_content":"这个延时双删不太靠谱，如果想保证强一致，由延时双删：删缓存、更新数据库、sleep、再删缓存，改为：在读取写缓存处和更新数据删缓存处加分布式锁，保证更新缓存和更新数据库同步，是不是可以保证强一致？","like_count":0},{"had_liked":false,"id":325329,"user_name":"Geek_018298","can_delete":false,"product_type":"c1","uid":1693927,"ip_address":"","ucode":"02FE1726627515","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIg8jibDUq1QVY6Kjabg6kc66QfjibibNCKwbEPCBq6ejQzg5WDhIv9Nyv9icfJ5W98CFMDYaoITibD7kQ/132","comment_is_top":false,"comment_ctime":1638925719,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1638925719","product_id":100056701,"comment_content":"对于并发不高的场景，可以采用延时双删，这个sleep的范围也比较好控制，对于并发比较高的场景，应该采用双写策略，配合分布式锁，先更新缓存再更新DB","like_count":0},{"had_liked":false,"id":323373,"user_name":"Del皮耶罗","can_delete":false,"product_type":"c1","uid":1326223,"ip_address":"","ucode":"E90D6311ED875F","user_header":"https://static001.geekbang.org/account/avatar/00/14/3c/8f/be719404.jpg","comment_is_top":false,"comment_ctime":1637858506,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637858506","product_id":100056701,"comment_content":"只读缓存的删改数据的情况，可以用分布式事务解决吗？","like_count":0},{"had_liked":false,"id":322936,"user_name":"InfoQ_小汤","can_delete":false,"product_type":"c1","uid":1739070,"ip_address":"","ucode":"E4C30DB7A9B54C","user_header":"https://static001.geekbang.org/account/avatar/00/1a/89/3e/0dd8e96b.jpg","comment_is_top":false,"comment_ctime":1637666300,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637666300","product_id":100056701,"comment_content":"说实话没看明白老师说的延时双删 b线程读取a更新以后的值会把新值写入缓存 但是a再更新数据库以前已经删除了旧值 sleep以后以后再次删除不是又把缓存删除了么","like_count":0},{"had_liked":false,"id":321743,"user_name":"授人以🐟，不如授人以渔","can_delete":false,"product_type":"c1","uid":1193874,"ip_address":"","ucode":"BD53829E924B66","user_header":"https://static001.geekbang.org/account/avatar/00/12/37/92/961ba560.jpg","comment_is_top":false,"comment_ctime":1637029533,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1637029533","product_id":100056701,"comment_content":"既然是拿「删除缓存值」和「更新缓存值」做比较，提到「更新缓存值」需要确保缓存和数据库中的数据是一致，那「删除缓存值」也需要确保数据一致的，毕竟删除缓存值的操作可能会失败。如此看来，其实两种策略并没有好坏之分。如果删除或更新缓存值失败了，那么缓存中存的是旧值。","like_count":0},{"had_liked":false,"id":319806,"user_name":"遥不可及@","can_delete":false,"product_type":"c1","uid":2821140,"ip_address":"","ucode":"2F345AE67C39D2","user_header":"https://static001.geekbang.org/account/avatar/00/2b/0c/14/74ccb737.jpg","comment_is_top":false,"comment_ctime":1635949406,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1635949406","product_id":100056701,"comment_content":"我就一个问题延迟双删第一次删除有什么用吗<br>无论删还是不删更新完数据库后缓存里的数据都有可能是无效的 直接更新完数据后延迟删除不就好了<br><br>因为这个期间无论读缓存还是db读到的数据都有可能是无效数据  感觉没有必要吧请求交给db来处理","like_count":0,"discussions":[{"author":{"id":1693927,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIg8jibDUq1QVY6Kjabg6kc66QfjibibNCKwbEPCBq6ejQzg5WDhIv9Nyv9icfJ5W98CFMDYaoITibD7kQ/132","nickname":"Geek_018298","note":"","ucode":"02FE1726627515","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536975,"discussion_content":"第一次删除是为了防止DB操作成功后删除缓存失败","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638925447,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":316670,"user_name":"不是党员","can_delete":false,"product_type":"c1","uid":1257945,"ip_address":"","ucode":"1C8DD42D693FFA","user_header":"https://static001.geekbang.org/account/avatar/00/13/31/d9/1a748694.jpg","comment_is_top":false,"comment_ctime":1634482956,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634482956","product_id":100056701,"comment_content":"情况二：先更新数据库值，再删除缓存值。<br>如果线程 A 删除了数据库中的值，但还没来得及删除缓存值，线程 B 就...<br><br>…………………………………………分割线…………………………………………<br><br>不是在讨论更新数据库么？怎么又线程 A 删除了数据库中的值 ？是写错了还是我没理解，请指导<br>","like_count":0},{"had_liked":false,"id":313249,"user_name":"用户6109996491","can_delete":false,"product_type":"c1","uid":1939179,"ip_address":"","ucode":"BDB4FFA1661DC7","user_header":"https://static001.geekbang.org/account/avatar/00/1d/96/eb/bd1b344f.jpg","comment_is_top":false,"comment_ctime":1632326842,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632326842","product_id":100056701,"comment_content":"我就是不太明白，sleep既然可以解决。","like_count":0},{"had_liked":false,"id":310953,"user_name":"郑印","can_delete":false,"product_type":"c1","uid":1005282,"ip_address":"","ucode":"181B0FDE5E1532","user_header":"https://static001.geekbang.org/account/avatar/00/0f/56/e2/2dcab30d.jpg","comment_is_top":false,"comment_ctime":1630999431,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630999431","product_id":100056701,"comment_content":"不知道为什么，很多文章都会把延迟双删，这种没有实际意义解决方案拿出来讨论~","like_count":0},{"had_liked":false,"id":308973,"user_name":"Geek_72b9a7","can_delete":false,"product_type":"c1","uid":2105175,"ip_address":"","ucode":"4C26B79F9F15A9","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/40ab8h1zbSUZmzxARyicDuXECYwtQNDd9jxAbys5LMnVLJMmibTCHd1icrRZMnMSvTJ27UdITA0439hAaVIxcOkGQ/132","comment_is_top":false,"comment_ctime":1629877120,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629877120","product_id":100056701,"comment_content":"当消息不自动ack时，如果更新db&#47;redis失败了，消息是不会丢失的，重回队列后可再次读取处理。","like_count":0},{"had_liked":false,"id":307654,"user_name":"Ethan New","can_delete":false,"product_type":"c1","uid":2063962,"ip_address":"","ucode":"9CA2EF39E58030","user_header":"https://static001.geekbang.org/account/avatar/00/1f/7e/5a/da39f489.jpg","comment_is_top":false,"comment_ctime":1629190779,"is_pvip":true,"discussion_count":0,"race_medal":4,"score":"1629190779","product_id":100056701,"comment_content":"问题：既然读写缓存可以使用事务机制，来保证缓存和数据库的更新具有原子性，那为什么只读缓存不能使用事务机制，来保证缓存删除和数据库的更新具有一致性呢？","like_count":0},{"had_liked":false,"id":305380,"user_name":"jun.hai","can_delete":false,"product_type":"c1","uid":1702947,"ip_address":"","ucode":"9740C5118DE6DC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epx1w8VkC30tcu4GlOCkUZB7picI2xesBBZF3rGWVPp9tHZfJdkc5iaqhSg7LOsvtefiajkM1YPno2JA/132","comment_is_top":false,"comment_ctime":1627954470,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1627954470","product_id":100056701,"comment_content":"老师好，在redis中热点数据怎么处理比较好，例如：有300W数据其中15～20W数据是热点数据，这个怎么处理比较好呢？","like_count":0,"discussions":[{"author":{"id":3201606,"avatar":"","nickname":"Geek_c5eb91","note":"","ucode":"650C7D09442F51","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591142,"discussion_content":"忽略","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666321870,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江西"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532624,"discussion_content":"定期提前预热","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637656614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":302617,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1626302457,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1626302457","product_id":100056701,"comment_content":"redis缓存一致性，除非是严格的事务一致性，否则是没办法保证严格的一致性的。<br>无论是重试，双删策略，都会存在短时间的不一致。<br>双删，在高并发的时候，写线程第二删除的时候即使sleep一段时间。<br>如果第二个另外一个线程先读取了数据(第一次删除后，更新数据库数据前，第二次删除前)，然后尝试加载数据，此时加载的是旧数据，然后这个线程尝试写入到缓存，这个写入即使第一个写线程sleep一段时间，还是有可能在这个sleep时间后，这个线程才进行写入的。<br>","like_count":0},{"had_liked":false,"id":302398,"user_name":"八百","can_delete":false,"product_type":"c1","uid":1253530,"ip_address":"","ucode":"79F1F79ADF5A00","user_header":"https://static001.geekbang.org/account/avatar/00/13/20/9a/3b1c65fd.jpg","comment_is_top":false,"comment_ctime":1626190477,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626190477","product_id":100056701,"comment_content":"看业务对数据一致性的容忍度，数据的读写量再考虑采用哪种方案。","like_count":0},{"had_liked":false,"id":300327,"user_name":"喰","can_delete":false,"product_type":"c1","uid":2659564,"ip_address":"","ucode":"6133C265D4D63D","user_header":"https://static001.geekbang.org/account/avatar/00/28/94/ec/8db3f04a.jpg","comment_is_top":false,"comment_ctime":1625120506,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625120506","product_id":100056701,"comment_content":"老师您好， 关于延迟双删我又一个疑问，我想请问一下线程A在更新完数据库后不延迟直接在删除一次缓存不可以吗？ 因为如果更新完数据库后在一次删除缓存，如果缓存里面有说明有其它线程操作了该数据，当然有可能是最新值也有可能是文章中提到的被缓存了旧值，不管它是新值或者旧值都直接删除这样不行吗？ 为什么要延迟呢？ 或者在再一次删除的时候如果缓存里面有值，那么用这个值和更新的值比较一下是最新的就不删除不是就删除这样可以吗？  还有redis在强一致性的情况下如何暂存读请求呢？","like_count":0},{"had_liked":false,"id":300079,"user_name":"张华清","can_delete":false,"product_type":"c1","uid":1212657,"ip_address":"","ucode":"AD7021EF2A0388","user_header":"https://static001.geekbang.org/account/avatar/00/12/80/f1/19c42f40.jpg","comment_is_top":false,"comment_ctime":1624976757,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624976757","product_id":100056701,"comment_content":"有个概念上的模糊，根据是否接受写请求分为只读缓存和读写缓存，在文中只读模式中，读取缓存未命中后，从数据库里面拿出来放到redis中不就是个写操作么","like_count":0},{"had_liked":false,"id":297839,"user_name":"ppingfann","can_delete":false,"product_type":"c1","uid":1242999,"ip_address":"","ucode":"38DE7D2F6D22E4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo435IStLENgI45dWOow9gPDh8RcqvuCOLp30XqLJK3wqmwO7QKRLx8sMg9eucMKnJdjwickrAQMBw/132","comment_is_top":false,"comment_ctime":1623809042,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623809042","product_id":100056701,"comment_content":"你好，我想问一下关于读写缓存的异步写回策略。<br>如果A在删除了缓存中的某个数据后，在它还没有写回到数据库之前，如果有另一个B去查询了这个数据，那么会不会出现B又把数据捞回缓存的情况呢？","like_count":0},{"had_liked":false,"id":296022,"user_name":"凯文小猪","can_delete":false,"product_type":"c1","uid":1980201,"ip_address":"","ucode":"36D8AD0229547F","user_header":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","comment_is_top":false,"comment_ctime":1622708183,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622708183","product_id":100056701,"comment_content":"针对双写的场景 实际上就是一个write through的实现 但实际场景往往是做不到的。<br>原因如下：<br>1. 如果数据库更新成功 redis更新失败 那么就意味着此时要回滚数据库或者重试redis 。这种处理往往会带入不必要冗余 而且会有死循环问题。<br>2.数据库更新成功 redis更新失败 对于读线程来说此时会拿到老值 引发更大的问题","like_count":0},{"had_liked":false,"id":295940,"user_name":"悟空聊架构","can_delete":false,"product_type":"c1","uid":1123163,"ip_address":"","ucode":"C2F482A0CF8AF1","user_header":"https://static001.geekbang.org/account/avatar/00/11/23/5b/983408b9.jpg","comment_is_top":false,"comment_ctime":1622673959,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1622673959","product_id":100056701,"comment_content":"直接更新缓存的值，你觉得和删除缓存值相比，有什么好处和不足吗？<br><br>好处：下次读取缓存时，可以直接命中，少了一次从数据库中读取数据放到缓存的操作。<br>不足：更新缓存会存在并发更新的可能，导致缓存和数据库中的不一致，可以考虑用分布式锁来避免这种情况。","like_count":0,"discussions":[{"author":{"id":2425143,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/ax8hKssnRFGUJvb0mQFZltpcnA7kyAR6Mx24gRpVwjUjRSFpZsF667IIZaCdpoamiaiaYnTqwHzOF1eFd6KYggow/132","nickname":"Geek_0902d9","note":"","ucode":"7D65F39B5955D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385797,"discussion_content":"是你吗，公众号","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627279572,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295566,"user_name":"金时","can_delete":false,"product_type":"c1","uid":1120428,"ip_address":"","ucode":"3491B2367A7238","user_header":"https://static001.geekbang.org/account/avatar/00/11/18/ac/4d68ba46.jpg","comment_is_top":false,"comment_ctime":1622477058,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622477058","product_id":100056701,"comment_content":"文中有这样一句话<br>“如果业务应用中读取数据库和写缓存的时间不好估算，那么，延迟双删中的等待时间就不好设置。“<br><br>请问下，延迟双删的时间和 业务读取和写缓存有什么关系？这个时间随意设置一个值不可以吗？没懂。","like_count":0},{"had_liked":false,"id":292362,"user_name":"王东","can_delete":false,"product_type":"c1","uid":1795357,"ip_address":"","ucode":"EF149E179D568E","user_header":"https://static001.geekbang.org/account/avatar/00/1b/65/1d/34ac9c2b.jpg","comment_is_top":false,"comment_ctime":1620792587,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1620792587","product_id":100056701,"comment_content":" 延迟双删的解释：<br>线程A：<br>1. 删缓存<br><br>线程B<br>1. 发现缓存不存在, 读取db<br><br>线程A:<br>1. 更新db<br><br>线程B<br>2. 将旧数据更新到redis. <br><br>线程A<br>3. 删除缓存。 <br><br>线程A步骤3-线程A步骤2的时间间隔必须大于线程B步骤2-线程A步骤2的时间，<br>即保证插入旧缓存的时间，一定在sleep结束之前。 <br>","like_count":0},{"had_liked":false,"id":289983,"user_name":"夏天","can_delete":false,"product_type":"c1","uid":2542376,"ip_address":"","ucode":"5F224DDAC94DFF","user_header":"https://static001.geekbang.org/account/avatar/00/26/cb/28/21a8a29e.jpg","comment_is_top":false,"comment_ctime":1619308618,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1619308618","product_id":100056701,"comment_content":"由于 sql 不同或者 db 压力很可能导致更新时间不同。sleep 只能降低概率。只能说没见过这么用的。如果你的系统不是异步，sleep 就坑了。大家多思考吧！","like_count":0},{"had_liked":false,"id":287180,"user_name":"wilson","can_delete":false,"product_type":"c1","uid":1009554,"ip_address":"","ucode":"F582F485FD44CF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/92/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1617806334,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617806334","product_id":100056701,"comment_content":"保证一致性的方法我认为有三<br>1）用数据库事务保证<br>2）用分布式锁<br>3）CDC，比如mysql binlog事件流","like_count":0},{"had_liked":false,"id":286615,"user_name":"脱缰的野马__","can_delete":false,"product_type":"c1","uid":1447569,"ip_address":"","ucode":"D5F993E7232C61","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/WtHCCMoLJ2DvzqQwPYZyj2RlN7eibTLMHDMTSO4xIKjfKR1Eh9L98AMkkZY7FmegWyGLahRQJ5ibPzeeFtfpeSow/132","comment_is_top":false,"comment_ctime":1617430577,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1617430577","product_id":100056701,"comment_content":"严格来说，在极端情况下，延迟双删还是会存在数据不一致情况！比如:A线程删除了缓存，准备更新数据库之前，B线程进来没有缓存命中，去数据库查找到了旧值，但是B在准备更新缓存时，因为被阻塞了(很有可能，因为从查库到更新缓存之间，可能你写的逻辑中还有进行耗时的运算，io请求，都可能出现阻塞问题！)，这时候A更新了数据库，sleep了，然后删除缓存，这时候B拿着旧一个再来更新缓存，就导致了数据不一致问题！","like_count":0,"discussions":[{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385790,"discussion_content":"所以sleep的时间要大于b从数据库读取+更新缓存的时间","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627274786,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":286017,"user_name":"达叔灬","can_delete":false,"product_type":"c1","uid":2404887,"ip_address":"","ucode":"5CCBAF13548F02","user_header":"https://static001.geekbang.org/account/avatar/00/24/b2/17/3161b49c.jpg","comment_is_top":false,"comment_ctime":1617107656,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617107656","product_id":100056701,"comment_content":"可以优先写入或修改redis缓存并且设置一个极短的过期时间（根据操作完成的时间来确定）而后在完成操作后删除缓存。","like_count":0},{"had_liked":false,"id":285844,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1617029877,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1617029877","product_id":100056701,"comment_content":"缓存雪崩的概念比较形象化，容易理解。<br><br>服务降级和请求限流有点类似，但是处理方式不同，服务降级是将非核心业务暂停，而请求限流则不区分业务类型，直接限制进入系统（后端）的请求数。<br><br>缓存击穿和缓存雪崩有点类似，如果从字面上理解，雪崩是大面积的缓存失效（超期）造成的，而击穿可能是针对热点数据（超期或无法处理）。<br><br>缓存穿透的概念我之前没有想的特别清楚，在这里得到了解惑。<br><br>布隆过滤器在这里的解释比较简单，如果想要详细的说明，出门右转《数据结构与算法之美》专栏里面有详细的说明。<br><br>对于课后题，应对缓存穿透问题，服务熔断、服务降级和请求限流都可以使用，能够在一定程度上保证系统的最小可用性，但是并不能有效的解决穿透的问题。<br><br>课代表补充一种缓存穿透的场景，就是用户在新业务模块没有业务数据的情况，不过我觉的这个严格来说应该不算是缓存穿透，可能归类到缓存冷启动更合适。<br><br>其实不光是应对缓存的故障，对于大一些的分布式系统，应对各类故障可能都会考虑请求限流、服务降级和服务熔断策略。","like_count":0},{"had_liked":false,"id":284134,"user_name":"轨迹","can_delete":false,"product_type":"c1","uid":1738455,"ip_address":"","ucode":"6C9619A0B60CDD","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/d7/bfd9e42a.jpg","comment_is_top":false,"comment_ctime":1616074603,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616074603","product_id":100056701,"comment_content":"我觉得一致性的解决方案还是使用事务和分布式锁，事务保证一致性和原子性，分布式锁保证有序性，排除并发情况。<br>对于只读缓存，先操作数据库，成功后再更新或者删除缓存，如果缓存操作失败，则回滚数据库事务。<br>对于读写缓存，直接在缓存上更新数据的操作，如果想要避免数据丢失(除非开始AOF同步写always)，需要采用同步写数据库的方式，但是这样的话，直接操作缓存的意义何在？","like_count":0},{"had_liked":false,"id":283529,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1615809168,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1615809168","product_id":100056701,"comment_content":"文章最后，怎么暂存并发读请求呢？求解","like_count":0,"discussions":[{"author":{"id":1437292,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ee/6c/246fa0d1.jpg","nickname":"Mr.差不多","note":"","ucode":"946555FCAE710B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542076,"discussion_content":"并发控制，要么加锁，要么串行化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640659068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":282139,"user_name":"十一","can_delete":false,"product_type":"c1","uid":1988912,"ip_address":"","ucode":"E48BE765F99BC8","user_header":"https://static001.geekbang.org/account/avatar/00/1e/59/30/7297937b.jpg","comment_is_top":false,"comment_ctime":1615106085,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615106085","product_id":100056701,"comment_content":"请问一下老师，在线程 A 更新完数据库值以后，我们可以让它先 sleep 一小段时间，再进行一次缓存删除操作。是不是没法解决线程B读取到旧值的情况，如果想解决这个问题，应该怎么操作？","like_count":0},{"had_liked":false,"id":278663,"user_name":"曾泽浩","can_delete":false,"product_type":"c1","uid":1104601,"ip_address":"","ucode":"A7E5CF9E1571A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/da/d9/f051962f.jpg","comment_is_top":false,"comment_ctime":1613186195,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613186195","product_id":100056701,"comment_content":"老师可以给一下具体的代码案例吗？","like_count":0},{"had_liked":false,"id":277797,"user_name":"neohope","can_delete":false,"product_type":"c1","uid":1043475,"ip_address":"","ucode":"C0268F6E7E2B6E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","comment_is_top":false,"comment_ctime":1612593567,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612593567","product_id":100056701,"comment_content":"数据在删改操作时，如果不是删除缓存值，而是直接更新缓存的值，你觉得和删除缓存值相比，有什么好处和不足？<br><br>不足：<br>1、redis没有事务支持，高并发时候，直接修改redis值很容易引起问题。可能需要自己维护数据版本号，做个并发控制<br>2、数据库操作的先后顺序，并不一定是redis操作的先后顺序，redis数值会有问题。除非自己实现一个串行控制<br>3、数据库事务执行完毕，再操作redis，总归有时间差，总归有短暂不一致性发生<br>4、redis操作不一定成功，比如更新后，需要更大的内存，但redis内存满了，这时就无法一致。只能删key。<br>总起来说，不建议第三方去实现数据库与redis的一致性，费力不讨好。最好由redis层面去实现redis与数据库的一致性。<br><br>优点：<br>1、key一直在线，减少了对数据库的压力；大量修改，很少读取的数据不建议放入redis","like_count":0},{"had_liked":false,"id":277665,"user_name":"小可","can_delete":false,"product_type":"c1","uid":1006735,"ip_address":"","ucode":"8834AF621FA67D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/8f/551b5624.jpg","comment_is_top":false,"comment_ctime":1612512208,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612512208","product_id":100056701,"comment_content":"只读缓存数据不一致问题自我总结：<br><br>一、操作缓存或DB，其中一个失败，无并发访问<br>1.产生过程<br>①先删缓存，DB修改失败，读到旧值，数据不一致，缓存DB均为旧值；<br>②先修改DB，缓存删除失败，读到旧值，数据不一致，缓存旧值，DB新值；<br>2.解决办法：<br>①将要修改数据发送值MQ，两步都成功时再移除，否则重试；<br>②重试超过一定次数也从MQ移除，发生业务层告警<br><br>二、操作缓存和DB都成功，但多线程并发访问<br>1.产生过程<br>①T1先删缓存；T2读缓存，读不到读DB，读到旧值，并更新到缓存；T1写DB；缓存旧值，DB新值，数据不一致，后续其他线程还有可能读到旧值<br>②T1先写DB；T2读缓存，读到旧值；T1删缓存；后续读取从DB load，值正常，影响小<br>2.对应解决办法：<br>①针对先删缓存的情况，采用延迟双删：更新完DB后，sleep一会，再删除一次，制造缓存缺失，从DB load；sleep时间根据运行时线程读数据和写缓存的操作时间统计确定<br><br>优先方案：使用只读缓存，先更新DB，删除缓存，失败入MQ重试；业务强一致要求，更新DB时，暂存并发读请求，等更新完DB删除完缓存，再读缓存从db load","like_count":0},{"had_liked":false,"id":275184,"user_name":"Geek_a499e7","can_delete":false,"product_type":"c1","uid":2297362,"ip_address":"","ucode":"5BF5B3248E4C64","user_header":"","comment_is_top":false,"comment_ctime":1611375555,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611375555","product_id":100056701,"comment_content":"只读缓存可以在业务上使用事务解决不一致情况吗","like_count":0},{"had_liked":false,"id":271806,"user_name":"之渊","can_delete":false,"product_type":"c1","uid":1876212,"ip_address":"","ucode":"02B9299DBB4881","user_header":"https://static001.geekbang.org/account/avatar/00/1c/a0/f4/7e122a67.jpg","comment_is_top":false,"comment_ctime":1609816091,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609816091","product_id":100056701,"comment_content":"还是感觉先删除缓存，再更新数据库更好，一般情况都够用了，防止并发就延迟双删。如果需要保证并发强一致性和性能，那么就可以在读的时候，发现缓存没有，去数据库读到值，写入缓存的时候，使用分布式锁或者其他标识符，防止在 更新的时候，其他读的线程将旧值写入缓存了，导致缓存存的是旧值。<br>即 更新的数据库值时候， 加一个分布式锁， 其他读线程 读了数据库值，写入redis前，需要获取分布式锁，获取到锁才可以写入 redis 缓存，否则就只直接返回。","like_count":0},{"had_liked":false,"id":270748,"user_name":"marker","can_delete":false,"product_type":"c1","uid":1094478,"ip_address":"","ucode":"DDBF1CD83665C4","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/4e/5f22b09d.jpg","comment_is_top":false,"comment_ctime":1609235996,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1609235996","product_id":100056701,"comment_content":"我认为应该做一个队列，还是走先删缓存在更新数据库，做一个队列吧更新和请求窜行划。请求做一个短暂的停顿，如果时间到了直接去数据库取。中间涉及了一些逻辑。猜想老师应该明白了","like_count":0},{"had_liked":false,"id":266448,"user_name":"Y娃","can_delete":false,"product_type":"c1","uid":2314145,"ip_address":"","ucode":"E6056EBBB15509","user_header":"https://static001.geekbang.org/account/avatar/00/23/4f/a1/6addd029.jpg","comment_is_top":false,"comment_ctime":1607342666,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607342666","product_id":100056701,"comment_content":"延迟双删，那还有一些并发请求，比如B取到了一个错误值？？？但是这是可以容忍的意思？","like_count":0},{"had_liked":false,"id":263150,"user_name":"yyl","can_delete":false,"product_type":"c1","uid":1170843,"ip_address":"","ucode":"1741DACDFCA9AF","user_header":"https://static001.geekbang.org/account/avatar/00/11/dd/9b/0bc44a78.jpg","comment_is_top":false,"comment_ctime":1606023722,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606023722","product_id":100056701,"comment_content":"解答：<br>直接更新缓存值 和删除缓存值相比，<br>好处：redis处理相对更加高效<br>不足：会存在更多的内存碎片","like_count":0},{"had_liked":false,"id":259800,"user_name":"Knuth","can_delete":false,"product_type":"c1","uid":1083616,"ip_address":"","ucode":"21298EF9BBB91A","user_header":"https://static001.geekbang.org/account/avatar/00/10/88/e0/292508a4.jpg","comment_is_top":false,"comment_ctime":1604840083,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1604840083","product_id":100056701,"comment_content":"建议楼主看看memcache在fb的那篇论文","like_count":0,"discussions":[{"author":{"id":1521451,"avatar":"https://static001.geekbang.org/account/avatar/00/17/37/2b/b32f1d66.jpg","nickname":"Ball","note":"","ucode":"1EE949E68D84CA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336450,"discussion_content":"链接发一下哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608599119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1521451,"avatar":"https://static001.geekbang.org/account/avatar/00/17/37/2b/b32f1d66.jpg","nickname":"Ball","note":"","ucode":"1EE949E68D84CA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340105,"discussion_content":"https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf\n\n结合这篇看看吧https://coolshell.cn/articles/17416.html","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609903661,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":336450,"ip_address":""},"score":340105,"extra":""},{"author":{"id":2049478,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/45/c6/ba5176a6.jpg","nickname":"从不卖萌","note":"","ucode":"E9B7B1C8FAFE0B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352171,"discussion_content":"文章很好，多谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614615081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":340105,"ip_address":""},"score":352171,"extra":""}]}]},{"had_liked":false,"id":259423,"user_name":"寻梦·阳溪","can_delete":false,"product_type":"c1","uid":1331268,"ip_address":"","ucode":"CB056C8638E86C","user_header":"https://static001.geekbang.org/account/avatar/00/14/50/44/99e4f560.jpg","comment_is_top":false,"comment_ctime":1604722381,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604722381","product_id":100056701,"comment_content":"只读缓存，先更新数据库、再删除缓存， 数据库更新成功后，<br>1、尚未删除缓存、有并发读请求，并发请求从缓存中读到旧值，这里不能称之为旧值吧， 数据库操作与缓存的删除放置在同一个事务中，数据库操作完成后，缓存尚未执行删除，那么数据库的事务也尚未提交， 从事务隔离来说，数据库设置为read commited，并发线程本就不应该脏读到新值；<br>2、尚未删除缓存、且后续缓存删除失败， 此时回滚数据库","like_count":0},{"had_liked":false,"id":256655,"user_name":"dfuru","can_delete":false,"product_type":"c1","uid":2110772,"ip_address":"","ucode":"0222FADA093D95","user_header":"","comment_is_top":false,"comment_ctime":1603698147,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603698147","product_id":100056701,"comment_content":"若直接更新缓存，缓存就变成了读写缓存。","like_count":0},{"had_liked":false,"id":256382,"user_name":"我是小妖怪🇨🇳","can_delete":false,"product_type":"c1","uid":1758660,"ip_address":"","ucode":"A5381FA2D2C713","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d5/c4/62b2cd5a.jpg","comment_is_top":false,"comment_ctime":1603614456,"is_pvip":false,"replies":[{"id":"93766","content":"加油！","user_name":"作者回复","user_name_real":"蒋德钧","uid":"1609687","ctime":1604028274,"ip_address":"","comment_id":256382,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1603614456","product_id":100056701,"comment_content":"加油！坚持就是胜利","like_count":0,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508009,"discussion_content":"加油！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604028274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":254791,"user_name":"大饶Raysir","can_delete":false,"product_type":"c1","uid":1589208,"ip_address":"","ucode":"0AFA191420A30D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTITcwicqBDYzXtLibUtian172tPs7rJpqG1Vab4oGjnguA9ziaYjDCILSGaS6qRiakvRdUEhdmSG0BGPKw/132","comment_is_top":false,"comment_ctime":1603187479,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603187479","product_id":100056701,"comment_content":"直接更新缓存，对于业务请求来说响应更快，能避免缓存未命中查询数据库的场景，这种场景下对redis的数据准确性的要求就更高了，业务必须得保证缓存设置的操作能成功","like_count":0},{"had_liked":false,"id":254401,"user_name":"wesley","can_delete":false,"product_type":"c1","uid":1439353,"ip_address":"","ucode":"102E5F24FE7EBD","user_header":"https://static001.geekbang.org/account/avatar/00/15/f6/79/43fc66d3.jpg","comment_is_top":false,"comment_ctime":1603111521,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1603111521","product_id":100056701,"comment_content":"老师您好，请教一个面试中遇到的问题<br>在数据库主从同步的情况下，如果采用先更新数据库再删除缓存的处理，如何保证得到的缓存是新值？<br>这个我先行在网上搜索了一下，有博客说可以订阅主库的binlog，然后根据binlog去删除缓存<br>不知道这种是不是最优解","like_count":0,"discussions":[{"author":{"id":2326907,"avatar":"","nickname":"Geek_bbd494","note":"","ucode":"148EA9397207A8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330746,"discussion_content":"还可以异步sleep一段时间，时间是主从延时加个几百毫秒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606702549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":254285,"user_name":"东","can_delete":false,"product_type":"c1","uid":1043947,"ip_address":"","ucode":"0FF5018422CEA9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/eb/88cac7a5.jpg","comment_is_top":false,"comment_ctime":1603096160,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603096160","product_id":100056701,"comment_content":"使用消息队列那个图，是不是先删除缓存，如果删除缓存失败再放入队列会更加经济一些？毕竟删除操作通常代价更低，至少不比放入队列代价高。而且通常情况下，大概率会删除成功。","like_count":0},{"had_liked":false,"id":253877,"user_name":"Geek_51cc93","can_delete":false,"product_type":"c1","uid":1508662,"ip_address":"","ucode":"DB1588A47E8B32","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqic8BwOdWJDVBy2H7X7N77ha6mm2kkJOaBqqcSBfphhTYv16KKuhBicN08pAxYmShTJYKMMwrDs6iaw/132","comment_is_top":false,"comment_ctime":1602927407,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"1602927407","product_id":100056701,"comment_content":"同步直写。 怎么通过事务保证完全一致呢？？<br><br>先更新完缓存，更新数据库的时候失败了，回滚数据库么?    缓存中的数据怎么回滚掉呢?","like_count":0,"discussions":[{"author":{"id":1763236,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI64XUGp3cKv9AQZzWWArk0jx05TBycvZL68GsLaTtia9uoHJGae54Dgm2OfBPXc7j77Kiasu6FwcLg/132","nickname":"Geek_24ebc1","note":"","ucode":"430073D39EAC36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378115,"discussion_content":"同步直写，这里不是说redis了吧；缓存3种读写策略，旁路缓存策略，同步直写策略，异步写回策略；redis用的旁路缓存策略；操作系统Page Cache用的异步写回策略；同步写回的例子还没找到；","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623057734,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1009554,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/92/abb7bfe3.jpg","nickname":"wilson","note":"","ucode":"F582F485FD44CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365487,"discussion_content":"update mysql\nif（delete redis）\n    mysql commit\nelse\n    mysql rollback","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617806642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1477612,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8b/ec/dc03f5ad.jpg","nickname":"张天屹","note":"","ucode":"8BD6BD6DCF0F4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343245,"discussion_content":"这个事务是分布式事务，不是本地事务","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610972343,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2253496,"avatar":"","nickname":"Geek_3d87cb","note":"","ucode":"F09334D60C3BC8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338875,"discussion_content":"分布式事务,补偿机制吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609407515,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253637,"user_name":"wesley","can_delete":false,"product_type":"c1","uid":1439353,"ip_address":"","ucode":"102E5F24FE7EBD","user_header":"https://static001.geekbang.org/account/avatar/00/15/f6/79/43fc66d3.jpg","comment_is_top":false,"comment_ctime":1602817246,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602817246","product_id":100056701,"comment_content":"我在实际业务中，如果对于需要比较准确的数据，也是先更新数据库再更新缓存，但是在更新数据库的时候加了乐观锁，所以在依据缓存的前置校验通过后，后面的乐观锁更新失败，保险起见也会直接删除缓存进行重建，也不知道这样做对不对。。","like_count":0},{"had_liked":false,"id":253377,"user_name":"yeek","can_delete":false,"product_type":"c1","uid":1020629,"ip_address":"","ucode":"A1C71023113CB9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/d5/699384a0.jpg","comment_is_top":false,"comment_ctime":1602722367,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1602722367","product_id":100056701,"comment_content":"在并发下，更新缓存可能造成缓存中部分数据不一致，删除重建缓存，则不会","like_count":0,"discussions":[{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532632,"discussion_content":"删除缓存也会的,只不过概率极低极低","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637657415,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253169,"user_name":"早起不吃虫","can_delete":false,"product_type":"c1","uid":1369757,"ip_address":"","ucode":"13CD3B5E1F9435","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/7WkTI1IicbKvsPJng5vQh5qlrf1smbfl2zb7icHZfzcAk1k4lr8w8IDEAdrqq1NHW5XZMPXiaa1h7Jn1LGOWOCkIA/132","comment_is_top":false,"comment_ctime":1602640679,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1602640679","product_id":100056701,"comment_content":"老师老师<br>在删除缓存更新DB的过程中有大量请求落到数据库上面，这个过程可以使用分布式锁控制访问量么<br>以及请求未获取到锁未获取到请求结果，这些请求要怎么操作么","like_count":0,"discussions":[{"author":{"id":1965699,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/fe/83/df562574.jpg","nickname":"慎独明强","note":"","ucode":"DC2F7F2C0C8F60","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312963,"discussion_content":"没有拿到锁的可以进行业务重试","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602894372,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1965699,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/fe/83/df562574.jpg","nickname":"慎独明强","note":"","ucode":"DC2F7F2C0C8F60","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312962,"discussion_content":"分布式锁就是消除并发了，只有一个线程能操作数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602894339,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}