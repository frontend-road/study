{"id":90201,"title":"20 | 并发容器：都有哪些“坑”需要我们填？","content":"<p>Java并发包有很大一部分内容都是关于<strong>并发容器</strong>的，因此学习和搞懂这部分的内容很有必要。</p><p>Java 1.5之前提供的<strong>同步容器</strong>虽然也能保证线程安全，但是性能很差，而Java 1.5版本之后提供的并发容器在性能方面则做了很多优化，并且容器的类型也更加丰富了。下面我们就对比二者来学习这部分的内容。</p><h2>同步容器及其注意事项</h2><p>Java中的容器主要可以分为四个大类，分别是List、Map、Set和Queue，但并不是所有的Java容器都是线程安全的。例如，我们常用的ArrayList、HashMap就不是线程安全的。在介绍线程安全的容器之前，我们先思考这样一个问题：如何将非线程安全的容器变成线程安全的容器？</p><p>在前面<a href=\"https://time.geekbang.org/column/article/87365\">《12 | 如何用面向对象思想写好并发程序？》</a>我们讲过实现思路其实很简单，只要把非线程安全的容器封装在对象内部，然后控制好访问路径就可以了。</p><p>下面我们就以ArrayList为例，看看如何将它变成线程安全的。在下面的代码中，SafeArrayList内部持有一个ArrayList的实例c，所有访问c的方法我们都增加了synchronized关键字，需要注意的是我们还增加了一个addIfNotExist()方法，这个方法也是用synchronized来保证原子性的。</p><!-- [[[read_end]]] --><pre><code>SafeArrayList&lt;T&gt;{\n  //封装ArrayList\n  List&lt;T&gt; c = new ArrayList&lt;&gt;();\n  //控制访问路径\n  synchronized\n  T get(int idx){\n    return c.get(idx);\n  }\n\n  synchronized\n  void add(int idx, T t) {\n    c.add(idx, t);\n  }\n\n  synchronized\n  boolean addIfNotExist(T t){\n    if(!c.contains(t)) {\n      c.add(t);\n      return true;\n    }\n    return false;\n  }\n}\n</code></pre><p>看到这里，你可能会举一反三，然后想到：所有非线程安全的类是不是都可以用这种包装的方式来实现线程安全呢？其实这一点不止你想到了，Java SDK的开发人员也想到了，所以他们在Collections这个类中还提供了一套完备的包装类，比如下面的示例代码中，分别把ArrayList、HashSet和HashMap包装成了线程安全的List、Set和Map。</p><pre><code>List list = Collections.\n  synchronizedList(new ArrayList());\nSet set = Collections.\n  synchronizedSet(new HashSet());\nMap map = Collections.\n  synchronizedMap(new HashMap());\n</code></pre><p>我们曾经多次强调，<strong>组合操作需要注意竞态条件问题</strong>，例如上面提到的addIfNotExist()方法就包含组合操作。组合操作往往隐藏着竞态条件问题，即便每个操作都能保证原子性，也并不能保证组合操作的原子性，这个一定要注意。</p><p>在容器领域<strong>一个容易被忽视的“坑”是用迭代器遍历容器</strong>，例如在下面的代码中，通过迭代器遍历容器list，对每个元素调用foo()方法，这就存在并发问题，这些组合的操作不具备原子性。</p><pre><code>List list = Collections.\n  synchronizedList(new ArrayList());\nIterator i = list.iterator(); \nwhile (i.hasNext())\n  foo(i.next());\n</code></pre><p>而正确做法是下面这样，锁住list之后再执行遍历操作。如果你查看Collections内部的包装类源码，你会发现包装类的公共方法锁的是对象的this，其实就是我们这里的list，所以锁住list绝对是线程安全的。</p><pre><code>List list = Collections.\n  synchronizedList(new ArrayList());\nsynchronized (list) {  \n  Iterator i = list.iterator(); \n  while (i.hasNext())\n    foo(i.next());\n}    \n</code></pre><p>上面我们提到的这些经过包装后线程安全容器，都是基于synchronized这个同步关键字实现的，所以也被称为<strong>同步容器</strong>。Java提供的同步容器还有Vector、Stack和Hashtable，这三个容器不是基于包装类实现的，但同样是基于synchronized实现的，对这三个容器的遍历，同样要加锁保证互斥。</p><h2>并发容器及其注意事项</h2><p>Java在1.5版本之前所谓的线程安全的容器，主要指的就是<strong>同步容器</strong>。不过同步容器有个最大的问题，那就是性能差，所有方法都用synchronized来保证互斥，串行度太高了。因此Java在1.5及之后版本提供了性能更高的容器，我们一般称为<strong>并发容器</strong>。</p><p>并发容器虽然数量非常多，但依然是前面我们提到的四大类：List、Map、Set和Queue，下面的并发容器关系图，基本上把我们经常用的容器都覆盖到了。</p><p><img src=\"https://static001.geekbang.org/resource/image/a2/1d/a20efe788caf4f07a4ad027639c80b1d.png?wh=1142*378\" alt=\"\"></p><center><span class=\"reference\">并发容器关系图</span></center><p>鉴于并发容器的数量太多，再加上篇幅限制，所以我并不会一一详细介绍它们的用法，只是把关键点介绍一下。</p><h3>（一）List</h3><p>List里面只有一个实现类就是<strong>CopyOnWriteArrayList</strong>。CopyOnWrite，顾名思义就是写的时候会将共享变量新复制一份出来，这样做的好处是读操作完全无锁。</p><p>那CopyOnWriteArrayList的实现原理是怎样的呢？下面我们就来简单介绍一下</p><p>CopyOnWriteArrayList内部维护了一个数组，成员变量array就指向这个内部数组，所有的读操作都是基于array进行的，如下图所示，迭代器Iterator遍历的就是array数组。</p><p><img src=\"https://static001.geekbang.org/resource/image/38/10/38739130ee9f34b821b5849f4f15e710.png?wh=1142*279\" alt=\"\"></p><center><span class=\"reference\">执行迭代的内部结构图</span></center><p>如果在遍历array的同时，还有一个写操作，例如增加元素，CopyOnWriteArrayList是如何处理的呢？CopyOnWriteArrayList会将array复制一份，然后在新复制处理的数组上执行增加元素的操作，执行完之后再将array指向这个新的数组。通过下图你可以看到，读写是可以并行的，遍历操作一直都是基于原array执行，而写操作则是基于新array进行。</p><p><img src=\"https://static001.geekbang.org/resource/image/b8/89/b861fb667e94c4e6ea0ca9985e63c889.png?wh=1142*507\" alt=\"\"></p><center><span class=\"reference\">执行增加元素的内部结构图</span></center><p>使用CopyOnWriteArrayList需要注意的“坑”主要有两个方面。一个是应用场景，CopyOnWriteArrayList仅适用于写操作非常少的场景，而且能够容忍读写的短暂不一致。例如上面的例子中，写入的新元素并不能立刻被遍历到。另一个需要注意的是，CopyOnWriteArrayList迭代器是只读的，不支持增删改。因为迭代器遍历的仅仅是一个快照，而对快照进行增删改是没有意义的。</p><h3>（二）Map</h3><p>Map接口的两个实现是ConcurrentHashMap和ConcurrentSkipListMap，它们从应用的角度来看，主要区别在于<strong>ConcurrentHashMap的key是无序的，而ConcurrentSkipListMap的key是有序的</strong>。所以如果你需要保证key的顺序，就只能使用ConcurrentSkipListMap。</p><p>使用ConcurrentHashMap和ConcurrentSkipListMap需要注意的地方是，它们的key和value都不能为空，否则会抛出<code>NullPointerException</code>这个运行时异常。下面这个表格总结了Map相关的实现类对于key和value的要求，你可以对比学习。</p><p><img src=\"https://static001.geekbang.org/resource/image/6d/be/6da9933b6312acf3445f736262425abe.png?wh=1142*596\" alt=\"\"></p><p>ConcurrentSkipListMap里面的SkipList本身就是一种数据结构，中文一般都翻译为“跳表”。跳表插入、删除、查询操作平均的时间复杂度是 O(log n)，理论上和并发线程数没有关系，所以在并发度非常高的情况下，若你对ConcurrentHashMap的性能还不满意，可以尝试一下ConcurrentSkipListMap。</p><h3>（三）Set</h3><p>Set接口的两个实现是CopyOnWriteArraySet和ConcurrentSkipListSet，使用场景可以参考前面讲述的CopyOnWriteArrayList和ConcurrentSkipListMap，它们的原理都是一样的，这里就不再赘述了。</p><h3>（四）Queue</h3><p>Java并发包里面Queue这类并发容器是最复杂的，你可以从以下两个维度来分类。一个维度是<strong>阻塞与非阻塞</strong>，所谓阻塞指的是当队列已满时，入队操作阻塞；当队列已空时，出队操作阻塞。另一个维度是<strong>单端与双端</strong>，单端指的是只能队尾入队，队首出队；而双端指的是队首队尾皆可入队出队。Java并发包里<strong>阻塞队列都用Blocking关键字标识，单端队列使用Queue标识，双端队列使用Deque标识</strong>。</p><p>这两个维度组合后，可以将Queue细分为四大类，分别是：</p><p>1.<strong>单端阻塞队列</strong>：其实现有ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue、LinkedTransferQueue、PriorityBlockingQueue和DelayQueue。内部一般会持有一个队列，这个队列可以是数组（其实现是ArrayBlockingQueue）也可以是链表（其实现是LinkedBlockingQueue）；甚至还可以不持有队列（其实现是SynchronousQueue），此时生产者线程的入队操作必须等待消费者线程的出队操作。而LinkedTransferQueue融合LinkedBlockingQueue和SynchronousQueue的功能，性能比LinkedBlockingQueue更好；PriorityBlockingQueue支持按照优先级出队；DelayQueue支持延时出队。</p><p><img src=\"https://static001.geekbang.org/resource/image/59/83/5974a10f5eb0646fa94f7ba505bfcf83.png?wh=1142*419\" alt=\"\"></p><center><span class=\"reference\">单端阻塞队列示意图</span></center><p>2.<strong>双端阻塞队列</strong>：其实现是LinkedBlockingDeque。</p><p><img src=\"https://static001.geekbang.org/resource/image/1a/96/1a58ff20f1271d899b93a4f9d54ce396.png?wh=1142*432\" alt=\"\"></p><center><span class=\"reference\">双端阻塞队列示意图</span></center><p>3.<strong>单端非阻塞队列</strong>：其实现是ConcurrentLinkedQueue。<br>\n4.<strong>双端非阻塞队列</strong>：其实现是ConcurrentLinkedDeque。</p><p>另外，使用队列时，需要格外注意队列是否支持有界（所谓有界指的是内部的队列是否有容量限制）。实际工作中，一般都不建议使用无界的队列，因为数据量大了之后很容易导致OOM。上面我们提到的这些Queue中，只有ArrayBlockingQueue和LinkedBlockingQueue是支持有界的，所以<strong>在使用其他无界队列时，一定要充分考虑是否存在导致OOM的隐患</strong>。</p><h2>总结</h2><p>Java并发容器的内容很多，但鉴于篇幅有限，我们只是对一些关键点进行了梳理和介绍。</p><p>而在实际工作中，你不单要清楚每种容器的特性，还要能<strong>选对容器，这才是关键</strong>，至于每种容器的用法，用的时候看一下API说明就可以了，这些容器的使用都不难。在文中，我们甚至都没有介绍Java容器的快速失败机制（Fail-Fast），原因就在于当你选对容器的时候，根本不会触发它。</p><h2>课后思考</h2><p>线上系统CPU突然飙升，你怀疑有同学在并发场景里使用了HashMap，因为在1.8之前的版本里并发执行HashMap.put()可能会导致CPU飙升到100%，你觉得该如何验证你的猜测呢？</p><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p><p></p>","neighbors":{"left":{"article_title":"19 | CountDownLatch和CyclicBarrier：如何让多线程步调一致？","id":89461},"right":{"article_title":"21 | 原子类：无锁工具类的典范","id":90515}},"comments":[{"had_liked":false,"id":85515,"user_name":"黑白尤文","can_delete":false,"product_type":"c1","uid":1152644,"ip_address":"","ucode":"95B9F73AA0F20D","user_header":"https://static001.geekbang.org/account/avatar/00/11/96/84/d4ba322f.jpg","comment_is_top":false,"comment_ctime":1555087057,"is_pvip":false,"replies":[{"id":"30656","content":"👍<br>","user_name":"作者回复","comment_id":85515,"uid":"1269969","ip_address":"","utype":1,"ctime":1555116855,"user_name_real":"王宝令"}],"discussion_count":2,"race_medal":0,"score":"710224690897","product_id":100023901,"comment_content":"Java7中的HashMap在执行put操作时会涉及到扩容，由于扩容时链表并发操作会造成链表成环，所以可能导致cpu飙升100%。","like_count":166,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446691,"discussion_content":"👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555116855,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1405947,"avatar":"https://static001.geekbang.org/account/avatar/00/15/73/fb/40164b5d.jpg","nickname":"A$APRocky","note":"","ucode":"D1B5C2F8B1B67C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310012,"discussion_content":"并发执行才会","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601559484,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85623,"user_name":"Grubby🐑","can_delete":false,"product_type":"c1","uid":1181905,"ip_address":"","ucode":"26B9256226F919","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/d1/3c7747ef.jpg","comment_is_top":false,"comment_ctime":1555146578,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"443936778066","product_id":100023901,"comment_content":"这篇太简单了，但其实这些容器平时用的挺多的，希望老师后面能出一篇更加详细的介绍","like_count":104},{"had_liked":false,"id":85538,"user_name":"ykkk88","can_delete":false,"product_type":"c1","uid":1068585,"ip_address":"","ucode":"A1BCFC2F0D1022","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/29/1be3dd40.jpg","comment_is_top":false,"comment_ctime":1555119377,"is_pvip":false,"replies":[{"id":"30801","content":"如果key冲突比较大，hashmap还是要靠链表或者tree来解决冲突的，所以O(1)是理想值。同时增删改操作很多也影响hashmap性能。这个也是要看冲突情况。也就是说hashmap的稳定性差，如果很不幸正好偶遇它的稳定性问题，同时又接受不了，就可以尝试skiplistmap，它能保证稳定性，无论你的并发量是多大，也没有key冲突的问题。","user_name":"作者回复","comment_id":85538,"uid":"1269969","ip_address":"","utype":1,"ctime":1555171749,"user_name_real":"王宝令"}],"discussion_count":5,"race_medal":2,"score":"370922306833","product_id":100023901,"comment_content":"没有理解为什么concurrentskiplistmap比concurrenthashmap性能好","like_count":87,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446702,"discussion_content":"如果key冲突比较大，hashmap还是要靠链表或者tree来解决冲突的，所以O(1)是理想值。同时增删改操作很多也影响hashmap性能。这个也是要看冲突情况。也就是说hashmap的稳定性差，如果很不幸正好偶遇它的稳定性问题，同时又接受不了，就可以尝试skiplistmap，它能保证稳定性，无论你的并发量是多大，也没有key冲突的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555171749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1703222,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fd/36/f947c340.jpg","nickname":"Roger宇","note":"","ucode":"CBA23C01409349","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281456,"discussion_content":"老师说的不完全对，ConcurrentHashMap中key冲突到一定程度链表会转红黑树，查询销量是OlgK,K为同一个bucket内的元素数，当然，这个转化本身有额外消耗，稳定性不如跳表的解释看上去也合理。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591750493,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1810156,"avatar":"","nickname":"poordickey","note":"","ucode":"2A436EC813AF97","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1703222,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fd/36/f947c340.jpg","nickname":"Roger宇","note":"","ucode":"CBA23C01409349","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337956,"discussion_content":"其实跳表就是写代码实现容易点  跟红黑树性能差不多  但是空间稍微占用多些  都是Logk操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609136396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":281456,"ip_address":""},"score":337956,"extra":""}]},{"author":{"id":2963434,"avatar":"","nickname":"Geek_94fa0e","note":"","ucode":"15BC7D4E130E80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561239,"discussion_content":"为什么 skiplist 还适合 增删改查？？？ ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649583615,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1096397,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ba/cd/1f91aa44.jpg","nickname":"KK","note":"","ucode":"14C0858C413E00","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":357317,"discussion_content":"你也可以从两者锁住的范围来考虑，map需要锁住tree","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615784591,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85532,"user_name":"张天屹","can_delete":false,"product_type":"c1","uid":1477612,"ip_address":"","ucode":"8BD6BD6DCF0F4F","user_header":"https://static001.geekbang.org/account/avatar/00/16/8b/ec/dc03f5ad.jpg","comment_is_top":false,"comment_ctime":1555115936,"is_pvip":false,"replies":[{"id":"30659","content":"👍，不止是存在竞态条件，如果在遍历的时候出现修改操作，直接抛快速失败异常<br>","user_name":"作者回复","comment_id":85532,"uid":"1269969","ip_address":"","utype":1,"ctime":1555117937,"user_name_real":"王宝令"}],"discussion_count":2,"race_medal":0,"score":"194828644256","product_id":100023901,"comment_content":"我理解的hashMap比其它线性容器更容易出问题是因为有扩容操作，存在更多竞态条件，所以如果条件满足时切换可能导致新生成很多数组，甚至可能出现链表闭环，这种情况可以查看堆栈，比如jstack查看会发现方法调用栈一直卡在HashMap的方法。另外上文迭代器遍历不安全是因为hasNext(size)和next()存在的竞态条件吗","like_count":45,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446700,"discussion_content":"👍，不止是存在竞态条件，如果在遍历的时候出现修改操作，直接抛快速失败异常\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555117937,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1309889,"avatar":"https://static001.geekbang.org/account/avatar/00/13/fc/c1/c76c9d0e.jpg","nickname":"前途未卜。","note":"","ucode":"6DEE5B690C7CB2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384812,"discussion_content":"很多容器都有扩容操作啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626762378,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85618,"user_name":"WolvesLeader","can_delete":false,"product_type":"c1","uid":1103839,"ip_address":"","ucode":"33610E19CA2E96","user_header":"https://static001.geekbang.org/account/avatar/00/10/d7/df/fc0a6709.jpg","comment_is_top":false,"comment_ctime":1555145014,"is_pvip":false,"replies":[{"id":"30761","content":"我觉得自己理解起来困难而且对实际工作还有用的就会讲的深入一些，反之我觉得概念或者工具跟正常思维没有冲突，就会讲的简单，甚至略过。毕竟我们只是工具的使用者，首要问题是利用这些工具解决问题。感谢你的认可，我甚至觉得写完第二篇和管程之后就可以收工了，其他所有章节不过就是帮助大家进一步理解，从不同角度理解。","user_name":"作者回复","comment_id":85618,"uid":"1269969","ip_address":"","utype":1,"ctime":1555163144,"user_name_real":"王宝令"}],"discussion_count":5,"race_medal":0,"score":"164763902262","product_id":100023901,"comment_content":"个人认为您第二篇内存模型讲的非常棒，，，，，，，，，，","like_count":38,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446737,"discussion_content":"我觉得自己理解起来困难而且对实际工作还有用的就会讲的深入一些，反之我觉得概念或者工具跟正常思维没有冲突，就会讲的简单，甚至略过。毕竟我们只是工具的使用者，首要问题是利用这些工具解决问题。感谢你的认可，我甚至觉得写完第二篇和管程之后就可以收工了，其他所有章节不过就是帮助大家进一步理解，从不同角度理解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555163144,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008071,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/61/c7/b64ac05e.jpg","nickname":"sky","note":"","ucode":"9FE5F43055D3AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":258540,"discussion_content":"后面的课程总结归纳 结合实际例子很棒👍","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1588691685,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1063308,"avatar":"https://static001.geekbang.org/account/avatar/00/10/39/8c/089525aa.jpg","nickname":"小乙哥","note":"","ucode":"C77E79BEA0C325","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386957,"discussion_content":"又契合了开篇词，跳出来看全景，钻进去看本质。不要一上来就干细节和实现，切记","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627909605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1436391,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ea/e7/9ce305ec.jpg","nickname":"Sancho","note":"","ucode":"78849913082622","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333535,"discussion_content":"“我甚至觉得写完第二篇和管程之后就可以收工了”，作者好谦虚，个人感觉后面讲得还是很好很有用的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607559990,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1061206,"avatar":"https://static001.geekbang.org/account/avatar/00/10/31/56/c21f0a1a.jpg","nickname":"Steve","note":"","ucode":"442CE19F51D044","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281091,"discussion_content":"头几篇是精华，后面的陪衬。一个成体系的教程，都不能缺少","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591670165,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87384,"user_name":"龙猫","can_delete":false,"product_type":"c1","uid":1112490,"ip_address":"","ucode":"FD726CC969EF9C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/aa/3e80212e.jpg","comment_is_top":false,"comment_ctime":1555580419,"is_pvip":false,"replies":[{"id":"31415","content":"👍<br>","user_name":"作者回复","comment_id":87384,"uid":"1269969","ip_address":"","utype":1,"ctime":1555587222,"user_name_real":"王宝令"}],"discussion_count":3,"race_medal":0,"score":"138994533891","product_id":100023901,"comment_content":"java8之前的版本hashmap执行put方法时会有环形链表的风险，java8以后改成了红黑树","like_count":32,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447422,"discussion_content":"👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555587222,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1546081,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoV7kTQGEFG101jDKycJ4AroKgTn7oicvbaia4ibk7uElZLjKe6SFoQicuvsJodHibZiazsdraiae0qhuzZg/132","nickname":"Geek_e5d39f","note":"","ucode":"A4712DE9721E06","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263300,"discussion_content":"1.8之后不会形成循环链表，应该是因为加节点的方式变了无关红黑树，\n1.7的时候新增元素会放在链表头部，并发会有循环链表和元素丢失风险\n1.8的时候新增元素放在了链表尾部，并发只会有元素丢失的风险","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1589197039,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1655117,"avatar":"https://static001.geekbang.org/account/avatar/00/19/41/4d/f6d6d13a.jpg","nickname":"啊良梓是我","note":"","ucode":"E42FC1A60D331C","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347210,"discussion_content":"只要改变应该是从头插法改为尾插法吧，这样子扩容 不会导致回环","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612174282,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85579,"user_name":"CCC","can_delete":false,"product_type":"c1","uid":1003738,"ip_address":"","ucode":"2E254444098267","user_header":"https://static001.geekbang.org/account/avatar/00/0f/50/da/ed4803cb.jpg","comment_is_top":false,"comment_ctime":1555132556,"is_pvip":false,"replies":[{"id":"30759","content":"那个跳表就跟字典的索引一样，通过这个索引既能快速定位数据，也能隔离并发（可以并发查看不同页上的字）","user_name":"作者回复","comment_id":85579,"uid":"1269969","ip_address":"","utype":1,"ctime":1555153554,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"91749445772","product_id":100023901,"comment_content":"老师，用跳表实现的ConcurrentSkipListMap为什么可以做到无锁并发呢","like_count":21,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446721,"discussion_content":"那个跳表就跟字典的索引一样，通过这个索引既能快速定位数据，也能隔离并发（可以并发查看不同页上的字）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555153554,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85536,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1555118954,"is_pvip":false,"replies":[{"id":"30784","content":"实际工作中，为了防止OOM，基本上都使用有界队列，我工作中也没用过LinkedTransferQueue。","user_name":"作者回复","comment_id":85536,"uid":"1269969","ip_address":"","utype":1,"ctime":1555168886,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"74569562986","product_id":100023901,"comment_content":"LinkedTransferQueue有什么应用场景吗？","like_count":17,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446701,"discussion_content":"实际工作中，为了防止OOM，基本上都使用有界队列，我工作中也没用过LinkedTransferQueue。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555168886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85659,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1555165547,"is_pvip":false,"replies":[{"id":"30786","content":"是的，底层实现变了，我同事在1.8版本费了好大劲都没重现出来","user_name":"作者回复","comment_id":85659,"uid":"1269969","ip_address":"","utype":1,"ctime":1555169006,"user_name_real":"王宝令"}],"discussion_count":2,"race_medal":0,"score":"65979674987","product_id":100023901,"comment_content":"除了jdk8之前因为并发导致的链表成环的问题还有一种可能是因为jdk8之前hash冲突还是使用的是链表，而jdk8之后使用了红黑树，开始还是生成链表，当链表长度为8时就会转变为红黑树，时间复杂度为O(logn),比链表效果好的多。","like_count":15,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446755,"discussion_content":"是的，底层实现变了，我同事在1.8版本费了好大劲都没重现出来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555169006,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2660077,"avatar":"","nickname":"供应链云","note":"","ucode":"3033481918D1B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548838,"discussion_content":"jdk8中当链表转换为红黑树时，多线程下操作HashMap，在resize时红黑树自旋也可能出现死循环。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643421126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85564,"user_name":"罗洲","can_delete":false,"product_type":"c1","uid":1263417,"ip_address":"","ucode":"68133E38A25C17","user_header":"https://static001.geekbang.org/account/avatar/00/13/47/39/0ce1aa62.jpg","comment_is_top":false,"comment_ctime":1555124952,"is_pvip":false,"replies":[{"id":"30765","content":"👍<br>","user_name":"作者回复","comment_id":85564,"uid":"1269969","ip_address":"","utype":1,"ctime":1555166902,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"61684667096","product_id":100023901,"comment_content":"jdk1.8以前的HashMap并发扩容的时候会导致陷入死循环，所以会导致cpu飙升，那么验证猜想我觉得有2种方法：<br>1.线上查故障，用dump分析线程。<br>2.用1.8以前的jdk在本地模拟。<br>","like_count":14,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446716,"discussion_content":"👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555166902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97409,"user_name":"张申傲","can_delete":false,"product_type":"c1","uid":1182372,"ip_address":"","ucode":"22D46BC529BA8A","user_header":"https://static001.geekbang.org/account/avatar/00/12/0a/a4/828a431f.jpg","comment_is_top":false,"comment_ctime":1558665783,"is_pvip":true,"replies":[{"id":"34881","content":"复制的时候允许读，可能读到数组里旧的元素。数组的引用是一致的，一旦设置就能读到，但是里面的元素会有不一致的情况","user_name":"作者回复","comment_id":97409,"uid":"1269969","ip_address":"","utype":1,"ctime":1558700075,"user_name_real":"王宝令"}],"discussion_count":3,"race_medal":2,"score":"44508338743","product_id":100023901,"comment_content":"老师，我有个问题：<br>文章里面说，使用CopyOnWriteArrayList时，需要能够容忍读写的短暂不一致，但是我理解CopyOnWriteArrayList应该不会出现不一致问题吧。因为底层的array是用volatile修饰的，根据happens-before原则，对volatile变量的写happens-before于对变量的读，也就是说如果存在并发读写的情况，写线程的setArray()一定是对读线程的getArray()可见的，所以我认为读到的始终都是最新的数据。<br>不知道我的理解有没有问题？<br>","like_count":10,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451272,"discussion_content":"复制的时候允许读，可能读到数组里旧的元素。数组的引用是一致的，一旦设置就能读到，但是里面的元素会有不一致的情况","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558700075,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1302876,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e1/5c/b32f00b1.jpg","nickname":"Richard","note":"","ucode":"C16AE7CE877DCA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7836,"discussion_content":"看了下代码，设置成功后会马上读到数组变化，如果在还没设置成功的时候去读，即使读到的是旧的数组也不能算是不一致吧。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567688081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2963434,"avatar":"","nickname":"Geek_94fa0e","note":"","ucode":"15BC7D4E130E80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1302876,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e1/5c/b32f00b1.jpg","nickname":"Richard","note":"","ucode":"C16AE7CE877DCA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561241,"discussion_content":"有道理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649583749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7836,"ip_address":""},"score":561241,"extra":""}]}]},{"had_liked":false,"id":151531,"user_name":"Randy","can_delete":false,"product_type":"c1","uid":1125259,"ip_address":"","ucode":"7BF52ADBFD4F5D","user_header":"https://static001.geekbang.org/account/avatar/00/11/2b/8b/dd02189a.jpg","comment_is_top":false,"comment_ctime":1573736817,"is_pvip":false,"replies":[{"id":"59690","content":"刚好有篇公众号讲到这个问题，写的非常好。https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;yxn47A4UcsrORoDJyREEuQ","user_name":"作者回复","comment_id":151531,"uid":"1269969","ip_address":"","utype":1,"ctime":1574729953,"user_name_real":"王宝令"}],"discussion_count":3,"race_medal":0,"score":"40228442481","product_id":100023901,"comment_content":"留言中很多都提到在JDK1.8以前会存在HashMap的并发情况下resize可能导致死循环问题，其实这个问题在1.8中也存在，并没有因为在1.8中引入了红黑树而规避掉。因为导致问题的原因是resize方法调用了transfer，也就是说是发生在链表的重组过程，跟红黑树没有关系。所以JDK1.8中还是存在这个问题<br>请宝令老师指正","like_count":9,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474517,"discussion_content":"刚好有篇公众号讲到这个问题，写的非常好。https://mp.weixin.qq.com/s/yxn47A4UcsrORoDJyREEuQ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574729953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2963434,"avatar":"","nickname":"Geek_94fa0e","note":"","ucode":"15BC7D4E130E80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":561246,"discussion_content":"这篇文章写的很好!","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649585064,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":474517,"ip_address":""},"score":561246,"extra":""}]},{"author":{"id":1658706,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJeQVzYNLVuOv8IuxydsXuVXEUoqLmN0vpkiceZuU26KPOt05xuxCSnsbkgBu4q9qmibRfTOvCiaPGJg/132","nickname":"Qualifor","note":"","ucode":"8F42453286719C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":139910,"discussion_content":"所以根据老师推荐的这个文章来看，主要是java8把链表的头插法给改成尾插法了吧，跟红黑树并没有关系，请老师指正","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1579329191,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87916,"user_name":"candy","can_delete":false,"product_type":"c1","uid":1449024,"ip_address":"","ucode":"9CA127B28F1058","user_header":"","comment_is_top":false,"comment_ctime":1555752563,"is_pvip":false,"replies":[{"id":"31625","content":"看这几行看不出来，一般问题都能通过线程栈发现问题。我遇到过生产者和消费者共用一个线程池，生产者把线程池里的线程用光了，导致消费不了。这种情况下通过线程池不太容易看，需要去计数。不知道你的问题是不是这个。所有线程都等待，还没有死锁，就查查为什么会等待吧。","user_name":"作者回复","comment_id":87916,"uid":"1269969","ip_address":"","utype":1,"ctime":1555769747,"user_name_real":"王宝令"}],"discussion_count":6,"race_medal":0,"score":"40210458227","product_id":100023901,"comment_content":"老师，你好，最近两天，我线上跑的计费进程假死了(从1月11日开始跑的，4月10日第一次出现假死）， ExecutorService services = Executors.newFixedThreadPool(taskThreads);   CountDownLatch cdt = new CountDownLatch(size);<br>                        &#47;&#47;一个个的处理数据<br>                        for (int j = 0; j &lt; size; j++) {<br>                            CFTask task = new CFTask(table, channelIds.get(j), batchId, cdt);<br>                            services.submit(task);<br>                        }<br>                        cdt.await(); 这个有什么错误吗？让多个线程处理步调一致<br><br>线上jstack pid 查看 部分日志，如下：好像线程池所有线程都在等待执行，感觉一个数据库查询操作跑死了，很奇怪<br>","like_count":9,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447646,"discussion_content":"看这几行看不出来，一般问题都能通过线程栈发现问题。我遇到过生产者和消费者共用一个线程池，生产者把线程池里的线程用光了，导致消费不了。这种情况下通过线程池不太容易看，需要去计数。不知道你的问题是不是这个。所有线程都等待，还没有死锁，就查查为什么会等待吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555769747,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2697700,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/LFJZ4x47rvShGhsePLIxc8EzdlBxAmVAIjJ2FQZ4NEpo8E4JCZQEOb2NIfOuiaQLL6Otkt7W3Rmu6Tv3AkgYdRA/132","nickname":"键盘上的魔术","note":"","ucode":"A731D721FB8D3A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":562627,"discussion_content":"每个线程里有调用cdt.countDown()吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649858135,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1441569,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ff/21/8815d2e5.jpg","nickname":"亮子","note":"","ucode":"DF37D5E0714D02","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544038,"discussion_content":"CFTask的执行方法加下try catch，同时cdt.await() 加个InterruptedException的异常捕获","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641384176,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1461801,"avatar":"https://static001.geekbang.org/account/avatar/00/16/4e/29/4b0d7a05.jpg","nickname":"ren","note":"","ucode":"A8787FDFD56956","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370668,"discussion_content":"所以 最后找到问题了么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619504187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1282819,"avatar":"","nickname":"尼糯米","note":"","ucode":"04D1B63F3801AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305130,"discussion_content":"向线程池提交的CFTask实例，其执行run()，是不是有异常被抛出，submit方式会把异常吃掉，且线程池整个会被挂起呢。可以先整个代码块try-catch下，看下是否异常了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599791850,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1241185,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f0/61/fedca2e9.jpg","nickname":"(Kelen)","note":"","ucode":"C8578DB62E3B2D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":207897,"discussion_content":"最后问题原因是啥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584523000,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85563,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1555124820,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"35914863188","product_id":100023901,"comment_content":"选对容器的前提还是要对原理，特性，使用场景，优缺点，坑，甚至底层实现都了如指掌才能说选对容器，要不然更多的也是蒙对容器","like_count":8},{"had_liked":false,"id":88549,"user_name":"我劝你善良","can_delete":false,"product_type":"c1","uid":1447802,"ip_address":"","ucode":"99ACEDE16B19D3","user_header":"https://static001.geekbang.org/account/avatar/00/16/17/7a/ab9bb6df.jpg","comment_is_top":false,"comment_ctime":1555940226,"is_pvip":false,"replies":[{"id":"31764","content":"CopyOnWriteArrayList写操作是互斥的。","user_name":"作者回复","comment_id":88549,"uid":"1269969","ip_address":"","utype":1,"ctime":1555946169,"user_name_real":"王宝令"}],"discussion_count":2,"race_medal":0,"score":"31620711298","product_id":100023901,"comment_content":"老师，针对CopyOnWriteArrayList<br>1.如果正在遍历的时候，同时有两个写操作执行，是会顺序在一个新数组上执行写操作，还是有两个写操作分别进行？如果是两个新数组的话，那么array又将指向哪一个新数组？<br>2.如果在遍历的过程中，写操作已经完成了，但是遍历尚未结束，那么是array是直接指向新数组，并继续在新数组上执行未完成的遍历，还是等待遍历完成了，再修改array的指向呢？如果在遍历完之前就修改指向，那么就会存在问题了啊！","like_count":7,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447825,"discussion_content":"CopyOnWriteArrayList写操作是互斥的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555946169,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1585829,"avatar":"https://static001.geekbang.org/account/avatar/00/18/32/a5/9868cd56.jpg","nickname":"southday","note":"","ucode":"4A8FB63D35F6E1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5037,"discussion_content":"第1个问题，老师已经回答了。我来说下第2个问题吧，我特意看了下 CopyOnWriteArrayList 源码（JDK 11），Iterator() 返回的是 COWIterator 内部类实例，简化代码如下：\n```java\nstatic final class COWIterator<E> implements ListIterator<E> {\n    /** Snapshot of the array */\n    private final Object[] snapshot;\n    /** Index of element to be returned by subsequent call to next.  */\n    private int cursor;\n\n    COWIterator(Object[] es, int initialCursor) {\n        cursor = initialCursor;\n        snapshot = es;\n    }\n}\n```\n可以看到，迭代器中访问的是 array 的快照，snapshot 最初和 array 指向的是同一个空间（旧数据），写线程更新了 array指针，但不会更新 snapshot 的指向，并且 snapshot 是被 final 修饰的，在访问快照过程中也不会被更改；","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1565886205,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87525,"user_name":"月月月月","can_delete":false,"product_type":"c1","uid":1330605,"ip_address":"","ucode":"3CD83BD83C6D3F","user_header":"https://static001.geekbang.org/account/avatar/00/14/4d/ad/5e4e94e4.jpg","comment_is_top":false,"comment_ctime":1555632791,"is_pvip":false,"replies":[{"id":"31546","content":"并发容器的遍历是线程安全的<br>","user_name":"作者回复","comment_id":87525,"uid":"1269969","ip_address":"","utype":1,"ctime":1555675487,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"27325436567","product_id":100023901,"comment_content":"老师，我想问下，文章里提到容器在遍历时要注意加锁保证线程安全，对于非线程安全的容器，我们可以通过包装让它变成线程安全的容器，然后在遍历的时候锁住集合对象。但是对于并发容器来说，在遍历的时候要怎么保证线程安全呢？如果还是锁住容器对象，但是对于不是使用synchronized去实现的并发容器，锁对象不就不一样了吗？那这样该怎么保证线程安全呢？","like_count":6,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447494,"discussion_content":"并发容器的遍历是线程安全的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555675487,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":86807,"user_name":"Sunny_Lu","can_delete":false,"product_type":"c1","uid":1453000,"ip_address":"","ucode":"4327DE41D7DB28","user_header":"https://static001.geekbang.org/account/avatar/00/16/2b/c8/61eeae65.jpg","comment_is_top":false,"comment_ctime":1555463289,"is_pvip":false,"replies":[{"id":"31282","content":"👍，多个数组<br>","user_name":"作者回复","comment_id":86807,"uid":"1269969","ip_address":"","utype":1,"ctime":1555499574,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"27325267065","product_id":100023901,"comment_content":"感觉copyonwrite的使用限制很大，首先要容忍暂时的不一致，数据量大的情况下，写一旦多一点 不断的复制也会有性能上的问题吧？还是说多次的写用的是同一个数组呢","like_count":6,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447184,"discussion_content":"👍，多个数组\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555499574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85658,"user_name":"曾轼麟","can_delete":false,"product_type":"c1","uid":1451391,"ip_address":"","ucode":"D418371AC11270","user_header":"https://static001.geekbang.org/account/avatar/00/16/25/7f/473d5a77.jpg","comment_is_top":false,"comment_ctime":1555164910,"is_pvip":false,"replies":[{"id":"30791","content":"1.8版本之后ConcurrentHashMap的实现改了","user_name":"作者回复","comment_id":85658,"uid":"1269969","ip_address":"","utype":1,"ctime":1555169397,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"23030001390","product_id":100023901,"comment_content":"帮老师补充HashMap：当数据的HashCode 分布状态良好，并且冲突较少的时候对ConcurrentHashMap（查询，value修改，不包括插入），性能上基本上是和HashMap一致的，主要取决于分段锁的插思想。但是由于插入使用的是CAS的方式，所以如果对数据追加不多（插入）的情况下，建议可以考虑多使用ConcurrentHashMap避免由于修改数据产生一些意想不到的并发问题，当然内部也有保护机制通过抛出ConcurrentModificationException（快速失败机制）来让我们及时发现出现并发数据异常的情况，不知道我补充的是否正确。","like_count":5,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446754,"discussion_content":"1.8版本之后ConcurrentHashMap的实现改了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555169397,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133884,"user_name":"Sharry","can_delete":false,"product_type":"c1","uid":1239293,"ip_address":"","ucode":"045DDB864659F6","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/fd/035f4c94.jpg","comment_is_top":false,"comment_ctime":1568690654,"is_pvip":false,"replies":[{"id":"51386","content":"👍","user_name":"作者回复","comment_id":133884,"uid":"1269969","ip_address":"","utype":1,"ctime":1568717959,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"18748559838","product_id":100023901,"comment_content":"在 JDK7  上 HashMap 数据迁移时, 会导致结点翻转, 多线程操作时, 可能会引发死循环<br>, 在 JDK8 上修改了数据迁移的算法, 保证数据的顺便, 不会出现死循环问题","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467543,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568717959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132582,"user_name":"李鑫磊","can_delete":false,"product_type":"c1","uid":1101615,"ip_address":"","ucode":"D06517CFCEEE00","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/2f/4f89f22a.jpg","comment_is_top":false,"comment_ctime":1568168355,"is_pvip":false,"replies":[{"id":"51083","content":"读无锁，写要看具体实现","user_name":"作者回复","comment_id":132582,"uid":"1269969","ip_address":"","utype":1,"ctime":1568503656,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"18748037539","product_id":100023901,"comment_content":"既然 CopyOnWrite 的写操作是互斥的，那老师为什么在学习攻略中把 CopyOnWrite 归为无锁的方案？","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467021,"discussion_content":"读无锁，写要看具体实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568503656,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85522,"user_name":"周治慧","can_delete":false,"product_type":"c1","uid":1335293,"ip_address":"","ucode":"7D56C4E66BEE17","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKR3ibELhjgVicCNShZCBwvaDxibnzibggG4wUzVkS2mkDxUBZyIs87nDEdJ7PiahJBVoZcuhQ84RxAziag/132","comment_is_top":false,"comment_ctime":1555110688,"is_pvip":false,"replies":[{"id":"30657","content":"原因是对的，cpu飙升不降的问题都可以用dump线程栈来分析<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555117082,"ip_address":"","comment_id":85522,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14440012576","product_id":100023901,"comment_content":"hashmap在put的时候扩容导致链表的死环导致，可以通过遍历去entries中entry的next一直不为空来判断","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446696,"discussion_content":"原因是对的，cpu飙升不降的问题都可以用dump线程栈来分析\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555117082,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91803,"user_name":"Geek_c991e0","can_delete":false,"product_type":"c1","uid":1206623,"ip_address":"","ucode":"5B6391E2D69D50","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epLLXBLBLgticobxvBYRezd304Y66Q8ibYCl7mG9dvTHGrx9obRcn7ZmJBcib3ibsQPIX3xIbNYiaAUrOA/132","comment_is_top":false,"comment_ctime":1557111835,"is_pvip":false,"replies":[{"id":"34455","content":"只允许一个一个写，写操作是有锁的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558362275,"ip_address":"","comment_id":91803,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10147046427","product_id":100023901,"comment_content":"老师好，copyonwrite如果并发写入很多，复制多个array写入，那重新指向的时候怎么把多个合并那，还是说写的时候只允许一个一个的写","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449035,"discussion_content":"只允许一个一个写，写操作是有锁的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558362275,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90620,"user_name":"彭锐","can_delete":false,"product_type":"c1","uid":1179669,"ip_address":"","ucode":"F2CB53DE42026D","user_header":"https://static001.geekbang.org/account/avatar/00/12/00/15/6e399ec7.jpg","comment_is_top":false,"comment_ctime":1556589631,"is_pvip":false,"replies":[{"id":"32461","content":"写会复制整个数组，还要看数组的大小。如果数组小，可以只看一致性的要求。如果数组大，还要看写操作是不是多","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556607210,"ip_address":"","comment_id":90620,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10146524223","product_id":100023901,"comment_content":"很多地方都说，CopyOnWriteAyyayList只适用于读多写少的场景。但安全并发容器，只有CopyOnWriteAyyayList啊。不适用又能怎么样？用Vector，性能比CopyOnWriteAyyayList差到不知道哪里去了。<br>因此，我觉得不是要换一种说法，在并发场景下，如果接受不了“最终一致”，才考虑其他的并发容器。","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448597,"discussion_content":"写会复制整个数组，还要看数组的大小。如果数组小，可以只看一致性的要求。如果数组大，还要看写操作是不是多","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556607210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85592,"user_name":"独立自主","can_delete":false,"product_type":"c1","uid":1371039,"ip_address":"","ucode":"11213FDC994385","user_header":"https://static001.geekbang.org/account/avatar/00/14/eb/9f/125ed81c.jpg","comment_is_top":false,"comment_ctime":1555136013,"is_pvip":false,"replies":[{"id":"30758","content":"两个原子操作直接，可能发生很多事情。你可以参考《07 | 安全性、活跃性以及性能问题》里面的set(get()+1)问题","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555153101,"ip_address":"","comment_id":85592,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10145070605","product_id":100023901,"comment_content":"老师组合操作为什么不能保证原子性。能举个例子吗这里没了解清楚。谢谢","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446725,"discussion_content":"两个原子操作直接，可能发生很多事情。你可以参考《07 | 安全性、活跃性以及性能问题》里面的set(get()+1)问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555153101,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85543,"user_name":"crazypokerk","can_delete":false,"product_type":"c1","uid":1158383,"ip_address":"","ucode":"9AAD5D9726E503","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/ef/494f56c3.jpg","comment_is_top":false,"comment_ctime":1555121665,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10145056257","product_id":100023901,"comment_content":"满满干货，条理立马清晰了！","like_count":2},{"had_liked":false,"id":268649,"user_name":"阿声","can_delete":false,"product_type":"c1","uid":1148174,"ip_address":"","ucode":"EEA5F2E9D4FC9C","user_header":"https://static001.geekbang.org/account/avatar/00/11/85/0e/e6640576.jpg","comment_is_top":false,"comment_ctime":1608282295,"is_pvip":false,"replies":[{"id":"97501","content":"在用户层面这样理解很直观������������","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1608358626,"ip_address":"","comment_id":268649,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5903249591","product_id":100023901,"comment_content":"很多评论对CopyOnWriteArrayList容器在并发情况下的的写操作有疑问，担心存在数据覆盖，我说下我的理解：<br><br>1、并发读，读的是快照，不会有并发问题。<br>2、并发迭代器遍历，生成的迭代器内部使用的也是快照，不会有并发问题。<br>3、并发写，内部使用ReentrantLock.lock做的并发控制，只会有一个线程进入临界区进行写复制操作；其他线程被lock住，同步排队处理。<br>所以并发写操作是不会出现覆盖的情况的。<br><br>PS：这个跟mysql的快照读、当前读很相似，可以类比对照。","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511997,"discussion_content":"在用户层面这样理解很直观������������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608358626,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115132,"user_name":"小予","can_delete":false,"product_type":"c1","uid":1442580,"ip_address":"","ucode":"3F5EAEE1746074","user_header":"https://static001.geekbang.org/account/avatar/00/16/03/14/e9ca2d09.jpg","comment_is_top":false,"comment_ctime":1563498487,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5858465783","product_id":100023901,"comment_content":"只有 ArrayBlockingQueue 和 LinkedBlockingQueue 是支持有界的吗，其他的队列应该也支持有界的吧，比如PriorityBlockingQueue初始化的时候就是可以指定大小的吧！","like_count":1,"discussions":[{"author":{"id":1460568,"avatar":"","nickname":"whuzxj","note":"","ucode":"0EC6153B0A0E8A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":216716,"discussion_content":"PriorityBlockingQueue初始化的时候可以指定初始大小，后续是可以扩容的。而ArrayBlockingQueue 和 LinkedBlockingQueue指定初始大小后，后续是不可以扩容的。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1585478430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":352983,"user_name":"SkillIP","can_delete":false,"product_type":"c1","uid":1744250,"ip_address":"北京","ucode":"60EAEB93EC6858","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9d/7a/fb762fea.jpg","comment_is_top":false,"comment_ctime":1659063601,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1659063601","product_id":100023901,"comment_content":"老师能回答一下，怎么验证猜测么？是通过查看Dump文件么？","like_count":0},{"had_liked":false,"id":332617,"user_name":"清风","can_delete":false,"product_type":"c1","uid":2317711,"ip_address":"","ucode":"62490AD4F949BB","user_header":"https://static001.geekbang.org/account/avatar/00/23/5d/8f/498d9ea5.jpg","comment_is_top":false,"comment_ctime":1643378575,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643378575","product_id":100023901,"comment_content":"头插法可能导致多线程环境下链表成环，1.8后默认尾插法就没这问题了","like_count":0},{"had_liked":false,"id":287445,"user_name":"YWH","can_delete":false,"product_type":"c1","uid":1145122,"ip_address":"","ucode":"B448CCF13F2BF2","user_header":"https://static001.geekbang.org/account/avatar/00/11/79/22/58981901.jpg","comment_is_top":false,"comment_ctime":1617953703,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1617953703","product_id":100023901,"comment_content":"老师，谈到 CopyOnWriteArrayList 的“迭代器 Iterator 遍历的就是 array 数组”，这个 array 数组指的是 CopyOnWriteArrayList  内部的数组吧？后面说“CopyOnWriteArrayList 迭代器是只读的，不支持增删改。因为迭代器遍历的仅仅是一个快照，而对快照进行增删改是没有意义的。”则是在快照遍历，这样是否有矛盾呢？","like_count":0,"discussions":[{"author":{"id":2226367,"avatar":"https://static001.geekbang.org/account/avatar/00/21/f8/bf/59f2e600.jpg","nickname":"月明风清","note":"","ucode":"65A97CF2E320FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575040,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654567845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":283872,"user_name":"秋叶","can_delete":false,"product_type":"c1","uid":1477444,"ip_address":"","ucode":"D0B7EAE78B04BE","user_header":"https://static001.geekbang.org/account/avatar/00/16/8b/44/80808100.jpg","comment_is_top":false,"comment_ctime":1615968443,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615968443","product_id":100023901,"comment_content":"LinkedBlockingQueue 不指定大小其默认大小就是Integer.MAX_VALUE，Executors内置的线程池队列大部分都是这种队列，所以不推荐使用Executors创建队列。","like_count":0},{"had_liked":false,"id":245315,"user_name":"那月真美","can_delete":false,"product_type":"c1","uid":1441895,"ip_address":"","ucode":"CEF1AF65C6064E","user_header":"https://static001.geekbang.org/account/avatar/00/16/00/67/e24dd940.jpg","comment_is_top":false,"comment_ctime":1598891849,"is_pvip":false,"replies":[{"id":"90225","content":"适用写少读多场景，不会有并发问你<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1598926410,"ip_address":"","comment_id":245315,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1598891849","product_id":100023901,"comment_content":"老师，假如有两个线程同时操作CopyOnWriteArrayList就会有并发问题吧？因为会同时指向两个不同的数组且都只保存了当前线程的快照。既然如此那还有啥意义呢？没法保证线程安全，读性能也不比ArrayList快啊","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504848,"discussion_content":"适用写少读多场景，不会有并发问你\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598926410,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1148174,"avatar":"https://static001.geekbang.org/account/avatar/00/11/85/0e/e6640576.jpg","nickname":"阿声","note":"","ucode":"EEA5F2E9D4FC9C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335714,"discussion_content":"并发读，读的是快照，不会有并发问题。\n并发写，内部使用ReentrantLock.lock做的并发控制，只会有一个线程进入临界区进行写复制操作；其他线程被lock住，同步排队处理。\n这个跟mysql的快照读、当前读很相似，可以类比对照。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608281749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221907,"user_name":"Geek_3422b1","can_delete":false,"product_type":"c1","uid":2007135,"ip_address":"","ucode":"ECD3AF9B1AFF13","user_header":"","comment_is_top":false,"comment_ctime":1590631719,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590631719","product_id":100023901,"comment_content":"CopyOnWriteArrayList  写的时候会复制一个新的线程，然后将新的线程赋值给array,  那么多线程写的时候不就完成彼此覆盖了吗？这个该怎么理解？？","like_count":0},{"had_liked":false,"id":219178,"user_name":"无言的约定","can_delete":false,"product_type":"c1","uid":1128953,"ip_address":"","ucode":"5E8046EB6B7956","user_header":"https://static001.geekbang.org/account/avatar/00/11/39/f9/acfb9a48.jpg","comment_is_top":false,"comment_ctime":1589961941,"is_pvip":false,"replies":[{"id":"94099","content":"数据量很大时很有可能oom������","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1604407317,"ip_address":"","comment_id":219178,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589961941","product_id":100023901,"comment_content":"老师，有个问题需要请教，多线程从Kafka中取出数据后按时间先后顺序存入ConcurrentSkipListMap，数据量很大时跳表会存不下吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495704,"discussion_content":"数据量很大时很有可能oom������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604407317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":199188,"user_name":"😜哈哈","can_delete":false,"product_type":"c1","uid":1069001,"ip_address":"","ucode":"1FF58FB3A91135","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/c9/88837387.jpg","comment_is_top":false,"comment_ctime":1585481777,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585481777","product_id":100023901,"comment_content":"Java8以前的HashMap如果put操作时有扩容，链表并发操作会造成链表成环，从而导致cpu飙升100%。","like_count":0},{"had_liked":false,"id":157502,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1274787,"ip_address":"","ucode":"C233DF1D224EC1","user_header":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","comment_is_top":false,"comment_ctime":1575180355,"is_pvip":true,"replies":[{"id":"67118","content":"我只能说，场景和依据参考算法里数组和链表的选择😂","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1579438741,"ip_address":"","comment_id":157502,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1575180355","product_id":100023901,"comment_content":"老师好！<br>ThreadPoolExecutor的构造方法中传入的队列，什么场景下使用LinkedBlockingQueue有界队列，什么场景下使用ArrayBlockingQueue有界队列？如何选择？有什么依据？<br>","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476450,"discussion_content":"我只能说，场景和依据参考算法里数组和链表的选择😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579438741,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150155,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1573470345,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573470345","product_id":100023901,"comment_content":"第一次听说容器的快速失败机制，学习了","like_count":0},{"had_liked":false,"id":135649,"user_name":"ly","can_delete":false,"product_type":"c1","uid":1221628,"ip_address":"","ucode":"5E2B85252DABF3","user_header":"https://static001.geekbang.org/account/avatar/00/12/a3/fc/379387a4.jpg","comment_is_top":false,"comment_ctime":1569235065,"is_pvip":false,"replies":[{"id":"52036","content":"猜测是key冲突后的解决方式决定的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1569245729,"ip_address":"","comment_id":135649,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569235065","product_id":100023901,"comment_content":"对于hashtable和conhashmap及conskiplistmap，为什么非得要求value也必须不能为null呢？按道理，key不能为null应该就够了吧，不知道这样设计对这些集合本身的结构有什么影响吗，还是说仅仅是给容器使用者一个约定（兄弟，只要存在key，则返回给你的一定不会是null）","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468288,"discussion_content":"猜测是key冲突后的解决方式决定的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569245729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134911,"user_name":"飞翔","can_delete":false,"product_type":"c1","uid":1068571,"ip_address":"","ucode":"65AF6AF292DAD6","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/1b/f4b786b9.jpg","comment_is_top":false,"comment_ctime":1568950213,"is_pvip":true,"replies":[{"id":"52710","content":"这个是里面的一个内部类的😂","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1569668081,"ip_address":"","comment_id":134911,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568950213","product_id":100023901,"comment_content":"老师 重大发现 CopyOnWriteArrayList jdk 一点8 读操作里边有锁 很奇怪<br><br>public class CopyOnWriteArrayList&lt;E&gt;<br> public E get(int index) {<br>            final ReentrantLock lock = l.lock;<br>            lock.lock();<br>            try {<br>                rangeCheck(index);<br>                checkForComodification();<br>                return l.get(index+offset);<br>            } finally {<br>                lock.unlock();<br>            }<br>        }","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467954,"discussion_content":"这个是里面的一个内部类的😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569668081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":125401,"user_name":"给心来块冰块","can_delete":false,"product_type":"c1","uid":1063689,"ip_address":"","ucode":"7AFB56581782A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/09/2cf074a7.jpg","comment_is_top":false,"comment_ctime":1566179586,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1566179586","product_id":100023901,"comment_content":"是否可以把HashMap换成ConcurrentSkipListMap,然后再看cpu的资源使用情况","like_count":0},{"had_liked":false,"id":120383,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1564852353,"is_pvip":false,"replies":[{"id":"53799","content":"我也没有深入对比过，vector这个容器在其他语言里也有，可能是为了某种形式上的标准化才创建的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1570670476,"ip_address":"","comment_id":120383,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1564852353","product_id":100023901,"comment_content":"老师，collectios版的arraylist和vector是不是性能有差别么？如果有差在哪边？我看他们都是用synchronized锁方法","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461309,"discussion_content":"我也没有深入对比过，vector这个容器在其他语言里也有，可能是为了某种形式上的标准化才创建的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570670476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118023,"user_name":"业余草","can_delete":false,"product_type":"c1","uid":1126538,"ip_address":"","ucode":"99BDC1E629049D","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/8a/b5ca7286.jpg","comment_is_top":false,"comment_ctime":1564213755,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564213755","product_id":100023901,"comment_content":"写的很好，需要细细品味","like_count":0},{"had_liked":false,"id":97028,"user_name":"wang","can_delete":false,"product_type":"c1","uid":1270262,"ip_address":"","ucode":"C1A3BCACCB188E","user_header":"https://static001.geekbang.org/account/avatar/00/13/61/f6/1d6b548a.jpg","comment_is_top":false,"comment_ctime":1558574152,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558574152","product_id":100023901,"comment_content":"跳表不是可以做到查找时间复杂度为log(n)么","like_count":0},{"had_liked":false,"id":93826,"user_name":"xiaoming","can_delete":false,"product_type":"c1","uid":1444765,"ip_address":"","ucode":"242B4C52B2B865","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/e6TFib156x0VEiaWPkwpgAqgqJ8P07WpHPicRTWqnBIAW6br6yoXDA6kCdAlWBBjlqFtlyyhM4rPzUhlF8IdMPhZQ/132","comment_is_top":false,"comment_ctime":1557631235,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557631235","product_id":100023901,"comment_content":"List list = Collections.synchronizedList(new ArrayList());<br>Iterator i = list.iterator();<br>while (i.hasNext())<br>  foo(i.next());<br>老师, 这段代码是否可以这样理解？  while (i.hasNext())   foo(i.next()); 这段代码没有加锁,  多个线程可以同时操作。 <br>A线程 list[0]= i.next(), 与B线程list[0] = i.next()获取了相同的数据data = 0,  <br>假设foo就是进行+1的操作<br>然后A,B线程都对data进行 操作 foo(data) ，两个线程运行完后, list[0] =1。  <br>如果加锁list了, 这段就是就是互斥的, A线程执行完后释放了锁list,  B线程获取锁才能执行while (i.hasNext())  foo(i.next()); 两个线程都执行完成后 list[0] =2；","like_count":0},{"had_liked":false,"id":93377,"user_name":"刘鹏","can_delete":false,"product_type":"c1","uid":1524765,"ip_address":"","ucode":"48A831C5D2031C","user_header":"https://static001.geekbang.org/account/avatar/00/17/44/1d/833b3890.jpg","comment_is_top":false,"comment_ctime":1557459818,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557459818","product_id":100023901,"comment_content":"cpu 100%的猜测--》可能用jstack看看？？？？？？","like_count":0},{"had_liked":false,"id":90677,"user_name":"平头辉辉","can_delete":false,"product_type":"c1","uid":1180283,"ip_address":"","ucode":"9BB2AD9ACD14CE","user_header":"https://static001.geekbang.org/account/avatar/00/12/02/7b/eae23749.jpg","comment_is_top":false,"comment_ctime":1556608156,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556608156","product_id":100023901,"comment_content":"空间复杂度也不一样","like_count":0},{"had_liked":false,"id":90625,"user_name":"彭锐","can_delete":false,"product_type":"c1","uid":1179669,"ip_address":"","ucode":"F2CB53DE42026D","user_header":"https://static001.geekbang.org/account/avatar/00/12/00/15/6e399ec7.jpg","comment_is_top":false,"comment_ctime":1556590614,"is_pvip":false,"replies":[{"id":"32459","content":"skiplist的优点是稳定，hash不是所有情况下都是O1。另外还要看他解决key冲突的策略是什么","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556606916,"ip_address":"","comment_id":90625,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556590614","product_id":100023901,"comment_content":"性能上，ConcurrentHashMap怎么会比ConcurrentSkipListMap更差呢？Hash本身的复杂度都是O(1)，两者并发上都使用了分段加锁技术。这个性能差在哪里了呢？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448599,"discussion_content":"skiplist的优点是稳定，hash不是所有情况下都是O1。另外还要看他解决key冲突的策略是什么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556606916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85932,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1555295220,"is_pvip":false,"replies":[{"id":"30898","content":"链表死循环了","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555299978,"ip_address":"","comment_id":85932,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555295220","product_id":100023901,"comment_content":"老师，hashmap 扩容时，会遍历链表我能想来，但是为啥cpu会飙升到100%, 是因为扩容时遍历的是无界链表的原因嘛？   😭😭😭😭","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446870,"discussion_content":"链表死循环了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555299978,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85735,"user_name":"undifined","can_delete":false,"product_type":"c1","uid":1068920,"ip_address":"","ucode":"449CB4CD2DC089","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/78/c3d8ecb0.jpg","comment_is_top":false,"comment_ctime":1555216097,"is_pvip":false,"replies":[{"id":"30826","content":"cow的读是无锁的，这个是关键<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555225894,"ip_address":"","comment_id":85735,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555216097","product_id":100023901,"comment_content":"老师 CopyOnWriteArrayList 如果用于读多写少的场景，而且短暂不一致，其实真正可用的场景比较少，如果增加元素不会引起扩容，那加锁的开销是不是比复制数组小，这样看 CopyOnWriteArrayList 其实不是很有意义 ","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446784,"discussion_content":"cow的读是无锁的，这个是关键\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555225894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}