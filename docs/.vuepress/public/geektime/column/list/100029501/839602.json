{"id":839602,"title":"加餐06｜SQL实战：快消场景的数据查询与优化","content":"<p>你好，我是陈博士。今天我们来看下麦当劳如何通过数据查询与分析来优化其业务运营。</p><p>麦当劳每天处理大量的交易，涉及数以百万计的顾客订单。有效的数据分析不仅有助于理解顾客消费行为和偏好，还能够为管理层提供决策支持。</p><p></p><p>针对该场景，我整理了5张数据表以及对应的查询问题。针对这些查询问题，你可以了解到这些SQL该如何撰写。</p><h2><strong>数据表</strong></h2><ul>\n<li><strong>订单表 orders</strong><br>\n<img src=\"https://static001.geekbang.org/resource/image/0f/b1/0f331b0d7d23b90fd78ce6cbb0d69cb1.jpg?wh=1798x1520\" alt=\"\"></li>\n</ul><p></p><ul>\n<li><strong>订单明细表 order_details</strong><br>\n<img src=\"https://static001.geekbang.org/resource/image/05/a1/05f2a4bc77b0aa12aed302dbb18f77a1.jpg?wh=1800x810\" alt=\"\"></li>\n</ul><p></p><ul>\n<li><strong>产品表 products</strong><br>\n<img src=\"https://static001.geekbang.org/resource/image/37/e5/374ec704448b03f990a0d7a9fyy402e5.jpg?wh=1802x1220\" alt=\"\"></li>\n</ul><p></p><ul>\n<li><strong>门店表 stores</strong><br>\n<img src=\"https://static001.geekbang.org/resource/image/68/fa/6832ccaba343ab13b05c1a4d95c576fa.jpg?wh=1808x1502\" alt=\"\"></li>\n</ul><p></p><ul>\n<li><strong>会员表 (members)</strong><br>\n<img src=\"https://static001.geekbang.org/resource/image/f8/a0/f8eaba74a4a4219a693e12911ae646a0.jpg?wh=1820x1222\" alt=\"\"></li>\n</ul><p></p><h2><strong>问题设定</strong></h2><p>我从门店分析、销售分析、产品分析、会员分析、订单分析、组合分析等维度设置了一些常见的查询问题，一起来看一下。</p><h3><strong>门店分析</strong></h3><ul>\n<li>各城市门店数量分布</li>\n</ul><pre><code class=\"language-plain\">&nbsp;SELECT city, COUNT(*) as store_count\nFROM stores\nGROUP BY city\nORDER BY store_count DESC\nLIMIT 10;\n&nbsp;\n// 说明：使用 GROUP BY 对城市进行分组，COUNT(*) 统计各城市门店数量，ORDER BY 和 LIMIT 限制结果，展示门店数量最多的前10个城市。\n</code></pre><p></p><ul>\n<li>查找最近30天新开业的门店</li>\n</ul><pre><code class=\"language-plain\">SELECT store_name, city, address, created_time\nFROM stores\nWHERE created_time &gt;= DATE_SUB(CURDATE(), INTERVAL 30 DAY)\nORDER BY created_time DESC;\n&nbsp;\n// 说明：使用 DATE_SUB 和 CURDATE() 函数计算最近30天的时间范围，WHERE 子句筛选新开业的门店，ORDER BY 按创建时间降序排列。\n</code></pre><!-- [[[read_end]]] --><p></p><ul>\n<li>统计各省份的门店数量</li>\n</ul><pre><code class=\"language-plain\">SELECT province, COUNT(*) as store_count\nFROM stores\nGROUP BY province\nORDER BY store_count DESC;\n&nbsp;\n// 说明：使用 GROUP BY province 对省份进行分组，COUNT(*) 统计每个省份的门店数量，ORDER BY store_count DESC 按门店数量降序排列，展示各省份的门店分布情况。\n</code></pre><p></p><h3><strong>销售分析</strong></h3><ul>\n<li>统计最近30天各门店的销售额</li>\n</ul><pre><code class=\"language-plain\">SELECT s.store_name,\n&nbsp; &nbsp; &nbsp; &nbsp;COUNT(o.order_id) as order_count,\n&nbsp; &nbsp; &nbsp; &nbsp;SUM(o.payment_amount) as total_sales\nFROM orders o\nJOIN stores s ON o.store_id = s.store_id\nWHERE o.created_time &gt;= DATE_SUB(CURDATE(), INTERVAL 30 DAY)\nGROUP BY s.store_id, s.store_name\nORDER BY total_sales DESC;\n&nbsp;\n// 说明：通过JOIN 连接订单和门店表，使用 WHERE 筛选最近30天的数据，GROUP BY 按门店分组，SUM 和 COUNT 分别计算销售额和订单数。\n&nbsp;\nDATE_SUB 是 SQL 中用于日期运算的函数之一，主要用于从给定日期中减去一个时间间隔。它对于筛选特定时间段的数据非常有用。\n</code></pre><p></p><ul>\n<li>统计各支付方式的使用比例</li>\n</ul><pre><code class=\"language-plain\">SELECT\n&nbsp; &nbsp; payment_method,\n&nbsp; &nbsp; COUNT(*) as use_count,\n&nbsp; &nbsp; ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM orders), 2) as percentage\nFROM orders\nGROUP BY payment_method;\n&nbsp;\n// 说明：使用 GROUP BY payment_method 分组统计每种支付方式的使用次数，通过子查询计算总订单数，ROUND 函数计算并格式化各支付方式的使用比例。\n</code></pre><p></p><ul>\n<li>按小时统计订单量分布</li>\n</ul><pre><code class=\"language-plain\">SELECT\n&nbsp; &nbsp; HOUR(created_time) as hour,\n&nbsp; &nbsp; COUNT(*) as order_count\nFROM orders\nGROUP BY HOUR(created_time)\nORDER BY hour;\n&nbsp;\n// 说明：使用 HOUR(created_time) 提取订单创建时间的小时部分，GROUP BY 按小时分组统计订单量，ORDER BY hour 按小时顺序排列，展示每小时的订单分布情况。\n</code></pre><p></p><h3><strong>产品分析</strong></h3><ul>\n<li>销量TOP10的产品</li>\n</ul><pre><code class=\"language-plain\">SELECT\n&nbsp; &nbsp; p.product_name,\n&nbsp; &nbsp; p.category_id,\n&nbsp; &nbsp; SUM(od.quantity) as total_quantity,\n&nbsp; &nbsp; SUM(od.subtotal) as total_amount\nFROM order_details od\nJOIN products p ON od.product_id = p.product_id\nGROUP BY p.product_id, p.product_name, p.category_id\nORDER BY total_quantity DESC\nLIMIT 10;\n&nbsp;\n// 说明：通过 JOIN 连接订单明细和产品表，使用 GROUP BY 按产品分组，SUM 计算总销量和总金额，ORDER BY total_quantity DESC 按销量排序，LIMIT 10 展示销量最高的10个产品。\n</code></pre><p></p><ul>\n<li>各品类销售占比</li>\n</ul><pre><code class=\"language-plain\">SELECT\n&nbsp; &nbsp; p.category_id,\n&nbsp; &nbsp; COUNT(DISTINCT od.order_id) as order_count,\n&nbsp; &nbsp; SUM(od.quantity) as total_quantity,\n&nbsp; &nbsp; SUM(od.subtotal) as total_amount,\n&nbsp; &nbsp; ROUND(SUM(od.subtotal) * 100.0 / (SELECT SUM(subtotal) FROM order_details), 2) as sales_percentage\nFROM order_details od\nJOIN products p ON od.product_id = p.product_id\nGROUP BY p.category_id\nORDER BY total_amount DESC;\n&nbsp;\n// 说明：ROUND(SUM(od.subtotal) * 100.0 / (SELECT SUM(subtotal) FROM order_details), 2) 这个表达式用于计算每个类别的销售额占总销售额的百分比，并将结果保留两位小数。\n</code></pre><p></p><h3><strong>会员分析</strong></h3><ul>\n<li>会员等级分布</li>\n</ul><pre><code class=\"language-plain\">SELECT\n&nbsp; &nbsp; member_level,\n&nbsp; &nbsp; COUNT(*) as member_count,\n&nbsp; &nbsp; ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM members), 2) as percentage\nFROM members\nGROUP BY member_level;\n&nbsp;\n// 说明：使用 GROUP BY member_level 按会员等级分组，COUNT(*) 统计各等级会员数量，通过子查询计算总会员数，ROUND 函数计算并格式化各等级会员占比。\n</code></pre><ul>\n<li>最近30天新增会员数</li>\n</ul><pre><code class=\"language-plain\">SELECT\n&nbsp; &nbsp; DATE(register_time) as register_date,\n&nbsp; &nbsp; COUNT(*) as new_member_count\nFROM members\nWHERE register_time &gt;= DATE_SUB(CURDATE(), INTERVAL 30 DAY)\nGROUP BY DATE(register_time)\nORDER BY register_date;\n&nbsp;\n// 说明：使用 DATE(register_time) 提取注册日期，WHERE 筛选最近30天的数据，GROUP BY DATE(register_time) 按天统计新增会员数，ORDER BY register_date 按日期排序展示。\n</code></pre><p></p><ul>\n<li>会员消费行为分析</li>\n</ul><pre><code class=\"language-plain\">SELECT\n&nbsp; &nbsp; m.member_level,\n&nbsp; &nbsp; COUNT(DISTINCT o.member_id) as active_members,\n&nbsp; &nbsp; COUNT(o.order_id) as total_orders,\n&nbsp; &nbsp; ROUND(COUNT(o.order_id) * 1.0 / COUNT(DISTINCT o.member_id), 2) as avg_orders_per_member,\n&nbsp; &nbsp; ROUND(AVG(o.payment_amount), 2) as avg_amount_per_order,\n&nbsp; &nbsp; ROUND(SUM(o.payment_amount) * 1.0 / COUNT(DISTINCT o.member_id), 2) as avg_amount_per_member\nFROM orders o\nJOIN members m ON o.member_id = m.member_id\nGROUP BY m.member_level;\n&nbsp;\n// 说明：通过 JOIN 连接订单和会员表，按会员等级分组，统计活跃会员数、总订单数、平均每人订单数、平均每笔订单金额及平均每人消费金额，全面分析会员消费行为。\n</code></pre><p></p><h3><strong>订单分析</strong></h3><ul>\n<li>订单完成率</li>\n</ul><pre><code class=\"language-plain\">SELECT\n&nbsp; &nbsp; order_status,\n&nbsp; &nbsp; COUNT(*) as order_count,\n&nbsp; &nbsp; ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM orders), 2) as percentage\nFROM orders\nGROUP BY order_status;\n&nbsp;\n// 说明：使用 GROUP BY order_status 按订单状态分组，统计各状态的订单数量，通过子查询计算总订单数，ROUND 函数计算并格式化各状态订单的占比，分析订单完成率。\n</code></pre><p></p><ul>\n<li>平均订单处理时间（分钟）</li>\n</ul><pre><code class=\"language-plain\">SELECT\n&nbsp; &nbsp; AVG(TIMESTAMPDIFF(MINUTE, created_time, payment_time)) as avg_payment_time,\n&nbsp; &nbsp; AVG(TIMESTAMPDIFF(MINUTE, payment_time, complete_time)) as avg_process_time,\n&nbsp; &nbsp; AVG(TIMESTAMPDIFF(MINUTE, created_time, complete_time)) as avg_total_time\nFROM orders\nWHERE order_status = 3; &nbsp;-- 已完成的订单\n&nbsp;\n// 说明：使用 TIMESTAMPDIFF 计算订单各阶段的时间差（分钟），AVG 求平均值，WHERE order_status = 3 筛选已完成订单，统计平均支付时间、处理时间和总时间。\n</code></pre><p></p><ul>\n<li>各时段订单量和金额分布</li>\n</ul><pre><code class=\"language-plain\">SELECT\n&nbsp; &nbsp; CASE\n&nbsp; &nbsp; &nbsp; &nbsp; WHEN HOUR(created_time) BETWEEN 6 AND 9 THEN '早餐'\n&nbsp; &nbsp; &nbsp; &nbsp; WHEN HOUR(created_time) BETWEEN 10 AND 13 THEN '午餐'\n&nbsp; &nbsp; &nbsp; &nbsp; WHEN HOUR(created_time) BETWEEN 14 AND 16 THEN '下午茶'\n&nbsp; &nbsp; &nbsp; &nbsp; WHEN HOUR(created_time) BETWEEN 17 AND 20 THEN '晚餐'\n&nbsp; &nbsp; &nbsp; &nbsp; ELSE '夜宵'\n&nbsp; &nbsp; END as meal_period,\n&nbsp; &nbsp; COUNT(*) as order_count,\n&nbsp; &nbsp; ROUND(AVG(payment_amount), 2) as avg_amount,\n&nbsp; &nbsp; SUM(payment_amount) as total_amount\nFROM orders\nGROUP BY meal_period\nORDER BY order_count DESC;\n&nbsp;\n// 说明：使用 CASE 语句按小时划分订单到不同的用餐时段，GROUP BY meal_period 统计各时段的订单量和金额，ORDER BY order_count DESC 按订单量降序排列，分析各时段的业务表现。\n</code></pre><p></p><h3><strong>组合分析</strong></h3><ul>\n<li>查找经常一起购买的产品组合</li>\n</ul><pre><code class=\"language-plain\">SELECT\n&nbsp; &nbsp; p1.product_name as product1,\n&nbsp; &nbsp; p2.product_name as product2,\n&nbsp; &nbsp; COUNT(*) as combination_count\nFROM order_details od1\nJOIN order_details od2 ON od1.order_id = od2.order_id AND od1.product_id &lt; od2.product_id\nJOIN products p1 ON od1.product_id = p1.product_id\nJOIN products p2 ON od2.product_id = p2.product_id\nGROUP BY p1.product_id, p2.product_id, p1.product_name, p2.product_name\nHAVING combination_count &gt; 10\nORDER BY combination_count DESC;\n&nbsp;\n// 说明：通过自连接 order_details 表匹配同一订单中的不同产品，使用 JOIN 连接产品表获取产品名称，GROUP BY 和 HAVING 筛选并统计购买次数超过10次的产品组合，按组合频率排序。\n</code></pre><p></p><ul>\n<li>会员消费升级分析（比较首次消费和最近一次消费）</li>\n</ul><pre><code class=\"language-plain\">WITH first_last_orders AS (\n&nbsp; &nbsp; SELECT\n&nbsp; &nbsp; &nbsp; &nbsp; member_id,\n&nbsp; &nbsp; &nbsp; &nbsp; MIN(created_time) as first_order_time,\n&nbsp; &nbsp; &nbsp; &nbsp; MAX(created_time) as last_order_time\n&nbsp; &nbsp; FROM orders\n&nbsp; &nbsp; GROUP BY member_id\n)\nSELECT\n&nbsp; &nbsp; m.member_level,\n&nbsp; &nbsp; ROUND(AVG(first_order.payment_amount), 2) as avg_first_amount,\n&nbsp; &nbsp; ROUND(AVG(last_order.payment_amount), 2) as avg_last_amount,\n&nbsp; &nbsp; ROUND(AVG(last_order.payment_amount - first_order.payment_amount), 2) as avg_amount_increase\nFROM first_last_orders fl\nJOIN orders first_order ON fl.member_id = first_order.member_id\n&nbsp; &nbsp; AND fl.first_order_time = first_order.created_time\nJOIN orders last_order ON fl.member_id = last_order.member_id\n&nbsp; &nbsp; AND fl.last_order_time = last_order.created_time\nJOIN members m ON fl.member_id = m.member_id\nGROUP BY m.member_level;\n&nbsp;\n// 说明：使用 WITH 子句获取每个会员的首次和最近一次消费时间，通过 JOIN 连接订单表和会员表，计算各会员等级的首次与最近一次平均消费金额及其增长，分析消费升级趋势。\n</code></pre><p>如果你是快消行业的从业人员，这节课将对你非常有帮助。</p><p>本次的课程迭代到这里就结束了，期待再会。如果你有更多SQL相关的学习需求，欢迎你留言给我，我们一起探讨！</p>","comments":[]}