{"id":78795,"title":"51 | 并行算法：如何利用并行处理提高算法的执行效率？","content":"<p>时间复杂度是衡量算法执行效率的一种标准。但是，时间复杂度并不能跟性能划等号。在真实的软件开发中，即便在不降低时间复杂度的情况下，也可以通过一些优化手段，提升代码的执行效率。毕竟，对于实际的软件开发来说，即便是像10%、20%这样微小的性能提升，也是非常可观的。</p><p>算法的目的就是为了提高代码执行的效率。那<strong>当算法无法再继续优化的情况下，我们该如何来进一步提高执行效率呢</strong>？我们今天就讲一种非常简单但又非常好用的优化方法，那就是并行计算。今天，我就通过几个例子，给你展示一下，<strong><span class=\"orange\">如何借助并行计算的处理思想对算法进行改造？</span></strong></p><h2>并行排序</h2><p>假设我们要给大小为8GB的数据进行排序，并且，我们机器的内存可以一次性容纳这么多数据。对于排序来说，最常用的就是时间复杂度为O(nlogn)的三种排序算法，归并排序、快速排序、堆排序。从理论上讲，这个排序问题，已经很难再从算法层面优化了。而利用并行的处理思想，我们可以很轻松地将这个给8GB数据排序问题的执行效率提高很多倍。具体的实现思路有下面两种。</p><p><strong>第一种是对归并排序并行化处理</strong>。我们可以将这8GB的数据划分成16个小的数据集合，每个集合包含500MB的数据。我们用16个线程，并行地对这16个500MB的数据集合进行排序。这16个小集合分别排序完成之后，我们再将这16个有序集合合并。</p><!-- [[[read_end]]] --><p><strong>第二种是对快速排序并行化处理</strong>。我们通过扫描一遍数据，找到数据所处的范围区间。我们把这个区间从小到大划分成16个小区间。我们将8GB的数据划分到对应的区间中。针对这16个小区间的数据，我们启动16个线程，并行地进行排序。等到16个线程都执行结束之后，得到的数据就是有序数据了。</p><p>对比这两种处理思路，它们利用的都是分治的思想，对数据进行分片，然后并行处理。它们的区别在于，第一种处理思路是，先随意地对数据分片，排序之后再合并。第二种处理思路是，先对数据按照大小划分区间，然后再排序，排完序就不需要再处理了。这个跟归并和快排的区别如出一辙。</p><p>这里我还要多说几句，如果要排序的数据规模不是8GB，而是1TB，那问题的重点就不是算法的执行效率了，而是数据的读取效率。因为1TB的数据肯定是存在硬盘中，无法一次性读取到内存中，这样在排序的过程中，就会有频繁地磁盘数据的读取和写入。如何减少磁盘的IO操作，减少磁盘数据读取和写入的总量，就变成了优化的重点。不过这个不是我们这节要讨论的重点，你可以自己思考下。</p><h2>并行查找</h2><p>我们知道，散列表是一种非常适合快速查找的数据结构。</p><p>如果我们是给动态数据构建索引，在数据不断加入的时候，散列表的装载因子就会越来越大。为了保证散列表性能不下降，我们就需要对散列表进行动态扩容。对如此大的散列表进行动态扩容，一方面比较耗时，另一方面比较消耗内存。比如，我们给一个2GB大小的散列表进行扩容，扩展到原来的1.5倍，也就是3GB大小。这个时候，实际存储在散列表中的数据只有不到2GB，所以内存的利用率只有60%，有1GB的内存是空闲的。</p><p>实际上，我们可以将数据随机分割成k份（比如16份），每份中的数据只有原来的1/k，然后我们针对这k个小数据集合分别构建散列表。这样，散列表的维护成本就变低了。当某个小散列表的装载因子过大的时候，我们可以单独对这个散列表进行扩容，而其他散列表不需要进行扩容。</p><p>还是刚才那个例子，假设现在有2GB的数据，我们放到16个散列表中，每个散列表中的数据大约是150MB。当某个散列表需要扩容的时候，我们只需要额外增加150*0.5=75MB的内存（假设还是扩容到原来的1.5倍）。无论从扩容的执行效率还是内存的利用率上，这种多个小散列表的处理方法，都要比大散列表高效。</p><p>当我们要查找某个数据的时候，我们只需要通过16个线程，并行地在这16个散列表中查找数据。这样的查找性能，比起一个大散列表的做法，也并不会下降，反倒有可能提高。</p><p>当往散列表中添加数据的时候，我们可以选择将这个新数据放入装载因子最小的那个散列表中，这样也有助于减少散列冲突。</p><h2>并行字符串匹配</h2><p>我们前面学过，在文本中查找某个关键词这样一个功能，可以通过字符串匹配算法来实现。我们之前学过的字符串匹配算法有KMP、BM、RK、BF等。当在一个不是很长的文本中查找关键词的时候，这些字符串匹配算法中的任何一个，都可以表现得非常高效。但是，如果我们处理的是超级大的文本，那处理的时间可能就会变得很长，那有没有办法加快匹配速度呢？</p><p>我们可以把大的文本，分割成k个小文本。假设k是16，我们就启动16个线程，并行地在这16个小文本中查找关键词，这样整个查找的性能就提高了16倍。16倍效率的提升，从理论的角度来说并不多。但是，对于真实的软件开发来说，这显然是一个非常可观的优化。</p><p>不过，这里还有一个细节要处理，那就是原本包含在大文本中的关键词，被一分为二，分割到两个小文本中，这就会导致尽管大文本中包含这个关键词，但在这16个小文本中查找不到它。实际上，这个问题也不难解决，我们只需要针对这种特殊情况，做一些特殊处理就可以了。</p><p>我们假设关键词的长度是m。我们在每个小文本的结尾和开始各取m个字符串。前一个小文本的末尾m个字符和后一个小文本的开头m个字符，组成一个长度是2m的字符串。我们再拿关键词，在这个长度为2m的字符串中再重新查找一遍，就可以补上刚才的漏洞了。</p><h2>并行搜索</h2><p>前面我们学习过好几种搜索算法，它们分别是广度优先搜索、深度优先搜索、Dijkstra最短路径算法、A*启发式搜索算法。对于广度优先搜索算法，我们也可以将其改造成并行算法。</p><p>广度优先搜索是一种逐层搜索的搜索策略。基于当前这一层顶点，我们可以启动多个线程，并行地搜索下一层的顶点。在代码实现方面，原来广度优先搜索的代码实现，是通过一个队列来记录已经遍历到但还没有扩展的顶点。现在，经过改造之后的并行广度优先搜索算法，我们需要利用两个队列来完成扩展顶点的工作。</p><p>假设这两个队列分别是队列A和队列B。多线程并行处理队列A中的顶点，并将扩展得到的顶点存储在队列B中。等队列A中的顶点都扩展完成之后，队列A被清空，我们再并行地扩展队列B中的顶点，并将扩展出来的顶点存储在队列A。这样两个队列循环使用，就可以实现并行广度优先搜索算法。</p><h2>总结引申</h2><p>上一节，我们通过实际软件开发中的“索引”这一技术点，回顾了之前学过的一些支持动态数据集合的数据结构。今天，我们又通过“并行算法”这个话题，回顾了之前学过的一些算法。</p><p>今天的内容比较简单，没有太复杂的知识点。我通过一些例子，比如并行排序、查找、搜索、字符串匹配，给你展示了并行处理的实现思路，也就是对数据进行分片，对没有依赖关系的任务，并行地执行。</p><p>并行计算是一个工程上的实现思路，尽管跟算法关系不大，但是，在实际的软件开发中，它确实可以非常巧妙地提高程序的运行效率，是一种非常好用的性能优化手段。</p><p>特别是，当要处理的数据规模达到一定程度之后，我们无法通过继续优化算法，来提高执行效率 的时候，我们就需要在实现的思路上做文章，利用更多的硬件资源，来加快执行的效率。所以，在很多超大规模数据处理中，并行处理的思想，应用非常广泛，比如MapReduce实际上就是一种并行计算框架。</p><h2>课后思考</h2><p>假设我们有n个任务，为了提高执行的效率，我们希望能并行执行任务，但是各个任务之间又有一定的依赖关系，如何根据依赖关系找出可以并行执行的任务？</p><p>欢迎留言和我分享，也欢迎点击“<span class=\"orange\">请朋友读</span>”，把今天的内容分享给你的好友，和他一起讨论、学习。</p>","neighbors":{"left":{"article_title":"50 | 索引：如何在海量数据中快速查找某个数据？","id":78449},"right":{"article_title":"52 | 算法实战（一）：剖析Redis常用数据类型对应的数据结构","id":79159}},"comments":[{"had_liked":false,"id":62874,"user_name":"失火的夏天","can_delete":false,"product_type":"c1","uid":1241770,"ip_address":"","ucode":"10C6E66EB2A65F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","comment_is_top":false,"comment_ctime":1548200445,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"907786299901","product_id":100017301,"comment_content":"思考题用一个有向图来存储任务之间的依赖关系，然后用拓扑排序的思想来执行任务，每次都找到入度为0的，放在队列里，启动线程池开始执行，队列里的任务并行执行完毕，再次调用拓扑排序找到入度为0的人，放入队列，直到所以任务跑完","like_count":212,"discussions":[{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":91361,"discussion_content":"嗯，还可以继续用双队列来优化","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576830161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1082785,"avatar":"https://static001.geekbang.org/account/avatar/00/10/85/a1/2442332c.jpg","nickname":"郭俊杰","note":"","ucode":"D328E5738A4413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":244564,"discussion_content":"拓扑sort, 这么快就用上派场了，哈哈","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587612955,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1127175,"avatar":"https://static001.geekbang.org/account/avatar/00/11/33/07/8f351609.jpg","nickname":"JustDoDT","note":"","ucode":"6AF0B80F00EAEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24516,"discussion_content":"优秀","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1570163816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1796438,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/zlWt0lPDicdib5BTUbuwA3wLLUuejtZ5icGu3DHMBPd6PicXOdhZ3zYFts8VkXjjyQuxzUJas2w5OTmx3icWKiaZM1Vg/132","nickname":"youyou.L","note":"","ucode":"B3DB0D0700EEAC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326342,"discussion_content":"拓扑+并行更佳，多个队列并行取入度为0的顶点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605581784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1260026,"avatar":"https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg","nickname":"安排","note":"","ucode":"F78CFA9624CAEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295909,"discussion_content":"活学活用啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596380250,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1243570,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f9/b2/2ed800b4.jpg","nickname":"社会你强哥","note":"","ucode":"325B9005588D9B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":262084,"discussion_content":"拓扑排序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589036301,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1389604,"avatar":"https://static001.geekbang.org/account/avatar/00/15/34/24/34ca1d23.jpg","nickname":"阿信","note":"","ucode":"50616ED68A5B40","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50249,"discussion_content":"正解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573696600,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":62974,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1548217905,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"216296582705","product_id":100017301,"comment_content":"一看到依赖，就想到了拓扑。<br><br>这种感觉好是还是不好呢？","like_count":51,"discussions":[{"author":{"id":1364248,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d1/18/5cc21f63.jpg","nickname":"万里国度","note":"","ucode":"9B47C4E69DAC8E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311369,"discussion_content":"最后思考题已经不是本节得算法问题了，而是如果高效实现多线程临界资源顺序共享得问题，计算机原理里面提到的优先级队列等一系列进程调度问题已经给出了解释","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1602318692,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1215892,"avatar":"https://static001.geekbang.org/account/avatar/00/12/8d/94/150dfe78.jpg","nickname":"GGL","note":"","ucode":"AED10B8248D1E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303556,"discussion_content":"+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599297304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1810050,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9e/82/61e5acf7.jpg","nickname":"MooNight","note":"","ucode":"B5B5876841E33E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":274972,"discussion_content":"+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590639179,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123507,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1565689209,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"186249282937","product_id":100017301,"comment_content":"现在才明白，其实最底层的数据结构是&lt;addr,value&gt;，按照存储介质是否连续、是否显示制定key又可以分为数组、链表和hash，其中数组可以认为是一种&lt;index,arr[index]&gt;，链表是&lt;p,*p&gt;，然后在这基础之上衍生出了一维的线性表、栈、队列，散列表，二维的树(平衡二叉树、红黑树、跳表)，三维的图，还有就是各种数据结构灵活组合的数据结构，这里的跳表可以算是组合类型的，但是它的使用范围很多，所以划到了二维中。这些是存储<br>然后是算法：排序、分治、贪心、回溯、动态规划<br>第一次真正感觉到了数据结构和算法的关联，好神奇的感觉。至少现在觉得那些难记的算法、数据结构没那么困难了，多思考、实践总会能够像写代码般应用到实际中。","like_count":44,"discussions":[{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":91354,"discussion_content":"hash？散列表，也是基于数组或者链表的啊\n真正的底层数据结构 只有 数组 + 链表","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576829776,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1233193,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","nickname":"DFighting","note":"","ucode":"F3BA2426FF8582","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":91421,"discussion_content":"如果按照存储的位置是否连续划分，只是数组和链表，但更深一点分析，它们都是存储在某一个位置的值<地址，值>，我觉得这也是一种映射关系，是hash，数组和链表更像是在这之上的一个发散。不过从应用的角度来看，你说的才是数据结构与算法的基础。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576833212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":91354,"ip_address":""},"score":91421,"extra":""}]}]},{"had_liked":false,"id":63039,"user_name":"hua168","can_delete":false,"product_type":"c1","uid":1065255,"ip_address":"","ucode":"CFF9A7E86EBA48","user_header":"https://static001.geekbang.org/account/avatar/00/10/41/27/3ff1a1d6.jpg","comment_is_top":false,"comment_ctime":1548234547,"is_pvip":false,"discussion_count":9,"race_medal":0,"score":"70267711283","product_id":100017301,"comment_content":"老师，我就问一个题外问题：<br>大专学历，想直接自学考本科或研究生，自考学历IT类公司承认的吗？<br>很多都要求全日制本科~~","like_count":16,"discussions":[{"author":{"id":1042983,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/27/a3737d61.jpg","nickname":"Shanks-王冲","note":"","ucode":"C4B90A17850E20","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302442,"discussion_content":"如果你是985 or 211，校招可能是最好进大厂的机会；之后要是进入了社会，那就需要自己专、精 —— 毕业之后，再考虑通过文凭，是几乎不太可能的(~1%); 真相搞IT这一块，显然你发现了极客时间；剩下就是要自己专心打磨自己的技术了；你对自己的数据结构与算法有要求，那就多刷刷LeetCode —— 找自己不太熟悉的知识点刷；然后去参加浙大的pat考试(https://www.patest.cn/); 当然，如果你是搞Java的，Java方面技术要多研究，aoe也提到找个开源项目好好贡献；想搞Android/iOS，也是一样，专研技术、精一点；基本上进大厂，or小厂慢慢走向更高的岗位也是可以的；最后，我很负责地说，工作1-2年后，就不应该再考虑学历问题，现在的学历对你来说是个迷思，就是干，干到比如说Java开发者的20%，基本上物质生活也绰绰有余；不如多想想 —— 如何有条不紊地提升自己的技术，扩大自己的技术影响力，哪怕从自己公司开始。祝你好运！","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1598925488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1042983,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/27/a3737d61.jpg","nickname":"Shanks-王冲","note":"","ucode":"C4B90A17850E20","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332747,"discussion_content":"赞！mark。学习了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607330417,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":302442,"ip_address":""},"score":332747,"extra":""}]},{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40335,"discussion_content":"大公司不同的岗位对学历要求不一样，也有不要求学历的。但越是对学历低要求的对技术要求越高。如果对开源社区有显著贡献，这个时候不看学历。可以找一个自己感兴趣的开源技术，深入学习，在学习的过程中提升自己，技术好了，工作就好找了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1572168720,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332748,"discussion_content":"赞！mark。学习了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1607330423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":40335,"ip_address":""},"score":332748,"extra":""}]},{"author":{"id":1082785,"avatar":"https://static001.geekbang.org/account/avatar/00/10/85/a1/2442332c.jpg","nickname":"郭俊杰","note":"","ucode":"D328E5738A4413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":244565,"discussion_content":"大部分企业只认统招，有些企业两者都认，但很少，自考学历，作用不大，有胜于无，认识清楚即可，哥也在自考中。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587613176,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2044188,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/bNQ1xdysiatMnMYpibXw70cpWPkuA2JXiaR0eDq7dia9oBic2z3SqFY84aRnEPH3QMgSklE6JSMZAPfKYukX6kPLoZQ/132","nickname":"Be_Young","note":"","ucode":"ACDBB2DD99738A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545881,"discussion_content":"认的啊，我朋友专升本，校招拿下携程JAVA后端","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642071103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1020525,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","nickname":"escray","note":"","ucode":"1F4204930E47C4","race_medal":2,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278443,"discussion_content":"不知道你现在的境遇如何？我记得老师在前一次课程的留言里面回答过你的问题，我也收益颇多。我的问题在于年龄。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591186991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1275407,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/0f/c7c8021d.jpg","nickname":"豆豆","note":"","ucode":"97788B134C3212","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020525,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","nickname":"escray","note":"","ucode":"1F4204930E47C4","race_medal":2,"user_type":1,"is_pvip":true},"discussion":{"id":286123,"discussion_content":"你多大啊？哥，怎么解决年龄的问题？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593067206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":278443,"ip_address":""},"score":286123,"extra":""}]},{"author":{"id":1131687,"avatar":"https://static001.geekbang.org/account/avatar/00/11/44/a7/171c1e86.jpg","nickname":"啦啦啦","note":"","ucode":"6B12EC90A62525","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87335,"discussion_content":"我已经报了尚德的，准备自考了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576662359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":65712,"user_name":"🐱您的好友William🐱","can_delete":false,"product_type":"c1","uid":1215456,"ip_address":"","ucode":"427786DB178965","user_header":"https://static001.geekbang.org/account/avatar/00/12/8b/e0/9a79ddac.jpg","comment_is_top":false,"comment_ctime":1549598405,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"57384173253","product_id":100017301,"comment_content":"使用拓扑关系来构建图安排计算顺序，这个spark，tensorflow都是这么安排的，效率比最开始的MapReduce还要高很多。","like_count":13,"discussions":[{"author":{"id":1476490,"avatar":"https://static001.geekbang.org/account/avatar/00/16/87/8a/07ab933c.jpg","nickname":"璀璨星空","note":"","ucode":"CE6324C4261A52","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336795,"discussion_content":"spark 是内存计算，MapReduce的计算数据是要轮盘的，你自己去了解下就知道了，spark计算肯定快鱼MapReduce","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608703959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":62863,"user_name":"茴香根","can_delete":false,"product_type":"c1","uid":1316111,"ip_address":"","ucode":"B91C00B72077F1","user_header":"https://static001.geekbang.org/account/avatar/00/14/15/0f/954be2db.jpg","comment_is_top":false,"comment_ctime":1548194895,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"53087802447","product_id":100017301,"comment_content":"思考题讲的够直白了，n个任务有互相依赖。那么并行处理的方法就要采用流水线的思想了。创建n个线程，每个线程完成一个任务。每个线程在它的上游线程结束输出结果后启动，完成之后把结果传递给下游任务线程继续流程。整个工作场景像工厂里面的流水线一样，每一个线程都努力地重复着某一阶段的任务，提高整体资源利用率。","like_count":12,"discussions":[{"author":{"id":2668694,"avatar":"https://static001.geekbang.org/account/avatar/00/28/b8/96/716ba431.jpg","nickname":"苏成","note":"","ucode":"80A8E7B243DD73","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572311,"discussion_content":"这个思路牛逼的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652700270,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93075,"user_name":"Geek_46cdcd","can_delete":false,"product_type":"c1","uid":1484198,"ip_address":"","ucode":"F67F8709F63A2C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJQyP4WVaRJVV3OQ6icPfjicf2JqHjNGw0PhhOMnibicoMzLC3xzibHuibd9s2c3uWa1Y9Gg721L4cO2MUQ/132","comment_is_top":false,"comment_ctime":1557391128,"is_pvip":false,"replies":[{"id":"33558","content":"是的","user_name":"作者回复","comment_id":93075,"uid":"1190123","ip_address":"","utype":1,"ctime":1557703100,"user_name_real":"王争"}],"discussion_count":3,"race_medal":0,"score":"44507064088","product_id":100017301,"comment_content":"请问老师，广度优先搜索中用两个队列是为了解决多线程的并发问题吗？","like_count":10,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449481,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557703100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1396572,"avatar":"https://static001.geekbang.org/account/avatar/00/15/4f/5c/427ae218.jpg","nickname":"斗魂","note":"","ucode":"EAD676A9F2C786","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4942,"discussion_content":"请问老师能不能详细介绍一下为什么一个队列会有并发问题？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565848389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1616622,"avatar":"https://static001.geekbang.org/account/avatar/00/18/aa/ee/15c328ca.jpg","nickname":"ɴɪᴋᴇʀ","note":"","ucode":"DB7D92CBB5FD15","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1396572,"avatar":"https://static001.geekbang.org/account/avatar/00/15/4f/5c/427ae218.jpg","nickname":"斗魂","note":"","ucode":"EAD676A9F2C786","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311748,"discussion_content":"因为一个队列在进行BFS时，记录下一层节点时用的是自身，放到多线程中，它们共用一个队列不就等于产生了依赖","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602481430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4942,"ip_address":""},"score":311748,"extra":""}]}]},{"had_liked":false,"id":84232,"user_name":"xuery","can_delete":false,"product_type":"c1","uid":1027584,"ip_address":"","ucode":"F461B61BE06131","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/00/025f37e7.jpg","comment_is_top":false,"comment_ctime":1554810602,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"40209516266","product_id":100017301,"comment_content":"想到的第一个思路就是前面所讲的拓扑排序，任务之间的关系用有向图表示，如果是采用khan遍历，则每次找到入度为0的，同时多线程执行，等他们执行完（java可以通过CountDownLatch来模拟实现），然后同理找到入度为0的任务，继续同理执行，直到全部执行完","like_count":9},{"had_liked":false,"id":62975,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1548218387,"is_pvip":false,"replies":[{"id":"22478","content":"也可以的。不过就有可能导致没法找到最短路径了。","user_name":"作者回复","comment_id":62975,"uid":"1190123","ip_address":"","utype":1,"ctime":1548405169,"user_name_real":"gg"}],"discussion_count":1,"race_medal":0,"score":"35907956755","product_id":100017301,"comment_content":"并行搜索只用一个队列不可以么？","like_count":8,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437423,"discussion_content":"也可以的。不过就有可能导致没法找到最短路径了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548405169,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":62884,"user_name":"纯洁的憎恶","can_delete":false,"product_type":"c1","uid":1130512,"ip_address":"","ucode":"5E9757DE6F45DF","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/10/b6bf3c3c.jpg","comment_is_top":false,"comment_ctime":1548202541,"is_pvip":true,"replies":[{"id":"22482","content":"并行是一种工程思路。分治是一种算法思想。感觉差不多哈；）你理解就好，不要太纠结；）","user_name":"作者回复","comment_id":62884,"uid":"1190123","ip_address":"","utype":1,"ctime":1548405728,"user_name_real":"gg"}],"discussion_count":1,"race_medal":0,"score":"31612973613","product_id":100017301,"comment_content":"并行与分治的区别是什么？前者偏工程，后者偏算法么？还是前者在并发环境中，后者在单核串行环境中？","like_count":7,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437383,"discussion_content":"并行是一种工程思路。分治是一种算法思想。感觉差不多哈；）你理解就好，不要太纠结；）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548405728,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176705,"user_name":"注定非凡","can_delete":false,"product_type":"c1","uid":1113597,"ip_address":"","ucode":"80673056E131B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","comment_is_top":false,"comment_ctime":1581144745,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"23055981225","product_id":100017301,"comment_content":"算法的目的就是为了提高代码执行的效率。当算法无法再继续优化的情况下，需要借助并行计算的处理思想对算法进行改造<br><br>并行排序<br>假设要给大小为 8GB 的数据进行排序，最常用的是三种排序算法，归并排序、快速排序、堆排序，时间复杂度为 O(nlogn) 。从理论上讲，已经很难再从算法层面优化了。而利用并行的处理思想可以将执行效率提高很多倍。<br><br>第一种是对归并排序并行化处理<br>\t* 将这8GB 的数据划分成 16 个小的数据集合，每个集合包含 500MB 的数据。<br>\t* 用 16 个线程，并行地对这 16 个 500MB 的数据集合进行排序。<br>\t* 16 个小集合分别排序完成之后，再将这 16 个有序集合合并。<br><br>第二种是对快速排序并行化处理<br>\t* 将数据扫描一遍，找到数据所处的范围区间，在按从小到大划分成 16 个小区间。<br>\t* 将 8GB 的数据划分到对应的16 个小区间中，启动 16 个线程，并行地进行排序。<br>\t* 等到 16 个线程都执行结束后，得到的数据就是有序数据了。<br><br>对比这两种处理思路<br>\t* 共同点：它们利用的都是分治的思想，对数据进行分片，然后并行处理。<br>\t* 不同点：<br>        （1）第一种处理思路是，先随意地对数据分片，排序之后再合并。<br>        （2）第二种处理思路是，先对数据按照大小划分区间后再排序，排完序就不需要再处理了。<br>\t* 这个跟归并和快排的区别如出一辙。<br><br>并行查找<br>      散列表是一种非常适合快速查找的数据结构。<br>弊端：<br>\t* 如果给动态数据构建索引，数据不断加入会使散列表的装载因子越来越大<br>\t* 为了保证散列表性能不下降，就需要对散列表进行动态扩容<br>\t* 对巨大的散列表进行动态扩容，不仅比较耗时，还比较消耗内存<br>优化：<br>\t* 实际上可以将数据随机分割成 k 份（比如 16 份），每份中的数据只有原来的 1&#47;k<br>\t* 然后针对这 k 个小数据集合分别构建散列表。这样，散列表的维护成本就变低了<br>\t* 当某个小散列表的装载因子过大的时，可以单独对这个散列表进行扩容，而其他散列表不需要进行扩容。<br>\t* 当要查找数据时，通过 16 个线程并行地在这16 个散列表中查找数据。这样的查找性能，比起一个大散列表的做法，也并不会下降，反倒有可能提高。<br>\t* 当往散列表中添加数据时，可以将新数据放入装载因子最小的散列表中，这样也有助于减少散列冲突。<br><br><br>假设有 2GB 的数据，放到 16 个散列表中，每个散列表中的数据大约是 150MB。当某个散列表需要扩容的时候，我们只需要额外增加 150*0.5=75MB 的内存（假设还是扩容到原来的 1.5 倍）。不管从扩容的执行效率还是内存的利用率上，这种多个小散列表的处理方法，都要比大散列表高效<br><br>并行字符串匹配<br>在文本中查找某个关键词可以通过字符串匹配算法来实现，字符串匹配算法有 KMP、BM、RK、BF 等<br><br>如果处理的是超级大的文本，可以把大的文本，分割成 k 个小文本。假设 k 是 16，就启动 16 个线程，并行地在这 16 个小文本中查找关键词，这样整个查找的性能就提高了 16 倍<br><br>并行搜索<br>搜索算法有：广度优先搜索、深度优先搜索、Dijkstra 最短路径算法、A* 启发式搜索算法。对于广度优先搜索算法，也可以将其改造成并行算法。<br>\t* 广度优先搜索是一种逐层搜索的搜索策略<br>\t* 基于当前这一层顶点，我们可以启动多个线程，并行地搜索下一层的顶点<br>\t* 在代码实现方面，原来广度优先搜索的代码实现，是通过一个队列来记录已经遍历到但还没有扩展的顶点<br>\t* 经过改造之后的并行广度优先搜索算法，需要利用两个队列来完成扩展顶点的工作<br><br>","like_count":5,"discussions":[{"author":{"id":1357311,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b5/ff/d1f205b0.jpg","nickname":"L","note":"","ucode":"5B847B2378854E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302561,"discussion_content":"课代表","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598956185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154837,"user_name":"刺猬","can_delete":false,"product_type":"c1","uid":1108297,"ip_address":"","ucode":"60C3E38F4F03CC","user_header":"https://static001.geekbang.org/account/avatar/00/10/e9/49/29072f9e.jpg","comment_is_top":false,"comment_ctime":1574577377,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"18754446561","product_id":100017301,"comment_content":"王铮老师，你好，学习了这么久一直有一个疑问，之前讲的那个100G订单排序的问题，一大份数据分成多份小数据然后进行排序，原理其实很简单，但是分的时候可以用到什么算法，分完组合的时候用到什么算法，因为100G订单不是之前就分好的，要一次性分，那也需要扫描这100G订单，另外如果分的时候不是采用先对数据按照大小划分区间，然后再排序的话，那么在每一段内是有序的，但是不能保证组合以后也有序，所以组合的时候还有进行排序，这种情况有什么好的解决思路。","like_count":4,"discussions":[{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":91357,"discussion_content":"组合的时候，新建一个数组来存，扫描一遍，每次比对出最小的，存起来就好了\n此时的时间复杂度是 O(n)","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576830010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1899599,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/fc/4f/0a452c94.jpg","nickname":"大毛","note":"","ucode":"93B18287F06706","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":239014,"discussion_content":"你可以学习桶排序的思路，将订单数据划分为多个有序的桶（注意，此时是桶与桶之间有序，而桶的内部是无序的）。随后对桶内进行排序，排序完成后依次按照桶输出数据即可。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587267299,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1659177,"avatar":"https://static001.geekbang.org/account/avatar/00/19/51/29/24739c58.jpg","nickname":"凉人。","note":"","ucode":"4DB16004A62015","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":200568,"discussion_content":"鄙人拙见，100G数据按排序内容区分范围，范围切割至可保存得大小，假设500M. 然后便利数据，放入不同区间文件中，然后单独对每个文件排序。 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583683319,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1105912,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL1Jz3oKyJicGV9jLDZOFxsuP9PDCPAsXjwnfickQyhDCt1we7dGtdJNtHWz19OFOaqJsNfrX9Jotjg/132","nickname":"小迎纸","note":"","ucode":"AE2E5289B07F20","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":75915,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575795723,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115633,"user_name":"mrlay","can_delete":false,"product_type":"c1","uid":1041640,"ip_address":"","ucode":"385A1954ED3317","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e4/e8/a1703783.jpg","comment_is_top":false,"comment_ctime":1563679370,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14448581258","product_id":100017301,"comment_content":"我觉得能够并行执行多少个任务，是取决于这些任务之间的依赖关系；采用拓扑只是为了确认任务的先后执行。 最坏的情况下还是会变成串行的。","like_count":3},{"had_liked":false,"id":269300,"user_name":"一念_风生","can_delete":false,"product_type":"c1","uid":1577339,"ip_address":"","ucode":"13211B6B33C491","user_header":"https://static001.geekbang.org/account/avatar/00/18/11/7b/3426351c.jpg","comment_is_top":false,"comment_ctime":1608605679,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5903572975","product_id":100017301,"comment_content":"一言以蔽之：单线程不够 多线程来凑 需要考虑的就是如何将算法与多线程结合起来 其实就是要巧妙的利用分治思想 不知道我这样理解是否正确","like_count":1},{"had_liked":false,"id":184234,"user_name":"Jarvi","can_delete":false,"product_type":"c1","uid":1076673,"ip_address":"","ucode":"5A867283588912","user_header":"https://static001.geekbang.org/account/avatar/00/10/6d/c1/a1aae7af.jpg","comment_is_top":false,"comment_ctime":1583251736,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5878219032","product_id":100017301,"comment_content":"硬盘里1t的数据咋处理，有人有想法么","like_count":1,"discussions":[{"author":{"id":1298380,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cf/cc/8de5007b.jpg","nickname":"徐改","note":"","ucode":"82276A584AC602","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383498,"discussion_content":"开多几台server，对1T的数据进行分片，减少单个线程的IO次数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626136143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99984,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1559378476,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5854345772","product_id":100017301,"comment_content":"利用两个队列A和B，多线程并行处理A队列中的顶点（入度为0），并将入度为0的扩展顶点（扩展顶点的入度减1）入队B，A队列中顶点都处理完，队列A清空，再并行处理B队列中顶点，并将入度为0的扩展顶点（扩展顶点的入度减1）入队A，如此两个队列循环使用","like_count":1},{"had_liked":false,"id":63220,"user_name":"牧民牛仔","can_delete":false,"product_type":"c1","uid":1247561,"ip_address":"","ucode":"1CC29B7129B207","user_header":"https://static001.geekbang.org/account/avatar/00/13/09/49/8bc5e315.jpg","comment_is_top":false,"comment_ctime":1548301075,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5843268371","product_id":100017301,"comment_content":"既然有依赖关系，我条件反射想到拓扑排序算法，根据依赖关系把任务分组，各组任务按照依赖关系排序。没有依赖关系的任务组可以并行执行，有依赖关系的任务组内则按依赖关系有序的执行。","like_count":1},{"had_liked":false,"id":62952,"user_name":"子嘉","can_delete":false,"product_type":"c1","uid":1252422,"ip_address":"","ucode":"CF0DC72E2B6B9C","user_header":"https://static001.geekbang.org/account/avatar/00/13/1c/46/a141c7e6.jpg","comment_is_top":false,"comment_ctime":1548212590,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5843179886","product_id":100017301,"comment_content":"思考题是：拓扑排序么。。","like_count":1},{"had_liked":false,"id":62868,"user_name":"feifei","can_delete":false,"product_type":"c1","uid":1105431,"ip_address":"","ucode":"B1F8AE3AD82C51","user_header":"https://static001.geekbang.org/account/avatar/00/10/de/17/75e2b624.jpg","comment_is_top":false,"comment_ctime":1548198228,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5843165524","product_id":100017301,"comment_content":"我想到了图，讲依赖关系抽象成边，使用图排序就可以找出依赖关系，然后将每一层的任务放入线程池执行，当一层完成后，继续下一层处理","like_count":1},{"had_liked":false,"id":355783,"user_name":"Geek_8e9c8d","can_delete":false,"product_type":"c1","uid":3073804,"ip_address":"广东","ucode":"40B28FBAE8EDD0","user_header":"","comment_is_top":false,"comment_ctime":1661745747,"is_pvip":false,"discussion_count":0,"race_medal":2,"score":"1661745747","product_id":100017301,"comment_content":"我觉得不一定需要两个队列吧 直接统计每次的size不就好了<br>","like_count":0},{"had_liked":false,"id":351561,"user_name":"H.H","can_delete":false,"product_type":"c1","uid":2668479,"ip_address":"","ucode":"3C0BB1E2A3EC51","user_header":"https://static001.geekbang.org/account/avatar/00/28/b7/bf/815f0ec6.jpg","comment_is_top":false,"comment_ctime":1657904055,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1657904055","product_id":100017301,"comment_content":"思考题就想到了C++的源文件编译，先找出没依赖关系，再找出下一级仅依赖这些没依赖的，同级之间就可以并行了。看到评论，才发现，原来是拓扑呀....","like_count":0},{"had_liked":false,"id":345931,"user_name":"苏成","can_delete":false,"product_type":"c1","uid":2668694,"ip_address":"","ucode":"80A8E7B243DD73","user_header":"https://static001.geekbang.org/account/avatar/00/28/b8/96/716ba431.jpg","comment_is_top":false,"comment_ctime":1652700145,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1652700145","product_id":100017301,"comment_content":"说一下自己的看法：<br>并行本质上是分治，将我们的问题分成几个小块，然后多线程执行，最后将结果合并<br>思考题：<br>我们在拓扑排序Kanh算法之时（其实这个就是BFS）也使用两个队列方法和本节课之中BFS并行搜索一致。A存储当前层的节点，多线程遍历结果存放在B之中，然后遍历B存放在A，循环使用两个队列","like_count":0},{"had_liked":false,"id":331130,"user_name":"有头脑的饕餮","can_delete":false,"product_type":"c1","uid":1757961,"ip_address":"","ucode":"B31B79CCB7BFA4","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d3/09/d6e7fc83.jpg","comment_is_top":false,"comment_ctime":1642436412,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642436412","product_id":100017301,"comment_content":"有关并行计算的入门书籍推荐吗？","like_count":0},{"had_liked":false,"id":313031,"user_name":"吴钩","can_delete":false,"product_type":"c1","uid":2062402,"ip_address":"","ucode":"0EB50E8144BCDE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKOnpl8fRB9r2vED2s8j7Arwbn2K6M6HUBWNjgoqV4uqe94fTGK4WGpOJLeRxXcBXk3dp23eQR0AQ/132","comment_is_top":false,"comment_ctime":1632218257,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632218257","product_id":100017301,"comment_content":"广度优先并行的理解：之所以用两个队列，是因为多线程下先扩展的节点可能后返回，导致按层遍历出现错误。而两个队列轮流扩展相当于按层做了同步，必须处理完一层才能处理下一层。","like_count":0},{"had_liked":false,"id":294075,"user_name":"豆瓣酱","can_delete":false,"product_type":"c1","uid":2625639,"ip_address":"","ucode":"AF7525F7FE83E8","user_header":"https://static001.geekbang.org/account/avatar/00/28/10/67/49dfb810.jpg","comment_is_top":false,"comment_ctime":1621749928,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621749928","product_id":100017301,"comment_content":"并行算法需要设计复杂的调度系统","like_count":0},{"had_liked":false,"id":281119,"user_name":"罗耀龙@坐忘","can_delete":false,"product_type":"c1","uid":1917663,"ip_address":"","ucode":"3CEA258DE7F3C7","user_header":"https://static001.geekbang.org/account/avatar/00/1d/42/df/a034455d.jpg","comment_is_top":false,"comment_ctime":1614587715,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1614587715","product_id":100017301,"comment_content":"茶艺师学编程<br><br>思考题<br>········在并行之前再套用拓扑结构吗？","like_count":0},{"had_liked":false,"id":261931,"user_name":"youyou.L","can_delete":false,"product_type":"c1","uid":1796438,"ip_address":"","ucode":"B3DB0D0700EEAC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/zlWt0lPDicdib5BTUbuwA3wLLUuejtZ5icGu3DHMBPd6PicXOdhZ3zYFts8VkXjjyQuxzUJas2w5OTmx3icWKiaZM1Vg/132","comment_is_top":false,"comment_ctime":1605582134,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605582134","product_id":100017301,"comment_content":"思考题：拓扑排序+多个队列并行执行<br>任务作为顶点，任务之间的依赖作为边构建有向图。把图中入度为0的顶点分配到多个队列当中，多线程并行执行一以下操作：从队列中获取顶点，把连接该顶点的边都删除，若与之连接的顶点入度为0，加入到对应的队列当中，重复此过程直到队列为空。","like_count":0},{"had_liked":false,"id":257041,"user_name":"王世林","can_delete":false,"product_type":"c1","uid":1076155,"ip_address":"","ucode":"2BB56D0FD71417","user_header":"https://static001.geekbang.org/account/avatar/00/10/6b/bb/10aaf123.jpg","comment_is_top":false,"comment_ctime":1603842336,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603842336","product_id":100017301,"comment_content":"装载因子不是不变的吗，只是扩容以后不能利用的内存空间变大了","like_count":0},{"had_liked":false,"id":242624,"user_name":"prepared","can_delete":false,"product_type":"c1","uid":1194853,"ip_address":"","ucode":"00E54A5C7CDCBE","user_header":"https://static001.geekbang.org/account/avatar/00/12/3b/65/3a4fc8cf.jpg","comment_is_top":false,"comment_ctime":1597799116,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597799116","product_id":100017301,"comment_content":"有依赖关系，可以组成有向图，通过广度优先搜索，每层就是可以并行处理的任务","like_count":0},{"had_liked":false,"id":230244,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1593326628,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593326628","product_id":100017301,"comment_content":"       把任务之间的依赖关系用一张有向图表示出来，图中的顶点代表任务，任务之间的依赖关系用带箭头的线段表示，比如B任务依赖A任务，则顶点A指向顶点B。<br>       然后利用有向图的网络拓扑排序算法，依次找出入度为0的任务(即不依赖其他任务的节点)，在算法循环找出这样的节点过程中，为每个节点都标上序号，在同一步骤中找到的节点，其序号应该一致，<br>然后按照序号从小到大执行任务，序号相同的任务即为可并行执行的任务。","like_count":0},{"had_liked":false,"id":229958,"user_name":"拉普达","can_delete":false,"product_type":"c1","uid":1930686,"ip_address":"","ucode":"0E524C0D99B2A0","user_header":"https://static001.geekbang.org/account/avatar/00/1d/75/be/6f3ab95e.jpg","comment_is_top":false,"comment_ctime":1593227049,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593227049","product_id":100017301,"comment_content":"根据执行依赖关系，利用拓扑排序构建特殊有向图，图中顶点间可以有多条边。而后，对两个顶点间的边进行并行计算。","like_count":0},{"had_liked":false,"id":229587,"user_name":"豆豆","can_delete":false,"product_type":"c1","uid":1275407,"ip_address":"","ucode":"97788B134C3212","user_header":"https://static001.geekbang.org/account/avatar/00/13/76/0f/c7c8021d.jpg","comment_is_top":false,"comment_ctime":1593067012,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593067012","product_id":100017301,"comment_content":"并行任务之间的依赖关系怎么存储啊？我上次工程中的解决方案使用闭包表。","like_count":0},{"had_liked":false,"id":220099,"user_name":"默默","can_delete":false,"product_type":"c1","uid":1006635,"ip_address":"","ucode":"AF798B9D327F24","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/2b/8b771383.jpg","comment_is_top":false,"comment_ctime":1590156280,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590156280","product_id":100017301,"comment_content":"将任务拓扑排序，每次选择入度为0的任务并行处理。","like_count":0},{"had_liked":false,"id":217635,"user_name":"鱼丸粗面","can_delete":false,"product_type":"c1","uid":1785016,"ip_address":"","ucode":"B2F3F75B0D1422","user_header":"https://static001.geekbang.org/account/avatar/00/1b/3c/b8/9489387c.jpg","comment_is_top":false,"comment_ctime":1589553344,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589553344","product_id":100017301,"comment_content":"同过广度优先搜索算法，先计算没有依赖的节点，一层一层计算有依赖的节点，在同一层中是灭有相互依赖关系的，可以使用并行的方式","like_count":0},{"had_liked":false,"id":195742,"user_name":"thinker","can_delete":false,"product_type":"c1","uid":1107762,"ip_address":"","ucode":"1D9ECA03A28931","user_header":"https://static001.geekbang.org/account/avatar/00/10/e7/32/82939538.jpg","comment_is_top":false,"comment_ctime":1585214605,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585214605","product_id":100017301,"comment_content":"分布式系统的核心就是分分合合，通过把大任务拆分成小任务，并行执行，最终达到解决问题的最快速度。","like_count":0},{"had_liked":false,"id":190570,"user_name":"高学义","can_delete":false,"product_type":"c1","uid":1321934,"ip_address":"","ucode":"4B1AA896B567B2","user_header":"https://static001.geekbang.org/account/avatar/00/14/2b/ce/15a82b5c.jpg","comment_is_top":false,"comment_ctime":1584669363,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584669363","product_id":100017301,"comment_content":"课后思考：先利用拓扑排序找到各个任务之间的依赖关系，然后对拓扑关系中处于同一层级的任务采用并行处理。","like_count":0},{"had_liked":false,"id":183316,"user_name":"无芽土豆","can_delete":false,"product_type":"c1","uid":1143835,"ip_address":"","ucode":"C72228B720D62C","user_header":"https://static001.geekbang.org/account/avatar/00/11/74/1b/85670a61.jpg","comment_is_top":false,"comment_ctime":1582993035,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582993035","product_id":100017301,"comment_content":"思考题思路：先应用有向图寻找依赖关系，再应并行化的广度优先搜索处理任务<br>先计算各个任务间的依赖关系，可以根据依赖关系构建有向图，若 A 依赖 B，则添加由 B 指向 A 的边，找到入度为 0 的任务，放入队列中，并行执行队列中的任务，每完成一个任务，删除该任务顶点及指出的边，当队列中的任务都执行完，再继续找入度为 0 的任务重复上述步骤，直至任务全部执行完成。","like_count":0},{"had_liked":false,"id":181960,"user_name":"发霉的宅大人","can_delete":false,"product_type":"c1","uid":1738243,"ip_address":"","ucode":"6757E30FE5E48D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/03/95004954.jpg","comment_is_top":false,"comment_ctime":1582684729,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582684729","product_id":100017301,"comment_content":"个人总结：<br>并行算法就是把数据分成多块并行处理，同时注意分割处可能出现的遗漏情况。<br>思考题个人理解：<br>n个任务我们就开n个线程，然后用有权有向图那一节讲到的邻接表处理这些线程索引。<br>我们用两个邻接表<br>用一个变量depend动态的表示他们的依赖个数，再用一个OriginalDe表示本来的依赖个数，每依赖一个depend+1，,我们首先找到depend为0的线程索引开始执行任务，执行完后放到另一个邻接表，OriginalDe赋值给depend（依赖数回复），如果当前的邻接表所有线程索引执行完了。就执行另一个邻接表。","like_count":0},{"had_liked":false,"id":173049,"user_name":"Kevin⚡️Zhou","can_delete":false,"product_type":"c1","uid":1440772,"ip_address":"","ucode":"C0FC2673705212","user_header":"https://static001.geekbang.org/account/avatar/00/15/fc/04/d83a555e.jpg","comment_is_top":false,"comment_ctime":1579417485,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579417485","product_id":100017301,"comment_content":"广度优先搜索那段, 如果采用并行搜索, 难道不需要考虑线程之间的race condition么?","like_count":0},{"had_liked":false,"id":152627,"user_name":"Sid","can_delete":false,"product_type":"c1","uid":1115041,"ip_address":"","ucode":"0461B574B2736B","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/a1/e6a0f60b.jpg","comment_is_top":false,"comment_ctime":1574053199,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574053199","product_id":100017301,"comment_content":"并行搜索，广度优先遍历，A中每个顶点的处理是并行的，但为了保证扩展出的节点之间的顺序与A队列节点之间的顺序一致，扩展出的顶点“放入”到B队列这个步骤还是要串行的吧。","like_count":0},{"had_liked":false,"id":144563,"user_name":"ruleGreen","can_delete":false,"product_type":"c1","uid":1314537,"ip_address":"","ucode":"FA4D36B97212A1","user_header":"https://static001.geekbang.org/account/avatar/00/14/0e/e9/929c5c73.jpg","comment_is_top":false,"comment_ctime":1571969305,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571969305","product_id":100017301,"comment_content":"广度优先搜索里面<br><br>假设这两个队列分别是队列 A 和队列 B。多线程并行处理队列...<br><br>这样先清空A，再清空B的做法，与原来只使用一个队列的方式没有太大的效率提升吧？无法做到在拓展A的时候同时拓展B啊？？？？<br>","like_count":0},{"had_liked":false,"id":135383,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1569142788,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569142788","product_id":100017301,"comment_content":"拓扑排序","like_count":0},{"had_liked":false,"id":134287,"user_name":"李冲","can_delete":false,"product_type":"c1","uid":1254530,"ip_address":"","ucode":"C8C12308B0FDDA","user_header":"https://static001.geekbang.org/account/avatar/00/13/24/82/b5808a60.jpg","comment_is_top":false,"comment_ctime":1568794516,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568794516","product_id":100017301,"comment_content":"虽然思考题与前面的编译依赖相似，但在本课程的语境下也许不仅仅只是找出哪些任务可以并行。如果任务是耗时的（相对普通指令周期而言），那思路可能不一样。<br><br>就拿高赞留言来讲，当某一代（就是指入度为0的判定后的任务集合）的任务数量比较少或者耗时离散度高的时候，线程池利用率就可能低了。因为下一代任务的启动必须等待这一代任务全部结束。如有理解题目有误，还请指正。<br>","like_count":0},{"had_liked":false,"id":133859,"user_name":"走马","can_delete":false,"product_type":"c1","uid":1251016,"ip_address":"","ucode":"EEFE8F7590FFA4","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/c8/980776fc.jpg","comment_is_top":false,"comment_ctime":1568685017,"is_pvip":false,"replies":[{"id":"51413","content":"😄 不懂spark","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1568759891,"ip_address":"","comment_id":133859,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568685017","product_id":100017301,"comment_content":"是不是就类似于spark中rdd 的宽窄依赖了","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467536,"discussion_content":"😄 不懂spark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568759891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93279,"user_name":"朱东旭","can_delete":false,"product_type":"c1","uid":1242338,"ip_address":"","ucode":"C48DD620A63868","user_header":"https://static001.geekbang.org/account/avatar/00/12/f4/e2/dbc4a5f2.jpg","comment_is_top":false,"comment_ctime":1557449652,"is_pvip":false,"replies":[{"id":"33708","content":"是并行处理完队列a，然后并行处理队列b这个样子的。并不是a、b的处理是并行的。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1557792401,"ip_address":"","comment_id":93279,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557449652","product_id":100017301,"comment_content":"老师，并行搜索在你的描述中是先操作队列A,再操作队列B,这是有先后顺序，这意味着是串行的不是并行呀。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449559,"discussion_content":"是并行处理完队列a，然后并行处理队列b这个样子的。并不是a、b的处理是并行的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557792401,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":68913,"user_name":"yaya","can_delete":false,"product_type":"c1","uid":1233856,"ip_address":"","ucode":"8C7FAC8F828BA4","user_header":"https://static001.geekbang.org/account/avatar/00/12/d3/c0/d38daa2d.jpg","comment_is_top":false,"comment_ctime":1550627907,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550627907","product_id":100017301,"comment_content":"将各任务通过依赖关系做成图，然后进行并行计算","like_count":0},{"had_liked":false,"id":63842,"user_name":"睡痴儿😑","can_delete":false,"product_type":"c1","uid":1187204,"ip_address":"","ucode":"750EF858EF2042","user_header":"https://static001.geekbang.org/account/avatar/00/12/1d/84/d0ec0064.jpg","comment_is_top":false,"comment_ctime":1548553354,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548553354","product_id":100017301,"comment_content":"使用的是拓扑排序，刚开始还以为太简单。不可能是这样","like_count":0},{"had_liked":false,"id":63542,"user_name":"才才","can_delete":false,"product_type":"c1","uid":1242373,"ip_address":"","ucode":"94D76106261987","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/05/d6547381.jpg","comment_is_top":false,"comment_ctime":1548397268,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548397268","product_id":100017301,"comment_content":"打卡，继续学习。","like_count":0},{"had_liked":false,"id":63341,"user_name":"小苏饼","can_delete":false,"product_type":"c1","uid":1247539,"ip_address":"","ucode":"80868F7477E2BB","user_header":"https://static001.geekbang.org/account/avatar/00/13/09/33/57757a23.jpg","comment_is_top":false,"comment_ctime":1548328727,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548328727","product_id":100017301,"comment_content":"spark，oozie的有向无环图","like_count":0},{"had_liked":false,"id":62983,"user_name":"少盐","can_delete":false,"product_type":"c1","uid":1305743,"ip_address":"","ucode":"BCC7E264B75702","user_header":"https://static001.geekbang.org/account/avatar/00/13/ec/8f/8299495a.jpg","comment_is_top":false,"comment_ctime":1548219908,"is_pvip":false,"replies":[{"id":"22479","content":"即便是n核也不一定提高n倍，毕竟还共享内存呢：）<br><br>我这里本就是粗略的表示:)","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1548405242,"ip_address":"","comment_id":62983,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1548219908","product_id":100017301,"comment_content":"计算机不一定都是n核的，怎么实现性能提升n倍呢","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437427,"discussion_content":"即便是n核也不一定提高n倍，毕竟还共享内存呢：）\n\n我这里本就是粗略的表示:)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548405242,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":62880,"user_name":"纯洁的憎恶","can_delete":false,"product_type":"c1","uid":1130512,"ip_address":"","ucode":"5E9757DE6F45DF","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/10/b6bf3c3c.jpg","comment_is_top":false,"comment_ctime":1548201743,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1548201743","product_id":100017301,"comment_content":"用Dag图","like_count":0},{"had_liked":false,"id":62867,"user_name":"farFlight","can_delete":false,"product_type":"c1","uid":1245211,"ip_address":"","ucode":"B0872D3ECBEC38","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83epbRibsic15KXfGEN3SSjnLhXGyhK2Uyrj5ibBJsKAjicNqtafDaQOLH4xpSJRZD1vmibFPJER1ySmwP9A/132","comment_is_top":false,"comment_ctime":1548197294,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548197294","product_id":100017301,"comment_content":"各个任务之间有依赖关系的话可以按照前面讲的拓扑排序来决定任务的执行顺序吧","like_count":0},{"had_liked":false,"id":62866,"user_name":"虫儿飞","can_delete":false,"product_type":"c1","uid":1251082,"ip_address":"","ucode":"628E330821B1D4","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/0a/e8868314.jpg","comment_is_top":false,"comment_ctime":1548195885,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548195885","product_id":100017301,"comment_content":"回答问题：我认为可以考虑按依赖关系分组，组外并行，组内串行。但若是生产者消费者模型，组内都可以并行计算。老师您觉得呢？","like_count":0}]}