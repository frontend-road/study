{"id":104094,"title":"18 | 如何设置线程池大小？","content":"<p>你好，我是刘超。</p><p>还记得我在16讲中说过“线程池的线程数量设置过多会导致线程竞争激烈”吗？今天再补一句，如果线程数量设置过少的话，还会导致系统无法充分利用计算机资源。那么如何设置才不会影响系统性能呢？</p><p>其实线程池的设置是有方法的，不是凭借简单的估算来决定的。<span class=\"orange\">今天我们就来看看究竟有哪些计算方法可以复用，</span>线程池中各个参数之间又存在怎样的关系。</p><h2>线程池原理</h2><p>开始优化之前，我们先来看看线程池的实现原理，有助于你更好地理解后面的内容。</p><p>在HotSpot VM的线程模型中，Java线程被一对一映射为内核线程。Java在使用线程执行程序时，需要创建一个内核线程；当该Java线程被终止时，这个内核线程也会被回收。因此Java线程的创建与销毁将会消耗一定的计算机资源，从而增加系统的性能开销。</p><p>除此之外，大量创建线程同样会给系统带来性能问题，因为内存和CPU资源都将被线程抢占，如果处理不当，就会发生内存溢出、CPU使用率超负荷等问题。</p><p>为了解决上述两类问题，Java提供了线程池概念，对于频繁创建线程的业务场景，线程池可以创建固定的线程数量，并且在操作系统底层，轻量级进程将会把这些线程映射到内核。</p><p><span class=\"orange\">线程池可以提高线程复用，又可以固定最大线程使用量，防止无限制地创建线程。</span>当程序提交一个任务需要一个线程时，会去线程池中查找是否有空闲的线程，若有，则直接使用线程池中的线程工作，若没有，会去判断当前已创建的线程数量是否超过最大线程数量，如未超过，则创建新线程，如已超过，则进行排队等待或者直接抛出异常。</p><!-- [[[read_end]]] --><h2>线程池框架Executor</h2><p>Java最开始提供了ThreadPool实现了线程池，为了更好地实现用户级的线程调度，更有效地帮助开发人员进行多线程开发，Java提供了一套Executor框架。</p><p>这个框架中包括了ScheduledThreadPoolExecutor和ThreadPoolExecutor两个核心线程池。前者是用来定时执行任务，后者是用来执行被提交的任务。鉴于这两个线程池的核心原理是一样的，下面我们就重点看看ThreadPoolExecutor类是如何实现线程池的。</p><p>Executors实现了以下四种类型的ThreadPoolExecutor：</p><p><img src=\"https://static001.geekbang.org/resource/image/8d/69/8d3c1654add00cb63645f1332e4eb669.jpg?wh=1240*486\" alt=\"\"></p><p>Executors利用工厂模式实现的四种线程池，我们在使用的时候需要结合生产环境下的实际场景。不过我不太推荐使用它们，因为选择使用Executors提供的工厂类，将会忽略很多线程池的参数设置，工厂类一旦选择设置默认参数，就很容易导致无法调优参数设置，从而产生性能问题或者资源浪费。</p><p>这里<span class=\"orange\">我建议你使用ThreadPoolExecutor自我定制一套线程池</span>。进入四种工厂类后，我们可以发现除了newScheduledThreadPool类，其它类均使用了ThreadPoolExecutor类进行实现，你可以通过以下代码简单看下该方法：</p><pre><code>    public ThreadPoolExecutor(int corePoolSize,//线程池的核心线程数量\n                              int maximumPoolSize,//线程池的最大线程数\n                              long keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间\n                              TimeUnit unit,//时间单位\n                              BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列\n                              ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可\n                              RejectedExecutionHandler handler) //拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务\n</code></pre><p>我们还可以通过下面这张图来了解下线程池中各个参数的相互关系：</p><p><img src=\"https://static001.geekbang.org/resource/image/66/e6/667149d07c494c29a23c1c08b9c0dbe6.jpg?wh=1666*1042\" alt=\"\"></p><p>通过上图，我们发现线程池有两个线程数的设置，一个为核心线程数，一个为最大线程数。在创建完线程池之后，默认情况下，线程池中并没有任何线程，等到有任务来才创建线程去执行任务。</p><p>但有一种情况排除在外，就是调用prestartAllCoreThreads()或者prestartCoreThread()方法的话，可以提前创建等于核心线程数的线程数量，这种方式被称为预热，在抢购系统中就经常被用到。</p><p>当创建的线程数等于 corePoolSize 时，提交的任务会被加入到设置的阻塞队列中。当队列满了，会创建线程执行任务，直到线程池中的数量等于maximumPoolSize。</p><p>当线程数量已经等于maximumPoolSize时， 新提交的任务无法加入到等待队列，也无法创建非核心线程直接执行，我们又没有为线程池设置拒绝策略，这时线程池就会抛出RejectedExecutionException异常，即线程池拒绝接受这个任务。</p><p>当线程池中创建的线程数量超过设置的corePoolSize，在某些线程处理完任务后，如果等待keepAliveTime时间后仍然没有新的任务分配给它，那么这个线程将会被回收。线程池回收线程时，会对所谓的“核心线程”和“非核心线程”一视同仁，直到线程池中线程的数量等于设置的corePoolSize参数，回收过程才会停止。</p><p>即使是corePoolSize线程，在一些非核心业务的线程池中，如果长时间地占用线程数量，也可能会影响到核心业务的线程池，这个时候就需要把没有分配任务的线程回收掉。</p><p>我们可以通过allowCoreThreadTimeOut设置项要求线程池：将包括“核心线程”在内的，没有任务分配的所有线程，在等待keepAliveTime时间后全部回收掉。</p><p>我们可以通过下面这张图来了解下线程池的线程分配流程：</p><p><img src=\"https://static001.geekbang.org/resource/image/b1/b0/b13aa36ef3b15a98fab1755ac36101b0.jpg?wh=746*950\" alt=\"\"></p><h2>计算线程数量</h2><p>了解完线程池的实现原理和框架，我们就可以动手实践优化线程池的设置了。</p><p>我们知道，环境具有多变性，设置一个绝对精准的线程数其实是不\b大可能的，但我们可以通过一些实际操作因素来计算出一个合理的线程数，避免由于线程池设置不合理而导致的性能问题。下面我们就来看看具体的计算方法。</p><p>一般多线程执行的任务类型可以分为CPU密集型和I/O密集型，根据不同的任务类型，我们计算线程数的方法也不一样。</p><p><strong>CPU密集型任务：</strong>这种任务消耗的主要是CPU资源，可以将线程数设置为N（CPU核心数）+1，比CPU核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用CPU的空闲时间。</p><p>下面我们用一个例子来验证下这个方法的可行性，通过观察CPU密集型任务在不同线程数下的性能情况就可以得出结果，你可以点击<a href=\"https://github.com/nickliuchao/threadpollsizetest\">Github</a>下载到本地运行测试：</p><pre><code>public class CPUTypeTest implements Runnable {\n\n\t//整体执行时间，包括在队列中等待的时间\n\tList&lt;Long&gt; wholeTimeList;\n\t//真正执行时间\n\tList&lt;Long&gt; runTimeList;\n\t\n\tprivate long initStartTime = 0;\n\t\n\t/**\n\t * 构造函数\n\t * @param runTimeList\n\t * @param wholeTimeList\n\t */\n\tpublic CPUTypeTest(List&lt;Long&gt; runTimeList, List&lt;Long&gt; wholeTimeList) {\n\t\tinitStartTime = System.currentTimeMillis();\n\t\tthis.runTimeList = runTimeList;\n\t\tthis.wholeTimeList = wholeTimeList;\n\t}\n\t\n\t/**\n\t * 判断素数\n\t * @param number\n\t * @return\n\t */\n\tpublic boolean isPrime(final int number) {\n\t\tif (number &lt;= 1)\n\t\t\treturn false;\n\n\n\t\tfor (int i = 2; i &lt;= Math.sqrt(number); i++) {\n\t\t\tif (number % i == 0)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * 計算素数\n\t * @param number\n\t * @return\n\t */\n\tpublic int countPrimes(final int lower, final int upper) {\n\t\tint total = 0;\n\t\tfor (int i = lower; i &lt;= upper; i++) {\n\t\t\tif (isPrime(i))\n\t\t\t\ttotal++;\n\t\t}\n\t\treturn total;\n\t}\n\n\tpublic void run() {\n\t\tlong start = System.currentTimeMillis();\n\t\tcountPrimes(1, 1000000);\n\t\tlong end = System.currentTimeMillis();\n\n\n\t\tlong wholeTime = end - initStartTime;\n\t\tlong runTime = end - start;\n\t\twholeTimeList.add(wholeTime);\n\t\trunTimeList.add(runTime);\n\t\tSystem.out.println(&quot;单个线程花费时间：&quot; + (end - start));\n\t}\n}\n</code></pre><p>测试代码在4核 intel i5 CPU机器上的运行时间变化如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/c5/f9/c54224d1ed2d579a550650693c70e4f9.jpg?wh=1628*924\" alt=\"\"></p><p>综上可知：当线程数量太小，同一时间大量请求将被阻塞在线程队列中排队等待执行线程，此时CPU没有得到充分利用；当线程数量太大，被创建的执行线程同时在争取CPU资源，又会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。通过测试可知，4~6个线程数是最合适的。</p><p><strong>I/O密集型任务：</strong>这种任务应用起来，系统会用大部分的时间来处理I/O交互，而线程在处理I/O的时间段内不会占用CPU来处理，这时就可以将CPU交出给其它线程使用。因此在I/O密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是2N。</p><p>这里我们还是通过一个例子来验证下这个公式是否可以标准化：</p><pre><code>public class IOTypeTest implements Runnable {\n\n\t//整体执行时间，包括在队列中等待的时间\n\tVector&lt;Long&gt; wholeTimeList;\n\t//真正执行时间\n\tVector&lt;Long&gt; runTimeList;\n\t\n\tprivate long initStartTime = 0;\n\t\n\t/**\n\t * 构造函数\n\t * @param runTimeList\n\t * @param wholeTimeList\n\t */\n\tpublic IOTypeTest(Vector&lt;Long&gt; runTimeList, Vector&lt;Long&gt; wholeTimeList) {\n\t\tinitStartTime = System.currentTimeMillis();\n\t\tthis.runTimeList = runTimeList;\n\t\tthis.wholeTimeList = wholeTimeList;\n\t}\n\t\n\t/**\n\t *IO操作\n\t * @param number\n\t * @return\n\t * @throws IOException \n\t */\n\tpublic void readAndWrite() throws IOException {\n\t\tFile sourceFile = new File(&quot;D:/test.txt&quot;);\n        //创建输入流\n        BufferedReader input = new BufferedReader(new FileReader(sourceFile));\n        //读取源文件,写入到新的文件\n        String line = null;\n        while((line = input.readLine()) != null){\n            //System.out.println(line);\n        }\n        //关闭输入输出流\n        input.close();\n\t}\n\n\tpublic void run() {\n\t\tlong start = System.currentTimeMillis();\n\t\ttry {\n\t\t\treadAndWrite();\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t\tlong end = System.currentTimeMillis();\n\n\n\t\tlong wholeTime = end - initStartTime;\n\t\tlong runTime = end - start;\n\t\twholeTimeList.add(wholeTime);\n\t\trunTimeList.add(runTime);\n\t\tSystem.out.println(&quot;单个线程花费时间：&quot; + (end - start));\n\t}\n}\n</code></pre><p>备注：由于测试代码读取2MB大小的文件，涉及到大内存，所以在运行之前，我们需要调整JVM的堆内存空间：-Xms4g -Xmx4g，避免发生频繁的FullGC，影响测试结果。</p><p><img src=\"https://static001.geekbang.org/resource/image/0b/88/0bb0fe79bc9fc3c386815e3d0bfcf088.jpg?wh=1572*848\" alt=\"\"></p><p>通过测试结果，我们可以看到每个线程所花费的时间。当线程数量在8时，线程平均执行时间是最佳的，这个线程数量和我们的计算公式所得的结果就差不多。</p><p>看完以上两种情况下的线程计算方法，你可能还想说，在平常的应用场景中，我们常常遇不到这两种极端情况，<strong>那么碰上一些常规的业务操作，比如，通过一个线程池实现向用户定时推送消息的业务，我们又该如何设置线程池的数量呢？</strong></p><p>此时我们可以参考以下公式来计算线程数：</p><pre><code>线程数=N（CPU核数）*（1+WT（线程等待时间）/ST（线程时间运行时间））\n</code></pre><p>我们可以通过JDK自带的工具VisualVM来查看WT/ST比例，以下例子是基于运行纯CPU运算的例子，我们可以看到：</p><pre><code>WT（线程等待时间）= 36788ms [线程运行总时间] - 36788ms[ST（线程时间运行时间）]= 0\n线程数=N（CPU核数）*（1+ 0 [WT（线程等待时间）]/36788ms[ST（线程时间运行时间）]）= N（CPU核数）\n</code></pre><p>这跟我们之前通过CPU密集型的计算公式N+1所得出的结果差不多。</p><p><img src=\"https://static001.geekbang.org/resource/image/32/65/3214039ef8f15076084a363a9f0b0b65.jpg?wh=2372*1254\" alt=\"\"></p><p>综合来看，我们可以根据自己的业务场景，从“N+1”和“2N”两个公式中选出一个适合的，计算出一个大概的线程数量，之后通过实际压测，逐渐往“增大线程数量”和“减小线程数量”这两个方向调整，然后观察整体的处理时间变化，最终确定一个具体的线程数量。</p><h2>总结</h2><p>今天我们主要学习了线程池的实现原理，Java线程的创建和消耗会给系统带来性能开销，因此Java提供了线程池来复用线程，提高程序的并发效率。</p><p>Java通过用户线程与内核线程结合的1:1线程模型来实现，Java将线程的调度和管理设置在了用户态，提供了一套Executor框架来帮助开发人员提高效率。Executor框架不仅包括了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，可以说Executor框架为并发编程提供了一个完善的架构体系。</p><p>在不同的业务场景以及不同配置的部署机器中，线程池的线程数量设置是不一样的。其设置不宜过大，也不宜过小，<span class=\"orange\">要根据具体情况，计算出一个大概的数值，再通过实际的性能测试，计算出一个合理的线程数量。</span></p><p>我们要提高线程池的处理能力，一定要先保证一个合理的线程数量，也就是保证CPU处理线程的最大化。在此前提下，我们再增大线程池队列，通过队列将来不及处理的线程缓存起来。在设置缓存队列时，我们要尽量使用一个有界队列，以防因队列过大而导致的内存溢出问题。</p><h2>思考题</h2><p>在程序中，除了并行段代码，还有串行段代码。那么当程序同时存在串行和并行操作时，优化并行操作是不是优化系统的关键呢？</p><p>期待在留言区看到你的见解。也欢迎你点击“请朋友读”，把今天的内容分享给身边的朋友，邀请他一起讨论。</p><p></p>","neighbors":{"left":{"article_title":"17 | 并发容器的使用：识别不同场景下最优容器","id":103541},"right":{"article_title":"19 | 如何用协程来优化多线程业务？","id":104521}},"comments":[{"had_liked":false,"id":108724,"user_name":"你好旅行者","can_delete":false,"product_type":"c1","uid":1154101,"ip_address":"","ucode":"5C72A428DC28F3","user_header":"https://static001.geekbang.org/account/avatar/00/11/9c/35/9dc79371.jpg","comment_is_top":false,"comment_ctime":1561865528,"is_pvip":false,"replies":[{"id":"39612","content":"对的，如果队列满了，就会新增线程来执行任务，如果已经是最大线程数量，则会执行拒绝策略。<br><br>这里不应该说不合理，而是不公平。可以深入源码查看具体的实现。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562032677,"ip_address":"","comment_id":108724,"utype":1}],"discussion_count":8,"race_medal":0,"score":"139000819000","product_id":100028001,"comment_content":"老师好！关于线程池我有一个问题一直不明白，在线程池达到了核心线程数，等待队列没满的这段时间，新的任务会被加入到等待队列。而当等待队列满了之后，最大线程数没满的这段时间，线程池会为新的任务直接创建线程。那岂不是说，我后来的任务反而比先到的任务更早被分配到线程的资源？这是不是有点不太合理呢？","like_count":33,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456090,"discussion_content":"对的，如果队列满了，就会新增线程来执行任务，如果已经是最大线程数量，则会执行拒绝策略。\n\n这里不应该说不合理，而是不公平。可以深入源码查看具体的实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562032677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2722962,"avatar":"","nickname":"曾文峰","note":"","ucode":"FCA525F93CE115","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413266,"discussion_content":"是不公平，这样做的好处是进入来的任务可以马上被新建的线程所执行，而不是先把新任务阻塞唤醒旧任务执行，这就可以少了一些阻塞唤醒带来的损耗。这对于总体效率来说是有提升的。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1636427143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1096630,"avatar":"https://static001.geekbang.org/account/avatar/00/10/bb/b6/55f6beba.jpg","nickname":"zhongjinming","note":"","ucode":"068B0DB0A74D2C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3653,"discussion_content":"所以核心业务并且要顺序性要求的 必须核心线程数与最大线程数设置为一致的，对吗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1564661611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1254217,"avatar":"https://static001.geekbang.org/account/avatar/00/13/23/49/5a3f295a.jpg","nickname":"W","note":"","ucode":"CEBEB8042DE386","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1096630,"avatar":"https://static001.geekbang.org/account/avatar/00/10/bb/b6/55f6beba.jpg","nickname":"zhongjinming","note":"","ucode":"068B0DB0A74D2C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":201554,"discussion_content":"有顺序性要求的话，我觉得就不能用多线程并发执行，只能单线程顺序执行吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583807788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3653,"ip_address":""},"score":201554,"extra":""}]},{"author":{"id":1851970,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/42/42/2a04ada9.jpg","nickname":"毛小树","note":"","ucode":"E47DC07CE4959E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584819,"discussion_content":"就跟医院窗口类似，AB窗口排满了人，就开设C窗口，此时后来的任务可以比找到AB尾部的任务先执行。但人是活的，可以从AB尾部见机行事挪到C窗口。不知道线程队列里的任务有没有这么聪明？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661145544,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383864,"discussion_content":"实际上就是一种抢占式处理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626257363,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066678,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/b6/edfe7ce8.jpg","nickname":"夜里吃西瓜","note":"","ucode":"362817AF375E38","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365188,"discussion_content":"都是FIFO的队列，不会存在你说的情况","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617722174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1225224,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","nickname":"尔冬橙","note":"","ucode":"0B013A49BC18DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":18078,"discussion_content":"老哥厉害了，我竟然没发现这个问题。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569003236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108673,"user_name":"飞翔","can_delete":false,"product_type":"c1","uid":1068571,"ip_address":"","ucode":"65AF6AF292DAD6","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/1b/f4b786b9.jpg","comment_is_top":false,"comment_ctime":1561835287,"is_pvip":true,"replies":[{"id":"39371","content":"在一些非核心业务，我们可以将核心线程数设置小一些，最大线程数量设置为计算线程数量。在一些核心业务中，两者可以设置一样。阻塞队列可以根据具体业务场景设置，如果线程处理业务非常迅速，我们可以考虑将阻塞队列设置大一些，处理的请求吞吐量会大些；如果线程处理业务非常耗时，阻塞队列设置小些，防止请求在阻塞队列中等待过长时间而导致请求已超时。<br>","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561867667,"ip_address":"","comment_id":108673,"utype":1}],"discussion_count":1,"race_medal":0,"score":"65986344727","product_id":100028001,"comment_content":"话说N+1和2N 是指的核心线程数嘛？ 那队列和最大线程数怎么设置呀","like_count":15,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456075,"discussion_content":"在一些非核心业务，我们可以将核心线程数设置小一些，最大线程数量设置为计算线程数量。在一些核心业务中，两者可以设置一样。阻塞队列可以根据具体业务场景设置，如果线程处理业务非常迅速，我们可以考虑将阻塞队列设置大一些，处理的请求吞吐量会大些；如果线程处理业务非常耗时，阻塞队列设置小些，防止请求在阻塞队列中等待过长时间而导致请求已超时。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561867667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109392,"user_name":"明翼","can_delete":false,"product_type":"c1","uid":1068361,"ip_address":"","ucode":"E77F86BEB3D5C1","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/49/28e73b9c.jpg","comment_is_top":false,"comment_ctime":1562029411,"is_pvip":false,"replies":[{"id":"39628","content":"1、如果队列满了，这个现成的任务会创建非核心线程，也就是不会先运行队列中的任务。<br>2、新来的任务a会通过创建新的线程来运行，只要线程数量小于核心线程数，新来的任务都会通过创建新的线程来运行。直到等于核心线程数，任务将会放到阻塞队列中，通过循环拿到阻塞队列中的任务执行。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562037219,"ip_address":"","comment_id":109392,"utype":1}],"discussion_count":1,"race_medal":0,"score":"61691571555","product_id":100028001,"comment_content":"老师早点发这个课就好了，先回答问题：程序的总体时间是由所有部分加起来时间决定的，串行如果很慢就会严重影响性能，优化是从性能最差的地方开始的。<br><br>请教问题：<br>1）按照老师的图，如果线程没超过核心线程，就创建，超过则加入到队列，队列满又没达到最大线程则创建非核心线程，那么创建好的线程是直接执行最近来的任务那，还是从队列的头部取一个执行。<br>2）第二个问题，如果线程池的线程数的在核心线程数量之内，A线程执行刚执行完任务，这时候来了个新来的任务a，那么这个A线程继续执行这个新来任务a，还是其他线程执行这个线程那，这里面有什么分配策略","like_count":15,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456391,"discussion_content":"1、如果队列满了，这个现成的任务会创建非核心线程，也就是不会先运行队列中的任务。\n2、新来的任务a会通过创建新的线程来运行，只要线程数量小于核心线程数，新来的任务都会通过创建新的线程来运行。直到等于核心线程数，任务将会放到阻塞队列中，通过循环拿到阻塞队列中的任务执行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562037219,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162642,"user_name":"阿杜","can_delete":false,"product_type":"c1","uid":1066705,"ip_address":"","ucode":"349D3572F5ABE7","user_header":"https://static001.geekbang.org/account/avatar/00/10/46/d1/a1ddf49f.jpg","comment_is_top":false,"comment_ctime":1576571588,"is_pvip":false,"replies":[{"id":"61959","content":"赞，做性能压测的时候会经常遇到这种情况，当某条SQL比较耗时的时候，如果线程数设置过大，就会出现不能打开DB连接的异常。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1576667716,"ip_address":"","comment_id":162642,"utype":1}],"discussion_count":2,"race_medal":0,"score":"57411146436","product_id":100028001,"comment_content":"线程池核心线程数的设置多少不仅仅依赖cpu核数和执行时间，还有线程执行的资源，比如调用的db，db连接数有限，线程数太多就可能打满db连接。","like_count":14,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478116,"discussion_content":"赞，做性能压测的时候会经常遇到这种情况，当某条SQL比较耗时的时候，如果线程数设置过大，就会出现不能打开DB连接的异常。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576667716,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1257043,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2e/53/bf62683f.jpg","nickname":"狼的诱惑","note":"","ucode":"AE89DFC5963C42","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367998,"discussion_content":"您好：数据库连接最大设置1000，应用程序16实例，配置的核心线程数和最大都是24，压测逻辑只插入数据，没其他逻辑，tps=13000左右。机器是8核16g。\n问题：\n1.dba设置数据库1000，压测时数据库无压力，dba认为合适，太大没意义，是这样吗？\n2.应用数据库连接池分别配置过12，24 进行压测，都是核心等于最大线程，tps差不多，可还有提升空间？\n3. druid和hikraicp两者性能测了下也没什么区别\n\n请问以目前的现状可否还有提升空间，sql插入执行还算快，就是有时获取数据库连接会有超时情况，请问怎么优化？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618535989,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108431,"user_name":"nico","can_delete":false,"product_type":"c1","uid":1209075,"ip_address":"","ucode":"DDB5EFE9F3A70E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Pr8laRQY3skrzzgen37ZIt4HQvtaThAcqvyK8eAzc9DRiak803q5HS7gCnXFxpx6CWibqT1Sic0h1TLMmVNUpJRibA/132","comment_is_top":false,"comment_ctime":1561771552,"is_pvip":true,"replies":[{"id":"39358","content":"我们先考虑单个环境，再去调优复杂环境。大多情况下，重要的服务会单独部署，尽量减少重要业务的相互影响。如果是核心业务冗余在了一个服务上，建议拆分之后分别部署。<br><br>非核心业务，很多业务处理可能是在不同时间点，彼此相互不影响，所以不用过多考虑混合部署服务的情况。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561863558,"ip_address":"","comment_id":108431,"utype":1}],"discussion_count":1,"race_medal":0,"score":"44511444512","product_id":100028001,"comment_content":"老师，请教个问题，生产环境有些应用是混部的，即一个虚拟机上跑很多个java程序，这个时候估算一个程序中的线程池的线程数，是不是就不合理了？这个要怎么估算合理的线程池配置？还有就是即使是单实例部署，cpu资源是机器内共用的，不可能只分配给java线程，这个要怎么考虑？","like_count":11,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455972,"discussion_content":"我们先考虑单个环境，再去调优复杂环境。大多情况下，重要的服务会单独部署，尽量减少重要业务的相互影响。如果是核心业务冗余在了一个服务上，建议拆分之后分别部署。\n\n非核心业务，很多业务处理可能是在不同时间点，彼此相互不影响，所以不用过多考虑混合部署服务的情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561863558,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108990,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1561944629,"is_pvip":false,"replies":[{"id":"39618","content":"我们一般会调整tomcat的线程数量的，线上环境的tomcat线程数量我们一般是在16核CPU的环境下为20左右。如果有万级的并发过来，100以及1000的线程数量，可能会有问题。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562034412,"ip_address":"","comment_id":108990,"utype":1}],"discussion_count":4,"race_medal":0,"score":"35921682997","product_id":100028001,"comment_content":"1.能理解io操作不占用cpu计算，但是io线程依旧不会让渡cpu资源的（执行时间片）。所以io线程池独立和调整io线程数只是因为它耗时不确定，一般耗时较长的特性。<br>2.综上所述，那么线程池线程数基本就20-30的样子（而且这个值怎么感觉是多个线程池的线程总数呢）。那么tomcat线程池默认好像200条吧，dubbo线程池我们设置1000条线程，这是否就不合理了？（线程这块太水，麻烦老师解惑下）","like_count":8,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456195,"discussion_content":"我们一般会调整tomcat的线程数量的，线上环境的tomcat线程数量我们一般是在16核CPU的环境下为20左右。如果有万级的并发过来，100以及1000的线程数量，可能会有问题。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1562034412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1682027,"avatar":"https://static001.geekbang.org/account/avatar/00/19/aa/6b/ab9a072a.jpg","nickname":"对与错","note":"","ucode":"EF55733E3BD78B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338607,"discussion_content":"谁告诉你IO操作不让出CPU资源的？你把DMA控制器放在哪里了?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609322962,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1403980,"avatar":"https://static001.geekbang.org/account/avatar/00/15/6c/4c/be735cc5.jpg","nickname":"自己争取","note":"","ucode":"90821BF6E6B85E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":227116,"discussion_content":"tomcat 设置20. Dubbo 也设置20。但是因为在一个机器上。不应该是总线程20才是最优嘛\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586451220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1403980,"avatar":"https://static001.geekbang.org/account/avatar/00/15/6c/4c/be735cc5.jpg","nickname":"自己争取","note":"","ucode":"90821BF6E6B85E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":227119,"discussion_content":"不是的，经过自己压测。io操作不依赖cpu。所以io操作多线程是能提高效率的。我压一个常规耗时150ms的操作，并行线程数达到150，耗时都依旧稳定。并行任务到了200才出现明显的耗时拐点。而这个操作内部还有异步操作。所以常规应用总的并行任务数应该都能在200出头（毕竟大多远程接口调用，是io密集型）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586452165,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":227116,"ip_address":""},"score":227119,"extra":""}]}]},{"had_liked":false,"id":118050,"user_name":"K","can_delete":false,"product_type":"c1","uid":1118374,"ip_address":"","ucode":"69831D1EFC083C","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/a6/4d2c933e.jpg","comment_is_top":false,"comment_ctime":1564218652,"is_pvip":false,"replies":[{"id":"43412","content":"这里理解是有误差的，目前很多服务器的IO操作都是交给DMA去完成，所以这里是让出CPU资源的。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564368652,"ip_address":"","comment_id":118050,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31628989724","product_id":100028001,"comment_content":"老师好，我也是看了下边同学的评论，又学到了很多知识。我有一个地方不理解，线程如果读文件的时候，这个线程可能处于wait的状态，然后cpu就可以被其他线程拿到使用了。那为什么看到有同学说：“io操作不占用cpu计算，但是io线程依旧不会让渡cpu资源的（执行时间片）”。麻烦老师解答一下，谢谢老师。","like_count":8,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460239,"discussion_content":"这里理解是有误差的，目前很多服务器的IO操作都是交给DMA去完成，所以这里是让出CPU资源的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564368652,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108479,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1561780096,"is_pvip":false,"replies":[{"id":"39364","content":"赞，Amdahl&#39;s定律指出优化串行是优化系统性能的关键，我们应该从算法入手，减少程序中串行的部分，而不是增加线程数来提高系统的并发处理能力。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561865128,"ip_address":"","comment_id":108479,"utype":1}],"discussion_count":2,"race_medal":0,"score":"31626551168","product_id":100028001,"comment_content":"优化并行操作是不是优化系统的关键呢?<br>可以参考阿姆达尔定律<br>S=1&#47;(1-a+a&#47;n)<br>总之，优化并行操作带来的收益是有上限的。","like_count":7,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455997,"discussion_content":"赞，Amdahl&amp;#39;s定律指出优化串行是优化系统性能的关键，我们应该从算法入手，减少程序中串行的部分，而不是增加线程数来提高系统的并发处理能力。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561865128,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1438863,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f4/8f/6b3d4370.jpg","nickname":"瑶老板的小弟","note":"","ucode":"EA6CDB3165227F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308142,"discussion_content":"涨知识。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600852406,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139282,"user_name":"承香墨影","can_delete":false,"product_type":"c1","uid":1023750,"ip_address":"","ucode":"4D6A4D6E1ED29F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9f/06/287d77dd.jpg","comment_is_top":false,"comment_ctime":1570601815,"is_pvip":false,"replies":[{"id":"54275","content":"赞","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1570956266,"ip_address":"","comment_id":139282,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27340405591","product_id":100028001,"comment_content":"只有在 workQueue 满了之后才会创建新的线程，直到线程数到达 maximumPoolSize 值。所以这里的等待队列无法使用无界队列就会导致永远都用不上 maximumPoolSize。当我们自己指定 ThreadPoolExecutor 参数的时候，需要注意不要使用无界队列，或者使用无界队列让 corePoolSize 和 maximumPoolSize 保持一致也可以。<br>参考：newFixedThreadPool 的创建过程。","like_count":6,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469877,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570956266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108480,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1561781403,"is_pvip":false,"replies":[{"id":"39365","content":"适用的，多个进程大部分时间不一定是重合运行的。但具体情况需要具体定，所以最终还是以压测调出来的线程数为准。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561865300,"ip_address":"","comment_id":108480,"utype":1}],"discussion_count":2,"race_medal":0,"score":"27331585179","product_id":100028001,"comment_content":"老师，我想问下生产环境情况下很少碰到单个java进程在一台主机中运行，大部分肯定是多个进程同时运行，不如docker技术，都是共享同一套硬件，那这套计算方程式是不是不适用了？","like_count":6,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455998,"discussion_content":"适用的，多个进程大部分时间不一定是重合运行的。但具体情况需要具体定，所以最终还是以压测调出来的线程数为准。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561865300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008587,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/cb/7c004188.jpg","nickname":"和你一起搬砖的胡大爷","note":"","ucode":"54607F4E17917A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3093,"discussion_content":"产线上的容器往往需要靠cgroup分配cpu时间，比如k8s，产线上的应用必须要有资源保证","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564158813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108421,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1561768812,"is_pvip":false,"replies":[{"id":"39356","content":"分别创建。<br><br>如果过分彼此相互影响，建议拆开服务，分别部署。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561862969,"ip_address":"","comment_id":108421,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27331572588","product_id":100028001,"comment_content":"请教老师一个问题：<br><br>对于应用而言，可能有多种类型的任务要执行，我们是分别创建不同的线程池还是创建一个统一的线程池来控制资源的使用呢？<br><br>1 如果用一个统一的线程池，担心io任务占有太多线程导致其他任务没有足够的线程消费<br><br>2 如果用多个线程池，这个资源怎么管理，会不会导致整个应用的线程数量过多，引起太多上下文切换从而导致开销过大<br>","like_count":7,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455967,"discussion_content":"分别创建。\n\n如果过分彼此相互影响，建议拆开服务，分别部署。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561862969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":111968,"user_name":"再续啸傲","can_delete":false,"product_type":"c1","uid":1360184,"ip_address":"","ucode":"912987A17DCA92","user_header":"https://static001.geekbang.org/account/avatar/00/14/c1/38/e45bbb6b.jpg","comment_is_top":false,"comment_ctime":1562644226,"is_pvip":false,"replies":[{"id":"41141","content":"是的，根据当前机器的CPU数量和执行的具体业务来定，如果是纯CPU执行的任务，一般是跟CPU数量的核心线程数量会最大效率利用CPU，而如果是I&#47;O型业务，本身处理I&#47;O的时间是不占用CPU的，可以适当将核心线程数调大一些。如果核心线程数远远大于CPU的核数，整体执行时间也会增加。<br><br>Tomcat线程数需要根据自己的业务和机器的环境来定，正常业务一般比机器的CPU核数大一些即可。当万级并发请求时，如果是不保持长连接的情况下，可以适当调大acceptCount参数。当然，业务处理时间过长，在大并发量出现，由于tomcat无法及时处理，会导致504或其他错误。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562895167,"ip_address":"","comment_id":111968,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23037480706","product_id":100028001,"comment_content":"老师，我在本地测试的时候，随着核心线程数的增加，表现出线程平均执行时间增长很快，但是线程整体实行时间却一直在下降。这是否说明任务在等待队列的等待时间要远大于线程之间上下文切换所花费的时间？<br>如果要将tomcat线程数设置成两位数，是否对服务TPS有较大影响。当万级请求进来的时候正常请求被阻塞，导致前端页面显示请求超时？","like_count":5,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457523,"discussion_content":"是的，根据当前机器的CPU数量和执行的具体业务来定，如果是纯CPU执行的任务，一般是跟CPU数量的核心线程数量会最大效率利用CPU，而如果是I/O型业务，本身处理I/O的时间是不占用CPU的，可以适当将核心线程数调大一些。如果核心线程数远远大于CPU的核数，整体执行时间也会增加。\n\nTomcat线程数需要根据自己的业务和机器的环境来定，正常业务一般比机器的CPU核数大一些即可。当万级并发请求时，如果是不保持长连接的情况下，可以适当调大acceptCount参数。当然，业务处理时间过长，在大并发量出现，由于tomcat无法及时处理，会导致504或其他错误。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562895167,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186727,"user_name":"这就是编程","can_delete":false,"product_type":"c1","uid":1009348,"ip_address":"","ucode":"4091B3EB368E9F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/66/c4/e87a61ec.jpg","comment_is_top":false,"comment_ctime":1583912573,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18763781757","product_id":100028001,"comment_content":"看了，这个文章，发现用的阻塞队列，为什么要把任务加到队列后再去创建线程，为什么当没有达到最大线程可以直接创建。上网找了下，发现Tomcat中有一个StandardThreadExecutor线程池，该线程池execute执行策略是优先扩充线程到maximumPoolSize，再offer到queue，如果满了就reject。","like_count":5},{"had_liked":false,"id":128849,"user_name":"月迷津渡","can_delete":false,"product_type":"c1","uid":1264111,"ip_address":"","ucode":"2B18B2FE3DAC3B","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/ef/02401473.jpg","comment_is_top":false,"comment_ctime":1566974678,"is_pvip":false,"replies":[{"id":"48639","content":"按照源码来说，是先判断工作线程是否小于corePoolSize ，如果是，则直接获取线程执行代码，否则，是先进入阻塞队列中。<br><br>按照源码看，如果核心线程被占用了，队列中的请求会一直处于等待状态。<br><br>建议阅读源码和手动实践一下。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1567427967,"ip_address":"","comment_id":128849,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14451876566","product_id":100028001,"comment_content":"当创建的线程数等于 corePoolSize 时,提交的任务会被加入到设置的阻塞队列中,当队列满了，会创建线程执行任务，直到线程池中的数量等于 maximumPoolSize。<br>这句话颠覆我原来认知了。。难道不是要达到maxPoolSize再进队列么。。如果按上面这么说如果队列不满，就不会创建新线程执行它？就是我永远霸占了coreSize的线程处理，然后队列里有一个待处理，永远执行不了？求教","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465134,"discussion_content":"按照源码来说，是先判断工作线程是否小于corePoolSize ，如果是，则直接获取线程执行代码，否则，是先进入阻塞队列中。\n\n按照源码看，如果核心线程被占用了，队列中的请求会一直处于等待状态。\n\n建议阅读源码和手动实践一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567427967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1235750,"avatar":"https://static001.geekbang.org/account/avatar/00/12/db/26/3c8d68fb.jpg","nickname":"天使梦泪","note":"","ucode":"782991747DD424","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290134,"discussion_content":"我也想问源码为什么要这么设计，加一个队列是为了减轻线程池的压力吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594353275,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118554,"user_name":"Jerry","can_delete":false,"product_type":"c1","uid":1088756,"ip_address":"","ucode":"4213083D076AB8","user_header":"https://static001.geekbang.org/account/avatar/00/10/9c/f4/7e14ff8a.jpg","comment_is_top":false,"comment_ctime":1564387004,"is_pvip":false,"replies":[{"id":"44482","content":"处于等待状态的线程不会争夺CPU资源，但会占用其他系统资源。建议减少创建线程数量。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1565056295,"ip_address":"","comment_id":118554,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14449288892","product_id":100028001,"comment_content":"老师，请教一下，在我的业务环境下一个24 core的node上，一个java进程有一万多个线程，其中有220个是runnable的，其他要么处于BLOCKED 要么处于parking&#47;waiting状态，这种情况应该怎么优化？ 始终处于parking&#47;waiting状态的thread是不会参与调度的，不影响调度效率，这样理解对吗？<br><br>      3    java.lang.Thread.State: BLOCKED (on object monitor)<br>    220    java.lang.Thread.State: RUNNABLE<br>     45    java.lang.Thread.State: TIMED_WAITING (on object monitor)<br>   6412    java.lang.Thread.State: TIMED_WAITING (parking)<br>    200    java.lang.Thread.State: TIMED_WAITING (sleeping)<br>      4    java.lang.Thread.State: WAITING (on object monitor)<br>   5292    java.lang.Thread.State: WAITING (parking)","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460452,"discussion_content":"处于等待状态的线程不会争夺CPU资源，但会占用其他系统资源。建议减少创建线程数量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565056295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108543,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1561797424,"is_pvip":false,"replies":[{"id":"39369","content":"1、守护线程也是JVM创建的线程，这块我没有具体看到源码。我们一般不会使用守护线程处理业务，我们这里讨论的是处理业务的线程数量。<br>2、在一些非核心业务，我们可以将核心线程数设置小一些，最大线程数量设置为计算线程数量。在一些核心业务中，两者可以设置一样。阻塞队列可以根据具体业务场景设置，如果线程处理业务非常迅速，我们可以考虑将阻塞队列设置大一些，处理的请求吞吐量会大些；如果线程处理业务非常耗时，阻塞队列设置小些，防止请求在阻塞队列中等待过长时间而导致请求已超时。<br><br>3、休眠对应的sleep操作，等待对应的wait，驻留对应的线程池里的空闲线程，监视对应的synchronized阻塞","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561867598,"ip_address":"","comment_id":108543,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14446699312","product_id":100028001,"comment_content":"有三个问题请教一下老师:<br>1. 守护线程也会映射到CPU的线程吗, 我还是没太理解在计算线程数量的时候为啥不考虑守护线程呢, 是因为守护线程运行状态是要么一直运行, 要么一直等待这样不会变化的情况所以不考虑吗? 为啥守护线程的状态一直不变化呢, 它们不会出让CPU吗?<br>2. 文章中讲的主要是核心线程的数量如何配置, 最大线程数量和阻塞队列长度应该如何确定, 是随便配一下就行影响不大吗, 还是也有什么指导原则?<br>3. 想问一下老师在visualVM中的线程查看的视窗中线程状态等待, 休眠, 驻留, 监视这几个状态都是啥意思, 是啥情况下会变成这几个状态.<br>","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456033,"discussion_content":"1、守护线程也是JVM创建的线程，这块我没有具体看到源码。我们一般不会使用守护线程处理业务，我们这里讨论的是处理业务的线程数量。\n2、在一些非核心业务，我们可以将核心线程数设置小一些，最大线程数量设置为计算线程数量。在一些核心业务中，两者可以设置一样。阻塞队列可以根据具体业务场景设置，如果线程处理业务非常迅速，我们可以考虑将阻塞队列设置大一些，处理的请求吞吐量会大些；如果线程处理业务非常耗时，阻塞队列设置小些，防止请求在阻塞队列中等待过长时间而导致请求已超时。\n\n3、休眠对应的sleep操作，等待对应的wait，驻留对应的线程池里的空闲线程，监视对应的synchronized阻塞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561867598,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206016,"user_name":"姜涛","can_delete":false,"product_type":"c1","uid":1927734,"ip_address":"","ucode":"C7EF07AA39B77D","user_header":"","comment_is_top":false,"comment_ctime":1586773482,"is_pvip":false,"replies":[{"id":"77101","content":"如果共用线程池，如果是IO密集型任务多一些，则可以按照IO密集型任务来设置，如果是CPU密集型任务多一些，可以取中间值。<br><br>做好线程隔离，则分别使用不同的线程池，可以分别设置线程数量。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1586862729,"ip_address":"","comment_id":206016,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10176708074","product_id":100028001,"comment_content":"接口之间的http调用是IO密集型任务嘛？如果一个服务既有IO密集型任务也有CPU密集型任务，是不是线程池需要分别设置线程池大小？","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491641,"discussion_content":"如果共用线程池，如果是IO密集型任务多一些，则可以按照IO密集型任务来设置，如果是CPU密集型任务多一些，可以取中间值。\n\n做好线程隔离，则分别使用不同的线程池，可以分别设置线程数量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586862729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108780,"user_name":"17702158422","can_delete":false,"product_type":"c1","uid":1230682,"ip_address":"","ucode":"226342D3CB73BA","user_header":"","comment_is_top":false,"comment_ctime":1561880709,"is_pvip":false,"replies":[{"id":"39617","content":"以上计算线程池大小都是基于一个比较理想状态下计算的。你说的这些线上环境只是一个微小的影响因素，实际在运行时，同时与线程池竞争资源的线程不会对这个公式造成非常大的影响。这些线程对CPU的使用率一般不会超过20%，系统负载也在1.0以下。<br><br>如果线上环境已经对线程池的大小产生了干扰，也就是说同时存在多线程池同时运行，且竞争CPU资源非常激烈，这个时候应该模拟线上环境，通过性能测试来调优线程池的线程数量。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562034237,"ip_address":"","comment_id":108780,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10151815301","product_id":100028001,"comment_content":"老师请问下一般服务器下所有进程的线程至少100多个了，包括JAVA应用下也不止线程池的线程，还有垃圾回收线程，TOMCAT内置线程等等，这些线程都跑在几个核上，他们也存在上下文切换呀，改如何计算自定义线程池的数量呢","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456113,"discussion_content":"以上计算线程池大小都是基于一个比较理想状态下计算的。你说的这些线上环境只是一个微小的影响因素，实际在运行时，同时与线程池竞争资源的线程不会对这个公式造成非常大的影响。这些线程对CPU的使用率一般不会超过20%，系统负载也在1.0以下。\n\n如果线上环境已经对线程池的大小产生了干扰，也就是说同时存在多线程池同时运行，且竞争CPU资源非常激烈，这个时候应该模拟线上环境，通过性能测试来调优线程池的线程数量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562034237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108459,"user_name":"听雨","can_delete":false,"product_type":"c1","uid":1254493,"ip_address":"","ucode":"252754F9FCFF0C","user_header":"https://static001.geekbang.org/account/avatar/00/13/24/5d/65e61dcb.jpg","comment_is_top":false,"comment_ctime":1561777251,"is_pvip":false,"replies":[{"id":"39361","content":"用过debug模式，在main函数第一条语句设置一个断点，进入断点后，再去VisualVM操作CPU采样，之后再运行程序。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561864497,"ip_address":"","comment_id":108459,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10151711843","product_id":100028001,"comment_content":"老师，程序很快就跑完了，visualvm还没打开程序呢，我看你的图监视的是已终止的程序，那怎么显示已终止程序的信息的呢","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455988,"discussion_content":"用过debug模式，在main函数第一条语句设置一个断点，进入断点后，再去VisualVM操作CPU采样，之后再运行程序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561864497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2426501,"avatar":"","nickname":"Geek_b0c3f5","note":"","ucode":"0C834A0E64015E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346873,"discussion_content":"debug不行吧， 不启动visualVM会卡着","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612088243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108417,"user_name":"张学磊","can_delete":false,"product_type":"c1","uid":1250029,"ip_address":"","ucode":"F545F384A6F1E1","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eotSSnZic41tGkbflx0ogIg3ia6g2muFY1hCgosL2t3icZm7I8Ax1hcv1jNgr6vrZ53dpBuGhaoc6DKg/132","comment_is_top":false,"comment_ctime":1561767363,"is_pvip":false,"replies":[{"id":"39355","content":"感谢学磊童鞋的提醒，已修正。<br><br>答案正确！","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561862875,"ip_address":"","comment_id":108417,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10151701955","product_id":100028001,"comment_content":"老师，线程池流程图提交任务后的第一个节点应该是线程数是否大于核心线程数，如果是再判断队列是否已满，否则直接创建新线程。<br><br>思考题，个人觉得线性执行的代码会成为影响性能的关键，应尽量减少执行时间，比如减少锁持有时间，这样才能达到最大程度的并发。","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455964,"discussion_content":"感谢学磊童鞋的提醒，已修正。\n\n答案正确！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561862875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":288549,"user_name":"狼的诱惑","can_delete":false,"product_type":"c1","uid":1257043,"ip_address":"","ucode":"AE89DFC5963C42","user_header":"https://static001.geekbang.org/account/avatar/00/13/2e/53/bf62683f.jpg","comment_is_top":false,"comment_ctime":1618536126,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5913503422","product_id":100028001,"comment_content":"老师好，大家好：<br>请教个问题，数据库连接最大设置1000，应用程序16实例，配置的核心线程数和最大都是24，压测逻辑只插入数据，没其他逻辑，tps=13000左右。机器是8核16g。<br>问题：<br>1.dba设置数据库1000，压测时数据库无压力，dba认为合适，连接池线程数太大没意义，是这样吗？<br>2.应用数据库连接池分别配置过12，24 进行压测，都是核心等于最大线程，tps差不多，可还有提升空间？<br>3. druid和hikraicp两者性能测了下也没什么区别<br><br>请问以目前的现状可否还有提升空间，sql插入执行还算快，就是有时获取数据库连接会有超时情况，请问怎么优化？","like_count":1},{"had_liked":false,"id":196995,"user_name":"永夜","can_delete":false,"product_type":"c1","uid":1349301,"ip_address":"","ucode":"92F435DFA5C197","user_header":"https://static001.geekbang.org/account/avatar/00/14/96/b5/d09a53c7.jpg","comment_is_top":false,"comment_ctime":1585328785,"is_pvip":false,"replies":[{"id":"75248","content":"对的，可以设置稍微大些","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1585742003,"ip_address":"","comment_id":196995,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5880296081","product_id":100028001,"comment_content":"如果因网络延时等原因导致线程等待时间长，是不是线程池的线程数量就设置的越大，此时就会远超cpu核数。","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489432,"discussion_content":"对的，可以设置稍微大些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585742003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135242,"user_name":"sweetie","can_delete":false,"product_type":"c1","uid":1122905,"ip_address":"","ucode":"824A0C7F0EE53C","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/SNvgKicZbkgtcno0a69T1QNFdXtwU03picZ08o96Jrf3ibdVITYQG8BicJlQfUHL6CPd5ew2kHiaeFib76ldYp5awaCg/132","comment_is_top":false,"comment_ctime":1569077737,"is_pvip":false,"replies":[{"id":"52262","content":"一般是按单机来算线程数","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1569416340,"ip_address":"","comment_id":135242,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5864045033","product_id":100028001,"comment_content":"老师，集群部署的情况，集群有8台机器，按这说法，cpu密集型任务，也要按单机的核数+1么？","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468108,"discussion_content":"一般是按单机来算线程数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569416340,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":116944,"user_name":"Vincent","can_delete":false,"product_type":"c1","uid":1135159,"ip_address":"","ucode":"CD8B84A57A6A0C","user_header":"https://static001.geekbang.org/account/avatar/00/11/52/37/13b4c8aa.jpg","comment_is_top":false,"comment_ctime":1563943505,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5858910801","product_id":100028001,"comment_content":"思考题: 一般我们的意识中都是优化串行段代码，它如果有锁的话会严重降低性能，当然如果你并行段如果有IO操作比如数据库操作那也是很慢的，那这个优化就属于数据库范围了！所以结论是以最终时间消耗为准决定那里优化最紧急","like_count":1},{"had_liked":false,"id":108442,"user_name":"听雨","can_delete":false,"product_type":"c1","uid":1254493,"ip_address":"","ucode":"252754F9FCFF0C","user_header":"https://static001.geekbang.org/account/avatar/00/13/24/5d/65e61dcb.jpg","comment_is_top":false,"comment_ctime":1561773570,"is_pvip":false,"replies":[{"id":"39360","content":"1、内核线程一直存在的，是通过调度器进行调度给用户线程使用的。<br><br>2、是的，如果大量用户线程创建，长时间不释放，会受限内核线程资源而影响系统性能。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561864406,"ip_address":"","comment_id":108442,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5856740866","product_id":100028001,"comment_content":"老师，您说的java线程和内核线程一一对应。那我想的是：<br>1.不管java线程是否阻塞，只要没有销毁，对应的内核线程就一直存在，是这样吗？<br>2.如果java线程已经从内核线程拿到数据，但是还没执行完业务流程，现在对应的内核线程明显已经无事可干了，也会一直存在吗？存在的话，略显浪费呀。<br>请老师解答一下！","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455978,"discussion_content":"1、内核线程一直存在的，是通过调度器进行调度给用户线程使用的。\n\n2、是的，如果大量用户线程创建，长时间不释放，会受限内核线程资源而影响系统性能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561864406,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108433,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1561771730,"is_pvip":false,"replies":[{"id":"39359","content":"可以的，这两个公式已经在生产环境中验证过的。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561863817,"ip_address":"","comment_id":108433,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5856739026","product_id":100028001,"comment_content":"老师我有个问题想问。<br>程序里面不止一个线程池啊，然后又有那么多进程线程数这么设真的可以么。<br>之前做http调用4000请求并发。测试下来开到50个线程时16S完成(最快)4核CPU。调用第三方花费时间差不多一次100ms。按照那个公式不是8个线程最快么。","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455973,"discussion_content":"可以的，这两个公式已经在生产环境中验证过的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561863817,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108427,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1561771084,"is_pvip":false,"replies":[{"id":"39357","content":"这块19讲会帮你解答，建议留意查看。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561863037,"ip_address":"","comment_id":108427,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5856738380","product_id":100028001,"comment_content":"老师好!能问点操作系统方面的问题么?全忘记了。<br>内核线程:会被cpu分配执行时间的线程。<br>用户线程:进程管理的线程，不参与CPU执行时间分配。<br>Linux操作系统其实只有进程的概念。创建的线程都是fork一个子进程然后，把设置一些线程私有的东西。因为是fork的所以同一个进程的线程之间。进程的内存是可见的。<br>然后我记得有个多对一的映射关系，是用户态映射到内核态?希望老师指点补充下，记不清楚了。谢谢老师!有空我再看一遍操作系统。","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455969,"discussion_content":"这块19讲会帮你解答，建议留意查看。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561863037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108411,"user_name":"罗洲","can_delete":false,"product_type":"c1","uid":1263417,"ip_address":"","ucode":"68133E38A25C17","user_header":"https://static001.geekbang.org/account/avatar/00/13/47/39/0ce1aa62.jpg","comment_is_top":false,"comment_ctime":1561761368,"is_pvip":false,"replies":[{"id":"39354","content":"对的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561862666,"ip_address":"","comment_id":108411,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5856728664","product_id":100028001,"comment_content":"思考题:此时优化串行代码是关键，串行代码一般是遇到了锁或阻塞IO，这个时候串行的效率也决定了整个程序的效率。","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455960,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561862666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346749,"user_name":"Bumblebee","can_delete":false,"product_type":"c1","uid":2051293,"ip_address":"","ucode":"B879C8A511D08D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","comment_is_top":false,"comment_ctime":1653396542,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1653396542","product_id":100028001,"comment_content":"今日收获，总结的不对的希望老师，同学们多多指正<br><br>① 为什么通常将核心线程数设置为CPU个数+1 ？<br><br>举个例子，在有4个CPU的机器上跑任务，当每个CPU都被一个线程所占用执行任务，当有个线程需要等待I&#47;O时此时CPU回空闲下来了，如果线程数比CPU多一个此时CPU能被这多出来的一个线程利用，从而提高了CPU的利用率；<br><br>② 为什么I&#47;O密集型的任务线程数要设置为2N？<br><br><br>因为线程大部分时间是在处理I&#47;O，线程处理I&#47;O时不占用CPU，空出来的CPU及时给其他线程用，从而提高CPU利用率；","like_count":0},{"had_liked":false,"id":346747,"user_name":"Bumblebee","can_delete":false,"product_type":"c1","uid":2051293,"ip_address":"","ucode":"B879C8A511D08D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","comment_is_top":false,"comment_ctime":1653395950,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1653395950","product_id":100028001,"comment_content":"分享一下，自己心中的一个疑问，后面又自己想清楚了的疑问😂<br><br><br>线程池线程设置过多，会造成线程竞争过于激烈从而造成过度的线程上线问切换；<br><br>假设，被持续提交给线程池的任务是一个方法，此方法被synchronized修饰，因为每次只有一个线程能获取到锁得到CPU执行权限，是不是就不会因为线程池太大而造成过多的线程上下文切换；<br><br>反过来想一下每次只能有一个线程得带锁，并获得CPU执行权限，那么为什么要用线程池呢😂","like_count":1},{"had_liked":false,"id":309684,"user_name":"时熵","can_delete":false,"product_type":"c1","uid":1095280,"ip_address":"","ucode":"3CDAE8628117D5","user_header":"https://static001.geekbang.org/account/avatar/00/10/b6/70/33e87a4f.jpg","comment_is_top":false,"comment_ctime":1630302189,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630302189","product_id":100028001,"comment_content":"老师“线程平均整体时间”这个是怎么计算出来的呢？","like_count":0},{"had_liked":false,"id":290388,"user_name":"aiwen","can_delete":false,"product_type":"c1","uid":1104346,"ip_address":"","ucode":"504F06CCC7B4FB","user_header":"https://static001.geekbang.org/account/avatar/00/10/d9/da/23a4a0c4.jpg","comment_is_top":false,"comment_ctime":1619523003,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619523003","product_id":100028001,"comment_content":"建议你看看美团技术一篇关于如何设置线程池大小的文章。","like_count":0},{"had_liked":false,"id":270651,"user_name":"惘 闻","can_delete":false,"product_type":"c1","uid":1181650,"ip_address":"","ucode":"C5909F034BF072","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","comment_is_top":false,"comment_ctime":1609207312,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609207312","product_id":100028001,"comment_content":"如果预热完全了核心线程切都是空闲的,那么新来一个任务还是会进入等待队列.然后被空闲线程遍历获取执行.","like_count":0},{"had_liked":false,"id":265236,"user_name":"dream","can_delete":false,"product_type":"c1","uid":1117793,"ip_address":"","ucode":"65B33D32FA8BE9","user_header":"https://static001.geekbang.org/account/avatar/00/11/0e/61/ae68f8eb.jpg","comment_is_top":false,"comment_ctime":1606820228,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606820228","product_id":100028001,"comment_content":"老师，我想问一下。<br>如果我在一个应用中有多个地方用不同的线程池。<br>那么线程池一的线程池数量按照文中的场景和公式套用了，线程池二需要考虑线程池一占用的资源吗？<br>如果可以的话，分两种场景考虑：<br>1. 两个线程池没有任何关联<br>2. 假设线程池一中的任务执行过程中需要使用线程池二<br>这两种情况分别怎么分析呢？","like_count":0},{"had_liked":false,"id":249402,"user_name":"W.YH","can_delete":false,"product_type":"c1","uid":1161636,"ip_address":"","ucode":"9BBE1EE38CDCAF","user_header":"https://static001.geekbang.org/account/avatar/00/11/b9/a4/e9d2f9ba.jpg","comment_is_top":false,"comment_ctime":1600649294,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600649294","product_id":100028001,"comment_content":"关于课后题，优化的应该是最占用时间的代码，如果是串行代码，但是不存在逻辑上的依赖关系，那么可以用并发包里面的工具类，将无关的串行逻辑并行处理完，再走后续逻辑","like_count":0},{"had_liked":false,"id":244989,"user_name":"旅途","can_delete":false,"product_type":"c1","uid":1212902,"ip_address":"","ucode":"5022477E8E9441","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/e6/6cafed37.jpg","comment_is_top":false,"comment_ctime":1598774683,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598774683","product_id":100028001,"comment_content":"讲得不错 将我之前了解的知识都串联并完善了 非常棒","like_count":0},{"had_liked":false,"id":213347,"user_name":"天天向上","can_delete":false,"product_type":"c1","uid":1242455,"ip_address":"","ucode":"0CCCA6F4DCC480","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg","comment_is_top":false,"comment_ctime":1588390639,"is_pvip":false,"replies":[{"id":"80541","content":"还是优先结合使用到该线程池的业务来设置，之后再考虑所有线程池的大小是否有相互影响，如果有相互影响，则需要考虑调整。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1589618695,"ip_address":"","comment_id":213347,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1588390639","product_id":100028001,"comment_content":"一个应用，肯定比不是单有线程池中的线程来运行的。比如我的一个web应用，既要处理正常的web请求，其中还有某些业务需要用到多线程来处理，那这时候多线程处理的部分线程池的数量如何设置呢？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493755,"discussion_content":"还是优先结合使用到该线程池的业务来设置，之后再考虑所有线程池的大小是否有相互影响，如果有相互影响，则需要考虑调整。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589618695,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":213339,"user_name":"天天向上","can_delete":false,"product_type":"c1","uid":1242455,"ip_address":"","ucode":"0CCCA6F4DCC480","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg","comment_is_top":false,"comment_ctime":1588389981,"is_pvip":false,"replies":[{"id":"80540","content":"这里指的是数量","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1589618425,"ip_address":"","comment_id":213339,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1588389981","product_id":100028001,"comment_content":"线程池中所有的线程应该都是一视同仁的吧，线程上并没有标记该线程为核心线程，或者该线程为非核心线程吧。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493750,"discussion_content":"这里指的是数量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589618425,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206018,"user_name":"姜涛","can_delete":false,"product_type":"c1","uid":1927734,"ip_address":"","ucode":"C7EF07AA39B77D","user_header":"","comment_is_top":false,"comment_ctime":1586773561,"is_pvip":false,"replies":[{"id":"77098","content":"看实际业务操作","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1586862555,"ip_address":"","comment_id":206018,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1586773561","product_id":100028001,"comment_content":"http的调用时IO密集型的嘛？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491642,"discussion_content":"看实际业务操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586862555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":197465,"user_name":"脱缰的野马__","can_delete":false,"product_type":"c1","uid":1447569,"ip_address":"","ucode":"D5F993E7232C61","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/WtHCCMoLJ2DvzqQwPYZyj2RlN7eibTLMHDMTSO4xIKjfKR1Eh9L98AMkkZY7FmegWyGLahRQJ5ibPzeeFtfpeSow/132","comment_is_top":false,"comment_ctime":1585380129,"is_pvip":false,"replies":[{"id":"75252","content":"是的，共用一个就好了，如果某些接口访问量比较大又担心影响其他接口，可以单独一个线程池做线程隔离","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1585743381,"ip_address":"","comment_id":197465,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585380129","product_id":100028001,"comment_content":"老师您好，我有个问题，就是我们一个后台服务，部署之后，这个服务肯定是对外提供多个接口服务的，我们在这个服务中应该只设置一个全局的线程数合理的线程池，这样的话所有接口的逻辑如果要用到线程池的话就都用这一个吧？这样才是合理的吧？因为我看过有些后台服务的代码，发现很多接口都是用各自创建的静态线程池，这样的话即使每个线程池数设计的合理，但从整个应用服务来看是不合理的对吗？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489527,"discussion_content":"是的，共用一个就好了，如果某些接口访问量比较大又担心影响其他接口，可以单独一个线程池做线程隔离","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585743381,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190130,"user_name":"北城以北","can_delete":false,"product_type":"c1","uid":1695382,"ip_address":"","ucode":"A8B6CB18EBA58C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLJiaPZmuibaYlicRJzS0iaeHcVJ9N8F00fsXicdlcJNZia7C0NtQ66ICUXr4Wb7RELcKMiaJUGpibhHF1axA/132","comment_is_top":false,"comment_ctime":1584605366,"is_pvip":false,"replies":[{"id":"74188","content":"调度在用户态发生，但是线程调度会发生上下文切换，这个没有冲突","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1585139344,"ip_address":"","comment_id":190130,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1584605366","product_id":100028001,"comment_content":"Java 通过用户线程与内核线程结合的 1:1 线程模型来实现，Java 将线程的调度和管理设置在了用户态<br>====================<br>想请问下老师这句话是不是有歧义，Java线程的调度是会发生系统调用，即用户态切换到用户态的，比如线程的新建、阻塞、关闭。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487897,"discussion_content":"调度在用户态发生，但是线程调度会发生上下文切换，这个没有冲突","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585139344,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170217,"user_name":"chp","can_delete":false,"product_type":"c1","uid":1112415,"ip_address":"","ucode":"F0A2442230CD45","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/5f/b0a125a9.jpg","comment_is_top":false,"comment_ctime":1578551926,"is_pvip":false,"replies":[{"id":"67223","content":"io为主，通常我们都是设置2*n，例如netty中的io线程池的线程数量默认为2*n","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1579524434,"ip_address":"","comment_id":170217,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578551926","product_id":100028001,"comment_content":"有个问题是，任务既有CPU消耗，也有IO消耗，这种情况下要用哪个公式好？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480885,"discussion_content":"io为主，通常我们都是设置2*n，例如netty中的io线程池的线程数量默认为2*n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579524434,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150906,"user_name":"杨彬Lennon","can_delete":false,"product_type":"c1","uid":1141816,"ip_address":"","ucode":"A758A0C221E549","user_header":"https://static001.geekbang.org/account/avatar/00/11/6c/38/f575ef95.jpg","comment_is_top":false,"comment_ctime":1573625233,"is_pvip":false,"replies":[{"id":"58093","content":"这个流程图没问题的，在队列满了之后，还会去判断线程池是否能再新增非核心线程，我们具体可以深入源码熟悉线程池的工作原理。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1573640620,"ip_address":"","comment_id":150906,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1573625233","product_id":100028001,"comment_content":"线程池的线程分配流程，这个图不对吧？队列是否已满:是的话要执行拒绝策略，否的话要加入任务队列，等待释放的线程资源。不知道是不是这样？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474306,"discussion_content":"这个流程图没问题的，在队列满了之后，还会去判断线程池是否能再新增非核心线程，我们具体可以深入源码熟悉线程池的工作原理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573640620,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1141816,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6c/38/f575ef95.jpg","nickname":"杨彬Lennon","note":"","ucode":"A758A0C221E549","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50387,"discussion_content":"哦，非公平nonfair的？好吧还是得多看源码，不能想当然了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573715274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144132,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1571847165,"is_pvip":false,"replies":[{"id":"55854","content":"没有到达核心线程数，新的任务进来也会创建线程执行，可以查看源码看到具体的实现","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1572078370,"ip_address":"","comment_id":144132,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1571847165","product_id":100028001,"comment_content":"老师，如果线程池没有达到核心线程数，等待队列中也没有数据（即空），那么新来的任务也会创建新的线程执行么，还是用池中原有的线程执行？看流程图突然想到了这个问题","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471822,"discussion_content":"没有到达核心线程数，新的任务进来也会创建线程执行，可以查看源码看到具体的实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572078370,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135220,"user_name":"sweetie","can_delete":false,"product_type":"c1","uid":1122905,"ip_address":"","ucode":"824A0C7F0EE53C","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/SNvgKicZbkgtcno0a69T1QNFdXtwU03picZ08o96Jrf3ibdVITYQG8BicJlQfUHL6CPd5ew2kHiaeFib76ldYp5awaCg/132","comment_is_top":false,"comment_ctime":1569067615,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569067615","product_id":100028001,"comment_content":"老师，cpu密集型任务，集群部署的情况，集群有8台机器，按这个N+1说法，怎么配呢？集群会影响配这个值么？","like_count":0},{"had_liked":false,"id":135084,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1569003137,"is_pvip":false,"replies":[{"id":"51862","content":"对的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1569051683,"ip_address":"","comment_id":135084,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569003137","product_id":100028001,"comment_content":"老师，最后一段表述是不是有问题，＂将来不及处理的线程缓存到队列中＂，应该是任务吧","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468039,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569051683,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135081,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1569002800,"is_pvip":false,"replies":[{"id":"51863","content":"cpu密集情况下是n+1，如果是4核的情况下就是4+1。2n+1一般用于io密集的情况","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1569051753,"ip_address":"","comment_id":135081,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569002800","product_id":100028001,"comment_content":"老师，平时常听到的4核8线程是什么意思？在cpu密集情况下，线程数是4+1还是8+1？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468037,"discussion_content":"cpu密集情况下是n+1，如果是4核的情况下就是4+1。2n+1一般用于io密集的情况","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569051753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135080,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1569002612,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569002612","product_id":100028001,"comment_content":"老师讲课的逻辑思路真清楚，可见功力之强、知识体系完整。每天看一遍都有新的收获","like_count":0},{"had_liked":false,"id":132262,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1568075283,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568075283","product_id":100028001,"comment_content":"课后思考及问题<br>1：当程序提交一个任务需要一个线程时，会去线程池中查找是否有空闲的线程，若有，则直接使用线程池中的线程工作，若没有，会去判断当前已创建的线程数量是否超过最大线程数量，如未超过，则创建新线程，如已超过，则进行排队等待或者直接抛出异常。<br>我们可以通过下面这张图来了解下线程池的线程分配流程：<br>有个疑问，感觉上段文字描述和线程池的分配流程不符？请老师解释下那个更加准确，我也看到评论区有好多同学都有这样的疑惑。老师的解释是线程池的分配流程图是OK的，假如线程池的分配流程图是OK的，那请老师解释一下如下疑问：<br>1：为什么会与上面这段文字的描述不符？<br>2：是否意味着等待队列中的任务只会分配给，核心线程？<br>3：老师后文又提到销毁线程时核心线程和非核心线程是同等对待的，这与2中的推断又是矛盾的？<br>4：假如老师解释清楚了1&#47;2&#47;3，这三个矛盾点，那我想问一下线程池的分配流程为什么这么设计？<br>5：线程池各个参数的相互关系图，我仔细看了几遍，有一个小瑕疵——corePoolSize那个位置也属于核心线程应该占的位置吧？图中核心线程有7个位置，非核心线程有6个位置，任务等待队列有9个位置，按照老师的线程池分配流程图来看，第1~6个线程提交的任务有核心线程来处理，第7~15个线程提交的任务会放入任务等待队列，第16~22个线程提交的任务会有非核心线程来处理(假设理想情况下这样)<br>5-1：此时再来一个线程提交的任务会根据拒绝策略来处理？全面的拒绝策略有几种都是如何实现的？<br>5-2：假如核心线程1处理完了一个任务，它去任务等待队列中获取任务是从队头有序获取的嘛？<br>5-3：会存在核心线程处理完任务重新放入线程池比新提交的任务晚，导致任务被拒绝的场景吧？这个有什么解决思路嘛？<br>5-4：如果只有15个线程提交任务，非核心线程是永远都不会创建了吧？<br>5-5：核心线程和非核心线程，本身或者在线程池中区分不开，所以，销毁时才不做区分同等对待嘛？<br>问题有点多，望老师解惑!<br>","like_count":0},{"had_liked":false,"id":129507,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1567143038,"is_pvip":false,"replies":[{"id":"53313","content":"是的，需要初始化","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1570352246,"ip_address":"","comment_id":129507,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1567143038","product_id":100028001,"comment_content":"老师，两个测试例子，一开始线程数都是2的时候，线程整体运行时间都很高，是不是因为此时线程池里面还没有线程，创建线程需要时间？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465510,"discussion_content":"是的，需要初始化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570352246,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129386,"user_name":"行则将至","can_delete":false,"product_type":"c1","uid":1542987,"ip_address":"","ucode":"DB972F2DF059C4","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","comment_is_top":false,"comment_ctime":1567124028,"is_pvip":false,"replies":[{"id":"48174","content":"这里缓存到队列只是一个任务队列，不是一种拒绝策略，是线程池实现排队等待获取线程的策略。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1567127714,"ip_address":"","comment_id":129386,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1567124028","product_id":100028001,"comment_content":"老师。关于线程池的拒绝策略。一共有四种<br>没有您说的直接把任务缓存到队列中的策略吧？<br>意思比较近的一个策略是：丢弃队列中最近的一个任务，然后缓存该任务<br>望老师指点","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465432,"discussion_content":"这里缓存到队列只是一个任务队列，不是一种拒绝策略，是线程池实现排队等待获取线程的策略。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567127714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128903,"user_name":"月迷津渡","can_delete":false,"product_type":"c1","uid":1264111,"ip_address":"","ucode":"2B18B2FE3DAC3B","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/ef/02401473.jpg","comment_is_top":false,"comment_ctime":1566982144,"is_pvip":false,"replies":[{"id":"48625","content":"使用的是ab测试工具","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1567425426,"ip_address":"","comment_id":128903,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566982144","product_id":100028001,"comment_content":"请问老师 上面的时间性能测试图，IO密集和CPU密集这两张截图是什么工具跑出来的。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465165,"discussion_content":"使用的是ab测试工具","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567425426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127178,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1566578706,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1566578706","product_id":100028001,"comment_content":"老师，您好！<br><br>最近遇到了一个问题，不知道该如何优雅终止线程。<br><br>现有 4 个线程（2个线程池）：<br>1. A、B线程（线程池）读取数据往队列里写。<br>2. C、D线程（线程池）从队列里读数据处理（处理比较慢）。<br><br>A 和 B 线程的伪代码：<br>while(true) {<br>  &#47;&#47; 从数据库读取列表<br>  list = query()<br>  if(list.isEmpty()) break;<br>  &#47;&#47; 数据放入队列<br>  for(item : list) queue.put(item);<br>}<br><br>C 和 D 线程的伪代码：<br>while(true) {<br>  &#47;&#47; 队列无数据，则阻塞等待<br>  item = queue.take();<br><br>  if(item == poisonPill) break;<br><br>  &#47;&#47; 处理 item<br>  process(item);<br>}<br><br>当 A 和 B 读完数据之后，如何通知 C 和 D，数据已经读取完毕，然后 C、D 自行处理完毕后就自动退出线程。<br><br>我现在的做法是往队列里写一个“毒丸”对象，但是这样只能通知到 C 或 D，无法两个线程都通知到。不知道该如何停止 C 和 D 线程。<br><br>或者让 C 和 D 线程一直阻塞在 queue.take()，等到第二天再次触发 A、B 线程读数据往队列写入数据时唤醒 C、D 线程？<br>C、D 阻塞在队列的 take() 方法处，占着资源不释放，会不会与我们的优化课程主题不太相符？<br><br>谢谢老师！！","like_count":0,"discussions":[{"author":{"id":1235750,"avatar":"https://static001.geekbang.org/account/avatar/00/12/db/26/3c8d68fb.jpg","nickname":"天使梦泪","note":"","ucode":"782991747DD424","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290156,"discussion_content":"notify all都唤醒线程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594361524,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122833,"user_name":"Geek_ebda96","can_delete":false,"product_type":"c1","uid":1134862,"ip_address":"","ucode":"02912E6D95A5A6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoRiaKX0ulEibbbwM4xhjyMeza0Pyp7KO1mqvfJceiaM6ZNtGpXJibI6P2qHGwBP9GKwOt9LgHicHflBXw/132","comment_is_top":false,"comment_ctime":1565538420,"is_pvip":false,"replies":[{"id":"45085","content":"跟具体的IO时间有关系，如果IO时间越长，线程数量就会越大。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1565573138,"ip_address":"","comment_id":122833,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565538420","product_id":100028001,"comment_content":"老师，你好，我用IOTypeTest这个代码测试了一下IO密集型的，我的机器4核64位的i7配置MAC，测试文件大小3M，线程数从4到32，线程平均执行时间都在2000到2300毫秒间变化，线程整体时间，随着线程数增大一直在减少，从4个线程到32个线程执行时间减少非常明细，从32线程到64线程整体执行时间减少很小，感觉32个线程是合适的，跟你给出的测试结果有些不一样，请问是什么原因呢","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462423,"discussion_content":"跟具体的IO时间有关系，如果IO时间越长，线程数量就会越大。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565573138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122639,"user_name":"Edward","can_delete":false,"product_type":"c1","uid":1058243,"ip_address":"","ucode":"7C8DE1047BB62E","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/c3/da248508.jpg","comment_is_top":false,"comment_ctime":1565449409,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565449409","product_id":100028001,"comment_content":"当程序提交一个任务需要一个线程时，会去线程池中查找是否有空闲的线程，若有，则直接使用线程池中的线程工作，若没有，会去判断当前已创建的线程数量是否超过最大线程数量，如未超过，则创建新线程，如已超过，则进行排队等待或者直接抛出异常。这块逻辑跟后面图中逻辑不一致啊，当core 线程满了以后，后面来的任务是先开新的线程还是放在阻塞队列呢","like_count":0},{"had_liked":false,"id":108995,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1561945327,"is_pvip":false,"replies":[{"id":"39620","content":"我们发包一般是通过网关将请求拦截，将请求转发到其他服务，并排除当前服务没有业务日志运行，再进行部署，这种可以排除你说的部署中断造成的异常问题。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562035427,"ip_address":"","comment_id":108995,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561945327","product_id":100028001,"comment_content":"思考题：一般会选择优化串行，毕竟大部分并行的异步操作都无需拿返回值，一般是做一下非强一致性的同步，收尾操作。但也不排除特例，比如生产消费模式，异步消费如果是整个调用链的瓶颈点，那么优化异步的消费代码就合理。所以优化串行代码还是并行代码就是看情况的选择项。<br>额外请教，如果发包中断进程，哪怕有做优雅关闭，异步线程调用好像都是拒绝的，也就是会直接抛异常。那么异常的回滚操作是不是就不能有异步操作？mq调用好像也是抛异常的。（实际工作出现过脏数据，猜测是这样，自己又没测试，望老师指明）","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456199,"discussion_content":"我们发包一般是通过网关将请求拦截，将请求转发到其他服务，并排除当前服务没有业务日志运行，再进行部署，这种可以排除你说的部署中断造成的异常问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562035427,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108965,"user_name":"夏天39度","can_delete":false,"product_type":"c1","uid":1104979,"ip_address":"","ucode":"A929B422255547","user_header":"https://static001.geekbang.org/account/avatar/00/10/dc/53/ccb62ea0.jpg","comment_is_top":false,"comment_ctime":1561942711,"is_pvip":false,"replies":[{"id":"39615","content":"没有相应的计算公式，不过我们可以通过压测来设置一个合理的大小。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562033084,"ip_address":"","comment_id":108965,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561942711","product_id":100028001,"comment_content":"超哥，如何设置有界队列的大小啊，设置大了容易oom，小了吞吐量又不够，有什么什么计算公式啊","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456185,"discussion_content":"没有相应的计算公式，不过我们可以通过压测来设置一个合理的大小。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562033084,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108742,"user_name":"欧星星","can_delete":false,"product_type":"c1","uid":1014347,"ip_address":"","ucode":"56365442E231A0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/4b/1a7b36ab.jpg","comment_is_top":false,"comment_ctime":1561870678,"is_pvip":false,"replies":[{"id":"39614","content":"看平均线程整体花费时间，继续增大线程数量，则平均线程整体花费时间会开始上升。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562033019,"ip_address":"","comment_id":108742,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561870678","product_id":100028001,"comment_content":"老师，请问一下，图中是看线程执行时间还是整体花费时间，我测试CPU密集型任务在我电脑中是整体时间下降、执行行时间上上升的。<br><br>线程数\t平均线程整体花费时间\t平均线程执行花费时间<br>2\t            34513\t\t\t\t1354<br>4\t            19912\t\t\t\t1494<br>8\t            14138\t\t\t\t2028<br>16\t            10632\t\t\t\t2855<br>32\t            9928\t\t\t\t4683<br>","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456099,"discussion_content":"看平均线程整体花费时间，继续增大线程数量，则平均线程整体花费时间会开始上升。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562033019,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108536,"user_name":"杨俊","can_delete":false,"product_type":"c1","uid":1158214,"ip_address":"","ucode":"3CAE634618D924","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/46/7e24bad6.jpg","comment_is_top":false,"comment_ctime":1561796179,"is_pvip":true,"replies":[{"id":"39368","content":"最后这个问题我没有太理解。非核心线程执行的任务可能是非阻塞队列的任务？","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561866545,"ip_address":"","comment_id":108536,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561796179","product_id":100028001,"comment_content":"老是我可以这样理解吗，阻塞队列满了之后创建的是非核心线程而不是核心线程，非核心线程执行完可能空闲一段时间就会被销毁，除非达到最大线程数，否则当阻塞时候有任务就会创建非核心线程，那是不是有可能这个非核心线程会比阻塞队列里面的先执行任务呢","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456030,"discussion_content":"最后这个问题我没有太理解。非核心线程执行的任务可能是非阻塞队列的任务？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561866545,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108513,"user_name":"Nu11PointerEx","can_delete":false,"product_type":"c1","uid":1177802,"ip_address":"","ucode":"D5C19A98F894B7","user_header":"https://static001.geekbang.org/account/avatar/00/11/f8/ca/1a1e190a.jpg","comment_is_top":false,"comment_ctime":1561789759,"is_pvip":false,"replies":[{"id":"39366","content":"通过excel制作的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561865380,"ip_address":"","comment_id":108513,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1561789759","product_id":100028001,"comment_content":"刘老师你好，我想问下测试结果的可视化图表是如何制作的？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456019,"discussion_content":"通过excel制作的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561865380,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1054958,"avatar":"https://static001.geekbang.org/account/avatar/00/10/18/ee/a1ed60d1.jpg","nickname":"ABC","note":"","ucode":"7501AD9C0C4A70","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":646,"discussion_content":"https://echarts.baidu.com/examples/editor.html?c=line-stack \n我不知道老师是怎么制作的，但可以在这直接修改数据,然后运行代码生成图表.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561872068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108501,"user_name":"colin","can_delete":false,"product_type":"c1","uid":1292206,"ip_address":"","ucode":"7A8849B8AE33E0","user_header":"https://static001.geekbang.org/account/avatar/00/13/b7/ae/a25fcb73.jpg","comment_is_top":false,"comment_ctime":1561786917,"is_pvip":false,"replies":[{"id":"39367","content":"是的，已修正。理解到位","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561865450,"ip_address":"","comment_id":108501,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561786917","product_id":100028001,"comment_content":"线程分配流程图的第一个分支应该是大于吧<br><br><br>线程池我的理解就是，经量使用核心线程。能等到核心线程的就不创建非核心线程。有长时间不工作的线程，那么就回收它，保证线程数量在核心线程数量内","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456009,"discussion_content":"是的，已修正。理解到位","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561865450,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}