{"id":740893,"title":"第 16 章 服务集成(1)","content":"<blockquote>\n<p><strong>本章内容</strong></p>\n<ul>\n<li>使用 Dubbo 进行 RPC 通信</li>\n<li>使用多种不同的消息中间件进行消息通信</li>\n<li>服务链路追踪的基本原理与实现</li>\n<li>Spring Cloud Gateway 的基本用法</li>\n</ul>\n</blockquote>\n<p>本书之前的章节中都使用基于 HTTP 的 REST 服务来进行通信。除了 REST 服务，现实生产中还有很多通信方式，同步调用可以选择 RPC，例如 Java 世界中早期的 RMI、如今阿里巴巴开源的 Dubbo 框架（国内有很多公司在使用）；如果希望使用异步通信，基于消息的形式也是很好的选择，像 Kafka、RocketMQ 和 RabbitMQ 的使用都很广泛。</p>\n<p>此外，在对外提供服务时通常不会让微服务系统直接面对外部，而是通过微服务网关来统一对外，内部跨域服务有时也会做类似的设计。基于微服务架构的系统链路往往很复杂，一个业务请求会经过很多系统，为了搞明白请求是怎么流转的，链路追踪相关的功能在后期也是必不可少的。在本书的最后一章，就让我们来聊聊这些和服务集成有关的话题吧！</p>\n<h2 id=\"nav_point_242\">16.1　使用 Dubbo 进行 RPC 通信</h2>\n<p>RPC 的全称是 Remote Procedure Call，也就是<strong>远程过程调用</strong>的意思。对软件开发者来说，RPC 框架可以把一次远程调用“伪装”成一次本地调用，在使用时几乎感觉不到两者的差异。这种设计可以说是把双刃剑，好处是降低了远程调用的使用门槛，坏处则是让人忽视了远程调用与本地调用的很多差异，容易掉进“坑”里。但不管怎么说，在一个微服务架构的系统里，服务间的通信是必不可少的，RPC 被大量运用于各种场景。业内有很多优秀的开源 RPC 框架，国外有 Google 的 gRPC、Facebook 的 Thrift 和 Twitter 的 Finagle，国内则有阿里巴巴的 Dubbo、百度的 bRPC 和新浪微博的 Motan。接下来就让我们一起了解一下国内广泛使用的 Dubbo 框架。</p><!-- [[[read_end]]] -->\n<h3 id=\"nav_point_243\">16.1.1　Dubbo 概述</h3>\n<p>Dubbo 是一款高性能、轻量级、易扩展的开源服务框架，除了 RPC 通信能力以外，还提供了大量服务治理能力，例如服务发现、负载均衡、流量调度等。凭借在阿里巴巴超大规模集群与流量的成功落地经验，Dubbo 被国内很多公司用作内部的 RPC 框架。</p>\n<p>虽然有无数光环在身，但 Dubbo 的一路发展也经历了一些“坎坷”。2008 年，阿里巴巴发布了 Dubbo 的首个版本，是其内部的 SOA 解决方案；到 2010 年，Dubbo 已经在阿里巴巴内部全面落地；2011 年，阿里巴巴开源了 Dubbo 的源代码，受到了广泛的好评，并被大量阿里巴巴以外的公司使用；但到了 2012 年，官方停止了对 Dubbo 的更新（停留在 2.5.3 版本），只能由一些使用了 Dubbo 的公司自己维护一些分支版本，其中最出名的就是当当维护的 DubboX；2017 年，阿里巴巴宣布重启 Dubbo 的维护，并在 2018 年将 Dubbo 捐献给了 Apache 基金会，2019 年 Dubbo 就成为了 Apache 的顶级项目。</p>\n<ol>\n<li><p><strong>Dubbo 的架构</strong></p>\n<p>在一个使用 Dubbo 的系统中，服务节点会分成如下几个主要角色——<strong>容器</strong>（Container）、<strong>服务提供者</strong>（Provider）、<strong>服务消费者</strong>（Consumer）、<strong>注册中心</strong>（Registry）和<strong>监控中心</strong>（Monitor），具体如图 16-1 所示 <span class=\"comment-number\">1</span>。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00798.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 16-1　Dubbo 架构示意图</strong></p>\n<p>一个 Dubbo 服务的注册消费过程大概是下面这样的，其中头 3 步是初始化阶段，第 (5) 步是同步调用，其余都是异步动作（对应了图 16-1 中的 0 到 5）：</p>\n<p>(1) 容器负责启动服务提供者；</p>\n<p>(2) 服务提供者在启动时（可以是立刻也可以稍有延时），向注册中心注册服务；</p>\n<p>(3) 服务消费者在启动时，向注册中心订阅自己所需的服务；</p>\n<p>(4) 注册中心将服务提供者的地址列表返回给消费者，如果列表有变更，注册中心会主动将变更推送给消费者；</p>\n<p>(5) 服务消费者会基于一定的算法，从列表中选择提供者进行调用；</p>\n<p>(6) 服务消费者和提供者定时将调用统计信息发送给监控中心（这一步是可选的，实际部署时可以没有监控中心）。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>2.<em>x</em> 与 3.<em>x</em> 的差异</strong></p>\n<p>Dubbo 3.0 已经正式发布了，这个版本带来了大量的新特性。由于在本书编写时 3.0 刚发布不久，很多周边的设施还未及时跟上，因而我们在书中还是继续使用 2.7.<em>x</em> 版本，但这并不妨碍大家了解两个大版本之间的差异。</p>\n<ul>\n<li>首先是服务发现模型的变化，在 3.0 之前 Dubbo 都是以<strong>服务接口</strong>的粒度来注册的。一个应用会提供多个接口，这就导致在大规模集群中接口数量特别多，在注册中心和服务内部都要消耗大量资源来存储这些接口，变更推送的压力也很大，管理起来还很麻烦。到了 3.0，可以用<strong>应用</strong>这个粒度来注册和发现服务，瞬间要操心的东西就少了很多。</li>\n<li>其次是在协议上，3.0 提供了全新的兼容 gRPC 的 Triple 协议，在跨语言的可交互性上得到了质的提升。作为一款基于 HTTP/2 构建的 RPC 协议，Triple 能很好地与各种基础设施协作，例如各种服务网格的 Sidecar 和服务网关。</li>\n</ul>\n<p>以上两点让 Dubbo 3.0 在性能方面优于 2.<em>x</em>。此外，3.0 是完全拥抱云原生的，解决了之前一直困扰大家的 Dubbo 服务与资源调度平台的生命周期、地址等不一致的问题。新的流量管理策略也能很好地支持服务网格，非常轻松地就能实现蓝绿发布等功能。</p>\n</li>\n</ol>\n\n<h3 id=\"nav_point_244\">16.1.2　Dubbo 的基础用法</h3>\n<p>Dubbo 的使用非常方便，特别是针对 Spring 项目，提供了多种配置方法——既可以使用传统的 Spring XML 文件，也可以使用 Java 注解的形式。在 Spring Boot 自动配置的帮助下，原先很多基础性的配置也不再需要开发者操心了，几乎就是“开箱即用”。让我们通过一个例子来了解一下 Dubbo 的具体用法。</p>\n<blockquote>\n<p><strong>需求描述</strong>　二进制奶茶店的系统之前都是使用 HTTP 的方式进行通信的，技术部人员进行了一些调研，想要在系统中尝试使用 Dubbo 进行通信—此处要做的就是，在保留原有服务的同时，增加一个 Dubbo 的菜单服务。</p>\n</blockquote>\n<ol>\n<li><p><strong>引入依赖</strong></p>\n<p>在传统 Spring 项目里，我们可以引入 <code>org.apache.dubbo:dubbo</code> 依赖，随后进行各种初始化。但在 Spring Boot 项目中，我们有更好的选择，就是像下面这样引入起步依赖 <span class=\"comment-number\">2</span>：</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;\n    &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;\n    &lt;version&gt;$&lt;/version&gt;\n&lt;/dependency&gt;</code></pre>\n<p>它会传递引用 <code>dubbo-spring-boot-autoconfiguration-compatible</code>，其中提供了与 Dubbo 相关的自动配置类 <code>DubboAutoConfiguration</code> 和 <code>DubboRelaxedBindingAutoConfiguration</code>，还有配置属性类 <code>DubboConfigurationProperties</code>，让我们可以用 Spring Boot 的方式使用 Dubbo。</p>\n<p>Dubbo 本身的 Jar 中只包含了自身的基本功能，我们要根据自己的需要增加各种其他依赖。例如，要使用 Zookeeper 来作为注册中心，就要引入对应的 Curator 依赖，而 Dubbo 对这些依赖的版本也有要求，因此最好让 Dubbo 来管理这些版本，在 <code>&lt;dependencyManagement/&gt;</code> 加入 <code>dubbo-dependencies-bom</code>，就像下面这样，后续添加对应库的依赖时就无须再写版本了。由于 <code>dubbo-dependencies-bom</code> 里的 Spring Framework 版本与 Spring Boot 的可能存在差异，因而这里额外再导入一下 Spring Framework 相关的依赖（<code>$</code> 是 Spring Boot 管理版本，无须自己定义）。<span class=\"comment-number\">3</span></p>\n<pre class=\"code-rows\"><code>&lt;dependencyManagement&gt;\n    &lt;dependencies&gt;\n        &lt;!-- 省略其他Spring Cloud与Spring Cloud Alibaba的依赖 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-framework-bom&lt;/artifactId&gt;\n            &lt;version&gt;$&lt;/version&gt;\n            &lt;type&gt;pom&lt;/type&gt;\n            &lt;scope&gt;import&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;\n            &lt;artifactId&gt;dubbo-dependencies-bom&lt;/artifactId&gt;\n            &lt;version&gt;$&lt;/version&gt;\n            &lt;type&gt;pom&lt;/type&gt;\n            &lt;scope&gt;import&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/dependencyManagement&gt;</code></pre>\n<p>我们如果想自己管理依赖，也可以不添加 <code>dubbo-dependencies-bom</code>，这个就看大家的实际情况了。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>服务提供者和消费者的配置</strong></p>\n<p>因为 Dubbo 服务都是基于接口来发布的，所以在添加好依赖之后，就该定义接口了。BinaryTea 中的菜单接口和实现相对比较简单，如代码示例 16-1 所示。由于之前已经定义了一个 <code>MenuService</code> 类，这次的新接口需要换个包，或者换个名字，这里选择将 Dubbo 的接口和实现放在 <code>learning.spring.binarytea.dubbo</code> 包中。为了避免发布服务过程中可能出现的各种问题，例如序列化、枚举变更等，我们重新定义了一个 <code>MenuItem</code> 类。</p>\n<blockquote>\n<p><strong>代码示例 16-1</strong>　菜单 Dubbo 接口的定义</p>\n</blockquote>\n<pre class=\"code-rows\"><code>public interface MenuService {\n    List&lt;MenuItem&gt; getAllMenu();\n}\n\n@Getter\n@Setter\npublic class MenuItem implements Serializable {\n    private static final long serialVersionUID = 1L;\n\n    private Long id;\n    private String name;\n    private String size;\n    private Long price;\n    private Date createTime;\n    private Date updateTime;\n}</code></pre>\n<p>此处需要注意两点。首先，实现功能时引用了之前的 <code>MenuService</code>，因为存在同名的情况，所以这里需要写全限定名。其次，返回的对象还需要做一下转换，方便起见，这里使用了 Spring 提供的 <code>BeanUtils.copyProperties()</code> 方法进行两个 POJO 对象的属性复制，如代码示例 16-2 所示。</p>\n<blockquote>\n<p><strong>代码示例 16-2</strong>　菜单 Dubbo 接口的实现</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@DubboService\npublic class MenuServiceDubboImpl implements MenuService {\n    @Autowired\n    private learning.spring.binarytea.service.MenuService menuService;\n\n    @Override\n    public List&lt;MenuItem&gt; getAllMenu() {\n        return menuService.getAllMenu().stream().map(i -&gt; convert(i)).collect(Collectors.toList());\n    }\n\n    private MenuItem convert(learning.spring.binarytea.model.MenuItem origin) {\n        MenuItem item = new MenuItem();\n        BeanUtils.copyProperties(origin, item);\n        item.setSize(origin.getSize().name());\n        item.setPrice(origin.getPrice().getAmountMinorLong());\n        return item;\n    }\n}</code></pre>\n<p>实现类上的 <code>@DubboService</code> 注解会告诉 Dubbo，这个类要被注册为 Spring Bean，同时作为 Dubbo 服务发布。注解上可以做很多配置，关于配置相关的内容稍后会详细介绍，这里先用默认值。自动配置已经替我们完成了大部分配置工作，剩下的就是在 <code>application.properties</code> 里做些必要的设置，如代码示例 16-3 所示。</p>\n<blockquote>\n<p><strong>代码示例 16-3</strong>　Spring Boot 项目中的 Dubbo 配置</p>\n</blockquote>\n<pre class=\"code-rows\"><code>dubbo.protocol.name=dubbo\ndubbo.protocol.port=12345\ndubbo.scan.base-packages=learning.spring.binarytea.dubbo\ndubbo.registry.address=nacos://localhost:8848</code></pre>\n<p>我们来解读一下上面的配置：</p>\n<ul>\n<li>设置了使用 Dubbo 协议，服务发布在 <code>12345</code> 端口上；</li>\n<li>要扫描 <code>learning.spring.binarytea.dubbo</code> 包中的各种 Dubbo 注解；</li>\n<li>注册中心方面，配置的地址是 <code>nacos://localhost:8848</code>，也就是使用 Nacos 作为注册中心，地址是 <code>locahost:8848</code>。</li>\n</ul>\n<p>由于使用了 Nacos，在 pom.xml 中还需要增加如下依赖：</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;\n    &lt;artifactId&gt;dubbo-registry-nacos&lt;/artifactId&gt;\n    &lt;version&gt;$&lt;/version&gt;\n&lt;/dependency&gt;</code></pre>\n<p>在 Nacos 的平台上，我们可以在服务列表页面上看到服务名为 <code>providers:learning.spring.binarytea.dubbo.MenuService::</code> 的服务，大致如图 16-2 所示。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00799.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 16-2　注册到 Nacos 上的 Dubbo 服务</strong></p>\n<blockquote>\n<p><strong>茶歇时间：多个 <code>copyProperties()</code> 该如何选择</strong></p>\n<p>在操作 POJO 对象时，我们经常要做类型转换，每次都手动取值再赋值的话，代码未免显得有些难看。因此，对于同名属性可以直接进行属性值的复制，非常省事。但 Apache Commons 的 <code>PropertyUtils.copyProperties()</code> 和 Spring 的 <code>BeanUtils.copyProperties()</code> 该用哪个呢？</p>\n<p>从功能上看，两者的作用差不多，但性能上就不太一样了，<code>PropertyUtils.copyProperties()</code> 的速度要比 Spring 的 <code>BeanUtils.copyProperties()</code> 的慢很多，两者都不在一个数量级上。仔细分析两者的代码，虽然都是用反射在两个对象中寻找属性，但后者用了如下的方法：</p>\n<pre class=\"code-rows\"><code>public static PropertyDescriptor[] getPropertyDescriptors(Class&lt;?&gt; clazz) throws BeansException {\n    return CachedIntrospectionResults.forClass(clazz).getPropertyDescriptors();\n}</code></pre>\n<p>从类名就能猜到，<code>CachedIntrospectionResults</code> 会缓存执行的结果，运行过一次就能把反射的信息缓存下来，后续重复对同一个类型执行操作时就能极大地提升性能。<code>PropertyUtils</code> 没有这个缓存，每次都是从头开始，自然性能很差。</p>\n<p>所以，如果再有需要复制属性的情况，请选择 Spring 提供的 <code>BeanUtils.copyProperties()</code> 方法。</p>\n</blockquote>\n<p>上面我们使用了自动配置加注解的方式来发布服务，Dubbo 也可以在 Spring XML 文件中进行配置，去掉 <code>MenuServiceDubboImpl</code> 上的 <code>@DubboService</code> 注解。具体方法是在 resources 里新增一个 spring 目录，然后在目录中放一个 dubbo-applicationContext.xml 配置文件，如代码示例 16-4 所示。Dubbo 的配置都在 <code>&lt;dubbo:/&gt;</code> 标签中：<code>&lt;dubbo:application/&gt;</code> 配置应用信息，例如应用名；<code>&lt;dubbo:registry/&gt;</code> 配置服务注册中心信息；<code>&lt;dubbo:protocol/&gt;</code> 配置服务协议，发布服务的端口；<code>&lt;dubbo:service/&gt;</code> 用来发布服务，<code>interface</code> 属性配置接口，<code>ref</code> 配置对应实现 Bean 的 ID；<code>&lt;dubbo:reference/&gt;</code> 用来引用服务，<code>id</code> 属性是生成的本地代理 Bean 的 ID，<code>interface</code> 属性配置要引用的服务接口。</p>\n<blockquote>\n<p><strong>代码示例 16-4</strong>　服务提供者的 XML 配置</p>\n</blockquote>\n<pre class=\"code-rows\"><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:dubbo=\"http://dubbo.apache.org/schema/dubbo\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       https://www.springframework.org/schema/beans/spring-beans.xsd\n       http://dubbo.apache.org/schema/dubbo\n       http://dubbo.apache.org/schema/dubbo/dubbo.xsd\"&gt;\n    &lt;!-- 如下配置也可放在application.properties中 --&gt;\n    &lt;!--\n        &lt;dubbo:application name=\"binarytea\" /&gt;\n        &lt;dubbo:registry address=\"nacos://localhost:8848\" /&gt;\n        &lt;dubbo:protocol name=\"dubbo\" port=\"12345\" /&gt;\n    --&gt;\n    &lt;!-- 声明需要暴露的服务接口 --&gt;\n    &lt;dubbo:service interface=\"learning.spring.binarytea.dubbo.MenuService\" ref=\"menuServiceDubboImpl\" /&gt;\n\n&lt;/beans&gt;</code></pre>\n<p>在 <code>BinaryTeaApplication</code> 上增加 <code>@ImportResource</code> 注解导入上述 XML 文件：</p>\n<pre class=\"code-rows\"><code>@SpringBootApplication\n@EnableCaching\n@EnableScheduling\n@ImportResource(\"classpath:/spring/*-applicationContext.xml\")\npublic class BinaryTeaApplication implements WebMvcConfigurer {...}</code></pre>\n<p>服务发布后，再简单修改下 Customer 工程，与之前一样，引入 Dubbo 和 Nacos 的依赖，在 <code>application.properties</code> 中配置好 Dubbo 的 Nacos 信息。Dubbo 是通过接口来发布和引用服务的，所以在实际生产中，我们通常会把服务提供者的接口和其他相关的类打在一个 Facade Jar 包中，服务消费者引入这个 Jar 包，直接使用其中的内容。在这里，我们为了演示方便，直接在 Customer 工程中创建一套与 BinaryTea 一模一样的 <code>learning.spring.binarytea.dubbo.MenuService</code> 接口。随后，编写一个调用 Dubbo 服务的 <code>DubboMenuRunner</code>，用 <code>@DubboReference</code> 注解引用 Dubbo 服务，如代码示例 16-5 所示。</p>\n<blockquote>\n<p><strong>代码示例 16-5</strong>　Dubbo 服务的消费者</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Component\n@Slf4j\n@Order(3)\npublic class DubboMenuRunner implements ApplicationRunner {\n    @DubboReference\n    private MenuService menuService;\n\n    @Override\n    public void run(ApplicationArguments args) throws Exception {\n        List&lt;MenuItem&gt; items = menuService.getAllMenu();\n        log.info(\"通过Dubbo接口获得了{}个菜单项\", items.size());\n    }\n}</code></pre>\n<p>同样的，如果不想用注解，也可以在 XML 文件中引入服务，然后用 ID 来使用这个 Bean 就可以了。</p>\n<pre class=\"code-rows\"><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:dubbo=\"http://dubbo.apache.org/schema/dubbo\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       https://www.springframework.org/schema/beans/spring-beans.xsd\n       http://dubbo.apache.org/schema/dubbo\n       http://dubbo.apache.org/schema/dubbo/dubbo.xsd\"&gt;\n\n    &lt;!-- 引用需要的服务接口 --&gt;\n    &lt;dubbo:reference id=\"menuService\" interface=\"learning.spring.binarytea.dubbo.MenuService\" /&gt;\n&lt;/beans&gt;</code></pre>\n<blockquote>\n<p><strong>茶歇时间：为什么对外的接口里不要用枚举</strong></p>\n<p>细心的朋友应该已经发现了，在前文 Dubbo 的例子中，我们故意将 <code>MenuItem</code> 里的 Size 枚举换成了 <code>String</code>，这是为什么呢？</p>\n<p>试想这样一个场景，Dubbo 接口方法的返回值中包含一个 <code>Size</code> 枚举，服务提供者有一天在枚举中增加了一个 <code>XLarge</code>，服务消费者的枚举却没有更新，在返回新增枚举值的情况下，消费者一端必然报错。Dubbo 服务的提供者通常都会给消费者提供一个 Jar 包，其中包含了服务接口和各种相关的内容。假设提供者要升级新版本，如果改动了接口中的枚举，就必须通知所有消费者评估是否需要升级 Jar 包—要升级的话，消费者就要被迫一起进行升级，对于一个被广泛使用的服务而言，消费者很多，发布一次可谓伤筋动骨。</p>\n<p>为了避免这种反序列化可能带来的问题，建议尽可能避免在接口中使用枚举类型，可以用整型、字符串等类型来代替枚举。如果有强校验逻辑，可以在内部处理时，将这些值再转换为内部枚举。对于无法识别的值编写一段默认逻辑，例如打印日志或者报警。这样一来，就可以避免很多不必要的变更和风险。</p>\n</blockquote>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>支持的注册中心</strong></p>\n<p>Dubbo 支持多种不同的服务注册中心，表 16-1 罗列了官方文档中出现的几种注册中心。</p>\n<p><strong>表 16-1　Dubbo 支持的部分注册中心</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>注册中心</th><th>配置前缀</th><th>依赖</th><th>说明</th></tr><tr><td>Zookeeper</td><td><code>zookeeper://</code></td><td>curator-recipes</td><td>自 2.7.<i>x</i> 版本起不再支持 zkclient，仅支持 Curator 客户端 <sup><b>4</b></sup></td></tr><tr><td>Nacos</td><td><code>nacos://</code></td><td>dubbo-registry-nacos</td><td></td></tr><tr><td>Redis</td><td><code>redis://</code></td><td>jedis</td><td>使用了 Redis 的 Pub/Sub 机制实现了服务变更的通知</td></tr><tr><td>Multicast</td><td><code>multicast://</code></td><td></td><td>不用注册中心，通过广播进行服务发现，仅用于很小规模的应用或者开发测试阶段</td></tr><tr><td>Simple</td><td></td><td></td><td>注册中心 <code>SimpleRegistryService</code> 本身就是个 Dubbo 服务，仅用于演示，不可用于生产</td></tr></table>\n\n<blockquote>\n<p><sup><b>4</b></sup>Curator 的不同版本之间的兼容性不是特别好，如果同时还是用 Spring Cloud Zookeeper，那 Dubbo 用的版本和它可能就不一样。正因为这样，在 16.1 节的例子中我们都用 Nacos 来做服务注册和配置管理。</p>\n</blockquote>\n<p>除此之外，Dubbo 的新版本还支持 Consul、Etcd 和 Eureka 等其他注册中心。在实际生产中，Zookeeper 和 Nacos 可能是使用较为广泛的。<span class=\"comment-number\">5</span> 无论使用哪种注册中心，都建议用集群方式进行部署，避免因注册中心宕机影响线上服务。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>部分常用配置</strong></p>\n<p>本节只是演示了 Dubbo 的最基本用法，其实 Dubbo 为开发者预留了大量配置，几乎每个地方都能按需调整；再加上强大的 SPI 机制，可以方便地进行各种扩展，可谓“只有想不到，没有做不到”。这一部分我们会挑选其中的一些配置进行介绍。</p>\n<p>在介绍各种具体配置前，先来了解下 Dubbo 配置的几种方式：</p>\n<ul>\n<li>XML，这是最传统也是功能最完整的配置方法，通过 <code>&lt;dubbo:/&gt;</code> 标签完成各种配置，下文也会以这种方式为主来进行说明；</li>\n<li>属性文件，系统会自动加载 CLASSPATH 根目录里的 <code>dubbo.properties</code>，也可以使用 <code>-Ddubbo.properties.file=xxx.properties</code> 的方式指定 <span class=\"comment-number\">6</span>；</li>\n<li>Java 系统参数，直接在启动的 <code>-D</code> 参数中配置 Dubbo 属性，属性名与属性文件里用的一样；</li>\n<li>注解方式，在 <code>@DubboService</code> 和 <code>@DubboReference</code> 注解上进行配置，这两个注解上有大量的属性可以调整；</li>\n<li>API 方式，通过 <code>ApplicationConfig</code>、<code>RegistryConfig</code>、<code>ProviderConfig</code>、<code>ServiceConfig</code> 等配置类用代码来完成配置。</li>\n</ul>\n<p>关于属性文件，还要再做些补充说明，文件类型是 Properties 格式，根据配置项的不同，键的格式也会有所差异：</p>\n<ul>\n<li>应用配置，<code>dubbo.{ 配置类型 }[. 配置 ID].{ 配置项 }= 值</code>，例如 <code>dubbo.application.name=binarytea</code>；</li>\n<li>服务生产者配置，<code>dubbo.service.{ 接口名 }[.{ 方法名 }].{ 配置项 }= 值</code>；</li>\n<li><p>服务消费者配置，<code>dubbo.reference.{ 接口名 }[.{ 方法名 }].{ 配置项 }= 值</code>。</p>\n</li>\n<li><p><strong>服务依赖检查</strong></p>\n<p>在服务启动时，Dubbo 可以检查引用的服务是否存在，如果找不到则会报错，阻止系统启动，这样可以尽早发现问题，以免影响生产服务。但这种校验也会带来一些问题，例如非必要的启动依赖。可以通过如下方式关闭检查：</p>\n<pre class=\"code-rows\"><code>&lt;!-- 关闭单个服务的检查 --&gt;\n&lt;dubbo:reference id=\"menuService\" interface=\"learning.spring.binarytea.dubbo.MenuService\" check=\"false\" /&gt;\n&lt;!-- 关闭所有服务的检查 --&gt;\n&lt;dubbo:consumer check=\"false\" /&gt;\n&lt;!-- 关闭注册中心的检查 --&gt;\n&lt;dubbo:registry check=\"false\" /&gt;</code></pre>\n<p>如果用的是配置文件或者 <code>-D</code> 参数，则是这样的，其中 <code>dubbo.reference.check</code> 是强制改变所有消费者的配置，而 <code>dubbo.consumer.check</code> 只是改变默认配置：</p>\n<pre class=\"code-rows\"><code>dubbo.reference.learning.spring.binarytea.dubbo.MenuService.check=false\ndubbo.reference.check=false\ndubbo.consumer.check=false\ndubbo.registry.check=false</code></pre>\n<p>正常情况下，我们都会希望在系统完整启动且经过“预热”后才发布服务，这样可以保证提供的服务是可用的，而且首次调用耗时不会很长。在 Dubbo 2.6.5 版本之后，Dubbo 的默认行为就是在监听到 <code>ContextRefreshedEvent</code> 事件后，也就是 Spring 容器启动成功后才发布服务。如果我们希望在容器启动成功后再等待一段时间对外注册自己的服务，则可以进行如下的配置，其中的单位是毫秒：</p>\n<pre class=\"code-rows\"><code>&lt;dubbo:service delay=\"5000\" /&gt;</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>服务分组</strong></p>\n<p>有些情况下，相同的接口会根据需要提供不同的服务，设想下面两种场景：</p>\n<ul>\n<li class=\"第3级无序列表\">根据系统配置不同，一个查询生产库，另一个查询历史归档库；</li>\n<li class=\"第3级无序列表\">根据调用方的重要级别，一个专门服务主链路，保证高可用，另一个专门提供后台系统查询，偶尔可以不可用。</li>\n</ul>\n<p>因为服务的接口是一样的，该如何进行区分呢？这时就要用到服务分组功能，可以使用 <code>group</code> 属性来定义所需的分组：</p>\n<pre class=\"code-rows\"><code>&lt;dubbo:service group=\"prod\" interface=\"learning.spring.binarytea.dubbo.MenuService\" /&gt;\n&lt;dubbo:service group=\"history\" interface=\"learning.spring.binarytea.dubbo.MenuService\" /&gt;\n\n&lt;dubbo:reference id=\"prodMenuService\" group=\"prod\" interface=\"learning.spring.binarytea.dubbo.MenuService\" /&gt;\n&lt;dubbo:reference id=\"historyMenuService\" group=\"history\" interface=\"learning.spring.binarytea.dubbo.MenuService\" /&gt;</code></pre>\n<p>在 <code>@DubboService</code> 和 <code>@DubboReference</code> 注解中也有 <code>group</code> 属性，如果用注解方式，也可以在那里配置。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>负载均衡</strong></p>\n<p>Dubbo 的服务负载均衡使用的是去中心化的方式，由发起调用的一方决定调用的目标。Dubbo 提供了几种负载均衡策略，具体如表 16-2 所示，策略缩写都定义在了 <code>LoadbalanceRules</code> 里。</p>\n<p><strong>表 16-2　Dubbo 提供的负载均衡策略</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>策略</th><th>实现类</th><th>配置缩写</th><th>说明</th></tr><tr><td>随机</td><td><code>RandomLoadBalance</code></td><td><code>random</code></td><td>根据权重随机访问，每个服务提供者可以配置不同的权重，这也是默认策略</td></tr><tr><td>轮询</td><td><code>RoundRobinLoadBalance</code></td><td><code>roundrobin</code></td><td>轮询每个服务提供者进行调用</td></tr><tr><td>最少活跃调用数</td><td><code>LeastActiveLoadBalance</code></td><td><code>leastactive</code></td><td>活跃调用是指当前正在进行、还未结束的调用，调用开始时加 1，结束后减 1，因此在大概率上处理越快的提供者活跃调用数越小，被选中的概率越高</td></tr><tr><td>最短响应时间</td><td><code>ShortestResponseLoadBalance</code></td><td><code>shortestresponse</code></td><td>选成功响应且响应时间短的提供者</td></tr><tr><td>一致性散列</td><td><code>ConsistentHashLoadBalance</code></td><td><code>consistenthash</code></td><td>使用一致性散列算法，根据参数选择服务提供者，用 <code>hash.arguments</code> 来选择参数，用 <code>hash.nodes</code> 来设置虚拟节点数</td></tr></table>\n\n<p>负载均衡策略可以配置在服务提供者一端，也可以配置在服务的消费者上，具体方法如下：</p>\n<pre class=\"code-rows\"><code>&lt;!-- 整个服务使用同一种策略--&gt;\n&lt;dubbo:service interface=\"...\" loadbalance=\"roundrobin\" /&gt;\n&lt;!-- 服务中的某个方法单独使用一种策略--&gt;\n&lt;dubbo:service interface=\"...\"&gt;\n    &lt;dubbo:method name=\"...\" loadbalance=\"roundrobin\"/&gt;\n&lt;/dubbo:service&gt;\n\n&lt;!-- 服务消费者使用同一种策略 --&gt;\n&lt;dubbo:reference interface=\"...\" loadbalance=\"roundrobin\" /&gt;\n&lt;!-- 消费者端的某个方法单独使用一种策略 --&gt;\n&lt;dubbo:reference interface=\"...\"&gt;\n    &lt;dubbo:method name=\"...\" loadbalance=\"roundrobin\"/&gt;\n&lt;/dubbo:reference&gt;</code></pre>\n<p><code>@DubboService</code> 和 <code>@DubboReference</code> 里都有 <code>loadbalance</code> 属性，可以配置接口级的负载均衡策略，<code>@Method</code> 注解的 <code>loadbalance</code> 可以配置方法级的策略。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>超时与重试</strong></p>\n<p>消费者发起调用后，为了保证稳定性，一定会在调用时控制超时和重试策略。超时方面，既可以在提供者的接口和方法上配置，也可以做默认配置，在服务的消费者一端也是一样的，超时的参数都是 <code>timeout</code>，单位是毫秒。从优先级上来看，方法上的配置优先级最高，其次是接口，最后是全局默认配置；消费者一端的配置优先级要高于提供者。通常建议在服务的提供者这边配置超时，因为提供者会更加了解自己的服务，而且服务的消费者默认就能用到服务者配置的超时，有特殊需要可以再覆盖配置。重试配置用的是 <code>retries</code> 属性，默认会重试 2 次，<code>0</code> 代表不重试。大概的配置方式会是下面这样的：</p>\n<pre class=\"code-rows\"><code>&lt;!-- 服务使用同一个超时和重试设置 --&gt;\n&lt;dubbo:service interface=\"...\" timeout=\"5000\" retries=\"0\" /&gt;\n&lt;!-- 修改整个提供者端的默认配置 --&gt;\n&lt;dubbo:provider timeout=\"5000\" retries=\"0\" /&gt;\n\n&lt;!-- 消费者使用同一个超时和重试设置 --&gt;\n&lt;dubbo:reference interface=\"...\" timeout=\"5000\" retries=\"0\" /&gt;\n&lt;!-- 修改整个消费者端的默认配置 --&gt;\n&lt;dubbo:consumer timeout=\"5000\" retries=\"0\" /&gt;</code></pre>\n<p>此处就不再赘述方法级别的配置了。此外，几个 Dubbo 的注解上也都提供了 <code>timeout</code> 和 <code>retries</code> 属性用以配置。</p>\n</li>\n</ul>\n</li>\n</ol>\n\n\n\n\n","neighbors":{"left":{"article_title":"第 15 章 服务容错保护(2)","id":740892},"right":{"article_title":"第 16 章 服务集成(2)","id":740894}},"comments":[]}