{"id":110482,"title":"24 | 请求是怎么被处理的？","content":"<p>你好，我是胡夕。今天我要和你分享的主题是：Kafka请求是怎么被处理的。</p><p>无论是Kafka客户端还是Broker端，它们之间的交互都是通过“请求/响应”的方式完成的。比如，客户端会通过网络发送消息生产请求给Broker，而Broker处理完成后，会发送对应的响应给到客户端。</p><p>Apache Kafka自己定义了一组请求协议，用于实现各种各样的交互操作。比如常见的PRODUCE请求是用于生产消息的，FETCH请求是用于消费消息的，METADATA请求是用于请求Kafka集群元数据信息的。</p><p>总之，Kafka定义了很多类似的请求格式。我数了一下，截止到目前最新的2.3版本，Kafka共定义了多达45种请求格式。<strong>所有的请求都是通过TCP网络以Socket的方式进行通讯的</strong>。</p><p>今天，我们就来详细讨论一下Kafka Broker端处理请求的全流程。</p><h2>处理请求的2种常见方案</h2><p>关于如何处理请求，我们很容易想到的方案有两个。</p><p>1.<strong>顺序处理请求</strong>。如果写成伪代码，大概是这个样子：</p><pre><code>while (true) {\n            Request request = accept(connection);\n            handle(request);\n}\n</code></pre><p>这个方法实现简单，但是有个致命的缺陷，那就是<strong>吞吐量太差</strong>。由于只能顺序处理每个请求，因此，每个请求都必须等待前一个请求处理完毕才能得到处理。这种方式只适用于<strong>请求发送非常不频繁的系统</strong>。</p><!-- [[[read_end]]] --><p><strong>2.每个请求使用单独线程处理</strong>。也就是说，我们为每个入站请求都创建一个新的线程来异步处理。我们一起来看看这个方案的伪代码。</p><pre><code>while (true) {\n            Request = request = accept(connection);\n            Thread thread = new Thread(() -&gt; {\n\thandle(request);});\n            thread.start();\n}\n</code></pre><p>这个方法反其道而行之，完全采用<strong>异步</strong>的方式。系统会为每个入站请求都创建单独的线程来处理。这个方法的好处是，它是完全异步的，每个请求的处理都不会阻塞下一个请求。但缺陷也同样明显。为每个请求都创建线程的做法开销极大，在某些场景下甚至会压垮整个服务。还是那句话，这个方法只适用于请求发送频率很低的业务场景。</p><p>既然这两种方案都不好，那么，Kafka是如何处理请求的呢？用一句话概括就是，Kafka使用的是<strong>Reactor模式</strong>。</p><h2>Kafka是如何处理请求的？</h2><p>谈到Reactor模式，大神Doug Lea的“<a href=\"http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf\">Scalable IO in Java</a>”应该算是最好的入门教材了。即使你没听说过Doug Lea，那你应该也用过ConcurrentHashMap吧？这个类就是这位大神写的。其实，整个java.util.concurrent包都是他的杰作！</p><p>好了，我们说回Reactor模式。简单来说，<strong>Reactor模式是事件驱动架构的一种实现方式，特别适合应用于处理多个客户端并发向服务器端发送请求的场景</strong>。我借用Doug Lea的一页PPT来说明一下Reactor的架构，并借此引出Kafka的请求处理模型。</p><p>Reactor模式的架构如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/5b/3c/5bf8e3e8d35d1ac62yydb092700b683c.jpg?wh=3770*1801\" alt=\"\"></p><p>从这张图中，我们可以发现，多个客户端会发送请求给到Reactor。Reactor有个请求分发线程Dispatcher，也就是图中的Acceptor，它会将不同的请求下发到多个工作线程中处理。</p><p>在这个架构中，Acceptor线程只是用于请求分发，不涉及具体的逻辑处理，非常得轻量级，因此有很高的吞吐量表现。而这些工作线程可以根据实际业务处理需要任意增减，从而动态调节系统负载能力。</p><p>如果我们来为Kafka画一张类似的图的话，那它应该是这个样子的：</p><p><img src=\"https://static001.geekbang.org/resource/image/b3/81/b3yy7c6ca1c6244f3f9d2268209a9081.jpg?wh=3618*1716\" alt=\"\"></p><p>显然，这两张图长得差不多。Kafka的Broker端有个SocketServer组件，类似于Reactor模式中的Dispatcher，它也有对应的Acceptor线程和一个工作线程池，只不过在Kafka中，这个工作线程池有个专属的名字，叫网络线程池。Kafka提供了Broker端参数num.network.threads，用于调整该网络线程池的线程数。其<strong>默认值是3，表示每台Broker启动时会创建3个网络线程，专门处理客户端发送的请求</strong>。</p><p>Acceptor线程采用轮询的方式将入站请求公平地发到所有网络线程中，因此，在实际使用过程中，这些线程通常都有相同的几率被分配到待处理请求。这种轮询策略编写简单，同时也避免了请求处理的倾斜，有利于实现较为公平的请求处理调度。</p><p>好了，你现在了解了客户端发来的请求会被Broker端的Acceptor线程分发到任意一个网络线程中，由它们来进行处理。那么，当网络线程接收到请求后，它是怎么处理的呢？你可能会认为，它顺序处理不就好了吗？实际上，Kafka在这个环节又做了一层异步线程池的处理，我们一起来看一看下面这张图。</p><p><img src=\"https://static001.geekbang.org/resource/image/41/95/41e0a69ed649f9c5yyea390edcd79a95.jpg?wh=3537*2088\" alt=\"\"></p><p>当网络线程拿到请求后，它不是自己处理，而是将请求放入到一个共享请求队列中。Broker端还有个IO线程池，负责从该队列中取出请求，执行真正的处理。如果是PRODUCE生产请求，则将消息写入到底层的磁盘日志中；如果是FETCH请求，则从磁盘或页缓存中读取消息。</p><p>IO线程池处中的线程才是执行请求逻辑的线程。Broker端参数<strong>num.io.threads</strong>控制了这个线程池中的线程数。<strong>目前该参数默认值是8，表示每台Broker启动后自动创建8个IO线程处理请求</strong>。你可以根据实际硬件条件设置此线程池的个数。</p><p>比如，如果你的机器上CPU资源非常充裕，你完全可以调大该参数，允许更多的并发请求被同时处理。当IO线程处理完请求后，会将生成的响应发送到网络线程池的响应队列中，然后由对应的网络线程负责将Response返还给客户端。</p><p>细心的你一定发现了请求队列和响应队列的差别：<strong>请求队列是所有网络线程共享的，而响应队列则是每个网络线程专属的</strong>。这么设计的原因就在于，Dispatcher只是用于请求分发而不负责响应回传，因此只能让每个网络线程自己发送Response给客户端，所以这些Response也就没必要放在一个公共的地方。</p><p>我们再来看看刚刚的那张图，图中有一个叫Purgatory的组件，这是Kafka中著名的“炼狱”组件。它是用来<strong>缓存延时请求</strong>（Delayed Request）的。<strong>所谓延时请求，就是那些一时未满足条件不能立刻处理的请求</strong>。比如设置了acks=all的PRODUCE请求，一旦设置了acks=all，那么该请求就必须等待ISR中所有副本都接收了消息后才能返回，此时处理该请求的IO线程就必须等待其他Broker的写入结果。当请求不能立刻处理时，它就会暂存在Purgatory中。稍后一旦满足了完成条件，IO线程会继续处理该请求，并将Response放入对应网络线程的响应队列中。</p><p>讲到这里，Kafka请求流程解析的故事其实已经讲完了，我相信你应该已经了解了Kafka Broker是如何从头到尾处理请求的。但是我们不会现在就收尾，我要给今天的内容开个小灶，再说点不一样的东西。</p><h2>控制类请求和数据类请求分离</h2><p>到目前为止，我提及的请求处理流程对于所有请求都是适用的，也就是说，Kafka Broker对所有请求是一视同仁的。但是，在Kafka内部，除了客户端发送的PRODUCE请求和FETCH请求之外，还有很多执行其他操作的请求类型，比如负责更新Leader副本、Follower副本以及ISR集合的LeaderAndIsr请求，负责勒令副本下线的StopReplica请求等。与PRODUCE和FETCH请求相比，这些请求有个明显的不同：它们不是数据类的请求，而是控制类的请求。也就是说，它们并不是操作消息数据的，而是用来执行特定的Kafka内部动作的。</p><p>Kafka社区把PRODUCE和FETCH这类请求称为数据类请求，把LeaderAndIsr、StopReplica这类请求称为控制类请求。细究起来，当前这种一视同仁的处理方式对控制类请求是不合理的。为什么呢？因为<strong>控制类请求有这样一种能力：它可以直接令数据类请求失效！</strong></p><p>我来举个例子说明一下。假设我们有个主题只有1个分区，该分区配置了两个副本，其中Leader副本保存在Broker 0上，Follower副本保存在Broker 1上。假设Broker 0这台机器积压了很多的PRODUCE请求，此时你如果使用Kafka命令强制将该主题分区的Leader、Follower角色互换，那么Kafka内部的控制器组件（Controller）会发送LeaderAndIsr请求给Broker 0，显式地告诉它，当前它不再是Leader，而是Follower了，而Broker 1上的Follower副本因为被选为新的Leader，因此停止向Broker 0拉取消息。</p><p>这时，一个尴尬的场面就出现了：如果刚才积压的PRODUCE请求都设置了acks=all，那么这些在LeaderAndIsr发送之前的请求就都无法正常完成了。就像前面说的，它们会被暂存在Purgatory中不断重试，直到最终请求超时返回给客户端。</p><p>设想一下，如果Kafka能够优先处理LeaderAndIsr请求，Broker 0就会立刻抛出<strong>NOT_LEADER_FOR_PARTITION异常</strong>，快速地标识这些积压PRODUCE请求已失败，这样客户端不用等到Purgatory中的请求超时就能立刻感知，从而降低了请求的处理时间。即使acks不是all，积压的PRODUCE请求能够成功写入Leader副本的日志，但处理LeaderAndIsr之后，Broker 0上的Leader变为了Follower副本，也要执行显式的日志截断（Log Truncation，即原Leader副本成为Follower后，会将之前写入但未提交的消息全部删除），依然做了很多无用功。</p><p>再举一个例子，同样是在积压大量数据类请求的Broker上，当你删除主题的时候，Kafka控制器（我会在专栏后面的内容中专门介绍它）向该Broker发送StopReplica请求。如果该请求不能及时处理，主题删除操作会一直hang住，从而增加了删除主题的延时。</p><p>基于这些问题，社区于2.3版本正式实现了数据类请求和控制类请求的分离。其实，在社区推出方案之前，我自己尝试过修改这个设计。当时我的想法是，在Broker中实现一个优先级队列，并赋予控制类请求更高的优先级。这是很自然的想法，所以我本以为社区也会这么实现的，但后来我这个方案被清晰地记录在“已拒绝方案”列表中。</p><p>究其原因，这个方案最大的问题在于，它无法处理请求队列已满的情形。当请求队列已经无法容纳任何新的请求时，纵然有优先级之分，它也无法处理新的控制类请求了。</p><p>那么，社区是如何解决的呢？很简单，你可以再看一遍今天的第三张图，社区完全拷贝了这张图中的一套组件，实现了两类请求的分离。也就是说，Kafka Broker启动后，会在后台分别创建两套网络线程池和IO线程池的组合，它们分别处理数据类请求和控制类请求。至于所用的Socket端口，自然是使用不同的端口了，你需要提供不同的<strong>listeners配置</strong>，显式地指定哪套端口用于处理哪类请求。</p><h2>小结</h2><p>讲到这里，Kafka Broker请求处理流程的解析应该讲得比较完整了。明确请求处理过程的最大意义在于，它是你日后执行Kafka性能优化的前提条件。如果你能从请求的维度去思考Kafka的工作原理，你会发现，优化Kafka并不是一件困难的事情。</p><h2>开放讨论</h2><p>坦白来讲，我对社区否定优先级队列方案是有一点不甘心的。如果是你的话，你觉得应该如何规避优先级队列方案中队列已满的问题呢？</p><p>欢迎写下你的思考和答案，我们一起讨论。如果你觉得有所收获，也欢迎把文章分享给你的朋友。</p>","neighbors":{"left":{"article_title":"23 | Kafka副本机制详解","id":110388},"right":{"article_title":"25 | 消费者组重平衡全流程解析","id":111226}},"comments":[{"had_liked":false,"id":146868,"user_name":"朱东旭","can_delete":false,"product_type":"c1","uid":1242338,"ip_address":"","ucode":"C48DD620A63868","user_header":"https://static001.geekbang.org/account/avatar/00/12/f4/e2/dbc4a5f2.jpg","comment_is_top":false,"comment_ctime":1572681633,"is_pvip":false,"replies":[{"id":"56829","content":"不是一个层级的东西。epoll是一种IO模型，而Reactor是一种IO处理模式（IO pattern）。可以这么说：我们可以使用epoll来实现Reactor","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1572832089,"ip_address":"","comment_id":146868,"utype":1}],"discussion_count":5,"race_medal":0,"score":"194846209953","product_id":100029201,"comment_content":"胡老师您好，为什么有时候听到epoll，有时候听到reactor,这俩有啥区别。。","like_count":46,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473039,"discussion_content":"不是一个层级的东西。epoll是一种IO模型，而Reactor是一种IO处理模式（IO pattern）。可以这么说：我们可以使用epoll来实现Reactor","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572832089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1655117,"avatar":"https://static001.geekbang.org/account/avatar/00/19/41/4d/f6d6d13a.jpg","nickname":"啊良梓是我","note":"","ucode":"E42FC1A60D331C","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389510,"discussion_content":"Reactor 里面的Selector 使用 的Epoll实现，这样子理解不知道行不行","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1629298036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1736462,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/7f/0e/e3a8dbd9.jpg","nickname":"Liujun","note":"","ucode":"3DB1F3CA57B5B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1655117,"avatar":"https://static001.geekbang.org/account/avatar/00/19/41/4d/f6d6d13a.jpg","nickname":"啊良梓是我","note":"","ucode":"E42FC1A60D331C","race_medal":1,"user_type":1,"is_pvip":true},"discussion":{"id":390459,"discussion_content":"对的，前提是Linux系统","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629854142,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":389510,"ip_address":""},"score":390459,"extra":""}]},{"author":{"id":1827961,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/e4/79/0f0114ba.jpg","nickname":"taochao_zs","note":"","ucode":"77382AB0B3CC0E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555359,"discussion_content":"确实不一样，epoll是系统调用上的IO多路复用（物理实现），reactor是应用层的io/网络模型设计（逻辑），按网络分层架构来说，reactor是应用层，epoll是系统/网络层。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1646881765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1508990,"avatar":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","nickname":"西门吹牛","note":"","ucode":"E5D3624DDE1E83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371386,"discussion_content":"Reactor 其实是一种多线程处理模型，类似线程池，epoll是计算机层面的IO处理模型，Reactor是你写的程序方面的，处理 epoll 拉取过来的数据。这块看下Netty 能更好的理解","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1619752001,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118136,"user_name":"明翼","can_delete":false,"product_type":"c1","uid":1068361,"ip_address":"","ucode":"E77F86BEB3D5C1","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/49/28e73b9c.jpg","comment_is_top":false,"comment_ctime":1564278572,"is_pvip":false,"replies":[{"id":"43351","content":"我觉得不错：）<br><br>","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1564361691,"ip_address":"","comment_id":118136,"utype":1}],"discussion_count":1,"race_medal":0,"score":"113233428268","product_id":100029201,"comment_content":"有两种方法：1 是直接替换数据处理队列中的最前面的数据进行处理，处理完控制队列，再将这个消息插队到队头；2 双队列设计，不过双队列，如果先处理控制消息，如果一直来控制消息，数据队列的消息岂不会被延迟很大；<br><br>关于复制一套，我看了下面评论，我和部分网友的理解不一样，我觉得是复制一套网络线程持+中间队列+IO线程池；也就是有两个网络线程池，+2个中间队列，和2套IO线程持；<br><br>网络线程池作用将数据分发到中间队列，和接受IO线程池的处理结果回复给客户端。我理解为什么要加这个中间队列是为了将网络处理的线程数和IO处理的线程数解耦，达到高性能和资源少占用的目的。","like_count":27,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460278,"discussion_content":"我觉得不错：）\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564361691,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":149078,"user_name":"注定非凡","can_delete":false,"product_type":"c1","uid":1113597,"ip_address":"","ucode":"80673056E131B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","comment_is_top":false,"comment_ctime":1573137235,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"70292613971","product_id":100029201,"comment_content":"1 Apache Kafka 自己定义了组请求协议，用于实现各种交互操作。常见有：<br>\ta. PRODUCE 请求用于生产消息<br>\tb. FETCH请求是用于消费消息<br>\tc. METADATA请求是用于请求Kafka集群元数据信息。<br>\t<br>\tKafka定义了很多类似的请求格式，所有的请求都是通过TCP网络以Socket的方式进行通讯的。<br><br>2 KaKfa Broker端处理请求的全流程<br>\tA ：常用请求处理方案<br>\t\ta：顺序处理请求<br>\t\t实现方法简答，但吞吐量太差是致命缺陷。因为是顺序处理，每个请求都必须等待前一个请求处理完毕才能得到处理。这只适用于请求发送非常不频繁的系统。<br>\t\tb：每个请求使用单独线程处理<br>\t\t它是完全异步的，每个请求的处理都创建单独线程处理，但缺陷明显，为每个请求都创建线程开销极大，某些场景甚至会压垮整个服务。<br><br>\tB ：Kafka的方案：使用Reactor模式<br>\t\ta：Reactor模式是JUC包作者的作品<br>\t\tb：Reactor模式是事件驱动架构的一种实现方式，特别适应用于处理多个客户端并发向服务端发送请求的场景。<br>\t<br>3 Kafka的请求处理方式<br>\tA ：Reactor模式中，多个客户端发送请求到Reactor。Reactor有个请求分发线程Dispatcher，它会将不同的请求下发到多个工作线程中处理。<br>\t\tAcceptor线程只用于请求分发，不涉及具体逻辑处理，因此有很高的吞吐量。而工作线程可以根据实际业务处理需要任意增减，从而动态调节系统负载能力。<br>\t<br>\tB ：kakfa中，Broker端有个SocketServer组件，类似于Reactor模式中的Dispatcher，他也有对应的Acceptor线程和一个工作线程池，在kafka中，被称为网络线程池。<br>\t\tBroker端参数num.network.threads，用于调整该网络线程池的线程数，默认为4，表示每台Broker启动时，会创建3个网络线程，专门处理客户端发送的请求。<br><br>\tC ：Acceptor线程采用轮询的方式将入站请求公平的发送到所有网络线程中。<br><br>\tD ：当网络线程接收到请求后，Kafka在这个环节又做了一层异步线程池的处理。<br>\t\t（1）当网络线程拿到请求后，她不是自己处理，而是将请求放入到一个共享请求队列中。<br>\t\t（2）Broker端还有个IO线程池，负责从该队列中取出请求，执行真正的处理。如果是PRODUCE生产请求，则将消息写入到底层的磁盘日志中；如果是FETCH请求，则从磁盘或页缓存中读取消息。<br><br>\tE ：IO线程池中的线程是执行请求逻辑的线程。Broker端参数num.io.threads控制了这个线程数，默认为8，表示每台Broker启动后自动创建8个IO线程处理请求。<br>\t<br>\tF ：请求队列是所有网络线程共享的，而响应队列则是每个网络线程专属的。原因在于Dispatcher只是用于请求分发而不负责响应回传，因此只能让每个网络线程自己发送Repsone给客户端，所有这些Response没必要放在一个公共的地方。<br>\t<br>\tG ：Purgatory组件，专门用来缓存延时请求（Delayed Requset）。如设置了acks=all的PRODUCE请求，该请求要必须等待ISR中所有副本都接收了消息后才能返回，此时处理该请求的IO线程就必须瞪大其他Broker的写入结果。当请求不能立即处理时，他就会暂存在Purgatory中。待满足了完成条件，IO线程会继续处理该请求，并将Response放入到对应的网络线程的响应队列中<br><br>4 Kafka对请求的处理特点<br>\tA ：Kafka Broker对所有的请求都是一视同仁的。<br>\tB ：这些请求根据功能，可分为不同的请求类型。从业务的权重角度来讲，是有高低之分的，如控制类请求可以影响数据类请求。<br>\tC ：无原则的平等，会造成混乱<br><br>\t社区采取的方案是，同时创建两套完全样的组件，实现两类请求的分离。<br>","like_count":17,"discussions":[{"author":{"id":2739957,"avatar":"","nickname":"Geek_39299b","note":"","ucode":"908C2FC4DECD33","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389577,"discussion_content":"非凡哥厉害","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629345640,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128976,"user_name":"蛋炒番茄","can_delete":false,"product_type":"c1","uid":1095049,"ip_address":"","ucode":"3F963347C4A97C","user_header":"https://static001.geekbang.org/account/avatar/00/10/b5/89/9a1b4dee.jpg","comment_is_top":false,"comment_ctime":1566998926,"is_pvip":false,"replies":[{"id":"48031","content":"原因就是没必要放在一起，让各自线程自己发送就可以了。类似于：有了任务大家一起分，做完了自己单独汇报就行了","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1567040840,"ip_address":"","comment_id":128976,"utype":1}],"discussion_count":8,"race_medal":0,"score":"57401573774","product_id":100029201,"comment_content":"请求队列是所有网络线程共享的，而响应队列则是每个网络线程专属。为什么这样设计，原因没看懂。希望老师讲详细一点","like_count":13,"discussions":[{"author":{"id":1009000,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/65/68/93c05ab0.jpg","nickname":"laugh","note":"","ucode":"1CB29054325D1D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282234,"discussion_content":"还有线程安全的原因吧。对比一下netty的eventloop","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1591926394,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465203,"discussion_content":"原因就是没必要放在一起，让各自线程自己发送就可以了。类似于：有了任务大家一起分，做完了自己单独汇报就行了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567040840,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578439,"discussion_content":"设计目的与计算机总线类似：cpu内部宏观上有两类总线，1. 数据总线 2.控制总线。同样的数据从数据总线传过来就是参数 从指令总线传过来就是操作码 诸如add等","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656749524,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2809887,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/e0/1f/de322ce3.jpg","nickname":"Harley","note":"","ucode":"F92472893F2156","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":566167,"discussion_content":"同时避免了多个io线程消费同一个消息？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650617910,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532704,"discussion_content":"响应实际上与socket有关 与某个线程无关。任何一个线程将响应准备好 找到那个socket即可给客户端响应","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637670631,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2739957,"avatar":"","nickname":"Geek_39299b","note":"","ucode":"908C2FC4DECD33","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389578,"discussion_content":"为了减少上下文切换?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629345688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1905357,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/12/cd/55e25527.jpg","nickname":"咕咕噜噜","note":"","ucode":"E9045BF11FAB7C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":272306,"discussion_content":"我也没看明白原因。每个网络线程单独一个响应队列，那还得让IO线程选择进入哪个响应队列。不明白这么做的原因，利弊有哪些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590285124,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1736462,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/7f/0e/e3a8dbd9.jpg","nickname":"Liujun","note":"","ucode":"3DB1F3CA57B5B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1905357,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/12/cd/55e25527.jpg","nickname":"咕咕噜噜","note":"","ucode":"E9045BF11FAB7C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390460,"discussion_content":"IO线程池选择啥啊，它就是在网络线程池中被调用的，结果就放到哪个响应队列","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629854413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":272306,"ip_address":""},"score":390460,"extra":""}]}]},{"had_liked":false,"id":158202,"user_name":"拾光","can_delete":false,"product_type":"c1","uid":1647343,"ip_address":"","ucode":"0A4B13605E66FA","user_header":"https://static001.geekbang.org/account/avatar/00/19/22/ef/d081613a.jpg","comment_is_top":false,"comment_ctime":1575347382,"is_pvip":false,"replies":[{"id":"60678","content":"我认为就是单纯地想要在做一层生产者-消费者分离","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1575423703,"ip_address":"","comment_id":158202,"utype":1}],"discussion_count":10,"race_medal":0,"score":"53114954934","product_id":100029201,"comment_content":"为什么不直接将Acceptor线程收到的请求存入共享队列，而要引入网络线程池来存？","like_count":12,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476668,"discussion_content":"我认为就是单纯地想要在做一层生产者-消费者分离","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575423703,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1590953,"avatar":"https://static001.geekbang.org/account/avatar/00/18/46/a9/70fa676f.jpg","nickname":"Luke","note":"","ucode":"2C8A1FAB8B6301","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320190,"discussion_content":"由acceptor直接将请放入共享队列是可以的，但是后续处理完的响应势必也要由acceptor返回给客户端，kafka可能是考虑到这样会导致acceptor的逻辑太重，所以独立出了一层网络线程池，用于将请求放入队列和负责响应的发送。","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1604287356,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1039816,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/dd/c8/3f100905.jpg","nickname":"walt","note":"","ucode":"F0AEA21D02B7E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379322,"discussion_content":"这题我会啊，网络线程组是服务员组，io线程组是厨师组。三个服务员+八个厨师 一起为顾客提供服务。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1623828928,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1395849,"avatar":"","nickname":"forcht","note":"","ucode":"4CECBEB8251364","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1039816,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/dd/c8/3f100905.jpg","nickname":"walt","note":"","ucode":"F0AEA21D02B7E7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388299,"discussion_content":"这样做有什么意义呢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1628686948,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":379322,"ip_address":""},"score":388299,"extra":""},{"author":{"id":2642315,"avatar":"","nickname":"Geek_c695c1","note":"","ucode":"FC2AD53F54582D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1395849,"avatar":"","nickname":"forcht","note":"","ucode":"4CECBEB8251364","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389943,"discussion_content":"提高了系统扩展能力吧，网络数据收发应该是比较快的操作，相比具体的业务操作比较耗时，为了匹配生产者消费组的速率差，可以通过扩展IO线程池的线程数量以提高处理能力，或者把网络数据缓存到共享请求队列。实现类似削峰填谷的作用。接收网络数据和处理具体业务是并发处理的，提高了整个系统的性能。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1629531040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":388299,"ip_address":""},"score":389943,"extra":""}]},{"author":{"id":1056982,"avatar":"https://static001.geekbang.org/account/avatar/00/10/20/d6/b9513db0.jpg","nickname":"kingcall","note":"","ucode":"508884DC684B5B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214059,"discussion_content":"放到共享队列怎么回复客户端呢","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1585144087,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2631837,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM7xAfqHCnnRicz3fPk0Hd5WUzbr6uMZeQpjz0eZgNNb3fftIcQ58icS25EGE85QqnN1PGibWQ8hyO0WA/132","nickname":"a lapp","note":"","ucode":"F18180F5EF0744","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":410960,"discussion_content":"我理解这跟netty的网络模型差不多吧，acceptor线程用于接收链接请求的，监听ACCEPT事件，网络线程池监听READ/WRITE事件。acceptor建立链接后将socket分配给网络线程池，网络线程池selector监听读写请求，有客户端请求到来后，将请求交给共享队列，由真正的io线程竞争式消费处理，同时网络线程池监听响应队列，将io线程处理结果发送给客户端。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1635818191,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1827961,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/e4/79/0f0114ba.jpg","nickname":"taochao_zs","note":"","ucode":"77382AB0B3CC0E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555361,"discussion_content":"acceptor单独做的事情越少越快，而且不占太多资源，轻量。\n业务逻辑就扔给网络线程池来处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646882006,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1361159,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqJobg767PUeqrqQQ4B6YvMatj2SRyOicKZZ4gWTf30dMketiaj58Gc3RFTmckGxAXlL9ERSxGovq9g/132","nickname":"涛哥哥","note":"","ucode":"329A1384E3AB5E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549034,"discussion_content":"Acceptor只是监听是否有链接事件，并不参与socket数据的读写，所以更快，可以类比lvs；\n\nProcessor可以类比nginx，他来网络请求数据的读写，因为涉及到io，会要慢一点；\n\n如果acceptor同时监听链接请求和网络数据读写，由于是单线程的，势必吞吐量上不去。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643525038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1001861,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/49/85/3f161d95.jpg","nickname":"Alpha","note":"","ucode":"60CA15A25EC796","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310704,"discussion_content":"同意是再做了一层生产者消费者分离，但花这么大成本引入这一层是否值得呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602000681,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118118,"user_name":"ban","can_delete":false,"product_type":"c1","uid":1034204,"ip_address":"","ucode":"E523CE97E48266","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c7/dc/9408c8c2.jpg","comment_is_top":false,"comment_ctime":1564247711,"is_pvip":false,"replies":[{"id":"43353","content":"嗯嗯，差不多是这个意思","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1564361710,"ip_address":"","comment_id":118118,"utype":1}],"discussion_count":1,"race_medal":0,"score":"44513920671","product_id":100029201,"comment_content":"老师，社区完全拷贝了这张图中的一套组件，实现了两类请求的分离。也就是说，Kafka Broker 启动后，会在后台分别创建网络线程池和 IO 线程池，它们分别处理数据类请求和控制类请求。<br><br>上面这段话不太懂，意思是说：分别建立两套组件（A套 网络线程池IO线程池：负责处理数据类请求)、（B套 网络线程池IO线程池：负责处理控制类请求),这样理解对吗？","like_count":10,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460269,"discussion_content":"嗯嗯，差不多是这个意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564361710,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216701,"user_name":"MasterSong","can_delete":false,"product_type":"c1","uid":1199935,"ip_address":"","ucode":"E9040F63E85253","user_header":"https://static001.geekbang.org/account/avatar/00/12/4f/3f/1cf8c297.jpg","comment_is_top":false,"comment_ctime":1589330126,"is_pvip":false,"replies":[{"id":"80173","content":"的确是一种思路~","user_name":"作者回复","user_name_real":"胡夕","uid":"1288090","ctime":1589331947,"ip_address":"","comment_id":216701,"utype":1}],"discussion_count":1,"race_medal":0,"score":"40244035790","product_id":100029201,"comment_content":"很自然的一种想法是在队列中预留部分空间给控制消息，比如队列空间达到95%时对于数据消息视作队列已满，但控制消息仍然可以入队","like_count":9,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494917,"discussion_content":"的确是一种思路~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589331947,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179718,"user_name":"旭杰","can_delete":false,"product_type":"c1","uid":1242099,"ip_address":"","ucode":"964603ACF81B28","user_header":"https://static001.geekbang.org/account/avatar/00/12/f3/f3/3fbb4c38.jpg","comment_is_top":false,"comment_ctime":1582083242,"is_pvip":false,"replies":[{"id":"69872","content":"每个网络线程创建自己的响应队列。<br><br>“IO线程指定网络线程来发送响应” --- 严格来说不算是IO线程指定的，因为Kafka会记录请求是被哪个网络线程接收的，因此发送response时还会发往那个网络线程。","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1582158814,"ip_address":"","comment_id":179718,"utype":1}],"discussion_count":6,"race_medal":0,"score":"35941821610","product_id":100029201,"comment_content":"当 IO 线程处理完请求后，会将生成的响应发送到网络线程池的响应队列中，然后由对应的网络线程负责将 Response 返还给客户端。这个响应队列不是网络线程池共享的吗？还是说IO线程指定网络线程来发送响应？","like_count":8,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484367,"discussion_content":"每个网络线程创建自己的响应队列。\n\n“IO线程指定网络线程来发送响应” --- 严格来说不算是IO线程指定的，因为Kafka会记录请求是被哪个网络线程接收的，因此发送response时还会发往那个网络线程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582158814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2381065,"avatar":"https://static001.geekbang.org/account/avatar/00/24/55/09/73f24874.jpg","nickname":"建华","note":"","ucode":"668977F598DA01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344604,"discussion_content":"老师好，如果响应的线程被其他占用的话，它还怎么回应给客户端呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611535462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1736462,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/7f/0e/e3a8dbd9.jpg","nickname":"Liujun","note":"","ucode":"3DB1F3CA57B5B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2381065,"avatar":"https://static001.geekbang.org/account/avatar/00/24/55/09/73f24874.jpg","nickname":"建华","note":"","ucode":"668977F598DA01","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390461,"discussion_content":"阻塞啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629854570,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":344604,"ip_address":""},"score":390461,"extra":""}]},{"author":{"id":1336475,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","nickname":"J.Smile","note":"","ucode":"C4D98DFDBF7584","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284450,"discussion_content":"这个对response发给哪个网络线程的解释才算是清楚了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592535337,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1236023,"avatar":"https://static001.geekbang.org/account/avatar/00/12/dc/37/b53e190f.jpg","nickname":"薛小O","note":"","ucode":"6F5A0CC03A909A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":270563,"discussion_content":"老师你在文章中没有表明这个东西，所以你在说细心的你一定发现了。。那段话我就没明白怎么回事","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590025287,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1336475,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","nickname":"J.Smile","note":"","ucode":"C4D98DFDBF7584","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1236023,"avatar":"https://static001.geekbang.org/account/avatar/00/12/dc/37/b53e190f.jpg","nickname":"薛小O","note":"","ucode":"6F5A0CC03A909A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289391,"discussion_content":"Kafka会记录请求是被哪个网络线程接收的，因此发送response时还会发往那个网络线程。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594087359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":270563,"ip_address":""},"score":289391,"extra":""}]}]},{"had_liked":false,"id":120898,"user_name":"Mick","can_delete":false,"product_type":"c1","uid":1391216,"ip_address":"","ucode":"5CCE3E2BDB110A","user_header":"https://static001.geekbang.org/account/avatar/00/15/3a/70/a874d69c.jpg","comment_is_top":false,"comment_ctime":1565011014,"is_pvip":false,"replies":[{"id":"44457","content":"我觉得挺好的：）<br>","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1565051064,"ip_address":"","comment_id":120898,"utype":1}],"discussion_count":3,"race_medal":0,"score":"35924749382","product_id":100029201,"comment_content":"老师麻烦帮我看下这个请求流程图我画的对不对？https:&#47;&#47;www.processon.com&#47;view&#47;link&#47;5d481e6be4b07c4cf3031755","like_count":8,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461519,"discussion_content":"我觉得挺好的：）\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565051064,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1391216,"avatar":"https://static001.geekbang.org/account/avatar/00/15/3a/70/a874d69c.jpg","nickname":"Mick","note":"","ucode":"5CCE3E2BDB110A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3995,"discussion_content":"谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565052218,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1336475,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","nickname":"J.Smile","note":"","ucode":"C4D98DFDBF7584","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1391216,"avatar":"https://static001.geekbang.org/account/avatar/00/15/3a/70/a874d69c.jpg","nickname":"Mick","note":"","ucode":"5CCE3E2BDB110A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289387,"discussion_content":"响应是怎么跟网络线程池中的线程对应起来的呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594086823,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3995,"ip_address":""},"score":289387,"extra":""}]}]},{"had_liked":false,"id":117913,"user_name":"cricket1981","can_delete":false,"product_type":"c1","uid":1001715,"ip_address":"","ucode":"758262F5958DA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/f3/f1034ffd.jpg","comment_is_top":false,"comment_ctime":1564191263,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"35923929631","product_id":100029201,"comment_content":"双队列设计，分别存放数据类和控制类请求，每次先处理完所有控制类请求再处理数据类请求。","like_count":8,"discussions":[{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384468,"discussion_content":"那如果一直处理控制类请求数据类请求得不到执行是不是有问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626605043,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1054827,"avatar":"https://static001.geekbang.org/account/avatar/00/10/18/6b/a1448af1.jpg","nickname":"贝影","note":"","ucode":"19545C8DCBF8A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544260,"discussion_content":"哈哈哈，线程饥饿","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641451304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":384468,"ip_address":""},"score":544260,"extra":""}]},{"author":{"id":1068361,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4d/49/28e73b9c.jpg","nickname":"明翼","note":"","ucode":"E77F86BEB3D5C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3177,"discussion_content":"和我想法一样哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564278058,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205389,"user_name":"王帅","can_delete":false,"product_type":"c1","uid":1932260,"ip_address":"","ucode":"D3B4A1361B45E5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKPiayvKUhCibSXra8SnEz7ibvljGNyjtuFfiaVzeRmJrpRkSRHbodp0bnQhAkoZmugl024xSSxemxnUg/132","comment_is_top":false,"comment_ctime":1586605975,"is_pvip":false,"replies":[{"id":"76938","content":"看一下是否存在大量的CLOSE_WAIT。之前在社区的确是碰到过这种海量CLOSE_WAIT撑爆了连接数的情形。如果是，目前除了无脑增加ulimit -n之外没有特别好的解决方案。","user_name":"作者回复","user_name_real":"胡夕","uid":"1288090","ctime":1586764980,"ip_address":"","comment_id":205389,"utype":1}],"discussion_count":4,"race_medal":0,"score":"31651377047","product_id":100029201,"comment_content":"老师，你好。我在使用kafka-2.11_0.11.0.1的时候遇到了一个问题，kafka服务端由于文件打开数过多导致出现too many open files重启。但是查看kafka端口使用情况只有1.3w+.通过lsof查看sock占用数达到了6W+。（我配置的最大链接数是65536）。查看监控发现是已分配的socket的数目比较高。能不能帮忙解答下。","like_count":7,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491469,"discussion_content":"看一下是否存在大量的CLOSE_WAIT。之前在社区的确是碰到过这种海量CLOSE_WAIT撑爆了连接数的情形。如果是，目前除了无脑增加ulimit -n之外没有特别好的解决方案。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586764980,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1932260,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKPiayvKUhCibSXra8SnEz7ibvljGNyjtuFfiaVzeRmJrpRkSRHbodp0bnQhAkoZmugl024xSSxemxnUg/132","nickname":"王帅","note":"","ucode":"D3B4A1361B45E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":235375,"discussion_content":"胡老师，您好。我将ulimit -n 调高到20W，还是会出现大量CLOSE_WAIT状态，导致broker down掉， 这个问题有没有其他解决方案呢？ 期待您的回复。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587038431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1932260,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKPiayvKUhCibSXra8SnEz7ibvljGNyjtuFfiaVzeRmJrpRkSRHbodp0bnQhAkoZmugl024xSSxemxnUg/132","nickname":"王帅","note":"","ucode":"D3B4A1361B45E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":232230,"discussion_content":"谢谢回复，在出现该问题的时候确实出现了大量的CLOSE_WAIT状态的链接，随后立刻转为CLOSED状态了，那如果调整kafka服务端配置connections.max.idle.ms有没有效果，因为我看源码这个是关闭空闲连接的超时时间。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586862223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1336475,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","nickname":"J.Smile","note":"","ucode":"C4D98DFDBF7584","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1932260,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKPiayvKUhCibSXra8SnEz7ibvljGNyjtuFfiaVzeRmJrpRkSRHbodp0bnQhAkoZmugl024xSSxemxnUg/132","nickname":"王帅","note":"","ucode":"D3B4A1361B45E5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289390,"discussion_content":"老铁，解决了吗，是CLOSE_WAIT引起的openfiles升高吗？可以加v---TiensC探讨下？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594087265,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":232230,"ip_address":""},"score":289390,"extra":""}]}]},{"had_liked":false,"id":118380,"user_name":"Sunney","can_delete":false,"product_type":"c1","uid":1380199,"ip_address":"","ucode":"DC7A18F4D5313E","user_header":"https://static001.geekbang.org/account/avatar/00/15/0f/67/1cfb574e.jpg","comment_is_top":false,"comment_ctime":1564357045,"is_pvip":false,"replies":[{"id":"43347","content":"相同的方法，都要传输字节数组。你需要找到合适的方法把你的视频流数据或照片编码成字节序列。当然Kafka其实并不适合传输特别大的消息，因此你可以评估一下是否真的需求传视频本身？","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1564360886,"ip_address":"","comment_id":118380,"utype":1}],"discussion_count":5,"race_medal":0,"score":"27334160821","product_id":100029201,"comment_content":"老师您好，这两天做项目遇到一个问题想咨询一下，对于网络摄像头的视频流数据和抓拍到的照片数据，kafka应该如何传输呢？","like_count":6,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460383,"discussion_content":"相同的方法，都要传输字节数组。你需要找到合适的方法把你的视频流数据或照片编码成字节序列。当然Kafka其实并不适合传输特别大的消息，因此你可以评估一下是否真的需求传视频本身？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564360886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1254112,"avatar":"https://static001.geekbang.org/account/avatar/00/13/22/e0/6295a753.jpg","nickname":"Harvey","note":"","ucode":"164D1178DA091A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3339,"discussion_content":"大文件本身通常是保存在存储，再同步到CDN加速，消息可以发送文件地址，避免用消息去传输大文件本身","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1564407630,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1380199,"avatar":"https://static001.geekbang.org/account/avatar/00/15/0f/67/1cfb574e.jpg","nickname":"Sunney","note":"","ucode":"DC7A18F4D5313E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3269,"discussion_content":"老师能介绍一下为什么kafka不适合传视频流嘛😄目前项目正在做前期的调研阶段","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564368377,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1682331,"avatar":"https://static001.geekbang.org/account/avatar/00/19/ab/9b/b12c223d.jpg","nickname":"第一片心意","note":"","ucode":"4CFE5F1D615743","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1380199,"avatar":"https://static001.geekbang.org/account/avatar/00/15/0f/67/1cfb574e.jpg","nickname":"Sunney","note":"","ucode":"DC7A18F4D5313E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":83821,"discussion_content":"视频流太大啊，kafka默认消息最大为1M。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576467514,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3269,"ip_address":""},"score":83821,"extra":""},{"author":{"id":1446592,"avatar":"https://static001.geekbang.org/account/avatar/00/16/12/c0/dd800b84.jpg","nickname":"、逍遥胖胖～","note":"","ucode":"DD01CD1E1927E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1380199,"avatar":"https://static001.geekbang.org/account/avatar/00/15/0f/67/1cfb574e.jpg","nickname":"Sunney","note":"","ucode":"DC7A18F4D5313E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581077,"discussion_content":"消息太大，数据在broker的页缓存中存不下就会刷盘，导致丧失了零拷贝的优势","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658485738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3269,"ip_address":""},"score":581077,"extra":""}]}]},{"had_liked":false,"id":189438,"user_name":"梁胖","can_delete":false,"product_type":"c1","uid":1528211,"ip_address":"","ucode":"2DB8801BC54D00","user_header":"https://static001.geekbang.org/account/avatar/00/17/51/93/83e3de61.jpg","comment_is_top":false,"comment_ctime":1584515948,"is_pvip":false,"replies":[{"id":"73065","content":"当时在讲的时候社区还不是很完善，现在就比较肯定了。举个例子，你可以这样设定来控制control-plane请求由哪个监听器来控制：<br>control.plane.listener.name=CONTROLLER<br>listener.security.protocol.map = INTERNAL:PLAINTEXT, EXTERNAL:SSL, CONTROLLER:SSL<br>listeners = INTERNAL:&#47;&#47;192.1.1.8:9092, EXTERNAL:&#47;&#47;10.1.1.5:9093, CONTROLLER:&#47;&#47;192.1.1.8:9094","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1584579546,"ip_address":"","comment_id":189438,"utype":1}],"discussion_count":0,"race_medal":0,"score":"23059352428","product_id":100029201,"comment_content":"&quot;Kafka Broker 启动后，会在后台分别创建两套网络线程池和 IO 线程池的组合，它们分别处理数据类请求和控制类请求。至于所用的 Socket 端口，自然是使用不同的端口了，你需要提供不同的 listeners 配置，显式地指定哪套端口用于处理哪类请求&quot;<br>胡老师您好，这句话我有个问题，请问：listeners配置中具体怎么显式地指定哪套端口用于处理哪类请求？","like_count":5},{"had_liked":false,"id":273485,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1610611402,"is_pvip":false,"replies":[{"id":"99086","content":"嗯嗯，确实有这方面的原因","user_name":"作者回复","user_name_real":"胡夕","uid":"1288090","ctime":1610620699,"ip_address":"","comment_id":273485,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18790480586","product_id":100029201,"comment_content":"疑惑Kafka为什么没用已经实现了Reactor模式的netty网络应用框架，搜了下原因，一个是追求性能，一个是不想太多依赖。<br>https:&#47;&#47;www.quora.com&#47;Why-did-Kafka-developers-prefer-to-implement-their-own-socket-server-instead-of-using-Netty-Does-that-help-with-performance-Does-Kafka-implement-such-features-already","like_count":4,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513614,"discussion_content":"嗯嗯，确实有这方面的原因","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610620699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1736462,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/7f/0e/e3a8dbd9.jpg","nickname":"Liujun","note":"","ucode":"3DB1F3CA57B5B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390466,"discussion_content":"怎么用netty？服务端是java？？？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629855516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217337,"user_name":"星之所在","can_delete":false,"product_type":"c1","uid":1247574,"ip_address":"","ucode":"03ADB0ADD5FC27","user_header":"https://static001.geekbang.org/account/avatar/00/13/09/56/2628852c.jpg","comment_is_top":false,"comment_ctime":1589466267,"is_pvip":false,"replies":[{"id":"80474","content":"默认是500的上限，如果满了会阻塞","user_name":"作者回复","user_name_real":"胡夕","uid":"1288090","ctime":1589524484,"ip_address":"","comment_id":217337,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18769335451","product_id":100029201,"comment_content":"老师共享队列满了，那么这个请求会丢弃吧？","like_count":4,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495113,"discussion_content":"默认是500的上限，如果满了会阻塞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589524484,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119020,"user_name":"锦","can_delete":false,"product_type":"c1","uid":1468298,"ip_address":"","ucode":"CB0EB4B68C468B","user_header":"https://static001.geekbang.org/account/avatar/00/16/67/8a/babd74dc.jpg","comment_is_top":false,"comment_ctime":1564488044,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18744357228","product_id":100029201,"comment_content":"我理解Acceptor是用来接收连接的（三次握手），连接成功后把读写请求的Socket提交到网络线程池，网络线程池中的线程通过Selector收到读请求后，从内核读取消息数据，然后再把待处理消息数据放入共享请求队列中。共享请求队列应该是多生产者多消费者模式（这里如何设计比较关键）。io线程池从共享请求队列中取出消息处理，处理完成再把响应提交到网络线程池中，由网络线程池发送至客户端。这里的共享请求队列为什么不直接使用io线程池自带的工作队列呢？另外控制类请求单独走不同线程池处理比较合理。<br>","like_count":4},{"had_liked":false,"id":308839,"user_name":"灰色","can_delete":false,"product_type":"c1","uid":1178135,"ip_address":"","ucode":"869B400BBD520D","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/17/d0b8135f.jpg","comment_is_top":false,"comment_ctime":1629818491,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"14514720379","product_id":100029201,"comment_content":"看了老师回答 “io线程池，异步处理消息，保证同一分区消息顺序一致性”的问题，感觉没有回答明白。<br>我这里在描述一下问题：一个producer向一个partition先后发了两条消息A和B，在共享队列里的顺序也是，先A后B，但是io线程有多个，这样消息A和消息B会被同时处理，而且很有可能，消息B先被处理完，保存到日志文件中，这让在日志中，就变成先B后A了，是不是就破坏了同一分区消息的有序性？","like_count":3,"discussions":[{"author":{"id":3162699,"avatar":"","nickname":"张信","note":"","ucode":"242ECB2A79702B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588356,"discussion_content":"我也有这个问题，你现在有答案了吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663686159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2912918,"avatar":"","nickname":"Geek_284c06","note":"","ucode":"4BD6D4449D4F1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577534,"discussion_content":"我也有这个问题，你现在有答案了吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656167006,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1155275,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","nickname":"张三丰","note":"","ucode":"3A6215A40B3B21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560333,"discussion_content":"同一个分区写的时候是要对日志先加锁的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649263583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2912918,"avatar":"","nickname":"Geek_284c06","note":"","ucode":"4BD6D4449D4F1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1155275,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","nickname":"张三丰","note":"","ucode":"3A6215A40B3B21","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577532,"discussion_content":"他说的是b先被处理完，跟加不加所没关系","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656166888,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":560333,"ip_address":""},"score":577532,"extra":""},{"author":{"id":2912918,"avatar":"","nickname":"Geek_284c06","note":"","ucode":"4BD6D4449D4F1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1155275,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","nickname":"张三丰","note":"","ucode":"3A6215A40B3B21","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577533,"discussion_content":"你加锁只是不能同时写罢了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656166919,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":560333,"ip_address":""},"score":577533,"extra":""}]}]},{"had_liked":false,"id":269102,"user_name":"一位不愿透漏姓名的足球名宿","can_delete":false,"product_type":"c1","uid":1244283,"ip_address":"","ucode":"2A67AD14C1F436","user_header":"https://static001.geekbang.org/account/avatar/00/12/fc/7b/adfef198.jpg","comment_is_top":false,"comment_ctime":1608524376,"is_pvip":false,"replies":[{"id":"97626","content":"很不错的文章","user_name":"作者回复","user_name_real":"胡夕","uid":"1288090","ctime":1608553378,"ip_address":"","comment_id":269102,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14493426264","product_id":100029201,"comment_content":"https:&#47;&#47;my.oschina.net&#47;u&#47;3573545&#47;blog&#47;2221656<br>可以看下这篇文章，感觉和netty很相似～","like_count":3,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512150,"discussion_content":"很不错的文章","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608553378,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":252610,"user_name":"小麦","can_delete":false,"product_type":"c1","uid":1618709,"ip_address":"","ucode":"2C800B598A2CDE","user_header":"https://static001.geekbang.org/account/avatar/00/18/b3/15/30822e33.jpg","comment_is_top":false,"comment_ctime":1602399722,"is_pvip":true,"replies":[{"id":"92491","content":"单个producer实例向单个分区下生产消息是保证有顺序的，如果在启用了retries之后设置max.in.flight.requests.per.connection = 1","user_name":"作者回复","user_name_real":"胡夕","uid":"1288090","ctime":1602637361,"ip_address":"","comment_id":252610,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14487301610","product_id":100029201,"comment_content":"老师能讲一下具体怎么保证分区的顺序性的吗？我看评论里回复的：<br><br>&#47;&#47; 所以在clients端进行保证，通过特定的参数来控制请求的发送顺序<br><br>具体是怎么控制的？","like_count":3,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506816,"discussion_content":"单个producer实例向单个分区下生产消息是保证有顺序的，如果在启用了retries之后设置max.in.flight.requests.per.connection = 1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602637361,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2912918,"avatar":"","nickname":"Geek_284c06","note":"","ucode":"4BD6D4449D4F1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":577529,"discussion_content":"多个io线程去队列里面拿请求处理，那怎么保证顺序性呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656166556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":506816,"ip_address":""},"score":577529,"extra":""}]}]},{"had_liked":false,"id":221326,"user_name":"张洋","can_delete":false,"product_type":"c1","uid":1182914,"ip_address":"","ucode":"549BE5DEEF8417","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/c2/bad34a50.jpg","comment_is_top":false,"comment_ctime":1590474836,"is_pvip":true,"replies":[{"id":"81709","content":"Control request固定长度是20，这里有个假设：control request比data request要少得多，不太可能同时累积20个请求。当然这只是假设了~<br>","user_name":"作者回复","user_name_real":"胡夕","uid":"1288090","ctime":1590547251,"ip_address":"","comment_id":221326,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14475376724","product_id":100029201,"comment_content":"老师现在kafka的解决方面完全copy了一份，相当于是两个队列，但是两个队列也是可能出现，队列都满了的情况的呀。","like_count":3,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496424,"discussion_content":"Control request固定长度是20，这里有个假设：control request比data request要少得多，不太可能同时累积20个请求。当然这只是假设了~\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590547251,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118085,"user_name":"电光火石","can_delete":false,"product_type":"c1","uid":1013160,"ip_address":"","ucode":"3AD33BB4AA940F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/a8/dfe4cade.jpg","comment_is_top":false,"comment_ctime":1564234267,"is_pvip":false,"replies":[{"id":"43363","content":"1. Kafka社区当初主要是为了jar依赖的问题而选择不使用netty，转而使用Java NIO的<br>2. Broker入口类是kafka.server.KafkaServer.scala","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1564361984,"ip_address":"","comment_id":118085,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14449136155","product_id":100029201,"comment_content":"优先级队列方案，可以开两个队列，分别处理，前面的监听端口不需要重新构建，只是后面的处理线程不同即可。<br>另外，想问一下：<br>1. 为什么当时kafka做的时候，没有考虑使用netty作为通信框架？<br>2. 对IO这一块的处理比较感兴趣，老师可以介绍一下broker的入口类吗，想去看一下源码<br>谢谢了！","like_count":3,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460256,"discussion_content":"1. Kafka社区当初主要是为了jar依赖的问题而选择不使用netty，转而使用Java NIO的\n2. Broker入口类是kafka.server.KafkaServer.scala","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564361984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117915,"user_name":"Riordon","can_delete":false,"product_type":"c1","uid":1127497,"ip_address":"","ucode":"E2F6855B5FE5F9","user_header":"https://static001.geekbang.org/account/avatar/00/11/34/49/6b27feb1.jpg","comment_is_top":false,"comment_ctime":1564191300,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14449093188","product_id":100029201,"comment_content":"数据类请求和控制类请求的分离，我理解的是多开一套端口，实现一套网络线程池+IO线程池？不对吗？<br>Acceptor线程：公平转发请求到网络线程<br>网络线程池：将请求放入共享队列<br>IO线程池：从共享队列取出请求，执行真正的IO<br>","like_count":3},{"had_liked":false,"id":294413,"user_name":"RecklesszZ 😶","can_delete":false,"product_type":"c1","uid":1548802,"ip_address":"","ucode":"8DF59BEAC079DD","user_header":"https://static001.geekbang.org/account/avatar/00/17/a2/02/bd5b398c.jpg","comment_is_top":false,"comment_ctime":1621932728,"is_pvip":false,"replies":[{"id":"107171","content":"如何定义1在2之前？是同一个TCP连接发过来的吗？如果不是，那么Kafka也没办法保证顺序","user_name":"作者回复","user_name_real":"胡夕","uid":"1288090","ctime":1622353648,"ip_address":"","comment_id":294413,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10211867320","product_id":100029201,"comment_content":"胡老师，请问下，在I&#47;O线程乱序处理以后，日志管理器实例是如何reorder成producer发送的顺序的，依靠的是什么方式？另外假设1,2两条数据，2数据先到日志管理器实例后，是先缓存起来，等到1到了以后再处理？","like_count":2,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520643,"discussion_content":"如何定义1在2之前？是同一个TCP连接发过来的吗？如果不是，那么Kafka也没办法保证顺序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622353648,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":251507,"user_name":"timmy21","can_delete":false,"product_type":"c1","uid":1174860,"ip_address":"","ucode":"9D6DED247B1F38","user_header":"https://static001.geekbang.org/account/avatar/00/11/ed/4c/8674b6ad.jpg","comment_is_top":false,"comment_ctime":1601625207,"is_pvip":false,"replies":[{"id":"92151","content":"一个broker上虽然有多个handler IO线程处理请求，但底层的日志管理器实例只有一个，因此依然能够保证消息的顺序性。当然这里所说的顺序性是指同一个producer发送消息的顺序性，多个producer同时发送消息，本来也无法确定哪个producer发送的消息在前，哪个producer发送的消息在后。","user_name":"作者回复","user_name_real":"胡夕","uid":"1288090","ctime":1602206898,"ip_address":"","comment_id":251507,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10191559799","product_id":100029201,"comment_content":"当前这种异步消息处理模型，如何保证分区的消息顺序的一致性？","like_count":2,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506524,"discussion_content":"一个broker上虽然有多个handler IO线程处理请求，但底层的日志管理器实例只有一个，因此依然能够保证消息的顺序性。当然这里所说的顺序性是指同一个producer发送消息的顺序性，多个producer同时发送消息，本来也无法确定哪个producer发送的消息在前，哪个producer发送的消息在后。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602206898,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1548802,"avatar":"https://static001.geekbang.org/account/avatar/00/17/a2/02/bd5b398c.jpg","nickname":"RecklesszZ 😶","note":"","ucode":"8DF59BEAC079DD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376031,"discussion_content":"胡老师，请问下，在I/O线程乱序处理以后，日志管理器实例是如何reorder成producer发送的顺序的，依靠的是什么方式？另外1,2两条数据，2数据先到日志管理器实例后，是先缓存起来，等到1到了以后再处理？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621932681,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1736462,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/7f/0e/e3a8dbd9.jpg","nickname":"Liujun","note":"","ucode":"3DB1F3CA57B5B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1548802,"avatar":"https://static001.geekbang.org/account/avatar/00/17/a2/02/bd5b398c.jpg","nickname":"RecklesszZ 😶","note":"","ucode":"8DF59BEAC079DD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390475,"discussion_content":"怎么可能，想要保证顺序性是看生产者的sender线程实现的，一个发送必须回来之后再发送第二个消息，这个需要一个参数设置，你懂的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629856424,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":376031,"ip_address":""},"score":390475,"extra":""}]}]},{"had_liked":false,"id":250661,"user_name":"对与错","can_delete":false,"product_type":"c1","uid":1682027,"ip_address":"","ucode":"EF55733E3BD78B","user_header":"https://static001.geekbang.org/account/avatar/00/19/aa/6b/ab9a072a.jpg","comment_is_top":false,"comment_ctime":1601188923,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10191123515","product_id":100029201,"comment_content":"接上一个问题，我还是没明白这个地方怎么是client端来保证，哪怕client发送的是一批有顺序的消息，<br>但是由于broker端的异步处理机制，这应该也会造成的消息非顺序的消费，求老师解惑<br>---------------------------------------------------------------------------------------<br>Kafka的异步处理机制应该不能保证消息的有序吧，比如哪怕只有一个分区，生产者发送10个消息，通过acceptor轮询给不同的Processor去处理，然后Processor最终处理的顺序不同，发送给RequestChannel的顺序也不同，那最后消费的顺序岂不是也不相同了?<br><br>作者回复: 所以在clients端进行保证，通过特定的参数来控制请求的发送顺序","like_count":2,"discussions":[{"author":{"id":1103208,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d5/68/2201b6b9.jpg","nickname":"归零","note":"","ucode":"C99B8E93009A46","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348780,"discussion_content":"同没有懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612710776,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250329,"user_name":"对与错","can_delete":false,"product_type":"c1","uid":1682027,"ip_address":"","ucode":"EF55733E3BD78B","user_header":"https://static001.geekbang.org/account/avatar/00/19/aa/6b/ab9a072a.jpg","comment_is_top":false,"comment_ctime":1601026699,"is_pvip":false,"replies":[{"id":"91723","content":"所以在clients端进行保证，通过特定的参数来控制请求的发送顺序","user_name":"作者回复","user_name_real":"胡夕","uid":"1288090","ctime":1601177121,"ip_address":"","comment_id":250329,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10190961291","product_id":100029201,"comment_content":"Kafka的异步处理机制应该不能保证消息的有序吧，比如哪怕只有一个分区，生产者发送10个消息，通过acceptor轮询给不同的Processor去处理，然后Processor最终处理的顺序不同，发送给RequestChannel的顺序也不同，那最后消费的顺序岂不是也不相同了?","like_count":2,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506187,"discussion_content":"所以在clients端进行保证，通过特定的参数来控制请求的发送顺序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601177121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1736462,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/7f/0e/e3a8dbd9.jpg","nickname":"Liujun","note":"","ucode":"3DB1F3CA57B5B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390471,"discussion_content":"这个参数就是那个生产者最多只有一个请求未应答，设置这个消息就有序了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629855814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220418,"user_name":"行则将至","can_delete":false,"product_type":"c1","uid":1542987,"ip_address":"","ucode":"DB972F2DF059C4","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","comment_is_top":false,"comment_ctime":1590239033,"is_pvip":false,"replies":[{"id":"81429","content":"靠额外的两个参数来确定：listener.security.protocol.map和control.plane.listener.name","user_name":"作者回复","user_name_real":"胡夕","uid":"1288090","ctime":1590329373,"ip_address":"","comment_id":220418,"utype":1}],"discussion_count":1,"race_medal":1,"score":"10180173625","product_id":100029201,"comment_content":"老师，社区复制了一套Reactor模式来提高控制类请求的优先级。文尾，您提到，listener配置。这个listener配置，不会就是server.properties中的listener和advertise.listener，这两个？如果真是这样，哪个处理控制类请求，哪个处理数据类请求？","like_count":2,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496137,"discussion_content":"靠额外的两个参数来确定：listener.security.protocol.map和control.plane.listener.name","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590329373,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212822,"user_name":"thomas","can_delete":false,"product_type":"c1","uid":1016777,"ip_address":"","ucode":"9AB945308F1B50","user_header":"https://static001.geekbang.org/account/avatar/00/0f/83/c9/5d03981a.jpg","comment_is_top":false,"comment_ctime":1588216314,"is_pvip":true,"replies":[{"id":"79133","content":"不用协调，就是机械性地依次执行这两个动作，毕竟一个是请求队列，一个是响应队列。响应队列只存放response，不会有request的。","user_name":"作者回复","user_name_real":"胡夕","uid":"1288090","ctime":1588400545,"ip_address":"","comment_id":212822,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10178150906","product_id":100029201,"comment_content":"老师，按流程图的理解：网络线程池的作用有两个，1 将请求放入共享队列  2. 处理响应队列。 请问网络线程池是如何协调1，2这两个步骤的？ 比如各个线程的响应队列都有100条Request待处理, 现在又不断的有请求进来。","like_count":2,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493620,"discussion_content":"不用协调，就是机械性地依次执行这两个动作，毕竟一个是请求队列，一个是响应队列。响应队列只存放response，不会有request的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588400545,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205636,"user_name":"欧阳","can_delete":false,"product_type":"c1","uid":1196886,"ip_address":"","ucode":"2612576E262813","user_header":"https://static001.geekbang.org/account/avatar/00/12/43/56/62c38c36.jpg","comment_is_top":false,"comment_ctime":1586692351,"is_pvip":true,"replies":[{"id":"76936","content":"会破坏的，所以Kafka更适用于处理那种前后无依赖关系的消息","user_name":"作者回复","user_name_real":"胡夕","uid":"1288090","ctime":1586764066,"ip_address":"","comment_id":205636,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10176626943","product_id":100029201,"comment_content":"请问异步处理不会破坏消息的顺序性吗？","like_count":2,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491535,"discussion_content":"会破坏的，所以Kafka更适用于处理那种前后无依赖关系的消息","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586764066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2912918,"avatar":"","nickname":"Geek_284c06","note":"","ucode":"4BD6D4449D4F1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":577530,"discussion_content":"那单分区顺序性是怎么保证的呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656166779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":491535,"ip_address":""},"score":577530,"extra":""}]}]},{"had_liked":false,"id":140600,"user_name":"云师兄","can_delete":false,"product_type":"c1","uid":1010459,"ip_address":"","ucode":"4475AF1598FBFD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/1b/4b397b80.jpg","comment_is_top":false,"comment_ctime":1571014462,"is_pvip":false,"replies":[{"id":"54557","content":"我不是设计人员不好妄言：）直观的感受是，可能就是单纯地想把分发线程和处理线程分开吧","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1571105059,"ip_address":"","comment_id":140600,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10160949054","product_id":100029201,"comment_content":"老师能否解答下kafka要分成网络线程和io线程？像tomcat这类请求模型中，网络线程也是执行线程，kafka大费周章，除了延迟请求，还有其他目的吗","like_count":2,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470461,"discussion_content":"我不是设计人员不好妄言：）直观的感受是，可能就是单纯地想把分发线程和处理线程分开吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571105059,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1762252,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/e3/cc/0947ff0b.jpg","nickname":"nestle","note":"","ucode":"469800BED81B54","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300875,"discussion_content":"可能会更加灵活，网络请求处理不过来增加网络线程数，io请求处理不过来增加io线程数。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598285180,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118546,"user_name":"Hello world","can_delete":false,"product_type":"c1","uid":1333607,"ip_address":"","ucode":"4D2EF3034571B7","user_header":"https://static001.geekbang.org/account/avatar/00/14/59/67/f4ba1da4.jpg","comment_is_top":false,"comment_ctime":1564385238,"is_pvip":false,"replies":[{"id":"43517","content":"Processor线程也不是啥都不做，它有很多要处理的事情，比如执行网络层的请求&#47;响应发送，这些都是后面API线程或请求处理线程做不了也不应该做的。","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1564447648,"ip_address":"","comment_id":118546,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10154319830","product_id":100029201,"comment_content":"老师，我理解Acceptor线程是分发请求给网络线程，而网络线程接收到请求再放入请求队列。Acceptor线程只是负责转发请求，压力不大，既然网络线程其实也是相当于转发请求，为啥还要有这个网络线程呢？","like_count":2,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460447,"discussion_content":"Processor线程也不是啥都不做，它有很多要处理的事情，比如执行网络层的请求/响应发送，这些都是后面API线程或请求处理线程做不了也不应该做的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564447648,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219433,"user_name":"薛小O","can_delete":false,"product_type":"c1","uid":1236023,"ip_address":"","ucode":"6F5A0CC03A909A","user_header":"https://static001.geekbang.org/account/avatar/00/12/dc/37/b53e190f.jpg","comment_is_top":false,"comment_ctime":1590025621,"is_pvip":false,"replies":[{"id":"81192","content":"嗯，哪里有误导呢？另外严格来讲，请求和响应不是在同一个地方。请求被放置在RequestChannel中，而响应被放置在Processor中。","user_name":"作者回复","user_name_real":"胡夕","uid":"1288090","ctime":1590129172,"ip_address":"","comment_id":219433,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5884992917","product_id":100029201,"comment_content":"老师请问下，请求和响应用的是同一个线程池吗？都是网络线程池哈，如果是，你的第3张图就有点误导了","like_count":1,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495806,"discussion_content":"嗯，哪里有误导呢？另外严格来讲，请求和响应不是在同一个地方。请求被放置在RequestChannel中，而响应被放置在Processor中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590129172,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179985,"user_name":"Ryoma","can_delete":false,"product_type":"c1","uid":1130590,"ip_address":"","ucode":"7F692369239692","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/5e/b8fada94.jpg","comment_is_top":false,"comment_ctime":1582156468,"is_pvip":true,"replies":[{"id":"70007","content":"感谢指正。这块总结是有歧义的。我的本意是社区引入了两套网络线程池+IO线程池。每套分别处理数据类请求和控制类请求。<br><br>其实就是Acceptor模式的分发线程，仅仅是解耦请求接收和请求处理，这样更加灵活些","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1582247796,"ip_address":"","comment_id":179985,"utype":1}],"discussion_count":1,"race_medal":2,"score":"5877123764","product_id":100029201,"comment_content":"老师在核心盘点中总结：网络线程池处理数据类请求，IO线程池处理控制类请求。<br>但从文中来看，数据类请求也是先经过网络线程池，最后由 IO 线程池实际处理的，这里是总结有误么？<br><br>还有一个问题：网络线程接受到请求，直接将请求放入共享请求队列。那为何还需要引入网络线程呢，如果没有做其它的事，这类轻操作单线程处理起来我觉得性能也不会差到哪儿去。有隐藏的原因么？","like_count":1,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484478,"discussion_content":"感谢指正。这块总结是有歧义的。我的本意是社区引入了两套网络线程池+IO线程池。每套分别处理数据类请求和控制类请求。\n\n其实就是Acceptor模式的分发线程，仅仅是解耦请求接收和请求处理，这样更加灵活些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582247796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151163,"user_name":"飞翔","can_delete":false,"product_type":"c1","uid":1068571,"ip_address":"","ucode":"65AF6AF292DAD6","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/1b/f4b786b9.jpg","comment_is_top":false,"comment_ctime":1573659744,"is_pvip":true,"replies":[{"id":"58200","content":"网络线程池的个数","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1573694924,"ip_address":"","comment_id":151163,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5868627040","product_id":100029201,"comment_content":"老师 请问有多少线程 在处理请求响应队列里的response消息呀","like_count":1,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474388,"discussion_content":"网络线程池的个数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573694924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139380,"user_name":"林肯","can_delete":false,"product_type":"c1","uid":1008582,"ip_address":"","ucode":"D2C97220230DE5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/c6/d6ea3df3.jpg","comment_is_top":false,"comment_ctime":1570623801,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5865591097","product_id":100029201,"comment_content":"reactor模式特别适合多客户端向服务端请求的场景，同样场景的还有redis","like_count":1},{"had_liked":false,"id":133405,"user_name":"aof","can_delete":false,"product_type":"c1","uid":1062864,"ip_address":"","ucode":"5815D63C4926BC","user_header":"https://static001.geekbang.org/account/avatar/00/10/37/d0/26975fba.jpg","comment_is_top":false,"comment_ctime":1568553409,"is_pvip":false,"replies":[{"id":"51244","content":"可以的：）","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1568593794,"ip_address":"","comment_id":133405,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5863520705","product_id":100029201,"comment_content":"老师可不可以这么理解，这一节其实就是讲的Kafka的网络模型？","like_count":1,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467381,"discussion_content":"可以的：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568593794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123343,"user_name":"落霞与孤鹜","can_delete":false,"product_type":"c1","uid":1111004,"ip_address":"","ucode":"1F06EB86DD2E6B","user_header":"https://static001.geekbang.org/account/avatar/00/10/f3/dc/e7e5c159.jpg","comment_is_top":false,"comment_ctime":1565660512,"is_pvip":false,"replies":[{"id":"45288","content":"要执行了LeaderAndIsr才有这个效果啊，如果LeaderAndIsr被阻塞了这个变更的时机就被大大推迟了啊<br>","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1565675628,"ip_address":"","comment_id":123343,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5860627808","product_id":100029201,"comment_content":"有点疑问，在说到控制类请求和数据类请求的时候，您说强制执行leaderandisr，leader副本立马失效，follwer副本立马上位，这不就是立马执行了控制类请求么？和下面说的优先处理leaderandisr请求，我咋感觉是一样一样的啊","like_count":1,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462628,"discussion_content":"要执行了LeaderAndIsr才有这个效果啊，如果LeaderAndIsr被阻塞了这个变更的时机就被大大推迟了啊\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565675628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120831,"user_name":"蓝魔丶","can_delete":false,"product_type":"c1","uid":1219438,"ip_address":"","ucode":"2AE4359E263558","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg","comment_is_top":false,"comment_ctime":1565003510,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5859970806","product_id":100029201,"comment_content":"回答最后问题：优先队列只能保证优先级高的控制类请求有机会先调度执行，无法保证控制类比数据类请求先处理的要求，同样还可能造成数据类请求饥饿现象，而且数据类请求会比控制类请求多，所以如果放在一个共享队列中，则无法线性扩展，所以使用双队列自己严格控制，数据类请求队列装满的概率大，可以动态扩展数据类请求队列加快处理过程，而对于控制类请求队列则没有影响","like_count":1},{"had_liked":false,"id":117911,"user_name":"cricket1981","can_delete":false,"product_type":"c1","uid":1001715,"ip_address":"","ucode":"758262F5958DA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/f3/f1034ffd.jpg","comment_is_top":false,"comment_ctime":1564190750,"is_pvip":false,"replies":[{"id":"43559","content":"嗯嗯，从某种意义上只是分离，确实不是我们认为的优先级处理，但总归是能解决之前碰到的那些问题不是：）","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1564452196,"ip_address":"","comment_id":117911,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5859158046","product_id":100029201,"comment_content":"从文章介绍来看社区方案也只是分开处理数据类和控制类请求，并无控制类优先于数据类处理逻辑啊","like_count":1,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460175,"discussion_content":"嗯嗯，从某种意义上只是分离，确实不是我们认为的优先级处理，但总归是能解决之前碰到的那些问题不是：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564452196,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":350285,"user_name":"凯文小猪","can_delete":false,"product_type":"c1","uid":1980201,"ip_address":"","ucode":"36D8AD0229547F","user_header":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","comment_is_top":false,"comment_ctime":1656749535,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1656749535","product_id":100029201,"comment_content":"设计目的与计算机总线类似：cpu内部宏观上有两类总线，1. 数据总线 2.控制总线。同样的数据从数据总线传过来就是参数 从指令总线传过来就是操作码 诸如add等","like_count":0},{"had_liked":false,"id":337536,"user_name":"taochao_zs","can_delete":false,"product_type":"c1","uid":1827961,"ip_address":"","ucode":"77382AB0B3CC0E","user_header":"https://static001.geekbang.org/account/avatar/00/1b/e4/79/0f0114ba.jpg","comment_is_top":false,"comment_ctime":1646882420,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1646882420","product_id":100029201,"comment_content":"老师，控制类请求的监听配置格式能提供一下，没找到这个配置项。","like_count":0},{"had_liked":false,"id":337534,"user_name":"taochao_zs","can_delete":false,"product_type":"c1","uid":1827961,"ip_address":"","ucode":"77382AB0B3CC0E","user_header":"https://static001.geekbang.org/account/avatar/00/1b/e4/79/0f0114ba.jpg","comment_is_top":false,"comment_ctime":1646882146,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1646882146","product_id":100029201,"comment_content":"需要找一种合适的数据结构。","like_count":0},{"had_liked":false,"id":333214,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1644216649,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644216649","product_id":100029201,"comment_content":"我感觉这里有个很严重的问题，io线程生产消费共享队列的时候存在大量的并发情况，这里如何限制的，靠锁？","like_count":0},{"had_liked":false,"id":330739,"user_name":"小仙","can_delete":false,"product_type":"c1","uid":1866677,"ip_address":"","ucode":"9F94043DFCEC3A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eq6pWvKsV4rzQ62z5MDEjaEU5MbDfmzbA62kUgoqia2tgKIIxw4ibkDhF7W48iat5dT8UB9Adky2NuzQ/132","comment_is_top":false,"comment_ctime":1642140811,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642140811","product_id":100029201,"comment_content":"社区解决方案：会在后台分别创建两套网络线程池和 IO 线程池的组合，它们分别处理数据类请求和控制类请求<br>问题：这样的话，如果控制类请求和数据类请求发送给 broker 端。<br>1.kafka 会先执行完控制类的线程池组合，而数据类的线程池阻塞？<br>2.还是说，两套线程池（控制类和数据类）互不影响？<br>3.如果是第一种，那么kafka源码如何判断控制类有消息在执行？通过获取控制类共享队列长度吗","like_count":0},{"had_liked":false,"id":322960,"user_name":"凯文小猪","can_delete":false,"product_type":"c1","uid":1980201,"ip_address":"","ucode":"36D8AD0229547F","user_header":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","comment_is_top":false,"comment_ctime":1637670855,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637670855","product_id":100029201,"comment_content":"提一个问题 对于同一个客户端发送的同一个分区的多个消息 ，kafka是如何保证网络线程并发写入请求队列依然有序的？<br>这一块没看出kafka是如何保证分区有序的","like_count":0},{"had_liked":false,"id":321906,"user_name":"云师兄","can_delete":false,"product_type":"c1","uid":1010459,"ip_address":"","ucode":"4475AF1598FBFD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/1b/4b397b80.jpg","comment_is_top":false,"comment_ctime":1637108573,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637108573","product_id":100029201,"comment_content":"文章中图片展示客户端直接连到broker，客户端是找到有相应主题数据的broker之前，是通过控制器跳转的吗","like_count":0},{"had_liked":false,"id":320603,"user_name":"云师兄","can_delete":false,"product_type":"c1","uid":1010459,"ip_address":"","ucode":"4475AF1598FBFD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/1b/4b397b80.jpg","comment_is_top":false,"comment_ctime":1636419433,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636419433","product_id":100029201,"comment_content":"Io线程处理完后投递到哪个响应队列中，是根据原来由哪个网络线程处理过来决定吗？也就是从哪个网络线程接收，就哪个响应吗？","like_count":0},{"had_liked":false,"id":309146,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1629960558,"is_pvip":false,"replies":[{"id":"112529","content":"它不像ZooKeeper那样会转发给leader，而是直接报错了","user_name":"作者回复","user_name_real":"胡夕","uid":"1288090","ctime":1630810203,"ip_address":"","comment_id":309146,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1629960558","product_id":100029201,"comment_content":"请教下：请求如果发送到非Leader节点broker，是不是会转发到leader节点，这一块是怎么个流程？","like_count":0,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525758,"discussion_content":"它不像ZooKeeper那样会转发给leader，而是直接报错了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630810203,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":298435,"user_name":"Geek_383ffd","can_delete":false,"product_type":"c1","uid":1834097,"ip_address":"","ucode":"C3E15ED58CB6DB","user_header":"","comment_is_top":false,"comment_ctime":1624101215,"is_pvip":false,"replies":[{"id":"108487","content":"常规的大小限制取决于你的磁盘容量","user_name":"作者回复","user_name_real":"胡夕","uid":"1288090","ctime":1624497478,"ip_address":"","comment_id":298435,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1624101215","product_id":100029201,"comment_content":"目前共享队列有大小限制吗？设置是多大，满了怎么办？","like_count":0,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522140,"discussion_content":"常规的大小限制取决于你的磁盘容量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624497478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296672,"user_name":"傻傻的帅","can_delete":false,"product_type":"c1","uid":1668617,"ip_address":"","ucode":"14A795523A682E","user_header":"https://static001.geekbang.org/account/avatar/00/19/76/09/62a10668.jpg","comment_is_top":false,"comment_ctime":1623113741,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623113741","product_id":100029201,"comment_content":"可以在原队列上保留一个百分比，用于控制指令的存储","like_count":0},{"had_liked":false,"id":294526,"user_name":"云师兄","can_delete":false,"product_type":"c1","uid":1010459,"ip_address":"","ucode":"4475AF1598FBFD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/1b/4b397b80.jpg","comment_is_top":false,"comment_ctime":1621990857,"is_pvip":false,"replies":[{"id":"107170","content":"主要区别就是并不是让每个请求运行在不同的线程中。","user_name":"作者回复","user_name_real":"胡夕","uid":"1288090","ctime":1622353571,"ip_address":"","comment_id":294526,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1621990857","product_id":100029201,"comment_content":"请问老师，一开始举例的单线程模式和每个请求一个线程的方案不合适，选用reactor模式，跟普通的线程池模式的区别是？","like_count":0,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520696,"discussion_content":"主要区别就是并不是让每个请求运行在不同的线程中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622353571,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1736462,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/7f/0e/e3a8dbd9.jpg","nickname":"Liujun","note":"","ucode":"3DB1F3CA57B5B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390472,"discussion_content":"IO多路复用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629856123,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":277858,"user_name":"归零","can_delete":false,"product_type":"c1","uid":1103208,"ip_address":"","ucode":"C99B8E93009A46","user_header":"https://static001.geekbang.org/account/avatar/00/10/d5/68/2201b6b9.jpg","comment_is_top":false,"comment_ctime":1612624886,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1612624886","product_id":100029201,"comment_content":"这节课讲的干货满满。设计思想很多都是共通的，学懂一个中间件，再看其他的就发现容易多了！","like_count":0},{"had_liked":false,"id":270780,"user_name":"102447","can_delete":false,"product_type":"c1","uid":2270904,"ip_address":"","ucode":"82B85EFB6AB052","user_header":"","comment_is_top":false,"comment_ctime":1609251639,"is_pvip":false,"replies":[{"id":"98432","content":"统一管理方便些。另外有些统计指标也依赖于这种集中式管理","user_name":"作者回复","user_name_real":"胡夕","uid":"1288090","ctime":1609723460,"ip_address":"","comment_id":270780,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1609251639","product_id":100029201,"comment_content":"胡大拿你好，请教个问题，响应队列里的response一定要通过网络线程池写回给客户端么。我的理解是：客户端的连接channel应该是缓存到本地map中啊，通过response上的客户端相关属性就能拿到相应channel进而给客户端发送响应就可以了阿。为什么一定要是网络线程池来处理呢？往予以解惑~~~~","like_count":0,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512748,"discussion_content":"统一管理方便些。另外有些统计指标也依赖于这种集中式管理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609723460,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1736462,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/7f/0e/e3a8dbd9.jpg","nickname":"Liujun","note":"","ucode":"3DB1F3CA57B5B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390473,"discussion_content":"channel不就是挂在网络线程池吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629856260,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":268494,"user_name":"夏日","can_delete":false,"product_type":"c1","uid":1214167,"ip_address":"","ucode":"A5DBEB3E437728","user_header":"https://static001.geekbang.org/account/avatar/00/12/86/d7/33d628b1.jpg","comment_is_top":false,"comment_ctime":1608216889,"is_pvip":false,"replies":[{"id":"97590","content":"最好保持一致。可以单独升级客户端。poll修改只与consumer端相关","user_name":"作者回复","user_name_real":"胡夕","uid":"1288090","ctime":1608516675,"ip_address":"","comment_id":268494,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1608216889","product_id":100029201,"comment_content":"胡老师你好，kafka客户端版本与broker的版本需要保持一致吗？因为项目中broker版本为1.0.0，消费端poll（long）方法会阻塞，在client2.0中已经换成poll（Duration），在不改变broker版本的情况下，是否可以升级客户端？poll方法的修改只与客户端相关，还是与broker也有关？","like_count":0,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511953,"discussion_content":"最好保持一致。可以单独升级客户端。poll修改只与consumer端相关","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608516675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":259172,"user_name":"傻傻的帅","can_delete":false,"product_type":"c1","uid":1668617,"ip_address":"","ucode":"14A795523A682E","user_header":"https://static001.geekbang.org/account/avatar/00/19/76/09/62a10668.jpg","comment_is_top":false,"comment_ctime":1604646570,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604646570","product_id":100029201,"comment_content":"可以借用oracle数据块的存储机制，在oracle数据块中，会预留一定比例的空间用作修改之用，那请求队列其实可以这样做，预留一定比例(具体到几个)给控制请求使用；平时当没有到达高水位时该 怎么放还怎么放，当到达高水位线后，数据请求就必须等待了，控制请求就可以正常进入。这样虽然牺牲一丁丁空间，但是却满足DRY原则，没有重复的逻辑功能，对于后期维护也方便","like_count":0},{"had_liked":false,"id":244211,"user_name":"hhhh","can_delete":false,"product_type":"c1","uid":1256101,"ip_address":"","ucode":"9E87017424B382","user_header":"https://static001.geekbang.org/account/avatar/00/13/2a/a5/625c0a2e.jpg","comment_is_top":false,"comment_ctime":1598430187,"is_pvip":false,"replies":[{"id":"89964","content":"网络线程仅做请求的分发，并不实际处理请求。因此你可以认为这时候的请求就是符合Kafka请求协议类型定义的字节数组","user_name":"作者回复","user_name_real":"胡夕","uid":"1288090","ctime":1598489799,"ip_address":"","comment_id":244211,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1598430187","product_id":100029201,"comment_content":"网络线程处理的请求，究竟是tcp连接的一个channel，还是已经解析出来的kafka自定义的命令","like_count":0,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504521,"discussion_content":"网络线程仅做请求的分发，并不实际处理请求。因此你可以认为这时候的请求就是符合Kafka请求协议类型定义的字节数组","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598489799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":228416,"user_name":"yes","can_delete":false,"product_type":"c1","uid":1386201,"ip_address":"","ucode":"612BF6884ED6CC","user_header":"https://static001.geekbang.org/account/avatar/00/15/26/d9/f7e96590.jpg","comment_is_top":false,"comment_ctime":1592662632,"is_pvip":false,"replies":[{"id":"84290","content":"网络线程主要是指Processor线程。","user_name":"作者回复","user_name_real":"胡夕","uid":"1288090","ctime":1592747821,"ip_address":"","comment_id":228416,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1592662632","product_id":100029201,"comment_content":"老师，网络线程指的是selector么？acceptor 将新建立的socket轮询注册到网络线程中？","like_count":0,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499027,"discussion_content":"网络线程主要是指Processor线程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592747821,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163067,"user_name":"AAA_叶子","can_delete":false,"product_type":"c1","uid":1325994,"ip_address":"","ucode":"1E93617D308EE0","user_header":"https://static001.geekbang.org/account/avatar/00/14/3b/aa/e8dfcd7e.jpg","comment_is_top":false,"comment_ctime":1576652013,"is_pvip":false,"replies":[{"id":"62104","content":"在producer部分的专栏有涉及到","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1576717321,"ip_address":"","comment_id":163067,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1576652013","product_id":100029201,"comment_content":"producer 发送消息给broker 这块还没讲呢，这里涉及到消息的分组和分批次发送。","like_count":0,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478237,"discussion_content":"在producer部分的专栏有涉及到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576717321,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151152,"user_name":"飞翔","can_delete":false,"product_type":"c1","uid":1068571,"ip_address":"","ucode":"65AF6AF292DAD6","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/1b/f4b786b9.jpg","comment_is_top":false,"comment_ctime":1573658708,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1573658708","product_id":100029201,"comment_content":"老师 kafka 为什么不用reactor 最后一种模式 把用boss reactor 和work reactor 模型 而用较简单的第一种reactor","like_count":0},{"had_liked":false,"id":133856,"user_name":"一道阳光","can_delete":false,"product_type":"c1","uid":1239557,"ip_address":"","ucode":"F35207CCCEC6E2","user_header":"https://static001.geekbang.org/account/avatar/00/12/ea/05/c0d8014d.jpg","comment_is_top":false,"comment_ctime":1568684814,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568684814","product_id":100029201,"comment_content":"控制类请求直接创建新的线程池执行。","like_count":0},{"had_liked":false,"id":133236,"user_name":"shjdwxy","can_delete":false,"product_type":"c1","uid":1017625,"ip_address":"","ucode":"3822D979DC35F6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/19/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1568456910,"is_pvip":false,"replies":[{"id":"51247","content":"相应的线程阻塞住，表现为请求处理延时增加","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1568593923,"ip_address":"","comment_id":133236,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568456910","product_id":100029201,"comment_content":"如果共享请求队列满了，会出现什么问题呢？","like_count":0,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467313,"discussion_content":"相应的线程阻塞住，表现为请求处理延时增加","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568593923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132033,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1568009523,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1568009523","product_id":100029201,"comment_content":"优先级队列就算解决了队列满的问题也可能造成数据类请求饥饿的问题，既然两者是不同类型的请求，我还是觉得分开设计会避免不少的问题，为以后的优化带来空间，不过有一个问题，控制类请求和数据类请求操作的对象或多或少肯定会有重合，遇到冲突的话现在是怎么解决的呢？","like_count":0},{"had_liked":false,"id":131635,"user_name":"Algoric","can_delete":false,"product_type":"c1","uid":1298722,"ip_address":"","ucode":"78D9850A88C254","user_header":"https://static001.geekbang.org/account/avatar/00/13/d1/22/706c492e.jpg","comment_is_top":false,"comment_ctime":1567828816,"is_pvip":false,"replies":[{"id":"50330","content":"由于Acceptor线程只接收请求然后转发，因此非常轻量级。通常情况下都不是瓶颈。你可以监控kafka.network:type=Acceptor,name=AcceptorBlockedPercent,listener={listenerName}来看看Acceptor线程的繁忙程度","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1567843256,"ip_address":"","comment_id":131635,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1567828816","product_id":100029201,"comment_content":"Acceptor单线程是不是存在单点问题？且单线程如果并发量过大会不会出现瓶颈？Netty的Acceptor应该也是使用了线程池吧，希望可以解答一下","like_count":0,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466551,"discussion_content":"由于Acceptor线程只接收请求然后转发，因此非常轻量级。通常情况下都不是瓶颈。你可以监控kafka.network:type=Acceptor,name=AcceptorBlockedPercent,listener={listenerName}来看看Acceptor线程的繁忙程度","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567843256,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1201577,"avatar":"https://static001.geekbang.org/account/avatar/00/12/55/a9/5282a560.jpg","nickname":"yic","note":"","ucode":"C8DC471B7C28B8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":169828,"discussion_content":"Netty的accept线程一般只需设置1个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581648732,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":125109,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1566089946,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566089946","product_id":100029201,"comment_content":"老师好，请教几个小问题。<br>1：细心的你一定发现了请求队列和响应队列的差别：请求队列是所有网络线程共享的，而响应队列则是每个网络线程专属的。这么设计的原因就在于，Dispatcher 只是用于请求分发而不负责响应回传，因此只能让每个网络线程自己发送 Response 给客户端，所以这些 Response 也就没必要放在一个公共的地方。<br>只能让每个网络线程自己发送response给客户端，这是否意味着，假如有100个请求就有100个响应的网络线程，那线程的创建比较耗费资源的问题还是存在的呀？<br><br>2：使用reactor模式，线程资源的节省是体现在处理线程比网络线程更轻量上嘛？另外处理线程和分发线程都是在同一台服务器还是分布在不同服务器，如果在一台服务器上，他的扩展性怎么实现？<br><br>担心优先级队列满的问题，能否将优先级队列也做分割处理，一个逻辑优先级队列被分割在N台物理机上，如果这样这个优先级队列恐怕需要自己实现了，难度比较大，但是一种思路。<br><br>我的理解集群具有无限的横向扩展的能力，就是借助了网络通信的力量，将N台物理机组成一个强大的逻辑机，将原来单机处理的资源管理工作上移到集群中有分布式应用框架开发人员来做啦！","like_count":0},{"had_liked":false,"id":118734,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1564443659,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564443659","product_id":100029201,"comment_content":"再请问一下老师, IO线程池为啥不涉及成3个共享队列, 一个是写请求共享队列,一个读请求共享队列, 一个控制类共享队列, 这样写消息共享队列因为是顺序写, 所以只用一个线程一直写就可以了, 这样还不需要线程上下文切换; 读请求共享队列因为可能不同消费者组的消费者消费进度不同可以有多个线程, 这样吧读写分开我感觉请求的处理效率可以进一步提高","like_count":0},{"had_liked":false,"id":118730,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1564443302,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564443302","product_id":100029201,"comment_content":"请问老师两个问题:<br>1. 网络线程池是不是在响应客户端上起到的作用更大, 我感觉在请求接受上, networkthread只是把请求放入共享请求队列, 是一个线程放还是多个线程放好像效率上没提高多少.<br>2. 如果是网络线程池是多个线程同时向共享队列里插入请求,那么怎么保证消息被顺序处理, 很可能后面的消息因为异步的原因先于前面的消息放入共享请求队列","like_count":0},{"had_liked":false,"id":118342,"user_name":"曾轼麟","can_delete":false,"product_type":"c1","uid":1451391,"ip_address":"","ucode":"D418371AC11270","user_header":"https://static001.geekbang.org/account/avatar/00/16/25/7f/473d5a77.jpg","comment_is_top":false,"comment_ctime":1564325457,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564325457","product_id":100029201,"comment_content":"补充一下前面的留言，外层优先队列只按照请求类来保证优先级，如果每次同类型的请求都有优先级的话，我建议再加一层同类型的内层优先队列，然后在这里面拉出链表，不过实现起来会稍微有点麻烦","like_count":0},{"had_liked":false,"id":118336,"user_name":"曾轼麟","can_delete":false,"product_type":"c1","uid":1451391,"ip_address":"","ucode":"D418371AC11270","user_header":"https://static001.geekbang.org/account/avatar/00/16/25/7f/473d5a77.jpg","comment_is_top":false,"comment_ctime":1564324750,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564324750","product_id":100029201,"comment_content":"继续使用优先队列，但是每个队列的节点都是一个node，允许有卫星数据（比如一个链表的引用），当同样等级或者类型的请求可以效仿hashmap发生hash冲突那样拉出一条链表，保存到堆里面，jvm允许的话这样就能拓展不会出现队列满的情况，同时保持着优先队列的特点","like_count":0},{"had_liked":false,"id":118331,"user_name":"曾轼麟","can_delete":false,"product_type":"c1","uid":1451391,"ip_address":"","ucode":"D418371AC11270","user_header":"https://static001.geekbang.org/account/avatar/00/16/25/7f/473d5a77.jpg","comment_is_top":false,"comment_ctime":1564324065,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564324065","product_id":100029201,"comment_content":"终于明白为什么broker可以配置两个listener了，那时候我看着官网还挺奇怪的","like_count":0},{"had_liked":false,"id":118106,"user_name":"rm -rf 😊ི","can_delete":false,"product_type":"c1","uid":1070908,"ip_address":"","ucode":"BC448EC4206D95","user_header":"https://static001.geekbang.org/account/avatar/00/10/57/3c/081b89ec.jpg","comment_is_top":false,"comment_ctime":1564243145,"is_pvip":false,"replies":[{"id":"43356","content":"不是。每类请求都有对应的网络线城市和IO线程池","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1564361774,"ip_address":"","comment_id":118106,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1564243145","product_id":100029201,"comment_content":"两者只是分开了，但也没解决上文说的，控制类请求比数据类请求优先的需求呀？希望老师解答一下。<br>另外，总结图写反了吧，网络线程池应该是处理控制类，IO线程池应该才是处理数据类请求吧？","like_count":0,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460264,"discussion_content":"不是。每类请求都有对应的网络线城市和IO线程池","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564361774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118024,"user_name":"aof","can_delete":false,"product_type":"c1","uid":1062864,"ip_address":"","ucode":"5815D63C4926BC","user_header":"https://static001.geekbang.org/account/avatar/00/10/37/d0/26975fba.jpg","comment_is_top":false,"comment_ctime":1564214171,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1564214171","product_id":100029201,"comment_content":"共享请求队列的作用是为了缓解上下游的压力吗？","like_count":0,"discussions":[{"author":{"id":1005126,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/56/46/abb7bfe3.jpg","nickname":"Weihai","note":"","ucode":"FAC5027BC24AC7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3146,"discussion_content":"共享队列先把请求接下来，可以提高并发量，解耦上下游处理压力","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564219815,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117923,"user_name":"cricket1981","can_delete":false,"product_type":"c1","uid":1001715,"ip_address":"","ucode":"758262F5958DA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/f3/f1034ffd.jpg","comment_is_top":false,"comment_ctime":1564192772,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564192772","product_id":100029201,"comment_content":"规避优先级队列方案中队列已满的问题可以考虑将队列中后进来的数据类请求清退到另一个队列或持久化到文件，以腾出队列空间给到控制类请求，待队列请求处理完再将其加载回原队列。","like_count":0},{"had_liked":false,"id":117906,"user_name":"calljson","can_delete":false,"product_type":"c1","uid":1505262,"ip_address":"","ucode":"A5F81A6A5B4497","user_header":"https://static001.geekbang.org/account/avatar/00/16/f7/ee/6eeb58a3.jpg","comment_is_top":false,"comment_ctime":1564188783,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564188783","product_id":100029201,"comment_content":"期待下一讲","like_count":0}]}