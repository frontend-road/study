{"id":740971,"title":"第 2 章 优质代码的内在特征","content":"<p>对于真正懂得如何写代码的高手来说，一段代码是否高质量，往往是一目了然的。之所以能做到这一点，是因为优秀的代码具有显而易见的特征。关注代码的这些特征，不仅能够快捷分辨优质代码和有问题的代码，也有助于推动设计质量的持续改善。这些特征，我称它们为优质代码的内在特征。</p>\n<p>本章选择了 7 个典型的优质代码的内在特征进行介绍。这些特征都是明显特征，即“一目了然”。也正因为这些特征如此简单而明显，所以它们对设计改善具有明显的杠杆效应。下面按照由基础到略微有些高级的顺序列出了这些特征。</p>\n<p>(1) 一致的编码风格。</p>\n<p>(2) 有意义的命名。</p>\n<p>(3) 简洁的行为实现。</p>\n<p>(4) 高内聚和低耦合的模块化结构。</p>\n<p>(5) 没有重复。</p>\n<p>(6) 没有多余的设计。</p>\n<p>(7) 具备自动化测试。</p>\n<p>其中第 (1) 条是对代码最基本的要求：代码应该整齐一致。第 (2) 条和第 (3) 条强调代码的可理解性：好代码要如同好文章一样，清晰、优雅。第 (4) 条至第 (6) 条反映了代码对变更和演进的支持能力。第 (7) 条强调了自动化测试。自动化测试是重要的代码资产，是代码质量的基础，也是代码演进的基础。</p>\n<p>和第 1 章类似，本章我们仍然关注特征本身，说明为什么它们是重要的，目的是让大家学会“鉴赏”，就“什么是美、什么是丑”达成一致的认知。至于“如何达到美”这个问题，我们留在后续章节深入讨论。</p><!-- [[[read_end]]] -->\n<h2 id=\"nav_point_28\">2.1　一致的编码风格</h2>\n<p>风格一致是对代码最基本的要求，门槛不高。在养成好的编程习惯、建立好的编程规范之后，风格一致是很容易做到的。形象地说，风格一致指的是“代码看上去像同一个人写出来的”。</p>\n<h3 id=\"nav_point_29\">2.1.1　需要一致的编码风格</h3>\n<p>为什么把一致的编码风格列为第一条呢？这是因为，代码是软件开发活动中最基本的信息媒介。没有人希望看到一段代码是一种布局，换一段代码就变成了另外一种布局。也没有人希望看到在一个地方是一种异常处理方式，在另外一个地方又是另一种。类似的情况还有很多。</p>\n<p>从空间维度讲，绝大多数软件组织的软件开发是以团队为单位进行的，需要许多开发者同时参与。从时间维度讲，一段代码的生命周期往往会跨越很长的时间，甚至会持续十几年、几十年。如果代码的风格不一致，那么很难想象开发者能在不同的代码风格之间无障碍地工作。不一致的编码风格会对代码的可理解性、可维护性产生非常大的影响。此外，从心理角度讲，风格不一致的代码会给人一种“敷衍”的感觉，使他们很难静下心来精心打磨设计。</p>\n<h3 id=\"nav_point_30\">2.1.2　通过编程规范约束编码风格</h3>\n<p>我们通常以编程规范的形式约束编码风格。编程规范是一个团队对代码风格做的约定。要想有效实施编程规范，需要注意如下 3 个方面。</p>\n<ul>\n<li>有成文的编程规范。</li>\n<li>团队成员对编程规范的约定有深刻的理解。</li>\n<li>编程规范是团队资产的一部分，会被刻意关注并持续演进。</li>\n</ul>\n<p>“有成文的编程规范”是一个非常基础的要求。这正如法律条文一样，首先得“有法可依”，才能做到“执法必严”。大公司往往拥有非常体系化的编程规范，如《阿里巴巴 Java 开发手册》<sup>[6]</sup>，该文件不仅在阿里巴巴内部具有重要影响，也影响了许多外部企业的开发者。对于一些尚未建立编程规范的企业和团队而言，选择一个与自己技术栈类似的大企业的编程规范作为基础，常常是一个好的起点。</p>\n<p>编程规范并不是一堆刻板的条文，而是最佳经验的总结。例如，在《阿里巴巴 Java 开发手册》的“集合处理”一节中，约定了 <code>hashCode</code> 和 <code>equals</code> 的重写必须一致、建议使用 <code>entrySet</code> 遍历 <code>Map</code> 而不是用 <code>keySet</code> 遍历等，这些要么和代码的正确性相关，要么和代码的执行效率相关。开发者除了要遵循编程规范，更要懂得编程规范背后的逻辑。只有理解了逻辑，才能真正地做到有效实施，并且保持编程规范的持续演进。</p>\n<h3 id=\"nav_point_31\">2.1.3　编程规范也要持续演进</h3>\n<p>既然编程规范体现了团队的经验总结，那么随着时间的推移，团队必然会积累新的经验和教训，这时编程规范也应该同步演进。</p>\n<blockquote>\n<p style=\"text-align: center\"><strong>扩展阅读</strong></p>\n<p>《阿里巴巴 Java 开发手册》从 2017 年 2 月发布第一个正式版本开始，到 2020 年 8 月，短短的 3 年半时间，就先后发布了 12 个版本，特别是在 1.4. 0 版本、1.5. 0 版本、1.6. 0 版本和 1.7. 0 版本中均增加了数量可观的规范（分别新增 14 条、21 条、34 条和 14 条）。这些增加的规范，往往来自团队认知水平的提升，这种提升以编程规范的形式获得了沉淀，从而为后续的开发活动提供支持。</p>\n</blockquote>\n<h3 id=\"nav_point_32\">2.1.4　通过代码评审和结对编程统一编码风格</h3>\n<p>编程规范在统一编码风格方面具有重要的作用，但它毕竟不可能覆盖代码的方方面面。在实践中，更多的统一是团队在日常的开发活动中逐渐形成的。例如，代码评审和结对编程就是两个统一编码风格非常有效的活动。</p>\n<p>代码评审是一个大家普遍认为非常有效的活动，但落地实施需要很多技巧。结对编程来自极限编程<sup>[7]</sup>，是一种非常有效的编程实践，尽管不少人对它持有怀疑态度，可是一旦能成功在团队中实施，收益还是非常明显的。结对编程不只是统一了编码的风格，也不只是一种“即时”的代码评审，其更重要的意义在于由它引发的密集交流，必然能更好地传播知识、产生更少的错误和编写出更易读的代码。本书的 10.4节会进一步介绍代码评审和结对编程。</p>\n<h3 id=\"nav_point_33\">2.1.5　编程规范示例</h3>\n<p>约定编程规范本身是一个专门的工作。本书仅给出典型的编程规范示例，更多具体的编程规范，请读者参阅相关技术书籍。</p>\n<p><strong>统一编码风格</strong></p>\n<p>风格类的编程规范，重点在于保证代码的可读性和风格的一致性。例如，如何使用空格、如何命名、如何使用大小写、是使用驼峰还是下划线、如何使用大括号，等等。比如在《阿里巴巴 Java 开发手册》中，关于在代码中应该使用 Tab 字符还是空格做了如下约定。</p>\n<blockquote>\n<p>【强制】采用 4 个空格缩进，禁止使用 Tab 字符。</p>\n</blockquote>\n<p>这个约定背后的考量，是 Tab 字符对应的空格数可以在编辑器中自定义。有些程序员可能把它设置为 4 个空格，有些程序员可能设置为 8 个。如果混用空格和 Tab 字符，那么在 Tab 字符对应 4 个空格的编辑器中正常显示的代码，在 Tab 字符对应 8 个空格的编辑器中会显示混乱。还有些编程规范中约定仅允许使用 Tab 字符，不允许使用空格，也能达到相同的效果。</p>\n<p><strong>传播最佳实践</strong></p>\n<p>在编码过程中会持续碰到一些典型情况，如前文提到的 <code>hashCode</code> 和 <code>equals</code>，如果不成对出现就可能出现问题。这些情况能否得到正确处理和代码质量密切相关。为了保证编程规范的最佳实践能够得以实施，我们常常以编程规范的形式把它们总结成文，这类编程规范的例子有抛出异常的策略、日志记录的策略等。</p>\n<p>我们仍然以《阿里巴巴 Java 开发手册》为例，来看其中的一条约定。</p>\n<blockquote>\n<p>【推荐】使用 JDK8 的 <code>Optional</code> 类来防止 NPE 问题。</p>\n</blockquote>\n<p>NPE 指的是空指针错误（Null Pointer Error）。<code>Optional</code> 类的核心目标就是避免 NPE 问题。类似这样最佳实践的问题，手册中常常使用“推荐”这个级别的编程规范进行约定。另外，该编程规范中的约束和建议还包括如何处理集合、如何使用数据库、如何构建项目的工程结构和二方库依赖、如何编写合格的单元测试等众多最佳实践和团队级约定。编程规范不仅体现了编码风格的一致性，也让团队成员积累的经验以编程规范的形式成为了团队资产。</p>\n<h2 id=\"nav_point_34\">2.2　有意义的命名</h2>\n<p>在编程规范中，肯定会提到命名。不过，命名仅仅出现在编程规范中是不够的。命名问题远远超出了“风格一致性”可以概括的范畴。好的命名能反映领域模型的概念（详见 4.1 节），同时也是意图导向编程的重要基础。</p>\n<h3 id=\"nav_point_35\">2.2.1　一个糟糕的例子</h3>\n<p>我们先来看下面这段示例代码。它节选自一个名为 Yhsj.java 的文件，这是一次大学课堂作业的学生作品。如果不继续向下看，我相信很多读者会和我一样，完全猜不到这个文件的内容是什么意思。</p>\n<pre class=\"code-rows\"><code>public class Yhsj {\n    public int[][] yanghui(int r) {\n        int a[][] = new int[r][];\n        for (int i = 0; i &lt; r; i++)\n            a[i] = new int[i + 1];\n        for (int i = 0; i &lt; r; i++) {\n            for (int j = 0; j &lt; a[i].length; j++) {\n                if (i == 0 || j == 0 || j == a[i].length - 1)\n                    a[i][j] = 1;\n                else\n                    a[i][j] = a[i - 1][j - 1] + a[i - 1][j];\n            }\n        }\n        return a;\n    }\n}</code></pre>\n<p><strong>代码清单 2.1</strong>　一个不好的杨辉三角形的实现</p>\n<p>类似这种代码，在大学作业中，甚至是在一些教材中都不算罕见。这段代码有很多问题。其中，类似于格式或者命名的问题是最显而易见的。例如，将 <code>Yhsj</code>（杨辉三角）这样的拼音缩写作为类名，是很多编程规范明确禁止的。更进一步，方法名 <code>yanghui</code> 也是一个有点别扭的命名。或许有读者会问，杨辉是一个中国人，不叫 <code>yanghui</code> 那叫什么？</p>\n<p>如果代码的作者在编写这段代码的时候能略仔细一点，那么仅需简单查阅就可以知道：杨辉三角的英文名是 Pascal Triangle。显然，尊重一个领域的通用说法才更合理，也能大大降低理解代码的成本。</p>\n<p>类名和方法名都和本节要讨论的命名有关。不过我们的分析还得更进一步。这段代码还有一个更严重、也更隐蔽的问题，就是应该出现的概念没有出现在代码中。</p>\n<h3 id=\"nav_point_36\">2.2.2　命名应该反映业务概念</h3>\n<p>具有一定编程经验的程序员都会明白，命名是软件开发中最重要和最困难的事情之一。不过，一旦掌握了命名逻辑，就会发现——为命名犯难不应该在编程的时候才发生，它应该被前移到问题分析阶段。命名困难的本质，是没有对业务概念建立正确的理解。</p>\n<p>在代码清单 2.1 中会出现 <code>Yhsj</code>、<code>yanghui</code> 这样的命名，是因为编写者不了解 Pascal Triangle 这个数学领域的通用概念。此外，代码中出现了大量的 <code>a[][]</code>、<code>i</code>、<code>j</code> 变量，变量名是简单了，但是业务概念丢失了，代码的可理解性自然不可能太好。</p>\n<blockquote>\n<p style=\"text-align: center\"><strong>糟糕的命名会伤害代码的可理解性</strong></p>\n<p>不好的命名等于是在给代码加密。有一定开发经验的读者可能听说过代码混淆（Obfuscated code）。在一定的业务场景下，出于保护源码的目的，可以对发布的编译后二进制代码进行混淆处理。例如，在 Java 语言中，如果没有进行代码混淆，那么可以反编译为 Java 字节码，得到近乎完整的源码。但是，如果代码经过混淆，那么即使反编译成功，也很难分析出程序的真正语义，这样就提高了逆向破解应用的难度。</p>\n<p>那么，代码混淆是如何做到的呢？重命名标识符就是最基本的混淆手段。经过重命名，代码标识符和业务概念已经完全没关系了，代码自然会变得非常难以理解。换句话说，在该使用业务概念的地方使用 <code>a</code>、<code>b</code>、<code>c</code> 这些变量，和混淆后的代码效果差不多——大幅提升了理解的难度。</p>\n</blockquote>\n<p>让我们回到杨辉三角形的例子，先从纯粹数学的角度来理解一下背后的逻辑。杨辉三角形打印出来应该是下面这样的<span class=\"comment-number\">1</span>。</p>\n\n<pre class=\"code-rows\"><code>1\n1 1\n1 2 1\n1 3 3 1\n1 4 6 4 1</code></pre>\n<p>它包含如下规律。</p>\n<ul>\n<li>规律 1：第 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00279.gif\" alt=\"n\" /> 行的数有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00279.gif\" alt=\"n\" /> 个。</li>\n<li>规律 2：每行的第一个数和最后一个数为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00280.gif\" alt=\"1\" />。</li>\n<li>规律 3：每行的其他数是它正上方的数和左上方的数之和。</li>\n</ul>\n<p>让我们记住这些规律，然后来看下面的代码。</p>\n<pre class=\"code-rows\"><code>public class PascalTriangle\n{\n    public int[] dataOf(int row) {\n        int[] data = new int[row + 1];\n        for (int col = 0; col &lt;= row; col++) {\n            data[col] = valueOf(row, col);\n        }\n        return data;\n    }\n\n    private int valueOf(int row, int col) {\n        if (isFirstOrLastElement(row, col)) {\n            return 1;\n        }\n        return valueOfUpper(row, col) + valueOfUpperLeft(row, col);\n    }\n\n    private int valueOfUpper(int row, int col) {\n        return valueOf(row - 1, col);\n    }\n\n    private int valueOfUpperLeft(int row, int col) {\n        return valueOf(row - 1, col - 1);\n    }\n\n    private boolean isFirstOrLastElement(int row, int col) {\n        return (col == 0 || col == row);\n    }\n}</code></pre>\n<p><strong>代码清单 2.2</strong>　杨辉三角形的更优实现</p>\n<p>代码清单 2.2 中的第 3 行至第 9 行反映的是规律 1，这部分代码只是完成了数值的拼装，它把如何计算数值的逻辑委托给了 <code>valueOf</code> 方法。第 11 行至第 16 行反映的是规律 2 和规律 3。<code>isFirstOrLastElement</code>、<code>valueOfUpper</code>、<code>valueOfUpperLeft</code> 都是为了表达规律 2 和规律 3 中的语义而引入的方法名，虽然这三个方法的实现代码都只有一行，且看起来多了一次方法调用，但是从可理解性的角度看，理解 <code>isFirstOrLastElement</code> 显然要比理解 <code>col == 0 || col == row</code> 更容易。如果不愿关心更多细节，甚至可以直接忽略第 17 行以后的代码。</p>\n<p>这是一个最简单的来自数学领域的小例子。在规模更大的业务系统中，情况其实也高度类似。一旦识别到了业务概念，那么代码的命名就有了清晰的业务概念作为基础，不会太困难。</p>\n<p>领域模型是对业务概念更规范的表述。本书的第 4 章将会介绍如何发现领域模型，第 8 章还会进一步介绍如何把领域模型映射到代码中。这些方法对提升代码的命名质量具有非常重要的指导意义。</p>\n<h3 id=\"nav_point_37\">2.2.3　避免从开发视角命名业务概念</h3>\n<p>从业务视角而不是开发视角命名代码，是程序员努力的方向。我们同样看一个简单且非常普遍的例子，请对比下面两段代码。</p>\n<pre class=\"code-rows\"><code>class Customer {\n    Address address;\n    void setAddress(Address address){\n        this.address = address;\n    }\n}</code></pre>\n<p><strong>代码清单 2.3</strong>　从开发视角命名方法</p>\n<pre class=\"code-rows\"><code>class Customer {\n    Address address;\n    void changeAddress(Address address){\n        this.address = address;\n    }\n}</code></pre>\n<p><strong>代码清单 2.4</strong>　从业务视角命名方法</p>\n<p><code>setAddress</code> 这个方法名反映的是程序员思维：<code>Customer</code> 类有一个成员变量叫 <code>address</code>，<code>setAddress</code> 用来改变这个变量的值。<code>changeAddress</code> 这个方法名反映的则是业务思维：存在一个业务概念叫客户（<code>Customer</code>），客户可以变更自己的地址（<code>changeAddress</code>）。</p>\n<p>如何才能写出更有业务意义的代码呢？提升编码时的业务意识只是一个方面，还需要一些较为高级的技巧。在第 9 章我们将会讨论由外而内的设计，这种实现方式配合第 8 章介绍的领域驱动设计的战术模式，能产出质量更高、更契合业务概念的代码。</p>\n<h3 id=\"nav_point_38\">2.2.4　面向设计意图进行命名优化</h3>\n<p>或许有些细心的读者已经注意到了，代码清单 2.2 中的一些代码命名和常见的约定有所不同。例如，在许多命名规范中，类名一般是名词，方法名一般是动词，或者动词+名词形成的动宾短语。例如，代码清单 2.4 中的 <code>Customer</code> 就是一个名词，<code>changeAddress</code> 是一个动宾短语。但是，为什么在代码清单 2.2 中，方法名出现了类似于 <code>dataOf(row)</code> 的词呢？</p>\n<p>确实，在大多数时候，一个合格的方法名应该是动宾短语。不过，在更好的设计中可以以更灵活的方式优化命名。形如 <code>dataOf</code> 的命名，是一种基于业务概念的进一步优化，其目的是提升代码的可读性。我们来看一段调用 <code>dataOf</code> 方法的代码。</p>\n<pre class=\"code-rows\"><code>class Main {\n    public static void main(String[] args) {\n        int rows = 5;\n        PascalTriangle triangle = new PascalTriangle();\n        for (int row = 0; i &lt; rows; i++){\n            print(triangle.dataOf(row));\n        }\n    }\n}</code></pre>\n<p><strong>代码清单 2.5</strong>　面向意图表达的方法命名示例</p>\n<p>请读者重点关注第 6 行的语句：<code>print(triangle.dataOf(row));</code>。把这条语句逐字翻译成文字，就是“打印三角形的第 <code>row</code> 行的数据”。如果僵化地遵循“方法名应该是动词或动宾短语”，那这条语句就要写成 <code>print(triangle.calculateData(row));</code>。仔细体会这两种写法，会明显感觉到前者的可读性要优于后者。</p>\n<p>好的代码，应该让人读起来像在阅读文章一样。在现代的框架、工具或者流行的项目中，有大量类似的写法。例如，在早期的 JUnit 测试框架中，仅提供了一种写断言的形式，类似于 <code>assertEquals(0,result)</code>。而现在，我们可以使用 <code>assertThat(result, is(0))</code> 这样的断言形式。从本质上讲这两个断言的写法是一样的。但是，从可读性上讲，明显后者要优于前者。</p>\n<p>把这种更接近业务语义的命名方式应用到接口定义上，就形成了一种更加有趣、也更加易用的接口定义方式，我们称之为流畅接口（Fluent Interface）。对比如下两段代码。</p>\n<pre>\nPerson person = new Person();\nperson.setName(\"name\");\nperson.setGender(Gender.Female);\nperson.setAge(10);<br />\n</pre>\n\n<p><strong>代码清单 2.6</strong>　使用 setter 的对象构造</p>\n<pre class=\"code-rows\"><code>Person person = Person.builder()\n        .name(\"name\")\n        .gender(Gender.Female)\n        .age(10)\n        .build();</code></pre>\n<p><strong>代码清单 2.7</strong>　使用流畅接口的对象构造</p>\n<p>这两段代码都是创建了 <code>Person</code> 对象并初始化其数据。对比来看，显然后者的表达力更强，代码也更为简洁优雅。</p>\n<h2 id=\"nav_point_39\">2.3　简洁的行为实现</h2>\n<p>无论是易于理解，还是易于演进，都意味着要编写更为简洁的代码。简洁，就是“少”“清晰”“简单”。简洁的反面是繁复，意味着“多”“烦琐”“复杂”。本节将从代码特征的角度，介绍简洁的行为实现的三个重要方面。</p>\n<p>(1) 代码元素（方法、类等）要尽量简短。</p>\n<p>(2) 代码的表达要清晰，抽象层次要一致。</p>\n<p>(3) 方法的实现复杂度要尽量低。</p>\n<p>这三个方面经常是彼此促进的，做好其中一个方面也会为另外两个方面带来提升。</p>\n<h3 id=\"nav_point_40\">2.3.1　代码元素要尽量简短</h3>\n<p>没有人喜欢看长长的代码。在工作环境中，我经常看到程序员把一个横着的显示器竖起来放，这往往是一个不太好的信号：代码太长了。</p>\n<p>不过，“代码元素（方法、类等）要尽量简短”这句话存在一定的歧义，需要加以解释。在 2.2 节的例子中，代码清单 2.1 中定义的 <code>Yhsj</code> 类的长度是 16 行，却只包含 1 个方法，这个方法占 14 行。在代码清单 2.2 中，<code>PascalTriangle</code> 类的长度达到了 29 行，包含 5 个方法，最长的方法占 7 行。可这两段代码实现的功能是完全相同的，那么在这种情况下，哪段代码算是更简短的呢？</p>\n<p><strong>简短是指“认知”层面的简短</strong></p>\n<p>要正确回答上面的问题，需要回到“认知”这个理解代码的核心维度上来，并不是哪段代码的总长度更短，哪段就更简洁。从认知层面讲，类、方法各是一个抽象层级。当代码阅读者理解一个类的时候，更关心方法这个层级，对于方法是怎么实现的则并不关心。更进一步，如果类的方法声明中区分了 <code>public</code> 和 <code>private</code>，那么代码阅读者首先会关心 <code>public</code> 方法。只有当理解了一个方法的时候，查看的才是实现方法的代码行这个层级。</p>\n<p>按照这种逻辑，当理解 <code>Yhsj</code> 类时面对的是 1 个方法；当理解 <code>PascalTriangle</code> 类时面对的也是 1 个方法，所以从类层级看二者没有本质区别。至于 <code>PascalTriangle</code> 类的另外 4 个 <code>private</code> 方法，代码阅读者只在需要分析 <code>PascalTriangle::dataOf</code> 方法时才会关心。这再次说明在类层级，这两个类的简短程度相同。</p>\n<p>当理解 <code>Yhsj::yanghui</code> 方法时，面对的是 14 行代码；当理解 <code>PascalTriangle::dataOf</code> 方法时面对的是 7 行代码，所以从方法层级看，代码清单 2.2 的实现更为简短。</p>\n<p><strong>设置一个关于简短的警戒值</strong></p>\n<p>在方法层级，尽管严格约定每个方法的长度是不现实的，但是设定一个警戒值还是有着重要的实践意义。过长的代码往往是设计不良的信号。Martin Fowler 在《重构》<sup>[8]</sup>中，将过长的方法列为代码的“坏味道”之一。至于多长才算是过长，在不同的语言、不同的业务上下文中可能有不同的解释。较好的处理办法是设定一个警戒值。例如，我会把警戒值设为 10 行，只要一个方法达到 10 行，我就会比较警惕：是不是这个方法过于复杂了？由于 10 行很容易感知，所以将它作为警戒值就很直观，并不需要一个代码统计工具作为辅助。</p>\n<p>代码清单 2.1 展示了一些开源代码的相关数据。我统计了包含的方法数量，同时计算了这些方法的代码行数的均值、中位数和最大值，供读者参考。</p>\n<p><strong>表 2.1</strong>　一些开源代码的相关数据</p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>开源代码</p></th>\n<th><p>方法数量（个）</p></th>\n<th><p>均值（行）</p></th>\n<th><p>中位数（行）</p></th>\n<th><p>最大值（行）</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>JUnit5<span class=\"comment-number\">2</span></p></td>\n<td><p>2 500</p></td>\n<td><p>2.7</p></td>\n<td><p>2</p></td>\n<td><p>36</p></td>\n</tr>\n<tr>\n<td><p>JUnit1<span class=\"comment-number\">3</span></p></td>\n<td><p>187</p></td>\n<td><p>6.3</p></td>\n<td><p>3</p></td>\n<td><p>165</p></td>\n</tr>\n<tr>\n<td><p>Depends<span class=\"comment-number\">4</span></p></td>\n<td><p>977</p></td>\n<td><p>5.4</p></td>\n<td><p>3</p></td>\n<td><p>66</p></td>\n</tr>\n<tr>\n<td><p>Spring-core<span class=\"comment-number\">5</span></p></td>\n<td><p>3 104</p></td>\n<td><p>5.7</p></td>\n<td><p>2</p></td>\n<td><p>819</p></td>\n</tr>\n<tr>\n<td><p>Netbeans<span class=\"comment-number\">6</span></p></td>\n<td><p>441 006</p></td>\n<td><p>6.9</p></td>\n<td><p>2</p></td>\n<td><p>7 213</p></td>\n</tr>\n</tbody>\n</table>\n\n\n\n\n\n<p>在统计代码行数量时使用了开源工具 javancss<span class=\"comment-number\">7</span>。其中，特别值得注意的是如下这些数据。</p>\n\n<ul>\n<li>JUnit5、Spring-core 和 NetBeans 的代码行数量中位数都是 2，JUnit1 和 Depends 的代码行数量中位数都是 3。也就是说，大多数方法的代码行数量在 2、3 行以下。</li>\n<li>在 Spring-core 和 NetBeans 中存在一些特别长的方法。如果读者去查看这些方法，就会发现它们确实较难阅读。</li>\n<li>JUnit 非常优秀。从代码简短性的视角看，JUnit1 已经很不错了，但是 JUnit5 更加优秀，可见一直在持续改进。</li>\n</ul>\n<p>如果读者去翻阅早期的技术书籍，就会发现对代码长度的要求曾经非常宽松。例如，在《代码大全》中，作者认为超过 200 行的程序才比较难以容忍。今天的技术环境已经很不一样了，不建议再参考这类数据。</p>\n<p>设定一个代码行数量的警戒值有助于编写更高质量的代码。之所以会有过长的方法，很多时候是因为在一个方法中做了太多事情。有意识地减少代码行（如抽取一个新方法）有助于发现不够内聚的设计，或者抽象层次不足等问题。一般来说，对复杂的方法进行简化就能得到更好的设计结果。这也是在 11.3 节将会介绍的核心策略。</p>\n<h3 id=\"nav_point_41\">2.3.2　代码的表达要清晰，抽象层次要一致</h3>\n<p>在 2.2 节讨论命名问题时，我们讲到了“好的代码，应该让人读起来像在阅读文章一样”。高质量的命名和一致的抽象层次，共同组成了这样的好代码。</p>\n<p>代码清单 2.2 就是这样的代码。它在任何一个方法中，都保持着同一个抽象层级。例如，在 <code>valueOf(int row, int col)</code> 方法中，它仅把注意力集中在杨辉三角形的规律 2 和规律 3 上，没有细化到实现层次，如判断某数是不是第一个数或最后一个数，也没有去关心如何获取正上方和左上方的数。作为对比，代码清单 2.1 中的 <code>yanghui</code> 方法做的事情就太复杂了，它把各个抽象层级的代码放到了一个方法中，既破坏了代码的可理解性，也让代码行变得冗长臃肿。</p>\n<p>在编码中做到“一致的抽象层次”并不是太困难，核心是要采用正确的编码顺序，也就是本书第 9 章将讲到的由外而内的设计和实现方法。我们可以先预览一段基于该方法编写的代码。</p>\n<pre class=\"code-rows\"><code>public void moveDown() {\n    if (isFallenBottom()) {\n        piledBlock.join(activeBlock);\n        piledBlock.eliminate(widthOfWindow());\n        fallDownIfPiledBlockHanged();\n        checkGameOver();\n        createActiveBlock();\n    } else {\n        activeBlock.moveDown();\n    }\n}</code></pre>\n<p><strong>代码清单 2.8</strong>　俄罗斯方块游戏中收到下落信号时的处理程序</p>\n<p>这是俄罗斯方块游戏中收到下落信号时的处理程序，这段代码的抽象层级就较为一致。许多类似的处理程序都没有达到如此好的抽象层级，例如下面的代码。</p>\n<pre class=\"code-rows\"><code>public void moveDownBadExample() {\n    if (collisionDetector.isCollision(activeBlock, borderBlock, MOVE_DOWN) ||\n        collisionDetector.isCollision(activeBlock, piledBlock, MOVE_DOWN)) {\n        piledBlock.join(activeBlock);\n        piledBlock.eliminate(widthOfWindow());\n        if (piledBlock.size() == 0) return;\n        while (!collisionDetector.isCollision(piledBlock, borderBlock, MOVE_DOWN))\n            piledBlock.moveDown();\n        if (piledBlock.size() &gt; 0) {\n            Cell c = piledBlock.getAt(piledBlock.size() - 1);\n            if (c.x == 0) {\n                ui.notifyGameOver();\n            }\n        }\n        activeBlock = nextBlock;\n        createNextBlock();\n    } else {\n        activeBlock.moveDown();\n    }\n}</code></pre>\n<p><strong>代码清单 2.9</strong>　抽象层级不够好的处理程序的实现</p>\n<p>这段代码和代码清单 2.8 实现的功能是一模一样的，只不过二者的抽象层级不一致：这段代码一会儿检测下落块是否和底部堆叠的方块重叠，一会儿连接底部堆叠块，一会儿又判断游戏是否已经结束，继而计算底部堆叠块的大小。代码阅读者的思维同样没有办法停留在一个抽象层级，他们被迫在“做什么”和“怎么做”之间反复跳转。</p>\n<p>关于由外而内的设计和实现方法，以及如何更好地实现一致的抽象层级，我们在第 9 章会进一步深入分析。</p>\n<h3 id=\"nav_point_42\">2.3.3　方法的实现复杂度要尽量低</h3>\n<p>计算机非常善于处理条件判断和循环逻辑，不过对人类来讲，条件语句和循环语句的组合及嵌套实在复杂。复杂了就容易出错。</p>\n<p>对比代码清单 2.1 和代码清单 2.2，前者包含一个两层嵌套的循环语句（第 6 行至第 13 行），第二层循环内部还有一个条件语句；后者包含的最深嵌套也只有一层循环（第 5 行至第 7 行）。因此，从可理解性上及出错的可能性上看，后者显然更优。</p>\n<p>针对控制代码结构的复杂性，有一些专门的度量指标，如本书 10.5 节将介绍的圈复杂度（McCabe 复杂度）和认知复杂度。不过，在日常的编码场景中，并不需要依赖度量指标来感知复杂度，只要多留意嵌套控制结构的数量即可。一旦超过两层，就应该非常警惕：是不是设计已经变得过于复杂了？复杂的控制结构，是非常容易识别的代码坏味道。一旦识别出这种问题，就需要关注控制结构的业务逻辑，重新组织代码结构，如提取方法或者进行抽象，以获得更为简短的代码。</p>\n<h2 id=\"nav_point_43\">2.4　高内聚和低耦合的结构</h2>\n<p>现实世界中的项目规模往往相当庞大。例如，一些大型项目可能有数十万行，甚至上百万、上千万行代码。如何才能在这样的项目上良好工作？模块化就是提升代码可理解性、可演进性、可复用性的关键。</p>\n<p>即使是只有几百行代码的程序，高质量的模块化和低质量的模块化带来的影响也截然不同。从设计层面看，模块化分解的最高指导原则是高内聚，模块间协作的最高指导原则是低耦合。</p>\n<blockquote>\n<p>高内聚、低耦合是提升代码可理解性、可演进性、可复用性的关键。</p>\n</blockquote>\n<h3 id=\"nav_point_44\">2.4.1　高内聚</h3>\n<p>高内聚描述了一个代码元素<span class=\"comment-number\">8</span>边界内内容的紧密程度。高内聚意味着以下两点。</p>\n\n<ul>\n<li>凡是紧密相关的东西，都应该放在一起。</li>\n<li>凡是被放在一起的东西，都是紧密相关的。</li>\n</ul>\n<p>图 2.1 是一个关于内聚的示意图，能方便读者对高内聚建立更深刻的印象。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00281.jpeg\" alt=\"\" width=\"75%\" style=\"width: 75%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 2.1</strong>　内聚示意图</p>\n<p><strong>低内聚代码的不良影响</strong></p>\n<p>为什么要强调高内聚呢？因为内聚性密切影响了第 1 章要求的易于理解、易于演进、易于复用的特征。不内聚的代码会增加理解难度、降低演进能力、降低复用的可能性。我们先来看一段真实代码，这段代码具有明显的内聚问题。</p>\n<pre class=\"code-rows\"><code>public AccountService {\n    public LoginResultDTO login(String accountName, String securedPassword) {\n        Account account = getAccount(accountName, securedPassword);\n        if (account == null) {\n            throw new RequestedResourceNotFound(\"账号或密码不正确!\");\n        }\n        LoginResultDTO r = new LoginResultDTO();\n        if (AccountType.STUDENT.equals(account.getDomain())) {\n            List&lt;RecordConsumptionDTO&gt; consumptionRecords = consumptionService\n            .getByAccount(account.getId());\n            if (consumptionRecords != null &amp;&amp; consumptionRecords.size() &gt; 0) {\n                // 存在消费记录, 代码略\n            } else {\n                // 不存在消费记录, 代码略\n            }\n        }\n        String token = buildSession(account);\n        r.setToken(token);\n        r.setAccount(helper.toAccountDTO(account));\n        return r;\n    }\n}</code></pre>\n<p><strong>代码清单 2.10</strong>　一段低内聚的代码</p>\n<p>代码清单 2.10 是低内聚的，它的问题非常容易分辨。从方法名上看，这个方法和登录（<code>login</code>）相关。这段代码的第 3 行至第 7 行、第 17 行至第 20 行确实都是处理和登录相关的内容。比较奇怪的是：从第 8 行开始，这个方法做了一些别的工作，它会根据账户类型去查询消费记录。出现这种情况的原因很可能是在登录功能开发完成后，收到了在登录成功界面上根据消费记录展示某些信息的新需求。</p>\n<p>需求固然没有问题，但是不应该这样设计。把和消费记录相关的逻辑加入 <code>login</code> 方法中，会产生以下几个显而易见的后果。</p>\n<ul>\n<li>从易于理解角度看，代码的可理解性下降了。代码阅读者的本意只是搞懂登录的逻辑，却不得不了解和消费记录相关的问题。</li>\n<li>从易于演进角度看，代码变更的可能性增加了。登录逻辑的变化频率一般较低，但是消费记录的逻辑，以及消费记录的展示是否要和登录动作放在一起都有更多变化的可能。一段代码多了一个变化源，代码变更的可能性必然也会增加。</li>\n<li>从易于复用的角度看，登录功能本来是一个通用资产，可在各种场景下使用，但是加入了和消费记录相关的信息后，就只能在本系统中使用了。</li>\n</ul>\n<p>尽管在某个特定的业务场景下，消费记录和用户的登录动作会被组合，但是从概念上看，这样的设计是不内聚的，它们至多是相关的概念，很难说是“紧密相关”。</p>\n<p>如何才能优化代码清单 2.10 的内聚性呢？一个可能的改造方法如下。</p>\n<ul>\n<li>让 <code>AccountService::login</code> 方法聚焦登录相关的业务逻辑；</li>\n<li>新建或复用消费记录相关的类 <code>ConsumptionRecordService</code>，提供和消费记录相关的服务；</li>\n<li>在外围增加一个面向特定应用场景的类 <code>UserLoginService</code>，组合 <code>AccountService</code> 和 <code>ConsumptionRecordService</code> 的能力。</li>\n</ul>\n<p>图 2.2 展示了重新分配职责之后的结果。这样的设计让登录模块的职责变得内聚，相应地也增强了这一模块的可理解性、稳定性、可复用性。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00282.jpeg\" alt=\"\" width=\"65%\" style=\"width: 65%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 2.2</strong>　通过职责分解提升内聚性<span class=\"comment-number\">9</span></p>\n\n<p><strong>更高标准的高内聚</strong></p>\n<p>内聚性差一般是显而易见的。如代码清单 2.10 这样的代码，只要阅读者稍微有点内聚性的意识，就不难判断这是低内聚代码，存在改进空间。但是，有大量设计处于内聚性差和内聚性好的中间地带，这才是设计的难点所在。</p>\n<p>代码清单 2.11 就是一段较难判断内聚性好坏的代码，作用是打印特定目录下的 Java 文件名。</p>\n<pre class=\"code-rows\"><code>import java.io.File;\nimport java.util.Arrays;\nimport org.apache.commons.io.FilenameUtils;\n\npublic class JavaFileNamePrinter {\n    /**\n     * 入口方法 打印出所有以 .java 结尾的文件名\n     * @param rootPath - 需要查找的根路径\n     */\n    public void printJavaFiles(String rootPath) {\n        File dir = new File(rootPath);\n        printJavaFiles(dir);\n    }\n    /**\n     * 实际执行的可递归调用的打印 Java 文件名的方法\n     */\n    private void printJavaFiles(File node) {\n        if (isJavaFile(node))\n            System.out.println(node.getAbsolutePath());\n        // 遍历子节点（包含文件和目录），递归调用 printJavaFiles\n        if (!node.isDirectory()) return;\n        File[] subnodes = node.listFiles();\n        Arrays.asList(subnodes).forEach(subnode-&gt;printJavaFiles(subnode));\n    }\n    private boolean isJavaFile(File node) {\n        if (!node.isFile()) return false;\n        return FilenameUtils.getExtension(node.getName()).endsWith(\"java\");\n    }\n}</code></pre>\n<p><strong>代码清单 2.11</strong>　一段较难判断内聚性好坏的代码</p>\n<p>从表面上看，无论编写规范性、命名规范性，还是方法的简短性，这段代码都是合格的。同时它的功能也不复杂，职责看起来也比较相关。那这段代码有没有内聚性问题呢？其实，这是没有唯一答案的。在有些场景下，这是合格的代码。换一种场景，这段代码就可能需要改进。</p>\n<p>特别关心答案的读者可以查看 2.5 节的讨论和另外一个版本的实现（代码清单 2.16）。它们均源自一个重要的设计概念：关注点分离。之所以在这里要特别提到这种更高标准的高内聚，是希望读者能留意软件的高内聚、低耦合和上下文强烈相关，设计不足和过度设计都是不可取的。一分不多一分不少是程序员在设计方面需要追求的目标，而演进式设计的思想在这一目标的达成上扮演了关键的角色，本书将在第 11 章展开讨论。</p>\n<h3 id=\"nav_point_45\">2.4.2　低耦合</h3>\n<p>内聚反映了设计单元内部的相关性，耦合则是设计单元之间相关性的表征。如果两个设计单元之间存在某种关系，使得当一个设计单元发生变化或者出现故障时，另外一个设计单元也会受到影响，那我们就说这二者之间存在耦合。</p>\n<p>内聚和耦合是彼此影响的两个因素。不然的话，只要简单地把所有代码都写在一个模块里面，那耦合自然就消失了。但是这样的模块不可能是高内聚的。</p>\n<p>耦合不可避免。只要是模块化设计，就必然会出现耦合——设计单元之间的协作是实现丰富功能的基础。但是，不同设计产生的耦合是不一样的。过度耦合是软件设计不稳定、不健壮的根源。如何才能避免过度耦合的设计呢？</p>\n<p><strong>避免过度耦合的设计</strong></p>\n<p>要理解耦合，必须先理解依赖。耦合和依赖有着紧密的联系。一般来说，管理好了依赖，也就解决了大多数耦合问题。图 2.3 展示了几种不同情况下的依赖示例。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00283.jpeg\" alt=\"\" width=\"75%\" style=\"width: 75%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 2.3</strong>　几种不同的依赖</p>\n<p>图 2.3 中的每一个圆圈都代表一个设计单元，它可能是类，也可能是模块或者系统。箭头代表设计单元之间的某种依赖关系，如 A 使用了 B 的方法或者数据，甚至 A 只是简单地共享了 B 的知识，那么 A 就依赖于 B。</p>\n<p>下面分别介绍这四种依赖形态对耦合的影响。</p>\n<p><strong>(1) 循环依赖造成紧耦合。</strong>图 2.3 中的①表示 A 和 B 之间存在循环依赖。循环依赖是一种非常紧的耦合。因为 A 的变化会引起 B 的变化，B 的变化也会引起 A 的变化，所以 A 和 B 本质上是一个整体，而不是两个不同的设计单元。</p>\n<p>循环依赖往往意味着设计不合理，或者依赖粒度过大。图 2.4 是一个真实场景的案例，其中包 <code>domain</code> 和包 <code>infrastructure</code> 之间存在循环依赖。如果仔细分析，就会发现只是类 <code>InvoiceRateService</code> 依赖了 <code>StringUtils</code>，类 <code>InvoiceRepoImpl</code> 实现了 <code>InvoiceRepo</code> 定义的接口。只要重新调整包 <code>infrastructure</code> 的粒度，把它划分为包 <code>lang</code> 和包 <code>database</code>，循环依赖就消失了。调整后的结果如 图 2.5 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00284.jpeg\" alt=\"\" width=\"40%\" style=\"width: 40%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 2.4</strong>　模块分割过大，造成循环依赖</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00285.jpeg\" alt=\"\" width=\"40%\" style=\"width: 40%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 2.5</strong>　调整模块粒度，消除循环依赖</p>\n<p><strong>(2) 依赖层级越深，耦合越紧。</strong>图 2.3 中的②表示 C 依赖 D，D 依赖 E。当 E 变化时，不仅 D 会受到影响，C 也会。所以，在这种依赖中，C 和 E 也存在耦合关系。依赖链越长，耦合影响的范围就越广。尽管链式依赖在设计中无可避免，但是存在许多能够减少依赖链长度的方法。</p>\n<p>图 2.6 展示的是一种链式依赖，<code>AccountService</code> 要用到数据库封装 <code>DBWrapper</code>，<code>DBWrapper</code> 又依赖于第三方代码库 <code>ThirdPartyLibrary</code>。当 <code>ThirdPartyLibrary</code> 更新时，<code>AccountService</code> 也可能受到影响。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00286.jpeg\" alt=\"\" width=\"30%\" style=\"width: 30%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 2.6</strong>　非必要的链式依赖</p>\n<p>让我们分析如何解决这个问题。<code>AccountService</code> 真正关心的并不是 <code>DBWrapper</code> 如何实现，而只是需要它提供的数据库访问服务。那把这种服务封装成接口 <code>AccountRepository</code>，然后让 <code>DBWrapper</code> 实现这个接口，<code>ThirdPartyLibrary</code> 的更新就不会影响 <code>AccountService</code> 了，如图 2.7 所示。这种通过接口解耦依赖的方式，就是著名的依赖倒置。在 6.1 节还会对依赖倒置做更详细的介绍。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00287.jpeg\" alt=\"\" width=\"65%\" style=\"width: 65%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 2.7</strong>　通过依赖倒置断开链式依赖<span class=\"comment-number\">9</span></p>\n\n<p><strong>(3) 依赖范围越广，耦合越严重。</strong>图 2.3 中的③表示 F 依赖于 G、H、I。在这种情况下，只要 G、H、I 中的任何一个发生变化，F 就会发生变化。所以，和依赖范围更小的设计单元相比，F 的稳定性相对较弱。此时如果能想办法降低 F 依赖的设计单元的数量，它的稳定性就可以得到增强。</p>\n<p>依赖范围过大，往往也和设计单元承担的职责过多有关。下面是代码清单 2.10 中类 <code>AccountService</code> 的部分声明。</p>\n<pre class=\"code-rows\"><code>public class AccountService {\n    AccountRepository repo;\n    SesssionManager sessionManager;\n    StudentService studentService;\n    ConsumptionService consumptionService;\n    // 其他\n    public LoginResultDTO login(String accountName, String securedPassword)\n    {...}\n}</code></pre>\n<p><strong>代码清单 2.12</strong>　职责过多引起依赖范围过大</p>\n<p>代码清单 2.12 中的 <code>StudentService</code> 和 <code>ConsumptionService</code> 的依赖显然是有问题的。造成这种问题的原因，是原来 <code>login</code> 方法的职责不够内聚，增加了不必要的功能。图 2.2 通过职责分解调整了 <code>login</code> 方法的职责，把和消费记录相关的内容移到了别的类中，自然也就消除了 <code>AccountService</code> 对 <code>StudentService</code> 和 <code>ConsumptionService</code> 的依赖。</p>\n<p><strong>(4) 全局依赖和隐式依赖让耦合难以管理。</strong>图 2.3 中的④代表 J 和 K 同时依赖 L。根据 L 类型的不同，会导致 J 和 K 之间出现不同类型的耦合。</p>\n<ul>\n<li>当 L 是一个全局变量时<span class=\"comment-number\">10</span>，J 和 K 会建立一种严重的耦合。因为 J 和 K 的状态会在缺乏设计可见性的情况下互相影响，所以要尽量避免这种耦合。</li>\n<li>当 L 是一个外部模块时<span class=\"comment-number\">11</span>，J 和 K 会同时受到 L 变化的影响，形成共同变更的耦合关系。当 J 和 K 对 L 的外部耦合可能发生变化时，更好的处理方案是建立一个 L 的封装层，让 J 和 K 依赖于该封装层。</li>\n<li>当 L 是一个隐含的知识，J 和 K 都与 L 没有实际的代码联系时，J 和 K 会产生隐式依赖。最典型的情况是，J 和 K 为两段重复的代码，一旦这份代码背后的逻辑发生变化，J 和 K 往往需要同步修改。</li>\n<li>当 L 是一个稳定的接口时，J 和 K 之间没有耦合关系。</li>\n</ul>\n\n\n<p><strong>(5) 对内部状态和数据的依赖是严重的耦合。</strong>对内部状态和数据的依赖在传统设计耦合理论中被称为内容耦合（Content Coupling）<sup>[9]</sup>。虽然内容耦合不能简单地用图形表达，图 2.3 中也没有相应的依赖，但是内容耦合会破坏封装性，是严重的耦合。下面是一个内容耦合的例子。</p>\n<pre class=\"code-rows\"><code>public double getArea(Sector s){\n    double result = s.getAngle() * s.getRadius() / 360;\n    return result;\n}</code></pre>\n<p><strong>代码清单 2.13</strong>　对内部数据直接操作造成内容耦合</p>\n<p>这个例子虽然看起来比较正常，但是它隐含地让 <code>getArea</code> 方法指定了扇形对象 <code>Sector</code> 的内部结构表示方式。（扇形中圆心角的表示方式一定是角度吗？可不可以是弧度呢？）良好的面向对象设计原则可以消除内容耦合。更合理的做法是把 <code>getArea</code> 方法的职责赋予 <code>Sector</code> 对象。</p>\n<pre class=\"code-rows\"><code>public double getArea(Sector s){\n    double result = s.getArea();\n    return result;\n}</code></pre>\n<p><strong>代码清单 2.14</strong>　通过面向对象封装解决内容耦合</p>\n<p>在实际项目中常见的设计反模式，如 Smart UI<span class=\"comment-number\">12</span> 和贫血模型<span class=\"comment-number\">13</span>，都是封装不足导致的内容耦合的结果。针对这种问题，最行之有效的做法是：除了纯粹的数据类，都应该尽量少暴露 <code>getter/setter</code> 方法。当一个对象对外暴露了 <code>getter/setter</code> 方法时，很容易引入不必要的对内部状态和数据的依赖。</p>\n\n\n<p>耦合不局限于代码层面，它可以发生在设计的任何粒度上。例如，如果两个系统之间是通过一组 API 定义进行通信，那这两个系统之间就基于这组 API 形成了耦合，当你开发的系统使用了某种第三方框架，或者使用了某种消息通信的基础设施时，同时也在你开发的系统和该第三方框架以及消息通信基础设施之间建立了耦合。框架、通信基础设施或者 API 的变化都会影响依赖这些内容的模块。</p>\n<h2 id=\"nav_point_46\">2.5　没有重复</h2>\n<p>重复是一种特殊的耦合。有经验的开发者会对代码中的重复特别敏感，因为重复代码不仅会影响到代码的易于理解、易于维护特征，往往也意味着拥有改善设计的机会。从设计角度看，重复代码具有以下特点。</p>\n<ul>\n<li>重复代码增加了理解难度。重复代码必然会增加代码量，也就增加了阅读代码的工作量。而且，如果这些重复代码存在细微的不同，那这些不同很容易被忽视，从而导致重复代码更加难以理解，甚至因此引入错误。</li>\n<li>重复代码加大了维护难度。如果重复代码中存在缺陷，那么很可能需要逐一修复每个重复实例。如果不了解系统中存在哪些重复实例，就很容易造成遗漏。更进一步，由于重复代码自身存在的差异以及所处的上下文环境有所不同，往往需要分别分析每个重复实例，这又加大了维护的工作量。</li>\n<li>重复代码往往隐含着改善设计的空间。重复代码本质上是一种重复的概念。如果以重复代码为表象，对重复概念加以识别和抽象，就有希望通过消除重复来改善设计。</li>\n</ul>\n<h3 id=\"nav_point_47\">2.5.1　DRY 原则</h3>\n<p>对于代码中的重复问题，Andy Hunt 和 Dave Thomas 提出了著名的 DRY（Don't Repeat Yourself）原则<sup>[10]</sup>，也就是“不要重复你自己”。DRY 原则背后的逻辑是：</p>\n<blockquote>\n<p>在一个系统中，每一块知识的表达，都应该是唯一、无歧义和权威的。</p>\n</blockquote>\n<p>这句话和 2.4 节讲到的基于知识的隐式依赖是同一个着眼点。只要在两个地方存在对同一个知识的表达，那么一旦这个知识改变了，这两个地方就需要一起改变。而且，既然这个知识可以被单独改变，就意味着这是一个单独的关注点，应该被分离出来，成为一个内聚的模块。</p>\n<h3 id=\"nav_point_48\">2.5.2　造成重复的原因</h3>\n<p>重复代码的引入，可能有多种原因。我们从一个最常见的场景开始分析，假如我们已经实现了列出指定目录下的 Java 文件名的代码（代码清单 2.11），现在有了一个新的业务需求：打印指定目录下的所有文本文件的内容。这是两个看起来有点类似，但是不尽相同的需求。</p>\n<p>如果项目进度恰好紧张，需要尽快实现该功能，那么对于正在完成这项工作的程序员而言，他下意识的反应很可能是复用代码清单 2.11 中的代码。于是，复制并修改就产生了以下代码。</p>\n<pre class=\"code-rows\"><code>import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.util.Arrays;\nimport org.apache.commons.io.FilenameUtils;\n\npublic class TextContentPrinter {\n    /**\n     * 入口方法 打印所有的以 .txt 结尾的文件内容。\n     * @param rootPath - 需要查找的根路径\n     */\n    public void printTextFileContents(String rootPath) {\n        File dir = new File(rootPath);\n        printTextFileContents(dir);\n    }\n    /**\n     * 实际执行的可递归调用的打印 *.txt 文件内容的方法\n     */\n    private void printTextFileContents(File node) {\n        if (isTextFile(node)) {\n            Files.readAllLines(node.toPath()).forEach(line-&gt;System.out.println(line));\n        }\n        //遍历子节点（包含文件和目录），递归调用 printTextFileContents\n        if (!node.isDirectory()) return;\n        File[] subnodes = node.listFiles();\n        Arrays.asList(subnodes).forEach(subnode-&gt;printTextFileContents(subnode));\n    }\n    private boolean isTextFile(File node) {\n        if (!node.isFile()) return false;\n        return  FilenameUtils.getExtension(node.getName()).endsWith(\"txt\");\n    }\n}</code></pre>\n<p><strong>代码清单 2.15</strong>　<code>TextContentPrinter</code>：复制 - 修改自代码清单 2.11</p>\n<p>仔细对比代码清单 2.15 和代码清单 2.11，会发现这两段代码看起来差不多，但是又不完全一样——这是重复代码最典型的表现。在软件设计中，下面几类<span class=\"comment-number\">14</span>都属于重复。</p>\n\n<ul>\n<li>完全相同的代码。</li>\n<li>模式一致的代码。</li>\n<li>模式一致，夹杂一些差异的代码。</li>\n<li>功能相同，实现方式不同的代码。</li>\n</ul>\n<p>产生重复的原因有很多。有时候是时间压力导致的复制 - 粘贴式编程方式，有时候是程序员担心在既有的方案上直接改动可能会破坏原有的功能，有时候是原来的代码关注点分离得不好，还有时候是需要改动的代码的所有权属于其他开发者或组织，自己没有办法直接修改。更多时候，重复是上述多种原因综合作用的结果。</p>\n<p>一旦不正确地接受了形如代码清单 2.15 和代码清单 2.11 的重复，就给未来的维护者带来了不好的范例，代码的腐化速度会逐渐变快。例如，当出现了一个新的需求——统计指定目录下的所有文件的个数时，会以更快的速度创造出一个新的代码重复副本。有句话叫“习惯成自然”，一旦某种编码风格形成习惯，久而久之，也就没人觉得这种重复是一种问题了。</p>\n<h3 id=\"nav_point_49\">2.5.3　通过消除重复改善设计</h3>\n<p>大多数时候，重复可能会引起维护问题，但是并不一定有害。例如，如果一段重复的代码从来都没有需要修复的缺陷，也从来没有演进的需求，那么在代码中保留这些重复，也很难说有根本性的问题。</p>\n<p>但是，无论重复是否真正有害，关注代码中的重复都能带来有价值的收益。最大的收益就是启发程序员注意关注点分离。我们分析一下代码清单 2.15 和代码清单 2.11 中的关注点，可以很容易得到如图 2.8 所示的结果。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00288.jpeg\" alt=\"\" width=\"85%\" style=\"width: 85%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 2.8</strong>　从重复现象中发现关注点分离的机会</p>\n<p>根据图 2.8，容易把通用职责从两段代码中分离出来，得到代码清单 2.16。它把代码清单 2.11 中的职责拆分为两个关注点：(1) 遍历目录文件；(2) 判断遍历到的每个文件的类型，并输出文件名。</p>\n<pre class=\"code-rows\"><code>public class FileTraversal {\n    private FileVisitor visitor;\n    public FileTraversal(FileVisitor visitor){\n        this.visitor = visitor;\n    }\n    public void travers(String path) {\n        File dir = new File(path);\n        travers(dir);\n    }\n    public void travers(File root) {\n        File[] files = root.listFiles();\n        Arrays.asList(files).forEach(f-&gt;visitor.visit(f));\n    }\n}\n\npublic interface FileVisitor {\n    void visit(File file);\n}\n\npublic class JavaFileNamePrinter implements FileVisitor {\n    @Override\n    public void visit(File file) {\n        if (isJavaFile(file))\n            System.out.println(file.getAbsolutePath());\n    }\n\n    private boolean isJavaFile(File file) {\n        if (!file.isFile()) return false;\n        return FilenameUtils.getExtension(file.getName()).endsWith(\"java\");\n    }\n\n    public void printJavaFiles(String rootPath) {\n        FileTraversal fileTransversal = new FileTraversal(this);\n        fileTransversal.travers(rootPath);\n    }\n}</code></pre>\n<p><strong>代码清单 2.16</strong>　基于 <code>Visitor Pattern</code> 的文件遍历并打印 Java 文件名}</p>\n<p>其中，<code>FileTraversal</code> 和 <code>FileVisitor</code> 是一个设计单元，它们负责完成目录文件的遍历，并对外部用户提供扩展点 <code>FileVisitor</code>。<code>JavaFileNamePrinter</code> 是一个设计单元，基于 <code>FileTraversal</code> 提供的遍历能力完成需求中的打印 Java 文件名的功能。图 2.9 是代码清单 2.16 对应的类图。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00289.jpeg\" alt=\"\" width=\"55%\" style=\"width: 55%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 2.9</strong>　分离通用职责</p>\n<p>对比两段代码，可以看出，代码清单 2.16 的内聚性要比代码清单 2.11 的好。通过分离关注点，我们还提升了代码的可复用性。利用代码清单 2.16 的设计，在遇到新的需求，如输出某个目录下的所有文本文件的内容时，我们就没有必要再像代码清单 2.15 那样冗余，可以直接非常简洁地写出如下代码。</p>\n<pre class=\"code-rows\"><code>public class TextContentPrinter implements FileVisitor {\n    @Override\n    public void visit(File file) {\n        if (isTextFile(file)) {\n            Files.readAllLines(file.toPath()).forEach(line -&gt; System.out.println(line));\n        }\n    }\n\n    private boolean isTextFile(File node) {\n        if (!node.isFile()) return false;\n        return FilenameUtils.getExtension(node.getName()).endsWith(\"txt\");\n    }\n\n    public void printTextFileContents(String rootPath) {\n        FileTraversal fileTransversal = new FileTraversal(this);\n        fileTransversal.travers(rootPath);\n    }\n}</code></pre>\n<p><strong>代码清单 2.17</strong>　基于 <code>Visitor Pattern</code> 的文件遍历并打印文本文件内容</p>\n<p>和代码清单 2.15 相比，这段代码不仅减少了 8 行，更重要的是我们无须知道如何实现遍历目录文件，只需要关心在遍历到具体的文件时做什么事情。</p>\n<p>顺便提一下，这是一个已经被实践检验过的设计。从 Java 7 开始，Java 的 <code>nio</code> 类库已经内建了名为 <code>Files.walkFileTree</code> 的方案，应用的就是刚才提及的关注点分离原则。在实际的工程项目中，程序员已经无须编写 <code>FileTraversal</code>，直接应用 <code>nio</code> 类库的 <code>Files.walkFileTree</code> 方案即可。</p>\n<h2 id=\"nav_point_50\">2.6　没有多余的设计</h2>\n<p>几乎所有的人都知道“画蛇添足”的寓言故事，也都知道“如无必要，勿增实体”的哲学逻辑。对于软件设计也是一样的，代码绝非越多越好，每一行代码在写出来之后，都意味着在未来会有理解成本和维护成本。如果一些代码没有存在的道理和价值，它就不应该存在，或者应该被及时移除。</p>\n<p>要想避免或者移除多余的设计，核心是要知道造成多余的原因。概括来说，大概有如下几种常见原因。</p>\n<ul>\n<li>刻板地遵循某种设计范例。</li>\n<li>代码曾经有用，但是后来变得无用。</li>\n<li>为未来预留了实现或者扩展点。</li>\n</ul>\n<p>下面让我们依次分析这几种原因。</p>\n<h3 id=\"nav_point_51\">2.6.1　避免刻板地遵循某种设计范例</h3>\n<p>设计范例很有用，但如果应用不当或者理解不充分，程序员也容易受到困扰。</p>\n<p>我们曾经在 2.2 节使用杨辉三角形的例子，这里继续使用这个例子。代码清单 2.5 定义了一个打印杨辉三角形的业务场景。不过，我相信有些读者可能见过下面这样的代码（请注意第 4 行和原来代码的差别）。</p>\n<pre class=\"code-rows\"><code>class Main {\n    public static void main(String[] args) {\n        int rows = 5;\n        IPascalTriangle triangle = new PascalTriangle();\n        for (int i = 0; i &lt; rows; i++){\n            print(triangle.dataOfRow(i));\n        }\n    }\n    private static void print(int[] data) {}\n}\ninterface IPascalTriangle {\n    int[] dataOfRow(int i);\n}\nclass PascalTriangle implements IPascalTriangle {\n    // 代码略\n}</code></pre>\n<p><strong>代码清单 2.18</strong>　面向意图表达的方法命名示例</p>\n<p>和代码清单 2.5 相比，代码清单 2.18 中改为使用接口 <code>IPascalTriangle</code>。在我见到的更极端的场景中，一个项目中的每个类都自带一个接口声明。出现这个现象的原因是：程序员见过许多遵循 IoP（面向接口编程，Interface oriented Programming）<sup>[13]</sup>的范例代码，却没有深刻理解 IoP 的根本驱动力。写出这种代码，往往是“照着葫芦画瓢”的结果。</p>\n<p>本书第 6 章会讲解 IoP，现在我们先简单介绍它。</p>\n<blockquote>\n<p>IoP 的本质是定义和实现的分离。定义指的是契约的定义，用接口承载。由于实现更容易变化也更难管理，所以通过接口形式建立的依赖关系更稳定也更容易管理。</p>\n</blockquote>\n<p>因此，应用 IoP 是一种基于投资回报的理性决策。举个例子：如果订单系统需要发送一个消息，那么依赖一个 <code>Message</code> 接口是很自然的决策。但是如果订单包含的订单项也要被定义为抽象接口，就显得非常奇怪和盲从了。因为，无论在未来怎么调整设计，订单和订单项都始终在同一个设计边界内，也不存在一个订单会有多种不同的订单项的实现方案。在这里机械地模仿一个面向接口的设计，只是白白增加了复杂性，没有任何益处。</p>\n<p>刻板遵循设计范例的现象比较常见，例如，我还见过某个团队，因为设计一般是分成若干层，如三层架构的 Controller、Service 和 DAO，所以即使自己的项目不是一个典型的数据库相关的项目，也要硬性分出这些层次，其实每个类都只是简单地向下一级传递了一次调用而已，这就属于典型的多余设计。</p>\n<p>如何避免这类设计问题呢？核心就是要明白：所有的设计范式，本身都是为了解决某个问题，它的权衡点在于投资回报。如果发现投资回报不合理，这时候就要做到“如无必要，勿增实体”，果断地把不该存在的设计删除。</p>\n<h3 id=\"nav_point_52\">2.6.2　及时删除已经不再有用的代码</h3>\n<p>相信许多读者都在代码中看到过“死代码”，就是那些根本不会被用到的代码。造成“死代码”的原因很多，例如业务逻辑发生了变化，原有的代码自然就没有用处了。或者是调整了设计，导致原来的一部分代码不再用得上。一次次阅读这些已经无用的代码，是一种不必要的成本。应该把它们及时删除。</p>\n<p>有一些工具可以帮助我们发现“死代码”。第一种是使用自动化测试，在具有比较完备的自动化测试的项目中，如果一些代码无法被测试覆盖，那它们大概率就是死代码。第二种是使用依赖分析工具，如 depends<sup>[14]</sup>，利用它能发现和所有代码都不存在依赖关系的设计单元，它们很可能也是死代码。</p>\n<p>有些程序员从心理上不舍得删除自己的代码，总感觉这段代码在未来会用得上。就算动手，也舍不得真正删除，而是把这些代码用注释符号包起来，最后这些代码变成了一大段看起来很凌乱的注释。这种做法和想法是不合适的，和打扫房间的时候舍不得扔掉一些已经两年不用的杂物是一样的道理。一个东西已经两年没用了，那在未来三年不用它的可能性也很高。“断舍离”是对待这些东西和这些代码最正确的态度，它们其实不是资产，而是债务。更进一步，几乎所有的规范项目，都应用了版本管理系统，如 git 工具，因为有这些工具的存在，所以任何历史上曾经存在的代码，都可以方便地找回。总之，如果某些代码真的有必要删除，就果断删除它们吧！</p>\n<h3 id=\"nav_point_53\">2.6.3　避免为不可预见的未来编写代码</h3>\n<p>代码应该具备扩展性，这毋庸置疑。但是，“为未来预留实现或者扩展点”并不可取。“未来”并不那么容易预测。一个常见的事实是：预期发生的没发生，不预期发生的发生了。</p>\n<p>面向不确定的未来，最好的方法是反脆弱<sup>[15]</sup>，反脆弱是塔勒布在同名书籍中提出的观点：因为未来的变化很难预测，会出现大量的黑天鹅事件，所以真正稳定的系统应该是那种具有高度适应性的系统。对应到我们的代码主题上，就是：应该编写具有高度适应性的代码，而不是预先假定代码在未来的演进方向。因为代码具有适应性，所以一旦有新的功能需求，总是能比较容易地适配。</p>\n<p>预留的扩展点在某种程度上已经假定了代码未来的演进方向，所以不是反脆弱的。相反，因为这些扩展点可能在相当长一段时间（甚至永远）都用不上，所以反倒会影响代码的可理解性和可维护性。真正反脆弱的代码，是那些高内聚、低耦合，和业务的本质概念关联紧密、对应良好的代码。当然了，还应该具备良好的自动化测试。</p>\n<p>如何避免不必要的预先设计是一个重要话题，本书还将在 11.1 节和 11.2 节深入探讨它。</p>\n<h2 id=\"nav_point_54\">2.7　具备自动化测试</h2>\n<p>应该没有任何读者会否定自动化测试的价值。自动化测试的价值远远不止“质量保障”那么简单，它几乎和优质代码的每一个外部属性紧密相关。</p>\n<h3 id=\"nav_point_55\">2.7.1　保障功能正确</h3>\n<p>测试的原始目的就是保障功能正确。不过，如果只有手工测试，那么不仅质量保障所需的成本很高，也无法达到质量保障的目标。特别是在敏捷开发模式下，软件开发被分成许多次迭代。每次迭代不仅要测试当前的功能，还要面向已经存在的功能进行回归。迭代越多，越频繁，历史功能越多，回归测试的重要性和复杂性就越高。只有不知疲倦、自带记忆、精准执行的自动化测试，才能胜任这一工作。只依靠人工，几乎是不可能的。</p>\n<h3 id=\"nav_point_56\">2.7.2　提升代码可理解性</h3>\n<p>当面对一段陌生的代码时，我已经养成了一个习惯，先看一下是否存在自动化测试代码。如果存在，那我一般不会先看产品代码，甚至不会看产品文档，而是直接开始阅读测试代码。这是一个非常有效的技巧，之所以有效，是因为：编写良好的自动化测试代码，是最好的产品文档。下面请看一段选自真实项目的代码示例。</p>\n<pre class=\"code-rows\"><code>class TestIdentifierSplitter {\n    static IdentifierSplitter  splitter;\n    @BeforeClass\n    static void createSplitter(){\n        splitter = new IdentifierSplitter();\n    }\n\n    @Test\n    void camelCaseShouldBeSplitted() {\n        List&lt;String&gt; result = splitter.split(\"HelloWorld\");\n        String[] expected = {\"Hello\",\"World\"};\n        assertArrayEquals(expected, result.toArray());\n    }\n\n    @Test\n    void continueUpperCaseShouldBeTreatAsOneWord() {\n        List&lt;String&gt; result = splitter.split(\"DNAReader\");\n        String[] expected = {\"DNA\",\"Reader\"};\n        assertArrayEquals(expected, result.toArray());\n    }\n\n    @Test\n    void continueUpperCaseWithUnderscoreShouldBeTwoWords() {\n        List&lt;String&gt; result = splitter.split(\"FONT_SIZE\");\n        String[] expected = {\"FONT\",\"SIZE\"};\n        assertArrayEquals(expected, result.toArray());\n    }\n\n    @Test\n    void preDefinedWordShouldNotBeSplitted() {\n        splitter.addPredefinedWord(\"JUnit4\");\n        List&lt;String&gt; result = splitter.split(\"JUnit4Runner\");\n        String[] expected = {\"JUnit4\",\"Runner\"};\n        assertArrayEquals(expected, result.toArray());\n    }\n}</code></pre>\n<p><strong>代码清单 2.19</strong>　从测试代码中可以很容易地了解代码功能</p>\n<p>代码清单 2.19 测试了 <code>IdentifierSplitter</code> 类的 <code>split</code> 方法。它可以拆分代码中的标识符，是一段对代码进行语义分析的基础程序。我们可以把代码清单 2.19 看作测试代码，也可以看作 <code>IdentifierSplitter</code> 类的用法说明书。</p>\n<p>从这段代码中可以了解到 <code>IdentifierSplitter</code> 类的 <code>split</code> 方法具有如下能力。</p>\n<ul>\n<li>接收一个字符串（标识符）作为输入，返回一个字符串列表（单词数组）作为输出。</li>\n<li>能够基于下划线或者驼峰（CamelCase）拆分标识符为单词数组。</li>\n<li>当连续出现大写字母时，自动判定除最后一个大写字母外的部分为一个单词。</li>\n<li>当大写字母和下划线连在一起时，以下划线作为分隔符。</li>\n<li>支持预定义词汇。当标识符中出现预定义的单词时，优先保证拆分出该单词。</li>\n</ul>\n<p>无须阅读代码，无须阅读文档，自动化测试清晰地描述了代码的功能，而且提供了如何使用这段代码的示例。</p>\n<p>用测试作为文档的一个特别大的优势是它不会过时。而一般的文档，甚至是代码中的注释，都可能会过时。有时候程序员更新了代码，但是忘记了更新文档，这种情况下文档系统不会有任何告警。但是，测试就不一样了。如果更新了代码，使得功能改变了，但是忘记了修改对应的测试代码，那么在执行测试时就会报错。所以，测试能够始终保持和代码同步，这是一个非常重要的优势。</p>\n<h3 id=\"nav_point_57\">2.7.3　保障软件系统的持续演进</h3>\n<p>软件开发是一个持续的过程，代码在生命周期中会多次被修改，以优化其结构（也就是重构），或增加新的功能或能力（支持新功能）。软件系统演进的一个特别重要的关注点，就是要确保过去能正常工作的功能，现在也能正常工作。如果有完备的自动化测试，那么只要一个命令，执行一下所有的自动化测试，哪些功能失败就一目了然了。所以，自动化测试是重构的防护网，在支持新功能时保护既有功能不被破坏。</p>\n<h3 id=\"nav_point_58\">2.7.4　用契约和资产的观点看待自动化测试</h3>\n<p>自动化测试代码和产品代码具备同等重要的地位，它也是软件资产的一部分。但是，在许多团队中，大量的代码仍然缺少完备的自动化测试。即使是对测试覆盖率提要求，也不一定能获得优质的测试。</p>\n<p>之所以存在上述问题，是因为团队对测试的本质了解不足。测试的本质绝不仅是“测试”，它更本质的属性是“契约”。在实践中，更有效的自动化测试开发是测试先行。本书将在第 7 章探讨测试先行的重要性，还会在 10.3 节讨论自动化测试的具体技术。</p>\n<h2 id=\"nav_point_59\">2.8　小结</h2>\n<p>软件设计和编码需要体现“专业性”。本章讨论的 7 个内在特征都是高质量设计的专业表现。我把它们按照受关注程度的不同进行了排列。同时，排列顺序也符合多数人的认知，即从最基础的编码规范到具备完善的自动化测试。</p>\n<p>值得说明的是，本章所讲的内在特征和外部特征具有密切的联系。尽管彼此联系的程度可能有所不同，但是为了便于读者理解，我在表 2.2 给出一个大致的映射关系，<span class=\"comment-number\">15</span>供读者参考。</p>\n\n<p><strong>表 2.2</strong>　设计的内在特征服务于外部特征</p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>内在特征</p></th>\n<th><p>功能正确性</p></th>\n<th><p>易于理解</p></th>\n<th><p>易于演进</p></th>\n<th><p>易于复用</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>一致的编码风格</p></td>\n<td><p>+</p></td>\n<td><p>+++</p></td>\n<td><p>++</p></td>\n<td><p>&nbsp;</p></td>\n</tr>\n<tr>\n<td><p>有意义的命名</p></td>\n<td><p>+</p></td>\n<td><p>+++</p></td>\n<td><p>++</p></td>\n<td><p>++</p></td>\n</tr>\n<tr>\n<td><p>简洁的行为实现</p></td>\n<td><p>+++</p></td>\n<td><p>+++</p></td>\n<td><p>++</p></td>\n<td><p>&nbsp;</p></td>\n</tr>\n<tr>\n<td><p>高内聚和低耦合的结构</p></td>\n<td><p>++</p></td>\n<td><p>+++</p></td>\n<td><p>+++</p></td>\n<td><p>+++</p></td>\n</tr>\n<tr>\n<td><p>没有重复</p></td>\n<td><p>+</p></td>\n<td><p>++</p></td>\n<td><p>+++</p></td>\n<td><p>&nbsp;</p></td>\n</tr>\n<tr>\n<td><p>没有多余的设计</p></td>\n<td><p>+</p></td>\n<td><p>++</p></td>\n<td><p>+++</p></td>\n<td><p>&nbsp;</p></td>\n</tr>\n<tr>\n<td><p>具备自动化测试</p></td>\n<td><p>+++</p></td>\n<td><p>+++</p></td>\n<td><p>+++</p></td>\n<td><p>+++</p></td>\n</tr>\n</tbody>\n</table>\n<p>图 2.10 总结了本章的核心内容。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00290.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 2.10</strong>　高质量设计的内在特征</p>\n\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"第 1 章 优质代码的外部特征","id":740970},"right":{"article_title":"第 3 章 高质量的需求","id":740972}},"comments":[]}