{"id":735122,"title":"06｜规范化：引入HttpRequest与HttpResponse","content":"<p>你好，我是郭屹。今天我们继续手写MiniTomcat。</p><p>在前面的学习结束之后，我们引入了池化技术，还实现Processor的异步化。前者复用对象，减少构造新对象的时间开销；后者使Connector能同时服务于多个Processor。这些都是提升性能和吞吐量的常用技术手段。</p><p>这节课我们继续研究Servlet规范，对我们现有的代码进行改造，使之适配这个规范。同时我们还要解析HTTP协议中的请求信息，并把它存储到服务器内存之中。</p><p>下面就让我们一起来动手实现。</p><h2>项目结构</h2><p>这节课因为需要进行Servlet规范适配工作，还要解析头部信息，因此会新增几个类，整体结构如下：</p><pre><code class=\"language-plain\">MiniTomcat\n├─ src\n│  ├─ main\n│  │  ├─ java\n│  │  │  ├─ server\n│  │  │  │  ├─ DefaultHeaders.java\n│  │  │  │  ├─ HttpConnector.java\n│  │  │  │  ├─ HttpHeader.java\n│  │  │  │  ├─ HttpProcessor.java\n│  │  │  │  ├─ HttpRequest.java\n│  │  │  │  ├─ HttpRequestLine.java\n│  │  │  │  ├─ HttpResponse.java\n│  │  │  │  ├─ HttpServer.java\n│  │  │  │  ├─ Request.java\n│  │  │  │  ├─ Response.java\n│  │  │  │  ├─ ServletProcessor.java\n│  │  │  │  ├─ SocketInputStream.java\n│  │  │  │  ├─ StatisResourceProcessor.java\n│  │  ├─ resources\n│  ├─ test\n│  │  ├─ java\n│  │  │  ├─ test\n│  │  │  │  ├─ HelloServlet.java\n│  │  ├─ resources\n├─ webroot\n│  ├─ test\n│  │  ├─ HelloServlet.class\n│  ├─ hello.txt\n├─ pom.xml\n</code></pre><!-- [[[read_end]]] --><h2>Servlet规范适配</h2><p>在Servlet规范中，对Request请求和Response返回提供了对应的HTTP协议接口定义，分别是javax.servlet.http.HttpServletRequest和javax.servlet.http.HttpServletResponse。接下来我们实现定义的接口，并逐步开始解析工作。</p><p>首先，定义HttpRequest与HttpResponse，分别实现HttpServletRequest与HttpServletResponse接口。实现了这个接口之后，就会要求实现很多接口里面的方法，绝大部分我们都没有用到，所以这里我只列举出几个基本的，不过后面我也给出了完整的代码链接，你可以参考。</p><pre><code class=\"language-java\">package server;\npublic class HttpRequest implements HttpServletRequest {\n    public Object getAttribute(String arg0) {\n        return null;\n    }\n    public Enumeration&lt;String&gt; getAttributeNames() {\n        return null;\n    }\n    public String getCharacterEncoding() {\n        return null;\n    }\n    public int getContentLength() {\n        return 0;\n    }\n    public String getContentType() {\n        return null;\n    }\n    public ServletInputStream getInputStream() throws IOException {\n        return null;\n    }\n    public String getParameter(String arg0) {\n        return null;\n    }\n    public Map&lt;String, String[]&gt; getParameterMap() {\n        return null;\n    }\n    public Enumeration&lt;String&gt; getParameterNames() {\n        return null;\n    }\n    public String[] getParameterValues(String arg0) {\n        return null;\n    }\n    public RequestDispatcher getRequestDispatcher(String arg0) {\n        return null;\n    }\n    public ServletContext getServletContext() {\n        return null;\n    }\n    public void setAttribute(String arg0, Object arg1) {\n    }\n    public void setCharacterEncoding(String arg0) throws UnsupportedEncodingException {\n    }\n    public Cookie[] getCookies() {\n        return null;\n    }\n    public String getQueryString() {\n        return null;\n    }\n    public String getRequestURI() {\n        return null;\n    }\n    public StringBuffer getRequestURL() {\n        return null;\n    }\n    public String getServletPath() {\n        return null;\n    }\n    public HttpSession getSession() {\n        return null;\n    }\n    public HttpSession getSession(boolean arg0) {\n        return null;\n    }\n}\n</code></pre><p>同样的，HttpServletResponse接口也会有很多实现方法。我们先定义，然后再开始慢慢实现，并不是每个方法都需要用到，绝大多数方法暂时可以不理会。下面是HttpResponse的定义，和前面一样，也只列出几个基本的方法。</p><pre><code class=\"language-java\">package server;\npublic class HttpResponse implements HttpServletResponse {\n    public String getCharacterEncoding() {\n        return null;\n    }\n    public String getContentType() {\n        return null;\n    }\n    public ServletOutputStream getOutputStream() throws IOException {\n        return null;\n    }\n    public PrintWriter getWriter() throws IOException {\n        return null;\n    }\n    public void setCharacterEncoding(String arg0) {\n    }\n    public void setContentLength(int arg0) {\n    }\n    public void setContentType(String arg0) {\n    }\n    public void addCookie(Cookie arg0) {\n    }\n    public String getHeader(String arg0) {\n        return null;\n    }\n    public Collection&lt;String&gt; getHeaderNames() {\n        return null;\n    }\n    public Collection&lt;String&gt; getHeaders(String arg0) {\n        return null;\n    }\n}\n</code></pre><h2>Request信息解析</h2><p>我们期望从Servlet的Request请求中能方便地获取到Header头部的信息，所以我们只需要先关注一下定义里的几个方法：getHeader、getHeaderNames、getHeaders、getParameter、getPrameterMap、getParameterNames、getParameterValues。</p><p>在HttpRequest的实现中，我们可以用下面这个结构保存这些头信息。</p><pre><code class=\"language-java\">protected HashMap&lt;String, String&gt; headers = new HashMap&lt;&gt;();\nprotected Map&lt;String, String&gt; parameters = new ConcurrentHashMap&lt;&gt;();\n</code></pre><p>结构中，headers用来存储头的信息，而parameters存储参数信息，采用ConcurrentHashMap结构也是考虑到允许Servlet并发进行增加删除修改操作。</p><p>在正式开始解析这些参数信息之前，我们先考虑一个问题：什么时候解析？目前可以考虑两种方案：一是在Connector中预先全部解析完毕，但这种方式性价比并不高，因为Header信息有数十个，甚至上百个，而一个Servlet中实际用到的可能只有寥寥数个；另外一种是在Servlet实际读取Request的时候，根据Request传入的Header信息每次都进行解析。</p><p>因此我们可以考虑做出选择：在Connector启动后，解析头部信息，而参数信息则在Servlet需要使用时再解析。放在不同的时间点解析头部和参数信息，主要是为了提高效率。这个选择是参考了Tomcat的做法。</p><p>下面我们就开始着手<strong>解析Request</strong>。</p><p>在此之前我们都是用InputStream进行解析，以字节为单位依次读取，效率不高。这里我们自己准备一个类——SocketInputStream，直接按行读取，获取Request line与Header。</p><p>首先定义HttpRequestLine类。这个类是Http Request头行的抽象，格式是method uri protocol，如 <code>GET /hello.txt HTTP/1.1</code>。</p><pre><code class=\"language-java\">package server;\npublic class HttpRequestLine {\n    public static final int INITIAL_METHOD_SIZE = 8;\n    public static final int INITIAL_URI_SIZE = 128;\n    public static final int INITIAL_PROTOCOL_SIZE = 8;\n    public static final int MAX_METHOD_SIZE = 32;\n    public static final int MAX_URI_SIZE = 2048;\n    public static final int MAX_PROTOCOL_SIZE = 32;\n    \n    //下面的属性对应于Http Request规范，即头行格式method uri protocol\n    //如：GET /hello.txt HTTP/1.1\n    //char[] 存储每段的字符串，对应的int值存储的是每段的结束位置\n    public char[] method;\n    public int methodEnd;\n    public char[] uri;\n    public int uriEnd;\n    public char[] protocol;\n    public int protocolEnd;\n    public HttpRequestLine() {\n        this(new char[INITIAL_METHOD_SIZE], 0, new char[INITIAL_URI_SIZE], 0,\n                new char[INITIAL_PROTOCOL_SIZE], 0);\n    }\n    public HttpRequestLine(char[] method, int methodEnd,\n                           char[] uri, int uriEnd,\n                           char[] protocol, int protocolEnd) {\n        this.method = method;\n        this.methodEnd = methodEnd;\n        this.uri = uri;\n        this.uriEnd = uriEnd;\n        this.protocol = protocol;\n        this.protocolEnd = protocolEnd;\n    }\n    public void recycle() {\n        methodEnd = 0;\n        uriEnd = 0;\n        protocolEnd = 0;\n    }\n    public int indexOf(char[] buf) {\n        return indexOf(buf, buf.length);\n    }\n    //这是主要的方法\n    //在uri[]中查找字符串buf的出现位置\n    public int indexOf(char[] buf, int end) {\n        char firstChar = buf[0];\n        int pos = 0; //pos是查找字符串buf在uri[]中的开始位置\n        while (pos &lt; uriEnd) {\n            pos = indexOf(firstChar, pos); //首字符定位开始位置\n            if (pos == -1) {\n                return -1;\n            }\n            if ((uriEnd - pos) &lt; end) {\n                return -1;\n            }\n            for (int i = 0; i &lt; end; i++) { //从开始位置起逐个字符比对\n                if (uri[i + pos] != buf[i]) {\n                    break;\n                }\n                if (i == (end - 1)) { //每个字符都相等，则匹配上了，返回开始位置\n                    return pos;\n                }\n            }\n            pos++;\n        }\n        return -1;\n    }\n    public int indexOf(String str) {\n        return indexOf(str.toCharArray(), str.length());\n    }\n    //在uri[]中查找字符c的出现位置\n    public int indexOf(char c, int start) {\n        for (int i = start; i &lt; uriEnd; i++) {\n            if (uri[i] == c) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n</code></pre><p>HttpRequestLine里，包含method、uri和protocol等信息，这是根据HTTP协议来定义的。在实现的过程中，用的数据结构是一个char数组，这样可以从inputstream中直接读取下来，不用经过String的转换，提高了效率，但也因此要提供xxxEnd几个属性来标识最后一个字符的位置，程序的复杂度提高了一些。</p><p>这个工具类里面提供了 <code>indexOf()</code> 方法来匹配uri，实现方法是char数组的双重循环匹配。具体可以看上面代码里的注释。</p><p>接下来再定义HttpHeader类。</p><pre><code class=\"language-java\">package server;\npublic class HttpHeader {\n     public static final int INITIAL_NAME_SIZE = 64;\n     public static final int INITIAL_VALUE_SIZE = 512;\n     public static final int MAX_NAME_SIZE = 128;\n     public static final int MAX_VALUE_SIZE = 1024;\n     public char[] name;\n     public int nameEnd;\n     public char[] value;\n     public int valueEnd;\n     protected int hashCode = 0;\n     public HttpHeader() {\n         this(new char[INITIAL_NAME_SIZE], 0, new char[INITIAL_VALUE_SIZE], 0);\n     }\n     public HttpHeader(char[] name, int nameEnd, char[] value, int valueEnd) {\n         this.name = name;\n         this.nameEnd = nameEnd;\n         this.value = value;\n         this.valueEnd = valueEnd;\n     }\n     public HttpHeader(String name, String value) {\n         this.name = name.toLowerCase().toCharArray();\n         this.nameEnd = name.length();\n         this.value = value.toCharArray();\n         this.valueEnd = value.length();\n     }\n     public void recycle() {\n         nameEnd = 0;\n         valueEnd = 0;\n         hashCode = 0;\n     }\n}\n\n</code></pre><p>根据上面的实现可以看到，HttpRequestLine里包含method、uri与protocol，HttpHeader中包含name与value。实现的类里面还包含xxxEnd类型的域定义，用来标识某一属性最后的位置。</p><p>在HttpRequestLine与HttpHeader类定义完毕之后，我们可以在SocketInputStream中定义两个方法，直接获取Request line与Headers。</p><pre><code class=\"language-java\">public void readRequestLine(HttpRequestLine requestLine){}\npublic void readHeader(HttpHeader header){}\n</code></pre><p>可以回忆一下我们之前解析Header首行的经过：按行读取成一个字符串，依据空格分隔，获取method、uri和protocol。现在我们参考Tomcat，在SocketInputStream里提供一个更专业、更高效的实现。</p><pre><code class=\"language-java\">protected void fill() throws IOException {\n    pos = 0;\n    count = 0;\n    int nRead = is.read(buf, 0, buf.length);\n    if (nRead &gt; 0) {\n        count = nRead;\n    }\n}\n</code></pre><p>上述代码显示，fill方法会从InputStream里读取一批字节，存储到byte数组的buf属性中。</p><p>而 <code>fill()</code> 被调用到 <code>read()</code> 方法内，每次从buf中读到当前的字节返回，如果 <code>pos &gt;= count</code> 表示当前的byte已获取完毕，内部就调用fill方法获取新的字节流。因此，对上层程序员来说，使用 <code>read()</code> 就相当于可以连续读取缓存中的数据。</p><p>read方法实现如下：</p><pre><code class=\"language-java\">@Override\npublic int read() throws IOException {\n    if (pos &gt;= count) {\n        fill();\n        if (pos &gt;= count) {\n            return -1;\n        }\n    }\n    return buf[pos++] &amp; 0xff;\n}\n</code></pre><p>其中这个方法返回-1表示读取出错。</p><p>有了这些铺垫，我们再来看SocketInputStream的完整实现。简单地说，这个类的作用就是从输入流中读出request line和header信息来。</p><pre><code class=\"language-java\">package server;\npublic class SocketInputStream extends InputStream {\n    private static final byte CR = (byte) '\\r';\n    private static final byte LF = (byte) '\\n';\n    private static final byte SP = (byte) ' ';\n    private static final byte HT = (byte) '\\t';\n    private static final byte COLON = (byte) ':';\n    private static final int LC_OFFSET = 'A' - 'a';\n    protected byte buf[];\n    protected int count;\n    protected int pos;\n    protected InputStream is;\n    public SocketInputStream(InputStream is, int bufferSize) {\n        this.is = is;\n        buf = new byte[bufferSize];\n    }\n    //从输入流中解析出request line\n    public void readRequestLine(HttpRequestLine requestLine)\n        throws IOException {\n        int chr = 0;\n        //跳过空行\n        do {\n            try {\n                chr = read();\n            } catch (IOException e) {\n            }\n        } while ((chr == CR) || (chr == LF));\n        //第一个非空位置\n        pos--;\n        int maxRead = requestLine.method.length;\n        int readStart = pos;\n        int readCount = 0;\n        boolean space = false;\n        //解析第一段method，以空格结束\n        while (!space) {\n            if (pos &gt;= count) {\n                int val = read();\n                if (val == -1) {\n                    throw new IOException(\"requestStream.readline.error\");\n                }\n                pos = 0;\n                readStart = 0;\n            }\n            if (buf[pos] == SP) {\n                space = true;\n            }\n            requestLine.method[readCount] = (char) buf[pos];\n            readCount++;\n            pos++;\n        }\n        requestLine.methodEnd = readCount - 1; //method段的结束位置\n        \n        maxRead = requestLine.uri.length;\n        readStart = pos;\n        readCount = 0;\n        space = false;\n        boolean eol = false;\n        //解析第二段uri，以空格结束\n        while (!space) {\n            if (pos &gt;= count) {\n                int val = read();\n                if (val == -1)\n                    throw new IOException(\"requestStream.readline.error\");\n                pos = 0;\n                readStart = 0;\n            }\n            if (buf[pos] == SP) {\n                space = true;\n            }\n            requestLine.uri[readCount] = (char) buf[pos];\n            readCount++;\n            pos++;\n        }\n        requestLine.uriEnd = readCount - 1; //uri结束位置\n        \n        maxRead = requestLine.protocol.length;\n        readStart = pos;\n        readCount = 0;\n        //解析第三段protocol，以eol结尾\n        while (!eol) {\n            if (pos &gt;= count) {\n                int val = read();\n                if (val == -1)\n                    throw new IOException(\"requestStream.readline.error\");\n                pos = 0;\n                readStart = 0;\n            }\n            if (buf[pos] == CR) {\n                // Skip CR.\n            } else if (buf[pos] == LF) {\n                eol = true;\n            } else {\n                requestLine.protocol[readCount] = (char) buf[pos];\n                readCount++;\n            }\n            pos++;\n        }\n        requestLine.protocolEnd = readCount;\n    }\n    public void readHeader(HttpHeader header)\n        throws IOException {\n        int chr = read();\n        if ((chr == CR) || (chr == LF)) { // Skipping CR\n            if (chr == CR)\n                read(); // Skipping LF\n            header.nameEnd = 0;\n            header.valueEnd = 0;\n            return;\n        } else {\n            pos--;\n        }\n        // 正在读取 header name\n        int maxRead = header.name.length;\n        int readStart = pos;\n        int readCount = 0;\n        boolean colon = false;\n        while (!colon) {\n            // 我们处于内部缓冲区的末尾\n            if (pos &gt;= count) {\n                int val = read();\n                if (val == -1) {\n                    throw new IOException(\"requestStream.readline.error\");\n                }\n                pos = 0;\n                readStart = 0;\n            }\n            if (buf[pos] == COLON) {\n                colon = true;\n            }\n            char val = (char) buf[pos];\n            if ((val &gt;= 'A') &amp;&amp; (val &lt;= 'Z')) {\n                val = (char) (val - LC_OFFSET);\n            }\n            header.name[readCount] = val;\n            readCount++;\n            pos++;\n        }\n        header.nameEnd = readCount - 1;\n        // 读取 header 值（可以跨越多行）\n        maxRead = header.value.length;\n        readStart = pos;\n        readCount = 0;\n        int crPos = -2;\n        boolean eol = false;\n        boolean validLine = true;\n        while (validLine) {\n            boolean space = true;\n            // 跳过空格\n            // 注意：仅删除前面的空格，后面的不删。\n            while (space) {\n                // 我们已经到了内部缓冲区的尽头\n                if (pos &gt;= count) {\n                    // 将内部缓冲区的一部分（或全部）复制到行缓冲区\n                    int val = read();\n                    if (val == -1)\n                        throw new IOException(\"requestStream.readline.error\");\n                    pos = 0;\n                    readStart = 0;\n                }\n                if ((buf[pos] == SP) || (buf[pos] == HT)) {\n                    pos++;\n                } else {\n                    space = false;\n                }\n            }\n            while (!eol) {\n                // 我们已经到了内部缓冲区的尽头\n                if (pos &gt;= count) {\n                    // 将内部缓冲区的一部分（或全部）复制到行缓冲区\n                    int val = read();\n                    if (val == -1)\n                        throw new IOException(\"requestStream.readline.error\");\n                    pos = 0;\n                    readStart = 0;\n                }\n                if (buf[pos] == CR) {\n                } else if (buf[pos] == LF) {\n                    eol = true;\n                } else {\n                    // FIXME：检查二进制转换是否正常\n                    int ch = buf[pos] &amp; 0xff;\n                    header.value[readCount] = (char) ch;\n                    readCount++;\n                }\n                pos++;\n            }\n            int nextChr = read();\n            if ((nextChr != SP) &amp;&amp; (nextChr != HT)) {\n                pos--;\n                validLine = false;\n            } else {\n                eol = false;\n                header.value[readCount] = ' ';\n                readCount++;\n            }\n        }\n        header.valueEnd = readCount;\n    }\n    @Override\n    public int read() throws IOException {\n        if (pos &gt;= count) {\n            fill();\n            if (pos &gt;= count) {\n                return -1;\n            }\n        }\n        return buf[pos++] &amp; 0xff;\n    }\n    public int available() throws IOException {\n        return (count - pos) + is.available();\n    }\n    public void close() throws IOException {\n        if (is == null) {\n            return;\n        }\n        is.close();\n        is = null;\n        buf = null;\n    }\n    protected void fill() throws IOException {\n        pos = 0;\n        count = 0;\n        int nRead = is.read(buf, 0, buf.length);\n        if (nRead &gt; 0) {\n            count = nRead;\n        }\n    }\n}\n</code></pre><p>从代码可以看出，Tomcat在这里就是用的最简单的扫描方法，从inputstream里读一个个的字节，放到buf里，buf有长度限制，读到尾后就从头再来。然后从buf里一个字节一个字节地判断，pos变量代表当前读取的位置，根据协议规定的分隔符解析到requestline和header里。</p><p>拥有了工具类后，Request内获取Request line就比较容易了，在HttpRequest中定义parse方法，直接用SocketInputStream解析。</p><pre><code class=\"language-java\">public void parse(Socket socket) {\n    this.sis.readRequestLine(requestLine);\n    this.uri = new String(requestLine.uri, 0, requestLine.uriEnd);\n}\n</code></pre><p>这个时候HttpProcessor中就不用Request类构建对象了，改用HttpRequest。</p><pre><code class=\"language-java\">HttpRequest request = new HttpRequest(input);\nrequest.parse(socket);\n</code></pre><p>所以ServletProcessor和StaticResourceProcessor里的process方法，传入的Request类型参数都改成HttpRequest。</p><p>同理，我们来解析Header。和前面一样，在SocketInputStream里已定义了 <code>readHeader(HttpHeader header)</code> 方法，将头信息读入header属性中。我们先定义DefaultHeaders常量类，假设支持下面这些头信息。</p><pre><code class=\"language-java\">package server;\npublic class DefaultHeaders {\n    static final String HOST_NAME = \"host\";\n    static final String CONNECTION_NAME = \"connection\";\n    static final String ACCEPT_LANGUAGE_NAME = \"accept-language\";\n    static final String CONTENT_LENGTH_NAME = \"content-length\";\n    static final String CONTENT_TYPE_NAME = \"content-type\";\n    static final String TRANSFER_ENCODING_NAME = \"transfer-encoding\";\n}\n</code></pre><p>接下来在HttpRequest中可定义parseHeaders方法解析头信息。</p><pre><code class=\"language-java\">private void parseHeaders() throws IOException, ServletException {\n    while (true) {\n        HttpHeader header = new HttpHeader();\n        sis.readHeader(header);\n        if (header.nameEnd == 0) {\n            if (header.valueEnd == 0) {\n                return;\n            } else {\n                throw new ServletException(\"httpProcessor.parseHeaders.colon\");\n            }\n        }\n        String name = new String(header.name,0,header.nameEnd);\n        String value = new String(header.value, 0, header.valueEnd);\n        // Set the corresponding request headers\n        if (name.equals(DefaultHeaders.ACCEPT_LANGUAGE_NAME)) {\n            headers.put(name, value);\n        } else if (name.equals(DefaultHeaders.CONTENT_LENGTH_NAME)) {\n            headers.put(name, value);\n        } else if (name.equals(DefaultHeaders.CONTENT_TYPE_NAME)) {\n            headers.put(name, value);\n        } else if (name.equals(DefaultHeaders.HOST_NAME)) {\n            headers.put(name, value);\n        } else if (name.equals(DefaultHeaders.CONNECTION_NAME)) {\n            headers.put(name, value);\n        } else if (name.equals(DefaultHeaders.TRANSFER_ENCODING_NAME)) {\n            headers.put(name, value);\n        } else {\n            headers.put(name, value);\n        }\n    }\n</code></pre><p>目前实现也比较简单，判断是否是我们支持的头信息，支持后直接存入headers这个map数据结构里。parse方法则支持解析Request Line与Header。</p><p>综合以上内容，我们来重新实现HttpRequest类，HttpServletRequest接口的那些现在没有用到的方法暂时不列出来。</p><pre><code class=\"language-java\">package server;\npublic class HttpRequest implements HttpServletRequest {\n    private InputStream input;\n    private SocketInputStream sis;\n    private String uri;\n    InetAddress address;\n    int port;\n    protected HashMap&lt;String, String&gt; headers = new HashMap&lt;&gt;();\n    protected Map&lt;String, String&gt; parameters = new ConcurrentHashMap&lt;&gt;();\n    HttpRequestLine requestLine = new HttpRequestLine();\n    public HttpRequest(InputStream input) {\n        this.input = input;\n        this.sis = new SocketInputStream(this.input, 2048);\n    }\n    public void parse(Socket socket) {\n        try {\n            parseConnection(socket);\n            this.sis.readRequestLine(requestLine);\n            parseHeaders();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (ServletException e) {\n            e.printStackTrace();\n        }\n        this.uri = new String(requestLine.uri, 0, requestLine.uriEnd);\n    }\n    private void parseConnection(Socket socket) {\n        address = socket.getInetAddress();\n        port = socket.getPort();\n    }\n    private void parseHeaders() throws IOException, ServletException {\n        while (true) {\n            HttpHeader header = new HttpHeader();\n            sis.readHeader(header);\n            if (header.nameEnd == 0) {\n                if (header.valueEnd == 0) {\n                    return;\n                } else {\n                    throw new ServletException(\"httpProcessor.parseHeaders.colon\");\n                }\n            }\n            String name = new String(header.name,0,header.nameEnd);\n            String value = new String(header.value, 0, header.valueEnd);\n            // 设置相应的请求头\n            if (name.equals(DefaultHeaders.ACCEPT_LANGUAGE_NAME)) {\n                headers.put(name, value);\n            } else if (name.equals(DefaultHeaders.CONTENT_LENGTH_NAME)) {\n                headers.put(name, value);\n            } else if (name.equals(DefaultHeaders.CONTENT_TYPE_NAME)) {\n                headers.put(name, value);\n            } else if (name.equals(DefaultHeaders.HOST_NAME)) {\n                headers.put(name, value);\n            } else if (name.equals(DefaultHeaders.CONNECTION_NAME)) {\n                headers.put(name, value);\n            } else if (name.equals(DefaultHeaders.TRANSFER_ENCODING_NAME)) {\n                headers.put(name, value);\n            } else {\n                headers.put(name, value);\n            }\n        }\n    }\n    public String getUri() {\n        return this.uri;\n    }\n}\n</code></pre><p>可以看到这个HttpRequest已经相对简单了。</p><h2>测试</h2><p>我们这一节课的实现只是内部的程序结构变动，并不影响用户的Servlet和客户端的访问。所以还是可以沿用上一节课的测试办法进行验证，这里我就不重复说了。</p><h2>小结</h2><p><img src=\"https://static001.geekbang.org/resource/image/7f/12/7fd829bfd127af9e1b2b4e3bc4abe412.jpg?wh=4358x2555\" alt=\"\"></p><p>这节课我们主要做了两件事：一是进一步适配Servlet规范，实现HttpServletRequest和HttpServletResponse两个接口。我们看到接口中有很多方法，目前我们绝大部分都没有实现，是留空状态，只是先实现最基本的几个方法就可以让程序运行起来了。</p><p>二是引入SocketInputStream，按行读取Request信息，解析Request line与header信息，提高效率和性能，摒弃了我们原有的解析模式。我们可以看到这是一种更加高效的实现办法。</p><p>这两件事情本身并没有扩展我们服务器的功能，目的是符合规范并且高效，这一点我们要向Tomcat学习。</p><p>本节课完整代码参见：<a href=\"https://gitee.com/yaleguo1/minit-learning-demo/tree/geek_chapter06\">https://gitee.com/yaleguo1/minit-learning-demo/tree/geek_chapter06</a></p><h2>思考题</h2><p>学完了这节课的内容，我们来思考一个问题：我们在 <code>SocketInputStream的read()</code> 方法中，用到了ketInputStream的read()方法中，用到了 <code>buf[pos++] &amp; 0xff</code> 这个操作，它的作用是什么？</p><p>欢迎你把你思考后的结果分享到评论区，也欢迎你把这节课的内容分享给其他朋友，我们下节课再见！</p>","neighbors":{"left":{"article_title":"05｜Server性能提升：设计多个Processor","id":735114},"right":{"article_title":"07｜对内的保护：引入门面模式封装内部实现类","id":737438}},"comments":[{"had_liked":false,"id":385662,"user_name":"C.","can_delete":false,"product_type":"c1","uid":1444698,"ip_address":"江苏","ucode":"5AE269220EFD73","user_header":"https://static001.geekbang.org/account/avatar/00/16/0b/5a/453ad411.jpg","comment_is_top":false,"comment_ctime":1703059839,"is_pvip":false,"replies":[{"id":140572,"content":"你说的是对的。我用自己的语言组织一下：\nbyte转int或者char的时候, 如果byte原本是正数，补零扩展是没有问题的。\n但是对于负数的情况，高位会补1，造成二进制补码不一致，所以用&amp;0xff\n将高位补零，低8位保持原样，这样二进制补码是一致的。\n","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1703149379,"ip_address":"江苏","comment_id":385662,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"buf[pos++]：表示buf的pos索引加一，以便后续read操作，是个后缀递增的操作。\n&amp; 0xff：位操作，字节在Java的中的范围为-128到127，是个有符号数，执行&amp; 0xff是在做一个按位与操作，转换为一个无符号数，返回的值在0-255。0xff等于十进制的255，二进制位11111111。buf[pos]字节会与11111111进行按位与操作，基本保持了原始字节的值不变。","like_count":4,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634275,"discussion_content":"你说的是对的。我用自己的语言组织一下：\nbyte转int或者char的时候, 如果byte原本是正数，补零扩展是没有问题的。\n但是对于负数的情况，高位会补1，造成二进制补码不一致，所以用&amp;0xff\n将高位补零，低8位保持原样，这样二进制补码是一致的。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1703149379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":2,"child_discussions":[{"author":{"id":1214384,"avatar":"https://static001.geekbang.org/account/avatar/00/12/87/b0/b06d25f4.jpg","nickname":"Y～龙。！","note":"","ucode":"21D0AF4DCC880A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":635000,"discussion_content":"这样的话，原本是负数的，经过高位补0不就变成正数了吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704272203,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":634275,"ip_address":"广西","group_id":0},"score":635000,"extra":""},{"author":{"id":1607786,"avatar":"https://static001.geekbang.org/account/avatar/00/18/88/6a/fe18b26d.jpg","nickname":"名字好腻害","note":"","ucode":"2D157076F1D5B7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1214384,"avatar":"https://static001.geekbang.org/account/avatar/00/12/87/b0/b06d25f4.jpg","nickname":"Y～龙。！","note":"","ucode":"21D0AF4DCC880A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":643066,"discussion_content":"我的理解是,http的请求头必须用asc编码,它单个字节不会出现负值,而java的字节是有符号的,那么直接用byte转char,会被当做unicode编码值进行解析,会造成错误;一定要用int先接,然后在需要的时候转char,才能保证是asc编码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1714014947,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":635000,"ip_address":"湖北","group_id":0},"score":643066,"extra":""}]}]},{"had_liked":false,"id":385796,"user_name":"Clark Chen","can_delete":false,"product_type":"c1","uid":1939363,"ip_address":"辽宁","ucode":"C0E5AECA4CE7C5","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL212ET0q3e8U5xXuYe7LCBlrpdBFkrgedibfdao2fMUKnCWwxm2I05RB7EyDcgeL0g60ib88cn2dmQ/132","comment_is_top":false,"comment_ctime":1703402309,"is_pvip":false,"replies":[{"id":140594,"content":"对，我的理解就是效率上的原因。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1703486998,"ip_address":"广东","comment_id":385796,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"老师好， 关于`SocketInputStream .readRequestLine(HttpRequestLine requestLine)`   方法的这段代码\n```   \n   while (!space) {\n            if (pos &gt;= count) {\n                int val = read();\n                if (val == -1) {\n                    throw new IOException(&quot;requestStream.readline.error&quot;);\n                }\n                pos = 0;\n                readStart = 0;\n            }\n            if (buf[pos] == SP) {\n                space = true;\n            }\n            requestLine.method[readCount] = (char) buf[pos];\n            readCount++;\n            pos++;\n        }\n```\n有些地方没想明白， 为什么要在这个方法里面对手动控制pos++，直接获取buf[]里面的值 ，而不是通过read 方法来获取值。如下面这样\n```\n        while (!space){\n            if(pos &gt;= count ){\n                readStart = 0;\n            }\n            int val = read();\n            if(val == -1){\n                throw new IOException(&quot;requestStream.readline.error&quot;);\n            }\n            if(val == SP){\n                space =true;\n            }\n            requestLine.getMethod()[readCount] = (char)val;\n            readCount++;\n        }\n```\n是有效率上的原因吗？","like_count":1,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634419,"discussion_content":"对，我的理解就是效率上的原因。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1703486998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385677,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1703079255,"is_pvip":false,"replies":[{"id":140570,"content":"if是用来处理特殊header的，如果不是这些特殊的header，统一put","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1703148704,"ip_address":"江苏","comment_id":385677,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"请教老师两个问题：\nQ1：parameters用来做什么？\nHttpRequest类中定义了parameters，但好像并没有使用，这个类是用来存什么的？\nQ2：parseHeaders函数用if区分有意义吗？\nHttpRequest类中的parseHeaders用if … else来区分各个部分，但其实最后都是调用headers.put(name, value);\n所有的分支，最后的处理结果都是一样的，这个区分还有意义吗？","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634273,"discussion_content":"if是用来处理特殊header的，如果不是这些特殊的header，统一put","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1703148704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385640,"user_name":"HH🐷🐠","can_delete":false,"product_type":"c1","uid":1133678,"ip_address":"广东","ucode":"C50172BDA604D5","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/6e/5435e214.jpg","comment_is_top":false,"comment_ctime":1703033577,"is_pvip":false,"replies":[{"id":140573,"content":"byte转int或者char的时候, 如果byte原本是正数，补零扩展是没有问题的。\n但是对于负数的情况，高位会补1，造成二进制补码不一致，所以用&amp;0xff\n将高位补零，低8位保持原样，这样二进制补码是一致的。\n","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1703149404,"ip_address":"江苏","comment_id":385640,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"😄感觉像是纠正什么数据","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634276,"discussion_content":"byte转int或者char的时候, 如果byte原本是正数，补零扩展是没有问题的。\n但是对于负数的情况，高位会补1，造成二进制补码不一致，所以用&amp;0xff\n将高位补零，低8位保持原样，这样二进制补码是一致的。\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1703149404,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]}]}