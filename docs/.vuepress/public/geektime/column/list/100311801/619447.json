{"id":619447,"title":"12｜代码实现（下）：怎样更加“面向对象”？","content":"<p>你好，我是钟敬。今天咱们继续研究编码。</p><p>上节课我们学习了<strong>领域服务</strong>和<strong>工厂</strong>两个模式，分别用于实现领域逻辑以及创建领域对象。今天我们考虑再增加一些面向对象的元素。</p><p>面向对象的三个特征是封装、继承和多态。其中多态我们暂时还不涉及。而<a href=\"https://time.geekbang.org/column/article/618175\">上节课</a>我们完成的<strong>添加组织</strong>功能，在封装和继承方面还不到位。</p><p>今天我们会继续开发<strong>修改组织</strong>功能，结合这个功能的开发，看看怎样运用封装和继承。</p><h2>为“修改组织”功能开卡</h2><p>为了完成<strong>修改组织</strong>的功能，我们再一次把产品经理老王请过来进行“开卡”，看需求的细节是否理解到位。</p><p>首先要确认的一个问题是，到底要修改组织的哪些信息。目前的Org对象一共有11个属性，我们列成一个表，和老王逐一确认。<br>\n<img src=\"https://static001.geekbang.org/resource/image/52/27/523fb35414c16cd045acbb9cyy969527.jpg?wh=2597x2808\" alt=\"\"></p><p>这个表的含义是，在完成某个功能时，客户端要提供哪些数据。其中“创建”一栏是创建组织时需要哪些参数。“修改”一栏中的问号，是我们觉得在修改时需要客户提供，但需要与业务确认的。</p><p>老王轻轻一笑，眼神中的意思是“你们这些搞IT的还是不懂业务呀”，然后给出了后面四条意见。</p><p>1.如果修改“上级组织”的话，实际上是在调整组织结构。一般不作为普通的修改功能，建议增加专门的“调整组织结构”功能。</p><p>2.“组织类别”不能修改，也就是说，一个开发组不能直接变成开发中心。如果真有这种需求，需要另外创建新的开发中心，把人迁移过去，然后撤销当前的开发组。</p><!-- [[[read_end]]] --><p>3.“状态”不能直接改，应该通过“撤销组织”功能间接修改。</p><p>4.最终只有“负责人”和“名称”可以直接修改，建议这个功能叫做“修改组织基本信息”。</p><p>根据老王的建议，我们把表格改成了下面的样子。由于调整组织结构功能比较复杂，所以以后再考虑，这里只增加了“撤销组织”功能。</p><p><img src=\"https://static001.geekbang.org/resource/image/1b/56/1bcbea3731de0c695e23e6d47a4d5456.jpg?wh=2597x2523\" alt=\"\"></p><p>接着，老王又为撤销组织增加了2个业务规则。<br>\n<img src=\"https://static001.geekbang.org/resource/image/10/e4/10510fe8c8e699db27d1e19dyy94a1e4.jpg?wh=3218x909\" alt=\"\"></p><h2>初步完成程序功能</h2><p>采用前两节课的方法，我们初步完成了“修改组织基本信息”和“撤销组织”功能。</p><p>修改后的OrgServcie是这样的。</p><pre><code class=\"language-plain\">package chapter12.unjuanable.application.orgmng;\n// imports ...\n\n@Service\npublic class OrgService {\n    private final OrgBuilderFactory orgBuilderFactory;\n    private final OrgRepository orgRepository;\n    private final OrgHandler orgHandler;  //新增了一个领域服务依赖\n\n    @Autowired\n    public OrgService(OrgBuilderFactory orgBuilderFactory\n            , OrgHandler orgHandler\n            , OrgRepository orgRepository) {\n        // 为依赖注入赋值 ...\n    }\n\n    @Transactional\n    public OrgDto addOrg(OrgDto request，Long userId) {\n        // 添加组织的功能已完成，这里省略 ...\n    }\n\n    //修改组织基本信息\n    @Transactional\n    public OrgDto updateOrgBasic(Long id, OrgDto request, Long userId) {\n        Org org = orgRepository.findById(request.getTenant(), id)\n                .orElseThrow(() -&gt; {\n                    throw new BusinessException(\"要修改的组织(id =\" \n                                + id + \"  )不存在！\");\n                });\n\n        orgHandler.updateBasic(org, request.getName() \n                , request.getLeader(), userId);\n                \n        orgRepository.update(org);\n\n        return buildOrgDto(org);\n    }\n\n    //取消组织\n    @Transactional\n    public Long cancelOrg(Long id, Long tenant, Long userId) {\n        Org org = orgRepository.findById(tenant, id)\n                .orElseThrow(() -&gt; {\n                    throw new BusinessException(\"要取消的组织(id =\" \n                                + id + \"  )不存在！\");\n                });\n\n        orgHandler.cancel(org, userId);\n        orgRepository.update(org);\n\n        return org.getId();\n    }\n\n    private static OrgDto buildOrgDto(Org org) {\n        // 将领域对象转换成DTO\n    }\n\n}\n</code></pre><p>我们写了一个OrgHandler来协助完成功能。和Validator一样，这也是一个<strong>领域服务，</strong>但命名为 OrgDomainService显得有点繁琐，我们这里按XxxHandler命名，也就是Xxx处理器。</p><p>OrgHandler的代码是这样的。</p><pre><code class=\"language-plain\">package chapter12.unjuanable.domain.orgmng.org;\n// imports...\n\n@Component\npublic class OrgHandler {\n    private final CommonValidator commonValidator;\n    private final OrgNameValidator nameValidator;\n    private final OrgLeaderValidator leaderValidator;\n    private CancelOrgValidator cancelValidator;\n\n    public OrgHandler(CommonValidator commonValidator\n            , OrgNameValidator nameValidator\n            , OrgLeaderValidator leaderValidator\n            , CancelOrgValidator cancelValidator) {\n        // 为依赖注入赋值...\n    }\n\n    public void updateBasic(Org org, String newName\n                , Long newLeader, Long userId) {\n        updateName(org, newName);\n        updateLeader(org, newLeader);\n        updateAuditInfo(org, userId);\n    }\n\n    public void cancel(Org org, Long userId) {\n        cancelValidator.cancelledOrgShouldNotHasEmp(org.getTenant()\n                        , org.getId());\n        cancelValidator.OnlyEffectiveOrgCanBeCancelled(org);\n        org.setStatus(OrgStatus.CANCELLED);\n        updateAuditInfo(org, userId);\n    }\n\n    private void updateLeader(Org org, Long newLeader) {\n        if (newLeader != null &amp;&amp; !newLeader.equals(org.getLeader())) {\n            leaderValidator.leaderShouldBeEffective(org.getTenant()\n                                , newLeader);\n            org.setLeader(newLeader);\n        }\n    }\n\n    private void updateName(Org org, String newName) {\n        if (newName != null &amp;&amp; !newName.equals(org.getName())) {\n            nameValidator.orgNameShouldNotEmpty(newName);\n            nameValidator.nameShouldNotDuplicatedInSameSuperior(\n                  org.getTenant(), org.getSuperior(), newName);\n            org.setName(newName);\n        }\n    }\n\n    private void updateAuditInfo(Org org, Long userId) {\n        // 设置最后修改人和时间\n    }\n}\n</code></pre><p>与OrgBuilder类似，这个类中的方法基本上也是先校验，再赋值，只不过这里是更改而不是新建。同时OrgHandler没有可变属性，因此可以直接注入到应用服务。</p><h2>提高应用API的封装性</h2><p>下面我们看看怎么提高程序的封装性。</p><p>所谓“封装”，指的是将一个模块的实现细节尽量隐藏在内部，只向外界暴露最小的可访问接口，也叫信息隐藏原则，或最小接口原则，目的是减小模块间的耦合，提高程序的可维护性。这里说的模块是广义的，一个函数、一个类、一个包乃至整个应用系统，都可以看作模块，而我们之前领域建模中说的<strong>模块</strong>模式是狭义的，专门指领域模型里的领域对象所组成的包。</p><p>先看一下系统对外提供的API。我们的系统采用RestfulAPI，以JSON作为参数格式，JSON的结构则是与OrgDto一致的。目前的DTO中有领域对象中所有11个属性，因此，不论增加还是修改，入口参数的JSON格式都是下面这样。</p><pre><code class=\"language-json\">{\n&nbsp; \"createdAt\": \"2022-10-05T06:49:39.659Z\",\n&nbsp; \"createdBy\": 0,\n&nbsp; \"id\": 0,\n&nbsp; \"lastUpdatedAt\": \"2022-10-05T06:49:39.659Z\",\n&nbsp; \"lastUpdatedBy\": 0,\n&nbsp; \"leader\": 0,\n&nbsp; \"name\": \"string\",\n&nbsp; \"orgType\": \"string\",\n&nbsp; \"status\": \"string\",\n&nbsp; \"superior\": 0,\n&nbsp; \"tenant\": 0\n}\n</code></pre><p>我们已经知道，添加和修改操作，实际上都只是用了这些属性的一个子集。现在这样简单粗暴地把所有属性都暴露给客户端，不仅违反了最小接口原则，也容易在理解上发生混淆。</p><p>为了解决这个问题，我们要为每个功能编写单独的参数DTO，只包含必要的参数。DTO本身的修改比较简单，你可以自己试一下。这里我们重点来看一下修改后应用层的包结构。</p><p><img src=\"https://static001.geekbang.org/resource/image/bd/3c/bd9546cc86yy3076d522e906e59e633c.jpg?wh=2900x1760\" alt=\"\"><br>\nCreateOrgRequest和UpdateOrgBasicRequest 分别是添加和修改组织的参数DTO。原来的OrgDto改名为OrgResponse，作为两个功能共同的返回参数类型。另外，这里又出现了一个包结构打横分还是打竖分的问题。</p><p>一些伙伴更喜欢打横分，也就是创建一个dto包，把EmpService和OrgService的DTO都放进去。而我们这里采用的是<strong>打竖分</strong>，也就是把service和这个service用到的DTO放在同一个包内，提高了模块的内聚性。</p><p>修改之后，添加组织的JSON参数格式成了下面这样。</p><pre><code class=\"language-json\">{\n  \"leader\": 0,\n  \"name\": \"string\",\n  \"orgType\": \"string\",\n  \"superior\": 0,\n  \"tenant\": 0\n}\n</code></pre><p>这就简洁多了，关键是缩小了API，系统的封装性提高了。修改组织功能的JSON的优化也是类似的。</p><h2>提高领域对象的封装性</h2><p>改进了系统API的封装之后，我们再来考虑领域对象层面。</p><p>现在的Org对象只是纯粹的DTO，所有属性都通过getter和setter暴露在外，没有任何封装性可言。要提高封装性，可以从两个角度考虑。第一是限制getter和setter的数量；第二是用表示业务含义的接口代替简单的setter和getter。</p><p>由于getter只是用来查询，不会破坏数据，而不恰当的setter则可能破坏数据，导致程序出错，所以相对而言，限制setter比限制getter更重要一些。为了限制setter，我们再列一个表，研究一下在创建了组织以后，哪些属性是可以修改的。<br>\n<img src=\"https://static001.geekbang.org/resource/image/48/d8/481119d0cb2d5ddfddb0bffe436691d8.jpg?wh=2429x2581\" alt=\"\"></p><p>我们可以只为那些可以修改的属性保留setter，其他的只有getter，成为只读属性。再为Org类增加一个包含只读属性的构造器，以便创建对象。</p><p>修改后的Org类是这样的。</p><pre><code class=\"language-plain\">public class Org {\n    private Long id;\n    private Long tenantId;\n    private Long superiorId;\n    private String orgTypeCoDe;\n    private Long leaderId;\n    private String name;\n    private OrgStatus status;\n    private LocalDateTime createdAt;\n    private Long createdBy;\n    private LocalDateTime lastUpdatedAt;\n    private Long lastUpdatedBy;\n\n    public Org(Long tenantId, String orgTypeCoDe\n          , LocalDateTime createdAt, Long createdBy) {\n        // 为属性赋值 ...\n    }\n\n    // 所有属性的 getter ...\n\n    // 保留了 superiorId, leaderId, name,\n    // lastUpdateAt, lastUPdateBy 和 status 的 setter ... \n   \n}\n</code></pre><p>其中OrgId比较特殊，大部分情况下是只读的，但当Repository将新建的Org保存到数据库时，由于id是数据库自动生成的，需要回填id值。这可以通过反射等技巧来绕过去。事实上，很多数据库访问框架就是利用反射，直接为私有属性赋值，以便在不破坏封装的前提下，从数据库中取出对象。</p><p>通过减少领域对象的Setter，我们进一步提高了程序的封装性。</p><h2>通过“表意接口”提高封装性</h2><p>做了这些改进以后，我们再看看在OrgHandler中完成“撤销组织”功能的代码。</p><pre><code class=\"language-java\">package chapter12.unjuanable.domain.orgmng.org;\n// imports ...\n\n@Component\npublic class OrgHandler {\n    //...\n    \n    public void cancel(Org org, Long userId) {\n        cancelValidator.OrgToBeCancelledShouldNotHasEmp(\n                                    org.getTenantId(), org.getId());\n        cancelValidator.OrgToBeCancelledShouldBeEffective(org);\n        org.setStatus(OrgStatus.CANCELLED); // 直接为 Status 赋值\n        updateAuditInfo(org, userId);\n    }\n    \n    // ...\n}\n</code></pre><p>其中，org.setStatus(OrgStatus.CANCELLED) 直接将组织的状态设置成了“已撤销”。从面向对象的角度来看，更好的做法是Org类提供一个cancel() 方法，像下面这样：</p><pre><code class=\"language-java\">package chapter12.unjuanable.domain.orgmng.org;\n// imports ...\n\npublic class Org {\n    //...\n    \n    //Org 自己管理自己的状态\n    public void cancel() { \n        this.status = OrgStatus.CANCELLED;\n    }\n    \n    //...\n}\n</code></pre><p>这样，Org类就可以自己管理自己的状态，OrgHandler就不必了解Org内部状态的转换细节，只需告诉Org需要撤销就可以了，像下面这样。</p><pre><code class=\"language-java\">package chapter12.unjuanable.domain.orgmng.org;\n// imports ...\n\n@Component\npublic class OrgHandler {\n    //...\n    \n    public void cancel(Org org, Long userId) {\n        cancelValidator.OrgToBeCancelledShouldNotHasEmp(\n                        org.getTenant(), org.getId());\n        cancelValidator.OrgToBeCancelledShouldBeEffective(org);\n        org.cancel();   // 只需告诉 Org 要进行撤销，但不必了解 Org 内部细节\n        updateAuditInfo(org, userId);\n    }\n    \n    // ...\n}\n</code></pre><p>类似的，我们看一下“只有有效的组织才能被撤销”这条规则的实现代码。</p><pre><code class=\"language-plain\">package chapter12.unjuanable.domain.orgmng.org.validator;\n// imports...\n\n@Component\npublic class CancelOrgValidator {\n    //...\n\n    // 只有有效的组织才能被撤销\n    public void OnlyEffectiveOrgCanBeCancelled(Org org) {\n        //直接访问了状态属性\n        if (!org.getStatus().equals(OrgStatus.EFFECTIVE)) { \n            throw new BusinessException(\"该组织不是有效状态，不能撤销！\");\n        }\n    }\n    \n    //...\n}\n</code></pre><p>我们看到CancelOrgValidator直接访问了Org的状态，判断是否为有效组织。这实际上又是重构中的一种坏味道，叫做<strong>特性依恋</strong>（Feature Envy）。Status这个特性是属于Org类的，而  CancelOrgValidator要通过访问这个特性来实现自己的逻辑，所以 CancelOrgValidator “依恋”了Org的特性。这是对象封装性被破坏的征兆。</p><p>解决方法是将这段判断逻辑移动到Org类内部，重构后的Org类是这样的。</p><pre><code class=\"language-java\">package chapter12.unjuanable.domain.orgmng.org;\n// imports ...\n\npublic class Org {\n    //...\n    \n    public boolean isEffective() {\n        return status.equals(OrgStatus.EFFECTIVE);\n    }\n      \n    //...\n}\n</code></pre><p>这样，CancelOrgValidator就可以不依赖Org的内部状态了。</p><pre><code class=\"language-java\">package chapter12.unjuanable.domain.orgmng.org.validator;\n// imports...\n\n@Component\npublic class CancelOrgValidator {\n    //...\n\n    // 只有有效的组织才能被撤销\n    public void OnlyEffectiveOrgCanBeCancelled(Org org) {\n        //不再依赖 Org 的内部状态\n        if (!org.isEffective()) { \n            throw new BusinessException(\"该组织不是有效状态，不能撤销！\");\n        }\n    }\n    \n    //...\n}\n</code></pre><p>Org.cancel() 和 Org.isEffective() 既提高了对象的封装性，也表达了这个功能的业务含义，因此也是<strong>表意接口</strong>模式的一种应用。</p><p>上一节的表意接口体现在“领域服务”，这一节体现在“领域对象”。对“表意接口”的运用，往往可以避免“特性依恋”的坏味道，反之，发现和消除“特性依恋”，也会重构出“表意接口”。</p><h2>用继承消除重复</h2><p>下面再来看看Org类还有什么可以优化的地方。</p><p>我们发现，其实每个实体都包含4个审计字段createdAt、createdBy、lastUpdatedAt和 lastUpdatedBy。那么我们可以考虑抽出一个包含这四个属性的父类，减少编写各个类的重复工作。抽出的父类是下面的样子。</p><pre><code class=\"language-plain\">package chapter12.unjuanable.common.framework.domain;\n\nimport java.time.LocalDateTime;\n\npublic abstract class AuditableEntity {\n    protected LocalDateTime createdAt;\n    protected Long createdBy;\n    protected LocalDateTime lastUpdatedAt;\n    protected Long lastUpdatedBy;\n\n    public AuditableEntity(LocalDateTime createdAt, Long createdBy) {\n        this.createdAt = createdAt;\n        this.createdBy = createdBy;\n    }\n\n    // lastUPdatedAt 和 lastUpdatedBy 的 setter 以及所有属性的 getter ...\n  \n}\n</code></pre><p>这个类放在common.framework包里面，因为这种基类属于框架层面。</p><p>在面向对象设计中一个常见的陷阱就是滥用继承。要防止这一倾向，要记住一个原则，<strong>不要仅仅为了复用而使用继承</strong>。你还要问自己一个问题，父类和子类的关系，在语义上，<strong>是否有分类关系，或者概念的普遍和特殊关系</strong>。只有符合这种关系的，才能采用继承，否则应该用“组合”来实现复用。</p><p>在我们的例子中，我们发现审计字段可以复用，只是可能可以采用继承的一个征兆。然后我们再从语义上进行分析。可以说，每个实体都是可审计的，或者说，每类实体都是一类特殊的可审计实体。<strong>我们发现了这种普遍和特殊的分类关系，所以在这里运用继承是合理的</strong>。</p><h2>编程风格回顾</h2><p>在<a href=\"https://time.geekbang.org/column/article/617473\">第10节课</a>中我们说过，具体的编程风格是多种多样的，每种都各有利弊。因此，不可能也没有必要强求一致。关键是理解背后的原理，作出取舍，然后在自己的开发团队中形成比较统一的风格。</p><p>下面总结一下我们这几节课采用的风格的要点，说明背后的原因，以及其他可选的方式。</p><p><strong>第一，领域对象不访问数据库。</strong></p><p>我们在领域对象中既不会显式，也不会隐式访问数据库，目的是使领域对象和数据库解耦，便于维护和测试。</p><p>如果使用JPA并结合延迟加载，领域对象就会隐式地访问数据库；如果在领域对象的方法中写SQL，则会显式地访问数据库。领域对象访问数据库，才能实现更加纯粹的面向对象风格，代价是一般需要对ORM框架有深入的理解，或者增加了领域对象和数据库访问机制的耦合，还可能无意间导致性能等问题。你可以根据这两者的利弊进行取舍。</p><p><strong>第二，领域服务只能读数据库。</strong></p><p>在实现一些业务规则时，需要访问数据库中的数据，因此领域服务需要读数据库。而写库的功能通常可以由应用服务来做，从而减轻领域层的负担。有些伙伴喜欢把写功能也放在领域服务，从而使应用服务非常薄，这样也可以。</p><p><strong>第三，应用服务可以读写数据库。</strong></p><p>纯粹的（通过调用仓库）读写数据库并不包含领域知识，因此放在应用服务似乎更合适一些。比如更新一个对象前，要把这个对象先从数据库中读出来；创建或修改对象后，要存回数据库，这些本身都没有领域逻辑。</p><p><strong>第四，用 ID 表示对象之间的关联。</strong></p><p>如果按偏面向对象的风格，对象之间的关联应该用对象导航的方式来实现。比如说，Org对象的leader属性的类型，应该是Emp（员工），这样就可以在内存中直接从组织对象导航到充当负责人的员工对象了。不过我们的程序中，leader属性仅保存了员工的ID，而不是员工对象。这是考虑到在企业应用中节省带宽和内存。关于对象导航风格，我们会在下个迭代中继续探讨。</p><p><strong>第五，领域对象有自己的领域服务。</strong></p><p>如果是偏面向对象风格，很多领域逻辑可以在领域对象内部完成，因此不一定需要领域服务。但对于偏过程式的风格，由于领域对象不能访问数据库，很多领域逻辑就要外化到领域服务中，因此多数领域对象都会有相应的领域服务。</p><p><strong>第六，在以上前提下利用封装和继承。</strong></p><p>即使是我们这种偏过程式的风格，如果善于利用封装、合理利用继承，也能有效提高程序质量。一个技巧是识别<strong>特性依恋</strong>的坏味道，并重构到<strong>表意接口</strong>。</p><p>最后要说的是，我们这个例子其实比较简单，但体现出的原理和复杂功能是一样的，咱们要以小见大，举一反三。</p><h2>总结</h2><p>好，今天的内容先讲到这里，现在来总结一下。</p><p>这节课我们主要是利用封装和继承，进一步提高了代码质量。我们可以通过两个层面来提高封装性。</p><p><strong>第一个层面</strong>是API的封装。添加和修改组织两种API的参数是不同的，我们只对外暴露出每个API 必须的参数，从而缩小了接口，提高了封装性。</p><p><strong>第二个层面</strong>是领域对象的封装。我们分析了哪些属性是不需要修改的，把这些属性变成只读的，从而缩小了对象的接口。另一方面，我们用<strong>表意接口</strong>封装了状态属性，使外界不需要直接关心状态转换的细节，同时消除了<strong>特性依恋</strong>的坏味道。</p><p>另外，我们还可以利用继承减少代码的重复。在我们的例子里，是通过抽象出AuditableEntity 作为所有实体的父类来实现的。</p><p>最后，我们对这三节课所使用的编程风格进行了回顾，说明了这么做的理由以及一些其他做法。这里没有唯一正确的方式，重要的是根据实际情况进行权衡。</p><p>讲完今天的课，第一个迭代就结束了。通过实现<strong>组织</strong>的<strong>创建</strong>和<strong>修改</strong>功能，我已经把这个迭代需要掌握的知识点都介绍清楚了（为了让你关注重点，我没有把所有的代码实现都写进课程里）。你可以尝试运用这些知识，自己实现其他的功能。</p><p>学完这个迭代，应该可以利用DDD开发一些不太复杂的需求了，你不妨在自己的项目中试一试。</p><p><strong>另外，为了帮助你检验迭代一的学习效果，我策划了加餐1的内容（包括十道选择题和一道建模题目），你可以通过<a href=\"https://time.geekbang.org/column/article/624452\">这个链接</a>去练习。建模题目的解析和参考答案，等你自己亲手练习以后，可以对照<a href=\"https://time.geekbang.org/column/article/629140\">加餐4</a> 的分析点评加深理解。</strong></p><h2>思考题</h2><p>1.对于领域对象，可否利用Java的包级私有权限，进一步增强封装？</p><p>2.在现在的Org类里，只对setter进行了限制，而所有属性都有getter，能否举例说明什么样的属性不应该有getter呢？</p><p>好，今天的课程结束了，有什么问题欢迎在评论区留言。从下节课开始，我们将进入第二个迭代，学习DDD中几个有些难度的内容，包括<strong>聚合</strong>和<strong>值对象</strong>模式以及<strong>泛化</strong>等技能。相信在咱们的共同努力下，你一定能顺利掌握。</p>","neighbors":{"left":{"article_title":"11｜代码实现（中）：怎样创建领域对象、实现领域逻辑？","id":618175},"right":{"article_title":"13｜迭代二概述：怎样更深刻地理解领域知识？","id":619632}},"comments":[{"had_liked":false,"id":367714,"user_name":"别天神","can_delete":false,"product_type":"c1","uid":1107606,"ip_address":"上海","ucode":"42A08D6EF5C59A","user_header":"https://static001.geekbang.org/account/avatar/00/10/e6/96/eb143e46.jpg","comment_is_top":true,"comment_ctime":1675496433,"is_pvip":false,"replies":[{"id":133947,"content":"这个思路不错👍🏻","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1675641950,"ip_address":"广东","comment_id":367714,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"1、对于包级私有权限来增强封装我觉得是可行的，领域对象的更改我认为只能通过领域方法来做，一方面保护了领域状态的一致性，另一方面也能最大程度确保开发人员随意更改状态，所以通常我觉得 领域对象内部不应该存在set方法，取而代之的是更加“表意”的领域方法。\n\n2、但是从存储介质进行领域对象恢复的时候，有时候又需要set方法，恢复领域对象应该无需关心业务，所以存在一些矛盾点：\n- 为了保护业务一致性和封装，不暴露set\n- 为了恢复领域对象，我们需要set，更进一步，为了使用工具类进行属性的copy还要求set必须是public的\n\n在实际实现上，我采用了一些折中的方案，\n- 领域对象自身不具备set方法，有一个包级别的领域对象Builder，Builder中承载set，如@Builder(setterPrefix = &quot;set&quot;, toBuilder = true, access = AccessLevel.PROTECTED)\n- 这样可以在同一个包内访问builder, 构建builder实例，同时因为setXxx是public的，还能解决属性copy问题\n- builder.build()可以转换成领域对象\n- 可以建一个FQN一样的包(和仓储实现同模块)，里面仅存放着 持久化对象到领域对象的转换，因为包名一样，可以访问到set\n","like_count":4,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":602042,"discussion_content":"这个思路不错👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675641950,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366795,"user_name":"Jaising","can_delete":false,"product_type":"c1","uid":1037630,"ip_address":"安徽","ucode":"F68830B7B90F96","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d5/3e/7f3a9c2b.jpg","comment_is_top":false,"comment_ctime":1674229689,"is_pvip":false,"replies":[{"id":134793,"content":"很佩服你的学习精神，加油！","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1677938937,"ip_address":"广东","comment_id":366795,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"还在犹豫是否要翻过墙的时候，就先把帽子丢到墙的另一边，剩下的自然会有办法。\n\n以我切身体会仅仅迭代一学完就治好了不少DDD恐惧症，真的感谢钟老师和编辑小新的最小闭环设计，对零基础入门DDD不要太好，平时不愿记笔记的我都能跟着老钟医通过重新演绎更新了五篇——事件风暴、领域建模、数据库设计、分层架构和代码实现，小结与导航在这里：https:&#47;&#47;juejin.cn&#47;post&#47;7190270005072625723。\n\n辞旧迎新，给自己的最好礼物就是持续学习，学以致用，换取职业生涯不断上台阶的可能，终身成长就有了立身之本，用来抵御各类危机。新的一年从入门DDD开始，会发现软件开发的世界照进了新的光，让我们一起加油！\n\n祝各位兔年快乐！","like_count":13,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":607555,"discussion_content":"很佩服你的学习精神，加油！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1677938937,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2721761,"avatar":"https://static001.geekbang.org/account/avatar/00/29/87/e1/b3edcc09.jpg","nickname":"范飞扬","note":"","ucode":"A665DF46833A81","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636968,"discussion_content":"感觉是看过乔老师专栏的战友哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1707384286,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1037630,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d5/3e/7f3a9c2b.jpg","nickname":"Jaising","note":"","ucode":"F68830B7B90F96","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2721761,"avatar":"https://static001.geekbang.org/account/avatar/00/29/87/e1/b3edcc09.jpg","nickname":"范飞扬","note":"","ucode":"A665DF46833A81","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":652741,"discussion_content":"哈哈就是，乔老师的专栏构建了一个工程师进阶框架","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1729559793,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":636968,"ip_address":"安徽","group_id":0},"score":652741,"extra":""}]}]},{"had_liked":false,"id":365401,"user_name":"bin","can_delete":false,"product_type":"c1","uid":1047442,"ip_address":"广东","ucode":"F540DADF3AAD87","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/92/4de0c05c.jpg","comment_is_top":false,"comment_ctime":1672455833,"is_pvip":false,"replies":[{"id":133260,"content":"目前的风格就是以是否依赖数据库来区分，参考课程中对代码风格的总结。当然，也可以制定你自己的代码规则。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1673090283,"ip_address":"广东","comment_id":365401,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"handler如果不依赖数据库，这部分业务逻辑好像也可以放到领域对象里面。有没有一个好的边界区分？","like_count":7,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598791,"discussion_content":"目前的风格就是以是否依赖数据库来区分，参考课程中对代码风格的总结。当然，也可以制定你自己的代码规则。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673090283,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365560,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"广东","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1672760083,"is_pvip":false,"replies":[{"id":133248,"content":"关于第2问，可以扩展一下。比如对于状态，如果用 isEffective(), isTerminated()之类的方法封装了，那么未必要用 getStatus()了。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1673058520,"ip_address":"广东","comment_id":365560,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"原来我现在的编程风格是偏过程式的\n\n思考题\n1. 可以。这样确实可以增强封装。再疯狂一点，可以使用 Java 模块化技术，让反射都无法打破封装。\n2. 没发现不应该有 getter 的属性。","like_count":4,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598757,"discussion_content":"关于第2问，可以扩展一下。比如对于状态，如果用 isEffective(), isTerminated()之类的方法封装了，那么未必要用 getStatus()了。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1673058520,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":598943,"discussion_content":"原来是这样，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673234002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":598757,"ip_address":"浙江","group_id":0},"score":598943,"extra":""}]}]},{"had_liked":false,"id":367263,"user_name":"H·H","can_delete":false,"product_type":"c1","uid":2108194,"ip_address":"上海","ucode":"113E95BA6B6F51","user_header":"https://static001.geekbang.org/account/avatar/00/20/2b/22/79d183db.jpg","comment_is_top":false,"comment_ctime":1675078864,"is_pvip":false,"replies":[{"id":133829,"content":"你是指把repository注入领域对象，从而使领域对象可以访问数据库吗？理论上可以，就看你要不要选这种编程风格。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1675227609,"ip_address":"广东","comment_id":367263,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"领域对象是否可以通过依赖注入的方式注入 仓储Repository？","like_count":2,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":601340,"discussion_content":"你是指把repository注入领域对象，从而使领域对象可以访问数据库吗？理论上可以，就看你要不要选这种编程风格。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675227609,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":3,"child_discussions":[{"author":{"id":2108194,"avatar":"https://static001.geekbang.org/account/avatar/00/20/2b/22/79d183db.jpg","nickname":"H·H","note":"","ucode":"113E95BA6B6F51","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":601342,"discussion_content":"我之前是这样实现了，这种方法可能会导致领域对象很重，但是领域服务很轻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675227825,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":601340,"ip_address":"上海","group_id":0},"score":601342,"extra":""},{"author":{"id":1022136,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/98/b8/e4f01f2c.jpg","nickname":"Paul","note":"","ucode":"4F0AA3B0BDDD68","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":606325,"discussion_content":"我也理解更应该将 repo 注入领域对象，这样更能保证领域对象完整性，应用服务直接save（org）会不会不能保证 org 完整性？希望老师帮忙解惑😀，感谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1677073897,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":601340,"ip_address":"广东","group_id":0},"score":606325,"extra":""},{"author":{"id":1057456,"avatar":"https://static001.geekbang.org/account/avatar/00/10/22/b0/050676f5.jpg","nickname":"樱花","note":"","ucode":"432F43127D847A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":649513,"discussion_content":"不理解这种风格\n在golang中，循环依赖是被禁止的。\n正常情况下repo层是依赖领域对象的，\n但领域对象再依赖repo加载数据就循环依赖了，\n老师怎么解决这个问题呢？\n还是说golang语言只能在领域对象显式写SQL加载数据？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1723512239,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":601340,"ip_address":"广东","group_id":0},"score":649513,"extra":""}]}]},{"had_liked":false,"id":366546,"user_name":"6点无痛早起学习的和尚","can_delete":false,"product_type":"c1","uid":1703256,"ip_address":"北京","ucode":"33A8A1CDA103F9","user_header":"https://static001.geekbang.org/account/avatar/00/19/fd/58/1af629c7.jpg","comment_is_top":false,"comment_ctime":1673918851,"is_pvip":false,"replies":[{"id":134774,"content":"加了@Transactional不会有什么坏处，如果以后逻辑更复杂了，可以避免忘掉。\n@Autowired注入的属性一般都用final，我有些地方没注意，等我稍后统一改一下","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1677930562,"ip_address":"广东","comment_id":366546,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"一些问题：\n5. 为什么在 addOrg 加事务？里面就一个 save 操作，是否没必要加@Transactional\n6. 很多用@Autowired 注入的属性，有些是 final，有些不是 final，这个有什么讲究吗？","like_count":2,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":607529,"discussion_content":"加了@Transactional不会有什么坏处，如果以后逻辑更复杂了，可以避免忘掉。\n@Autowired注入的属性一般都用final，我有些地方没注意，等我稍后统一改一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1677930562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":377925,"user_name":"Breakthrough","can_delete":false,"product_type":"c1","uid":2822757,"ip_address":"北京","ucode":"80EB01B5D6529D","user_header":"https://static001.geekbang.org/account/avatar/00/2b/12/65/846d566c.jpg","comment_is_top":false,"comment_ctime":1689562804,"is_pvip":false,"replies":[{"id":138093,"content":"关键是有领域模型、词汇表、业务规则表，可以把这几个制品融入到目前使用的文档中。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1691070601,"ip_address":"广东","comment_id":377925,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"钟老师，DDD设计完成后的交付文档一般长啥样，是不是也要做类似设计需求说明书的WORD档。如果是，是否有相关的模板参考下？","like_count":1,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":624934,"discussion_content":"关键是有领域模型、词汇表、业务规则表，可以把这几个制品融入到目前使用的文档中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1691070601,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365474,"user_name":"龙腾","can_delete":false,"product_type":"c1","uid":2864424,"ip_address":"广东","ucode":"81E70A02EB02A0","user_header":"https://static001.geekbang.org/account/avatar/00/2b/b5/28/3de99570.jpg","comment_is_top":false,"comment_ctime":1672641357,"is_pvip":false,"replies":[{"id":133263,"content":"“调用Repository，从数据库里取出一个领域对象”这句话是不需要和业务人员谈的，因此这句话反应的逻辑不包含领域知识，","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1673090756,"ip_address":"广东","comment_id":365474,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"老师请教一下，“第三，应用服务可以读写数据库。”这块没太明白，什么情况下读写数据库不包含领域知识呢？咱们的数据库设计不就是按照领域来划分设计的吗，只要读写都是在领域内进行的吧？","like_count":1,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598794,"discussion_content":"“调用Repository，从数据库里取出一个领域对象”这句话是不需要和业务人员谈的，因此这句话反应的逻辑不包含领域知识，","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1673090756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":389976,"user_name":"开心","can_delete":false,"product_type":"c1","uid":1517457,"ip_address":"广东","ucode":"C8E08E8724C7CE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKkzrezV2dOBAgickt9DLzabz3dNFYyDEVXENMQ5ibrWhFbFqXIOia3ZaR21pozvB7UfoxJx4Ar688sA/132","comment_is_top":false,"comment_ctime":1714021131,"is_pvip":false,"replies":[{"id":143677,"content":"正如第10课说的，我们这门课采用的是“偏过程”的风格，“在领域对象不直接或间接访问数据库的前提下，尽量面向对象”。所以你的感觉是正确的。当然，也可以采用更加面向对象的编程方式，这时通常要用JPA了。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1731549140,"ip_address":"广东","comment_id":389976,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"看到这里，没有感受到太多面向对象，更多是面向过程的实现。领域业务大都是放在了没有属性只有方法的领域服务，更多的是如何定义领域服务模块。有点不解。","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":653899,"discussion_content":"正如第10课说的，我们这门课采用的是“偏过程”的风格，“在领域对象不直接或间接访问数据库的前提下，尽量面向对象”。所以你的感觉是正确的。当然，也可以采用更加面向对象的编程方式，这时通常要用JPA了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1731549141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385426,"user_name":"路上","can_delete":false,"product_type":"c1","uid":1105864,"ip_address":"北京","ucode":"A004E01C3F1BFA","user_header":"https://static001.geekbang.org/account/avatar/00/10/df/c8/0ddf6f63.jpg","comment_is_top":false,"comment_ctime":1702618085,"is_pvip":false,"replies":[{"id":140488,"content":"没错，后面就会讲到这个思路。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1702805078,"ip_address":"广东","comment_id":385426,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"类似撤销这部分校验逻辑，目前看领域对象自己就可以校验，目前是在外层进行的校验之后调用领域方法进行状态变更\n是否可以在领域对象变更状态的方法内部自己进行校验呢","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633932,"discussion_content":"没错，后面就会讲到这个思路。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702805078,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":376308,"user_name":"末日，成欢","can_delete":false,"product_type":"c1","uid":1812201,"ip_address":"陕西","ucode":"BBAEBB9C93558A","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLm8skz4F7FGGBTXWUMia6qVEc00BddeXapicv5FkAx62GmOnUNEcE4scSR60AmappQoNdIQhccKsBA/132","comment_is_top":false,"comment_ctime":1686659642,"is_pvip":false,"replies":[{"id":137254,"content":"第一：是的\n第二：为了避免累赘，或者你看能否有更好的写法贡献出的？\n         对save的调用不算领域逻辑\n第三：粒度大体相当于一个事务\n本课程的的代码是偏过程式的。或许以后有时间给大家讲讲真正的面向对象编程是什么样。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1686839999,"ip_address":"广东","comment_id":376308,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"老师，有一些疑问。\n第一，领域对象不访问数据库。\n这里的不访问数据库,是指可以在领域服务中访问,而不要在领域对象中里访问数据是吧。\n第二个疑问, 修改组织信息和撤销组织, 第一步骤是查询组织是否为空, 这应该也是领域服务中的逻辑判断,应该也放在领域服务中把。这里直接放在应用服务的考虑是什么？\n还有为何save方法没有放到领域服务中？这里的应该不是应用逻辑把？\n第三个疑问, 事件风暴法中的第一个识别领域事件,这个领域事件维度多大呢,比如我想进行任务分解, 应该在哪个流程进行分解才合适呢？\n目前代码看到这里,还是偏向过程化, 只是利用了一些软件的设计原则(比如solid),代码更业务化, 还没理解有啥好处","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":621133,"discussion_content":"第一：是的\n第二：为了避免累赘，或者你看能否有更好的写法贡献出的？\n         对save的调用不算领域逻辑\n第三：粒度大体相当于一个事务\n本课程的的代码是偏过程式的。或许以后有时间给大家讲讲真正的面向对象编程是什么样。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1686839999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":375295,"user_name":"🏄🏻米兰的大铁匠🎤🎈","can_delete":false,"product_type":"c1","uid":1177832,"ip_address":"天津","ucode":"704DB6905F96D1","user_header":"https://static001.geekbang.org/account/avatar/00/11/f8/e8/bbd1b66d.jpg","comment_is_top":false,"comment_ctime":1685262300,"is_pvip":false,"replies":[{"id":137137,"content":"可以的","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1685968784,"ip_address":"广东","comment_id":375295,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"请问老师，&quot;只有有效的组织才能被撤销&quot;这段校验逻辑是否可以更进一步的内聚到org对象本身的cancel()方法中，这样外部触发&quot;撤销&quot;动作时，只需调用一个方法就行了","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":620235,"discussion_content":"可以的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1685968784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":374895,"user_name":"marker","can_delete":false,"product_type":"c1","uid":1094478,"ip_address":"四川","ucode":"DDBF1CD83665C4","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/4e/5f22b09d.jpg","comment_is_top":false,"comment_ctime":1684593710,"is_pvip":false,"replies":[{"id":137140,"content":"不同规则情况不同，要举出具体验证逻辑才能说明白。一般来说，数据在哪里，逻辑就放在哪里。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1685968986,"ip_address":"广东","comment_id":374895,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"老师，有一个问题就是领域服务，比如下单需要验证商品一系列的验证、但是商品和订单在两个bc下、会去做rpc操作、这个应该放在哪里合适","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":620238,"discussion_content":"不同规则情况不同，要举出具体验证逻辑才能说明白。一般来说，数据在哪里，逻辑就放在哪里。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1685968987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":372176,"user_name":"Hesher","can_delete":false,"product_type":"c1","uid":1026832,"ip_address":"北京","ucode":"99AB8B1704CB7E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ab/10/b812ff3e.jpg","comment_is_top":false,"comment_ctime":1680821088,"is_pvip":false,"replies":[{"id":136140,"content":"1、Java中区分了包级私有（package private）和私有（private)两种权限，和C++有所不同。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1681634031,"ip_address":"广东","comment_id":372176,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"回答一下课后问题：\n1. 一般直接用私有，避免被外部访问，即使是包内，封装性一步到位；\n2. 审计字段一般不会被业务使用，可以没有getter，其他字段看情况。","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":614024,"discussion_content":"1、Java中区分了包级私有（package private）和私有（private)两种权限，和C++有所不同。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681634031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371460,"user_name":"Geek_e10c1b","can_delete":false,"product_type":"c1","uid":3571487,"ip_address":"江苏","ucode":"FD99BF9161CBA2","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJzdBWzImYq5HgQvXr2APJTfjQgm0qiatW4ykjHy2aQZDcbIBZmEHlCZ6ibVQjPAOec0eVJkg5hW5hQ/132","comment_is_top":false,"comment_ctime":1679970746,"is_pvip":false,"replies":[{"id":135598,"content":"这是个好问题。\n\n首先，是否要懒加载取决于我们选择的编程范式。\n如果选择偏过程式的编程，那么是否加载某个对象，在应用服务或领域服务中已经确定了，不存在懒加载；如果选择偏对象式的编程，才存在懒加载的需求。\n这两种方式没有绝对的对错，只是取决于团队的选择。在课程里，为了照顾多数国内同学的编程习惯，选择了偏过程的范式，在这种方式中，领域对象不访问数据库，也不存在懒加载。\n但这并不意味着偏过程式的编程是唯一正确的方式。如果你的团队经过权衡，选择了偏对象式的范式，那么领域对象就可以访问数据库（直接或间接），可以使用懒加载。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1680161918,"ip_address":"广东","comment_id":371460,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":" 老师，领域对象中不访问数据库，那如何对某些属性进行懒加载呢","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":611545,"discussion_content":"这是个好问题。\n\n首先，是否要懒加载取决于我们选择的编程范式。\n如果选择偏过程式的编程，那么是否加载某个对象，在应用服务或领域服务中已经确定了，不存在懒加载；如果选择偏对象式的编程，才存在懒加载的需求。\n这两种方式没有绝对的对错，只是取决于团队的选择。在课程里，为了照顾多数国内同学的编程习惯，选择了偏过程的范式，在这种方式中，领域对象不访问数据库，也不存在懒加载。\n但这并不意味着偏过程式的编程是唯一正确的方式。如果你的团队经过权衡，选择了偏对象式的范式，那么领域对象就可以访问数据库（直接或间接），可以使用懒加载。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680161918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":369782,"user_name":"Fredo","can_delete":false,"product_type":"c1","uid":1438470,"ip_address":"广东","ucode":"681D6692617DAB","user_header":"https://static001.geekbang.org/account/avatar/00/15/f3/06/8da1bf0c.jpg","comment_is_top":false,"comment_ctime":1677934375,"is_pvip":false,"replies":[{"id":135086,"content":"“最小接口原则”建议只暴露最少的字段，这是通用的最佳实践。只有在有充分理由的情况下才应该打破。是个权衡问题。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1678843078,"ip_address":"广东","comment_id":369782,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"&quot;简单粗暴地把所有属性都暴露给客户端&quot; 这里实际前后端开发过程中，前端是否会觉得你直接给我提供一个共用的结构，对我前端来说更方便呢？","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609112,"discussion_content":"“最小接口原则”建议只暴露最少的字段，这是通用的最佳实践。只有在有充分理由的情况下才应该打破。是个权衡问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678843078,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368122,"user_name":"py","can_delete":false,"product_type":"c1","uid":1496577,"ip_address":"上海","ucode":"2372522D715419","user_header":"https://static001.geekbang.org/account/avatar/00/16/d6/01/2448b4a9.jpg","comment_is_top":false,"comment_ctime":1675914597,"is_pvip":false,"replies":[{"id":135182,"content":"不错","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1678976371,"ip_address":"广东","comment_id":368122,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"1. 可以\n2. 不需要被外部知道的信息不许要getter，比如一般情况下创建时间等","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609443,"discussion_content":"不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678976371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":367155,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"北京","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1674978702,"is_pvip":true,"replies":[{"id":135204,"content":"第1题说的包级私有权限，指的是方法名前面什么都不加（不加public、private、protected）的权限，这种方法只有自己包里的其他对象才能访问。这是Java特有的一种权限修饰符，C++里是没有的。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1678983144,"ip_address":"广东","comment_id":367155,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"从 org.setStatus(OrgStatus.CANCELLED) 到 org.cancel() 的重构，这个是不是应该在面向对象分析的时候就能够做到？org.isEffective() 也有类似的问题。\n\n1. 领域对象不访问数据库\n2. 领域服务只读数据库\n3. 应用服务可以写数据库\n4. 组合优于继承\n\n这三条编程风格，其实从开始设计的时候就采纳。\n\n对于思考题，\n\n1. 对于 Java 的包级私有权限，我的理解是可以默认为私有，只有在需要的时候才改为 protect 或者是 public，也就是说默认采用相对严格的封装。\n2. 对于不适合 getter 的属性，我的理解是所有没有明显业务含义的，都不需要 getter，比如 ID 字段，以及一些采用 ID 来表示对象之间关系的字段，例如 leaderID 就不需要 getter，可以补充一个 getLeader 的公开方法。\n\n课程看到这里，感觉在讲领域驱动的同时，也在说明面向对象的分析和设计，甚至包括代码实现和重构。","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609491,"discussion_content":"第1题说的包级私有权限，指的是方法名前面什么都不加（不加public、private、protected）的权限，这种方法只有自己包里的其他对象才能访问。这是Java特有的一种权限修饰符，C++里是没有的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678983144,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1020525,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","nickname":"escray","note":"","ucode":"1F4204930E47C4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":603077,"discussion_content":"代码可以参考 https://github.com/escray/geektime/tree/master/DDD-hand-in-hand","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675931765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366939,"user_name":"Johar","can_delete":false,"product_type":"c1","uid":1101969,"ip_address":"重庆","ucode":"834136A6F64CDC","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/91/89123507.jpg","comment_is_top":false,"comment_ctime":1674636961,"is_pvip":false,"replies":[{"id":135210,"content":"不错","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1678983542,"ip_address":"广东","comment_id":366939,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"1. 对于领域对象，可否利用 Java 的包级私有权限，进一步增强封装？\n可以\n2. 在现在的 Org 类里，只对 setter 进行了限制，而所有属性都有 getter，能否举例说明什么样的属性不应该有 getter 呢？\n应用层不需要的字段，或者是需要进行装换字段","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609498,"discussion_content":"不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678983542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365895,"user_name":"leesper","can_delete":false,"product_type":"c1","uid":1351104,"ip_address":"广东","ucode":"CC76320571BECA","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/c0/cb5341ec.jpg","comment_is_top":false,"comment_ctime":1673185523,"is_pvip":false,"replies":[{"id":133301,"content":"关于第2题，密码确实是一种。还有些只用于技术实现，业务不可见的，也未必要暴露出来。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1673239340,"ip_address":"广东","comment_id":365895,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"思考题：\n1. 可以，这种领域对象只在领域内使用，出了包完全访问不到，应该是一种纯的领域对象抽象\n2. 我觉得应该是某种类似于密码，轻易不可随便读的属性，可以没有getter方法","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598960,"discussion_content":"关于第2题，密码确实是一种。还有些只用于技术实现，业务不可见的，也未必要暴露出来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673239340,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1332753,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/4UBeJ4vlwbBU8ibVz6hdgr2Qozco6xSaIgRfNd2zvPPU7BTINsgKcW3MuQmrZ2A3AB0dyiccoHubZxukLZWmHVibw/132","nickname":"plimlips","note":"","ucode":"3E58B5A6721FF3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":600551,"discussion_content":"如果领域对象中存在仅仅为技术实现才有的属性，那这个领域对象是不是就不那么业务了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674516293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":598960,"ip_address":"重庆","group_id":0},"score":600551,"extra":""}]}]},{"had_liked":false,"id":365414,"user_name":"虚竹","can_delete":false,"product_type":"c1","uid":1691109,"ip_address":"广东","ucode":"8D8C96C793724E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJIocn8OMjfSGqyeSJEV3ID2rquLR0S6xo0ibdNYQgzicib6L6VlqWjhgxOqD2iaicX1KhbWXWCsmBTskA/132","comment_is_top":false,"comment_ctime":1672477747,"is_pvip":false,"replies":[{"id":133256,"content":"关于第2点，要还要看着5个对象之间有没有联系。最好举出具体的案例，才好回答。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1673089977,"ip_address":"广东","comment_id":365414,"utype":1}],"discussion_count":3,"race_medal":0,"score":4,"product_id":100311801,"comment_content":"1 这里的领域对象对应传统写法里的跟数据库表对应的XXEnity对象，传统上基本不会在XXEntity里写逻辑，而是在XXService里封装方法写逻辑，但似乎确实某些逻辑写这里最合适，比如数据状态是否有效，方便复用和修改\n2 如果某个校验涉及到5个领域对象（即需要5张表中的数据），是需要把5个领域对象都传入XXValidator，然后调用各个领域对象各自的方法组合起来使用？还是会基于这5个对象再进行一层封装，然后再传入XXValidator？","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598787,"discussion_content":"关于第2点，要还要看着5个对象之间有没有联系。最好举出具体的案例，才好回答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673089977,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":1691109,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJIocn8OMjfSGqyeSJEV3ID2rquLR0S6xo0ibdNYQgzicib6L6VlqWjhgxOqD2iaicX1KhbWXWCsmBTskA/132","nickname":"虚竹","note":"","ucode":"8D8C96C793724E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":598931,"discussion_content":"谢谢老师的解答，老师下边要讲的聚合可能可以解决第2个问题，先看看聚合部分","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673230333,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":598787,"ip_address":"北京","group_id":0},"score":598931,"extra":""},{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":1691109,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJIocn8OMjfSGqyeSJEV3ID2rquLR0S6xo0ibdNYQgzicib6L6VlqWjhgxOqD2iaicX1KhbWXWCsmBTskA/132","nickname":"虚竹","note":"","ucode":"8D8C96C793724E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":599309,"discussion_content":"后续有什么心得体会期待你在留言区继续分享。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673435253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":598931,"ip_address":"北京","group_id":0},"score":599309,"extra":""}]}]},{"had_liked":false,"id":366863,"user_name":"Sam Jiang","can_delete":false,"product_type":"c1","uid":3067009,"ip_address":"上海","ucode":"C9B0173A161175","user_header":"https://static001.geekbang.org/account/avatar/00/2e/cc/81/9514a363.jpg","comment_is_top":false,"comment_ctime":1674474918,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100311801,"comment_content":"问题一：个人觉得可以。\n问题二：如果getter返回的是容器类对象，需要防止客户程序通过引用修改容器。一种解决办法是返回不可变的容器，就无法增删元素了，但还是可以修改其中某个元素的属性。","like_count":0},{"had_liked":false,"id":365587,"user_name":"燃","can_delete":false,"product_type":"c1","uid":1337002,"ip_address":"浙江","ucode":"3F4AB00C8B93E7","user_header":"https://static001.geekbang.org/account/avatar/00/14/66/aa/639a276f.jpg","comment_is_top":false,"comment_ctime":1672802358,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":4,"product_id":100311801,"comment_content":"使用聚合对象的时候，比如电商领域，主单子单1-n关系，应该统一由聚合根暴露get，不能随意其他地方也能访问到子单对象。","like_count":0,"discussions":[{"author":{"id":1026832,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ab/10/b812ff3e.jpg","nickname":"Hesher","note":"","ucode":"99AB8B1704CB7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":601548,"discussion_content":"你要暴露时多半就是各种查询场景，用CQRS模式，就可以单独暴露了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675293517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}