{"id":740879,"title":"第 10 章 保护 Web 安全(1)","content":"<blockquote>\n<p><strong>本章内容</strong></p>\n<ul>\n<li>Spring Security 的基本情况</li>\n<li>基本的认证与授权管理方法</li>\n<li>几种常见 Web 攻击的应对措施</li>\n<li>简单的 REST API 客户端认证方法</li>\n</ul>\n</blockquote>\n<p>安全是开发者永远绕不开的话题，尤其是现在大家的安全意识在不断地提高，越来越重视对信息安全的保护；与此同时，黑产或者灰产也对用户和系统虎视眈眈，这就对系统开发者提出了更高的要求。你很难想象没有一点儿安全防护、在网上“裸奔”的系统。除了基础的系统安全措施，在系统开发过程中，开发者也要加入更多安全方面的考量。本章就让我们来聊聊如何在 Spring 开发的 Web 项目中增加一些安全措施。</p>\n<h2 id=\"nav_point_150\">10.1　认识 Spring Security</h2>\n<p>Spring Security 是 Spring 家族中专门用来提供认证（authentication）与授权（authorization）的一款框架，同时还对一些常见的攻击场景提供了对应的防御措施。对于基于 Spring Framework 开发的系统而言，Spring Security 算得上是安全加固的首选框架，可以帮助我们更方便地打造一个相对安全的 Web 系统。</p>\n<p>回顾 Spring Security 的历史，最早可以追溯到 2003 年，彼时的 Spring Framework 也才刚刚起步不久。虽然 Spring 团队认为安全是个非常值得投入的领域，但实在是无暇顾及这块。Ben Alex 开发了一个名为“The Acegi Security System for Spring”的项目 <span class=\"comment-number\">1</span>，后来该项目被纳入 Spring 项目集，并于 2006 年 5 月发布了正式的 1.0.0 版本，在经历了大量的改进后，于 2007 年底正式改名为 Spring Security。现在的 Spring Security 项目非常活跃，已经与 Spring Framework 一样，成为 Java Web 开发过程中安全相关领域的事实标准了。</p><!-- [[[read_end]]] -->\n\n<p>Spring Security 主要提供了如下一些特性。</p>\n<ul>\n<li><strong>身份认证</strong>，证明你是谁。Spring Security 支持多种不同类型的认证，例如基于用户名和密码的认证，基于 JAAS（Java Authentication and Authorization Service）的认证，以及 CAS 等。</li>\n<li><strong>操作授权</strong>，规定你能做什么。Spring Security 提供了相对完善的 RBAC（Role-Based Access Control，基于角色的访问控制）权限，通过表达式就能方便地完成相关配置，将粒度控制到方法级别。</li>\n<li><strong>常见攻击防御</strong>，在防火墙之外，再给应用穿套“铠甲”。Spring Security 能提供的防护种类有限，主要是针对 CSRF 和 HTTP 请求加固的。</li>\n</ul>\n<h3 id=\"nav_point_151\">10.1.1　模块介绍</h3>\n<p>从 Spring Security 3.0 开始，Spring Security 被分成了多个模块，放在不同的 Jar 中，我们可以按需引入相关的依赖。就这一点而言，它与 Spring Framework 的风格是高度一致的。表 10-1 列举了一些主要的模块。</p>\n<p><strong>表 10-1　Spring Security 的一些主要模块</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>Jar 包</p></th>\n<th><p>说明</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>spring-security-core.jar</p></td>\n<td><p>核心模块，包含了主要的认证与授权支持</p></td>\n</tr>\n<tr>\n<td><p>spring-security-web.jar</p></td>\n<td><p>提供 Web 相关的安全支持，大部分情况下都会用到它</p></td>\n</tr>\n<tr>\n<td><p>spring-security-config.jar</p></td>\n<td><p>提供 XML 与 Java 配置方式，可以辅助进行各种配置</p></td>\n</tr>\n<tr>\n<td><p>spring-security-ldap.jar</p></td>\n<td><p>提供 LDAP（Lightweight Directory Access Protocol）相关支持，很多公司都采用 LDAP 进行用户管理，因此 LDAP 的支持很实用</p></td>\n</tr>\n<tr>\n<td><p>spring-security-oauth2-*.jar</p></td>\n<td><p>提供了 OAuth 2.0 相关的支持。除了核心相关内容，还有客户端的支持和简单的资源服务器实现</p></td>\n</tr>\n</tbody>\n</table>\n<p>到了 Spring Security 5.<em>x</em> 的时代，除了同步的 Servlet 应用，Spring Security 还开始支持 Spring WebFlux 这样的响应式应用程序。不过在本章中，我们还是更多地聚焦于 Servlet 应用。</p>\n<h3 id=\"nav_point_152\">10.1.2　工作原理</h3>\n<p>Spring Security 针对 Web 应用做了安全加固，本质上是在应用的 Servlet<span class=\"comment-number\">2</span> 执行前后做了一些拦截。我们可以把它理解为类似 AOP 的方式，只不过这个拦截是依托于 Servlet 的 <code>Filter</code> 过滤器接口来实现的。</p>\n\n<p>既然是和 Spring Framework 搭配使用的，我们自然希望将尽可能多的东西交由 Spring 容器来托管，因此 Spring Security 提供了一个 <code>DelegatingFilterProxy</code>。它是一个标准的 Servlet 过滤器，注册到 Servlet 的容器中，但所有的操作都由 Spring 容器中那些实现了 <code>Filter</code> 的 Bean 来完成。我们可以认为 <code>DelegatingFilterProxy</code> 充当了 Servlet 容器与 Spring 容器之间的桥梁。</p>\n<p>通常情况下，系统中用到的过滤器不止一个，仅 Spring Security 就提供了大量不同作用的 Servlet 过滤器。如果每个都需要我们做特别的配置，那工作量无疑是巨大的。因此，我们直接在 <code>DelegatingFilterProxy</code> 里配置一个 <code>FilterChainProxy</code>，由它来调用 <code>SecurityFilterChain</code>（默认实现是 <code>DefaultSecurityFilterChain</code>），后者会管理所涉及的 <code>Filter</code> Bean。针对当前请求该对应哪些过滤器，都由 <code>SecurityFilterChain</code> 来决定。Spring Security 针对不同安全需求提供了大量过滤器，具体可见表 10-2。</p>\n<p><strong>表 10-2　Spring Security 提供的部分 <code>Filter</code> 实现</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p><code>Filter</code></p></th>\n<th><p>作用</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>CorsFilter</code></p></td>\n<td><p>处理 CORS（Cross-Origin Resource Sharing，跨域资源共享）的 <code>Filter</code> 实现</p></td>\n</tr>\n<tr>\n<td><p><code>CsrfFilter</code></p></td>\n<td><p>处理 CSRF（Cross-Site Request Forgery，跨站请求伪造）的 <code>Filter</code> 实现</p></td>\n</tr>\n<tr>\n<td><p><code>UsernamePasswordAuthenticationFilter</code></p></td>\n<td><p>处理用户名与密码认证的 <code>Filter</code> 实现</p></td>\n</tr>\n<tr>\n<td><p><code>AnonymousAuthenticationFilter</code></p></td>\n<td><p>处理匿名请求的 <code>Filter</code> 实现</p></td>\n</tr>\n<tr>\n<td><p><code>RememberMeAuthenticationFilter</code></p></td>\n<td><p>实现“记住我”功能的 <code>Filter</code> 实现</p></td>\n</tr>\n<tr>\n<td><p><code>BasicAuthenticationFilter</code></p></td>\n<td><p>处理 HTTP Basic 认证的 <code>Filter</code> 实现</p></td>\n</tr>\n<tr>\n<td><p><code>ExceptionTranslationFilter</code></p></td>\n<td><p>翻译异常信息的 <code>Filter</code> 实现</p></td>\n</tr>\n</tbody>\n</table>\n<p>如果用一张图来概括 Spring Security 的处理流程，它应该如图 10-1 所示。客户端发起请求，进入 Servlet 容器后会交由一系列 Servlet 过滤器进行处理，最后再走到 <code>DispatcherServlet</code>，处理后的结果再反向经过过滤器。其中的 <code>DelegatingFilterProxy</code> 在处理时会把请求转给在 Spring 上下文中的 <code>FilterChainProxy</code>，后者再将请求转给 <code>SecurityFilterChain</code>。顾名思义，过滤器链不是一个过滤器，而是一连串的过滤器，这些过滤器都是在 Spring 上下文中管理的。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00779.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-1　Spring Security 的请求处理流程</strong></p>\n<h2 id=\"nav_point_153\">10.2　身份认证</h2>\n<p>在对 Spring Security 有了一个大概的了解后，就该将其投入实践了，我们主要解决两个问题——我是谁以及我能干什么，分别对应身份认证与访问授权两大功能。接下来，就让我们从身份认证开始，来看看 Spring Security 是怎么帮助我们的吧。</p>\n<h3 id=\"nav_point_154\">10.2.1　Spring Security 的身份认证机制</h3>\n<p>在 Spring Security 中，有一个安全上下文的概念，用 <code>SecurityContext</code> 接口来表示，<code>SecurityContextHolder</code> 负责提供方法创建并维护当前的 <code>SecurityContext</code>。上下文中包含了当前用户的身份信息，用 <code>Authentication</code> 接口来表示，它又由下面的三部分信息组成。</p>\n<ul>\n<li><strong>用户主体信息</strong>，<code>Authentication</code> 直接继承了 <code>Principal</code> 接口，可以根据规范返回用户信息，<code>getPrincipal()</code> 方法返回任意的 <code>Object</code>，通常这里会使用 <code>UserDetails</code>。</li>\n<li><strong>证明信息</strong>，在用户名与密码做认证的场景下，证明信息通常就是密码，在身份认证通过后会清除该信息，避免信息泄露。</li>\n<li><strong>权限信息</strong>，由 <code>GrantedAuthority</code> 接口来表示，描述了当前用户是什么角色的，能做什么。</li>\n</ul>\n<p><code>Authentication</code> 里几乎已经包含了我们需要的所有信息，因此，整个过程中最重要的动作就是如何取得当前用户的 <code>Authentication</code>，并将其设置到 <code>SecurityContext</code> 里。<code>AuthenticationManager</code> 接口定义了 Spring Security 应该如何进行身份认证，<code>ProviderManager</code> 则是其最常用的实现，其中会有很多 <code>AuthenticationProvider</code> 来进行具体的身份验证判断，例如基于数据库做判断就用 <code>DaoAuthenticationProvider</code>。身份认证机制中一些主要接口与类的关系如图 10-2 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00780.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-2　身份认证机制中一些主要接口与类的关系</strong></p>\n<h3 id=\"nav_point_155\">10.2.2　基于用户名和密码的身份认证</h3>\n<p>在 Spring Boot 项目中，可以引入 spring-boot-starter-security 快速实现简单的身份认证功能，与此同时，框架也给我们留足了配置项和扩展点，能满足大部分的安全认证需求。</p>\n<ol>\n<li><p><strong>通过 Spring Boot 的自动配置实现身份认证</strong></p>\n<p>Spring Boot 提供的自动配置包含 HTTP 表单认证与 HTTP Basic 认证，在 pom.xml 中添加如下依赖：</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<p>启动程序后，在输出的日志中能看到类似下面这样的一段输出，这是 Spring Boot 的自动配置类 <code>SecurityProperties.User</code> 中用 UUID 生成的一段密码，对应的用户名默认是 <code>user</code>，用 UUID 做密码：</p>\n<pre class=\"code-rows\"><code>Using generated security password: 40e5d02a-de50-46d6-97a6-970252c35d57</code></pre>\n<p>在浏览器中，如果访问 http://localhost:8080/order 页面，会被 <code>302 Found</code> 重定向到 Spring Security 提供的默认登录页面；如果用 curl<span class=\"comment-number\">3</span> 命令，则会看到 <code>401 Unauthorized</code> 返回码：<span class=\"comment-number\">4</span></p>\n<pre class=\"code-rows\"><code>▸ curl -v http://localhost:8080/order\n\n&lt; HTTP/1.1 401\n&lt; Set-Cookie: JSESSIONID=3BB3C245CC937AF15B48DB2D1C07DE6F; Path=/; HttpOnly\n&lt; WWW-Authenticate: Basic realm=\"Realm\"\n&lt; X-Content-Type-Options: nosniff\n&lt; X-XSS-Protection: 1; mode=block\n&lt; Cache-Control: no-cache, no-store, max-age=0, must-revalidate\n&lt; Pragma: no-cache\n&lt; Expires: 0\n&lt; X-Frame-Options: DENY\n&lt; Content-Type: application/json\n&lt; Transfer-Encoding: chunked\n&lt; Date: Sun, 10 Jan 2021 13:48:50 GMT\n&lt;\n* Connection #0 to host localhost left intact\n{\"timestamp\":\"2021-01-10T13:48:50.763+00:00\",\"status\":401,\"error\":\"Unauthorized\",\"message\":\"\",\"path\":\n\"/order\"}* Closing connection 0</code></pre>\n<p>可以在登录页面中输入用户名进行登录，如果是 curl 命令则用下面的命令提供 HTTP Basic 认证所需的信息：</p>\n<pre class=\"code-rows\"><code>▸ curl -v -u user:40e5d02a-de50-46d6-97a6-970252c35d57 http://localhost:8080/order</code></pre>\n<p>如果每次都必须使用默认的用户名和自动生成的密码，那未免也太不方便了。既然是 <code>SecurityProperties</code> 里的属性，那必然可以通过配置来进行设置。可以在 <code>application.properties</code> 中配置下面的属性，将用户名和密码变成我们指定的内容：</p>\n<pre class=\"code-rows\"><code>spring.security.user.name=binarytea\nspring.security.user.password=showmethemoney</code></pre>\n<blockquote>\n<p><strong>茶歇时间：使用 Spring Security 加密保存密码</strong></p>\n<p>我们在项目中引入 Spring Security，就是为了增强项目的安全性，对密码的保护也是安全工作的一部分。由于密码泄露而造成的安全问题数不胜数，因而不建议直接用明文方式来保存密码。好在 Spring Security 提供了 <code>PasswordEncoder</code> 接口，我们可以用其 <code>encode()</code> 方法对明文进行编码，用 <code>matches()</code> 方法比较明文和编码后的内容。在创建 Spring Security 的 <code>User</code> 对象时，也能指定要使用的 <code>PasswordEncoder</code>，直接在设置密码时自动进行密码编码。</p>\n<p>在 5.0 版本前，默认的实现是 <code>NoOpPasswordEncoder</code>，对应的字符串前缀是 <code></code>。通过 <code>PasswordEncoderFactories.createDelegatingPasswordEncoder()</code> 可以创建一个包含大量算法的 <code>DelegatingPasswordEncoder</code> 实例，具体见表 10-3。</p>\n<p><strong>表 10-3　默认创建的 <code>DelegatingPasswordEncoder</code> 所代理的 <code>PasswordEncoder</code></strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>前缀</th><th>对应的 <code>PasswordEncoder</code> 实现</th></tr><tr><td><code></code></td><td><code>NoOpPasswordEncoder</code></td></tr><tr><td><code></code></td><td><code>BCryptPasswordEncoder</code></td></tr><tr><td><code></code></td><td><code>Pbkdf2PasswordEncoder</code></td></tr><tr><td><code></code></td><td><code>SCryptPasswordEncoder</code></td></tr><tr><td><code></code></td><td><code>MessageDigestPasswordEncoder</code></td></tr><tr><td><code></code></td><td><code>MessageDigestPasswordEncoder</code></td></tr><tr><td><code></code></td><td><code>StandardPasswordEncoder</code></td></tr><tr><td><code></code></td><td><code>MessageDigestPasswordEncoder</code></td></tr><tr><td><code></code></td><td><code>MessageDigestPasswordEncoder</code></td></tr><tr><td><code></code></td><td><code>LdapShaPasswordEncoder</code></td></tr><tr><td><code></code></td><td><code>Argon2PasswordEncoder</code></td></tr></table>\n\n<p>如果我们希望配置已编码的密码，可以通过代码事先加密，也可以简单一些，使用 Spring Boot 的 CLI 命令行工具 <span class=\"comment-number\">5</span>：</p>\n<pre class=\"code-rows\"><code>▸ spring encodepassword plaintext\n$2a$10$GUextEAokHFRL7vWGk6sqOE8RKyiXD1tnPLJxpqlvBfur4BXzvOSG</code></pre>\n<p>也可以用 <code>-a</code> 指定算法：</p>\n<pre class=\"code-rows\"><code>▸ spring encodepassword -a pbkdf2 plaintext\na40a2a9e11f7a85db0c2c3b508d096138fb38c4ae8fb7e6452f821fdd309496d9c4810b6e984614c</code></pre>\n</blockquote>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>自定义身份认证细节</strong></p>\n<p>通过前面的自动配置，我们已经实现了基本的身份认证需求，在访问大部分页面和接口前（除了登录和退出页），都必须先登录。但自动配置不是万能的，总会有些地方需要我们做个性化定制，例如，我们希望有些 URL 能禁用强制登录。</p>\n<p>可以在代码中编写一个继承了 <code>WebSecurityConfigurerAdapter</code> 类的配置类，同时在上面增加 <code>@EnableWebSecurity</code> 注解。代码示例 10-1 就将 /menu 路径彻底放开了，允许所有人来访问。<span class=\"comment-number\">6</span></p>\n<blockquote>\n<p><strong>代码示例 10-1</strong>　个性化的身份认证配置</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfiguration extends WebSecurityConfigurerAdapter {\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.authorizeRequests()\n            .antMatchers(\"/menu\").permitAll()\n            .anyRequest().authenticated().and()\n            .formLogin().and() // 使用表单登录\n            .httpBasic(); // 使用HTTP Basic认证\n    }\n}</code></pre>\n<p>如果只希望提供 HTTP Basic 的方式，可以将上面代码中的 <code>formLogin()</code> 调用去掉。其实，在遇到未登录的情况时，究竟采用何种方式应对，提供什么入口，是由 <code>AuthenticationEntryPoint</code> 接口来决定的。例如，<code>LoginUrlAuthenticationEntryPoint</code> 就会将浏览器重定向到登录页 URL；而 <code>BasicAuthenticationEntryPoint</code> 则会返回 <code>401 Unauthorized</code> 响应码，添加 <code>WWW-Authenticate</code> 头，使用 HTTP Basic 认证方式。</p>\n<p>在使用登录表单认证时，我们之前看到的 <code>/login</code> 页面是 Spring Security 提供的默认登录页，这个页面是通过 <code>DefaultLoginPageGeneratingFilter</code> 来生成的。如果查看它的源码，你会发现这个页面基本就是靠字符串拼接出来的。不过，就算这么一个页面，Spring Security 也给我们留足了配置项，一些常用的配置如表 10-4 所示。</p>\n<p><strong>表 10-4　<code>formLogin()</code> 提供的一些常用配置</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>配置方法</th><th>作用</th></tr><tr><td><code>usernameParameter()</code></td><td>配置表单中的用户名字段</td></tr><tr><td><code>passwordParameter()</code></td><td>配置表单中的密码字段</td></tr><tr><td><code>defaultSuccessUrl()</code></td><td>登录成功后跳转的 URL</td></tr><tr><td><code>failureUrl()</code></td><td>登录失败后跳转的 URL</td></tr><tr><td><code>loginProcessingUrl()</code></td><td>提交用户名和密码到此处指定的 URL 进行身份认证</td></tr><tr><td><code>loginPage()</code></td><td>指定自己的登录页，如果设置了这个配置，就不会再有默认的登录页了</td></tr></table>\n\n<p>代码示例 10-2 是自定义登录页面配置的一个演示，设置了登录成功与失败的 URL，定制了表单中的用户名和密码字段，还修改了处理登录请求的 URL。<span class=\"comment-number\">7</span> 在设置放行 URL 时，这里分别演示了使用 ANT 匹配器和 MVC 匹配器的方法。</p>\n<blockquote>\n<p><strong>代码示例 10-2</strong>　自定义登录表单</p>\n</blockquote>\n<pre class=\"code-rows\"><code>protected void configure(HttpSecurity http) throws Exception {\n    http.authorizeRequests()\n        .antMatchers(\"/\").permitAll()\n        .mvcMatchers(\"/actuator/*\").permitAll()\n        .anyRequest().authenticated().and()\n        .formLogin() // 使用表单登录\n        .defaultSuccessUrl(\"/order\")\n        .failureUrl(\"/login\")\n        .loginProcessingUrl(\"/doLogin\")\n        .usernameParameter(\"user\")\n        .passwordParameter(\"pwd\").and()\n        .httpBasic(); // 使用HTTP Basic认证\n}</code></pre>\n<p>Spring Security 的用户名和密码登录，默认是由 <code>UsernamePasswordAuthenticationFilter</code> 来实现的，其中最主要的工作就是取得用户名和密码，然后通过 <code>AuthenticationManager</code> 来实施具体的身份认证动作，<code>UsernamePasswordAuthenticationFilter</code> 中大概的处理逻辑如下所示：</p>\n<pre class=\"code-rows\"><code>public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {\n    // 1.POST校验\n    // 2.获得用户名与密码操作\n    // 3.生成AuthenticationToken\n    UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password);\n    setDetails(request, authRequest);\n    // 4.通过AuthenticationManager进行认证\n    return this.getAuthenticationManager().authenticate(authRequest);\n}</code></pre>\n<p>如果认证成功，需要“记住我”<span class=\"comment-number\">8</span> 的就做对应记住的动作，随后使用 <code>AuthenticationEventPublisher</code> 发送认证成功的事件，再调用 <code>AuthenticationSuccessHandler</code> 做登录成功后的处理。如果登录失败，清除之前保留的登录信息，调用 <code>AuthenticationFailureHandler</code> 做登录失败后的处理。</p>\n<p>在了解了定制身份认证细节的方法之后，让我们来看看如何将其运用到二进制奶茶店中，为系统提供更多的防护能力。</p>\n<blockquote>\n<p><strong>需求描述</strong>　为二进制奶茶店提供一个登录界面。奶茶店的根页面（<code>/</code>）谁都可以访问，但如果顾客到店希望点单，就只能通过店员进行操作。所以下单页面（<code>/order</code>）只能是店员登录后才能访问。</p>\n</blockquote>\n<p>在实际生产环境中，我们很少直接使用 Spring Security 的默认登录页面，通常会自己写一个页面。在通过 <code>loginPage()</code> 设置了自己的登录页 URL 后，Spring Security 就不会再为我们提供默认页面了，我们要自己负责处理对这个 URL 的请求。在代码示例 10-3 中，我们定义了自己的 <code>/login</code> 页面模板，使用的是第 10 章中用过的 Thymeleaf 模板。<span class=\"comment-number\">9</span></p>\n<blockquote>\n<p><strong>代码示例 10-3</strong>　自定义的登录页面模板</p>\n</blockquote>\n<pre class=\"code-rows\"><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"zh_CN\" xmlns:th=\"http://www.thymeleaf.org\"&gt;\n    &lt;head&gt;\n        &lt;meta charset=\"UTF-8\"&gt;\n        &lt;title&gt;二进制奶茶&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;二进制奶茶&lt;/h1&gt;\n        &lt;h2&gt;请登录&lt;/h2&gt;\n        &lt;div&gt;\n            &lt;form action=\"#\" th:action=\"@{/doLogin}\" method=\"post\"&gt;\n                &lt;p&gt;\n                    &lt;label&gt;用户名：&lt;/label&gt;\n                    &lt;input type=\"text\" name=\"user\" placeholder=\"用户名\" /&gt;\n                &lt;/p&gt;\n                &lt;p&gt;\n                    &lt;label&gt;密码：&lt;/label&gt;\n                    &lt;input type=\"password\" name=\"pwd\" placeholder=\"密码\" /&gt;\n                &lt;/p&gt;\n                &lt;p th:if=\"$\"\n                   th:with=\"errorMsg=$\"\n                   style=\"color:#ff0000\"&gt;\n                    登录失败，具体原因：\n                    &lt;span th:text=\"$\" style=\"color:#ff0000\"&gt;失败原因&lt;/span&gt;\n                &lt;/p&gt;\n                &lt;p&gt;\n                    &lt;input type=\"submit\" value=\"提交\"/&gt;\n                &lt;/p&gt;\n            &lt;/form&gt;\n        &lt;/div&gt;\n    &lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p>这里有几点内容需要说明：</p>\n<ul>\n<li>表单提交的目标需要与 <code>formLogin().loginProcessingUrl()</code> 中设置的地址匹配，默认是 <code>/login</code>；</li>\n<li>用户名与密码表单项的名称需要与 <code>formLogin().usernameParameter()</code> 和 <code>formLogin().passwordParameter()</code> 匹配，默认是 <code>username</code> 和 <code>password</code>；</li>\n<li>如果登录失败，Spring Security 会将异常放在 Session 的 <code>SPRING_SECURITY_LAST_EXCEPTION</code> 属性中（用户名密码错误是 <code>BadCredentialsException</code>），因此可以通过它是否为空来判断，<code>message</code> 中会有具体的失败原因描述；</li>\n<li>Thymeleaf 会自动为我们的表单带上一个 CSRF Token，关于 CSRF 的内容会在 10.3 节中展开说明。</li>\n</ul>\n<p>为了使用这个登录页，我们的配置也要稍作调整。由于 <code>/login</code> 在显示时并没有什么逻辑，可以直接用 <code>UrlFilenameViewController</code> 来充当控制器类，它能根据请求映射模板，Bean 的 ID 就是要映射的 URL。<code>formLogin().loginPage(\"/login\").permitAll()</code> 设置了要使用自定义登录页，我们还改了一些参数，具体内容见代码示例 10-4。</p>\n<blockquote>\n<p><strong>代码示例 10-4</strong>　使用自定义登录页的配置类</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfiguration extends WebSecurityConfigurerAdapter {\n    @Bean(\"/login\")\n    public UrlFilenameViewController loginController() {\n        UrlFilenameViewController controller = new UrlFilenameViewController();\n        controller.setSupportedMethods(HttpMethod.GET.name());\n        controller.setSuffix(\".html\");\n        return controller;\n    }\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.authorizeRequests()\n            .antMatchers(\"/\").permitAll()\n            .mvcMatchers(\"/actuator/*\").permitAll()\n            .anyRequest().authenticated().and()\n            .formLogin() // 使用表单登录\n            .loginPage(\"/login\").permitAll() // 设置登录页地址，全员可访问\n            .defaultSuccessUrl(\"/order\")\n            .failureUrl(\"/login\")\n            .loginProcessingUrl(\"/doLogin\")\n            .usernameParameter(\"user\")\n            .passwordParameter(\"pwd\").and()\n            .httpBasic(); // 使用HTTP Basic认证\n    }\n}</code></pre>\n<p>我们的登录页效果如图 10-3 所示。相比默认的页面，它的确是简单了一些。在实际生产系统中，页面通常都会加上 CSS 效果，不会这么简陋。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00781.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-3　自定义登录页</strong></p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>基于数据库管理用户信息</strong></p>\n<p>如果仅仅依靠配置文件配置的用户信息，是无法应对生产环境的复杂性的。我们对用户体系有着更高的要求，最起码也得实现不同用户能够使用不同账户进行登录，每个人都可以有不同的权限。这时将用户信息记录到数据库中的需求就出现了，而且数据库中的信息相比配置文件更易维护。</p>\n<p>Spring Security 中的 <code>UserDetailsService</code> 提供了用户信息服务的抽象，该接口就只有一个 <code>loadUserByUsername()</code> 方法，根据用户名加载用户信息。另外的 <code>UserDetailsManager</code> 则提供了用户信息的增加、删除和修改方法。两个接口搭配在一起就能完成关于用户的增删改查操作。</p>\n<blockquote>\n<p><strong>需求描述</strong>　随着日益增长的业务需要，奶茶店聘请了好几位员工。只有一个账号的情况肯定是不合适了，现在需要为每个员工分配一个账号，并且账号系统要易于维护。</p>\n</blockquote>\n<p>在使用关系型数据库之前，我们先来看看如何在内存中保存不同用户的信息，这时会用到 <code>InMemoryUserDetailsManager</code>。在没有提供 <code>UserDetailsService</code> 时，Spring Boot 的自动配置类 <code>UserDetailsServiceAutoConfiguration</code> 会自动为我们提供一个 <code>InMemoryUserDetailsManager</code>，所以我们只需自己定义一个就可以了，就像代码示例 10-5 这样。<span class=\"comment-number\">10</span></p>\n<blockquote>\n<p><strong>代码示例 10-5</strong>　增加了 <code>InMemoryUserDetailsManager</code> 的配置类</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfiguration extends WebSecurityConfigurerAdapter {\n    @Bean\n    public UserDetailsService userDetailsService(ObjectProvider&lt;PasswordEncoder&gt; passwordEncoder) {\n        PasswordEncoder encoder = passwordEncoder\n                .getIfAvailable(() -&gt; PasswordEncoderFactories.createDelegatingPasswordEncoder());\n        UserDetails employee = User.builder()\n                                      .username(\"lilei\")\n                                      .password(\"binarytea\")\n                                      .authorities(\"READ_ORDER\", \"WRITE_ORDER\")\n                                      .passwordEncoder(encoder::encode)\n                                      .build();\n        return new InMemoryUserDetailsManager(employee);\n    }\n    // 省略其他代码\n}</code></pre>\n<p>在上面的代码中，我们先尝试从 Spring 上下文中获取 <code>PasswordEncoder</code>，如果没有找到则创建一个默认的。通过 <code>User.UserBuilder</code> 来构建用户信息，用户名、密码和权限是必需的。此外，我们这里指定了 <code>PasswordEncoder</code> 来加密存储密码，随后用这个用户来初始化 <code>InMemoryUserDetailsManager</code>。<code>InMemoryUserDetailsManager</code> 中可以管理多个用户，我们的例子就只放了一个而已。</p>\n<p><code>InMemoryUserDetailsManager</code> 通常用在简单的场景或者测试中。在复杂的生产环境中，我们更倾向于使用 <code>JdbcUserDetailsManager</code>，它能够通过 JDBC 与关系型数据库进行交互，满足更多的要求。</p>\n<p>既然是要用数据库的，那必然就少不了要创建对应的表结构，Spring Security 在 Jar 包中提供了默认的表结构 DDL 文件（位置是 org/springframework/security/core/userdetails/jdbc/users.ddl），不过它并不要求我们严格遵守这个 DDL 文件中的定义。在之前的示例中，我们已经用了 H2 内嵌数据库，有 schema.sql 文件，所以我们可以把自己的用户和权限表定义加在后面，具体的 SQL 如代码示例 10-6 所示。<span class=\"comment-number\">11</span></p>\n<blockquote>\n<p><strong>代码示例 10-6</strong>　追加在 schema.sql 后面的用户和权限表语句</p>\n</blockquote>\n<pre class=\"code-rows\"><code>drop table if exists users;\ndrop table if exists authorities;\n\ncreate table users(\n    username varchar(50) not null primary key,\n    password varchar(500) not null,\n    enabled boolean not null\n);\n\ncreate table authorities (\n    username varchar(50) not null,\n    authority varchar(50) not null\n);\n\ncreate unique index ix_auth_username on authorities (username, authority);</code></pre>\n<p>上面的 SQL 是根据默认 DDL 修改的，去掉了外键，原先的字符串忽略大小写，这里我们还是选择区别大小写。随后在 data.sql 中插入一条默认数据，密码用 <code>spring encodepassword binarytea</code> 做了加密，如代码示例 10-7 所示。</p>\n<blockquote>\n<p><strong>代码示例 10-7</strong>　预先插入的默认数据</p>\n</blockquote>\n<pre class=\"code-rows\"><code>insert into users (username, password, enabled) values ('LiLei',\n        '$2a$10$iAty2GrJu9WfpksIen6qX.vczLmXlp.1q1OHBxWEX8BIldtwxHl3u', true);\ninsert into authorities (username, authority) values ('LiLei', 'READ_ORDER');\ninsert into authorities (username, authority) values ('LiLei', 'WRITE_ORDER');</code></pre>\n<p>最后，如代码示例 10-8 那样修改一下配置类，把 <code>UserDetailsService</code> 的 Bean 换成 <code>JdbcUserDetailsManager</code>，这里我们还演示了一下如何用代码创建一个用户，放入 <code>JdbcUserDetailsManager</code>。</p>\n<blockquote>\n<p><strong>代码示例 10-8</strong>　使用 <code>JdbcUserDetailsManager</code> 来提供用户信息</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfiguration extends WebSecurityConfigurerAdapter {\n    @Bean\n    public UserDetailsService userDetailsService(ObjectProvider&lt;DataSource&gt; dataSources) {\n        JdbcUserDetailsManager userDetailsManager = new JdbcUserDetailsManager();\n        userDetailsManager.setDataSource(dataSources.getIfAvailable());\n        UserDetails manager = User.builder().username(\"HanMeimei\").password(\"$2a$10$iAty2GrJu9Wf\n            pksIen6qX.vczLmXlp.1q1OHBxWEX8BIldtwxHl3u\").authorities(\"READ_ORDER\", \"WRITE_ORDER\").build();\n        userDetailsManager.createUser(manager);\n    return userDetailsManager;\n    }\n    // 省略其他代码\n}</code></pre>\n<p>如果详细查看 <code>JdbcUserDetailsManager</code> 的代码，我们会发现，它内部其实内置了很多不同操作所需的 SQL 语句：</p>\n<pre class=\"code-rows\"><code>    public static final String DEF_CREATE_USER_SQL = \"insert into users (username, password, enabled)\n        values (?,?,?)\";\n    public static final String DEF_DELETE_USER_SQL = \"delete from users where username = ?\";\n    public static final String DEF_UPDATE_USER_SQL = \"update users set password = ?, enabled = ? where username = ?\";\n    public static final String DEF_INSERT_AUTHORITY_SQL = \"insert into authorities (username, authority)\n        values (?,?)\";\n    public static final String DEF_DELETE_USER_AUTHORITIES_SQL = \"delete from authorities where username = ?\";\n    public static final String DEF_USER_EXISTS_SQL = \"select username from users where username = ?\";\n    public static final String DEF_CHANGE_PASSWORD_SQL = \"update users set password = ? where username = ?\";</code></pre>\n<p>如果我们修改了表名或者表结构，不用完全重写这个实现类，只需通过对应的方法把增删改查相关的 SQL 语句改了就可以。此外，<code>JdbcUserDetailsManager</code> 还支持用户组相关的概念和操作，实现方式也是在数据库中增加了用户组的表，并内置了相关 SQL 语句，这部分内容就不在本书中展开了。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>退出操作</strong></p>\n<p>既然有登录操作，那自然也有对应的退出操作。<code>WebSecurityConfigurerAdapter</code> 默认提供了 <code>/logout</code> 这个 URL 来处理退出的请求，它主要做了如下清理动作：</p>\n<ul>\n<li>清理 HTTP Session；</li>\n<li>清理“记住我”相关的信息；</li>\n<li>清理保存了当前用户信息的 <code>SecurityContextHolder</code>；</li>\n<li>重定向到 <code>/login?logout</code>。</li>\n</ul>\n<p>和 <code>formLogin()</code> 类似，<code>logout()</code> 也有很多可以定制的配置方法，表 10-5 提供了一些常用的配置方法。</p>\n<p><strong>表 10-5　<code>logout()</code> 提供的一些常用配置方法</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>配置方法</th><th>作用</th></tr><tr><td><code>logoutUrl()</code></td><td>触发退出操作的 URL，默认是 <code>/logout</code></td></tr><tr><td><code>logoutSuccessUrl()</code></td><td>成功退出后跳转的 URL</td></tr><tr><td><code>logoutSuccessHandler()</code></td><td>指定自定义的 <code>LogoutSuccessHandler</code>，有这个设置 <code>logoutSuccessUrl()</code> 会失效</td></tr><tr><td><code>invalidateHttpSession()</code></td><td>是否清理 HTTP Session</td></tr><tr><td><code>deleteCookies()</code></td><td>是否删除 Cookies</td></tr><tr><td><code>addLogoutHandler()</code></td><td>添加 <code>LogoutHandler</code>，Spring Security 有好多该接口的实现，默认 <code>SecurityContextLogoutHandler</code> 会加在最后</td></tr><tr><td><code>logoutRequestMatcher()</code></td><td>设置退出请求的匹配规则</td></tr></table>\n\n<p>Spring Security 中默认开启了 CSRF 防护，所以 <code>/logout</code> 也要求带有 CSRF 的 Token，而且必须要使用 <code>POST</code> 方法，这是合理的安全要求。可以通过提交表单的方式来实现退出，也可以用 JavaScript 代码来发起退出的 <code>POST</code> 请求。如果一定要用 <code>GET</code> 方法，可以像代码示例 10-9 这样进行设置，其中将退出成功后的重定向指向了 <code>/</code>，退出请求可以同时使用 <code>GET</code> 和 <code>POST</code> 方法。</p>\n<blockquote>\n<p><strong>代码示例 10-9</strong>　增加了退出设置的安全配置类</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfiguration extends WebSecurityConfigurerAdapter {\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.authorizeRequests()\n            .antMatchers(\"/\").permitAll()\n            .mvcMatchers(\"/actuator/*\").permitAll()\n            .anyRequest().authenticated().and()\n            .formLogin() // 使用表单登录\n            .loginPage(\"/login\").permitAll() // 设置登录页地址，全员可访问\n            .defaultSuccessUrl(\"/order\")\n            .failureUrl(\"/login\")\n            .loginProcessingUrl(\"/doLogin\")\n            .usernameParameter(\"user\")\n            .passwordParameter(\"pwd\").and()\n            .httpBasic().and() // 使用HTTP Basic认证\n            .logout()\n            .logoutSuccessUrl(\"/\")\n            .logoutRequestMatcher(new OrRequestMatcher(\n                new AntPathRequestMatcher(\"/logout\", \"GET\"),\n                new AntPathRequestMatcher(\"/logout\", \"POST\")));\n    }\n    // 省略其他代码\n}</code></pre>\n<p>现在，我们的下单页面已经拥有了最基本的登录和退出功能，也能在数据库中维护基本的用户信息了。之前都是通过浏览器手动做的验证，为了方便以后回归测试，我们需要编写一些自动化的单元测试。好在 Spring Security 对测试也有很好的支持，我们只需要在 pom.xml 中引入相应的依赖就行了，具体如代码示例 10-10 所示。</p>\n<blockquote>\n<p><strong>代码示例 10-10</strong>　pom.xml 中增加 Spring Security 的测试支持</p>\n</blockquote>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;</code></pre>\n<p>接下来，为 <code>OrderController</code> 编写一些测试用例。在为测试构建 <code>MockMvc</code> 时，需要增加 Spring Security 相关的支持，具体如代码示例 10-11 所示，其中用到了 <code>SecurityMockMvcConfigurers.springSecurity()</code> 来初始化 <code>MockMvc</code>。</p>\n<blockquote>\n<p><strong>代码示例 10-11</strong>　<code>OrderControllerTest</code> 的初始化</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootTest\nclass OrderControllerTest {\n    private MockMvc mockMvc;\n\n    @BeforeEach\n    void setUp(WebApplicationContext wac) {\n        this.mockMvc = MockMvcBuilders.webAppContextSetup(wac)\n                                         .apply(springSecurity())\n                                         .build();\n    }\n\n    @AfterEach\n    void tearDown() {\n        mockMvc = null;\n    }\n    // 省略其他代码\n}</code></pre>\n<p>先来测试一下登录和退出的功能，在代码示例 10-12 中，通过 <code>SecurityMockMvcRequestBuilders.formLogin()</code> 可以发起表单登录请求，我们在 <code>WebSecurityConfiguration</code> 中修改了默认配置，因此这里也需要手动指定处理登录请求的 URL，用户名和密码的表单项名称也要修改。登录后，可以通过 <code>SecurityMockMvcResultMatchers.authenticated()</code> 和 <code>unauthenticated()</code> 方法来判断当前是否通过身份验证，如果成功通过验证则继续确认重定向 URL 是否符合预期。退出的测试逻辑也是类似的，通过 <code>logout()</code> 向默认的 <code>/logout</code> 地址发起退出请求，随后判断是否已没有登录态并重定向到了 <code>/</code>。</p>\n<blockquote>\n<p><strong>代码示例 10-12</strong>　登录和退出的测试用例</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootTest\nclass OrderControllerTest {\n    @Test\n    void testLogin() throws Exception {\n        mockMvc.perform(formLogin(\"/doLogin\")\n                .user(\"user\", \"LiLei\")\n                .password(\"pwd\", \"binarytea\"))\n                .andExpect(authenticated())\n                .andExpect(redirectedUrl(\"/order\"));\n    }\n\n    @Test\n    void testLogout() throws Exception {\n        mockMvc.perform(logout())\n                .andExpect(unauthenticated())\n                .andExpect(redirectedUrl(\"/\"));\n    }\n    // 省略其他代码\n}</code></pre>\n<p>最后，再来测试一下登录和未登录情况下的 <code>/order</code> 页面请求。在未登录的情况下向 <code>/order</code> 发起 <code>GET</code> 请求，会返回 <code>401 Unauthorized</code> 响应码，此时的状态是未经过身份认证，就和用 curl 命令发起 <code>GET</code> 请求时类似。如果指定了 <code>Accept: text/html</code> 头，则情况与浏览器类似，会重定向到登录页面。在发起请求时，如果用 <code>with()</code> 方法带上登录信息，就能模拟带登录态的请求，可以直接带上 <code>user()</code>，指定用户信息（这里只带了用户名，也可以带密码和角色），也可以用 <code>httpBasic()</code> 模拟 HTTP Basic 认证。具体如代码示例 10-13 所示。</p>\n<blockquote>\n<p><strong>代码示例 10-13</strong>　对下单页面的单元测试</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootTest\nclass OrderControllerTest {\n    @Test\n    void testOrderPageWithoutAuthentication() throws Exception {\n        mockMvc.perform(get(\"/order\")\n                         // .header(\"Accept\", \"text/html\") // 模拟浏览器\n                     )\n                .andExpect(unauthenticated())\n                // .andExpect(status().is3xxRedirection()) // 浏览器里是跳转，否则是401走HTTP Basic\n                // .andExpect(redirectedUrlPattern(\"**/login\"))\n          ;\n    }\n\n    @Test\n    void testOrderPageWithAuthenticatedUser() throws Exception {\n        mockMvc.perform(get(\"/order\").with(user(\"LiLei\")))\n                .andExpect(status().is2xxSuccessful());\n        mockMvc.perform(get(\"/order\").with(httpBasic(\"LiLei\", \"binarytea\")))\n                .andExpect(status().is2xxSuccessful());\n    }\n    // 省略其他代码\n}</code></pre>\n<p>通过上面的例子，可以发现在 Spring MVC 中对控制器进行测试也不是特别复杂，即使加上了 Spring Security，难度也不高。在本书中，伴随着各种知识点已经出现了不少单元测试代码，希望大家都能养成为代码编写测试的习惯。</p>\n</li>\n</ol>\n\n\n\n\n\n\n\n\n\n<h3 id=\"nav_point_156\">10.2.3　实现“记住我”功能</h3>\n<p>一般在对安全要求不太严格的场景中，经常会出现“记住我”（Remember me）的选项，即首次成功登录后，对于同一台电脑，用户可以在一段相对较长的时间里无须再次手动输入用户名和密码即可进行登录。这个功能让用户无须重复登录，在一定程度上提升了使用体验。但是，必须强调，如果是在金融、国防等敏感场景下，不建议使用这个功能，至少不能保留太长时间。</p>\n<p>Spring Security 里为我们提供了一个 <code>RememberMeServices</code> 抽象，由它来实现“记住我”功能，默认有几个实现：</p>\n<ul>\n<li><code>NullRememberMeServices</code>，空实现，即不提供“记住我”功能，<code>UsernamePasswordAuthenticationFilter</code> 内部默认使用了这个实现；</li>\n<li><code>TokenBasedRememberMeServices</code>，通过 Cookie 中的一段经 BASE64 编码的令牌来实现“记住我”功能，实现较为简单；</li>\n<li><code>PersistentTokenBasedRememberMeServices</code>，通过持久化的令牌来实现“记住我”功能，这里的持久化可以是在内存里的（这严格上不算真正的持久化），也可以是持久化到数据库里的。</li>\n</ul>\n<p><code>TokenBasedRememberMeServices</code> 和 <code>PersistentTokenBasedRememberMeServices</code> 都是基于令牌来实现的，但两者的令牌生成策略不同。我们先来看看 <code>TokenBasedRememberMeServices</code> 生成令牌时使用的策略。令牌是一串字符串的 BASE64 编码，字符串中包含如下几部分：</p>\n<ul>\n<li>用户名，用来查找对应的密码；</li>\n<li>失效时间，用来表示这个令牌何时过期，单位毫秒；</li>\n<li>用户名、失效时间、密码与特定的私钥组合到一起的 MD5。</li>\n</ul>\n<p>官方文档中的表示方法如下：</p>\n<pre class=\"code-rows\"><code>base64(用户名 + \":\" + 失效时间 + \":\" + md5Hex(用户名 + \":\" + 失效时间 + \":\" + 密码 + \":\" + 私钥))</code></pre>\n<p>使用这样的组合，只要有令牌，就能还原出用户信息，因此无须在服务端存储令牌与用户的关联信息，而且 Cookie 中只会存储明文的用户名 <span class=\"comment-number\">12</span>，在到期或者用户修改了密码之后令牌都会失效。</p>\n\n<p><code>PersistentTokenBasedRememberMeServices</code> 的策略就不同了，它是随机生成一个令牌，在后端的持久化存储中记录下令牌与用户的关系、令牌的失效时间，每次来一个令牌，都要查询一下。</p>\n<p>与之前的表单登录和退出配置方法相似，“记住我”在 <code>rememberme()</code> 方法里也提供了不少配置方法，可以设置一系列的参数，表 10-6 中就列出了一些常用的配置方法。</p>\n<p><strong>表 10-6　<code>rememberMe()</code> 中常用的配置方法</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>配置方法</th><th>作用</th></tr><tr><td><code>key()</code></td><td>设置 <code>md5Hex()</code> 时使用的私钥</td></tr><tr><td><code>rememberMeParameter()</code></td><td>请求中表示是否要“记住我”的参数名，默认是 <code>remember-me</code></td></tr><tr><td><code>rememberMeCookieName()</code></td><td>在 Cookies 中保存令牌的 Cookie 名称，默认是 <code>remember-me</code></td></tr><tr><td><code>tokenValiditySeconds()</code></td><td>令牌的有效时间，默认两周</td></tr><tr><td><code>userDetailsService()</code></td><td>设置用来根据用户名获取用户信息的 <code>UserDetailsService</code></td></tr><tr><td><code>alwaysRemember()</code></td><td>是否始终开启“记住我”功能</td></tr><tr><td><code>tokenRepository()</code></td><td>设置用于保存持久化令牌的 <code>PersistentTokenRepository</code>，设置了这个后，就会使用 <code>PersistentTokenBasedRememberMeServices</code>，否则是 <code>TokenBasedRememberMeServices</code></td></tr></table>\n\n<p>接下来，我们一起来看看如何在二进制奶茶店中实现“记住我”的功能，以便大家更方便地将其应用于日常开发中。</p>\n<blockquote>\n<p><strong>需求描述</strong>　每次使用二进制奶茶店的 Web 页面都需要登录，未免有些麻烦。如果成功登录一次，店员这一天都无须再次输入用户名和密码就能以当前的用户身份一直做下单或其他的操作就好了。</p>\n</blockquote>\n<p>我们可以考虑在 BinaryTea 工程中演示如何开启“记住我”功能。我们先来稍微调整一下 Spring Security 的配置，像代码示例 10-14 这样 <span class=\"comment-number\">13</span>——其中设置了我们的私钥，即 <code>binarytea</code>；登录表单中表示是否要“记住我”的参数是 <code>remember</code>；令牌有效期修改为一天，还注入了上下文里的 <code>userDetailsService</code>。</p>\n\n<blockquote>\n<p><strong>代码示例 10-14</strong>　在 <code>WebSecurityConfiguration</code> 中增加 <code>rememberMe()</code> 配置</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfiguration extends WebSecurityConfigurerAdapter {\n    @Autowired\n    private UserDetailsService userDetailsService;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http// 省略其他配置内容\n            .rememberMe()\n            .key(\"binarytea\")\n            .rememberMeParameter(\"remember\")\n            .tokenValiditySeconds(24 * 60 * 60)\n            .userDetailsService(userDetailsService).and()\n            .logout()\n            .logoutSuccessUrl(\"/\")\n            .logoutRequestMatcher(new OrRequestMatcher(\n                new AntPathRequestMatcher(\"/logout\", \"GET\"),\n                new AntPathRequestMatcher(\"/logout\", \"POST\")));\n    }\n    // 省略其他代码\n}</code></pre>\n<p>在登录页面 login.html 中，我们也要相应地在表单里增加 <code>remember</code> 这个表单项，一般是复选框，就像代码示例 10-15 里的那样。</p>\n<blockquote>\n<p><strong>代码示例 10-15</strong>　login.html 中的表单部分</p>\n</blockquote>\n<pre class=\"code-rows\"><code>&lt;form action=\"#\" th:action=\"@{/doLogin}\" method=\"post\"&gt;\n    &lt;p&gt;\n        &lt;label&gt;用户名：&lt;/label&gt;\n        &lt;input type=\"text\" name=\"user\" placeholder=\"用户名\" /&gt;\n    &lt;/p&gt;\n    &lt;p&gt;\n        &lt;label&gt;密码：&lt;/label&gt;\n        &lt;input type=\"password\" name=\"pwd\" placeholder=\"密码\" /&gt;\n    &lt;/p&gt;\n    &lt;p&gt;\n        &lt;label&gt;记住我：&lt;/label&gt;\n        &lt;input type=\"checkbox\" name=\"remember\" /&gt;是\n    &lt;/p&gt;\n    &lt;p th:if=\"$\"\n       th:with=\"errorMsg=$\"\n       style=\"color:#ff0000\"&gt;\n        登录失败，具体原因：\n        &lt;span th:text=\"$\" style=\"color:#ff0000\"&gt;失败原因&lt;/span&gt;\n    &lt;/p&gt;\n    &lt;p&gt;\n        &lt;input type=\"submit\" value=\"提交\"/&gt;\n    &lt;/p&gt;\n&lt;/form&gt;</code></pre>\n<p>运行程序，成功登录后，我们可以通过 Chrome 浏览器的开发者工具观察一下响应中的 Cookies，这里就能找到用于实现“记住我”功能的 <code>remember-me</code>，如图 10-4 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00782.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-4　Cookies 中“记住我”的令牌值</strong></p>\n<p>如果要使用 Spring Security 内置的持久化令牌，我们需要配置一个 <code>PersistentTokenRepository</code> Bean，Spring Security 内置的还有测试用的 <code>InMemoryTokenRepositoryImpl</code> 内存令牌，还有代码示例 10-16 中使用的 <code>JdbcTokenRepositoryImpl</code>。代码示例 10-16 通过 <code>tokenRepository()</code> 设置了 <code>persistentTokenRepository()</code> 创建的 <code>JdbcTokenRepositoryImpl</code>。<code>JdbcTokenRepositoryImpl</code> 在初始化时可以自己建表，但由于这个动作不会判断表是否已经存在，所以每次初始化都会尝试建表。对于生产环境，本书不建议自动建表。默认的令牌表结构是下面这样的，可以把它加到 schema.sql 中：</p>\n<pre class=\"code-rows\"><code>create table persistent_logins (\n    username varchar(64) not null,\n    series varchar(64) primary key,\n    token varchar(64) not null,\n    last_used timestamp not null\n);</code></pre>\n<p>如果想要用自己的表，或者用 Redis 来保存令牌，只需自己实现一个 <code>PersistentTokenRepository</code> 就可以了。</p>\n<blockquote>\n<p><strong>代码示例 10-16</strong>　增加了持久化令牌的相关配置</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfiguration extends WebSecurityConfigurerAdapter {\n    @Autowired\n    private ObjectProvider&lt;DataSource&gt; dataSources;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n            // 省略其他配置内容\n                .rememberMe()\n                .key(\"binarytea\")\n                .rememberMeParameter(\"remember\")\n                .tokenValiditySeconds(24 * 60 * 60)\n                .tokenRepository(persistentTokenRepository(dataSources)) // 配置持久化令牌\n                .userDetailsService(userDetailsService(dataSources)).and()\n                .logout()\n            .logoutSuccessUrl(\"/\")\n            .logoutRequestMatcher(new OrRequestMatcher(\n                new AntPathRequestMatcher(\"/logout\", \"GET\"),\n                new AntPathRequestMatcher(\"/logout\", \"POST\")));\n    }\n\n    @Bean\n    public PersistentTokenRepository persistentTokenRepository(ObjectProvider&lt;DataSource&gt; dataSources) {\n        JdbcTokenRepositoryImpl tokenRepository = new JdbcTokenRepositoryImpl();\n        tokenRepository.setDataSource(dataSources.getIfAvailable());\n        tokenRepository.setCreateTableOnStartup(false);\n        return tokenRepository;\n    }\n    // 省略其他代码\n}</code></pre>\n<p>除了在浏览器中手动进行登录，查看 Cookies 以外，我们还要写个单元测试，保证代码的逻辑符合预期，具体如代码示例 10-17 所示。其中模拟向 <code>/doLogin</code> 提交了一个 <code>POST</code> 请求，其中包含了用户名和密码，还有页面上的复选框 <code>remember</code>，它的值可以是 <code>true</code>、<code>on</code>、<code>yes</code> 和 <code>1</code> 中的任意一个（忽略大小写）。此外，还必须要带上一个 CSRF 令牌（关于 CSRF 的内容，我们在 10.4.1 节再做说明，这里先加上）。在验证部分，额外验证了 <code>remember-me</code> Cookie 的情况，还对 persistent_logins 表里的数据进行了检查。</p>\n<blockquote>\n<p><strong>代码示例 10-17</strong>　针对持久化令牌的单元测试</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootTest\nclass OrderControllerTest {\n    private MockMvc mockMvc;\n    private JdbcTemplate jdbcTemplate;\n\n    @BeforeEach\n    void setUp(WebApplicationContext wac) {\n        this.mockMvc = MockMvcBuilders.webAppContextSetup(wac).apply(springSecurity()).build();\n        jdbcTemplate = new JdbcTemplate(wac.getBean(DataSource.class));\n    }\n\n    @AfterEach\n    void tearDown() {\n        mockMvc = null;\n        jdbcTemplate = null;\n    }\n\n    @Test\n    void testOrderPageWithPersistentToken() throws Exception {\n        mockMvc.perform(post(\"/doLogin\")\n                .param(\"user\", \"LiLei\")\n                .param(\"pwd\", \"binarytea\")\n                .param(\"remember\", \"1\")\n                .with(csrf())) // 提交的内容里要包含一个CSRF令牌\n                .andExpect(authenticated())\n                .andExpect(cookie().exists(\"remember-me\"))\n                .andExpect(cookie().maxAge(\"remember-me\", 24 * 60 * 60));\n        assertEquals(1, jdbcTemplate.queryForObject(\"select count(1) from persistent_logins\", Integer.class));\n        assertEquals(\"LiLei\",\n                jdbcTemplate.queryForObject(\"select username from persistent_logins\", String.class));\n    }\n    // 省略其他代码\n}</code></pre>\n<h3 id=\"nav_point_157\">10.2.4　自定义认证方式</h3>\n<p>虽然 Spring Security 提供了很多不同的身份验证方式，但总有些时候我们需要自己动手实现一些功能。例如，可以将 JSON Web Token（简称 JWT）拿过来，用做 <code>REST</code> 服务的身份认证。</p>\n<p>要实现自定义的认证，大致需要做以下的工作：</p>\n<p>(1) 提供一个用于登录的接口，可以是个 <code>Controller</code>；</p>\n<p>(2) 提供一个对每个请求进行权限验证的 <code>Filter</code>，一般会基于现有的 <code>Filter</code> 进行扩展，例如，稍后会看到的 <code>AbstractPreAuthenticatedProcessingFilter</code>；</p>\n<p>(3) 提供一个 <code>AuthenticationProvider</code>，用来进行具体的验证工作，这个对象会被放到 <code>AuthenticationManager</code> 中；</p>\n<p>(4) 如果获取用户信息的方式比较特殊，还需要提供定制的 <code>UserDetailsService</code> 实现。</p>\n<p>接下来，让我们看看如何在二进制奶茶店中通过自定义 JWT 认证的方式来提供身份认证能力。</p>\n<blockquote>\n<p><strong>需求描述</strong>　虽然店员可以通过 Web 界面为顾客下单，变更订单状态，但我们更希望顾客能够自己通过程序自助完成各种查看菜单和下单的过程。这时，程序就需要知道顾客是谁，告诉服务提供方，还要能验证顾客的身份。</p>\n</blockquote>\n<p>针对这个需求，JWT 就是一个比较轻量级的解决方案。Spring Security 对于 JWT 的支持嵌在 OAuth 2.0 的支持里，我们可以将 JWT 独立出来，专门为 <code>REST</code> 服务做一套身份认证的支持。<span class=\"comment-number\">14</span></p>\n\n<p>要支持 JWT，我们需要在 pom.xml 中引入对应的依赖，这里我们选择 Java JWT:JSON Web Token for Java and Android（简称 JJWT）<span class=\"comment-number\">15</span>，可以添加如下的依赖，如果不是用的 Jackson JSON，也有对应 GSON 的包：</p>\n\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;\n    &lt;artifactId&gt;jjwt-api&lt;/artifactId&gt;\n    &lt;version&gt;0.11.2&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;\n    &lt;artifactId&gt;jjwt-impl&lt;/artifactId&gt;\n    &lt;version&gt;0.11.2&lt;/version&gt;\n    &lt;scope&gt;runtime&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;\n    &lt;artifactId&gt;jjwt-jackson&lt;/artifactId&gt;\n    &lt;version&gt;0.11.2&lt;/version&gt;\n    &lt;scope&gt;runtime&lt;/scope&gt;\n&lt;/dependency&gt;</code></pre>\n<p>在开始 Spring Security 相关内容的开发前，先来准备一个辅助类，实现 JWT 令牌的生成与解析。在 JWT 中，编码的信息称为 Claim，因为 JWT 展开后是 JSON 格式的，所以每个 Claim 都是 JSON 对象里的一个键。一个 JWT 令牌分为三个部分，之间用“.”分隔，每个部分都是一段 BASE64 编码。第一部分是头信息，包含了签名算法等信息；第二部分是正文，包含了所有的 Claim；第三部分是签名。JWT 的令牌中可以记录和生成有效时间，超过时间就失效了。</p>\n<p>我们编写一个 <code>JwtTokenHelper</code> 类，封装与 JWT 有关的操作，代码示例 10-18 是其中的初始化部分。其中我们注入了配置文件中的 <code>jwt.secret</code>，这是签名用的密钥，生成密钥的代码也在示例中，通过 <code>Keys.hmacShaKeyFor()</code> 来进行还原。<code>JwtParser</code> 是线程安全的，因此我们直接在初始化过程中完成了对它的初始化，方便后续解析令牌，考虑到不同的服务器之间可能存在时钟偏移，<code>setAllowedClockSkewSeconds()</code> 方法设置了我们能够容忍的最大时钟误差。</p>\n<blockquote>\n<p><strong>代码示例 10-18</strong>　<code>JwtTokenHelper</code> 类的初始化代码</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Component\n@Slf4j\npublic class JwtTokenHelper implements InitializingBean {\n    private static final String ISSUER = \"BinaryTea\";\n\n    private JwtParser jwtParser;\n    private Key key;\n\n    @Value(\"$\")\n    public void setBase64Key(String base64) {\n        // this.key = Keys.secretKeyFor(SignatureAlgorithm.HS512);\n        // log.info(\"使用密钥：{}\", Base64.getEncoder().encodeToString(key.getEncoded()));\n        // 密钥类似：gR6cytlUlgMfVh08nLFZf8hMk4mdJDX5rWBVlsCbKvRlWcLwNRU6+rIPcLx21x191kJgP8udtoZuHt5yUDWtgg==\n        key = Keys.hmacShaKeyFor(Base64.getDecoder().decode(base64));\n    }\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        jwtParser = Jwts.parserBuilder().requireIssuer(ISSUER)\n                     .setSigningKey(key).setAllowedClockSkewSeconds(10)\n                     .build();\n    }\n    // 省略其他代码\n}</code></pre>\n<p>令牌的初始化主要是通过 <code>Jwts.builder()</code> 返回的 <code>JwtBuilder</code> 来做的，我们甚至可以将权限列表编码到令牌里，它提供了 <code>claim()</code> 和 <code>addClaims()</code> 等方法。解析令牌则是直接使用 <code>JwtParser.parseClaimsJws()</code> 方法。具体代码如代码示例 10-19 所示。</p>\n<blockquote>\n<p><strong>代码示例 10-19</strong>　<code>JwtTokenHelper</code> 类中关于令牌生成与解析的代码</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Component\n@Slf4j\npublic class JwtTokenHelper implements InitializingBean {\n    public String generateToken(String username) {\n        LocalDateTime now = LocalDateTime.now();\n        LocalDateTime expireTime = LocalDateTime.now().plusHours(1); // TOKEN一个小时有效\n\n        return Jwts.builder()\n                .setSubject(username)\n                .setIssuer(ISSUER)\n                .setIssuedAt(Date.from(now.atZone(ZoneId.systemDefault()).toInstant()))\n                .setExpiration(Date.from(expireTime.atZone(ZoneId.systemDefault()).toInstant()))\n                .signWith(key)\n                .compact();\n    }\n\n    public Jws&lt;Claims&gt; parseToken(String token) {\n        try {\n            return jwtParser.parseClaimsJws(token);\n        } catch (SignatureException | MalformedJwtException | UnsupportedJwtException |\n                IllegalArgumentException e) {\n            throw new BadCredentialsException(\"Invalid Token\", e);\n        } catch (ExpiredJwtException e) {\n            throw new CredentialsExpiredException(\"Token Expired\", e);\n        }\n    }\n    // 省略其他代码\n}</code></pre>\n<p>做好了前期的准备，接下来就要进入 Spring Security 相关类的开发阶段了。首先，是根据用户名与密码获取 JWT 令牌的登录接口。具体的登录校验是委托给了 <code>AuthenticationManager</code> 来做的：如果登录信息有效，就生成令牌并返回 HTTP <code>200 OK</code> 的应答；如果登录信息无效，则返回提示信息，用的响应码就是 <code>403 Forbidden</code>。具体如代码示例 10-20 所示。</p>\n<blockquote>\n<p><strong>代码示例 10-20</strong>　根据用户名与密码获得令牌的 <code>TokenController</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@RestController\n@Slf4j\npublic class TokenController {\n    @Autowired\n    private AuthenticationManager authenticationManager;\n    @Autowired\n    private JwtTokenHelper jwtTokenHelper;\n\n    @PostMapping(\"/token\")\n    public ResponseEntity&lt;TokenResponse&gt; createToken(@RequestBody @Valid TokenRequest tokenRequest,\n                                                     BindingResult result) {\n        if (result.hasErrors()) {\n            String errorMessage = result.getAllErrors().stream()\n                    .map(e -&gt; e.getDefaultMessage()).collect(Collectors.joining(\";\"));\n            return ResponseEntity.badRequest().body(new TokenResponse(null, errorMessage));\n        }\n        try {\n            Authentication authentication =\n                new UsernamePasswordAuthenticationToken(tokenRequest.getUsername(), tokenRequest.getPassword());\n            authenticationManager.authenticate(authentication);\n        } catch (AuthenticationException e) {\n            log.warn(\"Login failed. User: {}, Reason: {}\", tokenRequest.getUsername(), e.getMessage());\n            return ResponseEntity.status(HttpStatus.FORBIDDEN)\n                .body(new TokenResponse(null, e.getMessage()));\n        }\n\n        return ResponseEntity.ok(new TokenResponse(generateToken(tokenRequest.getUsername()), null));\n    }\n\n    private String generateToken(String username) {\n        String token = jwtTokenHelper.generateToken(username);\n        log.info(\"为用户{}生成Token [{}]\", username, token);\n        return token;\n    }\n}</code></pre>\n<p>其中对应的请求和应答类比较简单：<code>TokenRequest</code> 中包含要求非空（带了 <code>@NotEmpty</code> 注解）的 <code>username</code> 和 <code>password</code> 成员；<code>TokenResponse</code> 中则是代表令牌的 <code>token</code> 和代表描述消息的 <code>message</code>。</p>\n<p>接下来，要写的就是针对每个请求进行令牌校验的 <code>Filter</code> 了，由于这其实是个预先完成身份认证的处理过程，正好可以用上 <code>AbstractPreAuthenticatedProcessingFilter</code>，我们就将它作为父类进行扩展，Spring Security 针对这类处理已经提供了较好的支持，我们只需开发些简单的代码，再做些配置就好，具体如代码示例 10-21 所示。这段代码从请求中取出令牌作为要验证的主体信息，由于 <code>PreAuthenticatedAuthenticationProvider</code> 的验证要求，代表密码的 <code>getPreAuthenticatedCredentials()</code> 必须要有个值，所以随便返回一串文本。</p>\n<blockquote>\n<p><strong>代码示例 10-21</strong>　校验 JWT 令牌的 <code>JwtAuthenticationFilter</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>public class JwtAuthenticationFilter extends AbstractPreAuthenticatedProcessingFilter {\n    @Autowired\n    private JwtTokenHelper jwtTokenHelper;\n\n    @Override\n    protected Object getPreAuthenticatedPrincipal(HttpServletRequest request) {\n        String header = request.getHeader(HttpHeaders.AUTHORIZATION);\n        if (!StringUtils.startsWith(header, \"Bearer \")) {\n            return null;\n        }\n        String token = StringUtils.substring(header, 7);\n        Jws&lt;Claims&gt; jws = jwtTokenHelper.parseToken(token);\n        return jws.getBody().getSubject();\n    }\n\n    @Override\n    protected Object getPreAuthenticatedCredentials(HttpServletRequest request) {\n        return \"NO_PASSWORD_NEEDED\";\n    }\n}</code></pre>\n<p>最后将所有内容组装起来，配置过程还是放在 <code>WebSecurityConfiguration</code> 中，具体如代码示例 10-22 所示。</p>\n<blockquote>\n<p><strong>代码示例 10-22</strong>　<code>WebSecurityConfiguration</code> 中与 JWT 相关的代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Configuration\n@EnableWebSecurity\n@EnableGlobalMethodSecurity(securedEnabled = true, prePostEnabled = true, jsr250Enabled = true)\npublic class WebSecurityConfiguration extends WebSecurityConfigurerAdapter {\n    @Autowired\n    private UserDetailsService userDetailsService;\n\n    @Bean\n    public JwtAuthenticationFilter jwtAuthenticationFilter() throws Exception {\n        JwtAuthenticationFilter filter = new JwtAuthenticationFilter();\n        filter.setAuthenticationManager(authenticationManagerBean());\n        return filter;\n    }\n\n    @Bean\n    public PreAuthenticatedAuthenticationProvider jwtPreAuthenticatedAuthenticationProvider() {\n        PreAuthenticatedAuthenticationProvider provider = new PreAuthenticatedAuthenticationProvider();\n        provider.setPreAuthenticatedUserDetailsService(\n            new UserDetailsByNameServiceWrapper&lt;&gt;(userDetailsService));\n        return provider;\n    }\n\n    @Bean(\"authenticationManager\")\n    @Override\n    public AuthenticationManager authenticationManagerBean() throws Exception {\n        return super.authenticationManagerBean();\n    }\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.addFilterAt(jwtAuthenticationFilter(), AbstractPreAuthenticatedProcessingFilter.class)\n             .csrf().disable()\n             // .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n             .exceptionHandling()\n             .defaultAuthenticationEntryPointFor(\n                 new LoginUrlAuthenticationEntryPoint(\"/login\"), new MediaTypeRequestMatcher(MediaType.TEXT_HTML))\n             .defaultAuthenticationEntryPointFor(new HttpStatusEntryPoint(HttpStatus.UNAUTHORIZED),\n                 new MediaTypeRequestMatcher(MediaType.APPLICATION_JSON)).and()\n             .anonymous()\n             // 省略后续配置\n    }\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        auth.authenticationProvider(jwtPreAuthenticatedAuthenticationProvider())\n            .userDetailsService(userDetailsService);\n    }\n    // 省略其他代码\n}</code></pre>\n<p>上面的代码需要注意以下几点：</p>\n<p>(1) 因为我们的令牌中只有用户名的信息，未包含权限，所以 <code>PreAuthenticatedAuthentication Provider</code> 在验证后还需要从 <code>UserDetailsService</code> 中根据用户名取出用户信息，这里就要用 <code>UserDetailsByNameServiceWrapper</code> 封装一下；</p>\n<p>(2) 自定义的 <code>PreAuthenticatedAuthenticationProvider</code> 需要塞入 <code>AuthenticationManager</code> 里，最后的 <code>configure()</code> 方法就是用来配置 <code>AuthenticationManager</code> 的；</p>\n<p>(3) <code>HttpSecurity.addFilterAt()</code> 可以在 <code>Filter</code> 链的指定位置插入 <code>Filter</code>，我们用它来插入自己开发的 <code>JwtAuthenticationFilter</code>；</p>\n<p>(4) 由于是程序之间的交互，直接在头里携带身份信息，所以这里要关闭 CSRF 防护；</p>\n<p>(5) 正常情况下，如果程序全是处理 <code>REST</code> 请求的，可以将会话策略设置为 <code>STATELESS</code>；</p>\n<p>(6) 如果请求中未携带 JWT 令牌，需要给一个明确的提示，之前的表单登录用的是 <code>LoginUrlAuthenticationEntryPoint</code>，这里我们添加一个针对 <code>application/json</code> 请求有效的 <code>HttpStatusEntryPoint</code>，它会返回一个 <code>401 Unauthorized</code> 响应。</p>\n<p>这个服务端的开发基本就到此为止了，具体的客户端该如何使用，我们会在 10.4 节展开。</p>\n","comments":[]}