{"id":89832,"title":"HTML小实验：用代码分析HTML标准","content":"<p>你好，我是winter。</p><p>前面的课程中，我们已经讲解了大部分的HTML标签。</p><p>然而，为了突出重点，我们还是会忽略一些标签类型。比如表单类标签和表格类标签，我认为只有少数前端工程师用过，比如我在整个手机淘宝的工作生涯中，一次表格类标签都没有用到，表单类则只用过input，也只有几次。</p><p>那么，剩下的标签我们怎么样去了解它们呢？当然是查阅HTML标准。</p><p>由于阅读标准有一定门槛，需要了解一些机制，这节课，我为你设计了一个小实验，用JavaScript代码去抽取标准中我们需要的信息。</p><h2>HTML标准</h2><p>我们采用WHATWG的living standard标准，我们先来看看标准是如何描述一个标签的，这里我们看到，有下面这些内容。</p><pre><code>Categories:\n    Flow content.\n    Phrasing content.\n    Embedded content.\n    If the element has a controls attribute: Interactive content.\n    Palpable content.\nContexts in which this element can be used:\n    Where embedded content is expected.\nContent model:\n    If the element has a src attribute: zero or more track elements, then transparent, but with no media element descendants.\n    If the element does not have a src attribute: zero or more source elements, then zero or more track elements, then transparent, but with no media element descendants.\nTag omission in text/html:\n    Neither tag is omissible.\nContent attributes:\n    Global attributes\n    src — Address of the resource\n    crossorigin — How the element handles crossorigin requests\n    poster — Poster frame to show prior to video playback\n    preload — Hints how much buffering the media resource will likely need\n    autoplay — Hint that the media resource can be started automatically when the page is loaded\n    playsinline — Encourage the user agent to display video content within the element's playback area\n    loop — Whether to loop the media resource\n    muted — Whether to mute the media resource by default\n    controls — Show user agent controls\n    width — Horizontal dimension\n    height — Vertical dimension\nDOM interface:\n    [Exposed=Window, HTMLConstructor]\n    interface HTMLVideoElement : HTMLMediaElement {\n      [CEReactions] attribute unsigned long width;\n      [CEReactions] attribute unsigned long height;\n      readonly attribute unsigned long videoWidth;\n      readonly attribute unsigned long videoHeight;\n      [CEReactions] attribute USVString poster;\n      [CEReactions] attribute boolean playsInline;\n    };\n</code></pre><p>我们看到，这里的描述分为6个部分，有下面这些内容。</p><ul>\n<li>Categories：标签所属的分类。</li>\n<li>Contexts in which this element can be used：标签能够用在哪里。</li>\n<li>Content model：标签的内容模型。</li>\n<li>Tag omission in text/html：标签是否可以省略。</li>\n<li>Content attributes：内容属性。</li>\n<li>DOM interface：用WebIDL定义的元素类型接口。</li>\n</ul><!-- [[[read_end]]] --><p>这一节课，我们关注一下Categories、Contexts in which this element can be used、Content model这几个部分。我会带你从标准中抓取数据，做一个小工具，用来检查X标签是否能放入Y标签内。</p><h2>代码角度分析HTML标准</h2><p>HTML标准描述用词非常的严谨，这给我们抓取数据带来了巨大的方便，首先，我们打开单页面版HTML标准：</p><ul>\n<li><a href=\"https://html.spec.whatwg.org/\">https://html.spec.whatwg.org/</a></li>\n</ul><p>在这个页面上，我们执行一下以下代码：</p><pre><code>Array.prototype.map.call(document.querySelectorAll(&quot;.element&quot;), e=&gt;e.innerText);\n</code></pre><p>这样我们就得到了所有元素的定义了，现在有107个元素。</p><p>不过，比较尴尬的是，这些文本中并不包含元素名，我们只好从id属性中获取，最后代码类似这样：</p><pre><code class=\"language-JavaScript\">var elementDefinations = Array.prototype.map.call(document.querySelectorAll(\".element\"), e =&gt; ({\n  text:e.innerText,\n  name:e.childNodes[0].childNodes[0].id.match(/the\\-([\\s\\S]+)\\-element:/)?RegExp.$1:null}));\n</code></pre><p>接下来我们用代码理解一下这些文本。首先我们来分析一下这些文本，它分成了6个部分，而且顺序非常固定，这样，我们可以用JavaScript的正则表达式匹配来拆分六个字段。</p><p>我们这个小实验的目标是计算元素之间的包含关系，因此，我们先关心一下categories和contentModel两个字段。</p><pre><code class=\"language-JavaScript\">for(let defination of elementDefinations) {\n\n  console.log(defination.name + \":\")\n  let categories = defination.text.match(/Categories:\\n([\\s\\S]+)\\nContexts in which this element can be used:/)[1].split(\"\\n\");\n  for(let category of categories) {\n      console.log(category);\n  }\n    \n\n/*\n  let contentModel = defination.text.match(/Content model:\\n([\\s\\S]+)\\nTag omission in text\\/html:/)[1].split(\"\\n\");\n  for(let line of contentModel)\n    console.log(line);\n*/\n}\n</code></pre><p>接下来我们来处理category。</p><p>首先category的写法中，最基本的就是直接描述了category的句子，我们把这些不带任何条件的category先保存起来，然后打印出来其它的描述看看：</p><pre><code class=\"language-JavaScript\">for(let defination of elementDefinations) {\n\n  //console.log(defination.name + \":\")\n  let categories = defination.text.match(/Categories:\\n([\\s\\S]+)\\nContexts in which this element can be used:/)[1].split(\"\\n\");\n  defination.categories = [];\n  for(let category of categories) {\n    if(category.match(/^([^ ]+) content./))\n      defination.categories.push(RegExp.$1);\n    else\n      console.log(category)  \n  }\n    \n\n/*\n  let contentModel = defination.text.match(/Content model:\\n([\\s\\S]+)\\nTag omission in text\\/html:/)[1].split(\"\\n\");\n  for(let line of contentModel)\n    console.log(line);\n*/\n}\n</code></pre><p>这里我们要处理的第一个逻辑是带if的情况。</p><p>然后我们来看看剩下的情况：</p><pre><code> None.\n Sectioning root.\n None.\n Sectioning root.\n None.\n Form-associated element.\n Listed and submittable form-associated element.\n None.\n Sectioning root.\n None.\n If the type attribute is not in the Hidden state: Listed, labelable, submittable, resettable, and autocapitalize-inheriting form-associated element.\n If the type attribute is in the Hidden state: Listed, submittable, resettable, and autocapitalize-inheriting form-associated element.\n Listed, labelable, submittable, and autocapitalize-inheriting form-associated element.\n Listed, labelable, submittable, resettable, and autocapitalize-inheriting form-associated element.\n None.\n Listed, labelable, submittable, resettable, and autocapitalize-inheriting form-associated element.\n Listed, labelable, resettable, and autocapitalize-inheriting form-associated element.\n Labelable element.\n Sectioning root.\n Listed and autocapitalize-inheriting form-associated element.\n None.\n Sectioning root.\n None.\n Sectioning root.\n Script-supporting element.\n</code></pre><p>这里出现了几个概念：</p><ul>\n<li>None</li>\n<li>Sectioning root</li>\n<li>Form-associated element</li>\n<li>Labelable element</li>\n<li>Script-supporting element</li>\n</ul><p>如果我们要真正完美地实现元素分类，就必须要在代码中加入正则表达式来解析这些规则，这里作为今天的课后问题，留给你自己完成。</p><p>接下来我们看看Content Model，我们照例先处理掉最简单点的部分，就是带分类的内容模型：</p><pre><code class=\"language-JavaScript\">\nfor(let defination of elementDefinations) {\n\n  //console.log(defination.name + \":\")\n  let categories = defination.text.match(/Categories:\\n([\\s\\S]+)\\nContexts in which this element can be used:/)[1].split(\"\\n\");\n  defination.contentModel = [];\n  let contentModel = defination.text.match(/Content model:\\n([\\s\\S]+)\\nTag omission in text\\/html:/)[1].split(\"\\n\");\n  for(let line of contentModel)\n    if(line.match(/^([^ ]+) content./))\n      defination.contentModel.push(RegExp.$1);\n    else\n      console.log(line)\n}\n\n</code></pre><p>好了，我们照例看看剩下了什么：</p><pre><code> A head element followed by a body element.\n If the document is an iframe srcdoc document or if title information is available from a higher-level protocol: Zero or more elements of metadata content, of which no more than one is a title element and no more than one is a base element.\n Otherwise: One or more elements of metadata content, of which exactly one is a title element and no more than one is a base element.\n Text that is not inter-element whitespace.\n Nothing.\n Text that gives a conformant style sheet.\n One or more h1, h2, h3, h4, h5, h6 elements, optionally intermixed with script-supporting elements.\n Nothing.\n Zero or more li and script-supporting elements.\n Either: Zero or more groups each consisting of one or more dt elements followed by one or more dd elements, optionally intermixed with script-supporting elements.\n Or: One or more div elements, optionally intermixed with script-supporting elements.\n Either: one figcaption element followed by flow content.\n Or: flow content followed by one figcaption element.\n Or: flow content.\n If the element is a child of a dl element: one or more dt elements followed by one or more dd elements, optionally intermixed with script-supporting elements.\n If the element is not a child of a dl element: flow content.\n Transparent, but there must be no interactive content or a element descendants.\n See prose.\n Text.\n If the element has a datetime attribute: Phrasing content.\n Otherwise: Text, but must match requirements described in prose below.\n Nothing.\n Transparent.\n Zero or more source elements, followed by one img element, optionally intermixed with script-supporting elements.\n Nothing.\n Zero or more param elements, then, transparent.\n Nothing.\n If the element has a src attribute: zero or more track elements, then transparent, but with no media element descendants.\n If the element does not have a src attribute: zero or more source elements, then zero or more track elements, then transparent, but with no media element descendants.\n If the element has a src attribute: zero or more track elements, then transparent, but with no media element descendants.\n If the element does not have a src attribute: zero or more source elements, then zero or more track elements, then transparent, but with no media element descendants.\n Nothing.\n Transparent.\n Nothing.\n In this order: optionally a caption element, followed by zero or more colgroup elements, followed optionally by a thead element, followed by either zero or more tbody elements or one or more tr elements, followed optionally by a tfoot element, optionally intermixed with one or more script-supporting elements.\n If the span attribute is present: Nothing.\n If the span attribute is absent: Zero or more col and template elements.\n Nothing.\n Zero or more tr and script-supporting elements.\n Zero or more td, th, and script-supporting elements.\n Nothing.\n Zero or more option, optgroup, and script-supporting elements.\n Either: phrasing content.\n Or: Zero or more option and script-supporting elements.\n Zero or more option and script-supporting elements.\n If the element has a label attribute and a value attribute: Nothing.\n If the element has a label attribute but no value attribute: Text.\n If the element has no label attribute and is not a child of a datalist element: Text that is not inter-element whitespace.\n If the element has no label attribute and is a child of a datalist element: Text.\n Text.\n Optionally a legend element, followed by flow content.\n One summary element followed by flow content.\n Either: phrasing content.\n Or: one element of heading content.\n If there is no src attribute, depends on the value of the type attribute, but must match script content restrictions.\n If there is a src attribute, the element must be either empty or contain only script documentation that also matches script content restrictions.\n When scripting is disabled, in a head element: in any order, zero or more link elements, zero or more style elements, and zero or more meta elements.\n When scripting is disabled, not in a head element: transparent, but there must be no noscript element descendants.\n Otherwise: text that conforms to the requirements given in the prose.\n Nothing (for clarification, see example).\n Transparent\n Transparent, but with no interactive content descendants except for a elements, img elements with usemap attributes, button elements, input elements whose type attribute are in the Checkbox or Radio Button states, input elements that are buttons, select elements with a multiple attribute or a display size greater than 1, and elements that would not be interactive content except for having the tabindex attribute specified.\n</code></pre><p>这有点复杂，我们还是把它做一些分类，首先我们过滤掉带If的情况、Text和Transparent。</p><pre><code class=\"language-JavaScript\">for(let defination of elementDefinations) {\n  //console.log(defination.name + \":\")\n  let categories = defination.text.match(/Categories:\\n([\\s\\S]+)\\nContexts in which this element can be used:/)[1].split(\"\\n\");\n  defination.contentModel = [];\n  let contentModel = defination.text.match(/Content model:\\n([\\s\\S]+)\\nTag omission in text\\/html:/)[1].split(\"\\n\");\n  for(let line of contentModel)\n    if(line.match(/([^ ]+) content./))\n      defination.contentModel.push(RegExp.$1);\n    else if(line.match(/Nothing.|Transparent./));\n    else if(line.match(/^Text[\\s\\S]*.$/));\n    else\n      console.log(line)\n}\n</code></pre><p>这时候我们再来执行看看：</p><pre><code>A head element followed by a body element.\nOne or more h1, h2, h3, h4, h5, h6 elements, optionally intermixed with script-supporting elements.\nZero or more li and script-supporting elements.\nEither: Zero or more groups each consisting of one or more dt elements followed by one or more dd elements, optionally intermixed with script-supporting elements.\nOr: One or more div elements, optionally intermixed with script-supporting elements.\nIf the element is a child of a dl element: one or more dt elements followed by one or more dd elements, optionally intermixed with script-supporting elements.\nSee prose.\nOtherwise: Text, but must match requirements described in prose below.\nZero or more source elements, followed by one img element, optionally intermixed with script-supporting elements.\nZero or more param elements, then, transparent.\nIf the element has a src attribute: zero or more track elements, then transparent, but with no media element descendants.\nIf the element does not have a src attribute: zero or more source elements, then zero or more track elements, then transparent, but with no media element descendants.\nIf the element has a src attribute: zero or more track elements, then transparent, but with no media element descendants.\nIf the element does not have a src attribute: zero or more source elements, then zero or more track elements, then transparent, but with no media element descendants.\nIn this order: optionally a caption element, followed by zero or more colgroup elements, followed optionally by a thead element, followed by either zero or more tbody elements or one or more tr elements, followed optionally by a tfoot element, optionally intermixed with one or more script-supporting elements.\nIf the span attribute is absent: Zero or more col and template elements.\nZero or more tr and script-supporting elements.\nZero or more td, th, and script-supporting elements.\nZero or more option, optgroup, and script-supporting elements.\nOr: Zero or more option and script-supporting elements.\nZero or more option and script-supporting elements.\nIf the element has a label attribute but no value attribute: Text.\nIf the element has no label attribute and is not a child of a datalist element: Text that is not inter-element whitespace.\nIf the element has no label attribute and is a child of a datalist element: Text.\nWhen scripting is disabled, in a head element: in any order, zero or more link elements, zero or more style elements, and zero or more meta elements.\nWhen scripting is disabled, not in a head element: transparent, but there must be no noscript element descendants.\nOtherwise: text that conforms to the requirements given in the prose.\n</code></pre><p>这下剩余的就少多了，我们可以看到，基本上剩下的都是直接描述可用的元素了，如果你愿意，还可以用代码进一步解析，不过如果是我的话，会选择手工把它们写成JSON了，毕竟只有三十多行文本。</p><p>好了，有了contentModel和category，我们要检查某一元素是否可以作为另一元素的子元素，就可以判断一下两边是否匹配啦，首先，我们要做个索引：</p><pre><code class=\"language-JavaScript\">var dictionary = Object.create(null);\n\nfor(let defination of elementDefinations) {\n  dictionary[defination.name] = defination;\n}\n\n</code></pre><p>然后我们编写一下我们的check函数：</p><pre><code class=\"language-JavaScript\">function check(parent, child) {\n  for(let category of child.categories)\n    if(parent.contentModel.categories.contains(category))\n      return true;\n  if(parent.contentModel.names.contains(child.name))\n      return true;\n  return false;\n}\n\n</code></pre><h2>总结</h2><p>这一节课，我们完成了一个小实验：利用工具分析Web标准文本，来获得元素的信息。</p><p>通过这个实验，我希望能够传递一种思路，代码能够帮助我们从Web标准中挖掘出来很多想要的信息，编写代码的过程，也是更深入理解标准的契机。</p><p>我们前面的课程中把元素分成了几类来讲解，但是这些分类只能大概地覆盖所有的标签，我设置课程的目标也是讲解标签背后的知识，而非每一种标签的细节。具体每一种标签的属性和细节，可以留给大家自己去整理。</p><p>这一节课的产出，则是“绝对完整的标签列表”，也是我学习和阅读标准的小技巧，通过代码我们可以从不同的侧面分析标准的内容，挖掘需要注意的点，这是一种非常好的学习方法。</p>","comments":[{"had_liked":false,"id":85718,"user_name":"阿成","can_delete":false,"product_type":"c1","uid":1390032,"ip_address":"","ucode":"CEC3CD65FB9333","user_header":"https://static001.geekbang.org/account/avatar/00/15/35/d0/f2ac6d91.jpg","comment_is_top":false,"comment_ctime":1555211916,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"74569655948","product_id":100023201,"comment_content":"这种“通过简单的文本分析，快速提炼出自己感兴趣的部分”的方法是非常值得借鉴的，我平时也会用这种方法去网页中做一些快速的统计和信息筛选。<br><br>不过，通过这样的文本分析去完成一个“检查一个元素是否能够放置在另一个元素内部”的小程序还是有点“把问题复杂化”的感觉（尽管这个过程中也可以锻炼一些能力），况且文档是会更新的，指不定有一天那些check分支就hold不住新的case了。<br><br>在我看来，如果想知道A元素是否可以放在B元素中，只要把所有元素的categories和contentModel提取出来，筛选出A元素的categories和B元素的contentModel，再去阅读比较就可以了（当然你还要对标准中的一些术语有所了解，所幸的是这些术语都有超链接指向定义，所以还是比较方便的ヾ(≧▽≦*)o）。<br><br>","like_count":18},{"had_liked":false,"id":90334,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1556497300,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"35916235668","product_id":100023201,"comment_content":"老师 有个疑问： WHATWG 和 W3C 标准以哪个为准，这两个标准有什么区别？是不是相互不认可的","like_count":9},{"had_liked":false,"id":178744,"user_name":"前端男孩","can_delete":false,"product_type":"c1","uid":1541708,"ip_address":"","ucode":"58668020D2D5BD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/hkBfzo6cRvbBmFZKPxlzRnKyria9gzID4WQ9mI1NdBBox5lRox7eMuhicXPB7eU1ecOa0lD9fhNTG3H6yJlII50A/132","comment_is_top":false,"comment_ctime":1581814323,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10171748915","product_id":100023201,"comment_content":"为什么我去网页控制台上Console出不来呢？","like_count":3},{"had_liked":false,"id":84887,"user_name":"会飞的大猫","can_delete":false,"product_type":"c1","uid":1049880,"ip_address":"","ucode":"ABE6BBE8A5713E","user_header":"https://static001.geekbang.org/account/avatar/00/10/05/18/955a972f.jpg","comment_is_top":false,"comment_ctime":1554943238,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5849910534","product_id":100023201,"comment_content":"Winter，刚看完文章，就在淘宝技术节视频看到了你持相机和大家自拍的图片","like_count":1},{"had_liked":false,"id":246181,"user_name":"Clors","can_delete":false,"product_type":"c1","uid":2162945,"ip_address":"","ucode":"E25BEA2D544664","user_header":"https://static001.geekbang.org/account/avatar/00/21/01/01/897990a0.jpg","comment_is_top":false,"comment_ctime":1599201432,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599201432","product_id":100023201,"comment_content":"我提出一个场景，如果vw布局网页，不使用iframe如何做到限制最大大小？","like_count":0},{"had_liked":false,"id":185270,"user_name":"Change","can_delete":false,"product_type":"c1","uid":1161260,"ip_address":"","ucode":"FB60D2378C9F02","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/2c/0f7baf3a.jpg","comment_is_top":false,"comment_ctime":1583550478,"is_pvip":false,"discussion_count":1,"race_medal":2,"score":"1583550478","product_id":100023201,"comment_content":"本想实践一下这个实验，奈何https:&#47;&#47;html.spec.whatwg.org&#47;链接打不开是什么情况？","like_count":0,"discussions":[{"author":{"id":1253128,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1f/08/14642f9e.jpg","nickname":"相望于江湖","note":"","ucode":"9CCB6F89F92C89","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305510,"discussion_content":"要翻墙","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599976142,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":100089,"user_name":"爱学习的大叔","can_delete":false,"product_type":"c1","uid":1085152,"ip_address":"","ucode":"91F9ABF1EC98D0","user_header":"https://static001.geekbang.org/account/avatar/00/10/8e/e0/847348b1.jpg","comment_is_top":false,"comment_ctime":1559441237,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559441237","product_id":100023201,"comment_content":"没太看懂，好多语法基于这个页面https:&#47;&#47;html.spec.whatwg.org&#47;","like_count":0},{"had_liked":false,"id":90618,"user_name":"away","can_delete":false,"product_type":"c1","uid":1375012,"ip_address":"","ucode":"E4411B7D42A789","user_header":"https://static001.geekbang.org/account/avatar/00/14/fb/24/d2d64acc.jpg","comment_is_top":false,"comment_ctime":1556589432,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556589432","product_id":100023201,"comment_content":" @一步 WHATWG 和 W3C 标准若有不同，一般以 WHATWG 为准","like_count":0},{"had_liked":false,"id":85224,"user_name":"嗨海海","can_delete":false,"product_type":"c1","uid":1288501,"ip_address":"","ucode":"4B245711AAAE63","user_header":"https://static001.geekbang.org/account/avatar/00/13/a9/35/2b360ff1.jpg","comment_is_top":false,"comment_ctime":1555021478,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1555021478","product_id":100023201,"comment_content":"学不到，有因果关系，工作实际需要吗？","like_count":0,"discussions":[{"author":{"id":1249969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/12/b1/3a112b27.jpg","nickname":"段帅帅","note":"","ucode":"2675BC0BE154E8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":564158,"discussion_content":"很少吧，了解一下就可以了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650171848,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84891,"user_name":"被雨水过滤的空气","can_delete":false,"product_type":"c1","uid":1080417,"ip_address":"","ucode":"1A6316040EB6A7","user_header":"https://static001.geekbang.org/account/avatar/00/10/7c/61/76b1b888.jpg","comment_is_top":false,"comment_ctime":1554943412,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554943412","product_id":100023201,"comment_content":"学习了","like_count":0}]}