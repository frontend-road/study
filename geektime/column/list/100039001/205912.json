{"id":205912,"title":"51 | 适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？","content":"<p>前面几节课我们学习了代理模式、桥接模式、装饰器模式，今天，我们再来学习一个比较常用的结构型模式：适配器模式。这个模式相对来说还是比较简单、好理解的，应用场景也很具体，总体上来讲比较好掌握。</p><p>关于适配器模式，今天我们主要学习它的两种实现方式，类适配器和对象适配器，以及5种常见的应用场景。同时，我还会通过剖析slf4j日志框架，来给你展示这个模式在真实项目中的应用。除此之外，在文章的最后，我还对代理、桥接、装饰器、适配器，这4种代码结构非常相似的设计模式做简单的对比，对这几节内容做一个简单的总结。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>适配器模式的原理与实现</h2><p><strong>适配器模式</strong>的英文翻译是<strong>Adapter Design Pattern</strong>。顾名思义，这个模式就是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。对于这个模式，有一个经常被拿来解释它的例子，就是USB转接头充当适配器，把两种不兼容的接口，通过转接变得可以一起工作。</p><p>原理很简单，我们再来看下它的代码实现。适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。具体的代码实现如下所示。其中，ITarget表示要转化成的接口定义。Adaptee是一组不兼容ITarget接口定义的接口，Adaptor将Adaptee转化成一组符合ITarget接口定义的接口。</p><!-- [[[read_end]]] --><pre><code>// 类适配器: 基于继承\npublic interface ITarget {\n  void f1();\n  void f2();\n  void fc();\n}\n\npublic class Adaptee {\n  public void fa() { //... }\n  public void fb() { //... }\n  public void fc() { //... }\n}\n\npublic class Adaptor extends Adaptee implements ITarget {\n  public void f1() {\n    super.fa();\n  }\n  \n  public void f2() {\n    //...重新实现f2()...\n  }\n  \n  // 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点\n}\n\n// 对象适配器：基于组合\npublic interface ITarget {\n  void f1();\n  void f2();\n  void fc();\n}\n\npublic class Adaptee {\n  public void fa() { //... }\n  public void fb() { //... }\n  public void fc() { //... }\n}\n\npublic class Adaptor implements ITarget {\n  private Adaptee adaptee;\n  \n  public Adaptor(Adaptee adaptee) {\n    this.adaptee = adaptee;\n  }\n  \n  public void f1() {\n    adaptee.fa(); //委托给Adaptee\n  }\n  \n  public void f2() {\n    //...重新实现f2()...\n  }\n  \n  public void fc() {\n    adaptee.fc();\n  }\n}\n</code></pre><p>针对这两种实现方式，在实际的开发中，到底该如何选择使用哪一种呢？判断的标准主要有两个，一个是Adaptee接口的个数，另一个是Adaptee和ITarget的契合程度。</p><ul>\n<li>如果Adaptee接口并不多，那两种实现方式都可以。</li>\n<li>如果Adaptee接口很多，而且Adaptee和ITarget接口定义大部分都相同，那我们推荐使用类适配器，因为Adaptor复用父类Adaptee的接口，比起对象适配器的实现方式，Adaptor的代码量要少一些。</li>\n<li>如果Adaptee接口很多，而且Adaptee和ITarget接口定义大部分都不相同，那我们推荐使用对象适配器，因为组合结构相对于继承更加灵活。</li>\n</ul><h2>适配器模式应用场景总结</h2><p>原理和实现讲完了，都不复杂。我们再来看，到底什么时候会用到适配器模式呢？</p><p>一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式算是“无奈之举”。如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。</p><p>前面我们反复提到，适配器模式的应用场景是“接口不兼容”。那在实际的开发中，什么情况下才会出现接口不兼容呢？我建议你先自己思考一下这个问题，然后再来看我下面的总结 。</p><h3>1.封装有缺陷的接口设计</h3><p>假设我们依赖的外部系统在接口设计方面有缺陷（比如包含大量静态方法），引入之后会影响到我们自身代码的可测试性。为了隔离设计上的缺陷，我们希望对外部系统提供的接口进行二次封装，抽象出更好的接口设计，这个时候就可以使用适配器模式了。</p><p>具体我还是举个例子来解释一下，你直接看代码应该会更清晰。具体代码如下所示：</p><pre><code>public class CD { //这个类来自外部sdk，我们无权修改它的代码\n  //...\n  public static void staticFunction1() { //... }\n  \n  public void uglyNamingFunction2() { //... }\n\n  public void tooManyParamsFunction3(int paramA, int paramB, ...) { //... }\n  \n   public void lowPerformanceFunction4() { //... }\n}\n\n// 使用适配器模式进行重构\npublic interface ITarget {\n  void function1();\n  void function2();\n  void fucntion3(ParamsWrapperDefinition paramsWrapper);\n  void function4();\n  //...\n}\n// 注意：适配器类的命名不一定非得末尾带Adaptor\npublic class CDAdaptor extends CD implements ITarget {\n  //...\n  public void function1() {\n     super.staticFunction1();\n  }\n  \n  public void function2() {\n    super.uglyNamingFucntion2();\n  }\n  \n  public void function3(ParamsWrapperDefinition paramsWrapper) {\n     super.tooManyParamsFunction3(paramsWrapper.getParamA(), ...);\n  }\n  \n  public void function4() {\n    //...reimplement it...\n  }\n}\n</code></pre><h3>2.统一多个类的接口设计</h3><p>某个功能的实现依赖多个外部系统（或者说类）。通过适配器模式，将它们的接口适配为统一的接口定义，然后我们就可以使用多态的特性来复用代码逻辑。具体我还是举个例子来解释一下。</p><p>假设我们的系统要对用户输入的文本内容做敏感词过滤，为了提高过滤的召回率，我们引入了多款第三方敏感词过滤系统，依次对用户输入的内容进行过滤，过滤掉尽可能多的敏感词。但是，每个系统提供的过滤接口都是不同的。这就意味着我们没法复用一套逻辑来调用各个系统。这个时候，我们就可以使用适配器模式，将所有系统的接口适配为统一的接口定义，这样我们可以复用调用敏感词过滤的代码。</p><p>你可以配合着下面的代码示例，来理解我刚才举的这个例子。</p><pre><code>public class ASensitiveWordsFilter { // A敏感词过滤系统提供的接口\n  //text是原始文本，函数输出用***替换敏感词之后的文本\n  public String filterSexyWords(String text) {\n    // ...\n  }\n  \n  public String filterPoliticalWords(String text) {\n    // ...\n  } \n}\n\npublic class BSensitiveWordsFilter  { // B敏感词过滤系统提供的接口\n  public String filter(String text) {\n    //...\n  }\n}\n\npublic class CSensitiveWordsFilter { // C敏感词过滤系统提供的接口\n  public String filter(String text, String mask) {\n    //...\n  }\n}\n\n// 未使用适配器模式之前的代码：代码的可测试性、扩展性不好\npublic class RiskManagement {\n  private ASensitiveWordsFilter aFilter = new ASensitiveWordsFilter();\n  private BSensitiveWordsFilter bFilter = new BSensitiveWordsFilter();\n  private CSensitiveWordsFilter cFilter = new CSensitiveWordsFilter();\n  \n  public String filterSensitiveWords(String text) {\n    String maskedText = aFilter.filterSexyWords(text);\n    maskedText = aFilter.filterPoliticalWords(maskedText);\n    maskedText = bFilter.filter(maskedText);\n    maskedText = cFilter.filter(maskedText, &quot;***&quot;);\n    return maskedText;\n  }\n}\n\n// 使用适配器模式进行改造\npublic interface ISensitiveWordsFilter { // 统一接口定义\n  String filter(String text);\n}\n\npublic class ASensitiveWordsFilterAdaptor implements ISensitiveWordsFilter {\n  private ASensitiveWordsFilter aFilter;\n  public String filter(String text) {\n    String maskedText = aFilter.filterSexyWords(text);\n    maskedText = aFilter.filterPoliticalWords(maskedText);\n    return maskedText;\n  }\n}\n//...省略BSensitiveWordsFilterAdaptor、CSensitiveWordsFilterAdaptor...\n\n// 扩展性更好，更加符合开闭原则，如果添加一个新的敏感词过滤系统，\n// 这个类完全不需要改动；而且基于接口而非实现编程，代码的可测试性更好。\npublic class RiskManagement { \n  private List&lt;ISensitiveWordsFilter&gt; filters = new ArrayList&lt;&gt;();\n \n  public void addSensitiveWordsFilter(ISensitiveWordsFilter filter) {\n    filters.add(filter);\n  }\n  \n  public String filterSensitiveWords(String text) {\n    String maskedText = text;\n    for (ISensitiveWordsFilter filter : filters) {\n      maskedText = filter.filter(maskedText);\n    }\n    return maskedText;\n  }\n}\n</code></pre><h3>3.替换依赖的外部系统</h3><p>当我们把项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式，可以减少对代码的改动。具体的代码示例如下所示：</p><pre><code>// 外部系统A\npublic interface IA {\n  //...\n  void fa();\n}\npublic class A implements IA {\n  //...\n  public void fa() { //... }\n}\n// 在我们的项目中，外部系统A的使用示例\npublic class Demo {\n  private IA a;\n  public Demo(IA a) {\n    this.a = a;\n  }\n  //...\n}\nDemo d = new Demo(new A());\n\n// 将外部系统A替换成外部系统B\npublic class BAdaptor implemnts IA {\n  private B b;\n  public BAdaptor(B b) {\n    this.b= b;\n  }\n  public void fa() {\n    //...\n    b.fb();\n  }\n}\n// 借助BAdaptor，Demo的代码中，调用IA接口的地方都无需改动，\n// 只需要将BAdaptor如下注入到Demo即可。\nDemo d = new Demo(new BAdaptor(new B()));\n</code></pre><h3>4.兼容老版本接口</h3><p>在做版本升级的时候，对于一些要废弃的接口，我们不直接将其删除，而是暂时保留，并且标注为deprecated，并将内部实现逻辑委托为新的接口实现。这样做的好处是，让使用它的项目有个过渡期，而不是强制进行代码修改。这也可以粗略地看作适配器模式的一个应用场景。同样，我还是通过一个例子，来进一步解释一下。</p><p>JDK1.0中包含一个遍历集合容器的类Enumeration。JDK2.0对这个类进行了重构，将它改名为Iterator类，并且对它的代码实现做了优化。但是考虑到如果将Enumeration直接从JDK2.0中删除，那使用JDK1.0的项目如果切换到JDK2.0，代码就会编译不通过。为了避免这种情况的发生，我们必须把项目中所有使用到Enumeration的地方，都修改为使用Iterator才行。</p><p>单独一个项目做Enumeration到Iterator的替换，勉强还能接受。但是，使用Java开发的项目太多了，一次JDK的升级，导致所有的项目不做代码修改就会编译报错，这显然是不合理的。这就是我们经常所说的不兼容升级。为了做到兼容使用低版本JDK的老代码，我们可以暂时保留Enumeration类，并将其实现替换为直接调用Itertor。代码示例如下所示：</p><pre><code>public class Collections {\n  public static Emueration emumeration(final Collection c) {\n    return new Enumeration() {\n      Iterator i = c.iterator();\n      \n      public boolean hasMoreElments() {\n        return i.hashNext();\n      }\n      \n      public Object nextElement() {\n        return i.next():\n      }\n    }\n  }\n}\n</code></pre><h3>5.适配不同格式的数据</h3><p>前面我们讲到，适配器模式主要用于接口的适配，实际上，它还可以用在不同格式的数据之间的适配。比如，把从不同征信系统拉取的不同格式的征信数据，统一为相同的格式，以方便存储和使用。再比如，Java中的Arrays.asList()也可以看作一种数据适配器，将数组类型的数据转化为集合容器类型。</p><pre><code>List&lt;String&gt; stooges = Arrays.asList(&quot;Larry&quot;, &quot;Moe&quot;, &quot;Curly&quot;);\n</code></pre><h2>剖析适配器模式在Java日志中的应用</h2><p>Java中有很多日志框架，在项目开发中，我们常常用它们来打印日志信息。其中，比较常用的有log4j、logback，以及JDK提供的JUL(java.util.logging)和Apache的JCL(Jakarta Commons Logging)等。</p><p>大部分日志框架都提供了相似的功能，比如按照不同级别（debug、info、warn、erro……）打印日志等，但它们却并没有实现统一的接口。这主要可能是历史的原因，它不像JDBC那样，一开始就制定了数据库操作的接口规范。</p><p>如果我们只是开发一个自己用的项目，那用什么日志框架都可以，log4j、logback随便选一个就好。但是，如果我们开发的是一个集成到其他系统的组件、框架、类库等，那日志框架的选择就没那么随意了。</p><p>比如，项目中用到的某个组件使用log4j来打印日志，而我们项目本身使用的是logback。将组件引入到项目之后，我们的项目就相当于有了两套日志打印框架。每种日志框架都有自己特有的配置方式。所以，我们要针对每种日志框架编写不同的配置文件（比如，日志存储的文件地址、打印日志的格式）。如果引入多个组件，每个组件使用的日志框架都不一样，那日志本身的管理工作就变得非常复杂。所以，为了解决这个问题，我们需要统一日志打印框架。</p><p>如果你是做Java开发的，那Slf4j这个\b日志框架你肯定不陌生，它相当于JDBC规范，提供了一套打印日志的统一接口规范。不过，它只定义了接口，并没有提供具体的实现，需要配合其他日志框架（log4j、logback……）来使用。</p><p>不仅如此，Slf4j的出现晚于JUL、JCL、log4j等日志框架，所以，这些日志框架也不可能牺牲掉版本兼容性，将接口改造成符合Slf4j接口规范。Slf4j也事先考虑到了这个问题，所以，它不仅仅提供了统一的接口定义，还提供了针对不同日志框架的适配器。对不同日志框架的接口进行二次封装，适配成统一的Slf4j接口定义。具体的代码示例如下所示：</p><pre><code>// slf4j统一的接口定义\npackage org.slf4j;\npublic interface Logger {\n  public boolean isTraceEnabled();\n  public void trace(String msg);\n  public void trace(String format, Object arg);\n  public void trace(String format, Object arg1, Object arg2);\n  public void trace(String format, Object[] argArray);\n  public void trace(String msg, Throwable t);\n \n  public boolean isDebugEnabled();\n  public void debug(String msg);\n  public void debug(String format, Object arg);\n  public void debug(String format, Object arg1, Object arg2)\n  public void debug(String format, Object[] argArray)\n  public void debug(String msg, Throwable t);\n\n  //...省略info、warn、error等一堆接口\n}\n\n// log4j日志框架的适配器\n// Log4jLoggerAdapter实现了LocationAwareLogger接口，\n// 其中LocationAwareLogger继承自Logger接口，\n// 也就相当于Log4jLoggerAdapter实现了Logger接口。\npackage org.slf4j.impl;\npublic final class Log4jLoggerAdapter extends MarkerIgnoringBase\n  implements LocationAwareLogger, Serializable {\n  final transient org.apache.log4j.Logger logger; // log4j\n \n  public boolean isDebugEnabled() {\n    return logger.isDebugEnabled();\n  }\n \n  public void debug(String msg) {\n    logger.log(FQCN, Level.DEBUG, msg, null);\n  }\n \n  public void debug(String format, Object arg) {\n    if (logger.isDebugEnabled()) {\n      FormattingTuple ft = MessageFormatter.format(format, arg);\n      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n    }\n  }\n \n  public void debug(String format, Object arg1, Object arg2) {\n    if (logger.isDebugEnabled()) {\n      FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n    }\n  }\n \n  public void debug(String format, Object[] argArray) {\n    if (logger.isDebugEnabled()) {\n      FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n    }\n  }\n \n  public void debug(String msg, Throwable t) {\n    logger.log(FQCN, Level.DEBUG, msg, t);\n  }\n  //...省略一堆接口的实现...\n}\n</code></pre><p>所以，在开发业务系统或者开发框架、组件的时候，我们统一使用Slf4j提供的接口来编写打印日志的代码，具体使用哪种日志框架实现（log4j、logback……），是可以动态地指定的（使用Java的SPI技术，这里我不多解释，你自行研究吧），只需要将相应的SDK导入到项目中即可。</p><p>不过，你可能会说，如果一些老的项目没有使用Slf4j，而是直接使用比如JCL来打印日志，那如果想要替换成其他日志框架，比如log4j，该怎么办呢？实际上，Slf4j不仅仅提供了从其他日志框架到Slf4j的适配器，还提供了反向适配器，也就是从Slf4j到其他日志框架的适配。我们可以先将JCL切换为Slf4j，然后再将Slf4j切换为log4j。经过两次适配器的转换，我们就能成功将JCL切换为了log4j。</p><h2>代理、桥接、装饰器、适配器4种设计模式的区别</h2><p>代理、桥接、装饰器、适配器，这4种模式是比较常用的结构型设计模式。它们的代码结构非常相似。笼统来说，它们都可以称为Wrapper模式，也就是通过Wrapper类二次封装原始类。</p><p>尽管代码结构相似，但这4种设计模式的用意完全不同，也就是说要解决的问题、应用场景不同，这也是它们的主要区别。这里我就简单说一下它们之间的区别。</p><p><strong>代理模式：</strong>代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。</p><p><strong>桥接模式：</strong>桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。</p><p><strong>装饰器模式：</strong>装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。</p><p><strong>适配器模式：</strong>适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。让我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>适配器模式是用来做适配，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。</p><p>一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式算是“无奈之举”，如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。</p><p>那在实际的开发中，什么情况下才会出现接口不兼容呢？我总结下了下面这样5种场景：</p><ul>\n<li>封装有缺陷的接口设计</li>\n<li>统一多个类的接口设计</li>\n<li>替换依赖的外部系统</li>\n<li>兼容老版本接口</li>\n<li>适配不同格式的数据</li>\n</ul><h2>课堂讨论</h2><p>今天我们讲到，适配器有两种实现方式：类适配器、对象适配器。那我们之前讲到的代理模式、装饰器模式，是否也同样可以有两种实现方式（类代理模式、对象代理模式，以及类装饰器模式、对象装饰器模式）呢？</p><p>欢迎留言和我分享你的思考，如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>","comments":[{"had_liked":false,"id":182655,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1582841349,"is_pvip":true,"discussion_count":6,"race_medal":0,"score":"465439309317","product_id":100039001,"comment_content":"这篇总结将前几节课串联起来了，非常赞👍<br><br>课堂讨论：<br>1. 代理模式支持，基于接口组合代理就是对象匹配，基于继承代理就是类匹配<br>2. 装饰者模式不支持，这个模式本身是为了避免继承结构爆炸而设计的","like_count":109},{"had_liked":false,"id":182688,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1582851058,"is_pvip":false,"discussion_count":2,"race_medal":1,"score":"254985921522","product_id":100039001,"comment_content":"代理模式有两种实现方式：一般情况下，我们让代理类和原始类实现同样的接口。这种就是对象代理模式；但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的。在这种情况下，我们可以通过让代理类继承原始类的方法来实现代理模式，这种属于类代理模式。<br>装饰器模式没有这两种方式：装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。所以装饰器只有对象装饰器这一种。<br>","like_count":60,"discussions":[{"author":{"id":1425252,"avatar":"https://static001.geekbang.org/account/avatar/00/15/bf/64/c9a0e913.jpg","nickname":"塔兹米","note":"","ucode":"1A58C81EF9B0A4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60170,"discussion_content":"是CustomizedFeignClient类型。\n引用指向的对象一直没有变。\n父类引用指向子类对象。这是多态。\n调用引用的方法时，如果子类重写了父类的方法的话。那么就会执行子类的方法实现，没有重写的话就依然是执行继承父类时的方法实现了。\n有一个弊端是，如果子类有它自己单独的方法那么父类的引用是无法调用到的。因为父类没有这个方法。想要调用的话就只能强转了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574698406,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182853,"user_name":"唐龙","can_delete":false,"product_type":"c1","uid":1471657,"ip_address":"","ucode":"87A10AE04F2037","user_header":"https://static001.geekbang.org/account/avatar/00/16/74/a9/5eb3ebc6.jpg","comment_is_top":false,"comment_ctime":1582876419,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"134726862595","product_id":100039001,"comment_content":"C++的STL里有大量的适配器，比如迭代器适配器，容器适配器，仿函数适配器。<br><br>容器里的反向迭代器reverse_iterator就是对迭代器iterator的一层简单封装。<br><br>所谓的栈stack和单向队列queue也是对其他容器的封装，底层默认使用的是双向队列deque，两者也都可以选用双向链表list，stack也可以使用向量vector。可以通过模板参数选用具体的底层容器，比如stack&lt;int, vector&lt;int&gt;&gt; stk;。<br><br>而仿函数适配器functor adapter则是其中的重头戏，众所周知，仿函数functor是一种重载了函数调用运算符的类。仿函数适配器可以改变仿函数的参数个数，比如bind1st, bind2nd等。<br><br>一个使用仿函数适配器的例子：<br>count_if(scores.begin(),scores.end(),bind2nd(less&lt;int&gt;(), 60));<br>上述代码翻译成人话就是统计不到60分成绩的人数。<br><br>正常来讲，不论count_if的最后一个参数是函数指针还是仿函数对象，只能接受一个参数，我们没必要为“小于60”这么微不足道的事情单独写一个函数或是仿函数，所以选择了通过bind2nd这一个适配器改变函数的参数个数，并且把其中的第二个参数绑定为60。<br><br>STL使用适配器的目的是为了更灵活的组合一些基础操作，并不是设计缺陷。<br><br>所以对于老师所说的<br>……适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式算是“无奈之举”……<br>我并不认同。","like_count":32,"discussions":[{"author":{"id":1227840,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/40/2279cfb5.jpg","nickname":"大力水手Jerry","note":"","ucode":"E4A6C71E275DB5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338286,"discussion_content":"老师所举的五例并非全是考虑不周全的场景，但“补偿模式”的提法让我对适配器模式有一个清晰直观的认识，即当前实现类Adaptee与目标接口ITarget不匹配，因此需要补偿。一个概念或者描述一般都有应用的范围和场景，就像牛顿定律是低速场景下的规律，我们并不会说牛顿定律是错误的——我们知道这个背景就好了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1609232369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1234314,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d5/8a/7050236a.jpg","nickname":"东征","note":"","ucode":"DC557A1631A493","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":218863,"discussion_content":"认同","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585707811,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1311125,"avatar":"https://static001.geekbang.org/account/avatar/00/14/01/95/fd09e8a8.jpg","nickname":"布拉姆","note":"","ucode":"479FF27D73BCAD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391971,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630741725,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1476490,"avatar":"https://static001.geekbang.org/account/avatar/00/16/87/8a/07ab933c.jpg","nickname":"璀璨星空","note":"","ucode":"CE6324C4261A52","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381178,"discussion_content":"补偿模式是打了引号的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624938987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1243331,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f8/c3/1d557354.jpg","nickname":"o my love","note":"","ucode":"307601ACAC5DCC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292671,"discussion_content":"没太看懂，我感觉你说的count_if的最后一个参数，如果直接多重载一个函数，是不是就没必要使用适配器来适配，本质上是设计上没考虑周全","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595302633,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248995,"user_name":"阿骨打","can_delete":false,"product_type":"c1","uid":2122539,"ip_address":"","ucode":"35EADA5550162A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","comment_is_top":false,"comment_ctime":1600397815,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"126154449399","product_id":100039001,"comment_content":"说实话真的牛，看到51节，争哥的水平估计高于99.9%的码农了，能懂是一层境界，能说给别人听，使别人信服是一层境界，能串联起来说给别人听，又是一层境界。","like_count":30,"discussions":[{"author":{"id":2122539,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","nickname":"阿骨打","note":"","ucode":"35EADA5550162A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306880,"discussion_content":"老千层饼了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600410008,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2051293,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","nickname":"Bumblebee","note":"","ucode":"B879C8A511D08D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2122539,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","nickname":"阿骨打","note":"","ucode":"35EADA5550162A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385654,"discussion_content":"三楼是我","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627197135,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":306880,"ip_address":""},"score":385654,"extra":""}]},{"author":{"id":2051293,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","nickname":"Bumblebee","note":"","ucode":"B879C8A511D08D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385659,"discussion_content":"八楼了爬不动了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627197180,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2051293,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","nickname":"Bumblebee","note":"","ucode":"B879C8A511D08D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385658,"discussion_content":"七楼怎么又是我","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627197173,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2051293,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","nickname":"Bumblebee","note":"","ucode":"B879C8A511D08D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385657,"discussion_content":"六楼也是我","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627197159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2051293,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","nickname":"Bumblebee","note":"","ucode":"B879C8A511D08D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385656,"discussion_content":"五楼还是我","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627197153,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2051293,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","nickname":"Bumblebee","note":"","ucode":"B879C8A511D08D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385655,"discussion_content":"四楼还是我","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627197143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2051293,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","nickname":"Bumblebee","note":"","ucode":"B879C8A511D08D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385653,"discussion_content":"冒充评论很多的样子","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627197125,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182684,"user_name":"勤劳的明酱","can_delete":false,"product_type":"c1","uid":1259140,"ip_address":"","ucode":"05EBE89B80371B","user_header":"https://static001.geekbang.org/account/avatar/00/13/36/84/788f0c60.jpg","comment_is_top":false,"comment_ctime":1582849640,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"78892260968","product_id":100039001,"comment_content":"那SpringAop是代理模式，主要功能却是增强被代理的类，这不是更符合装饰器模式。","like_count":18,"discussions":[{"author":{"id":1738326,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","nickname":"守拙","note":"","ucode":"F594B2DA3F6D4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281119,"discussion_content":"代理和装饰器的区别在于代理为原始类做业务无关的增强, 装饰器为原始类做业务相关的增强. ","likes_number":28,"is_delete":false,"is_hidden":false,"ctime":1591674837,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1030842,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ba/ba/83de3488.jpg","nickname":"Carter","note":"","ucode":"1FD476D8F2BE27","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368199,"discussion_content":"Spring AOP一般是增加与原方法的功能无关的功能，比如打印日志、权限控制、限流等。而且使用者一般不选择是否使用代理附加的功能；而装饰器模式中，由使用者选择是否给原方法增强功能。所以Spring AOP是代理模式，我是这样子理解的。","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1618595503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1570088,"avatar":"https://static001.geekbang.org/account/avatar/00/17/f5/28/898a6947.jpg","nickname":"deepz","note":"","ucode":"4BD23A44CDB384","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1030842,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ba/ba/83de3488.jpg","nickname":"Carter","note":"","ucode":"1FD476D8F2BE27","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379519,"discussion_content":"你这个说法让我貌似分的清代理和装饰了 -.-","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623937515,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":368199,"ip_address":""},"score":379519,"extra":""}]},{"author":{"id":1700607,"avatar":"https://static001.geekbang.org/account/avatar/00/19/f2/ff/efea501e.jpg","nickname":"风不会停息 。","note":"","ucode":"A7806203EAC6A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":270016,"discussion_content":"个人理解。代理模式，父类对象在声明之后，可以利用多态，调用子类中的方法，使这个对象的功能层层增强；代理模式，是为了在不耦合主业务情况下，加入其他逻辑(比如验证)，通过组合的形式，对主业务类中的方法进行封装。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589974613,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1463740,"avatar":"https://static001.geekbang.org/account/avatar/00/16/55/bc/fad0090b.jpg","nickname":"Yeyw","note":"","ucode":"C9D20DB91C3BE5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360991,"discussion_content":"没有好好听课","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616575758,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1212912,"avatar":"https://static001.geekbang.org/account/avatar/00/12/81/f0/695ca05f.jpg","nickname":"Ifdevil","note":"","ucode":"79DB0ADE9AD082","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":262505,"discussion_content":"个人感觉代理模式更合适，因为代理模式更靠近类级别，而装饰器靠近对象级别","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589108040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188975,"user_name":"honnkyou","can_delete":false,"product_type":"c1","uid":1026608,"ip_address":"","ucode":"FD5EC4120EE803","user_header":"https://static001.geekbang.org/account/avatar/00/0f/aa/30/acc91f01.jpg","comment_is_top":false,"comment_ctime":1584440737,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"70303917473","product_id":100039001,"comment_content":"1 中的代码ITarget应该是接口吧","like_count":16,"discussions":[{"author":{"id":1144725,"avatar":"https://static001.geekbang.org/account/avatar/00/11/77/95/9d32e68c.jpg","nickname":"风絮1994","note":"","ucode":"FEB562DECA5E77","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":406454,"discussion_content":"对 应该是接口","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634777430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182802,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1582868607,"is_pvip":false,"discussion_count":1,"race_medal":1,"score":"44532541567","product_id":100039001,"comment_content":"代理模式有两种实现方式<br>1.代理类和原始类实现相同的接口，原始类只负责原始的业务功能，而代理类通过委托的方式调用原始类来执行业务逻辑，然后可以做一些附加功能。这也是一种基于接口而实现编程的设计思想。这就是基于组合也就是对象模式<br>2.如果原始类没有定义接口且不是我们开发维护的，这属于对外部类的扩展，可以使用继承的方式，只需要用代理类继承原始类，然后附加一些功能。这就是基于类模式<br><br>装饰者模式主要解决的问题就是继承关系过于复杂，通过组合来代替继承，主要作用是给原始类添加增强功能。所以装饰者模式只有对象模式","like_count":10},{"had_liked":false,"id":183018,"user_name":"f","can_delete":false,"product_type":"c1","uid":1396147,"ip_address":"","ucode":"686BD6C21FE02B","user_header":"https://static001.geekbang.org/account/avatar/00/15/4d/b3/85828cc4.jpg","comment_is_top":false,"comment_ctime":1582912811,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35942651179","product_id":100039001,"comment_content":"真的是好文章，讲出了别人讲不出的设计，看了很多遍理解了，但是想要融会贯通不是件容易的事，需要多实践，我需要反复看这边文章来思考这5种场景的实践，这次阅读的理解就是场景二可以指导框架设计，我们只要实现新的过滤器，add，就可以不修改源码来实现新的过滤，简直太棒了","like_count":8},{"had_liked":false,"id":251419,"user_name":"图灵机","can_delete":false,"product_type":"c1","uid":2034632,"ip_address":"","ucode":"EB02DB653AD591","user_header":"https://static001.geekbang.org/account/avatar/00/1f/0b/c8/15f055d3.jpg","comment_is_top":false,"comment_ctime":1601540256,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"23076376736","product_id":100039001,"comment_content":" FutureTask 里的RunnableAdapter实现了适配器模式","like_count":5},{"had_liked":false,"id":262748,"user_name":"Laughing","can_delete":false,"product_type":"c1","uid":1002134,"ip_address":"","ucode":"F68F1E000CA800","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/96/99466a06.jpg","comment_is_top":false,"comment_ctime":1605836151,"is_pvip":false,"replies":[{"id":"96121","content":"嗯嗯","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606700927,"ip_address":"","comment_id":262748,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14490738039","product_id":100039001,"comment_content":"1. 代理模式中，委托类的实现基本上就是类代理的模式<br>2. 装饰器模式本身为了解决继承太深的问题，所以没有类装饰器的模式","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509955,"discussion_content":"嗯嗯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700927,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187379,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1584095669,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14468997557","product_id":100039001,"comment_content":"代理、桥接、装饰器、适配器，这 4 种模式是比较常用的结构型设计模式。<br>记得桥接模式那节说桥接械不常用，熟悉即可。现在这边说成了常用了。","like_count":3,"discussions":[{"author":{"id":2282974,"avatar":"https://static001.geekbang.org/account/avatar/00/22/d5/de/f9a465ab.jpg","nickname":"成长型思维","note":"","ucode":"2FCE2C05FFCC83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327248,"discussion_content":"哈哈 自己打脸自己","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605774865,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182775,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1582863990,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14467765878","product_id":100039001,"comment_content":"代理模式：让代理类继承原始类就是类代理模式。不继承则是就是对象代理模式。<br><br>装饰器模式：装饰器模式主要解决继承关系过于复杂的问题，所以不适合用类装饰器模式。","like_count":3},{"had_liked":false,"id":212534,"user_name":"zhengyu.nie","can_delete":false,"product_type":"c1","uid":1541669,"ip_address":"","ucode":"FFE0377D323E46","user_header":"https://static001.geekbang.org/account/avatar/00/17/86/25/25ded6c3.jpg","comment_is_top":false,"comment_ctime":1588143179,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10178077771","product_id":100039001,"comment_content":"在DDD领域驱动中延伸的六边形架构，就是Adaptor模式吧。<br>所有的中间件、组件输入输出都Adapt一下，可以看作包了一层签名。","like_count":2},{"had_liked":false,"id":208317,"user_name":"王钰淇","can_delete":false,"product_type":"c1","uid":1061163,"ip_address":"","ucode":"3160E0F04909E6","user_header":"https://static001.geekbang.org/account/avatar/00/10/31/2b/d2b4336e.jpg","comment_is_top":false,"comment_ctime":1587339769,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10177274361","product_id":100039001,"comment_content":"我觉得适配器模式还有一个很重要的作用是用来隔离影响，使适配器关联的两个类可以独立发展，影响仅局限在变化的类和适配器本身，另外一个类不需要关心。","like_count":2,"discussions":[{"author":{"id":1589947,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXKSvfaeicog2Ficx4W3pNeA1KRLOS7iaFy2uoxCDoYpGkGnP6KPGecKia6Dr3MtCkNGpHxAzmTMd0LA/132","nickname":"Geek_East","note":"","ucode":"A1A7CBF9B8FB2D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543640,"discussion_content":"是事后补救类型的隔离影响。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641256668,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2152306,"avatar":"https://static001.geekbang.org/account/avatar/00/20/d7/72/cbef720d.jpg","nickname":"鲁鸣","note":"","ucode":"974BA3C3E64630","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305638,"discussion_content":"桥接模式是你说的这个目的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600043846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186833,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1583936050,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10173870642","product_id":100039001,"comment_content":"设计模式_51<br># 作业<br>- 代理模式可以使用继承或组合，可根据场景选择；<br>- 装饰器模式只能使用组合，因为它的初衷是避免继承爆炸。<br><br># 感想<br>看了第一个例子，我产生了一个疑问：<br>```<br>class Adaptee{<br>\tvoid funA(){}<br>}<br><br>interface ITarget {<br>\tvoid funA();<br>}<br><br>class Adapter extends Adaptee implements ITarget{}<br>```<br>这时，是使用Adaptee的funA()实现了ITarget的funA()方法吗？<br>这么写会有问题吗？<br><br>带着疑问亲自写了一遍，发现还真的是这样，课程内容有一次覆盖到了我没思考过的区域。","like_count":2,"discussions":[{"author":{"id":1577210,"avatar":"https://static001.geekbang.org/account/avatar/00/18/10/fa/d977627e.jpg","nickname":"刘大人","note":"","ucode":"F66AE613E80398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346243,"discussion_content":"先继承A 再实现B，可能是在适当的情况下使用继承A的方法实现B的实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611892435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290034,"discussion_content":"方法同名所以隐式的实现了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594307469,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182719,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1582855765,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10172790357","product_id":100039001,"comment_content":"课堂讨论<br><br>今天我们讲到，适配器有两种实现方式：类适配器、对象适配器。那我们之前讲到的代理模式、装饰器模式，是否也同样可以有两种实现方式（类代理模式、对象代理模式，以及类装饰器模式、对象装饰器模式）呢？<br><br><br><br>代理模式可以使用类代理模式的方式实现. 考虑到代理模式封装对象及控制访问的职责, 类代理模式并不能很好的适用.<br><br><br><br>装饰器模式可以使用类装饰器模式方式实现. 但会导致继承层次不可控制的严重缺陷. 极度不推荐使用此实现方式. 基于对象装饰器模式的实现可以多个装饰器间互相包裹, 这是类装饰器模式无法实现的.","like_count":2},{"had_liked":false,"id":285833,"user_name":"mqray","can_delete":false,"product_type":"c1","uid":1336634,"ip_address":"","ucode":"15664507AD7033","user_header":"https://static001.geekbang.org/account/avatar/00/14/65/3a/bc801fb2.jpg","comment_is_top":false,"comment_ctime":1617026761,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5911994057","product_id":100039001,"comment_content":"最典型的就是Thread接口中只支持Runnable而不支持Callable 通过FutureTask适配","like_count":1},{"had_liked":false,"id":197588,"user_name":"change","can_delete":false,"product_type":"c1","uid":1110876,"ip_address":"","ucode":"D78B4B3752B6FE","user_header":"https://static001.geekbang.org/account/avatar/00/10/f3/5c/8704e784.jpg","comment_is_top":false,"comment_ctime":1585386789,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"5880354085","product_id":100039001,"comment_content":"原理与实现<br>1、设计意图:为了本来不兼容的接口转换为可兼容的接口(举例:USB转接头);<br>2、两种实现方式:类适配器(通过继承关系来调用不兼容接口的功能)、对象适配器(通过组合关系实现,即把不兼容接口当作成员变量,进而调用其不兼容接口的功能);<br>3、两种实现的选择标准:需要适配的接口个数(个数不多,两个方式都可以)和目标接口与不兼容接口的契合程度(两者接口定义大部分都差不多,则用类适配器,代码量会少一些,反之用对象适配器);<br>应用场景<br>1、封装有缺陷的设计接口;<br>2、统一多个类的接口设计;<br>3、替换依赖的外部系统;<br>4、兼容老版本的接口;<br>5、适配不同格式的数据;<br>对比<br>1、代理模式:在不改变原始类接口的情况下,为其定义一个代理类,主要目的是为了控制访问,而不是加强功能;<br>2、装饰器模式:在不改变原始类接口的情况下,对原始类进行功能增强,并支持多个装饰器的嵌套使用;<br>3、桥接模式:将接口和实现部分分离,让它们较为容易、较为独立的进行变化;<br>4、适配器模式:提供与原始类不同的接口,核心功能还是在原始类中;","like_count":1},{"had_liked":false,"id":352010,"user_name":"Mister.张","can_delete":false,"product_type":"c1","uid":2956550,"ip_address":"","ucode":"2DA655DC15EABC","user_header":"https://static001.geekbang.org/account/avatar/00/2d/1d/06/9ee42a30.jpg","comment_is_top":false,"comment_ctime":1658324589,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658324589","product_id":100039001,"comment_content":"粗略的理解四个模式区别:<br>代理模式    –前置 控制<br>桥接模式    –中部 分离关注点<br>装饰器模式 –后置 增强功能<br>适配器模式 –前中后的补漏","like_count":0},{"had_liked":false,"id":346880,"user_name":"Geek_7e0e83","can_delete":false,"product_type":"c1","uid":2142423,"ip_address":"","ucode":"554DEE2AAAE33C","user_header":"","comment_is_top":false,"comment_ctime":1653490790,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653490790","product_id":100039001,"comment_content":"代理模式有类代理和对象代理，一种是继承类来实现，另一种是组合对象来实现。<br>装饰器模式就只有对象装饰器，因为装饰器模式主要解决的问题之一就是避免继承过多带来的类数量的膨胀问题。通过组合的方式，降低类的数量。","like_count":0},{"had_liked":false,"id":339174,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1647956901,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1647956901","product_id":100039001,"comment_content":"一般来讲如果是对外提供新接口，使用旧系统组件的场景，组合会更好点。后面替换的时候直接替换掉旧系统的组件就可以了。如果是继承还需要修改父类。","like_count":0},{"had_liked":false,"id":336233,"user_name":"斗斗","can_delete":false,"product_type":"c1","uid":2207985,"ip_address":"","ucode":"1178E2D17EFD19","user_header":"https://static001.geekbang.org/account/avatar/00/21/b0/f1/6d225d82.jpg","comment_is_top":false,"comment_ctime":1646019553,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646019553","product_id":100039001,"comment_content":"“假设我们的系统要对用户输入的文本内容做敏感词过滤，为了提高过滤的召回率，我们引入了多款第三方敏感词过滤系统，依次对用户输入的内容进行过滤”。 召回率是怎么提高的，没太懂这句话。","like_count":0},{"had_liked":false,"id":329051,"user_name":"逗你玩😄","can_delete":false,"product_type":"c1","uid":1030242,"ip_address":"","ucode":"2E6309586B0363","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b8/62/60937bbd.jpg","comment_is_top":false,"comment_ctime":1641082462,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641082462","product_id":100039001,"comment_content":"这个是第一次听懂了四种","like_count":0},{"had_liked":false,"id":327170,"user_name":"子房","can_delete":false,"product_type":"c1","uid":1438860,"ip_address":"","ucode":"CB05938C248BB3","user_header":"https://static001.geekbang.org/account/avatar/00/15/f4/8c/0866b228.jpg","comment_is_top":false,"comment_ctime":1639967139,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639967139","product_id":100039001,"comment_content":"spring bean的aop代理就是对象代理","like_count":0},{"had_liked":false,"id":325930,"user_name":"HomeyLiu","can_delete":false,"product_type":"c1","uid":1330141,"ip_address":"","ucode":"EF4CCB92C369B4","user_header":"https://static001.geekbang.org/account/avatar/00/14/4b/dd/41614582.jpg","comment_is_top":false,"comment_ctime":1639238370,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639238370","product_id":100039001,"comment_content":"不得不佩服 王争的内功深厚,很牛逼! ","like_count":0},{"had_liked":false,"id":325000,"user_name":"承香墨影","can_delete":false,"product_type":"c1","uid":1023750,"ip_address":"","ucode":"4D6A4D6E1ED29F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9f/06/287d77dd.jpg","comment_is_top":false,"comment_ctime":1638776369,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638776369","product_id":100039001,"comment_content":"太多的适配器是不会也会导致代码不易读？其实就是为原本的设计缺陷打不定，那这种问题是不是应该在重构的时候消除？","like_count":0},{"had_liked":false,"id":317859,"user_name":"Geek_32cca0","can_delete":false,"product_type":"c1","uid":2743957,"ip_address":"","ucode":"A24204F2C0485E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJF8vUICSb6yEleDjtsTe8OrwqmpaoxlicHB7NutCwMMs5ZvsQrguEJ3VL0x5I85jS6xlbrWcMdWKA/132","comment_is_top":false,"comment_ctime":1634996335,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634996335","product_id":100039001,"comment_content":"讲清楚了这四种模式","like_count":0},{"had_liked":false,"id":317053,"user_name":"makermade","can_delete":false,"product_type":"c1","uid":1133194,"ip_address":"","ucode":"03386B90CB8F20","user_header":"https://static001.geekbang.org/account/avatar/00/11/4a/8a/c1069412.jpg","comment_is_top":false,"comment_ctime":1634651376,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634651376","product_id":100039001,"comment_content":"敏感词过滤，客户端代码，遍历调用过滤器的地方，是不是有点问题","like_count":0},{"had_liked":false,"id":314690,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1633328931,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1633328931","product_id":100039001,"comment_content":"关键看最终的能力是以继承还是组合的形式提供。<br>代理模式可以有类及对象代理模式。<br>但装饰者最终能力如果是通过继承，意味着多种能力增强就需要不断的去通过继承解决，这样类就会越来越多，达不到装饰者本身要解决的类暴炸过多问题。","like_count":0},{"had_liked":false,"id":311843,"user_name":"Null","can_delete":false,"product_type":"c1","uid":1049235,"ip_address":"","ucode":"D48077EBAD2E87","user_header":"https://static001.geekbang.org/account/avatar/00/10/02/93/fed4baec.jpg","comment_is_top":false,"comment_ctime":1631502253,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631502253","product_id":100039001,"comment_content":"看了大家的评论，对于代理模式既能使用类代理也能使用对象代理基本是没有争议的，而对于装饰器模式是否能采用类装饰器模式争议比较大，我认为是不可以的。主要原因是装饰器模式有个重要特点，可以支持嵌套使用，实现的功能类似于多重继承，而大多数语言都是不支持多重继承的。","like_count":0},{"had_liked":false,"id":307500,"user_name":"The-Jogger","can_delete":false,"product_type":"c1","uid":1396612,"ip_address":"","ucode":"4F19CA3DFA88E3","user_header":"https://static001.geekbang.org/account/avatar/00/15/4f/84/8b3b6a55.jpg","comment_is_top":false,"comment_ctime":1629125385,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629125385","product_id":100039001,"comment_content":"Java SPI 实际上是“基于接口的编程＋策略模式＋配置文件”组合实现的动态加载机制","like_count":0},{"had_liked":false,"id":306166,"user_name":"乔帆 Kayla","can_delete":false,"product_type":"c1","uid":1883514,"ip_address":"","ucode":"81944832230BC4","user_header":"https://static001.geekbang.org/account/avatar/00/1c/bd/7a/37df606b.jpg","comment_is_top":false,"comment_ctime":1628413618,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628413618","product_id":100039001,"comment_content":"课堂讨论<br><br>代理模式：如果是动态代理，事先是不知道原始类的，那么代理类也就没办法事先创建。也就没有是组合还是继承这一说了；<br><br>桥接模式：&quot;接口&quot;需要支持各&quot;实现&quot;的独立变化，选择的灵活的*组合*最合适；<br><br>装饰器模式：对功能的增强目前有多种，未来还会有更多种，避免组合爆炸，势必选择基于&quot;*组合*&quot;的方式；为了每个增强类的不做本没必要工作（简单包裹委派），需要一个统一的*父类*把没必要的工作做足；","like_count":0},{"had_liked":false,"id":297356,"user_name":"JKwar","can_delete":false,"product_type":"c1","uid":1047466,"ip_address":"","ucode":"B733CA24D5701F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/aa/01fedf6c.jpg","comment_is_top":false,"comment_ctime":1623478384,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1623478384","product_id":100039001,"comment_content":"代理模式支持，一般情况下，我们让代理类和原始类实现同样的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的。在这种情况下，我们可以通过让代理类继承原始类的方法来实现代理模式。<br>装饰器模式不支持，装饰器模式主要的目的就是为了解决继承类爆炸的问题的。","like_count":0},{"had_liked":false,"id":289816,"user_name":"大方方","can_delete":false,"product_type":"c1","uid":1354013,"ip_address":"","ucode":"621AD8F1485753","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/6cyOoRd2dROgiblAJkW6RLhUyH1wwU0NNibIIuV930eQ9TiaNT41K61kBSVkvYoDYg7mJtuEoCQY1awBmV0WW6BFg/132","comment_is_top":false,"comment_ctime":1619187968,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619187968","product_id":100039001,"comment_content":"二刷这节，看了一些其他例子，感觉适配器如果是以统一API接口为目的的，配上工厂模式，有点类似于策略模式的混合状态了。","like_count":0},{"had_liked":false,"id":288250,"user_name":"Better me","can_delete":false,"product_type":"c1","uid":1261959,"ip_address":"","ucode":"CADF08D357489A","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","comment_is_top":false,"comment_ctime":1618380805,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1618380805","product_id":100039001,"comment_content":"代理模式：<br>针对是否提供代理接口，类代理模式、对象代理模式两种实现方式都可以<br>装饰器模式：<br>由于类继承组合会造成类数量太多难以维护而且不能灵活组合，所以从设计的角度只有对象装饰器模式","like_count":0},{"had_liked":false,"id":277608,"user_name":"进击的土豆","can_delete":false,"product_type":"c1","uid":1948043,"ip_address":"","ucode":"52249892A6C203","user_header":"https://static001.geekbang.org/account/avatar/00/1d/b9/8b/d0763d9a.jpg","comment_is_top":false,"comment_ctime":1612490940,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1612490940","product_id":100039001,"comment_content":"争哥，代理、桥接、装饰器、适配器代码结构相似,不太理解 桥接 和其他三种模式的相似之处，感觉差别挺大的呀？","like_count":0},{"had_liked":false,"id":269964,"user_name":"郑大钱","can_delete":false,"product_type":"c1","uid":1503067,"ip_address":"","ucode":"114CF48056880E","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/5b/ff28088f.jpg","comment_is_top":false,"comment_ctime":1608863987,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608863987","product_id":100039001,"comment_content":"哈哈，我对日志上报和分享的理解是正确的，它们就是适配器。<br>不经意间用过适配器模式，对适配器模式的理解更深入。本来期待能分清代理、桥接和装饰有什么区别，但整篇文章看下来觉得没有什么共鸣，今后真正用到的时候再回头来看吧，现在憋出来的分类也可能是一厢情愿。","like_count":0},{"had_liked":false,"id":267296,"user_name":"淤白","can_delete":false,"product_type":"c1","uid":1206503,"ip_address":"","ucode":"D1E65DC40DAF68","user_header":"https://static001.geekbang.org/account/avatar/00/12/68/e7/ee47d0e2.jpg","comment_is_top":false,"comment_ctime":1607673212,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607673212","product_id":100039001,"comment_content":"打卡：个人喜好，主要去了解了一下SPI技术。<br>再去看的slf4j，不过看源码，slf4j貌似并不是用的这个：<br>在使用日志的时候，LoggerFactory.getILoggerFactory()中，通过StaticLoggerBinder获取具体工厂，而StaticLoggerBinder其实是在不同的实现jar包中的（logback，log4j）。那是不是意味着，其实在JVM中加载了哪个包中的类，自然也就用的那种实现。","like_count":0},{"had_liked":false,"id":251116,"user_name":"茶没喝完","can_delete":false,"product_type":"c1","uid":1644104,"ip_address":"","ucode":"D72D88C42A1258","user_header":"https://static001.geekbang.org/account/avatar/00/19/16/48/09493874.jpg","comment_is_top":false,"comment_ctime":1601367866,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601367866","product_id":100039001,"comment_content":"老师是真的牛啊，讲的太好了。","like_count":0},{"had_liked":false,"id":243771,"user_name":"talkyoung","can_delete":false,"product_type":"c1","uid":1613665,"ip_address":"","ucode":"8D231FA9004B64","user_header":"https://static001.geekbang.org/account/avatar/00/18/9f/61/c46b42f4.jpg","comment_is_top":false,"comment_ctime":1598271482,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598271482","product_id":100039001,"comment_content":"如果依赖的外部系统A没有实现自某个接口，没有任何继承关系，那么适配器通过组合+继承的方式可以吗？","like_count":0},{"had_liked":false,"id":239877,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1596682547,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1596682547","product_id":100039001,"comment_content":"桥接模式不一定实现同样的接口吧。我的理解","like_count":0,"discussions":[{"author":{"id":1206229,"avatar":"https://static001.geekbang.org/account/avatar/00/12/67/d5/1b26b725.jpg","nickname":"Gopher","note":"","ucode":"3C1F9012BB486D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311563,"discussion_content":"确实是不一定，只是一种设计指导，哪怕在一个函数外面包一层来适配新的调用，这个也是适配器模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602402239,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235367,"user_name":"Varus","can_delete":false,"product_type":"c1","uid":1715988,"ip_address":"","ucode":"B9CB88C248BD93","user_header":"https://static001.geekbang.org/account/avatar/00/1a/2f/14/840d0925.jpg","comment_is_top":false,"comment_ctime":1594984941,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594984941","product_id":100039001,"comment_content":"真就表面工程","like_count":0},{"had_liked":false,"id":235366,"user_name":"Varus","can_delete":false,"product_type":"c1","uid":1715988,"ip_address":"","ucode":"B9CB88C248BD93","user_header":"https://static001.geekbang.org/account/avatar/00/1a/2f/14/840d0925.jpg","comment_is_top":false,"comment_ctime":1594984913,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594984913","product_id":100039001,"comment_content":"适配器模式像是套娃，但是里面东西不一样","like_count":0},{"had_liked":false,"id":234603,"user_name":"Obed","can_delete":false,"product_type":"c1","uid":1399904,"ip_address":"","ucode":"8717488DD14AB4","user_header":"https://static001.geekbang.org/account/avatar/00/15/5c/60/3754399d.jpg","comment_is_top":false,"comment_ctime":1594730880,"is_pvip":false,"replies":[{"id":"86608","content":"有可能是我理解错了，我再去核实一下，多谢指出！","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1594781114,"ip_address":"","comment_id":234603,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1594730880","product_id":100039001,"comment_content":"王争老师 今天学习了这篇文章，你说slf4j会使用spi的技术动态指定具体使用哪一种框架。然后我查了一下资料，看了自己项目关于日志的源码。slf4j好像是指定了org.slf4j.impl这个包。然后在LoggerFactory.getLogger()的时候在去扫描实现了slf4j接口的日志的这个指定包去加载对应的类。这跟java的spi好像不大一样。还是说其实这种实现跟spi的思想都是一样的","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501437,"discussion_content":"有可能是我理解错了，我再去核实一下，多谢指出！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594781114,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":232629,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1594053738,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594053738","product_id":100039001,"comment_content":"适配器模式用来解决类似敏感词过滤的问题，非常好用<br>","like_count":0},{"had_liked":false,"id":230672,"user_name":"maybe","can_delete":false,"product_type":"c1","uid":1475528,"ip_address":"","ucode":"93D160F617E750","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/c8/5ce842f6.jpg","comment_is_top":false,"comment_ctime":1593445270,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1593445270","product_id":100039001,"comment_content":"1、代理模式有类代理、对象代理。原始类没有定义接口，通过继承方式实现代理模式，这就是类代理。如果原始类定义了接口，通过组合模式实现代理模式，更加灵活，属于对象代理。<br>2、装饰器模式要解决继承而导致类数量爆炸，通过组合的方式实现，所以没有类装饰器，只有对象装饰器","like_count":0},{"had_liked":false,"id":226364,"user_name":"蹦哒","can_delete":false,"product_type":"c1","uid":1458931,"ip_address":"","ucode":"56591A657DE7C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epcs6PibsP9vEXv4EibUw3bhQPUK04zRTOvfrvF08TwM67xPb1LBh2uRENHQwo2VqYfC5GhJmM7icxHA/132","comment_is_top":false,"comment_ctime":1592047898,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592047898","product_id":100039001,"comment_content":"我认为都是可以基于继承或者组合实现的，具体用继承还是组合，取决于类之间关系是否稳定且层次浅<br><br>实际上，iOS开发中，系统框架中的代理模式，很多都是基于组合实现的","like_count":0},{"had_liked":false,"id":226118,"user_name":"宁悦","can_delete":false,"product_type":"c1","uid":1901403,"ip_address":"","ucode":"68844C314FEEF8","user_header":"https://static001.geekbang.org/account/avatar/00/1d/03/5b/3cdbc9fa.jpg","comment_is_top":false,"comment_ctime":1591953923,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591953923","product_id":100039001,"comment_content":"这个总结赞！","like_count":0},{"had_liked":false,"id":220649,"user_name":"炫炫","can_delete":false,"product_type":"c1","uid":1358609,"ip_address":"","ucode":"FDC7A0C6E08B02","user_header":"https://static001.geekbang.org/account/avatar/00/14/bb/11/7069b8eb.jpg","comment_is_top":false,"comment_ctime":1590303746,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590303746","product_id":100039001,"comment_content":"知其然知其所以然，然后灵活运用之，则学以致用，融会一通。赞👍","like_count":0},{"had_liked":false,"id":220067,"user_name":"有爱有波哥","can_delete":false,"product_type":"c1","uid":1464493,"ip_address":"","ucode":"DD9A023563151F","user_header":"https://static001.geekbang.org/account/avatar/00/16/58/ad/6abb57c4.jpg","comment_is_top":false,"comment_ctime":1590146904,"is_pvip":false,"replies":[{"id":"86623","content":"不是接口~","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1594783513,"ip_address":"","comment_id":220067,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590146904","product_id":100039001,"comment_content":"CD 实现代码不是接口是具体的方法吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496034,"discussion_content":"不是接口~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594783513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219534,"user_name":"jaryoung","can_delete":false,"product_type":"c1","uid":1077406,"ip_address":"","ucode":"6E72D107DB7E51","user_header":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","comment_is_top":false,"comment_ctime":1590037371,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590037371","product_id":100039001,"comment_content":"类适配器使用继承关系来实现，对象适配器使用组合关系来实现。<br>代理模式，类代理模式让我想到Java中jdk原生代理的实现。对象代理模式，让我先到Cglib的动态代理。","like_count":0},{"had_liked":false,"id":212884,"user_name":"慕容引刀","can_delete":false,"product_type":"c1","uid":1016308,"ip_address":"","ucode":"714E94AEB42D7D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/81/f4/d92c7ef5.jpg","comment_is_top":false,"comment_ctime":1588231457,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588231457","product_id":100039001,"comment_content":"在工作中使用过类似的实现方式，看完老师的课才知道使用了适配器模式🤣<br>用户提交内容后，有各种校验规则，规则之间互不相关，旧的代码实现就是if else.....<br>优化方式，定义统一校验接口，各规则各自实现校验接口并注册到校验规则列表中","like_count":0},{"had_liked":false,"id":200749,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1585646060,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585646060","product_id":100039001,"comment_content":"这篇信息量太大了！","like_count":0},{"had_liked":false,"id":195513,"user_name":"不能忍的地精","can_delete":false,"product_type":"c1","uid":1754913,"ip_address":"","ucode":"66A921C0BC8102","user_header":"","comment_is_top":false,"comment_ctime":1585192840,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585192840","product_id":100039001,"comment_content":"没有<br>代理有子类代理和接口代理<br>装饰模式是对被装饰对象的方法增强,如果是用继承,就不是对被装饰对象增强了,是增强自己","like_count":0},{"had_liked":false,"id":190985,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1584715872,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1584715872","product_id":100039001,"comment_content":"突然醒悟工作中经常封装的三方接口其实就是适配器模式，以前太局限于概念了","like_count":0,"discussions":[{"author":{"id":1254656,"avatar":"https://static001.geekbang.org/account/avatar/00/13/25/00/3afbab43.jpg","nickname":"88591","note":"","ucode":"04CE3E46455185","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212096,"discussion_content":"无招胜有招","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584933976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":189782,"user_name":"Geek_3b1096","can_delete":false,"product_type":"c1","uid":1549364,"ip_address":"","ucode":"A6BD92B79B3632","user_header":"","comment_is_top":false,"comment_ctime":1584548714,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584548714","product_id":100039001,"comment_content":"这篇总结很受用","like_count":0},{"had_liked":false,"id":186629,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1583893507,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583893507","product_id":100039001,"comment_content":"对于代理模式,JDK的实现方式就依赖于接口,其本质上就是去创建一个子类,在需要实现的接口,都是委托父类的实现方法<br>对于装饰器模式,是为了解决由于组合多种类,导致组合类的数量爆炸式增长,而产生的,如果通过委托父类来执行,一是导致没法减少组合类的数量,二是如果使用了继承父类 那么有些实现类中的独有特性,增强后的功能的红利没法去很好的使用<br>","like_count":0},{"had_liked":false,"id":185007,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1583465096,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583465096","product_id":100039001,"comment_content":"今日总结<br>1. 适配器模式解决什么问题<br>    解决接口设计缺陷<br>2. 怎么解决？<br>    通过对目标类进行封装 实现接口对应的<br>    2.1 类适配器<br>         通过继承原目标方式进行 实现对应的接口的定义 满足接口需求 适用场景 目标类和接口类 方法大部分相同 可以采用继承 减少代码量<br>    2.2 对象适配器<br>         通过组合方式对原目标进行分组实现对应的接口定义 满足接口需求 适用场景目标类和接口类方法大不相同的场景<br>    2.3 当原目标或者接口类方法比较少时 两种都可以<br>3. 适配器模式使用举例<br>   3.1 解决接口设计缺陷<br>   3.2 兼容新老版本(文中迭代器iterator的更新迭代)<br>   3.3 替换外部依赖(比如mysql换到mongoDB)<br>   3.4 依赖注入框架 比如我在项目中 注入每个逻辑的AI<br>思考题<br> 我觉得还是要从 代理模式、装饰器模式解决什么问题入手<br>1. 代理模式 主要是外部增加功能或者控制访问权限 对目标类未进行修改 其实用组合或者继承都可以<br>2. 装饰器模式 主要是解决继承过于复杂的问题  如果继承层次很浅的话也就没有必要再用装饰器模式 所以最好还是用组合","like_count":0},{"had_liked":false,"id":184831,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1583415320,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1583415320","product_id":100039001,"comment_content":"adaptee：是一组不兼容ITarget接口定义的借口<br>Adapter将Adaptee转换成符合ITarget接口定义的接口。<br><br>适配器：<br>基于继承、基于组合。<br><br>适用场景：<br>1、封装隔离设计上的缺陷<br>2、统一多个类的接口设计<br>3、替换依赖的外部系统<br>4、兼容老版本接口<br>5、适配不同格式数据（Java中的Arrays.asList()，字节流和字符流的转换。）<br><br>Java中的sf4日志框架到其他日志的适配和反向适配，可以实现日志框架间的切换。<br><br>代理模式实现和原有类相同的接口。若没有接口，则继承原始类。<br>装饰者模式继承原有类相同的接口，增强功能，通过组合实现。","like_count":0},{"had_liked":false,"id":184584,"user_name":"123456","can_delete":false,"product_type":"c1","uid":1485820,"ip_address":"","ucode":"9F7C4F3E4416BE","user_header":"https://static001.geekbang.org/account/avatar/00/16/ab/fc/38ccd186.jpg","comment_is_top":false,"comment_ctime":1583366446,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1583366446","product_id":100039001,"comment_content":"争哥，能否在设计模式的讲解上带上类图。那样感觉会好一点","like_count":0,"discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":197257,"discussion_content":"我画了类图，看看对你有没有用？ https://github.com/gdhucoder/DesignPattern ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583415376,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184391,"user_name":"William","can_delete":false,"product_type":"c1","uid":1346215,"ip_address":"","ucode":"55F5D9DEE485B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","comment_is_top":false,"comment_ctime":1583305162,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1583305162","product_id":100039001,"comment_content":"桥接模式的目标是:分离.<br>适配器的目标是:合并.","like_count":0},{"had_liked":false,"id":183743,"user_name":"前端西瓜哥","can_delete":false,"product_type":"c1","uid":1248576,"ip_address":"","ucode":"150130C34CD1C1","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/40/f70e5653.jpg","comment_is_top":false,"comment_ctime":1583124433,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583124433","product_id":100039001,"comment_content":"课堂讨论的思考：<br><br>对于代理模式，一般是通过组合（对应对象代理模式）的方式实现，继承的实现方式是特殊情况（如无法修改的外部类）下不得已才使用的。可以认为有两种实现方式。<br><br>装饰类有点不一样，装饰器类和原始类继承同样的父类。在装饰类初始化时，将原始类依赖注入，且装饰类要重写父类的所有方法。装饰类和原始类只有组合的关系，没有继承的关系。所以说应该是只有对象装饰器模式。","like_count":0},{"had_liked":false,"id":183545,"user_name":"平风造雨","can_delete":false,"product_type":"c1","uid":1014349,"ip_address":"","ucode":"F9EE4704F31E22","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/4d/b0228a1a.jpg","comment_is_top":false,"comment_ctime":1583063241,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1583063241","product_id":100039001,"comment_content":"代理模式使用类代理的目的更明确，大多数场景中代码更少，装饰器模式就是为了解决继承爆炸，并且灵活的选择是否适配，所以装饰器模式默认都应是实例代理。","like_count":0},{"had_liked":false,"id":183428,"user_name":"柏油","can_delete":false,"product_type":"c1","uid":1604468,"ip_address":"","ucode":"92BFEEEE8BBFA0","user_header":"https://static001.geekbang.org/account/avatar/00/18/7b/74/9b88e040.jpg","comment_is_top":false,"comment_ctime":1583038101,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583038101","product_id":100039001,"comment_content":"请问一个类如果需要两种及以上的实现如何做适配呢","like_count":0},{"had_liked":false,"id":183425,"user_name":"bin","can_delete":false,"product_type":"c1","uid":1307082,"ip_address":"","ucode":"EC4F4194082715","user_header":"https://static001.geekbang.org/account/avatar/00/13/f1/ca/9b9b8a7c.jpg","comment_is_top":false,"comment_ctime":1583037151,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583037151","product_id":100039001,"comment_content":"代理模式可以用类代理模式、对象代理模式。<br>装饰器模式可以用对象装饰器模式但不可以用类装饰器模式，因为装饰器模式就是为了避免过多的继承而设计的","like_count":0},{"had_liked":false,"id":183347,"user_name":"相逢是缘","can_delete":false,"product_type":"c1","uid":1060730,"ip_address":"","ucode":"CB299F53A95654","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg","comment_is_top":false,"comment_ctime":1583026089,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583026089","product_id":100039001,"comment_content":"一、定义（理解）：<br>将不兼容的接口转化为兼容的接口，让原本不能在一起工作的类可以在一起工作。<br>（适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷）<br>二、使用场景：<br>1）封装有缺陷的接口（如包含大量的静态的方法，影响测试等）<br>2）通过多个类的接口设计，利用多态性复用业务逻辑<br>3）替换依赖的外部系统（新的接口进行封装，可以按以前的方式调用）<br>4）兼容老版本接口（老版本接口中包装新的接口的功能）<br>5）适配不同的数据格式<br><br>三、实现方式：<br>大部分情况下的实现思路是：定义一个统一的抽象类或是接口（抽象），之后基于不同的原始类，都去实现这个抽象，业务层利用多态进行业务逻辑复用。<br><br>四、 代理、桥接、装饰器、适配器 4 种设计模式的区别<br>这四种模式都是Wrapper 模式，都需要进行二次封装<br>代理模式：不改变原始类，为控制访问（不是加强功能，这个是和装饰器最大的区别）设计一个代理类；<br>桥接模式：将多个维度（接口）进行拆分，各自独立变化，通过对象的组合实现最终需求；<br>装饰器模式：在不改变原始类的情况下，对原始类功能进行增强，并且支持多个装饰器嵌套（典型的JAVA IO）；<br>适配器模式：提供和原始类不同的接口，以做到对业务层接口的兼容。","like_count":0},{"had_liked":false,"id":183287,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1018370,"ip_address":"","ucode":"7A488CC6FE15E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","comment_is_top":false,"comment_ctime":1582987585,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582987585","product_id":100039001,"comment_content":"适配器模式主要用于接口的适配。将源接口适配为符合客户端调用的目标接口。适配器有两种实现方式：类适配器和对象适配器，前者基于继承，后者集合组合。推荐使用后者，因为组合灵活性比较高，例如使用组合可以将多个源接口适配为一个目标接口。","like_count":0},{"had_liked":false,"id":183105,"user_name":"高源","can_delete":false,"product_type":"c1","uid":1048887,"ip_address":"","ucode":"751B41FD38EF7D","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/37/12e4c9c9.jpg","comment_is_top":false,"comment_ctime":1582954063,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582954063","product_id":100039001,"comment_content":"老师讲的好啊，让你明白具体的4个模式的应用和区别，王争老师厉害啊😊要是再把这4个模式用同一个例子分别说明就更好了，这样对于像我这样的需要看代码加深印象的学习者是再好不过了，感谢老师辛勤付出辛苦了","like_count":0},{"had_liked":false,"id":183019,"user_name":"f","can_delete":false,"product_type":"c1","uid":1396147,"ip_address":"","ucode":"686BD6C21FE02B","user_header":"https://static001.geekbang.org/account/avatar/00/15/4d/b3/85828cc4.jpg","comment_is_top":false,"comment_ctime":1582913615,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582913615","product_id":100039001,"comment_content":"我的天啊 值得深思 对着每个字思考使用场景","like_count":0},{"had_liked":false,"id":182861,"user_name":"糖醋排骨","can_delete":false,"product_type":"c1","uid":1620507,"ip_address":"","ucode":"00ED918A220077","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epTx3WM1A1hxjOmtfQNa0QQ01QUlhaaSHrZ3OcnzYibY1gFeNFAcZ7yQpxZsbyk7D9m6JA9X5j44tA/132","comment_is_top":false,"comment_ctime":1582878024,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582878024","product_id":100039001,"comment_content":"是不是第二个敏感词汇过滤的例子也运用了桥接模式？通过组合的方式来进行扩展。求老师解答","like_count":0},{"had_liked":false,"id":182785,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1582865971,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1582865971","product_id":100039001,"comment_content":"实际项目中一直有对外不使用不方便接口的封装，实际用的就是适配器的思想或者说是模式。<br>只是限于对适配器的浅显认知，没有意识到时这种模式的应用，更多的是理解为工具类。<br>醍醐灌顶~","like_count":0},{"had_liked":false,"id":182682,"user_name":"岁月神偷","can_delete":false,"product_type":"c1","uid":1484111,"ip_address":"","ucode":"BA851259EA1F71","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/4f/592d00f2.jpg","comment_is_top":false,"comment_ctime":1582848716,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582848716","product_id":100039001,"comment_content":"我认为装饰器模式不能使用类匹配，类匹配形成了装饰器类与继承类强耦合的关系，本身装饰器是想对实现某一接口的所有实现类提供增强，一旦进行类匹配就变成了这个装饰器只是对某个实现类的增强","like_count":0},{"had_liked":false,"id":182675,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1582848080,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582848080","product_id":100039001,"comment_content":"1、代理模式，扩展非功能需求，如缓存、日志、鉴权等，从业务流程出发，代理类仍然需要暴露和被代理类一样的接口，所以也可以用继承来实现，这样代理类对外接口的数量就完全和被代理类一样了，可以覆盖其中需要扩展非功能需求的方法。这就是类代理模式。<br>  老师的讲解是以对象代理模式进行的，即用组合的方式。<br><br>2、装饰器模式，拓展原功能的某一侧面，如缓存。这里侧面就是某几个方法，增强某几个方法的某些侧面，其余方法不变，所以用继承的方式即使用类适配器比较方便。用对象适配器，即组合方式也可以，但是比较麻烦。","like_count":0},{"had_liked":false,"id":182672,"user_name":"Andy_Ron","can_delete":false,"product_type":"c1","uid":1147385,"ip_address":"","ucode":"A6963B60B326AA","user_header":"https://static001.geekbang.org/account/avatar/00/11/81/f9/3508b638.jpg","comment_is_top":false,"comment_ctime":1582847614,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582847614","product_id":100039001,"comment_content":"好像有点明白了，再看一遍🤓","like_count":0},{"had_liked":false,"id":182661,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1582845464,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582845464","product_id":100039001,"comment_content":"适配器的五种使用场景:<br>封装有缺陷的接口设计<br>统一多个类的接口设计<br>替换依赖的外部系统<br>兼容老版本接口<br>适配不同格式的数据","like_count":0},{"had_liked":false,"id":182657,"user_name":"旭东(Frank)","can_delete":false,"product_type":"c1","uid":1024486,"ip_address":"","ucode":"176FA629800062","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a1/e6/50da1b2d.jpg","comment_is_top":false,"comment_ctime":1582843879,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1582843879","product_id":100039001,"comment_content":"替换外部系统是不是不继承外部接口更好，这样和外部的耦合度更低些，个人认为","like_count":0,"discussions":[{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290041,"discussion_content":"适配的目的就是继承外部接口啊，现有代码用的都是老的外部接口，这样现有代码对外部系统的调用就都不用改了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594308390,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182646,"user_name":"Yayu","can_delete":false,"product_type":"c1","uid":1058015,"ip_address":"","ucode":"5E7842458D8229","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/df/645f8087.jpg","comment_is_top":false,"comment_ctime":1582821906,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582821906","product_id":100039001,"comment_content":"请问老师，如果一门语言里没有继承特性，是不是只能用对象适配器模式了？","like_count":0}]}