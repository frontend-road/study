{"id":167907,"title":"05 | for (let x of [1,2,3]) ...：for循环并不比使用函数递归节省开销","content":"<p>你好，我是周爱民。欢迎回到我的专栏，我将为你揭示JavaScript最为核心的那些实现细节。</p><p>语句，是JavaScript中组织代码的基础语法组件，包括函数声明等等在内的六种声明，其实都被归为“语句”的范畴。因此，如果将一份JavaScript代码中的所有语句抽离掉，那么大概就只会剩下为数不多的、在全局范围内执行的表达式了。</p><p>所以，理解“语句”在JavaScript中的语义是重中之重。</p><p>尽管如此，你实际上要了解的也无非是<strong>顺序</strong>、<strong>分支</strong>、<strong>循环</strong>这三种执行逻辑而已，相比于它们，其它语句在语义上的复杂性通常不值一提。而这三种逻辑中尤其复杂的就是<span class=\"orange\">循环</span>，今天的这一讲，我就来给你讲讲它。</p><h2>块</h2><p>在ECMAScript 6之后，JavaScript实现了<strong>块级作用域</strong>。因此，现在绝大多数语句都基于这一作用域的概念来实现。近乎想当然的，几乎所有开发者都认为一个JavaScript语句就有一个自己的块级作用域。这看起来很好理解，因为这样处理是典型的、显而易见的<strong>代码分块的结果</strong>。</p><p>然而，事实上正好相反。</p><p>真正的状况是，<strong>绝大多数JavaScript语句都并没有自己的块级作用域</strong>。从语言设计的原则上来看，越少作用域的执行环境调度效率也就越高，执行时的性能也就越好。</p><!-- [[[read_end]]] --><p>基于这个原则，<code>switch</code>语句被设计为有且仅有一个作用域，无论它有多少个case语句，其实都是运行在一个块级作用域环境中的。例如：</p><pre><code>var x = 100, c = 'a';\nswitch (c) {\n  case 'a': \n    console.log(x); // ReferenceError\n    break;\n  case 'b':\n    let x = 200;\n    break;\n}\n</code></pre><p>在这个例子中，switch语句内是无法访问到外部变量<code>x</code>的，即便声明变量<code>x</code>的分支<code>case 'b'</code>永远都执行不到。这是因为所有分支都处在同一个块级作用域中，所以任意分支的声明都会给该作用域添加这个标识符，从而覆盖了全局的变量<code>x</code>。</p><p>一些简单的、显而易见的块级作用域包括：</p><pre><code>// 例1\ntry {\n  // 作用域1\n}\ncatch (e) { // 表达式e位于作用域2\n  // 作用域2\n}\nfinally {\n  // 作用域3\n}\n\n// 例2\n//（注：没有使用大括号）\nwith (x) /* 作用域1 */; // &lt;- 这里存在一个块级作用域\n\n// 例3, 块语句\n{\n  // 作用域1\n</code></pre><p>除了这三个语句和“<strong>一个特例</strong>”之外，所有其它的语句都是没有块级作用域的。例如<code>if</code>条件语句的几种常见书写形式：</p><pre><code>if (x) {\n  ...\n}\n\n// or\nif (x) {\n  ...\n}\nelse {\n  ...\n}\n}\n</code></pre><p>这些语法中的“块级作用域”都是一对大括号表示的“块语句”自带的，与上面的“例3”是一样的，而与<code>if</code>语句本身无关。</p><p>那么，这所谓的“一个特例”是什么呢？这个特例，就是今天这一讲标题中的<code>for</code>循环。</p><h2>循环语句中的块</h2><p>并不是所有的循环语句都有自己的块级作用域，例如while和do..while语句就没有。而且，也不是所有for语句都有块级作用域。在JavaScript中，有且仅有：</p><blockquote>\n<p>for (<em>&lt;let/const&gt;</em> ...) ...</p>\n</blockquote><p>这个语法有自己的块级作用域。当然，这也包括相同设计的<code>for await</code>和<code>for .. of/in ..</code>。例如：</p><blockquote>\n<p>for await (<em>&lt;let/const&gt;</em> x of ...) ...<br>\nfor (<em>&lt;let/const&gt;</em> x ... in ...) ...<br>\nfor (<em>&lt;let/const&gt;</em> x ... of ...) ...</p>\n</blockquote><p>等等。你应该已经注意到了，这里并没有按照惯例那样列出“var”关键字。关于这一点，后面写到的时候我也会再次提及到。就现在来说，你可能需要关心的问题是：<strong>为什么这是个特例？</strong>以及，<strong>如果它是拥有自己的块级作用域的特例，那么它有多少个块级作用域呢？</strong></p><p>后面这个问题的答案，是：“说不准”。</p><p>看起来，我是被JavaScript的古怪设计击败了。我居然给出了这么一个显而易见是在糊弄大众的答案！但是要知道，所谓的“块级作用域”有两种形式，一种是静态的词法作用域，这对于上面的for语句来说，它们都只有两个块级作用域。但是对于另一种动态的、“块级作用域”的实例来说，这答案就真的是“说不准”了。</p><p>不过，先放下这个，我接下来先给你解释一下“<strong>为什么这里需要一个特例</strong>”。</p><h2>特例</h2><p>除了语句的关键字和语法结构本身之外，语句中可以包括什么呢？</p><p>如果你归纳一下语句中可以包含的全部内容，你应该可以看到一个简单的结果：所有在语句内可以存在的东西只有四种：表达式、其它语句、标识符声明（取决于声明语句或其它的隐式声明的方式），以及一种特殊的语法元素，称为“标签（例如标签化语句，或break语句指向的目标位置）”。</p><p>所谓“块级作用域”，本质上只包括一组标识符。因此，只有当存在潜在标识符冲突的时候，才有必要新添加一个作用域来管理它们。例如函数，由于函数存在“重新进入”的问题，所以它必须有一个作用域来管理“重新进入之前”的那些标识符。这个东西想必你是听说过的，它被称为“<strong>闭包</strong>”。</p><blockquote>\n<p>NOTE: 在语言设计时，有三种需求会促使语句构建自己的作用域，标识符管理只是其中之一。其它两种情况，要么是因为在语法上支持多语句（例如try...catch..finally语句），要么是语句所表达的语义要求有一个块，例如“块语句{ }”在语义上就要求它自己是一个块级作用域。</p>\n</blockquote><p>所以<strong>标签</strong>、<strong>表达式</strong>和<strong>其它语句</strong>这三种东西都不需要使用一个“独立作用域”去管理起来。所谓“其它语句”当然存在这种冲突，不过显然这种情况下它们也应该自己管理这个作用域。所以，对于当前语句来说，就只需要考虑剩下的唯一一种情况，就是在“<strong>语句中包含了标识符声明</strong>”的情况下，需要创建块级作用域来管理这些声明出来的标识符。</p><p>在所有六种声明语句之外，只剩下<code>for (&lt;let/const&gt;...)...</code>这一个语句能在它的语法中去做这样的标识符声明。所以，它就成了块级作用域的这个唯一特例。</p><p>那么这个语法中为什么单单没有了“var声明”呢？</p><h2>特例中的特例</h2><p>“var声明”是特例中的特例。</p><p>这一特性来自于<strong>JavaScript远古时代的作用域设计</strong>。在早期的JavaScript中，并没有所谓的块级作用域，那个时候的作用域设计只有“函数内”和“函数外”两种，如果一个标识符不在任何（可以多层嵌套的）函数内的话，那么它就一定是在“全局作用域”里。</p><p>“函数内→全局”之间的作用域，就只有概念上无限层级的“函数内”。</p><p>而在这个时代，变量也就只有“var声明”的变量。由于作用域只有上面两个，所以任何一个“var声明”的标识符，要么是在函数内的，要么就是在全局的，没有例外。按照这个早期设计，如下语句中的变量<code>x</code>：</p><pre><code>for (var x = ...)\n    ...\n</code></pre><p>是不应该出现在“<strong>for语句所在的</strong>”块级作用域中的。它应该出现其外层的某个函数作用域，或者全局作用域中。这种越过当前语法范围，而在更外围的作用域中登记名字行为就称为“<strong>提升（Hoisting/Hoistable）</strong>”。</p><p>ECMAScript 6开始的JavaScript在添加块级作用域特性时充分考虑了对旧有语法的兼容，因此当上述语法中出现“var声明”时，它所声明的标识符是与该语句的块级作用域无关的。在ECMAScript中，这是两套标识符体系，也是使用两套作用域来管理的。确切地说：</p><ul>\n<li>所有“var声明”和函数声明的标识符都登记为varNames，使用“<strong>变量作用域</strong>”管理；</li>\n<li>其它情况下的标识符/变量声明，都作为lexicalNames登记，使用“<strong>词法作用域</strong>”管理。</li>\n</ul><blockquote>\n<p>NOTE: 考虑到对传统JavaScript的兼容，函数内部的顶层函数名是提升到变量作用域中来管理的。 &gt; &gt; NOTE: 我通常会将“在变量声明语句前使用该变量”也称为一种提升效果（<em>Hoisting effect</em>)，但这种说法不见于ECMAScript规范。ES规范将这种“提前使用”称为“访问一个未初始化的绑定（<em>uninitialized mutable/immutable binding</em>）”。而所谓“var声明能被提前使用”的效果，事实上是“var变量总是被引擎预先初始化为undefined”的一种后果。</p>\n</blockquote><p>所以，语句<code>for (&lt;const/let&gt; x ...) ...</code>语法中的标识符<code>x</code>是一个<strong>词法名字</strong>，应该由<code>for</code>语句为它创建一个（块级的）词法作用域来管理之。</p><p>然而进一步后，新的问题产生了：一个词法作用域是足够的吗？</p><h2>第二个作用域</h2><p>首先，必须要拥有至少一个块级作用域。如之前讲到的，这是出于管理标识符的必要性。下面的示例简单说明这个块级作用域的影响：</p><pre><code>var x = 100;\nfor (let x = 102; x &lt; 105; x++)\n  console.log('value:', x);  // 显示“value: 102~104”\nconsole.log('outer:', x); // 显示“outer: 100”\n</code></pre><p>因为<code>for</code>语句的这个块级作用域的存在，导致循环体内访问了一个局部的<code>x</code>值（循环变量），而外部的（outer）变量<code>x</code>是不受影响的。</p><p>那么在循环体内是否需要一个新的块级作用域呢？这取决于在语言设计上是否支持如下代码：</p><pre><code>for (let x = 102; x &lt; 105; x++)\n  let x = 200;\n</code></pre><p>也就是说，如果循环体（单个语句）允许支持新的变量声明，那么为了避免它影响到循环变量，就必须为它再提供另一个块级作用域。很有趣的是，<strong>在这里，JavaScript是不允许声明新的变量的</strong>。上述的示例会抛出一个异常，提示你“单语句不支持词法声明”：</p><blockquote>\n<p><em>SyntaxError: Lexical declaration cannot appear in a single-statement context</em></p>\n</blockquote><p>这个语法错误并不常见，因为很少有人会尝试构建这样的特殊代码。然而事实上，它是一个普遍存在的语法禁例，例如以下语句语法：</p><pre><code>// if语句中的禁例\nif (false) let x = 100;\n\n// while语句中的禁例\nwhile (false) let x = 200;\n\n// with语句中的禁例\nwith (0) let x = 300\n</code></pre><p>所以，现在可以确定：<span class=\"orange\">循环语句（对于支持“<em>let/const</em>”的for语句来说）“通常情况下”只支持一个块级作用域。</span>更进一步地说，在上面的代码中，我们并没有机会覆盖for语句中的“let/const”声明。</p><p>但是如果在for语句支持了let/const的情况下，仅仅只有一个块级作用域是不方便的。例如：</p><pre><code>for (let i=0; i&lt;2; i++) /* 用户代码 */;\n</code></pre><p>在这个例子中，“只有一个块级作用域”的设计，将会导致“用户代码”直接运行在与“let声明”相同的词法作用域中。对于这个例子来说，这一切还好，因为“let i = 0”这个代码只执行了一次，因为它是for语句的初始化表达式。</p><p>但是对于下面这个例子来说，“只有一个块级作用域”就不够了：</p><pre><code>for (let i in x) ...;\n</code></pre><p>在这个例子中，“let i ...”在语义上就需要被执行多次——因为在静态结构中它的多次迭代都作用于同一个语法元素。而你是知道的，let语句的变量不能重复声明的。所以，这里就存在了一个冲突：“let/const”语句的单次声明（不可覆盖）的设计，与迭代多次执行的现实逻辑矛盾了。</p><p>这个矛盾的起点，就是“只有一个块级作用域”。所以，在JavaScript引擎实现“支持_let/const_的for语句”时，就在这个地方做了特殊处理：为循环体增加一个作用域。</p><p>这样一来，“let i”就可以只执行一次，然后将“i in x”放在每个迭代中来执行，这样避免了与“let/const”的设计冲突。</p><p>上面讲的，其实是JavaScript在语法设计上的处理，也就是在语法设计上，需要为使用<code>let/const</code>声明循环变量的for语句多添加一个作用域。然而，这个问题到了具体的运行环境中，变量又有些不同了。</p><h2>for循环的代价</h2><p>在JavaScript的具体执行过程中，作用域是被作为环境的上下文来创建的。如果将for语句的块级作用域称为<strong>forEnv</strong>，并将上述为循环体增加的作用域称为<strong>loopEnv</strong>，那么<strong>loopEnv</strong>它的外部环境就指向<strong>forEnv</strong>。</p><p>于是在loopEnv看来，变量<code>i</code>其实是登记在父级作用域forEnv中，并且loopEnv只能使用它作为名字“i”的一个引用。更准确地说，在loopEnv中访问变量<code>i</code>，在本质上就是通过环境链回溯来查找标识符（Resolve identifier, or Get Identifier Reference）。</p><p>上面的矛盾“貌似”被解决了，但是想想程序员可以在每次迭代中做的事情，这个解决方案的结果就显得并不那么乐观了。例如：</p><pre><code>for (let i in x)\n  setTimeout(()=&gt;console.log(i), 1000);\n</code></pre><p>这个例子创建了一些定时器。当定时器被触发时，函数会通过它的闭包（这些闭包处于loopEnv的子级环境中）来回溯，并试图再次找到那个标识符<code>i</code>。然而，当定时器触发时，整个for迭代有可能都已经结束了。这种情况下，要么上面的forEnv已经没有了、被销毁了，要么它即使存在，那个<code>i</code>的值也已经变成了最后一次迭代的终值。</p><p>所以，要想使上面的代码符合预期，这个loopEnv就必须是“随每次迭代变化的”。也就是说，需要为每次迭代都创建一个新的作用域副本，这称为<strong>迭代环境</strong>（iterationEnv)。因此，每次迭代在实际上都并不是运行在loopEnv中，而是运行在该次迭代自有的iterationEnv中。</p><p>也就是说，在语法上这里只需要两个“块级作用域”，而实际运行时却需要为其中的第二个块级作用域创建无数个副本。</p><p>这就是for语句中使用“let/const”这种块级作用域声明所需要付出的代价。</p><h2>知识回顾</h2><p>今天我讲述了for循环为了支持局部的标识符声明而付出的代价。</p><p>在传统的JavaScript中是不存在这个问题的，因为“var声明”是直接提升到函数的作用域中登记的，不存在上面的矛盾。这里讲的for语句的特例，是在ECMAScript 6支持了块级作用域之后，才出现的特殊语法现象。当然，它也带来了便利，也就是可以在每个for迭代中使用独立的循环变量了。</p><p>当在这样的for循环中添加块语句时（这是很常见的），块语句是作为iterationEnv的子级作用域的，因此块语句在每个迭代中都会都会创建一次它自己的块级作用域副本。这个循环体越大，支持的层次越多，那么这个环境的创建也就越频繁，代价越高昂。再加上可以使用函数闭包将环境传递出去，或交给别的上下文引用，这里的负担就更是雪上加霜了。</p><p>注意，无论用户代码是否直接引用loopEnv中的循环变量，这个过程都是会发生的。这是因为JavaScript允许动态的eval()，所以引擎并不能依据代码文本静态地分析出循环体（ForBody）中是否引用哪些循环变量。</p><p>你应该知道一种理论上的观点，也就是所谓“<strong>循环与函数递归在语义上等价</strong>”。所以在事实上，上述这种<strong>for循环并不比使用函数递归节省开销</strong>。在函数调用中，这里的循环变量通常都是通过函数参数传递来处理的。因而，那些支持“let/const”的for语句，本质上也就与“在函数参数界面中传递循环控制变量的递归过程”完全等价，并且在开销上也是完全一样的。</p><p>因为每一次函数调用其实都会创建一个<strong>新的闭包</strong>——也就是函数的作用域的一个副本。</p><h2>思考题</h2><ul>\n<li>为什么单语句（single-statement）中不能出现词法声明（ lexical declaration ）？</li>\n</ul><p>希望你喜欢我的分享，也欢迎你把文章分享给你的朋友。</p>","neighbors":{"left":{"article_title":"04 | export default function() {}：你无法导出一个匿名函数表达式","id":166491},"right":{"article_title":"加餐 | 捡豆吃豆的学问（上）：这门课讲的是什么？","id":171116}},"comments":[{"had_liked":false,"id":153318,"user_name":"Y","can_delete":false,"product_type":"c1","uid":1555967,"ip_address":"","ucode":"4AA6170E230C0C","user_header":"https://static001.geekbang.org/account/avatar/00/17/bd/ff/f4f2ae6a.jpg","comment_is_top":false,"comment_ctime":1574215128,"is_pvip":false,"replies":[{"id":"58891","content":"是的。<br>赞，好几个赞。^^.","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574219157,"ip_address":"","comment_id":153318,"utype":1}],"discussion_count":13,"race_medal":0,"score":"164782972376","product_id":100039701,"comment_content":"老师，在es6中，其实for只要写大括号就代表着块级作用域。所以只要写大括号，不管用let 还是 var，一定是会创建相应循环数量的块级作用域的。<br>如果不用大括号，在for中使用了let，也会创建相应循环数量的块级作用域。<br>也就是说，可以提高性能的唯一情况只有（符合业务逻辑的情况下），循环体是单行语句就不使用大括号且for中使用var。","like_count":38,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475118,"discussion_content":"是的。\n赞，好几个赞。^^.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574219157,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2273657,"avatar":"https://static001.geekbang.org/account/avatar/00/22/b1/79/7d087962.jpg","nickname":"Leo","note":"","ucode":"1E4CFF7CAAC4F6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327622,"discussion_content":"var根本就不会创建块级作用域，和有没有大括号没有关系。用了var还想创建块级作用域就得用IIFE，要不就直接用let，大家可以看看我博客里做的对比试验就知道了：https://blog.csdn.net/Leo_Franklin/article/details/109616931","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1605875951,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1338736,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6d/70/25ba4287.jpg","nickname":"明月","note":"","ucode":"D6586156BF09CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2273657,"avatar":"https://static001.geekbang.org/account/avatar/00/22/b1/79/7d087962.jpg","nickname":"Leo","note":"","ucode":"1E4CFF7CAAC4F6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542983,"discussion_content":"let x = 1;\nfor(var i= 1; i&lt; 10 ;i++) {\n    let x = 3\n}\nconsole.log(x); //1\n测试如下代码就知道，如果用了var + {} ，就会创建块级作用域。否则上面的代码就会报错。真实的结果是这里输出 1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640920799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":327622,"ip_address":""},"score":542983,"extra":""}]},{"author":{"id":1390530,"avatar":"https://static001.geekbang.org/account/avatar/00/15/37/c2/4e630398.jpg","nickname":"名字长了容易被人记住是真的吗","note":"","ucode":"21C7DEB8A1CAAC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":154189,"discussion_content":"用var是不会产生块级作用域的，即使用了大括号，因为貌似在es6之前并没有for循环的作用域一说","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1580124853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1138706,"avatar":"https://static001.geekbang.org/account/avatar/00/11/60/12/268826e6.jpg","nickname":"Marvin","note":"","ucode":"D955A98C48CBEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60819,"discussion_content":"如果不用大括号，在for中使用了let，也会创建相应循环数量的块级作用域。这句话不是和文中的 对于支持“let/const”的 for 语句来说）“通常情况下”只支持一个块级作用域，相矛盾么？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574757349,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1293057,"avatar":"https://static001.geekbang.org/account/avatar/00/13/bb/01/568ac2d6.jpg","nickname":"K4SHIFZ","note":"","ucode":"BFB49AAC0E4C74","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1138706,"avatar":"https://static001.geekbang.org/account/avatar/00/11/60/12/268826e6.jpg","nickname":"Marvin","note":"","ucode":"D955A98C48CBEF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":157201,"discussion_content":"本专栏作者表述真的晦涩难懂，九曲十八弯","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1580453781,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":60819,"ip_address":""},"score":157201,"extra":""},{"author":{"id":2656622,"avatar":"https://static001.geekbang.org/account/avatar/00/28/89/6e/a8a3b90d.jpg","nickname":"infi","note":"","ucode":"252923169E3374","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1293057,"avatar":"https://static001.geekbang.org/account/avatar/00/13/bb/01/568ac2d6.jpg","nickname":"K4SHIFZ","note":"","ucode":"BFB49AAC0E4C74","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387000,"discussion_content":"我觉得也是 总感觉在绕","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1627932565,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":157201,"ip_address":""},"score":387000,"extra":""}]},{"author":{"id":1376627,"avatar":"https://static001.geekbang.org/account/avatar/00/15/01/73/a3bbaab9.jpg","nickname":"Aiden","note":"","ucode":"3B0FA384541943","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":198059,"discussion_content":"运行这段代码，证明for带大括号不会有新的作用域产生\n-----\nlet x = 1;\nfor(var i= 1; i< 10 ;i++) {\n    var x = 3\n}\nconsole.log(x)\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583467915,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1361489,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c6/51/44791c01.jpg","nickname":"🇧🇪 Hazard🇦🇷","note":"","ucode":"E2C44FAFDFAA88","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1376627,"avatar":"https://static001.geekbang.org/account/avatar/00/15/01/73/a3bbaab9.jpg","nickname":"Aiden","note":"","ucode":"3B0FA384541943","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":239198,"discussion_content":"你好，关于你这个回答我不太懂是什么意思？\n\nfor循环首先跟后面的大括号是没有关系的，这里的大括号的确是有产生一个块级作用域。而你的例子中，会在`var x`这里报一个错，其原因在我看来是因为在早期js设计中，只有全局作用域和函数作用域，所以这里的var提升到了外层，其实相当于 let x和 var x写在了一起，报错是在语法解析阶段进行的处理，为了防止同一个环境下声明标识符同名；\n\n而块级作用域是es6中的概念，let const的实现也是在此基础上的，如果你把代码改成 外面是 `var x = 1`, 里面是 `let x = 3`，就不会报错了，原因就是 let x 在这里是在内部的大括号的块级作用域下的声明；但是你可能会觉得这里是因为for循环有一个varEnv的作用域，所以并不能证明什么；\n同理在if语句中也是一样的\n```js\n// 不报错\nvar x = 1\nif(true) let x = 3\n\n// 报错 syntaxError\nlet x = 1\nif(true) var x = 3\n```\n所以其实这里是有块级作用域的，而且跟for循环没有关系。\n\n欢迎指正！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587283809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":198059,"ip_address":""},"score":239198,"extra":""},{"author":{"id":1156074,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a3/ea/53333dd5.jpg","nickname":"HoSalt","note":"","ucode":"610B03E2A002D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1361489,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c6/51/44791c01.jpg","nickname":"🇧🇪 Hazard🇦🇷","note":"","ucode":"E2C44FAFDFAA88","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":262871,"discussion_content":"if(true) let x = 3\n就这句我在chrome下试会报错\nif(true) var x = 3 这个不报错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589131621,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":239198,"ip_address":""},"score":262871,"extra":""},{"author":{"id":1094421,"avatar":"https://static001.geekbang.org/account/avatar/00/10/b3/15/01ef8470.jpg","nickname":"人间动物园","note":"","ucode":"FAF6DC16334C2F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1156074,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a3/ea/53333dd5.jpg","nickname":"HoSalt","note":"","ucode":"610B03E2A002D1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296309,"discussion_content":"第一句报错是因为单语句禁例（单语句不支持词法声明），第二句不报错是因为你只打了一句代码在控制台，记得在前面先加上let x =1;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596506934,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":262871,"ip_address":""},"score":296309,"extra":""}]},{"author":{"id":1038790,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d9/c6/8be8664d.jpg","nickname":"ytd","note":"","ucode":"C6AEA2D19E447A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":59887,"discussion_content":"看来let也不能随便用呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574694890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1390561,"avatar":"https://static001.geekbang.org/account/avatar/00/15/37/e1/0953c506.jpg","nickname":"授人以摸鱼","note":"","ucode":"69417D324C1473","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1038790,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d9/c6/8be8664d.jpg","nickname":"ytd","note":"","ucode":"C6AEA2D19E447A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":63538,"discussion_content":"不过讲道理，用js写的代码应该也用不着这么扣性能……真性能敏感的部分应该可以想办法用别的语言编webasm(不会拼)给js调……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574874927,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":59887,"ip_address":""},"score":63538,"extra":""}]}]},{"had_liked":false,"id":153570,"user_name":"westfall","can_delete":false,"product_type":"c1","uid":1632773,"ip_address":"","ucode":"F3F5CB7DF695FC","user_header":"https://static001.geekbang.org/account/avatar/00/18/ea/05/b164dc15.jpg","comment_is_top":false,"comment_ctime":1574260847,"is_pvip":false,"replies":[{"id":"59064","content":":)<br>+1","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574303262,"ip_address":"","comment_id":153570,"utype":1}],"discussion_count":2,"race_medal":0,"score":"87473606767","product_id":100039701,"comment_content":"因为单语句没有块级作用域，而词法声明是不可覆盖的，单语句后面的词法声明会存在潜在的冲突。","like_count":20,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475213,"discussion_content":":)\n+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574303262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1361489,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c6/51/44791c01.jpg","nickname":"🇧🇪 Hazard🇦🇷","note":"","ucode":"E2C44FAFDFAA88","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":208606,"discussion_content":"啥意思，大佬能再解释一下吗？如 for 单语句","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584552223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184679,"user_name":"小毛","can_delete":false,"product_type":"c1","uid":1350319,"ip_address":"","ucode":"938EC487011357","user_header":"https://static001.geekbang.org/account/avatar/00/14/9a/af/ac09799f.jpg","comment_is_top":false,"comment_ctime":1583380997,"is_pvip":false,"replies":[{"id":"71496","content":"这个问题点问得非常细，解释起来也不容易。<br><br>&gt; 1. for (let&#47;const x...)<br><br>在这个结构中，for语句总是会生成一个块级作用域，用来放x等等变量。这一点是没有疑问的。并且，由于var声明，或者没有任何声明的for语句在这里不需要放变量名，所以在那些语法格式，也就不产生块级作用域。这个理由和逻辑也很清晰。这个地方创建的作用域（环境）称为forEnv。<br><br>基于此，我们继续讨论。<br><br>&gt; 2. for (let&#47;const x...) ...<br><br>在第二个...位置，亦即是forBody的位置如果没有块语句，那么这里就会被识别为“单语句上下文（single-statement context）”，也就是说这种情况下for被理解为单语句。if语句在这里的情况也一样，也是没有块语句，就理解为单语句。<br><br>对于forBody来说，它每一次循环都需要创建一个iterationEnv，这个iterationEnv抄写自loopEnv。——注意这里是抄写，而不是简单地将parent指向loopEnv，所以它确实比较消耗资源。（再次说明，loopEnv的parent指向forEnv，但iterationEnv是抄写loopEnv而不是指向它）。<br><br>但为什么要“抄写”呢？这个部分在正文里面有仔细讲，使用了一个基于setTimeout()的例子，请再回顾一下。<br><br>但是上面（在这个评论的）第1部分中说到的单语句的部分为什么仍然要iterationEnv呢？——这个才是你的问题本身不是？<br><br>其实这就与单语句或块语句无关了。for语句是不包括后面的大括号的。它的语法就是`for (...) ...`，后面是大括号还是单语句上下文，无关。所以`for (let&#47;const ...) ...`语句就约定了每次循环都创建iterationEnv并抄写自loopEnv，以确保在forBody部分可以创建新的作用域，而至于在forBody中是setTimeout打开中的函数闭包，还是一个块语句，它们的处理逻辑（以及对块级作用域的需求）其实都是一样的。<br><br>最后，你的问题提到是不是可以将let x放for语句外。是的，这会提高效率，并且也不需要创建loopEnv和iterationEnv。你也可以考虑用var，以及用一个函数来包起来，避免变量泄露到全局。简单地说，使用函数内套一个for循环，并在函数内管理变量名，比将这些变量名放到for (let&#47;const ...)循环语句中，要效率高一些。<br><br>如上。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1583472317,"ip_address":"","comment_id":184679,"utype":1}],"discussion_count":1,"race_medal":0,"score":"57417955845","product_id":100039701,"comment_content":"老师，最后的思考题感觉有点懵，按你文章里说的，for(let&#47;const...)这中语法，不管怎样在执行阶段，都会为每次循环创建一个iterationEnv块级作用域，那又为什么在单语句语法中不能有let词法声明呢，像if不能有是可以理解的，但是对于for(let&#47;const...)就不能理解了。<br>另外如果要提高for的性能，是不是不for(let&#47;const...)这样写，把let x放在for语句体外，在其之前声明，是不是就可以在执行阶段只有一个loopEnv，而不创建iterationEnv，从而提高性能。","like_count":13,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486093,"discussion_content":"这个问题点问得非常细，解释起来也不容易。\n\n&amp;gt; 1. for (let/const x...)\n\n在这个结构中，for语句总是会生成一个块级作用域，用来放x等等变量。这一点是没有疑问的。并且，由于var声明，或者没有任何声明的for语句在这里不需要放变量名，所以在那些语法格式，也就不产生块级作用域。这个理由和逻辑也很清晰。这个地方创建的作用域（环境）称为forEnv。\n\n基于此，我们继续讨论。\n\n&amp;gt; 2. for (let/const x...) ...\n\n在第二个...位置，亦即是forBody的位置如果没有块语句，那么这里就会被识别为“单语句上下文（single-statement context）”，也就是说这种情况下for被理解为单语句。if语句在这里的情况也一样，也是没有块语句，就理解为单语句。\n\n对于forBody来说，它每一次循环都需要创建一个iterationEnv，这个iterationEnv抄写自loopEnv。——注意这里是抄写，而不是简单地将parent指向loopEnv，所以它确实比较消耗资源。（再次说明，loopEnv的parent指向forEnv，但iterationEnv是抄写loopEnv而不是指向它）。\n\n但为什么要“抄写”呢？这个部分在正文里面有仔细讲，使用了一个基于setTimeout()的例子，请再回顾一下。\n\n但是上面（在这个评论的）第1部分中说到的单语句的部分为什么仍然要iterationEnv呢？——这个才是你的问题本身不是？\n\n其实这就与单语句或块语句无关了。for语句是不包括后面的大括号的。它的语法就是`for (...) ...`，后面是大括号还是单语句上下文，无关。所以`for (let/const ...) ...`语句就约定了每次循环都创建iterationEnv并抄写自loopEnv，以确保在forBody部分可以创建新的作用域，而至于在forBody中是setTimeout打开中的函数闭包，还是一个块语句，它们的处理逻辑（以及对块级作用域的需求）其实都是一样的。\n\n最后，你的问题提到是不是可以将let x放for语句外。是的，这会提高效率，并且也不需要创建loopEnv和iterationEnv。你也可以考虑用var，以及用一个函数来包起来，避免变量泄露到全局。简单地说，使用函数内套一个for循环，并在函数内管理变量名，比将这些变量名放到for (let/const ...)循环语句中，要效率高一些。\n\n如上。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583472317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159745,"user_name":"Elmer","can_delete":false,"product_type":"c1","uid":1233975,"ip_address":"","ucode":"61FC9CE0BA5BC1","user_header":"https://static001.geekbang.org/account/avatar/00/12/d4/37/528a43e7.jpg","comment_is_top":false,"comment_ctime":1575775728,"is_pvip":true,"replies":[{"id":"61018","content":"正是如此😃👍","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1575778437,"ip_address":"","comment_id":159745,"utype":1}],"discussion_count":1,"race_medal":0,"score":"53115383280","product_id":100039701,"comment_content":"从语言设计的原则上来看，越少作用域的执行环境调度效率也就越高，执行时的性能也就越好。<br>单语句如果支持变量声明，相当于需要支持为iteration env新增子作用域，降低了效率？ <br>如果需要完全可以自己写{} 来强制生成一个子作用域<br>不知道这样说对不对","like_count":12,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477160,"discussion_content":"正是如此😃👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575778437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":171052,"user_name":"wDaLian","can_delete":false,"product_type":"c1","uid":1381721,"ip_address":"","ucode":"D419921E3CFC00","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoJ8fUFEicTEPIvIdsicBywsBoIlBrPAPSbiasul9LNSO5juOxXJub1icIoWRdyk33MByyFxzHhdVKkUw/132","comment_is_top":false,"comment_ctime":1578833487,"is_pvip":false,"replies":[{"id":"66452","content":"很晚才回复你的这个问题，原因是确实不好回复，不知道哪种方法才能有效地解决你的疑惑。<br><br>首先，不要相信你写的代码，它并不是最终执行的，引擎会做一些优化，这些优化不是语言本身的，所以也不适用于我们在这个课程中所讨论的。<br><br>其次，如果你需要用你所列举的类似代码来（粗略地）检查性能，那么建议把数量提高100~1000倍以上，我运行了你的代码，单个测试case大概才20ms，这种情况下，随便的一个后台进程的波动就影响了结果，有效性成问题。再一次强调，不要用这种方法来检测性能，不要相信你的代码在“字面上的表现出来的”效率。<br><br>第三，关于debug版本并track内核，我建议你参考一下下面这两篇，一篇是讲编译的，一篇是讲优化的：<br>```<br>https:&#47;&#47;zhuanlan.zhihu.com&#47;p&#47;25120909<br>https:&#47;&#47;segmentfault.com&#47;a&#47;1190000008285728<br>```<br>我原来的意思是说，你可能会在原生语言（例如C）这个层面调试和分析内核有困难，所以就向你推荐了一下prepack-core。这个也是一个js引擎，但是是用javascript写的，你分析起来会好一些。——但坦率地说，也并不容易，这个项目还是很难的。在这里：<br>```<br>https:&#47;&#47;github.com&#47;aimingoo&#47;prepack-core<br>```<br><br>第四，我认为我还是应该给你一个简单的分析路径，来解释你的问题。从你的代码来看，你只是想尝试for let&#47;var两种语法到底性能上有什么样的差异。我的建议是这样：<br>```<br>var array = Array.from({length:10},(item,i)=&gt;i);<br><br>&#47;&#47; 例1<br>var a = [], checker1 = ()=&gt;console.log(a[1] == a[5]); &#47;&#47; anything<br>for (var i in array) setTimeout(()=&gt;a.push(i), 0);<br>setTimeout(checker1, 0); &#47;&#47; true<br><br>&#47;&#47; 例2<br>var b = [], checker2 = ()=&gt;console.log(b[1] == b[5]); &#47;&#47; anything<br>for (let i in array) setTimeout(()=&gt;b.push(i), 0);<br>setTimeout(checker2, 0); &#47;&#47; false<br>```<br><br>进一步测试如下：<br>```<br>&gt; a<br>[ &#39;9&#39;, &#39;9&#39;, &#39;9&#39;, &#39;9&#39;, &#39;9&#39;, &#39;9&#39;, &#39;9&#39;, &#39;9&#39;, &#39;9&#39;, &#39;9&#39; ]<br><br>&gt; b<br>[ &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39; ]<br>```<br><br>我们分析一个问题：<br><br>* 一、在checker1()中，a[]的元素保存了相同的i值，是不是意味着所有的setTimeout()中a.push()操作其实是工作在一个环境中的？而相对的，由于在checker2()中，b[]保存了不同的i值，那么b.push()就得工作在不同的环境中（从而才能访问不同的i值）。是不是？<br><br>* 二、所以，如果在checker2()中每一次迭代都在不同的环境中，是不是说每一次迭代都要消耗一个“创建一个环境”所需要的时间和空间？如果是这样，是不是就说明了`let i`其实效率远低于`var i`？<br><br>OK. 最后说明一下，百度查不到东西是正常的，查到才不正常。^^.","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1578926042,"ip_address":"","comment_id":171052,"utype":1}],"discussion_count":1,"race_medal":0,"score":"44528506447","product_id":100039701,"comment_content":"const array = Array.from({length:100000},(item,i)=&gt;i)<br><br>    &#47;&#47; 案例一<br>    console.time(&#39;a&#39;)<br>    const cc = []<br>    for(let i in array){<br>        cc.push(i)<br>    }<br>    console.log(cc)<br>    console.timeEnd(&#39;a&#39;)<br><br>    &#47;&#47; 案例二<br>    console.time(&#39;b&#39;)<br>    const ccc = []<br>    for(var i in array){<br>        ccc.push(i)<br>    }<br>    console.log(ccc)<br>    console.timeEnd(&#39;b&#39;)<br>    <br>    &#47;&#47; 案例三<br>    console.time(&#39;c&#39;)<br>    const cccv = []<br>    for(let i in array)<br>        cccv.push(i);<br>    console.log(cccv)<br>    console.timeEnd(&#39;c&#39;)<br><br>1.老师你上次的评论我没看懂，第一我案例一和案例三是为了做区分所以案例一有大括号的<br>2.编译引擎的debug版本然后track内核，或者你可以尝试一个prepack-core这个项目，这两个东西是啥 我百度也没查到<br>3.老师你讲的都是概念的，我就想看到一个肉眼的案例然后根据概念消化，要不现在根本就是这个for循环到底应该咋写我都懵了","like_count":10,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481221,"discussion_content":"很晚才回复你的这个问题，原因是确实不好回复，不知道哪种方法才能有效地解决你的疑惑。\n\n首先，不要相信你写的代码，它并不是最终执行的，引擎会做一些优化，这些优化不是语言本身的，所以也不适用于我们在这个课程中所讨论的。\n\n其次，如果你需要用你所列举的类似代码来（粗略地）检查性能，那么建议把数量提高100~1000倍以上，我运行了你的代码，单个测试case大概才20ms，这种情况下，随便的一个后台进程的波动就影响了结果，有效性成问题。再一次强调，不要用这种方法来检测性能，不要相信你的代码在“字面上的表现出来的”效率。\n\n第三，关于debug版本并track内核，我建议你参考一下下面这两篇，一篇是讲编译的，一篇是讲优化的：\n```\nhttps://zhuanlan.zhihu.com/p/25120909\nhttps://segmentfault.com/a/1190000008285728\n```\n我原来的意思是说，你可能会在原生语言（例如C）这个层面调试和分析内核有困难，所以就向你推荐了一下prepack-core。这个也是一个js引擎，但是是用javascript写的，你分析起来会好一些。——但坦率地说，也并不容易，这个项目还是很难的。在这里：\n```\nhttps://github.com/aimingoo/prepack-core\n```\n\n第四，我认为我还是应该给你一个简单的分析路径，来解释你的问题。从你的代码来看，你只是想尝试for let/var两种语法到底性能上有什么样的差异。我的建议是这样：\n```\nvar array = Array.from({length:10},(item,i)=&amp;gt;i);\n\n// 例1\nvar a = [], checker1 = ()=&amp;gt;console.log(a[1] == a[5]); // anything\nfor (var i in array) setTimeout(()=&amp;gt;a.push(i), 0);\nsetTimeout(checker1, 0); // true\n\n// 例2\nvar b = [], checker2 = ()=&amp;gt;console.log(b[1] == b[5]); // anything\nfor (let i in array) setTimeout(()=&amp;gt;b.push(i), 0);\nsetTimeout(checker2, 0); // false\n```\n\n进一步测试如下：\n```\n&amp;gt; a\n[ &amp;#39;9&amp;#39;, &amp;#39;9&amp;#39;, &amp;#39;9&amp;#39;, &amp;#39;9&amp;#39;, &amp;#39;9&amp;#39;, &amp;#39;9&amp;#39;, &amp;#39;9&amp;#39;, &amp;#39;9&amp;#39;, &amp;#39;9&amp;#39;, &amp;#39;9&amp;#39; ]\n\n&amp;gt; b\n[ &amp;#39;0&amp;#39;, &amp;#39;1&amp;#39;, &amp;#39;2&amp;#39;, &amp;#39;3&amp;#39;, &amp;#39;4&amp;#39;, &amp;#39;5&amp;#39;, &amp;#39;6&amp;#39;, &amp;#39;7&amp;#39;, &amp;#39;8&amp;#39;, &amp;#39;9&amp;#39; ]\n```\n\n我们分析一个问题：\n\n* 一、在checker1()中，a[]的元素保存了相同的i值，是不是意味着所有的setTimeout()中a.push()操作其实是工作在一个环境中的？而相对的，由于在checker2()中，b[]保存了不同的i值，那么b.push()就得工作在不同的环境中（从而才能访问不同的i值）。是不是？\n\n* 二、所以，如果在checker2()中每一次迭代都在不同的环境中，是不是说每一次迭代都要消耗一个“创建一个环境”所需要的时间和空间？如果是这样，是不是就说明了`let i`其实效率远低于`var i`","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578926042,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224962,"user_name":"Geek_8d73e3","can_delete":false,"product_type":"c1","uid":1961902,"ip_address":"","ucode":"FF89629117B96C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epneC3LXv0Ve2tCXPfvsXtRb5StVicNCEHUSfzneLYUDJ03B6ocINHzeLf94aw0dEkjLShSdK9NUoA/132","comment_is_top":false,"comment_ctime":1591602505,"is_pvip":false,"replies":[{"id":"83358","content":"我个问题真的把我考到了，很花了一些时间来分析它。<br><br>首先，简单地说，这个问题可以视为对如下两个语法的比较：<br>```<br>&#47;&#47; 例1：如下成立<br>var x = 100;<br>for (let x = 0; x &lt; 1; x++)<br>  console.log(x);  &#47;&#47; 0<br><br>&#47;&#47; 例2：如下不成立<br>for (let x = 0; x&lt;1; x++) {<br>  var x = 100;<br>}<br>```<br><br>就是说，为什么上述“例2”是不成立的呢？从我们之前的分析来说，`var x`声明的变量`x`是位于外部（例如全局）的，因此与当前块中的`let x`应该是没有关系的。——这类似于“例1”。<br><br>先说答案：这是语法限制。<br><br>下面……重点来了：JavaScript在语法上不允许在同一个块中出现“声明与词法名字相同的标识符”。也就是说，在语法上：<br>```<br>&#47;&#47; 例3：你既不能写<br>let x = 100;<br>const x = 100;<br><br>&#47;&#47; 例4：（所以，）也不能写<br>let x = 100;<br>var x = 100;<br>```<br>只要是在同一个词法作用域中，与&#39;let&#47;const&#39;相同的“标识符声明”就是不被许可的。<br><br>再次强调：这是语法声明上的限制，而与执行过程是无关的。<br><br>不过在ECMAScript的规范上，对这一点也是语焉不详的。——唯一与此相关的，就是在一个语法块中，会将所有的let&#47;const名字登记在BoundNames表中，以完成“例3”所示的名字重复检查。这在如下章节：<br><br>&gt; https:&#47;&#47;tc39.es&#47;ecma262&#47;#sec-let-and-const-declarations-static-semantics-early-errors<br><br>但这个位置的语法查错（至少在ECMAScript中看起来）是与`var x`声明无关的。并且事实上在ECMAScript规范中，并没有对`var`语句定义任何的语法错误抛出。<br><br>然而“（在同一个块中）不能重复声明”的语法限制是真实存在的。这项限制存在于两个地方。<br><br>首先，语法parser引擎自己会处理这个重复检测（尽管ECMAScript没有定义）。parser过程会维护当前块的词法上下文，并且拒绝在forBody和forHead中出现这种重复声明。而且有趣的是，这个检测过程对于let&#47;const，以及var来说是不同的。——具体来说，let&#47;const是只检测当前词法作用域，而var是检测词法作用域栈（scopeStack, scope chains）。关于这一点的实现，可以在这里看到：<br>&gt; https:&#47;&#47;github.com&#47;babel&#47;babel&#47;blob&#47;master&#47;packages&#47;babel-parser&#47;src&#47;util&#47;scope.js#L95<br><br>所以这是一个parser在语法解析中表现出来的结果。但带来了一个更有趣的示例：<br>```<br>&#47;&#47; 示例5，不成立<br>for (let x in {}) { var x = 100 }<br><br>&#47;&#47; 示例6，成立<br>for (let x in {}) { let x = 100 }<br>```<br><br>接下来，我们需要置疑：使用eval()来执行的话，会不会产生一个“提升到外部（例如global）的变量”呢？<br><br>答案是：也不会。而这也是唯一一处在ECMAScript中对这种现象做了解释的地方，原文是：<br><br>&gt; A direct eval will not hoist var declaration over a like-named lexical declaration.<br><br>也就是“直接的eval()是不能将对变量提升到同名的词法声明之外的”。也就是，如下代码会导致一个执行期的错误：<br>```<br>&#47;&#47; 示例7，不成立<br>for (let x in {}) { eval(&#39;var x = 100&#39;) }<br>```<br><br>而这一段的说明是被ECMAScript写进规范，并在执行期而`eval()`来处理的。参见这里：<br><br>&gt; https:&#47;&#47;tc39.es&#47;ecma262&#47;#sec-evaldeclarationinstantiation","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1592061070,"ip_address":"","comment_id":224962,"utype":1}],"discussion_count":4,"race_medal":0,"score":"35951340873","product_id":100039701,"comment_content":"老师我发现运行以下代码会报错<br>for(let x = 0;x&lt;1;x++){<br>      var x = 100;<br>    }<br>    &#47;&#47;Uncaught SyntaxError: Identifier &#39;x&#39; has already been declared<br>在我理解中，let声明的x是在forEnv中，而我使用var声明的x因为javaScript早期设计，会在全局中声明一个x。这两个作用域是不会冲突的呀，为什么报错了？","like_count":8,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497672,"discussion_content":"我个问题真的把我考到了，很花了一些时间来分析它。\n\n首先，简单地说，这个问题可以视为对如下两个语法的比较：\n```\n// 例1：如下成立\nvar x = 100;\nfor (let x = 0; x &amp;lt; 1; x++)\n  console.log(x);  // 0\n\n// 例2：如下不成立\nfor (let x = 0; x&amp;lt;1; x++) {\n  var x = 100;\n}\n```\n\n就是说，为什么上述“例2”是不成立的呢？从我们之前的分析来说，`var x`声明的变量`x`是位于外部（例如全局）的，因此与当前块中的`let x`应该是没有关系的。——这类似于“例1”。\n\n先说答案：这是语法限制。\n\n下面……重点来了：JavaScript在语法上不允许在同一个块中出现“声明与词法名字相同的标识符”。也就是说，在语法上：\n```\n// 例3：你既不能写\nlet x = 100;\nconst x = 100;\n\n// 例4：（所以，）也不能写\nlet x = 100;\nvar x = 100;\n```\n只要是在同一个词法作用域中，与&amp;#39;let/const&amp;#39;相同的“标识符声明”就是不被许可的。\n\n再次强调：这是语法声明上的限制，而与执行过程是无关的。\n\n不过在ECMAScript的规范上，对这一点也是语焉不详的。——唯一与此相关的，就是在一个语法块中，会将所有的let/const名字登记在BoundNames表中，以完成“例3”所示的名字重复检查。这在如下章节：\n\n&amp;gt; https://tc39.es/ecma262/#sec-let-and-const-declarations-static-semantics-early-errors\n\n但这个位置的语法查错（至少在ECMAScript中看起来）是与`var x`声明无关的。并且事实上在ECMAScript规范中，并没有对`var`语句定义任何的语法错误抛出。\n\n然而“（在同一个块中）不能重复声明”的语法限制是真实存在的。这项限制存在于两个地方。\n\n首先，语法parser引擎自己会处理这个重复检测（尽管ECMAScript没有定义）。parser过程会维护当前块的词法上下文，并且拒绝在forBody和forHead中出现这种重复声明。而且有趣的是，这个检测过程对于let/const，以及var来说是不同的。——具体来说，let/const是只检测当前词法作用域，而var是检测词法作用域栈（scopeStack, scope chains）。关于这一点的实现，可以在这里看到：\n&amp;gt; https://github.com/babel/babel/blob/master/packages/babel-parser/src/util/scope.js#L95\n\n所以这是一个parser在语法解析中表现出来的结果。但带来了一个更有趣的示例：\n```\n// 示例5，不成立\nfor (let x in {}) { var x = 100 }\n\n// 示例6，成立\nfor (let x in {}) { let x = 100 }\n```\n\n接下来，我们需要置疑：使用eval()来执行的话，会不会产生一个“提升到外部（例如global）的变量”呢？\n\n答案是：也不会。而这也是唯一一处在ECMAScript中对这种现象做了解释的地方，原文是：\n\n&amp;gt; A direct eval will not hoist var declaration over a like-named lexical declaration.\n\n也就是“直接的eval()是不能将对变量提升到同名的词法声明之外的”。也就是，如下代码会导致一个执行期的错误：\n```\n// 示例7，不成立\nfor (let x in {}) { eval(&amp;#39;var x = 100&amp;#39;) }\n```\n\n而这一段的说明是被ECMAScript写进规范，并在执行期而`eval","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592061070,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1961902,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epneC3LXv0Ve2tCXPfvsXtRb5StVicNCEHUSfzneLYUDJ03B6ocINHzeLf94aw0dEkjLShSdK9NUoA/132","nickname":"Geek_8d73e3","note":"","ucode":"FF89629117B96C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281048,"discussion_content":"老师，我好像知道为什么了，在for中的loopEnv中使用var声明，var存在变量提升，首先会检查标识符是否重复，这是一个链式查找，先查找上一级的forEnv，发现forEnv中存在let生命的x，let是词法声明不可覆盖，所以导致了报错。老师，我这解释正确么？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591665997,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1375112,"avatar":"https://static001.geekbang.org/account/avatar/00/14/fb/88/558a1b35.jpg","nickname":"你老公‮下一你了亲并‭","note":"","ucode":"E1DB7E1CAF82DD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371897,"discussion_content":"我在想这个语法限制会不会和var提升有关，比如：\nfor(;;){ \n   var x; //最终这个x将在for的外层作用域中\n}\n所以：\nfor(let x){ \n  //如果没有这个语法限制\n  var x; \n  //那么现在let x的作用域层级将高于var x\n  //后面对x的引用都是 let x\n  //那么var x这个语句对for毫无意义\n}\n\n感觉还得再去看看es6对let和var处理的区别。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620046578,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282740,"discussion_content":"你的理解是对的。我刚刚写了一个完整的分析（如上），这是一个有趣的语法现象。^^.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592061293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221251,"user_name":"Geek_8d73e3","can_delete":false,"product_type":"c1","uid":1961902,"ip_address":"","ucode":"FF89629117B96C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epneC3LXv0Ve2tCXPfvsXtRb5StVicNCEHUSfzneLYUDJ03B6ocINHzeLf94aw0dEkjLShSdK9NUoA/132","comment_is_top":false,"comment_ctime":1590456318,"is_pvip":false,"replies":[{"id":"81599","content":"这是因为<br> &gt; `for (let i = 0...)`<br>和<br> &gt; `{ let i = 1000; ...`<br>是在两个作用域里面。前者是forEnv，后者是bodyEnv。所以不冲突，不会算作重复声明。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1590459656,"ip_address":"","comment_id":221251,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31655227390","product_id":100039701,"comment_content":"老师，我发现，我运行这段代码的时候，并没有报错。<br>for(let i = 0;i&lt;10;i++){<br><br>        let i = 1000;<br><br>        console.log(i);<br>      }","like_count":7,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496400,"discussion_content":"这是因为\n &amp;gt; `for (let i = 0...)`\n和\n &amp;gt; `{ let i = 1000; ...`\n是在两个作用域里面。前者是forEnv，后者是bodyEnv。所以不冲突，不会算作重复声明。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590459656,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154270,"user_name":"Wiggle Wiggle","can_delete":false,"product_type":"c1","uid":1036052,"ip_address":"","ucode":"EFE746551BA998","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cf/14/384258ba.jpg","comment_is_top":false,"comment_ctime":1574400843,"is_pvip":false,"replies":[{"id":"59207","content":"《JavaScript语言精髓与编程实践》第三版。^^.<br>已经交稿，大概快要出了。<br><br>如果急用，可以看ECMAScript~ 别的书很少用语言层面来讲的。不过，另外，你可以看《程序原本》，对很多概念都是讲到的。在这里可以直接下载：<br>https:&#47;&#47;github.com&#47;aimingoo&#47;my-ebooks","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574401975,"ip_address":"","comment_id":154270,"utype":1}],"discussion_count":2,"race_medal":0,"score":"31639171915","product_id":100039701,"comment_content":"词法、词法作用域、语法元素……等等，这些概念特别模糊，老师有什么推荐的书吗？","like_count":7,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475421,"discussion_content":"《JavaScript语言精髓与编程实践》第三版。^^.\n已经交稿，大概快要出了。\n\n如果急用，可以看ECMAScript~ 别的书很少用语言层面来讲的。不过，另外，你可以看《程序原本》，对很多概念都是讲到的。在这里可以直接下载：\nhttps://github.com/aimingoo/my-ebooks","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574401975,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1742968,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/98/78/6459e29e.jpg","nickname":"麦芽科技学堂","note":"","ucode":"A90DDE4B6696BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":171473,"discussion_content":"第三版上市了，麻烦老师通知一下哦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581722047,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153314,"user_name":"zcdll","can_delete":false,"product_type":"c1","uid":1004086,"ip_address":"","ucode":"F1F20EB17D8789","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/36/18f5d218.jpg","comment_is_top":false,"comment_ctime":1574214135,"is_pvip":false,"replies":[{"id":"58896","content":"case &#39;b&#39; 永远执行不到，但它里面的x却已经声明了，并且导致case &#39;a&#39;中的代码无法访问到外部的`x = 100`。<br><br>这说明case &#39;a&#39;和case &#39;b&#39;使用了同一个闭包。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574219405,"ip_address":"","comment_id":153314,"utype":1}],"discussion_count":5,"race_medal":0,"score":"31638985207","product_id":100039701,"comment_content":"看不懂。。。第一个 switch 那个例子都看不懂。。","like_count":7,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475117,"discussion_content":"case &amp;#39;b&amp;#39; 永远执行不到，但它里面的x却已经声明了，并且导致case &amp;#39;a&amp;#39;中的代码无法访问到外部的`x = 100`。\n\n这说明case &amp;#39;a&amp;#39;和case &amp;#39;b&amp;#39;使用了同一个闭包。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574219405,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1004086,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/52/36/18f5d218.jpg","nickname":"zcdll","note":"","ucode":"F1F20EB17D8789","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54282,"discussion_content":"又看了两遍文章，终于看懂了，原来一开始我理解错了，方向看错了。。。谢谢老师","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574293767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1006786,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5c/c2/8ffd2ad0.jpg","nickname":"qqq","note":"","ucode":"91B0ACF8CBE7BD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53814,"discussion_content":"去掉第 7 行执行下试试，然后对比思考下","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574221010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1376627,"avatar":"https://static001.geekbang.org/account/avatar/00/15/01/73/a3bbaab9.jpg","nickname":"Aiden","note":"","ucode":"3B0FA384541943","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":198029,"discussion_content":"这个部分讲的太绕了 简单理解JS中只要函数作用域和特殊情况下的块作用域。而case 既不是函数也不是块，case并不能形成作用域。let 加 switch的块 才能形成作用域","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583463591,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1338736,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6d/70/25ba4287.jpg","nickname":"明月","note":"","ucode":"D6586156BF09CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1376627,"avatar":"https://static001.geekbang.org/account/avatar/00/15/01/73/a3bbaab9.jpg","nickname":"Aiden","note":"","ucode":"3B0FA384541943","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543014,"discussion_content":"应该是 {} 让switch具备了块级作用域而不是let关键词","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640932707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":198029,"ip_address":""},"score":543014,"extra":""}]}]},{"had_liked":false,"id":153460,"user_name":"Y","can_delete":false,"product_type":"c1","uid":1555967,"ip_address":"","ucode":"4AA6170E230C0C","user_header":"https://static001.geekbang.org/account/avatar/00/17/bd/ff/f4f2ae6a.jpg","comment_is_top":false,"comment_ctime":1574238798,"is_pvip":false,"replies":[{"id":"59071","content":"不是，单语句也可以实现很复杂的逻辑的。如果单语句使用let&#47;const声明，也一样可以包括逻辑。例如（这个当然不能执行）：<br><br>if (false) let x = 100, y = x++; &#47;&#47; &lt; 这里的x就被使用了<br>","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574303589,"ip_address":"","comment_id":153460,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27344042574","product_id":100039701,"comment_content":"既然是单语句就说明只有一句话，如果就一句话，还是词法声明，那就会创建一个块级作用域，但是因为是单语句，那一定就没有地方会用到这个声明了。那这个声明就是没有意义的。所以js为了避免这种没有意义的声明，就会直接报错。是这样嘛","like_count":6,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475175,"discussion_content":"不是，单语句也可以实现很复杂的逻辑的。如果单语句使用let/const声明，也一样可以包括逻辑。例如（这个当然不能执行）：\n\nif (false) let x = 100, y = x++; // &amp;lt; 这里的x就被使用了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574303589,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219222,"user_name":"🐒🐱🐭🐮🐯🐰🐶","can_delete":false,"product_type":"c1","uid":1189080,"ip_address":"","ucode":"52426AE36A9A39","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/d8/aa41d743.jpg","comment_is_top":false,"comment_ctime":1589968564,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23064805044","product_id":100039701,"comment_content":"看了4遍 终于看懂了","like_count":5},{"had_liked":false,"id":155793,"user_name":"Marvin","can_delete":false,"product_type":"c1","uid":1138706,"ip_address":"","ucode":"D955A98C48CBEF","user_header":"https://static001.geekbang.org/account/avatar/00/11/60/12/268826e6.jpg","comment_is_top":false,"comment_ctime":1574757462,"is_pvip":false,"replies":[{"id":"59899","content":"for (let&#47;const ...) “通常情况下”只支持一个块级作用域。<br>for (let&#47;const ... in&#47;of ...) 会迭代创建作用域副本。<br><br>有一眯眯细微的不同哦。 ^^.","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574776525,"ip_address":"","comment_id":155793,"utype":1}],"discussion_count":3,"race_medal":0,"score":"23049593942","product_id":100039701,"comment_content":"如果使用let &#47;const 声明for循环语句，会迭代创建作用域副本。那么不是和文中的：<br>对于支持“let&#47;const”的 for 语句来说）“通常情况下”只支持一个块级作用域这句话相矛盾么？","like_count":5,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475873,"discussion_content":"for (let/const ...) “通常情况下”只支持一个块级作用域。\nfor (let/const ... in/of ...) 会迭代创建作用域副本。\n\n有一眯眯细微的不同哦。 ^^.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574776525,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2656622,"avatar":"https://static001.geekbang.org/account/avatar/00/28/89/6e/a8a3b90d.jpg","nickname":"infi","note":"","ucode":"252923169E3374","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387312,"discussion_content":"太绕了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628117658,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1376627,"avatar":"https://static001.geekbang.org/account/avatar/00/15/01/73/a3bbaab9.jpg","nickname":"Aiden","note":"","ucode":"3B0FA384541943","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":198064,"discussion_content":"这块的一个上下文是for循环单语句，而且作用域也被作者分为 forEnv和IterationEnv。读起来真的是很难懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583468196,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154715,"user_name":"海绵薇薇","can_delete":false,"product_type":"c1","uid":1601296,"ip_address":"","ucode":"37C7CC2EB81909","user_header":"https://static001.geekbang.org/account/avatar/00/18/6f/10/bfbf81dc.jpg","comment_is_top":false,"comment_ctime":1574518891,"is_pvip":false,"replies":[{"id":"59545","content":"1. 这个问题出在我对“for(let&#47;const...)”这个语法没有展开讲，它跟“for(var...)”，以及后面的“for(let&#47;const ... in&#47;of)”其实都有区别。所以你套用它们的处理方法，结果都有点差异，对你结论会带来干扰。<br>你读一下ECMA这个部分：<br>https:&#47;&#47;tc39.es&#47;ecma262&#47;#sec-for-statement-runtime-semantics-labelledevaluation<br><br>注意其中的第三节的具体说明：<br>&gt; IterationStatement: <br> for(LexicalDeclarationExpression;Expression)Statement<br>在后续调用中，简单地说，就是这种情况下for语句会为每次循环创建 CreatePerIterationEnvironment()来产生一个新的IterationEnv。并且thisIterationEnv 与lastIterationEnv 之间会有关联。<br><br><br>2. with({}) let b = 1 这个语法报错，不是因为with()没有作用域，而是它的作用域称为“对象作用域”，而不是“词法作用域”。对象作用域只有在用作global的时候可以接受var和泄露的变量声明，其它情况下，它不能接受“向作用域添加名字”这样的行为——它的名字列表来自于属性名，例如obj.x对吧。<br><br>3. eval有一个自己的作用域。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574664557,"ip_address":"","comment_id":154715,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18754388075","product_id":100039701,"comment_content":"hello，老师好，一如既往有许多问题等待解答：）<br><br>for(let&#47;const ...) ... 这个语句有两个词法作用域，分别是 forEnv 和 loopEnv。还有一个概念是iterationEnv，这个是迭代时生成的loopEnv的副本。<br><br>对于forEnv和loopEnv的范围我不是很清楚，请老师指点。<br><br>for(let i = 0; i &lt; 10; i++) <br><br>​\tsetTimeout(() =&gt; console.log(i))<br><br>1 如上代码，let i 声明的 i 在forEnv还是在loopEnv &#47; iterationEnv里？<br><br>\t1.1 如果在loopEnv &#47; iterationEnv里那么forEnv看起来就没啥用了<br>\t<br>\t1.2 如果在forEnv（文章中说let只会执行一次，并且forEnv是lopEnv的上级），那么按理说console.log打印出来的都是11（参考于：晓小东）<br><br>2 关于单语 let a = 1 报错问题<br><br>\t2.1 如果是单语句中词法声明被重复有问题，那么with({}) let b = 1 这个报错就解释不通了。上面是说with有自己的块作用域，这个词法声明是在自己块语句中做的，并不会和别人冲突 <br><br>\t2.2 同样的情况存在于for(let a...) ... 中，for也有自己的作用域，并且每次循环都会生成新的副本，也不应该存在重复问题<br><br>3 关于上面提到的eval<br>\teval(&#39;let a = 1&#39;); console.log(a) &#47;&#47; 报错<br>\teval是不是自己也有一个作用域？<br><br>期待：）","like_count":4,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475556,"discussion_content":"1. 这个问题出在我对“for(let/const...)”这个语法没有展开讲，它跟“for(var...)”，以及后面的“for(let/const ... in/of)”其实都有区别。所以你套用它们的处理方法，结果都有点差异，对你结论会带来干扰。\n你读一下ECMA这个部分：\nhttps://tc39.es/ecma262/#sec-for-statement-runtime-semantics-labelledevaluation\n\n注意其中的第三节的具体说明：\n&amp;gt; IterationStatement: \n for(LexicalDeclarationExpression;Expression)Statement\n在后续调用中，简单地说，就是这种情况下for语句会为每次循环创建 CreatePerIterationEnvironment()来产生一个新的IterationEnv。并且thisIterationEnv 与lastIterationEnv 之间会有关联。\n\n\n2. with({}) let b = 1 这个语法报错，不是因为with()没有作用域，而是它的作用域称为“对象作用域”，而不是“词法作用域”。对象作用域只有在用作global的时候可以接受var和泄露的变量声明，其它情况下，它不能接受“向作用域添加名字”这样的行为——它的名字列表来自于属性名，例如obj.x对吧。\n\n3. eval有一个自己的作用域。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574664557,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153864,"user_name":"晓小东","can_delete":false,"product_type":"c1","uid":1194643,"ip_address":"","ucode":"93F9462EAAA63C","user_header":"https://static001.geekbang.org/account/avatar/00/12/3a/93/d7be8a1a.jpg","comment_is_top":false,"comment_ctime":1574321965,"is_pvip":true,"replies":[{"id":"59205","content":"在node里很合理呀。<br>在node里的second值是：Second1，Second2，Second3<br><br>如果你把setTimeout()超时值都改成0，就看得到计算过程了。<br><br>0<br>1<br>2<br>Last:0<br>Second1<br>Last:1<br>Second2<br>Last:2<br>Second3","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574401790,"ip_address":"","comment_id":153864,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18754191149","product_id":100039701,"comment_content":"<br>老师您看下这段代码， 我在Chrome 打印有点不符合直觉， Second 最终打印的应该是2， 为什么还是1，2， 3；<br><br>for (let i = 0; i &lt; 3; i ++, setTimeout(() =&gt; console.log(&quot;Second&quot; + i), 20))<br>    console.log(i), setTimeout(() =&gt; console.log(&#39;Last:&#39; + i), 30);<br><br>0, 1, 2 <br>Second: 0, 1,  2<br>Last: 0, 1, 2","like_count":4,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475300,"discussion_content":"在node里很合理呀。\n在node里的second值是：Second1，Second2，Second3\n\n如果你把setTimeout()超时值都改成0，就看得到计算过程了。\n\n0\n1\n2\nLast:0\nSecond1\nLast:1\nSecond2\nLast:2\nSecond3","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574401790,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153617,"user_name":"桔子","can_delete":false,"product_type":"c1","uid":1387844,"ip_address":"","ucode":"9555BC4494A28C","user_header":"https://static001.geekbang.org/account/avatar/00/15/2d/44/0a209c31.jpg","comment_is_top":false,"comment_ctime":1574271443,"is_pvip":false,"replies":[{"id":"59063","content":"是的。^^.","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574303233,"ip_address":"","comment_id":153617,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18754140627","product_id":100039701,"comment_content":"假设允许的话，没有块语句创建的iterationEnv的子作用域，let声明就直接在iterationEnv作用域中，会每次循环重复声明。","like_count":4,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475230,"discussion_content":"是的。^^.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574303233,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1361489,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c6/51/44791c01.jpg","nickname":"🇧🇪 Hazard🇦🇷","note":"","ucode":"E2C44FAFDFAA88","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":208590,"discussion_content":"你好，请问为什么在iterationEnv作用域中循环重复声明为什么不可以？不是每次循环都会“抄写”出一个作用域副本iterationEnv吗？所以每个iterationEnv不是应该是独立的吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584550177,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":251637,"user_name":"G","can_delete":false,"product_type":"c1","uid":2189373,"ip_address":"","ucode":"C267833DBBE254","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/3lp20weUpmEjiaLAS6umkKRGB7WicIPGWQ7sjRsxbw0EAiapnslID17FfmrMFppSDw7vn0A8bu1icBBmPXGGweGhjQ/132","comment_is_top":false,"comment_ctime":1601737624,"is_pvip":false,"replies":[{"id":"92066","content":"可以先“观其大略，不求甚解”，一遍两遍之后，再“务求精细，绝无遗漏”。读书也好，学习也好，不同的东西要用不同的方法来应对，这门课是适合反复研究的。<br><br>在这门课的结束语中说过：即便是同一个石狮子，在不同的层次看到的，仍然是不同的东西、不同的答案、不同的理解。所以，不要纠结于你之前的所得“是否错了”，你可能只是高度提高了，理解有了不同而已。——如果你能否定之前的所见，是提高；如果你有能力质疑它，也是提高；如果你能肯定它，还是提高。<br><br>不进则退，无论否定、质疑、肯定，皆是进步，但都不是终点。是谓学习。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1601916068,"ip_address":"","comment_id":251637,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14486639512","product_id":100039701,"comment_content":"老师您好，关于如何学习这门课，可否请您指点一下。<br>第一部分的内容我其实已经来回读了很多遍了，我接触js差不多一年，里面很多内容对我来说比较难懂。在读到后面内容的时候，我常常需要再翻回前面这些内容重新读，因为有一些前面章节我所没有理解的地方，在后续章节会讲到，这时候重新读我就会有新的收获。而且我在重新读的过程中，发现文章中的每一句话都是很有用的，少看一句话可能就会让我造成理解上的错误，每次重新读都有新收获这件事，让我开心又让我焦虑，因为这代表我并没有完全读懂任何一章。在继续学习第三部分的时候，我又发现我开始很难读懂文章，此时我不知道我应该先整体读完第三部分然后再回过头来重新读几遍，还是把每一篇文章尽量弄清楚，我目前采取的是后面这种方式，我已经学了差不多20天这个课程，但是目前也没有真正走出第二部分的内容，这个会不会是我这种学习方式不对。<br>希望周老师指点一下。","like_count":3,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506574,"discussion_content":"可以先“观其大略，不求甚解”，一遍两遍之后，再“务求精细，绝无遗漏”。读书也好，学习也好，不同的东西要用不同的方法来应对，这门课是适合反复研究的。\n\n在这门课的结束语中说过：即便是同一个石狮子，在不同的层次看到的，仍然是不同的东西、不同的答案、不同的理解。所以，不要纠结于你之前的所得“是否错了”，你可能只是高度提高了，理解有了不同而已。——如果你能否定之前的所见，是提高；如果你有能力质疑它，也是提高；如果你能肯定它，还是提高。\n\n不进则退，无论否定、质疑、肯定，皆是进步，但都不是终点。是谓学习。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601916068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":252730,"user_name":"二二","can_delete":false,"product_type":"c1","uid":2198765,"ip_address":"","ucode":"D4C43342B42CD3","user_header":"","comment_is_top":false,"comment_ctime":1602471727,"is_pvip":false,"replies":[{"id":"92571","content":"这个是特难解释的，因为devtool测的也不见得是js引擎的结果，而且chrome自身也还对v8引擎有优化，不见得是ecmascript语言规范所表现出来的样子。<br><br>只以你的例子来说，由于var其实声明是在for语句之外一层的变量作用域（这里正好是全局作用域）中的，所以在for语言中访问var变量其实是要经过多一次的查找的。而let块是在for语句里，尽管每次都创建一个新的(从上一次复制而来），但是它们之间不需要嵌套，所以访问层次总是1。因此，大抵来说，是用空间（更多的作用域环境）换了时间（更少的访问层次）。<br>对于js引擎（包括jit优化引擎）来说，let以及它所对应的词法作用域是易于优化处理的，而var则很难，因为var中的名字是可增删的，因此不能缓存也不能做层次的消减。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1602746060,"ip_address":"","comment_id":252730,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10192406319","product_id":100039701,"comment_content":"你好老师，按照文章的解释，因为for循环中let会导致块级作用域，开销会变大，此处的开销可以粗略理解成时间。<br>var a = new Array(10000).fill(0)<br>console.time(&#39;var&#39;)<br>for(var i=0, len=a.length; i&lt;len; i++){}<br>console.timeEnd(&#39;var&#39;)<br>console.time(&#39;let&#39;)<br>for(let i=0, len=a.length; i&lt;len; i++){}<br>console.timeEnd(&#39;let&#39;)<br>在chrome devtool执行的结果，var会比let要慢许多，请问中间还发生了什么，导致var会比let慢呢？","like_count":2,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506852,"discussion_content":"这个是特难解释的，因为devtool测的也不见得是js引擎的结果，而且chrome自身也还对v8引擎有优化，不见得是ecmascript语言规范所表现出来的样子。\n\n只以你的例子来说，由于var其实声明是在for语句之外一层的变量作用域（这里正好是全局作用域）中的，所以在for语言中访问var变量其实是要经过多一次的查找的。而let块是在for语句里，尽管每次都创建一个新的(从上一次复制而来），但是它们之间不需要嵌套，所以访问层次总是1。因此，大抵来说，是用空间（更多的作用域环境）换了时间（更少的访问层次）。\n对于js引擎（包括jit优化引擎）来说，let以及它所对应的词法作用域是易于优化处理的，而var则很难，因为var中的名字是可增删的，因此不能缓存也不能做层次的消减。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602746060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":243333,"user_name":"青山入我怀","can_delete":false,"product_type":"c1","uid":2129828,"ip_address":"","ucode":"0A712556F4D7A3","user_header":"https://static001.geekbang.org/account/avatar/00/20/7f/a4/34955365.jpg","comment_is_top":false,"comment_ctime":1598063430,"is_pvip":false,"replies":[{"id":"89728","content":"你忘了通常来说的代码，类似于`for (let i =0; i&lt;x; i++) ...`，会在下一次迭代之前先`i++`一次？如果是`let i in obj`运算，那么也会发生一次将属性名提取到i的操作~<br><br>所以i是副本，但“通常”会被立即重写。当然，如果代码中没有`i++`这样类似重写的操作，那么这个复制副本的行为就浪费了。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1598177748,"ip_address":"","comment_id":243333,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10187998022","product_id":100039701,"comment_content":"老师，请问既然forEnv是loopEnv的上级，而iterationEnv又是loopEnv的副本，那么按道理在iterationEnv中对i的改动，在查找i时不都是会通过环境链回溯，找到forEnv这个运用域下的i吗，那么闭包现象发生时，找到的i应该是同一个i啊，感觉增加了副本无法避免这个问题啊？","like_count":2,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504258,"discussion_content":"你忘了通常来说的代码，类似于`for (let i =0; i&amp;lt;x; i++) ...`，会在下一次迭代之前先`i++`一次？如果是`let i in obj`运算，那么也会发生一次将属性名提取到i的操作~\n\n所以i是副本，但“通常”会被立即重写。当然，如果代码中没有`i++`这样类似重写的操作，那么这个复制副本的行为就浪费了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598177748,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":238934,"user_name":"A.     成事在天","can_delete":false,"product_type":"c1","uid":2056450,"ip_address":"","ucode":"0B069A8EAD0E9B","user_header":"https://static001.geekbang.org/account/avatar/00/1f/61/02/6ccf315c.jpg","comment_is_top":false,"comment_ctime":1596375313,"is_pvip":false,"replies":[{"id":"88448","content":"你是对的。在作用域链上，递归的链会更长，而for总是两个层级。但他们的生成的作用域的个数是相当的。但似乎这与“生成global scope”没什么关系，但我想这可能只是你在表述上的一点问题吧。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1596532508,"ip_address":"","comment_id":238934,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10186309905","product_id":100039701,"comment_content":"老师我认为的是函数递归比for循坏开支大，首先函数递归会不断重复的在作用域链中生成global scope，如果递归10次就会有十个重复的global scope，for循环是块级作用域它确实也会重复的生成内部的上下文但是不会生成作用域链也就不会重复的去生成global scope，老师我理解的对吗","like_count":2,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502900,"discussion_content":"你是对的。在作用域链上，递归的链会更长，而for总是两个层级。但他们的生成的作用域的个数是相当的。但似乎这与“生成global scope”没什么关系，但我想这可能只是你在表述上的一点问题吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596532508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2056450,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/61/02/6ccf315c.jpg","nickname":"A.     成事在天","note":"","ucode":"0B069A8EAD0E9B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296402,"discussion_content":"奥，我明白老师您说的意思了，我之前理解的有问题，看了您回复的明白了，感谢老师解😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596533080,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224958,"user_name":"Geek_8d73e3","can_delete":false,"product_type":"c1","uid":1961902,"ip_address":"","ucode":"FF89629117B96C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epneC3LXv0Ve2tCXPfvsXtRb5StVicNCEHUSfzneLYUDJ03B6ocINHzeLf94aw0dEkjLShSdK9NUoA/132","comment_is_top":false,"comment_ctime":1591601987,"is_pvip":false,"replies":[{"id":"83239","content":"一般的“块级作用域”所在的环境中并没有“变量作用域”。所以块级作用域只能放let&#47;const。<br><br>同时具有“变量作用域”和“词法作用域 ”的只有函数、全局和ES6之后的模块。所以，当在一个一般的“块级作用域”中声明了var的时候，它就必须被“提升”到上面三种环境中去存放。<br><br>所以下面的代码中：<br>```<br>for (...) {<br>  var x = 1;<br>  let y = 2;<br>  ...<br>```<br>在这其中`y`是放在for的forBody块中的，而`x`是放在这个语句所在的、更外层的“变量作用域”中的。<br><br>这个变量作用域并不是为上面两行代码“专门创建”的。但是for(let i =0....)中的“词法作用域 ”是为for语句专门创建的，因此它跟更外层的（例如全局）并不是同一个。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1591906651,"ip_address":"","comment_id":224958,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10181536579","product_id":100039701,"comment_content":"所以，语句for ( x ...) ...语法中的标识符x是一个词法名字，应该由for语句为它创建一个（块级的）词法作用域来管理之。<br>老师，对于这句话，如果我运行以下代码<br>var x = 1;<br>let  y = 2;<br>那么javaScript也会创建两个作用域？一个变量作用域管理x，一个词法作用域管理y？<br>那么如果全局中已经存在了变量作用域和词法作用域<br>为什么for(let i =0....)中， 这个i不在刚才的词法作用域中声明，而要重新再创讲一个词法作用域？","like_count":2,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497671,"discussion_content":"一般的“块级作用域”所在的环境中并没有“变量作用域”。所以块级作用域只能放let/const。\n\n同时具有“变量作用域”和“词法作用域 ”的只有函数、全局和ES6之后的模块。所以，当在一个一般的“块级作用域”中声明了var的时候，它就必须被“提升”到上面三种环境中去存放。\n\n所以下面的代码中：\n```\nfor (...) {\n  var x = 1;\n  let y = 2;\n  ...\n```\n在这其中`y`是放在for的forBody块中的，而`x`是放在这个语句所在的、更外层的“变量作用域”中的。\n\n这个变量作用域并不是为上面两行代码“专门创建”的。但是for(let i =0....)中的“词法作用域 ”是为for语句专门创建的，因此它跟更外层的（例如全局）并不是同一个。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591906651,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203823,"user_name":"海绵薇薇","can_delete":false,"product_type":"c1","uid":1601296,"ip_address":"","ucode":"37C7CC2EB81909","user_header":"https://static001.geekbang.org/account/avatar/00/18/6f/10/bfbf81dc.jpg","comment_is_top":false,"comment_ctime":1586270533,"is_pvip":false,"replies":[{"id":"76733","content":"之所以一直没有回复，是因为我确实花了好些天的时间来理解这个说法。<br><br>如果你试图用loopEnv(i)来说明在每次迭代结束时存在一次抄写过程，那么你是对的。我们显然可以用如下方式来验证这个过程的存在：<br><br>```<br>for (const i of [1,2,3])<br>  setTimeout(<br>    function fff() { console.log(i) },<br>    1000);<br>```<br><br>如果不存在一个潜在的抄写过程，那么timeout结束后所有输出都应该是相同值；反过来，正是因为每次迭代都抄写，所以fff()才会有多个闭包，以及通过闭包引用到（多个不同的）loopEnv。<br><br>而你的示例（模拟代码）是说明了loopEnv的确是每次抄写了一个i值。与上例的意思是相同的。<br><br>最后，对于`for (let x = 100; ; x++) ...`这样的例子来说，抄写也一样会发生。同样，也是出于setTimeout中的函数闭包需要引用到（各自独立的）外部loopEnv的缘故。——而且，显而易见的，抄写必须发生成`x++`这个表达式执行之前。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1586629017,"ip_address":"","comment_id":203823,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10176205125","product_id":100039701,"comment_content":"老师好，关于forEnv和loopEnv和loopEnv的抄写是否可以简单模拟如下？<br><br>function forEnv() {<br>    for (var i = 0, len = 10; i &lt; len; i++) <br>\t(function loopEnv(i) {<br>\t    console.log(i)<br>\t}(i))<br>}<br><br>其中forEnv就可以被看做for(let i ...) ... 生成的forEnv。<br>循环体每次迭代进行的loopEnv抄写，被每次迭代生成的函数闭包所模拟。<br>","like_count":2,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490969,"discussion_content":"之所以一直没有回复，是因为我确实花了好些天的时间来理解这个说法。\n\n如果你试图用loopEnv(i)来说明在每次迭代结束时存在一次抄写过程，那么你是对的。我们显然可以用如下方式来验证这个过程的存在：\n\n```\nfor (const i of [1,2,3])\n  setTimeout(\n    function fff() { console.log(i) },\n    1000);\n```\n\n如果不存在一个潜在的抄写过程，那么timeout结束后所有输出都应该是相同值；反过来，正是因为每次迭代都抄写，所以fff()才会有多个闭包，以及通过闭包引用到（多个不同的）loopEnv。\n\n而你的示例（模拟代码）是说明了loopEnv的确是每次抄写了一个i值。与上例的意思是相同的。\n\n最后，对于`for (let x = 100; ; x++) ...`这样的例子来说，抄写也一样会发生。同样，也是出于setTimeout中的函数闭包需要引用到（各自独立的）外部loopEnv的缘故。——而且，显而易见的，抄写必须发生成`x++`这个表达式执行之前。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586629017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1338736,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6d/70/25ba4287.jpg","nickname":"明月","note":"","ucode":"D6586156BF09CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":543053,"discussion_content":"老师，如果这里的抄写是发生在 x++ 之前的，那么是不是意味在最后一次迭代结束后也后进行抄写，而这次抄写是多余的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640939891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":490969,"ip_address":""},"score":543053,"extra":""}]}]},{"had_liked":false,"id":191252,"user_name":"从未止步","can_delete":false,"product_type":"c1","uid":1792361,"ip_address":"","ucode":"17F310796CE8D5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI5jr1KfpLoXdoiaLzLswPiazCgCnyPkKhIqrEujPtGA1kryZYaruF8GmUTRRWn1YK71QVSTSVpwkzQ/132","comment_is_top":false,"comment_ctime":1584758371,"is_pvip":false,"replies":[{"id":"73430","content":"作用域的价值在于“容纳变量声明”，而代价是“每增加一级作用域，都会导致效率变差”。<br><br>而一般的for语句，以及`for (var ...`其实不需要在该语句的位置上声明变量，因此没有必要付出上述的高昂的代价。但是语法`for (let&#47;const ...`就需要一个作用域来放变量声明，并“隔开forBody区的变量声明”，所以就加入了这个作用域。<br><br>单语句不支持块级作用域，本质上就是尽量提高效率。——即使因此带来一些语法限制，也是在所不惜的。<br>","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1584792411,"ip_address":"","comment_id":191252,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10174692963","product_id":100039701,"comment_content":"老师，因为在循环后边的单语句中如果出现了词法声明，但是这时候其实单语句并没有块级作用域，需要重复声明创建作用域副本，来支持这个语句的执行，所以javaScript限制了这种情况的发生，可以这样理解嘛？ 谢谢老师～","like_count":2,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488139,"discussion_content":"作用域的价值在于“容纳变量声明”，而代价是“每增加一级作用域，都会导致效率变差”。\n\n而一般的for语句，以及`for (var ...`其实不需要在该语句的位置上声明变量，因此没有必要付出上述的高昂的代价。但是语法`for (let/const ...`就需要一个作用域来放变量声明，并“隔开forBody区的变量声明”，所以就加入了这个作用域。\n\n单语句不支持块级作用域，本质上就是尽量提高效率。——即使因此带来一些语法限制，也是在所不惜的。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584792411,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153398,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1574229943,"is_pvip":false,"replies":[{"id":"58977","content":"你可以在后面用var声明试试😊","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574239805,"ip_address":"","comment_id":153398,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10164164535","product_id":100039701,"comment_content":"为什么单语句（single-statement）中不能出现词法声明（ lexical declaration ）？<br>我觉得应该是语法规定 单语句后面需要一个表达式，而一个声明语句是不行的。","like_count":2,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475151,"discussion_content":"你可以在后面用var声明试试😊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574239805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153357,"user_name":"qqq","can_delete":false,"product_type":"c1","uid":1006786,"ip_address":"","ucode":"91B0ACF8CBE7BD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/c2/8ffd2ad0.jpg","comment_is_top":false,"comment_ctime":1574221932,"is_pvip":true,"replies":[{"id":"58966","content":"不是。<br><br>而是这种情况下并没有所谓的“块级作用域（变量作用域）”。<br><br>这就是需要仔细地“数”清楚一个语法有几个作用域的原因。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574233939,"ip_address":"","comment_id":153357,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10164156524","product_id":100039701,"comment_content":"单语句对应的是变量作用域，不能出现词法声明吗","like_count":2,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475135,"discussion_content":"不是。\n\n而是这种情况下并没有所谓的“块级作用域（变量作用域）”。\n\n这就是需要仔细地“数”清楚一个语法有几个作用域的原因。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574233939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":323302,"user_name":"👣","can_delete":false,"product_type":"c1","uid":2195962,"ip_address":"","ucode":"0998E775EC1957","user_header":"https://static001.geekbang.org/account/avatar/00/21/81/fa/542577c8.jpg","comment_is_top":false,"comment_ctime":1637826470,"is_pvip":false,"replies":[{"id":"117379","content":"我能明白你的意思，并且你的分析也是对的。但是，你混淆了一些概念，所以叙述出来就变得不那么清晰了和正确了。<br><br>比如“这里的虽然创建块级作用域， 但是没有声明自己的词法作用域”，实际上块级作用域只是抽象概念上的、对代码块的一个形式上的说明，它并不会有一个“（执行期创建出来的）块级作用域”。所以第二个例子中既没有词法作用域也没有块级作用域——如果不考虑那一对大括号的话。并且，这个例子中闭包是存在的，但闭包是属于箭头函数自己的，并不是for语句的作用域（或它的环境）。<br><br>你认为“需要多个词法作用域的原因是避免let&#47;const的重复声明”，简单地这样来理解是对的。而且也与可观察的事实相符。不过，我建议你考虑一下for循环迭代中的事实。因为，循环变量在连续两次迭代中可能会被重用——因此两次迭代应该分属于两个不同的词法环境。这也就是在ECMAScript规范中，for迭代结束（并且在下一次迭代开始之前）会将前一个环境中的名字复制到新环境的原因。","user_name":"作者回复","user_name_real":"编辑","uid":"1521669","ctime":1637934491,"ip_address":"","comment_id":323302,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5932793766","product_id":100039701,"comment_content":"老师。 我是这样理解的。 <br>1. 如果使用了 for（let &#47; const....) {} 在使用了let &#47; const 和 {} 会创建n个此法作用域 和 创建n个块级作用域。<br>    如果不是的话： 那么看一下代码<br>   for（let x in {name: 1, gae: 2}）{<br>     &#47;&#47; 在这里的话 会创建2个父级作用域 两个父级作用域下会有不同的块级作用于<br>      如果不是的话， 那么这里的x 不是重复声明 而是 重新赋值？ 但是如果是重新赋值 那么使用const的话 会报一个 重复创建的错误<br>    }<br>2。 如果使用了 for（var x ...)   这里的var 是创建在 上级作用域的 varNames里的 如果写在函数中则是创建在函数作用于中。。。。。<br>      for（var x  in {name: 1, age:2})  {<br>           setTimeout(_ =&gt; console.log(x), 1000)<br>           &#47;&#47; 这里的虽然创建块级作用域， 但是没有声明 自己的词法作用域。 在要执行宏任务的时候， 可能 循环已经完成 而x 已经是最新的值， 所以输出是 age 但是如果使用的是 let &#47; const。则x 是不同的key 应为， 他们创建了自己的词法作用域名， 所有哪怕10秒之后在执行的宏任务。依旧可以访问到。 forEvn中变量。 其实这里也算是一种闭包的使用是吗？<br>      }","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":533695,"discussion_content":"我能明白你的意思，并且你的分析也是对的。但是，你混淆了一些概念，所以叙述出来就变得不那么清晰了和正确了。\n\n比如“这里的虽然创建块级作用域， 但是没有声明自己的词法作用域”，实际上块级作用域只是抽象概念上的、对代码块的一个形式上的说明，它并不会有一个“（执行期创建出来的）块级作用域”。所以第二个例子中既没有词法作用域也没有块级作用域——如果不考虑那一对大括号的话。并且，这个例子中闭包是存在的，但闭包是属于箭头函数自己的，并不是for语句的作用域（或它的环境）。\n\n你认为“需要多个词法作用域的原因是避免let/const的重复声明”，简单地这样来理解是对的。而且也与可观察的事实相符。不过，我建议你考虑一下for循环迭代中的事实。因为，循环变量在连续两次迭代中可能会被重用——因此两次迭代应该分属于两个不同的词法环境。这也就是在ECMAScript规范中，for迭代结束（并且在下一次迭代开始之前）会将前一个环境中的名字复制到新环境的原因。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637934491,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221256,"user_name":"Geek_8d73e3","can_delete":false,"product_type":"c1","uid":1961902,"ip_address":"","ucode":"FF89629117B96C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epneC3LXv0Ve2tCXPfvsXtRb5StVicNCEHUSfzneLYUDJ03B6ocINHzeLf94aw0dEkjLShSdK9NUoA/132","comment_is_top":false,"comment_ctime":1590456747,"is_pvip":false,"replies":[{"id":"81600","content":"和前一个你问的问题一样。所谓“try块”，亦即是`try { ... }`是一个作用域，而if后面的“块语句”也是一个独立的作用域。不冲突。<br><br>`if (...)`语句没有块级作用域，但它后面的“一对大括号{}”是一个独立的块语句，有自己的块级作用域。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1590459767,"ip_address":"","comment_id":221256,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5885424043","product_id":100039701,"comment_content":"老师，我发现这行代码会输出1000。这是为什么呀<br>      let x = 1000;<br>      try{<br>        console.log(x);<br><br>        if(true){<br>          let x = 100;<br>        }<br><br>      }catch(e){<br>        console.log(e)<br>      }","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496403,"discussion_content":"和前一个你问的问题一样。所谓“try块”，亦即是`try { ... }`是一个作用域，而if后面的“块语句”也是一个独立的作用域。不冲突。\n\n`if (...)`语句没有块级作用域，但它后面的“一对大括号{}”是一个独立的块语句，有自己的块级作用域。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590459767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206509,"user_name":"蔡孟泳","can_delete":false,"product_type":"c1","uid":1550692,"ip_address":"","ucode":"898007381B5C83","user_header":"https://static001.geekbang.org/account/avatar/00/17/a9/64/819fccec.jpg","comment_is_top":false,"comment_ctime":1586872318,"is_pvip":false,"replies":[{"id":"77384","content":"在JavaScript中的话，这个问题就与存储无关，因为一般Array是采用key&#47;value对存储的，没有“连续存储”的问题。<br><br>但是数组在抽象概念上还是顺序存储和顺序访问，因此shift()方法之类还是会导致索引重排，这样的操作代价并不低。因此从数组尾部弹出(pop)还是比首部移除(shift)要经济和高效，这可能是倒序处理的唯一合法理由了（在JavaScript中）。<br><br>绝大多数算法，如果是连续处理的话，正序和倒序并没有区别。就好象有正无穷和负无穷一样，向索引（下标）的哪一个方向做极值处理，在数学&#47;算法上并没有明显的不同。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1587015696,"ip_address":"","comment_id":206509,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5881839614","product_id":100039701,"comment_content":"老师 请问下 有时候会采用数组倒序来有话，原理是？因为数组是顺序存储结构？","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491814,"discussion_content":"在JavaScript中的话，这个问题就与存储无关，因为一般Array是采用key/value对存储的，没有“连续存储”的问题。\n\n但是数组在抽象概念上还是顺序存储和顺序访问，因此shift()方法之类还是会导致索引重排，这样的操作代价并不低。因此从数组尾部弹出(pop)还是比首部移除(shift)要经济和高效，这可能是倒序处理的唯一合法理由了（在JavaScript中）。\n\n绝大多数算法，如果是连续处理的话，正序和倒序并没有区别。就好象有正无穷和负无穷一样，向索引（下标）的哪一个方向做极值处理，在数学/算法上并没有明显的不同。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587015696,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204040,"user_name":"HoSalt","can_delete":false,"product_type":"c1","uid":1156074,"ip_address":"","ucode":"610B03E2A002D1","user_header":"https://static001.geekbang.org/account/avatar/00/11/a3/ea/53333dd5.jpg","comment_is_top":false,"comment_ctime":1586323626,"is_pvip":false,"replies":[{"id":"76419","content":"with的比较好证明的，因为它的作用域中有可访问的名字。例如：<br>```<br>var obj = { a: 100 };<br>var a = 200;<br><br>&#47;&#47; 输出100，证明跟它外部的变量a并不处于同一个作用域中<br>with (obj) console.log(a);<br>```","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1586399168,"ip_address":"","comment_id":204040,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5881290922","product_id":100039701,"comment_content":"&#47;&#47;（注：没有使用大括号）<br>with (x) &#47;* 作用域1 *&#47;; &#47;&#47; &lt;- 这里存在一个块级作用域<br><br>with 没有大括号却有作用域能怎么体现（证明）吗？","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491052,"discussion_content":"with的比较好证明的，因为它的作用域中有可访问的名字。例如：\n```\nvar obj = { a: 100 };\nvar a = 200;\n\n// 输出100，证明跟它外部的变量a并不处于同一个作用域中\nwith (obj) console.log(a);\n```","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586399168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184991,"user_name":"Aiden","can_delete":false,"product_type":"c1","uid":1376627,"ip_address":"","ucode":"3B0FA384541943","user_header":"https://static001.geekbang.org/account/avatar/00/15/01/73/a3bbaab9.jpg","comment_is_top":false,"comment_ctime":1583463722,"is_pvip":false,"replies":[{"id":"71491","content":"不。块语句内即使没有let&#47;const，块语句依然会有一个块作用域。这是语法形式导致的结果，而不受语句执行中“是&#47;否”有let、const声明等等影响。<br><br>块语句就是一对大括号。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1583470362,"ip_address":"","comment_id":184991,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5878431018","product_id":100039701,"comment_content":"&gt; 一些简单的、显而易见的块级作用域包括：<br><br>这里没看懂第三点<br>1；try catch finally 会形成块作用域<br>2：with会形成块作用域<br>3：快语句是个啥？<br><br>我的理解是块语句要和let const配置使用才会形成块作用域。","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486205,"discussion_content":"不。块语句内即使没有let/const，块语句依然会有一个块作用域。这是语法形式导致的结果，而不受语句执行中“是/否”有let、const声明等等影响。\n\n块语句就是一对大括号。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583470362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182456,"user_name":"红白十万一只","can_delete":false,"product_type":"c1","uid":1659901,"ip_address":"","ucode":"7170636C924D93","user_header":"https://static001.geekbang.org/account/avatar/00/19/53/fd/db2cac71.jpg","comment_is_top":false,"comment_ctime":1582790715,"is_pvip":false,"replies":[{"id":"70657","content":"最后一句问得不对。<br>{}并没有“强制创建作用域”这样的能力。<br>单语句就是“没有创建作用域”的语句。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1582820670,"ip_address":"","comment_id":182456,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5877758011","product_id":100039701,"comment_content":"根据ECMAScript 规范第 13.7.4.7 节<br>for循环的var和let、const处理是不同的<br>var的就不说了，老师已经说得很明白了。会变量提升至当前作用域<br>而let和const：<br>for (let i = 0; i &lt; 3; i++) {<br>  let i = &#39;a&#39;;<br>  console.log(i);<br>}<br>输出 a a a<br>其实底层处理时在for (let i = 0; i &lt; 3; i++)这个括号内有一个隐藏作用域<br>每次迭代循环时都创建一个新变量i，并以之前迭代中同名变量(i)的值将其初始化<br>所以这三次循环相当于(伪)<br>(let i=0){<br>  let i = &#39;a&#39;;<br>  console.log(i);<br>}<br>(let i=1){<br>  let i = &#39;a&#39;;<br>  console.log(i);<br>}<br>(let i=2){<br>  let i = &#39;a&#39;;<br>  console.log(i);<br>}<br>这就是let、const在for(有{}的情况下)是有两个作用域的。另外for (const i = 0; i &lt; 3; i++) 会报错，因为虽然const i是重新生成的，但是i++修改了i这个值，const又是常量无法修改导致报错<br>最后<br>单语句中不能出现词法声明，是因为没有使用{}强制创建作用域，无法词法声明么？","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485344,"discussion_content":"最后一句问得不对。\n{}并没有“强制创建作用域”这样的能力。\n单语句就是“没有创建作用域”的语句。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582820670,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1659901,"avatar":"https://static001.geekbang.org/account/avatar/00/19/53/fd/db2cac71.jpg","nickname":"红白十万一只","note":"","ucode":"7170636C924D93","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":188949,"discussion_content":"明白了，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582824959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161419,"user_name":"蛋黄酱","can_delete":false,"product_type":"c1","uid":1050196,"ip_address":"","ucode":"2351562F282B68","user_header":"https://static001.geekbang.org/account/avatar/00/10/06/54/16bb64d0.jpg","comment_is_top":false,"comment_ctime":1576203296,"is_pvip":false,"replies":[{"id":"61529","content":"那样的话，也是{}这个块语句自己的块级作用域啊。{}是一个语句呢，放在switch语句之内，就变成好子级的语法树了。而`if () {}`等等也是如此，if自己没有块级作用域，而`{}`是它子级的语法树。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1576208828,"ip_address":"","comment_id":161419,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5871170592","product_id":100039701,"comment_content":"老师，switch case 如果加了{} 就会转成块级作用域了吧。<br>正在用AST写工具，测switch的时候并没有意识到case的作用域问题，现在感觉最好把ecma读一遍。","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477714,"discussion_content":"那样的话，也是{}这个块语句自己的块级作用域啊。{}是一个语句呢，放在switch语句之内，就变成好子级的语法树了。而`if () {}`等等也是如此，if自己没有块级作用域，而`{}`是它子级的语法树。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576208828,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153741,"user_name":"Fans","can_delete":false,"product_type":"c1","uid":1743350,"ip_address":"","ucode":"D3A068FD3C0A83","user_header":"https://static001.geekbang.org/account/avatar/00/1a/99/f6/b1310a47.jpg","comment_is_top":false,"comment_ctime":1574301464,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5869268760","product_id":100039701,"comment_content":"看到标题感觉的终于有一个可能会看的懂了","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54606,"discussion_content":"努力！加油！Yeah~ 然后……看懂了报个告呀！^&amp;^","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574304553,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153344,"user_name":"Chao","can_delete":false,"product_type":"c1","uid":1108745,"ip_address":"","ucode":"DD7742F5537521","user_header":"https://static001.geekbang.org/account/avatar/00/10/eb/09/ba5f0135.jpg","comment_is_top":false,"comment_ctime":1574220383,"is_pvip":false,"replies":[{"id":"58967","content":"临时死区 = ？","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574233980,"ip_address":"","comment_id":153344,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5869187679","product_id":100039701,"comment_content":"临时死区使得 通过let &#47; const 定义的变量。 在定义之前调用报错。","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475130,"discussion_content":"临时死区 = ？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574233980,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358353,"user_name":"😁陈哲奇","can_delete":false,"product_type":"c1","uid":1121237,"ip_address":"江苏","ucode":"3EFD41A04C923C","user_header":"https://static001.geekbang.org/account/avatar/00/11/1b/d5/0cae2c5b.jpg","comment_is_top":false,"comment_ctime":1664244508,"is_pvip":true,"replies":[{"id":"130851","content":"这里的forEnv就是for语句的那个lexEnv","user_name":"作者回复","user_name_real":"编辑","uid":"1521669","ctime":1665812862,"ip_address":"江苏","comment_id":358353,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1664244508","product_id":100039701,"comment_content":"ECMA规范中并没有看到 forEnv 的描述，只有 loopEnv 和 (this)InterrationEnv，循环变量 i 是在 loopEnv 中创建的，每次循环，InterrationEnv 都会从上一个 InterrationEnv 中拷贝新的变量值（一般是经过了 increment 后的变量值）。<br><br>这个和文章中的描述并不一致。<br><br>https:&#47;&#47;262.ecma-international.org&#47;13.0&#47;#sec-forbodyevaluation","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590488,"discussion_content":"这里的forEnv就是for语句的那个lexEnv","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665812862,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346286,"user_name":"Andy259","can_delete":false,"product_type":"c1","uid":1137496,"ip_address":"","ucode":"B47AF1E71C9DD3","user_header":"https://static001.geekbang.org/account/avatar/00/11/5b/58/eca3578b.jpg","comment_is_top":false,"comment_ctime":1653004207,"is_pvip":false,"replies":[{"id":"126374","content":"是的。作用域是下一篇中的环境的基础。事实上，名字、作用域和表达式执行都是“运行环境”的基础组件，这是第一篇与第二篇之间的衔接关系。","user_name":"作者回复","user_name_real":"编辑","uid":"1521669","ctime":1653101423,"ip_address":"","comment_id":346286,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1653004207","product_id":100039701,"comment_content":"我觉得本文的重点在于作用域出现的目的，是为了解决什么问题。最重要的可能是为了对标识符的管理。","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572952,"discussion_content":"是的。作用域是下一篇中的环境的基础。事实上，名字、作用域和表达式执行都是“运行环境”的基础组件，这是第一篇与第二篇之间的衔接关系。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653101423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336883,"user_name":"圆满","can_delete":false,"product_type":"c1","uid":1038192,"ip_address":"","ucode":"99A2625FDE8357","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d7/70/5d8bc78d.jpg","comment_is_top":false,"comment_ctime":1646447847,"is_pvip":false,"replies":[{"id":"123127","content":"刚试了没问题呀？<br>```<br>Welcome to Node.js v13.14.0.<br>Type &quot;.help&quot; for more information.<br>&gt; .editor<br>&#47;&#47; Entering editor mode (^D to finish, ^C to cancel)<br>let a = 13;<br>if (true) {<br>  let a = 12;<br>}<br>console.log(a)<br><br>13<br>```","user_name":"作者回复","user_name_real":"编辑","uid":"1521669","ctime":1646494510,"ip_address":"","comment_id":336883,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1646447847","product_id":100039701,"comment_content":"for(let i = 0;i&lt;10;i++){<br>        let i = 1000;<br>        console.log(i);<br>      }<br>这段代码不报错 看到评论里 老师说是因为在两个作用域里面。前者是forEnv，后者是bodyEnv。<br>那bodyEnv是属于forEnv子作用域吧，不然不也能访问到 forEnv里面的变量了.<br><br>同样的父子集作用域 <br>let a = 13<br>if(true){<br>    let a = 14<br>}<br>这种就会报错呢？不明白为什么","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554623,"discussion_content":"刚试了没问题呀？\n```\nWelcome to Node.js v13.14.0.\nType &#34;.help&#34; for more information.\n&gt; .editor\n// Entering editor mode (^D to finish, ^C to cancel)\nlet a = 13;\nif (true) {\n  let a = 12;\n}\nconsole.log(a)\n\n13\n```","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646494510,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336802,"user_name":"冷静冷静  再冷静","can_delete":false,"product_type":"c1","uid":2250102,"ip_address":"","ucode":"EDFED21A3B488F","user_header":"https://static001.geekbang.org/account/avatar/00/22/55/76/f880a299.jpg","comment_is_top":false,"comment_ctime":1646376509,"is_pvip":false,"replies":[{"id":"123099","content":"如果a未被声明过，那么typeof a中的a将是一个Unresolvable Reference（这里的“引用（规范类型）”；而一旦它被let&#47;const&#47;var，甚至是被import&#47;class&#47;function声明过，那么在typeof a中，它就是一个“有效的”引用，因为它总是一个既已存在的名字。<br><br>typeof这个运算总是对Unresolvable Reference返回undefined，这在历史中就是这样设计的，并且也正是这个undefined的语义所在。所以你的示例1正常执行，且返回undefined。<br><br>但是对于一个“有效的、已存在的引用”，typeof的返回就取决于这个引用的当前性质。let声明的变量a总是在当前作用域初始时就开始存在。——也就是说它是静态的、预先创建在当前作用域中的。只不是它被创建为一个“未初始化的名字（uninitialized binding）”。包括delete&#47;typeof等等所有任何方式的操作都不能作用于这样一个名字（亦即是“引用”），如果这样做就会返回异常。这要一直等到代码执行到“let a = 1”这一行时，才会完成它的实始化。——也就是说，对uninitialized binding只能做初始赋值操作，其它运算都是失效的、异常的。<br><br>所以你的示例2执行异常。<br><br>另外，var a声明将在当前的变量作用域中创建“初始化为undefined的名字”，所以它在执行到声明语句之前就可以访问，包括typeof&#47;delete甚至是console.log(a)等等。其实，let a与var a声明的都是一个名字，处理过程也一样，区别只在于是否在作用域创建时就初始化（为undefined）而已。","user_name":"作者回复","user_name_real":"作者","uid":"1521669","ctime":1646409888,"ip_address":"","comment_id":336802,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1646376509","product_id":100039701,"comment_content":"老师，你好，<br>console.log(typeof a ) &#47;&#47; undefined<br>*********<br>console.log(typeof a ) <br>let a = 1 <br>就会报错呢<br>这个具体是什么原因呢","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554513,"discussion_content":"如果a未被声明过，那么typeof a中的a将是一个Unresolvable Reference（这里的“引用（规范类型）”；而一旦它被let/const/var，甚至是被import/class/function声明过，那么在typeof a中，它就是一个“有效的”引用，因为它总是一个既已存在的名字。\n\ntypeof这个运算总是对Unresolvable Reference返回undefined，这在历史中就是这样设计的，并且也正是这个undefined的语义所在。所以你的示例1正常执行，且返回undefined。\n\n但是对于一个“有效的、已存在的引用”，typeof的返回就取决于这个引用的当前性质。let声明的变量a总是在当前作用域初始时就开始存在。——也就是说它是静态的、预先创建在当前作用域中的。只不是它被创建为一个“未初始化的名字（uninitialized binding）”。包括delete/typeof等等所有任何方式的操作都不能作用于这样一个名字（亦即是“引用”），如果这样做就会返回异常。这要一直等到代码执行到“let a = 1”这一行时，才会完成它的实始化。——也就是说，对uninitialized binding只能做初始赋值操作，其它运算都是失效的、异常的。\n\n所以你的示例2执行异常。\n\n另外，var a声明将在当前的变量作用域中创建“初始化为undefined的名字”，所以它在执行到声明语句之前就可以访问，包括typeof/delete甚至是console.log(a)等等。其实，let a与var a声明的都是一个名字，处理过程也一样，区别只在于是否在作用域创建时就初始化（为undefined）而已。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646409888,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":267298,"user_name":"龙眼","can_delete":false,"product_type":"c1","uid":1383962,"ip_address":"","ucode":"8549009E822429","user_header":"https://static001.geekbang.org/account/avatar/00/15/1e/1a/e748832f.jpg","comment_is_top":false,"comment_ctime":1607673260,"is_pvip":false,"replies":[{"id":"97165","content":"这几个例子是在讨论“语句”的作用域。以`if (...) { ... }`为例，这里并不是习惯上认为的“是一个if语句”，而是“一个if语句，和一个块语句”，是两个语句。<br><br>在ES中，并不是用“数{}个数”来对应找到作用域的。某些语句有，而另一些没有作用域，是在语言设计时就确定好的。例如with (...) ...，它并没有大括号，但确实就存在一个作用域。关于语句在作用域上的设计，在《JavaScript语言精髓与编程实践》第4.4章节中专门有一个表格来列出。并且，需要强调的是，所谓作用域，在这里讨论的是“语言的结构化”的问题，是语言的设计，而不是编程。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1607823618,"ip_address":"","comment_id":267298,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1607673260","product_id":100039701,"comment_content":"三个例子一个特例的说法有问题，三个例子应该去掉，一个特例进行了，因为在es6中，只要遇到{}那就是一个作用域，只是for为了保存forENV的变量做了特殊处理而已。","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511585,"discussion_content":"这几个例子是在讨论“语句”的作用域。以`if (...) { ... }`为例，这里并不是习惯上认为的“是一个if语句”，而是“一个if语句，和一个块语句”，是两个语句。\n\n在ES中，并不是用“数{}个数”来对应找到作用域的。某些语句有，而另一些没有作用域，是在语言设计时就确定好的。例如with (...) ...，它并没有大括号，但确实就存在一个作用域。关于语句在作用域上的设计，在《JavaScript语言精髓与编程实践》第4.4章节中专门有一个表格来列出。并且，需要强调的是，所谓作用域，在这里讨论的是“语言的结构化”的问题，是语言的设计，而不是编程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607823618,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262437,"user_name":"Geek_zy1991","can_delete":false,"product_type":"c1","uid":1640823,"ip_address":"","ucode":"3E9DBB03DE6D9A","user_header":"","comment_is_top":false,"comment_ctime":1605721761,"is_pvip":false,"replies":[{"id":"95310","content":"只有一个关键处你忽略了，就是每次的iterationEnv将是一个“完整拷贝”，而不是仅仅将parent指向forEnv。这个每次的拷贝是消耗很大的，关于这一点请参见：<br>https:&#47;&#47;tc39.es&#47;ecma262&#47;#sec-createperiterationenvironment<br>对于for..in&#47;of来说稍复杂一点，但目标是一致的，可以用iterationEnv关键字在ecmascript仔细看一下。<br><br>关于第二点，`i in x`是指在x的属性中取名字到`i`，这个过程发生在创建iterationEnv之前。很显然，如果`i in x`发生在iterationEnv创建之后，那么当`x`没有任何属性时，iterationEnv就会白白地创建一次；同理，这样一来，`i in x`也总会在循环结束时多创建一iterationEnv。——这显然是不应该的。<br>但是，对于这个过程来说，更加需要留意的细节是：取得这个名字`i`发生在创建iterationEnv之前，但却是在创建iterationEnv之后，才将它绑定到该环境中的。也就是说，这里分成了两步，一步用于判断“是否需要继续循环”，另一步用于“向iterationEnv绑定值”。关于这一点，你可以用“Perform BindingInstantiation for lhs passing iterationEnv as the argument”这个语句在ECMAScript中查找。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1605805185,"ip_address":"","comment_id":262437,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1605721761","product_id":100039701,"comment_content":"老师你好，看完本节内容我反而对这段代码弄不明白了，<br>for (let i in x)  setTimeout(()=&gt;console.log(i), 1000);<br>按本节所讲，执行到for语句的时候，创建了作用域forEnv和loopEnv，然后每次迭代都会创建loopEnv的副本iterationEnv。有以下两点不清楚：<br>第一点：let i对应在forEnv中，也就是说在forEnv中登记i；i in x放到每次迭代中执行，也就是在每次迭代中只是相当于给i赋值，并没有在iterationEnv中登记i；但是当执行定时器时，会分别在每个定时器对应的iteratonEnv中找i，但是i不是登记在这里的，所以会沿着作用域链往上找，找到forEnv，这个forEnv不是只有一个吗？那么在它里面可以找到登记的i，但是这个值此时此刻只会是某一个具体的值（最后一个迭代中对i操作后的值），这样分析就与实际结果不对了，但是并不知道分析哪里出问题了。<br>第二点：i in x，此语句是对应在loopEnv中执行，然后再根据loopEnv复制出本次迭代所需的iterationEnv；还是说先为本次迭代根据loopEnv复制出iterationEnv，然后在iterationEnv执行i in x呢？<br>请老师解惑，谢谢","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509832,"discussion_content":"只有一个关键处你忽略了，就是每次的iterationEnv将是一个“完整拷贝”，而不是仅仅将parent指向forEnv。这个每次的拷贝是消耗很大的，关于这一点请参见：\nhttps://tc39.es/ecma262/#sec-createperiterationenvironment\n对于for..in/of来说稍复杂一点，但目标是一致的，可以用iterationEnv关键字在ecmascript仔细看一下。\n\n关于第二点，`i in x`是指在x的属性中取名字到`i`，这个过程发生在创建iterationEnv之前。很显然，如果`i in x`发生在iterationEnv创建之后，那么当`x`没有任何属性时，iterationEnv就会白白地创建一次；同理，这样一来，`i in x`也总会在循环结束时多创建一iterationEnv。——这显然是不应该的。\n但是，对于这个过程来说，更加需要留意的细节是：取得这个名字`i`发生在创建iterationEnv之前，但却是在创建iterationEnv之后，才将它绑定到该环境中的。也就是说，这里分成了两步，一步用于判断“是否需要继续循环”，另一步用于“向iterationEnv绑定值”。关于这一点，你可以用“Perform BindingInstantiation for lhs passing iterationEnv as the argument”这个语句在ECMAScript中查找。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605805185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330039,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqy8OyLoqgLmRZCAibvth9NhmOacHn2WRlurJML4d14BSQcORjeTz3wYvAuguCQiawgMHz7wXsaib22Q/132","nickname":"刘闻道","note":"","ucode":"E0D3795BD6334A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378890,"discussion_content":"有点明白了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623490213,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244182,"user_name":"‏5102","can_delete":false,"product_type":"c1","uid":2116537,"ip_address":"","ucode":"476092AB890CF2","user_header":"https://static001.geekbang.org/account/avatar/00/20/4b/b9/2449c7b7.jpg","comment_is_top":false,"comment_ctime":1598420491,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598420491","product_id":100039701,"comment_content":"这就是为什么for（var...）性能比for(const&#47;let...)好的原因","like_count":0},{"had_liked":false,"id":240045,"user_name":"Geek_885849","can_delete":false,"product_type":"c1","uid":1740861,"ip_address":"","ucode":"2054C0DD8D4A64","user_header":"","comment_is_top":false,"comment_ctime":1596725582,"is_pvip":false,"replies":[{"id":"88663","content":"是。多个迭代的thisIterationEnv之间是平级的，它们是oldEnv是fork。所以我一直只是说它们的个数跟递归是一样的，但嵌套的深度还是递归要深些的（当然尾递归的处理又是另一回事了）。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1596782242,"ip_address":"","comment_id":240045,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1596725582","product_id":100039701,"comment_content":"https:&#47;&#47;tc39.es&#47;ecma262&#47;#sec-createperiterationenvironment<br>老师为什么这里给我的感觉 iterationenv和loopenv是平级关系呢,<br>首先running execution context 是loopenv吧? 然后loopenv.[[OuterEnv]]是oldenv,<br>然后 thisIterationEnv.[[OuterEnv]]等于oldenv吧?","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503318,"discussion_content":"是。多个迭代的thisIterationEnv之间是平级的，它们是oldEnv是fork。所以我一直只是说它们的个数跟递归是一样的，但嵌套的深度还是递归要深些的（当然尾递归的处理又是另一回事了）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596782242,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240006,"user_name":"Geek_885849","can_delete":false,"product_type":"c1","uid":1740861,"ip_address":"","ucode":"2054C0DD8D4A64","user_header":"","comment_is_top":false,"comment_ctime":1596711602,"is_pvip":false,"replies":[{"id":"88664","content":"是。上面的回复中有解释了。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1596782274,"ip_address":"","comment_id":240006,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1596711602","product_id":100039701,"comment_content":"老师你好,forenv是不是可以理解为规范中的oldenv啊,而loopenv是存储迭代计数i的环境,每次循环都会创建的环境抄写自loopenv,也就是说跟loopenv是平级关系 而不是父子关系","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503303,"discussion_content":"是。上面的回复中有解释了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596782274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":231671,"user_name":"Geek_885849","can_delete":false,"product_type":"c1","uid":1740861,"ip_address":"","ucode":"2054C0DD8D4A64","user_header":"","comment_is_top":false,"comment_ctime":1593745279,"is_pvip":false,"replies":[{"id":"85965","content":"这个我之前倒是没注意到。<br><br>他的指示是“单语句中不能声明...”，我想是解释器将“a: ...”这样的标签化语句处理成了单语句的缘故。关于单语句，虽然ECMAScript中没有什么说明，但确实是没有办法在其中声明标识符的，因为它没有自有的词法作用域（块级作用域）。<br><br>至于“标签化语句”为什么是单语句，这个就完全不在ECMAScript中的解释中了。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1594175415,"ip_address":"","comment_id":231671,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1593745279","product_id":100039701,"comment_content":"老师你好,,为什么 a:let b=123;  也会报错呢","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500400,"discussion_content":"这个我之前倒是没注意到。\n\n他的指示是“单语句中不能声明...”，我想是解释器将“a: ...”这样的标签化语句处理成了单语句的缘故。关于单语句，虽然ECMAScript中没有什么说明，但确实是没有办法在其中声明标识符的，因为它没有自有的词法作用域（块级作用域）。\n\n至于“标签化语句”为什么是单语句，这个就完全不在ECMAScript中的解释中了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594175415,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224955,"user_name":"Geek_8d73e3","can_delete":false,"product_type":"c1","uid":1961902,"ip_address":"","ucode":"FF89629117B96C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epneC3LXv0Ve2tCXPfvsXtRb5StVicNCEHUSfzneLYUDJ03B6ocINHzeLf94aw0dEkjLShSdK9NUoA/132","comment_is_top":false,"comment_ctime":1591601341,"is_pvip":false,"replies":[{"id":"83240","content":"另一个回复中应该已经解释了这个问题。顶层函数名与var声明的处理逻辑是一样的，都会被“提升”。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1591906698,"ip_address":"","comment_id":224955,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591601341","product_id":100039701,"comment_content":"函数内部的顶层函数名是提升到变量作用域中来管理的。老师这句话怎么理解?","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497668,"discussion_content":"另一个回复中应该已经解释了这个问题。顶层函数名与var声明的处理逻辑是一样的，都会被“提升”。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591906698,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217110,"user_name":"Ppei","can_delete":false,"product_type":"c1","uid":1369514,"ip_address":"","ucode":"C354F8EF0C5814","user_header":"https://static001.geekbang.org/account/avatar/00/14/e5/aa/57926594.jpg","comment_is_top":false,"comment_ctime":1589421577,"is_pvip":false,"replies":[{"id":"80450","content":"这个“多少会”是不确定的。就好象“多咸是咸”一样，没法量化。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1589508805,"ip_address":"","comment_id":217110,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589421577","product_id":100039701,"comment_content":"老师，在相同的for循环逻辑下，创建块级作用域多少会对性能的影响。如果符合逻辑，以下代码的性能是不是这样：<br>for(var x= ..) ... &gt;  for(var x= ..) { ... }  &gt;  for(let x= ..) { ... }","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495041,"discussion_content":"这个“多少会”是不确定的。就好象“多咸是咸”一样，没法量化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589508805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215999,"user_name":"HoSalt","can_delete":false,"product_type":"c1","uid":1156074,"ip_address":"","ucode":"610B03E2A002D1","user_header":"https://static001.geekbang.org/account/avatar/00/11/a3/ea/53333dd5.jpg","comment_is_top":false,"comment_ctime":1589165324,"is_pvip":false,"replies":[{"id":"80069","content":"loopEnv和iterationEnv都是ECMAScript中真实存在的。这一部分的内容也是对ECMAScript的解读，并且也确实会发生抄写。<br><br>关于这一部分，你可以读一下：<br>https:&#47;&#47;tc39.es&#47;ecma262&#47;#sec-forbodyevaluation<br><br>关于其中的 CreatePerIterationEnvironment()，此外ECMAScript一共有两处是涉及这个相关处理的，处理逻辑也并不完全一致。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1589250441,"ip_address":"","comment_id":215999,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1589165324","product_id":100039701,"comment_content":"「对于forBody来说，它每一次循环都需要创建一个iterationEnv，这个iterationEnv抄写自loopEnv。——注意这里是抄写，而不是简单地将parent指向loopEnv，所以它确实比较消耗资源。（再次说明，loopEnv的parent指向forEnv，但iterationEnv是抄写loopEnv而不是指向它）」<br><br>是将 loopEnv 的 变量的信息复制到每次新创建的 iterationEnv 中吗？<br><br>for(let i = 1; i &lt; 10; i++) {<br>    console.log(i)<br>    i += 2<br>}<br><br>如果是复制上面的 i+= 2 实际上是改变的 iterationEnv 中的值，但改变 iterationEnv 中的 i 似乎不能影响循环的次数，因为 iterationEnv 抄自 loopEnv，而 bodyEnv 的作用域链上并没有 loopEnv，但实际上却是影响了，这是什么原因导致的？<br><br>基于上面的问题 loopEnv 是实际存在的吗，不太清楚老师是否为了说明 iterationEnv 而提出来的？<br><br>最后一个问题，对于单语句，其是和iterationEnv共享一个作用域？<br><br>谢谢老师<br>","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494634,"discussion_content":"loopEnv和iterationEnv都是ECMAScript中真实存在的。这一部分的内容也是对ECMAScript的解读，并且也确实会发生抄写。\n\n关于这一部分，你可以读一下：\nhttps://tc39.es/ecma262/#sec-forbodyevaluation\n\n关于其中的 CreatePerIterationEnvironment()，此外ECMAScript一共有两处是涉及这个相关处理的，处理逻辑也并不完全一致。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589250441,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1338736,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6d/70/25ba4287.jpg","nickname":"明月","note":"","ucode":"D6586156BF09CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544440,"discussion_content":"其实真实的答案在对 👣的回复中：\n在for循环的每次迭代中，会进行“完全拷贝”。这里的“完全拷贝”是指在后一次迭代会复制前一次迭代词法作用域中的变量已经变量的值，同时生成新的词法作用域。\nfor(let i = 1; i &lt; 10; i++) {\n    console.log(i)\n    i += 2\n}\n至于你的这个例子中，在前一次迭代中操作了 i 值（这里包含i += 2 以及 i++），那么下一次的迭代会复制被你操作过的 i 值作为初始值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641523259,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1338736,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6d/70/25ba4287.jpg","nickname":"明月","note":"","ucode":"D6586156BF09CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544165,"discussion_content":"在老师后续的回复中有，iterationEnv抄写自loopEnv，同时它的parent还是指向loopEnv的。同时你提问中的事例也好解释，换一个更直观的例子吧：\nfor (let i = 0; i &lt; 5; i++)\n    (function fff() {\n        i++;         \n        console.log(i); // 1 3 5\n    }(i)); \nfor (let i = 0; i &lt; 5; i++)\n    (function fff(i) {// 作为func的参数\n        i++;         \n        console.log(i);  // 1 2 3 4 5\n    }(i));\n原因就在于：虽然在iterationEnv形成了一个闭包，但是如果操作的变量在当前闭包中无法找到那么还是得往上一层的作用域中查找","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641434361,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211904,"user_name":"🐒🐱🐭🐮🐯🐰🐶","can_delete":false,"product_type":"c1","uid":1189080,"ip_address":"","ucode":"52426AE36A9A39","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/d8/aa41d743.jpg","comment_is_top":false,"comment_ctime":1588037557,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588037557","product_id":100039701,"comment_content":"每读一边，就会有新得发现，令人振奋！","like_count":0},{"had_liked":false,"id":203916,"user_name":"HoSalt","can_delete":false,"product_type":"c1","uid":1156074,"ip_address":"","ucode":"610B03E2A002D1","user_header":"https://static001.geekbang.org/account/avatar/00/11/a3/ea/53333dd5.jpg","comment_is_top":false,"comment_ctime":1586306657,"is_pvip":false,"replies":[{"id":"76271","content":"是的。”非简单参数”会导致一个临时作用域。这个课程里也讲到过这种情况～","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1586320761,"ip_address":"","comment_id":203916,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1586306657","product_id":100039701,"comment_content":"老师，之前看到说用到es6特性的函数申明，形参那儿会形成一个临时的作用域？","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491001,"discussion_content":"是的。”非简单参数”会导致一个临时作用域。这个课程里也讲到过这种情况～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586320761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185012,"user_name":"Aiden","can_delete":false,"product_type":"c1","uid":1376627,"ip_address":"","ucode":"3B0FA384541943","user_header":"https://static001.geekbang.org/account/avatar/00/15/01/73/a3bbaab9.jpg","comment_is_top":false,"comment_ctime":1583465817,"is_pvip":false,"replies":[{"id":"71490","content":"确实是没有。<br><br>if语句的语法是:<br><br>&gt; if (...) aSatament<br><br>只是因为上面示例中aSatament用了一个块语句，所以这个“块级作用域”是块语句的，而不是if语句的。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1583470256,"ip_address":"","comment_id":185012,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1583465817","product_id":100039701,"comment_content":"其它的语句都是没有块级作用域的。例如`if`条件语句的几种常见书写形式：<br>-------<br>if(true) {<br><br>    let a = 1<br>}<br><br>这种情况下也没有块级作用域吗 咋觉得这一节看不懂呢","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486213,"discussion_content":"确实是没有。\n\nif语句的语法是:\n\n&amp;gt; if (...) aSatament\n\n只是因为上面示例中aSatament用了一个块语句，所以这个“块级作用域”是块语句的，而不是if语句的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583470256,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175324,"user_name":"antimony","can_delete":false,"product_type":"c1","uid":1394138,"ip_address":"","ucode":"7DFA3DCFD5138C","user_header":"https://static001.geekbang.org/account/avatar/00/15/45/da/71b7599d.jpg","comment_is_top":false,"comment_ctime":1580654978,"is_pvip":false,"replies":[{"id":"68153","content":"换成let就undefined了。<br>Var的作用域是在函数或全局，而并不是声明在块级作用域中。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1580699913,"ip_address":"","comment_id":175324,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1580654978","product_id":100039701,"comment_content":"var x = 100, c = &#39;a&#39;;<br>switch (c) {<br>  case &#39;a&#39;: <br>    console.log(x); &#47;&#47; 100<br>    break;<br>  case &#39;b&#39;:<br>    var x = 200;<br>    break;<br>}<br>爱民老师，能请教一下上面那段代码为什么在chrome中会输出100呢，在我的理解中应该输出undefined才对啊，因为switch 中的x不是应该被提升了吗，望解惑谢谢。","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482693,"discussion_content":"换成let就undefined了。\nVar的作用域是在函数或全局，而并不是声明在块级作用域中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580699913,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1394138,"avatar":"https://static001.geekbang.org/account/avatar/00/15/45/da/71b7599d.jpg","nickname":"antimony","note":"","ucode":"7DFA3DCFD5138C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":159592,"discussion_content":"明白了，当时脑子有点乱忘记var的作用域和var不止能声明一次了，谢谢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580711666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170835,"user_name":"wDaLian","can_delete":false,"product_type":"c1","uid":1381721,"ip_address":"","ucode":"D419921E3CFC00","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoJ8fUFEicTEPIvIdsicBywsBoIlBrPAPSbiasul9LNSO5juOxXJub1icIoWRdyk33MByyFxzHhdVKkUw/132","comment_is_top":false,"comment_ctime":1578734694,"is_pvip":false,"replies":[{"id":"66263","content":"第一，你的案例一在循环体中多了一对大括号，这会导致作用域创建，去掉它才能跟后面的比较。<br><br>第二，差异很细微，建议你编译引擎的debug版本然后track内核，或者你可以尝试一个prepack-core这个项目，可以在js源代码级别来分析。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1578820094,"ip_address":"","comment_id":170835,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578734694","product_id":100039701,"comment_content":"有点懵，这个节省指的是时间上的节省 还是空间上的节省，我计算了事件发现let 和var 基本没啥区别速度上<br>const array = Array.from({length:100000},(item,i)=&gt;i)<br><br>    &#47;&#47; 案例一<br>    console.time(&#39;a&#39;)<br>    const cc = []<br>    for(let i in array){<br>        cc.push(i)<br>    }<br>    console.log(cc)<br>    console.timeEnd(&#39;a&#39;)<br><br>    &#47;&#47; 案例二<br>    console.time(&#39;b&#39;)<br>    const ccc = []<br>    for(var i in array){<br>        ccc.push(i)<br>    }<br>    console.log(ccc)<br>    console.timeEnd(&#39;b&#39;)<br>    <br>    &#47;&#47; 案例三<br>    console.time(&#39;c&#39;)<br>    const cccv = []<br>    for(let i in array)<br>        cccv.push(i);<br>    console.log(cccv)<br>    console.timeEnd(&#39;c&#39;)","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481131,"discussion_content":"第一，你的案例一在循环体中多了一对大括号，这会导致作用域创建，去掉它才能跟后面的比较。\n\n第二，差异很细微，建议你编译引擎的debug版本然后track内核，或者你可以尝试一个prepack-core这个项目，可以在js源代码级别来分析。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578820094,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166847,"user_name":"伪装","can_delete":false,"product_type":"c1","uid":1614884,"ip_address":"","ucode":"F484F3ADFEB060","user_header":"https://static001.geekbang.org/account/avatar/00/18/a4/24/0f4a9157.jpg","comment_is_top":false,"comment_ctime":1577614155,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577614155","product_id":100039701,"comment_content":"越来越感觉js 是最烂的语言 没有之一 设计上是一塌糊涂","like_count":0},{"had_liked":false,"id":166390,"user_name":"Elmer","can_delete":false,"product_type":"c1","uid":1233975,"ip_address":"","ucode":"61FC9CE0BA5BC1","user_header":"https://static001.geekbang.org/account/avatar/00/12/d4/37/528a43e7.jpg","comment_is_top":false,"comment_ctime":1577440408,"is_pvip":true,"replies":[{"id":"63448","content":"我不太明白你说的。能有一个比较完整的示例么？","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1577459863,"ip_address":"","comment_id":166390,"utype":1}],"discussion_count":5,"race_medal":0,"score":"1577440408","product_id":100039701,"comment_content":"有个地方不懂。。<br>let i在forenv中，i = ... 在iterationenv中<br>let i <br>{const c=1; i=2,;setTimeout(() =&gt; {console.log(i)}, 100)};<br>{const c=2; i= 3; setTimeout(() =&gt; {console.log(i)}, 50)};<br>类似这种？ 可这样输出的都是3呀","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479497,"discussion_content":"我不太明白你说的。能有一个比较完整的示例么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577459863,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":108026,"discussion_content":"Oh... 实例化每一个iteration env的时候，会重新抄写（以及“可能的”实始化）一次变量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577621963,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1233975,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d4/37/528a43e7.jpg","nickname":"Elmer","note":"","ucode":"61FC9CE0BA5BC1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":108481,"discussion_content":"那for env的意义是什么。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577631001,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":108026,"ip_address":""},"score":108481,"extra":""}]},{"author":{"id":1233975,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d4/37/528a43e7.jpg","nickname":"Elmer","note":"","ucode":"61FC9CE0BA5BC1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":105666,"discussion_content":"我的意思是假设let i在forenv中\n我后面的两个｛｝分别实例化了两个iteration\n env 这个时候iteration env是不一样，但i只有一个，是怎么做到每个iteration env中i的值不同的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577462335,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1153873,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9b/51/113102a9.jpg","nickname":"magnus","note":"","ucode":"7C450CFBEF8CFB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1233975,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d4/37/528a43e7.jpg","nickname":"Elmer","note":"","ucode":"61FC9CE0BA5BC1","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":115869,"discussion_content":"个人见解，在创建副本iteration env的时候，应该是用闭包缓存了当时的i值。否则setTimeout(macrotasks)只可能输出同步(microtasks)的最后一次i的值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578041423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":105666,"ip_address":""},"score":115869,"extra":""}]}]},{"had_liked":false,"id":162698,"user_name":"leslee","can_delete":false,"product_type":"c1","uid":1384326,"ip_address":"","ucode":"DB1CBF9F8D16BF","user_header":"https://static001.geekbang.org/account/avatar/00/15/1f/86/3a7eeac4.jpg","comment_is_top":false,"comment_ctime":1576578979,"is_pvip":false,"replies":[{"id":"61900","content":"1. 你的结论是对的，这里的确是一个静态解析异常。另外，“词法作用域”如果理解为静态的，那么for语句只有一个；如果考虑它在执行期的效果，那么for语句中带有let&#47;const声明时，它会有“迭代次数+1”个。这就好象函数递归调用，函数实例只有一个，但闭包其实是递归次数个一样。它们的原因、性质和效果都是类似的。<br><br>2. 对于“for (let&#47;const...”来说，这个语句在处理的时候，所有的IterationEnv的parent指向相同的、外部的环境，也就是指向loopEnv。这个代码在这里：<br>https:&#47;&#47;tc39.es&#47;ecma262&#47;#sec-createperiterationenvironment<br>它是每次迭代都创建一个新的IterationEnv，并根据perIterationBindings[]来抄写上一次迭代环境中的值到新环境。<br><br>而对于“for (let&#47;const ... in&#47;of)” 这个语法来说，在实现的逻辑上稍有区别，在这里：<br>https:&#47;&#47;tc39.es&#47;ecma262&#47;#sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset<br><br>但是在你的问题上答案是一致的，每次迭代都是iterationEnv的parent指向loopEnv。因为在上面的代码中，迭代是基于迭代器的循环，而每次创建新的iterationEnv时使用的将是相同的outer&#47;parent值，也就是代码中的oldEnv，也就是loopEnv。<br>","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1576637693,"ip_address":"","comment_id":162698,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1576578979","product_id":100039701,"comment_content":"老师好, 跟随老师学到了第10讲了, 但是回头看了一下, 发现我并没有真正的写到东西, 在看了老师的加餐后, 醒悟了, 并没有追求进度, 所以回过头来重新看第一章, 每一讲都看了不下三遍, 算是学到了一些知识, 在这一章的最后一讲, 还有些疑问, 望老师解答. 感谢<br><br>`for(let inForEnv  i in {}) let inLoopEnv;`<br><br>1. 上文说在迭代的过程中会为后面的 let inLoopEnv 循环体创建相应数量的作用域, 但是又说使用了 let 的for单语句 通常只有一个块级作用域, 我理解的是 &#39;创建相应数量的作用域&#39; 是动态的,是运行时的 跟词法作用域无关,  而 &#39;只有一个块级作用域&#39; 是词法作用域, 也就是说 let inForEnv 跟 let inLoopEnv 在同一个词法作用域了, 每次迭代let都会冲突, 所以不允许在单语句中使用let词法声明,`Uncaught SyntaxError: Lexical declaration cannot appear in a single-statement context` 所以这个错其实是静态解析的错是么<br><br>2: forEnv 是 loopEnv 的外部环境, 那么 IterationEnv 的外部环境是否是loopEnv , 上面所说 `创建了第二个作用域的无数个副本`  那这几个环境的层级是怎样的, 是 forEnv -&gt; loopEnv -&gt; iterationEnv 还是 forEnv-&gt; loopEnv&#47;iterationEnv","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478130,"discussion_content":"1. 你的结论是对的，这里的确是一个静态解析异常。另外，“词法作用域”如果理解为静态的，那么for语句只有一个；如果考虑它在执行期的效果，那么for语句中带有let/const声明时，它会有“迭代次数+1”个。这就好象函数递归调用，函数实例只有一个，但闭包其实是递归次数个一样。它们的原因、性质和效果都是类似的。\n\n2. 对于“for (let/const...”来说，这个语句在处理的时候，所有的IterationEnv的parent指向相同的、外部的环境，也就是指向loopEnv。这个代码在这里：\nhttps://tc39.es/ecma262/#sec-createperiterationenvironment\n它是每次迭代都创建一个新的IterationEnv，并根据perIterationBindings[]来抄写上一次迭代环境中的值到新环境。\n\n而对于“for (let/const ... in/of)” 这个语法来说，在实现的逻辑上稍有区别，在这里：\nhttps://tc39.es/ecma262/#sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset\n\n但是在你的问题上答案是一致的，每次迭代都是iterationEnv的parent指向loopEnv。因为在上面的代码中，迭代是基于迭代器的循环，而每次创建新的iterationEnv时使用的将是相同的outer/parent值，也就是代码中的oldEnv，也就是loopEnv。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576637693,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1361489,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c6/51/44791c01.jpg","nickname":"🇧🇪 Hazard🇦🇷","note":"","ucode":"E2C44FAFDFAA88","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":208609,"discussion_content":"大佬，我没懂这里：\n“也就是说 let inForEnv 跟 let inLoopEnv 在同一个词法作用域了, 每次迭代let都会冲突, 所以不允许在单语句中使用let词法声明,”\n迭代let声明不是在 副本 iterationEnv中吗？在每个单独的作用域中，为什么会有冲突？\n\n如果说是静态解析时报的错，那只是预解析阶段强制在这里做了类似这样的判断“单语句声明词法变量我就会报错！” 还是怎么回事？ 静态解析阶段实际上工作流程是怎么回事？如果静态解析可以不报这个错的话，执行阶段会有什么问题吗？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584552767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161384,"user_name":"Jing","can_delete":false,"product_type":"c1","uid":1742214,"ip_address":"","ucode":"D550C1BE1FF95F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/95/86/dc7b7fb4.jpg","comment_is_top":false,"comment_ctime":1576200327,"is_pvip":false,"replies":[{"id":"61504","content":"不是。<br><br>这里的“顶层”是作用域的说法，就是作用域的最外层。比如在function f() {}里面，如果有多级嵌套的函数，那么就是最外层的那一个（但还是f()的内的嵌套函数声明）。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1576203210,"ip_address":"","comment_id":161384,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1576200327","product_id":100039701,"comment_content":"考虑到对传统 JavaScript 的兼容，函数内部的顶层函数名是提升到变量作用域中来管理的。其中顶层函数名的指的是那些isNaN（），Number（）这些JavaScript内置顶层函数吗","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477702,"discussion_content":"不是。\n\n这里的“顶层”是作用域的说法，就是作用域的最外层。比如在function f() {}里面，如果有多级嵌套的函数，那么就是最外层的那一个（但还是f()的内的嵌套函数声明）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576203210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159624,"user_name":"一路向北","can_delete":false,"product_type":"c1","uid":1017835,"ip_address":"","ucode":"DB0FF1C153C485","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/eb/20492a37.jpg","comment_is_top":false,"comment_ctime":1575708237,"is_pvip":false,"replies":[{"id":"60989","content":"其实入门和应用的话，看JS的手册或语法书就可以了，这门课程主要的目标不是在“讲js怎么用”的。简单的话，我还是挺推荐w3cschool的，包括这里：<br>https:&#47;&#47;www.w3school.com.cn&#47;js&#47;index.asp<br>或这里：<br>https:&#47;&#47;www.w3cschool.cn&#47;javascript&#47;","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1575719030,"ip_address":"","comment_id":159624,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1575708237","product_id":100039701,"comment_content":"凭我的一点C语言基础很难理解JS了😇","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477122,"discussion_content":"其实入门和应用的话，看JS的手册或语法书就可以了，这门课程主要的目标不是在“讲js怎么用”的。简单的话，我还是挺推荐w3cschool的，包括这里：\nhttps://www.w3school.com.cn/js/index.asp\n或这里：\nhttps://www.w3cschool.cn/javascript/","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575719030,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159532,"user_name":"小童","can_delete":false,"product_type":"c1","uid":1763395,"ip_address":"","ucode":"300444B520E79D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/e8/43/f9c0faed.jpg","comment_is_top":false,"comment_ctime":1575672055,"is_pvip":false,"replies":[{"id":"60983","content":"没有的。<br><br>如果你写成`if () { ... }`，那么那个块级作用域是后面那个块语句的，不是if语句的。比如，条件表达式`()`就不会在那个块里面执行。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1575711583,"ip_address":"","comment_id":159532,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1575672055","product_id":100039701,"comment_content":"if也没有块级作用域吗？","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477088,"discussion_content":"没有的。\n\n如果你写成`if () { ... }`，那么那个块级作用域是后面那个块语句的，不是if语句的。比如，条件表达式`()`就不会在那个块里面执行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575711583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1763395,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/e8/43/f9c0faed.jpg","nickname":"小童","note":"","ucode":"300444B520E79D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":95390,"discussion_content":"哦 居然是分开理解的，老师这样都是ECMAScript中里面都有写吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577021844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158453,"user_name":"南墙的树","can_delete":false,"product_type":"c1","uid":1384130,"ip_address":"","ucode":"289B98CA489C09","user_header":"https://static001.geekbang.org/account/avatar/00/15/1e/c2/edf5dfcb.jpg","comment_is_top":false,"comment_ctime":1575375780,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575375780","product_id":100039701,"comment_content":"晓小东的一波操作，我还没见过这种写法，学习了","like_count":0}]}