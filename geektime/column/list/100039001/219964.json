{"id":219964,"title":"66 | 迭代器模式（中）：遍历集合的同时，为什么不能增删集合元素？","content":"<p>上一节课中，我们通过给ArrayList、LinkedList容器实现迭代器，学习了迭代器模式的原理、实现和设计意图。迭代器模式主要作用是解耦容器代码和遍历代码，这也印证了我们前面多次讲过的应用设计模式的主要目的是解耦。</p><p>上一节课中讲解的内容都比较基础，今天，我们来深挖一下，如果在使用迭代器遍历集合的同时增加、删除集合中的元素，会发生什么情况？应该如何应对？如何在遍历的同时安全地删除集合元素？</p><p>话不多说，让我们正式开始今天的内容吧！</p><h2>在遍历的同时增删集合元素会发生什么？</h2><p>在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素被重复遍历或遍历不到。不过，并不是所有情况下都会遍历出错，有的时候也可以正常遍历，所以，这种行为称为<strong>结果不可预期行为</strong>或者<strong>未决行为</strong>，也就是说，运行结果到底是对还是错，要视情况而定。</p><p>怎么理解呢？我们通过一个例子来解释一下。我们还是延续上一节课实现的ArrayList迭代器的例子。为了方便你查看，我把相关的代码都重新拷贝到这里了。</p><pre><code>public interface Iterator&lt;E&gt; {\n  boolean hasNext();\n  void next();\n  E currentItem();\n}\n\npublic class ArrayIterator&lt;E&gt; implements Iterator&lt;E&gt; {\n  private int cursor;\n  private ArrayList&lt;E&gt; arrayList;\n\n  public ArrayIterator(ArrayList&lt;E&gt; arrayList) {\n    this.cursor = 0;\n    this.arrayList = arrayList;\n  }\n\n  @Override\n  public boolean hasNext() {\n    return cursor &lt; arrayList.size();\n  }\n\n  @Override\n  public void next() {\n    cursor++;\n  }\n\n  @Override\n  public E currentItem() {\n    if (cursor &gt;= arrayList.size()) {\n      throw new NoSuchElementException();\n    }\n    return arrayList.get(cursor);\n  }\n}\n\npublic interface List&lt;E&gt; {\n  Iterator iterator();\n}\n\npublic class ArrayList&lt;E&gt; implements List&lt;E&gt; {\n  //...\n  public Iterator iterator() {\n    return new ArrayIterator(this);\n  }\n  //...\n}\n\npublic class Demo {\n  public static void main(String[] args) {\n    List&lt;String&gt; names = new ArrayList&lt;&gt;();\n    names.add(&quot;a&quot;);\n    names.add(&quot;b&quot;);\n    names.add(&quot;c&quot;);\n    names.add(&quot;d&quot;);\n\n    Iterator&lt;String&gt; iterator = names.iterator();\n    iterator.next();\n    names.remove(&quot;a&quot;);\n  }\n}\n</code></pre><p>我们知道，ArrayList底层对应的是数组这种数据结构，在执行完第55行代码的时候，数组中存储的是a、b、c、d四个元素，迭代器的游标cursor指向元素a。当执行完第56行代码的时候，游标指向元素b，到这里都没有问题。</p><!-- [[[read_end]]] --><p>为了保持数组存储数据的连续性，数组的删除操作会涉及元素的搬移（详细的讲解你可以去看我的另一个专栏《数据结构与算法之美》）。当执行到第57行代码的时候，我们从数组中将元素a删除掉，b、c、d三个元素会依次往前搬移一位，这就会导致游标本来指向元素b，现在变成了指向元素c。原本在执行完第56行代码之后，我们还可以遍历到b、c、d三个元素，但在执行完第57行代码之后，我们只能遍历到c、d两个元素，b遍历不到了。</p><p>对于上面的描述，我画了一张图，你可以对照着理解。</p><p><img src=\"https://static001.geekbang.org/resource/image/d8/e9/d86223f2b0f996ebb2b21e5abbeceae9.jpg?wh=1409*1382\" alt=\"\"></p><p>不过，如果第57行代码删除的不是游标前面的元素（元素a）以及游标所在位置的元素（元素b），而是游标后面的元素（元素c和d），这样就不会存在任何问题了，不会存在某个元素遍历不到的情况了。</p><p>所以，我们前面说，在遍历的过程中删除集合元素，结果是不可预期的，有时候没问题（删除元素c或d），有时候就有问题（删除元素a或b），这个要视情况而定（到底删除的是哪个位置的元素），就是这个意思。</p><p>在遍历的过程中删除集合元素，有可能会导致某个元素遍历不到，那在遍历的过程中添加集合元素，会发生什么情况呢？还是结合刚刚那个例子来讲解，我们将上面的代码稍微改造一下，把删除元素改为添加元素。具体的代码如下所示：</p><pre><code>public class Demo {\n  public static void main(String[] args) {\n    List&lt;String&gt; names = new ArrayList&lt;&gt;();\n    names.add(&quot;a&quot;);\n    names.add(&quot;b&quot;);\n    names.add(&quot;c&quot;);\n    names.add(&quot;d&quot;);\n\n    Iterator&lt;String&gt; iterator = names.iterator();\n    iterator.next();\n    names.add(0, &quot;x&quot;);\n  }\n}\n</code></pre><p>在执行完第10行代码之后，数组中包含a、b、c、d四个元素，游标指向b这个元素，已经跳过了元素a。在执行完第11行代码之后，我们将x插入到下标为0的位置，a、b、c、d四个元素依次往后移动一位。这个时候，游标又重新指向了元素a。元素a被游标重复指向两次，也就是说，元素a存在被重复遍历的情况。</p><p>跟删除情况类似，如果我们在游标的后面添加元素，就不会存在任何问题。所以，在遍历的同时添加集合元素也是一种不可预期行为。</p><p>同样，对于上面的添加元素的情况，我们也画了一张图，如下所示，你可以对照着理解。</p><p><img src=\"https://static001.geekbang.org/resource/image/4c/d2/4cd27c2dcdb2be169ef30194899c19d2.jpg?wh=1649*1382\" alt=\"\"></p><h2>如何应对遍历时改变集合导致的未决行为？</h2><p>当通过迭代器来遍历集合的时候，增加、删除集合元素会导致不可预期的遍历结果。实际上，“不可预期”比直接出错更加可怕，有的时候运行正确，有的时候运行错误，一些隐藏很深、很难debug的bug就是这么产生的。那我们如何才能避免出现这种不可预期的运行结果呢？</p><p>有两种比较干脆利索的解决方案：一种是遍历的时候不允许增删元素，另一种是增删元素之后让遍历报错。</p><p>实际上，第一种解决方案比较难实现，我们要确定遍历开始和结束的时间点。遍历开始的时间节点我们很容易获得。我们可以把创建迭代器的时间点作为遍历开始的时间点。但是，遍历结束的时间点该如何来确定呢？</p><p>你可能会说，遍历到最后一个元素的时候就算结束呗。但是，在实际的软件开发中，每次使用迭代器来遍历元素，并不一定非要把所有元素都遍历一遍。如下所示，我们找到一个值为b的元素就提前结束了遍历。</p><pre><code>public class Demo {\n  public static void main(String[] args) {\n    List&lt;String&gt; names = new ArrayList&lt;&gt;();\n    names.add(&quot;a&quot;);\n    names.add(&quot;b&quot;);\n    names.add(&quot;c&quot;);\n    names.add(&quot;d&quot;);\n\n    Iterator&lt;String&gt; iterator = names.iterator();\n    while (iterator.hasNext()) {\n      String name = iterator.currentItem();\n      if (name.equals(&quot;b&quot;)) {\n        break;\n      }\n    }\n  }\n}\n</code></pre><p>你可能还会说，那我们可以在迭代器类中定义一个新的接口finishIteration()，主动告知容器迭代器使用完了，你可以增删元素了，示例代码如下所示。但是，这就要求程序员在使用完迭代器之后要主动调用这个函数，也增加了开发成本，还很容易漏掉。</p><pre><code>public class Demo {\n  public static void main(String[] args) {\n    List&lt;String&gt; names = new ArrayList&lt;&gt;();\n    names.add(&quot;a&quot;);\n    names.add(&quot;b&quot;);\n    names.add(&quot;c&quot;);\n    names.add(&quot;d&quot;);\n\n    Iterator&lt;String&gt; iterator = names.iterator();\n    while (iterator.hasNext()) {\n      String name = iterator.currentItem();\n      if (name.equals(&quot;b&quot;)) {\n        iterator.finishIteration();//主动告知容器这个迭代器用完了\n        break;\n      }\n    }\n  }\n}\n</code></pre><p>实际上，第二种解决方法更加合理。Java语言就是采用的这种解决方案，增删元素之后，让遍历报错。接下来，我们具体来看一下如何实现。</p><p>怎么确定在遍历时候，集合有没有增删元素呢？我们在ArrayList中定义一个成员变量modCount，记录集合被修改的次数，集合每调用一次增加或删除元素的函数，就会给modCount加1。当通过调用集合上的iterator()函数来创建迭代器的时候，我们把modCount值传递给迭代器的expectedModCount成员变量，之后每次调用迭代器上的hasNext()、next()、currentItem()函数，我们都会检查集合上的modCount是否等于expectedModCount，也就是看，在创建完迭代器之后，modCount是否改变过。</p><p>如果两个值不相同，那就说明集合存储的元素已经改变了，要么增加了元素，要么删除了元素，之前创建的迭代器已经不能正确运行了，再继续使用就会产生不可预期的结果，所以我们选择fail-fast解决方式，抛出运行时异常，结束掉程序，让程序员尽快修复这个因为不正确使用迭代器而产生的bug。</p><p>上面的描述翻译成代码就是下面这样子。你可以结合着代码一起理解我刚才的讲解。</p><pre><code>public class ArrayIterator implements Iterator {\n  private int cursor;\n  private ArrayList arrayList;\n  private int expectedModCount;\n\n  public ArrayIterator(ArrayList arrayList) {\n    this.cursor = 0;\n    this.arrayList = arrayList;\n    this.expectedModCount = arrayList.modCount;\n  }\n\n  @Override\n  public boolean hasNext() {\n    checkForComodification();\n    return cursor &lt; arrayList.size();\n  }\n\n  @Override\n  public void next() {\n    checkForComodification();\n    cursor++;\n  }\n\n  @Override\n  public Object currentItem() {\n    checkForComodification();\n    return arrayList.get(cursor);\n  }\n  \n  private void checkForComodification() {\n    if (arrayList.modCount != expectedModCount)\n        throw new ConcurrentModificationException();\n  }\n}\n\n//代码示例\npublic class Demo {\n  public static void main(String[] args) {\n    List&lt;String&gt; names = new ArrayList&lt;&gt;();\n    names.add(&quot;a&quot;);\n    names.add(&quot;b&quot;);\n    names.add(&quot;c&quot;);\n    names.add(&quot;d&quot;);\n\n    Iterator&lt;String&gt; iterator = names.iterator();\n    iterator.next();\n    names.remove(&quot;a&quot;);\n    iterator.next();//抛出ConcurrentModificationException异常\n  }\n}\n</code></pre><h2>如何在遍历的同时安全地删除集合元素？</h2><p>像Java语言，迭代器类中除了前面提到的几个最基本的方法之外，还定义了一个remove()方法，能够在遍历集合的同时，安全地删除集合中的元素。不过，需要说明的是，它并没有提供添加元素的方法。毕竟迭代器的主要作用是遍历，添加元素放到迭代器里本身就不合适。</p><p>我个人觉得，Java迭代器中提供的remove()方法还是比较鸡肋的，作用有限。它只能删除游标指向的前一个元素，而且一个next()函数之后，只能跟着最多一个remove()操作，多次调用remove()操作会报错。我还是通过一个例子来解释一下。</p><pre><code>public class Demo {\n  public static void main(String[] args) {\n    List&lt;String&gt; names = new ArrayList&lt;&gt;();\n    names.add(&quot;a&quot;);\n    names.add(&quot;b&quot;);\n    names.add(&quot;c&quot;);\n    names.add(&quot;d&quot;);\n\n    Iterator&lt;String&gt; iterator = names.iterator();\n    iterator.next();\n    iterator.remove();\n    iterator.remove(); //报错，抛出IllegalStateException异常\n  }\n}\n</code></pre><p>现在，我们一块来看下，为什么通过迭代器就能安全的删除集合中的元素呢？源码之下无秘密。我们来看下remove()函数是如何实现的，代码如下所示。稍微提醒一下，在Java实现中，迭代器类是容器类的内部类，并且next()函数不仅将游标后移一位，还会返回当前的元素。</p><pre><code>public class ArrayList&lt;E&gt; {\n  transient Object[] elementData;\n  private int size;\n\n  public Iterator&lt;E&gt; iterator() {\n    return new Itr();\n  }\n\n  private class Itr implements Iterator&lt;E&gt; {\n    int cursor;       // index of next element to return\n    int lastRet = -1; // index of last element returned; -1 if no such\n    int expectedModCount = modCount;\n\n    Itr() {}\n\n    public boolean hasNext() {\n      return cursor != size;\n    }\n\n    @SuppressWarnings(&quot;unchecked&quot;)\n    public E next() {\n      checkForComodification();\n      int i = cursor;\n      if (i &gt;= size)\n        throw new NoSuchElementException();\n      Object[] elementData = ArrayList.this.elementData;\n      if (i &gt;= elementData.length)\n        throw new ConcurrentModificationException();\n      cursor = i + 1;\n      return (E) elementData[lastRet = i];\n    }\n    \n    public void remove() {\n      if (lastRet &lt; 0)\n        throw new IllegalStateException();\n      checkForComodification();\n\n      try {\n        ArrayList.this.remove(lastRet);\n        cursor = lastRet;\n        lastRet = -1;\n        expectedModCount = modCount;\n      } catch (IndexOutOfBoundsException ex) {\n        throw new ConcurrentModificationException();\n      }\n    }\n  }\n}\n</code></pre><p>在上面的代码实现中，迭代器类新增了一个lastRet成员变量，用来记录游标指向的前一个元素。通过迭代器去删除这个元素的时候，我们可以更新迭代器中的游标和lastRet值，来保证不会因为删除元素而导致某个元素遍历不到。如果通过容器来删除元素，并且希望更新迭代器中的游标值来保证遍历不出错，我们就要维护这个容器都创建了哪些迭代器，每个迭代器是否还在使用等信息，代码实现就变得比较复杂了。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素被重复遍历或遍历不到。不过，并不是所有情况下都会遍历出错，有的时候也可以正常遍历，所以，这种行为称为结果不可预期行为或者未决行为。实际上，“不可预期”比直接出错更加可怕，有的时候运行正确，有的时候运行错误，一些隐藏很深、很难debug的bug就是这么产生的。</p><p>有两种比较干脆利索的解决方案，来避免出现这种不可预期的运行结果。一种是遍历的时候不允许增删元素，另一种是增删元素之后让遍历报错。第一种解决方案比较难实现，因为很难确定迭代器使用结束的时间点。第二种解决方案更加合理。Java语言就是采用的这种解决方案。增删元素之后，我们选择fail-fast解决方式，让遍历操作直接抛出运行时异常。</p><p>像Java语言，迭代器类中除了前面提到的几个最基本的方法之外，还定义了一个remove()方法，能够在遍历集合的同时，安全地删除集合中的元素。</p><h2>课堂讨论</h2><p>1、基于文章中给出的Java迭代器的实现代码，如果一个容器对象同时创建了两个迭代器，一个迭代器调用了remove()方法删除了集合中的一个元素，那另一个迭代器是否还可用？或者，我换个问法，下面代码中的第13行的运行结果是什么？</p><pre><code>public class Demo {\n  public static void main(String[] args) {\n    List&lt;String&gt; names = new ArrayList&lt;&gt;();\n    names.add(&quot;a&quot;);\n    names.add(&quot;b&quot;);\n    names.add(&quot;c&quot;);\n    names.add(&quot;d&quot;);\n\n    Iterator&lt;String&gt; iterator1 = names.iterator();\n    Iterator&lt;String&gt; iterator2 = names.iterator();\n    iterator1.next();\n    iterator1.remove();\n    iterator2.next(); // 运行结果？\n  }\n}\n</code></pre><p>2、LinkedList底层基于链表，如果在遍历的同时，增加删除元素，会出现哪些不可预期的行为呢？</p><p>欢迎留言和我分享你的想法。如果有收获，欢迎你把这篇文章分享给你的朋友。</p>","comments":[{"had_liked":false,"id":202219,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1585925290,"is_pvip":false,"discussion_count":12,"race_medal":1,"score":"323708472490","product_id":100039001,"comment_content":"思考题：<br>1. iterator1 和 iterator2是两个不同的迭代器对象，修改一个不会影响另外一个，所以执行iterator1.remove()后，再执行iterator2.next时，会执行checkForComodification();检查，可是检查条件“arrayList.modCount != expectedModCount”中arrayList的modCount已经变成了5，而此时iterator2的expectedModCount还是4，所以触发ConcurrentModificationException异常。<br>2. LinkedList和ArrayList不同是LinkedList底层基于链表实现，增加删除元素不需要移动元素的位置，所以不会出现跟ArrayList不同的情况，比如增加元素时，不论增加的元素时在迭代器前还是后，都能通过指针寻址到下一个元素。","like_count":76,"discussions":[{"author":{"id":1702886,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fb/e6/1b9edb91.jpg","nickname":"练习生","note":"","ucode":"60203A2AA0EA36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360799,"discussion_content":"源码不看，乱下定论，还这么多赞，你要对其他阅读的人负责任的！","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1616518108,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1691447,"avatar":"https://static001.geekbang.org/account/avatar/00/19/cf/37/6ed137b9.jpg","nickname":"Dunk","note":"","ucode":"A8F5AB98382719","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378410,"discussion_content":"错误的答案居然还在第一个位置，误人子弟吧！","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1623213377,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1020311,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/91/97/3762ca10.jpg","nickname":"小情绪","note":"","ucode":"92D8081DB8DB45","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312774,"discussion_content":"LinkedList和ArraryList的情况一样，都会出现未决行为的。","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1602814186,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336960,"discussion_content":"经看LinkedList源码，添加或删除元素时，modCount都会做modCount++操作，所以假如在迭代器遍历过程中添加或删除元素，下一次执行next()过程中会检查modCount 和expectedModCount，此时modCount != expectedModCount，会抛出ConcurrentModificationException","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1608734334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385180,"discussion_content":"能给差评吗?","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1626935235,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1207079,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6b/27/8c964e52.jpg","nickname":"不惑ing","note":"","ucode":"AF04E417D38027","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":225433,"discussion_content":"新增元素在游标前遍历不到，在游标后遍历的到，这也算是一种未决行为吧","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1586358626,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1131070,"avatar":"https://static001.geekbang.org/account/avatar/00/11/42/3e/c1f76202.jpg","nickname":"青山","note":"","ucode":"749BAD1834AC0F","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":1207079,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6b/27/8c964e52.jpg","nickname":"不惑ing","note":"","ucode":"AF04E417D38027","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292974,"discussion_content":"是未决行为，不过只要有增删都会走checkForComodification，就直接异常了。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1595400498,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":225433,"ip_address":""},"score":292974,"extra":""},{"author":{"id":2286788,"avatar":"https://static001.geekbang.org/account/avatar/00/22/e4/c4/065f8c0c.jpg","nickname":"Tom-TTC","note":"","ucode":"36AB0797D6FD3A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1131070,"avatar":"https://static001.geekbang.org/account/avatar/00/11/42/3e/c1f76202.jpg","nickname":"青山","note":"","ucode":"749BAD1834AC0F","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":358879,"discussion_content":"讨论题并不是问集合框架是怎么设计的，只是问如文中一样假设可以增删会出现哪些奇怪的结果。你说的是最终设计，肯定是抛异常，哈哈哈(ಡωಡ)hiahiahia","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616070151,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":292974,"ip_address":""},"score":358879,"extra":""}]},{"author":{"id":1228852,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c0/34/0574bb44.jpg","nickname":"最初的印象","note":"","ucode":"4DD68307FA274E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558875,"discussion_content":"小编能不能把错误的评论删除，还那么多点赞。这不是误导人家吗？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1648517327,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2076251,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/ae/5b/4bd42286.jpg","nickname":"宋计洋","note":"","ucode":"9A34E8F71C6CBD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1228852,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c0/34/0574bb44.jpg","nickname":"最初的印象","note":"","ucode":"4DD68307FA274E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561702,"discussion_content":"我觉得LinkedList是可以不抛异常的，但源码应该是为了保持一致","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649694996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":558875,"ip_address":""},"score":561702,"extra":""}]},{"author":{"id":1138645,"avatar":"https://static001.geekbang.org/account/avatar/00/11/5f/d5/2fec2911.jpg","nickname":"yu","note":"","ucode":"56856DCC0C8387","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":252294,"discussion_content":"但两个迭代器对象共用一个List容器对象，modCount是共享的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588149708,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1887603,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/cd/73/f6889c2f.jpg","nickname":"Wind","note":"","ucode":"AD108636DE44C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1138645,"avatar":"https://static001.geekbang.org/account/avatar/00/11/5f/d5/2fec2911.jpg","nickname":"yu","note":"","ucode":"56856DCC0C8387","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298877,"discussion_content":"对modCount都感知了，但是expectedModCount一个变了一个没变，所以没变那个会报错","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1597458276,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":252294,"ip_address":""},"score":298877,"extra":""}]}]},{"had_liked":false,"id":201878,"user_name":"kyle","can_delete":false,"product_type":"c1","uid":1179158,"ip_address":"","ucode":"DB05C0F7D2C472","user_header":"https://static001.geekbang.org/account/avatar/00/11/fe/16/0f096793.jpg","comment_is_top":false,"comment_ctime":1585871891,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"78895283219","product_id":100039001,"comment_content":"迭代器中删除元素那一段，执行完第57行(删除a以后)，游标应该指向c，图中指向d了","like_count":18},{"had_liked":false,"id":202120,"user_name":"Ken张云忠","can_delete":false,"product_type":"c1","uid":1134288,"ip_address":"","ucode":"D0BAC9FC17DE2B","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","comment_is_top":false,"comment_ctime":1585905103,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"57420479951","product_id":100039001,"comment_content":"1.基于文章中给出的 Java 迭代器的实现代码，如果一个容器对象同时创建了两个迭代器，一个迭代器调用了 remove() 方法删除了集合中的一个元素，那另一个迭代器是否还可用？或者，我换个问法，下面代码中的第 13 行的运行结果是什么？<br>Exception in thread &quot;main&quot; java.util.ConcurrentModificationException<br>因为iterator2.expectedModCount的值与names.modCount的值不相等,expectedModCount比modCount小1.<br><br>2.LinkedList 底层基于链表，如果在遍历的同时，增加删除元素，会出现哪些不可预期的行为呢？<br>当在游标及游标之前增删元素时会使有的元素遍历不到;当在游标之后增删元素时无问题.<br>LinkedList与ArrayList一样,因为都是集成抽象类java.util.AbstractList,<br>在遍历的同时调用两次remove()都会抛出异常,都会抛出的是java.lang.IllegalStateException异常.<br>两个迭代器遍历的同时,其中一个迭代器删除元素都会使另一个迭代器抛出java.util.ConcurrentModificationException异常.<br>都不支持迭代器里添加元素.","like_count":14},{"had_liked":false,"id":201968,"user_name":"，","can_delete":false,"product_type":"c1","uid":1701867,"ip_address":"","ucode":"A5543C8DFEB198","user_header":"https://static001.geekbang.org/account/avatar/00/19/f7/eb/e7127bb8.jpg","comment_is_top":false,"comment_ctime":1585883048,"is_pvip":true,"discussion_count":13,"race_medal":0,"score":"57420457896","product_id":100039001,"comment_content":"1.ConcurrentModificationException是在调用迭代器的next方法时产生,因为迭代器2并没有使用,所以不会报错,如果在第13行调用的是iterator2.next()则会报错(原因:expectedModCount在新建迭代器的时候初始化,调用iterator1.remove()只修改iterator1的expectedModCount,不会修改iterator2的,所以在调用iterator2.next()时会报错)<br>2.使用迭代器遍历的同时,使用容器的方法进行增删操作也会触发ConcurrentModificationException,行为和ArrayList是一样的<br><br>       我有一个问题想问老师,我是培训班出身,而且学历不好,自觉基础不行,所以从工作以来,基本每天都坚持学习,如今已经工作一年多了.可是我每天学习两三个钟头就觉得很累了,脑子像浆糊一样,没办法继续学新东西了,有时学习一整天,从上班开始学,一直学到下班,下班的时候感觉脑子都要扭曲了,好长时间缓解不过来,前几天听说去哪网的前端架构师去世了,年龄才30岁出头,我感觉我保持当下这个状态的话,到不了他的水平就得猝死,我想知道老师是怎么平衡日常生活的?真的有人能坚持每天学习十几个小时吗?这让我觉得特别累,喘不过气来","like_count":13,"discussions":[{"author":{"id":1114452,"avatar":"https://static001.geekbang.org/account/avatar/00/11/01/54/46266631.jpg","nickname":"gwen","note":"","ucode":"82A01FD8458671","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":135974,"discussion_content":"同问？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579103284,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":202670,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1586051023,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23060887503","product_id":100039001,"comment_content":"第一个问题，由于modcount不一样了，所以会出现异常。<br>第二个问题，LinkedList和ArrayList行为一致。","like_count":6},{"had_liked":false,"id":201921,"user_name":"Jackie","can_delete":false,"product_type":"c1","uid":1179920,"ip_address":"","ucode":"B853ECB3E962C5","user_header":"https://static001.geekbang.org/account/avatar/00/12/01/10/cb36bfed.jpg","comment_is_top":false,"comment_ctime":1585877375,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23060713855","product_id":100039001,"comment_content":"终于明白报ConcurrentModificationException的真正原因了","like_count":5},{"had_liked":false,"id":202014,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1585887684,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18765756868","product_id":100039001,"comment_content":"hpublic class Demo {<br>  public static void main(String[] args) {<br>    List&lt;String&gt; names = new ArrayList&lt;&gt;();<br>    names.add(&quot;a&quot;);<br>    names.add(&quot;b&quot;);<br>    names.add(&quot;c&quot;);<br>    names.add(&quot;d&quot;);<br>    Iterator&lt;String&gt; iterator1 = names.iterator();<br>    Iterator&lt;String&gt; iterator2 = names.iterator();<br>    iterator1.next();<br>    iterator1.remove();<br>    iterator1.next(); &#47;&#47; 运行结果？<br>  }<br>}<br><br>哈哈老师的题目笔误了吧。<br>运行结果那行应该是iterator2.next()。<br><br>然后结果应该是会抛异常，因为modifyCount不一致了。","like_count":4},{"had_liked":false,"id":201888,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1585873871,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18765743055","product_id":100039001,"comment_content":"1 第二个迭代器会报错，modCount发生变化<br>2 链表增删不影响游标，不会出现意外","like_count":4},{"had_liked":false,"id":204608,"user_name":"东征","can_delete":false,"product_type":"c1","uid":1234314,"ip_address":"","ucode":"DC557A1631A493","user_header":"https://static001.geekbang.org/account/avatar/00/12/d5/8a/7050236a.jpg","comment_is_top":false,"comment_ctime":1586428912,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14471330800","product_id":100039001,"comment_content":"问题一，因为每个iterator都会保留自己的expectModCount，而modCount是全局的，所以会抛错。<br>问题二，因为底层实现是链表，所以若在游标前新增删除，会导致整体遍历漏处理或多处理。在游标上删除，导致后面的内容无法遍历。在游标后新增删除无影响","like_count":3},{"had_liked":false,"id":201927,"user_name":"DexterPoker","can_delete":false,"product_type":"c1","uid":1612721,"ip_address":"","ucode":"F3A2094DA7CEF2","user_header":"https://static001.geekbang.org/account/avatar/00/18/9b/b1/61dd29ad.jpg","comment_is_top":false,"comment_ctime":1585878275,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14470780163","product_id":100039001,"comment_content":"老师的题目是不是<br>iterator1.next();<br>iterator1.remove();<br>iterator2.next(); &#47;&#47; 运行结果？<br>如果是iterator1，能正常运行；<br>如果是iterator2.next();就报错了","like_count":3},{"had_liked":false,"id":213106,"user_name":"xk_","can_delete":false,"product_type":"c1","uid":1514305,"ip_address":"","ucode":"DFE1AC38EA78A7","user_header":"https://static001.geekbang.org/account/avatar/00/17/1b/41/dbb7d785.jpg","comment_is_top":false,"comment_ctime":1588302372,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10178236964","product_id":100039001,"comment_content":"1、结论：报错。两个迭代器共享modCount属性，一个expectedModCount--了，另一个没变，所以报错了。<br>2、如果光看链表这个结构，遍历时增删元素是没有问题的。但是LinkedList有索引这个变量，所以在遍历时在指针前增删元素，索引是会出现问题的。","like_count":2},{"had_liked":false,"id":206360,"user_name":"xzy","can_delete":false,"product_type":"c1","uid":1002095,"ip_address":"","ucode":"1A44368083A19E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/6f/e36b3908.jpg","comment_is_top":false,"comment_ctime":1586846955,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10176781547","product_id":100039001,"comment_content":"看了ArrayList和LinkedList的源码，来回答思考题：<br>1，会抛出 ConcurrentModificationException 异常<br>2，添加元素分为两种情况：添加元素在游标前、添加元素在游标后<br>     游标前：nextIndex = next元素实际的下标 - 1，所以hasNext()函数在next()返回链表的最后一个元素后仍然成立<br>     游标后：无影响<br>   删除元素也分为三种情况：删除元素在游标前、删除元素在游标后、删除游标元素<br>     游标前：nextIndex = next元素的实际下标 + 1，所有hasNext()函数在next()返回链表末尾第二个元素后便不在成立<br>     游标后：无影响<br>     删除游标元素：访问当前游标元素后面的元素时会报空指针异常<br><br>  &#47;**<br>  * LinkedList 迭代器的部分源码<br>  * &#47;<br>  private class ListItr implements ListIterator&lt;E&gt; {<br>        private Node&lt;E&gt; lastReturned;<br>        private Node&lt;E&gt; next;<br>        private int nextIndex;<br>        private int expectedModCount = modCount;<br><br>        ListItr(int index) {<br>            &#47;&#47; assert isPositionIndex(index);<br>            next = (index == size) ? null : node(index);<br>            nextIndex = index;<br>        }<br><br>        public boolean hasNext() {<br>            return nextIndex &lt; size;<br>        }<br><br>        public E next() {<br>            checkForComodification();<br>            if (!hasNext())<br>                throw new NoSuchElementException();<br><br>            lastReturned = next;<br>            next = next.next;<br>            nextIndex++;<br>            return lastReturned.item;<br>        }<br><br>    }","like_count":2},{"had_liked":false,"id":202801,"user_name":"牧名","can_delete":false,"product_type":"c1","uid":1020390,"ip_address":"","ucode":"193F0F33E1AB47","user_header":"https://static001.geekbang.org/account/avatar/00/0f/91/e6/03582dee.jpg","comment_is_top":false,"comment_ctime":1586071733,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10176006325","product_id":100039001,"comment_content":"`LinkedList 底层基于链表，如果在遍历的同时，增加删除元素，会出现哪些不可预期的行为呢`<br>1. 增加元素：如果在当前元素之前添加新元素，那么新增的元素不会被遍历到；如果在当前元素之后添加元素则会被遍历到，存在未决行为。<br>2. 删除元素：如果删除当前元素之前的元素，那么这个被删除的元素其实之前已经被遍历过了；如果是删除当前元素之后的元素，则被删除元素将不会被遍历到；如果正好是删除当前元素，那么当前元素之后的元素将不会被遍历到，同样存在未决行为。","like_count":3},{"had_liked":false,"id":201895,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1585874943,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10175809535","product_id":100039001,"comment_content":"1.会报错，modCount变了；<br>2.LinkedList也是需要使用迭代器的remove方法，不然会有不可预期行为。","like_count":2},{"had_liked":false,"id":201853,"user_name":"马以","can_delete":false,"product_type":"c1","uid":1344431,"ip_address":"","ucode":"3FEA06CA14DE28","user_header":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","comment_is_top":false,"comment_ctime":1585845285,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10175779877","product_id":100039001,"comment_content":"不会报错","like_count":2,"discussions":[{"author":{"id":1026039,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a7/f7/9e5409d0.jpg","nickname":"wanan","note":"","ucode":"C3957AFAC024F2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220475,"discussion_content":"第12行应该是 iterator2.next(); 所以会报错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585881630,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203040,"user_name":"草上飞蝶号🙈","can_delete":false,"product_type":"c1","uid":1604231,"ip_address":"","ucode":"DF06A06BE61317","user_header":"https://static001.geekbang.org/account/avatar/00/18/7a/87/668a4f38.jpg","comment_is_top":false,"comment_ctime":1586109048,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5881076344","product_id":100039001,"comment_content":"1、会报错。虽然迭代器自身的没有变，但是arraylist的变了，导致不相等，因此会仍然报错。<br>1、会存在未觉行为。例如新增的元素在cursor之前会遍历不到新增的元素，假如情况2，新增的元素恰好在当前cursor之后所指的元素，也遍历不到新增的元素，如果不考虑新增的元素后续不再遍历的话，增加元素就不存在未觉行为。删除的元素为cursor所指的元素时，后续元素遍历不到。为了统一增加和删除，应该是会报错。具体待查看代码验证。","like_count":1},{"had_liked":false,"id":202802,"user_name":"牧名","can_delete":false,"product_type":"c1","uid":1020390,"ip_address":"","ucode":"193F0F33E1AB47","user_header":"https://static001.geekbang.org/account/avatar/00/0f/91/e6/03582dee.jpg","comment_is_top":false,"comment_ctime":1586071896,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5881039192","product_id":100039001,"comment_content":"`基于文章中给出的 Java 迭代器的实现代码，如果一个容器对象同时创建了两个迭代器，一个迭代器调用了 remove() 方法删除了集合中的一个元素，那另一个迭代器是否还可用？或者，我换个问法，下面代码中的第 13 行的运行结果是什么？`<br>后调用remove的迭代器会出错，即iterator2.next()会抛出ConcurrentModificationException异常","like_count":1},{"had_liked":false,"id":202559,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1586007623,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880974919","product_id":100039001,"comment_content":"    &#47;**课堂讨论<br>     * 1:<br>     * 当iterator1调用过remove, iterator2#next()时,<br>     * Iterator#checkForComodification()会检查 Iterator#expectedModCount<br>     * 与ArrayList#modCount是否一致.<br>     *  由于Iterator1#remove()时调用了ArrayList#remove(),<br>     *  而ArrayList#remove()调用了updateSizeAndModCount()导致ArrayList#modCount发生改变,<br>     *  所以iterator2#next()会fail-fast.<br>     *<br>     *  2:<br>     *  首先, LinkedList#iterator()返回的iterator实例与ArrayList#iterator()<br>     *  返回的实例出自于同一个类: AbstractList#Iter.<br>     *  换句话说, LinkedList#iterator()与ArrayList#iterator()的行为是完全一致的,<br>     *  会造成同样的不可预期结果.<br>     *<br>     *   *&#47;","like_count":1},{"had_liked":false,"id":202443,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1585989350,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880956646","product_id":100039001,"comment_content":"1、因为modCount和expectModCount不一致，iterator2在遍历时会抛出异常；              2、如果是单链表，如果在游标对应的元素之前增加元素，可能会导致新增加的元素遍历不到；如果删除的恰好是游标对应的元素，可能会导致无效指针错误。","like_count":1},{"had_liked":false,"id":202121,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1585905207,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"5880872503","product_id":100039001,"comment_content":"思考题1，会报错，iterator2中的 expectedModCount 是最开始的 4，而 names 中的 modCount 是 5，所以报错","like_count":1},{"had_liked":false,"id":202112,"user_name":"Ken张云忠","can_delete":false,"product_type":"c1","uid":1134288,"ip_address":"","ucode":"D0BAC9FC17DE2B","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","comment_is_top":false,"comment_ctime":1585904022,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880871318","product_id":100039001,"comment_content":"1.基于文章中给出的 Java 迭代器的实现代码，如果一个容器对象同时创建了两个迭代器，一个迭代器调用了 remove() 方法删除了集合中的一个元素，那另一个迭代器是否还可用？或者，我换个问法，下面代码中的第 13 行的运行结果是什么？<br>Exception in thread &quot;main&quot; java.util.ConcurrentModificationException<br>因为iterator2.expectedModCount的值与names.modCount的值不相等,expectedModCount比modCount小1.<br><br>2.LinkedList 底层基于链表，如果在遍历的同时，增加删除元素，会出现哪些不可预期的行为呢？<br>LinkedList与ArrayList一样,因为都是集成抽象类java.util.AbstractList,<br>在遍历的同时调用两次remove()都会抛出异常,都会抛出的是java.lang.IllegalStateException异常.<br>两个迭代器遍历的同时,其中一个迭代器删除元素都会使另一个迭代器抛出java.util.ConcurrentModificationException异常.<br>都不支持迭代器里添加元素.","like_count":1},{"had_liked":false,"id":202058,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1585895255,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880862551","product_id":100039001,"comment_content":"设计模式_66: <br># 作业<br>1. (代码有错误: 13行应该是`iterator2.next()`), 在`checkForComodification`方法抛出异常。因为`iterator1`remove会导致`iterator2`的`expectedModCount`与集合的`modCount`就不一致。<br>2. <br>- 删除游标之前元素，会导致遍历了已删除的元素。<br>- 增加游标之前的元素，会导致新增元素不被遍历。<br><br># 感想<br>对于“不可预期直接出错更加可怕”感触比较深，因为直接出错的问题一般会在自测(或单元测试)或提测后暴露出来，线上产品不会有问题。于是，“不可预期”的问题更多地会暴露在线上，最终牺牲了用户体验。","like_count":1},{"had_liked":false,"id":202052,"user_name":"君哥聊技术","can_delete":false,"product_type":"c1","uid":1325816,"ip_address":"","ucode":"2C9A22BCE4C79E","user_header":"https://static001.geekbang.org/account/avatar/00/14/3a/f8/c1a939e7.jpg","comment_is_top":false,"comment_ctime":1585893901,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880861197","product_id":100039001,"comment_content":"无论是ArrayList还是LinkedList，使用iterator的remove方法来remove元素后再遍历，都是不会报错的，使用list中的remove都会报错。因为expectedModCount != modCount<br>但是LinkedList删除元素，并不会移动后面的元素，所以不存在文中说的遍历不到的问题","like_count":1},{"had_liked":false,"id":202000,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1585885795,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880853091","product_id":100039001,"comment_content":"1.实现中,remove方法中,会在调用集合的remove方法后,将当前的修改量赋值到这个迭代器的内部的修改量属性上,但是对于其他迭代器调用的remove无法感知,自然无法修改本迭代器内部的修改量属性,导致next()会在调用checkForComodification()函数的时候发生报错<br>2.LinkedList,在增删的时候,由于双向链表的特性,只能感知到上一位和下一位,所以并不会导致异常情况的发生","like_count":1},{"had_liked":false,"id":347893,"user_name":"Geek_7e0e83","can_delete":false,"product_type":"c1","uid":2142423,"ip_address":"","ucode":"554DEE2AAAE33C","user_header":"","comment_is_top":false,"comment_ctime":1654564431,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654564431","product_id":100039001,"comment_content":"1.会抛出ConcurrentModificationException的异常，因为第二个迭代器调用next的时候检查modCount时已经不一致了。<br>2.linkedList 的迭代器和arrayList的实现类似，也会抛出ConcurrentModificationException。原因也一致","like_count":0},{"had_liked":false,"id":343953,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1651141551,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1651141551","product_id":100039001,"comment_content":"越到后面，人越少哦。哦豁。","like_count":0},{"had_liked":false,"id":328314,"user_name":"idiot","can_delete":false,"product_type":"c1","uid":2526391,"ip_address":"","ucode":"D7A6E980B530B4","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/fcftgBsticCicEEkuzB0GTkHIocX62YVTSvnhR1c94sccj42lVaYXrmcZyhzUI3l9NcvuN1rXLhXt2eBrZZ0Tw7A/132","comment_is_top":false,"comment_ctime":1640663515,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1640663515","product_id":100039001,"comment_content":"讨论题属于细节了，不值得深究。作为用户来说，简单地不在遍历时修改容器就对了。这节课重要的概念是，作为框架开发者来说，怎么主动检测用户的错误使用方式（如果无法避免）并报错。","like_count":0},{"had_liked":false,"id":326852,"user_name":"HomeyLiu","can_delete":false,"product_type":"c1","uid":1330141,"ip_address":"","ucode":"EF4CCB92C369B4","user_header":"https://static001.geekbang.org/account/avatar/00/14/4b/dd/41614582.jpg","comment_is_top":false,"comment_ctime":1639721461,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639721461","product_id":100039001,"comment_content":"LinkedList和ArrayList行为一致。<br>我看了LinkedList的源码.添加元素和增加元素,一样会导致未决行为结果.<br><br>没看源码的不要瞎逼逼!","like_count":0},{"had_liked":false,"id":275643,"user_name":"子房","can_delete":false,"product_type":"c1","uid":1438860,"ip_address":"","ucode":"CB05938C248BB3","user_header":"https://static001.geekbang.org/account/avatar/00/15/f4/8c/0866b228.jpg","comment_is_top":false,"comment_ctime":1611630368,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611630368","product_id":100039001,"comment_content":"学习了，很受用","like_count":0},{"had_liked":false,"id":260001,"user_name":"瓶子霸哥","can_delete":false,"product_type":"c1","uid":1125806,"ip_address":"","ucode":"A7EEB459AB5550","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/nVVI6Fib5LHbhAhv8CJ9MYPau7Lcp840ST6BeqnlibUNmI4UYvGIzxtOHcKIzFa10ERANAZQUaiaKkQg4SowsUR2g/132","comment_is_top":false,"comment_ctime":1604905099,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1604905099","product_id":100039001,"comment_content":"为什么有 lastRet 啊，remove 的时候直接让 cursor -= 1 不行吗","like_count":0,"discussions":[{"author":{"id":1363822,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/uktgj5R0p78c67oLib8EuRMRCgP8yjxnZ1ibVOuibhRZvjJpKSJNaTl0UlEfGyiaaiaGyPmqpGYpibTt0QopX1qtWfQQ/132","nickname":"杨大小最嗨皮","note":"","ucode":"7DFACF1414AE16","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374968,"discussion_content":"为了支持从后往前遍历","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621423608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239724,"user_name":"Leon Wong","can_delete":false,"product_type":"c1","uid":1073650,"ip_address":"","ucode":"B49B327367CF9E","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/f2/ca989d6f.jpg","comment_is_top":false,"comment_ctime":1596623415,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596623415","product_id":100039001,"comment_content":"思考题1：<br><br>关键点在于 expectedModCount 变量是 Iterator 维护的本地变量，当使用remove方法的时候会使得 modCount发生改变，而iterator2的本地expectedModCount变量并未及时改变，因此会出现未决行为","like_count":0},{"had_liked":false,"id":204448,"user_name":"不能忍的地精","can_delete":false,"product_type":"c1","uid":1754913,"ip_address":"","ucode":"66A921C0BC8102","user_header":"","comment_is_top":false,"comment_ctime":1586401553,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586401553","product_id":100039001,"comment_content":"思考题: 1. 运行结果报错,因为第一个迭代器remove()改变了modCount的值和exceptMod的值,但是第二个没有改变","like_count":0},{"had_liked":false,"id":203287,"user_name":"L🚲🐱","can_delete":false,"product_type":"c1","uid":1577856,"ip_address":"","ucode":"08A012739614DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","comment_is_top":false,"comment_ctime":1586165853,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586165853","product_id":100039001,"comment_content":"打卡，长知识了，以前在普通foe循环中 写过删除后再访问元素的代码😂","like_count":0},{"had_liked":false,"id":203091,"user_name":"Geek_3b1096","can_delete":false,"product_type":"c1","uid":1549364,"ip_address":"","ucode":"A6BD92B79B3632","user_header":"","comment_is_top":false,"comment_ctime":1586138664,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586138664","product_id":100039001,"comment_content":"清楚了谢谢老师","like_count":0}]}