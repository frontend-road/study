{"id":413708,"title":"13 | 在 Spring 项目中如何进行单元测试？","content":"<p>你好，我是郑晔！</p><p>上一讲，我们将 ToDo 应用从命令行扩展为了 REST 服务。在这个应用里，我们用到了 Spring 这个在 Java 世界中广泛使用的框架。大多数人对于 Spring 这个框架的认知都停留在如何使用它完成各种功能特性上，而 Spring 更大的价值其实在对于开发效率的巨大提升上，其中就包含了对测试的支持。</p><p>在接下来的两讲，我们就把注意力从一个具体的项目上挪开，放到 Spring 框架本身，看看它对开发效率提升的支持。</p><h2>轻量级开发的 Spring</h2><p>很多人对于 Spring 的理解是从依赖注入容器开始的，但是，Spring 真正对行业的影响却是从它对原有开发模式的颠覆开始。</p><p>在 21 世纪初的时候，Java 世界的主流开发方式是 J2EE，也就是 Java 的企业版。在那个时候，企业版代表软件开发的最高水准。在这个企业版的构想中，所有的复杂都应该隐藏起来，写代码的程序员不需要知道各种细节，需要的东西拿过来用就好了。</p><p>这种想法本身是没有问题的，时至今日，很多平台和框架也是这么想的。到了具体的做法上，J2EE 提供了一个应用服务器，我把这些复杂性都放在这个应用服务器里实现，你写好的程序部署到这个应用服务器上就万事大吉了。但正是因为应用服务器的存在，使用 J2EE 进行开发变成了一件无比复杂的事情。</p><!-- [[[read_end]]] --><p>将程序打包部署这件事说起来很简单，但在实际的工作中，如果一个团队没有做好自动化，打包部署会非常麻烦。再者，除了自己的业务代码，所有相关的第三方 JAR 包都需要打到最终的发布包中，造成的结果就是发布包非常大。在那个网络带宽还不是特别大的年代，传输这个发布包也要花很长的时间。</p><p>更关键的是，一旦出了问题怎么去定位也是个令人头疼的问题。</p><p>程序员最熟悉定位问题的方式就是调试代码。之前所有的代码都是在本地，调试起来还比较容易，现在代码运行在应用服务器上，我们必须连接到远程应用服务器上进行调试，而要连接应用服务器进行调试，还需要一些配置，总之，这件事真的是非常麻烦。</p><p>对于麻烦的事情，人们倾向于少做或不做，但是  J2EE 让这件麻烦事成了必选项。所以，那个年代的 Java 程序员处于一种痛苦不堪的状态，开发效率极其低下。</p><p>就在整个 Java 社区饱受折磨之际，Spring 横空出世。对于 J2EE 提出的问题，Spring 是承认的，但对其给出的解决方案，它却是不认的。因为应用服务器太重了，Spring 给社区带来了轻量级开发。</p><p>Spring 的逻辑很简单，这些东西通过程序库的方式就可以完成，为什么非要弄一个应用服务器呢？采用程序库的方式，最大的优势就在于可以在本地开发环境中进行开发和调试，这就极大地降低开发的难度。于是，对于同样的问题，Spring 抛弃了 J2EE 中的大部分内容，给出了自己的程序库解决方案，应用服务器变得可有可无了。</p><p>事实证明，人们更喜爱简单的解决方案，即便 J2EE 有强大的官方背书，程序员们还是义无反顾地抛弃了它。Spring 从此成了 Java 社区的主流，也成了轻量级开发的代名词。</p><p>Spring 不仅是恰当地把握了时机，占据了 Java 世界中的关键位置，更重要的是，在随后的发展中，一直凭借对于轻量级开发的追求以及良好的品位，使得它在 Java 程序员心目中占据着无可替代的位置。即便中间有部分地方其它的程序库做得稍微好一些，它也能很快地学习过来。</p><p>前面我说过，虽然 Spring 抛弃了 J2EE 中的大部分内容，基于 Web 服务器的开发还是得到了保留。因为当时确实没有什么更好的选择，虽然大部分代码可以在本地测试，但很多时候我们还是要打成一个 WAR 包部署到像 Tomcat 这样的 Web 服务器上。不过，随着 Tomcat 和一众 Web 服务器提供了可嵌入的 API，打包部署这种 J2EE 残留方式就彻底成为了过去，也就诞生今天很多 Java 程序员熟悉的 Spring Boot，可以说 Spring Boot 是 Spring 多年努力的集大成者！</p><h2>Spring 的测试</h2><p>不过在 Spring Boot 出现之前，正是因为无法摆脱打包部署的这样的模式，基于这条路走下去开发难度依然不小，可以说并没有从根本上改变问题。但 Spring 的轻量级开发理念是支撑它一路向前的动力，既然那个时候  Web 服务器不能舍弃，索性 Spring 就选择了另外一条路：从测试支持入手。</p><p>所以  Spring 提供了一条测试之路，让我们在最终打包之前，能够让自己编写的代码在本地得到完整验证。你在实战环节中已经见识过如何使用 Spring 做测试了。简单来说就是<strong>使用单元测试构建稳定的业务核心，使用 Spring 提供的基础设施进行集成测试。</strong></p><p>严格地说，构建稳定的业务核心其实并不依赖于 Spring，但 Spring 提供了一个将组件组装到一起基础设施，也就是依赖注入（Dependency Injection，简称 DI）容器。通常我们会利用 DI 容器完成我们的工作，也正是因为 DI 容器用起来很容易，所以常常会造成 <strong>DI 容器的误用，反而会阻碍测试。</strong></p><p>在<a href=\"https://time.geekbang.org/column/article/408187\">第6讲</a>中，我们讨论过要编写能够组合的代码。依赖注入的风格会引导我们编写能够组合的代码，也就是不要在类的内部创建组件，而是通过依赖注入的方式将组件注入到对象之中。</p><p>所以，在一个使用 Spring 项目进行单元测试的关键就是，<strong>保证代码可以组合的，也就是通过依赖注入的。</strong>你可能会说，我们都用了 Spring，那代码肯定是组合的。这还真不一定，有些错误的做法就会造成对依赖注入的破坏，进而造成单元测试的困难。</p><h3>不使用基于字段的注入</h3><p>有一种典型的错误就是基于字段的注入，比如像下面这样。</p><pre><code>@Service\npublic class TodoItemService {\n  @Autowired\n  private TodoItemRepository repository;\n\n}\n</code></pre><p>@Autowired 是一个很好用的特性，它会告诉 Spring 自动帮我们注入相应的组件。在字段上加Autowired 是一个容易写的代码，但它对单元测试却很不友好，因为你需要很繁琐地去设置这个字段的值，比如通过反射。</p><p>如果不使用基于字段的注入该怎么做呢？其实很简单，提供一个构造函数就好，把@Autowired 放在构造函数上，像下面这样子。</p><pre><code>@Service\npublic class TodoItemService {\n  private final TodoItemRepository repository;\n\n  @Autowired\n  public TodoItemService(final TodoItemRepository repository) {\n    this.repository = repository;\n  }\n  ...\n}\n</code></pre><p>这样一来，编写测试的时候我们只要像普通对象一样去测试就好了，具体的做法你要是记不清了，可以去回顾一下实战环节。</p><p>这种构造函数一般我们都可以利用 IDE 的快捷键生成，所以这段代码对我们来说也不是很重的负担。如果你还嫌弃这种代码的冗余，也可以用 Lombok（Lombok 是一个帮助我们生成代码的程序库）的 Annotation 来简化代码，像下面这样。</p><pre><code>@Service\n@RequiredArgsConstructor\npublic class TodoItemService {\n  private final TodoItemRepository repository;\n\n  ...\n}\n</code></pre><h3>不依赖于 ApplicationContext</h3><p>使用 Spring 还有一种典型的错误，就是通过 ApplicationContext 获取依赖的对象，比如像下面这样。</p><pre><code>@Service\npublic class TodoItemService {\n  @Autowired\n  private ApplicationContext context;\n  \n  private TodoItemRepository repository; \n  \n  public TodoItemService() {\n    this.repository = context.getBean(TodoItemRepository.class);\n  }\n  ...\n}\n</code></pre><p>我们可以把 ApplicationContext 理解成 DI 容器，原本使用 DI 容器的优点就是可以不知晓依赖是怎么产生的，而在这段代码里，却知晓了 DI 容器，这就完全打破了 DI 容器设计的初衷（关于 Spring 的设计初衷，我在《软件设计之美》中专门<a href=\"https://time.geekbang.org/column/article/241123\">有一讲</a>分析过，如果你有兴趣可以去了解一下）。</p><p><strong>在业务核心代码中出现 ApplicationContext 是一种完全错误的做法。</strong>一方面，它打破了 DI 容器原本的设计，另一方面，还让业务核心代码对第三方代码（也就是 ApplicationContext）产生了依赖。</p><p>我们再从设计的角度看一下，AppliationContext 的出现使得我们在测试这段代码时，必须引入 ApplicationContext。要想在代码里获取到相应的组件，需要在测试中向 ApplicationContext 里添加相应的组件，这会让一个原本很简单的测试变得复杂起来。</p><p>你看，一个正常的测试是如此简单，但正是因为引入了 Spring，许多人反而会做错。Spring 最大的优点是可以在代码层面上不依赖于 Spring，而错误的做法反而是深深地依赖于 Spring。</p><p>我们前面讨论了这么多，其实并没有针对 Spring 对单元测试的支持进行讲解，但 Spring 其实还真提供了一个对单元测试的支持，也就是@MockBean，也就是帮我们进行 Mock 对象的初始化，像对于下面这行代码来说：</p><pre><code>@MockBean\nprivate TodoItemRepository repository;\n</code></pre><p>它就等同于下面这段。</p><pre><code>@BeforeEach\npublic void setUp() {\n  this.repository = mock(TodoItemRepository.class);\n  ...\n}\n</code></pre><p>但是我并不想特意强调这种做法。一方面，这种初始化的代码清晰且不复杂，另一方面，即便我们真的打算节省这两行的代码，更好的做法是根据你使用的 Mock 框架采用其对应的做法。比如使用 Mockito，我们可以像下面这么写。</p><pre><code>@ExtendWith(MockitoExtension.class)\npublic class TodoItemServiceTest {\n  @Mock\n  private TodoItemRepository repository;\n}\n</code></pre><p>不过@MockBean 并非一无是处，我们在集成测试中会用到它，让它参与到依赖注入的过程中去。下一讲，我们就来讨论一下如何使用 Spring 进行集成测试。</p><h2>总结时刻</h2><p>这一讲我们讲到了 Spring 这个 Java 世界使用最广泛的框架，它最大的贡献是对开发模式的颠覆：由原来 J2EE 依赖于部署的重量级开发模式，到可以在本地开发环境完成主要工作的轻量级开发方式。</p><p>轻量级的开发方式是 Spring 一以贯之的追求，采用 Spring 开发可以在部署到容器之前就完成所有代码的验证，其中对测试的支持是非常重要的一环。</p><p>虽然我们今天的主题是如何使用 Spring 进行单元测试，但实际上真正做好的业务测试和普通代码的测试是没有区别的，所以，我们更多地是在谈如何规避过度使用 Spring 框架犯下的错误。比如不要使用基于字段的注入，也不要依赖于 ApplicationContext 获取相应的依赖，这些做法都会让原本简单的测试变得复杂。</p><p>如果今天的内容你只能记住一件事，那请记住：<strong>业务代码不要过度依赖于框架。</strong></p><h2>思考题</h2><p>今天我们的重点是错误使用了框架，你在实际的工作中，遇到过度使用框架特性，反而让代码陷入难以调整的困境吗？欢迎在留言区分享你的经验。</p>","neighbors":{"left":{"article_title":"12 | 实战：将 ToDo 应用扩展为一个 REST 服务","id":412830},"right":{"article_title":"14 | 在 Spring 项目如何进行集成测试？","id":414448}},"comments":[{"had_liked":false,"id":310567,"user_name":"邓志国","can_delete":false,"product_type":"c1","uid":1043844,"ip_address":"","ucode":"380AE67ED7B9D7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/84/0b8e2d25.jpg","comment_is_top":false,"comment_ctime":1630748166,"is_pvip":false,"replies":[{"id":"112544","content":"多谢补充","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1630817507,"ip_address":"","comment_id":310567,"utype":1}],"discussion_count":1,"race_medal":0,"score":"48875388422","product_id":100085101,"comment_content":"构造函数不写autowire也能依赖注入","like_count":12,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526277,"discussion_content":"多谢补充","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630817507,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321239,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1636722404,"is_pvip":false,"replies":[{"id":"116699","content":"其实就差一点点","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1636815421,"ip_address":"","comment_id":321239,"utype":1}],"discussion_count":4,"race_medal":0,"score":"18816591588","product_id":100085101,"comment_content":"一直错误使用字段注入，所以感觉单元测试非常难","like_count":5,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530249,"discussion_content":"其实就差一点点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636815421,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2556910,"avatar":"https://static001.geekbang.org/account/avatar/00/27/03/ee/7bd2b994.jpg","nickname":"舍大家保小佳","note":"","ucode":"6387EF881816C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580116,"discussion_content":"如果以前使用的时基于字段的注入，那么单元测试时，也可以考虑使用org.springframework.test.util.ReflectionTestUtils，通过反射，注入依赖。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1657877571,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2556910,"avatar":"https://static001.geekbang.org/account/avatar/00/27/03/ee/7bd2b994.jpg","nickname":"舍大家保小佳","note":"","ucode":"6387EF881816C1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580135,"discussion_content":"谢谢，现在大多改成构造函数注入了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657902800,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":580116,"ip_address":""},"score":580135,"extra":""},{"author":{"id":1183703,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0f/d7/31d07471.jpg","nickname":"牛年榴莲","note":"","ucode":"230C076193C6C0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2556910,"avatar":"https://static001.geekbang.org/account/avatar/00/27/03/ee/7bd2b994.jpg","nickname":"舍大家保小佳","note":"","ucode":"6387EF881816C1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591029,"discussion_content":"这是个好办法，以前遇到使用@Autowired注入的时候，又去加了个setter，😓","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666233359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":580116,"ip_address":"北京"},"score":591029,"extra":""}]}]},{"had_liked":false,"id":310052,"user_name":"蔡奎","can_delete":false,"product_type":"c1","uid":1184625,"ip_address":"","ucode":"2846E2C3CE60D9","user_header":"https://static001.geekbang.org/account/avatar/00/12/13/71/887f0c83.jpg","comment_is_top":false,"comment_ctime":1630472367,"is_pvip":false,"replies":[{"id":"112393","content":"你说得对，从单元测试的角度，不依赖于Spring是最好的测试选择。依赖于Spring属于集成测试，是下一讲的内容。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1630545532,"ip_address":"","comment_id":310052,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14515374255","product_id":100085101,"comment_content":"老师,spring 应用中依赖太多，每次启动都需要几分钟，如何保证测试。为了减少启动时间，步子都会迈大了，导致一些逻辑都不会写测试。最后就放弃测试。","like_count":4,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526113,"discussion_content":"你说得对，从单元测试的角度，不依赖于Spring是最好的测试选择。依赖于Spring属于集成测试，是下一讲的内容。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630545532,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":310014,"user_name":"我的康康","can_delete":false,"product_type":"c1","uid":1501436,"ip_address":"","ucode":"E7E2C969A91F8C","user_header":"https://static001.geekbang.org/account/avatar/00/16/e8/fc/4d84560f.jpg","comment_is_top":false,"comment_ctime":1630457672,"is_pvip":false,"replies":[{"id":"112307","content":"是的","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1630458978,"ip_address":"","comment_id":310014,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14515359560","product_id":100085101,"comment_content":"老师，那平常开发过程中，也是不推荐用基于字段注入 而是推荐用基于构造方法注入吗？","like_count":4,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526100,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630458978,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327822,"user_name":"null","can_delete":false,"product_type":"c1","uid":1880003,"ip_address":"","ucode":"1B8F3E9B047E7D","user_header":"https://static001.geekbang.org/account/avatar/00/1c/af/c3/b213e913.jpg","comment_is_top":false,"comment_ctime":1640316959,"is_pvip":false,"replies":[{"id":"119841","content":"循环依赖其实是一种设计的失败，应该先改善设计，再来设计。","user_name":"作者回复","user_name_real":"编辑","uid":"1258861","ctime":1640958903,"ip_address":"","comment_id":327822,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5935284255","product_id":100085101,"comment_content":"一些场景不适合使用构造器注入的呢？比如循环依赖。","like_count":2,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543137,"discussion_content":"循环依赖其实是一种设计的失败，应该先改善设计，再来设计。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640958903,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1185259,"avatar":"https://static001.geekbang.org/account/avatar/00/12/15/eb/a2955dd6.jpg","nickname":"5%","note":"","ucode":"66E71A77A00923","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":549238,"discussion_content":"循环依赖和DDD设计中的聚合根思想是违背的吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643766656,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":543137,"ip_address":""},"score":549238,"extra":""}]}]},{"had_liked":false,"id":312418,"user_name":"sylan215","can_delete":false,"product_type":"c1","uid":1019029,"ip_address":"","ucode":"5A2CF31BC69F40","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/95/4544d905.jpg","comment_is_top":false,"comment_ctime":1631792323,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5926759619","product_id":100085101,"comment_content":"有幸在 Java1.5 的时代就接触了 Java，那时候 Java 的三个方向是 J2EE、J2SE、J2ME，后面 Spring 横空出世时，我就没有了解了，不过挺老师这么一说，真的是个转折点了。<br><br>至于框架对测试的支持，我也有过体会，比如 Python 里面的 Django 框架对测试的支持就是特别好，我当时学习的一个教程，就是一边讲代码，一边写测试，毫无违和感。<br><br>当然，老师也说了，不要过度依赖某些特性，所以怎么把框架特性，适度合理的进行利用，也是一个技术活。","like_count":2},{"had_liked":false,"id":348310,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1654951414,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654951414","product_id":100085101,"comment_content":"平时同事，还有我自己都是基于字段注入的","like_count":0},{"had_liked":false,"id":348309,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1654951338,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654951338","product_id":100085101,"comment_content":"业务代码不要过度依赖于框架。--记下来","like_count":0},{"had_liked":false,"id":347945,"user_name":"😚 46","can_delete":false,"product_type":"c1","uid":1433535,"ip_address":"","ucode":"EED0EBBBF80A43","user_header":"https://static001.geekbang.org/account/avatar/00/15/df/bf/96b50d1e.jpg","comment_is_top":false,"comment_ctime":1654595669,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654595669","product_id":100085101,"comment_content":"@MockBean 可以设置 Bean 的行为吗？","like_count":0},{"had_liked":false,"id":341725,"user_name":"花花大脸猫","can_delete":false,"product_type":"c1","uid":1117318,"ip_address":"","ucode":"8ABDB3F7F4FB0F","user_header":"https://static001.geekbang.org/account/avatar/00/11/0c/86/8e52afb8.jpg","comment_is_top":false,"comment_ctime":1649810207,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1649810207","product_id":100085101,"comment_content":"因为字段注入的问题，导致mock对象很难，后续全部调整成了构造器注入，另外我的观念是尽量单元测试不需要springboot的运行时环境依赖，这样会使得单元测试不纯粹，还需要依赖外部组件启动玩成才能运行","like_count":1,"discussions":[{"author":{"id":1756909,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKDe7Ep3YW87rib33lhErnnkEsdfOJUDlDgHDs9Nic88FHU8s2feX6preYqR46TDsOMW7Eib6ddUyr0A/132","nickname":"我爱搞钱","note":"","ucode":"CBB1DF3ACE1026","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":567377,"discussion_content":"字段注入导致单元测试困难？？？困难在哪里？？？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650897829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311393,"user_name":"Geek_3b1096","can_delete":false,"product_type":"c1","uid":1549364,"ip_address":"","ucode":"A6BD92B79B3632","user_header":"","comment_is_top":false,"comment_ctime":1631200232,"is_pvip":false,"replies":[{"id":"112847","content":"就是用起来容易，才容易犯错误","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1631237290,"ip_address":"","comment_id":311393,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1631200232","product_id":100085101,"comment_content":"ApplicationContext用起来简单，之后会避免","like_count":1,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526585,"discussion_content":"就是用起来容易，才容易犯错误","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631237290,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}