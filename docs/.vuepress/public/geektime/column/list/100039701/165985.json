{"id":165985,"title":"03 | a.x = a = {n:2}：一道被无数人无数次地解释过的经典面试题","content":"<p>你好，我是周爱民。</p><p>在前端的历史中，有很多人都曾经因为同一道面试题而彻夜不眠。这道题出现在9年之前，它的提出者“蔡mc（蔡美纯）”曾是JQuery的提交者之一，如今已经隐去多年，不复现身于前端。然而这道经典面试题仍然多年挂于各大论坛，被众多后来者一遍又一遍地分析。</p><p>在2010年10月，<a href=\"https://github.com/snandy\">Snandy</a>于iteye/cnblogs上发起对这个话题的讨论之后，淘宝的玉伯（lifesinger）也随即成为这个问题早期的讨论者之一，并写了一篇“<strong>a.x = a = { }, 深入理解赋值表达式</strong>”来专门讨论它。再后来，随着它在各种面试题集中频繁出现，这个问题也就顺利登上了知乎，成为一桩很有历史的悬案。</p><p>蔡mc最初提出这个问题时用的标题是“<strong>赋值运算符:\"=\", 写了10年javascript未必全了解的\"=\"</strong>”，原本的示例代码如下：</p><pre><code>var c = {};\nc.a = c = [];\nalert(c.a); //c.a是什么？\n</code></pre><p>蔡mc是在阅读JQuery代码的过程中发现了这一使用模式：</p><pre><code>elemData = {}\n...\nelemData.events = elemData = function(){};\nelemData.events  = {};\n</code></pre><p>并质疑，<span class=\"orange\">为什么<code>elemData.events</code>需要连续两次赋值。</span>而Snandy在转述的时候，换了一个更经典、更有迷惑性的示例：</p><pre><code>var a = {n:1};\na.x = a = {n:2};\nalert(a.x); // --&gt; undefined\n</code></pre><p>Okay，这就是今天的主题。</p><p>接下来，我就为你解释一下，<span class=\"orange\">为什么在第二行代码之后<code>a.x</code>成了undefined值。</span></p><!-- [[[read_end]]] --><h2>与声明语句的不同之处</h2><p>你可能会想，三行代码中出问题的，为什么不是第1行代码？</p><p>在上一讲的讨论中，声明语句也可以是一个连等式，例如：</p><pre><code>var x = y = 100;\n</code></pre><p>在这个示例中，“var”关键字所声明的，事实上有且仅有“x”一个变量名。</p><p>在可能的情况下，变量“y”会因为赋值操作而导致JavaScript引擎“<strong>意外</strong>”创建一个全局变量。所以，声明语句“var/let/const”的一个关键点在于：语句的关键字var/let/const只是用来“声明”变量名x的，去除掉“var x”之后剩下的部分，并不是一个严格意义上的“赋值运算”，而是被称为“初始器（Initializer）”的语法组件，它的词法描述为：</p><blockquote>\n<p><em>Initializer</em>: <strong>=</strong>  <em>AssignmentExpression</em></p>\n</blockquote><p>在这个描述中，“=”号并不是运算符，而是一个语法分隔符号。所以，之前我在讲述这个部分的时候，总是强调它“被实现为一个赋值操作”，而不是直接说“它是一个赋值操作”，原因就在这里。</p><p>如果说在语法“var x = 100”中，“= 100”是向x绑定值，那么“var x”就是单纯的标识符声明。这意味着非常重要的一点——<strong>“x”只是一个表达名字的、静态语法分析期作为标识符来理解的字面文本，而不是一个表达式</strong>。</p><p>而当我们从相同的代码中去除掉“var”关键字之后：</p><pre><code>x = y = 100;\n</code></pre><p>其中的“x”却是一个表达式了，它被严格地称为“赋值表达式的左手端（lhs）操作数”。</p><p>所以，关键的区别在于：（赋值表达式左侧的）操作数可以是另一个表达式——这在专栏的第一讲里就讲过了，而“var声明”语句中的等号左边，绝不可能是一个表达式！</p><p>也许你会质疑：难道ECMAScript 6之后的模板赋值的左侧，也不是表达式？确实，答案是：如果它用在声明语句中，那么就“不是”。</p><p>对于声明语句来说，紧随于“var/let/const”之后的，一定是变量名（标识符），且无论是一个或多个，都是在JavaScript语法分析阶段必须能够识别的。</p><p>如果这里是赋值模板，那么“var/let/const”语句也事实上只会解析那些用来声明的变量名，并在运行期使用“初始器（Initializer）”来为这些名字绑定值。这样，“变量声明语句”的语义才是确定的，不至于与赋值行为混淆在一起。</p><p>因此，根本上来说，在“var声明”语法中，变量名位置上就是写不成<code>a.x</code>的。例如：</p><pre><code>var a.x = ...   // &lt;- 这里将导致语法出错\n</code></pre><p>所以，在最初蔡mc提出这个问题时，以及其后Sanady和玉伯的转述中，都不约而同地在代码中绕过了第一行的声明，而将问题指向了第二行的连续赋值运算。</p><pre><code>var a = {n:1};   // 第一行\na.x = a = {n:2};  // 第二行\n...\n</code></pre><h2>来自《JavaScript权威指南》的解释</h2><p>有人曾经引述《JavaScript权威指南》中的一段文字（4.7.7 运算顺序），来解释第二行的执行过程：</p><blockquote>\n<p>JavaScript总是严格按照从左至右的顺序来计算表达式。</p>\n</blockquote><p>并且还举了一个例子：</p><blockquote>\n<p>例如，在表达式<code>w = x + y * z</code>中，将首先计算子表达式w，然后计算x、y和z；然后，y的值和z的值相乘，再加上x的值；最后将其赋值给表达式w所指代的变量或属性。</p>\n</blockquote><p>《JavaScript权威指南》的解释是没有问题的。首先，在这个赋值表达式的右侧<code>x + y*z</code>中，<code>x</code>与<code>y*z</code>是求和运算的两个操作数，任何运算的操作数都是严格从左至右计算的，因此x先被处理，然后才会尝试对<code>y</code>和<code>z</code>求乘积。<span class=\"orange\">这里所谓的“x先被处理”是JavaScript中的一个特异现象</span>，即：</p><blockquote>\n<p>一切都是表达式，一切都是运算。</p>\n</blockquote><p>这一现象在语言中是函数式的特性，类似“一切被操作的对象都是函数求值的结果，一切操作都是函数”。</p><p>这对于以过程式的，或编译型语言为基础的学习者来说是很难理解的，因为在这些传统的模式或语言范型中，所谓“标识符/变量”就是一个计算对象，它可能直接表达为某个内存地址、指针，或者是一个编译器处理的东西。对于程序员来说，将这个变量直接理解为“操作对象”就可以了，没有别的、附加的知识概念。例如：</p><pre><code>a = 100\nb * c\n</code></pre><p>这两个例子中，a、b、c都是确定的操作数，我们只需要</p><ul>\n<li>将第一行理解为“a有了值100”；</li>\n<li>将第二行理解为“b与c的乘积”</li>\n</ul><p>就可以了，至于引擎怎么处理这三个变量，我们是不管的。</p><p>然而在JavaScript中，上面一共是有六个操作的。以第二行为例，包括：</p><ul>\n<li>将<code>b</code>理解为单值表达式，求值并得到<code>GetValue(evalute('b'))</code>；</li>\n<li>将<code>c</code>理解为单值表达式，求值并得到<code>GetValue(evalute('c'))</code>；</li>\n<li>将上述两个值理解为求积表达式’*'的两个操作数，计算</li>\n</ul><blockquote>\n<p><code>evalute('*', GetValue(evalute('b')), GetValue(evalute('c')))</code></p>\n</blockquote><p>所以，关键在于<code>b</code>和<code>c</code>在表达式计算过程中都并不简单的是“一个变量”，而是“一个单值表达式的计算结果”。这意味着，在面对JavaScript这样的语言时，你需要关注“变量作为表达式是什么，以及这样的表达式如何求值（以得到变量）”。</p><p>那么，现在再比较一下今天这一讲和上一讲的示例：</p><pre><code>var x = y = 100;\na.x = a = {n:2}\n</code></pre><p>在这两个例子中，</p><ul>\n<li>x是一个标识符（不是表达式），而y和100都是表达式，且<code>y = 100</code>是一个赋值表达式。</li>\n<li>a.x是一个表达式，而<code>a = {n:2}</code>也是表达式，并且后者的每一个操作数（本质上）也都是表达式。</li>\n</ul><p>这就是“语句与表达式”的不同。正如上一讲的所强调的：“<strong>var x”从来都不进行计算求值，所以也就不能写成“var a.x …</strong>”。</p><blockquote>\n<p>所以严格地说，在上一讲的例子中，并不存在连续赋值运算，因为“var x = …”是<strong>值绑定操作</strong>，而不是“将…赋值给x”。在代码<code>var x = y = 100;</code>中实际只存在一个赋值运算，那就是“y = 100”。</p>\n</blockquote><h2>两个连续赋值的表达式</h2><p>所以，今天标题中的这行代码，是真正的、两个连续赋值的表达式：</p><pre><code>a.x = a = {n:2}\n</code></pre><p>并且，按照之前的理解，<code>a.x</code>总是最先被计算求值的（从左至右）。</p><p>回顾第一讲的内容，你也应该记得，所谓“a.x”也是一个表达式，其结果是一个“引用”。这个表达式“a.x”本身也要再计算它的左操作数，也就是“a”。完整地讲，“a.x”这个表达式的语义是：</p><ul>\n<li>计算单值表达式<code>a</code>，得到<code>a</code>的引用；</li>\n<li>将右侧的名字<code>x</code>理解为一个标识符，并作为“.”运算的右操作数；</li>\n<li>计算“a.x”表达式的结果（Result）。</li>\n</ul><p>表达式“a.x”的计算结果是一个引用，因此通过这个引用保存了一些计算过程中的信息——例如它保存了“a”这个对象，以备后续操作中“可能会”作为<code>this</code>来使用。所以现在，在整行代码的前三个表达式计算过程中，“a”是作为一个<strong>引用</strong>被暂存下来了的。</p><p>那么这个“a”现在是什么呢？</p><pre><code>var a = {n:1};\na.x = ...\n</code></pre><p>从代码中可见，保存在“a.x”这个引用中的“a”是当前的“{n:1}”这个对象。好的，接下来再继续往下执行：</p><pre><code>var a = {n:1};\na.x =     // &lt;- `a` is {n:1}\n      a = // &lt;- `a` is {n:1}\n...\n</code></pre><p>这里的“a = …”中的<code>a</code>仍然是当前环境中的变量，与上一次暂存的值是相同的。这里仍然没有问题。</p><p>但接下来，发生了赋值：</p><pre><code>...\na.x =              // &lt;- `a` is {n:1}\n      a =          // &lt;- `a` is {n:1}\n          {n:2};   // 赋值，覆盖当前的左操作数（变量`a`）\n</code></pre><p>于是，左操作数<code>a</code>作为一个引用被覆盖了，这个引用仍然是当前上下文中的那个变量<code>a</code>。因此，这里真实地发生了一次<code>a = {n:2}</code>。</p><p>那么现在，表达式最开始被保留在“一个结果（Result）”中的引用<code>a</code>会更新吗？</p><p>不会的。这是因为那是一个“<strong>运算结果</strong>（Result）”，这个结果有且仅有引擎知道，它现在是一个引擎才理解的“<strong>引用</strong>（规范对象）”，对于它的可能操作只有：</p><ul>\n<li>取值或置值（GetValue/PutValue），以及</li>\n<li>作为一个引用向别的地方传递等。</li>\n</ul><p>当然，如同第一讲里强调的，它也可以被typeof和delete等操作引用的运算来操作。但无论如何，在JavaScript用户代码层面，能做的主要还是<strong>取值</strong>和<strong>置值</strong>。</p><p>现在，在整个语句行的最左侧“<strong>空悬</strong>”了一个已经求值过的“a.x”。当它作为赋值表达式的左操作数时，它是一个被赋值的引用（这里是指将<code>a.x</code>的整体作为一个引用规范对象）。而它作为结果（Result）所保留的“a”，是在被第一次赋值操作覆盖之前的、那个“原始的变量<code>a</code>”。也就是说，如果你试图访问它的“a.n”，那应该是值“1”。</p><p>这个被赋值的引用“a.x”其实是一个未创建的属性，赋值操作将使得那个“原始的变量<code>a</code>”具有一个新属性，于是它变成了下面这样：</p><pre><code>// a.x中的“原始的变量`a`”\n{\n  x: {n: 2},  // &lt;- 第一次赋值“a = {n:2}”的结果\n  n: 1\n}\n</code></pre><p>这就是第二次赋值操作的结果。</p><h2>复现现场</h2><p>上面发生了两次赋值，第一次赋值发生于“a = {n: 2}”，它覆盖了“原始的变量<code>a</code>”；第二次赋值发生于被“a.x”引用暂存的“原始的变量<code>a</code>”。</p><p>我可以给出一段简单的代码，来复现这个现场，以便你看清这个结果。例如：</p><pre><code>// 声明“原始的变量a”\nvar a = {n:1};\n\n// 使它的属性表冻结（不能再添加属性）\nObject.freeze(a);\n\ntry {\n  // 本节的示例代码\n  a.x = a = {n:2};\n}\ncatch (x) {\n  // 异常发生，说明第二次赋值“a.x = ...”中操作的`a`正是原始的变量a\n  console.log('第二次赋值导致异常.');\n}\n\n// 第一次赋值是成功的\nconsole.log(a.n); //\n</code></pre><p>第二次赋值操作中，将尝试向“原始的变量<code>a</code>”添加一个属性“a.x“，且如果它没有冻结的话，属性“a.x”会指向第一次赋值的结果。</p><h2>回到标题中的示例</h2><p>那标题中的这行代码的最终结果是什么呢？答案是：</p><ul>\n<li>有一个新的<code>a</code>产生，它覆盖了原始的变量<code>a</code>，它的值是<code>{n:2}</code>；</li>\n<li>最左侧的“a.x”的计算结果中的“原始的变量<code>a</code>”在引用传递的过程中丢失了，且“a.x”被同时丢弃。</li>\n</ul><p>所以，第二次赋值操作“a.x = …”实际是无意义的。因为它所操作的对象，也就是“原始的变量<code>a</code>”被废弃了。但是，如果有其它的东西，如变量、属性或者闭包等，持有了这个“原始的变量<code>a</code>”，那么上面的代码的影响仍然是可见的。</p><blockquote>\n<p>事实上，由于JavaScript中支持属性读写器，因此向“a.x”置值的行为总是可能存在“某种执行效果”，而与“a”对象是否被覆盖或丢弃无关。</p>\n</blockquote><p>例如：</p><pre><code>var a = {n:1}, ref = a;\na.x = a = {n:2};\nconsole.log(a.x); // --&gt; undefined\nconsole.log(ref.x); // {n:2}\n</code></pre><p>这也解释了最初“蔡mc”的疑问：连续两次赋值<code>elemData.events</code>有什么用？</p><p>如果<code>a</code>（或<code>elemData</code>）总是被重写的旧的变量，那么如下代码：</p><pre><code>a.x = a = {n:2}\n</code></pre><p>意味着给<strong>旧的变量</strong>添加一个<strong>指向新变量的属性</strong>。因此，一个链表是可以像下面这样来创建的：</p><pre><code>var i = 10, root = {index: &quot;NONE&quot;}, node = root;\n\n// 创建链表\nwhile (i &gt; 0) {\n  node.next = node = new Object;\n  node.index = i--;  // 这里可以开始给新node添加成员\n}\n\n// 测试\nnode = root;\nwhile (node = node.next) {\n  console.log(node.index);\n}\n</code></pre><p>最后，我做这道面试题做一点点细节上的补充：</p><ul>\n<li>这道面试题与运算符优先级无关；</li>\n<li>这里的运算过程与“栈”操作无关；</li>\n<li>这里的“引用”与传统语言中的“指针”没有可比性；</li>\n<li>这里没有变量泄漏；</li>\n<li>这行代码与上一讲的例子有本质的不同；</li>\n<li>上一讲的例子“var x = y = 100”严格说来并不是连续赋值。</li>\n</ul><h2>知识回顾</h2><p>前三讲中，我通过对几行特殊代码的分析，希望能帮助你理解“引用（规范类型）”在JavaScript引擎内部的基本运作原理，包括：</p><ul>\n<li>引用在语言中出现的历史；</li>\n<li>引用与值的创建与使用，以及它的销毁（delete）；</li>\n<li>表达式（求值）和引用之间的关系；</li>\n<li>引用如何在表达式连续运算中传递计算过程的信息；</li>\n<li>仔细观察每一个表达式（及其操作数）计算的顺序；</li>\n<li>所有声明，以及声明语句的共性。</li>\n</ul><h2>复习题</h2><p>下面有几道复习题，希望你尝试解答一下：</p><ol>\n<li>试解析<code>with ({x:100}) delete x;</code> 将发生什么。</li>\n<li>试说明<code>(eval)()</code>与<code>(0, eval)()</code>的不同。</li>\n<li>设“a.x === 0”，试说明“(a.x) = 1”为什么可行。</li>\n<li>为什么<code>with (obj={}) x = 100;</code> 不会给obj添加一个属性’x’？</li>\n</ol><p>希望你喜欢我的分享，也欢迎你把文章分享给你的朋友。</p>","neighbors":{"left":{"article_title":"02 | var x = y = 100：声明语句与语法改变了JavaScript语言核心性质","id":165198},"right":{"article_title":"04 | export default function() {}：你无法导出一个匿名函数表达式","id":166491}},"comments":[{"had_liked":false,"id":151812,"user_name":"blacknhole","can_delete":false,"product_type":"c1","uid":1098286,"ip_address":"","ucode":"271682FFE28F25","user_header":"https://static001.geekbang.org/account/avatar/00/10/c2/2e/c4a527d9.jpg","comment_is_top":false,"comment_ctime":1573795909,"is_pvip":false,"replies":[{"id":"58408","content":"赞的！就是这个意思。呵呵~","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573797840,"ip_address":"","comment_id":151812,"utype":1}],"discussion_count":16,"race_medal":0,"score":"418185623621","product_id":100039701,"comment_content":"从内容上其实已经说清楚了，不过在内容表达上还是会让人产生困惑，我觉得问题是出在“当前上下文中的那个变量a”和“原始的变量a”这样的表述方式上。或许如下表述在语意上会更加清晰：<br><br>1，这里其实只有一个变量，就是a，不存在那个变量a和这个变量a之分，有分别的其实是变量a的值，即“变量a过去的值”和“变量a现在的值”。<br><br>2，当发生第一次赋值时，“左操作数a作为一个引用被覆盖”，此时变量a产生了新的值。<br><br>3，第二次赋值时，“整个语句行的最左侧‘空悬’了一个已经求值过的‘a.x’”，这是一个表达式结果，这个结果以及其中保留的“a”（即“变量a过去的值”）与变量a已经没有关系了，因为变量a已经有了新的值，即“变量a现在的值”。<br><br>4，第二次赋值其实是，在“变量a过去的值”那个对象上，创建一个新属性x，x的值为变量a的值，即“变量a现在的值”。<br><br>5，在第二次赋值后，因为“变量a过去的值”那个对象已经不再被任何变量持有，所以它已经无法被访问到了，它“跑丢了”。<br><br>是这样吧？","like_count":98,"discussions":[{"author":{"id":1743160,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/99/38/79a962d4.jpg","nickname":"龙卷风","note":"","ucode":"0D16C7612BA6CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53236,"discussion_content":"实不相瞒，鄙人通篇下来听得迷迷糊糊。看你的评论瞬间就明白了","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1574148630,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2030114,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKLaNiaLEqyGw3qE1WIcYUxiafNjmR1AzNmZKyK5RHr49r8Ry4Y0bjfwkY9krLKQmGiaIQ2MRqDwA85Q/132","nickname":"听话的小孩77","note":"","ucode":"06DB21A7A4CDCF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1743160,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/99/38/79a962d4.jpg","nickname":"龙卷风","note":"","ucode":"0D16C7612BA6CF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580352,"discussion_content":"+10086","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658125451,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53236,"ip_address":""},"score":580352,"extra":""}]},{"author":{"id":1439990,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f8/f6/3e2db176.jpg","nickname":"七月有风","note":"","ucode":"B3F82397347C5B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":180021,"discussion_content":"var c = {n:1}\nvar a = c;\na.x = a = {n:2};\n将跑丢的值先存一下，就能直观的理解左侧a.x是一个结果","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1582272176,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1346502,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLTYpERVj4wtwAwqz4SUiaoQXDIyhYaKjABMvkJbVXaI3kcJterXovCTqZZSQ1TnueIWX7VGvC3koA/132","nickname":"麦田里的守望者","note":"","ucode":"E2D35F3A628C06","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72622,"discussion_content":"老师的表达能力没有你强啊！👍👍👍","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1575509464,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474623,"discussion_content":"赞的！就是这个意思。呵呵~","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573797840,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1750628,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJUaOs097vUd4wh5GCqnPkHM6oR2TMIOI0xQEooL2EH6DpzdjsQbyRhsJuD0AyG3QkFcWq5icZlgmA/132","nickname":"rl58xz","note":"","ucode":"3409114D447098","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337712,"discussion_content":"还有一个关键点，就是表达式的计算是从左向右的，因此a.x是先计算的，所以此时的a.x就是过去的a。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1609054024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1862956,"avatar":"","nickname":"覃玲芸","note":"","ucode":"B506A8CF48F79A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294556,"discussion_content":"赞！老师的解释没看懂，看你的解释秒懂！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595927262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1096511,"avatar":"https://static001.geekbang.org/account/avatar/00/10/bb/3f/87bc2d81.jpg","nickname":"葉","note":"","ucode":"33289B5569E626","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214684,"discussion_content":"我看到你评论，豁然开朗……感恩","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585226119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1267661,"avatar":"https://static001.geekbang.org/account/avatar/00/13/57/cd/9235341a.jpg","nickname":"庄风","note":"","ucode":"21FC66BA9E7EBB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52628,"discussion_content":"刚才已经蒙了，这么一解释，我好像懂了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574073864,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1367464,"avatar":"https://static001.geekbang.org/account/avatar/00/14/dd/a8/a2c910b6.jpg","nickname":"katalya","note":"","ucode":"CCD1FE6C4F8C1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589577,"discussion_content":"6","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665136915,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1347425,"avatar":"https://static001.geekbang.org/account/avatar/00/14/8f/61/8c28ae2b.jpg","nickname":"D","note":"","ucode":"10A0F1F79156B7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575647,"discussion_content":"大赞，读完文章已经懵逼的我，看你的评论懂了😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655000108,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1361002,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c4/6a/e45bbb6b.jpg","nickname":"Smile","note":"","ucode":"674C2361FFB807","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553924,"discussion_content":"👍🏻👍🏻👍🏻醍醐灌顶","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646133550,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2818551,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/01/f7/75eb754f.jpg","nickname":"即将暴富的木杉","note":"","ucode":"EC23AB5FFCD5F7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553828,"discussion_content":"很赞，个人觉得这个跟垃圾回收关系很大\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646113530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2389114,"avatar":"https://static001.geekbang.org/account/avatar/00/24/74/7a/17373040.jpg","nickname":"阿松","note":"","ucode":"3DA3F0E52CD75E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531115,"discussion_content":"厉害，懂了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637234454,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1293057,"avatar":"https://static001.geekbang.org/account/avatar/00/13/bb/01/568ac2d6.jpg","nickname":"K4SHIFZ","note":"","ucode":"BFB49AAC0E4C74","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":118860,"discussion_content":"看你的我才明白了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578195463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1099314,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c6/32/31b216f4.jpg","nickname":"Jacob 周","note":"","ucode":"EEC7D081F7695F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60518,"discussion_content":"班长威武","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574735532,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152177,"user_name":"青史成灰","can_delete":false,"product_type":"c1","uid":1514406,"ip_address":"","ucode":"C28AB62034B833","user_header":"https://static001.geekbang.org/account/avatar/00/17/1b/a6/6373416f.jpg","comment_is_top":false,"comment_ctime":1573900079,"is_pvip":false,"replies":[{"id":"58498","content":"这个顺序是这样来读的（你仔细看看顺序是不是从左至右）：<br><br><br>第一次<br>======<br>a.x = a = {n:2}<br>^1     ^2<br><br>第二次<br>======<br>a = { n:   2 }<br>^3  ^4<br><br>第三次<br>======<br>{ n:   2 }<br>^5   ^6<br><br>第四次（以下求值然后回传）<br>======<br>求值传回(4)<br>@4 &lt;= ^5, ^6<br><br>第五次<br>======<br>求值回传(3)<br>@3 = (^4 &lt;= ^5, ^6)<br><br>第六次<br>======<br>求值回传（2）<br>a = @3 = (^4 &lt;= ^5, ^6)<br><br>第七次<br>======<br>求值回传（1）<br>a.x = a = @3 = ...","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573904164,"ip_address":"","comment_id":152177,"utype":1}],"discussion_count":4,"race_medal":0,"score":"53113507631","product_id":100039701,"comment_content":"老师上面引用《JavaScript权威指南》中说“JavaScript总是严格按照从左到右的顺序计算表达式”，那为什么下文的2次赋值操作`a.x = a = {n:2}`，是先赋值`a={n:2}`，然后才是`a.x = a`呢","like_count":13,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474739,"discussion_content":"这个顺序是这样来读的（你仔细看看顺序是不是从左至右）：\n\n\n第一次\n======\na.x = a = {n:2}\n^1     ^2\n\n第二次\n======\na = { n:   2 }\n^3  ^4\n\n第三次\n======\n{ n:   2 }\n^5   ^6\n\n第四次（以下求值然后回传）\n======\n求值传回(4)\n@4 &amp;lt;= ^5, ^6\n\n第五次\n======\n求值回传(3)\n@3 = (^4 &amp;lt;= ^5, ^6)\n\n第六次\n======\n求值回传（2）\na = @3 = (^4 &amp;lt;= ^5, ^6)\n\n第七次\n======\n求值回传（1）\na.x = a = @3 = ...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573904164,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1489754,"avatar":"https://static001.geekbang.org/account/avatar/00/16/bb/5a/5b37caff.jpg","nickname":"饼","note":"","ucode":"E67C1675B05ECC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":551868,"discussion_content":"也就是实际上是给拆分成了 a.x = (a = {n:2};) 这样两部分吧\n\n任何表达式都只存在一个 = 号，= 号左右应该看成 一个值\n所以这种复合的表达式应该拆成等号左右，分别按照从左到右计算出结果后再运算","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645158402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":474739,"ip_address":""},"score":551868,"extra":""}]},{"author":{"id":1564429,"avatar":"https://static001.geekbang.org/account/avatar/00/17/df/0d/a87f1e78.jpg","nickname":"谁","note":"","ucode":"183B73A8A2F389","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55410,"discussion_content":"可以理解为JS优先级与赋值问题 \n点操作符的优先级大于的赋值操作 \n所以a.x先执行 此时a的引用对象增加了一个x属性  \n之后执行赋值操作(右向左) \na指向了一个新的地址 a.x也指向了这个新地址 这个a是刚才的信用","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574363409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1393522,"avatar":"https://static001.geekbang.org/account/avatar/00/15/43/72/fbe7aed3.jpg","nickname":"..·","note":"","ucode":"6D266D45493357","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":323627,"discussion_content":"没明白^1是啥意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604976914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152636,"user_name":"天方夜","can_delete":false,"product_type":"c1","uid":1034749,"ip_address":"","ucode":"5D17D55B0CE10C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c9/fd/5ac43929.jpg","comment_is_top":false,"comment_ctime":1574054542,"is_pvip":false,"replies":[{"id":"58672","content":"第2个不太完整。不过总体满分😃<br>第二个涉及的问题到20讲才开讲呢^_^","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574073246,"ip_address":"","comment_id":152636,"utype":1}],"discussion_count":2,"race_medal":0,"score":"48818694798","product_id":100039701,"comment_content":"1. with ({x:100}) delete x 中 delete 删除的是对象的成员，即 property x；<br>2. (0, eval) 之中有一步逗号运算；<br>3. 表达式 (a.x) 的计算结果是 a 对象的属性 x 这个引用，所以可行；<br>4. with 只指定属性查找的优先级，所以 with 里面 x = 100 还是会泄漏到全局。","like_count":11,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474881,"discussion_content":"第2个不太完整。不过总体满分😃\n第二个涉及的问题到20讲才开讲呢^_^","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574073246,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1361489,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c6/51/44791c01.jpg","nickname":"🇧🇪 Hazard🇦🇷","note":"","ucode":"E2C44FAFDFAA88","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":237980,"discussion_content":"第三题啥意思，大佬可以从 a.x === 0 开始解释吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587202406,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":226513,"user_name":"新哥","can_delete":false,"product_type":"c1","uid":1005317,"ip_address":"","ucode":"69CAF2FD490660","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/05/6e0193b5.jpg","comment_is_top":false,"comment_ctime":1592126819,"is_pvip":false,"replies":[{"id":"83666","content":"是的。谢谢~ ^^.","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1592296975,"ip_address":"","comment_id":226513,"utype":1}],"discussion_count":1,"race_medal":0,"score":"44541799779","product_id":100039701,"comment_content":"画个图最好说明问题了，a和ref 指向同一块内存地址，保存的数据是{n:1};<br>执行第二行的时候，a下移指向新的内存地址，保存的数据是{n:2};<br>且第一块内存空间 添加新的属性x,因为ref.x被赋值a,所以ref.x指向新的刚添加的那个地址，数据为{n:2};<br>这样ref指向原始的内存地址，a指向新的内存地址；","like_count":11,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498270,"discussion_content":"是的。谢谢~ ^^.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592296975,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151689,"user_name":"weineel","can_delete":false,"product_type":"c1","uid":1049741,"ip_address":"","ucode":"6DC6EF4F256A53","user_header":"https://static001.geekbang.org/account/avatar/00/10/04/8d/005c2ff3.jpg","comment_is_top":false,"comment_ctime":1573779531,"is_pvip":true,"replies":[{"id":"58332","content":"其实我早期也是这么理解的。好象大家理解事物的方式都差不多，就是从相似性出发，从差异性辨别。<br><br>但是我后来发现，与其如此，不如为新东西建个体系，然后在新体系中来看待这个新事物。这一下子就不同了。<br><br>以至于我现在对引用的认识，就不太依赖与比较或比拟。引用就是引用，它就是一个计算的结果，它存放结果中包括的那几个东西。它是一个数据结构，用在引擎层面来存储计算过程的中间信息，以及在连续计算中传递这些信息。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573784207,"ip_address":"","comment_id":151689,"utype":1}],"discussion_count":3,"race_medal":2,"score":"40228485195","product_id":100039701,"comment_content":"老是您好：我理解的指针和引用是，指针是存储的地址，引用是存储的别名。<br><br>在 js 中的“引用”与传统语言中的“指针”有哪些根本性的区别。","like_count":9,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474575,"discussion_content":"其实我早期也是这么理解的。好象大家理解事物的方式都差不多，就是从相似性出发，从差异性辨别。\n\n但是我后来发现，与其如此，不如为新东西建个体系，然后在新体系中来看待这个新事物。这一下子就不同了。\n\n以至于我现在对引用的认识，就不太依赖与比较或比拟。引用就是引用，它就是一个计算的结果，它存放结果中包括的那几个东西。它是一个数据结构，用在引擎层面来存储计算过程的中间信息，以及在连续计算中传递这些信息。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573784207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1741276,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/91/dc/eca877c4.jpg","nickname":"Chor","note":"","ucode":"6692BF7A104A26","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":180093,"discussion_content":"老师，请问这里的这个“引用”也是es规范层面上所说的“引用”吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582276454,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1049741,"avatar":"https://static001.geekbang.org/account/avatar/00/10/04/8d/005c2ff3.jpg","nickname":"weineel","note":"","ucode":"6DC6EF4F256A53","race_medal":2,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51268,"discussion_content":"感谢老师的回复，很受启发。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573829660,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206907,"user_name":"🇧🇪 Hazard🇦🇷","can_delete":false,"product_type":"c1","uid":1361489,"ip_address":"","ucode":"E2C44FAFDFAA88","user_header":"https://static001.geekbang.org/account/avatar/00/14/c6/51/44791c01.jpg","comment_is_top":false,"comment_ctime":1586955657,"is_pvip":false,"replies":[{"id":"77383","content":"在去年的D2上，我专门讲过一讲《JS 语言在引擎级别的执行过程》，对你提到的问题大都有涉及。并且，有丰富的图示讲解。所以我建议你先听听视频，或者你的许多问题就有解了。<br><br>在这里：<br>https:&#47;&#47;v.youku.com&#47;v_show&#47;id_XNDUwNTc3MjUzMg==.html<br><br>PPT在这里找：<br>https:&#47;&#47;github.com&#47;d2forum&#47;14th&#47;tree&#47;master&#47;PPT<br><br>还有文字版，在“2020前端工程师必读手册”里面有收录。你搜搜~","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1587015281,"ip_address":"","comment_id":206907,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35946694025","product_id":100039701,"comment_content":"老师你好，我有一些关于词法环境规范的疑问，可能跟这一讲的内容有点出入，希望能得到您的解答。<br>1. 环境记录规范有 5 种，但是我没有找到什么资料去告诉我，什么声明会把标识符binding到具体哪个EnvironmentRecord中；还有就是全局变量会放在哪里？<br><br>2. ECMAScript中关于环境记录与标识符喜欢用 binding 这个词，我不知道是什么意思？这个变量是存储在环境记录规范中的吗？还是存储在别的地方？在执行上下文的结构中有一个叫 Realms 的东西，不知道是不是跟这个有关。<br><br>3. EnvironmentRecord的内部结构其实是怎样的？感觉听到了很多术语，但还是感觉很抽象。<br><br>我现在看到了第9讲，发现越来越有点看不懂，于是从头开始学，希望能得到老师的解答，如果解答起来比较复杂，能否提供一些其他资料链接。 谢谢！","like_count":8,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491945,"discussion_content":"在去年的D2上，我专门讲过一讲《JS 语言在引擎级别的执行过程》，对你提到的问题大都有涉及。并且，有丰富的图示讲解。所以我建议你先听听视频，或者你的许多问题就有解了。\n\n在这里：\nhttps://v.youku.com/v_show/id_XNDUwNTc3MjUzMg==.html\n\nPPT在这里找：\nhttps://github.com/d2forum/14th/tree/master/PPT\n\n还有文字版，在“2020前端工程师必读手册”里面有收录。你搜搜~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587015281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181778,"user_name":"红白十万一只","can_delete":false,"product_type":"c1","uid":1659901,"ip_address":"","ucode":"7170636C924D93","user_header":"https://static001.geekbang.org/account/avatar/00/19/53/fd/db2cac71.jpg","comment_is_top":false,"comment_ctime":1582632658,"is_pvip":false,"replies":[{"id":"70407","content":"这种解释是对的。并且跟这一讲的解释是同义的。只是由于两个解释的侧重点不同，所以貌似有不同而已。<br><br>这个解释中也引入了一个#001来说明，这个在本讲中被称为“原始的a”，又或者说是“原始的a的一个引用”。其实都是相同的意思，你按照这种关联来对照着看，就明白了。但是本讲侧重于说明表达式和引用，所以是更强调基于“引用（规范类型）”的解释过程。<br><br>我刻意没有讨论优先级的问题。在课后的留言评论中提到过按优先级来演算的过程，但也不如你这里的细致。优先级是运算规则的很重要的组成部分，在设计表达式语法时也很重要，但是我们的课程并不特别关注这个部分，所以我是有意不从这个角度入手来讲的。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1582637472,"ip_address":"","comment_id":181778,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31647403730","product_id":100039701,"comment_content":"老师这题我看过别的文章，不过是与运算符优先级解释。<br>按照运算符优先级的思路：<br>var a={n1}<br>a.x=a={n:1}<br>=的关联性是从右到左，优先级是3，赋值运算符的返回结果是右边的值<br>.(成员访问)的关联性是从右到左，优先级是19<br>a.x的赋值等于a={n:1}，而a的赋值等于{n:1}。<br>按照顺序会先计算a={n:1}的值，但是a.x是成员访问优先级是19。<br>所以会先进行a.x的解析，解析结果就是变量a对象的引用(引用地址#001)并创建了a.x这个属性，引用被暂存。<br>这是表达式就是：#001.x=a={n:1}<br>a={n:1}时修改了变量a(例#001)的引用地址为{n:1}(例#002)。<br>表达式就是#001.x={n:1}(例#002)<br>也就是#001这个引用地址中x的值被修改为了{n:1}<br>#001这个引用地址的值也就是<br>{<br>n:1,<br>x:{n:1}<br>}<br>但是这个引用已经没有任何变量、属性持有了<br>而变量a的值就是<br>{n:1}<br>关于这种解释有没有什么问题，麻烦老师解释一下。","like_count":8,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485117,"discussion_content":"这种解释是对的。并且跟这一讲的解释是同义的。只是由于两个解释的侧重点不同，所以貌似有不同而已。\n\n这个解释中也引入了一个#001来说明，这个在本讲中被称为“原始的a”，又或者说是“原始的a的一个引用”。其实都是相同的意思，你按照这种关联来对照着看，就明白了。但是本讲侧重于说明表达式和引用，所以是更强调基于“引用（规范类型）”的解释过程。\n\n我刻意没有讨论优先级的问题。在课后的留言评论中提到过按优先级来演算的过程，但也不如你这里的细致。优先级是运算规则的很重要的组成部分，在设计表达式语法时也很重要，但是我们的课程并不特别关注这个部分，所以我是有意不从这个角度入手来讲的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582637472,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154947,"user_name":"授人以摸鱼","can_delete":false,"product_type":"c1","uid":1390561,"ip_address":"","ucode":"69417D324C1473","user_header":"https://static001.geekbang.org/account/avatar/00/15/37/e1/0953c506.jpg","comment_is_top":false,"comment_ctime":1574603037,"is_pvip":false,"replies":[{"id":"59539","content":"是的。都对！赞！","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574661306,"ip_address":"","comment_id":154947,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31639374109","product_id":100039701,"comment_content":"所以我现在这么理解js中的“值”和“引用”这两个概念了：<br>“引用”保存了两个信息：对象的地址，和要查询的属性名(字符串或symbol)<br>“值”只保存了一个信息：原始值本身，或一个地址<br>从引用中获取值这个操作是惰性的，只有真正要使用值的时候才会执行getvalue","like_count":8,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475620,"discussion_content":"是的。都对！赞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574661306,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152802,"user_name":"蓝配鸡","can_delete":false,"product_type":"c1","uid":1348738,"ip_address":"","ucode":"C79A7CA8885B7C","user_header":"https://static001.geekbang.org/account/avatar/00/14/94/82/d0a417ba.jpg","comment_is_top":false,"comment_ctime":1574082295,"is_pvip":false,"replies":[{"id":"58761","content":"Result是引用。<br>value是undefined。<br><br>value = GetValue(Result)","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574131514,"ip_address":"","comment_id":152802,"utype":1}],"discussion_count":3,"race_medal":0,"score":"31638853367","product_id":100039701,"comment_content":"不明白为什么a.x 这个表达式的result是一个a的引用呢？<br><br>不应该是 undefined吗？<br><br>没明白...","like_count":8,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474944,"discussion_content":"Result是引用。\nvalue是undefined。\n\nvalue = GetValue(Result)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574131514,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1003716,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/50/c4/c311b591.jpg","nickname":"Amundsen","note":"","ucode":"10F828DD46E762","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":208136,"discussion_content":"我是这么理解的：在这里a.x并没有求值，它是一个lhs，所以这里是引用。如果求值，那么是undefined。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584536710,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1394159,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/pTZS48zWWAhI0zGXrib8s124HSenCS2FTDD0r4SKCqw2ub4adicI4x2wTeH7bHdlsl8QwxeVmzTGs1PIImURxxPg/132","nickname":"itgou","note":"","ucode":"4F6FFA0DD1ACBA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53156,"discussion_content":"作者回复: Result是引用。\nvalue是undefined。\n\nvalue = GetValue(Result)\n\n因为是在等号左边所以取引用，如果在等号右边就取value","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574140434,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151971,"user_name":"Lambert","can_delete":false,"product_type":"c1","uid":1383138,"ip_address":"","ucode":"06DC409CC9C235","user_header":"https://static001.geekbang.org/account/avatar/00/15/1a/e2/0a5ff5b7.jpg","comment_is_top":false,"comment_ctime":1573824753,"is_pvip":false,"replies":[{"id":"58431","content":"这个时候的Result是一个“引用（Reference）”。<br><br>如果它在后续运算中被作为lhs，例如 a.x = ...，那么它就是作为“引用”来使用，这样就可以访问到`x`这个属性，并置值；如果它在后续运算中被作为rhs，例如console.log(a.x)，那么它就会被GetValue()取值（并作为值来使用），于是console.log()就能打印出它的值来。<br><br>a.x整体被作为“一个操作数”，它的用法与它被使用的位置是有关的。但是“得到它（亦即是对a.x这个表达式求Result）”的过程并没有什么不同。<br><br>你可以读一下这个“.”操作在ECMAScript中的规范：<br>https:&#47;&#47;tc39.es&#47;ecma262&#47;#sec-property-accessors-runtime-semantics-evaluation","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573835256,"ip_address":"","comment_id":151971,"utype":1}],"discussion_count":3,"race_medal":0,"score":"31638595825","product_id":100039701,"comment_content":"“a.x”这个表达式的语义是：<br>计算单值表达式a，得到a的引用；<br>将右侧的名字x理解为一个标识符，并作为“.”运算的右操作数；<br>计算“a.x”表达式的结果（Result）。<br>老师请问一下  这个时候 的 Result  是 undefined吗？ 因为还没有进行赋值","like_count":7,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474674,"discussion_content":"这个时候的Result是一个“引用（Reference）”。\n\n如果它在后续运算中被作为lhs，例如 a.x = ...，那么它就是作为“引用”来使用，这样就可以访问到`x`这个属性，并置值；如果它在后续运算中被作为rhs，例如console.log(a.x)，那么它就会被GetValue()取值（并作为值来使用），于是console.log()就能打印出它的值来。\n\na.x整体被作为“一个操作数”，它的用法与它被使用的位置是有关的。但是“得到它（亦即是对a.x这个表达式求Result）”的过程并没有什么不同。\n\n你可以读一下这个“.”操作在ECMAScript中的规范：\nhttps://tc39.es/ecma262/#sec-property-accessors-runtime-semantics-evaluation","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573835256,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1383138,"avatar":"https://static001.geekbang.org/account/avatar/00/15/1a/e2/0a5ff5b7.jpg","nickname":"Lambert","note":"","ucode":"06DC409CC9C235","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51449,"discussion_content":"谢谢，看来得把ECMAScript规范看一遍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573875183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1251429,"avatar":"https://static001.geekbang.org/account/avatar/00/13/18/65/35361f02.jpg","nickname":"潇潇雨歇","note":"","ucode":"4BD52BF0F0A084","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51288,"discussion_content":"就是undefined","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573831211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215081,"user_name":"HoSalt","can_delete":false,"product_type":"c1","uid":1156074,"ip_address":"","ucode":"610B03E2A002D1","user_header":"https://static001.geekbang.org/account/avatar/00/11/a3/ea/53333dd5.jpg","comment_is_top":false,"comment_ctime":1588901413,"is_pvip":false,"replies":[{"id":"79736","content":"一对括号，亦即是所谓分组表达式`()`，这个东西是在JS中极其罕见的在执行中“返回结果(result)”的表达式。因为通常的表达式是“返回值(value)”的，这甚至包括返回所谓ECMAScript规范引用，这也是作为value来返回的。——另一个如此有趣的东西是表达式作为函数体的箭头函数。<br><br>在分组表达式中，“返回结果(result)”而不是“返回值(value)”其实是有着非常大的、非常有魔力的不同的。例如说：<br><br>&gt; (test.fn)<br><br>在这个表达式里面，`test.fn`的Result是一个ECMAScript规范中的引用，因此这个引用就被返回了，因此`(test.fn)()`这个函数调用中，fn()就能得到this。也因此（eval)与直接的eval没有区别，都是eval引用。<br><br>但是你注意看，<br><br>&gt; (test.fn)<br><br>分组表达式操作的“里面的表达式`test.fn`”是一个属性存取表达式，它返回“ECMAScript规范的引用”。而下面：<br><br>&gt; (0, test.fn)<br><br>代码中在“里面的表达式`0, test.fn`”是什么呢？是用`,`号分隔开的所谓的“连续运算表达式”，而这个连续运算表达式的第二个子表达式，才是`test.fn`，对吧？<br><br>连续运算表达式返回什么呢？很不幸，连续运算表达式返回“最后一个子表达式的值（value）”——我们前面说过，所有表达式中目前只有两个是直接返回Result的。其它的情况下，其实都会返回value，包括以value定义的规范类型，或者GetValue(result）。<br><br>所以说，事实上<br><br>&gt; (0, test.fn)<br><br>表达式的返回的是连续运算的最后一个表达式的value，也就是test.fn的getValue(result)，也就是fn这个函数。因此，再调用<br><br>&gt; (0, test.fn)()<br><br>的时候，就丢失掉了test这个对象引用了。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1588997368,"ip_address":"","comment_id":215081,"utype":1}],"discussion_count":4,"race_medal":0,"score":"27358705189","product_id":100039701,"comment_content":"老师 (test.fn)()和test.fn()的调用this都只想test，为什么前面的括号里面的内容没有返回值而是返回了引用","like_count":6,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494305,"discussion_content":"一对括号，亦即是所谓分组表达式`()`，这个东西是在JS中极其罕见的在执行中“返回结果(result)”的表达式。因为通常的表达式是“返回值(value)”的，这甚至包括返回所谓ECMAScript规范引用，这也是作为value来返回的。——另一个如此有趣的东西是表达式作为函数体的箭头函数。\n\n在分组表达式中，“返回结果(result)”而不是“返回值(value)”其实是有着非常大的、非常有魔力的不同的。例如说：\n\n&amp;gt; (test.fn)\n\n在这个表达式里面，`test.fn`的Result是一个ECMAScript规范中的引用，因此这个引用就被返回了，因此`(test.fn)()`这个函数调用中，fn()就能得到this。也因此（eval)与直接的eval没有区别，都是eval引用。\n\n但是你注意看，\n\n&amp;gt; (test.fn)\n\n分组表达式操作的“里面的表达式`test.fn`”是一个属性存取表达式，它返回“ECMAScript规范的引用”。而下面：\n\n&amp;gt; (0, test.fn)\n\n代码中在“里面的表达式`0, test.fn`”是什么呢？是用`,`号分隔开的所谓的“连续运算表达式”，而这个连续运算表达式的第二个子表达式，才是`test.fn`，对吧？\n\n连续运算表达式返回什么呢？很不幸，连续运算表达式返回“最后一个子表达式的值（value）”——我们前面说过，所有表达式中目前只有两个是直接返回Result的。其它的情况下，其实都会返回value，包括以value定义的规范类型，或者GetValue(result）。\n\n所以说，事实上\n\n&amp;gt; (0, test.fn)\n\n表达式的返回的是连续运算的最后一个表达式的value，也就是test.fn的getValue(result)，也就是fn这个函数。因此，再调用\n\n&amp;gt; (0, test.fn)()\n\n的时候，就丢失掉了test这个对象引用了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588997368,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1445936,"avatar":"https://static001.geekbang.org/account/avatar/00/16/10/30/c07d419c.jpg","nickname":"卡尔","note":"","ucode":"BD6F76BC18FF8F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281861,"discussion_content":"没看明白","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591835737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1445936,"avatar":"https://static001.geekbang.org/account/avatar/00/16/10/30/c07d419c.jpg","nickname":"卡尔","note":"","ucode":"BD6F76BC18FF8F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333504,"discussion_content":"重新回来看，明白了！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607531709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1565909,"avatar":"https://static001.geekbang.org/account/avatar/00/17/e4/d5/579615e2.jpg","nickname":"仿生狮子","note":"","ucode":"ECB2726F7E8F2F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331387,"discussion_content":"妙啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606840592,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153280,"user_name":"海绵薇薇","can_delete":false,"product_type":"c1","uid":1601296,"ip_address":"","ucode":"37C7CC2EB81909","user_header":"https://static001.geekbang.org/account/avatar/00/18/6f/10/bfbf81dc.jpg","comment_is_top":false,"comment_ctime":1574210507,"is_pvip":false,"replies":[{"id":"58898","content":"YES! 这回侬对了。^^.","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574219425,"ip_address":"","comment_id":153280,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27344014283","product_id":100039701,"comment_content":"hello 老师好：<br>一开始我不明白为啥要称 var a = 1; 是值绑定操作，看了几遍之后应该理解了，var 是一个申明，等号左边不是表达式。而赋值操作等号左边是一个表达式结果是引用，右边是值，这样完成的赋值操作。但是var 右边等号左边不是一个表达式所以不是赋值，换了名字叫绑定。","like_count":7,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475107,"discussion_content":"YES! 这回侬对了。^^.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574219425,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170785,"user_name":"GitHubGanKai","can_delete":false,"product_type":"c1","uid":1477351,"ip_address":"","ucode":"BF6D6F8F3EED31","user_header":"https://static001.geekbang.org/account/avatar/00/16/8a/e7/a6c603cf.jpg","comment_is_top":false,"comment_ctime":1578716047,"is_pvip":false,"replies":[{"id":"66262","content":"我之前并没有听过关于这个 ‘未经计算的操作数’的说法。因此我特地地看了一下MDN中的相关说明。<br><br> ‘未经计算的操作数(unevaluated operand)’这个，其实也并没有特别的难解。例如有一个值是2的常量x，对于这个`x`，如果它“计算了”，那结果当然就是2，对吧。那么这种情况下，“未经计算时的x”是什么呢？<br><br>这个其实还是我们在文章中说的“引用（规范类型）”。“引用（规范类型）”作为左手端时，只是引用，并不求值，这种情况下它就是`unevaluated operand`。所以，一个错误的、根本不存在的引用也可以被typeof操作，因为这个“错误的、根本不存在的”并没有被“计算”，所以也就不会抛出错误。例如你试试：<br>```<br>typeof adfasdljkfla;  &#47;&#47; &lt;- 随便一个变量名<br>```<br>之所以没有异常发生，就是后面的`adfasdljkfla`这个东东“未经计算”。同样的，如果我们尝试下面的代码：<br>```<br>typeof(adfasdljkfla);  &#47;&#47; 同上例<br>```<br>这里其实多了一个操作符，就是一对括号表示的“分组运算符（grouping）”，这个运算符也是“返回未经运算的结果”。所以同样，不会出错。——在我们这个系列的文章中，这种情况称为“引用（规范类型）”，或者一个“（未决定操作手性rhs&#47;lhs的）结果Result”。<br><br>还有你的另一个问题：<br>&gt; 而且这个typeof的返回值，返回的应该不是一种类型吧！<br>这个是其它类型的语言来理解函数式语言的一个常见误区。尤其是，如果你以传统的（经典的）数据结构的知识为基础，那么更是会有误解。<br><br>在JavaScript中，以及在函数式语言中 ，“函数”的确是一种数据类型。它可以作为值（在函数界面上）传递，也可以作为结果（在函数返回中）传出，还可以查看类型，还可以与其它数据进行运算（例如 1 + (function(){})），那么它为什么不是“一种数据类型”呢？<br><br>函数既是数据，也是运算，这个是函数式语言的核心概念。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1578819936,"ip_address":"","comment_id":170785,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23053552527","product_id":100039701,"comment_content":"老师你好，有个问题想要请教一下你，就是MDN中：typeof 操作符返回一个字符串，表示未经计算的操作数的类型。那么这句话中的 ‘未经计算的操作数’是什么意思呢？这个‘未经计算的操作数’有哪些类型呢？而且这个typeof的返回值，返回的应该不是一种类型吧！因为用typeof检测类型的时候可能返回 &#39;function&#39;，但是function又不属于数据类型，是不是有点矛盾呢？","like_count":5,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481111,"discussion_content":"我之前并没有听过关于这个 ‘未经计算的操作数’的说法。因此我特地地看了一下MDN中的相关说明。\n\n ‘未经计算的操作数(unevaluated operand)’这个，其实也并没有特别的难解。例如有一个值是2的常量x，对于这个`x`，如果它“计算了”，那结果当然就是2，对吧。那么这种情况下，“未经计算时的x”是什么呢？\n\n这个其实还是我们在文章中说的“引用（规范类型）”。“引用（规范类型）”作为左手端时，只是引用，并不求值，这种情况下它就是`unevaluated operand`。所以，一个错误的、根本不存在的引用也可以被typeof操作，因为这个“错误的、根本不存在的”并没有被“计算”，所以也就不会抛出错误。例如你试试：\n```\ntypeof adfasdljkfla;  // &amp;lt;- 随便一个变量名\n```\n之所以没有异常发生，就是后面的`adfasdljkfla`这个东东“未经计算”。同样的，如果我们尝试下面的代码：\n```\ntypeof(adfasdljkfla);  // 同上例\n```\n这里其实多了一个操作符，就是一对括号表示的“分组运算符（grouping）”，这个运算符也是“返回未经运算的结果”。所以同样，不会出错。——在我们这个系列的文章中，这种情况称为“引用（规范类型）”，或者一个“（未决定操作手性rhs/lhs的）结果Result”。\n\n还有你的另一个问题：\n&amp;gt; 而且这个typeof的返回值，返回的应该不是一种类型吧！\n这个是其它类型的语言来理解函数式语言的一个常见误区。尤其是，如果你以传统的（经典的）数据结构的知识为基础，那么更是会有误解。\n\n在JavaScript中，以及在函数式语言中 ，“函数”的确是一种数据类型。它可以作为值（在函数界面上）传递，也可以作为结果（在函数返回中）传出，还可以查看类型，还可以与其它数据进行运算（例如 1 + (function(){})），那么它为什么不是“一种数据类型”呢？\n\n函数既是数据，也是运算，这个是函数式语言的核心概念。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578819936,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151813,"user_name":"Wiggle Wiggle","can_delete":false,"product_type":"c1","uid":1036052,"ip_address":"","ucode":"EFE746551BA998","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cf/14/384258ba.jpg","comment_is_top":false,"comment_ctime":1573795981,"is_pvip":false,"replies":[{"id":"58406","content":"https:&#47;&#47;tc39.es&#47;ecma262&#47;#sec-reference-specification-type<br><br>^^.","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573797582,"ip_address":"","comment_id":151813,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23048632461","product_id":100039701,"comment_content":"那么“引用”这个数据结构究竟是什么样子呢？在引擎内部是如何实现的呢？老师可否讲一下或者给个链接？","like_count":5,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474624,"discussion_content":"https://tc39.es/ecma262/#sec-reference-specification-type\n\n^^.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573797582,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239835,"user_name":"Geek_8d73e3","can_delete":false,"product_type":"c1","uid":1961902,"ip_address":"","ucode":"FF89629117B96C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epneC3LXv0Ve2tCXPfvsXtRb5StVicNCEHUSfzneLYUDJ03B6ocINHzeLf94aw0dEkjLShSdK9NUoA/132","comment_is_top":false,"comment_ctime":1596674968,"is_pvip":false,"replies":[{"id":"88582","content":"let x;<br>这是声明没错，但它有“执行期语义（Runtime Semantics）”。对于LetOrConst来说，这个执行期语义就是“绑定初始值”。<br><br>简单地说，就是“执行到这一行就初始化了”。<br><br>参见这里：<br>https:&#47;&#47;tc39.es&#47;ecma262&#47;#sec-let-and-const-declarations-runtime-semantics-evaluation","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1596684515,"ip_address":"","comment_id":239835,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14481576856","product_id":100039701,"comment_content":"老师，那我还有一个疑惑<br>既然let x 为词法声明，词法声明不会初始化绑定一个undefined，而且js引擎拒绝访问未初始化的词法声明<br>那如何解释以下代码<br>let x;<br>console.log(x)   &#47;&#47;这里输出undefined","like_count":3,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503243,"discussion_content":"let x;\n这是声明没错，但它有“执行期语义（Runtime Semantics）”。对于LetOrConst来说，这个执行期语义就是“绑定初始值”。\n\n简单地说，就是“执行到这一行就初始化了”。\n\n参见这里：\nhttps://tc39.es/ecma262/#sec-let-and-const-declarations-runtime-semantics-evaluation","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596684515,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180456,"user_name":"Chor","can_delete":false,"product_type":"c1","uid":1741276,"ip_address":"","ucode":"6692BF7A104A26","user_header":"https://static001.geekbang.org/account/avatar/00/1a/91/dc/eca877c4.jpg","comment_is_top":false,"comment_ctime":1582284627,"is_pvip":false,"replies":[{"id":"70045","content":"1. 是的。<br><br>2. 是的。“引用（规范类型）”可以看作原始a的容器，包含原始a的信息。<br><br>3. &quot;表达式的Result中是否包含相关的x的信息&quot;，是的，是包含着x的相关信息。<br><br>“引用（规范类型）”是一个结构，通常有三个成员，base、name和strict。所以，无论`x`属性是否存在，`a.x`都被表达为{&quot;base&quot;: a, &quot;name&quot;: &quot;x&quot;, ...}，这个结构就是`a.x`的引用，或者说是Result。直到需要读写它的时候（例如作为rhs），才会去检索a[&quot;x&quot;]是否真实存在，并决定后续操作。<br><br>关于“引用（规范类型）”的一些细节，你可以看看这个：<br>https:&#47;&#47;github.com&#47;d2forum&#47;14th&#47;<br><br>在《JS 语言在引擎级别的执行过程》中专门有一部分是讲述它的。视频在这里：<br><br>https:&#47;&#47;v.youku.com&#47;v_show&#47;id_XNDUwNTc3MjUzMg==.html","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1582287173,"ip_address":"","comment_id":180456,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14467186515","product_id":100039701,"comment_content":"老师您好，我想问一下：<br>1. “这个被赋值的引用“a.x”其实是一个未创建的属性，赋值操作将使得那个“原始的变量a”具有一个新属性” 这句话是不是说，x这个本来不存在的属性仅在第二次赋值操作的时候才会被创建？<br>2. a.x 这个表达式计算的结果（Result）是一个引用，是否可以把这个引用看作一个“容器”，这个“容器”包含着原始的a的信息？还是说这个引用就是原始的a本身？<br>3.一开始程序在分析 a.x 的时候（第二次赋值发生之前），这个表达式的Result中是否包含相关的x的信息？还是说这时候x只是一个暂时不存在、等待创建的东西？","like_count":3,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484670,"discussion_content":"1. 是的。\n\n2. 是的。“引用（规范类型）”可以看作原始a的容器，包含原始a的信息。\n\n3. &amp;quot;表达式的Result中是否包含相关的x的信息&amp;quot;，是的，是包含着x的相关信息。\n\n“引用（规范类型）”是一个结构，通常有三个成员，base、name和strict。所以，无论`x`属性是否存在，`a.x`都被表达为{&amp;quot;base&amp;quot;: a, &amp;quot;name&amp;quot;: &amp;quot;x&amp;quot;, ...}，这个结构就是`a.x`的引用，或者说是Result。直到需要读写它的时候（例如作为rhs），才会去检索a[&amp;quot;x&amp;quot;]是否真实存在，并决定后续操作。\n\n关于“引用（规范类型）”的一些细节，你可以看看这个：\nhttps://github.com/d2forum/14th/\n\n在《JS 语言在引擎级别的执行过程》中专门有一部分是讲述它的。视频在这里：\n\nhttps://v.youku.com/v_show/id_XNDUwNTc3MjUzMg==.html","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582287173,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1741276,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/91/dc/eca877c4.jpg","nickname":"Chor","note":"","ucode":"6692BF7A104A26","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":181236,"discussion_content":"好的，谢谢老师的回复","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582349994,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156838,"user_name":"itgou","can_delete":false,"product_type":"c1","uid":1394159,"ip_address":"","ucode":"4F6FFA0DD1ACBA","user_header":"https://wx.qlogo.cn/mmopen/vi_32/pTZS48zWWAhI0zGXrib8s124HSenCS2FTDD0r4SKCqw2ub4adicI4x2wTeH7bHdlsl8QwxeVmzTGs1PIImURxxPg/132","comment_is_top":false,"comment_ctime":1574987448,"is_pvip":false,"replies":[{"id":"60434","content":"闭包这个概念是与函数相关的（当然对象闭包则与with相关），所以这里不适合用“闭包”这个词。<br>在大括号内的是一个块级作用域，你也可以叫“词法的块级作用域”或者直接叫“作用域”。<br><br>当一个“单向链表”处于系统中时，如果链表首（root）没有被引用的话，你是找不到这个完整的链表的。——很明显，你没有办法反向地检索。所以会有外层的node = root。当然，从引擎的角度上来说，如果是这样的一个链表（没有变量来引用root），那么它的确会被废弃。你从数据结构的角度上思考一下就明白了，没有办法回溯，也没有别的东西来引用任何一个“向前的”结点，只会有最后一个结点被引用（从而不被废弃）。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1575223623,"ip_address":"","comment_id":156838,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14459889336","product_id":100039701,"comment_content":"<br>书读百遍，其义自见，在听读了n遍之后，终于理解了标题中的代码，但是看到链表代码，又有点晕了，亲老师解答一下。问题如下<br>var i = 10, root = {index: &quot;NONE&quot;}, node = root;<br><br><br>while (i &gt; 0) {<br>  node.next = node = new Object; &#47;&#47;本行开头的node.next未被丢弃，是因为这里大括号里面是一个闭包，而外层node=root对这里有引用吗？<br>  node.index = i--; <br>}<br><br>&#47;&#47; 测试<br>node = root;<br>while (node = node.next) {<br>  console.log(node.index);<br>}<br><br>问题写在了while循环当中，请老师回答一下。","like_count":4,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476248,"discussion_content":"闭包这个概念是与函数相关的（当然对象闭包则与with相关），所以这里不适合用“闭包”这个词。\n在大括号内的是一个块级作用域，你也可以叫“词法的块级作用域”或者直接叫“作用域”。\n\n当一个“单向链表”处于系统中时，如果链表首（root）没有被引用的话，你是找不到这个完整的链表的。——很明显，你没有办法反向地检索。所以会有外层的node = root。当然，从引擎的角度上来说，如果是这样的一个链表（没有变量来引用root），那么它的确会被废弃。你从数据结构的角度上思考一下就明白了，没有办法回溯，也没有别的东西来引用任何一个“向前的”结点，只会有最后一个结点被引用（从而不被废弃）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575223623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152044,"user_name":"Ming","can_delete":false,"product_type":"c1","uid":1358174,"ip_address":"","ucode":"A94E8D8433E54F","user_header":"https://static001.geekbang.org/account/avatar/00/14/b9/5e/a8f6f7db.jpg","comment_is_top":false,"comment_ctime":1573862961,"is_pvip":true,"replies":[{"id":"58500","content":"除了“a.x = a”导致栈异常之外，这个好象不太对。其它应该没什么问题了。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573904300,"ip_address":"","comment_id":152044,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14458764849","product_id":100039701,"comment_content":"反反复复看了几遍，留言区里帮我屡清了思路。<br><br>第一句：<br>var a = {n : 1};<br>&#47;&#47; 变量声明，变量a作为引用，最终指向了等号右侧表达式的计算结果，即一个对象{n : 1}<br><br>第二句：<br>a.x = a = {m : 2};<br>&#47;&#47; 两个等号划分了3个表达式（宏观上）；<br>&#47;&#47; a.x... 要为a添加x属性的蠢蠢欲动，缓存a，a = {n : 1};<br>&#47;&#47; a.x = a... 没有做赋值操作！如果代码写到这截止，事实上会报一种错，叫Error: Maximum call stack size exceeded<br>&#47;&#47; a.x = a = {m : 2}; 做了两次赋值操作，首先后半段先做赋值操作，a的引用指向了新的对象{m : 2}，第二次赋值操作完成了为之前缓存的a添加x属性的如愿已久，x的引用指向后面的这个完成了初始化的a。现在，我们去使用a，实际上使用的是后面的这个a，a = {m : 2}，那之前缓存的那个a呢？被引擎吃掉了，无法访问到。那它指向哪个对象呢？{n : 1, x : {m : 2}}，理由是一次初始化和一次属性拓展。","like_count":3,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474699,"discussion_content":"除了“a.x = a”导致栈异常之外，这个好象不太对。其它应该没什么问题了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573904300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151758,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1573786199,"is_pvip":false,"replies":[{"id":"58405","content":"好主意！我问问编辑能怎么改。<br>后面的内容我尽量都加上。多谢提议！","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573794036,"ip_address":"","comment_id":151758,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14458688087","product_id":100039701,"comment_content":"文章读起来挺吃力的，可能是 JS 很多设计跟固有思维不一致，也可能是对 EMACScript 规范不了解，老师能否考虑下放文章中涉及到的规范地址？","like_count":3,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474605,"discussion_content":"好主意！我问问编辑能怎么改。\n后面的内容我尽量都加上。多谢提议！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573794036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1251429,"avatar":"https://static001.geekbang.org/account/avatar/00/13/18/65/35361f02.jpg","nickname":"潇潇雨歇","note":"","ucode":"4BD52BF0F0A084","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50983,"discussion_content":"老师可以给点学习资料","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573796544,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225686,"user_name":"卡尔","can_delete":false,"product_type":"c1","uid":1445936,"ip_address":"","ucode":"BD6F76BC18FF8F","user_header":"https://static001.geekbang.org/account/avatar/00/16/10/30/c07d419c.jpg","comment_is_top":false,"comment_ctime":1591834586,"is_pvip":false,"replies":[{"id":"83234","content":"在下面的示例代码中：<br><br>node.next中的`node`，就是这个”总是重写的旧的变量“；而，<br>node.index中的`node`则是”新的变量“。<br><br>所以，”a（或elemData）总是被重写“，意味着在建立链表的过程中它是可以用来”暂存上一个节点（node)“的。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1591905614,"ip_address":"","comment_id":225686,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10181769178","product_id":100039701,"comment_content":"如果a（或elemData）总是被重写的旧的变量，那么如下代码：<br><br>老师，这话是什么意思？","like_count":2,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497945,"discussion_content":"在下面的示例代码中：\n\nnode.next中的`node`，就是这个”总是重写的旧的变量“；而，\nnode.index中的`node`则是”新的变量“。\n\n所以，”a（或elemData）总是被重写“，意味着在建立链表的过程中它是可以用来”暂存上一个节点（node)“的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591905614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215070,"user_name":"HoSalt","can_delete":false,"product_type":"c1","uid":1156074,"ip_address":"","ucode":"610B03E2A002D1","user_header":"https://static001.geekbang.org/account/avatar/00/11/a3/ea/53333dd5.jpg","comment_is_top":false,"comment_ctime":1588900226,"is_pvip":false,"replies":[{"id":"79741","content":"是的。`let x`跟`let x = undefined`是相同的处理过程。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1589001562,"ip_address":"","comment_id":215070,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10178834818","product_id":100039701,"comment_content":"老师，let x 这种申明是不是以为执行到这里会调用初始化器，将x设置为undefined,在其后面就能访问了？","like_count":2,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494301,"discussion_content":"是的。`let x`跟`let x = undefined`是相同的处理过程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589001562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207306,"user_name":"🇧🇪 Hazard🇦🇷","can_delete":false,"product_type":"c1","uid":1361489,"ip_address":"","ucode":"E2C44FAFDFAA88","user_header":"https://static001.geekbang.org/account/avatar/00/14/c6/51/44791c01.jpg","comment_is_top":false,"comment_ctime":1587045162,"is_pvip":false,"replies":[{"id":"77630","content":"globalER是一个组合的ER，由一个OER和一个DER共同组成。注意ER是指环境记录（EnvironmentRecords）。<br><br>任何一个ECMA的执行上下文（ECMAScriptExecuteContext）都同时有两个环境，而系统的执行上下文（ExecuteContext）都没有环境。而这里说到的，叫环境（Environment&#47;Env）。环境包含环境记录。这里的环境称为LexicalEnvironment和VariableEnvironment，简写起来，可以叫ctx.lexEnv和ctx.varEnv。<br><br>变量并不是“存储在”ctx.varEnv中的，只是它可以通过ctx.varEnv来查找到。举一个最简单例子，global的ctx.lexEnv和ctx.varEnv其实指向同一个环境，也就是globalEnv。——它们是相同的，所以不存在“保存在哪儿”的问题，只不过在执行系统中需要处理var的时候，就直接拿ctx.varEnv来查找罢了。<br><br>既然如此，那么为什么还要分两个环境呢？<br><br>因为ctx.varEnv和ctx.lexEnv在某些时候也并不指向同一个环境。明显的例子就是：如果是在非严格模式，那么在eval函数所创建的ctx中，它的ctx.varEnv指向外层函数或全局环境的varEnv。<br><br>所以，在非严格模式中，当eval执行时遇到var和函数名声明时，那么它们就被写到varEnv里面去了。——回到之前的说明里面，如果这个时候ctx.varEnv是指向全局的话，那么在全局中的globalEnv其实在“全局的ctx”中还是那个“同一个”。也就是：<br>&gt; globalCtx.varEnv === globalCtx.lexEnv === globalEnv<br><br>关键在于：所谓varEnv&#47;lexEnv分成两组，只是用于在ctx中“查找”不同的环境，而并不决定环境的“组成结构”是什么样子。——例如，前面也说过，全局环境(globalEnv)由一个OER和一个DER组成。<br><br>最后，“var 声明&#47;函数声明”是保存在ER中的。它将通过环境记录（varEnv&#47;lexEnv）来查找，并保存在找到的环境（Env）的环境记录（ER）中。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1587236804,"ip_address":"","comment_id":207306,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10176979754","product_id":100039701,"comment_content":"老师好，看了您分享的js执行过程的视频，然后又看了一下文档。发现tc39中关于 var、function声明的描述让我没懂，globalER中又说会把声明绑定到 OER 中，但是 DER 中的描述又说是跟六种声明有关。所以比较疑惑 var 声明到底是存储在哪里的？","like_count":2,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492077,"discussion_content":"globalER是一个组合的ER，由一个OER和一个DER共同组成。注意ER是指环境记录（EnvironmentRecords）。\n\n任何一个ECMA的执行上下文（ECMAScriptExecuteContext）都同时有两个环境，而系统的执行上下文（ExecuteContext）都没有环境。而这里说到的，叫环境（Environment/Env）。环境包含环境记录。这里的环境称为LexicalEnvironment和VariableEnvironment，简写起来，可以叫ctx.lexEnv和ctx.varEnv。\n\n变量并不是“存储在”ctx.varEnv中的，只是它可以通过ctx.varEnv来查找到。举一个最简单例子，global的ctx.lexEnv和ctx.varEnv其实指向同一个环境，也就是globalEnv。——它们是相同的，所以不存在“保存在哪儿”的问题，只不过在执行系统中需要处理var的时候，就直接拿ctx.varEnv来查找罢了。\n\n既然如此，那么为什么还要分两个环境呢？\n\n因为ctx.varEnv和ctx.lexEnv在某些时候也并不指向同一个环境。明显的例子就是：如果是在非严格模式，那么在eval函数所创建的ctx中，它的ctx.varEnv指向外层函数或全局环境的varEnv。\n\n所以，在非严格模式中，当eval执行时遇到var和函数名声明时，那么它们就被写到varEnv里面去了。——回到之前的说明里面，如果这个时候ctx.varEnv是指向全局的话，那么在全局中的globalEnv其实在“全局的ctx”中还是那个“同一个”。也就是：\n&amp;gt; globalCtx.varEnv === globalCtx.lexEnv === globalEnv\n\n关键在于：所谓varEnv/lexEnv分成两组，只是用于在ctx中“查找”不同的环境，而并不决定环境的“组成结构”是什么样子。——例如，前面也说过，全局环境(globalEnv)由一个OER和一个DER组成。\n\n最后，“var 声明/函数声明”是保存在ER中的。它将通过环境记录（varEnv/lexEnv）来查找，并保存在找到的环境（Env）的环境记录（ER）中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587236804,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":178109,"user_name":"star","can_delete":false,"product_type":"c1","uid":1505243,"ip_address":"","ucode":"54D858422D1E27","user_header":"https://static001.geekbang.org/account/avatar/00/16/f7/db/4eb5da19.jpg","comment_is_top":false,"comment_ctime":1581587372,"is_pvip":false,"replies":[{"id":"69089","content":"非严格模式中向只读属性（包括冻结的属性）赋值并不发生异常。<br>置为严格模式就看到了。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1581595946,"ip_address":"","comment_id":178109,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10171521964","product_id":100039701,"comment_content":"```js<br>&#47;&#47; 声明“原始的变量a”<br>var a = {n:1};<br><br>&#47;&#47; 使它的属性表冻结（不能再添加属性）<br>Object.freeze(a);<br><br>try {<br>  &#47;&#47; 本节的示例代码<br>  a.x = a = {n:2};<br>}<br>catch (x) {<br>  &#47;&#47; 异常发生，说明第二次赋值“a.x = ...”中操作的`a`正是原始的变量a<br>  console.log(&#39;第二次赋值导致异常.&#39;);<br>}<br><br>&#47;&#47; 第一次赋值是成功的<br>console.log(a.n); &#47;&#47;<br>```<br>这段代码再chrome和nodejs内执行都不会catch到异常，这是为什么？","like_count":2,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483669,"discussion_content":"非严格模式中向只读属性（包括冻结的属性）赋值并不发生异常。\n置为严格模式就看到了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581595946,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158167,"user_name":"qqq","can_delete":false,"product_type":"c1","uid":1006786,"ip_address":"","ucode":"91B0ACF8CBE7BD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/c2/8ffd2ad0.jpg","comment_is_top":false,"comment_ctime":1575341348,"is_pvip":true,"replies":[{"id":"60988","content":"最后一个答案有点草率了，其它的都很简洁地指到关键处了。可以+2分~ 哈哈~","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1575712815,"ip_address":"","comment_id":158167,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10165275940","product_id":100039701,"comment_content":"1. x 就是一个引用，没有异常发生，返回 true<br>2. 一个是引用求值，一个是表达式求值<br>3. a.x 就是一个引用，可以赋值<br>4. 添加到全局对象了","like_count":2,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476648,"discussion_content":"最后一个答案有点草率了，其它的都很简洁地指到关键处了。可以+2分~ 哈哈~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575712815,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153330,"user_name":"简＜单","can_delete":false,"product_type":"c1","uid":1379817,"ip_address":"","ucode":"6367AD50BE7B94","user_header":"https://static001.geekbang.org/account/avatar/00/15/0d/e9/23e21a58.jpg","comment_is_top":false,"comment_ctime":1574218246,"is_pvip":false,"replies":[{"id":"58969","content":"前面部分的问题，在留言中有一个给“青史成灰”的回复，应该是一样的，你先看看。<br><br>后面这个问题，你的答案是对的，“对它赋值1和直接操作a.x=1应该都是一样”。但是这个问题的另一个“扩展版本”是，如果“如何该赋值是成立的，那么为什么(0, a.x) = 1”不成立。^^.<br><br>:)","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574234300,"ip_address":"","comment_id":153330,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10164152838","product_id":100039701,"comment_content":"文中老师说a.x = a = { n: 2 }的执行是从左向右的，但是第一次赋值操作是 a = { n: 2}，这一点说说自己的理解，希望老师确认一下：<br>1、从左向右，执行表达式a.x = a = { n: 2 } ， 先执行a.x<br>2、然后执行表达式 a.x = 「 a= { n :2} 」（这里加「」是为了表达清晰），由于后面a={ n: 2}也是个表达式，得继续求值之后，才能执行第一个 = 赋值操作<br>3、执行a = { n :2 } ，这里同理，先a，再{ n: 2} <br>4、这个时候 = 两边的表达式已经求值完成，可以执行赋值操作了（ a = { n: 2} ），所以说第一次赋值是a = { n: 2} ，同时，这个赋值表达式的求值结果是{ n: 2}<br>5、这时候第一个 = 两边表达式的求值都已经完成（分别是a.x 和 { n: 2}），这时候执行第二次赋值操作，a.x = { n: 2 }<br>以上是我自己的理解，希望老师批改一下～<br><br>顺便对于复习题第三道“设“a.x === 0”，试说明“(a.x) = 1”为什么可行”，没有看懂题意😢，这难道不是说a.x先是0，然后再给它赋值为1嘛？为什么会有可行不可行一说？对a.x加了括号也是一个表达式，它的求值结果也就是a.x引用，对它赋值1和直接操作a.x=1应该都是一样的吧？我已经绕晕了T_T","like_count":2,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475123,"discussion_content":"前面部分的问题，在留言中有一个给“青史成灰”的回复，应该是一样的，你先看看。\n\n后面这个问题，你的答案是对的，“对它赋值1和直接操作a.x=1应该都是一样”。但是这个问题的另一个“扩展版本”是，如果“如何该赋值是成立的，那么为什么(0, a.x) = 1”不成立。^^.\n\n:)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574234300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151867,"user_name":"桔子","can_delete":false,"product_type":"c1","uid":1387844,"ip_address":"","ucode":"9555BC4494A28C","user_header":"https://static001.geekbang.org/account/avatar/00/15/2d/44/0a209c31.jpg","comment_is_top":false,"comment_ctime":1573802681,"is_pvip":false,"replies":[{"id":"58432","content":"这个……确实实现起来有难度。我通常在做讲演稿的时候才会用这种方式，但讲演稿的讲法，跟这里的课程的讲课方法区别还是很大的。<br><br>当然，即使不用动态的图，使用流程图或框线图其实也挺好的。不过，总之，以极客时间的“语音课程”来说，很难讲。——话说回来，如果是需要更深的阅读，以及更丰富的图例，以及表格等表现形式，那么可以看我的书哦。《JavaScript语言精髓与编程实践》这本书的第三版……快要出版了吔~ ^^.","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573835441,"ip_address":"","comment_id":151867,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10163737273","product_id":100039701,"comment_content":"有的地方描述有点晕，看了好几遍才明白表述的意思，要是有一些动态的图演示的话可能效果更好点","like_count":2,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474641,"discussion_content":"这个……确实实现起来有难度。我通常在做讲演稿的时候才会用这种方式，但讲演稿的讲法，跟这里的课程的讲课方法区别还是很大的。\n\n当然，即使不用动态的图，使用流程图或框线图其实也挺好的。不过，总之，以极客时间的“语音课程”来说，很难讲。——话说回来，如果是需要更深的阅读，以及更丰富的图例，以及表格等表现形式，那么可以看我的书哦。《JavaScript语言精髓与编程实践》这本书的第三版……快要出版了吔~ ^^.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573835441,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1742968,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/98/78/6459e29e.jpg","nickname":"麦芽科技学堂","note":"","ucode":"A90DDE4B6696BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":160603,"discussion_content":"这样的课程需要深度思考，估计没人听音频的，不知道极客有没有统计过，有多少人听过听过音频","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1580819390,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1742968,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/98/78/6459e29e.jpg","nickname":"麦芽科技学堂","note":"","ucode":"A90DDE4B6696BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":160601,"discussion_content":"第三版有了吗，哪里有卖","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580819182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":238393,"user_name":"Geek_8d73e3","can_delete":false,"product_type":"c1","uid":1961902,"ip_address":"","ucode":"FF89629117B96C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epneC3LXv0Ve2tCXPfvsXtRb5StVicNCEHUSfzneLYUDJ03B6ocINHzeLf94aw0dEkjLShSdK9NUoA/132","comment_is_top":false,"comment_ctime":1596158872,"is_pvip":false,"replies":[{"id":"88074","content":"<br>&gt; console.log输出的是undefined<br>这是因为a作为一个声明，是在当前环境块（例如函数或全局）创建的时候被同时创建在环境块中的。——也就是说这个过程早于该环境块中的“第一行”代码的执行。而`var`声明意味着在创建它（也就是a）的时候，将初始绑定一个undefined值。<br>这样一来，由于“a是创建并立即初始绑定了undefined的”，所以`console.log`就能输出undefined.<br><br>接下来说第二个问题。`= 10`是初始器语法组件，是在语句解析（parser）阶段就决定了的事情，所以到执行期也是按这个来执行的，不会“变成了赋值语句”。——尽管在效果上一致。<br><br>同样的过程，对于`let a = 10`来说，虽然它在“环境创建”的时候也创建了名字`a`，但是并没有初始化它（为undefined），所以它就是一个“未绑定过的a”。当执行到`console.log`时，会因为“访问一个未绑定过值的名字”而抛出异常，尽管这种情况下错误提示是“a is not defined”，但事实是它未绑定值，而不是未声明。<br><br>最后补充一点，`= 10`作为初始器，在执行的时候调用的是 InitializeReferencedBinding(`a`, GetValue(rhs))；而`a = 10`作为赋值，在执行的时候调用的是PutValue(`a`, GetValue(rhs))。从ECMAScript中就可以看出这样的不同来。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1596162870,"ip_address":"","comment_id":238393,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5891126168","product_id":100039701,"comment_content":"console.log(a);<br>var a = 10;<br><br>老师，var a = 10 不是一个赋值语句，= 10这是一个初始器的语法组件，那么我上述的代码中，这个初始器是不是赋值语句？因为我console.log输出的是undefined。初始器并不想我们想的那样在a声明之后就被初始为了10，而是在真正运行到程序的第二行的时候才被赋值为了10，那我这岂不是算一个赋值语句了？","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502736,"discussion_content":"\n&amp;gt; console.log输出的是undefined\n这是因为a作为一个声明，是在当前环境块（例如函数或全局）创建的时候被同时创建在环境块中的。——也就是说这个过程早于该环境块中的“第一行”代码的执行。而`var`声明意味着在创建它（也就是a）的时候，将初始绑定一个undefined值。\n这样一来，由于“a是创建并立即初始绑定了undefined的”，所以`console.log`就能输出undefined.\n\n接下来说第二个问题。`= 10`是初始器语法组件，是在语句解析（parser）阶段就决定了的事情，所以到执行期也是按这个来执行的，不会“变成了赋值语句”。——尽管在效果上一致。\n\n同样的过程，对于`let a = 10`来说，虽然它在“环境创建”的时候也创建了名字`a`，但是并没有初始化它（为undefined），所以它就是一个“未绑定过的a”。当执行到`console.log`时，会因为“访问一个未绑定过值的名字”而抛出异常，尽管这种情况下错误提示是“a is not defined”，但事实是它未绑定值，而不是未声明。\n\n最后补充一点，`= 10`作为初始器，在执行的时候调用的是 InitializeReferencedBinding(`a`, GetValue(rhs))；而`a = 10`作为赋值，在执行的时候调用的是PutValue(`a`, GetValue(rhs))。从ECMAScript中就可以看出这样的不同来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596162870,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168959,"user_name":"wDaLian","can_delete":false,"product_type":"c1","uid":1381721,"ip_address":"","ucode":"D419921E3CFC00","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoJ8fUFEicTEPIvIdsicBywsBoIlBrPAPSbiasul9LNSO5juOxXJub1icIoWRdyk33MByyFxzHhdVKkUw/132","comment_is_top":false,"comment_ctime":1578225680,"is_pvip":false,"replies":[{"id":"65579","content":"你的整个理解过程是对的。<br><br>不过在案例3里面，“原来的e没有了因此不能赋值了”这个说法不对的。原来的e还是在的，在这个赋值操作中它也成功赋值了，只是赋在“原来的e”上面（所以我称为左侧“空悬”了一个e），而你又没有办法找到“原来的e”，所以看不见这个结果罢了。<br><br>你只需要为“原来的e”添加一个引用，就能观察到它了。比如声明为：<br>```<br>var x;<br>var e = x = {};<br>```<br>然后你能从x.a观察到“原来的e”的赋值效果。<br><br>这也是在这一讲里面讲到过的方法。^^.","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1578278128,"ip_address":"","comment_id":168959,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5873192976","product_id":100039701,"comment_content":"   我是将整个代码分成三个案例来看<br>   1. 首先案例一中先执行了c.a 因为这是一个表达式，然后紧接着执行了b（这个时候b也是表单式吧个人不确定希望老师告诉一下），然后执行了{&#39;a&#39;:1},接着从右往左一次赋值就得到案例一的结果<br>    2.案例二也是一样先执行表达式d.a ，然后依次 d ，{&#39;a&#39;:1},然后又依次从右往左赋值，但是d先变成了<br>{‘a’:1},此时d的指向已经变了不是之前的指向了，然后该给d.a赋值，但是d.a在表达式执行的时候d是上一次<br>的内存指向，赋值发现之前的d已经没有所以不能给d.a赋值，但打印的时候打印的其实是现在新的指向d因此是1<br>    3.案例三就是老是说的案例，我理解就是还是一样依次执行e.a，e，{‘ee’:1}然后又从右往左赋值，又到了e.a的时候发现e的指向已经变了，原来的e没有了因此不能赋值了，但是下面打印的e.a其实新的指向也就是{&#39;ee&#39;:1},因为这里确实没有&#39;a&#39;这个key 所以打印就是undefined<br><br>    &#47;&#47; 案例一<br>    var c = {};<br>    var b= {}<br>    c.a = b = {&#39;a&#39;:1};<br>    console.log(c.a); &#47;&#47; {a: 1}<br>    <br>    &#47;&#47; 案例二<br>    var d = {};<br>    d.a = d = {&#39;a&#39;:1};<br>    console.log(d.a); &#47;&#47; 1<br><br>    &#47;&#47; 案例三<br>    var e = {};<br>    e.a = e = {&#39;ee&#39;:1};<br>    console.log(e.a); &#47;&#47; undefined<br><br>不知道说的对不对希望老师 帮看一下我的理解","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480387,"discussion_content":"你的整个理解过程是对的。\n\n不过在案例3里面，“原来的e没有了因此不能赋值了”这个说法不对的。原来的e还是在的，在这个赋值操作中它也成功赋值了，只是赋在“原来的e”上面（所以我称为左侧“空悬”了一个e），而你又没有办法找到“原来的e”，所以看不见这个结果罢了。\n\n你只需要为“原来的e”添加一个引用，就能观察到它了。比如声明为：\n```\nvar x;\nvar e = x = {};\n```\n然后你能从x.a观察到“原来的e”的赋值效果。\n\n这也是在这一讲里面讲到过的方法。^^.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578278128,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165999,"user_name":"AIMD","can_delete":false,"product_type":"c1","uid":1455864,"ip_address":"","ucode":"4990A56A63A9FF","user_header":"https://static001.geekbang.org/account/avatar/00/16/36/f8/80abb3f7.jpg","comment_is_top":false,"comment_ctime":1577360740,"is_pvip":false,"replies":[{"id":"63298","content":"对的。确实是这样。^^.","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1577376728,"ip_address":"","comment_id":165999,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5872328036","product_id":100039701,"comment_content":"我觉的可以这样理解，<br>var a = {n:1}, ref = a;&#47;&#47; 第一行<br>a.x = a = {n:2};&#47;&#47; 第二行<br>console.log(a.x); &#47;&#47; --&gt; undefined<br>console.log(ref.x); &#47;&#47; {n:2}<br><br>1.首先声明了a变量，里面放了一个对象（即a容器里面放了{n:1}）<br>2.成员访问运输符的优先级高于赋值操作符，所以a.x = a = {n:2};中的a.x会被运算求值为一个引用结果（ a = { n:1<br>           x:  undefined <br>}）即这个对象的地址,此时a.x已经不在是容器，就是一个Result<br>3.变量容器同步，此时a对象存放着（ a = { n:1<br>           x:  undefined <br>}）<br>4.接着从右自左执行赋值操作 ，此时a对象变成了<br>a = {   n: 1<br>         x:  {n:2}<br>}）<br><br>5.因为a.x已经不是容器，无法赋值为最新的状态，所以保留原来的Result，在访问a.x就是undefined ;<br>6.因为ref和a是同一个引用，所以ref.x就是第4步骤最新状态的a.x的值<br>","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479347,"discussion_content":"对的。确实是这样。^^.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577376728,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162966,"user_name":"Geek_8b9ecb","can_delete":false,"product_type":"c1","uid":1465006,"ip_address":"","ucode":"20CB545ABD4472","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKaVQQBhGwMYsqtGPm6WojicdSDUtXADNDBRiaqwJsuvdicdTUObN2foNd9OZicGOP2d3t7bEYOoocyrg/132","comment_is_top":false,"comment_ctime":1576635681,"is_pvip":false,"replies":[{"id":"61929","content":"这个……这一节讲的不就是为什么么？这个例子就是一个应用了（当然我其实不建议这么用），所以答案还是得从这一课的内容中找。。。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1576648169,"ip_address":"","comment_id":162966,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5871602977","product_id":100039701,"comment_content":"老师好，为什么root会是{index:&#39;NONE&#39;,next:{index:10,next:{index:9,...}}}","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478191,"discussion_content":"这个……这一节讲的不就是为什么么？这个例子就是一个应用了（当然我其实不建议这么用），所以答案还是得从这一课的内容中找。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576648169,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162537,"user_name":"三叶草","can_delete":false,"product_type":"c1","uid":1179020,"ip_address":"","ucode":"3718E89ABA2066","user_header":"https://static001.geekbang.org/account/avatar/00/11/fd/8c/9c00e165.jpg","comment_is_top":false,"comment_ctime":1576551047,"is_pvip":false,"replies":[{"id":"61840","content":"后面有一个能查看“原始的a”的示例。<br><br>```<br>var a = {n:1}, ref = a; &#47;&#47; ref暂存了“原始的a”<br><br>a.x = a = {n:2};<br><br>console.log(a.x); &#47;&#47; --&gt; undefined<br>console.log(ref.x); &#47;&#47; {n:2}<br>console.log(ref.n); &#47;&#47; 1  &lt;-这里是1<br>```<br>","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1576560995,"ip_address":"","comment_id":162537,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5871518343","product_id":100039701,"comment_content":"老师：这句话说 a.x它作为结果（Result）所保留的“a”，是在被第一次赋值操作覆盖之前的、那个“原始的变量a”。也就是说，如果你试图访问它的“a.n”，那应该是值“1”。<br>但是我google中console进行测试，alert(a.n)弹出来的是2，而不是“1”，是什么原因","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478079,"discussion_content":"后面有一个能查看“原始的a”的示例。\n\n```\nvar a = {n:1}, ref = a; // ref暂存了“原始的a”\n\na.x = a = {n:2};\n\nconsole.log(a.x); // --&amp;gt; undefined\nconsole.log(ref.x); // {n:2}\nconsole.log(ref.n); // 1  &amp;lt;-这里是1\n```\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576560995,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157795,"user_name":"穿秋裤的男孩","can_delete":false,"product_type":"c1","uid":1748640,"ip_address":"","ucode":"D0F48C66377893","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ae/a0/707350ef.jpg","comment_is_top":false,"comment_ctime":1575260113,"is_pvip":false,"replies":[{"id":"60486","content":"“第二次赋值的结果是{ n: 2 },并且第二次赋值完成之后，会把结果再赋值给第一次a = ...”<br><br>^^，答案正确。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1575274271,"ip_address":"","comment_id":157795,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5870227409","product_id":100039701,"comment_content":"老师，假如换个位置如下：<br>var a = { n: 1 };<br>a = a.x = { n: 2 }; &#47;&#47; 之前为a.x = a = { n: 2 };<br>a.x的赋值是在第二次（从左往右执行），也就是a = ...是第一次赋值，为什么a.x还是undefined呢？<br>难道第二次赋值的结果是{ n: 2 },并且第二次赋值完成之后，会把结果再赋值给第一次a = ...吗？这边的赋值过程能帮忙解惑吗？<br>非常感谢！","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476532,"discussion_content":"“第二次赋值的结果是{ n: 2 },并且第二次赋值完成之后，会把结果再赋值给第一次a = ...”\n\n^^，答案正确。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575274271,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155706,"user_name":"Ronnie","can_delete":false,"product_type":"c1","uid":1266726,"ip_address":"","ucode":"DD24A2981E59F2","user_header":"https://static001.geekbang.org/account/avatar/00/13/54/26/d3997877.jpg","comment_is_top":false,"comment_ctime":1574739120,"is_pvip":false,"replies":[{"id":"59906","content":"“所以js engine，首先会create 一个新的属性x”。——这个操作是不会发生的。如果这样做，那么意味着“访问不存在的属性”是一个“创建属性”的行为，这样一来，系统的负担&#47;开销就大得不得了了。<br><br>所以我在讲述这里的时候，说的是“空悬”了一个引用。就是这个意思。除了没有“创建属性”这样的隐式行为之外，你其它的描述是没什么问题的。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574777207,"ip_address":"","comment_id":155706,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5869706416","product_id":100039701,"comment_content":"a.x= ...., 这个是不是可以这样理解， 在求值a.x=..., 时候，由于x 在原来变量里不存在，所以js engine，首先会create 一个新的属性x，然后把这个x 的引用作为赋值的左操作数，然后依据右边的操作数完成赋值，但右边的a={n: 2}是一个表达式，赋值完成后，返回的是a 的新值{n: 2}, 这样赋值后 x 就等于{n: 2}, 由于x所在的对象{n: 1, x: {n： 2}} 现在没有引用（很快会被回收）也就没法访问了。","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475842,"discussion_content":"“所以js engine，首先会create 一个新的属性x”。——这个操作是不会发生的。如果这样做，那么意味着“访问不存在的属性”是一个“创建属性”的行为，这样一来，系统的负担/开销就大得不得了了。\n\n所以我在讲述这里的时候，说的是“空悬”了一个引用。就是这个意思。除了没有“创建属性”这样的隐式行为之外，你其它的描述是没什么问题的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574777207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1266726,"avatar":"https://static001.geekbang.org/account/avatar/00/13/54/26/d3997877.jpg","nickname":"Ronnie","note":"","ucode":"DD24A2981E59F2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":63741,"discussion_content":"这里的‘create” 只有在赋值的情况下才会发生，否则这个’引用‘怎么产生。 您说的”空悬“这个有点抽象。 可以的话可以找一些js engine 的代码或者标准文档解释这个背后怎么发生的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574906770,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153161,"user_name":"18625322963","can_delete":false,"product_type":"c1","uid":1628953,"ip_address":"","ucode":"825472ECCDA3A7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKfaQfj2oHpIawX80rIr0bAMuP77wN0BDdMW20HfyMyj2b6RlGSTRSRwX3F9rtevWoibSuoE4iaeEBg/132","comment_is_top":false,"comment_ctime":1574171334,"is_pvip":false,"replies":[{"id":"58970","content":"请参见对“青史成灰”的留言的回复。^^.","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574234344,"ip_address":"","comment_id":153161,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5869138630","product_id":100039701,"comment_content":"按照权威指南那句话，是不是可以这么理解，先执行a.x = {},此时a指向内存的值为{x: x}.然后执行a = {},因为原a指向的内存是对象，可以理解为此时的a是被重新定义了，而原a引用为0，销毁了，如果有一个b曾经指向原a，那么此时b 引用 原a，原a指向的内存没有被销毁， 而a等于新a ，相当于重新创建了一个值保存","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475065,"discussion_content":"请参见对“青史成灰”的留言的回复。^^.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574234344,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151960,"user_name":"旺旺","can_delete":false,"product_type":"c1","uid":1159196,"ip_address":"","ucode":"FE2CF90F446BFB","user_header":"https://static001.geekbang.org/account/avatar/00/11/b0/1c/2e30eeb8.jpg","comment_is_top":false,"comment_ctime":1573823045,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5868790341","product_id":100039701,"comment_content":"JavaScript果然太灵活，然后感觉好难啊","like_count":1},{"had_liked":false,"id":151846,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1573799637,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5868766933","product_id":100039701,"comment_content":"老师讲得真细啊，学到了很多，谢谢老师。","like_count":1},{"had_liked":false,"id":341940,"user_name":"胡家富","can_delete":false,"product_type":"c1","uid":2960520,"ip_address":"","ucode":"94CA00B970E15F","user_header":"","comment_is_top":false,"comment_ctime":1649925874,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649925874","product_id":100039701,"comment_content":"尊敬的方总，你好","like_count":0},{"had_liked":false,"id":333803,"user_name":"Geek_a44db9","can_delete":false,"product_type":"c1","uid":2835868,"ip_address":"","ucode":"8D58329B4F1689","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJWOyzdmdY17rolD2WqfvMNpUeXCCHwjnOOsRvqU5ib9LGXtxrGnYiaY04xZ4yomwiaeulnZEQ2Pfz9A/132","comment_is_top":false,"comment_ctime":1644543797,"is_pvip":false,"replies":[{"id":"122089","content":"老实说，我不太读得通你的问题~ <br><br>我只能提到三点。<br><br>第一，在`with (obj) x = ...`中，如果obj没有x这个属性，那么就相当于“向一个不存在的变量名赋值”，并且会因此导致在当前函数或更者全局声明一个变量x。这符合处理“变量名泄漏”的基本原则，这是最早最早的JavaScript约定的。<br><br>第二，与你的第2个问题相关的，“为什么不会给obj添加属性x”呢？这是因为with语句只为它后面的“语句块”创建了一个【词法作用域】，以便在其中添加let&#47;const这些“词法声明”；但with语句并没有创建【变量作用域】，因此不能在其中添加var声明。——而所有的“变量名泄露”出来的名字，都只能在【变量作用域】中创建，因此它就被“提升”到更加外层的作用域中去创建了。<br><br>第三，在JavaScript中，函数和全局是拥有自己的【变量作用域】的，所以“with (obj) x = ...”泄漏出来的名字就会创建在它们之中；模块也有自己的【变量作用域】，但是因为它总是工作在严格模式中所以不存在“变量名泄漏”的问题。<br><br>综合来看，“with (obj) ...语句中不能创建obj的属性”是语言设计上的约定规则，而实现上，就是上面讲述的过程。当然，你也可以把“规则”看成是实现的结果。","user_name":"作者回复","user_name_real":"编辑","uid":"1521669","ctime":1644835290,"ip_address":"","comment_id":333803,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1644543797","product_id":100039701,"comment_content":"亲爱的周爱民老师，具体的地址如下: https:&#47;&#47;2ality.com&#47;2011&#47;06&#47;with-statement.html<br>他们说with的作用是： 它的预期用途是在多次访问对象时避免冗余，这点是对的。<br>1. 在【 bla   = 123;】他并不会给当前对象的添加属性呀,这里文章是不是有错误？<br>      访问对象，修改其属性，这样的一种值绑定会添加到 外部函数，故 是window.bla    = 123；<br>2.expression 将给定的表达式添加到在评估语句时使用的作用域链上。<br>   是不是相当于将本表达式的引用添加上去，那既然都可以访问到，  <br>   那 为什么with (obj={}) x = 100; 不会给 obj 添加一个属性’x’？ <br>foo.bar.baz.bla   = 123;<br>foo.bar.baz.yadda = &quot;abc&quot;;<br>with(foo.bar.baz) {<br>        bla   = 123;<br>        yadda = &quot;abc&quot;;<br>    }","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550984,"discussion_content":"老实说，我不太读得通你的问题~ \n\n我只能提到三点。\n\n第一，在`with (obj) x = ...`中，如果obj没有x这个属性，那么就相当于“向一个不存在的变量名赋值”，并且会因此导致在当前函数或更者全局声明一个变量x。这符合处理“变量名泄漏”的基本原则，这是最早最早的JavaScript约定的。\n\n第二，与你的第2个问题相关的，“为什么不会给obj添加属性x”呢？这是因为with语句只为它后面的“语句块”创建了一个【词法作用域】，以便在其中添加let/const这些“词法声明”；但with语句并没有创建【变量作用域】，因此不能在其中添加var声明。——而所有的“变量名泄露”出来的名字，都只能在【变量作用域】中创建，因此它就被“提升”到更加外层的作用域中去创建了。\n\n第三，在JavaScript中，函数和全局是拥有自己的【变量作用域】的，所以“with (obj) x = ...”泄漏出来的名字就会创建在它们之中；模块也有自己的【变量作用域】，但是因为它总是工作在严格模式中所以不存在“变量名泄漏”的问题。\n\n综合来看，“with (obj) ...语句中不能创建obj的属性”是语言设计上的约定规则，而实现上，就是上面讲述的过程。当然，你也可以把“规则”看成是实现的结果。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1644835290,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2835868,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJWOyzdmdY17rolD2WqfvMNpUeXCCHwjnOOsRvqU5ib9LGXtxrGnYiaY04xZ4yomwiaeulnZEQ2Pfz9A/132","nickname":"Geek_a44db9","note":"","ucode":"8D58329B4F1689","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550430,"discussion_content":"我明白了，一切都是作用链的选择！他的文章是没问题的！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644544554,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332414,"user_name":"Kids See Ghost","can_delete":false,"product_type":"c1","uid":1390088,"ip_address":"","ucode":"DA57BB8327BB01","user_header":"https://static001.geekbang.org/account/avatar/00/15/36/08/c77d8a5a.jpg","comment_is_top":false,"comment_ctime":1643240290,"is_pvip":false,"replies":[{"id":"121484","content":"好的语言设计是这样的，不过JavaScript并不按这个方式来讨论语句或表达式。","user_name":"作者回复","user_name_real":"编辑","uid":"1521669","ctime":1643338930,"ip_address":"","comment_id":332414,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1643240290","product_id":100039701,"comment_content":"想请教一下，我一些地方资料上看到过说expression和statement的区别是expression不会有side effects。但是赋值作为一个expression它就有很明显的side effect - 即赋值(改变binding）所以想请问您怎么看待这个问题的。","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548711,"discussion_content":"好的语言设计是这样的，不过JavaScript并不按这个方式来讨论语句或表达式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643338930,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332413,"user_name":"Kids See Ghost","can_delete":false,"product_type":"c1","uid":1390088,"ip_address":"","ucode":"DA57BB8327BB01","user_header":"https://static001.geekbang.org/account/avatar/00/15/36/08/c77d8a5a.jpg","comment_is_top":false,"comment_ctime":1643239588,"is_pvip":false,"replies":[{"id":"121487","content":"所有的表达式都“同时”可以是语句。“表达式语句”与“表达式”只是语法解析上的不同，更准确地说是“不同的语法解析阶段对同一事物的理解不同”。不过在引擎执行它们的时候，因为这种不同是会有差异的，例如<br>```<br>eval(&#39;{}&#39;);<br>```<br>如果是按语句解析这行字符串（代码），那么它是块语句；如果按表达式来解析，就是对象字面量（单值表达式）。eval是先按语句解析（然后才在语句中找下一级的表达式），所以它会被理解为块语句。","user_name":"作者回复","user_name_real":"编辑","uid":"1521669","ctime":1643339307,"ip_address":"","comment_id":332413,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1643239588","product_id":100039701,"comment_content":"老师请问赋值是一个表达式(expression）的同时，**也是**一个statement吗？还是说assignment 只能是一个expression，不算事statement？","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548714,"discussion_content":"所有的表达式都“同时”可以是语句。“表达式语句”与“表达式”只是语法解析上的不同，更准确地说是“不同的语法解析阶段对同一事物的理解不同”。不过在引擎执行它们的时候，因为这种不同是会有差异的，例如\n```\neval(&#39;{}&#39;);\n```\n如果是按语句解析这行字符串（代码），那么它是块语句；如果按表达式来解析，就是对象字面量（单值表达式）。eval是先按语句解析（然后才在语句中找下一级的表达式），所以它会被理解为块语句。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643339307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330858,"user_name":"Kids See Ghost","can_delete":false,"product_type":"c1","uid":1390088,"ip_address":"","ucode":"DA57BB8327BB01","user_header":"https://static001.geekbang.org/account/avatar/00/15/36/08/c77d8a5a.jpg","comment_is_top":false,"comment_ctime":1642229755,"is_pvip":false,"replies":[{"id":"120743","content":"为什么要把他们分开……之前不是回复过了么？const&#47;let&#47;var是声明，声明就是静态语法，而a=1是表达式执行，是运行过程中的。在解释你<br>   &gt; 至于 “修正什么样的错误理解”的问题<br>时详细说过二者的区别呀。<br><br>如果非得说二者是否都是putValue()。那还真是有区别的。“向标识符的第一次赋值”其实是有特定意义的。第一次叫“绑定初值”，之后的才叫“赋值”。赋值才用putValue。<br><br>绑定初值有什么意义呢？这个在早期的js中是不区分的。但在ES6之后就把这个阶段独立出来了（事实上在ECMAScript中更早，只是不显式地讲）。“绑定初值”的价值在于说明一个运算数的可变性。——绑定初值后不可变的，是常量；绑定初值后可变的，是变量。<br><br>在js中，变量又分let&#47;var两种。这也与绑定初值有关：var是绑定初值undefined的变量，而let是不绑定初值的标识符（要等到它完成初始绑定后才可用）。<br><br>这才是为什么let不支持变量提升的原因，因为在执行到let x = ...这样的“初始绑定”之前，标识符x是存在的，但没有“初始绑定”，所以不能用。<br><br>总之来说，规范在这些语言的基础概念上都是不讲的，很多东西也都不是直接讲的，得假设读者有一些相关的基础，所以你得补很多的课外知识才能解释规范的某些行为。这与具体的语言（例如js或c）是无关的。有关语言设计的书很多，很难的也有，比如我在看《计算系统的形式语义》（两大卷），一般的也有，推荐你看看我那本开放的电子书《程序原本》。在这里：https:&#47;&#47;github.com&#47;aimingoo&#47;my-ebooks ，你需要看其中的前5章。","user_name":"作者回复","user_name_real":"作者","uid":"1521669","ctime":1642307700,"ip_address":"","comment_id":330858,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1642229755","product_id":100039701,"comment_content":"请问一下为什么规范要把赋值和变量申明的初始化设计成不同的语法结构：<br><br>赋值语法是：LeftHandSideExpression = AssignmentExpression<br>声明语法是：BindingIdentifier Initializer 其中初始器（Initializer）语法是：“= AssignmentExpression”<br>他们本质上都会调用`putValue`吧？<br>所以不论是`const a = 1` 还是 `a = 1` ， 都可以用赋值来解释。是为什么要把他们区分开来呢？是因为变量初始化的时候,`a` 不能evaluate成一个reference？所以要先创建一个reference才能用putValue? 之后赋值的话，因为a已经是一个reference，就可以用putValue了？<br>","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546381,"discussion_content":"为什么要把他们分开……之前不是回复过了么？const/let/var是声明，声明就是静态语法，而a=1是表达式执行，是运行过程中的。在解释你\n   > 至于 “修正什么样的错误理解”的问题\n时详细说过二者的区别呀。\n\n如果非得说二者是否都是putValue()。那还真是有区别的。“向标识符的第一次赋值”其实是有特定意义的。第一次叫“绑定初值”，之后的才叫“赋值”。赋值才用putValue。\n\n绑定初值有什么意义呢？这个在早期的js中是不区分的。但在ES6之后就把这个阶段独立出来了（事实上在ECMAScript中更早，只是不显式地讲）。“绑定初值”的价值在于说明一个运算数的可变性。——绑定初值后不可变的，是常量；绑定初值后可变的，是变量。\n\n在js中，变量又分let/var两种。这也与绑定初值有关：var是绑定初值undefined的变量，而let是不绑定初值的标识符（要等到它完成初始绑定后才可用）。\n\n这才是为什么let不支持变量提升的原因，因为在执行到let x = ...这样的“初始绑定”之前，标识符x是存在的，但没有“初始绑定”，所以不能用。\n\n总之来说，规范在这些语言的基础概念上都是不讲的，很多东西也都不是直接讲的，得假设读者有一些相关的基础，所以你得补很多的课外知识才能解释规范的某些行为。这与具体的语言（例如js或c）是无关的。有关语言设计的书很多，很难的也有，比如我在看《计算系统的形式语义》（两大卷），一般的也有，推荐你看看我那本开放的电子书《程序原本》。在这里：https://github.com/aimingoo/my-ebooks ，你需要看其中的前5章。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642307700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1390088,"avatar":"https://static001.geekbang.org/account/avatar/00/15/36/08/c77d8a5a.jpg","nickname":"Kids See Ghost","note":"","ucode":"DA57BB8327BB01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":546623,"discussion_content":"感谢 所以绑定初值并没有用到put Value吗 我以为要把一个值给一个变量必须要用到putValue呢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642362760,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":546381,"ip_address":""},"score":546623,"extra":""}]}]},{"had_liked":false,"id":330673,"user_name":"Kids See Ghost","can_delete":false,"product_type":"c1","uid":1390088,"ip_address":"","ucode":"DA57BB8327BB01","user_header":"https://static001.geekbang.org/account/avatar/00/15/36/08/c77d8a5a.jpg","comment_is_top":false,"comment_ctime":1642109423,"is_pvip":false,"replies":[{"id":"120598","content":"你的理解1是对的。相关引用在下面：<br>======<br>https:&#47;&#47;tc39.es&#47;ecma262&#47;#sec-assignment-operators<br>赋值语法是：LeftHandSideExpression = AssignmentExpression<br><br>https:&#47;&#47;tc39.es&#47;ecma262&#47;#sec-declarations-and-the-variable-statement<br>声明语法是：BindingIdentifier Initializer<br>其中初始器（Initializer）语法是：“= AssignmentExpression”<br>也就是说初始器是一个语法结构，其中“=”号是一个语法组件；而赋值中的“=”号是一个运算符。<br>======<br><br>关于第二个问题其实很简单，例如“obj.x = 1”，其中左侧就是一个表达式啊，所以向左侧表达式赋值，有什么奇怪的么？<br><br>至于 “修正什么样的错误理解”的问题。比如说，标识符就是静态语法分析期能理解的，因为“声明语句（语法）”中的标识会就可以导出。——导入与导出都是静态语法可分析的。<br><br>拿这个来举个例子。<br><br>“var a = 1”这个语法要求“a”是标识符，而不能是表达式，对吧？<br>正是因此，<br>export var a = 1是成立的；而export &quot;obj.x = 1”就不成立。因为obj.x是表达式。<br><br>反之，如果模糊掉上面的差异，非要认为“var a”中的a是一个表达式，那么“export var obj.x = 1”就必须成立。<br><br>更进一步的，如果说“标识符”与“表达式”没有差异，那么下面两个语法也就没差异：<br>export a; &#47;&#47; 例1。成立<br>export obj.x; &#47;&#47; 例2。既然没差异，那么也要成立吗？<br><br>这显然是不对的。——所以现实是，我们不能导出一个表达式，也就上述例2不成立。","user_name":"作者回复","user_name_real":"编辑","uid":"1521669","ctime":1642130268,"ip_address":"","comment_id":330673,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1642109423","product_id":100039701,"comment_content":"想请问一下，如果我没有理解错的话: <br>1. var a = 1 这里的a不是表达式(expression) 而是标识符(identifier)<br>2. a = 1 这里的a就是表达式<br>我还是没有太明白为什么（2）例子中的a可以是表达式，“给一个表达式赋值”感觉讲不通。<br>另外请问把（1）里的a理解为标识符(identifier)而不是表达式(expression)能具体修正我们什么样的错误理解吗？<br>另外请问您能给一个link到es specs里具体指出了以上这两种情况的区别吗？","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546016,"discussion_content":"你的理解1是对的。相关引用在下面：\n======\nhttps://tc39.es/ecma262/#sec-assignment-operators\n赋值语法是：LeftHandSideExpression = AssignmentExpression\n\nhttps://tc39.es/ecma262/#sec-declarations-and-the-variable-statement\n声明语法是：BindingIdentifier Initializer\n其中初始器（Initializer）语法是：“= AssignmentExpression”\n也就是说初始器是一个语法结构，其中“=”号是一个语法组件；而赋值中的“=”号是一个运算符。\n======\n\n关于第二个问题其实很简单，例如“obj.x = 1”，其中左侧就是一个表达式啊，所以向左侧表达式赋值，有什么奇怪的么？\n\n至于 “修正什么样的错误理解”的问题。比如说，标识符就是静态语法分析期能理解的，因为“声明语句（语法）”中的标识会就可以导出。——导入与导出都是静态语法可分析的。\n\n拿这个来举个例子。\n\n“var a = 1”这个语法要求“a”是标识符，而不能是表达式，对吧？\n正是因此，\nexport var a = 1是成立的；而export &#34;obj.x = 1”就不成立。因为obj.x是表达式。\n\n反之，如果模糊掉上面的差异，非要认为“var a”中的a是一个表达式，那么“export var obj.x = 1”就必须成立。\n\n更进一步的，如果说“标识符”与“表达式”没有差异，那么下面两个语法也就没差异：\nexport a; // 例1。成立\nexport obj.x; // 例2。既然没差异，那么也要成立吗？\n\n这显然是不对的。——所以现实是，我们不能导出一个表达式，也就上述例2不成立。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642130268,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":1390088,"avatar":"https://static001.geekbang.org/account/avatar/00/15/36/08/c77d8a5a.jpg","nickname":"Kids See Ghost","note":"","ucode":"DA57BB8327BB01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":546161,"discussion_content":"感谢您的回复。请问您在举表达式的例子的时候为什么要用`obj.x`\n我的理解是\n`a = 1` 中的a也是表达式\n我疑惑的一点是，按照这节课里讲的\nvar/let/const a = 1 中的a是identifier\na = 1 中的a是表达式\n\n所以说identifier和表达式都可以被赋值吗？表达式会被evaluate成一个具体的值，向表达式赋值不变成了向一个值赋值，这样感觉说不通啊：\nlet a = 1\na = 2 // 这里我们向a赋值\n`a = 2` 把表达式a替换成它的值不就变成了 1 = 2， 这样感觉说不太通。我的理解可能还是有问题，希望老师能够指导一下。\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1642184009,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":546016,"ip_address":""},"score":546161,"extra":""},{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1390088,"avatar":"https://static001.geekbang.org/account/avatar/00/15/36/08/c77d8a5a.jpg","nickname":"Kids See Ghost","note":"","ucode":"DA57BB8327BB01","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546426,"discussion_content":"所以表达式的结果（Result）要考虑手性，当它作为lhs，就可以赋值，当它作为rhs，就会被取值。obj.x的结果作为lhs，就是obj.x = 1；obj.x的结果作为rhs，就是f(obj.x)。手性与具体的运算符是有关的~~ 再说明一下，表达式被赋值并没有什么不可以，因为原则上来说，是“表达式的运算结果Result”在被赋值，而“结果（Result）”被理解成什么，是由后续运算——例如赋值运算符来决定的。\n\n又，补充说一点。后台不会把你的回复推给我，所以通常读者的回复我很少二次回的，因为看不到（除非我一个个地查）。但如果你是新开一个主题，那我就第一时间看到了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642309927,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":546161,"ip_address":""},"score":546426,"extra":""}]}]},{"had_liked":false,"id":319155,"user_name":"sugar","can_delete":false,"product_type":"c1","uid":1167046,"ip_address":"","ucode":"454538FF253B5F","user_header":"https://static001.geekbang.org/account/avatar/00/11/ce/c6/958212b5.jpg","comment_is_top":false,"comment_ctime":1635645243,"is_pvip":false,"replies":[{"id":"115710","content":"是。解构赋值中，左侧的这个语法元素就叫做赋值模板。<br>","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1635669664,"ip_address":"","comment_id":319155,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1635645243","product_id":100039701,"comment_content":"请问：文中提到的es6的赋值模板，是指解构赋值吗？ 比如 const obj = { a : 123}; const { a } = obj;","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529523,"discussion_content":"是。解构赋值中，左侧的这个语法元素就叫做赋值模板。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635669664,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":302078,"user_name":"肖海涛","can_delete":false,"product_type":"c1","uid":1892268,"ip_address":"","ucode":"5E4C20D5A69BEC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM6fGV3BcHQHyNibzRhsPr6KqYzOtMF8G9fiaNvYUavdlhdqMugcHWggWGBbIibkYTibIXramEXsvg4aXA/132","comment_is_top":false,"comment_ctime":1626071771,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1626071771","product_id":100039701,"comment_content":"var a = {n:1}, old = a;<br>a.x = a = {n:2}<br><br>--------------------------------------<br>a.x = a = {n:2} <br>等价于<br>a.x = (a = {n:2})<br><br>计算步骤：<br>1. getValue(evaluate(&#39;a.x&#39;)) \t\t\t\t\t&#47;&#47;a-&gt;{n:1}  a.x-&gt;undefind<br>2. getValue(evaluate(&#39;a={n:2}&#39;) \t\t\t\t<br>\t2.1 getValue(evaluate(&#39;a&#39;))\t\t\t\t\t&#47;&#47;a-&gt;{n:1}  a.x-&gt;undefind<br>\t2.2 getValue(evaluate(&#39;{n:2}&#39;))\t\t\t\t&#47;&#47;a-&gt;{n:1}  a.x-&gt;undefind<br>\t2.3 PutValue(Result(2.1), Result(2.2))\t\t&#47;&#47;a-&gt;{n:2}  a指向新对象<br>\t2.4 Return Result(2.3)\t\t\t\t\t\t&#47;&#47;Return {n:2}<br>3. PutValue(Result(1), Result(2))\t\t\t\t&#47;&#47;把第2步的结果赋值给原来的a.x，即把{n:2}赋值给old.x。此时a.x-&gt;undefind, old.x-&gt;{n:2}<br><br>重点：<br>1、表达式从左向右计算。<br>2、计算a.x=...这个赋值表达式时，把右侧所有内容看成表达式右操作数，这些内容被看作一个整体。<br>3、a={n:2}，这个赋值表达式有两个作用，第一，改变了a的值，第二，返回一个计算结果{n:2}。","like_count":0},{"had_liked":false,"id":292893,"user_name":"边城浪子","can_delete":false,"product_type":"c1","uid":1638358,"ip_address":"","ucode":"CE23DB5D185C25","user_header":"https://static001.geekbang.org/account/avatar/00/18/ff/d6/93a97d02.jpg","comment_is_top":false,"comment_ctime":1621058128,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621058128","product_id":100039701,"comment_content":"我以前理解这个题目是  int* a = 0b00 0001 (假设是这样一个地址取名：地址1)  int a.x = 0b00 0001 + 0b00 0001 (这块地址中的值取名地址2)  a.x = a = { n = 1} ===&gt; a = 0b00 0111(另外一块地址 地址3)    然后  地址2 存放 地址3  <br>","like_count":0},{"had_liked":false,"id":273867,"user_name":"修亦然","can_delete":false,"product_type":"c1","uid":1297494,"ip_address":"","ucode":"5B18DCEF1FF80B","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/56/9f5f9abd.jpg","comment_is_top":false,"comment_ctime":1610700329,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1610700329","product_id":100039701,"comment_content":"理清赋值的顺序<br>1. 先计算单个表达式的值, 注意值的指向<br>2. 再进行赋值操作,<br>var a = {n: 1}; var b = a<br>a.x = a = {n: 2};<br><br>&#47;&#47; 右结合<br>a.x = (a = {n: 2})<br>&#47;&#47; 计算 ref-1 初始指针, ref-2 新指针<br>[[a-ref1]].x = ([[a-ref1]] = {n: 2})<br>&#47;&#47; 赋值<br>([[a-ref1]] = {n: 2}) =&gt; [[a-ref2]] &#47;&#47; a 指向改变<br>[[a-ref1]].x = {n: 2}<br>&#47;&#47; 结果<br>a = [[a-ref2]]<br>b = [[a-ref1]]<br><br><br>不要使用连等","like_count":0},{"had_liked":false,"id":273866,"user_name":"修亦然","can_delete":false,"product_type":"c1","uid":1297494,"ip_address":"","ucode":"5B18DCEF1FF80B","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/56/9f5f9abd.jpg","comment_is_top":false,"comment_ctime":1610699949,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1610699949","product_id":100039701,"comment_content":"赋值的顺序<br>1. 计算表达式的值<br>2. 进行赋值操作","like_count":0},{"had_liked":false,"id":260085,"user_name":"油菜","can_delete":false,"product_type":"c1","uid":2263588,"ip_address":"","ucode":"DB3334BC1720F1","user_header":"","comment_is_top":false,"comment_ctime":1604922028,"is_pvip":false,"replies":[{"id":"94499","content":"<br>参见下例：<br>```<br>a = {<br>  set x() {<br>    console.log(&amp;#39;某种执行效果&amp;#39;);<br>  }<br>}<br><br>&#47;&#47; ......置值的行为...可能存在...某种执行效果<br>a.x = 100;<br><br>&#47;&#47; 这件事（置值行为，或其导致的执行效果）与.....是否被覆盖或丢弃无关<br>a = 100;<br>```","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1604973528,"ip_address":"","comment_id":260085,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1604922028","product_id":100039701,"comment_content":"老师，“由于 JavaScript 中支持属性读写器，因此向“a.x”置值的行为总是可能存在“某种执行效果”，而与“a”对象是否被覆盖或丢弃无关。”  这段话，不太理解<br>","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509103,"discussion_content":"\n参见下例：\n```\na = {\n  set x() {\n    console.log(&amp;amp;#39;某种执行效果&amp;amp;#39;);\n  }\n}\n\n// ......置值的行为...可能存在...某种执行效果\na.x = 100;\n\n// 这件事（置值行为，或其导致的执行效果）与.....是否被覆盖或丢弃无关\na = 100;\n```","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604973528,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":251921,"user_name":"二二","can_delete":false,"product_type":"c1","uid":2198765,"ip_address":"","ucode":"D4C43342B42CD3","user_header":"","comment_is_top":false,"comment_ctime":1601974730,"is_pvip":false,"replies":[{"id":"92079","content":"这个确实无法臆测。我不觉得这种写法有什么优势，除文末的那个链表的例子，我也确实想不出来其它的价值。<br><br>这个例子用来学习理解JS的表达式特性就好了，不建议实用。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1601997171,"ip_address":"","comment_id":251921,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1601974730","product_id":100039701,"comment_content":"老师您好，如果没有jQuery的例子的话，我会觉得这就是一个单纯的js执行语句的分析。还是有实际意义的，我想问一下：<br>jQuery为什么一定要使用那种写法？貌似就算正常按逻辑赋值，也可以达到一样的效果吧。<br>这样的写法有什么明显的优势吗？","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506662,"discussion_content":"这个确实无法臆测。我不觉得这种写法有什么优势，除文末的那个链表的例子，我也确实想不出来其它的价值。\n\n这个例子用来学习理解JS的表达式特性就好了，不建议实用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601997171,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":242652,"user_name":"青山入我怀","can_delete":false,"product_type":"c1","uid":2129828,"ip_address":"","ucode":"0A712556F4D7A3","user_header":"https://static001.geekbang.org/account/avatar/00/20/7f/a4/34955365.jpg","comment_is_top":false,"comment_ctime":1597805218,"is_pvip":false,"replies":[{"id":"89601","content":"往后看。过了第六讲会有这方面的讨论","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1597969703,"ip_address":"","comment_id":242652,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1597805218","product_id":100039701,"comment_content":"请问getValue得到的是什么呀，为什么表达式右侧表达式计算结果通过getValue就可以赋值给一个引用？ 值赋给引用？是什么意思呢","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504065,"discussion_content":"往后看。过了第六讲会有这方面的讨论","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597969703,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203186,"user_name":"🐒🐱🐭🐮🐯🐰🐶","can_delete":false,"product_type":"c1","uid":1189080,"ip_address":"","ucode":"52426AE36A9A39","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/d8/aa41d743.jpg","comment_is_top":false,"comment_ctime":1586151688,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586151688","product_id":100039701,"comment_content":"可以这样理解：从左往右<br>var a = {n:1};<br>a.x = a = {n:2};<br>1 -----------------<br>a.x =  a    得到结果  a = {n:1};    a.x={n:1}; <br>也就是a所引用得内容变为了 a={<br>     n:1,<br>     x:{<br>       n:1,<br>     }<br>}<br><br>2=======<br>此时得a指向得内容又被<br>a= {n:2}; 给替换掉了，此时得a只想得内容是{n:2}；<br>3=======<br>而a = {n:2}  里面并不存在  x的属性","like_count":0},{"had_liked":false,"id":190415,"user_name":"陈娟","can_delete":false,"product_type":"c1","uid":1909623,"ip_address":"","ucode":"E4452292BDB871","user_header":"","comment_is_top":false,"comment_ctime":1584641954,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584641954","product_id":100039701,"comment_content":"第一遍没听懂，听了第二遍突破口是c.a是表达式，首先先计算这几个表达式的值，则c.a中c的引用已经固定，第一次c的引用改变了，而c.a中c的引用不会随着改变","like_count":0},{"had_liked":false,"id":182860,"user_name":"心平气和的韩丽媛","can_delete":false,"product_type":"c1","uid":1177510,"ip_address":"","ucode":"ADB7DB7383EA4A","user_header":"https://static001.geekbang.org/account/avatar/00/11/f7/a6/0b590c34.jpg","comment_is_top":false,"comment_ctime":1582877771,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582877771","product_id":100039701,"comment_content":"看完了脑子乱糟糟的，看完留言清晰了","like_count":0},{"had_liked":false,"id":170663,"user_name":"夜行观星","can_delete":false,"product_type":"c1","uid":1010389,"ip_address":"","ucode":"C880CB39033929","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6a/d5/73c75eb3.jpg","comment_is_top":false,"comment_ctime":1578657032,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578657032","product_id":100039701,"comment_content":"看到留言反馈，跟我预想的一样，讲语言绕过编译相关的知识是在难讲，第二节和第三节不理解，就容易混淆。其实上面的内容拿JS的 EBNF 语法，对应着生成AST，逐步讲解会不会更好呢？突然冒出来一两句EBNF让人很突兀。","like_count":0},{"had_liked":false,"id":166395,"user_name":"情诗和你","can_delete":false,"product_type":"c1","uid":1607858,"ip_address":"","ucode":"2614726BA9D619","user_header":"https://static001.geekbang.org/account/avatar/00/18/88/b2/b323a8c1.jpg","comment_is_top":false,"comment_ctime":1577441144,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577441144","product_id":100039701,"comment_content":"python 也是类似的诶，这个很有趣","like_count":0},{"had_liked":false,"id":155459,"user_name":"南墙的树","can_delete":false,"product_type":"c1","uid":1384130,"ip_address":"","ucode":"289B98CA489C09","user_header":"https://static001.geekbang.org/account/avatar/00/15/1e/c2/edf5dfcb.jpg","comment_is_top":false,"comment_ctime":1574690820,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574690820","product_id":100039701,"comment_content":"看不懂，多看几遍","like_count":0},{"had_liked":false,"id":151855,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1573800110,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1573800110","product_id":100039701,"comment_content":"1. delete返回true 可以删除<br>2.会先计算表达式(0, eval)<br>3.没懂<br>4.obj={} 是一个表达式，返回的是{}这个值，所以with还是在全局上下文，x会被赋值为window的属性","like_count":0,"discussions":[{"author":{"id":1233975,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d4/37/528a43e7.jpg","nickname":"Elmer","note":"","ucode":"61FC9CE0BA5BC1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72889,"discussion_content":"第四点解释的不对，虽然返回的值，但仍是一个引用，这里没赋值上是因为{}里面没有x 可以试一下with(obj = {y: 1}) {y = 100}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575540378,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}