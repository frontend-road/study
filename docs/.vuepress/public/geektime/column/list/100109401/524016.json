{"id":524016,"title":"38｜RESTful Web Services（2）：根据Spike的结果，要如何调整架构愿景？","content":"<p>你好，我是徐昊。今天我们继续使用TDD的方式实现RESTful Web Services。</p><p>在上节课，我们通过Spike实现了一个非常简略的版本，可以通过Root Resource以及对应的方法处理请求，并使用MessageBodyWriter扩展点，将内容写入Http响应中。代码如下：</p><pre><code>static class ResourceServlet extends HttpServlet {\n\n    private Application application;\n    \n    private Providers providers;\n    \n    public ResourceServlet(Application application, Providers providers) {\n        this.application = application;\n        this.providers = providers;\n    }\n    \n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        Stream&lt;Class&lt;?&gt;&gt; rootResources = application.getClasses().stream().filter(c -&gt; c.isAnnotationPresent(Path.class));\n        Object result = dispatch(req, rootResources);\n        MessageBodyWriter&lt;Object&gt; writer = (MessageBodyWriter&lt;Object&gt;) providers.getMessageBodyWriter(result.getClass(), null, null, null);\n        writer.writeTo(result, null, null, null, null, null, resp.getOutputStream());\n    }\n    \n    Object dispatch(HttpServletRequest req, Stream&lt;Class&lt;?&gt;&gt; rootResources) {\n        try {\n            Class&lt;?&gt; rootClass = rootResources.findFirst().get();\n            Object rootResource = rootClass.getConstructor().newInstance();\n            Method method = Arrays.stream(rootClass.getMethods()).filter(m -&gt; m.isAnnotationPresent(GET.class)).findFirst().get();\n            return method.invoke(rootResource);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n</code></pre><p>在这个Spike的基础上，我们可以进一步细化架构的愿景：</p><p><img src=\"https://static001.geekbang.org/resource/image/16/e1/165d9ce2d5223bf6498b9c1ceffa71e1.jpg?wh=8000x4500\" alt=\"\"></p><p>通过结合JAX-RS的Application和Providers，我们大致清楚了ResourceServlet如何使用Application和Providers，以及大致在什么地方需要使用依赖注入容器。</p><p>说到依赖注入，在JAX-RS中存在两种依赖注入：对于Application Scope的Inject注入，以及对于Request Scope的Context注入。这仍然是不太清晰的部分，我们需要进一步Spike：</p><p><video poster=\"https://media001.geekbang.org/d29799ac35dd4b23b9970d9024035d1d/snapshots/e30ab08ae657497b999c58519eca83de-00005.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/59a45f88-181373067c8-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/b3eb6cfe9b6942f6bdd48c190153015e/b085a0a2b2674742aa682d3f42612f6c-5407b06f06327959ef0feabec17a10e4-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><h2>思考题</h2><p>根据Spike的结果，接下来要如何进一步调整架构愿景？</p><p>欢迎把你的想法分享在留言区，也欢迎把你的项目代码分享出来。相信经过你的思考与实操，学习效果会更好！</p><!-- [[[read_end]]] -->","neighbors":{"left":{"article_title":"37｜RESTful Web Services（1）：明确架构愿景与架构组件间的交互","id":522346},"right":{"article_title":"39｜RESTful Web Services（3）：明确架构愿景与调用栈顺序","id":524018}},"comments":[{"had_liked":false,"id":348846,"user_name":"张铁林","can_delete":false,"product_type":"c1","uid":1108258,"ip_address":"","ucode":"4AB8BC6CDAC0A3","user_header":"https://static001.geekbang.org/account/avatar/00/10/e9/22/7606c6ba.jpg","comment_is_top":false,"comment_ctime":1655453821,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100109401,"comment_content":"我再贡献一个情况，之前di-container项目没有加任何包名，就是放在java下面，在融合后，默认找不到ContextCofnig，给di-container加一个包名后，就能引入了。","like_count":2},{"had_liked":false,"id":348255,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1654878182,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100109401,"comment_content":"问题一：gradle 如何引入子模块\n答：implementation(project(&#39;:container&#39;))。参考专栏 《程序员的测试课》| 01 | 实战：实现一个 ToDo 的应用（上）中的项目 https:&#47;&#47;github.com&#47;dreamhead&#47;geektime-todo。在 GitHub 中打开后按.(句号)可以切换到在线 VsCode，方便查阅代码\n\n问题二：之前 di-container 中没有这个方法 config.component(wirteClass, wirteClass) （视频 03:53）也没有之后出现的 config.from 方法。\n答：35课，老师对代码做了重构，只贴了代码，没有视频。（感谢完美的红国王解答）","like_count":2},{"had_liked":false,"id":348860,"user_name":"张铁林","can_delete":false,"product_type":"c1","uid":1108258,"ip_address":"","ucode":"4AB8BC6CDAC0A3","user_header":"https://static001.geekbang.org/account/avatar/00/10/e9/22/7606c6ba.jpg","comment_is_top":false,"comment_ctime":1655470683,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100109401,"comment_content":"https:&#47;&#47;github.com&#47;vfbiby&#47;tdd-restful\n把之前的代码移到restful子模块，再引用了前面一个兄弟的di container作为git submodule，直接完成了这一节，手册也在里面了。多次提交，如果不会子模块的，可以参考一下。","like_count":1}]}