{"id":225869,"title":"10 | 索引拆分：大规模检索系统如何使用分布式技术加速检索？","content":"<p>你好，我是陈东。</p><p>在互联网行业中，分布式系统是一个非常重要的技术方向。我们熟悉的搜索引擎、广告引擎和推荐引擎，这些大规模的检索系统都采用了分布式技术。</p><p>分布式技术有什么优点呢？<strong>分布式技术就是将大任务分解成多个子任务，使用多台服务器共同承担任务，让整体系统的服务能力相比于单机系统得到了大幅提升</strong>。而且，在<a href=\"https://time.geekbang.org/column/article/222810\">第8讲</a>中我们就讲过，在索引构建的时候，我们可以使用分布式技术来提升索引构建的效率。</p><p>那今天，我们就来聊一聊，大规模检索系统中是如何使用分布式技术来加速检索的。</p><h2>简单的分布式结构是什么样的？</h2><p>一个完备的分布式系统会有复杂的服务管理机制，包括服务注册、服务发现、负载均衡、流量控制、远程调用和冗余备份等。在这里，我们先抛开分布式系统的实现细节，回归到它的本质，也就是从“让多台服务器共同承担任务”入手，来看一个简单的分布式检索系统是怎样工作的。</p><p>首先，我们需要一台接收请求的服务器，但是该服务器并不执行具体的查询工作，它只负责任务分发，我们把它叫作<strong>分发服务器</strong>。真正执行检索任务的是<strong>多台索引服务器</strong>，每台索引服务器上都保存着完整的倒排索引，它们都能完成检索的工作。</p><p>当分发服务器接到请求时，它会根据负载均衡机制，将当前查询请求发给某台较为空闲的索引服务器进行查询。具体的检索工作由该台索引服务器独立完成，并返回结果。<br>\n<img src=\"https://static001.geekbang.org/resource/image/5b/df/5ba0f02fc5607409831cc0256a62eedf.jpg?wh=1920*775\" alt=\"\"></p><!-- [[[read_end]]] --><center><span class=\"reference\">简单的分布式检索系统</span></center><p>现在，分布式检索系统的结构你已经知道了，那它的效率怎么样呢？举个例子，如果一台索引服务器一秒钟能处理1000条请求，那我们同时使用10台索引服务器，整个系统一秒钟就能处理10000条请求了。也就是说，这样简单的分布式系统，就能大幅提升整个检索系统的处理能力。</p><p>但是，这种简单的分布式系统有一个问题：它仅能提升检索系统整体的“吞吐量”，而不能缩短一个查询的检索时间。也就是说，如果单机处理一个查询请求的耗时是1秒钟，那不管我们增加了多少台机器，单次查询的检索时间依然是1秒钟。所以，如果我们想要缩短检索时间，这样的分布式系统是无法发挥作用的。</p><p>那么，我们能否利用多台机器，来提升单次检索的效率呢？我们先来回顾一下，在前面讨论工业级的倒排索引时我们说过，对于存储在磁盘上的大规模索引数据，我们要尽可能地将数据加载到内存中，以此来减少磁盘访问次数，从而提升检索效率。</p><p>根据这个思路，当多台服务器的总内存量远远大于单机的内存时，我们可以把倒排索引拆分开，分散加载到每台服务器的内存中。这样，我们就可以避免或者减少磁盘访问，从而提升单次检索的效率了。</p><p>即使原来的索引都能加载到内存中，索引拆分依然可以帮助我们提升单次检索的效率。这是因为，检索时间和数据规模是正相关的。当索引拆分以后，每台服务器上加载的数据都会比全量数据少，那每台服务器上的单次查询所消耗的时间也就随之减少了。</p><p>因此，索引拆分是检索加速的一个重要优化方案，至于索引应该如何拆分，以及拆分后该如何检索，工业界也有很多不同的实现方法。你可以先自己想一想，然后我们再一起来看看，工业界一般都是怎么做的。</p><h2>如何进行业务拆分？</h2><p>首先，在工业界中一个最直接的索引拆分思路，是根据业务进行索引拆分。那具体该如何拆分呢？</p><p>我来举个例子。在图书管理系统中，有许多不同国籍的作家的作品。如果我们将它们分成国内作品和国外作品两大类，分别建立两个倒排索引，这就完成了索引拆分。索引拆分之后，我们可以使用不同的服务器加载不同的索引。在检索的时候，我们需要先判断检索的是国内作品还是国外作品，然后在检索界面上做好选择，这样系统就可以只在一个索引上查询了。如果我们不能确认是哪类作品，那也没关系，系统可以在两个索引中并行查找，然后将结果汇总。</p><p>你会看到，基于业务的拆分是一个实用的索引拆分方案，在许多应用场景中都可以使用。但是这种方案和业务的耦合性太强，需要根据不同的业务需求灵活调整。那我们有没有更通用的技术解决方案呢？你可以先想一下，然后我们一起来讨论。</p><h2>如何基于文档进行拆分？</h2><p>以搜索引擎为例，一个通用的方案是借鉴索引构建的拆分思路，将大规模文档集合随机划分为多个小规模的文档集合分别处理。这样我们就可以基于文档进行拆分，建立起多个倒排索引了。其中，每个倒排索引都是一个索引分片，它们分别由不同的索引服务器负责。每个索引分片只包含部分文档，所以它们的posting list都不会太长，这样单机的检索效率也就得到了提升。</p><p><img src=\"https://static001.geekbang.org/resource/image/ee/39/eec1b7de0974b1d0ac62b8b043504439.jpg?wh=1920*925\" alt=\"\"></p><center><span class=\"reference\">基于文档拆分索引</span></center><p>但是，这样拆分出来的任意一个单独的索引分片，它检索出来的结果都不完整，我们还需要合并操作才能得到最后的检索结果。因此，对于基于文档进行拆分的分布式方案，我们的检索流程可以总结为3个步骤：</p><ol>\n<li>分发服务器接受查询请求，将请求发送给所有不同索引分片的索引服务器；</li>\n<li>每台索引服务器根据自己加载的索引分片进行检索，将查询结果返回分发服务器；</li>\n<li>分发服务器将所有返回的结果进行合并处理，再返回最终结果。</li>\n</ol><p><img src=\"https://static001.geekbang.org/resource/image/2d/c0/2d98f7658d29f1d6cef4a21af7238fc0.jpeg?wh=1920*1080\" alt=\"\"></p><center><span class=\"reference\">基于文档拆分索引的检索过程</span></center><p>这种基于文档拆分的方案是随机划分的，所以我们可以不用关心业务细节。而且每个索引分片的大小都能足够相近，因此，这种拆分方式能很均匀地划分检索空间和分担检索负载。并且，如果我们将索引数据分成合适的份数，是有可能将所有数据都加载到内存中的。由于每个索引分片中的文档列表都不长，因此每台机器对于单个请求都能在更短的时间内返回，从而加速了检索效率。</p><p>但是，分片的数量也不宜过多。这是因为，一个查询请求会被复制到所有的索引分片上，如果分片过多的话，每台加载索引分片的服务器都要返回n个检索结果，这会带来成倍的网络传输开销。而且，分片越多，分发服务器需要合并的工作量也会越大，这会使得分发服务器成为瓶颈，造成性能下降。因此，对于索引分片数量，我们需要考虑系统的实际情况进行合理的设置。</p><h2>如何基于关键词进行拆分？</h2><p>在搜索引擎中，为了解决分片过多导致一次请求被复制成多次的问题，我们还可以使用另一种拆分方案，那就是基于关键词进行拆分。这种方案将词典划分成多个分片，分别加载到不同的索引服务器上。每台索引服务器上的词典都是不完整的，但是词典中关键词对应的文档列表都是完整的。</p><p><img src=\"https://static001.geekbang.org/resource/image/d8/3a/d8ef8131d943d4ed7b812dd30e51ba3a.jpg?wh=1920*1012\" alt=\"\"></p><center><span class=\"reference\">基于关键词拆分索引</span></center><p>当用户查询时，如果只有一个关键词，那我们只需要查询存有这个关键词的一台索引服务器，就能得到完整的文档列表，而不需要给所有的索引服务器都发送请求；当用户同时查询两个关键词时，如果这两个关键词也同时属于一个索引分片的话，那系统依然只需要查询一台索引服务器即可。如果分别属于两个分片，那我们就需要发起两次查询，再由分发服务器进行结果合并。</p><p><img src=\"https://static001.geekbang.org/resource/image/d3/1b/d38afa0d9b400798fd30a9c0e147e91b.jpg?wh=1920*825\" alt=\"\"></p><center><span class=\"reference\">基于关键词拆分索引的检索过程</span></center><p>也就是说，在查询词少的情况下，如果能合理分片，我们就可以大幅降低请求复制的代价了。</p><p>但是这种切分方案也带来了很多复杂的管理问题，比如，如果查询词很多并且没有被划分到同一个分片中，那么请求依然会被多次复制。再比如，以及如果有的关键词是高频词，那么对应的文档列表会非常长，检索性能也会急剧下降。此外，还有新增文档的索引修改问题，系统热点查询负载均衡的问题等。</p><p>因此，除了少数的高性能检索场景有需求以外，一般我们还是基于文档进行索引拆分。这样，系统的扩展性和可运维性都会更好。</p><h2>重点回顾</h2><p>好了，今天的内容就先讲到这里。我们一起来总结一下，你要掌握的重点内容。</p><p>首先，利用分布式技术，我们可以将倒排索引进行索引拆分。索引拆分的好处是：一方面是能将更多的索引数据加载到内存中，降低磁盘访问次数，使得检索效率能得到大幅度的提升；另一方面是基于文档的拆分，能将一个查询请求复制成多份，由多台索引服务器并行完成，单次检索的时间也能得到缩短。</p><p>其次，除了搜索引擎，其他大规模数据检索引擎，如广告引擎、推荐引擎等也都使用了类似的索引拆分技术。只是由于它们处理的对象不是文档，因此对于拆分方式的命名也不同。</p><p>一般来说，根据处理对象将倒排索引进行拆分，每个索引分片都可能有完整的词典，但posting list不完整，这种拆分方案叫作<strong>水平拆分</strong>。如果是根据倒排索引中的关键词进行拆分，每个索引分片的词典都不完整，但是词典中的关键词对应的posting list是完整的，这种拆分方案叫作<strong>垂直拆分</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/56/9e/56dfa700a087ea1984a7fcda8a6d409e.jpg?wh=1920*839\" alt=\"\"></p><center><span class=\"reference\">水平拆分和垂直拆分</span></center><p>总之，<strong>合理的索引拆分是分布式检索加速的重要手段，也是工业界的有效实践经验</strong>。因此，我希望你能好好地理解今天的内容。</p><h2>课堂讨论</h2><p>为什么说基于文档拆分的方案会比基于关键词拆分的方案更好维护？你可以结合以下2个问题来考虑一下：</p><ol>\n<li>当有新文档加入时，会影响多少台索引服务器？</li>\n<li>当某些关键词是热点，会被大量查询时，每台服务器的负载是否均衡？</li>\n</ol><p>欢迎在留言区畅所欲言，说出你的思考过程和最终答案。如果有收获，也欢迎把这篇文章分享给你的朋友。</p>","neighbors":{"left":{"article_title":"09 | 索引更新：刚发布的文章就能被搜到，这是怎么做到的？","id":222807},"right":{"article_title":"11｜精准Top K检索：搜索结果是怎么进行打分排序的？","id":226100}},"comments":[{"had_liked":false,"id":210000,"user_name":"无形","can_delete":false,"product_type":"c1","uid":1016889,"ip_address":"","ucode":"B740E2A68A17A5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/84/39/c8772466.jpg","comment_is_top":false,"comment_ctime":1587650120,"is_pvip":true,"replies":[{"id":78306,"content":"回答和总结得很仔细。\n关于基于关键词拆分，能否特殊处理热点的问题，当然是可以的。如果查询热点一直比较稳定的话，我们可以通过加缓存，加副本，升级机器等方案来优化。不过一般来说，升级机器这种方案用得比较少，因为这涉及到更多的运维团队的工作，不如增加查询缓存，或者增加副本机器等机器调度方案便捷。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1587651927,"ip_address":"","comment_id":210000,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"先来回答老师的问题，基于文档拆分的方案，1，新增数据会落到某个具体的服务器，不需要考虑数据在所有检索服务器之间同步、不一致的问题，2，由于所有的检索服务器之间数据是均衡分布的，不存在服务器之间检索负载不均衡的问题\n\n索引水平拆分垂直拆分和数据库的水平拆分和垂直拆分是类似的\n我理解文档拆分是把数据对一个整体进行分片，对整体的查询变成了并行在分片上查询，缩短了查询时间，还有一个好处是新的文档被哈希到到某个分片上，对查询结果的影响被限定到这个具体的分片，不会影响所有分片\n关键词拆分也是把整体分片，对整体的查询变成了在单个分片上的查询，如果有热点数据会导致posting list过大，降低查询效率，这里能不能特殊处理，给热点数据指定专门的更高性能检索服务器，提升查询效率","like_count":4},{"had_liked":false,"id":207619,"user_name":"奕","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1587120247,"is_pvip":false,"replies":[{"id":77532,"content":"你举的这个例子很有意思。其实Redis cluster是一个kv存储，而不是一个倒排索引。对于kv，你既可以说它是按关键词拆分的，也可以说是按文档拆分的。\n\n当然，如果kv中的v是一个结果集合列表的话，这就是一个典型的基于关键词拆分的倒排索引了。在我们不需要进行多个关键词合并的场景下，这样的使用方案是很适合的。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1587124111,"ip_address":"","comment_id":207619,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"Redis Cluster 技术相当于按照关键词进行拆分，直接定位到 要查询的 key 在哪个 slot","like_count":3,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492184,"discussion_content":"你举的这个例子很有意思。其实Redis cluster是一个kv存储，而不是一个倒排索引。对于kv，你既可以说它是按关键词拆分的，也可以说是按文档拆分的。\n\n当然，如果kv中的v是一个结果集合列表的话，这就是一个典型的基于关键词拆分的倒排索引了。在我们不需要进行多个关键词合并的场景下，这样的使用方案是很适合的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587124111,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"奕","note":"","ucode":"73CEA468CE70C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":236868,"discussion_content":"哈哈，我想这个例子的时候也考虑也是基于文档拆分了，但是感觉基于基于key更合适些，对于整体来说某些key分到一个分片上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587128035,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207389,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1587080299,"is_pvip":false,"replies":[{"id":77450,"content":"总结得很好。我觉得可以给你补两个问题。有精力的童鞋也都可以想想。\n1.如果索引是使用“全量索引+增量索引”，再基于文档拆分，那么一个新文档加入时，它是会加入到所有索引服务器的增量索引中，还是可以只加入到一台服务器的增量索引中？\n2.基于文档拆分，会造成查询请求被复制多份，那除了基于关键词拆分，我们使用业务拆分的方案是否也能避免这个问题?","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1587082307,"ip_address":"","comment_id":207389,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"# 提高的吞吐量而非检索效率\n简单的分布式检索系统是指每台索引服务器保存了全量的索引数据，然后加机器，这种方式只能提高系统整体的&quot;吞吐量&quot;，而不能缩短检索时间从而加速检索效率\n\n# 通过拆分提高检索效率\n检索时间与数据规模正相关，所以采用索引拆分可以加入检索效率\n\n# 如何拆分？\n## 基于文档拆分\n核心思想是把大规模的文档集合随机拆分成多个小规模文档集合，即建了多个倒排索引，但每个倒排索引就是一个索引分片，保存了部分数据，所以它的 postinglist 不会太长，可以提升单机的检索效率\n\n## 基于文档拆分的检索流程\n- 分发服务器接受查询请求，然后将请求分发给其他索引服务器\n- 每台服务器根据自己加载的索引分片数据进行检索，再把结果返回给分发服务器\n- 分发服务器将所有返回结果进行合并，返回给客户端\n\n## 基于文档拆分的优缺点\n优点\n1.基于随机划分，每个索引分片大小相近，在索引空间分配上是相对均衡的，而且每台索引服务器的负载也相对均衡\n2.通过设置合理的分片数，有可能把所有数据加载到内存中，同时因为每个索引分片数据不大，可以提升检索效率\n\n不足\n分片数不能设置太大\n因为客户端发过来的请求是先经过分发服务器的，然后转发给其他索引分片服务器，如果分片数过多，会设计很多网络 IO 操作，性能就会下降\n\n## 基于关键词拆分\n通过关键词进行拆分是将不同的关键词放到不同的索引分片上，然后加载到不同的服务器上，这样的拆分方式可以达到每台索引服务器上的文档不是完整的，但关键词对应的列表是完整的\n\n## 基于关键词拆分的检索流程\n客户端发来请求，如果只有一个关键词，那只需要查询改关键词所在的索引服务器就可以得到完整的文档列表，省去了分发造成的网络 IO\n如果是多个关键词，可能也会发生分发请求，然后分发服务器合并请求返回给客户端\n\n## 基于关键词拆分的优缺点\n优点\n适合查询词少的情况，可以减少分发造成的网络 IO\n\n不足\n1.如果查询词比较多且没有被划分到一个分片中，也会分发请求，有网络 IO\n2.如果关键词是高频热点词，那它对应的文档列表会非常长，检索性能也会下降\n3.高频热点词所在服务器负载高，低频词所在服务器负载低，导致索引服务器负载不均衡\n4.如果有新增文档，会涉及到多台索引服务器修改\n\n# 思考题 \n## 为什么说基于文档拆分比关键词拆分更好维护？\n其实在上面分析两种方案的优缺点时已经介绍了，下面就简单总结下\n- 当有新文档加入时，最糟糕情况会修改所有的索引服务器\n- 遇到高频热点词，大量查询都打到了这个热点词所在的服务器上，导致该服务器负载很高，完成索引服务器的负载不均衡","like_count":3,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492106,"discussion_content":"总结得很好。我觉得可以给你补两个问题。有精力的童鞋也都可以想想。\n1.如果索引是使用“全量索引+增量索引”，再基于文档拆分，那么一个新文档加入时，它是会加入到所有索引服务器的增量索引中，还是可以只加入到一台服务器的增量索引中？\n2.基于文档拆分，会造成查询请求被复制多份，那除了基于关键词拆分，我们使用业务拆分的方案是否也能避免这个问题?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587082307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1056019,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg","nickname":"峰","note":"","ucode":"C53CB64E8E7D19","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":267000,"discussion_content":"回答下老师的问题，（1）采用了文档拆分，每台server就有其对应的文档集合，各自独立，所以只会加入到该台上。（2） 比如说将文档hash到不同server上的规则是融入了业务类型，广告的到server1集合，商店的到server2集合。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589589478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":213132,"user_name":"new life","can_delete":false,"product_type":"c1","uid":1447866,"ip_address":"","ucode":"B817AC3909102B","user_header":"https://static001.geekbang.org/account/avatar/00/16/17/ba/c56aa720.jpg","comment_is_top":false,"comment_ctime":1588309547,"is_pvip":false,"replies":[{"id":79102,"content":"总结得很好。尤其你还提到了分页检索，这的确也是一个难点。基于文档拆分的方式需要解决问题。\n至于思考题，在更新一个文档的时候，如果是基于关键词拆分的话，由于一篇文档中会有多个关键词，这些关键词可能是分布在不同的服务器上的，因此会影响多台服务器。\n至于热点查询问题，如果是基于文档拆分，那么负载会更容易均衡到多台服务器上，避免热点。如果真有热点发生时，也可以灵活地重新分片进行负载均衡。因此会比基于关键词拆分更灵活。\n","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1588318647,"ip_address":"","comment_id":213132,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"按文档划分和按关键词划分，各有利弊\n按文档划分:\n1、一个关键词的所有文档分布在多个服务器上，缩短了每台服务器postlist的长度，提升了单台服务器的检索效率；\n2、但是检索对外时候需要检索多台服务器，合并检索结果，增加了分页检索实现的难度；\n\n按关键词划分\n1、每台服务器上含有这个关键词所有的文档，检索的时候，只要找到对应的服务器，检索一次就行，不用结果合并，分页控制也好实现；\n2、但是一个关键词的文档id列表放一块，提高了每次查询的检索成本，尤其是热点数据的检索时候，总要受不常用数据的拖累\n\n思考题\n\n我理解插入文档的时候，文档拆分和关键词拆分影响的都是一台服务器，热点数据检索的时候，关键词、文档拆分这种方式都是负载是均衡的，这也体现出按文档拆分的优势；","like_count":2,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492106,"discussion_content":"总结得很好。我觉得可以给你补两个问题。有精力的童鞋也都可以想想。\n1.如果索引是使用“全量索引+增量索引”，再基于文档拆分，那么一个新文档加入时，它是会加入到所有索引服务器的增量索引中，还是可以只加入到一台服务器的增量索引中？\n2.基于文档拆分，会造成查询请求被复制多份，那除了基于关键词拆分，我们使用业务拆分的方案是否也能避免这个问题?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587082307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1056019,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg","nickname":"峰","note":"","ucode":"C53CB64E8E7D19","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":267000,"discussion_content":"回答下老师的问题，（1）采用了文档拆分，每台server就有其对应的文档集合，各自独立，所以只会加入到该台上。（2） 比如说将文档hash到不同server上的规则是融入了业务类型，广告的到server1集合，商店的到server2集合。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589589478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216426,"user_name":"paulhaoyi","can_delete":false,"product_type":"c1","uid":1105619,"ip_address":"","ucode":"C972F4B459E7D6","user_header":"https://static001.geekbang.org/account/avatar/00/10/de/d3/2aa0177f.jpg","comment_is_top":false,"comment_ctime":1589257071,"is_pvip":false,"replies":[{"id":80135,"content":"其实对于这种是否存在的过滤问题，第四讲中我提到过，可以使用bloomfilter来进行判断文章是否已读。这样在容量和查询性能上都不错。缺点就是可能会有一定的错误率。不过作为内容分发场景而言，错判的话，只是少分发一个内容而已，应该是可以接受的。\n如果不希望有错误率，那么可以使用加餐1中我提到过的roaring bitmap来进行查找。\n至于你说的用文章ID为key，用户作为posting list的方案，我的理解是这个也是可行的。但是其实它和以用户为key，文章为posting list的方案的存储空间是一样的。你可以画一个矩阵，每一行是一个用户，每一列是一个文章。那么这个矩阵横着就是以用户ID为key，以文章ID为posting list的倒排;竖着就变成了以文章ID为key，以用户ID为posting list的倒排，因此并不会省空间。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1589298220,"ip_address":"","comment_id":216426,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"老师您好，请教一个问题，可能不一定和本章有关。我们做内容分发，需要再召回源拿出内容后，过滤用户读过的文章。由于量比较大，有些用户的阅读历史又很长，单独每个用户记录已读列表，不管是容量还是过滤性能都不太能接受。感觉这就是一个判断是否存在的问题。如果我用文章id做key，用户做的文档。建立倒排合适么？或者老师有什么好的方法建议？","like_count":1,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493689,"discussion_content":"总结得很好。尤其你还提到了分页检索，这的确也是一个难点。基于文档拆分的方式需要解决问题。\n至于思考题，在更新一个文档的时候，如果是基于关键词拆分的话，由于一篇文档中会有多个关键词，这些关键词可能是分布在不同的服务器上的，因此会影响多台服务器。\n至于热点查询问题，如果是基于文档拆分，那么负载会更容易均衡到多台服务器上，避免热点。如果真有热点发生时，也可以灵活地重新分片进行负载均衡。因此会比基于关键词拆分更灵活。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588318647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207515,"user_name":"峰","can_delete":false,"product_type":"c1","uid":1056019,"ip_address":"","ucode":"C53CB64E8E7D19","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg","comment_is_top":false,"comment_ctime":1587098931,"is_pvip":false,"replies":[{"id":77505,"content":"是的。后面抽象成了水平拆分和垂直拆分，其实就和数据库的拆分理念很相似了。包括业务拆分，其实也和分库很相似。因此，许多设计理念都是可以相互借鉴，融会贯通的。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1587102909,"ip_address":"","comment_id":207515,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"本来按照题目写了下答案，但感觉还不如跳出来回答这个问题，看着太像传统数据库横向拆分纵向拆分，然后引入中间件，然后就有手工分库分表那一坨解决方案。跳出这个思路，横向纵向分片只是分散数据到各个节点的手段，上层应该提供策略屏蔽这些手段的差异，针对具体的分片方式做优化，比如热点，那就针对这个分片多点副本。","like_count":1,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494812,"discussion_content":"其实对于这种是否存在的过滤问题，第四讲中我提到过，可以使用bloomfilter来进行判断文章是否已读。这样在容量和查询性能上都不错。缺点就是可能会有一定的错误率。不过作为内容分发场景而言，错判的话，只是少分发一个内容而已，应该是可以接受的。\n如果不希望有错误率，那么可以使用加餐1中我提到过的roaring bitmap来进行查找。\n至于你说的用文章ID为key，用户作为posting list的方案，我的理解是这个也是可行的。但是其实它和以用户为key，文章为posting list的方案的存储空间是一样的。你可以画一个矩阵，每一行是一个用户，每一列是一个文章。那么这个矩阵横着就是以用户ID为key，以文章ID为posting list的倒排;竖着就变成了以文章ID为key，以用户ID为posting list的倒排，因此并不会省空间。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589298220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207480,"user_name":"那时刻","can_delete":false,"product_type":"c1","uid":1150927,"ip_address":"","ucode":"B0D150856C3A4A","user_header":"https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg","comment_is_top":false,"comment_ctime":1587091261,"is_pvip":false,"replies":[{"id":77504,"content":"1.没错。如果使用了全量索引+增量索引机制的话，对于新增文档，其实只需要先分片到对应的索引服务器上，然后加入这台服务器的增量索引即可。\n2.业务拆分尽管和业务耦合紧密，不过它可以同时兼具文档拆分和关键词拆分的优点(也可以理解为，业务拆分可以在两个方向进行抽象，分别变成文档拆分和关键词拆分)。\n业务既能对文档进行分片，也能在查询时指定只去一个分片查询，而不是所有分片都查询。因此在一些简单的应用场合中也是可以考虑的。\n对应到数据库设计，就是分库的问题。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1587102624,"ip_address":"","comment_id":207480,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"尝试回答老师在回复里的问题。不明白的地方请老师指正。\n1.按文档拆分，新增加的文档可以只加到一台增量索引的机器上班，因为查询的时候有按照关键字的合并\n2.我觉得可以按照业务拆分来减少查询的复制，比如按照文档类型 军事，娱乐来把文档分区，这样查询关键字的时候，比如这个关键字属于军事类型就只去军事类型文档分区找就可以了。","like_count":1,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492145,"discussion_content":"1.没错。如果使用了全量索引+增量索引机制的话，对于新增文档，其实只需要先分片到对应的索引服务器上，然后加入这台服务器的增量索引即可。\n2.业务拆分尽管和业务耦合紧密，不过它可以同时兼具文档拆分和关键词拆分的优点(也可以理解为，业务拆分可以在两个方向进行抽象，分别变成文档拆分和关键词拆分)。\n业务既能对文档进行分片，也能在查询时指定只去一个分片查询，而不是所有分片都查询。因此在一些简单的应用场合中也是可以考虑的。\n对应到数据库设计，就是分库的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587102624,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207470,"user_name":"那时刻","can_delete":false,"product_type":"c1","uid":1150927,"ip_address":"","ucode":"B0D150856C3A4A","user_header":"https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg","comment_is_top":false,"comment_ctime":1587090303,"is_pvip":false,"replies":[{"id":77503,"content":"是的。你会看到，数据库的分库分表其实也是一样的思路。因此，也希望大家能将一个技术进行横行对比，这样能更好地融会贯通，举一反三。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1587102231,"ip_address":"","comment_id":207470,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"基于文档或关键字拆分，类似于数据库的分库分表操作。基于文档拆分的好处在于分摊网络和io的压力。","like_count":1,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492141,"discussion_content":"是的。你会看到，数据库的分库分表其实也是一样的思路。因此，也希望大家能将一个技术进行横行对比，这样能更好地融会贯通，举一反三。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587102231,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207431,"user_name":"_你说了不算","can_delete":false,"product_type":"c1","uid":1185159,"ip_address":"","ucode":"212F890565FE5C","user_header":"https://static001.geekbang.org/account/avatar/00/12/15/87/d22d8c3e.jpg","comment_is_top":false,"comment_ctime":1587085645,"is_pvip":false,"replies":[{"id":77501,"content":"1.关于es的使用，的确是要了解了相关检索技术，已经了解了es以后，才能发挥出es的优势。如果你们想走这条路线的话，那需要多花点时间深入了解。\n2.你所谓的内存过滤，我的理解就是你们自研系统，在内存中建立索引处理。那么这样的话，你可以结合这个专栏的内容看看如何优化，比如说索引拆分，你们可以指定一个固定分片数，然后在离线环节就拆分好；然后结合全量索引+增量索引的机制，也能保证索引更新时的性能；还有倒排检索加速(参考两篇加餐)，应该也是有帮助的。\n3.MySQL和es的数据同步问题，其实有许多工具可以做，比如说logstash等。而一致性问题，需要你进行监控和周期性检查，避免有错误。还可以进行周期性完整重建索引的方式，将之前可能已经造成的不一致进行修复。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1587101713,"ip_address":"","comment_id":207431,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"老师，我们的广告投放引擎在数据检索这块就走了不少路，es过滤和内存过滤两种方式都用过，最终还是用了内存过滤，原因是后者服务器的cpu和内存状态更好，不知道是不是我们用es的姿势不对。最近引擎系统cpu一直报警，除了加机器，就是加机器，想请教下老师，有遇到过类似的这种情况吗？假如按照文章中提到的索引拆分的方式，具体的落地方案老师能不能指点一二？还有我们的数据是AE通过管理后台存在mysql的，那么mysql和es的数据一致性怎么处理？希望老师百忙中解答","like_count":1,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492121,"discussion_content":"1.关于es的使用，的确是要了解了相关检索技术，已经了解了es以后，才能发挥出es的优势。如果你们想走这条路线的话，那需要多花点时间深入了解。\n2.你所谓的内存过滤，我的理解就是你们自研系统，在内存中建立索引处理。那么这样的话，你可以结合这个专栏的内容看看如何优化，比如说索引拆分，你们可以指定一个固定分片数，然后在离线环节就拆分好；然后结合全量索引+增量索引的机制，也能保证索引更新时的性能；还有倒排检索加速(参考两篇加餐)，应该也是有帮助的。\n3.MySQL和es的数据同步问题，其实有许多工具可以做，比如说logstash等。而一致性问题，需要你进行监控和周期性检查，避免有错误。还可以进行周期性完整重建索引的方式，将之前可能已经造成的不一致进行修复。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587101713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":283004,"user_name":"Christmas","can_delete":false,"product_type":"c1","uid":1219172,"ip_address":"","ucode":"F48F6BE4A7595B","user_header":"https://static001.geekbang.org/account/avatar/00/12/9a/64/ad837224.jpg","comment_is_top":false,"comment_ctime":1615516338,"is_pvip":false,"replies":[{"id":102779,"content":"业界一般都是按文档拆分的，文中和课后习题里，都解释了原因。毕竟对于大部分应用而言，分片数也不会太多。\n当然，在极端考虑性能的情况下，是可以考虑关键词拆分的。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1615714080,"ip_address":"","comment_id":283004,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"超大规模的数据量的情况下，感觉按照文档切分，会出现性能问题，分发服务器请求的查询服务器会过多，因为一般es也不建议shard数量很大。不知道业界超大规模额情况下，是按照文档切分的吗？","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516906,"discussion_content":"业界一般都是按文档拆分的，文中和课后习题里，都解释了原因。毕竟对于大部分应用而言，分片数也不会太多。\n当然，在极端考虑性能的情况下，是可以考虑关键词拆分的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615714080,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":210000,"user_name":"无形","can_delete":false,"product_type":"c1","uid":1016889,"ip_address":"","ucode":"B740E2A68A17A5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/84/39/c8772466.jpg","comment_is_top":false,"comment_ctime":1587650120,"is_pvip":true,"replies":[{"id":78306,"content":"回答和总结得很仔细。\n关于基于关键词拆分，能否特殊处理热点的问题，当然是可以的。如果查询热点一直比较稳定的话，我们可以通过加缓存，加副本，升级机器等方案来优化。不过一般来说，升级机器这种方案用得比较少，因为这涉及到更多的运维团队的工作，不如增加查询缓存，或者增加副本机器等机器调度方案便捷。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1587651927,"ip_address":"","comment_id":210000,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"先来回答老师的问题，基于文档拆分的方案，1，新增数据会落到某个具体的服务器，不需要考虑数据在所有检索服务器之间同步、不一致的问题，2，由于所有的检索服务器之间数据是均衡分布的，不存在服务器之间检索负载不均衡的问题\n\n索引水平拆分垂直拆分和数据库的水平拆分和垂直拆分是类似的\n我理解文档拆分是把数据对一个整体进行分片，对整体的查询变成了并行在分片上查询，缩短了查询时间，还有一个好处是新的文档被哈希到到某个分片上，对查询结果的影响被限定到这个具体的分片，不会影响所有分片\n关键词拆分也是把整体分片，对整体的查询变成了在单个分片上的查询，如果有热点数据会导致posting list过大，降低查询效率，这里能不能特殊处理，给热点数据指定专门的更高性能检索服务器，提升查询效率","like_count":4,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492910,"discussion_content":"回答和总结得很仔细。\n关于基于关键词拆分，能否特殊处理热点的问题，当然是可以的。如果查询热点一直比较稳定的话，我们可以通过加缓存，加副本，升级机器等方案来优化。不过一般来说，升级机器这种方案用得比较少，因为这涉及到更多的运维团队的工作，不如增加查询缓存，或者增加副本机器等机器调度方案便捷。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587651927,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207619,"user_name":"奕","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1587120247,"is_pvip":false,"replies":[{"id":77532,"content":"你举的这个例子很有意思。其实Redis cluster是一个kv存储，而不是一个倒排索引。对于kv，你既可以说它是按关键词拆分的，也可以说是按文档拆分的。\n\n当然，如果kv中的v是一个结果集合列表的话，这就是一个典型的基于关键词拆分的倒排索引了。在我们不需要进行多个关键词合并的场景下，这样的使用方案是很适合的。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1587124111,"ip_address":"","comment_id":207619,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"Redis Cluster 技术相当于按照关键词进行拆分，直接定位到 要查询的 key 在哪个 slot","like_count":3,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492910,"discussion_content":"回答和总结得很仔细。\n关于基于关键词拆分，能否特殊处理热点的问题，当然是可以的。如果查询热点一直比较稳定的话，我们可以通过加缓存，加副本，升级机器等方案来优化。不过一般来说，升级机器这种方案用得比较少，因为这涉及到更多的运维团队的工作，不如增加查询缓存，或者增加副本机器等机器调度方案便捷。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587651927,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207389,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1587080299,"is_pvip":false,"replies":[{"id":77450,"content":"总结得很好。我觉得可以给你补两个问题。有精力的童鞋也都可以想想。\n1.如果索引是使用“全量索引+增量索引”，再基于文档拆分，那么一个新文档加入时，它是会加入到所有索引服务器的增量索引中，还是可以只加入到一台服务器的增量索引中？\n2.基于文档拆分，会造成查询请求被复制多份，那除了基于关键词拆分，我们使用业务拆分的方案是否也能避免这个问题?","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1587082307,"ip_address":"","comment_id":207389,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"# 提高的吞吐量而非检索效率\n简单的分布式检索系统是指每台索引服务器保存了全量的索引数据，然后加机器，这种方式只能提高系统整体的&quot;吞吐量&quot;，而不能缩短检索时间从而加速检索效率\n\n# 通过拆分提高检索效率\n检索时间与数据规模正相关，所以采用索引拆分可以加入检索效率\n\n# 如何拆分？\n## 基于文档拆分\n核心思想是把大规模的文档集合随机拆分成多个小规模文档集合，即建了多个倒排索引，但每个倒排索引就是一个索引分片，保存了部分数据，所以它的 postinglist 不会太长，可以提升单机的检索效率\n\n## 基于文档拆分的检索流程\n- 分发服务器接受查询请求，然后将请求分发给其他索引服务器\n- 每台服务器根据自己加载的索引分片数据进行检索，再把结果返回给分发服务器\n- 分发服务器将所有返回结果进行合并，返回给客户端\n\n## 基于文档拆分的优缺点\n优点\n1.基于随机划分，每个索引分片大小相近，在索引空间分配上是相对均衡的，而且每台索引服务器的负载也相对均衡\n2.通过设置合理的分片数，有可能把所有数据加载到内存中，同时因为每个索引分片数据不大，可以提升检索效率\n\n不足\n分片数不能设置太大\n因为客户端发过来的请求是先经过分发服务器的，然后转发给其他索引分片服务器，如果分片数过多，会设计很多网络 IO 操作，性能就会下降\n\n## 基于关键词拆分\n通过关键词进行拆分是将不同的关键词放到不同的索引分片上，然后加载到不同的服务器上，这样的拆分方式可以达到每台索引服务器上的文档不是完整的，但关键词对应的列表是完整的\n\n## 基于关键词拆分的检索流程\n客户端发来请求，如果只有一个关键词，那只需要查询改关键词所在的索引服务器就可以得到完整的文档列表，省去了分发造成的网络 IO\n如果是多个关键词，可能也会发生分发请求，然后分发服务器合并请求返回给客户端\n\n## 基于关键词拆分的优缺点\n优点\n适合查询词少的情况，可以减少分发造成的网络 IO\n\n不足\n1.如果查询词比较多且没有被划分到一个分片中，也会分发请求，有网络 IO\n2.如果关键词是高频热点词，那它对应的文档列表会非常长，检索性能也会下降\n3.高频热点词所在服务器负载高，低频词所在服务器负载低，导致索引服务器负载不均衡\n4.如果有新增文档，会涉及到多台索引服务器修改\n\n# 思考题 \n## 为什么说基于文档拆分比关键词拆分更好维护？\n其实在上面分析两种方案的优缺点时已经介绍了，下面就简单总结下\n- 当有新文档加入时，最糟糕情况会修改所有的索引服务器\n- 遇到高频热点词，大量查询都打到了这个热点词所在的服务器上，导致该服务器负载很高，完成索引服务器的负载不均衡","like_count":3,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492184,"discussion_content":"你举的这个例子很有意思。其实Redis cluster是一个kv存储，而不是一个倒排索引。对于kv，你既可以说它是按关键词拆分的，也可以说是按文档拆分的。\n\n当然，如果kv中的v是一个结果集合列表的话，这就是一个典型的基于关键词拆分的倒排索引了。在我们不需要进行多个关键词合并的场景下，这样的使用方案是很适合的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587124111,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"奕","note":"","ucode":"73CEA468CE70C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":236868,"discussion_content":"哈哈，我想这个例子的时候也考虑也是基于文档拆分了，但是感觉基于基于key更合适些，对于整体来说某些key分到一个分片上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587128035,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":213132,"user_name":"new life","can_delete":false,"product_type":"c1","uid":1447866,"ip_address":"","ucode":"B817AC3909102B","user_header":"https://static001.geekbang.org/account/avatar/00/16/17/ba/c56aa720.jpg","comment_is_top":false,"comment_ctime":1588309547,"is_pvip":false,"replies":[{"id":79102,"content":"总结得很好。尤其你还提到了分页检索，这的确也是一个难点。基于文档拆分的方式需要解决问题。\n至于思考题，在更新一个文档的时候，如果是基于关键词拆分的话，由于一篇文档中会有多个关键词，这些关键词可能是分布在不同的服务器上的，因此会影响多台服务器。\n至于热点查询问题，如果是基于文档拆分，那么负载会更容易均衡到多台服务器上，避免热点。如果真有热点发生时，也可以灵活地重新分片进行负载均衡。因此会比基于关键词拆分更灵活。\n","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1588318647,"ip_address":"","comment_id":213132,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"按文档划分和按关键词划分，各有利弊\n按文档划分:\n1、一个关键词的所有文档分布在多个服务器上，缩短了每台服务器postlist的长度，提升了单台服务器的检索效率；\n2、但是检索对外时候需要检索多台服务器，合并检索结果，增加了分页检索实现的难度；\n\n按关键词划分\n1、每台服务器上含有这个关键词所有的文档，检索的时候，只要找到对应的服务器，检索一次就行，不用结果合并，分页控制也好实现；\n2、但是一个关键词的文档id列表放一块，提高了每次查询的检索成本，尤其是热点数据的检索时候，总要受不常用数据的拖累\n\n思考题\n\n我理解插入文档的时候，文档拆分和关键词拆分影响的都是一台服务器，热点数据检索的时候，关键词、文档拆分这种方式都是负载是均衡的，这也体现出按文档拆分的优势；","like_count":2,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493689,"discussion_content":"总结得很好。尤其你还提到了分页检索，这的确也是一个难点。基于文档拆分的方式需要解决问题。\n至于思考题，在更新一个文档的时候，如果是基于关键词拆分的话，由于一篇文档中会有多个关键词，这些关键词可能是分布在不同的服务器上的，因此会影响多台服务器。\n至于热点查询问题，如果是基于文档拆分，那么负载会更容易均衡到多台服务器上，避免热点。如果真有热点发生时，也可以灵活地重新分片进行负载均衡。因此会比基于关键词拆分更灵活。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588318647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216426,"user_name":"paulhaoyi","can_delete":false,"product_type":"c1","uid":1105619,"ip_address":"","ucode":"C972F4B459E7D6","user_header":"https://static001.geekbang.org/account/avatar/00/10/de/d3/2aa0177f.jpg","comment_is_top":false,"comment_ctime":1589257071,"is_pvip":false,"replies":[{"id":80135,"content":"其实对于这种是否存在的过滤问题，第四讲中我提到过，可以使用bloomfilter来进行判断文章是否已读。这样在容量和查询性能上都不错。缺点就是可能会有一定的错误率。不过作为内容分发场景而言，错判的话，只是少分发一个内容而已，应该是可以接受的。\n如果不希望有错误率，那么可以使用加餐1中我提到过的roaring bitmap来进行查找。\n至于你说的用文章ID为key，用户作为posting list的方案，我的理解是这个也是可行的。但是其实它和以用户为key，文章为posting list的方案的存储空间是一样的。你可以画一个矩阵，每一行是一个用户，每一列是一个文章。那么这个矩阵横着就是以用户ID为key，以文章ID为posting list的倒排;竖着就变成了以文章ID为key，以用户ID为posting list的倒排，因此并不会省空间。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1589298220,"ip_address":"","comment_id":216426,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"老师您好，请教一个问题，可能不一定和本章有关。我们做内容分发，需要再召回源拿出内容后，过滤用户读过的文章。由于量比较大，有些用户的阅读历史又很长，单独每个用户记录已读列表，不管是容量还是过滤性能都不太能接受。感觉这就是一个判断是否存在的问题。如果我用文章id做key，用户做的文档。建立倒排合适么？或者老师有什么好的方法建议？","like_count":1,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494812,"discussion_content":"其实对于这种是否存在的过滤问题，第四讲中我提到过，可以使用bloomfilter来进行判断文章是否已读。这样在容量和查询性能上都不错。缺点就是可能会有一定的错误率。不过作为内容分发场景而言，错判的话，只是少分发一个内容而已，应该是可以接受的。\n如果不希望有错误率，那么可以使用加餐1中我提到过的roaring bitmap来进行查找。\n至于你说的用文章ID为key，用户作为posting list的方案，我的理解是这个也是可行的。但是其实它和以用户为key，文章为posting list的方案的存储空间是一样的。你可以画一个矩阵，每一行是一个用户，每一列是一个文章。那么这个矩阵横着就是以用户ID为key，以文章ID为posting list的倒排;竖着就变成了以文章ID为key，以用户ID为posting list的倒排，因此并不会省空间。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589298220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207515,"user_name":"峰","can_delete":false,"product_type":"c1","uid":1056019,"ip_address":"","ucode":"C53CB64E8E7D19","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg","comment_is_top":false,"comment_ctime":1587098931,"is_pvip":false,"replies":[{"id":77505,"content":"是的。后面抽象成了水平拆分和垂直拆分，其实就和数据库的拆分理念很相似了。包括业务拆分，其实也和分库很相似。因此，许多设计理念都是可以相互借鉴，融会贯通的。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1587102909,"ip_address":"","comment_id":207515,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"本来按照题目写了下答案，但感觉还不如跳出来回答这个问题，看着太像传统数据库横向拆分纵向拆分，然后引入中间件，然后就有手工分库分表那一坨解决方案。跳出这个思路，横向纵向分片只是分散数据到各个节点的手段，上层应该提供策略屏蔽这些手段的差异，针对具体的分片方式做优化，比如热点，那就针对这个分片多点副本。","like_count":1,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492155,"discussion_content":"是的。后面抽象成了水平拆分和垂直拆分，其实就和数据库的拆分理念很相似了。包括业务拆分，其实也和分库很相似。因此，许多设计理念都是可以相互借鉴，融会贯通的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587102909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207480,"user_name":"那时刻","can_delete":false,"product_type":"c1","uid":1150927,"ip_address":"","ucode":"B0D150856C3A4A","user_header":"https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg","comment_is_top":false,"comment_ctime":1587091261,"is_pvip":false,"replies":[{"id":77504,"content":"1.没错。如果使用了全量索引+增量索引机制的话，对于新增文档，其实只需要先分片到对应的索引服务器上，然后加入这台服务器的增量索引即可。\n2.业务拆分尽管和业务耦合紧密，不过它可以同时兼具文档拆分和关键词拆分的优点(也可以理解为，业务拆分可以在两个方向进行抽象，分别变成文档拆分和关键词拆分)。\n业务既能对文档进行分片，也能在查询时指定只去一个分片查询，而不是所有分片都查询。因此在一些简单的应用场合中也是可以考虑的。\n对应到数据库设计，就是分库的问题。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1587102624,"ip_address":"","comment_id":207480,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"尝试回答老师在回复里的问题。不明白的地方请老师指正。\n1.按文档拆分，新增加的文档可以只加到一台增量索引的机器上班，因为查询的时候有按照关键字的合并\n2.我觉得可以按照业务拆分来减少查询的复制，比如按照文档类型 军事，娱乐来把文档分区，这样查询关键字的时候，比如这个关键字属于军事类型就只去军事类型文档分区找就可以了。","like_count":1,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492155,"discussion_content":"是的。后面抽象成了水平拆分和垂直拆分，其实就和数据库的拆分理念很相似了。包括业务拆分，其实也和分库很相似。因此，许多设计理念都是可以相互借鉴，融会贯通的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587102909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207470,"user_name":"那时刻","can_delete":false,"product_type":"c1","uid":1150927,"ip_address":"","ucode":"B0D150856C3A4A","user_header":"https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg","comment_is_top":false,"comment_ctime":1587090303,"is_pvip":false,"replies":[{"id":77503,"content":"是的。你会看到，数据库的分库分表其实也是一样的思路。因此，也希望大家能将一个技术进行横行对比，这样能更好地融会贯通，举一反三。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1587102231,"ip_address":"","comment_id":207470,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"基于文档或关键字拆分，类似于数据库的分库分表操作。基于文档拆分的好处在于分摊网络和io的压力。","like_count":1,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492145,"discussion_content":"1.没错。如果使用了全量索引+增量索引机制的话，对于新增文档，其实只需要先分片到对应的索引服务器上，然后加入这台服务器的增量索引即可。\n2.业务拆分尽管和业务耦合紧密，不过它可以同时兼具文档拆分和关键词拆分的优点(也可以理解为，业务拆分可以在两个方向进行抽象，分别变成文档拆分和关键词拆分)。\n业务既能对文档进行分片，也能在查询时指定只去一个分片查询，而不是所有分片都查询。因此在一些简单的应用场合中也是可以考虑的。\n对应到数据库设计，就是分库的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587102624,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207431,"user_name":"_你说了不算","can_delete":false,"product_type":"c1","uid":1185159,"ip_address":"","ucode":"212F890565FE5C","user_header":"https://static001.geekbang.org/account/avatar/00/12/15/87/d22d8c3e.jpg","comment_is_top":false,"comment_ctime":1587085645,"is_pvip":false,"replies":[{"id":77501,"content":"1.关于es的使用，的确是要了解了相关检索技术，已经了解了es以后，才能发挥出es的优势。如果你们想走这条路线的话，那需要多花点时间深入了解。\n2.你所谓的内存过滤，我的理解就是你们自研系统，在内存中建立索引处理。那么这样的话，你可以结合这个专栏的内容看看如何优化，比如说索引拆分，你们可以指定一个固定分片数，然后在离线环节就拆分好；然后结合全量索引+增量索引的机制，也能保证索引更新时的性能；还有倒排检索加速(参考两篇加餐)，应该也是有帮助的。\n3.MySQL和es的数据同步问题，其实有许多工具可以做，比如说logstash等。而一致性问题，需要你进行监控和周期性检查，避免有错误。还可以进行周期性完整重建索引的方式，将之前可能已经造成的不一致进行修复。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1587101713,"ip_address":"","comment_id":207431,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"老师，我们的广告投放引擎在数据检索这块就走了不少路，es过滤和内存过滤两种方式都用过，最终还是用了内存过滤，原因是后者服务器的cpu和内存状态更好，不知道是不是我们用es的姿势不对。最近引擎系统cpu一直报警，除了加机器，就是加机器，想请教下老师，有遇到过类似的这种情况吗？假如按照文章中提到的索引拆分的方式，具体的落地方案老师能不能指点一二？还有我们的数据是AE通过管理后台存在mysql的，那么mysql和es的数据一致性怎么处理？希望老师百忙中解答","like_count":1,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492141,"discussion_content":"是的。你会看到，数据库的分库分表其实也是一样的思路。因此，也希望大家能将一个技术进行横行对比，这样能更好地融会贯通，举一反三。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587102231,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":283004,"user_name":"Christmas","can_delete":false,"product_type":"c1","uid":1219172,"ip_address":"","ucode":"F48F6BE4A7595B","user_header":"https://static001.geekbang.org/account/avatar/00/12/9a/64/ad837224.jpg","comment_is_top":false,"comment_ctime":1615516338,"is_pvip":false,"replies":[{"id":102779,"content":"业界一般都是按文档拆分的，文中和课后习题里，都解释了原因。毕竟对于大部分应用而言，分片数也不会太多。\n当然，在极端考虑性能的情况下，是可以考虑关键词拆分的。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1615714080,"ip_address":"","comment_id":283004,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"超大规模的数据量的情况下，感觉按照文档切分，会出现性能问题，分发服务器请求的查询服务器会过多，因为一般es也不建议shard数量很大。不知道业界超大规模额情况下，是按照文档切分的吗？","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492121,"discussion_content":"1.关于es的使用，的确是要了解了相关检索技术，已经了解了es以后，才能发挥出es的优势。如果你们想走这条路线的话，那需要多花点时间深入了解。\n2.你所谓的内存过滤，我的理解就是你们自研系统，在内存中建立索引处理。那么这样的话，你可以结合这个专栏的内容看看如何优化，比如说索引拆分，你们可以指定一个固定分片数，然后在离线环节就拆分好；然后结合全量索引+增量索引的机制，也能保证索引更新时的性能；还有倒排检索加速(参考两篇加餐)，应该也是有帮助的。\n3.MySQL和es的数据同步问题，其实有许多工具可以做，比如说logstash等。而一致性问题，需要你进行监控和周期性检查，避免有错误。还可以进行周期性完整重建索引的方式，将之前可能已经造成的不一致进行修复。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587101713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":273305,"user_name":"趁早","can_delete":false,"product_type":"c1","uid":1031970,"ip_address":"","ucode":"949FB3AA250D80","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bf/22/26530e66.jpg","comment_is_top":false,"comment_ctime":1610530234,"is_pvip":false,"replies":[{"id":99532,"content":"是的。所以水平拆分的分片也不宜过多。\n那你可以会有一个问题，又要保证分片不要过多，又要保证高并发，这应该怎么办呢？\n一种解决方案是为每个分片建立一个集群。这样当要查询n个分片时，其实是去查询n个集群，在每个集群中按某种分配算法(比如随机)选一台具体的服务器进行查询，最后将n个集群的分片查询结果合并即可。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1610894872,"ip_address":"","comment_id":273305,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100048401,"comment_content":"连接的问题怎么处理，比如基于文档的水平拆分，每次查询都要遍历所有的分片，那分发服务需要跟每台分片保持实时的连接，这个开销也是很大的","like_count":0},{"had_liked":false,"id":263695,"user_name":"明翼","can_delete":false,"product_type":"c1","uid":1068361,"ip_address":"","ucode":"E77F86BEB3D5C1","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/49/28e73b9c.jpg","comment_is_top":false,"comment_ctime":1606221140,"is_pvip":false,"replies":[{"id":95728,"content":"看到了你的另一个问题，我就在下面一起回答了。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1606320010,"ip_address":"","comment_id":263695,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100048401,"comment_content":"老师请教个问题我们有大量的pcap文件，然后通过四元组来进行pcap的查找，我们如果对四元组分别建四个hashmap作为索引，值为pcap文件的偏移量，这个办法会造成文件持久的可能太大，而且hashmap还不太好持久化，有什么好的思路吗？谢谢老师","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510274,"discussion_content":"看到了你的另一个问题，我就在下面一起回答了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606320010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244727,"user_name":"独酌相思解千愁","can_delete":false,"product_type":"c1","uid":1653628,"ip_address":"","ucode":"578995696A1482","user_header":"https://static001.geekbang.org/account/avatar/00/19/3b/7c/a977d9a9.jpg","comment_is_top":false,"comment_ctime":1598634038,"is_pvip":false,"replies":[{"id":90080,"content":"是的。按文档拆分的更新代价会更低，而且按文档拆分还更容易进行水平扩展，解决热点问题。因此在大部分情况下，系统都会采用普适性更好的按文档拆分，ES集群就是这么做的。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1598687739,"ip_address":"","comment_id":244727,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100048401,"comment_content":"我的理解是，两者的区别就是分词典和分文档（就是这么直白）。当然不是把一个完整文档分城小片，然后路由到不同服务器上。最直观的感受就是，当有一个新文档来时，两者都要把文档路由到指定服务器上，但在索引更新时，安文档分的，就只用更新它所在服务器索引；而安词典分就需要更新所有可能的词典和其postinglist（他们可能分布在不同服务其上）。另外es集群应该就是文档分的吧。","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504681,"discussion_content":"是的。按文档拆分的更新代价会更低，而且按文档拆分还更容易进行水平扩展，解决热点问题。因此在大部分情况下，系统都会采用普适性更好的按文档拆分，ES集群就是这么做的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598687739,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223124,"user_name":"yalinz","can_delete":false,"product_type":"c1","uid":1931952,"ip_address":"","ucode":"8E9C2A40FE92A2","user_header":"https://static001.geekbang.org/account/avatar/00/1d/7a/b0/259f82a1.jpg","comment_is_top":false,"comment_ctime":1591005458,"is_pvip":false,"replies":[{"id":82303,"content":"关于基于文档的拆分，我们并不是先把完整的倒排索引建好，再对posting list进行分段拆分，这样做反而复杂了，而且会出现你说的许多分片都受影响的情况。\n你可以仔细看一下文章中描述基于文档拆分的文字和图示。你会发现，基于文档拆分的实现其实很简单，它是先将文档进行分片(比如说可以根据文档ID随机哈希划分)，划分为多个小的文档集合，然后针对每个小的文档集合，独立创建索引。因此，当新增一个文档时，我们只需要使用同样的文档分片规则，将新文档分配到所属的文档集合中，然后仅更新这个文档集合对应的索引即可。这样，新增文档仅会影响一个索引分片，而不是影响所有的索引分片。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1591074476,"ip_address":"","comment_id":223124,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100048401,"comment_content":"思考了下老师提出的问题，又看了同学的评论，还是不觉得基于文档拆分一定比基于关键字拆分更有优势：\n1.在新得文档加入时，一般应该是有多个关键字的吧，也就是说有多个关键字的postinglist需要更新。但在水平拆分时因为postinglist是有序的，但postinglist大小不同，那么拆分时是直接平均分段截取postinglist来拆分的吗?这样的话对于新增的文档来说更新索引时可能对于关键字一，该文档就处于postinglist相对靠前的位置，对于关键字二可能就处于postinglist靠后的位置，也就是说拆分后新增一个文档的话并不一定能避免在多个分片上进行更新的问题？那么水平拆分在增加文档时有时同样需要更新多个分片的内容？对这块我有些疑问。\n而垂直拆分的话增加文档也同样需要更新多个分片，但每个postlinglist是完整的，数据较大，更新操作确实比水平拆分负担要大。","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504681,"discussion_content":"是的。按文档拆分的更新代价会更低，而且按文档拆分还更容易进行水平扩展，解决热点问题。因此在大部分情况下，系统都会采用普适性更好的按文档拆分，ES集群就是这么做的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598687739,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222108,"user_name":"朱月俊","can_delete":false,"product_type":"c1","uid":1017707,"ip_address":"","ucode":"4DA0728B862FBD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/6b/0b6cd39a.jpg","comment_is_top":false,"comment_ctime":1590678098,"is_pvip":false,"replies":[{"id":82069,"content":"你提到了热点数据和长尾数据的问题，这是非常好的角度。从这个角度来看，基于word进行分库，会有两种比较大的开销:一种是这个word是热点，posting list特别长，那么查询开销就会很大;另一种是一个doc中的word很多，会涉及到多个分片的更新。因此基于word进行分库要处理的特殊情况会比较多，开销也大，不如基于文档拆分的方案可扩展性好。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1590843940,"ip_address":"","comment_id":222108,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100048401,"comment_content":"一切数据库都离不开增删查改，热点以及长尾数据。\n对于倒排索引，\n基于文档分库时，增加一份新doc，查询某个word，删除doc中的word，更新doc中的word，开销都不大。\n基于word分库时，增加一份新doc(可能包含多个word)会影响多个分片，删除doc中的word比较轻松，查一个word包含的docs(可能长尾数据，热点数据)，开销异常情况下还是蛮大的，更新doc中的word，因为有多个word，也需要涉及多个分片。\n这样看来，基于文档更合适些。\n","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496670,"discussion_content":"你提到了热点数据和长尾数据的问题，这是非常好的角度。从这个角度来看，基于word进行分库，会有两种比较大的开销:一种是这个word是热点，posting list特别长，那么查询开销就会很大;另一种是一个doc中的word很多，会涉及到多个分片的更新。因此基于word进行分库要处理的特殊情况会比较多，开销也大，不如基于文档拆分的方案可扩展性好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590843940,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214879,"user_name":"时隐时现","can_delete":false,"product_type":"c1","uid":1111899,"ip_address":"","ucode":"DA4D622FF84920","user_header":"https://static001.geekbang.org/account/avatar/00/10/f7/5b/d2e7c2c4.jpg","comment_is_top":false,"comment_ctime":1588841057,"is_pvip":false,"replies":[{"id":79569,"content":"这是一个好问题。如何保证分布式系统中的倒排索引的一致性。这就看应用具体的要求了。\n如果对于一致性要求不高的话，比如说搜索引擎，用户a搜索使用的是旧的全量索引，用户b搜索使用的是新的全量索引，其实这是没有任何问题的。因此这时候不需要特别处理。\n但如果是有强一致性要求的场景，那么可以使用分布式锁(Redis，zookeeper都可以，你可以了解一下)，来保证所有的副本都一致后再切换服务。不过这肯定会损失性能。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1588847435,"ip_address":"","comment_id":214879,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100048401,"comment_content":"老师好，有个问题：\n第一种多副本全量索引架构，如果对全量索引进行更新且确保每个副本都一致？db副本可以借助paxos&#47;raft协议实现，倒排索引适用这种协议吗？有现成的架构可以采用吗？","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494232,"discussion_content":"这是一个好问题。如何保证分布式系统中的倒排索引的一致性。这就看应用具体的要求了。\n如果对于一致性要求不高的话，比如说搜索引擎，用户a搜索使用的是旧的全量索引，用户b搜索使用的是新的全量索引，其实这是没有任何问题的。因此这时候不需要特别处理。\n但如果是有强一致性要求的场景，那么可以使用分布式锁(Redis，zookeeper都可以，你可以了解一下)，来保证所有的副本都一致后再切换服务。不过这肯定会损失性能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588847435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207432,"user_name":"Mq","can_delete":false,"product_type":"c1","uid":1178359,"ip_address":"","ucode":"041F572AFAB275","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/f7/91ac44c5.jpg","comment_is_top":false,"comment_ctime":1587085650,"is_pvip":false,"replies":[{"id":77502,"content":"对于热点的问题，如果所有的服务器的负载都同时上升，其实这是我们期望的事情，这时候没有服务器是“热点”，我们在运维时只要无差别扩容就行。\n相反，如果有的服务器查询负载很低，但有的服务器查询负载很高，那么这时候就存在“热点”问题了，我们需要针对特殊的一小撮服务器进行加副本扩容。但这时候可能其他服务器其实还是足够空闲的，这就造成了资源浪费。而且，如果第二天热点切换了的话，那我们是不是还要将原热点的副本下线，然后上线其他热点的副本?这样就会给运维带来很大的复杂性。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1587102147,"ip_address":"","comment_id":207432,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100048401,"comment_content":"基于文档的方案在有新文档加入时只会影响到有文档的那台服务器，基于关键词的拆分会影响到有关键词的所有服务器。\n热点关键词问题我怎么觉得基于文档跟基于关键词的划分都有，并且基于文档划分的影响范围更大。因为基于文档的划分所有索引服务器都保存了完整的key，也就意味着热点key来了后会导致所有索引服务器负载高，基于热点key的划分还只会影响到热点key的那台服务器，也主要针对那些服务器加副本就可以了。","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492122,"discussion_content":"对于热点的问题，如果所有的服务器的负载都同时上升，其实这是我们期望的事情，这时候没有服务器是“热点”，我们在运维时只要无差别扩容就行。\n相反，如果有的服务器查询负载很低，但有的服务器查询负载很高，那么这时候就存在“热点”问题了，我们需要针对特殊的一小撮服务器进行加副本扩容。但这时候可能其他服务器其实还是足够空闲的，这就造成了资源浪费。而且，如果第二天热点切换了的话，那我们是不是还要将原热点的副本下线，然后上线其他热点的副本?这样就会给运维带来很大的复杂性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587102147,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1178359,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fa/f7/91ac44c5.jpg","nickname":"Mq","note":"","ucode":"041F572AFAB275","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":236564,"discussion_content":"老师你这样解释就明白了，有时候思路就是来回切换不通，对一些原理理解不深","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587104004,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207392,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1587080549,"is_pvip":false,"replies":[{"id":77453,"content":"热点问题的确很常见。一个通用的解法就是为热点分片增加副本。\n此外，对于随机划分的文档拆分方案而言，由于随机的特性，它出现热点分片的概率相对较低，而且即使出现了，它也可以通过再次随机划分，或者有规划地划分来完成检索负载均衡的问题。\n而基于关键词划分的方案，因为还有一个“相关的关键词要被划分到同一个分片”的限制，因此在调整分片上能做的事情就很有限了。这也是它不如文档拆分更灵活的原因。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1587083789,"ip_address":"","comment_id":207392,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100048401,"comment_content":"按照老师的思路大致可以理一下，当新的文档加入，势必会根据新文档的关键词再拆分，影响的服务器得根据具体场景来定，可能会影响多台服务器，而基于文档拆分会直接将新增文档加入到特定的服务器中，对于热点关键词，肯定会被频繁访问，一台服务器会不堪重负，而冷点关键词估计会在服务器中发霉，热点关键词可能需要多台服务器进行支持，并增加相应的网关进行负载均衡。\n那么根据文档拆分也会遇到热点文档的问题，也需要多服务器和负载均衡，那么请问老师具体的场景会怎么做呢？","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492108,"discussion_content":"热点问题的确很常见。一个通用的解法就是为热点分片增加副本。\n此外，对于随机划分的文档拆分方案而言，由于随机的特性，它出现热点分片的概率相对较低，而且即使出现了，它也可以通过再次随机划分，或者有规划地划分来完成检索负载均衡的问题。\n而基于关键词划分的方案，因为还有一个“相关的关键词要被划分到同一个分片”的限制，因此在调整分片上能做的事情就很有限了。这也是它不如文档拆分更灵活的原因。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587083789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":372493,"user_name":"ifelse","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"浙江","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1681204150,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":3,"score":3,"product_id":100048401,"comment_content":"合理的索引拆分是分布式检索加速的重要手段，也是工业界的有效实践经验。--记下来","like_count":0},{"had_liked":false,"id":305890,"user_name":"anker","can_delete":false,"product_type":"c1","uid":1218937,"ip_address":"","ucode":"6EDF1FB9D45238","user_header":"https://static001.geekbang.org/account/avatar/00/12/99/79/74d4f24f.jpg","comment_is_top":false,"comment_ctime":1628219568,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100048401,"comment_content":"基于文档拆分：新文档插入只会影响一台服务器，由于关键词会分布在多台服务器，关键词的posting list也会更短便于维护，会降低热点关键词平均负载。\n\n基于关键词拆分：新文档插入由于一个文档有多个关键词，会影响多台服务器。此时单个关键词的posting list会特别的长，如果最近某个社会热点完成某写关键词大量出现的话，会造成倒排索引的热点读和热点写的问题","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492108,"discussion_content":"热点问题的确很常见。一个通用的解法就是为热点分片增加副本。\n此外，对于随机划分的文档拆分方案而言，由于随机的特性，它出现热点分片的概率相对较低，而且即使出现了，它也可以通过再次随机划分，或者有规划地划分来完成检索负载均衡的问题。\n而基于关键词划分的方案，因为还有一个“相关的关键词要被划分到同一个分片”的限制，因此在调整分片上能做的事情就很有限了。这也是它不如文档拆分更灵活的原因。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587083789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":273305,"user_name":"趁早","can_delete":false,"product_type":"c1","uid":1031970,"ip_address":"","ucode":"949FB3AA250D80","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bf/22/26530e66.jpg","comment_is_top":false,"comment_ctime":1610530234,"is_pvip":false,"replies":[{"id":99532,"content":"是的。所以水平拆分的分片也不宜过多。\n那你可以会有一个问题，又要保证分片不要过多，又要保证高并发，这应该怎么办呢？\n一种解决方案是为每个分片建立一个集群。这样当要查询n个分片时，其实是去查询n个集群，在每个集群中按某种分配算法(比如随机)选一台具体的服务器进行查询，最后将n个集群的分片查询结果合并即可。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1610894872,"ip_address":"","comment_id":273305,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100048401,"comment_content":"连接的问题怎么处理，比如基于文档的水平拆分，每次查询都要遍历所有的分片，那分发服务需要跟每台分片保持实时的连接，这个开销也是很大的","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513561,"discussion_content":"是的。所以水平拆分的分片也不宜过多。\n那你可以会有一个问题，又要保证分片不要过多，又要保证高并发，这应该怎么办呢？\n一种解决方案是为每个分片建立一个集群。这样当要查询n个分片时，其实是去查询n个集群，在每个集群中按某种分配算法(比如随机)选一台具体的服务器进行查询，最后将n个集群的分片查询结果合并即可。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610894872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1219172,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9a/64/ad837224.jpg","nickname":"Christmas","note":"","ucode":"F48F6BE4A7595B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":355994,"discussion_content":"这就有涉及到数据同步问题了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615515710,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263695,"user_name":"明翼","can_delete":false,"product_type":"c1","uid":1068361,"ip_address":"","ucode":"E77F86BEB3D5C1","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/49/28e73b9c.jpg","comment_is_top":false,"comment_ctime":1606221140,"is_pvip":false,"replies":[{"id":95728,"content":"看到了你的另一个问题，我就在下面一起回答了。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1606320010,"ip_address":"","comment_id":263695,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100048401,"comment_content":"老师请教个问题我们有大量的pcap文件，然后通过四元组来进行pcap的查找，我们如果对四元组分别建四个hashmap作为索引，值为pcap文件的偏移量，这个办法会造成文件持久的可能太大，而且hashmap还不太好持久化，有什么好的思路吗？谢谢老师","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513561,"discussion_content":"是的。所以水平拆分的分片也不宜过多。\n那你可以会有一个问题，又要保证分片不要过多，又要保证高并发，这应该怎么办呢？\n一种解决方案是为每个分片建立一个集群。这样当要查询n个分片时，其实是去查询n个集群，在每个集群中按某种分配算法(比如随机)选一台具体的服务器进行查询，最后将n个集群的分片查询结果合并即可。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610894872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1219172,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9a/64/ad837224.jpg","nickname":"Christmas","note":"","ucode":"F48F6BE4A7595B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":355994,"discussion_content":"这就有涉及到数据同步问题了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615515710,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244727,"user_name":"独酌相思解千愁","can_delete":false,"product_type":"c1","uid":1653628,"ip_address":"","ucode":"578995696A1482","user_header":"https://static001.geekbang.org/account/avatar/00/19/3b/7c/a977d9a9.jpg","comment_is_top":false,"comment_ctime":1598634038,"is_pvip":false,"replies":[{"id":90080,"content":"是的。按文档拆分的更新代价会更低，而且按文档拆分还更容易进行水平扩展，解决热点问题。因此在大部分情况下，系统都会采用普适性更好的按文档拆分，ES集群就是这么做的。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1598687739,"ip_address":"","comment_id":244727,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100048401,"comment_content":"我的理解是，两者的区别就是分词典和分文档（就是这么直白）。当然不是把一个完整文档分城小片，然后路由到不同服务器上。最直观的感受就是，当有一个新文档来时，两者都要把文档路由到指定服务器上，但在索引更新时，安文档分的，就只用更新它所在服务器索引；而安词典分就需要更新所有可能的词典和其postinglist（他们可能分布在不同服务其上）。另外es集群应该就是文档分的吧。","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510274,"discussion_content":"看到了你的另一个问题，我就在下面一起回答了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606320010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223124,"user_name":"yalinz","can_delete":false,"product_type":"c1","uid":1931952,"ip_address":"","ucode":"8E9C2A40FE92A2","user_header":"https://static001.geekbang.org/account/avatar/00/1d/7a/b0/259f82a1.jpg","comment_is_top":false,"comment_ctime":1591005458,"is_pvip":false,"replies":[{"id":82303,"content":"关于基于文档的拆分，我们并不是先把完整的倒排索引建好，再对posting list进行分段拆分，这样做反而复杂了，而且会出现你说的许多分片都受影响的情况。\n你可以仔细看一下文章中描述基于文档拆分的文字和图示。你会发现，基于文档拆分的实现其实很简单，它是先将文档进行分片(比如说可以根据文档ID随机哈希划分)，划分为多个小的文档集合，然后针对每个小的文档集合，独立创建索引。因此，当新增一个文档时，我们只需要使用同样的文档分片规则，将新文档分配到所属的文档集合中，然后仅更新这个文档集合对应的索引即可。这样，新增文档仅会影响一个索引分片，而不是影响所有的索引分片。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1591074476,"ip_address":"","comment_id":223124,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100048401,"comment_content":"思考了下老师提出的问题，又看了同学的评论，还是不觉得基于文档拆分一定比基于关键字拆分更有优势：\n1.在新得文档加入时，一般应该是有多个关键字的吧，也就是说有多个关键字的postinglist需要更新。但在水平拆分时因为postinglist是有序的，但postinglist大小不同，那么拆分时是直接平均分段截取postinglist来拆分的吗?这样的话对于新增的文档来说更新索引时可能对于关键字一，该文档就处于postinglist相对靠前的位置，对于关键字二可能就处于postinglist靠后的位置，也就是说拆分后新增一个文档的话并不一定能避免在多个分片上进行更新的问题？那么水平拆分在增加文档时有时同样需要更新多个分片的内容？对这块我有些疑问。\n而垂直拆分的话增加文档也同样需要更新多个分片，但每个postlinglist是完整的，数据较大，更新操作确实比水平拆分负担要大。","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497018,"discussion_content":"关于基于文档的拆分，我们并不是先把完整的倒排索引建好，再对posting list进行分段拆分，这样做反而复杂了，而且会出现你说的许多分片都受影响的情况。\n你可以仔细看一下文章中描述基于文档拆分的文字和图示。你会发现，基于文档拆分的实现其实很简单，它是先将文档进行分片(比如说可以根据文档ID随机哈希划分)，划分为多个小的文档集合，然后针对每个小的文档集合，独立创建索引。因此，当新增一个文档时，我们只需要使用同样的文档分片规则，将新文档分配到所属的文档集合中，然后仅更新这个文档集合对应的索引即可。这样，新增文档仅会影响一个索引分片，而不是影响所有的索引分片。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591074476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222108,"user_name":"朱月俊","can_delete":false,"product_type":"c1","uid":1017707,"ip_address":"","ucode":"4DA0728B862FBD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/6b/0b6cd39a.jpg","comment_is_top":false,"comment_ctime":1590678098,"is_pvip":false,"replies":[{"id":82069,"content":"你提到了热点数据和长尾数据的问题，这是非常好的角度。从这个角度来看，基于word进行分库，会有两种比较大的开销:一种是这个word是热点，posting list特别长，那么查询开销就会很大;另一种是一个doc中的word很多，会涉及到多个分片的更新。因此基于word进行分库要处理的特殊情况会比较多，开销也大，不如基于文档拆分的方案可扩展性好。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1590843940,"ip_address":"","comment_id":222108,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100048401,"comment_content":"一切数据库都离不开增删查改，热点以及长尾数据。\n对于倒排索引，\n基于文档分库时，增加一份新doc，查询某个word，删除doc中的word，更新doc中的word，开销都不大。\n基于word分库时，增加一份新doc(可能包含多个word)会影响多个分片，删除doc中的word比较轻松，查一个word包含的docs(可能长尾数据，热点数据)，开销异常情况下还是蛮大的，更新doc中的word，因为有多个word，也需要涉及多个分片。\n这样看来，基于文档更合适些。\n","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497018,"discussion_content":"关于基于文档的拆分，我们并不是先把完整的倒排索引建好，再对posting list进行分段拆分，这样做反而复杂了，而且会出现你说的许多分片都受影响的情况。\n你可以仔细看一下文章中描述基于文档拆分的文字和图示。你会发现，基于文档拆分的实现其实很简单，它是先将文档进行分片(比如说可以根据文档ID随机哈希划分)，划分为多个小的文档集合，然后针对每个小的文档集合，独立创建索引。因此，当新增一个文档时，我们只需要使用同样的文档分片规则，将新文档分配到所属的文档集合中，然后仅更新这个文档集合对应的索引即可。这样，新增文档仅会影响一个索引分片，而不是影响所有的索引分片。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591074476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214879,"user_name":"时隐时现","can_delete":false,"product_type":"c1","uid":1111899,"ip_address":"","ucode":"DA4D622FF84920","user_header":"https://static001.geekbang.org/account/avatar/00/10/f7/5b/d2e7c2c4.jpg","comment_is_top":false,"comment_ctime":1588841057,"is_pvip":false,"replies":[{"id":79569,"content":"这是一个好问题。如何保证分布式系统中的倒排索引的一致性。这就看应用具体的要求了。\n如果对于一致性要求不高的话，比如说搜索引擎，用户a搜索使用的是旧的全量索引，用户b搜索使用的是新的全量索引，其实这是没有任何问题的。因此这时候不需要特别处理。\n但如果是有强一致性要求的场景，那么可以使用分布式锁(Redis，zookeeper都可以，你可以了解一下)，来保证所有的副本都一致后再切换服务。不过这肯定会损失性能。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1588847435,"ip_address":"","comment_id":214879,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100048401,"comment_content":"老师好，有个问题：\n第一种多副本全量索引架构，如果对全量索引进行更新且确保每个副本都一致？db副本可以借助paxos&#47;raft协议实现，倒排索引适用这种协议吗？有现成的架构可以采用吗？","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496670,"discussion_content":"你提到了热点数据和长尾数据的问题，这是非常好的角度。从这个角度来看，基于word进行分库，会有两种比较大的开销:一种是这个word是热点，posting list特别长，那么查询开销就会很大;另一种是一个doc中的word很多，会涉及到多个分片的更新。因此基于word进行分库要处理的特殊情况会比较多，开销也大，不如基于文档拆分的方案可扩展性好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590843940,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207432,"user_name":"Mq","can_delete":false,"product_type":"c1","uid":1178359,"ip_address":"","ucode":"041F572AFAB275","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/f7/91ac44c5.jpg","comment_is_top":false,"comment_ctime":1587085650,"is_pvip":false,"replies":[{"id":77502,"content":"对于热点的问题，如果所有的服务器的负载都同时上升，其实这是我们期望的事情，这时候没有服务器是“热点”，我们在运维时只要无差别扩容就行。\n相反，如果有的服务器查询负载很低，但有的服务器查询负载很高，那么这时候就存在“热点”问题了，我们需要针对特殊的一小撮服务器进行加副本扩容。但这时候可能其他服务器其实还是足够空闲的，这就造成了资源浪费。而且，如果第二天热点切换了的话，那我们是不是还要将原热点的副本下线，然后上线其他热点的副本?这样就会给运维带来很大的复杂性。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1587102147,"ip_address":"","comment_id":207432,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100048401,"comment_content":"基于文档的方案在有新文档加入时只会影响到有文档的那台服务器，基于关键词的拆分会影响到有关键词的所有服务器。\n热点关键词问题我怎么觉得基于文档跟基于关键词的划分都有，并且基于文档划分的影响范围更大。因为基于文档的划分所有索引服务器都保存了完整的key，也就意味着热点key来了后会导致所有索引服务器负载高，基于热点key的划分还只会影响到热点key的那台服务器，也主要针对那些服务器加副本就可以了。","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494232,"discussion_content":"这是一个好问题。如何保证分布式系统中的倒排索引的一致性。这就看应用具体的要求了。\n如果对于一致性要求不高的话，比如说搜索引擎，用户a搜索使用的是旧的全量索引，用户b搜索使用的是新的全量索引，其实这是没有任何问题的。因此这时候不需要特别处理。\n但如果是有强一致性要求的场景，那么可以使用分布式锁(Redis，zookeeper都可以，你可以了解一下)，来保证所有的副本都一致后再切换服务。不过这肯定会损失性能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588847435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207392,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1587080549,"is_pvip":false,"replies":[{"id":77453,"content":"热点问题的确很常见。一个通用的解法就是为热点分片增加副本。\n此外，对于随机划分的文档拆分方案而言，由于随机的特性，它出现热点分片的概率相对较低，而且即使出现了，它也可以通过再次随机划分，或者有规划地划分来完成检索负载均衡的问题。\n而基于关键词划分的方案，因为还有一个“相关的关键词要被划分到同一个分片”的限制，因此在调整分片上能做的事情就很有限了。这也是它不如文档拆分更灵活的原因。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1587083789,"ip_address":"","comment_id":207392,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100048401,"comment_content":"按照老师的思路大致可以理一下，当新的文档加入，势必会根据新文档的关键词再拆分，影响的服务器得根据具体场景来定，可能会影响多台服务器，而基于文档拆分会直接将新增文档加入到特定的服务器中，对于热点关键词，肯定会被频繁访问，一台服务器会不堪重负，而冷点关键词估计会在服务器中发霉，热点关键词可能需要多台服务器进行支持，并增加相应的网关进行负载均衡。\n那么根据文档拆分也会遇到热点文档的问题，也需要多服务器和负载均衡，那么请问老师具体的场景会怎么做呢？","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492122,"discussion_content":"对于热点的问题，如果所有的服务器的负载都同时上升，其实这是我们期望的事情，这时候没有服务器是“热点”，我们在运维时只要无差别扩容就行。\n相反，如果有的服务器查询负载很低，但有的服务器查询负载很高，那么这时候就存在“热点”问题了，我们需要针对特殊的一小撮服务器进行加副本扩容。但这时候可能其他服务器其实还是足够空闲的，这就造成了资源浪费。而且，如果第二天热点切换了的话，那我们是不是还要将原热点的副本下线，然后上线其他热点的副本?这样就会给运维带来很大的复杂性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587102147,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1178359,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fa/f7/91ac44c5.jpg","nickname":"Mq","note":"","ucode":"041F572AFAB275","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":236564,"discussion_content":"老师你这样解释就明白了，有时候思路就是来回切换不通，对一些原理理解不深","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587104004,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":372493,"user_name":"ifelse","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"浙江","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1681204150,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":3,"score":3,"product_id":100048401,"comment_content":"合理的索引拆分是分布式检索加速的重要手段，也是工业界的有效实践经验。--记下来","like_count":0},{"had_liked":false,"id":305890,"user_name":"anker","can_delete":false,"product_type":"c1","uid":1218937,"ip_address":"","ucode":"6EDF1FB9D45238","user_header":"https://static001.geekbang.org/account/avatar/00/12/99/79/74d4f24f.jpg","comment_is_top":false,"comment_ctime":1628219568,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100048401,"comment_content":"基于文档拆分：新文档插入只会影响一台服务器，由于关键词会分布在多台服务器，关键词的posting list也会更短便于维护，会降低热点关键词平均负载。\n\n基于关键词拆分：新文档插入由于一个文档有多个关键词，会影响多台服务器。此时单个关键词的posting list会特别的长，如果最近某个社会热点完成某写关键词大量出现的话，会造成倒排索引的热点读和热点写的问题","like_count":0}]}