{"id":740866,"title":"第 5 章 面向生产的 Spring Boot(1)","content":"<blockquote>\n<p><strong>本章内容</strong></p>\n<ul>\n<li>通过 Spring Boot Actuator 了解运行情况</li>\n<li>定制 Spring Boot Actuator 的端点</li>\n<li>使用 Micrometer 输出度量数据</li>\n<li>Spring Boot 应用程序的部署及原理</li>\n</ul>\n</blockquote>\n<p>在 4.1.2 节中，我们介绍了 Spring Boot 的四大核心组成部分，第 4 章主要介绍了其中的起步依赖与自动配置，本章将重点介绍 Spring Boot Actuator，包括如何通过 Actuator 提供的各种端点（endpoint）了解系统的运行情况，使用 Micrometer 为各种监控系统提供度量指标数据，最后还要了解如何打包部署 Spring Boot 应用程序。</p>\n<h2 id=\"nav_point_74\">5.1　Spring Boot Actuator 概述</h2>\n<p>Spring Boot Actuator 是 Spring Boot 的重要功能模块，能为系统提供一系列在生产环境中运行所必需的功能，比如监控、度量、配置管理等。只需引入 <code>org.springframework.boot:spring-boot-starter-actuator</code> 起步依赖后，我们就可以通过 HTTP 来访问这些功能（也可以使用 JMX 来访问）。Spring Boot 还为我们预留了很多配置，可以根据自己的需求对 Spring Boot Actuator 的功能进行定制。</p>\n<h3 id=\"nav_point_75\">5.1.1　端点概览</h3>\n<p>不知道大家有没有尝试解决过类似下面的问题：</p>\n<ul>\n<li>Spring 上下文中到底存在哪些 Bean</li>\n<li>Spring Boot 中的哪些自动配置最终生效了</li>\n<li>应用究竟获取到了哪些配置项</li>\n<li>系统中存在哪些 URL，它们又映射到了哪里</li>\n</ul>\n<p>在没有 Spring Boot Actuator 的时候，获取这些信息还是需要费一番功夫的；但现在就不一样了，Spring Boot Actuator 内置了大量的端点，这些端点可以帮助大家了解系统内部的运行情况，并针对一些功能做出调整。</p><!-- [[[read_end]]] -->\n<p>根据功能的不同，我们可以将这些端点划分成四类：信息类端点、监控类端点、操作类端点、集成类端点，其中部分端点需要引入特定的依赖，或者配置特定的 Bean。接下来我们会依次介绍这四类端点，首先是用于获取系统运行信息的端点，如表 5-1 所示。</p>\n<p><strong>表 5-1　Spring Boot Actuator 中的信息类端点列表</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>端点 ID</p></th>\n<th><p>默认开启 HTTP</p></th>\n<th><p>默认开启 JMX</p></th>\n<th><p>端点说明</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>auditevents</code></p></td>\n<td><p>否</p></td>\n<td><p>是</p></td>\n<td><p>提供系统的审计信息</p></td>\n</tr>\n<tr>\n<td><p><code>beans</code></p></td>\n<td><p>否</p></td>\n<td><p>是</p></td>\n<td><p>提供系统中的 Bean 列表</p></td>\n</tr>\n<tr>\n<td><p><code>caches</code></p></td>\n<td><p>否</p></td>\n<td><p>是</p></td>\n<td><p>提供系统中的缓存信息</p></td>\n</tr>\n<tr>\n<td><p><code>conditions</code></p></td>\n<td><p>否</p></td>\n<td><p>是</p></td>\n<td><p>提供配置类的匹配情况及条件运算结果</p></td>\n</tr>\n<tr>\n<td><p><code>configprops</code></p></td>\n<td><p>否</p></td>\n<td><p>是</p></td>\n<td><p>提供 <code>@ConfigurationProperties</code> 的列表</p></td>\n</tr>\n<tr>\n<td><p><code>env</code></p></td>\n<td><p>否</p></td>\n<td><p>是</p></td>\n<td><p>提供 <code>ConfigurableEnvironment</code> 中的属性信息</p></td>\n</tr>\n<tr>\n<td><p><code>flyway</code></p></td>\n<td><p>否</p></td>\n<td><p>是</p></td>\n<td><p>提供已执行的 Flyway 数据库迁移信息</p></td>\n</tr>\n<tr>\n<td><p><code>httptrace</code></p></td>\n<td><p>否</p></td>\n<td><p>是</p></td>\n<td><p>提供 HTTP 跟踪信息，默认最近 100 条</p></td>\n</tr>\n<tr>\n<td><p><code>info</code></p></td>\n<td><p>是</p></td>\n<td><p>是</p></td>\n<td><p>显示事先设置好的系统信息</p></td>\n</tr>\n<tr>\n<td><p><code>integrationgraph</code></p></td>\n<td><p>否</p></td>\n<td><p>是</p></td>\n<td><p>提供 Spring Integration 图信息</p></td>\n</tr>\n<tr>\n<td><p><code>liquibase</code></p></td>\n<td><p>否</p></td>\n<td><p>是</p></td>\n<td><p>提供已执行的 Liquibase 数据库迁移信息</p></td>\n</tr>\n<tr>\n<td><p><code>logfile</code></p></td>\n<td><p>否</p></td>\n<td><p>无此功能</p></td>\n<td><p>如果设置了 <code>logging.file.name</code> 或 <code>logging.file.path</code> 属性，则显示日志文件内容</p></td>\n</tr>\n<tr>\n<td><p><code>mappings</code></p></td>\n<td><p>否</p></td>\n<td><p>是</p></td>\n<td><p>提供 <code>@RequestMapping</code> 的映射列表</p></td>\n</tr>\n<tr>\n<td><p><code>scheduledtasks</code></p></td>\n<td><p>否</p></td>\n<td><p>是</p></td>\n<td><p>提供系统中的调度任务列表</p></td>\n</tr>\n</tbody>\n</table>\n<p>第二类端点是监控与度量相关的端点，具体如表 5-2 所示。</p>\n<p><strong>表 5-2　Spring Boot Actuator 中的监控类端点列表</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>端点 ID</p></th>\n<th><p>默认开启 HTTP</p></th>\n<th><p>默认开启 JMX</p></th>\n<th><p>端点说明</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>health</code></p></td>\n<td><p>是</p></td>\n<td><p>是</p></td>\n<td><p>提供系统运行的健康状态</p></td>\n</tr>\n<tr>\n<td><p><code>metrics</code></p></td>\n<td><p>否</p></td>\n<td><p>是</p></td>\n<td><p>提供系统的度量信息</p></td>\n</tr>\n<tr>\n<td><p><code>prometheus</code></p></td>\n<td><p>否</p></td>\n<td><p>无此功能</p></td>\n<td><p>提供 Prometheus 系统可解析的度量信息</p></td>\n</tr>\n</tbody>\n</table>\n<p>我们对第 1 章的 <code>helloworld</code> 示例稍作调整，在其 pom.xml 的 <code>&lt;dependencies/&gt;</code> 中增加如下内容即可引入 Spring Boot Actuator 的依赖：</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<p>从上述两张表中我们可以发现，默认只有 <code>info</code> 和 <code>health</code> 两个端点是开启了 HTTP 访问的，因此在运行程序后，通过浏览器或者其他方式访问 <code>http://localhost:8080/actuator/health</code> 就能访问到 <code>health</code> 端点的信息。如果在 macOS 或 Linux 上，我们可以使用 <code>curl</code> 命令 <span class=\"comment-number\">1</span>，具体运行结果如下：</p>\n\n<pre class=\"code-rows\"><code>▸ curl -v http://localhost:8080/actuator/health\n\n*   Trying ::1...\n* TCP_NODELAY set\n* Connected to localhost (::1) port 8080 (#0)\n&gt; GET /actuator/health HTTP/1.1\n&gt; Host: localhost:8080\n&gt; User-Agent: curl/7.64.1\n&gt; Accept: */*\n&gt;\n&lt; HTTP/1.1 200\n&lt; Content-Type: application/vnd.spring-boot.actuator.v3+json\n&lt; Transfer-Encoding: chunked\n&lt; Date: Fri, 10 Jul 2020 15:38:54 GMT\n&lt;\n* Connection #0 to host localhost left intact\n{\"status\":\"UP\"}* Closing connection 0</code></pre>\n<p>如果使用浏览器，访问的效果如图 5-1 所示 <span class=\"comment-number\">2</span>。</p>\n\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00761.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 5-1　通过 Chrome 浏览器查看 <code>health</code> 端点</strong></p>\n<p>第三类端点可以执行一些实际的操作，例如调整日志级别，具体如表 5-3 所示。</p>\n<p><strong>表 5-3　Spring Boot Actuator 中的操作类端点列表</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>端点 ID</p></th>\n<th><p>默认开启 HTTP</p></th>\n<th><p>默认开启 JMX</p></th>\n<th><p>端点说明</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>heapdump</code></p></td>\n<td><p>否</p></td>\n<td><p>无此功能</p></td>\n<td><p>执行 Heap Dump 操作</p></td>\n</tr>\n<tr>\n<td><p><code>loggers</code></p></td>\n<td><p>否</p></td>\n<td><p>是</p></td>\n<td><p>查看并修改日志信息</p></td>\n</tr>\n<tr>\n<td><p><code>sessions</code></p></td>\n<td><p>否</p></td>\n<td><p>是</p></td>\n<td><p>针对使用了 Spring Session 的系统，可获取或删除用户的 Session</p></td>\n</tr>\n<tr>\n<td><p><code>shutdown</code></p></td>\n<td><p>否</p></td>\n<td><p>否</p></td>\n<td><p>优雅地关闭系统</p></td>\n</tr>\n<tr>\n<td><p><code>threaddump</code></p></td>\n<td><p>否</p></td>\n<td><p>是</p></td>\n<td><p>执行 Thread Dump 操作</p></td>\n</tr>\n</tbody>\n</table>\n<p>最后一类端点比较特殊，它的功能与集成有关，就只有一个 <code>jolokia</code>，见表 5-4。</p>\n<p><strong>表 5-4　Spring Boot Actuator 中的集成类端点列表</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>端点 ID</p></th>\n<th><p>默认开启 HTTP</p></th>\n<th><p>默认开启 JMX</p></th>\n<th><p>端点说明</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>jolokia</code></p></td>\n<td><p>否</p></td>\n<td><p>无此功能</p></td>\n<td><p>通过 HTTP 来发布 JMX Bean</p></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"nav_point_76\">5.1.2　端点配置</h3>\n<p>在了解了 Spring Boot 提供的端点后，我们就要将它们投入具体的生产使用当中了。Spring Boot Actuator 非常灵活，它提供了大量的开关配置，还有两种不同的访问方式可供我们选择。接下来大家就来一起了解一下这些配置。</p>\n<ol>\n<li><p><strong>开启或禁用端点</strong></p>\n<p>默认情况下，除了 <code>shutdown</code> 以外，所有的端点都是处于开启状态的，只是访问方式不同，或者保护状态不同。如果要开启或者禁用某个端点，可以调整 <code>management.endpoint.&lt;id&gt;.enabled</code> 属性。例如，想要开启 <code>shutdown</code> 端点，就可以这样配置：</p>\n<pre class=\"code-rows\"><code>management.endpoint.shutdown.enabled=true</code></pre>\n<p>也可以调整默认值，禁用所有端点，随后开启指定端点。例如，只开启 <code>health</code> 端点：</p>\n<pre class=\"code-rows\"><code>management.endpoints.enabled-by-default=false\nmanagement.endpoint.health.enabled=true</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>通过 HTTP 访问端点</strong></p>\n<p>默认仅有 <code>health</code> 和 <code>info</code> 端点是可以通过 HTTP 方式来访问的，在 5.1.1 节中，我们已经看到了如何通过 <code>curl</code> 命令和浏览器来访问 <code>health</code> 端口。那如何才能开启其他端点的 HTTP 访问功能呢？可以使用 <code>management.endpoints.web.exposure.include</code> 和 <code>management.endpoints.web.exposure.exclude</code> 这两个属性来控制哪些端点可以通过 HTTP 方式发布，哪些端点不行。前者的默认值为 <code>health,info</code>，后者的默认值为空。</p>\n<p>例如，我们希望在原有基础上再增加 <code>beans</code> 和 <code>env</code> 端点，就可以这样来设置：</p>\n<pre class=\"code-rows\"><code>management.endpoints.web.exposure.include=beans,env,health,info</code></pre>\n<p>如果希望放开所有的端点，让它们都能通过 HTTP 方式来访问，我们就可以将上述属性设置为 <code>*</code><span class=\"comment-number\">3</span>：</p>\n<pre class=\"code-rows\"><code>management.endpoints.web.exposure.include=*</code></pre>\n<p>要是一个端点同时出现在 <code>management.endpoints.web.exposure.include</code> 和 <code>management.endpoints.web.exposure.exclude</code> 这两个属性里，那么后者的优先级会高于前者，也就是说该端点会被排除。</p>\n<p>如果我们希望了解 HTTP 方式可以访问哪些端点，可以直接访问 <code>/actuator</code> 地址，会得到类似下面的 JSON 信息：</p>\n<pre class=\"code-rows\"><code>{\n    \"_links\": {\n        \"health\": {\n            \"href\": \"http://localhost:8080/actuator/health\",\n            \"templated\": false\n        },\n        \"health-path\": {\n            \"href\": \"http://localhost:8080/actuator/health/{*path}\",\n            \"templated\": true\n        },\n        \"info\": {\n            \"href\": \"http://localhost:8080/actuator/info\",\n            \"templated\": false\n        },\n        \"self\": {\n            \"href\": \"http://localhost:8080/actuator\",\n            \"templated\": false\n        }\n    }\n}</code></pre>\n<p>其中 <code>templated</code> 为 <code>true</code> 的 URL 可以用具体的值去代替 <code>{}</code> 里的内容，比如，<code>http://localhost:8080/actuator/metrics/</code> 的 <code></code> 就可以用 <code>http://localhost:8080/actuator/metrics</code> 里所罗列的名称代替。</p>\n<p>需要特别说明一点，要发布 HTTP 端点，必须要有 Web 支持，因此项目需要引入 <code>spring-boot-starter-web</code> 起步依赖。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>通过 JMX 访问端点</strong></p>\n<p>与 HTTP 方式类似，JMX 也有两个属性，即 <code>management.endpoints.jmx.exposure.include</code> 和 <code>management.endpoints.jmx.exposure.exclude</code>。前者的默认值为 <code>*</code>，后者的默认值为空。</p>\n<p>有不少工具可以用来访问 JMX 端点，比如 JVisualVM 和 JConsole，它们都是 JDK 自带的工具。以 JConsole 为例，启动 JConsole 后会弹出新建连接界面，从中可以选择想要连接的本地 Java 进程，也可以通过指定信息连接远程的进程，具体如图 5-2 所示。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00762.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 5-2　JConsole 的新建连接界面</strong></p>\n<p>选中目标进程后，点击连接按钮，稍过一段时间后，就能连上目标进程了。随后选中 MBean 标签页，在 <code>org.springframework.boot</code> 目录下找到 <code>Endpoint</code>，其中列出的就是可以访问的 JMX 端点。图 5-3 就是选择了 <code>Health</code> 后界面的样子，点击 <code>health</code> 按钮即可获得健康检查的 JSON 结果。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00763.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 5-3　通过 JMX 方式访问 <code>health</code> 端点</strong></p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>保护端点</strong></p>\n<p>如果在工程中引入了 Spring Security，那么 Spring Boot Actuator 会自动对各种端点进行保护，例如，默认通过浏览器访问时，浏览器会显示一个页面，要求输入用户名和密码。如果我们没有配置过相关信息，那么在系统启动时，可以在日志中查找类似下面的日志：</p>\n<pre class=\"code-rows\"><code>Using generated security password: 4fbc8059-fdb8-46f9-a54e-21d5cb2e9eb2</code></pre>\n<p>默认的用户名是 <code>user</code>，密码就是上面这段随机生成的内容。关于 Spring Security 的更多细节，我们会在第 10 章中详细展开。此处，给出两个示例，它们都需要在 pom.xml 中增加 <code>spring-boot-starter-actuator</code> 和 <code>spring-boot-starter-security</code> 起步依赖。这里先来演示如何不用登录页，而是使用 HTTP Basic 的方式进行验证（但 <code>health</code> 端点除外），具体的配置如代码示例 5-1 所示 <span class=\"comment-number\">4</span>，注意其中的 <code>EndpointRequest</code> 用的是 <code>org.springframework.boot.actuate.autoconfigure.security.servlet.EndpointRequest</code>。</p>\n<blockquote>\n<p><strong>代码示例 5-1</strong>　需要认证才可访问端点的配置代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Configuration\npublic class ActuatorSecurityConfigurer extends WebSecurityConfigurerAdapter {\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.requestMatcher(EndpointRequest.toAnyEndpoint().excluding(\"health\")).\nauthorizeRequests((requests) -&gt; requests.anyRequest().authenticated());\n        http.httpBasic();\n    }\n}</code></pre>\n<p>第二个演示针对所有端点，可以提供匿名访问，具体如代码示例 5-2 所示。</p>\n<blockquote>\n<p><strong>代码示例 5-2</strong>　可匿名访问端点的配置代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Configuration\npublic class ActuatorSecurityConfigurer extends WebSecurityConfigurerAdapter {\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.requestMatcher(EndpointRequest.toAnyEndpoint()).authorizeRequests((requests) -&gt; requests.\nanyRequest().anonymous());\n        http.httpBasic();\n    }\n}</code></pre>\n<blockquote>\n<p><strong>茶歇时间：针对 Web 和 Actuator 使用不同端口的好处</strong></p>\n<p>试想一下，我们的系统在对外提供 HTTP 服务，一般会在集群前增加一个负载均衡设备（比如 Nginx），将外部对 <code>80</code> 端口的请求转发至系统的 <code>8080</code> 端口。如果 Spring Boot Actuator 的端口也在 <code>8080</code>，而我们又没对端点做足够的保护，黑客很轻松地就能获取系统的信息。就算做了保护，黑客也能通过端点信息推断出这个系统是通过 Spring Boot 实现的、可能存在哪些漏洞。</p>\n<p>一般我们都会在系统启动后，通过 <code>health</code> 端点来判断系统的健康情况，如果对这个端点做了过多保护，反而不便于获取健康检查结果。</p>\n<p>一种做法是在防火墙或者负载均衡层面，禁止外部访问 Spring Boot Actuator 的 URL，例如，直接禁止访问 <code>/actuator</code> 及其子路径。另一种做法，就是索性让 Actuator 的端点暴露在与业务代码不同的 HTTP 端口上，比如，不再共用 <code>8080</code> 端口，而是单独提供一个 <code>8081</code> 端口，而防火墙和负载均衡设备只知道 <code>8080</code> 端口的存在，也只会转发请求到 <code>8080</code> 端口，就不用担心外部能访问到 <code>8081</code> 端口的问题了。</p>\n<p>通过 <code>management.server.port=8081</code> 能实现设置 Actuator 专属端口的功能。更进一步，我们还可以使用 <code>management.server.base-path</code> 属性（以前是 <code>management.server.servlet.context-path</code>）为 Spring Boot Actuator 设置 Servlet 上下文，默认为空；使用 <code>management.endpoints.web.base-path</code> 属性来调整 <code>/actuator</code> 这个默认的基础路径。如果像下面这样来做设置，就能将 <code>health</code> 端点访问的 URL 调整为 <code>http://localhost:8081/management/my-actuator/health</code> 了：</p>\n<pre class=\"code-rows\"><code>management.server.port=8081\nmanagement.server.base-path=/management\nmanagement.endpoints.web.base-path=/my-actuator</code></pre>\n</blockquote>\n</li>\n</ol>\n\n\n<h3 id=\"nav_point_77\">5.1.3　定制端点信息</h3>\n<p>Spring Boot Actuator 中的每个端点或多或少会有一些属于自己的配置属性，大家可以在 <code>org.springframework.boot:spring-boot-actuator-autoconfigure</code> 包中查看各种以 <code>Properties</code> 结尾的属性类，也可以直接通过 <code>configprops</code> 端点来查看属性类。</p>\n<p>例如，<code>EnvironmentEndpointProperties</code> 就对应了 <code>management.endpoint.env</code> 中的属性，其中的 <code>keysToSanitize</code> 就是环境中要过滤的自定义敏感信息键名清单，根据代码注释，其中可以设置匹配的结尾字符串，也可以使用正则表达式。在设置了 <code>management.endpoint.env.keys-to-sanitize=java.*,sun.*</code> 后，<code>env</code> 端点返回的属性中，所有 <code>java</code> 和 <code>sun</code> 打头的属性值都会以 <code>*</code> 显示。</p>\n<p>Spring Boot Actuator 默认为 <code>info</code> 和 <code>health</code> 端点开启了 HTTP 访问支持，那么就让我们来详细了解一下这两个端点有哪些可以定制的地方吧。</p>\n<ol>\n<li><p><strong>定制 info 端点信息</strong></p>\n<p>根据 <code>InfoEndpointAutoConfiguration</code> 可以得知，<code>InfoEndpoint</code> 中会注入 Spring 上下文中的所有 <code>InfoContributor</code> Bean 实例。<code>InfoContributorAutoConfiguration</code> 自动注册了 <code>env</code>、<code>git</code> 和 <code>build</code> 这三个 <code>InfoContributor</code>，Spring Boot Actuator 提供的 <code>InfoContributor</code> 列表如表 5-5 所示。</p>\n<p><strong>表 5-5　内置 <code>InfoContributor</code> 列表</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>类名</th><th>默认开启</th><th>说明</th></tr><tr><td><code>BuildInfoContributor</code></td><td>是</td><td>提供 <code>BuildProperties</code> 的信息，通过 <code>spring.info.build</code> 来设置，默认读取 <code>META-INF/build-info.properties</code></td></tr><tr><td><code>EnvironmentInfoContributor</code></td><td>是</td><td>将配置中以 <code>info</code> 打头的属性通过端点暴露</td></tr><tr><td><code>GitInfoContributor</code></td><td>是</td><td>提供 <code>GitProperties</code> 的信息，通过 <code>spring.info.git</code> 来设置，默认读取 <code>git.properties</code></td></tr><tr><td><code>InfoPropertiesInfoContributor</code></td><td>否</td><td>抽象类，一般作为其他 <code>InfoContributor</code> 的父类</td></tr><tr><td><code>MapInfoContributor</code></td><td>否</td><td>将内置 <code>Map</code> 作为信息输出</td></tr><tr><td><code>SimpleInfoContributor</code></td><td>否</td><td>仅包含一对键值对的信息</td></tr></table>\n\n<p>假设在配置文件中设置了如下内容：</p>\n<pre class=\"code-rows\"><code>info.app=HelloWorld\ninfo.welcome=Welcome to the world of Spring.</code></pre>\n<p>再提供如下的 Bean：</p>\n<pre class=\"code-rows\"><code>@Bean\npublic SimpleInfoContributor simpleInfoContributor() {\n    return new SimpleInfoContributor(\"simple\", \"HelloWorld!\");\n}</code></pre>\n<p>那 info 端点输出的内容大致如下所示：</p>\n<pre class=\"code-rows\"><code>{\n    \"app\": \"HelloWorld\",\n    \"simple\": \"HelloWorld!\",\n    \"welcome\": \"Welcome to the world of Spring.\"\n}</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>定制 health 端点信息</strong></p>\n<p>健康检查是一个很常用的功能，可以帮助我们了解系统的健康状况，例如，系统在启动后是否准备好对外提供服务了，所依赖的组件是否已就绪等。</p>\n<p>健康检查主要是依赖 <code>HealthIndicator</code><span class=\"comment-number\">5</span> 的各种实现来完成的。Spring Boot Actuator 内置了近 20 种不同的实现，表 5-6 列举了一些常用的 <code>HealthIndicator</code> 实现，基本可以满足日常使用的需求。</p>\n<p><strong>表 5-6　常用的 <code>HealthIndicator</code> 实现</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>实现类</th><th>作用</th></tr><tr><td>`DataSourceHealthIndicator`</td><td>检查 Spring 上下文中能取到的所有 `DataSource` 是否健康</td></tr><tr><td>`DiskSpaceHealthIndicator`</td><td>检查磁盘空间</td></tr><tr><td>`LivenessStateHealthIndicator`</td><td>检查系统的存活（Liveness）情况，一般用于 Kubernetes 中</td></tr><tr><td>`ReadinessStateHealthIndicator`</td><td>检查系统是否处于就绪（Readiness）状态，一般用于 Kubernetes 中</td></tr><tr><td>`RedisHealthIndicator`</td><td>检查所依赖的 Redis 健康情况</td></tr></table>\n\n<p>每个 <code>HealthIndicator</code> 检查后都会有自己的状态信息，Spring Boot Actuator 最后会根据所有结果的状态信息综合得出系统的最终状态。<code>org.springframework.boot.actuate.health.Status</code> 定义了几种默认状态，按照优先级降序排列分别为 <code>DOWN</code>、<code>OUT_OF_SERVICE</code>、<code>UP</code> 和 <code>UNKNOWN</code>，所有结果状态中优先级最高的状态会成为 <code>health</code> 端点的最终状态。如果有需要，我们也可以通过 <code>management.endpoint.health.status.order</code> 来更改状态的优先级。</p>\n<p>Spring Boot Actuator 默认开启了所有的 <code>HealthIndicator</code>，它们会根据情况自行判断是否生效，也可以通过 <code>management.health.defaults.enabled=false</code> 开关（默认关闭），随后使用 <code>management.health.&lt;name&gt;.enabled</code> 选择性地开启 <code>HealthIndicator</code>。例如，<code>DataSourceHealthContributorAutoConfiguration</code> 是这样定义的：</p>\n<pre class=\"code-rows\"><code>@Configuration(proxyBeanMethods = false)\n@ConditionalOnClass({ JdbcTemplate.class, AbstractRoutingDataSource.class })\n@ConditionalOnBean(DataSource.class)\n@ConditionalOnEnabledHealthIndicator(\"db\")\n@AutoConfigureAfter(DataSourceAutoConfiguration.class)\npublic class DataSourceHealthContributorAutoConfiguration extends\n    CompositeHealthContributorConfiguration\n&lt;AbstractHealthIndicator, DataSource&gt;\n    implements InitializingBean {}</code></pre>\n<p>那么它的生效条件是这样的：</p>\n<ul>\n<li>CLASSPATH 中存在 <code>JdbcTemplate</code> 和 <code>AbstractRoutingDataSource</code> 类；</li>\n<li>Spring 上下文中存在 <code>DataSource</code> 类型的 Bean；</li>\n<li>默认开关打开，或者 <code>management.health.db.enabled=true</code>，此处 <code>@ConditionalOnEnabledHealthIndicator</code> 中的 <code>db</code> 就是 <code>name</code><span class=\"comment-number\">6</span>。</li>\n</ul>\n<p>知道了 <code>health</code> 中的各个 <code>HealthIndicator</code> 后，怎么才能看到结果呢？我们可以通过配置 <code>management.endpoint.health.show-details</code> 和 <code>management.endpoint.health.show-components</code> 的属性值来查看结果，默认是 <code>never</code>，将其调整为 <code>always</code> 后就会始终显示具体内容了。如果依赖中存在 Spring Security，也可以仅对授权后的用户开放，将属性值配置为 <code>when-authorized</code>，这时我们可以通过 <code>management.endpoint.health.roles</code> 来设置可以访问的用户的角色。一般情况下，可以考虑将其调整为 <code>always</code>。</p>\n<p>如今越来越多的系统运行在 Kubernetes 环境中，而 Kubernetes 需要检查系统是否存活，是否就绪，对此，<code>health</code> 端点也提供了对应的 <code>LivenessStateHealthIndicator</code> 和 <code>ReadinessStateHealthIndicator</code>，默认 URL 分别为 <code>/actuator/health/liveness</code> 和 <code>/actuator/health/readiness</code>。</p>\n</li>\n</ol>\n\n\n<h3 id=\"nav_point_78\">5.1.4　开发自己的组件与端点</h3>\n<p>在上一节中，我们看到的基本都是对现有端点与组件的配置，Spring Boot Actuator 提供了让我们自己扩展端点或者实现新端点的功能。例如，在进行健康检查时，我们可以加入自己的检查逻辑，只需实现 <code>HealthIndicator</code> 即可。</p>\n<ol>\n<li><p><strong>开发自己的 HealthIndicator</strong></p>\n<p>为了增加自己的健康检查逻辑，我们可以定制一个 HealthIndicator 实现，通常会选择扩展 <code>AbstractHealthIndicator</code> 类，实现其中的 <code>doHealthCheck()</code> 方法。</p>\n<p>根据 <code>HealthEndpointConfiguration</code> 类的代码，我们可以知道 <code>healthContributorRegistry</code> 会从 Spring 上下文获取所有 <code>HealthContributor</code> 类型（<code>HealthIndicator</code> 继承了这个接口）的 Bean，并进行注册，所以我们也只需要把写好的 <code>HealthIndicator</code> 配置为 Bean 即可。</p>\n<pre class=\"code-rows\"><code>@Configuration(proxyBeanMethods = false)\nclass HealthEndpointConfiguration {\n@Bean\n    @ConditionalOnMissingBean\n    HealthContributorRegistry healthContributorRegistry(ApplicationContext applicationContext,\n            HealthEndpointGroups groups) {\n        Map&lt;String, HealthContributor&gt; healthContributors = new LinkedHashMap&lt;&gt;(applicationContext\n            .getBeansOfType(HealthContributor.class));\n        if (ClassUtils.isPresent(\"reactor.core.publisher.Flux\", applicationContext.getClassLoader())) {\n            healthContributors.putAll(new AdaptedReactiveHealthContributors(applicationContext).get());\n        }\n        return new AutoConfiguredHealthContributorRegistry(healthContributors, groups.getNames());\n    }\n    // 省略其他代码\n}</code></pre>\n<p>接下来，我们以第 4 章的 BinaryTea 项目作为基础，在其中添加自己的 <code>HealthIndicator</code>。在 <code>ShopReadyHealthIndicator</code> 上添加 <code>@Component</code> 注解，以便在扫描到它后就能将其注册为 Bean。通过构造方法注入 <code>BinaryTeaProperties</code>，检查时如果没有 <code>binaryTeaProperties</code> 或者属性中的 <code>ready</code> 为 <code>false</code>，检查即为失败，除此之外都算成功。具体如代码示例 5-3 所示。<span class=\"comment-number\">7</span></p>\n<blockquote>\n<p><strong>代码示例 5-3</strong>　<code>ShopReadyHealthIndicator</code> 健康检查器</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Component\npublic class ShopReadyHealthIndicator extends AbstractHealthIndicator{\n    private BinaryTeaProperties binaryTeaProperties;\n\n    public ShopReadyHealthIndicator(ObjectProvider&lt;BinaryTeaProperties&gt; binaryTeaProperties) {\n        this.binaryTeaProperties = binaryTeaProperties.getIfAvailable();\n    }\n\n    @Override\n    protected void doHealthCheck(Health.Builder builder) throws Exception {\n        if (binaryTeaProperties == null || !binaryTeaProperties.isReady()) {\n            builder.down();\n        } else {\n            builder.up();\n        }\n    }\n}</code></pre>\n<p>运行代码前还需要在 pom.xml 中加入 Spring Web 和 Spring Boot Actuator 的依赖，具体如下：</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<p>同时在 <code>application.properties</code> 中增加 <code>management.endpoint.health.show-details=always</code>，以便可以看到 <code>ShopReadyHealthIndicator</code> 的效果。运行 <code>BinaryTeaApplication</code> 后，在浏览器中访问 http://localhost:8080/actuator/health，就能看到类似下面的 JSON 输出：</p>\n<pre class=\"code-rows\"><code>{\n    \"components\": {\n        // 省略部分内容\n        \"ping\": {\n            \"status\": \"UP\"\n        },\n        \"shopReady\": {\n            \"status\": \"UP\"\n        }\n    },\n    \"status\": \"UP\"\n}</code></pre>\n<p>为了能够进行自动测试，我们还可以在 <code>ShopConfigurationEnableTest</code> 和 <code>ShopConfigurationDisableTest</code> 中分别加入对应的测试用例，再写个测试检查是否注册了对应的信息，如代码示例 5-4 所示。</p>\n<blockquote>\n<p><strong>代码示例 5-4</strong>　针对 <code>ShopReadyHealthIndicator</code> 的各种单元测试用例</p>\n</blockquote>\n<pre class=\"code-rows\"><code>// ShopConfigurationEnableTest中的测试用例\n@Test\nvoid testIndicatorUp() {\n    ShopReadyHealthIndicator indicator = applicationContext.getBean(ShopReadyHealthIndicator.class);\n    assertEquals(Status.UP, indicator.getHealth(false).getStatus());\n}\n\n// ShopConfigurationDisableTest中的测试用例\n@Test\nvoid testIndicatorDown() {\n    ShopReadyHealthIndicator indicator = applicationContext.getBean(ShopReadyHealthIndicator.class);\n    assertEquals(Status.DOWN, indicator.getHealth(false).getStatus());\n}\n\n// 独立的ShopReadyHealthIndicatorTest，测试是否注册了shopReady\n@SpringBootTest\npublic class ShopReadyHealthIndicatorTest {\n    @Autowired\n    private HealthContributorRegistry registry;\n\n    @Test\n    void testRegistryContainsShopReady() {\n        assertNotNull(registry.getContributor(\"shopReady\"));\n    }\n}</code></pre>\n<p>如果一切顺利，执行 <code>mvn test</code> 后我们应该就能看到测试通过的信息了：</p>\n<pre class=\"code-rows\"><code>[INFO] Results:\n[INFO]\n[INFO] Tests run: 7, Failures: 0, Errors: 0, Skipped: 0\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------</code></pre>\n<blockquote>\n<p><strong>茶歇时间：为什么要优先通过 <code>ObjectProvider</code> 获取 Bean</strong></p>\n<p>当我们需要从 Spring 上下文中获取其他 Bean 时，最直接的方法是使用 <code>@Autowired</code> 注解，但系统运行时的不确定性太多了，比如不确定是否存在需要的依赖，这时就需要加上 <code>required=false</code> ；也有可能目标类型的 Bean 不止一个，而我们只需要一个；构造方法有多个参数……</p>\n<p>这时就该 <code>ObjectProvider&lt;T&gt;</code> 上场了，它大多用于构造方法注入的场景，让我们有能力处理那些尴尬的场面，其中的 <code>getIfAvailable()</code> 方法在存在对应 Bean 时返回对象，不存在时则返回 <code>null</code>；<code>getIfUnique()</code> 方法在有且仅有一个对应 Bean 时返回对象，Bean 不存在或不唯一，且不唯一时没有标注 <code>Primary</code> 的情况下返回 <code>null</code>。再加上一些检查和遍历的方法，通过明确的编码，我们就可以确保自己的代码获取到必要的依赖，或判断出缺少的东西，并加以处理。</p>\n</blockquote>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>开发自己的端点</strong></p>\n<p>如果内置的端点无法满足我们的需求，那最后一招就是写一个自己的端点。好在 Spring Boot Actuator 支持到位，只需简单几步就能帮助我们实现一个端点。</p>\n<p>首先，在 Bean 上添加 <code>@Endpoint</code> 注解，其中带有 <code>@ReadOperation</code>、<code>@WriteOperation</code> 和 <code>@DeleteOperation</code> 的方法能被发布出来，而且能通过 JMX 或者 HTTP 的方式访问到这些方法</p>\n<p>接下来，如果我们希望限制只用其中的一种方式来发布，则可以将 <code>@Endpoint</code> 替换为 <code>@JmxEndpoint</code> 或 <code>@WebEndpoint</code>。</p>\n<p>如果是通过 HTTP 方式访问的，默认的 URL 是 <code>/actuator/&lt;id&gt;</code>，其中的 <code>id</code> 就是 <code>@Endpoint</code> 注解中指定的 <code>id</code>，而 <code>@ReadOperation</code>、<code>@WriteOperation</code> 和 <code>@DeleteOperation</code> 的方法分别对应了 HTTP 的 <code>GET</code>、<code>POST</code> 和 <code>DELETE</code> 方法。HTTP 的响应码则取决于方法的返回值，如果存在返回内容，则响应码是 <code>200 OK</code>，否则 <code>@ReadOperation</code> 方法会返回 <code>404 Not Found</code>，而另两个则返回 <code>204 No Content</code>；对于需要参数但又获取不到的情况，方法会返回 <code>400 Bad Request</code>。</p>\n<p>我们为 BinaryTea 编写了一个返回商店状态的端点，具体如代码示例 5-5 所示，大部分逻辑与 <code>ShopReadyHealthIndicator</code> 是类似的，这里就不再赘述了。</p>\n<blockquote>\n<p><strong>代码示例 5-5</strong>　<code>ShopEndpoint</code> 代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Component\n@Endpoint(id = \"shop\")\npublic class ShopEndpoint {\n    private BinaryTeaProperties binaryTeaProperties;\n\n    public ShopEndpoint(ObjectProvider&lt;BinaryTeaProperties&gt; binaryTeaProperties) {\n        this.binaryTeaProperties = binaryTeaProperties.getIfAvailable();\n    }\n\n    @ReadOperation\n    public String state() {\n        if (binaryTeaProperties == null || !binaryTeaProperties.isReady()) {\n            return \"We're not ready.\";\n        } else {\n            return \"We open \" + binaryTeaProperties.getOpenHours() + \".\";\n        }\n    }\n}</code></pre>\n<p>为了能访问到我们的端点，需要在 <code>application.properties</code> 中允许它以 Web 形式发布：</p>\n<pre class=\"code-rows\"><code>management.endpoints.web.exposure.include=health,info,shop</code></pre>\n<p>启动系统后，通过 <code>http://localhost:8080/actuator/shop</code> 即可访问 <code>ShopEndpoint</code> 的输出。</p>\n</li>\n</ol>\n\n<h2 id=\"nav_point_79\">5.2　基于 Micrometer 的系统度量</h2>\n<p>系统在生产环境中运行时，我们需要通过各种方式了解系统的运作是否正常。之前提到的 <code>health</code> 端点只能判断最基本的情况，至于更多细节，还需要获取详细的度量指标，<code>metrics</code> 端点就是用来提供系统度量信息的。</p>\n<h3 id=\"nav_point_80\">5.2.1　Micrometer 概述</h3>\n<p>从 2.0 版本开始，Spring Boot 就把 Micrometer 作为默认的系统度量指标获取途径了 <span class=\"comment-number\">8</span>，因此本节也先从 Micrometer 讲起。</p>\n\n<p>Java 开发者应该都很熟悉 SLF4J（Simple Logging Facade for Java），它提供了一套日志框架的抽象，屏蔽了底层不同日志框架（比如 Commons Logging、Log4j 和 Logback）实现上的差异，让开发者能以统一的方式在代码中打印日志。如果说 Micrometer 的目标就是成为度量界的 SLF4J，相信大家就能理解 Micrometer 是干什么的了。</p>\n<p>Micrometer 为很多主流的监控系统提供了一套简单且强大的客户端门面，先是定义了一套 SPI（Service Provider Interface），再为不同的监控系统提供实现。接入 Micrometer 后，开发者通过 Micrometer 进行埋点时就不会被绑定在某个特定的监控系统上。它支持的监控系统，以及这些系统的特性，如表 5-7 所示。</p>\n<p><strong>表 5-7　Micrometer 支持的监控系统清单</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>监控系统</p></th>\n<th><p>是否支持多维度<span class=\"comment-number\">9</span></p></th>\n<th><p>数据聚合方式</p></th>\n<th><p>数据获取方式</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>AppOptics</p></td>\n<td><p>是</p></td>\n<td><p>客户端聚合</p></td>\n<td><p>客户端推</p></td>\n</tr>\n<tr>\n<td><p>Atlas</p></td>\n<td><p>是</p></td>\n<td><p>客户端聚合</p></td>\n<td><p>客户端推</p></td>\n</tr>\n<tr>\n<td><p>Azure Monitor</p></td>\n<td><p>是</p></td>\n<td><p>客户端聚合</p></td>\n<td><p>客户端推</p></td>\n</tr>\n<tr>\n<td><p>Cloudwatch</p></td>\n<td><p>是</p></td>\n<td><p>客户端聚合</p></td>\n<td><p>客户端推</p></td>\n</tr>\n<tr>\n<td><p>Datadog</p></td>\n<td><p>是</p></td>\n<td><p>客户端聚合</p></td>\n<td><p>客户端推</p></td>\n</tr>\n<tr>\n<td><p>Datadog StatsD</p></td>\n<td><p>是</p></td>\n<td><p>客户端聚合</p></td>\n<td><p>服务端拉</p></td>\n</tr>\n<tr>\n<td><p>Dynatrace</p></td>\n<td><p>是</p></td>\n<td><p>客户端聚合</p></td>\n<td><p>客户端推</p></td>\n</tr>\n<tr>\n<td><p>Elastic</p></td>\n<td><p>是</p></td>\n<td><p>客户端聚合</p></td>\n<td><p>客户端推</p></td>\n</tr>\n<tr>\n<td><p>Etsy StatsD</p></td>\n<td><p>否</p></td>\n<td><p>客户端聚合</p></td>\n<td><p>服务端拉</p></td>\n</tr>\n<tr>\n<td><p>Ganglia</p></td>\n<td><p>否</p></td>\n<td><p>客户端聚合</p></td>\n<td><p>客户端推</p></td>\n</tr>\n<tr>\n<td><p>Graphite</p></td>\n<td><p>否</p></td>\n<td><p>客户端聚合</p></td>\n<td><p>客户端推</p></td>\n</tr>\n<tr>\n<td><p>Humio</p></td>\n<td><p>是</p></td>\n<td><p>客户端聚合</p></td>\n<td><p>客户端推</p></td>\n</tr>\n<tr>\n<td><p>Influx</p></td>\n<td><p>是</p></td>\n<td><p>客户端聚合</p></td>\n<td><p>客户端推</p></td>\n</tr>\n<tr>\n<td><p>JMX</p></td>\n<td><p>否</p></td>\n<td><p>客户端聚合</p></td>\n<td><p>客户端推</p></td>\n</tr>\n<tr>\n<td><p>KairosDB</p></td>\n<td><p>是</p></td>\n<td><p>客户端聚合</p></td>\n<td><p>客户端推</p></td>\n</tr>\n<tr>\n<td><p>New Relic</p></td>\n<td><p>是</p></td>\n<td><p>客户端聚合</p></td>\n<td><p>客户端推</p></td>\n</tr>\n<tr>\n<td><p>Prometheus</p></td>\n<td><p>是</p></td>\n<td><p>服务端聚合</p></td>\n<td><p>服务端拉</p></td>\n</tr>\n<tr>\n<td><p>SignalFx</p></td>\n<td><p>是</p></td>\n<td><p>客户端聚合</p></td>\n<td><p>客户端推</p></td>\n</tr>\n<tr>\n<td><p>Sysdig StatsD</p></td>\n<td><p>是</p></td>\n<td><p>客户端聚合</p></td>\n<td><p>服务端拉</p></td>\n</tr>\n<tr>\n<td><p>Telegraf StatsD</p></td>\n<td><p>是</p></td>\n<td><p>客户端聚合</p></td>\n<td><p>服务端拉</p></td>\n</tr>\n<tr>\n<td><p>Wavefront</p></td>\n<td><p>是</p></td>\n<td><p>服务端聚合</p></td>\n<td><p>客户端推</p></td>\n</tr>\n</tbody>\n</table>\n\n<p>Micrometer 通过 <code>Meter</code> 接口来收集系统的度量数据，由 <code>MeterRegistry</code> 来创建并管理 <code>Meter</code>，Micrometer 支持的各种监控系统都有自己的 <code>MeterRegistry</code> 实现。内置的 <code>Meter</code> 实现分为几种，具体如表 5-8 所示。</p>\n<p><strong>表 5-8　几种主要的 <code>Meter</code> 实现</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p><code>Meter</code> 类型</p></th>\n<th><p>说明</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>Timer</code></p></td>\n<td><p>计时器，用来记录一个事件的耗时</p></td>\n</tr>\n<tr>\n<td><p><code>Counter</code></p></td>\n<td><p>计数器，用来表示一个单调递增的值</p></td>\n</tr>\n<tr>\n<td><p><code>Gauge</code></p></td>\n<td><p>计量仪，用来表示一个变化的值，通常能用 <code>Counter</code> 就不用 <code>Gauge</code></p></td>\n</tr>\n<tr>\n<td><p><code>DistributionSummary</code></p></td>\n<td><p>分布统计，用来记录事件的分布情况，可以设置一个范围，获取范围内的直方图和百分位数</p></td>\n</tr>\n<tr>\n<td><p><code>LongTaskTimer</code></p></td>\n<td><p>长任务计时器，记录一个长时间任务的耗时，可以记录已经耗费的时间</p></td>\n</tr>\n<tr>\n<td><p><code>FunctionCounter</code></p></td>\n<td><p>函数计数器，追踪某个单调递增函数的计数器</p></td>\n</tr>\n<tr>\n<td><p><code>FunctionTimer</code></p></td>\n<td><p>函数计时器，追踪两个单调递增函数，一个计数，另一个计时</p></td>\n</tr>\n</tbody>\n</table>\n<p>要创建 <code>Meter</code>，既可以通过 <code>MeterRegistry</code> 上的方法，例如 <code>registry.timer(\"foo\")</code>，也可以通过 Fluent 风格的构建方法，例如 <code>Timer.builder(\"foo\").tags(\"bar\").register(registry)</code>。<code>Meter</code> 的命名采用以 <code>.</code> 分隔的全小写单词组合，不同的监控系统功能有不同的命名方式，Micrometer 会负责将 <code>Meter</code> 的名称转为合适的方式，在官方文档中就给出了这样一个例子：</p>\n<pre class=\"code-rows\"><code>registry.timer(\"http.server.requests\");</code></pre>\n<p>在使用 Prometheus 时，这个 <code>Timer</code> 的名字就会被转为 <code>http_server_requests_duration_seconds</code>。</p>\n<p>标签也遵循一样的命名方式，Micrometer 同样也会负责帮我们将 <code>Timer</code> 的标签转换成不同监控系统所推荐的名称。下面的标签名为 <code>uri</code>，值为 <code>/api/orders</code>：</p>\n<pre class=\"code-rows\"><code>registry.timer(\"http.server.requests\", \"uri\", \"/api/orders\");</code></pre>\n<p>针对通用的标签，Micrometer 还贴心地提供了公共标签的功能，在 <code>MeterRegistry</code> 上设置标签：</p>\n<pre class=\"code-rows\"><code>registry.config().commonTags(\"prod\", \"region\", \"cn-shanghai-1\");</code></pre>\n<h3 id=\"nav_point_81\">5.2.2　常用度量指标</h3>\n<p>Spring Boot Actuator 中提供了 <code>metrics</code> 端点，通过 <code>/actuator/metrics</code> 我们可以获取系统的度量值。而且 Spring Boot 还内置了很多实用的指标，可以直接拿来使用。</p>\n<p>首先介绍的是 Micrometer 本身支持的 JVM 相关指标，具体见表 5-9。</p>\n<p><strong>表 5-9　Micrometer 支持的 JVM 度量指标</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>度量指标</p></th>\n<th><p>说明</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>ClassLoaderMetrics</code></p></td>\n<td><p>收集加载和卸载的类信息</p></td>\n</tr>\n<tr>\n<td><p><code>JvmMemoryMetrics</code></p></td>\n<td><p>收集 JVM 内存利用情况</p></td>\n</tr>\n<tr>\n<td><p><code>JvmGcMetrics</code></p></td>\n<td><p>收集 JVM 的 GC 情况</p></td>\n</tr>\n<tr>\n<td><p><code>ProcessorMetrics</code></p></td>\n<td><p>收集 CPU 负载情况</p></td>\n</tr>\n<tr>\n<td><p><code>JvmThreadMetrics</code></p></td>\n<td><p>收集 JVM 中的线程情况</p></td>\n</tr>\n</tbody>\n</table>\n<p>用下面的语句就能绑定一个 <code>ClassLoaderMetrics</code>：</p>\n<pre class=\"code-rows\"><code>new ClassLoaderMetrics().bindTo(registry);</code></pre>\n<p>但在 Spring Boot Actuator 的帮助下，我们无须自己来绑定这些度量指标，Spring Boot 中 <code>JvmMetricsAutoConfiguration</code> 之类的自动配置类已经替我们做好了绑定的工作。此外，它还在此基础上提供了 Spring MVC、Spring WebFlux、HTTP 客户端和数据源等其他度量指标。</p>\n<p>仍然以 5.1.4 节的 binarytea-endpoint 为例，我们在 <code>application.properties</code> 中做些修改，将 <code>metrics</code> 端点加入 Web 可访问的端点中：</p>\n<pre class=\"code-rows\"><code>management.endpoints.web.exposure.include=health,info,shop,metrics</code></pre>\n<p>启动程序后，通过 <code>http://localhost:8080/actuator/metrics</code> 可以看到类似下面这样的一个清单，其中列举的 <code>names</code> 就是具体的度量指标名称：</p>\n<pre class=\"code-rows\"><code>{\n    \"names\": [\n        \"http.server.requests\",\n        \"jvm.buffer.count\",\n        \"jvm.buffer.memory.used\",\n        \"jvm.buffer.total.capacity\",\n        \"jvm.classes.loaded\",\n        \"jvm.classes.unloaded\",\n        \"jvm.gc.live.data.size\",\n        \"jvm.gc.max.data.size\",\n        \"jvm.gc.memory.allocated\",\n        \"jvm.gc.pause\",\n        \"jvm.memory.max\",\n        \"jvm.memory.used\",\n        \"jvm.threads.live\",\n        \"jvm.threads.peak\",\n        \"logback.events\",\n        \"process.cpu.usage\",\n        \"process.files.max\",\n        \"process.start.time\",\n        \"process.uptime\",\n        \"system.cpu.usage\",\n        \"system.load.average.1m\",\n        \"tomcat.sessions.active.current\",\n        \"tomcat.sessions.active.max\",\n        \"tomcat.sessions.rejected\"\n        // 列表中省略了一些内容\n    ]\n}</code></pre>\n<p>在 URI 后增加具体的名称，例如，<code>http://localhost:8080/actuator/metrics/jvm.classes.loaded</code>，就能查看具体的度量信息：</p>\n<pre class=\"code-rows\"><code>{\n    \"availableTags\": [\n\n    ],\n    \"baseUnit\": \"classes\",\n    \"description\": \"The number of classes that are currently loaded in the Java virtual machine\",\n    \"measurements\": [\n        {\n        \"statistic\": \"VALUE\",\n        \"value\": 7232.0\n        }\n    ],\n    \"name\": \"jvm.classes.loaded\"\n}</code></pre>\n<ol>\n<li><p><strong>Spring MVC</strong></p>\n<p>默认所有基于 Spring MVC 的 Web 请求都会被记录下来，通过 <code>/actuator/metrics/http.server.requests</code> 我们可以查看类似下面这样的输出，其中包含了大量的信息，比如用过的 HTTP 方法、访问过的地址、返回的 HTTP 响应码、请求的总次数和总耗时，以及最大单次耗时等：</p>\n<pre class=\"code-rows\"><code>{\n    \"availableTags\": [\n        { \"tag\": \"exception\", \"values\": [\"None\"] },\n        { \"tag\": \"method\", \"values\": [\"GET\"] },\n        {\n            \"tag\": \"uri\",\n            \"values\": [\n                \"/actuator/metrics/\",\n                \"/actuator/metrics\"\n            ]\n        },\n        { \"tag\": \"outcome\", \"values\": [\"SUCCESS\"] },\n        { \"tag\": \"status\", \"values\": [\"200\"] }\n    ],\n    \"baseUnit\": \"seconds\",\n    \"description\": null,\n    \"measurements\": [\n        { \"statistic\": \"COUNT\", \"value\": 5.0 },\n        { \"statistic\": \"TOTAL_TIME\", \"value\": 0.085699938 },\n        { \"statistic\": \"MAX\", \"value\": 0.042694752 }\n    ],\n    \"name\": \"http.server.requests\"\n}</code></pre>\n<p><code>management.metrics.web.server.request.autotime.enabled</code> 默认为 <code>true</code>，它能自动统计所有的 Web 请求，如果我们将它设置为 <code>false</code>，则需要自己在类上或者方法上添加 <code>@Timed</code> 来标记要统计的 <code>Controller</code> 方法 <span class=\"comment-number\">10</span>，<code>@Timed</code> 注解可以做些更精细的设置，例如，添加额外的标签，计算百分位数，等等：</p>\n<pre class=\"code-rows\"><code>@Controller\npublic class SampleController {\n    @RequestMapping(\"/\")\n    @Timed(extraTags = { \"region\", \"cn-shanghai-1\" }, percentiles = 0.99)\n    public String foo() {}\n}</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>HTTP 客户端</strong></p>\n<p>当使用 <code>RestTemplate</code> 和 <code>WebClient</code> 访问 HTTP 服务时 <span class=\"comment-number\">11</span>，Spring Boot Actuator 提供了针对 HTTP 客户端的度量指标，但这并不是自动的，还需要做一些配置它们才能生效。这里建议通过如下方式来创建 <code>RestTemplate</code>：</p>\n<pre class=\"code-rows\"><code>@Bean\npublic RestTemplate restTemplate(RestTemplateBuilder builder) {\n    return builder.build();\n}</code></pre>\n<p>使用 <code>RestTemplateBuilder</code> 来构建 <code>RestTemplate</code> 时，会对其应用所有配置在 Spring 上下文里的 <code>RestTemplateCustomizer</code>，而其中就有与度量相关的 <code>MetricsRestTemplateCustomizer</code>。针对 <code>WebClient</code> 也是一样的，可以用 <code>WebClient.Builder</code>。</p>\n<p>如果大家有通过 <code>RestTemplate</code> 访问过 HTTP 服务，访问 <code>/actuator/metrics/http.client.requests</code> 后就能看到类似下面这样的输出：</p>\n<pre class=\"code-rows\"><code>{\n    \"availableTags\": [\n        { \"tag\": \"method\", \"values\": [ \"GET\" ] },\n        { \"tag\": \"clientName\", \"values\": [ \"localhost\" ] },\n        { \"tag\": \"uri\", \"values\": [ \"/actuator/metrics\" ] },\n        { \"tag\": \"outcome\", \"values\": [ \"SUCCESS\" ] },\n        { \"tag\": \"status\", \"values\": [ \"200\" ] }\n    ],\n    \"baseUnit\": \"seconds\",\n    \"description\": \"Timer of RestTemplate operation\",\n    \"measurements\": [\n        { \"statistic\": \"COUNT\", \"value\": 1.0 },\n        { \"statistic\": \"TOTAL_TIME\", \"value\": 0.115555898 },\n        { \"statistic\": \"MAX\", \"value\": 0.115555898 }\n    ],\n    \"name\": \"http.client.requests\"\n}</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>数据源</strong></p>\n<p>对于那些使用了数据库的系统，了解数据源的具体情况是非常有必要的，例如，当前的连接池配置的大小是什么样的，有多少个连接处于活跃状态等。如果连接池经常被占满，导致业务代码无法获取连接，那么无论是让业务线程等待连接，还是等待超时后报错都可能影响业务。</p>\n<p>只要在 Spring 上下文中存在 <code>DataSource</code><span class=\"comment-number\">12</span> Bean，Spring Boot Actuator 就会自动配置对应的度量指标，如果我们使用的是 HikariCP，还会有额外的信息。访问 <code>/actuator/metrics</code> 后能看到下面这些显示：</p>\n<pre class=\"code-rows\"><code>{\n    \"names\": [\n        \"hikaricp.connections\",\n        \"hikaricp.connections.acquire\",\n        \"hikaricp.connections.active\",\n        \"hikaricp.connections.creation\",\n        \"hikaricp.connections.idle\",\n        \"hikaricp.connections.max\",\n        \"hikaricp.connections.min\",\n        \"hikaricp.connections.pending\",\n        \"hikaricp.connections.timeout\",\n        \"hikaricp.connections.usage\",\n        \"jdbc.connections.max\",\n        \"jdbc.connections.min\"\n        // 省略其他无关的内容\n    ]\n}</code></pre>\n<p>而具体到 <code>/actuator/metrics/hikaricp.connections</code> 则是这样的：</p>\n<pre class=\"code-rows\"><code>{\n    \"availableTags\": [\n        { \"tag\": \"pool\", \"values\": [ \"HikariPool-1\" ] }\n    ],\n    \"baseUnit\": null,\n    \"description\": \"Total connections\",\n    \"measurements\": [\n        { \"statistic\": \"VALUE\", \"value\": 10.0 }\n    ],\n    \"name\": \"hikaricp.connections\"\n}</code></pre>\n<p>通过这些度量指标，我们可以轻松地掌握系统中数据源的大概情况，在遇到问题时更好地进行决策。</p>\n</li>\n</ol>\n\n\n\n<h3 id=\"nav_point_82\">5.2.3　自定义度量指标</h3>\n<p>Spring Boot Actuator 内置的度量指标可以帮助我们掌握系统的情况，但光了解系统是远远不够的，系统运行正常，但业务指标却一路下滑的情况并不少见，因此还需要针对各种业务做对应的数据埋点，通过业务指标我们也可以反过来进一步了解系统的情况。</p>\n<p>有两种绑定 <code>Meter</code> 的方法，一般可以考虑使用后者：</p>\n<ul>\n<li>注入 Spring 上下文中的 <code>MeterRegistry</code>，通过它来绑定 <code>Meter</code>；</li>\n<li>让 Bean 实现 <code>MeterBinder</code>，在其 <code>bindTo()</code> 方法中绑定 <code>Meter</code>。</li>\n</ul>\n<p>下面，让我们通过二进制奶茶店项目中的一个例子来了解一下如何自定义度量指标。</p>\n<blockquote>\n<p><strong>需求描述</strong>　门店开始营业后，我们要频繁关注经营情况，像订单总笔数、总金额、客单价等都是常见的经营指标，最好能有个地方可以让经营者方便地看到这些信息。</p>\n</blockquote>\n<p>以 5.1.4 节的 binarytea-endpoint 作为基础，增加如表 5-10 所示的三个经营指标，用来记录自开始营业起的经营情况，相信是个经营者都关心自己的店是不是赚钱吧？大家可以在本书配套示例的 ch5/binarytea-metrics 目录中找到这个例子。</p>\n<p><strong>表 5-10　三个经营指标</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>指标名称</p></th>\n<th><p>类型</p></th>\n<th><p>含义</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>order.count</code></p></td>\n<td><p><code>Counter</code></p></td>\n<td><p>总订单数</p></td>\n</tr>\n<tr>\n<td><p><code>order.amount.sum</code></p></td>\n<td><p><code>Counter</code></p></td>\n<td><p>总订单金额</p></td>\n</tr>\n<tr>\n<td><p><code>order.amount.average</code></p></td>\n<td><p><code>Gauge</code></p></td>\n<td><p>客单价</p></td>\n</tr>\n</tbody>\n</table>\n<p>除此之外，为了演示 <code>DistributionSummary</code> 的用法，我们还额外增加了一个 <code>order.summary</code> 的指标，可以输出 95 分位的订单情况 <span class=\"comment-number\">13</span>。对应的 <code>Meter</code> 配置与绑定代码如代码示例 5-6 所示，其中绑定了四个 <code>Meter</code>（为了方便演示，客单价使用了一个整数），还提供了一个新的下订单方法，用来改变各 <code>Meter</code> 的值。</p>\n\n<blockquote>\n<p><strong>代码示例 5-6</strong>　<code>SalesMetrics</code> 的代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Component\npublic class SalesMetrics implements MeterBinder {\n    private Counter orderCount;\n    private Counter totalAmount;\n    private DistributionSummary orderSummary;\n    private AtomicInteger averageAmount = new AtomicInteger();\n\n    @Override\n    public void bindTo(MeterRegistry registry) {\n        this.orderCount = registry.counter(\"order.count\", \"direction\", \"income\");\n        this.totalAmount = registry.counter(\"order.amount.sum\", \"direction\", \"income\");\n        this.orderSummary = registry.summary(\"order.summary\", \"direction\", \"income\");\n        registry.gauge(\"order.amount.average\", averageAmount);\n    }\n\n    public void makeNewOrder(int amount) {\n        orderCount.increment();\n        totalAmount.increment(amount);\n        orderSummary.record(amount);\n        averageAmount.set((int) orderSummary.mean());\n    }\n}</code></pre>\n<p>由于现阶段还没有开发下单的客户端，我们可以在 <code>BinaryTeaApplication</code> 这个主程序中通过 2.4.2 节中介绍的定时任务来定时下单，如代码示例 5-7 所示，其中金额为 0 至 100 元内的随机整数 <span class=\"comment-number\">14</span>，每隔 5 秒会下一单并打印日志。</p>\n\n<blockquote>\n<p><strong>代码示例 5-7</strong>　可以定时下单的主程序代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootApplication\n@EnableScheduling\npublic class BinaryTeaApplication {\n    private static Logger logger = LoggerFactory.getLogger(BinaryTeaApplication.class);\n    private Random random = new Random();\n    @Autowired\n    private SalesMetrics salesMetrics;\n\n    public static void main(String[] args) {\n        SpringApplication.run(BinaryTeaApplication.class, args);\n    }\n\n    @Scheduled(fixedRate = 5000, initialDelay = 1000)\n    public void periodicallyMakeAnOrder() {\n        int amount = random.nextInt(100);\n        salesMetrics.makeNewOrder(amount);\n        logger.info(\"Make an order of RMB {} yuan.\", amount);\n    }\n}</code></pre>\n<p>此时，通过 <code>/actuator/metrics</code> 我们会看到多出了如下几个指标：</p>\n<pre class=\"code-rows\"><code class=\"language-{\">    \"names\": [\n        \"order.amount.average\",\n        \"order.amount.sum\",\n        \"order.count\",\n        \"order.summary\",\n        // 省略其他内容\n    ]\n}</code></pre>\n<p>具体访问 <code>/actuator/metrics/order.summary</code> 则能看到类似下面这样的输出：</p>\n<pre class=\"code-rows\"><code>{\n    \"availableTags\": [\n        { \"tag\": \"direction\", \"values\": [ \"income\" ] }\n    ],\n    \"baseUnit\": null,\n    \"description\": null,\n    \"measurements\": [\n        { \"statistic\": \"COUNT\", \"value\": 168.0 },\n        { \"statistic\": \"TOTAL\", \"value\": 7890.0 },\n        { \"statistic\": \"MAX\", \"value\": 95.0 }\n    ],\n    \"name\": \"order.summary\"\n}</code></pre>\n<p>Spring Boot Actuator 中可以对 Micrometer 的度量指标做很多定制，我们既可以按照 Micrometer 的官方做法用 <code>MeterFilter</code> 精确地进行调整，也可以简单地使用配置来做些常规的改动。</p>\n<p>例如，可以像下面这样来设置公共标签，将 <code>region</code> 标签的值设置为 <code>cn-shanghai-1</code>：</p>\n<pre class=\"code-rows\"><code>management.metrics.tags.region=cn-shanghai-1</code></pre>\n<p>针对每个 <code>Meter</code> 也有一些对应的属性，如表 5-11 所示，表中给出的是前缀，在其后面带上具体的度量指标名称后，即可有针对性地进行设置了，例如 <code>management.metrics.enable.order.amount.average=false</code>。</p>\n<p><strong>表 5-11　部分针对单个 <code>Meter</code> 的属性前缀</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>属性前缀</p></th>\n<th><p>说明</p></th>\n<th><p>适用范围</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>management.metrics.enable</code></p></td>\n<td><p>是否开启</p></td>\n<td><p>全部</p></td>\n</tr>\n<tr>\n<td><p><code>management.metrics.distribution.minimum-expected-value</code></p></td>\n<td><p>分布统计时范围的最小值</p></td>\n<td><p><code>Timer</code> 与 <code>DistributionSummary</code></p></td>\n</tr>\n<tr>\n<td><p><code>management.metrics.distribution.maximum-expected-value</code></p></td>\n<td><p>分布统计时范围的最大值</p></td>\n<td><p><code>Timer</code> 与 <code>DistributionSummary</code></p></td>\n</tr>\n<tr>\n<td><p><code>management.metrics.distribution.percentiles</code></p></td>\n<td><p>分布统计时希望计算的百分位值</p></td>\n<td><p><code>Timer</code> 与 <code>DistributionSummary</code></p></td>\n</tr>\n</tbody>\n</table>\n<p>如果希望输出 95 分位的订单情况，可以像代码示例 5-8 那样修改 <code>application.properties</code> 文件。</p>\n<blockquote>\n<p><strong>代码示例 5-8</strong>　修改后的 <code>application.properties</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>binarytea.ready=true\nbinarytea.open-hours=8:30-22:00\n\nmanagement.endpoint.health.show-details=always\nmanagement.endpoints.web.exposure.include=health,info,shop,metrics\n\nmanagement.metrics.distribution.percentiles.order.summary=0.95</code></pre>\n<p>配置后会多出一个 <code>order.summary.percentile</code> 的度量指标，具体的内容大致如下所示：</p>\n<pre class=\"code-rows\"><code>{\n    \"availableTags\": [\n        { \"tag\": \"phi\", \"values\": [ \"0.95\" ] },\n        { \"tag\": \"direction\", \"values\": [ \"income\" ] }\n    ],\n    \"baseUnit\": null,\n    \"description\": null,\n    \"measurements\": [\n        { \"statistic\": \"VALUE\", \"value\": 87 }\n    ],\n    \"name\": \"order.summary.percentile\"\n}</code></pre>\n<blockquote>\n<p><strong>茶歇时间：性能分析时的 95 线与 99 线是什么含义</strong></p>\n<p>说到衡量一个接口的耗时怎么样，大家的第一反应大多是使用平均响应时间。的确，平均耗时能代表大部分情况下接口的表现。假设一个接口的最小耗时为 4 毫秒，平均耗时为 8 毫秒—看起来性能挺好的，但如果经常会有那么几个请求的时间超过 1000 毫秒，那我们是否应该继续去优化它呢？</p>\n<p>答案是肯定的，对于这类长尾的请求，我们还需要去做进一步的分析，这其中必然隐藏着一些问题。在性能测试中，我们往往会更多地关注 TP95 或者 TP99（TP 是 Top Percentile 的缩写），也就是通常所说的 95 线和 99 线指标。在 100 个请求中，按耗时从小到大排序，第 95 个就是耗时的 95 线，95%的请求都能在这个时间内完成。</p>\n<p>还有更苛刻的条件是要去分析 TP9999，也就是 99.99%的情况，这样才能确保绝大部分请求的耗时都达到要求。</p>\n</blockquote>\n<h3 id=\"nav_point_83\">5.2.4　度量值的输出</h3>\n<p>通过 <code>/actuator/metrics</code> 虽然可以看到每个度量值的情况，但我们无法一直盯着这个 URI 看输出。在实际生产环境中，我们需要一个更成熟的度量值输出和收集的方案。好在 Micrometer 和 Spring Boot 早已经考虑到了这些，为我们准备好了。</p>\n<ol>\n<li><p><strong>输出到日志</strong></p>\n<p>Micrometer 提供了几个基本的 <code>MeterRegistry</code>，其中之一就是 <code>LoggingMeterRegistry</code>，它可以定时将系统中的各个度量指标输出到日志中。有了结构化的日志信息，就能通过 ELK（Elasticsearch、Logstash 和 Kibana）等方式将它们收集起来，并加以分析。即使不做后续处理，把这些日志放着，作为日后回溯的材料也是可以的。</p>\n<p>前一节的例子中，在 <code>BinaryTeaApplication</code> 里加上代码示例 5-9 的代码 <span class=\"comment-number\">15</span>，用来定义一个组合的 <code>MeterRegistry</code>，其中添加了基础的 <code>SimpleMeterRegistry</code> 和输出日志的 <code>LoggingMeterRegistry</code>。</p>\n<blockquote>\n<p><strong>代码示例 5-9</strong>　组合多个 <code>MeterRegistry</code> 的定义</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Bean\npublic MeterRegistry customMeterRegistry() {\n    CompositeMeterRegistry meterRegistry = new CompositeMeterRegistry();\n    meterRegistry.add(new SimpleMeterRegistry());\n    meterRegistry.add(new LoggingMeterRegistry());\n    return meterRegistry;\n}</code></pre>\n<p>运行后，过一段时间就能在控制台输出的日志中看到类似下面的内容：</p>\n<pre class=\"code-rows\"><code>2022-02-06 22:44:00.029 INFO 50342 --- [trics-publisher] i.m.c.i.logging.LoggingMeterRegistry : jvm.gc.\npause throughput=0.033333/s mean=0.012s max=0.012s\n2022-02-06 22:44:00.030 INFO 50342 --- [trics-publisher] i.m.c.i.logging.LoggingMeterRegistry : order.\nsummary throughput=0.133333/s mean=40.125 max=84</code></pre>\n<p>在生产环境中使用时，我们可以调整日志的配置文件，将 <code>LoggingMeterRegistry</code> 输出的日志打印到单独的日志中，方便管理。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>输出到 Prometheus</strong></p>\n<p>在介绍 Mircometer 时，我们提到过它支持多种不同的监控系统，将度量信息直接输出到监控系统也是一种常见做法。下面以 Prometheus 为例，介绍一下它在 Spring Boot 系统中该如何操作。</p>\n<p>首先，需要在项目的 pom.xml 中添加 Micrometer 为 Prometheus 编写的 <code>MeterRegistry</code> 依赖，有了这个依赖，后面的事交给 Spring Boot 的自动配置即可：</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.micrometer&lt;/groupId&gt;\n    &lt;artifactId&gt;micrometer-registry-prometheus&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<p>随后，在 <code>application.properties</code> 中放开对对应端点的控制，让 <code>prometheus</code> 端点可以通过 Web 访问：</p>\n<pre class=\"code-rows\"><code>management.endpoints.web.exposure.include=health,info,shop,metrics,prometheus</code></pre>\n<p>再次运行我们的程序，在浏览器中访问 <code>/actuator/prometheus</code> 就能看到一个文本输出，Prometheus 在经过适当配置后会读取其中的内容，可以看到其中的名称已经从 Micrometer 的以点分隔，变为了 Prometheus 的下划线分隔，这也是 Micrometer 实现的：</p>\n<pre class=\"code-rows\"><code># 省略了很多内容，以下仅为片段\njvm_memory_max_bytes 2.44105216E8\n# HELP order_count_total\n# TYPE order_count_total counter\norder_count_total 7.0\n# HELP order_summary_max\n# TYPE order_summary_max gauge\norder_summary_max 76.0\n# HELP order_summary\n# TYPE order_summary summary\norder_summary 79.5\norder_summary_count 7.0\norder_summary_sum 347.0\n# HELP tomcat_sessions_active_current_sessions\n# TYPE tomcat_sessions_active_current_sessions gauge\ntomcat_sessions_active_current_sessions 0.0</code></pre>\n</li>\n</ol>\n\n","neighbors":{"left":{"article_title":"第 4 章 从 Spring Framework 到 Spring Boot(2)","id":740865},"right":{"article_title":"第 5 章 面向生产的 Spring Boot(2)","id":740867}},"comments":[{"had_liked":false,"id":388093,"user_name":"kaiven_z","can_delete":false,"product_type":"c1","uid":3224759,"ip_address":"山东","ucode":"A5325FE4BFFA16","user_header":"https://static001.geekbang.org/account/avatar/00/31/34/b7/97378734.jpg","comment_is_top":false,"comment_ctime":1709302996,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636606,"comment_content":"请问老师，测试代码种该如何判断自定义端点是否启用","like_count":0},{"had_liked":false,"id":388062,"user_name":"kaiven_z","can_delete":false,"product_type":"c1","uid":3224759,"ip_address":"山东","ucode":"A5325FE4BFFA16","user_header":"https://static001.geekbang.org/account/avatar/00/31/34/b7/97378734.jpg","comment_is_top":false,"comment_ctime":1709272782,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636606,"comment_content":"在课程默认的2.6.3版本中，试了一下需要手动设置management.info.env.enabled=true，才能在info端点加载配置文件中info.信息。","like_count":0},{"had_liked":false,"id":388061,"user_name":"kaiven_z","can_delete":false,"product_type":"c1","uid":3224759,"ip_address":"山东","ucode":"A5325FE4BFFA16","user_header":"https://static001.geekbang.org/account/avatar/00/31/34/b7/97378734.jpg","comment_is_top":false,"comment_ctime":1709272669,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636606,"comment_content":"management.info.env.enabled","like_count":0}]}