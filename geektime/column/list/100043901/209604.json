{"id":209604,"title":"23 | 深入理解：容斥原理与递推算法","content":"<p>你好，我是胡光，欢迎回来。</p><p>上两节呢，我们学习了两个具有单调性的数据结构：<strong>单调队列</strong>和<strong>单调栈</strong>。其中，单调队列是用来维护滑动窗口内的区间最值的单调结构，单调栈是用来维护最近大于或小于关系的单调结构。这两种单调结构的均摊时间复杂度都是 $O(1)$，每个元素的操作次数最多是 2 次，足以看到这两种结构的高效。如果想彻底掌握这两种结构，我建议你在课下时间不断地练习。</p><p>从今天开始呢，我们将从数据结构，跳跃到算法的学习上。将要带你认识一类比较偏重于思维的算法，大类叫做递推算法，以及其中的一个重要的组成部分，动态规划类算法。</p><p>关于递推算法，在“语言基础篇”的第05讲<a href=\"https://time.geekbang.org/column/article/188612\">《数组：一秒钟，定义1000个变量》</a>中，我们其实就使用了递推算法的思想。如果你已经忘了的话，我建议你可以先回去看看，复习一下之前的内容，为今天的课程做好充足的准备。</p><h2>今日任务</h2><p>咱们今天这10分钟的任务呢，和钱有关系。众所周知，在不计算小于 1 元钱的面额的前提下，我国的纸币系统中，曾经拥有如下面值：1元、2元、5元、10元、20元、50元 和 100元。假设，每一种面值的纸币，我们都有无限张，现在想用这些钱凑出1000元，请问你有多少种不同的方案？</p><!-- [[[read_end]]] --><p>这里说的不同方案，是不关注钱币之间的顺序的，例如要凑 7 元钱，可以是1元、5元、1元，也可以是1元、1元、5元，这两种方案我们视为同一种。</p><p>好了，面对这个问题，你要怎么解决呢？让我们开始今天的学习吧。</p><h2>必知必会，查缺补漏</h2><h4>温故知新：容斥原理</h4><p>在讲今天的递推问题之前呢，先来和你解释一个与递推思维相关的数学原理：容斥原理。</p><p>我们知道，一般在计数问题中，为了保证计数准确，必须注意两个事情：一是没有重复，二是没有遗漏。保证没有遗漏，这一点比较好做到，就像对某片地区采取地毯式轰炸，只要炸弹足够多，你可以很容易地保证，没有任何一个被漏掉的地方。可你要保证任何一片土地都仅被轰炸一次，这就很难做到。计数类问题往往也是这样的，想要保证没有遗漏的计数，比较简单，可要是想保证没有重复的计数，可能就困难那么一点儿了。</p><p>容斥原理就是为了解决计数类问题中的重复问题，其基本思想是：先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排除出去，使得计算的结果既无遗漏又无重复。简单来说，就是在计算过程中，如果加多了，就把加多的部分减掉，如果发现又减多了，就再加回来一部分，一直到不多不少为止。</p><p>这么说，你可能还是有点儿懵。没关系，回想一下，我们之前在第13节课<a href=\"https://time.geekbang.org/column/article/197583\">《程序设计原则：把计算过程交给计算机》</a>中，提到的求1000以内，3或者5倍数的所有数字和的问题。</p><p>原问题解决方法如图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/0b/9d/0b903e61a086497d128d0fe6197ec19d.jpg?wh=2001*968\" alt=\"\" title=\"图1： 倍数问题的集合表示\"><br>\n当时，我们提出了基于等差数列求和的一种做法，就是用 3 的倍数，加上 5 的倍数，然而我们发现，有一部分加多了，就又减掉了 15 的倍数，这样才是我们真正想要求的值。你仔细想一想，这种做法本质上，其实就是容斥原理的一种体现。</p><p>关于理解容斥原理，你需要理解问题的集合思维，关于这点呢，我在下面还会带着你做详细的解释。</p><h4>一个递推算法例子：兔子繁殖问题</h4><p>我们先从一个简单的问题开始，逐步熟悉容斥原理与递推算法。假设在一片草原上，莫名其妙来了一只外星兔子，这种外星兔子呢，第一个月的时候是幼体，第二个月成长为成体，从第三个月开始，成体兔子每个月都会产生出一只克隆体的幼体兔子，而且这种兔子不会衰老，一旦成体以后，就会一直生下去。按照这种情况，请你计算出第 n 个月，草原上有多少只兔子？</p><p>这里我给出了前6个月，草原上兔子数量的情况：<br>\n<img src=\"https://static001.geekbang.org/resource/image/a4/73/a4d7c79cfaf01acc956e5f461a8e1773.jpg?wh=1954*1367\" alt=\"\" title=\"图2： 兔子前6个月繁殖情况\"><br>\n我们看到，从第1个月到第6个月，草原上兔子的数量分别是：1、1、2、3、5、8，我们主要来分析第6个月兔子的组成情况。</p><p>第6个月共有 8 只兔子，其中5 只成兔，3 只幼兔。可以看到，之所以有 5 只成兔，是因为上个月总共有5只兔子，毕竟根据兔子的成长周期，不管它们是否成年，到下个月都会成长为成兔，所以<strong>第6个月的成兔数量等于第5个月的兔子总数</strong>。</p><p>而第6个月的另外的3 只幼兔，是由第 5 个月的 3 只成兔产生的，根据前面的推论，我们知道第5个月的3只成兔，是源自第4个月的兔子总数。所以，<strong>第6个月的幼兔数量等于第4个月的兔子总数</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/56/bf/56a7b86ac2b48050b715fe4622d5d2bf.jpg?wh=2163*1090\" alt=\"\" title=\"图3：第6个月的兔子数量与前两个月兔子数量关系\"><br>\n因此，我们可以得出这样的一个结论：从第3个月开始，<strong>第 n 个月的兔子总数，等于该月的成兔数量与幼兔数量之和，也就等于第 n - 1 个月的兔子数量与第n - 2个月的兔子数量之和</strong>。</p><p>在这个兔子繁殖问题中，我们把当前月份的兔子分成两类，一类是成年兔子，一类是幼年兔子。这种分类方法，就保证了我们对两类分别统计的时候，它们之间没有交集，也就不需要考虑容斥原理中剔除重复部分的过程了。</p><p>之后，我们重点分析本月的成年兔子数量、幼年兔子数量与之前的哪个量有关系，最终得到了一个只使用某个月兔子数量，对本月兔子数量进行表示的数学关系。<strong>这种使用序列中的前项的值，来计算当前项值的做法，就是我们今天要讲的递推算法</strong>。</p><p>那么这个算法具体如何求解呢？下面我们就来看看递推问题的求解过程。</p><h4>递推问题求解步骤</h4><p><strong>递推问题，通常分成三步进行求解。第一步，确定递推状态，也叫做状态定义；第二步，推导递推公式；最后一步，程序设计与编写。</strong></p><p>接下来，我将用前面的兔子繁殖问题为例，说明递推问题求解的前两个步骤。最后一步的程序设计与编写，将作为作业题，留给你来完成。</p><h4>1. 确定递推状态</h4><p>所谓确定递推状态，就是确定一个有明确含义的数学符号，这里重要的是这个明确含义，而非那个数学符号。</p><p>什么意思呢？就以兔子繁殖问题为例，当我们分析完问题以后，就可以定义出具有明确语义的数学符号，例如：f(n) 。如果我们仅仅列出这么一个数学符号，其实是没有多大意义的，可是当我们定义了它的语义，即 f(n) 代表第 n 个月兔子的数量，这才算是完成了状态定义。因为只有确定了状态定义，我们才能进行下一步的递推公式推导。</p><p>说到这里，在继续讲下面递推公式推导之前，你可能会有疑问了：这个状态定义中的数学符号虽然不重要，可一般是怎么确定出来的呢？</p><p>针对这类问题，那就不得不提到我的思考技巧了：我一般会把递推类问题，看成是初中的代数问题，先分析问题中的<strong>自变量</strong>和<strong>因变量</strong>。自变量，就是问题中那些不受控制的量，就像兔子繁殖问题中的月份。而因变量就是那些随自变量改变而改变的量，就像兔子繁殖问题中兔子的数量，是随着月份而改变的。</p><p>所以，我的技巧就是把和问题求解量相关的自变量，都作为数学符号中的参数，然后将相关问题求解量作为数学符号映射值的含义。就像我们刚刚所说的，f(n) 代表第 n 个月兔子的数量，在这个状态定义中，将问题求解量，也就是兔子数量，作为函数映射值的含义；而与问题求解量，即兔子数量相关的自变量只有一个，那就是月份，所以我们将月份作为函数的参数。</p><p>这样，我们就完成了状态定义。</p><h4>2.推导递推公式</h4><p>接下来，就是递推问题求解的第二步了，推导递推公式。在推导递推公式的时候，这里需要用到前面我们定义的递推状态，并且，使用时一定要严格遵守递推状态的语义信息。</p><p>例如，在兔子繁殖问题中，如果你想用状态 f(n) 做公式推导的时候，那么 f(n - 1) 就代表了第 n - 1 个月兔子的数量，而 f(n - 2) 就代表第 n - 2 个月兔子的数量。这就是我刚刚所说的“要严格遵守递推状态的语义信息”的意思。</p><p>一般做递推公式推导的时候，我们主要思考的事情是，当前递推状态和前几项递推状态之间的关系。例如，在兔子繁殖问题中，当我们确定了递推状态 f(n) 以后，通过分析可以得到如下递推公式：<br>\n<img src=\"https://static001.geekbang.org/resource/image/a9/2a/a9a9ab49024a11c0a3eb34337f33232a.jpg?wh=2506*520\" alt=\"\" title=\"图4： 兔子繁殖问题递推公式\"><br>\n根据前面对兔子繁殖问题的分析，你应该很容易理解这个递推公式吧？就是前两个月（n=1,2），兔子的数量都是1只；到第三个月以及之后的月份（n&gt;=3），本月的兔子数量等于上两个月的兔子数量之和。其中 f(n - 1) 等于本月中成兔的数量，f(n - 2) 实际代表的是 2 个月前的兔子数量，它也等于本月中幼兔的数量。套用集合的思想就是，成兔与幼兔这两部分互为补集，加在一起就正好等于全集。</p><p>细心的你肯定发现了，这个公式是不是在哪里见过？没错，在咱们的第12节课<a href=\"https://time.geekbang.org/column/article/197058\">《数学归纳法：搞定循环与递归的钥匙》</a>中，我们提到了菲波那契数列递推公式，就跟这个兔子繁殖公式一模一样。</p><h2>一起动手，搞事情</h2><p>请你来完成兔子繁殖问题的第三步：程序设计与编写。要求是用两种方式完成：</p><ol>\n<li>请使用循环的程序实现方式</li>\n<li>请使用递归的程序实现方式</li>\n</ol><p>在你用递归实现了兔子繁殖问题的求解过程以后，我希望你可以计算下80个月后，兔子的数量。你的程序将发生一些奇奇怪怪的现象，试着自己去理解这个程序现象，并且想一想，如何解决出现的问题吧。</p><p>在这里呢，再跟你多说一句，在进行程序实践的时候，一定要注意总结我们之前讲过的数学归纳法和递推算法与程序之间的关系。</p><h2>凑钱币问题</h2><p>最后，让我们回到今天的任务，也就是用1元、2元、5元、10元、20元、50元和100元凑成1000元钱，总共有多少种方案。</p><p>第一步，让我们来确定递推状态。确定递推状态之前，我们需要分析清楚题目中的自变量与因变量。因变量比较好分析，就是方案总数，那这个方案总数都受什么影响呢？很明显，是钱币的种类和拼凑目标金额。也就是说，钱币种类发生变化，方案总数就会发生变化；同理，如果拼凑的目标金额发生变化，方案总数也一定会发生变化。所以，自变量是 2 个，钱币种类和拼凑的钱币数量。因变量是 1 个，就是方案总数。</p><p>通过上面的分析，我们就可以列出状态定义：f(i, j) ，代表使用前 i 种钱币，拼凑 j 元钱的方案总数。例如，f[3][10] 就代表使用前3种钱币，也就是只使用1元、2元、5元，凑10元钱的方案总数。</p><p>第二步，就是用这个状态定义，进行递推公式推导，关键就是分析当前项与前几项的关系。核心思想其实就是容斥原理，也就是用某几项表示 f(i, j) ，如果发现这些表示 f(i, j) 的项之间存在交集，就将交集部分减去，如果减多了再加回来一些，直到正好表示 f(i, j) 为止。</p><p>好在这道题目还算是一道简单的递推问题，我们可以将 f(i, j) 划分成性质不同且互为补集的两部分。在 f(i, j) 所代表的所有方案中，一部分方案是使用了第 i 种钱币的，另外一部分方案中是没有使用第 i 种钱币的，我们就用这个性质，将 f(i, j) 表示成两项相加之和的形式。</p><p>例如，在用前三种钱币，拼凑 10 元钱的所有方案中，可以按照方案中是否使用第 3 种钱币，也就是是否使用了 5 元钱，将所有方案划分成两类。</p><p>其中一类方案不包含第 3 种钱币，也就是不用 5 元这个钱币，这些方案的数量，等价于使用前 2 种钱币拼凑 10 元钱的方案总数，也就是 f[2][10] 的值。另外一类方案中，使用了至少 1 张 5 块钱，那么我们可以在这些方案中，都拿掉一张 5 元钱，剩余的部分组成的方案数量，就等于 f[3][5]，也就是用前 3 种钱币凑 5 元钱的方案总数。</p><p>这样我们就推导出了递推公式：f[3][10] = f[2][10] + f[3][5]。</p><p><img src=\"https://static001.geekbang.org/resource/image/45/cc/45e07e8c765a5dd9ab50767d54705ccc.jpg?wh=1938*1461\" alt=\"\" title=\"图5： 凑钱币问题示意图\"><br>\n回到我们的任务，就是在 f(i, j) 代表的所有方案中，没有使用第 i 种钱币，拼凑 j 元钱的方案数量，就是 f(i - 1, j)，代表使用前 i - 1 种钱币拼凑 j 元钱的方案总数。剩下的使用了第 i 种钱币的方案中，由于都存在第 i 种钱币至少 1 张，假设第 i 种钱币的面额是 val[i]，也就意味着，我们可以使用前 i 种钱币，凑 j - val[i] 的钱数，给第 i 种钱币留出一个位置，这么做所对应的方案总数就是 f(i, j - val[i])。</p><p>最终，我们推导出了递推公式：<strong>f(i, j) = f(i - 1, j) + f(i, j - val[i])</strong>。其中，边界条件是 f(1, k * val[1]) = 1，也就是用在只使用第 1 种钱币的条件下，想要凑第 1 种钱币的整数倍面额的方案总数都是 1。</p><p>至此，我们就完成了凑钱币问题的递推求解过程。最后，还剩一个程序实现，试着自己完成一下吧，加油！你可以的！</p><h2>课程小结</h2><p>最后呢，我们来总结一下今天的内容，今天的内容主要想让你记住三点：</p><ol>\n<li>递推问题第一步是要确定递推状态，也就是给出一个数学符号，以及数学符号的相关描述。</li>\n<li>在设计递推状态的时候，主要分析自变量与因变量的关系，一般因变量都是问题求解的那个量。</li>\n<li>递推问题的第二步是推导递推公式，而容斥原理的思想，对于这一步的求解，十分重要。</li>\n</ol><p>递推问题的求解过程，不是一朝一夕就能掌握的，今天的课程呢，只是让你拥有这种感觉，以及掌握求解递推问题的重要思考过程。我相信，只要你沿着今天讲的递推问题求解过程，去学习每一个递推问题，总有一天，你会对递推问题理解得更加透彻。</p><p>对于学有余力的小伙伴们，如果想更深入地了解一下容斥原理，可以通过学习莫比乌斯函数、狄利克雷卷积与莫比乌斯反演等内容，进一步感受一下这个思想所绽放出的光芒。</p><p>好了，关于递推的知识今天就讲到这里了，我是胡光，咱们下期见。</p>","comments":[{"had_liked":false,"id":186514,"user_name":"徐洲更","can_delete":false,"product_type":"c1","uid":1314643,"ip_address":"","ucode":"F8A323CB732D05","user_header":"https://static001.geekbang.org/account/avatar/00/14/0f/53/92a50f01.jpg","comment_is_top":false,"comment_ctime":1583855152,"is_pvip":true,"replies":[{"id":"72089","content":"有不同，爬楼梯的方案是在乎顺序的，凑钱币问题，是不在乎顺序的。爬楼梯，本质上，一维递推状态定义即可，由于在乎顺序，所以，只需要考虑最后一步走什么即可。","user_name":"作者回复","comment_id":186514,"uid":"1374625","ip_address":"","utype":1,"ctime":1583935956,"user_name_real":"胡炜燚"}],"discussion_count":1,"race_medal":0,"score":"18763724336","product_id":100043901,"comment_content":"还有一个问题，把零钱兑换改成爬楼梯，每次是1,2,5,10  然后要爬到第100层 的走法 和零钱兑换的状态定义有什么不同呢","like_count":4,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486787,"discussion_content":"有不同，爬楼梯的方案是在乎顺序的，凑钱币问题，是不在乎顺序的。爬楼梯，本质上，一维递推状态定义即可，由于在乎顺序，所以，只需要考虑最后一步走什么即可。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583935956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186508,"user_name":"徐洲更","can_delete":false,"product_type":"c1","uid":1314643,"ip_address":"","ucode":"F8A323CB732D05","user_header":"https://static001.geekbang.org/account/avatar/00/14/0f/53/92a50f01.jpg","comment_is_top":false,"comment_ctime":1583854155,"is_pvip":true,"replies":[{"id":"72090","content":"perfect！","user_name":"作者回复","comment_id":186508,"uid":"1374625","ip_address":"","utype":1,"ctime":1583935974,"user_name_real":"胡炜燚"}],"discussion_count":1,"race_medal":0,"score":"14468756043","product_id":100043901,"comment_content":"这节课最大的收获就是 状态数组的定义，之前之前靠经验，现在学到了如何用因变量和自变量来定义","like_count":4,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486783,"discussion_content":"perfect！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583935974,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187107,"user_name":"栾~龟虽寿！","can_delete":false,"product_type":"c1","uid":1504671,"ip_address":"","ucode":"219B38C08979FE","user_header":"https://static001.geekbang.org/account/avatar/00/16/f5/9f/1509d389.jpg","comment_is_top":false,"comment_ctime":1584017460,"is_pvip":false,"replies":[{"id":"72428","content":"^_^","user_name":"作者回复","comment_id":187107,"uid":"1374625","ip_address":"","utype":1,"ctime":1584202639,"user_name_real":"胡炜燚"}],"discussion_count":1,"race_medal":0,"score":"10173952052","product_id":100043901,"comment_content":"真的叹为观止，自变量，因变量，容斥原理，数学功底深厚，算法的底层是数学，展现的淋漓尽致。喵。","like_count":3,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486991,"discussion_content":"^_^","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584202639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":254020,"user_name":"罗耀龙@坐忘","can_delete":false,"product_type":"c1","uid":1917663,"ip_address":"","ucode":"3CEA258DE7F3C7","user_header":"https://static001.geekbang.org/account/avatar/00/1d/42/df/a034455d.jpg","comment_is_top":false,"comment_ctime":1603018715,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"5897986011","product_id":100043901,"comment_content":"茶艺师学编程<br><br>兔子问题<br><br>第80个月，兔子的数量为23416728348467685只。<br><br>老师不是一般的坏，是算准我们这些菜鸟不会注意数据类型对结果呈现效果的影响······用“一般”的方法，是呈现不出第80个月的兔子数量。<br><br>我摸到的方法，就是使用long long（%lld）型，到这里，仅仅解决了循环解法的问题。递归算法还是“算不出来”。<br><br>循环法直接计算，而递归法总得重复计算。<br><br>既然这样，那就让要重复计算的部分直接抄答案就好了，正如老师所说的，“数组是展开的函数，函数是压缩的函数。”于是有了下面“有点肥”的递归解法。<br><br>&#47;*兔子数量（斐波那契数列） 循环解法*&#47; <br><br>&#47;*兔子数量（斐波那契数列） 循环解法*&#47; <br><br>#include &lt;stdio.h&gt;<br><br>long long r(int n){<br> if(n == 1 || n == 2)return 1;<br> long long n1 = 1;<br> long long n2 = 1;<br> long long n3;<br> for(int i = 0; i &lt; (n - 2); i++){<br>  n3 = n1 + n2;<br>  n1 = n2;<br>  n2 = n3;<br> }<br> return n3;<br>}<br>int main(){<br> printf(&quot;循环解法 n = 80 %lld\\n&quot;, r(80));<br> return 0;<br>} <br><br>&#47;*兔子数量（斐波那契数列） 递归解法*&#47; <br><br>#include &lt;stdio.h&gt;<br><br>long long r(int n){<br>\tif(n == 1 || n == 2)return 1;<br>\tif(n == 10)return 55;<br>\tif(n == 20)return 6765;<br>\tif(n == 30)return 832040; <br>\tif(n == 40)return 102334155;<br>\tif(n == 50)return 12586269025;<br>\tif(n == 55)return 139583862445;<br>\tif(n == 58)return 591286729879;<br>\tif(n == 60)return 1548008755920;<br>\tif(n == 63)return 6557470319842;<br>\tif(n == 65)return 17167680177565;<br>\tif(n == 68)return 72723460248141;<br>\tif(n == 70)return 190392490709135;<br>\tif(n == 72)return 498454011879264;<br>\tif(n == 74)return 1304969544928657;<br>\tif(n == 76)return 3416454622906707;<br>\tif(n == 78)return 8944394323791464;<br>\tif(n == 80)return 23416728348467685;<br>\treturn r(n - 1) + r(n - 2); <br>}<br><br>int main(){<br>\tprintf(&quot;递归解法 n = 80 %lld&quot;, r(80));<br>\treturn 0;<br>} <br>","like_count":2},{"had_liked":false,"id":187645,"user_name":"宋不肥","can_delete":false,"product_type":"c1","uid":1240126,"ip_address":"","ucode":"32B34AF579C91C","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/3e/885ec1d2.jpg","comment_is_top":false,"comment_ctime":1584180778,"is_pvip":false,"replies":[{"id":"72423","content":"对的，没错！","user_name":"作者回复","comment_id":187645,"uid":"1374625","ip_address":"","utype":1,"ctime":1584202007,"user_name_real":"胡炜燚"}],"discussion_count":1,"race_medal":0,"score":"5879148074","product_id":100043901,"comment_content":"关于递归的优化，其实可以考虑用数组构建一个散列表，将已经计算的值记录下来，当再次遇见时，先查询散列表中是否存在（O（1）），如果存在直接调用，从而避免重复计算.。","like_count":2,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487181,"discussion_content":"对的，没错！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584202007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186517,"user_name":"徐洲更","can_delete":false,"product_type":"c1","uid":1314643,"ip_address":"","ucode":"F8A323CB732D05","user_header":"https://static001.geekbang.org/account/avatar/00/14/0f/53/92a50f01.jpg","comment_is_top":false,"comment_ctime":1583855508,"is_pvip":true,"replies":[{"id":"72088","content":"对的！所以，再结合：数组是展开的函数，函数是压缩的数组。你能想到什么？","user_name":"作者回复","comment_id":186517,"uid":"1374625","ip_address":"","utype":1,"ctime":1583935869,"user_name_real":"胡炜燚"}],"discussion_count":2,"race_medal":0,"score":"5878822804","product_id":100043901,"comment_content":"解答下问下递归慢，递归慢是因为递归树中有大量重复计算，f(6) 需要计算f(5)和f(4) , 而f(5)需要计算f(4) f(3), 计算机不会自动复用f(4)计算结果 而是要重复算","like_count":1,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486788,"discussion_content":"对的！所以，再结合：数组是展开的函数，函数是压缩的数组。你能想到什么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583935869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1314643,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0f/53/92a50f01.jpg","nickname":"徐洲更","note":"","ucode":"F8A323CB732D05","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":202812,"discussion_content":"这就是时间和空间的互换吧。数组可以快速访问之前的结果，而函数每次都要运算。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583945116,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186433,"user_name":"🤪HappyJoo","can_delete":false,"product_type":"c1","uid":1234591,"ip_address":"","ucode":"96E1858F06BABA","user_header":"https://static001.geekbang.org/account/avatar/00/12/d6/9f/0213e8a0.jpg","comment_is_top":false,"comment_ctime":1583844683,"is_pvip":false,"replies":[{"id":"72092","content":"循环快，是因为没有做多余运算，递归慢，是因为做了多余的运算。具体参考，@陈洲更 的留言。<br>关于递归程序的优化，其实是想让你们更深刻的理解：数组是展开的函数，函数是压缩的数组。这句话。","user_name":"作者回复","comment_id":186433,"uid":"1374625","ip_address":"","utype":1,"ctime":1583936100,"user_name_real":"胡炜燚"}],"discussion_count":1,"race_medal":0,"score":"5878811979","product_id":100043901,"comment_content":"fibonacci的问题：int 的字节，算到第47个fibonacci的数的时候，就不够用了，可以用long，当然，long 只有8个字节，也就算到第92个，有兴趣的同学可以用前面学过的大数字表达法哈哈哈。<br><br>我的问题：为什么递归那么慢，用循环一下子就出结果了，应该也就是算了92次，递归算了几分钟还没有算出来，循环毫秒内就算好了。“它的运行需要较多次数的函数调用，如果调用层数比较深，需要增加额外的堆栈处理（还有可能出现堆栈溢出的情况），比如参数传递需要压栈等操作”，虽然我不知道堆栈是啥，但反正就调用了很多次函数，效率很低。好像可以用尾递归解决？（尾递归参考：https:&#47;&#47;www.zhihu.com&#47;question&#47;20761771，他写出了每一层的区别）","like_count":1,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486753,"discussion_content":"循环快，是因为没有做多余运算，递归慢，是因为做了多余的运算。具体参考，@陈洲更 的留言。\n关于递归程序的优化，其实是想让你们更深刻的理解：数组是展开的函数，函数是压缩的数组。这句话。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583936100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":271557,"user_name":"璆(科学)","can_delete":false,"product_type":"c1","uid":2090618,"ip_address":"","ucode":"396D61574FF229","user_header":"https://static001.geekbang.org/account/avatar/00/1f/e6/7a/495bf265.jpg","comment_is_top":false,"comment_ctime":1609691377,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609691377","product_id":100043901,"comment_content":"写个python 版本吧。。<br># f(n) = f(n-1) + f(n-2)<br># 备忘录存储Z<br>import time<br>begin = time.time()<br>Z =dict()<br>def breed(n):<br>    print(f_breed(n))<br>def f_breed(n):<br>    if n==1:<br>        Z[1] = 1<br>        return 1<br>    elif n==0:<br>        Z[0] = 1<br>        return 1<br>    else:<br>        Z[n] = (Z[n-2] if n-2 in Z.keys() else f_breed(n-2)) +(Z[n-1] if n-1 in Z.keys() else f_breed(n-1))<br>        return  Z[n]<br>        # 不带备忘录的版本<br>        # return f_breed(n-1) + f_breed(n-2)<br>if __name__ == &quot;__main__&quot;:<br>    n = 79<br>    breed(n)<br>    print(time.time() - begin)","like_count":0},{"had_liked":false,"id":254207,"user_name":"罗耀龙@坐忘","can_delete":false,"product_type":"c1","uid":1917663,"ip_address":"","ucode":"3CEA258DE7F3C7","user_header":"https://static001.geekbang.org/account/avatar/00/1d/42/df/a034455d.jpg","comment_is_top":false,"comment_ctime":1603082642,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1603082642","product_id":100043901,"comment_content":"茶艺师学编程<br><br>凑钱问题<br><br>用7种纸币凑1000元，能有234896541种方法。<br><br>在这里折腾，我获得一个感悟，就是想用好递归，边界条件要写好，不然就等着内存溢出吧······<br><br>&#47;*凑纸币*&#47;<br><br>#include &lt;stdio.h&gt;<br><br>int val[8] = {0, 1, 2, 5, 10, 20, 50, 100};<br><br>int f(int n, int j){<br>\tif (j &lt; 0)return 0;<br>\tif (j == 0)return 1;<br>\tif (n == 1 &amp;&amp; j % val[1] == 0)return 1;<br>\treturn f(n-1, j) + f(n, j - val[n]);<br>} <br><br>int main(){<br>\tint n ,j;<br>\tscanf(&quot;%d %d&quot;, &amp;n, &amp;j); <br>\tprintf(&quot;用%d种纸币凑%d元，能有%d种方法&quot;,n, j, f(n, j));<br>\treturn 0;<br>}","like_count":1},{"had_liked":false,"id":223993,"user_name":"佐西玛","can_delete":false,"product_type":"c1","uid":1090743,"ip_address":"","ucode":"73AAED82340E2B","user_header":"https://static001.geekbang.org/account/avatar/00/10/a4/b7/e0d88365.jpg","comment_is_top":false,"comment_ctime":1591252053,"is_pvip":false,"replies":[{"id":"83505","content":"答案的话，在后面是有专门文章的，你可以往后看看。另外你的凑钱币代码中，i == 1 &amp;&amp; j % val[1] 这里写错了，应该是 j % val[i] == 0。不过从代码能看出来，你是理解了思路的，加油！d(^_^o)","user_name":"作者回复","comment_id":223993,"uid":"1374625","ip_address":"","utype":1,"ctime":1592207095,"user_name_real":"胡炜燚"}],"discussion_count":1,"race_medal":0,"score":"1591252053","product_id":100043901,"comment_content":"用递归算兔子的数量：<br>int cal_rabbit_num(int n) {<br>    if(n == 1 || n == 2) {<br>        return 1;<br>    }<br>    return cal_rabbit_num(n - 1) + cal_rabbit_num(n - 2);<br>}<br>用循环算兔子的数量：<br>int cal_rabbit_num_loop(int n) {<br>    if(n == 1 || n == 2) {<br>        return 1;<br>    }<br>    int n1 = 1;<br>    int n2 = 1;<br>    int n3 = 0;<br>    for(int i = 0; i &lt; n - 2; i++) {<br>        n3 = n1 + n2;<br>        n1 = n2;<br>        n2 = n3; <br>    }<br>    return n3;<br>}<br>凑钱：<br>int cal_coins(int i, int j) {<br>    if(j &lt; 0) {<br>        return 0;<br>    }<br>    if(j == 0) {<br>        return 1;<br>    }<br>    if(i == 1 &amp;&amp; j % val[1] == 0) {<br>        return 1;<br>    }<br>    return cal_coins(i - 1, j) + cal_coins(i, j - val[i]);<br>}<br>int main() {<br>    int n;<br>    scanf(&quot;%d&quot;, &amp;n);<br>    printf(&quot;%d\\n&quot;,cal_coins(3, n));<br>    return 0;<br>}<br><br>能不能公布一下答案，看看自己有没有算错。多谢船长！<br>","like_count":0,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497329,"discussion_content":"答案的话，在后面是有专门文章的，你可以往后看看。另外你的凑钱币代码中，i == 1 &amp;amp;&amp;amp; j % val[1] 这里写错了，应该是 j % val[i] == 0。不过从代码能看出来，你是理解了思路的，加油！d(^_^o)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592207095,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187750,"user_name":"宋不肥","can_delete":false,"product_type":"c1","uid":1240126,"ip_address":"","ucode":"32B34AF579C91C","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/3e/885ec1d2.jpg","comment_is_top":false,"comment_ctime":1584212703,"is_pvip":false,"replies":[{"id":"72576","content":"这回逻辑上还有那么点儿意思。d(^_^d)","user_name":"作者回复","comment_id":187750,"uid":"1374625","ip_address":"","utype":1,"ctime":1584290757,"user_name_real":"胡炜燚"}],"discussion_count":1,"race_medal":0,"score":"1584212703","product_id":100043901,"comment_content":"&#47;&#47;凑钱币 更改版 <br>#include&lt;stdio.h&gt;<br>int a[7] = {1,2,5,10,20,50,100};<br>int f_money(int i,int j){<br>\tif( i == 1 || j == 0 ) return 1;<br>\tif(a[i-1] &lt;= j ) return f_money(i-1,j) + f_money(i,j-a[i-1]);<br>\tif(a[i-2] &lt;= j ) return f_money(i-1,j) + f_money(i,j-a[i-2]);<br>\tif(a[i-3] &lt;= j ) return f_money(i-1,j) + f_money(i,j-a[i-3]);<br>\tif(a[i-4] &lt;= j ) return f_money(i-1,j) + f_money(i,j-a[i-4]);<br>\tif(a[i-5] &lt;= j ) return f_money(i-1,j) + f_money(i,j-a[i-5]);<br>\tif(a[i-6] &lt;= j ) return f_money(i-1,j) + f_money(i,j-a[i-6]);<br>}<br>int main(){<br>\tint v;<br>\tv = f_money(7,1000);<br>\tprintf(&quot;%d&quot;,v); <br>}<br>","like_count":0,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487227,"discussion_content":"这回逻辑上还有那么点儿意思。d(^_^d)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584290757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187640,"user_name":"宋不肥","can_delete":false,"product_type":"c1","uid":1240126,"ip_address":"","ucode":"32B34AF579C91C","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/3e/885ec1d2.jpg","comment_is_top":false,"comment_ctime":1584180504,"is_pvip":false,"replies":[{"id":"72422","content":"赞，说的很透彻！","user_name":"作者回复","comment_id":187640,"uid":"1374625","ip_address":"","utype":1,"ctime":1584201991,"user_name_real":"胡炜燚"}],"discussion_count":1,"race_medal":0,"score":"1584180504","product_id":100043901,"comment_content":"其实关于狄利克雷卷积，不仅可以可以推导莫比乌斯反演这种离散情况，同时他也是大名鼎鼎得傅里叶变换得基础，在工科专业里面卷积常用于求一个系统得响应，初学时候总是不理解，其实是可以结合容斥与递推来理解得，一个系统当前得输出应该等于之前所有得输入在当前时刻得响应，也就是在保持容斥状态下求所有前项输入在当前是个得响应之和。同样傅里叶变换也是在容斥得要求下便利所有时间对所求频率得响应和，虽然是积分，但到了计算机里面也是加法了。初学时候要是考虑到每个时间点之间是容斥的，也会好理解的多。果然数学都是相通的。","like_count":0,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487178,"discussion_content":"赞，说的很透彻！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584201991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187638,"user_name":"宋不肥","can_delete":false,"product_type":"c1","uid":1240126,"ip_address":"","ucode":"32B34AF579C91C","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/3e/885ec1d2.jpg","comment_is_top":false,"comment_ctime":1584179925,"is_pvip":false,"replies":[{"id":"72429","content":"凑钱币问题的程序实现有问题，递归边界条件没有控制好，你试试 f_money(2, 2)，想想为什么程序错了。","user_name":"作者回复","comment_id":187638,"uid":"1374625","ip_address":"","utype":1,"ctime":1584203239,"user_name_real":"胡炜燚"}],"discussion_count":1,"race_medal":0,"score":"1584179925","product_id":100043901,"comment_content":"作业打卡：<br>&#47;&#47;兔子繁殖 <br>#include &lt;stdio.h&gt;<br>&#47;&#47; 递归<br>long f_recursive(int x){<br>\tif( x == 2 || x == 1) return 1;<br>\treturn f_recursive(x-1)+f_recursive(x-2);<br>} <br>&#47;&#47;递推循环 <br>long f_recursion(int x){<br>\tif( x == 2 || x == 1) return 1;<br>\tlong sum = 1 ,pre = 1,temp = 0;<br>\tfor(int i = 3;i &lt;= x; ++i){<br>\t\ttemp = sum;<br>\t\tsum += pre;<br>\t\tpre = temp;<br>\t}<br>\treturn sum;<br>}<br><br>int main(){<br>\tlong a = 0;<br>\ta = f_recursive(20);<br>\tprintf(&quot;%ld\\n&quot;,a);<br>\ta = f_recursion(20);<br>\tprintf(&quot;%ld\\n&quot;,a);<br>} <br><br><br>&#47;&#47;凑钱币 <br>#include&lt;stdio.h&gt;<br>int a[7] = {1,2,5,10,20,50,100};<br>int f_money(int i,int j){<br>\tif( i == 1 || j == 1 ) return 1;<br>\tif(a[i-1] &lt;= j ) return f_money(i-1,j) + f_money(i,j-a[i-1]);<br>\tif(a[i-2] &lt;= j ) return f_money(i-1,j) + f_money(i,j-a[i-2]);<br>\tif(a[i-3] &lt;= j ) return f_money(i-1,j) + f_money(i,j-a[i-3]);<br>\tif(a[i-4] &lt;= j ) return f_money(i-1,j) + f_money(i,j-a[i-4]);<br>\tif(a[i-5] &lt;= j ) return f_money(i-1,j) + f_money(i,j-a[i-5]);<br>\tif(a[i-6] &lt;= j ) return f_money(i-1,j) + f_money(i,j-a[i-6]);<br>}<br>int main(){<br>\tint v;<br>\tv = f_money(7,1000);<br>\tprintf(&quot;%d&quot;,v); <br>}<br><br><br>","like_count":0,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487176,"discussion_content":"凑钱币问题的程序实现有问题，递归边界条件没有控制好，你试试 f_money(2, 2)，想想为什么程序错了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584203239,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}