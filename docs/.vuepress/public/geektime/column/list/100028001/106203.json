{"id":106203,"title":"21 | 磨刀不误砍柴工：欲知JVM调优先了解JVM内存模型","content":"<p>你好，我是刘超。</p><p>从今天开始，我将和你一起探讨Java虚拟机（JVM）的性能调优。JVM算是面试中的高频问题了，通常情况下总会有人问到：请你讲解下JVM的内存模型，JVM的性能调优做过吗？</p><h2>为什么JVM在Java中如此重要？</h2><p>首先你应该知道，运行一个Java应用程序，我们必须要先安装JDK或者JRE包。这是因为Java应用在编译后会变成字节码，然后通过字节码运行在JVM中，而JVM是JRE的核心组成部分。</p><p><span class=\"orange\">JVM不仅承担了Java字节码的分析（JIT compiler）和执行（Runtime），同时也内置了自动内存分配管理机制。</span>这个机制可以大大降低手动分配回收机制可能带来的内存泄露和内存溢出风险，使Java开发人员不需要关注每个对象的内存分配以及回收，从而更专注于业务本身。</p><h2>从了解内存模型开始</h2><p>JVM自动内存分配管理机制的好处很多，但实则是把双刃剑。这个机制在提升Java开发效率的同时，也容易使Java开发人员过度依赖于自动化，弱化对内存的管理能力，这样系统就很容易发生JVM的堆内存异常，垃圾回收（GC）的方式不合适以及GC次数过于频繁等问题，这些都将直接影响到应用服务的性能。</p><p>因此，要进行JVM层面的调优，就需要深入了解JVM内存分配和回收原理，这样在遇到问题时，我们才能通过日志分析快速地定位问题；也能在系统遇到性能瓶颈时，通过分析JVM调优来优化系统性能。这也是整个模块四的重点内容，今天我们就从JVM的内存模型学起，为后续的学习打下一个坚实的基础。</p><!-- [[[read_end]]] --><h2>JVM内存模型的具体设计</h2><p>我们先通过一张JVM内存模型图，来熟悉下其具体设计。<span class=\"orange\">在Java中，JVM内存模型主要分为堆、程序计数器、方法区、虚拟机栈和本地方法栈。</span></p><p><img src=\"https://static001.geekbang.org/resource/image/df/8b/dfd02c98d495c4c4ed201ea7fe0e3f8b.jpg?wh=1022*664\" alt=\"\"></p><p>JVM的5个分区具体是怎么实现的呢？我们一一分析。</p><h3>1. 堆（Heap）</h3><p>堆是JVM内存中最大的一块内存空间，该内存被所有线程共享，几乎所有对象和数组都被分配到了堆内存中。堆被划分为新生代和老年代，新生代又被进一步划分为Eden和Survivor区，最后Survivor由From Survivor和To Survivor组成。</p><p>在Java6版本中，永久代在非堆内存区；到了Java7版本，永久代的静态变量和运行时常量池被合并到了堆中；而到了Java8，永久代被元空间取代了。 结构如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/99/6c/9906824978c891c86524f9394102de6c.png?wh=619*674\" alt=\"\"></p><h3>2. 程序计数器（Program Counter Register）</h3><p>程序计数器是一块很小的内存空间，主要用来记录各个线程执行的字节码的地址，例如，分支、循环、跳转、异常、线程恢复等都依赖于计数器。</p><p>由于Java是多线程语言，当执行的线程数量超过CPU核数时，线程之间会根据时间片轮询争夺CPU资源。如果一个线程的时间片用完了，或者是其它原因导致这个线程的CPU资源被提前抢夺，那么这个退出的线程就需要单独的一个程序计数器，来记录下一条运行的指令。</p><h3>3. 方法区（Method Area）</h3><p>很多开发者都习惯将方法区称为“永久代”，其实这两者并不是等价的。</p><p>HotSpot虚拟机使用永久代来实现方法区，但在其它虚拟机中，例如，Oracle的JRockit、IBM的J9就不存在永久代一说。因此，方法区只是JVM中规范的一部分，可以说，在HotSpot虚拟机中，设计人员使用了永久代来实现了JVM规范的方法区。</p><p><span class=\"orange\">方法区主要是用来存放已被虚拟机加载的类相关信息，</span>包括类信息、运行时常量池、字符串常量池。类信息又包括了类的版本、字段、方法、接口和父类等信息。</p><p>JVM在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。在加载类的时候，JVM会先加载class文件，而在class文件中除了有类的版本、字段、方法和接口等描述信息外，还有一项信息是常量池(Constant Pool Table)，用于存放编译期间生成的各种字面量和符号引用。</p><p>字面量包括字符串（String a=“b”）、基本类型的常量（final修饰的变量），符号引用则包括类和方法的全限定名（例如String这个类，它的全限定名就是Java/lang/String）、字段的名称和描述符以及方法的名称和描述符。</p><p>而当类加载到内存中后，JVM就会将class文件常量池中的内容存放到运行时的常量池中；在解析阶段，JVM会把符号引用替换为直接引用（对象的索引值）。</p><p>例如，类中的一个字符串常量在class文件中时，存放在class文件常量池中的；在JVM加载完类之后，JVM会将这个字符串常量放到运行时常量池中，并在解析阶段，指定该字符串对象的索引值。运行时常量池是全局共享的，多个类共用一个运行时常量池，class文件中常量池多个相同的字符串在运行时常量池只会存在一份。</p><p><span class=\"orange\">方法区与堆空间类似，也是一个共享内存区，所以方法区是线程共享的。</span>假如两个线程都试图访问方法区中的同一个类信息，而这个类还没有装入JVM，那么此时就只允许一个线程去加载它，另一个线程必须等待。</p><p>在HotSpot虚拟机、Java7版本中已经将永久代的静态变量和运行时常量池转移到了堆中，其余部分则存储在JVM的非堆内存中，而Java8版本已经将方法区中实现的永久代去掉了，并用元空间（class metadata）代替了之前的永久代，并且元空间的存储位置是本地内存。之前永久代的类的元数据存储在了元空间，永久代的静态变量（class static variables）以及运行时常量池（runtime constant pool）则跟Java7一样，转移到了堆中。</p><p><strong>那你可能又有疑问了，Java8为什么使用元空间替代永久代，这样做有什么好处呢？</strong></p><p>官方给出的解释是：</p><ul>\n<li>移除永久代是为了融合 HotSpot JVM 与 JRockit VM 而做出的努力，因为JRockit没有永久代，所以不需要配置永久代。</li>\n<li>永久代内存经常不够用或发生内存溢出，爆出异常java.lang.OutOfMemoryError: PermGen。这是因为在JDK1.7版本中，指定的PermGen区大小为8M，由于PermGen中类的元数据信息在每次FullGC的时候都可能被收集，回收率都偏低，成绩很难令人满意；还有，为PermGen分配多大的空间很难确定，PermSize的大小依赖于很多因素，比如，JVM加载的class总数、常量池的大小和方法的大小等。</li>\n</ul><h3>4.虚拟机栈（VM stack）</h3><p>Java虚拟机栈是线程私有的内存空间，它和Java线程一起创建。当创建一个线程时，会在虚拟机栈中申请一个线程栈，用来保存方法的局部变量、操作数栈、动态链接方法和返回地址等信息，并参与方法的调用和返回。每一个方法的调用都伴随着栈帧的入栈操作，方法的返回则是栈帧的出栈操作。</p><h3>5.本地方法栈（Native Method Stack）</h3><p>本地方法栈跟Java虚拟机栈的功能类似，Java虚拟机栈用于管理Java函数的调用，而本地方法栈则用于管理本地方法的调用。但本地方法并不是用Java实现的，而是由C语言实现的。</p><h2>JVM的运行原理</h2><p>看到这里，相信你对JVM内存模型已经有个充分的了解了。接下来，我们通过一个案例来了解下代码和对象是如何分配存储的，Java代码又是如何在JVM中运行的。</p><pre><code>public class JVMCase {\n\n\t// 常量\n\tpublic final static String MAN_SEX_TYPE = &quot;man&quot;;\n\n\t// 静态变量\n\tpublic static String WOMAN_SEX_TYPE = &quot;woman&quot;;\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tStudent stu = new Student();\n\t\tstu.setName(&quot;nick&quot;);\n\t\tstu.setSexType(MAN_SEX_TYPE);\n\t\tstu.setAge(20);\n\t\t\n\t\tJVMCase jvmcase = new JVMCase();\n\t\t\n\t\t// 调用静态方法\n\t\tprint(stu);\n\t\t// 调用非静态方法\n\t\tjvmcase.sayHello(stu);\n\t}\n\n\n\t// 常规静态方法\n\tpublic static void print(Student stu) {\n\t\tSystem.out.println(&quot;name: &quot; + stu.getName() + &quot;; sex:&quot; + stu.getSexType() + &quot;; age:&quot; + stu.getAge()); \n\t}\n\n\n\t// 非静态方法\n\tpublic void sayHello(Student stu) {\n\t\tSystem.out.println(stu.getName() + &quot;say: hello&quot;); \n\t}\n}\n\nclass Student{\n\tString name;\n\tString sexType;\n\tint age;\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getSexType() {\n\t\treturn sexType;\n\t}\n\tpublic void setSexType(String sexType) {\n\t\tthis.sexType = sexType;\n\t}\n\tpublic int getAge() {\n\t\treturn age;\n\t}\n\tpublic void setAge(int age) {\n\t\tthis.age = age;\n\t}\n}\n</code></pre><p><strong>当我们通过Java运行以上代码时，JVM的整个处理过程如下：</strong></p><p>1.JVM向操作系统申请内存，JVM第一步就是通过配置参数或者默认配置参数向操作系统申请内存空间，根据内存大小找到具体的内存分配表，然后把内存段的起始地址和终止地址分配给JVM，接下来JVM就进行内部分配。</p><p>2.JVM获得内存空间后，会根据配置参数分配堆、栈以及方法区的内存大小。</p><p>3.class文件加载、验证、准备以及解析，其中准备阶段会为类的静态变量分配内存，初始化为系统的初始值（这部分我在第21讲还会详细介绍）。</p><p><img src=\"https://static001.geekbang.org/resource/image/94/32/94e6ebbaa0a23d677a4ad752e3e68732.jpg?wh=1258*930\" alt=\"\"></p><p>4.完成上一个步骤后，将会进行最后一个初始化阶段。在这个阶段中，JVM首先会执行构造器&lt;clinit&gt;方法，编译器会在.java 文件被编译成.class 文件时，收集所有类的初始化代码，包括静态变量赋值语句、静态代码块、静态方法，收集在一起成为 &lt;clinit&gt;() 方法。</p><p><img src=\"https://static001.geekbang.org/resource/image/29/59/29d54f4a8e1ecf388adc6b99cd5e0159.jpg?wh=1248*864\" alt=\"\"></p><p>5.执行方法。启动main线程，执行main方法，开始执行第一行代码。此时堆内存中会创建一个student对象，对象引用student就存放在栈中。</p><p><img src=\"https://static001.geekbang.org/resource/image/c6/7e/c6702aea3f1aaca60b1cd2e38981ad7e.jpg?wh=1372*968\" alt=\"\"></p><p>6.此时再次创建一个JVMCase对象，调用sayHello非静态方法，sayHello方法属于对象JVMCase，此时sayHello方法入栈，并通过栈中的student引用调用堆中的Student对象；之后，调用静态方法print，print静态方法属于JVMCase类，是从静态方法中获取，之后放入到栈中，也是通过student引用调用堆中的student对象。</p><p><img src=\"https://static001.geekbang.org/resource/image/b7/23/b7d00191a1d42def9633b8ea8491cf23.jpg?wh=1414*984\" alt=\"\"></p><p>了解完实际代码在JVM中分配的内存空间以及运行原理，相信你会更加清楚内存模型中各个区域的职责分工。</p><h2>总结</h2><p>这讲我们主要深入学习了最基础的内存模型设计，了解其各个分区的作用及实现原理。</p><p>如今，JVM在很大程度上减轻了Java开发人员投入到对象生命周期的管理精力。在使用对象的时候，JVM会自动分配内存给对象，在不使用的时候，垃圾回收器会自动回收对象，释放占用的内存。</p><p>但在某些情况下，正常的生命周期不是最优的选择，有些对象按照JVM默认的方式，创建成本会很高。比如，我在<a href=\"https://time.geekbang.org/column/article/97215\">第03讲</a>讲到的String对象，在特定的场景使用String.intern可以很大程度地节约内存成本。<span class=\"orange\">我们可以使用不同的引用类型，改变一个对象的正常生命周期，从而提高JVM的回收效率，这也是JVM性能调优的一种方式。</span></p><h2>思考题</h2><p>这讲我只提到了堆内存中对象分配内存空间的过程，那如果有一个类中定义了String a=\"b\"和String c = new String(“b”)，请问这两个对象会分别创建在JVM内存模型中的哪块区域呢？</p><p>期待在留言区看到你的答案。也欢迎你点击“请朋友读”，把今天的内容分享给身边的朋友，邀请他一起讨论。</p><p></p>","comments":[{"had_liked":false,"id":112001,"user_name":"张学磊","can_delete":false,"product_type":"c1","uid":1250029,"ip_address":"","ucode":"F545F384A6F1E1","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eotSSnZic41tGkbflx0ogIg3ia6g2muFY1hCgosL2t3icZm7I8Ax1hcv1jNgr6vrZ53dpBuGhaoc6DKg/132","comment_is_top":false,"comment_ctime":1562652040,"is_pvip":false,"replies":[{"id":"40861","content":"对的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562723480,"ip_address":"","comment_id":112001,"utype":1}],"discussion_count":3,"race_medal":0,"score":"353749970312","product_id":100028001,"comment_content":"String a=&quot;b&quot;可能创建一个对象或者不创建对象,如果&quot;b&quot;这个字符串在常量池里不存在会在常量池创建一个String对象&quot;b&quot;,如果已经存在则a直接reference to这个常量池里的对象;<br>String c= new String(&quot;b&quot;)至少创建一个对象,也可能两个,因为用到new关键字,会在堆内在创建一个的String对象,它的值是&quot;b&quot;。同时,如果&quot;b&quot;这个字符串在常量池里不存在,会在常量池创建这个一个String对象&quot;b&quot;。","like_count":83,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457536,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562723480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1307497,"avatar":"https://static001.geekbang.org/account/avatar/00/13/f3/69/7039d03f.jpg","nickname":"书策稠浊","note":"","ucode":"A29875CE15FDA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383348,"discussion_content":"下面那种情况就有两个一样的对象了，堆中1个，长江池中1个，实际上都在堆内存，为啥不重用呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626064479,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1616970,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/2UXuSevhia94o9Eky4OfMuSictaldxcqpjGuvRCOcvjIIoVBAENLEZbv2lgwmwC8icK1ZrUcneNtiaeFBV8MT3uzNg/132","nickname":"Gavin","note":"","ucode":"A5735665E303FD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1307497,"avatar":"https://static001.geekbang.org/account/avatar/00/13/f3/69/7039d03f.jpg","nickname":"书策稠浊","note":"","ucode":"A29875CE15FDA3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559772,"discussion_content":"是呀，同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648951507,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":383348,"ip_address":""},"score":559772,"extra":""}]}]},{"had_liked":false,"id":111907,"user_name":"Xiao","can_delete":false,"product_type":"c1","uid":1179212,"ip_address":"","ucode":"71FFCCEEDE09E1","user_header":"https://static001.geekbang.org/account/avatar/00/11/fe/4c/46eb517a.jpg","comment_is_top":false,"comment_ctime":1562635899,"is_pvip":true,"replies":[{"id":"40717","content":"感谢Xiao同学的提醒。<br><br>我想你说的内存模型应该是指Java内存模型（JMM）吧。这里的JVM内存模型跟Java内存模型是不一样的，这里的JVM内存模型和和内存结构是一个意思。<br><br>元空间是分配的本地内存，文中开始描述不清楚（已纠正），但后面有明确说明。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562655842,"ip_address":"","comment_id":111907,"utype":1}],"discussion_count":1,"race_medal":0,"score":"147591523963","product_id":100028001,"comment_content":"老师，这儿其实应该说JVM内存结构更合适！JVM内存模型是一种规范，和JVM内存结构不是一个概念。其次，元空间，在Java8，不是在堆内分配的，它的大小是依赖于本地内存大小！","like_count":35,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457493,"discussion_content":"感谢Xiao同学的提醒。\n\n我想你说的内存模型应该是指Java内存模型（JMM）吧。这里的JVM内存模型跟Java内存模型是不一样的，这里的JVM内存模型和和内存结构是一个意思。\n\n元空间是分配的本地内存，文中开始描述不清楚（已纠正），但后面有明确说明。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562655842,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":111846,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1562630938,"is_pvip":false,"replies":[{"id":"40689","content":"方法区不是堆的一部分，方法区和堆存在交集。方法区的静态变量和运行时常量池存放在堆中，但类的元信息等还是存放在了本地内存中。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562635509,"ip_address":"","comment_id":111846,"utype":1}],"discussion_count":2,"race_medal":0,"score":"91756944154","product_id":100028001,"comment_content":"请教一个问题，所以1.8开始，方法区是堆的一部分吗？也即是说，方法区的大小受限于堆","like_count":22,"discussions":[{"author":{"id":1226462,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b6/de/95dc7537.jpg","nickname":"双","note":"","ucode":"9A6A370DAD648E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1433,"discussion_content":"&#34;方法区&#34;是规范中的概念并非真正的实现，逻辑上是属于堆的。以hotspot实现为例，1.8之前的&#34;永久代&#34;可以看做&#34;方法区&#34;的实现（当然并不等价），1.8以后取而代之的是&#34;metaspace&#34;，他其实是使用的本地内存，有时叫&#34;非堆&#34;，所以不受xms(堆空间)限制，可以用-XX:MetaspaceSize等指定。","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1562633898,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457467,"discussion_content":"方法区不是堆的一部分，方法区和堆存在交集。方法区的静态变量和运行时常量池存放在堆中，但类的元信息等还是存放在了本地内存中。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1562635509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119226,"user_name":"夏天39度","can_delete":false,"product_type":"c1","uid":1104979,"ip_address":"","ucode":"A929B422255547","user_header":"https://static001.geekbang.org/account/avatar/00/10/dc/53/ccb62ea0.jpg","comment_is_top":false,"comment_ctime":1564539491,"is_pvip":false,"replies":[{"id":"43999","content":"对的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564712946,"ip_address":"","comment_id":119226,"utype":1}],"discussion_count":1,"race_medal":0,"score":"53104147043","product_id":100028001,"comment_content":"超哥，我可以这样理解吗，方法区只是一个逻辑概念，方法区是包括元空间物理内存和堆内存","like_count":13,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460792,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564712946,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119762,"user_name":"Gred","can_delete":false,"product_type":"c1","uid":1442929,"ip_address":"","ucode":"F68068880E348B","user_header":"https://static001.geekbang.org/account/avatar/00/16/04/71/853b2292.jpg","comment_is_top":false,"comment_ctime":1564675492,"is_pvip":false,"replies":[{"id":"44008","content":"严格来说，是静态常量池和运行时常量池，静态常量池是存放字符串字面量、符号引用以及类和方法的信息，而运行时常量池存放的是运行时一些直接引用。<br><br>运行时常量池是在类加载完成之后，将静态常量池中的符号引用值转存到运行时常量池中，类在解析之后，将符号引用替换成直接引用。<br><br>这两个常量池在JDK1.7版本之后，就移到堆内存中了，这里指的是物理空间，而逻辑上还是属于方法区（方法区是逻辑分区）。<br>","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564714745,"ip_address":"","comment_id":119762,"utype":1}],"discussion_count":3,"race_medal":0,"score":"31629446564","product_id":100028001,"comment_content":"老师，运行时变量应该都在方法区中，从java7开始只有字符串常量池移到堆中而已","like_count":8,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461061,"discussion_content":"严格来说，是静态常量池和运行时常量池，静态常量池是存放字符串字面量、符号引用以及类和方法的信息，而运行时常量池存放的是运行时一些直接引用。\n\n运行时常量池是在类加载完成之后，将静态常量池中的符号引用值转存到运行时常量池中，类在解析之后，将符号引用替换成直接引用。\n\n这两个常量池在JDK1.7版本之后，就移到堆内存中了，这里指的是物理空间，而逻辑上还是属于方法区（方法区是逻辑分区）。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564714745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":3198749,"avatar":"https://static001.geekbang.org/account/avatar/00/30/cf/1d/87ceabeb.jpg","nickname":"漫步人生","note":"","ucode":"40A85812DBD4B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":590141,"discussion_content":"老师 请问方法区的物理空间存在堆内存的年轻代还是老年代 又或者单独开辟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665553705,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":461061,"ip_address":"安徽"},"score":590141,"extra":""}]},{"author":{"id":1509008,"avatar":"https://static001.geekbang.org/account/avatar/00/17/06/90/7592bd6a.jpg","nickname":"jeakiry","note":"","ucode":"A436FB6C610A4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":188776,"discussion_content":"永久代的静态变量（class static variables）以及运行时常量池（runtime constant pool）则跟 Java7 一样，转移到了堆中。\n\n静态常量池和静态变量，这两好像有出入，不是很理解。。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582818083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":111836,"user_name":"我又不乱来","can_delete":false,"product_type":"c1","uid":1221356,"ip_address":"","ucode":"737405E2339A8D","user_header":"https://static001.geekbang.org/account/avatar/00/12/a2/ec/205fd50c.jpg","comment_is_top":false,"comment_ctime":1562629321,"is_pvip":false,"replies":[{"id":"40685","content":"正确","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562635234,"ip_address":"","comment_id":111836,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31627400393","product_id":100028001,"comment_content":"String a=&quot;b&quot;应该会放在字符串常量池中。<br>String c= new String(&quot;b&quot;) 首先应该放在 堆中一份，再在常量池中放一份。但是常量池中有b了。<br>第一次留言。不知道理解的对不对。超哥","like_count":7,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457464,"discussion_content":"正确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562635234,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115548,"user_name":"发条橙子 。","can_delete":false,"product_type":"c1","uid":1259218,"ip_address":"","ucode":"ED076F4534FFED","user_header":"https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg","comment_is_top":false,"comment_ctime":1563618047,"is_pvip":false,"replies":[{"id":"43573","content":"是的，没有变化。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564452708,"ip_address":"","comment_id":115548,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23038454527","product_id":100028001,"comment_content":"老师，这句话怎么理解 <br><br>之前永久代的类的元数据存储在了元空间，永久代的静态变量（class static variables）以及运行时常量池（runtime constant pool）则跟 Java7 一样，转移到了堆中。<br><br>方法区的一部分是由永久代实现的，永久代主要存储类的静态数据以及运行时常量池并储存在堆内存中。 但是由于容易发生permen内存溢出，后来就发明了元数据空间。那我理解元空间除了存储之前方法区的类信息还包括之前放在永久代中的 静态变量 和 运行时常量池 。 <br>文中为什么说和jdk7一样还是转移到堆中，那不是没有变化么？","like_count":6,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459154,"discussion_content":"是的，没有变化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564452708,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130289,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1567419261,"is_pvip":false,"replies":[{"id":"48598","content":"我们说的常量池一般分为静态常量池和运行时常量池，通常字符串常量是存放的引用是在运行时常量池，而字面量是存在了静态常量池。动态生成的字符串，对象是存放在堆中，如果调用intern方法，会将引用存放在常量池中。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1567423250,"ip_address":"","comment_id":130289,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18747288445","product_id":100028001,"comment_content":"老师，我看有人说字符串常量池只放引用；那new出来除了堆中会有一个对象，如果字符串常量池没有，也会创建一个，这个对象是在堆中非字符串常量池的地方么","like_count":4,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465892,"discussion_content":"我们说的常量池一般分为静态常量池和运行时常量池，通常字符串常量是存放的引用是在运行时常量池，而字面量是存在了静态常量池。动态生成的字符串，对象是存放在堆中，如果调用intern方法，会将引用存放在常量池中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567423250,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1052859,"avatar":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","nickname":"Demon.Lee","note":"","ucode":"7F0E5493A8E345","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7315,"discussion_content":"老师说的是这个意思吗？String aa = &#34;123&#34;; 其中aa在运行时常量池，&#34;123&#34; 在静态常量池","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567486466,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":112133,"user_name":"黑夜里的猫","can_delete":false,"product_type":"c1","uid":1241906,"ip_address":"","ucode":"8C5D2AF9EB420B","user_header":"https://static001.geekbang.org/account/avatar/00/12/f3/32/44297a74.jpg","comment_is_top":false,"comment_ctime":1562673020,"is_pvip":false,"replies":[{"id":"41143","content":"方法区是一个规范，并不是一个物理空间，我们这里说的字符串常量放在堆内存空间中，是指实际的物理空间。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562895797,"ip_address":"","comment_id":112133,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18742542204","product_id":100028001,"comment_content":"字符串常量不是在java8中已经被放入到堆中了吗，应该不在方法区中了，但是看到老师的图中还在方法区中","like_count":4,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457593,"discussion_content":"方法区是一个规范，并不是一个物理空间，我们这里说的字符串常量放在堆内存空间中，是指实际的物理空间。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562895797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":113170,"user_name":"东方奇骥","can_delete":false,"product_type":"c1","uid":1354850,"ip_address":"","ucode":"DEE7085F7E55A4","user_header":"https://static001.geekbang.org/account/avatar/00/14/ac/62/37912d51.jpg","comment_is_top":false,"comment_ctime":1562907286,"is_pvip":true,"replies":[{"id":"41801","content":"元空间主要存储类的一些信息，包括方法、字段、类等描述类信息。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563333553,"ip_address":"","comment_id":113170,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14447809174","product_id":100028001,"comment_content":"老师，问一下，1.8静态变量和常量存储在的堆里面，那元空间里是什么？文中说之前永久带类的数据存储在了元空间，不是很理解，","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458090,"discussion_content":"元空间主要存储类的一些信息，包括方法、字段、类等描述类信息。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563333553,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":112849,"user_name":"晓杰","can_delete":false,"product_type":"c1","uid":1441546,"ip_address":"","ucode":"1174C88EEBF8A6","user_header":"https://static001.geekbang.org/account/avatar/00/15/ff/0a/12faa44e.jpg","comment_is_top":false,"comment_ctime":1562831284,"is_pvip":false,"replies":[{"id":"41167","content":"对的，这里是申请一个线程栈。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562902007,"ip_address":"","comment_id":112849,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14447733172","product_id":100028001,"comment_content":"创建一个线程，就会在虚拟机中申请一个栈帧，这句话有问题吧<br>应该是创建一个线程，会创建一个栈，然后方法调用一次，就会申请一个栈帧吧","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457928,"discussion_content":"对的，这里是申请一个线程栈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562902007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146446,"user_name":"ZHANG","can_delete":false,"product_type":"c1","uid":1442437,"ip_address":"","ucode":"BAFD110AE33328","user_header":"https://static001.geekbang.org/account/avatar/00/16/02/85/9a81a973.jpg","comment_is_top":false,"comment_ctime":1572526290,"is_pvip":false,"replies":[{"id":"73040","content":"是的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1584536571,"ip_address":"","comment_id":146446,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10162460882","product_id":100028001,"comment_content":"老师，是这样吗，java8中类的静态变量，运行时常量池，字符串常量池都在堆中，那元空间只有一些类的信息了，比如版本什么的。","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472865,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584536571,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":112558,"user_name":"Cain","can_delete":false,"product_type":"c1","uid":1005926,"ip_address":"","ucode":"82BDECC530E27C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/59/66/39eeb3f9.jpg","comment_is_top":false,"comment_ctime":1562758235,"is_pvip":false,"replies":[{"id":"41150","content":"在逻辑空间是属于方法区。堆、栈、方法区等，这些是一种规范，是逻辑上的分区。<br><br>在物理空间中，常量池是存储在堆内存空间的。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562897155,"ip_address":"","comment_id":112558,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10152692827","product_id":100028001,"comment_content":"常量池在哪个区？堆区？栈区？方法区？静态区？方法区，静态区他俩是什么关系？","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457794,"discussion_content":"在逻辑空间是属于方法区。堆、栈、方法区等，这些是一种规范，是逻辑上的分区。\n\n在物理空间中，常量池是存储在堆内存空间的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562897155,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":111915,"user_name":"crazypokerk","can_delete":false,"product_type":"c1","uid":1158383,"ip_address":"","ucode":"9AAD5D9726E503","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/ef/494f56c3.jpg","comment_is_top":false,"comment_ctime":1562636889,"is_pvip":false,"replies":[{"id":"40853","content":"厉害","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562722829,"ip_address":"","comment_id":111915,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10152571481","product_id":100028001,"comment_content":"引用a和c都会放在栈中，但是a直接指向堆中的运行时常量池中的&quot;b&quot;，而引用c会先在堆中创建一个String对象，该对象会指向运行时常量池中的&quot;b&quot;。","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457495,"discussion_content":"厉害","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562722829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":213701,"user_name":"knightyxgy","can_delete":false,"product_type":"c1","uid":1844842,"ip_address":"","ucode":"DBC82FC9F263C9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/WtA4zsJVEhatPFnoAgMoiaguBwsiacRsibsdKuHQ7FnO17EUOx7hcEfM6XAt2wmbCiaAN0LSUPSO98icMSmfPpxg1LQ/132","comment_is_top":false,"comment_ctime":1588516559,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5883483855","product_id":100028001,"comment_content":"请教老师，看了您对其他留言的回答给予了肯定：1、JVM的堆和操作系统的堆不是一个概念。2、静态常量池和运行时常量池移入的堆内存是指物理内存，逻辑上还是属于JVM对于方法区的规范。3、方法区实际上是在本地内存即堆外内存分配的<br>根据老师的回答理解下来，两个常量池移入的堆内存就是操作系统层次的概念，可是JVM内存无论是堆内存还是非堆内存（元空间）应该都是操作系统抽象的堆内存中分配的吧。如何理解操作系统层次的堆和JVM的堆以及本地内存之间的关系呢？","like_count":1},{"had_liked":false,"id":154716,"user_name":"斐波那契","can_delete":false,"product_type":"c1","uid":1464006,"ip_address":"","ucode":"85E2EBC01392B1","user_header":"https://static001.geekbang.org/account/avatar/00/16/56/c6/0b449bc6.jpg","comment_is_top":false,"comment_ctime":1574519106,"is_pvip":false,"replies":[{"id":"59449","content":"两者有区别，通常方法区中有静态常量池和运行时常量池，静态常量池主要存储的是字面量以及符号引用等信息，而运行时常量池存储的是类运行加载时生成的直接引用等信息。静态常量池也包括了我们说的字符串常量池。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1574580679,"ip_address":"","comment_id":154716,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5869486402","product_id":100028001,"comment_content":"老师 看完这个 对于运行时常量池和字符串常量池有点搞不清 是不是运行时常量池包括字符串常量池还是说这两个是不同的东西?","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475557,"discussion_content":"两者有区别，通常方法区中有静态常量池和运行时常量池，静态常量池主要存储的是字面量以及符号引用等信息，而运行时常量池存储的是类运行加载时生成的直接引用等信息。静态常量池也包括了我们说的字符串常量池。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574580679,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1537865,"avatar":"https://static001.geekbang.org/account/avatar/00/17/77/49/445eea2d.jpg","nickname":"SochiLee","note":"","ucode":"47596594EDF4D7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351543,"discussion_content":"对静态常量池和运行时常量池不太理解，请问关于静态常量池和运行时常量池，有哪本比较权威的书籍或资料讲到？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614321272,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126035,"user_name":"帽子丨影","can_delete":false,"product_type":"c1","uid":1225395,"ip_address":"","ucode":"2B34892A2DE83E","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/b3/798a4bb2.jpg","comment_is_top":false,"comment_ctime":1566298712,"is_pvip":false,"replies":[{"id":"50388","content":"本地内存是一种非JVM堆内存","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1567946984,"ip_address":"","comment_id":126035,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5861266008","product_id":100028001,"comment_content":"元空间的存储位置时本地内存，请问下本地内存是个什么东西，在第一张图里没找到啊。","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463798,"discussion_content":"本地内存是一种非JVM堆内存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567946984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1442123,"avatar":"https://static001.geekbang.org/account/avatar/00/16/01/4b/196a7d8a.jpg","nickname":"起点","note":"","ucode":"A54A6D21383B23","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301153,"discussion_content":"本地内存就是操作系统的内存，JVM的内存是由JVM启动的时候向操作系统申请的一块内存区域。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598427232,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":112182,"user_name":"Alpha","can_delete":false,"product_type":"c1","uid":1001861,"ip_address":"","ucode":"60CA15A25EC796","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/85/3f161d95.jpg","comment_is_top":false,"comment_ctime":1562679602,"is_pvip":false,"replies":[{"id":"40867","content":"已捋顺，也就是说静态变量和运行时常量池依然存储在堆内存物理空间中。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562724317,"ip_address":"","comment_id":112182,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5857646898","product_id":100028001,"comment_content":"而到了 Java8，静态变量和运行时常量池与 Java7 的永久代一样，都移到了堆中。 <br><br>这句没看懂。。上一句说到java7把永久代里的静态变量和运行时常量池移到堆中，这一句又说java8移了 静态变量和运行时常量池？","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457611,"discussion_content":"已捋顺，也就是说静态变量和运行时常量池依然存储在堆内存物理空间中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562724317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":111984,"user_name":"听雨","can_delete":false,"product_type":"c1","uid":1254493,"ip_address":"","ucode":"252754F9FCFF0C","user_header":"https://static001.geekbang.org/account/avatar/00/13/24/5d/65e61dcb.jpg","comment_is_top":false,"comment_ctime":1562647630,"is_pvip":false,"replies":[{"id":"40711","content":"而到了 Java8，永久代被元空间取代了，元空间存储静态变量...<br><br>以上这句话描述不准确。将元空间去掉。元空间是使用的本地内存，在后面讲述到了：“并且元空间的存储位置是本地内存”","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562654787,"ip_address":"","comment_id":111984,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5857614926","product_id":100028001,"comment_content":"元空间不是本地内存吗，老师说的元空间移入堆内存是什么意思呀，不理解，是元空间属于堆内存的一部分吗？","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457530,"discussion_content":"而到了 Java8，永久代被元空间取代了，元空间存储静态变量...\n\n以上这句话描述不准确。将元空间去掉。元空间是使用的本地内存，在后面讲述到了：“并且元空间的存储位置是本地内存”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562654787,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":111925,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1562638378,"is_pvip":false,"replies":[{"id":"40855","content":"从实际的存储物理空间来说，都是在JVM的堆内存空间中。而从规范的逻辑空间来说，一个是在方法区的字符串常量池中，一个是在堆中。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562722944,"ip_address":"","comment_id":111925,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5857605674","product_id":100028001,"comment_content":"new的会在堆申请空间。所以在堆。字符串的直接声明赋值会存在字节码的常量池加载后在常量池里面。但是常量池1.8也放堆了，所以都在堆空间。","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457499,"discussion_content":"从实际的存储物理空间来说，都是在JVM的堆内存空间中。而从规范的逻辑空间来说，一个是在方法区的字符串常量池中，一个是在堆中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562722944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":111899,"user_name":"超威丶","can_delete":false,"product_type":"c1","uid":1180753,"ip_address":"","ucode":"1A18DE885D3C44","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/51/da465a93.jpg","comment_is_top":false,"comment_ctime":1562635326,"is_pvip":false,"replies":[{"id":"40851","content":"字符串常量存储在了常量池，引用在运行时存放在了栈中。new String(&quot;&quot;)是会创建一个新对象的，可以查看一下构造函数：<br>    public String(String original) {<br>        this.value = original.value;<br>        this.hash = original.hash;<br>    }<br>","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562722750,"ip_address":"","comment_id":111899,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5857602622","product_id":100028001,"comment_content":"其实常量池中是不会存储具体对象的吧，也是引用，所以说new String的话会现在常量池中去寻找，存在直接由常量池中的引用指向堆中对象，不存在直接开辟新对象？","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457488,"discussion_content":"字符串常量存储在了常量池，引用在运行时存放在了栈中。new String(&amp;quot;&amp;quot;)是会创建一个新对象的，可以查看一下构造函数：\n    public String(String original) {\n        this.value = original.value;\n        this.hash = original.hash;\n    }\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562722750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":111885,"user_name":"undifined","can_delete":false,"product_type":"c1","uid":1068920,"ip_address":"","ucode":"449CB4CD2DC089","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/78/c3d8ecb0.jpg","comment_is_top":false,"comment_ctime":1562634202,"is_pvip":false,"replies":[{"id":"40850","content":"如果更准确一点，就是&quot;b&quot;在方法区的常量池，new String(&quot;b&quot;)在堆中。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562722506,"ip_address":"","comment_id":111885,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5857601498","product_id":100028001,"comment_content":"String a = &quot;b&quot;，会被存放在方法区的常量池中<br>String c = new String(&quot;b&quot;)会被存放在堆中","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457483,"discussion_content":"如果更准确一点，就是&amp;quot;b&amp;quot;在方法区的常量池，new String(&amp;quot;b&amp;quot;)在堆中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562722506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":111844,"user_name":"TerryGoForIt","can_delete":false,"product_type":"c1","uid":1020644,"ip_address":"","ucode":"701B0E72F15AB5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/e4/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1562630074,"is_pvip":false,"replies":[{"id":"40686","content":"对了","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562635253,"ip_address":"","comment_id":111844,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5857597370","product_id":100028001,"comment_content":"思考题：<br>String a=&quot;b&quot;，定义在方法区的常量池中；<br>new String(&quot;b&quot;) 是实例化一个 String 对象，定义在堆中；","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457466,"discussion_content":"对了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562635253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":111831,"user_name":"TerryGoForIt","can_delete":false,"product_type":"c1","uid":1020644,"ip_address":"","ucode":"701B0E72F15AB5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/e4/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1562628578,"is_pvip":false,"replies":[{"id":"40684","content":"是的，调换下位置方便更好理解JIT，因为JIT用到了JVM内存的知识点。声明下，这里不是JMM，JMM是Java Memory Model，而我们这节讲的是JVM的内存模型（Java Virtual Machine Structure）。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562635143,"ip_address":"","comment_id":111831,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5857595874","product_id":100028001,"comment_content":"老师您好，我想问一下，深入理解 JIT 放到下一节了嘛？我看课程目录 JIT 是在 JMM 之前哇。","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457461,"discussion_content":"是的，调换下位置方便更好理解JIT，因为JIT用到了JVM内存的知识点。声明下，这里不是JMM，JMM是Java Memory Model，而我们这节讲的是JVM的内存模型（Java Virtual Machine Structure）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562635143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":293250,"user_name":"丫-泡面","can_delete":false,"product_type":"c1","uid":1251786,"ip_address":"","ucode":"B2DF933F5C61ED","user_header":"https://static001.geekbang.org/account/avatar/00/13/19/ca/99c3e0bc.jpg","comment_is_top":false,"comment_ctime":1621305378,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621305378","product_id":100028001,"comment_content":"老师是用什么工具去看jvm的","like_count":0},{"had_liked":false,"id":291791,"user_name":"知易","can_delete":false,"product_type":"c1","uid":1246882,"ip_address":"","ucode":"BD3E3F0F0A40EF","user_header":"https://static001.geekbang.org/account/avatar/00/13/06/a2/350c4af0.jpg","comment_is_top":false,"comment_ctime":1620484745,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620484745","product_id":100028001,"comment_content":"来自评论<br>老师 看完这个 对于运行时常量池和字符串常量池有点搞不清 是不是运行时常量池包括字符串常量池还是说这两个是不同的东西?<br>作者回复: 两者有区别，通常方法区中有静态常量池和运行时常量池，静态常量池主要存储的是字面量以及符号引用等信息，而运行时常量池存储的是类运行加载时生成的直接引用等信息。静态常量池也包括了我们说的字符串常量池。","like_count":0},{"had_liked":false,"id":290349,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1619511980,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619511980","product_id":100028001,"comment_content":"原文：永久代的静态变量（class static variables）以及运行时常量池（runtime constant pool）则跟 Java7 一样，转移到了堆中。<br><br>请问老师，为什么文章中的图片，静态变量 WOMAN_SEX_TYPE 和常量 &quot;man&quot; 没在堆，而是画在了方法区？<br>谢谢！","like_count":0},{"had_liked":false,"id":279313,"user_name":"._.我大概是只，成功的猫","can_delete":false,"product_type":"c1","uid":1597316,"ip_address":"","ucode":"0BDDEFAB97360F","user_header":"https://static001.geekbang.org/account/avatar/00/18/5f/84/4c8288a6.jpg","comment_is_top":false,"comment_ctime":1613716557,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613716557","product_id":100028001,"comment_content":"刘超老师，对于栈空间，何时释放，能再解释一下吗？","like_count":0},{"had_liked":false,"id":270684,"user_name":"惘 闻","can_delete":false,"product_type":"c1","uid":1181650,"ip_address":"","ucode":"C5909F034BF072","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","comment_is_top":false,"comment_ctime":1609217171,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609217171","product_id":100028001,"comment_content":"老师我有两个问题.<br>问题一: 老师回答中:方法区不是堆的一部分，方法区和堆存在交集。方法区的静态变量和运行时常量池存放在堆中，但类的元信息等还是存放在了本地内存中。<br>老师我看了你的这个回答发现和文章中你给的图不一致.类的元信息在1.7保存在堆中的永久代中,在1.8保存在堆中元空间中.<br>而且方法区中的静态变量和运行时常量池也都是存放在堆中的.<br>所以方法区中的静态变量和运行时常量池和类元信息都是存放在堆中的.那么方法区不就包含在堆中了吗,是不是还有其他方法区的属性不保存在堆中也不保存在元空间或者永久代中呢?<br>问题二: 静态变量和运行时常量池是保存在堆的哪个位置呢?新生代还是老年代.<br>谢谢老师指点!","like_count":0},{"had_liked":false,"id":269286,"user_name":"Andrew.Fang","can_delete":false,"product_type":"c1","uid":2359194,"ip_address":"","ucode":"1D754BBFC223F4","user_header":"https://static001.geekbang.org/account/avatar/00/23/ff/9a/f7d84a69.jpg","comment_is_top":false,"comment_ctime":1608602267,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608602267","product_id":100028001,"comment_content":"反射时获取的Class对象是真正的对象吗？是在堆中的吗？那是什么时候创建的？里面存储的是静态变量吧？这个静态变量和JDK7,8中转移到堆中的静态变量是什么关系？","like_count":0},{"had_liked":false,"id":266142,"user_name":"曾泽浩","can_delete":false,"product_type":"c1","uid":1104601,"ip_address":"","ucode":"A7E5CF9E1571A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/da/d9/f051962f.jpg","comment_is_top":false,"comment_ctime":1607184527,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607184527","product_id":100028001,"comment_content":"老师，你好，运行时常量池指的是什么呢？能否举个例子","like_count":0},{"had_liked":false,"id":265736,"user_name":"静静聆听","can_delete":false,"product_type":"c1","uid":1263932,"ip_address":"","ucode":"0A8600CB928EFE","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/3c/5d54c510.jpg","comment_is_top":false,"comment_ctime":1606998264,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606998264","product_id":100028001,"comment_content":"老师👨🏻‍🏫，请教一下，方法不是在程序计数器中的么，怎么最后一个实战案例，方法还入栈呢","like_count":0},{"had_liked":false,"id":252305,"user_name":"Wheat","can_delete":false,"product_type":"c1","uid":1260141,"ip_address":"","ucode":"7D99EA149B6DE8","user_header":"https://static001.geekbang.org/account/avatar/00/13/3a/6d/910b2445.jpg","comment_is_top":false,"comment_ctime":1602230815,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602230815","product_id":100028001,"comment_content":"老师能讲一下堆内内存和堆外内存吗，哪些逻辑上的分区用的堆内内存，哪些用的堆外内存","like_count":0},{"had_liked":false,"id":252295,"user_name":"Wheat","can_delete":false,"product_type":"c1","uid":1260141,"ip_address":"","ucode":"7D99EA149B6DE8","user_header":"https://static001.geekbang.org/account/avatar/00/13/3a/6d/910b2445.jpg","comment_is_top":false,"comment_ctime":1602226646,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602226646","product_id":100028001,"comment_content":"老师，您在讲堆的时候说，8的时候永久代被元空间替换了，那7时放到堆中的静态变量和运行时常量池去哪了，我看您在讲方法区的时候又说方法区里有运行时常量池，那现在运行时常量池到底在哪呀","like_count":0},{"had_liked":false,"id":251027,"user_name":"BingoJ","can_delete":false,"product_type":"c1","uid":1298126,"ip_address":"","ucode":"6160CD02AD592B","user_header":"https://static001.geekbang.org/account/avatar/00/13/ce/ce/53392e44.jpg","comment_is_top":false,"comment_ctime":1601338264,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601338264","product_id":100028001,"comment_content":"老师，你好，文中说到，“在 JVM 加载完类之后，JVM 会将这个字符串常量放到运行时常量池中”，但是看了你给其他同学的回复中是这样“通常方法区中有静态常量池和运行时常量池，静态常量池也包括了我们说的字符串常量池”，这样是不是有些矛盾～～所以，这个静态常量池，字符串常量池，运行时常量池，这三个东西，还是有些不清楚～～","like_count":0},{"had_liked":false,"id":245815,"user_name":"xcoder","can_delete":false,"product_type":"c1","uid":1207135,"ip_address":"","ucode":"2C70ED36B4AC8E","user_header":"https://static001.geekbang.org/account/avatar/00/12/6b/5f/cec1e980.jpg","comment_is_top":false,"comment_ctime":1599060749,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599060749","product_id":100028001,"comment_content":"在评论中看到很多关于jdk8方法区的实现永久代取消了，改成了元空间，但原来在方法区的静态变量和字符串常量池移到了堆内存中的问题。<br>说实话我真没理解透彻，<br>1.现在的jdk8的元空间到底是怎样的一个概念？是完全独立的本地内存，还是说是方法区的代替永久代的另一种实现呢？<br>2.因为文中又说元空间是用于替代永久代的，且原本方法区永久代存储的类信息存到了元空间中，静态变量和常量池转移到了堆中，那这样来推论好像元空间就是方法区的另一种实现，只是静态变量和常量池还是和JDK7一样还在堆内存中。<br>3.如果元空间是本地内存，那这个意思是不是说元空间是独立于JVM内存结构而存在，不受JVM内存结构的约束？如果不受JVM内存结构的约束，那还要方法区干嘛?","like_count":0},{"had_liked":false,"id":245071,"user_name":"旅途","can_delete":false,"product_type":"c1","uid":1212902,"ip_address":"","ucode":"5022477E8E9441","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/e6/6cafed37.jpg","comment_is_top":false,"comment_ctime":1598803468,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598803468","product_id":100028001,"comment_content":"老师，按您的说法，jdk7永久代里类的信息放在了非堆内存，这样怎么还能 报out of memory呢？","like_count":0},{"had_liked":false,"id":244992,"user_name":"杨杨杨Ray","can_delete":false,"product_type":"c1","uid":1645267,"ip_address":"","ucode":"C2F01C4E07238D","user_header":"https://static001.geekbang.org/account/avatar/00/19/1a/d3/375aea2a.jpg","comment_is_top":false,"comment_ctime":1598776205,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598776205","product_id":100028001,"comment_content":"请问一下，运行时常量池和字符串常量池是什么关系呢？类似String.intern产生的字符串常量是存在字符串常量池还是运行时常量池中呢？","like_count":0},{"had_liked":false,"id":227096,"user_name":"耿嘉艺","can_delete":false,"product_type":"c1","uid":2023401,"ip_address":"","ucode":"727A22BD41E8AF","user_header":"","comment_is_top":false,"comment_ctime":1592284408,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592284408","product_id":100028001,"comment_content":"1. 静态常量区放的常量不止字符串常量，整型常量应该也有吧？具体来说应该是字面量<br>2. 方法区包括类的相关信息、静态常量池、运行时常量池，类的相关信息包括版本信息、字段、方法、接口等<br>3. 元空间存放了类的元信息，那我想问下，这些元信息包括什么信息？","like_count":0},{"had_liked":false,"id":224292,"user_name":"joker","can_delete":false,"product_type":"c1","uid":1041680,"ip_address":"","ucode":"DA1FD164B64083","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e5/10/0a94311f.jpg","comment_is_top":false,"comment_ctime":1591337732,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591337732","product_id":100028001,"comment_content":"超哥，您好，不知道您还能不能看到留言并回复。<br>在学习JVM的内存模型的时候，我有这样一些疑惑：<br>1、我们通常只是定义了堆大小(-Xms初始，-Xmx最大)，虚拟机栈大小(-Xss)。<br>但是我发现这并不能计算出一个java进程占用的全部内存大小。<br>以下是我自己理解的(JDK1.8)：<br>java进程占用的内存<br>    =JVM管理的内存+非JVM管理的内存<br>    =线程独立的内存+线程共享的内存<br>    =n*(虚拟机栈内存+程序计数器内存+本地方法栈内存)+堆内存(heap)+非堆内存(non-heap)+元空间(metaspace)+堆外内存(off-heap:direct memory)<br>其中：<br>    JVM管理的内存：n*(虚拟机栈内存+程序计数器内存+本地方法栈内存)+堆内存(heap)+非堆内存(non-heap)<br>    非JVM管理的内存：元空间(metaspace)+堆外内存(off-heap:direct memory)<br>    线程独立的内存：n*(虚拟机栈内存+程序计数器内存+本地方法栈内存)，n是线程数<br>    线程共享的内存：堆内存(heap)+非堆内存(non-heap)+元空间(metaspace)+对外内存(off-heap:direct memory)<br>以上我的理解是否正确呢？麻烦超哥指点<br><br><br>2、在JDK1.7及以前，有个永久代(PermGen)，也就是文中说的方法区。这块区域也被称为非堆内存<br>    那么在JDK1.8及以后，永久代变成了元空间，到了JVM管理之外了，那么JDK1.8及以后的版本中还有非堆内存(non-heap)的说法吗？如果有的话，是指什么呢？<br><br>3、关于线程独立的这块内存{n*(虚拟机栈内存+程序计数器内存+本地方法栈内存)，n是线程数}，它是完全独立于其他的内存的吗？<br>    还是会分享堆内存，受到堆内存大小的限制<br>    还是说Thread对象是建立在堆内存，然后每个Thread对应的虚拟机栈都是独立的吗？ 换句话说，随着Thread的增加(堆内存充足：还能给新的对象分配内存)，java进程占用的内存会越来越大-----我觉得这肯定不对，但是我却无法解释<br><br>4、我做了一些测试(JDK1.8)：<br>    4.1、指定很小的堆内存，改变虚拟机栈大小<br>        4.1.1、-Xms2m -Xmx2m -Xss16m 启动java进程，直到递归调用1,016,085深度，会报StackOverflowError<br>        4.1.2、-Xms2m -Xmx2m -Xss8m 启动java进程，直到递归调用318,031深度，会报StackOverflowError<br>    4.2、指定很小的堆内存，如-Xms2m -Xmx2m，最终会报OutOfMemoryError","like_count":1},{"had_liked":false,"id":199377,"user_name":"10年以后","can_delete":false,"product_type":"c1","uid":1297421,"ip_address":"","ucode":"FE58CA7E5C2AF9","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/0d/89435926.jpg","comment_is_top":false,"comment_ctime":1585487977,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585487977","product_id":100028001,"comment_content":"内存模型","like_count":0},{"had_liked":false,"id":193919,"user_name":"程序员二师兄","can_delete":false,"product_type":"c1","uid":1205697,"ip_address":"","ucode":"C9E3B5B3358BDF","user_header":"https://static001.geekbang.org/account/avatar/00/12/65/c1/afcd981b.jpg","comment_is_top":false,"comment_ctime":1584982786,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584982786","product_id":100028001,"comment_content":"看了很多文章，这一篇文章是我见过最简单直接清晰讲明白JVM运行原理的。看明白了","like_count":0},{"had_liked":false,"id":187121,"user_name":"Aaron","can_delete":false,"product_type":"c1","uid":1066251,"ip_address":"","ucode":"B0C504A76297C7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/0Qp9pxHBvgdZAveKzsvUFFUicCJfe7ONzhC7jSNFQDNFvg0jRMXuqqZOdxG1qKosylUYrpIHUR2Q76w5m4HtVkg/132","comment_is_top":false,"comment_ctime":1584020902,"is_pvip":true,"replies":[{"id":"73031","content":"这里不分顺序，严格来讲是按照代码的执行顺序来进栈的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1584533618,"ip_address":"","comment_id":187121,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1584020902","product_id":100028001,"comment_content":"&#47;&#47; 调用静态方法 <br>print(stu); <br>&#47;&#47; 调用非静态方法 <br>jvmcase.sayHello(stu);<br><br>为什么sayHello比print方法先压栈？print不是在前面吗？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486997,"discussion_content":"这里不分顺序，严格来讲是按照代码的执行顺序来进栈的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584533618,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184674,"user_name":"f(x)","can_delete":false,"product_type":"c1","uid":1224568,"ip_address":"","ucode":"3680BBD50AFAE4","user_header":"https://static001.geekbang.org/account/avatar/00/12/af/78/07d3e282.jpg","comment_is_top":false,"comment_ctime":1583380582,"is_pvip":false,"replies":[{"id":"72182","content":"是的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1584015765,"ip_address":"","comment_id":184674,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1583380582","product_id":100028001,"comment_content":"老师，上面说的物理空间堆内存，和jvm的堆概念不一样吧，物理空间堆内存是操作系统抽象出来的数据结构吗？，jvm的堆是jvm逻辑分区？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486089,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584015765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184489,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1583326770,"is_pvip":false,"replies":[{"id":"72184","content":"是的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1584016172,"ip_address":"","comment_id":184489,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1583326770","product_id":100028001,"comment_content":"编译期的class文件的中，static修饰静态变量和静态代码块是不会放到常量池么？因为您文章说符号引用只包括字符串字面量和常量，加载到JVM后，静态变量是放在堆中的静态常量池么","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486033,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584016172,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184488,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1583326410,"is_pvip":false,"replies":[{"id":"72185","content":"不会的，元空间存储的是类信息，常量池存储的是引用和常量","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1584016241,"ip_address":"","comment_id":184488,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1583326410","product_id":100028001,"comment_content":"静态常量池和运行时常量池都移动到堆中了吧，那么元空间存的是class的类结构信息，两者是否会有重复之处？比如，static int a = 0; 元空间会有信息，静态常量池也会有？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486032,"discussion_content":"不会的，元空间存储的是类信息，常量池存储的是引用和常量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584016241,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163823,"user_name":"将军","can_delete":false,"product_type":"c1","uid":1113211,"ip_address":"","ucode":"51A23EB5D9C866","user_header":"https://static001.geekbang.org/account/avatar/00/10/fc/7b/3e7622c8.jpg","comment_is_top":false,"comment_ctime":1576808321,"is_pvip":true,"replies":[{"id":"62973","content":"我们说的是JVM的内存模型（Java Virtual Machine Structure），不是JMM（Java Memory Model）。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1577186672,"ip_address":"","comment_id":163823,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1576808321","product_id":100028001,"comment_content":"老师，这应该不叫内存模型，叫内存区域吧。内存模型不是主内存和工作内存的同步吗？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478543,"discussion_content":"我们说的是JVM的内存模型（Java Virtual Machine Structure），不是JMM（Java Memory Model）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577186672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150803,"user_name":"Malcolm。","can_delete":false,"product_type":"c1","uid":1230086,"ip_address":"","ucode":"EE50DA745FC6A7","user_header":"https://static001.geekbang.org/account/avatar/00/12/c5/06/acc0c221.jpg","comment_is_top":false,"comment_ctime":1573611759,"is_pvip":false,"replies":[{"id":"72194","content":"是的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1584016938,"ip_address":"","comment_id":150803,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573611759","product_id":100028001,"comment_content":"print 静态方法属于 JVMCase 类  JVMCase 类在方法区 所以静态方法也是在方法区是吧","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474272,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584016938,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142420,"user_name":"谭震弘","can_delete":false,"product_type":"c1","uid":1606866,"ip_address":"","ucode":"CFCE9107F0F31A","user_header":"https://static001.geekbang.org/account/avatar/00/18/84/d2/7668d3cb.jpg","comment_is_top":false,"comment_ctime":1571365667,"is_pvip":false,"replies":[{"id":"55139","content":"对的，此处的数量是指CPU核数","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1571472333,"ip_address":"","comment_id":142420,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571365667","product_id":100028001,"comment_content":"由于 Java 是多线程语言，当执行的线程数量超过 CPU数量<br><br>这里cpu数量不对把，应该是cpu核数？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471117,"discussion_content":"对的，此处的数量是指CPU核数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571472333,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142277,"user_name":"丁浪","can_delete":false,"product_type":"c1","uid":1055145,"ip_address":"","ucode":"F71070AA75E89B","user_header":"https://static001.geekbang.org/account/avatar/00/10/19/a9/f48eefad.jpg","comment_is_top":false,"comment_ctime":1571324313,"is_pvip":false,"replies":[{"id":"55149","content":"从官方文档解释，class metadata is stored in a new space called Metaspace，所以并没有指出有其他内容存放在元空间。具体的可以参考以下链接：<br>https:&#47;&#47;www.oracle.com&#47;webfolder&#47;technetwork&#47;tutorials&#47;mooc&#47;JVM_Troubleshooting&#47;week1&#47;lesson1.pdf<br><br>","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1571475211,"ip_address":"","comment_id":142277,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571324313","product_id":100028001,"comment_content":"你的理解跟我不太一致，说下我的理解。<br>jdk7以前，常量池都是存放在方法区，也就是永久代中。jdk7的时候，只是把“字符串常量池”从方法区&#47;永久代中移除了，“运行时字符串”其实还没变的。jdk8的时候，只是用元空间取代了以前的永久代，“字符串常量池”在堆中，“运行时常量”、类的元数据信息等等都在元空间。元空间属于非堆，使用的是本地内存。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471057,"discussion_content":"从官方文档解释，class metadata is stored in a new space called Metaspace，所以并没有指出有其他内容存放在元空间。具体的可以参考以下链接：\nhttps://www.oracle.com/webfolder/technetwork/tutorials/mooc/JVM_Troubleshooting/week1/lesson1.pdf\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571475211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132506,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1568157561,"is_pvip":false,"replies":[{"id":"50699","content":"1、根据机器配置环境创建线程数量不一样；2、3&#47;4&#47;5有可能会成为瓶颈，有参数可以调节，例如，使用-Xss 参数设置栈的大小。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1568166253,"ip_address":"","comment_id":132506,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568157561","product_id":100028001,"comment_content":"课后思考及问题<br>1：JVM的内存结构<br>1-1：堆——共享，最大，存几乎所有对象和数组，内部有分为年轻代和老年代，年轻代又继续分为E区、S0区、S1区。<br>1-2：方法区——共享，是个逻辑分区，8-物理上在堆上分配，存类信息、运行时常量池、静态常量池等信息。8是开辟了部分本地内存，用于存储类信息，常量池信息还在堆上分配。<br>1-3：虚拟机方法栈——私有，存储线程的方法调用信息，主要是栈帧。<br>1-4：本地方法栈——私有，存储线程的本地方法调用信息，也是主要是栈帧。<br>1-5：程序计数器——私有，记录线程的当前执行的位置信息。<br>老师，请问线程能创建多少，3&#47;4&#47;5中最小的是一个关键限制因素嘛？这三个区域也有对用的配置参数可调控吧？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466978,"discussion_content":"1、根据机器配置环境创建线程数量不一样；2、3/4/5有可能会成为瓶颈，有参数可以调节，例如，使用-Xss 参数设置栈的大小。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568166253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123193,"user_name":"飞翔","can_delete":false,"product_type":"c1","uid":1068571,"ip_address":"","ucode":"65AF6AF292DAD6","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/1b/f4b786b9.jpg","comment_is_top":false,"comment_ctime":1565623541,"is_pvip":true,"replies":[{"id":"45276","content":"本地方法一般是指非Java实现的代码提供的方法，通常都是C&#47;C++实现的，例如Unsafe下面的allocateMemory","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1565659417,"ip_address":"","comment_id":123193,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565623541","product_id":100028001,"comment_content":"老师 啥是 本地方法呀？ 可否举个例子<br><br>","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462575,"discussion_content":"本地方法一般是指非Java实现的代码提供的方法，通常都是C/C++实现的，例如Unsafe下面的allocateMemory","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565659417,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122269,"user_name":"冉","can_delete":false,"product_type":"c1","uid":1136462,"ip_address":"","ucode":"72E88C227C02CD","user_header":"https://static001.geekbang.org/account/avatar/00/11/57/4e/dd45e359.jpg","comment_is_top":false,"comment_ctime":1565327538,"is_pvip":true,"replies":[{"id":"45114","content":"是的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1565575180,"ip_address":"","comment_id":122269,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565327538","product_id":100028001,"comment_content":"老师你好，我有个疑问，编译器会在.java 文件被编译成.class 文件时，收集 所有类的初始化代码，包括静态变量赋值语句、静态代码块、静态方法，收集在一起成为&lt;clinit&gt;()方法，文中所提 jvm在类初始化阶段会执行&lt;clinit&gt;()方法,那么静态方法是不是也会被一起执行呢？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462180,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565575180,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119438,"user_name":"Gred","can_delete":false,"product_type":"c1","uid":1442929,"ip_address":"","ucode":"F68068880E348B","user_header":"https://static001.geekbang.org/account/avatar/00/16/04/71/853b2292.jpg","comment_is_top":false,"comment_ctime":1564587220,"is_pvip":false,"replies":[{"id":"44005","content":"在方法区，方法区是一个逻辑分区空间。而实际分配的内存地址是在堆内存中分配的，这里指的堆是物理空间。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564713458,"ip_address":"","comment_id":119438,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1564587220","product_id":100028001,"comment_content":"Java的运行时常量池到底是在堆还是方法区，我看老师有些地方描述的是在方法区？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460905,"discussion_content":"在方法区，方法区是一个逻辑分区空间。而实际分配的内存地址是在堆内存中分配的，这里指的堆是物理空间。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564713458,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115727,"user_name":"Gankki","can_delete":false,"product_type":"c1","uid":1190150,"ip_address":"","ucode":"399C6F74286590","user_header":"https://static001.geekbang.org/account/avatar/00/12/29/06/0b327738.jpg","comment_is_top":false,"comment_ctime":1563705693,"is_pvip":false,"replies":[{"id":"43571","content":"可以的，nick.liuchao@hotmail.com。可以提出具体不懂的地方，我们一起讨论分析。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564452570,"ip_address":"","comment_id":115727,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563705693","product_id":100028001,"comment_content":"刘老师好，final修饰的基本数据类型和引用类型在类加载阶段和实例化后的内存分配还不是很清楚，可以在请教老师一下吗？<br>另外老师 github 留的邮箱没找到呀，可以回复留一个吗？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459258,"discussion_content":"可以的，nick.liuchao@hotmail.com。可以提出具体不懂的地方，我们一起讨论分析。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564452570,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114400,"user_name":"小白程序之路","can_delete":false,"product_type":"c1","uid":1134218,"ip_address":"","ucode":"ADDD1C2640C32A","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/8a/514101cb.jpg","comment_is_top":false,"comment_ctime":1563289904,"is_pvip":true,"replies":[{"id":"41770","content":"对的，谢谢这位同学的提醒","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563326216,"ip_address":"","comment_id":114400,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563289904","product_id":100028001,"comment_content":"老师，你的图中方法区初始化的时候两个字段名称都写成了是 MAN_SEX_TYPE，应该是一个：MAN_SEX_TYPE、WOMAN_SEX_TYPE","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458644,"discussion_content":"对的，谢谢这位同学的提醒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563326216,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":113974,"user_name":"文灏","can_delete":false,"product_type":"c1","uid":1122739,"ip_address":"","ucode":"177D548FC87BED","user_header":"https://static001.geekbang.org/account/avatar/00/11/21/b3/db933462.jpg","comment_is_top":false,"comment_ctime":1563197055,"is_pvip":false,"replies":[{"id":"41619","content":"元空间是属于方法区的，方法区只是一个逻辑分区，而元空间是具体实现。所以类的元数据是存放在元空间的，逻辑上属于方法区。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563244882,"ip_address":"","comment_id":113974,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563197055","product_id":100028001,"comment_content":"请教一下，1.8中类的元数据是放在元数据区还是方法区呢？看得有点晕","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458462,"discussion_content":"元空间是属于方法区的，方法区只是一个逻辑分区，而元空间是具体实现。所以类的元数据是存放在元空间的，逻辑上属于方法区。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563244882,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":112653,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1562802883,"is_pvip":false,"replies":[{"id":"41156","content":"对的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562899334,"ip_address":"","comment_id":112653,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562802883","product_id":100028001,"comment_content":"看了下留言，我再和老师确认下，所以方法区实际上是在本地内存即堆外内存分配的吗","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457839,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562899334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":112514,"user_name":"小橙橙","can_delete":false,"product_type":"c1","uid":1054923,"ip_address":"","ucode":"4F467210A15F66","user_header":"https://static001.geekbang.org/account/avatar/00/10/18/cb/edb5a0a0.jpg","comment_is_top":false,"comment_ctime":1562749495,"is_pvip":false,"replies":[{"id":"41149","content":"跟之前永久代的作用差不多，例如，存储类信息，只是实现的方式和存储的位置不一样。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562897079,"ip_address":"","comment_id":112514,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562749495","product_id":100028001,"comment_content":"老师好，文中说“元空间（class metadata）代替了之前的永久代”，但元空间在Java1.8版本中的作用是什么呢？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457774,"discussion_content":"跟之前永久代的作用差不多，例如，存储类信息，只是实现的方式和存储的位置不一样。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562897079,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":112340,"user_name":"苏志辉","can_delete":false,"product_type":"c1","uid":1068927,"ip_address":"","ucode":"39B25CE21C04EE","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/7f/5dc11380.jpg","comment_is_top":false,"comment_ctime":1562722056,"is_pvip":false,"replies":[{"id":"41148","content":"有部分是属于堆空间。对的，这里不强调调用顺序。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562896988,"ip_address":"","comment_id":112340,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562722056","product_id":100028001,"comment_content":"图中黄色的部分方法区属于堆吧，还有就是我看先调用的是print然后是sayhello","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457686,"discussion_content":"有部分是属于堆空间。对的，这里不强调调用顺序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562896988,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":112320,"user_name":"一路奔跑","can_delete":false,"product_type":"c1","uid":1562814,"ip_address":"","ucode":"F1B708E8AE1793","user_header":"https://static001.geekbang.org/account/avatar/00/17/d8/be/49d49db2.jpg","comment_is_top":false,"comment_ctime":1562720124,"is_pvip":false,"replies":[{"id":"40844","content":"已修正，以文章为准","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562721969,"ip_address":"","comment_id":112320,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562720124","product_id":100028001,"comment_content":"刘老师，前面章节在评论区有指出文章内容描述不准确的地方，修改了吗？如果修改了我们就以文章为准，如果没有，我们读文章时就注意下！！","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457673,"discussion_content":"已修正，以文章为准","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562721969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":112294,"user_name":"MZC","can_delete":false,"product_type":"c1","uid":1399853,"ip_address":"","ucode":"46278027D522FB","user_header":"https://static001.geekbang.org/account/avatar/00/15/5c/2d/226a3631.jpg","comment_is_top":false,"comment_ctime":1562717463,"is_pvip":false,"replies":[{"id":"41147","content":"都有入栈出栈","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562896895,"ip_address":"","comment_id":112294,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562717463","product_id":100028001,"comment_content":"老师    有个问题   就是上边讲的JVMCase 的sayHello方法入栈 非静态方法入栈   那静态方法呢","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457663,"discussion_content":"都有入栈出栈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562896895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":112275,"user_name":"明翼","can_delete":false,"product_type":"c1","uid":1068361,"ip_address":"","ucode":"E77F86BEB3D5C1","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/49/28e73b9c.jpg","comment_is_top":false,"comment_ctime":1562712675,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1562712675","product_id":100028001,"comment_content":"老师您的这些知识是怎么学的啊？厉害","like_count":0,"discussions":[{"author":{"id":1328342,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/uXBAfhWDWhwMbMNbbVbENibOmeDNQ6dQuLKicP2emibGUTrt0Z311Mczh6oareppbuu5TTOPIwXs42ahwcWRQB4pw/132","nickname":"英长","note":"","ucode":"501CF122762F8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1753,"discussion_content":"可以看看深入理解jvm虚拟机","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562893879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":112253,"user_name":"歪曲丶","can_delete":false,"product_type":"c1","uid":1182880,"ip_address":"","ucode":"5D3DDAAFFE2C7D","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/a0/a7a87f96.jpg","comment_is_top":false,"comment_ctime":1562691043,"is_pvip":true,"replies":[{"id":"40849","content":"哈哈，厉害了。这些知识点在下一讲中将会出现。这里是在排除这些情况下的问答题。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562722384,"ip_address":"","comment_id":112253,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562691043","product_id":100028001,"comment_content":"无用代码剔除 方法内联 逃逸分析等特性下 new String(&quot;b&quot;) 不会创建对象的 ","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457640,"discussion_content":"哈哈，厉害了。这些知识点在下一讲中将会出现。这里是在排除这些情况下的问答题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562722384,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":112049,"user_name":"colin","can_delete":false,"product_type":"c1","uid":1292206,"ip_address":"","ucode":"7A8849B8AE33E0","user_header":"https://static001.geekbang.org/account/avatar/00/13/b7/ae/a25fcb73.jpg","comment_is_top":false,"comment_ctime":1562660250,"is_pvip":false,"replies":[{"id":"40864","content":"从物理空间来说，是属于堆内存空间的，而从逻辑空间来说，它是属于方法区。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562724080,"ip_address":"","comment_id":112049,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562660250","product_id":100028001,"comment_content":"java7的那个图中，堆好像把永久代也包括了，这个是不是有点问题","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457552,"discussion_content":"从物理空间来说，是属于堆内存空间的，而从逻辑空间来说，它是属于方法区。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562724080,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":111937,"user_name":"iris","can_delete":false,"product_type":"c1","uid":1165241,"ip_address":"","ucode":"9F7D34AE07DDF1","user_header":"https://static001.geekbang.org/account/avatar/00/11/c7/b9/0e01e81a.jpg","comment_is_top":false,"comment_ctime":1562640040,"is_pvip":false,"replies":[{"id":"40858","content":"是本地内存，oracle以及openjdk官网都有说明：Metaspace is allocated out of native memory。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562723313,"ip_address":"","comment_id":111937,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562640040","product_id":100028001,"comment_content":"我也记得说，元空间是使用的堆外物理内存啊，网上什么说法都有，老师有权威一点的官方文档说法吗","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457505,"discussion_content":"是本地内存，oracle以及openjdk官网都有说明：Metaspace is allocated out of native memory。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562723313,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":111814,"user_name":"nightmare","can_delete":false,"product_type":"c1","uid":1056314,"ip_address":"","ucode":"EF2E51C2122A86","user_header":"https://static001.geekbang.org/account/avatar/00/10/1e/3a/5b21c01c.jpg","comment_is_top":false,"comment_ctime":1562622319,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562622319","product_id":100028001,"comment_content":"字面量b位于堆的运行时常量池中，a变量的引用指向字面量b，而c需要在堆中创建一个对象，对象执行字面量","like_count":0}]}