{"id":548002,"title":"07｜手写CPU（二）：如何实现指令译码模块？","content":"<p>你好，我是LMOS。</p><p>上节课，我们了解了什么是CPU的流水线，并决定采用经典的五级流水线来设计我们的MiniCPU，之后梳理了我们将要设计的MiniCPU架构长什么样，最后完成了流水线的第一步——取指。</p><p>取指阶段把存储器里的指令读出以后，就会传递给后续的译码模块进行处理。那之后指令是如何译码的呢？这就要说到流水线的第二步——译码（代码从<a href=\"https://gitee.com/lmos/Geek-time-computer-foundation\">这里</a>下载）。</p><h2>指令是如何翻译的？</h2><p><a href=\"https://time.geekbang.org/column/article/546957\">第五节课</a>我们已经讲过了RISC-V指令架构，明确了我们的MiniCPU选用的是RV32I指令集。其中每条指令都是32位，且分为6种指令格式，不同格式的指令中包含了不一样的指令信息。</p><p><img src=\"https://static001.geekbang.org/resource/image/7b/c8/7b035797137a9e42cc1f6544d6d4dac8.jpg?wh=4005x2200\" alt=\"\"></p><p>如上图所示的6种指令格式，其中R型指令包含了操作码opcode、目标寄存器索引rd、功能码funct3和funct7以及源寄存器索引rs1和rs2。而I型指令则是包含操作码opcode、目标寄存器索引rd、功能码funct3、源寄存器索引rs1以及立即数imm。</p><p>与此类似，后面的S型指令、B型指令、U型指令和J型指令也有特定的操作码、功能码、源寄存器索引、目标寄存器索引和立即数。</p><p>不过指令格式不同，指令译码模块翻译指令的工作机制却是统一的。首先译码电路会翻译出指令中携带的寄存器索引、立即数大小等执行信息。接着，在解决数据可能存在的数据冒险（这个概念后面第九节课会讲）之后，由译码数据通路负责把译码后的指令信息，发送给对应的执行单元去执行。</p><!-- [[[read_end]]] --><h2>译码模块的设计</h2><p>通过上面的分析，你是否对译码模块的设计已经有了头绪？是的，译码模块就是拆解从取指模块传过来的每一条指令。译码时，需要识别出指令的操作码，并根据对应的指令格式提取出指令中包含的信息。</p><p>译码模块具体的Verilog设计代码如下：</p><pre><code class=\"language-verilog\">module decode (\n  input  [31:0] instr,\t\t\t//指令源码\n\n  output  [4:0] rs1_addr,\t\t//源寄存器rs1索引\n  output  [4:0] rs2_addr,\t\t//源寄存器rs2索引\n  output  [4:0] rd_addr,\t\t//目标寄存器rd索引\n  output  [2:0] funct3,\t\t\t//功能码funct3\n  output  [6:0] funct7,\t\t\t//功能码funct7\n  output        branch,\n  output [1:0]  jump,\n  output        mem_read,\n  output        mem_write,\n  output        reg_write,\n  output        to_reg,\n  output [1:0]  result_sel,\n  output        alu_src,\n  output        pc_add,\n  output [6:0]  types,\n  output [1:0]  alu_ctrlop,\n  output        valid_inst,\n  output [31:0] imm\n);\n\nlocalparam DEC_INVALID = 21'b0;\n\nreg [20:0] dec_array;\n\n//---------- decode rs1、rs2 -----------------\nassign rs1_addr = instr[19:15]; \nassign rs2_addr = instr[24:20];\n\n//---------- decode rd -----------------------\nassign rd_addr = instr[11:7]; \n\n//---------- decode funct3、funct7 -----------\nassign funct7 = instr[31:25]; \nassign funct3 = instr[14:12]; \n\n// ----------------------------- decode signals ---------------------------------\n\n//                        20     19-18  17       16        15        14     13-12      11      10     9--------3  2---1      0\n//                        branch jump   memRead  memWrite  regWrite  toReg  resultSel  aluSrc  pcAdd     RISBUJZ  aluctrlop  validInst\nlocalparam DEC_LUI     = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b01,     1'b0,   1'b0,  7'b0000100, 2'b00,     1'b1};\nlocalparam DEC_AUIPC   = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b00,     1'b1,   1'b1,  7'b0000100, 2'b00,     1'b1};\nlocalparam DEC_JAL     = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b10,     1'b0,   1'b0,  7'b0000010, 2'b00,     1'b1};\nlocalparam DEC_JALR    = {1'b0,  2'b11, 1'b0,    1'b0,     1'b1,     1'b0,  2'b10,     1'b1,   1'b0,  7'b0100000, 2'b00,     1'b1};\nlocalparam DEC_BRANCH  = {1'b1,  2'b00, 1'b0,    1'b0,     1'b0,     1'b0,  2'b00,     1'b0,   1'b0,  7'b0001000, 2'b10,     1'b1};\nlocalparam DEC_LOAD    = {1'b0,  2'b00, 1'b1,    1'b0,     1'b1,     1'b1,  2'b00,     1'b1,   1'b0,  7'b0100000, 2'b00,     1'b1};\nlocalparam DEC_STORE   = {1'b0,  2'b00, 1'b0,    1'b1,     1'b0,     1'b0,  2'b00,     1'b1,   1'b0,  7'b0010000, 2'b00,     1'b1};\nlocalparam DEC_ALUI    = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b00,     1'b1,   1'b0,  7'b0100000, 2'b01,     1'b1};\nlocalparam DEC_ALUR    = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b00,     1'b0,   1'b0,  7'b1000000, 2'b01,     1'b1};\n\nassign  {branch, jump, mem_read, mem_write, reg_write, to_reg, result_sel, alu_src, pc_add, types, alu_ctrlop, valid_inst} = dec_array;\n\nalways @(*) begin\n  case(instr[6:0])\n    `OPCODE_LUI    :   dec_array &lt;= DEC_LUI;   \n    `OPCODE_AUIPC  :   dec_array &lt;= DEC_AUIPC; \n    `OPCODE_JAL    :   dec_array &lt;= DEC_JAL; \n    `OPCODE_JALR   :   dec_array &lt;= DEC_JALR;   \n    `OPCODE_BRANCH :   dec_array &lt;= DEC_BRANCH; \n    `OPCODE_LOAD   :   dec_array &lt;= DEC_LOAD;   \n    `OPCODE_STORE  :   dec_array &lt;= DEC_STORE;  \n    `OPCODE_ALUI   :   dec_array &lt;= DEC_ALUI;  \n    `OPCODE_ALUR   :   dec_array &lt;= DEC_ALUR;  \n    default        :  begin\n                 dec_array &lt;= DEC_INVALID;\n    end\n  endcase\nend\n\n// -------------------- IMM -------------------------\n\nwire [31:0] Iimm = {{21{instr[31]}}, instr[30:20]};\nwire [31:0] Simm = {{21{instr[31]}}, instr[30:25], instr[11:7]};\nwire [31:0] Bimm = {{20{instr[31]}}, instr[7], instr[30:25], instr[11:8], 1'b0};\nwire [31:0] Uimm = {instr[31:12], 12'b0};\nwire [31:0] Jimm = {{12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0};   \n\nassign imm = {32{types[5]}} &amp; Iimm\n           | {32{types[4]}} &amp; Simm\n           | {32{types[3]}} &amp; Bimm\n           | {32{types[2]}} &amp; Uimm\n           | {32{types[1]}} &amp; Jimm;\n\nendmodule\n</code></pre><p>这段代码看起来很长，其实整个代码可以分为三个部分：第28行到37行负责完成指令的源寄存器、目标寄存器、3位操作码和7位操作码的译码，第40行至73行负责完成指令格式类型的识别，第75行至87行负责完成立即数译码。</p><p>首先，我们来看指令中源寄存器、目标寄存器、3位操作码和7位操作码的译码。仔细观察上面提到的6种指令格式，我们可以发现一定的规律：全部的目标寄存器索引 <strong>rd</strong> 都位于指令的第7～11位，源寄存器索引 <strong>rs1</strong> 位于指令的第15～19位，源寄存器索引 <strong>rs2</strong> 位于指令的第20～24位，三位的操作码 <strong>funct3</strong> 位于指令的第12～14位，七位的操作码 <strong>funct7</strong> 位于指令的第25～31位。</p><p>它们的位置分布如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/c1/7a/c1d593a99ac6b08e50yy0c45a930857a.jpg?wh=1920x310\" alt=\"图片\"></p><p>上述这些信号在不同指令格式中的位置比较固定。因此我们就可以根据这些位置特点，直接从指令中截取，从而得到它们相应的信息，具体实现的Verilog代码如下（对应整体代码的27～37行）：</p><pre><code class=\"language-verilog\">//---------- decode rs1、rs2 -----------------\nassign rs1_addr = instr[19:15]; \nassign rs2_addr = instr[24:20];\n\n//---------- decode rd -----------------------\nassign rd_addr = instr[11:7]; \n\n//---------- decode funct3、funct7 -----------\nassign funct7 = instr[31:25]; \nassign funct3 = instr[14:12]; \n</code></pre><p>在所有的指令格式中，还有一段最为特殊的信息码。这段信息码是每条指令都有的，且位置和位宽保持不变。没错，它就是指令的操作码opcode。</p><p>对照RISC-V的官方手册，我为你整理出了RV32I指令集的操作码对照表，如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/2e/23/2ea867d9beff30ca1b60fa9e8003ec23.jpg?wh=1920x1286\" alt=\"图片\"></p><p>我们再来回顾一下RISC-V的指令格式，这次我们重点观察指令操作码的位置。</p><p><img src=\"https://static001.geekbang.org/resource/image/7b/c8/7b035797137a9e42cc1f6544d6d4dac8.jpg?wh=4005x2200\" alt=\"\"></p><p>不难发现，所有指令操作码都位于指令的第0～6位。根据这7位的操作码就可以判断出一条指令是什么类型，它对应的是什么指令格式。进而可以产生指令执行信号，为后续的指令执行单元的操作提供依据。</p><p>以下就是指令操作码的译码和产生相关指令控制信号的Verilog代码（对应整体代码的39～72行）：</p><pre><code class=\"language-verilog\">// ----------------------------- decode signals ---------------------------------\n\n//                        20     19-18  17       16        15        14     13-12      11      10     9--------3  2---1      0\n//                        branch jump   memRead  memWrite  regWrite  toReg  resultSel  aluSrc  pcAdd     RISBUJZ  aluctrlop  validInst\nlocalparam DEC_LUI     = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b01,     1'b0,   1'b0,  7'b0000100, 2'b00,     1'b1};\nlocalparam DEC_AUIPC   = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b00,     1'b1,   1'b1,  7'b0000100, 2'b00,     1'b1};\nlocalparam DEC_JAL     = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b10,     1'b0,   1'b0,  7'b0000010, 2'b00,     1'b1};\nlocalparam DEC_JALR    = {1'b0,  2'b11, 1'b0,    1'b0,     1'b1,     1'b0,  2'b10,     1'b1,   1'b0,  7'b0100000, 2'b00,     1'b1};\nlocalparam DEC_BRANCH  = {1'b1,  2'b00, 1'b0,    1'b0,     1'b0,     1'b0,  2'b00,     1'b0,   1'b0,  7'b0001000, 2'b10,     1'b1};\nlocalparam DEC_LOAD    = {1'b0,  2'b00, 1'b1,    1'b0,     1'b1,     1'b1,  2'b00,     1'b1,   1'b0,  7'b0100000, 2'b00,     1'b1};\nlocalparam DEC_STORE   = {1'b0,  2'b00, 1'b0,    1'b1,     1'b0,     1'b0,  2'b00,     1'b1,   1'b0,  7'b0010000, 2'b00,     1'b1};\nlocalparam DEC_ALUI    = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b00,     1'b1,   1'b0,  7'b0100000, 2'b01,     1'b1};\nlocalparam DEC_ALUR    = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b00,     1'b0,   1'b0,  7'b1000000, 2'b01,     1'b1};\n\nassign  {branch, jump, mem_read, mem_write, reg_write, to_reg, result_sel, alu_src, pc_add, types, alu_ctrlop, valid_inst} = dec_array;\n\nalways @(*) begin\n  case(instr[6:0])\n    `OPCODE_LUI    :   dec_array &lt;= DEC_LUI;   \n    `OPCODE_AUIPC  :   dec_array &lt;= DEC_AUIPC; \n    `OPCODE_JAL    :   dec_array &lt;= DEC_JAL; \n    `OPCODE_JALR   :   dec_array &lt;= DEC_JALR;   \n    `OPCODE_BRANCH :   dec_array &lt;= DEC_BRANCH; \n    `OPCODE_LOAD   :   dec_array &lt;= DEC_LOAD;   \n    `OPCODE_STORE  :   dec_array &lt;= DEC_STORE;  \n    `OPCODE_ALUI   :   dec_array &lt;= DEC_ALUI;  \n    `OPCODE_ALUR   :   dec_array &lt;= DEC_ALUR;  \n    default        :  begin\n                 dec_array &lt;= DEC_INVALID;\n    end\n  endcase\nend\n</code></pre><p>从上面的代码我们可以看到，译码的过程就是先识别指令的低7位操作码instr[6:0]，根据操作码对应的代码标识，产生分支信号branch、跳转信号jump、读存储器信号mem_read……这些译码之后的指令控制信息。然后，把译码得到的信息交到CPU流水线的下一级去执行。</p><p>此外，还有指令中的立即数需要提取。观察上述的6种指令格式你会发现，除了R型指令不包含立即数，其他5种指令类型都包含了立即数。</p><p>前面我已经讲过了怎么去识别指令的类型。那指令里的立即数怎么提取呢？其实这跟提取指令的索引、功能码差不多。</p><p>我们根据不同指令类型中立即数的分布位置，就能直接提取指令的立即数。最后也是根据指令的类型选择性输出I型、S型、B型、U型或者J型指令的立即数即可，具体的代码如下：</p><pre><code class=\"language-verilog\">// -------------------- IMM -------------------------\n\nwire [31:0] Iimm = {{21{instr[31]}}, instr[30:20]};\nwire [31:0] Simm = {{21{instr[31]}}, instr[30:25], instr[11:7]};\nwire [31:0] Bimm = {{20{instr[31]}}, instr[7], instr[30:25], instr[11:8], 1'b0};\nwire [31:0] Uimm = {instr[31:12], 12'b0};\nwire [31:0] Jimm = {{12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0};   \n\nassign imm = {32{types[5]}} &amp; Iimm\n           | {32{types[4]}} &amp; Simm\n           | {32{types[3]}} &amp; Bimm\n           | {32{types[2]}} &amp; Uimm\n           | {32{types[1]}} &amp; Jimm;\n</code></pre><h2>译码控制模块设计</h2><p>前面的译码模块得到的指令信号，可以分为两大类。一类是由指令的操作码经过译码后产生的<strong>指令执行控制信号</strong>，如跳转操作jump信号、存储器读取mem_read信号等；另一类是从指令源码中提取出来的<strong>数据信息</strong>，如立即数、寄存器索引、功能码等。</p><p>为了能对流水线更好地实施控制，这里我们需要把译码后的数据和控制信号分开处理。首先来看译码控制模块的实现：</p><pre><code class=\"language-verilog\">module id_ex_ctrl(\n  input        clk,\n  input        reset,\n  input        in_ex_ctrl_itype,\n  input  [1:0] in_ex_ctrl_alu_ctrlop,\n  input  [1:0] in_ex_ctrl_result_sel,\n  input        in_ex_ctrl_alu_src,\n  input        in_ex_ctrl_pc_add,\n  input        in_ex_ctrl_branch,\n  input  [1:0] in_ex_ctrl_jump,\n  input        in_mem_ctrl_mem_read,\n  input        in_mem_ctrl_mem_write,\n  input  [1:0] in_mem_ctrl_mask_mode,\n  input        in_mem_ctrl_sext,\n  input        in_wb_ctrl_to_reg,\n  input        in_wb_ctrl_reg_write,\n  input        in_noflush,\n  input        flush,\n  input        valid,\n  output       out_ex_ctrl_itype,\n  output [1:0] out_ex_ctrl_alu_ctrlop,\n  output [1:0] out_ex_ctrl_result_sel,\n  output       out_ex_ctrl_alu_src,\n  output       out_ex_ctrl_pc_add,\n  output       out_ex_ctrl_branch,\n  output [1:0] out_ex_ctrl_jump,\n  output       out_mem_ctrl_mem_read,\n  output       out_mem_ctrl_mem_write,\n  output [1:0] out_mem_ctrl_mask_mode,\n  output       out_mem_ctrl_sext,\n  output       out_wb_ctrl_to_reg,\n  output       out_wb_ctrl_reg_write,\n  output       out_noflush\n);\n\n  reg  reg_ex_ctrl_itype; \n  reg [1:0] reg_ex_ctrl_alu_ctrlop; \n  reg [1:0] reg_ex_ctrl_result_sel; \n  reg  reg_ex_ctrl_alu_src; \n  reg  reg_ex_ctrl_pc_add; \n  reg  reg_ex_ctrl_branch; \n  reg [1:0] reg_ex_ctrl_jump; \n  reg  reg_mem_ctrl_mem_read; \n  reg  reg_mem_ctrl_mem_write; \n  reg [1:0] reg_mem_ctrl_mask_mode; \n  reg  reg_mem_ctrl_sext; \n  reg  reg_wb_ctrl_to_reg; \n  reg  reg_wb_ctrl_reg_write; \n  reg  reg_noflush; \n\n  ………………    //由于这里的代码较长，结构相似，这里省略了一部分\n  \n  always @(posedge clk or posedge reset) begin\n    if (reset) begin \n      reg_noflush &lt;= 1'h0; \n    end else if (flush) begin \n      reg_noflush &lt;= 1'h0; \n    end else if (valid) begin \n      reg_noflush &lt;= in_noflush; \n    end\n  end\nendmodule\n</code></pre><p>上面就是译码控制模块的Verilog设计代码。</p><p>上一节课学习取指模块的时候我们说过，并不是所有从存储器中读取出来的指令，都能够给到执行单元去执行的。比如，当指令发生冲突时，需要对流水线进行冲刷，这时就需要清除流水线中的指令。同样的，译码阶段的指令信号也需要清除。</p><p>译码控制模块就是为了实现这一功能，当指令清除信号flush有效时，把译码模块产生的jump、branch、mem_read、mem_write、reg_write……这些控制信号全部清“0”。否则，就把这些控制信号发送给流水线的下一级进行处理。</p><h2>译码数据通路模块设计</h2><p>和译码模块类似，译码数据通路模块会根据CPU相关控制模块产生的流水线冲刷控制信号，决定要不要把这些数据发送给后续模块。</p><p>其中，译码得到的数据信息包括立即数imm、源寄存器索引rs1和rs2、目标寄存器索引rd以及功能码funct3和funct7。具体的设计代码如下所示：</p><pre><code class=\"language-verilog\">module id_ex(\n  input         clk,\n  input         reset,\n  input  [4:0]  in_rd_addr,\n  input  [6:0]  in_funct7,\n  input  [2:0]  in_funct3,\n  input  [31:0] in_imm,\n  input  [31:0] in_rs2_data,\n  input  [31:0] in_rs1_data,\n  input  [31:0] in_pc,\n  input  [4:0]  in_rs1_addr,\n  input  [4:0]  in_rs2_addr,\n  input         flush,\n  input         valid,\n  output [4:0]  out_rd_addr,\n  output [6:0]  out_funct7,\n  output [2:0]  out_funct3,\n  output [31:0] out_imm,\n  output [31:0] out_rs2_data,\n  output [31:0] out_rs1_data,\n  output [31:0] out_pc,\n  output [4:0]  out_rs1_addr,\n  output [4:0]  out_rs2_addr\n);\n  reg [4:0] reg_rd_addr; \n  reg [6:0] reg_funct7; \n  reg [2:0] reg_funct3; \n  reg [31:0] reg_imm; \n  reg [31:0] reg_rs2_data; \n  reg [31:0] reg_rs1_data; \n  reg [31:0] reg_pc; \n  reg [4:0] reg_rs1_addr; \n  reg [4:0] reg_rs2_addr; \n\n  …………  //由于代码较长，结构相似，这里省略了一部分，完整代码你可以从Gitee上获取\n\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin \n      reg_rs2_addr &lt;= 5'h0; \n    end else if (flush) begin \n      reg_rs2_addr &lt;= 5'h0; \n    end else if (valid) begin \n      reg_rs2_addr &lt;= in_rs2_addr; \n    end\n  end\n\nendmodule\n</code></pre><p>我们以目标寄存器的索引地址reg_rd_addr信号为例，分析一下它是怎么流通的。当流水线冲刷信号flush有效时，目标寄存器的索引地址reg_rd_addr直接清“0”，否则当信号有效标志valid为“1”时，把目标寄存器的索引地址传递给流水线的下一级。</p><pre><code class=\"language-verilog\">  always @(posedge clk or posedge reset) begin\n    if (reset) begin \n      reg_rd_addr &lt;= 5'h0; \n    end else if (flush) begin \n      reg_rd_addr &lt;= 5'h0; \n    end else if (valid) begin \n      reg_rd_addr &lt;= in_rd_addr; \n    end\n  end\n</code></pre><p>类似地，当流水线冲刷信号flush有效时，把译码模块得到的源操作数1、源操作数2、立即数、目标寄存器地址……等等这些数据全部清“0”。否则，就把这些数据发送给流水线的下一级进行处理。</p><h2>重点回顾</h2><p>指令译码是CPU流水线中比较重要的一步，在译码阶段一定不能出错，否则流水线后续的执行就全都乱了。今天我们设计出了指令译码的相关模块，我带你回顾一下这节课的要点。</p><p>首先，我们针对RV32I指令集的6种指令格式，分析了它们各自包含了哪些指令信号。根据这些信息的位置不同，指令译码模块就可以从不同类型的指令格式中，把每条指令包含的信息提取出来。</p><p>之后，根据上面分析的译码思路，我们就可以设计译码模块了。经过观察，<strong>我们发现指令中的操作码、目标寄存器索引、源寄存器索引和功能码，在不同指令格式中的位置比较固定，所以这些信息可以直接从指令中截取得到。</strong></p><p>由于指令的操作码有特殊的指令标识作用，我们可以根据操作码产生指令控制信息，给到CPU流水线的下一级去执行。此外，还可以根据不同指令类型中立即数的分布位置特点，通过截取得到指令的立即数。</p><p>译码得到的指令信号分为两大类：一类是由指令的操作码经过译码后产生的<strong>指令执行控制信号</strong>，另一类是从指令源码中提取出来的<strong>数据信息</strong>。为了让译码后的信息，能更好地分发给流水线后续模块去执行，这里我们把译码后的数据和控制信号分开处理，分别设计了数据通路模块和译码控制模块。</p><p><img src=\"https://static001.geekbang.org/resource/image/c9/6c/c9a820a96faa70f18a77155be538506c.jpg?wh=1920x1324\" alt=\"图片\"></p><h2>思考题</h2><p>在6种指令格式中，S型、J型和B型指令里的立即数是不连续的，这是为什么？</p><p>欢迎你在留言区跟我交流互动，也推荐你把这节课分享给更多朋友，组团一起来跟我折腾CPU!</p>","comments":[{"had_liked":false,"id":354520,"user_name":"青玉白露","can_delete":false,"product_type":"c1","uid":2619436,"ip_address":"湖北","ucode":"96FE2D4D2B94A0","user_header":"https://static001.geekbang.org/account/avatar/00/27/f8/2c/92969c48.jpg","comment_is_top":true,"comment_ctime":1660484641,"is_pvip":false,"replies":[{"id":129186,"content":"正确 正确","user_name":"作者回复","user_name_real":"编辑","uid":1345199,"ctime":1661052844,"ip_address":"湖北","comment_id":354520,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100117801,"comment_content":"我觉得之所以将立即数设置为不连续，主要还是为了让rs1 rs2 rd 寄存器的位置保持固定，从而提高指令流水线的效率。至于不连续的立即数，只要在译码的时候拼接就可以了。","like_count":12,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584706,"discussion_content":"正确 正确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661052844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖北","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360788,"user_name":"阿狸狸狸狸，","can_delete":false,"product_type":"c1","uid":3069599,"ip_address":"湖北","ucode":"060655E936C29C","user_header":"https://static001.geekbang.org/account/avatar/00/2e/d6/9f/4894fbc4.jpg","comment_is_top":false,"comment_ctime":1666855794,"is_pvip":false,"replies":[{"id":131297,"content":"控制器","user_name":"作者回复","user_name_real":"编辑","uid":1345199,"ctime":1667029870,"ip_address":"湖北","comment_id":360788,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100117801,"comment_content":"我想请问一下，id_ex_ctrl这个译码控制模块的输入信号从哪里来？输出信号又送去哪里？","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592010,"discussion_content":"控制器","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667029870,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖北","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":354113,"user_name":"=","can_delete":false,"product_type":"c1","uid":2600127,"ip_address":"湖北","ucode":"104232A8292220","user_header":"https://static001.geekbang.org/account/avatar/00/27/ac/bf/f549183e.jpg","comment_is_top":false,"comment_ctime":1660101873,"is_pvip":false,"replies":[{"id":128907,"content":"为什么这么认为呢","user_name":"作者回复","user_name_real":"编辑","uid":1345199,"ctime":1660319398,"ip_address":"湖北","comment_id":354113,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100117801,"comment_content":"localparam DEC_JALR    = {1&#39;b0,  2&#39;b11, 1&#39;b0,    1&#39;b0,     1&#39;b1,     1&#39;b0,  2&#39;b10,     1&#39;b1,   1&#39;b0,  7&#39;b0100000, 2&#39;b00,     1&#39;b1};\n请问这里的7&#39;b0100000不应该是7&#39;b0000010吗","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583744,"discussion_content":"为什么这么认为呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660319398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖北","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2600018,"avatar":"https://static001.geekbang.org/account/avatar/00/27/ac/52/4eba136e.jpg","nickname":"Gosling","note":"","ucode":"65FEF06DB6CFDC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":584052,"discussion_content":"同问，JALR这个指令是属于J类型的，按代码上的注释来理解的话，7&#39;b0000010的倒数第二位就是对应的J类型呀，为什么这里是7&#39;b0100000？不太懂，是我理解的有误差嘛？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660582263,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":583744,"ip_address":"湖北","group_id":0},"score":584052,"extra":""}]}]},{"had_liked":false,"id":354101,"user_name":"苏流郁宓","can_delete":false,"product_type":"c1","uid":2729645,"ip_address":"湖北","ucode":"AD07BD9CE03047","user_header":"https://static001.geekbang.org/account/avatar/00/29/a6/ad/e65aec4c.jpg","comment_is_top":false,"comment_ctime":1660097603,"is_pvip":false,"replies":[{"id":128898,"content":"你理解正确","user_name":"作者回复","user_name_real":"编辑","uid":1345199,"ctime":1660318779,"ip_address":"湖北","comment_id":354101,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100117801,"comment_content":"B型是有条件跳转指令，J型是无条件跳转指令。俺的理解是既然是跳转指令，允许不连续的\nS型是和内存交流，俺的理解是可以为指令，也可以部分为数据，没有严格的要求导致可以允许不连续的！","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583735,"discussion_content":"你理解正确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660318779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖北","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":363157,"user_name":"小傅","can_delete":false,"product_type":"c1","uid":2616255,"ip_address":"湖北","ucode":"56B75C45A6C761","user_header":"https://static001.geekbang.org/account/avatar/00/27/eb/bf/8acfeaa6.jpg","comment_is_top":false,"comment_ctime":1669296305,"is_pvip":false,"replies":[{"id":132467,"content":"规范","user_name":"作者回复","user_name_real":"编辑","uid":1345199,"ctime":1670923172,"ip_address":"湖北","comment_id":363157,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100117801,"comment_content":"decode signals这段代码是怎么得出来的","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":596379,"discussion_content":"规范","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1670923172,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖北","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":354799,"user_name":"小博(微信/手机号1849登录)","can_delete":false,"product_type":"c1","uid":3114449,"ip_address":"湖北","ucode":"58FA146873C268","user_header":"https://static001.geekbang.org/account/avatar/00/2f/85/d1/bfe4d1b2.jpg","comment_is_top":false,"comment_ctime":1660794093,"is_pvip":false,"replies":[{"id":129463,"content":"立即数就是根据对应的指令格式拼接的","user_name":"作者回复","user_name_real":"编辑","uid":1345199,"ctime":1661734423,"ip_address":"湖北","comment_id":354799,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100117801,"comment_content":"还是有一个地方没看懂，那个立即数的拼接规则是什么呀？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585617,"discussion_content":"立即数就是根据对应的指令格式拼接的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661734424,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖北","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3068416,"avatar":"https://static001.geekbang.org/account/avatar/00/2e/d2/00/23784f62.jpg","nickname":"Geek_6a1eb9","note":"","ucode":"10AA5B12E0C8C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585370,"discussion_content":"看看这个视频：第四期3分21秒：https://www.bilibili.com/video/BV1cS4y1h73D/?spm_id_from=pageDriver&amp;vd_source=848d96f76bd7922d39f70343e2f35a57","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661500980,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"山东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3068416,"avatar":"https://static001.geekbang.org/account/avatar/00/2e/d2/00/23784f62.jpg","nickname":"Geek_6a1eb9","note":"","ucode":"10AA5B12E0C8C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585369,"discussion_content":"将指令中的立即数组按照正确的顺序排放，然后高位进行符号位扩展（符号位即指令的最高位31位，扩展即向前填充到立即数的31位最高位），低位填充 0 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661500937,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"山东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":354791,"user_name":"木易杨","can_delete":false,"product_type":"c1","uid":1353456,"ip_address":"","ucode":"3C6EFF05AFFACA","user_header":"https://static001.geekbang.org/account/avatar/00/14/a6/f0/50d0931d.jpg","comment_is_top":false,"comment_ctime":1660789441,"is_pvip":false,"replies":[{"id":129093,"content":"编辑回复：传的Gitee啊，链接：https:&#47;&#47;gitee.com&#47;lmos&#47;Geek-time-computer-foundation，觉得不错star支持下哦～","user_name":"编辑回复","user_name_real":"编辑","uid":1501385,"ctime":1660876833,"ip_address":"","comment_id":354791,"utype":2}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100117801,"comment_content":"老师，这个写的代码有上传到git上嘛？","like_count":0,"discussions":[{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584490,"discussion_content":"编辑回复：传的Gitee啊，链接：https://gitee.com/lmos/Geek-time-computer-foundation，觉得不错star支持下哦～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660876833,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":8}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":354648,"user_name":"LockedX","can_delete":false,"product_type":"c1","uid":1683139,"ip_address":"湖北","ucode":"19B82B910FC67F","user_header":"https://static001.geekbang.org/account/avatar/00/19/ae/c3/d930693b.jpg","comment_is_top":false,"comment_ctime":1660637312,"is_pvip":false,"replies":[{"id":129456,"content":"指令中含有立即数 数据 ","user_name":"作者回复","user_name_real":"编辑","uid":1345199,"ctime":1661678543,"ip_address":"湖北","comment_id":354648,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100117801,"comment_content":"wire [31:0] Iimm = {{21{instr[31]}}, instr[30:20]};\nwire [31:0] Simm = {{21{instr[31]}}, instr[30:25], instr[11:7]};\nwire [31:0] Bimm = {{20{instr[31]}}, instr[7], instr[30:25], instr[11:8], 1&#39;b0};\nwire [31:0] Uimm = {instr[31:12], 12&#39;b0};\nwire [31:0] Jimm = {{12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1&#39;b0};  \n\n老师，这个立即数的截取一直没看懂，{21{instr[31]}}的含义是什么呢","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585576,"discussion_content":"指令中含有立即数 数据 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661678543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖北","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3068416,"avatar":"https://static001.geekbang.org/account/avatar/00/2e/d2/00/23784f62.jpg","nickname":"Geek_6a1eb9","note":"","ucode":"10AA5B12E0C8C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585368,"discussion_content":"将指令中的立即数组按照正确的顺序排放，然后高位进行符号位扩展（符号位即指令的最高位31位，扩展即向前填充到立即数的31位最高位），低位填充 0 ","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1661500919,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"山东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1796908,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/6b/2c/b27eefc5.jpg","nickname":"Abcd","note":"","ucode":"274C7487FDDC21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584324,"discussion_content":"这就是符号位扩展","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660747365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":354501,"user_name":"你要有个信念","can_delete":false,"product_type":"c1","uid":3115320,"ip_address":"湖北","ucode":"CA9D3E9DC138EA","user_header":"https://static001.geekbang.org/account/avatar/00/2f/89/38/441bb99b.jpg","comment_is_top":false,"comment_ctime":1660468106,"is_pvip":false,"replies":[{"id":128943,"content":"32位 运算啊  ","user_name":"作者回复","user_name_real":"编辑","uid":1345199,"ctime":1660523135,"ip_address":"湖北","comment_id":354501,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100117801,"comment_content":"请问为什么要把立即数扩成32位的呢？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583943,"discussion_content":"32位 运算啊  ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660523135,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖北","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":3220050,"avatar":"https://static001.geekbang.org/account/avatar/00/31/22/52/49be0b7e.jpg","nickname":"一笑千古","note":"","ucode":"372EFBAB7A3FC1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":595840,"discussion_content":"老师，我还想问一下为什么选择通过复制立即数的最高位这一方式来扩充成32位的，就单纯补0可以吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1670399113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":583943,"ip_address":"上海","group_id":0},"score":595840,"extra":""}]}]},{"had_liked":false,"id":354396,"user_name":"伊宝峰","can_delete":false,"product_type":"c1","uid":1809580,"ip_address":"湖北","ucode":"6E0E99A9711605","user_header":"https://static001.geekbang.org/account/avatar/00/1b/9c/ac/4a488a4e.jpg","comment_is_top":false,"comment_ctime":1660358675,"is_pvip":false,"replies":[{"id":128948,"content":"对","user_name":"作者回复","user_name_real":"编辑","uid":1345199,"ctime":1660523325,"ip_address":"湖北","comment_id":354396,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100117801,"comment_content":"立即数不连续是为了让不同指令源和目的寄存器位置固定，方便寄存器地址的译码。","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583948,"discussion_content":"对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660523325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖北","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384483,"user_name":"A君","can_delete":false,"product_type":"c1","uid":1940105,"ip_address":"上海","ucode":"FE96F089C2312C","user_header":"https://static001.geekbang.org/account/avatar/00/1d/9a/89/babe8b52.jpg","comment_is_top":false,"comment_ctime":1701046997,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100117801,"comment_content":"提取立即数的那段代码为什么是所有类型的立即数的集合？为什么不像前面那样根据opcode走不通分支来赋值?","like_count":0}]}