{"id":386400,"title":"19 | 土地不能浪费：如何管理内存对象？","content":"<p>你好，我是LMOS。</p><p>在前面的课程中，我们建立了物理内存页面管理器，它既可以分配单个页面，也可以分配多个连续的页面，还能指定在特殊内存地址区域中分配页面。</p><p>但你发现没有，物理内存页面管理器一次分配至少是一个页面，而我们对内存分页是一个页面4KB，即4096字节。对于小于一个页面的内存分配请求，它无能为力。如果要实现小于一个页面的内存分配请求，又该怎么做呢？</p><p>这节课我们就一起来解决这个问题。课程配套代码，你可以从<a href=\"https://gitee.com/lmos/cosmos/tree/master/lesson19~21/Cosmos\">这里</a>获得。</p><h2>malloc给我们的启发</h2><p>首先，我想和你说说，为什么小于一个页面的内存我们也要格外珍惜？</p><p>如果你在大学学过C程序设计语言的话，相信你对C库中的malloc函数也不会陌生，它负责完成分配一块内存空间的功能。</p><p>下面的代码。我相信你也写过，或者写过类似的，不用多介绍你也可以明白。</p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt; \n#include &lt;stdlib.h&gt;   \nint main() {    \n    char *str;      \n    //内存分配 存放15个char字符类型   \n    str = (char *) malloc(15);\n    if (str == NULL) {\n        printf(&quot;mem alloc err\\n&quot;);\n        return -1;\n    }\n    //把hello world字符串复制到str开始的内存地址空间中\n    strcpy(str, &quot;hello world&quot;);\n    //打印hello world字符串和它的地址    \n    printf(&quot;String = %s,  Address = %u\\n&quot;, str, str);\n    //释放分配的内存\n    free(str);      \n    return(0); \n}\n</code></pre><p>这个代码流程很简单，就是分配一块15字节大小的内存空间，然后把字符串复制到分配的内存空间中，最后用字符串的形式打印了那个块内存，最后释放该内存空间。</p><p>但我们并不是要了解malloc、free函数的工作原理，而是要清楚，像这样分配几个字节内存空间的操作，这在内核中比比皆是。</p><h2>页还能细分吗</h2><p>是的，单从内存角度来看，页最小是以字节为单位的。但是从MMU角度看，内存是以页为单位的，所以我们的Cosmos的物理内存分配器也以页为单位。现在的问题是，内核中有大量远小于一个页面的内存分配请求，如果对此还是分配一个页面，就会浪费内存。</p><!-- [[[read_end]]] --><p>要想解决这个问题，<strong>就要细分“页”这个单位</strong>。虽然从MMU角度来看，页不能细分，但是从软件逻辑层面页可以细分，但是如何分，则十分讲究。</p><p>结合历史经验和硬件特性（Cache行大小）来看，我们可以把一个页面或者连续的多个页面，分成32字节、64字节、128字节、256字节、512字节、1024字节、2048字节、4096字节（一个页）。这些都是Cache行大小的倍数。我们给这些小块内存取个名字，叫<strong>内存对象</strong>。</p><p>我们可以这样设计：<strong>把一个或者多个内存页面分配出来，作为一个内存对象的容器，在这个容器中容纳相同的内存对象，即同等大小的内存块。</strong>你可以把这个容器，想像成一个内存对象数组。为了让你更好理解，我还给你画了张图解释。</p><p><img src=\"https://static001.geekbang.org/resource/image/a9/47/a9e3c059aceb3433de2116f9bee02d47.jpg?wh=5160x3099\" alt=\"\" title=\"内存对象视图\"></p><h2>如何表示一个内存对象</h2><p>前面只是进行了理论上的设计和构想，下面我们就通过代码来实现这些构想，真正把想法变成现实。</p><p>我们从内存对象开始入手。如何表示一个内存对象呢？当然是要设计一个表示内存对象的数据结构，代码如下所示：</p><pre><code>typedef struct s_FREOBJH\n{\n    list_h_t oh_list;     //链表\n    uint_t oh_stus;       //对象状态\n    void* oh_stat;        //对象的开始地址\n}freobjh_t;\n</code></pre><p>我们在后面的代码中就用freobjh_t结构表示一个对象，其中的链表是为了找到这个对象。是不是很简单？没错，表示一个内存对象就是如此简单。</p><h2>内存对象容器</h2><p>光有内存对象还不够，如何放置内存对象是很重要的。根据前面的构想，为了把多个同等大小的内存对象放在一个内存对象容器中，我们需要设计出表示内存对象容器的数据结构。内存容器要占用内存页面，需要内存对象计数信息、内存对象大小信息，还要能扩展容量。</p><p>把上述功能综合起来，代码如下所示。</p><pre><code>//管理内存对象容器占用的内存页面所对应的msadsc_t结构\ntypedef struct s_MSCLST\n{\n    uint_t ml_msanr;  //多少个msadsc_t\n    uint_t ml_ompnr;  //一个msadsc_t对应的连续的物理内存页面数\n    list_h_t ml_list; //挂载msadsc_t的链表\n}msclst_t;\n//管理内存对象容器占用的内存\ntypedef struct s_MSOMDC\n{\n    //msclst_t结构数组mc_lst[0]=1个连续页面的msadsc_t\n    //               mc_lst[1]=2个连续页面的msadsc_t\n    //               mc_lst[2]=4个连续页面的msadsc_t\n    //               mc_lst[3]=8个连续页面的msadsc_t\n    //               mc_lst[4]=16个连续页面的msadsc_t\n    msclst_t mc_lst[MSCLST_MAX];\n    uint_t mc_msanr;   //总共多个msadsc_t结构\n    list_h_t mc_list;\n    //内存对象容器第一个占用msadsc_t\n    list_h_t mc_kmobinlst;\n    //内存对象容器第一个占用msadsc_t对应的连续的物理内存页面数\n    uint_t mc_kmobinpnr;\n}msomdc_t;\n//管理内存对象容器扩展容量\ntypedef struct s_KMBEXT\n{\n    list_h_t mt_list;        //链表\n    adr_t mt_vstat;          //内存对象容器扩展容量开始地址\n    adr_t mt_vend;           //内存对象容器扩展容量结束地址\n    kmsob_t* mt_kmsb;        //指向内存对象容器结构\n    uint_t mt_mobjnr;        //内存对象容器扩展容量的内存中有多少对象\n}kmbext_t;\n//内存对象容器\ntypedef struct s_KMSOB\n{\n    list_h_t so_list;        //链表\n    spinlock_t so_lock;      //保护结构自身的自旋锁\n    uint_t so_stus;          //状态与标志\n    uint_t so_flgs;\n    adr_t so_vstat;          //内存对象容器的开始地址\n    adr_t so_vend;           //内存对象容器的结束地址\n    size_t so_objsz;         //内存对象大小\n    size_t so_objrelsz;      //内存对象实际大小\n    uint_t so_mobjnr;        //内存对象容器中总共的对象个数\n    uint_t so_fobjnr;        //内存对象容器中空闲的对象个数\n    list_h_t so_frelst;      //内存对象容器中空闲的对象链表头\n    list_h_t so_alclst;      //内存对象容器中分配的对象链表头\n    list_h_t so_mextlst;     //内存对象容器扩展kmbext_t结构链表头\n    uint_t so_mextnr;        //内存对象容器扩展kmbext_t结构个数\n    msomdc_t so_mc;          //内存对象容器占用内存页面管理结构\n    void* so_privp;          //本结构私有数据指针\n    void* so_extdp;          //本结构扩展数据指针\n}kmsob_t;\n</code></pre><p>这段代码中设计了四个数据结构：kmsob_t用于表示内存对象容器，kmbext_t用于表示内存对象容器的扩展内存，msomdc_t和msclst_t用于管理内存对象容器占用的物理内存页面。</p><p>你可能很难理解它们之间的关系，所以我为你准备了一幅图，如下所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/7y/bb/7yye7013ae2a878286fc6052c9318bbb.jpg?wh=4460x3085\" alt=\"\" title=\"内存对象容器关系\"></p><p>结合图示我们可以发现，在一组连续物理内存页面（用来存放内存对象）的开始地址那里，就存放着我们kmsob_t和kmbext_t的实例变量，它们占用了几十字节的空间。</p><h2>初始化</h2><p>因为kmsob_t、kmbext_t、freobjh_t结构的实例变量，它们是建立内存对象容器时创建并初始化的，这个过程是伴随着分配内存对象而进行的，所以内存对象管理器的初始化很简单。</p><p>但是有一点还是要初始化的，那就是<strong>管理kmsob_t结构的数据结构</strong>，它用于挂载不同大小的内存容器。现在我们就在cosmos/hal/x86/目录下建立一个kmsob.c文件，来实现这个数据结构并初始化，代码如下所示。</p><pre><code>#define KOBLST_MAX (64)\n//挂载kmsob_t结构\ntypedef struct s_KOBLST\n{\n    list_h_t ol_emplst; //挂载kmsob_t结构的链表\n    kmsob_t* ol_cahe;   //最近一次查找的kmsob_t结构\n    uint_t ol_emnr;     //挂载kmsob_t结构的数量\n    size_t ol_sz;       //kmsob_t结构中内存对象的大小\n}koblst_t;\n//管理kmsob_t结构的数据结构\ntypedef struct s_KMSOBMGRHED\n{\n    spinlock_t ks_lock;  //保护自身的自旋锁\n    list_h_t ks_tclst;   //链表\n    uint_t ks_tcnr;\n    uint_t ks_msobnr;    //总共多少个kmsob_t结构\n    kmsob_t* ks_msobche; //最近分配内存对象的kmsob_t结构\n    koblst_t ks_msoblst[KOBLST_MAX]; //koblst_t结构数组\n}kmsobmgrhed_t;\n//初始化koblst_t结构体\nvoid koblst_t_init(koblst_t *initp, size_t koblsz)\n{\n    list_init(&amp;initp-&gt;ol_emplst);\n    initp-&gt;ol_cahe = NULL;\n    initp-&gt;ol_emnr = 0;\n    initp-&gt;ol_sz = koblsz;\n    return;\n}\n//初始化kmsobmgrhed_t结构体\nvoid kmsobmgrhed_t_init(kmsobmgrhed_t *initp)\n{\n    size_t koblsz = 32;\n    knl_spinlock_init(&amp;initp-&gt;ks_lock);\n    list_init(&amp;initp-&gt;ks_tclst);\n    initp-&gt;ks_tcnr = 0;\n    initp-&gt;ks_msobnr = 0;\n    initp-&gt;ks_msobche = NULL;\n    for (uint_t i = 0; i &lt; KOBLST_MAX; i++)\n    {\n        koblst_t_init(&amp;initp-&gt;ks_msoblst[i], koblsz);\n        koblsz += 32;//这里并不是按照开始的图形分类的而是每次增加32字节，所以是32，64,96,128,160,192,224，256，.......\n    }\n    return;\n}\n//初始化kmsob\nvoid init_kmsob()\n{\n    kmsobmgrhed_t_init(&amp;memmgrob.mo_kmsobmgr);\n    return;\n}\n</code></pre><p>上面的代码注释已经很清楚了，就是init_kmsob函数调用kmsobmgrhed_t_init函数，在其中循环初始化koblst_t结构体数组，不多做解释。</p><p>但是有一点我们要搞清楚：<strong>kmsobmgrhed_t结构的实例变量是放在哪里的，它其实放在我们之前的memmgrob_t结构中了</strong>，代码如下所示。</p><pre><code>//cosmos/include/halinc/halglobal.c\nHAL_DEFGLOB_VARIABLE(memmgrob_t,memmgrob);\n\ntypedef struct s_MEMMGROB\n{\n    list_h_t mo_list;\n    spinlock_t mo_lock;\n    uint_t mo_stus;\n    uint_t mo_flgs;\n    //略去很多字段\n    //管理kmsob_t结构的数据结构\n    kmsobmgrhed_t mo_kmsobmgr;\n    void* mo_privp;\n    void* mo_extp;\n}memmgrob_t;\n//cosmos/hal/x86/memmgrinit.c\nvoid init_memmgr()\n{\n    //初始化内存页结构\n    init_msadsc();\n    //初始化内存区结构\n    init_memarea();\n    //处理内存占用\n    init_search_krloccupymm(&amp;kmachbsp);\n    //合并内存页到内存区中\n    init_memmgrob();\n    //初始化kmsob\n    init_kmsob();\n    return;\n}\n</code></pre><p>这并没有那么难，是不是？到这里，我们在内存管理初始化init_memmgr函数中调用了init_kmsob函数，对管理内存对象容器的结构进行了初始化，这样后面我们就能分配内存对象了。</p><h2>分配内存对象</h2><p>根据前面的初始化过程，我们只是初始化了kmsobmgrhed_t结构，却没初始化任何kmsob_t结构，而这个结构就是存放内存对象的容器，没有它是不能进行任何分配内存对象的操作的。</p><p>下面我们一起在分配内存对象的过程中探索，应该如何查找、建立kmsob_t结构，然后在kmsob_t结构中建立freobjh_t结构，最后在内存对象容器的容量不足时，一起来扩展容器的内存。</p><h3>分配内存对象的接口</h3><p>分配内存对象的流程，仍然要从分配接口开始。分配内存对象的接口很简单，只有一个内存对象大小的参数，然后返回内存对象的首地址。下面我们先在kmsob.c文件中写好这个函数，代码如下所示。</p><pre><code>//分配内存对象的核心函数\nvoid *kmsob_new_core(size_t msz)\n{\n    //获取kmsobmgrhed_t结构的地址\n    kmsobmgrhed_t *kmobmgrp = &amp;memmgrob.mo_kmsobmgr;\n    void *retptr = NULL;\n    koblst_t *koblp = NULL;\n    kmsob_t *kmsp = NULL;\n    cpuflg_t cpuflg;\n    //对kmsobmgrhed_t结构加锁\n    knl_spinlock_cli(&amp;kmobmgrp-&gt;ks_lock, &amp;cpuflg);\n    koblp = onmsz_retn_koblst(kmobmgrp, msz);\n    if (NULL == koblp)\n    {\n        retptr = NULL;\n        goto ret_step;\n    }\n    kmsp = onkoblst_retn_newkmsob(koblp, msz);\n    if (NULL == kmsp)\n    {\n        kmsp = _create_kmsob(kmobmgrp, koblp, koblp-&gt;ol_sz);\n        if (NULL == kmsp)\n        {\n            retptr = NULL;\n            goto ret_step;\n        }\n    }\n    retptr = kmsob_new_onkmsob(kmsp, msz);\n    if (NULL == retptr)\n    {\n        retptr = NULL;\n        goto ret_step;\n    }\n    //更新kmsobmgrhed_t结构的信息\n    kmsob_updata_cache(kmobmgrp, koblp, kmsp, KUC_NEWFLG);\nret_step:\n    //解锁kmsobmgrhed_t结构\n    knl_spinunlock_sti(&amp;kmobmgrp-&gt;ks_lock, &amp;cpuflg);\n    return retptr;\n}\n//内存对象分配接口\nvoid *kmsob_new(size_t msz)\n{\n    //对于小于1 或者 大于2048字节的大小不支持 直接返回NULL表示失败\n    if (1 &gt; msz || 2048 &lt; msz)\n    {\n        return NULL;\n    }\n    //调用核心函数\n    return kmsob_new_core(msz);\n}\n</code></pre><p>上面代码中，内存对象分配接口很简单，只是对分配内存对象的大小进行检查，然后调用分配内存对象的核心函数，在这个核心函数中，就是围绕我们之前定义的几个数据结构，去进行一系列操作了。</p><p>但是究竟做了哪些操作呢，别急，我们继续往下看。</p><h3>查找内存对象容器</h3><p>根据前面的设计，我们已经知道内存对象是放在内存对象容器中的，所以要分配内存对象，必须要先根据要分配的内存对象大小，找到内存对象容器。</p><p>同时，我们还知道，内存对象容器数据结构kmsob_t就挂载在kmsobmgrhed_t数据结构中的ks_msoblst数组中，所以我们要遍历ks_msoblst数组，我们来写一个onmsz_retn_koblst函数，它返回ks_msoblst数组元素的指针，表示先根据内存对象的大小找到挂载kmsob_t结构对应的koblst_t结构。</p><pre><code>//看看内存对象容器是不是合乎要求\nkmsob_t *scan_newkmsob_isok(kmsob_t *kmsp, size_t msz)\n{    \n    //只要内存对象大小小于等于内存对象容器的对象大小就行\n    if (msz &lt;= kmsp-&gt;so_objsz)\n    {\n        return kmsp;\n    }\n    return NULL;\n}\n\nkoblst_t *onmsz_retn_koblst(kmsobmgrhed_t *kmmgrhlokp, size_t msz)\n{\n    //遍历ks_msoblst数组\n    for (uint_t kli = 0; kli &lt; KOBLST_MAX; kli++)\n    {\n        //只要大小合适就返回       \n        if (kmmgrhlokp-&gt;ks_msoblst[kli].ol_sz &gt;= msz)\n        {\n            return &amp;kmmgrhlokp-&gt;ks_msoblst[kli];\n        }\n    }\n    return NULL;\n}\n\nkmsob_t *onkoblst_retn_newkmsob(koblst_t *koblp, size_t msz)\n{\n    kmsob_t *kmsp = NULL, *tkmsp = NULL;\n    list_h_t *tmplst = NULL;\n    //先看看上次分配所用到的koblst_t是不是正好是这次需要的\n    kmsp = scan_newkmsob_isok(koblp-&gt;ol_cahe, msz);\n    if (NULL != kmsp)\n    {\n        return kmsp;\n    }\n    //如果koblst_t中挂载的kmsob_t大于0\n    if (0 &lt; koblp-&gt;ol_emnr)\n    {\n        //开始遍历koblst_t中挂载的kmsob_t\n        list_for_each(tmplst, &amp;koblp-&gt;ol_emplst)\n        {\n            tkmsp = list_entry(tmplst, kmsob_t, so_list);\n            //检查当前kmsob_t是否合乎要求\n            kmsp = scan_newkmsob_isok(tkmsp, msz);\n            if (NULL != kmsp)\n            {\n                return kmsp;\n            }\n        }\n    }\n    return NULL;\n}\n</code></pre><p>上述代码非常好理解，就是通过onmsz_retn_koblst函数，它根据内存对象大小查找并返回ks_msoblst数组元素的指针，这个数组元素中就挂载着相应的内存对象容器，然后由onkoblst_retn_newkmsob函数查询其中的内存对象容器并返回。</p><h3>建立内存对象容器</h3><p>不知道你发现没有，有一种情况必然会发生，那就是第一次分配内存对象时调用onkoblst_retn_newkmsob函数，它肯定会返回一个NULL。因为第一次分配时肯定没有kmsob_t结构，所以我们在这个时候建立一个kmsob_t结构，即<strong>建立内存对象容器</strong>。</p><p>下面我们写一个_create_kmsob函数来创建kmsob_t结构，并执行一些初始化工作，代码如下所示。</p><pre><code>//初始化内存对象数据结构\nvoid freobjh_t_init(freobjh_t *initp, uint_t stus, void *stat)\n{\n    list_init(&amp;initp-&gt;oh_list);\n    initp-&gt;oh_stus = stus;\n    initp-&gt;oh_stat = stat;\n    return;\n}\n//初始化内存对象容器数据结构\nvoid kmsob_t_init(kmsob_t *initp)\n{\n    list_init(&amp;initp-&gt;so_list);\n    knl_spinlock_init(&amp;initp-&gt;so_lock);\n    initp-&gt;so_stus = 0;\n    initp-&gt;so_flgs = 0;\n    initp-&gt;so_vstat = NULL;\n    initp-&gt;so_vend = NULL;\n    initp-&gt;so_objsz = 0;\n    initp-&gt;so_objrelsz = 0;\n    initp-&gt;so_mobjnr = 0;\n    initp-&gt;so_fobjnr = 0;\n    list_init(&amp;initp-&gt;so_frelst);\n    list_init(&amp;initp-&gt;so_alclst);\n    list_init(&amp;initp-&gt;so_mextlst);\n    initp-&gt;so_mextnr = 0;\n    msomdc_t_init(&amp;initp-&gt;so_mc);\n    initp-&gt;so_privp = NULL;\n    initp-&gt;so_extdp = NULL;\n    return;\n}\n//把内存对象容器数据结构，挂载到对应的koblst_t结构中去\nbool_t kmsob_add_koblst(koblst_t *koblp, kmsob_t *kmsp)\n{\n    list_add(&amp;kmsp-&gt;so_list, &amp;koblp-&gt;ol_emplst);\n    koblp-&gt;ol_emnr++;\n    return TRUE;\n}\n//初始化内存对象容器\nkmsob_t *_create_init_kmsob(kmsob_t *kmsp, size_t objsz, adr_t cvadrs, adr_t cvadre, msadsc_t *msa, uint_t relpnr)\n{\n    //初始化kmsob结构体\n    kmsob_t_init(kmsp);\n    //设置内存对象容器的开始、结束地址，内存对象大小\n    kmsp-&gt;so_vstat = cvadrs;\n    kmsp-&gt;so_vend = cvadre;\n    kmsp-&gt;so_objsz = objsz;\n    //把物理内存页面对应的msadsc_t结构加入到kmsob_t中的so_mc.mc_kmobinlst链表上\n    list_add(&amp;msa-&gt;md_list, &amp;kmsp-&gt;so_mc.mc_kmobinlst);\n    kmsp-&gt;so_mc.mc_kmobinpnr = (uint_t)relpnr;\n    //设置内存对象的开始地址为kmsob_t结构之后，结束地址为内存对象容器的结束地址\n    freobjh_t *fohstat = (freobjh_t *)(kmsp + 1), *fohend = (freobjh_t *)cvadre;\n\n    uint_t ap = (uint_t)((uint_t)fohstat);\n    freobjh_t *tmpfoh = (freobjh_t *)((uint_t)ap);\n    for (; tmpfoh &lt; fohend;)\n    {//相当在kmsob_t结构体之后建立一个freobjh_t结构体数组\n        if ((ap + (uint_t)kmsp-&gt;so_objsz) &lt;= (uint_t)cvadre)\n        {//初始化每个freobjh_t结构体\n            freobjh_t_init(tmpfoh, 0, (void *)tmpfoh);\n            //把每个freobjh_t结构体加入到kmsob_t结构体中的so_frelst中\n           list_add(&amp;tmpfoh-&gt;oh_list, &amp;kmsp-&gt;so_frelst);\n            kmsp-&gt;so_mobjnr++;\n            kmsp-&gt;so_fobjnr++;\n        }\n        ap += (uint_t)kmsp-&gt;so_objsz;\n        tmpfoh = (freobjh_t *)((uint_t)ap);\n    }\n    return kmsp;\n}\n\n//建立一个内存对象容器\nkmsob_t *_create_kmsob(kmsobmgrhed_t *kmmgrlokp, koblst_t *koblp, size_t objsz)\n{\n    kmsob_t *kmsp = NULL;\n    msadsc_t *msa = NULL;\n    uint_t relpnr = 0;\n    uint_t pages = 1;\n    if (128 &lt; objsz)\n    {\n        pages = 2;\n    }\n    if (512 &lt; objsz)\n    {\n        pages = 4;\n    }\n    //为内存对象容器分配物理内存空间，这是我们之前实现的物理内存页面管理器\n    msa = mm_division_pages(&amp;memmgrob, pages, &amp;relpnr, MA_TYPE_KRNL, DMF_RELDIV);\n    if (NULL == msa)\n    {\n        return NULL;\n    }\n    u64_t phyadr = msa-&gt;md_phyadrs.paf_padrs &lt;&lt; PSHRSIZE;\n    u64_t phyade = phyadr + (relpnr &lt;&lt; PSHRSIZE) - 1;\n    //计算它们的虚拟地址\n    adr_t vadrs = phyadr_to_viradr((adr_t)phyadr);\n    adr_t vadre = phyadr_to_viradr((adr_t)phyade);\n    //初始化kmsob_t并建立内存对象\n    kmsp = _create_init_kmsob((kmsob_t *)vadrs, koblp-&gt;ol_sz, vadrs, vadre, msa, relpnr);\n    //把kmsob_t结构，挂载到对应的koblst_t结构中去\n    if (kmsob_add_koblst(koblp, kmsp) == FALSE)\n    {\n        system_error(&quot; _create_kmsob kmsob_add_koblst FALSE\\n&quot;);\n    }\n    //增加计数\n    kmmgrlokp-&gt;ks_msobnr++;\n    return kmsp;\n</code></pre><p>_create_kmsob函数就是根据分配内存对象大小，建立一个内存对象容器。</p><p>首先，这个函数会找物理内存页面管理器申请一块连续内存页面。然后，在其中的开始部分建立kmsob_t结构的实例变量，又在kmsob_t结构的后面建立freobjh_t结构数组，并把每个freobjh_t结构挂载到kmsob_t结构体中的so_frelst中。最后再把kmsob_t结构，挂载到kmsobmgrhed_t结构对应的koblst_t结构中去。</p><p>上面的注释已经很清楚了，我相信你看得懂。</p><h3>扩容内存对象容器</h3><p>如果我们不断重复分配同一大小的内存对象，那么那个内存对象容器中的内存对象，迟早要分配完的。一旦内存对象分配完，内存对象容器就没有空闲的内存空间产生内存对象了。这时，我们就要为内存对象容器扩展内存空间了。</p><p>下面我们来写代码实现，如下所示。</p><pre><code>//初始化kmbext_t结构\nvoid kmbext_t_init(kmbext_t *initp, adr_t vstat, adr_t vend, kmsob_t *kmsp)\n{\n    list_init(&amp;initp-&gt;mt_list);\n    initp-&gt;mt_vstat = vstat;\n    initp-&gt;mt_vend = vend;\n    initp-&gt;mt_kmsb = kmsp;\n    initp-&gt;mt_mobjnr = 0;\n    return;\n}\n//扩展内存页面\nbool_t kmsob_extn_pages(kmsob_t *kmsp)\n{\n    msadsc_t *msa = NULL;\n    uint_t relpnr = 0;\n    uint_t pages = 1;\n    if (128 &lt; kmsp-&gt;so_objsz)\n    {\n        pages = 2;\n    }\n    if (512 &lt; kmsp-&gt;so_objsz)\n    {\n        pages = 4;\n    }\n    //找物理内存页面管理器分配2或者4个连续的页面\n    msa = mm_division_pages(&amp;memmgrob, pages, &amp;relpnr, MA_TYPE_KRNL, DMF_RELDIV);\n    if (NULL == msa)\n    {\n        return FALSE;\n    }\n    u64_t phyadr = msa-&gt;md_phyadrs.paf_padrs &lt;&lt; PSHRSIZE;\n    u64_t phyade = phyadr + (relpnr &lt;&lt; PSHRSIZE) - 1;\n    adr_t vadrs = phyadr_to_viradr((adr_t)phyadr);\n    adr_t vadre = phyadr_to_viradr((adr_t)phyade);\n    //求出物理内存页面数对应在kmsob_t的so_mc.mc_lst数组中下标\n    sint_t mscidx = retn_mscidx(relpnr);\n    //把物理内存页面对应的msadsc_t结构加入到kmsob_t的so_mc.mc_lst数组中\n    list_add(&amp;msa-&gt;md_list, &amp;kmsp-&gt;so_mc.mc_lst[mscidx].ml_list);\n    kmsp-&gt;so_mc.mc_lst[mscidx].ml_msanr++;\n\n    kmbext_t *bextp = (kmbext_t *)vadrs;\n    //初始化kmbext_t数据结构\n    kmbext_t_init(bextp, vadrs, vadre, kmsp);\n//设置内存对象的开始地址为kmbext_t结构之后，结束地址为扩展内存页面的结束地址\n    freobjh_t *fohstat = (freobjh_t *)(bextp + 1), *fohend = (freobjh_t *)vadre;\n\n    uint_t ap = (uint_t)((uint_t)fohstat);\n    freobjh_t *tmpfoh = (freobjh_t *)((uint_t)ap);\n    for (; tmpfoh &lt; fohend;)\n    {\n        if ((ap + (uint_t)kmsp-&gt;so_objsz) &lt;= (uint_t)vadre)\n        {//在扩展的内存空间中建立内存对象\n            freobjh_t_init(tmpfoh, 0, (void *)tmpfoh);\n            list_add(&amp;tmpfoh-&gt;oh_list, &amp;kmsp-&gt;so_frelst);\n            kmsp-&gt;so_mobjnr++;\n            kmsp-&gt;so_fobjnr++;\n            bextp-&gt;mt_mobjnr++;\n        }\n        ap += (uint_t)kmsp-&gt;so_objsz;\n        tmpfoh = (freobjh_t *)((uint_t)ap);\n    }\n    list_add(&amp;bextp-&gt;mt_list, &amp;kmsp-&gt;so_mextlst);\n    kmsp-&gt;so_mextnr++;\n    return TRUE;\n}\n</code></pre><p>有了前面建立内存对象容器的经验，加上这里的注释，我们理解上述代码并不难：不过是分配了另一块连续的内存空间，作为空闲的内存对象，并且把这块内存空间加内存对象容器中统一管理。</p><h3>分配内存对象</h3><p>有了内存对象容器，就可以分配内存对象了。由于我们前面精心设计了内存对象容器、内存对象等数据结构，这使得我们的内存对象分配代码时极其简单，而且性能极高。</p><p>下面我们来实现它吧！代码如下所示。</p><pre><code>//判断内存对象容器中有没有内存对象\nuint_t scan_kmob_objnr(kmsob_t *kmsp)\n{\n    if (0 &lt; kmsp-&gt;so_fobjnr)\n    {\n        return kmsp-&gt;so_fobjnr;\n    }\n    return 0;\n}\n//实际分配内存对象\nvoid *kmsob_new_opkmsob(kmsob_t *kmsp, size_t msz)\n{\n    //获取kmsob_t中的so_frelst链表头的第一个空闲内存对象\n    freobjh_t *fobh = list_entry(kmsp-&gt;so_frelst.next, freobjh_t, oh_list);\n    //从链表中脱链\n    list_del(&amp;fobh-&gt;oh_list);\n    //kmsob_t中的空闲对象计数减一\n    kmsp-&gt;so_fobjnr--;\n    //返回内存对象首地址\n    return (void *)(fobh);\n}\n\nvoid *kmsob_new_onkmsob(kmsob_t *kmsp, size_t msz)\n{\n    void *retptr = NULL;\n    cpuflg_t cpuflg;\n    knl_spinlock_cli(&amp;kmsp-&gt;so_lock, &amp;cpuflg);\n    //如果内存对象容器中没有空闲的内存对象了就需要扩展内存对象容器的内存了\n    if (scan_kmsob_objnr(kmsp) &lt; 1)\n    {//扩展内存对象容器的内存\n        if (kmsob_extn_pages(kmsp) == FALSE)\n        {\n            retptr = NULL;\n            goto ret_step;\n        }\n    }\n    //实际分配内存对象\n    retptr = kmsob_new_opkmsob(kmsp, msz);\nret_step:\n    knl_spinunlock_sti(&amp;kmsp-&gt;so_lock, &amp;cpuflg);\n    return retptr;\n}\n</code></pre><p>分配内存对象的核心操作就是，<strong>kmsob_new_opkmsob函数从空闲内存对象链表头中取出第一个内存对象，返回它的首地址</strong>。这个算法非常高效，无论内存对象容器中的内存对象有多少，kmsob_new_opkmsob函数的操作始终是固定的，而如此高效的算法得益于我们先进的数据结构设计。</p><p>好了，到这里内存对象的分配就已经完成了，下面我们去实现内存对象的释放。</p><h2>释放内存对象</h2><p>释放内存对象，就是要把内存对象还给它所归属的内存对象容器。其逻辑就是根据释放内存对象的地址和大小，找到对应的内存对象容器，然后把该内存对象加入到对应内存对象容器的空闲链表上，最后看一看要不要释放内存对象容器占用的物理内存页面。</p><h3>释放内存对象的接口</h3><p>这里我们依然要从释放内存对象的接口开始实现，下面我们在kmsob.c文中写下这个函数，代码如下所示。</p><pre><code>bool_t kmsob_delete_core(void *fadrs, size_t fsz)\n{\n    kmsobmgrhed_t *kmobmgrp = &amp;memmgrob.mo_kmsobmgr;\n    bool_t rets = FALSE;\n    koblst_t *koblp = NULL;\n    kmsob_t *kmsp = NULL;\n    cpuflg_t cpuflg;\n    knl_spinlock_cli(&amp;kmobmgrp-&gt;ks_lock, &amp;cpuflg);\n    //根据释放内存对象的大小在kmsobmgrhed_t中查找并返回koblst_t，在其中挂载着对应的kmsob_t，这个在前面已经写好了\n    koblp = onmsz_retn_koblst(kmobmgrp, fsz);\n    if (NULL == koblp)\n    {\n        rets = FALSE;\n        goto ret_step;\n    }\n    kmsp = onkoblst_retn_delkmsob(koblp, fadrs, fsz);\n    if (NULL == kmsp)\n    {\n        rets = FALSE;\n        goto ret_step;\n    }\n    rets = kmsob_delete_onkmsob(kmsp, fadrs, fsz);\n    if (FALSE == rets)\n    {\n        rets = FALSE;\n        goto ret_step;\n    }\n    if (_destroy_kmsob(kmobmgrp, koblp, kmsp) == FALSE)\n    {\n        rets = FALSE;\n        goto ret_step;\n    }\n    rets = TRUE;\nret_step:\n    knl_spinunlock_sti(&amp;kmobmgrp-&gt;ks_lock, &amp;cpuflg);\n    return rets;\n}\n//释放内存对象接口\nbool_t kmsob_delete(void *fadrs, size_t fsz)\n{\n    //对参数进行检查，但是多了对内存对象地址的检查 \n    if (NULL == fadrs || 1 &gt; fsz || 2048 &lt; fsz)\n    {\n        return FALSE;\n    }\n    //调用释放内存对象的核心函数\n    return kmsob_delete_core(fadrs, fsz);\n}\n</code></pre><p>上述代码中，等到kmsob_delete函数检查参数通过之后，就调用释放内存对象的核心函数kmsob_delete_core，在这个函数中，一开始根据释放内存对象大小，找到挂载其kmsob_t结构的koblst_t结构，接着又做了一系列的操作，这些操作正是我们接下来要实现的。</p><h3>查找内存对象容器</h3><p>释放内存对象，首先要找到这个将要释放的内存对象所属的内存对象容器。释放时的查找和分配时的查找不一样，因为要检查<strong>释放的内存对象是不是属于该内存对象容器。</strong></p><p>下面我们一起来实现这个函数，代码如下所示。</p><pre><code>//检查释放的内存对象是不是在kmsob_t结构中\nkmsob_t *scan_delkmsob_isok(kmsob_t *kmsp, void *fadrs, size_t fsz)\n{//检查释放内存对象的地址是否落在kmsob_t结构的地址区间\n    if ((adr_t)fadrs &gt;= (kmsp-&gt;so_vstat + sizeof(kmsob_t)) &amp;&amp; ((adr_t)fadrs + (adr_t)fsz) &lt;= kmsp-&gt;so_vend)\n    {    //检查释放内存对象的大小是否小于等于kmsob_t内存对象容器的对象大小 \n        if (fsz &lt;= kmsp-&gt;so_objsz)\n        {\n            return kmsp;\n        }\n    }\n    if (1 &gt; kmsp-&gt;so_mextnr)\n    {//如果kmsob_t结构没有扩展空间，直接返回\n        return NULL;\n    }\n    kmbext_t *bexp = NULL;\n    list_h_t *tmplst = NULL;\n    //遍历kmsob_t结构中的每个扩展空间\n    list_for_each(tmplst, &amp;kmsp-&gt;so_mextlst)\n    {\n        bexp = list_entry(tmplst, kmbext_t, mt_list);\n        //检查释放内存对象的地址是否落在扩展空间的地址区间\n        if ((adr_t)fadrs &gt;= (bexp-&gt;mt_vstat + sizeof(kmbext_t)) &amp;&amp; ((adr_t)fadrs + (adr_t)fsz) &lt;= bexp-&gt;mt_vend)\n        {//同样的要检查大小\n            if (fsz &lt;= kmsp-&gt;so_objsz)\n            {\n                return kmsp;\n            }\n        }\n    }\n    return NULL;\n}\n//查找释放内存对象所属的kmsob_t结构\nkmsob_t *onkoblst_retn_delkmsob(koblst_t *koblp, void *fadrs, size_t fsz)\n{\n    v *kmsp = NULL, *tkmsp = NULL;\n    list_h_t *tmplst = NULL;\n    //看看上次刚刚操作的kmsob_t结构\n    kmsp = scan_delkmsob_isok(koblp-&gt;ol_cahe, fadrs, fsz);\n    if (NULL != kmsp)\n    {\n        return kmsp;\n    }\n    if (0 &lt; koblp-&gt;ol_emnr)\n    {    //遍历挂载koblp-&gt;ol_emplst链表上的每个kmsob_t结构\n        list_for_each(tmplst, &amp;koblp-&gt;ol_emplst)\n        {\n            tkmsp = list_entry(tmplst, kmsob_t, so_list);\n            //检查释放的内存对象是不是属于这个kmsob_t结构\n            kmsp = scan_delkmsob_isok(tkmsp, fadrs, fsz);\n            if (NULL != kmsp)\n            {\n                return kmsp;\n            }\n        }\n    }\n    return NULL;\n}\n</code></pre><p>上面的代码注释已经很明白了，搜索对应koblst_t结构中的每个kmsob_t结构体，随后进行检查，检查了kmsob_t结构的自身内存区域和扩展内存区域。即比较释放内存对象的地址是不是落在它们的内存区间中，其大小是否合乎要求。</p><h3>释放内存对象</h3><p>如果不出意外，会找到释放内存对象的kmsob_t结构，这样就可以释放内存对象了，就是把这块内存空间还给内存对象容器，这个过程的具体代码实现如下所示。</p><pre><code>bool_t kmsob_del_opkmsob(kmsob_t *kmsp, void *fadrs, size_t fsz)\n{\n    if ((kmsp-&gt;so_fobjnr + 1) &gt; kmsp-&gt;so_mobjnr)\n    {\n        return FALSE;\n    }\n    //让freobjh_t结构重新指向要释放的内存空间\n    freobjh_t *obhp = (freobjh_t *)fadrs;\n    //重新初始化块内存空间\n    freobjh_t_init(obhp, 0, obhp);\n    //加入kmsob_t结构的空闲链表\n    list_add(&amp;obhp-&gt;oh_list, &amp;kmsp-&gt;so_frelst);\n    //kmsob_t结构的空闲对象计数加一\n    kmsp-&gt;so_fobjnr++;\n    return TRUE;\n}\n//释放内存对象\nbool_t kmsob_delete_onkmsob(kmsob_t *kmsp, void *fadrs, size_t fsz)\n{\n    bool_t rets = FALSE;\n    cpuflg_t cpuflg;\n    //对kmsob_t结构加锁\n    knl_spinlock_cli(&amp;kmsp-&gt;so_lock, &amp;cpuflg);\n    //实际完成内存对象释放\n    if (kmsob_del_opkmsob(kmsp, fadrs, fsz) == FALSE)\n    {\n        rets = FALSE;\n        goto ret_step;\n    }\n    rets = TRUE;\nret_step:\n    //对kmsob_t结构解锁\n    knl_spinunlock_sti(&amp;kmsp-&gt;so_lock, &amp;cpuflg);\n    return rets;\n}\n</code></pre><p>结合上述代码和注释，我们现在明白了kmsob_delete_onkmsob函数调用kmsob_del_opkmsob函数。其核心机制就是<strong>把要释放内存对象的空间，重新初始化，变成一个freobjh_t结构的实例变量，最后把这个freobjh_t结构加入到kmsob_t结构中空闲链表中</strong>，这就实现了内存对象的释放。</p><h3>销毁内存对象容器</h3><p>如果我们释放了所有的内存对象，就会出现空的内存对象容器。如果下一次请求同样大小的内存对象，那么这个空的内存对象容器还能继续复用，提高性能。</p><p>但是你有没有想到，频繁请求的是不同大小的内存对象，那么空的内存对象容器会越来越多，这会占用大量内存，所以我们必须要把空的内存对象容器销毁。</p><p>下面我们写代码实现销毁内存对象容器。</p><pre><code>uint_t scan_freekmsob_isok(kmsob_t *kmsp)\n{\n    //当内存对象容器的总对象个数等于空闲对象个数时，说明这内存对象容器空闲\n    if (kmsp-&gt;so_mobjnr == kmsp-&gt;so_fobjnr)\n    {\n        return 2;\n    }\n    return 1;\n}\n\nbool_t _destroy_kmsob_core(kmsobmgrhed_t *kmobmgrp, koblst_t *koblp, kmsob_t *kmsp)\n{\n    list_h_t *tmplst = NULL;\n    msadsc_t *msa = NULL;\n    msclst_t *mscp = kmsp-&gt;so_mc.mc_lst;\n    list_del(&amp;kmsp-&gt;so_list);\n    koblp-&gt;ol_emnr--;\n    kmobmgrp-&gt;ks_msobnr--;\n    //释放内存对象容器扩展空间的物理内存页面\n    //遍历kmsob_t结构中的so_mc.mc_lst数组\n    for (uint_t j = 0; j &lt; MSCLST_MAX; j++)\n    {\n        if (0 &lt; mscp[j].ml_msanr)\n        {//遍历每个so_mc.mc_lst数组中的msadsc_t结构\n            list_for_each_head_dell(tmplst, &amp;mscp[j].ml_list)\n            {\n                msa = list_entry(tmplst, msadsc_t, md_list);\n                list_del(&amp;msa-&gt;md_list);\n                //msadsc_t脱链\n                //释放msadsc_t对应的物理内存页面\n                if (mm_merge_pages(&amp;memmgrob, msa, (uint_t)mscp[j].ml_ompnr) == FALSE)\n                {\n                    system_error(&quot;_destroy_kmsob_core mm_merge_pages FALSE2\\n&quot;);\n                }\n            }\n        }\n    }\n    //释放内存对象容器本身占用的物理内存页面\n    //遍历每个so_mc.mc_kmobinlst中的msadsc_t结构。它只会遍历一次\n    list_for_each_head_dell(tmplst, &amp;kmsp-&gt;so_mc.mc_kmobinlst)\n    {\n        msa = list_entry(tmplst, msadsc_t, md_list);\n        list_del(&amp;msa-&gt;md_list);\n        //msadsc_t脱链\n        //释放msadsc_t对应的物理内存页面\n        if (mm_merge_pages(&amp;memmgrob, msa, (uint_t)kmsp-&gt;so_mc.mc_kmobinpnr) == FALSE)\n        {\n            system_error(&quot;_destroy_kmsob_core mm_merge_pages FALSE2\\n&quot;);\n        }\n    }\n    return TRUE;\n}\n//\n```销毁内存对象容器\nbool_t _destroy_kmsob(kmsobmgrhed_t *kmobmgrp, koblst_t *koblp, kmsob_t *kmsp)\n{\n    //看看能不能销毁\n    uint_t screts = scan_freekmsob_isok(kmsp);\n    if (2 == screts)\n    {//调用销毁内存对象容器的核心函数\n        return _destroy_kmsob_core(kmobmgrp, koblp, kmsp);\n    }\n    return FALSE;\n}\n</code></pre><p>上述代码中，首先会检查一下内存对象容器是不是空闲的，如果空闲，就调用<strong>销毁内存对象容器的核心函数_destroy_kmsob_core</strong>。在_destroy_kmsob_core函数中，首先要释放内存对象容器的扩展空间所占用的物理内存页面，最后才可以释放内存对象容器自身占用物理内存页面。</p><p>请注意。<strong>这个顺序不能前后颠倒</strong>，这是因为扩展空间的物理内存页面对应的msadsc_t结构，它就挂载在kmsob_t结构的so_mc.mc_lst数组中。</p><p>好了，到这里我们内存对象释放的流程就完成了，这意味着我们整个内存对象管理也告一段落了。</p><h2>重点回顾</h2><p>今天我们从malloc函数入手，思考内核要怎样分配大量小块内存。我们把物理内存页面进一步细分成内存对象，为了表示和管理内存对象，又设计了内存对象、内存对象容器等一系列数据结构，随后写代码把它们初始化，最后我们依赖这些数据结构实现了内存对象管理算法。</p><p>下面我们来回顾一下这节课的重点。</p><p>1.我们发现，在应用程序中可以使用malloc函数动态分配一些小块内存，其实这样的场景在内核中也是比比皆是。比如，内核经常要动态创建数据结构的实例变量，就需要分配小块的内存空间。</p><p>2.为了实现内存对象的表示、分配和释放功能，我们定义了内存对象和内存对象容器的数据结构freobjh_t、kmsob_t，并为了管理kmsob_t结构又定义了kmsobmgrhed_t结构。</p><p>3.我们写好了初始化kmsobmgrhed_t结构的函数，并在init_kmsob中调用了它，进而又被init_memmgr函数调用，由于kmsobmgrhed_t结构是为了管理kmsob_t结构的所以在一开始就要被初始化。</p><p>4.我们基于这些数据结构实现了内存对象的分配和释放。</p><h2>思考题</h2><p>为什么我们在分配内存对象大小时要按照Cache行大小的倍数分配呢？</p><p>欢迎你在留言区分享你的思考或疑问。如果这节课对你有帮助，也欢迎你分享给自己的同事、朋友，跟他一起交流讨论。</p><p>好，我是LMOS，我们下节课见！</p>","neighbors":{"left":{"article_title":"18 | 划分土地（下）：如何实现内存页的分配与释放？","id":385628},"right":{"article_title":"20 | 土地需求扩大与保障：如何表示虚拟内存？","id":387258}},"comments":[{"had_liked":false,"id":298669,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":true,"comment_ctime":1624256108,"is_pvip":false,"replies":[{"id":"108444","content":"666666","user_name":"作者回复","comment_id":298669,"uid":"1345199","ip_address":"","utype":1,"ctime":1624421864,"user_name_real":"LMOS"}],"discussion_count":2,"race_medal":0,"score":"9.2233721759180001e+18","product_id":100078401,"comment_content":"怕大家误会我的意思，我再说明一下。我上面的评论其实是在呼吁大家不要拘泥于代码，也不要深陷细节，一叶而障目是学习路上最容易犯的错误。<br>我以自身为例来说，初学数据结构时，链表是最简单的一种数据结构，老师一讲就懂，书一看就会，可是自己去写，尤其是链表的各种操作都是细节满满，很考验个人代码功底和思维完善性，至今我都记得从我懂链表起，到真正写出一个能work的链表都花了一周时间，最开始写是CV，后面是背，多次画图和理解后我才能闭卷完完整整的写出链表。<br>虽然这过去了好几年，我也从初学者到现在走了很多路。对于这几节专栏而言，同样如此，无论是上一节的伙伴算法还是这一节的slab，都是linux系统走过了几十年迭代，摸爬滚打过滤下的精华。这样的算法都有一个普遍性，那就是思路和方式听起来都简单，可是自己去实现却又困难重重，所以专栏里面出现了大量的代码，大家都不适应，扣代码细节，反而忘记了buddy和slab要解决的问题，要干什么，为什么这样设计，这才是第一次读专栏的重点。<br>代码我也没全读懂，代码我也看着头疼，所以我才自勉写下上面的评论，希望大家能跳出来，宏观的看待问题，因为即使是linux本人都未必能扣出细节。大家加油～","like_count":33,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522205,"discussion_content":"666666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624421864,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1335495,"avatar":"https://static001.geekbang.org/account/avatar/00/14/60/c7/fe7080ec.jpg","nickname":"冰河","note":"","ucode":"85BB6E539ABA8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388279,"discussion_content":"同意pedro的观点，至少第一次学这些章节的时候陷入细节很容易打击积极性。如果真的从头写这些代码，即使作者讲的再明白，真实现起来也不是一会儿功夫就能实现的。能看懂都已经非常厉害。\n我觉得我学习这门课程是抱着这样的心态进行的：\n1. 理解为什么要这么设计，这么设计要解决什么问题（当前阶段）\n2. 接着来看别人是怎么实现的\n3. 尝试改进部分代码以验证自己的理解","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1628677768,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":298726,"user_name":"neohope","can_delete":false,"product_type":"c1","uid":1043475,"ip_address":"","ucode":"C0268F6E7E2B6E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","comment_is_top":true,"comment_ctime":1624278814,"is_pvip":false,"replies":[{"id":"108443","content":"大佬 66666<br><br>最后，想问一下，koblst_t在什么情况下，会挂载多个kmsob_t呢？感觉内存对象不够用，就去补充kmbext_t了吧？<br>-----------------------------------------------------<br>目前不会，因为还没有 区分 kmsob_t的类型","user_name":"作者回复","comment_id":298726,"uid":"1345199","ip_address":"","utype":1,"ctime":1624421828,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"9.223372098608599e+18","product_id":100078401,"comment_content":"一、整理一下内存结构<br>1、memmgrob_t中有kmsobmgrhed_t<br>2、kmsobmgrhed_t中有一个koblst_t数组【KOBLST_MAX个】，序号为n的koblst_t，存储全部实际长度为长度为32*（n+1）内存对象<br>3、每个koblst_t，都包括一个kmsob_t链表<br>4、kmsob_t结构如下：<br>结构体描述部分【<br>双向链表<br>扩展结构链表【kmbext_t】<br>空闲对象链表【freobjh_t】<br>已分配对象链表【freobjh_t】<br>占用内存页面管理结构【msomdc_t】<br>kmsob_t结构体页面链表【so_mc.mc_kmobinlst】<br>全部kmbext_t结构体页面链表【so_mc.mc_lst】<br>结构体起止地址<br>......<br>】<br>除结构体描述部分，都按相同大小划分为了内存对象【freobjh_t】<br><br>5、扩展管理kmbext_t，用于扩容<br>结构体描述部分{<br>双向链表<br>结构体起止地址<br>......<br>}<br>除结构体描述部分，都按相同大小划分为了内存对象【freobjh_t】<br><br>6、链表处理部分做的真漂亮！<br><br>二、分配内存<br>1、从memmgrob_t获取kmsobmgrhed_t，也就找到了koblst_t数组<br>2、根据申请内存对象大小，找到对应的koblst_t【第一个内存对象比需求大的koblst_t】<br>3、如果koblst_t中没有找到kmsob_t，则要初始化<br>A、按页申请内存【1、2或4页】<br>B、进行kmsob_t初始化工作，首先初始化描述部分<br>C、将之后的空间，按固定大小全部初始化为freobjh_t结构<br>D、把全部freobjh_t挂载到koblst_t的空闲列表中<br>E、然后将kmsob_t挂载到koblst_t结构中去<br><br>4、在kmsob_t中分配内存对象<br>4.1、首先判断kmsob_t是否有空闲对象可以分配<br>4.2、如果没有空闲对象可以分配，则尝试扩容，创建新的kmbext_t：：<br>A、申请内存【1、2或4页】<br>B、并进行初始化工作kmbext_t，首先初始化描述部分<br>C、将之后的空间，按固定大小全部初始化为freobjh_t结构<br>D、把内存页面记录到kmsob_t的页面列表中<br>E、把freobjh_t挂载到koblst_t的空闲列表中<br>F、把kmbext_t挂载到kmsob_t的扩展结构链表中<br>4.3、最后返回一个空闲内存对象，并从空闲列表中移除<br><br>5、更新kmsobmgrhed_t结构的信息<br>6、代码中还有各种加速，加锁解锁、校验代码，可以看下<br><br>三、释放内存<br>1、从memmgrob_t获取kmsobmgrhed_t，也就找到了koblst_t数组<br>2、根据申请内存对象大小，找到对应的koblst_t【第一个内存对象比需求大的koblst_t】<br>3、查找内存对象所属的kmsob_t结构<br>对于koblst_t中的每一个kmsob_t结构：<br>A、先检查内存对象的地址是否落在kmsob_t结构的地址区间<br>B、然后依次检测内存对象的地址是否落在kmsob_t的各个kmbext_t扩展结构的地址区间<br><br>4、释放内存对象，也就是将内存对象添加到空闲列表中<br><br>5、尝试销毁内存对象所在 kmsob_t结构<br>4.1、首先判断该kmsob_t全部内存对象都已释放<br>4.2、如果全部内存对象都已释放，则释放kmsob_t<br>A、将kmsob_t脱链<br>B、更新kmsobmgrhed_t结构的信息<br>C、遍历释放kmsob_t中全部扩展结构占用的内存页面【先脱链，再释放】<br>D、释放kmsob_t自身占用的全部页面【先脱链，再释放】<br><br>6、代码中还有各种加速，加锁解锁、校验代码，可以看下<br><br>最后，想问一下，koblst_t在什么情况下，会挂载多个kmsob_t呢？感觉内存对象不够用，就去补充kmbext_t了吧？","like_count":14,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522221,"discussion_content":"大佬 66666\n\n最后，想问一下，koblst_t在什么情况下，会挂载多个kmsob_t呢？感觉内存对象不够用，就去补充kmbext_t了吧？\n-----------------------------------------------------\n目前不会，因为还没有 区分 kmsob_t的类型","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624421828,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311088,"user_name":"wenkin","can_delete":false,"product_type":"c1","uid":2226384,"ip_address":"","ucode":"0F9E623B1C4A75","user_header":"https://static001.geekbang.org/account/avatar/00/21/f8/d0/092f04df.jpg","comment_is_top":true,"comment_ctime":1631068957,"is_pvip":false,"replies":[{"id":"112798","content":"学的很透","user_name":"作者回复","comment_id":311088,"uid":"1345199","ip_address":"","utype":1,"ctime":1631151169,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"9.2233720513707008e+18","product_id":100078401,"comment_content":"Linux内存管理之slab分配器分析：<br>前面分析过了大内存分配的实现机制，事实，上,若为小块内存而请求整个页面，这样对于内存来说是种极度的浪费。因此linux采用了slab来管理小块内存的分配与释放。<br>1:内核函数经常倾向于反复请求相同的数据类型。比如:创建进程时，会请求一块内存来存放mm结构。<br>2: 不同的结构使用不同的分配方法可以提高效率。同样，如果进程在撤消的时候，内核不把mm结构释放掉，而是存放到一个缓冲区里，以后若有请求mm存储空间的行为就可以直接从缓冲区中取得，而不需重新分配内存.<br>3:前面，伙伴系统频繁分配，释放内存会影响系统的效率，以此，可以把要释放到的内存放到缓冲区中，直至超过一-个阀值才把它释放至伙伴系统，这样可以在- -定程度.上缓减减伙伴系统的压力。<br>4:为了缓减“内碎片”的产生，通常可以把小内存块按照2的倍数组织在一起，这一点和伙伴系统类似，这就是为什么分配内存对象大小时要按照 Cache 行大小的倍数分配。<br><br><br>笔记：<br>本章内容可以细分为三个小节即：内存的初始化，内存的分配，内存的释放，其具体流程参考neohope的笔记，就不多赘述。<br>","like_count":3,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526469,"discussion_content":"学的很透","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631151169,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312107,"user_name":"沈畅","can_delete":false,"product_type":"c1","uid":1077953,"ip_address":"","ucode":"7404E41356B36B","user_header":"https://static001.geekbang.org/account/avatar/00/10/72/c1/59509397.jpg","comment_is_top":true,"comment_ctime":1631628227,"is_pvip":true,"replies":[{"id":"113148","content":"对头铁子","user_name":"作者回复","comment_id":312107,"uid":"1345199","ip_address":"","utype":1,"ctime":1631751763,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"9.223372042781399e+18","product_id":100078401,"comment_content":"建议大家先浏览文稿，理解数据结构以及整体的设计思路（作者画的数据结构图要了然于胸）。先把数据结构理顺，再细看代码就比较容易了。我一开始也是觉得比较难懂，确实变量和函数名缩写不是很好。但是只要理解文稿中概念，和数据结构对应上，不要陷入这些奇怪的命名，代码思路就清晰了。先不要扣细节，从框架到函数最后到细节。看完还是很有收获的。其实看多了，有些缩写也大概猜得出来。","like_count":2,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526865,"discussion_content":"对头铁子","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631751763,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":298601,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1624230844,"is_pvip":false,"replies":[{"id":"108321","content":"“文章要解决什么问题，思路是什么，为什么要这么解决”   文章中都有啊 ，页面分配都懂了， 这个应该很简单才对，有什么地方觉得很难的 ","user_name":"作者回复","comment_id":298601,"uid":"1345199","ip_address":"","utype":1,"ctime":1624238524,"user_name_real":"LMOS"}],"discussion_count":5,"race_medal":0,"score":"23099067324","product_id":100078401,"comment_content":"评论越来越少，证明能跟上的人也越来越少。<br>作为一个每节都评论，都思考的人，我也能感受到内容难度的加大，而且缺乏阅读方向，代码量越来越大，但是文章要解决什么问题，思路是什么，为什么要这么解决，为什么不用流程图画一下等等，都能改善专栏阅读的困难。<br><br>至于思考题，那就比较简单了，前面的小节也谈过cpu cache line的问题，总而言之分配内存对象大小按照cache行来分配根本原因在于合理利用cpu缓存。","like_count":5,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522184,"discussion_content":"“文章要解决什么问题，思路是什么，为什么要这么解决”   文章中都有啊 ，页面分配都懂了， 这个应该很简单才对，有什么地方觉得很难的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624238524,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1988156,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/56/3c/f9ff3ed8.jpg","nickname":"杨军","note":"","ucode":"AF881224E54C14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393804,"discussion_content":"太多的命名简写，代码可读性不好","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1631606241,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1200704,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","nickname":"pedro","note":"","ucode":"F40C839DDFD599","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379915,"discussion_content":"我在自勉，也在提醒大家，不要拘泥细节，宏观掌握才是当务之急","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1624243431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1200704,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","nickname":"pedro","note":"","ucode":"F40C839DDFD599","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379912,"discussion_content":"体系","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624242931,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2624649,"avatar":"https://static001.geekbang.org/account/avatar/00/28/0c/89/fde96d28.jpg","nickname":"杨","note":"","ucode":"969A0AA5A59522","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379910,"discussion_content":"有木有提高学习效率和理解文章的方法？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624241403,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":298626,"user_name":"朱熙","can_delete":false,"product_type":"c1","uid":1039029,"ip_address":"","ucode":"2B9E2B8645A844","user_header":"https://static001.geekbang.org/account/avatar/00/0f/da/b5/9d1f2f55.jpg","comment_is_top":false,"comment_ctime":1624242167,"is_pvip":false,"replies":[{"id":"108446","content":"对的 ","user_name":"作者回复","comment_id":298626,"uid":"1345199","ip_address":"","utype":1,"ctime":1624421949,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"18804111351","product_id":100078401,"comment_content":"感觉确实如pedro所说，能跟上的人越来越少，可能也和内核越来越深入有关系。<br>个人想法是不用纠结代码的每一行，更多的跟着注释体会代码整体流程，知道每块代码在做什么，如果有必要，再去看每行代码。<br>也希望将来能够每个模块与linux内核做一个比较，讲解下优缺点或者差异，让读者能够简单了解linux为了某些目的，增加了那些逻辑。","like_count":4,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522194,"discussion_content":"对的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624421949,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342688,"user_name":"艾恩凝","can_delete":false,"product_type":"c1","uid":2950704,"ip_address":"","ucode":"F2B81BF4F0106A","user_header":"https://static001.geekbang.org/account/avatar/00/2d/06/30/c26ea06a.jpg","comment_is_top":false,"comment_ctime":1650420404,"is_pvip":false,"replies":[{"id":"125988","content":"我要分享","user_name":"作者回复","comment_id":342688,"uid":"1345199","ip_address":"","utype":1,"ctime":1652067426,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"10240354996","product_id":100078401,"comment_content":"为啥不能理解细节代码，强迫症，整体流程明白了，深究代码，结束了之后，再画一遍流程图，加深印象，虽然慢倒也可以，对每个函数 函数参数 步骤 添加注释，笔记+流程图 ---&gt;https:&#47;&#47;aeneag.xyz&#47;virginOS  打卡","like_count":3,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571096,"discussion_content":"我要分享","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652067426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":302239,"user_name":"青玉白露","can_delete":false,"product_type":"c1","uid":2619436,"ip_address":"","ucode":"96FE2D4D2B94A0","user_header":"https://static001.geekbang.org/account/avatar/00/27/f8/2c/92969c48.jpg","comment_is_top":false,"comment_ctime":1626143597,"is_pvip":false,"replies":[{"id":"109362","content":"因为我搞了很多新的概念 ，那些新的概念你不懂 。也不需要懂，只要明白有什么作用就好了 ","user_name":"作者回复","comment_id":302239,"uid":"1345199","ip_address":"","utype":1,"ctime":1626170138,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"10216078189","product_id":100078401,"comment_content":"之所以分配内存大小要采用cache的倍数，主要是为了合理的使用CPU的缓存。<br>顺带一提，C语言的代码命名确实一个很大的问题，词不达意，很难理解一个函数到底是来干什么的，相比之下，这段时间学习的Java命名格式就显得好的多了，以后我自己写c语言代码的时候就需要借鉴java的命名方法。","like_count":2,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523236,"discussion_content":"因为我搞了很多新的概念 ，那些新的概念你不懂 。也不需要懂，只要明白有什么作用就好了 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626170138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328097,"user_name":"blackonion","can_delete":false,"product_type":"c1","uid":1395426,"ip_address":"","ucode":"E34B3704CE9055","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/E5icvvKzlGRD5trSibYvs5ZrhAvOib1UhyZV7ftYJLw1Jna1FWxpHBFlvK130DqArFVdXHh92GVWvSkckqxlibZAbg/132","comment_is_top":false,"comment_ctime":1640528733,"is_pvip":false,"replies":[{"id":"119660","content":"对的","user_name":"作者回复","comment_id":328097,"uid":"1345199","ip_address":"","utype":1,"ctime":1640768482,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"5935496029","product_id":100078401,"comment_content":"一开始瞄了一眼发现这节代码比较多，的确有点发怵，但看了评论，知道不抠名字这个细节比较好后，耐下心来看了一遍，基本还是能懂的。老师的图非常给力，行文的思路也清晰，注释也比较到位。看到半年过去了，老师还会回答新读者的提问，这种程度的用心真的让我感动~<br><br>用我自己的话总结一下这节内容吧。<br>为提高内存利用率，避免需要很少内容时分配一页，引入了内存对象。<br>一个结构含有一组内存对象，这个结构叫内存对象容器。<br>内存对象容器加上内存对象数组默认占据一页，如果不够的话可以申请新的页，用一个类似的结构管理扩展的内存对象。<br>一种内存对象容器对应一种特定大小的内存对象。<br>有个结构含有一组内存对象容器，姑且叫内存对象容器管理器。<br>初始化内存管理功能时，也有初始化内存对象容器管理器的数组。但内存对象是有需求才分配的。","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542497,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640768482,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312053,"user_name":"杨军","can_delete":false,"product_type":"c1","uid":1988156,"ip_address":"","ucode":"AF881224E54C14","user_header":"https://static001.geekbang.org/account/avatar/00/1e/56/3c/f9ff3ed8.jpg","comment_is_top":false,"comment_ctime":1631608519,"is_pvip":false,"replies":[{"id":"113150","content":"以后 看看吧","user_name":"作者回复","comment_id":312053,"uid":"1345199","ip_address":"","utype":1,"ctime":1631752403,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"5926575815","product_id":100078401,"comment_content":"老师能够简单补充写个数据结构、函数的命名规则文档吗？在看代码过程中看到一些名称实在不好理解，来回跳跃看数据结构定义、代码，实在是很不容易把把握整个代码的执行流程，把握不了整体的思路","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526845,"discussion_content":"以后 看看吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631752403,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":301826,"user_name":"xhy","can_delete":false,"product_type":"c1","uid":2688691,"ip_address":"","ucode":"5CED9F8C47F3D1","user_header":"https://static001.geekbang.org/account/avatar/00/29/06/b3/7cb8c071.jpg","comment_is_top":false,"comment_ctime":1625900546,"is_pvip":false,"replies":[{"id":"109572","content":"感谢你的反馈，小编来回应下。因为有些概念是老师自己设计的，比如 mf_olkty 就是 msadsc flags order  link type。但是我们又不知道order  link type是啥，这个是老师特别设计的属性，方便未来扩展用。所以，咱们学习重点就是知道各种设计的功能，而不是纠结名字哦。","user_name":"编辑回复","comment_id":301826,"uid":"1501385","ip_address":"","utype":2,"ctime":1626401101,"user_name_real":"赵宇新"}],"discussion_count":11,"race_medal":0,"score":"5920867842","product_id":100078401,"comment_content":"希望老师把这些数据结构简写的全英文名称写出来，否则看着这样的命名太难受了","like_count":1,"discussions":[{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523101,"discussion_content":"感谢你的反馈，小编来回应下。因为有些概念是老师自己设计的，比如 mf_olkty 就是 msadsc flags order  link type。但是我们又不知道order  link type是啥，这个是老师特别设计的属性，方便未来扩展用。所以，咱们学习重点就是知道各种设计的功能，而不是纠结名字哦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626401101,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1555050,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/6a/5a0bb648.jpg","nickname":"黄光华","note":"","ucode":"66865B43F2D132","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391720,"discussion_content":"像msadsc这种，我们都还能猜得出是什么单词拼在一次。\nmf_olkty 就是 msadsc flags order link type？？？这谁能猜得出呢。\n真的不是说我们纠结名字，而是项目中有巨量的“不明白意思又难记”的命名，我们真的很难理解的~\n","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1630591462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1988156,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/56/3c/f9ff3ed8.jpg","nickname":"杨军","note":"","ucode":"AF881224E54C14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1555050,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/6a/5a0bb648.jpg","nickname":"黄光华","note":"","ucode":"66865B43F2D132","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393814,"discussion_content":"巨量的“不明白意思又难记”的命名，心有戚戚焉","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1631609783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":391720,"ip_address":""},"score":393814,"extra":""}]},{"author":{"id":2406655,"avatar":"https://static001.geekbang.org/account/avatar/00/24/b8/ff/d327274b.jpg","nickname":"wtafting","note":"","ucode":"3690C222F23C30","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390937,"discussion_content":"不是说纠结名字为什么是它的问题，是类似的名字太多了，长得都很像，看代码的时候容易搞混了，建议有个可以有个文档说明，遇到一时记不起的类型名可以直接查是做什么用的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1630162353,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1954784,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/d4MHbXBwovYHW7xA18j88ibw1wS2R1JCoH5oLJIMUTdXe07dyVeTNWNzqWUKT7nPg21oClPhy1rSZPFiaibHeUFBA/132","nickname":"Geek_a5edac","note":"","ucode":"A47341B4DB9C8E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385711,"discussion_content":"强烈赞同，目前的命名实在太难理解了，很影响代码理解效率，有必要给个全称放到注释栏里","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1627221841,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2688691,"avatar":"https://static001.geekbang.org/account/avatar/00/29/06/b3/7cb8c071.jpg","nickname":"xhy","note":"","ucode":"5CED9F8C47F3D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384138,"discussion_content":"名字不清楚，是影响概念之间的联系的，例如msadsc是啥意思我就看不出来，很难理解","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1626401281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2175036,"avatar":"https://static001.geekbang.org/account/avatar/00/21/30/3c/398dca65.jpg","nickname":"AC_Saber","note":"","ucode":"37A238D34438F2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549351,"discussion_content":"同样很希望老师把这些命名的含义给出来方便理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643874659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2175036,"avatar":"https://static001.geekbang.org/account/avatar/00/21/30/3c/398dca65.jpg","nickname":"AC_Saber","note":"","ucode":"37A238D34438F2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549350,"discussion_content":"猜一下，msadsc：memory space address descriptor。?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643874565,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1927222,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/68/36/478194f3.jpg","nickname":"Shawn Duan","note":"","ucode":"628BAD6473FBCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404814,"discussion_content":"既然这么多人纠结命名，我也挑剔一下：&#34;msadsc flags order link type&#34; 可以写成 msdsc_flg_rd_lnk_tp， 虽然长了点，但可以看懂。以后也不需要文档了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634420903,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2677530,"avatar":"https://static001.geekbang.org/account/avatar/00/28/db/1a/52d1501f.jpg","nickname":"rain","note":"","ucode":"A2E81AB7C4274C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384836,"discussion_content":"数据结构、函数接口命名，建议把英语全程加到注释里面去","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626766610,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384168,"discussion_content":"msa: memory space address","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626409796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":298610,"user_name":"blentle","can_delete":false,"product_type":"c1","uid":1064679,"ip_address":"","ucode":"AC092609A4942A","user_header":"https://static001.geekbang.org/account/avatar/00/10/3e/e7/261711a5.jpg","comment_is_top":false,"comment_ctime":1624237228,"is_pvip":false,"replies":[{"id":"108447","content":"你好  是的 ","user_name":"作者回复","comment_id":298610,"uid":"1345199","ip_address":"","utype":1,"ctime":1624422009,"user_name_real":"LMOS"}],"discussion_count":7,"race_medal":0,"score":"5919204524","product_id":100078401,"comment_content":"提个建议，能否用有意义的名称来命名函数或变量，要不然函数调用关系看的云里雾里. <br>其实思考题在最开始的几篇提cpu三级缓存的时候已经提了，为了能有效的让缓存生效，提高缓存命中率. 不够的都用padding还是去拼接成缓存行的倍数","like_count":2,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522188,"discussion_content":"你好  是的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624422009,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2536364,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b3/ac/2c8baa5e.jpg","nickname":"Zhendicai","note":"","ucode":"6E1A8AE4C33CBE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379970,"discussion_content":"有些命名的确有点不好理解  如果能给出一些全称应该会更容易理解 主要是结构体中的成员比较多 容易看了后面忘了前面 不过好像也没什么办法 毕竟操作系统内核也不是什么简单的东西","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1624266420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2621994,"avatar":"https://static001.geekbang.org/account/avatar/00/28/02/2a/2b0018d3.jpg","nickname":"XF-薛峰","note":"","ucode":"046F1E06D5CBD8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383883,"discussion_content":"+1如果能注释下缩写的全称就太好了，英语不好没办法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626267207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":2621994,"avatar":"https://static001.geekbang.org/account/avatar/00/28/02/2a/2b0018d3.jpg","nickname":"XF-薛峰","note":"","ucode":"046F1E06D5CBD8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383887,"discussion_content":"有很多概念是老师自创的，所以不太容易望文生义，老师提示过多关注这些函数是干啥用的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626269448,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":383883,"ip_address":""},"score":383887,"extra":""}]},{"author":{"id":1474356,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI3F4IdQuDZrhN8ThibP85eCiaSWTYpTrcC6QB9EoAkw3IIj6otMibb1CgrS1uzITAnJmGLXQ2tgIkAQ/132","nickname":"cugphoenix","note":"","ucode":"80101AF04C00D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380211,"discussion_content":"+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624373808,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1060730,"avatar":"https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg","nickname":"相逢是缘","note":"","ucode":"CB299F53A95654","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379956,"discussion_content":"是的，缩写给个注释，是哪些单词缩写，看着会容易很多，现在全靠猜啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624261332,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2616028,"avatar":"https://static001.geekbang.org/account/avatar/00/27/ea/dc/aa699264.jpg","nickname":"宏典","note":"","ucode":"63953F36596C28","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379926,"discussion_content":"+1  建议给出结构体命名的全称，方便阅读。 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624247502,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351848,"user_name":"Ziggy_aa","can_delete":false,"product_type":"c1","uid":1140762,"ip_address":"","ucode":"B8921BF0C11DDC","user_header":"https://static001.geekbang.org/account/avatar/00/11/68/1a/d9a35bc7.jpg","comment_is_top":false,"comment_ctime":1658226973,"is_pvip":false,"replies":[{"id":"128026","content":"会的 这需要额外的机制来处理","user_name":"作者回复","comment_id":351848,"uid":"1345199","ip_address":"","utype":1,"ctime":1658373992,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1658226973","product_id":100078401,"comment_content":"一个提问。如果我没有读错代码，按照现在的销毁逻辑，如果但凡有一个内存对象在被使用，该容器就不会被销毁。但是，如果该容器已经分配了许多 extended 部分。那么那些部分占用的内存不会被释放。极端情况下是否会造成巨大的内存浪费？","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580788,"discussion_content":"会的 这需要额外的机制来处理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658373992,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":350139,"user_name":"卖薪沽酒","can_delete":false,"product_type":"c1","uid":2465726,"ip_address":"","ucode":"7F04A84EDBA856","user_header":"https://static001.geekbang.org/account/avatar/00/25/9f/be/14b2ad2e.jpg","comment_is_top":false,"comment_ctime":1656595420,"is_pvip":false,"replies":[{"id":"128064","content":"666666","user_name":"作者回复","comment_id":350139,"uid":"1345199","ip_address":"","utype":1,"ctime":1658390599,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1656595420","product_id":100078401,"comment_content":"慢慢来， 舒服了","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580857,"discussion_content":"666666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658390599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344857,"user_name":"飘在空中的鱼","can_delete":false,"product_type":"c1","uid":1138812,"ip_address":"","ucode":"D3B2C65A01061E","user_header":"https://static001.geekbang.org/account/avatar/00/11/60/7c/5afcb3ee.jpg","comment_is_top":false,"comment_ctime":1651825579,"is_pvip":false,"replies":[{"id":"125961","content":"哈哈 看注释","user_name":"作者回复","comment_id":344857,"uid":"1345199","ip_address":"","utype":1,"ctime":1652065452,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1651825579","product_id":100078401,"comment_content":"老师，这个变量名看得真是头疼啊","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571067,"discussion_content":"哈哈 看注释","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652065452,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":334360,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1644900008,"is_pvip":false,"replies":[{"id":"122176","content":"加油","user_name":"编辑回复","comment_id":334360,"uid":"1501385","ip_address":"","utype":2,"ctime":1644976644,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":4,"score":"1644900008","product_id":100078401,"comment_content":"都是大神","like_count":0,"discussions":[{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551286,"discussion_content":"加油","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644976644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":8}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327255,"user_name":"kocgockohgoh王裒","can_delete":false,"product_type":"c1","uid":2617112,"ip_address":"","ucode":"35EFABDE0D713D","user_header":"https://static001.geekbang.org/account/avatar/00/27/ef/18/6a620733.jpg","comment_is_top":false,"comment_ctime":1640014270,"is_pvip":false,"replies":[{"id":"119157","content":"phytovirt  是处理内核线性映射空间的地址","user_name":"作者回复","comment_id":327255,"uid":"1345199","ip_address":"","utype":1,"ctime":1640137276,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1640014270","product_id":100078401,"comment_content":"这里的内存管理返回的地址都是虚拟地址吧  那页表呢   phytovirt好像没用页表啊  有点糊涂了  能不能请点拨一下啊","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540685,"discussion_content":"phytovirt  是处理内核线性映射空间的地址","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640137277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":315228,"user_name":"Geek_34dba1","can_delete":false,"product_type":"c1","uid":2785652,"ip_address":"","ucode":"DA6F2A13191C15","user_header":"","comment_is_top":false,"comment_ctime":1633758991,"is_pvip":false,"replies":[{"id":"114253","content":"代码也不多啊","user_name":"作者回复","comment_id":315228,"uid":"1345199","ip_address":"","utype":1,"ctime":1633937819,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"1633758991","product_id":100078401,"comment_content":"不想让大家关注代码本身就少放一些代码，而是把实现的思路，过程用文字和图示勾勒出来","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527908,"discussion_content":"代码也不多啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633937819,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313361,"user_name":"paulpen","can_delete":false,"product_type":"c1","uid":2435832,"ip_address":"","ucode":"330B8F2787E232","user_header":"https://static001.geekbang.org/account/avatar/00/25/2a/f8/8d483f93.jpg","comment_is_top":false,"comment_ctime":1632389993,"is_pvip":false,"replies":[{"id":"113496","content":"加油，后面二刷就可以细看了，收获会更大。","user_name":"编辑回复","comment_id":313361,"uid":"1501385","ip_address":"","utype":2,"ctime":1632393674,"user_name_real":"赵宇新"}],"discussion_count":1,"race_medal":0,"score":"1632389993","product_id":100078401,"comment_content":"这是我第一遍看，遇见大段代码，就是简单把注释瞄一下，知道大概是干啥的，然后跳过，就怕迷失在代码细节中。","like_count":0,"discussions":[{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527326,"discussion_content":"加油，后面二刷就可以细看了，收获会更大。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632393674,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300006,"user_name":"Fan","can_delete":false,"product_type":"c1","uid":1115232,"ip_address":"","ucode":"3BF28670FD9407","user_header":"https://static001.geekbang.org/account/avatar/00/11/04/60/64d166b6.jpg","comment_is_top":false,"comment_ctime":1624952653,"is_pvip":false,"replies":[{"id":"108792","content":"哈哈 很困难吗","user_name":"作者回复","comment_id":300006,"uid":"1345199","ip_address":"","utype":1,"ctime":1624958448,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"1624952653","product_id":100078401,"comment_content":"打个卡，不容易呀。来到这里了。","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522612,"discussion_content":"哈哈 很困难吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624958448,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}